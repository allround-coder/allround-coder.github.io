{"pageProps":{"posts":[{"title":"Vite React에서 프록시 설정하기","description":"","date":"2024-05-12 20:13","slug":"2024-05-12-SetupProxyinViteReact","content":"\n\nVite React 애플리케이션에서는 다음이 제게 가장 잘 작동하는 방법입니다:\n\nvite.config.js 파일에서 proxy 옵션을 사용할 수 있습니다. proxy 옵션을 사용하면 개발 중에 특정 요청을 다른 서버로 리디렉션할 수 있습니다. 이는 예를 들어 프런트엔드 애플리케이션이 별도 서버에서 실행되는 백엔드 API와 통신해야 할 때 유용합니다.\n\nvite.config.js 파일 안에 proxy 옵션을 정의하세요:\n\n```js\n/// <reference types=\"vite/client\" />\n\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n      proxy: {\n        '/api': {\n          target: 'http://your-backend-api-server.com',\n          changeOrigin: true,\n          rewrite: (path) => path.replace(/^\\/api/, ''),\n        },\n      },\n    },\n});\n```\n\n\n\n이 예제에서는 /api로 시작하는 요청에 대한 프록시를 설정하고 있습니다. 이 패턴과 일치하는 모든 요청은 http://your-backend-api-server.com 으로 리디렉션됩니다.\n\n환경 변수에서 API URL을 가져오고 싶다면 다음과 같이 작성할 수 있습니다.\n\n```js\n/// <reference types=\"vite/client\" />\n\nimport { defineConfig, loadEnv } from 'vite';\nimport react from '@vitejs/plugin-react';\n\n// https://vitejs.dev/config/\nexport default ({ mode }) => {\n  process.env = { ...process.env, ...loadEnv(mode, process.cwd()) };\n  const config = {\n    plugins: [react()],\n    server: {\n      proxy: {\n        '/api': {\n          target: process.env.VITE_BASE_URL,\n          changeOrigin: true,\n          rewrite: (path) => path.replace(/^\\/api/, ''),\n        },\n      },\n    },\n  };\n  return defineConfig(config);\n};\n```\n\n여기서 VITE_BASE_URL이 API URL입니다.\n\n\n\n이 포스트가 마음에 드셨다면 아래의 하트를 클릭해주세요 :).","ogImage":{"url":"/assets/img/2024-05-12-SetupProxyinViteReact_0.png"},"coverImage":"/assets/img/2024-05-12-SetupProxyinViteReact_0.png","tag":["Tech"],"readingTime":2},{"title":"바퀴 다시 발명하기 - 목록 사용","description":"","date":"2024-05-12 20:09","slug":"2024-05-12-Re-inventingthewheelUselist","content":"\n\n이번 시리즈에서는 바퀴를 새롭게 발명해 보려 합니다. 맞아요, 사람들이 네게 하지 말라고 말했던 것을 정확히 하려고 하지만, 우리는 반항자들이야 😉.\n\n프로젝트 틀을 만들기 위해 단순한 pnpm monorepos를 만들었지만, 여러분은 자유롭게 설정을 사용할 수 있어요. 중요한 건 완벽하게 작동하는 리액트 프로젝트를 갖고 있다는 것이에요. 이 시리즈는 그것에 대해 이야기하는 것이 아니지만, 관심이 있다면 나와 같은 가이드를 따라 갈 수 있어요: https://dev.to/vinomanick/create-a-monorepo-using-pnpm-workspace-1ebn\n\n하지만 내 설정을 꼭 따르고 싶다면, 여기서 레포를 클론할 수 있어요: https://github.com/FrancoRATOVOSON/use-wheel\n\n# 소개\n\n\n\nReact 생태계의 방대한 풍경 가운데, 우리는 개발 업무를 간소화해 주겠다고 약속하는 다양한 라이브러리와 프레임워크로 여유롭게 나눠먹는다. 그러나 프로젝트가 복잡해지면서 우리는 종종 우리의 요구 사항을 초과하는 부품과 복잡한 시스템과 씨름해야 할 때가 많습니다.\n\n이러한 딜레마는 최근 사이드 프로젝트에 착수할 때 익숙한 일 중 하나였습니다. 여러 도구와 라이브러리를 만지작거리면서, 많은 요구 사항이 더 단순하고 집중된 해결책으로 충족될 수 있다는 것을 깨달았습니다. 그래서 이 시리즈 아이디어가 탄생했습니다 — 불필요한 것을 벗어내고 단숨함의 우아함을 받아들이는 기본으로 되돌아가는 여정입니다.\n\n그러나 이것은 그냥 대충 다시 만드는 것에 대한 이야기만이 아닙니다. 이것은 창조의 기쁨을 되찾고 체험을 통해 학습함으로써 배우는 것에 대한 새로운 가능성을 발견하는 것입니다. 복잡한 개념을 기본 구성 요소로 분해함으로써, 우리는 어떻게 일이 진행되는지에 대한 깊은 이해를 얻고 혁신을 위한 새로운 가능성을 발견할 수 있습니다.\n\n# 오늘 우리는 뭐 요리해볼까요?\n\n\n\n그러면 함께 이 여정을 시작해보죠. 리스트는 널리 사용되는 만큼 필수적인 요소이죠. 사용자를 표시하거나 제품을 전시하는 등 무수히 많은 응용 프로그램의 기초를 이룹니다. 이미 사용 중인 솔루션들인 useList와 @tastack/table(테이블과 더 관련이 있다는 건 알지만) 같은 솔루션들은 매력적인 기능을 제공하지만, 우리의 요구에 정확히 맞춘 것을 만들 수 있다면 어떨까요?\n\nReact에서 리스트 관리의 기술을 탐구하며, 가벼우면서 다목적으로 사용할 수 있는 효용성 있는 도구를 만들어보겠습니다. 이 시리즈가 끝날 때쯤, 단순함의 힘에 대한 새로운 인식과 개발 워크플로우를 향상시킬 실용적인 도구가 생길 것입니다.\n\n이 여정의 끝에 우리가 생산할 결과는 다음과 같습니다:\n\n# 요구 사항\n\n\n\n그래, 시작해봅시다! 우리의 야생 목록을 다룰 때 필수적인 기능들에 대한 체크리스트가 있어요:\n\n- 정렬 (Sorting): 지저분한 데이터 스택에서 탐색해 본 적이 있나요? 시간이 없어요! 목록을 정렬하고 혼돈을 조금이나마 정리할 방법이 필요해요.\n- 필터링 (Filtering): 정보 과부하와 이별을 외치죠! 불필요한 소음을 걸러내고 진정으로 중요한 것에 집중하고 싶어요.\n- 표시 (Pagination & Page Size): 끝없는 결과 페이지를 넘기며 보기? 그럴 필요 없어요! 소형 청크로 나누어 탐색을 쉽게 만들어 주세요.\n- 선택 (Selection): 때로는 선택해야 할 때가 있어요! 여러 항목을 선택하거나 특별 데이터에 집중해야 할 때, 일을 처리할 도구가 필요해요.\n\n이제 우리의 희망 목록이 완성되었으니, 옷 소매를 걷어 올리고 일하러 가봐요. 우리 신뢰할 수 있는 \"useList\" 유틸리티의 탄생이랍니다!\n\n```js\n// useList.ts\n\nexport function useList<T>(data: Array<T>) {\n  return {\n    list: data\n      .filter(() => true) // 필터링 로직을 위한 자리 표시자\n      .sort(() => 0)      // 정렬 로직을 위한 자리 표시자\n      .slice()            // 페이징 로직을 위한 자리 표시자\n  }\n}\n```\n\n\n\n여기서 우리가 보고 있는 것은 무엇일까요? 우리는 데이터 배열을 가져와서 \"list\" 속성을 포함하는 깔끔한 패키지를 반환하는 일반적인 함수를 만들었습니다. 이 속성은 우리의 원본 데이터 배열의 필터링, 정렬 및 잘린 버전을 보유하고 있습니다.\n\n하지만 기다려봐, 아직 끝난 게 아니에요! 당연히 기본 기능이 준비되었지만, 이제 진짜 로직을 뿌려야 할 때입니다. 우리는 정렬, 필터링, 페이지네이션 및 선택을 다루고 있어요. 그러니 생각의 모자를 쓰고, 이에 조금의 코딩 마법을 뿌려봐요. 이것은 상당히 흥미진진한 여정이 될 거에요! 🎩✨\n\n일단 쉬운 것부터 시작해봅시다.\n\n## 선택하기\n\n\n\n알겠어요, 친구들, 선택에 관한 이야기를 해볼 시간이에요! 우리 목록에서 항목을 선택할 때 몇 가지 옵션이 있어요:\n\n- 사용자 지정 고유 ID: 한 가지 옵션은 사용자에게 고유 ID를 각 요소에 제공하도록 요청하는 것이에요. 이렇게 하면 사용자가 선택을 식별하는 방법을 완전히 제어할 수 있어요.\n- 유연한 선택 메커니즘: 또 다른 방법은 사용자가 선택 프로세스가 작동하는 방식을 결정하도록 하는 것이에요. 그러면 사용자가 자신의 특정 요구 사항과 선호도에 맞게 조정할 수 있어요.\n\n하지만 또 다른 옵션이 있어요, 선택 메커니즘을 우리가 맡지만 사용자들이 각 요소를 식별하는 방법을 선택할 수 있게 할 거예요. 어떻게요? 바로 이런 멋진 작은 함수를 제공해서:\n\n```js\ntype UseListOptions<T, U> = {\n  getId: (element: T) => U\n}\n```\n\n\n\n이렇게 하면 사용자가 요소를 식별하는 자체 방법을 지정할 수 있어요. 제공된 데이터에 이미 고유한 ID가 있는 경우 훌륭해요! 그렇지 않은 경우, 함수를 사용자 정의하여 ID를 생성할 수 있어요.\n\n이제 구현에 대해 자세히 알아볼까요? 수행해야 할 일은 선택 목록과 선택을 켜고 끄는 함수를 추가하는 것 뿐이에요:\n\n```js\nexport function useList<T, U>(data: Array<T>, { getId }: UseListOptions<T, U>) {\n  const [selection, setSelection] = React.useState<Set<U>>(new Set([]))\n\n  const toogleSelection = React.useCallback(\n    (item: T, state?: boolean) =>\n      setSelection(currentSelection => {\n        const itemId = getId(item)\n        const selectionList = new Set(currentSelection)\n        if (state || !selectionList.has(itemId)) selectionList.add(itemId)\n        else selectionList.delete(itemId)\n        return new Set(selectionList)\n      }),\n    [getId]\n  )\n\n  return {\n    list: data\n      .filter(() => true)\n      .sort(() => 0)\n      .slice(),\n    selection,\n    toogleSelection\n  }\n}\n```\n\n뭔가 빠뜨린 게 있나요? 음, 네, 제공하지 않을 수 없는 기능을 잊었네요:\n\n\n\n```js\nconst toogleSelectionAll = React.useCallback(\n  (state?: boolean) =>\n    setSelection(currentSelection => {\n      if (state || currentSelection.size === 0)\n        return new Set(data.map(item => getId(item)))\n      const selectionList = new Set(currentSelection)\n      selectionList.clear()\n      return selectionList\n    }),\n  [data, getId]\n)\n```\n\n그리고 이로서 모든 것을 마쳤습니다. 그 다음 계획은 무엇인가요?\n\n## 정렬 및 필터링\n\n좋아요, 여러분, 이제 정렬과 필터링을 다루는 시간입니다! 그리고 놀랍게도 선택보다 더 쉽습니다. 사용자는 함수를 제공하고, 우리는 그저 마법을 부릅니다.\n\n\n\n위 코드를 업데이트해 봅시다:\n\n```js\ntype UseListOptions<T, U> = {\n  filterFn: (element: T) => boolean\n  getId: (element: T) => U\n  sortFn: (elementA: T, elementB: T) => number\n}\n\nexport function useList<T, U>(\n  data: Array<T>,\n  { filterFn, getId, sortFn }: UseListOptions<T, U>\n) {\n\n  ...\n\n  return {\n    list: data.filter(filterFn).sort(sortFn).slice(),\n    selection,\n    toggleSelection\n  }\n}\n```\n\n이제 궁금증이 생길 수 있어요. \"필터링과 정렬 순서는 중요할까요?\" 그 대답은 네요 — 주로 성능상의 이유로 중요합니다. 정렬이 시작되기 전에 배열 크기를 줄이기 위해 데이터를 먼저 필터링합니다. 그러나 slice 작업은 마지막에 옵니다. 페이지네이션을 위한 것이거든요. 우리는 표시된 항목을 기준으로 정렬 및 필터링 매개변수가 변경되더라도 일관성을 유지하기 위해 전체 데이터 집합에서 필터링 및 정렬합니다.\n\n하지만 여기서 멈추지 않겠어요! 나중에 우리는 최적화와 코드 청결성에 대해 더 탐구할 거에요.\n\n\n\n이러한 조정 사항을 고려하면 정렬 및 필터링 기능이 빛을 발할 준비가 되었어요! React에서 목록 관리의 멋진 세계로 더 깊이 파고들어가는 것을 기대해 주세요.\n\n## 페이지네이션\n\n자, 이제 파티 시작할 시간이에요 😎.\n\n페이지네이션은 간단해 보일 수 있지만, 믿어두세요, 눈에 보이는 것 이상의 것이 있어요. 먼저, 현재 위치(현재 페이지, 말하자면)를 추적하고 한 번에 표시할 항목 수(페이지 크기)를 파악하며 페이지 간에 전환할 수 있는 편리한 기능이 몇 가지 필요해요 (첫 번째, 이전, 다음, 마지막, 그리고 심지어 이동하기까지!).\n\n\n\n시작해봐요:\n\n```js\n유형 UseListOptions <T, U> = {\n  defaultPageSize: 숫자\n  ...\n}\n\nexport function useList <T, U> (\n  데이터 : 배열 <T>,\n  { defaultPageSize, filterFn, getId, sortFn }: UseListOptions <T, U>\n) {\n  const [pageSize, setPageSize] = React.useState <number> (defaultPageSize)\n  const [index, setIndex] = React.useState <number> (0)\n\n  ...\n\n  return {\n    list : 데이터\n      .filter (filterFn)\n      .sort (sortFn)\n      .slice (index, index + pageSize),\n    ...\n  }\n}\n```\n\n참 간단하죠? 이제 현재 페이지를 결정하는 문제부터 해결해 봅시다:\n\n```js\nexport function useList <T, U> (\n  데이터 : 배열 <T>,\n  { defaultPageSize, filterFn, getId, sortFn }: UseListOptions <T, U>\n) {\n  ...\n\n  const currentPage = React.useMemo (\n    () => index / pageSize + 1,\n    [index, pageSize]\n  )\n\n  return {\n    ...\n    currentPage,\n  }\n}\n```\n\n\n\n이건 꽤 쉬운데요, 현재 페이지는 현재 인덱스를 페이지 크기로 나눈 값에 1을 더하면 됩니다. 왜냐하면 페이지는 1부터 시작하기 때문이에요. 그런데 이 말은 인덱스가 항상 페이지 크기의 배수여야 한다는 가정을 하고 있죠. 그러나 이는 합리적입니다. 페이지를 변경할 때마다 인덱스에 페이지 크기를 더해주기 때문이에요.\n\n이제 페이지 간에 부드러운 탐색을 보장합시다:\n\n```js\nconst nextPage = React.useCallback(() => {\n  if (pageSize < data.length && index + pageSize < data.length)\n    setIndex(currentIndex => currentIndex + pageSize)\n}, [data.length, index, pageSize])\n```\n\n먼저, 아직 보여줄 데이터가 남아 있는 경우에만 nextPage로 이동할 수 있도록 합시다. 이를 위해 페이지 크기는 데이터의 길이보다 작아야 하고, 인덱스를 증가시켰을 때 그 값이 데이터 배열 내에 여전히 존재해야 합니다. 이런 논리를 따라가면, 인덱스는 항상 페이지 크기의 배수일 것이라는 것을 알 수 있습니다. 왜냐하면 0, 페이지 크기, 페이지 크기 + 페이지 크기, ... 와 같이 될 수 있거든. 그런데 만약 갑자기 페이지 크기를 변경한다면 어떻게 될까요? 우리가 첫 번째 페이지에 있는 동안에는 별 상관이 없겠지만, 리스트의 어딘가에 있는데 첫 페이지가 아닌 경우에는 현재 페이지와 표시해야 하는 내용을 다시 계산해야 할 것입니다.\n\n\n\n음 네, 먼저 네비게이션을 완성하고 나중에 여기로 돌아올까요?\n그래서, 이전, 첫 번째 그리고 마지막 페이지:\n\n```js\nconst previousPage = React.useCallback(() => {\n  if (pageSize < data.length && index - pageSize >= 0)\n    setIndex(currentIndex => currentIndex - pageSize)\n}, [data.length, index, pageSize])\n\nconst firstPage = React.useCallback(() => setIndex(0), [])\n\nconst lastPage = React.useCallback(() => {\n  if (pageSize < data.length && index + pageSize < data.length) {\n    const pageCount = Math.ceil(data.length / pageSize)\n    setIndex(pageSize * pageCount)\n  }\n}, [data.length, index, pageSize])\n```\n\n알아채셨나요? 우리는 또 다른 중요한 정보인 pageCount를 만들었어요. 우리도 그것을 반환해야겠네요.\n\n코드를 변경해봅시다:\n\n\n\n```js\nconst pageCount = React.useMemo(() => {\n  if (pageSize >= data.length) return 1\n  return Math.ceil(data.length / pageSize)\n}, [data.length, pageSize])\n\n...\n\nconst lastPage = React.useCallback(() => {\n  if (pageSize < data.length && index + pageSize < data.length)\n    setIndex(pageSize * (pageCount - 1))\n}, [data.length, index, pageCount, pageSize])\r\n```\n\n이제 setPageSize 구현 전에 보너스 기능을 추가해 봅시다:\n\n```js\nconst goToPage = React.useCallback(\n  (destinationPage: number) => {\n    if (destinationPage < pageCount)\n      setIndex(pageSize * (destinationPage - 1))\n  },\n  [pageCount, pageSize]\n)\n```\n\n보시다시피 lastPage와 거의 비슷합니다. 나중에 정리하도록 하겠습니다.\n\n\n\n## 페이지 크기 설정\n\n여기서 재미있는 부분이 나왔네요! 사용자가 페이지 크기를 변경하기로 결정하는 것은 보통 한 번에 더 많은 정보를 보고 싶어서입니다. 그러나 이미 여러 페이지를 탐색 중이라면, 현재 페이지 유지와 더 많은 요소 표시 중 어느 것에 우선순위를 두어야 할까요? 우리에게 완전히 달려 있지만, 사용자의 관점에서는 뷰 크기를 변경했기 때문에 이전에 발견한 정보를 잃는 것이 이상적이지 않습니다. 게다가, 현재 어떤 페이지에 있는지에 대해서는 관심조차 없을 수도 있습니다.\n\n현재 표시된 정보는 현재 인덱스와 현재 페이지 크기 사이에 있습니다. 따라서 사용자가 페이지 크기를 업데이트하면, 현재 인덱스를 조정하여 그 값에 페이지 크기를 추가하면 마지막 인덱스가 포함되도록 해야 합니다.\n\n그것을 하는 가장 쉬운 방법은 다음과 같습니다:\n\n\n\n```js\nconst setPageSize = React.useCallback(\n  (size: number) => {\n    setPageSizeState(size);\n    const newIndex = Math.floor(index / size) * size;\n    setIndex(newIndex);\n  },\n  [index]\n);\n```\n\n아시다시피, 이것은 내가 만들기 별로 어렵지 않아 보이는 것보다 더 쉬운 것 같아요 😛. 해결책의 단순함이 해결해야 할 문제의 복잡함을 숨기는 것이 아니기 때문이에요. 이제 코드를 설명해 볼게요:\n먼저, 페이지 크기를 새 페이지 크기로 설정해요. 간단하죠? 그런데 이제 어려운 부분이 나와요: 왜 Math.floor를 사용하는 걸까요? 그리고 여기서 정확히 무엇을 계산하고 있을까요?\n\n다음을 고려해 보세요: 표시된 어떤 요소든 index와 index + pageSize 사이에 위치해 있어요. 다시 말해:\n\n- 페이지 1의 요소는 0부터 pageSize 사이에 위치해요\n- 페이지 2의 요소는 pageSize부터 pageSize * 2 사이에 위치해요\n- 페이지 3의 요소는 pageSize * 2부터 pageSize * 3 사이에 위치해요\n- 계속해서 이어지죠...\n\n\n\n일반적으로, 페이지 n의 요소는 (pageSize * (n-1))과 (pageSize * n) 사이에 있습니다. 이 계산을 역으로 바꾸면, n이 항상 (i / pageSize) + 1 이하임을 알 수 있습니다. 하지만 왜 \"이상\"이 아닌 걸까요? 이 계산이 수학적으로 맞을 수 있지만, 중요한 점은 i가 0에서 시작하는 반면 페이지 인덱스는 1에서 시작한다는 것을 기억하는 것입니다. 현재 인덱스는 현재 페이지에 페이지 크기를 곱한 값이기 때문에 결과를 곱해서 올바른 인덱스를 찾습니다.\n\n휴! 수학적인 여정이 꽤 길었지만, 이러한 세세한 점을 이해하면 사용자가 어떻게 상호 작용하든 페이징 시스템이 원활하게 작동하도록 할 수 있습니다.\n\n# 테스트\n\n## 설정하기\n\n\n\n우리의 페이지네이션 시스템을 만들었으니, 이제 시험해보는 시간이에요! 사용자 주문 목록을 만들고, 날짜나 금액으로 정렬하거나, 이메일로 필터링하며, 주문 상태를 변경(배송됨 또는 아직 안됨)하는 기능 등을 탐험해볼 거에요. 데이터를 채우기 위해, 현실적인 테스트 데이터를 생성하는 유용한 도구인 faker.js를 사용할 거예요.\n\n먼저, 데이터를 생성하는 방법을 보겠어요:\n\n```js\n// 저는 생성한 사용자 목록을 가지고 있는 사용자 목록을 만들었어요.\n// 각 주문이 개별 사용자에 속하지 않도록 하기 위해, 이것은 검색 필터 기능을 위한 것이에요.\nfunction fakeUserList() {\n  const list: string[] = []\n  for (let index = 0; index < 10; index++) {\n    list.push(faker.internet.email())\n  }\n  return list\n}\n\nexport function fakeOrdersList() {\n  const userList = fakeUserList()\n  const list: Order[] = []\n  const dataSize = faker.number.int({ max: 100, min: 50 })\n  for (let index = 0; index < dataSize; index++) {\n    list.push({\n      amount: faker.number.int({ max: 500, min: 150 }),\n      date: faker.date.recent({ days: 100 }),\n      id: faker.string.uuid(),\n      isDelivered: faker.number.int({ max: 10, min: 0 }) % 2 === 0,\n      user: userList[faker.number.int({ max: userList.length - 1, min: 0 })]\n    })\n  }\n\n  return list\n}\n```\n\n이제, 부모 컴포넌트를 설정해봅시다:\n\n\n\n```js\nimport React from 'react'\n\nimport { OrderList } from '@/components/common'\nimport { fakeOrdersList } from '@/lib/faker'\n\nexport default function OrdersPage() {\n  const [orders, setOrders] = React.useState(fakeOrdersList())\n\n  const deleteOrders = React.useCallback(\n    (ids: string[]) =>\n      setOrders(list => list.filter(element => !ids.includes(element.id))),\n    []\n  )\n\n  return <OrderList deleteOrders={deleteOrders} list={orders} />\n}\n```\n\n그리고 리스트 컴포넌트 :\n\n```js\n// import문 생략...\n\ninterface OrderListProps {\n  deleteOrders: (ids: string[]) => void\n  list: Array<Order>\n}\n\nexport default function OderList({ deleteOrders, list: data }: OrderListProps) {\n  const [search, setSearch] = React.useState<string>('')\n  const [sort, setSort] = React.useState<'asc' | 'desc' | null>(null)\n  const {\n    currentPage,\n    firstPage,\n    lastPage,\n    list,\n    nextPage,\n    pageCount,\n    pageSize,\n    previousPage,\n    selection,\n    setPageSize,\n    toogleSelection,\n    toogleSelectionAll\n  } = useList(data, {\n    defaultPageSize: 5,\n    filterFn: order => {\n      if (search) return order.user.toLowerCase().includes(search.toLowerCase())\n      return true\n    },\n    getId: elt => elt.id,\n    sortFn: (a, b) => {\n      if (!sort) return 0\n      if (sort === 'asc') return a.amount - b.amount\n      return b.amount - a.amount\n    }\n  })\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between gap-2 items-center\">\n        <div className=\"flex justify-start items-center gap-2\">\n          <div className=\"relative ml-auto flex-1 md:grow-0\">\n            <Search className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n            <Input\n              className=\"w-full rounded-lg bg-background pl-9 md:w-[200px] lg:w-[336px]\"\n              placeholder=\"검색...\"\n              type=\"search\"\n              onChange={e => setSearch(e.target.value)}\n            />\n          </div>\n          <div>\n            <DropdownMenu>\n              <DropdownMenuTrigger asChild>\n                <Button variant=\"outline\">\n                  {sort === 'asc' ? (\n                    <>\n                      <ArrowUpNarrowWide className=\"size-4 mr-4\" />\n                      오름차순\n                    </>\n                  ) : sort === 'desc' ? (\n                    <>\n                      <ArrowDownNarrowWide className=\"size-4 mr-4\" />\n                      내림차순\n                    </>\n                  ) : (\n                    <>\n                      <ArrowUpDown className=\"size-4 mr-4\" />\n                      정렬\n                    </>\n                  )}\n                </Button>\n              </DropdownMenuTrigger>\n              <DropdownMenuContent className=\"w-28 h-fit p-2 bg-background border rounded-md mt-2\">\n                <DropdownMenuRadioGroup\n                  value={sort || undefined}\n                  onValueChange={value => setSort(value as 'asc' | 'desc')}\n                >\n                  <DropdownMenuRadioItem className=\"cursor-pointer\" value=\"asc\">\n                    오름차순\n                  </DropdownMenuRadioItem>\n                  <DropdownMenuRadioItem\n                    className=\"cursor-pointer\"\n                    value=\"desc\"\n                  >\n                    내림차순\n                  </DropdownMenuRadioItem>\n                </DropdownMenuRadioGroup>\n              </DropdownMenuContent>\n            </DropdownMenu>\n          </div>\n          {search && (\n            <div>{`${data.filter(order => order.user.toLowerCase().includes(search.toLowerCase())).length} 결과`}</div>\n          )}\n        </div>\n        <div className=\"flex justify-end gap-2 items-center\">\n          <div className=\"text-muted-foreground text-nowrap\">페이지당 표시 행 수</div>\n          <Select\n            value={`${pageSize}`}\n            onValueChange={value => setPageSize(Number(value))}\n          >\n            <SelectTrigger className=\"w-16\">\n              <SelectValue placeholder={`${pageSize}`} />\n            </SelectTrigger>\n            <SelectContent side=\"bottom\">\n              {[5, 10, 15, 20, 30, 50].map(size => (\n                <SelectItem key={`pageSize-${size}`} value={`${size}`}>\n                  {size}\n                </SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n        </div>\n      </div>\n      <div className=\"space-y-4\">\n        {list.map(order => {\n          const { amount, date, id, isDelivered, user } = order\n          return (\n            <Card\n              className={cn('p-4', 'flex items-center justify-between')}\n              key={id}\n            >\n              <div className=\"flex item-center gap-2\">\n                <div className=\"size-9 grid content-center ml-2\">\n                  <Checkbox\n                    checked={selection.has(id)}\n                    id={user}\n                    onCheckedChange={state =>\n                      toogleSelection(\n                        order,\n                        typeof state === 'string' ? false : state\n                      )\n                    }\n                  />\n                </div>\n                <label\n                  className={cn(\n                    'flex flex-col gap-1',\n                    'font-medium leading-none',\n                    'cursor-pointer'\n                  )}\n                  htmlFor={user}\n                >\n                  <span className=\"font-semibold\">{user}</span>\n                  <span className=\"text-sm text-muted-foreground\">\n                    {format(date, 'PPP')}\n                  </span>\n                </label>\n                <div>{isDelivered && <Badge>배송완료</Badge>}</div>\n              </div>\n              <div>{`${amount} $`}</div>\n            </Card>\n          )\n        })}\n      </div>\n      <div className=\"flex justify-between items-center\">\n        <div className=\"flex justify-start items-center gap-4\">\n          <div className=\"flex flex-col gap-0\">\n            <div className=\"flex gap-2 justify-start items-center\">\n              <Checkbox\n                checked={selection.size > 0}\n                id=\"all-users-selection\"\n                onCheckedChange={state =>\n                  toogleSelectionAll(typeof state === 'string' ? false : state)\n                }\n              />\n              <label\n                className=\"text-muted-foreground cursor-pointer\"\n                htmlFor=\"all-users-selection\"\n              >\n                {selection.size > 0 ? `모두 선택 해제` : `모두 선택`}\n              </label>\n            </div>\n            {data && (\n              <p>{`${selection.size} 중 ${data.length} 사용자 선택됨.`}</p>\n            )}\n          </div>\n          {selection.size > 0 && (\n            <Button\n              variant=\"destructive\"\n              onClick={() => deleteOrders(Array.from(selection))}\n            >\n              선택된 사용자 삭제\n            </Button>\n          )}\n        </div>\n        <div className={cn('flex justify-start items-center gap-2')}>\n          <Button\n            disabled={currentPage === 0}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={firstPage}\n          >\n            <DoubleArrowLeftIcon className=\"size-4\" />\n          </Button>\n          <Button\n            disabled={currentPage === 0}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={previousPage}\n          >\n            <ChevronLeftIcon className=\"size-4\" />\n          </Button>\n          <div className=\"text-muted-foreground\">\n            {`페이지 ${currentPage} / 총 ${pageCount} 페이지`}\n          </div>\n          <Button\n            disabled={currentPage >= pageCount}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={nextPage}\n          >\n            <ChevronRightIcon className=\"size-4\" />\n          </Button>\n          <Button\n            disabled={currentPage >= pageCount}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={lastPage}\n          >\n            <DoubleArrowRightIcon className=\"size-4\" />\n          </Button>\n        </div>\n      </div>\n    </div>\n  )\n}\n```\n\n\n\n## 기다리지 말고, 한번 시도해봅시다\n\n우리 예시를 테스트해보러 바로 들어가봅시다! 처음 눈에 보이는 대로 모든 것이 원활히 작동해야 합니다. 몇 가지 요소를 선택해보고, 모두 선택 해제하기, 모두 선택하기, 오름차순 및 내림차순으로 정렬하기, 페이지 크기 변경하기, 페이지를 통해 이동하기를 시도해보세요. 예! 모든 것이 잘 진행되지만, 검색할 때까지요.\n\n[이미지](/assets/img/2024-05-12-Re-inventingthewheelUselist_0.png)\n\n어떤 문제를 발견하셨나요? 화면에 표시된 요소는 9개만 있어야 합니다. 이것은 페이지 2가 4개의 요소만 포함해야 한다는 것을 의미합니다 (실제로 그렇지만), 그리고 마지막 페이지여야 합니다. 그러나 그렇지 않습니다. 요소를 필터링할 때, 페이지네이션 로직이 목록의 현재 상태에 따라 따르지 않습니다. 그 결과, 다른 페이지로 이동하면 아무것도 나타나지 않게 됩니다.\n\n\n\n지금, 이러한 오류를 수정하고 코드를 정리해 봅시다:\n\n# 마지막 스프린트\n\n## 우선, 문제를 해결하세요\n\n해결책은 놀랍게도 간단합니다:\n\n\n\n```js\nexport function useList<T, U>(\n  dataList: Array<T>,\n  { defaultPageSize, filterFn, getId, sortFn }: UseListOptions<T, U>\n) {\n  const data = React.useMemo(\n    () => dataList.filter(filterFn ?? (() => true)),\n    [dataList, filterFn]\n  )\n  ...\n}\n```\n\n지금은 많은 것을 이름을 다시 지을 필요가 없어요. 우리는 간단히 페이지네이션 및 선택과 같은 다른 기능들을, 필터된 목록을 기반으로 합니다.\n이제 예제를 다시 실행하고 변경 사항을 관찰해 보세요:\n\n![Re-inventing the wheel: UseList](/assets/img/2024-05-12-Re-inventingthewheelUselist_1.png)\n\n심지어 모두 선택을 시도해 볼 수 있고, 필터된 결과만 선택됨을 알 수 있을 거예요. 그러나 모든 선택된 값을 삭제하면, \"모두 선택\" 확인란이 여전히 선택된 채로 남겨진다는 것을 알 수 있을 거예요. 이는 데이터가 변경될 때 선택 목록을 업데이트하지 않기 때문입니다.\n이러한 문제를 해결해 봅시다:\n\n\n\n```js\nexport function useList<T, U>(\n  dataList: Array<T>,\n  { defaultPageSize, filterFn, getId, sortFn }: UseListOptions<T, U>\n) {\n  ...\n\n  React.useEffect(() => {\n    setSelection(new Set([]))\n  }, [dataList.length])\n\n  ...\n}\n```\n\n각 렌더링마다 원본 데이터의 길이가 변경되면 선택 목록을 지웁니다.\n\n네, 우리의 훅은 실제로 더 확장되고 복잡해지고 있습니다. 이제 코드를 정리해봅시다.\n(네, 알겠어요. 여전히 깔끔한 코드에 대해서는 이야기를 못하고 있는데 말이죠! 🙄)\n\n## 정리하기\n\n\n\n먼저, 각 기능을 자신만의 함수로 분리해 봅시다. 선택 기능부터 시작해 보겠습니다. 선택에 대한 파일을 만들고 다음 코드를 붙여 넣어주세요:\n\n```js\nexport function useListSelection<T, U>(\n  data: Array<T>,\n  getId: (element: T) => U\n) {\n  const [selection, setSelection] = React.useState<Set<U>>(new Set([]))\n\n  React.useEffect(() => {\n    setSelection(new Set([]))\n  }, [data.length])\n\n  const toogleSelection = React.useCallback(\n    (item: T, state?: boolean) =>\n      setSelection(currentSelection => {\n        const itemId = getId(item)\n        const selectionList = new Set(currentSelection)\n        if (state || !selectionList.has(itemId)) selectionList.add(itemId)\n        else selectionList.delete(itemId)\n        return new Set(selectionList)\n      }),\n    [getId]\n  )\n\n  const toogleSelectionAll = React.useCallback(\n    (state?: boolean) =>\n      setSelection(currentSelection => {\n        if (state || currentSelection.size === 0)\n          return new Set(data.map(item => getId(item)))\n        const selectionList = new Set(currentSelection)\n        selectionList.clear()\n        return selectionList\n      }),\n    [data, getId]\n  )\n\n  return { selection, toogleSelection, toogleSelectionAll }\n}\n```\n\n이제 페이징에 대해 해결해 봅시다. 파일을 만들고 아래 코드를 붙여 넣어주세요:\n\n```js\nexport function useListPagination<T>(data: Array<T>, defaultPageSize: number) {\n  const [pageSize, setPageSizeState] = React.useState<number>(defaultPageSize)\n  const [index, setIndex] = React.useState<number>(0)\n\n  const currentPage = React.useMemo(\n    () => index / pageSize + 1,\n    [index, pageSize]\n  )\n\n  const pageCount = React.useMemo(() => {\n    if (pageSize >= data.length) return 1\n    return Math.ceil(data.length / pageSize)\n  }, [data.length, pageSize])\n\n  const nextPage = React.useCallback(() => {\n    if (pageSize < data.length && index + pageSize < data.length)\n      setIndex(currentIndex => currentIndex + pageSize)\n  }, [data.length, index, pageSize])\n\n  const previousPage = React.useCallback(() => {\n    if (pageSize < data.length && index - pageSize >= 0)\n      setIndex(currentIndex => currentIndex - pageSize)\n  }, [data.length, index, pageSize])\n\n  const firstPage = React.useCallback(() => setIndex(0), [])\n\n  const lastPage = React.useCallback(() => {\n    if (pageSize < data.length && index + pageSize < data.length)\n      setIndex(pageSize * (pageCount - 1))\n  }, [data.length, index, pageCount, pageSize])\n\n  const goToPage = React.useCallback(\n    (destinationPage: number) => {\n      if (destinationPage < pageCount)\n        setIndex(pageSize * (destinationPage - 1))\n    },\n    [pageCount, pageSize]\n  )\n\n  const setPageSize = React.useCallback(\n    (size: number) => {\n      setPageSizeState(size)\n      const newIndex = Math.floor(index / size) * size\n      setIndex(newIndex)\n    },\n    [index]\n  )\n\n  return {\n    currentPage,\n    firstPage,\n    goToPage,\n    index,\n    lastPage,\n    nextPage,\n    pageCount,\n    pageSize,\n    previousPage,\n    setPageSize\n  }\n}\n```\n\n\n\n그렇죠, 여전히 꽤 크지만 삶이 그런 거에요. 항상 원하는 대로 되는 것은 아니죠. 🤷🏾‍♂️.\n자, 이제 메인 후크를 업데이트해 봅시다:\n\n```js\nexport function useList<T, U>(\n  dataList: Array<T>,\n  { defaultPageSize, filterFn, getId, sortFn }: UseListOptions<T, U>\n) {\n  const data = React.useMemo(\n    () => dataList.filter(filterFn ?? (() => true)),\n    [dataList, filterFn]\n  )\n\n  const selection = useListSelection(data, getId)\n  const { index, pageSize, ...pagination } = useListPagination(\n    data,\n    defaultPageSize\n  )\n\n  const list = React.useMemo(\n    () => [...data].sort(sortFn).slice(index, index + pageSize),\n    [data, index, pageSize, sortFn]\n  )\n\n  return {\n    list,\n    pageSize,\n    ...pagination,\n    ...selection\n  }\n}\n```\n\n\"모두 선택\" 확인란이 데이터 크기가 변경될 때(예: 삭제 시) 또는 필터링할 때 선택 취소됩니다. 이는 선택을 지우기 위해 사용하는 useEffect가 필터링된 데이터에 기반하고 있기 때문입니다. 사용자가 적용하는 검색 또는 필터와 관계없이 선택을 유지할지 또는 현재 동작을 유지할지 결정할 수 있습니다.\n\n현재 동작을 유지하면 선택은 후크에서 반환한 데이터를 기반으로 하지만, 기존 동작은 최종 사용자가 보기를 결정한 데이터 내용이 아닌 데이터에서 작동할 수 있어 예측할 수 없는 동작을 초래할 수 있습니다. 사용자 경험(UX)과 보안을 위해 현재 구현이 더 나은 선택입니다. 하지만, 여전히 확신이 들지 않는다면, 선택 후크에서 useEffect를 제거하고 그것을 useList 함수로 이동시키고, 의존성을 dataList.length로 변경해보세요.\n\n\n\n# 최종 기능\n\n이제 최종 고려 사항은 사용자가 사용하려는 기능을 선택할 수 있는 유연성을 제공하는 것입니다. 사용자가 항상 정렬, 필터링 또는 선택 기능이 필요한 것은 아닐 수 있습니다. 따라서 이러한 기능을 선택 사항으로 허용해야 합니다. 구현 내용을 자세히 살펴보겠습니다.\n\n일부 새로운 아이디어: 사용자가 사용하려는 각 기능에 대해 값을 제공해야 합니다. 예를 들어, 페이지네이션에는 defaultPageSize, 필터링에는 filterFn, 정렬에는 sortFn, 선택 기능에는 getId를 제공해야 합니다. 사용자가 매개변수에 값을 제공하지 않으면 해당 기능이 비활성화됩니다. getId 함수를 제공하지 않고도 액세스하려고 할 경우에도 기능을 사용할 수 있습니다.\n\n이제 당신은 « 네, 그런데 모든 것이 선택 사항이라면, 사용자가 빈 객체를 제공하면 어떻게 되나요? »라고 할 것이고, 저는 그들이 그냥 멍청한 것이라고 말할 것이지만 그것은 아무 문제가 되지 않을 것입니다 😜. 걱정하지 마세요, TypeScript가 우리를 돕기 위해 여기 있습니다. 사용자로부터 최소한 하나의 매개변수를 제공 받기 위해 유틸리티 타입을 생성해야 합니다. 여기에 결과입니다:\n\n\n\n```js\r\ntype AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> & U[keyof U]\n\ntype UseListOptions<T, U> = {\n  defaultPageSize: number\n  filterFn: (element: T) => boolean\n  getId: (element: T) => U\n  sortFn: (elementA: T, elementB: T) => number\n}\n\ntype UseListParamsType<T, U> = AtLeastOne<UseListOptions<T, U>>\r\n```\n\n이제 UseListParamsType을 훅의 두 번째 매개변수 유형으로 사용하고 완료!\n\n예제 코드의 오류를 수정하는 시간입니다 (일부 매개변수를 제거해서 어떻게 되는지도 시도해보세요):\n\n```js\r\nreturn (\n  <div className=\"space-y-4\">\n    <div className=\"flex justify-between gap-2 items-center\">\n      <div className=\"flex justify-start items-center gap-2\">\n        <div className=\"relative ml-auto flex-1 md:grow-0\">\n          <Search className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n          <Input\n            className=\"w-full rounded-lg bg-background pl-9 md:w-[200px] lg:w-[336px]\"\n            placeholder=\"Search...\"\n            type=\"search\"\n            onChange={e => setSearch(e.target.value)}\n          />\n        </div>\n        <div>\n          <DropdownMenu>\n            <DropdownMenuTrigger asChild>\n              <Button variant=\"outline\">\n                {sort === 'asc' ? (\n                  <>\n                    <ArrowUpNarrowWide className=\"size-4 mr-4\" />\n                    Asc\n                  </>\n                ) : sort === 'desc' ? (\n                  <>\n                    <ArrowDownNarrowWide className=\"size-4 mr-4\" />\n                    Desc\n                  </>\n                ) : (\n                  <>\n                    <ArrowUpDown className=\"size-4 mr-4\" />\n                    Sort\n                  </>\n                )}\n              </Button>\n            </DropdownMenuTrigger>\n            <DropdownMenuContent className=\"w-28 h-fit p-2 bg-background border rounded-md mt-2\">\n              <DropdownMenuRadioGroup\n                value={sort || undefined}\n                onValueChange={value => setSort(value as 'asc' | 'desc')}\n              >\n                <DropdownMenuRadioItem className=\"cursor-pointer\" value=\"asc\">\n                  Asc\n                </DropdownMenuRadioItem>\n                <DropdownMenuRadioItem\n                  className=\"cursor-pointer\"\n                  value=\"desc\"\n                >\n                  Desc\n                </DropdownMenuRadioItem>\n              </DropdownMenuRadioGroup>\n            </DropdownMenuContent>\n          </DropdownMenu>\n        </div>\n        {search && (\n          <div>{`${data.filter(order => order.user.toLowerCase().includes(search.toLowerCase())).length} results`}</div>\n        )}\n      </div>\n      {pageSize && setPageSize && (\n        <div className=\"flex justify-end gap-2 items-center\">\n          <div className=\"text-muted-foreground text-nowrap\">\n            Rows per page\n          </div>\n          <Select\n            value={`${pageSize}`}\n            onValueChange={value => setPageSize?.(Number(value))}\n          >\n            <SelectTrigger className=\"w-16\">\n              <SelectValue placeholder={`${pageSize}`} />\n            </SelectTrigger>\n            <SelectContent side=\"bottom\">\n              {[5, 10, 15, 20, 30, 50].map(size => (\n                <SelectItem key={`pageSize-${size}`} value={`${size}`}>\n                  {size}\n                </SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n        </div>\n      )}\n    </div>\n    <div className=\"space-y-4\">\n      {list.map(order => {\n        const { amount, date, id, isDelivered, user } = order\n        return (\n          <Card\n            className={cn('p-4', 'flex items-center justify-between')}\n            key={id}\n          >\n            <div className=\"flex item-center gap-2\">\n              {selection && toogleSelection && (\n                <div className=\"size-9 grid content-center ml-2\">\n                  <Checkbox\n                    checked={selection.has(id)}\n                    id={user}\n                    onCheckedChange={state =>\n                      toogleSelection(\n                        order,\n                        typeof state === 'string' ? false : state\n                      )\n                    }\n                  />\n                </div>\n              )}\n              <label\n                className={cn(\n                  'flex flex-col gap-1',\n                  'font-medium leading-none',\n                  'cursor-pointer'\n                )}\n                htmlFor={user}\n              >\n                <span className=\"font-semibold\">{user}</span>\n                <span className=\"text-sm text-muted-foreground\">\n                  {format(date, 'PPP')}\n                </span>\n              </label>\n              <div>{isDelivered && <Badge>delivered</Badge>}</div>\n            </div>\n            <div>{`${amount} $`}</div>\n          </Card>\n        )\n      })}\n    </div>\n    <div className=\"flex justify-between items-center\">\n      {selection && (\n        <div className=\"flex justify-start items-center gap-4\">\n          <div className=\"flex flex-col gap-0\">\n            <div className=\"flex gap-2 justify-start items-center\">\n              {toogleSelectionAll && (\n                <Checkbox\n                  checked={selection.size > 0}\n                  id=\"all-users-selection\"\n                  onCheckedChange={state =>\n                    toogleSelectionAll(\n                      typeof state === 'string' ? false : state\n                    )\n                  }\n                />\n              )}\n              <label\n                className=\"text-muted-foreground cursor-pointer\"\n                htmlFor=\"all-users-selection\"\n              >\n                {selection.size > 0 ? `Unselect all` : `Select all`}\n              </label>\n            </div>\n            {data && (\n              <p>{`${selection.size} of ${data.length} user(s) selected.`}</p>\n            )}\n          </div>\n          {selection.size > 0 && (\n            <Button\n              variant=\"destructive\"\n              onClick={() => deleteOrders(Array.from(selection))}\n            >\n              Delete selected users\n            </Button>\n          )}\n        </div>\n      )}\n      {currentPage && pageCount && (\n        <div className={cn('flex justify-start items-center gap-2')}>\n          <Button\n            disabled={currentPage === 0}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={firstPage}\n          >\n            <DoubleArrowLeftIcon className=\"size-4\" />\n          </Button>\n          <Button\n            disabled={currentPage === 0}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={previousPage}\n          >\n            <ChevronLeftIcon className=\"size-4\" />\n          </Button>\n          <div className=\"text-muted-foreground\">\n            {`Page ${currentPage} of ${pageCount}`}\n          </div>\n          <Button\n            disabled={currentPage >= pageCount}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={nextPage}\n          >\n            <ChevronRightIcon className=\"size-4\" />\n          </Button>\n          <Button\n            disabled={currentPage >= pageCount}\n            size=\"icon\"\n            variant=\"outline\"\n            onClick={lastPage}\n          >\n            <DoubleArrowRightIcon className=\"size-4\" />\n          </Button>\n        </div>\n      )}\n    </div>\n  </div>\n)\r\n```\n\n\n\n# 결론\n\n긴 여정이죠? 깊게 숨 쉬세요, 우리는 막 시작했어요. 이 시리즈에서는 리액트 애플리케이션에서 보통 사용하는 몇 가지 유용한 도구들을 새롭게 구현해 볼 거예요.","ogImage":{"url":"/assets/img/2024-05-12-Re-inventingthewheelUselist_0.png"},"coverImage":"/assets/img/2024-05-12-Re-inventingthewheelUselist_0.png","tag":["Tech"],"readingTime":33},{"title":"React-router를 사용하여 네비게이션 바 만들기","description":"","date":"2024-05-12 20:08","slug":"2024-05-12-Creatingnavbarusingreact-router","content":"\n\n안녕하세요 여러분! 어떻게 하고 계신가요?\n\n여기서는 React 라우팅 모듈을 사용하여 React 네비게이션 바를 설정하는 방법에 대해 자세히 알아보겠습니다. 이 방법 외에도 다른 방법들이 있지만, 저는 이 방법을 선호합니다. 보다 간결하고 오류를 방지할 수 있기 때문이죠. 단계별로 진행해보겠습니다.\n\n단계1\n\n먼저 다음 명령어를 사용하여 React 앱을 설정할 것입니다:\n\n\n\n여기에는 시스템에 최신 노드 버전이 설치되어 있어야 합니다.\n\n단계 2\n\n앱의 src 디렉터리 내에 컴포넌트 폴더를 만들고 다음과 같이 네비게이션 바에 표시할 세 개의 컴포넌트를 만드십시오.\n\n![Creatingnavbarusingreact-router](/assets/img/2024-05-12-Creatingnavbarusingreact-router_0.png)\n\n\n\n### 단계 3:\n\n이제 리액트 라우터 라이브러리를 설치할 것입니다.\n\n리액트 라우터는 리액트에서 경로 지정을 위한 표준 라이브러리입니다. 리액트 애플리케이션의 다양한 컴포넌트 뷰 간의 이동을 활성화하며, 브라우저 URL을 변경 가능하게 하고 UI가 URL과 동기화되도록 합니다.\n\n기억해야 할 한 가지는 버전이 `6.3여야 한다는 것입니다. 이전 버전은 이 프로젝트에서 사용할 일부 자식 컴포넌트를 지원하지 않습니다.\n\n\n\n![이미지](/assets/img/2024-05-12-Creatingnavbarusingreact-router_1.png)\n\n### 단계 4\n\n다음으로 할 일은 index.js에서 react-router-dom에서 BrowserRouter를 import하는 것입니다. 그런 다음, 우리가 만들어진 앱을 browserRouter로 감싸줄 것입니다. 우리의 index.js 파일은 다음과 같이 보일 것입니다:\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { BrowserRouter } from 'react-router-dom';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <App />\n    </BrowserRouter>\n  </React.StrictMode>\n);\nreportWebVitals();\n```\n\n\n\n5단계\n\n이제 네비게이션 바 페이지를 만들어봅시다. 먼저, React Router DOM에서 Link 컴포넌트를 가져와야 합니다. Link는 다른 경로로의 링크를 생성하고 애플리케이션에서 탐색을 구현하는 데 사용됩니다. 네비게이션 바의 앵커 태그 역할을 하는데, 'to'를 사용하여 경로를 정의합니다('to'는 href와 유사합니다). 우리의 네비게이션 바는 다음과 같이 보여야 합니다:\n\n```js\nimport React from 'react';\nimport {Link} from 'react-router-dom';\n\nconst Navbar=()=>{\n    return (    \n                <div className='navBar'>\n                    <div className='stocks'>\n                        <Link to=\"/\">Stocks</Link>\n                    </div>\n                    <div className='favourites'>\n                        <Link to=\"/favourites\">Favourite</Link>\n                    </div>\n                    <div className='cart'>\n                        <Link to=\"/cart\">Cart</Link>\n                    </div>\n                </div>\n    )\n\n}\n\nexport default Navbar;\n```\n\n6단계\n\n\n\napp.js로 이동하여 react-router-dom에서 Route 및 routes 컴포넌트를 가져옵니다. Routes 컴포넌트에는 모든 경로가 포함되어 있고, route는 선택할 수있는 개별 경로를 정의합니다. 우리의 app.js는 이렇게 보일 것입니다:\n\n```js\nimport './App.css';\nimport { Route, Routes } from 'react-router-dom';\nimport Navbar from './components/navbar';\nimport Stocks from './components/stocks';\nimport Favourites from './components/favourites';\nimport Cart from './components/cart';\n\nfunction App() {\n  return (\n   <>\n    <Navbar/>\n      <div>\n    <Routes>        \n      <Route path=\"/\"  element={<Stocks/>} />\n      <Route path=\"/favourites\"  element={<Favourites />}/>\n      <Route path=\"/cart\"  element={<Cart/>}/>\n    </Routes>\n    </div>\n    </>\n   \n  );\n}\n\nexport default App;\n```\n\n그런 다음 우리는 일치하는 경로를 사용하여 element로 컴포넌트를 정의합니다.\n\n우와!!! 우리의 네비게이션 바가 사용할 준비가 되었습니다. 전체 코드는 GitHub에서 확인할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-Creatingnavbarusingreact-router_0.png"},"coverImage":"/assets/img/2024-05-12-Creatingnavbarusingreact-router_0.png","tag":["Tech"],"readingTime":3},{"title":"Reactjs에서 Yup 라이브러리를 사용하여 양식 유효성 검사를 만드는 방법","description":"","date":"2024-05-12 20:07","slug":"2024-05-12-HowtocreateformvalidationwithYuplibraryinReactjs","content":"\n\n폼 유효성 검사는 모든 웹 애플리케이션의 중요한 부분입니다. 사용자가 입력한 데이터가 올바르고 완전한지 확인하는 데 도움이 됩니다. Yup은 Reactjs의 인기있는 유효성 검사 라이브러리로, 폼 유효성을 쉽게 만들고 관리할 수 있습니다.\n\n![Yup 라이브러리를 사용하여 어떻게 Reactjs에서 폼 유효성을 만들 수 있는지](/assets/img/2024-05-12-HowtocreateformvalidationwithYuplibraryinReactjs_0.png)\n\nYup을 사용하려면 먼저 npm을 사용하여 설치해야 합니다: npm install yup\n\nYup을 설치한 후에는 유효성 검사 스키마를 작성할 수 있습니다. 유효성 검사 스키마는 폼의 데이터를 유효성 검사하는 규칙을 정의하는 객체입니다.\n\n\n\n예를 들어, 다음 스키마는 사용자 이름과 비밀번호를 유효성 검사합니다:\n\n```js\nconst schema = Yup.object().shape({\n  username: Yup.string().required(),\n  password: Yup.string().required().minLength(8),\n});\n```\n\nrequired() 규칙은 필드가 필수임을 나타냅니다. minLength() 규칙은 필드가 적어도 8자여야 함을 나타냅니다.\n\n그런 다음 validate() 메서드를 사용하여 폼 데이터를 유효성 검사할 수 있습니다.\n\n\n\n```js\nconst formData = {\n  username: \"user123\",\n  password: \"password123\",\n};\n\nconst errors = schema.validate(formData);\n\nif (errors.length > 0) {\n  // 폼 데이터에 오류가 있습니다\n} else {\n  // 폼 데이터가 유효합니다\n}\n```\n\n만일 폼 데이터가 유효하지 않을 경우, errors 객체는 오류 메시지의 배열을 포함하게 됩니다.\n\nYup은 email(), url(), number() 등 다양한 다른 유효성 검사 규칙도 제공합니다. Yup 문서에서 사용 가능한 유효성 검사 규칙의 전체 목록을 찾을 수 있습니다.\n\n다음은 사용자가 새 계정을 만들 수 있는 폼을 유효성 검사하기 위해 Yup을 사용하는 예시입니다:\n\n\n\n\n```js\nconst schema = Yup.object().shape({\n  username: Yup.string().required().minLength(3).maxLength(25),\n  email: Yup.string().email().required(),\n  password: Yup.string().required().minLength(8).maxLenght(25),\n});\n\nconst handleSubmit = (e) => {\n  e.preventDefault();\n\n  const formData = {\n    username: e.target.username.value,\n    email: e.target.email.value,\n    password: e.target.password.value,\n  };\n\n  const errors = schema.validate(formData);\n\n  if (errors.length > 0) {\n    // 양식 데이터에 오류가 있음\n    alert(errors.join(\"\\n\"));\n  } else {\n    // 양식 데이터가 유효함, 처리할 작업 수행\n  }\n};\n\nconst App = () => {\n  return (\n    <form onSubmit={handleSubmit}>\n      <input type=\"text\" name=\"username\" placeholder=\"사용자 이름\" />\n      <input type=\"email\" name=\"email\" placeholder=\"이메일\" />\n      <input type=\"password\" name=\"password\" placeholder=\"비밀번호\" />\n      <button type=\"submit\">계정 생성</button>\n    </form>\n  );\n};\n```\n\n이 예시는 사용자가 제출 버튼을 클릭할 때 onSubmit 이벤트 핸들러를 사용하여 양식 데이터를 유효성 검사합니다. 양식 데이터가 유효하면 코드는 해당 데이터를 처리합니다. 그렇지 않으면 오류 메시지가 표시됩니다.\n","ogImage":{"url":"/assets/img/2024-05-12-HowtocreateformvalidationwithYuplibraryinReactjs_0.png"},"coverImage":"/assets/img/2024-05-12-HowtocreateformvalidationwithYuplibraryinReactjs_0.png","tag":["Tech"],"readingTime":3},{"title":"Nextjs에서 이미지 로딩을 흐릿하게 만들기","description":"","date":"2024-05-12 20:06","slug":"2024-05-12-MakeYourImageLoadingBlurryinNextjs","content":"\n\n웹 이미지는 사이트 성능 측면에서 중요하며 솔직히 말하자면 번거로운 부분이기도 합니다. Next.js의 최고의 기능 중 하나는 이미지 컴포넌트로, 이미지를 최적화해 줍니다. 이 컴포넌트는 화면 크기에 맞춰 WebP와 같은 현대적인 포맷의 이미지를 자동으로 생성하여 이미지 크기를 줄여줍니다. 또한 이미지가 뷰포트에 진입할 때 이미지를 불러오는 lazy loading과 레이아웃 이동을 방지하는 시각적 안정성이 구현되어 있습니다. 만약 이미지 컴포넌트에 익숙하지 않다면 Lee Robinson의 이 비디오를 추천합니다. 이 글에서는 실제 이미지가 로드되는 동안 흐린 이미지를 추가하는 것에 초점을 맞추고자 합니다.\n\n## 이미지 컴포넌트의 기본 이미지 흐림\n\n이미지 컴포넌트에는 한 가지 제한이 있지만, 기본 옵션으로 이미지를 흐리게 만들어 줄 수도 있습니다! 제 포트폴리오 웹사이트에서 한 예시를 보여드리겠습니다.\n\n기본 로딩보다 훨씬 나아요. 앞서 언급한 대로 한 가지 제한이 있습니다: 이미지를 정적으로 가져와야 합니다. 특히 이미지 동적 또는 클라우드 서비스를 사용하는 경우에는 이미지를 정적으로 가져오는 것이 불가능할 수 있습니다. 이 제한을 다음 기술에서 극복하겠지만, 지금은 이 기본 흐린 이미지를 가능하게 하는 코드를 살펴보도록 하죠.\n\n\n\n```js\nimport furkanpicture from \"@/public/pics/furkan.png\";\nimport Image from \"next/image\";\nimport React from \"react\";\n\nexport default function AboutImage() {\n  return (\n    <figure>\n      <Image\n        src={furkanpicture}\n        alt={\"Furkan Cengiz\"}\n        placeholder=\"blur\" //기본값은 \"empty\"입니다\n      />\n    </figure>\n  );\n}\n```\n\nplaceholder prop을 blur로 전달하고 src prop을 정적으로 가져온 이미지 개체로 전달할 때 Image 컴포넌트는 비디오에서 보는 것처럼 흐린 이미지를 생성합니다! 정적 페이지나 웹사이트를 구축 중이라면 기본적인 블러 동작을 활용할 수 있습니다!\n\n## Plaiceholder를 사용하여 dataURL 생성하기\n\n정적 이미지를 사용하는 경우 로딩 상태에 대한 흐린 이미지를 추가할 수 있습니다. 이제 이전 방법의 한계를 극복해야 합니다.\n\n\n\n\n문서에 따르면 동적 이미지를 위해 Image 컴포넌트의 blurDataUrl 속성에 dataURL을 전달해야 합니다. dataURL은 기본적으로 base64 형식으로 흐린 이미지 데이터를 보유하는 문자열입니다.\n\n```js\ndataURL 예시\ndata:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAYAAAB/qH1jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAJ0lEQVR4nGPY2fXjv458/H9Bbtf/IDbD/7v//8/Mvfq/J+nEfxAbAF3NFsFiuaE1AAAAAElFTkSuQmCC\n```\n\n우리는 이제 무엇이 필요한지 알았지만, 이렇게 데이터URL을 생성하는 방법이 무엇인지 궁금할 것입니다. 문서에서 제안한대로, plaiceholder는 이를 가능하게 해줍니다!\n\n우선, sharp와 plaiceholder 두 가지 패키지를 설치해야 합니다. 설치 방법은 이 페이지를 참고해주세요.\n\n\n\nNext.js를 사용하고 있다고 가정합니다. 다음 페이지를 따라서 next.config.ts 또는 next.config.mjs 파일을 구성해 주세요.\n\n설치가 완료되었습니다! 이제 서버 측에서 실행되는 사용자 정의 함수를 구현해야 합니다. 이 함수는 우리가 필요한 데이터URL을 생성합니다.\n\n```js\nimport fs from \"node:fs/promises\";\nimport { getPlaiceholder } from \"plaiceholder\";\n\nexport const getBase64 = async (imgPath: string) => {\n  try {\n    const file = await fs.readFile(`public/${imgPath}`)\n    const { base64 } = await getPlaiceholder(file)\n    return base64\n  } catch (error: unknown) {\n    // 에러 처리\n    if (error instanceof Error) return error.message\n    else if (error && typeof error === \"object\" && \"message\" in error)\n      return error.message as string\n    else if (typeof error === \"string\") return error;\n    else return \"예기치 않은 오류 발생!\"\n  }\n}\n```\n\n저는 문서에서처럼 then 또는 catch 메서드 대신 async-await 키워드를 사용하여 구현했습니다. getPlaiceholder 함수가 필요한 파일을 읽어야 합니다. 파일 경로에 \"public\" 접두사를 추가했습니다. 그런 다음 파일을 getPlaiceholder 함수에 전달했습니다. 이 함수는 css, color, pixels, base64 등과 같은 여러 객체를 반환합니다. 반환된 객체를 비구조화하여 base64 값을 추출하고 반환하세요!\n\n\n\n필요한 데이터URL을 생성하는 함수가 완성되었습니다. 이제 중요한 마지막 단계가 나왔어요!\n\n## getBase64 함수 사용하기\n\n함수에서 node:fs/promises를 가져오는 함수를 통해 파일을 읽었음을 알 수 있어요. 이는 이 함수가 노드 환경에서만 실행될 수 있다는 뜻이에요. 그러므로, 클라이언트 구성 요소에서 이 함수를 사용할 수는 없다는 점을 명심하는 것이 중요해요. 그치만 걱정할 필요는 아직 없어요. 왜냐하면 서버 구성 요소는 있거든요. 클라이언트 구성 요소에서 이 함수를 사용할 수 없더라도, 여전히 서버 구성 요소에서 이 async 함수를 호출하고 반환된 값을 클라이언트 구성 요소로 전달할 수 있어요.\n\n저의 포트폴리오 프로젝트에서 예제를 확인할 수 있어요. (이미 서버 구성 요소에서 이미지 구성 요소를 사용 중이라면, 이 마지막 단계는 필요하지 않아요. 클라이언트 구성 요소에 base64 문자열을 blurDataUrl 속성에 전달하려면 단순히 구성 요소를 async로 만들고 함수를 호출하면 됩니다.)\n\n\n\n위의 코드에서 여러 개의 base64 문자열을 생성하고 각각의 클라이언트 컴포넌트로 전달하고 있어요. (개별 이미지의 경로 문자열을 getBase64 함수에 전달하고 기다리면 단일 base64 문자열을 생성할 수 있어요)\n\n그래서 지금 우리는 흐린 이미지를 준비했어요!\n\n\n\n마지막으로, 플레이스홀더를 사용하여 SVG 및 색상과 같은 다른 기술을 활용할 수 있습니다. 그 외에도 시도해 볼 수 있는 기술이 많으니 플레이스홀더의 데모를 방문해 모든 기술을 확인해보세요.\n\n로딩 상태에서 흐릿한 이미지는 정말 좋아하는 기술입니다. 많은 웹사이트와 심지어 Discord와 같은 Windows 애플리케이션이 사용하는 기술인데, 우아함의 요소를 더해준다고 생각합니다. 이 기사가 도움이 되었으면 좋겠어요. 제 최신 작업 소식을 받아보려면 Medium이나 LinkedIn에서 팔로우해주세요. 다음 글에서 뵙길 기대하겠습니다!","ogImage":{"url":"/assets/img/2024-05-12-MakeYourImageLoadingBlurryinNextjs_0.png"},"coverImage":"/assets/img/2024-05-12-MakeYourImageLoadingBlurryinNextjs_0.png","tag":["Tech"],"readingTime":4},{"title":"리덕스-퍼시스트로 React 앱의 상태 유지하기","description":"","date":"2024-05-12 20:05","slug":"2024-05-12-PersistingStateinYourReactAppwithRedux-Persist","content":"\n\n프런트엔드 개발 세계에서 React는 주요한 역할을 하는 기술로 떠올랐어요. 컴포넌트 기반 아키텍처와 가상 DOM을 통해 사용자 인터페이스를 구축하는 데 강력한 도구로 작용해요. React 애플리케이션의 상태를 관리할 때 Redux는 예측 가능성과 디버깅의 용이성으로 인해 인기 있는 선택지에요. 그렇다면 Redux 상태를 페이지 새로고침이나 앱 재시작에 걸쳐 유지하려면 어떻게 해야 할까요? 이때 \"redux-persist\"가 등장해요.\n\nRedux-persist는 Redux와 완벽하게 통합되어 애플리케이션의 상태를 유지하도록 돕는 라이브러리에요. 이 글에서는 실용적인 코드 조각을 활용해 React 앱에서 redux-persist를 사용하는 방법을 살펴볼 거예요.\n\n# 상태 유지의 필요성\n\nredux-persist에 대해 자세히 알아보기 전에 React 애플리케이션에서 상태 유지가 필요한 이유를 이해하는 것이 중요해요. 대부분의 경우, 애플리케이션의 상태는 메모리에 저장되며 페이지를 새로고침하거나 앱을 닫았다가 다시 열 때 재설정돼요. 일부 애플리케이션에서는 이러한 동작이 수용 가능할 수 있지만, 사용자가 페이지를 떠나거나 새로고침한 후에도 사용자 데이터, 설정 또는 세션 정보를 저장하고 로드해야 하는 경우도 많아요.\n\n\n\n리덕스-퍼시스트는 이 문제에 간편한 해결책을 제공합니다. 이를 통해 Redux 스토어의 상태를 로컬 스토리지나 AsyncStorage(React Native 애플리케이션의 경우)와 같은 영구 저장 매체에 저장한 다음 앱을 로드할 때 해당 상태로 스토어를 재생성할 수 있습니다.\n\n이제 여러분의 리액트 애플리케이션에 이를 구현하는 방법을 살펴보겠습니다.\n\n# 시작하기\n\n먼저, 리액트 프로젝트에 리덕스가 설정되어 있는지 확인하세요. 아직 설정하지 않았다면 Redux를 설치하고 애플리케이션을 위한 스토어를 만들어야 합니다. 이번 시연을 위해 이미 준비된 리덕스 스토어가 있다고 가정하겠습니다.\n\n\n\n다음으로 redux-persist 라이브러리를 설치해야 합니다. npm 또는 yarn을 사용하여 다음과 같이 설치할 수 있습니다:\n\n```js\nnpm install redux-persist\n# 또는\nyarn add redux-persist\n```\n\n이제 redux-persist를 설치했으므로 Redux 스토어와 함께 작동하도록 구성할 수 있습니다.\n\n# 구성\n\n\n\n당신의 Redux 스토어 구성 파일에서 redux-persist로부터 persistReducer를 import하여 상태의 원하는 부분을 지속적으로 저장하도록 구성하세요. 어떤 리듀서와 그 리듀서의 어떤 속성을 지속적으로 저장할지 선택할 수 있습니다.\n\n```js\n// store.js\nimport { createStore } from 'redux';\nimport { persistStore, persistReducer } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage'; // 사용할 저장 엔진 선택\nimport rootReducer from './reducers'; // 루트 리듀서 import\nconst persistConfig = {\n  key: 'root',\n  storage,\n  // 지속적으로 저장하려는 리듀서 지정\n  whitelist: ['user'], // 이 예시에서는 'user' 리듀서를 지속적으로 저장합니다\n};\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\nexport const store = createStore(persistedReducer);\nexport const persistor = persistStore(store);\n```\n\n이 예시에서는 redux-persist를 사용하여 `user` 리듀서를 지속적으로 저장하도록 구성했지만, 이를 애플리케이션의 요구에 맞게 사용자 정의할 수 있습니다.\n\n# 앱 감싸기\n\n\n\n이제 Redux 스토어를 redux-persist로 구성했으니, redux-persist에서 제공하는 PersistGate 컴포넌트로 앱을 감싸야 합니다. 이 컴포넌트는 영속 상태가 검색되기 전에 앱이 렌더링되도록 보장합니다.\n\n```js\n// index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { PersistGate } from 'redux-persist/integration/react'; // PersistGate 가져오기\nimport { store, persistor } from './store';\nimport App from './App';\nReactDOM.render(\n  <Provider store={store}>\n    <PersistGate loading={null} persistor={persistor}>\n      <App />\n    </PersistGate>\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\n# 사용법\n\nredux-persist가 설정된 상태에서는 React 컴포넌트에서 Redux를 평소처럼 사용할 수 있습니다. persistConfig에서 지정한 모든 상태는 자동으로 지속될 것이며 다시 수분화될 것입니다.\n\n\n\n```js\n// userReducer.js\nconst initialState = {\n  username: '',\n  email: '',\n  // ... other user-related properties\n};\nconst userReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'SET_USERNAME':\n      return {\n        ...state,\n        username: action.payload,\n      };\n    case 'SET_EMAIL':\n      return {\n        ...state,\n        email: action.payload,\n      };\n    // ... other reducer cases\n    default:\n      return state;\n  }\n};\nexport default userReducer;\n```\n\n위 예에서 'user' 리듀서에 대한 모든 변경 사항은 앱이 다시 시작되거나 페이지가 새로고침될 때 자동으로 유지되고 다시로드됩니다.\n\n# 결론\n\nRedux-persist는 React 애플리케이션의 상태 지속성을 제공하여 애플리케이션을 강화하는 강력한 라이브러리입니다. 이는 사용자가 로그인해야 하는 애플리케이션이나 사용자 선호 설정 및 세션 데이터를 저장하려는 애플리케이션에 매우 유용할 수 있습니다.\n\n\n\n\n이 문서에 설명된 단계를 따라 하면 Redux를 사용하는 React 애플리케이션에 redux-persist를 쉽게 통합할 수 있습니다. 이를 통해 사용자들이 세션 및 페이지 새로고침 간에 데이터 지속성을 즐길 수 있게 되어, 더 견고하고 사용자 친화적인 애플리케이션을 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-PersistingStateinYourReactAppwithRedux-Persist_0.png"},"coverImage":"/assets/img/2024-05-12-PersistingStateinYourReactAppwithRedux-Persist_0.png","tag":["Tech"],"readingTime":4},{"title":"NPMRC 파일이란 무엇인가요","description":"","date":"2024-05-12 20:05","slug":"2024-05-12-Whatisanpmrcfile","content":"\n\n.npmrc 파일은 npm(Node Package Manager) 명령행 도구에서 사용되는 구성 파일입니다. 이 파일을 통해 npm이 패키지 및 의존성을 관리하는 방식과 관련된 다양한 설정을 사용자 정의할 수 있습니다. 이 파일은 일반적으로 프로젝트의 루트 디렉토리에 위치하며 다양한 구성 옵션을 포함할 수 있습니다. 아래는 .npmrc 파일에 설정할 수 있는 일반적인 사용 사례 및 구성 옵션입니다:\n\n- 레지스트리 구성: .npmrc 파일을 사용하여 npm이 패키지를 가져올 레지스트리를 지정할 수 있습니다. 예를 들어, 프라이빗 레지스트리나 기본 레지스트리의 미러를 사용하고 싶을 수 있습니다.\n- 스코프 패키지 구성: 스코프 패키지(이름이 @scope/로 시작하는 패키지)를 사용하는 경우 해당 패키지에 특정한 구성 옵션을 설정할 수 있습니다.\n- 인증: .npmrc 파일을 사용하여 프라이빗 레지스트리나 서비스의 인증 토큰 또는 자격 증명을 저장할 수 있습니다.\n- 프록시 구성: 회사 프록시 뒤에서 작업하는 경우 .npmrc 파일에 프록시 관련 옵션을 설정하여 npm이 프록시를 통해 작동하도록 할 수 있습니다.\n- 캐시 제어: .npmrc 파일에 캐시 관련 설정을 지정하여 npm이 패키지를 캐시하는 방식을 제어할 수 있습니다.\n- 글로벌 대 로컬 구성: 글로벌 및 로컬 설정에 대해 서로 다른 .npmrc 파일을 가질 수 있습니다. 글로벌 설정은 시스템의 모든 프로젝트에 적용되고, 로컬 설정은 프로젝트 디렉토리에만 특정합니다.\n- 패키지 설치 동작: npm install을 실행할 때 npm이 패키지를 기본적으로 dependencies 또는 devDependencies로 저장하도록 구성할 수 있습니다. 또한 npm이 패키지를 자동으로 package.json 파일에 저장할지 여부를 제어할 수도 있습니다.\n\n다음은 간단한 .npmrc 파일이 어떻게 보일 수 있는지 예제입니다:\n\n```js\nregistry=https://registry.npmjs.org/\nloglevel=warn\nsave-exact=true\n```\n\n\n\n이 예시에서, 이 파일은 기본 레지스트리를 npm 공개 레지스트리로 설정하고, 로그 레벨을 “warn\"으로 설정하며, npm이 패키지의 정확한 버전을 저장하도록 구성합니다.\n\n.npmrc 파일에 설정한 일부 옵션은 npm을 사용할 때 명령행 인수에 의해 재정의될 수 있습니다. npm 문서에서 설정 옵션의 포괄적인 목록을 찾을 수 있습니다.\n\n.npmrc 파일은 종종 코드와 함께 버전 관리 시스템에 저장되므로 인증 토큰과 같은 중요한 정보를 조심스럽게 다루어야 합니다. 중요한 정보를 관리하기 위해 환경 변수나 다른 안전한 방법을 사용하는 것을 고려해야 합니다.","ogImage":{"url":"/assets/img/2024-05-12-Whatisanpmrcfile_0.png"},"coverImage":"/assets/img/2024-05-12-Whatisanpmrcfile_0.png","tag":["Tech"],"readingTime":2},{"title":"NextJS 인증 플로우  JWT를 쿠키에 저장하기","description":"","date":"2024-05-12 20:04","slug":"2024-05-12-NextJSAuthenticationFlowStoreJWTInCookie","content":"\n\n나는 NextJS 앱 라우터를 프론트엔드로, NestJS를 백엔드로 활용한 사이드 프로젝트에 참여하고 있어. JWT와 쿠키를 사용해서 장기간에 걸쳐 인증 플로우를 구축 중이야. 여기에서는 내가 사용 중인 인증 플로우를 공유할 거야.\n\n# 왜 LocalStorage나 SessionStorage 대신 쿠키를 사용하나요?\n\nLocalStorage/SessionStorage에 저장된 항목은 JavaScript에서 읽을 수 있어 XSS 공격에 취약할 수 있어. 그래서 나는 JavaScript에서 접근할 수 없는 HttpOnly 쿠키를 사용해 액세스 토큰을 저장하기로 결정했어. 즉, 공격자들은 쿠키에서 액세스 토큰을 읽을 수 없다는 뜻이야.\n\n# 인증 플로우\n\n\n\n\n![이미지](/assets/img/2024-05-12-NextJSAuthenticationFlowStoreJWTInCookie_0.png)\n\n![이미지](/assets/img/2024-05-12-NextJSAuthenticationFlowStoreJWTInCookie_1.png)\n\n# 로그인\n\n## NextJS\n\n\n\n로그인 라우트 핸들러를 실행하세요.\n\nLoginButton.tsx\n\n```js\n    const loginRes = await fetch(\"/api/login\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify(YOUR_LOGIN_CREDENTIAL),\n    });\n```\n\n## NextJS 라우트 핸들러\n\n\n\n여기가 엑세스 토큰을 설정해야 하는 곳입니다.\n\napp/api/login/route.ts\n\n```js\n...\nexport async function POST(request: NextRequest) {\n  const loginRes = await axios.post(\n    \"MY_BACKEND_URL/api/login\",\n    {...}\n  );\n\n  cookies().set(\"accessToken\", loginRes.data.accessToken, {\n    httpOnly: true,\n    maxAge: 24 * 60 * 60,\n    sameSite: \"strict\"\n  });\n  \n  return NextResponse.json(loginRes.data, { status: 201 });\n}\n```\n\n## Axios\n\n\n\n쿠키가 SameSite=Strict로 설정되어 있으면, 다른 도메인에서 요청이 발생했을 때 서버로 자동으로 전송되지 않습니다. 백엔드로 보낼 때 jwt를 수동으로 쿠키로 설정하고 싶을 수 있습니다. 그렇지 않으면 백엔드는 쿠키가 어디에 있는지 모릅니다. 따라서, Axios 인터셉터를 사용하여 요청 헤더에 쿠키를 첨부합니다.\n\n```js\nimport { cookies } from \"next/headers\";\n\nexport const getCookie = async (name: string) => {\n  return cookies().get(name)?.value ?? \"\";\n};\n\ninstance.interceptors.request.use(async function (config) {\n  const accessToken = await getCookie(\"accessToken\");\n  // 인증에서 쿠키를 설정할 수 있습니다\n  // 백엔드에서 accessToken을 읽으려면 어떻게 하고 싶은지에 따라 다릅니다\n  config.headers.Cookie = `accessToken=${accessToken}`;\n  return config;\n});\n```\n\n## NestJS\n\nJWT를 생성하고 API 응답에 포함시켜 반환합니다.\n\n\n\n```js\n...\n@Injectable()\nexport class AuthService {\n  constructor(\n    private jwtService: JwtService,\n  ) {}\n\n  async login(token: string) {\n    try {\n      ...\n      const userPayload = {\n        sub: sub,\n        username: name,\n        email: email,\n        _id: user._id,\n      };\n      const accessToken = await this.jwtService.signAsync(userPayload);\n\n      return { accessToken };\n    } catch (e) {\n      console.log(e);\n    }\n  }\n}\n```\n\n# 로그아웃\n\n## NextJS\n\n\n\n\n로그아웃 라우트 핸들러를 실행합니다\n\n```js\n  const logout = async () => {\n    await fetch(\"/api/logout\", {\n      method: \"POST\",\n    });\n  };\n```\n\n## NextJS 라우트 핸들러\n\n쿠키를 삭제합니다.\n\n\n\n```js\n...\nimport { cookies } from \"next/headers\";\n\nexport async function POST(request: NextRequest) {\n  cookies().delete(\"accessToken\");\n  return NextResponse.json({ status: 201 });\n}\n```\n\n# 결론\n\n프로젝트에 대한 최종 인증 흐름이 아마 이것은 아닐 것입니다. 여전히 더 나은 구현 방법(예: Refresh Token 흐름 구현 등)을 찾고 있습니다. 읽어 주셔서 감사합니다.\n\n# 간단하게 설명하면 🚀\n\n\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우해주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠 확인해보세요","ogImage":{"url":"/assets/img/2024-05-12-NextJSAuthenticationFlowStoreJWTInCookie_0.png"},"coverImage":"/assets/img/2024-05-12-NextJSAuthenticationFlowStoreJWTInCookie_0.png","tag":["Tech"],"readingTime":4},{"title":"조드 TypeScript를 우선으로 하는 최고의 스키마 유효성 검사 라이브러리","description":"","date":"2024-05-12 20:03","slug":"2024-05-12-ZodTheUltimateTypeScript-firstSchemaValidationLibrary","content":"\n\n데이터 유효성 검사는 어떤 애플리케이션 개발 과정에서 중요한 측면으로, 들어오는 데이터가 예상 형식과 제약 조건을 준수하는지 확인합니다. TypeScript 세계에서, 개발자들은 종종 untyped 또는 느슨하게 typed된 데이터 원본을 처리할 때 타입 안전성을 유지하는 도전에 직면합니다. 여기 Zod가 나타납니다. TypeScript-first 스키마 유효성 검사 라이브러리로, 이 간극을 원활하게 연결하려고 합니다.\n\n![2024-05-12-ZodTheUltimateTypeScript-firstSchemaValidationLibrary_0](/assets/img/2024-05-12-ZodTheUltimateTypeScript-firstSchemaValidationLibrary_0.png)\n\n## Zod란 무엇인가요?\n\nZod는 개발자 친화적인 경험을 제공하도록 설계된 스키마 선언 및 유효성 검사 라이브러리입니다. TypeScript 강력한 유형 시스템을 활용해 스키마 정의에서 정적 유형을 추론하며, 중복된 유형 선언의 필요성을 제거합니다. Zod를 사용하면 한 번의 유효성 검사기를 선언하고 자동으로 해당 TypeScript 유형을 추론할 수 있어, 간단한 유형을 복잡한 데이터 구조로 구성하기가 쉬워집니다.\n\n\n\n## Zod 사용의 장점들\n\n- 타입 안전성: Zod의 기반은 TypeScript의 타입 시스템으로 구축되어 코드베이스 전반에 걸쳐 견고한 타입 안전성을 제공합니다.\n- 간편함: Zod의 간결하고 연결 가능한 인터페이스는 직관적인 스키마 정의를 가능하게 하여 기존 스키마의 구성 및 확장을 용이하게 합니다.\n- 성능: Zod은 가벼우며 의존성이 없어 서버 및 클라이언트 애플리케이션에 모두 적합합니다.\n- 기능적 접근: Zod은 데이터 유효성 검사에 기능적 접근을 채택하여 \"구문 분석, 유효성 검사\" 패러다임을 장려하여 더 예측 가능하고 신뢰할 수 있는 경험을 제공합니다.\n- 확장성: Zod은 풍부한 내장 유효성 검사 세트를 제공하면서 리파인먼트와 변환을 통해 사용자 정의 유효성 로직을 정의할 수 있는 유연성을 제공합니다.\n\n## Zod 사용 시작하기\n\nZod를 설치하는 것은 간단하며 원하는 패키지 매니저를 사용하여 수행할 수 있습니다:\n\n\n\n```js\n# npm을 이용한 설치\nnpm install zod\n\n# yarn을 이용한 설치\nyarn add zod\n```\n\n설치가 완료되면 TypeScript에서 첫 번째 스키마를 정의할 수 있습니다:\n\n```js\nimport { z } from 'zod';\n\n// 간단한 문자열 스키마 정의\nconst mySchema = z.string();\n\n// 데이터 구문 분석\nmySchema.parse('tuna'); // 'tuna' 반환\nmySchema.parse(12); // ZodError가 발생함\n```\n\n이 예제에서는 z.string() 스키마를 만들고 .parse() 메서드를 사용하여 입력 데이터를 유효성 검사합니다. 입력이 문자열이면 반환되고, 그렇지 않으면 ZodError가 발생합니다.\n\n\n\nZod은 기본 데이터 유형(문자열, 숫자, 부울), 객체, 배열, 유니언, 교차 등을 포함한 포괄적인 스키마 유형 세트를 제공합니다. 이러한 스키마를 조합하여 복잡한 데이터 구조를 나타내고 다양한 유효성 검사 및 변환을 적용할 수 있습니다.\n\n## 고급 기능\n\nZod은 데이터 유효성 검사 경험을 향상시키는 다양한 고급 기능을 제공합니다:\n\n- 세분화: 세분화를 사용하여 데이터에 특정 제약 조건을 강제할 사용자 지정 유효성 검사 논리를 정의할 수 있습니다.\n- 변환: 유효성 검사 전후에 데이터에 변환을 적용하여 데이터 조작을 원활하게 할 수 있습니다.\n- 오류 처리: Zod은 자세한 오류 보고 및 사용자 정의 옵션을 제공하여 유효성 검사 오류를 효과적으로 처리하기 쉽게 만듭니다.\n- 함수형 프로그래밍: Zod의 함수형 프로그래밍 기능을 활용하여 스키마를 조합하고 변환하여 더 선언적이고 표현이 풍부한 코딩 스타일을 구현할 수 있습니다.\n- 생태계 지원: Zod은 제3자 라이브러리와 통합이 확장되고 인기있는 프레임워크 및 도구와의 원활한 통합을 가능하게 하는 성장 중인 생태계를 보유하고 있습니다.\n\n\n\n## 결론\n\nZod는 TypeScript 개발자들에게 강력하고 사용자 친화적인 데이터 유효성 검사 솔루션을 찾는 사람들에게 혁신적인 변화를 가져다줍니다. TypeScript의 타입 시스템을 활용하고 풍부한 기능 세트를 제공함으로써, Zod는 복잡한 데이터 구조를 정의하고 유효성을 검사하는 작업을 간단하게 만들어 주며, 타입 안전성과 유지 보수성을 보장합니다. 서버 측 API, 클라이언트 측 애플리케이션 또는 TypeScript 기반 프로젝트를 구축하고 있다면, Zod가 개발 환경을 크게 향상시키고 개발 주기 초기에 데이터 관련 문제를 빨리 찾을 수 있도록 도와줄 것입니다.\n\nZod의 힘을 받아 TypeScript 프로젝트에서 자신감을 키워보세요. 자세한 내용을 알아보고 예제를 살펴보며 더 깊게 파고들기 위해 https://zod.dev의 공식 Zod 문서를 방문해보세요.","ogImage":{"url":"/assets/img/2024-05-12-ZodTheUltimateTypeScript-firstSchemaValidationLibrary_0.png"},"coverImage":"/assets/img/2024-05-12-ZodTheUltimateTypeScript-firstSchemaValidationLibrary_0.png","tag":["Tech"],"readingTime":3},{"title":"Amplify vs Firebase 내 실제 제품과의 대면 비교","description":"","date":"2024-05-12 20:01","slug":"2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct","content":"\n## 주요 차이점 및 유사점\n\n![Comparison Image](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_0.png)\n\n지난 1년간 실제 트래픽과 사용자가 있는 2개 제품을 개발했습니다. 하나는 Amplify를 사용하고, 다른 하나는 Firebase를 사용했습니다. 제가 배운 교훈들과 Amplify와 Firebase를 대조한 비교를 공유하려고 합니다.\n\n이 글을 두 부분으로 나눠 작성하겠습니다. 첫 번째 부분에서는 Firebase에 대해, 두 번째 부분에서는 Amplify에 대해 이야기하겠습니다.\n\n# 왜 Firebase 또는 Amplify를 사용해야 하나요?\n\n간단히 말해서, 나는 경력이 4년인 프론트엔드 엔지니어입니다. 제 경험상 본업급 백엔드에 거의 관여한 적이 없어 백엔드 품질에 대한 최고의 실천 방법에 대한 지식이 적다고 가정해도 좋습니다.\n\n제품 개발에 집중하고 싶으며, 인증, 데이터베이스 CRUD, 자산 저장, 그리고 물론 백엔드 보안을 포함한 백엔드 측면의 품질을 희생하지 않고 가장 빠르게 출시하고자 합니다.\n\nAmplify와 Firebase는 모두 동일한 문제를 해결하는데, 즉 프론트엔드 웹 및 모바일 개발자가 쉽게 앱 또는 게임을 빌드하고 확장할 수 있는 완벽한 솔루션을 제공한다는 점입니다.\n\n# 파이어베이스를 사용하여 만든 내가 만든 것\n\n세계 각지의 플레이어들이 게임 속에 출시되기를 원하는 모든 노래 위시리스트를 수집하기위해 프로젝트 세카이를 기반으로 한 커뮤니티 페이지를 만들었습니다.\n\n![이미지](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_1.png)\n\n# 내 프로젝트에서 사용한 파이어베이스 기능\n\n## 인증\n\nFirebase Authentication을 사용하여 사용자 인증 및 권한 부여를 처리했어요. 많은 인증 옵션이 있지만, 이 프로젝트에서는 Google 로그인과 Twitter 로그인을 선택했어요.\n\n![이미지](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_2.png)\n\n## Firestore\n\nCloud Firestore를 데이터베이스 옵션으로 사용했어요. 이는 MongoDB와 유사한 문서 기반 구조를 가진 NoSQL 데이터베이스입니다. 이 데이터베이스를 사용하여 다음을 처리했어요:\n\n- 내장된 실시간 업데이트로 사용자 투표\n\n![](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_3.png)\n\n- 사용자가 소원 노래를 제출\n\n![이미지](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_4.png)\n\n- 게임에서 이미 출시된 노래를 관리합니다.\n\n![이미지](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_5.png)\n\n## 저장소\n\n저는 이미지 배너와 같은 자산 저장을 다루는 간단한 사용 사례를 가지고 있는 Cloud Storage를 사용했어요.\n\n## 보안 규칙\n\n저는 사용자가 특정 데이터에 접근할 수 있도록 조작할 수 있는 보안 규칙을 사용했어요.\n\n## Algolia\n\nCloud Firestore은 데이터 조작 기능이 훌륭하지만 한 가지 중요한 기능을 수행할 수 없습니다: 전체 텍스트 및 부분 텍스트 검색입니다. 그러나 Firebase는 Algolia 검색과 통합하는 것을 지원하는 우선 순위 옵션을 제공합니다.\n\n# Firebase의 장단점\n\n## 장점\n\n- 생산성 — Firebase는 프론트엔드 엔지니어를 위한 훌륭한 기능을 갖추고 있어 제품을 빨리 출시하고 사용자 트래픽에 따라 자동으로 확장하며 보안을 보장하는 데 큰 도움이 됩니다. Firebase의 내부에는 GCP 자체가 있어 Firebase 프로젝트의 기능을 Google Cloud Platform으로 쉽게 확장할 수 있습니다.\n- 학습 곡선 — Firebase 기능과의 통합이 매우 직관적이기 때문에 학습 곡선이 낮습니다.\n- 인증 — Firebase 인증은 Google, Apple, Facebook, Twitter, Microsoft, GitHub, Yahoo와 같은 제3자 서비스와의 통합을 위한 많은 내장 지원이 있습니다.\n\n## 단점\n\n어드민 패널이 없음 — Firebase에는 내장된 어드민 패널이 제공되지 않습니다. 사용자들은 Firebase 콘솔 내에서 데이터를 직접 조작할 수 있지만, UI가 기술 지식이 없는 사람들에겐 너무 기술적일 수 있습니다. 이 경우, 별도의 어드민 패널을 만들어야 합니다.\n\n![이미지](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_6.png)\n\n전체 또는 부분 텍스트 검색 미지원 — 부분 또는 전체 텍스트 검색을 수행하는 데 필요한 기능이 내장되어 있지 않기 때문에, Algolia, Elasticsearch, 또는 Typesense와 같은 제3자 서비스와 통합해야 합니다.\n\n데이터베이스 객체 모델링 - 이 프로젝트를 개발할 때, 저는 여전히 Firebase 버전 8.10.0을 사용하고 있었는데, 클라우드와 코드 간 데이터 유형의 일관성을 유지하는 것이 꽤 어려웠습니다. MongoDB와 같은 데이터베이스는 객체 모델링을 위한 Mongoose와 같은 솔루션이 있지만, Firestore에 대한 유사한 솔루션을 찾지 못했습니다. 이는 때때로 필드 이름에 오타가 있거나, 필드 이름이 아직 정의되지 않아서 생산성과 코드 품질이 떨어지게 만듭니다.\n\n하지만 Firebase의 최신 버전에서는 이 문제를 해결할 수 있는 사용자 정의 객체를 처리하는 기능이 있습니다:\n\n```js\nclass City {\n  constructor(name, state, country) {\n    this.name = name;\n    this.state = state;\n    this.country = country;\n  }\n  toString() {\n    return this.name + \", \" + this.state + \", \" + this.country;\n  }\n}\n\n// Firestore 데이터 컨버터\nconst cityConverter = {\n  toFirestore: (city) => {\n    return {\n      name: city.name,\n      state: city.state,\n      country: city.country,\n    };\n  },\n  fromFirestore: (snapshot, options) => {\n    const data = snapshot.data(options);\n    return new City(data.name, data.state, data.country);\n  },\n};\n```\n\n# Amplify를 활용해 만들어본 것\n\n코스프레 취미를 위한 전체적인 의상 대여 샵을 만들었어.\n\n![이미지](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_7.png)\n\n# 내 프로젝트에서 사용한 Amplify 기능\n\n- Amazon Cognito — 사용자 인증 및 권한 부여를 처리하기 위해 Amazon Cognito를 사용했어. 다양한 인증 옵션이 있지만, 이 프로젝트에서는 Google 및 Facebook 로그인을 선택했어.\n- Amazon CloudFormation — AWS CloudFormation을 사용하면 인프라를 코드로 처리하여 AWS 및 제3자 리소스를 모델링, 프로비저닝 및 관리할 수 있어. CloudFormation 덕분에 스테이징 및 프로덕션과 같은 브랜치 환경을 쉽게 만들 수 있어.\n- Amazon AppSync — AWS AppSync을 사용하면 서버리스 GraphQL 및 Pub/Sub API를 생성해 어플리케이션 개발을 단순화할 수 있어. 안전하게 데이터 쿼리, 업데이트 또는 게시하는 단일 엔드포인트를 통해 애플리케이션 개발을 단순화할 수 있어.\n- Amazon DynamoDB — Firestore를 사용하는 문서 기반 컨셉에 대해 이전 섹션에서 소개했었어. 다른 쪽으로 DynamoDB는 Redis와 유사한 키-값 스키마를 사용해. 웹사이트의 모든 데이터(사용자 데이터, 제품 데이터, 거래 데이터, 결제 데이터 등)를 처리하기 위해 DynamoDB를 사용했어.\n- Amazon S3 — S3는 어디서든 어떤 양의 데이터든 검색할 수 있는 객체 저장소야. 제품 이미지, 웹사이트 자산, 사용자 자산을 처리하기 위해 Amazon S3를 사용했어.\n- Amazon Pinpoint — Amazon Pinpoint는 대상 멀티채널 통신 도구야. Google Analytics의 AWS 플랫폼용 동등물이야. 웹사이트 관련 추적 및 분석을 처리하기 위해 Amazon Pinpoint를 사용했어.\n- Amazon Lambda — Amazon Lambda는 서버리스, 이벤트 주도형 컴퓨팅 서비스야. 결제 게이트웨이 및 택배 게이트웨이와 같은 제3자 공급업체와의 모든 API 통신을 처리하기 위해 AWS Lambda를 사용했어.\n\n# Amplify의 장단점\n\n## 장점\n\n- Amplify Studio — 이전 섹션에서 논의된 Firebase 버전과 달리, AWS Amplify에는 Amplify Studio라는 일반 관리 패널이 함께 제공됩니다. Amplify Studio는 데이터 관리, 사용자 관리 및 자산 관리를 처리할 수 있습니다. Amplify Studio의 기능을 보여주는 몇 가지 예시는 다음과 같습니다.\n\n![Amplify Studio](/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_8.png)\n\n- CloudFormation - AWS CloudFormation을 사용하면 환경을 쉽게 복제할 수 있습니다. 특히 스테이징 및 프로덕션 환경을 구축할 때 유용합니다. Firebase와 비교했을 때 이것이 주요 장점 중 하나입니다.\n- 데이터베이스 객체 모델링 - AWS AppSync을 통해 GraphQL 스키마 유형을 사용하여 데이터베이스 스키마를 정의할 수 있습니다. 이것은 '데이터베이스를 코드로' 접근 방식을 만들어 모든 데이터 구성에서 일관성을 보장합니다. 또한 이 스키마를 사용하여 데이터 인가를 구성할 수도 있습니다.\n\n```js\ntype Products @model @auth(rules: [{allow: public}]) {\n  id: ID!\n  available_size: [AvailableSizeEnums!]!\n  day_rent_price: Int!\n  is_active: Boolean!\n  minimum_rent_duration: Int!\n  product_name: String!\n  quantity: Int!\n  weight: Int!\n  s3_path: String!\n  product_image: [String!]!\n  product_description: String!\n}\n```\n\n전체-부분-텍스트 검색 - Amazon은 Amazon OpenSearch로 검색을 처리하는 내장 기능을 제공합니다.\n\n## 단점\n\n인증 - AWS Cognito는 Firebase와 비교했을 때 소셜 통합 옵션이 적습니다. Amazon, Facebook, Google 및 Apple을 통한 로그인 옵션이 있지만 Auth0와 연동하여 확장할 수 있습니다.\n\n학습 곡선 - AWS Amplify는 Firebase에 비해 UI 엔지니어들에게 이해하기 어려운 학습 곡선을 가지고 있다고 느껴져요. Amplify는 AWS 리소스를 관리하기 위한 구축 블록이자 CLI 가이드 명령어일뿐입니다. 따라서 Amplify가 어떻게 작동하는지 이해하려면 여러 AWS 제품을 이해해야 합니다. 예를 들어, DynamoDB에 새 데이터 필드를 추가하려면 Firestore와 달리 몇 단계를 거쳐야 합니다.\n\n커뮤니티 토론 부족 - 앞서 말한대로 AWS Amplify는 학습 곡선이 높습니다. 그래서 오류, 문제 또는 모르는 것을 만났을 때 Firebase와 비교하여 Stack Overflow나 GitHub의 토론 및 질의응답이 적습니다. 게다가 AWS 개발자 지원을 구독하여 기술적인 질문이 있을 경우 AWS에서 직접 개발자 지원을 받을 수 있습니다.\n\n# 결론\n\n프론트엔드 엔지니어로서, Amplify와 Firebase는 우리가 직접 제품을 만들 때 백엔드와 관련된 복잡한 문제를 해결할 수 있는 좋은 도구입니다. 어떤 것을 더 선호하는지 물어본다면, 그것은 상황에 따라 다르겠죠.\n\n커뮤니티와 함께 재미있는 것이나 별로 중요하지 않은 제품을 만들고 싶다면 Firebase를 선택할 것입니다. 하지만 본격적인 제품을 만들어 나의 부수입을 올리고 싶다면 Amplify를 선택할 것입니다.\n\n# 자료\n\n- [Amplify 문서](https://docs.amplify.aws/)\n- [Firebase 문서](https://firebase.google.com/docs)\n","ogImage":{"url":"/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_0.png"},"coverImage":"/assets/img/2024-05-12-AmplifyvsFirebaseAHead-to-HeadComparisonWithMyRealProduct_0.png","tag":["Tech"],"readingTime":7}],"page":"139","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}