{"pageProps":{"posts":[{"title":"React를 사용하여 파일 업로더 만들기","description":"","date":"2024-05-12 18:54","slug":"2024-05-12-BuildingaFileUploaderwithReact","content":"\n\n<img src=\"/assets/img/2024-05-12-BuildingaFileUploaderwithReact_0.png\" />\n\n파일 업로드는 이미지, 비디오 및 파일을 웹 서버에 올리는 과정입니다. 이는 클라이언트 기기의 사용자가 파일을 서버에 업로드하려는 것을 의미합니다. 파일을 웹 애플리케이션에 신속하고 효율적으로 업로드하는 능력은 중요합니다.\n\nReact는 개발자가 상호 작용적이고 원활한 웹 애플리케이션을 구축하는 데 도움이 되는 인기 있는 JavaScript 프레임워크입니다. 이 글은 React를 사용하여 파일을 업로드하는 방법에 대한 단계별 가이드를 제공할 것입니다.\n\n파일 업로드의 중요성\n\n\n\n- 파일 업로드는 데이터 수집을 효율적이고 편리하게 해주는 과정을 제공합니다.\n- 페이스북, 트위터, 인스타그램 등 소셜 미디어 플랫폼들은 사용자 생성 콘텐츠에 크게 의존하고 있습니다. 파일 업로더 없이는 사용자가 사진, 비디오 및 기타 파일을 업로드할 수 없어 이러한 플랫폼이 상호작용이 적고 따분하며 매력이 부족해질 것입니다.\n- 파일 업로드는 오류 발생 가능성이 있고 수동 데이터 수집 및 처리와 비교하여 시간을 절약합니다.\n- 파일 업로드 기능이 없다면 Dropbox 및 Google 드라이브와 같은 클라우드 저장소 서비스가 존재하지 않았을 것입니다. 이러한 애플리케이션들은 사용자가 파일을 원활하게 업로드, 저장 및 공유할 수 있도록 돕습니다.\n\n문서 공유, 이력서 업로드, 데이터 가져오기 또는 내보내기, 미디어 공유, 클라우드 저장소 서비스 등에서 파일 업로더가 사용됩니다.\n\nReact.js에서 기본 파일 업로드 구성 요소 만들기\n\n이는 'file' 유형의 입력을 포함한 양식을 생성하는 것을 포함합니다. 간단한 예제는 아래에 표시되어 있습니다.\n\n\n\n```js\nimport React from 'react';\n\nclass FileUpload extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      selectedFile: null,\n    };\n  }\n\n  onFileChange = event => {\n    this.setState({ selectedFile: event.target.files[0] });\n  };\n\n  onFileUpload = () => {\n    // formData 객체 생성\n    const formData = new FormData();\n\n    // formData 객체 업데이트\n    formData.append(\n      \"myFile\",\n      this.state.selectedFile,\n      this.state.selectedFile.name\n    );\n\n    // 업로드된 파일의 세부 정보 출력\n    console.log(this.state.selectedFile);\n\n    // 백엔드 API로 요청 전송\n    // formData 객체 전송\n    // axios.post(\"api/uploadfile\", formData);\n  };\n\n  render() {\n    return (\n      <div>\n        <h3>React를 이용한 파일 업로드!</h3>\n        <div>\n          <input type=\"file\" onChange={this.onFileChange} />\n          <button onClick={this.onFileUpload}>\n            업로드!\n          </button>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default FileUpload;\n```\n\n이 예제에서는 컴포넌트의 selectedFile 상태가 사용자 입력으로부터 파일 객체를 보유합니다. 사용자가 파일을 선택하면 onFileChange 함수가 트리거되어 선택한 파일로 selectedFile 상태를 업데이트합니다.\n\n사용자가 `업로드` 버튼을 클릭하면 onFileUpload 함수가 트리거됩니다. 이 함수는 FormData 객체를 생성하고 선택한 파일을 추가합니다. FormData 객체는 그 후 HTTP 요청을 사용하여 서버에 전송할 수 있습니다.\n\n이 예제에서는 파일 세부 정보를 콘솔에 로깅하는 것만 있습니다. 실제 시나리오에서는 formData를 서버로 전송하기 위해 axios.post 함수를 사용할 것입니다.\n\n\n\n# 파일 업로더 핸들러\n\nReact 파일 업로더 핸들러를 작성하는 것은 몇 가지 단계를 포함합니다. 이러한 단계는 다음과 같습니다:\n\n- 파일 입력 요소(`input type=\"file\"`)를 포함하는 컴포넌트를 만듭니다. 이 컴포넌트를 통해 사용자가 업로드하려는 파일을 선택할 수 있습니다.\n\n```js\nimport React from 'react';\n\nfunction FileUploadHandler() {\n  const handleFileChange = (event) => {\n    const file = event.target.files[0];\n    // 파일 처리\n  };\n\n  return (\n    <div>\n      <input type=\"file\" onChange={handleFileChange} />\n    </div>\n  );\n}\n\nexport default FileUploadHandler;\n```\n\n\n\n위 코드에서 `FileUploadHandler` 컴포넌트는 파일 입력 요소를 포함하고 있습니다. onChange 이벤트 핸들러는 사용자가 파일을 선택했을 때 트리거됩니다.\n\n- 파일 변화 이벤트 처리\n\n필요한 경우 유효성 검사를 이 지점에서 수행할 수 있습니다. 이벤트를 통해 선택한 파일에는 event.target.files[0]로 액세스할 수 있습니다. 이 예제에서는 이미지는 PNG 또는 JPEG여야 하며 1MB를 초과해서는 안 되며, 그렇지 않으면 경고 메시지가 표시되거나 일찍 반환됩니다.\n\n```js\nconst handleFileChange = (event) => {\n  const file = event.target.files[0];\n\n  if (file.type !== 'image/png' && file.type !== 'image/jpeg') {\n    alert('PNG 또는 JPEG 이미지 파일을 선택해주세요.');\n    return;\n  }\n\n  if (file.size > 1024 * 1024) {\n    alert('파일 크기는 1MB를 초과할 수 없습니다.');\n    return;\n  }\n\n  // 추가 처리 또는 파일 업로드 수행\n};\n```\n\n\n\n- 파일 업로드하기 (백엔드 연동)\n\n서버에 파일을 업로드하기 위해 HTTP 요청을 보내야 합니다. Fetch API나 Axios 라이브러리를 사용하여 요청을 처리할 수 있습니다. 이 예시에서는 Axios를 사용할 것입니다.\n\n- 아래 명령어를 실행하여 Axios를 설치하세요\n\n```js\nnpm install axios --save\n```\n\n\n\n- 이 예제에서는 선택한 파일을 FormData 객체에 래핑하여 /api/upload 엔드포인트로 POST 요청을 보내는 데 Axios를 사용하고 있습니다. 이를 통해 파일 및 기타 양식 데이터를 전송할 수 있습니다. /api/upload 엔드포인트의 서버 측 구현은 백엔드 기술에 따라 다를 것입니다.\n\n```js\nimport axios from 'axios';\n\n// ...\n\nconst handleFileChange = (event) => {\n  const file = event.target.files[0];\n  \n  // FormData 객체 생성\n  const formData = new FormData();\n  formData.append('file', file);\n\n  // 파일 서버로 전송\n  axios.post('/api/upload', formData)\n    .then((response) => {\n      // 파일 업로드 성공\n      console.log(response.data);\n    })\n    .catch((error) => {\n      // 파일 업로드 실패\n      console.log(error);\n  });\n};\n```","ogImage":{"url":"/assets/img/2024-05-12-BuildingaFileUploaderwithReact_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaFileUploaderwithReact_0.png","tag":["Tech"],"readingTime":5},{"title":"일렉트론, 리액트 보일러플레이트","description":"","date":"2024-05-12 18:53","slug":"2024-05-12-ElectronReactTheBoilerplate","content":"\n\n이 글에서는 Electron 및 React를 사용하여 크로스 플랫폼 데스크톱 애플리케이션을 개발할 수 있는 보일러플레이트를 만드는 방법을 안내하겠습니다.\n\n# 소개\n\n## Electron이란 무엇인가요?\n\nElectron은 JavaScript, HTML5, CSS와 같은 웹 기술로 크로스 플랫폼(Mac, Windows, Linux) 애플리케이션을 만들기 위한 프레임워크입니다. Electron은 렌더링을 위해 Chromium을 사용하고 파일 시스템에 액세스하기 위해 Node.js를 사용합니다. 간단히 말해, Electron은 크롬 창에서 웹사이트를 실행하여 네이티브 애플리케이션처럼 보이게 합니다. 그래서...\n\n\n\n일부 인기 있는 앱인 Discord, Figma, Notion, Obsidian, Microsoft Teams, Sourcetree은 Electron으로 제작되었습니다. (모든 앱은 여기에서 확인할 수 있어요: [https://electronjs.org/apps](https://electronjs.org/apps))\n\n## Electron Forge란 무엇인가요?\n\nElectron Forge는 Electron 애플리케이션을 패키징하고 배포하는 올인원 도구입니다. 각각의 단일 목적 패키지를 결합하여 작동하는 전체 빌드 파이프라인을 만듭니다.\n\n## TypeScript가 무엇인가요?\n\n\n\nTypeScript은 Microsoft에서 개발한 무료 오픈 소스 고수준 프로그래밍 언어로, JavaScript에 정적 타이핑을 추가하여 선택적으로 타입 주석을 제공합니다.\n\n### Sass가 무엇인가요?\n\nSass는 세계에서 가장 성숙하고 안정적이며 강력한 전문가용 CSS 확장 언어입니다.\n\n### React가 무엇인가요?\n\n\n\n리액트는 컴포넌트를 기반으로 하는 사용자 인터페이스를 구축하기 위한 무료 오픈 소스 프론트엔드 JavaScript 라이브러리입니다. Meta (이전 Facebook)에서 유지보수되고 있습니다.\n\n페이스북, 인스타그램, 넷플릭스, 페이팔 등과 같은 사이트들이 리액트로 개발되었습니다.\n\n## 부트스트랩이란 무엇인가요?\n\n부트스트랩은 반응형이고 모바일을 우선으로 하는 프론트엔드 웹 개발을 위한 무료 오픈 소스 CSS 프레임워크입니다.\n\n\n\n## Font Awesome 4.7이란 무엇인가요?\n\nFont Awesome은 수백만 명의 디자이너, 개발자 및 컨텐츠 제작자들이 사용하는 인터넷 아이콘 라이브러리 및 툴킷입니다.\n\n# 시작하기\n\n## 1. NodeJS 설치\n\n\n\nNodeJS를 설치하세요, 아직 설치하지 않았다면요. 여기서 시스템에 맞는 최신 LTS를 다운로드할 수 있어요.\n\n여기서 모든 단계는 운영 체제에 관계없이 적용할 수 있어요. Windows의 cmd, Mac 및 Linux에서 터미널을 사용하세요.\n\n### 2. Electron Forge를 사용하여 초기 프로젝트 생성\n\n새로운 cmd/터미널 창을 열고 다음 명령을 실행하세요:\n\n\n\n```js\nnpm init electron-app@latest boilerplate -- --template=webpack-typescript\n```\n\n시간이 걸리지만 모든 것이 잘 되었다면 프로젝트 폴더(boilerplate) 내에서 이 파일 구조를 볼 수 있을 것입니다:\n\n![ElectronReactTheBoilerplate_0](/assets/img/2024-05-12-ElectronReactTheBoilerplate_0.png)\n\n이제 다음 명령어로 앱을 시작해 볼 수 있습니다:\n\n\n\n```js\nnpm start\n```\n\n![이미지](/assets/img/2024-05-12-ElectronReactTheBoilerplate_1.png)\n\n## 3. 의존성 설치\n\n```js\nnpm i @popperjs/core bootstrap font-awesome react@17 react-dom@17\n```\n\n\n\n```js\nnpm i -D sass sass-loader autoprefixer postcss postcss-loader resolve-url-loader @types/bootstrap @types/react@17 @types/react-dom@17\n```\n\n## 4. 설정 파일 업데이트하기\n\ntsconfig.json을 업데이트하세요.\n\n```js\n{\n  \"compilerOptions\": {\n    \"target\": \"ES6\",\n    \"allowJs\": true,\n    \"module\": \"commonjs\",\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"noImplicitAny\": true,\n    \"sourceMap\": true,\n    \"baseUrl\": \".\",\n    \"outDir\": \"dist\",\n    \"moduleResolution\": \"node\",\n    \"resolveJsonModule\": true,\n    \"paths\": {\n      \"*\": [\"node_modules/*\"],\n      \"@/*\": [\"src/*\"]\n    },\n    \"jsx\": \"react-jsx\"\n  },\n  \"include\": [\"src/**/*\"]\n}\n```\n\n\n\n웹팩 메인 설정 파일인 wepback.main.config.ts를 업데이트 해주세요.\n\n```typescript\nimport type { Configuration } from 'webpack';\nimport { resolve } from 'path';\n\nimport { rules } from './webpack.rules';\nimport { plugins } from './webpack.plugins';\n\nexport const mainConfig: Configuration = {\n  /**\n   * 이 파일은 애플리케이션의 주요 진입점입니다. 메인 프로세스에서 처음으로 실행되는 파일입니다.\n   */\n  entry: './src/index.ts',\n  // 이 아래에 일반 웹팩 설정을 넣어주세요\n  module: { rules },\n  plugins,\n  resolve: {\n    alias: { '@': resolve(__dirname, 'src') },\n    extensions: ['.js', '.ts', '.jsx', '.tsx', '.css', '.scss', '.json']\n  }\n};\n```\n\n웹팩 렌더러 설정 파일인 webpack.renderer.config.ts를 업데이트 해주세요.\n\n```typescript\nimport type { Configuration } from 'webpack';\nimport { resolve } from 'path';\n\nimport { rules } from './webpack.rules';\nimport { plugins } from './webpack.plugins';\n\nrules.push({\n  test: /\\.(css|scss)$/,\n  use: [\n    { loader: 'style-loader' },\n    {\n      loader: 'css-loader',\n      options: {\n        sourceMap: true\n      }\n    },\n    { loader: 'resolve-url-loader' },\n    {\n      loader: 'postcss-loader',\n      options: {\n        postcssOptions: {\n          plugins: () => [require('autoprefixer')]\n        }\n      }\n    },\n    { loader: 'sass-loader' }\n  ]\n});\n\nexport const rendererConfig: Configuration = {\n  module: { rules },\n  plugins,\n  resolve: {\n    alias: { '@': resolve(__dirname, 'src') },\n    extensions: ['.js', '.ts', '.jsx', '.tsx', '.css', '.scss']\n  }\n};\n```\n\n\n\n## 5. 소스 파일 업데이트\n\nsrc/scss.d.ts 파일을 생성하세요\n\n```js\ndeclare module '*.scss';\n```\n\nsrc/index.css 파일의 이름을 src/index.scss로 변경하세요.\n\n\n\nsrc/index.scss을 업데이트하세요.\n\n```scss\n@import 'bootstrap';\n@import 'font-awesome';\n```\n\nsrc/index.html을 업데이트하세요.\n\n```html\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n    <title></title>\n  </head>\n\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n```\n\n\n\n```ts\nimport { 엄격한모드 } from 'react';\nimport { 렌더 } from 'react-dom';\n\nimport '@/index.scss';\n\n렌더(\n    <엄격한모드>\n        <div className=\"p-3\">\n            <h1><i className=\"fa fa-heart text-danger\" /> 안녕하세요, 세계여!</h1>\n            <p>Electron 애플리케이션에 오신 것을 환영합니다.</p>\n        </div>\n    </엄격한모드>,\n    document.getElementById('root')\n);\n```\n\nsrc/renderer.ts를 업데이트하세요.\n\n```ts\nimport '@popperjs/core';\nimport 'bootstrap';\n\nimport './App';\n```\n\n\n\nsrc/index.ts 파일을 업데이트 해주세요.\n\n```js\nimport { BrowserWindow, Menu, app } from 'electron';\n\n// 이 부분은 TypeScript가 Forge의 Webpack 플러그인에 의해 자동으로 생성된 매직 상수를 인식할 수 있도록 합니다. \n// 이 상수들은 Electron 앱이 개발 모드든 프로덕션 모드든 Webpack으로 번들된 앱 코드를 어디에서 찾아야 하는지 알려줍니다.\ndeclare const MAIN_WINDOW_WEBPACK_ENTRY: string;\ndeclare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;\n\n// Windows에서 단축키를 추가/제거하는 처리\nif (require('electron-squirrel-startup')) {\n  app.quit();\n}\n\nconst createWindow = (): void => {\n  // 브라우저 창을 생성합니다.\n  const mainWindow = new BrowserWindow({\n    title: `Boilerplate ${app.getVersion()}`,\n    height: 600,\n    width: 800,\n    webPreferences: {\n      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY\n    }\n  });\n\n  Menu.setApplicationMenu(null);\n\n  // 그리고 어플리케이션의 index.html을 로드합니다.\n  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);\n};\n\n// 이 메서드는 Electron이 초기화를 마치고 브라우저 창을 생성할 준비가 된 시점에 호출됩니다.\n// 일부 API는 이 이벤트 이후에만 사용할 수 있습니다.\napp.on('ready', createWindow);\n\n// 모든 창이 닫힐 때 앱을 종료합니다. macOS에서는 달리 동작합니다. 거기서는 사용자가 Cmd + Q로 \n// 명시적으로 종료할 때까지 앱 및 메뉴바가 활성 상태로 유지되는 것이 일반적입니다.\napp.on('window-all-closed', () => {\n  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\n\napp.on('activate', () => {\n  // macOS에서는 dock 아이콘을 클릭하고 다른 창이 열려있지 않을 때 어플리케이션의 창을 다시 만드는 것이 일반적입니다.\n  if (BrowserWindow.getAllWindows().length === 0) {\n    createWindow();\n  }\n});\n\n// 이 파일에서 어플리케이션의 특정한 메인 프로세스 코드를 포함할 수 있습니다.\n// 별도의 파일에 작성하고 여기에서 가져와 사용할 수도 있습니다.\n```\n\n다시 실행해보세요: npm start\n\n![이미지](/assets/img/2024-05-12-ElectronReactTheBoilerplate_2.png)\n\n\n\n# 릴리스\n\nnpm run make 명령을 사용하면 Forge 구성 (forge.config.ts)을 기반으로 응용 프로그램에 대한 배포 가능한 항목을 만들 수 있습니다.\n\nWindows에서 작업 중인 경우 출력은 다음과 같아야 합니다:\n\n이 글이 유용하셨다면 손가락 몇 개를 눌러 주시고 다른 작품들도 확인해보세요.\n\n\n\n읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-12-ElectronReactTheBoilerplate_0.png"},"coverImage":"/assets/img/2024-05-12-ElectronReactTheBoilerplate_0.png","tag":["Tech"],"readingTime":7},{"title":"Nextjs API Routes에서 외부 패키지 없이 요청 속도 제한 설정하기","description":"","date":"2024-05-12 18:52","slug":"2024-05-12-ImplementingRateLimitinginNextjsAPIRouteswithoutExternalPackages","content":"\n\n---\n이미지: /assets/img/2024-05-12-ImplementingRateLimitinginNextjsAPIRouteswithoutExternalPackages_0.png\n\n속도 제한은 서버의 트래픽을 관리하고 과부하를 방지하며 악용으로부터 보호하는 중요한 측면입니다. Next.js API 라우트에 속도 제한을 구현하기 위한 패키지들이 있지만 외부 의존성에 의존하지 않고 이를 어떻게 달성할지 살펴보겠습니다. \"고정 창 카운터\" 접근 방식을 활용할 것인데, 이 방식은 특정 시간 간격 내에 발신자로부터 발생하는 요청 수를 기록합니다. 요청 수가 제한을 초과하면 해당 발신자로부터의 추가 요청은 거부됩니다.\n\n# 속도 제한 미들웨어 구축하기\n\nAPI 라우트를 위한 게이트키퍼로 작동하는 미들웨어 함수를 만들어봅시다. 이 함수는 단일 IP 주소가 지정된 시간 창 내에서 설정한 요청 제한을 초과하지 않도록 보장하여 서버의 안정성과 성능을 향상시킵니다.\n\n\n\n\n앱 루트 디렉토리에 \"middleware\"라는 폴더를 만들고, 다음 코드가 포함된 \"rateLimiter.js\" 파일을 추가해주세요:\n\n이제 레이트 제한을 구현하는 코드를 자세히 살펴보겠습니다:\n\n```js\nconst rateLimitMap = new Map();\n\nexport default function rateLimitMiddleware(handler) {\n    return (req, res) => {\n        const ip = req.headers[\"x-forwarded-for\"] || req.connection.remoteAddress;\n        const limit = 5; // IP 당 분당 요청 수를 5개로 제한\n        const windowMs = 60 * 1000; // 1분\n        \n        if (!rateLimitMap.has(ip)) {\n            rateLimitMap.set(ip, {\n                count: 0,\n                lastReset: Date.now(),\n            });\n        }\n        \n        const ipData = rateLimitMap.get(ip);\n        \n        if (Date.now() - ipData.lastReset > windowMs) {\n            ipData.count = 0;\n            ipData.lastReset = Date.now();\n        }\n        \n        if (ipData.count >= limit) {\n            return res.status(429).send(\"너무 많은 요청\");\n        }\n        \n        ipData.count += 1;\n        \n        return handler(req, res);\n    };\n}\n```\n\n# 구현\n\n\n\n자, 이제 이 코드를 API 경로에 통합해 봅시다:\n\n\"limited.js\"라는 경로를 생성하고 rateLimitMiddleware를 적용하세요. IP 주소가 제한을 초과하면 \"너무 많은 요청\" 상태 코드 (429)로 응답합니다.\n\n```js\nimport rateLimitMiddleware from \"@/middleware/rateLimiter\";\n\nfunction handler(req, res) {\n  res.status(200).json({ name: \"Limited, don't over use me!\" });\n}\nexport default rateLimitMiddleware(handler);\n```\n\n# 결론\n\n\n\n이 문서에서는 외부 패키지에 의존하지 않고 Next.js API 라우트에서 요금 제한을 구현하는 방법을 살펴보았습니다. \"고정 창 카운터\" 방식을 활용하여 들어오는 요청을 효과적으로 관리하여 과부하를 방지하고 서버의 원활한 작동을 보장할 수 있습니다. 이 사용자 정의 솔루션은 특정 요구 사항에 맞게 유연하고 맞춤 설정할 수 있습니다. 그러니 안심하고 요금 제한을 Next.js 프로젝트에 통합하여 서버를 건강하고 반응적으로 유지하세요!\n\n유용한 자원 코딩 도전\n\n내 GitHub 저장소에서 전체 코드에 액세스해보세요.","ogImage":{"url":"/assets/img/2024-05-12-ImplementingRateLimitinginNextjsAPIRouteswithoutExternalPackages_0.png"},"coverImage":"/assets/img/2024-05-12-ImplementingRateLimitinginNextjsAPIRouteswithoutExternalPackages_0.png","tag":["Tech"],"readingTime":3},{"title":"배열 변수를 상태 변수로 변환하기","description":"","date":"2024-05-12 18:51","slug":"2024-05-12-TransformingArrayVariableAsAStateVariable","content":"\n\n```js\nconst demoArray = [\n  { id: 0, name: \"Yogesh\", age: 24 },\n  { id: 1, name: \"Nitesh\", age: 21 },\n  { id: 2, name: \"Hriday\", age: 24 },\n];\n```\n\n화면에 표시하거나 렌더링 목록 기술을 사용하여 배열 정보를 렌더링하는 컴포넌트를 만듭니다.\n\n```js\nfunction TransformArray() {\n  const [info, setInfo] = useState(demoArray);\n\n  return (\n    <Fragment>\n      <h1>소피모어를 하는 우리 동문 정보</h1>\n      {info.map((ele) => (\n        <Fragment key={ele.id}>\n          <h1>\n            {ele.name}-{ele.age}\n          </h1>\n        </Fragment>\n      ))}\n    </Fragment>\n  );\n}\n```\n\n\n\n루트 컴포넌트에서 TransformArray의 컴포넌트 인스턴스를 생성하는 컴포넌트를 반환하세요.\n\n```js\nfunction App() {\n  return <TransformArray />;\n}\n```\n\n렌더링하기\n\n```js\nimport React from \"react\";\nimport { createRoot } from \"react-dom\";\n\ncreateRoot(document.getElementById(\"root\")).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n```\n\n\n\n여기 전체 코드가 있어요\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\n\n// 전역으로 선언된 배열\nconst demoArray = [\n  { id: 0, name: \"Yogesh\", age: 24 },\n  { id: 1, name: \"Nitesh\", age: 21 },\n  { id: 2, name: \"Hriday\", age: 24 },\n];\n\n// 작동하는 컴포넌트\nfunction TransformArray() {\n  const [info, setInfo] = useState(demoArray);\n\n  return (\n    <Fragment>\n      <h1>2학년 시절 우리 동문 정보</h1>\n      {info.map((ele) => (\n        <Fragment key={ele.id}>\n          <h1>\n            {ele.name}-{ele.age}\n          </h1>\n        </Fragment>\n      ))}\n    </Fragment>\n  );\n}\n\n// 루트 컴포넌트\nfunction App() {\n  return <TransformArray />;\n}\n\n// React 컴포넌트 렌더링\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n```\n\n이제 이 학생들이 10년 후의 나이를 알려주는 버튼을 만들어보세요\n\n```js\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\n\n// 전역으로 선언된 배열\nconst demoArray = [\n  { id: 0, name: \"Yogesh\", age: 24 },\n  { id: 1, name: \"Nitesh\", age: 21 },\n  { id: 2, name: \"Hriday\", age: 24 },\n];\n\n// 작동하는 컴포넌트\nfunction TransformArray() {\n  const [info, setInfo] = useState(demoArray);\n\n  function handleClick() {\n    const newVal = info.map((ele) => ({ ...ele, age: ele.age + 10 }));\n    setInfo(newVal);\n  }\n\n  return (\n    <Fragment>\n      <h1>2학년 시절 우리 동문 정보</h1>\n      {info.map((ele) => (\n        <Fragment key={ele.id}>\n          <h1>\n            {ele.name}-{ele.age}\n          </h1>\n        </Fragment>\n      ))}\n      <button onClick={handleClick}>현재 나이</button>\n    </Fragment>\n  );\n}\n\n// 루트 컴포넌트\nfunction App() {\n  return <TransformArray />;\n}\n\n// React 컴포넌트 렌더링\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n```\n\n\n\n여기서 우리는 현재 학생의 나이를 처리하는 간단한 버튼을 만들었습니다.\n\n지금은 맵 메서드가 특히 배열 내부의 객체를 업데이트하기 위해 리액트에서 널리 사용됩니다.\n\n우리가 원하는 변수를 업데이트하는 데 꽤 간단한 방법으로 구조 분해 메커니즘을 사용했습니다.","ogImage":{"url":"/assets/img/2024-05-12-TransformingArrayVariableAsAStateVariable_0.png"},"coverImage":"/assets/img/2024-05-12-TransformingArrayVariableAsAStateVariable_0.png","tag":["Tech"],"readingTime":3},{"title":"React Native 리스트의 성능을 개선하는 방법 FlatList 최적화 가이드","description":"","date":"2024-05-12 18:48","slug":"2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide","content":"\n\n소개\n\n![이미지](/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_0.png)\n\nFlatList란 무엇인가요?\n\n- 성능 최적화: FlatList는 대규모 목록을 효율적으로 렌더링하기 위해 설계된 React Native 컴포넌트입니다. \"게으른 로딩\"이라는 기술을 통해 이를 수행합니다. 이는 화면에 현재 표시된 항목만 렌더링하고 사용자가 스크롤할 때 컴포넌트를 재활용함으로써 작동합니다.\n- 이를 통해 많은 양의 데이터를 다룰 때에도 앱이 부드럽고 반응성 있게 유지됩니다.\n- 필수적인 목록 기능: FlatList는 사용자 친화적인 목록을 구축하는 데 필수적인 다양한 기능을 제공합니다.\n- 매우 맞춤화 가능: 속성, 스타일링, 사용자 정의 컴포넌트를 사용하여 목록의 모양과 느낌을 쉽게 조정할 수 있습니다.\n\n\n\nFlatList를 사용하는 주요 장점들\n\n- 성능, 성능, 성능: FlatList는 긴 목록을 처리할 때 빛을 발합니다. 게으르게 로딩하고 최적화 기술을 사용하여 데이터가 많아져도 앱이 느려지지 않도록 합니다.\n- 내장 기능: 바퀴를 재창조할 필요 없어요. FlatList에는 현대적인 목록에서 기대할 수 있는 기능이 탑재되어 있습니다: 당겨서 새로고침, 헤더, 푸터, 항목 구분선, 특정 위치로 스크롤 등.\n- 크로스 플랫폼: 하나의 코드 베이스로 iOS와 Android 기기에서 목록이 매끄럽게 작동합니다.\n\n## 핵심 기능들:\n\n- FlatList는 상자에서 바로 제공되는 주요 기능들로, 매우 유용하게 만들어집니다:\n- 크로스 플랫폼: iOS와 Android에서 일관되게 작동합니다.\n- 수평 모드: 표준 수직 및 수평 목록 간 전환 가능.\n- 가시성 콜백: 보이는 항목을 추적하여, 사용자가 끝에 가까워질 때 추가 데이터를 로드할 수 있도록 합니다.\n- 헤더 및 푸터: 헤더와 푸터를 목록에 쉽게 통합합니다.\n- 구분선: 목록 항목 사이의 구분선 외관을 사용자 정의할 수 있습니다.\n- 당겨서 새로고침: 사용자가 목록 내용을 새로 고칠 수 있는 일반적인 인터페이스.\n- 스크롤 로딩 (무한 스크롤): 사용자가 스크롤할 때 자연스럽게 더 많은 데이터를 로드합니다.\n- ScrollToIndex: 목록에서 특정 항목으로 빠르게 이동합니다.\n- 여러 열: 그리드 형식으로 목록을 렌더링합니다.\n\n\n\nFlatList을 언제 사용해볼까요?\n\n- 연락처 목록 표시\n- 이미지 갤러리 만들기\n- 뉴스 피드 또는 타임라인 구축\n- 전자상거래 앱에서 제품 목록 렌더링\n- 스크롤 가능한 항목 목록을 표시해야 하는 모든 시나리오\n\n간단한 예제로 설명해 보겠습니다:\n\n```js\nimport { FlatList, Text } from 'react-native';\n\nconst myData = [ /* 데이터 객체 배열 */ ];\n\nconst renderItem = ({ item }) => (\n    <Text>{item.title}</Text> \n);\n\n<FlatList\n  data={myData}\n  renderItem={renderItem} \n  keyExtractor={item => item.id} \n/>\r\n```\n\n\n\n중요한 속성 설명해 드릴게요\n\n- data: 리스트에 표시하려는 데이터 배열입니다.\n- renderItem: 데이터 배열에서 개별 항목을 가져와서 시각적으로 표현하는 JSX 구조를 반환하는 함수입니다.\n- keyExtractor: 각 목록 항목에 대한 고유한 키를 생성하는 함수입니다 (React의 렌더링 최적화에 중요합니다).\n\n## FlatList가 동적으로 업데이트되도록 만드는 방법\n\n이 핵심은 FlatList가 응용 프로그램 데이터 변경에 따라 디스플레이를 어떻게 업데이트할지 제어하는 데 있습니다.\n\n\n\n- 선택 가능한 항목: FlatList에서 항목을 선택할 때 시각적으로 변경되도록 하는 것이 목표입니다 (예: 선택된 항목 강조 표시). 이를 위해 다음이 필요합니다:\n\n- 상태(State): 현재 선택된 항목의 ID를 추적하기 위해 selectedId와 같은 상태 변수가 필요합니다.\n- 시각적 스타일링: renderItem 함수 내부에서 항목의 ID가 선택된 ID와 일치하는지 여부에 따라 다른 스타일을 적용해야 합니다.\n\nextraData - 업데이트의 핵심:\n\n- FlatList는 PureComponent이므로 생성자에서 직접 변경된 경우에만 다시 렌더링됩니다.\n- 항목을 선택하는 경우 대부분 FlatList 자체의 속성 외부에서 상태를 변경하므로, extraData='selectedId'를 사용하여 selectedId 상태 변수가 변경될 때마다 FlatList가 다시 렌더링되어야 함을 알립니다.\n\n\n\nkeyExtractor - 고유 키 보장하기:\n\n- keyExtractor는 React에서 리스트를 업데이트할 때 효율적으로 사용됩니다. 데이터의 각 항목에서 고유 키(일반적으로 ID)를 추출하는 방법을 제공합니다.\n\n예시\n\n```js\nimport { FlatList, View, StyleSheet, TouchableOpacity, Text } from 'react-native';\n\nconst recipes = [\n  { id: 'recipe1', title: '맛있는 팬케이크' },\n  { id: 'recipe2', title: '초콜릿 케이크' },\n  // ... 더 많은 레시피\n];\n\nconst RecipeCard = ({ recipe, onFavoriteToggle }) => { return ( <TouchableOpacity onPress={() => onFavoriteToggle(recipe.id)}> <View style={styles.card}> <Text style={styles.title}>{recipe.title}</Text> {/* 가상: 여기에 이미지가 있을 것 */} <Text style={recipe.isFavorite ? styles.favorite : styles.notFavorite}> {recipe.isFavorite ? '♥ 즐겨찾기한 레시피' : '☆ 즐겨찾기하기' } </Text> </View> </TouchableOpacity> ); };\n\nconst RecipeApp = () => {\n  const [recipesData, setRecipesData] = useState(recipes); // 즐겨찾기 관리\n  const [selectedId, setSelectedId] = useState(null); // extraData에 여전히 사용됨\n\n  const handleFavoriteToggle = (recipeId) => {\n    setRecipesData(prevRecipes => prevRecipes.map(recipe =>\n      recipe.id === recipeId ? { ...recipe, isFavorite: !recipe.isFavorite } : recipe\n    ));\n    setSelectedId(recipeId); \n  };\n\n  return (\n    <FlatList\n      data={recipesData} // 업데이트된 데이터 전달\n      renderItem={({ item }) => (\n        <RecipeCard \n         recipe={item} \n         isFavorite={item.isFavorite} // 속성으로 전달\n         onFavoriteToggle={handleFavoriteToggle} \n        /> \n      )} \n      keyExtractor={(item) => item.id} \n      numColumns={2} \n      extraData={selectedId} \n    />\n  );\n};\n```\n\n\n\n데이터:\n\n- recipes: 초기 레시피 데이터를 보유한 간단한 배열입니다. 각 레시피에는 id 및 title 속성이 포함되어 있습니다.\n\n구성 요소:\n\n- RecipeCard: 단일 레시피 카드를 표시하는 컴포넌트입니다. 제목, 이미지를 위한 자리 표시자 및 즐겨찾기 버튼이 포함되어 있습니다. 이 버튼은 레시피의 isFavorite 상태에 따라 동적으로 변경됩니다.\n- RecipeApp: 앱의 주요 컴포넌트입니다. 다음을 관리합니다:\n- 상태:\n- recipesData: 레시피의 현재 상태를 유지하는 배열로, isFavorite 상태를 포함합니다. 이는 recipes 배열을 사용하여 초기화됩니다.\n- selectedId: 레시피를 즐겨찾기 추가하거나 취소할 때 FlatList를 다시 렌더링하기 위해 사용됩니다.\n- handleFavoriteToggle: 레시피를 즐겨찾기 추가/취소하는 논리를 처리하는 함수입니다. 이 함수는 다음을 수행합니다:\n- recipesData 배열에서 올바른 레시피를 찾습니다.\n- 레시피의 isFavorite 속성을 토글합니다.\n- 다시 렌더링을 트리거하기 위해 setRecipesData를 사용하여 recipesData 상태를 업데이트합니다.\n- 렌더링을 강제로 수행하기 위해 setSelectedId를 통해 selectedId를 업데이트하여 하트/별표가 즉시 업데이트되도록 합니다.\n\n\n\n아래는 Markdown 형식으로 변환된 텍스트입니다:\n\n- **FlatList**: 레시피 목록을 효율적으로 렌더링하는 데 사용됩니다. 주요 속성은 다음과 같습니다:\n  - **data**: 현재 즐겨찾기 상태를 반영하도록 recipesData 배열을 사용합니다.\n  - **renderItem**: 데이터 내 각 레시피에 대해 RecipeCard 컴포넌트를 렌더링하며, 레시피 데이터와 handleFavoriteToggle 함수를 전달합니다.\n  - **keyExtractor**: 각 레시피 객체에서 고유 id 속성을 추출하여 효율적인 추적을 가능하도록 합니다.\n  - **numColumns**: 두 개의 열을 갖는 그리드를 생성합니다.\n  - **extraData**: 선택된 ID가 변경될 때 (즐겨찾기를 추가하거나 삭제할 때) FlatList가 업데이트된 즐겨찾기 상태를 반영하도록 합니다.\n\n## VirtualizedList을 위한 Wrapper로서 FlatList\n\n- **성능 중점**: FlatList는 효율성을 위해 VirtualizedList 기반으로 구축되었습니다. 화면에 현재 보이는 레시피 카드만 렌더링합니다. 많은 레시피가 있는 경우 부드러운 스크롤링을 위해 중요합니다.\n- **상태 제한**: 레시피 카드가 화면에서 스크롤되어 나가면 (예: 확장된 세부 정보 섹션이 있는 경우) 내부 상태가 기본적으로 유지되지 않습니다. 보통 Redux와 같은 중앙 집중형 저장소에 그러한 데이터를 저장합니다.\n\n\n\nPureComponent 동작\n\n- 변경 감지: PureComponent인 FlatList는 속성이나 기본 데이터가 실제로 변경될 때만 다시 렌더링되도록 최적화되어 있습니다. 여기서 extraData가 중요한 역할을 하며 레시피를 즐겨찾기로 지정하면 새로 고침이 트리거되어야 함을 알려줍니다.\n- 속성 동등성: 레시피 배열 내의 변경 사항이 감지됩니다. renderItem이 의존하는 모든 요소가 레시피 데이터에 포함되어 있거나 별도의 속성으로 전달되는지 확인하는 것이 중요합니다.\n\n메모리 관리 및 부드러운 스크롤링\n\n- 비동기 렌더링: FlatList는 스크롤이 부드럽게 느껴지도록 실제로 보이는 것보다 약간 앞의 내용을 렌더링합니다. 하지만 너무 빠르게 스크롤할 경우, 콘텐츠가로드될 때까지 잠깐 빈 공간이 보일 수 있습니다.\n\n\n\nkeyExtractor\n\n- 중요도: React에서 어떤 레시피 카드가 무엇인지 효율적으로 추적하는 것은 매우 중요합니다. 고유한 ID를 사용하는 것이 이상적인 방법입니다.\n\n## ItemSeparatorComponent\n\nReact Native의 FlatList와 관련된 ItemSeparatorComponent의 설명은 다음과 같습니다:\n\n\n\n목적:\n\n- ItemSeparatorComponent 속성을 사용하면 FlatList에 사용자 정의 구성 요소나 요소를 각 항목 사이에 삽입하여 시각적 구분선이나 간격을 만들 수 있습니다.\n\n작동 방식:\n\n- 기본값 없음: FlatList에 기본 구분자가 없습니다. ItemSeparatorComponent를 사용하면 간단히 추가할 수 있습니다.\n- 배치: 구분자 구성 요소는 각 항목 사이에 렌더링되며 목록의 맨 위와 맨 아래를 제외합니다.\n- renderItem 통합: FlatList의 renderItem 함수는 그 내부의 info 매개변수에 속성을 제공합니다:\n  - highlighted: 현재 항목이 강조 표시되는지 표시합니다 (예: 눌림).\n  - separators.highlight: 구분자를 강조 표시하는 함수입니다.\n  - separators.unhighlight: 구분자의 강조 표시를 제거하는 함수입니다.\n  - separators.updateProps: 구분자의 다른 사용자 지정 속성을 업데이트하는 함수입니다.\n\n\n\n유연성:\n\n- 컴포넌트: 사용자 정의 React 컴포넌트를 생성하여 구분자 역할을 할 수 있습니다. 이렇게 하면 외관과 동작에 대한 완전한 제어권을 갖게 됩니다.\n- 엘리먼트: 간단한 구분자의 경우 `View`와 같은 React 엘리먼트를 직접 전달하고 선 또는 간격을 위한 스타일링을 적용할 수 있습니다.\n\n예시:\n\n```js\nconst ItemSeparator = () => <View style={ height: 1, backgroundColor: 'lightgray' } />;\n\n<FlatList\n  data={myData}\n  renderItem={({ item }) => <MyItemComponent item={item} />}\n  ItemSeparatorComponent={ItemSeparator} \n/>\n```\n\n\n\n종류:\n\n- component: 리액트 컴포넌트 클래스 또는 함수형 컴포넌트.\n- function: 리액트 엘리먼트를 반환하는 함수.\n- element: 직접적인 리액트 엘리먼트 (시각적 구분선을 위한 간단한 뷰일 때가 많음)\n\n## 스타일링 속성\n\n다음은 리액트 네이티브의 FlatList 컴포넌트 내에서 다양한 스타일링 속성 및 다른 중요한 목록 관련 속성에 대한 설명입니다:\n\n\n\n# ListEmptyComponent\n\n리액트 네이티브의 FlatList에서 ListEmptyComponent가 어떻게 작동하는지 살펴보겠습니다:\n\n목적:\n\n- ListEmptyComponent 속성은 FlatList가 렌더링할 데이터가 없을 때(즉, 데이터 배열이 비어있을 때) 표시할 내용을 결정합니다.\n- 완전히 비어있는 화면이 아닌 사용자에게 친숙한 메시지나 시각적 표시 방법을 제공합니다.\n\n\n\n작동 방식:\n\n- 조건부 렌더링: FlatList는 자동으로 데이터 배열이 비어 있는지 확인합니다. 데이터 배열이 비어있으면 보통의 목록 항목 대신 ListEmptyComponent를 렌더링합니다.\n- 유연성: 렌더링할 대상에 대해 두 가지 주요 옵션이 있습니다:\n\n    - React 컴포넌트: 사용자 정의 React 컴포넌트(예: EmptyListComponent)를 만들어 메시지, 이미지, \"새로 고침\" 버튼과 같은 작업을 제공합니다. 외관과 기능에 완전한 제어권을 제공합니다.\n\n  2. React 엘리먼트: 종종 \"단순한\" 것처럼 React 엘리먼트를 직접 제공합니다:\n\n\n\n```js\n<Text style={textAlign: 'center'}>레시피를 찾을 수 없어요!</Text>\n```\n\n```js\nconst EmptyListComponent = () => (\n    <View style={styles.emptyContainer}>\n        <Text style={styles.emptyText}>아직 레시피가 없어요!</Text>\n    </View> \n);\n\n<FlatList\n    data={recipes}\n    renderItem={({ item }) => <RecipeCard recipe={item} />} \n    ListEmptyComponent={EmptyListComponent} \n/>\r\n```\n\n유형\n\n- component: React 컴포넌트 클래스 또는 함수형 컴포넌트.\n- element: React 요소 직접 사용.\n\n\n\n주요 포인트:\n\n- 스타일링: 앱 디자인에 맞게 빈 컴포넌트의 스타일을 적절히 지정하세요.\n- 사용자 경험: 잘 디자인된 ListEmptyComponent는 맨 텅 빈 목록보다 훨씬 나은 경험을 제공할 수 있습니다.\n\n# ListFooterComponent\n\nReact Native의 FlatList 안에서 ListFooterComponent를 살펴봅시다.\n\n\n\n목적:\n\n- ListFooterComponent 속성을 사용하면 FlatList의 가장 아래에 일반 리스트 항목들 다음에 렌더링되는 구성 요소나 요소를 추가할 수 있습니다.\n- 일반적인 사용 사례:\n   - 추가 데이터를 가져오기 위한 \"더 보기\" 버튼 표시\n   - 데이터를 가져오는 동안 로딩 스피너 표시\n   - 나열된 항목을 기반으로 요약 정보나 총계 제공\n   - 광고를 위한 자리 표시\n\n작동 방식:\n\n- 배치: ListFooterComponent는 리스트의 절대적 끝에 일관되게 렌더링되며, 리스트가 화면 전체를 채우지 않더라도 렌더링됩니다.\n- 렌더링: 리스트에 데이터가 있는지 여부와 상관없이 렌더링됩니다.\n- 유연성: 다른 유사한 속성과 마찬가지로, 사용할 수 있는 옵션:\n   - React 구성 요소: 복잡한 레이아웃이나 상호작용을 위한 사용자 지정 구성 요소\n   - React 요소: 기본 디스플레이를 위한 `View`와 같은 간단한 요소\n\n\n\n예시\n\n```js\nconst FooterLoader = () => (\n  <View style={styles.footer}>\n    <ActivityIndicator size=\"small\" color=\"gray\" />\n    <Text style={styles.footerText}>더 로딩 중...</Text>\n  </View>\n);\n\n<FlatList\n  data={recipes}\n  renderItem={({ item }) => <RecipeCard recipe={item} />}\n  ListFooterComponent={FooterLoader} \n/>\r\n```\n\n유형\n\n- component: React 컴포넌트 클래스 또는 함수형 컴포넌트.\n- element: React 요소 직접.\n\n\n\n중요한 사항:\n\n- 스크롤: ListFooterComponent를 보려면 사용자가 목록의 맨 아래로 스크롤해야 할 수도 있습니다.\n- ListHeaderComponent: ListHeaderComponent라는 상대적인 요소가 있으며 비슷한 기능을 하지만 목록의 맨 위에 컴포넌트를 렌더링합니다.\n\n# ListFooterComponentStyle\n\nReact Native의 FlatList에서 ListFooterComponentStyle에 대해 이야기해봅시다.\n\n\n\n목적:\n\n- ListFooterComponentStyle prop을 사용하면 ListFooterComponent를 포함하는 내부 뷰에 사용자 정의 스타일을 적용할 수 있습니다. 이를 통해 목록 내의 footer 영역의 모양과 레이아웃을 제어할 수 있습니다.\n\n사용 방법:\n\n- StyleSheet를 Import하세요:\n\n\n\n```js\nimport { StyleSheet } from 'react-native';\n```\n\n2. 스타일 생성:\n\n```js\nconst styles = StyleSheet.create({\n    footerContainer: {\n        backgroundColor: 'lightblue',\n        padding: 20,\n        alignItems: 'center' \n    }\n});\n```\n\n3. FlatList에 적용하기:\n\n\n\n```js\n<FlatList\n    // ... 다른 FlatList 속성들\n    ListFooterComponent={footerComponent}\n    ListFooterComponentStyle={styles.footerContainer}\n/>\n```\n\n스타일링 제어:\n\n- ListFooterComponentStyle 속성은 유효한 View 스타일 속성을 받습니다. 다음과 같이 사용자 정의할 수 있습니다:\n- 레이아웃: flex, flexDirection, justifyContent, alignItems 등\n- 배경: backgroundColor\n- 크기: height, width, padding, margin\n- 테두리: borderWidth, borderColor, borderRadius\n- ... 그 외 등등!\n\n중요한 고려 사항:\n\n\n\n- 내부 뷰: ListFooterComponent를 보유하는 컨테이너를 스타일링하고 있습니다. 컴포넌트 자체를 스타일링하고 있지 않습니다.\n- 컴포넌트 스타일링: 필요하다면 ListFooterComponent를 따로 스타일링하세요.\n\n예시:\n\n화면 하단에 고정된 푸터를 원한다면:\n\n```js\nListFooterComponentStyle={ \n    position: 'absolute',\n    bottom: 0,\n    left: 0,\n    right: 0\n}\n```\n\n\n\n팁\n\n- 지금까지 보여준 대로 스타일 시트를 사용하여 구성된 스타일링을 하세요.\n- 원하는 푸터 레이아웃과 외관을 얻기 위해 실험해보세요!\n- ListFooterComponentStyle: ListFooterComponent를 보유하는 컨테이너에 스타일을 적용합니다.\n- ListHeaderComponentStyle: ListHeaderComponent를 보유하는 컨테이너에 스타일을 적용합니다.\n- columnWrapperStyle: numColumns를 사용하는 경우 다중 항목 행의 스타일을 사용자 정의합니다.\n\n스타일링에 대한 중요한 참고 사항\n\n- 이러한 props은 레이아웃, 테두리, 배경 등을 사용자 정의하기 위한 유효한 ViewStyle 속성을 수용합니다.\n- 일반적으로 헤더, 푸터 및 항목 구성 요소를 내부 콘텐츠에 대해 별도로 스타일링할 것입니다.\n\n\n\n기타 중요한 속성들\n\n좀 더 복잡하거나 자주 사용되는 몇 가지 속성들을 알아보겠습니다:\n\n- **extraData:**\n  - 주요 데이터 속성 외부의 데이터가 변경될 때 FlatList(순수 컴포넌트)에게 다시 렌더링하도록 지시합니다.\n  - 항목 자체가 아닌 다른 요소에 기반한 동적 업데이트에 유용합니다(예: 컴포넌트 내 선택된 상태 등).\n- **getItemLayout:**\n  - 최적화: 성능 향상을 위해 항목의 높이와 오프셋을 미리 계산하여 크기가 고정된 항목의 목록에 사용됩니다.\n- **horizontal:**\n  - 목록의 레이아웃을 가로 스크롤링으로 전환합니다.\n- **initialNumToRender:**\n  - 초기 경험을 더 부드럽게 하기 위해 처음에 렌더링할 항목 수를 지정합니다.\n- **inverted:**\n  - 목록의 방향을 반대로 바꿉니다.\n- **keyExtractor:**\n  - 항목에 대한 고유한 키를 제공하여 React의 렌더링 효율성을 유지합니다.\n- **numColumns:**\n  - 다중 열 그리드 레이아웃을 만듭니다.\n- **onRefresh & refreshing:**\n  - \"당겨서 새로고침\" 기능을 구현합니다.\n- **onViewableItemsChanged:**\n  - 항목 가시성이 변경될 때 트리거되는 콜백 함수(게으른 로딩과 같은 작업에 유용)입니다.\n- **viewabilityConfig:**\n  - onViewableItemsChanged 콜백이 트리거되는 조건을 세밀하게 조정합니다(가시성 임계값 등).\n\n큰 목록을 최적화하기\n\n\n\n### onViewableItemsChanged\n\n**도전 과제:** FlatList를 사용하여 오래된 버전이나 성능이 떨어지는 장치에서 특히 많은 데이터 목록을 표시할 때 성능 문제를 겪을 수 있습니다. 한꺼번에 많은 항목을 렌더링하면 장치에 과부하가 걸려 스크롤이 느려지거나 프레임이 떨어질 수 있습니다.\n\n**해결책:** React Native의 FlatList 컴포넌트는 이러한 성능 문제를 해결하기 위해 설계된 onViewableItemsChanged라는 강력한 속성을 제공합니다. 이는 목록 내 항목의 가시성이 변경될 때마다 호출되는 콜백 함수를 제공합니다. 이를 통해 다음과 같은 최적화를 전략적으로 구현할 수 있습니다:\n\n- **지연 로딩:** 사용자가 목록 끝에 접근할 때만 추가 데이터를 가져와 렌더링합니다.\n- **미디어 제어:** 비디오가 뷰포트를 벗어나거나 들어올 때 비디오를 일시 정지하거나 재생하여 자원을 절약합니다.\n- **선택적 업데이트:** 현재 가시 상태인 항목에 따라 FlatList 바깥쪽의 UI 일부를 업데이트합니다.\n\n\n\n`onViewableItemsChanged` Prop에 대해 설명드리겠습니다.\n\n함수 서명:\n\n```js\nonViewableItemsChanged: ({ changed, viewableItems }) => void\n```\n\n- changed: ViewToken 객체의 배열입니다. 각 객체는 특정 항목의 가시성 변경을 설명합니다.\n- viewableItems: 현재 뷰포트 내에서 실제로 보이는 항목을 나타내는 ViewToken 객체의 배열입니다.\n\n\n\nViewToken 구조:\n\n- index: 데이터 배열 내 항목의 인덱스입니다.\n- isViewable: 해당 항목이 보이는 영역 내에 있는 경우 true이고, 그렇지 않으면 false인 부울 값입니다.\n- key: 항목에 제공한 고유한 키입니다.\n- (기타 속성 가능): ViewToken은 viewabilityConfig에 기반한 추가 속성을 가질 수 있습니다.\n\n키 구성 옵션 (viewabilityConfig)\n\n- viewAreaCoveragePercentThreshold: 콜백을 트리거하기 위해 항목의 영역 중 얼마나 비춰져 있어야 하는지 결정하는 숫자 (예: 50).\n- itemVisiblePercentThreshold: 화면에 표시되어야 하는 항목의 얼마나 많은 부분을 제어하는 숫자 (항목의 높이가 다른 목록에 유용).\n- minimumViewTime: 항목이 \"보이는\" 것으로 간주되기 전에 보이는 지속 시간을 설정하는 밀리초 단위의 값입니다.\n- waitForInteraction: true인 경우 사용자가 목록과 상호 작용한 후까지 가시성 업데이트를 지연시켜 빠른 스크롤 중에 성능을 향상시킵니다.\n\n\n\n실용적인 예시: 무한 스크롤링\n\n```js\nconst handleViewableItemsChanged = ({ viewableItems }) => {\n  const isLastItemVisible = viewableItems[viewableItems.length - 1].isViewable;\n  if (isLastItemVisible && !isLoading) {  \n    loadMoreData(); \n  }\n};\n\n<FlatList\n    data={data}\n    onViewableItemsChanged={handleViewableItemsChanged}\n    viewabilityConfig={{ viewAreaCoveragePercentThreshold: 50 }} \n    // ... 다른 FlatList 속성들\n/>\n```\n\n주의사항\n\n- 트레이드오프(Trade-offs): onViewableItemsChanged 내부에 과도하게 복잡한 계산을 포함하는 것은 성능에 영향을 줄 수 있습니다. 콜백을 트리거하는 방법을 세밀하게 조정하기 위해 viewabilityConfig을 사용하세요.\n- 실제 최적화 예시: 매우 복잡한 시나리오에서는 onViewableItemsChanged를 getItemLayout과 결합하여 아이템 크기를 사전 계산하여 더 부드러운 스크롤링을 구현할 수 있습니다.\n\n\n\n## 스크롤 및 제어를 위한 주요 FlatList 메서드\n\n메서드 설명\n\n- flashScrollIndicators()\n- 목적: 스크롤 표시기(스크롤바)를 잠시 표시하여 사용자에게 시각적 피드백을 제공합니다.\n- 사용 사례: 목록 끝에 새 데이터를로드 한 후나 프로그래밍 방식으로 위치로 스크롤하는 경우에 사용합니다.\n- 예시:\n\n```js\nmyListRef.current.flashScrollIndicators();\n```\n\n\n\n- getNativeScrollRef()\n  - 목적: 기본 네이티브 스크롤 컴포넌트(예: ScrollView 또는 VirtualizedList)에 대한 참조를 제공합니다.\n  - 사용 사례: 절대적으로 필요한 경우에만 스크롤 컴포넌트의 하위 수준 사용자 정의를 위해 이에 액세스합니다. (대부분의 경우, 이는 필요하지 않을 것입니다).\n- getScrollResponder()\n  - 목적: 스크롤 상호작용을 관리하는 스크롤 응답자 객체에 대한 참조를 반환합니다.\n  - 사용 사례: 스크롤 동작을 세밀하게 조정하거나 특정 스크롤 이벤트에 응답해야 하는 고급 시나리오에서 사용합니다.\n- getScrollableNode()\n  - 목적: 스크롤 가능한 컴포넌트 자체에 대한 참조를 제공합니다.\n  - 사용 사례: 거의 필요하지 않습니다. 주로 스크롤 가능한 노드에서 직접 메서드를 호출해야 할 경우에 유용합니다.\n- scrollToEnd(params?: ' animated?: boolean ')\n  - 목적: 콘텐츠의 맨 끝(또는 목록이 수평인 경우 하단)으로 스크롤합니다.\n  - 옵션:\n    - animated (boolean, 기본: true): 스크롤을 애니메이션으로 제어할지 여부를 결정합니다.\n  - 예시:\n\n```js\nconst scrollToEnd = () => {\n    flatListRef.current.scrollToEnd({ animated: true }); \n};\n```\n\n* **중요:** 큰 목록의 경우, 부드럽고 효율적인 스크롤링을 위해 `getItemLayout` 속성을 사용하는지 확인하십시오.\n\nscrollToIndex(params: ' animated?: boolean; index: number; viewOffset?: number; viewPosition?: number; ')\n\n\n\n\n- 목적: 데이터 배열 내에서 특정 항목의 인덱스(위치)로 스크롤합니다.\n- 옵션:\n  - animated (boolean, 기본값: true): 애니메이션을 컨트롤합니다.\n  - index (number): 스크롤할 항목의 인덱스입니다.\n  - viewOffset (number): 픽셀 단위의 추가 오프셋입니다.\n  - viewPosition (number): 뷰포트 내 항목의 위치를 제어합니다 (0: 맨 위, 1: 맨 아래, 0.5: 중앙).\n- 예시:\n\n```js\nconst scrollToRecipe = (index) => {\n  flatListRef.current.scrollToIndex({ index, viewPosition: 0 }); // 화면 맨 위에 있는 항목의 맨 위로 스크롤\n};\n```\n\n- **강조:** 성능 개선을 위해 특정 항목으로 스크롤하는 우선적인 방법입니다.\n\nscrollToItem(params: ' animated?: boolean; item: Item; viewPosition?: number; ')\n\n\n\n- 목적: 데이터에서 아이템 객체를 제공하여 해당 항목으로 스크롤합니다.\n- 단점: 특히 대규모 목록의 경우 scrollToIndex보다 효율성이 떨어질 수 있으며 데이터 배열을 검색해야 할 수도 있습니다.\n- 참고: 가능하면 최상의 성능을 위해 scrollToIndex를 선택하십시오.\n\n## 이론을 실제로 구현하기: React Native의 FlatList를 활용한 인터랙티브 레시피 앱 제작\n\nFlatListDemonstration.jsx\n\n```js\nimport React, { useState, useCallback } from 'react';\nimport {\n  SafeAreaView,\n  FlatList,\n  Text,\n  TouchableOpacity,\n  ActivityIndicator,\n  RefreshControl,\n  StyleSheet,\n  TextInput,\n  View,\n} from 'react-native';\nimport recipesData from '../data/recipeData'; // 데이터가 올바르게 형식화되었는지 확인\nimport { useNavigation } from '@react-navigation/native';\n\nconst FlatListDemonstration = () => {\n  const navigation = useNavigation();\n  const [recipes, setRecipes] = useState(recipesData);\n  const [isFetching, setIsFetching] = useState(false);\n  const [refreshing, setRefreshing] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n\n  const toggleFavorite = (id) => {\n    const newRecipes = recipes.map(recipe =>\n      recipe.id === id ? { ...recipe, isFavorite: !recipe.isFavorite } : recipe,\n    );\n    setRecipes(newRecipes);\n    navigation.navigate('Favorites', {\n      recipes: newRecipes.filter(r => r.isFavorite),\n    });\n  };\n\n  const handleSearch = (text) => {\n    setSearchQuery(text);\n    const filteredData = text\n      ? recipes.filter(recipe =>\n          recipe.name.toLowerCase().includes(text.toLowerCase()),\n        )\n      : recipesData;\n    setRecipes(filteredData);\n  };\n\n  const onRefresh = useCallback(async () => {\n    setRefreshing(true);\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    setRefreshing(false);\n  }, []);\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <TextInput\n        style={styles.searchBar}\n        placeholder=\"레시피 검색...\"\n        value={searchQuery}\n        onChangeText={handleSearch}\n      />\n      <FlatList\n        data={recipes}\n        renderItem={({ item }) => (\n          <View style={styles.item}>\n            <Text style={styles.title}>{item.name}</Text>\n            <View style={styles.actionArea}>\n              <TouchableOpacity onPress={() => toggleFavorite(item.id)}>\n                <Text style={styles.favorite}>\n                  {item.isFavorite ? '♥' : '☆'}\n                </Text>\n              </TouchableOpacity>\n              <TouchableOpacity\n                onPress={() =>\n                  navigation.navigate('RecipeDetails', { recipe: item })\n                }>\n                <Text style={styles.detailsButton}>세부 정보</Text>\n              </TouchableOpacity>\n            </View>\n          </View>\n        )}\n        keyExtractor={item => item.id.toString()}\n        refreshControl={\n          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />\n        }\n      />\n    </SafeAreaView>\n  );\n};\n\nexport default FlatListDemonstration;\n```\n\n\n\n<img src=\"/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_1.png\" />\n\nRecipeDetailsScreen.jsx\n\n```js\nimport React from 'react';\nimport {View, Text, StyleSheet, ScrollView} from 'react-native';\n\nconst RecipeDetailsScreen = ({route}) => {\n  const {recipe} = route.params;\n\n  return (\n    <ScrollView style={styles.container}>\n      <Text style={styles.title}>{recipe.name}</Text>\n      <Text style={styles.description}>{recipe.description}</Text>\n      <View style={styles.section}>\n        <Text style={styles.header}>재료</Text>\n        {recipe.ingredients.map((ingredient, index) => (\n          <Text key={index} style={styles.text}>\n            {ingredient.name}: {ingredient.quantity}\n          </Text>\n        ))}\n      </View>\n      <View style={styles.section}>\n        <Text style={styles.header}>조리 방법</Text>\n        {recipe.instructions.map((step, index) => (\n          <Text key={index} style={styles.text}>\n            {index + 1}. {step}\n          </Text>\n        ))}\n      </View>\n    </ScrollView>\n  );\n};\r\n```\n\n<img src=\"/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_2.png\" />\n\n\n\nFavouriteList.jsx\n\n```js\nimport React, {useState} from 'react';\nimport {View, Text, TouchableOpacity, Image, StyleSheet} from 'react-native';\nimport DraggableFlatList from 'react-native-draggable-flatlist';\nimport {GestureHandlerRootView} from 'react-native-gesture-handler';\nimport {useNavigation} from '@react-navigation/native';\nconst FavoriteList = ({route}) => {\n    const navigation = useNavigation();\n    const {recipes} = route.params;\n    const [favorites, setFavorites] = useState(recipes);\n\n    return (\n        <GestureHandlerRootView style={styles.rootView}>\n            <View style={styles.container}>\n                <DraggableFlatList\n                    data={favorites}\n                    renderItem={({item, drag, isActive}) => (\n                        <TouchableOpacity\n                            onLongPress={drag}\n                            style={[styles.card, isActive && styles.activeCard]}\n                        >\n                            <Image\n                                source={item.image}\n                                style={styles.recipeImage}\n                                accessibilityLabel={`Image of ${item.name}`}\n                            />\n                            <View style={styles.textContainer}>\n                                <Text style={styles.recipeTitle}>{item.name}</Text>\n                                <Text style={styles.recipeDescription}>{item.description}</Text>\n                                <TouchableOpacity  style={styles.detailsButton}  onPress={() =>\n                                    navigation.navigate('RecipeDetails', {recipe: item})}\n                                >\n                                    <Text style={styles.detailsButtonText}>View Details</Text>\n                                </TouchableOpacity>\n                            </View>\n                        </TouchableOpacity>\n                    )}\n                    keyExtractor={item => item.id.toString()}\n                    onDragEnd={({data}) => setFavorites(data)}\n                />\n            </View>\n        </GestureHandlerRootView>\n    );\n};\n```\n\n![Image 1](/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_3.png)\n\n![Image 2](/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_4.png)\n\n\n\n\nApp.jsx\n\n```js\nimport React from 'react';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport FlatListDemonstration from './src/components/flatlist';\nimport RecipeDetailsScreen from './src/screens/RecipeDetailsScreen';\n\nimport FavoriteList from './src/components/FavoriteList';\n\nconst Stack = createNativeStackNavigator();\n\nconst App = () => {\n  return (\n      <NavigationContainer>\n        <Stack.Navigator initialRouteName=\"Home\">\n          <Stack.Screen\n            name=\"Home\"\n            component={FlatListDemonstration} // 홈 화면에 FlatListDemonstration 사용\n            options={{ title: 'Recipe List' }}\n          />\n\n          <Stack.Screen\n            name=\"RecipeDetails\"\n            component={RecipeDetailsScreen}\n            options={{ title: 'Recipe Details' }}\n          />\n          \n          <Stack.Screen name=\"Favorites\" component={FavoriteList} options={{ title: 'Favorite Recipes' }} />\n      \n        </Stack.Navigator>\n      </NavigationContainer>\n  );\n};\n\nexport default App;\n```\n\n컴포넌트와 역할:\n\n- FlatListDemonstration: 레시피 목록을 렌더링하는 주요 컴포넌트입니다. 레시피 데이터, 사용자 상호작용(검색, 즐겨찾기), 다른 화면으로의 이동을 관리합니다.\n- FavoriteList: DraggableFlatList 라이브러리를 사용하여 즐겨찾은 레시피 목록을 표시하는 컴포넌트로, 사용자가 순서를 변경할 수 있습니다.\n- RecipeDetailsScreen: FlatList에서 항목을 탭하면 특정 레시피의 세부 정보를 표시하는 컴포넌트입니다.\n\n\n\nFlatList와 관련된 주요 기능:\n\n- 상태 관리 (useState):\n  - 컴포넌트는 여러 상태 변수를 유지합니다:\n    - recipes: 레시피 데이터 배열을 보유합니다.\n    - isFetching: 데이터를 가져오는지 추적합니다 (풀 투 리프레시를 위한 가능성 있음).\n    - refreshing: 데이터 가져오는 동안 시각적 리프레시 인디케이터를 제어합니다.\n    - searchQuery: 사용자가 입력한 현재 검색어를 저장합니다.\n  - toggleFavorite 함수는 사용자가 레시피 항목의 즐겨찾기 버튼을 탭할 때 트리거됩니다. 이 함수는 특정 레시피를 찾아 isFavorite 속성을 토글하고, 필요에 따라 즐겨찾기 화면으로 이동을 트리거합니다.\n  - handleSearch 함수는 검색 바에서 사용자 입력에 따라 searchQuery 상태를 업데이트합니다. 그런 다음 검색어와 일치하는 레시피 데이터만 표시하기 위해 recipes 데이터를 필터링합니다.\n- 검색 기능:\n  - 검색 바를 사용하여 레시피 목록을 동적으로 필터링할 수 있습니다.\n  - 사용자가 검색 바에 입력할 때 handleSearch 함수가 호출되어 searchQuery 상태를 업데이트합니다.\n  - handleSearch 함수는 filter 메서드를 사용하여 recipes 데이터를 필터링합니다. 검색어의 소문자 버전을 포함하는 레시피 이름을 가진 레시피만 유지합니다.\n  - 필터링된 데이터는 새로운 recipes 상태로 설정되어 FlatList가 업데이트된 목록으로 다시 렌더링됩니다.\n- 내비게이션 (@react-navigation/native):\n  - 이 예제는 화면 간 부드러운 내비게이션을 위해 @react-navigation/native를 사용합니다.\n  - 레시피 항목을 누르면 toggleFavorite 함수가 호출되며, 레시피가 즐겨찾기 상태인 경우 즐겨찾기 화면으로 이동할 수 있습니다.\n  - \"자세히 보기\" 버튼을 누르면 navigation.navigate(`RecipeDetails`, 'recipe: item')이 호출되어 선택한 레시피 데이터를 매개변수로 전달하여 RecipeDetailsScreen을 내비게이션 스택에 푸시합니다.\n- 풀 투 리프레시 (RefreshControl):\n  - 풀 투 리프레시 기능을 구현하기 위해 RefreshControl 컴포넌트를 사용합니다.\n  - 사용자가 목록 상단에서 아래로 스와이프하면 onRefresh 함수가 호출됩니다.\n  - 이 예제에서 onRefresh는 데이터 가져오기를 모방하기 위해 1.5초 지연을 시뮬레이션하고, 그 후 refreshing 상태를 업데이트하여 리프레시 인디케이터를 끕니다.\n  - 실제 앱에서는 onRefresh가 아마도 API에서 새 데이터를 가져오고 recipes 상태를 그에 맞게 업데이트할 것입니다.\n\n더 많은 정보를 보려면 공식 문서를 방문해주세요: https://reactnative.dev/docs/flatlist\n\n이 글을 읽어주셔서 정말 감사합니다! 여러분의 지원과 관심이 저에게는 큰 힘이 됩니다. 유용하게 여기셨다면, 이를 즐길 수 있는 다른 사람들과 공유해보시기를 권장드립니다. 더 많은 통찰과 팁을 기대해주세요. 📚💖 우리 커뮤니티의 멋진 일원이 되어 주셔서 다시 한번 감사드립니다! 🌟\n\n\n\n# 스택데믹 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 응원하고 팔로우해 주세요! 👏\n- 저희를 팔로우하세요 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼들도 방문해 주세요: In Plain English | CoFeed | Venture | Cubed\n- 스택데믹닷컴에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_0.png"},"coverImage":"/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_0.png","tag":["Tech"],"readingTime":26},{"title":"마이크로 프론트엔드를 탐구하며 React  Vite로 구현하기","description":"","date":"2024-05-12 18:46","slug":"2024-05-12-ExploringMicroFrontendsandImplementationwithReactVite","content":"\n\n![이미지](/assets/img/2024-05-12-ExploringMicroFrontendsandImplementationwithReactVite_0.png)\n\n마이크로 프론트엔드는 현대적인 웹 애플리케이션을 구축하기 위한 확장 가능한 프레임워크로 점점 더 인기를 얻고 있습니다. 이 방법론은 팀이 독립적인 특징이나 구성 요소를 구축, 배포 및 확장할 수 있게 함으로써 증진된 협력과 지속가능성을 육성합니다. 이 기사에서는 마이크로 프론트엔드가 무엇인지, 그리고 React와 Vite를 활용한 마이크로 프론트엔드의 기본 구현을 탐색할 것입니다.\n\n## 안내\n\n- 마이크로 프론트엔드란 무엇인가요?\n- 예시: 전통적인 전자 상거래 프론트엔드 애플리케이션\n- 예시: 마이크로 프론트엔드를 활용한 전자 상거래\n- 마이크로 프론트엔드 프로젝트 설정\n- 프로젝트 실행\n- 결론\n\n\n\n## 마이크로 프론트엔드\n\n백엔드 팀에서 백엔드를 구축하기 위해 마이크로서비스 접근 방식을 사용한다고 들어 보았을 수 있습니다. 그렇다면 같은 방식을 프론트 엔드 구축에도 사용할 수 있다면 어떨까요?\n\n이렇게 하면 팀이 개별적으로 작업할 수 있고, 코드베이스에서 충돌이 적어지며, 그 충돌을 해결하는 데 걸리는 시간을 줄일 수 있는 등 여러 가지 이점을 얻을 수 있습니다.\n\n프론트엔드 세계에서 마이크로서비스의 확장 개념은 마이크로 프론트엔드라고 불립니다. 예를 들어 React를 사용하여 구축된 전자 상거래 프론트 엔드 애플리케이션을 살펴보며 용어 '마이크로 프론트엔드'를 이해해 봅시다.\n\n\n\n## 전통적인 전자 상거래 프런트 엔드 응용 프로그램\n\n일반적으로 프런트엔드 응용 프로그램을 구축할 때는 구성 요소, 자산, 라우팅 및 프런트엔드에 필요한 비즈니스 로직을 모든 코드베이스에 작성한 후 서버에서 제공됩니다. 그러나 현재 대부분의 조직에서 사용하는 다양한 JavaScript UI 프레임워크의 등장으로 이 프레임워크에는 제한 사항이나 단점이 있습니다. 예를 들어, 응용 프로그램이 커질수록 브라우저의 로드 시간이 증가합니다.\n\n![이미지](/assets/img/2024-05-12-ExploringMicroFrontendsandImplementationwithReactVite_1.png)\n\nReact를 사용하여 구축된 전자 상거래 앱을 고려해 보세요. 제품 검색, 구매 및 주문 추적과 같은 기능이 포함되어 있습니다. 모놀리식 프런트엔드 응용 프로그램에서 이러한 페이지들이 포함될 것입니다.\n\n\n\n리액트 전자 상거래 애플리케이션이 메인 JavaScript 청크에 구축되어 있습니다. 누군가 사이트를 방문할 때 브라우저에 의해로드됩니다. 사용자는 전체 프론트엔드 애플리케이션을 포함한 모든 JavaScript 파일을 다운로드하기까지 기다려야 합니다. 이로 인해 애플리케이션의 초기 로드 시간이 크게 증가할 수 있습니다.\n\n이 로드 시간 문제를 마이크로 프론트엔드로 해결할 수 있습니다.\n\n## 마이크로 프론트엔드와 전자 상거래\n\n전자 상거래 애플리케이션을 고려해 봅시다. 사용자가 제품을 검색하기 위해 애플리케이션에 들어올 경우, 브라우저는 모든 코드를 다운로드할 필요가 없습니다. 대신, 사용자가 필요로 하는 부분을 사용할 수 있어야 합니다. 심지어 다른 부분은 그들에게 관련이 없더라도요.\n\n\n\n동일한 애플리케이션을 마이크로 프론트엔드 접근 방식을 사용하여 구축할 수 있습니다. 마이크로 프론트엔드 접근 방식은 전체 큰 애플리케이션을 제공하는 기능에 따라 세분화하여 각각 개별적으로 구축하는 간단한 아이디어입니다. 이렇게 하면 팀원들이 자신이 구축 중인 기능에 대해 더 잘 이해할 수 있고 해당 기능에 대해서만 책임질 수 있습니다.\n\n따라서 전자 상거래 애플리케이션을 제품, 주문 및 배송 기능으로 나눌 수 있습니다. 제품 마이크로 프론트엔드 애플리케이션은 제품 목록 및 검색과 관련된 UI만 렌더링합니다. 주문 마이크로 프론트엔드 애플리케이션은 주문 관련 UI에 책임을 지고 있으며, 배송 마이크로 프론트엔드는 제품 추적 기능에 책임이 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/0*sA7aQvM473L0-qOW.gif)\n\n이 애플리케이션을 작은 부분으로 나누기 때문에 이러한 작은 앱들을 병합하거나 통합하여 주 애플리케이션으로 작동할 수 있어야 합니다. 사용자 입력에 따라 이러한 작은 앱들을 통합하고 렌더링하는 책임을 지게 될 host라는 주 메인 애플리케이션을 구축할 수 있습니다.\n\n\n\n다양한 서브 애플리케이션을 통합하는 다른 방법들이 있습니다. 빌드 시간 통합, 실행 시간 통합, 서버 측 통합 등이 있어요. 이것은 마이크로 프론트엔드가 무엇인지에 대한 개요를 제공합니다.\n\n## 마이크로 프론트엔드 프로젝트 설정\n\n이 프로젝트에서는 호스트/애플리케이션을 설정하고, 2개의 리액트 컴포넌트 remote-a 및 remote-b를 호스팅하고 있습니다. 그리고 host로 호스트하고 있어요.\n\n```js\n# 모든 애플리케이션을 담을 폴더 생성\nmkdir vite-react-micro-frontend \ncd vite-react-micro-frontend\n\n# 호스트 애플리케이션 생성\nnpx create-vite host --template react\ncd host\nnpm install\nnpm install @originjs/vite-plugin-federation --save-dev\ncd ..\n\n# remote-a 애플리케이션 생성\nnpx create-vite remote-a --template react\ncd remote-a\nnpm install\nnpm install @originjs/vite-plugin-federation --save-dev\ncd ..\n\n# remote-b 애플리케이션 생성\nnpx create-vite remote-b --template react\ncd remote-b\nnpm install\nnpm install @originjs/vite-plugin-federation --save-dev\ncd ..\n\n# Visual Code 편집기를 해당 폴더에서 열기\ncode .\n```\n\n\n\n이제 세 개의 React 앱이 생성되었습니다.\n\n계속하기 위해 두 개의 원격 애플리케이션의 vite.config.js 파일을 수정해야 합니다.\n\nremote-a의 경우 vite.config.js 파일을 수정할 수 있습니다.\n\n```js\n// remote-a/vite.config.js\n\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport federation from '@originjs/vite-plugin-federation'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    react(),\n    federation({\n      name: \"remote_a\",\n      filename: \"remoteEntry.js\",\n      exposes: {\n        \"./App\": \"./src/App\",\n      },\n      shared: [\"react\", \"react-dom\"],\n    })\n  ],\n  build: {\n    modulePreload: false,\n    target: \"esnext\",\n    minify: false,\n    cssCodeSplit: false,\n  },\n})\n```\n\n\n\n\nFor remote-b, we can amend the `vite.config.js` file as follows:\n\n```js\n// remote-a/vite.config.js\n\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport federation from '@originjs/vite-plugin-federation'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    react(),\n    federation({\n      name: \"remote_b\",\n      filename: \"remoteEntry.js\",\n      exposes: {\n        \"./App\": \"./src/App\",\n      },\n      shared: [\"react\", \"react-dom\"],\n    })\n  ],\n  build: {\n    modulePreload: false,\n    target: \"esnext\",\n    minify: false,\n    cssCodeSplit: false,\n  },\n})\n```\n\nTo make the same modification for remote-b's project, you should edit the `vite.config.js` file. The only difference is the name of the federation. Make sure to change it accordingly.\n\nNext, navigate to the `package.json` file and define a separate port for each remote project. Remember, only one project can run on each port.\n\n\n\n지금은 package.json의 remote-a를 다음과 같이 유지하고 있어요:\n\n```js\n{\n  \"name\": \"remote-a\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite --port 2020\",\n    \"build\": \"vite build\",\n    \"lint\": \"eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0\",\n    \"preview\": \"vite preview --port 2020\"\n  },\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@originjs/vite-plugin-federation\": \"^1.3.5\",\n    \"@types/react\": \"^18.2.66\",\n    \"@types/react-dom\": \"^18.2.22\",\n    \"@vitejs/plugin-react\": \"^4.2.1\",\n    \"eslint\": \"^8.57.0\",\n    \"eslint-plugin-react\": \"^7.34.1\",\n    \"eslint-plugin-react-hooks\": \"^4.6.0\",\n    \"eslint-plugin-react-refresh\": \"^0.4.6\",\n    \"vite\": \"^5.2.10\"\n  }\n}\n```\n\n그리고 remote-b의 package.json은 다음과 같아요:\n\n```js\n{\n  \"name\": \"remote-b\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite --port 4000\",\n    \"build\": \"vite build\",\n    \"lint\": \"eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0\",\n    \"preview\": \"vite preview --port 4000\"\n  },\n  \"dependencies\": {\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@originjs/vite-plugin-federation\": \"^1.3.5\",\n    \"@types/react\": \"^18.2.66\",\n    \"@types/react-dom\": \"^18.2.22\",\n    \"@vitejs/plugin-react\": \"^4.2.1\",\n    \"eslint\": \"^8.57.0\",\n    \"eslint-plugin-react\": \"^7.34.1\",\n    \"eslint-plugin-react-hooks\": \"^4.6.0\",\n    \"eslint-plugin-react-refresh\": \"^0.4.6\",\n    \"vite\": \"^5.2.0\"\n  }\n}\n```\n\n\n\n지금 React 앱을 호스트하게 변경해주세요. 호스트의 프로젝트인 vite.config.js 파일을 수정해야 합니다.\n\n```js\n// host/vite.config.js\n\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport federation from '@originjs/vite-plugin-federation'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    react(),\n    federation({\n      name: \"app\",\n      remotes: {\n        remoteA: \"http://localhost:2020/assets/remoteEntry.js\",\n        remoteB: \"http://localhost:4000/assets/remoteEntry.js\",\n      },\n      shared: [\"react\", \"react-dom\"]\n    })\n  ],\n})\n```\n\n이제 host 프로젝트로 remoteA와 remoteB를 가져올 수 있습니다. 시연 목적으로, host의 App.js 파일에 remoteA와 remoteB를 가져올 것입니다. 아래 코드에서 확인할 수 있습니다.\n\n```js\nimport { useState } from 'react'\nimport reactLogo from './assets/react.svg'\nimport viteLogo from '/vite.svg'\nimport './App.css'\nimport RemoteA from \"remoteA/App\"\nimport RemoteB from \"remoteB/App\"\n\nfunction App() {\n  const [count, setCount] = useState(0)\n  return (\n    <>\n      <section>\n        <div>\n          <div>\n            <a href=\"https://vitejs.dev\" target=\"_blank\">\n              <img src={viteLogo} className=\"logo\" alt=\"Vite 로고\" />\n            </a>\n            <a href=\"https://react.dev\" target=\"_blank\">\n              <img src={reactLogo} className=\"logo react\" alt=\"React 로고\" />\n            </a>\n          </div>\n          <h1>호스트</h1>\n          <div className=\"card\">\n            <button onClick={() => setCount((count) => count + 1)}>\n              현재 카운트: {count}\n            </button>\n            <p>\n              <code>src/App.jsx</code>를 편집하고 저장하여 HMR을 테스트하세요.\n            </p>\n          </div>\n          <p className=\"read-the-docs\">\n            Vite 및 React 로고를 클릭하여 더 많이 알아보세요.\n          </p>\n        </div>\n      </section>\n      <section><RemoteA /></section>\n      <section><RemoteB /></section>\n    </>\n  )\n}\n\nexport default App\n```\n\n\n\n## 프로젝트 실행하기\n\n원격 서버 A와 원격 서버 B의 터미널로 이동하여 프로젝트를 빌드하고 정적 빌드 프로젝트를 제공하세요.\n\n```js\nnpm run build\nnpm run preview\n```\n\n이렇게 하면 몇 가지 Js 파일이 생성되고 어플리케이션을 미리보기할 수 있는 URL이 제공됩니다. 해당 URL을 브라우저에서 열어보세요.\n\n\n\n호스트 앱을 실행하세요. 호스트 앱 터미널로 이동해서 다음 명령어를 입력한 후 엔터 키를 누르세요.\n\n```js\nnpm run dev\n```\n\n이제 원격 앱인 remote-a 및 remote-b 앱이 호스트 앱 내에서 추가 구성 요소로 원활하게 통합되는 것을 관찰하세요. 이것은 Micro Frontends의 우아함을 보여줍니다. 호스트 애플리케이션은 이러한 원격 구성 요소를 동적으로 검색하고 통합합니다.\n\n저는 세 가지 다른 React 애플리케이션인 remote-a, remote-b 및 호스트 애플리케이션을 통합된 환경 내에서 운영하는 것을 보여줬습니다. 이것은 Micro Frontends 패러다임의 대표적 예시입니다. 이 React 애플리케이션을 개발할 때 어떤 거대한 프레임워크도 사용하지 않아서 명확성을 유지하기 위해 그랬습니다. 자유롭게 시도해보세요. 솔직히 말해서, 저도 React+Vite로 Micro Frontends를 처음 사용해봅니다.\n\n\n\n## 결론\n\n마지막으로, React와 Vite를 활용하여 @originjs/vite-plugin-federation이 향상시킨 Micro Frontends의 구축은 웹 애플리케이션 개발을 위한 모듈식이며 확장 가능한 프레임워크를 제공합니다. 이 방법론은 팀이 다양한 프로젝트 구성 요소에 대해 독립적으로 작업하고 협업 및 지속가능성을 촉진할 수 있습니다. 이 설정을 실험해보면 웹 개발 활동에서 Micro Frontends의 유연성과 견고함을 직접 체험할 수 있습니다.\n\n마지막까지 읽어 주셔서 감사합니다.\n\n더 많이 알고 싶다면 저를 소개하는 링크를 통해 연락해 주세요.\n\n\n\n제 다음 블로그를 게시할 때 알림을 받으려면 구독해 주세요. 다음에 또 만나요! \n\n# 쉽고 명료한 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어줘서 감사합니다! 떠나시기 전에:\n\n- 반드시 박수를 보내고 작가를 팔로우해 주세요️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼에서도 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-ExploringMicroFrontendsandImplementationwithReactVite_0.png"},"coverImage":"/assets/img/2024-05-12-ExploringMicroFrontendsandImplementationwithReactVite_0.png","tag":["Tech"],"readingTime":10},{"title":"iFrame가 리스너를 제거하고 React는 알지 못한다 ","description":"","date":"2024-05-12 18:44","slug":"2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit","content":"\n\n# 개요\n\n이 기사에서는 부모 창과 자식 iFrame 간에 메시지를 보내는 방법을 보여드리고 싶어요. 이 과정에서 iFrame이 리스너를 어떻게 지우는지에 대해 흥미로운 점을 발견했어요. 걱정하지 마세요, 나아가면서 스크린샷을 게시할 거에요. [GitHub 링크](https://github.com)\n\n즐겁게 공부하세요!\n\n# iFrame이란 무엇인가요?\n\n\n\niFrame 또는 인라인 프레임은 부모 웹페이지 내에 다른 문서를 로드하는 HTML 요소입니다.\n\n# iFrame을 사용하는 곳은 어디인가요?\n\niFrame은 이미 있는 HTML 안에 HTML을 포함시키고 싶을 때나 신뢰할 수 없거나 제3자 스크립트를 백그라운드에서 실행하고 싶을 때 사용합니다. 즉, 광고 섹션을 웹사이트에 표시하거나 YouTube 비디오를 넣고 싶을 때 iFrame을 사용할 수 있습니다. 주로 iFrame을 사용하는 경우는 제3자 사이트/콘텐츠를 호스팅하는 것입니다.\n\n# iFrame 생성하기\n\n\n\n제가 만든 프로젝트는 간단한 React 앱(v18.2.0)입니다. 부모 위젯(App.tsx)은 iFrame 컴포넌트(IFrame.tsx)를 로드합니다. 두 컴포넌트가 마운트될 때 모두 메시지 이벤트를 수신하기 위해 이벤트 리스너를 추가합니다. 이벤트 리스너는 컴포넌트가 마운트 해제될 때 제거됩니다. 부모 컴포넌트는 자바스크립트의 postMessage 함수를 사용하여 iFrame에 메시지를 보냅니다.\n\nApp.tsx\n\n```js\nimport React, { useEffect, useRef } from \"react\";\nimport IFrame from \"./iFrame\";\n\nconst App: React.FC = () => {\n const refs = useRef<HTMLIFrameElement>(null);\n\n useEffect(() => {\n   window.addEventListener(\"message\", processMessage, false);\n   return () => window.removeEventListener(\"message\", processMessage);\n }, []);\n\n\n const processMessage = (event: MessageEvent) => {\n   if (event.origin !== \"http://localhost:8080\") {\n     return;\n   }\n   console.log(\"parent Event Listener\", event);\n };\n\n\n const buttonClick = (event: React.MouseEvent) => {\n   event.stopPropagation();\n   if (refs.current === null) {\n     return;\n   }\n\n   refs?.current?.contentWindow?.postMessage(\"부모에서 보낸 메시지\", \"*\");\n };\n return (\n   <div>\n     <button\n       style={ margin: \"10px\", marginLeft: \"0px\" }\n       onClick={buttonClick}\n     >\n       자식에게 메시지 보내기\n     </button>\n     <IFrame ref={refs} />\n   </div>\n );\n};\n\nexport default App;\n```\n\nIFrame.tsx\n\n\n\n```js\nimport React, { useEffect, useState, forwardRef, ForwardedRef } from \"react\";\n\n\ninterface IFrameProps {\n ref: ForwardedRef<HTMLIFrameElement>;\n}\n\nconst IFrame = forwardRef<HTMLIFrameElement, IFrameProps>((prop, ref) => {\n const [message, setMessage] = useState('');\n const iframeRef = ref as React.MutableRefObject<HTMLIFrameElement>;\n useEffect(() => {\n   console.log(\"mounted\");\n   iframeRef?.current?.contentWindow?.addEventListener(\n     \"message\",\n     processMessage,\n     false\n   );\n   return () => {\n     console.log(\"unmounted\");\n     iframeRef?.current?.contentWindow?.removeEventListener(\n       \"message\",\n       processMessage,\n       false\n     );\n   };\n }, [iframeRef?.current]);\n\n\n const processMessage = (event: MessageEvent) => {\n   console.log(\"iFrame Event Listener\");\n   if (event.origin !== \"http://localhost:8080\") {\n     return;\n   }\n\n\n  const newMessage = message.concat(event?.data)\n  setMessage(newMessage);\n\n\n };\n\n\n return (\n   <div>\n     <iframe id=\"1\" {...prop} ref={ref} srcDoc={message}></iframe>\n   </div>\n );\n});\n\n\nexport default IFrame;\r\n```\n\n리스너가 올바르게 마운트되었는지 확인하기 위해 iFrame에서 getEventListeners(window)을 실행했습니다. iFrame에서 'message' 이벤트를 수신 대기하는 리스너를 확인할 수 있었습니다. 보안 대책으로 악의적인 사용자로부터의 메시지를 무시하도록 origin을 확인해야 합니다.\n\n<img src=\"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_0.png\" />\n\n# 화면에서 보이는 모습\n\n\n\n\n<img src=\"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_1.png\" />\n\n버튼을 클릭하면 메시지가 iFrame 안에 나타납니다.\n\n<img src=\"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_2.png\" />\n\n이 모든 것이 정말 기뻤어요. 그러나 이곳에서 문제가 발생했습니다. 다시 메시지를 iFrame으로 보내려고 시도했을 때 iFrame UI가 변경되지 않았습니다. iFrame 안에서 \"부모로부터 온 메시지\"를 여러 번 보기를 기대했는데 그런 일은 일어나지 않았습니다. 버튼 클릭 시 UI가 매번 업데이트되지 못했다는 것 같았어요.\n\n\n\n<img src=\"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_3.png\" />\n\n내 콘솔 로그를 확인해 보니, 이벤트 리스너를 언마운트한 후에 출력하는 `unmounted`가 아무런 발생하지 않았어. 이것은 React가 버튼 클릭 후 iFrame의 이벤트 리스너를 제대로 언마운트하지 않았음을 확인했어. (재표현)\n\nuseEffect의 의존성 배열을 건드리면서 리스너를 다시 마운트해 보았지만, 모든 시도가 실패했어. 자식에게 메시지를 여러 번 보내도, 자식은 첫 번째 메시지만 듣더라고.\n\n# 그래서 어떻게 하면 제대로 동작시킬 수 있을까?\n\n\n\n더 궁금해져서, 처음 메시지가 도착한 후에 다시 이벤트 리스너를 확인해 봤어요. 여기서 문제를 발견했어요.\n\n![이미지](/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_4.png)\n\n첫 번째 메시지가 도착한 후에 iFrame에는 어떠한 리스너도 연결되어 있지 않았어요. 마치 어떻게든 첫 번째 메시지가 도착한 후에 리스너들이 제거된 것처럼 보였어요.\n\n조금 더 실험해 본 결과, srcDoc 요소에 문제가 있는 것을 발견했어요. 따라서, 상태가 변경될 때 srcDoc 요소가 iFrame의 새 메시지를 가리키게 되었어요. 이 변경으로 인해 iFrame은 iFrame과 관련된 모든 이벤트 리스너를 모두 제거하고 리액트는 아무것도 모르게 되었어요 🫢.\n\n\n\n그래서 React는 iFrame이 그것을 하는지 모릅니다. 왜냐하면 React에게는 iFrame에 대한 참조가 추가/제거되어야 하는데, 참조가 절대 변경되지 않기 때문에 React는 이벤트 리스너를 마운트하거나 언마운트하지 않습니다.\n\n이 문제를 해결하기 위해 iFrame에 정적 HTML을 추가했으며, 메시지가 도착할 때마다 기존 HTML에 추가합니다. 이는 srcDoc가 새 HTML이 아니기 때문에 iFrame에 첨부된 이벤트 리스너를 지우지 않습니다.\n\n```js\nimport React, { useEffect, forwardRef, ForwardedRef } from \"react\";\n\n\ninterface IFrameProps {\n  ref: ForwardedRef<HTMLIFrameElement>;\n}\n\n\nconst html = `<html>\n<body>\n<div id=\"changeText\" value=\"changeText\">Hello Div</div>\n<button value=\"replyButton\" id=\"replyButton\">Reply to parent</button>\n<script>\n// Get the button element\nvar button = document.getElementById(\"replyButton\");\n\n\n// click event listener\nbutton.addEventListener(\"click\", function() {\n  console.log('sending message to parent');\n  window.parent.postMessage('Message from Child. Listen to me!');\n});\n</script>\n</body>\n</html>`;\n\n\nconst IFrame = forwardRef<HTMLIFrameElement, IFrameProps>((prop, ref) => {\n  const iframeRef = ref as React.MutableRefObject<HTMLIFrameElement>;\n  useEffect(() => {\n    console.log(\"mounted\");\n    iframeRef?.current?.contentWindow?.addEventListener(\n      \"message\",\n      processMessage,\n      false\n    );\n    return () => {\n      console.log(\"unmounted\");\n      iframeRef?.current?.contentWindow?.removeEventListener(\n        \"message\",\n        processMessage,\n        false\n      );\n    };\n  }, [iframeRef?.current]);\n\n\n  const processMessage = (event: MessageEvent) => {\n    console.log(\"iFrame Event Listener\");\n    if (event.origin !== \"http://localhost:8080\") {\n      return;\n    }\n\n\n    const node = document.createElement(\"div\");\n    const textNode = document.createTextNode(event?.data);\n    node.appendChild(textNode);\n    iframeRef?.current?.contentWindow?.document.body.appendChild(textNode);\n  };\n\n\n  return (\n    <div>\n      <iframe id=\"1\" {...prop} ref={ref} srcDoc={html}></iframe>\n    </div>\n  );\n});\n\n\nexport default IFrame;\r\n```\n\n# 요약\n\n\n\n- 부모와 자식 간의 간단한 메시지 통신이 작동하지 않는 이유에 대해 공유했어요. iFrame에서 srcDoc 요소를 변경할 경우 작동하지 않아요.\n- 이를 해결하기 위해 iFrame에 HTML을 삽입하고 지속적으로 추가하면 됩니다. 이렇게 하면 iFrame이 이벤트 리스너를 지워 버리는 것을 방지할 수 있어요.","ogImage":{"url":"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_0.png"},"coverImage":"/assets/img/2024-05-12-iFramewipesoutlistenersandReactdoesnotknowaboutit_0.png","tag":["Tech"],"readingTime":7},{"title":"초보 퍼블리셔를 위한 HTML 완벽 가이드","description":"","date":"2024-05-02 00:58","slug":"2024-05-02-AComprehensiveGuidetoHTMLforBeginners","content":"\n\n<img src=\"/assets/img/2024-05-02-AComprehensiveGuidetoHTMLforBeginners_0.png\" />\n\n# 목차\n\n- 소개\n- HTML이란 무엇인가?\n- HTML 작성 방법\n- HTML 문서 구조\n- HTML 요소의 구성\n- 일반적인 HTML 태그\n- 일반적인 HTML 속성\n- 첫 번째 HTML 파일 만들기\n- 추가 학습 자료\n- 결론\n\n# 소개\n\n<div class=\"content-ad\"></div>\n\n개발자 여정을 시작하면 웹사이트의 기본 구조를 만드는 데 도움이 되는 HTML을 이해하는 것이 중요합니다. HTML은 온라인 리소스 간의 링크 지원을 위해 만들어졌으며 이는 웹을 구축하는 혁명적인 단계로 작용했습니다.\n\n그러나 웹 개발의 맥락에서 HTML은 웹사이트의 내용과 관련이 있습니다. 웹페이지에 뼈대와 구조를 제공하는 뼈대 역할을 수행한다고 생각해보세요. HTML을 잘 이해하면 CSS로 스타일을 지정하고 JavaScript로 조작할 수 있는 기능적인 웹사이트를 만들 수 있습니다.\n\n2024년 현재 95% 이상의 웹사이트가 HTML을 사용하고 있습니다.\n\n본 문서는 HTML에 대한 포괄적인 안내서 역할을 하며, HTML의 기본 개념, HTML 작성 방법, 일반적인 태그와 속성, HTML 파일 작성 및 HTML 코딩에 사용되는 일반 텍스트 편집기에 대한 안내, 마지막으로 HTML 학습에 도움이 되는 추가 자료를 제공할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# HTML은 정확히 무엇인가요?\n\n1989년 팀 버너스-리에 의해 만들어진 HTML은 월드 와이드 웹의 핵심 언어로 작동합니다. HyperText Markup Language의 약자인 HTML은 하이퍼링크를 통해 다른 웹사이트 간에 탐색할 수 있도록 하는 웹의 중심 요소입니다.\n\n마크업 언어로서, HTML은 HTML 파일 내의 주석을 사용하여 페이지를 표시합니다. 이러한 주석은 브라우저에 렌더링되지 않지만 내부적으로 작동하여 콘텐츠를 일반 대중에게 표시하는 방법을 브라우저에 알려줍니다.\n\n집을 짓기 시작할 때, 튼튼한 기초가 마련되어야 하며 구조적으로 견고하게 유지되어야 합니다. 마찬가지로 HTML은 웹사이트를 구축하는 데 필요한 기초로, 웹상에서 콘텐츠를 제시하기 위한 구조와 의미를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n계속하기 전에 HTML이 주로 프로그래밍 언어가 아닌 마크업 언어로 간주된다는 점을 참고하세요. HTML은 구조적인 목적을 제공하므로 프로그래밍 언어로 간주되지 않는다는 주장이 있습니다.\n\n# HTML 작성 방법\n\nHTML 문서는 브라우저에 렌더링할 내용을 알려주는 요소로 구성된 표준 구조를 따릅니다.\n\n기본 HTML 요소에는 시작 태그와 종료 태그, 내용이 포함되어 있고 속성과 값이 포함될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n사람들처럼 적절한 HTML 구조는 `head`와 `body`를 갖추고 있어야 합니다. `head` 요소에는 메타데이터를 추가하고, `body`에는 웹페이지에 표시될 정보가 포함됩니다. `body` 태그에는 페이지에 표시할 내용만 넣어야 하며, 그 외의 모든 것은 `body` 안에 들여쓰기해야 합니다.\n\n# HTML 문서 구조\n\n기본 HTML 구조는 다음과 같습니다:\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <!-- 여기에 메타데이터를 삽입합니다 -->\n    <!-- 메타데이터에는 웹페이지에 대한 정보가 포함됩니다 -->\n    <title></title>\n  </head>\n  <body>\n    <!-- body에는 웹페이지 내에서 표시될 내용이 포함됩니다 -->\n  </body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n- `!DOCTYPE html`: 이것은 HTML에서의 첫 번째 코드 줄입니다. HTML 버전을 명시하며 선언으로 알려져 있습니다. 브라우저가 산업 표준을 준수하도록 합니다.\n\n- html lang=\"en\"``/html``: 이는 HTML 문서의 시작과 끝 태그입니다. 'lang' 속성을 포함하고 있으며 이는 'en' 값으로 추가되어 페이지 언어를 영어로 지정합니다.\n\n- `head``/head`: 이는 페이지에 대한 메타데이터를 포함합니다.\n\n- `title``/title`: 이는 브라우저의 제목 표시줄에 표시될 페이지 제목을 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n\n**body**: 웹페이지에서 보이는 내용을 포함합니다.\n\n# HTML 요소의 구조\n\n![HTML 요소 구조](/assets/img/2024-05-02-AComprehensiveGuidetoHTMLforBeginners_1.png)\n\n다양한 HTML 요소는 웹 브라우저에 정보를 전달하는 데 도움이 됩니다. 위 다이어그램에서 HTML 요소는 태그(시작 태그와 종료 태그)로 지정됨을 볼 수 있습니다. *몇몇 요소는 종료 태그가 필요하지 않을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n속성은 요소에 추가 정보를 제공하는 반면 값은 추가된 속성에 대한 추가 정보를 제공합니다. 예를 들어 앵커 요소를 살펴보겠습니다:\n\n```js\n<a href=\"링크 주소\">내용</a>\n\n<!-- 여는 <a>는 여는 태그를 나타냅니다 -->\n<!-- href는 앵커 태그의 하이퍼텍스트 참조를 나타내는 속성입니다 -->\n<!-- 링크 주소가 값입니다 -->\n<!-- 닫는 </a>는 종료 태그를 나타냅니다 -->\n```\n\n# 흔한 HTML 태그\n\n총 142개가 넘는 HTML 태그가 존재하며, 각각이 HTML 문서 내에서 다른 수준에서 역할을 수행합니다. HTML 코딩 중 대부분 마주치게 되는 필수 요소들을 정리했습니다.\n\n<div class=\"content-ad\"></div>\n\n대부분의 HTML 요소는 여는 태그와 닫는 태그를 가지고 있어요.\n\n여는 태그에는`<`와 `>` 사이에 요소가 들어가요. 그에 반해, 닫는 태그(해당하는 경우)는 요소 이름 앞에 슬래시(`/`)가 있는 `<`와 `>`로 묶인 요소를 포함하고 있어요.\n\n중요한 HTML 태그들은 다음과 같아요:\n\n- 제목(H1 — H6): 제목은 웹페이지의 컨텐츠 계층을 정의하며, `h1`이 가장 중요하고 `h6`가 가장 중요하지 않아요. 문서에 낮은 계층의 제목 요소를 추가하는 것은 새로운 하위 섹션을 시작한다는 것을 의미해요.\n\n<div class=\"content-ad\"></div>\n\n```js\n<h1>Hello World</h1> <!-- 가장 중요한 제목 -->\n <h6>hello world</h6> <!-- 하위 제목 -->\n```\n\n2. 단락(p): 명시적인 문서를 제시하는 데 도움이 되는 단락을 추가할 수 있습니다.\n\n```js\n<p>This is your paragraph content</p>\n```\n\n3. 링크(a): 앵커 요소는 하이퍼링크를 만들어줍니다. 이를 통해 웹 페이지 간 또는 동일 페이지의 섹션 간을 이동할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이미지를 HTML 문서에 추가하려면 `img` 태그를 사용할 수 있어요. 지금까지 보신 태그들과는 달리 이미지 태그는 자체적으로 닫는 태그이기 때문에 별도의 종료 태그가 필요하지 않아요.\n\n이미지 요소에는 이미지 원본을 지정하는 (src) 속성이 반드시 필요해요. 이미지가 로드되지 않을 경우 화면 낭독기의 접근성을 향상시키기 위해 (alt) 속성을 추가하는 것도 도움이 돼요.\n\n```js\n<img src=\"blah.jpg\" alt=\"blah doing blah\" />\n <!-- alt 속성은 이미지에 대한 중요한 메타데이터를 제공하여 구글 검색 결과 페이지 순위를 높이는 데 도움이 돼요 -->\n```\n\n<div class=\"content-ad\"></div>\n\n5. `div` 태그: `div` 태그는 유사한 콘텐츠를 그룹화하고 스타일을 적용하기 위한 일반적인 블록 수준 컨테이너 요소입니다. 이 태그는 CSS로 스타일이 적용되거나 JavaScript로 조작되지 않는 이상 문서 내용에 영향을 미치지 않습니다.\n\n일반적으로 HTML 문서는 div들의 모음이라고 말합니다. 다른 태그들이 `div` 요소 내에 중첩될 수도 있고, div들이 다른 div들 안에 중첩될 수도 있습니다. 이것을 ‘HTML 문서 트리’라고 합니다.\n\n아래는 HTML 문서 트리를 보여주며 요소들이 서로 어떻게 중첩되어 있는지 보여주는 다이어그램입니다.\n\n![HTML document tree diagram](/assets/img/2024-05-02-AComprehensiveGuidetoHTMLforBeginners_2.png)\n\n<div class=\"content-ad\"></div>\n\n6. 목록(ul)(ol)(li): 목록은 순서가 있는(ol) 경우와 순서가 없는(ul) 경우가 있습니다. 순서가 있는 목록을 만들려면, 시작하는 `ol` 태그와 닫는 `/ol` 태그를 코딩하세요. 여기에 리스트 항목 태그 `li``/li`를 중첩하여 들여쓰기를 해야 합니다.\n\n글머리 기호(불릿 포인트)를 만들려면, 그냥 순서가 없는 목록 요소에 리스트 항목(li)을 중첩하면 됩니다.\n\n따라서 식료품 목록의 글머리 기호를 작성하려면, 다음과 같이 코딩해야 합니다:\n\n```js\n- Eggs\n- Butter\n- Flour\n- Sugar\n```\n\n\n<div class=\"content-ad\"></div>\n\n위 내용을 한글로 번역하면 이렇게 될 거에요:\n\n<img src=\"/assets/img/2024-05-02-AComprehensiveGuidetoHTMLforBeginners_3.png\" />\n\n- 일반적인 HTML 태그를 배웠으니 이제 일반적인 HTML 속성들로 넘어가 봅시다.\n\n# 일반적인 HTML 속성들\n\n<div class=\"content-ad\"></div>\n\nHTML 속성은 콘텐츠에 나타나지 않는 요소에 대한 추가 정보를 제공합니다.\n\n이 속성들은 항상 요소의 시작/열림 태그에서 지정되며 일반적으로 값이 할당됩니다. 이름/값은 속성 쌍입니다. (name=\"value\"). 속성 값은 따옴표로 묶어야 함을 유의하십시오.\n\n또한 모든 HTML 요소가 속성을 필요로 하는 것은 아니며 모든 속성이 값을 필요로 하는 것은 아닙니다(이를 부울 속성이라고 함). HTML 학습을 더 진행하면 이러한 개념들을 이해하는 것이 더 쉬워질 것입니다.\n\n일반적인 HTML 속성은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- (src) 속성: source 속성(src)은 이미지 링크를 값으로 하는 `img` 요소에서 유용합니다. `img` 요소에 (src) 속성이 추가되지 않으면 브라우저가 렌더링할 이미지를 알 수 없습니다. `img src=\"이미지 링크\"/`\n- (href) 속성: HTML 문서의 하이퍼링크 대상을 정의하며 값은 링크 대상을 지정합니다. 앵커`a` 요소에 (href) 속성이 추가되지 않으면 방문자가 링크를 클릭해도 브라우저에서 어디로도 이동하지 않습니다. `a href=\"링크\"`링크 텍스트`/a`\n- (class)와 (id) 속성: 이들은 CSS를 활용한 스타일링과 JavaScript를 활용한 조작을 통해 HTML 요소에 추가 정보와 스타일을 제공합니다.\n- (lang) 속성: 웹 페이지의 언어를 지정하는 필수적인 속성으로 `html` 요소의 시작 태그에 추가해야 합니다. 웹 브라우저와 검색 엔진에 도움이 되며, 페이지 언어가 영어인 경우 `html lang=\"en\"``/html`로 지정합니다.\n- (alt) 속성: 필수적인 속성은 아니지만 `img` 요소에 (alt)를 추가하는 것은 좋은 HTML 관행으로 간주됩니다. 대체 텍스트를 추가하면 저시력을 가진 방문자 등에게 사이트 접근성을 높이고 이미지가 제대로 렌더링되지 않을 때에도 대비할 수 있습니다. `img src=\"cat.jpg\" alt=\"고양이 잠자는 모습\" /`\n\n더 많은 속성이 있으며, 이를 효과적으로 활용하는 방법을 배우면 HTML 문서를 향상시킬 수 있습니다. 기억해야 할 점은 HTML 속성은 HTML 요소 내부에서 사용되는 특별한 단어로 요소의 동작을 제어합니다.\n\n# 첫 번째 HTML 파일 생성하기\n\nHTML을 사용하기 위해 다음 단계를 따르세요:\n\n<div class=\"content-ad\"></div>\n\n- 텍스트 편집기 다운로드하기: 텍스트 편집기는 텍스트 파일을 변경, 편집, 생성 및 열 수 있는 컴퓨터 프로그램이에요. 기본적으로 코드를 작성하는 데 도움을 줍니다. HTML 코딩용 여러 텍스트 편집기가 있어요. 내가 좋아하는 몇 가지는 Visual Studio Code, Notepad++(Windows), Sublime Text(Mac) 등이 있어요.\n- 텍스트 편집기를 다운로드한 후, 열리면 에디터 창이 나타날 거에요. 여기서 첫 번째 HTML 코드를 작성할 거에요.\n- `!DOCTYPE html`로 페이지를 선언한 다음, `html lang=\"en\"`로 언어를 영어로 설정하는 `html` 엘리먼트로 시작해보세요.\n- `html` 엘리먼트 내에 `head`와 `body` 엘리먼트를 중첩해 주세요.\n- `head` 엘리먼트 안에 `title` 엘리먼트를 중첩하고, 콘텐츠를 `My first HTML page`로 설정하여 페이지에 제목을 부여하세요.\n- `body` 내부에 `h1`와 `p` 엘리먼트를 중첩하고, 전자에는 \"My first Heading\", 후자에는 \"My first paragraph\"를 내용으로 설정해 주세요.\n\n다음과 같은 모습이어야 해요:\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>My first HTML page</title>\n  </head>\n  <body>\n    <h1>My first Heading</h1>\n    <p>My first paragraph</p>\n  </body>\n</html>\n```\n\n7. 다음으로, 컴퓨터에 방금 생성한 파일을 저장하고 (.html) 확장자를 할당해 주세요.\n\n<div class=\"content-ad\"></div>\n\n8. 완성된 파일을 보려면 저장된 파일을 더블 클릭하여 열어주세요. 그러면 기본 브라우저에서 열릴 거에요. 추가한 HTML 파일에 따라 웹 페이지가 표시될 거에요.\n\n9. 축하해요, 친구야! 첫 번째 HTML 파일을 만들었어, 정말 자랑스러워!\n\n![image](/assets/img/2024-05-02-AComprehensiveGuidetoHTMLforBeginners_4.png)\n\n10. 보이는 대로, 꽤 기본적인 페이지에요. 마음대로 편집해봐도 돼. 텍스트 편집기에서 파일을 수정하여 이미지, 양식, 링크 및 기타 요소를 추가해 동적인 웹 페이지를 만들 수 있어. 변경 사항을 저장하지 않으면 브라우저에 반영되지 않으니 주의해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 더 배우기 위한 자료\n\nHTML 마스터링 여정을 계속하려면, 내가 개발자 여정에서 도움을 받은 몇 가지 가치 있는 자원들이 있어요:\n\n- freeCodeCamp: freeCodeCamp의 '반응형 웹 디자인' 과정은 개발 경력을 가속화하는 데 도움이 되었어요. 이름에서 알 수 있듯이 무료이며 계정 생성만 필요해요.\n- Per Borgen의 HTML과 CSS: 저에게 항상 초심자에게 추천하는 동영상이에요. Per가 개념을 단순하게 설명하고 듣는 이를 참여시키는 데 뛰어난 일을 했어요.\n- The Odin Project: 컴퓨터 기초, HTML, CSS, Flexbox 등에 대한 실전 소개가 있어요.\n\n온라인 튜토리얼이나 추천 도서 중 어느 쪽을 선호하든, HTML을 배울 수 있는 방법에 부족함이 없어요. 당신에게 가장 적합한 자원을 선택하기 위해 조사를 하고 선택해보세요!\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nHTML은 웹의 언어이며 개발자 여정에 발을 딛을 때 HTML에 대한 좋은 이해는 디지털 랜드스케이프에서 유용하고 보람찬 것으로 입증될 것입니다.\n\nHTML만을 이용하여 간단한 웹사이트를 제작할 수 있지만, 아름답고 기능적인 웹사이트를 만들기 위해서는 CSS와 JavaScript에 대한 좋은 이해가 미래에 필수적일 것입니다. 인간과 같이, HTML은 뼈대에 비유할 수 있고, CSS는 피부에, JavaScript는 웹사이트의 두뇌에 비유할 수 있습니다.\n\n원하는 것을 배울 때에는 연습과 인내가 중요하다는 것을 기억하세요. HTML은 동적이고 상호작용적인 웹 경험을 만들어내기 위한 흥미진진한 모험의 시작에 불과합니다. 개발자 여정에서 행운이 함께 하길 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n행복한 코딩 친구들!","ogImage":{"url":"/assets/img/2024-05-02-AComprehensiveGuidetoHTMLforBeginners_0.png"},"coverImage":"/assets/img/2024-05-02-AComprehensiveGuidetoHTMLforBeginners_0.png","tag":["Tech"],"readingTime":9},{"title":"HTMX가 개발자들에게 인기 없는 이유","description":"","date":"2024-05-02 00:56","slug":"2024-05-02-SorryImNotDigginHTMX","content":"\n![image](/assets/img/2024-05-02-SorryImNotDigginHTMX_0.png)\n\n언제나 새로 나오는 기술에 대해 비판적이라고 해도 되겠죠. 그래서 HTMX에 대해 처음 들었을 때부터 팬이 아니었어요.\n\nHTMX는 \"자바스크립트 대신 HTML에서 직접 현대적인 브라우저 기능에 액세스할 수 있도록 하는 라이브러리\"라고 설명되어 있는데, HTMX를 사용하는 첫 번째 단계는 자바스크립트 라이브러리를 포함해야 한다는 거잖아요:\n\n```js\n<script\n  src=\"https://unpkg.com/htmx.org@1.9.10\"\n  integrity=\"sha384-D1Kt99CQMDuVetoL1lrYwg5t+9QdHe7NLX/SoJYkXDFfX37iInKRy5xLSi8nO7UC\"\n  crossorigin=\"anonymous\"\n></script>\n```\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:960/1*Z6JScodi-nf6CEtuSxaBmw.gif)\n\n내게 더 감명깊게 만들었을 것은 JavaScript 이외의 언어를 사용했다면 였을 겁니다. 예를 들어, WebAssembly를 사용하는 Blazor나 기술적으로는 여전히 JavaScript인데 Python으로 작성된 Brython 같은 것들이 있죠. 색다른 솔루션은 인정하지만, JavaScript를 사용하지 않는다고 주장하면서 실제로는 JavaScript를 사용한다면, 자바스크립트 라이브러리가 계속 늘어난다는 장난이었을까 하는 생각이 들었어요.\n\n안타깝게도 이것은 농담이 아니예요.\n\n하지만, 이것 때문에 HTMX 아이디어를 뭔가 좀 무시해버렸죠. 그러나, X와 Reddit 등 어디서나 계속 HTMX에 대해 듣고 있는데, 특히 이것이 프로젝트에 통합하기가 얼마나 쉬운지에 대해 말이죠. 정말로 일반적인 JavaScript보다 얼마나 더 쉬운지. 얼마나 쉬운가요? 쉬워요? 쉬워요?? 제가 정말로 이해하지 못했습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 이 프레임워크에 대해 더 알고 싶게 된 이유는 Jason Knight의 HTMX, \"Framework Stupid\"이 심도깊게 늘어난 것이었습니다! Knight의 글은 항상 재밌게 읽히며, 그는 몇 가지 탄탄한 주장을 펼쳐 HTMX가 진지하게 다가오지 않는다면, 나도 진지하게 받아들이지 않아도 된다는 것을 깨닫게 했습니다.\n\n일단, HTMX에 대해서 더 알려주는 몇 가지 핵심 \"모티베이션\" 포인트가 있으며, 이들 중 어느 것도 나에게는 정말 이해하기 어렵습니다.\n\n## 1. `<a>`와 `<form>`만이 HTTP 요청을 보낼 수 있는 이유는 무엇인가요?\n\n사실 아닙니다. `img` 태그도 마찬가지이며, `audio`, `video`, `iframe`, `embed`, `frame`과 `link`, `script`와 같은 미디어 태그도 HTTP 요청을 보낼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 2. 클릭 및 제출 이벤트만 [HTTP 요청]을 트리거해야 하는 이유는 무엇인가요?\n\n(왜 첫 번째 항목에는 \"and\"라고 하고 두 번째 항목에는 \"&\"이라고 할까요? 일관성이 있을 것 같지 않나요? 어쨌든, 제가 지나치게 까다로운 것 같아요. 그들이 실제 현금 협찬을 받는 신생 기술인 것처럼 보이지는 않잖아요.)\n\n이 명제는 사실이 아닙니다. HTTP 요청은 나태 속성을 포함하는 이미지로 동적으로 트리거될 수 있습니다. 그리고 클릭 외에도 터치 이벤트도 있습니다. 물론 onload와 같이 HTTP 요청을 호출하는 명백한 방법뿐만 아니라 EventSource와 같이 뜻밖의 방법도 있습니다. 클릭 및 제출 외에도 HTTP 요청을 트리거하는 여러 방법이 많이 있습니다.\n\n## 3. 왜 GET 및 POST 메서드만 사용 가능해야 하나요?\n\n<div class=\"content-ad\"></div>\n\n이건 너가 빠져들 수 있는 토끼굴이야! 물론 계속해서 토론을 해왔고 또 해왔지만. 예를 들어, 이 W3C 권고서는 2009년 10월 20일에 발표됐고 또는 이 2011 스택익스체인지 스레드나 이 2012 W3C 버그 리포트에서 다뤄졌어.\n\n이건 여러 번 제안된 적이 있지만 항상 거부당했어. 왜 그럴까? HTML5 Working draft을 만드는 인간, 전설이자 신화인 이안 힉슨에 따르면:\n\n나에겐 이해가 돼!\n\n## 4. 왜 전체 화면만 교체할 수 있어야 할까?\n\n<div class=\"content-ad\"></div>\n\n웹사이트가 `테이블`과 `프레임`으로 만들어졌던 시절이 그립다면, 정말 행운아지! 요즘에는 React부터 Blazor까지 다양한 컴포넌트들이 있어서 옛 콘텐츠를 그대로 두고도 새로운 콘텐츠로 업데이트할 수 있는 독립적인 동적 요소들이 등장했어.\n\n하지만, 이 같은 기능은 예전부터 있었어. 2006년에 출시된 jQuery 1.0은 바로 이것을 수행하는 load() 메소드를 가지고 있었어:\n\n```js\n$(\"#result\").load(\"ajax/test.html #container\");\n```\n\n이와 같은 기능은 바닐라 JavaScript로도 아주 쉽게 할 수 있지:\n\n<div class=\"content-ad\"></div>\n\n```js\nlet resultElement = document.getElementById(\"result\");\n\nfetch(\"ajax/test.html\")\n  .then((response) => response.text())\n  .then((html) => {\n    let tempElement = document.createElement(\"div\");\n    tempElement.innerHTML = html;\n    let containerContent = tempElement.querySelector(\"#container\").innerHTML;\n    resultElement.innerHTML = containerContent;\n  })\n  .catch((error) => console.error(\"콘텐츠를 불러오는 중 오류가 발생했습니다:\", error));\n```\n\n![링크](https://miro.medium.com/v2/resize:fit:960/1*5bwk8lXsMpJK7xyn-LJ1-A.gif)\n\n# HTMX가 테이블에 무엇을 가져다주나요?\n\n그들의 동기에는 동의하지 않지만, 그들이 자바스크립트를 사용하고 있다는 점에서 그들이 자바스크립트 없는 시스템을 운영하고 있다고 주장하는 것에도 동의하지 않습니다. 그럼에도 불구하고 HTMX가 제게 어떻게 생활을 편하게 해줄 수 있을지 알고 싶었습니다. 이론에는 동의할 수 없을지라도 실제로는 맘에 들 수도 있지 않을까요?\n\n<div class=\"content-ad\"></div>\n\n그래서 나는 그들의 Hypermedia On Whatever you’d Like 라는 기사를 읽었어. 그 기사에서는 HOWL 스택에 대해 이야기하고 있었는데 (그렇기 때문에 \"you’d\" 가 소문자로 적힌 것... 나를 괴롭히는 것...). 이 기사는 JavaScript가 프런트엔드 개발의 기본 언어이기 때문에 백엔드에서도 사용할 필요가 있다는 압박(그들의 말)이 많다고 이야기하고 있어. 10년 이상 코딩을 해 온 나로써는 이 압박을 전혀 느낀 적이 없어. 마음대로 사용하거나, 이용주가 원하는대로 사용하면 돼. 웹사이트의 73%가 워드프레스를 실행하고 있다. 왜 PHP로 만들어진 웹사이트인 워드프레스 Headless CMS를 사용해야 할까?(너를 쳐다봐, 워드프레스 Headless CMS.) PHP가 오래된 언어인가? 나는 6개월마다 새로운 JavaScript 라이브러리를 채택하는 것보다는 PHP를 사용하는 게 좋다. 또 다른 더 인기 있는 대안도 많다는 거지.\n\n이 기사는 이렇게 마무리돼:\n\n… 하지만 그게 아니잖아?? 이들의 주장에 대해 이해할 수가 없어. React는 사이트의 3.5%에서 사용되고 있고, Node.js는 3%에서 사용되고 있다. PHP는 73%, ASP.NET은 6%를 차지하고 있다. JavaScript를 사용할 수는 있지만, 단일 옵션으로 고려해서는 안 된다.\n\n그들이 인용한 사이트 중 하나는 \"HTMX + Flask: 최신 Python 웹 앱, JavaScript 제외한 코스\"다. 이 코스는 Flask를 HTMX와 함께 사용하는 방법을 보여주는 3시간 강의인데, 단지 사용할 수 있다는 점 외에는, 왜 사용해야 하는지 이해가 안 가. JavaScript를 코딩하지 않고 사용하기 위한 것일까? 나는 더 이해하기 위해 이 코스를 듣고 싶지만, 그 기술을 그 이면을 이해하지 않고 사용하는 아이디어는 파괴적인 결과를 낼 수 있다. 자바스크립트나 CSS 기본 원리를 이해하지 않은 채 React나 Tailwind 같은 프레임워크를 사용하는 개발자들을 보면 그게 확실하게 확인된다.\n\n<div class=\"content-ad\"></div>\n\n![HTMX](https://miro.medium.com/v2/resize:fit:960/1*LovCpYqVf20IXXpi3VZ2JA.gif)\n\n# HTMX를 시도해보려면 어떤 점이 필요할까요?\n\n저가 HTMX를 사용하는 데 제일 막혀 있는 것은 그들의 동기, 실천 또는 문법에 동의하지 않아서가 아닙니다. 그들이 hyperscript.js를 만들어서 꽤 멋지다고 생각하기 때문에도 아닙니다. 또한 Knight가 그의 글에서 언급한 그들의 끔찍하게 유효하지 않고 접근하기 어려운 HTML 때문도 아닙니다. 저는 그 모든 것을 넘어서 볼 수 있습니다.\n\nHTMX를 시도해보게끔 만들기 위해 그들이 해야 할 일은 그들의 웹 사이트가 실제로 HTMX를 사용한다면 좋겠다는 것입니다. 그들의 웹 사이트는 꽤 간단하지만, HTMX를 실제로 사용해보여주기에 훌륭한 기회입니다. 홈페이지는 꽤 최소한이지만, 설명서 페이지는 그렇지 않습니다. 각 섹션에 대해 다른 페이지가 있는 모듈 시스템이 있고, 컨텐츠를 동적으로 가져오기 위해 HTMX를 사용하는 것은 HTMX의 능력을 보여줄 수 있는 좋은 방법이 될 것입니다. 눈으로 보는 것이 믿는 것이며, 그들 자신조차 사용하지 않을 때 어떤 것도 믿기 어렵습니다.\n\n<div class=\"content-ad\"></div>\n\nHTMX에 대한 생각이 어떻습니까? 그냥 또 다른 유행 용어인가요, 아니면 실제로 따라야 할 가치 있는 것인가요? 제 생각을 알려주세요!\n","ogImage":{"url":"/assets/img/2024-05-02-SorryImNotDigginHTMX_0.png"},"coverImage":"/assets/img/2024-05-02-SorryImNotDigginHTMX_0.png","tag":["Tech"],"readingTime":6},{"title":"도커 컨테이너 내부에 샘플 HTML 파일로 Apache 기본 웹 페이지 교체하기","description":"","date":"2024-05-02 00:54","slug":"2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5","content":"\n\n당신은 다음을 해야 합니다:\n\n- 샘플 HTML 파일을 만듭니다.\n- 이전 작업에서 사용한 Dockerfile을 사용합니다.\n- 도커 컨테이너 내의 기본 페이지를 이 샘플 HTML 파일로 교체합니다.\n\n<div class=\"content-ad\"></div>\n\nUbuntu 컨테이너를 생성하고 Apache2를 설치하세요 - 도커 과제 1\n\n새 이미지를 사용하여 컨테이너를 시작하고 여기에서 Apache 2 서비스를 시작하세요 - 도커 과제 2\n\nDocker 허브에서 이미지를 가져와 다른 머신에 Apache2를 설치하세요 - 도커 과제 3\n\n컨테이너를 실행한 후 자동으로 Apache2를 설치하는 Docker 파일을 생성하세요 - 도커 과제 4\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_0.png)\n\n## Git Hub Repository 링크를 확인하여 명령어를 복사하세요:\n\n# A. 샘플 HTML 파일 생성\n\n먼저, 이 과제를 수행하기 위한 EC2 인스턴스를 생성할 것입니다. EC2 인스턴스를 생성한 후 \"index.html\" 파일을 만들 것입니다.\n\n<div class=\"content-ad\"></div>\n\n단계 1: \"서비스\" 섹션으로 이동한 후 \"EC2\" 위에 커서를 올려주세요. \"인스턴스\"를 클릭하세요.\n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_1.png)\n\n단계 2: \"인스턴스 시작\"을 클릭하세요.\n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_2.png)\n\n<div class=\"content-ad\"></div>\n\n### 단계 3: \"이름 및 태그\" 섹션에서 \"이름\"을 \"Assignment 5\"로 선택합니다.\n\n![Assignment 5 step 3](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_3.png)\n\n### 단계 4: \"AMI\"를 \"Ubuntu\"로 선택합니다.\n\n![Assignment 5 step 4](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_4.png)\n\n<div class=\"content-ad\"></div>\n\nStep 5: \"인스턴스 유형\"을 \"t2.micro\"로 선택하고 키 페어(로그인)를 \"Docker\"로 설정하세요.\n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_5.png)\n\nStep 6: \"공통 보안 그룹\"을 \"launch-wizard-9\"로 선택하세요.\n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_6.png)\n\n<div class=\"content-ad\"></div>\n\n**7단계**: \"인스턴스 시작\"을 클릭합니다.\n\n![Step 7](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_7.png)\n\n**8단계**: \"(하이퍼링크(i-041c3e5b59ce92d00)\"를 클릭합니다.\n\n![Step 8](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_8.png)\n\n<div class=\"content-ad\"></div>\n\n**단계 9:** 인스턴스가 \"실행 중\" 상태가 될 것입니다. 인스턴스를 선택하고 \"연결\"을 클릭하세요.\n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_9.png)\n\n**단계 10:** 다시 \"연결\"을 클릭하세요.\n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_10.png)\n\n<div class=\"content-ad\"></div>\n\n11단계: 이 명령을 사용하여 머신을 업데이트하세요:\n\n```js\nsudo apt-get update\n```\n\n![링크](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_11.png)\n\n12단계: 이 명령을 사용하여 도커를 설치하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo apt-get install docker.io -y\n```\n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_12.png)\n\n단계 13: 다음 명령어를 사용하여 \"Docker\"에 액세스하기 위해 루트 사용자로 로그인하세요:\n\n```js\nsudo su -\n```\n\n<div class=\"content-ad\"></div>\n\nStep 14: 다음 명령어를 사용하여 \"Docker\" 상태를 확인해보세요:\n\n```js\nsystemctl status docker\n```\n\n<div class=\"content-ad\"></div>\n\n도커는 \"Active\" 상태입니다.\n\n단계 15: 이제, 다음 명령을 사용하여 index.html 파일을 만들겠습니다:\n\n```js\nsudo nano index.html\n```\n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_15.png)\n\n<div class=\"content-ad\"></div>\n\n단계 2: index.html 파일에 더미 콘텐츠를 붙여넣기하세요.\n\n```js\n<!DOCTYPE html>\n<html>\n<head>\n<title>Page Title</title>\n</head>\n<body>\n<h1>This is a Heading</h1>\n<p>This is a paragraph.</p>\n</body>\n</html>\n```\n\n<img src=\"/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_16.png\" />\n\n파일을 저장하려면 CTRL+X를 누르고 Y를 누르세요. \"Enter\"를 누르면 파일이 저장됩니다.\n\n<div class=\"content-ad\"></div>\n\n# B. 이전 작업에서 Dockerfile을 사용합니다\n\n단계 1: 이제, index.html 파일을 /var/www/html 위치에 추가할 것입니다. 다음 명령을 실행하세요:\n\n```js\nvim Dockerfile\n``` \n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_17.png)\n\n<div class=\"content-ad\"></div>\n\n```js\nFROM ubuntu\nRUN apt-get update\nRUN apt-get install apache2 -y\nRUN apt-get install apache2-utils -y\nRUN apt-get clean\nENTRYPOINT apache2ctl -D FOREGROUND\n```\n\n# C. 도커 컨테이너 내부에 있는 이 샘플 HTML 파일을 기본 페이지로 대체하기\n\n단계 1: 다음 명령을 Dockerfile에 추가하세요:\n\n```js\nADD index.html /var/www/html/\n```\n\n<div class=\"content-ad\"></div>\n\n```plaintext\n도커 파일의 table 태그를 Markdown 형식으로 변경하십시오.\n```\n\n<div class=\"content-ad\"></div>\n\n이 명령어를 사용해보세요:\n\n```js\ndocker build –t assignment5 .\n```\n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_19.png)\n\n3단계: Docker 이미지가 \"assignment5\"로 성공적으로 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_20.png\" />\n\n4단계: 이제 다음 명령을 사용하여 생성된 이미지를 사용하여 새 컨테이너를 만듭니다:\n\n```js\ndocker container run –itd --name testcont1 –p 89:80 assignment5\n```\n\n<img src=\"/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_21.png\" />\n\n<div class=\"content-ad\"></div>\n\n5단계: 컨테이너가 생성되었는지 확인하려면 다음 명령을 실행하세요:\n\n```js\ndocker container ls -a\n```\n\n<img src=\"/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_22.png\" />\n\n6단계: 다음 명령을 사용하여 컨테이너 내부로 이동하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n도커 컨테이너 실행 -it testcont1 bash\n```\n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_23.png)\n\n7단계: 다음 명령어를 실행하세요:\n\ncd /var/www/html/ — html 폴더 안으로 이동합니다.\n\n<div class=\"content-ad\"></div>\n\n\"HTML 디렉토리\"에 있는 파일을 확인하려면 \"ls\"를 입력하세요.\n\n```js\ncd /var/www/html\nls\n```\n\n<img src=\"/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_24.png\" />\n\n\"index.html\" 파일이 \"html\" 디렉토리에 있는 것을 확인할 수 있을 거예요.\n\n<div class=\"content-ad\"></div>\n\n8단계: 다음 명령을 실행하십시오. \"cat index.html\" 파일을 실행합니다. index 파일의 내용을 쉽게 확인할 수 있습니다.\n\n```js\ncat index.html\n```\n\n<img src=\"/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_25.png\" />\n\n9단계: 이제 \"인스턴스\"로 이동하고 \"Public IPV4 주소\" 섹션에서 \"열린 주소\"를 클릭하십시오.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_26.png)\n\n10단계: 13.233.195.209 IP 주소 뒤에 :89를 입력하세요. \"index.html\" 파일 내용이 열릴 것입니다.\n\n![이미지](/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_27.png)\n\n또한 이 도커 가이드를 읽어보세요:\n\n<div class=\"content-ad\"></div>\n\n프로덕션 환경에서 Docker를 사용하여 HTML 웹사이트를 컨테이너화했습니다 — Docker 사례 연구","ogImage":{"url":"/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_0.png"},"coverImage":"/assets/img/2024-05-02-ReplacetheApacheDefaultWebPageWithSampleHTMLFileInsideContainerDockerAssignment5_0.png","tag":["Tech"],"readingTime":7}],"page":"144","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":14,"currentPageGroup":7},"__N_SSG":true}