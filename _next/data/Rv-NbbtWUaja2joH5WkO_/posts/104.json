{"pageProps":{"posts":[{"title":"LWC에서 구성 요소 간 통신","description":"","date":"2024-05-14 15:09","slug":"2024-05-14-ComponentCommunicationinLWC","content":"\n\n![Component Communication in LWC](/assets/img/2024-05-14-ComponentCommunicationinLWC_0.png)\n\n이 주제에서는 LWC 컴포넌트가 서로 통신하는 방법을 다룰 것입니다.\n\n컴포넌트 간에 통신하는 네 가지 방법이 있습니다.\n\n- 부모에서 자식으로의 통신\n- 자식에서 부모로의 통신\n- Pub-Sub 모델을 사용한 독립형 컴포넌트 간 통신 (구식 기술)\n- 교차 프레임워크 (VF 페이지, Aura 및 라이트닝 메시징 서비스를 사용한 LWC 간 통신)\n\n\n\n# 부모 자식간 통신\n\n부모 자식 간 통신을 하려면 아래 단계를 따라하세요.\n\n- 컴포넌트 구성을 만듭니다. 부모 클래스에서 `c-component-communication-child`와 같은 자식 컴포넌트에 액세스할 수 있습니다.\n- 자식 컴포넌트에서 부모 데이터를 보관할 public 속성을 만들어야 합니다.\n- public 속성을 만들기 위해 @api 데코레이터를 사용하십시오.\n- 부모 컴포넌트에서 자식 컴포넌트의 public 속성을 정의하려면 하이픈(-) 부호를 사용합니다. 예를 들어, 자식 컴포넌트에 @api userDetails가 있다면 부모 컴포넌트에 user-details와 같이 작성해야 합니다.\n\n## 부모에서 자식으로 통신하는 방법이 4가지 있습니다.\n\n\n\nA. 자식에게 기본 데이터 전달\nB. 자식에게 비 기본 데이터 전달\nC. 작업 이벤트에서 자식에게 데이터 전달\nD. 자식 메서드를 부모에서 호출\n\n자식에게 기본 데이터 전달\n--- --- --- --- --- --- --- ---\n\n부모 컴포넌트\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_1.png)\n\n\n\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_2.png)\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_3.png)\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_4.png)\n\n\n\n\n결과\n\n<img src=\"/assets/img/2024-05-14-ComponentCommunicationinLWC_5.png\" />\n\n## 자식에게 비 기본 데이터 전달\n\n---\n\n\n\n부모 컴포넌트\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_6.png)\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_7.png)\n\n자식 컴포넌트\n\n\n\n\n![Component Communication in LWC - Step 8](/assets/img/2024-05-14-ComponentCommunicationinLWC_8.png)\n\n![Component Communication in LWC - Step 9](/assets/img/2024-05-14-ComponentCommunicationinLWC_9.png)\n\n### Result\n\n![Component Communication in LWC - Step 10](/assets/img/2024-05-14-ComponentCommunicationinLWC_10.png)\n\n\n\n\n## 액션 이벤트 발생 시 자식에 데이터 전달\n\n---\n\n부모 컴포넌트\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_11.png)\n\n\n\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_12.png)\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_13.png)\n\n![Child Component](/assets/img/2024-05-14-ComponentCommunicationinLWC_14.png)\n\n\n\n\n결과\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*YiKgaCBRXqveyetchoFM8A.gif\" />\n\n## 부모에게 자식 메서드 호출하기\n\n---\n\n\n\n이 코드를 사용하면 querySelector 매개변수에 자식 컴포넌트 이름을 전달하여 자식 컴포넌트 메서드를 호출할 수 있습니다.\n예시: this.template.querySelector('c-component-communication-child').childMethod().\n\n부모 컴포넌트\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_15.png)\n\n![이미지](/assets/img/2024-05-14-ComponentCommunicationinLWC_16.png)\n\n\n\nChild Component\n\n![Component Communication in LWC](/assets/img/2024-05-14-ComponentCommunicationinLWC_17.png)\n\n![Component Communication in LWC](/assets/img/2024-05-14-ComponentCommunicationinLWC_18.png)\n\nResult\n\n\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*TkpNP-vozpdAfIjKnElUeA.gif)\n\n# 자식에서 부모로 통신하기\n\n자식에서 부모로 통신하려면 사용자 지정 이벤트를 사용하고 해당 이벤트를 발송해야 합니다. 하지만 사용자 지정 이벤트로 넘어가기 전에 먼저 이벤트가 무엇인지 알아보겠습니다.\n\n이벤트란 무엇인가?\nJS와 HTML의 상호 작용은 모두 이벤트를 통해 처리됩니다. 사용자나 브라우저가 페이지를 조작하려고 할 때 해당 페이지가 로드될 때 이를 이벤트라고 합니다. 모든 이벤트는 'on' 키워드로 시작합니다.\n\n\n\n\n예를 들어, onclick, onchange, onkeyup 등.\n\n## 커스텀 이벤트 생성 및 발송\n\n커스텀 이벤트를 생성하려면 CustomEvent() 생성자를 사용하세요. 이 생성자에는 이벤트 유형을 나타내는 문자열이 필수 매개변수로 전달되어야 합니다.\n\n커스텀 이벤트를 발송하려면 EventTarget.dispatchEvent()를 사용하세요. LWC에서 EventTarget는 this를 의미합니다.\n\n\n\n부모 컴포넌트\n\n![이미지1](/assets/img/2024-05-14-ComponentCommunicationinLWC_19.png)\n\n![이미지2](/assets/img/2024-05-14-ComponentCommunicationinLWC_20.png)\n\n자식 컴포넌트\n\n\n\n\n![Screenshot 1](/assets/img/2024-05-14-ComponentCommunicationinLWC_21.png)\n\n![Screenshot 2](/assets/img/2024-05-14-ComponentCommunicationinLWC_22.png)\n\nResult\n\n![Animation](https://miro.medium.com/v2/resize:fit:1400/1*4gUjy7HDpHBU0m-ucNilTQ.gif)\n\n\n\n\n# Pub-Sub 모델을 사용한 독립 구성 요소 간 통신\n\n두 개의 독립 구성 요소 간의 통신을 위해 두 가지 기술인 1) Pub-Sub 모델과 2) 라이트닝 메시지 서비스(LMS)를 사용합니다.\n\n이 주제에서는 Pub-Sub 모델을 사용하여 독립 구성 요소 간 통신하는 방법을 배워 보겠습니다.\n\n먼저, 원하는 이름으로 컴포넌트를 만들어야 합니다. 저는 pubsub이라는 이름을 사용했습니다.\n해당 컴포넌트에는 아래 코드를 js 파일에 붙여넣으십시오.\n\n\n\n```js\n/* eslint-disable no-console */\nconst store = {};\n/**\n * 이벤트에 대한 콜백 함수를 구독합니다.\n * @param {string} eventName - 청취할 이벤트의 이름.\n * @param {function} callback - 해당 이벤트가 발생했을 때 호출할 함수.\n */\n\nconst subscribe = (eventName, callback) => {\n    if (!store[eventName]) {\n        store[eventName] = new Set();\n    }\n    store[eventName].add(callback);\n};\n\n/**\n * 이벤트에 대한 콜백 함수 구독을 취소합니다.\n * @param {string} eventName - 구독을 취소할 이벤트의 이름.\n * @param {function} callback - 구독을 취소할 함수.\n */\nconst unsubscribe = (eventName, callback) => {\n    if (store[eventName]) {\n        store[eventName].delete(callback);\n    }\n};\n\n/**\n * 청취자에게 이벤트를 발행합니다.\n * @param {string} eventName - 발행할 이벤트의 이름.\n * @param {*} payload - 발행할 이벤트의 페이로드.\n */\n\nconst publish = (eventName, payload) => {\n    if (store[eventName]) {\n        store[eventName].forEach(callback => {\n            try {\n                callback(payload);\n            } catch (error) {\n                console.error(error);\n            }\n        });\n    }\n};\n\nexport default {\n    subscribe,\n    unsubscribe,\n    publish\n};\n```\n\n위의 코드에서 두 개의 매개변수를 보유하는 세 개의 Const 변수가 있습니다. 첫 번째는 eventName이고 두 번째는 콜백 메서드입니다.\n\nPubSubComp_A\n\n![ComponentCommunicationinLWC_23](/assets/img/2024-05-14-ComponentCommunicationinLWC_23.png)\n\n\n\n\n\n![PubSubComp_B](/assets/img/2024-05-14-ComponentCommunicationinLWC_25.png)\n\n![Image](/assets/img/2024-05-14-ComponentCommunicationinLWC_26.png)\n\n\n\n\n결과\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*50ZgsP84cx1CGezDS_iu6A.gif)","ogImage":{"url":"/assets/img/2024-05-14-ComponentCommunicationinLWC_0.png"},"coverImage":"/assets/img/2024-05-14-ComponentCommunicationinLWC_0.png","tag":["Tech"],"readingTime":6},{"title":"Vuejs 3 앱의 모듈화를 개선하는 방법 의존성 주입","description":"","date":"2024-05-14 15:07","slug":"2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection","content":"\n\nVueJS를 사용하면 반응형 컴포넌트, 함수, 라이브러리 및 플러그인을 효율적으로 재사용할 수 있습니다. 이러한 기능들은 VueJS의 한 가지 우아하고 강력한 API 중 하나인 의존성 주입을 활용합니다.\n\n의존성 주입을 통해 부모 컴포넌트에서 후손 컴포넌트로 효율적인 로직 재사용이 가능하며, 프롭 전달에 대한 고민을 없애줍니다. 부모 컴포넌트에서 API로부터 데이터를 가져와 이 데이터를 계층 구조 내의 여러 하위 컴포넌트로 전송해야 하는 시나리오를 고려해 보세요. 이러한 하위 컴포넌트들은 부모로부터 전달된 데이터에 의존하여 정보를 렌더링합니다. 기존에는 모든 하위 컴포넌트에 데이터를 전달했을 것입니다. 데이터가 필요하지 않은 하위 컴포넌트에게까지 말이죠.\n\n이는 특정 컴포넌트로 무관한 데이터의 전달을 포함하는 프롭 드릴링(Prop Drilling)으로 이어질 수 있습니다.\n\n![image](/assets/img/2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection_0.png)\n\n\n\n이 접근 방식은 불필요한 구성 요소에 영향을 미치며, 우리가 깊이 파고들수록 유지 보수가 복잡해질 수 있습니다. 이러한 종류의 로직을 다루는 것은 부담스럽고 역생산적일 수 있습니다. 그러나 의존성 주입을 활용하면 이러한 어려움을 완전히 우회할 수 있습니다.\n\nVueJS 3 Composition API에서 의존성 주입을 구현하는 방법을 살펴보겠습니다. 우리는 이를 통해 VueJS 애플리케이션 내에서 모듈성을 보장하기 위해 그것을 활용하는 다양한 방법을 살펴볼 것입니다. 이를 설명하기 위해 샘플 사용 사례를 살펴볼 것입니다.\n\n## 예시\n\nVueJS 앱을 만들어보겠습니다. 가이드를 따라 VueJS 앱을 만들 수 있습니다.\n\n\n\n전제 조건\n\n- 명령줄에 익숙하신 분\n- Node.js 버전 16.0 이상 설치\n\nVue.js를 설정하고 모든 준비가 완료되었다고 가정하고 진행할 수 있습니다.\n\n## 앱 수준 종속성 주입\n\n\n\n앱 레벨 의존성 주입은 주입된 프로바이더를 렌더링된 앱 내 모든 컴포넌트에서 접근할 수 있도록 보장합니다. 주입될 프로바이더는 애플리케이션 상수, 변수, 핸들러 함수 등이 될 수 있습니다. 이러한 프로바이더는 자식이든 부모이든 관계없이 컴포넌트 계층 구조 어디에서든 사용할 수 있습니다.\n\n프로바이더는 두 개의 매개변수를 사용하여 선언됩니다. provide의 첫 번째 매개변수는 provide의 이름을 나타내며 문자열이어야 합니다. 두 번째 매개변수는 값을 정의합니다. 프로바이더가 여러 값을 하나의 프로바이더 이름 아래 캡슐화해야 할 때 객체도 받을 수 있다는 것을 명심하세요.\n\n현재 날짜를 제공하여 프로젝트 내에서 렌더링된 컴포넌트 어디에서나 편리하게 액세스하고 재사용할 수 있게 하려는 시나리오를 고려해보세요.\n\n프로젝트 설정 중 JavaScript 또는 TypeScript를 선택한 경우 main.js 또는 main.ts 파일로 이동하세요.\n\n\n\n위의 코드 스니펫에서는 날짜 변수의 값을 할당한 날짜를 제공합니다.\n\n## 구성 요소에서 제공된 항목에 액세스\n\n애플리케이션의 렌더링된 모든 구성 요소 내에서, 우리는 inject 함수를 활용하고 제공의 이름을 매개변수로 전달하여 날짜에 액세스할 수 있습니다.\n\n## 제공을 통해 도우미 함수 전달하기\n\n\n\n가정해 봅시다. 저희 애플리케이션에서 다양한 컴포넌트에서 제공하고 사용할 수 있는 헬퍼 함수가 있다고 합시다. 핸들러 함수를 가지고 제공으로 전달할 수도 있고 필요할 때마다 이를 액세스할 수 있습니다.\n\n우리의 사용 사례 시나리오를 수정해 봅시다. 우리 애플리케이션의 특정 컴포넌트에서 상대 시간을 표시하려고 합니다. 이를 위해 formatDateTimeWithRelativeTime 함수를 정의할 것입니다. 이 함수는 입력으로 날짜 문자열을 받아 그 날짜의 상대 시간을 현재 날짜 및 시간과 비교하여 결정합니다.\n\n이 함수를 날짜 제공 프로바이더로 제공하여 렌더링된 컴포넌트 내에서 액세스할 수 있도록 할 것입니다.\n\n렌더링된 컴포넌트 내에서 함수에 액세스하고 활용하는 것은 다른 함수와 동일하게 간단합니다. 특히 이 특정 시나리오에서는 아래 코드 스니펫에 표시된 대로 이를 관리할 수 있습니다.\n\n\n\n## 기본값 및 유연성\n\n우리가 제공되는 값이 없을 때 기본값을 제공하고 싶은 경우, 두 번째 매개변수를 제공하여 기본값으로 작용하게 할 수 있습니다. 즉,\n\n```js\n<script setup lang=\"ts\">\nimport { inject } from 'vue';\n\nconst date = inject('dates', \"20230812T144718\");\n\n//'20230812T144718'는 'dates' 제공자가 존재하지 않을 때 기본 날짜입니다.\n\n</script>\n\n<template>\n  <main>\n    <div>\n      <p>의존성 주입</p>\n      <p>날짜는 { date }입니다.</p>\n    </div>\n  </main>\n</template>\n```\n\n## 반응성과 유지보수\n\n\n\n사용자를 대상으로 하는 애플리케이션에서 값 제공을 위해 동적 업데이트가 필요할 수 있습니다. 이를 달성하기 위해서는 반응성이 우리를 이끌어 컴포넌트를 전략적으로 업데이트하고, 최적의 유지보수를 위해 관련 코드를 중앙집중화해야 합니다. 이 방식은 코드 관리를 간소화합니다.\n\nReactive provide/inject 값을 사용할 때 변경 사항을 가능한 한 제공자 내의 반응형 상태로 제한하는 것이 좋습니다. 이 실천은 제공된 상태와 잠재적인 변경 사항이 동일한 컴포넌트에 존재하도록 보장하여, 향후 유지보수를 간소화합니다.\n\n이 안내서에서 사용된 코드는 GitHub에서 찾을 수 있습니다.\n\n## 자원\n\n\n\n- https://vuejs.org/api/composition-api-dependency-injection.html\n- https://vuejs.org/guide/typescript/composition-api.html#typing-provide-inject\n\n## 결론\n\n의존성 주입은 특히 다른 대안들을 사용했을 때 prop 드릴링이 발생할 수 있는 시나리오에서 매우 유용합니다. 이 메커니즘을 통해 애플리케이션 전체에서 접근 가능해야 하는 중요한 기능, 변수 및 상수를 중앙 집중화하고, 중복을 제거하여 한 번만 포함시킴으로써 효율을 높일 수 있습니다.\n\n이 가이드를 따라 주셔서 감사합니다. 다른 사람들과 공유해주시면 감사하겠습니다. 궁금한 사항, 제안 사항이 있거나 단순히 이야기를 나누고 싶다면, X에서 @amjohnphilip과 연락하십시오. 귀하의 참여를 환영합니다!\n\n\n\n## 더 많은 읽을거리\n\n# 쉬운 영어로\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 격려해 주시고 팔로우해 주세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾으실 수 있습니다. 🚀\n- 무료 주간 뉴스레터에 가입해 주세요. 🗞️\n- 트위터, 링크드인, 유튜브, 디스코드에서도 팔로우해 주세요.","ogImage":{"url":"/assets/img/2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection_0.png"},"coverImage":"/assets/img/2024-05-14-EnhancingModularityofYourVuejs3AppsWithDependencyInjection_0.png","tag":["Tech"],"readingTime":4},{"title":"웹을 더 접근성 있게 만들기 메뉴와 로더","description":"","date":"2024-05-14 15:03","slug":"2024-05-14-Makingthewebmoreaccessiblemenusandloaders","content":"\n\n웹 애플리케이션을 개발할 때 종종 접근성이 간과되곤 합니다. 하지만 이는 인터넷을 더 포용적인 공간으로 만드는 데 큰 도움이 됩니다.\n\n대부분의 개발자들은 특히 처음 시작할 때 접근성에 집중하지 않는데, 접근성과 관련된 매우 기본적인 인터뷰 질문을 클리어하는 데 주로 관심을 가집니다.\n\n그러므로 시작해 보겠습니다. 웹에서 자주 마주치는 아주 흔한 시나리오를 살펴보겠습니다:\n\n- 메뉴 열기\n- 항목 클릭\n- 클릭한 항목이 로드될 때 까지 기다리기\n\n\n\n접근성을 생각할 때, 이 행동을 웹사이트를 사용하는 사람의 관점에서 더 자세히 살펴봅니다. 예를 들어 사용자는 메뉴와 메뉴 항목에 대해 상호작용하는 것을 알아야 하며, 메뉴에 몇 개의 항목이 있는지 알아야 하며, 항목에 다른 하위 메뉴가 있는지 등을 알아야 합니다.\n\n사용 사례 및 UI 상호작용의 복잡성에 따라 단계가 더욱 세심해질 수 있습니다.\n\n## 메뉴 만들기\n\n메뉴를 만들기 위해 먼저 로컬 HTML 파일에 다음의 시작 코드를 복사하여 붙여넣을 수 있습니다:\n\n\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n  <title>문서</title>\n  <style>\n    body {\n      margin: 0 auto;\n    }\n\n    .navbar {\n      display: flex;\n      background-color: #ccc;\n      font-family: Arial;\n    }\n\n    .navbar>ul {\n      list-style: none;\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      margin: 0;\n      padding: 10px;\n      width: 100%;\n    }\n\n    .navbar li {\n      font-size: 16px;\n      color: black;\n      text-align: center;\n      padding: 10px;\n      border-radius: 5px;\n      text-decoration: none;\n    }\n\n    .dropdown {\n      overflow: hidden;\n    }\n\n    .dropdown .dropbtn {\n      font-size: 16px;\n      border: none;\n      color: black;\n      background-color: inherit;\n      font-family: inherit;\n      margin: 0;\n    }\n\n    .navbar li:hover,\n    .dropdown:hover .dropbtn {\n      background-color: #e6e6e6;\n    }\n\n    .navbar .dropdown-content {\n      display: none;\n      position: absolute;\n      background-color: #f9f9f9;\n      box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);\n      z-index: 1;\n    }\n\n    .dropdown-content li {\n      color: black;\n      text-decoration: none;\n      display: block;\n      text-align: left;\n    }\n\n    .dropdown-content li:hover {\n      background-color: #ddd;\n    }\n\n    .dropdown:hover .dropdown-content {\n      display: flex;\n      flex-direction: column;\n      padding: 10px;\n    }\n\n    .loader-wrapper {\n      display: none;\n    }\n\n    .content-wrapper .show-loader-wrapper {\n      display: block;\n      margin: 0 auto;\n      margin-top: 200px;\n      text-align: center;\n    }\n\n    .loader {\n      border: 16px solid #f3f3f3;\n      margin: 0 auto;\n      border-top: 16px solid #3498db;\n      border-radius: 50%;\n      width: 120px;\n      height: 120px;\n      animation: spin 2s linear infinite;\n    }\n\n    @keyframes spin {\n      0% {\n        transform: rotate(0deg);\n      }\n\n      100% {\n        transform: rotate(360deg);\n      }\n    }\n  </style>\n  <script>\n    function doSomething() {\n      document.getElementById('main-loader').classList.add('show-loader-wrapper');\n      let timer = 0;\n      const timerInterval = setInterval(() => {\n        if (timer === 99) {\n          clearInterval(timerInterval);\n        }\n        timer += 1;\n        document.querySelector('.loader-progress').innerHTML = `${timer} %`;\n      }, 400);\n\n    }\n  </script>\n</head>\n\n<body>\n  <main class=\"content-wrapper\">\n    <nav class=\"navbar\">\n      <ul>\n        <li><a onclick=\"doSomething()\">홈</a></li>\n        <li class=\"dropdown\">\n          <div class=\"dropbtn\">\n            드롭다운\n            <i class=\"fa fa-caret-down\"></i>\n          </div>\n          <ul class=\"dropdown-content\">\n            <li><a onclick=\"doSomething()\">링크 1</a></li>\n            <li><a onclick=\"doSomething()\">링크 2</a></li>\n            <li><a onclick=\"doSomething()\">링크 3</a></li>\n          </ul>\n        </li>\n        <li><a onclick=\"doSomething()\">뉴스</a></li>\n      </ul>\n    </nav>\n    <div class=\"loader-wrapper\" id=\"main-loader\">\n      <div class=\"loader\">\n      </div>\n      <div class=\"loader-progress-container\">로딩 중 <span class=\"loader-progress\"></span></div>\n    </div>\n  </main>\n</body>\n\n</html>\n```\n\n\n\n자, 이제 우리는 이를 접근성 있게 만드는 방법은 무엇인가요?\n\n## 내비게이션 메뉴를 접근성 있게 만드는 방법\n\n우리는 사용자들이 마우스나 다른 포인터 장치를 사용하지 못하거나 서로 다른 색상을 구별하지 못하는 등의 다양한 도전에 직면할 수 있음을 고려해야 합니다.\n\n이는 예를 들어 학술 환경에서 사용되는 웹사이트를 만드는 경우 특히 중요해집니다. 거기에는 기술을 사용할 때 다양한 도전에 직면하는 많은 사용자들이 있을 수 있기 때문입니다.\n\n\n\n현재 상태에서 네브바를 확인해 보겠습니다. 먼저 고려사항 중 하나인 마우스나 다른 포인터 장치를 사용하지 않고 네비게이션을 하는 것을 검증할 겁니다.\n\n이를 위해 Tab 키를 사용하여 페이지의 다음 항목으로 이동하고 Shift + Tab 키를 사용하여 이전 항목으로 이동할 것입니다.\n\n우리 웹페이지에서 시도해 보겠습니다. 페이지의 빈 영역을 클릭한 후 Tab 키를 눌러주세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*JwlfxSNzMs_IYp2zWhG9wQ.gif)\n\n\n\n당신은 메뉴를 탭 키로 전혀 탐색할 수 없다는 것을 알게 될 거에요. 우리가 모든 것을 올바르게 했음에도 불구하고요.\n\n키보드 탐색에 관해서, 일부 요소는 브라우저에 의해 0으로 설정된 tabindex가 자동으로 할당됩니다.\n\n버튼, 입력 필드, 선택 상자, 텍스트 영역과 같은 익숙한 요소 몇 가지는 이렇게 자동으로 할당됩니다. 그리고 앵커 태그도요.\n\n하지만, 앵커 태그를 사용하는 우리도 똑같죠?\n\n\n\n앵커 태그에 연결된 href가 없는 경우 tabindex가 자동으로 할당되지 않습니다.\n\n\"Home\" 목록 항목에 href를 연결하고 확인해보세요:\n\n```js\n<li><a onclick=\"doSomething()\" href=\"#\">Home</a></li>\n```\n\n위와 같은 결과를 확인할 수 있어야 합니다. \"Home\" 버튼은 이제 Tab 키를 눌러 접근할 수 있을 것입니다. 외곽선은 중요하며 곧 볼 대비 기준이 있을 것입니다:\n\n\n\n다른 옵션은 모든 앵커 태그를 버튼으로 변환하는 것입니다. 실제 링크로 이동하는 대신 함수를 호출하고 있으므로 지금 그렇게 하겠습니다.\n\n```js\n<body>\n  <main class=\"content-wrapper\">\n    <nav class=\"navbar\">\n      <ul>\n        <li><button onclick=\"doSomething()\" href=\"#\">홈</button></li>\n        <li class=\"dropdown\">\n          <div class=\"dropbtn\">\n            <button>드롭다운</button>\n            <i class=\"fa fa-caret-down\"></i>\n          </div>\n          <ul class=\"dropdown-content\">\n            <li><button onclick=\"doSomething()\">링크 1</button></li>\n            <li><button onclick=\"doSomething()\">링크 2</button></li>\n            <li><button onclick=\"doSomething()\">링크 3</button></li>\n          </ul>\n        </li>\n        <li><button onclick=\"doSomething()\">뉴스</button></li>\n      </ul>\n    </nav>\n    <div class=\"loader-wrapper\" id=\"main-loader\">\n      <div class=\"loader\">\n      </div>\n      <div class=\"loader-progress-container\">로딩 중 <span class=\"loader-progress\"></span></div>\n    </div>\n  </main>\n</body>\n```\n\n그러면 키보드의 Tab 키를 통해 네비게이션 바의 각 항목을 \"탭할 수 있는\" 상태로 만드는 페이지가 나올 것입니다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*nQaPuP3mAFVyx63sB4DxtA.gif\" />\n\n\n\n하지만 버튼들이 조금 못생겼죠? 기본 CSS를 사용하여 이를 수정해 봅시다. 다음 스타일을 추가하여 버튼을 스타일링하세요:\n\n```js\n.navbar button {\n  background: #e6e6e6;\n  border: none;\n  padding: 10px;\n  border-radius: 5px;\n}\n```\n\n좋아요! 이제 \"Dropdown\" 옵션의 하위 메뉴를 키보드로 접근할 수 있도록 만들어 봅시다.\n\n## 키보드로 중첩된 메뉴에 액세스하기\n\n\n\n지금은 \"Dropdown\" 옵션으로 탭을 이동해도 메뉴가 열리지 않는 문제가 있습니다. 심지어 \"Enter\" 키를 눌러도 열리지 않습니다. 이는 하위 메뉴의 가시성을 css로 제어하고 있기 때문입니다. \n\n이 문제를 해결하기 위해 Dropdown으로 탭을 이동하면 사용자가 Enter 키와 같은 키를 눌러서 하위 메뉴를 열 수 있어야 합니다. \"Dropdown\" 버튼에 추가된 onclick을 주목해주세요:\n\n```js\n<li class=\"dropdown\">\n  <div class=\"dropbtn\">\n    <button onclick=\"openSubmenu()\">Dropdown</button>\n    <i class=\"fa fa-caret-down\"></i>\n  </div>\n  <ul class=\"dropdown-content\">\n    <li><button onclick=\"doSomething()\">Link 1</button></li>\n    <li><button onclick=\"doSomething()\">Link 2</button></li>\n    <li><button onclick=\"doSomething()\">Link 3</button></li>\n  </ul>\n</li>\n```\n\n이제 스크립트 태그에 \"openSubmenu\" 함수를 추가하여 하위 메뉴에 클래스를 추가하고 그 표시 속성을 설정합니다.\n\n\n\n```js\n<script>\n  function doSomething() {\n    console.log('로더가 활성화됐어요');\n    document.getElementById('main-loader').classList.add('show-loader-wrapper');\n    let timer = 0;\n    const timerInterval = setInterval(() => {\n      if (timer === 99) {\n        clearInterval(timerInterval);\n      }\n      timer += 1;\n      document.querySelector('.loader-progress').innerHTML = `${timer} %`;\n    }, 400);\n\n  }\n\n  // 새로 추가된 기능\n  function openSubmenu() {\n    console.log('서브메뉴 열기');\n    const submenu = document.querySelector('.dropdown-content');\n    submenu.classList.add('show-submenu');\n    submenu.getElementsByTagName('button')[0].focus();\n  }\n</script>\n```\n\n그런 다음, 이 클래스에 hover 효과와 동일한 스타일 속성을 부여하기 위해 기존 스타일에 클래스 이름을 추가하여 CSS 선택기를 사용하십시오:\n\n```css\n.dropdown:hover .dropdown-content,\n.navbar .dropdown-content.show-submenu {\n  display: flex;\n  flex-direction: column;\n  padding: 10px;\n}\n```\n\n이후에는 키보드로 하위 메뉴에 접근할 수 있게 됩니다. 사용자가 Enter 키를 누르면 \"openSubmenu()\" 함수에서 다음 줄 때문에 자동으로 포커스가 서브메뉴의 첫 번째 항목으로 이동할 것입니다:\n\n\n\n\n```js\nsubmenu.getElementsByTagName('button')[0].focus();\n```\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*VecBx6iFQ-moyNqkwEOAfw.gif)\n\n지금까지 페이지를 키보드나 보조 기술 장치를 통해 액세스할 수 있게 했습니다. 사용자가 페이지의 요소들 사이를 이동할 수 있는 키를 제공할 수 있는 장치입니다.\n\n이제 사용자가 페이지의 요소들을 적절하게 구별할 수 있게하는 방법에 대해 이야기해 보겠습니다.\n\n\n\n## 웹 페이지의 접근성을 높이는 대비의 역할\n\n요소 색상과 음영 사이의 효과적인 대비를 정의하는 몇 가지 지침을 제시했습니다. 이 대비 체커와 같은 유용한 사이트를 사용하여 당사의 버튼 및 내비게이션 바가 이 기준을 충족하는지 확인해 봅시다.\n\n우리의 내비게이션 바의 색상 코드는 #ccc이며, 버튼의 색상은 #e6e6e6입니다.\n\n![이미지](/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_0.png)\n\n\n\n이 문맥에서 \"그래픽 개체 및 사용자 인터페이스 구성요소\"에 주의를 기울입니다. WCAG AA에도 실패하는 것을 볼 수 있습니다. 접근성의 최소 수준이어야 하는데요. 같은 도구를 사용하여 이 기준을 충족하는 더 유용한 쉐이드를 찾아봅시다. WCAG는 그러한 요소에 대해 최소 3대 1의 대조 비를 요구합니다.\n\n![이미지](/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_1.png)\n\n버튼과 탐색 막대를 비교하고 있으니, 지금은 스크린샷의 마지막 기준에만 신경 쓰겠습니다. 이제 버튼의 배경을 업데이트해봅시다.\n\n```css\n.navbar button {\n      background: #6e6e6e;\n      border: none;\n      padding: 10px;\n      border-radius: 5px;\n}\n```\n\n\n\n이제 또 다른 문제에 부딪히게 되었어요. 우리의 네비게이션 바는 이렇게 보입니다:\n\n![Navbar](/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_2.png)\n\n텍스트가 버튼의 배경과 거의 구분되지 않아요. 다시 대비 확인 도구를 사용해서 텍스트에 어울리는 색상을 선택해 볼까요:\n\n![대비 확인](/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_3.png)\n\n\n\n우리는 WCAG AAA 지원의 높은 기준을 충족하기 위해 버튼을 약간 어둡게 만들고 버튼 텍스트를 흰색 (#fff)으로 바꿔야 할 것입니다. 이전에 정의한 다음 스타일을 찾아서 아래와 같이 색 속성을 업데이트해 주세요:\n\n```js\n.navbar button {\n      background: #595959;\n      color: #fff;\n      border: none;\n      padding: 10px;\n      border-radius: 5px;\n}\n```\n\n동시에 키보드로 탭을 눌러 버튼 아웃라인도 강조합니다.\n\n![이미지](/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_4.png)\n\n\n\n기본 아웃라인의 색상과 스타일을 변경하여 대비 기준을 충족시키는 방법에 대해 생각해 보는 것은 연습으로 남겨두겠습니다.\n\n# 우리의 메뉴는 정말로 접근성이 확보되었을까요?\n\n다음 단계에서는 화면 낭독기와 같은 보조 기술과 호환될 수 있도록 메뉴를 확인해야 합니다.\n\n## 설정\n\n\n\n웹 접근성을 고려해 코딩할 때, 스크린 리더와 같은 접근성 도구를 사용하여 테스트하는 것이 좋습니다. 데스크탑에서는 Windows 전용인 무료 NVDA를 사용할 수 있습니다.\n\n맥북에는 내장된 Apple VoiceOver가 함께 제공됩니다. command + f5를 눌러 시작/중지할 수 있어요.\n\nGoogle 확장 프로그램인 Chrome Vox도 사용 가능하지만, 제 경험에 따르면 다소 어색하게 느껴집니다.\n\n불행히도, 이 블로그에 스크린 리더 비디오를 직접 첨부할 수 없습니다. 그래서 시스템의 VoiceOver 프롬프트를 사용할 거예요. 그것들도 화면 리더에 의해 말해진 내용을 보여줍니다.\n\n\n\n시스템에 NVDA를 설치하거나 보이스오버를 사용하여 다음 단계를 따를 수 있어요. 화면 낭독기는 콘텐츠를 읽는 방식이 약간 다를 수 있지만, 사용자에게 웹사이트에 대한 기본적인 이해를 제공할 수 있어야 해요.\n\n## 구현 방법\n\n이제 화면 낭독기를 시작한 후에 페이지로 탭을 이동하면 화면 낭독기가 \"홈 버튼, 3개 항목이 있는 목록\"과 같은 내용을 말해줄 거예요. 당신이 현재 위치한 버튼을 설명하고 이용 가능한 총 항목 수를 알려줄 거예요.\n\n그러나 \"드롭다운\" 버튼으로 탭을 이동하면 부 메뉴임을 사용자에게 알리지 않아요. 화면 낭독기는 \"목록 항목 2, 드롭다운 버튼\"이라고 말하거나 그냥 \"드롭다운 버튼\"이라고 할 거예요.\n\n\n\n사용자가 유용한 정보를 놓치지 않게 하려면 \"Dropdown\" 버튼이 추가로 사용 가능한 메뉴를 가지고 있다는 것을 알려줄 필요가 있습니다.\n\n이것을 해결해 보겠습니다. 우리가 가지고 있는 WCAG 문서의 가이드라인을 참고하겠습니다.\n\n현재 가이드라인에 따르면, 우리는 이미 button 요소를 사용하고 있기 때문에 button 역할은 이미 다 covered되어 있습니다. 그러나 화면 낭독기와 같은 보조 기술을 돕기 위해 aria-haspopup와 aria-expanded 속성을 업데이트해야 합니다.\n\n또한 \"menu\" 역할을 적절하게 할당해야 합니다. 하위 메뉴는 사용자가 escape 키를 누르거나 하위 메뉴의 마지막 항목을 벗어날 때 닫혀야 합니다.\n\n\n\n지금 이것을 해 봅시다. 먼저 사용자가 하위 메뉴를 닫을 수 있도록 허용해 주겠습니다:\n\n```js\nfunction closeSubmenu() {\n  const submenu = document.querySelector(\".dropdown-content\");\n  submenu.classList.remove(\"show-submenu\");\n}\n\nfunction openSubmenu() {\n  console.log(\"하위 메뉴 열기\");\n  const submenu = document.querySelector(\".dropdown-content\");\n  submenu.classList.add(\"show-submenu\");\n  submenu.getElementsByTagName(\"button\")[0].focus();\n\n  // 메뉴를 닫는 핸들러 추가\n  window.addEventListener(\"keydown\", (event) => {\n    if (event.key === \"Escape\" && submenu.classList.contains(\"show-submenu\")) {\n      closeSubmenu();\n      const dropdownBtn = document.querySelector(\".dropbtn button\");\n      dropdownBtn.focus();\n    }\n  });\n}\n```\n\n우리는 드롭다운 컨테이너에 메뉴의 역할을 추가하고, 마지막 항목에서 벗어날 때 메뉴를 닫기 위해 마지막 요소에 \"onblur\"를 추가하고 closeSubmenu 함수를 호출합니다:\n\n```js\n<li class=\"dropdown\" role=\"menu\">\n  <div class=\"dropbtn\">\n    <button onclick=\"openSubmenu()\">드롭다운</button>\n    <i class=\"fa fa-caret-down\"></i>\n  </div>\n  <ul class=\"dropdown-content\">\n    <li><button onclick=\"doSomething()\">링크 1</button></li>\n    <li><button onclick=\"doSomething()\">링크 2</button></li>\n    <li><button onclick=\"doSomething()\" onblur=\"closeSubmenu()\">링크 3</button></li>\n  </ul>\n</li>\n```\n\n\n\n이것을 수행하는 방법은 여러 가지가 있습니다. 현재는 이를 위한 매우 간단한 해결책을 사용했습니다. 중요한 것은 메뉴가 닫힌 후에 올바른 요소로 포커스를 돌려주는 것입니다.\n\n이제 이스케이프 키를 사용하여 하위 메뉴를 닫아보세요. 작동해야 합니다.\n\n이제 접근성 도구를 사용하여 메뉴를 테스트해 보죠.\n\n화면 하단의 스크린 리더 안내문을 주목해보세요. 이제 (조금 더) 메뉴 항목으로 식별되는 것을 알 수 있을 겁니다.\n\n\n\n위의 기준에 따라 유효한 aria 속성을 설정하도록 더 세부적으로 정제하겠습니다. 또한 여기에 정의된 메뉴 및 메뉴바 기준도 설정하겠습니다.\n\n```js\nnav태그에 class=\"navbar\"를 추가합니다:\n  - 메뉴바 역할(role)을 가진 ul요소를 추가합니다:\n    - Home 버튼에 onclick=\"doSomething()\" href=\"#\"를 추가합니다.\n    - dropdown class가 있는 li요소를 추가합니다:\n      - dropbtn class를 가진 div에 다음을 추가합니다:\n        - dropdown-trigger id를 가진 버튼에 onclick=\"openSubmenu(true)\" onfocus=\"openSubmenu(false)\"을 추가하고,\n          aria-controls=\"dropdown-submenu\", aria-haspopup=\"true\", aria-expanded=\"false\"를 추가합니다.\n        - fa-caret-down class를 가진 i요소를 추가합니다.\n      - dropdown-content class를 가진 ul요소를 추가하고, aria-labelledby=\"dropdown-trigger\", role=\"menu\", id=\"dropdown-submenu\"를 추가합니다:\n        - menuitem 역할(role)을 가진 각각의 li요소를 추가하고, aria-owns=\"dropdown-submenu\"를 추가합니다.\n          - onclick=\"doSomething()\"를 추가한 버튼을 추가합니다.\n    - News 버튼에 onclick=\"doSomething()\"를 추가합니다.\n```\n\n\n\n위에 한 일들을 확인해 보세요.\n\n또한 스크립트를 수정하여 aria 확장 상태를 업데이트합시다:\n\n```js\nfunction closeSubmenu() {\n  const submenu = document.querySelector('.dropdown-content');\n  submenu.classList.remove('show-submenu');\n}\n\nfunction openSubmenu(focusOnlistItem) {\n  console.log('opening submenu');\n  const dropdownBtn = document.querySelector('.dropbtn button');\n\n  // aria 확장 상태 설정\n  dropdownBtn.ariaExpanded = true;\n  const submenu = document.querySelector('.dropdown-content');\n  submenu.classList.add('show-submenu');\n  if (focusOnlistItem) {\n    submenu.getElementsByTagName('button')[0].focus();\n  }\n  window.addEventListener(\"keydown\", (event) => {\n    if (event.key === 'Escape' && submenu.classList.contains('show-submenu')) {\n      closeSubmenu();\n\n      // 닫을 때 aria 확장 상태 재설정\n      dropdownBtn.ariaExpanded = false;\n      dropdownBtn.focus();\n    }\n  });\n}\n```\n\n이제 화면 리더가 알림을 하면서 말하는 내용을 확인해 봅시다.\n\n\n\n아래 프롬프트를 보면, 스크린 리더가 메뉴의 \"확장된\" 상태를 읽어 줍니다.\n\n서브 메뉴도 올바르게 읽혀지며 각 항목들은 적절한 menuitem 역할과 aria-owns 속성을 가지고 부모 메뉴 id를 가리킵니다:\n\n이 모든 것을 보면, 심지어 간단한 내비게이션 메뉴조차 완전히 접근 가능하게 만드는 데 얼마나 많은 것이 필요한지 놀랄 것입니다.\n\n# 접근 가능한 로더 만들기\n\n\n\n메뉴를 접근 가능하게 만든 후에 \"Enter\" 키를 눌러 화면 리더를 켠 채로 로더를 실행해보세요.\n\n이제 로더는 상호 작용 요소는 아니지만, 웹사이트를 제대로 볼 수 없는 사용자에게 페이지의 현재 상태에 대해 알려주어야 합니다. 여기서 몇 가지 잘 알려지지 않은 aria 태그가 유용할 수 있습니다.\n\n이 중 첫 번째는 aria-live입니다. 자세히 설명드리겠습니다. 이 태그는 기본적으로 페이지의 동적인 부분에 대한 정보를 사용자에게 알리는 데 사용됩니다. 화면 리더나 보조 기술이 이 태그를 인식하고 태그에 지정된 값대로 업데이트를 알려줍니다.\n\n\"doSomething\" 목업 로더 함수에 다음과 같은 변경 사항을 가해보세요:\n\n\n\n```js\n<script>\n    function doSomething() {\n      console.log('fireddd');\n      document.getElementById('main-loader').classList.add('show-loader-wrapper');\n      let timer = 0;\n      const timerInterval = setInterval(() => {\n        if (timer === 99) {\n          clearInterval(timerInterval);\n        }\n        timer += 1;\n        document.querySelector('.loader-progress').innerHTML = \n          `<span aria-live=\"polite\">${timer} % </span>`;\n      }, 400);\n\n    }\n\n    function closeSubmenu() {\n      ...\n    }\n\n    function openSubmenu(focusOnlistItem) {\n      ...\n    }\n</script>\n```\n\n위 코드에서 innerHTML에 추가한 특정한 라인을 주목해주세요:\n\n```js\n<span aria-live=\"polite\">${timer} % </span>\n```\n\n이 라인을 통해 진행 상황을 호출하는 것이 시작될 것입니다.\n\n\n\n하지만 또 다른 문제가 있어요. 화면 판독기가 업데이트를 읽어주는 동안 로더는 여러 단위로 진행돼요.\n\n이로 인해 로더의 진행 상황과 실제 진행 상황이 맞지 않게 될 수 있어요.\n\n예를 들어, 아래는 진행 불일치의 스크린샷이에요. 화면 판독기 안내와 실제 로더 진행 상황을 주목해주세요:\n\n로더 진행률은 42%인데, 화면 판독기는 \"12%\"라고 읽어주는 걸 알 수 있어요. 이는 말로 진행 상황을 명확히 이야기하는 데 걸리는 시간 때문이에요.\n\n\n\n이 문제를 해결하기 위해 특정 간격 이후에 진행 상황을 읽어주도록 할 수 있습니다. 이 간격은 예를 들어 10% 진행 후에 발생할 수 있습니다.\n\n이를 위해 true/false로 설정된 aria-busy라는 또 다른 속성을 사용할 것입니다. 여기에는 관련 문서가 있으나, 이것은 true로 설정되어 있는 동안 업데이트를 잠깐 차단할 것입니다.\n\n로더에 대한 HTML 코드를 수정해 봅시다:\n\n```js\n<div class=\"loader-wrapper\" id=\"main-loader\">\n  <div class=\"loader\">\n  </div>\n  <div class=\"loader-progress-container\">\n    <span class=\"loader-progress\">\n      <span id=\"load-progress\" aria-live=\"polite\" aria-busy=\"true\"></span>\n    </span>\n  </div>\n</div>\n```\n\n\n\n로드 진행률 스팬을 동적으로 스크립트를 통해 생성하는 대신 HTML로 옮겼습니다. 이는 이제 aria-live 및 aria-busy 속성을 추적하여 업데이트해야 하기 때문입니다. 이전에는 매번 새 요소를 생성했습니다. 이제는 요소의 단일 인스턴스가 필요하며 해당 aria 속성만 업데이트해야 합니다.\n\n다음 단계는 업데이트마다(첫 번째 업데이트 포함) 10%씩 읽어 주는 것입니다. 이를 간단히 JS 코드를 사용하여 aria-busy 속성을 true/false로 설정하여 수행할 것입니다:\n\n```js\n<script>\n    function doSomething() {\n      console.log('fireddd');\n      document.getElementById('main-loader').classList.add('show-loader-wrapper');\n      let timer = 0;\n      const timerInterval = setInterval(() => {\n\n        // 로드 진행률 스팬을 가져와 타이머를 업데이트합니다\n        const loadProgressElm = document.getElementById(\"load-progress\");\n        if (loadProgressElm) {\n          if (timer % 10 === 0 || timer === 1) {\n            // 음성 업데이트 허용\n            loadProgressElm.ariaBusy = \"false\";\n          } else {\n            // 음성 업데이트 차단\n            loadProgressElm.ariaBusy = \"true\";\n          }\n        }\n\n        if (timer === 99) {\n          clearInterval(timerInterval);\n        }\n        timer += 1;\n        loadProgressElm.innerHTML = `로딩 중 ${timer} %`;\n      }, 400);\n\n    }\n\n    function closeSubmenu() {\n      ...\n    }\n\n    function openSubmenu(focusOnlistItem) {\n      ...\n    }\n  </script>\n```\n\n실시간으로 어떻게 보이는지 확인해보세요. 하단의 프롬프트를 주목하면 마지막 진행 업데이트와 동기화되어 있음을 알 수 있습니다:\n\n\n\n그렇게 하면 스크린 리더 및 보조 기술에서 이해하기 쉬운 로더를 얻을 수 있습니다.\n\n## 결론\n\n위에서 살펴본 것을 통해 웹 사이트의 이해를 돕는 중요성에 대해 감을 잡을 수 있습니다. 위의 프로젝트를 더 다듬을 부분과 몇 가지 버그가 있지만, 이는 접근성을 구현하는 효과적인 전략 개요를 제공하는 데 사용된 데모였습니다.\n\n간단한 메뉴/로더 구현만으로도 접근성이 의미 있는 태그와 매우 높은 수준의 aria 속성을 넘어 사용자에게 가장 관련성 있는 업데이트를 제공해야 함을 이해할 수 있습니다.\n\n\n\n많은 aria 태그와 이를 구현하는 데 사용할 수 있는 해결책들이 있습니다. MDN에서 읽어보거나 WCAG 가이드라인을 확인해보세요.\n\n언제나 사용자 경험이 접근 가능해야 합니다. 사용하는 의미론적 태그의 수나 알고 있는 aria 속성의 종류와는 무관하게요!","ogImage":{"url":"/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_0.png"},"coverImage":"/assets/img/2024-05-14-Makingthewebmoreaccessiblemenusandloaders_0.png","tag":["Tech"],"readingTime":18},{"title":"획일적인 느낌을 줄이고 친근하고 친밀한 느낌을 주도록 노력하였습니다 이러한 형식으로 번역이 만족스러우시다면, 더 도움을 주실 수 있는 부분이 있으면 알려주세요","description":"","date":"2024-05-14 15:02","slug":"2024-05-14-HowtogetGithubCopilotfor100free","content":"\n\n대부분의 분들이 GitHub Copilot이 무엇인지 알고 계실 것으로 믿습니다. 알지 못하는 경우를 대비해 아래에 설명드리겠습니다.\n\n\"GitHub Copilot은 AI 페어 프로그래머로, 코드를 더 빠르고 더 쉽게 작성할 수 있도록 돕습니다. 주석과 코드에서 문맥을 추출하여 개별 라인과 전체 함수를 즉시 제안합니다. GitHub Copilot은 OpenAI가 만든 Codex라는 생성 사전 훈련 언어 모델에 의해 제공됩니다. Visual Studio Code, Visual Studio, Neovim 및 JetBrains 통합 개발 환경(IDE) 패밀리용 확장으로 제공됩니다.\"\n\n![이미지](/assets/img/2024-05-14-HowtogetGithubCopilotfor100free_0.png)\n\n아래 비디오를 시청하시거나 글을 끝까지 읽어보시면 무료로 Github Co-Pilot을 얻는 방법에 대해 알 수 있습니다.\n\n\n\n이전에 Github Co-Pilot은 미리 등록된 모든 사용자에게 무료였습니다. 이는 Github가 다양한 언어와 코드베이스를 통해 트레이닝하여 코-파일러의 AI 모델을 사용자 친화적으로 만들고 싶었기 때문입니다. 현재 Github Co-Pilot의 정확도는 약 26%로 도달했습니다. 이제 Github는 Github Co-Pilot에 대해 요금을 부과하기 시작하는 좋은 정확도라고 생각하고 있습니다.\n\n현재 Github Co-Pilot의 구독 비용은 얼마인가요:\n\n[https://github.com/github-copilot/signup](https://github.com/github-copilot/signup)\n\n![그림](/assets/img/2024-05-14-HowtogetGithubCopilotfor100free_1.png)\n\n\n\n비록 이 소프트웨어는 인간의 창조물 중에 빛나는 작품이지만, 모두가 이를 구매할 수 있는 것은 아닙니다 (대부분의 사람들은 무료 소프트웨어를 사용하는 것에 익숙합니다). 그래서, 나는 Github Co-pilot을 무료로 얻는 합법적인 방법을 찾아 냈습니다.\n\nGithub의 공식 문서에 언급되어 있듯이, Co-pilot은 오픈 소스 기여자와 학생들을 위해 무료로 제공될 것입니다.\n\n- 오픈 소스에 적극적으로 기여하고 있는 경우, 즉 인기 있는 라이브러리를 만들거나 기존 인기 있는 라이브러리의 버그를 수정하는 경우 Github는 이미 당신을 알고 있습니다. Github Co-pilot 구독을 신청하려고 할 때, 무료로 제공됩니다.\n- 또는 고등학교, 중학교, 대학, 자평, 또는 유사한 교육 기관과 같은 학위나 자격증이 주어지는 과정에 등록된 학생인 경우, Github Co-pilot을 무료로 이용할 수 있습니다. Github는 교육 세부 정보를 확인하고 유효성을 인증할 것입니다. 올바른 세부 정보를 제공하면 Github Co-Pilot에 무료로 액세스할 수 있습니다.\n- 이미 일을 하고 있고 파트타임 교육/자격증 프로그램을 이수 중인 경우 학생 범주 하에서 라이선스를 신청할 자격이 있을 수 있습니다. 그러나 Github의 심사 과정에 대해서는 확신할 수는 없지만, 시도해 볼 가치가 있습니다.\n\n위의 단계 중 어떤 것도 작동하지 않는다면, Github Co-pilot의 대안인 여러 개의 오픈 소스가 있습니다. 해당 대안에 대해 알고 싶다면 댓글 섹션에 알려주세요. 저는 그것들을 설명하는 기사를 작성할 것입니다.\n\n\n\n만약 개인적으로 모의 면접, 면접 대비 팁과 노하우, 또는 이력서 검토에 대해 이야기를 나누고 싶다면, 여기에서 세션을 예약할 수 있어요:\n\n즐거운 독서, 다음 기사에서 뵙겠습니다.\n\n동일한 저자의 다른 기사들:\n\n- 90%가 풀지 못할 페이스북 면접 문제\n- 드디어 Github Co-Pilot이 모두에게 공개되었어요\n- Meta, Amazon, Google, Apple, Microsoft 프론트엔드 개발자 면접 문제 풀기\n- 최근 페이스북 프론트엔드 개발자 면접 문제 풀기","ogImage":{"url":"/assets/img/2024-05-14-HowtogetGithubCopilotfor100free_0.png"},"coverImage":"/assets/img/2024-05-14-HowtogetGithubCopilotfor100free_0.png","tag":["Tech"],"readingTime":2},{"title":"캔버스의 마법을 해제해 보세요","description":"","date":"2024-05-14 15:01","slug":"2024-05-14-UnlockingtheMagicofCanvas","content":"\n\n## 예술이 코드와 만나는 곳\n\n# 캔버스란?\n\n캔버스는 HTML5 스위트 내에서 놀라운 기능으로, 웹 브라우저 안에서 예술적 및 계산적 가능성을 펼칠 수 있도록 설계되었습니다. 그래픽 콘텐츠와 애니메이션에 대한 강력한 플레이그라운드로서, 개발자들이 제3자 플러그인이나 라이브러리가 필요 없이 자신의 창의성과 기술을 펼칠 수 있도록 초대합니다.\n\n![캔버스 이미지](/assets/img/2024-05-14-UnlockingtheMagicofCanvas_0.png)\n\n\n\n# 캔버스의 탁월한 기능들\n\n- 유연성: 캔버스는 예술가를 위한 빈 캔버스와 같습니다; 다양한 그래픽 및 애니메이션을 만들기 위한 절대적인 유연성을 제공합니다.\n- 클라이언트 측 렌더링: 캔버스의 놀라운 점 중 하나는 모든 렌더링 작업이 클라이언트 측에서 수행되어 서버 부하를 줄이고 더 빠르고 효율적인 실행을 보장한다는 것입니다.\n- 고성능: 하드웨어 가속을 통해 캔버스는 유동적인 애니메이션 및 복잡한 그래픽 작업에 대한 빠른 옵션으로 빛납니다.\n- 다재다능한 렌더링: 2D 또는 WebGL이든, 캔버스는 프로젝트의 필요에 맞는 다양한 렌더링 옵션을 제공합니다.\n- JavaScript와의 깊은 통합: 포괄적인 JavaScript API로, 캔버스는 복잡한 작업 및 조작을 손쉽게 수행할 수 있게 합니다.\n\n# 다양한 응용 분야\n\n- 데이터 시각화: 인터랙티브 그래프, 상세한 지도, 실시간 분석 대시보드 등을 상상해보세요.\n- 게임 개발: 캔버스 덕분에 웹 기반 게임이 살아나고 있습니다.\n- 이미지 처리: 사진 편집부터 필터 적용까지, 가능성은 무한합니다.\n- 인터랙티브 애니메이션: 시각적으로 매력적인 UI 및 애니메이션 스토리텔링을 구축하는 데 중요한 역할을 합니다.\n- 실시간 렌더링: 음악 파형, 실시간 데이터 시각화 - 무엇이든, 캔버스가 처리할 수 있습니다.\n\n\n\n# 훌륭한 예시\n\n여기에 당신을 위한 CodePen 샌드박스가 있어요. 페이지를 클릭해서 즐겁게 놀아보세요!\n\n# 코드 설명\n\n## HTML 구조\n\n\n\n우리는 HTML에서 `canvas` 태그를 정의하고 ID를 할당하여, 그래픽 가능성의 세계로의 게이트웨이 역할을 하도록 시작합니다.\n\n```html\n<div class=\"page\" >\n  <canvas id=\"canvas\" class=\"canvas\"></canvas>\n</div>\n```\n\n## 스타일링하기\n\nCSS에서는 Canvas가 정말 빛날 수 있는 세련된 환경을 설정합니다.\n\n\n\n```js\n.page {\n  /* 페이지 콘텐츠를 가운데 정렬 */\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n  width: 100vw;\n}\n.canvas {\n  /* Canvas를 전체 화면으로 설정하고 가장 하단 레이어에 위치시킴 */\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: -1;\n  background-color: #000;\n}\n```\n\n## JavaScript 생태계\n\n여기서 우아한 두 가지 클래스인 StarrySky와 Particle을 소개합니다.\n\n```js\nclass StarrySky {\n    canvas;\n    ctx;\n    particles;\n    count;\n    actions;\n    action;\n\n    constructor() {\n        this.canvas = document.getElementById('canvas');\n        this.canvas.width = innerWidth;\n        this.canvas.height = innerHeight;\n        this.canvas.style.zIndex = '-1';\n        this.ctx = this.canvas.getContext('2d');\n        this.particles = [];\n        this.count = 300;\n\n        this.actions = ['right', 'left', 'up', 'down', 'around'];\n        this.action = 0;\n    }\n\n    init() {\n        this.animate();\n        this.event();\n    }\n\n    event() {\n        document.body.addEventListener('click', () => {\n            this.action += Math.floor(Math.random() * this.actions.length) || 1;\n            this.action = this.action % this.actions.length;\n        });\n    }\n\n    draw() {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        if (this.particles.length < this.count) {\n            this.particles.push(\n                new Particle(this.canvas.width, this.canvas.height, this.ctx)\n            );\n        }\n        for (let i in this.particles) {\n            const p = this.particles[i];\n            p.update(this.actions[this.action]);\n            p.draw();\n        }\n    }\n\n    animate() {\n        requestAnimationFrame(() => this.animate());\n        this.draw();\n    }\n\n}\n\nclass Particle {\n    x;\n    y;\n    vx;\n    w;\n    h;\n    ctx;\n\n    constructor(width, height, ctx) {\n        this.w = width;\n        this.h = height;\n        this.ctx = ctx;\n        this.x = Math.random() * width;\n        this.y = Math.random() * height;\n        this.vx = Math.random();\n    }\n\n    update(direction = 'right') {\n        switch (direction) {\n            case 'right':\n                this.x += this.vx * 3;\n                if (this.x > this.w) this.x = 0;\n                break;\n            case 'left':\n                this.x -= this.vx * 3;\n                if (this.x < 0) this.x = this.w;\n                break;\n            case 'up':\n                this.y -= this.vx * 3;\n                if (this.y < 0) this.y = this.h;\n                break;\n            case 'down':\n                this.y += this.vx * 3;\n                if (this.y > this.h) this.y = 0;\n                break;\n        }\n    }\n\n    draw() {\n        this.ctx.beginPath();\n        this.ctx.arc(this.x, this.y, 1 + this.vx, 0, Math.PI * 2);\n        this.ctx.fillStyle = `rgba(255, 255, 255, ${this.vx})`;\n        this.ctx.fill();\n    }\n}\n```\n\n\n\n- StarrySky: 캔버스와 입자 객체를 초기화하고 관리하는 역할을 맡습니다.\n- Particle: 개별 입자의 렌더링 및 업데이트에 초점을 맞춥니다.\n\n```js\n// 초기화\nconst starrySky = new StarrySky();\nwindow.onload = () => {\n  starrySky.init();\n};\nwindow.onresize = () => {\n  starrySky.canvas.width = innerWidth;\n  starrySky.canvas.height = innerHeight;\n};\n```\n\n페이지가 로드될 때 우리는 StarrySky 클래스의 경이로운 힘을 소환합니다. 또한, 창 크기가 조정될 때 캔버스의 크기를 동적으로 조정하여 항상 매혹적인 경험을 제공합니다.\n\n## 코드 자세히 설명\n\n\n\n- 캔버스와 컨텍스트: this.canvas = document.getElementById(`canvas`); 및 this.ctx = this.canvas.getContext(`2d`); 라인을 사용하여 캔버스의 우주와 2D 그리기 공간에 접근합니다.\n- 입자 이동: this.actions = [`right`, `left`, `up`, `down`, `around`]; 라인에서는 클릭으로 입자가 날아갈 방향을 조절할 수 있는 능력을 제공합니다.\n- 애니메이션 루프: requestAnimationFrame(() =` this.animate()); 라인은 매혹적이고 끝없는 애니메이션 루프를 제공합니다.\n- 이벤트 리스너: document.body.addEventListener(`click`, () =` ' ... ');를 통해 각 클릭이 입자 행동을 변화시켜 애니메이션을 더 인터랙티브하고 동적으로 만듭니다.\n- 입자 업데이트 및 렌더링: this.particles.push(new Particle(...));을 통해 새로운 우주 입자를 생성하고 p.update() 및 p.draw()를 통해 이동과 외관을 업데이트합니다.\n\n캔버스는 웹 개발 세계에서 놀라운 기술로 자리 잡고 있습니다. 데이터 시각화부터 대규모 웹 기반 게임 제작까지, 응용 분야는 여러분의 상상력만큼 무한합니다. 이 가이드는 캔버스에 대한 이해를 풍성하게 하고 멋진 프로젝트를 시작할 자극을 드리기 위해 노력합니다. 그러니 할 수 있어요, 캔버스가 여러분의 타작게요!\n\n만약 이 글을 좋아한다면, 박수를 보내주세요. 여러분의 응원이 제 창의적 엔진을 충전합니다. 건배하며 백만 번 감사합니다!\n\n<img src=\"/assets/img/2024-05-14-UnlockingtheMagicofCanvas_1.png\" />","ogImage":{"url":"/assets/img/2024-05-14-UnlockingtheMagicofCanvas_0.png"},"coverImage":"/assets/img/2024-05-14-UnlockingtheMagicofCanvas_0.png","tag":["Tech"],"readingTime":6},{"title":"NodeJS에서 ExpressJS를 사용하여 GET 및 POST 엔드포인트를 만드는 방법","description":"","date":"2024-05-14 15:00","slug":"2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS","content":"\n\n<img src=\"/assets/img/2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS_0.png\" />\n\nGET 및 POST 엔드포인트는 REST API에서 가장 일반적인 엔드포인트 중 두 가지입니다. GET 엔드포인트를 사용하면 클라이언트가 서버에서 데이터를 검색할 수 있고, POST 엔드포인트를 사용하면 클라이언트가 서버로 데이터를 보낼 수 있습니다. 여기에서는 NodeJS와 ExpressJS를 사용하여 필수 GET 및 POST 엔드포인트를 만드는 방법을 보여드릴 거에요.\n\n# GET 엔드포인트 생성\n\nGET 엔드포인트를 만들려면 app.get() 메서드를 사용할 수 있어요. 이 메서드는 두 개의 매개변수를 가지는데, 첫 번째는 엔드포인트의 경로이고, 두 번째는 클라이언트가 엔드포인트에 GET 요청을 할 때마다 실행될 콜백 함수입니다.\n\n\n\n다음은 /users-list 경로에 GET 엔드포인트를 만드는 방법의 예시입니다:\n\n```js\nconst express = require('express');\n\nconst app = express();\n\napp.get('/users-list', (req, res) => {\n  // 사용자 목록 전체를 가져옵니다\n  const usersList = [];\n\n  // 사용자 목록을 클라이언트에 응답으로 전송합니다\n  res.send(usersList);\n});\n```\n\n다음은 위에서 만든 엔드포인트를 사용하여 GET 요청을 보내는 방법의 예시입니다:\n\n```js\nconst fetch = require('fetch');\n\nfetch('http://localhost:3000/users-list')\n  .then(response => response.json())\n  .then(usersList => {\n    console.log(usersList.data);\n    // 응답으로 수행하려는 동작을 작성합니다\n  })\n  .catch(error => {\n    console.log(error);\n    // 요청이 성공적이지 않을 때의 오류를 처리합니다\n  });\n```\n\n\n\n만일 이 엔드포인트를 테스트하고 싶다면, Postman에서 다음 단계를 따르세요:\n\n- Postman을 열고 새 요청을 생성하세요.\n- HTTP 메소드를 GET으로 설정하세요.\n- URL을 http://localhost:3000/users-list로 설정하세요.\n- 보내기 버튼을 클릭하여 요청을 보내세요.\n\n가끔은 GET 요청과 함께 쿼리 매개변수를 보내야 할 때가 있습니다. 여기에 간단한 코드 조각이 있습니다:\n\n```js\nconst express = require('express');\nconst app = express();\napp.get('/users-list/:id', (req, res) => {\n  const id = req.params.id;\n  // 데이터베이스에서 사용자 데이터 가져오기\n  const user = {\n    id: 1,\n    name: 'John Doe',\n  };\n  // 클라이언트에 응답 보내기\n  res.send({\n    user: user,\n  });\n});\n```\n\n\n\n# POST 엔드포인트 생성하기\n\nPOST 엔드포인트를 만들려면 app.post() 메소드를 사용할 수 있어요. 이 함수는 app.get() 메소드와 유사하게 두 개의 매개변수를 사용해요. 하지만 여기서는 콜백 함수에서 요청 바디인 즉, 클라이언트가 요청할 때 보내는 데이터에 접근할 수 있어요. 이 엔드포인트를 사용하여 새로운 사용자를 만들 수 있어요.\n\n다음은 /users-list 경로에 POST 엔드포인트를 만드는 예시에요:\n\n```js\nconst express = require('express');\n\nconst app = express();\n\napp.post('/users-list', (req, res) => {\n  const usersList = req.body;\n\n  // 클라이언트가 보낸 사용자 데이터를 저장해요\n\n  // 요청이 성공적이었음을 보여주는 응답을 클라이언트에게 보내요\n  res.send({\n    message: '새 사용자가 목록에 추가되었어요',\n  });\n});\n```\n\n\n\n위에서 만든 엔드포인트를 사용하여 POST 요청을 보내는 예시입니다:\n\n```js\nconst fetch = require('fetch');\n\nconst user = {\n  name: \"John Doe\",\n  email: \"john.doe@example.com\"\n};\n\nfetch('http://localhost:3000/users-list', {\n  method: 'POST',\n  body: JSON.stringify(user)\n})\n  .then(response => {\n    console.log(response.data);\n  })\n  .catch(error => {\n    console.log(error);\n});\n```\n\n아래는 이 엔드포인트를 Postman에서 테스트하는 방법에 대한 단계입니다:\n\n- Postman을 열고 새 요청을 작성합니다.\n- HTTP 메서드를 POST로 설정합니다.\n- URL을 http://localhost:3000/users-list로 설정합니다.\n- Body 탭에서 content-type 헤더를 application/json로 설정합니다.\n- 그런 다음 보내고 싶은 JSON 데이터를 본문 탭에 붙여넣습니다.\n- Send 버튼을 클릭하여 요청을 보냅니다.\n\n\n\n위에 제시된 예시들은 매우 기본적이고 데모 목적으로 제공되었어요. 그러나 당신의 요구에 따라 더 복잡한 엔드포인트를 생성하기 위해 같은 단계를 따를 수 있어요.\n\n아래는 엔드포인트를 생성하는 동안 고려할 수 있는 몇 가지 추가 팁이에요:\n\n- 개발자가 실제로 엔드포인트가 무엇을 하는지 이해하는 데 도움이 되는 설명적인 엔드포인트 경로를 사용하세요.\n- POST 엔드포인트의 요청 본문을 유효성 검사할 수도 있어요. 이것은 받는 데이터가 올바른 형식에 있는지 확인하는 추가적인 검사층 역할을 해요.\n- 가능하다면 팀 내 다른 개발자에게 쉽게 엔드포인트를 설명할 수 있는 철저한 문서를 유지하는 것이 좋아요.\n\n위의 정보가 도움이 되었기를 바래요. 읽어주셔서 감사해요. 질문, 의견 또는 관심사가 있으면 아래에 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS_0.png"},"coverImage":"/assets/img/2024-05-14-HowtocreateGETandPOSTendpointsinNodeJSusingExpressJS_0.png","tag":["Tech"],"readingTime":4},{"title":"Nodejs가 쇠약하다고 Bun 10이 JavaScript 게임을 바꾼다","description":"","date":"2024-05-14 14:59","slug":"2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame","content":"\n\n![Node.js is Dying, Bun 1.0 is Changing the JavaScript Game](/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_0.png)\n\n그 이전에, 자바스크립트 런타임이 무엇이며 왜 속도에 대해 신경 써야 하는지 설명해야 합니다.\n\n자바스크립트로 이야기를 쓰고 누군가에게 읽어달라고 부탁했다고 상상해보세요. 자바스크립트 런타임은 당신의 이야기를 살아있게 만드는 친근한 서술자 같은 존재입니다! 이것은 당신의 자바스크립트 이야기가 읽히고 연기되는 특별한 환경입니다. 하지만 좀 더 깊게 들어가보죠. 기술적으로, 이 '서술자'는 자바스크립트 엔진과 같은 구성 요소로 구성되어 있습니다. 이 엔진은 런타임의 핵심으로서 코드를 이해하고 실행하는 일을 담당합니다. 이것은 업무를 실행하고 코드가 스스로 걸림돌에 걸리지 않도록 하는 이벤트 루프와 같은 도구와 함께 사용됩니다. 또한 모든 캐릭터(또는 변수)가 각자 공간을 가지는 메모리 힙이 포함되어 있습니다. 씬별로 이야기의 액션이 일어나는 곳을 추적하는 호출 스택도 있습니다.\n\n# Bun 1.0 소개\n\n\n\nBun은 인기 있는 Node JS와 Deno보다 여러 가지 주요 장점을 가지고 있는 새로운 JavaScript 런타임입니다. Bun은 앱을 더 빠르게 만들기 위해 코드에 추가 복잡성을 추가할 필요 없이 설계되었습니다.\n\nNode.js의 대체물로 만들어졌기 때문에 Bun을 사용할 때는 node나 nodemon이 필요하지 않습니다. Bun은 내장된 감시 모드, dotenv, cross-env를 갖추고 있으며 .env 파일을 기본적으로 읽습니다.\n\n또한 Bun은 .js, .ts, .mjs, .jsx, .cjs, .tsx와 같은 다양한 파일을 실행할 수 있기 때문에 이제 프로젝트에 babel, tsc, ts-node 및 tsx를 설치할 필요가 없습니다.\n\nBun은 놀라운 성능을 자랑하는 JavaScript 번들러이며 esbuild 호환 플러그인 API를 제공하므로 esbuild, webpack 및 parcel도 필요하지 않습니다.\n\n\n\nBun은 npm과 yarn보다 빠른 속도가 가장 큰 이점 중 하나입니다. Bun은 npm과 yarn에 있는 익숙한 모든 명령어를 사용할 수 있는 npm 호환 패키지 매니저입니다. 또한 package.json 파일을 읽고 node_modules에 쓰지만 30배 빠르기 때문에 게임 체인저입니다.\n\n기본으로 Jest와 호환되는 테스트 러너를 내장하고 있어 추가 종속성을 설치하지 않고도 단위 테스트를 작성할 수 있습니다.\n\nNode.js의 대체할 수 있는 디자인으로 개발되었기 때문에 path, fs, net과 같은 일반적인 Node.js 모듈과 __dirname, process와 같은 전역 변수를 내장 지원합니다.\n\n# 성능 비교\n\n\n\n우리가 말했듯이 Bun은 Node.js보다 4배 빠르기 때문에 코드가 가벼워지고 실행 시간이 짧아지는데, 사용하기도 간단해요.\n\n```js\n$ bun install \n```\n\n<img src=\"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_1.png\" />\n\n테스트를 실행하는 차이는 더 미친 것 같아요.\n\n\n\n```js\n$ bun test\n```\n\n<img src=\"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_2.png\" />\n\n사용하기 쉽습니다. 다음은 Bun을 사용하여 HTTP 서버를 만드는 예제입니다.\n\n```js\nconst server = Bun.serve({\n  port: 3000,\n  fetch(request) {\n    return new Response(“Bun에 오신 것을 환영합니다!\");\n  },\n});\n\nconsole.log(`localhost:${server.port}에서 서버를 대기 중입니다`);\n```\n\n\n\n# Bun이 Node.JS를 대체해야 할까요?\n\n요약하면, Bun은 자바스크립트 세계에서 새롭고 멋진 장난감 같은 존재입니다. 다음 프로젝트에 무엇을 사용할지 고민 중이라면 Bun을 한 번 시도해보는 것을 권해드립니다. 신뢰성이 있고, Node.js에 없는 멋진 기능들을 갖추고 있으며 빠르기도 합니다.\n\nBun 팀이 다음에 어떤 일을 할지 기대되네요. 그리고 더 자세히 알고 싶다면, [공식 안내서](링크)를 확인해보세요. 필요한 모든 세부 정보가 담겨 있답니다!\n\nBun에 대한 생각은 어떠신가요? Node.js를 대체할 것인가요? 아래 댓글에서 함께 토론해보세요!\n\n\n\n# 친근한 한국어 번역\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가에게 박수를 보내고 팔로우하세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾을 수 있어요. 🚀\n- 무료 주간 뉴스레터에 가입하세요. 🗞️\n- 트위터(X), 링크드인, 유튜브, 디스코드에서 우리를 팔로우하세요.","ogImage":{"url":"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_0.png"},"coverImage":"/assets/img/2024-05-14-NodejsisDyingBun10isChangingtheJavaScriptGame_0.png","tag":["Tech"],"readingTime":3},{"title":"Nodejs에서 SOLID 원칙 마스터하기 실전 예제와 모범 사례 ","description":"","date":"2024-05-14 14:58","slug":"2024-05-14-MasteringSOLIDPrinciplesinNodejsPracticalExamplesandBestPractices","content":"\n\nNode.js 개발의 광활한 우주에서 SOLID 원칙을 숙달하면 튼튼하고 유지보수가 쉽며 확장 가능한 애플리케이션을 만들 수 있는 우주선이 될 것입니다. 🛸 SOLID 우주를 탐험하며 각 원칙을 실제 예제와 코드 스니펫과 함께 살펴봅시다.\n\n## 단일 책임 원칙 (SRP) 🎯\n\n하나의 임무를 가진 우주선을 상상해보세요: 먼 행성으로 화물을 전달하는 것. 마찬가지로 Node.js에서 각 모듈은 하나의 명확한 목적을 가져야 합니다.\n\n예시: 사용자 서비스 모듈 🤖\n\n\n\nDo:\n\n```js\n// userService.js\nconst getUserById = (userId) => {\n  // 데이터베이스에서 사용자를 가져오는 로직\n};\n\nconst updateUser = (userId, newData) => {\n  // 데이터베이스에서 사용자를 업데이트하는 로직\n};\n\nmodule.exports = { getUserById, updateUser };\n```\n\nDon't:\n\n```js\n// IncorrectUserService.js\nconst userController = require('./userController');\n\nconst getUserByIdAndUpdate = (userId, newData) => {\n  // 같은 함수에서 사용자를 가져오고 업데이트하는 로직\n};\n```\n\n\n\n## 개방/폐쇄 원칙 (OCP) 🚪\n\n우주선의 문이 우주의 진공으로부터 닫혀있는 것처럼, 모듈은 확장을 위해 열려있지만 수정을 위해서는 닫혀있어야 합니다.\n\n예시: Logger 모듈 📝\n\n올바른 방법:\n\n\n\n```js\n// logger.js\nclass Logger {\n  log(message) {\n    // 메시지를 기록하는 로직\n  }\n}\nmodule.exports = Logger;\n```\n\n하지 말아야 할 것:\n\n```js\n// IncorrectLogger.js\nconst logger = require('./logger');\n\nlogger.customLog = (message, level) => {\n  // 사용자 정의 로깅 로직\n};\n```\n\n## 리스코프 치환 원칙 (LSP) 🧩\n\n\n\n\n소프트웨어 개발의 광대한 은하 속에서, 하위 클래스는 혼돈을 초래하지 않으면서 상위 클래스의 역할을 원활하게 수행해야 합니다.\n\n예: 데이터베이스 어댑터 📡\n\n올바르게 적용하라:\n\n```js\n// dbAdapter.js\nclass DatabaseAdapter {\n  connect() {\n    // 데이터베이스에 연결하는 로직\n  }\n}\n\nmodule.exports = DatabaseAdapter;\n```\n\n\n\n좋은 동료! 😊\n\n다음과 같이 변경해주실 수 있을까요?:\n\n\n```js\n// IncorrectDBAdapter.js\nclass MongoDBAdapter extends DatabaseAdapter {\n  connectToMongoDB() {\n    // Logic to connect specifically to MongoDB\n}\n```\n\n## Interface Segregation Principle (ISP) 🛠️\n\n만능 도구가 다양한 작업에 적응할 수 있는 것처럼, 인터페이스는 불필요한 메서드를 난잡하게 늘리지 않고 특정 필요에 맞게 설계되어야 합니다.\n\n\n\n예시: 인증 모듈 🔐\n\n다음과 같이 하세요:\n\n```js\n// auth.js\nclass Auth {\n  login(username, password) {\n    // 사용자 인증 로직\n  }\n  logout() {\n      // 사용자 로그아웃 로직\n    }\n  }\nmodule.exports = Auth;\n```\n\n하지 말아주세요:\n\n\n\n```js\n// IncorrectAuth.js\nclass Auth {\n  login(username, password) {\n    // 사용자를 인증하기 위한 로직\n  }\n  deleteUser(userId) {\n    // 사용자 삭제를 위한 관련 없는 메서드\n  }\n}\n```\n\n## 의존 역전 원칙 (DIP) 🔄\n\n의존성의 끊임없이 변화하는 우주에서, 고수준 모듈은 구체적인 구현이 아닌 추상화를 바라봐야 합니다.\n\n예시: 이메일 서비스 📧\n\n\n\n\n아래와 같이 변경해 주세요:\n\n\n// emailService.js\nclass EmailService {\n  sendEmail(to, subject, body) {\n    // 이메일을 보내는 로직\n  }\n}\n\nmodule.exports = EmailService;\n\n\n\n// IncorrectEmailService.js\nconst nodemailer = require('nodemailer');\n\nconst sendEmail = (to, subject, body) => {\n  // nodemailer를 직접 사용하여 이메일을 보내는 로직\n};\n\n\n\n\n이러한 SOLID 원칙에 따라 Node.js 프로젝트를 조정함으로써, 우리는 자신감과 미련으로 소프트웨어 개발의 광대한 우주를 탐험할 수 있습니다. 🌌 행복한 코딩, 동료 우주 탐험가 여러분! 🚀","ogImage":{"url":"/assets/img/2024-05-14-MasteringSOLIDPrinciplesinNodejsPracticalExamplesandBestPractices_0.png"},"coverImage":"/assets/img/2024-05-14-MasteringSOLIDPrinciplesinNodejsPracticalExamplesandBestPractices_0.png","tag":["Tech"],"readingTime":3},{"title":"Execa 9 저희의 가장 큰 릴리스","description":"","date":"2024-05-14 14:56","slug":"2024-05-14-Execa9ourbiggestrelease","content":"\n\n\n![Execa](/assets/img/2024-05-14-Execa9ourbiggestrelease_0.png)\n\nExeca는 스크립트, 애플리케이션 또는 라이브러리에서 명령을 실행합니다. zx와 Bun 쉘과는 달리, Execa는 쉘과 Bash 스크립트의 옛날과 거리를 둡니다. 대신, 현대적이고 완전히 JavaScript 방식을 채택하여 프로그래밍적 사용에 최적화되었습니다. 이러한 접근 방식은 명령 실행을 간단하고 안전하며 크로스 플랫폼이며 디버깅하기 쉽게 만듭니다.\n\n```js\nimport {$} from 'execa';\n\nconst tokensUrl = 'https://example.com/api/tokens';\nconst token = await $`curl ${tokensUrl}`\n  .pipe`grep api_token`\n  .pipe`head -n 1`;\n\nconst branch = await $`git branch --show-current`;\n\nconst logFile = 'logs.txt';\nawait $({stderr: logFile})`dep deploy\n  --parallel\n  --token=${token}\n  --branch=${branch}`;\n```\n\n프로젝트가 8년 된 이후에도 매우 활발하게 유지되고 있습니다. 사실, 오늘의 릴리스는 지금까지의 가장 큰 릴리스로, 6명의 기여자, 개발 9개월, 317개 PR 및 3915개 자동화된 테스트가 포함되었습니다. 여기에 몇 가지 새로운 기능 중 일부를 강조해보겠습니다.\n\n\n\n\n# 출력을 한 줄씩 읽기\n\n만약 명령어가 오랜 시간 동안 실행된다면, 여전히 실행 중일 때 출력을 읽을 수도 있습니다. 대부분의 명령어는 텍스트 기반이므로, 일반적으로 각 출력 라인을 반복하여 처리해야 합니다. 처음에는 간단해 보일 수 있지만, 실제로는 제대로 처리하는 것이 꽤 어려운 일이죠.\n\nExeca를 사용하면 명령어를 한 번에 한 줄씩 반복할 수 있습니다. lines 옵션을 사용하면 전체 출력을 여러 줄로 나눌 수도 있습니다.\n\n```js\nimport { execa } from 'execa';\n\n// 한 번에 한 줄씩\nfor await (const line of execa`npm run build`) {\n  if (line.includes('ERROR')) {\n    await reportError(line);\n  }\n}\n\n// 한 번에 모든 줄\nconst { stdout: lines } = await execa({\n  lines: true,\n})`npm run build`;\nconst errorLines = lines\n  .filter(line => line.includes('ERROR'))\n  .join('\\n');\nconsole.error(errorLines);\n```\n\n\n\n# 입력과 출력을 매핑/필터링하다\n\nNode.js Duplexes와 Transforms는 데이터를 매핑하거나 필터링하는 스트림입니다. 파싱 CSV부터 데이터 압축 또는 로깅까지 다양한 사용 가능한 모듈이 있습니다.\n\nExeca를 사용하면 명령어의 stdin, stdout 또는 stderr 옵션으로 바로 전달하여 입력 또는 출력을 변환할 수 있습니다. 웹 기반 TransformStreams도 지원됩니다.\n\n스트리밍은 메모리를 점진적으로 소비하고 CPU를 작은 버스트로 유지합니다. 명령어가 느리거나 출력이 큰 경우 일괄적으로 최종 결과를 수정하는 것보다 효율적입니다.\n\n\n\n```js\nimport {execa} from 'execa';\n\nconst {stdout} = await execa({\n  stdout: new CompressionStream('gzip'),\n  encoding: 'buffer',\n})`npm run build`;\n\n// `stdout`이 gzip으로 압축되었습니다\nconsole.log(stdout); \n```\n\n# Generator-based transforms\n\n그렇지만 직접 스트림을 작성하는 일은 어려울 수 있습니다. 그들의 혜택을 누리고자 하지만 구체적인 내용에 대해 자세히 파고들기 싫다면 간단한 제너레이터 함수 대신 사용할 수 있습니다.\n\n```js\nimport {execa} from 'execa';\n\nlet count = 0;\nconst {stdout} = await execa({\n  * stdout(line) {\n    yield `[${count++}] ${line}`;\n  },\n})`npm run build`;\n\n// 줄 번호를 접두사로 붙입니다:\n// [0] ...\n// [1] ...\n// [2] ...\nconsole.log(stdout);\n```\n\n\n\n# 입력 및 출력 리디렉션\n\n명령어의 입력 또는 출력은 종종 유닉스 쉘 내에서 사용되는 \\`와 \\` 내장 연산자에 의해 표시된 대로 파일로 리디렉팅됩니다. Execa를 사용하면 stdin, stdout 또는 stderr 옵션에 'file: \\`./path\\`' 객체를 전달하여 이 작업을 수행할 수 있습니다.\n\n또 다른 일반적인 작업은 명령어의 출력을 점진적으로 표시하는 것입니다. stdout 또는 stderr 옵션에 'inherit'를 전달하면 이를 달성할 수 있지만, 출력을 변수에 저장하는 것을 방지합니다. 대신에 [`inherit`, `pipe`]를 전달하면 이 문제를 해결할 수 있습니다.\n\n```js\nimport {execa} from 'execa';\n\nconst {stderr} = await execa({\n  // stdout를 파일에 작성\n  stdout: {file: './stdout.txt'},\n  // stderr를 반환하되 출력도 함께 표시\n  stderr: ['inherit', 'pipe'],\n})`npm run build`;\n```\n\n\n\n# 여러 명령어를 연결하기\n\n파이프 연산자(|)는 대화식 터미널에서 아주 유용합니다. 그러나 스크립트 파일에서는 쉽게 다음을 할 수 없을 때가 있습니다:\n\n- 각 명령의 출력을 가져오기 어려울 수 있어 디버깅을 어렵게 만듭니다.\n- 오류 처리가 어렵습니다: 파이프라인 내의 몇 가지 명령이 실패해도 파이프라인이 성공할 수 있습니다(pipefail 옵션이 설정되지 않은 경우).\n- 하나의 명령을 여러 개에, 또는 여러 명령을 하나의 명령에 파이프하는 것이 어렵습니다.\n- 명령의 파이프 목적지를 변경하기 어렵습니다.\n- 파이프라인 문자열을 TypeScript에서 구문 분석하는 것이 불가능하기 때문에 강한 유형을 활용할 수 없습니다.\n\nExeca의 subprocess.pipe() 메소드는 위의 모든 것을 수행할 수 있어 프로그래밍적인 환경에서 더 나은 경험을 제공합니다.\n\n\n\n```js\nimport {execa, execaNode} from 'execa';\n\n// `npm run build | sort | head -n 2`를 실행합니다\n// 위의 세 개의 명령 중 하나라도 실패하면 오류가 발생합니다\nconst finalResult = await execa`npm run build`\n  .pipe`sort`\n  .pipe`head -n 2`;\n// `npm run build | sort`를 실행합니다\nconst sortResult = finalResult.pipedFrom[0];\n// `npm run build`를 실행합니다\nconst buildResult = sortResult.pipedFrom[0];\n\n// 동일한 로깅 프로세스로 여러 명령을 파이프합니다\nconst logger = execaNode`log-remotely.js`;\nawait Promise.all([\n  execa`npm run build`.pipe(logger),\n  execa`npm run test`.pipe(logger),\n]);\n```\n\n# 자세한 모드\n\n명령어는 때때로 블랙박스처럼 느껴집니다. 이들은 서로 격리된 프로세스에서 실행되어, 작은 오타가 몇 시간동안의 디버깅 지옥으로 변할 수 있습니다.\n\n이 문제를 완화하기 위해, 자세한 모드가 개선되어 자동으로 명령어의 인수, 출력, 오류, 완료 및 소요 시간을 출력합니다.\n\n\n\n```js\n// build.js\nimport {execa} from 'execa';\n\nawait execa`npm run build`;\nawait execa`npm run test`;\n```\n\n```js\n$ NODE_DEBUG=execa node build.js\n[00:57:44.581] [0] $ npm run build\n[00:57:44.653] [0]   애플리케이션 빌드 중...\n[00:57:44.653] [0]   빌드 완료.\n[00:57:44.658] [0] ✔ (수행 시간: 78ms)\n[00:57:44.658] [1] $ npm run test\n[00:57:44.740] [1]   테스트 실행 중...\n[00:57:44.740] [1]   오류: 진입점이 잘못되었습니다.\n[00:57:44.747] [1] ✘ 명령이 종료 코드 1로 실패했습니다: npm run test\n[00:57:44.747] [1] ✘ (수행 시간: 89ms)\n```\n\n# 상세한 오류\n\n오류 메시지에는 이제 출력 내용, 수행 시간 및 실패 원인에 대한 추가 정보와 통찰이 포함되어 있습니다.\n\n\n\n```js\nimport {execa} from 'execa';\n\ntry {\n  await execa({timeout: 5000})`npm run build`;\n} catch (error) {\n  console.error(error);\n  // ExecaError: Command timed out after 5000 milliseconds: npm run build\n  //     at file:///home/me/Desktop/example.js:2:20\n  //     at ... {\n  //   command: 'npm run build',\n  //   escapedCommand: 'npm run build',\n  //   cwd: '/path/to/cwd',\n  //   durationMs: 19.95693,\n  //   failed: true,\n  //   timedOut: true,\n  //   isCanceled: false,\n  //   isTerminated: true,\n  //   isMaxBuffer: false,\n  //   signal: 'SIGTERM',\n  //   signalDescription: 'Termination',\n  //   stdout: 'Building the application...',\n  //   stderr: 'Warning: deprecated API.',\n  //   stdio: [\n  //     undefined, \n  //     'Building the application...', \n  //     'Warning: deprecated API.',\n  //   ],\n  //   pipedFrom: []\n  // }\n}\n```\n\n# 디버그 종료 신호\n\n특정 명령이 갑자기 종료된 이유가 궁금했던 적이 있나요? SIGTERM과 같은 종료 신호에는 정보가 전달되지 않습니다. 메시지나 스택 추적도 없죠.\n\n이런 문제를 해결하기 위해 subprocess.kill()에 오류 인스턴스를 전달하여 복잡한 버그를 디버그하는 데 시간을 절약할 수 있습니다.\n\n\n\n```js\nimport {execa} from 'execa';\n\nconst subprocess = execa`npm run build`;\nonCancel(reason => {\n  const error = new Error(`Canceled by ${reason}`);\n  subprocess.kill(error);\n});\nawait subprocess;\n```\n\n# 템플릿 문자열\n\nExeca 7부터 명령어를 zx와 같은 템플릿 문자열을 사용하여 지정할 수 있습니다. 그러나 이전에는 $ 메소드에 한정되어 있었습니다.\n\n템플릿 문자열 구문 및 전통적인 배열 구문은 이제 모든 Execa 메소드와 함께 사용할 수 있습니다. 두 가지 방법은 동등하며 주로 선호에 따라 다릅니다.\n\n\n\n\n또한, 템플릿 문자열은 여러 줄에 걸쳐 사용할 수 있어 여러 CLI 플래그를 전달할 때 유용합니다.\n\n스크립트에서 일련의 명령을 실행할 때는 $를 권장합니다. 응용 프로그램이나 라이브러리에서 개별 명령을 호출할 때는 execa와 execaNode를 대신 사용하는 것이 좋습니다. 유일한 차이점은 $가 스크립트 친화적인 기본 옵션을 사용한다는 것입니다. 예를 들어, 터미널로부터 stdin을 자동으로 읽습니다.\n\n```js\nimport {execa} from 'execa';\n\nawait execa`npm run build\n  --concurrency 2\n  --fail-fast`;\n```\n\n# 옵션 공유\n\n\n\n모든 Execa 메소드는 옵션을 바인딩할 수 있습니다. 이를 통해 전역 옵션을 설정하거나 여러 명령 사이에서 재사용할 수 있습니다.\n\n```js\nimport { execa as execa_ } from 'execa';\n\n// 전역 옵션 설정\nconst execa = execa_({ timeout: 5000 });\n\nawait execa`npm run build`;\nawait execa`npm run test`;\n```\n\n# 웹 API에 더 확실해져요\n\n서버 측 자바스크립트는 Node.js 코어 모듈 대신 웹 API를 점차 채택하고 있습니다. Execa도 마찬가지로 Node.js 스트림, 파일 경로 문자열 및 Buffer 대신 웹 스트림, 파일 URL 및 Uint8Array를 사용할 수 있습니다.\n\n\n\n```js\nimport {execaNode} from 'execa';\n\nconst response = await fetch('https://example.com/api/orders');\nawait execaNode({\n  stdin: response.body,\n})`send_orders.js`;\n```\n\n# 스트림으로 변환하기\n\n일부 모듈은 인수로 스트림을 사용하거나 반환합니다. 이러한 모듈에 직접 명령을 사용할 수 있도록 하려면 Execa의 자식 프로세스를 subprocess.readable(), subprocess.writable() 또는 subprocess.duplex()를 사용하여 스트림으로 변환할 수 있습니다.\n\n```js\nimport {execaNode} from 'execa';\nimport {pipeline} from 'node:stream/promises';\nimport {\n  createReadStream, \n  createWriteStream,\n} from 'node:fs';\n\nawait pipeline(\n  createReadStream('./input.txt'),\n  execaNode`transform.js`.duplex(),\n  createWriteStream('./output.txt'),\n);\n```\n\n\n\n모든 중요한 변경 내용, 새로운 기능 및 버그 수정 사항에 대한 전체 목록은 릴리스 노트를 확인해 주세요.\n\n그리고 문서 전체를 완전히 개선했습니다: 참조 섹션 외에도 이제 많은 사용자 가이드와 예제가 포함되어 있습니다. 처음에는 좀 어려울 수 있는 프로세스를 더 잘 이해할 수 있도록 새로운 사용자들을 격려하고 싶습니다. 기존 사용자가 이전에 놓쳤던 특정 기능을 발견할 수 있도록 새 문서가 도움이 되기를 희망합니다.","ogImage":{"url":"/assets/img/2024-05-14-Execa9ourbiggestrelease_0.png"},"coverImage":"/assets/img/2024-05-14-Execa9ourbiggestrelease_0.png","tag":["Tech"],"readingTime":8},{"title":"위대한 JavaScript 분할 CommonJS vs ES Modules","description":"","date":"2024-05-14 14:55","slug":"2024-05-14-TheGreatJavaScriptDivideCommonJSvsESModules","content":"\n\n<img src=\"/assets/img/2024-05-14-TheGreatJavaScriptDivideCommonJSvsESModules_0.png\" />\n\n자바스크립트 커뮤니티가 논쟁을 즐기는 것은 비밀이 아닙니다. 4년 동안, 우리는 코드를 어떻게 구성해야 하는지에 대한 파티션이 계속되어 왔습니다. 이것은 기본적이지만 놀랄 만한 논란이 많은 질문이며, 개발자들을 나누는 계속된 문제입니다.\n\n이 분계는 CommonJS와 ES 모듈 두 가지 주요 시스템을 중심으로 이루어져 있습니다.\n\n## 분계를 이해하기\n\n\n\n자바스크립트가 처음에 발명된 때는 웹 브라우저의 스크립팅 언어로 사용되었습니다. 그러나 Node.js가 등장하면서 다양한 가능성이 열렸습니다.\n\n이제 브라우저용 언어가 아니라 서버 및 기타 응용 프로그램을 구동할 수 있었습니다.\n\n그 당시에는 브라우저의 모든 것이 전역 범위에 있었기 때문에 모듈에 대해 심각하게 생각할 필요가 없었습니다. 그러나 복잡한 서버 응용 프로그램을 구축하는 것은 간단하지 않았습니다. 모든 코드를 한 파일에 번들로 모아두는 것은 악몽이었기 때문입니다.\n\n이에 등장한 해결책은 CommonJS라는 모듈 시스템입니다.\n\n\n\n```js\nconst moduleA = require('./moduleA');\n```\n\nCommonJS는 다른 파일에서 JavaScript를 가져와서 그 파일이 내보낸 함수에 접근할 수 있게 해주는 require라는 함수를 사용합니다.\n\n그러나 JavaScript는 곧 ES6(이제는 유명한 버전)으로 이러한 아이디어를 채택했습니다. 이것은 웹 애플리케이션을 위한 것이며 import와 export를 소개했습니다.\n\n```js\nimport moduleA from './moduleA';\n```\n\n\n\n지금, 궁금해 할 수도 있습니다. 왜 JavaScript는 이미 사용 중인 require 호출에 고수하지 않았을까요?\n\nrequire의 문제는 동기적이라는 것이며, 모든 파일이 준비되어 있는 것을 전제로 원활하게 작동합니다. 그러나 브라우저 컨텍스트 내에서는 외부 리소스를 기다려야 하는 경우가 있기 때문에 require의 동기적인 성격은 시스템을 무너뜨릴 수 있습니다.\n\n그리고 이렇게 분리가 시작되었습니다.\n\n## 호환성의 진퇴양난\n\n\n\n대부분의 개발자들이 ES 모듈로 이동했는데, 이는 새롭고 사용하기 즐거웠기 때문이다. 그러나 상당수의 사용자는 CommonJS를 선택했습니다. 이 분리로 호환성 문제가 발생했습니다.\n\nES 모듈을 사용하는 경우 CommonJS를 문제없이 가져올 수 있습니다. 그러나 CommonJS로 ES 모듈을 가져오려고 하면 작동하지 않습니다. 대신, 가져오기를 모방하는 async 함수 해킹을 사용해야 합니다.\n\n```js\nconst moduleA = await import('./moduleA');\n```\n\n패키지를 배포할 때 이러한 호환성 문제 — 쌍둥이 패키지 하자로도 알려진 — 덕분에 매우 어려워집니다. 왜냐하면 ES 모듈과 CommonJS 사용자를 둘 다 고려해야 하기 때문입니다. ES 모듈만 제공하는 경우 CommonJS 사용자는 소외되고 반대의 경우도 마찬가지입니다.\n\n\n\n## 번들러의 역할\n\n번들러 또는 트랜스파일러인 Babel이나 TypeScript와 같은 도구들은 이 미묘한 문제에 추가적인 레이어를 더합니다. 여기서, 당신이 작성하는 코드가 무엇인지는 당신이 출력하는 코드에 따라 달라집니다. ES 모듈로 작성할 수도 있지만 CommonJS로 출력될 수도 있습니다.\n\n```js\n// Babel 또는 TypeScript 컴파일러가 ES Modules을 CommonJS로 변환\nconst moduleA = require('./moduleA');\n```\n\n당신이 생성한 코드에 require 호출이 보인다면, 당신은 CommonJS를 출력하고 있는 것이며, 반면에 import와 export가 있는 것은 당신이 ES 모듈의 일부라는 것을 나타냅니다. 앞으로 ES 모듈의 부분이 됩니다.\n\n\n\n## 미래는 ES 모듈로 향합니다\n\n개발자들의 관심을 끈 새로운 도구 중 하나는 번입니다. 번의 주요 강점은 CommonJS와 ES Modules 간의 상호 운용성 문제를 해결했다는 점입니다. 그러나 이 문제는 정확히 명세에 부합하지는 않습니다—CommonJS와 ES Modules 간의 문제를 해결하기 위해 대충 뭉개 놓은 것 뿐입니다.\n\nJavaScript 도구 체인은 이러한 별개의 모듈 시스템을 지원하느라 엄청난 복잡성을 가지고 있습니다.\n\n가능한 곳에서 ES 모듈을 사용하세요. 우리는 이 분열을 종식하고 미래를 수용할 때가 되었습니다. 현대적인 JavaScript. 통일된 JavaScript.\n\n\n\n만약 CommonJS를 사용하고 있거나 사용을 고려하고 있다면, 이제 코드를 좀 더 자세히 살펴볼 시간이 됐을지도 모릅니다. 미래는 ES 모듈을 사용하는 곳이며, JavaScript 환경을 더욱 간단하고 코딩이 더 재미있는 곳으로 만들기 위해 각자 역할을 다해야 합니다.\n\nBun의 최신 업데이트에 대한 자세한 내용은 확인해보세요:\n\n# 쉽게 이해하기\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\n\n- 작가에게 박수를 보내고 팔로우해 주세요! 👏\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인할 수 있어요 🚀\n- 무료 주간 뉴스레터에 가입해 보세요. 🗞️\n- 트위터(X) 말고도 링크드인, 유튜브, 디스코드에서도 팔로우해 주세요.","ogImage":{"url":"/assets/img/2024-05-14-TheGreatJavaScriptDivideCommonJSvsESModules_0.png"},"coverImage":"/assets/img/2024-05-14-TheGreatJavaScriptDivideCommonJSvsESModules_0.png","tag":["Tech"],"readingTime":3}],"page":"104","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}