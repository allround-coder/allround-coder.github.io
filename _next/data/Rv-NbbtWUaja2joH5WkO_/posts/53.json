{"pageProps":{"posts":[{"title":"Django Rest FrameworkDFR를 사용하여 Mpesa STK 푸시 및 CallbackView 구현하기","description":"","date":"2024-06-19 23:36","slug":"2024-06-19-ImplementingMpesaSTKpushandCallbackViewusingDjangoRestFrameworkDFR","content":"\n\n![이미지](/assets/img/2024-06-19-ImplementingMpesaSTKpushandCallbackViewusingDjangoRestFrameworkDFR_0.png)\n\nMpesa와 Safaricom은 네트워킹 분야에서 경쟁사들을 능가하는 뛰어난 위치에 있습니다. Mpesa의 주요 목표는 사용자들이 편리하게 거래할 방법을 마련하는 것이었습니다. 기술의 발전으로, 사용자들이 금전 거래를 수행해야 하는 많은 웹 및 모바일 애플리케이션 내에서 사용될 API를 만들 필요가 있었습니다.\n\nMPESA STK PUSH\n\n대부분의 사람들은 대부분 시간에 핸드폰을 가지고 있기 때문에 핸드폰으로 결제하는 것이 합리적일 것입니다. Mpesa 팀은 라이브 및 샌드박스 API를 소개했습니다. mpesa stk push를 사용하려면 액세스 토큰을 생성해야 합니다. 액세스 토큰은 응용 프로그램이 mpesa api를 사용할 수 있는 시간대를 제공하는 코드입니다. 액세스 토큰 생성을 구현하려면 Daraja 계정이 필요합니다. 그런 다음 홈 뷰의 내 애플리케이션 섹션으로 이동하여 앱을 만듭니다. 앱이 생성되면 다음이 생성됩니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-ImplementingMpesaSTKpushandCallbackViewusingDjangoRestFrameworkDFR_1.png\" />\n\n여기에 필요한 모든 세부 정보를 제공합니다. 각 앱은 특정 조직을 위해 구축되었기 때문에 거기에 나와 있는 일부 자격 증명은 실제로 필요하지 않을 수 있습니다.\n\n이제 여러분의 views 파일에 액세스 생성 기능을 구현합니다. 참고로, 이 가이드는 여러분이 django와 그 구조를 충분히 숙지하고 있다고 가정합니다. 그러나 보안을 위해, 'pip install python-decouple'을 사용하여 python decouple을 설치하는 것을 강력히 권장합니다. 이는 매개변수를 재배포하지 않고 변경할 수 있도록 설정을 구성하는 데 도움이 됩니다. 다음은 django에서 해당 기능을 구현하는 방법입니다:\n\n<img src=\"/assets/img/2024-06-19-ImplementingMpesaSTKpushandCallbackViewusingDjangoRestFrameworkDFR_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n실제로 사용자 키와 시크릿은 보안상의 이유로 소스에 노출되어서는 안 되지만 별도의 .env 파일에 넣어야 합니다. 이는 구성에서 사용자 키와 시크릿을 검색하여 콜론 구분자로 연결한 후 결과를 Base64로 인코딩하고 인코딩된 값으로 HTTP 인증 헤더를 구성합니다. 그런 다음 지정된 API URL로 Authorization 헤더 및 JSON Content-Type 헤더와 함께 GET 요청을 보냅니다. JSON 형식으로 예상되는 API 응답은 \"access_token\" 값을 추출하여 함수에서 반환됩니다. 액세스 토큰은 mpesa stk push 함수에서 사용될 것입니다.\n\n![image](/assets/img/2024-06-19-ImplementingMpesaSTKpushandCallbackViewusingDjangoRestFrameworkDFR_3.png)\n\n알겠어요, 앞에서 언급한 대로 Safaricom에서 생성한 키는 기밀이며 소스 코드에 노출되어서는 안 됩니다. 함수에서 모든 거래에 타임 스탬프를 첨부하기 위해 날짜 형식이 필요하며 위에서 보여준 형식을 따라야 합니다. 그런 다음 위 함수로부터 받은 액세스 토큰을 사용합니다. 그런 다음 mpesa 비밀번호가 필요하며 이 비밀번호는 mpesa 숏코드, mpesa 패스키, 그리고 형식 지정된 날짜를 문자열로 변환하여 비밀번호를 인코딩하는 공식이 필요합니다. 그런 다음 수신한 데이터를 사용하는 페이로드를 구성하고 이 경우에는 전화번호와 금액입니다. 그런 다음 거래가 성공적인지 여부에 대한 JSON 응답을 받습니다.\n\nMPESA CALLBACK VIEW\n\n<div class=\"content-ad\"></div>\n\nmpesa stk 페이로드에서는 모든 stk 푸시 트랜잭션 결과가 전송되는 안전한 콜백URL을 포함해야 합니다. 이를 통해 트랜잭션을 추적할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-ImplementingMpesaSTKpushandCallbackViewusingDjangoRestFrameworkDFR_4.png)\n\n동그라미가 그려진 선은 생성된 모델을 나타냅니다. 모든 거래, 실패한 것도 포함하여 mpesa에서 콜백 URL로 수신된 모든 거래가 거기에 저장됩니다. mpesa에서 수신한 본문은 daraja 웹사이트에서 찾을 수 있는 구조가 있는 딕셔너리입니다. 상태 코드가 200인 응답은 성공적으로 간주되어 SuccessfulResponses 모델에 저장됩니다. POST 메서드를 사용하여 콜백 URL이 데이터를 저장하는 기능에 액세스할 수 있으며, GET 메서드는 모델의 모든 트랜잭션을 볼 수 있는 용도로 사용됩니다. 이 경우 직렬화기를 사용하여 파이썬 객체를 JSON으로 변환합니다. 모든 변환 복잡성은 정의해야 하는 직렬화기에 의해 처리됩니다. 다음은 예시입니다:\n\n![이미지](/assets/img/2024-06-19-ImplementingMpesaSTKpushandCallbackViewusingDjangoRestFrameworkDFR_5.png)\n\n<div class=\"content-ad\"></div>\n\n이 시리얼라이저는 데이터베이스의 AllResponses 모델의 모든 레코드를 변환합니다.\n\n요약하자면, 이것은 stk push를 통한 mpesa 거래의 전체 흐름입니다. 데이터의 전체 흐름을 설명할 때 비 기술용어를 사용하지 않으려 노력했지만, 이는 기본적인 장고 패러다임을 전제로 한 것입니다.\n\n즐겁게 코딩하세요.","ogImage":{"url":"/assets/img/2024-06-19-ImplementingMpesaSTKpushandCallbackViewusingDjangoRestFrameworkDFR_0.png"},"coverImage":"/assets/img/2024-06-19-ImplementingMpesaSTKpushandCallbackViewusingDjangoRestFrameworkDFR_0.png","tag":["Tech"],"readingTime":3},{"title":"파이썬을 활용한 의료 시설 위치 최적화를 위한 오픈 데이터 주도 방법","description":"","date":"2024-06-19 23:33","slug":"2024-06-19-AnOpenData-DrivenApproachtoOptimisingHealthcareFacilityLocationsUsingPython","content":"\n\n![이미지](/assets/img/2024-06-19-AnOpenData-DrivenApproachtoOptimisingHealthcareFacilityLocationsUsingPython_0.png)\n\n이 작업은 조아킴 그로미초 교수님과 카이 카이저와 공동 저술되었습니다. 저자(들)는 모든 오류와 누락에 대해 책임이 있습니다.\n\n건강 시설까지의 이동 시간을 정확하게 산출하는 것은 건강 서비스 접근성을 평가하는 데 기본적입니다, 특히 접근 장애가 공공 건강 결과에 중대한 영향을 미칠 수 있는 지역에서. 이러한 계산은 자원 배분, 건강 서비스 이용, 공평한 의료 접근, 미래 시설을 위한 전략적 계획에 필수적입니다. 그러나 이를 계산하기 위해서는 병원 위치, 인구 분포, 그리고 OpenStreetMaps나 구글 또는 맵박스 같은 API로부터 도로 네트워크 데이터를 기반으로 한 이동 시간 계산을 포함한 많은 데이터 처리가 필요합니다.\n\n지리적 변동성인 지형, 도로 상태 및 기후 등도 이동 시간 계산에 기여합니다. 또한 사용 가능한 교통 수단 및 종류도 건강 시설로의 접근을 제한하며, 많은 시골 지역에서 신뢰할 수 있는 대중교통이나 개인 교통 수단 옵션이 부족합니다. 게다가 모든 병원의 지오코딩 된 데이터의 정확성과 가용성은 개발도상국을 포함한 많은 국가에서 종종 부족하여, 접근에 대한 정확한 추정이 줄어듭니다.\n\n<div class=\"content-ad\"></div>\n\n# 방법론 및 사용된 데이터\n\n먼저 우리는 우리가 관심을 갖는 지역의 모양 파일(동락레스테의 한 지방인 바우카우 중 하나)을 인도적 데이터 교환소(HDX)에서 다운로드합니다. HDX는 국가별 경계를 포괄하는 표준화된 자료인 Global Database of Political Administrative Boundaries Database 에 액세스할 수 있습니다. 이 데이터는 Open Database License (ODC-ODbL)에 따라 이용할 수 있습니다.\n\n우리는 Meta에서 고해상도 인구 데이터와 이를 결합합니다. 이 데이터는 Creative Commons Attribution International에 따라 라이선스가 부여됩니다.\n\n접근성을 향상시키는 방법을 결정하기 위해 기존 의료 시설 위치(병원과 진료소)로 시작해야 합니다. 이 데이터의 오픈소스 저장소는 OpenStreetMap입니다. 이것은 출발하기에 좋은 곳이지만, 정부나 세계 보건 기구(World Health Organization)와 같은 국제 발전 기구들이 유지하는 공식 의료 시설 등록 정보만큼 포괄적이지 않을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다음으로 Openrouteservice API와 MapBox Isochrones API를 사용하여 이동 시간을 계산하고 의료 접근성을 평가합니다. Openrouteservice에서 얻은 API 결과는 어떤 맥락에서든 CC-BY 4.0으로 라이선스가 부여됩니다. Isochrone API의 이용 약관에 대한 자세한 내용은 Mapbox 제품 약관을 참조하십시오.\n\n위 정보를 활용하여 기존 시설의 캐치먼트 영역을 분석하여, 의료 보장 범위에 대한 상세한 시각화를 상호작용적인 지도로 만들어 인구의 접근 가능 여부를 식별할 수 있습니다.\n\n마지막으로 최적화 모델을 실행하여 새로운 의료 시설의 잠재적 장소를 식별합니다.\n\n# 인도네시아의 티모르-레슈테의 행정 구역을 인도네시아 지도 데이터 교환에서 추출하고 Python의 Folium을 사용하여 시각화하기\n\n<div class=\"content-ad\"></div>\n\n다음 코드 스니펫은 GADM (Global Administrative Areas) 데이터에 대한 다운로더를 초기화하며 버전 4.0을 지정합니다. 그런 다음 이 다운로더를 사용하여 티모르-레스테의 관리 경계 데이터를 검색하며 지구상의 첫 번째 관리 수준인 지구나 주를 중점적으로 다룹니다. 지리 공간 데이터를 획득한 후에는 이 스크립트가 Folium 맵 상에 이 경계를 시각화하고, 배경 지도로 OpenStreetMap을 사용합니다.\n\n![이미지 1](/assets/img/2024-06-19-AnOpenData-DrivenApproachtoOptimisingHealthcareFacilityLocationsUsingPython_1.png)\n\n![이미지 2](/assets/img/2024-06-19-AnOpenData-DrivenApproachtoOptimisingHealthcareFacilityLocationsUsingPython_2.png)\n\n![이미지 3](/assets/img/2024-06-19-AnOpenData-DrivenApproachtoOptimisingHealthcareFacilityLocationsUsingPython_3.png)\n\n<div class=\"content-ad\"></div>\n\n# 메타로부터 고해상도 인구 밀도 지도 다운로드 및 시각화하기\n\n이 섹션에서는 메타로부터 고해상도 인구 밀도 지도를 다운로드하고 시각화하는 방법에 대해 설명합니다. 이러한 지도는 30m 해상도에서 인구 추정치를 제공하며, 다양한 그룹을 포함하는 인구 통계를 다룹니다. 또한 160개 이상의 국가에 대해 공개적으로 제공됩니다. 이러한 지도는 인구 성장을 모델링하고 인구 조사 데이터를 사용하여 건물을 감지하고, 건물 밀도를 계산하며, 해당 밀도를 기반으로 타일에 걸쳐 인구 데이터를 분배하여 작성됩니다.\n\n다음의 Python 코드 스니펫에서는 `TLS` ISO 코드로 식별되는 티모르-레스테(Timor-Leste)의 2020년 Facebook 인구 데이터를 검색하는 함수 `fb_pop_data`가 정의되어 있습니다. 데이터가 다운로드되어 GeoDataFrame으로 처리되고, 선택된 행정 경계 범위의 좌표 참조 시스템과 일치시킵니다. 관심 영역(선택된 행정 지역) 내의 인구를 계산하고 표시합니다.\n\n![이미지](/assets/img/2024-06-19-AnOpenData-DrivenApproachtoOptimisingHealthcareFacilityLocationsUsingPython_4.png)\n\n<div class=\"content-ad\"></div>\n\n# 오픈스트릿맵 데이터를 활용하여 티모르-레스테의 의료 시설 매핑\n\n이 코드 세그먼트는 특히 병원과 의원을 위한 티모르-레스테의 의료 시설 데이터를 검색하고 분석하는 데 전념되어 있습니다. 다음과 같은 기능을 수행합니다:\n\n- Overpass API를 통해 티모르-레스테 전역의 병원 및 의원 위치에 대한 OpenStreetMap 쿼리를 수행합니다.\n- 병원 (df_hospitals) 및 의원 (df_clinics)용으로 이름, 좌표 및 편의시설과 같은 필수 데이터를 추출하여 별도의 DataFrame에 저장합니다.\n\n이러한 데이터 세트를 공간 분석을 위해 하나의 GeoDataFrame(df_health_osm)으로 병합합니다.\n\n<div class=\"content-ad\"></div>\n\n- 티모르-레스테에서 의료 시설 수를 결정하기 위해 지역 조인을 실행하여 지정된 관심 지역(AOI) 내의 의료 시설 수를 파악합니다. 이는 티모르-레스테에서 의료 접근성을 평가하는 데 유용한 통찰력을 제공합니다.\n\n![이미지](/assets/img/2024-06-19-AnOpenData-DrivenApproachtoOptimisingHealthcareFacilityLocationsUsingPython_5.png)\n\n# 이소크론 분석을 통한 의료 접근성 평가\n\nget_isochrone_osm 함수는 티모르-레스테의 의료 시설들에 대한 이소크론을 계산합니다. 이소크론은 특정 위치(일반적으로 병원)로부터의 지정된 시간 내에 도달 가능한 영역을 나타내는 다각형입니다. 이 함수는 OpenRouteService API를 사용하여 이러한 다각형을 생성하며, 이동 모드로 걷기를 선택하여 60분 여행 시간을 기준으로 합니다. 그 결과 다각형은 각 시설에 접근 가능한 인구를 결정하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n의료 접근성을 평가하는 중요한 측면 중 하나는 기본 데이터 소스를 기반으로 한 분석의 신뢰성과 민감도를 이해하는 것입니다. 이전 단계에서는 오픈스트리트맵(OpenStreetMap, OSM)의 도로 네트워크 데이터를 사용하여 의료 시설까지의 이동 시간을 계산합니다. 그러나 이 데이터는 품질과 완성도에서 상당한 변동성을 보일 수 있으며, 이는 접근성에 대한 이속론 지도의 정확도 및 결론에 영향을 줄 수 있습니다. 따라서 이러한 불확실성을 해결하기 위해 대안 데이터 소스를 활용한 민감도 분석을 수행하는 것이 좋습니다.\n\nOSM 데이터가 신뢰성이 떨어지거나 오래되어 있는 지역에서는 Mapbox나 Google과 같은 API를 활용하여 보다 최신이거나 완벽한 도로 네트워크 정보를 기반으로 한 접근성의 정확한 계산이 가능합니다. 자원이 허용된다면 이러한 API를 활용하여 OSM 데이터에서의 결과를 보완하거나 검증할 수 있습니다.\n\n예를 들어, Mapbox를 통해 이속론 분석을 수행해보겠습니다. 이 예시는 Mapbox의 이속론 API를 사용하여 기존 병원에서 걸어서 60분 이내에 접근 가능한 지역을 계산하는 방법을 보여줍니다.\n\n아래 코드를 통해 상기 결과를 시각화할 수 있습니다. 이는 주황색 GeoJson 객체로 행정 경계를 개요로 나타내고, 각각의 팝업에 병원 이름을 표시하는 파란핀으로 병원 위치를 표시합니다. 또한, 의료 서비스에 접근할 수 있는 인구를 기준으로 구분하여, 접근하지 못하는 사람들은 빨간색 원 마커로, 접근할 수 있는 사람들은 초록색으로 나타냅니다. 이러한 마커들의 투명도는 인구수에 의해 결정되어, 밀집된 지역과 잘 제공되는 지역과 듬성 듬성한 인프라와 서비스가 부족한 지역을 명확하게 시각적으로 구분하여 의료 접근성의 격차를 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-AnOpenData-DrivenApproachtoOptimisingHealthcareFacilityLocationsUsingPython_6.png)\n\n## 행정 경계의 대표적인 잠재 위치 그리드\n\n새로운 병원과 클리닉을 배치하는 것은 포괄적인 건강 관리 지원을 보장하기 위해 중요합니다. 이는 종종 공식 소스로부터 특정 사이트 권장이 없는 경우에는 대상 지역 내에서 대표적인 그리드를 통해 근사화할 수 있는 잠재적 위치를 분석하는 것을 포함합니다.\n\n이러한 그리드는 새로운 건강 시설을 설립할 위치를 고려하는 시작 프레임워크를 제공하여 언더서빈 인구에 대한 접근성을 극대화하기 위한 목적으로 사용됩니다. 이 코드 조각은 특정 지리적 영역 내에서 이 대표적인 그리드를 생성하는 데 사용되는 generate_grid_in_polygon Python 함수를 설명합니다.\n\n\n<div class=\"content-ad\"></div>\n\n해당 기능은 제공된 지오메트리 범위 전체에 대해 간격 매개변수에 의해 결정된 일렬로 배치된 점들의 시리즈를 생성하여 Baucau에 318개의 잠재적 위치를 얻을 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-AnOpenData-DrivenApproachtoOptimisingHealthcareFacilityLocationsUsingPython_7.png)\n\n잠재적인 의료 시설의 배치를 최적화하기 위해 우리의 분석은 각 제안된 위치에 대한 이소크로너(isochrone)를 계산하여 기존 시설에 적용된 60분 도보 매개변수를 동일하게 활용합니다. 이 데이터를 활용하여 접근이 제한된 인구 집단을 결정하고 이러한 잠재적 시설이 제공할 수 있는 인구 집단을 확인합니다.\n\n그런 다음 기존 및 잠재적 위치에서의 접근 데이터를 집계하여 모든 잠재적 위치가 개설되고 기존 시설과 함께 개설된다면 가능한 최대 접근을 계산합니다.\n\n<div class=\"content-ad\"></div>\n\n# 수학적 최적화\n\n이제 수학적 최적화를 사용하여 오픈할 최적 병원 하위 집합을 결정할 것입니다. 수학적 최적화에 익숙하지 않은 경우, 이 주피터 책에 있는 실습 소개로 시작하는 것을 권장합니다.\n\n수학적 최적화의 핵심은 우리가 최적화하려는 현실 세계의 디지털 쌍둥이 역할을 하는 수학 모델을 만드는 것입니다. 이러한 모델을 개발한 후 해당 모델에 관련 데이터를 입력하여 최적화 문제의 구체적 예제를 만듭니다. 이러한 예제는 적절한 솔버를 사용하여 해결되어 최상의 실현 가능한 해를 발견하게 됩니다. 이를 최적해라고 합니다.\n\n모델링은 개념적인 과정이며, 모델을 코딩하는 것은 기술적인 작업입니다. 저희는 주피터 책에서와 같이 pyomo 패키지를 사용합니다. 이후 논의되는 모델은 캠브리지 대학 출판사로부터 예정된 교재의 3.1 연습문제로 소개되며, 위에 언급된 주피터 책은 이 책의 온라인 동반자로 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n강력한 솔버를 활용하여 문제를 해결할 수 있습니다. 우리가 설명할 문제와 같은 경우, Gurobi는 뛰어난 상용 솔버이며, MIT 라이선스 하에 제공되는 우수한 오픈 소스 대안인 HiGHS가 있습니다.\n\n모델링 프로세스는 결정해야 할 사항을 식별하여 결정 변수를 정의하는 것으로 시작합니다. 이러한 결정과 변수에 이름을 붙인 후, 해당 변수의 함수를 사용하여 목표와 제약 조건을 형식화합니다.\n\n- 목표 함수는 솔루션의 품질을 측정합니다.\n- 제약 조건은 솔루션이 모든 필요한 규칙을 준수하여 실행 가능한 것으로 간주될 수 있도록 보장합니다.\n\n우리의 경우와 많은 다른 경우, 함수는 선형일 것이며, 변수는 예/아니오 결정을 나타내기 위해 이진 형태를 가질 것입니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 접근 가능한 개방형 병원이 가구 당 하나의 변수를 필요로하고, 이를 서비스하는지 여부를 결정하는 또 다른 변수가 있습니다. 또한 각 병원당 변수가 필요하며, 해당 병원이 여는지 여부를 나타냅니다. 모델을 표현하는 전형적인 수학적 표기법은 변수의 지원 집합 이름, 지수 및 데이터에서 유도된 모델 매개변수를 명명하여 시작됩니다.\n\n저희 최적화 과제에서 이러한 것들이 포함됩니다:\n\n집합\n\n- 𝐼 — 가구 집합\n- 𝐽 — 잠재적인 병원 위치 집합\n- 𝐽𝑖 — 집합 내 가구 𝑖∈𝐼의 닿을 수 있는 잠재적인 병원 위치. 참고: 𝐽𝑖⊆𝐽.\n\n<div class=\"content-ad\"></div>\n\n매개변수\n\n- 𝑣𝑖 — 가구 𝑖∈𝐼의 가구원 수.\n\n## 체 Church와 ReVelle의 논문에 기재된 최대 커버링 모델\n\n이 모델은 각 가구 𝑖∈𝐼에 대해 해당 가구가 𝑗∈𝐽에서 개설된 병원에 의해 서비스를 받을 수 있는지를 나타내는 변수 𝑧𝑖를 정의하며, 완전한 모델은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-AnOpenData-DrivenApproachtoOptimisingHealthcareFacilityLocationsUsingPython_8.png)\n\n첫 번째 줄은 가구 수를 최대화하는 목표를 설명하고, 두 번째 줄 (_subject to:_ 이후)은 첫 번째 제약 조건을 나열합니다: 각 가구는 도달 가능한 최소한 하나의 병원이 열려 있을 때에만 서비스를 받습니다. 그런 다음, 열 병원 수는 선택을 제한하며, 마지막으로 사용되는 변수의 이진성이 지정됩니다.\n\n위 모델은 최대 𝑝개의 병원을 선택합니다. 원래 논문에서는 Church와 ReVelle이 정확히 𝑝개의 병원을 선택했지만, 우리 모델에는 나중에 논의할 장점이 있습니다.\n\n## 수학적 모델 구현하기\n\n\n<div class=\"content-ad\"></div>\n\n모델을 설계한 후에는 구현이 수학적 표현에서 개념을 코드로 번역합니다. 번역은 대부분 일대일로 이루어지며, 주된 차이점은 변수를 사용하기 전에 항상 프로그래밍에서 처럼 변수를 선언한다는 것입니다. 반대로, 수학적 공식은 전통적으로 변수를 끝에 선언합니다. 저희는 모델을 코딩하기 위해 패키지 Pyomo를 사용합니다.\n\n- 최적화 모델 정의\n\nmodel_max_covering 함수는 Pyomo를 사용하여 수학적 최적화 모델을 정의합니다. 다음과 같은 여러 매개변수를 사용합니다:\n\n- w: 각 가구 ID의 인구 수가 포함된 사전\n- I: 가구 ID 세트\n- J: 잠재적 병원 위치 ID 세트\n- JI: 각 가구 ID를 그들에게 서비스를 제공할 수 있는 잠재적 병원 ID 세트로 매핑하는 사전\n- p: 오픈할 최대 병원 수\n\n<div class=\"content-ad\"></div>\n\n모델은 의사결정 변수 x(이진, j 위치에 병원을 열지 여부)와 z(이진, i 가 서비스를 받는지 여부)를 설정합니다. 목적은 총 인구를 최대한 커버하는 것이며, 가구가 서비스를 받는 경우에는 도달 가능한 병원이 열리기 때문에 제약 조건을 따릅니다. 예산인 -p를 초과하지 않도록 전체 병원 수를 최대화합니다.\n\n### 2. 입력 데이터 준비\n\n그런 다음 코드는 데이터프레임에서 관련 데이터를 추출합니다:\n\n- J_existing: 기존 병원 ID 집합\n- J_potential: 잠재적인 새 병원 위치 ID 집합\n- I1: 모든 가구 ID 집합\n- IJ_existing: 기존 병원 ID를 해당 병원이 서비스를 제공할 수 있는 가구 집합으로 매핑한 사전\n- IJ_potential: 잠재적인 병원 ID를 해당 병원이 서비스를 제공할 수 있는 가구 집합으로 매핑한 사전\n- JI1: 이전 두 가지로부터 역으로 매핑한 것으로, 각 가구에 대해 잠재적인 병원 집합을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n3. 최적화 모델 호출\n\nget_ids 함수는 주어진 예산(개설할 병원 수)에 대해 최적화 모델을 초기화하고 해결하기 위해 정의됩니다. 이 함수는 모델 인스턴스 m1을 생성하고, 제안된 제약 조건을 사용하여 개선할 기존 병원을 설정하며, 기존 병원의 수를 추가하여 예산 p를 조정합니다.\n\n그런 다음 HiGHS 솔버를 사용하여 모델을 해결하고 선택된(개설된) 병원들의 ID가 반환됩니다.\n\n4. 최적 솔루션 찾기\n\n<div class=\"content-ad\"></div>\n\n다음 코드 블록에서는 결과를 저장하기 위한 result_list라는 리스트가 생성됩니다. 다양한 예산(개설할 병원 수)에 대한 결과가 저장됩니다.\n\n루프는 다양한 예산 값에서 실행되며, 잠재적 위치의 총 수까지 반복됩니다. 각 예산에 대해:\n\n- get_ids 함수를 호출하여 개설할 병원 ID의 최적 집합을 가져옵니다.\n- 선택된 병원을 기반으로 액세스가 있는 인구와 액세스가 없는 인구가 계산됩니다.\n- 액세스가 있는 인구의 백분율이 계산됩니다.\n- 이 백분율과 해당 예산이 result_list에 추가됩니다.\n\n이 프로세스를 통해 개설하는 병원 수와 인구를 커버하는 백분율 간의 균형을 탐색하고, 결과적으로 파레토 곡선 시각화를 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n파레토 곡선 시각화는 최적화 모델 실행 결과를 다른 예산(개설할 병원 수)으로 2차원 그래프에 도식화하는 것을 의미합니다. 이는 개설된 시설 수와 그에 따른 인구 보호율 사이의 트레이드 오프를 시각화할 수 있게 합니다. 구체적으로, x축은 개설된 병원 수(예산)를 나타내고, y축은 의료 시설에 접근할 수 있는 인구 백분율을 보여줍니다. 예산(따라서 개설된 병원 수)이 증가함에 따라 인구 보호율도 향상되는 경향이 있습니다. 그러나 일반적으로 개설된 병원이 추가됨에 따라 개선 속도는 감소하며, 일정 시점을 넘어 병원이 추가될수록 둔화되는 곡선이 나타납니다. 이러한 곡선을 파레토 곡선 또는 파레토 프론티어라고 합니다. 이것은 우위에 있지 않은 솔루션 집합을 나타내며, 한 목표(예: 인구 보호율)를 증가시키려면 다른 목표(예: 병원 수/예산 증가)를 희생해야 하는 솔루션입니다. 파레토 곡선 시각화는 이 맥락에서 중요합니다. 결정자들이 관련된 트레이드 오프를 이해하고 정보에 기반한 선택을 할 수 있도록 돕기 때문입니다. 예를 들어:\n\n- 곡선이 가파른 초기 기울기를 가지고 있다면, 몇 개의 병원을 추가함으로써 인구 보호율을 크게 향상시킬 수 있어 투자가 매우 효과적일 수 있습니다.\n- 곡선이 빠르게 평평해진다면, 일정 시점을 넘어 병원을 추가로 개설해도 보호율이 크게 증가하지 않을 수 있어, 감소하는 수익을 시사합니다.\n- 곡선은 트레이드 오프가 덜 유리해지는 \"무릎\"이나 포인트를 나타낼 수 있어, 두 목표를 균형있게 맞출 수 있는 잠재적인 좋은 지점을 식별하는 데 도움을 줍니다.\n\n아래 코드는 Plotly.express 모듈을 사용하여 최적화 결과의 파레토 프론티어를 시각화하는 데 사용됩니다.\n\n# 이제, 가장 중요한 질문: 이 최적화된 위치들은 어디에 있을까요?\n\n<div class=\"content-ad\"></div>\n\n저희 최적화 모델은 여러 전략적 위치를 식별하여 새로운 의료 시설을 개선해 전반적인 접근성을 향상시켰습니다. 추가 5개 시설을 오픈하는 예산 제약 조건 하에, 분석 결과 이러한 위치를 선택함으로써 47.4% (기존 시설만 사용하는 경우)에서 61.93%로 인구 접근률을 증가시키는데 가장 효과적인 선택지로 제시합니다.\n\n![이미지](/assets/img/2024-06-19-AnOpenData-DrivenApproachtoOptimisingHealthcareFacilityLocationsUsingPython_9.png)\n\n요약하자면, 이 블로그 글은 개방 데이터, 지리 정보 분석 및 수학적 최적화 기술을 활용하여 공평한 의료 접근 계획의 중요 도전에 대응하는 능력을 보여줍니다. Python의 능력을 활용하고 다양한 데이터 소스를 통합함으로써, 우리는 의료 시설 위치를 평가하고 새로운 시설을 위한 최적 위치를 식별하기 위한 견고한 방법론을 개발했습니다.\n\n이 사례 연구는 티모르-레스테에 초점을 맞췄지만, 이 블로그에서 제시된 방법론은 보편적으로 적용 가능하며, 의료 시설에 대한 물리적 접근 문제에 직면한 다른 지역이나 국가에 적응하여 투자 우선순위를 결정할 수 있도록 돕습니다.\n\n<div class=\"content-ad\"></div>\n\n이 튜토리얼의 전체 코드는 Colab 노트북에서 찾을 수 있어요. 당신이 파이썬 프로그래머가 아니더라도, 우리는 이 기여가 최적화 모델을 사용해 새로운 세대의 의사 결정 지원을 위한 오픈으로 이용 가능한 지리적 데이터를 활용하는 가능성과 프로세스에 관한 직관적인 감각을 제공해 줄 것을 바라고 있어요.","ogImage":{"url":"/assets/img/2024-06-19-AnOpenData-DrivenApproachtoOptimisingHealthcareFacilityLocationsUsingPython_0.png"},"coverImage":"/assets/img/2024-06-19-AnOpenData-DrivenApproachtoOptimisingHealthcareFacilityLocationsUsingPython_0.png","tag":["Tech"],"readingTime":12},{"title":"포켓몬은 몇 마리나 들어갈까요","description":"","date":"2024-06-19 23:30","slug":"2024-06-19-HowManyPokmonFit","content":"\n\n<img src=\"/assets/img/2024-06-19-HowManyPokmonFit_0.png\" />\n\n이 게시물에서는 PuLP 라이브러리를 사용하여 Python에서 최적화 문제를 모델링하고 해결하는 방법을 보여드리고 포켓몬 데이터를 활용하여 프로세스를 설명하겠습니다. Python에서 최적화 문제를 해결하는 방법에 대해 더 배우고 싶으시거나 포켓몬을 좋아하시는 분이면, 이 튜토리얼을 통해 쉽게 이해할 수 있는 단계를 안내받을 수 있습니다.\n\n그럼 출발해봅시다! 🚀\n\n# 포켓몬 역사를 조금 알아보기\n\n<div class=\"content-ad\"></div>\n\n오리지널 포켓몬의 제1세대는 1996년에 일본에서 발매된 포켓몬 레드와 그린 게임에 소개된 151마리의 포켓몬으로 구성되어 있어요. 이후 여러 세대와 버전의 포켓몬이 추가로 출시되어 1,000여 마리가 넘는 포켓몬이 생성되었는데, 전자 게임, 애니메이션, 트레이딩 카드, 상품 등에서 포켓몬은 문화적 상징으로 자리매김했습니다. 그럼에도 불구하고, 이 튜토리얼에서는 제1세대의 원래 151마리 포켓몬 데이터만 사용할 거에요.\n\n원래의 포켓몬 게임에서는 두 가지 주요 목표가 있습니다 — 포켓몬 챔피언이 되는 것과 전국도감을 완성하는 것입니다. 포켓몬 챔피언이 되기 위해서는 여덟 개의 체육관 리더를 이기고 해당하는 여덟 개의 체육관 뱃지를 획득해야 합니다. 그런 다음 엘리트 포와 현재의 포켓몬 챔피언을 물리칠 때 될 수 있는 포켓몬 챔피언이 될 수 있어요! 전국도감을 완성하기 위해서는 야생에서 잡거나 전투에서 얻거나 교환하여 151마리의 포켓몬을 모두 포함해야 해요.\n\n게임의 주요 제한 사항 중 하나는 결투 중에 활성 팀에 포켓몬을 최대 6마리 밖에 가지고 다닐 수 없다는 것이에요. 그렇다면, 만약 151마리 포켓몬을 모두 잡았다면, 어떤 6마리의 포켓몬을 팀에 포함해야 할지 고를 때 관련 질문이 생기죠. 어떤 6마리의 포켓몬을 선택할지 결정하려면, 먼저 각 포켓몬의 전투에서의 효과를 평가하기 위해 측정 지표(즉, 목표 함수)를 선택해야 합니다. 그런 다음 목표는 정의된 목표 함수를 최대화하는 포켓몬 팀을 선택하는 것이 되겠죠.\n\n각 포켓몬은 게임 플레이 메카닉을 형성하는 여러 독특한 특성을 가지고 있어요. 게임을 즐기고 다양한 환경에서 포켓몬 결투의 승자를 결정하도록 도와주죠. 각 포켓몬에는 HP(체력), 공격력, 방어력, 특수공격력, 특수방어력, 스피드와 같은 6가지 기본 통계가 있어요. 기본 통계 외에도 화재, 물, 전기 등 포켓몬 타입, 포켓몬 기술, 현재 포켓몬 레벨 등과 같은 다양한 특성이 포켓몬의 효과성에 기여합니다. 그래도, 포켓몬 커뮤니티에서 효과성을 평가하는 인기 지표는 포켓몬의 총 기본 통계(BST)입니다. BST는 포켓몬의 기본 통계의 총합이라고 생각하시면 됩니다!\n\n<div class=\"content-ad\"></div>\n\n만약 우리가 선택해야 할 포켓몬이 6마리뿐이라는 단 하나의 제약 조건만 있다면, 문제는 비교적 쉽고 명백한 해결책을 갖게 됩니다. 즉, 각 후보 포켓몬의 BST를 계산하고, 그 중에서 가장 효과적인 상위 6마리의 포켓몬을 우리 팀에 포함시키는 것입니다.\n\n본 게시물에서 최적화 문제의 좀 더 세밀한 버전을 탐색하기 위해 추가적인 제약 조건을 가정할 것입니다. 구체적으로, 선택한 포켓몬들의 총 무게에 제한이 있다고 가정할 것입니다. 즉, 선택한 포켓몬들의 총 무게는 1,000kg 이하이어야 합니다. 이 추가적인 제약 조건은 우리에게 포켓몬 데이터를 사용한 가상의 난쟁이 문제(knapsack problem)를 구성할 수 있게 해줍니다.\n\n# 난쟁이 문제에 대해 어떻게 생각하시나요?\n\n난쟁이 문제는 다음과 같이 표현될 수 있는 고전적인 결합 최적화 문제입니다:\n\n<div class=\"content-ad\"></div>\n\n다시 말해, 낙석 문제에서는 특정 가치와 크기를 가진 항목 집합을 일정 크기의 낙석가방에 담아야 합니다. 문제는 총 항목 중에서 낙석가방에 맞게 최대 총 가치를 얻을 수 있는 부분집합을 찾는 것입니다.\n\n가장 흔한 낙석 문제의 경우는 0/1 낙석 문제인데, 각 항목에 대해 하나의 인스턴스만 있는 문제입니다. 다시 말해, 0/1 낙석 문제에서 각 항목은 고유하며 낙석가방에 포함시킬지 여부를 한 번 선택하거나 아예 선택하지 않습니다. 유사하게, 포켓몬 문제에서는 151가지의 고유한 포켓몬이 있으며, 각각의 포켓몬은 우리의 활약팀에 한 번 포함되거나 전혀 포함되지 않을 것입니다.\n\n![포켓몬이 맞게 들어가는지 확인할 수 없습니다.](/assets/img/2024-06-19-HowManyPokmonFit_1.png)\n\n0/1 낙석 문제는 바이너리 정수 프로그래밍(BIP) 문제로서 이렇게 정식으로 정의할 수 있습니다, 좀 멋있게 말하면:\n\n<div class=\"content-ad\"></div>\n\n특히:\n\n- υi는 항목 i의 가치입니다.\n- wi는 항목 i의 무게입니다.\n- W는 배낭의 총 무게 수용량이며,\n- i는 항목 i가 배낭에 포함되는지 여부를 나타내는 결정 변수로, 각각 1 또는 0입니다.\n\n배낭 문제의 다른 변형들도 있습니다. 예를 들어, 제한된 배낭 문제(각 항목을 주어진 숫자까지 여러 번 선택할 수 있는 문제)와 무제한 배낭 문제(각 항목을 원하는 만큼 여러 번 선택할 수 있는 문제)가 있습니다.\n\n배낭 문제는 NP-어려운 문제로 알려져 있지만, 작은 경우에는 정확한 알고리즘을 사용하여 효율적으로 해결할 수 있습니다. 따라서, 이 게시물에서는 PuLP Python 라이브러리를 사용하여 PokeAPI 데이터를 활용하여 0/1 배낭 문제를 모델링하고 해결합니다.\n\n<div class=\"content-ad\"></div>\n\n# 모두 잡기!\n\n저는 Jupyter Lab 노트북을 사용하여 PokeAPI 데이터를 가져오고, PuLP로 최적화 문제를 모델링하고 해결하며, 데이터의 간단한 Plotly 시각화를 만들 것입니다.\n\n## PokéAPI에서 데이터 가져오기\n\n분석에 필요한 다양한 포켓몬 특성을 획득하기 위해 PokeAPI에서 제공하는 데이터를 사용할 것입니다. 더 구체적으로, requests 라이브러리를 이용하여 Python에서 PokeAPI에 접근할 수 있습니다. 'limit = 151'을 설정하여 PokeAPI에서 1세대의 처음 151마리 포켓몬과 그 URL을 쉽게 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\r\nimport requests\n\nurl = \"https://pokeapi.co/api/v2/pokemon?limit=151\"\nresponse = requests.get(url)\ndata = response.json()\npokemon_urls = [pokemon['url'] for pokemon in data['results']]\r\n```\n\n그런 다음 URL을 반복하면서 각 항목에 대해 API를 호출하여 151마리의 포켓몬의 속성도 가져올 수 있습니다. 각 포켓몬에 대해 BST 계산에 필요한 기본 통계 및 포켓몬 유형을 가져오겠습니다. pokemon_data라는 딕셔너리에 각각의 151마리 포켓몬 이름과 해당 속성을 저장합니다.\n\n```js\r\ncounter = 0\npokemon_data = []\nfor url in pokemon_urls:\n    response = requests.get(url)\n    pokemon = response.json()\n    base_stats = {stat['stat']['name']: stat['base_stat'] for stat in pokemon['stats']}\n    pokemon_data.append({\n        'name': pokemon['name'],\n        'weight': pokemon['weight'],\n        'hp': base_stats.get('hp', 0),\n        'attack': base_stats.get('attack', 0),\n        'defense': base_stats.get('defense', 0),\n        'special_attack': base_stats.get('special-attack', 0),\n        'special_defense': base_stats.get('special-defense', 0),\n        'speed': base_stats.get('speed', 0),\n        'type': [t['type']['name'] for t in pokemon['types']],\n    })\n    counter += 1\r\n```\n\n데이터프레임 형식으로 데이터셋을 살펴볼 수도 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```python\nimport pandas as pd \ndf = pd.DataFrame(pokemon_data)\ndf\n```\n\n![Pokemon Image](/assets/img/2024-06-19-HowManyPokmonFit_2.png)\n\n그리고 이제 PuLP로 배낭 문제를 모델링할 준비가 되었습니다!\n\n## PuLP을 사용하여 문제 모델링하기\n\n<div class=\"content-ad\"></div>\n\n최적화 문제를 구조화하는 매우 첫 번째 단계는 결정 변수를 정의하는 것입니다. 우리의 경우, 우리가 결정하려고 하는 것은 어떤 포켓몬을 팀에 포함할 것인지입니다. 다시 말해, 151마리의 포켓몬 각각에 대해 그 포켓몬을 팀에 포함할지(따라서 이 포켓몬에 대한 결정 변수는 1이 될 것) 아닐지를 결정하려고 합니다(따라서 결정 변수는 0이 될 것). 결과적으로, 이 문제의 결정 변수는 이 문제에서 포켓몬이 우리 팀에 포함되어 있는지 여부를 나타내는 이진 결정 변수 x입니다.\n\n결정 변수 x를 정의한 후, 우리는 문제의 목적 함수도 정할 수 있습니다. 즉, 우리가 최적화하려는 대상은 무엇인가요. 여기서 우리는 포켓몬 팀의 총 BST를 최적화하려고 하며, 더 구체적으로 그 값을 최대화하려고 합니다. 따라서, 문제의 목적 함수는 다음과 같이 표현할 수 있습니다:\n\n![식](/assets/img/2024-06-19-HowManyPokmonFit_3.png)\n\n마지막으로, 우리는 문제의 제약 조건도 정해야 합니다. 이는:\n\n<div class=\"content-ad\"></div>\n\n- 결정 변수 x는 바이너리(0 또는 1)여야 합니다.\n- 우리의 포켓몬 팀의 총 무게는 1,000kg 이하이어야 합니다.\n- 선택된 포켓몬의 총 수는 정확히 6마리여야 합니다.\n\n![이미지](/assets/img/2024-06-19-HowManyPokmonFit_4.png)\n\n파이썬으로 이를 작성하려면, 우선 PuLP 라이브러리를 가져와 최적화 문제의 인스턴스를 초기화합니다.\n\n```python\nimport pulp\n\nprob = pulp.LpProblem(\"포켓몬 팀 최적화\", pulp.LpMaximize)\n```\n\n<div class=\"content-ad\"></div>\n\n그런 다음, 결정 변수를 정의합니다. 여기에는 바이너리 변수 제약 조건이 직접 통합됩니다.\n\n```js\nx = pulp.LpVariable.dicts(\"x\", range(len(pokemon_data)), cat='Binary')\n```\n\n그리고 목적 함수는 다음과 같습니다.\n\n```js\nprob += pulp.lpSum(\n    (pokemon['hp'] + pokemon['attack'] + pokemon['defense'] + pokemon['special_attack'] + pokemon['special_defense'] + \n     pokemon['speed']) * x[i] for i, pokemon in enumerate(pokemon_data)\n), \"Total Combat Effectiveness\"\n```\n\n<div class=\"content-ad\"></div>\n\n…그리고 문제 제약 사항입니다.\n\n```js\n# 총 무게 제약 사항\nmax_weight_capacity = 1000\nprob += pulp.lpSum(pokemon['weight'] * x[i] for i, pokemon in enumerate(pokemon_data)) <= max_weight_capacity, \"무게 한도\"\n\n# 포켓몬 총 수 제약 사항\nprob += pulp.lpSum(x[i] for i in range(len(pokemon_data))) == 6, \"팀 크기\"\n```\n\n이렇게 하면 파이썬에서 최적화 문제의 모델을 완전히 정의하였으며, 이제 해결할 준비가 되었습니다.\n\n## 포켓몬 드림 팀\n\n<div class=\"content-ad\"></div>\n\n아래와 같이 Markdown 형식으로 변경할 수 있습니다:\n\n\nThe defined problem can be solved simply by:\n\n```js\nprob.solve()\n```\n\n… which returns ‘1’, meaning that the status of our problem is ‘LpStatusOptimal’, meaning the problem has an optimal solution. prob.solve() may also return other outputs, as for instance ‘-1’ (LpStatusInfeasible), meaning that there is no feasible solution for the problem given the constraints, or ‘-2’ (LpStatusUnbounded), indicating that the solution is unbounded.\n\nIn any case, given that our problem has an optimal solution, we can display it by:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n선택된_포켓몬 = [포켓몬_데이터[i]['이름'] for i in range(len(포켓몬_데이터)) if pulp.value(x[i]) == 1]\nprint(\"선택된 포켓몬:\", 선택된_포켓몬)\n```\n\n![이미지](/assets/img/2024-06-19-HowManyPokmonFit_5.png)\n\n그리고 ✨보세요✨\n\n우리의 포켓몬 드림 팀을 얻었어요!\n\n<div class=\"content-ad\"></div>\n\n문제의 제약 조건(허용 중량 및/또는 포켓몬 수 변경, 포켓몬 유형 추가 등), 다른 목적 함수 정의 또는 기본 통계 중 하나에 대한 다른 계수 할당으로 인해 서로 다른 팀을 얻을 수 있다고 하는 것 같아요.\n\n이 문제의 맥락에서는 포켓몬의 BST가 포켓몬의 무게와 어떻게 관련되는지 확인하는 것도 흥미롭고, 전체 151마리 포켓몬 중에서 선택 가능한 포켓몬 팀의 시각적 표현도 가질 수 있어요. Plotly 산점도 차트로 이를 할 수 있어요:\n\n```js\n# 모든 포켓몬의 BST 계산\nfor pokemon in pokemon_data:\n    pokemon['BST'] = (pokemon['hp'] + pokemon['attack'] + pokemon['defense'] +\n                                             pokemon['special_attack'] + pokemon['special_defense'] + \n                                             pokemon['speed'])\n    \nall_pokemon_df = pd.DataFrame(pokemon_data)\nselected_df = pd.DataFrame(selected_pokemon_data)\n\n# 산점도 생성\nfig = go.Figure()\n\n# 모든 포켓몬 추가\nfig.add_trace(go.Scatter(\n    x=all_pokemon_df['weight'],\n    y=all_pokemon_df['BST'],\n    mode='markers',\n    name='모든 포켓몬',\n    marker=dict(size=10, color='blue', opacity=0.6),\n    text=all_pokemon_df['name']\n))\n\n# 선택된 포켓몬 추가\nfig.add_trace(go.Scatter(\n    x=selected_df['weight'],\n    y=selected_df['total_combat_effectiveness'],\n    mode='markers',\n    name='선택된 포켓몬',\n    marker=dict(size=12, color='red', opacity=0.9),\n    text=selected_df['name']\n))\n\n# 제목 및 레이블, 크기 조정\nfig.update_layout(\n    title=\"포켓몬 선택 최적화\",\n    xaxis_title=\"무게 (kg)\",\n    yaxis_title=\"BST\",\n    legend_title=\"범례\",\n    width=1000, \n    height=600,\n    showlegend=True\n)\n\n# 플롯 표시\nfig.show()\n```\n\n# 제 생각\n\n<div class=\"content-ad\"></div>\n\n포켓몬 챔피언십을 위해 팀을 구성하는 것 외에도 배낭 문제는 여러 다양한 분야에서 실제 결정 과정에서 발생합니다. 이러한 실제 상황에는 예산 할당, 화물/트럭 적재, 투자 포트폴리오 최적화, 의약품 제조 또는 식단 계획 등이 포함됩니다. 이러한 문제를 프로그래밍적으로 인식, 모델링 및 해결하는 것은 어떤 조직에게도 중요한 통찰력을 제공할 수 있습니다. PuLP는 파이썬 환경에서 효율적으로 최적화 문제를 모델링하고 해결할 수 있는 강력한 라이브러리이며, 이는 파이썬의 다재다능성을 완전하게 보여줍니다.\n\n# 출처\n\n데이터는 포켓몬 API에서 수집되었습니다. © 2013–2023 Paul Hallett 및 포켓몬 API 기여자에 의해 제공되며, 3-Clause BSD 라이선스 하에 공개되었습니다. 전체 라이선스 세부 정보는 포켓몬 API GitHub 페이지를 방문해 주세요.\n\n✨읽어 주셔서 감사합니다!✨\n\n<div class=\"content-ad\"></div>\n\n이 게시물을 즐겼나요? 친구가 되어요!\n\n💌 제 Medium 또는 LinkedIn에 함께해요!\n\n💼 Upwork에서 저와 함께 일해요!","ogImage":{"url":"/assets/img/2024-06-19-HowManyPokmonFit_0.png"},"coverImage":"/assets/img/2024-06-19-HowManyPokmonFit_0.png","tag":["Tech"],"readingTime":10},{"title":"데이터 과학자가 알아야 할 선형 대수학 개념","description":"","date":"2024-06-19 23:27","slug":"2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow","content":"\n\n## 데이터 과학\n\n![이미지](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_0.png)\n\n선형 대수는 모든 데이터 과학 및 머신 러닝 작업의 기반입니다.\n\n이것은 이론적 모델을 실용적인 솔루션으로 변환하는 언어입니다.\n\n<div class=\"content-ad\"></div>\n\n데이터에서 학습할 수 있도록 하는 원칙을 내포하고 있어요.\n\n![이미지](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_1.png)\n\n이것들은 다음과 같이 사용됩니다.\n\n- 데이터의 표현: 데이터를 구조화하고 조작하는 구조화된 방법으로, 복잡한 데이터셋을 행렬로 표현할 수 있도록 합니다.\n- 차원 축소: PCA와 같은 기법은 중요한 정보를 잃지 않으면서 모델 효율성을 높이기 위해 변수의 수를 줄이는 데 선형대수를 활용합니다.\n- 최적화: 그래디언트 디센트는 ML의 핵심 엔진으로, 함수의 최솟값을 찾기 위해 선형대수를 사용합니다.\n- 피쳐 엔지니어링: 선형 변환과 행렬 연산을 통해 기존 데이터에서 새로운 피처를 생성합니다.\n- 유사성 측정: 임베딩은 벡터로 저장되며, 오늘날 추천 시스템과 AI 챗봇에서 사용됩니다.\n- 그 밖에도 많아요!\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 선형 대수학 개념, 시각적 설명 및 코드 예제를 살펴볼 거에요.\n\n시작해 봅시다!\n\n코드 → Deepnote 노트북\n\n# 목차\n\n<div class=\"content-ad\"></div>\n\n### 벡터\n\n- **단위 벡터**: 단위 벡터\n- **벡터 연산**\n  - **벡터 덧셈**\n  - **스칼라 곱**\n  - **닷 프로덕트**\n- **벡터 공간**\n  - **영 공간 (커널)**\n  - **Span**\n  - **기저**\n  - **선형 독립성**\n\n# 행렬\n\n- **함수로서의 행렬**\n- **선형 변환**\n- **역행렬**\n- **특이 행렬**\n- **항등 행렬**\n- **대각 행렬**\n- **직교 행렬**\n- **행렬 곱셈**\n- **트레이스**\n- **행렬식**\n- **랭크**\n- **고유 벡터와 고유값**\n\n![선형 대수학 개념](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_2.png)\n\n이것이 선형 대수학의 기본적인 구성 요소입니다.\n\n<div class=\"content-ad\"></div>\n\n벡터를 생각하는 방법은 3가지가 있어요.\n\n첫 번째는 물리학적인 시각입니다. 벡터는 공간에 향하는 화살표로 정의되며, 길이와 방향에 의해 결정됩니다. 평면상의 벡터는 2차원이고, 우리가 사는 공간에 있는 벡터는 3차원입니다.\n\n두 번째는 컴퓨터 과학적 시각입니다. 벡터는 숫자의 순서대로 나열된 목록입니다. 이 목록의 길이가 차원을 결정합니다.\n\n세 번째는 수학자의 시각입니다. 벡터는 서로 더해지거나 숫자로 곱해지는 모든 것이 될 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n## 단위 벡터\n\n단위 벡터는 크기가 1인 벡터입니다. 종종 크기에 관계없이 벡터의 방향을 나타내는 데 사용됩니다.\n\n# 벡터 연산\n\n## 벡터 덧셈\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_3.png\" />\n\n두 벡터를 요소별로 더하여 새로운 벡터를 형성하는 것을 의미합니다.\n\n<img src=\"/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_4.png\" />\n\n## 스칼라 곱\n\n\n<div class=\"content-ad\"></div>\n\n표 태그를 마크다운 형식으로 변경하세요. \n\n## 내적\n\n형식적으로는 두 벡터의 유클리드 크기와 사이의 각도의 코사인의 곱으로, 벡터의 길이와 방향 관계를 모두 반영한다.\n\n![image](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_5.png)\n\n<div class=\"content-ad\"></div>\n\n직관적으로 생각해보면 한 벡터의 방향성 성장을 다른 벡터에 적용하는 것이라고 생각할 수 있습니다. 또는 \"한 벡터가 다른 벡터에게 얼마나 많은 밀어내기/에너지를 주는가?\"라고 생각할 수도 있습니다. 결과는 우리가 원래의 벡터를 얼마나 더 강하게 만들었는지를 보여줍니다 (양수, 음수 또는 0).\n\n![Image 6](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_6.png)\n\n만약 내적이 0이라면, 그것은 벡터들이 직교한다는 것을 말해줍니다.\n\n![Image 7](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_7.png)\n\n<div class=\"content-ad\"></div>\n\n반가운 비유를 하나 소개하겠습니다.\n\n빨간 화살표 벡터는 당신의 속도를 나타내고, 파란 화살표 벡터는 부스터 패드의 방향을 나타냅니다. 숫자가 클수록 더 강력한 파워를 의미합니다. 점곱은 당신이 받을 부스터 양을 나타냅니다.\n\n이 공식을 사용하면, |a|는 당신의 진입 속도, |b|는 최대 부스트이며, 받게 되는 부스트의 백분율은 cos(𝛉)이며, 전체 부스트는 |a| |b| cos(𝛉)가 됩니다.\n\n![이미지](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_8.png)\n\n<div class=\"content-ad\"></div>\n\n# 벡터 공간\n\n벡터(또는 선형) 공간은 더하고 숫자로 곱할 수 있는 벡터의 모음입니다. 이 숫자는 이 문맥에서 스칼라라고 불립니다.\n\nV가 벡터 공간이라고 불리기 위해서는 공리 목록을 만족해야 합니다.\n\n이미지를 표시하는 대신 Markdown 형식으로 표를 변경했습니다.\n\n![Vector Space Table](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_9.png)\n\n<div class=\"content-ad\"></div>\n\n## 널 공간 (커널)\n\n널 공간은 행렬과 곱해졌을 때 영벡터가 되는 벡터들의 집합입니다.\n\n이는 방정식 Ax = 0의 해를 나타냅니다. 여기서 A는 주어진 행렬입니다.\n\n주어진 행렬에 곱해졌을 때 두 벡터를 원점(영벡터)으로 수렴시키는 부분공간으로서 행렬의 널 공간을 시각화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## Span\n\n주어진 두 벡터 v와 w의 선형 결합인 av + bw를 통해 도달할 수 있는 모든 가능한 벡터의 집합이며, 여기서 a와 b는 모든 실수입니다.\n\n대부분의 벡터 쌍에 대해, 2차원 벡터 평면의 모든 점에 도달할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_10.png)\n\n두 벡터가 일치하는 경우, 원점을 지나는 단일 선에 제한됩니다.\n\nspan의 개념은 basis의 개념에 기초합니다.\n\n## Basis\n\n\n<div class=\"content-ad\"></div>\n\n기저는 전체 벡터 공간을 구성하는 선형 독립적인 벡터들의 모임입니다. 이는 벡터 공간 내의 모든 벡터를 기저 벡터의 선형 조합으로 표현할 수 있다는 것을 의미합니다.\n\n이들을 공간 내 모든 다른 벡터들을 위한 기본 요소로 생각해보세요.\n\n하나의 벡터를 화살표로 생각하는 것이 도움이 되지만, 벡터들의 집합에 대해서는 점으로 생각해보세요. 대부분의 기저 벡터 쌍은 공간의 전체 2차원 시트를 채울 수 있습니다.\n\n## 선형 독립성\n\n<div class=\"content-ad\"></div>\n\n일련의 벡터가 선형 독립적인 경우 집합 내의 벡터들이 결과적으로 ax + by 형태인 어떤 식으로도 나타낼 수 없는 경우입니다.\n\n## 행렬\n\n행렬은 입력과 연산을 행과 열로 구성하는 방법입니다.\n\n![이미지](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_11.png)\n\n<div class=\"content-ad\"></div>\n\n여기 2행 2열의 행렬이 있어요.\n\n구조화된 방식으로 문제를 해결할 수 있는 수학적 도구입니다.\n\n## 함수로서의 행렬\n\n행렬을 함수로 생각할 수 있어요. 파이썬 함수가 입력 매개변수를 받아 처리하고 출력을 반환하는 것처럼, 행렬 변환은 선형 변환을 통해 입력 벡터를 출력 벡터로 변환합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Linear Transformation](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_12.png)\n\n## 선형 변환\n\n![선형 변환](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_13.png)\n\n선형 변환은 두 벡터 공간 간의 매핑 V → W로, 벡터 덧셈과 스칼라 곱셈의 연산을 보존하는 것을 말합니다.\n\n\n<div class=\"content-ad\"></div>\n\n실제로 행렬 A를 벡터 x에 적용하여 다른 벡터 y를 얻는 것(Ax = y 작업을 통해)은 선형 변환입니다.\n\n이것은 데이터 과학에서 많이 사용됩니다:\n\n- 차원 축소: PCA는 선형 변환을 사용하여 고차원 데이터를 낮은 차원 공간으로 매핑합니다.\n- 데이터 변환: 데이터 집합을 정규화하거나 표준화하는 것은 선형 변환이다.\n- 피처 엔지니어링: 기존 피처의 조합을 통해 새로운 피처를 생성하는 것.\n\n다음은 몇 가지 형태의 행렬입니다:\n\n<div class=\"content-ad\"></div>\n\n## 역행렬\n\n행렬은 그 역행렬과 곱해지면 항등 행렬이 됩니다.\n\n## 특이 행렬\n\n특이 행렬은 역행렬을 가지지 않는 정방 행렬입니다. 이는 행렬의 행렬식이 0이거나 랭크가 크기보다 작은 것과 동일합니다.\n\n<div class=\"content-ad\"></div>\n\n## 항등 행렬.\n\n항등 행렬은 주 대각선에는 1의 값을, 그 외의 곳에는 0의 값을 갖는 정사각 행렬입니다. 행렬 곱셈에서 곱셈 항등원으로 작용하여 어떤 행렬에 적용해도 그 행렬을 변경시키지 않습니다. 그냥 숫자 1과 마찬가지로 작용합니다.\n\n## 대각 행렬\n\n대각 행렬은 모든 주 대각선을 제외한 항목이 0인 정사각 행렬입니다. 고유값을 찾거나 행렬식을 계산하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 직교 행렬\n\n![직교 행렬](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_14.png)\n\n실수 요소를 갖는 정방 행렬은 전치가 역행렬과 같으면 '직교'로 간주됩니다.\n\n형식적으로, 행렬 A가 AᵀA=AAᵀ = I를 만족하면 A는 직교 행렬입니다. 여기서 I는 항등 행렬입니다.\n\n<div class=\"content-ad\"></div>\n\n기하학적으로, 행렬은 그 열과 행이 직교하는 단위 벡터인 경우 직교합니다. 다시 말해, 서로 수직이며 크기가 1인 벡터입니다.\n\n두 벡터가 서로 직교하고(90도) 그들 사이의 내적이 0이면 두 벡터는 직교한다는 것을 기억하세요.\n\n## 행렬 곱셈\n\n행렬 곱셈을 수행하는 데에 행렬을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 아래는 선형대수에 관한 직관적인 가이드에서 가져온 멋진 시각화입니다.\n\n![Visualization](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_15.png)\n\n각 입력 데이터를 각 연산을 통해 흘리는 것을 상상해 보세요.\n\n![Operations](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_16.png)\n\n<div class=\"content-ad\"></div>\n\n여기 작업의 예시가 있어요.\n\n![이미지](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_17.png)\n\n작업을 수행한 결과는 다음과 같아요.\n\n![이미지](/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_18.png)\n\n<div class=\"content-ad\"></div>\n\n입력은 [3 x 2] 행렬이며, 우리의 작업 행렬은 [2 x 3]입니다. 그 결과는 [2 x 3] [3 x 2] = [2 x 2]입니다.\n\n입력의 크기는 작업의 크기와 일치해야 합니다.\n\n## Trace\n\n행렬의 Trace는 모든 대각 요소의 합입니다. 기저 변경에 불변이며, 행렬에 대한 고유값의 합인 행렬에 대한 정보적인 값을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## 행렬식\n\n행렬식은 출력 변환의 크기를 의미해요.\n\n입력이 단위 벡터인 경우(면적이나 부피가 1일 때), 행렬식은 변환된 면적이나 부피의 크기를 나타냅니다.\n\n예를 들어 이 행렬을 살펴보죠. A의 면적이 6배로 스케일링된 경우, 변환의 행렬식은 6이 되는 거죠.\n\n<div class=\"content-ad\"></div>\n\n음수 determinant는 전체 공간이 뒤집혔음을 알려줍니다. 이 변환은 종이 더미를 뒤집는 것과 비슷합니다.\n\n빨간색과 녹색 축의 방향이 뒤바뀐 것을 주목하세요.\n\nDeterminant가 0이면 행렬이 \"파괴적\"이며 뒤집을 수 없습니다. 0으로 곱하는 것과 비슷하게 정보가 손실됩니다.\n\nDeterminant는 행렬이 역행렬인지를 알려줄 수 있습니다. det(A)가 0이면 역행렬이 존재하지 않으며 행렬은 특이합니다.\n\n<div class=\"content-ad\"></div>\n\n## Rank\n\n행렬에서 선형 독립 열/행 벡터의 최대 개수를 나타내는 것입니다. 그것은 행 또는 열에 의해 만들어진 벡터 공간의 차원을 나타냅니다.\n\n또한 선형 변환 후 출력 차원의 개수를 알려줍니다.\n\n변환의 출력이 단일 선 (일차원이라고 함)인 경우, 해당 변환이 1의 순위를 가진다고 말합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 모든 벡터가 일부 2차원 평면에 있을 경우, 해당 변환은 랭크 2를 가졌다고 말합니다.\n\n2x2 행렬의 경우 랭크 2가 가장 좋습니다. 이것이 full rank로 알려져 있죠. 이것은 기저 벡터가 전체 2차원 공간과 0이 아닌 determinant를 표현할 수 있다는 것을 의미합니다.\n\n그러나 3x3 행렬의 경우, 랭크 2는 더 안 좋은데, 완전히 무너진 것은 아닙니다. 하지만, 랭크 1보다는 낫다고 볼 수 있죠.\n\n## 고유벡터와 고유값\n\n<div class=\"content-ad\"></div>\n\n고유 벡터와 고유 값은 변환의 \"축\"을 나타냅니다.\n\n고유 벡터는 선형 변환 후에도 방향이 변하지 않는 입력값입니다. 방향은 변하지 않지만 크기는 변할 수 있습니다. 이 크기, 즉 고유 벡터가 확대되거나 축소되는 정도가 고유 값입니다.\n\n지구본을 회전시킬 때 생각해보세요; 극을 제외한 모든 위치가 새로운 방향을 향합니다. 그들의 방향은 변하지 않습니다.\n\n여기 고유 벡터의 시각적 예시가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:600/1*d34D2o-Gx1IOgFnuuJ2kog.gif)\n\n행렬 A와 벡터 v에 대해, Av = λv이면 λ가 고유값이고, v가 행렬 A의 고유벡터입니다.\n\n다른 말로, 정방 행렬 A의 고유벡터는 행렬 곱셈 = 스칼라 곱셈인 벡터입니다.\n\n# 읽어 주셔서 감사합니다!\n\n\n<div class=\"content-ad\"></div>\n\n# 자원\n\n해커들 방식\n\n- 코더를 위한 계산 선형 대수학\n- 파이썬을 활용한 응용 기계 학습을 위한 선형 대수학 소개\n\n시각화\n\n<div class=\"content-ad\"></div>\n\n- 그래픽 선형 대수학 — LA를 수행하는 새로운 방법\n- 3Blue1Brown의 선형대수학 본질 — 놀라운 애니메이션, 개념 시각화\n- 인벡터라이즈\n- 직관적인 수학\n\n논문/강의/교재\n\n- 딥 러닝에 필요한 행렬 미적분\n- 데이터 분석, 신호 처리 및 머신 러닝을 위한 행렬 방법 | 수학 | MIT 오픈코스웨어\n- 올바르게 수행하는 선형 대수학\n- 선형대수학 4페이지로 알아보기.pdf\n\n# 연락을 유지하세요!\n\n<div class=\"content-ad\"></div>\n\n비트그릿 데이터 사이언스 퍼블리케이션을 팔로우하면 최신 소식을 받아보실 수 있어요!\n\n데이터 사이언스 및 인공지능 최신 동향을 다른 데이터 과학자들과 함께 논의하고 싶나요? 저희 디스코드 서버에 가입해보세요!\n\n워크숍 및 다가오는 대회 정보를 받아보려면 비트그릿을 팔로우하세요!\n\n디스코드 | 웹사이트 | 트위터 | 링크드인 | 인스타그램 | 페이스북 | 유튜브","ogImage":{"url":"/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_0.png"},"coverImage":"/assets/img/2024-06-19-LinearAlgebraConceptsEveryDataScientistShouldKnow_0.png","tag":["Tech"],"readingTime":9},{"title":"파이썬에서 Uncle Bob의 Clean Code 원칙 적용하는 방법","description":"","date":"2024-06-19 23:23","slug":"2024-06-19-HowtoApplyUncleBobsCleanCodePrinciplesinPython","content":"\n\n![이미지](/assets/img/2024-06-19-HowtoApplyUncleBobsCleanCodePrinciplesinPython_0.png)\n\n온클 밥, 모든 코더의 아버지,는 2008년에 '클린 코드'라는 책을 출판했습니다. 소프트웨어 엔지니어링에 진지하다면, 꼭 이 책을 읽어야 합니다. 이 글에서는 이 책을 요약하고 그 원칙들을 우리의 파이썬 코드에 어떻게 적용할 수 있는지 살펴보겠습니다. 이는 책에서 논의된 SOLID 원칙이 아니라, 코드베이스에서 그것을 따라야 하는 실제 상황에 대한 이야기입니다.\n\n로버트 마틴이 논의한 이 원칙들은 어떤 프로그래밍 언어에도 적용 가능하므로, 내 생각에는 모든 소프트웨어 개발자에게 필수적입니다. 나쁜 코드는 아무도 도와준 적이 없습니다.\n\n이 원칙들이 어떻게 작용하는지 확인하고 싶으신가요? 여기서 제 YouTube 비디오를 확인해보세요: [YouTube 비디오 링크](링크 주소)\n\n<div class=\"content-ad\"></div>\n\n## 깔끔한 코드란 무엇인가요?\n\n로버트 C. 마틴이 쓴 'Clean Code: Agile Software Craftsmanship'에서 소개한 깔끔한 코드란 쉽게 읽고 이해하며 유지보수할 수 있는 코드를 말합니다. 가독성, 간결함, 유지보수성을 강조합니다. 깔끔한 코드는 잘 구조화되어 있고 표준 규칙을 따르며 불필요한 복잡성이 없습니다. 또한 모듈화되어 있고 테스트 가능하며, 단일 책임을 갖는 함수와 메소드를 가지고 있어 코드 수정 및 확장이 쉽게 가능하며 버그를 도입하지 않도록 설계되어 있습니다. 깔끔한 코드의 궁극적인 목표는 견고하고 유연하며 작업하기 즐거운 코드베이스를 만드는 것입니다.\n\n## 깔끔한 코드의 주요 원칙\n\n이러한 일반 규칙은 간단하지만 강력합니다. 자세한 내용을 살펴보고 즐겨 사용하는 프로그래밍 언어인 Python에서 명확한 예제와 함께 이를 어떻게 구현하는지 알아봅시다.\n\n<div class=\"content-ad\"></div>\n\n- 표준 규칙 준수하기\n\n표준 규칙을 따르는 것은 깔끔하고 유지보수가 쉬운 코드를 작성하는 데 중요합니다. Python에서는 PEP 8에 따르는 것이 중요합니다. PEP 8는 일관된 Python 코드를 작성하는 데 대한 가이드라인과 모범 사례를 제공합니다.\n\n- KISS 원칙 준수하기\n\n디자인 시에 간결함을 중요시해야 합니다. 간단한 코드는 보다 쉽게 읽고 이해할 수 있으며 유지보수하기도 쉽습니다.\n\n<div class=\"content-ad\"></div>\n\n이 책의 SOLID 원칙과는 논란이 될 수 있습니다. 적용하는 것이 그렇지 않을 때보다 쉽다고 말할 순 없지만 결국 그들이 당신의 삶을 더 나아지게 만들 수 있다는 것은 사실입니다.\n\n- 보이 스카우트 규칙\n\n보이 스카우트 규칙은 항상 코드를 발견한 것보다 깨끗하게 남겨야 한다고 제안합니다. 이것은 지저분한 코드를 발견하면 변경 사항을 가입하는 동안 정리해야 한다는 것을 의미합니다.\n\n- 항상 근본 원인을 찾으세요\n\n<div class=\"content-ad\"></div>\n\n문제의 원인을 항상 찾아보고, 단기적인 해결책을 찾는 대신에 해결하시는 것이 좋습니다. 이렇게 하면 반복되는 문제가 발생하지 않고 시스템의 무결성을 유지할 수 있습니다.\n\n그렇다면, 이제 우리의 Python 코드에 깔끔한 코드 원칙을 적용하는 방법을 살펴보겠습니다.\n\n## if/else 대신 다형성 선호\n\n간단히 말해 다형성은 서로 다른 객체가 동일한 클래스의 인스턴스로 보일 수 있는 능력입니다. 이는 동일한 작업을 서로 다른 클래스에서 다르게 동작하도록 하는 것을 허용합니다. 예를 들어, 다른 클래스가 동일한 이름의 메소드를 가지고 있는 경우, 다형성을 통해 해당 메소드를 각 클래스의 객체에 대해 호출하고 그 클래스의 구현에 따라 특정 결과를 얻을 수 있습니다. 이는 코드에서 유연성과 재사용을 가능하게 합니다.\n\n<div class=\"content-ad\"></div>\n\n다형성을 활용하면 상속과 메서드 재정의를 통해 복잡한 조건 로직을 피할 수 있습니다. 이 접근 방식은 개방/폐쇄 원칙과 일치합니다.\n\n- if/else를 사용한 나쁜 예시\n\n```js\ndef get_discount(customer_type): \n    if customer_type == \"regular\": \n        return 0.1 \n    elif customer_type == \"premium\": \n        return 0.2 else: \n    return 0.0\n```\n\n- 다형성을 활용한 좋은 예시\n\n<div class=\"content-ad\"></div>\n\n```python\nclass Customer:\n    def get_discount(self):\n        return 0.0\n\nclass RegularCustomer(Customer):\n    def get_discount(self):\n        return 0.1\n\nclass PremiumCustomer(Customer):\n    def get_discount(self):\n        return 0.2\n\ndef get_customer_discount(customer):\n    return customer.get_discount()\n```\n\n## Use Dependency Injection\n\n의존성 주입(Dependency Injection, DI)은 클래스에 의존성을 주입할 수 있도록 하는 디자인 패턴으로, 클래스 간의 결합도를 줄이고 테스트 용이성과 유지보수성을 향상시킵니다.\n\n클래스가 자체적으로 의존성을 내부적으로 생성하는 경우, 해당 클래스는 해당 의존성에 강하게 결합됩니다. 이는 클래스가 의존성의 특정 구현에 대해 직접적으로 알고 있고 의존하고 있다는 것을 의미하며, 이를 수정하지 않고는 의존성을 변경하거나 대체하기가 어려워집니다. 이는 의존성 역전 원칙(Dependency Inversion Principle)을 위반하는 것으로, 고수준 모듈이 저수준 모듈에 의존하지 않고, 둘 다 추상화에 의존해야 한다는 원칙에 어긋납니다.\n\n\n<div class=\"content-ad\"></div>\n\n한편, 의존성 주입은 외부에서 클래스로 의존성을 주입할 수 있게 합니다. 이는 클래스가 의존성을 어떻게 생성해야 하는지 알 필요가 없다는 것을 의미합니다. 그 대신 외부에서 제공되는 의존성에 의존하는 방식입니다. 이는 클래스 간의 느슨한 결합을 촉진하는데, 클래스는 구체적인 구현이 아닌 추상화(인터페이스 또는 추상 클래스)에만 의존합니다. 또한 클래스를 테스트하기가 더 쉬우며, 의존성을 테스트 중에는 목업 또는 테스트용 대체품으로 교체할 수 있습니다.\n\n총론적으로, 의존성 주입은 더 유연하고 유지보수하기 쉬운 코드를 이끌며, 객체지향 설계 원칙을 더 잘 준수하게 만듭니다.\n\n- 의존성 주입이 없는 경우\n\n```js\nclass Service: \n    def init(self): \n        self.repository = Repository()\n```\n\n<div class=\"content-ad\"></div>\n\n```python\n    def perform_action(self):\n        data = self.repository.get_data()\r\n```\n\n- DI\n\n```python\r\nclass Service: \n    def init(self, repository): \n        self.repository = repository\n    def perform_action(self):\n        data = self.repository.get_data()\n        # perform action with data\n\nrepository = Repository() \nservice = Service(repository)\r\n```\n\n## Prevent Over-Configurability and Don’t Use Flag Arguments\n\n<div class=\"content-ad\"></div>\n\n소프트웨어를 간단하게 유지하는 것은 불필요한 설정이나 옵션을 추가하지 않는 것을 의미합니다. 플래그 인수는 함수를 복잡하고 이해하기 어렵게 만들 수 있습니다.\n코드에서 과도한 구성 가능성은 복잡성, 유지 관리 부담 증가, 코드 냄새, 가독성 저하와 같은 문제를 일으킬 수 있습니다. 함수가 너무 많은 구성 옵션을 가지고 있는 경우, 단일 책임 원칙(SRP)을 위반하고 있는 것으로, 책임이 불명확하고 코드 구성이 떨어지게 됩니다. 또한, 긴 복잡한 구성이 코드를 읽고 이해하기 어렵게 만들 수 있습니다.\n\n- 플래그 인수를 사용한 나쁜 예시\n\n```js\ndef create_user(name, email, is_admin=False): \n    user = User(name, email) \n    if is_admin: \n        user.set_admin_permissions() \n    return user\n```\n\n- 플래그 인수를 사용하지 않은 좋은 예시\n\n<div class=\"content-ad\"></div>\n\n```js\ndef create_user(name, email): \n    return User(name, email)\n\ndef create_admin_user(name, email): \n    user = User(name, email) \n    user.set_admin_permissions() \n    return user\n```\n\n## Law of Demeter를 따르세요\n\n클래스는 직접적인 의존성만을 알아야 합니다. 이는 느슨한 결합과 캡슐화를 장려하여 코드를 모듈화하고 유지보수하기 쉽게 만듭니다.\n\n- Law of Demeter를 위반하는 나쁜 예\n\n<div class=\"content-ad\"></div>\n\n```python\ndef get_user_info(user): \n    address = user.get_address() \n    city = address.get_city() \n    return city\n```\n\n- 지데르 법칙을 잘 따른 좋은 예시\n\n```python\ndef get_user_info(user): \n    return user.get_city()\n```\n\n## 논리적 의존성 회피하기\n\n<div class=\"content-ad\"></div>\n\n클래스 내의 메서드는 동일한 클래스 내의 다른 메서드의 내부 상태나 동작에 의존해서는 안 됩니다. 각 메서드는 독립적이고 독립적이어야 합니다.\n\n- 논리적 의존성이 있는 나쁜 예시\n\n```js\nclass Calculator: \n    def init(self): \n        self.result = 0\n    def add(self, number):\n        self.result += number\n    \n    def subtract(self, number):\n        self.result -= number\n    \n    def get_result(self):\n        return self.result\n```\n\n- 논리적 의존성이 없는 좋은 예시\n\n<div class=\"content-ad\"></div>\n\n\nclass Calculator: \n    def add(self, a, b): \n        return a + b\n    def subtract(self, a, b):\n        return a - b\n\n\n## 부작용 방지\n\n부작용이 없는 함수는 예측 가능하고, 테스트하기 쉽고, 모듈화되어 있으며, 병렬 실행에 안전하며, 일반적으로 유지보수가 용이하고 가독성이 좋은 코드로 이어집니다. 이러한 함수들은 입력에만 의존하고 외부 상태를 수정하지 않고 출력을 생성해야 합니다.\n\n이것은 또한 SOLID의 \"단일 책임 원칙\"의 예입니다. 함수는 한 가지 일만 수행해야 합니다. 즉, 부작용을 발생시키면 안 됩니다. 변수 2개를 더한 함수라면 콘솔에 뭔가를 로깅해서는 안 됩니다. 데이터베이스에서 사용자를 생성하는 함수라면 검증을 수행해서도 안 됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n- 부작용이 있는 안좋은 예시\n\n```python\ndef add_to_list(item, item_list=[]): \n    item_list.append(item) \n    return item_list\n```\n\n- 부작용이 없는 좋은 예시\n\n```python\ndef add_to_list(item, item_list=None): \n    if item_list is None: \n        item_list = [] \n    \n    new_list = item_list + [item] \n    return new_list\n```\n\n<div class=\"content-ad\"></div>\n\n## 깨끗한 코드를 읽는 가치가 있을까요?\n\n절대로요. 로버트 C. 마틴의 Clean Code는 소프트웨어 개발에 진지한 사람에게 꼭 필요한 책입니다. 이 책은 읽기 쉽고 유지보수가 쉽며 효율적인 코드 작성에 대한 실용적인 조언을 제공하여 더 나은 소프트웨어 품질과 더 쉬운 유지보수를 이루어냅니다. 이 책에 투자하는 시간은 귀하의 코딩 스킬과 전문 실무 방법을 크게 향상시킬 것입니다.\n\n## 결론\n\n요약하면, 우리는 Uncle Bob의 Clean Code에서 여러 원칙을 다뤄보았고 파이썬에서의 적용 방법을 보여주었습니다. 이 책을 꼭 읽어보시기를 강력히 추천합니다. 서로의 코드 품질을 높이는 데 노력합시다.\n\n<div class=\"content-ad\"></div>\n\n클린 코드 책 요약 페이지를 보려면 GitHub 페이지를 확인해보세요.\n\n코딩 즐기세요!","ogImage":{"url":"/assets/img/2024-06-19-HowtoApplyUncleBobsCleanCodePrinciplesinPython_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoApplyUncleBobsCleanCodePrinciplesinPython_0.png","tag":["Tech"],"readingTime":7},{"title":"파이썬 프로젝트를 위한 완벽한 패키지 프로토 타입 제안","description":"","date":"2024-06-19 23:20","slug":"2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects","content":"\n<img src=\"/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_0.png\" />\n\n# 소개\n\nPython 패키지의 구조를 세울 때 고려해야 할 많은 옵션이 있고 많은 결정을 내려야 합니다. 그러나 한 번 디자인 선택사항을 결정하면 기본적인 구조적 변경을 만들기가 매우 어려워집니다.\n\n또한 사용자가 자신의 프로젝트에 네임스페이스를 포함하기 시작했다면, 어떠한 변경을 가하더라도 그 사용자가 소스 코드를 변경해야 할 필요가 생깁니다.\n\n<div class=\"content-ad\"></div>\n\n그러므로 처음에 꾸미고 배치 결정을 잘 내리는 것이 매우 중요합니다.\n\n## 문제\n\n파이썬 패키지를 구성하는데 여러 옵션이 많기 때문에 적절한 디자인을 찾거나 적어도 나중에 문제를 일으키지 않을 디자인을 찾는 것이 어려울 수 있습니다.\n\n## 기회\n\n<div class=\"content-ad\"></div>\n\n일반 패키지 레이아웃을 구성하고 모든 도전 과제를 해결하는 데 필요한 스켈레톤 프로젝트에서 프로토타입을 구축할 수 있다면, 앞으로 패키지를 만드는 것은 빠르고 간단한 복사 및 붙여넣기만으로 완료될 것입니다.\n\n## 앞으로의 계획\n\n제안된 완벽한 패키지 프로토타입에 대한 요구 사항을 설정한 다음, 모든 이러한 요구 사항을 해결하는 표준 프로젝트 구조를 생성할 수 있습니다.\n\n# 배경\n\n<div class=\"content-ad\"></div>\n\n여러 해 동안 많은 파이썬 패키지를 작성해 왔고, 프로젝트 구조를 각각 실험하고 수정하여 완벽한 구조를 찾으려 했지만, 항상 어느 한 측면에서는 불완전한 상태였습니다.\n\n그로 인해 완벽한 패키지 구조에 대한 요구 사항을 작성하고, 모든 원하는 것을 이루기 위한 방법을 찾기 위해 연구에 착수했습니다.\n\n# 요구 사항\n\n- 인기 있는 전문 패키지의 네임 스페이스 관례를 모방해야 합니다 (예: statsmodels.regression.linear_model에서 RegressionResultsWrapper를 가져옵니다).\n- 코드와 클래스를 잘 구조화된 폴더 및 파일 세트로 구성해야 합니다.\n- 패키지 사용자에게 노출되는 네임스페이스가 statsmodels.regression.linear_model과 같이 잘 지어진 체계를 반영해야 하며, 폴더와 파일 이름을 철저하게 따라서는 안 됩니다.\n- 하위 폴더의 클래스가 다른 하위 폴더 및 폴더 계층구조 상위 폴더의 클래스를 참조하고 액세스할 수 있어야 합니다.\n- 패키지 코드를 개발하고 테스트할 수 있는 Jupyter 노트북이 포함된 최상위 폴더를 포함해야 합니다.\n- 패키지의 모든 코드 및 클래스를 발견할 수 있는하위 폴더로 구성된 단위 테스트가 포함된 최상위 폴더를 포함해야 합니다.\n- 모든 패키지 폴더와 하위 폴더의 클래스 docstring에서 자동으로 생성된 문서가 포함된 최상위 폴더를 포함해야 합니다.\n- Jupyter 노트북, 단위 테스트 및 패키지에 접근하는 다른 프로젝트에서 패키지 위치를 하드 코딩하는 것을 피해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 솔루션이 작동하는 것을 증명하기\n\n솔루션을 증명하기 위해 2개의 테스트 클래스를 포함하는 빈 프로젝트 템플릿 또는 스켈레톤을 만들었습니다 -\n\n- class BaseLearner()는 알고리즘 클래스 집합을 위한 베이스 클래스로 설계된 가상의 클래스입니다.\n- class Fisher(BaseLearner)는 \"Fisher\" 알고리즘 코드를 포함할 가상의 클래스로, 이 클래스는 BaseLearner(폴더 구조의 완전히 다른 부분에 위치한)를 상속받는 것이 목적입니다.\n\n# 뒤의 시작하기\n\n<div class=\"content-ad\"></div>\n\n모든 요구 사항을 해결하고 두 개의 테스트 클래스에 대한 개요를 제공하는 완료된 프로젝트/패키지 구조 미리보기입니다 (Fisher 클래스가 fisher_file.py에 포함되어 있고 BaseLearner 클래스가 base_file.py에 포함되어 있는 것을 알립니다)\n\n![이미지](/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_1.png)\n\n# 그렇다면 큰 문제는 무엇인가요?\n\n이 구조는 모든 요구 사항을 해결했을 것으로 보이지만, 이 구조에는 주의할 필요가 있는 몇 가지 근본적인 문제가 있습니다...\n\n<div class=\"content-ad\"></div>\n\n# 네이밍 규칙\n\n주어진 패키지 레이아웃에 따라 BaseLearner를 가져오기 위한 코드는 다음과 같습니다.\n\n```python\nfrom common.base_file import BaseLearner\n```\n\n원하는 가져오기는 다음과 같습니다.\n\n<div class=\"content-ad\"></div>\n\nghpackage.common 모듈에서 BaseLearner를 가져왔습니다.\n\n따라서 이 패키지를 사용하는 사람들이 사용하는 네이밍 규칙이 직관적이지 않고 statsmodels.regression.linear_model에서 사용하는 표준과 일치하지 않을 수 있습니다.\n\n# 상대 및 절대 참조\n\nfisher_file.py에서는 ghtestpackage.common 모듈의 BaseLearner를 불러오는 코드가 작동하지 않을 것입니다. 왜냐하면 현재 위치에서 상대적인 참조를 사용했기 때문입니다. 즉, ghtestpackage.common 모듈에서 BaseLearner를 해결하려는 시도는 algorithms.ghtestpackage.common에서 BaseLearner를 찾지 못할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 큰 문제가 있어요\n\n그 문제는 더 심각해지고 있어요. 다양한 요구 사항을 통합하려고 하면서 이 패키지는 한꺼번에 3가지 역할을 수행하려고 노력하고 있어요:\n\n- 외부에서 참조할 수 있는 패키지.\n- Jupyter 노트북을 실행하는 환경.\n- pytest 단위 테스트를 실행하는 환경.\n\n문제는, 이 3가지 다른 사용 사례가 서로 다른 방식으로 실행되며 다른 상대적인 위치에서 실행을 시작한다는 것이 거의 불가능하다는 것이에요.\n\n<div class=\"content-ad\"></div>\n\n패키지가 Python 프로그램으로 가져올 때, 해당 패키지의 시작 지점은 부모 폴더입니다. 다음 시스템 경로를 고려하면 확인할 수 있습니다...\n\n```js\n[\n  \"c:\\\\Users\\\\GHarr\\\\OneDrive\\\\Python Projects\\\\Public-Github\\\\Package Structure\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\python310.zip\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\DLLs\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\lib\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\",\n  \"\",\n  \"C:\\\\Users\\\\GHarr\\\\AppData\\\\Roaming\\\\Python\\\\Python310\\\\site-packages\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\lib\\\\site-packages\",\n  \"C:\\\\Users\\\\GHarr\\\\OneDrive\\\\Python Projects\\\\Packages\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\lib\\\\site-packages\\\\win32\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\lib\\\\site-packages\\\\win32\\\\lib\",\n  \"c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\lib\\\\site-packages\\\\Pythonwin\",\n];\n```\n\n저는 현재 Anaconda를 사용 중이며, project-env 채널을 선택한 상태입니다. 경로에서 알 수 있듯이, **site-packages**가 **c:\\\\Users\\\\GHarr\\\\anaconda3\\\\envs\\\\project-env\\\\lib\\\\site-packages**에 위치하고 있습니다.\n\nAnaconda에서 CMD.exe 프롬프트를 실행하고 **site-packages** 폴더의 디렉토리를 나열하여 쉽게 확인할 수 있습니다...\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_2.png)\n\n프로그램이 pandas에서 DataFrame을 가져오는 것과 같이 import를 실행할 때, 참조는 C:\\Users\\GHarr\\anaconda3\\envs\\project-env\\Lib\\site-packages에서 시작되며 DataFrame이 포함 된 pandas라는 이름의 디렉토리를 찾을 것으로 예상합니다.\n\n주피터 노트북은 다르게 동작합니다. 그들의 \"홈\" 위치(또는 시작 실행 경로)는 .ipynb 소스 파일을 포함하는 폴더이며, 참조는 주피터 노트북에서 상대적으로(및 아래로) 진행됩니다.\n\n마지막으로 Visual Studio Code에서의 pytest 단위 테스트는 다시 다르게 동작합니다. VS Code 안에서 pytest 단위 테스트의 홈 / 실행 경로는 프로젝트의 루트 폴더입니다.\n\n<div class=\"content-ad\"></div>\n\n요약하면 다음과 같습니다...\n\n- 참조된 패키지는 프로젝트 폴더의 상위를 기준으로 상대적인 경로를 참조합니다.\n- Jupyter Notebook은 노트북을 포함하는 폴더를 기준으로 상대적인 경로를 참조합니다.\n- pytest 유닛 테스트는 프로젝트의 루트 폴더를 기준으로 상대적인 경로를 참조합니다.\n\n# 큰 문제 해결하기\n\n오랫동안 이 난제에 대한 유일한 해결책은 내 패키지에서 가져와야 하는 프로젝트의 import 코드에 직접 경로를 삽입하는 것이었습니다...\n\n<div class=\"content-ad\"></div>\n\n이 방법은 작동하지만 일부 심각한 단점이 있습니다.\n\n먼저 이 코드를 실행하는 데 매우 느립니다. 프로젝트가 처음으로 로드되고 VS Code에서 실행될 때, 외부 참조를 해결하고 가져오기를 처리하는 데, 꽤 좋은 i7 프로세서를 사용해도 52초가 걸립니다.\n\n다음 단점은 ghlibrary 프로젝트가 구조가 잘못되었다는 것입니다.\n\n예를 들어, dag_tools.py 및 causal_tools.py가 ghlibrary의 루트에 직접 존재하며 위치를 변경하는 옵션이 제한되어 있습니다. 따라서 시간이 지남에 따라 이러한 소스 파일이 커졌고, VS Code는 린팅, 도구 팁 및 기타 기능을 처리하는 데 느려졌습니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n또한, 패키지에 액세스하는 모든 프로젝트에 경로를 추가하는 코드도 포함되어야 하며, 실제로 패키지 위치를 하드코딩해야 합니다. 이 코드는 구성 파일로 옮길 수 있지만, 여러 프로젝트가 패키지에 액세스하고 패키지가 이동한다면 모두 업데이트해야 합니다.\n\n마지막으로, 이 접근 방식을 취하는 것은 패키지를 더 넓은 Python 커뮤니티에 배포하는 옵션을 방지한다는 가장 큰 단점입니다.\n\n홈/실행 폴더는 부모 폴더가 아닌 패키지 폴더이므로 pandas나 pgmpy와는 다르게 작동합니다. 그 이상으로, Python 커뮤니티가 수동 참조 코드를 포함하고 처리 시간이 느려진다는 것을 기대하는 것은 합리적이지 않습니다.\n\n더 나은 대안이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n사이트 패키지의 경로는 sys.path를 실행하여 쉽게 식별할 수 있습니다. 이미 제 컴퓨터에서는 C:\\Users\\GHarr\\anaconda3\\envs\\project-env\\lib\\site-packages임을 확인했습니다.\n\n파일 이름과 .pth 확장자가 붙은 파일을 생성한 다음, 해당 파일을 site-packages 폴더에 저장하면 Anaconda가 자동으로 읽어 시작 시 삽입할 패키지 경로를 추가할 수 있습니다.\n\n여기에 제 .pth 파일이 어떻게 생겼는지 알려드리겠습니다...\n\n![링크명](/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_3.png)\n\n<div class=\"content-ad\"></div>\n\n이 의미는 만약 ghtestpackage가 C:\\Users\\GHarr\\OneDrive\\Python Projects\\Packages의 하위 폴더로 생성된다면, 모든 Python 프로젝트의 검색 경로에 자동으로 포함되며 그 안에 포함된 모든 파일 및 클래스를 참조하고 가져올 수 있게 됩니다…\n\n- 한 번에 특정 경로를 모든 프로젝트에 하드 코딩할 필요가 사라집니다.\n- 또한, 컴퓨터 전체에서 Packages 경로에 대한 단일 참조만 있기 때문에 pandas 및 기타 인기 있는 패키지와 완전히 동일한 방식으로 작동합니다.\n- 만약 이 패키지가 GitHub을 통해 분산되고 pip 사용자가 이를 사이트 패키지 폴더에 다운로드한다면 계속해서 작동할 것입니다.\n\n모든 이러한 것들이 한 줄의 코드를 한 파일에 추가함으로써 해결됩니다!\n\n큰 문제가 해결되면 나머지 요구사항을 달성하는 것이 훨씬 쉬워질 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 남은 문제 해결하기\n\n## 패키지를 서브 폴더와 파일로 구성하기\n\n제가 소스 파일을 base_file.py 및 fisher_file.py로 명명하고 서브 폴더를 base_folder 및 fisher_folder로 명명한 것을 알아채셨을지도 모릅니다.\n\n소스 파일을 서브 폴더와 파일로 구성해야 하지만, 반대로 가져오기(import)할 때 이러한 이름을 사용하고 싶지는 않을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 다음과 같이 import하는 것은 너무 길고 직관적이지 않습니다.\n\nfrom ghlibrary.algorithms.fisher_folder.fisher_file import Fisher\n\n더 나은 import 방법은 다음과 같습니다.\n\nfrom ghlibrary.algorithms import Fisher\n\n<div class=\"content-ad\"></div>\n\n하지만 코드를 폴더 및 파일로 계층적으로 분할하는 유연성과 패키지의 소비자에게 표시되는 가져오기를 여전히 제어할 수도 있습니다. 이것은 패키지 각 수준에 있는 **init**.py 파일을 통해 이루어집니다.\n\nghpackage\\algorithms\\fisher_folder부터 시작합니다. 여기에 있는 **init**.py 파일은 다음과 같습니다.\n\n```python\nfrom .fisher_file import Fisher\n```\n\n이는 전처리기에게 현재 폴더의 fisher_file.py를 찾도록 지시합니다. ( .은 현재 폴더에 대한 표기법입니다.) 그리고 Fisher 클래스는 이제 fisher_file이 아닌 fisher_folder에 직접 존재하며 해당 폴더에서 참조할 수 있습니다.\n\n이 시점에서 가져오기를 from ghlibrary.algorithms.fisher_folder import Fisher로 단축시킬 수 있으나 더 나은 방법이지만 완벽하지는 않습니다.\n\n<div class=\"content-ad\"></div>\n\n다음 단계는 알고리즘 폴더에 다음과 같이 **init**.py를 제공하는 것입니다...\n\n이전 단계에서 fisher_folder에 추가한 참조를 취하고, 이를 알고리즘 폴더에서 사용할 수 있도록 만듭니다.\n\nfrom .fisher_folder import Fisher은 전처리기에게 현재 폴더에서 시작 (.은 여기에서 시작하라는 뜻이며, algorithms에서 시작) 하고 fisher_folder로 한 수준 아래로 이동하여 Fisher 클래스를 가져오도록 지시합니다.\n\n패키지를 사용하는 소비자는 이제 다음을 사용할 수 있습니다 -\n\n<div class=\"content-ad\"></div>\n\nghlibrary.algorithms에서 Fisher를 가져와주세요.\n\n베이스 클래스를 마무리하기 위해서 동일한 처리가 필요합니다.\n\nghpackage\\common 하위 폴더의 **init**.py 파일은 다음과 같습니다...\n\n그리고 common 폴더에 추가 하위 폴더가 없기 때문에 그게 전부입니다.\n\n<div class=\"content-ad\"></div>\n\n소비자 분들은 다음과 같이 참조할 수 있어요...\n\n```python\nfrom ghpackage.common import BaseLearner\n```\n\n... 심지어 BaseLearner 클래스가 base_file.py에 저장되어 있는 경우에도요.\n\n하위 폴더와 파일로 계층적으로 구성된 프로젝트 클래스들은 이제 클라이언트가 다음과 같이 참조할 수 있어요...\n\n<div class=\"content-ad\"></div>\n\n아직 풀지 않은 수수께끼가 하나 있습니다. Fisher 클래스의 소스 코드를 살펴보십시오...\n\n문제는 Fisher()가 ghtestpackage/algorithms/fisher_folder/fisher_file.py에 있고 ghtestpackage.common에서 from ghtestpackage.common import BaseLearner를 사용하여 BaseLearner를 가져오는 방법입니다.\n\nBaseLearner는 ghtestpackage/common/base_file.py에 위치해 있고 따라서 ghtestpackage.common에서 from ghtestpackage.common import BaseLearner를 사용하는 것은 동작하지 않아야 합니다.\n\n동작하는 이유는 .pth 파일을 사용하여 Anaconda에 C:\\Users\\GHarr\\anaconda3\\envs\\project-env\\lib\\site-packages를 포함하도록 알려주었기 때문입니다. 이 경로는 ghtestpackage의 상위 폴더입니다. 따라서 ghtestpackage.common에서 BaseLearner를 참조하는 것은 패키지의 상위 폴더에서 해결됩니다.\n\n<div class=\"content-ad\"></div>\n\n이 단계에서는 \"완벽한 패키지 프로토타입\"이 생성되었고, 남은 일은 그것이 예상대로 작동하는지 증명하기 위해 철저히 테스트하는 것입니다.\n\n# 완벽한 패키지 프로토타입 테스트\n\n증명 및 테스트를 시작하려면 ghtestpackage/common/base_file.py의 BaseLearner() 및 ghtestpackage/algorithms/fisher_folder/fisher_file.py의 Fisher()의 소스 코드를 확인해보세요...\n\nBaseLearner()이 서로 다른 폴더 위치의 여러 알고리즘을 위한 기본 클래스가 될 것이라는 아이디어 때문에, 이 코드는 common 폴더로 분리되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이번 데모에서 기본 클래스에는 서브 클래스에서 호출할 수 있어야 할 단일 메서드가 있습니다. 각 클래스는 호출되었음을 증명하기 위해 icecream을 사용하여 디버그 메시지를 출력합니다.\n\n## 주피터 노트북 클라이언트 테스트\n\nghtestpackage\\notebooks 폴더에는 ghtest_notebook.ipynb라는 주피터 노트북이 있습니다. 이는 \"완벽한 패키지\" 구조가 패키지 코드를 개발하고 테스트하는 데 도움이 되는 노트북을 포함할 수 있어야 한다는 요구 사항을 충족하기 위한 것입니다.\n\n노트북에 있는 코드는 다음과 같습니다...\n\n<div class=\"content-ad\"></div>\n\n그리고 이것이 출력 결과입니다...\n\n```js\nic | \"BaseLearner.init\";\nic | \"BaseLearner.init\";\nic | \"fisher.init\";\nic | \"BaseLearner.test\";\n```\n\n...결과적으로 베이스 클래스와 알고리즘 클래스를 참조하고 인스턴스화하고 호출할 수 있다는 것을 증명했습니다.\n\n또한 주의할 점은 완전히 별도의 프로젝트에 노트북이 생성되고 위의 코드가 셀에 입력된 경우에도 모든 작업이 올바르게 수행된다는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## pytest 클라이언트 테스트 중\n\n여기에는 ghtestbackage/unit_tests/test_base/test_base.py에 저장된 기본 클래스를 테스트하기 위한 코드가 있습니다...\n\n... 그리고 여기에는 ghtestbackage/unit_tests/test_fisher/test_fisher.py의 코드가 있습니다.\n\n다시 말하지만, .pth 파일의 지시에 따라 패키지의 부모 폴더를 시스템 경로에 추가했기 때문에 참조가 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n최종 증명은 VS Code의 단위 테스트 패널로 이동하여 단위 테스트가 식별되고 발견되었는지 확인하고, 모두 실행하여 오류 없이 완료되는지 확인하는 것입니다...\n\n![image](/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_4.png)\n\n이것은 제안된 완벽한 패키지 프로토타입의 주요 이점 중 하나입니다 —\n\n# 문서 작성\n\n<div class=\"content-ad\"></div>\n\n마지막 요구 사항은 문서 생성과 관련이 있습니다. 한 가지 방법은 모듈, 클래스 및 함수에 포괄적인 독스트링이 있는지 확인하는 것입니다(이 스텁은 VS Code에서 자동으로 생성될 수 있습니다).\n\n다음은 잘 구조화되고 포괄적인 독스트링의 예시입니다…\n\n이러한 독스트링은 작성하는 데 시간이 걸리지만 메서드의 기능, 매개변수, 반환 값, 호출 방법 예시 및 맥락적인 참고 사항을 완벽하게 기록합니다.\n\n이 접근 방식을 모든 소스 코드에 적용하면 pydoc를 사용하여 HTML 형식의 도움말 파일을 자동으로 생성하는 것이 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n제안된 프로젝트 프로토타입에는 makedocs.bat 파일이 포함된 docs라는 폴더가 있습니다...\n\n```js\npython -m pydoc -w \"..\\algorithms\\fisher_folder\\fisher_file.py\"\npython -m pydoc -w \"..\\common\\base.py\"\n```\n\n해야 할 일은 단순히 docs 폴더에서 makedocs를 실행하면 docstrings에서 자동으로 문서가 생성됩니다...\n\n![이미지](/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_5.png)\n\n<div class=\"content-ad\"></div>\n\n많은 다양한 방법으로 도움 파일을 작성하고 생성할 수 있지만 여기서는 pydoc을 선택했습니다. pydoc은 코드와 클래스의 목적과 사용을 설명하는 문서를 빠르고 쉽게 생성할 수 있는 방법을 제공하기 때문입니다.\n\n# 마지막으로 — 디버깅 테스트\n\n현재 제안된 것은 거의 작동하지만 한 가지 더 있습니다...\n\n유닛 테스트가 실패하거나 예상치 못한 결과를 내는 경우 디버깅이 필요할 수 있으며 이 구성에서는 VS Code에서 유닛 테스트 내에서 디버깅을 시작하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n디버깅을 시도하면 \"Invalid message: Found duplicate in \"env\": PATH\"와 함께 프로세스가 크래시됩니다.\n\n오류 대화상자에서는 launch.json을 열 수 있는 옵션이 제공되며, 이를 통해 .vscode 폴더에 다음과 같이 보이는 launch.json 파일이 생성됩니다.\n\n그런데 여전히 제대로 작동하지 않습니다. 목적 속성을 설정하기 위해 추가로 라인을 추가해야 합니다.\n\n여기에 파이널 프루프가 있습니다 — pytest 단위 테스트인 test_fisher_3()가 디버깅되고 있으며, 곧 \"test_fisher\"를 커맨드 라인에 출력할 예정입니다...\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_6.png\" />\n\n# 결론\n\n어떤 프로그래밍 프로젝트도 잘 구조화되고 잘 작성된 코드에 의존하여 코드가 효율적으로 구축되고 예기치 않은 결과를 출력할 때 효과적으로 디버깅 및 수정할 수 있습니다.\n\n또한, 원래 프로그래머거나 다른 사람에 의해 언젠가는 코드를 변경해야 할 것이고 미래 관리 가능성의 효과성을 위해서는 잘 작성된 코드가 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n그럼, 코드를 포함하는 프로젝트가 잘 구조화되고 조직화되어 훌륭한 코드를 제공할 수 있는 기반이 제공되기 때문에 이것이 가능합니다.\n\n프로젝트가 1000줄 이상을 포함하는 경우, 여전히 상대적으로 적은 규모이지만, .py 파일을 여러 개에 걸쳐 지능적으로 분산하지 않으면 VS Code가 느려지고 린팅, 코드 개요 및 타입-어헤드와 같은 기능이 제대로 동작하지 않을 수 있습니다.\n\n이 모든 것의 핵심은 첫 번째 코드 줄을 작성하기 전에 프로젝트 구조를 올바르게 가져야 한다는 것입니다.\n\n이 기사는 요구 사항의 집합을 설명하여 테스트를 통해 이러한 요구 사항을 충족하는 레이아웃 및 구조를 제시함으로써 \"완벽한\" 패키지 구조에 대한 한 제안을 제시했습니다.\n\n<div class=\"content-ad\"></div>\n\n주요 도전 과제는 전문적인 네임스페이스의 최상의 폴더 및 파일 레이아웃을 통합하고 클래스가 .pth 파일을 구성하고 **init**.py 파일의 항목을 통해 일반 프로젝트, Jupyter 노트북 및 pytest 단위 테스트로 가져올 수 있도록 하는 것이었습니다.\n\n파이썬 프로젝트용 완벽한 패키지 프로토타입에 대한 다른 제안이 많을 수 있겠지만, 이 프로젝트는 매우 잘 작동합니다.\n\n# 추가 섹션: 프로토타입 빠르고 쉽게 사용하기...\n\n패키지 프로토타입 프로젝트는 다음 링크를 통해 GitHub에서 다운로드할 수 있습니다...\n\n<div class=\"content-ad\"></div>\n\n... 그리고 다음 단계를 따릅니다...\n\n- 프로젝트를 다운로드하세요.\n- 이를 개발 패키지를 저장할 부모 폴더 바로 아래에 위치시킵니다.\n- docs 하위 폴더에서 mypackages.pth 파일을 Anaconda 설치의 site-packages 폴더로 복사합니다.\n- mypackages.pth 파일을 편집하여 로컬 컴퓨터에서 만든 경로로 대체합니다.\n- Jupyter Notebook 및 pytest 유닛 테스트를 실행하여 참조 및 네임스페이스를 확인합니다.\n- 뼈대 프로젝트를 복사하여 Fisher() 및 BaseLearner()를 실제 클래스로 대체하고 제품 코드로 배치를 시작합니다.\n\n만약 로컬 컴퓨터에서 site-packages 폴더가 어디에 있는지 모호하다면, 간단히 sys를 import하고 sys.path 명령을 실행하여 다음과 유사한 경로를 찾아보세요...\n\n```js\nC:\\Users\\GHarr\\anaconda3\\envs\\project-env\\lib\\site-packages\n```\n\n<div class=\"content-ad\"></div>\n\n# 소통하고 연락하기...\n\n이 기사가 마음에 드셨다면 제 소식을 받아보려면 팔로우해주세요.\n\n인과 추론(저의 다른 최근 기사 참조)에 대한 생각 또는 견해가 있다면 언제든지 연락주세요. 이 흥미로운 새로운 데이터 과학 분야가 어디로 향하고 있는지 알려주세요. 메시지를 남겨주시면 저에게 연락드리겠습니다.\n\n제 이전 기사는 제 연구와 인과 추론과 관련된 모든 내용이 담겨 있는 제 블로그(The Data Blog)에서 확인하실 수 있습니다. 감사합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_0.png"},"coverImage":"/assets/img/2024-06-19-AProposedPerfectPackagePrototypeforPythonProjects_0.png","tag":["Tech"],"readingTime":14},{"title":"팬더스를 포함한 다양한 라이브러리에서 Case-When 다시 살펴보기","description":"","date":"2024-06-19 23:17","slug":"2024-06-19-LetsRevisitCase-WheninDifferentLibrariesIncludingtheNewPlayerPandas","content":"\n\n\n![이미지](/assets/img/2024-06-19-LetsRevisitCase-WheninDifferentLibrariesIncludingtheNewPlayerPandas_0.png)\n\n데이터 분석, 데이터 정리 또는 심지어 피처 엔지니어링을 할 때, 다른 열의 값에 기반한 새로운 열을 만드는 것은 자주 수행되는 작업입니다.\n\n나는 데이터 정리 및 조작에 사용한 모든 도구들이 이 작업을 위한 함수를 가지고 있었다 (예: SQL, R 데이터 테이블, PySpark). 이제 우리에게 새로운 플레이어가 등장했습니다: Pandas.\n\n그런데, Pandas로 조건부 열을 만드는 것은 가능했지만, 전용 case-when 함수는 없었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n판다 2.2.0에서 case_when 함수가 도입되어 한 개 이상의 조건에 기반한 Series 객체를 생성할 수 있습니다.\n\n이 유용한 작업을 어떻게 수행하는지 다시 살펴봅시다. 이것은 데이터 분석 및 조작 도구로 널리 사용되는 방법입니다.\n\n도구 간 차이를 쉽게 식별하고 일관성 있게 유지하기 위해 작은 데이터셋을 사용하겠습니다.\n\n## SQL\n\n<div class=\"content-ad\"></div>\n\n다음은 'mytable'이라는 작은 SQL 테이블입니다.\n\n```js\n|           a |        b |       c |\n|-------------|----------|---------|\n|           0 |        5 |       1 |\n|           1 |       -1 |       0 |\n|           5 |       20 |       0 |\n|           4 |        8 |       1 |\n|           4 |        4 |       1 |\n|          10 |        7 |       0 |\n|           4 |        2 |       1 |\n```\n\n기존 열의 값에 따라 새로운 열을 생성할 것입니다. 다음은 조건입니다:\n\n- a 열이 b 열보다 크면 a 열의 값이 사용됩니다.\n- a 열이 b 열보다 작으면 a 열과 c 열의 곱이 사용됩니다.\n- 그렇지 않은 경우 (즉, a 열이 b 열과 같은 경우), a 열과 b 열의 합이 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n필요에 따라 여러 조건을 만들고, 그것들을 훨씬 복잡하게 만들 수 있지만, 이 세 가지 조건은 논리를 배울 때 충분합니다.\n\n새 열을 \"d\" 라고 부르고, 위 두 조건에 기반한 이 열을 생성하기 위한 SQL 코드는 다음과 같습니다:\n\n```js\nselect \n  (case \n     when a > b then a\n     when a < b then a * c\n     else a + b end\n  ) as d\nfrom mytable\n```\n\n이 SQL 코드는 \"mytable\"에서 열 d만 생성하고 선택합니다. 열 a, b, c를 함께 반환하도록 필요하다면, select 문에 해당 열을 작성해주세요.\n\n<div class=\"content-ad\"></div>\n\n```R\nselect \n  a,\n  b,\n  c,\n  (case \n     when a > b then a\n     when a < b then a * c\n     else a + b end\n  ) as d\nfrom mytable\n```\n\n## R data table\n\n데이터 테이블 패키지는 R 프로그래밍 언어를 위한 매우 효율적인 데이터 분석 및 조작 도구입니다.\n\n이제 이 패키지를 사용하여 조건부 열 d를 생성하는 방법을 배워보겠습니다. 먼저 SQL 테이블과 동일한 열을 포함하는 데이터 테이블을 만들어봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nmytable <- data.table(\n      a=c(0, 1, 5, 4, 4, 10, 4), \n      b=c(5, -1, 20, 8, 4, 7, 2), \n      c=c(1, 0, 0, 1, 1, 0, 1)\n)\n```\n\n데이터 테이블에서 조건에 맞는 경우 fcase 함수를 사용하여 구현할 수 있습니다. 조건을 작성하고 해당하는 값들을 쉼표로 구분하여 입력할 수 있습니다.\n\n다음은 주어진 조건에 따라 열 d를 만드는 방법입니다:\n\n```js\nmytable[, d := (fcase(a > b, a, a < b, a*c, a==b, a+b))]\n```\n\n<div class=\"content-ad\"></div>\n\nfcase 함수 내부의 첫 번째 표현식(a ` b)은 첫 번째 조건이며, 두 번째 표현식(a)은 해당 값을 나타냅니다. 세 번째 표현식(a ` b)은 두 번째 조건이며, 네 번째 표현식(a*c)은 해당 값을 의미합니다. 그리고 이어서 계속됩니다.\n\n이제 데이터 테이블 \"mytable\"은 다음과 같습니다:\n\n```js\n    a  b c  d\n1:  0  5 1  0\n2:  1 -1 0  1\n3:  5 20 0  0\n4:  4  8 1  4\n5:  4  4 1  8\n6: 10  7 0 10\n7:  4  2 1  4\n```\n\n## PySpark\n\n<div class=\"content-ad\"></div>\n\n파이스파크는 대규모 데이터 처리에 사용되는 분석 엔진인 Spark를 위한 Python API입니다. 수십억 개의 행을 가진 데이터셋 작업에는 보통 Spark가 선호되는 도구입니다.\n\nPySpark API는 매우 직관적이며 이해하기 쉬운 구문을 가지고 있습니다. 먼저 이전과 동일한 열과 값이 포함된 Spark DataFrame을 만들어 봅시다.\n\n```python\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql import functions as F\nspark = SparkSession.builder.getOrCreate()\n\ndata = [\n    {\"a\": 0, \"b\": 5, \"c\": 1},\n    {\"a\": 1, \"b\": -1, \"c\": 0},\n    {\"a\": 5, \"b\": 20, \"c\": 0},\n    {\"a\": 4, \"b\": 8, \"c\": 1},\n    {\"a\": 4, \"b\": 4, \"c\": 1},\n    {\"a\": 10, \"b\": 7, \"c\": 0},\n    {\"a\": 4, \"b\": 2, \"c\": 1}\n]\n\nmytable = spark.createDataFrame(data)\n```\n\n우리는 먼저 spark 세션을 시작하고 그 후에 DataFrame을 만들었습니다. Databricks와 같은 개발 환경에서 작업하는 경우에는 명시적으로 spark 세션을 생성할 필요가 없다는 점에 유의하세요.\n\n<div class=\"content-ad\"></div>\n\nwithColumn 함수를 사용하여 새 열을 생성하고 여러 조건에 따라 값을 결정하기 위해 when 함수를 사용할 수 있습니다.\n\n```js\nmytable = (\n    mytable\n    .withColumn(\"d\",\n                F.when(F.col(\"a\") > F.col(\"b\"), F.col(\"a\"))\n                 .when(F.col(\"a\") < F.col(\"b\"), F.col(\"a\") * F.col(\"c\"))\n                 .otherwise(F.col(\"a\") + F.col(\"b\")))\n)\n\nmytable.show()\n\n+---+---+---+---+\n|  a|  b|  c|  d|\n+---+---+---+---+\n|  0|  5|  1|  0|\n|  1| -1|  0|  1|\n|  5| 20|  0|  0|\n|  4|  8|  1|  4|\n|  4|  4|  1|  8|\n| 10|  7|  0| 10|\n|  4|  2|  1|  4|\n+---+---+---+---+\n```\n\n이전 도구와 마찬가지로 필요한만큼 많은 조건을 결합할 수 있습니다. 각 조건은 자체 when 함수를 가지고 있고 최종 조건의 값 (이전 조건 중 어느 것도 충족되지 않을 경우)은 otherwise 함수를 사용하여 지정됩니다.\n\n## 판다스\n\n<div class=\"content-ad\"></div>\n\n팬더스는 데이터 분석 및 조작 작업 중 가장 자주 사용되는 도구일 수 있습니다. 버전 2.2.0 이전에는 팬더스에 case_when 함수가 없었습니다. 그러나 다른 함수들을 사용하여 작업을 처리할 수 있었습니다. 예를 들어, 팬더스의 where 함수나 NumPy의 where 및 select 함수를 사용할 수 있었습니다. 그러나 지금은 팬더스에 case_when 함수가 있으니 다른 도구들로 작업하던 것을 이 함수를 사용하여 보겠습니다.\n\n먼저 팬더스 데이터프레임을 생성해보겠습니다.\n\n```python\nimport pandas as pd\n\nmytable = pd.DataFrame(\n    {\n        \"a\": [0, 1, 5, 4, 4, 10, 4],\n        \"b\": [5, -1, 20, 8, 4, 7, 2],\n        \"c\": [1, 0, 0, 1, 1, 0, 1]\n    }\n)\n```\n\ncase_when 함수는 조건 및 해당 값을 튜플로 포함하는 케이스 리스트를 인수로 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ncaselist = [\n    (mytable[\"a\"] > mytable[\"b\"], mytable[\"a\"]),\n    (mytable[\"a\"] < mytable[\"b\"], mytable[\"a\"] * mytable[\"c\"]),\n    (mytable[\"a\"] == mytable[\"b\"], mytable[\"a\"] + mytable[\"b\"])\n]\n\nmytable.loc[:, \"d\"] = mytable[\"a\"].case_when(caselist)\n\nmytable\n\n    a  b  c  d\n0   0  5  1  0\n1   1 -1  0  1\n2   5 20  0  0\n3   4  8  1  4\n4   4  4  1  8\n5  10  7  0 10\n6   4  2  1  4\n```\n\ncaselist의 각 튜플은 조건과 해당하는 값이 포함되어 있어요. DataFrame의 열에 대해 case_when 함수를 적용할 때 중요한 점이에요. 주어진 조건 중 어느 조건도 충족되지 않는 행이 있는 경우, 새 열의 해당 행은 원래 열의 값을 가져와요.\n\n위의 예시에서, 만약 그러한 행이 있다면, 열 d의 해당 값은 열 a에서 가져오게 될 거에요. caselist의 마지막 조건을 제거하여 시도해보겠어요.\n\n```js\ncaselist = [\n    (mytable[\"a\"] > mytable[\"b\"], mytable[\"a\"]),\n    (mytable[\"a\"] < mytable[\"b\"], mytable[\"a\"] * mytable[\"c\"])\n]\n\nmytable.loc[:, \"d\"] = mytable[\"a\"].case_when(caselist)\n\nmytable\n\n    a  b  c  d\n0   0  5  1  0\n1   1 -1  0  1\n2   5 20  0  0\n3   4  8  1  4\n4   4  4  1  4\n5  10  7  0 10\n6   4  2  1  4\n```\n\n<div class=\"content-ad\"></div>\n\n4번 행의 값들을 확인해 보세요. 열 d의 값은 열 a의 값과 같습니다.\n\n## 마지막으로\n\n데이터 정리, 분석 및 조작을 위한 많은 도구와 라이브러리가 있습니다. 대부분의 경우 사용할 도구는 선택의 문제입니다. 이러한 도구들은 일반적인 작업을 효율적으로 수행할 수 있는 능력을 갖추고 있습니다. 그러나 여전히 다양한 도구를 사용하여 특정 작업을 수행하는 방법을 알고 있는 것이 좋습니다.\n\n이 글에서는 SQL, PySpark, R 데이터 테이블 및 Pandas를 사용하여 조건부 열을 생성하는 방법에 대해 배웠습니다.\n\n<div class=\"content-ad\"></div>\n\n읽어 주셔서 감사합니다. 피드백이 있으시면 언제든 알려주세요!","ogImage":{"url":"/assets/img/2024-06-19-LetsRevisitCase-WheninDifferentLibrariesIncludingtheNewPlayerPandas_0.png"},"coverImage":"/assets/img/2024-06-19-LetsRevisitCase-WheninDifferentLibrariesIncludingtheNewPlayerPandas_0.png","tag":["Tech"],"readingTime":6},{"title":"Nestjs 오류 처리","description":"","date":"2024-06-19 23:16","slug":"2024-06-19-NestjsErrorHandling","content":"\n\n<img src=\"/assets/img/2024-06-19-NestjsErrorHandling_0.png\" />\n\n# 1. 소개\n\nNestJs는 백엔드 시스템을 개발하는 데 사용되는 프레임워크입니다. 이 프레임워크는 컨트롤러 레이어에서 오류 처리에 대한 규칙을 정의했지만, 이는 대규모 프로젝트에는 충분하지 않을 수 있습니다. 본 문서에서는 오류를 우아하게 처리하고 신중하게 대우하는 더 효과적이고 구조화된 접근 방식을 소개합니다.\n\n# 2. 오류 처리 전략\n\n<div class=\"content-ad\"></div>\n\n# 에러 유형\n\n코드에서 발생할 수 있는 에러 유형을 정의해보겠습니다:\n\n- 유효성 검사 에러\n- 제삼자 에러\n- 데이터베이스 에러\n- 일반(예기치 않은) 에러\n\n언급된 모든 종류의 에러에 특히 주의해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n특정 오류, 예를 들어 유효성 검사 오류와 같은 경우 적절한 응답이나 상태 코드로 처리할 수 있습니다. 그러나 일반 오류와 같은 다른 종류의 오류의 경우, 유지보수자에게 알리거나 높은 우선순위로 티켓을 생성하는 등의 추가 조치가 필요할 수 있습니다. 또 다른 오류 유형인 데이터베이스 오류는 복구와 복원 논리가 필요할 수 있습니다.\n\n# 3. 다른 계층에서의 오류 처리\n\n저는 우리의 응용프로그램 계층을 다음과 같이 분류하는 것을 선호합니다:\n\n- 요청 계층\n- 인터셉터\n- 가드\n- 컨트롤러 계층(*)\n- 서비스 계층\n- 모델\n- 데이터베이스\n- 예외 처리 계층\n\n<div class=\"content-ad\"></div>\n\n컨트롤러 레이어 아래의 모든 레이어에서 오류가 발생하면 상위 레이어로 throw해야 합니다. 예를 들어:\n\n- 데이터베이스 CRUD 함수(ORM 함수 등)에서 오류가 발생하면 Database Error 유형을 throw해야 합니다.\n- 서드파티 호출(Stripe 등)에서 오류가 발생하면 Third-party 에러 유형을 throw해야 합니다.\n- 예기치 않은 오류가 발생하면 Generic 에러 유형으로 간주해야 합니다.\n- 등등\n\n```js\nasync sampleFucntion(@AuthenticatedUser() jwtPayload: JwtDto) {\n        try {\n            return this.utilsService.apiResponse(200, await this.sampleService.sampleServiceFucntion(jwtPayload.id))\n        } catch (error) {\n            this.utilsService.handleError(error, jwtPayload, {}, 'description')\n        }\n    }\n```\n\n언급한 모든 오류는 상위 레이어로 throw되어야 하며, throw된 오류를 받은 해당 레이어도 Controller 레이어가 `try-catch` 블록에서 오류를 받게 될 때까지 throw해야 합니다. 그런 다음 Controller 레이어는 잡힌 오류를 utils 모듈이나 errors 모듈에 포함된 `ErrorHandler` 함수로 전달해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 오류 처리기 함수\n\n이 함수는 받은 오류 유형을 Switch-case 또는 if-else 방식으로 감지하여 처리해야 합니다.\n\n```js\nhandleError(error, jwt: JwtDto, additionalInfo: any, description: string): void {\n        if (error instanceof CheckingException) {\n            throw new CheckingException(error.message, error.statusCode,error.messageData)\n        } else if (error instanceof DatabaseException) {\n            throw new DatabaseException(error.message, error, error.queryParams, description)\n        } else if (error instanceof StripeErrorException) {\n            throw new StripeErrorException(error as Stripe.errors.StripeError, error.stack, description)\n        } else if (error instanceof HttpException){\n                throw error\n        } else {\n            throw new GenericException(error.message, error, jwt, additionalInfo, description)\n        }\n    }\n```\n\n유형을 감지한 후, 각 오류 유형에 적합한 매개변수로 오류 유형을 생성하고 해당 오류를 throw해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n샘플 Exception 클래스:\n\n```js\nexport class DatabaseException extends Error {\n    queryParams: any\n    description: any\n    stack:any\n    message : string\n    constructor(message: string,error: Error, q: any, description?: string) {\n        super(`데이터베이스 오류가 발생했습니다: ${message}`)\n        this.queryParams = q\n        this.description = description\n        this.stack = error.stack\n        this.message = error.message\n    }\n}\n```\n\n특정 APP_FILTER를 정의하고 app.module에서 등록해야 합니다:\n\n```js\nproviders: [\n    {\n        provide: APP_FILTER,\n        useClass: GenericExceptionFilter,\n    },\n    {\n        provide: APP_FILTER,\n        useClass: checkingExceptionFilter,\n    },\n    {\n        provide: APP_FILTER,\n        useClass: DatabaseExceptionFilter,\n    },\n    {\n        provide: APP_FILTER,\n        useClass: StripeExceptionFilter,\n    },\n    AppService,\n    UtilsService,\n    JwtService,\n    LoggerService,\n]\n```\n\n<div class=\"content-ad\"></div>\n\n예외 필터에서는 이제 이러한 오류 중 하나에 완벽하게 대응해야 합니다:\n다음 조건을 고려해 주세요:\n\n- 데이터베이스 및 일반적인 오류는 유지보수자에게 알리고 처리된 오류에 대한 사용자 응답이 있어야 합니다.\n- Stripe 및 Checking(유효성) 오류는 사용자에게만 응답해야 합니다.\n\n데이터베이스 및 일반적인 오류에 대한 샘플 예외 필터:\n\n```js\n// database.filter.ts\nimport { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common'\nimport { LoggerService } from '../../../../logger/logger.service'\nimport { GenericException } from './generic.exception'\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n@Catch(GenericException)\nexport class GenericExceptionFilter implements ExceptionFilter {\n    constructor(private readonly loggerService: LoggerService) {}\n    catch(exception: GenericException, host: ArgumentsHost) {\n        const ctx = host.switchToHttp()\n        const response = ctx.getResponse()\n        const errorData = {\n            description: exception.description,\n            stack: exception.stack,\n            jwtPayload: exception.jwtPayload,\n            additionalInfo: exception.additionalInfo,\n            message: exception.message,\n        }\n        this.loggerService.error(exception.message, errorData)\n        response.status(500).json({\n            statusCode: 500,\n            message: exception.message,\n            error: 'Error',\n        })\n    }\n}\n```\n\nWinston 로거를 사용하여 오류 수준 로그를 송신 및 티켓 생성을 위해 로그 전송기를 정의했습니다:\n\nthis.loggerService.error(exception.message, errorData)\n\n일반적인 오류(외부 라이브러리 또는 유효성 검사 오류)에 대한 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common'\nimport { CheckingException } from './checking.exception'\n```\n\n```js\n@Catch(CheckingException)\nexport class checkingExceptionFilter implements ExceptionFilter {\n    catch(exception: CheckingException, host: ArgumentsHost) {\n        const ctx = host.switchToHttp()\n        const response = ctx.getResponse()\n        response.status(exception.statusCode).json({\n            statusCode: exception.statusCode,\n            message: exception.messageData,\n            error: exception.message,\n        })\n    }\n}\n```\n\n# 모니터링 도구\n\n더 나은 오류 처리를 위해 몇 가지 도구를 사용할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- Sentry\n- Raygun\n- Winston\n- 등\n\n이 프로젝트에서는 Raygun을 사용하여 오류 모니터링 및 보고를 합니다.\n\n## Raygun\n\nRaygun은 개발자가 애플리케이션에서 문제를 식별하고 전체 소프트웨어 품질을 향상시키는 종합 오류, 충돌 및 성능 모니터링 솔루션입니다.\n\n<div class=\"content-ad\"></div>\n\n```typescript\nasync createUser(createUserDto: CreateUserDto): Promise<User> {\n    try {\n      // 사용자 생성을 위한 비즈니스 로직\n    } catch (error) {\n      this.raygunLoggerService.error('사용자 생성 실패', error.stack);\n      throw new Error('사용자 생성 실패');\n    }\n```\n\n성능 모니터링\n\n- Raygun은 성능 메트릭을 추적하고 응용 프로그램의 병목 현상을 식별하는 실제 사용자 모니터링 (RUM) 및 응용 프로그램 성능 모니터링 (APM)도 제공합니다.\n\nRaygun 대시보드\n\n<div class=\"content-ad\"></div>\n\nRaygun 대시 보드에 액세스하여 자세한 오류 보고서를 확인하고 응용 프로그램 성능을 추적하며 중요한 문제에 대한 경보 및 알림을 설정할 수 있습니다.\n\nRaygun을 NestJS 애플리케이션에 통합하면 오류 및 성능 문제에 대한 강력한 통찰력을 얻어 문제를 선제적으로 해결하고 소프트웨어의 전반적인 안정성과 신뢰성을 향상시킬 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-NestjsErrorHandling_0.png"},"coverImage":"/assets/img/2024-06-19-NestjsErrorHandling_0.png","tag":["Tech"],"readingTime":7},{"title":"초보자를 위한 Nestjs","description":"","date":"2024-06-19 23:15","slug":"2024-06-19-Nestjsforbeginners","content":"\n\nNest.js는 TypeScript를 사용하여 확장 가능한 서버 측 애플리케이션을 구축하기 위한 Node.js 프레임워크입니다.\n\n![Nest.js](/assets/img/2024-06-19-Nestjsforbeginners_0.png)\n\n# Nest.js를 선택하는 이유\n\n아마 이미 알고 계시다시피, 인기 있는 Node.js 프레임워크 중 하나는 Express입니다. 디자인상으로 매우 미니멀하게 설계되어 있습니다. 몇 가지 기능을 소개하여 서버 측 애플리케이션을 구축할 수 있지만, 백엔드의 전반적인 아키텍처는 사용자에게 달려 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Nestjsforbeginners_1](/assets/img/2024-06-19-Nestjsforbeginners_1.png)\n\nExpress 문서를 살펴보면 라우팅, 미들웨어, 일부 오류 처리를 수행할 수 있는 몇 가지 기능을 제공합니다. 이렇게 보면 이것이 거의 전부입니다. 이러한 아키텍처의 부재는 굉장히 유연하다는 점을 의미합니다. Express로 원하는 대로 거의 무엇이든 할 수 있습니다.\n\n그러나 프로젝트나 팀이 성장함에 따라 여러분은 매우 쉽게 스파게티로 변할 수 있다는 것을 발견할 것입니다. 여러분은 실제로 규칙과 구조가 필요합니다. 특히 GraphQL, REST 또는 Swagger와 같은 것들을 통합해야 할 때 이것들은 매우 중요합니다.\n\n이제 Nest가 나와서 말합니다: \"에이, 우리가 서버 쪽 애플리케이션의 아키텍처를 돌보겠다고. 그리고 가장 좋은 부분은 무엇일까요? Express를 여전히 사용할 수 있다는 것입니다!\"\n\n\n<div class=\"content-ad\"></div>\n\n# Nest.js가 작동하는 방식\n\nNest.js는 빠른 개발과 예측 가능하고 가독성 있는 코드를 위해 express (Fastify도 포함)를 활용하는 도구 모음을 제공합니다. 기본적으로 REST 및 GraphQL API를 지원하거나 Laravel이나 Ruby on Rails와 같은 프레임워크를 사용하여 모델-뷰-컨트롤러(MVC) 설계 패턴을 활용하여 풀 스택 애플리케이션을 구축하는 데 사용할 수 있습니다.\n\n데이터베이스 작업을 처리하거나 보안을 다루는 등 서버 측 애플리케이션에서 수행할 수 있는 작업을 상상할 수 있는 모듈이 풍부하게 포함되어 있습니다.\n\n![Nest.js 이미지](/assets/img/2024-06-19-Nestjsforbeginners_2.png)\n\n\n<div class=\"content-ad\"></div>\n\nNest.js에는 훌륭한 문서가 있어요. 모든 핵심 개념에 대한 개요를 제공할 뿐만 아니라 테스팅, 데이터베이스 연결, 작업 스케줄링, 큐, 이벤트, 웹소켓, GraphQL 등 다른 작업 방법에 대한 지침도 볼 수 있어요.\n\n그리고 TypeScript에 매우 중점을 두고 있어요. OOP와 FP의 요소를 결합했는데, 데코레이터에 큰 비중을 두고 있어요. 스프링부트 프레임워크를 사용해봤다면 익숙할 수도 있겠죠.\n\n# Nest CLI\n\nNest에는 자체 강력한 Command Line Tool이 있어요. nest new 명령어로 새 프로젝트를 손쉽게 만들 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\n> nest new server-side-app\n```\n\n이 명령은 Jest를 통해 미리 구성된 코드베이스를 제공하고, 타입스크립트를 설정하여 더 가독성이 있고 믿을만한 코드를 작성할 수 있도록 합니다. 이제 Nest.js로 시작할 준비가 되었습니다!\n\n독자 여러분 감사합니다 🎉\n","ogImage":{"url":"/assets/img/2024-06-19-Nestjsforbeginners_0.png"},"coverImage":"/assets/img/2024-06-19-Nestjsforbeginners_0.png","tag":["Tech"],"readingTime":2},{"title":"Nodejs에서 첫 번째 REST API를 만드는 방법","description":"","date":"2024-06-19 23:14","slug":"2024-06-19-HowtomakeyourfirstRESTAPIinNodejs","content":"\n\n## 5분 이내로\n\n![이미지](/assets/img/2024-06-19-HowtomakeyourfirstRESTAPIinNodejs_0.png)\n\nNode.js에서 REST API (Representational State Transfer Application Programming Interface)를 만드는 것은 현대 웹 개발자에게 필수적인 기술입니다. 이 유형의 API는 웹 애플리케이션과 같은 다양한 클라이언트가 상태를 유지하지 않는 일련의 작업을 사용하여 서버와 상호 작용할 수 있게 합니다. 이 튜토리얼에서는 Node.js에서 간단한 REST API를 설정하는 기본 사항을 살펴보며, 데이터 유형, 클래스 및 다양한 HTTP 메서드를 사용한 코드 예제를 다룰 것입니다.\n\n# 필수 사항\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 시스템에 Node.js가 설치되어 있는지 확인해주세요. Node.js는 nodejs.org에서 다운로드할 수 있습니다. 또한 JavaScript, Node.js, 그리고 인기 있는 Node.js 프레임워크 Express에 대한 기본적인 이해가 필요합니다.\n\n# 단계 1: 프로젝트 설정하기\n\n먼저, 프로젝트를 위한 새 디렉토리를 만들고 그 안에서 새 Node.js 프로젝트를 초기화하세요.\n\n```js\nmkdir my-rest-api\ncd my-rest-api\nnpm init -y\n```\n\n<div class=\"content-ad\"></div>\n\n위 작업은 당신의 프로젝트 종속성을 관리할 package.json 파일을 디렉토리에 생성합니다.\n\n# 단계 2: Express 설치하기\n\nHTTP 요청을 쉽게 처리하려면 Express를 설치하세요.\n\n```js\nnpm install express\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 3: 첫 번째 엔드포인트 생성하기\n\n이제 프로젝트 디렉토리에 index.js 파일을 생성하세요. 이것이 진입점이 될 것입니다.\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.listen(3000, () => {\n console.log(\"포트 3000에서 실행 중인 서버\");\n});\n```\n\n이 코드는 포트 3000에서 수신 대기하는 기본 Express 서버를 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 4: HTTP 메소드 처리\n\nREST API는 다양한 HTTP 메소드와 함께 작동합니다. 가장 일반적인 메소드는 GET, POST, PUT 및 DELETE입니다.\n\n# GET 요청\n\n간단한 메시지를 반환하는 GET 엔드포인트를 만들어 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\napp.get(\"/msg\", (req, res, next) => {\n  res.json({\"message\": \"안녕, 세계!\"});\n});\n```\n\n# POST 요청\n\nPOST 요청을 할 때는 종종 데이터를 받게 됩니다. 예시를 보겠습니다.\n\n```js\napp.use(express.json()); // for parsing application/json\n\napp.post(\"/msg\", (req, res, next) => {\n  const message = req.body.message;\n  res.json({\"receivedMessage\": message});\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 5: 클래스와 데이터 유형 사용하기\n\n더 나은 코드 구성을 위해 클래스를 사용하여 코드를 구성할 수 있습니다. Message 클래스를 만들어 봅시다.\n\n```js\nclass Message {\n  constructor(content) {\n    this.content = content;\n  }\n\n  getContent() {\n    return this.content;\n  }\n}\n```\n\n이제 이 클래스를 사용하여 POST 엔드포인트를 리팩토링할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\napp.post(\"/msg\", (req, res, next) => {\n  const newMessage = new Message(req.body.message);\n  res.json({\"receivedMessage\": newMessage.getContent()}); \n});\n```\n\n# 단계 6: API 테스트하기\n\nAPI를 테스트하려면 Postman이나 cURL과 같은 도구를 사용할 수 있습니다. GET 요청의 경우 브라우저에서 http://localhost:3000/msg 로 간단히 방문할 수 있습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\nNode.js에서 REST API를 만드는 것은 연습을 통해 더 직관적인 과정이 되는 간단한 일입니다. Express의 사용은 다양한 HTTP 메소드를 간단하게 처리하게 해주며, 클래스와 적절한 데이터 유형을 사용하여 코드를 조직화하면 유지 관리 및 가독성을 크게 향상시킬 수 있습니다.\n\n기억하세요, 이것은 시작점에 불과합니다. 더 편안해지면 API를 더 복잡한 라우트로 확장하거나 데이터베이스에 연결하거나 인증을 구현하는 등 다양한 기능을 추가할 수 있습니다. 계속해서 탐험하고 실험하여 더 견고하고 효율적인 API를 만들어 보세요!","ogImage":{"url":"/assets/img/2024-06-19-HowtomakeyourfirstRESTAPIinNodejs_0.png"},"coverImage":"/assets/img/2024-06-19-HowtomakeyourfirstRESTAPIinNodejs_0.png","tag":["Tech"],"readingTime":3}],"page":"53","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}