{"pageProps":{"posts":[{"title":"httpOnly 쿠키로 React 앱 보안을 강화하는 방법","description":"","date":"2024-06-22 03:10","slug":"2024-06-22-UsehttpOnlycookieToSecureYourReactApp","content":"\n\n\n<img src=\"/assets/img/2024-06-22-UsehttpOnlycookieToSecureYourReactApp_0.png\" />\n\n안녕하세요 여러분, 영원한 학습자가 돌아왔어요. 처음 게시물이 백엔드 개발에 관한 것이었으니, 이번에는 프론트엔드 주제에 대해 이야기하기로 했어요. 보안과 관련된 주제를 선택했어요.\n\n사용자 세션을 관리하고 localStorage에 토큰을 저장하기로 결정한다고 상상해보세요. 이 접근 방식은 편리해 보일 수 있지만, 여러분의 토큰을 잠재적인 보안 위험에 노출시키게 됩니다.\n\n외부 사이트 스크립팅 (XSS) 공격을 통해 삽입된 악성 스크립트는 쉽게 localStorage에 접근하여 이러한 토큰을 도용할 수 있어 사용자 계정 및 중요한 정보에 미승인된 액세스를 유발할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 위험을 줄이기 위한 더 안전한 대안은 세션 토큰을 저장하기 위해 httpOnly 쿠키를 사용하는 것입니다.\n\n간단 요약.\n\n이 블로그 포스트는 React 앱에서 httpOnly 쿠키를 사용하는 방법을 설명합니다. 이미 해당 쿠키를 제공하는 API가 있는 것으로 가정합니다.\n\n# HttpOnly 쿠키란 무엇인가\n\n<div class=\"content-ad\"></div>\n\nHttpOnly 쿠키는 서버에서만 액세스할 수 있는 쿠키로, JavaScript와 같은 클라이언트 측 스크립트에서는 액세스할 수 없는 쿠키입니다.\n\nHttpOnly 속성은 Set-Cookie HTTP 응답 헤더에 포함되며, 해당 쿠키가 JavaScript의 Document.cookie API를 통해 액세스할 수 없음을 나타냅니다. 이를 통해 쿠키를 크로스 사이트 스크립팅 (XSS) 공격으로부터 보호하여 보안을 강화합니다.\n\n이러한 관행은 세션 토큰이 도용되거나 남용되는 것을 방지하여 사용자 세션의 기밀성과 무결성을 유지함으로써 웹 응용 프로그램의 보안을 강화합니다.\n\nHttpOnly 쿠키를 구현하는 것은 일반적인 웹 취약점에 대한 응용 프로그램의 방어를 강화하는 간단하고 효과적인 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n# 전제 조건\n\n다음 코드 스니펫은 다음 라이브러리를 사용합니다:\n\n- react-hook-form\n- axios\n- react-query\n- react-router-dom\n\n# 인증 시스템 설정\n\n<div class=\"content-ad\"></div>\n\n우리의 React 앱은 로그인 페이지가 있고 사용자가 로그인한 후에 리소스에 액세스할 것입니다. 로그인 폼 제출 프로세스를 설정하는 방법을 알려드리겠습니다:\n\n## 로그인 폼 제출하기\n\n이미 로그인 폼이 준비되어 있다고 가정하고, 제출 프로세스에 집중해 봅시다:\n\n```js\nimport { LoginFailure } from \"./types/LoginFailure\";\nimport { LoginRequest } from \"./types/LoginRequest\";\nimport { UserInterface } from \"./types/UserInterface\";\nimport { useMutation } from \"@tanstack/react-query\";\nimport { SubmitHandler, useForm } from \"react-hook-form\";\nimport { useAuth } from \"./Service/AuthProvider\";\nimport apiClient from './apiClient';\n\nconst Login = () => {\n  const { mutate, isPending } = useMutation({\n    mutationFn: (data: LoginRequest) => {\n      const config = { withCredentials: true };\n      return apiClient.post<UserInterface | LoginFailure>(\"/login\", data, config);\n    },\n  });\n\n  const { control, handleSubmit } = useForm<LoginRequest>({\n    defaultValues: { email: \"\", password: \"\" },\n  });\n\n  const { logUserIn } = useAuth();\n  const onSubmit: SubmitHandler<LoginRequest> = (formData) => {\n    mutate(formData, {\n      onSuccess: (response) => {\n        logUserIn();\n      },\n    });\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      {/* 여기에 폼 필드를 넣으세요 */}\n    </form>\n  );\n}\n\nexport default Login;\n```\n\n<div class=\"content-ad\"></div>\n\n## 여기서 우리가 한 일은 무엇인가요 ?\n\n우리는 React 기능 컴포넌트인 Login을 만들었습니다. 이는 폼 핸들링과 뮤테이션 훅을 사용하여 사용자 로그인 기능을 다룹니다.\n\n- useMutation: React Query의 이 훅은 뮤테이션(실제로 서버에서 데이터를 변경하는 API 호출)을 다루는 데 사용됩니다.\n- useForm: React Hook Form에서는 폼 관리에 사용됩니다.\n- useAuth: 사용자 로그인을 포함한 인증 관련 작업을 처리하는 사용자 정의 훅입니다.\n- onSubmit: 폼이 제출될 때 호출되는 함수입니다.\n\nhttpOnly 쿠키를 고려해야 할 사항은 mutationFn 메서드에서 API 호출에 설정한 구성입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// ...\nmutationFn: (data: LoginRequest) => {\n  const config = { withCredentials: true };\n  return apiClient.post<UserInterface | LoginFailure>(\n    \"/login\", data, config\n  );\n},\n// ...\n```\n\n그 구성 없이는 헤더가 손실되어 React 요청이 성공하지 않을 것입니다.\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*4CPCLz6E3A5f1RAq5Cbq1A.gif)\n\n## 알아두면 좋은 사항\n\n<div class=\"content-ad\"></div>\n\nCORS 문제를 만날 수 있습니다. 해결하는 방법은 다음과 같습니다:\n\n- Node 백엔드의 경우 cors NPM 모듈을 사용하세요.\n- Symfony PHP 애플리케이션의 경우 NelmioCorsBundle을 사용하세요.\n- 허용된 출처를 설정하도록 웹 서버 구성을 업데이트하세요.\n\n⚠️ 앱과 API가 서로 다른 도메인에 위치하는 경우, API 쿠키의 sameSite 매개변수를 Lax 또는 None으로 설정해야 합니다.\n\nSymfony 앱에서 lexik/LexikJWTAuthenticationBundle을 사용하는 경우 예시가 아래에 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```yaml\nlexik_jwt_authentication:\n  secret_key: '%env(resolve:JWT_SECRET_KEY)%'\n  public_key: '%env(resolve:JWT_PUBLIC_KEY)%'\n  pass_phrase: '%env(resolve:JWT_PASSPHRASE)%'\n\n  token_extractors:\n    cookie:\n      enabled: true\n      name: BEARER\n  set_cookies:\n    BEARER:\n      # Update here to set strict, lax or none\n      samesite: none\n```\n\n# 로그인 후 리소스 가져오기\n\n우리는 login 및 홈페이지로 리디렉트를 처리하는 logUserIn() 메서드를 포함하는 custom hookuserAuth()를 구현할 것입니다.\n\n그리고 예를 들어 홈페이지에서 API 호출을 하게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\nAuthProvier를 구현했습니다.\n\n```js\nimport { Context, ReactNode, createContext, useContext, useState } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\n\ntype AuthContextType = {\n  isAuthenticated: boolean;\n  logUserIn: () => void;\n};\n\ntype AuthContextPropsType = {\n  children: ReactNode;\n};\n\nconst AuthContext: Context<AuthContextType | null> =\n  createContext<AuthContextType | null>(null);\n\nexport const AuthProvider = ({ children }: AuthContextPropsType) => {\n  const [isAuthenticated, setIsAuthenticated] = useState<boolean>(false);\n  const navigate = useNavigate();\n\n  const logUserIn = () => {\n    // 예시를 위해 prop을 설정했지만 여기서 더 많은 작업이 필요합니다\n    setIsAuthenticated(true);\n    // 홈페이지로 리디렉션\n    navigate(\"/\");\n  };\n\n  return (\n    <AuthContext.Provider value={{ isAuthenticated, logUserIn }}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = () => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error(\n      \"useAuth는 AuthProvider 내에서 사용되어야 합니다. 애플리케이션의 최상위 수준에 AuthProvider를 렌더링하는지 확인해주세요.\"\n    );\n  }\n\n  return context;\n};\n```\n\n여기서 우리는 무엇을 했나요?\n\n사용자 로그인 상태를 관리하고 앱 전체에서 이 상태에 액세스하고 업데이트할 수 있는 방법을 제공하기 위해 인증 컨텍스트를 설정했습니다.\n\n<div class=\"content-ad\"></div>\n\n인증 로직의 중앙 처리를 가능하게 합니다. 사용자가 한 번 로그인하면 자동으로 홈페이지로 리디렉션됩니다.\n\n## 홈페이지에서 리소스 가져오기\n\n```js\nimport { useQuery } from 'react-query';\nimport { UseQueryResult, useQuery } from \"@tanstack/react-query\";\nimport apiClient from './apiClient';\n\ntype ApiResponse = {\n  message: string;\n};\n\nexport default function HomeView() {\n  const query = useQuery<ApiResponse, Error>({\n    queryKey: [\"unique_name_example\"],\n    queryFn: async () => {\n      const response = await apiClient.get<ApiResponse>(\"/test\", {\n        withCredentials: true,\n      });\n      return response.data;\n    },\n  });\n  const { data, isFetching, isError, error }: UseQueryResult<ApiResponse, Error> = query;\n\n  return (\n    <>\n      <h1>여기는 API에서 온 메시지입니다</h1>\n      {isFetching && <div>로딩 중</div>}\n      {isError && <div>오류가 발생했습니다: {error?.message}</div>}\n      {!isError && !isFetching && <div>{JSON.stringify(data)}</div>}\n    </>\n  );\n}\n\nexport default Home;\n```\n\n여기서는 API에서 리소스를 가져오기 위해 전통적인 쿼리를 수행했고, credentials 구성도 설정했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n{ withCredentials: true }\n```\n\n이를 통해 세션이 유지됩니다.\n\n이것을 제거하면 멋진 401 Unauthorized HTTP 응답을 받게 될 거에요.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:996/1*aY_QKlVYUqtW2JmHjFaO1g.gif\" />\n\n<div class=\"content-ad\"></div>\n\n# 이어서\n\n- HttpOnly 쿠키는 XSS 공격으로부터 세션 토큰을 보호하여 앱의 보안을 강화합니다.\n- CORS를 적절하게 처리하고 SameSite 매개변수를 도메인 설정에 따라 설정하는 것을 기억하세요.\n- 마지막으로, API 호출에서 withCredentials를 true로 설정하면 세션이 유지됩니다.\n\n그리고 이로써 이 주제에 대한 내용이 마무리되었습니다.\n\n도움이 되었으면 좋겠습니다. 가능한 더 효율적으로 만들려고 노력했지만, 중요하지 않다고 생각하는 것은 생략했습니다.","ogImage":{"url":"/assets/img/2024-06-22-UsehttpOnlycookieToSecureYourReactApp_0.png"},"coverImage":"/assets/img/2024-06-22-UsehttpOnlycookieToSecureYourReactApp_0.png","tag":["Tech"],"readingTime":7},{"title":"React 컴파일러 발견 최적화된 React 마법 탐험하기","description":"","date":"2024-06-22 03:09","slug":"2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic","content":"\n\n안녕하세요, React 열정가 여러분! 오늘은 새로운 React 컴파일러에 관한 흥미로운 소식을 공유하려고 해요. React 팀에서 나온 이 편리한 도구는 React 앱을 자동으로 최적화해줍니다. 함께 React 컴파일러가 무엇인지, 시작하는 방법, 그리고 한번 시도해볼 가치가 있는 이유에 대해 알아보려고 해요.\n\n# 공사 중 🚧\n\n우선, React 컴파일러에 대한 문서 작업은 아직 진행 중입니다. 자세한 내용은 React 컴파일러 작업 그룹 레포를 확인해주세요. 하지만 지금은 전반적인 내용을 살펴볼까요?\n\n# React 컴파일러란?\n\n<div class=\"content-ad\"></div>\n\nReact Compiler은 빌드 시간에 React 앱을 최적화하기 위해 설계된 실험적인 도구입니다. 커뮤니티로부터 피드백을 모으기 위해 오픈 소스로 제공되며 일반 JavaScript와 완벽하게 작동합니다. 최고의 점은 기존 코드를 다시 작성할 필요가 없다는 것입니다.\n\n그러나 React Compiler를 사용하려면 React 19 RC가 필요합니다. 이전 버전에 머물러 있으면 해결책이 있지만 업그레이드하는 것이 가장 좋습니다.\n\n# 컴파일러는 무엇을 하는가?\n\n간단히 말해, React Compiler는 코드를 자동으로 메모이즈합니다. useMemo, useCallback 또는 React.memo를 사용해 본 적이 있다면 메모이제이션의 강력함을 알고 있을 것입니다. 컴파일러는 이를 자동으로 수행하여 효율적인 업데이트를 보장하며 별다른 노력없이 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n# Vite를 이용한 React 컴파일러 설정:\n\nReact 컴파일러를 Vite와 통합하는 것은 프로젝트의 성능을 크게 향상시킬 수 있는 간단한 과정입니다. 이 설정에서는 React 컴파일러를 쉽게 통합할 수 있는 방법을 보여주기 위해 샘플 프로젝트를 만들 것입니다. 이 설정은 Vite로 구동되는 React 앱에 React 컴파일러가 가져다주는 효율성과 속도 향상의 잠재적인 개선 사항을 보여줄 것입니다.\n\n# 필수 조건\n\n이전 버전과 호환되지 않으니 React 19 RC 이상을 사용하는지 확인해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 설치 및 설정\n\n- 새로운 Vite 프로젝트를 만들기:\n\n가장 먼저, 새로운 Vite 프로젝트를 만들어 봅시다. 터미널을 열고 다음 명령을 실행해 주세요:\n\n```js\nnpm create vite@latest react-beta-test\n```\n\n<div class=\"content-ad\"></div>\n\n2. React 19 Beta 설치하기:\n\n이제 방금 만든 디렉토리로 이동해서 React 19 Beta를 설치해봅시다.\n\n```js\ncd react-beta-test\nnpm install react@beta react-dom@beta\n```\n\n<div class=\"content-ad\"></div>\n\nTypeScript 팬 여러분, 여기 한 가지 팁이 있습니다. 모든 것이 조화롭게 맞물리도록 package.json 파일을 조금 조정해야 합니다.\n\n```js\n\"dependencies\": {\n  \"@types/react\": \"npm:types-react@alpha\",\n  \"@types/react-dom\": \"npm:types-react-dom@alpha\",\n  \"react\": \"^19.0.0-beta-94eed63c49-20240425\",\n  \"react-dom\": \"^19.0.0-beta-94eed63c49-20240425\"\n},\n\"overrides\": {\n  \"@types/react\": \"npm:types-react@alpha\",\n  \"@types/react-dom\": \"npm:types-react-dom@alpha\"\n}\n```\n\n- Babel Plugin 설치:\n- 다음으로, React 컴파일러를 활성화할 Babel 플러그인을 설치해야 합니다. 다음 명령어를 실행해주세요:\n\n```js\nnpm install babel-plugin-react-compiler\n```\n\n<div class=\"content-ad\"></div>\n\n2. Vite 구성에 React 컴파일러 플러그인을 추가해보세요:\n\n마지막으로, Vite가 React 컴파일러 플러그인을 사용하도록 구성해 봅시다. vite.config.js 파일을 열고 다음 구성을 추가하세요:\n\n```js\n// vite.config.js\nReactCompilerConfig = {};\n\nexport default defineConfig(() => {\n  return {\n    plugins: [\n      react({\n        babel: {\n          plugins: [\n            [\"babel-plugin-react-compiler\", ReactCompilerConfig],\n          ],\n        },\n      }),\n    ],\n  };\n});\n```\n\n# 파트 1: 컴파일러 및 useMemo 없이\n\n<div class=\"content-ad\"></div>\n\n간단한 앱을 두 가지 상태로 가정해 봅시다: 숫자(n)와 카운터. 1부터 n까지 숫자의 합을 계산할 겁니다. useMemo 없이 이 계산은 컴포넌트가 다시 렌더링될 때마다 발생하게 됩니다. 카운터만 변경된 경우에도 그렇죠. 무엇이 발생하는지 확인해 볼까요? 함께 알아봐요!\n\n# 컴포넌트 설정하기\n\n우선, 두 개의 상태와 합을 계산하는 함수로 컴포넌트를 설정해 보겠습니다. App.jsx 파일의 코드를 바꿔서 결과를 확인해 보세요. (\"use no memo\"를 사용해서 컴파일러가 자동으로 메모이제이션하지 않게 합니다)\n\n```js\n\"use no memo\";\nimport React, { useState } from 'react';\nconst App = () => {\n  const [number, setNumber] = useState(1);\n  const [counter, setCounter] = useState(0);\n  const calculateSum = (n) => {\n    console.log('합을 계산 중...');\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n      sum += i;\n    }\n    return sum;\n  };\n  const sum = calculateSum(number);\n  return (\n    <div>\n      <h1>1부터 {number}까지의 합: {sum}</h1>\n      <button onClick={() => setNumber(number + 1)}>숫자 증가</button>\n      <button onClick={() => setCounter(counter + 1)}>카운터 증가</button>\n      <p>카운터: {counter}</p>\n    </div>\n  );\n};\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\n# 불필요한 재렌더링 관찰\n\n이 설정에서는 \"Increment Counter\" 버튼을 클릭할 때마다 숫자가 변경되지 않았음에도 불구하고 calculateSum 함수가 실행됩니다. 콘솔을 확인해보세요 - 매번 \"Calculating sum...\"이 기록되는 것을 볼 수 있을 겁니다. 이것은 비효율적입니다! 숫자가 변경되지 않았다면 sum을 다시 계산하고 싶지 않습니다.\n\n# 파트 2: 컴파일러 없이 useMemo 사용하기\n\n여기서 마법이 벌어집니다. 숫자를 종속성으로 전달하여 calculateSum 호출을 useMemo로 감싸겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# useMemo 추가하기\n\n컴포넌트를 최적화해보죠. number가 변경될 때에만 계산이 발생하도록 useMemo를 사용해보세요.\n\n```js\n\"use no memo\";\nimport React, { useState, useMemo } from 'react';\nconst App = () => {\n  const [number, setNumber] = useState(1);\n  const [counter, setCounter] = useState(0);\n  const calculateSum = (n) => {\n    console.log('계산 중...');\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n      sum += i;\n    }\n    return sum;\n  };\n  const sum = useMemo(() => calculateSum(number), [number]);\n  return (\n    <div>\n      <h1>1부터 {number}까지의 합: {sum}</h1>\n      <button onClick={() => setNumber(number + 1)}>숫자 증가</button>\n      <button onClick={() => setCounter(counter + 1)}>카운터 증가</button>\n      <p>카운터: {counter}</p>\n    </div>\n  );\n};\nexport default App;\n```\n\n# 최적화 즐기기\n\n<div class=\"content-ad\"></div>\n\n이제 useMemo가 적용되어 있어서 calculateSum 함수는 숫자가 변경될 때만 실행됩니다. 한 번 시도해보세요! \"Increment Counter\" 버튼을 클릭하고 콘솔을 확인해보세요. 불필요한 \"Calculating sum...\" 메시지가 사라졌죠. 높은 다섯! 🖐\n\n# 파트 3: 컴파일러와 함께\n\n상상해보세요: 프로젝트를 작업 중인데 useMemo를 추가하는 것을 깜빡했습니다. 걱정하지 마세요! 우리 마법같은 React 컴파일러가 자동으로 추가해 줍니다. 어떻게 작동하는지 보겠습니다. (우리는 \"use no memo\"를 사용하지 않기 때문에 컴파일러가 자체적으로 동작합니다)\n\n# 마법 같은 컴파일러 동작 방식\n\n<div class=\"content-ad\"></div>\n\n리액트 컴파일러를 사용하면, useMemo 없이 코드를 작성해도 컴포넌트가 자동으로 최적화됩니다. 다시 원본 코드를 확인해보겠습니다:\n\n```js\nimport React, { useState } from 'react';\nconst SumComponent = () => {\n  const [number, setNumber] = useState(1);\n  const [counter, setCounter] = useState(0);\n  const calculateSum = (n) => {\n    console.log('Calculating sum...');\n    let sum = 0;\n    for (let i = 1; i <= n; i++) {\n      sum += i;\n    }\n    return sum;\n  };\n  const sum = calculateSum(number);\n  return (\n    <div>\n      <h1>Sum from 1 to {number}: {sum}</h1>\n      <button onClick={() => setNumber(number + 1)}>Increment Number</button>\n      <button onClick={() => setCounter(counter + 1)}>Increment Counter</button>\n      <p>Counter: {counter}</p>\n    </div>\n  );\n};\nexport default SumComponent;\n```\n\n# 최고 수준의 자동 최적화\n\n![image](/assets/img/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic_0.png)\n\n<div class=\"content-ad\"></div>\n\n컴파일러의 마법 덕분에 이 코드는 자동으로 변경되어 useMemo을 포함하여 효율적인 다시 렌더링을 보장해줍니다. 우리는 손가락 한 번 까딱하지 않아도 됩니다! 컴파일러는 필요한 곳에 useMemo를 추가하여 컴포넌트를 최적화합니다. 콘솔을 다시 확인해보세요 – \"Calculating sum...\" 메시지가 필요없어졌죠. 마치 성능 요정이 어깨에 앉아 있는 느낌이에요! 🧚‍♂️\n\n# 해볼 가치가 있을까요?\n\nReact 컴파일러는 아직 실험 단계이며 베타 버전으로, 완전히 제품으로 출시되지는 않았습니다. Meta에서 이미 사용 중이지만, 여러분의 앱에 적합한지 여부는 코드가 React의 규칙을 얼마나 잘 준수하는지에 달려 있습니다.\n\n컴파일러를 더 작은 프로젝트나 앱의 일부분에서 실험하는 것이 전체 앱에서 시도하는 것보다 좋은 아이디어입니다.\n\n<div class=\"content-ad\"></div>\n\n# 마무리하며\n\nReact 컴파일러는 React 앱의 성능을 최적화해줄 것으로 기대되는 흥미로운 새로운 도구입니다. 아직 개발 중이고 베타 버전이지만, 앱 성능을 향상시키려는 열정을 가지고 있다면 탐색할 가치가 있습니다. 한번 시도해보고 생각을 공유해보세요!\n\n이 개요가 React 컴파일러에 대해 흥미를 느끼게 해주기를 바랍니다. 궁금한 점이나 의견이 있으시면 언제든 댓글로 남겨주세요. 즐거운 코딩 되세요! 🎉","ogImage":{"url":"/assets/img/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic_0.png"},"coverImage":"/assets/img/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic_0.png","tag":["Tech"],"readingTime":7},{"title":"TypeScript로 React의 forwardRef 완벽 마스터하기","description":"","date":"2024-06-22 03:08","slug":"2024-06-22-MasteringforwardRefinReactwithTypeScript","content":"\n\n부모 컴포넌트에서 자식 컴포넌트의 DOM 요소에 액세스하거나 메서드를 호출합니다.\n\n![이미지](/assets/img/2024-06-22-MasteringforwardRefinReactwithTypeScript_0.png)\n\n## 소개\n\nReact에서 참조(refs)를 처리하고 부모 컴포넌트가 자식 컴포넌트와 상호 작용하는 것은 까다로울 수 있습니다. 다행스럽게도, React의 forwardRef 기능을 사용하면 이러한 상호작용을 효율적으로 관리할 수 있는 좋은 방법을 제공합니다. TypeScript와 함께 사용될 때, forwardRef는 컴포넌트간의 통신을 더 원활하게 만들뿐만 아니라 코드 안전성과 유지 보수의 용이성을 향상시킵니다. 이 안내서에서는 TypeScript와 함께 forwardRef를 사용하는 방법을 살펴보고, 실용적인 예제를 보여주며 최상의 사용 사례에 대한 팁을 공유할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## forwardRef 이해하기\n\nReact에서 forwardRef를 사용하면 참조(ref)를 한 컴포넌트를 통해 바로 해당 컴포넌트의 자식 컴포넌트로 전달할 수 있습니다. 이 기술은 특히 부모 컴포넌트에서 자식 컴포넌트의 DOM 요소에 직접 액세스하거나 메소드를 호출하는 데 유용합니다.\n\n## TypeScript와 함께 사용하는 기본 구문\n\n```js\nimport { forwardRef } from 'react';\n\nconst MyComponent = forwardRef((props, ref) => {\n  return <button ref={ref} onClick={props.onClick}>Click Me!</button>;\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# TypeScript를 이용한 간단한 예제\n\n자식 구성 요소에서 DOM 요소에 액세스하기 위해 forwardRef를 사용하는 간단한 사용 사례를 보여드립니다.\n\n## forwardRef를 사용한 자식 구성 요소\n\n```js\nimport { forwardRef } from 'react';\n\nconst TextInput = forwardRef<HTMLInputElement, { placeholder: string }>(\n  (props, ref) => {\n    return <input ref={ref} type=\"text\" placeholder={props.placeholder} />;\n  }\n);\n```\n\n<div class=\"content-ad\"></div>\n\n## 부모 컴포넌트가 자식의 DOM 노드에 액세스하는 방법\n\n```js\nimport { useRef, useEffect } from 'react';\n\nconst App: React.FC = () => {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    inputRef.current?.focus();\n  }, []);\n\n  return <TextInput ref={inputRef} placeholder=\"Focus on me\" />;\n};\n```\n\n이 예제에서 부모 컴포넌트는 TextInput 컴포넌트에 포커스를 맞추며, DOM 요소를 조작하기 위해 forwardRef를 간단하게 활용한 것을 보여줍니다.\n\n# 고급 사용법: 자식 컴포넌트 메서드 노출\n\n<div class=\"content-ad\"></div>\n\n더 복잡한 시나리오는 자식 컴포넌트 메서드를 부모에 노출하는 것을 포함합니다. 이것이 forwardRef가 진정으로 빛을 발하는 곳이며, 특히 useImperativeHandle과 함께 사용할 때 빛을 발합니다.\n\n## 노출된 메서드를 가진 자식 컴포넌트\n\n이 시나리오에서는 onClick 메서드를 노출하는 버튼이 있습니다. 이 메서드는 부모 컴포넌트에서 트리거될 것입니다.\n\n```js\nimport { forwardRef, useImperativeHandle } from \"react\";\n\ninterface ChildProps {}\n\n/**\n * 부모 컴포넌트에 노출될 인터페이스입니다.\n */\nexport interface ChildRef {\n  onClick: () => void;\n}\n\nexport const ChildComponent = forwardRef<ChildRef, ChildProps>((props, ref) => {\n  const onClick = () => {\n    alert(\"자식 컴포넌트의 버튼이 클릭되었습니다!\");\n  };\n\n  /**\n   * `onClick` 함수를 부모 컴포넌트에 노출합니다.\n   */\n  useImperativeHandle(ref, () => ({\n    onClick,\n  }));\n\n  return <button onClick={onClick}>알림 표시하기!</button>;\n});\n```\n\n<div class=\"content-ad\"></div>\n\n## 자식을 제어하는 부모 컴포넌트\n\n부모 컴포넌트에서는 자식 컴포넌트의 `onClick` 메서드를 트리거할 것입니다. 여기서는 또한 `ChildRef`를 사용하여 ref의 타입을 지정합니다.\n\n```js\nimport { useRef } from \"react\";\n\nimport { ChildComponent, ChildRef } from \"../child\";\n\nexport const App: React.FC = () => {\n  const childRef = useRef<ChildRef>(null);\n\n  const triggerChild = () => {\n    childRef.current?.onClick();\n  };\n\n  return (\n    <div className=\"app\">\n      <header>\n        forwardRef의 사용법을 보여줍니다.{\" \"}\n        <a onClick={triggerChild}>여기를 클릭</a>하여 자식 컴포넌트의 버튼을 클릭하는 이벤트를 발생시킵니다.\n      </header>\n\n      <div className=\"child\">\n        <ChildComponent ref={childRef} />\n      </div>\n    </div>\n  );\n};\n```\n\n이 섹션은 TypeScript에서 `forwardRef`와 `useImperativeHandle`를 결합하여 자식 컴포넌트의 동작을 제어하는 방법을 보여줍니다. 이 패턴을 사용하여 아코디언을 토글하거나 모달을 열기와 같은 다양한 기능을 구현할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nGitHub 레포지토리에서 고급 예제의 완전한 소스 코드를 찾아볼 수 있습니다: [https://github.com/mattdeveloper/mastering-react-forward-ref](https://github.com/mattdeveloper/mastering-react-forward-ref)\n\n# forwardRef를 사용한 컴포넌트 타입 지정\n\nTypeScript에서 forwardRef를 사용할 때, props와 refs에 알맞은 유형을 정의하여 타입 안정성을 보장하는 것이 매우 중요합니다.\n\n## 유형 정의\n\n<div class=\"content-ad\"></div>\n\n컴포넌트의 props와 ref를 명확히하려면 먼저 각각의 타입을 정의해야 합니다.\n\n```js\ninterface MyComponentProps {\n  label: string;\n}\n\ninterface MyComponentRef {\n  focus: () => void;\n}\n```\n\n## 타입 구현하기\n\n정의된 타입을 사용하여 forwardRef를 이용해 컴포넌트를 구현하세요. 이렇게 하면 props와 ref가 명시된 타입에 따라 작동하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst MyComponent = forwardRef<MyComponentRef, MyComponentProps>((props, ref) => {\n  const internalRef = useRef<HTMLInputElement>(null);\n\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      internalRef.current?.focus();\n    },\n  }));\n\n  return <input ref={internalRef} aria-label={props.label} />;\n});\n```\n\n# 소스 코드\n\n여기 고급 예제의 완전한 소스 코드가 포함된 GitHub 리포지토리가 있습니다: https://github.com/mattdeveloper/mastering-react-forward-ref\n\n# 최고의 사례와 고려 사항\n\n<div class=\"content-ad\"></div>\n\n컴포넌트에서 forwardRef를 활용할 때, 특히 TypeScript와 함께 사용할 때는 다음과 같은 모범 사례를 고려해보세요:\n\n- forwardRef를 사용하는 경우는 자식 컴포넌트의 DOM 노드나 메서드에 직접 액세스해야 할 때에만 사용하세요.\n- useImperativeHandle을 활용하여 자식 컴포넌트의 필요한 기능만 노출시켜 컴포넌트의 API를 깔끔하고 명시적으로 유지하세요.\n- 중첩된 컴포넌트나 forwardRef를 다룰 때 특히 ref를 올바르게 전파하세요.\n\n# 결론\n\n특히 TypeScript와 함께 사용할 때 forwardRef는 React 컴포넌트의 유연성, 재사용성, 유형 안정성을 향상시키는 강력한 방법을 제공합니다. 사용 패턴과 모범 사례를 이해하면 더 유지보수하기 쉽고 견고한 React 애플리케이션을 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-MasteringforwardRefinReactwithTypeScript_0.png"},"coverImage":"/assets/img/2024-06-22-MasteringforwardRefinReactwithTypeScript_0.png","tag":["Tech"],"readingTime":5},{"title":"동적이고 확장 가능한 마이크로 프런트엔드 모듈 페더레이션 사용 방법","description":"","date":"2024-06-22 03:06","slug":"2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation","content":"\n\n![DynamicScalableMicro-FrontendswithModuleFederation_0](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_0.png)\n\n안녕하세요! \n\nKredX는 내국 (인보이스 할인) 및 국제 (글로벌 무역 금융 거래소)에서 접근성을 보장하는 공급망 금융(SCF) 플랫폼입니다.\n\n인도의 중소기업 및 중소기업(MSME) 부문의 급속한 성장을 고려해, KredX는 이 섹터의 모든 금융 요구에 대한 일괄 해결책으로 나타났습니다. 우리는 SCF 및 현금 관리 솔루션(CMS) SaaS 생태계의 다양한 측면에서 빠르게 발전하고 있습니다.\n\n성장에는 주의가 필요합니다!\n비즈니스의 보다 광범위한 요구를 충족하기 위해, 저희의 SCF 제품 중 하나인 인보이스 할인(ID)의 코드베이스는 거대한 단일체(monolith)가 되었으며, 이로 인해 개발자의 생산성을 저해하고 독자적인 변경이 적게 유연해졌습니다.\n\n<div class=\"content-ad\"></div>\n\n마크다운 포맷으로 위의 텍스트를 번역하겠습니다.\n\n![이미지](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_1.png)\n\n매일 개발하는 것이 얼마나 어려워졌는지 이해하는 데 도움이 되었으면 좋겠습니다. 우리의 ID 프론트엔드 코드 빌드 시간이 거의 50-55분이 걸리고, 프로젝트를 로컬에서 실행하는 데 약 8-12분이 소요됩니다.\n\n오늘날, 프로젝트는 너무 끌려다붙었다고 할 정도로 심각해졌는데, 우리의 단일 내부 모듈 중 하나에 문제가 발생하면 전체 앱에 영향을 줄 수도 있습니다(무하랏 모듈의 단일 문제가 금융가 및 관리자 대시보드 전체를 다운시키는 문제가 발생) 그리고 때로는 여러 제품에도 영향을 미칠 수 있습니다(재사용할 수 없는 인증 과정으로 인해 여러 제품에 영향을 미침).\n\n기존 단일체 아키텍처의 고통\n코드베이스가 커짐에 따라 여러 문제가 시작되었습니다:\n\n<div class=\"content-ad\"></div>\n\n- 빌드 시간이 길어짐: 코드베이스의 크기가 커지면 개발 서버를 시작하는 데와 HMR이 개발자 변경 사항을 반영하는 데 더 오래 걸립니다.\n- 높은 인지 부담: 여러 앱의 코드가 동일한 저장소에 있기 때문에, 개발자가 이해해야 하는 코드 영역이 증가하여 개발자의 인지 부담이 커집니다.\n- 단일 장애점: 모놀리스의 어떤 부분에서 버그가 발생하면 전체 애플리케이션을 다운시키는 결과를 가져옵니다. 즉, 모든 다양한 사용자 설정이 영향을 받아 신뢰성이 떨어지고 수동 및 자동화된 테스트에 더 많은 부담이 생깁니다.\n- 독립적인 CI/CD 부재: 금융 자금 할인용으로 사용되는 동일한 ID 코드베이스가 운영자용 대시보드, IPA용 대시보드, GTX용 인증 흐름, KredX Financier 앱에 대한 일반 코드, 그리고 그 이외 많은 곳에도 사용됩니다. 한 모듈의 작은 변경이 전체 코드베이스의 배포를 필요로 합니다.\n\n우리에게는 코드베이스를 더 작고 독립적인 모듈로 분리할 수 있는 해결책이 필요하다는 점이 매우 명확했습니다. 각 모듈은 유연하여 매끄럽게 플러그인하고 플러그아웃할 수 있어야 하며, 개발, 테스트 및 배포를 독립적으로 수행할 수 있어야 합니다.\n\n기술적인 탐색은 이곳에서 시작됩니다.\n동적이고 확장 가능한 솔루션을 찾기 위한 연구\n\n해당 솔루션에 대한 고민에 들어가기 전에 솔루션이 어떻게 보일지에 대한 몇 가지 기준을 결정했습니다:\n\n<div class=\"content-ad\"></div>\n\n- 좋은 개발자 경험: 이 솔루션은 전반적인 개발자 경험을 향상시켜야 합니다.\n- 최소한의 아키텍처 변경: 기존 웹 아키텍처에 급격한 수정이 필요하지 않아야 합니다.\n- 구성의 용이성: 솔루션을 비교적 쉽게 구성할 수 있어야 합니다.\n- 점진적인 학습 곡선: 개발자들에게 순차적인 학습 곡선을 가지며 빠른 도입을 용이하게 해야 합니다.\n- 미래 기술 이전: 미래 기술 이전을 위해 솔루션을 쉽게 분리할 수 있어야 합니다.\n- 커뮤니티 지원 및 미래 비전: 강력한 커뮤니티 지원과 미래 비전을 가져야 합니다.\n\n다양한 접근법\n문제를 자세히 고려하여, 우리는 몇 가지 실행 가능한 접근법을 식별했습니다:\n\n![Dynamic Scalable Micro-Frontends with Module Federation](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_2.png)\n\n우리가 시도한 솔루션 중에, Module Federation과 Monorepo가 모든 영역을 충족하고 그 이상을 제공하는 솔루션이라는 것을 발견했습니다.\n\n<div class=\"content-ad\"></div>\n\n결국, 모듈 페더레이션이 무엇인가요?\n믿어봐요, 기다릴 가치가 있어요!\n\n모듈 페더레이션은 Webpack 및 Rspack의 고급 기능으로, JavaScript 애플리케이션을 분산화하는 아키텍처 패턴을 제공하여 (서버 측의 마이크로서비스와 유사하게) 다른 애플리케이션(또는 마이크로 프론트엔드)로부터 코드를 동적으로 로드할 수 있는 방법을 제공합니다. 이는 다음과 같은 이점을 제공할 수 있어요:\n\n- 코드 중복 감소\n- 코드 유지 관리성 향상\n- 애플리케이션 전체 크기 감소\n- 애플리케이션 성능 향상\n\n모듈 페더레이션의 주요 요소\n모듈 페더레이션 애플리케이션에서는 이해해야 할 여러 요소가 있지만, 아키텍처를 설명할 수 있는 3가지 요소가 있어요:\n\n<div class=\"content-ad\"></div>\n\n- 호스트 또는 셸: 이름 그대로, 이것은 여러 연합된 원격 모듈과 결합될 수 있는 컨테이너입니다. (그 자체가 연합된 모듈임)\r\n- 원격: 자바스크립트, 기본 값, 복잡한 값 또는 전체 모듈 모두 일 수 있습니다. 원격에서 노출하고자 하는 내용은 무엇이든 될 수 있습니다. 기본적으로 이러한 원격 모듈은 최종 조각을 만들기 위해 셸 안에 결합됩니다.\r\n- 공유 의존성: 다른 원격들 간에 공유되는 패키지/라이브러리와 같은 종속성입니다. 이로 인해 중복이 줄어들고 코드 크기도 작아집니다.\n\n모든 이러한 설정은 웹팩 구성 내에서 이루어집니다.\n\n![이미지1](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_3.png)\n\n![이미지2](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_4.png)\n\n<div class=\"content-ad\"></div>\n\n여러 가지 방법으로 모듈 연합을 활용할 수 있습니다.\n연합 모듈을 사용하는 방법에는 다음과 같은 다양한 유연성이 있습니다.\n\n- 도메인 수준: 여기에 각 연합 모듈은 별도의 도메인에 호스팅되어 독립적으로 사용됩니다.\n- 위젯/컴포넌트 수준: 이 방법을 통해 어떤 앱에서든 다른 앱으로부터 어떤 위젯(예: 작은 코드 조각)을 추가할 수 있습니다.\n- 하이브리드 수준: 첫 번째와 두 번째 방법을 함께 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_5.png)\n\n저희는 우리의 요구에 하이브리드 방법을 선택했습니다. 이곳에서 호스트는 여러 마이크로 프론트엔드(원격)간의 탐색 로직 뿐만 아니라 루트의 지연 로딩도 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 다양한 리모트들 사이에서 모든 공통 유틸, 컴포넌트, 훅 등을 처리하는 일반 위젯/컴포넌트 페더레이티드 모듈도 만들었습니다.\n\n그저 하나의 웹팩 플러그인을 추가하면 끝이라고요? 그 답은: 네와 아니요 둘 다!\n\n네, 의심의 여지가 없이 이것은 극적인 변화를 일으키지 않으며, 모듈을 레고처럼 간단하게 만들어 코드베이스에 쉽게 꽂아 넣고 뺄 수 있게 만들어 줍니다. 게다가, 다른 웹팩 플러그인 옆에 앉아서 단순히 연결하기만 하면 됩니다.\n\n하지만, 아니요, 저희 팀이 이를 해결하느라 겪은 일부 고통스러운 문제가 있었습니다. 주요 문제로는 오류 처리, 버전 리소스 및 버전 관리, HMR, 타입 안전성 등이 있었어요.\n\n<div class=\"content-ad\"></div>\n\n각각의 내부 요구사항과 접근법에 따라 이 문제에 대한 여러 가지 다른 방법을 얻을 수 있습니다. 간단히 말씀드리면, 오늘은 가장 일반적이고 귀찮은 문제인 Type-Safety에 대해 이야기해 볼 거예요. 우리는 개발자가 로컬에서 코드를 작성할 때 타입 안전성과 자동 완성을 원하며, 추가로 타입 확인을 실행하여 TS 오류가 없는지 확인하고 싶어해요.\n\n타입 안전성을 되찾아보자!\n\n우리는 모노 저장소 구조를 사용하기 때문에 생성된 .d.ts 파일들을 참조하려고 노력했어요. 작동은 했지만 모노 저장소 구조와 결합되었고 외부 모듈에 독립적으로 사용할 수 없었어요.\n\n그 다음으로 시도한 것은 타입을 NPM 패키지로 내보내는 것이었지만 이 문제가 우리에게 큰 장애물이었어요.\n\n<div class=\"content-ad\"></div>\n\n마침내 확장 가능한 솔루션이다. 이 솔루션에는 웹팩 구성 내부에 다음 도구가 포함되어 있습니다.\n\n- dts-loader: 모든 d.ts 파일을 별도의 폴더에 생성하는 데 사용됨\n- ExternalTemplateRemotesPlugin: 원격지에서 생성된 타입 tar 파일을 다운로드함\n\n![이미지](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_6.png)\n\n기본적으로 자바스크립트와 함께 생성된 유형의 tar 파일을 번들링하며, 해당 원격지가 사용된 곳에서 ExternalTemplateRemotesPlugin을 통해 해당 파일을 다운로드합니다.\n\n<div class=\"content-ad\"></div>\n\n저희가 새로운 애플리케이션을 만들었는데 ID의 모든 경우/기능이 다 다뤄지지 않았기 때문에 이 결과는 사전 보드 결과와 비슷할 것입니다. 지금은 대략적인 방향을 얻을 수 있습니다;\n\n![이미지](/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_7.png)\n\n축하합니다! 성공하셨네요!\n의문이나 제안이 있으면 댓글에 남겨주세요. 또는 제 소셜 미디어 ID 중 하나로 메시지를 남겨주세요. 이처럼 도전을 해결하는 것을 즐기신다면, 저희 채용 페이지 https://www.kredx.com/join-our-team을 꼭 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_0.png"},"coverImage":"/assets/img/2024-06-22-DynamicScalableMicro-FrontendswithModuleFederation_0.png","tag":["Tech"],"readingTime":6},{"title":"실시간 성능 최적화 WebSockets와 Reactjs 통합하는 방법 Part I","description":"","date":"2024-06-22 03:04","slug":"2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI","content":"\n\n<img src=\"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_0.png\" />\n\n요즘에는 많은 양의 데이터가 있는데, 그것을 빨리 얻고 모든 것이 잘 작동하는 것이 정말 중요해요. 하지만 때로는 예전 방식(HTTP 요청)을 사용해서 계속해서 데이터를 요청하는 것은 오늘날 앱에는 충분히 빠르지 않을 수도 있어요. 그런 상황에서 WebSockets가 등장해요. WebSockets는 거의 즉시 업데이트를 보낼 수 있어 마치 마법 같은 기술이에요. 이를 통해 최신 정보를 곧바로 받아볼 수 있어요.\n\n그리고 React와 함께 사용한다면, 실시간으로 정보를 얻는 새로운 방식이 열립니다. React는 정말 빠른데, 너무 많은 것을 변경하면 신중하지 않으면, 앱이 느려지거나 작동을 멈출 수도 있어요. 그래서 React에서 일어나는 변경 사항을 신중하게 다루는 것은 중요해요, 특히 WebSockets를 사용할 때는요.\n\n우선, 이를 최적화하지 않은 방법에 대해 먼저 이야기해볼게요. 나중에는 React와 WebSockets를 사용하는 최적화된 방법에 대해 더 깊이 탐구해볼 거에요. 기대해주세요, 우리는 응용 프로그램의 성능과 효율성을 극대화하기 위한 WebSockets를 활용하는 최상의 방법에 대해 탐구할 거예요.\n\n<div class=\"content-ad\"></div>\n\n# 먼저 WebSocket이란 무엇인가요? 웹소켓 이해하기\n\n웹소켓은 단일, 오래 지속되는 연결을 통해 전이편된 통신 채널을 제공합니다. 이를 통해 클라이언트(브라우저)와 서버 간 실시간 데이터 교환이 가능해집니다. 전통적인 HTTP 요청과는 달리 웹소켓은 클라이언트와 서버가 모두 통신을 시작할 수 있어 즉각적인 업데이트가 필요한 응용 프로그램에 이상적입니다.\n\n실시간 데이터 스트리밍의 장점\n\n- 효율성 향상: 웹소켓을 통해 데이터 업데이트가 원활해집니다. 한 번 연결되면 데이터가 지연 없이 흘러가며 지속적인 요청 시간을 제거합니다.\n- 즉각적인 업데이트: 웹소켓을 통해 즉각적으로 업데이트를 받을 수 있습니다. 시장 동향이나 암호화폐 가격 추이를 추적하는 경우에도 신속한 결정을 위해 항상 최신 정보를 얻을 수 있습니다.\n- 양방향 대화: 웹소켓을 이용하면 서버와 클라이언트가 즉각적으로 양방향 대화를 할 수 있습니다. 모두가 듣고 듣는 빠른 대화와 같아서 팀워크가 쉬워집니다.\n- 확장성: 데이터 요구가 증가함에 따라 웹소켓은 부하를 다룰 수 있습니다. 연결을 열어두기 때문에 많은 사용자가 있더라도 원활하게 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_1.png\" />\n\n# React에서 WebSockets 사용하기\n\n이제, 웹소켓의 강점을 React 애플리케이션으로 가져올 수 있는 \"react-use-websocket\"이라는 유용한 도구에 대해 이야기해보겠습니다. 이 라이브러리는 웹소켓을 React 컴포넌트에 통합하는 과정을 단순화하여 심지어 초보자들도 사용할 수 있게 해줍니다.\n\n\"react-use-websocket\"을 사용하면 WebSocket 연결을 쉽게 설정할 수 있고, 메시지를 보내고 받을 수 있으며, 연결 오류를 처리할 수 있습니다 - 모두 React 컴포넌트 내에서 가능합니다. 시작하는 방법은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 설치: 라이브러리를 설치하려면 npm 또는 yarn을 사용하여 다음과 같이 시작하세요:\n\n```js\nnpm install react-use-websocket\n```\n\n또는\n\n```js\nyarn add react-use-websocket\n```\n\n<div class=\"content-ad\"></div>\n\n2. 사용 방법: 설치한 후에는 React 컴포넌트에서 useWebSocket 훅을 가져와 사용할 수 있습니다. 아래는 기본 예제입니다:\n\n```js\nimport React from 'react';\nimport { useWebSocket } from 'react-use-websocket';\n\nconst MyComponent = () => {\n  const { sendMessage, lastMessage } = useWebSocket('wss://example.com/ws');\n\n  const handleClick = () => {\n    sendMessage('Hello, WebSocket!');\n  };\n\n  return (\n    <div>\n      <button onClick={handleClick}>메시지 보내기</button>\n      <p>최근 메시지: {lastMessage ? lastMessage.data : '없음'}</p>\n    </div>\n  );\n};\n\nexport default MyComponent;\n```\n\n이 예제에서는 'wss://example.com/ws'로 WebSocket 연결을 설정하기 위해 useWebSocket 훅을 사용하고 있습니다. sendMessage 함수를 사용하여 메시지를 보내고, lastMessage 객체를 사용하여 최근 받은 메시지를 표시합니다.\n\n3. 이벤트 처리: \"react-use-websocket\"은 onOpen, onMessage, onError, onClose와 같은 다양한 WebSocket 이벤트를 처리하는 훅을 제공합니다. 이러한 훅을 사용하여 UI를 업데이트하거나 오류를 기록하는 등 다양한 WebSocket 이벤트에 기반한 작업을 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst { sendMessage, lastMessage, readyState } = useWebSocket('wss://example.com/ws', {\n   onOpen: () => console.log('WebSocket connection opened!'),\n   onClose: () => console.log('WebSocket connection closed!'),\n   onError: (event) => console.error('WebSocket error:', event),\n   onMessage: (event) => console.log('Received message:', event.data),\n});\n```\n\n“리액트-유즈-웹소켓”을 사용하면 React 애플리케이션에 WebSocket을 쉽고 직관적으로 통합할 수 있습니다. 실시간 채팅 애플리케이션, 실시간 데이터 대시보드 또는 협업 도구를 구축하든, \"리액트-유즈-웹소켓\"을 사용하면 익숙한 React 환경에서 WebSocket의 강력함을 활용할 수 있습니다.\n\n# 좀 더 전체적인 예시를 살펴보겠습니다.\n\n이를 위해 cryptocompare와 같은 외부 웹소켓을 사용할 것인데, 그를 위해 무료 API 키를 생성하기 위해 계정을 생성해야 합니다. 자세한 지침은 여기를 참고하세요.\n\n<div class=\"content-ad\"></div>\n\nAPI 키를 받은 후 다음 패키지를 추가하겠습니다:\n\n```js\nnpm i react-use-websocket bootstrap react-bootstrap react-router-dom --save \n```\n\n또는\n\n```js\nyarn add react-use-websocket bootstrap react-bootstrap react-router-dom\n```\n\n<div class=\"content-ad\"></div>\n\n부트스트랩 패키지는 스타일링을 위한 것입니다.\n\n설치가 완료되면 Home.tsx 컴포넌트를 생성하겠습니다. 이 컴포넌트에는 입력 텍스트만 포함되어 있고 api 키를 제출하여 http://localhost:3000/dashboard로 리디렉션하고 api_key를 쿼리 매개변수로 추가할 것입니다.\n\n```js\nimport { useState } from \"react\";\nimport Modal from \"react-bootstrap/Modal\";\nimport Button from \"react-bootstrap/Button\";\nimport Form from \"react-bootstrap/Form\";\nimport { useNavigate } from \"react-router-dom\";\n\nconst Home = () => {\n  const [show, setShow] = useState(true);\n  const [apiKey, setApiKey] = useState(\"\");\n  const navigate = useNavigate();\n\n  const handleClose = () => setShow(false);\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setApiKey(e.target.value);\n  };\n\n  const handleSubmit = (e: React.SyntheticEvent) => {\n    e.preventDefault();\n    navigate(`/dashboard?api_key=${apiKey}`);\n  };\n  return (\n    <>\n      <Modal\n        show={show}\n        onHide={handleClose}\n        data-bs-theme=\"dark\"\n        style={{ color: \"white\" }}\n      >\n        <Modal.Header closeButton>\n          <Modal.Title>react use websocket</Modal.Title>\n        </Modal.Header>\n        <Modal.Body>\n          <Form onSubmit={handleSubmit}>\n            <Form.Group controlId=\"formBasicEmail\">\n              <Form.Label>Api key:</Form.Label>\n              <Form.Control\n                type=\"text\"\n                placeholder=\"Please provide api key\"\n                value={apiKey}\n                onChange={handleChange}\n              />\n            </Form.Group>\n          </Form>\n        </Modal.Body>\n        <Modal.Footer>\n          <Button variant=\"primary\" onClick={handleSubmit}>\n            Submit\n          </Button>\n        </Modal.Footer>\n      </Modal>\n    </>\n  );\n};\n\nexport default Home;\n```\n\nDashboard.tsx 컴포넌트에는 웹소켓 응답 객체를 위한 인터페이스를 생성해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n위의 코드를 한글로 번역하면 다음과 같습니다:\n\n```js\nexport interface CryptoMessage {\n  TYPE: string;\n  M: string;\n  FSYM: string;\n  TSYM: string;\n  F: string;\n  ID?: string;\n  TS?: string;\n  Q?: number;\n  P?: number;\n  TOTAL?: number;\n  RTS?: string;\n  CCSEQ?: number;\n  TSNS?: number;\n  RTSNS?: number;\n}\n```\n\n그리고 useWebSocket 훅을 호출하세요.\n\n```js\nconst { readyState, sendJsonMessage, lastJsonMessage } =\n    useWebSocket<CryptoMessage>(socketUrl, { share: true });\n```\n\n이제 readyState, sendJsonMessage, lastJsonMessage가 무엇인지 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\nReadyState:\n\n\"useWebSocket\" 훅에서 제공하는 readyState 속성은 현재 WebSocket 연결 상태를 나타냅니다. WebSocket 연결이 보류 중인지, 열린 상태인지, 닫히는 중인지 또는 닫힌 상태인지를 나타냅니다. readyState 속성은 다음 네 가지 값 중 하나를 가질 수 있는 정수 값입니다:\n\n- CONNECTING (0): 이 상태는 WebSocket 연결이 설정 중인 상태를 나타냅니다. useWebSocket 훅을 초기 호출하고 WebSocket 연결을 시작할 때 연결이 성공적으로 설정될 때까지 CONNECTING 상태로 진입합니다.\n- OPEN (1): 이 상태는 WebSocket 연결이 열려 있고 메시지를 보내고 받을 준비가 된 상태를 나타냅니다. 연결이 성공적으로 설정되면 OPEN 상태로 전환되어 클라이언트와 서버 간에 양방향 통신이 가능해집니다.\n- CLOSING (2): 이 상태는 WebSocket 연결이 닫히는 중인 상태를 나타냅니다. useWebSocket 훅에서 제공하는 closeWebSocket 함수를 사용하여 WebSocket 연결을 종료하면 닫히기 전에 CLOSING 상태로 진입합니다.\n- CLOSED (3): 이 상태는 WebSocket 연결이 닫힌 상태를 나타냅니다. 연결이 서버에 의해 닫히거나 클라이언트가 명시적으로 closeWebSocket 함수를 사용하여 연결을 닫으면 발생합니다. 연결이 닫힌 후에는 새 WebSocket 연결을 초기화할 때까지 CLOSED 상태로 유지됩니다.\n\n<div class=\"content-ad\"></div>\n\n\"useWebSocket\" 라이브러리 내의 useWebSocket 훅에서 제공하는 sendJsonMessage 함수는 WebSocket 연결을 통해 JSON 형식의 메시지를 보내는 데 유용한 유틸리티 함수입니다. 이 함수는 JavaScript 객체를 JSON 문자열로 직렬화하는 번거로운 작업을 추상화하여 구조화된 데이터를 WebSocket 서버로 보내는 프로세스를 간소화합니다.\n\nlastJsonMessage:\n\n\"useWebSocket\" 라이브러리 내의 useWebSocket 훅에서 제공하는 lastJsonMessage 속성은 WebSocket 연결을 통해 수신한 JSON 형식의 최근 메시지를 나타냅니다. 이 속성을 사용하면 React 컴포넌트 내에서 받은 마지막 메시지에 포함된 데이터에 액세스하고 처리할 수 있습니다.\n\n다음 코드는 현재 WebSocket 연결 상태를 UI에 표시합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nimport useWebSocket, { ReadyState } from \"react-use-websocket\";\r\nimport { useSearchParams } from \"react-router-dom\";\r\n\r\nexport interface CryptoMessage {\r\n  TYPE: string;\r\n  M: string;\r\n  FSYM: string;\r\n  TSYM: string;\r\n  F: string;\r\n  ID?: string;\r\n  TS?: string;\r\n  Q?: number;\r\n  P?: number;\r\n  TOTAL?: number;\r\n  RTS?: string;\r\n  CCSEQ?: number;\r\n  TSNS?: number;\r\n  RTSNS?: number;\r\n}\r\n\r\nconst Dashboard = () => {\r\n  const [searchParams] = useSearchParams();\r\n  const api_key = searchParams.get(\"api_key\");\r\n  const socketUrl = `wss://streamer.cryptocompare.com/v2?api_key=${api_key}`;\r\n  const { readyState, sendJsonMessage, lastJsonMessage } =\r\n    useWebSocket<CryptoMessage>(socketUrl, { share: true });\r\n\r\n  const connectionStatus = {\r\n    [ReadyState.CONNECTING]: \"연결 중\",\r\n    [ReadyState.OPEN]: \"열림\",\r\n    [ReadyState.CLOSING]: \"닫히는 중\",\r\n    [ReadyState.CLOSED]: \"닫힘\",\r\n    [ReadyState.UNINSTANTIATED]: \"미초기화\",\r\n  }[readyState];\r\n\r\n  return <>{connectionStatus} </>;\r\n};\r\n\r\nexport default Dashboard;\r\n```\r\n\r\n\"열림\" 상태를 받으면 WebSocket 서비스로 메시지를 보낼 수 있습니다.\r\n\r\n```js\r\nuseEffect(() => {\r\n    if (readyState === ReadyState.OPEN) {\r\n      sendJsonMessage({\r\n        action: \"SubAdd\",\r\n        subs: [\r\n          \"0~Coinbase~BTC~USD\",\r\n          \"0~Coinbase~BTC~EUR\",\r\n          \"0~Coinbase~ETH~USD\",\r\n          \"0~Coinbase~ETH~EUR\",\r\n        ],\r\n      });\r\n    }\r\n  }, [readyState, sendJsonMessage]);\r\n```\r\n\r\nsendJsonMessage 내에 있는 json 객체를 설명해보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n# 작업:\n\n- 해당 객체에는 값이 \"SubAdd\"인 action 속성이 포함되어 있습니다.\n- 이는 WebSocket 서버에서 수행할 작업이 새 데이터 스트림에 구독하는 것임을 나타냅니다.\n\n# 구독:\n\n- 해당 객체에는 subs라는 속성이 포함되어 있으며 구독 문자열의 배열을 보유합니다.\n- 각 구독 문자열은 클라이언트가 구독하려는 특정 데이터 스트림을 나타냅니다.\n- 각 구독 문자열의 형식은 \"0~'거래소'~'기초통화'~'견적통화'\"입니다. 여기서:\n- \"0\": 스트리밍 데이터에 대한 구독을 나타냅니다 (역사적 데이터와 대조됨).\n- '거래소': 데이터를 제공하는 거래소의 이름을 나타냅니다 (예: \"코인베이스\").\n- '기초통화': 거래 페어의 기초 통화를 나타냅니다 (예: 비트코인의 경우 \"BTC\", 이더리움의 경우 \"ETH\").\n- '견적통화': 거래 페어의 견적 통화를 나타냅니다 (예: 미국 달러의 경우 \"USD\", 유로의 경우 \"EUR\").\n\n<div class=\"content-ad\"></div>\n\n요약하자면, 이 코드는 WebSocket 서버에게 새로운 데이터 스트리밍을 위한 구독을 추가하도록 지시합니다. subs 배열에 지정된 구독은 Coinbase 거래소의 다양한 거래 페어를 대상으로 하며, BTC/USD, BTC/EUR, ETH/USD 및 ETH/EUR 등이 포함됩니다. 이를 통해 클라이언트가 WebSocket 서버로부터 이러한 거래 페어의 실시간 업데이트를 받을 수 있게 됩니다.\n\n이제 데이터를 가능한 한 빨리 받을 수 있게 되었으니, 남은 작업은 브라우저에 스트리밍 데이터를 표시하는 것 뿐입니다.\n\n```js\nconst renderList = () => {\n    return list.map((element: CryptoMessage, index: number) => {\n      return (\n        <li key={index}>\n          {element.FSYM} - {element.P}\n        </li>\n      );\n    });\n  };\n\nreturn <>{readyState === ReadyState.OPEN? renderList() : connectionStatus} </>;\n```\n\n각 요소에 대해, element.FSYM의 값 (암호화폐 심볼인지 ETH 또는 BTC인지)을 나타내는 JSX `li` 요소를 반환하고, 그 뒤에는 대시(-)와 element.P의 값(가격)을 나타냅니다. 결과는 다음과 같을 것입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_2](/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_2.png)\n\n우리 데이터를 그래프로 시각화하는 것이 훨씬 쉬울 것입니다. 이를 위해 react google charts를 설치해야 합니다.\n\n```js\nnpm install --save react-google-charts\n```\n\n또는\n\n\n<div class=\"content-ad\"></div>\n\n```js\nyarn add react-google-charts\n```\n\n이후에 Chart를 가져와서 renderList 함수를 renderGraph로 변경합시다:\n\n```js\nconst graphData: any[] = [[\"\", \"BTC\", \"ETH\"]];\n      let BTCPrice;\n      let ETHPrice;\n      for (const element of list) {\n        if (element.FSYM === \"BTC\") {\n          BTCPrice = element.P;\n        } else if (element.FSYM === \"ETH\") {\n          ETHPrice = element.P;\n        }\n        if (typeof BTCPrice === \"undefined\" || typeof ETHPrice === \"undefined\") {\n          continue;\n        } else {\n          graphData.push([\"\", BTCPrice, ETHPrice]);\n        }\n      }\n      return (\n        <Chart\n          graph_id=\"graph\"\n          chartType=\"LineChart\"\n          width=\"100%\"\n          height=\"400px\"\n          data={graphData}\n          options={options}\n        />\n      );\n  };\n\n  return (\n    <>{readyState === ReadyState.OPEN ? renderGraph() : connectionStatus} </>\n  );\n```\n\n결과는 다음과 같을 것입니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_3.png\" />\n\n그리고 마지막으로 작동 예제가 있습니다.\n\n# 결론\n\n이는 웹소켓을 사용하는 매우 단순한 방법이지만 문제를 해결해야 할 두 가지 중요한 문제가 있습니다. 첫 번째는 끝없는 리스트로 브라우저를 휩쓸 것이라는 점이고, 두 번째는 배열을 \"n\"개의 요소로 나누어도 대규모 다시 렌더링 문제가 발생하여 응용 프로그램이 반응 없거나 느려질 수 있습니다. 애플리케이션을 빠르고 부드럽게 실행하기 위한 몇 가지 기술이 있지만 이 글을 너무 길게 만들고 싶지 않아 두 부분으로 나누기로 결정했습니다.","ogImage":{"url":"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_0.png"},"coverImage":"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_0.png","tag":["Tech"],"readingTime":12},{"title":" TypeScript와 GitHub Actions를 사용하여 React 앱을 GitHub Pages에 배포하는 방법 ","description":"","date":"2024-06-22 03:03","slug":"2024-06-22-DeployingaReactAppwithTypeScriptandGitHubActionstoGitHubPages","content":"\n\n리액트 애플리케이션을 GitHub Pages에 배포하는 것은 적절한 설정으로 간단할 수 있어요. 이 안내서를 통해 TypeScript 및 GitHub Actions를 사용하여 미리 빌드된 React 앱을 GitHub Pages에 배포하는 방법을 안내할 거에요. 최적의 방법에 중점을 두어 배포를 깔끔하고 효율적으로 만들어보겠습니다.\n\n# 소개\n\n이 워크플로우는 dist 폴더를 메인 브랜치에 커밋하는 대신 peaceiris/actions-gh-pages@v3action을 사용하여 dist 디렉토리의 내용을 직접 gh-pages 브랜치에 배포합니다. 이 방법을 통해 애플리케이션의 컴파일된 최적화된 프로덕션 빌드만 GitHub Pages에 배포되므로 메인 브랜치를 깨끗하게 유지하고 소스 코드 관리에 집중할 수 있습니다.\n\n# 구성 세부 정보\n\n<div class=\"content-ad\"></div>\n\n1. 라우터의 베이스네임 속성: 🛤️\nApp.tsx 파일에서 `Router` 컴포넌트의 basename 속성을 설정하세요. 이렇게 하면 애플리케이션이 GitHub Pages의 하위 디렉토리 (/pokemon-react-app)에 배포될 때, 라우트가 해당 기본 URL을 기준으로 올바르게 해석됩니다.\n\n```js\n<Router basename=\"/pokemon-react-app\">\n {/* 여러분의 라우트 */}\n</Router>\n```\n\n2. 웹팩 설정: 🔧\n웹팩 구성에서 publicPath를 조정하여 하위 디렉토리에 배포될 때 자산 URL을 고려하세요.\n\n```js\noutput: {\n  filename: 'bundle.js',\n  path: path.resolve(__dirname, 'dist'),\n  publicPath: '/pokemon-react-app/',\n}\n```\n\n<div class=\"content-ad\"></div>\n\n3. Package.json 구성: 📦\npackage.json의 name 및 homepage 필드가 GitHub Pages를 올바르게 구성하도록 설정되었는지 확인하세요.\n\n```js\n{\n  \"name\": \"pokemon-react-app\",\n  \"homepage\": \"https://Jagoda11.github.io/pokemon-react-app\",\n}\n```\n\n# 단계별 안내 📝\n\n# 1. gh-pages 브랜치 생성하기 🌿\n\n<div class=\"content-ad\"></div>\n\n첫째로, gh-pages 브랜치가 없는 경우에만 생성하고 해당 내용을 정리하세요:\n\n```js\ngit checkout -b gh-pages\ngit checkout gh-pages\ngit rm -r .\ngit commit -m \"배포를 위한 정리\"\ngit push origin gh-pages\n```\n\n# 2. GitHub Actions Workflow ⚙️\n\nci.yml 파일에 GitHub Actions Workflow를 설정하여 배포 프로세스를 자동화하세요.\n\n<div class=\"content-ad\"></div>\n\n```yaml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [21.x]\n\n    steps:\n      - uses: actions/checkout@v2\n      - name: 🛠️ Use Node.js ${ matrix.node-version }\n        uses: actions/setup-node@v2\n        with:\n          node-version: ${ matrix.node-version }\n      - name: 📦 Install dependencies\n        run: npm ci\n      - name: 🖌️ Format code\n        run: npm run format\n      - name: 🧹 Lint code\n        run: npm run lint\n      - name: 🔨 Build\n        run: npm run build\n      - name: 🧪 Test with coverage\n        run: npm run test\n      - name: 🚀 Deploy to GitHub Pages 🚀\n        if: github.ref == 'refs/heads/main'\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${ secrets.GITHUB_TOKEN }\n          publish_dir: ./dist\n```\n\n# 3. Configuring GitHub Pages in GitHub Interface 🌐\n\nTo configure GitHub Pages in the GitHub interface:\n\n1. Navigate to Repository Settings: 🛠️\nGo to your repository on GitHub, click on the Settings tab.\n\n<div class=\"content-ad\"></div>\n\n2. 페이지 설정에 액세스하기: 📄\n왼쪽 메뉴에서 아래로 스크롤하여 \"페이지\"를 클릭하세요.\n\n3. 소스 브랜치 선택하기: 🌳\n\"소스\" 섹션에서 브랜치 드롭다운 메뉴에서 gh-pages를 선택하세요.\n\n4. 폴더 지정하기: 📁\n만약 당신의 dist 폴더가 리포지토리의 루트 레벨에 있다면, 폴더 드롭다운에서 / (루트)를 선택하세요. 다른 디렉토리 안에 있다면 해당 경로를 명시하세요.\n\n5. HTTPS 강제하기: 🔒\n사이트를 배포할 때 안전한 연결을 보장하기 위해 HTTPS를 활성화할 박스를 체크하세요.\n\n<div class=\"content-ad\"></div>\n\n6. 저장하기: 💾\n구성을 적용하려면 저장 버튼을 클릭하세요.\n\n![이미지](/assets/img/2024-06-22-DeployingaReactAppwithTypeScriptandGitHubActionstoGitHubPages_0.png)\n\n## 4. .gitignore에 dist 유지하기 🚫\n\n주 브랜치를 깨끗하게 유지하려면 .gitignore 파일에 dist 디렉토리를 포함시키세요. 이렇게 하면 dist 폴더가 주 브랜치에 커밋되지 않고, GitHub Actions 파이프라인에서 빌드 프로세스 중에 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\n 다음과 같은 줄을 .gitignore 파일에 추가해주세요:\n\n```js\ndist/\n```\n\n# 결론 🎉\n\n위 단계를 따라하면 GitHub Actions를 통해 GitHub Pages에 React 애플리케이션을 효율적으로 배포할 수 있습니다. 이 설정은 메인 브랜치를 유지하고 소스 코드 관리에 집중하면서 최적화된 프로덕션 빌드만 배포되도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n제 포켓몬 앱의 작동 예제를 확인하고 완전한 소스 코드를 보려면 GitHub 저장소를 살펴보세요.\n\n저자 소개\n\n안녕하세요, 개발에 열정을 품고 웹 개발과 오픈 소스 프로젝트에 관심을 가지고 있는 Jagoda입니다. GitHub에서 제 작품을 더 확인하거나 LinkedIn에서 저와 소통할 수 있습니다.\n\n질문이 있거나 추가 도움이 필요하다면 언제든지 댓글을 남기거나 연락해주세요. 즐거운 배포되세요!🌟","ogImage":{"url":"/assets/img/2024-06-22-DeployingaReactAppwithTypeScriptandGitHubActionstoGitHubPages_0.png"},"coverImage":"/assets/img/2024-06-22-DeployingaReactAppwithTypeScriptandGitHubActionstoGitHubPages_0.png","tag":["Tech"],"readingTime":4},{"title":"useState와 useRef 훅을 언제 사용하는지 이해하기","description":"","date":"2024-06-22 03:02","slug":"2024-06-22-UnderstandingofwhentouseuseStateanduseRefhooks","content":"\n\n<img src=\"/assets/img/2024-06-22-UnderstandingofwhentouseuseStateanduseRefhooks_0.png\" />\n\nReact는 사용자 인터페이스를 구축하기 위한 자바스크립트 라이브러리입니다. 선언적이고 효율적이며 유연합니다. React는 컴포넌트 기반 접근 방식을 사용하여 인터랙티브한 UI를 쉽게 생성할 수 있습니다.\n\nReact에서 Hook은 클래스 컴포넌트를 생성하지 않고도 상태 및 기타 React 기능을 사용하는 방법입니다. 가장 자주 사용되는 Hook 중 하나는 useState()이지만 때로는 useRef()를 사용하는 것이 더 나은 방법으로 상태를 관리할 수 있습니다.\n\n이 글에서는 useState() 훅 이외에 useRef() 훅을 사용할 때에 대해 배우게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 사용법 useState():\n\n폼 입력 필드를 처리할 때 주로 사용되는 경우는 제출 버튼이 클릭될 때입니다. 예를 들어, 다음 코드 조각을 살펴보겠습니다:\n\n![화면 캡처 이미지](/assets/img/2024-06-22-UnderstandingofwhentouseuseStateanduseRefhooks_1.png)\n\n위의 예에서는 이메일과 비밀번호 두 가지 입력 필드가 있습니다. 제출 버튼을 클릭하면 두 입력 필드의 값이 콘솔에 기록됩니다. useState() 훅을 사용하여 두 입력 필드의 상태를 관리합니다. 그러나 입력 필드가 변경될 때마다 컴포넌트가 다시 렌더링되도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*0mz26TiXCcMdstgoUx73ug.gif)\n\n이걸 보면 우리가 onSubmit 안에서만 이 상태 변수들을 사용한다는 것을 알 수 있어요. 즉, 이 상태 변수들이 변경되는 값을 우리는 신경 쓰지 않습니다. 우리는 submit 버튼을 눌렀을 때 상태 변수들의 값만을 신경 씁니다. \n\n이 예시에서는 문제가 되지 않지만, 보다 복잡한 어플리케이션에서는 성능 문제를 일으킬 수 있어요.\n\n## 이를 피하려면, useState() 대신 useRef()를 사용할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n## useRef 사용:\n\n![image](/assets/img/2024-06-22-UnderstandingofwhentouseuseStateanduseRefhooks_2.png)\n\n위 예시에서 useRef를 사용하여 ref를 생성하고 input 필드에 할당합니다. 버튼을 클릭하면 handleSubmit 함수가 실행되고 사용자의 이메일 및 비밀번호를 얻을 수 있습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*W-14Q7gk6Cvyre6b_fGalQ.gif)\n\n<div class=\"content-ad\"></div>\n\n보시는 대로, 이메일 및 비밀번호 필드를 변경할 때 컴포넌트가 다시 렌더링되지 않았습니다. 그리고 이를 위해 상태 값이 사용되지 않았습니다.\n\n다음은 useState() 대신 useRef()를 사용해야 하는 경우의 몇 가지 예시입니다:\n\n- 업데이트될 때 다시 렌더링을 트리거하지 않는 값을 저장해야 할 때\n- 렌더링 방법에서 사용되지 않는 값을 저장해야 할 때\n- 컴포넌트의 수명 동안 지속되어야 하는 값을 저장해야 할 때\n\n# 결론:\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 useRef와 useState가 React에서 모두 중요한 훅이지만 서로 다른 목적을 가지고 있다는 것을 배웠습니다. useRef는 DOM에 직접 액세스하고 조작할 수 있게 해주는 훅입니다. 요소에 대한 참조를 제공하지만 내용이 변경될 때 다시 렌더링을 트리거하지 않습니다. useState는 컴포넌트의 상태를 관리할 수 있게 해주는 훅입니다. 상태가 변경되면 새로운 상태로 컴포넌트가 다시 렌더링됩니다.\n\n# 읽어 주셔서 감사합니다\n\n이 기사가 유용하게 느껴졌으면 좋겠습니다. 궁금한 점이나 제안 사항이 있으시면 댓글을 남겨 주세요. 피드백은 제게 더 나아질 수 있게 도와줍니다.","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingofwhentouseuseStateanduseRefhooks_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingofwhentouseuseStateanduseRefhooks_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트 설정 WebPack, 린트 그리고 핫리로드 사용 방법","description":"","date":"2024-06-22 03:01","slug":"2024-06-22-ReactSetupusingWebPackalongwithlintandhotreload","content":"\n\n## React의 기본 설정, 핫 리로딩, 린트, 웹팩\n\n![React 설정](/assets/img/2024-06-22-ReactSetupusingWebPackalongwithlintandhotreload_0.png)\n\n## 1. 폴더 생성\n\n```js\nmkdir 폴더명\ncd 폴더명\n```\n\n<div class=\"content-ad\"></div>\n\n## 2. git 설치하기\n\n```js\ngit init // 명령을 완료하려면 Enter 키를 여러 번 누르세요\n```\n\n## 3. .gitignore 파일 생성\n\n.gitignore 파일을 생성하고 아래 코드를 추가하세요\n\n<div class=\"content-ad\"></div>\n\n```js\n// .gitignore 파일에 아래 라인 추가\n\nnode_modules\n.DS_Store\n```\n\n## 4. 루트 폴더에 Package.json 생성\n\n```js\nnpm init // 명령어를 실행하고 엔터 키를 여러 번 눌러주세요\n```\n\n## 5. 루트 폴더에 린트 추가하기\n\n<div class=\"content-ad\"></div>\n\n프로젝트에 lint 패키지를 소개하고 있어요. Airbnb는 우리가 사용할 표준 lint 패키지입니다. 먼저 아래 명령어로 패키지를 설치해주세요.\n\n```js\n// lint npm 패키지 및 의존성 설치\nnpx install-peerdeps --dev eslint-config-airbnb\n```\n\n.eslintrc 파일을 만들고 아래 코드를 추가해주세요.\n\n```js\n{\n  \"extends\": \"airbnb\",\n  \"parser\": \"@babel/eslint-parser\",\n  \"plugins\": [\n    \"react-hooks\"\n  ],\n  \"globals\": {\n    \"globalThis\": true,\n    \"google\": true,\n    \"document\": true\n  },\n  \"rules\": {\n    \"import/no-extraneous-dependencies\": [\"off\"], // webpack-dashboard와 같은 외부 종속성 사용 필요\n    \"react/jsx-filename-extension\": [1, { \"extensions\": [\".js\", \".jsx\"] }] // jsx 사용 필요\n  },\n  \"parserOptions\": {\n    \"ecmaVersion\":\"latest\" // 최신 ECMA 스크립트 지원을 위해\n}\n```\n\n<div class=\"content-ad\"></div>\n\nMarkdown 형식으로 표 태그를 변경하십시오. \n\n또한 VScode에 ESLint 플러그인을 설치하십시오. vscode에서 eslint 확장 프로그램 이미지를 아래 이미지에서 확인하십시오.\n\n![eslint extension in vscode](/assets/img/2024-06-22-ReactSetupusingWebPackalongwithlintandhotreload_1.png)\n\n## 6. 루트 폴더에 .editorconfig 파일 생성\n\n그 다음 단계로, 코드 형식을 유지하기 위해 .editorconfig 파일을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n\n루트 = 참\n\n[*]\n들여쓰기_스타일 = 공간\n들여쓰기_크기 = 2\n줄의_끝 = lf\n문자셋 = utf-8\n뒤의_공백_제거 = 참\n마지막_새줄_삽입 = 참\r\n\n\n## 7. 루트 폴더 내 .vscode 폴더에 setting.json 만들기\n\n우리는 .vscode라는 폴더를 생성하고 .vscode 폴더 내에 setting.json 파일을 만듭니다. 아래 라인을 추가하여 린트 자동 수정 및 탭 들여쓰기가 2인 설정을 합니다. setting.json에 아래 코드를 추가하세요.\n\n\n{\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": \"explicit\",\n    \"source.fixAll\": \"always\", \n    \"editor.tabSize\": 2 \n  },\n  \"eslint.workingDirectories\": [\n      {\"mode\": \"auto\"}\n    ],\n  },\n  \"search.exclude\": {\n      \"**/index.js\": true,\n      \"**/__build-es/**\": true\n   }\n}\n\n\n<div class=\"content-ad\"></div>\n\n## 8. 앱 폴더 생성\n\n앱 폴더를 만들어보겠습니다. 모든 개발 관련 파일은 앱 폴더 아래에 위치합니다.\n\n우리는 client.js라는 새 파일을 추가하고 있습니다. 일단 client.js 내에 콘솔을 추가하고 있습니다. 나중에는 애플리케이션을 부트스트랩하기 위해 리액트 코드를 추가할 것입니다.\n\n```js\nconsole.log('Client file loaded');\n```\n\n<div class=\"content-ad\"></div>\n\n## 9. webpack.config.js 추가하기\n\n웹팩과 웹팩-cli를 설치하여 webpack.config.js를 구성하세요.\n\n```js\nnpm install webpack webpack-cli webpack-dev-server --save-dev\n```\n\n다음 단계에서는 싱글 페이지 애플리케이션을 위해 webpack.config.js를 생성하고 구성해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst path = require('path');\n\n module.exports = {\n   entry: {\n     client: './app/client.js',\n   },\n   mode: 'development',\n   output: {\n     filename: 'client.js',\n     path: path.resolve(__dirname, 'build'),\n     publicPath: '',\n   },\n };\n```\n\npackage.json 파일 내 script 오브젝트에 명령어 추가\n\n```js\n\"build\": \"webpack --config webpack.config.js\"\n```\n\n터미널에서 명령어 실행\n\n```js\nnpm run build\n```\n\n<div class=\"content-ad\"></div>\n\n와우, 빌드 폴더 내의 js 파일을 Transpile하는 설정을 완료했어요. 빌드 폴더가 생성되었고 client.js Transpile 파일이 포함되어 있어요.\n\n## 10. JSX 지원 제공\n\nnpm i @babel/preset-react --save-dev를 설치해주세요.\n\n그리고 루트 폴더에 .babelrc 파일을 추가하고 아래 코드를 추가해주세요. 이렇게 하면 JSX 지원이 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n  \"presets\": [\n    \"@babel/preset-react\"\n  ]\n}\n```\n\n## 11. babel-loader를 사용하여 React 코드를 Javascript로 변환하기\n\n```js\nnpm i babel-loader --save-dev\n```\n\nmode: \"development\" 이후에 webpack.babel.js 안에 babel-loader를 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.js$/,\n      exclude: /node_modules/,\n      use: [{ loader: 'babel-loader', options: { cacheDirectory: true } }],\n    },\n  ],\n},\n```\n\n## 12. 프로젝트에서 React 및 JSX 사용하기\n\nReact 및 react-dom 설치\n\n```js\nnpm i react react-dom --save\n```\n\n<div class=\"content-ad\"></div>\n\n아래 코드를 client.js 파일 안에 추가해주세요.\n\n```js\nimport React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\nconst APP = (\n  <div>앱이 실행 중입니다</div>\n);\n\ncreateRoot(document.getElementById('root')).render(APP);\n```\n\n## 13. 루트 폴더에 index.html을 추가해봅시다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>App 1</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script src=\"build/client.js\"></script>\n  </body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\nindex.html 파일을 실행해 주세요.\n\n와우, 설치가 완료되었습니다.\n\n## 14. 핫 리로딩 추가하기\n\nclient.js 파일 변경이 페이지에 반영되지 않는군요. webpack-dev-server를 이용해 핫 리로딩을 추가해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\r\nnpm install webpack-dev-server\r\n```\r\n\r\n이제 package.json의 start 스크립트를 변경해야 합니다.\r\n\r\n```js\r\n// 이전 설정\r\n\"start\": \"webpack  --config webpack.config.js\"\r\n\r\n// 이제 핫리로딩이 가능한 설정\r\n\"start\": \"webpack-dev-server  --config webpack.config.js\"\r\n```\r\n\r\nwebpack.config.json 파일에 webpack-dev-server를 추가해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\ndevServer: {\n  devMiddleware: { writeToDisk: true },\n  static: {\n    directory: path.join(__dirname, '/'),\n  },\n  compress: true,\n  port: 9000,\n},\n```\n\n그거 정말 멋지죠. 이제 http://localhost:9000/에서 애플리케이션을 실행할 수 있어요.\n\n## 결론:\n\n이 설정에서 우리는 지원을 제공했습니다.\n\n<div class=\"content-ad\"></div>\n\n- git (버전 관리)\n- Airbnb의 ESlint\n- 코드 형식 유지\n- Linting 자동 수정\n- JSX 지원\n- React 지원\n- 핫 리로딩","ogImage":{"url":"/assets/img/2024-06-22-ReactSetupusingWebPackalongwithlintandhotreload_0.png"},"coverImage":"/assets/img/2024-06-22-ReactSetupusingWebPackalongwithlintandhotreload_0.png","tag":["Tech"],"readingTime":6},{"title":"Shadcn UI, Vite, Tailwind CSS, Storybook으로 React UI 컴포넌트 라이브러리 만드는 방법 단계별 가이드","description":"","date":"2024-06-22 02:59","slug":"2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook","content":"\n\n![이미지](/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_0.png)\n\n안녕하세요! 이 글에서는 Shadcn UI, Vite, Tailwind CSS 및 Storybook을 사용하여 React UI 컴포넌트 라이브러리를 설정하는 방법에 대해 안내하겠습니다. 설정 프로세스에 들어가기 전에 이 기술들이 무엇이며 왜 사용하는지에 대해 먼저 이해해봅시다.\n\n- Shadcn UI: Shadcn UI는 아름답고 접근성 있는 컴포넌트들의 모음이며 응용 프로그램에서 사용할 수 있습니다. 이는 종속성으로 설치하는 전통적인 컴포넌트 라이브러리가 아닙니다. 대신 컴포넌트를 찾아보고 복사하여 붙여넣거나 필요에 맞게 사용자 정의할 수 있습니다. Shadcn UI를 사용하는 이유는 일관된 디자인 시스템으로 빠르게 프로토타입을 만들고 컴포넌트를 구축할 수 있기 때문입니다.\n- Vite: Vite는 현대적인 웹 프로젝트에 대해 더 빠르고 가벼운 개발 경험을 제공하도록 목적으로 하는 빌드 도구입니다. Vite에는 두 가지 주요 부분이 포함되어 있습니다. 네이티브 ES 모듈에 대해 매우 빠른 핫 모듈 교체(HMR)와 같은 기능을 제공하는 개발 서버 및 코드를 Rollup과 함께 번들로 묶어서 프로덕션용으로 매우 최적화된 정적 에셋을 출력할 수 있도록 사전 구성된 빌드 명령이 있습니다. Vite의 사용 이유는 전통적인 도구와 비교하여 더 빠르고 효율적인 빌드 프로세스를 제공하기 때문입니다.\n- Tailwind CSS: Tailwind CSS는 맞춤형 사용자 인터페이스를 빠르게 구축하기 위한 유틸리티 중심의 CSS 프레임워크입니다. HTML을 떠나지 않고 완전히 맞춤형 디자인을 구축할 수 있도록 낮은 수준의 유틸리티 클래스를 제공합니다. 버튼이나 테이블과 같은 요소에 대해 미리 정의된 클래스 시리즈를 제공하지 않습니다. Tailwind CSS를 사용하는 이유는 쉽고 효율적으로 사용자 지정 스타일을 만들 수 있기 때문입니다.\n- Storybook: Storybook은 UI 컴포넌트 및 페이지를 격리해서 구축하는 도구입니다. 전체 앱을 실행할 필요 없이 어려운 상태와 예외 사례를 개발하고 공유할 수 있습니다. 수천 개의 팀이 UI 개발, 테스트 및 문서 작업을 위해 Storybook을 사용합니다. Storybook을 사용하는 이유는 컴포넌트를 격리해서 개발 및 테스트할 수 있어 개발 프로세스를 더 효율적으로 관리할 수 있기 때문입니다.\n\n이제 이러한 기술들에 대한 이해를 더 했으니 설정 프로세스에 대해 알아봅시다. 함께 진행해보시죠!\n\n<div class=\"content-ad\"></div>\n\n# 준비 사항\n\n시작하기 전에 다음을 이미 알고 있다고 가정합니다:\n\n- React\n- TypeScript\n- Tailwind CSS\n\n그리고 시스템에 다음이 설치되어 있는지 확인하세요:\n\n<div class=\"content-ad\"></div>\n\n- Node.js와 npm\n\n# 단계 1: Vite로 프로젝트 설정하기\n\n우선 Vite (5.2.0)를 사용하여 새 프로젝트를 설정해야 합니다. 터미널에서 다음 명령을 실행하십시오:\n\n```js\nnpm create vite@latest\n```\n\n<div class=\"content-ad\"></div>\n\n터미널에서 화면 안내에 따라 따라가서 프로젝트 이름을 입력하세요. 이 글에서는 \"ui-library\"라는 이름을 사용하고 있습니다. 리액트와 TypeScript를 사용할 것이기 때문에 해당 옵션을 선택하세요.\n\n![이미지](/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_1.png)\n\n모든 지침을 따르고 나면 \"ui-library\" 프로젝트 디렉토리 안에 들어가고 http://localhost:5173/에서 Vite 데모 페이지를 볼 수 있을 것입니다.\n\n# 단계 2: Tailwind CSS 설치하기\n\n<div class=\"content-ad\"></div>\n\n다음으로, Tailwind CSS (3.4.3)를 다음 명령어를 사용하여 설치합니다:\n\n```js\nnpm install -D tailwindcss postcss autoprefixer\n```\n\n# 단계 3: Tailwind CSS 구성\n\nTailwind CSS를 설치한 후, 구성 파일을 생성해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpx tailwindcss init -p\n```\n\n프로젝트 루트에 tailwind.config.js 파일이 생성됩니다. 우선 아래 내용대로 파일을 업데이트하세요. shadcn이 설치되면 업데이트될 것입니다.\n\n<img src=\"/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_2.png\" />\n\n각 Tailwind 레이어에 대한 @tailwind 지시문을 src/index.css 파일에 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\r\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\nApp.tsx 파일 안의 모든 내용을 다음과 같이 바꾸고 npm run dev를 실행하십시오:\n\n```js\r\nexport default function App() {\n  return <h1 className='text-3xl font-bold underline'>안녕, 세상아!</h1>;\n}\r\n```\n\n이제 브라우저에서 다음이 표시됩니다:\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_3.png)\n\n현재 단계에서는 Vite 및 Tailwind가 설치된 프로젝트를 가지고 있습니다.\n\n# 단계 4: Storybook 통합\n\n이제 우리는 Storybook 8을 통합하여 UI 구성요소를 격리된 상태로 개발하고 각 구성요소에 대한 청결한 문서를 제공할 것입니다. 다음 명령을 사용하여 설치하십시오:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nnpx storybook@latest init\n```\n\n이 명령어를 실행하면 자동으로 프로젝트 유형을 감지하고 package.json에 필요한 종속성 및 스크립트를 추가하게 될 거에요. 그리고 http://localhost:6006/에 아래의 데모 페이지를 볼 수 있을 거에요:\n\n![이미지](/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_4.png)\n\nStorybook과 함께 Tailwind 클래스를 사용하려면 .storybook/preview.ts 파일에 불러와야 해요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport 'tailwindcss/tailwind.css'\n```\n\n# 단계 5: Shadcn UI 설치하기\n\n이제 Shadcn을 프로젝트에 설정할 것이며, 이를 통해 UI 컴포넌트를 생성할 것입니다.\n\n먼저, tsconfig.json 파일의 compilerOptions에 경로를 해결하는 몇 가지 코드를 추가해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n{\n  \"compilerOptions\": {\n    // ...\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\n        \"./src/*\"\n      ]\n    }\n    // ...\n  }\n}\n```\n\n그런 다음 다음 명령을 사용하여 @types/node을 설치하겠습니다.\n\n```js\n# (\"path\"를 오류 없이 가져올 수 있도록 함)\nnpm i -D @types/node\n```\n\n아래 코드를 vite.config.ts에 추가하여 앱이 오류 없이 경로를 해석할 수 있도록 하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport path from \"path\"\nimport react from \"@vitejs/plugin-react\"\nimport { defineConfig } from \"vite\"\n \nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"./src\"),\n    },\n  },\n})\n```\n\n프로젝트를 설정하려면 shadcn-ui init 명령을 실행하세요:\n\n```js\nnpx shadcn-ui@latest init\n```\n\n다음과 같이 옵션을 선택하세요:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_5.png)\n\n이제 첫 번째 컴포넌트를 추가할 준비가 되었습니다.\n\n# 단계 6: 컴포넌트 생성\n\n이제 Shadcn UI를 사용하여 간단한 컴포넌트를 만들어 봅시다. 아래 명령어는 Button 컴포넌트를 프로젝트에 추가합니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nnpx shadcn-ui@latest add button\n```\n\nStorybook story나 src\\components\\ui\\button.tsx에서 Button 컴포넌트를 가져올 수 있습니다.\n\n# 단계 7: Storybook에 컴포넌트 추가하기\n\n마지막으로, Button 컴포넌트를 Storybook에 추가해 보겠습니다. Storybook에는 기존의 Button 컴포넌트가 있을텐데, 이것을 포함하여 다른 샘플 컴포넌트들을 삭제할 수 있습니다. src\\stories\\Button.stories.ts 디렉토리의 파일 Button.stories.tsx를 다음과 같이 편집하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Button } from '@/components/ui/button'\nimport type { Meta, StoryObj } from '@storybook/react'\nimport { fn } from '@storybook/test'\n\nconst meta = {\n  title: 'Example/Button',\n  component: Button,\n  parameters: {\n    layout: 'centered',\n  },\n  tags: ['autodocs'],\n  argTypes: {},\n  args: { onClick: fn() },\n} satisfies Meta<typeof Button>\nexport default meta\ntype Story = StoryObj<typeof meta>\nexport const Primary: Story = {\n  args: {\n    children: 'Button',\n  },\n}\n```\n\n이제 npm run storybook을 실행하여 Storybook을 시작하고 http://localhost:6006/에서 구성 요소를 확인할 수 있습니다. 이렇게 보일 것입니다:\n\n<img src=\"/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_6.png\" />\n\n이제 Button 구성 요소를 사용자 정의하고 여기에서 더 많은 shadcn 구성 요소를 추가할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n축하합니다! Shadcn UI, Vite, Tailwind CSS 및 Storybook을 사용하여 React UI 컴포넌트 라이브러리를 성공적으로 설정했습니다. 이 설정은 컴포넌트를 효율적으로 생성하고 관리하는 데 도움이 될 것입니다.\n\n도움이 되었다면 좋아요를 눌러주세요. 피드백은 언제나 환영합니다 :)","ogImage":{"url":"/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoBuildaReactUIComponentLibraryAStep-by-StepGuideusingShadcnUIViteTailwindCSSandStorybook_0.png","tag":["Tech"],"readingTime":7},{"title":"Skeleton Loaders React 데이터 로딩 쉽게 하기 - 1부","description":"","date":"2024-06-22 02:58","slug":"2024-06-22-SkeletonLoadersSimplifyingDataLoadinginReactPart1","content":"\n\n![이미지](/assets/img/2024-06-22-SkeletonLoadersSimplifyingDataLoadinginReactPart1_0.png)\n\n# 파트 원: 우리의 리액트 앱 만들기\n\n이 두 파트 시리즈에 오신 것을 환영합니다. 우리는 Skeleton Loaders에 대해 살펴보며 React에서 데이터 로딩을 간소화하는 방법에 대해 알아볼 것입니다. 첫 번째 파트에서는 새로운, 현대적인 React 애플리케이션을 처음부터 설정할 것입니다. 그런 다음 일부 데이터를 가져와 스타일링을 추가할 것입니다.\n\n## Skeleton Loading 화면의 파워를 이해하기\n\n<div class=\"content-ad\"></div>\n\n대부분의 최신 웹 사이트는 데이터를 서버 측이 아닌 브라우저에서 가져옵니다. 사용자가 콘텐츠를 서버에서로드하기까지 기다릴 필요가 없어서 이는 장점이 될 수 있었지만, 그러면 브라우저에서 데이터를 가져와야 하므로 기다려야 하는 상황이 발생했습니다. 이 데이터 가져오기 이벤트를 처리하고 사용자가 애플리케이션 또는 웹 사이트와 상호 작용하도록 유지하기 위해 일반적으로 어떤 종류의 로더나 스피너가 표시됩니다. 매우 실용적이고 점점 일반적인 접근 방법은 스켈레톤 로딩 화면을 사용하는 것입니다. 이는 콘텐츠의 레이아웃을 반영하는 플레이스홀더 요소를 추가하여 들어오는 데이터를 나타냅니다. Facebook 및 LinkedIn과 같은 주요 웹 사이트에서 사용되는 스켈레톤 로딩 화면은 이 상황에 대한 해결책입니다.\n\n전제 조건\n\n- React의 기본 지식.\n- React Hooks에 익숙함.\n\n# 프로젝트 설정하기\n\n<div class=\"content-ad\"></div>\n\n먼저 새로운 리액트 애플리케이션을 생성하세요:\n\n```js\nnpx create-react-app react-skeleton-screens\n```\n\n프로젝트 디렉토리로 이동하세요:\n\n```js\ncd react-skeleton-screens\n```\n\n<div class=\"content-ad\"></div>\n\nVisual Studio Code에서 프로젝트를 열어보세요:\n\n```js\ncode .\n```\n\n## 보일러플레이트 코드 제거\n\ncreate-react-app으로 생성된 기본 파일들을 정리해보세요.\n\n<div class=\"content-ad\"></div>\n\n- `src` 폴더를 열어서 다음 파일들을 삭제해주세요:\n— App.css\n— App.test.js\n— logo.svg\n— setupTests.js\n\n2. index.js 파일 내에서 service worker의 import 및 호출을 제거해주세요.\n\n3. App.js 파일 내에서 logo.svg와 App.css의 import를 제거해주세요. \n\n`App.js`에 다음 코드를 넣어주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from \"react\";\nimport Home from \"./components/Home\";\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header>\n        <h1>식단 레시피</h1>\n      </header>\n      <div className=\"content\">\n        <Home />\n      </div>\n    </div>\n  );\n}\nexport default App;\n```\n\n## 컴포넌트 생성\n\nsrc 폴더 안에 components라는 새 폴더를 만들어주세요. 이 폴더 안에 Home.jsx 파일을 만들어주세요:\n\n```js\nimport React from \"react\";\nconst Home = () => {\n  return <div className=\"home\"></div>;\n};\nexport default Home;\n```\n\n<div class=\"content-ad\"></div>\n\n## 애플리케이션에 스타일 추가하기\n\n우리 애플리케이션의 외관을 개선하기 위해 App.js의 헤더에 일부 스타일을 적용할 거에요.\n\nindex.css 업데이트\n\n`index.css`의 내용을 다음 스타일로 대체해 주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\nheader {\n  font-size: 1.5rem;\n  font-weight: 900;\n  display: grid;\n  align-items: center;\n}\nheader h1 {\n  max-width: 1200px;\n  margin: 0 auto;\n}\n.container {\n  background-color: #6b7280;\n  color: #ffffff;\n  min-height: 100vh;\n  transition: all 1s ease-out;\n}\n.meals {\n  display: grid;\n  grid-template-columns: repeat(1, minmax(0, 1fr));\n  gap: 1.25rem;\n  margin-top: 1.25rem;\n  transition: all 1s ease-out;\n  padding: 10px 50px;\n}\n@media (min-width: 640px) {\n  .meals {\n    grid-template-columns: repeat(2, minmax(0, 1fr));\n  }\n}\n@media (min-width: 768px) {\n  .meals {\n    grid-template-columns: repeat(3, minmax(0, 1fr));\n  }\n}\n@media (min-width: 1280px) {\n  .meals {\n    grid-template-columns: repeat(4, minmax(0, 1fr));\n  }\n}\n.meal {\n  border-radius: 0.25rem;\n  overflow: hidden;\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),\n    0 2px 4px -1px rgba(0, 0, 0, 0.06);\n  cursor: pointer;\n  position: relative;\n  height: 15rem;\n  width: 15rem;\n}\n.meal-img:hover {\n  box-shadow: 0 10px 15px -3px rgba(147, 102, 102, 0.1),\n    0 4px 6px -2px rgba(0, 0, 0, 0.05);\n  transition: all 1s ease-out;\n}\n.meal-img {\n  width: 100%;\n  height: 100%;\n  border: solid 4px #ffffff;\n}\n```\n\n이 스타일은 애플리케이션 헤더가 깔끔하고 시각적으로 매력적으로 보이도록 보장합니다.\n\n## 애플리케이션 실행하기\n\n변경 사항을 확인하려면 개발 서버를 시작하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nyarn dev\n```\n\n브라우저에서 http://localhost:3000 으로 이동하여 새로운 스타일이 적용된 업데이트된 페이지를 확인할 수 있어요.\n\n데이터 가져오기\n\nMealDB API(https://www.themealdb.com/api.php)를 사용하여 데이터를 가져올 거에요.\n\n<div class=\"content-ad\"></div>\n\nApp.js에서 데이터를 저장할 상태를 생성해보세요:\n\n```js\nconst [meals, setMeals] = useState(null);\n```\n\n컴포넌트가 렌더링될 때 데이터를 가져오기 위해 useEffect 훅을 사용해보세요:\n\n```js\nimport { useState, useEffect } from \"react\";\nimport Home from \"./components/Home\";\nfunction App() {\n  const [meals, setMeals] = useState(null);\n  useEffect(() => {\n    setTimeout(async () => {\n      const res = await fetch(\n        \"https://www.themealdb.com/api/json/v1/1/search.php?s=chicken\"\n      );\n      const data = await res.json();\n      setMeals(data);\n    }, 5000);\n  }, []);\n  return (\n    <div className=\"App\">\n      <header>\n        <h1>Meal Recipes</h1>\n      </header>\n      <div className=\"content\">\n        <Home meals={meals} />\n      </div>\n    </div>\n  );\n}\nexport default App;\n```\n\n<div class=\"content-ad\"></div>\n\nHome.js 파일에서 조건부 렌더링을 사용하여 식사 레시피 결과를 표시하십시오:\n\n```js\nimport { useState, useEffect } from \"react\";\nimport { Link } from \"react-router-dom\";\nconst Home = () => {\n  const [meals, setMeals] = useState(null);\n  useEffect(() => {\n    setTimeout(async () => {\n      const res = await fetch(\n        \"https://www.themealdb.com/api/json/v1/1/search.php?s=chicken\"\n      );\n      const meals = await res.json();\n      setMeals(meals);\n    }, 5000);\n  }, []);\n  return (\n    <div className=\"bg-gray-900 text-white min-h-screen\">\n      <div className=\"m-auto max-w-3xl flex flex-col items-center justify-center text-center\">\n        <div id=\"meals\" className=\"meals\">\n          {meals &&\n            meals.meals.map((meal) => (\n              <div className=\"meal\" key={meal.idMeal}>\n                <Link to={`/MealInfo/${meal.idMeal}`}>\n                  <img\n                    className=\"meal-img\"\n                    src={meal.strMealThumb}\n                    alt={meal.strMeal}\n                  />\n                  <div className=\"meal-info\" data-mealid={meal.idMeal}>\n                    <h3>{meal.strMeal}</h3>\n                  </div>\n                </Link>\n              </div>\n            ))}\n        </div>\n      </div>\n    </div>\n  );\n};\nexport default Home;\n```\n\n## React Router 추가\n\nreact-router-dom 설치하기:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install react-router-dom\n```\n\nreact-router-dom에서 BrowserRouter을 사용하여 main.js에 App을 감싸세요:\n\n```js\nimport React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport App from './App.jsx'\nimport './index.css'\nimport { BrowserRouter } from 'react-router-dom'\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <App />\n    </BrowserRouter>\n  </React.StrictMode>\n);\n```\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n이번 시리즈의 첫 번째 파트에서는 리액트 애플리케이션에 스켈레톤 로딩 화면을 구현하는 기초 작업을 마무리지었습니다. 기본적인 React 프로젝트를 설정하고 컴포넌트를 생성하며, 스타일을 추가하고 API에서 데이터를 가져오면서 우리는 애플리케이션에 스켈레톤 로딩 화면을 통합할 기초를 마련했습니다.\n\n두 번째 파트에서는 스켈레톤 로딩 화면의 구현 세부사항에 더 깊이 파고들 것입니다. 재사용 가능한 스켈레톤 컴포넌트를 생성하는 방법, 로딩 애니메이션을 사용자 정의하는 방법, 그리고 다양한 로딩 시나리오를 효율적으로 처리하는 방법을 살펴볼 것입니다. PART 2로 이동하여 스켈레톤 로딩 화면을 더 발전시키는 방법을 확인해보세요!","ogImage":{"url":"/assets/img/2024-06-22-SkeletonLoadersSimplifyingDataLoadinginReactPart1_0.png"},"coverImage":"/assets/img/2024-06-22-SkeletonLoadersSimplifyingDataLoadinginReactPart1_0.png","tag":["Tech"],"readingTime":7}],"page":"26","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}