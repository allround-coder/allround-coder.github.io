{"pageProps":{"posts":[{"title":"웹사이트에서 UI UX 디자인을 하는 방법","description":"","date":"2024-05-18 22:12","slug":"2024-05-18-MyJourneyintoUIUXDesign","content":"\n\n2023년 활기찬 한 해에 저는 MyCaptain의 존경받는 멘토들에게 인도받으며 UI/UX 디자인의 영역으로 모험을 떴어요. 이 수습기는 학습 경험이 아닌, 제가 산업의 도전을 받아들일 준비가 된 숙련된 열정적인 디자이너로 변화시킨 변혁적인 여정이었어요.\n\n## 기반을 발견하다: UI, HTML 및 CSS\n\n제 여정은 디자인의 기초에 대한 심층적인 탐구로 시작했어요. 여기서 UI, HTML 및 CSS에 대한 제 기술을 갈고 닦았죠. 이러한 기본 요소들이 제 디자인 지식의 기초를 이루어 시각적으로 멋지고 사용자 친화적인 인터페이스를 만들 수 있도록 능력을 부여했어요.\n\n## 제품 디자인의 세계를 탐험하기\n\n<div class=\"content-ad\"></div>\n\n제가 제품 디자인 방법론 세계에 몰두하는 흥미로운 기회를 가졌어요. 탐구한 전략 중에는 5단계 방법론과 더블 다이아몬드 4단계가 있었는데, 두 방법 모두 창의성과 정밀성을 바탕으로 디자인 과제에 접근하는 데 도움이 되었어요.\n\n5단계 방법론은 디자인 사고 방식의 체계적 접근법으로, 사용자와 공감하고 문제를 정의하며 해결책을 생각하고 아이디어를 프로토타입으로 만들고 사용자에게 테스트하는 단계를 포함합니다. 이 방법론은 사용자의 필요성과 고통을 이해하는 중요성을 가르쳐줬어요. 이는 타겟 대상을 완벽하게 만족시키는 사용자 중심 디자인을 만들기 위해 필수적이에요.\n\n그 반면, 더블 다이아몬드 4단계 방법론은 확산 및 수렴적 사고를 강조합니다. 첫 번째 다이아몬드는 문제 발견 및 정의 단계를 나타내고, 두 번째 다이아몬드는 해결책 개발 및 제공을 집중합니다. 이 방법론은 가장 실행 가능한 해결책으로 좁혀들기 전에 여러 아이디어를 탐색하는 방법을 가르쳐줬어요. 이를 통해 최종 디자인이 혁신적이면서도 실용적이며 실행 가능하도록 보장했어요.\n\n이러한 방법론들은 제 디자인 도구 상자를 확장시키는 데 그치지 않고 문제 해결 능력도 향상시켜줬어요. 사용자와 공감하고 아이디어를 반복해 의미 있는 디자인을 만들어내는 방법을 가르쳐줬죠.\n\n<div class=\"content-ad\"></div>\n\n## 현실 세계 프로젝트 및 크리에이티브 챌린지\n\n산업 전문가들의 지도 아래, 저는 상상력을 발휘할 수밖에 없게끔 밀어붙이는 현실 세계 프로젝트에 참여하게 되었습니다. 그 중 하나는 선도적인 전자 상거래 플랫폼 인 Myntra의 리디자인 작업이었습니다. 이 프로젝트는 사용자 경험을 모든 각도에서 고려하도록 나를 도전했고, 결과적으로 기능적이면서 시각적으로 매력적인 리디자인을 이끌어 냈습니다.\n\n[Behance 링크](behance link)\n\nSteerX는 자동차 시장에서 혁신적인 모바일 애플리케이션으로 돋보입니다. 자동차를 구매하고 판매하는 데에 탁월하고 직관적인 플랫폼을 제공합니다. 맞춤형 추천과 검색 필터를 갖춘 개인화된 접근 방식으로, 각 사용자가 완벽한 매치를 찾을 수 있도록 보장합니다. 플랫폼의 가장 돋보이는 기능은 매 사용자에게 제공되는 개인 가이드로, 전문적인 조언을 제공하고 최상의 경험을 보장합니다. 게다가, SteerX는 사용자들이 결정전에 기능을 탐색할 수 있도록 무료 20일 체험 기간을 제공합니다. 이것은 신뢰를 쌓을 뿐만 아니라 사용자들이 플랫폼을 완전히 경험하도록 격려합니다. 더불어, SteerX는 차량 구매 프로세스를 무난하게 만드는 집으로의 배달과 같은 편리한 서비스도 제공합니다.\n\n<div class=\"content-ad\"></div>\n\nSteerX의 UI/UX 디자인은 사용자 친화적이며 깔끔한 인터페이스로 쉬운 탐색을 가능하게 합니다. 이 앱의 디자인은 사용자가 원하는 것을 쉽게 찾아내고 거래를 원활하게 완료할 수 있도록 보장합니다. 또한 혁신적인 기능 중 하나는 사용자가 플랫폼과 상호 작용하여 포인트를 획득하고 할인 혜택과 보상으로 교환할 수 있는 \"자체 포인트 만들기\" 시스템입니다. 이 시스템은 사용자 참여를 유도하고 전체 사용자 경험을 향상시킵니다. 요약하면, SteerX는 모바일 애플리케이션에 그치지 않고 자동차 구매 및 판매 경험을 개인화된 접근법, 무료 평가 기간, 편리한 서비스 및 혁신적인 기능으로 재정의하는 자동차 시장의 혁명입니다.\n\n[myntra 링크]\n\n혁신적인 옷 구매 플랫폼인 Myntra를 재설계하는 도전은 사용자 경험을 재상상하는 흥미로운 기회였습니다. 도입한 주요 기능 중 하나는 사용자가 옷을 수거하여 새 드레스 구매에 대한 포인트를 획득할 수 있는 독특한 이니셔티브였습니다. 이 혁신적인 기능은 지속가능성을 촉진하는 데 그치지 않고 쇼핑 경험을 게임화하여 사용자 참여를 촉진했습니다.\n\n게다가 나는 전반적인 사용자 경험을 향상시키기 위해 내비게이션 메뉴를 보다 직관적이고 사용자 친화적으로 재디자인했습니다. 또한 매력적이고 정보를 제공하는 방식으로 제품을 전시하는 시각적으로 매력적인 제품 페이지를 작성하는 데 노력했습니다. 이러한 개선사항은 사용자에게 전체 쇼핑 경험을 향상시키고 플랫폼에서 상품을 더 쉽고 더 즐겁게 둘러보고 구매할 수 있도록 하는 것을 목표로 했습니다.\n\n<div class=\"content-ad\"></div>\n\n와인 포도밭\n\nVineValley는 고급스럽고 사용자 친화적인 웹사이트로, 탁월한 와인의 판매에 전념합니다. 저희의 디자인 미학은 우아함과 사용자 친화성을 결합하여 모든 방문객이 원활한 탐색 및 구매 경험을 즐길 수 있도록 보장합니다. VineValley에 접속하는 순간, 저희가 정성스럽게 선별한 와인들을 소개하는 시각적으로 매료하는 레이아웃이 환영합니다. 직관적인 내비게이션 메뉴로 다양한 와인 카테고리를 쉽게 탐색할 수 있어 어떤 행사에도 완벽한 병을 찾기 쉽습니다.\n\nVineValley에서 고급 와인의 세계를 탐험하고 즐기세요:\n\nVineValley에서는 와인을 구매하는 것이 즐거운 경험이어야 한다고 믿습니다. 따라서 외관 뿐만 아니라 기능 면에서도 매우 기능적인 웹사이트로 설계했습니다. 와인 전문가이든, 탐험을 하고자 하는 분이든, VineValley는 브라우징 및 와인 구매를 쉽게 만드는 사용자 친화적 인터페이스를 제공합니다. 제품 설명서, 고객 리뷰, 안전한 결제 옵션과 같은 기능으로 VineValley는 와인 구매 여정의 모든 측면이 즐거운 경험이 되도록 보장합니다. 모든 병이 이야기를 전하는 VineValley의 우아함과 편리함을 경험해보세요.\n\n<div class=\"content-ad\"></div>\n\n표를 Markdown 형식으로 변경해주세요.\n\n| The end.. |\n| behance |\n| dribble |\n| [dribbble link](https://dribbble.com/prem123423) |\n\n<div class=\"content-ad\"></div>\n\n결론적으로, 디자이너로서의 나의 여정은 아름다운 사용자 친화적 경험을 만들기 위한 헌신으로 정의되어 왔습니다. 웹사이트부터 UI 디자인까지, 각 프로젝트는 나의 디자이너로서成長하는 과정에서의 발파석이었습니다. 새로운 아이디어를 탐구하고 사용자들을 위한 의미있는 경험을 만들기 위해 디자인의 경계를 넓히는 이 여정을 계속하기를 고대하고 있습니다.","ogImage":{"url":"/assets/img/2024-05-18-MyJourneyintoUIUXDesign_0.png"},"coverImage":"/assets/img/2024-05-18-MyJourneyintoUIUXDesign_0.png","tag":["Tech"],"readingTime":4},{"title":"CSS Flexbox 최신 레이아웃 디자인 안내","description":"","date":"2024-05-18 22:11","slug":"2024-05-18-CSSFlexboxGuidetoModernLayoutDesign","content":"\n\n<table>\n\n<img src=\"/assets/img/2024-05-18-CSSFlexboxGuidetoModernLayoutDesign_0.png\" />\n\n소개:\n\n현대 웹 개발 분야에서는 유연하고 반응형 레이아웃을 만드는 것이 모든 형태와 크기의 디바이스에서 매력적인 사용자 경험을 전달하는 데 중요합니다. 이를 달성하기 위한 개발자의 가장 강력한 도구 중 하나가 CSS Flexbox입니다. 이 포괄적인 가이드에서는 Flexbox의 기본 개념과 핵심 원칙, 그리고 실용적인 예제를 탐구하여 이 다재다능한 레이아웃 모델을 숙달할 수 있도록 도와드리겠습니다.\n\nFlexbox 이해하기: Flexbox는 유연하고 동적인 레이아웃을 쉽게 만들기 위해 설계된 CSS 레이아웃 모델입니다. 전통적인 레이아웃 방법인 플롯(floats)과 포지셔닝과는 달리 Flexbox는 공간을 효율적으로 분배하고 컨테이너 내 요소를 정렬하기 위한 더 효율적인 방법을 제공합니다. 개발자는 플렉스 컨테이너와 플렉스 아이템의 조합을 활용하여 다양한 화면 크기와 방향에 대응하는 복잡한 레이아웃을 구현할 수 있습니다.\n\n</table>\n\n<div class=\"content-ad\"></div>\n\nKey Concepts of Flexbox:\n\n- Flex Containers: When the display property of a container is set to \"flex\" or \"inline-flex,\" it becomes a flex container. Flex containers can adjust the layout and alignment of their child elements, which are referred to as flex items.\n\n- Flex Items: Elements inside a flex container are known as flex items. These items can be positioned horizontally or vertically, rearranged, resized, and aligned within the container using Flexbox properties.\n\n# Exploring Flexbox Properties:\n\n<div class=\"content-ad\"></div>\n\n- Flex Direction: flex 컨테이너 내에서 flex 항목이 배치되는 기본 축을 결정하여 수평 (행) 또는 수직 (열) 정렬이 가능합니다.\n- Justify Content: flex 컨테이너의 주 축을 따라 flex 항목의 정렬을 제어하여 공간을 항목 사이에 고르게 분배하거나 주위로 배치할 수 있습니다.\n- Align Items 및 Align Self: flex 컨테이너의 교차 축을 따라 flex 항목을 개별적으로 (align self) 또는 집합적으로 (align items) 정렬합니다.\n- Flex Wrap: 공간이 제한될 때 flex 항목이 flex 컨테이너 내에서 여러 줄로 줄 바꿈해야 하는지 여부를 지정합니다.\n- Flex Grow, Flex Shrink 및 Flex Basis: flex 항목이 flex 컨테이너 내에서 어떻게 성장하고 축소되며 초기 크기를 설정할지 결정하여 사용 가능한 공간에 따라 동적으로 크기 조정이 가능합니다.\n\n실제 예시:\n\n- 반응형 내비게이션 메뉴 만들기:\n\n```js\n<nav class=\"menu\">\n  <a href=\"#\">Home</a>\n  <a href=\"#\">About</a>\n  <a href=\"#\">Services</a>\n  <a href=\"#\">Contact</a>\n</nav>\n```\n\n<div class=\"content-ad\"></div>\n\n```css\n.menu {\n  display: flex;\n  justify-content: space-around;\n}\n```\n\n2. 유연한 카드 레이아웃 구축\n\n```html\n<div class=\"card-container\">\n  <div class=\"card\">카드 1</div>\n  <div class=\"card\">카드 2</div>\n  <div class=\"card\">카드 3</div>\n</div>\n```\n\n```css\n.card-container {\n  display: flex;\n  flex-wrap: wrap;\n}\n.card {\n  flex: 1 1 300px; /* Flex-grow, flex-shrink, flex-basis */\n  margin: 10px;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n3. 동일한 높이 열 구현:\n\n```js\n<div class=\"container\">\n  <div class=\"column\">Column 1</div>\n  <div class=\"column\">Column 2</div>\n  <div class=\"column\">Column 3</div>\n</div>\n```\n\n```js\n.container {\n  display: flex;\n}\n\n.column {\n  flex: 1;\n  margin: 0 10px;\n}\n```\n\n최상의 관행과 고려 사항:\n\n<div class=\"content-ad\"></div>\n\n- 오래된 브라우저들이 Flexbox를 완전히 지원하지 않을 수도 있는 브라우저 지원 및 대체 방법에 대한 이해\n- CSS Grid와 같은 다른 레이아웃 모델과 함께 사용하여 더 복잡하고 반응형 디자인을 만드는 법\n- 다양한 디바이스와 화면 크기 간에 레이아웃을 테스트하여 일관된 렌더링 및 사용자 경험을 보장하는 법\n\n결론:\n\nCSS Flexbox는 개발자들에게 유연하고 반응형 레이아웃을 만들기 위한 강력하고 직관적인 방법을 제공하여 현대 웹 디자인에 필수적인 도구가 됩니다. Flexbox의 주요 개념과 속성을 숙달함으로써, 계속 바뀌는 디지털 환경에 매끄럽게 적응하는 동적이고 시각적으로 매력적인 인터페이스를 만드는 끝없는 가능성을 찾아낼 수 있습니다. 그래서 프로젝트에서 Flexbox를 적극적으로 활용하고 레이아웃 디자인 기술을 더 높은 수준으로 끌어올려보세요!\n\n더 많은 자료를 원하신다면 여기에서 Flex로 놀아볼 수 있는 링크가 있습니다:","ogImage":{"url":"/assets/img/2024-05-18-CSSFlexboxGuidetoModernLayoutDesign_0.png"},"coverImage":"/assets/img/2024-05-18-CSSFlexboxGuidetoModernLayoutDesign_0.png","tag":["Tech"],"readingTime":4},{"title":"Tailwind에서 동적 색상 테마사용하는 방법","description":"","date":"2024-05-18 22:10","slug":"2024-05-18-TailwindDynamicColorThemeSolutions","content":"\n\n<img src=\"/assets/img/2024-05-18-TailwindDynamicColorThemeSolutions_0.png\" />\n\n안녕하세요! Tailwind를 사용하여 더 나은 색상 관리를 위한 테마 솔루션을 온라인으로 찾아보았지만 많은 것을 찾지 못했습니다. 그래서 이 문제에 부딪히는 다른 사람들을 돕기 위해 이 기사에 찾은 솔루션을 문서화하고 있어요.\n\n# 문제점\n\n- Tailwind는 주로 밝은(light)과 어두운(dark) 두 가지 색상 테마만 지원합니다. 대부분의 경우 이것으로 충분하지만, 프로젝트에 대해 더 많은 옵션과 사용자 정의를 찾고 계시다면 이것만으로는 충분하지 않을 수 있어요.\n- 어두운 테마 스타일은 html 파일에 개별적으로 정의되어야 하므로 모든 색상 선택지가 css에서 두 번 반복되는 느낌을 주고 유지보수가 어렵게 만들 수 있어요.\n- CSS 변수의 사용은 가능하지만, 중요한 단점이 있습니다: 불투명 클래스(예: bg-primary/50)는 '원시' hsl이나 rgb로 정의되지 않는 한 더 이상 작동하지 않을 것입니다(예: — color-primary: 0 0 100;). 또한 css 변수를 사용하면 tailwind의 내장 색상을 재사용하거나 자체 JSON 객체를 사용하여 정의할 수 없어요.\n\n<div class=\"content-ad\"></div>\n\n여기 내가 생각한 해결책이 두 가지 있어.\n\n## 해결책 1: 테마 파일 사용\n\n여기 단순한 해결책이 있어. 개발 중에 컬러 팔레트를 테스트하는 데 충분한 추상화만 사용하면서 코드에서 그 색상에 멋진 의미론적 접근 방식을 제공해. 보너스로 테일윈드 구성 파일에서 CSS 변수 대신에 색상 스왓치 미리보기를 VScode에서 볼 수 있어.\n\n테일윈드 구성 파일:\n\n<div class=\"content-ad\"></div>\n\n```js\n//tailwind.config.js\n/** @type {import('tailwindcss').Config} */\n\nimport { colors, getNeutral, getThemeColors } from './src/styles/theme'\n\nmodule.exports = {\n  content: [\n    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',\n    './src/components/**/*.{js,ts,jsx,tsx,mdx}',\n    './src/app/**/*.{js,ts,jsx,tsx,mdx}',\n  ],\n  darkMode: 'class',\n  theme: {\n    extend: {\n      colors: {\n        dark: getNeutral('dark'),\n        light: getNeutral('light'),\n        neutral: getThemeColors(colors.neutral),\n        brand: getThemeColors(colors.brand),\n        success: getThemeColors(colors.success),\n        warn: getThemeColors(colors.warn),\n        danger: getThemeColors(colors.danger),\n        info: getThemeColors(colors.info),\n      },\n    },\n  },\n  plugins: [],\n}\n```\n\nTheme file:\n\n```js\n//theme.js\nconst tailwindColors = require('tailwindcss/colors')\n\nconst darkShade = 600\nconst lightShade = 300\nconst defaultShade = 500\nconst neutralLightShade = 50\nconst neutralDarkShade = 950\n\nexport const colors = {\n  neutral: tailwindColors.slate,\n  brand: tailwindColors.violet,\n  success: tailwindColors.teal,\n  warn: tailwindColors.orange,\n  danger: tailwindColors.red,\n  info: tailwindColors.cyan,\n}\n\nexport const getThemeColors = color => {\n  return {\n    DEFAULT: color[defaultShade],\n    l: color[lightShade],\n    d: color[darkShade],\n    ...color,\n  }\n}\n\nexport const getNeutral = shade => {\n  return shade === 'light' ? neutralLightShade : shade === 'dark' ? neutralDarkShade : colors.neutral[shade]\n}\n```\n\nUsing this solution may have some drawbacks. The process of setting up dark mode, while somewhat improved, still involves some complexity. Additionally, managing text visibility over colored backgrounds is manageable but finding a semantically sensible solution can be challenging.\n\n<div class=\"content-ad\"></div>\n\n# 해결책 2: CSS 변수 사용\n\n이 해결책은 아주 쉽고 직관적이지만, 몇 가지 단점이 있어서 난 어렵게 느껴져서 전환하기 어렵습니다. 이 해결책의 좋은 버전은 shadcn이 제공하고 그의 UI 해결책에서 사용되는 것입니다 (여기서 그의 예제 저장소를 확인해보세요)\n\nTailwind 구성 파일:\n\n```js\n// tailwind.config.js\n\nconst { fontFamily } = require(\"tailwindcss/defaultTheme\")\n\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: [\n    \"./app/**/*.{ts,tsx}\",\n    \"./components/**/*.{ts,tsx}\",\n    \"./ui/**/*.{ts,tsx}\",\n    \"./content/**/*.{md,mdx}\",\n  ],\n  darkMode: [\"class\"],\n  theme: {\n    container: {\n      center: true,\n      padding: \"2rem\",\n      screens: {\n        \"2xl\": \"1400px\",\n      },\n    },\n    extend: {\n      colors: {\n        border: \"hsl(var(--border))\",\n        input: \"hsl(var(--input))\",\n        ring: \"hsl(var(--ring))\",\n        background: \"hsl(var(--background))\",\n        foreground: \"hsl(var(--foreground))\",\n        primary: {\n          DEFAULT: \"hsl(var(--primary))\",\n          foreground: \"hsl(var(--primary-foreground))\",\n        },\n        secondary: {\n          DEFAULT: \"hsl(var(--secondary))\",\n          foreground: \"hsl(var(--secondary-foreground))\",\n        },\n        destructive: {\n          DEFAULT: \"hsl(var(--destructive))\",\n          foreground: \"hsl(var(--destructive-foreground))\",\n        },\n        muted: {\n          DEFAULT: \"hsl(var(--muted))\",\n          foreground: \"hsl(var(--muted-foreground))\",\n        },\n        accent: {\n          DEFAULT: \"hsl(var(--accent))\",\n          foreground: \"hsl(var(--accent-foreground))\",\n        },\n        popover: {\n          DEFAULT: \"hsl(var(--popover))\",\n          foreground: \"hsl(var(--popover-foreground))\",\n        },\n        card: {\n          DEFAULT: \"hsl(var(--card))\",\n          foreground: \"hsl(var(--card-foreground))\",\n        },\n      },\n      borderRadius: {\n        lg: `var(--radius)`,\n        md: `calc(var(--radius) - 2px)`,\n        sm: \"calc(var(--radius) - 4px)\",\n      },\n      fontFamily: {\n        sans: [\"var(--font-sans)\", ...fontFamily.sans],\n        heading: [\"var(--font-heading)\", ...fontFamily.sans],\n      },\n      keyframes: {\n        \"accordion-down\": {\n          from: { height: 0 },\n          to: { height: \"var(--radix-accordion-content-height)\" },\n        },\n        \"accordion-up\": {\n          from: { height: \"var(--radix-accordion-content-height)\" },\n          to: { height: 0 },\n        },\n      },\n      animation: {\n        \"accordion-down\": \"accordion-down 0.2s ease-out\",\n        \"accordion-up\": \"accordion-up 0.2s ease-out\",\n      },\n    },\n  },\n  plugins: [require(\"tailwindcss-animate\"), require(\"@tailwindcss/typography\")],\n}\n```\n\n<div class=\"content-ad\"></div>\n\n![Tailwind Dynamic Color Theme Solutions](/assets/img/2024-05-18-TailwindDynamicColorThemeSolutions_1.png)\n\nGlobal CSS File:\n\n```css\n/* global.css */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  :root {\n    --background: 0 0% 100%;\n    --foreground: 222.2 47.4% 11.2%;\n\n    --muted: 210 40% 96.1%;\n    --muted-foreground: 215.4 16.3% 46.9%;\n\n    --popover: 0 0% 100%;\n    --popover-foreground: 222.2 47.4% 11.2%;\n\n    --border: 214.3 31.8% 91.4%;\n    --input: 214.3 31.8% 91.4%;\n\n    --card: 0 0% 100%;\n    --card-foreground: 222.2 47.4% 11.2%;\n\n    --primary: 222.2 47.4% 11.2%;\n    --primary-foreground: 210 40% 98%;\n\n    --secondary: 210 40% 96.1%;\n    --secondary-foreground: 222.2 47.4% 11.2%;\n\n    --accent: 210 40% 96.1%;\n    --accent-foreground: 222.2 47.4% 11.2%;\n\n    --destructive: 0 100% 50%;\n    --destructive-foreground: 210 40% 98%;\n\n    --ring: 215 20.2% 65.1%;\n\n    --radius: 0.5rem;\n  }\n\n  .dark {\n    --background: 224 71% 4%;\n    --foreground: 213 31% 91%;\n\n    --muted: 223 47% 11%;\n    --muted-foreground: 215.4 16.3% 56.9%;\n\n    --accent: 216 34% 17%;\n    --accent-foreground: 210 40% 98%;\n\n    --popover: 224 71% 4%;\n    --popover-foreground: 215 20.2% 65.1%;\n\n    --border: 216 34% 17%;\n    --input: 216 34% 17%;\n\n    --card: 224 71% 4%;\n    --card-foreground: 213 31% 91%;\n\n    --primary: 210 40% 98%;\n    --primary-foreground: 222.2 47.4% 1.2%;\n\n    --secondary: 222.2 47.4% 11.2%;\n    --secondary-foreground: 210 40% 98%;\n\n    --destructive: 0 63% 31%;\n    --destructive-foreground: 210 40% 98%;\n\n    --ring: 216 34% 17%;\n\n    --radius: 0.5rem;\n  }\n}\n\n@layer base {\n  * {\n    @apply border-border;\n  }\n  body {\n    @apply bg-background text-foreground;\n    font-feature-settings: \"rlig\" 1, \"calt\" 1;\n  }\n}\n```\n\nThe advantages of using a solution like this one are that not only the styling will be quicker to write as we don’t need to manage our dark theme with Tailwind, but we also can create as many themes as we want based on any class or selector we want.\n\n\n<div class=\"content-ad\"></div>\n\n큰 단점은 Tailwind의 투명도 기능을 유지하기 위해서는 원시 rbg 또는 hsl 코드를 사용해야 하므로 읽기가 훨씬 어려워진다는 것입니다. 이 방식으로는 색상 관리가 쉽거나 직관적이지 않지만, 한 가지 해결책은 루트에서 의미 있는 색상 변수를 정의한 다음에 테마에서 사용하는 것입니다:\n\n```js\n/* global.css */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  :root {\n\n    --gray-hsl--50: 0 0% 100%;\n    --gray-hsl--950: 222.2 47.4% 11.2%;\n\n    --background: var(--gray-hsl--50);\n    --foreground: var(--gray-hsl--950);\n\n  /* ... */\n  }\n\n  .dark {\n    --background: var(--gray-hsl--950);\n    --foreground: var(--gray-hsl--50);\n\n   /* ... */\n  }\n}\n\n/* ... */\n```\n\n# 기타 해결책\n\n몇 가지 더 선택지가 떠오르지만, 나중에 이곳에 작성할 수도 있지만, 지금은 이 2가지 솔루션이 동적으로 색상 테마를 관리하기 위해 찾은 최상의 해결책입니다.","ogImage":{"url":"/assets/img/2024-05-18-TailwindDynamicColorThemeSolutions_0.png"},"coverImage":"/assets/img/2024-05-18-TailwindDynamicColorThemeSolutions_0.png","tag":["Tech"],"readingTime":9},{"title":"잘 알려지지 않은 CSS 팁 10가지","description":"","date":"2024-05-18 22:08","slug":"2024-05-18-10lesserknownCSStrickspart8","content":"\n\n![이미지](/assets/img/2024-05-18-10lesserknownCSStrickspart8_0.png) \n\n10가지 잘 알려지지 않은 CSS 트릭 시리즈의 여덟 번째 파트에 오신 것을 환영합니다. 이미 느끼고 계신 분들도 있겠지만, 만약 여기 처음 오신 분들이라면 이전 게시물을 보지 않으셨다면... 안녕하세요! 저는 10가지 잘 알려지지 않은 CSS 트릭 목록을 만들었어요 (지금까지 70가지를 소개했고, 이번을 끝으로 80가지 트릭 모음이 완성될 거에요). 이번 트릭들이 웹 디자인 역량 향상에 도움이 되길 바래요.\n\n## 01. scroll-snap-align\n\nscroll-snap-align 속성은 스크롤 컨테이너 내에서 스크롤 스냅 지점의 정렬을 제어하여 스크롤 동작을 정확하게 제어하고 사용자 경험을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n```css\n.container {\n  scroll-snap-type: x mandatory;\n}\n\n.item {\n  scroll-snap-align: center;\n}\n```\n\n## 02. overscroll-behavior\n\noverscroll-behavior를 사용하면 브라우저가 스크롤 초과를 처리하는 방식을 정의하여 원치 않는 스크롤 효과를 방지하고 전체 스크롤 경험을 개선할 수 있습니다.\n\n```css\n.scrollable {\n  overscroll-behavior: contain;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 03. font-kerning\n\nfont-kerning은 문자 간 간격을 미세하게 조정하여 텍스트 요소 내 문자 간 간격을 조정하여 최적의 가독성을 보장합니다.\n\n```js\np {\n  font-kerning: auto;\n}\n```\n\n## 04. shape-margin\n\n<div class=\"content-ad\"></div>\n\n함께 사용할 때 CSS 모양과 shape-margin은 부유 요소의 모양 주변에 여백을 지정하여 텍스트 감싸기와 레이아웃을 미세하게 제어할 수 있습니다.\n\n```js\n.shape {\n  shape-margin: 20px;\n}\n```\n\n## 05. scroll-margin\n\nscroll-margin은 스크롤링 컨테이너의 가장자리와 스크롤링 콘텐츠 시작 사이의 여백을 설정하여 스크롤링을 위한 버퍼 공간을 제공하여 사용자 경험을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n```css\n.container {\n  scroll-margin-top: 100px;\n}\n```\n\n## 06. tab-size\n\nscroll-margin은 스크롤링 컨테이너의 가장자리와 스크롤링 콘텐츠의 시작 사이의 여백을 설정하여 스크롤링에 대한 버퍼 공간을 제공하여 사용자 경험을 향상시킵니다.\n\n```css\npre {\n  tab-size: 4;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 07. text-align-last\n\ntext-align-last은 블록 요소 내 텍스트의 마지막 줄 맞춤을 결정하여, 다중 줄 블록에서 텍스트 정렬을 정밀하게 제어합니다.\n\n```js\np {\n  text-align-last: justify;\n}\n```\n\n## 08. text-justify\n\n<div class=\"content-ad\"></div>\n\n이 속성은 텍스트 맞춤 동작을 제어하며, 텍스트 맞춤에 대해 단어 간 간격 또는 글자 간 간격을 사용해야 하는지를 지정합니다.\n\n```js\np {\n  text-align: justify;\n  text-justify: inter-word;\n}\n```\n\n## 09. column-fill\n\ncolumn-fill은 콘텐츠가 다중 열 레이아웃 전체에 분배되는 방식을 지시하여, 콘텐츠가 열 사이에 순차적으로 또는 균형있게 분배되도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n```css\n.container {\n  column-count: 3;\n  column-fill: auto;\n}\n```\n\n## 10. outline-offset\n\noutline-offset 속성은 윤곽선과 요소 가장자리 사이의 간격을 조정하여 레이아웃에 영향을 주지 않고 윤곽선의 모양을 미세하게 제어할 수 있게 합니다.\n\n```css\nbutton {\n  outline: 2px solid blue;\n  outline-offset: 4px;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 읽어 주셔서 감사합니다\n\n- 👏 이야기에 박수를 보내주세요 (50번 클랩) - 기사를 더 많이 퍼지도록 도와주세요\n- ✉️ 독점 콘텐츠, 리소스 및 무료 선물을 위해 뉴스레터에 가입해주세요\n- 🤝 Buymeacoffee.com에서 커피 한 잔을 기부해주세요\n- 🔔 팔로우해주세요: Medium | X | LinkedIn\n- 📝  매월 5달러로 Medium 멤버십 프로그램에 가입하고 저와 다른 작가들이 멋진 작품을 이어나갈 수 있도록 지원해주세요","ogImage":{"url":"/assets/img/2024-05-18-10lesserknownCSStrickspart8_0.png"},"coverImage":"/assets/img/2024-05-18-10lesserknownCSStrickspart8_0.png","tag":["Tech"],"readingTime":3},{"title":"SASS로 웹사이트 스타일링 하는 방법","description":"","date":"2024-05-18 22:07","slug":"2024-05-18-SASSFundamentals","content":"\n\n![그림](/assets/img/2024-05-18-SASSFundamentals_0.png)\n\n시대적으로 멋진 스타일 시트(SASS)는 전처리기 스크립팅 언어로 해석되거나 컴파일되어 캐스케이딩 스타일 시트(CSS)로 변환됩니다. 이를 통해 CSS에 기능과 능력이 추가되어 웹 페이지 스타일링이 더욱 강력하고 효율적으로 이루어집니다.\n\n시작하기 전에 SASS와 SCSS의 차이를 파악하는 것이 중요합니다.\n\n들여쓰기 구문으로 알려진 SASS는 코드 블록을 구분하기 위해 공백과 들여쓰기를 활용합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n//SASS \n$primaryColor: #fff\n.myclass\n  color: $primaryColor\n```\n\n한편, SASS의 진화인 SCSS는 CSS에 더 가까운 구문을 채택하여 중괄호와 세미콜론을 활용합니다.\n\n```js\n// SCSS\n$primaryColor: #fff\n.myclass{\n  color: $primaryColor ;\n}\n```\n\n이로써 SCSS는 CSS에 익숙한 개발자들에게 더 친숙하며, 두 언어 간의 전환을 쉽게 만들어 줍니다.\n\n<div class=\"content-ad\"></div>\n\n변수의 힘을 이용하기:\n\nSass의 주요 기능 중 하나는 변수를 지원하며, 이를 사용하여 개발자가 스타일시트 전반에 걸쳐 재사용 가능한 값을 정의할 수 있습니다. 색상, 글꼴 및 기타 일반적인 속성에 대한 변수를 선언함으로써, 개발자는 프로젝트 전체에서 유지 관리성을 향상시키고 일관성을 확보할 수 있습니다. 예를 들어, 개발자가 여러 번 16진 코드나 글꼴 이름을 반복하지 않고, 변수를 참조함으로써 전역 스타일을 간편하게 업데이트할 수 있게 됩니다.\n\n```js\n$fontStack: Helvetica, sans-serif;\n$primaryColor: #fff;\n\nbody {\n  font: 10px $fontStack;\n  color: $primaryColor;\n}\n```\n\n<div class=\"content-ad\"></div>\n\nSass의 중첩 기능을 사용하면 개발자가 CSS 규칙을 계층적으로 구성하여 HTML 요소의 구조를 반영할 수 있습니다. 이는 가독성을 향상시키고 코드의 반복을 줄이는데 도움이 됩니다. 서로 중첩된 선택기를 사용하여 개발자는 더 간결하고 구조화된 스타일 시트를 만들 수 있습니다. 그러나 네스팅을 사용할 때는 과도하게 구체적이거나 부풀어 올라간 CSS 출력을 생성하지 않도록 주의해야 합니다.\n\n```js\n.button { \n  &:visited {\n      color: blue;\n    } \n  &:hover {\n      color: red;\n    } \n  &:active {\n      color: yellow;\n    } \n}\n```\n\n믹신을 활용하여 재사용성 향상하기:\n\n믹신은 Sass의 또 다른 강력한 기능으로, 재사용 가능한 스타일과 동작을 캡슐화할 수 있게 해줍니다. 그레디언트, 전환, 또는 애니메이션과 같은 일반적인 패턴에 대한 믹신을 정의함으로써 개발자는 코드를 중복하지 않고 여러 요소에 이러한 스타일을 쉽게 적용할 수 있습니다. 믹신은 인수를 받아들일 수도 있어 더 큰 유연성과 사용자 정의가 가능합니다. 이는 코드 재사용을 촉진하고 유지 관리를 간편화하여 효율적인 개발 워크플로를 이끌어냅니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n@mixin theme($theme: DarkGray) {\n  background: $theme;\n  box-shadow: 0 0 1px rgba($theme, .25);\n  color: #fff;\n}\n```\n\n이 예시에서는 기본값이 DarkGray인 $theme라는 선택적 인수를 가지는 theme이라는 mixin을 만들었습니다. 이 mixin은 $theme의 값에 기반하여 배경색, 그림자 박스 및 텍스트 색상을 설정합니다.\n\n해당 mixin을 사용하려면, 스타일에서 @include를 사용하고 필요한 인수를 전달하면 됩니다. 다음은 예시입니다:\n\n```js\n.info {\n  @include theme;\n}\n\n.alert {\n  @include theme($theme: DarkRed);\n}\n\n.success {\n  @include theme($theme: DarkGreen);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 세 가지 다른 클래스에 테마 mixin을 적용했습니다: .info, .alert 및 .success입니다. .info 클래스는 $theme의 기본 값을 사용하고, .alert 및 .success 클래스는 각각 $theme에 대한 고유한 값을 전달합니다.\n\nSASS를 CSS로 컴파일하면 다음과 같은 결과물이 나타납니다:\n\n```js\n.info {\n  background: DarkGray;\n  box-shadow: 0 0 1px rgba(169, 169, 169, 0.25);\n  color: #fff;\n}\n\n.alert {\n  background: DarkRed;\n  box-shadow: 0 0 1px rgba(139, 0, 0, 0.25);\n  color: #fff;\n}\n\n.success {\n  background: DarkGreen;\n  box-shadow: 0 0 1px rgba(0, 100, 0, 0.25);\n  color: #fff;\n}\n```\n\n컨트롤 지시문으로 제어를 향상시키기:\n\n<div class=\"content-ad\"></div>\n\nSass는 @if, @else, @for 및 @each와 같은 제어 지시문을 제공합니다. 이를 통해 개발자들은 조건과 반복을 기반으로 한 동적 스타일 시트를 생성할 수 있습니다. 이러한 지시문은 CSS 생성에 대한 더 큰 제어를 제공하여 개발자들이 표현력 있고 효율적인 코드를 작성할 수 있게 합니다. 예를 들어, 개발자들은 @for 반복문을 사용하여 증가하는 값으로 스타일의 시리즈를 생성하거나 @if문을 사용하여 특정 조건에 따라 다른 스타일을 적용할 수 있습니다.\n\n```js\n$type: primary;\nh1 {\n  @if $type == secondary {\n    color: blue;\n  } @else if $type == tertiary {\n    color: red;\n  } @else if $type == primary {\n    color: green;\n  } @else {\n    color: black;\n  }\n}\n```\n\n결론:\n\nSass는 웹 개발 세계에서 게임 체인저로 떠오르며, 개발자들에게 CSS 작업을 간소화하고 유지 보수가능한 스타일 시트를 생성하는 강력한 도구 세트를 제공합니다. Sass의 기본을 숙달하면 변수, 중첩, 믹스인, 제어 지시문 등을 통해 프로젝트에서 효율성과 생산성을 새로운 수준으로 끌어올릴 수 있습니다. 그래서 무엇을 기다리고 있나요? 지금 당장 Sass에 뛰어들어 웹 개발 기술을 새로운 레벨로 끌어올리세요!","ogImage":{"url":"/assets/img/2024-05-18-SASSFundamentals_0.png"},"coverImage":"/assets/img/2024-05-18-SASSFundamentals_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular를 사용한 Hexagonal 아키텍처","description":"","date":"2024-05-18 22:05","slug":"2024-05-18-HexagonalArchitecturewithAngular","content":"\n\n## Angular 앱에 육각형 아키텍처를 적용하는 방법을 보여주는 구체적인 예시입니다.\n\n![이미지](/assets/img/2024-05-18-HexagonalArchitecturewithAngular_0.png)\n\n# 요약\n\n- 소개\n- 완전하고 작동하는 예시\n- 구현 선택 사항\n- Angular에서의 육각형 아키텍처의 이점\n- 언제 Angular에서 육각형 아키텍처를 사용해야 하는가\n- 결론\n\n<div class=\"content-ad\"></div>\n\n# 1 — 소개\n\n오랜 시간 동안, 모델 뷰 컨트롤러는 소프트웨어 개발자들의 즐겨 사용하는 아키텍처였습니다. 이것은 백엔드에서 사용되었을 뿐 아니라 프론트엔드 코드에서도 사용되었습니다. 그러나 커뮤니티가 도메인 주도 설계에 대한 관심이 높아지면서, 이 아키텍처는 그 사촌인 \"헥사고널\" (또는 \"포트와 어댑터\") 아키텍처에 의해 도전을 받았습니다.\n\nMVC와 마찬가지로, 헥사고널 아키텍처는 분리 원칙을 사용하지만 더 많은 추상화를 포함하며, 도메인 코드가 아키텍처의 중심에 위치합니다.\n헥사고널 아키텍처에 대해 더 많은 정보를 원하신다면, 이 아키텍처의 설계자인 알리스터 코크번이 작성한 완전한 기사가 있습니다.\n\n현재 헥사고널 아키텍처는 대부분 백엔드 코드에서 사용되고 있으며, 특히 Angular에 대한 프론트엔드 코드에 대한 정보가 부족합니다.\n\n<div class=\"content-ad\"></div>\n\nAngular에서 여섯각형 아키텍처를 적용하는 방법은 무엇인가요? 이것이 유익할까요? 만약 이러한 질문에 관심이 있다면, 이 글을 읽어보세요.\n\n# 2 — 완전한, 작동하는 예시\n\n다음 설명은 내가 개발하고 Github에서 사용 가능한 예시 앱을 기반으로 합니다. 이 앱은 Angular의 영웅 투어를 기반으로 합니다. 앱을 실행하면 표시되는 인터페이스는 Angular 튜토리얼과 동일하지만 코드 구조는 매우 다릅니다. 이 작은 앱의 원칙은 영웅 목록을 표시하고(생성, 삭제, 수정) 관리하는 것입니다. 외부 API 호출을 시뮬레이트하기 위해 angular-in-memory-web-api 모듈이 사용됩니다.\n\n이 예시 아키텍처 개요입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Hexagonal Architecture with Angular](/assets/img/2024-05-18-HexagonalArchitecturewithAngular_1.png)\n\nAnd the associated code organization:\n\n![Hexagonal Architecture with Angular](/assets/img/2024-05-18-HexagonalArchitecturewithAngular_2.png)\n\n## Domain\n\n\n<div class=\"content-ad\"></div>\n\n헥사고널 아키텍처에서는 전체 도메인 관련 코드가 격리되어 있습니다. 히어로즈 앱은 다음과 같은 목적을 갖고 있습니다: 히어로 목록 표시, 특정 히어로에 대한 세부 정보 표시, 그리고 사용자가 수행한 작업 로그 표시. 도메인 관련 클래스는 아키텍처의 핵심입니다: HeroesDisplayer, HeoresDetailDisplayer, 그리고 MessagesDisplayer.\n\n## 포트\n\n도메인 관련 코드가 우리의 히어로즈 앱에서 홀로 있는 것은 상상하기 어렵습니다. Angular 컴포넌트에 해당하는 사용자 인터페이스 관련 코드와 Angular 서비스에 해당하는 외부 API 호출도 있습니다. 매 헥사고날 아키텍처에서 도메인 관련 코드는 이 모든 코드와 직접 상호작용하지 않습니다. 대신 포트라 불리는 객체를 사용하며, 인터페이스 클래스로 구현됩니다. 이렇게 하면 아키텍처의 요소들 간의 결합이 약해집니다.\n\n우리의 히어로즈 앱에서 HeroesDisplayer와 HeoresDetailDisplayer는 히어로 관련 상호작용을 저장하는 외부 서비스와 상호작용해야 합니다. 이를 위해 IManageHeroes 포트를 노출할 것입니다. 각 도메인 클래스에 대해 모든 사용자 상호작용을 기록하고 싶습니다. 이를 위해 IManageMessages 포트도 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n사용자들은 앱에서 실제 작업을 디스플레이 인터페이스를 통해 수행합니다. 이러한 인터페이스는 목적에 따라 여러 카테고리로 나눌 수 있습니다. Angular 투어 오브 히어로즈 앱과의 충실한 비교를 보장하기 위해 우리는 영웅을 표시하는 인터페이스(영웅 목록 및 대시보드), 영웅 세부 정보를 표시하는 인터페이스, 그리고 메시지를 표시하는 인터페이스가 있어야 합니다. 따라서 관련된 포트는 각각 IDisplayHeroes, IDisplayHeroDetail 및 IDisplayMessages여야 합니다.\n\n## 어댑터\n\n이제 포트들이 정의되었으니, 해당 포트에 어댑터를 연결해야 합니다. 헥사고날 아키텍처의 장점 중 하나는 어댑터 간 전환할 때 용이함입니다. 예를 들어, IManageHeroes에 연결된 어댑터는 REST API를 호출하는 어댑터일 수 있으며, GraphQL API를 사용하는 어댑터로 쉽게 교체할 수 있습니다. 우리의 경우, 앱을 Google 투어 오브 히어로즈 앱과 동일하게 만들고 싶습니다. 따라서 우리는 메모리 기반의 웹 API를 호출하는 Angular 서비스인 HeroAdapterService와, 메시지를 로컬로 저장하는 MessageAdapterService를 구현합니다.\n\n다른 세 포트에 대한 어댑터는 사용자 인터페이스 관련 어댑터입니다. 우리의 앱에서는 이러한 어댑터들이 Angular 컴포넌트로 구현될 것입니다. IDisplayHeroes 포트가 세 어댑터로 구현된 것을 확인할 수 있습니다. 자세한 내용은 다음에 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n위에서 설명한대로, 우리의 어댑터에는 그 특성 때문에 비대칭성이 있습니다. 아키텍처 다이어그램은 이를 다음과 같이 나타냅니다: 아키텍처의 왼쪽 어댑터는 사용자 상호작용을 위해 설계되었고, 오른쪽 어댑터는 외부 서비스 상호작용을 위해 설계되었습니다.\n\n# 3 — 구현 선택사항\n\n헥사고날 아키텍처는 백엔드 애플리케이션을 위해 설계되었기 때문에, 코드 구현에 일부 조치가 취해졌습니다. 이러한 선택사항은 다음 부분에서 설명될 것입니다.\n\n## 도메인 코드 내 Angular 관련 객체\n\n<div class=\"content-ad\"></div>\n\n호반 구조에서 좋은 실천 방법 중 하나는 도메인 관련 코드를 어떤 프레임워크에서도 독립적으로 유지하여 어댑터 유형에 대해 기능적이라는 것을 보증하는 것입니다. 하지만 저희 코드에서는 도메인이 Angular 및 rxjs 객체에 매우 의존적입니다. 사실, TypeScript나 JavaScript 프레임워크를 여러 개 사용하지 않을 것으로 가정할 수 있으며 인터페이스 일관성을 유지하기 위해서입니다. 또한, Angular 의존성 주입 시스템은 제어의 역전 원칙을 성취하는 데 매우 유용합니다. 그러나 rxjs Observable 대신 JavaScript Promises를 사용할 수 있어야 하지만, 우리 클래스에 많은 보일러플레이트 코드를 작성해야 할 것입니다.\n\n## Observable return type in left-side ports\n\n코드 뒤에 있는 로직이 도메인에서 처리되므로 IDisplayHeroDetail, IDisplayHeroes 및 IDisplayMessages 포트에서 Observable 객체를 반환하는 이유를 궁금해 할 수 있습니다. 실제로 서비스에서 반환된 각 객체는 도메인 코드 내에서 pipe와 tap 메서드를 사용하여 처리됩니다. 예를 들어, HeroAdapterService에서 반환된 히어로 상세 저장 결과는 직접 HeroDetailDisplayer에서 처리됩니다.\n\n그럼에도 불구하고 askHeroNameChange 메서드에서 빈 observable을 반환하는 것은 데이터가로드 된 시기를 인터페이스 어댑터가 알 수 있도록 하는 데 흥미로울 수 있습니다. 예를 들어, 히어로 상세 정보가 변경되었을 때, 이전 페이지로 돌아가도록 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 구현 선택의 단점은 좌측 측면 어댑터 내에서 각 도메인 함수 호출에 구독해야 하는 필요성입니다.\n\n## HeroesDisplayer 클래스가 두 번 인스턴스화됨\n\n우리 앱에서 의존성 주입은 app.module.ts에서 처리됩니다. 의존성 주입 토큰을 사용하여 Angular 컴포넌트 내에서 도메인 클래스에 액세스할 수 있습니다. 예를 들어 HeroDetail 컴포넌트로 IDisplayHeroDetail을 주입하는 방법은 다음과 같습니다:\n\nIDisplayHeroDetail 구현체로 HeroesDetailDisplayer 인스턴스 설정\n\n<div class=\"content-ad\"></div>\n\nHeroDetailComponent 안에 HeroDetailDisplayer를 삽입합니다.\n\n그러나 코드 어딘가에 섬세한 점이 있습니다: HeroesDisplayer 클래스를 위한 두 가지 다른 인젝션 토큰이 생성됩니다. 게다가 HeroesComponent와 DashboardComponent는 동일한 인젝션 토큰을 공유하며, HeroSearchComponent 구성 요소는 다른 토큰을 사용합니다.\n\nHeroesComponent와 DashboardComponent가 HeroesDisplayer의 동일한 인스턴스를 공유할 수 있는 이유는 그들이 동일한 영웅 목록을 표시하기 때문입니다. 반면에 HeroSearchComponent가 이 같은 인스턴스를 가진다면 각 검색이 표시된 영웅에 영향을 미칠 것입니다. 왜냐하면 HeroesDisplayer의 askHeroesFiltered 메소드에 의해 heroes 속성이 수정되기 때문입니다. 세 구성 요소에 대해 동일한 토큰을 공유한다면 우리 앱의 동작이 변경될 겁니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*8pOHcNceUxS-xw2uoGF4bg.gif)\n\n<div class=\"content-ad\"></div>\n\n# 4 — Angular에서의 육각형 아키텍처 이점\n\n육각형 아키텍처의 주요 본질은 서로 교환 가능한 어댑터를 갖고 있어 우리 앱이 사람, 시스템 또는 테스트에 의해 동일하게 구동될 수 있다는 점에 있습니다. 우리 앱은 Angular 프레임워크와 긴밀히 연결되어 있으므로 이 아키텍처 자산에서 전체적인 이점을 얻지 못하는 상황입니다. 그러나 앞단 코드에서 이를 경험함으로써 약간의 유망한 통찰을 얻었습니다.\n\n## 분리된 프레젠테이션 레이어, 코어 레이어 및 외부 서비스 호출\n\n코어 레이어에 해당하는 도메인 코드는 포트를 통해 명확하게 인터페이스 어댑터인 프레젠테이션 레이어와 분리됩니다. 이러한 포트 덕분에 외부 서비스 호출에 원치 않는 코드를 추가하는 위험이 줄어듭니다. 모든 핵심 로직은 도메인 클래스에서 처리됩니다.\n\n<div class=\"content-ad\"></div>\n\n도메인 클래스를 가져와 코드 레이어에 대응합니다.\n\n뷰 안에서 도메인 코드로 처리되는 히어로 정보를 사용하며, 프레젠테이션 레이어에 대응합니다.\n\n## 코드 인수화\n\n원래의 히어로 애플리케이션 투어를 살펴보면, HeroesComponent, HeroSearchComponent 및 DashboardComponent의 주요 목적이 매우 유사합니다. 모든 구성 요소는 히어로 목록을 표시하지만 구성 요소에 따라 가능한 상호 작용이 다릅니다. 따라서 표시된 정보에 대한 반환 서비스를 매핑하는 관련 핵심 코드를 인수화해야 합니다. 우리의 코드에서는 세 구성 요소에 대한 도메인 관련 코드를 인수화했습니다. 헥사고날 포트 재사용성을 활용했습니다.\n\n<div class=\"content-ad\"></div>\n\n## 테스트\n\n가끔은 Angular 테스트가 매우 고통스러울 수 있습니다. 특히 코어 코드가 컴포넌트 내의 프레젠테이션 코드와 섞여 있는 경우 더 그렇습니다. 이 코드는 응용 프로그램이 발전함에 따라 계속해서 늘어납니다. 디스플레이 컴포넌트, 도메인 코드 및 서비스를 서로 분리하여 유지하면 테스트가 더 간단해집니다. 다른 레이어를 쉽게 모의(mock)화할 수 있고 현재 클래스를 테스트하는 데 집중할 수 있습니다.\n\n히어로 세부 정보 디스플레이 테스트: 도메인 클래스와 메서드를 쉽게 모의화(mock)할 수 있습니다\n\n# 5 — Angular에서 헥사고날 아키텍처를 사용해야 하는 시점\n\n<div class=\"content-ad\"></div>\n\n비록 백엔드 코드와 완전하게 비교할 순 없지만, 헥사고날 아키텍처는 일부 프론트엔드 애플리케이션에서 매우 유용한 이점을 가질 수 있습니다. 특히 특정 사용 사례들은 이 아키텍처에 특히 적합해 보입니다.\n\n## 프로필 기반 앱\n\n프레젠테이션 레이어를 분리했기 때문에, 프로필 기반 앱과 같은 인터페이스 내에서 동일한 로직이 사용되는 애플리케이션은 우리의 아키텍처를 위한 좋은 후보입니다. 관리자 패널 브랜치는 어드민 패널 인터페이스를 추가했을 때 앱이 어떻게 보일지 예시를 제공합니다. 이 인터페이스는 어드민 사용자를 위해 설계되었으며, 단일 뷰 안에서 모든 관리 작업을 수행할 수 있습니다: 히어로 추가, 변경, 삭제 또는 검색. 히어로 앱에는 AdminPanelComponent만 추가되었고, 도메인 코드나 서비스 내부의 변경은 없으며 재사용 가능한 속성을 보여줍니다.\n\n관리자 인터페이스를 시작하려면, 관리자 패널 브랜치에서 npm run start:admin을 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n## 다중 외부 서비스를 호출하는 앱\n\n같은 목적을 제공하는 여러 외부 서비스에 연락해야 하는 경우 Angular 헥사고날 아키텍처를 채택할 수도 있습니다. 다시 한번, 도메인 코드의 재사용으로 작업을 간단하게 만들 수 있습니다. 예를 들어, 우리가 메모리에 있는 히어로 서비스 대신 온라인 서비스를 호출하려고 한다면 Yoann Cribier의 슈퍼히어로 API를 사용할 수 있습니다. `SuperheroApiAdapterService`를 추가하는 것만으로도 충분합니다. superhero-api 브랜치에서 확인할 수 있습니다.\n\n앱이 슈퍼히어로 API와 통신하도록 하려면 superhero-api 브랜치에서 `npm run start:superhero-api`를 실행하면 됩니다. 주의: 이 예시에서는 히어로 수정 및 삭제가 온라인 서비스에 구현되지 않았습니다.\n\n# 6 - 결론\n\n<div class=\"content-ad\"></div>\n\n이 작은 앱은 Angular 앱에 육각형 아키텍처를 적용할 수 있다는 것을 보여줍니다. 투어 오브 히어로즈 튜토리얼 앱에서 다루지 않은 일부 문제를 해결할 수 있습니다.\n\n읽어 주셔서 감사합니다!\n이 글을 즐겁게 보셨기를 바라며, 이 아키텍처 도입에 대한 어떠한 피드백도 매우 관심이 있습니다.\n\n또한, 이 글을 교정해 주신 Leila에게 감사드립니다.\n\n원문은 2022년 8월 10일에 https://dev.to에서 최초로 게시되었습니다.","ogImage":{"url":"/assets/img/2024-05-18-HexagonalArchitecturewithAngular_0.png"},"coverImage":"/assets/img/2024-05-18-HexagonalArchitecturewithAngular_0.png","tag":["Tech"],"readingTime":8},{"title":"RxJS Creation Operators 마스터하기","description":"","date":"2024-05-18 22:03","slug":"2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams","content":"\n\n반응형 프로그래밍은 현대 웹 개발에서 중요한 기반 기술이 되었으며 비동기 데이터 스트림을 처리하는 견고한 방법을 제공합니다. RxJS 또는 JavaScript용 반응형 익스텐션은 JavaScript에서 반응형 프로그래밍을 구현하는 가장 인기있는 라이브러리 중 하나입니다. 생성 연산자는 여러 기능 중에서도 관찰 가능한 스트림을 생성하는 데 필수적인 도구로 강조됩니다. 이 블로그 포스트에서는 다양한 RxJS 생성 연산자, 작동 방식 및 각각에 대한 실제 사용 사례를 살펴보겠습니다.\n\n![image](/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png)\n\n## RxJS 생성 연산자란?\n\n이러한 연산자는 다양한 데이터 소스에서 새로운 Observables를 생성합니다. 이러한 연산자는 개발자들이 작업할 데이터 스트림의 소스를 정의할 수 있도록 해주기 때문에 중요합니다. 이러한 연산자를 이해하는 것은 RxJS의 전체 기능을 최대한 활용하는 데 필수적입니다.\n\n<div class=\"content-ad\"></div>\n\n# Creation Operators 목록\n\n(참고: “⭐ — 일반적으로 사용됨”)\n\n- ⭐ajax: Ajax 요청을 위한 observable을 생성하는 데 사용됩니다.\n- bindCallback: 콜백 스타일 함수를 observable로 변환합니다.\n- bindNodeCallback: bindCallback과 유사하지만, Node.js 스타일 콜백(error-first)을 위한 것입니다.\n- defer: observable의 생성을 구독 지점까지 지연시킵니다.\n- empty: 어떤 값도 방출하지 않고 즉시 완료되는 observable을 생성합니다.\n- ⭐from: 다양한 다른 객체 및 데이터 유형을 observable로 변환합니다.\n- ⭐fromEvent: DOM 이벤트 대상 또는 Node.js EventEmitter에서 이벤트를 방출하는 observable을 생성합니다.\n- fromEventPattern: 주어진 addHandler/removeHandler 함수 쌍에서 observable을 생성합니다.\n- generate: 제공된 반복 함수에 기반하여 시간이 지남에 따라 값들을 생성합니다.\n- ⭐interval: 지정된 간격에서 증가하는 숫자를 방출하는 observable을 생성합니다.\n- ⭐of: 값의 시퀀스를 observable 시퀀스로 방출합니다.\n- range: 지정된 범위 내의 숫자 시퀀스를 방출합니다.\n- throwError: 오류를 방출하는 observable을 생성합니다.\n- timer: 지정된 지연 후 단일 값을 방출합니다.\n- iif: 두 가지 가능한 원본 observable 중 하나에 조건부로 구독합니다.\n\n이제 Creation Operator를 하나씩 검토하고 예제를 통해 학습하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# Ajax\n\nXMLHttpRequest API를 사용하여 HTTP 요청을 보냅니다.\n\n```js\n/* 실시간 사용 사례: 요청에서 반환되는 응답 객체를 방출하는 Observable */\nimport { ajax } from 'rxjs/ajax';\n\nconst githubUsers = `https://api.github.com/users?per_page=2`;\nconst users = ajax(githubUsers);\n\nconst subscribe = users.subscribe(\n  res => console.log(res),\n  err => console.error(err)\n);\n```\n\n```js\n/* 실시간 사용 사례: 요청에서 반환되는 응답 객체의 json 키만 방출하는 Observable */\nimport { ajax } from 'rxjs/ajax';\n\nconst githubUsers = `https://api.github.com/users?per_page=2`;\nconst users = ajax.getJSON(githubUsers);\n\nconst subscribe = users.subscribe(\n  res => console.log(res),\n  err => console.error(err)\n);\n```  \n\n<div class=\"content-ad\"></div>\n\n# bindCallback\n\n콜백 스타일의 함수를 Observable로 변환합니다.\n\n```js\n/* 실시간 사용 사례: jQuery의 getJSON을 Observable API로 변환하는 방법 */\n\nimport { bindCallback } from 'rxjs';\nimport * as jQuery from 'jquery';\n\nconst getJSONAsObservable = bindCallback(jQuery.getJSON);\nconst result = getJSONAsObservable('/my/url');\nresult.subscribe(x => console.log(x), e => console.error(e));\n```\n\n# bindNodeCallback\n\n<div class=\"content-ad\"></div>\n\n- 노드 스타일 콜백 함수를 Observable로 변환합니다.\n\n```js\n/* 실시간 사용 사례: 파일 시스템에서 파일 읽어오기 및 데이터를 Observable로 얻기 */\nimport { bindNodeCallback } from 'rxjs';\nimport * as fs from 'fs';\n\nconst readFileAsObservable = bindNodeCallback(fs.readFile);\nconst result = readFileAsObservable('./roadNames.txt', 'utf8');\n\nresult.subscribe(\n  x => console.log(x), // 파일 내용 처리\n  e => console.error(e) // 오류 처리\n);\n```\n\n- `defer`\n\nSubscriber가 Observable에 구독할 때까지 실행을 지연시키는 Observable를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\nRxJS에서 defer는 Observable을 생성하는 함수입니다. 주요 목적은 Observable이 구독될 때까지 Observable의 생성을 지연하는 것입니다. 이는 새로운 옵저버가 Observable을 구독할 때마다 설정 또는 초기화 논리가 실행되어야 하는 시나리오에서 유용합니다.\n\n```js\n/* 실시간 사용 사례: `of`를 사용하여 난수 생성 */\nimport { of, defer } from 'rxjs';\nconst randomOf$ = of(Math.random());\n\n// 랜덤 숫자 생성을 위해 `defer` 사용\nconst randomDefer$ = defer(() => of(Math.random()));\n\n// `randomOf$`를 여러 번 구독\nrandomOf$.subscribe(randomNumber => console.log('랜덤 숫자 (of):', randomNumber));\nrandomOf$.subscribe(randomNumber => console.log('랜덤 숫자 (of):', randomNumber));\nrandomOf$.subscribe(randomNumber => console.log('랜덤 숫자 (of):', randomNumber));\n\n// `randomDefer$`를 여러 번 구독\nrandomDefer$.subscribe(randomNumber => console.log('랜덤 숫자 (defer):', randomNumber));\nrandomDefer$.subscribe(randomNumber => console.log('랜덤 숫자 (defer):', randomNumber));\nrandomDefer$.subscribe(randomNumber => console.log('랜덤 숫자 (defer):', randomNumber));\n```\n\nOutput\n\n```js\n랜덤 숫자 (of): 0.123456789\n랜덤 숫자 (of): 0.123456789\n랜덤 숫자 (of): 0.123456789\n랜덤 숫자 (defer): 0.987654321\n랜덤 숫자 (defer): 0.654321987\n랜덤 숫자 (defer): 0.123456789\n```\n\n<div class=\"content-ad\"></div>\n\n# 빈\n\n빈 Observable을 생성하고 즉시 완료 콜백을 호출합니다.\n\nRxJS의 빈 연산자는 값을 방출하지 않고 즉시 완료되는 Observable을 생성합니다. 값이 방출될 필요가 없지만 완료를 신호해야 하는 경우에 유용합니다.\n\n```js\n/* 실시간 사용 사례: 빈 Observable 생성 */\nimport { empty } from 'rxjs';\nconst emptyObservable$ = empty();\n// 빈 Observable에 구독하기\nemptyObservable$.subscribe({\n  next: () => console.log('다음 값'), // 호출되지 않음\n  complete: () => console.log('완료됨') // 즉시 호출됨\n});\n```\n\n<div class=\"content-ad\"></div>\n\n# from\n\n배열, 프로미스, 이터러블 객체 또는 Observable과 유사한 객체에서 Observable을 생성합니다.\n\n```js\nimport { from } from 'rxjs';\nconst arraySource = from([1, 2, 3, 4, 5]);\nconst subscribe = arraySource.subscribe(val => console.log(val));\n//출력: 1, 2, 3, 4, 5\n```\n\n```js\nimport { from } from 'rxjs';\nconst source = from('Hello World');\nconst subscribe = source.subscribe(val => console.log(val));\n//출력: 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'\n```\n\n<div class=\"content-ad\"></div>\n\n\n```js\nconst numbers = from(new Promise((resolve, reject) => resolve('Hello World')));\nnumbers.subscribe((data) => {\n  console.log(data);\n});\n//output: Hello World\n```\n\n# fromEvent\n\n- 이벤트에서 Observable을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 사용자가 화면을 클릭할 때 시간 추적 */\nimport { fromEvent } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst source = fromEvent(document, 'click');\nconst example = source.pipe(map(event => event.timeStamp));\nconst subscribe = example.subscribe(val => console.log(`이벤트 시간: ${val / 1000} 초`));\n```\n\n<div class=\"content-ad\"></div>\n\n출력\n\n```js\n이벤트 시간: 5.418900000000373 초\n이벤트 시간: 7.552900000000372 초\n```\n\n# fromEventPattern\n\nfromEventPattern은 이벤트를 반환하는 함수에서 Observable을 생성합니다. fromEventPattern을 사용하면 이벤트 처리기 함수를 등록하는 API를 Observable로 변환할 수 있습니다. fromEvent과 유사하지만 훨씬 유연합니다. fromEvent의 모든 사용 사례는 fromEventPattern으로 쉽게 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 생성\n\n함수를 기반으로 값을 생성하는 옵저버블을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 숫자 시퀀스 생성 */\n\nimport { generate } from 'rxjs';\nconst result = generate(0, x => x < 3, x => x + 1, x => x);\nresult.subscribe(x => console.log(x));\n\n// 결과:\n// 0\n// 1\n// 2\n```\n\n# 간격\n\n<div class=\"content-ad\"></div>\n\n일정한 간격으로 정수 시퀀스를 방출하는 Observable을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 1초 간격으로 값 시퀀스를 방출 */\nimport { interval } from 'rxjs';\n\n// 1초마다 시퀀스 값 방출\nconst source = interval(1000);\nconst subscribe = source.subscribe(val => console.log(val));\n//결과: 0, 1, 2, 3, 4, 5....\n```\n\n# of\n\n- 지정된 값을 순서대로 방출하는 Observable을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { of } from 'rxjs';\n\nof(10, 20, 30)\n  .subscribe({\n    next: value => console.log('다음 값:', value),\n    error: err => console.log('에러 발생:', err),\n    complete: () => console.log('완료'),\n  });\n\n// 결과\n// 다음 값: 10\n// 다음 값: 20\n// 다음 값: 30\n// 완료\n```\n\n# range\n\n지정된 범위 내에서 숫자의 시퀀스를 방출하는 Observable을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 1에서 10까지 순차적으로 방출 */\n\nimport { range } from 'rxjs';\nconst source = range(1, 10);\nconst example = source.subscribe(val => console.log(val));\n// 출력: 1,2,3,4,5,6,7,8,9,10\n```\n\n<div class=\"content-ad\"></div>\n\n# throwError\n\n- 구독 시 오류를 발생시키는 Observable을 생성합니다.\n\n```js\n/* 구독 시 오류 발생 */\nimport { throwError } from 'rxjs';\n// 특정 값과 함께 오류를 발생시킵니다.\n\nconst source = throwError('오류 발생!');\n// 출력: 'Error: 오류 발생!'\n\nconst subscribe = source.subscribe({\n  next: val => console.log(val),\n  complete: () => console.log('완료!'),\n  error: val => console.log(`오류: ${val}`)\n});\n```\n\n# timer\n\n<div class=\"content-ad\"></div>\n\n- 특정 시간 간격 후에 발행을 시작하고 정수 시퀀스를 발행하는 Observable를 생성합니다.\n\n```js\n/* 실제 시나리오: 타이머는 1초 후에 발행을 시작하고 그 이후 매 2초마다 값을 발행합니다 */\n\nimport { timer } from 'rxjs';\n\n/*\n  timer 함수는 두 번째 인자를 가지며, 연속적으로 값들을 발행하는 빈도를 정의합니다.\n  이 경우, 1초 후에 첫 번째 값을 발행하고 그 이후 2초마다 값을 발행합니다.\n*/\nconst source = timer(1000, 2000);\n//출력: 0,1,2,3,4,5......\nconst subscribe = source.subscribe(val => console.log(val));\n```\n\n# iif\n\n조건에 따라 함수의 출력을 발행하는 Observable를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n/* Observable에 대한 액세스 제어 */\n\nimport { iif, of, EMPTY } from 'rxjs';\n \nlet accessGranted;\nconst observableIfYouHaveAccess = iif(\n  () => accessGranted,\n  of('액세스가 허용된 것 같아요...'),\n  EMPTY\n);\n \naccessGranted = true;\nobservableIfYouHaveAccess.subscribe({\n  next: value => console.log(value),\n  complete: () => console.log('끝')\n});\n \n// 출력:\n// '액세스가 허용된 것 같아요...'\n// '끝'\n \naccessGranted = false;\nobservableIfYouHaveAccess.subscribe({\n  next: value => console.log(value),\n  complete: () => console.log('끝')\n});\n \n// 출력:\n// '끝'\n```\n\n요약하면, RxJS Creation Operators는 JavaScript에서 반응형 프로그래밍의 기본 구성 요소입니다. 다양한 데이터 소스에서 Observable을 생성할 수 있게 해줌으로써, 이러한 연산자는 비동기 데이터 스트림을 효율적으로 처리할 수 있도록 개발자들을 지원합니다. API에서 데이터를 가져오는 ajax, 사용자 상호 작용에 반응하는 fromEvent, interval 및 timer를 사용하여 작업을 예약하는 등, 이러한 연산자들은 반응형 애플리케이션에서 데이터 흐름을 유연하고 강력하게 관리할 수 있는 방법을 제공합니다. 이러한 생성 연산자를 숙달하는 것은 RxJS의 모든 잠재력을 발휘하고 반응형 프로그래밍을 통한 반응형, 확장 가능하고 유지보수 가능한 애플리케이션을 구축하는 데 필수적입니다. 이 연산자들을 깊이 이해하고 그 기능을 실험하며, RxJS를 활용한 반응형 프로그래밍 마스터의 길에 나아가 보세요.\n\n즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png"},"coverImage":"/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png","tag":["Tech"],"readingTime":9},{"title":"Angular 17에서 Google 지도 통합하기","description":"","date":"2024-05-18 22:02","slug":"2024-05-18-IntegratingGoogleMapsinAngular17","content":"\n\n만약 당신이 Angular에서 Google 지도 컴포넌트를 사용해 왔다면, 2024년 2월 21일부로 Marker가 사용 중단되었다는 경고를 받은 적이 있을 것입니다. 새롭고 더 사용자 정의할 수 있는 Advanced Marker를 사용하도록 권장되었습니다.\n\n안타깝게도, Angular에서의 Advanced Marker 사용 방법에 대한 가이드나 정보가 많이 없으며, 대부분의 문서들은 여전히 구식 Marker를 사용하고 있습니다.\n\n그러나 이 기사에서는 기존 Angular 프로젝트를 업데이트해야 하는 경우든, 처음부터 해당 컴포넌트를 시도해보는 경우든 새로운 Advanced Marker를 어떻게 사용할 수 있는지 공유하겠습니다.\n\n그러면 시작해봅시다!\n\n<div class=\"content-ad\"></div>\n\n# 준비물\n\nAngular 프로젝트를 생성하기 전에 Google Maps JavaScript API를 사용하기 위한 유효한 API 키가 있는지 확인해주세요. 추가 지침은 아래 링크를 참조해주세요:\nhttps://developers.google.com/maps/documentation/javascript/get-api-key\n\n또한, 이 컴포넌트에 필요한 맵 ID도 필요합니다. 다음 링크를 따라서 얻을 수 있습니다:\nhttps://developers.google.com/maps/documentation/get-map-id\n\n만일 맵 ID를 가지고 있지 않거나 얻을 수 없다면, 구글에서 제공한 개발용 맵 ID를 사용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- Map ID = DEMO_MAP_ID\n\n# 설정 단계\n\n새 프로젝트를 시작하고 이미 Angular v17이 설정되어 있다고 가정하면 새 앱을 만듭니다:\n\n```js\nng new angular-google-maps\ncd angular-google-maps\n```\n\n<div class=\"content-ad\"></div>\n\nGoogle Maps 모듈을 설치하려면 다음 명령어를 실행하세요:\n\n```js\nnpm i @angular/google-maps\n```\n\nAngular v17에서는 새 응용 프로그램이 기본적으로 독립적인 프로젝트로 생성됩니다. 컴포넌트가 독립적인지 여부는 src/app/app.component.ts 파일의 standalone 속성을 확인하여 알 수 있습니다. 컴포넌트가 독립적인 경우 해당 속성은 true로 표시됩니다.\n\n독립적인 컴포넌트의 경우 모듈을 src/app/app.component.ts 파일에 다음과 같이 가져옵니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n...\nimport { GoogleMapsModule } from \"@angular/google-maps\";\n\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  imports: [RouterOutlet, GoogleMapsModule],\n  templateUrl: './app.component.html',\n  styleUrl: './app.component.scss'\n})\n...\n```\n\n만약 해당 컴포넌트가 독립적이지 않다면 모듈을 src/app/app.module.ts 파일로 가져오세요:\n\n```js\n...\nimport { GoogleMapsModule } from \"@angular/google-maps\";\n\n@NgModule({\n  declarations: [...],\n  imports: [..., GoogleMapsModule],\n  ...\n})\nexport class AppModule {}\n```\n\n다음 스크립트를 애플리케이션의 src/index.html 파일에 추가하고 YOUR_API_KEY를 해당하는 API 키로 교체하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\n<!DOCTYPE html>\n<head>\n  ...\n</head>\n<body>\n  ...\n  <script>\n    (g => {\n        var h, a, k, p = \"The Google Maps JavaScript API\", c = \"google\", l = \"importLibrary\", q = \"__ib__\", m = document, b = window;\n        b = b[c] || (b[c] = {});\n        var d = b.maps || (b.maps = {}),\n            r = new Set,\n            e = new URLSearchParams,\n            u = () => h || (h = new Promise(async (f, n) => {\n            await (a = m.createElement(\"script\"));\n            e.set(\"libraries\", [...r] + \"\");\n            for (k in g) e.set(k.replace(/[A-Z]/g, t => \"_\" + t[0].toLowerCase()), g[k]);\n            e.set(\"callback\", c + \".maps.\" + q);\n            a.src = `https://maps.${c}apis.com/maps/api/js?` + e;\n            d[q] = f;\n            a.onerror = () => h = n(Error(p + \" could not load.\"));\n            a.nonce = m.querySelector(\"script[nonce]\")?.nonce || \"\";\n            m.head.append(a)\n          }));\n        d[l] ? console.warn(p + \" only loads once. Ignoring:\", g) : d[l] = (f, ...n) => r.add(f) && u().then(() => d[l](f, ...n))\n      })({\n        v: \"weekly\",\n        key: \"YOUR_API_KEY\"\n      });\n  </script>\n</body>\n</html>\n```\n\n스크립트는 닫히는 body 태그 이전에 위치하고 head 태그 사이에 있지 않아야 합니다.\n\n# 지도 추가하기\n\n이제 맵의 높이와 너비를 추가하고, 옵션을 설정하여 구글 지도 컴포넌트를 애플리케이션에 추가할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 지도가 렌더링된 맵의 ID를 나타냅니다\n- center는 맵의 중심 (위도 및 경도)\n- zoom은 맵의 줌 레벨\n\n```js\n<!-- app.component.html -->\n<h1>Angular 17에서 Google 지도</h1>\n<google-map height=\"600px\" width=\"800px\" [options]=\"options\"> </google-map>\n```\n\n```js\n// app.component.ts\n...\nexport class AppComponent {\n  ...\n  options: google.maps.MapOptions = {\n    mapId: \"DEMO_MAP_ID\",\n    center: { lat: -31, lng: 147 },\n    zoom: 4,\n  };\n}\n```\n\n이제 다음 명령을 사용하여 응용 프로그램을 실행하실 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nng serve\n```\n\n해당 이미지와 비슷한 지도를 얻어야 합니다:\n\n<img src=\"/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_0.png\" />\n\n# 고급 마커 추가하기\n\n<div class=\"content-ad\"></div>\n\n먼저, 마커의 위치(위도 및 경도)를 정의해야 합니다. 다음 변수를 app.component.ts 파일에 선언해주세요:\n\n```js\nexport class AppComponent {\n  ...\n  nzLocations: any[] = [\n    { lat: -36.817685, lng: 175.699196 },\n    { lat: -36.828611, lng: 175.790222 },\n    { lat: -39.927193, lng: 175.053218 },\n    { lat: -41.330162, lng: 174.865694 },\n    { lat: -43.999792, lng: 170.463352 },\n  ];\n  auLocations: any[] = [\n    { lat: -31.56391, lng: 147.154312 },\n    { lat: -33.718234, lng: 150.363181 },\n    { lat: -33.727111, lng: 150.371124 },\n    { lat: -33.848588, lng: 151.209834 },\n    { lat: -33.851702, lng: 151.216968 },\n    { lat: -34.671264, lng: 150.863657 },\n    { lat: -35.304724, lng: 148.662905 },\n    { lat: -37.75, lng: 145.116667 },\n    { lat: -37.759859, lng: 145.128708 },\n    { lat: -37.765015, lng: 145.133858 },\n    { lat: -37.770104, lng: 145.143299 },\n    { lat: -37.7737, lng: 145.145187 },\n    { lat: -37.774785, lng: 145.137978 },\n    { lat: -37.819616, lng: 144.968119 },\n    { lat: -38.330766, lng: 144.695692 },\n    { lat: -42.734358, lng: 147.439506 },\n    { lat: -42.734358, lng: 147.501315 },\n    { lat: -42.735258, lng: 147.438 },\n  ];\n}\n```\n\n다음으로, app.component.html 파일에서 for-loop를 사용하여 지도에 Advanced Markers를 추가할 것입니다.\n\n```html\n<google-map height=\"600px\" width=\"800px\" [options]=\"options\">\n  @for (location of nzLocations; track location) {\n  <map-advanced-marker\n    #markerElem=\"mapAdvancedMarker\"\n    [position]=\"{ lat: location.lat, lng: location.lng }\"\n  />\n  } @for (location of auLocations; track location) {\n  <map-advanced-marker\n    #markerElem=\"mapAdvancedMarker\"\n    [position]=\"{ lat: location.lat, lng: location.lng }\"\n  />\n  }\n</google-map>\n```\n\n<div class=\"content-ad\"></div>\n\n지금은 파일을 저장할 수 있고, 지도에 여러 호주 및 뉴질랜드 위치 표시기가 삽입된 것을 확인할 수 있습니다.\n\n![Google Map with location markers](/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_1.png)\n\n# 고급 마커 사용자 정의\n\n이제 우리가 지도를 성공적으로 초기화하고 표시기를 추가했으므로, 사용자 정의 이미지로 그들을 계속하여 사용자 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 인라인 SVG 사용하기\n\n기본 마커를 변경하려면 먼저 DOMParser를 추가하여 SVG 문자열을 DOM 요소로 변환해야 합니다. app.component.ts 파일에서 파서와 사용하려는 SVG 문자열을 초기화합니다:\n\n```js\n...\nngOnInit() {\n  const parser = new DOMParser();\n  // 이것은 집 아이콘의 SVG 문자열입니다. 사용하고 싶은 SVG 아이콘을 자유롭게 사용해주십시오.\n  const svgString = `<svg aria-hidden=\"true\" xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" fill=\"#FF5733\" stroke=\"#FFFFFF\" viewBox=\"0 0 24 24\">\n                    <path fill-rule=\"evenodd\" d=\"M11.293 3.293a1 1 0 0 1 1.414 0l6 6 2 2a1 1 0 0 1-1.414 1.414L19 12.414V19a2 2 0 0 1-2 2h-3a1 1 0 0 1-1-1v-3h-2v3a1 1 0 0 1-1 1H7a2 2 0 0 1-2-2v-6.586l-.293.293a1 1 0 0 1-1.414-1.414l2-2 6-6Z\" clip-rule=\"evenodd\"/>\n                    </svg>`;\n}\n```\n\n다음으로, 우리의 뉴질랜드 마커를 루프하여 원하는 이미지로 설정합니다. forEach 루프를 사용하여 각 위치의 내용 속성을 파서를 사용하여 문서 요소로 설정합니다. 위 코드에 이어 ngOnInit() 함수 내에서 이 작업을 수행하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nthis.nzLocations.forEach((location) => {\n  location.content = parser.parseFromString(svgString, \"image/svg+xml\").documentElement;\n});\n```\n\n모든 위치의 내용이 설정된 후에는 New Zealand 위치의 `map-advanced-marker` 태그의 내용 속성을 app.component.html 파일에서도 추가하고 수정해야 합니다.\n\n```html\n...\n@for (location of nzLocations; track location) {\n<map-advanced-marker\n  #markerElem=\"mapAdvancedMarker\"\n  [position]=\"{ lat: location.lat, lng: location.lng }\"\n  [content]=\"location.content\"\n/>\n}\n...\n```\n\n다음 이미지는 마커의 기본 핀 모양을 변경한 후 현재 지도가어떻게 보여야하는지 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_2.png\" />\n\n## PNG 이미지 사용하기\n\nPNG 이미지를 사용하려면 이미지를 참조하고 해당 요소를 위치 내용 태그에 설정해야 합니다.\n\napp.component.ts 파일에서 먼저 PNG 이미지에 대한 링크를 정의합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nngOnInit() {\n  ...\n  // 예시로 구글의 비치 플래그 이미지를 사용할 것이지만, 마음에 드시는 이미지를 자유롭게 사용해도 괜찮습니다\n  const beachFlag = \"https://developers.google.com/maps/documentation/javascript/examples/full/images/beachflag.png\";\n}\n```\n\n그런 다음, 우리는 ngOnInit() 함수 안에서 위 코드 이후에 오스트레일리아 마커들에 대해 forEach 루프를 사용하여 인라인 SVG 섹션에서 했던 것과 유사하게 각 위치의 내용으로 전달될 img 요소를 생성할 것입니다.\n\n```js\nthis.auLocations.forEach((location) => {\n  let imgTag = document.createElement(\"img\");\n  imgTag.src = beachFlag;\n  location.content = imgTag;\n});\n```\n\n한번 더, app.component.html 파일에서 오스트레일리아 위치들의 `map-advanced-marker` 태그의 내용 속성을 추가 및 수정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n@for (location of auLocations; track location) {\n<map-advanced-marker\n  #markerElem=\"mapAdvancedMarker\"\n  [position]=\"{ lat: location.lat, lng: location.lng }\"\n  [content]=\"location.content\"\n/>\n}\n```\n\n\nThe final result should look like the following image:\n\n![Integrating Google Maps in Angular](/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_3.png)\n\n## Adding a Title\n\n\n<div class=\"content-ad\"></div>\n\n마커 위로 마우스를 올리면 제목 텍스트가 나타나며, 이는 `map-advanced-marker` 태그의 title 속성을 수정하여 설정합니다. 아래 코드에서는 각 위치의 인덱스 번호를 기반으로 제목을 추가했지만, 원하는 대로 변경할 수 있습니다.\n\n\n따라서 마커 위로 커서를 올리면 해당 위치 번호가 나타나는 작은 텍스트가 표시됩니다.\n\n<img src=\"/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n## 정보 창 추가하기\n\n정보 창은 마커에 대한 자세한 정보를 제공할 수 있으며, 일반적으로 마커를 클릭할 때 표시됩니다. 우리는 고급 마커를 사용하고 있기 때문에 Advanced Marker에서 제공되는 새로운 기능인 openAdvancedMarkerElement()를 활용할 수 있습니다.\n\n먼저, imports를 업데이트하고 app.component.ts 파일에서 infoWindow의 ViewChild를 정의해야 합니다.\n\n```js\nimport { Component, ViewChild } from \"@angular/core\";\nimport { GoogleMapsModule, MapAdvancedMarker, MapInfoWindow } from \"@angular/google-maps\";\n...\nexport class AppComponent {\n...\n  @ViewChild(MapInfoWindow) infoWindow!: MapInfoWindow;\n...\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그럼, 마커를 클릭했을 때 실행될 AppComponent 클래스의 함수를 작성할 수 있어요:\n\n```js\n...\nexport class AppComponent {\n...\n  onMarkerClick(marker: MapAdvancedMarker) {\n    this.infoWindow.openAdvancedMarkerElement(marker.advancedMarker, marker.advancedMarker.title);\n  }\n...\n}\n```\n\n`openAdvancedMarkerElement()` 함수의 첫 번째 매개변수는 정보 창이 열릴 마커 요소의 위치를 나타내고, 두 번째 매개변수는 정보 창에 표시될 내용으로 사용될 null이 가능한 문자열 또는 Element를 받아요.\n\n이제 할 일은 만들어둔 onMarkerClick 함수와 `map-info-window` 태그를 app.component.html 파일에 추가하는 거에요.\n\n<div class=\"content-ad\"></div>\n\n파일을 저장하고 이제 마커를 클릭하면 마커 제목이 나타나는 정보 창이 표시됩니다.\n\n<img src=\"/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_5.png\" />\n\n# 결론\n\n\n<div class=\"content-ad\"></div>\n\n지금까지 따라오신 여러분, 축하드립니다! 구글 지도를 구현하여 클릭 시 정보 창이 열리는 사용자 정의 고급 마커가 포함된 지도를 성공적으로 만들었습니다.\n\n위 코드에 문제가 있거나 전체 코드를 보고 싶은 경우, 이 GitHub 저장소로 방문하여 프로젝트를 확인할 수 있습니다. 꼭 API 키를 교체해 주세요!\n\n이번 글은 여기까지입니다! 아래 댓글에 의견을 자유롭게 나눠주세요. 도움이 되었고 쉽게 따라올 수 있었기를 바라며, 저의 첫 Medium 글에 클랩 몇 개 부탁 드리겠습니다. 감사합니다! 😄","ogImage":{"url":"/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_0.png"},"coverImage":"/assets/img/2024-05-18-IntegratingGoogleMapsinAngular17_0.png","tag":["Tech"],"readingTime":11},{"title":"Angular 개발에서 흔히 하는 10가지 실수","description":"","date":"2024-05-18 21:56","slug":"2024-05-18-10CommonMistakesinAngularDevelopment","content":"\n\n## 고성능, 견고하며 안전한 애플리케이션 개발하기\n\n![이미지](/assets/img/2024-05-18-10CommonMistakesinAngularDevelopment_0.png)\n\nAngular 애플리케이션을 개발할 때 개발자들이 종종 실수하는 10가지 일반적인 실수를 예제와 함께 살펴보겠습니다.\n\n다음은 우리가 살펴볼 예제들에 대한 간략한 개요입니다:\n\n<div class=\"content-ad\"></div>\n\n- 구성 요소 설계의 부족: 일반적인 실수 중 하나는 Angular 구성 요소를 올바르게 설계하지 않는 것입니다. 이는 관심사의 분리와 재사용성의 원칙을 준수하지 않고, 볼륨이 크고 유지 보수가 어려운 구성 요소로 이어질 수 있습니다.\n- 비효율적인 변경 감지: Angular는 변경 감지를 사용하여 뷰를 모델과 동기화 유지합니다. 그러나 개발자가 변경 감지 전략을 최적화하지 않아 성능 문제를 발생시킬 수 있습니다. 기본 \"OnPush\" 전략을 사용하지 않거나 불필요하고 비용이 많이 드는 뷰 업데이트로 이어질 수 있습니다.\n- 반응형 프로그래밍 사용하지 않기: Angular는 반응형 폼과 RxJS와 같은 강력한 반응형 프로그래밍 기능을 제공하며, 이를 활용하지 않으면 복잡하고 오류가 발생하기 쉬운 코드로 이어질 수 있습니다.\n- 적절하지 못한 메모리 관리: 개발자가 리소스를 적절하게 관리하지 못하면 Angular 앱이 메모리 누수에 시달릴 수 있습니다. 예를 들어 옵저버를 구독해지하지 않거나 구성 요소를 올바르게 삭제하지 않거나 Angular의 의존성 주입 시스템을 올바르게 사용하지 않으면 메모리 누수가 발생하고 앱 성능이 저하될 수 있습니다.\n- 성능 최적화 부족: 성능 최적화가 제대로 구현되지 않으면 Angular 애플리케이션은 느려지고 응답하지 않을 수 있습니다. ngFor에 trackBy를 사용하지 않거나 HTTP 요청을 최적화하지 않거나 모듈의 지연 로딩을 활용하지 않으면 성능 최적화를 무시하면 사용자 경험이 좋지 않을 수 있습니다.\n- 보안 최선의 사례 무시: Angular는 XSS(Cross-Site Scripting) 및 CSRF(Cross-Site Request Forgery) 보호와 같은 내장 보안 기능을 제공합니다. 이러한 보안 기능을 무시하거나 사용자 입력을 유효성 검사하지 않거나 인증 및 권한 부여를 올바르게 처리하지 않으면 보안 취약점이 노출될 수 있습니다.\n- 테스트 부족: 포괄적인 단위 테스트와 e2e(종단 간) 테스트를 작성하지 않으면 버그가 많은 신뢰할 수 없는 애플리케이션으로 이어질 수 있습니다. 적절한 테스트를 무시하면 프로덕션 결함이 발생하고 애플리케이션의 유지 및 업데이트가 어려워질 수 있습니다.\n- Angular 최선의 사례 무시: Angular에는 고유한 최선의 사례와 코딩 규칙이 있습니다. Angular 스타일 가이드를 따르지 않거나 권장 폴더 구조를 준수하지 않으면 코드베이스를 이해하고 유지 관리하기 어려울 수 있습니다.\n- DOM 조작 최적화 무시: Angular 애플리케이션은 DOM(Document Object Model)의 빈번한 조작을 필요로 합니다. 과도한 양방향 데이터 바인딩을 사용하거나 안전한 DOM 업데이트를 위해 Renderer2 API를 활용하지 않으면 성능 문제, 느린 렌더링 및 부자연스러운 사용자 경험으로 이어질 수 있습니다.\n- 오류 조건 처리 미흡: 오류 처리는 견고하고 신뢰할 수 있는 Angular 애플리케이션을 작성하는 중요한 측면입니다. 실패한 HTTP 요청, 잘못된 사용자 입력 또는 예기치 않은 예외와 같은 오류 조건을 적절하게 처리하지 않으면 애플리케이션 충돌, 일관되지 않은 동작 및 부자연스러운 사용자 경험이 발생할 수 있습니다. 사용자에게 오류 메시지를 표시하거나 디버깅을 위해 오류를 로깅하고 오류에서 우아하게 복구하는 적절한 오류 처리 메커니즘을 구현하는 것이 중요합니다.\n\n## Poor Component Design\n\n관심사의 분리 부족:\n```js\nimport { Component } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <!-- ... 템플릿 코드 ... -->\n  `\n})\nexport class ExampleComponent {\n  constructor(private http: HttpClient) { }\n\n  // 컴포넌트 로직, HTTP 요청 포함하여 직접 컴포넌트 클래스에 작성\n  // ...\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 Angular 컴포넌트는 HttpClient 모듈을 사용하여 HTTP 요청을 직접 처리하고 있습니다. 이는 관심사 분리 원칙을 위반하는 것이며, 컴포넌트는 뷰 렌더링 및 사용자 상호작용 처리에 중점을 두어야 하고, 서비스는 데이터 검색 및 조작을 포함한 비즈니스 로직을 처리해야 합니다. 컴포넌트 클래스에서 관심사를 섞으면 코드가 비대해지고 유지보수가 어려워질 수 있습니다.\n\n재사용성 부족:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-product-list',\n  template: `\n    <h2>Product List</h2>\n    <ul>\n      <li *ngFor=\"let product of products\">{{ product.name }}</li>\n    </ul>\n  `\n})\nexport class ProductListComponent {\n  products: Product[] = [\n    { id: 1, name: 'Product 1' },\n    { id: 2, name: 'Product 2' },\n    { id: 3, name: 'Product 3' }\n  ];\n\n  // 제품 목록에 특화된 컴포넌트 로직\n  // ...\n}\n\ninterface Product {\n  id: number;\n  name: string;\n}\n```\n\n이 예시에서는 제품 목록을 표시하는 ProductListComponent가 있습니다. 그러나 이 컴포넌트는 제품의 구체적인 데이터 구조와 제품 목록 표시에 특화된 로직과 강하게 결합되어 있습니다. 이는 다른 데이터 구조나 사용 사례에 쉽게 적응되지 않아서 재사용성이 떨어집니다.\n\n<div class=\"content-ad\"></div>\n\n향상된 재사용성:\n\n```js\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-item-list',\n  template: `\n    <h2>{ title }</h2>\n    <ul>\n      <li *ngFor=\"let item of items\">{ item.name }</li>\n    </ul>\n  `\n})\nexport class ItemListComponent {\n  @Input() title: string;\n  @Input() items: any[];\n\n  // 일반적인 항목 목록을 표시하는 컴포넌트 로직\n  // ...\n}\n```\n\n이 향상된 예시에서는 더 일반적인 형태의 ItemListComponent가 제공된 데이터를 통해 항목 목록을 표시할 수 있습니다. 이 컴포넌트는 더 이상 제품의 특정 데이터 구조에 강하게 결합되어 있지 않으며, @Input() 속성을 통해 다른 데이터 구조나 사용 사례에 쉽게 적응할 수 있습니다.\n\n컴포넌트를 더 일반적이고 설정 가능하며 유연하게 설계함으로써, 재사용성을 향상시킬 수 있습니다. 이러한 방식으로 컴포넌트를 다양한 시나리오에 적합하게 만들어 Angular 애플리케이션에서 코드 중복을 줄일 수 있습니다. 이는 유지보수성과 확장성을 촉진하며, 컴포넌트를 코드를 다시 작성하거나 복제하지 않고도 애플리케이션의 다양한 부분에서 쉽게 재사용할 수 있도록 돕습니다.\n\n<div class=\"content-ad\"></div>\n\n## 더 자세히 알아보기:\n\n## 비효율적인 변경 감지\n\n아래는 Angular 컴포넌트에서 비효율적인 변경 감지의 예시입니다:\n\n```js\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-user',\n  template: `\n    <div>\n      <h1>{ user.name }</h1>\n      <p>{ user.age }</p>\n    </div>\n  `,\n})\nexport class UserComponent {\n  @Input() user: User; // User는 사용자 데이터를 표현하는 인터페이스 또는 클래스입니다\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위의 예제에서 UserComponent에는 사용자 데이터를 입력으로받는 @Input() 속성 바인딩이 있는 user라는 속성이 있습니다. 기본적으로 Angular는 \"CheckAlways\" 변경 감지 전략을 사용합니다. 이것은 부모 구성요소에 변경이 발생할 때마다 사용자 입력 속성과 관련이 없어도 Angular가 UserComponent를 다시 렌더링하고 불필요한 뷰 업데이트를 일으킬 수 있어 성능 문제를 일으킬 수 있습니다.\n\n변경 감지 전략을 최적화하고 불필요한 뷰 업데이트를 피하기 위해 \"OnPush\" 변경 감지 전략을 사용할 수 있습니다. 이는 @Input() 속성의 참조가 변경될 때만 변경 감지가 트리거되는 변경 감지 전략을 사용합니다. 다음은 예시입니다:\n\n```js\nimport { Component, Input, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-user',\n  template: `\n    <div>\n      <h1>{ user.name }</h1>\n      <p>{ user.age }</p>\n    </div>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush, // 변경 감지 전략을 OnPush로 설정\n})\nexport class UserComponent {\n  @Input() user: User; // User는 사용자 데이터를 나타내는 인터페이스나 클래스입니다\n}\n```\n\n\"OnPush\" 변경 감지 전략을 사용하면 사용자 입력 속성의 참조가 변경될 때만 UserComponent에서 변경 감지가 수행되므로, 사용자 데이터가 자주 변경되지 않는 경우에는 보다 효율적인 변경 감지와 성능이 향상됩니다.\n\n<div class=\"content-ad\"></div>\n\n앵귤러 애플리케이션에서 각 구성 요소에 적합한 변경 감지 전략을 신중하게 선택하여 성능을 최적화하고 불필요한 뷰 업데이트를 방지하는 것이 중요합니다.\n\n## 반응형 프로그래밍을 사용하지 않는 경우\n\n다음은 폼 처리에 반응형 프로그래밍을 사용하지 않는 예제입니다:\n\n```js\nimport { Component } from '@angular/core';\nimport { FormGroup, FormControl, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-login-form',\n  template: `\n    <form (ngSubmit)=\"onSubmit()\">\n      <input type=\"text\" [(ngModel)]=\"username\" name=\"username\" required>\n      <input type=\"password\" [(ngModel)]=\"password\" name=\"password\" required>\n      <button type=\"submit\">Login</button>\n    </form>\n  `,\n})\nexport class LoginFormComponent {\n  username: string;\n  password: string;\n\n  onSubmit() {\n    // 사용자 이름과 비밀번호로 폼 제출 로직\n    // ...\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위 예제에서는 LoginFormComponent가 템플릿 기반 폼과 ngModel을 사용하여 양방향 데이터 바인딩을 처리합니다. 하지만 이 접근 방식은 복잡하고 오류를 발생할 가능성이 있는 코드로 이어질 수 있습니다. 이는 폼 상태를 수동으로 관리하고 폼 유효성을 처리해야하기 때문입니다.\n\nAngular의 ReactiveFormsModule와 반응형 프로그래밍을 활용한 대안적 접근 방식은 다음과 같습니다:\n\n```js\nimport { Component } from '@angular/core';\nimport { FormGroup, FormControl, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-login-form',\n  template: `\n    <form [formGroup]=\"loginForm\" (ngSubmit)=\"onSubmit()\">\n      <input formControlName=\"username\" required>\n      <input formControlName=\"password\" type=\"password\" required>\n      <button type=\"submit\">Login</button>\n    </form>\n  `,\n})\nexport class LoginFormComponent {\n  loginForm: FormGroup;\n\n  constructor() {\n    this.loginForm = new FormGroup({\n      username: new FormControl('', [\n        Validators.required,\n        Validators.pattern(/^\\S+$/), // enforce non-whitespace characters\n      ]),\n      password: new FormControl('', Validators.required, Validators.minLength(8)),\n    });\n  }\n\n  onSubmit() {\n    if (this.loginForm.invalid) {\n      // 폼이 유효하지 않음, 에러 처리\n      return;\n    }\n\n    const username = this.loginForm.get('username').value.trim();\n    const password = this.loginForm.get('password').value;\n\n    // 사용자 이름과 암호를 사용한 폼 제출 로직\n    // ...\n  }\n}\n```\n\n이 예제에서는 LoginFormComponent가 FormGroup 및 FormControl을 사용하여 Angular의 ReactiveFormsModule로 폼 입력을 반응적으로 처리합니다. 이를 통해 폼 상태를 효과적으로 제어할 수 있고, 보다 복잡한 폼 유효성을 처리할 수 있으며, 컴포넌트 로직에서 폼 데이터 처리를 단순화할 수 있습니다. Angular의 반응형 폼과 RxJS를 활용하면 응용 프로그램 상태 관리를 크게 간소화하고, 코드 유지 관리성을 향상시키며, 오류를 발생시킬 가능성을 줄일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n리액티브 프로그래밍 특성을 활용하면 Angular의 리액티브 폼과 RxJS와 같은 기능을 사용하여 Angular 애플리케이션에서 오류 발생 가능성을 줄일 수 있습니다. 다음은 몇 가지 방법입니다:\n\n- 강한 타이핑: 리액티브 폼을 사용하면 TypeScript 인터페이스나 클래스를 활용하여 폼 데이터의 형태와 유형을 정의할 수 있습니다. 이를 통해 컴파일 시간 타입 체크를 제공하여 런타임이 아닌 빌드 시간에 타입 관련 오류를 찾아낼 수 있습니다. 이로써 잘못된 데이터 유형 전달 또는 정의되지 않은 속성 접근과 같은 문제를 방지할 수 있습니다.\n- 선언적 유효성 검사: 리액티브 폼을 사용하면 내장된 유효성 검사기나 사용자 정의 유효성 검사기를 활용하여 선언적으로 폼 유효성을 정의할 수 있습니다. 이를 통해 폼 입력의 복잡한 유효성 규칙을 정의하고 관리하기가 더 쉬워집니다. 유효성 검사 논리는 폼 내부에 캡슐화되어 있어 응용 프로그램의 다른 부분에 걸쳐 유효성 검사 논리의 일관성 또는 오류 발생 가능성을 줄일 수 있습니다.\n- 불변 데이터 흐름: 리액티브 프로그래밍은 불변 데이터 흐름을 장려하며 데이터를 불변이라고 다루고 변경 사항을 이벤트 스트림을 통해 수행합니다. 이를 통해 데이터의 직접적인 변이를 방지하여 예기치 않은 데이터 변이나 부작용으로 인한 오류 발생 가능성을 줄일 수 있습니다.\n- 명시적 상태 관리: RxJS를 사용한 리액티브 프로그래밍은 데이터 및 상태 변경의 흐름을 명시적으로 만들어줍니다. 이벤트 스트림이 관찰 가능하며 구독할 수 있기 때문에 데이터 및 상태 변경 흐름에 대해 추론하기가 더 쉬워질 수 있습니다. 이를 통해 숨겨진 또는 예상치 못한 상태 변경으로 인한 버그 발생 가능성을 줄일 수 있습니다.\n- 코드 조직 개선: 리액티브 프로그래밍은 관심사의 분리와 데이터 및 이벤트 처리에 더 기능적인 접근을 장려합니다. 결과적으로 조직화되고 모듈화된 코드와 역할의 명확한 분리로 인해 코딩이 더 용이해지며, 결합도가 높거나 흩어진 코드로 인한 오류가 줄어듭니다.\n- 오류 처리: RxJS를 사용한 리액티브 프로그래밍은 오류 처리 메커니즘을 내장하고 있어, 오류 처리 연산자와 같은 것을 통해 보다 체계적이고 집중적으로 오류를 처리할 수 있습니다. 이는 응용 프로그램이 크래시되거나 예상치 못한 동작을 일으킬 수 있는 처리되지 않은 오류를 방지하는 데 도움이 됩니다.\n\nAngular 애플리케이션에서 리액티브 폼과 RxJS와 같은 리액티브 프로그래밍 기능을 활용하면 오류 발생 가능성이 줄어들고 코드 유지 관리성이 향상되며, 더 견고하고 신뢰할 수 있는 애플리케이션을 개발할 수 있습니다.\n\n## 메모리 관리 부적절(runtime error)\n\n<div class=\"content-ad\"></div>\n\nAngular 애플리케이션에서 메모리 관리를 잘못한 예시를 몇 가지 들었습니다:\n\n옵저버블을 올바르게 해제하지 않기:\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-product-list',\n  template: `\n    <h2>Product List</h2>\n    <!-- Display products -->\n  `\n})\nexport class ProductListComponent implements OnInit {\n  products: Product[];\n\n  constructor(private dataService: DataService) {}\n\n  ngOnInit() {\n    // 데이터 서비스로부터 제품을 가져와 옵저버블을 구독합니다.\n    this.dataService.getProducts()\n      .subscribe(products => this.products = products);\n  }\n}\n```\n\n이 예시에서 ProductListComponent는 DataService에 의해 반환된 옵저버블을 구독하여 제품을 가져옵니다. 그러나 컴포넌트가 파괴되기 전에 옵저버블을 해지하지 않아 옵저버블이 완료되기 전에 컴포넌트가 파괴된 경우 메모리 누수가 발생할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위의 예제를 개선하려면 다음과 같이 unsubscribe 메서드를 추가할 수 있습니다:\n\n```js\nimport { Component, OnInit, OnDestroy } from '@angular/core';\nimport { DataService } from './data.service';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-product-list',\n  template: `\n    <h2>Product List</h2>\n    <!-- Display products -->\n  `\n})\nexport class ProductListComponent implements OnInit, OnDestroy {\n  // ...\n\n  ngOnDestroy() {\n    // 메모리 누수를 방지하기 위해 옵저버에 대한 구독 취소\n    this.subscription.unsubscribe();\n  }\n}\n```\n\nAngular의 의존성 주입 시스템의 잘못된 사용:\n\n```js\nimport { Component, Injector } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-product-list',\n  template: `\n    <h2>Product List</h2>\n    <!-- Display products -->\n  `,\n  providers: [DataService]\n})\nexport class ProductListComponent {\n  constructor(private injector: Injector) {\n    // 의존성 주입기를 사용하여 데이터 서비스에서 제품 가져오기\n    const dataService = this.injector.get(DataService);\n    dataService.getProducts().subscribe(products => {\n      // 제품 처리\n    });\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예에서 ProductListComponent는 Angular의 Injector를 사용하여 수동으로 DataService의 인스턴스를 생성하고 가져오는 중입니다. this.injector.get(DataService)를 사용하여. 그러나 이 방식은 DataService가 Angular의 DI 시스템에 의해 적절하게 관리되지 않으면 메모리 누수로 이어질 수 있습니다. Angular는 컴포넌트가 파괴될 때 인스턴스를 자동으로 정리하지 않기 때문입니다.\n\nAngular의 의존성 주입 시스템의 올바른 사용법:\n\n```js\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-product-list',\n  template: `\n    <h2>Product List</h2>\n    <!-- 제품 표시 -->\n  `,\n  providers: [DataService]\n})\nexport class ProductListComponent {\n  constructor(private dataService: DataService) {\n    // 데이터 서비스로부터 제품 가져오기\n    this.dataService.getProducts().subscribe(products => {\n      // 제품 처리\n    });\n  }\n}\n```\n\n이 향상된 예에서는 ProductListComponent가 Angular의 의존성 주입 시스템을 올바르게 활용하도록 개선되었습니다. DataService를 직접 컴포넌트 생성자에 주입함으로써 Angular가 DataService 인스턴스를 관리하고 컴포넌트가 파괴될 때 올바르게 정리하며, 메모리 누수를 방지하고 메모리 관리를 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n## 성능 최적화 부족\n\nngFor와 trackBy를 사용하지 않음:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <ul>\n      <li *ngFor=\"let product of products\">{ product }</li>\n    </ul>\n  `\n})\nexport class ExampleComponent {\n  products: Product[] = [\n    { id: 1, name: 'Product 1' },\n    { id: 2, name: 'Product 2' },\n    { id: 3, name: 'Product 3' }\n  ];\n\n  // 음이 아닌 경우가 뭐죠? trackBy 함수가 제공되지 않았습니다\n}\n```\n\n이 예에서 *ngFor 지시문을 사용하여 항목 목록을 렌더링합니다. 그러나 각 항목을 참조에 따라 비교하는 기본 추적 전략을 사용하며 항목을 변경할 때 전체 목록을 다시 렌더링합니다. 이는 특히 대규모 목록의 경우 비효율적일 수 있으며 불필요한 DOM 업데이트를 유발할 수 있습니다. 각 항목에 대해 고유 식별자를 반환하는 trackBy 함수를 제공함으로써 Angular는 렌더링 프로세스를 최적화하고 DOM 업데이트 수를 줄일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <ul>\n      <li *ngFor=\"let product of products; trackBy: trackByProductId\">{ product.name }</li>\n    </ul>\n  `\n})\nexport class ExampleComponent {\n  products: Product[] = [\n    { id: 1, name: 'Product 1' },\n    { id: 2, name: 'Product 2' },\n    { id: 3, name: 'Product 3' }\n  ];\n\n  trackByProductId(index: number, product: Product): number {\n    return product.id; // Use a unique identifier for the product, such as an ID or a unique property value\n  }\n}\n\ninterface Product {\n  id: number;\n  name: string;\n}\n```\n\n이 업데이트된 버전에서는 trackByProductId 함수가 컴포넌트에 추가되었습니다. 이 함수는 템플릿의 ngFor 지시문의 trackBy 입력에 바인딩되어 있습니다. trackByProductId 함수는 ngFor 지시문에서 인덱스와 제품을 가져와 제품의 고유 식별자를 반환합니다. 이 경우에는 제품 객체의 id 속성입니다. 이렇게 함으로써 Angular은 제품을 효율적으로 추적하고 필요할 때에만 DOM을 업데이트하여 성능을 향상시키고 불필요한 DOM 업데이트를 줄일 수 있습니다. 또한 템플릿에서 product.name을 사용하여 제품의 이름을 표시하는 대신 전체 제품 객체를 사용하면 DOM의 불필요한 렌더링을 줄일 수 있습니다.\n\nHTTP 요청 최적화하지 않기:\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <!-- API에서 데이터 표시 -->\n    <div *ngFor=\"let data of apiData\">{ data }</div>\n  `\n})\nexport class ExampleComponent implements OnInit {\n  apiData: any[];\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit() {\n    // 컴포넌트 초기화 시 API 요청\n    this.http.get('https://api.example.com/data')\n      .subscribe(response => {\n        this.apiData = response;\n      });\n  }\n\n   // 앗! API 요청이 최적화되지 않았네요\n}\n```\n\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 HttpClient 모듈을 사용하여 컴포넌트 초기화 시 API 요청을 보내어 데이터를 가져오는 예제가 나와 있습니다. 그러나 캐싱, 디바운싱 또는 페이지네이션과 같은 최적화가 적용되지 않았습니다. 이로 인해 불필요한 HTTP 요청이 여러 번 발생하여 성능 문제가 발생하고 애플리케이션 실행이 느려질 수 있습니다. API 응답을 캐싱하거나 짧은 시간 내에 여러 요청을 방지하기 위해 디바운싱을 적용하거나 데이터를 더 작은 단위로 가져오기 위해 페이지네이션을 사용함으로써 애플리케이션의 성능을 향상시킬 수 있습니다.\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { debounceTime, tap } from 'rxjs/operators';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <!-- API에서 데이터 표시 -->\n    <div *ngFor=\"let data of apiData\">{{ data }}</div>\n    <!-- 로딩 스피너 표시 -->\n    <div *ngIf=\"loading\">데이터 로드 중...</div>\n    <!-- 오류 메시지 표시 -->\n    <div *ngIf=\"error\">{{ error }}</div>\n    <!-- 더 많은 데이터 로드 버튼 표시 -->\n    <button (click)=\"loadMore()\" *ngIf=\"hasNextPage && !loading\">더 불러오기</button>\n  `\n})\nexport class ExampleComponent implements OnInit {\n  apiData: any[] = [];\n  loading: boolean = false;\n  error: string = '';\n  page: number = 1;\n  hasNextPage: boolean = true;\n\n  constructor(private http: HttpClient) {}\n\n  ngOnInit() {\n    this.loadMore(); // 초기 데이터 로드\n  }\n\n  loadMore() {\n    if (this.loading || !this.hasNextPage) return; // 여러 요청 방지하고 데이터를 다 로드했을 때 로딩 중지\n    this.loading = true;\n    this.error = '';\n\n    this.http.get(`https://api.example.com/data?page=${this.page}`)\n      .pipe(\n        tap(response => {\n          // 새로운 데이터를 기존 데이터 배열에 추가\n          this.apiData = this.apiData.concat(response);\n        }),\n        debounceTime(300) // 빠른 API 요청을 방지하기 위해 디바운스 적용\n      )\n      .subscribe(\n        () => {\n          this.loading = false;\n          this.page++; // 다음 loadMore 요청을 위해 페이지 증가\n        },\n        error => {\n          this.loading = false;\n          this.error = '데이터 로드 실패'; // 오류 메시지 표시\n        }\n      );\n  }\n}\n```\n\n이 업데이트된 버전에서는 다음 최적화가 적용되었습니다:\n\n- 캐싱: 로드된 데이터가 apiData 배열에 캐싱되어 불필요한 API 요청 없이 빠른 데이터 검색 및 렌더링이 가능합니다.\n- 디바운싱: API 요청에 debounceTime 연산자가 적용되어 빠른 API 요청을 방지합니다. 사용자가 빠르게 스크롤하거나 구성 요소와 상호 작용할 때 불필요한 요청을 방지하기 위해 요청을 지정된 시간 (이 예제에서는 300밀리초) 동안 지연시킵니다.\n- 페이지네이션: 현재 API에서 로드되는 데이터 페이지를 추적하기 위해 페이지 변수를 사용합니다. 각 성공적인 API 요청 후 증가되며, 데이터를 페이지별로 가져오고 한꺼번에 모든 데이터를 로드하는 것이 아닌 데이터를 청크 단위로 로드하여 성능을 향상시킬 수 있습니다.\n- 로딩 표시 및 오류 처리: API 요청 중 더 나은 사용자 피드백을 제공하기 위해 로딩 스피너와 오류 메시지가 추가되었습니다. 데이터를 가져오는 동안 로딩 스피너가 표시되고 API 요청이 실패하면 오류 메시지가 표시되어 사용자 경험을 향상시킵니다.\n- 더 많이 불러오기 버튼: 사용자가 수동으로 API에서 더 많은 데이터를로드하게하는 \"불러오기\" 버튼이 추가되었습니다. 구성 요소가 처음 렌더링될 때 초기 데이터를 자동으로로드하는 것을 방지하고 사용자가 언제 데이터를 추가로로드할지 제어할 수 있도록합니다.\n\n<div class=\"content-ad\"></div>\n\n모듈에 대한 레이지 로딩을 활용하지 않았습니다:\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home.component';\nimport { AboutComponent } from './about.component';\nimport { ContactComponent } from './contact.component';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'about', component: AboutComponent },\n  { path: 'contact', component: ContactComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n이 예제에서 모든 컴포넌트(HomeComponent, AboutComponent, 그리고 ContactComponent)가 AppRoutingModule에서 직접 import되어 즉시 로드됩니다. 이는 응용 프로그램이 시작될 때 이러한 모든 컴포넌트가 로드되고 초기화된다는 것을 의미합니다. 실제로 필요하지 않은 경우에도 이로 인해 초기 응용 프로그램 시작 시간이 더 오래 걸릴 수 있고 성능이 저하될 수 있습니다.\n\n성능을 최적화하려면 Angular는 레이지 로딩을 제공합니다. 이를 통해 모듈과 컴포넌트가 실제로 필요할 때만 로드할 수 있습니다. 모듈에 대한 레이지 로딩을 활용하여 초기 번들 크기를 줄이고 응용 프로그램의 시작 성능을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어:\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\n\nconst routes: Routes = [\n  { path: '', loadChildren: () => import('./home.component').then(m => m.HomeComponent) },\n  { path: 'about', loadChildren: () => import('./about.component').then(m => m.AboutComponent) },\n  { path: 'contact', loadChildren: () => import('./contact.component').then(m => m.ContactComponent) }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n이 갱신된 버전에서 route 설정에서 component 속성 대신 loadChildren 속성을 사용했습니다. loadChildren 속성은 import() 문을 사용하여 동적으로 구성 요소를 로드하는 함수를 지정하며, 구성 요소를 게으르게 로드하게 합니다.\n\n게으르게 로딩을 통해 사용자가 실제로 액세스할 때만 구성 요소를로드할 수 있으므로, 애플리케이션의 초기 로드 시간이 향상되고 미리로드해야 하는 코드 양이 줄어듭니다. 이는 특히 다수의 구성 요소와 복잡한 라우팅 구성이 있는 대규모 응용 프로그램에서 빠른로드 시간과 향상된 성능을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 보안 최적 사례 무시하기\n\n크로스사이트 스크립팅(XSS) 방어 무시하기:\n\n```js\nimport { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <div [innerHTML]=\"unsafeHtml\"></div>\n  `\n})\nexport class ExampleComponent {\n  @Input() unsafeHtml: string;\n\n  // 어이쿠! 안전하지 않은 HTML이 템플릿에 직접 바인딩되어 있습니다.\n}\n```\n\n이 예에서 unsafeHtml 속성은 [innerHTML]을 사용하여 템플릿에 직접 바인딩됩니다. 이는 unsafeHtml에 전달된 악의적인 HTML 코드가 적절히 살균 처리되지 않고 그대로 렌더링되어 애플리케이션이 크로스사이트 스크립팅(XSS) 공격을 당할 가능성이 있습니다. XSS 공격을 방지하려면 Angular에서 DomSanitizer 서비스와 같은 내장 살균 메커니즘을 제공하므로 템플릿에 렌더링하기 전에 동적 콘텐츠를 적절히 살균 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```typescript\nimport { Component, Input } from '@angular/core';\nimport { DomSanitizer, SafeHtml } from '@angular/platform-browser';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <div [innerHtml]=\"safeHtml\"></div>\n  `\n})\nexport class ExampleComponent {\n  @Input() unsafeHtml: string;\n  safeHtml: SafeHtml;\n\n  constructor(private sanitizer: DomSanitizer) {}\n\n  ngOnInit() {\n    // 안전하지 않은 HTML을 살균 처리합니다.\n    this.safeHtml = this.sanitizer.sanitize(\n      // 허용되는 HTML 요소 및 속성 목록을 사용합니다.\n      this.unsafeHtml,\n      { \n        allowedTags: ['div', 'span', 'a'], \n        allowedAttributes: { 'a': ['href'] } \n      }\n    );\n  }\n}\n```\n\n`ngOnInit()` 메서드에서는 `DomSanitizer` 서비스의 `sanitize()` 메서드를 사용하여 입력된 HTML 코드를 살균 처리합니다. `sanitize()` 메서드에 두 가지 인수를 전달합니다.\n\n- 잠재적으로 위험한 HTML 코드가 포함된 `unsafeHtml` 문자열입니다.\n- 허용되는 HTML 요소 및 속성을 정의하는 객체입니다.\n\n이 예제에서는 div, span, a 요소 및 a 요소의 href 속성만 허용하는 작은 화이트리스트를 정의했습니다. `unsafeHtml` 문자열에 있는 다른 요소나 속성은 살균 처리 중에 제거됩니다.\n\n\n<div class=\"content-ad\"></div>\n\nThe `sanitize()` 메서드는 안전한 HTML 코드를 포함하는 문자열을 반환하며, 그것을 `safeHtml` 속성에 할당합니다. `safeHtml` 속성은 `SafeHtml` 유형이며, Angular에서 HTML을 신뢰하고 기본 보안 검사를 우회하기 위해 사용하는 래퍼 클래스입니다. \n\n컴포넌트에서 렌더링하기 전에 잠재적으로 위험한 HTML 코드를 DomSanitizer 서비스를 사용하여 안전하게 처리함으로써 HTML에 포함된 악성 코드로 발생할 수 있는 XSS 공격의 위험을 줄일 수 있습니다.\n\nCross-Site Request Forgery (CSRF) 방지 무시:\n\n```js\nimport { HttpClient } from '@angular/common/http';\n\nexport class ExampleService {\n  constructor(private http: HttpClient) {}\n\n  public updateData(data: any) {\n    // 저런! 요청에 CSRF 토큰이 포함되지 않았습니다\n    return this.http.post('https://api.example.com/update', data);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 Angular 서비스의 updateData 메서드는 서버의 데이터를 업데이트하기 위해 POST 요청을 수행합니다. 그러나 요청에 Cross-Site Request Forgery (CSRF) 토큰이 포함되어 있지 않아 애플리케이션이 CSRF 공격에 취약해질 수 있습니다. Angular는 HTTP 요청에 자동으로 CSRF 토큰을 포함하여 기본 CSRF 보호 기능을 제공하지만, 적절한 설정과 사용법이 필요합니다. CSRF 보호를 무시하면 애플리케이션이 보안 위험에 노출될 수 있습니다.\n\n```js\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\n\nexport class ExampleService {\n  constructor(private http: HttpClient) {}\n\n  public updateData(data: any) {\n    // 요청 헤더에 CSRF 토큰 포함\n    const headers = new HttpHeaders().set('X-CSRF-TOKEN', '여기에_csrf_토큰_입력');\n    return this.http.post('https://api.example.com/update', data, { headers });\n  }\n}\n```\n\n이 업데이트된 버전에서는 HttpHeaders 클래스를 @angular/common/http에서 import하여 CSRF 토큰을 포함하는 새로운 헤더 객체를 생성합니다. X-CSRF-TOKEN 헤더는 적절한 CSRF 토큰 값으로 설정되어야 하며, 이는 안전한 소스(예: 서버 측)에서 얻어진 후 HTTP 요청과 함께 전달되어야 합니다. 이를 통해 CSRF 공격으로부터 보호를 제공하며, 서버 측에서 요청의 신뢰성을 확인합니다. CSRF 토큰을 얻고 포함하는 실제 방법은 애플리케이션의 백엔드 아키텍처 및 보안 구성에 따라 다를 수 있음을 참고해 주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <input [(ngModel)]=\"username\" placeholder=\"Username\">\n    <button (click)=\"login()\">Login</button>\n  `\n})\nexport class ExampleComponent {\n  username: string;\n\n  public login() {\n    // 앗! 입력 유효성 검사가 수행되지 않았어요\n    if (this.username === 'admin') {\n      // 관리자 액세스 부여\n    } else {\n      // 일반 사용자 액세스 부여\n    }\n  }\n}\n```\n\n이 예제에서는 Angular 컴포넌트에서 간단한 로그인 기능이 구현되어 있어요. 그러나 사용자명 입력에 대한 입력 유효성 검사가 수행되지 않아 악의적인 입력이 가능해지고 SQL 삽입, 코드 삽입 또는 권한 상승 공격과 같은 보안 취약점이 발생할 수 있어요. 데이터 유형, 길이, 형식 및 허용되는 문자를 포함한 적절한 사용자 입력 유효성 검사는 애플리케이션 내의 보안 위험을 방지하는 데 중요해요.\n\n```js\nimport { Component, FormBuilder, FormGroup, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <form [formGroup]=\"loginForm\">\n      <input formControlName=\"username\" placeholder=\"Username\">\n      <button (click)=\"login()\">Login</button>\n    </form>\n  `\n})\nexport class ExampleComponent {\n  loginForm: FormGroup;\n\n  constructor(private formBuilder: FormBuilder) {\n    this.loginForm = this.formBuilder.group({\n      username: ['', Validators.required, Validators.pattern(/^\\S*$/)]\n    });\n  }\n\n  public login() {\n    if (this.loginForm.valid) {\n      const username = this.loginForm.value.username;\n      if (username === 'admin') {\n        // 관리자 액세스 부여\n      } else {\n        // 일반 사용자 액세스 부여\n      }\n    }\n  }\n}\n```\n\n이 업데이트된 버전에서 Reactive Forms를 사용하고 있어요. [(ngModel)]을 사용하는 대신 Angular의 Reactive Forms 접근 방식을 고려해보세요. Reactive Forms는 양방향 데이터 바인딩보다 더 많은 제어와 유연성을 제공하며 양식 유효성 검사 및 데이터 처리에 관한 추가적인 기능을 제공해요.\n\n\n<div class=\"content-ad\"></div>\n\n## 테스트 부족\n\n단위 테스트 부족:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <div *ngIf=\"isLoggedIn\">Welcome, { username }!</div>\n    <div *ngIf=\"!isLoggedIn\">Please login</div>\n  `\n})\nexport class ExampleComponent {\n  isLoggedIn: boolean;\n  username: string;\n\n  // 안타깝게도, 이 컴포넌트 로직을 다루는 단위 테스트가 없습니다.\n}\n```\n\n이 예시에서, Angular 컴포넌트는 isLoggedIn 플래그에 기반한 조건부 렌더링을 사용하여 간단한 로그인 기능을 구현했습니다. 그러나 이 컴포넌트 로직을 다루는 단위 테스트가 작성되지 않았습니다. 단위 테스트 부족은 발견되지 않은 버그로 이어지며 개발 또는 유지보수 중에 문제를 식별하고 해결하기 어렵게 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { ExampleComponent } from './example.component';\n\ndescribe('ExampleComponent', () => {\n  let component: ExampleComponent;\n  let fixture: ComponentFixture<ExampleComponent>;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      declarations: [ExampleComponent]\n    });\n    fixture = TestBed.createComponent(ExampleComponent);\n    component = fixture.componentInstance;\n  });\n\n  it('should display welcome message when isLoggedIn is true', () => {\n    component.isLoggedIn = true;\n    component.username = 'John';\n    fixture.detectChanges();\n    const welcomeElement = fixture.nativeElement.querySelector('div');\n    expect(welcomeElement.textContent).toContain('Welcome, John!');\n  });\n\n  it('should display login message when isLoggedIn is false', () => {\n    component.isLoggedIn = false;\n    fixture.detectChanges();\n    const loginElement = fixture.nativeElement.querySelector('div');\n    expect(loginElement.textContent).toContain('Please login');\n  });\n});\n```\n\n위 예제에서는 Angular Testing Utilities의 TestBed를 사용하여 테스트 모듈을 구성하고 생성하고, ComponentFixture를 사용하여 테스트 중에 구성 요소의 인스턴스를 만들고 조작합니다. fixture.detectChanges() 메서드는 변경 감지를 트리거하고 구성 요소의 뷰를 업데이트합니다.\n\nit 문은 구성 요소의 동작에 대한 기대치를 정의합니다. isLoggedIn이 true로 설정되었을 때 올바른 사용자 이름이 포함된 환영 메시지가 표시되고, isLoggedIn이 false로 설정되었을 때 로그인 메시지가 표시되는지 확인합니다.\n\n참고: 이것은 기본적인 예제일 뿐이며, 특정 요구 사항과 구성 요소 논리에 기반하여 테스트를 사용자 정의해야 할 수 있습니다. 모든 가능한 시나리오를 철저히 테스트하여 구성 요소의 정확성과 신뢰성을 보증하는 것이 중요합니다.\n  \n\n<div class=\"content-ad\"></div>\n\n## 여기서 더 알아보세요:\n\nEnd-to-End (e2e) 테스트 부재:\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <!-- ... 템플릿 코드 ... -->\n  `\n})\nexport class ExampleComponent {\n  // 이런! 이 컴포넌트의 기능을 커버하는 end-to-end (e2e) 테스트가 없어요\n}\n```\n\n이 예시에서 Angular 컴포넌트는 다양한 사용자 상호작용(예: 폼 제출, API 호출, DOM 조작)을 포함한 복잡한 기능을 구현합니다. 그러나 이 컴포넌트의 기능을 커버하는 end-to-end (e2e) 테스트가 작성되어 있지 않습니다. e2e 테스트 부재는 사용자 상호작용, 데이터 흐름, 컴포넌트, 서비스, API 간 통합과 관련된 발견되지 않은 문제를 초래할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n적절한 테스트, 단위 테스트 및 엔드 투 엔드 테스트를 포함한 적절한 테스팅은 개발 프로세스 초기에 문제를 식별하고 수정하는 데 중요합니다. 이를 통해 애플리케이션의 신뢰성과 안정성을 보장하고 앞으로의 유지 보수 및 업데이트를 용이하게 합니다.\n\n```js\nimport cy from 'cypress';\n\ndescribe('ExampleComponent', () => {\n  beforeEach(() => {\n    // 예: ExampleComponent 페이지로 이동하는 설정 작업 수행\n    cy.visit('/example');\n  });\n\n  it('로그인한 경우 환영 메시지가 표시되어야 함', () => {\n    // 예: 유효한 사용자 이름으로 로그인하는 사전 조건 설정\n    // Cypress의 명령을 사용하여 구성 요소의 DOM과 상호 작용할 수 있습니다.\n    cy.get('input').type('john');\n    cy.get('button').click();\n\n    // 예상되는 결과 확인, 예: 환영 메시지가 표시되는지 확인\n    cy.get('div').should('contain.text', 'Welcome, john!');\n  });\n\n  it('로그인하지 않은 경우 로그인 메시지가 표시되어야 함', () => {\n    // 예: 로그아웃하거나 로그인하지 않은 사전 조건 설정\n    // Cypress의 명령을 사용하여 구성 요소의 DOM과 상호 작용할 수 있습니다.\n\n    // 예상되는 결과 확인, 예: 로그인 메시지가 표시되는지 확인\n    cy.get('div').should('contain.text', 'Please login');\n  });\n});\n```\n\n위 예제에서는 Angular 애플리케이션용으로 인기 있는 엔드 투 엔드 테스트 프레임워크인 Cypress를 사용하고 있습니다. Cypress를 사용하면 애플리케이션과 상호 작용을 시뮬레이션하고 결과 DOM에 대한 단언을 수행할 수 있습니다.\n\n이 코드의 주요 포인트 요약은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 위 코드는 ExampleComponent에 대한 테스트 스위트를 정의합니다.\n- beforeEach 훅은 각 테스트 케이스를 실행하기 전에 일부 설정 작업을 실행하는 데 사용됩니다. 이 경우에는 cy.visit를 사용하여/example 페이지로 이동합니다.\n- 첫 번째 테스트 케이스(it)는 유효한 사용자 이름으로 로그인할 때 환영 메시지가 표시되는지 확인합니다. 이를 위해 Cypress의 cy.get 명령을 사용하여 입력 요소에 사용자 이름을 입력하고 버튼 요소를 클릭한 다음, should 명령과 contain.text 단언을 사용하여 div 요소가 예상 텍스트를 포함하는지 확인합니다.\n- 두 번째 테스트 케이스는 사용자가 로그인하지 않은 경우 로그인 메시지가 표시되는지 확인합니다. 이를 위해 div 요소가 예상 텍스트를 포함하는지 확인합니다.\n- 두 테스트 케이스 모두 Cypress의 명령 인터페이스(cy)를 사용하여 구성 요소의 DOM과 예상 결과에 대한 단언을 만듭니다.\n- describe 블록은 테스트 스위트를 캡슐화하고 이를 위한 설명적인 이름을 제공합니다.\n\n참고: 이는 기본적인 예시이며, 특정 응용 프로그램의 설정 및 요구 사항에 맞게 테스트를 사용자 정의해야 할 수 있습니다. 구성 요소의 최종 기능을 철저히 테스트하여 애플리케이션의 정확성과 신뢰성을 보증하는 것이 중요합니다.\n\n## Angular 최적 사례 무시\n\nAngular 최적 사례를 무시하면 이해하기, 유지 관리하기 및 확장하기 어려운 코드로 이어질 수 있습니다. Angular 최적 사례를 무시하는 몇 가지 예시는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- Angular 스타일 가이드를 따르지 않기: Angular는 명명 규칙, 파일 구성, 컴포넌트 아키텍처 등을 위한 지침을 제공하는 스타일 가이드가 있어요. 이러한 가이드를 무시하면 일관성이 없고 읽기 어려운 코드로 이어질 수 있어요. 예를 들어, 컴포넌트, 서비스 및 변수의 명명 규칙을 준수하지 않으면 코드베이스의 다른 부분의 목적과 기능을 이해하기 어려울 수 있어요. 또한 명명 충돌이 발생하고 문제를 식별하고 수정하기 어려워질 수 있어요.\n\n```js\n// Angular 스타일 가이드에 맞지 않는 예\n// 컴포넌트 클래스 이름에 PascalCase 사용 지침 무시\n// 컴포넌트 셀렉터에 kebab-case 사용 지침 무시\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'appExample', // 셀렉터에 kebab-case 사용하지 않음\n  templateUrl: './example.component.html',\n  styleUrls: ['./example.component.css']\n})\nexport class exampleComponent { // 클래스 이름에 PascalCase 사용하지 않음\n  // ...\n}\n```\n\n2. 권장된 폴더 구조를 따르지 않기: Angular는 컴포넌트, 서비스, 자산과 같은 다양한 파일 유형을 구성하기 위한 특정 폴더 구조를 권장해요. 권장된 구조를 무시하면 애플리케이션이 커지고 복잡해질수록 파일을 찾고 관리하기 어려워질 수 있어요. 예를 들어, 컴포넌트, 서비스 및 기타 파일을 각각의 폴더로 분리하지 않으면 혼잡하고 혼란스러운 디렉토리 구조로 이어질 수 있어요.\n\n```js\n// 권장된 폴더 구조를 따르지 않는 예\n// 컴포넌트를 별도의 폴더에 구성하는 지침 무시\n// 다른 파일에 대해 명확한 폴더 구조를 사용하지 않음\nsrc/\n  app/\n    components/\n      example.component.ts // 컴포넌트를 별도의 폴더에 구성하지 않음\n    services/\n      example.service.ts // 서비스를 별도의 폴더에 구성하지 않음\n    example.module.ts // 다른 파일에 대해 명확한 폴더 구조를 사용하지 않음\n    example.component.css\n    example.component.html\n```\n\n<div class=\"content-ad\"></div>\n\n3. Angular 기능을 적절하게 활용하지 않기: Angular은 개발을 간단하게 만들고 성능을 향상시키며 유지 보수성을 향상시키기 위한 다양한 기능과 API를 제공합니다. 이러한 기능을 무시하거나 잘못 사용하면 최적화되지 않은 코드나 유지 관리가 어려운 코드로 이어질 수 있습니다. 예를 들어, Angular의 내장 의존성 주입(DI) 시스템을 활용하지 않으면 묶여 있는 코드나 테스트하기 어려운 코드를 얻게 될 수 있습니다.\n\n```js\n// Angular의 의존성 주입을 적절하게 사용하지 않은 예시\n// 서비스에 대한 의존성 주입 가이드라인을 무시한 예\nimport { Component } from '@angular/core';\nimport { ExampleService } from './example.service';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <!-- ... 템플릿 코드 ... -->\n  `,\n  providers: [ExampleService] // 의존성 주입을 사용하지 않고 서비스를 주입하는 예\n})\nexport class ExampleComponent {\n  constructor() {\n    this.exampleService = new ExampleService(); // 의존성 주입을 사용하지 않고 서비스를 주입하는 예\n  }\n  // ...\n}\n```\n\nAngular의 최선의 실천 방법을 따르면 코드베이스를 유지보수 가능하고 확장 가능하며 업계 표준을 준수할 수 있습니다. Angular 애플리케이션의 최적 개발과 유지 관리를 위해 최신 Angular 최선의 실천 방법과 코딩 규칙과 일치하도록 코드베이스를 정기적으로 검토하고 업데이트하는 것이 중요합니다.\n\n## DOM 조작 최적화하지 않기\n\n<div class=\"content-ad\"></div>\n\n과도한 양방향 데이터 바인딩:\n\n```js\n<!-- 컴포넌트 템플릿 -->\n<input [(ngModel)]=\"username\" />\n```\n\n이 예에서는 username이라는 속성이 양방향 데이터 바인딩을 사용하여 입력 필드에 바인딩되었을 경우, 입력 필드의 변경이 발생하면 변경 감지가 트리거되어 DOM이 업데이트됩니다. 이로 인해 빈번하고 불필요한 DOM 업데이트가 발생할 수 있어, 대규모 양식이나 빈번히 업데이트되는 입력란을 다룰 때 퍼포먼스 문제가 발생할 수 있습니다.\n\n이를 최적화하기 위해 (input) 및 (change)와 같은 이벤트 핸들링을 사용하여 일방향 데이터 바인딩을 고려하고, 두방향 데이터 바인딩 대신 필요할 때만 컴포넌트 속성을 수동으로 업데이트할 수 있습니다. 다음은 이에 대한 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n<!-- 컴포넌트 템플릿 -->\n<input [value]=\"username\" (input)=\"onUsernameInput($event.target.value)\" />\n\n<!-- 컴포넌트 클래스 -->\nonUsernameInput(value: string) {\n  this.username = value;\n}\n```\n\nRenderer2 API를 사용하지 않고 안전한 DOM 업데이트를 하지 않은 예시:\n\n```js\n<!-- 컴포넌트 템플릿 -->\n<div [style.backgroundColor]=\"bgColor\">안녕, 세상아!</div>\n```\n\n이 예시에서 bgColor 속성은 div 요소의 style.backgroundColor 속성에 바인딩되어 있어, DOM 스타일을 직접 조작하고 있습니다. 그러나 DOM을 직접 조작하는 것은 위험할 수 있고 권장되지 않습니다. 이는 애플리케이션에 보안 취약점을 노출시키고 Angular의 내장 보안 기능을 우회할 수 있기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n이를 최적화하기 위해 DOM을 안전하게 조작하는 Angular의 Renderer2 API를 사용할 수 있습니다. 예를 들어:\n\n```js\n<!-- 컴포넌트 템플릿 -->\n<div #myDiv>Hello, World!</div>\n```\n\n```js\n<!-- 컴포넌트 클래스 -->\nimport { Renderer2, ElementRef, ViewChild } from '@angular/core';\n\n@ViewChild('myDiv', { static: true }) myDiv: ElementRef;\n\nconstructor(private renderer: Renderer2) {}\n\nngOnInit() {\n  this.renderer.setStyle(this.myDiv.nativeElement, 'backgroundColor', this.bgColor);\n}\n```\n\n이 예에서는 Renderer2 API를 사용하여 div 요소의 배경색 스타일을 안전하게 설정하고 Angular의 보안 기능이 적용되어 DOM 조작이 최적화됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 에러 조건 처리하지 않기:\n\n실패한 HTTP 요청 처리하기:\n\nAngular 애플리케이션에서 실패한 HTTP 요청을 처리하지 않는 것이 어떤 문제를 일으킬 수 있는지 예시를 보여드리겠습니다:\n\n```js\nimport { Component } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <div>{ data }</div>\n  `,\n})\nexport class ExampleComponent {\n  data: string;\n\n  constructor(private http: HttpClient) {}\n\n  getData() {\n    this.http.get('/api/data').subscribe(\n      (data) => {\n        this.data = data; // 검색한 데이터로 UI 업데이트\n      },\n      (error) => {\n        console.error('데이터 가져오기 실패:', error); // 에러 기록\n      }\n    );\n  }\n}\n```  \n\n<div class=\"content-ad\"></div>\n\n위 예시에서는 Angular의 HttpClient를 사용하여 HTTP GET 요청을 /api/data로 보내고 있습니다. http.get() 메서드로 반환된 Observable에 구독하여 데이터를 검색하고 있습니다. 그러나 subscribe() 메서드의 두 번째 콜백 함수를 사용하여 적절한 오류 처리를 구현하지 않았습니다.\n\n이로 인해 다음과 같은 문제가 발생할 수 있습니다:\n\n- 애플리케이션 충돌: HTTP 요청 중에 오류가 발생하는 경우(네트워크 오류 또는 서버 측 오류 등), 오류는 subscribe() 메서드의 오류 콜백으로 전달됩니다. 그러나 적절한 오류 처리를 구현하지 않았기 때문에 오류가 처리되지 않고, 이로 인해 예외가 발생하여 애플리케이션이 충돌할 수 있습니다.\n- 일관성 없는 동작: HTTP 요청 중에 오류가 발생하는 경우 데이터 속성이 업데이트되지 않을 수 있지만 UI는 여전히 사용자에게 불완전하거나 일관성 없는 정보를 표시할 수 있습니다. 이는 사용자 경험을 해치고 부정확한 애플리케이션 동작으로 이어질 수 있습니다.\n- 오류 가시성 부족: 적절한 오류 처리 없이 오류 메시지나 로그가 사용자에게 표시되지 않거나 디버깅을 위해 기록되지 않을 수 있습니다. 이는 애플리케이션의 문제를 식별하고 해결하는 데 어려움을 줄 수 있으며, 안정성과 신뢰성이 감소할 수 있습니다.\n\n이 문제를 해결하기 위해서는 사용자에게 오류 메시지를 표시하거나 디버깅을 위해 오류를 기록하고 오류에서 원활하게 복구하는 등의 적절한 오류 처리 메커니즘을 구현하는 것이 중요합니다. 이전 코드 예제에서 보여준 대로 이를 수행하여 Angular 애플리케이션의 안정성과 신뢰성을 확보할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { catchError } from 'rxjs/operators';\nimport { throwError } from 'rxjs';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <div>{ data }</div>\n    <div class=\"error\" *ngIf=\"errorMessage\">{ errorMessage }</div>\n  `,\n})\nexport class ExampleComponent {\n  data: string;\n  errorMessage: string;\n\n  constructor(private http: HttpClient) {}\n\n  getData() {\n    this.http.get('/api/data').pipe(\n      catchError((error) => {\n        this.errorMessage = 'Failed to get data: ' + error; // Display error message\n        console.error('Failed to get data:', error); // Log error\n        return throwError(error); // Rethrow the error to propagate\n      })\n    ).subscribe(\n      (data) => {\n        this.data = data; // Update UI with retrieved data\n      }\n    );\n  }\n}\n```\n\n개선된 예시에서는 RxJS 라이브러리의 catchError 연산자를 사용하여 HTTP 요청 중 발생하는 오류를 처리했습니다. HTTP 요청 중 오류가 발생하면 catchError 연산자가 오류를 잡고 사용자 정의 오류 처리 논리를 구현할 수 있게 합니다. 이 경우 UI에 오류 메시지를 표시하고 오류를 콘솔에 로깅하고 있습니다. 또한 RxJS의 throwError를 사용하여 오류를 재전파하여 처리되지 않은 상태로 남지 않도록 하고 있습니다.\n\n적절한 오류 처리 메커니즘을 구현함으로써, HTTP 요청의 오류가 적절히 처리되고, 사용자에게 오류 메시지가 표시되며, 디버깅을 위해 오류가 로깅되고, 응용 프로그램이 안정적이고 신뢰할 수 있게 유지될 수 있습니다.\n\n예기치 않은 예외 처리:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <button (click)=\"onButtonClick()\">Click me</button>\n  `,\n})\nexport class ExampleComponent {\n  onButtonClick() {\n    // This code may throw an unexpected exception\n    throw new Error('Unexpected exception occurred');\n  }\n}\n```\n\n이 예시에서는 간단한 Angular 컴포넌트가 있는데, 버튼 클릭 이벤트 핸들러가 포함되어 있습니다. 버튼을 클릭하면 onButtonClick() 메서드가 호출되는데, 이 메서드에는 예상치 못한 예외가 발생할 수 있는 코드가 포함되어 있습니다. 그러나 이 예외를 잡고 처리하기 위한 오류 처리 메커니즘이 구현되어 있지 않습니다.\n\n예기치 못한 예외를 처리하지 않는 문제는 응용 프로그램을 충돌시키고 일관성없는 사용자 경험을 유발할 수 있다는 것입니다. 예상치 못한 예외가 발생하면 응용 프로그램이 알 수 없는 상태로 남아 있고, 사용자는 빈 화면이나 깨진 화면을 보거나 응용 프로그램이 응답하지 않을 수 있습니다. 더욱이, 예외가 처리되지 않았으므로 디버깅 목적으로 기록되지 않을 수도 있어 문제를 진단하고 해결하는 것이 어려울 수 있습니다.\n\n예상치 못한 예외를 잡고 처리하기 위해 try-catch 블록을 사용하거나 Angular에서 전역 오류 처리 기술을 사용하는 등 적절한 오류 처리 메커니즘을 구현하는 것이 중요합니다. 이는 응용 프로그램이 안정적이고 신뢰성 있게 유지되며, 예기치 않은 오류가 발생해도 일관된 사용자 경험을 제공하도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `\n    <button (click)=\"onButtonClick()\">Click me</button>\n    <div *ngIf=\"errorMessage\" class=\"error-message\">{ errorMessage }</div>\n  `,\n})\nexport class ExampleComponent {\n  errorMessage: string = '';\n\n  onButtonClick() {\n    try {\n      // This code may throw an unexpected exception\n      throw new Error('Unexpected exception occurred');\n    } catch (error) {\n      // Handle the error and display error message\n      this.errorMessage = 'An error occurred: ' + error.message;\n      console.error(error); // Log the error for debugging\n    }\n  }\n}\n```\n\n개선된 예시에서는 예기치 못한 예외가 발생할 수 있는 코드 주변에 try-catch 블록을 추가했습니다. 예외가 발생하면 catch 블록에서 잡히며, 사용자에게 오류 메시지를 표시하고 디버깅 목적으로 오류를 로깅할 수 있습니다. 예기치 못한 예외를 처리함으로써 응용 프로그램이 안정적으로 유지되고 예기치 않은 오류가 발생해도 일관된 사용자 경험을 제공할 수 있습니다.\n\n요약하면, Angular는 웹 응용 프로그램을 구축하기 위한 강력하고 기능이 풍부한 프레임워크이지만, 최적의 성능, 유지 관리 및 신뢰성을 보장하기 위해 개발자들이 인식하고 피해야 할 몇 가지 흔한 실수가 있습니다. 이러한 실수에는 부적절한 컴포넌트 설계, 비효율적인 변경 감지, 반응형 프로그래밍의 부재, 적절하지 않은 메모리 관리, 성능 최적화의 부족, 보안 모범 사례 무시, 테스트 부재, Angular 최상의 실천법 따르지 않기, 오류 상황 처리를 미뤄두는 것 등이 있습니다.\n\n이러한 일반적인 실수를 이해하고 해결함으로써, 개발자들은 원할하고 신뢰할 수 있는 Angular 애플리케이션을 만들 수 있습니다. 사용자 경험을 원활하게 제공하며 유지 가능하며 확장 가능하며 모범 사례를 준수하는 Angular 애플리케이션을 만들기 위해 Angular 문서를 준수하고 최신 모범 사례를 따르고 적절한 오류 처리, 테스트 및 성능 최적화 기법을 통합하는 것이 중요합니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 리유저블 컴포넌트로 Angular 앱 만들기, 마치 레고처럼\n\n![Image](/assets/img/2024-05-18-10CommonMistakesinAngularDevelopment_1.png)\n\nBit는 오픈 소스 도구로 25만 명 이상의 개발자들이 컴포넌트를 사용해 앱을 구축할 수 있게 도와줍니다.\n\nUI, 기능 또는 페이지를 재사용 가능한 컴포넌트로 바꾸고 애플리케이션 간에 공유할 수 있습니다. 협업하기 쉽고 더 빨리 작업할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n→ 더 알아보기\n\n앱을 컴포넌트로 분할하여 앱 개발을 더 쉽게 만들고 원하는 워크플로에 대한 최상의 경험을 즐기세요:\n\n## → 마이크로 프론트엔드\n\n## → 디자인 시스템\n\n<div class=\"content-ad\"></div>\n\n## → 코드 공유 및 재사용\n\n## → Monorepo\n\n## 더 알아보기:\n\n[https://blog.bitsrc.io/how-we-build-micro-front-ends-d3eeeac0acfc](https://blog.bitsrc.io/how-we-build-micro-front-ends-d3eeeac0acfc)\n\n<div class=\"content-ad\"></div>\n\nhttps://blog.bitsrc.io/how-we-build-our-design-system-15713a1f1833","ogImage":{"url":"/assets/img/2024-05-18-10CommonMistakesinAngularDevelopment_0.png"},"coverImage":"/assets/img/2024-05-18-10CommonMistakesinAngularDevelopment_0.png","tag":["Tech"],"readingTime":38},{"title":"앵귤러에서 let을 사용하여 템플릿 로컬 변수 생성하기","description":"","date":"2024-05-18 21:55","slug":"2024-05-18-TemplatelocalvariableswithletinAngular","content":"\n\n![image](/assets/img/2024-05-18-TemplatelocalvariableswithletinAngular_0.png)\n\n# Angular에서 let 사용하기\n\nAngular를 오랫동안 사용해본 적이 있다면, 언젠가는 템플릿 내에서 변수를 선언하고 싶은 경우가 있을 것입니다. 이것은 나중에 템플릿에서 사용할 값을 저장하고 싶을 때 흔히 발생하는 상황입니다.\n\n가장 일반적인 방법은 ngIf와 같은 디렉티브를 사용하여 as 키워드를 이용해 변수에 값을 할당하는 것입니다. 예를 들면:\n\n<div class=\"content-ad\"></div>\n\n```js\n<div *ngIf=\"user$ | async as user\">\n  <h1>{ user.name }</h1>\n</div>\n\n<!-- 또는 새로운 제어 흐름 사용 -->\n@if (user$ | async; as user) {\n  <h1>{ user.name }</h1>\n}\n```\n\n숫자를 다루고 있을 때는 어떻게 될까요?\n\n```js\n<div>\n    @if (points$ | async; as points) {\n        <h1>당신은 { points } 포인트를 가지고 있습니다!</h1>\n    }\n</div>\n```\n\n템플릿에서 포인트가 0이라면 어떻게 표시될까요? 아무것도 표시되지 않을 것입니다! 왜냐하면 0은 falsy한 값이기 때문에 if 블록 내에서 사용될 때 내용을 표시하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n새로운 @let 블록이 작용하는 곳입니다. @let 블록을 사용하면 템플릿 내에서 변수를 선언하고 나중에 템플릿에서 사용할 수 있습니다. 어떻게 작동하는지 살펴봅시다.\n\n```js\n<div>\n    @let points = (points$ | async) ?? 0;  \n    <h1>You have: { points } points!</h1>\n</div>\n```\n\n이렇게 하면 points가 0이더라도 내용이 렌더링됩니다. 이는 let 블록이 Falsy 값을 확인하지 않기 때문에 발생하는 것이며 템플릿에서 그 시점에 변수를 선언하기 때문입니다.\n\n또한, @let 블록의 가장 일반적인 사용 사례 중 하나는 복잡한 표현식에 대한 별칭을 저장할 수 있는 변수를 저장하는 것입니다. 예를 들어:\n\n<div class=\"content-ad\"></div>\n\n```js\n@let someField = someService.someSignal().someProperty.someOtherProperty;\n<div>{ someField }</div>\n```\n\n# Angular에서 @let 사용 방법\n\n다음은 새로운 @let를 여러 방법으로 사용할 수 있습니다:\n\n- 비동기 파이프와 함께:\n\n<div class=\"content-ad\"></div>\n\n\n```js\n<div>\n    @let user = (user$ | async) ?? { name: 'Guest' };  \n    <h1>{ user.name }</h1>\n</div>\n```\n\n- With control flow directives:\n\n```js\n<div>\n    @let user = user$ | async;  \n    @if (user) {\n        <h1>{ user.name }</h1>\n    }\n</div>\n```\n\n- Inside @for to refactor code duplications:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n<mat-selection-list>\n    @for (item of items(); track item.id) {\n        @let isSelected = item.id === selectedId();\n        <mat-list-option [selected]=\"isSelected\" [class.selected]=\"isSelected\">\n            { item.text } \n            @if (isSelected) {\n                <span>(selected)</span>\n            }\n        </mat-list-option>\n    }\n</mat-selection-list>\n```\n\n- 삼항 연산자 활용:\n\n```js\n<div>\n    @for (game of games; track game.id) {\n        @let points = calcPoints(game.points > 0 ? game.points : 0);  \n        <h1>You have: { points } points!</h1>\n    }\n</div>\n```\n\n- 기본 산술 연산자 활용:\n\n<div class=\"content-ad\"></div>\n\n```js\n<div>\n   @for (게임 of 게임목록; 게임.id로 순회) {\n       @let 합계 = 이전합계 + 게임.점수; \n       <h1>총 점수: { 합계 }</h1>\n   }\n</div>\n```\n\n- 신호와 함께:\n\n```js\n<div>\n    @let 사용자이름 = 사용자()?.이름 ?? '손님';\n    <h1>환영합니다, { 사용자이름 }</h1>\n</div>\n```\n\n- 여러 선언을 한 줄에 나열하거나 여러 줄에 나눠서 선언하기:\n\n<div class=\"content-ad\"></div>\n\n```js\n<div>  \n    @let total = count + previousCount, average = calcAverage(count), (여기서 `total`을 사용할 수 있을까요?)\n    \n    @let total = count + previousCount, \n         average = calcAverage(count)\n    <h1>{total}</h1>\n</div>\n```\n\n# 좋은 정보\n\nlet 선언은 JavaScript의 let 선언과 거의 동일하게 작동합니다.\n\n- 스코핑은 JavaScript의 let과 동일하게 작동합니다.\n- 타입 추론이 그대로 작동합니다!\n- let 선언은 구성 속성보다 로컬 let 선언을 우선시합니다.\n- let 선언은 정의되기 전에 참조할 수 없으며, 예외는 이벤트 핸들러 내에서 사용될 때입니다. \n\n\n<div class=\"content-ad\"></div>\n\n이 기능은 2017년 3월부터 열려 있던 문제를 해결합니다.\n\n이 PR에서는 @let 블록이 도입되기 전에 고려된 여러 대안을 볼 수 있습니다.\n\n- @let 대신 @const\n- 새로운 키워드 전체\n- @let 대신 @var\n- 블록 형식의 구문\n\nPR에 대한 자세한 정보는 여기에서 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n여기서 새로운 @let 블록을 Angular 템플릿에서 사용하는 방법이 있습니다. 이 기능은 아마도 예상대로 다가오는 달에 출시될 Angular v18.1에서 사용 가능할 것으로 예상됩니다.\n\nAngular 템플릿에서 @let 블록의 다른 사용 사례에 대해 떠오르는 것이 있으면 알려주세요. 🚀\n\n# 읽어 주셔서 감사합니다!\n\n만약 이 글이 흥미로웠고 유용하다고 생각되고 Angular에 대해 더 배우고 싶다면, 제게 커피 한 잔 사주는 걸로 응원해주세요 ☕️ 또는 X(이전 트위터) @Enea_Jahollari에서 저를 팔로우해주세요. Angular 최신 뉴스, 신호, 비디오, 팟캐스트, 업데이트, RFC, 풀 리퀘스트 등에 대해 많이 트윗하고 블로깅합니다. 💎","ogImage":{"url":"/assets/img/2024-05-18-TemplatelocalvariableswithletinAngular_0.png"},"coverImage":"/assets/img/2024-05-18-TemplatelocalvariableswithletinAngular_0.png","tag":["Tech"],"readingTime":4}],"page":"66","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}