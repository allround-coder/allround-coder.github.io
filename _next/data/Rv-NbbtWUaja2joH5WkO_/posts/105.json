{"pageProps":{"posts":[{"title":"RAWALPINDI, 이슬라마바드를 위한 최고의 PHP MySQL 및 Laravel 강좌인 FIT 인증 코스","description":"","date":"2024-05-14 14:54","slug":"2024-05-14-FITProvedBestPHPMySQLandLaravelCourseForRawalpindiIslamabad","content":"\n\n![FIT Proved Best PHP, MySQL, and Laravel Course in Rawalpindi Islamabad](/assets/img/2024-05-14-FITProvedBestPHPMySQLandLaravelCourseForRawalpindiIslamabad_0.png)\n\n- 웹사이트: [Future IT Technology](https://futureittechnology.com/)\n- 코스 링크: [PHP, MySQL, Laravel 코스](https://futureittechnology.com/php-mySQL-Laravel.html)\n\n안녕하세요! 이 포괄적인 코스는 PHP, MySQL 및 Laravel 프레임워크를 사용하여 웹 개발을 초급자에서 고급 수준까지 안내합니다. 프로그래밍이 처음이신 분들이거나 다른 언어에 어느 정도 경험이 있는 분들도 이 코스를 통해 견고한 웹 애플리케이션을 구축하는 데 필요한 기술과 지식을 습득할 수 있습니다.\n\n\n\n수업 개요:\n\n1. PHP를 활용한 웹 개발 소개\n\n- 웹 개발의 기본 개념 이해\n- PHP 프로그래밍 언어 소개\n- 개발 환경 설정하기\n\n2. MySQL 시작하기\n\n\n\n- MySQL 데이터베이스 관리 시스템 소개\n- 데이터베이스 및 테이블 생성\n- CRUD 작업 수행 (생성, 조회, 업데이트, 삭제)\n\n3. PHP 기초\n\n- 변수, 데이터 유형 및 연산자\n- 제어 구조 (if 문, 반복문)\n- 함수 및 배열\n- 양식 처리와 유효성 검사\n\n5. Laravel 소개\n\n\n\n- Laravel 프레임워크 이해하기\n- Laravel 환경 설정하기\n- Laravel 디렉토리 구조 및 설정\n\n6. Laravel로 애플리케이션 개발하기\n\n- 라우트 생성 및 관리\n- 컨트롤러 및 뷰 사용하기\n- 데이터베이스 마이그레이션과 시딩\n- 인증과 권한 부여\n- 데이터베이스 작업을 위한 엘로퀀트 ORM 사용\n\n7. 고급 Laravel 기술\n\n\n\n- 미들웨어 및 라우트 보호\n- RESTful API 개발\n- Laravel 패키지 사용\n- Laravel 애플리케이션 테스트 및 디버깅\n- 성능 최적화 기술\n\n필요 사항:\n\n- HTML 및 CSS의 기본적인 이해\n- 프로그래밍 컨셉(변수, 반복문, 함수)에 대한 이해\n- PHP, MySQL 또는 Laravel 경험이 없어도 됨\n\n이 수업을 마치면 웹 개발 원리, PHP 프로그래밍 언어, MySQL 데이터베이스 관리 및 Laravel 프레임워크에 대한 견고한 이해를 얻을 것입니다. 제작된 데이터 기반의 동적 웹 애플리케이션을 처음부터 만들고 제작 환경에 배포할 수 있게 될 것입니다.\n\n\n\n# PHP 기본 과정\n# PHP 고급 과정\n# 이슬라마바드 프리랜싱 과정\n# 라왈핀디 프리랜싱 과정\n# 라왈핀디 PHP 강좌\n# 이슬라마바드 PHP 강좌\n# 이슬라마바드 웹 디자인 강좌\n# 이슬라마바드 웹 개발 강좌\n# 라왈핀디 웹 디자인 강좌\n# 라왈핀디 웹 개발 강좌\n# 라왈핀디 이슬라마바드 고급 웹 개발\n# 라왈핀디 이슬라마바드 웹 개발 학원\n# 라왈핀디 이슬라마바드 IT 강좌\n# 라왈핀디 이슬라마바드 최고의 컴퓨터 학원\n\n[futureittechnology.com](https://futureittechnology.com/)\n\n[PHP, MySQL, Laravel](https://futureittechnology.com/php-mySQL-Laravel.html)\n\n주소: 퓨처 IT 기술, 피트 컴퓨터 학원 2층, 알-Mustafa 플라자, 찬드니 초크 근처, C 블록 피트 타운, 라왈핀디, 펀잡 46000\n\n\n\n휴대폰: 0344 5701828","ogImage":{"url":"/assets/img/2024-05-14-FITProvedBestPHPMySQLandLaravelCourseForRawalpindiIslamabad_0.png"},"coverImage":"/assets/img/2024-05-14-FITProvedBestPHPMySQLandLaravelCourseForRawalpindiIslamabad_0.png","tag":["Tech"],"readingTime":2},{"title":"Nodejs에서 Role-Based Access Control RBAC 구현하기","description":"","date":"2024-05-14 14:52","slug":"2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs","content":"\n\n역할 기반 액세스 제어 (RBAC)는 응용 프로그램 보안의 중요한 측면입니다. 조직 또는 응용 프로그램 내에서 사용자의 역할에 따라 리소스에 대한 액세스를 관리하고 제한하는 구조화된 접근 방식을 제공합니다. 이 포괄적인 안내서에서는 RBAC 개념을 탐색하고 혜택을 논의하며 Node.js 응용 프로그램에 RBAC를 구현하는 과정을 안내합니다. 이 글을 마치면 직접 프로젝트에 대해 RBAC를 설계하고 구현하는 방법을 명확히 이해할 수 있을 것입니다.\n\n![2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_0](/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_0.png)\n\n# 목차\n\n- 역할 기반 액세스 제어 (RBAC) 소개\n\n\n\n- RBAC이란 무엇인가요?\n- RBAC의 장점들\n\n- Node.js 환경 설정하기\n\n- 준비물\n- 프로젝트 구조\n\n- 예시 프로젝트: RBAC 실습하기\n\n\n\n- 간단한 업무 관리 시스템 구축\n- 역할 및 권한 정의\n- 인증 및 권한 부여 구현\n- RBAC 시스템 테스트\n\n- 최상의 실천 방법 및 보안 고려 사항\n\n- 데이터 유효성 검사\n- 감사 추적\n- 세분화된 권한\n- 정기적인 업데이트 및 모니터링\n\n- 결론\n\n\n\n# 1. 역할 기반 액세스 제어 (RBAC) 소개\n\n# RBAC란 무엇인가요?\n\n역할 기반 액세스 제어 (RBAC)은 시스템 액세스를 인가된 사용자로 제한하는 보안 개념입니다. RBAC에서는 액세스 권한이 역할과 연관되며 사용자에게 하나 이상의 역할이 할당됩니다. 이러한 역할은 사용자가 시스템 내에서 어떤 작업이나 작업을 수행할 수 있는지를 정의합니다.\n\nRBAC는 권한을 중앙 집중화하여 액세스 제어를 간소화하며, 관리자가 고수준에서 사용자 액세스를 관리할 수 있게 합니다. 사용자가 자신의 역할을 수행하는 데 필요한 권한만 갖도록 보장하여 보안을 강화하며, 무단 조치의 위험을 줄입니다.\n\n\n\n# 롤 기반 인증 이해하기\n\n롤 기반 인증은 사용자에게 역할을 할당하고 해당 역할에 따라 리소스에 대한 액세스를 결정하는 액세스 제어 방법입니다. 보통 각 역할에는 관련된 권한 집합이 있고, 사용자들은 할당된 역할에 기반하여 리소스에 액세스 권한이 부여됩니다.\n\n응용 프로그램에 따라 역할은 다양할 수 있지만 일반적으로 사용되는 역할은 다음과 같습니다:\n\n- Admin: 일반적으로 모든 기능에 액세스하고 관리 작업을 수행할 수 있는 관리 권한이 있는 사용자입니다.\n- User: 기본 기능 및 기능에 액세스 권한이 있는 표준 사용자입니다.\n- Moderator: 콘텐츠를 조절하거나 사용자를 관리하는 역할을 맡은 권한이 있는 사용자입니다.\n- Guest: 인증되지 않은 사용자로서 애플리케이션에 제한된 액세스 권한을 갖는 사용자입니다.\n\n\n\n# RBAC의 장점\n\nRBAC를 구현하면 다음과 같은 여러 가지 이점이 있습니다:\n\n- 보안: RBAC는 응용 프로그램 내에서 미인가된 액세스나 작업의 위험을 최소화하여 보안 취약점을 줄입니다.\n- 간편함: RBAC는 권한을 역할로 그룹화하여 사용자 액세스 관리를 간편하게 만들어 관리를 더 간편하게 합니다.\n- 확장성: RBAC는 매우 확장 가능하여 소규모 및 대규모 응용 프로그램에 모두 적합합니다.\n- 준수: GDPR 및 HIPAA와 같은 많은 규제 프레임워크는 RBAC와 같은 견고한 액세스 제어 메커니즘을 요구합니다.\n- 감사 기능: RBAC를 사용하면 사용자 작업을 추적하고 감사할 수 있어 보안 침해를 식별하는 데 중요합니다.\n\n이제 RBAC의 개념과 장점을 이해했으니, Node.js 애플리케이션에서 구현해 봅시다.\n\n\n\n# 2. Node.js 환경 설정하기\n\n# 요구 사항\n\nRBAC 구현에 들어가기 전에, 다음의 요구 사항이 갖춰져 있는지 확인해주세요:\n\n- 시스템에 Node.js가 설치되어 있어야 합니다.\n- 코드 편집기(예: Visual Studio Code)가 필요합니다.\n- JavaScript와 Node.js의 기본 지식이 요구됩니다.\n- Node.js 애플리케이션을 실행하기 위한 터미널 또는 명령 프롬프트가 있어야 합니다.\n- 의존성을 설치하기 위한 npm(Node Package Manager)이 필요합니다.\n\n\n\n# 프로젝트 구조\n\n이번 튜토리얼에서 사용할 기본 프로젝트 구조입니다:\n\n```js\nrbca/\n│\n├── helpers/\n│   ├── db.js\n│   ├── errorHandler.js\n│   ├── jwt.js\n│   └── role.js\n│\n├── models/\n│   └── user.js\n│\n├── public/\n│   └── stylesheets/\n│       └── style.css\n│\n├── routes/\n│   ├── index.js\n│   └── user.controllers.js\n│\n├── services/\n│   └── user.services.js\n│\n├── views/\n│   ├── error.jade\n│   ├── index.jade\n│   └── layout.jade\n│\n├── .gitignore\n├── README.md\n├── app.js\n├── config.json\n├── package-lock.json\n└── package.json\n```\n\n이 프로젝트 구조는 튜토리얼을 진행하면서 점진적으로 구성해 나갈 것입니다.\n\n\n\n# 의존성 설치\n\n```js\nnpm install bcryptjs@^2.4.3 cookie-parser@~1.4.4 cors@^2.8.5 debug@~2.6.9 express@~4.16.1 express-jwt@^6.0.0 http-errors@~1.6.3 jade@~1.11.0 jsonwebtoken@^8.5.1 mongoose@^5.9.25 morgan@~1.9.1 rootpath@^0.1.2 --save\n```\n\n# helpers/db.js:\n\n```js\nconst config = require(\"../config.json\");\nconst mongoose = require(\"mongoose\");\nconst conenctionOptions = {\n  useCreateIndex: true,\n  useNewUrlParser: true,\n  useUnifiedTopology: true,\n  useFindAndModify: false,\n};\ntry {\n  mongoose\n    .connect(\n      process.env.MONGODB_URI || config.connectionString,\n      conenctionOptions\n    )\n    .then((res) => console.log(`MOngoDB connected Successfully..!`));\n} catch (error) {\n  console.log(`MongoDB Error: `, error.message);\n  process.exit(1);\n}\n\nmongoose.Promise = global.Promise;\n\nmodule.exports = {\n  User: require(\"../models/user\"),\n};\n```\n\n\n\n- mongoose 모듈을 가져옵니다\n- 설정에서 데이터베이스 URL을 읽어옵니다\n- 연결 옵션을 설정합니다\n- 연결 및 오류 이벤트를 처리합니다\n- Promise 라이브러리를 구성합니다\n- 다른 곳에서 사용할 모델을 내보냅니다\n\nhelpers/errorHandler.js:\n\n```js\nfunction errorHandler(err, req, res, next) {\n  if (typeof err === \"string\") {\n    // 사용자 정의 애플리케이션 오류\n    return res.status(400).json({ message: err });\n  }\n  if (err.name === \"ValidationError\") {\n    // mongoose 유효성 검사 오류\n    return res.status(400).json({ message: err.message });\n  }\n\n  if (err.name === \"UnauthorizedError\") {\n    // jwt 인증 오류\n    return res.status(401).json({ message: \"잘못된 토큰\" });\n  }\n\n  // 기본적으로 500 서버 오류\n  return res.status(500).json({ message: err.message });\n}\n\nmodule.exports = errorHandler;\n```\n\nhelpers/jwt.js:\n\n\n\n```js\nconst expressJwt = require(\"express-jwt\");\nconst config = require(\"../config.json\");\nconst db = require(\"../helpers/db\");\n\nfunction jwt(roles = []) {\n  // roles 매개변수는 단일 역할 문자열 (예: Role.User 또는 'User')이거나 역할 배열 ([Role.Admin, Role.User] 또는 ['Admin', 'User'])일 수 있습니다.\n  if (typeof roles === \"string\") {\n    roles = [roles];\n    console.log(roles);\n  }\n\n  const secret = config.secret;\n\n  return [\n    // JWT 토큰을 인증하고 사용자를 요청 객체(req.user)에 추가합니다.\n    expressJwt({ secret, algorithms: [\"HS256\"] }),\n\n    // 사용자 역할에 따라 권한 부여\n    async (req, res, next) => {\n      const user = await db.User.findById(req.user.sub);\n\n      if (!user || (roles.length && !roles.includes(user.role))) {\n        // 사용자 역할이 허가되지 않았습니다.\n        return res.status(401).json({ message: \"Only Admin is Authorized!\" });\n      }\n      // 인증 및 권한 부여 성공\n      req.user.role = user.role;\n      next();\n    },\n  ];\n}\n\nmodule.exports = jwt;\n```\n\nhelpers/role.js:\n\n```js\nmodule.exports = {\n  Admin: \"Admin\",\n  User: \"User\",\n};\n```\n\nmodels/user.js:\n\n\n\n\n```js\nconst mongoose = require(\"mongoose\");\nconst Schema = mongoose.Schema;\n\nconst schema = new Schema({\n  email: { type: String, unique: true, required: true },\n  firstName: { type: String, required: true },\n  lastName: { type: String, required: true },\n  password: { type: String, required: true },\n  role: { type: String, required: true },\n  createdDate: { type: Date, default: Date.now },\n});\n\nschema.set(\"toJSON\", {\n  virtuals: true,\n  versionKey: false,\n  transform: function (doc, ret) {\n    delete ret._id, delete ret.password;\n  },\n});\n\nmodule.exports = mongoose.model(\"User\", schema);\n```\n\nroutes/index.js:\n\n```js\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\nmodule.exports = router;\n```\n\nroutes/user.controllers.js:\n\n\n\n\n```js\nconst express = require(\"express\");\nconst router = express.Router();\nconst userServices = require(\"../services/user.services\");\nconst Role = require(\"../helpers/role\");\nconst jwt = require(\"../helpers/jwt\");\n\n// 라우트\nrouter.post(\"/authenticate\", authenticate);\nrouter.post(\"/register\", register);\nrouter.get(\"/\", jwt(Role.Admin), getAll);\nrouter.get(\"/current\", jwt(), getCurrent);\nrouter.get(\"/:id\", getById);\nrouter.put(\"/:id\", update);\nrouter.delete(\"/:id\", _delete);\n\nmodule.exports = router;\n\n// 라우트 함수\nfunction authenticate(req, res, next) {\n  userServices\n    .authenticate(req.body)\n    .then((user) => {\n      console.log(user);\n      user\n        ? res.json({ user: user, message: \"사용자가 로그인되었습니다.\" })\n        : res\n            .status(400)\n            .json({ message: \"사용자 이름 또는 비밀번호가 잘못되었습니다.\" });\n    })\n    .catch((error) => next(error));\n}\n\nfunction register(req, res, next) {\n  userServices\n    .create(req.body)\n    .then((user) =>\n      res.json({\n        user: user,\n        message: `이메일 ${req.body.email}으로 성공적으로 등록되었습니다.`,\n      })\n    )\n    .catch((error) => next(error));\n}\n\nfunction getAll(req, res, next) {\n  const currentUser = req.user;\n\n  if (currentUser.role !== Role.Admin) {\n    return res.status(401).json({ message: \"권한이 없습니다!\" });\n  }\n  userServices\n    .getAll()\n    .then((users) => res.json(users))\n    .catch((err) => next(err));\n}\n\nfunction getCurrent(req, res, next) {\n  console.log(req);\n  userServices\n    .getById(req.user.sub)\n    .then((user) => (user ? res.json(user) : res.status(404)))\n    .catch((error) => next(error));\n}\n\nfunction getById(req, res, next) {\n  userServices\n    .getById(req.params.id)\n    .then((user) => {\n      if (!user) {\n        res.status(404).json({ message: \"사용자를 찾을 수 없습니다!\" });\n        next();\n      }\n      return res.json(user);\n    })\n    .catch((error) => next(error));\n}\n\nfunction update(req, res, next) {\n  userServices\n    .update(req.params.id, req.body)\n    .then(() =>\n      res.json({\n        message: `ID가 ${req.params.id}인 사용자가 성공적으로 업데이트되었습니다.`,\n      })\n    )\n    .catch((error) => next(error));\n}\n\nfunction _delete(req, res, next) {\n  userServices\n    .delete(req.params.id)\n    .then(() =>\n      res.json({\n        message: `ID가 ${req.params.id}인 사용자가 성공적으로 삭제되었습니다.`,\n      })\n    )\n    .catch((error) => next(error));\n}\n```\n\nservices/user.services.js:\n\n```js\nconst jwt = require(\"jsonwebtoken\");\nconst bcrypt = require(\"bcryptjs\");\nconst config = require(\"../config.json\");\nconst db = require(\"../helpers/db\");\nconst User = db.User;\n\n// 사용자 자격 증명을 인증하는 함수\nasync function authenticate({ email, password }) {\n  // 이메일로 사용자 찾기\n  const user = await User.findOne({ email });\n  console.log(\"사용자 모델\", user);\n  // 사용자가 있고 암호가 일치하면 토큰 생성\n  if (user && bcrypt.compareSync(password, user.password)) {\n    const token = jwt.sign({ sub: user.id, role: user.role }, config.secret, {\n      expiresIn: \"7d\",\n    });\n    \n    return { ...user.toJSON(), token };\n  }\n}\n\n// 모든 사용자 가져오기\nasync function getAll() {\n  return await User.find();\n}\n\n// ID를 사용하여 사용자 가져오기\nasync function getById(id) {\n  console.log(\"ID를 찾는 중: \", id);\n  return await User.findById(id);\n}\n\n// 사용자 추가\nasync function create(userParam) {\n  // 사용자가 있는지 확인\n  const user = await User.findOne({ email: userParam.email });\n  // 유효성 검사\n  if (user) throw `동일한 이메일이 이미 존재합니다: ${userParam.email}`;\n\n  // 사용자 객체 생성\n  const newUser = new User(userParam);\n  if (userParam.password) {\n    newUser.password = bcrypt.hashSync(userParam.password, 10);\n  }\n\n  await newUser.save();\n}\n\n// 사용자 업데이트\nasync function update(id, userParam) {\n  const user = await User.findById(id);\n  if (!user) throw \"사용자를 찾을 수 없습니다.\";\n  if (\n    user.email !== userParam.email &&\n    (await User.findOne({ email: userParam.email }))\n  ) {\n    throw `동일한 이메일을 가진 사용자가 이미 존재합니다: ${userParam.email}`;\n  }\n\n  if (userParam.password) {\n    userParam.password = bcrypt.hashSync(userParam.password, 10);\n  }\n\n  // 사용자 객체 복사\n  Object.assign(user, userParam);\n  await user.save();\n}\n\nasync function _delete(id) {\n  await User.findByIdAndRemove(id);\n}\n\nmodule.exports = {\n  authenticate,\n  getAll,\n  getById,\n  create,\n  update,\n  delete: _delete,\n};\n```\n\n\n\n```js\n레이아웃 확장\n\n콘텐츠 블록\n  h1= 메시지\n  h2= 오류 상태\n  pre #{error.stack}\n```\n\nviews/index.jade:\n\n```js\n레이아웃 확장\n\n콘텐츠 블록\n  h1= 제목\n  p 환영합니다 #{title}\n```\n\nviews/layout.jade:\n\n\n\n```json\n{\n  \"database\": {\n    \"host\": \"localhost\",\n    \"username\": \"admin\",\n    \"password\": \"password123\",\n    \"port\": 3306\n  },\n  \"server\": {\n    \"port\": 5000,\n    \"corsOptions\": {\n      \"origin\": \"*\"\n    }\n  }\n}\n```\n\n\n\n```json\n{\n  \"connectionString\": \"//당신의 MONGODB URI\",\n  \"secret\": \"//JWT 토큰을 위한 원하는 시크릿 키\"\n}\n```\n\n사용자 등록\n\n![사진](/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_1.png)\n\n사용자 인증\n\n\n\n\n![Current User](/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_2.png)\n\n![Unauthorize](/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_3.png)\n\n\n\n\n<img src=\"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_4.png\" />\n\n# 7. 모범 사례 및 보안 주의 사항\n\nNode.js 애플리케이션에서 RBAC를 구현할 때 다음 모범 사례와 보안 주의 사항을 고려해보세요:\n\n# 데이터 유효성 검사\n\n\n\n사용자 입력을 항상 유효성 검사하여 SQL 인젝션, XSS 공격 등과 같은 보안 취약점을 방지하세요. 데이터 무결성을 보장하기 위해 유효성 검사 라이브러리나 프레임워크를 사용하세요.\n\n## 감사 로그\n\n사용자 활동과 액세스 시도를 추적하기 위해 감사 로그를 구현하세요. 이는 보안 위반이나 무단 활동을 식별하는 데 중요할 수 있습니다.\n\n## 세분화된 권한\n\n\n\n사용자가 자신의 업무를 수행하는 데 필요한 최소한의 권한을 보장하기 위해 세밀한 권한을 정의하십시오. 역할에 권한을 너무 많이 할당하지 않도록 주의하십시오.\n\n## 정기적인 업데이트와 모니터링\n\nRBAC 시스템을 최신 상태로 유지하십시오. 응용 프로그램이 발전함에 따라 역할과 권한을 조정해야 할 수 있습니다. 보안을 유지하기 위해 정기적으로 RBAC 정책을 모니터링하고 검토하십시오.\n\n## 저와 소통하기:\n\n\n\nLinkedin: [https://www.linkedin.com/in/suneel-kumar-52164625a/](https://www.linkedin.com/in/suneel-kumar-52164625a/)\n\n# 8. 결론\n\n이 포괄적인 안내서에서는 Role-Based Access Control (RBAC)의 개념을 탐구하고 Node.js 애플리케이션에 구현하는 방법을 시연했습니다. 역할 및 권한 정의, 사용자 인증, 역할 할당, 역할 기반 미들웨어, 그리고 RBAC가 작동하는 방식을 보여 주기 위해 샘플 작업 관리 시스템을 만들었습니다.\n\nRBAC를 구현함으로써 Node.js 애플리케이션의 보안을 크게 향상시키고 사용자 액세스를 효과적으로 제어하며 보안 위협을 줄일 수 있습니다. 또한, 최적의 방법을 따르고 보안 고려 사항을 고려함으로써 RBAC 시스템의 견고성을 보장할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingRole-BasedAccessControlRBACinNodejs_0.png","tag":["Tech"],"readingTime":13},{"title":"서버 측 JavaScript의 진화","description":"","date":"2024-05-14 14:48","slug":"2024-05-14-EvolutionofServer-SideJavaScript","content":"\n\n자바 기반 런타임부터 Node.js의 급부상, NPM의 탄생, 성장하는 생태계, 혁신적인 Deno, 그리고 초고속 Bun의 등장까지, 몇 년 동안 서버 측 자바스크립트가 어떻게 발전해 왔는지 알아보세요.\n\n![Evolution of Server-Side JavaScript](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_0.png)\n\n# 초기 시기\n\n서버 측 자바스크립트에 대해 이야기할 때, 먼저 떠오르는 것은 Node.js입니다. 그러나 노드 이전에도 백엔드 자바스크립트는 존재했음을 알아야 합니다. 이들은 생태계를 혁신시키지 않았던 것입니다. 커뮤니티에 영감을 주지 않은 것들. 역사의 잊혀진 페이지들 속에 사라진 것들입니다:\n\n\n\n- Jaxer\n- Silk\n- RingoJS\n- Rihno\n- AppEngineJS 등\n\n자바스크립트는 백엔드 프로젝트에서 피해 왔던 이유가 있습니다. 서버는 요청 당 스레드 모델에서 작동했는데, 이는 싱글 스레드인 자바스크립트와 잘 맞지 않았습니다.\n\n한 스레드가 점유되면 서버가 한 번에 하나의 요청만 처리할 수 있어 느리게 동작할 수밖에 없었습니다.\n\n멀티스레딩을 달성하기 위해 Ringo와 같은 라이브러리는 자바 가상 머신 위에 구축되었습니다. 그러나 심지어 JVM을 사용하여도 이러한 문제들을 해결하지 못했습니다. (서버에서 10,000개의 동시 연결을 처리하는 C10K 문제)\n\n\n\nJavaScript로는 이 문제에 대한 해결책이 없어 보였는데, 2009년 Ryan Dahl이 Node.js를 소개하기 전까지였습니다.\nNode.js는 JVM을 기반으로하지는 않았지만, C10K 문제를 해결했습니다.\n\n그래서 Node.js를 돋보이게 한 것은 무엇일까요? - 바로 비차단입니다!\n\n![Node.js 이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_1.png)\n\n# Node.js\n\n\n\nNode.js는 개방 소스, 크로스 플랫폼, 비동기적이고 이벤트 주도형 자바스크립트 런타임 환경으로, 개발자들이 서버에서 자바스크립트 코드를 실행할 수 있게 해줍니다. 이는 Google Chrome 브라우저를 구동하는 V8 자바스크립트 엔진 위에 구축되어 있습니다.\n\nNode.js는 개발자들이 JavaScript를 통해 OS와 상호작용할 수 있게 해 줍니다. 이는 파일 시스템, 운영 체제 검사, 프로세스 처리 외에도 HTTP 및 TCP 서버를 생성하고, DNS, CLI와 그 이상의 기능들을 사용할 수 있게 해 줍니다.\n\n\n\nNode.js는 최소주의, 속도 및 모듈성(공통JS 모듈을 사용하여)이라는 점에서 마이크로서비스를 개발할 때 완벽한 선택지가 되었습니다.\n결국, Node.js는 많은 노드로 분산 응용 프로그램을 구축하기 위해 설계되었습니다. 따라서 이름이 Node.js인 것입니다.\n\n하지만 Node.js는 그냥 수준을 높인 것이 아니라, 그것을 완전히 파괴했고 이 모든 것은 뒤에서 실행되는 천재적인 아키텍처로 시작되었습니다.\n\n## Non-Blocking I/O\n\nChrome의 V8 엔진(C++)과 Libuv(C 라이브러리)에서 구축되어진 Node.js는 JavaScript 외부에서 I/O 및 비동기 작업을 처리할 수 있도록 허용했습니다. 이때 작업의 스케줄링은 Event Loop에서 처리되었습니다.\n\n\n\n![Node.js](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_2.png)\n\n이것은 Node.js가 메인 JavaScript 스레드를 차단하지 않고 속도를 저하시키지 않고 여러 API 요청을 실행하거나 파일/데이터베이스에 읽기/쓰기를 할 수 있다는 것을 의미합니다.\n\n이 공식은 Node.js에서 이벤트, 소켓, 스트림 및 해싱 알고리즘을 포함하여 CPU 바운드 작업이 아닌 모든 것에서 재사용됩니다.\n\nNode.js 팀은 더 나아가서 Node.js 애플리케이션을 CPU 한계에 도전하게 허용함으로써 당신의 컴퓨터의 모든 파워를 활용할 수 있도록 했습니다. 기본적으로 Node.js는 CPU의 단일 프로세스에서 실행되며, 실패할 경우 그만입니다. 그러나 개발자들이 자식 프로세스를 활용할 수 있게 함으로써, Node.js는 각 CPU에 대해 복제본을 생성하고 내장된 로드 밸런서를 사용하여 트래픽을 균형있게 분산시켜 컴퓨터의 전체 성능을 활용할 수 있습니다.\n\n\n\n\n![이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_3.png)\n\n그리고 하나가 실패하면, Node.js는 다른 것을 분기하고, 사이클을 다시 시작합니다. \n\"단일 스레드\"를 넘어서는 이야기를 해보는 거야.\n\nNode.js는 이 모든 것을 원래부터 제공해. 필요하다면 Nginx나 PM2, Docker, 또는 Kubernetes 같은 프로세스 매니저를 사용해서 기능을 향상시킬 수도 있어.\nNode.js를 따라온 JavaScript 런타임들은 이벤트 기반(논블로킹) 아키텍처를 디자인할 때 Node.js를 따랐지.\n\n하지만 네이티브 메커니즘 외에도, Node.js는 유틸리티, 라이브러리, 프레임워크를 위한 써드파티 패키지로 업그레이드할 수 있게 해 줬어.\n\n\n\n\n\n![Evolution of Server-Side JavaScript](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_4.png)\n\n# NPM\n\nNode Package Manager (NPM)은 Isaac Z. Schlueter에 의해 개발된 JavaScript 언어용 패키지 관리자입니다. NPM의 목적은 Node.js 또는 웹 앱을 다양한 서드파티 도구로 업그레이드할 수 있도록 하는 것입니다.\n\n패키지를 추가하는 것은 다음과 같이 간단합니다:\n\n\n\n\n```js\n> npm i package-name\n```\n\n그게 전부에요. \n이제 패키지가 프로젝트에 추가되었고(패키지.json 파일에 표시됨) 사용할 준비가 되었습니다. 직접 CDN을 찾을 필요가 없을 뿐만 아니라 .dll 파일을 설정할 필요도 없어요.\n\n<img src=\"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_5.png\" />\n\n일부 패키지는 서버 측 또는 웹 앱에만 특정되어 있고, 다른 것은 양쪽에서 작동합니다. 그리고 다양한 패키지 관리자가 있습니다:\n\n\n\n\n- Npm\n- Yarn\n\n누구나 자신의 패키지를 게시할 수 있기 때문에 NPM은 오픈 소스 도구들의 가장 큰 레지스트리 중 하나로 성장했습니다.\n\n## Express.js\n\nNode.js에 내장된 표준 HTTP 서버 모듈은 개발자들의 기대를 충족시키지 못했습니다. 곧 Express가 나와 문제를 해결했습니다. Express는 Node.js를 인기있게 만든 간소한 API 프레임워크입니다. Express의 아름다움은 몇 줄만으로도 처음부터 HTTP 서버를 시작할 수 있다는 점입니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_6.png\" />\n\nExpress의 또 다른 특징은 매우 확장 가능하다는 것입니다. Express 핵심 팀에 의해 개발되지 않은 것은 전 세계의 오픈 소스 개발자들의 커뮤니티에 의해 개발되었습니다.\n\n## 풀 스택 JavaScript\n\nNode.js는 JavaScript 서버 기술이기 때문에, 이미 JavaScript에 익숙한 프런트엔드 개발자들은 새로운 프로그래밍 언어나 스택을 배우지 않아도 백엔드 개발자로 전환할 수 있습니다.\n\n\n\n동네에 또 다른 신입생이 나타났어요. Express와 동일한 해에 MongoDB도 선보였죠, JSON 구조를 사용하여 데이터를 저장하는 문서 기반 데이터베이스입니다. MongoDB 팀은 자신들의 데이터베이스를 홍보할 만한 파트너가 필요했고, 그 파트너를 Node.js & Express에서 찾았어요.\n\n- Angular.js와 같은 JavaScript 웹 프레임워크\n- Express.js와 같은 백엔드 서버사이드 JavaScript 프레임워크\n- JavaScript를 닮은 데이터베이스 MongoDB\n- JavaScript로 만들어진 런타임 환경 Node.js\n\nJavaScript 스택이 탄생했습니다.\n\n![에볼루션](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_7.png)\n\n\n\n# ECMAScript 6\n\nES6(가끔 ES2015로도 불림)은 언어에 전환점을 일으킨 주요 JavaScript 버전이었습니다.\n\n- Let & Const\n- Classes\n- Promises\n- ES 모듈\n- Map 및 Set 데이터 구조\n- 화살표 함수\n- 전개 연산자\n- 해체 할당\n\nClasses는 다른 언어에서 온 개발자들이 JavaScript로 쉽게 적응할 수 있도록 도와주었는데, 대부분의 경우 Classes는 JavaScript Prototype 상속을 위한 문법적 설탕일 뿐입니다.\n\n\n\n프로미스는 비동기 데이터를 조작하는 새로운 방법으로, 콜백보다 간단하게 사용하고 더 빠릅니다. ES6에서는 생성기 함수도 함께 도입되었습니다.\n\n![이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_8.png)\n\n화살표 함수를 사용하면 콜백 구문이 더 깔끔하고 간단해지며, 전개 연산자와 구조 분해를 사용하면 복잡한 구조에서 데이터를 쉽게 추출할 수 있습니다.\n\n모듈의 강력함이 브라우저에도 도입되었습니다. Node.js에서 사용되는 CommonJS 모듈과 달리 ES 모듈은 패키지를 비동기적으로 가져왔습니다. 이를 통해 JavaScript 스크립트 파일을 더 작은 파일로 분할하고 연결할 수 있었습니다.\n\n\n\n언어 변경으로 서버 측 JavaScript(Node.js)도 적응해야 했습니다. ES6 기능을 사용하고 프라미스를 통해 비동기 작업을 처리할 수 있도록 만든 것부터 ES 모듈 지원을 제공하는 것까지 바뀌었습니다(Node.js v13에서 나온 것). \n\n![Evolution of Server-Side JavaScript](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_9.png)\n\n## 번들러\n\n이러한 새로운 언어 기능과 최신 라이브러리 중 주요 단점 중 하나는 브라우저 지원에 있습니다. Google Chrome에서 작동하는 것이 다른 웹 브라우저에서는 동일하게 작동하지 않을 수도 있습니다. 결국 모든 브라우저는 서로 다른 JavaScript 엔진 위에 구축되어 있기 때문입니다.\n\n\n\n이를 해결하기 위해, 프레임워크는 ES6, React 또는 TypeScript로 작성된 코드를 일반 JavaScript로 번들하는 데 사용되는 Babel 및 Webpack과 같은 Transpiler에 의존했습니다.\n이러한 도구는 또한 ES 모듈 가져오기(예: 라이브러리 가져오기)를 제거하고, ES6(그리고 향후 ES 버전) 코드를 ES5 등가물로 변환하고, 빈 공간을 제거하며, 이미지를 압축하고, 프로세스를 자동화하는 등 다양한 최적화를 제공했습니다.\n\n한 번 변환 및 번들링되면, 코드는 브라우저 및 Node.js에서 완전히 실행 가능했습니다. 몇 년 동안 기술이 발전했고 모든 최신 브라우저가 ES6를 지원하지만, 새로운 ECMAScript 버전이 출시될 때마다 이러한 기술들은 여전히 사용되고 있습니다.\n\n내 컨텐츠를 좋아하시고 더 많이 보고 싶다면 저에게 따뜻한 한잔의 커피를 사주세요 ☕\n\n![이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_10.png)\n\n\n\n![2024-05-14-EvolutionofServer-SideJavaScript_11](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_11.png)\n\n# TypeScript\n\nES6와 함께 최근 몇 년 동안 JavaScript 언어에 가져온 가장 큰 혁신 중 하나는 TypeScript입니다.\n\nTypeScript는 JavaScript를 기반으로 확장하여 언어에 엄격한 유형을 추가함으로써 개발되는 오픈 소스 언어입니다. TypeScript는 string, number, boolean 및 array와 같은 유형 변수를 사용하도록 개발자를 제한하며 Dictionary, Generics, Enums, Interfaces, Classes 및 Tuples와 같은 추가 기능을 도입하며 엄격한 널 체크를 통해 각 기능에 더 많은 컨텍스트를 제공합니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_12.png\" />\n\n하지만 TypeScript는 JavaScript에 엄격한 타입을 도입하려는 첫 번째 시도가 아니었습니다.\n\n2000년대 초반에는 JavaScript를 타입과 함께 개선하려는 아이디어가 있었습니다. 이것은 JavaScript ECMAScript 4라는 코드명을 가졌습니다. 그러나 변경 사항이 너무 커서 당시 브라우저와 호환되지 않았습니다.\n\n그 실험이 실패했다고 말할 수 있습니다. 그래서 ES 3.1 이후에 우리는 즉시 ES5로 넘어가고, ES4는 TypeScript로 재구성되었습니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_13.png\" />\n\n# 성장하는 생태계\n\nNode.js가 인기를 얻을수록 생태계도 함께 커져갔어요. 갑자기 자바스크립트가 모든 곳에 나타났죠. 핸드폰에서, 데스크톱 앱에서, 블로그에서, 개발자 모임에서도 말이에요.\n\n- Cross-platform tools (Electron, React Native, Ionic)\n- Visualization tools (D3, Chart, Three.js)\n- Video games (Phaser)\n- 다양한 웹 프레임워크 (React, Angular, Vue)\n- 상태 관리 도구 (Redux, Ngrx, Mobx)\n- 시간 및 날짜 조작 (Moment, DateFns, Day.js)\n- 유틸리티 라이브러리 (Lodash, Rx.js, Async.js)\n- 기계 학습 (TensorFlow.js)\n- 운영 체제 (NodeOS)\n\n\n\nNPM에는 100K개 이상의 모듈이 있습니다.\n\n그게 충분하지 않다면, Serverless 컴퓨팅의 팬들은 개발자들을 위한 프레임워크를 개발하여 코드로 인프라를 설정하고 AWS, Azure 및 GCP와 같은 클라우드 플랫폼에 분산시켰습니다. 그 결과 Serverless Framework가 탄생되었습니다.\n\n프로그레시브 웹 앱도 등장했고, Node.js도 발전했습니다. HTTP 2 지원, Async Hooks, Worker Threads 및 Watch 모드 등 다양한 기능이 추가되었습니다.\n한편, Angular의 팬들은 Nest.js를 개발했습니다. 이는 Express.js가 사용하는 함수형 접근 방식보다 C# 및 Java와 같은 언어에 사용되는 객체지향 패러다임을 선호하는 신선한 백엔드 프레임워크입니다.\n\n\n\n자바스크립트는 모든 면에서 선전하고 있는 것으로 보여서 얼마든지 사라지지 않을 것 같아요. 하지만 Node.js는 따라가는 데 어려움을 겪고 있었어요.\n\n## Node.js Chakra\n\nNode.js의 다른 버전이 있었죠. Node.js Chakra는 Microsoft가 자사의 JavaScript Chakra 엔진을 사용하여 Node.js를 재창조하려는 시도였어요. 이는 Windows 플랫폼을 특히 대상으로 한 고성능을 자랑했죠.\n\n하지만 운명은 그렇지 않았어요. Node.js Chakra의 인기는 매우 낮았기 때문에 Microsoft는 이 프로젝트를 포기하고 V8을 사용하기 시작했어요.\n\n\n\n<img src=\"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_15.png\" />\n\n# Node.js의 문제점\n\n시간이 지남에 따라 Node.js의 결함이 더욱 뚜렷해졌습니다.\n\n## ES 모듈\n\n\n\n프론트엔드 JavaScript가 ECMAScript 모듈을 채택하기 시작하면서 Node.js도 이 트렌드를 따라야 한다는 것이 분명해졌어요. 그러나 기존 NPM 모듈은 여전히 CommonJS 모듈에 의존하고 있었죠. 이는 라이브러리 개발자들도 ES 모듈만 지원하거나 둘 다 지원하도록 라이브러리를 변경해야 한다는 것을 의미했어요. Node.js는 둘 다 기본으로 지원하죠.\n\n## TypeScript\n\nTypeScript는 Node.js를 여러 가지 면에서 개선했어요. 단점은 TypeScript를 사용하려면 ts-node 패키지를 설치해야 하며, 사용한 NPM 패키지의 TypeScript 변형도 함께 설치해야 한다는 것이에요. Express를 설치할 때 @types/express도 함께 설치해야 한다는 거죠. 일부 패키지는 TypeScript 변형이 없어 TS와 전혀 호환되지 않을 수도 있어요. 반면에 새로운 패키지들은 TS 지원이 내장되어 있어 똑같은 패키지를 두 번 설치할 필요가 없는 것이 장점이에요.\n\n## 다양한 NPM 보안 문제\n\n\n\nNPM은 보안 문제로 유명합니다. 누구나 패키지를 만들고 NPM에 발행할 수 있기 때문에 악성 코드를 만들어 온라인으로 공유하는 것을 막을 방법이 없습니다. 또한 해로울 수 있는 패키지나 사용이 중단된 패키지를 설치할 때 경고도 없습니다.\n\n![이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_16.png)\n\n이러한 문제들은 Node.js 개발자들을 처음부터 괴롭혔습니다. NPM 팀은 이를 해결하기 위해 끊임없이 노력하고 있습니다.\n\n## 표준화 부족\n\n\n\nNode.js 프로젝트를 설정하는 방법이나 사용할 라이브러리 도구, 따를 특별한 코드 규칙이 없습니다. 다른 패키지들마다 다른 구현을 가지고 있죠 (함수형, 이벤트 기반, 또는 객체 지향).\n\n필요한 것은 모두 NPM에 있어서 여러분의 프로젝트에 맞게 적합한지 확인해볼 수 있어서 끝도 없이 탐구하고 테스트할 수 있습니다. 다행히도 온라인에서 좋은 콘텐츠 제작자, 튜토리얼, 블로그 기사들이 있어서 적절한 도구를 찾는 데 도움을 줄 수 있습니다.\n\n이런 문제들을 살펴보면 다른 언어의 백엔드 개발자들이 Node.js를 피하는 이유가 분명해집니다. 대부분의 문제들이 해결되었지만, 한 표준에서 다른 표준으로의 전환은 많은 Node.js 개발자들에게 영향을 주었습니다. 심지어 Ryan Dahl이라는 창조자조차도 몇 년 전에 새로운 JavaScript 런타임을 만들기로 결정했죠. 이것이 Deno입니다.\n\n![에볼루션 오브 서버 측 자바스크립트](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_17.png)\n\n\n\n# 데노\n\n데노는 서버 측 자바스크립트에 대한 새로운 접근 방식입니다. 시선을 모은 신입생입니다. Libuv 대신 V8 및 Tokio (Rust 라이브러리)로 작성되어 더 빠르고 가벼운 런타임으로 홍보되었습니다.\n\nNode.js의 창시자에 의해 개발된 점이 엄청난 마케팅 포인트였습니다. 라이언은 노드.js의 문제점을 정확히 알고 있었으며 데노로 어떻게 개선할지 알고 있었습니다. 두 번째로, 노드.js의 창조자가 더 이상 사용하지 않고 일부 개발자를 데노의 세계로 끌어들였습니다.\n\n데노는 많은 새로운 기능을 가져왔습니다:\n\n\n\n- 그림 파일을 Markdown 형식으로 변환하면 됩니다.\n\n\n\n거기에 더불어, Node.js 팬들은 Deno의 일부 기능이 Node.js로 가져와지길 원하며, 특히 TypeScript가 기본으로 제공되길 열망합니다. 그러나 아직 그러한 변화는 일어나지 않았습니다.\n\n그러나 이 모든 기능들 중에서도 한 가지 주요 문제가 있었습니다 — Third-party 모듈들! Deno에서 NPM을 제거하는 것은, 이미 Node.js에서 NPM으로 갖고 있던 대부분의 기능들을 다시 개발해야 한다는 것을 의미했습니다.\n\n확실히 Deno 팀은 일부 NPM 패키지를 활성화하는 방법을 개발했지만, 내용의 부족으로 인해 Deno가 Node.js를 대체하지 못했습니다. 대신, Node.js는 Deno에서 가져온 몇 가지 새로운 기능을 채택했습니다. 오늘날에도 Node.js는 JS 생태계에서 가장 널리 사용되는 서버 측 플랫폼으로 자리잡고 있습니다.\n\n![이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_19.png)\n\n\n\n# 메타 프레임워크\n\n최근 몇 년 동안 우리는 JavaScript 메타 프레임워크의 부상을 지켜보았습니다 - 이 도구들은 완전한 스택 앱을 구축할 수 있는 도구입니다. 백엔드 부분은 데이터베이스와 통신하고 엔드포인트를 노출시키며 다양한 방법으로 콘텐츠를 렌더링하는 역할을 하고 있습니다:\n\n- 정적 사이트 생성\n- 서버 측 렌더링\n- 증분적 정적 재생성\n\n한편, 프론트엔드 부분은 싱글 페이지 애플리케이션입니다. 이를 수행할 수 있는 몇 가지 도구가 있으며, Vercel의 Next.js가 그 중 선두를 달리고 있습니다.\n\n\n\n![Evolution of Server-Side JavaScript](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_20.png)\n\n샤벨트(Svelte) 및 퀵(Qwik)와 같은 새로운 프레임워크들이 자체적인 기능들을 가져왔습니다. 기존의 수분화(hydration)를 포기하고 Resumability라는 새 개념을 선호했습니다.\n\n이어서 Vite가 등장했습니다. 이는 속도와 성능에 중점을 둔 새로운 프론트엔드 빌더 도구로, Webpack의 직접적인 경쟁 상대입니다.\nVite는 백엔드에서도 발전하고 있습니다. Nest.js 팀은 SWC를 발견했습니다. 이는 Rust 기반의 플랫폼으로, 빠른 컴파일 및 번들링에 사용할 수 있으며 Vite와 호환됩니다.\n\n노드.js를 구동하는 V8 엔진은 더 이상 서버 측 개발의 궁극적인 해결책으로 여겨지지 않습니다. Rust가 점유율을 높이면서, 갑자기 죽을 것 같은 새로운 도구가 등장했습니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_21.png\" />\n\n# 번\n\n인터넷에 자바스크립트 런타임 간의 다양한 성능 비교 기사들이 올라온 것은 2022년 말쯤이었습니다. 그 중 하나가 새로운 초고속 기술인 번입니다.\n\nZig로 작성되었고 V8 엔진을 완전히 피하는 번은 Deno 및 Node.js를 합친 것보다 현저히 빠르다는 것이 증명되었지만, 이점은 여기서 끝나지 않습니다:\n\n\n\n- 즉시 사용 가능한 TypeScript 지원\n- Node.js 코어 모듈 지원\n- NPM 지원\n- 내장 번들러\n- ECMAScript 및 CommonJS 모듈 지원\n- 기존 프레임워크 지원 (예: Next, Express 또는 Nest)\n\nBun 발명자 Jarred Sumner가 괴물을 만들었습니다.\n\nBun은 JavaScript 커뮤니티에서 확실하게 폭발적인 반응을 얻었습니다.\n\n현재 모든 게 완벽하다는 뜻은 아닙니다. Bun은 NPM을 통해 문을 열었지만, 제대로 기능하지 않는 패키지 목록이 꽤 있습니다. 그리고 Bun은 막 나온 것이기 때문에 경험이 부족하고 이전에 나온 런타임과 비교했을 때 온라인 참조가 부족합니다.\n\n\n\n저에게 있어서 Bun의 매력은 빠르거나 새롭고 혹평받는 것이 아니라, 오히려 Bun이 표준을 만들고자 한다는 점입니다. 개발자들을 소외시키거나 모듈을 가져오는 방법이나 패키지의 출처를 지시하는 대신, Bun은 맞는 방법을 찾으라고 장려합니다. 이는 JavaScript 개발자들과 생태계를 통합하는 중요한 한걸음이라고 생각해요.\n\n![이미지](/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_22.png)\n\nBun은 계속 발전할 것입니다. 버그는 수정되고 새로운 기능이 정기적으로 추가됩니다. 앞으로 몇 년 안에 Bun이 어떻게 발전할지 기대됩니다.\n\n# 백엔드 JavaScript의 미래\n\n\n\n다년간 JavaScript는 여러 변형을 거쳤어요. 어떤 확장 기능은 실패했고, 어떤 것은 성공하여 오늘날의 생태계가 되기까지 고난을 겪었죠.\n\n서버 측 JavaScript는 몇 년 전보다 오늘날 더 나은 상태에 있는 걸까요? 음, 그것은 상황에 따라 다르죠.\n\nNode.js 이전의 상태와 비교하면 JavaScript는 많은 발전을 이루었어요. 1995년 JavaScript가 시작된 때와는 더욱 예측할 수 없는 방향으로 발전해 왔거든요. 오랜 기간 개발자였다면 변화를 환영하며 빨리 적응할 수 있을 겁니다. 하지만 JavaScript 초심자라면 모든 것이 다른 런타임, 언어, 번들러, 모듈 등이 얽혀있어 엉망스럽게 들릴 수도 있어요.\n\n내가 생각하기에 장래에 Node.js가 여전히 최고의 서버 측 JavaScript 런타임 역할을 하게 될 것 같아요. 경쟁 상대들의 긍정적인 점들에도 불구하고, 다른 도구들은 Node.js만큼의 안정성, 많은 API와 온라인 참고 자료, 인기가 없을 뿐만 아니라 오랫동안 실전을 경험했다는 점에서 뒤쳐지죠.\n\n\n\n나의 극심한 희망은 언젠가 세 가지 중 가장 좋은 것을 모두 하나의 지붕 아래에 갖게 될 것이라는 것입니다 —빠르고 안전한 런타임, JS, TS 및 번들링을 위한 기본 지원이 충분히 갖춰진 것, 그리고 내장 및 제3자 도구가 풍부한 것, 그리고 전 세계 개발자들이 사용하는 것과도 함께요.\n지금까지 Bun은 그것을 달성하기 위한 좋은 길일 것입니다.\n\n분명한 한 가지는, 확실한 것은, 흥미진진한 JavaScript 세계에서 다음에 무엇이 일어날지 확실히 말하기 쉽지 않다는 것입니다.\n\n# 더 많은 JavaScript 이야기 읽기\n\n이제 잠시 안녕👋","ogImage":{"url":"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-EvolutionofServer-SideJavaScript_0.png","tag":["Tech"],"readingTime":13},{"title":"자바스크립트 - Strict Mode는 어떻게 작동하나요","description":"","date":"2024-05-14 14:46","slug":"2024-05-14-JavaScriptStrictModeHowDoesItWork","content":"\n\n![이미지](/assets/img/2024-05-14-JavaScriptStrictModeHowDoesItWork_0.png)\n\n과연 엄격한 선생님이나 멘토를 만나본 적이 있나요? 그러나 결국 더 나은 학생이나 전문가가 되도록 도와준 적이 있습니까?\n자바스크립트 세계에서 \"use strict\"는 비슷한 역할을 합니다. 이는 최고의 실천법을 강요하고 더 깔끔하고 견고한 코드를 작성하는 데 도움을 줍니다.\n\n## 엄격 모드의 기원\n\n1990년대 초에 처음으로 등장한 이후로 자바스크립트는 많은 발전을 이루었습니다. 언어가 발전함에 따라 그 동안 유용했던 특정 기능 및 동작이 혼동을 일으키고 잠재적 버그의 원인이 되기도 했습니다. 이러한 문제를 해결하기 위해 ECMAScript 5 (ES5) 명세에서는 엄격 모드(strict mode)를 소개했습니다. 이로써 자바스크립트의 제한된 변형에 참여할 수 있는 방법을 제공했습니다.\n\n\n\nStrict 모드는 언어의 완전히 별개의 버전이 아닙니다. 오히려 언어의 일부 규칙을 자발적으로 준수하여 더욱 문제가 되는 기능과 동작을 제거하는 방법입니다. Strict 모드를 선택함으로써 JavaScript에게 \"약간 더 엄격해지길 바래. 날 마구 코딩 실수로 그냥 넘어가게 하지 말아줘\"라고 말하는 것과 같습니다.\n\n## Strict 모드 활성화\n\nStrict 모드를 활성화하는 것은 단순합니다. JavaScript 파일이나 함수의 시작 부분에 다음 줄을 추가하는 것으로 가능합니다:\n\n```js\n\"use strict\";\n```\n\n\n\n파일 상단에 이 줄을 포함하면 전체 스크립트에 strict 모드가 적용됩니다. 또는 함수 몸체의 시작 부분에 \"use strict\" 문을 포함하여 특정 함수에 대해 strict 모드를 활성화할 수도 있습니다.\n\n```js\nfunction strictFunction() {\n  \"use strict\";\n  // Strict 모드 코드를 여기에 입력합니다.\n}\n```\n\nES6 모듈 및 클래스에서는 strict 모드가 자동으로 활성화되며 비활성화할 수 없다는 점을 유의해야 합니다.\n\n## Strict 모드의 장점\n\n\n\n이제 엄격 모드를 활성화하는 방법을 알았으니, 이 모드가 제공하는 일부 이점을 살펴보겠습니다:\n\n- 일반적인 코딩 실수 잡기\n엄격 모드는 문제가 될 수 있는 또는 에러를 일으킬 수 있는 특정 코딩 패턴에 대해 예외를 던집니다. 예를 들어, 비엄격 모드에서는 변수 이름을 잘못 입력하거나 선언을 잊어서 전역 변수를 실수로 만들 수 있습니다. 엄격 모드는 이를 방지하기 위해 에러를 던져서 변수를 정확하게 선언하도록 강요합니다.\n\n```js\n\"use strict\";\nx = 3.14; // 이것은 엄격 모드에서 에러를 발생시킵니다\n```\n\n안전하지 않은 동작 방지\n엄격 모드는 예상치 못한 동작이나 보안 취약점으로 이어질 수 있는 일부 동작을 금지합니다. 예를 들어, 변수나 객체 속성을 삭제함으로써 실수로 전역 변수를 만드는 것을 방지합니다.\n\n\n\n```js\n\"use strict\";\ndelete Object.prototype; // 이것은 엄격한 모드에서 오류를 발생시킵니다.\n```\n\n혼란스러운 기능 제거하기\nJavaScript의 일부 기능들은 언어의 최상의 가이드가 완전히 확립되기 전에 도입되었습니다. 엄격 모드(strict mode)는 이러한 혼란스러운 기능들을 없애거나 수정하여 더 나은 코딩 관행을 촉진합니다. 예를 들어, 비 엄격 모드에서는 with 문을 사용할 수 있지만, 이는 예상치 못한 동작 및 성능 문제로 이어질 수 있습니다. 엄격 모드는 with 문의 사용을 금지합니다.\n\n```js\n\"use strict\";\nwith (Math) { // 이것은 엄격한 모드에서 오류를 발생시킵니다.\n  console.log(PI);\n}\n```\n\n더 나은 매개변수 처리 강화하기\n비 엄격 모드에서는 함수 내에 중복된 매개변수 이름을 가질 수 있으나, 이는 혼란과 버그를 초래할 수 있습니다. 엄격 모드는 중복된 매개변수 이름을 갖는 함수를 선언하려고 시도하면 오류를 발생시킵니다.\n\n\n\n```js\n\"use strict\";\nfunction duplicateParams(a, a) { // 이것은 엄격한 모드에서 오류를 발생시킵니다\n  // ...\n}\n```\n\n실수로 전역 변수를 만드는 것을 방지하기\nJavaScript에서 버그가 가장 일반적으로 발생하는 소스 중 하나는 실수로 전역 변수를 만드는 것입니다. 엄격한 모드는 미선언 변수에 값을 할당하려고 할 때 오류를 던져 이를 방지합니다.\n\n```js\n\"use strict\";\nmyGlobal = 42; // 이것은 엄격한 모드에서 오류를 발생시킵니다\n```\n\n변수 사용을 단순화하기\n엄격한 모드가 아닌 경우, arguments 객체는 약간 특이한 동작을 합니다. 함수의 명명된 매개변수로 별칭을 지정하고 그 값을 덮어쓸 수 있습니다. 엄격한 모드는 이러한 혼동스러운 동작을 제거하여 arguments 객체를 다루기 쉽게 만듭니다.\n\n\n\n```js\n// 비 엄격 모드\nfunction nonStrict() {\n  var obj = {\n    prop: 1\n  };\n  \n  // 존재하지 않는 속성에 값 할당하기\n  obj.prop2 = 2;\n  \n  // 선언되지 않은 변수에 접근하기 (오류가 발생하지 않음)\n  x = 10;\n  \n  return obj;\n}\n\n// 엄격 모드\nfunction strict() {\n  \"use strict\";\n  var obj = {\n    prop: 1\n  };\n  \n  // 존재하지 않는 속성에 값 할당 시도 (오류 발생)\n  obj.prop2 = 2; // 엄격 모드에서 오류 발생\n  \n  // 선언되지 않은 변수에 접근 (오류 발생)\n  // x = 10; // 이 줄을 주석 해제하면 엄격 모드에서 오류가 발생합니다.\n  \n  return obj;\n}\n\nconsole.log(nonStrict());\nconsole.log(strict());\n```\n\n## 결론\n\n엄격 모드는 처음에는 엄격한 선생님처럼 보일 수 있지만, 결국 더 나은 JavaScript 개발자가 되도록 돕는 역할을 합니다. 엄격 모드를 사용하면 일반적인 실수를 미리 잡을 수 있습니다.\n\n물론, 엄격 모드가 모든 문제를 해결해주는 마법의 해결책은 아닙니다.\n\n\n\n# 친절한 어조로 번역한 내용 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠로 고생하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 더 많은 콘텐츠: PlainEnglish.io","ogImage":{"url":"/assets/img/2024-05-14-JavaScriptStrictModeHowDoesItWork_0.png"},"coverImage":"/assets/img/2024-05-14-JavaScriptStrictModeHowDoesItWork_0.png","tag":["Tech"],"readingTime":4},{"title":"Angular 17 데이터 공유하기 BehaviorSubject를 활용한 간단한 가이드","description":"","date":"2024-05-14 14:45","slug":"2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide","content":"\n\n<img src=\"/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_0.png\" />\n\n앵귤러 애플리케이션에서 컴포넌트 간 데이터 흐름을 관리하는 것은 복잡해질 수 있습니다. 이때 비동기 프로그래밍을 위한 강력한 라이브러리인 RxJS가 유용합니다. RxJS는 데이터 스트림을 처리하는 다양한 연산자와 Subject를 제공하며, 그 중에서 BehaviorSubject는 중요한 역할을 합니다. BehaviorSubject는 상태를 관리하고 Angular 애플리케이션 내에서 변경 사항을 전파하는 데 기본적인 구조로 나타납니다. 이 블로그 포스트에서는 BehaviorSubject를 사용하여 컴포넌트 간 데이터를 공유하는 방법에 대해 알아보겠습니다.\n\n# BehaviorSubject란 무엇인가요?\n\n기본적으로 BehaviorSubject는 RxJS 라이브러리에서 제공하는 Observable의 한 유형입니다. 특정 이벤트가 발생할 때만 값을 방출하는 전통적인 Observable과 달리, BehaviorSubject는 최신 값을 유지하고 새로운 구독자에게 즉시 전달합니다.\n\n\n\n# 주요 기능:\n\n## 초기값으로의 초기화:\n\nBehaviorSubject를 생성할 때, 개발자는 초기값을 지정합니다. 이 초기값은 이후 발생하는 값들의 시작점으로 작용하며, 새로운 구독자가 구독 시 즉시 업데이트를 받을 수 있도록 보장해줍니다.\n\n## 상태 유지:\n\n\n\nBehaviorSubject의 독특한 특징 중 하나는 최신 값을 유지 및 구독자에게 전달할 수 있는 능력입니다. 이 행동은 추가 이벤트를 트리거할 필요 없이 컴포넌트가 가장 최신 데이터와 동기화되도록 합니다.\n\n## next() 메서드:\n\nnext() 메서드를 통해 개발자는 BehaviorSubject가 보유한 값을 동적으로 업데이트할 수 있습니다. 이 메커니즘은 응용 프로그램 전체에 이어지는 데이터 전파를 원활하게 처리하여 반응성 및 반응적인 동작을 가능하게 합니다.\n\n# 실제 구현:\n\n\n\n## 1. 빈 Angular 프로젝트를 생성하세요\n\n```js\nng new behaviorsubject-demo\n```\n\n## 2. 서비스 및 컴포넌트 생성\n\n이 프로젝트에서는 아래와 같은 UI를 만들 예정입니다. 이를 위해 인용구 데이터를 가진 Quote 서비스를 생성하고, 인용구를 업데이트하는 컴포넌트와 인용구를 표시하는 컴포넌트를 만들 예정입니다.\n\n\n\n아래 명령어를 실행하여 서비스와 컴포넌트를 생성하세요.\n\n```js\nng generate service services/quote\nng generate component components/display-quote\nng generate component components/update-quote\n```\n\n폴더 구조는 아래와 같이 보일 것입니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_2.png\" />\n\n## 3. 서비스에 아래 코드를 추가하세요\n\n```js\n// quote.service.ts\n\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class QuoteService {\n\n  constructor() {}\n\n  // 명언 속성을 선언하고 초기화합니다. BehaviorSubject이 될 예정\n  qoute = new BehaviorSubject(\"Hello world\");\n\n  // BehaviorSubject를 Observable로 노출합니다\n  currentQuote = this.qoute.asObservable();\n\n  // BehaviorSubject 값을 업데이트하는 함수\n  updateQuote(newQuote: string){\n    this.qoute.next(newQuote);\n  }\n}\n```\n\n## 4. 명언 서비스에서 명언 값을 표시하기\n\n\n\n```typescript\n// display-quote.component.ts\n\n...\n\nimport { QuoteService } from '../../services/quote.service';\n\n...\nexport class DisplayQuoteComponent {\n\n  constructor(private quoteService: QuoteService){}\n  \n  currentQuote: string = '';\n\n  ngOnInit(): void {\n    // 현재 시간 값을 가져오기 위해 quote 서비스의 currentQuote 속성을 구독합니다\n    this.quoteService.currentQuote.subscribe(\n      // 컴포넌트의 속성을 업데이트합니다\n      quote => this.currentQuote = quote\n    );\n  }\n}\n\n// display-quote.component.html\n\n<h2>{currentQuote}</h2>\r\n```\n\n이제 display-quote 컴포넌트에서 quote 서비스의 초기 인용구를 볼 수 있게 될 것입니다\n\n## 5. 인용구 값 업데이트\n\n```typescript\n// update-quote.component.ts\n\nimport { Component } from '@angular/core';\nimport { QuoteService } from '../../services/quote.service';\n\n...\nexport class UpdateQuoteComponent {\n\n  constructor(private quoteService: QuoteService){}\n\n  quote = '';\n\n  // 서비스에서 인용구를 업데이트하는 함수\n  submitHandler(){    \n   this.quoteService.updateQuote(this.quote);\n    this.quote=\"\";\n  }\n}\n\n// update-quote.component.html\n\n<div>\n  <input type=\"text\" [(ngModel)]=\"quote\" placeholder=\"새로운 인용구를 작성하세요\" />\n  <button (click)=\"submitHandler()\">제출</button>\n</div>\r\n```\n\n\n\n이제 update-quote 컴포넌트에서 인용구 값을 업데이트할 수 있게 되었고, 이는 display-quote 컴포넌트에 직접적으로 반영될 것입니다. 아래 다이어그램에서 프로젝트 내 데이터의 흐름을 확인할 수 있습니다.\n\n![Diagram](/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_3.png)\n\n# 결론:\n\n- 이 예제에서 인용구 서비스는 BehaviorSubject를 사용하여 인용구를 저장합니다. display-quote 컴포넌트는 currentQuote observable을 구독하여 최신 인용구를 가져와 로컬 변수를 업데이트합니다.\n- Angular 개발에서 BehaviorSubject는 상태를 관리하고 컴포넌트 및 서비스 간 반응형 동작을 용이하게 하는 강력한 도구로 사용됩니다. 개발자들은 이를 활용하여 동적 데이터 흐름을 쉽게 다룰 수 있는 견고하고 반응적인 Angular 애플리케이션을 구축할 수 있습니다.\n\n\n\n아래 GitHub 저장소에서 최종 코드를 얻어보세요.","ogImage":{"url":"/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_0.png"},"coverImage":"/assets/img/2024-05-14-Angular17DataSharingwithBehaviorSubjectsASimpleGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"더 나은 코드를 작성하기 위한 5가지 빠른 팁과 기술","description":"","date":"2024-05-14 14:43","slug":"2024-05-14-5QuickTipsAndTechniquesToWriteBetterCode","content":"\n\n오늘 깨끗한 코드를 작성하는 데 도움이 되는 몇 가지 간단한 팁과 기술이 있습니다.\n\n![이미지](/assets/img/2024-05-14-5QuickTipsAndTechniquesToWriteBetterCode_0.png)\n\n만약 이 기사를 읽고 있다면, 코드를 작성하는 사람이실 겁니다. 아마도 상당량의 코드를 작성하고 계신 것 같군요... 아마도 그 코드 작성이 즐거운 활동이며 중요한 일일 것입니다. 코딩을 좋아하거나 싫어할지 모르지만, 개발자로서 실제로 코드를 작성하는 시간보다 10배 정도 더 많은 시간을 코드를 읽는 데 사용하고 있는 것이 사실입니다.\n\n다른 사람의 코드를 읽는 것, 아쉽게도 때로는 우리 자신의 코드를 읽는 것은 가끔 슬픈 경험일 수 있습니다. 이해하기 어려운, 지저분하고 맡의 코드들이죠. 우리는 모두 본 적이 있습니다. 우리 모두가 작성해 봤습니다...\n\n\n\n조금만 신경을 쓰지 않으면 우리의 코드베이스는 금방 엉망이 될 수 있어요. 엉망이 된 코드를 소유하는 비용이 높아요! 회사에게도 높은 비용이 들고요. 정신적 안녕에도 높은 비용이 들어요. 부패한 코드는 우리 프로젝트를 저주받은 묘지로 만들어 버려요. 심지어 가장 경험 많은 엔지니어들조차 가기를 꺼리게 해요. 다행히도 간단한 몇 가지 기술을 사용해서 쉽게 코드를 개선할 수 있어요:\n\n- 조건부(if)문을 설명적인 메소드로 추상화\n- 주석을 선언적인 코드로 대체\n- 더 깨끗한 함수 작성\n- 다형성을 사용하여 switch 문 제거\n- 끝에서 시작하기 — 목적 코드를 생각하고 그 목적 지점에 도달하는 방법을 고민하기\n\n이러한 5가지 팁을 실제 코드 예제와 함께 설명할 거예요. 예제는 대부분의 사람들이 익숙한 JavaScript를 사용했지만, 다른 언어에도 쉽게 적용할 수 있어요. 모든 예제 코드는 제 깃허브에서 확인할 수 있어요.\n\n시작하기 전에, 깨끗한 코드와 깨끗한 코드를 작성하는 기술에 대해 간략히 얘기해 볼게요.\n\n\n\n## 깨끗한 코드\n\n여기서 궁극적인 목표는 깨끗한 코드를 만드는 것입니다. 많은 주니어 개발자들이 깨끗한 코드를 작성하는 것은 우리가 가지고 있는 기술이거나 시간이 지나면 개발되는 기술이라고 생각합니다. 사실상, 심지어 가장 경험이 많은 개발자조차 첫 번째 시도때 모든 날 깔끔하고 우아한 코드를 작성하지는 않습니다.\n\n좋은 품질의 코드를 작성하는 것은 반복 작업이며, 대부분의 기술은 리팩토링 기술입니다.\n\n## 빨강, 초록, 리팩터링\n\n\n\n더 좋은 코드를 작성하는 핵심은 신뢰할 만한 테스트를 갖고 있어서 코드를 리팩터링할 때 여전히 작동하는지 알 수 있다는 것입니다. 처음에는 종종 우리가 원하는대로 작동하는지 확인하기 위해 지저분한 절차적 코드와 몇 가지 테스트를 작성할 것입니다. 가장 중요한 단계는 다음 단계입니다 - 여기서 우리는 코드를 리팩터링하고 정리하여 더 이해하기 쉽고 유지보수하기 쉬운 상태로 만드는 것입니다.\n\n![image](/assets/img/2024-05-14-5QuickTipsAndTechniquesToWriteBetterCode_1.png)\n\n너무 많은 개발자들은 코드를 정리하는 마지막 단계를 건너뛰곤 합니다. 테스트가 없으면 우리는 전혀 코드를 정리하기 어렵다고 느낄 가능성이 높습니다. 구글은 이에 대한 훌륭한 철학을 가지고 있습니다:\n\n## 1. 조건부(if) 문을 설명적인 메서드로 추상화하세요\n\n\n\n첫 번째 리팩터링 기법은 아마 가장 쉽게 구현할 수 있는 기법입니다. 아래 코드는 Nightclub(클럽)에 입장을 허용할 수 있는지 확인합니다. 그들은 입장이 허용되거나 대기열로 보내지거나 거절될 것입니다.\n\n첫 번째 조건부 (if) 문은 꽤 복잡하며, 무슨 일이 벌어지고 있는지 파악하기 어려운데요. 우리는 이를 명확하게 명명된 함수로 추상화할 수 있으며, 독자들이 이해할 수 있게 되죠. 또한 몇 개의 '마법' 숫자(18과 500)가 여기저기 돌아다니고 있습니다. 이것들이 무엇을 위한 것인지 명확하지 않습니다.\n\n조건부 문을 잘 명명된 함수로 추상화하면 읽기가 훨씬 쉬워집니다. '마법' 숫자들에도 유용한 이름이 지정되어 독자가 이 숫자들이 어떤 용도로 사용되는지 이해할 수 있도록 도와줍니다.\n\n## 2. 주석을 선언적인 코드로 대체\n\n\n\n프로그래밍에서 주석은 가장 남용되는 언어 기능 중 하나입니다. 잘 쓰여진 풍부한 선언형 코드는 그 자체로 말을 할 수 있어서 전혀 주석이 필요하지 않습니다.\n\n우리는 코드로 이해하기 어려운 경계 케이스가 있는 드문 상황에서만 주석을 작성해야 합니다.\n\n다음 코드는 포럼의 질문과 관련된 상위 10개 평점이 높은 답변을 검색합니다.\n\n이전 코드는 쓸데없는 주석으로 가득 차 있습니다. 거의 모든 주석은 함수와 변수의 이름을 더 잘 붙이거나 설명하는 코드를 잘 명명된 함수로 추출함으로써 제거할 수 있습니다.\n\n\n\n정리된 버전의 코드는 더 작은 함수로 분해되었고, 각 함수의 이름이 명확히 무엇을 하는지 설명하도록 되어 있어요. top 변수가 만들어져서 딱 10개의 아이템만 선택될 것임을 명확하게 보여줍니다.\n\n## 3. 더 깔끔한 함수 작성하기\n\n함수 작성에 있어서, 일반적으로 함수가 작을수록 더 나아요. 작은 함수는 이해하기 쉽고 재사용하기 쉽고 컴퓨터가 최적화하기 쉬워요.\n\n함수는 한 가지 일만 해야 해요. 만약 getDataAndThenMapAndSendToCustomer 같은 이름을 사용해야 한다면, 함수를 분해해야 한다고 생각해보세요.\n\n\n\n\"더 깨끗한 함수를 설계하는 데 도움이 되는 몇 가지 규칙이 있어요:\n\n- 함수는 작아야 해요 (이상적으로 15줄 미만)\n- 함수의 이름은 설명적이고 의미 있는 이름을 가져야 해요\n- 함수는 데이터를 검색하거나 변경해야 해요. 둘 다 하면 안 돼요.\n- 함수는 하나의 추상화 수준에서 작동해야 해요\n- 가능한 경우 else 조건 사용을 피해야 해요\n\n다음 코드는 텍스트 라인의 단어 수를 세는데 사용됩니다. 계산에서 제외할 ignoreWords 집합을 전달할 수 있어요.\n\n이전 예제는 대부분의 규칙을 어기고 있어서 이해하기 어렵습니다. 깊게 중첩된 루프와 if/else 문이 있어서 인지 복잡성이 높아져요. 또한 많은 서로 다른 추상화 수준에서 작업하고 있습니다.\"\n\n\n\n2번째 예시는 복잡한 방법을 3단계로 분해합니다: 단어를 포함해야 하는지 확인, 한 줄에 있는 단어 수 세기 및 각 줄에서의 카운트를 집계하는 것입니다.\n\n## 4. 다형성을 사용하여 switch 문을 제거\n\nswitch 문은 종종 코드 냄새로 여겨집니다. 만약 무언가를 위해 switch 문을 사용해야 한다면, 코드에 한 번만 나타나야 합니다.\n\n비슷한 switch 문이 코드 여기저기 흩어져 있다면, 그것은 코드를 더 나은 방식으로 추상화할 수 있는 좋은 신호일 수 있습니다. 종종 그것을 할 수 있는 가장 좋은 방법은 다형성을 사용하는 것입니다.\n\n\n\n다양한 채널을 사용하여 알림을 게시할 수있는 Notifier 클래스를 살펴보겠습니다. '이메일' 채널은 언제든지 알림을 전송할 수 있지만, 'SMS' 채널은 업무 시간 외에 알림을 '예약'해야 합니다.\n\n이전 코드에서는 유사한 스위치 문이 많은 곳에서 사용되고 있습니다. 비효율적일 뿐만 아니라 유지 관리도 어렵습니다. 새로운 채널이 필요하면 여러 스위치 문을 업데이트해야한다는 것을 기억해야합니다.\n\n코드를 정리하기 위해 채널을 다른 NotificationService 구현으로 분해할 수 있습니다: EmailService, SmsService\n\n이제 우리가 해야 할 일은 코드에서 어떤 유형의 NotificationService를 생성할 지 결정하는 것뿐입니다.\n\n\n\n우리는 스위치 문을 하나 제외한 모든 것을 제거했고, 결과 코드가 훨씬 간단해졌어요.\n\n이런 종류의 문제에 잘 맞는 또 다른 패턴은 '팩토리' 패턴입니다. NoticationService의 생성을 팩토리 클래스로 추출할 수 있어요.\n\n이제 우리의 Notifier 클래스를 더 간단하게 만들 수 있어요.\n\n## 5. 끝에서 시작하기\n\n\n\n이 마지막 기술은 리팩토링 기술이 아닌 목록 중 유일한 기술입니다. 이것은 경험이 풍부한 시니어 개발자가 코드를 작성하는 방식과 경험이 적은 주니어 개발자가 접근하는 방식 사이의 차이를 명확히 보여주는 기술입니다.\n\n설명하기 전에 몇 가지 예시를 살펴보겠습니다.\n\n주니어가 솔루션을 만들 때 종종 코드를 작성하기 전에 거의 계획이나 설계를 하지 않고 바로 코드를 작성하는 경우가 많습니다. 그들은 먼저 많은 양의 코드를 작성하고 나중에 어떻게 메서드나 테스트를 둘러싸야 할지를 결정합니다. 그 결과로 나오는 클래스, API 및 메서드 시그니처는 보통 설계가 잘못되어 사용하기 어렵고 변경하기 어렵습니다.\n\n반면에 경험이 풍부한 개발자는 먼저 고수준 API, 클래스 및 메서드 시그니처에 가장 적합한 설계에 대해 생각한 뒤, 코드로 어떻게 이를 달성할지 고려합니다. 문제는 Fluent, OOP, 함수형, 데이터 주도형 프로그래밍을 필요로 하는가요? 소비자는 어떻게 솔루션을 사용할 것인가요? 어떻게 테스트할 것인가요?\n\n\n\n만약 이 내용이 익숙하게 들린다면, 당신은 맞습니다. 이것이 바로 Test-Driven Development (TDD)의 본질입니다. TDD는 우리가 코드가 어떻게 사용될지 (테스트를 통해) 고민하게 만들기 때문에 훌륭합니다. 우리가 어떻게 구현할 것인지 알기 전에 코드가 어떻게 사용될지 고려합니다.\n\nTDD를 좋아하지 않는 사람도 있고, 그것도 괜찮습니다. 만약 이를 좋아하지 않는다면, 코드를 작성하기 전에 최종 모습을 상상해보는 방식으로 이 기술을 적용할 수 있습니다. 팀을 위해 공유 라이브러리 코드를 작성할 기회가 있다면, 소비자의 관점에서 최종 결과물을 고려하는 좋은 방법이 될 수 있습니다.\n\n깨끗한 코드를 작성하는 것은 과정입니다. 누구나 경험의 양에 관계없이 거쳐야 하는 과정입니다. 이러한 팁과 기술이 이 과정을 더 나은 방식으로 진행할 수 있도록 도와줄 것이라고 희망합니다.\n\n모든 코드 예제와 테스트는 아래의 제 GitHub 저장소에서 찾을 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-5QuickTipsAndTechniquesToWriteBetterCode_0.png"},"coverImage":"/assets/img/2024-05-14-5QuickTipsAndTechniquesToWriteBetterCode_0.png","tag":["Tech"],"readingTime":5},{"title":"Nodejs에서 CPU 집약적 작업 최적화하기 워커 스레드 가이드","description":"","date":"2024-05-14 14:40","slug":"2024-05-14-OptimizingCPU-IntensiveTasksinNodejsAGuidetoWorkerThreads","content":"\n\n<img src=\"/assets/img/2024-05-14-OptimizingCPU-IntensiveTasksinNodejsAGuidetoWorkerThreads_0.png\" />\n\n# 소개\n\nNode.js는 주로 단일 스레드 이벤트 루프 모델에서 작동합니다. 이는 즉, 코드가 한 번에 한 가지 작업만 수행할 수 있다는 뜻입니다. 그러나 Node.js는 또한 libuv와 같은 라이브러리를 통해 디스크에서 파일을 읽는 것과 같은 I/O 작업을 백그라운드 스레드에 지원하는 메커니즘도 제공합니다. 이러한 백그라운드 스레드는 파일 I/O, 네트워크 요청 및 DNS 조회와 같은 작업을 처리하여 주 스레드가 다른 이벤트를 계속 처리할 수 있도록 합니다.\n\n이제, 복잡한 수학 문제를 해결하거나 대형 이미지 또는 비디오 압축을 처리하는 등 매우 어려운 작업이 있다고 상상해보십시오. Node.js가 이러한 유형의 작업을 처리할 때, 완전히 점령되어 다른 작업을 완료할 때까지 아무 것도 할 수 없습니다. 이는 다른 작업이 대기 중인 경우, 그 일이 완료될 때까지 기다려야 한다는 것을 의미합니다.\n\n\n\n컴퓨터에 여러 개의 프로세서(코어)가 있더라도 Node.js는 이러한 어려운 작업을 자동으로 분산시키지 않습니다. 모든 것을 처리하기 위해 하나의 프로세서, 하나의 코어만 사용하며, 다른 것들도 사용 가능한 상황에서도 이를 계속 사용합니다. 따라서 현대 컴퓨터는 여러 코어로 더 많은 처리량을 갖고 있지만, Node.js는 이러한 어려운 작업에 대해 그것들을 완전히 활용하지 못합니다. 이는 응용 프로그램이 많은 작업을 처리해야 할 경우 속도를 늦출 수 있습니다.\n\n이를 극복하기 위해 Node.js는 \"worker-threads\"라는 모듈을 도입했습니다. 이를 사용하면 서로 다른 작업을 동시에 처리할 수 있는 별도의 스레드를 생성할 수 있습니다. 한 스레드가 작업을 마치면 결과를 메인 스레드로 다시 보내어 기다리지 않고 계속 작업할 수 있습니다. 따라서 워커 스레드를 사용하면 CPU 집약적인 작업이 메인 스레드를 더 이상 막지 않고 큰 작업을 여러 스레드로 나누어 속도를 높일 수 있습니다.\n\nNode.js 앱과 CPU 집약적 작업이 메인 스레드를 차단하는 노드를 통해 워커 스레드를 탐색해 보겠습니다. CPU 집약적 작업을 다른 스레드로 오프로드하여 메인 스레드를 차단하지 않고 작업을 진행할 수 있도록 워커 스레드 모듈을 사용할 것입니다. 마지막으로 CPU-바운드 작업을 나누어 네 개의 스레드가 병렬로 작업할 수 있도록 하여 작업을 가속화할 것입니다.\n\n# 프로젝트 및 종속성 설정하기\n\n\n\n시작하기 전에 프로젝트 디렉터리를 만들어 주세요:\n\n```js\nmkdir multi-threading\ncd multi-threading\n```\n\n이후, npm init 명령어를 사용하여 npm을 통해 프로젝트 디렉터리를 초기화해주세요:\n\n```js\nnpm init -y\n```\n\n\n\n다음으로, 다음 종속성을 설치하세요:\n\n```js\nnpm install express\n```\n\nExpress를 사용하여 블로킹 및 논블로킹 엔드포인트를 갖는 서버 애플리케이션을 만들 것입니다. 워커 스레드 모듈은 Node.js와 함께 제공되므로 별도로 설치할 필요가 없습니다.\n\n# 프로세스와 스레드 이해하기\n\n\n\nCPU 바운드 작업을 시작하기 전에, 컴퓨터에서 하나 이상의 코어를 가지고 있는 프로세스와 스레드가 어떤 것인지 이해하는 것이 중요합니다.\n\n## 프로세스\n\n프로세스란 운영 체제에서 실행 중인 프로그램입니다. 각각의 프로세스는 자체 메모리를 가지고 있으며, 다른 실행 중인 프로그램의 메모리에 접근할 수 없습니다. 무한 루프가 포함된 Node 프로그램을 만들어보겠습니다. 이 프로그램은 실행 중지되지 않고 계속 실행될 것입니다.\n\nprocess.js 라는 이름의 파일을 생성하고 아래 코드를 입력해주세요:\n\n\n\n```js\nconst process_name = process.argv.slice(2)[0];\nlet count = 0;\nwhile (true) {\n  count++;\n  if (count === 200 || count === 400) {\n    console.log(`${process_name}: ${count}`);\n  }\n}\n```\n\n이 프로그램을 node 명령어를 사용하여 실행해봅시다:\n\n```js\nnode process.js A &\n```\n\nA는 프로그램으로 전달된 명령행 인수로, process_name 변수에 저장됩니다. &는 노드 프로그램이 백그라운드에서 실행되도록 하며, 이것을 통해 셸에서 더 많은 명령을 입력할 수 있습니다.\n\n\n\n```js\n결과\n[1] 15228\nA: 200\nA: 400\n```\n\n숫자 7754는 운영 체제가 할당한 프로세스 ID입니다. A: 200 및 A: 400은 프로그램의 출력입니다.\n\nnode 명령을 사용하여 프로그램을 실행하면(가정으로 Node.js를 참조하는 경우), 프로세스가 생성됩니다. 운영 체제는 프로그램을위한 메모리를 할당하고, 컴퓨터의 디스크에서 프로그램 실행 파일을 찾아 메모리로 로드하는 작업과 같은 작업을 처리합니다. 그런 다음 프로그램에 프로세스 ID(PID)를 할당하고 실행을 시작합니다. 이 단계에서 프로그램은 프로세스가됩니다.\n\nNode 프로세스에 대한 간단한 요약을 얻으려면:\n\n\n\n```js\nps | grep node\n```\n\n```js\n출력\n15228 pts/1    00:00:15 node\n```\n\n하나의 프로그램에서 여러 프로세스를 생성할 수 있어요. 예를 들어, 다음 명령어를 사용해서 서로 다른 인수를 가진 세 개의 프로세스를 생성하고 백그라운드로 실행할 수 있어요:\n\n```js\nnode process.js B & node process.js C & node process.js D &\n```\n\n\n\n위의 명령을 실행한 후 출력 결과가 다음과 비슷할 수 있지만 순서가 다를 수 있습니다:\n\n```js\n출력:\n[1] 15925\n[2] 15926\n[3] 15927\nB: 200\nC: 200\nB: 400\nD: 400\nC: 400\nD: 400\n```\n\n출력을 주의 깊게 살펴보면 실행 순서가 고정되어 있지 않다는 것을 알 수 있습니다. B, C 및 D의 순서로 시작했지만 다른 순서로 완료될 수 있습니다. 이러한 동작의 이유는 OS가 각 프로세스를 실행할 시기를 결정하는 스케줄링 알고리즘을 가지고 있기 때문입니다.\n\n단일 코어 기계에서는 프로세스가 동시에 실행됩니다. 이는 OS가 일정 시간 동안 프로세스를 전환하는 것을 의미합니다. 예를 들어, 프로세스 D가 한정된 시간 동안 실행된 다음에는 상태가 어딘가에 저장되고 OS가 프로세스 B를 실행할 수 있도록 일정 시간을 예약하고, 이와 같은 방식으로 계속 진행됩니다. 이것은 모든 작업이 완료될 때까지 계속됩니다. 출력에서는 각 프로세스가 완료된 것처럼 보일 수 있지만 실제로는 OS 스케줄러가 계속해서 프로세스 간을 전환하고 있는 것입니다.\n\n\n\n멀티 코어(4코어) 운영 체제에서는 각 프로세스를 동시에 각 코어에서 실행하도록 OS가 스케줄링합니다. 이를 병렬 처리라고 합니다. 그러나 4개의 코어에 4개의 프로세스를 생성하면(총 8개의 프로세스), 각 코어는 두 개의 프로세스를 동시에 실행하여 완료될 때까지 처리합니다.\n\n# 스레드\n\nNode.js의 스레드는 프로세스와 유사하지만 단일 프로세스의 메모리 내에서 작동합니다. 프로세스는 자체 메모리 공간을 갖지만 각 스레드는 부모 프로세스의 메모리를 공유합니다. Node.js에서 프로세스를 생성하면 worker_threads 모듈을 사용하여 JavaScript 작업을 동시에 실행하기 위해 여러 스레드를 생성할 수 있습니다. 스레드는 메시지 전달이나 프로세스 메모리 내에서 데이터를 공유함으로써 서로 통신합니다. 프로세스와는 달리 스레드를 생성할 때 운영 체제에서 추가 메모리가 필요하지 않아 가벼우면서 작업을 병렬로 실행하기에 효율적입니다.\n\n스레드 실행 시, 프로세스와 유사하게 동작합니다. 단일 코어 시스템에 여러 스레드가 있는 경우 운영 체제는 정기적으로 스레드 간 전환을 수행하여 각 스레드가 단일 CPU에서 직접 실행되는 차례를 부여합니다. 다중 코어 시스템의 경우 OS는 모든 코어에 걸쳐 스레드를 스케줄링하여 JavaScript 코드를 동시에 실행할 수 있도록 합니다. 사용 가능한 코어보다 더 많은 스레드가 생성된 경우, 각 코어는 여러 스레드를 동시에 처리하여 리소스 사용을 최적화합니다.\n\n\n\n# Node.js에서 숨겨진 스레드들\n\nNode.js는 입출력 (I/O) 작업을 보다 효율적으로 처리하기 위해 추가 스레드를 활용하기 때문에 종종 \"다중 스레드\"라고 불립니다. 작동 방식은 다음과 같습니다:\n\n도입에서 설명한 바와 같이 JavaScript 자체는 단일 스레드형이기 때문에 한 번에 한 가지 작업만 처리합니다. 프로그램이 파일을 읽거나 네트워크 요청을 만들어야 할 때, 이러한 작업이 완료될 때까지 기다리며 주 스레드를 차단할 수 있습니다.\n\n그러나 Node.js는 libuv 라이브러리를 구현하여 4개의 추가 스레드를 Node.js 프로세스에 제공합니다. 이러한 스레드를 이용하여 I/O 작업을 별도로 처리하며, 작업이 완료되면 이벤트 루프가 해당 I/O 작업과 관련된 콜백을 마이크로태스크 대기열에 추가합니다. 주 스레드의 호출 스택이 비워지면 콜백이 호출 스택에 푸시되고 실행됩니다. 명확히 하기 위해 주어진 I/O 작업과 관련된 콜백은 병렬로 실행되지 않지만, 파일을 읽거나 네트워크 요청 등의 작업은 추가 스레드의 도움으로 병렬로 처리됩니다. I/O 작업이 완료되면 해당 콜백이 주 스레드에서 실행됩니다.\n\n\n\n위의 네 개 스레드에 추가로 V8 엔진은 자동 가비지 수집과 같은 작업을 처리하기 위해 두 개의 스레드도 제공합니다.\n\n이 말은 모든 노드 프로세스가 총 일곱 개의 스레드를 가지고 있다는 것을 의미합니다. 우리의 process.js 파일을 다시 실행하여 백그라운드에서 실행되도록 확인해보겠습니다:\n\n```js\nnode process.js A &\n```\n\n이제 스레드를 확인하기 위해 top 명령어를 사용하고 그에게 프로세스 ID를 전달해보겠습니다.\n\n\n\n```js\ntop -H -p 19821\n```\n\n위 명령을 실행하면 출력물은 다음과 유사합니다:\n\n![image](/assets/img/2024-05-14-OptimizingCPU-IntensiveTasksinNodejsAGuidetoWorkerThreads_1.png)\n\n출력물에서 알 수 있듯이, Node.js 프로세스에는 총 일곱 개의 스레드가 있습니다: JavaScript를 실행하는 주 스레드 하나, Node.js 스레드 네 개, 그리고 V8 스레드 둘입니다.\n\n\n\n이제 Node.js 프로세스의 스레드에 대해 알았으니, 다음 섹션에서 CPU 바운드 작업을 수행하고 주요 스레드를 관찰해 보겠습니다.\n\n# 워커 스레드를 사용하지 않고 CPU 바운드 작업 생성하기\n\nExpress 서버를 생성하여 두 가지 경로를 가지는 서버를 만들어봅시다: blocking과 non-blocking(컴퓨터 집약적 작업 실행).\n\n```js\nconst express = require(\"express\");\n\nconst app = express();\nconst port = 8000;\n\napp.get(\"/non-blocking\", (req, res) => {\n  res.status(200).send(\"비차단 페이지\");\n});\n\napp.get(\"/blocking\", async (req, res) => {\n  let counter = 0;\n  for (let i = 0; i < 20000000000; i++) {\n    counter++;\n  }\n  res.status(200).send(`결과는 ${counter} 입니다`);\n});\n\napp.listen(port, () => {\n  console.log(`포트 ${port}에서 서버 실행 중`);\n});\n```\n\n\n\n위의 코드 블록에서 Express.js를 사용하여 HTTP 서버를 만들었습니다. CPU 집약적인 작업을 실행하는 /non-blocking route와 /blocking route를 만들었습니다. 200 억 번을 반복하는 for 루프를 만들어 각 반복마다 카운터 변수를 1씩 증가시킵니다.\n\n아래 명령어를 실행하여 서버를 시작해 봅시다:\n\n```js\nnode index.js\n\n출력:\nServer running on port: 8000\n```\n\n이제 http://localhost:8000/non-blocking을 방문하면 즉시 응답을 받을 수 있습니다. 그 다음으로 새 탭에서 http://localhost:8000/blocking을 열고 다시 http://localhost:8000/non-blocking을 열면 즉시 응답을 받지 못하고 페이지가 계속로드를 시도하는 것을 볼 수 있습니다. /non-blocking route는 단지 /blocking route가 응답 결과를 반환할 때만 결과를 반환합니다. 결과는 20000000000입니다.\n\n\n\n이유는 CPU 바운드 루프로 인해 메인 스레드가 차단되기 때문입니다. 메인 스레드가 차단되면 Node.js는 CPU 바운드 작업이 완료될 때까지 어떤 요청도 처리할 수 없습니다. 따라서 /non-blocking route로 동시에 수천 개의 GET 요청이 있는 경우, /blocking route로의 단일 방문은 앱이 반응하지 않게 만들 수 있습니다.\n\n이제 CPU 집약적 작업이 애플리케이션에 미치는 영향을 이해했으니, 이제 약속(promises)을 사용하여 메인 스레드를 차단하지 않도록 노력해보겠습니다.\n\n# 약속(promises) 사용하여 CPU 바운드 작업 오프로드하기\n\n개발자들이 CPU 바운드 작업으로 인한 차단 효과를 알게 되면 약속(promises)을 사용하여 코드를 차단되지 않게 만들어보려 합니다. 이들은 readFile() 및 writeFile()과 같은 차단되지 않는 약속 기반 I/O 메서드 사용에 대한 지식에서 비롯됩니다. 그러나 알고 계시다시피, I/O 작업은 Node.js의 숨겨진 스레드를 사용하지만, CPU 바운드 작업은 아닙니다. 그럼에도 불구하고 이 섹션에서는 CPU 바운드 작업을 약속으로 감싸 차단되지 않도록 시도할 것입니다. 이 방법은 작동하지 않지만, 다음 섹션에서 할 일인 워커 스레드 사용의 가치를 알 수 있습니다.\n\n\n\n우리의 index.js 파일을 프로미스를 위해 수정해 봅시다:\n\n```js\nconst express = require(\"express\");\n\nconst app = express();\nconst port = 8000;\n\napp.get(\"/non-blocking\", (req, res) => {\n  res.status(200).send(\"non-blocking 페이지\");\n});\n\nfunction calculateCount() {\n  return new Promise((resolve, reject) => {\n    let counter = 0;\n    for (let i = 0; i < 20_000_000_000; i++) {\n      counter++;\n    }\n    resolve(counter);\n  });\n}\n\n\napp.get(\"/blocking\", async (req, res) => {\n  const counter = await calculateCount();\n  res.status(200).send(`결과: ${counter}`);\n});\n\napp.listen(port, () => {\n  console.log(`서버가 포트에서 실행 중: ${port}`);\n});\n```\n\n웹 브라우저에서 http://localhost:8000/blocking을 방문하고 로드될 때, 빠르게 http://localhost:8000/non-blocking 탭을 새로 고쳐보세요. 알 수 있듯이, non-blocking 라우트도 영향을 받아 /blocking 라우트가 로딩을 완료할 때까지 모두 기다립니다. 라우트가 여전히 영향을 받기 때문에, 프로미스는 자바스크립트 코드를 병렬로 실행시키지 않고 CPU 바운드 작업을 비차단형으로 만드는 데 사용할 수 없습니다.\n\n# CPU 바운드 작업 완화를 위해 worker-threads 사용하기\n\n\n\n이제 메인 스레드를 차단하지 않기 위해 worker-thread 모듈을 사용할 것입니다.\n\nworker.js 파일을 만들고 다음 코드를 추가해봅시다:\n\n```js\nconst { parentPort } = require(\"worker_threads\");\n\nlet counter = 0;\nfor (let i = 0; i < 20000000000; i++) {\n  counter++;\n}\n\nparentPort.postMessage(counter);\n```\n\n그 다음에 index.js를 수정해주세요:\n\n\n\n```js\nconst express = require(\"express\");\nconst { Worker } = require(\"worker_threads\");\n\nconst app = express();\nconst port = 8000;\n\napp.get(\"/non-blocking/\", (req, res) => {\n  res.status(200).send(\"non-blocking 페이지\");\n});\n\napp.get(\"/blocking\", async (req, res) => {\n  const worker = new Worker(\"./worker.js\");\n  worker.on(\"message\", (data) => {\n    res.status(200).send(`결과는 ${data} 입니다`);\n  });\n  worker.on(\"error\", (msg) => {\n    res.status(404).send(`오류 발생: ${msg}`);\n  });\n});\n\napp.listen(port, () => {\n  console.log(`서버가 포트 ${port}에서 실행 중입니다.`);\n});\n```\n\n파일을 저장한 후 서버를 실행하세요:\n\n```js\nnode index.js\n```\n\n웹 브라우저에서 http://localhost:8000/blocking 탭을 다시 방문해보세요. 이 페이지가 로딩을 완료하기 전에 http://localhost:8000/non-blocking 탭을 모두 새로고침 해보세요. 이제 /blocking 루트가 로딩을 마치기를 기다리지 않고 바로 로딩되는 것을 알 수 있을 겁니다. 이는 CPU 바운드 작업이 다른 스레드로 오프로드되어 메인 스레드가 모든 요청을 처리하기 때문입니다.\n\n\n\n\n요런식으로 워커 스레드를 사용하여 CPU 집약 작업을 블로킹되지 않게 만들 수 있어요.\n\n- 기사 영감: Stanley Ulili and Rachel Lee\n- Danish Shaikh | LinkedIn\n- Danish Shaikh | Github","ogImage":{"url":"/assets/img/2024-05-14-OptimizingCPU-IntensiveTasksinNodejsAGuidetoWorkerThreads_0.png"},"coverImage":"/assets/img/2024-05-14-OptimizingCPU-IntensiveTasksinNodejsAGuidetoWorkerThreads_0.png","tag":["Tech"],"readingTime":10},{"title":"뉵트 3에서 데이터 가져오기","description":"","date":"2024-05-14 14:38","slug":"2024-05-14-DataFetchingwithNuxt3","content":"\n\n\n![이미지](/assets/img/2024-05-14-DataFetchingwithNuxt3_0.png)\n\nTable of Contents\n\n- 소개\n- $fetch\n- useFetch\n- useAsyncData\n- 옵션\n- 캐싱 및 재검색\n\n# 소개\n\n\n\n\n데이터 가져오기와 관련된 Nuxt 3의 세계에서는 useFetch, useAsyncData, 그리고 $fetch 세 가지 강력한 도구를 갖추고 있습니다. 흥미로운 점은 이것들이 각기 다른 목적을 위해 사용되는 두 가지 조합 가능한 함수와 하나의 내장 라이브러리로 깔끔하게 분류될 수 있다는 것입니다. 이 모든 것을 이해하기 위해선, 단순함을 위해 차이점부터 알아야 합니다.\n\n# $fetch\n\n먼저 $fetch의 차이를 정의해야 한다고 생각합니다;\n\n- $fetch는 Nuxt에서 HTTP 요청을 만들기 위한 유틸리티 함수입니다. $fetch는 Vue 앱이나 API 라우트 내에서 HTTP 요청을 만들기 위해 ofetch 라이브러리를 사용합니다.\n- $fetch는 서버 측에서 클라이언트 측으로 상태를 전달할 수 없으며, 따라서 서버 및 클라이언트 측 모두에 대해 두 번 요청해야 합니다. 이 상황은 다음과 같은 코드로 콘솔과 터미널에서 기본적으로 볼 수 있습니다;\n\n\n\n```js\nconst dataFetch = await $fetch('https://jsonplaceholder.typicode.com/photos')\nconsole.log(dataFetch)\n```\n\n![Data Fetching with Nuxt](/assets/img/2024-05-14-DataFetchingwithNuxt3_1.png)\n\n두 번째로, useAsyncData의 차이점은 다음과 같이 설명할 수 있습니다:\n\n- useAsyncData는 컴포넌트 내에서 데이터 가져오기 프로세스를 조직적으로 관리할 수 있게 해주는 복합 기능입니다.\n- useAsyncData의 특징은 key와 handler 함수를 둘 다 필요로 한다는 점입니다. 예를 들어, useAsyncData를 사용하면 axios, graphql 또는 firebase와 같은 다양한 라이브러리나 API를 활용할 수 있습니다. 또한 useAsyncData와 nuxtApp 인수를 함께 사용하면 Nuxt 애플리케이션의 다른 기능에 액세스할 수 있어 데이터, 상태, 변수를 공유할 수 있습니다.\n- useAsyncData는 서버 사이드 렌더링 중 미리 데이터를 서버에서 가져와 클라이언트 측에서 재요청 없이 사용할 수 있습니다. 따라서 $fetch와 달리 데이터를 서버 측에서 클라이언트 측으로 재요청 없이 전송할 수 있습니다.\n\n\n\n```js\nconst data = await useAsyncData('photos', () => $fetch('https://jsonplaceholder.typicode.com/photos'))\nconsole.log(data)\n```\n\n![Image](/assets/img/2024-05-14-DataFetchingwithNuxt3_2.png)\n\n보시다싶이 클라이언트 측에서 사진을 가져오는 순서가 아니라 터미널에서 가져오는 것을 볼 수 있습니다.\n\n마지막으로 foruseFetch에 대해 말하자면, useAsyncData와 같은 목적을 가졌지만 더 구체적인 방법으로 데이터를 가져오는 데 사용할 수 있습니다.\n\n\n\n- useFetch는 URL을 사용하여 데이터를 가져오는 데 사용하는 다른 조합 가능한(composable)입니다.\n- 이 함수와 거의 동등하면서 더 간단하다고 말할 수 있습니다:\n\n![이미지](/assets/img/2024-05-14-DataFetchingwithNuxt3_3.png)\n\n차이점을 확인했으므로, 어떻게 사용하는지 알아보고 세부 사항을 자세히 살펴볼 수 있습니다.\n\n# useFetch\n\n\n\n가장 간단한 형태로 useFetch 컴포저블을 사용해보고, 그 기능을 분석해봅시다;\n\n```js\nconst data = useFetch('https://jsonplaceholder.typicode.com/photos')\nconsole.log(data)\n```\n\n![이미지](/assets/img/2024-05-14-DataFetchingwithNuxt3_4.png)\n\n보시다시피 우리가 얻는 결과는 약속(promise)이고, 이는 미래에 완료될 값이 담겨 있는 비동기 작업을 나타냅니다. 따라서 우리는 await을 사용해야 합니다. 또한, 몇 가지 중요한 값들을 관찰할 수 있는데, 이들을 어떻게 사용하고 그 의미를 이해하는지 알아보겠습니다.\n\n\n\n- data: 비동기 작업의 결과물을 나타내는 RefImpl 객체입니다.\n- error: 데이터 요청이 실패할 때 오류 객체를 포함하는 ObjectRefImpl입니다. 데이터 요청이 성공한 경우 null 값을 받습니다.\n- execute: useFetch 함수에 전달된 매개변수인 execute는 데이터 요청을 다시 시작하는 데 사용되는 함수입니다. lazy 매개변수가 useFetch 함수에서 true로 설정된 경우에 사용됩니다. 이 경우 데이터 요청은 route가 로드된 후에 해결되며, execute는 데이터 요청을 수동으로 시작하는 데 사용될 수 있습니다.\n- pending: 비동기 작업이 완료되었는지를 나타내는 RefImpl 객체입니다. RefImpl의 값이 true이면 작업이 계속 진행 중이라는 것을 의미합니다.\n- refresh: useFetch 함수에서 반환된 refresh 함수는 데이터를 다시 가져오는 데 사용할 수 있는 함수입니다. refresh 함수는 useFetch 함수를 다시 호출하여 데이터를 업데이트합니다. 데이터가 변경되거나 다시 로드해야 할 때 유용합니다.\n- status: 비동기 작업의 완료 상태를 나타내는 RefImpl 객체입니다. 성공, 오류, 대기 중 또는 진행 중과 같은 값들을 가질 수 있습니다.\n\n# useAsyncData\n\n사용할 때는 useFetch와 동일한 결과가 나올 것이므로, 제대로 사용합시다;\n\n```js\nconst { data: photos, error, execute, pending, refresh, status} = await useAsyncData('photos', () => $fetch('https://jsonplaceholder.typicode.com/photos'))\n```\n\n\n\n이 사용 예에서는 가져오기에 대한 'photos' 키 값을 지정했습니다.\n\n```js\n// promise.all을 사용한 예제\nconst { data: postCard, error, execute, pending, refresh, status } = await useAsyncData('post-card', async () => {\n  const [posts, users, comments] = await Promise.all([\n    $fetch('https://jsonplaceholder.typicode.com/posts'),\n    $fetch('https://jsonplaceholder.typicode.com/users'),\n    $fetch('https://jsonplaceholder.typicode.com/comments')\n  ])\n  return { posts, users, comments }\n})\n```\n\n키 지정\n\nuseAsyncData 함수에서 키를 지정하지 않으면 Nuxt가 자동으로 하나를 생성합니다. 이 키는 useAsyncData 함수가 위치한 파일 이름과 행 번호를 기반으로합니다. 그러나 이 키는 때때로 잘못될 수 있거나 충돌할 수 있습니다. 따라서 useAsyncData 함수에서 키를 명시하는 것이 좋습니다. 키 매개변수는 데이터 가져오기에 속하는 고유한 값을 가져야합니다.\n\n\n\n<img src=\"/assets/img/2024-05-14-DataFetchingwithNuxt3_5.png\" />\n\n# 옵션\n\n옵션은 composable에 대한 더 깊은 수준의 제어를 제공하며, useFetch와 useAsyncData에 대해 공통 값들을 취합니다. 이들을 통해 어떤 것을 달성할 수 있는지 자세히 살펴보겠습니다:\n\nLazy\n\n\n\n기본적으로 fetch composables의 기능 중 하나는 데이터를 가져오는 동안 라우트를 로딩하는 것을 방지하는 것입니다. 이는 데이터를 가져오는 예상 시간 동안 라우트 로딩이 일시 중지되어 데이터가 준비된 후 라우트가 로드됩니다. 그러나이 함수의 lazy 매개변수를 true로 설정하여 데이터 가져오기가 라우트 로드를 차단하지 않도록 허용할 수 있습니다. 이 경우 데이터를 가져오는 예상 시간 동안에도 라우트의 로드가 계속되며 결과적으로 데이터가 라우트 로드 후에 로드됩니다.\n\n기본적으로 두 가지 방법으로 lazy하게 만들 수 있습니다;\n\n```js\n// useFetch()\nconst { data } = await useFetch('https://jsonplaceholder.typicode.com/photos', {\n    lazy: true\n})\n// useAsyncData()\nconst { data }= await useAsyncData('photos', () => $fetch('https://jsonplaceholder.typicode.com/photos'), {\n    lazy: true\n})\n```\n\n```js\n// useFetch()\nconst { data } = await useLazyFetch('https://jsonplaceholder.typicode.com/photos')\n\n// useAsyncData()\nconst { data } = await useLazyAsyncData('photos', () => $fetch('https://jsonplaceholder.typicode.com/photos'))\n```\n\n\n\n클라이언트 전용 데이터 가져오기\n\n기본적으로 데이터 가져오기 구성 요소는 서버 측과 클라이언트 측에서 모두 작동합니다. 클라이언트 측에서만 실행하는 것이 서버 측에서 데이터를 가져올 필요가 없는 경우에 유용할 수 있습니다. 예를 들어 데이터가 사용자 상호작용에 따라 달라지거나 SEO에 민감하지 않은 데이터에 이 접근 방식을 사용할 수 있습니다.\n\n페이지가 처음로드 될 때 발생하는 대기 상태는 클라이언트 측 탐색 중에는 경험되지 않습니다. lazy 옵션과 함께 사용하면 초기 렌더링 시 필요하지 않은 데이터에 특히 유용할 수 있으며, 특히 클라이언트 측 탐색에 대해 유용합니다.\n\n```js\nconst { data } = await useFetch('https://jsonplaceholder.typicode.com/photos', {\n    lazy: true,\n    server: false,\n})\n```\n\n\n\n페이로드 크기 최소화\n\nNuxt 3을 사용하면 데이터를 가져올 때 pick 및 transform 옵션을 사용하여 페이지 로드를 줄일 수 있습니다. pick 옵션으로 초기 데이터에서 원하는 키 값을 가져올 수 있고, transform 기능으로 모든 데이터에서 특정 키 값을 가져올 수 있습니다.\n\n데이터를 가져오고 받는 과정에서는 변경사항이 없으며, 대신 서버 측에서 수신한 데이터를 처리하고 클라이언트 측으로는 특정 값만 보냅니다.\n\n```js\n// Pick\nconst { data: photos, error, pending, refresh, execute, status } = await useFetch('https://jsonplaceholder.typicode.com/photos?&_limit=50', {\n  pick: ['url', 'id']\n})\n// Transform\nconst {data: photos, pending, error, execute, refresh, status} = await useFetch('https://jsonplaceholder.typicode.com/photos', {\n  transform: (photos) => {\n    return photos.map(photo => ({ title: photo.title, url: photo.url }))\n  }\n})\n```\n\n\n\n와치\n\n와치 옵션을 사용하면 값을 모니터링하고 해당 값이 변경될 때마다 페치 프로세스를 다시 트리거할 수 있습니다. Immediate가 false로 설정되어 있을 때는 페치 프로세스를 완전 수동으로 수행합니다. 사용법은 다음과 같습니다:\n\n![이미지](/assets/img/2024-05-14-DataFetchingwithNuxt3_6.png)\n\nDeep\n\n\n\n깊이 옵션을 사용하면 데이터가 ref 객체에서 어떻게 반환되는지 제어할 수 있습니다. 기본적으로 deep 값은 true로 설정되어 있어 데이터가 깊게 반응하는 ref 객체로 반환됩니다. 이는 그 안의 항목 중 하나에 대한 변경 사항이 모두 추적된다는 것을 의미합니다. 이 옵션은 일반적으로 성능을 최적화하고 데이터 내의 모든 변경을 추적할 필요가 없을 때 사용됩니다.\n\n중복 제거\n\ndedupe 옵션은 데이터 검색 시 동일한 키로 데이터를 여러 차례 반환하는 것을 방지하는 데 사용됩니다. 이 옵션의 기본값은 cancel로, 새 요청이 발생할 때 기존 요청을 취소합니다. 다른 옵션인 defer는 대기 중인 요청이 있을 때 새 요청을 만들지 않습니다. 이러한 옵션을 사용하면 데이터 검색이 더 효율적이고 성능 지향적으로 이루어집니다.\n\n# 캐싱과 재검색\n\n\n\nNuxt 3를 사용하면 서버 쪽에서 데이터를 가져와 클라이언트 쪽으로 전송하는 데 useFetch 및 useAsyncData 컴포저블을 사용하는 방법을 탐색했습니다. 이렇게 하면 양쪽에서 데이터를 가져 오는 필요가 없어지죠. 그러나 클라이언트 측 탐색 중에 반복적인 데이터 가져 오기 작업에 대한 문제가 여전히 존재합니다. 이때 캐싱이 우리를 구해줍니다. 할당 된 키 값에 따라 캐시에서 이러한 데이터를 가져 오므로 클라이언트 측 탐색 중에 이러한 데이터를 반복적으로 가져 오는 필요가 사라집니다. 대신 캐시를 일시적 저장소로 활용하여 짧은 기간 동안 사용합니다.\n\n캐시 데이터 가져 오기\n\n일반적으로 캐시에서 데이터를 검색할 때 useNuxtData를 사용하면 데이터를 성공적으로 가져올 수 있습니다. 그러나 이것만으로 충분하지 않을 수 있습니다. 또한 캐시에 데이터가 없는 경우에만 조건부로 데이터를 가져 오는 경우, 페이지 간 탐색 중에 캐시에서 데이터를 활용하고 데이터를 다시 가져 오지 않을 겁니다. 여기서 필요한 컴포저블은 useNuxtApp입니다. 그러나 먼저 수행해야 할 작은 추가 사항이 있습니다.\n\n```js\nexport default defineNuxtConfig({\n// ...\n  experimental: {\n    payloadExtraction: true,\n  },\n});\n```\n\n\n\n그런 다음, 우리는 useFetch 및 useAsyncData 조합을 사용하여 getCacheData 옵션을 이용해 작은 함수를 작성할 것입니다. 이 방법을 통해 데이터가 캐시에 없을 때에만 fetch 작업이 실행됩니다.\n\n```js\nconst nuxtApp = useNuxtApp()\nconst { data: photos, error} = await useFetch('https://jsonplaceholder.typicode.com/photos?_limit=5', {\n  key: 'photos',\n  getCachedData(key) {\n    return nuxtApp.payload.data[key] || nuxtApp.static.data[key]\n  }\n})\n```\n\nuseNuxtData\n\n이 조합을 사용하면 지정된 키를 사용하여 데이터를 쉽게 검색하거나 새로 고칠 수 있습니다. 사용 예시는 다음과 같습니다:\n\n\n\n```js\nconst { data: cachedPhotos } = useNuxtData('photos')\n```\n\n여기서 캐시에서 데이터를 직접 가져오는 것이에요. 사용자가 시작한 변경사항 또는 다른 이유로 데이터를 다시 가져와 캐시를 새로 고치는 필요가 있을 때는 refreshNuxtData가 아주 편리한 방법일 수 있어요. 이렇게 하면 데이터를 다시 불러오게 돼요:\n\n```js\nconst refreshData = async () => {\n  await refreshNuxtData('photos')\n}\n```","ogImage":{"url":"/assets/img/2024-05-14-DataFetchingwithNuxt3_0.png"},"coverImage":"/assets/img/2024-05-14-DataFetchingwithNuxt3_0.png","tag":["Tech"],"readingTime":9},{"title":"최대 컨텐츠 로딩 시간LCP을 향상시키는 방법","description":"","date":"2024-05-14 14:36","slug":"2024-05-14-HowtoImproveLargestContentfulPaintLCP","content":"\n\n![이미지](/assets/img/2024-05-14-HowtoImproveLargestContentfulPaintLCP_0.png)\n\n가장 큰 콘텐츠 페인트(LCP)는 웹 사이트의 로딩 성능을 평가하는 중요한 지표입니다. 이는 페이지에서 사용자에게 가장 큰 콘텐츠 요소가 보이기까지 걸리는 시간을 나타냅니다. 이 요소는 일반적으로 이미지, 비디오 또는 큰 텍스트 블록입니다. LCP가 왜 중요한가요? 사용자 경험에 직접적인 영향을 미치기 때문입니다.\n\n온라인 쇼핑을 한다고 상상해보세요. 제품 페이지를 클릭했을 때 제품 이미지가 올라오는 데 오랜 시간이 걸린다면, 참을성을 잃고 사이트를 나갈 수도 있습니다. 이때 LCP가 중요한 역할을 하며, 사용자가 중요한 콘텐츠가 나타날 때까지 기다리는 데 걸리는 시간을 측정합니다.\n\n# 현재 LCP 지표를 점검해봅시다\n\n\n\n최적화 작업을 시작하기 전에 지금 어디에 서 있는지 알아야 합니다. Google PageSpeed Insights나 Lighthouse와 같은 도구들이 여기서 가장 좋은 도우미가 될 거에요. 웹사이트를 돌려보고 결과를 분석해 보세요.\n\n예를 들어, 제품 페이지에서 LCP 점수가 4초라고 해봅시다. 이것은 꽤 높은 점수로, 사용자들이 기본 제품 이미지를 볼 수 있기까지 상당한 시간을 기다려야 한다는 것을 나타냅니다.\n\n# 이미지 최적화\n\n이미지는 종종 높은 LCP 점수의 원인이 된다. 이런 시나리오를 고려해 보세요: 온라인 매거진을 운영하고 기사들이 이미지가 많이 들어가 있습니다. 만약 이러한 이미지들이 최적화되지 않았다면, LCP가 영향을 받을 수 있습니다.\n\n\n\n이를 해결하기 위해 이미지를 압축하고 크기를 조절하세요. 이 작업에는 여러 도구와 플러그인이 있습니다. 또한 WebP와 같은 최신 이미지 형식을 사용해보세요. WebP는 더 작은 파일 크기로 높은 품질을 제공합니다. 예를 들어, 2MB 크기의 JPEG 이미지를 WebP 형식으로 변환하면 품질에 눈에 띄는 손실 없이 파일 크기를 200KB로 줄일 수 있습니다.\n\n# 서버 응답 시간 최소화\n\n느린 서버 응답은 LCP에 큰 영향을 줄 수 있습니다. 전자 상거래 웹사이트를 운영한다고 상상해보세요. 서버가 사용자 요청에 3초가 걸린다면, 그 3초가 LCP에 추가됩니다!\n\n서버 성능을 향상시키려면 서버 측 캐싱을 구현하세요. 자주 액세스되는 콘텐츠를 더 빨리 제공하기 위해 서버 측 캐싱을 사용하는 것이 좋습니다. 또한 사용자에게 더 가까운 서버에서 콘텐츠를 제공하여 서버 응답 시간을 줄이기 위해 콘텐츠 전송 네트워크 (CDN)를 사용하는 것도 고려해보세요.\n\n\n\n# 콘텐츠 전달 최적화\n\n콘텐츠 전달은 LCP 최적화의 또 다른 중요한 측면입니다. 전 세계 뉴스 웹 사이트를 운영한다고 가정해 봅시다. 뉴욕에 서버가 있지만 호주에 있는 사용자가 사이트에 액세스하려고 하면 그 사용자에게 콘텐츠가 도달하는 데 더 오랜 시간이 걸릴 것입니다.\n\n이것이 CDN이 유용한 이유입니다. CDN은 전 세계 여러 서버에 콘텐츠를 분산하여 사용자가 지리적으로 가까운 서버에서 액세스할 수 있도록 합니다. 이렇게 함으로써 콘텐츠의 이동 속도를 줄이고, 궁극적으로 LCP를 개선합니다.\n\n# 렌더링 차단 리소스 줄이기\n\n\n\n렌더링이 차단되는 자원인 JavaScript 및 CSS는 페이지 로딩 속도를 늦출 수 있습니다. 만약 무거운 JavaScript 라이브러리와 CSS 파일이 있는 웹사이트를 운영 중이라고 상상해보세요. 사용자가 사이트에 접속하면, 그들의 브라우저는 이러한 자원을 모두 로드할 때까지 컨텐츠를 표시하기 전에 멈춰야 합니다.\n\n최적화를 위해 렌더링을 차단하는 JavaScript 및 CSS 사용을 최소화하세요. 비필수 스크립트에 대해 비동기적으로 로드하여, 이러한 자원이 완전히 로드되기 전에도 페이지가 렌더링을 시작할 수 있도록 합니다.\n\n# 화면 상단 콘텐츠에 우선순위를 둡니다\n\n화면 상단 콘텐츠란 스크롤 없이 사용자에게 보이는 콘텐츠를 말합니다. 사용자가 더 빠른 초기 경험을 제공하기 위해 이 콘텐츠를 먼저 로드하는 것이 중요합니다.\n\n\n\n예를 들어, 블로그를 운영 중이라면 제목, 주요 이미지 및 소개 텍스트가 다른 내용보다 먼저 로드되도록하세요. 사용자들은 나머지 페이지가 백그라운드에서 계속로드될 때 독자적으로 읽기를 시작할 수 있어야 합니다.\n\n# 브라우저 캐싱\n\n브라우저 캐싱은 사용자의 장치에 정적 자산을 로컬로 저장하여 LCP를 줄이는 강력한 기술입니다. 이는 사용자가 사이트를 다시 방문할 때, 브라우저가 모든 자산을 다시 다운로드 할 필요가 없어 더 빠른 로드 시간을 보장합니다.\n\n브라우저 캐싱을 구현하기 위해, 다양한 유형의 콘텐츠에 적절한 캐시 만료 헤더를 설정할 수 있습니다. 예를 들어, 이미지, 스타일시트 및 스크립트를 일정 기간 동안 캐시하도록 서버를 구성하여 반복 다운로드를 줄여줄 수 있습니다.\n\n\n\n```js\n<! — 브라우저 캐싱을 위한 샘플 Apache 구성 →\n<IfModule mod_expires.c>\n ExpiresActive on\n ExpiresByType text/css \"access plus 1 year\"\n ExpiresByType image/jpeg \"access plus 1 month\"\n ExpiresByType image/png \"access plus 1 month\"\n</IfModule>\n```\n\n# 폰트 최적화\n\n폰트도 LCP에 영향을 미칠 수 있습니다. 다양한 폰트와 폰트 두께를 사용하면 추가로 로딩 시간이 소요될 수 있습니다. 폰트를 최적화하려면 사용하는 폰트와 변형의 수를 제한하세요.\n\n예를 들어, 여섯 가지 서로 다른 폰트 두께를 사용하는 대신 두 가지나 세 가지만 사용하는 것을 고려해보세요. 또한, font-display CSS 속성을 사용하여 폰트 로딩을 제어할 수 있습니다. font-display: swap;과 같은 설정은 폰트가 완전히 로드되지 않은 경우에도 텍스트가 보이도록 보장하여 레이아웃 변동을 방지합니다. \n\n\n\n```js\n/* 폰트 표시 방식 예시 */\n@font-face {\n font-family: 'Roboto';\n src: url('roboto.woff2') format('woff2');\n font-display: swap;\n}\n```\n\n# 반응형 디자인\n\n오늘날 다양한 기기에서 사용되는 세상에서는, 반응형 디자인은 LCP(Largest Contentful Paint)를 줄이는 데 중요합니다. 모바일 폰부터 대형 데스크탑 디스플레이까지 다양한 화면 크기에 맞게 웹사이트가 우아하게 적응하도록 해야 합니다.\n\n예를 들어, 전자상거래 사이트를 운영 중이라면, 제품 이미지가 작은 화면에 맞게 크기를 조정하고 적절하게 재구성되도록 확인하세요. 사용자의 장치에 따라 다른 이미지 크기를 제공하여 최적의 로드 시간을 보장하는 `srcset` 속성과 같은 반응형 이미지 기술을 사용하세요.\n\n\n\n\n```js\n<! — 반응형 이미지를 위해 srcset을 사용한 예시 →\n<img srcset=\"image.jpg 1024w,\n     image-800.jpg 800w,\n     image-400.jpg 400w\"\n     sizes=\"(min-width: 768px) 50vw, 100vw\"\n     src=\"image.jpg\" alt=\"반응형 이미지\">\n```\n\n# 컨텐츠 전달 우선순위화\n\nLCP를 줄이기 위해 컨텐츠 전달을 최적화하는 것이 중요합니다. 중요한 리소스를 우선적으로 다운로드하려면 프리로딩(preloading) 및 프리페칭(prefetching)과 같은 리소스 힌트를 사용할 수 있습니다. 이러한 힌트를 통해 브라우저에게 어떤 리소스를 먼저 가져와야 하는지에 대한 정보를 제공합니다.\n\n예를 들어, 상호 작용 기능에 필요한 큰 JavaScript 파일이 있다면, `link rel=\"preload\"` 태그를 사용하여 브라우저에 가능한 빨리 로드하도록 지시할 수 있습니다.\n\n\n\n\n```js\n<!— JavaScript 파일을 사전로드하는 예시 →\n<link rel=\"preload\" href=\"script.js\" as=\"script\">\n```\n\n이 힌트들을 적절히 활용하십시오. 리소스를 너무 많이 사전로드하는 것은 불필요한 로드 시간으로 이어질 수 있습니다.\n\n# 정기적인 성능 테스트\n\nLCP 최적화는 계속되는 과정이며, 정기적인 성능 테스트는 진행 상황을 추적하고 새로운 문제를 식별하는 데 중요합니다. Google PageSpeed Insights, Lighthouse 또는 WebPageTest와 같은 도구를 사용하여 정기적으로 LCP 점수를 평가하십시오.\n\n\n\n\n효율 저하 알림을 설정하여 문제를 신속하게 해결할 수 있도록 하세요. 일관된 테스트와 모니터링은 웹사이트가 시간이 지남에 따라 최적의 LCP를 유지하도록 도와줍니다.\n\n# 콘텐츠 관리 시스템(CMS) 업데이트\n\n워드프레스와 같은 콘텐츠 관리 시스템을 사용 중이라면, CMS와 해당 플러그인/테마가 업데이트되어 있는지 확인하세요. CMS 업데이트에는 성능 향상과 버그 수정이 포함되어 있어 LCP에 긍정적인 영향을 미칠 수 있습니다.\n\nCMS와 플러그인을 업데이트하지 않으면 성능을 저하시키는 오래된 코드가 발생할 수 있으므로 정기적으로 업데이트를 확인하고 적용하는 것을 습관으로 만드세요.\n\n\n\n# 사용자 경험 최적화\n\n기술적 최적화 이상으로 사용자 경험을 향상하는 것은 LCP의 인식되는 영향을 줄이는 데 중요합니다. 페이지가 로드되기를 기다리는 상황을 상상해보세요 — 간단한 로딩 애니메이션이나 콘텐츠를 위한 플레이스홀더는 사용자들을 관여시키고 기다림을 덜 지루하게 만들어줄 수 있어요.\n\n예를 들어, 뉴스 웹사이트를 운영 중이라면, 전체 기사가 백그라운드에서 로드될 때 로딩 스피너나 티저 이미지를 표시할 수 있어요. 이렇게 하면 사용자들이 로딩 프로세스 중에도 계속해서 관심을 가지고 정보를 얻을 수 있어요.\n\n# 사용자 테스트 및 피드백\n\n\n\nLCP가 사용자에게 어떤 영향을 미치는지 정확히 파악하려면 그들로부터 직접 피드백을 모으는 것이 중요합니다. 실제 사용자 피드백을 통해 성능 테스트만으로는 놓치기 쉬운 문제를 발견할 수 있습니다.\n\n웹사이트와 상호 작용하는 사용자를 관찰하는 사용자 테스트 세션을 진행해 보세요. LCP가 느릴 때 사용자의 반응에 주목해 보세요. 그들이 좌절이나 성가신 감정을 드러내는지 확인해 보세요. 그들의 피드백은 문제점을 파악하는 데 매우 소중할 수 있습니다.\n\n또한, 히트맵과 세션 녹화와 같은 도구를 활용하여 사용자 행동에 대한 통찰력을 얻을 수 있습니다. 이 도구는 사용자가 어디를 클릭하고, 어디까지 스크롤하며, 어디에서 이탈하는지 보여줍니다. 이 데이터를 LCP의 맥락에서 분석하여 개선이 필요한 영역을 정확히 식별할 수 있습니다.\n\n# 문서 작성 및 교육\n\n\n\nLCP 최적화는 일회성 작업이 아니라 팀 내 협력과 지식 공유가 필요한 지속적 노력입니다. 웹사이트를 유지하는 모든 이들이 동일한 목표를 향해 나아갈 수 있도록 최적화 전략과 모범 사례를 문서화하세요.\n\n내부 문서를 작성하여 LCP 최적화 기술, 사용하는 도구 및 웹사이트에 고유한 프로세스를 자세히 기술해보세요. 이 문서는 현재와 미래 팀원들에게 참고 자료로 활용될 수 있습니다.\n\n또한, 팀을 대상으로 교육 세션이나 워크샵을 제공하는 것도 고려해보세요. LCP의 중요성과 그에 대한 역할이 어떻게 최적화에 기여하는지에 대해 팀원들을 교육해주세요. LCP의 중요성과 각자의 역할을 이해하면, 노력이 더욱 조화롭고 효율적일 것입니다.\n\n# 지속적인 개선\n\n\n\n웹 성능 최적화는 동적인 분야입니다. 새로운 기술, 최상의 실천 방법 및 사용자 기대치는 지속적으로 발전하고 있습니다. 경쟁 우위를 유지하기 위해 계속해서 개선해야 합니다.\n\n정기적으로 LCP 지표와 최적화 전략을 재방문하세요. 변경 사항과 개선 사항을 구현하면서 LCP 점수와 사용자 경험에 미치는 영향을 모니터링하세요. 관찰한 결과에 기반하여 접근 방식을 조정할 준비를 하세요.\n\n산업 트렌드와 떠오르는 기술에 대해 최신 정보를 유지하세요. 예를 들어, 새로운 이미지 최적화 기술이나 콘텐츠 전달 방식이 인기를 얻는 경우, LCP 최적화 전략에 통합하는 것을 고려해 보세요.\n\n마지막으로, 사용자의 의견을 경청하세요. 페이지 로딩 시간이 느리거나 LCP 문제에 관한 피드백을 받으면 신속히 처리하세요. 사용자 만족도는 항상 노력의 최우선 과제여야 합니다.\n\n\n\n# 🔥 발견한 이 웹 개발 안내서가 도움이 되셨나요? 🔥\n\n이런 심층 안내서를 작성하는 데에는 시간, 헌신, 그리고 네! — 풍부한 커피가 필요합니다! 만약 이 글이나 기타 글이 여러분의 개발자 여정에 가치를 더했다면, 고맙다는 마음을 표현해주세요.\n\n👉 제 노력을 지원하고 커피 한 잔 사주세요! https://www.buymeacoffee.com/svetloslav ☕\n\n여러분이 기부해주시는 매 한 잔의 커피는 이와 같은 글들이 더 많이 나오도록 도와줍니다. 이 여정에 함께해 주셔서 감사합니다!\n\n\n\n# 친절한말로\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우해주세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀\n- 무료 주간 뉴스레터에 가입하세요. 🗞️\n- 트위터(X) 대신 링크드인, 유튜브, 디스코드에서도 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-14-HowtoImproveLargestContentfulPaintLCP_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoImproveLargestContentfulPaintLCP_0.png","tag":["Tech"],"readingTime":7},{"title":"JavaScript에서 설명하는 기본적인 OOP 개념","description":"","date":"2024-05-14 14:35","slug":"2024-05-14-BasicOOPConceptsExplainedinJavaScript","content":"\n\n# 소개\n\n객체 지향 프로그래밍은 소프트웨어 개발에서 가장 중요한 프로그래밍 패러다임 중 하나입니다.\n\n그래서 나는 JavaScript의 맥락에서 OOP의 기본 개념을 설명하는 이 기사를 쓰기로 결정했습니다.\n\n![이미지](/assets/img/2024-05-14-BasicOOPConceptsExplainedinJavaScript_0.png)\n\n\n\n# 클래스:\n\nOOP(객체 지향 프로그래밍)를 시작할 때 보통 가장 먼저 배우는 개념은 \"클래스\"입니다. 왜냐하면 OOP 패러다임이 시작되는 곳이기도 하고 이 패러다임의 기반이기 때문이죠.\n\n클래스는 나중에 우리가 객체라고 부르게 될 것을 정의하기 시작하는 곳으로, 메서드와 속성과 같은 모든 사용할 수 있는 것들을 클래스 내에서 정의합니다.\n\n자바스크립트의 클래스 예제를 살펴보겠습니다:\n\n\n\n위의 예제에서는 \"Car\"라는 클래스를 정의했습니다. 이 클래스에는 이름, 색상 및 모델과 같은 속성이 있으며, 내부에는 두 개의 메서드가 있습니다. 첫 번째 메서드(getCarName)는 이름 속성을 반환하는 역할을 하고, 두 번째 메서드(getCarDescription)는 차량의 설명을 형식화된 방식으로 반환하는 역할을 합니다.\n\n간단히 설명하자면, OOP에서의 속성은 클래스가 메서드에서 처리할 수 있는 값들이며, 메서드는 함수와 비슷하며 클래스의 속성을 사용하여 다양한 작업, 유효성 검사 또는 요청을 수행할 수 있는 곳입니다.\n\n클래스 개념에 대해 이미 다뤘으니 이제 객체 개념에 대해 이야기해보겠습니다.\n\n# 객체:\n\n\n\nOOP(객체 지향 프로그래밍)에서 객체 개념은 대부분 클래스 개념과 함께 사용됩니다. 왜냐하면 객체는 기본적으로 클래스의 인스턴스이기 때문이죠.\n\n따라서 객체는 우리가 이전에 정의한 속성과 메서드를 사용하는 곳입니다.\n\n이제 객체의 예시를 살펴봅시다:\n\n물론, 객체 예시는 클래스 예시와 거의 비슷하죠?\n\n\n\n이렇게 두 개념이 어떻게 함께 작동하는지 정말 잘 볼 수 있습니다.\n클래스 예제와 달리, 이제는 객체(클래스의 인스턴스)를 정의하고 클래스에 속성이 갖게 될 값을 알려줍니다(정확히 22번째 줄).\n\n그래서 이 객체 내에서 이것이 클래스 안에 있는 속성들의 값입니다:\n\n```js\nthis.name = \"Ferrari\",\nthis.color = \"Red\",\nthis.model = \"Roma\";\n```\n\n객체를 생성한 후, console.log() 메소드 내에서 \"getCarDescription\" 메소드를 호출하고, 다음과 같이 기록됩니다:\n\n\n\n```js\n\"차 설명: 이름: 페라리 - 모델: 로마 - 색상: 빨간색\"\n```\n\n# 정말 간단하죠?\n\n이 두 가지 기본 개념은 가장 중요한 것들 중 하나입니다. 왜냐하면 이 둘을 명확하게 이해하지 못하면 객체 지향 프로그래밍을 배우기 매우 어려워지기 때문이죠. 이 두 요소는 시스템이 정의된 클래스와 객체를 통해 상호 작용할 수 있는지 확인하기 위해 중요한 역할을 하며, 이를 통해 이 시리즈의 다음 장에서 설명될 상속, 캡슐화, 추상화 및 다형성과 같은 객체 지향 프로그래밍의 나머지 개념을 활용할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-BasicOOPConceptsExplainedinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-14-BasicOOPConceptsExplainedinJavaScript_0.png","tag":["Tech"],"readingTime":2}],"page":"105","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}