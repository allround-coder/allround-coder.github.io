{"pageProps":{"posts":[{"title":"React Native 웹 뷰와 React 앱 간의 통신","description":"","date":"2024-05-14 11:40","slug":"2024-05-14-CommunicationbetweenReactNativewebviewandReactapp","content":"\n\n이것은 React Native 웹 뷰와 React 응용 프로그램 간의 데이터 통신 방법 중 하나입니다.\n\n![CommunicationbetweenReactNativewebviewandReactapp](/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png)\n\nReact Native 앱의 웹 뷰와 별도로 호스팅된 React 애플리케이션 간의 통신 방법은 여러 가지가 있을 수 있습니다. 저는 이러한 요구사항을 마주했고, 여기에 적용하기로 결정한 해결책을 공유하려 합니다.\n\n먼저, React 응용 프로그램과 React Native 응용 프로그램의 기본 구현을 살펴보겠습니다.\n\n\n\n간단한 React 어플리케이션:-\n\n- App.js의 useEffect() 안에 원시 이벤트를 수신하는 이벤트 리스너를 추가합니다. 이는 HTML의 \"window\" 객체 내에 존재합니다. EventTarget 인터페이스의 addEventListener() 메소드는 특정 이벤트가 대상에 전달될 때마다 호출될 함수를 설정합니다. 참고: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n- 첨부한 리스너 함수 안에서는 React 네이티브 또는 HTML 문서로 전송되는 외부 소스에서 찾을 수 있는 데이터가 포함된 nativeEvent 객체를 얻습니다.\n- React에서 React 네이티브로 메시지를 보내려면 window.ReactNativeWebView.postMessage() 메소드를 사용할 수 있습니다. 추가적인 임포트나 패키지가 필요하지 않습니다. 이는 HTML의 \"window\" 객체에 내장되어 있습니다. window.postMessage() 메소드는 Window 객체 간 안전하게 교차 출처 통신을 가능하게 합니다. 예를 들어 페이지와 생성된 팝업 간 또는 페이지와 내장된 iframe 간의 통신입니다. 참고: https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n\n<img src=\"/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_1.png\" />\n\n간단한 React 네이티브 어플리케이션과 웹 뷰:-\n\n\n\n- 어떤 npm 패키지에서 간단한 웹뷰를 생성합니다.\n- 웹사이트에서 메시지를 받으려면 웹뷰의 onMessage = '' 속성을 가리키는 메소드를 첨부합니다. 해당 함수에서 들어오는 메시지를 처리할 수 있습니다.\n- React로 메시지를 보내려면 useRef()를 사용하여 참조를 가져와야 합니다. ref = 'webViewRef'와 함께 첨부합니다.\n- webViewRef.current.postMessage()를 사용하여 React 웹사이트로 메시지를 보낼 수 있습니다.\n- componentDidMount() 시점에 뭔가를 트리거하려면, webview의 onLoadEnd() 속성에 필요한 메소드를 추가하여 할 수 있습니다. 이것은 웹뷰가 웹사이트를 로드했을 때 콜백을 트리거합니다.\n- 최신 버전의 userAgents를 언급했습니다. 또한 domStorageEnabled, cacheEnabled, javaScriptEnabled 등과 같은 프롭스를 활성화하여 React Native 스크린의 성능이 향상되도록 했습니다.\n- 사이트가 로드될 때까지 사용자 정의 로더를 표시할 수도 있습니다.\n\n[이미지 바로가기](/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_2.png)\n\n저의 Github 저장소 공유합니다: [react-zoom](https://github.com/svbala99/react-zoom) 및 [zoomsdk-sign-generator-express](https://github.com/svbala99/zoomsdk-sign-generator-express)\n\n이 저장소들은 React Native에서 웹뷰를 설정할 수 있게 해주고, 해당 웹뷰에서 zoom 미팅을 호스팅할 수 있게 합니다. 두 번째 저장소는 안전한 서명을 생성하는 데 도움이 됩니다. 이는 공식 Zoom에서 지시한 대로 입니다.\n\n\n\n누군가에게 도움이 되면 좋겣습니다. 읽어 주셔서 감사합니다. 또 다른 흥미로운 글로 돌아오겠습니다. 건강하세요, 챙기세요!!!","ogImage":{"url":"/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png"},"coverImage":"/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png","tag":["Tech"],"readingTime":3},{"title":"이 Go 라이브러리는 혁신적입니다","description":"","date":"2024-05-14 11:39","slug":"2024-05-14-ThisGoLibraryIsGameChanging","content":"\n\n<img src=\"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_0.png\" />\n\nReact의 강력한 기능 중 하나는 JSX입니다. React는 렌더링 로직이 다른 UI 로직과 본질적으로 결합되어 있다는 사실을 받아들입니다. Jinja와 같은 템플릿 엔진을 사용하는 것은 데이터를 컴포넌트로 전달하는 대신 엔진에 문맥을 '전달'해야 한다는 사실로 인해 같은 경험을 제공해주지 않습니다.\n\n# Templ은 HTML과 Go 사이의 간격을 좁히려고 합니다\n\n```js\npackage main\n\n// 우리 Component에서 사용할 수 있는 일반 Go 코드\nvar greeting = \"환영합니다!\"\n\n// templ Component\ntempl headerTemplate(name string) {\n  <header>\n    <h1>{ name }</h1>\n    <h2>\"{ greeting }\"은 일반 Go 코드에서 옵니다</h2>\n  </header>\n}\n```\n\n\n\n다음과 같이 templ은 Go에 자체 구문을 추가하지만 기본적으로 함수처럼 작동합니다.\n\n# 구성\n\n## Templ\n\n```js\npackage components\n\ntempl Link(name string, path string) {\n    - <li>\n    -     <a href={templ.URL(path)}>{name}</a>\n    - </li>\n}\n\ntempl NavBar() {\n    - @Link(\"Home\", \"home\")\n    - @Link(\"News\", \"news\")\n    - @Link(\"Contact Us\", \"contact-us\")\n}\n```\n\n\n\n## 리엑트\n\n```js\nfunction Welcome(props) {\n  return <h1>안녕, {props.name}</h1>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <Welcome name=\"사라\" />\n      <Welcome name=\"카할\" />\n      <Welcome name=\"에디트\" />\n    </div>\n  );\n}\n```\n\n보시다시피 구문은 매우 유사합니다. 리엑트 컴포넌트는 HTML 스타일 요소로 변합니다.\n\n# For 루프\n\n\n\n```js\npackage main\n\ntempl nameList(items []Item) {\n  <ul>\n  for _, item := range items {\n    <li>{ item.Name }</li>\n  }\n  </ul>\n}\n```\n\n여기서 Javascript가 약간 뛰어나다고 할 수 있습니다. Javascript에는 배열을 쉽게 반복할 수 있는 Map 함수와 같은 작은 도우미들이 많이 있습니다.\n\n# Javascript\n\n문법이 React와 비슷해 보이지만, 완전히 다릅니다. Templ은 Javascript와 상호 작용할 수 없도록 제한됩니다.\n\n\n\n```js\ntempl body() {\n <script>\n  const chart = LightweightCharts.createChart(document.body, { width: 400, height: 300 });\n  const lineSeries = chart.addLineSeries();\n  lineSeries.setData([\n    { time: '2019-04-11', value: 80.01 },\n    { time: '2019-04-12', value: 96.63 },\n    { time: '2019-04-13', value: 76.64 },\n    { time: '2019-04-14', value: 81.89 },\n    { time: '2019-04-15', value: 74.43 },\n    { time: '2019-04-16', value: 80.01 },\n    { time: '2019-04-17', value: 96.63 },\n    { time: '2019-04-18', value: 76.64 },\n    { time: '2019-04-19', value: 81.89 },\n    { time: '2019-04-20', value: 74.43 },\n  ]);\n </script>\n}\n```\n\n템플은 그냥 템플릿 엔진일 뿐이에요. 텍스트를 합쳐주는 거죠.\n\n# 템플 설치하기\n\n```js\ngo install github.com/a-h/templ/cmd/templ@latest\n```\n\n\n\n# Templ은 어떻게 작동하나요?\n\nTempl 문서에서는 모든 .templ 파일을 components 폴더/패키지에 저장하는 것을 권장합니다.\n\n```js\n//navbar.templ\npackage components\n\ntempl Link(name string, path string) {\n    <li>\n        <a href={templ.URL(path)}>{name}</a>\n    </li>\n}\n\ntempl NavBar() {\n    @Link(\"Home\", \"home\")\n    @Link(\"News\", \"news\")\n    @Link(\"Contact Us\", \"contact-us\")\n}\n```\n\n그런 다음 .templ 파일을 만든 후 다음 명령을 실행하면 됩니다:\n\n\n\n```js\ntempl generate\n```\n\n그런 다음, 코드 생성을 사용하여 별도의 ‘navbar_templ.go’ 파일을 생성합니다.\n\n<img src=\"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_1.png\" />\n\n그런 다음 핸들러에서는 간단히 Render 함수를 호출할 수 있습니다.\n\n\n\n\n```js\npackage main\n\nimport (\n\"context\"\n\"templ-echo-test/components\"\n\n\"github.com/labstack/echo/v4\"\n)\n\nfunc Page(c echo.Context) error {\nreturn components.NavBar().Render(context.Background(), c.Response())\n}\n```\n\n코드 생성 패스 없이는 Go가 .templ 파일을 읽을 수 없습니다.\n\n# 핫 리로드\n\ntempl을 사용하는 Go 웹 애플리케이션에 웹 브라우저에서 액세스하려면 몇 가지 일이 발생해야 합니다:\n\n\n\n\n- templ generate 명령을 실행하여 *.templ 파일에서 Go 코드 (*_templ.go 파일)를 생성해야 합니다.\n- Go 코드는 포트에서 웹 서버를 시작해야 합니다. 예: (http.ListenAndServe(\"localhost:8080\", nil).\n- Go 프로그램을 실행해야 합니다. 예: go run .. 명령으로 실행합니다.\n- 웹 브라우저가 페이지에 접속하거나 새로고침해야 합니다. 예: http://localhost:8080.\n\n만약 *.templ 파일이 변경되면, #1과 #2를 실행해야 합니다.\n\n만약 *.go 파일이 변경되면, #3과 #4를 실행해야 합니다.\n\nTempl은 이러한 작업을 자동으로 수행하는 내장 툴을 제공합니다. Air와 같은 도구들도 사용할 수 있지만, 내장된 툴처럼 페이지를 자동으로 새로고침하지는 않습니다.\n\n\n\n아래 명령어를 실행하여 설정을 합니다\n\n```js\ntempl generate --watch --proxy=\"http://localhost:8080\" --cmd=\"go run .\"\n```\n\n# 내 이북을 확인해보세요: Go로 풀스택 애플리케이션 작성하기\n\nhttps://harryhtml.gumroad.com/l/tdbxl","ogImage":{"url":"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_0.png"},"coverImage":"/assets/img/2024-05-14-ThisGoLibraryIsGameChanging_0.png","tag":["Tech"],"readingTime":4},{"title":"리액트 네이티브에서 네이티브 모듈 생성하기","description":"","date":"2024-05-14 11:38","slug":"2024-05-14-CreatingaNativeModuleinReactNative","content":"\n\n리액트 네이티브는 JavaScript와 React를 사용하여 모바일 앱을 개발할 수 있게 해주는 인기 있는 프레임워크입니다. 때때로 자바스크립트에서 사용할 수 없는 플랫폼별 기능에 액세스해야 할 수도 있습니다. 이때 네이티브 모듈이 필요한데, 이를 통해 iOS의 Swift나 안드로이드의 코틀린과 같은 네이티브 언어로 코드를 작성하여 사용할 수 있습니다.\n\n## 네이티브 모듈이란?\n\n네이티브 모듈은 JavaScript로 처리할 수 없는 작업을 수행할 수 있도록 해주는, 네이티브 플랫폼 언어(Swift, Kotlin 등)로 작성된 코드 조각입니다. 디바이스 하드웨어 기능에 액세스하거나 복잡한 계산을 수행하는 것 등이 그 예시에 해당합니다.\n\n## 요구 사항\n\n\n\n시작하기 전에 설치해야 할 사항들을 확인해 주세요:\n\n- Node.js와 npm\n- React Native CLI\n- Xcode (iOS 개발을 위해)\n- 안드로이드 스튜디오 (Android 개발을 위해)\n\n## 단계별 안내\n\n1. 개발 환경 설정하기\n\n\n\n우선, 아직 React Native 프로젝트를 설정하지 않았다면 다음을 따르세요:\n\n```js\nnpx react-native init MyNativeModuleProject\ncd MyNativeModuleProject\n```\n\n2. 네이티브 모듈 생성\n\niOS 및 Android 모두에서 기기 정보를 제공하는 네이티브 모듈을 생성해봅시다.\n\n\n\n안드로이드용으로:\n\n- Kotlin 파일 생성: 안드로이드 프로젝트 디렉토리로 이동하세요:\n\n```js\ncd android/app/src/main/java/com/mynativemoduleproject/\n```\n\n- 패키지 내에 DeviceInfoModule.kt라는 새로운 Kotlin 파일을 생성하세요.\n- Kotlin 파일 편집:\n\n\n\n이 네이티브 모듈의 Kotlin 코드입니다:\n\n```js\npackage com.mynativemoduleproject\n\nimport com.facebook.react.bridge.ReactApplicationContext\nimport com.facebook.react.bridge.ReactContextBaseJavaModule\nimport com.facebook.react.bridge.ReactMethod\nimport com.facebook.react.bridge.Promise\n\nclass DeviceInfoModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext) {\n    override fun getName(): String {\n        return \"DeviceInfo\"\n    }\n\n    @ReactMethod\n    fun getDeviceInfo(promise: Promise) {\n        try {\n            val deviceInfo = mapOf(\"device\" to android.os.Build.MODEL, \"OS\" to android.os.Build.VERSION.RELEASE)\n            promise.resolve(deviceInfo)\n        } catch (e: Exception) {\n            promise.reject(\"Error\", e.localizedMessage)\n        }\n    }\n}\n```\n\n이 모듈은 기기 모델과 OS 버전을 반환합니다.\n\n시각적 표현:\n\n\n\n- 모듈 등록하기: 이 모듈을 당신의 주 애플리케이션 파일에 등록해야 합니다.\n- MainApplication.java 파일 편집하기:\n\n```js\npackage com.mynativemoduleproject;\n\nimport com.facebook.react.ReactPackage;\nimport com.facebook.react.shell.MainReactPackage;\nimport com.facebook.soloader.SoLoader;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class MainApplication extends Application implements ReactApplication {\n\n    private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {\n        @Override\n        public boolean getUseDeveloperSupport() {\n            return BuildConfig.DEBUG;\n        }\n\n        @Override\n        protected List<ReactPackage> getPackages() {\n            return Arrays.<ReactPackage>asList(\n                new MainReactPackage(),\n                new DeviceInfoPackage()  // 여기에 패키지 등록\n            );\n        }\n\n        @Override\n        protected String getJSMainModuleName() {\n            return \"index\";\n        }\n    };\n\n    @Override\n    public ReactNativeHost getReactNativeHost() {\n        return mReactNativeHost;\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        SoLoader.init(this, /* native exopackage */ false);\n    }\n}\n```\n\niOS 경우:\n\n- Swift 파일 생성하기: Xcode에서 iOS 프로젝트 디렉토리로 이동한 후 MyDeviceInfo.swift라는 새로운 Swift 파일을 생성합니다.\n- Swift 파일 편집하기:\n\n\n\n여기 네이티브 모듈을 위한 Swift 코드가 있어요:\n\n```js\n// MyDeviceInfo.swift\nimport Foundation\nimport UIKit\n\n@objc(MyDeviceInfo)\nclass MyDeviceInfo: NSObject {\n\n  @objc\n  func getDeviceInfo(_ callback: RCTResponseSenderBlock) {\n    callback([nil, [\"device\": UIDevice.current.model, \"OS\": UIDevice.current.systemVersion]])\n  }\n\n  @objc\n  static func requiresMainQueueSetup() -> Bool {\n    return true\n  }\n}\n```\n\n이 코드 스니펫은 안드로이드 버전과 유사한 기능을 제공하여, 디바이스 모델과 OS 버전을 반환해 주는 거예요.\n\n비주얼 표현:\n\n\n\n- 모듈 등록: Bridging-Header.h 파일을 편집하여 Swift 파일이 React Native에서 보이도록 합니다:\n\n```js\n#import \"React/RCTBridgeModule.h\"\n```\n\n- JavaScript에서 네이티브 모듈 사용\n\n이제 JavaScript 코드에서 네이티브 모듈을 사용할 수 있습니다.\n\n\n\n```js\nimport React, { Component } from 'react';\nimport { View, Text, NativeModules } from 'react-native';\n\nconst { DeviceInfo } = NativeModules;\n\nclass App extends Component {\n  state = {\n    deviceInfo: {}\n  };\n\n  componentDidMount() {\n    DeviceInfo.getDeviceInfo((error, info) => {\n      if (error) {\n        console.error(error);\n      } else {\n        this.setState({ deviceInfo: info });\n      }\n    });\n  }\n\n  render() {\n    const { deviceInfo } = this.state;\n    return (\n      <View style={ flex: 1, justifyContent: 'center', alignItems: 'center' }>\n        <Text>기기 모델: {deviceInfo.device}</Text>\n        <Text>OS 버전: {deviceInfo.OS}</Text>\n      </View>\n    );\n  }\n}\n\nexport default App;\n```\n\n이 React 컴포넌트는 네이티브 모듈에서 불러온 기기 정보를 표시합니다.\n\n## 결론\n\nReact Native에서 네이티브 모듈을 생성하는 것은 플랫폼별 코드를 활용하여 앱의 기능을 확장하는 강력한 방법입니다. 이 단계를 따르면 네이티브 기능에 액세스하여 모바일 애플리케이션을 효과적으로 강화할 수 있습니다. 즐거운 코딩하세요!\n\n\n\n\n참고 : https://reactnative.dev/docs/native-modules-android","ogImage":{"url":"/assets/img/2024-05-14-CreatingaNativeModuleinReactNative_0.png"},"coverImage":"/assets/img/2024-05-14-CreatingaNativeModuleinReactNative_0.png","tag":["Tech"],"readingTime":5},{"title":"왜 htmx를 사용해야 할까요","description":"","date":"2024-05-14 11:37","slug":"2024-05-14-Whyhtmx","content":"\n\n![이미지](/assets/img/2024-05-14-Whyhtmx_0.png)\n\nHTMX는 JavaScript 라이브러리로, JavaScript를 작성할 필요 없이 HTML에서 직접 최신 브라우저 기능에 액세스할 수 있게 해줍니다. 이는 HTML 구문을 확장하여 AJAX, 웹소켓 및 서버 전송 이벤트와 같은 기능을 HTML에서 바로 사용할 수 있도록 합니다.\n\n클릭 버튼을 구현하고 싶다면 아마도 아래의 HTML과 JavaScript 코드를 작성해야 할 것입니다.\n\n![이미지](/assets/img/2024-05-14-Whyhtmx_1.png)\n\n\n\nhtmx를 사용하면 간단히 다음을 할 수 있어요:\n\n![Whyhtmx_2.png](/assets/img/2024-05-14-Whyhtmx_2.png)\n\n정말 간단하고 쉬워요.\n\nHTMX에서 hx-swap은 서버 요청으로 반환된 콘텐츠가 요소의 현재 콘텐츠를 대체하는 방법을 결정하는 속성입니다.\n\n\n\n\"hx-swap=\"outerHTML\"\"를 설정하면 해당 요소 전체(오픈 및 클로징 태그 포함)가 서버 응답으로 교체됩니다.\n\n예를 들어, 이 HTMX 코드를 살펴보십시오:\n\n```js\n<div id=\"myDiv\" hx-get=\"/some/url\" hx-swap=\"outerHTML\">Original Content</div>\n```\n\n“/some/url\"로의 요청이 발생하고 서버가 `span`New Content`/span`으로 응답하는 경우, hx-swap=\"outerHTML\"은 서버 응답으로 전체 div 요소를 교체합니다.\n\n\n\n서버에서 응답을 받은 후에, HTML이 다음과 같이 변경됩니다:\n\n```js\n<span>New Content</span>\n```\n\n원본의 `div` 요소와 그 내용(\"Original Content\")은 완전히 새로운 `span` 요소로 대체되었습니다.\n\n## 리액트, 앵귤러, 뷰와 작별인가요?\n\n\n\n백엔드 개발자로서, 위의 프레임워크 중 하나를 배우는 것보다 htmx를 배우는 것이 훨씬 가벼운 일입니다.\n\n다음은 HTMX를 사용할 이유가 있는 몇 가지 이유입니다:\n\n간편함:\n\nHTMX는 HTML을 확장하여 JavaScript를 작성할 필요 없이 마크업에 직접 상호 작용성을 추가할 수 있습니다. 이렇게 하면 코드를 이해하고 유지하기 쉬울 수 있습니다.\n\n\n\n점진적 향상:\nHTMX를 사용하면 필요한 곳에 상호작용성을 추가하면서 전체 프론트엔드 코드를 완전히 다시 작성할 필요가 없이 HTML을 점진적으로 향상시킬 수 있습니다.\n\n서버 측 렌더링:\nHTMX를 사용하면 페이지의 대부분 컨텐츠에 대해 서버 측 렌더링을 활용할 수 있어서 성능과 SEO를 향상시킬 수 있습니다.\n\n\n\n적은 양의 자바스크립트:\n\nHTMX는 SPA 프레임워크보다 적은 양의 자바스크립트를 필요로 하며, 이는 더 빠른 로드 시간과 적은 복잡성으로 이어질 수 있습니다.\n\n기존 프로젝트 통합:\n\nHTMX는 많은 SPA 프레임워크와 달리 완전한 재작성 없이 기존 프로젝트에 쉽게 추가할 수 있습니다.\n\n\n\n하지만 HTMX가 모든 프로젝트에 가장 적합한 선택은 아닐 수 있습니다. React, Angular 및 Vue와 같은 SPA 프레임워크는 더 많은 기능을 제공하며 복잡하고 상태를 가지는 애플리케이션을 구축하기에 더 적합합니다. 최상의 선택은 프로젝트의 구체적인 요구 사항에 따라 다릅니다.\n\n내 경우에는 프로젝트 초기 단계에서 다른 것들보다 HTMX를 시도해 볼 것입니다.","ogImage":{"url":"/assets/img/2024-05-14-Whyhtmx_0.png"},"coverImage":"/assets/img/2024-05-14-Whyhtmx_0.png","tag":["Tech"],"readingTime":2},{"title":"리액트 네이티브의 세계를 탐험하기 쉽게 모바일 애플리케이션 만들기","description":"","date":"2024-05-14 11:36","slug":"2024-05-14-ExploringtheWorldofReactNativeBuildingMobileAppswithEase","content":"\n\n## 타이틀: React Native 세계 탐험: 쉬운 모바일 앱 개발\n\n소개: React Native의 흥미진진한 세계로 오신 것을 환영합니다! 이 블로그 포스트에서는 React Native의 기초를 통해 React Native의 능력, 장점, 그리고 모바일 앱 개발을 혁신하는 방법을 탐험하겠습니다. 경험 많은 개발자든 코딩 여행을 시작한 지 얼마 안 된 분이든, 이 안내서는 React Native의 힘을 활용하는 데 도움이 되는 소중한 통찰을 제공할 것입니다.\n\nReact Native란 무엇인가? React Native는 Facebook이 개발한 오픈 소스 프레임워크로, JavaScript와 React를 사용하여 모바일 애플리케이션을 만드는 데 사용됩니다. iOS 및 Android 플랫폼에 대해 별도의 코드베이스가 필요한 전통적인 모바일 앱 개발과 달리, React Native는 개발자가 코드를 한 번 작성하고 다중 플랫폼에 배포할 수 있게 해줍니다. 이는 개발 프로세스를 간소화하는 데 그치지 않고 일관성과 효율성을 보장해 줍니다.\n\nReact Native의 주요 기능:\n\n\n\n- 크로스 플랫폼 호환성: React Native를 사용하면 개발자들은 iOS 및 Android 플랫폼 모두에서 원활하게 작동하는 단일 코드베이스를 작성할 수 있어 별도의 개발 노력이 필요하지 않습니다.\n- 네이티브 성능: React Native는 JavaScript와 네이티브 컴포넌트 간의 간극을 줄여 최적의 성능과 모바일 앱에 네이티브한 느낌을 제공합니다.\n- 핫 리로딩: React Native의 가장 인기 있는 기능 중 하나인 핫 리로딩을 통해 개발자들은 코드를 수정하면 실시간으로 앱에서 반영되는 변화를 볼 수 있어 개발 프로세스를 빠르게 할 수 있습니다.\n- 재사용 가능한 컴포넌트: React Native는 재사용 가능한 컴포넌트의 사용을 장려하여 모듈식이고 유지 보수 가능한 코드베이스를 구축할 수 있게 합니다.\n- 제3자 라이브러리: React Native 생태계는 다양한 제3자 라이브러리와 플러그인으로 풍부하며 이를 통해 지도, 애니메이션, 푸시 알림과 같은 기능을 앱에 손쉽게 통합할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-14-ExploringtheWorldofReactNativeBuildingMobileAppswithEase_0.png"},"coverImage":"/assets/img/2024-05-14-ExploringtheWorldofReactNativeBuildingMobileAppswithEase_0.png","tag":["Tech"],"readingTime":2},{"title":"다음 JS 어드민 대시보드 템플릿 무료","description":"","date":"2024-05-14 11:34","slug":"2024-05-14-NextJSAdminDashboardTemplateFree","content":"\n\n<img src=\"/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_0.png\" />\n\n# Next JS란 무엇인가요?\n\nNextJS 관리 대시보드 템플릿은 편의성과 견고함으로 큰 인기를 끌고 있습니다. 그리고 개발자로서, 일을 더 쉽게 만들어주는 프레임워크를 찾는 것만큼 멋진 일은 없죠. 개발자로서 업무 흐름을 간소화하고 코드를 더욱 효율적으로 만드는 방법을 찾고 계신다면 정말 좋은 선택일 것입니다. 여기서 Next JS가 등장합니다. 하지만 템플릿을 살펴보기 전에 Next JS 기술에 대해 알아보겠습니다.\n\n더 나아가서, Next.js는 React를 사용하여 서버 측 렌더링 (SSR) 및 정적 웹 응용 프로그램을 구축할 수 있게 해주는 인기 있는 오픈 소스 JavaScript 프레임워크입니다. 자동 코드 분할, 서버 측 렌더링, 동적 가져오기 등의 기능을 제공하여 뛰어난 개발 경험을 제공하며, 성능이 우수하고 확장 가능한 웹 응용 프로그램을 구축하는 데 도움을 줍니다. 또한 Next.js를 사용하면 대량 트래픽을 처리하고 서버 리소스를 효율적으로 활용할 수 있는 웹 응용 프로그램을 만들 수 있습니다.\n\n\n\nNext JS의 다른 장점 중 하나는 디자인 매니저 도구를 사용하여 블로그 템플릿을 사용자 정의할 수 있는 기능이 있습니다. 또한 헤더와 푸터 HTML에 사용자 정의 코드나 스크립트를 추가하고 블로그에 스타일 시트를 첨부할 수도 있습니다. 더불어 서버 측 렌더링을 제공하여 페이지 로드 시간 및 SEO를 개선할 수도 있습니다. 또한 편리한 내비게이션을 위한 통합 라우팅 시스템을 제공하므로 응용 프로그램 내의 다른 페이지 간에 쉽게 이동할 수 있습니다.\n\nNext.js의 또 다른 멋진 기능은 서버리스 함수를 사용하여 서버에서 직접 실행되는 웹 사이트의 일부를 구축할 수 있다는 점입니다. 이를 통해 동적 콘텐츠를 만들고 서버 비용을 줄일 수 있습니다. 각 요청 시 사용된 리소스에 대해서만 지불하면 되기 때문입니다.\n\nNext JS를 선택해야 하는 이유\n\n- Next.js는 서버 측 렌더링, 자동 코드 분할 및 쉬운 구성을 제공하는 인기 있는 React 프레임워크입니다.\n- 개발자들이 쉽고 빠르게 확장 가능한 웹 애플리케이션을 구축할 수 있도록 지원하며 우수한 SEO 기능을 제공합니다.\n- 템플릿은 핫 리로딩과 빠른 새로고침을 기본적으로 지원하여 개발자 경험을 향상시킵니다.\n- 많은 특징과 플러그인이 함께 제공되어 웹 애플리케이션을 더 쉽고 효율적으로 구축할 수 있습니다.\n- Netflix, Uber, Hulu 등 인기있는 회사들이 사용하는 만큼 확장성과 신뢰성에 대한 확증입니다.\n\n\n\n# NextJS 템플릿\n\n개발자들은 다양한 Next.js 대시보드 템플릿을 활용하여 완전히 기능이 구현된 Production-Ready 대시보드를 작성하는 개발 프로세스를 가속화할 수 있습니다. 이러한 템플릿은 일반적으로 사용자 관리, 데이터 시각화 및 인증과 같은 표준 대시보드 기능을 지원하는 미리 구축된 레이아웃과 구성 요소를 포함하고 있습니다.\n\n개발자 사이에 인기있는 Next.js 대시보드 템플릿으로는 Dash UI, salvia-kit, chris-trapstar, Modernize, CoreUI PRO, Tokyo Free White 등이 있습니다. 따라서 우리는 다음 섹션에서 모든 NextJS 관리자 대시보드 템플릿을 자세히 살펴볼 것입니다. 이러한 대시보드 템플릿을 활용하면 개발자들은 개발 시간을 절약하고 앱의 독특한 기능을 구축하는 것을 우선시할 수 있습니다.\n\n# Dash UI — NextJS 관리자 템플릿\n\n\n\nDash UI는 무료이며 다양한 기능을 제공하는 Next.js 기반 관리 대시보드 템플릿입니다. 이는 웹 애플리케이션에 쉽게 통합될 수 있는 모바일 우선 responsiv 레이아웃을 포함하고 있으며 카드, 테이블, 인증 양식과 같은 사전 구축된 UI 구성요소가 포함되어 있습니다.\n\n![다운로드](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_1.png)\n\n또한, Dash UI NextJS Admin Dashboard Template은 다음 프로젝트용 웹 앱과 페이지를 구축하는 데 좋은 선택일 수 있습니다. 이 개발자 친화적이고 매우 사용자 정의 가능한 템플릿은 프로세스를 더 쉽게 만들어주고 필요한 대로 정확히 만들 수 있도록 도와줄 수 있습니다.\n\n- 적절히 문서화됨\n- 프로필, 청구, 404 등 9개 이상의 페이지\n- 회원가입 및 로그인과 같은 인증 페이지\n- 댓글 기능\n- 대부분의 브라우저와 호환됨\n- Github에서 이용 가능\n\n\n\n테이블 태그를 마크다운 형식으로 변경하면 다음과 같습니다.\n\n| Preview |\n|--------|\n| Download |\n\nNext.js로 전문적이고 효율적인 웹 애플리케이션을 만들고 싶으신가요? 그렇다면 Starter NextJS Admin 대시보드 템플릿을 확인해 보세요.\n\n# 시작하기: NextJS Admin 템플릿\n\n\n\n---  \n![template image](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_2.png)\n\n이 템플릿은 현대적이고 효율적인 웹 애플리케이션을 구축하려는 사람들에게 우수한 선택지입니다. 또한 현대적인 디자인, 확장성 및 성능 최적화로 그 어떤 것과도 차별화됩니다. 이 템플릿은 당신의 웹 애플리케이션을 다음 수준으로 이끌 수 있는 힘을 가지고 있습니다.\n\n- 고도로 확장 가능\n- 차트 및 그래프, 폼 입력, 테이블 등 구성 요소 사용 가능\n- 최적화 및 사용자 정의\n\n미리보기\n\n\n\n다운로드\n\n# Tokyo Free White — NextJS Admin Template\n\n이 관리자 대시보드 템플릿은 가장 최신 버전의 Next.js를 사용합니다. 또한 암호화폐를 모티브로한 대시보드이며, 모든 노드 종속성이 최신 상태이며, 미래의 버전에서도 그대로 유지될 것입니다. 더불어, 이 템플릿은 현대적인 파란색 강조 색상을 사용하여 UI 구성 요소 프레임워크인 MUI(Material-UI)와 완벽하게 조화를 이룹니다.\n\n![이미지](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_3.png)\n\n\n\n더불어, Next JS 관리 대시보드는 오픈 소스이며 꼭 당신의 엔드 투 엔드 개발 프로세스를 지원할 것입니다. 개발자들에 의해 쉽게 수정될 수 있는 전체적인 외관을 가지고 있습니다.\n\n- 웹 앱을 위한 다양한 페이지 제공\n- 무료 오픈 소스\n- 공통 컴포넌트 제공\n- 메신저 페이지\n\n미리보기\n\n다운로드\n\n\n\n# Materio — 무료 MUI React NextJS Admin 템플릿\n\n이것은 개발자를 위해 특별히 만들어진 상세하고 결과 중심적인 Next JS 관리자 대시보드입니다. 따라서 다음 프로젝트를 위한 세련되고 현대적인 관리자 템플릿을 찾고 있다면 Materio를 무료로 이용할 수 있습니다. \n\n![이미지](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_4.png)\n\n이 템플릿은 다양한 기능으로 가득 차 있으며 완전히 반응형이므로 모든 프로젝트에 적합한 좋은 선택입니다. 그리고 가장 좋은 점은 무료로 사용할 수 있다는 것입니다. 맞습니다 — 지출하지 않고도 모든 기능을 활용할 수 있습니다. Materio의 특징 중 하나는 MUI (Material-UI) 프레임워크의 사용입니다. 이를 통해 템플릿 전체에서 일관된 통합된 디자인을 구현할 수 있어 사용하기 쉬우며 탐색하기 쉽습니다.\n\n\n\n- The Next JS 관리자 대시보드에는 사용자 정의 페이지와 컴포넌트가 포함되어 있어요.\n- 사용자 목록, 사용자 보기, 이메일, 채팅, 캘린더, 송장 및 역할 및 권한과 같은 애플리케이션을 받아보세요.\n- 빠른 검색 및 탐색\n- 3개의 차트 라이브러리\n\n미리 보기\n\n다운로드\n\n# CoreUI Pro NextJS Admin Template\n\n\n\nNextJS 관리자 템플릿은 당신이 비즈니스를 관리하고 직원을 관리하며 워크플로우를 손쉽게 최적화할 수 있도록 도와주는 현대적인 템플릿입니다.\n\n![NextJS Admin Template](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_5.png)\n\n게다가 Core UI Pro NextJS Admin 대시보드 템플릿은 반응형 디자인으로 모든 기기에서 멋지게 보이는 다양한 커스터마이즈 가능한 UI 구성 요소 및 직관적인 사용자 인터페이스를 제공하여 내비게이션을 쉽게 할 수 있습니다.\n\n하지만 이 관리자 템플릿을 독특하게 만드는 것은 놀라운 유연성입니다. 프로젝트를 관리하거나 데이터를 추적하며 비즈니스 성과를 모니터링하는 경우 Core UI Pro는 작업을 완료하기 위한 도구를 제공합니다. 간단한 대시보드부터 복잡한 워크플로까지, 이 템플릿은 모두 해낼 수 있습니다.\n\n\n\n- Next.js 13, Bootstrap 5 및 React 18을 따릅니다.\n- 반응형입니다.\n- 다이나믹한 Bootstrap 기반 테마\n- 완벽히 사용자 정의 가능합니다.\n- Dark 및 Light와 같은 다양한 테마\n\n미리보기\n\n다운로드\n\n# NextJS 관리자 템플릿을 현대화하세요\n\n\n\n복잡하고 혼란스러운 관리자 대시보드를 만들 때 몇 시간을 보내는 데 지쳤나요? 그렇다면 Modernize의 Next JS 관리자 대시보드 템플릿을 확인해보는 것이 시간이길래요.\n\n![이미지](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_6.png)\n\nModernize는 직관적이고 사용자 친화적이며 정확한 필요에 맞게 사용자 정의할 수 있는 템플릿을 디자인했어요. 세련된 디자인과 미리 디자인된 구성 요소가 담긴 이 템플릿은 모양도 아름답고 기능적인 대시보드를 쉽게 만들 수 있게 해줘요.\n\n더욱이, 이 템플릿의 가장 좋은 점은 인기 있는 React 프레임워크인 Next JS로 제작되었다는 것이에요. 따라서 데이터 시각화 및 분석 도구와 같은 필요한 React 라이브러리 및 기능을 쉽게 통합할 수 있다는 뜻이에요.\n\n\n\n또한 사용하기 쉬운 인터페이스와 반응형 디자인으로, Modernize Next JS 관리자 대시보드 템플릿은 업무 프로세스를 간소화하고 생산성을 향상시킬 수 있습니다. 그러므로 더 이상 복잡한 코드를 이해하거나 작업을 느리게 만드는 다소 불편한 대시보드에 시달리지 않아도 됩니다.\n\n- 완전히 사용자 정의 가능한 구성 요소: Next JS, React 및 다른 라이브러리를 사용하여 템플릿 내의 모든 구성 요소를 사용자 정의할 수 있습니다.\n- 반응형 디자인: 데스크톱, 태블릿 또는 모바일에서 언제든지 부드러운 경험을 누릴 수 있습니다.\n- 다크 모드: 몇 번의 클릭만으로 다크 모드 테마로 전환할 수 있습니다.\n- 다양한 레이아웃: 여러 레이아웃 중에서 대시보드에 가장 적합한 것을 선택할 수 있습니다.\n- 검증된 기술: 신뢰할 수 있는 인기 있는 기술로 구축되어 신뢰성, 확장성 및 보안을 보장합니다.\n\n미리보기\n\n다운로드\n\n\n\n# Windmill-Next JS 관리 대시보드\n\n강력하고 신뢰할 수 있으며 견고한 Next JS 관리 대시보드 템플릿입니다. 동적 기능으로 응용 프로그램에 전원을 공급합니다. 이 직관적이고 사용자 친화적인 대시보드는 비즈니스가 데이터 및 지표를 추적하는 데 명확하고 사용하기 쉬운 플랫폼을 제공하여 운영을 최적화하도록 설계되었습니다.\n\n![대시보드 이미지](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_7.png)\n\n이 대시보드의 뛰어난 점 중 하나는 쉬운 사용자 정의 기능입니다. 간단한 코딩 수정으로 사용자는 대시보드에서 색상, 글꼴 및 아이콘을 자사의 고유한 브랜드 아이덴티티에 맞게 조정할 수 있습니다. 결과적으로 기능적이면서 시각적으로 매력적인 대시보드를 찾는 비즈니스 또는 개인에게 우수한 선택지가 됩니다.\n\n\n\n위트있는 톤으로 한국어로 번역해 드리겠습니다.\n\n\"맞춤 설정 옵션 외에도, 윈드밀 대시보드 프로젝트는 어떤 대시보드에도 쉽게 통합할 수 있는 다양한 컴포넌트를 제공합니다. 또한, 드롭다운 메뉴와 탭부터 모달창과 테이블까지 모든 요소를 포괄하여 대답할 수 있습니다. 이로 인해 매우 다재다능하며 어떤 대시보드에도 적응할 수 있습니다.\n\n- 자세한 접근성\n- 다크 테마\n- 다양한 개발 컴포넌트\n- 코드 분할 기능\n\n미리보기\n\n다운로드\"\n\n\n\n# Salvia-Kit’s: Next JS Admin 대시보드 템플릿\n\nSalvia-kit의 대시보드는 강력하고 효율적인 프레임워크 인 Next JS에서 구축되어 빠른 성능과 원활한 탐색을 보장합니다.\n\n![대시보드 이미지](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_8.png)\n\n이 대시보드는 사용자 친화적이며 시각적으로 매력적입니다. 직관적인 인터페이스로 원하는 기능을 쉽게 찾아 액세스할 수 있어 소중한 시간을 절약하고 생산성을 향상시킵니다. 또한 NextJS admin 대시보드 템플릿은 매우 사용자 정의가 가능하여 개인적인 요구에 맞게 수정할 수 있습니다. 여러 가지 다른 색상 구성표와 레이아웃을 선택하거나 위젯을 추가하거나 삭제할 수도 있습니다.\n\n\n\n또한 Salvia-kit 대시보드의 뛰어난 기능 중 하나는 실시간 데이터 시각화입니다. 또한, 실시간으로 업데이트되는 동적 차트와 그래프를 통해 웹사이트의 트래픽, 매출 및 기타 주요 지표를 손쉽게 추적할 수 있습니다.\n\n- 활성화된 경로 지원\n- 상세한 사용자 정의\n- 공급 업체 잠금 없음\n- 선호에 따른 좌우 네비게이션\n\n미리보기\n\n다운로드\n\n\n\n# Salvia-kit/dashboard-v6\n\nSalvia-kit 관리자 대시보드 템플릿은 6번째 버전에서 Next.js의 진보된 사용으로 다음 수준으로 나아갑니다. 이 인기있고 강력한 프레임워크는 빠른 개발 능력, 사용 편의성 및 성능 최적화 기능으로 알려져 있습니다.\n\n![Salvia-kit](/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_9.png)\n\n또한 Salvia-kit 대시보드에 Next.js를 사용하는 가장 중요한 이점 중 하나는 복잡한 데이터 세트를 쉽게 관리하고 조직화할 수 있는 것입니다. 이 새 버전을 통해 사용자는 특정 요구 사항에 맞는 사용자 정의 데이터 시각화 및 인터랙티브 구성 요소를 유연하게 생성할 수 있습니다. 게다가 Next.js의 모듈식 설계는 컴포넌트를 이전보다 더 빠르게 구축하고 배포할 수 있습니다.\n\n\n\n- 브라우저 호환성\n- 여러 개의 웹 페이지\n- 자세한 사용자 정의\n\n미리보기\n\n다운로드","ogImage":{"url":"/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_0.png"},"coverImage":"/assets/img/2024-05-14-NextJSAdminDashboardTemplateFree_0.png","tag":["Tech"],"readingTime":8},{"title":"리액트 JS에서 Font Awesome 아이콘 사용하기","description":"","date":"2024-05-14 11:33","slug":"2024-05-14-conesdoFontAwesomenoReactJS","content":"\n\nReact JS에서 Font Awesome 아이콘을 사용하는 방법:\n\n![Font Awesome](/assets/img/2024-05-14-conesdoFontAwesomenoReactJS_0.png)\n\n- SVG Core 설치하기 (아이콘이 작동하는 유틸리티가 포함 된 패키지):\nnpm i — save @fortawesome/fontawesome-svg-core\n- 사용할 키트 패키지 설치. 참고: Font Awesome의 무료 패키지는 다음과 같습니다:\nnpm i — save @fortawesome/free-solid-svg-icons\nnpm i — save @fortawesome/free-regular-svg-icons\nnpm i — save @fortawesome/free-brands-svg-icons\n- Font Awesome 컴포넌트 설치하기:\nnpm i — save @fortawesome/react-fontawesome@latest\n\n- Font Awesome 컴포넌트와 사용할 아이콘들을 import 하기:\nimport 'FontAwesomeIcon' from ‘@fortawesome/react-fontawesome’;\nimport 'icon1, icon2' from ‘@fortawesome/kit that contains the icon’;\n\n\n\n예시:\nimport ' faHtml5, faCss3Alt ' from ‘@fortawesome/free-brands-svg-icons’;\n\n- 프로젝트에 아이콘 삽입:\n`FontAwesomeIcon icon=' 아이콘 ' /`\n\n예시:\n`FontAwesomeIcon icon='faHtml5' /`\n`FontAwesomeIcon icon='faCss3Alt' /`\n\nFont Awesome 문서:","ogImage":{"url":"/assets/img/2024-05-14-conesdoFontAwesomenoReactJS_0.png"},"coverImage":"/assets/img/2024-05-14-conesdoFontAwesomenoReactJS_0.png","tag":["Tech"],"readingTime":1},{"title":"리액트 Context와 useState 함께 사용하는 방법","description":"","date":"2024-05-14 11:32","slug":"2024-05-14-HowtouseReactContextwithuseState","content":"\n\n래엑트 앱에서 props를 도대체 어디서 사용해야 하는지 지친 적이 있나요? Redux에 대한 대안을 찾고 계신가요? 자식 컴포넌트가 props를 사용하지 않고 계속해서 전달하고 있나요? 더 나은 방법이 여기 있어요!\n\n![이미지](/assets/img/2024-05-14-HowtouseReactContextwithuseState_0.png)\n\n필수 요구 사항: props, state, 컴포넌트 및 훅에 대한 기본적인 React 지식이 필요합니다. 더불어 TypeScript 지식도 약간 필요합니다. 이 예시에서는 함수형 컴포넌트를 사용할 것입니다. (그리고 제 동료 요한네스가 쓴 React 컴포넌트 작성을 위한 고려 사항 기사도 확인해보세요)\n\n## 개요\n\n\n\n1. 문제와 Context 사용 시기\n2. 쉬운 구현과 기본 사항\n3. 더 현실적인 예제\n4. 고려할 사항\n\n# 1. 문제와 Context 사용 시기\n\nContext를 사용하는 가장 흔한 문제 또는 고려 사항 중 하나는 prop drilling 문제입니다. 이 문제를 설명하기 위해 음식 주문 앱을 예시로 사용하겠습니다. 새롭고 멋진 음식 주문 앱을 작성했다고 상상해보세요. 앱에는 리스트에 표시하고 싶은 음식 항목이 있습니다. 각 음식 항목에는 쇼핑 카트에 항목을 추가할 수 있는 카운터가 있습니다. 주문하기 전에 음식의 양을 보여주는 쇼핑 카트 컴포넌트를 작성했다고 가정해 보겠습니다. 이 앱의 컴포넌트 트리는 다음과 유사할 수 있습니다:\n\n![그림](/assets/img/2024-05-14-HowtouseReactContextwithuseState_1.png)\n\n\n\n음식 항목의 현재 개수를 추적하는 방법을 간단히 보여주는 코드 예제가 있어요. 계수 상태는 FoodCounter 및 FoodSummary 구성 요소에 필요하기 때문에 트리 상단에 있어요.\n\n우리는 상태를 전체 트리를 통해 prop으로 전달하고 있는 것을 알 수 있어요. FoodItem 구성 요소에서는 심지어 상태가 필요하지 않을 수도 있지만, 우리는 단지 FoodCounter 구성 요소에 전달하기 위해 prop을 전달하고 있어요. 이것이 프롭 드릴링 문제에 관한 것이죠. (코드 예제에 표시되어 있지 않은 ShoppingCart 및 FoodSummary 구성 요소에서도 비슷한 일이 발생할 수 있어요)\n\n이렇게 하면 구성 요소가 혼잡해지고, 다른 사람이 코드를 읽는 데 어려워질 수 있어요. 특히 여러 속성을 전달하기 시작하면 더 나빠질 수도 있어요. 그러나 우리가 원하는 것은 구성 요소를 깔끔하게 유지하고 실제 필요한 곳에만 상태를 갖도록 하는 것이에요. 이때 React Context가 도움을 줄 거예요.\n\n# 2. 쉬운 구현으로 기초를 익히기\n\n\n\n자, 이 예제를 조금 더 자세히 살펴볼게요. 모든 구성 요소를 'Component'로 이름을 변경해서 우리가 중점을 두어야 할 중요한 부분, 즉 Context를 구축하는 작업에 집중하도록 할 거에요. 우리는 Context, Context Provider 및 Context Consumer를 생성하여 상태를 다르게 관리할 거에요.\n\n## 세 가지 주요 구성 요소\n\n![이미지](/assets/img/2024-05-14-HowtouseReactContextwithuseState_2.png)\n\n위 이미지에서 보다 싶이, 세 가지 주요 구성 요소는 Context, Provider 및 Consumer이기 때문에 우리는 다음을 해야해요:\n\n\n\n- 컨텍스트 생성하기\n- 부모 컴포넌트를 Provider로 감싸기\n- 컨텍스트 사용하기\n\n### 1. 컨텍스트 생성하기\n\n코드 예시에서 보는 것처럼 React에서 컨텍스트를 생성하는 것은 정말 쉽습니다. createContext 함수를 호출하기만 하면 됩니다. 선택적으로 기본값을 전달할 수 있습니다. 이 경우에는 \"defaultValue\"라는 문자열을 전달했습니다.\n\n### 2. 부모 컴포넌트를 Provider로 감싸기\n\n\n\n부모 컴포넌트에서는 반환하는 요소들을 우리의 Context로 감쌀 수 있습니다. 구체적으로, MyContext의 Provider 속성으로 MyParentComponent를 감싸고 있습니다. 이는 우리가 React에서 Context를 생성한 후에 얻는 기본 속성입니다. 다른 파일에서 Context를 생성했다면 쉽게 여기에서 불러와서 사용할 수 있습니다. 예제에서 보시다시피 Provider는 React에서 일반 컴포넌트처럼 사용할 수 있습니다.\n\n게다가, Context Provider 컴포넌트에는 value 속성이 함께 제공됩니다. 우리는 이를 사용하여 마음에 드는 어떤 값을 전달할 수 있습니다. 이 경우 \"My Context Value\" 문자열을 만들어서 Context Provider에 전달해 보겠습니다.\n\n## 3. Context를 사용하고 값을 활용하기\n\nMyComponent 내부나 트리 아래의 다른 자식 컴포넌트에서 이를 사용할 수 있습니다:\n\n\n\n그래서 이제 우리는 MyComponent에서 또는 그 하위 컴포넌트 중 어디에서든 Context를 직접 사용할 수 있습니다. Context를 사용하려면 useContext 훅을 호출하고 Context(MyContext)를 인수로 전달하면 됩니다. 이렇게 하면 Provider에서 제공한 값을 얻을 수 있습니다. 이름이 어디에서 유래했는지 이제 아시겠죠 😉\n\n값을 얻으면 다른 종류의 프롭(prop)이나 상태 변수와 마찬가지로 사용할 수 있습니다. 여기서는 그 값을 단락 안에 반환하기만 합니다.\n\n## 중요: React가 어떻게 해당 값 사용 여부를 알 수 있을까요?\n\n# 3. 좀 더 현실적인 예제\n\n\n\n첫 번째 예는 React Context 개념을 설명하기 위해 범용적이고 최소한의 내용이었습니다. 이제 실제 응용 프로그램에서 찾을 수있는 것과 훨씬 가까운 예제를 살펴볼 것입니다. 예를 들어, 사용자가 앱에서 가입하는 온보딩 또는 등록 흐름을 사용할 것입니다.\n\n이 예제에서 TypeScript를 사용할 것입니다. 또한 useState 훅을 사용할 Provider 컴포넌트를 직접 만들 것입니다. 온보딩 흐름에는 여러 단계가 있어 각 단계 간에 데이터를 공유하고 요약 화면에 데이터를 표시하려는 경우를 상상해보세요. 모든 데이터를 props로 전달하고 싶지 않기 때문에 OnboardingContext를 사용할 것입니다.\n\n우선, 사용자 이름 상태와 사용자 이름 상태를 업데이트하는 setUsername 액션을 가진 Context를 위한 인터페이스를 생성합니다. 여기에서는 단순화를 위해 사용자 이름만 사용합니다. 물론 메일 주소나 사용자의 생일과 같은 속성을 추가할 수 있습니다.\n\n이후에 이전과 같이 Context를 생성하며, 이는 OnboardingContextValue 또는 undefined 유형이 될 수 있습니다. 기본값으로 undefined를 전달합니다. 이제 사용자 정의 Provider 컴포넌트를 만들어봅시다.\n\n\n\n여기서는 평소처럼 useState 훅을 호출하고 사용자 이름과 setUsername 함수를 언팩합니다. 그런 다음 모든 하위 구성 요소를 사용하여 우리의 온보딩 컨텍스트 프로바이더를 반환합니다. 값으로는 사용자 이름과 setUsername 함수만 전달합니다. 물론, 이 시점에서 더 많은 상태를 추가하고 값을 프로바이더에 전달할 수도 있습니다. 아마도 이미 우리가 컨텍스트 생성 시 기본 값으로 undefined를 전달한 이유에 궁금증을 품었을 수도 있습니다. 여기에 그 답이 있습니다:\n\n컨텍스트가 생성되고 일치하는 프로바이더를 찾지 못할 때 undefined가 기본 값으로 사용됩니다. 이는 우리에게 에러를 throw해줍니다. 실제로 이 에러가 발생하길 원합니다. 왜냐하면 우리는 컨텍스트에서 기본 값을 사용하고 싶지 않기 때문입니다. 우리는 커스텀 프로바이더 컴포넌트에서 정의한 상태를 사용하려고 합니다. 그러나 온보딩 컨텍스트가 undefined인 경우 부모 컴포넌트를 커스텀 프로바이더로 감싸놓지 않았을 수도 있습니다.\n\n이 문제를 해결하기 위해 부모 컴포넌트를 커스텀 프로바이더로 감싸놓습니다:\n\n상태 값들을 사용하려면 하위 구성 요소 중 하나에서 커스텀 훅을 사용할 수 있습니다. 그냥 사용자 이름과 setUsername 함수를 언팩하면 됩니다. 이제 이들을 다른 상태 값이나 상태 액션처럼 사용할 수 있습니다. 마치 이 컴포넌트에서 useState 훅을 직접 사용했을 때와 유사합니다. 이렇게 하면 단일 컴포넌트에서 상태를 컨텍스트로 쉽게 옮기는 것도 가능합니다.\n\n\n\n# 4. 고려해야 할 사항\n\n코드베이스에 Context를 도입하기 전에 고려해야 할 몇 가지 사항이 있습니다. 먼저, 데이터에 대해 고민해야 합니다. 컴포넌트에 어떤 데이터가 필요한가요? 그리고 이 데이터가 정확히 어디에 필요한가요? 이를 통해 일반적으로 전체 응용 프로그램을 더 잘 이해할 수 있습니다. 이는 또한 어떤 데이터가 어울리는지, 그리고 데이터가 정말 공유 Context에 있어야 하는지에 대한것도 포함합니다.\n\n이후, 다음 질문을 통해 계속할 수 있습니다. \"현재 사용 중인 상태는 무엇인가요?\" 여전히 이러한 상태가 필요할 수 있지만, 이를 Context로 옮길 수도 있습니다. 어떤 상태를 Context에 넣고 싶은지 스스로에게 묻고, 그 상태가 단 하나의 컴포넌트에만 필요하기 때문에 Context에 필요하지 않은 상태도 파악해야 합니다. 또한 상태를 어떻게 변경하는지도 고민해보세요. set state 함수를 Context로 이동할 수 있지만, 사용자 지정 처리기까지 이동하는 등 더 나아간 방향으로 진행할 수도 있습니다.\n\n마지막으로, prop drilling이 정말 큰 문제인지 스스로에게 물어보아야 합니다. Context를 생성하면 특정한 오버헤드가 발생합니다. 이는 응용 프로그램을 변경하거나 리팩토링하는 데 어렵게 만들 수 있습니다. 예를 들어, Context는 컴포넌트를 테스트하기 어렵게 만들 수 있습니다. 컴포넌트에 모킹된 props를 전달하는 것이 Context로 컴포넌트를 감싼 사용자 지정 테스트 렌더 함수를 작성하는 것보다 쉽습니다. Context의 오버헤드가 props를 전달하는 작은 번거로움만큼 가치가 있는지 스스로에게 물어보세요.\n\n\n\n컨텍스트를 사용하면 컴포넌트 간 데이터 흐름을 이해하기 어려울 수 있어요. 하지만 프롭스를 사용하면 어떤 데이터가 컴포넌트로 들어오고 나가는지 항상 명확하게 알 수 있어요. 컨텍스트를 사용하면 실제 데이터가 어디에서 오는지 찾기 위해 조사를 먼저 해야할 수도 있어요.\n\n## 요약하자면\n\n우리가 하는 일을 좋아하시나요? 함께 하고 싶으신가요? 저희의 최신 채용정보를 확인해보세요: https://www.comsystoreply.com/career\n\n이 블로그 포스트는 Comsysto Reply GmbH에서 발행되었습니다.","ogImage":{"url":"/assets/img/2024-05-14-HowtouseReactContextwithuseState_0.png"},"coverImage":"/assets/img/2024-05-14-HowtouseReactContextwithuseState_0.png","tag":["Tech"],"readingTime":6},{"title":"React Server Components와 NextJS Best Practices, 팁","description":"","date":"2024-05-14 11:30","slug":"2024-05-14-ReactServerComponentswithNextJSBestPracticesTips","content":"\n\nReact Server Components (RSCs)는 React 애플리케이션의 서버 측 렌더링(SSR)에 대한 생각 방식을 변경할 것으로 약속합니다. 이 개념은 개발자 커뮤니티 내에서 긍정적인 관심을 불러일으켰어요. Next.js가 이제 RSCs를 지원함에 따라, 개발자들은 전통적인 싱글 페이지 애플리케이션에 일반적으로 연관된 복잡성 없이 SSR을 받아들일 수 있게 되었습니다. 그러나, 새로운 프레임워크나 기술에는 항상 개발자가 알아야 할 도전과 함정이 따르게 됩니다.\n이 가이드는 NextJS와 함께 RSCs를 탐험하려는 프론트엔드 개발자를 대상으로 합니다.\n\n## 서버 측 렌더링에 대한 간단한 소개:\n\n서버 측 렌더링은 자바스크립트 코드를 실행하고, 서버 측에서 웹 페이지의 초기 HTML을 생성한 후, 완전히 렌더링된 페이지가 브라우저로 전달됩니다.\n\n이 방식에는 몇 가지 장점이 있습니다:\n\n\n\n- SEO 순위 향상: 검색 엔진이 이미 HTML로 렌더링된 페이지 컨텐츠를 쉽게 색인화할 수 있습니다.\n- 빠른 성능: 브라우저가 서버로부터 HTML을 받자마자 페이지 컨텐츠의 렌더링을 시작할 수 있습니다. 이는 인지되는 성능을 최적화합니다.\n- 접근성: JavaScript를 비활성화한 사용자도 페이지 컨텐츠를 볼 수 있습니다.\n\n전통적인 클라이언트 렌더링:\n\n![이미지](/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_0.png)\n\n서버 측 렌더링:\n\n\n\n\n![React Server Components with Next.js Best Practices and Tips](/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_1.png)\n\nRSC와 함께 사용할 때 고려해야 할 몇 가지 최상의 실천 방안을 살펴보겠습니다.\n\n## 서버-클라이언트 경계 이동하기:\n\nNextJS 13+에서는 기본적으로 트래디셔널 페이지 라우터 대신 App 라우터를 제공합니다. 이 경계를 이해하는 것은 효과적인 컴포넌트 관리에 중요합니다. App 라우터를 사용하면 우리가 생성하는 모든 컴포넌트는 클라이언트로 명시되지 않는 한 서버 컴포넌트로 간주됩니다.\nhttps://nextjs.org/docs/app/building-your-application/routing\n\n\n\n\n지금 '서버 클라이언트 경계'가 뭔가요?\n\n이것은 NextJS의 서버 및 클라이언트 구성 요소 사이의 가상의 경계입니다. 서버 구성 요소는 엄격히 서버 측에서 처리되어 클라이언트 번들의 일부로 다운로드되지 않습니다.\n\n이 경계는 어떻게 정의되나요?\n\n이전에 설명했듯이, App 라우터의 모든 구성 요소는 기본적으로 서버 구성 요소이며 클라이언트로 지정되지 않는 한입니다.\n\n\n\n그래서, 클라이언트 구성 요소를 지정하는 방법은 무엇인가요?\n\n클라이언트 번들의 일부로 구성 요소가 해석되도록 하려면 JavaScript/TypeScript 파일의 맨 위에 'use client'를 언급해야 합니다.\n\n![이미지](/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_2.png)\n\n서버 측으로 이동할 컴포넌트와 클라이언트 측으로 이동할 컴포넌트를 선택하는 방법:\n\n\n\n서버 구성 요소 (데이터 가져오기): 서버 구성 요소를 루트 구성 요소로 설정하는 것이 좋습니다. 루트 구성 요소는 모든 클라이언트 구성 요소를 감싸야 합니다. 이 구성 요소의 목적은 API 호출을 수행하고 내부 구성 요소를 위한 래퍼 HTML을 생성하는 것입니다. 서버 구성 요소의 장점 중 하나는 민감한 데이터(인증/로그인 정보)를 처리하는 데 사용할 수 있다는 것입니다.\n\n클라이언트 구성 요소 (상호작용): 상호작용이 많은 하위 구성 요소로 설정해야 합니다. 이 구성 요소들은 훅 같은 기능을 사용할 필요가 있습니다. Redux와 같은 상태 관리 도구는 클라이언트 구성 요소에서만 사용할 수 있습니다. 이들은 부모 구성 요소로부터 데이터를 prop drilling을 통해 전달받을 수 있습니다.\n\n## 우선 순위에 따른 사전 렌더링:\n\n사전 렌더링은 NextJS의 가장 강력한 기능 중 하나입니다. 브라우저가 웹페이지를 요청할 때 NextJS는 클라이언트 및 서버 구성 요소를 사용하여 사전 렌더링된 HTML을 생성합니다. 이는 백그라운드에서 NextJS/React가 상호작용을 위해 구성 요소를 업데이트하는 동안 초기 페이지 콘텐츠를 빠르게 전달하는 데 도움이 됩니다.\n그렇다면 '우선 순위에 따른 사전 렌더링'이란 무엇을 의미할까요?\nNextJS는 초기 페이지 로드 시 고객에게 표시되는 부분과 그렇지 않은 부분을 모두 사전 렌더링합니다. 이는 느린 네트워크에서 로드할 때 FCP (첫 콘텐츠 렌더링) 지연이 몇 초까지 발생할 수 있습니다.\n예를 들어 드롭다운을 개발 중이라고 가정해 봅시다. 일반적으로 초기 페이지 로드 시 드롭다운 제목만 표시되고 실제 콘텐츠는 마우스를 가져가면 활성화됩니다. 따라서 이상적으로는 컴포넌트를 분할하고 요청 시 부분을 동적으로 로드해야 합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_3.png)\n\n페이지 전체에 최적화되면 웹페이지의 FCP(첫 번째 콘텐츠 표시)가 줄어들고 페이지가 더 빠르게 렌더링됩니다.\n\n## 동적/레이지 로딩:\n\n위 주제를 더 확장하기 위해 웹페이지 전체에 대한 리액트 컴포넌트의 레이지 로딩 또는 동적 로딩으로 많은 최적화를 수행할 수 있습니다. 모든 것을 사전 렌더링할 필요는 없습니다.\n'react.lazy' 또는 Next/dynamic과 함께 동적 임포트를 사용할 수 있습니다.\n\n\n\n리액트.lazy는 좋지만 클라이언트 측에서 컴포넌트를 렌더링하지 않는 옵션을 제공하지 않습니다. 컴포넌트를 가져올 때 'ssr: false' 플래그를 사용하여 서버 측에서 렌더링되지 않도록 할 수 있습니다.\n\n## 서버 컴포넌트와 CSS:\n\n서버 컴포넌트는 발전 중이지만 몇 가지 제한 사항이 여전히 존재합니다. 서버 컴포넌트로 HTML을 렌더링할 수 있지만, 기기별로 지나치게 구체적이거나 CSS가 많이 사용된 컴포넌트는 피하는 것이 좋습니다. 오직 드문드문한 HTML/CSS만 남기는 주요 이유 중 하나는 서버가 웹 페이지를 요청하는 기기를 모르기 때문에 기기별 HTML 블록을 렌더링하는 것을 방지하기 때문입니다.\n\n모든 최상의 실천 방법을 모두 포함하지는 않겠지만 RSCs를 시작하는 데 도움이 되리라 생각됩니다.","ogImage":{"url":"/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_0.png"},"coverImage":"/assets/img/2024-05-14-ReactServerComponentswithNextJSBestPracticesTips_0.png","tag":["Tech"],"readingTime":4},{"title":"Vite와 함께 React 컴포넌트 라이브러리 만들기 그리고 NPM에 배포하기","description":"","date":"2024-05-14 11:28","slug":"2024-05-14-ReactComponentLibrarywithViteandDeployinNPM","content":"\n\n![ReactComponentTutorial](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_0.png)\n\n안녕하세요! 이 튜토리얼은 React 및 Vite를 사용하여 TypeScript 템플릿으로 React 컴포넌트를 빌드하고, 그것을 NPM에 게시하는 방법을 안내하기 위해 만들어졌어요. 이 빌드 패키지는 다른 React 애플리케이션에서도 재사용할 수 있어요. 저희는 빌드 도구 및 로컬 개발 환경으로 Vite를 사용할 거예요. 로컬 개발 환경으로 storybook을 사용할 수도 있지만, 간단함을 위해 vite를 사용할 거에요.\n\n# 준비물\n\n- Git이 설치되어 있어야 해요.\n- NodeJs와 NPM이 설치되어 있어야 해요.\n- NPM 계정이 있어야 해요. 계정이 없다면, NPM 계정을 만들어 주세요.\n\n\n\n# 초기 설정 및 컴포넌트 라이브러리 생성\n\n## 단계 1: Vite를 사용하여 React 프로젝트 생성하기\n\nVite를 사용하여 TypeScript 템플릿을 갖춘 React 프로젝트를 생성해보세요. 아래 명령어를 사용하여 React 프로젝트를 생성할 수 있습니다.\n\n```js\nnpm init vite@latest react-vite-library -- --template react-ts\n```\n\n\n\n프레임워크를 선택하라는 안내가 있을 것입니다.\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_1.png)\n\nReact를 선택하고 입력하라고 하면\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_2.png)\n\n\n\nTypeScript 변형을 선택하고 입력하세요. TypeScript로 만들어진 React 프로젝트가 생성됩니다.\n\n## 단계 2: Prettier와 ESLint 구성\n\nPrettier와 ESLint를 구성하는 이유는 프로그래밍 및 스타일 오류에 대한 일련의 규칙에 대해 분석하여 소스 코드를 평가하고 디버깅하는 데 도움이 되기 때문입니다. 이를 통해 개발자가 코드를 실행하기 전에 오류를 찾을 수 있습니다. 규칙은 또한 최상의 코드 표준과 관행을 시행하며, 더 좋은 코드 품질, 더 가독성이 좋고 유지보수하기 쉬운 코드를 제공합니다.\n\n프로젝트에 ESLint를 설치해 봅시다.\n\n\n\n```js\nyarn global add eslint // 전역에 설치합니다\nyarn add -D eslint  // 이 명령어는 package.json의 devDependencies에 eslint를 추가합니다\n```\n\neslint를 설치한 후, eslint --init을 실행하여 프로젝트에서 eslint를 구성하세요. 그럼 질문이 나올 텐데, 주어진 옵션을 선택하고 eslint가 프로젝트에 구성될 때까지 계속 입력하세요.\n\n<img src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_3.png\" />\n\n프로젝트용 모듈 유형을 선택하고 입력하세요.\n\n\n\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_4.png)\n\nReact 프레임워크를 선택하고 입력해주세요.\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_5.png)\n\n프로젝트는 TypeScript를 사용하므로 '예'를 선택하고 입력해주세요.\n\n\n\n<img src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_6.png\" />\n\nJSON을 선택하고 입력하세요\n\n<img src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_7.png\" />\n\n마지막 단계에서 패키지를 설치하라는 메시지가 표시됩니다. 이때 yes를 선택하면 npm이 패키지를 설치해 줍니다. 만약 yarn을 사용 중이라면 no를 선택하고 yarn을 사용하여 패키지를 설치할 수 있습니다.\n\n\n\nmd\n![React Component Library with Vite and Deploy in NPM](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_8.png)\n\n프로젝트 루트에 .eslintc.json 파일이 생성됩니다. 이 파일에는 기본 구성이 포함되어 있습니다. 필요에 따라 규칙을 추가할 수 있습니다. 아래의 구성을 직접 사용할 수도 있습니다: .eslintc.json.\n\n위 구성에는 prettier, react-hooks 및 simple-import-sort가 포함되어 있습니다. 다음 명령어를 사용하여 패키지를 설치할 수 있습니다.\n\n```js\nyarn add -D react-hooks eslint-plugin-simple-import-sort prettier\n\nnpm install -D react-hooks eslint-plugin-simple-import-sort prettier\n``` \n\n\n\n\n프로젝트 루트에 .prettierrc 파일을 만들고 다음 코드를 포함하세요. 이 코드는 코드를 서식 맞추는 데 사용됩니다.\n\npackage.json에 다음 스크립트를 추가하세요.\n\n```js\n\"lint\": \"eslint 'src/**/*.{js,jsx,ts,tsx}'\",\n\"lint:fix\": \"eslint --fix 'src/**/*.{jsx,ts,tsx}'\",\n\"format\": \"prettier --write src//**/*.{ts,tsx,css} --config ./.prettierrc\",\n```\n\n## 단계 3: husky 및 lint-staged 구성하기\n\n\n\nGit 훅은 git 실행 중 특정 시점에서 액션을 트리거할 수 있게 해줍니다. 코드베이스를 깨끗하게 유지하는 데 중요한 역할을 합니다. 코드 형식을 확인하거나 린트를 실행하거나 코드가 커밋되거나 원격 저장소로 푸시되기 전에 테스트를 실행하는 등의 작업을 수행할 수 있습니다. Husky를 사용하면 git 훅을 더 쉽게 사용할 수 있습니다. 이 프로젝트에서는 pre-commit 훅만 사용하며 lint-staged 패키지를 사용하여 git 훅을 staged 파일에만 적용합니다.\n\n```js\nnpm install husky --save-dev\nyarn add -D husky\n```\n\npackage.json에 다음 스크립트를 추가하고 yarn prepare를 실행합니다. 스크립트를 실행한 후 프로젝트 루트에 .husky 폴더가 생성됩니다.\n\n```js\n\"prepare\": \"husky install\"\n```\n\n\n\n그런 다음 다음 명령을 실행하여 pre-commit 훅을 추가합니다.\n\n```js\nnpx husky add .husky/pre-commit \"yarn lint-staged\"\ngit add .husky/pre-commit\n```\n\n이제 아래 내용으로 package.json 파일을 업데이트하십시오.\n\n프로젝트에 Husky와 lint-staged가 성공적으로 추가되었습니다.\n\n\n\n## 단계 4: 라이브러리에 포함시킬 컴포넌트들 생성하기\n\nsrc/components 폴더 안에 컴포넌트들을 생성하세요.\n\n- src/components/HelloWorld.tsx\n- src/components/style.css\n\n\n\nsrc/components/index.ts: 이 파일은 모든 것이 이 한 파일에서 내보내어지는 컴포넌트의 주 진입점입니다.\n\n## 단계 5: vite.config.ts 설정\n\n컴포넌트 라이브러리의 빌드 버전을 생성하기 위해 vite.config.ts 파일을 구성해야 합니다.\n\n- 에디터에서 /vite.config.js를 열고 다음을 붙여넣으세요:\n\n\n\n2. linterPlugin은 프로젝트의 린트를 확인하는 데 사용됩니다. dts은 구성 요소 라이브러리에서 사용되는 유형 정의를 생성하는 데 사용됩니다. dts 내부에는 구성 요소가 포함된 폴더의 위치가 포함되어 있습니다.\n\n3. name: `ReactViteLibrary`를 귀하의 구성 요소의 이름으로 교체하는지 확인하십시오.\n\n4. 마찬가지로, fileName 값의 react-vite-library가 귀하의 구성 요소의 이름으로 변경되었는지 확인하십시오.\n\n5. entry: resolve(\"src\",\"component.index.ts\")를 귀하의 구성 요소에서 모든 것이 내보내지는 주 파일의 경로로 대체하십시오. 이는 귀하의 구성 요소의 주 진입점입니다.\n\n\n\n6. `rollupOptions`은 직접적으로 기존의 Rollup 번들을 사용자 정의할 수 있습니다. 이는 Rollup 구성 파일에서 내보낼 수 있는 옵션들과 동일하며, Vite의 내부 Rollup 옵션과 병합됩니다.\n\n## 단계 6: tsConfig.json 및 tsConfig.node.json 구성하기\n\ntsConfig.json에 다음 코드를 포함하세요.\n\n위의 예시에서, `react-vite-library: [\"src\",\"component.index.ts\"]`는 `componentLibraryName: main entry file 위치`를 나타내며, `typeRoots`는 빌드 요소에 포함될 유형을 나타냅니다.\n\n\n\ntsConfig.node.json에 다음 코드를 포함하세요.\n\n## 단계 7: package.json 구성\n\n다음 내용으로 package.json을 업데이트하세요.\n\n- react-vite-library의 모든 인스턴스를 귀하의 컴포넌트/패키지 이름으로 바꿉니다. 다른 npm 패키지에서 이미 존재하지 않아야 합니다. 이 이름은 사용자가 프로젝트에 귀하의 컴포넌트를 설치하는 데 입력할 것이기 때문에 예를 들어: npm install my-component. 해당 이름이 이미 사용 중인지 npm 웹 사이트에서 검색하여 확인할 수 있습니다.\n- description, author 및 keywords에 자체 값 추가\n- 라이선스를 선호하는 대로 변경\n- React를 개발 종속성으로 설치하세요. 리액트 앱은 귀하의 컴포넌트 패키지에 대한 React 제품 의존성을 책임지기 때문에 프로덕션 종속성으로 설치하지 않습니다.\n- repository, bugs 및 homepage에 자체 GitHub 저장소 링크를 추가하세요\n\n\n\n## 단계 8: 빌드\n\n만약 yarn build를 실행하면, 프로젝트 루트에 dist 폴더가 생성됩니다. 이 폴더 안에는 4단계에서 빌드한 컴포넌트들이 포함되어 있습니다.\n\n# 버전 태그 생성\n\n빌드한 패키지를 릴리스하기 위해 버전 태그를 생성해야 합니다. package.json 파일에서 버전 태그를 간단하게 편집할 수 있습니다. 여기서는 버전을 개발하기 위해 GitHub 액션을 사용할 것입니다.\n\n\n\n- GitHub 저장소로 이동해서 액션을 클릭해주세요\n\n![액션 클릭](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_9.png)\n\n2. 직접 workflow를 설정하고 아래 코드를 복사하여 붙여넣기해주세요\n\n버전 태그를 생성하기 위해 이 액션을 패치해야 합니다. 이를 위해 액션으로 이동해야 합니다.\n\n\n\n- 버전을 생성하는 GitHub 액션을 선택하고 아래에 표시된 \"Run workflow\"를 클릭하세요:\n\n![GitHub 액션](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_10.png)\n\n2. GitHub 액션이 완료되면 버전 태그를 받게 됩니다.\n\n![버전 태그](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_11.png)\n\n\n\n# NPM에 발행하기\n\n컴포넌트 라이브러리를 NPM에 발행하려면 NPM 계정이 있어야 합니다. 계정이 없다면 NPM에 발행하기 전에 먼저 계정을 만들어주세요. NPM에 컴포넌트 라이브러리를 발행하는 방법은 두 가지가 있습니다: NPM 명령줄을 사용하여 직접 발행하거나 GitHub 작업을 사용해 발행합니다.\n\n명령줄 도구를 사용하여 발행하기\n\n단계 1: 먼저 package.json 파일의 버전 번호가 올바른지이며, 의미론적 버전 규칙을 준수하는지 확인하세요. 각 새로운 버전 번호로 NPM에 발행할 때마다 이 작업을 수행해야 합니다.\n\n\n\n단계 2: 테스트를 작성했다면, 테스트 및 린트 규칙을 모두 통과하는지 확인하세요.\n\n```js\nyarn run test\nyarn run lint\n```\n\n단계 3: 컴포넌트를 빌드하려면 `yarn build`를 실행하세요. UMD 및 ESM 모듈 형식이 생성되고 `/dist` 폴더에 배치됩니다.\n\n단계 4: npm에 로그인되어 있는지 확인하세요. 그렇지 않은 경우 다음을 입력하세요:\n\n\n\n```js\nnpm login\n```\n\n단계 5: 컴포넌트를 게시합니다\n\n```js\nnpm publish\n```\n\nGitHub 작업을 사용하여 게시하기\n\n\n\n단계 1: GitHub 리포지토리로 이동하여 Actions를 클릭하세요.\n\n단계 2: 새 워크플로우를 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_12.png)\n\n단계 3: 직접 워크플로우를 설정하기를 클릭하세요.\n\n\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_13.png)\n\n단계 4: 다음 코드를 복사하여 GitHub 작업을 생성합니다.\n\n단계 4: GitHub 작업 위에 secrets.NPM_TOKEN이 있습니다. 따라서 NPM에서 액세스 토큰을 생성해야 합니다.\n\n- https://www.npmjs.com/으로 이동하여 계정에 로그인합니다. 프로필 아이콘을 클릭하면 다음 드롭다운 메뉴가 표시되며, 액세스를 선택합니다.\n\n\n\n![새 토큰 생성하기](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_14.png)\n\n2. 새 토큰을 생성하세요\n\n![정보 작성 및 액세스 토큰 생성](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_15.png)\n\n3. 정보를 작성하고 액세스 토큰을 생성하세요\n\n\n\n<img src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_16.png\" />\n\n4. 방금 생성한 액세스 토큰을 복사한 후 깃허브 리포지토리 설정으로 이동하십시오. 그리고 새 리포지토리 시크릿을 클릭하세요.\n\n<img src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_17.png\" />\n\n5. 액세스 토큰을 붙여넣고 시크릿을 추가하세요.\n\n\n\n<img src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_18.png\" />\n\n비밀 키를 리포지토리에 성공적으로 추가했습니다.\n\n단계 5: 이제 '새 릴리스 만들기'를 클릭하여 릴리스를 생성하세요.\n\n<img src=\"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_19.png\" />\n\n\n\n단계 6: 버전 태그를 선택하고 정보를 입력한 후 '릴리스 게시'를 클릭하세요.\n\n![Image](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_20.png)\n\n단계 7: 게시를 클릭한 후에는 만든 GitHub 작업이 실행됩니다. \"액션\"으로 이동하여 확인할 수 있습니다.\n\n![Image](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_21.png)\n\n\n\n8단계: 패키지가 성공적으로 게시되었습니다. NPM 계정으로 이동하여 확인해주세요.\n\n![이미지](/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_22.png)\n\n# 결론\n\nReact 컴포넌트 라이브러리를 성공적으로 만들었고 NPM에 게시했습니다. 이제 할 일 중 하나는 테스트 애플리케이션을 만들고 NPM에서 컴포넌트를 설치하는 것입니다. 그런 다음 의도한 대로 작동하는지 확인할 수 있습니다.\n\n\n\n# 보너스\n\n저는 이 간단한 방법을 사용하여 구축한 또 다른 컴포넌트 라이브러리가 있습니다. 해당 라이브러리를 사용하면 하나의 패키지로 다른 종류의 모달을 사용할 수 있습니다. https://www.npmjs.com/package/react-global-modal\n\n코딩 즐기세요. 👨🏻‍💻","ogImage":{"url":"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_0.png"},"coverImage":"/assets/img/2024-05-14-ReactComponentLibrarywithViteandDeployinNPM_0.png","tag":["Tech"],"readingTime":9}],"page":"116","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":5},"__N_SSG":true}