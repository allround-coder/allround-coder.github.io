{"pageProps":{"posts":[{"title":"Nodejs와 Expressjs로 간단하게 구현하는 Keycloak RBAC 방법","description":"","date":"2024-06-23 13:24","slug":"2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs","content":"\n\n안녕하세요!\n\n오늘은 Node.js 및 Express.js API에 대한 간단한 역할 기반 액세스 제어 (RBAC)를 구축하는 방법을 알아볼 것입니다. 이를 위해 인증을 위해 Keycloak을 사용할 것입니다.\n\nKeycloak 인증을 통해 Node + Express API를 안전하게 보호하는 해결책을 찾던 중 Keycloak Node.js 어댑터인 keycloak-connect를 만났습니다. 이 어댑터는 모든 요청과 함께 제공된 Bearer 토큰을 확인하는 프로세스를 간소화해주지만, 특정 역할이 있는 사용자가 특정 경로에 액세스할 수 있는지 확인하는 것은 조금 더 복잡해졌습니다.\n\n조사한 결과, Keycloak에서 큰 설정이 필요하지 않는 해결책을 찾을 수 있었습니다. 함께 알아보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## 준비 사항\n\n안내서를 따라 가기 전에 이미 독립적인 Keycloak 설정이 완료되어 있어야 합니다. 그렇지 않은 경우 Docker를 사용하여 빠르게 로컬에서 설정할 수 있습니다. 또한 사용자 액세스 토큰을 생성하는 방법이 이미 설정되어 있는 것을 기대합니다. (이전 글에서 구성한 프론트엔드 설정을 재사용할 수 있습니다)\n\n# 새로운 Node.js 프로젝트 만들기\n\n먼저, 로컬에서 새로운 Node.js 프로젝트를 시작해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm init\n```\n\n구성을 원하는 대로 변경할 수 있어요. 주로 기본 설정을 사용해요.\n\n## npm 패키지 설치\n\n이 프로젝트에 필요한 패키지를 설치해봐요.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm i cors dotenv express jsonwebtoken keycloak-connect nodemon\n```\n\n각 패키지에 대해 자세히 알아보려면 해당 공식 문서를 확인할 수 있어요.\n\njwt를 사용하여 API 요청을 통해 전달된 Bearer 토큰을 읽고, keycloak-connect를 사용하여 토큰을 확인할 거에요.\n\n로컬에서 API 서버를 실행하려면 package.json 파일에 스크립트를 추가해야 해요. \"scripts\" 아래에 이 줄을 객체에 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 파일: package.json\n\n...\n\n\"start\": \"nodemon index.js\",\n\n...\n```\n\n사용 편의를 위해 package.json 파일에 루트 및 미들웨어 디렉토리의 경로 별칭도 추가했습니다.\n\n```js\n// 파일: package.json\n\n...\n\n\"imports\": {\n  \"#routes/*\": \"./routes/*.js\",\n  \"#middlewares/*\": \"./middlewares/*.js\"\n}\n\n...\n```\n\n## 기본 프로젝트 생성하기\n\n<div class=\"content-ad\"></div>\n\nAPI가 작동하는지 테스트하려면 간단한 기본 프로젝트를 만들어 보겠습니다. 루트 폴더에 index.js 파일을 추가해주세요.\n\n```js\n// 파일: index.js\n\nrequire('dotenv').config();\nconst cors = require('cors');\nconst express = require('express');\n\nconst port = process.env.PORT;\n\n// 라우터\nconst testRoutes = require('#routes/test');\n\nconst errorHandler = (error, req, res, next) => {\n  const status = error.status || 422;\n  res.status(status).send(error.message);\n}\n\nconst app = express();\n\napp.use(express.json());\napp.use(cors());\n\n// 라우트 등록\napp.use('/api', testRoutes);\napp.use(errorHandler);\n\napp.listen(port, () => {\n  console.log(`서버가 ${port} 포트에서 시작되었습니다.`);\n});\n```\n\n여기서 환경 변수를 사용하는 것을 주목했나요?\n\n프로젝트용 .env 파일을 만들고, 이미 만들지 않았다면 API에 사용할 포트 번호를 할당해주세요.\n\n<div class=\"content-ad\"></div>\n\n우리는 테스트를 위해 라우트 파일을 사용하고 있습니다. 다음으로 그것을 생성해 봅시다.\n\n```js\n// 파일: routes/test.js\n\nconst express = require('express');\nconst router = express.Router();\n\n// 테스트 라우트\nrouter.get('/test', (req, res) => {\n  res.json({\n    message: \"API 연결이 설정되었습니다.\",\n    status: \"성공\"\n  })\n  .status(200);\n});\n\nmodule.exports = router;\n```\n\n## 기본 프로젝트를 가동해 봅시다\n\n로컬에서 API를 실행하려면 터미널에서 다음을 실행하세요 :\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm start\n```\n\n터미널에서 'Server Started at `port`'와 같은 메시지가 표시될 것입니다.\n\n모든 것이 동작하는지 확인하려면 브라우저에서 http://localhost:`port`/api/test을 열어보세요. 여기에서는 test.js 라우트 파일에서 만든 응답 객체를 확인할 수 있어야 합니다. 이는 우리의 기본 프로젝트가 기대한 대로 동작 중임을 의미합니다.\n\n# 사용을 위한 Keycloak 구성하기\n\n\n<div class=\"content-ad\"></div>\n\n설정한 Keycloak으로 새로운 프로젝트를 위한 Realm을 생성해보세요. 저는 간단하게 \"rbacDemo\"라고 지었습니다.\n\n만들어진 Realm으로 이동한 후, 좌측의 \"Clients\"를 선택하고 \"Client 목록\" 탭에서 \"Client 만들기\" 버튼을 클릭해보세요. \"Client 만들기\" 양식에서 \"일반 설정\" 아래에 새로운 클라이언트 ID를 지정해주세요.\n\n\"Realm 역할\"로 이동하여 좌측에 있는 \"역할 만들기\" 버튼을 클릭해주세요. 우리는 이 Realm을 위한 관리자 역할을 만들 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지1](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_1.png)\n\n이제 \"Realm roles\"로 돌아가면 방금 만든 관리자 역할을 볼 수 있어야 합니다.\n\n이제 우리의 realm 및 클라이언트가 준비되었으므로 사용자가 필요합니다. 2명만 있으면 됩니다. 하나는 관리자 사용자이고 다른 하나는 일반 사용자입니다. \"사용자\"로 이동하고 \"사용자 추가\" 버튼을 클릭하세요.\n\n![이미지2](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_2.png)\n\n<div class=\"content-ad\"></div>\n\n관리자 사용자가 생성되면 사용자의 \"사용자 세부정보\" 페이지로 이동하여 \"자격 증명\" 탭에서 사용자의 비밀번호를 설정해주세요.\n\n\n![이미지](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_3.png)\n\n\n한 번 더 \"사용자\" 페이지로 돌아가서 다른 사용자를 추가해주세요.\n\n\n![이미지](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n카렌을 위해도 비밀번호를 만들지 않도록하세요.\n\"사용자\"로 돌아가서 이제 목록에 Admin과 Karen 두 명의 사용자가 있는 것을 확인할 수 있을 거에요.\n\n이제 어드민 사용자로 이동하여 \"Role mapping\" 탭 아래에서 사용자에게 역할을 할당해볼까요?\n\n![이미지](/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_5.png)\n\n이제 우리 어드민 사용자에게 \"admin\" 역할이 할당된 것을 확인할 수 있을 거에요.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_6.png\" />\n\n그것만으로도 Keycloak에서 RBAC 작업을 시작할 준비가 끝났습니다.\n\n# API에 RBAC 구현하기\n\n먼저 Keycloak Realm 및 Client ID를 .env 파일에 추가해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n키클로크가 있는 위치에 따라 KEYCLOAK_URL을 변경해주세요.\n\n## 키클로크 미들웨어 설정\n\nkeycloak-connect를 라우트의 미들웨어로 사용하려면, 새로운 미들웨어를 만들어야 합니다.\n```  \n\n<div class=\"content-ad\"></div>\n\n```js\n// file: middlewares/keycloak.js\n\nconst Keycloak = require(\"keycloak-connect\");\nconst dotenv = require('dotenv').config();\n\nconst config = {\n  \"realm\": process.env.KEYCLOAK_REALM,\n  \"auth-server-url\": `${process.env.KEYCLOAK_URL}`,\n  \"ssl-required\": \"external\",\n  \"resource\": process.env.KEYCLOAK_CLIENT,\n  \"bearer-only\": true\n}\n\nmodule.exports = new Keycloak({}, config);\n```\n\n그런 다음 우리는 index.js에 방금 만든 미들웨어를 사용하도록 알려주어야 합니다.\n\n```js\n// file: index.js\n\n...\n\nconst express = require('express');\nconst keycloak = require('#middlewares/keycloak'); // Keycloak\n\n...\n\napp.use(keycloak.middleware());\napp.use(express.json());\n\n...\n```\n\n## 라우트에 Keycloak 미들웨어 추가하기\n\n\n<div class=\"content-ad\"></div>\n\n새로운 라우트 파일을 만들어 미들웨어를 사용할 것이에요.\n\n```js\n// 파일: routes/menuItems.js\n\nconst express = require(\"express\");\nconst router = express.Router();\n\n// 미들웨어\nconst keycloak = require(\"#middlewares/keycloak\");\n\n// 가짜 데이터\nconst menuItems = [\n  {\n    name: \"크루아상\",\n    price: \"$1\",\n    onMenu: true\n  },\n  {\n    name:\"라떼\",\n    price: \"$5\",\n    onMenu: true\n  },\n  {\n    name: \"로티 차나이\",\n    price: \"$0.50\",\n    onMenu: true\n  },\n  {\n    name: \"핫 초콜릿\",\n    price: \"$5\",\n    onMenu: false\n  },\n  {\n    name: \"사테\",\n    price: \"$8\",\n    onMenu: false\n  },\n  {\n    name: \"팟 타이\",\n    price: \"$7\",\n    onMenu: false\n  }\n];\n\n// 어떤 역할이든 열려 있는 라우트\nrouter.get(\"/menu-items\",\n[keycloak.protect()],\nasync (req, res, next) => {\n  try {\n    let filtered = menuItems.filter(item => {\n      if (item.onMenu === true) {\n        return item;\n      }\n    });\n\n    // 필터된 데이터 반환\n    res.json(filtered);\n  } catch (error) {\n    return next(error);\n  }\n});\n\nmodule.exports = router;\n```\n\n라우트가 데이터 세트를 반환하도록 지시할 거에요. 일반적으로는 데이터베이스에서 하겠지만 여기서는 가짜 데이터를 사용할 거에요.\n\n## Keycloak 미들웨어 테스트하기\n\n<div class=\"content-ad\"></div>\n\n알림: 여기서 사용자의 엑세스 토큰을 생성해야 합니다.\n\nBearer 토큰을 요청의 인증 헤더로 파싱하고 있다고 가정하면, 메뉴에 있는 항목만 응답을 받아야 합니다. /menu-items 경로는 모든 사용자에게 열려 있기 때문에 관리자와 카렌이 동일한 응답을 받아야 합니다.\n\nPostman을 사용하여 이를 테스트할 수 있습니다.\n\n## Bearer 토큰에서 데이터 디코딩 및 추출하기\n\n<div class=\"content-ad\"></div>\n\n이제 \"admin\" 역할을 가진 사용자에게만 제한된 또 다른 경로를 추가해 봅시다.\n\n먼저 두 개의 미들웨어를 추가해야 합니다.\n하나는 jsonwebtoken을 사용하여 Bearer 토큰에서 사용자 데이터를 해독 및 추출하는 것이고, 다른 하나는 해당 사용자가 필요한 역할을 가졌는지 확인하는 것입니다.\n\n```js\n// file: middlewares/extractToken.js\n\nconst jwt = require(\"jsonwebtoken\");\n\nmodule.exports = async (req, res, next) => {\n  try {\n    // 액세스 토큰 디코딩\n    const bearerToken = req.headers.authorization;\n    // bearerToken은 \"Bearer <access_token>\"을 반환합니다.\n\n    const token = bearerToken.split(\" \");\n    // token은 [\"Bearer\", \"<access_token>\"]을 반환합니다.\n\n    const tokenData = jwt.decode(token[1]);\n    // tokenData는 사용자 데이터를 반환합니다.\n\n    // 해독된 토큰 데이터를 요청에 저장\n    req.tokenData = tokenData;\n\n    next();\n  } catch (error) {\n    next(error);\n  }\n}\n```\n\n```js\n// file: middlewares/checkIfAdmin.js\n\nmodule.exports = async (req, res, next) => {\n  try {\n    const tokenData = req.tokenData;\n    const roles = tokenData.realm_access.roles;\n    // roles는 문자열 배열을 반환합니다.\n\n    const isAdmin = roles.includes(\"admin\");\n\n    if (isAdmin) {\n      // 사용자가 Admin 역할을 가지고 있는 경우, 진행합니다.\n      next();\n    } else {\n      // 사용자가 관리자가 아닌 경우 오류 발생\n      const error = new Error(\"액세스 거부: 이에 액세스할 수 있는 권한이 없습니다.\");\n      error.statusCode = 401;\n      throw error;\n    }\n  } catch (error) {\n    next(error);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n작성된 미들웨어와 새로운 라우트를 메뉴 아이템 라우트 파일에 추가해보세요.\n\n```js\n// 파일: routes/menuItems.js\n\n...\n\n// 미들웨어\nconst keycloak = require(\"#middlewares/keycloak\");\nconst extractToken = require(\"#middlewares/extractToken\");\nconst checkIfAdmin = require(\"#middlewares/checkIfAdmin\");\n\n...\n\n// 어드민 역할만 접근 가능한 라우트\nrouter.get(\"/menu-items/all\", \n[keycloak.protect(), extractToken, checkIfAdmin],\nasync ( req, res, next) => {\n  try {\n    // 모든 데이터 반환\n    res.json(menuItems);\n  } catch (error) {\n    return next(error);\n  }\n});\n\nmodule.exports = router;\n```\n\n이제 이 새로운 API 라우트를 Postman을 사용하여 두 사용자로 테스트해보세요.\n\nKaren의 토큰을 사용하면 액세스 거부 오류가 발생합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 Admin의 토큰을 사용했다면, 메뉴에 있는 모든 항목을 얻을 수 있습니다.\n\n# 마무리\n\n여기서는 Node + Express API에 간단한 Role-Based Access Control (RBAC)를 구현하는 방법을 안내했습니다. Keycloak를 사용했습니다.\n\n이 안내서는 여러분의 API에 사용할 수 있는 방법을 쉽게 보여주기 위해 간소화되었습니다. 이 안내서에서는 GET 요청만 사용했지만 사실상 다른 요청 방법과 함께 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 가이드의 소스 코드는 여기에서 확인할 수 있어요. 이 기사에 대해 토론할 내용이 있다면 언제든지 연락해 주세요.\n\n읽어 주셔서 감사합니다. 다음에 또 만나요! 👋","ogImage":{"url":"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_0.png"},"coverImage":"/assets/img/2024-06-23-SimpleKeycloakRBACwithNodejsExpressjs_0.png","tag":["Tech"],"readingTime":9},{"title":"Nodejs 애플리케이션에서 Winston으로 로깅하는 방법","description":"","date":"2024-06-23 13:23","slug":"2024-06-23-UsingWinstonforLogginginNodejsApplications","content":"\n\n로그 기록은 모든 애플리케이션에서 중요한 부분입니다. 디버깅, 모니터링 및 코드 유지 관리에 도움이 됩니다. 유연성과 기능이 풍부한 기능으로 Node.js에서 가장 인기 있는 로깅 라이브러리 중 하나인 Winston에 대해 알아보겠습니다. 이 기사에서는 Node.js 애플리케이션에 Winston을 통합하는 방법과 그 기능을 최대한 활용하는 방법을 살펴보겠습니다.\n\n![이미지](/assets/img/2024-06-23-UsingWinstonforLogginginNodejsApplications_0.png)\n\n# 개요:\n\n이 튜토리얼에서 다룰 내용은:\n\n<div class=\"content-ad\"></div>\n\n- Node.js 프로젝트에서 Winston 설정하기.\n- 다른 로깅 레벨 구성하기.\n- 사용자 정의 로그 형식 만들기.\n- 여러 전송 방법 (콘솔, 파일 등)으로 로깅하기.\n- 사용자 정의 로그 레벨 만들기.\n- 매일 로그 파일에 로깅하기.\n- Express 애플리케이션에서 Winston 사용하기.\n\n# 준비물:\n\n- JavaScript 및 Node.js의 기본 지식.\n- npm 및 Express에 익숙해야 합니다 (마지막 단계에서 선택 사항이지만 권장됨).\n\n# 설정:\n\n<div class=\"content-ad\"></div>\n\nNode.js 프로젝트를 초기화해봅시다:\n\n```js\nmkdir winston-logger-example\ncd winston-logger-example\nnpm init -y\n```\n\nWinston을 설치해보세요:\n\n```js\nnpm install express winston winston-daily-rotate-file\n```\n\n<div class=\"content-ad\"></div>\n\n# 기본 설정:\n\nWinston을 설정하기 위한 logger.js 파일을 만듭니다:\n\n```js\n// logger.js\n\nconst { createLogger, format, transports } = require('winston');\n\nconst logger = createLogger({\n  level: 'info',\n  format: format.combine(\n    format.colorize(),\n    format.timestamp(),\n    format.printf(({ timestamp, level, message }) => `${timestamp} ${level}: ${message}`)\n  ),\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: 'app.log' })\n  ]\n});\n\nmodule.exports = logger;\n```\n\n설명:\n\n<div class=\"content-ad\"></div>\n\n- createLogger: 새 로거 인스턴스를 초기화합니다.\n- format.combine: 여러 형식을 결합하는데, 여기에서는 colorize, timestamp, printf를 사용합니다.\n- transports: 로그를 전송할 위치를 지정합니다. 이 예에서는 콘솔과 파일 (app.log)에 로그를 남깁니다.\n\n# 로깅 레벨 구성:\n\nWinston은 error, warn, info, http, verbose, debug, silly와 같은 여러 가지 로깅 레벨을 지원합니다. 캡쳐할 로그의 최소 레벨을 구성할 수 있습니다.\n\n```js\n// logger.js\n\nconst { createLogger, format, transports } = require('winston');\n\nconst logger = createLogger({\n  levels: {\n    error: 0,\n    warn: 1,\n    info: 2,\n    http: 3,\n    verbose: 4,\n    debug: 5,\n    silly: 6\n  },\n  level: 'info', // 기본 로그 레벨 설정\n  format: format.combine(\n    format.colorize(),\n    format.timestamp(),\n    format.printf(({ timestamp, level, message }) => `${timestamp} ${level}: ${message}`)\n  ),\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: 'app.log' })\n  ]\n});\n\nmodule.exports = logger;\n```\n\n<div class=\"content-ad\"></div>\n\n설명:\n\n- levels: 사용자 정의 로깅 레벨을 정의합니다.\n- level: 캡처할 로그의 최소 레벨을 설정합니다 (여기서는 info로 설정되어 있음).\n\n# 로그 레벨 이해:\n\n로그 레벨은 기록되는 메시지의 심각성을 결정합니다. Winston은 npm 스타일 로깅 레벨을 사용하며, 가장 심각한 것부터 가장 적게 심각한 것까지 우선 순위가 정해져 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- error: (0) 즉각적인 주의가 필요한 오류를 기록하는 데 사용합니다.\n- warn: (1) 잠재적인 문제를 나타내는 경고 메시지를 기록하는 데 사용합니다.\n- info: (2) 애플리케이션 진행 상황을 강조하는 정보 메시지를 기록하는 데 사용합니다.\n- http: (3) HTTP 요청을 기록하는 데 사용합니다.\n- verbose: (4) 디버깅 중 유용한 자세한 정보를 기록하는 데 사용합니다.\n- debug: (5) 디버깅 정보를 기록하는 데 사용합니다.\n- silly: (6) 필요 이상으로 자세한 정보를 기록하는 데 사용합니다.\n\n덜 심각한 메시지를 필터링하기 위해 최소 로그 레벨을 설정할 수 있습니다. 예를 들어, 로그 레벨을 info로 설정하면 info, warn, error 메시지만 기록됩니다.\n\n# 사용자 정의 로그 포맷 생성:\n\n필요에 맞게 사용자 정의 로그 포맷을 만들 수 있습니다. 예를 들어, 메타데이터를 추가하거나 로그 메시지 구조를 변경할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// logger.js\n\nconst { createLogger, format, transports } = require('winston');\n\nconst customFormat = format.combine(\n  format.colorize(),\n  format.timestamp(),\n  format.printf(({ timestamp, level, message, ...meta }) => {\n    return `${timestamp} ${level}: ${message} ${Object.keys(meta).length ? JSON.stringify(meta, null, 2) : ''}`;\n  })\n);\n\nconst logger = createLogger({\n  level: 'info',\n  format: customFormat,\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: 'app.log' })\n  ]\n});\n\nmodule.exports = logger;\n```\n\n해설:\n\n- customFormat: 타임스탬프, 로그 레벨, 메시지 및 선택적인 메타데이터를 구조화된 로그 형식으로 결합합니다.\n\n# 다중 전송으로 로깅하기:\n\n<div class=\"content-ad\"></div>\n\n윈스턴은 서로 다른 파일, 외부 로깅 서비스 또는 콘솔과 같은 여러 대상에 로그를 기록할 수 있어요.\n\n```js\n// logger.js\n\nconst { createLogger, format, transports } = require('winston');\n\nconst logger = createLogger({\n  level: 'info',\n  format: format.combine(\n    format.timestamp(),\n    format.printf(({ timestamp, level, message }) => `${timestamp} ${level}: ${message}`)\n  ),\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: 'app.log' }),\n    new transports.File({ filename: 'error.log', level: 'error' })\n  ]\n});\n\nmodule.exports = logger;\n```\n\n설명:\n\n- transports.File('filename: ‘error.log’, level: ‘error’'): 에러 메시지를 별도의 파일에 기록합니다.\n\n<div class=\"content-ad\"></div>\n\n# 커스텀 로그 레벨 만들기:\n\n윈스턴(Winston)에서 자체적인 로그 레벨을 정의할 수 있습니다. 기본 레벨로는 충분하지 않은 특정 요구 사항이 있을 때 유용합니다.\n\n```js\n// logger.js\n\nconst { createLogger, format, transports, config } = require('winston');\n\nconst customLevels = {\n  levels: {\n    critical: 0,\n    error: 1,\n    warn: 2,\n    info: 3,\n    debug: 4\n  },\n  colors: {\n    critical: 'red',\n    error: 'red',\n    warn: 'yellow',\n    info: 'green',\n    debug: 'blue'\n  }\n};\n\nconst logger = createLogger({\n  levels: customLevels.levels,\n  level: 'info', // 기본 로그 레벨 설정\n  format: format.combine(\n    format.colorize({ all: true }),\n    format.timestamp(),\n    format.printf(({ timestamp, level, message }) => `${timestamp} ${level}: ${message}`)\n  ),\n  transports: [\n    new transports.Console(),\n    new transports.File({ filename: 'app.log' })\n  ]\n});\n\nwinston.addColors(customLevels.colors);\n\nmodule.exports = logger;\n```\n\n설명:\n\n<div class=\"content-ad\"></div>\n\n- customLevels: 사용자 정의 로깅 수준 및 해당하는 색상을 정의합니다.\n- winston.addColors: 로깅 수준에 사용자 정의 색상을 적용합니다.\n\n# 매일 로그 파일에 로깅하기:\n\nwinston-daily-rotate-file 전송을 사용하여 매일 새로운 로그 파일을 생성할 수 있습니다.\n\nwinston-daily-rotate-file를 설치하세요:\n\n<div class=\"content-ad\"></div>\n\n```jsx\nnpm install winston-daily-rotate-file\n\n매일 로테이트 파일 전송을 구성하세요:\n\n// logger.js\n\nconst { createLogger, format, transports } = require('winston');\nconst DailyRotateFile = require('winston-daily-rotate-file');\n\nconst logger = createLogger({\n  level: 'info',\n  format: format.combine(\n    format.timestamp(),\n    format.printf(({ timestamp, level, message }) => `${timestamp} ${level}: ${message}`)\n  ),\n  transports: [\n    new transports.Console(),\n    new DailyRotateFile({\n      filename: 'application-%DATE%.log',\n      datePattern: 'YYYY-MM-DD',\n      zippedArchive: true,\n      maxSize: '20m',\n      maxFiles: '14d'\n    })\n  ]\n});\n\nmodule.exports = logger;\n\n설명:\n```\n\n<div class=\"content-ad\"></div>\n\n- DailyRotateFile: 지정된 날짜 패턴으로 매일 새 로그 파일을 생성합니다.\n- zippedArchive: 이전 로그 파일을 압축합니다.\n- maxSize: 로테이션하기 전 로그 파일의 최대 크기입니다.\n- maxFiles: 로그 파일을 유지하는 최대 일수입니다.\n\n# Express 애플리케이션에서 Winston 사용하기:\n\nWinston을 Express 애플리케이션에 통합하여 HTTP 요청과 오류에 대한 로깅을 처리하세요.\n\nExpress 설치하기:\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm install express\n```\n\nWinston을 이용한 Express 서버 설정:\n\n```js\n// server.js\n\nconst express = require('express');\nconst logger = require('./logger');\n\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// HTTP 요청을 로깅하는 미들웨어\napp.use((req, res, next) => {\n  logger.http(`${req.method} ${req.url}`);\n  next();\n});\n\napp.get('/', (req, res) => {\n  res.send('Hello, World!');\n});\n\n// 에러 처리 미들웨어\napp.use((err, req, res, next) => {\n  logger.error(err.message);\n  res.status(500).send('Internal Server Error');\n});\n\napp.listen(PORT, () => {\n  logger.info(`서버가 http://localhost:${PORT} 에서 실행 중입니다.`);\n});\n```\n\n설명:\n\n\n<div class=\"content-ad\"></div>\n\n- HTTP 요청 로깅: 미들웨어는 logger.http를 사용하여 수신된 모든 HTTP 요청을 로깅합니다.\n- 오류 처리 미들웨어: logger.error를 사용하여 오류를 로깅합니다.\n\n# 결론:\n\nWinston을 Node.js 애플리케이션에 통합함으로써 더욱 강력하고 유연한 로깅 시스템을 구축할 수 있습니다. 이를 통해 코드를 보다 효율적으로 디버깅, 모니터링 및 유지보수할 수 있습니다. 콘솔, 파일 또는 외부 서비스로 로그를 기록해야 하는 경우, Winston의 다양한 기능이 Node.js 로깅에 우수한 선택이 될 것입니다.","ogImage":{"url":"/assets/img/2024-06-23-UsingWinstonforLogginginNodejsApplications_0.png"},"coverImage":"/assets/img/2024-06-23-UsingWinstonforLogginginNodejsApplications_0.png","tag":["Tech"],"readingTime":8},{"title":"Nodejs를 이용한 이중 인증 구현 단계별 가이드","description":"","date":"2024-06-23 13:21","slug":"2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide","content":"\n\n오늘날의 디지턈 시대에서는 보안이 매우 중요합니다, 특히 웹 애플리케이션의 경우에는 더욱 그렇습니다. 두 단계 인증(2FA)을 구현하는 것은 애플리케이션의 보안을 향상시키는 효율적인 기술입니다.\n\n이 게시물은 node.js 개발자에게 가치 있는 정보일 것이지만, 개발자가 아니더라도 모든 프로그래밍 언어에 적용되는 주제이므로 여러분에게 많은 도움이 될 것입니다. Twilio Authy, Microsoft Authenticator, Google Authenticator 등 인기있는 인증 앱이 많이 있습니다. 이 튜토리얼에서는 Google Authenticator를 사용하여 2FA가 무엇인지, 애플리케이션 보안에 어떻게 도움이 되는지, 그리고 구현하는 방법에 대한 단계별 지침을 제공할 것입니다.\n\n## 두 단계 인증(2FA)이란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n이중 인증 또는 2FA는 사용자가 자신의 신원을 확인하기 위해 두 가지 다른 요소를 제공해야하는 보안 메커니즘입니다. 이러한 요소는 일반적으로 세 가지 범주로 나뉩니다:\n\n- 알고 있는 것 (예: 비밀번호)\n- 소지품 (예: 모바일 기기)\n- 본인인 것 (예: 생체 인식)\n\n일반적인 사용자 이름 및 비밀번호 조합 이외에도 2FA는 더 높은 수준의 보안을 추가합니다. 해커가 비밀번호를 얻거나 추측해도 두 번째 요소 없이 계정에 액세스할 수 없습니다.\n\n## Google Authenticator를 사용한 Node.js에서의 2FA 구현\n\n<div class=\"content-ad\"></div>\n\n2FA를 Node.js 애플리케이션에 Google Authenticator 앱을 사용하여 통합하는 방법을 알아봐요. 코딩 부분에 들어가기 전에 먼저 이 과정에 포함된 단계를 이해해 봅시다.\n\n- 비밀 키 생성: 사용자 등록 시마다 각 사용자를 위한 고유한 비밀 키를 생성해요.\n- QR 코드 생성: 비밀 키를 사용하여 사용자가 Google Authenticator 앱으로 스캔할 수 있는 QR 코드를 생성해요.\n- 사용자 설정: 애플리케이션에서 사용자에게 QR 코드 또는 비밀 키를 제공해요. 사용자는 Google Authenticator 앱으로 QR 코드를 스캔해야 해요.\n- OTP 코드 생성: 서버에서 비밀 키를 사용하여 시간 기반 일회용 암호(TOTP)를 생성해요. 이 코드는 매 30초마다 바뀌어요.\n- 사용자 인증: 로그인 시 사용자는 Google Authenticator 앱에서 생성된 현재 OTP를 입력해야 해요.\n- 검증: 사용자가 입력한 OTP를 서버에서 생성된 OTP와 비교해요. 일치하면 사용자가 인증됩니다.\n\n이제 재미있는 부분이 다가와요 :) 우리는 위 단계들을 모두 코드로 변환할 거에요.\n\n<div class=\"content-ad\"></div>\n\n양방향 인증을 구현하기 전에 다음 사전 요구 사항을 갖추었는지 확인해주세요:\n\n- JavaScript 또는 TypeScript의 기본 지식.\n- API 디자인과 CRUD 패턴에 대한 기본 이해.\n- 시스템에 Node.js의 최신 버전이 설치되어 있어야 합니다.\n- Node.js와 Express에 대한 기본 지식이 있어야 합니다.\n\n## 단계 1: Node.js 프로젝트 설정\n\n시작하기 위해 프로젝트용 새 디렉토리를 만들고 터미널에서 해당 디렉토리로 이동한 후 새 Node.js 프로젝트를 초기화하고 필요한 패키지를 설치하세요. 아래 명령어를 터미널에서 실행해보세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nmkdir node_2fa\ncd node_2fa\nnpm init -y\nnpm install express otpauth hi-base32\n```\n\n- express – Node.js 웹 프레임워크\n- otpauth – TOTP를 생성하고 유효성을 검사하는 라이브러리\n- hi-base32 – 데이터를 Base32 형식으로 인코딩 및 디코딩하는 기능을 제공하는 라이브러리입니다. Authenticator 앱에서 TOTP를 생성하는 데 사용할 것입니다.\n\n## 단계 2: Express 서버 설정\n\n프로젝트에 index.js 파일을 만들고 기본 express 서버를 설정하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\napp.get('/', (req, res) => {\n  res.send('이중 인증 예제');\n});\n\napp.listen(port, () => {\n  console.log(`서버가 포트 ${port}에서 실행 중입니다`);\n});\n```\n\n## 단계 3: 사용자 등록\n\n이 단계에서는 사용자 등록을 구현하고 사용자 정보를 안전하게 저장합니다. 보통 이를 위해 데이터베이스를 사용하지만, 이 예시에서는 간단함을 위해 내부 배열을 사용합니다. MongoDB를 이용한 포괄적인 예시는 제 GitHub 레포지토리에서 확인할 수 있습니다. https://github.com/Nik720/2fa-nodejs\n\n```js\nconst users = [];\n\n// 새로운 사용자 등록을 위한 엔드포인트\napp.post('/register', (req, res) => {\n  const { username, password } = req.body;\n  const id = users.length + 1;\n\n  // 사용자 정보를 안전하게 저장 (사용자의 비밀번호 포함)\n  users.push({ id, username, password });\n  res.status(201).send({\n    status: \"성공\",\n    message: \"사용자가 성공적으로 생성되었습니다\"\n  });\n});\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Step 4: Enable Two-Way Authentication](/assets/img/2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide_1.png)\n\n## 단계 4: 두 가지 요소 인증 활성화\n\n이제 otpauth 라이브러리를 사용하여 두 가지 요인 인증을 구축해 봅시다. 사용자가 인증 앱으로 스캔할 수있는 QR 코드를 표시하고 일회용 코드를 확인하는 비밀 키를 생성하는 것이 이 프로세스의 단계입니다.\n\n```js\nconst OTPAuth = require(\"otpauth\");\nconst encode = require(\"hi-base32\");\nconst QRCode = require('qrcode');\n\n// 두 가지 요소 인증 활성화를 위한 엔드포인트\napp.post('/enable-2fa', (req, res) => {\n  const { username } = req.body;\n\n  // 사용자를 사용자 이름으로 찾기 (여기서는 데이터베이스를 사용해야 함)\n  const user = users.find((u) => u.username === username);\n\n  if (!user) {\n    return res.status(404).send('사용자를 찾을 수 없습니다.');\n  }\n\n  // 사용자를 위한 비밀 키 생성\n  const base32_secret = generateBase32Secret();\n  user.secret = base32_secret;\n\n  // 사용자가 스캔할 QR 코드 URL 생성\n  let totp = new OTPAuth.TOTP({\n      issuer: \"YourSite.com\",\n      label: \"YourSite\",\n      algorithm: \"SHA1\",\n      digits: 6,\n      secret: base32_secret,\n  });\n\n  let otpauth_url = totp.toString();\n\n  // 생성된 QR 코드를 응답으로 보내기\n  QRCode.toDataURL(otpauth_url, (err) => {\n        if(err) {\n            return res.status(500).json({\n                status: 'fail',\n                message: \"QR 코드 생성 중 오류 발생\"\n            })\n        }\n        res.json({\n            status: \"success\",\n            data: {\n                qrCodeUrl: qrUrl,\n                secret: base32_secret\n            }\n        })\n    })\n});\n\nconst generateBase32Secret = () => {\n  const buffer = crypto.randomBytes(15);\n  const base32 = encode(buffer).replace(/=/g, \"\").substring(0, 24);\n  return base32;\n};\n```\n\n\n<div class=\"content-ad\"></div>\n\n위 코드 스니펫에서 개발한 GenerateBase32Secret() 메서드는 base32로 인코딩된 비밀 키를 생성하는 데 사용됩니다. 이 키는 TOTP 생성 메커니즘의 중요한 구성 요소입니다. 또한 필요한 인수로 인스턴스화 한 후에 totpvariable에 OTPAuth.TOTP 클래스를 할당했습니다.\n\n다음으로, totp.toString() 함수를 사용하여 TOTP Auth URL을 가져왔습니다. QR 코드를 생성하고 응용 프로그램에서 TOTP 인증을 구성하기 위해 필요한 인코딩된 비밀과 필요한 설정은 이 URL에서 사용할 수 있습니다. 또한, 미래에 이러한 값을 사용할 수 있도록 base32 비밀 문자열을 사용자 객체에 저장했습니다.\n\n마지막 단계에서는 QR 코드 라이브러리를 사용하여 otpauth_url로 QR 코드를 만들고 JSON 응답에 QR 코드 URL과 base32 비밀 문자열을 반환했습니다. 클라이언트에게 이러한 값을 반환함으로써 클라이언트 측 구현을 유연하고 쉽게 할 수 있습니다. 이를 통해 클라이언트는 base32 비밀 문자열을 사용하거나 인증 애플리케이션을 스캔하여 QR 코드를 사용하여 관련 TOTP 토큰을 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n인증 확인의 마지막 단계로 진행하기 전에, 먼저 인증 앱을 구성하여 다음 단계에서 토큰으로 제공될 6자리 코드를 생성해야 합니다.\n\nGoogle Authenticator 앱을 활성화하기 위해 중요한 몇 가지 단계가 필요합니다. 이를 편리하게 하기 위해 여기서는 Chrome 확장 프로그램을 사용하고 있습니다. API에서 제공된 base64 비밀을 수동으로 입력하거나 계정을 추가하기 위해 QR 코드를 스캔해야 합니다.\n\n![2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide_3.png](/assets/img/2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide_3.png)\n\n## 단계 5: 양방향 인증 확인하기\n\n<div class=\"content-ad\"></div>\n\n마침내, 사용자가 제공한 일회용 코드를 확인하는 엔드포인트를 구현하세요. 이 단계에서는 인증 앱에서 생성된 6자리 코드를 전달하여 사용자의 신원을 확인해야 합니다.\n\n```js\n// 두 단계 인증 코드를 검증하는 엔드포인트\napp.post('/verify-2fa', (req, res) => {\n  const { username, token } = req.body;\n\n  // 사용자명으로 사용자 찾기\n  const user = users.find((u) => u.username === username);\n\n  if (!user) {\n    return res.status(404).send('사용자를 찾을 수 없습니다');\n  }\n\n  // 토큰을 검증합니다.\n  let totp = new OTPAuth.TOTP({\n      issuer: \"YourSite.com\",\n      label: \"YourSite\",\n      algorithm: \"SHA1\",\n      digits: 6,\n      secret: user.secret!,\n   });\n\n  let delta = totp.validate({ token });\n\n  if(delta) {\n        res.json({\n            status: \"success\",\n            message: \"인증 성공\"\n        })\n    } else {\n        res.status(401).json({\n            status: \"fail\",\n            message: \"인증 실패\"\n        }) \n    }\n});\n```\n\n<img src=\"/assets/img/2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide_4.png\" />\n\n이 게시물은 2단계 인증의 기본 설정 및 사용법을 다룹니다. 사용자의 존재 여부를 확인하는 기능을 구현했지만, 실제 구현에서는 2FA를 활성화하거나 비활성화하거나 인증하기 전에 사용자 로그인 상태를 추가로 확인해야 합니다.\n\n<div class=\"content-ad\"></div>\n\nMongoDB 데이터베이스를 활용한 포괄적인 예제를 구축했어요. 모든 필수 API 엔드포인트와 미들웨어를 통합했습니다. 자세한 내용은 GitHub 레포지토리를 방문해주세요. https://github.com/Nik720/2fa-nodejs\n\n최초 블로그 게시: https://codeshakti.com/how-to-implement-two-factor-authentication-using-node-js-step-by-step-guide/\n\n## 결론\n\n이 게시물에서 설명된 기술들인 QR 코드 기반 토큰 생성 및 안전한 OTP 확인을 적용함으로써, 무단 접근에 대한 강력한 방어막을 만들고 Node.js 사용자에게 비교할 수 없는 보호를 제공할 수 있습니다. 오늘부터 2FA 시스템을 구축하여 더 안전한 디지털 공간으로 나아가는 첫걸음을 내딛어보세요!\n\n<div class=\"content-ad\"></div>\n\n# 이 글을 즐겼나요?\n\n다음 글에서는 노드 JS 클러스터 모듈을 활용하여 로드 밸런서를 만드는 방법에 대해 더 자세히 다룰 것입니다.\n\n제 글이 마음에 드셨다면 아래 작은 👏을 눌러주세요 (50번 타포도 가능합니다). 더 많은 기술 기사를 위해 팔로우해주세요. 친구들 👦, 동료들 👭 🧑‍🤝‍🧑 와 공유해주세요.\n\n여러분의 지지를 감사히 받겠습니다. 💚 읽어 주셔서 감사합니다! 🙏\n\n<div class=\"content-ad\"></div>\n\n제 블로깅 사이트 codeshakti.com에서 기술 블로그에 대해 더 많은 정보를 찾아보세요.\n\n코딩 즐거움을 느끼세요... 😁","ogImage":{"url":"/assets/img/2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoImplementTwo-FactorAuthenticationusingNodejsStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":8},{"title":"Nodejs를 사용하여 MongoDB에서 중첩된 배열 필드를 업데이트하는 방법","description":"","date":"2024-06-23 13:20","slug":"2024-06-23-HowtoupdatenestedarrayfieldinMongoDBusingNodejs","content":"\n\n몽고디비에서 문서 내 배열 업데이트하기.\n\n![이미지](/assets/img/2024-06-23-HowtoupdatenestedarrayfieldinMongoDBusingNodejs_0.png)\n\nNode.js와 몽고디비를 이용하여 애플리케이션 배열 내 특정 applicationId의 활성 상태를 업데이트하려면 $set 연산자를 사용해야 합니다. $ 연산자는 쿼리 조건과 일치하는 첫 번째 배열 요소를 업데이트할 수 있도록 합니다.\n\n```js\n// applications 배열에서 지정된 applicationId를 포함하는 문서를 찾는 쿼리.\nconst filter = { _id: userId, 'applications.applicationId': applicationId };\n\n// 활성 상태를 설정하는 업데이트.\nconst updateDoc = {\n  // $set 및 $ 연산자 활용: 일치하는 applicationId의 active 필드를 업데이트.\n  $set: { 'applications.$.active': newStatus }\n};\n\nconst result = await collection.updateOne(filter, updateDoc);\n```\n\n<div class=\"content-ad\"></div>\n\n## 설명:\n\n- 필터: 필터 객체는 특정 userId(또는 문서의 다른 고유 식별자)와 applications 배열 내의 applicationId를 가진 문서를 찾고 있는지를 나타냅니다.\n- 업데이트: $set 연산자는 일치하는 배열 요소의 active 필드를 업데이트하기 위해 위치 $ 연산자와 함께 사용됩니다.\n\n## 이제 중첩된 배열에서 여러 applicationId의 활성 상태를 업데이트하는 방법:\n\n한 번의 작업에서 applications 배열 내의 여러 applicationId 항목의 활성 상태를 업데이트하려면 $set 연산자를 $[`identifier`] 배열 필터와 함께 사용할 수 있습니다. 이를 통해 배열 내의 요소를 일치시키고 이에 따라 업데이트할 수 있는 여러 조건을 지정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 여러 applicationId 항목을 업데이트하는 단계:\n\n- MongoDB에 연결: MongoDB 클라이언트를 사용하여 데이터베이스에 연결합니다.\n- 쿼리 정의: 업데이트할 문서를 지정합니다.\n- Array Filters와 $set 사용: 배열 필터를 사용하여 여러 applicationId 항목을 일치시키고 업데이트합니다.\n- 업데이트 처리: 업데이트 명령을 실행하고 응답을 처리합니다.\n\n# 예시 코드\n\n다음은 Node.js와 MongoDB를 사용하여 이 작업을 수행하는 방법입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nconst { MongoClient } = require('mongodb');\r\n\r\n// 귀하의 MongoDB 연결 문자열과 데이터베이스 이름으로 대체합니다.\r\nconst uri = 'mongodb://localhost:27017';\r\nconst dbName = '귀하의데이터베이스이름';\r\nconst collectionName = '귀하의컬렉션이름';\r\n\r\nasync function updateApplicationStatu(userId, updates) {\r\n  const client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true });\r\n\r\n  try {\r\n    await client.connect();\r\n    console.log('MongoDB에 연결됨');\r\n\r\n    const database = client.db(dbName);\r\n    const collection = database.collection(collectionName);\r\n\r\n    // 사용자 문서 가져오기\r\n    const userDoc = await collection.findOne({ _id: userId });\r\n\r\n    if (!userDoc) {\r\n      console.log('사용자 문서를 찾을 수 없음');\r\n      return;\r\n    }\r\n\r\n    // applications 배열을 초기화\r\n    if (!userDoc.applications) {\r\n      userDoc.applications = [];\r\n    }\r\n\r\n    const updateOperations = [];\r\n    const applicationIds = userDoc.applications.map(app => app.applicationId);\r\n\r\n    // 중첩 배열 내 여러 applicationId의 활성 상태를 업데이트\r\n    updates.forEach(update => {\r\n      if (applicationIds.includes(update.applicationId)) {\r\n        // 기존 애플리케이션 상태를 업데이트\r\n        updateOperations.push({\r\n          updateOne: {\r\n            filter: { _id: userId, 'applications.applicationId': update.applicationId },\r\n            update: { \r\n              $set: { 'applications.$.active': update.active },\r\n              $addToSet: { updatedBy: req.session.userId }\r\n            }\r\n          }\r\n        });\r\n      } else {\r\n        // 존재하지 않는 경우 새로운 애플리케이션 추가\r\n        updateOperations.push({\r\n          updateOne: {\r\n            filter: { _id: userId },\r\n            update: {\r\n              $push: {\r\n                applications: { applicationId: update.applicationId, active: update.active }\r\n              }\r\n            },\r\n            $addToSet: { updatedBy: req.session.userId }\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    // 대량 쓰기 작업 수행\r\n    const result = await collection.bulkWrite(updateOperations);\r\n\r\n    if (result.modifiedCount > 0 || result.insertedCount > 0) {\r\n      console.log('애플리케이션 상태가 성공적으로 업데이트됨.');\r\n    } else {\r\n      console.log('일치하는 애플리케이션이 없거나 변경된 내용이 없습니다.');\r\n    }\r\n  } catch (error) {\r\n    console.error('애플리케이션 상태 업데이트 오류:', error);\r\n  } finally {\r\n    await client.close();\r\n  }\r\n}\r\n\r\n// 사용 예시: 여러 애플리케이션 업데이트\r\nupdateApplicationStatuses('userId123', [\r\n  { applicationId: 'Apple', active: true },\r\n  { applicationId: 'Mango', active: false },\r\n  { applicationId: 'Orange', active: true }\r\n]);\r\n```\r\n\r\n# 설명\r\n\r\n- MongoDB 연결: MongoDB 인스턴스에 연결을 설정합니다.\r\n- 데이터베이스 및 컬렉션: 작업할 데이터베이스 및 컬렉션을 지정합니다.\r\n- 필터: 필터 객체는 userId 또는 문서의 다른 고유 식별자를 기반으로 문서를 식별합니다.\r\n- 업데이트 오브젝트: updateDoc은 $set 연산자를 사용하여 지정된 applicationId 엔트리의 활성 상태를 업데이트합니다. 필드 경로는 배열 필터를 동적으로 사용하기 위해 구성됩니다.\r\n- 배열 필터: arrayFilters 옵션을 사용하여 어떤 요소를 업데이트해야 하는지를 정의하는 조건을 정의합니다. 각 필터는 업데이트해야 할 applicationId에 해당합니다.\r\n- updatedBy 필드: updatedBy는 applications 배열의 일부가 아닌 문서의 별도 필드입니다. 요구 사항에 따라서 applications 배열에서 수정이나 추가가 있을 때마다 updatedBy 필드를 업데이트해야 합니다.\r\n- 결과 처리: 업데이트 작업이 문서를 수정했는지 확인하고 결과를 로그에 남깁니다.\r\n\r\n만약 applicationId가 존재하지 않는 경우 해당 활성 상태와 함께 추가되어야 합니다. 이를 위해 쿼리와 업데이트 작업을 혼합해 사용합니다.\r\n\n\n<div class=\"content-ad\"></div>\n\n# 단계:\n\n- 문서 가져오기 및 확인: _id별로 문서를 가져와서 applications 배열의 각 applicationId를 확인합니다.\n- 업데이트 수행: applicationId가 있는지 여부에 따라 기존 객체를 업데이트하거나 새로운 객체를 추가합니다.\n\n# 예시 코드\n\n다음은 Node.js와 MongoDB를 사용하여 이 작업을 수행하는 전체 예시 코드입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst { MongoClient } = require('mongodb');\n\n// 귀하의 MongoDB 연결 문자열 및 데이터베이스 이름으로 대체합니다.\nconst uri = 'mongodb://localhost:27017';\nconst dbName = '당신의데이터베이스이름';\nconst collectionName = '당신의컬렉션이름';\n\nasync function updateApplicationStatuses(userId, updates) {\n  const client = new MongoClient(uri, { useNewUrlParser: true, useUnifiedTopology: true });\n\n  try {\n    await client.connect();\n    console.log('MongoDB에 연결되었습니다.');\n\n    const database = client.db(dbName);\n    const collection = database.collection(collectionName);\n\n    // 사용자 문서 검색\n    const userDoc = await collection.findOne({ _id: userId });\n\n    if (!userDoc) {\n      console.log('사용자 문서를 찾을 수 없습니다.');\n      return;\n    }\n\n    // applications 배열을 초기화합니다.\n    if (!userDoc.applications) {\n      userDoc.applications = [];\n    }\n\n    const updateOperations = [];\n    const applicationIds = userDoc.applications.map(app => app.applicationId);\n\n    updates.forEach(update => {\n      if (applicationIds.includes(update.applicationId)) {\n        // 기존 애플리케이션 상태 업데이트\n        updateOperations.push({\n          updateOne: {\n            filter: { _id: userId, 'applications.applicationId': update.applicationId },\n            update: { $set: { 'applications.$.active': update.active } }\n          }\n        });\n      } else {\n        // 새로운 애플리케이션 추가\n        updateOperations.push({\n          updateOne: {\n            filter: { _id: userId },\n            update: {\n              $push: {\n                applications: { applicationId: update.applicationId, active: update.active }\n              }\n            }\n          }\n        });\n      }\n    });\n\n    // 일괄 작성 작업 수행\n    const result = await collection.bulkWrite(updateOperations);\n\n    if (result.modifiedCount > 0 || result.insertedCount > 0) {\n      console.log('애플리케이션 상태를 성공적으로 업데이트했습니다.');\n    } else {\n      console.log('일치하는 애플리케이션이 없거나 변경 사항이 없습니다.');\n    }\n  } catch (error) {\n    console.error('애플리케이션 상태를 업데이트하는 중 오류 발생:', error);\n  } finally {\n    await client.close();\n  }\n}\n\n// 예제 사용법: 여러 애플리케이션을 업데이트\nupdateApplicationStatuses('userId123', [\n  { applicationId: 'Apple', active: true },\n  { applicationId: 'Mango', active: false },\n  { applicationId: 'Orange', active: true }\n]);\n```\n\n만약 도움이 되었다면 👏 👏 를 좀 받아도 괜찮으세요? 다른 사람들에게도 도움이 될 수 있도록 글을 공유해주시면 정말 감사하겠습니다 :)\n\n언제나 환호해 주세요...\n\n<img src=\"https://miro.medium.com/v2/resize:fit:156/0*9zGASKmAOha2Ov3S.gif\" />\n","ogImage":{"url":"/assets/img/2024-06-23-HowtoupdatenestedarrayfieldinMongoDBusingNodejs_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoupdatenestedarrayfieldinMongoDBusingNodejs_0.png","tag":["Tech"],"readingTime":8},{"title":"2024 최신 Python Flask와 Nodejs Express 비교","description":"","date":"2024-06-23 13:19","slug":"2024-06-23-PythonFlaskvsNodejsExpress","content":"\n\n웹 애플리케이션을 개발할 때, 성능과 확장성을 위해 올바른 프레임워크를 선택하는 것이 중요합니다. Python의 Flask와 Node.js의 Express는 프로젝트 요구 사항에 따라 각각 고유한 장단점을 제공하는 인기 있는 옵션입니다.\n\n![Python Flask vs Node.js Express](/assets/img/2024-06-23-PythonFlaskvsNodejsExpress_0.png)\n\n# 성능\n\n성능 측면에서 Node.js(Express)와 Flask는 각자의 강점과 약점을 가지고 있습니다. Chrome의 V8 JavaScript 엔진 위에 구축된 Node.js는 비동기 I/O 모델과 이벤트 기반 아키텍처 덕분에 우수한 성능으로 알려져 있습니다. 이로 인해 Node.js는 다량의 동시 요청을 효율적으로 처리하며 실행을 지연시키지 않거나 다른 작업을 차단하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n한편, 파이썬 기반의 프레임워크인 플라스크는 특정 시나리오에서 노드.js의 원시 성능과 부합하지 않을 수 있습니다. 파이썬의 Global Interpreter Lock (GIL)은 멀티 스레드 환경에서 CPU 바운드 작업의 성능을 제한할 수 있습니다. 그러나 플라스크의 가벼운 성격과 한 번에 처리할 수 있는 요청 수가 적다는 점은 중간 규모의 트래픽이 발생하고 성능 요구 사항이 덜한 애플리케이션에 적합합니다.\n\n노드.js(익스프레스)와 플라스크를 비교한 벤치마크 결과에 따르면, 일반적으로 노드.js가 처리량과 응답 시간 측면에서 플라스크보다 뛰어나며 특히 높은 동시성 환경에서 더 우수한 성능을 보입니다. TechEmpower에 따른 벤치마크에 따르면, 노드.js(익스프레스)는 플라스크에 비해 더 많은 초당 요청을 처리할 수 있었습니다. 그러나 성능은 특정 사용 사례, 애플리케이션 아키텍처, 그리고 적용된 최적화에 따라 다를 수 있습니다. 플라스크의 성능은 캐싱, 라이브러리인 지벤트와 같은 비동기 처리, 그리고 건코른과 같은 WSGI 서버를 사용하는 기술을 통해 개선할 수 있습니다.\n\n최종적으로, 노드.js(익스프레스)와 플라스크 간의 성능 차이는 대부분의 애플리케이션에 있어 결정적인 요소가 되지 않을 수 있습니다. 선택은 프로젝트의 구체적 요구 사항, 개발 팀의 전문성, 그리고 각 프레임워크에 제공되는 라이브러리와 도구 생태계에 기반해야 합니다.\n\n <img src=\"/assets/img/2024-06-23-PythonFlaskvsNodejsExpress_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 확장성\n\n확장성을 고려할 때 Node.js(Express)는 Flask보다 명확한 장점을 지니고 있어요. Node.js의 이벤트 주도 및 비차단 I/O 모델은 성능 문제 없이 많은 동시 연결을 처리할 수 있게 해줘요. 이 확장성은 Node.js가 시스템 자원을 효율적으로 활용하고 오버헤드를 최소화하여 동시 요청을 처리하는 능력에 기인합니다.\n\n숫자적으로는 Node.js의 단일 인스턴스가 수천 개의 동시 연결을 처리할 수 있는 반면, Flask의 단일 인스턴스는 약 10개 정도의 동시 연결을 처리하는 것으로 제한됩니다. 이 확연한 확장성의 차이로 인해, 높은 트래픽을 예상하고 많은 동시 사용자를 처리해야 하는 애플리케이션에는 Node.js가 더 적합한 선택이 되어요.\n\n파이썬 기반 프레임워크인 Flask는 Python의 Global Interpreter Lock (GIL)에 제약을 받아 진정한 병렬성을 멀티스레드 환경에서 제한받고 있습니다. 특히 CPU 바운드 작업을 다룰 때 Flask 애플리케이션의 확장성에 영향을 미칠 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n그러나 중요한 점은 확장성이 프레임워크 자체로만 결정되는 것은 아니라는 점입니다. 적절한 아키텍처 디자인, 효율적인 데이터베이스 관리, 캐싱 전략 및 부하 분산 기술은 Node.js 및 Flask 애플리케이션의 확장성을 크게 향상시킬 수 있습니다.\n\nNode.js의 내장 클러스터링 지원은 애플리케이션이 다중 코어 시스템을 활용하여 여러 CPU 코어를 사용하여 수직으로 확장할 수 있게 합니다. 이 기능을 통해 외부 도구나 복잡한 구성 없이 Node.js 애플리케이션을 확장하는 것이 더 쉬워집니다.\n\n한편 Flask는 로드 밸런서 뒤에 애플리케이션의 여러 인스턴스를 배포함으로써 수평 확장성을 달성할 수 있습니다. 이 접근 방식을 통해 Flask 애플리케이션은 여러 서버에 부하를 분산시켜 트래픽 증가를 처리할 수 있습니다. 간단히 말해, Node.js(Express)는 대규모 동시 연결을 효율적으로 처리할 수 있는 이벤트 주도형, 비차단 아키텍처로 인해 확장성 측면에서 내재적인 우위를 가지고 있습니다. Flask는 기본적으로는 그렇게 확장성이 좋지는 않지만 적절한 아키텍처 및 배포 전략을 통해 수평 확장이 가능합니다. 이 두 프레임워크 중 어떤 것을 선택할지는 애플리케이션의 예상 확장성 요구사항과 개발 팀의 성능 및 확장성 최적화 능력에 기반해 결정되어야 합니다.\n\n![이미지](/assets/img/2024-06-23-PythonFlaskvsNodejsExpress_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 가장 적합한 응용프로그램 유형\n\nNode.js (Express)와 Flask는 각각의 장점과 특성에 따라 다른 유형의 응용프로그램에 적합합니다. Node.js (Express)는 다음과 같은 것들을 구축하는 데에 우수한 선택지입니다:\n\n- 실시간 응용프로그램: Node.js의 이벤트 기반 및 비차단 I/O 모델은 채팅 애플리케이션, 협업 도구, 그리고 게임 플랫폼과 같이 실시간 통신이 필요한 응용프로그램들을 개발하는 데에 이상적입니다.\n- 마이크로서비스 아키텍처: Node.js의 가벼운 모듈화된 성격은 마이크로서비스 아키텍처와 잘 맞습니다. 개발자들은 쉽게 확장하고 유지보수할 수 있는 작고 독립된 서비스를 만들 수 있습니다.\n- 단일 페이지 응용프로그램 (SPA): Node.js는 Angular, React, 그리고 Vue.js 같은 프론트엔드 기술과 시드 나게 통합되어 있어, 원활하고 상호작용적인 사용자 경험을 제공하는 SPA를 구축하는 데에 인기가 있습니다.\n- 데이터 집중형 응용프로그램: Node.js는 대량의 동시 연결 처리 능력과 효율적인 I/O 작업을 다룰 수 있는 능력으로, 스트리밍 플랫폼이나 데이터 처리 파이프라인과 같이 대량의 데이터를 다루는 응용프로그램에 적합합니다.\n\n반면에, Flask는 다음과 같은 용도에 적합합니다:\n\n<div class=\"content-ad\"></div>\n\n- 작은 및 중간 규모의 웹 애플리케이션: Flask의 가벼우면서 미니멀한 특성 덕분에 작고 중간 규모의 웹 애플리케이션을 빠르고 효율적으로 개발하기에 이상적입니다.\n- 프로토타이핑 및 MVP 개발: Flask의 간결함과 유연성으로 인해 개발자들은 빠르게 아이디어를 프로토타입화하고 최소 실현 가능 제품(MVP)을 만들 수 있습니다. 이 과정에서 별다른 복잡한 프레임워크 없이 개발이 가능합니다.\n- RESTful API: Flask는 RESTful API를 쉽고 직관적으로 만들 수 있는 기능을 제공하여 백엔드 서비스 및 마이크로 서비스를 구축하는 데 인기가 있습니다.\n- 머신 러닝 및 데이터 과학 애플리케이션: Flask는 Python의 풍부한 과학 라이브러리와 도구(예: NumPy, Pandas, scikit-learn)와 잘 통합되어 있어 머신 러닝 및 데이터 과학 기능을 활용하는 웹 애플리케이션을 구축하는 데 적합합니다.\n- 신속한 개발: Flask의 간단함과 확장성을 통해 개발자들은 웹 애플리케이션을 빠르게 구축하고 배포할 수 있으며, 프로젝트 기한이 촉박하거나 신속한 반복이 필요한 경우에 좋은 선택지입니다.\n\n# Node.js 또는 Flask 선택하기\n\n![Python Flask vs Node.js Express](/assets/img/2024-06-23-PythonFlaskvsNodejsExpress_3.png)\n\n- 성능 요구사항: 애플리케이션이 뛰어난 성능을 요구하고 큰 수의 동시 요청을 처리해야 하는 경우, 이벤트 기반 및 논블로킹 아키텍처로 인해 Node.js(Express)가 더 나은 선택일 수 있습니다. 그러나 애플리케이션이 중간 성능을 필요로 하는 경우에도 Flask는 여전히 유효한 옵션이 될 수 있습니다.\n- 확장성 기대치: Node.js(Express)는 많은 동시 접속을 다룰 때 특히 잘 확장되는 능력으로 알려져 있습니다. 애플리케이션이 상당한 성장을 예상하고 증가하는 트래픽을 처리해야 하는 경우 Node.js가 더 적합할 수 있습니다. 반면, Flask는 본래 확장성이 떨어지지만 적절한 아키텍처와 배포 전략으로 가로 방향 스케일링이 가능합니다.\n- 개발팀의 전문성: 개발팀의 기술과 경험을 고려하세요. JavaScript에 능숙하고 Node.js 경험이 있는 팀인 경우 Express를 선택하면 기존 지식을 활용하고 학습 곡선을 줄일 수 있습니다. 반면, Python에 더 익숙한 팀이라면 Flask가 더 자연스러울 수 있습니다.\n- 생태계 및 라이브러리: 각 프레임워크에 대한 생태계 및 라이브러리의 가용성을 평가하세요. Node.js는 npm(노드 패키지 매니저)를 통해 다양한 패키지와 모듈이 제공되는 방대한 생태계를 가지고 있습니다. Python 프레임워크인 Flask는 데이터 과학 및 머신 러닝과 같은 분야에서 특히 Python의 풍부한 라이브러리와 도구로 이점을 가집니다.\n- 프로젝트 복잡도 및 규모: Flask의 간단함과 가벼운 특성으로 인해 작고 중간 규모의 프로젝트나 신속한 개발이 필요한 경우에 적합합니다. Node.js(Express)는 실시간 기능이나 마이크로서비스 아키텍처가 포함된 복잡하고 대규모 애플리케이션을 처리할 수 있습니다.\n- 다른 기술과의 통합: 사용할 다른 기술과 얼마나 잘 통합되는지 고려하세요. Node.js는 Angular, React, Vue.js와 같은 프론트엔드 기술과 원활하게 통합되어 있어 전체 스택 JavaScript 애플리케이션을 구축하는 데 좋은 선택입니다. Python 프레임워크인 Flask는 데이터 분석이나 머신 러닝과 관련된 애플리케이션에 적합하도록 Python의 과학적 라이브러리와 도구와 잘 통합됩니다.\n- 커뮤니티 지원 및 자원: 각 프레임워크의 커뮤니티 지원 및 자원을 살펴보세요. Node.js와 Flask는 활발한 커뮤니티와 포괄적인 문서, 자습서 및 온라인 자원을 보유하고 있습니다. 그러나 Node.js는 보급이 더 잘 되어 있기 때문에 더 많은 사용자 지원 및 제3자 패키지가 제공될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n대부분의 기술적인 결정과 마찬가지로, Node.js(Express)와 Flask 사이의 선택은 특정 프로젝트 요구 사항, 성능 요구사항, 확장성 기대치, 팀 전문성, 그리고 필요한 도구와 라이브러리의 생태계에 따라 다릅니다. 이러한 요소를 신중하게 평가하고 프로젝트의 목표와 제한 사항과 가장 잘 부합하는 것을 기반으로 알찬 결정을 내리는 것이 중요합니다.","ogImage":{"url":"/assets/img/2024-06-23-PythonFlaskvsNodejsExpress_0.png"},"coverImage":"/assets/img/2024-06-23-PythonFlaskvsNodejsExpress_0.png","tag":["Tech"],"readingTime":6},{"title":"이미지에서 표를 JSON으로 추출하는 GPT-4 사용 방법","description":"","date":"2024-06-23 13:17","slug":"2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4","content":"\n\n<img src=\"/assets/img/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4_0.png\" />\n\nOpenAI는 모든 인류에 이익을 제공하는 인공 일반 지능(AGI)을 보장하기 위해 헌신하는 선구적인 인공 지능 연구 기관입니다. 2015년 12월 일론 머스크, 샘 알트만, 그리고 다른 유명한 기술 리더들에 의해 설립된 OpenAI는 안전하고 높은 능력을 가진 AI 시스템을 만드는 것을 목표로 합니다.\n\nGPT(생성 사전 학습 트랜스포머)는 OpenAI가 개발한 일련의 언어 모델로, 인간과 유사한 텍스트를 이해하고 생성하는 데 사용됩니다. GPT-1부터 시작해 각 버전은 규모, 정확도, 성능 면에서 점진적으로 개선되었습니다. GPT-2는 더 긴 단락을 통해 일관된 및 맥락에 맞는 텍스트를 생성할 수 있는 능력을 보여주었으며, GPT-3는 1750억 개의 매개변수로 이를 크게 확장하여 극소량의 훈련으로 여러 언어 작업을 수행할 수 있는 능력을 가졌습니다.\n\n최신 버전인 GPT-4는 더 높은 정확도, 일관성, 다재다능성을 가진 이러한 능력을 더욱 향상시킵니다. 이는 콘텐츠 생성부터 고객 서비스, 복잡한 문제 해결까지 다양한 응용 분야에서 뛰어난 성과를 내며, AI 기술의 주요 발전을 대표합니다.\n\n<div class=\"content-ad\"></div>\n\n## 실제 시나리오\n\n우리의 목표는 이미지에서 테이블 데이터를 읽어와 Node.js를 사용하여 JSON으로 변환하는 것입니다.\n\n입력:\n\n![이미지](/assets/img/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4_1.png)\n\n<div class=\"content-ad\"></div>\n\n이상적인 결과는\n\n```js\n message: {\n      role: 'assistant',\n      content: \"이미지에서 인간이 읽을 수 있는 JSON 형식으로 상세 정보를 보여드립니다:\\n\" +\n        '\\n' +\n        'json\\n' +\n        '{\\n' +\n        '  \"transactions\": [\\n' +\n        '    {\\n' +\n        '      \"date\": \"01-04-2023\",\\n' +\n        '      \"particulars\": \"B/F\",\\n' +\n        '      \"cheque_no\": \"\",\\n' +\n        '      \"withdrawals\": 0.00,\\n' +\n        '      \"deposits\": 0.00,\\n' +\n        '      \"autosweep\": 0.00,\\n' +\n        '      \"reverse_sweep\": 0.00,\\n' +\n        '      \"balance\": \"35,024.54 잔액\"\\n' +\n        '    },\\n' +\n        ...\n        '    {\\n' +\n        '      \"date\": \"29-04-2023\",\\n' +\n        '      \"particulars\": \"UPI/311976583935/Net Bank/8460615089@ybI/Karur Vysya\",\\n' +\n        '      \"cheque_no\": \"\",\\n' +\n        '      \"withdrawals\": 0.00,\\n' +\n        '      \"deposits\": 5,000.00,\\n' +\n        '      \"autosweep\": 0.00,\\n' +\n        '      \"reverse_sweep\": 0.00,\\n' +\n        '      \"balance\": \"21,104.54 잔액\"\\n' +\n        '    }\\n' +\n        '  ],\\n' +\n        '  \"totals\": {\\n' +\n        '    \"withdrawals\": 27600.00,\\n' +\n        '    \"deposits\": 13680.00,\\n' +\n        '    \"autosweep\": 0.00,\\n' +\n        '    \"reverse_sweep\": 0.00,\\n' +\n        '    \"balance\": \"21,104.54 잔액\"\\n' +\n        '  }\\n' +\n        '}\\n' +\n        ''\n    },\n```\n\n단계별로 진행해 봅시다:\n\n단계 1: 시스템에 Node.js를 설치하세요.\n\n<div class=\"content-ad\"></div>\n\nStep 2: 새 디렉토리를 만들고 프로젝트를 설정하십시오.\n\n```js\nmkdir image-analysis\ncd image-analysis\nnpm init -y\nnpm install openai\n```\n\nStep 3: 새 파일 index.js를 만드세요.\n\n```js\nconst fs = require(\"fs\");\nconst OpenAI = require(\"openai\");\n//더 나은 보안을 위해 API 키는 .env 파일에 보관하십시오.\nconst OPENAI_API_KEY = \"your-api-key\";\nconst openai = new OpenAI({\n  apiKey: OPENAI_API_KEY,\n});\n\n// 이미지를 base64 문자열로 읽는 함수\nfunction encodeImage(imagePath) {\n  const imageData = fs.readFileSync(imagePath);\n  return imageData.toString('base64');\n}\n\nasync function main() {\n  const imagePath = \"path-of-your-image\";\n  const base64Image = encodeImage(imagePath);\n\n  const response = await openai.chat.completions.create({\n    model: \"gpt-4o\", \n    messages: [\n      {\n        role: \"system\",\n        content: \"이미지의 각 행과 열의 자세한 정보를 인간이 읽기 쉬운 형식의 멋진 JSON 형식으로 공유해 주세요.\",\n      },\n      {\n        role: \"user\",\n        content: [\n          { type: \"text\", text: \"이 이미지를 분석해 주세요:\" },\n          { type: \"image_url\", image_url: { url: `data:image/png;base64,${base64Image}` } },\n        ],\n      },\n    ],\n  });\n\n  console.log(response.choices);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n4단계: 스크립트 실행하기\n\n```js\nnode index.js\n```\n\n출력:\n\n<img src=\"/assets/img/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n최종 솔루션에 도달하기 전 직면한 문제들:\n\n문제 1 - openai.createImage이(가) 함수가 아닙니다\n이 문제는 GPT-4에서 createImage 메서드가 사용되지 않기 때문에 발생합니다. OpenAI API에서는 더 이상 이미지를 처리하거나 생성하기 위해 이 메서드를 지원하지 않습니다. 대신, createCompletion 또는 createChatCompletion과 같은 다른 메서드를 사용하여 GPT-4 모델과 상호 작용할 수 있습니다. 이러한 메서드를 사용하면 이미지 데이터를 base64 문자열로 인코딩하여 텍스트 프롬프트 내에서 전달할 수 있습니다.\n\n```js\nconst response = await openai.createImage({\n^\n\nTypeError: openai.createImage is not a function\n```\n\n문제 2: openai 버전 4 변환.\n\n<div class=\"content-ad\"></div>\n\n오픈AI의 버전 4 변환 문제와 이전 버전 방법이 작동하지 않는 문제는 버전 간의 기반이 되는 아키텍처 및 API 기능에 중요한 변화가 있기 때문에 발생합니다. 이러한 변화로 인해 호환성 문제가 발생할 수 있으며, 이전 버전과 작동했던 기존 방법 및 통합이 버전 4에서 작동하지 않을 수 있습니다. 결과적으로 개발자들은 기존 방법을 사용하려고 할 때 오류나 예상치 못한 동작을 만날 수 있으며, 이에 대응하기 위해 코드를 업데이트하고 새 버전의 사양 및 모범 사례에 적응해야 할 수도 있습니다.\n\n```js\nconst { Configuration, OpenAIApi } = require(\"openai\");\n\n// const readline = require(\"readline\");\n\nconst configuration = new Configuration({\napiKey: \"API_KEY\",\n});\n\nTypeError: Configuration is not a constructor\nat Object. (D:\\nodeJS-chatBot\\index.cjs:5:23)\nat Module._compile (node:internal/modules/cjs/loader:1226:14)\nat Module._extensions…js (node:internal/modules/cjs/loader:1280:10)\nat Module.load (node:internal/modules/cjs/loader:1089:32)\nat Module._load (node:internal/modules/cjs/loader:930:12)\nat Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\nat node:internal/main/run_main_module:23:47\n```\n\n이 문제에 대한 해결책을 오픈AI 커뮤니티에서 찾았습니다\nhttps://chatgpt.com/share/b175130a-0d77-465e-8187-59b92590df8b\n\n문제점 3- gpt-4-vision-preview 모델이 더 이상 사용되지 않습니다\n\n<div class=\"content-ad\"></div>\n\n\n![이미지 추출 표](/assets/img/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4_3.png)\n\n문제 4 - GPT-4로 이미지를 직접 업로드할 수 없어 GPT-3.5-turbo로 전환해야 하는 이유는, GPT-4가 이미지 데이터 입력을 처리하는 현재 능력 부족 때문입니다. 이 제한으로 인해 GPT-4를 통해 포괄적인 데이터 처리에 의존하는 개발자는 직접 이미지 업로드가 필요한 작업에는 모델을 전환해야 합니다. 이러한 전환은 작업 흐름을 복잡하게 만들고 개발 복잡성을 증가시키며 두 모델 간 데이터 처리 및 응답 생성에 불일치 가능성을 가져올 수 있습니다. 이러한 중단은 지연을 유발하고 원활한 사용자 경험을 유지하는 데 노력이 더 필요할 수 있습니다.\n\n```js\nreturn new BadRequestError(status, error, message, headers); ^ BadRequestError: 400 'image'가 잘못된 값입니다. 지원되는 값은 'text', 'image_url', 'audio_url'입니다.\nconst fs = require(\"fs\"); const OpenAI = require(\"openai\");\nconst OPENAI_API_KEY = \"\"; const openai = new OpenAI({ apiKey: OPENAI_API_KEY, });\nasync function main() { const imageData = fs.readFileSync(\"/home/akash/Downloads/test.png\");\nconst response = await openai.chat.completions.create({ model: \"gpt-4o\", instructions: \"이미지의 각 행과 열에 대한 자세한 정보를 아름답게 JSON 형식으로 공유해주세요.\", messages: [ { role: \"user\", content: [ { type: \"text\", text: \"이 이미지를 분석해주세요:\" }, { type: \"image\", image: imageData }, ], }, ], });\nconsole.log(response.data.result); }\nmain();\n경로 대신 이미지 URL을 제공하십시오: https://www.perfectxl.com/wp-content/uploads/2020/07/pivot-table-excel-source-data.png.webp\n```\n\n문제 5: 이미지에서 JSON으로 변환하기 위해 GPT-3.5-turbo를 사용하는 것은 여러 문제를 발생시킬 수 있습니다. 이미지 데이터 처리에 대한 이 모델의 본래 한계로 인해 변환 과정에서 정확성 문제가 발생할 수 있어 JSON 출력물이 불완전하거나 잘못될 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 5 문제 1 해결책\n\n**L’Oreal Paris❌**\n\n**gpt-4o✅**\n\nGPT-4은 로컬 이미지를 효율적으로 Base64 인코딩으로 변환한 다음 데이터를 구문 분석하여 이미지를 JSON으로 변환하는 도구입니다. Base64 인코딩을 사용함으로써 GPT-4은 이미지 데이터가 텍스트 친화적 형식으로 정확하게 표현되어 후속 처리 단계가 간단해지도록 보장합니다. 이 방법을 통해 다른 모델 간 전환을 줄이고 개발 워크플로우를 최적화하여 일관성을 향상시킵니다. 또한 GPT-4의 강건성은 변환 프로세스의 신뢰성과 정확성을 향상시켜 보다 정확한 JSON 출력물을 제공합니다. 이 방식은 코드 유지보수를 간편화할 뿐만 아니라 응용 프로그램 내에서 이미지 데이터를 처리하는 효율성과 효과성을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\nGitHub에서 예제 프로젝트를 찾을 수 있어요.\n\n제 글을 읽어 주셔서 감사합니다. 추가로 더 얘기 나 질문이 있으시면 언제든지 연락해 주세요!","ogImage":{"url":"/assets/img/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4_0.png"},"coverImage":"/assets/img/2024-06-23-ExtractingTablesfromImagestoJSONUsingGPT-4_0.png","tag":["Tech"],"readingTime":8},{"title":"Nodejs에서 SSO Single Sign-On 이해하기 구현 방법과 사례 설명","description":"","date":"2024-06-23 13:16","slug":"2024-06-23-UnderstandingSSOSingleSignOninNodejs","content":"\n\n싱글 사인온(SSO)은 현대 웹 애플리케이션에서 핵심 구성 요소로 사용되며 사용자 인증을 간소화하고 보안을 향상시킵니다. 이 블로그 포스트에서는 OAuth 2.0 및 OpenID Connect와 같은 인기있는 인증 프로토콜을 활용하여 Node.js 애플리케이션에 SSO를 구현하는 방법을 살펴보겠습니다.\n\n![UnderstandingSSOSingleSignOninNodejs](/assets/img/2024-06-23-UnderstandingSSOSingleSignOninNodejs_0.png)\n\n## 싱글 사인온(SSO)이란?\n\n싱글 사인온은 사용자가 한 번 인증하면 각각의 애플리케이션이나 서비스에 다시 로그인할 필요 없이 여러 애플리케이션 또는 서비스에 접근할 수 있는 기능을 말합니다. 이는 사용자 경험을 향상시키는 데에 그치지 않고 조직이 인증과 권한 부여를 중앙 집중화하여 관리를 간소화합니다.\n\n<div class=\"content-ad\"></div>\n\nSSO가 어떻게 동작하는지 단계별로 이해해 봅시다:\n\n- 사용자가 보호된 리소스에 액세스하고 서비스 제공자(SP)에 의해 신원 공급자(IdP)로 리디렉션됩니다.\n- 사용자는 자격 증명을 사용하여 IdP에서 인증합니다.\n- IdP는 사용자의 신원을 확인하는 보안 토큰 또는 주장을 발급합니다.\n- 사용자는 토큰을 가지고 SP로 돌아갑니다.\n- SP는 토큰의 진위 및 무결성을 확인합니다.\n- 유효한 경우, 리소스에 대한 액세스가 허용됩니다.\n- 선택 사항: SP 도메인 내에서 사용자를 위한 세션이 설정됩니다.\n- 신속한 인증을 통해 사용자는 자격 증명을 다시 입력하지 않고 여러 리소스에 액세스할 수 있습니다.\n- 동시 로그아웃을 위해 모든 서비스에서 로그아웃하는 단일 로그아웃이 제공될 수 있습니다.\n- SSO는 사용자 경험을 향상시키고, 마찰을 줄이며, 응용 프로그램 간에 보안을 유지합니다.\n\n![이미지](/assets/img/2024-06-23-UnderstandingSSOSingleSignOninNodejs_1.png)\n\n# SSO 전략이란?\n\n<div class=\"content-ad\"></div>\n\nSingle Sign-On (SSO) 전략은 적절한 인증 프로토콜 및 신원 제공자(IdP) 선택, SSO 기능을 애플리케이션에 통합, 사용자 교육 및 훈련, 강력한 보안 조치 구현, 지속적인 모니터링 및 유지보수, 확장 가능성 계획, 사용자 경험 최적화, 규정 준수 및 거버넌스 요구 사항 준수를 포함합니다. 요구 사항을 평가하고 적합한 프로토콜과 IdP를 선택하며 매끄럽게 통합하고 사용자를 교육하고 보안을 보장하며 성능을 모니터링하고 확장 가능성을 계획하고 사용자 경험을 최적화하고 규정 준수를 유지함으로써 기관은 통합된 SSO 전략을 수립할 수 있습니다. 이를 통해 인증 프로세스를 강화하고 보안을 강화하며 애플리케이션 생태계 전반에서 사용자 만족도를 향상시킬 수 있습니다.\n\n# 왜 SSO가 중요한가\n\nSSO를 구현하면 여러 가지 이점이 있습니다:\n\n- 향상된 사용자 경험: 사용자는 여러 세트의 자격 증명을 기억할 필요가 없어서 마찰을 줄이고 사용 용이성을 향상시킵니다.\n- 향상된 보안: 중앙화된 인증은 암호 관련 보안 위반 위험을 줄이고 사용자 액세스에 대한 더 나은 제어를 가능케 합니다.\n- 효율적인 관리: 조직은 정책을 중앙에서 강제하고 관리 오버헤드를 줄이는 방식으로 사용자 액세스를 더 효과적으로 관리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Node.js에서 SSO 구현하기\n\nNode.js 애플리케이션에서 SSO 구현 세부사항을 살펴보겠습니다.\n\n## 1. SSO 제공 업체 선택\n\nGoogle, Facebook과 같은 OAuth 2.0 제공 업체 또는 passport.js와 같은 라이브러리를 사용하여 사용자 정의 솔루션과 같은 여러 SSO 제공 업체가 있습니다. 이 예제에서는 SSO 제공자로 Google을 사용하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## 2. 인증 서버 설정하기\n\n먼저, Node.js와 Express를 사용하여 인증 서버를 설정해 봅시다:\n\n```js\nconst express = require('express');\nconst passport = require('passport');\nconst GoogleStrategy = require('passport-google-oauth20').Strategy;\n\nconst app = express();\n\npassport.use(new GoogleStrategy({\n    clientID: '********your-client-id********',\n    clientSecret: '********your-client-secret********',\n    callbackURL: '/auth/google/callback'\n  },\n  (accessToken, refreshToken, profile, done) => {\n    return done(null, profile);\n  }\n));\n\napp.get('/auth/google',\n  passport.authenticate('google', { scope: ['profile', 'email'] }));\n\napp.get('/auth/google/callback',\n  passport.authenticate('google', { failureRedirect: '/login' }),\n  (req, res) => {\n    res.redirect('/');\n  }\n);\n\napp.listen(3000, () => {\n  console.log('서버가 3000번 포트에서 실행 중입니다');\n});\n```\n\n위 코드에서:\n\n<div class=\"content-ad\"></div>\n\n- Passport.js를 GoogleStrategy와 함께 구성합니다.\n- 인증을 시작하고 콜백을 처리하는 라우트를 정의합니다.\n\n## 3. SSO 공급자와 통합\n\n다음으로, Node.js 애플리케이션을 SSO 공급자의 적절한 자격 증명으로 구성해야 합니다. Google의 경우 Google 개발자 콘솔에서 프로젝트를 생성하여 클라이언트 ID와 클라이언트 비밀을 획득할 수 있습니다.\n\n## 4. 라우트 보안화\n\n<div class=\"content-ad\"></div>\n\n인증이 필요한 경로를 보호하기 위해 사용자가 인증되었는지 확인하는 미들웨어를 만들 수 있습니다:\n\n```js\nfunction ensureAuthenticated(req, res, next) {\n  if (req.isAuthenticated()) {\n    return next();\n  }\n  res.redirect('/login');\n}\n\napp.get('/profile', ensureAuthenticated, (req, res) => {\n  res.render('profile', { user: req.user });\n});\n```\n\n이 코드에서:\n\n- ensureAuthenticated 미들웨어는 Passport.js의 isAuthenticated 메서드를 사용하여 사용자가 인증되었는지 확인합니다.\n- 사용자가 인증되었으면 다음 미들웨어 또는 경로 핸들러로 진행하고, 그렇지 않으면 로그인 페이지로 리다이렉트됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 5. 사용자 세션 관리\n\n사용자 세션을 관리하기 위해 express-session 미들웨어를 Passport.js와 함께 사용할 수 있습니다:\n\n```js\nconst session = require('express-session');\n\napp.use(session({\n  secret: 'your-secret-key',\n  resave: false,\n  saveUninitialized: false\n}));\n\napp.use(passport.initialize());\napp.use(passport.session());\n\npassport.serializeUser((user, done) => {\n  done(null, user);\n});\n\npassport.deserializeUser((obj, done) => {\n  done(null, obj);\n});\n```\n\n# SSO에서의 안전성 (SSO는 안전한가요?)\n\n<div class=\"content-ad\"></div>\n\nSingle Sign-On (SSO)은 올바르게 구현될 때 안전한 인증 방법이 될 수 있어요. SSO의 안전은 선택된 인증 프로토콜과 Identity Provider (IdP)의 신뢰성을 포함한 여러 요소에 달려 있어요. OAuth 2.0 또는 OpenID Connect와 같은 인증 프로토콜은 보안 기능과 기존 시스템과의 호환성을 고려하여 신중하게 선택돼야 해요. 또한 사용자를 인증하고 보안 토큰을 발급하는 IdP는 신뢰할 수 있어야 하며, 암호화 및 다중 인증 (MFA)과 같은 견고한 보안 조치를 채택해야 해요. 토큰의 안전한 전송, 저장 및 유효성 검사는 무단 액세스를 방지하기 위해 핵심적인 역할을 해요. 적절한 세션 관리, 안전한 구현 관행 준수, 그리고 보안 위협 인식 및 회피에 대한 사용자 교육은 SSO의 보안 수준에 추가적으로 기여해요.\n\n하지만 SSO는 편의성과 효율성을 제공하는 반면, 조직이 대처해야 할 잠재적인 보안 위험을 도입하기도 해요. 세션 탈취나 피싱 공격과 같은 취약점은 SSO 시스템을 침해할 수 있어요. 지속적인 모니터링, 감사 및 사용자 인식 훈련은 보안 사고를 신속하게 감지하고 대응하는 데 필수적이에요. 올바른 보안 조치를 채택함으로써, 조직은 SSO의 혜택을 활용하면서 보안 위험을 효과적으로 완화할 수 있어요. 사용자 및 조직을 위해 시스템과 데이터의 기밀성, 무결성 및 가용성을 유지하는 것은 사용자와 조직 모두에게 안전한 SSO 환경을 보장하는 데 중요해요.\n\n# 결론\n\nNode.js 애플리케이션에 Single Sign-On을 구현하면 보안이 강화되며 사용자 인증이 간단해지고 전반적인 사용자 경험이 향상됩니다. Passport.js와 같은 인기있는 인증 프로토콜 및 라이브러리를 활용함으로써, 개발자들은 SSO 기능을 애플리케이션에 원활하게 통합할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 추가 자료\n\n- Passport.js 문서\n- Google OAuth 2.0 문서","ogImage":{"url":"/assets/img/2024-06-23-UnderstandingSSOSingleSignOninNodejs_0.png"},"coverImage":"/assets/img/2024-06-23-UnderstandingSSOSingleSignOninNodejs_0.png","tag":["Tech"],"readingTime":6},{"title":"사용하지 않을 때에도 웹 서비스 활동 유지하는 방법","description":"","date":"2024-06-23 13:15","slug":"2024-06-23-HackforRenderWebservicesspindownduetoinactivity","content":"\n\n백엔드 응용 프로그램을 취미로 배포할 때, Render는 간편성과 기능 세트로 인해 인기 있는 선택지입니다. 그러나 Render의 일반적인 문제 중 하나는 사용되지 않을 경우 무료 인스턴스가 중단될 수 있다는 것입니다. 이는 인스턴스를 다시 배포해야 할 때 최대 1분까지 응답이 지연되는 결과를 가져옵니다. Render에서 이러한 동작에 대해 명확히 설명되어 있습니다:\n\n![image](/assets/img/2024-06-23-HackforRenderWebservicesspindownduetoinactivity_0.png)\n\n**문제점**\n사용되지 않을 때 Render 인스턴스가 중단되어 서버가 일정 시간 후에 액세스될 때 지연이 발생합니다. 이는 응답 시간이 느려지면 사용자 경험에 영향을 미칠 수 있어 특히 거슬리는 문제일 수 있습니다.\n\n**해결책**\n사이트를 사용하지 않는 경우에도 인스턴스를 활성 상태로 유지하려면 app.js 또는 index.js 파일에 자체 참조 리로더를 추가할 수 있습니다. 이를 통해 정기적으로 서버에 핑을 보내 인스턴스가 중단되지 않도록 할 수 있습니다.\n\n다음은 이 작업을 수행하는 간단한 코드 스니펫입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconst url = `https://yourappname.onrender.com/`; // 사용 중인 Render URL로 변경\nconst interval = 30000; // 간격을 밀리초 단위로 지정 (30초)\n\nfunction reloadWebsite() {\n  axios.get(url)\n    .then(response => {\n      console.log(`새로고침 시간: ${new Date().toISOString()}: 상태 코드 ${response.status}`);\n    })\n    .catch(error => {\n      console.error(`새로 고침 에러 시간: ${new Date().toISOString()}:`, error.message);\n    });\n}\n\n\nsetInterval(reloadWebsite, interval);\r\n```\n\n작동 방식\n\n- 자체 참조 새로 고침: 이 코드 스니펫은 서버에 매 30초마다 핑을 보내는 간격을 설정합니다.\n- 유지 및 활성 상태 유지: 서버에 지속적으로 핑을 보내면 활성 상태를 유지하고 중단되지 않도록 합니다.\n- 로그: 주기적인 확인을 볼 수 있고 서버가 활성 상태인지 확인할 수 있는 로그를 모니터링할 수 있습니다.\n\n구현\n\n<div class=\"content-ad\"></div>\n\n- 코드 추가: 위 코드를 app.js 또는 index.js 파일에 추가합니다.\n- 서버 시작: 앱을 Render에 배포하세요.\n- 모니터링: Render 대시보드의 로그를 확인하여 서버가 정기적으로 핑되는지 확인하세요.\n\n장점\n\n- 다운타임 없음: 서버가 활성 상태로 유지되어 빠른 응답을 제공합니다.\n- 간편한 솔루션: 복잡한 설정 없이 쉽게 구현할 수 있습니다.\n- 확장성: 소규모에서 중규모의 취미 프로젝트에 잘 작동합니다.\n\n다중 백엔드 관리\n다중 백엔드가 있는 프로젝트의 경우, 리로더를 단일 백엔드로 통합할 수 있습니다. 이 접근 방식은 각 백엔드가 자체 리로더를 필요로하지 않고 모든 인스턴스가 활성 상태로 유지되도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n결론\n백엔드에 간단한 다시로더 스크립트를 추가함으로써, Render 인스턴스가 비활성화로 인해 종료되는 것을 방지할 수 있습니다. 이를 통해 서버가 반응성을 유지하여 취미 프로젝트에 더 나은 사용자 경험을 제공할 수 있습니다. 이 해결책은 소규모부터 중규모 프로젝트에 효과적이며 서버의 활동을 지속적으로 유지하는 데 도움이 됩니다.\n\n참고:\n\n- Github\n\n도움이 되셨기를 바랍니다! 즐거운 배포되길 바랍니다.","ogImage":{"url":"/assets/img/2024-06-23-HackforRenderWebservicesspindownduetoinactivity_0.png"},"coverImage":"/assets/img/2024-06-23-HackforRenderWebservicesspindownduetoinactivity_0.png","tag":["Tech"],"readingTime":2},{"title":"React Native CICD GitHub Actions와 App Center 사용하는 방법","description":"","date":"2024-06-23 13:14","slug":"2024-06-23-ReactNativeCICDGitHubActionsAppCenter","content":"\n\nReact Native 프로젝트에 대한 Continuous Integration 및 Continuous Deployment (CI/CD) 설정은 빌드, 테스트 및 배포 프로세스 자동화를 포함합니다. 이렇게 React Native 프로젝트를 CI/CD하려면 인기 있는 도구인 CI용 GitHub Actions 및 CD용 App Center를 사용하는 기본 예제가 있습니다:\n\n![React Native CI/CD](/assets/img/2024-06-23-ReactNativeCICDGitHubActionsAppCenter_0.png)\n\n1. GitHub 저장소 설정:\n- 이미 하지 않았다면 React Native 프로젝트용 GitHub 저장소를 만듭니다.\n- React Native 프로젝트 코드를 이 저장소에 푸시합니다.\n\n2. CI용 GitHub Workflow 만들기:\n- 저장소에 `.github/workflows/ci.yml` 파일을 만듭니다.\n- GitHub Actions를 사용하여 CI 워크플로우를 정의하기 위해 이 파일을 구성합니다. 다음은 기본 예제입니다:\n\n<div class=\"content-ad\"></div>\n\n```yaml\n이름: CI\n\n활성화:\n  푸시:\n    브랜치: [main]\n\n작업:\n  빌드:\n    실행: ubuntu-latest\n\n    단계:\n      - 이름: 코드 체크아웃\n        사용: actions/checkout@v2\n\n      - 이름: Node.js 설정\n        사용: actions/setup-node@v1\n        with:\n          node-version: '14.x'\n\n      - 이름: 종속성 설치\n        실행: npm install\n\n      - 이름: 빌드\n        실행: npm run build\n\n      - 이름: 테스트\n        실행: npm test\n```\n\n3. CD를 위해 앱 센터 설정:\n- 이미 Microsoft 앱 센터에 계정이 없다면 계정을 설정하세요.\n- React Native 프로젝트에 대응하는 앱 센터에서 앱을 생성하세요.\n\n4. App Center와 CD 통합:\n- 개발 환경에서 App Center CLI를 설치하세요.\n- CLI를 App Center와 인증하세요.\n- React Native 프로젝트에 App Center를 통합하세요:\n\n```bash\nappcenter login\nappcenter apps create -d \"Your React Native App\" -o \"React Native\" -p React-Native\n```\n\n<div class=\"content-ad\"></div>\n\n— App Center에서 제공하는 지침에 따라 React Native 프로젝트에 SDK를 통합하여 충돌 보고, 분석 및 배포 기능을 활성화하세요.\n\n5. CD 파이프라인 구성:\n— 자동 배포를 위해 App Center에 릴리스 파이프라인을 생성하세요.\n— 새 빌드 아티팩트가 생성된 경우(예: CI 성공 후) 파이프라인을 트리거하도록 구성하세요.\n\n6. CD 트리거를 위한 GitHub Workflow 업데이트:\n— 성공한 빌드 후 App Center CD를 트리거하도록 GitHub Actions workflow를 수정하세요:\n\n```js\n...\njobs:\n  build:\n    ...\n    steps:\n      ...\n\n  deploy:\n    needs: build\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Trigger App Center Release\n        run: appcenter codepush release-react -a <ownerName>/<appName> -d <deploymentName>\r\n```\n\n<div class=\"content-ad\"></div>\n\n7. 변경 내용 커밋 및 푸시하기:\n- `.github/workflows/ci.yml` 및 다른 관련 파일에 변경 내용을 커밋합니다.\n- 변경 사항을 GitHub 저장소에 푸시합니다.\n\n위 단계를 통해 React Native 프로젝트를 위한 기본 CI/CD 파이프라인을 설정했습니다. 저장소에 변경 사항을 푸시할 때마다 GitHub Actions가 자동으로 빌드하고 테스트를 실행합니다. 성공적으로 완료되면, App Center가 앱을 지정된 배포 환경으로 배포합니다. 해당 설정을 프로젝트 요구사항과 선호에 맞게 조정하고 확장해보세요.","ogImage":{"url":"/assets/img/2024-06-23-ReactNativeCICDGitHubActionsAppCenter_0.png"},"coverImage":"/assets/img/2024-06-23-ReactNativeCICDGitHubActionsAppCenter_0.png","tag":["Tech"],"readingTime":3},{"title":"자바스크립트를 이제 그만 사용해야 하는 이유 5가지","description":"","date":"2024-06-23 13:14","slug":"2024-06-23-StopusingJavaScript","content":"\n\n![Table](/assets/img/2024-06-23-StopusingJavaScript_0.png)\n\n웹 개발을 시작한 이후로 JavaScript를 열광하는 팬이었어요. 하지만 JavaScript의 결함을 깨닫게 되었던 것은 글쓰기와 잠재적 책을 집필하기 시작한 이후였어요.\n\n마이크로소프트의 TypeScript가 그 결함을 해결하려고 노력했지만, 각자의 단점이 있었죠. 양 언어의 일반적인 차이점을 표로 보여드리고, 다음 프로젝트에 어떤 언어를 선택해야 하는지에 대해 깊이 알아보겠어요.\n\n# 일반적인 차이점\n\n<div class=\"content-ad\"></div>\n\n기초부터 시작해보죠. 많이 읽기 귀찮은 사람들을 위한 표도 준비했어요. 이 중 일부는 글의 후반부에서 해당 내용과 같은 설명을 이해해야 합니다.\n\n![JavaScript Table](/assets/img/2024-06-23-StopusingJavaScript_1.png)\n\n# JavaScript\n\n인터넷이 1990년대에 형성되기 시작할 때 JavaScript가 탄생했어요. 이는 Java의 성공에서 영감을 얻은 후 1995년에 나왔어요.\n\n<div class=\"content-ad\"></div>\n\n넷스케이프, 모직라의 전신,는 상호 작용형 웹 애플리케이션을 위해 JavaScript를 만들었습니다. 브렌단 아이크는 많은 결함이 있는 JavaScript를 몇 일 안에 완성했습니다.\n\n![이미지](/assets/img/2024-06-23-StopusingJavaScript_2.png)\n\n지금으로부터 빠르게 전진하면 TypeScript가 나옵니다. 그 결함들? 예, 누군가 그것들을 고쳐야 한다고 판단했습니다. 하지만 JavaScript가 도움이 되는 경우도 있습니다.\n\n## TypeScript보다 좋은 이유\n\n<div class=\"content-ad\"></div>\n\n- TypeScript은 작은 프로젝트에 적합하지 않습니다. 이때 JavaScript가 빛을 발합니다. 이는 Microsoft 개발자들이 그런 식으로 설계했기 때문입니다. 사이드 프로젝트에서는 정적 유형, 인터페이스 등이 필요하지 않습니다.\n- TypeScript 기반 프로젝트에는 시간 비용이 들어간다는 것이 JavaScript보다 더 나은 이유입니다. TS는 브라우저가 이해할 수 있게 TS 코드를 JS 코드로 변환하는 데 꽤 많은 시간이 걸립니다. 이러한 추가 비용은 작은 프로젝트에 값어치가 없습니다.\n- 작은 코드 스니펫에서는 JavaScript가 네이티브 브라우저에서 디버깅하기 쉽습니다.\n- 프로토타입에는 JavaScript가 더 나은데, TS나 기타 추가 비용에 드는 시간을 감당할 수 없는 작은 프로젝트와 같습니다.\n- 현재 JavaScript를 사용하고 있는 대규모 프로젝트에 대해서는 계속하여 JavaScript를 사용할 수 있습니다. 코드를 TypeScript로 리팩토링하는 비용이 그렇게 가치 있는 것은 아닐 수도 있습니다.\n\n이제 JavaScript가 머리아픈 일의 원인이 되는 경우를 설명해보겠습니다.\n\n# TypeScript\n\n만약 여러분이 인터넷에서 JavaScript를 없애는 해결책이 없는 이유에 궁금해 한다면, 그 이유는 JavaScript가 모든 웹 브라우저의 핵심이기 때문입니다. 웹 애플리케이션을 구축하는 데 필요한 세 가지 기술(HTML, CSS 및 JS) 중 하나입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-StopusingJavaScript_3.png\" />\n\n그것을 대체하는 대신, 개발자들은 그것을 개선하는 데 집중했습니다. 그 결과 TypeScript가 탄생했습니다. JavaScript의 창시자 인 Brendan Eich도 TypeScript를 JavaScript에 유익한 부가 기능으로 간주합니다.\n\n## JavaScript보다 나은 이유\n\n- JavaScript는 호환성 문제를 가지고 있습니다. 여러 브라우저에서 ECMA 표준의 구현이 다르며, JS 코드를 파싱하기 위해 여러 해석기가 사용됩니다. 일부 브라우저는 여전히 이전 버전의 ECMAScript를 사용하고 있습니다. TypeScript를 사용하면 새로운 JavaScript 기능을 사용하여 이전 브라우저와 NodeJS 버전과 함께 사용할 수 있습니다.\n- TypeScript는 JavaScript의 상위 집합입니다. TypeScript의 기능을 사용하지 않더라도 기술적으로 JavaScript 코드는 TypeScript 코드가 되고 그 반대도 성립합니다. TypeScript에는 브라우저를 위해 TS 코드를 JS로 변환해주는 컴파일러가 있습니다.\n- JavaScript는 동적으로 유형이 지정되지 않아 예상치 못한 오류가 발생할 수 있습니다. 이는 데이터의 유형을 정의할 필요가 없다는 뜻입니다. TypeScript는 JavaScript에 정적 유형을 추가하여 변수, 함수 매개변수 및 반환 값의 데이터 유형을 지정할 수 있도록 하여 개발자가 개발 과정 초기에 유형 관련 오류를 미연에 방지할 수 있습니다.\n- TypeScript를 사용하면 코드를 ES3 또는 그 이하의 이전 JavaScript 버전으로 변환할 수 있습니다. WebPack과 함께 사용하면 레거시 브라우저를 지원하는 데 도움이 됩니다.\n- TypeScript는 인터페이스, 상속 기능, 캡슐화 능력 및 클래스를 제공합니다. 객체 지향 배경을 가진 개발자들에게 JavaScript로 전환하기가 더 쉽습니다. 새로운 환경을 배울 필요가 없고 기존의 습관을 유지할 수 있습니다.\n- TypeScript를 사용하면 함수의 선택적 매개변수와 해당 선택적 또는 필수 매개변수의 기본 값을 설정할 수 있습니다.\n- TypeScript에는 데코레이터가 있습니다. 클래스, 메서드 및 속성에 메타데이터를 첨부할 수 있습니다. 이는 의존성 주입 및 관점 지향 프로그래밍에 도움이 됩니다.\n- TypeScript에는 제네릭이 있습니다. 구성 요소가 하나뿐만 아니라 여러 데이터 유형을 지원할 수 있습니다. Java와 같은 언어는 이미 제네릭을 지원합니다. 이를 통해 개발자는 기존 및 미래에 사용할 수 있는 구성 요소를 작성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nTypeScript은 유연성과 확장성을 제공합니다. 이 차별화로 보아 미래를 향해 나아가면서도 역호환성을 생각하고 있음을 알 수 있습니다. JavaScript가 실패하는 부분에서 TypeScript가 잘 해내고 있는 것이죠.\n\n의견을 나누고 싶다면 댓글을 달아주세요. 다른 사항을 변경해야 한다면 알려주세요. 이메일 director@afankhan.com (Afan Khan LLC) 으로 언제든지 연락할 수 있습니다. 그렇지 않으면 트위터(@whyafan)를 통해서 가장 쉽게 연락할 수 있습니다.\n\n# 쉬운 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n<div class=\"content-ad\"></div>\n\n- 작가를 박수로 응원하고 팔로우하기 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-23-StopusingJavaScript_0.png"},"coverImage":"/assets/img/2024-06-23-StopusingJavaScript_0.png","tag":["Tech"],"readingTime":4}],"page":"10","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}