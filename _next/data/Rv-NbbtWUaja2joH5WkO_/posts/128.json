{"pageProps":{"posts":[{"title":"인앱 알림 대비 푸시 알림 - 2024년 제품 커뮤니케이션에서 어떤 알림 채널이 더 나을까요","description":"","date":"2024-05-12 22:47","slug":"2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024","content":"\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_0.png)\n\n업무 커뮤니케이션 채널에 대한 필요성이 증가함에 따라, 인앱 인박스 알림이 모바일 및 웹 푸시 알림의 장점을 효과적으로 통합한 혁신적인 솔루션으로 등장했습니다. hbr.org의 통계에 따르면 소비자들 중 73%가 단일 소매업체와 여러 통신 채널을 통해 상호 작용하는 필요성을 보여주고 있습니다.\n\n먼저 앱 인박스 플레이그라운드를 시도해보세요→\n\n인앱 인박스 메시징을 통해 사용자들은 편의에 맞게 메시지를 다시 확인할 수 있어 전통적인 푸시 알림의 긴급성을 줄입니다. 알림 센터는 메시지가 관련성을 잃을 때까지 접근 가능한 저장소 역할을 하게 됩니다. 고객 공참을 향상하기 위해 사용하는 사용자와의 모바일 인박스 거래 5가지 사용 사례를 확인해보세요.\n\n\n\n# 푸시 알림 이해하기:\n\n푸시 알림은 널리 사용되는 커뮤니케이션 도구로, 높은 무시율과 과다함에 대한 도전에 직면하고 있습니다. 스마트폰 사용자들은 하루에 평균 46개의 푸시 알림을 받아, 대안 탐색이 필수적입니다.\n\n# 비교 분석: 앱 인박스 대 푸시 알림:\n\n기술적 세부 사항을 탐색하여, 앱 인박스 메시징과 푸시 알림을 비교하는 자세한 비교를 살펴봅시다.\n\n\n\n# 1. 구독 과정:\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_1.png)\n\n# 2. 출현과 소멸:\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_2.png)\n\n\n\n# 3. 기술 구현 및 호환성:\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_3.png)\n\n# 4. 사용자 상호작용:\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_4.png)\n\n\n\n# 5. 스토리지 및 접근성:\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_5.png)\n\n# 사용 사례: 언제 앱 인박스 또는 푸시 알림을 선택해야 하는가:\n\n제품에서 푸시 알림을 사용해야 하는 때와 인앱 박스 알림을 사용해야 하는 때를 알아보고 몇 가지 예시를 살펴보세요. 이 외에도 이벤트의 흐름을 통합하기 위해 메시지 대기열 기술을 선택해야 합니다. 당신의 알림 시스템을 위해 적절한 메시지 대기열 기술을 선택하기.\n\n\n\n<img src=\"/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_6.png\" />\n\n# 기술 정보 — 앱 안내상자 설정:\n\n커뮤니케이션 전략에 앱 안내상자 메시징을 통합하는 것은 주요 기술 정보를 활용한 간단한 프로세스로 진행됩니다. 백엔드 인프라, 프론트엔드 알림함, socket.io를 사용하여 두 가지 사이의 연결이 필요하므로 이는 복잡한 작업입니다. 그러나 SuprSend를 사용하면 이런 프로세스를 크게 간소화할 수 있어서 앱 안내상자를 쉽게 구현할 수 있습니다.\n\nSuprSend로 두 단계만 거치면 시작할 수 있습니다.\n\n\n\n## 스크립트 설치:\n\nApp Inbox 설정을 위해 하나의 스크립트를 사용하여 고급 기능에 접근하세요.\n\n예시 코드:\n\n`<img src=\"/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_7.png\" />`\n\n\n\n휴대폰 받은 편지함이 사용자 참여도를 높이는 방법을 아셨나요? (inapp-inbox를 사용한 사례 연구 포함)\n\n## 사용자 인증:\n\n메시지는 별도의 구독 과정 없이 인증된 사용자에게 접근 가능합니다.\n\n예시 코드:\n\n\n\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_8.png)\n\n문서를 확인해보세요: 개요 (suprsend.com)\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_9.png)\n\n# 기술적인 통찰력 — 푸시 알림 설정:\n\n\n\n사용자에게 푸시 알림을 고려 중인 비즈니스들을 위해 고려해야 할 몇 가지 기술적 측면이 있습니다:\n\n## Firebase 통합:\n\n푸시 알림은 Firebase 프로젝트 생성 및 ESP와의 기능 연관이 필요합니다.\n\n예시 코드:\n\n\n\n\n![이미지](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_10.png)\n\n## 토큰 사용법:\n\n푸시 알림은 메시지를 보내기 위해 푸시 토큰을 사용하며 사용자는 웹사이트에서 구독해야 합니다.\n\n예시 코드:\n\n\n\n\n![image](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_11.png)\n\n이 모든 것들은 코드에서 유지하기가 꽤 복잡하고, 특히 멀티 테넌시 사용 사례가 있는 경우에는 더욱 어렵습니다. 여기서 SuprSend는 선호하는 푸시 알림 공급업체를 추가하고 API나 프론트엔드 편집기를 통해 템플릿과 코드를 만들며, API를 통해 워크플로우를 관리하고, 멀티 테넌트를 관리하며 대시보드에서 완전한 감시를 할 수 있는 단일 대시보드를 제공하여 모든 것을 간단하게 만듭니다.\n\n![image](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_12.png)\n\n결론적으로, 앱 인박스와 푸시 알림 중 어떤 것을 선택할지는 비즈니스의 특정 커뮤니케이션 요구에 달려 있습니다. 푸시 알림은 즉각적이고 주목을 끄는 시나리오에서 뛰어나지만, 앱 인박스는 사용자 중심 접근 방식을 제공하여 장기 프로모션과 지속적인 참여에 이상적입니다. 자세한 정보는 확인해보세요: Mobile In-App Inboxes Have 17% Higher Click Rates Than Push Notifications. Why It Should Bother Product Teams?\n\n\n\n# 앱 인박스를 쉽게 통합하고 싶으신가요?\n\nSuprSend와 함께하면 10분 이내에 앱 인박스를 시작할 수 있습니다. 원하는 SDK를 통합하고 몇 줄의 코드를 복사하면 됩니다. 문서를 확인하여 무난하게 시작하세요.\n\n2줄의 코드로 인앱 인박스를 통합하고 시작할 수 있습니다. 자세한 내용은 다음 문서를 확인해주세요: [인앱 인박스 템플릿](suprsend.com)\n\n![image](/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_13.png)\n\n\n\n원래 발행된 곳: https://www.suprsend.com.","ogImage":{"url":"/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_0.png"},"coverImage":"/assets/img/2024-05-12-In-AppNotificationVSPushNotificationsWhichNotificationChannelisBetterForProductCommunicationin2024_0.png","tag":["Tech"],"readingTime":5},{"title":"Reactjs에서 데이터를 Excel XLSX로 내보내는 방법","description":"","date":"2024-05-12 22:45","slug":"2024-05-12-HowtoexportdatatoExcelXLSXinReactjs","content":"\n\n# 소개\n\n웹 개발의 동적 풍경에서 React.js는 강력한 라이브러리로 강력한 사용자 인터페이스를 구축하는 데 뛰어납니다. 많은 웹 애플리케이션에서 일반적인 요구 사항 중 하나는 데이터를 Excel 형식으로 내보내는 기능입니다. 이 안내서에서는 React.js와 SheetJS 및 File-Saver 라이브러리를 함께 사용하여 이를 원활하게 수행하는 방법을 살펴보겠습니다.\n\n![이미지](/assets/img/2024-05-12-HowtoexportdatatoExcelXLSXinReactjs_0.png)\n\n## SheetJS와 File-Saver를 사용해야 하는 이유?\n\n\n\nSheetJS는 엑셀을 포함한 다양한 스프레드시트 형식의 데이터를 구문 분석, 조작 및 작성하는 데 사용할 수 있는 높은 수준의 기능을 제공하는 자바스크립트 라이브러리입니다. 반면에 File-Saver는 브라우저에서 자바스크립트로 생성된 파일을 저장하는 프로세스를 간단하게 만들어 줍니다. 이 두 라이브러리를 함께 사용하면 React.js 애플리케이션에서 데이터를 엑셀 형식으로 직접 내보내는 강력한 솔루션을 제공할 수 있습니다.\n\n## 설치\n\n시작하려면 SheetJS와 File-Saver를 설치해 보겠습니다:\n\n```js\nnpm install xlsx file-saver\n```\n\n\n\n## 실행\n\n의존성을 설치한 후 구현부로 넘어가봅시다. \"ExcelExport.jsx\" 파일을 만들고 아래 코드를 추가해주세요:\n\n```js\nimport React from 'react';\nimport { saveAs } from 'file-saver';\nimport XLSX from 'xlsx';\n\nconst ExcelExport = ({ data, fileName }) => {\n  const exportToExcel = () => {\n    const worksheet = XLSX.utils.json_to_sheet(data);\n    const workbook = XLSX.utils.book_new();\n    XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');\n    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });\n    const blob = new Blob([excelBuffer], {type: 'application/octet-stream'});\n    saveAs(blob, `${fileName}.xlsx`);\n  };\n\n  return (\n    <button onClick={exportToExcel}>Excel로 내보내기</button>\n  );\n}\n\nexport default ExcelExport;\n```\n\n## 사용법\n\n\n\nExcelExport 컴포넌트를 사용하려면 내보내려는 데이터를 props로 전달하면 됩니다:\n\n```js\nimport React from 'react';\nimport ExcelExport from './ExcelExport';\n\nconst data = [\n  { id: 1, name: 'John Doe', age: 30, profession: 'Developer' },\n  { id: 2, name: 'Jane Smith', age: 25, profession: 'Designer' }\n];\n\nconst App = () => {\n  return (\n    <div>\n      <h1>데이터를 Excel로 내보내기</h1>\n      <ExcelExport data={data} fileName=\"employees\" />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n## 사용자 정의\n\nSheetJS가 제공하는 다양한 기능을 사용하여 워크시트 오브젝트를 조작하여 워크북에 추가하는 전에 Excel 시트를 더 자세히 사용자 정의할 수 있습니다. 이는 추가 시트 추가, 셀 스타일링 및 기타 작업을 포함하며, SheetJS가 제공하는 다양한 기능을 사용하여 가능합니다.\n\n\n\n## 결론\n\nReact.js 애플리케이션에서 데이터를 Excel 형식으로 내보내는 것은 많은 프로젝트에서 흔한 요구사항입니다. SheetJS와 File-Saver 라이브러리의 기능을 활용하면 이 작업을 매우 간단하게 수행할 수 있습니다. 이 안내서에서 안내된 단계를 따르면 Excel 내보내기 기능을 React.js 애플리케이션에 원활하게 통합하여 사용자가 데이터를 분석하고 조작하는 편리한 방법을 제공할 수 있습니다. 그러니 사용자에게 권한을 부여하고, SheetJS와 File-Saver 라이브러리의 강력한 조합을 통해 개발 워크플로를 간소화하세요!","ogImage":{"url":"/assets/img/2024-05-12-HowtoexportdatatoExcelXLSXinReactjs_0.png"},"coverImage":"/assets/img/2024-05-12-HowtoexportdatatoExcelXLSXinReactjs_0.png","tag":["Tech"],"readingTime":3},{"title":"리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식","description":"","date":"2024-05-12 22:45","slug":"2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB","content":"\n\n![이미지](/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png)\n\n건설 산업을 위한 웹 응용 프로그램(또는 현장에서 사용할 웹 응용 프로그램)을 구축한다고 상상해보세요. 이 앱에서 현장 감독관들은 작업 사이트에서 양식을 통해 프로젝트 및 근로자 상태를 데이터베이스에 업데이트합니다. 이제 하루에 여러 사이트를 방문하고 iPad를 통해 웹 앱에 엑세스해야 하는 경우를 상상해보세요. 이러한 시나리오에서는 지속적인 인터넷 연결을 보장할 수 없습니다. 이 정보에 프로젝트 성공에 중요한 자원이 의존하는 경우는 어떨까요? 이 위험을 어떻게 완화할 수 있을까요? 이를 완화하는 한 가지 방법은 오프라인 우선 방법으로 앱을 구축하는 것입니다.\n\n우리는 React와 네이티브 자바스크립트 라이브러리인 서비스 워커(Service Workers)와 IndexedDB를 결합하여 웹에서 오프라인 우선 양식을 만들 것입니다.\n\n서비스 워커란 무엇인가요?\n\n\n\n서비스 워커는 웹의 시크릿 에이전트처럼, 뒷면에서 작업하는 것 같아요. 이들은 원본과 경로에 대해 등록된 이벤트 기반 워커입니다. 웹 페이지/사이트를 제어할 수 있는 자바스크립트 파일이에요. 이들 스크립트는 메인 브라우저 스레드와 별도로 실행되며 논블로킹입니다. 그들은 네트워크 요청을 가로채거나 자원 요청을 캐시하거나 검색하며 푸시 메시지를 전달할 수 있어요. 또한 오프라인 상태일 때에도 작동합니다. 이것은 오프라인 우선 구성 SaSS 시나리오에 완벽합니다.\n\n동기화 관리자와 IndexedDB: 완벽한 조합\n\nSync Manager API는 안정적인 연결이 확립될 때까지 작업을 연기하는 데 도움을 주는 네이티브 JS 기능입니다. IndexedDB는 로컬 스토리지보다 훨씬 강력한 클라이언트 측 저장소를 위한 저수준 API입니다. 함께 사용할 때 웹 응용프로그램은 사용자 세션 및 연결 상태 변경 사이에서 데이터를 저장하고 동기화할 수 있습니다.\n\n사용 사례: 오프라인에서 양식 데이터 저장\n\n\n\n건설 앱 시나리오에서 사용자는 양식을 입력하고 제출하려고 합니다. 일반적으로 연결이 끊어지면 해당 데이터가 손실될 수 있습니다. 그러나 저희 설정은 서비스 워커를 사용하여 폼 제출을 가로채고 데이터를 IndexedDB에 저장하며 Sync Manager와 동기화를 등록합니다. 연결이 다시 연결되면 데이터가 서버로 전송됩니다. 코드에서 어떻게 작동하는지 살펴봅시다.\n\n# 코드 예시\n\n## 시작하기\n\n저희는 빠른 실행과 Vite를 빌드 도구로 사용하겠습니다.\n\n\n\n번을 설치한 후 다음 명령어를 사용하여 Vite로 생성된 React 앱을 만들고 실행할 수 있어요:\n\n```js\nbun create my-app --template react\n```\n\n```js\ncd my-app && bun run dev\n```\n\n저희는 src 디렉토리 내의 App.tsx 파일에서 애플리케이션을 개발하기 시작할 거예요.\n\n\n\n**참고**: 이 예제의 React JSX나 백엔드는 확인하지 않습니다. 백엔드는 저장된 사람들을 위한 GET 및 POST 엔드포인트가 있는 기본 REST API입니다. 전체 코드는 GitHub 저장소를 참조하십시오.\n\n# 단계 1: 서비스 워커 등록\n\n애플리케이션이 로드될 때, 브라우저가 서비스 워커를 지원하는지 확인하고, 지원하는 경우 서비스 워커 스크립트를 등록합니다 (나중에 이 service-worker.js를 생성합니다). 이 등록은 애플리케이션이 시작되면 발생하며, 서비스 워커가 요청을 가로채고 캐싱 및 동기화 작업을 관리할 준비가 되도록 합니다.\n\n```js\ninterface Person {\n  firstName: string,\n  lastName: string,\n  age: number\n}\n\nfunction App() {\n  const [people, setPeople] = useState<Person[]>([]);\n  const { register, handleSubmit } = useForm();\n\n  const registerWorker = () => {\n    if ('serviceWorker' in navigator) {\n      window.addEventListener('load', () => {\n        navigator.serviceWorker.register('/service-worker.js', {scope: '/', type: 'module'})\n          .then(registration => {\n            console.log('Service Worker registered: ', registration);\n          })\n          .catch(registrationError => {\n            console.log('Service Worker registration failed: ', registrationError); \n          });\n      });\n    }\n  }\n```\n\n\n\n# 단계 2: 서비스 워커 파일 생성 및 설치 시 IndexedDB 설정\n\n우리가 App.tsx에서 등록하려고 하는 서비스 워커를 생성하기 위해, src 디렉토리와 동일한 디렉토리 수준에 service-worker.js라는 파일을 만들 것입니다. 이렇게 하는 이유는 서비스 워커를 더 넓은 범위로 설정하기 위해서입니다. 더 높은 또는 루트 디렉토리 수준에 서비스 워커를 배치하면 애플리케이션 전체에서 더 많은 리소스에 대한 요청을 가로챌 수 있습니다. 이 위치 설정은 서비스 워커가 캐싱 및 네트워크 요청을 효과적으로 관리할 수 있도록하는 데 중요합니다.\n\n이 서비스 워커 파일에서 'install' 이벤트 동안 IndexedDB를 초기화합니다. 우리는 formDataStore라는 데이터베이스를 설정하고 오프라인 폼 데이터를 저장하기 위해 특별히 설계된 formData 개체 저장소를 구성합니다. 이 설정은 앱에서 견고한 오프라인 기능을 활성화하는 데 중요합니다:\n\n```js\n// service-worker.js \n\nself.addEventListener('install', async (event) => {\n    console.log('Service Worker installing...');\n    await openDB('formDataStore', 1, {\n        upgrade(db) {\n          if (!db.objectStoreNames.contains('formData')) {\n            db.createObjectStore('formData', { autoIncrement: true });\n            console.log('Object store created!');\n          }\n        },\n    });\n    console.log('Service Worker installed.');\n});\n```\n\n\n\n# 단계 3: 폼 제출 가로채기\n\n폼이 제출되면, 애플리케이션은 기기가 온라인인지 확인합니다. 온라인 상태인 경우, 데이터를 API를 통해 직접 서버로 보냅니다. 오프라인 상태인 경우, 데이터를 IndexedDB에 저장합니다.\n\n```js\n// App.tsx\n\n  const onSubmit = async (data: FieldValues) => {\n    if (navigator.onLine) {\n      const response = await fetch(API_URL + '/people',\n        { method: \"POST\", body: JSON.stringify(data) }\n      )\n      if (response.ok) {\n        console.log(response)\n        setPeople((prevPeople) => [{...data} as Person, ...prevPeople])\n      }\n\n    } else {\n      await storeFormDataLocally(data);\n    }\n  }\n```\n\n# 단계 4: 로컬로 데이터 저장하기\n\n\n\n오프라인 상태에서는 폼 데이터가 IndexedDB에 저장됩니다. 이 storeFormDataLocally 함수는 formData 객체 저장소에서 트랜잭션을 열고 데이터를 작성한 다음, 이 데이터가 서버로 전송되어야 할 것임을 나타내는 sendFormData 태그와의 백그라운드 동기화 이벤트를 등록합니다. 이렇게 하면 나중에 연결이 복원될 때 이 데이터를 서버로 보낼 수 있습니다.\n\n```js\nasync function storeFormDataLocally(formData : FieldValues) {\n\n    const db = await openDB('formDataStore', 1);\n    const tx = db.transaction('formData', 'readwrite');\n    const store = tx.objectStore('formData');\n    store.put(formData);\n    await tx.done;\n    if ('serviceWorker' in navigator && 'SyncManager' in window) {\n      const registration : any  = await navigator.serviceWorker.ready\n      try {\n        await registration.sync.register('sendFormData');\n          console.log('Sync event registered');\n      } catch(e) {\n          console.log('Failed to register sync, will retry on next   visit' + e);\n      }\n  }\n    db.close();\n  }\n```\n\n서비스 워커는 'sync' 이벤트를 수신 대기합니다. 이벤트가 트리거될 때(온라인으로 변경될 때 자동적으로 발생), IndexedDB에서 모든 저장된 폼 데이터를 검색하여 서버로 보내려고 시도합니다. 성공적인 제출은 그 후에 저장소에서 삭제되어 중복 전송을 방지합니다.\n\n```js\nself.addEventListener('sync', event => {\n    if (event.tag === 'sendFormData') {\n        event.waitUntil(sendFormDataToServer());\n    }\n});\n```\n\n\n\n# 단계 6: 데이터 서버로 전송하고 IndexedDB 초기화하기\n\n실제 데이터 전송 함수는 formData 스토어에서 모든 항목을 가져와 각 항목을 서버로 전송하며 성공적인 전송 후 스토어에서 해당 항목을 제거합니다. 이렇게 함으로써 로컬 스토어를 유지하고 최신 상태로 유지할 수 있습니다.\n\n```js\nexport async function sendFormDataToServer() {\n    const db = await openDB('formDataStore', 1);\n    const tx = db.transaction('formData', 'readonly');\n    const store = tx.objectStore('formData');\n    const allSavedData = await store.getAll();\n    console.log('저장된 폼 데이터', allSavedData);\n    try {\n        allSavedData.forEach( async (form, index) =>  {\n            const response = await fetch('http://localhost:3000/people',  \n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(form)\n            });\n            if (response.ok) {\n                console.log('서버와 동기화된 데이터:', form);\n                await db.transaction('formData', 'readwrite').objectStore('formData').delete(index);\n                console.log(`제거된 폼 데이터: ${form.firstName} ${form.lastName}` )\n            }\n        });\n    } catch (error) {\n        console.error('폼 데이터 전송 실패:', error);\n    }\n}\n```\n\n# 결론\n\n\n\n건설 SaSS 웹 앱 시나리오로 돌아가 봅시다. 건설 현장에서는 감독관이 여러 장소를 자주 이동하며 중요한 프로젝트 및 작업자 데이터에 원활하게 접근할 수 있어야 합니다. 때때로 인터넷 연결이 불안정한 상황에서도요.\n\nReact, 서비스 워커 및 IndexedDB를 사용하여 오프라인 우선 접근 방식을 채택함으로써 이러한 독특한 요구 사항을 충족시켰습니다. 이러한 기술을 활용하면 지속적인 워크플로우를 지원하고 신뢰할 수 없는 연결성으로 인한 위험을 완화하며 모든 이해관계자가 최신 정보에 접근할 수 있도록하여 적시에 결정을 내릴 수 있게 하며 꾸준한 프로젝트 진행을 보장할 수 있습니다.\n\n코드의 전체 내용은 여기에서 Github 저장소를 참조하세요.\n\n원문은 https://dennistowns.substack.com에서 원본 게시됨.","ogImage":{"url":"/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png"},"coverImage":"/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png","tag":["Tech"],"readingTime":7},{"title":"칼닷컴을 리액트를 이용하여 웹사이트에 통합하는 단계별 안내","description":"","date":"2024-05-12 22:44","slug":"2024-05-12-IntegratingCalcomIntoYourWebsiteUsingReactAStep-by-StepGuide","content":"\n\n현재의 빠르게 변화하는 세상에서 비즈니스 및 전문가들이 시간을 효율적으로 관리하기 위해 필수적인 효율적인 일정 관리 도구들이 되었습니다. Cal.com은 회의와 약속을 일정 잡는 과정을 간소화하여 사용자들이 회의를 설정하는 데 자주 발생하는 번복된 소통을 최소화하고 시간을 절약할 수 있는 도구 중 하나입니다. 이 블로그 포스트에서는 React를 사용하여 웹 사이트에 Cal.com을 원활하게 임베드하는 방법에 대해 살펴보겠습니다. React는 사용자 인터페이스를 구축하는 데 가장 인기있는 JavaScript 라이브러리 중 하나입니다.\n\n# 단계 1: Cal.com 계정 등록\n\nCal.com을 웹 사이트에 임베드하려면 먼저 Cal.com에 계정을 등록해야 합니다. 다행히도 이 과정은 간단하며 몇 분 정도 소요됩니다. 등록이 완료되면 Cal.com 대시보드에 접속하여 일정 설정 기본 사항을 사용자 정의하고, 임베드 가능한 일정 링크를 생성할 수 있게 됩니다.\n\n\n\n# 단계 2: React 설치하기\n\n이미 진행하지 않았다면 Cal.com을 웹사이트에 통합하기 위해 React 프로젝트를 설정해야 합니다. create-react-app을 사용하거나 React 프로젝트를 초기화하는 선호하는 방법을 사용하여 새로운 React 프로젝트를 만들 수 있습니다.\n\n# 단계 3: Cal.com 위젯 패키지 설치하기 (방법 1)\n\nCal.com은 React 위젯 패키지를 제공하여 React 애플리케이션에 일정 기능을 쉽게 포함시킬 수 있습니다. Cal.com 위젯 패키지를 설치하려면 npm을 사용할 수 있습니다:\n\n\n\n```js\nnpm install @calcom/react-widget\n```\n\nCal.com 위젯 패키지를 설치한 후 Cal.com 위젯 컴포넌트를 React 애플리케이션에 추가할 수 있습니다. CalcomWidget 컴포넌트를 React 컴포넌트로 가져와 JSX 마크업 내에서 사용하세요:\n\n```js\nimport React from 'react';\nimport { CalcomWidget } from '@calcom/react-widget';\n\nconst App = () => {\n  return (\n    <div>\n      <h1>내 웹사이트에 오신 것을 환영합니다</h1>\n      <CalcomWidget\n        schedulingLink=\"여기에 당신의 일정 관리 링크를 입력하세요\"\n        buttonText=\"내 Cal 예약하기\"\n        \n      />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n\"여기에 당신의 일정 관리 링크를 입력하세요\"를 Cal.com 대시보드에서 생성된 일정 관리 링크로 대체하세요. 원하는대로 버튼 텍스트를 사용자화할 수 있습니다.\n\n\n\nCal.com 위젯 컴포넌트는 당신의 웹사이트와 일치하도록 커스터마이징할 수 있어요. CalcomWidget 컴포넌트에 props를 전달하여 버튼 텍스트, 버튼 색상, 위젯 크기 등을 다양하게 사용자화할 수 있어요.\n\n당신의 웹사이트는 이렇게 보일 거에요:\n\n![Cal.com Widget Example](/assets/img/2024-05-12-IntegratingCalcomIntoYourWebsiteUsingReactAStep-by-StepGuide_1.png)\n\n# 단계 3: Cal.com 임베드 패키지 설치 (방법 2)\n\n\n\nCal.com은 React 임베드 패키지도 제공합니다. npm을 사용하여 패키지를 설치할 수 있어요:\n\n```js\nnpm install @calcom/embed-react\n```\n\n패키지를 설치한 후에는 React 애플리케이션에 Cal.com 임베드 컴포넌트를 추가할 수 있어요. React 컴포넌트에서 Cal 컴포넌트를 가져와 JSX 마크업 안에서 사용하세요:\n\n```js\nimport React from 'react';\nimport Cal from \"@calcom/embed-react\";\n\nexport default function App() {\n  return (\n    <div className=\"App\">\n      <h1>다음은 인라인 cal.com 임베드입니다</h1>\n      <Cal calLink=\"rick/get-rick-rolled\"></Cal>\n    </div>\n  );\n}\n```\n\n\n\nCal 컴포넌트는 calLink라는 속성과 함께 사용됩니다. 이 속성은 삽입할 Cal.com 일정 링크를 지정합니다. 이 경우 \"rick/get-rick-rolled\"이 예제 링크로 제공됩니다. 이를 Cal.com 대시보드에서 생성된 실제 Cal.com 일정 링크로 교체해야 합니다.\n\n당신의 웹사이트는 다음과 같이 보일 것입니다:\n\n![Image](/assets/img/2024-05-12-IntegratingCalcomIntoYourWebsiteUsingReactAStep-by-StepGuide_2.png)\n\n# Method 1과 Method 2 사이의 차이는 무엇인가요?\n\n\n\n두 코드 스니펫은 모두 Cal.com 일정을 React 애플리케이션에 삽입하는 동일한 목표를 달성합니다.\n\n요약하면, 메소드 1은 상세한 지침과 사용자 정의 옵션을 제공하는 포괄적인 가이드를 제공하며, 메소드 2는 빠른 통합을 위한 간단하고 사용 준비가 된 코드 스니펫을 제공합니다. 두 가지 방법 중 선택은 사용자의 선호도, React에 대한 익숙함 및 통합에 필요한 사용자 지정 수준에 달려 있습니다.\n\n# 단계 6: 웹사이트 테스트 및 배포하기\n\nReact 애플리케이션에 Cal.com을 통합한 후에는 모든 것이 올바르게 작동하는지 확인하기 위해 기능을 테스트하는 것이 중요합니다. 누군가가 약속을 예약하면 제어판이 표시됩니다:\n\n\n\n\n![image](/assets/img/2024-05-12-IntegratingCalcomIntoYourWebsiteUsingReactAStep-by-StepGuide_3.png)","ogImage":{"url":"/assets/img/2024-05-12-IntegratingCalcomIntoYourWebsiteUsingReactAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-12-IntegratingCalcomIntoYourWebsiteUsingReactAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"Axios를 활용하여 API 요청 최적화하기 Interceptors 및 고급 오류 처리","description":"","date":"2024-05-12 22:42","slug":"2024-05-12-OptimizingAPIRequestswithAxiosInterceptorsandAdvancedErrorHandling","content":"\n\n\n![Alt text](/assets/img/2024-05-12-OptimizingAPIRequestswithAxiosInterceptorsandAdvancedErrorHandling_0.png)\n\n프로젝트에서 API 통신의 참된 잠재력을 발휘해 보세요! 다재다능한 HTTP 클라이언트인 Axios를 살펴보고, 인터셉터와 견고한 에러 처리로 요청 관리를 어떻게 높일 수 있는지 알아보세요.\n\nAxios와 기본 Fetch API는 JavaScript에서 HTTP 요청을 하는 도구이지만, 주요 차이점이 있습니다. Axios가 인기 있는 이유와 Fetch API와의 차이점을 강조한 비교입니다:\n\n## 1. 사용 편의성 및 구문:\n\n\n\n— Axios: 깔끔한 구문과 일관된 API를 제공하여 간단하게 사용할 수 있습니다. 그리고 메서드들은 Promises를 반환하여 비동기 작업을 쉽게 연결하고 처리할 수 있습니다.\n— Fetch API: 강력하지만 더 많은 설명이 필요한 구문을 갖고 있으며, 다양한 HTTP 메서드나 헤더를 처리하기 위해서는 추가적인 보일러플레이트(boilerplate) 코드가 필요할 수 있습니다.\n\n## 2. JSON 데이터 다루기:\n\n— Axios: JSON 응답을 자동으로 구문 분석하여 JSON 데이터를 다루는 프로세스를 간단화합니다.\n— Fetch API: 응답에서 JSON 데이터를 추출하려면 수동으로 .json() 메서드를 호출해야 합니다.\n\n## 3. 인터셉터:\n\n\n\n- Axios: Interceptors를 사용하여 HTTP 요청이나 응답이 .then() 또는 .catch() 블록에 도달하기 전에 전역적으로 가로채고 수정하는 것을 가능하게 합니다.\n- Fetch API: 내장된 Interceptors가 없기 때문에 유사한 기능을 달성하려면 추가 코드 및 각 사용 지점에서 처리가 필요합니다.\n\n## 4. 오류 처리:\n\n- Axios: 견고한 오류 처리가 있으며 HTTP 오류 상태 (예: 404 또는 500)에 대해 자동으로 프라미스를 거부합니다.\n- Fetch API: 응답의 ok 속성을 수동으로 확인해야 하며 오류는 자동으로 throw되지 않습니다.\n\nAxios가 인기 있는 이유:\n- 편리성: Axios는 개발자 친화적 인터페이스를 제공하여 명확한 구문으로 작업하기 쉽게 만듭니다.\n- 기능이 풍부함: Interceptors, 자동 JSON 구문 분석 및 요청/응답 변환과 같은 내장 기능은 인기에 기여합니다.\n- 일관된 동작: Axios는 Fetch API에 존재하는 일부 불일치에 대응하여 서로 다른 브라우저에서 일관된 동작을 보장합니다.\n\n\n\n## Axios 시작하기\n\n## 1. Axios 설치하기:\n\n프로젝트에 Axios가 설치되어 있는지 확인하세요. npm 또는 yarn을 사용하여 설치할 수 있습니다:\n\n```js\nnpm install axios\n// 또는\nyarn add axios\n```\n\n\n\n## 2. Axios 인스턴스를 가져와서 만들기:\n\nAPI 요청을 만들 예정인 JavaScript 파일에서 Axios를 가져와주세요. 그리고 기본 URL, 헤더 등과 같은 기본 설정을 설정하기 위해 Axios 인스턴스를 만들어주세요. 이렇게 하면 다른 요청에서 동일한 설정을 재사용할 수 있어요:\n\n```js\nimport axios from 'axios';\n\nconst api = axios.create({\n  baseURL: 'https://api.example.com',\n  headers: {\n    'Content-Type': 'application/json',\n    // 다른 공통 헤더를 추가해주세요\n  },\n});\n```\n\n## 3. 요청과 응답 인터셉터 처리:\n\n\n\n```js\nAxios는 요청과 응답을 전역적으로 처리하기 위해 인터셉터를 사용할 수 있습니다. 이는 헤더 추가, 오류 처리 등과 같은 작업에 유용합니다.\n\n// 요청 인터셉터\napi.interceptors.request.use(\n  (config) => {\n    // 요청 구성을 여기서 수정하세요 (예: 권한 헤더 추가)\n    return config;\n  },\n  (error) => {\n    // 요청 오류 처리\n    return Promise.reject(error);\n  }\n);\n\n// 응답 인터셉터\napi.interceptors.response.use(\n  (response) => {\n    // 응답 데이터를 여기서 수정하세요\n    return response;\n  },\n  (error) => {\n    // 응답 오류 처리\n    return Promise.reject(error);\n  }\n);\n\n## 4. 비동기 요청에 대해 Async/Await 사용:\n\n클린하고 가독성이 좋은 비동기 코드를 위해 async/await 구문을 활용하세요:\n```\n\n\n\n```js\nasync function fetchData() {\n  try {\n    const response = await api.get('/endpoint');\n    // 응답 데이터 처리\n  } catch (error) {\n    // 에러 처리\n  }\n}\n```\n\n## 5. 동시 요청 최적화:\n\n여러 요청을 동시에 실행할 수 있는 경우 성능을 최적화하기 위해 Promise.all을 사용해보세요:\n\n```js\nasync function fetchMultipleData() {\n  try {\n    const [data1, data2] = await Promise.all([\n      api.get('/endpoint1'),\n      api.get('/endpoint2'),\n    ]);\n    // 데이터 처리\n  } catch (error) {\n    // 에러 처리\n  }\n}\n```\n\n\n\n## 6. 요청 취소:\n\nAxios는 요청 취소를 지원합니다. 이는 사용자가 요청이 완료되기 전에 페이지를 벗어날 때 불필요한 요청을 방지하는 데 유용할 수 있습니다:\n\n```js\nconst source = axios.CancelToken.source();\n\ntry {\n  const response = await api.get('/endpoint', {\n    cancelToken: source.token,\n  });\n  // 응답 처리\n} catch (error) {\n  if (axios.isCancel(error)) {\n    // 요청이 취소되었습니다\n  } else {\n    // 다른 오류 처리\n  }\n}\n\n// 요청 취소하기\nsource.cancel('사용자에 의해 요청이 취소됨');\n```\n\n## 성공 및 오류 토스트와 함께 완전한 소스 코드\n\n\n\n```js\nimport { toast } from 'react-hot-toast';\nimport Axios from 'axios';\n\nconst axios = Axios.create({\n  // 여러분의 API 기본 URL로 변경하세요\n  baseURL: 'https://fakerapi.it/api/v1',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\naxios.interceptors.response.use(\n  (response) => {\n    const data = response?.data;\n\n    console.log(data);\n\n    if (data?.message && typeof data?.message === 'string') {\n      toast.success(data.message);\n    } else if (data?.status && typeof data?.status === 'string') {\n      toast.success(data.status + ` - 상태 코드: ${data.code}`);\n    }\n\n    // 필요에 맞게 변경하세요\n    return data.data;\n  },\n  (error) => {\n    const data = error.response.data;\n\n    if (data?.message && typeof data?.message === 'string') {\n      toast.error(data.message);\n    } else if (data?.status && typeof data?.status === 'string') {\n      toast.error(data.status + ` - 상태 코드: ${data.code}`);\n    }\n\n    return Promise.reject(data);\n  }\n);\n\naxios.interceptors.request.use((config) => {\n  let token = 'your-bearer-token';\n\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  } else {\n    // 토큰이 없는 경우 처리\n    // 로그인 페이지로 리디렉션하거나 적절한 조치를 취할 수 있습니다\n  }\n\n  return config;\n});\n\nexport default axios;\n```\n\naxios 템플릿 코드를 문서에 추가했고, 아래 링크를 참조해주세요:\n\n[GitHub Gist](https://www.0cb.tech/jbbch)\n[실시간 코드 — StackBlitz](https://www.0cb.tech/fvopy)\n\n' embed https://stackblitz.com/edit/vitejs-vite-uqovqp?embed=1&file=src%2Flib%2Faxios.js '\n","ogImage":{"url":"/assets/img/2024-05-12-OptimizingAPIRequestswithAxiosInterceptorsandAdvancedErrorHandling_0.png"},"coverImage":"/assets/img/2024-05-12-OptimizingAPIRequestswithAxiosInterceptorsandAdvancedErrorHandling_0.png","tag":["Tech"],"readingTime":5},{"title":"env 변수 undefined","description":"","date":"2024-05-12 22:41","slug":"2024-05-12-envvariablesundefined","content":"\n\n애플리케이션을 구축할 때 VITE, REACT 또는 NEXT를 기반으로 하는 상황에 갇혀 과연 환경 변수를 어떻게 설정해야 할지 모를 때가 있나요?\n\n저 또한 예전에 여러분과 같은 상황에 처해 있었고, 고민 끝에 제 문제에 맞는 해결책을 찾기 위해 인터넷을 뒤적였어요.\n\n우리가 설치한 패키지/모듈의 공식 문서에 기재된 케이스와 맞지 않는 기능이 있는 프로젝트를 갖고 있는 경우가 많습니다. 따라서 이 게시물은 환경 변수와 여러분의 “상황\"에서 이를 작동시키는 방법에 대한 내용입니다.\n\n환경 변수란 정확히 무엇인가요?\n\n\n\n환경 변수는 단순히 프로젝트의 파일 시스템 전역에서 사용하려는 변수들입니다. 하지만 이를 인터넷에서 다른 사람들에게 공개하거나 보여주고 싶지는 않아요. 기본적으로 \"SECRET_KEY\"나 \"PUBLISHABLE_KEY\"와 같은 민감한 변수나 키들입니다. 이러한 종류의 키/변수는 .env라는 파일 안에 작성됩니다.\n\n이 .env 파일을 어떻게 만들까요?\n\n먼저 프로젝트 폴더에서 package.json 파일의 계층을 찾으세요. 그 후, 새 파일을 만들기 위해 마우스 오른쪽 버튼을 클릭하고 파일 이름을 \"env\"로 작성하세요. 정확하게 이렇게 작성해 주셔야 하며, 이렇게 하시면 환경 변수 파일이 생성됩니다.\n\n![이미지](/assets/img/2024-05-12-envvariablesundefined_0.png)\n\n\n\n.env 파일에 환경 변수를 어떻게 작성하나요?\n\n- Vite 애플리케이션(프론트엔드)에 환경 변수를 사용하려면 패키지(dotenv)를 설치할 필요가 없습니다. .env 파일을 생성하기만 하면 됩니다.\n\n```js\nVITE_YOUR_VARIABLE_NAME=SOMETHING\n```\n\n2. 마찬가지로 React 애플리케이션(프론트엔드)에 환경 변수를 사용하려면 패키지(dotenv)를 설치할 필요가 없습니다. .env 파일을 생성하기만 하면 됩니다.\n\n\n\n3. REACT 앱에서 변수를 선언하는 구문은 다음과 같습니다. 변수 이름은 'REACT_APP_' 프리픽스가 있어야 합니다. 그렇지 않으면 변수가 제대로 작동하지 않습니다.\n\n```js\nREACT_APP_YOUR_VARIABLE_NAME=SOMETHING\n```\n\n4. NEXT 앱에서 환경 변수를 선언할 때 변수는 아래와 같이 보여야 합니다. \"NEXT_PUBLIC_\" 프리픽스가 있어야만 제대로 작동합니다.\n\n```js\nNEXT_PUBLIC_YOUR_VARIABLE_NAME=SOMETHIN\n```\n\n\n\n<img src=\"/assets/img/2024-05-12-envvariablesundefined_1.png\" />\n\n5. 백엔드(server) 폴더에서 환경 변수를 선언하는 경우, dotenv이라는 패키지가 필요합니다.\n\n설치\n\nyarn과 npm은 우리가 인터넷에서 패키지를 다운로드하여 프로젝트에서 사용하고 멋진 것을 만들 수 있도록 도와주는 패키지 관리자입니다.\n\n\n\n```js\nnpm i dotenv\n```\n\n또는\n\n```js\nyarn add dotenv\n```\n\n5. 이제 서버 측 폴더의 index.js(루트 파일/진입점)에서 방금 설치한 이 패키지를 구성해야 합니다.\n\n\n\n```js\nconst dotenv = require(\"dotenv\")\ndotenv.config()\n```\n\n![2024-05-12-envvariablesundefined_2.png](/assets/img/2024-05-12-envvariablesundefined_2.png)\n\n다음에는 .env 파일을 만드는 방법에 언급된 것과 똑같은 절차를 수행합니다. 그러나 백엔드에서는 환경 변수의 이름을 원하는 대로 지정할 수 있습니다.\n\n```js\nMONGO_URL=SDAHKAFHKLJAHFLA\nJWT_KEY=FHALKHFLAHF\n```\n\n\n\n그 변수를 컴포넌트 파일에서 어떻게 접근할 수 있는지 알고 계신가요?\n\n프런트엔드\n\n- Vite 앱의 경우\n\n```js\nconst VARIABLE_NAME = import.meta.env.VITE_YOUR_KEY_VARIABLE_NAME\n```\n\n\n\n- React 앱용\n\n```js\nconst VARIABLE_NAME = process.env.REACT_APP_YOUR_KEY_VARIABLE_NAME\n```\n\n- Next 앱용\n\n```js\nconst VARIABLE_NAME = process.env.NEXT_PUBLIC_YOUR_VARIABLE_NAME\n```\n\n\n\n백엔드\n\n- 원하는 변수에 액세스하려면 process.env.VARIABLE_NAME을 사용해야 합니다.\n\n```js\nconst VARIABLE_NAME = process.env.YOUR_VARIABLE_NAME\n```\n\n최종 참고 사항:\n\n\n\n- VARIABLE_NAME을 대문자로 작성하는 것이 좋지만 casing은 당신에게 달려 있어요.\n- 환경 변수를 선언할 때 공백, 쉼표 또는 세미콜론을 사용하지 마세요.\n\n이제 프런트엔드와 백엔드를 위한 환경 변수 설정의 기술을 습득했어요. 어려움이 있으면 언제든 저에게 GitHub 또는 프로필 내 링크를 통해 연락해 주세요.\n\n마지막으로, 표준 최고의 실천 방법을 준수하면 개발 능력이 향상되고 다른 사람에게 전문성을 나타낼 수 있어요. 이 \"case\"에서는 대문자 또는 소문자 변수 이름 사용을 피하세요.","ogImage":{"url":"/assets/img/2024-05-12-envvariablesundefined_0.png"},"coverImage":"/assets/img/2024-05-12-envvariablesundefined_0.png","tag":["Tech"],"readingTime":3},{"title":"프론트엔드에서의 JWT 인증 웹 애플리케이션 보안 강화하기","description":"","date":"2024-05-12 22:40","slug":"2024-05-12-JWTAuthenticationintheFrontendEnhancingSecurityinWebApplications","content":"\n\n이 블로그에서는 JWT 토큰을 사용하여 프론트 엔드에서 사용자를 인증하고 웹 애플리케이션/웹 사이트에 대한 무단 액세스를 방지하는 방법에 대해 배워보겠습니다.\n\n![JWTAuthenticationintheFrontendEnhancingSecurityinWebApplications_0.png](/assets/img/2024-05-12-JWTAuthenticationintheFrontendEnhancingSecurityinWebApplications_0.png)\n\n이전 블로그에서 API 서버를 만들어서 로그인 엔드포인트를 제공했습니다. 사용자가 로그인하면 로그인한 사용자의 데이터와 액세스 토큰 및 리프레시 토큰을 얻을 수 있습니다. 이를 사용하여 프론트 엔드에서 서버에 자격 증명을 인증할 수 있습니다. 이 블로그에서는 프론트 엔드로 React JS를 사용할 것입니다.\n\n간단히 복습해보죠.\n\n\n\nJWT는 JSON 웹 토큰의 약자입니다. 이는 JSON 객체로 정보를 안전하게 전송하는 데 사용되는 공개 표준 (RFC 7519)입니다. JWT는 웹 애플리케이션과 API에서 인증 및 권한 부여에 일반적으로 사용됩니다.\n\n이 정보는 디지털으로 서명되어 신뢰할 수 있습니다. JWT는 HMAC 알고리즘을 사용하여 비밀을 이용하거나 RSA 또는 ECDSA를 사용한 공개/비공개 키 쌍을 사용하여 서명할 수 있습니다.\n\nJWT는 세 가지 부분으로 구성됩니다: 헤더, 페이로드 및 서명.\n\n- 헤더 — 헤더는 두 부분으로 구성됩니다: 토큰을 서명하는 알고리즘 (예: HMAC SHA256 또는 RSA) 및 이 경우 JWT인 토큰 유형이 포함됩니다.\n- 페이로드 — 페이로드는 클레임을 포함합니다. 클레임은 사용자 ID 또는 사용자 이름과 같이 엔티티 특정 정보를 전달할 수 있습니다.\n- 서명 — 서명은 인코딩된 헤더, 인코딩된 페이로드 및 서버만 알 수 있는 비밀 키를 결합하여 형성됩니다. 이는 토큰의 무결성을 확인하고 변조되지 않았음을 보장하기 위해 사용됩니다.\n\n\n\nJWT는 어떻게 동작합니까?\n\nJWT 토큰을 사용할 때 일반적으로 사용되는 흐름은 다음과 같습니다 —\n\n- 사용자 인증 — 먼저 사용자는 자격 증명을 전달하여 서버에 인증합니다.\n- 토큰 생성 — 사용자가 인증되면 사용자 세부 정보를 페이로드로 포함하는 토큰이 생성되며, 이는 프론트 엔드 및 백엔드에서 검증을 수행하는 데 필요합니다.\n- 토큰 저장 — 서버가 로그인 요청에 대한 응답으로 프론트 엔드에 토큰을 전송하고, 프론트 엔드는 이를 로컬 저장소나 세션에 저장합니다.\n- 요청 생성 — 클라이언트가 백엔드 서버에 요청을 보낼 때 헤더에 JWT 액세스 토큰을 전달하여 서버에 대한 신원을 인증합니다. 이것이 JWT의 주요 목적입니다.\n- 토큰 확인 — 서버는 요청 헤더, 즉 JWT 액세스 토큰을 확인하고 토큰이 유효하면 요청된 리소스에 대한 액세스를 제공하고, 토큰이 유효하지 않으면 401 상태 코드를 반환하여 사용자를 비인증 상태로 만듭니다.\n\nJWT 만료란 무엇을 의미합니까?\n\n\n\n보안을 강화하기 위해 JWT에는 만료 시간을 정의할 수 있는 추가 기능이 있습니다. 특정 기간이 지나면 액세스 토큰이 더 이상 유효하지 않게 됩니다. 만료된 JWT 액세스 토큰을 사용할 수 없습니다. 서버에 액세스하려면 새로운 토큰을 생성해야 합니다.\n\n이를 위해 클라이언트용 새로운 액세스 토큰을 가져오는 작업을 수행하는 리프레시 액세스 토큰을 사용합니다.\n\n우리는 프런트 엔드에서 JWT를 사용하는 방법을 볼 수 있는 로그인 폼을 만들 것입니다. 그래서 먼저 리액트 앱을 생성해보겠습니다. 리액트 앱을 만들기 위해 Vite를 사용하겠습니다.\n\n```js\nnpm create vite@latest\n```\n\n\n\n그럼 프로젝트 이름을 지정하고 React 및 간단한 JavaScript을 선택하도록 요청합니다. 이렇게 하면 앱이 포함된 폴더가 생성됩니다. 그런 다음 필요한 모든 패키지를 설치해야 합니다.\n\n```js\ncd project_name\nnpm i   \n```\n\nReact 앱을 만든 후에는 로그인을 위한 폼을 만들겠습니다. 이를 통해 사용자가 서버에 액세스할 수 있습니다. 사용자가 사용자 이름과 암호를 사용해 로그인하면 백엔드는 액세스 토큰과 리프레시 토큰과 함께 액세스를 부여할 것입니다.\n\n그러므로 먼저 로그인 폼을 만들어 봅시다.\n\n\n\nApp.js\n\n```js\nimport axios from \"axios\";\nfunction App() {\n  const [user, setUser] = useState(null);\n  const [username, setUsername] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      const response = await axios.post(\"/api/login\", { username, password });\n      setUser(response.data);\n    } catch (error) {\n      console.log(error);\n    }\n  };\n  return (\n    <div className=\"container\">\n      {user ? (\n        <div className=\"login\">\n          <form onSubmit={handleSubmit}>\n            <span className=\"formTitle\">Lama Login</span>\n            <input\n              type=\"text\"\n              placeholder=\"username\"\n              onChange={(e) => setUsername(e.target.value)}\n            />\n            <input\n              type=\"password\"\n              placeholder=\"password\"\n              onChange={(e) => setPassword(e.target.value)}\n            />\n            <button type=\"submit\" className=\"submitButton\">\n              Login\n            </button>\n          </form>\n        </div>\n      ) : (\n        <span>User has been loggedIn </span>\n      )}\n    </div>\n  );\n}\n```\n\nApp.css\n\n```css\n.container {\n  font-family: \"Quicksand\", sans-serif;\n}\n\n.login {\n  width: 200px;\n  height: 200px;\n  padding: 20px;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  margin: auto;\n  border: 1px solid lightgray;\n  border-radius: 10px;\n}\n\n.formTitle {\n  color: teal;\n  font-weight: bold;\n}\n\n.submitButton {\n  width: 100px;\n  padding: 10px;\n  border: none;\n  border-radius: 10px;\n  background-color: teal;\n  color: white;\n  cursor: pointer;\n}\n```\n\n\n\n지금은 App() 함수의 반환부에 로그인 후 기능을 작성하는 코드를 작성할 것입니다. 특권을 가진 사용자는 삭제 작업을 수행할 수 있습니다. 기능을 추가한 후 App.js 파일은 다음과 같이 보일 것입니다.\n\n```js\nfunction App() {\n  const [user, setUser] = useState(null);\n  const [username, setUsername] = useState(\"\");\n  const [password, setPassword] = useState(\"\");\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      const res = await axios.post(\"/login\", { username, password });\n      setUser(res.data);\n    } catch (err) {\n      console.log(err);\n    }\n  };\n\n  const handleDelete = async (id) => {\n    setSuccess(false);\n    setError(false);\n    try {\n      await axios.delete(\"/users/\" + id, {\n        headers: { authorization: \"Bearer \" + user.accessToken },\n      });\n      setSuccess(true);\n    } catch (err) {\n      setError(true);\n    }\n  };\n\n  return (\n    <div className=\"container\">\n      {user ? (\n        <div className=\"home\">\n          <span>\n            {user.isAdmin ? \"어드민\" : \"사용자\"} 대시보드에 오신 것을 환영합니다, <b>{user.username}</b>님.\n          </span>\n          <span>사용자 삭제:</span>\n          <button className=\"deleteButton\" onClick={() => handleDelete(1)}>\n            John 삭제\n          </button>\n          <button className=\"deleteButton\" onClick={() => handleDelete(2)}>\n            Jane 삭제\n          </button>\n          {error && (\n            <span className=\"error\">\n              이 사용자를 삭제할 수 없습니다!\n            </span>\n          )}\n          {success && (\n            <span className=\"success\">\n              사용자가 성공적으로 삭제되었습니다...\n            </span>\n          )}\n        </div>\n      ) : (\n        <div className=\"login\">\n          <form onSubmit={handleSubmit}>\n            <span className=\"formTitle\">Lama 로그인</span>\n            <input\n              type=\"text\"\n              placeholder=\"사용자명\"\n              onChange={(e) => setUsername(e.target.value)}\n            />\n            <input\n              type=\"password\"\n              placeholder=\"비밀번호\"\n              onChange={(e) => setPassword(e.target.value)}\n            />\n            <button type=\"submit\" className=\"submitButton\">\n              로그인\n            </button>\n          </form>\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n로그인 양식을 사용하여 로그인하면 사용자 데이터와 액세스 토큰 및 리프레시 토큰을 받게 됩니다. 서버로 삭제 요청을 수행할 때 액세스 토큰을 전달합니다. 그러나 액세스 토큰이 만료될 수 있으므로 서버에 전달하기 전에 액세스 토큰을 확인하고 만료되었을 경우 리프레시 토큰을 사용하여 새 액세스 토큰을 얻어야 합니다.\n\n```js\nconst axiosJWT = axios.create()\n\naxiosJWT.interceptors.request.use(\n  async (config) => {\n    let currentDate = new Date();\n    const decodedToken = jwt_decode(user.accessToken);\n    if (decodedToken.exp * 1000 < currentDate.getTime()) {\n      const data = await refreshToken();\n      config.headers[\"authorization\"] = \"Bearer \" + data.accessToken;\n    }\n    return config;\n  },\n  (error) => {\n    return Promise.reject(error);\n  }\n);\n\nconst handleDelete = async (id) => {\n  setSuccess(false);\n  setError(false);\n  try {\n    await axiosJWT.delete(\"/users/\" + id, {\n      headers: { authorization: \"Bearer \" + user.accessToken },\n    });\n    setSuccess(true);\n  } catch (err) {\n    setError(true);\n  }\n};\n```\n\n\n\n이렇게 하면 액세스 토큰 만료 문제를 다룰 수 있고, 서버에 요청을 보내기 전에 새 액세스 토큰을 받을 수 있습니다.\n\nGitHub 링크는 다음에서 찾을 수 있습니다.\n\n제 블로그를 읽어 주셔서 감사합니다. 새로운 것을 배우셨으면 좋겣습니다.","ogImage":{"url":"/assets/img/2024-05-12-JWTAuthenticationintheFrontendEnhancingSecurityinWebApplications_0.png"},"coverImage":"/assets/img/2024-05-12-JWTAuthenticationintheFrontendEnhancingSecurityinWebApplications_0.png","tag":["Tech"],"readingTime":7},{"title":"React TypeScript로 npm 패키지 생성하고 배포하는 방법 데모 및 자동 빌드 포함","description":"","date":"2024-05-12 22:36","slug":"2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild","content":"\n\n## 제로부터 놀라운 프로젝트를 만드는 법을 배워보세요\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_0.png)\n\n# 소개\n\nnpm 패키지를 발행하는 데 대해 더 많은 기사를 쓰기로 결정한 이유는 무엇일까요? 제가 스스로 이러한 패키지를 만들어야 할 때, 인터넷의 대부분의 지침이 오래되었거나 제품 제작에 거의 도움이 되지 않는 매우 짧았기 때문입니다.\n\n\n\n모든 단계를 가능한 명확하게 설명하고자 노력하겠습니다. 그래서 여러분도 처음부터 직접 프로젝트를 만들어보실 수 있을 거에요. 시작해 봐요!\n\n간단한 React 애플리케이션을 만드는 것을 제안합니다. 두 개의 버튼으로 이루어진 카운터 값을 증가시키거나 감소시키는 애플리케이션입니다.\n\n우리 애플리케이션은 이렇게 생겼을 거에요:\n\n데모: [링크](https://gapon2401.github.io/my-react-typescript-package/)\n저장소: [링크](https://github.com/gapon2401/my-react-typescript-package)\n\n\n\n우리는 모든 것을 다루는 14단계가 있어요:\n\n- 프로젝트 준비하기\n- React 애플리케이션 만들기\n- Git 구성하기\n- ESLint 구성하기\n- Prettier 구성하기\n- Jest로 테스트 추가하기\n- package.json 구성하고 발행 준비하기\n- 코드를 커밋하고 푸시하기\n- NPM에 발행하기\n- 예제 폴더 생성하기\n- 자동 빌드 설정하기\n- 데모 페이지\n- README.md 파일과 shields.io\n- 릴리스 만들기\n\n# 단계 1. 프로젝트 준비\n\n- 프로젝트의 명령줄에서 다음을 실행하세요:\n\n\n\n```js\nnpm init -y\n```\n\n이 명령어를 실행하면 기본 값으로 package.json 파일이 생성되고, 나중에 필요에 따라 수정할 수 있습니다.\n\n- src 폴더를 생성하세요.\n\n이 폴더에 모든 프로젝트 파일을 보관할 예정입니다.\n\n\n\n프로젝트에 React와 TypeScript를 추가해 보겠어요 (만약 상관 없다면 yarn을 사용할 거에요)\n\n```js\nyarn add -D react react-dom typescript @types/react\n```\n\n이제 node_modules 폴더와 yarn.lock 파일이 생성되었어요 — 꽤 좋죠!\n\n- TypeScript를 컴파일하기 위해 프로젝트 루트에 다음 내용을 가진 tsconfig.json 파일을 생성하세요:\n\n\n\n위의 내용을 참조하시면 가능한 모든 속성을 확인할 수 있어요: https://www.typescriptlang.org/tsconfig\n\n주요 내용:\n\n- rootDir — 소스 파일 내에서의 루트 폴더\n\n- include— TypeScript 프로젝트에 포함될 파일을 지정\n\n\n\n- exclude — TypeScript 프로젝트에서 제외할 파일을 지정합니다. dist 폴더와 모든 node_modules를 포함하고 싶지 않습니다.\n\n- outDir — 이것은 컴파일된 출력물의 위치입니다.\n\n- 빈 README.md 및 LICENSE 파일을 생성합니다.\n\n어떤 라이센스를 사용할지는 당신에게 달려있습니다. 저는 MIT를 사용할 것입니다. 해당 파일의 내용을 확인할 수 있습니다.\n\n\n\n위에 있는 내용을 마크다운 형식으로 바꿔보세요:\n\n![structure](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_1.png)\n\n## 단계 2. React 애플리케이션 만들기\n\nsrc 폴더 안에 components 폴더를 만들어주세요. 여기에 프로젝트의 모든 컴포넌트를 보관할 수 있습니다. 이 글에서는 여기에 App.tsx라는 파일 하나만 만들어보겠습니다. 파일에는 아래 내용을 넣어주세요:\n\n\n\n저희의 React 애플리케이션이에요.\n\n이제 src 폴더 안에 index.ts 파일을 만들어주세요. 모듈을 내보내세요.\n\n프로젝트를 컴파일할 시간이에요!\n\npackage.json을 열어서 scripts 섹션을 변경해봐요:\n\n\n\n터미널에서 다음 명령을 실행하세요:\n\n```js\nyarn build\n```\n\n모든 컴파일된 코드와 함께 dist 폴더가 나타날 것입니다.\n\n축하합니다! 컴파일된 애플리케이션을 생성했습니다. 조금 더 나가야 할 과정이 남았습니다! (아마도.)\n\n\n\n위에서 언급한 단계 2 이후의 프로젝트 구조를 비교해보세요:\n\n![프로젝트 구조](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_2.png)\n\n## 단계 3. git 설정하기\n\n프로젝트를 빠르게 만들었으니 이제 git을 설정할 시간입니다.\n\n\n\n프로젝트 루트에서 다음 명령어로 git을 초기화하세요:\n\n```js\ngit init\n```\n\n프로젝트 루트에 다음 내용을 가진 .gitignore 파일을 생성하세요:\n\n```js\nnode_modules\n.idea\ndist\nyarn-error.log\n```\n\n\n\nJetbrains IDE를 사용하여 개발을 도와주기 때문에 .idea를 추가했어요.\n\n.gitignore 파일에는 리포지토리에 포함하고 싶지 않은 파일과 디렉터리를 나열합니다.\n\nGitHub에서 git repo를 만드세요. 나중에 초기 커밋을 만들고 원격 git을 로컬 git에 연결할 거에요.\n\n# 단계 4. ESLint 구성\n\n\n\nESLint은 코드를 정적으로 분석하여 빠르게 문제를 찾아줍니다. 우리는 개발 시에만 필요합니다.\n\n다음 코드로 eslint와 모든 필요한 구성 요소를 추가해주세요:\n\n```js\nyarn add -D eslint eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser\n```\n\n원하는 대로 구성할 수 있으며, 자세한 사용자 가이드는 여기에 있어요: https://eslint.org/docs/user-guide/configuring/\n\n\n\n프로젝트의 루트에 .eslintrc 파일을 만드는 것을 제안합니다:\n\n.eslintignore 파일을 추가하세요:\n\n```js\nnode_modules\ndist\n```\n\n우리는 컴파일된 파일이 위치한 dist 폴더와 node_modules를 체크하지 않도록 무시할 것입니다.\n\n\n\n테이블 태그를 마크다운 형식으로 변경해 주세요.\n\n\n\n```js\nyarn lint\n```\n\n에러가 없어야 해요. \n\n스텝 4 이후 프로젝트 구조를 비교해보세요:\n\n![프로젝트 구조 비교](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_3.png)\n\n\n\n# 단계 5. Prettier 구성\n\nPrettier는 코드 포매터입니다. 팀으로 작업할 때 사용하면 모두의 코드가 동일한 표준을 준수하게 됩니다.\n\n터미널에서 다음 명령을 실행해주세요:\n\n```js\nyarn add -D eslint-config-prettier eslint-plugin-prettier prettier\n```\n\n\n\n프로젝트 루트에서 .prettierrc.json 파일을 만들어주세요:\n\n모든 옵션에 대해 더 알아보려면 여기를 확인해주세요: https://prettier.io/docs/en/options.html.\n\n.eslintrc에 prettier 플러그인을 추가해주세요:\n\nprettier 설정이 완료되었습니다! 이제 yarn lint를 실행하여 포맷 에러를 확인해보세요. 에러가 없다면, 인간인지 확인해보세요 😆.\n\n\n\n<img src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_4.png\" />\n\n이제 그것들을 수정해 봅시다! package.json에 다음을 추가하세요:\n\n```js\n\"prettier\": \"prettier --write \\\"{src,tests,example/src}/**/*.{js,ts,jsx,tsx}\\\"\"\n```\n\n좋아요, yarn prettier를 실행하면 다음과 유사한 결과를 얻을 수 있습니다:\n\n\n\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_5.png)\n\n이제 yarn lint를 실행한 후에는 오류가 없어야 합니다. src/components/App.tsx 및 src/index.ts 파일을 확인해보세요. 변경되었습니다.\n\npackage.json의 scripts 섹션:\n\n```js\n\"scripts\": {\n  \"build\": \"tsc\",\n  \"lint\": \"eslint \\\"{**/*,*}.{js,ts,jsx,tsx}\\\"\",\n  \"prettier\": \"prettier --write \\\"{src,tests,example/src}/**/*.{js,ts,jsx,tsx}\\\"\"\n}\n``` \n\n\n\nStep 5 이후 프로젝트 구조를 비교해보세요:\n\n![프로젝트 구조](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_6.png)\n\n## 단계 6. Jest를 사용한 테스트 추가\n\n테스트를 만들기 위해 저는 Jest 라이브러리를 사용하고 있어요. Jest는 꽤 유용하고 강력한 테스트 프레임워크에요. 얼마나 어려운 테스트를 작성할지는 당신에게 달렸어요.\n\n\n\n프로젝트에 jest를 추가해주세요:\n\n```js\nyarn add -D jest jest-canvas-mock jest-environment-jsdom ts-jest @types/jest @testing-library/react\n```\n\n프로젝트 루트 파일 jestconfig.json을 생성해주세요.\n\n폴더 tests를 만들어주세요.\n\n\n\n첫 번째 테스트를 작성하는 시간입니다. 우리는 매우 간단한 테스트를 작성할 것인데, 렌더링이 성공적으로 이루어졌는지 확인할 것입니다.\n\ntests 폴더 안에 common.test.tsx 파일을 만들어주세요.\n\npackage.json 파일의 scripts 섹션을 변경해주세요:\n\n```js\n\"test\": \"jest --config jestconfig.json\"\n```\n\n\n\nyarn test 명령을 실행해보세요. 테스트가 통과해야 합니다:\n\n![프로젝트 구조 비교 후 이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_7.png)\n\n스텝 6 이후의 프로젝트 구조를 비교해보세요:\n\n![스텝 6 이후 프로젝트 구조 이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_8.png)\n\n\n\n# 단계 7. package.json 구성 및 발행 준비\n\n저는 빌드를 분리하는 것을 제안합니다. 우리는 패키지를 가능한 한 접근하기 쉽게 만들기 위해 ECMAScript 모듈뿐만 아니라 CommonJs 모듈도 컴파일할 것입니다.\n\npackage.json 파일에서 다음을 대체하세요:\n\n```json\n\"build\": \"tsc\",\n```\n\n\n\n다음 코드를 사용하여\n\n```js\n\"build\": \"yarn build:esm && yarn build:cjs\",\n\"build:esm\": \"tsc\",\n\"build:cjs\": \"tsc --module commonjs --outDir dist/cjs\",\n```\n\nbuild:esm과 build:cjs를 추가하고 이를 하나의 명령어로 결합했습니다.\n\nyarn build를 실행하면, 이제 dist/ 폴더에 cjs 폴더가 생성된 것을 확인할 수 있습니다.\n\n\n\n더 나아가보세요.\n\npackage.json 파일에서는 패키지가 게시될 때 자동으로 호출되는 매직 스크립트를 사용할 수 있습니다. 이러한 스크립트를 사용하면 패키지를 모든 종류의 오류로부터 확인하고 실수로 업데이트를 업로드하여 패키지가 사용되는 수백 만 프로젝트를 충돌시키지 않도록 도와줍니다!\n\n- prepare — 패키지가 패킹되고 게시되기 전에 실행됩니다. 인수 없이 로컬 npm install에서 실행됩니다.\n- prepublishOnly — 패키지가 준비되고 패킹되기 전에 실행됩니다. npm publish에서만 실행됩니다. 여기에는 테스트가 들어갑니다.\n\n다음을 스크립트 섹션에 추가하세요:\n\n\n\n```json\n\"scripts\": {\n  \"prepare\": \"npm run build\",\n  \"prepublishOnly\": \"npm test && npm run prettier && npm run lint\"\n},\n\"main\": \"dist/index.js\",\n\"types\": \"dist/index.d.ts\"\n```\n\n\n\n```js\n\"main\": \"index.js\",\n```\n\n다음과 같이 변경해주세요:\n\n```js\n\"main\": \"./dist/cjs/index.js\",\n\"module\": \"./dist/esm/index.js\",\n\"types\": \"./dist/esm/index.d.ts\",\n```\n\n원격 Git 저장소에 대한 정보를 추가해주세요 (단계 3에서 제공한 Git URL을 명시해주세요):\n\n\n\n```js\n\"repository\": {\n  \"type\": \"git\",\n  \"url\": \"git+https://github.com/gapon2401/my-react-typescript-package.git\"\n},\n```\n\n우리 패키지를 사용할 프로젝트는 적어도 `=16` 버전 이상의 리액트 버전을 가져야 합니다:\n\n```js\n\"peerDependencies\": {\n  \"react\": \">=16\"\n},\n```\n\n패키지가 불필요한 파일이 없도록하려면, 허용된 파일 및 폴더만 사용하여 패키지에 추가하십시오:\n\n\n\n\n```js\n\"files\": [\n  \"dist\",\n  \"LICENSE\",\n  \"README.md\"\n],\n```\n\n프로젝트를 찾을 수 있도록 키워드를 추가해주세요:\n\n```js\n\"keywords\": [\n  \"react\",\n  \"typescript\",\n  \"awesome-project\"\n],\n```\n\n라이선스를 명시해주세요:\n\n\n\n```js\n\"license\": \"MIT\",\n```\n\n저자 이름 변경하는거 잊지 마세요:\n\n```js\n\"author\": \"Igor Gaponov (gapon2401)\",\n```\n\n그게 충분한 것 같아요.\n\n\n\nREADME.md 파일에 설명을 추가해주세요.\n\n현재 README 파일에는 한 줄만 있습니다. 이것이 h1 입니다:\n\n```js\n# my-react-typescript-package\n```\n\npackage.json 파일의 최종 버전을 확인해보세요.\n\n\n\n# 단계 8. 코드를 커밋하고 푸시하세요\n\n우선, 원격 및 로컬 저장소를 연결하고 프로젝트를 푸시해 봅시다.\n\n다음 코드를 실행해 주세요:\n\n```js\ngit add .\ngit commit -m \"Initial commit\"\ngit remote add origin <저장소 URL>\ngit push -u origin master\n```\n\n\n\n본인의 `Repository Url`을 변경하는 것을 잊지 마세요. 이는 https URL이거나 ssh 일 수 있습니다. 이 URL은 레포지토리에서 얻을 수 있습니다.\n\n다음과 같은 예시를 살펴보세요.\n\n- HTTPS 레포지토리 URL (인증이 필요합니다)\n\n```js\ngit remote add origin https://github.com/gapon2401/my-react-typescript-package.git\n```\n\n\n\n- SSH 저장소 URL (SSH 연결 구성 필요)\n\n```js\ngit remote add origin git@github.com:gapon2401/my-react-typescript-package.git\n```\n\n저는 두 번째 해결책을 사용했어요.\n\n# 단계 9. NPM에 발행\n\n\n\n- 패키지 이름 선택하기\n\n우리 패키지의 이름을 사용할 수 있는지 확인해야 합니다. https://www.npmjs.com/ 웹사이트로 이동하여 검색 도구를 사용해보세요.\n\npackage.json 파일에서 프로젝트의 기본 이름을 찾아 변경할 수 있습니다:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_9.png)\n\n\n\n나의 경우에는 my-react-typescript-package 이 있습니다. 아직 그런 패키지는 없네요.\n\n다음과 같이 링크에 이름을 직접 삽입하여 확인하는 것이 더 좋다고 생각해요:\n\n```js\nhttps://www.npmjs.com/package/<당신의 패키지 이름>\n```\n\n`당신의 패키지 이름` 자리에 프로젝트의 이름을 넣어주세요.\n\n\n\n다음 URL을 받았어요:\n\n```js\nhttps://www.npmjs.com/package/my-react-typescript-package\n```\n\n만약 이름이 무료하면 404 페이지가 표시됩니다:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_10.png)\n\n\n\n- NPM에 등록/로그인하기\n\n프로젝트를 게시하려면 https://www.npmjs.com/에서 인증해야 합니다.\n\n아직 계정이 없다면 https://www.npmjs.com/signup에서 등록하거나 명령줄을 사용해 주세요:\n\n```js\nnpm adduser\n```\n\n\n\n사용자 이름, 비밀번호 및 이메일을 입력하라는 메시지가 표시됩니다.\n\n이미 계정이 있는 경우에는 다음을 실행하세요:\n\n```js\nnpm login\n```\n\n그리고 인증을 완료하세요.\n\n\n\n- 배포하기\n\n배포하기 전에 필요한 파일만 패키지에 포함되었는지, 오류가 없는지, 그리고 모든 것이 올바르게 포맷되어 있는지 확인하는 것을 추천합니다. 이를 위해 아래 명령어를 실행할 수 있습니다:\n\n```js\nnpm publish --dry-run\n```\n\n패키지가 실제로 게시되지는 않을 거에요, 걱정 마세요.\n\n\n\n\"매직 스크립트인 prepublishOnly가 호출되어 테스트 및 코드 형식 지정이 실행됨을 확인하게 될 거에요.\n\n그런 다음 프로젝트에 포함된 모든 파일 목록을 볼 수 있게 되며:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_11.png)\n\nTarball 콘텐츠에는 package.json에서 지정된 파일 및 폴더가 포함되어 있습니다:\"\n\n\n\n```js\n\"files\": [\n   \"dist\",\n   \"LICENSE\",\n   \"README.md\"\n ],\n```\n\n모든 준비가 끝났어요! 이제 패키지를 게시하면 돼요!\n\n다음 명령어를 실행해 주세요:\n\n```js\nnpm publish\n```\n\n\n\n이 명령을 실행할 때마다 항상 걱정이 돼요.\n\n명령 호출의 전체 결과를 첨부합니다:\n\n![Command Result](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_12.png)\n\n이제 축하해요! 패키지가 발행되었어요. 공개되었고, 누구든 사용할 수 있어요! 생각보다 어렵지 않았죠.\n\n\n\nNPM에서 해당 패키지를 확인해보세요.\n\n이전에 열었던 링크를 열어보세요.\n\n```js\nhttps://www.npmjs.com/package/<당신의 패키지 이름>\n```\n\n<img src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_13.png\" />\n\n\n\n잘 보이네요!\n\n# 단계 10. 예제 폴더 만들기\n\n우리 패키지를 계속 발전시키는 재미를 느껴봐요. 이번 단계에서는 패키지를 어떻게 활용할 수 있는지 보여줄 예제 폴더를 만들 것입니다. 이 폴더에서는 서버를 빠르게 시작하고 코드를 테스트할 수 있어요. \n애플리케이션을 빠르게 실행하려면 https://parceljs.org/를 사용할 거에요.\n\n`example`라는 폴더를 생성하세요.\n\n\n\n해당 폴더 안에 비어 있는 src 폴더와 파일을 만들어주세요:\n\n- .gitignore:\n\n```js\nnode_modules\nyarn.lock\n.parcel-cache\ndist\nyarn-error.log\n```\n\n- package.json:\n\n\n\n- README.md:\n\n자, 지금 주의를 기울여봐! 프로젝트의 루트 디렉토리에서 명령줄을 열고 예제 폴더로 이동해봐:\n\n```js\ncd example\n```\n\n그리고 실행해봐:\n\n\n\n```js\nyarn add -D parcel my-react-typescript-package react react-dom @types/react-dom @types/react\n```\n\nsrc 폴더 안에 index.html 파일을 만듭니다.\n\n이제, 우리 패키지를 가져와서 사용하는 예제를 작성해야 합니다.\n\nsrc 폴더 안에 index.tsx 파일을 만듭니다.\n\n\n\n서버를 실행할 시간입니다! 아래 명령어를 사용해주세요:\n\n```js\nyarn start\n```\n\n서버가 성공적으로 실행되면 다음 메시지가 표시됩니다:\n\n<img src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_14.png\" />\n\n\n\n아래의 예시를 확인하려면 http://localhost:1234 링크를 열어보세요:\n\n![예시 이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_15.png)\n\n모든 설치와 서버 실행 후의 예시 폴더 구조를 비교해보세요. 아래와 같은 모양이어야 합니다:\n\n![예시 이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_16.png)\n\n\n\n# 단계 11. 자동 빌드 설정하기\n\n자동 빌드에 대해 이야기해보겠습니다. 변경 사항을 git에 푸시하고 각 릴리스마다 npm에 푸시해야 하는 것은 꽤 불편합니다. 이 프로세스를 GitHub Actions로 자동화할 것입니다.\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_17.png)\n\n프로젝트 구조의 루트에 .github라는 폴더를 생성해주세요.\n\n\n\n안녕하세요! 친절한 안내드립니다.\n\nMarkdown 형식으로 테이블 태그를 변경하고,\n\n폴더 workflows를 만드세요.\n\n그 안에 파일 publish.yml을 만드세요:\n\n파일 안에는 중요한 포인트들이 주석처리되어 있습니다.\n\nGitHub에 릴리스할 때 우리의 패키지가 자동으로 빌드되어 NPM에 푸시됩니다.\n\n\n\n다음 라인을 확인해 주세요:\n\n```js\n# 우리 NPM 계정에 필요합니다\nNODE_AUTH_TOKEN: ${ secrets.NPM_TOKEN }\n```\n\n이 방법으로 GitHub를 NPM과 연결할 예정입니다.\n\n브라우저에서 https://www.npmjs.com/ 에서 계정을 열고 토큰이 있는 페이지로 이동해 주세요:\n\n\n\n아래는 Markdown 형식으로 변경된 내용입니다.\n\n\n![이미지1](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_18.png)\n\n새 토큰을 생성하십시오:\n\n![이미지2](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_19.png)\n\n이름을 입력하고 유형을 선택하라는 메시지가 표시됩니다. Automation은 github-actions에 적합합니다.\n\n\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_20.png)\n\n토큰을 복사하고 Github 레포지토리를 엽니다.\n\n탭 설정으로 이동하여 Secrets — Actions를 엽니다. 새 저장소 시크릿 변수를 만듭니다. NPM_TOKEN이라는 이름을 주고 NPM에서 받은 토큰 값을 붙여넣습니다:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_21.png)\n\n\n\n잘 했어요! 이제 프로젝트의 새 버전을 만들고 GitHub에 푸시하기만 남았어요.\n\n어떤 변경 사항을 커밋하기 전에 다음 명령어를 실행하는 것을 잊지 마세요:\n\n```js\nyarn prepublishOnly\n```\n\n코드가 깔끔하게 유지될 수 있도록 확인하는 것이 좋아요.\n\n\n\n프로젝트를 푸시한 후에 Actions 탭으로 이동하면 GitHub이 워크플로 액션을 감지했음을 알 수 있습니다. 그러나 아직 아무것도 시작되지 않았습니다. 왜냐하면 우리가 아직 릴리스를 만들지 않았기 때문입니다.)\n\n![image](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_22.png)\n\n# 단계 12. 데모 페이지\n\n이미 패키지를 사용하는 예제가 있는 폴더가 있지만, 전체 프로젝트를 클론하지 않고도 사용자가 빠르게 패키지 작업을 볼 수 있도록 서로 다른 페이지를 만들고 싶습니다. 이 페이지를 만들어 봅시다!\n\n\n\n우리는 깃허브 페이지를 사용하여 데모를 만들 거에요.\n\n새 깃 브랜치를 만들어보세요:\n\n```js\ngit checkout -b gh-pages\n```\n\n이제 프로젝트에서 모든 파일을 지우세요!\n\n\n\n이전 파일들은 모두 안전하게 다른 master 브랜치에 보관될 거니까 걱정하지 마세요. gh-pages 브랜치는 데모용으로만 사용될 거에요. 그래서 모든 파일을 삭제해야 해요. 자, 모두 삭제해주세요!\n\n그런 다음 명령 줄에서 다음을 실행하세요:\n\n```js\nnpm init -y\n```\n\n이 명령은 package.json 파일을 생성할 거에요. 이번에는 자세히 설정하지 않을 거에요.\n\n\n\n데모 페이지에는 우리가 익숙한 Parcel을 사용하는 것을 제안합니다 (단계 10)\n\n다음을 실행해보세요:\n\n```js\nyarn add -D parcel my-react-typescript-package react react-dom @types/react-dom @types/react typescript\n```\n\n`.gitignore` 파일을 생성하세요:\n\n\n\n```js\nnode_modules\nyarn.lock\n.parcel-cache\ndist\nyarn-error.log\n```\n\n다음 내용을 포함한 파일 tsconfig.json을 생성하세요.\n\nEslint를 설정하는 단계 4를 따르세요.\n\n빈 폴더 src를 생성하세요. 그 안에 다음 내용을 가진 파일 index.html을 생성하세요.\n\n\n\n새로운 index.tsx 파일을 생성해주세요.\n\npackage.json 파일의 scripts 섹션에 아래 코드를 추가해주세요:\n\n```json\n\"start\": \"parcel src/index.html\",\n\"build\": \"parcel build src/index.html --dist-dir docs --public-url .\"\n```\n\n제 package.json 파일을 확인해주세요.\n\n\n\n서버를 실행하여 모든 것이 잘 작동하는지 확인하세요:\n\n```js\nyarn start \n```\n\n이제 다음 명령어를 사용하여 오류를 확인하는 코드를 실행하세요:\n\n```js\nyarn lint\n```\n\n\n\n수정 사항 없습니다! 멋져요! 이제 페이지를 만들 차례에요.\n\n```js\nyarn build\n```\n\n데모 프로젝트의 모든 파일이 포함된 docs 폴더가 표시될 거예요.\n\n다음은 브랜치 gh-pages의 구조입니다:\n\n\n\n<img src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_23.png\" />\n\n이제 변경 사항을 모두 git에 푸시합시다. 다음을 실행하세요:\n\n```js\ngit add .\ngit commit -m \"초기 페이지 커밋\"\ngit push -u origin gh-pages\n```\n\nGitHub 저장소를 열어서 설정으로 이동하고 페이지로 이동합니다. 소스에서 /docs를 선택한 후 Save를 누릅니다:\n\n\n\n<img src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_24.png\" />\n\n약 3-5분 정도 기다리시면 지정된 URL에 사이트가 이용 가능해집니다. 페이지에 표시된 URL을 확인해보세요.\n\n<img src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_25.png\" />\n\n데모 페이지 작업이 끝났습니다. 보시다시피 사용자의 취향에 맞게 원하는 대로 커스터마이즈하고 어떠한 복잡도의 페이지나 웹사이트를 만들 수 있습니다.\n\n\n\n여기 결과가 있어요: [https://gapon2401.github.io/my-react-typescript-package/](https://gapon2401.github.io/my-react-typescript-package/)\n\n# 단계 13. README.md 파일 및 shields.io\n\n이제 코드 작업이 끝났으니, 이제 패키지의 설명 파일로 전환해 볼게요.\n\ngit에서 master 브랜치로 전환하고 README.md 파일을 열어주세요.\n\n\n\n테이블 태그를 마크다운 형식으로 변경해주세요:\n\n\nFor the description file, we are using markdown.\n\nIn README.md, I have added a short description of the package, link to demo-page, and a usage section.\n\nAt the beginning of the readme file, I have small cute icons. This is [shields.io](https://shields.io/). It is very convenient to have them. I’ve added just a couple as an example, you can use as many as you want.\n\n\n\nGitHub 앱lications에 shields.io를 추가해보세요.\n\n파일 끝을 살펴보세요; 이미지와 링크가 있는 변수를 만들었습니다. Markdown을 사용하면 이러한 변수를 만들 수 있기 때문에 설명 파일이 더 정확해집니다. 저장소 경로와 패키지 이름을 변경하는 것을 잊지 마세요.\n\npackage.json에서 버전을 변경하고, 커밋하고 파일을 레포지토리에 푸시하세요. 모든 작업은 스스로 진행해주세요. 이전 단계에 이미 수행했던 것과 같은 절차입니다.\n\n# 단계 14. 릴리스 만들기\n\n\n\n이것이 마지막 단계입니다. 짧을 거에요.\n\n우리가 계획했던 모든 것을 완료했어요! 이제 공식 릴리스를 GitHub에 작성하고 자동 빌드가 어떻게 작동하는지 확인할 수 있어요.\n\n저장소의 메인 페이지로 이동해서 '새 릴리스 생성'을 클릭하세요:\n\n![Create a new release](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_26.png)\n\n\n\n현재 버전을 지정하는 태그를 추가하세요. 릴리스 시 자동으로 생성됩니다. 릴리스 제목과 설명을 인쇄하고 릴리스를 발행하려면 클릭하십시오.\n\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_27.png)\n\n이제 탭 \"Actions\"를 열고 빌드가 성공적으로 완료되었는지 확인하세요.\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_28.png)\n\n\n\n패키지를 NPM에서 업데이트했는지 확인해 봐요.\n\n패키지 링크를 열어 볼게요:\n\n```js\nhttps://www.npmjs.com/package/<패키지 이름>\n```\n\n제것을 열어 볼게요:\n\n\n\n```js\nhttps://www.npmjs.com/package/my-react-typescript-package\n```\n\n새 버전과 새 설명이 나와 있어요:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_29.png)\n\n긴 여정이었지만, 매우 유용하길 바랍니다. 처음 패키지를 게시할 때 어려웠던 모든 것을 설명하기 위해 노력했고, 이 정보들을 조각 조각 모았어요.\n\n\n\n읽어 주셔서 감사합니다! ❤","ogImage":{"url":"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_0.png"},"coverImage":"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_0.png","tag":["Tech"],"readingTime":17},{"title":"고르는 아픔","description":"","date":"2024-05-12 22:33","slug":"2024-05-12-ChooseYourPain","content":"\n\n나의 이야기를 탐험하면서, 당신에게 권장하고 싶은 것은 당신의 삶의 여정에 대해 깊이 사색에 몰입하는 것입니다. 오늘, 여러분은 수많은 영혼 사이에서 스스로의 길을 명확한 로드맵 없이 개척하는 사람들 중 하나로 자리 잡게 될 것입니다. 당신은 스스로의 생존을 책임져야 함을 깨달았습니다.\n\n도전을 극복하며 지혜롭게 이끌어나가는 도중에, 때로는 승리를 거두기도 하고 가치 있는 교훈을 얻기도 합니다. 매일 과업을 완수하기 위해 노력하고 있습니다. 작업을 완료하지 못했더라도, 탄탄한 인내심을 지닌 채 새로운 하루를 맞이할 준비가 되어 있습니다. 삶이 불가피한 실패를 안겨주더라도, 여러분은 다시 일어서며 고통 속에서 현명해짐을 이해하고 있는 강한 의지를 지니고 있습니다.\n\n이러한 경험들이 삶의 틀을 짜며, 항복은 선택지가 아닙니다. 노력은 성공으로 가는 길이며, 무능히 행동함은 패배를 보장합니다. 삶은 다양한 고통을 제공합니다. 여러분의 고통을 선택하세요.","ogImage":{"url":"/assets/img/2024-05-12-ChooseYourPain_0.png"},"coverImage":"/assets/img/2024-05-12-ChooseYourPain_0.png","tag":["Tech"],"readingTime":1},{"title":"리액트 네이티브 앱을 위한 CICD 파이프라인 Fastlane과 GitHub Actions 사용하기 - 파트 1 Fastlane 이해하기","description":"","date":"2024-05-12 22:32","slug":"2024-05-12-CICDpipelineforReactNativeappsuseFastlaneandGitHubActions-Part1understandFastlane","content":"\n\n![Screenshot](/assets/img/2024-05-12-CICDpipelineforReactNativeappsuseFastlaneandGitHubActions-Part1understandFastlane_0.png)\n\n리액트 네이티브 프레임워크는 크로스 플랫폼 앱 개발을 혁신적으로 변화시켰으며, iOS 및 Android 모두에 대한 풍부하고 성능이 우수한 애플리케이션을 개발할 수 있도록 허용합니다. 그러나 현대 소프트웨어 개발에서 요구되는 민첩성은 코드 작성 뿐만 아니라 견고한 테스트, 자동화된 빌드 및 신속한 배포도 포함됩니다.\n\n리액트 네이티브는 iOS 및 Android 애플리케이션 모두를 제공하므로 Apple 및 Google 스토어에 출시하는 것은 머리아플 수도 있습니다: 둘 다 별도로 빌드하고 테스트하고, 리뷰에 제출하고 확인을 기다립니다. 리액트 네이티브의 초창기에 이러한 프로세스를 수행하는 것은 머리아팠지만, 그 이후에 그 작업을 수행할 수 있는 도구들이 출시되었습니다.\n\n해당 프로세스는 다음과 같이 수행되었습니다:\n\n\n\n## 안드로이드 (Google Play Store):\n\n- 개발자들은 Android Studio를 사용하여 코드를 작성하고 안드로이드 앱 프로젝트를 관리합니다. Gradle은 빌드 프로세스를 자동화하며 코드 컴파일 및 APK 생성과 같은 작업을 처리합니다. 앱이 배포 준비가 되면, 개발자들은 Google Play 콘솔을 사용하여 앱을 제출하고, 앱 메타데이터를 관리하며 사용자 피드백 및 분석을 모니터링합니다.\n\n## iOS (Apple App Store):\n\n- Xcode는 iOS 앱 개발의 주요 도구로, 구축 및 테스트를 위한 포괄적인 기능 세트를 제공합니다. Fastlane은 Xcode를 보완하여 배포 작업을 자동화합니다. 개발자들은 Fastlane 레인을 구성하여 앱을 빌드, 코드 서명, App Store에 앱을 릴리스하는 작업을 처리합니다. Apple Developer 계정은 App Store에 앱을 제출하기 위한 필수 사항이며, 여기서 개발자들은 앱 인증서, 프로비저닝 프로필 및 앱 제출을 관리합니다.\n\n\n\n표가 있던 형식은 자동화 도구들이 소개되기 전까지는 그랬어요. 그 중 일부는 다음과 같아요:\n\n## Expo\n\nExpo는 React Native 앱의 개발 및 배포를 간단하게 만드는 플랫폼이에요. iOS 및 Android 장치 모두에 앱을 쉽게 구축, 테스트 및 배포할 수 있는 도구와 서비스를 제공해요. 또한 Expo에는 Google Play Store와 Apple App Store용 앱 이진 파일을 생성할 수 있는 내장된 빌드 서버도 포함돼 있어요.\n\n## Fastlane\n\n\n\n패스트레인은 iOS 및 안드로이드 앱 개발 및 배포와 관련된 작업을 자동화하는 도구입니다. 빌드, 테스트, 앱 배포, Google Play Store 및 Apple App Store를 위한 스크린샷 및 메타데이터 생성 등과 같은 작업을 자동화하는 데 사용할 수 있습니다.\n\n패스트레인은 \"레인\"이라는 개념을 소개하여 워크플로우를 간소화합니다. 빌드, 테스트, 코드 서명 및 배포와 같은 작업을 자동화하여 수동 에러를 줄이고 전체 생산성을 향상시킵니다.\n\n## AppCenter\n\nAppCenter는 iOS 및 안드로이드 기기에 앱을 빌드, 테스트 및 배포하는 데 사용되는 도구 모음을 제공하는 플랫폼입니다. 내장된 빌드 서버, 지속적 통합 및 지속적 전달 (CI/CD) 파이프라인 및 배포 플랫폼이 포함되어 있습니다.\n\n\n\n## Codemagic\n\n코드매직은 클라우드 기반 CI/CD 플랫폼으로, 모바일 앱의 빌드 및 배포를 자동화하는 데 사용할 수 있습니다. Expo, Fastlane, AppCenter 등 다양한 도구와 통합됩니다.\n\n## Firebase\n\nFirebase는 모바일 앱을 빌드, 배포 및 관리하기 위한 다양한 서비스를 제공하는 플랫폼입니다. 내장된 CI/CD 파이프라인, 배포 플랫폼, 그리고 분석, 크래시 보고 등의 기능을 위한 도구 세트를 포함하고 있습니다.\n\n\n\n저에게 있어서 제일 좋은 도구는 Fastlane이었어요. 이 도구를 사용해서 제작한 앱들을 수동으로 제출하는데 사용했지만, GitHub Actions가 도입되면서 더 쉬워졌어요.\n\nGitHub Actions는 GitHub 저장소와 완벽하게 통합되는 CI/CD 플랫폼입니다. 이를 사용하여 개발자들은 코드 푸시 또는 풀 리퀘스트와 같은 이벤트로 트리거되는 자동화된 워크플로우를 정의할 수 있습니다.\n\n이 기사에서는 Fastlane을 GitHub Actions와 함께 사용하여 CI/CD 릴리스 프로세스를 진행하는 방법을 단계별로 안내할 거에요.\n\n## 가정들\n\n\n\n튜토리얼 일부를 따를 수 있어요:\n\n- 맥 머신을 사용하고 계시다면 좋아요\n- React Native 저장소를 호스팅하는 GitHub 계정을 가지고 있어요\n- React Native 앱과 이미 통합된 Firebase 계정을 가지고 있어요 (Firebase 앱 배포를 건너뛸 수 있다면 선택사항)\n- Google Play Store와 iOS App Store에 앱이 등록되어 있어요\n\n# 솔루션을 엔지니어링하는 방법:\n\n이 섹션에서는 Fastlane과 Github actions을 통합하는 방법을 설명하고 싶어요. 다른 튜토리얼을 읽을 수 있지만, 주로 어떻게 하는지 보여주는 것보다는 어떻게 엔지니어링하는지에 대해 알려드릴 거예요. '어떻게 생각하는지 가르치는' 방법을 알 수 있을 거예요.\n\n\n\n## Fastlane의 내부 작동 방식:\n\nFastlane은 빌드, 테스트 및 제출 작업을 자동화합니다. 아래와 같은 방법으로 사용됩니다:\n\n- 레인 정의: Fastfile에서 레인을 정의하여 관련 작업을 그룹화합니다. 예를 들어, 앱을 빌드하는 레인, 앱을 테스트하는 레인, 앱을 배포하는 레인 등이 있을 수 있습니다.\n- 플러그인 사용: Fastlane은 다양한 작업을 자동화할 수 있는 풍부한 플러그인 생태계를 보유하고 있습니다. 예를 들어, 앱을 빌드하는 플러그인, 앱을 테스트하는 플러그인, 스크린샷을 생성하는 플러그인, 앱을 앱 스토어에 제출하는 플러그인 등이 있습니다.\n- 자격증명 및 비밀 정보: Fastlane은 API 키, 인증서, 프로비저닝 프로필과 같은 중요 정보를 안전하게 관리할 수 있는 방법을 제공합니다. 이러한 정보는 빌드 프로세스 중에 안전하게 저장되고 액세스할 수 있습니다.\n\n- iOS 및 Android 앱에 서명하기 위해 인증서와 프로비저닝 프로필이 필요합니다. 이를 통해 개발자는 Apple 또는 Google에 자신을 식별하고 앱을 앱 스토어 또는 구글 플레이에 배포할 수 있습니다.\n- 이는 빌드 및 제출 작업시 다른 인증서와 프로비저닝 프로필이 필요하기 때문에 중요합니다. 이를 관리하기 위해 사용되는 플러그인 중 하나가 Fastlane Match입니다.\n\n\n\n4. 앱 테스트하기: Fastlane을 사용하면 배포 전에 앱이 정확히 작동하는지 확인하는 테스트를 실행할 수 있습니다.\n\n5. 스크린샷 생성하기: Fastlane을 사용하면 앱 스토어를 위한 스크린샷을 생성할 수 있어서 앱이 다양한 기기에서 잘 보이도록 할 수 있습니다.\n\niOS의 경우:\n\n- Fastlane을 사용하여 원하는 iOS 기기나 시뮬레이터용으로 앱을 빌드할 수 있습니다.\n- Fastlane을 사용하여 XCTest나 Jest와 같은 도구로 iOS 테스트를 실행할 수 있습니다.\n- Fastlane을 사용하여 FastlaneSnapshots와 같은 도구로 앱 스토어를 위한 스크린샷을 생성할 수 있습니다.\n- Fastlane을 사용하여 App Store Connect와 같은 도구로 앱을 앱 스토어에 제출할 수 있습니다.\n\n\n\n## 안드로이드 용:\n\n- Fastlane은 원하는 Android 장치 또는 에뮬레이터를 위해 Gradle 또는 Bazel을 사용하여 앱을 빌드할 수 있습니다.\n- Fastlane은 Espresso 또는 Mockito와 같은 도구를 사용하여 Android 테스트를 실행할 수 있습니다.\n- Fastlane은 Appium과 같은 도구를 사용하여 Google Play Store를 위한 스크린샷을 생성할 수 있습니다.\n- Fastlane은 Google Play Console과 같은 도구를 사용하여 앱을 Google Play Store에 제출할 수 있습니다.\n\n팁: Fastlane은 미리 정의된 스크립트를 실행하므로 수동으로 수행할 수 있는 작업을 자동화합니다. 이는 Fastlane이 필요하지 않고 앱을 Apple 및 Google 스토어에 제출하는 CI-CD 프로세스를 달성할 수 있다는 것을 의미합니다. 그러나 사용하면 (자동화 도구와 같은) CI-CD 프로세스를 크게 개선할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-12-CICDpipelineforReactNativeappsuseFastlaneandGitHubActions-Part1understandFastlane_0.png"},"coverImage":"/assets/img/2024-05-12-CICDpipelineforReactNativeappsuseFastlaneandGitHubActions-Part1understandFastlane_0.png","tag":["Tech"],"readingTime":5}],"page":"128","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":6},"__N_SSG":true}