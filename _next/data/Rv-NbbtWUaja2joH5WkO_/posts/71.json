{"pageProps":{"posts":[{"title":"개발자라면 반드시 알아야 할 CSS 팁 25가지","description":"","date":"2024-05-17 21:24","slug":"2024-05-17-25CSSHacksEveryDeveloperShouldKnow","content":"\n\n\n![CSS](/assets/img/2024-05-17-25CSSHacksEveryDeveloperShouldKnow_0.png)\n\nCSS (Cascading Style Sheets)은 웹 개발자에게 필수적인 도구로, HTML 요소를 정확하게 스타일링할 수 있게 해줍니다. 그러나 CSS를 정복하는 것은 기본을 알고 있는 것 이상의 일이 필요합니다. 여기에는 여러분의 삶을 더 쉽게 만들고 코드를 더 깔끔하게 만들 수 있는 25가지 CSS 해킹 방법이 있습니다.\n\n## 1. 요소를 수직 및 수평으로 가운데 정렬하기\n\n문제: 요소를 컨테이너 내에서 수직 및 수평으로 가운데 정렬하는 것.\n\n\n<div class=\"content-ad\"></div>\n\n해결책: Flexbox를 사용해주세요.\n\n```js\n.container {\n    display: flex;\n    justify-content: center; /* 수평 가운데 정렬 */\n    align-items: center; /* 수직 가운데 정렬 */\n    height: 100vh;\n}\n```\n\n## 2. `vw`를 사용한 반응형 텍스트\n\n문제: 뷰포트와 비례하여 텍스트가 확대/축소되는지 확인하는 것이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n해결책: `vw` 단위를 사용하세요.\n\n```css\nh1 {\n    font-size: 5vw;\n}\n```\n\n## 3. 종횡비 유지\n\n문제: 요소의 종횡비 유지하기.\n\n<div class=\"content-ad\"></div>\n\n해결책: 백분율 기반의 패딩 사용하기.\n\n```js\n.aspect-ratio-box {\nwidth: 100%;\npadding-top: 56.25%; /* 16:9 비율 */\nposition: relative;\n}\n.aspect-ratio-content {\nposition: absolute;\ntop: 0;\nright: 0;\nbottom: 0;\nleft: 0;\n}\n```\n\n## 4. 커스텀 체크박스 및 라디오 버튼\n\n문제: 기본 체크박스와 라디오 버튼의 스타일링.\n\n<div class=\"content-ad\"></div>\n\n해결책: 기본 입력란을 숨기고 레이블을 스타일링합니다.\n\n```js\n<label class=\"custom-checkbox\">\n<input type=\"checkbox\" />\n<span class=\"checkmark\"></span>\n</label>\n```\n\n```js\n.custom-checkbox input {\ndisplay: none;\n}\n.custom-checkbox .checkmark {\nwidth: 20px;\nheight: 20px;\nbackground-color: #eee;\nborder-radius: 4px;\n}\n.custom-checkbox input:checked + .checkmark {\nbackground-color: #2196F3;\n}\n```\n\n## 5. 레이아웃을 위한 CSS 그리드\n\n<div class=\"content-ad\"></div>\n\n문제: 복잡한 레이아웃 만들기.\n\n해결책: CSS Grid를 사용하세요.\n\n```css\n.container {\ndisplay: grid;\ngrid-template-columns: repeat(3, 1fr);\ngap: 10px;\n}\n.item {\nbackground-color: lightblue;\npadding: 20px;\n}\n```\n\n## 6. 고정 푸터\n\n<div class=\"content-ad\"></div>\n\n문제: 페이지 하단에 푸터를 고정하는 방법\n\n해결책: Flexbox를 사용하세요.\n\n```js\nbody {\n    display: flex;\n    flex-direction: column;\n    min-height: 100vh;\n}\nmain {\n    flex: 1;\n}\nfooter {\n    background-color: #f1f1f1;\n    padding: 10px;\n    text-align: center;\n}\n```\n\n## 7. 부드러운 스크롤\n\n<div class=\"content-ad\"></div>\n\n문제: 앵커 링크에 부드러운 스크롤 추가하기\n\n해결책: `scroll-behavior`를 사용하세요.\n\n```css\nhtml {\nscroll-behavior: smooth;\n}\n```\n\n## 8. 반응형 이미지\n\n<div class=\"content-ad\"></div>\n\n문제: 이미지가 반응형으로 표시되도록하기\n\n해결책: `max-width` 속성 사용\n\n```css\nimg {\n    max-width: 100%;\n    height: auto;\n}\n```\n\n## 9. 텍스트 줄임표(...) 처리\n\n<div class=\"content-ad\"></div>\n\n해결: 넘치는 텍스트 자르기\n\n해결책: `text-overflow`를 사용하세요.\n\n```css\n.truncate {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  width: 200px; /* 또는 필요한 너비 */\n}\n```\n\n## 10. 커스텀 스크롤바\n\n<div class=\"content-ad\"></div>\n\n문제: 스크롤바 스타일링하기.\n\n솔루션: `::-webkit-scrollbar`를 사용하세요.\n\n```js\n::-webkit-scrollbar {\n    width: 10px;\n}\n\n::-webkit-scrollbar-track {\n    background: #f1f1f1;\n}\n\n::-webkit-scrollbar-thumb {\n    background: #888;\n}\n\n::-webkit-scrollbar-thumb:hover {\n    background: #555;\n}\n```\n\n## 11. 전체 화면 배경 이미지\n\n<div class=\"content-ad\"></div>\n\n문제: 배경 이미지를 전체 화면에 적용하는 방법.\n\n해결 방법: `background-size`를 사용하세요.\n\n```css\n.full-screen-bg {\nbackground-image: url('background.jpg');\nbackground-size: cover;\nbackground-position: center;\nheight: 100vh;\n}\n```\n\n## 12. 그라디언트 배경 애니메이션\n\n<div class=\"content-ad\"></div>\n\n문제: 애니메이션 그라데이션 배경 만들기.\n\n해결책: `@keyframes`를 사용하세요.\n\n```js\n@keyframes gradient {\n0% { background-position: 0% 50%; }\n50% { background-position: 100% 50%; }\n100% { background-position: 0% 50%; }\n}\n.animated-gradient {\nbackground: linear-gradient(270deg, #ff7e5f, #feb47b);\nbackground-size: 400% 400%;\nanimation: gradient 15s ease infinite;\n}\n```\n\n## 13. 오버레이\n\n<div class=\"content-ad\"></div>\n\n문제: 이미지에 오버레이 추가하기\n\n해결책: `::after` 가상 요소 사용하세요.\n\n```js\n.image-overlay {\nposition: relative;\n}\n.image-overlay::after {\ncontent: '';\nposition: absolute;\ntop: 0;\nleft: 0;\nwidth: 100%;\nheight: 100%;\nbackground-color: rgba(0, 0, 0, 0.5); /* 투명도 50%인 검은색 */\n}\n```\n\n## 14. 이미지 호버 효과\n\n<div class=\"content-ad\"></div>\n\n문제: 이미지에 호버 효과 추가하기.\n\n해결책: `:hover`를 사용하세요.\n\n```css\n.image-hover img {\n    transition: transform 0.3s;\n}\n.image-hover img:hover {\n    transform: scale(1.1);\n}\n```\n\n## 15. CSS 변수\n\n<div class=\"content-ad\"></div>\n\n문제: 테마 변경을 간단하게하기.\n\n해결책: CSS 변수를 사용하세요.\n\n```css\n:root {\n    --primary-color: #3498db;\n    --secondary-color: #2ecc71;\n}\nbutton {\n    background-color: var(--primary-color);\n    color: var(--secondary-color);\n}\n```\n\n## 16. 이미지용 Object Fit\n\n<div class=\"content-ad\"></div>\n\n문제: 이미지가 왜곡되지 않고 컨테이너 내에 잘 맞게 표시되는지 확인합니다.\n\n해결책: `object-fit`를 사용하세요.\n\n```css\n.fit-image {\n    width: 100%;\n    height: 200px;\n    object-fit: cover; /* 또는 contain, fill 등 */\n}\n```\n\n## 17. 줄 바꿈 방지\n\n<div class=\"content-ad\"></div>\n\n문제: 텍스트가 여러 줄로 나뉘는 것을 방지해야 합니다.\n\n해결책: `white-space`를 사용하세요.\n\n```css\n.no-break {\nwhite-space: nowrap;\n}\n```\n\n## 18. 전체 너비 요소\n\n<div class=\"content-ad\"></div>\n\n문제: 요소가 부모 요소의 전체 너비를 차지하도록 만들기.\n\n해결책: `width: 100vw`를 사용하세요.\n\n```css\n.full-width {\nwidth: 100vw;\nmargin-left: calc(50% - 50vw);\nmargin-right: calc(50% - 50vw);\n}\n```\n\n## 19. SVG 아이콘 색상 제어\n\n<div class=\"content-ad\"></div>\n\n문제: CSS를 사용하여 인라인 SVG의 색상 변경하기\n\n해결책: `currentColor`을 사용하세요.\n\n```css\n.icon {\nfill: currentColor;\n}\n.icon-container {\ncolor: #ff6347;\n}\n```\n\n## 20. 이름이 지정된 영역을 사용한 CSS 그리드\n\n<div class=\"content-ad\"></div>\n\n문제: 이름이 지정된 그리드 영역으로 복잡한 레이아웃을 생성하려면.\n\n해결책: `grid-template-areas`를 사용하세요.\n\n```js\n.grid-container {\n  display: grid;\n  grid-template-areas:\n    'header header'\n    'sidebar content'\n    'footer footer';\n  grid-gap: 10px;\n}\n.header {\n  grid-area: header;\n}\n.sidebar {\n  grid-area: sidebar;\n}\n.content {\n  grid-area: content;\n}\n.footer {\n  grid-area: footer;\n}\n```\n\n## 21. CSS Transtions\n\n<div class=\"content-ad\"></div>\n\n문제: 상태 간의 부드러운 전환.\n\n해결 방법: `transition`을 사용하세요.\n\n```css\n.transition-button {\nbackground-color: #3498db;\ntransition: background-color 0.3s;\n}\n.transition-button:hover {\nbackground-color: #2ecc71;\n}\n```\n\n## 22. CSS 애니메이션\n\n<div class=\"content-ad\"></div>\n\n문제: 요소에 애니메이션 추가하기\n\n해결책: `@keyframes`을 사용하세요.\n\n```js\n@keyframes bounce {\n0%, 100% { transform: translateY(0); }\n50% { transform: translateY(-20px); }\n}\n.bounce {\nanimation: bounce 2s infinite;\n}\n```\n\n## 23. CSS 모양 아웃사이더들\n\n<div class=\"content-ad\"></div>\n\n문제: 비직사각형 모양 만들기.\n\n해결책: `clip-path`를 사용하세요.\n\n```js\n.clip-path {\nclip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);\nbackground-color: #3498db;\nwidth: 200px;\nheight: 200px;\n}\n```\n\n## 24. 다크 모드\n\n<div class=\"content-ad\"></div>\n\n문제: 다크 모드 구현하기.\n\n해결책: CSS 변수와 미디어 쿼리 사용하기.\n\n```css\n:root {\n  --bg-color: #fff;\n  --text-color: #000;\n}\n\n@media (prefers-color-scheme: dark) {\n  :root {\n    --bg-color: #333;\n    --text-color: #fff;\n  }\n}\n\nbody {\n  background-color: var(--bg-color);\n  color: var(--text-color);\n}\n```\n\n## 25. CSS 카운터\n\n<div class=\"content-ad\"></div>\n\n문제: 카운터 만들기\n\n해결방법: `counter-reset` 및 `counter-increment`을 사용하세요.\n\n```css\n.counter-list {\n    counter-reset: section;\n}\n.counter-list li::before {\n    counter-increment: section;\n    content: \"섹션 \" counter(section) \": \";\n}\n```","ogImage":{"url":"/assets/img/2024-05-17-25CSSHacksEveryDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-05-17-25CSSHacksEveryDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":7},{"title":"리액트에서 화면 크기에 맞게 반응형으로 텍스트 크기 조정하기","description":"","date":"2024-05-17 21:22","slug":"2024-05-17-AdaptatextsizetoscreensizewithdifferentratioinReact","content":"\n\n현대 웹 개발의 중요한 측면 중 하나는 반응형 웹 디자인을 만드는 것입니다. 다양한 디바이스의 존재로 인해 텍스트가 다양한 화면 크기와 비율에서 가독성이 좋고 심미적으로 매력적으로 보이도록 하는 것은 어려운 과제일 수 있습니다. 이 기사에서는 React 애플리케이션을 다룰 때 다양한 화면 비율에 맞게 텍스트 크기를 동적으로 조정하는 실용적인 해결책에 대해 살펴보겠습니다.\n\n# 과제 이해하기\n\n서로 다른 크기와 모양의 화면에 완벽하게 맞는 텍스트 블록이 필요한 시나리오를 상상해보세요. 이는 너비에 맞추는 것뿐만 아니라 높이도 고려해야 합니다. 예를 들어, 여러 열로 구성된 큰 화면의 경우 텍스트는 사용 가능한 공간을 효과적으로 활용하기 위해 적응해야 합니다. 화면 너비에만 의존하는 미디어 쿼리는 화면의 더 높은 부분에 미사용 공간이 남아 작은 크기의 텍스트를 만들어낼 수 있습니다. 따라서 뷰포트의 너비와 높이를 모두 고려하는 보다 세밀한 접근 방식이 필요합니다.\n\n# 기본 사항:\n\n<div class=\"content-ad\"></div>\n\n솔루션으로 들어가기 전에 사용될 몇 가지 개념을 기본적으로 이해하는 것이 중요합니다.\n\n먼저, CSS 단위에 대해 설명하겠습니다. 그런 다음, 리액트 컴포넌트 생명주기에 대해 자세히 알아보겠습니다. 리액트를 프레임워크로 사용하고 있지만, 동일한 원칙은 어떤 프레임워크 없이 순수한 JavaScript(프레임워크 없는 JavaScript)로도 적용할 수 있습니다.\n\n## CSS 단위 이해\n\n이 도전 과제를 효과적으로 해결하기 위해 CSS 단위에 대한 명확한 이해가 중요합니다. CSS 단위는 반응형 디자인의 구성 요소입니다. 다음은 가장 일반적으로 사용되는 몇 가지 단위입니다:\n\n<div class=\"content-ad\"></div>\n\n- 픽셀 (px): 화면에서 하나의 픽셀을 나타내는 가장 기본적인 단위입니다. 다른 요소에 따라 변경되지 않는 절대적인 단위입니다.\n- 뷰포트 너비 (vw): 이 단위는 뷰포트의 너비(브라우저 창의 가시 영역)의 1%에 대한 상대적인 값입니다. 예를 들어, 뷰포트가 1000px 너비라면 1vw는 10px입니다.\n- 뷰포트 높이 (vh): vw와 유사하지만 뷰포트의 높이에 상대적입니다. 따라서 1vh는 뷰포트 높이의 1%입니다.\n- 퍼센트 (%): 이 단위는 부모 요소의 크기에 상대적입니다. 레이아웃에 자주 사용되지만 텍스트에는 조심해야 합니다.\n- em과 rem: 이것들은 글꼴 상대적 크기입니다. em은 요소의 글꼴 크기에 상대적이며 rem은 루트 요소의 글꼴 크기에 상대적입니다.\n\n## 리액트 컴포넌트와 라이프사이클\n\n리액트는 개발자들이 재사용 가능한 UI 컴포넌트를 만들 수 있도록 합니다. 우리의 맥락에서, 우리는 함수형 컴포넌트를 다룰 것입니다.\n\n리액트 컴포넌트에는 라이프사이클이라고 하는 것이 있습니다 — 컴포넌트의 생성부터 언마운트까지 일련의 이벤트가 발생합니다. useState와 같은 훅을 사용하여 상태 관리하거나 window 크기 조정과 같은 부수 효과에 대응하기 위한 useEffect를 통해, 리액트는 동적 행위를 다루는 강력한 방법을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n# useState\n\nuseState은 React에서 함수 컴포넌트에 상태를 추가할 수 있게 해주는 훅(React의 특별한 함수)입니다. 기본적으로 함수에 인자로써 사용되며, 컴포넌트의 어떤 측면을 변경할 수 있게 합니다. 예를 들어, 숫자를 표시하는 페이지가 있고 이 숫자를 증가시킬 수 있는 두 개의 버튼이 있다고 가정해보세요. 숫자는 상태여야만 컴포넌트를 재구성할 수 있습니다.\n\nuseState은 값을 반환하고 값을 설정하는 함수를 제공합니다. 아래의 예시에서 \"Increase\"를 클릭할 때마다, 숫자를 1씩 증가시키기 위해 update 함수인 setNumber를 호출합니다. 숫자가 상태에 저장되어 있기 때문에 React는 변경될 때마다 업데이트된 점수로 컴포넌트를 다시 렌더링해야 함을 압니다. 이를 통해 표시가 현재 점수와 동기화됩니다. useState가 없다면 버튼을 클릭해도 페이지의 숫자가 변경되지 않을 것입니다.\n\n```js\nimport {useState} from React\n\nconst Scoreboard = () => {\n\nconst [number, setNumber] = useState(0);\n\nreturn(<>\n  <button onClick={() => setNumber(number + 1)}>Increase</button>\n  <p>{number}</p>\n</>\n)\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# useEffect\n\nReact에서 작업할 때, 코드는 해석적이 아닙니다. 즉, 어떤 코드가 실행되고 있는지 정확히 알 수 없다는 것을 의미합니다. 때로는 어떤 계산을 수행하기 전에 모든 것이 렌더링되었는지 확인해야 할 수도 있습니다. 이럴 때 useState가 유용합니다.\n\n웹페이지가 숫자를 표시하고 해당 숫자를 증가시키거나 감소시키는 버튼으로 제어되는 예제를 계속해 보겠습니다. 만약 이 숫자가 변경될 때마다 특정 작업이나 계산을 수행하고 싶다면, 예를 들어 해당 숫자를 로깅하거나 UI의 다른 부분을 업데이트하는 경우입니다.\n\n## 숫자 표시 예제\n\n<div class=\"content-ad\"></div>\n\n```js\nuseEffect(() => {\n  // 이 코드는 `number`가 업데이트된 후에 실행됩니다\n  console.log(\"숫자가 변경되었습니다:\", number);\n  // 이 숫자를 기반으로 다른 것을 업데이트하고 싶을 수도 있습니다\n  // 예를 들어, 숫자가 짝수인지 홀수인지에 따라 배경색을 변경할 수 있습니다\n  if (number % 2 === 0) {\n    document.body.style.backgroundColor = \"lightblue\";\n  } else {\n    document.body.style.backgroundColor = \"lightpink\";\n  }\n}, [number]); // 이는 React에게 `number`가 변경될 때 효과를 실행하도록 알려줍니다\n```\n\n이 코드에서는 useEffect가 숫자 상태를 관찰합니다. 숫자가 변할 때(버튼 클릭으로 인해), useEffect는 코드를 실행합니다. 현재 숫자를 기록하고 숫자가 짝수인지 홀수인지에 따라 배경색을 변경합니다. useEffect는 useState 계산 후에 함수가 실행되도록 보장합니다. 버튼의 onClick 핸들러 안에서 setNumber를 호출한 직후 동작을 수행하려고 하면 문제가 발생할 수 있습니다. 상태 업데이트(setNumber)는 즉시 발생하지 않습니다. React가 일정에 따라 예약되기 때문에 실제로 상태가 변경되기 전에 후속 코드가 실행될 수 있어 예상치 못한 동작을 유발할 수 있습니다. useEffect는 React가 새로운 상태로 구성 요소를 업데이트한 후에만 내부 코드가 실행되도록 보장하여 이 문제를 해결합니다.\n\n# 해결 방법:\n\n우리는 React에서 useState와 useEffect 훅을 사용하여 viewport 너비 (vw) 및 높이 (vh)의 변경에 따라 적응하는 반응형 텍스트 크기를 만들어 보겠습니다. 아래는 단계별 가이드입니다:\n\n\n<div class=\"content-ad\"></div>\n\n## 단계 1: 상태 설정하기\n\n먼저, useState를 사용하여 텍스트 스타일의 초기 상태를 정의합니다. 이 상태는 글ꔼ 크기, 줄 높이 및 글ꔼ 굵기를 보관합니다.\n\n```js\nconst [paragraphStyle, setStyle] = useState({\n  fontSize: \"3vw\",\n  lineHeight: \"4vw\",\n  fontWeight: \"100\",\n});\nconst [catchSentenceStyle, setCatchSentenceStyle] = useState({\n  fontSize: \"7vw\",\n  lineHeight: \"9vw\",\n  fontWeight: \"600\",\n});\n```\n\n## 단계 2: 글ꔼ 크기 동적으로 계산하기\n\n<div class=\"content-ad\"></div>\n\n우리는 viewport의 너비와 높이에 기반하여 동적으로 글꼴 크기를 계산하는 updateStyle 함수를 생성합니다.\n\n```js\nconst updateStyle = () => {\n  const vw = window.innerWidth * 0.0095;\n  const vh = window.innerHeight * 0.0095;\n  const responsiveSize = vh + vw;\n  const cresponsiveSize = responsiveSize * 3.5;\n```\n\n```js\n  // 화면 비율에 따른 추가 조정 적용을 위해 주석을 해제하세요\n  // if (screenRatio < 0.74 && screenRatio > 0.5) {\n  //   responsiveSize = responsiveSize * 1.3 * screenRatio;\n  //   cresponsiveSize = cresponsiveSize * 1.3 * screenRatio;\n  // }\n  setStyle({\n    fontSize: responsiveSize + \"px\",\n    lineHeight: responsiveSize * 1.3 + \"px\",\n    fontWeight: \"100\",\n  });\n  setCatchSentenceStyle({\n    fontSize: cresponsiveSize + \"px\",\n    lineHeight: cresponsiveSize * 1.1 + \"px\",\n    fontWeight: \"100\",\n  });\n};\n```\n\n## 단계 3: 창 크기 조정에 대한 응답\n\n<div class=\"content-ad\"></div>\n\nuseEffect 훅은 컴포넌트가 마운트될 때와 창 사이즈가 조정될 때 updateStyle을 호출하기 위해 사용됩니다.\n\n```js\nuseEffect(() => {\n  updateStyle();\n  window.addEventListener(\"resize\", updateStyle);\n  return () => window.removeEventListener(\"resize\", updateStyle);\n}, []);\n```\n\n## 단계 4: 스타일 적용\n\n마지막으로, 이 스타일을 컴포넌트의 텍스트 요소에 적용합니다.\n\n<div class=\"content-ad\"></div>\n\n```html\n<div\n  style={\n    padding: \"8vh 8vw\",\n    // additional styles...\n  }\n>\n  <p style={catchSentenceStyle}>Catchy sentence here.</p>\n  <p style={paragraphStyle}>Detailed paragraph here.</p>\n  {/* Additional paragraphs... */}\n</div>\n```\n\n이 솔루션을 통해 텍스트가 다양한 화면 비율에서 스케일링되며, 좋은 글꼴 크기로 조정되어 윈도우 높이 및 폭에 모두 적응합니다.\n\n# 결론\n\n텍스트 크기를 다른 화면 크기에 맞게 조정하는 것은 반응형 웹 디자인의 중요한 측면입니다. React의 useState 및 useEffect 훅을 활용하여 개발자는 화면 너비뿐만 아니라 높이에도 조절되는 텍스트를 생성할 수 있으며, 가독성과 화면 공간의 최적 활용을 보장합니다. 이 접근 방식은 다양한 장치와 화면 크기에 걸쳐 사용자 경험을 향상시킵니다.\n\n\n<div class=\"content-ad\"></div>\n\n이제 이러한 개념을 이해했으니, 2600px에서처럼 응용 프로그램에서 특정 브레이크포인트를 관리하는 방법에 접근할 수 있습니다. 이는 주방에 특별한 규칙이 있는 것과 같습니다: \"2600 명 이상의 고객이 있을 때 다른 메뉴로 전환해야 합니다.\" 웹 개발에서 브레이크포인트는 웹사이트 레이아웃이 다른 화면 크기나 방향에 맞게 변경되는 지점을 의미합니다.\n\n우리의 예시 컴포넌트에서 2600px에서의 브레이크포인트를 관리하는 것은 updateStyle 함수에서 화면 너비를 확인하고 너비가 2600px를 초과할 때 스타일을 조정하는 조건을 설정하는 것을 포함합니다. 이는 화면이 커지더라도 텍스트 크기와 레이아웃이 최적이며 가독성이 유지되도록 보장하며, 항상 우리 메뉴가 고객 수에 적합한지 확인하는 것과 같은 역할을 합니다. 이 도전에 도전해 보고 결과를 게시해보세요!","ogImage":{"url":"/assets/img/2024-05-17-AdaptatextsizetoscreensizewithdifferentratioinReact_0.png"},"coverImage":"/assets/img/2024-05-17-AdaptatextsizetoscreensizewithdifferentratioinReact_0.png","tag":["Tech"],"readingTime":7},{"title":"HTML, CSS 및 Javascript를 사용한 최고의 멋진 슬라이더 효과 만드는 방법","description":"","date":"2024-05-17 21:21","slug":"2024-05-17-CreateATopCrazySliderEffectsUsingHTMLCSSandJavascript","content":"\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1140/1*5lwNm-FVTRS5eGwUvm8Hbw.gif\" />\n\n웹사이트의 사용자 경험을 크게 향상시킬 수 있는 멋진 상호작용 슬라이더를 만들어보세요. 이 기사에서는 HTML, CSS 및 JavaScript를 사용하여 최고 수준의 멋진 슬라이더 효과를 구축하는 과정을 안내합니다. 초보자든 숙련된 개발자든 상관없이 이 자습서를 통해 시각적으로 매력적이고 매우 기능적인 슬라이더를 만들 수 있을 것입니다.\n\n이 쉽게 이해할 수 있는 비디오를 시청해보세요 🙏😁\n\n## 단계 1: HTML 구조 설정\n\n<div class=\"content-ad\"></div>\n\n먼저, 슬라이더의 기초 역할을 하는 간단한 HTML 구조가 필요합니다. 다음은 설정 방법에 대한 예시입니다:\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Top Slider</title>\n    <link rel=\"stylesheet\" href=\"style.css\">\n    <link href=\"https://cdn.jsdelivr.net/npm/remixicon@4.2.0/fonts/remixicon.css\" rel=\"stylesheet\" />\n</head>\n\n<body>\n    <div class=\"gallery-wrap\">\n\n        <div class=\"gallery\">\n            <div>\n                <span><img src=\"./images/image-1.png\" alt=\"\"></span>\n                <span><img src=\"./images/image-2.png\" alt=\"\"></span>\n                <span><img src=\"./images/image-3.png\" alt=\"\"></span>\n                <span><img src=\"./images/image-4.png\" alt=\"\"></span>\n                <span><img src=\"./images/image-5.png\" alt=\"\"></span>\n                <span><img src=\"./images/image-6.png\" alt=\"\"></span>\n            </div>\n\n        </div>\n\n        <div class=\"Btn-group\">\n            <span><i id=\"topBtn\" class=\"ri-arrow-up-fill\"></i></span>\n            <span><i id=\"downBtn\" class=\"ri-arrow-down-fill\"></i></span>\n        </div>\n    </div>\n\n    <script src=\"app.js\"></script>\n</body>\n\n</html>\n```\n\n## 단계 2: CSS로 스타일링\n\n다음은 슬라이더를 CSS로 스타일링하여 멋지게 보이고 원활하게 작동하도록하는 샘플 CSS 코드입니다:\n\n<div class=\"content-ad\"></div>\n\n```css\n*{\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\nhtml,body {  \n    height: 100vh;\n    width: 100%;\n    background-color: #191919;\n    overflow: hidden;\n}\n.gallery-warp{\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin: 10% auto;\n    flex-direction: column;\n}\n.gallery{\n    display: flex;\n    width: 27%;\n    height: 587px;\n    overflow-y: scroll;\n}\n.gallery::-webkit-scrollbar{\n    display: none;\n}\n.gallery div{\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n    padding: 10px;\n}\n.gallery div img{\n    filter: grayscale(100%);\n    width: 100%;\n    transition: transform 0.5s;\n}\n.gallery div img:hover{\n    filter: grayscale(0);\n    cursor: pointer;\n    transform: scale(1.1);\n}\n.Btn-group{\n    margin-top: 1rem;\n    display: flex;\n    gap: 18px;\n}\n.Btn-group span i{\n    padding: 4px 4px;\n    border: 1px solid;\n    font-size: 24px;\n    color: #fff;\n    border-radius: 20px;\n    cursor: pointer;\n    transition: all ease-in-out 0.8s;\n}\n.Btn-group span i:hover{\n    background-color: #fff;\n    color: #191919;\n    border: none;\n}\n```\n## Step 3: Adding JavaScript for Functionality\n\nFinally, add JavaScript to bring the slider to life. This script will handle the slide transitions and navigation functionality:\n\n```js\nlet scrollContainer = document.querySelector(\".gallery\");\nlet topBtn = document.getElementById(\"topBtn\")\nlet downBtn = document.getElementById(\"downBtn\");\n\nscrollContainer.addEventListener(\"wheel\", (e) => {\n    e.preventDefault();\n    scrollContainer.style.scrollBehavior = \"auto\";\n    scrollContainer.scrollTop += e.deltaY;\n})\n\ntopBtn.addEventListener(\"click\", () => {\n    scrollContainer.style.scrollBehavior = \"smooth\";\n    scrollContainer.scrollTop += 610;\n})\ndownBtn.addEventListener(\"click\", () => {\n    scrollContainer.style.scrollBehavior = \"smooth\";\n    scrollContainer.scrollTop -= 600;\n})\n```\n\n<div class=\"content-ad\"></div>\n\n# 향상 및 고급 기능\n\n비디오에서 기본 슬라이더에 추가할 수 있는 가능한 향상 방안을 제안합니다:\n\n- 3D 전환: CSS 변형을 이용하여 슬라이드 전환에 3D 효과를 추가합니다.\n- Parallax 효과: 패럴랙스 스크롤링을 구현하여 깊이 효과를 부여합니다.\n- 고급 애니메이션: GSAP(그린속 애니메이션 플랫폼)과 같은 라이브러리를 사용하여 더 복잡한 애니메이션을 만듭니다.","ogImage":{"url":"/assets/img/2024-05-17-CreateATopCrazySliderEffectsUsingHTMLCSSandJavascript_0.png"},"coverImage":"/assets/img/2024-05-17-CreateATopCrazySliderEffectsUsingHTMLCSSandJavascript_0.png","tag":["Tech"],"readingTime":4},{"title":"css 애니메이션을 위한 베지에 곡선(Bezier Curves) 이해하기","description":"","date":"2024-05-17 21:20","slug":"2024-05-17-UnderstandingBzierCurves","content":"\n\n![Understanding Bézier Curves](/assets/img/2024-05-17-UnderstandingBzierCurves_0.png)\n\n베지에 곡선은 어디에나 있어요. 당신의 CSS 애니메이션 타이밍 함수부터 그래픽 편집기, 타이포그래피, 자동차 디자인 등등 많은 곳에서 사용돼요. 부드러운 곡선을 모델링하려면, 아마도 베지에 곡선을 사용하게 될 거에요.\n\n저에게는 이러한 곡선들이 개발자로서 일상생활에 수학적 영향을 직접 보여주는 완벽한 예이에요. 우리가 추상화의 산천 아래에 무엇이 있는지 정확하게 이해하길 바라는 것은 아니더라도, (저는 확실히 하고 싶지 않지만) 약간의 관심을 가지고 깊게 이해하면 가치가 있다고 생각해요.\n\n이 글의 목표는 바로 이에요. 이후에 베지에 곡선이 정확히 무엇인지, 왜 사용하는지, 어떻게 동작하는지에 대한 수학적이고 직관적인 이해를 가지게 될 거에요.\n\n<div class=\"content-ad\"></div>\n\n# 베지에 곡선이란?\n\n베지에 곡선은 매개변수 곡선으로 (매개변수 t가 0부터 1까지 변하는) 제어점 세트에 의해 정의된 곡선입니다. 이러한 점들 간의 위치는 곡선의 모양을 정의합니다.\n\n![베지에 곡선](/assets/img/2024-05-17-UnderstandingBzierCurves_1.png)\n\n만약 Adobe Illustrator나 Figma와 같은 그래픽 편집 소프트웨어를 사용해본 적이 있다면, 이미 이러한 제어점들이 어떻게 작용하는지 보았을 겁니다. 아래 gif에서 각 점이 움직일 때 곡선의 모양이 그에 따라 어떻게 변하는지 주목해보세요.\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*j6VPAteSfVSRWswKIeQtPw.gif)\n\nYou can also use as many control points as you like. The more control points you add, the greater the control you have over the final shape of your curve. As an example, the cubic-bezier function in CSS uses a bézier curve with 4 points (hence cubic) that describe the evolution of your animation.\n\n## What’s going on?\n\nThat’s great and all, but how do we get a curve from just positioning a bunch of points around?\n\n\n<div class=\"content-ad\"></div>\n\n그 답은 베지에 곡선의 수학적 기초인 버네스타인 다항식에 있습니다. n차 버넨스타인 다항식은 각각 버넨스타인 계수에 의해 곱해진 버넨스타인 기저 다항식의 합으로 정의됩니다.\n\n![그림 1](/assets/img/2024-05-17-UnderstandingBzierCurves_2.png)\n\n![그림 2](/assets/img/2024-05-17-UnderstandingBzierCurves_3.png)\n\n이러한 공식들에 집착하지 마세요. 필요한 것은 이 중에서 몇 가지 주요한 점뿐이에요.\n\n<div class=\"content-ad\"></div>\n\n먼저, 그들의 목적이 무엇인가요? 얼마나 간략하게 말씀드릴까요? Bernstein 다항식은 처음에는 닫힌 구간 내의 임의의 연속 함수를 근사화하는 방법으로 사용되었습니다 (자세한 내용은 Stone-Weierstrass 정리를 참조하세요). 다시 말해, 이러한 다항식을 사용함으로써 우리는 원하는 거의 모든 함수(어떤 곡선도 모델링 가능)를 근사화할 수 있습니다. 이는 다항식이 일반적으로 다른 유형의 함수보다 훨씬 간단하게 계산하고 조작할 수 있기 때문에 정말 유용합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:440/1*hoKuMOP-U-V2RSLGzwvatg.gif)\n\n둘째, 이 근사화는 정확히 어떻게 일어날까요? Bernstein 계수를 기억하시나요? 그것이 그들의 역할입니다! 수식에서 기저 다항식이 항상 같은 것을 주목하세요 (차수 n에 따라만 달라집니다) - 계수가 실제로 대상 함수를 근사하는 역할을 합니다. 함수 f를 근사하는 정확한 공식은 다음과 같습니다:\n\n![이미지](/assets/img/2024-05-17-UnderstandingBzierCurves_4.png)\n\n<div class=\"content-ad\"></div>\n\n베지에 곡선이 정확히 무엇인가요? 베르슈타인 다항식이며, 여기서 베르슈타인 계수는 제어점이 됩니다! 따라서 베지에 곡선을 구축할 때 우리는 사실적인 함수를 근사하는 것이죠! 이것은 베르슈타인 다항식의 직접적인 응용입니다.\n\n이것이 바로 베지에 곡선의 명시적/수학적 정의라고 알려진 것입니다. 이제 살펴볼 또 다른 방법으로는 베지에 곡선을 볼 때 더 강력하고 직관적인 방식이 있습니다.\n\n# 다른 접근 방법\n\n베지에 곡선에는 각각의 차수(제어점 수)에 따라 구분되는 몇 가지 유명한 형식이 있습니다. 선형, 이차 및 삼차 베지에 곡선이 그 중 몇 가지입니다. 이 주제를 공부할 때, 베르슈타인 다항식에 기반한 공식을 적용하여 얻을 수 있는 이들의 공식을 아마도 만날 것입니다.\n\n<div class=\"content-ad\"></div>\n\n![UnderstandingBézierCurves_5](/assets/img/2024-05-17-UnderstandingBzierCurves_5.png)\n\n다시 말하지만, 이러한 공식에 집착하지 마세요. 이 중요한 점 하나만 기억하면 됩니다.\n\n선형 베지어 곡선의 수식에 주목하세요. (1-t)와 t가 어떤 것의 곱으로 나타나는 것을 주의깊게 살펴보세요. 맥락 없이는 그저 기본적인 선형 함수일뿐입니다. 그러나 이차 공식에서 약간 이동하면 어떻게 되는지 살펴보세요:\n\n![UnderstandingBézierCurves_6](/assets/img/2024-05-17-UnderstandingBzierCurves_6.png)\n\n<div class=\"content-ad\"></div>\n\n패턴 (1-t) 및 t가 반복됩니다. 우리는 이차 곡선 P0P1P2를 (1-t) * (베지에(P0P1)) + t * (베지에(P1P2))로 표현하고 있습니다. (다양한 종류의 베지에 곡선이 있는 이전 이미지로 돌아가서 제어점을 연결하는 선에 주목해주세요). 실제로 이를 높은 차수의 곡선에 대해 테스트해보면 그것이 성립함을 볼 수 있습니다. 여기서 새로운 재귀적인 방법으로 베지에 곡선을 정의할 수 있습니다:\n\n![image](/assets/img/2024-05-17-UnderstandingBzierCurves_7.png)\n\n또한 수학적 정의 (버너스타인 다항식)에서 비롯된 원래 방식과 다른 베지에 곡선의 점을 평가하는 새로운 방법을 얻을 수 있습니다.\n\n우리가 이차 베지에 곡선에서 t=0.5 지점을 계산하려고한다고 상상해보세요. 방금 본 바와 같이, 우리는 이 곡선을 P0, P1 및 P1, P2가 되는 두 개의 선형 베지에 곡선으로 표현할 수 있습니다. 새로운 재귀 공식에 0.5를 대입함으로써, 우리는 P0P1 선상의 t=0.5를 계산하고, 다음으로 P1P2 선상의 t=0.5를 계산합니다. 이로서 우리는 두 개의 새로운 점을 얻게 되는데, 이 두 중간점을 다시 다른 선으로 연결하고 (더 작은 차수의 곡선을 곱하는 (1-t) 및 t를 기억하세요) t=0.5의 최종 위치를 계산할 수 있게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n현재 상황을 시각화해 드릴게요:\n\n![Visualization 1](https://miro.medium.com/v2/resize:fit:480/1*MTvJLHEDRpAcAFY25iQeww.gif)\n\n각 평가된 지점 t마다, 먼저 작은 차수 곡선들 각각에서 이를 계산한 후 이들을 연결하여 결과 선상에서 원하는 지점을 계산합니다. 이러한 패턴은 더 높은 곡선들에서도 반복됩니다:\n\n![Visualization 2](https://miro.medium.com/v2/resize:fit:480/1*NUV8KWFfKmevb_Z_L2A1hQ.gif)\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:480/1*jFpYqpzDRr0F6HppPpr9kA.gif)\n\n이것을 이해하는 것은 중요합니다. 왜냐하면 Bézier 곡선을 공부할 때 항상 나오는 특별한 주제인 De Casteljau 알고리즘의 설명이기 때문입니다.\n\n## De Casteljau의 알고리즘\n\n이 알고리즘은 곡선의 각 점을 평가하기 위해 이 재귀적 정의를 사용합니다. 이는 계산을 단계별로 나누며, 첫 번째 단계에는 개별 제어점이 있고, 최종 단계에는 원하는 점이 있으며, 중간 단계에는 재귀적 정의를 통해 계산하는 모든 중간 점들이 있습니다. 어떻게 3차 곡선에서 작동하는지 살펴봅시다:\n  \n\n<div class=\"content-ad\"></div>\n\n\n![UnderstandingBzierCurves_8](/assets/img/2024-05-17-UnderstandingBzierCurves_8.png)\n\n따라서, 레벨 0의 각 포인트가 제어 포인트 자체임을 감안할 때, 레벨 j의 임의의 점 Pi에 대해, De Casteljau 알고리즘은 해당 값이 다음과 같을 것을 알려줍니다:\n\n![UnderstandingBzierCurves_9](/assets/img/2024-05-17-UnderstandingBzierCurves_9.png)\n\n언제나, 이것이 베지에 곡선에서 재귀 패턴을 사용하고 있다는 점을 기억해 주세요. 이는 버너스타인 다항식에서 유도되었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 왜 베지에 곡선인가요?\n\n우리가 베지에 곡선에 대해 이야기한 모든 것을 고려할 때, 그것들이 왜 중요한 것인지 궁금하십니까? 왜 우리는 그것들을 이렇게 많이 사용하는 걸까요?\n\n기본적으로 이들은 무한대로 확장 가능한 곡선을 작성하는 방법입니다. 우리는 원하는 대로 세부적으로 만들 수 있기 때문에, 수퍼 고차 커브를 만들지 않고 작은 차수의 커브를 이어붙이기만 하면 거의 모든 원하는 커브를 얻을 수 있습니다.\n\n타이포그래피의 대표적인 예를 들어보겠습니다. 베지에 곡선은 우리에게 간단한 고정폭 서체에서부터 아름다운 표시 서체까지 다양한 서체를 만들 수 있게 해줍니다!\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-17-UnderstandingBzierCurves_10.png\" />\n\n# 마무리\n\n이 글에서 배운 모든 것을 요약해보면:\n\n- Bézier 곡선은 제어점 집합에 의해 정의된 매개변수 곡선입니다.\n- 그들의 수학적 기원은 Bernstein 다항식에서 왔는데, 이것은 실제 함수를 근사하는 방법입니다.\n- Bézier 곡선은 제어 점이 Bernstein 계수 자리를 차지하는 Bernstein 다항식입니다.\n- Bézier 곡선은 재귀적이며, Pn 점으로 된 각 Bézier는 Bézier 곡선 P0Pn-1 및 P1Pn의 선형 보간(선)으로 나타낼 수 있습니다.\n- De Casteljau 알고리즘은 임의의 Bézier 곡선의 점을 계산하기 위해 이 재귀 관계를 사용합니다.\n- Bézier 곡선은 무한대로 확장이 가능하며, 원하는 거의 모든 곡선을 만들 수 있게 해줍니다.","ogImage":{"url":"/assets/img/2024-05-17-UnderstandingBzierCurves_0.png"},"coverImage":"/assets/img/2024-05-17-UnderstandingBzierCurves_0.png","tag":["Tech"],"readingTime":6},{"title":"프론트엔드 개발자를 위한 CSS 팁","description":"","date":"2024-05-17 21:18","slug":"2024-05-17-MyULTIMATECSSCheatSheetfromBeginnertoPro","content":"\n\n## 개발자가 알아야 할 100가지 CSS 속성\n\n![CSS Cheat Sheet](/assets/img/2024-05-17-MyULTIMATECSSCheatSheetfromBeginnertoPro_0.png)\n\n웹 애플리케이션을 만들고 스타일링하는 것을 좋아하며 CSS가 제가 생각하고 이야기하는 가장 좋아하는 것입니다.\n\n4년의 경험을 통해 많은 것을 배웠고, 이 기사에서 그 지식을 여러분과 공유하고 싶습니다.\n\n<div class=\"content-ad\"></div>\n\n오늘은 모든 사람을 위한 궁극적인 CSS 치트 시트를 제공하기 위해 모든 것을 다 할 거에요 - 절대 초보자부터 궁극의 전문가까지.\n\n마지막으로, 아무도 모르는 최고의 CSS 한 줄 코드 몇 가지를 보여드릴 테니, 이를 통해 많은 작업을 절약할 수 있을 거에요.\n\n편안히 앉아서 즐기고 나중을 위해 저장하세요!\n\n# 초보자 레벨\n\n<div class=\"content-ad\"></div>\n\n셀렉터: `element`\n지정된 타입의 모든 요소를 선택합니다.\n\n셀렉터: `#id`\n지정된 id를 가진 요소를 선택합니다.\n\n셀렉터: `.class`\n지정된 클래스를 가진 모든 요소를 선택합니다.\n\n속성: color\n텍스트의 색상을 설정합니다.\n예시:\n\n<div class=\"content-ad\"></div>\n\n```css\np {\n color: blue;\n }\n```\n\n속성: font-size\n글꼴 크기를 설정합니다.\n예시:\n\n```css\nh1 {\n font-size: 24px;\n }\n```\n\n속성: background-color\n배경 색상을 설정합니다.\n예시:\n\n<div class=\"content-ad\"></div>\n\n\n```css\nbody {\n background-color: #f0f0f0;\n }\n```\n\n\nProperty: margin\nSets the margin properties.\nExample:\n\n```css\n.container {\n margin: 10px;\n }\n```\n\nProperty: padding\n\n\n<div class=\"content-ad\"></div>\n\n패딩 속성을 설정합니다.\n예시:\n\n```js\n.box {\n  padding: 20px;\n}\n```\n\n속성: display\n요소의 표시 방법을 설정합니다.\n예시:\n\n```js\n.block {\n  display: block;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\nProperty: position\nSets the positioning method.\nExample:\n\n```js\n.absolute {\n position: absolute;\n top: 0;\n left: 0;\n }\n```\n\nProperty: width\nSets the width of an element.\nExample:\n\n```js\nimg {\n width: 100px;\n }\n```\n\n<div class=\"content-ad\"></div>\n\n프로퍼티: 높이\n요소의 높이를 설정합니다.\n예시:\n\n```js\n.header {\n height: 80px;\n }\n```\n\n# 중급 레벨\n\n프로퍼티: 글꼴 패밀리\n글꼴 패밀리를 설정합니다.\n예시:\n\n<div class=\"content-ad\"></div>\n\n```json\nbody {\n font-family: Arial, sans-serif;\n }\n```\n\n속성: font-weight\n글꼴의 굵기를 설정합니다.\n예시:\n\n```json\n.bold-text {\n font-weight: bold;\n }\n```\n\n속성: text-transform\n텍스트 대문자화를 제어합니다.\n예시:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nbutton {\n  cursor: pointer;\n}\n```\n\n속성: 배경 이미지\n요소에 하나 이상의 배경 이미지를 설정합니다.\n예시:\n\n```js\n.hero-section {\n  background-image: url('hero.jpg');\n}\n```\n\n속성: 배경 위치\n배경 이미지의 시작 위치를 설정합니다.\n예시:\n\n<div class=\"content-ad\"></div>\n\n```js\n.header {\n background-position: center;\n }\n```\n\n속성: background-repeat\n배경 이미지가 반복되는 방식을 설정합니다.\n예시:\n\n```js\n.pattern {\n background-repeat: repeat-x;\n }\n```\n\n속성: background-size\n배경 이미지의 크기를 설정합니다.\n예시:\n\n<div class=\"content-ad\"></div>\n\n```css\n.cover-image {\n background-size: cover;\n }\n```\n\n속성: 투명도\n투명도 수준을 설정합니다.\n예시:\n\n```css\n.overlay {\n opacity: 0.5;\n }\n```\n\n# 고급 레벨\n\n\n<div class=\"content-ad\"></div>\n\n속성: flex\n유연한 요소의 유연한 길이를 설정합니다.\n예시:\n\n```js\n.container {\n display: flex;\n }\n```\n\n속성: flex-direction\n유연한 컨테이너의 주 축 방향을 지정합니다.\n예시:\n\n```js\n.container {\n flex-direction: row;\n }\n```\n\n<div class=\"content-ad\"></div>\n\nProperty: flex-wrap\n플렉스 항목이 줄 바꿈해야 하는지를 지정합니다.\n예시:\n\n```js\n.container {\n flex-wrap: wrap;\n }\n```\n\nProperty: flex-grow\n플렉스 항목이 서로에 비해 어떻게 성장하는지를 지정합니다.\n예시:\n\n```js\n.item {\n flex-grow: 1;\n }\n```\n\n<div class=\"content-ad\"></div>\n\n속성: flex-shrink\n서로에 비해 얼마나 flex 항목이 줄어드는지를 지정합니다.\n예시:\n\n```js\n.item {\n  flex-shrink: 0;\n}\n```\n\n속성: flex-basis\nflex 항목의 초기 길이를 지정합니다.\n예시:\n\n```js\n.item {\n  flex-basis: 100px;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n프로퍼티: align-items\n플렉스 컨테이너의 교차 축을 따라 플렉스 아이템을 정렬합니다.\n예시:\n\n```js\n.container {\n align-items: center;\n }\n```\n\n프로퍼티: align-self\n개별 플렉스 아이템의 기본 정렬을 재정의할 수 있습니다.\n예시:\n\n```js\n.item {\n align-self: flex-end;\n }\n```\n\n<div class=\"content-ad\"></div>\n\n프로퍼티: justify-content\n플렉스 컨테이너의 주축을 따라 플렉스 아이템을 정렬합니다.\n예시:\n\n```js\n.container {\n justify-content: space-between;\n }\n```\n\n프로퍼티: grid-template-columns\n그리드 레이아웃에서 열의 크기를 지정합니다.\n예시:\n\n```js\n.container {\n display: grid;\n grid-template-columns: 1fr 2fr;\n }\n```\n\n<div class=\"content-ad\"></div>\n\n속성: grid-template-rows\n그리드 레이아웃에서 행의 크기를 지정합니다.\n예시:\n\n```js\n.container {\n display: grid;\n grid-template-rows: 100px auto;\n }\n```\n\n속성: grid-gap\n그리드 레이아웃에서 열과 행 사이의 간격을 설정합니다.\n예시:\n\n```js\n.container {\n display: grid;\n grid-gap: 10px;\n }\n```\n\n<div class=\"content-ad\"></div>\n\n속성: grid-auto-columns\n암시적 그리드 열의 크기를 지정합니다.\n예시:\n\n```js\n.container {\n display: grid;\n grid-auto-columns: 100px;\n}\n```\n\n속성: grid-auto-rows\n암시적 그리드 행의 크기를 지정합니다.\n예시:\n\n```js\n.container {\n display: grid;\n grid-auto-rows: 100px;\n}\n```\n\n<div class=\"content-ad\"></div>\n\nProperty: grid-auto-flow\n그리드 레이아웃에서 자동 배치 알고리즘이 작동하는 방식을 지정합니다.\n예시:\n\n```js\n.container {\n display: grid;\n grid-auto-flow: dense;\n }\n```\n\nProperty: grid-column\n그리드 열 내에서 그리드 항목의 크기와 위치를 지정합니다.\n예시:\n\n```js\n.item {\n grid-column: 2 / span 2;\n }\n```\n\n<div class=\"content-ad\"></div>\n\nProperty: grid-row\n그리드 항목의 크기 및 그리드 행 내 위치를 지정합니다.\n예시:\n\n```js\n.item {\n grid-row: 1 / span 2;\n }\n```\n\nProperty: grid-area\n요소의 크기 및 그리드 레이아웃 내 위치를 설정합니다.\n예시:\n\n```js\n.item {\n grid-area: 1 / 1 / span 2 / span 2;\n }\n```\n\n<div class=\"content-ad\"></div>\n\n이 상세한 CSS 치트 시트는 초보부터 고급 수준까지 다양한 속성 및 선택자를 다루며, 사용 예시를 통해 설명합니다. 특정 속성에 대한 질문이 있거나 추가 설명이 필요하다면 댓글로 자유롭게 질문해 주세요!\n\n이 기사가 도움이 되었기를 바랍니다. 여러분의 문제를 해결하는 데 도움이 되었기를 희망합니다! (새로운 문제가 발생하지 않길 바랍니다 ;-))\n\n즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-17-MyULTIMATECSSCheatSheetfromBeginnertoPro_0.png"},"coverImage":"/assets/img/2024-05-17-MyULTIMATECSSCheatSheetfromBeginnertoPro_0.png","tag":["Tech"],"readingTime":5},{"title":"앵귤러에서의 로컬 변경되었을 때 감지하는 방법","description":"","date":"2024-05-17 21:16","slug":"2024-05-17-LocalChangeDetectioninAngular","content":"\n\n\n![Local Change Detection in Angular](/assets/img/2024-05-17-LocalChangeDetectioninAngular_0.png)\n\nAngular 16 introduced Signals as a pivotal feature, setting the stage for future applications and laying the foundation for a zoneless environment. Signals operate reactively, enabling the generation of derived values or side effects through functions like signal(), computed(), and effect().\n\nThese Signals are instrumental in Angular’s shift from a component-centric rendering approach to one centered around Signals. The dependency graph created by Signals represents the application state. When this graph changes, Angular triggers a DOM update via Change Detection.\n\nFrom a framework’s perspective, the render process is just a side effect of a Signal change. By reacting to the Signals, Angular knows exactly when and what to update.\n\n\n<div class=\"content-ad\"></div>\n\n그것을 달성하기 위해서, 새로운 유형의 컴포넌트가 필요합니다. 새로운 Signal Component를 사용하면 Change Detection을 일으키는 것이 zone.js가 아니라 신호 자체가 됩니다.\n\n불행히도, Signal Components는 17버전에서 사용할 수 없습니다. 그래서 우리는 조금 더 기다려야 합니다.\n\n당연한 질문은: \"Signals로부터 어떤 혜택을 받을 수 있나요?\" 17에서는 대답이 있습니다: 지역 Change Detection입니다.\n\n글을 읽는 것보다 비디오를 선호하신다면, 여기에 하나가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n# 성능이 떨어지는 변경 감지\n\n현재 Angular는 변경이 발생했는지 실질적으로 인식하지 못합니다. 그래서 zone.js와 변경 감지에 의존합니다.\n\nzone.js는 DOM 이벤트가 발생하거나 비동기 작업이 완료될 때 변경 감지를 트리거합니다.\n\n변경 감지는 전체 컴포넌트 트리를 통과하고 변경 사항을 검색해야 합니다. 변경 사항을 감지하면 해당 DOM 노드를 업데이트합니다.\n\n<div class=\"content-ad\"></div>\n\n이것은 전혀 변화가 없을 때도 변경 감지가 실행되므로 성능이 그리 좋지 않습니다.\n\n![Local Change Detection in Angular](/assets/img/2024-05-17-LocalChangeDetectioninAngular_1.png)\n\n부모 및 자식 컴포넌트가 있는 시나리오를 고려해보겠습니다. 부모 컴포넌트는 데이터 그리드를 표시하고, 자식 컴포넌트에는 마지막 업데이트 이후 경과된 시간을 보여주는 타이머가 있습니다:\n\n```typescript\n@Component({\n  selector: 'app-list',\n  template: `\n      <div>\n          <mat-table [dataSource]=\"dataSource\">\n              <ng-container matColumnDef=\"title\">\n                  <mat-header-cell *matHeaderCellDef> Title</mat-header-cell>\n                  <mat-cell *matCellDef=\"let element\">{ element.title }</mat-cell>\n              </ng-container>\n              <ng-container matColumnDef=\"description\">\n                  <mat-header-cell *matHeaderCellDef> Country</mat-header-cell>\n                  <mat-cell *matCellDef=\"let element\">{ element.description }</mat-cell>\n              </ng-container>\n              <mat-header-row *matHeaderRowDef=\"displayedColumns\"/>\n              <mat-row *matRowDef=\"let row; columns: displayedColumns;\"/>\n          </mat-table>\n          <div>\n              @if (lastUpdate) {\n                  <app-timer [lastUpdate]=\"lastUpdate\"></app-timer>\n              }\n              <button mat-raised-button color=\"primary\" (click)=\"refresh()\">Refresh</button>\n          </div>\n      </div>\n      {logCd()}\n  `,\n  standalone: true,\n  imports: [MatTableModule, MatButtonModule, TimerComponent]\n})\nexport class ListComponent implements OnInit {\n  lastUpdate: Date | undefined\n  dataSource = new MatTableDataSource<Holiday[]>([]);\n  displayedColumns = ['title', 'description'];\n  ngOnInit() {\n    this.refresh()\n  }\n  refresh() {\n    fetch('https://api.eternal-holidays.net/holiday').then(res => res.json()).then(value => {\n      this.lastUpdate = new Date();\n      this.dataSource.data = value;\n    });\n  }\n  logCd() {\n    console.log('cd from list');\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n@Component({\n  selector: 'app-timer',\n  template: `<span>Last Updated: { lastUpdateInSeconds | number:'1.0-0' } Seconds</span> { logCd() }`,\n  standalone: true,\n  imports: [DatePipe, DecimalPipe]\n})\nexport class TimerComponent {\n  @Input() lastUpdate = new Date();\n  lastUpdateInSeconds = 0\n  constructor() {\n    setInterval(() => {\n      this.lastUpdateInSeconds = (new Date().getTime() - this.lastUpdate.getTime()) / 1_000;\n    }, 1000);\n  }\n  logCd() {\n    console.log('log from timer');\n  }\n}\n```\n\nTimerComponent은 매 초 간격으로 lastUpdateInSeconds를 업데이트합니다. 이 간격은 zone.js가 매 초마다 변경 감지를 트리거할 수 있도록 합니다.\n\n따라서 변경 감지가 시작되면 부모 구성 요소를 통해 데이터가 변경되었는지 확인합니다. 변경이 있으면 필요한 DOM 요소를 업데이트하고 TimerComponent로 이동합니다.\n\n즉, Angular는 매 초 ListComponent를 불필요하게 확인합니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 컴포넌트의 logCd()은 체크가 실행될 때 마다 로그를 남깁니다. 현재로서는 매우 빈번하게 로그를 남깁니다.\n\n# OnPush\n\nComponent 데코레이터의 인기 있는 설정 중 하나는 ChangeDetectionStrategy:OnPush입니다. Angular가 변경 감지를 실행할 때 그 설정이 있는 컴포넌트를 만나면 중단합니다. 또한 해당 컴포넌트가 \"더러운\" 것으로 표시하는 플래그가 없는 한 그 하위 항목을 통과하지 않습니다.\n\n컴포넌트가 \"더러워\"지는 일반적인 기준은:\n\n<div class=\"content-ad\"></div>\n\n- 입력값이 객체 참조를 변경합니다.\n- 컴포넌트가 이벤트 핸들러를 실행합니다. 이벤트 핸들러가 없는 요소를 클릭하는 것만으로는 충분하지 않습니다.\n- 비동기 파이프가 적용되어 기본 Observable이 새 값을 방출합니다.\n- 시그널이 변경됩니다.\n\n\"더티 마킹\"이 변경 감지를 트리거하지 않는다는 점을 중요하게 알아두어야 합니다. 이 동작은 여전히 zone.js의 작업으로, 실행된 이벤트 핸들러가 있거나 비동기 작업이 종료될 때 비동기적으로 스케줄링됩니다.\n\nAngular가 컴포넌트를 \"더티\" 상태로 표시하면 해당 부모 컴포넌트에도 적용됩니다. 왜 이게 필요한 걸까요? 부모도 OnPush로 설정되어 있는 경우 CD가 자식 컴포넌트로 전파되지 않을 것입니다.\n\n다음 그림은 OnPush와 기본 전략을 사용한 변경 감지의 차이를 보여 줍니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Local Change Detection in Angular](/assets/img/2024-05-17-LocalChangeDetectioninAngular_2.png)\n\n![Local Change Detection in Angular](/assets/img/2024-05-17-LocalChangeDetectioninAngular_3.png)\n\n이 그림에서는 \"Dirty Marking\"이라는 별도의 프로세스가 변경 감지 전에 실행되는 것을 보여줍니다. 이는 속성 바인딩이 포함되지 않은 경우에만 해당됩니다. \"Dirty Checking\"도 변경 감지 중에 발생할 것입니다.\n\n따라서 TimerComponent가 ListComponent의 자식 요소인 한, 변경 감지는 ListComponent를 통과하여 해당 요소도 확인해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 함께 해요\n\nTimerComponent에만 OnPush를 설정해보세요. 그러면 로그가 ListComponent에서만 발생하는 것을 볼 수 있을 거예요. 그 이유는 OnPush가 구성 요소에 대해 zone.js를 비활성화하지 않기 때문이에요. 여전히 간격을 인식하고 변경 감지를 트리거하여 매 초마다 실행해요.\n\nTimerComponent는 어떤 기준(위의 목록 참조)도 해당되지 않아 '더티'로 표시되지 않습니다. 따라서 DOM이 업데이트되지 않아요. 비동기 작업은 변경 감지만 트리거하고 구성 요소를 '더티'로 표시하지는 않아요.\n\n새로 고침을 클릭하면 TimerComponent에서도 변경 감지가 트리거되는 것을 볼 수 있어요. 이는 @Input이 새 참조로 업데이트되었기 때문이에요.\n\n<div class=\"content-ad\"></div>\n\n만약 \"Updated\" 텍스트를 클릭하면 아무 변화가 없다는 것을 알 수 있어요. DOM 이벤트를 발생시켰지만 내부적으로 해당 이벤트를 처리할 이벤트 핸들러가 없어요.\n\n텍스트에 이벤트 리스너를 추가해봐요. 아무 동작을 하지 않아도 괜찮아요. 그냥 존재하는 것만으로도 충분해요. 클릭하면 Change Detection이 실행되는 것을 확인할 수 있을 거예요.\n\n이미 목록을 확인하고 있는데, async 파이프도 추가해보도록 해요:\n\n```js\n@Component({\n  selector: 'app-timer',\n  template: `<span class=\"px-2\">Last Updated: { lastUpdateInSeconds$ | async | number:'1.0-0' }\n      Seconds</span> { logCd() }`,\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [\n    DatePipe,\n    DecimalPipe,\n    AsyncPipe\n  ]\n})\nexport class TimerComponent {\n  @Input() lastUpdate = new Date();\n\n  lastUpdateInSeconds$ = interval(1000).pipe(map(() => this.lastUpdateInSeconds = (new Date().getTime() - this.lastUpdate.getTime()) / 1_000))\n\n  logCd() {\n    console.log('log from timer');\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n지금부터 타이머가 매 초 업데이트되어야 합니다. 만약 동기부여를 받았다면 컴포넌트에서 구독을 시도해 보세요. 그러면 변경 감지가 더 이상 컴포넌트를 확인하지 않음을 알 수 있을 것입니다.\n\n이미 OnPush를 사용하고 있지만 변경 감지는 여전히 ListComponent를 매 초 확인합니다. 그것은 그다지 효율적이지 않습니다.\n\n# 로컬 변경 감지\n\nAngular 17와 신호를 발견하세요.\n\n<div class=\"content-ad\"></div>\n\n앵귤러 팀이 17번 버전을 릴리스하기 일주일 전에, 로컬 변경 감지를 추가했습니다. 이 기능은 우리의 사용 사례에 완벽하게 어울립니다.\n\n이를 통해 컴포넌트 트리에서 단일 컴포넌트를 더러운 상태로 표시할 수 있습니다. 따라서 변경 감지는 부모를 확인하지 않을 것입니다. 만약 그 자식 컴포넌트들이 OnPush로 표시되어 있다면, 그것들 또한 제외될 것입니다.\n\n이 기능을 작동시키기 위해 우리는 두 가지 요소가 필요합니다: 신호(Signals)와 OnPush입니다. 그래서 필요한 것은 이 두 가지뿐입니다.\n\n아래 그림은 이 새로운 기능을 보여줍니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Local Change Detection in Angular](/assets/img/2024-05-17-LocalChangeDetectioninAngular_4.png)\n\nOnPush를 추가하고 TimerComponent를 Signals로 리팩토링한 코드입니다:\n\n```javascript\n@Component({\n  selector: 'app-timer',\n  template: `<span>Last Updated: {{ lastUpdateInSeconds() | number:'1.0-0' }} Seconds</span> {{ logCd() }}`,\n  standalone: true,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [DatePipe, DecimalPipe, AsyncPipe]\n})\nexport class TimerComponent {\n  @Input() lastUpdate = new Date();\n  lastUpdateInSeconds = signal(0)\n  constructor() {\n    setInterval(() => {\n      this.lastUpdateInSeconds.set((new Date().getTime() - this.lastUpdate.getTime()) / 1_000);\n    }, 1000);\n  }\n\n  logCd() {\n    console.log('log from timer');\n  }\n}\n```\n\nListComponent도 OnPush여야 합니다. 그렇지 않으면 Change Detection이 항상 확인합니다.\n\n\n<div class=\"content-ad\"></div>\n\n만약 지금 페이지를 새로고침하면, 타이머가 작동 중이지만 목록은 한 번만 확인되었습니다. 이제 \"새로고침\" 버튼을 클릭하면 ListComponent에서 처리되는 DOM 이벤트를 트리거합니다. 따라서 변경 감지는 해당 컴포넌트에 대해... 두 번 실행됩니다.\n\n한 번이 아니라 두 번 왜 그럴까요? 여기에는 두 가지 트리거가 있습니다. 첫 번째는 DOM 이벤트이고, 두 번째는 나중에 약간 끝나는 fetch에서 비동기 작업입니다.\n\n이것이 바로 로컬 변경 감지입니다. 시그널 컴포넌트에 대해 기대할 수 있는 일부를 간단히 살펴보았습니다.\n\n# 요약\n\n<div class=\"content-ad\"></div>\n\n로컬 변경 감지는 강력한 기능입니다. 변경 감지에서 어떤 구성 요소가 검사를 거쳐야 하는지 정확히 정의할 수 있습니다.\n\nAngular 17에서만 사용 가능하며 OnPush 및 신호를 모두 사용해야 합니다.\n\n이는 미래 신호 구성 요소의 일부로, 더욱 미세한 변경 감지가 가능해질 것입니다.\n\n데모 저장소는 다음에서 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n# 감사의 말씀\n\n이 글을 철저히 검토하고 그림을 개선하도록 강력히 요구한\nThomas Laforge님에게 감사의 말씀을 전하고 싶습니다.\n\n또한, Change Detection의 내부 작업에 대한 통찰을 제공해 준\nAndrew Scott님과\nSander Elias님께도 감사의 말씀을 전합니다.\n\n# 추가로 읽을 거리","ogImage":{"url":"/assets/img/2024-05-17-LocalChangeDetectioninAngular_0.png"},"coverImage":"/assets/img/2024-05-17-LocalChangeDetectioninAngular_0.png","tag":["Tech"],"readingTime":9},{"title":"Angular에서 의존성 주입 Dependency Injection을 사용하여 브라우저 글로벌 객체에 접근하기","description":"","date":"2024-05-17 21:15","slug":"2024-05-17-AccessingBrowserGlobalObjectsinAngularwithDependencyInjection","content":"\n\n<img src=\"/assets/img/2024-05-17-AccessingBrowserGlobalObjectsinAngularwithDependencyInjection_0.png\" />\n\nAngular 애플리케이션에서는 종종 네이티브 브라우저 API 또는 window나 document와 같은 전역 객체와 상호 작용해야 할 때가 있습니다. 이러한 객체들을 직접 참조할 수는 있지만, 권장되지 않습니다. 왜냐하면 이는 더 강한 결합을 유발하고, 테스트하기 어렵게 만들며, 코드를 특정 플랫폼(즉, 브라우저)에 종속시키기 때문입니다.\n\n이것이 의존성 주입 (DI)가 구원해주는 곳입니다...\n\n# Angular의 Document 토큰\n\n<div class=\"content-ad\"></div>\n\nAngular에서는 브라우저의 문서 객체를 주입할 수 있는 DOCUMENT 토큰이 있습니다. 이 토큰은 Angular의 platform-browser 패키지의 일부이며, 앱이 서버 또는 브라우저에서 실행 중인지에 관계없이 적절한 객체를 제공할 것입니다.\n\n다음 예제는 COMPONENT에서 DOCUMENT 토큰을 주입하고 해당 함수 중 하나에 접근하는 방법을 보여줍니다:\n\n```js\nimport { DOCUMENT } from '@angular/common';\nimport { inject } from '@angular/core';\n\nexport class TestComponent {\n  private readonly document = inject(DOCUMENT);\n\n  reloadPage(): void {\n    this.document?.location?.reload();\n  }\n}\n```\n\n이 전 예제는 매우 간단합니다: Angular의 DOCUMENT 토큰을 가져와 주입하고, 브라우저의 위치 속성에 접근하며 다시로드하는 방법을 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n# 창 속성 접근\n\n창 속성에 접근해야 할 경우, 동일한 DOCUMENT 토큰을 사용해야 합니다:\n\n```js\nimport { DOCUMENT } from '@angular/common';\nimport { inject } from '@angular/core';\n\nexport class TestComponent {\n  private readonly document = inject(DOCUMENT);\n  private readonly window = this.document?.defaultView\n\n  getLanguage(): string {\n    return this.window?.navigator?.language\n  }\n}\n```\n\n주입된 DOCUMENT를 활용하여, defaultView 속성을 통해 창 객체에 접근할 수 있습니다. 이를 통해 모든 기능과 객체에 접근할 수 있습니다. 이 구체적인 예제에서는 브라우저 사용자 인터페이스의 언어를 나타내는 문자열을 제공하는 navigator 객체를 가져옵니다.\n\n<div class=\"content-ad\"></div>\n\n이 방식은 이제 브라우저별 API와 작업하는 것이 훨씬 쉽고 안전해졌어요. 그러나 window 객체를 자주 사용해야 하는 상황이 생기면 사용자 정의 토큰을 만들 수도 있어요.\n\n# 사용자 정의 Window 토큰\n\n다음 예에서는 Angular의 DOCUMENT와 비슷한 커스텀 WINDOW 토큰을 생성하고 프로젝트 전반에 걸쳐 사용하는 방법을 보여줍니다:\n\n```js\n// browser-global-tokens.ts\nimport { DOCUMENT } from '@angular/common';\nimport { InjectionToken, inject } from '@angular/core';\n\n/**\n * 전역 window 객체를 위한 인젝션 토큰.\n */\nexport const WINDOW = new InjectionToken<Window>('Global window object', {\n  factory: (): Window => inject(DOCUMENT)?.defaultView\n});\n```\n\n<div class=\"content-ad\"></div>\n\n위의 코드 스니펫은 팩토리 함수를 사용하여 생성된 WINDOW이라는 인젝션 토큰을 정의합니다. 이 함수는 inject(DOCUMENT).defaultView를 사용하여 DOCUMENT 객체의 defaultView 속성을 검색하며, Angular 애플리케이션 내에서 의존성 주입(DI)을 통해 윈도우 객체에 접근할 수 있도록 합니다.\n\n새로운 WINDOW 토큰을 사용하여 TestComponent 예제를 업데이트해 보겠습니다:\n\n```js\nimport { WINDOW } from './browser-global-tokens.ts';\nimport { inject } from '@angular/core';\n\nexport class TestComponent {\n  private readonly window = inject(WINDOW);\n\n  getLanguage(): string {\n    return this.window?.navigator?.language\n  }\n}\n```\n\n우리의 WINDOW 토큰을 직접 사용하여 브라우저의 언어에 액세스하는 코드를 약간 단순화할 수 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nAngular의 의존성 주입 메커니즘을 활용하여 window와 같은 전역 객체를 안전하고 유지보수가 용이하게 애플리케이션에 주입하는 방법을 살펴보았습니다. 주입 토큰과 팩토리 함수를 사용하여 이러한 전역 객체를 우리의 코드에 매끄럽게 통합할 수 있으며 Angular의 최상의 관행을 준수할 수 있습니다.\n\nAngular 애플리케이션에서 전역 객체에 직접 접근을 피하는 것은 좋은 코드 구성 및 테스트 가능성을 촉진할 뿐만 아니라 유형 안정성 및 크로스 플랫폼 호환성을 향상시킵니다.","ogImage":{"url":"/assets/img/2024-05-17-AccessingBrowserGlobalObjectsinAngularwithDependencyInjection_0.png"},"coverImage":"/assets/img/2024-05-17-AccessingBrowserGlobalObjectsinAngularwithDependencyInjection_0.png","tag":["Tech"],"readingTime":3},{"title":"현업에서 바로 사용할 수 있는 5가지 Angular 라이브러리 ","description":"","date":"2024-05-17 21:14","slug":"2024-05-17-5AngularLibrariesToUseInYourProjects","content":"\n\n\n![Angular Code Input](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_0.png)\n\n안녕하세요, 여러분! 오늘은 여러분과 함께 유용한 5가지 Angular 라이브러리를 소개할 거에요. 이 라이브러리들을 제가 제 프로젝트에서 사용해서, 개발 속도를 높였어요. 확실히 이 라이브러리들이 여러분들의 삶을 훨씬 편하게 만들 거예요. 그럼, 어떤 것들이 있는지 한번 알아볼까요?\n\n## Angular Code Input\n\n![Angular Code Input](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_1.png)\n\n\n<div class=\"content-ad\"></div>\n\n저희 프로젝트에서는 사용자 인증 프로세스에 OTP와 같은 확인 코드를 사용하기도 합니다. 일반 텍스트 상자를 사용하면 입력 확인을 수동으로 처리해야 합니다. 그러나 이 라이브러리를 사용하면 입력 확인을 쉽게 할 수 있습니다. 또한 이 라이브러리는 UI에 멋진 룩을 더하는 좋은 컴포넌트를 제공합니다. 클립보드 이벤트도 지원됩니다. 따라서 별도의 컴포넌트를 생성할 필요가 없습니다. 이 라이브러리는 Angular 7 이상 버전만 지원합니다.\n\n## Angular Gridster 2\n\n![image](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_2.png)\n\n대시보드를 만들 때 서로 다른 카드를 표시합니다. 때로는 드래그 앤 드롭, 크기 조절 기능을 추가하고 싶을 때도 있습니다. 또한 반응형이어야 합니다. 이러한 것들을 수동으로 처리하는 것은 매우 번거로운 작업입니다. 이런 경우에 이 라이브러리가 도움이 됩니다. Angular Gridster에는 이러한 기능이 모두 갖춰져 있습니다. 이 라이브러리를 사용하여 멋진 대시보드를 만들 수 있습니다. 다양한 옵션이 있습니다. 이 링크를 통해 이 라이브러리의 데모를 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## Ngx 마크다운\n\n![이미지](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_3.png)\n\n만약 Angular 프로젝트를 위한 마크다운 에디터를 찾고 있다면, 여기 있어요. 이 라이브러리는 구문 강조, 수학식 지원, 이모지 지원, 차트 및 다이어그램 시각화와 같은 기능을 갖춘 마크다운 에디터를 제공합니다. 이 라이브러리는 행동을 사용자 정의할 수 있는 다양한 옵션을 제공합니다. 또한 이 라이브러리와 놀 수 있는 데모 프로젝트도 제공됩니다.\n\n## Ng2 차트\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_4.png)\n\nAngular에서 데이터 시각화를 위한 훌륭한 라이브러리입니다. 이 라이브러리는 막대 차트, 파이 차트, 산점도, 선 그래프 등 다양한 차트를 제공합니다. 이 라이브러리는 chart.js를 기반으로 하고 있습니다. 따라서 Angular 프로젝트에서 chart.js 라이브러리의 모든 차트를 사용할 수 있습니다. 이 링크에서 라이브러리 데모를 확인할 수 있습니다.\n\n## Ngx Cookie Service\n\n![이미지](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n이 라이브러리는 Angular에서 쿠키를 쉽게 처리할 수 있는 서비스를 제공합니다. 이 라이브러리는 Angular 서비스로 작동합니다. 이 라이브러리를 사용하여 쿠키의 읽기, 설정 및 삭제 작업을 수행할 수 있습니다. 또한 이 라이브러리는 서버 측 렌더링을 지원합니다. 라이브러리를 설치한 다음 컴포넌트에 주입하면 됩니다. 이제 이것을 일반 Angular 서비스로 사용할 수 있습니다.\n\n지금까지입니다. 프로젝트에서 이 라이브러리를 사용해보세요. 또 다른 블로그에서 만나요. 즐거운 코딩하세요! 이 블로그가 도움이 되었다면 좋아요를 부탁드립니다.\n\n![Angular Libraries](/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_6.png)\n\n저의 웹사이트 https://hirushafernando.com/ 에서 연락을 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Stackademic 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 저자를 칭찬하고 팔로우해 주시면 감사하겠습니다! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루어야 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_0.png"},"coverImage":"/assets/img/2024-05-17-5AngularLibrariesToUseInYourProjects_0.png","tag":["Tech"],"readingTime":3},{"title":"웹 성능을 향상시키는 Angular FormArray 팁","description":"","date":"2024-05-17 21:12","slug":"2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners","content":"\n\n## 웹 개발\n\n![이미지](/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_0.png)\n\n비디오 버전은 여기에서 확인할 수 있습니다.\n\nFormArrays의 한 가지 큰 도전 과제는 최적의 웹 성능과 원활한 사용자 상호 작용을 보장하기 위해 이벤트 리스너를 효율적으로 관리하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n아래 사례 연구에서는 FormArray의 항목이 변경될 때 API에서 데이터를 가져 오는 두 가지 전략을 밝힐 것입니다. 실제 예제와 함께 이를 살아있게 만들 것입니다. 각 접근 방법을 안내하고 코드 디자인 및 웹 성능에 어떤 것이 도움이 될지 살펴볼 것입니다. 그러니 코딩 모자를 준비하고 시작해 보세요.\n\n기술적인 면으로 들어가기 위해 실제 시나리오로 들어가겠습니다. \"사용자 지정 필드 집합 만들기\" 양식을 보여드리겠습니다:\n\n![이미지](/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_1.png)\n\n여기서 \"필드 클래스 추가\" 버튼을 클릭하고 필드 클래스를 선택한 후, 필드 클래스를 선택하면 Get 요청이 트리거되어 API로 전송되는 것을 관찰하십시오. 두 번째 필드 클래스를 선택하면 추가 요청이 전송됩니다.\n\n<div class=\"content-ad\"></div>\n\n![Image](/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_2.png)\n\n이제 재미있는 부분으로 들어가서 두 가지 다른 방법으로 이러한 요청을 API로 보내는 방법을 살펴보겠습니다. 각 방법이 응용 프로그램의 성능에 어떤 영향을 미치는지 주의 깊게 살펴보세요.\n\n그래서 먼저 소스 코드를 확인하고 현재 요청이 UI에서 API로 전송되는 방법을 살펴보겠습니다.\n\n\"사용자 지정 필드 세트 작성\" 양식의 템플릿에서 fieldclasses 섹션에서 다음 FormArray가 있는 것을 확인할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n20번 라인에는 `mat-autocomplete` 목록이 포함되어 있습니다. 사용자가 \"Add Fieldclass\" 버튼을 클릭할 때마다 새로운 `mat-autocomplete`가 FormArray에 추가됩니다. 이는 가능한 fieldclass 값에 대한 제안이 포함된 드롭다운을 표시합니다.\n\nngOnInit() 라이프사이클 훅에서 다음 이벤트 리스너가 있습니다:\n\n`.valueChanges()`에 대한 구독은 fielclasses FormArray에 연결되어 있어, FormArray에서 변경이 발생할 때마다 부모 컴포넌트로 이벤트 getOutputKeysForFieldClasses를 발행합니다.\n\n부모 컴포넌트는 이를 표현식으로 캐치합니다: (getOutputKeysForFieldClasses)=\"getOutputKeys($event)\"\n\n<div class=\"content-ad\"></div>\n\n그리고 Store Service에서 getOutputKeysForFieldClasses(fieldClasses)을 호출할 거에요:\n\n요즘 구현 상태를 확인하려면 브라우저에서 애플리케이션의 동작을 확인해봐요.\n\n\"사용자 정의 필드 집합 만들기\" 양식을 다시 열고 보내질 API 요청의 숫자를 세볼 거에요.\n\n- 먼저, \"필드클래스 추가\"를 클릭할 거에요,\n- 항목을 선택하면 하나의 요청이 보내져요,\n- \"필드클래스 추가\"를 다시 클릭합니다. 두 번째 클릭 후에는 FormArray에 두 번째 폼 필드만 있지만, 아직 필드클래스를 선택하지 않았어요. 그런데 또 다른 요청이 API로 전송돼요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_3.png\" />\n\n사용자가 \"Add Field class\" 버튼을 클릭할 때마다 새로운 요청이 API로 전송됩니다. 심지어 새로 추가된 폼 필드가 아직 비어 있더라도 그렇습니다.\n\n그 이유는 FormArray에 변경 사항이 있기 때문에 .valueChanges() 이벤트 리스너의 내용이 실행됩니다. 그러나 예상한 동작은 Fieldclass를 선택한 후에만 API로 Get 요청을 보내야 한다는 것입니다.\n\n# 문제 해결\n\n<div class=\"content-ad\"></div>\n\n이제 문제를 어떻게 해결할 수 있는지 살펴봅시다.\n\n전체 FormArray의 변경 사항 구독을 제거할 것입니다. 대신 새로운 이벤트 리스너를 추가하고 `mat-autocomplete`에 연결할 것입니다.\n\n따라서 옵션을 선택한 후 onSelectFieldclass() 메서드를 호출할 것이며, 이 메서드는 FormArray에서 Fieldclasses 목록을 검색하여 전달된 이벤트의 매개변수로 제공할 것입니다.\n\n이전에는 Fieldclasses 목록도 FormArray에서 검색되었지만, getOutputKeysForFieldClasses 이벤트를 트리거해야 하는 시점이 다소 정확하지 않았습니다. 이제 옵션이 선택된 경우에만 이 이벤트가 발생됩니다.\n\n<div class=\"content-ad\"></div>\n\n이제 브라우저에서 동작을 확인해 볼게요:\n  \n- \"Add Fieldclass\"를 클릭하면 요청이 전송되지 않아요.\n- 2번 클릭해 봐도 요청이 전송되지 않아요.\n- 그런데 Fieldclass를 선택하면 요청이 한 번만 전송돼요.\n\n<img src=\"/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_4.png\" />\n\n이제 요청이 예상대로 올바르게 전송돼요! 이를 통해 문제를 해결했어요.\n\n<div class=\"content-ad\"></div>\n\n그냥 명심해야 할 점은 API로 보내는 요청의 수가 늘어나거나 예상된 것보다 훨씬 많은 이벤트 리스너의 문제로 인해 성능 문제가 발생하지 않도록 하려면 예제처럼 로직을 올바른 위치에 추가해야 한다는 것이에요.\n\n# 두 가지 접근 방식 비교\n\n여기서 FormArray의 .valueChanges observable을 구독한 것과 `mat-autocomplete` 태그의 (optionSelected) 이벤트에 의해 트리거된 onSelectItem() 메소드를 사용한 새로운 접근 방식 사이의 차이를 요약해 봤어.\n\n디자인과 성능 측면에서 그 차이는 상당히 중요해요.\n\n<div class=\"content-ad\"></div>\n\n## 원래 접근 방식: valueChanges 이벤트에 대해\n\n- 이벤트 트리거: FormArray의 valueChanges 이벤트 리스너는 배열 내의 양식 컨트롤의 값이 변경될 때마다 또는 FormArray에 새 양식 컨트롤이 추가될 때마다 트리거됩니다. 이는 옵션 자동완성에서 옵션을 선택하는 것뿐만 아니라 모든 변경에 반응한다는 것을 의미합니다.\n- 반응 범위가 넓음: 이벤트 리스너는 변경 유형을 구분하지 않습니다. 관련없는 변경에 반응할 수 있으며, 이는 내부 논리의 불필요한 실행으로 이어질 수 있습니다.\n- 성능: 다른 유형의 FormArray 업데이트가 발생하는 경우에도 데이터를 가져오지 않아도 되는 경우를 고려하면 효율적이지 않습니다.\n\n## 새로운 접근 방식: optionSelected 이벤트에 대해\n\n- 특정 이벤트 트리거: onSelectItem() 메서드는 `mat-autocomplete`의 (optionSelected) 이벤트에 의해 특별히 트리거됩니다. 이렇게하면 메서드가 옵션을 활성적으로 선택했을 때만 실행되도록 보장하여 좀 더 명확해집니다.\n- 단순화된 논리: 메서드는 선택한 옵션 처리에 직접 초점을 맞춥니다. 이로 인해 코드가 쉽고 유지보수가 쉬워지게 됩니다.\n- 성능 향상: 선택 이벤트에만 반응함으로써 FormArray의 모든 미세한 변경에 반응하는 성능 부담을 피할 수 있습니다. 변경 빈도가 높은 양식에서 특히 유익할 수 있습니다.\n- 부수 효과 감소: 옵션 선택에 대한 응답을 단지 옵션 선택으로 제한함으로써 관련 없는 양식 컨트롤 변경으로 인한 불필요한 프로세스 또는 부수 효과를 트리거할 위험이 줄어듭니다.\n\n<div class=\"content-ad\"></div>\n\n요약하자면, `mat-autocomplete`의 (optionSelected) 이벤트에 관련된 새로운 접근 방식은 이벤트 중심 프로그래밍에서 더 나은 방법으로, 특히 복잡한 양식에서 효과적입니다.\n\n그리고 이로써 우리는 Angular에서 양식 이벤트 처리를 최적화하는 방법에 대해 알아보았습니다! 기억해 주세요, 올바른 접근 방식은 좋은 코드를 훌륭한 코드로 만들 수 있으며, 성능을 향상시키고 개발 프로세스를 간소화할 수 있습니다.\n\n# 최종 생각\n\n오늘 탐구한 것은 빙산의 일각에 불과합니다.\n\n<div class=\"content-ad\"></div>\n\n흥미로운가요?\n\n여기에는 \"웹 성능 101\" 비디오 코스에 포함된 내용 일부만 입니다. 웹 개발 스킬을 더 향상시키고 싶다면, 이 기회를 놓치지 마세요!\n\n이 여정을 시작한 이미 약 3만 명의 학생들과 함께 웹 성능의 예술과 과학을 마스터하는 여정에 참여하세요 🚀. 아래 링크를 확인하고 무엇이 이렇게 핫한지 직접 확인해보세요!\n\n만약 이 포스트가 도움이 되었다면, 친구들과 공유해보세요. 호기심을 갖고 코딩을 계속해 나가다 보면, 다음 글에서 다시 만나요.\n\n<div class=\"content-ad\"></div>\n\n# 더 알고 싶으세요?\n\n내가 똑똑하고 호기심 많은 사람들을 위해 엔지니어링, 기술, 리더십에 대해 쓰고 있어요 🧠💡. 독점 액세스를 위한 무료 이메일 뉴스레터에 가입해보세요.","ogImage":{"url":"/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_0.png"},"coverImage":"/assets/img/2024-05-17-AngularFormArrayTipsforSmootherWebPerformanceEventListeners_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular 17의 새로운 제어 흐름 구문 내용 정리","description":"","date":"2024-05-17 21:10","slug":"2024-05-17-MustKnowAngular17NewControlFlowSyntax","content":"\n\n\n![New Control Flow Syntax in Angular](/assets/img/2024-05-17-MustKnowAngular17NewControlFlowSyntax_0.png)\n\n앵귤러 17과 18에서 소개된 새로운 제어 흐름 구문에 대한 포괄적인 설명을 제공해 드릴게요. 예제를 통해 자세히 설명해 드리겠습니다:\n\n# 앵귤러에서의 새로운 제어 흐름 구문\n\n앵귤러 17과 18은 내장 구문을 사용하여 템플릿 내에서 제어 흐름을 더 직관적이고 선언적으로 다룰 수 있도록 제공합니다. 이를 통해 *ngIf, *ngFor, ngSwitch와 같은 디렉티브를 사용할 필요가 없어져 가독성과 유지보수성이 향상되었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 주요 개념:\n\n- @if...else: 불리언 표현식에 기반하여 조건부 렌더링을 구현합니다. 프로그래밍 언어의 전통적인 if...else 문과 유사합니다.\n- @for...of: 배열이나 iterable을 반복하며 각 항목과 루프 내의 컨텍스트 변수에 액세스를 제공합니다.\n- @switch...case...default: 조건에 기반하여 다중 분기를 제공하며 JavaScript의 switch 문과 일치합니다.\n\n예시\n\n```js\n<div>\n  @if (isLoggedIn) {\n    <p>환영합니다, { username }님!</p>\n    <button (click)=\"logout()\">로그아웃</button>\n  } else {\n    <p>계속하려면 로그인하세요.</p>\n    <button (click)=\"login()\">로그인</button>\n  }\n</div>\n\n<ul>\n  @for (let item of items; track item.id) {\n    <li>{ item.name }</li>\n  }\n  @empty {\n    <li>표시할 항목이 없습니다.</li>\n  }\n</ul>\n\n<div>\n  @switch (status) {\n    @case ('pending') {\n      <p>주문 처리 중입니다.</p>\n    }\n    @case ('shipped') {\n      <p>주문이 발송되었습니다! <a href=\"#\">여기</a>에서 추적하세요.</p>\n    }\n    @default {\n      <p>주문 상태를 확인할 수 없습니다.</p>\n    }\n  }\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n설명:\n\n## 조건부 렌더링:\n\n- @if 블록은 isLoggedIn 변수에 따라 조건부로 콘텐츠를 렌더링합니다.\n- else 블록은 isLoggedIn이 false인 경우 대체 뷰를 제공합니다.\n\n## 반복문:\n\n<div class=\"content-ad\"></div>\n\n- @for (let item of items; track item.id)은 items 배열을 반복합니다.\n- let item은 루프 내 각 항목에 대한 지역 변수 item을 생성합니다.\n- track item.id는 효율적인 DOM 업데이트에 사용되는 trackBy 표현식입니다.\n- 루프 몸체는 각 항목에 대해 목록 항목 'li'를 렌더링하고 해당 name 속성을 표시합니다.\n- @empty 블록은 배열에 항목이 없는 경우 메시지를 표시합니다.\n\n# 다중 분기:\n\n- @switch (status)는 status 변수를 평가합니다.\n- @case 블록은 특정 값(‘pending’, ‘shipped’)과 일치합니다.\n- 일치하는 case 블록은 상태에 기반하여 해당 내용을 렌더링합니다.\n- @default 블록은 일치하지 않는 경우를 처리합니다.\n\n# 이점:\n\n<div class=\"content-ad\"></div>\n\n- 개선된 가독성: 새로운 구문은 표준 프로그래밍 구조와 더 밀접하게 일치하여 템플릿을 이해하기 쉽게 만듭니다.\n- 불필요한 길이를 줄인: 긴 지시어 구문(*ngIf, *ngFor 등)을 제거하여 코드를 더 깨끗하게 만듭니다.\n- 향상된 유지보수성: 선언적 접근 방식은 로직을 단순화하고 유지보수성을 향상시킵니다.\n\n# 추가 사항:\n\n- 새로운 제어 흐름 구문은 선택 사항입니다. 선호하는 경우 기존 지시어를 계속 사용할 수 있습니다.\n- 데이터가 없는 경우 정보 전달 메시지를 제공하려면 컬렉션을 반복할 때 @empty 블록을 사용하는 것을 고려해보세요.\n\nAngular 17 및 18의 새로운 제어 흐름 구문에 대한 더 많은 예제를 확인할 수 있습니다. 그것의 다재다능성을 보여줍니다.  \n\n\n<div class=\"content-ad\"></div>\n\n# 1. 중첩된 제어 흐름:\n\n```js\n- 카테고리:\n- 제품:\n```\n이 예제는 @for를 사용하여 중첩된 루프를 보여줍니다. 외부 루프는 카테고리를 반복하고, 내부 루프는 각 카테고리 내의 제품을 반복합니다. 내부 루프 내의 @empty 블록은 카테고리에 제품이 없는 경우 메시지를 제공합니다.\n\n# 2. bind를 사용한 조건부 속성:\n\n<div class=\"content-ad\"></div>\n\n```js\n<input type=\"text\"\n       @bind-disabled=\"!isEditEnabled\"\n       placeholder=\"이름을 입력하세요\">\n```\n\n@bind 지시문을 사용하면 속성에 바인딩을 조건부로 적용할 수 있습니다. 여기서 disabled 속성은 !isEditEnabled에 바인딩됩니다. isEditEnabled가 false인 경우 입력 필드가 비활성화됩니다.\n\n# 3. 색인($index) 및 다른 문맥 변수를 사용한 루핑:\n\n```js\n<ul>\n  @for (let item of items; track item.id) {\n    <li>아이템 #{ $index + 1 }: { item.name }</li>\n  }\n</ul>\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시는 $index를 활용하여 각 항목의 인덱스(1부터 시작)를 표시합니다. @count (총 항목 수), @first (첫 번째 항목 여부), @last (마지막 항목 여부), @even 및 @odd와 같은 다른 문맥 변수를 사용하여 더 복잡한 형식을 지정할 수도 있습니다.\n\n### 4. 논리 연산자와 함께 @if 조합하기:\n\n```js\n<div>\n  @if (isLoggedIn && hasPermission('edit')) {\n    <button (click)=\"editUser()\">Edit User</button>\n  }\n</div>\n```\n\n@if를 사용하면 논리 연산자(&&, ||, !)를 사용하여 조건을 결합할 수 있습니다. 여기서 사용자가 로그인되어 있고 \"편집\" 권한을 가지고 있을 때에만 버튼이 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 5. 복잡한 조건과 함께 @switch 사용하기:\n\n```js\n<div>\n  @switch (userRole) {\n    @case ('admin') {\n      <p>환영합니다, 관리자님!</p>\n    }\n    @case ('editor', 'moderator') {\n      <p>환영합니다, 콘텐츠 편집자/모더레이터님!</p>\n    }\n    @default {\n      <p>환영합니다, 사용자님!</p>\n    }\n  }\n</div>\n```\n\n@switch는 복잡한 조건을 가진 여러 경우를 처리할 수 있습니다. 여기서는 쉼표로 구분된 값들('admin', 'editor', 또는 'moderator')에 대해 확인합니다.\n\n이것들은 단지 몇 가지 예시일 뿐입니다. 새로운 제어 흐름 구문은 Angular 템플릿에서 조건부 렌더링과 루프 로직을 유연하고 강력하게 다룰 수 있는 방법을 제공합니다. 자유롭게 실험하고 더 많은 기능을 탐구해보세요!\n\n<div class=\"content-ad\"></div>\n\n수고하셨습니다,\n\n찬단","ogImage":{"url":"/assets/img/2024-05-17-MustKnowAngular17NewControlFlowSyntax_0.png"},"coverImage":"/assets/img/2024-05-17-MustKnowAngular17NewControlFlowSyntax_0.png","tag":["Tech"],"readingTime":4}],"page":"71","totalPageCount":154,"totalPageGroupCount":8,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}