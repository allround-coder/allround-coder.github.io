{"pageProps":{"post":{"title":"React 스킬을 향상시키는 방법 Promises","description":"","date":"2024-05-12 19:50","slug":"2024-05-12-LevelUpYourReactSkillswithPromises","content":"\n\n<img src=\"/assets/img/2024-05-12-LevelUpYourReactSkillswithPromises_0.png\" />\n\nReact에서 Promise은 JavaScript의 기능 중 하나로 사용되는 비동기 작업을 처리하는 데 사용됩니다. Promise는 작업이 완료될 때 무엇을 할지 나타내는 객체입니다. 네트워크 요청, 파일 로드 및 데이터베이스 쿼리와 같은 비동기 작업을 처리하는 데 일반적으로 사용됩니다.\n\nReact에서 Promise은 일반적으로 데이터를 가져오거나 수정할 때 사용됩니다. 예를 들어, API 요청을 보내고 응답을 기다릴 때 Promise를 사용하여 데이터를 비동기적으로 가져옵니다.\n\nReact에서 Promise는 비동기 작업의 결과를 처리하고 상태를 업데이트하거나 UI를 업데이트하는 데 사용됩니다. 일반적으로 fetch() 함수를 사용하여 API 요청을 보내고 Promise를 사용하여 응답을 처리합니다.\n\n\n\n예를 들어, React에서 데이터를 가져오기 위해 Promise를 사용하는 간단한 예제가 다음과 같습니다:\n\n```js\nfetch('https://api.example.com/data')\n  .then(response => response.json()) // Promise를 사용하여 응답을 JSON 형식으로 파싱\n  .then(data => {\n    // 파싱된 데이터를 처리하거나 상태를 업데이트하는 작업 수행\n    console.log(data);\n  })\n  .catch(error => {\n    // 에러 처리\n    console.error('데이터를 불러오는 중 오류가 발생했습니다:', error);\n  });\n```\n\n이 예제에서, fetch() 함수를 사용하여 API에서 데이터를 가져옵니다. 이 함수는 Promise를 반환하며, 데이터가 성공적으로 가져와지면 .then() 메서드를 사용하여 응답을 처리합니다. 에러가 발생하면 .catch() 메서드를 사용하여 에러를 처리합니다.\n\n그렇다면 비동기 작업이 필요한 이유는 무엇일까요? 비동기 작업이 필요한 주요 이유는 주로 다음과 같습니다:\n\n\n\n- 성능 개선: 비동기 작업을 사용하여 여러 작업을 동시에 처리함으로써 전체 성능을 향상시킬 수 있습니다. 특히 네트워크 요청이나 파일 로딩과 같은 I/O 작업에서 비동기 작업을 사용하면 응답 대기 시간을 줄일 수 있습니다.\n- 향상된 사용자 경험: 비동기 작업은 사용자 인터페이스를 더 반응적이고 빠르게 만듭니다. 예를 들어 데이터를 비동기적으로 가져와 웹 페이지에 표시할 때 페이지의 로딩 시간이 줄어들어 사용자가 더 빨리 상호 작용할 수 있습니다.\n- 자원 관리: 비동기 작업은 효율적인 자원 관리를 가능하게 합니다. 특히 멀티스레딩을 통해 여러 작업을 동시에 처리하고 자원을 효율적으로 활용할 수 있습니다.\n\n비동기 작업과 비교해 동기 작업은 한 번에 하나의 작업만 처리하고 다른 작업이 완료될 때까지 기다립니다. 동기 작업을 사용하면 성능이 저하되고 사용자 경험이 줄어들 수 있습니다. 왜냐하면 작업이 순차적으로 실행되기 때문입니다. 또한, 동기 작업에서 하나의 작업이 느리게 실행되면 다른 작업이 기다려야 하므로 시스템 전체 효율성이 감소합니다.\n\n동기 작업 예시:\n\n```js\nfunction syncTask() {\n  console.log(\"동기 작업 시작\");\n  console.log(\"동기 작업 진행 중...\");\n  console.log(\"동기 작업 완료\");\n}\n\nconsole.log(\"프로그램 시작\");\nsyncTask();\nconsole.log(\"프로그램 종료\");\n```\n\n\n\n이 코드에서 syncTask() 함수는 동기적으로 실행되며, 해당 함수의 작업이 완료될 때까지 이후의 코드가 진행되지 않습니다. 그래서 출력은 다음과 같습니다:\n\n```js\n프로그램 시작\n동기 작업 시작\n진행 중인 동기 작업...\n동기 작업 완료\n프로그램 종료\n```\n\n비동기 작업 예제:\n\n```js\nfunction asyncTask() {\n  console.log(\"비동기 작업 시작\");\n  setTimeout(() => {\n    console.log(\"비동기 작업 완료\");\n  }, 2000); // 2초 후 완료 메시지 출력\n}\n\nconsole.log(\"프로그램 시작\");\nasyncTask();\nconsole.log(\"프로그램 종료\");\n```\n\n\n\n이 코드에서는 asyncTask() 함수가 비동기적으로 실행되며 setTimeout() 함수를 사용하여 2초 후에 완료 메시지가 출력됩니다. 따라서 출력은 다음과 같습니다:\n\n```js\n프로그램 시작\n비동기 작업 시작\n프로그램 종료\n비동기 작업 완료 // 2초 후에 출력됨\n```\n\n이제 React에서 사용되는 예제를 살펴보겠습니다.\n\nReact에서 비동기 작업을 처리하는 일반적인 방법은 useState 및 useEffect 훅을 사용하여 상태를 관리하고 비동기 작업을 처리하는 함수를 호출하는 것입니다. API에서 데이터를 가져와 화면에 표시하는 시나리오를 고려해 봅시다.\n\n\n\n```js\nimport React, { useState, useEffect } from 'react';\n\nfunction App() {\n  // 상태 초기화\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  // useEffect를 사용하여 컴포넌트가 마운트될 때 데이터를 가져옵니다\n  useEffect(() => {\n    // 비동기 작업 시작\n    fetchData()\n      .then(response => {\n        // 데이터를 가져오는 데 성공하면 상태 업데이트\n        setData(response);\n        setLoading(false);\n      })\n      .catch(error => {\n        // 데이터를 가져오는 데 실패하면 에러 처리\n        console.error('데이터 가져오기 오류:', error);\n        setLoading(false);\n      });\n  }, []); // 컴포넌트가 마운트될 때 useEffect가 한 번만 실행되도록 빈 배열을 전달\n\n  // 데이터를 가져오는 비동기 함수\n  const fetchData = async () => {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    return data;\n  };\n\n  return (\n    <div>\n      <h1>React 비동기 작업 예제</h1>\n      {loading ? (\n        <p>Loading...</p>\n      ) : (\n        <div>\n          <h2>데이터:</h2>\n          <pre>{JSON.stringify(data, null, 2)}</pre>\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n```\n\n위 코드에서 useEffect 훅을 사용하여 컴포넌트가 마운트될 때 한 번 데이터를 가져오도록 합니다. fetchData 함수를 사용하여 API에서 데이터를 가져옵니다. 데이터를 가져오는 동안 로딩 상태를 true로 설정하여 로딩 메시지를 표시합니다. 데이터 가져오기가 성공하면 데이터 상태를 업데이트합니다. 데이터 가져오기 중에 오류가 발생하면 오류를 적절히 처리합니다.\n\nReact가 비동기 작업을 효과적으로 처리하는 방법입니다.","ogImage":{"url":"/assets/img/2024-05-12-LevelUpYourReactSkillswithPromises_0.png"},"coverImage":"/assets/img/2024-05-12-LevelUpYourReactSkillswithPromises_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-05-12-LevelUpYourReactSkillswithPromises_0.png\">\n<p>React에서 Promise은 JavaScript의 기능 중 하나로 사용되는 비동기 작업을 처리하는 데 사용됩니다. Promise는 작업이 완료될 때 무엇을 할지 나타내는 객체입니다. 네트워크 요청, 파일 로드 및 데이터베이스 쿼리와 같은 비동기 작업을 처리하는 데 일반적으로 사용됩니다.</p>\n<p>React에서 Promise은 일반적으로 데이터를 가져오거나 수정할 때 사용됩니다. 예를 들어, API 요청을 보내고 응답을 기다릴 때 Promise를 사용하여 데이터를 비동기적으로 가져옵니다.</p>\n<p>React에서 Promise는 비동기 작업의 결과를 처리하고 상태를 업데이트하거나 UI를 업데이트하는 데 사용됩니다. 일반적으로 fetch() 함수를 사용하여 API 요청을 보내고 Promise를 사용하여 응답을 처리합니다.</p>\n<p>예를 들어, React에서 데이터를 가져오기 위해 Promise를 사용하는 간단한 예제가 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://api.example.com/data'</span>)\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =></span> response.<span class=\"hljs-title function_\">json</span>()) <span class=\"hljs-comment\">// Promise를 사용하여 응답을 JSON 형식으로 파싱</span>\n  .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =></span> {\n    <span class=\"hljs-comment\">// 파싱된 데이터를 처리하거나 상태를 업데이트하는 작업 수행</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data);\n  })\n  .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n    <span class=\"hljs-comment\">// 에러 처리</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'데이터를 불러오는 중 오류가 발생했습니다:'</span>, error);\n  });\n</code></pre>\n<p>이 예제에서, fetch() 함수를 사용하여 API에서 데이터를 가져옵니다. 이 함수는 Promise를 반환하며, 데이터가 성공적으로 가져와지면 .then() 메서드를 사용하여 응답을 처리합니다. 에러가 발생하면 .catch() 메서드를 사용하여 에러를 처리합니다.</p>\n<p>그렇다면 비동기 작업이 필요한 이유는 무엇일까요? 비동기 작업이 필요한 주요 이유는 주로 다음과 같습니다:</p>\n<ul>\n<li>성능 개선: 비동기 작업을 사용하여 여러 작업을 동시에 처리함으로써 전체 성능을 향상시킬 수 있습니다. 특히 네트워크 요청이나 파일 로딩과 같은 I/O 작업에서 비동기 작업을 사용하면 응답 대기 시간을 줄일 수 있습니다.</li>\n<li>향상된 사용자 경험: 비동기 작업은 사용자 인터페이스를 더 반응적이고 빠르게 만듭니다. 예를 들어 데이터를 비동기적으로 가져와 웹 페이지에 표시할 때 페이지의 로딩 시간이 줄어들어 사용자가 더 빨리 상호 작용할 수 있습니다.</li>\n<li>자원 관리: 비동기 작업은 효율적인 자원 관리를 가능하게 합니다. 특히 멀티스레딩을 통해 여러 작업을 동시에 처리하고 자원을 효율적으로 활용할 수 있습니다.</li>\n</ul>\n<p>비동기 작업과 비교해 동기 작업은 한 번에 하나의 작업만 처리하고 다른 작업이 완료될 때까지 기다립니다. 동기 작업을 사용하면 성능이 저하되고 사용자 경험이 줄어들 수 있습니다. 왜냐하면 작업이 순차적으로 실행되기 때문입니다. 또한, 동기 작업에서 하나의 작업이 느리게 실행되면 다른 작업이 기다려야 하므로 시스템 전체 효율성이 감소합니다.</p>\n<p>동기 작업 예시:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">syncTask</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"동기 작업 시작\"</span>);\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"동기 작업 진행 중...\"</span>);\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"동기 작업 완료\"</span>);\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"프로그램 시작\"</span>);\n<span class=\"hljs-title function_\">syncTask</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"프로그램 종료\"</span>);\n</code></pre>\n<p>이 코드에서 syncTask() 함수는 동기적으로 실행되며, 해당 함수의 작업이 완료될 때까지 이후의 코드가 진행되지 않습니다. 그래서 출력은 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\">프로그램 시작\n동기 작업 시작\n진행 중인 동기 작업...\n동기 작업 완료\n프로그램 종료\n</code></pre>\n<p>비동기 작업 예제:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">asyncTask</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"비동기 작업 시작\"</span>);\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"비동기 작업 완료\"</span>);\n  }, <span class=\"hljs-number\">2000</span>); <span class=\"hljs-comment\">// 2초 후 완료 메시지 출력</span>\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"프로그램 시작\"</span>);\n<span class=\"hljs-title function_\">asyncTask</span>();\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"프로그램 종료\"</span>);\n</code></pre>\n<p>이 코드에서는 asyncTask() 함수가 비동기적으로 실행되며 setTimeout() 함수를 사용하여 2초 후에 완료 메시지가 출력됩니다. 따라서 출력은 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\">프로그램 시작\n비동기 작업 시작\n프로그램 종료\n비동기 작업 완료 <span class=\"hljs-comment\">// 2초 후에 출력됨</span>\n</code></pre>\n<p>이제 React에서 사용되는 예제를 살펴보겠습니다.</p>\n<p>React에서 비동기 작업을 처리하는 일반적인 방법은 useState 및 useEffect 훅을 사용하여 상태를 관리하고 비동기 작업을 처리하는 함수를 호출하는 것입니다. API에서 데이터를 가져와 화면에 표시하는 시나리오를 고려해 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, { useState, useEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\">// 상태 초기화</span>\n  <span class=\"hljs-keyword\">const</span> [data, setData] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">null</span>);\n  <span class=\"hljs-keyword\">const</span> [loading, setLoading] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">true</span>);\n\n  <span class=\"hljs-comment\">// useEffect를 사용하여 컴포넌트가 마운트될 때 데이터를 가져옵니다</span>\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-comment\">// 비동기 작업 시작</span>\n    <span class=\"hljs-title function_\">fetchData</span>()\n      .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =></span> {\n        <span class=\"hljs-comment\">// 데이터를 가져오는 데 성공하면 상태 업데이트</span>\n        <span class=\"hljs-title function_\">setData</span>(response);\n        <span class=\"hljs-title function_\">setLoading</span>(<span class=\"hljs-literal\">false</span>);\n      })\n      .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> {\n        <span class=\"hljs-comment\">// 데이터를 가져오는 데 실패하면 에러 처리</span>\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'데이터 가져오기 오류:'</span>, error);\n        <span class=\"hljs-title function_\">setLoading</span>(<span class=\"hljs-literal\">false</span>);\n      });\n  }, []); <span class=\"hljs-comment\">// 컴포넌트가 마운트될 때 useEffect가 한 번만 실행되도록 빈 배열을 전달</span>\n\n  <span class=\"hljs-comment\">// 데이터를 가져오는 비동기 함수</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fetchData</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">'https://api.example.com/data'</span>);\n    <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n    <span class=\"hljs-keyword\">return</span> data;\n  };\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>React 비동기 작업 예제<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      {loading ? (\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span>></span>Loading...<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n      ) : (\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h2</span>></span>데이터:<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h2</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">pre</span>></span>{JSON.stringify(data, null, 2)}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">pre</span>></span>\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      )}\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n  );\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">App</span>;\n</code></pre>\n<p>위 코드에서 useEffect 훅을 사용하여 컴포넌트가 마운트될 때 한 번 데이터를 가져오도록 합니다. fetchData 함수를 사용하여 API에서 데이터를 가져옵니다. 데이터를 가져오는 동안 로딩 상태를 true로 설정하여 로딩 메시지를 표시합니다. 데이터 가져오기가 성공하면 데이터 상태를 업데이트합니다. 데이터 가져오기 중에 오류가 발생하면 오류를 적절히 처리합니다.</p>\n<p>React가 비동기 작업을 효과적으로 처리하는 방법입니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}