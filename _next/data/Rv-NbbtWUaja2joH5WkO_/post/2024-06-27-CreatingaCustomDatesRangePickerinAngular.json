{"pageProps":{"post":{"title":"Angular로 사용자 지정 날짜 범위 선택기 만드는 방법","description":"","date":"2024-06-27 18:22","slug":"2024-06-27-CreatingaCustomDatesRangePickerinAngular","content":"\n\n이 글은 Angular에서 구성 요소로써 처음부터 날짜 범위 선택기를 만드는 방법을 설명하는 것을 목표로 하고 있습니다. 이것은 제 첫 번째 글의 두 번째 버전으로 여기에서 찾을 수 있습니다: [Medium 링크](https://medium.com/stackademic/creating-a-custom-date-time-picker-in-angular-5f00591d641c). 또한, 다음 글에서 작성할 사용자 정의 구성 요소의 장점을 잊지 않으세요.\n\n![이미지](/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_0.png)\n  \n## 생성 의도\n\n이 구성 요소를 만들기 전에, 쉽게 스타일링할 수 있고 다음을 제공하는 범용 날짜 선택기를 찾고 있었습니다: 날짜 선택, 시간 선택, 범위 선택. 제가 필요한 것은 간단한 것이었지만, 조사 중에 대부분의 날짜 선택기가 너무 복잡하거나 필요한 조합을 제공하지 않는 것을 발견했습니다.\n\n<div class=\"content-ad\"></div>\n\n## 필요한 기능들:\n\n- 날짜 - 시간 선택기\n- 오직 날짜 선택기\n- 오직 시간 선택기\n- 날짜 - 범위 선택기\n\n이전에는 이 모든 것이 있었지만 범위 기능만 빠졌었어요. 그래서 논리를 간단한 말로 적어보기 시작했어요:\n\n# 논리\n\n<div class=\"content-ad\"></div>\n\n범위=false인 경우에 대한 두 가지 다른 출력이 필요합니다. 하나는 단일 선택이고 두 번째는 선택된 범위 배열이며 selectedRange[0]는 시작 선택이되고 selectedRange[1]는 끝 선택이됩니다.\n\n\n![Creating a Custom Dates Range Picker in Angular](/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_1.png)\n\n\n그런 다음 범위를 확인하여 시각적으로 선택을 표시할 수 있도록해야합니다.\n\n```js\ninRangeSelection(i: number) {\n  const currentDay = new Date(\n    this.date.getFullYear(),\n    this.date.getMonth(),\n    i\n  );\n\n  return (\n    this.range &&\n    this.clickedDate &&\n    this.clickedToDate &&\n    this.clickedDate.getDate() < currentDay.getDate() &&\n    this.clickedToDate.getDate() > currentDay.getDate() &&\n    this.clickedDate.getFullYear() >= currentDay.getFullYear() &&\n    this.clickedToDate.getFullYear() >= currentDay.getFullYear() &&\n    this.clickedDate.getMonth() >= currentDay.getMonth() &&\n    this.clickedToDate.getMonth() >= currentDay.getMonth()\n  );\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n  setDate(index: number) {\n    // 만약 범위 선택이 요청된 경우\n    if (this.range) {\n      // 순서가 매우 중요합니다 -> 이미 범위가 있는 경우 새로운 선택을 클릭하면 다시 처음부터 시작합니다\n      if (this.clickedDate && this.clickedToDate) {\n        this.clickedDate = null;\n        this.clickedToDate = null;\n      }\n\n      // 이미 첫 번째 선택이 있는 경우 값을 clickedToDate에 할당합니다\n      if (this.clickedDate && !this.clickedToDate) {\n        this.clickedToDate = new Date(\n          this.date.getFullYear(),\n          this.date.getMonth(),\n          index\n        );\n      }\n\n      // 여기서만 첫 번째 및 가장 중요한 시작점 설정이 가능합니다\n      if (!this.clickedToDate && !this.clickedDate) {\n        this.clickedDate = new Date(\n          this.date.getFullYear(),\n          this.date.getMonth(),\n          index\n        );\n      }\n\n      // clickedToDate가 clickedDate보다 낮은 경우 뒤집습니다\n      if (\n        this.clickedDate &&\n        this.clickedToDate &&\n        this.clickedDate > this.clickedToDate\n      ) {\n        const clickedToDate = this.clickedDate;\n        const clickedDate = this.clickedToDate;\n        this.clickedDate = clickedDate;\n        this.clickedToDate = clickedToDate;\n      }\n    // 일반 모드에서\n    } else {\n      this.clickedDate = new Date(\n        this.date.getFullYear(),\n        this.date.getMonth(),\n        index\n      );\n    }\n  }\n```\n\n마지막으로 출력 메서드가 변경되었습니다:\n\n```js\n  confirm() {\n    if (this.range) {\n      if (this.clickedDate && this.clickedToDate) {\n        this.selectRange.emit([this.clickedDate, this.clickedToDate]);\n      }\n    } else {\n      if (this.clickedDate) {\n        this.clickedDate.setHours(this.timeForm.get('hours')?.value || 0);\n        this.clickedDate.setMinutes(this.timeForm.get('minutes')?.value || 0);\n        this.selectDate.emit(this.clickedDate);\n      }\n    }\n  }\n```\n\n## 모든 로직을 컴포넌트 내부에 놓게 된 이유는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n만약 저장소에서 전체 컴포넌트를 확인했다면: https://github.com/marekpanti/dateTimePicker/blob/master/projects/marekpanti/angular-date-time-picker/src/lib/angular-date-time-picker.component.ts 아마도 궁금할 것입니다. 왜 Marek는 패서드와 깔끔한 컴포넌트에 대해 언급했을 때 모든 로직을 컴포넌트 내부에 넣는 건지요.\n\n룰에는 예외가 없는 법입니다. 복잡한 컴포넌트와 UI 컴포넌트의 경우, 나는 내 로직이 한 곳에 있기를 원합니다. 내 컴포넌트가 시각적이며 각 속성이 각 메소드와 연결되어 있음을 이해하기 때문에, 서비스를 분리하여 메소드를 읽는 것이 오히려 더 어려울 것입니다.\n\n# 결론\n\n이 글은 처음에 복잡해 보이지만 적절한 계획과 문제 이해로 자신만의 컴포넌트를 쉽게 만들 수 있는 방법을 잘 정리한 요약입니다.\n\n<div class=\"content-ad\"></div>\n\n# Stackademic 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 칭찬하고 팔로우해 주시면 감사하겠습니다! 👏\n- 다음 채널을 구독해 주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해 보세요: In Plain English | CoFeed | Differ\n- 더 많은 컨텐츠는 Stackademic.com에서 확인할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_0.png"},"coverImage":"/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>이 글은 Angular에서 구성 요소로써 처음부터 날짜 범위 선택기를 만드는 방법을 설명하는 것을 목표로 하고 있습니다. 이것은 제 첫 번째 글의 두 번째 버전으로 여기에서 찾을 수 있습니다: <a href=\"https://medium.com/stackademic/creating-a-custom-date-time-picker-in-angular-5f00591d641c\" rel=\"nofollow\" target=\"_blank\">Medium 링크</a>. 또한, 다음 글에서 작성할 사용자 정의 구성 요소의 장점을 잊지 않으세요.</p>\n<p><img src=\"/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_0.png\" alt=\"이미지\"></p>\n<h2>생성 의도</h2>\n<p>이 구성 요소를 만들기 전에, 쉽게 스타일링할 수 있고 다음을 제공하는 범용 날짜 선택기를 찾고 있었습니다: 날짜 선택, 시간 선택, 범위 선택. 제가 필요한 것은 간단한 것이었지만, 조사 중에 대부분의 날짜 선택기가 너무 복잡하거나 필요한 조합을 제공하지 않는 것을 발견했습니다.</p>\n<div class=\"content-ad\"></div>\n<h2>필요한 기능들:</h2>\n<ul>\n<li>날짜 - 시간 선택기</li>\n<li>오직 날짜 선택기</li>\n<li>오직 시간 선택기</li>\n<li>날짜 - 범위 선택기</li>\n</ul>\n<p>이전에는 이 모든 것이 있었지만 범위 기능만 빠졌었어요. 그래서 논리를 간단한 말로 적어보기 시작했어요:</p>\n<h1>논리</h1>\n<div class=\"content-ad\"></div>\n<p>범위=false인 경우에 대한 두 가지 다른 출력이 필요합니다. 하나는 단일 선택이고 두 번째는 선택된 범위 배열이며 selectedRange[0]는 시작 선택이되고 selectedRange[1]는 끝 선택이됩니다.</p>\n<p><img src=\"/assets/img/2024-06-27-CreatingaCustomDatesRangePickerinAngular_1.png\" alt=\"Creating a Custom Dates Range Picker in Angular\"></p>\n<p>그런 다음 범위를 확인하여 시각적으로 선택을 표시할 수 있도록해야합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">inRangeSelection</span>(<span class=\"hljs-params\">i: number</span>) {\n  <span class=\"hljs-keyword\">const</span> currentDay = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">date</span>.<span class=\"hljs-title function_\">getFullYear</span>(),\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">date</span>.<span class=\"hljs-title function_\">getMonth</span>(),\n    i\n  );\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">range</span> &#x26;&#x26;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span> &#x26;&#x26;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span> &#x26;&#x26;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span>.<span class=\"hljs-title function_\">getDate</span>() &#x3C; currentDay.<span class=\"hljs-title function_\">getDate</span>() &#x26;&#x26;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span>.<span class=\"hljs-title function_\">getDate</span>() > currentDay.<span class=\"hljs-title function_\">getDate</span>() &#x26;&#x26;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span>.<span class=\"hljs-title function_\">getFullYear</span>() >= currentDay.<span class=\"hljs-title function_\">getFullYear</span>() &#x26;&#x26;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span>.<span class=\"hljs-title function_\">getFullYear</span>() >= currentDay.<span class=\"hljs-title function_\">getFullYear</span>() &#x26;&#x26;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span>.<span class=\"hljs-title function_\">getMonth</span>() >= currentDay.<span class=\"hljs-title function_\">getMonth</span>() &#x26;&#x26;\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span>.<span class=\"hljs-title function_\">getMonth</span>() >= currentDay.<span class=\"hljs-title function_\">getMonth</span>()\n  );\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">  <span class=\"hljs-title function_\">setDate</span>(<span class=\"hljs-params\">index: number</span>) {\n    <span class=\"hljs-comment\">// 만약 범위 선택이 요청된 경우</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">range</span>) {\n      <span class=\"hljs-comment\">// 순서가 매우 중요합니다 -> 이미 범위가 있는 경우 새로운 선택을 클릭하면 다시 처음부터 시작합니다</span>\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span> &#x26;&#x26; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span>) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span> = <span class=\"hljs-literal\">null</span>;\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span> = <span class=\"hljs-literal\">null</span>;\n      }\n\n      <span class=\"hljs-comment\">// 이미 첫 번째 선택이 있는 경우 값을 clickedToDate에 할당합니다</span>\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span> &#x26;&#x26; !<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span>) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">date</span>.<span class=\"hljs-title function_\">getFullYear</span>(),\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">date</span>.<span class=\"hljs-title function_\">getMonth</span>(),\n          index\n        );\n      }\n\n      <span class=\"hljs-comment\">// 여기서만 첫 번째 및 가장 중요한 시작점 설정이 가능합니다</span>\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span> &#x26;&#x26; !<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span>) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">date</span>.<span class=\"hljs-title function_\">getFullYear</span>(),\n          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">date</span>.<span class=\"hljs-title function_\">getMonth</span>(),\n          index\n        );\n      }\n\n      <span class=\"hljs-comment\">// clickedToDate가 clickedDate보다 낮은 경우 뒤집습니다</span>\n      <span class=\"hljs-keyword\">if</span> (\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span> &#x26;&#x26;\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span> &#x26;&#x26;\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span> > <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span>\n      ) {\n        <span class=\"hljs-keyword\">const</span> clickedToDate = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span>;\n        <span class=\"hljs-keyword\">const</span> clickedDate = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span>;\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span> = clickedDate;\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span> = clickedToDate;\n      }\n    <span class=\"hljs-comment\">// 일반 모드에서</span>\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">date</span>.<span class=\"hljs-title function_\">getFullYear</span>(),\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">date</span>.<span class=\"hljs-title function_\">getMonth</span>(),\n        index\n      );\n    }\n  }\n</code></pre>\n<p>마지막으로 출력 메서드가 변경되었습니다:</p>\n<pre><code class=\"hljs language-js\">  <span class=\"hljs-title function_\">confirm</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">range</span>) {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span> &#x26;&#x26; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span>) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">selectRange</span>.<span class=\"hljs-title function_\">emit</span>([<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedToDate</span>]);\n      }\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span>) {\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span>.<span class=\"hljs-title function_\">setHours</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">timeForm</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'hours'</span>)?.<span class=\"hljs-property\">value</span> || <span class=\"hljs-number\">0</span>);\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span>.<span class=\"hljs-title function_\">setMinutes</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">timeForm</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'minutes'</span>)?.<span class=\"hljs-property\">value</span> || <span class=\"hljs-number\">0</span>);\n        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">selectDate</span>.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clickedDate</span>);\n      }\n    }\n  }\n</code></pre>\n<h2>모든 로직을 컴포넌트 내부에 놓게 된 이유는 무엇인가요?</h2>\n<div class=\"content-ad\"></div>\n<p>만약 저장소에서 전체 컴포넌트를 확인했다면: <a href=\"https://github.com/marekpanti/dateTimePicker/blob/master/projects/marekpanti/angular-date-time-picker/src/lib/angular-date-time-picker.component.ts\" rel=\"nofollow\" target=\"_blank\">https://github.com/marekpanti/dateTimePicker/blob/master/projects/marekpanti/angular-date-time-picker/src/lib/angular-date-time-picker.component.ts</a> 아마도 궁금할 것입니다. 왜 Marek는 패서드와 깔끔한 컴포넌트에 대해 언급했을 때 모든 로직을 컴포넌트 내부에 넣는 건지요.</p>\n<p>룰에는 예외가 없는 법입니다. 복잡한 컴포넌트와 UI 컴포넌트의 경우, 나는 내 로직이 한 곳에 있기를 원합니다. 내 컴포넌트가 시각적이며 각 속성이 각 메소드와 연결되어 있음을 이해하기 때문에, 서비스를 분리하여 메소드를 읽는 것이 오히려 더 어려울 것입니다.</p>\n<h1>결론</h1>\n<p>이 글은 처음에 복잡해 보이지만 적절한 계획과 문제 이해로 자신만의 컴포넌트를 쉽게 만들 수 있는 방법을 잘 정리한 요약입니다.</p>\n<div class=\"content-ad\"></div>\n<h1>Stackademic 🎓</h1>\n<p>끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:</p>\n<ul>\n<li>작가를 칭찬하고 팔로우해 주시면 감사하겠습니다! 👏</li>\n<li>다음 채널을 구독해 주세요: X | LinkedIn | YouTube | Discord</li>\n<li>다른 플랫폼도 방문해 보세요: In Plain English | CoFeed | Differ</li>\n<li>더 많은 컨텐츠는 Stackademic.com에서 확인할 수 있습니다.</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}