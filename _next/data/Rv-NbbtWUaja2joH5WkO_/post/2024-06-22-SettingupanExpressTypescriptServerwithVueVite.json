{"pageProps":{"post":{"title":"Express  Typescript 서버에서 Vue  Vite 설정하는 방법","description":"","date":"2024-06-22 03:22","slug":"2024-06-22-SettingupanExpressTypescriptServerwithVueVite","content":"\n\n\n\n![Setting up an Express TypeScript Server with Vue Vite](/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png)\n\n백엔드 개발에 뛰어들기는, 특히 프론트엔드 개발자로써는 미지의 영역에 발을 딛는 것처럼 느껴질 수 있어요. \"프론트엔드 걸리\"를 자처하는 나로서는 솔직히 말하면, 백엔드 개발에 뛰어들기 전에 조심스럽게 느껴졌어요. 그러나 프로젝트의 일부 클라이언트 측 로직을 백엔드로 옮긴 후에야, 서버 측 작업이 상상했던 것만큼 무섭지 않다는 것을 깨달았어요.\n\n백엔드 개발에 대해 제가 느낀 불안을 공감한다면, 여기에 잘 왔어요. 이 블로그에서는 Express 서버를 TypeScript와 통합하는 방법을 안내할 거예요.\n\n초보자를 위한 이 포괄적인 가이드는 다음을 중점적으로 다룰 거예요:\n\n\n<div class=\"content-ad\"></div>\n\n- TypeScript로 Express 서버 설정하기\n- 클라이언트와 서버 간 통신 설정하기\n- Vite를 사용하여 요청 프록시 설정하기\n\n이제 프론트엔드와 백엔드 간의 간극을 좁히러 뛰어들어봅시다! 🚀\n\n# 시작하기\n\n이 튜토리얼의 전체 소스 코드에 액세스하려면 여기에 있는 GitHub 리포지토리를 방문해주세요. 서버 및 클라이언트 환경 변수를 추가하는 것을 잊지 마세요. 클론하거나 포크하거나 리포지토리를 별표로 표시하여 차후 참고 및 실험에 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 컴퓨터에 Node.js가 설치되어 있는지 확인해주세요. 터미널에서 명령어 node -v를 실행하여 Node.js가 설치되어 있는지 확인할 수 있습니다. 설치되어 있다면 설치된 버전이 표시됩니다. 그렇지 않다면 여기를 클릭하여 Node.js를 설치할 수 있습니다.\n\n## 서버 설정하기\n\n백엔드를 설정하는 첫 번째 단계는 적절한 기술 스택을 선택하는 것입니다. Express.js를 사용할 것이며, 이는 간결함과 유연성으로 유명한 Node.js 프레임워크입니다. 추가로 TypeScript를 활용하여 서버 측 코드베이스에 정적 타이핑을 도입할 것입니다.\n\n## 프로젝트 초기화\n\n<div class=\"content-ad\"></div>\n\n우리는 새 디렉토리를 만들고 npm을 사용하여 새 Node.js 프로젝트를 초기화할 것입니다. 초기화된 후 Express 및 TypeScript를 포함한 필수 종속성을 설치하기 위해 각각의 명령을 실행할 것입니다.\n\n- 새 디렉토리 만들기\n\n우리는 스타터 프로젝트를 위한 새 디렉토리를 만들어 시작할 것입니다. 이를 위해 당신의 운영 체제의 터미널 또는 파일 탐색기를 사용할 수 있습니다.\n\n```js\nmkdir express-starter\n```\n\n<div class=\"content-ad\"></div>\n\n2. 프로젝트 디렉토리로 이동해주세요.\n\n디렉토리가 생성되면 cd 명령어를 사용하여 해당 디렉토리로 이동해주세요.\n\n```js\ncd express-starter\n```\n\n3. 서버 및 클라이언트 폴더를 생성하세요.\n\n<div class=\"content-ad\"></div>\n\nexpress-starter 디렉토리에 들어간 후, 두 개의 폴더를 만들어주세요: client와 server 폴더를 만들어주세요. 그런 다음 server 폴더로 이동해주세요.\n\n```js\nmkdir server client cd server\n```\n\n4. 새로운 Node.js 프로젝트 초기화하기.\n\nnpm init을 사용하여 새로운 Node.js 프로젝트를 초기화하세요. 이렇게 하면 package.json 파일이 생성되며, 프로젝트와 의존성에 대한 메타데이터가 저장됩니다. 프롬프트를 따르거나 -y 플래그를 사용하여 모든 프롬프트에 대한 기본값을 수락할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nnpm init -y\n```\n\n5. 의존성 설치하기.\n\n이제, 프로젝트에 필요한 의존성을 설치해보겠습니다.\n\n```js\n# dependencies \nnpm install express cors dotenv  \n\n# development dependencies \nnpm install -D typescript @types/cors @types/node @types/express nodemon\n```\n\n<div class=\"content-ad\"></div>\n\n각 종속성이 무엇을 하는지 간단히 살펴봅시다.\n\n- express: 우리가 서버를 구축하기 위해 사용할 Node.js의 웹 프레임워크입니다.\n- typescript: TypeScript 컴파일러 및 언어입니다. 프로젝트를 타입 안전하게 유지하고 런타임 이전에 버그를 잡을 수 있게 합니다.\n- cors: Cross-Origin Resource Sharing은 교차 출처 요청을 허용하여 백엔드 API가 다른 포트에서 실행되더라도 클라이언트에서 안전하게 액세스할 수 있도록 합니다.\n- dotenv: .env 파일에서 환경 변수를로드합니다.\n- nodemon: Nodemon은 변경 사항을 감지하면 자동으로 노드 응용 프로그램을 다시 시작합니다. 이는 변경 사항이 적용되기 위해 응용 프로그램을 중지하고 다시 시작할 필요가 없다는 것을 의미합니다.\n- @types/node, @types/cors 및 @types/express: Node.js, Cors 및 Express에 대한 유형 정의로 TypeScript 지원을 활성화합니다.\n\n의존성 대 개발 의존성\n\n-D 플래그를 사용하여 설치 중에 일부 dev 종속성을 추가했지만, 왜 필요했을까요? 개발 의존성은 개발 중에만 필요한 모듈로, 종속성은 런타임에서 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n의존성\n\n의존성은 우리 애플리케이션이 올바르게 작동하기 위해 필요한 필수 패키지입니다. npm install을 실행하면 이러한 패키지가 설치됩니다. 이러한 패키지는 package.json 파일의 의존성 섹션에 나열됩니다. 이러한 패키지 없이 배포된 앱은 작동하지 않을 수 있습니다.\n\n개발 의존성\n\n반면에 개발 의존성은 개발 및 테스트 목적에만 필요합니다. 이러한 패키지는 앱이 정상적으로 실행되기 위해 반드시 필요한 것은 아니지만, 빌드, 테스트 및 코드 린팅과 같은 작업에 중요합니다. 이러한 패키지들은 package.json의 devDependencies 섹션에 명시됩니다.\n\n<div class=\"content-ad\"></div>\n\n6. tsconfig.json 생성하기\n\nTypeScript를 구성하기 위해 tsconfig.json 파일을 생성하세요. 이 파일은 TypeScript가 코드를 컴파일하는 방법을 지정합니다. npx tsconfig.json을 실행한 후 Node를 선택하세요. 이 명령은 일부 기본 설정이 포함된 tsconfig.json 파일을 생성합니다.\n\n```sh\nnpx tsconfig.json\n```\n\n7. 소스 파일 생성 및 package.json 업데이트하기\n\n<div class=\"content-ad\"></div>\n\n다음으로, src 디렉토리를 생성하세요. src 디렉토리 안에 우리의 주 파일인 main.ts를 만들 것입니다.\n\n```js\n# src 폴더 생성\nmkdir src\n\n# 폴더로 이동\ncd src\n\n# .ts 파일 생성\ntouch main.ts\n\n# src에서 나와서 서버 디렉토리로 돌아갑니다\ncd ..\n```\n\npackage.json에서 엔트리 포인트를 index.js 대신 main.js로 수정하세요.\n\n```js\n\"main\": \"main.js\",\n```\n\n<div class=\"content-ad\"></div>\n\n8. .env 파일을 생성하세요.\n\n환경 변수를 구성하기 위해 .env 파일을 만듭니다 (예: API 키). 이 파일은 민감한 정보가 노출되지 않도록 버전 관리에서 제외되어야 합니다. 서버 폴더의 루트에 .env 파일을 생성하세요.\n\n```js\ntouch .env\n```\n\n9. .gitignore 파일을 생성하세요.\n\n<div class=\"content-ad\"></div>\n\n.gitignore 파일을 만들어서 버전 관리에서 무시해야 할 파일과 디렉토리를 지정하여 불필요한 파일을 커밋하는 것을 피해야 합니다. 서버 폴더의 루트에 .gitignore 파일을 생성하세요. 우선 node_modules와 .env*를 추가하겠습니다. *는 Git에게 .env로 시작하는 모든 파일이나 폴더를 무시하도록 지시합니다.\n\n```js\n.env* \nnode_modules/\n```\n\n이 시점에서 프로젝트 구조는 다음과 같을 수 있습니다:\n\n```js\nexpress-starter/\n├── client/\n└── server/\n    ├── node_modules/\n  └── src/\n        └── main.ts\n  ├── .env\n  ├── .gitignore\n    ├── package.json\n    ├── tsconfig.json\n```\n\n<div class=\"content-ad\"></div>\n\n기본 설정을 마쳤으니 이제 서버를 생성해봅시다.\n\n# 서버 생성\n\nsrc/main.ts 파일 안에 다음 스니펫을 추가하세요.\n\n```js\n// server/src/main.ts\n\nimport cors from 'cors';\nimport 'dotenv/config';\nimport express from 'express';\n\nconst app = express();\n\napp.use(cors());\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\nconst PORT = process.env.PORT || 3001;\n\napp.get('/api', (_req, res) => {\n  res.status(200).json({ message: '서버에서 안녕하세요!' });\n});\n\napp.listen(PORT, () => {\n  console.log(`서버가 포트 ${PORT}에서 실행 중입니다.`);\n});\n```\n\n<div class=\"content-ad\"></div>\n\n이것은 기본 express 서버입니다. 이 앱은 서버를 시작하고 지정된 포트에서 연결을 수신 대기합니다. /api 경로에 대한 요청에 대해 \"서버에서 안녕하세요!\"라고 응답합니다. 코드가 무엇을 하는지 이해해 봅시다.\n\n- 미들웨어 설정\n\napp.use()는 미들웨어를 등록하는 방법입니다. 미들웨어는 서버가 특정 요청을 처리하기 전에 실행하는 특별한 함수들입니다. 미들웨어는 서버가 요청을 수신하고 클라이언트에게 응답을 보내는 순간 사이에서 작동합니다.\n\n우리의 경우, 몇 가지 전역 미들웨어를 등록했습니다:\n\n<div class=\"content-ad\"></div>\n\n- cors: 이 미들웨어는 서버가 서로 다른 소스/출처에서 오는 요청을 수락할 수 있도록 합니다.\n- express.json(): 들어오는 요청을 JSON 형식으로 파싱합니다.\n- express.urlencoded('extended: true'): 요청에서 폼 데이터를 파싱합니다.\n\n2. 라우트 설정\n\napp.get(`/api`)은 특히 /api URL로의 GET 요청에 대한 라우트 핸들러를 설정합니다. 이 라우트로 GET 요청이 올 경우, 서버는 상태 코드 200과 \"서버에서 인사합니다!\" 메시지로 응답합니다.\n\n3. 서버 초기화\n\n<div class=\"content-ad\"></div>\n\napp.listen()은 지정된 포트(PORT)에서 Express 앱을 수신하여 시작합니다. 환경 변수에 포트가 지정되지 않은 경우 기본값은 포트 3001입니다.\n\n이 설정으로 서버를 실행하는 한 걸음 더 나아갈 수 있습니다.\n\n# TypeScript로 Nodemon 구성하기\n\nmain.ts를 실행하려면 서버 디렉토리 내에서 node src/main.ts를 실행할 수 있지만, \".ts\" 라는 알 수 없는 파일 확장자 오류가 발생합니다.\n\n<div class=\"content-ad\"></div>\n\nNode와 TypeScript\n\n`node src/main.ts`를 실행할 때 Node.js가 TypeScript 파일을 직접 실행할 것으로 기대할 수 있습니다. 그러나 Node.js는 TypeScript를 네이티브로 이해하지 않습니다. JavaScript만을 이해합니다.\n\nTypeScript는 JavaScript의 확장이므로 TypeScript 코드는 Node.js에서 실행되기 전에 JavaScript로 컴파일되어야 합니다. 이 컴파일 과정은 .ts 파일을 Node가 이해할 수 있는 동등한 .js 파일로 변환합니다.\n\n서버 코드를 실행하려면 먼저 TypeScript 컴파일러(tsc)를 사용하여 TypeScript 코드를 JavaScript로 변환해야 합니다. 이를 통해 컴파일된 JavaScript 코드가 포함된 dist/main.js 파일이 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 모든 TypeScript 파일을 JavaScript로 컴파일\nnpx tsc\n\n# 생성된 JavaScript 파일 실행\nnode dist/main.js\n```\n\n위의 명령어에서 npx tsc는 TypeScript 컴파일러(tsc)를 호출하여 프로젝트의 모든 TypeScript 파일을 JavaScript로 컴파일합니다. 그 결과로 생성된 JavaScript 파일은 dist 디렉토리에 출력됩니다. 생성된 JavaScript 파일은 Node.js를 사용하여 실행할 수 있습니다.\n\n컴파일된 JavaScript 파일의 출력 디렉토리는 tsconfig.json 파일의 outDir 속성을 사용하여 지정됩니다.\n\n```js\n// server/tsconfig.json\n\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\"\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n마지막으로, dist 폴더를 .gitignore 파일에 포함시켜야합니다. 이렇게 하면 컴파일된 JavaScript 파일이 버전 관리에 포함되지 않습니다.\n\n```js\n// server/.gitignore\n\nnode_modules\ndist\n.env*\n```\n\nNodemon을 사용하여 변경 사항 감지\n\nTypeScript 파일을 수정할 때마다 npx tsc 및 node dist/main.js를 사용하여 파일을 수동으로 다시 컴파일하고 실행해야합니다. 이러한 반복 작업은 빠르게 지루해질 수 있습니다. 이 과정을 간소화하기 위해 nodemon이라는 도구를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nNodemon은 디렉토리 내 파일 변경을 감지하여 Node.js 기반 애플리케이션을 자동으로 다시 시작하는 도구입니다. 이를 이용하면 코드를 수정할 때마다 서버를 수동으로 중지하고 다시 시작하는 수고를 덜 수 있습니다.\n\nNodemon은 이미 설치했으므로 이제 구성만 남았습니다.\n\nNodemon 구성하기\n\nNodemon을 구성하려면 package.json에 nodemonConfig를 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```json\n// server/package.json\n\n\"scripts\": {\n    \"dev\": \"nodemon\"\n  },\n  \"nodemonConfig\": {\n    \"watch\": [\n      \"src\"\n    ],\n    \"exec\": \"tsc && node ./dist/main.js\",\n    \"ext\": \"ts,js,json\"\n  },\n```\n\nnodemonConfig 섹션은 파일 변경을 모니터링할 때 nodemon이 어떻게 동작해야 하는지 알려줍니다:\n\n- watch: nodemon에게 src 폴더 내의 변경 사항을 모니터링하도록 지시합니다.\n- ext: 변경 사항을 모니터링할 파일 확장자를 지정합니다 (ts, js, json).\n- exec: 변경 사항이 감지되었을 때 실행할 명령을 정의합니다. 이 경우 TypeScript 파일을 컴파일하고 node ./dist/main.js를 실행하여 서버를 시작합니다.\n\n이제 npm run dev를 실행하여 간단히 nodemon과 함께 서버를 시작할 수 있습니다. 파일 변경 사항을 모니터링하고 서버를 자동으로 다시 시작하는 프로세스가 자동화됩니다. 이 변경 사항으로 서버는 요청을 받을 준비가 되었습니다. Postman과 같은 API 플랫폼이 있다면 http://localhost:3001/api에 GET 요청을 보내보거나 브라우저에서 링크를 방문하여 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 클라이언트 설정\n\n저희 서버는 클라이언트로부터의 요청을 받을 준비가 되어 있습니다. 프론트엔드에서는 Vue를 사용할 것입니다. Vue는 Vite를 기반으로 한 빌드 설정을 사용하며, 이를 우리 서버와 통신하도록 구성할 것입니다. 시작해봅시다.\n\n- 클라이언트 디렉토리로 이동하기\n\n먼저 서버 디렉토리를 중지하고 종료한 후, 클라이언트로 이동해보겠습니다. 서버가 실행 중인 터미널에서 ^ + C (control + C)를 눌러 중지한 다음, 다음 명령어를 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 서버 디렉토리를 나와 클라이언트로 이동 \ncd ../client\n```\n\n2. Vue 프로젝트 생성\n\nVue 앱을 만들려면 다음 명령을 실행하세요. 이 명령은 . .에 의해 지정된 클라이언트 폴더에 직접 프로젝트를 생성합니다.\n\n```js\nnpm create vue@latest .\n```\n\n<div class=\"content-ad\"></div>\n\n여러 선택지를 만들어 몇 가지 선택을 해야 할 것입니다. 패키지 이름과 TypeScript 지원에 대해 고민할 차례입니다. 당신의 프로젝트를 위해 express-vue로 이름을 지어주고 TypeScript 지원에 \"예\"를 선택하되, 다른 선택 가능한 기능들에 대해서는 \"아니요\"를 선택하여 프로젝트를 간단하게 유지해주세요.\n\n그 다음, 의존성을 설치하고 개발 서버를 시작해보세요.\n\n```js\n# 의존성 설치\nnpm install\n\n# 개발 서버 시작\nnpm run dev\n```\n\n이제 http://localhost:5173/에서 Vue 프로젝트가 실행 중일 것입니다.\n\n<div class=\"content-ad\"></div>\n\n3. .env 파일 추가\n\n다음 변수를 사용하여 클라이언트 폴더의 루트에 .env 파일을 추가하십시오.\n\n```js\nVITE_SERVER_URL=http://localhost:3001\nVITE_SERVER_API_PATH=/api\n```\n\n.env 파일을 변경하면 서버를 다시 시작해야 할 수도 있습니다. 서버를 중지하려면 서버가 실행 중인 터미널에서 ^ + C (control + C)를 눌러주세요. 그런 다음 서버를 다시 시작하려면 npm run dev를 다시 실행해주세요.\n\n<div class=\"content-ad\"></div>\n\n4. vite.config.ts 파일 업데이트\n\n우리는 vite.config.ts 파일을 사용하여 클라이언트와 서버 간의 통신을 활성화하기 위해 파일을 사용자 정의하고 싶어요. defineConfig은 Vite 프로젝트에서 구성 옵션을 정의하는 데 사용되는 도우미 함수입니다. defineConfig은 객체나 함수 둘 중 하나를 인수로 받을 수 있어요. 환경 변수를 로드할 수 있도록 함수를 전달할 거에요.\n\n```js\nimport { fileURLToPath, URL } from 'node:url';\n\nimport vue from '@vitejs/plugin-vue';\nimport { defineConfig, loadEnv } from 'vite';\n\n// <https://vitejs.dev/config/>\nexport default defineConfig((env) => {\n  const envars = loadEnv(env.mode, './');\n\n  const serverURL = new URL(\n    envars.VITE_SERVER_URL ?? '<http://localhost:3001>'\n  );\n  const serverAPIPath = envars.VITE_SERVER_API_PATH ?? '/api';\n\n  return {\n    envDir: './',\n\n    // 클라이언트에서 API 경로를 전역적으로 사용할 수 있도록 함\n    define: {\n      __API_PATH__: JSON.stringify(serverAPIPath),\n    },\n\n    plugins: [vue()],\n    resolve: {\n      alias: {\n        '@': fileURLToPath(new URL('./src', import.meta.url)),\n      },\n    },\n\n    server: {\n      port: 5173,\n      proxy: {\n        // API 경로를 가진 요청을 서버로 프록시함\n        // <http://localhost:5173/api> -> <http://localhost:3001/api>\n        [serverAPIPath]: serverURL.origin,\n      },\n    },\n  };\n});\n```\n\n이 설정의 각 부분이 어떤 역할을 하는지 살펴보도록 하죠.\n\n<div class=\"content-ad\"></div>\n\n- 환경 변수 로딩: loadEnv 함수를 사용하여 현재 모드(예: 개발, 프로덕션)에 기반하여 환경 변수를 로드합니다. 프로젝트 디렉토리에 있는 .env 파일을 읽고 변수를 envars 객체에 로드합니다.\n- 서버 URL 및 API 경로 구문 분석: 서버 URL 및 API 경로가 구문 분석되며, .env 파일에서 찾지 못한 경우 기본값이 제공됩니다.\n\n구성 옵션:\n\n- envDir: 환경 변수가 위치한 디렉토리를 지정합니다.\n- define: 빌드 과정 중에 대체될 전역 상수를 정의할 수 있습니다. 이 경우 __API_PATH__는 서버 API 경로 값으로 정의됩니다.\n- plugins: 프로젝트에서 사용하는 Vite 플러그인을 지정합니다. 여기서 Vue.js 플러그인(vue())이 추가됩니다.\n- resolve.alias: 모듈 해상도를 위한 별칭을 정의합니다. 이 경우 @ 별칭이 src 디렉토리로 설정됩니다.\n\n서버 구성:\n\n<div class=\"content-ad\"></div>\n\n- server.port: Vite 개발 서버가 실행될 포트를 지정합니다. 여기서는 5173으로 설정되어 있어요.\n- server.proxy: 프록시 설정은 클라이언트와 서버 간 통신을 가능하게 합니다. API 경로와 일치하는 요청은 서버 URL로 전달됩니다. http://localhost:5173/api로 요청을 보내면 http://localhost:3001/api로 우리 서버로 전달됩니다.\n\n5. 전역 상수 선언\n\nvite.config.ts 파일에 전역 상수를 추가한 후, TypeScript가 이 상수를 인식하여 타입 확인을 수행하게 만들어야 합니다. env.d.ts 파일에 타입 정의를 선언하여 이를 달성할 수 있어요.\n\n```js\n// client/env.d.ts  \n\n/// <reference types=\"vite/client\" /> \ndeclare const __API_PATH__: string;\n```  \n\n<div class=\"content-ad\"></div>\n\n이 선언에서는 TypeScript에 __API_PATH__ 상수의 존재를 알리고, 해당 타입을 문자열로 지정합니다. 이는 TypeScript가 프로젝트 전체에서 이 글로벌 상수에 대한 유형 확인 및 IntelliSense 지원을 제공하도록 보장합니다.\n\n6. 서버에 요청 보내기\n\n이제 Vite 프로젝트를 서버와 통신하도록 구성했으므로 App.vue 파일을 업데이트하여 서버로부터 요청을 보내고 응답을 화면에 표시해 보겠습니다. 다음 스니펫은 Vue.js composition API를 사용하여 서버에서 데이터를 가져와 앱에 표시하는 방법을 보여줍니다.\n\n```js\n// client/src/App.vue\n\n<script setup lang=\"ts\">\nimport { ref } from \"vue\";\n\n// API 기본 URL을 포함하는 전역 상수 -> /api\nconst baseURL = __API_PATH__;\n\n// 로딩 상태 및 응답 메시지 관리를 위한 반응형 변수\nconst isLoading = ref(false);\nconst message = ref(\"\");\n\n// 서버에서 데이터를 가져오는 함수\nasync function fetchAPI() {\n  try {\n    // 로딩 상태를 true로 설정\n    isLoading.value = true;\n\n    // 서버에 GET 요청 보내기\n    const response = await fetch(baseURL);\n\n    // JSON 응답 해석\n    const data = await response.json();\n\n    // 응답 데이터로 메시지 업데이트\n    message.value = data.message;\n  } catch (error) {\n    // 오류 처리\n    message.value = \"데이터 검색 오류\";\n    console.error(error);\n  } finally {\n    // 로딩 상태 재설정\n    isLoading.value = false;\n  }\n}\n</script>\n\n<template>\n  <!-- fetchAPI 함수를 실행하는 버튼 -->\n  <button @click=\"fetchAPI\">가져오기</button>\n\n  <!-- 데이터를 가져올 때 로딩 메시지 표시 -->\n  <p v-if=\"isLoading\">로딩 중...</p>\n\n  <!-- 사용 가능한 경우 응답 메시지 표시 -->\n  <p v-else-if=\"message\">{ message }</p>\n</template>\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드 스니펫에서:\n\n- 우리는 Vue의 composition API에서 ref 함수를 가져와 반응형 변수를 생성하여 로딩 상태(isLoading)와 응답 메시지(message)를 관리합니다.\n- fetchAPI 함수는 fetch API를 사용해 서버로 GET 요청을 보내는 데 정의됩니다.\n- 요청이 처리되는 동안 로딩 상태가 true로 설정되고 로딩 메시지가 표시됩니다.\n- 요청이 완료되면 로딩 상태가 재설정되고 서버로부터의 응답 메시지가 표시됩니다.\n- 요청 중에 발생하는 모든 오류는 catch되어 메시지가 업데이트됩니다.\n\n이러한 업데이트로 인해, Vue 애플리케이션은 서버에서 데이터를 가져와 사용자에게 표시할 수 있습니다.\n\n7. 두 서버를 시작하세요.\n\n<div class=\"content-ad\"></div>\n\n이미 클라이언트가 실행 중이므로 서버를 시작해야 합니다. VS Code를 사용 중이라면, 메뉴 바에서 Terminal 옵션을 마우스 오른쪽 클릭하고 New Terminal을 선택하여 새 터미널을 열 수 있습니다. 또는 새 터미널 창을 열어 프로젝트 디렉토리로 이동할 수도 있어요. 프로젝트 디렉토리에 들어간 후 아래 명령어를 실행하여 서버를 시작하세요:\n\n```js\ncd server\nnpm run dev\n```\n\n위의 명령어를 실행하면 서버 디렉토리로 이동한 후 개발 모드에서 서버가 시작됩니다.\n\n8. 클라이언트 측 요청 초기화.\n\n<div class=\"content-ad\"></div>\n\n클라이언트에서 App.vue에서 버튼을 클릭하여 요청을 트리거하는 것이 마지막 단계입니다. 이렇게 하면 서버로 요청이 전송됩니다.\n\n# 결론\n\n축하합니다! 🎉 Express.js 및 TypeScript를 사용하여 백엔드에 Vue.js 및 Vite를 사용하는 풀스택 웹 개발 환경을 구축하는 방법을 성공적으로 배우셨습니다.\n\n이 가이드에서 다룬 내용은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 백엔드 설정: TypeScript로 Express.js 서버를 초기화하고 미들웨어를 구성하며 노드.js에서 실행할 수 있도록 코드를 컴파일하는 것부터 시작했습니다.\n- 프론트엔드 구성: 다음으로, 클라이언트와 서버 간의 통신을 허용하도록 Vite를 구성했습니다. 특정 요청을 서버로 프록시하기 위해 Vite의 서버 옵션을 활용했습니다.\n- 클라이언트-서버 통신: 환경을 설정한 후, Vue.js composition API를 사용하여 프론트엔드에서 백엔드로 요청을 보내는 방법을 배웠습니다. 서버에서 데이터를 가져와 UI를 업데이트하여 반응형 웹 애플리케이션을 만들었습니다.\n\n서버 측 로직 작업에 대한 걱정이 줄어들었기를 바라며, 동적 웹 애플리케이션을 구축하는 기초를 마련했으니 실험을 계속해보고, 계속해서 개발하고, 풀스택 부분에 더 깊이 파고들기를 주저하지 마십시오.\n\n즐거운 코딩!\n\n![이미지](/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_1.png)","ogImage":{"url":"/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png"},"coverImage":"/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png","tag":["Tech"],"readingTime":15},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_0.png\" alt=\"Setting up an Express TypeScript Server with Vue Vite\"></p>\n<p>백엔드 개발에 뛰어들기는, 특히 프론트엔드 개발자로써는 미지의 영역에 발을 딛는 것처럼 느껴질 수 있어요. \"프론트엔드 걸리\"를 자처하는 나로서는 솔직히 말하면, 백엔드 개발에 뛰어들기 전에 조심스럽게 느껴졌어요. 그러나 프로젝트의 일부 클라이언트 측 로직을 백엔드로 옮긴 후에야, 서버 측 작업이 상상했던 것만큼 무섭지 않다는 것을 깨달았어요.</p>\n<p>백엔드 개발에 대해 제가 느낀 불안을 공감한다면, 여기에 잘 왔어요. 이 블로그에서는 Express 서버를 TypeScript와 통합하는 방법을 안내할 거예요.</p>\n<p>초보자를 위한 이 포괄적인 가이드는 다음을 중점적으로 다룰 거예요:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>TypeScript로 Express 서버 설정하기</li>\n<li>클라이언트와 서버 간 통신 설정하기</li>\n<li>Vite를 사용하여 요청 프록시 설정하기</li>\n</ul>\n<p>이제 프론트엔드와 백엔드 간의 간극을 좁히러 뛰어들어봅시다! 🚀</p>\n<h1>시작하기</h1>\n<p>이 튜토리얼의 전체 소스 코드에 액세스하려면 여기에 있는 GitHub 리포지토리를 방문해주세요. 서버 및 클라이언트 환경 변수를 추가하는 것을 잊지 마세요. 클론하거나 포크하거나 리포지토리를 별표로 표시하여 차후 참고 및 실험에 사용하세요.</p>\n<div class=\"content-ad\"></div>\n<p>시작하기 전에 컴퓨터에 Node.js가 설치되어 있는지 확인해주세요. 터미널에서 명령어 node -v를 실행하여 Node.js가 설치되어 있는지 확인할 수 있습니다. 설치되어 있다면 설치된 버전이 표시됩니다. 그렇지 않다면 여기를 클릭하여 Node.js를 설치할 수 있습니다.</p>\n<h2>서버 설정하기</h2>\n<p>백엔드를 설정하는 첫 번째 단계는 적절한 기술 스택을 선택하는 것입니다. Express.js를 사용할 것이며, 이는 간결함과 유연성으로 유명한 Node.js 프레임워크입니다. 추가로 TypeScript를 활용하여 서버 측 코드베이스에 정적 타이핑을 도입할 것입니다.</p>\n<h2>프로젝트 초기화</h2>\n<div class=\"content-ad\"></div>\n<p>우리는 새 디렉토리를 만들고 npm을 사용하여 새 Node.js 프로젝트를 초기화할 것입니다. 초기화된 후 Express 및 TypeScript를 포함한 필수 종속성을 설치하기 위해 각각의 명령을 실행할 것입니다.</p>\n<ul>\n<li>새 디렉토리 만들기</li>\n</ul>\n<p>우리는 스타터 프로젝트를 위한 새 디렉토리를 만들어 시작할 것입니다. 이를 위해 당신의 운영 체제의 터미널 또는 파일 탐색기를 사용할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">mkdir express-starter\n</code></pre>\n<div class=\"content-ad\"></div>\n<ol start=\"2\">\n<li>프로젝트 디렉토리로 이동해주세요.</li>\n</ol>\n<p>디렉토리가 생성되면 cd 명령어를 사용하여 해당 디렉토리로 이동해주세요.</p>\n<pre><code class=\"hljs language-js\">cd express-starter\n</code></pre>\n<ol start=\"3\">\n<li>서버 및 클라이언트 폴더를 생성하세요.</li>\n</ol>\n<div class=\"content-ad\"></div>\n<p>express-starter 디렉토리에 들어간 후, 두 개의 폴더를 만들어주세요: client와 server 폴더를 만들어주세요. 그런 다음 server 폴더로 이동해주세요.</p>\n<pre><code class=\"hljs language-js\">mkdir server client cd server\n</code></pre>\n<ol start=\"4\">\n<li>새로운 Node.js 프로젝트 초기화하기.</li>\n</ol>\n<p>npm init을 사용하여 새로운 Node.js 프로젝트를 초기화하세요. 이렇게 하면 package.json 파일이 생성되며, 프로젝트와 의존성에 대한 메타데이터가 저장됩니다. 프롬프트를 따르거나 -y 플래그를 사용하여 모든 프롬프트에 대한 기본값을 수락할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">npm init -y\n</code></pre>\n<ol start=\"5\">\n<li>의존성 설치하기.</li>\n</ol>\n<p>이제, 프로젝트에 필요한 의존성을 설치해보겠습니다.</p>\n<pre><code class=\"hljs language-js\"># dependencies \nnpm install express cors dotenv  \n\n# development dependencies \nnpm install -D typescript @types/cors @types/node @types/express nodemon\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>각 종속성이 무엇을 하는지 간단히 살펴봅시다.</p>\n<ul>\n<li>express: 우리가 서버를 구축하기 위해 사용할 Node.js의 웹 프레임워크입니다.</li>\n<li>typescript: TypeScript 컴파일러 및 언어입니다. 프로젝트를 타입 안전하게 유지하고 런타임 이전에 버그를 잡을 수 있게 합니다.</li>\n<li>cors: Cross-Origin Resource Sharing은 교차 출처 요청을 허용하여 백엔드 API가 다른 포트에서 실행되더라도 클라이언트에서 안전하게 액세스할 수 있도록 합니다.</li>\n<li>dotenv: .env 파일에서 환경 변수를로드합니다.</li>\n<li>nodemon: Nodemon은 변경 사항을 감지하면 자동으로 노드 응용 프로그램을 다시 시작합니다. 이는 변경 사항이 적용되기 위해 응용 프로그램을 중지하고 다시 시작할 필요가 없다는 것을 의미합니다.</li>\n<li>@types/node, @types/cors 및 @types/express: Node.js, Cors 및 Express에 대한 유형 정의로 TypeScript 지원을 활성화합니다.</li>\n</ul>\n<p>의존성 대 개발 의존성</p>\n<p>-D 플래그를 사용하여 설치 중에 일부 dev 종속성을 추가했지만, 왜 필요했을까요? 개발 의존성은 개발 중에만 필요한 모듈로, 종속성은 런타임에서 필요합니다.</p>\n<div class=\"content-ad\"></div>\n<p>의존성</p>\n<p>의존성은 우리 애플리케이션이 올바르게 작동하기 위해 필요한 필수 패키지입니다. npm install을 실행하면 이러한 패키지가 설치됩니다. 이러한 패키지는 package.json 파일의 의존성 섹션에 나열됩니다. 이러한 패키지 없이 배포된 앱은 작동하지 않을 수 있습니다.</p>\n<p>개발 의존성</p>\n<p>반면에 개발 의존성은 개발 및 테스트 목적에만 필요합니다. 이러한 패키지는 앱이 정상적으로 실행되기 위해 반드시 필요한 것은 아니지만, 빌드, 테스트 및 코드 린팅과 같은 작업에 중요합니다. 이러한 패키지들은 package.json의 devDependencies 섹션에 명시됩니다.</p>\n<div class=\"content-ad\"></div>\n<ol start=\"6\">\n<li>tsconfig.json 생성하기</li>\n</ol>\n<p>TypeScript를 구성하기 위해 tsconfig.json 파일을 생성하세요. 이 파일은 TypeScript가 코드를 컴파일하는 방법을 지정합니다. npx tsconfig.json을 실행한 후 Node를 선택하세요. 이 명령은 일부 기본 설정이 포함된 tsconfig.json 파일을 생성합니다.</p>\n<pre><code class=\"hljs language-sh\">npx tsconfig.json\n</code></pre>\n<ol start=\"7\">\n<li>소스 파일 생성 및 package.json 업데이트하기</li>\n</ol>\n<div class=\"content-ad\"></div>\n<p>다음으로, src 디렉토리를 생성하세요. src 디렉토리 안에 우리의 주 파일인 main.ts를 만들 것입니다.</p>\n<pre><code class=\"hljs language-js\"># src 폴더 생성\nmkdir src\n\n# 폴더로 이동\ncd src\n\n# .<span class=\"hljs-property\">ts</span> 파일 생성\ntouch main.<span class=\"hljs-property\">ts</span>\n\n# src에서 나와서 서버 디렉토리로 돌아갑니다\ncd ..\n</code></pre>\n<p>package.json에서 엔트리 포인트를 index.js 대신 main.js로 수정하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">\"main\"</span>: <span class=\"hljs-string\">\"main.js\"</span>,\n</code></pre>\n<div class=\"content-ad\"></div>\n<ol start=\"8\">\n<li>.env 파일을 생성하세요.</li>\n</ol>\n<p>환경 변수를 구성하기 위해 .env 파일을 만듭니다 (예: API 키). 이 파일은 민감한 정보가 노출되지 않도록 버전 관리에서 제외되어야 합니다. 서버 폴더의 루트에 .env 파일을 생성하세요.</p>\n<pre><code class=\"hljs language-js\">touch .<span class=\"hljs-property\">env</span>\n</code></pre>\n<ol start=\"9\">\n<li>.gitignore 파일을 생성하세요.</li>\n</ol>\n<div class=\"content-ad\"></div>\n<p>.gitignore 파일을 만들어서 버전 관리에서 무시해야 할 파일과 디렉토리를 지정하여 불필요한 파일을 커밋하는 것을 피해야 합니다. 서버 폴더의 루트에 .gitignore 파일을 생성하세요. 우선 node_modules와 .env*를 추가하겠습니다. *는 Git에게 .env로 시작하는 모든 파일이나 폴더를 무시하도록 지시합니다.</p>\n<pre><code class=\"hljs language-js\">.<span class=\"hljs-property\">env</span>* \nnode_modules/\n</code></pre>\n<p>이 시점에서 프로젝트 구조는 다음과 같을 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">express-starter/\n├── client/\n└── server/\n    ├── node_modules/\n  └── src/\n        └── main.<span class=\"hljs-property\">ts</span>\n  ├── .<span class=\"hljs-property\">env</span>\n  ├── .<span class=\"hljs-property\">gitignore</span>\n    ├── package.<span class=\"hljs-property\">json</span>\n    ├── tsconfig.<span class=\"hljs-property\">json</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>기본 설정을 마쳤으니 이제 서버를 생성해봅시다.</p>\n<h1>서버 생성</h1>\n<p>src/main.ts 파일 안에 다음 스니펫을 추가하세요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// server/src/main.ts</span>\n\n<span class=\"hljs-keyword\">import</span> cors <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'cors'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'dotenv/config'</span>;\n<span class=\"hljs-keyword\">import</span> express <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'express'</span>;\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-title function_\">express</span>();\n\napp.<span class=\"hljs-title function_\">use</span>(<span class=\"hljs-title function_\">cors</span>());\napp.<span class=\"hljs-title function_\">use</span>(express.<span class=\"hljs-title function_\">json</span>());\napp.<span class=\"hljs-title function_\">use</span>(express.<span class=\"hljs-title function_\">urlencoded</span>({ <span class=\"hljs-attr\">extended</span>: <span class=\"hljs-literal\">true</span> }));\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PORT</span> = process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">PORT</span> || <span class=\"hljs-number\">3001</span>;\n\napp.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'/api'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">_req, res</span>) =></span> {\n  res.<span class=\"hljs-title function_\">status</span>(<span class=\"hljs-number\">200</span>).<span class=\"hljs-title function_\">json</span>({ <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'서버에서 안녕하세요!'</span> });\n});\n\napp.<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-variable constant_\">PORT</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`서버가 포트 <span class=\"hljs-subst\">${PORT}</span>에서 실행 중입니다.`</span>);\n});\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이것은 기본 express 서버입니다. 이 앱은 서버를 시작하고 지정된 포트에서 연결을 수신 대기합니다. /api 경로에 대한 요청에 대해 \"서버에서 안녕하세요!\"라고 응답합니다. 코드가 무엇을 하는지 이해해 봅시다.</p>\n<ul>\n<li>미들웨어 설정</li>\n</ul>\n<p>app.use()는 미들웨어를 등록하는 방법입니다. 미들웨어는 서버가 특정 요청을 처리하기 전에 실행하는 특별한 함수들입니다. 미들웨어는 서버가 요청을 수신하고 클라이언트에게 응답을 보내는 순간 사이에서 작동합니다.</p>\n<p>우리의 경우, 몇 가지 전역 미들웨어를 등록했습니다:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>cors: 이 미들웨어는 서버가 서로 다른 소스/출처에서 오는 요청을 수락할 수 있도록 합니다.</li>\n<li>express.json(): 들어오는 요청을 JSON 형식으로 파싱합니다.</li>\n<li>express.urlencoded('extended: true'): 요청에서 폼 데이터를 파싱합니다.</li>\n</ul>\n<ol start=\"2\">\n<li>라우트 설정</li>\n</ol>\n<p>app.get(<code>/api</code>)은 특히 /api URL로의 GET 요청에 대한 라우트 핸들러를 설정합니다. 이 라우트로 GET 요청이 올 경우, 서버는 상태 코드 200과 \"서버에서 인사합니다!\" 메시지로 응답합니다.</p>\n<ol start=\"3\">\n<li>서버 초기화</li>\n</ol>\n<div class=\"content-ad\"></div>\n<p>app.listen()은 지정된 포트(PORT)에서 Express 앱을 수신하여 시작합니다. 환경 변수에 포트가 지정되지 않은 경우 기본값은 포트 3001입니다.</p>\n<p>이 설정으로 서버를 실행하는 한 걸음 더 나아갈 수 있습니다.</p>\n<h1>TypeScript로 Nodemon 구성하기</h1>\n<p>main.ts를 실행하려면 서버 디렉토리 내에서 node src/main.ts를 실행할 수 있지만, \".ts\" 라는 알 수 없는 파일 확장자 오류가 발생합니다.</p>\n<div class=\"content-ad\"></div>\n<p>Node와 TypeScript</p>\n<p><code>node src/main.ts</code>를 실행할 때 Node.js가 TypeScript 파일을 직접 실행할 것으로 기대할 수 있습니다. 그러나 Node.js는 TypeScript를 네이티브로 이해하지 않습니다. JavaScript만을 이해합니다.</p>\n<p>TypeScript는 JavaScript의 확장이므로 TypeScript 코드는 Node.js에서 실행되기 전에 JavaScript로 컴파일되어야 합니다. 이 컴파일 과정은 .ts 파일을 Node가 이해할 수 있는 동등한 .js 파일로 변환합니다.</p>\n<p>서버 코드를 실행하려면 먼저 TypeScript 컴파일러(tsc)를 사용하여 TypeScript 코드를 JavaScript로 변환해야 합니다. 이를 통해 컴파일된 JavaScript 코드가 포함된 dist/main.js 파일이 생성됩니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"># 모든 <span class=\"hljs-title class_\">TypeScript</span> 파일을 <span class=\"hljs-title class_\">JavaScript</span>로 컴파일\nnpx tsc\n\n# 생성된 <span class=\"hljs-title class_\">JavaScript</span> 파일 실행\nnode dist/main.<span class=\"hljs-property\">js</span>\n</code></pre>\n<p>위의 명령어에서 npx tsc는 TypeScript 컴파일러(tsc)를 호출하여 프로젝트의 모든 TypeScript 파일을 JavaScript로 컴파일합니다. 그 결과로 생성된 JavaScript 파일은 dist 디렉토리에 출력됩니다. 생성된 JavaScript 파일은 Node.js를 사용하여 실행할 수 있습니다.</p>\n<p>컴파일된 JavaScript 파일의 출력 디렉토리는 tsconfig.json 파일의 outDir 속성을 사용하여 지정됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// server/tsconfig.json</span>\n\n{\n  <span class=\"hljs-string\">\"compilerOptions\"</span>: {\n    <span class=\"hljs-string\">\"outDir\"</span>: <span class=\"hljs-string\">\"./dist\"</span>\n  }\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>마지막으로, dist 폴더를 .gitignore 파일에 포함시켜야합니다. 이렇게 하면 컴파일된 JavaScript 파일이 버전 관리에 포함되지 않습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// server/.gitignore</span>\n\nnode_modules\ndist\n.<span class=\"hljs-property\">env</span>*\n</code></pre>\n<p>Nodemon을 사용하여 변경 사항 감지</p>\n<p>TypeScript 파일을 수정할 때마다 npx tsc 및 node dist/main.js를 사용하여 파일을 수동으로 다시 컴파일하고 실행해야합니다. 이러한 반복 작업은 빠르게 지루해질 수 있습니다. 이 과정을 간소화하기 위해 nodemon이라는 도구를 사용할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>Nodemon은 디렉토리 내 파일 변경을 감지하여 Node.js 기반 애플리케이션을 자동으로 다시 시작하는 도구입니다. 이를 이용하면 코드를 수정할 때마다 서버를 수동으로 중지하고 다시 시작하는 수고를 덜 수 있습니다.</p>\n<p>Nodemon은 이미 설치했으므로 이제 구성만 남았습니다.</p>\n<p>Nodemon 구성하기</p>\n<p>Nodemon을 구성하려면 package.json에 nodemonConfig를 추가할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-comment\">// server/package.json</span>\n\n<span class=\"hljs-attr\">\"scripts\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">\"dev\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"nodemon\"</span>\n  <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"nodemonConfig\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">\"watch\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n      <span class=\"hljs-string\">\"src\"</span>\n    <span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"exec\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"tsc &#x26;&#x26; node ./dist/main.js\"</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"ext\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"ts,js,json\"</span>\n  <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n</code></pre>\n<p>nodemonConfig 섹션은 파일 변경을 모니터링할 때 nodemon이 어떻게 동작해야 하는지 알려줍니다:</p>\n<ul>\n<li>watch: nodemon에게 src 폴더 내의 변경 사항을 모니터링하도록 지시합니다.</li>\n<li>ext: 변경 사항을 모니터링할 파일 확장자를 지정합니다 (ts, js, json).</li>\n<li>exec: 변경 사항이 감지되었을 때 실행할 명령을 정의합니다. 이 경우 TypeScript 파일을 컴파일하고 node ./dist/main.js를 실행하여 서버를 시작합니다.</li>\n</ul>\n<p>이제 npm run dev를 실행하여 간단히 nodemon과 함께 서버를 시작할 수 있습니다. 파일 변경 사항을 모니터링하고 서버를 자동으로 다시 시작하는 프로세스가 자동화됩니다. 이 변경 사항으로 서버는 요청을 받을 준비가 되었습니다. Postman과 같은 API 플랫폼이 있다면 <a href=\"http://localhost:3001/api%EC%97%90\" rel=\"nofollow\" target=\"_blank\">http://localhost:3001/api에</a> GET 요청을 보내보거나 브라우저에서 링크를 방문하여 확인할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<h1>클라이언트 설정</h1>\n<p>저희 서버는 클라이언트로부터의 요청을 받을 준비가 되어 있습니다. 프론트엔드에서는 Vue를 사용할 것입니다. Vue는 Vite를 기반으로 한 빌드 설정을 사용하며, 이를 우리 서버와 통신하도록 구성할 것입니다. 시작해봅시다.</p>\n<ul>\n<li>클라이언트 디렉토리로 이동하기</li>\n</ul>\n<p>먼저 서버 디렉토리를 중지하고 종료한 후, 클라이언트로 이동해보겠습니다. 서버가 실행 중인 터미널에서 ^ + C (control + C)를 눌러 중지한 다음, 다음 명령어를 실행하세요.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"># 서버 디렉토리를 나와 클라이언트로 이동 \ncd ../client\n</code></pre>\n<ol start=\"2\">\n<li>Vue 프로젝트 생성</li>\n</ol>\n<p>Vue 앱을 만들려면 다음 명령을 실행하세요. 이 명령은 . .에 의해 지정된 클라이언트 폴더에 직접 프로젝트를 생성합니다.</p>\n<pre><code class=\"hljs language-js\">npm create vue@latest .\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>여러 선택지를 만들어 몇 가지 선택을 해야 할 것입니다. 패키지 이름과 TypeScript 지원에 대해 고민할 차례입니다. 당신의 프로젝트를 위해 express-vue로 이름을 지어주고 TypeScript 지원에 \"예\"를 선택하되, 다른 선택 가능한 기능들에 대해서는 \"아니요\"를 선택하여 프로젝트를 간단하게 유지해주세요.</p>\n<p>그 다음, 의존성을 설치하고 개발 서버를 시작해보세요.</p>\n<pre><code class=\"hljs language-js\"># 의존성 설치\nnpm install\n\n# 개발 서버 시작\nnpm run dev\n</code></pre>\n<p>이제 <a href=\"http://localhost:5173/%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\">http://localhost:5173/에서</a> Vue 프로젝트가 실행 중일 것입니다.</p>\n<div class=\"content-ad\"></div>\n<ol start=\"3\">\n<li>.env 파일 추가</li>\n</ol>\n<p>다음 변수를 사용하여 클라이언트 폴더의 루트에 .env 파일을 추가하십시오.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">VITE_SERVER_URL</span>=<span class=\"hljs-attr\">http</span>:<span class=\"hljs-comment\">//localhost:3001</span>\n<span class=\"hljs-variable constant_\">VITE_SERVER_API_PATH</span>=/api\n</code></pre>\n<p>.env 파일을 변경하면 서버를 다시 시작해야 할 수도 있습니다. 서버를 중지하려면 서버가 실행 중인 터미널에서 ^ + C (control + C)를 눌러주세요. 그런 다음 서버를 다시 시작하려면 npm run dev를 다시 실행해주세요.</p>\n<div class=\"content-ad\"></div>\n<ol start=\"4\">\n<li>vite.config.ts 파일 업데이트</li>\n</ol>\n<p>우리는 vite.config.ts 파일을 사용하여 클라이언트와 서버 간의 통신을 활성화하기 위해 파일을 사용자 정의하고 싶어요. defineConfig은 Vite 프로젝트에서 구성 옵션을 정의하는 데 사용되는 도우미 함수입니다. defineConfig은 객체나 함수 둘 중 하나를 인수로 받을 수 있어요. 환경 변수를 로드할 수 있도록 함수를 전달할 거에요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { fileURLToPath, <span class=\"hljs-variable constant_\">URL</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'node:url'</span>;\n\n<span class=\"hljs-keyword\">import</span> vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@vitejs/plugin-vue'</span>;\n<span class=\"hljs-keyword\">import</span> { defineConfig, loadEnv } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vite'</span>;\n\n<span class=\"hljs-comment\">// &#x3C;https://vitejs.dev/config/></span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">env</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> envars = <span class=\"hljs-title function_\">loadEnv</span>(env.<span class=\"hljs-property\">mode</span>, <span class=\"hljs-string\">'./'</span>);\n\n  <span class=\"hljs-keyword\">const</span> serverURL = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">URL</span>(\n    envars.<span class=\"hljs-property\">VITE_SERVER_URL</span> ?? <span class=\"hljs-string\">'&#x3C;http://localhost:3001>'</span>\n  );\n  <span class=\"hljs-keyword\">const</span> serverAPIPath = envars.<span class=\"hljs-property\">VITE_SERVER_API_PATH</span> ?? <span class=\"hljs-string\">'/api'</span>;\n\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">envDir</span>: <span class=\"hljs-string\">'./'</span>,\n\n    <span class=\"hljs-comment\">// 클라이언트에서 API 경로를 전역적으로 사용할 수 있도록 함</span>\n    <span class=\"hljs-attr\">define</span>: {\n      <span class=\"hljs-attr\">__API_PATH__</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(serverAPIPath),\n    },\n\n    <span class=\"hljs-attr\">plugins</span>: [<span class=\"hljs-title function_\">vue</span>()],\n    <span class=\"hljs-attr\">resolve</span>: {\n      <span class=\"hljs-attr\">alias</span>: {\n        <span class=\"hljs-string\">'@'</span>: <span class=\"hljs-title function_\">fileURLToPath</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">URL</span>(<span class=\"hljs-string\">'./src'</span>, <span class=\"hljs-keyword\">import</span>.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">url</span>)),\n      },\n    },\n\n    <span class=\"hljs-attr\">server</span>: {\n      <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">5173</span>,\n      <span class=\"hljs-attr\">proxy</span>: {\n        <span class=\"hljs-comment\">// API 경로를 가진 요청을 서버로 프록시함</span>\n        <span class=\"hljs-comment\">// &#x3C;http://localhost:5173/api> -> &#x3C;http://localhost:3001/api></span>\n        [serverAPIPath]: serverURL.<span class=\"hljs-property\">origin</span>,\n      },\n    },\n  };\n});\n</code></pre>\n<p>이 설정의 각 부분이 어떤 역할을 하는지 살펴보도록 하죠.</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>환경 변수 로딩: loadEnv 함수를 사용하여 현재 모드(예: 개발, 프로덕션)에 기반하여 환경 변수를 로드합니다. 프로젝트 디렉토리에 있는 .env 파일을 읽고 변수를 envars 객체에 로드합니다.</li>\n<li>서버 URL 및 API 경로 구문 분석: 서버 URL 및 API 경로가 구문 분석되며, .env 파일에서 찾지 못한 경우 기본값이 제공됩니다.</li>\n</ul>\n<p>구성 옵션:</p>\n<ul>\n<li>envDir: 환경 변수가 위치한 디렉토리를 지정합니다.</li>\n<li>define: 빌드 과정 중에 대체될 전역 상수를 정의할 수 있습니다. 이 경우 __API_PATH__는 서버 API 경로 값으로 정의됩니다.</li>\n<li>plugins: 프로젝트에서 사용하는 Vite 플러그인을 지정합니다. 여기서 Vue.js 플러그인(vue())이 추가됩니다.</li>\n<li>resolve.alias: 모듈 해상도를 위한 별칭을 정의합니다. 이 경우 @ 별칭이 src 디렉토리로 설정됩니다.</li>\n</ul>\n<p>서버 구성:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>server.port: Vite 개발 서버가 실행될 포트를 지정합니다. 여기서는 5173으로 설정되어 있어요.</li>\n<li>server.proxy: 프록시 설정은 클라이언트와 서버 간 통신을 가능하게 합니다. API 경로와 일치하는 요청은 서버 URL로 전달됩니다. <a href=\"http://localhost:5173/api%EB%A1%9C\" rel=\"nofollow\" target=\"_blank\">http://localhost:5173/api로</a> 요청을 보내면 <a href=\"http://localhost:3001/api%EB%A1%9C\" rel=\"nofollow\" target=\"_blank\">http://localhost:3001/api로</a> 우리 서버로 전달됩니다.</li>\n</ul>\n<ol start=\"5\">\n<li>전역 상수 선언</li>\n</ol>\n<p>vite.config.ts 파일에 전역 상수를 추가한 후, TypeScript가 이 상수를 인식하여 타입 확인을 수행하게 만들어야 합니다. env.d.ts 파일에 타입 정의를 선언하여 이를 달성할 수 있어요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// client/env.d.ts  </span>\n\n<span class=\"hljs-comment\">/// &#x3C;reference types=\"vite/client\" /> </span>\ndeclare <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">__API_PATH__</span>: string;\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이 선언에서는 TypeScript에 <strong>API_PATH</strong> 상수의 존재를 알리고, 해당 타입을 문자열로 지정합니다. 이는 TypeScript가 프로젝트 전체에서 이 글로벌 상수에 대한 유형 확인 및 IntelliSense 지원을 제공하도록 보장합니다.</p>\n<ol start=\"6\">\n<li>서버에 요청 보내기</li>\n</ol>\n<p>이제 Vite 프로젝트를 서버와 통신하도록 구성했으므로 App.vue 파일을 업데이트하여 서버로부터 요청을 보내고 응답을 화면에 표시해 보겠습니다. 다음 스니펫은 Vue.js composition API를 사용하여 서버에서 데이터를 가져와 앱에 표시하는 방법을 보여줍니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// client/src/App.vue</span>\n\n&#x3C;script setup lang=<span class=\"hljs-string\">\"ts\"</span>>\n<span class=\"hljs-keyword\">import</span> { ref } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"vue\"</span>;\n\n<span class=\"hljs-comment\">// API 기본 URL을 포함하는 전역 상수 -> /api</span>\n<span class=\"hljs-keyword\">const</span> baseURL = __API_PATH__;\n\n<span class=\"hljs-comment\">// 로딩 상태 및 응답 메시지 관리를 위한 반응형 변수</span>\n<span class=\"hljs-keyword\">const</span> isLoading = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-literal\">false</span>);\n<span class=\"hljs-keyword\">const</span> message = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-string\">\"\"</span>);\n\n<span class=\"hljs-comment\">// 서버에서 데이터를 가져오는 함수</span>\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fetchAPI</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-comment\">// 로딩 상태를 true로 설정</span>\n    isLoading.<span class=\"hljs-property\">value</span> = <span class=\"hljs-literal\">true</span>;\n\n    <span class=\"hljs-comment\">// 서버에 GET 요청 보내기</span>\n    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(baseURL);\n\n    <span class=\"hljs-comment\">// JSON 응답 해석</span>\n    <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n\n    <span class=\"hljs-comment\">// 응답 데이터로 메시지 업데이트</span>\n    message.<span class=\"hljs-property\">value</span> = data.<span class=\"hljs-property\">message</span>;\n  } <span class=\"hljs-keyword\">catch</span> (error) {\n    <span class=\"hljs-comment\">// 오류 처리</span>\n    message.<span class=\"hljs-property\">value</span> = <span class=\"hljs-string\">\"데이터 검색 오류\"</span>;\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(error);\n  } <span class=\"hljs-keyword\">finally</span> {\n    <span class=\"hljs-comment\">// 로딩 상태 재설정</span>\n    isLoading.<span class=\"hljs-property\">value</span> = <span class=\"hljs-literal\">false</span>;\n  }\n}\n&#x3C;/script>\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">template</span>></span>\n  <span class=\"hljs-comment\">&#x3C;!-- fetchAPI 함수를 실행하는 버튼 --></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"fetchAPI\"</span>></span>가져오기<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span>\n\n  <span class=\"hljs-comment\">&#x3C;!-- 데이터를 가져올 때 로딩 메시지 표시 --></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"isLoading\"</span>></span>로딩 중...<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n\n  <span class=\"hljs-comment\">&#x3C;!-- 사용 가능한 경우 응답 메시지 표시 --></span>\n  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"message\"</span>></span>{ message }<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">template</span>></span></span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이 코드 스니펫에서:</p>\n<ul>\n<li>우리는 Vue의 composition API에서 ref 함수를 가져와 반응형 변수를 생성하여 로딩 상태(isLoading)와 응답 메시지(message)를 관리합니다.</li>\n<li>fetchAPI 함수는 fetch API를 사용해 서버로 GET 요청을 보내는 데 정의됩니다.</li>\n<li>요청이 처리되는 동안 로딩 상태가 true로 설정되고 로딩 메시지가 표시됩니다.</li>\n<li>요청이 완료되면 로딩 상태가 재설정되고 서버로부터의 응답 메시지가 표시됩니다.</li>\n<li>요청 중에 발생하는 모든 오류는 catch되어 메시지가 업데이트됩니다.</li>\n</ul>\n<p>이러한 업데이트로 인해, Vue 애플리케이션은 서버에서 데이터를 가져와 사용자에게 표시할 수 있습니다.</p>\n<ol start=\"7\">\n<li>두 서버를 시작하세요.</li>\n</ol>\n<div class=\"content-ad\"></div>\n<p>이미 클라이언트가 실행 중이므로 서버를 시작해야 합니다. VS Code를 사용 중이라면, 메뉴 바에서 Terminal 옵션을 마우스 오른쪽 클릭하고 New Terminal을 선택하여 새 터미널을 열 수 있습니다. 또는 새 터미널 창을 열어 프로젝트 디렉토리로 이동할 수도 있어요. 프로젝트 디렉토리에 들어간 후 아래 명령어를 실행하여 서버를 시작하세요:</p>\n<pre><code class=\"hljs language-js\">cd server\nnpm run dev\n</code></pre>\n<p>위의 명령어를 실행하면 서버 디렉토리로 이동한 후 개발 모드에서 서버가 시작됩니다.</p>\n<ol start=\"8\">\n<li>클라이언트 측 요청 초기화.</li>\n</ol>\n<div class=\"content-ad\"></div>\n<p>클라이언트에서 App.vue에서 버튼을 클릭하여 요청을 트리거하는 것이 마지막 단계입니다. 이렇게 하면 서버로 요청이 전송됩니다.</p>\n<h1>결론</h1>\n<p>축하합니다! 🎉 Express.js 및 TypeScript를 사용하여 백엔드에 Vue.js 및 Vite를 사용하는 풀스택 웹 개발 환경을 구축하는 방법을 성공적으로 배우셨습니다.</p>\n<p>이 가이드에서 다룬 내용은 다음과 같습니다:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>백엔드 설정: TypeScript로 Express.js 서버를 초기화하고 미들웨어를 구성하며 노드.js에서 실행할 수 있도록 코드를 컴파일하는 것부터 시작했습니다.</li>\n<li>프론트엔드 구성: 다음으로, 클라이언트와 서버 간의 통신을 허용하도록 Vite를 구성했습니다. 특정 요청을 서버로 프록시하기 위해 Vite의 서버 옵션을 활용했습니다.</li>\n<li>클라이언트-서버 통신: 환경을 설정한 후, Vue.js composition API를 사용하여 프론트엔드에서 백엔드로 요청을 보내는 방법을 배웠습니다. 서버에서 데이터를 가져와 UI를 업데이트하여 반응형 웹 애플리케이션을 만들었습니다.</li>\n</ul>\n<p>서버 측 로직 작업에 대한 걱정이 줄어들었기를 바라며, 동적 웹 애플리케이션을 구축하는 기초를 마련했으니 실험을 계속해보고, 계속해서 개발하고, 풀스택 부분에 더 깊이 파고들기를 주저하지 마십시오.</p>\n<p>즐거운 코딩!</p>\n<p><img src=\"/assets/img/2024-06-22-SettingupanExpressTypescriptServerwithVueVite_1.png\" alt=\"이미지\"></p>\n</body>\n</html>\n"},"__N_SSG":true}