{"pageProps":{"post":{"title":"시그널 signal, computed, effect을 테스트하는 방법은 무엇인가요","description":"","date":"2024-06-20 05:37","slug":"2024-06-20-HowdoItestSignalssignalcomputedeffect","content":"\n\n![image](/assets/img/2024-06-20-HowdoItestSignalssignalcomputedeffect_0.png)\n\n가벼운 \"반응형 기본 요소\"로서의 신호는 Angular 애플리케이션의 미래를 형성할 것입니다. 이 글을 쓰는 시점에서 signal() 및 computed()는 안정적이며, effect()는 개발자 미리보기 상태입니다.\n\n개발자 미리보기는 불안정한 기능을 가지고 있다는 것이 아니라 Angular 팀이 주요 버전 내에서 파괴적인 변경 사항을 도입할 수 있다는 것을 의미합니다. 해당 기능이 안정적이지 않다면 실험적인 레이블이 달려 있을 것입니다.\n\n특히 신호 입력과 함께, 신호는 일상적인 작업에서 더 많이 사용되고 있습니다. 이제 신호를 코드베이스에 통합하는 것을 고려할 때입니다.\n\n<div class=\"content-ad\"></div>\n\n그것은 우리가 테스트를 작성할 수 있어야 한다는 것을 요구합니다.\n\n시각적으로 더 잘 배우시는 분을 위해 영상이 준비되어 있습니다:\n\n# 신호 및 반응력 개요\n\ncomputed()와 effect()를 사용하여 파생된 신호를 생성하거나 신호의 값이 변경될 때 부수효과를 실행합니다. 그것이 신호의 반응성입니다.\n\n<div class=\"content-ad\"></div>\n\nRxJs와 비교할 때 반응성은 수동 구독이 필요하지 않습니다. Angular가 대신해줍니다.\n\nsignal()이나 computed()으로 생성된 신호는 의존성 주기가 발생하는 반응적인 컨텍스트 안에서 실행되어야 합니다. Angular에서는 두 가지가 있습니다:\n\n- 컴포넌트의 템플릿\n- effect() 함수\n\n다시 말해, 템플릿이나 effect() 안에서 Signal을 호출할 때마다 Signal은 반응성을 갖게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\"Reactive Signal(반응형 신호)”이 변경되면, 그 신호는 computed(), effect() 또는 템플릿을 구독하는 소비자들에게 알릴 것입니다. computed()은 더 많은 소비자들을 가질 수도 있고, 그 소비자들도 다시 소비자들을 가질 수 있습니다.\n\n반응형 컨텍스트에 따라 DOM 업데이트(템플릿) 또는 사이드 이펙트(effect() 실행)가 발생합니다.\n\n변경 감지(Change Detection) 중에 반응형 컨텍스트가 실행됩니다: 마지막 값만 통과됩니다. 변화 감지 실행 사이에 신호가 여러 번 변경되더라도 마지막 값을 처리합니다. 즉, computed(), effect(), 그리고 템플릿은 중간 값이 아닌 마지막 값을 처리합니다.\n\n이 동작은 프론트엔드 프레임워크의 관점에서 신호를 보면 완전히 이해할 수 있습니다. 만약 세 번의 동기(중간) 변경이 있다면, 왜 세 번 DOM을 업데이트해야 할까요? 기술적으로 가능하더라도 서로 다른 렌더링 프레임에서 값이 변경되기 때문에 최종 사용자는 새로운 값이 보이지 않을 것입니다. 신호가 “안정 상태”에 도달할 때까지 기다린 후에 DOM을 업데이트하는 것이 훨씬 나은 접근입니다.\"\n\n<div class=\"content-ad\"></div>\n\n이 동작은 \"Glitch-free effect\" 또는 \"Push/Pull\"로 알려져 있어요.\n\n어쩌면 이 애니메이션이 \"Glitch-free effect\"를 이해하는 데 도움이 될 수도 있어요.\n\n# 테스트 대상 구성 요소\n\n저희 구성 요소는 온라인 쇼핑몰의 바구니입니다. 사용자가 제품 수량을 증가시키거나 감소시킬 수 있는 곳이에요:\n\n<div class=\"content-ad\"></div>\n\n```js\n@Component({\n  selector: 'app-basket',\n  template: `<h2>Basket</h2>\n    <div class=\"w-[640px]\">\n      <div class=\"grid grid-cols-4 gap-4 auto-cols-fr\">\n        <div class=\"font-bold\">이름</div>\n        <div class=\"font-bold\">가격</div>\n        <div class=\"font-bold\">수량</div>\n        <div>&nbsp;</div>\n        @for (product of products(); track product.id) {\n          <div>{ product.name }</div>\n          <div>{ product.price }</div>\n          <div>{ product.amount }</div>\n          <div>\n            <button\n              mat-raised-button\n              (click)=\"decrease(product.id)\"\n              data-testid=\"btn-decrease\"\n            >\n              <mat-icon>remove</mat-icon>\n            </button>\n            <button\n              mat-raised-button\n              (click)=\"increase(product.id)\"\n              data-testid=\"btn-increase\"\n            >\n              <mat-icon>add</mat-icon>\n            </button>\n          </div>\n        }\n\n        <div class=\"font-bold\">총 가격</div>\n        <div class=\"font-bold\" data-testid=\"total\">{ totalPrice() }</div>\n      </div>\n    </div>`,\n  standalone: true,\n  imports: [MatButton, MatIcon],\n})\nexport default class BasketComponent {\n  products = signal([\n    { id: 1, name: '커피', price: 3, amount: 1 },\n    { id: 2, name: '슈니첼', price: 15, amount: 1 },\n  ]);\n\n  syncService = inject(SyncService);\n\n  constructor() {\n    effect(() => this.syncService.sync(this.products()));\n  }\n\n  totalPrice = computed(() =>\n    this.products().reduce(\n      (total, product) => total + product.price * product.amount,\n      0,\n    ),\n  );\n\n  decrease(id: number) {\n    this.#change(id, (product) =>\n      product.amount > 0 ? { ...product, amount: product.amount - 1 } : product,\n    );\n  }\n\n  increase(id: number) {\n    this.#change(id, (product) => ({ ...product, amount: product.amount + 1 }));\n  }\n\n  #change(id: number, callback: (product: Product) => Product) {\n    this.products.update((products) =>\n      // some logic to update the products\n    );\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n@Injectable({ providedIn: 'root' })\nexport class SyncService {\n  sync(products: Product[]) {\n    console.log(products);\n  }\n}\n```\n\n그렇게 많지 않아요😀, 하지만 가능한 짧은 예제를 유지하고 싶습니다.\n\n# 변경 감지를 사용한 테스트\n\nSignals의 핵심인 변경 감지의 중요성을 고려하면, 변경 감지가 테스트의 일부인 경우 테스트가 훨씬 쉽다는 것이 명백해질 것입니다.\n\n<div class=\"content-ad\"></div>\n\n우리의 테스트가 DOM을 통해 Component와 통신하고 TestBed.createComponent를 통해 Component를 생성할 때 항상 발생하는 경우입니다.\n\n## computed() 테스트\n\n이것은 DOM을 통해 총 가격을 확인하는 테스트입니다:\n\n```js\nit('상품의 수량을 증가시켜야 합니다', () => {\n  const fixture = TestBed.configureTestingModule({\n    imports: [BasketComponent],\n  }).createComponent(BasketComponent);\n  fixture.detectChanges();\n\n  const total: HTMLDivElement = fixture.debugElement.query(\n    By.css('[data-testid=\"total\"]'),\n  ).nativeElement;\n  expect(total.textContent).toBe('18');\n\n  fixture.debugElement\n    .query(By.css('[data-testid=\"btn-increase\"]'))\n    .nativeElement.click();\n  fixture.detectChanges();\n\n  expect(total.textContent).toBe('21');\n});\n```\n\n<div class=\"content-ad\"></div>\n\n그 테스트가 예상대로 작동합니다. 깜짝 놀랄 일이 없네요!\n\n변경 감지를 올바른 위치에서 실행하면 모든 것이 잘 됩니다. 그 올바른 위치는 클릭과 같은 이벤트 이후와 컴포넌트를 초기화할 때입니다.\n\n## effect() 테스트\n\neffect()를 테스트에 포함하는 경우 약간 복잡해집니다.\n\n<div class=\"content-ad\"></div>\n\neffect() 함수가 SyncService를 실행하기 때문에 그 호출 횟수를 세고 싶습니다.\n\n매 변경 감지 시, effect() 함수는 products의 값이 변경되었는지 확인합니다. 값이 변경되면 effect() 함수는 SyncService를 실행합니다.\n\n우리는 DOM을 통해 SyncService의 실행을 단언할 수 없습니다. 그래서 SyncService 인스턴스에 스파이를 적용해야 합니다. 이를 위해 컴포넌트 인스턴스에 접근할 수 있어야 합니다.\n\n업데이트된 테스트:\n\n<div class=\"content-ad\"></div>\n\n```js\nit('SyncService를 실행해야 합니다', () => {\n  const fixture = TestBed.configureTestingModule({\n    imports: [BasketComponent],\n  }).createComponent(BasketComponent);\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n  fixture.detectChanges();\n\n  expect(spy).toHaveBeenCalledTimes(1);\n});\n```\n\n우리는 effect()가 제품이 변경되고 Change Detection이 실행될 때만 실행되는 것을 확인할 수 있습니다.\n\n다음 두 가지 테스트가 실패해야 합니다:\n\n```js\nit('SyncService를 실행해야 합니다', () => {\n  const fixture = TestBed.configureTestingModule({\n    imports: [BasketComponent],\n  }).createComponent(BasketComponent);\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n\n  // Change Detection이 실행되지 않았습니다\n  expect(spy).toHaveBeenCalledTimes(1); \n})\n\nit('SyncService를 실행해야 합니다', () => {\n  const fixture = TestBed.configureTestingModule({\n    imports: [BasketComponent],\n  }).createComponent(BasketComponent);\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n  fixture.detectChanges();\n\n  expect(spy).toHaveBeenCalledTimes(1);\n  \n  // 총합이 변경되지 않아서 효과가 없습니다\n  fixture.detectChanges();\n  expect(spy).toHaveBeenCalledTimes(2); \n})\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 바구니에 있는 금액을 늘릴 수 있고, 변경 감지의 또 다른 실행 후에 SyncService가 두 번 실행된 것을 볼 수 있어야 합니다:\n\n```js\nit('SyncService를 실행해야 합니다', () => {\n  const fixture = TestBed.configureTestingModule({\n    imports: [BasketComponent],\n  }).createComponent(BasketComponent);\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n  fixture.detectChanges();\n\n  expect(spy).toHaveBeenCalledTimes(1);\n\n  const total: HTMLDivElement = fixture.debugElement.query(\n    By.css('[data-testid=\"total\"]'),\n  ).nativeElement;\n  expect(total.textContent).toBe('18');\n\n  fixture.debugElement\n    .query(By.css('[data-testid=\"btn-increase\"]'))\n    .nativeElement.click();\n\n  fixture.detectChanges();\n  expect(spy).toHaveBeenCalledTimes(2);\n});\n```\n\n다음으로 변경 감지가 사용 불가능한 다른 테스트 유형으로 넘어가 봅시다.\n\n# 변경 감지 없이 테스트하기\n\n<div class=\"content-ad\"></div>\n\nBasketComponent의 로직을 BasketService로 추출했습니다:\n\n```js\n@Injectable({ providedIn: 'root' })\nexport class BasketService {\n  products = signal([\n    {\n      id: 1,\n      name: 'Coffee',\n      price: 3,\n      amount: 1,\n    },\n    { id: 2, name: 'Schnitzel', price: 15, amount: 1 },\n  ]);\n\n  syncService = inject(SyncService);\n\n  constructor() {\n    effect(() => this.syncService.sync(this.products()));\n  }\n\n  totalPrice = computed(() =>\n    this.products().reduce(\n      (total, product) => total + product.price * product.amount,\n      0,\n    ),\n  );\n\n  decrease(id: number) {\n    this.#change(id, (product) =>\n      product.amount > 0 ? { ...product, amount: product.amount - 1 } : product,\n    );\n  }\n\n  increase(id: number) {\n    this.#change(id, (product) => ({ ...product, amount: product.amount + 1 }));\n  }\n\n  #change(id: number, callback: (product: Product) => Product) {\n    this.products.update((products) =>\n      products.map((product) => {\n        if (product.id === id && product.amount > 0) {\n          return callback(product);\n        } else {\n          return product;\n        }\n      }),\n    );\n  }\n}\n\n@Component({\n  selector: 'app-basket',\n  template: '<!-- 이전과 같은 템플릿 -->',\n  standalone: true,\n  imports: [MatButton, MatIcon],\n})\nexport default class BasketComponent {\n  basketService = inject(BasketService);\n\n  products = this.basketService.products;\n  totalPrice = this.basketService.totalPrice;\n\n  decrease(id: number) {\n    this.basketService.decrease(id);\n  }\n\n  increase(id: number) {\n    this.basketService.increase(id);\n  }\n}\n```\n\n이전의 테스트는 유지했습니다. 이제 Component와 두 개의 Service를 모두 커버합니다.\n\nBasketService만을 커버하는 테스트는 어떻게 작성할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n우리는 Component가 없으므로 이제 fixture.detectChanges()를 실행할 수 없습니다. 따라서 ComponentFixture도 없습니다.\n\n## computed() 테스트\n\ntotalPrice Signal을 확인하는 SignalService 테스트는 다음과 같이 보일 것입니다:\n\n```js\nit('BasketService를 테스트해야 합니다', () => {\n  const basketService = TestBed.inject(BasketService);\n  expect(basketService.totalPrice()).toBe(18);\n\n  basketService.increase(1);\n  expect(basketService.totalPrice()).toBe(21);\n});\n```\n\n<div class=\"content-ad\"></div>\n\n위의 테스트는 작동합니다. 왜냐하면 totalPrice를 반응적으로 만들려면 변경 감지 실행이 필요한 것 아닌가요?\n\n맞아요. 그렇지만 우리의 경우에는 totalPrice를 반응적인 방식으로 사용하지 않아요. 우리는 totalPrice를 직접 호출해요.\n\ncomputed()를 기반으로 한 Signal은 언제든지, 종속성이 변경되었는지 알 수 있고 (즉, 더티 상태인지), 다시 처리해야 해요.\n\n다시 처리를 시작하려면, 누군가가 그 값을 요청할 때 까지 기다려야 해요.\n\n<div class=\"content-ad\"></div>\n\n'컴포넌트 테스트에서 \"호출자\"는 변경 감지였습니다. 테스트에서 우리가 그것을 했죠.\n\n## effect() 테스트하기\n\ncomputed() 신호는 변경 감지 없이 간단히 테스트할 수 있지만, 실제 어려움은 effect()에서 발생합니다.\n\ncomputed()과 마찬가지로 effect()는 내부적으로 먼저 변경 유무를 알고 있습니다(의존성 중 하나가 값이 변경되었을 경우). 유감스럽게도 computed() 신호처럼 접근할 수는 없습니다.'\n\n<div class=\"content-ad\"></div>\n\nAngular 16에서 effect()를 테스트하는 유일한 방법은 Service를 \"Helper Component\"로 감싸는 것이었습니다. 그러나 Angular 17부터는 새로운 함수가 등장했습니다. 이 함수는 effect를 \"호출\"합니다: TestBed.flushEffects().\n\n이제 실제로 코드를 보겠습니다:\n\n```js\nit('BasketService를 테스트해야 합니다', () => {\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n\n  const basketService = TestBed.inject(BasketService);\n  TestBed.flushEffects();\n\n  basketService.increase(1);\n  TestBed.flushEffects();\n  expect(spy).toHaveBeenCalledTimes(2);\n});\n```\n\n다시 한 번 강조하면 Component 테스트와 동일한 동작을 볼 수 있습니다. effect()를 실행하려면 두 가지가 필요합니다:\n\n<div class=\"content-ad\"></div>\n\n1. effect() 함수는 더러워야 하고\n2. \"액티브 엑세스\"가 있어야 합니다.\n\n이 테스트들은 다시 실패할 것입니다:\n\n```js\nit('BasketService를 테스트해야 합니다', () => {\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n  TestBed.inject(BasketService);\n\n  // effect가 실행되지 않았습니다\n  expect(spy).toHaveBeenCalledTimes(1);\n});\n\nit('BasketService를 테스트해야 합니다', () => {\n  const syncService = TestBed.inject(SyncService);\n  const spy = spyOn(syncService, 'sync');\n  TestBed.inject(BasketService);\n\n  TestBed.flushEffects();\n  expect(spy).toHaveBeenCalledTimes(1);\n\n  // effect가 더러우지 않았습니다\n  TestBed.flushEffects();\n  expect(spy).toHaveBeenCalledTimes(2);\n});\n```\n\n# 요약\n\n<div class=\"content-ad\"></div>\n\n우리는 시그널을 사용하는 코드를 테스트할 때 \"Glitch-free\" 효과를 알아야 합니다.\n\n테스트에 변경 감지(Change Detection)가 포함되어 있는 경우, 해당 테스트는 우리 애플리케이션과 동일하게 작동합니다.\n\n변경 감지가 포함되지 않은 테스트 유형의 경우, 시그널을 직접 호출하고 TestBed.flushEffects()를 실행하여 \"dirty side effects\"를 실행해야 합니다.\n\nRepository에 접근할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\nhttps://github.com/rainerhahnekamp/how-do-i-test\n\n만약 여러분이 테스트 과제를 직면하고 저에게 도움 요청을 하고 싶다면 언제든지 연락해 주세요!\n\n추가 정보와 업데이트를 받으려면 LinkedIn에서 저와 연락하시거나 X와 함께 워크샵 및 테스팅에 관한 컨설팅 서비스를 탐색해 주세요.\n\nhttps://www.angulararchitects.io/en/training/professional-angular-testing-playwright-edition/","ogImage":{"url":"/assets/img/2024-06-20-HowdoItestSignalssignalcomputedeffect_0.png"},"coverImage":"/assets/img/2024-06-20-HowdoItestSignalssignalcomputedeffect_0.png","tag":["Tech"],"readingTime":12},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-20-HowdoItestSignalssignalcomputedeffect_0.png\" alt=\"image\"></p>\n<p>가벼운 \"반응형 기본 요소\"로서의 신호는 Angular 애플리케이션의 미래를 형성할 것입니다. 이 글을 쓰는 시점에서 signal() 및 computed()는 안정적이며, effect()는 개발자 미리보기 상태입니다.</p>\n<p>개발자 미리보기는 불안정한 기능을 가지고 있다는 것이 아니라 Angular 팀이 주요 버전 내에서 파괴적인 변경 사항을 도입할 수 있다는 것을 의미합니다. 해당 기능이 안정적이지 않다면 실험적인 레이블이 달려 있을 것입니다.</p>\n<p>특히 신호 입력과 함께, 신호는 일상적인 작업에서 더 많이 사용되고 있습니다. 이제 신호를 코드베이스에 통합하는 것을 고려할 때입니다.</p>\n<div class=\"content-ad\"></div>\n<p>그것은 우리가 테스트를 작성할 수 있어야 한다는 것을 요구합니다.</p>\n<p>시각적으로 더 잘 배우시는 분을 위해 영상이 준비되어 있습니다:</p>\n<h1>신호 및 반응력 개요</h1>\n<p>computed()와 effect()를 사용하여 파생된 신호를 생성하거나 신호의 값이 변경될 때 부수효과를 실행합니다. 그것이 신호의 반응성입니다.</p>\n<div class=\"content-ad\"></div>\n<p>RxJs와 비교할 때 반응성은 수동 구독이 필요하지 않습니다. Angular가 대신해줍니다.</p>\n<p>signal()이나 computed()으로 생성된 신호는 의존성 주기가 발생하는 반응적인 컨텍스트 안에서 실행되어야 합니다. Angular에서는 두 가지가 있습니다:</p>\n<ul>\n<li>컴포넌트의 템플릿</li>\n<li>effect() 함수</li>\n</ul>\n<p>다시 말해, 템플릿이나 effect() 안에서 Signal을 호출할 때마다 Signal은 반응성을 갖게 됩니다.</p>\n<div class=\"content-ad\"></div>\n<p>\"Reactive Signal(반응형 신호)”이 변경되면, 그 신호는 computed(), effect() 또는 템플릿을 구독하는 소비자들에게 알릴 것입니다. computed()은 더 많은 소비자들을 가질 수도 있고, 그 소비자들도 다시 소비자들을 가질 수 있습니다.</p>\n<p>반응형 컨텍스트에 따라 DOM 업데이트(템플릿) 또는 사이드 이펙트(effect() 실행)가 발생합니다.</p>\n<p>변경 감지(Change Detection) 중에 반응형 컨텍스트가 실행됩니다: 마지막 값만 통과됩니다. 변화 감지 실행 사이에 신호가 여러 번 변경되더라도 마지막 값을 처리합니다. 즉, computed(), effect(), 그리고 템플릿은 중간 값이 아닌 마지막 값을 처리합니다.</p>\n<p>이 동작은 프론트엔드 프레임워크의 관점에서 신호를 보면 완전히 이해할 수 있습니다. 만약 세 번의 동기(중간) 변경이 있다면, 왜 세 번 DOM을 업데이트해야 할까요? 기술적으로 가능하더라도 서로 다른 렌더링 프레임에서 값이 변경되기 때문에 최종 사용자는 새로운 값이 보이지 않을 것입니다. 신호가 “안정 상태”에 도달할 때까지 기다린 후에 DOM을 업데이트하는 것이 훨씬 나은 접근입니다.\"</p>\n<div class=\"content-ad\"></div>\n<p>이 동작은 \"Glitch-free effect\" 또는 \"Push/Pull\"로 알려져 있어요.</p>\n<p>어쩌면 이 애니메이션이 \"Glitch-free effect\"를 이해하는 데 도움이 될 수도 있어요.</p>\n<h1>테스트 대상 구성 요소</h1>\n<p>저희 구성 요소는 온라인 쇼핑몰의 바구니입니다. 사용자가 제품 수량을 증가시키거나 감소시킬 수 있는 곳이에요:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-basket'</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&#x3C;h2>Basket&#x3C;/h2>\n    &#x3C;div class=\"w-[640px]\">\n      &#x3C;div class=\"grid grid-cols-4 gap-4 auto-cols-fr\">\n        &#x3C;div class=\"font-bold\">이름&#x3C;/div>\n        &#x3C;div class=\"font-bold\">가격&#x3C;/div>\n        &#x3C;div class=\"font-bold\">수량&#x3C;/div>\n        &#x3C;div>&#x26;nbsp;&#x3C;/div>\n        @for (product of products(); track product.id) {\n          &#x3C;div>{ product.name }&#x3C;/div>\n          &#x3C;div>{ product.price }&#x3C;/div>\n          &#x3C;div>{ product.amount }&#x3C;/div>\n          &#x3C;div>\n            &#x3C;button\n              mat-raised-button\n              (click)=\"decrease(product.id)\"\n              data-testid=\"btn-decrease\"\n            >\n              &#x3C;mat-icon>remove&#x3C;/mat-icon>\n            &#x3C;/button>\n            &#x3C;button\n              mat-raised-button\n              (click)=\"increase(product.id)\"\n              data-testid=\"btn-increase\"\n            >\n              &#x3C;mat-icon>add&#x3C;/mat-icon>\n            &#x3C;/button>\n          &#x3C;/div>\n        }\n\n        &#x3C;div class=\"font-bold\">총 가격&#x3C;/div>\n        &#x3C;div class=\"font-bold\" data-testid=\"total\">{ totalPrice() }&#x3C;/div>\n      &#x3C;/div>\n    &#x3C;/div>`</span>,\n  <span class=\"hljs-attr\">standalone</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">MatButton</span>, <span class=\"hljs-title class_\">MatIcon</span>],\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasketComponent</span> {\n  products = <span class=\"hljs-title function_\">signal</span>([\n    { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'커피'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">amount</span>: <span class=\"hljs-number\">1</span> },\n    { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'슈니첼'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">15</span>, <span class=\"hljs-attr\">amount</span>: <span class=\"hljs-number\">1</span> },\n  ]);\n\n  syncService = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">SyncService</span>);\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">effect</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">syncService</span>.<span class=\"hljs-title function_\">sync</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">products</span>()));\n  }\n\n  totalPrice = <span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =></span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">products</span>().<span class=\"hljs-title function_\">reduce</span>(\n      <span class=\"hljs-function\">(<span class=\"hljs-params\">total, product</span>) =></span> total + product.<span class=\"hljs-property\">price</span> * product.<span class=\"hljs-property\">amount</span>,\n      <span class=\"hljs-number\">0</span>,\n    ),\n  );\n\n  <span class=\"hljs-title function_\">decrease</span>(<span class=\"hljs-params\">id: number</span>) {\n    <span class=\"hljs-variable language_\">this</span>.#<span class=\"hljs-title function_\">change</span>(id, <span class=\"hljs-function\">(<span class=\"hljs-params\">product</span>) =></span>\n      product.<span class=\"hljs-property\">amount</span> > <span class=\"hljs-number\">0</span> ? { ...product, <span class=\"hljs-attr\">amount</span>: product.<span class=\"hljs-property\">amount</span> - <span class=\"hljs-number\">1</span> } : product,\n    );\n  }\n\n  <span class=\"hljs-title function_\">increase</span>(<span class=\"hljs-params\">id: number</span>) {\n    <span class=\"hljs-variable language_\">this</span>.#<span class=\"hljs-title function_\">change</span>(id, <span class=\"hljs-function\">(<span class=\"hljs-params\">product</span>) =></span> ({ ...product, <span class=\"hljs-attr\">amount</span>: product.<span class=\"hljs-property\">amount</span> + <span class=\"hljs-number\">1</span> }));\n  }\n\n  #<span class=\"hljs-title function_\">change</span>(<span class=\"hljs-params\">id: number, callback: (product: Product) => Product</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">products</span>.<span class=\"hljs-title function_\">update</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">products</span>) =></span>\n      <span class=\"hljs-comment\">// some logic to update the products</span>\n    );\n  }\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Injectable</span>({ <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">'root'</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SyncService</span> {\n  <span class=\"hljs-title function_\">sync</span>(<span class=\"hljs-params\">products: Product[]</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(products);\n  }\n}\n</code></pre>\n<p>그렇게 많지 않아요😀, 하지만 가능한 짧은 예제를 유지하고 싶습니다.</p>\n<h1>변경 감지를 사용한 테스트</h1>\n<p>Signals의 핵심인 변경 감지의 중요성을 고려하면, 변경 감지가 테스트의 일부인 경우 테스트가 훨씬 쉽다는 것이 명백해질 것입니다.</p>\n<div class=\"content-ad\"></div>\n<p>우리의 테스트가 DOM을 통해 Component와 통신하고 TestBed.createComponent를 통해 Component를 생성할 때 항상 발생하는 경우입니다.</p>\n<h2>computed() 테스트</h2>\n<p>이것은 DOM을 통해 총 가격을 확인하는 테스트입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">'상품의 수량을 증가시켜야 합니다'</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> fixture = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">configureTestingModule</span>({\n    <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">BasketComponent</span>],\n  }).<span class=\"hljs-title function_\">createComponent</span>(<span class=\"hljs-title class_\">BasketComponent</span>);\n  fixture.<span class=\"hljs-title function_\">detectChanges</span>();\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">total</span>: <span class=\"hljs-title class_\">HTMLDivElement</span> = fixture.<span class=\"hljs-property\">debugElement</span>.<span class=\"hljs-title function_\">query</span>(\n    <span class=\"hljs-title class_\">By</span>.<span class=\"hljs-title function_\">css</span>(<span class=\"hljs-string\">'[data-testid=\"total\"]'</span>),\n  ).<span class=\"hljs-property\">nativeElement</span>;\n  <span class=\"hljs-title function_\">expect</span>(total.<span class=\"hljs-property\">textContent</span>).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-string\">'18'</span>);\n\n  fixture.<span class=\"hljs-property\">debugElement</span>\n    .<span class=\"hljs-title function_\">query</span>(<span class=\"hljs-title class_\">By</span>.<span class=\"hljs-title function_\">css</span>(<span class=\"hljs-string\">'[data-testid=\"btn-increase\"]'</span>))\n    .<span class=\"hljs-property\">nativeElement</span>.<span class=\"hljs-title function_\">click</span>();\n  fixture.<span class=\"hljs-title function_\">detectChanges</span>();\n\n  <span class=\"hljs-title function_\">expect</span>(total.<span class=\"hljs-property\">textContent</span>).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-string\">'21'</span>);\n});\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>그 테스트가 예상대로 작동합니다. 깜짝 놀랄 일이 없네요!</p>\n<p>변경 감지를 올바른 위치에서 실행하면 모든 것이 잘 됩니다. 그 올바른 위치는 클릭과 같은 이벤트 이후와 컴포넌트를 초기화할 때입니다.</p>\n<h2>effect() 테스트</h2>\n<p>effect()를 테스트에 포함하는 경우 약간 복잡해집니다.</p>\n<div class=\"content-ad\"></div>\n<p>effect() 함수가 SyncService를 실행하기 때문에 그 호출 횟수를 세고 싶습니다.</p>\n<p>매 변경 감지 시, effect() 함수는 products의 값이 변경되었는지 확인합니다. 값이 변경되면 effect() 함수는 SyncService를 실행합니다.</p>\n<p>우리는 DOM을 통해 SyncService의 실행을 단언할 수 없습니다. 그래서 SyncService 인스턴스에 스파이를 적용해야 합니다. 이를 위해 컴포넌트 인스턴스에 접근할 수 있어야 합니다.</p>\n<p>업데이트된 테스트:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">'SyncService를 실행해야 합니다'</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> fixture = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">configureTestingModule</span>({\n    <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">BasketComponent</span>],\n  }).<span class=\"hljs-title function_\">createComponent</span>(<span class=\"hljs-title class_\">BasketComponent</span>);\n  <span class=\"hljs-keyword\">const</span> syncService = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">SyncService</span>);\n  <span class=\"hljs-keyword\">const</span> spy = <span class=\"hljs-title function_\">spyOn</span>(syncService, <span class=\"hljs-string\">'sync'</span>);\n  fixture.<span class=\"hljs-title function_\">detectChanges</span>();\n\n  <span class=\"hljs-title function_\">expect</span>(spy).<span class=\"hljs-title function_\">toHaveBeenCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n});\n</code></pre>\n<p>우리는 effect()가 제품이 변경되고 Change Detection이 실행될 때만 실행되는 것을 확인할 수 있습니다.</p>\n<p>다음 두 가지 테스트가 실패해야 합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">'SyncService를 실행해야 합니다'</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> fixture = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">configureTestingModule</span>({\n    <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">BasketComponent</span>],\n  }).<span class=\"hljs-title function_\">createComponent</span>(<span class=\"hljs-title class_\">BasketComponent</span>);\n  <span class=\"hljs-keyword\">const</span> syncService = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">SyncService</span>);\n  <span class=\"hljs-keyword\">const</span> spy = <span class=\"hljs-title function_\">spyOn</span>(syncService, <span class=\"hljs-string\">'sync'</span>);\n\n  <span class=\"hljs-comment\">// Change Detection이 실행되지 않았습니다</span>\n  <span class=\"hljs-title function_\">expect</span>(spy).<span class=\"hljs-title function_\">toHaveBeenCalledTimes</span>(<span class=\"hljs-number\">1</span>); \n})\n\n<span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">'SyncService를 실행해야 합니다'</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> fixture = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">configureTestingModule</span>({\n    <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">BasketComponent</span>],\n  }).<span class=\"hljs-title function_\">createComponent</span>(<span class=\"hljs-title class_\">BasketComponent</span>);\n  <span class=\"hljs-keyword\">const</span> syncService = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">SyncService</span>);\n  <span class=\"hljs-keyword\">const</span> spy = <span class=\"hljs-title function_\">spyOn</span>(syncService, <span class=\"hljs-string\">'sync'</span>);\n  fixture.<span class=\"hljs-title function_\">detectChanges</span>();\n\n  <span class=\"hljs-title function_\">expect</span>(spy).<span class=\"hljs-title function_\">toHaveBeenCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n  \n  <span class=\"hljs-comment\">// 총합이 변경되지 않아서 효과가 없습니다</span>\n  fixture.<span class=\"hljs-title function_\">detectChanges</span>();\n  <span class=\"hljs-title function_\">expect</span>(spy).<span class=\"hljs-title function_\">toHaveBeenCalledTimes</span>(<span class=\"hljs-number\">2</span>); \n})\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>우리는 바구니에 있는 금액을 늘릴 수 있고, 변경 감지의 또 다른 실행 후에 SyncService가 두 번 실행된 것을 볼 수 있어야 합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">'SyncService를 실행해야 합니다'</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> fixture = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">configureTestingModule</span>({\n    <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">BasketComponent</span>],\n  }).<span class=\"hljs-title function_\">createComponent</span>(<span class=\"hljs-title class_\">BasketComponent</span>);\n  <span class=\"hljs-keyword\">const</span> syncService = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">SyncService</span>);\n  <span class=\"hljs-keyword\">const</span> spy = <span class=\"hljs-title function_\">spyOn</span>(syncService, <span class=\"hljs-string\">'sync'</span>);\n  fixture.<span class=\"hljs-title function_\">detectChanges</span>();\n\n  <span class=\"hljs-title function_\">expect</span>(spy).<span class=\"hljs-title function_\">toHaveBeenCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">total</span>: <span class=\"hljs-title class_\">HTMLDivElement</span> = fixture.<span class=\"hljs-property\">debugElement</span>.<span class=\"hljs-title function_\">query</span>(\n    <span class=\"hljs-title class_\">By</span>.<span class=\"hljs-title function_\">css</span>(<span class=\"hljs-string\">'[data-testid=\"total\"]'</span>),\n  ).<span class=\"hljs-property\">nativeElement</span>;\n  <span class=\"hljs-title function_\">expect</span>(total.<span class=\"hljs-property\">textContent</span>).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-string\">'18'</span>);\n\n  fixture.<span class=\"hljs-property\">debugElement</span>\n    .<span class=\"hljs-title function_\">query</span>(<span class=\"hljs-title class_\">By</span>.<span class=\"hljs-title function_\">css</span>(<span class=\"hljs-string\">'[data-testid=\"btn-increase\"]'</span>))\n    .<span class=\"hljs-property\">nativeElement</span>.<span class=\"hljs-title function_\">click</span>();\n\n  fixture.<span class=\"hljs-title function_\">detectChanges</span>();\n  <span class=\"hljs-title function_\">expect</span>(spy).<span class=\"hljs-title function_\">toHaveBeenCalledTimes</span>(<span class=\"hljs-number\">2</span>);\n});\n</code></pre>\n<p>다음으로 변경 감지가 사용 불가능한 다른 테스트 유형으로 넘어가 봅시다.</p>\n<h1>변경 감지 없이 테스트하기</h1>\n<div class=\"content-ad\"></div>\n<p>BasketComponent의 로직을 BasketService로 추출했습니다:</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Injectable</span>({ <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">'root'</span> })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasketService</span> {\n  products = <span class=\"hljs-title function_\">signal</span>([\n    {\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>,\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Coffee'</span>,\n      <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">3</span>,\n      <span class=\"hljs-attr\">amount</span>: <span class=\"hljs-number\">1</span>,\n    },\n    { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Schnitzel'</span>, <span class=\"hljs-attr\">price</span>: <span class=\"hljs-number\">15</span>, <span class=\"hljs-attr\">amount</span>: <span class=\"hljs-number\">1</span> },\n  ]);\n\n  syncService = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">SyncService</span>);\n\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-title function_\">effect</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">syncService</span>.<span class=\"hljs-title function_\">sync</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">products</span>()));\n  }\n\n  totalPrice = <span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =></span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">products</span>().<span class=\"hljs-title function_\">reduce</span>(\n      <span class=\"hljs-function\">(<span class=\"hljs-params\">total, product</span>) =></span> total + product.<span class=\"hljs-property\">price</span> * product.<span class=\"hljs-property\">amount</span>,\n      <span class=\"hljs-number\">0</span>,\n    ),\n  );\n\n  <span class=\"hljs-title function_\">decrease</span>(<span class=\"hljs-params\">id: number</span>) {\n    <span class=\"hljs-variable language_\">this</span>.#<span class=\"hljs-title function_\">change</span>(id, <span class=\"hljs-function\">(<span class=\"hljs-params\">product</span>) =></span>\n      product.<span class=\"hljs-property\">amount</span> > <span class=\"hljs-number\">0</span> ? { ...product, <span class=\"hljs-attr\">amount</span>: product.<span class=\"hljs-property\">amount</span> - <span class=\"hljs-number\">1</span> } : product,\n    );\n  }\n\n  <span class=\"hljs-title function_\">increase</span>(<span class=\"hljs-params\">id: number</span>) {\n    <span class=\"hljs-variable language_\">this</span>.#<span class=\"hljs-title function_\">change</span>(id, <span class=\"hljs-function\">(<span class=\"hljs-params\">product</span>) =></span> ({ ...product, <span class=\"hljs-attr\">amount</span>: product.<span class=\"hljs-property\">amount</span> + <span class=\"hljs-number\">1</span> }));\n  }\n\n  #<span class=\"hljs-title function_\">change</span>(<span class=\"hljs-params\">id: number, callback: (product: Product) => Product</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">products</span>.<span class=\"hljs-title function_\">update</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">products</span>) =></span>\n      products.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">product</span>) =></span> {\n        <span class=\"hljs-keyword\">if</span> (product.<span class=\"hljs-property\">id</span> === id &#x26;&#x26; product.<span class=\"hljs-property\">amount</span> > <span class=\"hljs-number\">0</span>) {\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">callback</span>(product);\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-keyword\">return</span> product;\n        }\n      }),\n    );\n  }\n}\n\n@<span class=\"hljs-title class_\">Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-basket'</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&#x3C;!-- 이전과 같은 템플릿 -->'</span>,\n  <span class=\"hljs-attr\">standalone</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">imports</span>: [<span class=\"hljs-title class_\">MatButton</span>, <span class=\"hljs-title class_\">MatIcon</span>],\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BasketComponent</span> {\n  basketService = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BasketService</span>);\n\n  products = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">basketService</span>.<span class=\"hljs-property\">products</span>;\n  totalPrice = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">basketService</span>.<span class=\"hljs-property\">totalPrice</span>;\n\n  <span class=\"hljs-title function_\">decrease</span>(<span class=\"hljs-params\">id: number</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">basketService</span>.<span class=\"hljs-title function_\">decrease</span>(id);\n  }\n\n  <span class=\"hljs-title function_\">increase</span>(<span class=\"hljs-params\">id: number</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">basketService</span>.<span class=\"hljs-title function_\">increase</span>(id);\n  }\n}\n</code></pre>\n<p>이전의 테스트는 유지했습니다. 이제 Component와 두 개의 Service를 모두 커버합니다.</p>\n<p>BasketService만을 커버하는 테스트는 어떻게 작성할 수 있을까요?</p>\n<div class=\"content-ad\"></div>\n<p>우리는 Component가 없으므로 이제 fixture.detectChanges()를 실행할 수 없습니다. 따라서 ComponentFixture도 없습니다.</p>\n<h2>computed() 테스트</h2>\n<p>totalPrice Signal을 확인하는 SignalService 테스트는 다음과 같이 보일 것입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">'BasketService를 테스트해야 합니다'</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> basketService = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BasketService</span>);\n  <span class=\"hljs-title function_\">expect</span>(basketService.<span class=\"hljs-title function_\">totalPrice</span>()).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-number\">18</span>);\n\n  basketService.<span class=\"hljs-title function_\">increase</span>(<span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-title function_\">expect</span>(basketService.<span class=\"hljs-title function_\">totalPrice</span>()).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-number\">21</span>);\n});\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>위의 테스트는 작동합니다. 왜냐하면 totalPrice를 반응적으로 만들려면 변경 감지 실행이 필요한 것 아닌가요?</p>\n<p>맞아요. 그렇지만 우리의 경우에는 totalPrice를 반응적인 방식으로 사용하지 않아요. 우리는 totalPrice를 직접 호출해요.</p>\n<p>computed()를 기반으로 한 Signal은 언제든지, 종속성이 변경되었는지 알 수 있고 (즉, 더티 상태인지), 다시 처리해야 해요.</p>\n<p>다시 처리를 시작하려면, 누군가가 그 값을 요청할 때 까지 기다려야 해요.</p>\n<div class=\"content-ad\"></div>\n<p>'컴포넌트 테스트에서 \"호출자\"는 변경 감지였습니다. 테스트에서 우리가 그것을 했죠.</p>\n<h2>effect() 테스트하기</h2>\n<p>computed() 신호는 변경 감지 없이 간단히 테스트할 수 있지만, 실제 어려움은 effect()에서 발생합니다.</p>\n<p>computed()과 마찬가지로 effect()는 내부적으로 먼저 변경 유무를 알고 있습니다(의존성 중 하나가 값이 변경되었을 경우). 유감스럽게도 computed() 신호처럼 접근할 수는 없습니다.'</p>\n<div class=\"content-ad\"></div>\n<p>Angular 16에서 effect()를 테스트하는 유일한 방법은 Service를 \"Helper Component\"로 감싸는 것이었습니다. 그러나 Angular 17부터는 새로운 함수가 등장했습니다. 이 함수는 effect를 \"호출\"합니다: TestBed.flushEffects().</p>\n<p>이제 실제로 코드를 보겠습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">'BasketService를 테스트해야 합니다'</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> syncService = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">SyncService</span>);\n  <span class=\"hljs-keyword\">const</span> spy = <span class=\"hljs-title function_\">spyOn</span>(syncService, <span class=\"hljs-string\">'sync'</span>);\n\n  <span class=\"hljs-keyword\">const</span> basketService = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BasketService</span>);\n  <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">flushEffects</span>();\n\n  basketService.<span class=\"hljs-title function_\">increase</span>(<span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">flushEffects</span>();\n  <span class=\"hljs-title function_\">expect</span>(spy).<span class=\"hljs-title function_\">toHaveBeenCalledTimes</span>(<span class=\"hljs-number\">2</span>);\n});\n</code></pre>\n<p>다시 한 번 강조하면 Component 테스트와 동일한 동작을 볼 수 있습니다. effect()를 실행하려면 두 가지가 필요합니다:</p>\n<div class=\"content-ad\"></div>\n<ol>\n<li>effect() 함수는 더러워야 하고</li>\n<li>\"액티브 엑세스\"가 있어야 합니다.</li>\n</ol>\n<p>이 테스트들은 다시 실패할 것입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">'BasketService를 테스트해야 합니다'</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> syncService = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">SyncService</span>);\n  <span class=\"hljs-keyword\">const</span> spy = <span class=\"hljs-title function_\">spyOn</span>(syncService, <span class=\"hljs-string\">'sync'</span>);\n  <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BasketService</span>);\n\n  <span class=\"hljs-comment\">// effect가 실행되지 않았습니다</span>\n  <span class=\"hljs-title function_\">expect</span>(spy).<span class=\"hljs-title function_\">toHaveBeenCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n});\n\n<span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">'BasketService를 테스트해야 합니다'</span>, <span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-keyword\">const</span> syncService = <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">SyncService</span>);\n  <span class=\"hljs-keyword\">const</span> spy = <span class=\"hljs-title function_\">spyOn</span>(syncService, <span class=\"hljs-string\">'sync'</span>);\n  <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">BasketService</span>);\n\n  <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">flushEffects</span>();\n  <span class=\"hljs-title function_\">expect</span>(spy).<span class=\"hljs-title function_\">toHaveBeenCalledTimes</span>(<span class=\"hljs-number\">1</span>);\n\n  <span class=\"hljs-comment\">// effect가 더러우지 않았습니다</span>\n  <span class=\"hljs-title class_\">TestBed</span>.<span class=\"hljs-title function_\">flushEffects</span>();\n  <span class=\"hljs-title function_\">expect</span>(spy).<span class=\"hljs-title function_\">toHaveBeenCalledTimes</span>(<span class=\"hljs-number\">2</span>);\n});\n</code></pre>\n<h1>요약</h1>\n<div class=\"content-ad\"></div>\n<p>우리는 시그널을 사용하는 코드를 테스트할 때 \"Glitch-free\" 효과를 알아야 합니다.</p>\n<p>테스트에 변경 감지(Change Detection)가 포함되어 있는 경우, 해당 테스트는 우리 애플리케이션과 동일하게 작동합니다.</p>\n<p>변경 감지가 포함되지 않은 테스트 유형의 경우, 시그널을 직접 호출하고 TestBed.flushEffects()를 실행하여 \"dirty side effects\"를 실행해야 합니다.</p>\n<p>Repository에 접근할 수 있습니다:</p>\n<div class=\"content-ad\"></div>\n<p><a href=\"https://github.com/rainerhahnekamp/how-do-i-test\" rel=\"nofollow\" target=\"_blank\">https://github.com/rainerhahnekamp/how-do-i-test</a></p>\n<p>만약 여러분이 테스트 과제를 직면하고 저에게 도움 요청을 하고 싶다면 언제든지 연락해 주세요!</p>\n<p>추가 정보와 업데이트를 받으려면 LinkedIn에서 저와 연락하시거나 X와 함께 워크샵 및 테스팅에 관한 컨설팅 서비스를 탐색해 주세요.</p>\n<p><a href=\"https://www.angulararchitects.io/en/training/professional-angular-testing-playwright-edition/\" rel=\"nofollow\" target=\"_blank\">https://www.angulararchitects.io/en/training/professional-angular-testing-playwright-edition/</a></p>\n</body>\n</html>\n"},"__N_SSG":true}