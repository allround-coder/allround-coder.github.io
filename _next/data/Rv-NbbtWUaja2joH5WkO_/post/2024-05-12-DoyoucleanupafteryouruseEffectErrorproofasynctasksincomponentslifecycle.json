{"pageProps":{"post":{"title":"마무리는 제대로 했나요 컴포넌트 라이프사이클에서 오류가 발생하지 않게 하는 비동기 작업","description":"","date":"2024-05-12 23:20","slug":"2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle","content":"\n\nReact의 useEffect 훅은 함수 컴포넌트에서 부작용을 관리하는 강력한 도구입니다. 하지만 적절한 처리 없이 사용하면 코드베이스의 최악의 악몽이 될 수 있습니다. 오늘은 제가 즐겨 사용하는 API 중 하나인 TheCatAPI를 사용하여, useEffect에서 비동기 작업을 정리하는 방법에 초점을 맞추어 React 컴포넌트를 가능한 깨끗하고 효율적으로 유지하는 방법을 살펴보겠습니다.\n\n![이미지](/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_0.png)\n\n## useEffect에서 정리 작업이 중요한 이유\n\nReact 컴포넌트는 마운트되고 업데이트되며 마침내 언마운트됩니다. useEffect 훅을 사용하면 이러한 단계를 우회하여 코드를 실행할 수 있습니다. DOM을 조작하거나 서비스에 구독하거나 타이머를 설정하거나 데이터를 가져오는 등의 작업을 수행할 수 있습니다. 그러나 중요한 건 이러한 작업을 설정하는 것뿐 아니라 그것들을 언제, 어떻게 해제해야 하는지를 알고 있는 것입니다.\n\n\n\n적절한 정리가 없으면 애플리케이션이 더는 필요하지 않은 효과를 계속 실행하거나, 더 나쁜 경우에는 DOM에서 사라진 구성 요소를 참조할 수 있습니다. 이러한 문제는 성능 문제, 메모리 누수 및 디버깅하기 어려운 오류로 이어질 수 있습니다.\n\n# 먼저, 고양이 사진을 가져와 봅시다\n\n아마도 많은 분들이 이 고양이 서비스 API를 이미 알고 있을 겁니다. 이 글에서는 이미지 엔드포인트만 사용할 것입니다. 만약 이 API에 대해 더 알고 싶다면, 이 링크를 확인해보세요:\n\n프로그램이 초기 페이지 로드 시 10개의 고양이 사진을 표시하도록 해 봅시다.\n\n\n\n```js\nimport { useState, useEffect } from \"react\";\n\nfunction App() {\n  const [catImageUrl, setCatImageUrl] = useState([]);\n\n  useEffect(() => {\n    const fetchCatImage = async () => {\n      try {\n        const response = await fetch(\n          `https://api.thecatapi.com/v1/images/search?limit=10&api_key=${APIKEY}`\n        );\n        const data = await response.json();\n        if (data.length > 0) {\n          const imageURLS = data.map((obj) => obj.url);\n          setCatImageUrl(imageURLS); // 첫 번째 이미지 URL을 설정하려 가정합니다\n        }\n      } catch (error) {\n        console.error(\"데이터를 가져오는 중 오류 발생:\", error);\n      }\n    };\n\n    fetchCatImage();\n  }, []); // 의존성 배열이 비어 있어서 효과가 한 번만 실행됩니다\n\n  return (\n    <>\n      <h1>당신의 하루 고양이 사진</h1>\n      <div\n        style={{\n          display: \"flex\",\n          flexWrap: \"wrap\",\n          gap: \"10px\",\n        }}\n      >\n        {catImageUrl.map((url, index) => (\n          <img\n            key={index}\n            src={url}\n            alt=\"랜덤한 고양이\"\n            style={{ flex: \"0 0 200px\", height: \"200px\" }}\n          />\n        ))}\n      </div>\n    </>\n  );\n}\n```\n\n<img src=\"/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_1.png\" />\n\n아주 좋아요, 의도한 대로 10개의 고양이 사진을 요청했지만 잠재적인 문제가 있습니다: 데이터 가져오기가 비동기적인 것으로 인해 작업이 완료되기 전에 컴포넌트가 언마운트될 수 있습니다 (예: 경로 변경 또는 DOM에서 컴포넌트가 제거되는 경우). 그런 경우에 컴포넌트가 언마운트된 상태에서 상태를 업데이트하려고 하면 \"Can’t perform a React state update on an unmounted component\"와 같은 오류가 발생할 수 있습니다.\n\nuseEffect 내에서 데이터를 가져올 때 주요 도전 과제는 컴포넌트의 라이프사이클을 처리하는 것입니다.\n\n\n\n\n그러니까, 코드에 버그가 없도록 정리를 해봅시다!\n\n# 효과에서 직접 함수를 반환하기\n\nReact의 useEffect 훅을 사용할 때, 정리를 처리하는 일반적이고 권장되는 방법은 효과에서 직접 함수를 반환하는 것입니다.\n\n```js\nuseEffect(() => {\n  // 코드 로직\n\n  return () => {\n    // 정리 작업 \n  };\n}, []); //효과가 한 번만 발생해야 하는 경우, 의존성을 비워둡니다\n```\n\n\n\n# 효율적인 데이터 가져오기 정리를 위해 AbortController 사용\n\nAbortController는 현대 브라우저와 node-fetch를 사용하는 Node.js 환경에서 널리 지원되지만, 모든 환경에서 지원되지 않을 수 있다는 점을 고려하는 것이 중요합니다 (예: IE의 모든 버전이나 일부 오래된 브라우저).\n\nAbortController를 사용하면 fetch가 시작된 시점에 컨트롤러 신호를 추가하여 fetch 요청을 취소할 수 있습니다. isMounted 플래그를 사용하는 것과 비교해 (곧 다룰 예정), fetch 요청과 같은 비동기 작업을 취소하는 표준화된 방법을 제공합니다.\n\n먼저, 새 AbortController를 만들어야 합니다:\n\n\n\n```js\nconst controller = new AbortController();\nconst { signal } = controller;\n```\n\nAbortController 인스턴스를 생성하면 signal 속성을 포함한 객체가 반환됩니다. 이 signal은 fetch 요청이 중단되어야 함을 신호하는데 사용되는 AbortSignal의 인스턴스입니다.\n\n그런 다음 signal을 옵션 객체로 fetch 요청에 전달할 수 있습니다. 이를 통해 컨트롤러의 signal을 fetch 요청과 연결할 수 있습니다.\n\n```js\nconst fetchCatImage = async () => {\n      try {\n        const response = await fetch(\n          `https://api.thecatapi.com/v1/images/search?limit=10&api_key=${APIKEY}`, { signal } // 이곳에 signal 전달\n      );\n        const data = await response.json();\n        if (data.length > 0) {\n          const imageURLS = data.map((obj) => obj.url);\n          setCatImageUrl(imageURLS);\n        }\n      } catch (error) {\n        if (error.name === \"AbortError\") {\n          console.log(\"Fetch aborted\"); // fetch가 중단된 경우 처리\n        } else {\n          console.error(\"데이터를 불러오는 중 오류 발생:\", error); // 다른 오류 처리\n        }\n      }\n    };\n    \n    fetchCatImage();\n\n    return () => {\n      controller.abort(); // 컴포넌트가 언마운트 될 때 fetch 요청 중단\n    };\n  }, []);\n```\n\n\n\n\"AbortError\"은 AbortController에서 abort() 함수가 호출될 때 발생하는 고유한 오류 객체입니다. catch 블록에서 AbortError에 대한 특정 메시지를 추가할 수 있습니다.\n\n이제 각 새로운 효과가 발생하기 전이나 컴포넌트가 마운트 해제되기 바로 전에 fetch 요청이 즉시 취소됩니다.\n\nAbortController를 useEffect 정리 함수와 함께 사용하면 React에서 비동기 작업을 처리하는 견고한 해결책을 제공할 수 있습니다. 이 패턴을 사용하면 컴포넌트가 마운트 해제된 후에 상태를 업데이트하려고 시도하지 않도록 보장할 수 있습니다.\n\n# IsMounted 플래그 설정:\n\n\n\n오래된 브라우저나 제한된 JavaScript 환경에서 개발 중이라면 IsMounted 플래그를 사용하면 간단한 대안이 될 수 있습니다.\n\n컴포넌트가 초기에 마운트될 때 isMounted를 true로 설정합니다. 컴포넌트가 여전히 마운트된 상태인 경우에만 상태를 업데이트합니다. 마지막으로 useEffect에서 반환된 정리 함수에서 컴포넌트가 마운트 해제되면 isMounted를 false로 설정하여 컴포넌트가 마운트 해제된 후 데이터 가져오기가 완료된 경우 상태 업데이트를 방지합니다.\n\n```js\n  useEffect(() => {\n    let isMounted = true; // 컴포넌트가 마운트된 상태를 추적하는 플래그\n\n    const fetchCatImage = async () => {\n      try {\n        const response = await fetch(\n          `https://api.thecatapi.com/v1/images/search?limit=10&api_key=${APIKEY}`\n        );\n        const data = await response.json();\n        if (isMounted && data.length > 0) {\n          const imageURLS = data.map((obj) => obj.url);\n          setCatImageUrl(imageURLS);\n        }\n      } catch (error) {\n        console.error(\"데이터를 불러오는 중 오류 발생:\", error);\n      }\n    };\n\n    fetchCatImage();\n\n    return () => {\n      isMounted = false; // 컴포넌트가 언마운트될 때 isMounted를 false로 설정하여 정리\n    };\n  }, []);\n```\n\n그러니, 간략히 정리하면:\n\n\n\n- useEffect 정리: 권장하는 방법은 정리를 수행하는 함수를 직접 반환하는 것입니다.\n- AbortController 사용: 대부분의 경우에 해당합니다. 주요 비동기 작업(예: 데이터 가져오기)에 신호를 첨부하고 정리 함수에서 컨트롤러를 중지합니다.\n- isMounted 플래그 사용: 일부 오래된 환경이나 제한적인 환경에서 AbortController을 지원하지 않을 때\n\n여기까지 하면 useEffect가 스스로 정리할 수 있어요! 고양이 사진을 즐기세요!\n\n이 게시물을 읽어주셔서 감사합니다!! 💜\n\n게시물이 마음에 들었다면 👏 또는 댓글을 남겨주세요.\n\n\n\n질문이나 제안이 있으시거나 저와 함께 일하고 싶으시다면 언제든지 연락해 주세요:\n\n- 이메일: renashen314@gmail.com\n- LinkedIn","ogImage":{"url":"/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_0.png"},"coverImage":"/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_0.png","tag":["Tech"],"readingTime":6},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>React의 useEffect 훅은 함수 컴포넌트에서 부작용을 관리하는 강력한 도구입니다. 하지만 적절한 처리 없이 사용하면 코드베이스의 최악의 악몽이 될 수 있습니다. 오늘은 제가 즐겨 사용하는 API 중 하나인 TheCatAPI를 사용하여, useEffect에서 비동기 작업을 정리하는 방법에 초점을 맞추어 React 컴포넌트를 가능한 깨끗하고 효율적으로 유지하는 방법을 살펴보겠습니다.</p>\n<p><img src=\"/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_0.png\" alt=\"이미지\"></p>\n<h2>useEffect에서 정리 작업이 중요한 이유</h2>\n<p>React 컴포넌트는 마운트되고 업데이트되며 마침내 언마운트됩니다. useEffect 훅을 사용하면 이러한 단계를 우회하여 코드를 실행할 수 있습니다. DOM을 조작하거나 서비스에 구독하거나 타이머를 설정하거나 데이터를 가져오는 등의 작업을 수행할 수 있습니다. 그러나 중요한 건 이러한 작업을 설정하는 것뿐 아니라 그것들을 언제, 어떻게 해제해야 하는지를 알고 있는 것입니다.</p>\n<p>적절한 정리가 없으면 애플리케이션이 더는 필요하지 않은 효과를 계속 실행하거나, 더 나쁜 경우에는 DOM에서 사라진 구성 요소를 참조할 수 있습니다. 이러한 문제는 성능 문제, 메모리 누수 및 디버깅하기 어려운 오류로 이어질 수 있습니다.</p>\n<h1>먼저, 고양이 사진을 가져와 봅시다</h1>\n<p>아마도 많은 분들이 이 고양이 서비스 API를 이미 알고 있을 겁니다. 이 글에서는 이미지 엔드포인트만 사용할 것입니다. 만약 이 API에 대해 더 알고 싶다면, 이 링크를 확인해보세요:</p>\n<p>프로그램이 초기 페이지 로드 시 10개의 고양이 사진을 표시하도록 해 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { useState, useEffect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">App</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> [catImageUrl, setCatImageUrl] = <span class=\"hljs-title function_\">useState</span>([]);\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fetchCatImage</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) => {\n      <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(\n          <span class=\"hljs-string\">`https://api.thecatapi.com/v1/images/search?limit=10&#x26;api_key=<span class=\"hljs-subst\">${APIKEY}</span>`</span>\n        );\n        <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n        <span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-property\">length</span> > <span class=\"hljs-number\">0</span>) {\n          <span class=\"hljs-keyword\">const</span> imageURLS = data.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">obj</span>) =></span> obj.<span class=\"hljs-property\">url</span>);\n          <span class=\"hljs-title function_\">setCatImageUrl</span>(imageURLS); <span class=\"hljs-comment\">// 첫 번째 이미지 URL을 설정하려 가정합니다</span>\n        }\n      } <span class=\"hljs-keyword\">catch</span> (error) {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">\"데이터를 가져오는 중 오류 발생:\"</span>, error);\n      }\n    };\n\n    <span class=\"hljs-title function_\">fetchCatImage</span>();\n  }, []); <span class=\"hljs-comment\">// 의존성 배열이 비어 있어서 효과가 한 번만 실행됩니다</span>\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h1</span>></span>당신의 하루 고양이 사진<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h1</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>\n        <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span>\n          <span class=\"hljs-attr\">display:</span> \"<span class=\"hljs-attr\">flex</span>\",\n          <span class=\"hljs-attr\">flexWrap:</span> \"<span class=\"hljs-attr\">wrap</span>\",\n          <span class=\"hljs-attr\">gap:</span> \"<span class=\"hljs-attr\">10px</span>\",\n        }}\n      ></span>\n        {catImageUrl.map((url, index) => (\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">img</span>\n            <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{index}</span>\n            <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">{url}</span>\n            <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"랜덤한 고양이\"</span>\n            <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">flex:</span> \"<span class=\"hljs-attr\">0</span> <span class=\"hljs-attr\">0</span> <span class=\"hljs-attr\">200px</span>\", <span class=\"hljs-attr\">height:</span> \"<span class=\"hljs-attr\">200px</span>\" }}\n          /></span>\n        ))}\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/></span></span>\n  );\n}\n</code></pre>\n<img src=\"/assets/img/2024-05-12-DoyoucleanupafteryouruseEffectErrorproofasynctasksincomponentslifecycle_1.png\">\n<p>아주 좋아요, 의도한 대로 10개의 고양이 사진을 요청했지만 잠재적인 문제가 있습니다: 데이터 가져오기가 비동기적인 것으로 인해 작업이 완료되기 전에 컴포넌트가 언마운트될 수 있습니다 (예: 경로 변경 또는 DOM에서 컴포넌트가 제거되는 경우). 그런 경우에 컴포넌트가 언마운트된 상태에서 상태를 업데이트하려고 하면 \"Can’t perform a React state update on an unmounted component\"와 같은 오류가 발생할 수 있습니다.</p>\n<p>useEffect 내에서 데이터를 가져올 때 주요 도전 과제는 컴포넌트의 라이프사이클을 처리하는 것입니다.</p>\n<p>그러니까, 코드에 버그가 없도록 정리를 해봅시다!</p>\n<h1>효과에서 직접 함수를 반환하기</h1>\n<p>React의 useEffect 훅을 사용할 때, 정리를 처리하는 일반적이고 권장되는 방법은 효과에서 직접 함수를 반환하는 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n  <span class=\"hljs-comment\">// 코드 로직</span>\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-comment\">// 정리 작업 </span>\n  };\n}, []); <span class=\"hljs-comment\">//효과가 한 번만 발생해야 하는 경우, 의존성을 비워둡니다</span>\n</code></pre>\n<h1>효율적인 데이터 가져오기 정리를 위해 AbortController 사용</h1>\n<p>AbortController는 현대 브라우저와 node-fetch를 사용하는 Node.js 환경에서 널리 지원되지만, 모든 환경에서 지원되지 않을 수 있다는 점을 고려하는 것이 중요합니다 (예: IE의 모든 버전이나 일부 오래된 브라우저).</p>\n<p>AbortController를 사용하면 fetch가 시작된 시점에 컨트롤러 신호를 추가하여 fetch 요청을 취소할 수 있습니다. isMounted 플래그를 사용하는 것과 비교해 (곧 다룰 예정), fetch 요청과 같은 비동기 작업을 취소하는 표준화된 방법을 제공합니다.</p>\n<p>먼저, 새 AbortController를 만들어야 합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> controller = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AbortController</span>();\n<span class=\"hljs-keyword\">const</span> { signal } = controller;\n</code></pre>\n<p>AbortController 인스턴스를 생성하면 signal 속성을 포함한 객체가 반환됩니다. 이 signal은 fetch 요청이 중단되어야 함을 신호하는데 사용되는 AbortSignal의 인스턴스입니다.</p>\n<p>그런 다음 signal을 옵션 객체로 fetch 요청에 전달할 수 있습니다. 이를 통해 컨트롤러의 signal을 fetch 요청과 연결할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fetchCatImage</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) => {\n      <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(\n          <span class=\"hljs-string\">`https://api.thecatapi.com/v1/images/search?limit=10&#x26;api_key=<span class=\"hljs-subst\">${APIKEY}</span>`</span>, { signal } <span class=\"hljs-comment\">// 이곳에 signal 전달</span>\n      );\n        <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n        <span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-property\">length</span> > <span class=\"hljs-number\">0</span>) {\n          <span class=\"hljs-keyword\">const</span> imageURLS = data.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">obj</span>) =></span> obj.<span class=\"hljs-property\">url</span>);\n          <span class=\"hljs-title function_\">setCatImageUrl</span>(imageURLS);\n        }\n      } <span class=\"hljs-keyword\">catch</span> (error) {\n        <span class=\"hljs-keyword\">if</span> (error.<span class=\"hljs-property\">name</span> === <span class=\"hljs-string\">\"AbortError\"</span>) {\n          <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"Fetch aborted\"</span>); <span class=\"hljs-comment\">// fetch가 중단된 경우 처리</span>\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">\"데이터를 불러오는 중 오류 발생:\"</span>, error); <span class=\"hljs-comment\">// 다른 오류 처리</span>\n        }\n      }\n    };\n    \n    <span class=\"hljs-title function_\">fetchCatImage</span>();\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> {\n      controller.<span class=\"hljs-title function_\">abort</span>(); <span class=\"hljs-comment\">// 컴포넌트가 언마운트 될 때 fetch 요청 중단</span>\n    };\n  }, []);\n</code></pre>\n<p>\"AbortError\"은 AbortController에서 abort() 함수가 호출될 때 발생하는 고유한 오류 객체입니다. catch 블록에서 AbortError에 대한 특정 메시지를 추가할 수 있습니다.</p>\n<p>이제 각 새로운 효과가 발생하기 전이나 컴포넌트가 마운트 해제되기 바로 전에 fetch 요청이 즉시 취소됩니다.</p>\n<p>AbortController를 useEffect 정리 함수와 함께 사용하면 React에서 비동기 작업을 처리하는 견고한 해결책을 제공할 수 있습니다. 이 패턴을 사용하면 컴포넌트가 마운트 해제된 후에 상태를 업데이트하려고 시도하지 않도록 보장할 수 있습니다.</p>\n<h1>IsMounted 플래그 설정:</h1>\n<p>오래된 브라우저나 제한된 JavaScript 환경에서 개발 중이라면 IsMounted 플래그를 사용하면 간단한 대안이 될 수 있습니다.</p>\n<p>컴포넌트가 초기에 마운트될 때 isMounted를 true로 설정합니다. 컴포넌트가 여전히 마운트된 상태인 경우에만 상태를 업데이트합니다. 마지막으로 useEffect에서 반환된 정리 함수에서 컴포넌트가 마운트 해제되면 isMounted를 false로 설정하여 컴포넌트가 마운트 해제된 후 데이터 가져오기가 완료된 경우 상태 업데이트를 방지합니다.</p>\n<pre><code class=\"hljs language-js\">  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">let</span> isMounted = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 컴포넌트가 마운트된 상태를 추적하는 플래그</span>\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fetchCatImage</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) => {\n      <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(\n          <span class=\"hljs-string\">`https://api.thecatapi.com/v1/images/search?limit=10&#x26;api_key=<span class=\"hljs-subst\">${APIKEY}</span>`</span>\n        );\n        <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n        <span class=\"hljs-keyword\">if</span> (isMounted &#x26;&#x26; data.<span class=\"hljs-property\">length</span> > <span class=\"hljs-number\">0</span>) {\n          <span class=\"hljs-keyword\">const</span> imageURLS = data.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">obj</span>) =></span> obj.<span class=\"hljs-property\">url</span>);\n          <span class=\"hljs-title function_\">setCatImageUrl</span>(imageURLS);\n        }\n      } <span class=\"hljs-keyword\">catch</span> (error) {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">\"데이터를 불러오는 중 오류 발생:\"</span>, error);\n      }\n    };\n\n    <span class=\"hljs-title function_\">fetchCatImage</span>();\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> {\n      isMounted = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// 컴포넌트가 언마운트될 때 isMounted를 false로 설정하여 정리</span>\n    };\n  }, []);\n</code></pre>\n<p>그러니, 간략히 정리하면:</p>\n<ul>\n<li>useEffect 정리: 권장하는 방법은 정리를 수행하는 함수를 직접 반환하는 것입니다.</li>\n<li>AbortController 사용: 대부분의 경우에 해당합니다. 주요 비동기 작업(예: 데이터 가져오기)에 신호를 첨부하고 정리 함수에서 컨트롤러를 중지합니다.</li>\n<li>isMounted 플래그 사용: 일부 오래된 환경이나 제한적인 환경에서 AbortController을 지원하지 않을 때</li>\n</ul>\n<p>여기까지 하면 useEffect가 스스로 정리할 수 있어요! 고양이 사진을 즐기세요!</p>\n<p>이 게시물을 읽어주셔서 감사합니다!! 💜</p>\n<p>게시물이 마음에 들었다면 👏 또는 댓글을 남겨주세요.</p>\n<p>질문이나 제안이 있으시거나 저와 함께 일하고 싶으시다면 언제든지 연락해 주세요:</p>\n<ul>\n<li>이메일: <a href=\"mailto:renashen314@gmail.com\">renashen314@gmail.com</a></li>\n<li>LinkedIn</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}