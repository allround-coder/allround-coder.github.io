{"pageProps":{"post":{"title":"Angular v18에서 RedirectCommand를 사용하여 Redirect Guards 및 Resolvers 다루기","description":"","date":"2024-06-20 03:05","slug":"2024-06-20-RedirectingGuardsandResolversinAngularv18withRedirectCommand","content":"\n\n웹 개발의 현대 시대에서는 동적이고 인터랙티브한 애플리케이션을 만드는 것이 일반적입니다. 특정 사용자에게 독점적이거나 특정 조건에서 사용 가능한 기능을 구현하는 것은 매우 복잡한 도전일 수 있습니다.\n\n그래서 Angular는 Routes, rules, 그리고 components에 기반한 라우팅 시스템을 제공하여 쉽게 애플리케이션을 디자인할 수 있게 합니다.\n\n이 글에서는 Angular v18에서 소개된 새로운 기능을 사용하여 사용자를 다른 곳으로 리디렉션하는 Routes를 보호하는 방법에 대해 논의할 것입니다.\n\n그러나 진행하기 전에 Angular 라우터에 대해 간단히 리뷰해보겠습니다...\n\n<div class=\"content-ad\"></div>\n\n# Angular 라우터 가드 및 리졸버\n\nAngular 라우터 라이브러리를 사용하면 Angular 애플리케이션 내에서 네비게이션을 관리할 수 있으며 Routes 목록을 정의할 수 있습니다.\n\n각 Route는 접근 경로, 로드할 Angular 컴포넌트, 하위 Routes 등과 같은 일련의 정보로 정의됩니다.\n\n```js\nimport { Route } from '@angular/router';\nimport { MyFeatureComponent, MyFeatureGuard } from './my-feature';\n\nconst routes: Route[] = [\n  {\n    path: 'my-feature',\n    component: MyFeatureComponent,\n    canActivate: [MyFeatureGuard],\n    data: {\n      id: \"my-feature-id\"\n    }\n  }\n];\n```\n\n<div class=\"content-ad\"></div>\n\n하나 이상의 루트를 보호하여 특정 조건에 따라 접근 또는 빠져나갈 수 있습니다. 이는 가드라고 불리는 함수를 사용합니다.\n\n```js\nimport { Route } from '@angular/router';\nimport { MyService } from './my-feature';\n\nconst myRoute: Route = [\n  path: 'my-feature',\n  canMatch: [() => inject(MyService).canMatch()],\n  canActivate: [() => inject(MyService).canActivate()],\n  canActivateChild: [() => inject(MyService).canActivateChild()],\n  canDeactivate: [() => inject(MyService).canDeactivate()],\n];\n```\n\nAngular 가드에는 다음과 같이 네 가지 유형이 있습니다. 각각의 역할은 다릅니다:\n\n- canMatch: 루트가 로드될 수 있는지 확인하는 데 사용됩니다. 하나의 경로에 대해 여러 루트를 정의하고 특정 조건에 따라 하나만 선택하려면 이 가드를 사용할 수 있습니다.\n- canActivate: 특정 루트를 활성화할 수 있는지 여부를 결정하는 데 사용됩니다. 예를 들어, 특정 사용자만 접근할 수 있는 페이지에 대한 액세스를 제어하는 데 사용할 수 있습니다.\n- canActivateChild: canActivate와 유사하지만, 주 루트의 자식 루트에 대한 액세스도 제어합니다. 다른 자식 루트에서 시작되었더라도 모든 자식 루트로의 네비게이션에 대해 실행됩니다.\n- canDeactivate: 사용자가 특정 루트에서 빠져나갈 수 있는지를 확인하는 데 사용됩니다. 예를 들어 페이지를 떠날 때 확인을 요청하는 데 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n더불어 Route에 데이터를 준비하기 위해 Resolver 함수를 사용할 수 있습니다:\n\n```js\nimport { Route } from '@angular/router';\nimport { MyService } from './my-feature';\n\nconst myRoute: Route = [\n  path: 'my-feature',\n  resolve: {\n    user: () => inject(MyService).getUserInfo(),\n    config: () => inject(MyService).getUserConfig()\n  }\n];\n```\n\nResolver를 사용하는 것은 Route에 액세스하기 전에 데이터의 존재 여부를 보장하고 페이지에서 누락된 데이터를 처리하지 않도록 하는 훌륭한 접근 방식입니다.\n\n<img src=\"/assets/img/2024-06-20-RedirectingGuardsandResolversinAngularv18withRedirectCommand_0.png\" />\n\n<div class=\"content-ad\"></div>\n\n기초 사항을 다루었으니 이제 라우트를 보호하기 위해 사용자를 다른 곳으로 리디렉션하는 방법을 살펴보겠습니다.\n\n# 가드(Guards) 및 리졸버(Resolvers) 사용하여 네비게이션을 리디렉트하기\n\nAngular 가드(Guards)를 사용하면 하나 이상의 라우트 접근 또는 종료를 막아 네비게이션을 차단할 수 있습니다.\n\n그러나 더 부드러운 사용자 경험을 보장하기 위해서는 종종 사용자를 다른 라우트로 리디렉트하는 것이 선호됩니다.\n\n<div class=\"content-ad\"></div>\n\n가드 덕분에 매우 쉽게 이것을 달성할 수 있습니다. 현재 내비게이션을 차단하기 전에 새로운 내비게이션을 시작할 수 있습니다. \n\n```js\nimport { inject } from '@angular/core';\nimport { Route, Router } from '@angular/router';\nimport { MyPage } from './pages/my-page';\n\nconst route: Route = {\n  path: 'my-page',\n  component: MyPage,\n  canActivate: [\n    () => {\n      const router = inject(Router);\n\n      router.navigate(['./my-other-page']);\n      return false;\n    },\n  ],\n};\n```\n\nResolver를 사용하여 비슷한 결과를 얻을 수도 있습니다. Resolver를 이용하여 내부에서 새로운 내비게이션을 시작할 수 있습니다.\n\n```js\nimport { Route, Router } from '@angular/router';\nimport { MyService } from './my-feature';\n\nconst myRoute: Route = [\n  path: 'my-feature',\n  resolve: {\n    user: () => {\n      const router = inject(Router);\n\n      router.navigate(['./my-other-page']);\n      return null;\n    }\n  }\n];\n```\n\n<div class=\"content-ad\"></div>\n\n## UrlTree를 사용한 Redirect\n\n또 다른 방법으로, Guards와 Resolvers를 사용하여 새로운 Route를 나타내는 UrlTree를 반환함으로써 네비게이션을 리다이렉트할 수 있습니다:\n\n```js\nimport { inject } from '@angular/core';\nimport { Route, Router, UrlTree } from '@angular/router';\nimport { MyPage } from './pages/my-page';\n\nconst route: Route = {\n  path: 'my-page',\n  component: MyPage,\n  canActivate: [\n    () => {\n      const router: Router = inject(Router);\n\n      const urlTree: UrlTree = router.parseUrl('./my-other-page');\n      return urlTree;\n    },\n  ],\n};\n```\n\n그러나 이 기술은 이전 기술이 허용하는 NavigationExtras를 사용하여 네비게이션을 리다이렉트하는 것을 허용하지는 않습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\ncanActivate: [\n  () => {\n    const router = inject(Router);\n\n    router.navigate(['./my-other-page'], { skipLocationChange: true });\n    return false;\n  }\n]\n```\n\n## Redirect with RedirectCommand\n\n해결책으로 Angular v18에서는 NavigationExtras를 처리할 수 있는 새로운 RedirectCommand 클래스를 소개했습니다. 이를 통해 Guards 및 Resolvers에서 네비게이션을 리다이렉트할 수 있습니다:\n\n```js\nimport { inject } from '@angular/core';\nimport { RedirectCommand, Route, Router, UrlTree } from '@angular/router';\nimport { MyPage } from './pages/my-page';\n\nconst route: Route = {\n  path: 'my-page',\n  component: MyPage,\n  canActivate: [\n    () => {\n      const router: Router = inject(Router);\n      const urlTree: UrlTree = router.parseUrl('./my-other-page');\n\n      return new RedirectCommand(urlTree, { skipLocationChange: true });\n    },\n  ],\n};\n```\n\n<div class=\"content-ad\"></div>\n\n이 새로운 RedirectCommand 클래스의 도입은 가드 및 리졸버의 유지 보수성을 크게 향상시킵니다.\n\n![RedirectingGuardsandResolversinAngularv18withRedirectCommand_1](/assets/img/2024-06-20-RedirectingGuardsandResolversinAngularv18withRedirectCommand_1.png)\n\n특히 이러한 사용 사례에 특별히 설계된 이 클래스는 앞으로 필요한 새로운 매개변수에 쉽게 대응할 수 있습니다.\n\n# 지금까지 읽어 주셔서 감사합니다 🙏\n\n<div class=\"content-ad\"></div>\n\n피드백을 주실 수 있다면 댓글을 남겨주세요. 👏\n\n그리고 정말 좋았다면 꼭 여러분의 커뮤니티, 기술 관련 그룹, 원하시는 분들과 공유해주세요. 그리고 LinkedIn 팔로우도 잊지마세요. 👋😁","ogImage":{"url":"/assets/img/2024-06-20-RedirectingGuardsandResolversinAngularv18withRedirectCommand_0.png"},"coverImage":"/assets/img/2024-06-20-RedirectingGuardsandResolversinAngularv18withRedirectCommand_0.png","tag":["Tech"],"readingTime":6},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>웹 개발의 현대 시대에서는 동적이고 인터랙티브한 애플리케이션을 만드는 것이 일반적입니다. 특정 사용자에게 독점적이거나 특정 조건에서 사용 가능한 기능을 구현하는 것은 매우 복잡한 도전일 수 있습니다.</p>\n<p>그래서 Angular는 Routes, rules, 그리고 components에 기반한 라우팅 시스템을 제공하여 쉽게 애플리케이션을 디자인할 수 있게 합니다.</p>\n<p>이 글에서는 Angular v18에서 소개된 새로운 기능을 사용하여 사용자를 다른 곳으로 리디렉션하는 Routes를 보호하는 방법에 대해 논의할 것입니다.</p>\n<p>그러나 진행하기 전에 Angular 라우터에 대해 간단히 리뷰해보겠습니다...</p>\n<div class=\"content-ad\"></div>\n<h1>Angular 라우터 가드 및 리졸버</h1>\n<p>Angular 라우터 라이브러리를 사용하면 Angular 애플리케이션 내에서 네비게이션을 관리할 수 있으며 Routes 목록을 정의할 수 있습니다.</p>\n<p>각 Route는 접근 경로, 로드할 Angular 컴포넌트, 하위 Routes 등과 같은 일련의 정보로 정의됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Route</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/router'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">MyFeatureComponent</span>, <span class=\"hljs-title class_\">MyFeatureGuard</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./my-feature'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">routes</span>: <span class=\"hljs-title class_\">Route</span>[] = [\n  {\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'my-feature'</span>,\n    <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">MyFeatureComponent</span>,\n    <span class=\"hljs-attr\">canActivate</span>: [<span class=\"hljs-title class_\">MyFeatureGuard</span>],\n    <span class=\"hljs-attr\">data</span>: {\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">\"my-feature-id\"</span>\n    }\n  }\n];\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>하나 이상의 루트를 보호하여 특정 조건에 따라 접근 또는 빠져나갈 수 있습니다. 이는 가드라고 불리는 함수를 사용합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Route</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/router'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">MyService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./my-feature'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">myRoute</span>: <span class=\"hljs-title class_\">Route</span> = [\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'my-feature'</span>,\n  <span class=\"hljs-attr\">canMatch</span>: [<span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">MyService</span>).<span class=\"hljs-title function_\">canMatch</span>()],\n  <span class=\"hljs-attr\">canActivate</span>: [<span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">MyService</span>).<span class=\"hljs-title function_\">canActivate</span>()],\n  <span class=\"hljs-attr\">canActivateChild</span>: [<span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">MyService</span>).<span class=\"hljs-title function_\">canActivateChild</span>()],\n  <span class=\"hljs-attr\">canDeactivate</span>: [<span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">MyService</span>).<span class=\"hljs-title function_\">canDeactivate</span>()],\n];\n</code></pre>\n<p>Angular 가드에는 다음과 같이 네 가지 유형이 있습니다. 각각의 역할은 다릅니다:</p>\n<ul>\n<li>canMatch: 루트가 로드될 수 있는지 확인하는 데 사용됩니다. 하나의 경로에 대해 여러 루트를 정의하고 특정 조건에 따라 하나만 선택하려면 이 가드를 사용할 수 있습니다.</li>\n<li>canActivate: 특정 루트를 활성화할 수 있는지 여부를 결정하는 데 사용됩니다. 예를 들어, 특정 사용자만 접근할 수 있는 페이지에 대한 액세스를 제어하는 데 사용할 수 있습니다.</li>\n<li>canActivateChild: canActivate와 유사하지만, 주 루트의 자식 루트에 대한 액세스도 제어합니다. 다른 자식 루트에서 시작되었더라도 모든 자식 루트로의 네비게이션에 대해 실행됩니다.</li>\n<li>canDeactivate: 사용자가 특정 루트에서 빠져나갈 수 있는지를 확인하는 데 사용됩니다. 예를 들어 페이지를 떠날 때 확인을 요청하는 데 사용할 수 있습니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>더불어 Route에 데이터를 준비하기 위해 Resolver 함수를 사용할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Route</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/router'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">MyService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./my-feature'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">myRoute</span>: <span class=\"hljs-title class_\">Route</span> = [\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'my-feature'</span>,\n  <span class=\"hljs-attr\">resolve</span>: {\n    <span class=\"hljs-attr\">user</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">MyService</span>).<span class=\"hljs-title function_\">getUserInfo</span>(),\n    <span class=\"hljs-attr\">config</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">MyService</span>).<span class=\"hljs-title function_\">getUserConfig</span>()\n  }\n];\n</code></pre>\n<p>Resolver를 사용하는 것은 Route에 액세스하기 전에 데이터의 존재 여부를 보장하고 페이지에서 누락된 데이터를 처리하지 않도록 하는 훌륭한 접근 방식입니다.</p>\n<img src=\"/assets/img/2024-06-20-RedirectingGuardsandResolversinAngularv18withRedirectCommand_0.png\">\n<div class=\"content-ad\"></div>\n<p>기초 사항을 다루었으니 이제 라우트를 보호하기 위해 사용자를 다른 곳으로 리디렉션하는 방법을 살펴보겠습니다.</p>\n<h1>가드(Guards) 및 리졸버(Resolvers) 사용하여 네비게이션을 리디렉트하기</h1>\n<p>Angular 가드(Guards)를 사용하면 하나 이상의 라우트 접근 또는 종료를 막아 네비게이션을 차단할 수 있습니다.</p>\n<p>그러나 더 부드러운 사용자 경험을 보장하기 위해서는 종종 사용자를 다른 라우트로 리디렉트하는 것이 선호됩니다.</p>\n<div class=\"content-ad\"></div>\n<p>가드 덕분에 매우 쉽게 이것을 달성할 수 있습니다. 현재 내비게이션을 차단하기 전에 새로운 내비게이션을 시작할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Route</span>, <span class=\"hljs-title class_\">Router</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/router'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">MyPage</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./pages/my-page'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">route</span>: <span class=\"hljs-title class_\">Route</span> = {\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'my-page'</span>,\n  <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">MyPage</span>,\n  <span class=\"hljs-attr\">canActivate</span>: [\n    <span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">Router</span>);\n\n      router.<span class=\"hljs-title function_\">navigate</span>([<span class=\"hljs-string\">'./my-other-page'</span>]);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    },\n  ],\n};\n</code></pre>\n<p>Resolver를 사용하여 비슷한 결과를 얻을 수도 있습니다. Resolver를 이용하여 내부에서 새로운 내비게이션을 시작할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Route</span>, <span class=\"hljs-title class_\">Router</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/router'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">MyService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./my-feature'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">myRoute</span>: <span class=\"hljs-title class_\">Route</span> = [\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'my-feature'</span>,\n  <span class=\"hljs-attr\">resolve</span>: {\n    <span class=\"hljs-attr\">user</span>: <span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">Router</span>);\n\n      router.<span class=\"hljs-title function_\">navigate</span>([<span class=\"hljs-string\">'./my-other-page'</span>]);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n    }\n  }\n];\n</code></pre>\n<div class=\"content-ad\"></div>\n<h2>UrlTree를 사용한 Redirect</h2>\n<p>또 다른 방법으로, Guards와 Resolvers를 사용하여 새로운 Route를 나타내는 UrlTree를 반환함으로써 네비게이션을 리다이렉트할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Route</span>, <span class=\"hljs-title class_\">Router</span>, <span class=\"hljs-title class_\">UrlTree</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/router'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">MyPage</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./pages/my-page'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">route</span>: <span class=\"hljs-title class_\">Route</span> = {\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'my-page'</span>,\n  <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">MyPage</span>,\n  <span class=\"hljs-attr\">canActivate</span>: [\n    <span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">router</span>: <span class=\"hljs-title class_\">Router</span> = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">Router</span>);\n\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">urlTree</span>: <span class=\"hljs-title class_\">UrlTree</span> = router.<span class=\"hljs-title function_\">parseUrl</span>(<span class=\"hljs-string\">'./my-other-page'</span>);\n      <span class=\"hljs-keyword\">return</span> urlTree;\n    },\n  ],\n};\n</code></pre>\n<p>그러나 이 기술은 이전 기술이 허용하는 NavigationExtras를 사용하여 네비게이션을 리다이렉트하는 것을 허용하지는 않습니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">canActivate</span>: [\n  <span class=\"hljs-function\">() =></span> {\n    <span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">Router</span>);\n\n    router.<span class=\"hljs-title function_\">navigate</span>([<span class=\"hljs-string\">'./my-other-page'</span>], { <span class=\"hljs-attr\">skipLocationChange</span>: <span class=\"hljs-literal\">true</span> });\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  }\n]\n</code></pre>\n<h2>Redirect with RedirectCommand</h2>\n<p>해결책으로 Angular v18에서는 NavigationExtras를 처리할 수 있는 새로운 RedirectCommand 클래스를 소개했습니다. 이를 통해 Guards 및 Resolvers에서 네비게이션을 리다이렉트할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { inject } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">RedirectCommand</span>, <span class=\"hljs-title class_\">Route</span>, <span class=\"hljs-title class_\">Router</span>, <span class=\"hljs-title class_\">UrlTree</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/router'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">MyPage</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./pages/my-page'</span>;\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">route</span>: <span class=\"hljs-title class_\">Route</span> = {\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'my-page'</span>,\n  <span class=\"hljs-attr\">component</span>: <span class=\"hljs-title class_\">MyPage</span>,\n  <span class=\"hljs-attr\">canActivate</span>: [\n    <span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">router</span>: <span class=\"hljs-title class_\">Router</span> = <span class=\"hljs-title function_\">inject</span>(<span class=\"hljs-title class_\">Router</span>);\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">urlTree</span>: <span class=\"hljs-title class_\">UrlTree</span> = router.<span class=\"hljs-title function_\">parseUrl</span>(<span class=\"hljs-string\">'./my-other-page'</span>);\n\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RedirectCommand</span>(urlTree, { <span class=\"hljs-attr\">skipLocationChange</span>: <span class=\"hljs-literal\">true</span> });\n    },\n  ],\n};\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이 새로운 RedirectCommand 클래스의 도입은 가드 및 리졸버의 유지 보수성을 크게 향상시킵니다.</p>\n<p><img src=\"/assets/img/2024-06-20-RedirectingGuardsandResolversinAngularv18withRedirectCommand_1.png\" alt=\"RedirectingGuardsandResolversinAngularv18withRedirectCommand_1\"></p>\n<p>특히 이러한 사용 사례에 특별히 설계된 이 클래스는 앞으로 필요한 새로운 매개변수에 쉽게 대응할 수 있습니다.</p>\n<h1>지금까지 읽어 주셔서 감사합니다 🙏</h1>\n<div class=\"content-ad\"></div>\n<p>피드백을 주실 수 있다면 댓글을 남겨주세요. 👏</p>\n<p>그리고 정말 좋았다면 꼭 여러분의 커뮤니티, 기술 관련 그룹, 원하시는 분들과 공유해주세요. 그리고 LinkedIn 팔로우도 잊지마세요. 👋😁</p>\n</body>\n</html>\n"},"__N_SSG":true}