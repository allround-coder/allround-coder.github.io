{"pageProps":{"post":{"title":"기존 인터페이스를 강력한 타입의 리액티브 폼으로 사용하는 방법 Angular","description":"","date":"2024-06-22 03:12","slug":"2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform","content":"\n\nAngular 14+에서 우리는 기다리던 바대로 반응형 폼에 타입을 지정할 수 있는 기회를 얻었습니다. 문제는 폼 자체에 대한 특정 모델을 만들어야 하므로, 앱이 더 복잡한 객체를 사용할 때 폼 타입이 약간 더 복잡하고 유지하기 어려워진다는 점입니다.\n\n![이미지](/assets/img/2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform_0.png)\n\n간단한 모델이 있는 경우에는 어느 정도 쉽게 이해됩니다. 이런 식으로 User 인터페이스를 가진 경우를 살펴봅시다:\n\n```js\nexport interface User {\n    id: number;\n    name: string;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위 인터페이스를 기반으로 강력한 유형화된 반응형 폼을 만들려면, 폼 컨트롤을 보유할 미러 모델이 필요합니다:\n\n```js\nexport interface UserForm {\n    id: FormControl<number>;\n    name: FormControl<string>;\n}\n```\n\n그리고 많은 모델을 가지고 있을 때, 이 방법은 꽤 지루하고 시간이 많이 걸릴 수 있어요.\n\n## 모델을 복제하는 것은 해결책이 아닙니다.\n\n<div class=\"content-ad\"></div>\n\nTypescript의 힘을 이용해서, 우리는 인터페이스를 래핑할 타입을 만들 것이고, 이를 통해 프로젝트에서 모델 중복을 피할 수 있습니다.\n\n시작해봅시다!\n\n우리의 타입은 Generics을 사용하여 어떤 종류의 인터페이스든 받을 수 있어야 하며, 이를 FormGroup으로 변환하고 모든 속성을 FormControl로 변환해야 합니다.\n\n```js\nexport type ToFormType<T> = FormGroup<{\n    [K in keyof T]: FormControl<T[K] | null>;\n}>;\n```\n\n<div class=\"content-ad\"></div>\n\n쉽죠? 이제 우리가 하는 일 인터페이스 T를 감싸는 슈퍼 타입을 만들어요. 이 슈퍼 타입은 FormGroup으로 변환하고 각 속성은 FormControl으로 변환하죠.\n\n사용법:\n\n```js\npublic myForm: ToFormType<User>;\n\n...\n\nmyForm = this.fb.group(...);\n```\n\n기다려 주세요! 아직 끝나지 않았어요.\n\n<div class=\"content-ad\"></div>\n\n저희 유저 인터페이스에 작은 변경사항을 가해보도록 하죠:\n\n```js\nexport interface User {\n    id: number;\n    name: string;\n    address: Address;\n}\n\nexport interface Address {\n    zipCode: number;\n    city: string;\n}\n```\n\n음... 이전 유형에서 오류가 발생했네요.\n\n```js\n'Type 'FormGroup<{…}>' is not assignable to type 'ToFormType<User>'.\nTypes of property 'controls' are incompatible.\n```\n\n<div class=\"content-ad\"></div>\n\n잘 했어요… FormControl과 FormGroup을 처리할 수 있도록 유형을 업데이트해야 해요.\n\n다음과 같이 시도해 봅시다:\n\n```js\nexport type ToFormType<T> = FormGroup<{\n    [K in keyof T]: T[K] extends object\n        ? ToFormType<T[K]>\n        : FormControl<T[K] | null>;\n}>;\n```\n\n작동하는 것으로 보이네요. 중첩된 객체가 있는 경우에도 처리할 수 있어요. 하지만, 한 가지 문제가 있어요: 만약 User에 birthDate 속성이 있다면 어떻게 될까요? Date는 object를 확장한다네요… 안타깝지만요.\n\n<div class=\"content-ad\"></div>\n\n위에 있는 내용을 친한 톤으로 한국어로 번역해 드리겠습니다:\n\n말씀하신 대로, 쉽게 코드를 업데이트하여 작동시킬 수 있습니다:\n\n```js\nexport type ToFormType<T> = FormGroup<{\n    [K in keyof T]: T[K] extends object\n        ? T[K] extends Date\n            ? FormControl<T[K] | null>\n            : ToFormType<T[K]>\n        : FormControl<T[K] | null>;\n}>;\r\n```\n\n조금은 섬세하지 않지만, 대부분의 경우에는 작동할 것입니다.\n\n```js\nexport interface User {\n    id: number;\n    name: string;\n    address: Address;\n    hobbies: Hobby[];\n}\n\nexport interface Address {\n    zipCode: number;\n    city: string;\n}\n\nexport interface Hobby {\n    name: string;\n    description: string;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n다음과 같이 번역됩니다:\n\n```js\n'Type 'FormGroup<{…}>'은(는) 'ToFormType<User>' 유형에 할당할 수 없습니다. 'controls' 속성의 유형이 호환되지 않습니다.\n```\n\n익숙하신가요? 어떻게 해야 할 지 알겠어요! 다시 한번 형식을 발전시켜 봅시다!\n\n이렇게 하고 싶은 유혹을 느낄 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\nT[K]이 배열을 확장한다면 FormArray<ToFormType<T[K]>>으로 ....를 설정합니다.\n\n그러나 이 방법은 작동하지 않을 것입니다. 이유는 타입이 일치하지 않기 때문입니다. \n\n이를 피하기 위해서는 배열로부터 타입을 « 추출 » 할 때 infer를 사용해야 합니다. (자세한 내용은 https://blog.logrocket.com/understanding-infer-typescript/에서 확인할 수 있습니다):\n\nexport type ToFormType<T> = FormGroup<{\n    [K in keyof T]: T[K]이 객체를 확장한다면\n        ? T[K]이 날짜인 경우\n            ? FormControl<T[K] | null>\n            : T[K]이 알 수 없는 배열인 경우\n                ? FormArray<ToFormType<T[K] extends (infer V)[] ? V : T[K]>>\n                : ToFormType<T[K]>\n        : FormControl<T[K] | null>;\n}>;\n\n<div class=\"content-ad\"></div>\n\n이제 우리에게 대부분의 인터페이스를 강력하게 입력 형식화된 반응 형식으로 변환할 수 있는 타입이 생겼어요!\n\n폼 내부에서 인터페이스를 풍부하게 제공하거나 부분적으로 사용하려면 Typescript의 Pick, Required, Intersection, Omit과 같은 기능을 활용할 수도 있어요. 예를 들면:\nToFormType<Pick<User, 'id' | 'name' >>;\n// OR\nToFormType<User & { birthDate: Date }>;\n\n그리고 모든 사용 사례에 대해 중복으로 정의하지 않고 단일 인터페이스를 사용할 수 있어요:)\n\n<div class=\"content-ad\"></div>\n\n참고 자료\n\n- [Typescript 공식 문서: 제네릭](https://www.typescriptlang.org/docs/handbook/2/generics.html)\n- [TypeScript의 infer 키워드 이해하기](https://blog.logrocket.com/understanding-infer-typescript/)\n- [Typescript 공식 문서: 유틸리티 타입 - `Pick`](https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys)\n- [Typescript 공식 문서: 병합과 교차 타입](https://www.typescriptlang.org/docs/handbook/unions-and-intersections.html)\n\n지금까지였습니다! 즐겁게 보셨길 바라요!\n\n이와 같은 글을 계속해서 놓치고 싶지 않다면, 저희를 팔로우해주시면 감사하겠습니다 :)","ogImage":{"url":"/assets/img/2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform_0.png"},"coverImage":"/assets/img/2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>Angular 14+에서 우리는 기다리던 바대로 반응형 폼에 타입을 지정할 수 있는 기회를 얻었습니다. 문제는 폼 자체에 대한 특정 모델을 만들어야 하므로, 앱이 더 복잡한 객체를 사용할 때 폼 타입이 약간 더 복잡하고 유지하기 어려워진다는 점입니다.</p>\n<p><img src=\"/assets/img/2024-06-22-AngularUseanyexistinginterfaceintostronglytypedreactiveform_0.png\" alt=\"이미지\"></p>\n<p>간단한 모델이 있는 경우에는 어느 정도 쉽게 이해됩니다. 이런 식으로 User 인터페이스를 가진 경우를 살펴봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> interface <span class=\"hljs-title class_\">User</span> {\n    <span class=\"hljs-attr\">id</span>: number;\n    <span class=\"hljs-attr\">name</span>: string;\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>위 인터페이스를 기반으로 강력한 유형화된 반응형 폼을 만들려면, 폼 컨트롤을 보유할 미러 모델이 필요합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> interface <span class=\"hljs-title class_\">UserForm</span> {\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-title class_\">FormControl</span>&#x3C;number>;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">FormControl</span>&#x3C;string>;\n}\n</code></pre>\n<p>그리고 많은 모델을 가지고 있을 때, 이 방법은 꽤 지루하고 시간이 많이 걸릴 수 있어요.</p>\n<h2>모델을 복제하는 것은 해결책이 아닙니다.</h2>\n<div class=\"content-ad\"></div>\n<p>Typescript의 힘을 이용해서, 우리는 인터페이스를 래핑할 타입을 만들 것이고, 이를 통해 프로젝트에서 모델 중복을 피할 수 있습니다.</p>\n<p>시작해봅시다!</p>\n<p>우리의 타입은 Generics을 사용하여 어떤 종류의 인터페이스든 받을 수 있어야 하며, 이를 FormGroup으로 변환하고 모든 속성을 FormControl로 변환해야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">ToFormType</span>&#x3C;T> = <span class=\"hljs-title class_\">FormGroup</span>&#x3C;{\n    [K <span class=\"hljs-keyword\">in</span> keyof T]: <span class=\"hljs-title class_\">FormControl</span>&#x3C;T[K] | <span class=\"hljs-literal\">null</span>>;\n}>;\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>쉽죠? 이제 우리가 하는 일 인터페이스 T를 감싸는 슈퍼 타입을 만들어요. 이 슈퍼 타입은 FormGroup으로 변환하고 각 속성은 FormControl으로 변환하죠.</p>\n<p>사용법:</p>\n<pre><code class=\"hljs language-js\">public <span class=\"hljs-attr\">myForm</span>: <span class=\"hljs-title class_\">ToFormType</span>&#x3C;<span class=\"hljs-title class_\">User</span>>;\n\n...\n\nmyForm = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">fb</span>.<span class=\"hljs-title function_\">group</span>(...);\n</code></pre>\n<p>기다려 주세요! 아직 끝나지 않았어요.</p>\n<div class=\"content-ad\"></div>\n<p>저희 유저 인터페이스에 작은 변경사항을 가해보도록 하죠:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> interface <span class=\"hljs-title class_\">User</span> {\n    <span class=\"hljs-attr\">id</span>: number;\n    <span class=\"hljs-attr\">name</span>: string;\n    <span class=\"hljs-attr\">address</span>: <span class=\"hljs-title class_\">Address</span>;\n}\n\n<span class=\"hljs-keyword\">export</span> interface <span class=\"hljs-title class_\">Address</span> {\n    <span class=\"hljs-attr\">zipCode</span>: number;\n    <span class=\"hljs-attr\">city</span>: string;\n}\n</code></pre>\n<p>음... 이전 유형에서 오류가 발생했네요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">'Type '</span><span class=\"hljs-title class_\">FormGroup</span>&#x3C;{…}><span class=\"hljs-string\">' is not assignable to type '</span><span class=\"hljs-title class_\">ToFormType</span>&#x3C;<span class=\"hljs-title class_\">User</span>><span class=\"hljs-string\">'.\nTypes of property '</span>controls<span class=\"hljs-string\">' are incompatible.\n</span></code></pre>\n<div class=\"content-ad\"></div>\n<p>잘 했어요… FormControl과 FormGroup을 처리할 수 있도록 유형을 업데이트해야 해요.</p>\n<p>다음과 같이 시도해 봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">ToFormType</span>&#x3C;T> = <span class=\"hljs-title class_\">FormGroup</span>&#x3C;{\n    [K <span class=\"hljs-keyword\">in</span> keyof T]: T[K] <span class=\"hljs-keyword\">extends</span> object\n        ? <span class=\"hljs-title class_\">ToFormType</span>&#x3C;T[K]>\n        : <span class=\"hljs-title class_\">FormControl</span>&#x3C;T[K] | <span class=\"hljs-literal\">null</span>>;\n}>;\n</code></pre>\n<p>작동하는 것으로 보이네요. 중첩된 객체가 있는 경우에도 처리할 수 있어요. 하지만, 한 가지 문제가 있어요: 만약 User에 birthDate 속성이 있다면 어떻게 될까요? Date는 object를 확장한다네요… 안타깝지만요.</p>\n<div class=\"content-ad\"></div>\n<p>위에 있는 내용을 친한 톤으로 한국어로 번역해 드리겠습니다:</p>\n<p>말씀하신 대로, 쉽게 코드를 업데이트하여 작동시킬 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">ToFormType</span>&#x3C;T> = <span class=\"hljs-title class_\">FormGroup</span>&#x3C;{\n    [K <span class=\"hljs-keyword\">in</span> keyof T]: T[K] <span class=\"hljs-keyword\">extends</span> object\n        ? T[K] <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Date</span>\n            ? <span class=\"hljs-title class_\">FormControl</span>&#x3C;T[K] | <span class=\"hljs-literal\">null</span>>\n            : <span class=\"hljs-title class_\">ToFormType</span>&#x3C;T[K]>\n        : <span class=\"hljs-title class_\">FormControl</span>&#x3C;T[K] | <span class=\"hljs-literal\">null</span>>;\n}>;\n</code></pre>\n<p>조금은 섬세하지 않지만, 대부분의 경우에는 작동할 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> interface <span class=\"hljs-title class_\">User</span> {\n    <span class=\"hljs-attr\">id</span>: number;\n    <span class=\"hljs-attr\">name</span>: string;\n    <span class=\"hljs-attr\">address</span>: <span class=\"hljs-title class_\">Address</span>;\n    <span class=\"hljs-attr\">hobbies</span>: <span class=\"hljs-title class_\">Hobby</span>[];\n}\n\n<span class=\"hljs-keyword\">export</span> interface <span class=\"hljs-title class_\">Address</span> {\n    <span class=\"hljs-attr\">zipCode</span>: number;\n    <span class=\"hljs-attr\">city</span>: string;\n}\n\n<span class=\"hljs-keyword\">export</span> interface <span class=\"hljs-title class_\">Hobby</span> {\n    <span class=\"hljs-attr\">name</span>: string;\n    <span class=\"hljs-attr\">description</span>: string;\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>다음과 같이 번역됩니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">'Type '</span><span class=\"hljs-title class_\">FormGroup</span>&#x3C;{…}><span class=\"hljs-string\">'은(는) '</span><span class=\"hljs-title class_\">ToFormType</span>&#x3C;<span class=\"hljs-title class_\">User</span>><span class=\"hljs-string\">' 유형에 할당할 수 없습니다. '</span>controls<span class=\"hljs-string\">' 속성의 유형이 호환되지 않습니다.\n</span></code></pre>\n<p>익숙하신가요? 어떻게 해야 할 지 알겠어요! 다시 한번 형식을 발전시켜 봅시다!</p>\n<p>이렇게 하고 싶은 유혹을 느낄 수 있어요.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">T[K]이 배열을 확장한다면 <span class=\"hljs-title class_\">FormArray</span>&#x3C;<span class=\"hljs-title class_\">ToFormType</span>&#x3C;T[K]>>으로 ....를 설정합니다.\n\n그러나 이 방법은 작동하지 않을 것입니다. 이유는 타입이 일치하지 않기 때문입니다. \n\n이를 피하기 위해서는 배열로부터 타입을 « 추출 » 할 때 infer를 사용해야 합니다. (자세한 내용은 <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//blog.logrocket.com/understanding-infer-typescript/에서 확인할 수 있습니다):</span>\n\n<span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">ToFormType</span>&#x3C;T> = <span class=\"hljs-title class_\">FormGroup</span>&#x3C;{\n    [K <span class=\"hljs-keyword\">in</span> keyof T]: T[K]이 객체를 확장한다면\n        ? T[K]이 날짜인 경우\n            ? <span class=\"hljs-title class_\">FormControl</span>&#x3C;T[K] | <span class=\"hljs-literal\">null</span>>\n            : T[K]이 알 수 없는 배열인 경우\n                ? <span class=\"hljs-title class_\">FormArray</span>&#x3C;<span class=\"hljs-title class_\">ToFormType</span>&#x3C;T[K] <span class=\"hljs-keyword\">extends</span> (infer V)[] ? V : T[K]>>\n                : <span class=\"hljs-title class_\">ToFormType</span>&#x3C;T[K]>\n        : <span class=\"hljs-title class_\">FormControl</span>&#x3C;T[K] | <span class=\"hljs-literal\">null</span>>;\n}>;\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n이제 우리에게 대부분의 인터페이스를 강력하게 입력 형식화된 반응 형식으로 변환할 수 있는 타입이 생겼어요!\n\n폼 내부에서 인터페이스를 풍부하게 제공하거나 부분적으로 사용하려면 <span class=\"hljs-title class_\">Typescript</span>의 <span class=\"hljs-title class_\">Pick</span>, <span class=\"hljs-title class_\">Required</span>, <span class=\"hljs-title class_\">Intersection</span>, <span class=\"hljs-title class_\">Omit</span>과 같은 기능을 활용할 수도 있어요. 예를 들면:\n<span class=\"hljs-title class_\">ToFormType</span>&#x3C;<span class=\"hljs-title class_\">Pick</span>&#x3C;<span class=\"hljs-title class_\">User</span>, <span class=\"hljs-string\">'id'</span> | <span class=\"hljs-string\">'name'</span> >>;\n<span class=\"hljs-comment\">// OR</span>\n<span class=\"hljs-title class_\">ToFormType</span>&#x3C;<span class=\"hljs-title class_\">User</span> &#x26; { <span class=\"hljs-attr\">birthDate</span>: <span class=\"hljs-title class_\">Date</span> }>;\n\n그리고 모든 사용 사례에 대해 중복으로 정의하지 않고 단일 인터페이스를 사용할 수 있어요:)\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n참고 자료\n\n- [<span class=\"hljs-title class_\">Typescript</span> 공식 문서: 제네릭](<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//www.typescriptlang.org/docs/handbook/2/generics.html)</span>\n- [<span class=\"hljs-title class_\">TypeScript</span>의 infer 키워드 이해하기](<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//blog.logrocket.com/understanding-infer-typescript/)</span>\n- [<span class=\"hljs-title class_\">Typescript</span> 공식 문서: 유틸리티 타입 - <span class=\"hljs-string\">`Pick`</span>](<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys)</span>\n- [<span class=\"hljs-title class_\">Typescript</span> 공식 문서: 병합과 교차 타입](<span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//www.typescriptlang.org/docs/handbook/unions-and-intersections.html)</span>\n\n지금까지였습니다! 즐겁게 보셨길 바라요!\n\n이와 같은 글을 계속해서 놓치고 싶지 않다면, 저희를 팔로우해주시면 감사하겠습니다 :)\n</code></pre>\n</body>\n</html>\n"},"__N_SSG":true}