{"pageProps":{"post":{"title":"SwiftUI에서 HTML 렌더링하기","description":"","date":"2024-06-20 03:39","slug":"2024-06-20-RenderHTMLinSwiftUI","content":"\n\n## NSAttributedString, UITextView 및 UIViewRepresentable를 사용하여 SwiftUI에서 HTML 렌더링하기.\n\n![이미지](/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png)\n\nSwiftUI는 멋지지만 여전히 기능이 부족한 것이 많습니다. 몇 년간 UIKit을 사용한 후 익숙해진 기능이죠. 그 중 하나는 NSAttributedString 및 UITextView를 사용하여 간단한 HTML 텍스트를 렌더링할 수 있는 기능입니다.\n\n이 글에서는 SwiftUI를 UIViewRepresentable을 사용하여 UIKit과 연결하고, HTML을 렌더링하는 사용자 정의 SwiftUI View를 만드는 방법을 간단히 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n업데이트: 원본 기사 개선 사항\n\n이 기사의 원본 버전에서는 NSAttributedString을 사용하여 HTML을 스타일링하고 렌더링하는 데 특화된 간단한 사용자 정의 SwiftUI 뷰를 만드는 방법에 대해 살펴보았습니다. 이 기사에서는 AttributedText 뷰도 언급되었습니다. 그러나 이로 인해 이상한 동작이 발생했는데, 아직 적절한 해결책을 찾지 못했습니다. 따라서 이 기사의 업데이트된 버전에서는 HTML 뷰를 제거하고 NSAttributedString에 대한 편리한 확장 기능이 몇 가지 추가되었습니다. 나는 이상한 동작에 대한 더 나은 이해를 얻기 위해 Apple 개발자 포럼과 스택 오버플로에 게시했습니다.\n\n## 주요 포인트\n\n- UIViewRepresentable 프로토콜을 사용하여 UIKit 뷰를 SwiftUI 뷰 계층구조에 포함할 수 있습니다.\n- NSAttributedString (UITextView를 통해)의 강력한 기능을 노출할 수 있으며, 현재 SwiftUI 세계에는 동등한 것이 없습니다 (하지만 AttributedString는 좋은 후보일 수 있음).\n- 스타일이 지정된 HTML 형식의 NSAttributedStrings는 UIViewRepresentable에 의해 관리되는 UITextView에 의해 렌더링될 수 있습니다. HTML 형식의 텍스트에서 일부 CSS 스타일 속성을 인라인으로 정의하거나 HTML 형식의 텍스트의 전용 스타일 태그로 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사에서 사용된 완성된 예제 코드는 GitHub에서 찾을 수 있어요: https://github.com/thomsmed/ios-examples/tree/main/SwiftUIHTML.\n\n# 커스텀 UIViewRepresentable\n\nSwiftUI가 처음 발표됐을 때는 기존 UIKit 뷰를 SwiftUI 뷰 계층구조에 임베드할 수 있도록 하는 API도 함께 제공되었습니다. 개발자들에게 UIKit에서 SwiftUI로의 전환이 쉬워졌어요.\n\n이러한 API 중 하나는 UIViewRepresentable 프로토콜인데요, SwiftUI의 컨텍스트에서 UIKit 뷰를 관리하는 데 사용돼요. Apple은 이 프로토콜과 다른 SwiftUI와 UIKit을 연결하는 프로토콜을 통해 이를 통한 가능성을 보여주는 멋진 WWDC 비디오를 제공했어요. 적어도 'Integrating SwiftUI'를 확인해보시기를 권해요.\n\n<div class=\"content-ad\"></div>\n\n## AttributedText\n\nNSAttributedString은 텍스트 문자열을 강력하게 관리하는 도구로, 텍스트 문자열의 문자 범위를 스타일링하는 강력한 방법을 제공합니다. 심지어 간단한 HTML에 따라 텍스트를 스타일링할 수도 있습니다.\n\nNSAttributedString을 스타일링된 상태로 초기화하려면 NSAttributedString.init(data:options:documentAttributes:) 이니셜라이저에 .documentType 옵션을 .html로 설정한 HTML 문자열(데이터 형식으로)을 전달하면 됩니다. 그리고 UITextView와 함께 사용하여 앱에서 HTML을 렌더링할 수 있습니다!\n\nUIViewRepresentable 프로토콜을 사용하여 NSAttributedString 및 UITextView의 기능을 SwiftUI에 사용되는 사용자 지정 AttributedText View로 노출시킬 것입니다!\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\n\nstruct AttributedText: UIViewRepresentable {\n    private let attributedString: NSAttributedString\n\n    init(_ attributedString: NSAttributedString) {\n        self.attributedString = attributedString\n    }\n\n    func makeUIView(context: Context) -> UITextView {\n        // SwiftUI이 이 \"View\"를 렌더링하는 첫 번째 시간에 호출됩니다.\n\n        let uiTextView = UITextView()\n\n        // 배경 뷰가 반짝일 수 있도록 투명하게 만듭니다.\n        uiTextView.backgroundColor = .clear\n\n        // 텍스트 시각화만을 위한 것이므로 편집되지 않도록 합니다.\n        uiTextView.isEditable = false\n\n        // UITextView를 가능한 너비에 맞게 유연하게 만들지만, 콘텐츠에 맞는 높이를 요구합니다.\n        // 또한 UITextView가 스크롤되지 않게 하여 UITextView가 텍스트 콘텐츠와 일치하도록 `intrinsicContentSize`를 설정합니다.\n        uiTextView.isScrollEnabled = false\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .vertical)\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .horizontal)\n        uiTextView.setContentCompressionResistancePriority(.required, for: .vertical)\n        uiTextView.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)\n\n        return uiTextView\n    }\n\n    func updateUIView(_ uiTextView: UITextView, context: Context) {\n        // SwiftUI이 이 UIViewRepresentable을 처음 렌더링하는 시간과 상태 변경에 대해 알림을 받을 때마다 호출됩니다. (예: @State 변수를 통해)\n        uiTextView.attributedText = attributedString\n    }\n}\n```\n\nUIViewRepresentable로 위에서 정의한 AttributedText를 사용하여 SwiftUI 앱에서 NSAttributedStrings를 렌더링할 수 있습니다. HTML 형식의 텍스트로 초기화된 NSAttributedStrings를 렌더링하는 것이 주된 목표이므로 NSAttributedString에 대한 편의 생성자를 만듭니다.\n\n```swift\nimport UIKit\n\nextension NSAttributedString {\n    static func html(withBody body: String) -> NSAttributedString {\n        // 앱에서 사용되는 현재 로케이션과 일치하는 HTML `lang` 속성을 매치합니다. (즉, Bundle.main)\n        let bundle = Bundle.main\n        let lang = bundle.preferredLocalizations.first\n            ?? bundle.developmentLocalization\n            ?? \"en\"\n\n        return (try? NSAttributedString(\n            data: \"\"\"\n            <!doctype html>\n            <html lang=\"\\(lang)\">\n            <head>\n                <meta charset=\"utf-8\">\n                <style type=\"text/css\">\n                    /*\n                      HTML 형식의 텍스트에 대한 사용자 정의 CSS 스타일 지정\n                      주의: NSAttributedString/UITextView에서 지원하는 CSS 기능은 제한적입니다.\n                    */\n\n                    body {\n                        font: -apple-system-body;\n                        color: \\(UIColor.secondaryLabel.hex);\n                    }\n\n                    h1, h2, h3, h4, h5, h6 {\n                        color: \\(UIColor.label.hex);\n                    }\n\n                    a {\n                        color: \\(UIColor.systemGreen.hex);\n                    }\n\n                    li:last-child {\n                        margin-bottom: 1em;\n                    }\n                </style>\n            </head>\n            <body>\n                \\(body)\n            </body>\n            </html>\n            \"\"\".data(using: .utf8)!,\n            options: [\n                .documentType: NSAttributedString.DocumentType.html,\n                .characterEncoding: String.Encoding.utf8.rawValue,\n            ],\n            documentAttributes: nil\n        )) ?? NSAttributedString(string: body)\n    }\n}\n\n// UIColor를 CSS 친화적인 색상 헥스 문자열로 변환\n\nprivate extension UIColor {\n    var hex: String {\n        var red: CGFloat = 0\n        var green: CGFloat = 0\n        var blue: CGFloat = 0\n        var alpha: CGFloat = 0\n\n        getRed(&red, green: &green, blue: &blue, alpha: &alpha)\n\n        return String(\n            format: \"#%02lX%02lX%02lX%02lX\",\n            lroundf(Float(red * 255)),\n            lroundf(Float(green * 255)),\n            lroundf(Float(blue * 255)),\n            lroundf(Float(alpha * 255))\n        )\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nNSAttributedString은 일부 CSS 기능을 지원합니다 (안타깝게도 어딘가 제대로 문서화되지 않은 기능들이 있습니다), 하지만 인라인 및 별도의 태그 내에서 스타일을 정의하는 것이 가능합니다 (일반적으로 HTML head 태그의 일부로).\n\n## SwiftUI에서 HTML 렌더링하기\n\n그런 다음, 우리는 AttributedText UIViewRepresentable을 사용하여 NSAttributedString 편리한 초기화자를 함께 사용하여 SwiftUI 앱에서 HTML을 렌더링할 수 있습니다 - 심지어 인라인 스타일링도 가능합니다!\n\n```js\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        NavigationStack {\n            ScrollView {\n                AttributedText(.html(withBody: \"\"\"\n                <h3>This is a H3 header</h3>\n                <p>This is a paragraph</p>\n                <ul>\n                    <li>List item one</li>\n                    <li>List item two</li>\n                </ul>\n                <p>This is a paragraph with a <a href=\"https://developer.apple.com/\">link</a></p>\n                <p style=\"color: blue; text-align: center;\">\n                    This is a paragraph with inline styling\n                </p>\n                \"\"\"))\n                .padding()\n            }\n            .navigationTitle(\"Render HTML in SwiftUI\")\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 보너스: 테마별 HTML 렌더링\n\n만약 앱이 (색상) 테마 개념을 사용하여 앱 전반에 대한 색상 정보 등을 전파한다면, 현재 테마 정보를 기반으로 HTML을 스타일링할 수도 있습니다.\n\n사용자 정의 테마 환경 값과 다른 NSAttributedString 편의 이니셜라이저를 사용하면 다음과 같이 보일 수 있습니다:\n\n사용자 정의 테마 환경 값\n\n<div class=\"content-ad\"></div>\n\n다음은 Markdown 형식으로 테이블 태그를 변경한 코드입니다.\n\n\nimport SwiftUI\n\n// Example of a simple Theme struct.\nstruct Theme {\n    let textPrimary: UIColor\n    let textSecondary: UIColor\n    let textInteractive: UIColor\n}\n\nextension Theme {\n    static let `default` = Theme(\n        textPrimary: .label,\n        textSecondary: .secondaryLabel,\n        textInteractive: .systemGreen\n    )\n}\n\nprivate struct ThemeEnvironmentKey: EnvironmentKey {\n    static var defaultValue: Theme = .default\n}\n\nextension EnvironmentValues {\n    var theme: Theme {\n        get { self[ThemeEnvironmentKey.self] }\n        set { self[ThemeEnvironmentKey.self] = newValue }\n    }\n}\n\n\nNSAttributedString을 위한 편리한 이니셜라이저\n\n\nimport UIKit\n\nextension NSAttributedString {\n    static func themedHtml(withBody body: String, theme: Theme = .default) -> NSAttributedString {\n        // Match the HTML `lang` attribute to current localisation used by the app (aka Bundle.main).\n        let bundle = Bundle.main\n        let lang = bundle.preferredLocalizations.first\n            ?? bundle.developmentLocalization\n            ?? \"en\"\n\n        return (try? NSAttributedString(\n            data: \"\"\"\n            <!doctype html>\n            <html lang=\"\\(lang)\">\n            <head>\n                <meta charset=\"utf-8\">\n                <style type=\"text/css\">\n                    /*\n                      Custom CSS styling of HTML formatted text.\n                      Note, only a limited number of CSS features are supported by NSAttributedString/UITextView.\n                    */\n\n                    body {\n                        font: -apple-system-body;\n                        color: \\(theme.textSecondary.hex);\n                    }\n\n                    h1, h2, h3, h4, h5, h6 {\n                        color: \\(theme.textPrimary.hex);\n                    }\n\n                    a {\n                        color: \\(theme.textInteractive.hex);\n                    }\n\n                    li:last-child {\n                        margin-bottom: 1em;\n                    }\n                </style>\n            </head>\n            <body>\n                \\(body)\n            </body>\n            </html>\n            \"\"\".data(using: .utf8)!,\n            options: [\n                .documentType: NSAttributedString.DocumentType.html,\n                .characterEncoding: String.Encoding.utf8.rawValue,\n            ],\n            documentAttributes: nil\n        )) ?? NSAttributedString(string: body)\n    }\n}\n\n// MARK: Converting UIColors into CSS friendly color hex string\n\nprivate extension UIColor {\n    var hex: String {\n        var red: CGFloat = 0\n        var green: CGFloat = 0\n        var blue: CGFloat = 0\n        var alpha: CGFloat = 0\n\n        getRed(&red, green: &green, blue: &blue, alpha: &alpha)\n\n        return String(\n            format: \"#%02lX%02lX%02lX%02lX\",\n            lroundf(Float(red * 255)),\n            lroundf(Float(green * 255)),\n            lroundf(Float(blue * 255)),\n            lroundf(Float(alpha * 255))\n        )\n    }\n}\n\n\nSwiftUI에서 테마가 적용된 HTML 렌더링하기\n\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    @Environment(\\.theme) private var theme: Theme\n\n    var body: some View {\n        NavigationStack {\n            ScrollView {\n                AttributedText(.themedHtml(withBody: \"\"\"\n                <h3>This is a H3 header</h3>\n                <p>This is a paragraph</p>\n                <ul>\n                    <li>List item one</li>\n                    <li>List item two</li>\n                </ul>\n                <p>This is a paragraph with a <a href=\"https://developer.apple.com/\">link</a></p>\n                <p style=\"color: blue; text-align: center;\">\n                    This is a paragraph with inline styling\n                </p>\n                \"\"\", theme: theme))\n                .padding()\n            }\n            .navigationTitle(\"Render Themed HTML in SwiftUI\")\n        }\n    }\n}\n```\n\n## 이게 다야!\n\n쉽죠! SwiftUI가 정말 멋지지만, 때로는 몇 년 동안 사랑해 온 UIKit 뷰와 기능을 임베드할 수 있는 것이 참 좋습니다.\n\n코딩하세요! 🙌\n","ogImage":{"url":"/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png"},"coverImage":"/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png","tag":["Tech"],"readingTime":12},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>NSAttributedString, UITextView 및 UIViewRepresentable를 사용하여 SwiftUI에서 HTML 렌더링하기.</h2>\n<p><img src=\"/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png\" alt=\"이미지\"></p>\n<p>SwiftUI는 멋지지만 여전히 기능이 부족한 것이 많습니다. 몇 년간 UIKit을 사용한 후 익숙해진 기능이죠. 그 중 하나는 NSAttributedString 및 UITextView를 사용하여 간단한 HTML 텍스트를 렌더링할 수 있는 기능입니다.</p>\n<p>이 글에서는 SwiftUI를 UIViewRepresentable을 사용하여 UIKit과 연결하고, HTML을 렌더링하는 사용자 정의 SwiftUI View를 만드는 방법을 간단히 살펴보겠습니다.</p>\n<div class=\"content-ad\"></div>\n<p>업데이트: 원본 기사 개선 사항</p>\n<p>이 기사의 원본 버전에서는 NSAttributedString을 사용하여 HTML을 스타일링하고 렌더링하는 데 특화된 간단한 사용자 정의 SwiftUI 뷰를 만드는 방법에 대해 살펴보았습니다. 이 기사에서는 AttributedText 뷰도 언급되었습니다. 그러나 이로 인해 이상한 동작이 발생했는데, 아직 적절한 해결책을 찾지 못했습니다. 따라서 이 기사의 업데이트된 버전에서는 HTML 뷰를 제거하고 NSAttributedString에 대한 편리한 확장 기능이 몇 가지 추가되었습니다. 나는 이상한 동작에 대한 더 나은 이해를 얻기 위해 Apple 개발자 포럼과 스택 오버플로에 게시했습니다.</p>\n<h2>주요 포인트</h2>\n<ul>\n<li>UIViewRepresentable 프로토콜을 사용하여 UIKit 뷰를 SwiftUI 뷰 계층구조에 포함할 수 있습니다.</li>\n<li>NSAttributedString (UITextView를 통해)의 강력한 기능을 노출할 수 있으며, 현재 SwiftUI 세계에는 동등한 것이 없습니다 (하지만 AttributedString는 좋은 후보일 수 있음).</li>\n<li>스타일이 지정된 HTML 형식의 NSAttributedStrings는 UIViewRepresentable에 의해 관리되는 UITextView에 의해 렌더링될 수 있습니다. HTML 형식의 텍스트에서 일부 CSS 스타일 속성을 인라인으로 정의하거나 HTML 형식의 텍스트의 전용 스타일 태그로 정의할 수 있습니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>이 기사에서 사용된 완성된 예제 코드는 GitHub에서 찾을 수 있어요: <a href=\"https://github.com/thomsmed/ios-examples/tree/main/SwiftUIHTML\" rel=\"nofollow\" target=\"_blank\">https://github.com/thomsmed/ios-examples/tree/main/SwiftUIHTML</a>.</p>\n<h1>커스텀 UIViewRepresentable</h1>\n<p>SwiftUI가 처음 발표됐을 때는 기존 UIKit 뷰를 SwiftUI 뷰 계층구조에 임베드할 수 있도록 하는 API도 함께 제공되었습니다. 개발자들에게 UIKit에서 SwiftUI로의 전환이 쉬워졌어요.</p>\n<p>이러한 API 중 하나는 UIViewRepresentable 프로토콜인데요, SwiftUI의 컨텍스트에서 UIKit 뷰를 관리하는 데 사용돼요. Apple은 이 프로토콜과 다른 SwiftUI와 UIKit을 연결하는 프로토콜을 통해 이를 통한 가능성을 보여주는 멋진 WWDC 비디오를 제공했어요. 적어도 'Integrating SwiftUI'를 확인해보시기를 권해요.</p>\n<div class=\"content-ad\"></div>\n<h2>AttributedText</h2>\n<p>NSAttributedString은 텍스트 문자열을 강력하게 관리하는 도구로, 텍스트 문자열의 문자 범위를 스타일링하는 강력한 방법을 제공합니다. 심지어 간단한 HTML에 따라 텍스트를 스타일링할 수도 있습니다.</p>\n<p>NSAttributedString을 스타일링된 상태로 초기화하려면 NSAttributedString.init(data:options:documentAttributes:) 이니셜라이저에 .documentType 옵션을 .html로 설정한 HTML 문자열(데이터 형식으로)을 전달하면 됩니다. 그리고 UITextView와 함께 사용하여 앱에서 HTML을 렌더링할 수 있습니다!</p>\n<p>UIViewRepresentable 프로토콜을 사용하여 NSAttributedString 및 UITextView의 기능을 SwiftUI에 사용되는 사용자 지정 AttributedText View로 노출시킬 것입니다!</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">import</span> SwiftUI\n\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">AttributedText</span>: <span class=\"hljs-title class_\">UIViewRepresentable</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">let</span> attributedString: <span class=\"hljs-type\">NSAttributedString</span>\n\n    <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">attributedString</span>: <span class=\"hljs-type\">NSAttributedString</span>) {\n        <span class=\"hljs-keyword\">self</span>.attributedString <span class=\"hljs-operator\">=</span> attributedString\n    }\n\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">makeUIView</span>(<span class=\"hljs-params\">context</span>: <span class=\"hljs-type\">Context</span>) -> <span class=\"hljs-type\">UITextView</span> {\n        <span class=\"hljs-comment\">// SwiftUI이 이 \"View\"를 렌더링하는 첫 번째 시간에 호출됩니다.</span>\n\n        <span class=\"hljs-keyword\">let</span> uiTextView <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">UITextView</span>()\n\n        <span class=\"hljs-comment\">// 배경 뷰가 반짝일 수 있도록 투명하게 만듭니다.</span>\n        uiTextView.backgroundColor <span class=\"hljs-operator\">=</span> .clear\n\n        <span class=\"hljs-comment\">// 텍스트 시각화만을 위한 것이므로 편집되지 않도록 합니다.</span>\n        uiTextView.isEditable <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span>\n\n        <span class=\"hljs-comment\">// UITextView를 가능한 너비에 맞게 유연하게 만들지만, 콘텐츠에 맞는 높이를 요구합니다.</span>\n        <span class=\"hljs-comment\">// 또한 UITextView가 스크롤되지 않게 하여 UITextView가 텍스트 콘텐츠와 일치하도록 `intrinsicContentSize`를 설정합니다.</span>\n        uiTextView.isScrollEnabled <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span>\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .vertical)\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .horizontal)\n        uiTextView.setContentCompressionResistancePriority(.required, for: .vertical)\n        uiTextView.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)\n\n        <span class=\"hljs-keyword\">return</span> uiTextView\n    }\n\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">updateUIView</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">uiTextView</span>: <span class=\"hljs-type\">UITextView</span>, <span class=\"hljs-params\">context</span>: <span class=\"hljs-type\">Context</span>) {\n        <span class=\"hljs-comment\">// SwiftUI이 이 UIViewRepresentable을 처음 렌더링하는 시간과 상태 변경에 대해 알림을 받을 때마다 호출됩니다. (예: @State 변수를 통해)</span>\n        uiTextView.attributedText <span class=\"hljs-operator\">=</span> attributedString\n    }\n}\n</code></pre>\n<p>UIViewRepresentable로 위에서 정의한 AttributedText를 사용하여 SwiftUI 앱에서 NSAttributedStrings를 렌더링할 수 있습니다. HTML 형식의 텍스트로 초기화된 NSAttributedStrings를 렌더링하는 것이 주된 목표이므로 NSAttributedString에 대한 편의 생성자를 만듭니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">import</span> UIKit\n\n<span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">NSAttributedString</span> {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">html</span>(<span class=\"hljs-params\">withBody</span> <span class=\"hljs-params\">body</span>: <span class=\"hljs-type\">String</span>) -> <span class=\"hljs-type\">NSAttributedString</span> {\n        <span class=\"hljs-comment\">// 앱에서 사용되는 현재 로케이션과 일치하는 HTML `lang` 속성을 매치합니다. (즉, Bundle.main)</span>\n        <span class=\"hljs-keyword\">let</span> bundle <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Bundle</span>.main\n        <span class=\"hljs-keyword\">let</span> lang <span class=\"hljs-operator\">=</span> bundle.preferredLocalizations.first\n            <span class=\"hljs-operator\">??</span> bundle.developmentLocalization\n            <span class=\"hljs-operator\">??</span> <span class=\"hljs-string\">\"en\"</span>\n\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">try?</span> <span class=\"hljs-type\">NSAttributedString</span>(\n            data: <span class=\"hljs-string\">\"\"\"\n            &#x3C;!doctype html>\n            &#x3C;html lang=\"<span class=\"hljs-subst\">\\(lang)</span>\">\n            &#x3C;head>\n                &#x3C;meta charset=\"utf-8\">\n                &#x3C;style type=\"text/css\">\n                    /*\n                      HTML 형식의 텍스트에 대한 사용자 정의 CSS 스타일 지정\n                      주의: NSAttributedString/UITextView에서 지원하는 CSS 기능은 제한적입니다.\n                    */\n\n                    body {\n                        font: -apple-system-body;\n                        color: <span class=\"hljs-subst\">\\(UIColor.secondaryLabel.hex)</span>;\n                    }\n\n                    h1, h2, h3, h4, h5, h6 {\n                        color: <span class=\"hljs-subst\">\\(UIColor.label.hex)</span>;\n                    }\n\n                    a {\n                        color: <span class=\"hljs-subst\">\\(UIColor.systemGreen.hex)</span>;\n                    }\n\n                    li:last-child {\n                        margin-bottom: 1em;\n                    }\n                &#x3C;/style>\n            &#x3C;/head>\n            &#x3C;body>\n                <span class=\"hljs-subst\">\\(body)</span>\n            &#x3C;/body>\n            &#x3C;/html>\n            \"\"\"</span>.data(using: .utf8)<span class=\"hljs-operator\">!</span>,\n            options: [\n                .documentType: <span class=\"hljs-type\">NSAttributedString</span>.<span class=\"hljs-type\">DocumentType</span>.html,\n                .characterEncoding: <span class=\"hljs-type\">String</span>.<span class=\"hljs-type\">Encoding</span>.utf8.rawValue,\n            ],\n            documentAttributes: <span class=\"hljs-literal\">nil</span>\n        )) <span class=\"hljs-operator\">??</span> <span class=\"hljs-type\">NSAttributedString</span>(string: body)\n    }\n}\n\n<span class=\"hljs-comment\">// UIColor를 CSS 친화적인 색상 헥스 문자열로 변환</span>\n\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">UIColor</span> {\n    <span class=\"hljs-keyword\">var</span> hex: <span class=\"hljs-type\">String</span> {\n        <span class=\"hljs-keyword\">var</span> red: <span class=\"hljs-type\">CGFloat</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">var</span> green: <span class=\"hljs-type\">CGFloat</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">var</span> blue: <span class=\"hljs-type\">CGFloat</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">var</span> alpha: <span class=\"hljs-type\">CGFloat</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>\n\n        getRed(<span class=\"hljs-operator\">&#x26;</span>red, green: <span class=\"hljs-operator\">&#x26;</span>green, blue: <span class=\"hljs-operator\">&#x26;</span>blue, alpha: <span class=\"hljs-operator\">&#x26;</span>alpha)\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">String</span>(\n            format: <span class=\"hljs-string\">\"#%02lX%02lX%02lX%02lX\"</span>,\n            lroundf(<span class=\"hljs-type\">Float</span>(red <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">255</span>)),\n            lroundf(<span class=\"hljs-type\">Float</span>(green <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">255</span>)),\n            lroundf(<span class=\"hljs-type\">Float</span>(blue <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">255</span>)),\n            lroundf(<span class=\"hljs-type\">Float</span>(alpha <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">255</span>))\n        )\n    }\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>NSAttributedString은 일부 CSS 기능을 지원합니다 (안타깝게도 어딘가 제대로 문서화되지 않은 기능들이 있습니다), 하지만 인라인 및 별도의 태그 내에서 스타일을 정의하는 것이 가능합니다 (일반적으로 HTML head 태그의 일부로).</p>\n<h2>SwiftUI에서 HTML 렌더링하기</h2>\n<p>그런 다음, 우리는 AttributedText UIViewRepresentable을 사용하여 NSAttributedString 편리한 초기화자를 함께 사용하여 SwiftUI 앱에서 HTML을 렌더링할 수 있습니다 - 심지어 인라인 스타일링도 가능합니다!</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">SwiftUI</span>\n\nstruct <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">NavigationStack</span> {\n            <span class=\"hljs-title class_\">ScrollView</span> {\n                <span class=\"hljs-title class_\">AttributedText</span>(.<span class=\"hljs-title function_\">html</span>(<span class=\"hljs-attr\">withBody</span>: <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\"\n                &#x3C;h3>This is a H3 header&#x3C;/h3>\n                &#x3C;p>This is a paragraph&#x3C;/p>\n                &#x3C;ul>\n                    &#x3C;li>List item one&#x3C;/li>\n                    &#x3C;li>List item two&#x3C;/li>\n                &#x3C;/ul>\n                &#x3C;p>This is a paragraph with a &#x3C;a href=\"</span><span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//developer.apple.com/\">link&#x3C;/a>&#x3C;/p></span>\n                <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: blue; text-align: center;\"</span>></span>\n                    This is a paragraph with inline styling\n                <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span></span>\n                <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\"))\n                .padding()\n            }\n            .navigationTitle(\"</span><span class=\"hljs-title class_\">Render</span> <span class=\"hljs-variable constant_\">HTML</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title class_\">SwiftUI</span><span class=\"hljs-string\">\")\n        }\n    }\n}\n</span></code></pre>\n<div class=\"content-ad\"></div>\n<h2>보너스: 테마별 HTML 렌더링</h2>\n<p>만약 앱이 (색상) 테마 개념을 사용하여 앱 전반에 대한 색상 정보 등을 전파한다면, 현재 테마 정보를 기반으로 HTML을 스타일링할 수도 있습니다.</p>\n<p>사용자 정의 테마 환경 값과 다른 NSAttributedString 편의 이니셜라이저를 사용하면 다음과 같이 보일 수 있습니다:</p>\n<p>사용자 정의 테마 환경 값</p>\n<div class=\"content-ad\"></div>\n<p>다음은 Markdown 형식으로 테이블 태그를 변경한 코드입니다.</p>\n<p>import SwiftUI</p>\n<p>// Example of a simple Theme struct.\nstruct Theme {\nlet textPrimary: UIColor\nlet textSecondary: UIColor\nlet textInteractive: UIColor\n}</p>\n<p>extension Theme {\nstatic let <code>default</code> = Theme(\ntextPrimary: .label,\ntextSecondary: .secondaryLabel,\ntextInteractive: .systemGreen\n)\n}</p>\n<p>private struct ThemeEnvironmentKey: EnvironmentKey {\nstatic var defaultValue: Theme = .default\n}</p>\n<p>extension EnvironmentValues {\nvar theme: Theme {\nget { self[ThemeEnvironmentKey.self] }\nset { self[ThemeEnvironmentKey.self] = newValue }\n}\n}</p>\n<p>NSAttributedString을 위한 편리한 이니셜라이저</p>\n<p>import UIKit</p>\n<p>extension NSAttributedString {\nstatic func themedHtml(withBody body: String, theme: Theme = .default) -> NSAttributedString {\n// Match the HTML <code>lang</code> attribute to current localisation used by the app (aka Bundle.main).\nlet bundle = Bundle.main\nlet lang = bundle.preferredLocalizations.first\n?? bundle.developmentLocalization\n?? \"en\"</p>\n<pre><code>    return (try? NSAttributedString(\n        data: \"\"\"\n        &#x3C;!doctype html>\n        &#x3C;html lang=\"\\(lang)\">\n        &#x3C;head>\n            &#x3C;meta charset=\"utf-8\">\n            &#x3C;style type=\"text/css\">\n                /*\n                  Custom CSS styling of HTML formatted text.\n                  Note, only a limited number of CSS features are supported by NSAttributedString/UITextView.\n                */\n\n                body {\n                    font: -apple-system-body;\n                    color: \\(theme.textSecondary.hex);\n                }\n\n                h1, h2, h3, h4, h5, h6 {\n                    color: \\(theme.textPrimary.hex);\n                }\n\n                a {\n                    color: \\(theme.textInteractive.hex);\n                }\n\n                li:last-child {\n                    margin-bottom: 1em;\n                }\n            &#x3C;/style>\n        &#x3C;/head>\n        &#x3C;body>\n            \\(body)\n        &#x3C;/body>\n        &#x3C;/html>\n        \"\"\".data(using: .utf8)!,\n        options: [\n            .documentType: NSAttributedString.DocumentType.html,\n            .characterEncoding: String.Encoding.utf8.rawValue,\n        ],\n        documentAttributes: nil\n    )) ?? NSAttributedString(string: body)\n}\n</code></pre>\n<p>}</p>\n<p>// MARK: Converting UIColors into CSS friendly color hex string</p>\n<p>private extension UIColor {\nvar hex: String {\nvar red: CGFloat = 0\nvar green: CGFloat = 0\nvar blue: CGFloat = 0\nvar alpha: CGFloat = 0</p>\n<pre><code>    getRed(&#x26;red, green: &#x26;green, blue: &#x26;blue, alpha: &#x26;alpha)\n\n    return String(\n        format: \"#%02lX%02lX%02lX%02lX\",\n        lroundf(Float(red * 255)),\n        lroundf(Float(green * 255)),\n        lroundf(Float(blue * 255)),\n        lroundf(Float(alpha * 255))\n    )\n}\n</code></pre>\n<p>}</p>\n<p>SwiftUI에서 테마가 적용된 HTML 렌더링하기</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">import</span> SwiftUI\n\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-meta\">@Environment</span>(\\.theme) <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> theme: <span class=\"hljs-type\">Theme</span>\n\n    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> {\n        <span class=\"hljs-type\">NavigationStack</span> {\n            <span class=\"hljs-type\">ScrollView</span> {\n                <span class=\"hljs-type\">AttributedText</span>(.themedHtml(withBody: <span class=\"hljs-string\">\"\"\"\n                &#x3C;h3>This is a H3 header&#x3C;/h3>\n                &#x3C;p>This is a paragraph&#x3C;/p>\n                &#x3C;ul>\n                    &#x3C;li>List item one&#x3C;/li>\n                    &#x3C;li>List item two&#x3C;/li>\n                &#x3C;/ul>\n                &#x3C;p>This is a paragraph with a &#x3C;a href=\"https://developer.apple.com/\">link&#x3C;/a>&#x3C;/p>\n                &#x3C;p style=\"color: blue; text-align: center;\">\n                    This is a paragraph with inline styling\n                &#x3C;/p>\n                \"\"\"</span>, theme: theme))\n                .padding()\n            }\n            .navigationTitle(<span class=\"hljs-string\">\"Render Themed HTML in SwiftUI\"</span>)\n        }\n    }\n}\n</code></pre>\n<h2>이게 다야!</h2>\n<p>쉽죠! SwiftUI가 정말 멋지지만, 때로는 몇 년 동안 사랑해 온 UIKit 뷰와 기능을 임베드할 수 있는 것이 참 좋습니다.</p>\n<p>코딩하세요! 🙌</p>\n</body>\n</html>\n"},"__N_SSG":true}