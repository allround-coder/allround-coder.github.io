{"pageProps":{"post":{"title":"Nestjs에서 Retry 패턴 구현하는 방법","description":"","date":"2024-06-22 02:20","slug":"2024-06-22-ImplementRetryPatterninNestjs","content":"\n\n![2024-06-22-ImplementRetryPatterninNestjs_0.png](/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png)\n\n이 기사에서는 다시 시도 및 회로 차단 패턴의 개념을 살펴보고 구현해야 하는 시점과 이유를 파악할 것입니다.\n\n가끔은 추가 서비스를 활용해야 할 때가 있습니다. 우리의 서비스 또는 결제 서비스와 같은 타사 서비스를 호출할 때 상상해 보세요. 그때 결제 서비스가 부하 상태에 있어 우리 요청에 응답하지 못할 수 있습니다. 또는 네트워크 지연이나 인프라 서비스의 문제로 인해 요청이 처리되지 않을 수 있습니다. 그러나 요청을 다시 보내면 대상 서비스가 부하가 해소될 수 있거나 인프라 문제가 해결될 수 있으며 우리 요청이 성공적으로 처리될 수 있습니다.\n\n이 상황에서 우리는 어떻게 해야 할까요?\n개발자로서 우리의 책임 중 하나는 시스템 실패의 허용한도를 높이는 것입니다. 개발된 서비스는 다양한 시나리오와 상황에서 호환되며 방탄이어야 하며 원활한 사용자 경험을 제공해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n여러 번 시도하면 성공 응답을 받을 수 있는 경우가 있음을 알고 있습니다. 사용자에게는 제3자 서비스에서 오류가 발생하는 첫 번째 시도에 대해 응답하지 않아야 하며, 한 두 번 더 시도하면 성공 응답을 받을 수도 있습니다. 그러나 UnAuth, 액세스 거부 등과 같이 다시 시도할 수 없는 오류도 있음을 알고 있어야 합니다.\n\n이제 다른 개념, Jitter에 대해 알아보겠습니다!\n\n여러 클라이언트가 특정 서비스를 호출하려고 시도하는 상황을 상상해보세요. 해당 서비스는 부하를 받아 일부 클라이언트에게 응답하지 못할 것이며, 실패 응답을 받은 클라이언트는 동시에 해당 서비스를 호출하려고 하면 다시 부하를 받아 서비스 거부 상태가 될 것입니다. 이때, 다시 시도 사이에 지연을 설정하는 것이 좋습니다. 다음 공식을 통해 지연을 설정하세요:\n\n고정된 밀리초 + 임의의 밀리초\n\n<div class=\"content-ad\"></div>\n\n무작위 시간에 서비스를 호출하여 서비스가 스스로 회복될 수 있도록 도와줍니다.\n\n아래는 Axios와 호환되는 jitter를 사용한 재시도 유틸리티 서비스 구현 예시입니다:\n\n```js\nimport { Injectable } from '@nestjs/common';\nimport { AxiosResponse } from 'axios';\n\nexport type AxiosMethod = () => Promise<AxiosResponse>;\n\n@Injectable()\nexport class Retry {\n  constructor() {}\n\n  async retry(\n    axiosMethod: AxiosMethod,\n    retry: number,\n    delayInMs: number,\n    jitter: boolean,\n  ): Promise<AxiosResponse> {\n    try {\n      let res: AxiosResponse | null = null;\n\n      for (let i = 0; i <= retry; i++) {\n        try {\n          res = await axiosMethod();\n          break;\n        } catch (err) {\n          if (i < retry) {\n            const j = this.getJitter(jitter);\n            await this.executeWithDelay(delayInMs + j);\n            continue\n          } else {\n            throw err;\n          }\n        }\n      }\n      return res;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private executeWithDelay(delay: number) {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n  }\n\n  private getJitter(jitter: boolean) {\n    return jitter ? Math.floor(Math.random() * (200 - 50 + 1)) + 50 : 0;\n  }\n}\n```\n\n이 설명이 프로젝트 개발에 높은 실패 허용성을 가로지어드릴 수 있기를 바랍니다. 궁금한 점이 있으시면 언제든지 질문해주세요.👌\n\n<div class=\"content-ad\"></div>\n\n# 관련 자료\n\nhttps://learn.microsoft.com/en-us/azure/architecture/patterns/retry","ogImage":{"url":"/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png"},"coverImage":"/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png","tag":["Tech"],"readingTime":3},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png\" alt=\"2024-06-22-ImplementRetryPatterninNestjs_0.png\"></p>\n<p>이 기사에서는 다시 시도 및 회로 차단 패턴의 개념을 살펴보고 구현해야 하는 시점과 이유를 파악할 것입니다.</p>\n<p>가끔은 추가 서비스를 활용해야 할 때가 있습니다. 우리의 서비스 또는 결제 서비스와 같은 타사 서비스를 호출할 때 상상해 보세요. 그때 결제 서비스가 부하 상태에 있어 우리 요청에 응답하지 못할 수 있습니다. 또는 네트워크 지연이나 인프라 서비스의 문제로 인해 요청이 처리되지 않을 수 있습니다. 그러나 요청을 다시 보내면 대상 서비스가 부하가 해소될 수 있거나 인프라 문제가 해결될 수 있으며 우리 요청이 성공적으로 처리될 수 있습니다.</p>\n<p>이 상황에서 우리는 어떻게 해야 할까요?\n개발자로서 우리의 책임 중 하나는 시스템 실패의 허용한도를 높이는 것입니다. 개발된 서비스는 다양한 시나리오와 상황에서 호환되며 방탄이어야 하며 원활한 사용자 경험을 제공해야 합니다.</p>\n<div class=\"content-ad\"></div>\n<p>여러 번 시도하면 성공 응답을 받을 수 있는 경우가 있음을 알고 있습니다. 사용자에게는 제3자 서비스에서 오류가 발생하는 첫 번째 시도에 대해 응답하지 않아야 하며, 한 두 번 더 시도하면 성공 응답을 받을 수도 있습니다. 그러나 UnAuth, 액세스 거부 등과 같이 다시 시도할 수 없는 오류도 있음을 알고 있어야 합니다.</p>\n<p>이제 다른 개념, Jitter에 대해 알아보겠습니다!</p>\n<p>여러 클라이언트가 특정 서비스를 호출하려고 시도하는 상황을 상상해보세요. 해당 서비스는 부하를 받아 일부 클라이언트에게 응답하지 못할 것이며, 실패 응답을 받은 클라이언트는 동시에 해당 서비스를 호출하려고 하면 다시 부하를 받아 서비스 거부 상태가 될 것입니다. 이때, 다시 시도 사이에 지연을 설정하는 것이 좋습니다. 다음 공식을 통해 지연을 설정하세요:</p>\n<p>고정된 밀리초 + 임의의 밀리초</p>\n<div class=\"content-ad\"></div>\n<p>무작위 시간에 서비스를 호출하여 서비스가 스스로 회복될 수 있도록 도와줍니다.</p>\n<p>아래는 Axios와 호환되는 jitter를 사용한 재시도 유틸리티 서비스 구현 예시입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AxiosResponse</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'axios'</span>;\n\n<span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">AxiosMethod</span> = <span class=\"hljs-function\">() =></span> <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-title class_\">AxiosResponse</span>>;\n\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Retry</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) {}\n\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">retry</span>(\n    <span class=\"hljs-attr\">axiosMethod</span>: <span class=\"hljs-title class_\">AxiosMethod</span>,\n    <span class=\"hljs-attr\">retry</span>: number,\n    <span class=\"hljs-attr\">delayInMs</span>: number,\n    <span class=\"hljs-attr\">jitter</span>: boolean,\n  ): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-title class_\">AxiosResponse</span>> {\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">res</span>: <span class=\"hljs-title class_\">AxiosResponse</span> | <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>;\n\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C;= retry; i++) {\n        <span class=\"hljs-keyword\">try</span> {\n          res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">axiosMethod</span>();\n          <span class=\"hljs-keyword\">break</span>;\n        } <span class=\"hljs-keyword\">catch</span> (err) {\n          <span class=\"hljs-keyword\">if</span> (i &#x3C; retry) {\n            <span class=\"hljs-keyword\">const</span> j = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">getJitter</span>(jitter);\n            <span class=\"hljs-keyword\">await</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">executeWithDelay</span>(delayInMs + j);\n            <span class=\"hljs-keyword\">continue</span>\n          } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">throw</span> err;\n          }\n        }\n      }\n      <span class=\"hljs-keyword\">return</span> res;\n    } <span class=\"hljs-keyword\">catch</span> (error) {\n      <span class=\"hljs-keyword\">throw</span> error;\n    }\n  }\n\n  private <span class=\"hljs-title function_\">executeWithDelay</span>(<span class=\"hljs-params\">delay: number</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =></span> <span class=\"hljs-built_in\">setTimeout</span>(resolve, delay));\n  }\n\n  private <span class=\"hljs-title function_\">getJitter</span>(<span class=\"hljs-params\">jitter: boolean</span>) {\n    <span class=\"hljs-keyword\">return</span> jitter ? <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() * (<span class=\"hljs-number\">200</span> - <span class=\"hljs-number\">50</span> + <span class=\"hljs-number\">1</span>)) + <span class=\"hljs-number\">50</span> : <span class=\"hljs-number\">0</span>;\n  }\n}\n</code></pre>\n<p>이 설명이 프로젝트 개발에 높은 실패 허용성을 가로지어드릴 수 있기를 바랍니다. 궁금한 점이 있으시면 언제든지 질문해주세요.👌</p>\n<div class=\"content-ad\"></div>\n<h1>관련 자료</h1>\n<p><a href=\"https://learn.microsoft.com/en-us/azure/architecture/patterns/retry\" rel=\"nofollow\" target=\"_blank\">https://learn.microsoft.com/en-us/azure/architecture/patterns/retry</a></p>\n</body>\n</html>\n"},"__N_SSG":true}