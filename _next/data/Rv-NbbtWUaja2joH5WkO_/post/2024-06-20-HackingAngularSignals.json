{"pageProps":{"post":{"title":"앵귤러 시그널 해킹하기","description":"","date":"2024-06-20 05:43","slug":"2024-06-20-HackingAngularSignals","content":"\n\n앵귤러 시그널이 무엇인지 살펴보고, 기능을 확장하고 디버깅하는 데 어떻게 활용할 수 있는지 알아봅시다.\n\n## 앵귤러 시그널이란\n\n앵귤러 시그널은 다음과 같은 메서드가 있는 함수입니다:\n\n```js\nconst $val = signal(0);\n\n// 함수:\nconst value = $val();\n\n// 객체:\n$val.set(4);\n$val.update((v) => v * 2);\n```\n\n<div class=\"content-ad\"></div>\n\n어떻게 가능한 걸까요? JavaScript에서는 함수가 객체이기 때문입니다:\n\n```js\n// 함수 선언\nconst double = (val: number) => val * 2;\n\n// 메소드 추가\ndouble.isEven = (number: number) => number % 2 === 0;\n\n// 객체처럼 사용하기\ndouble.isEven(15) // false\n\n// 함수처럼 사용하기\ndouble(8) // 16\n```\n\n어떻게 활용할 수 있을까요?\n\n우리는 가능합니다:\n\n<div class=\"content-ad\"></div>\n\n- 새로운 메서드 추가하기\n- 수정 사항을 가로챌 수 있도록 set() 및 update() 메서드를 오버라이딩하기\n- 신호의 내부 상태 변수 및 메서드 읽기\n- 읽기를 가로챌 프록시 신호 생성하기\n\n## 신호 확장하기\n\n가끔 변수를 신호로 사용해야 하지만 코드의 일부는 대신 Observable로 사용하려고 할 수 있습니다.\n\n다행히도 신호 및 Observable의 인터페이스는 메서드 이름에서 충돌이 없습니다. 그러니 하이브리드를 만들어 보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```typescript\n// 여기서는 단순히 기존 객체에 새로운 메서드를 추가하고 있습니다.\n\n또는 Proxy 객체를 만들어서 요청된 메서드를 가지고 있지 않은 Signal에 대해서만 Observable의 메서드를 반환할 수 있습니다:\n\nexport function toObservableSignal<T>(s: Signal<T>) {\n\n  const obs = toObservable(s, options); \n   \n  return new Proxy(s, {\n    get(_, prop) {\n      if (prop in s) {\n        return (s as any)[prop];\n      }\n      return (obs as any)[prop];\n    }\n  });\n}\n\n<div class=\"content-ad\"></div>\n\n아래는 사용 예시입니다:\n\n@Component({\n  //...\n  template: `\n    <h4>Signal A: { a() }</h4>\n    <h4>Observable A: {a|async}</h4>\n    <h4>Signal C (computed() A*3): {c()}</h4>\n\n    {quote()}\n  `,\n})\nexport class App {\n  a = toObservableSignal(signal<number>(1));\n\n  // use as Observable\n  b = this.a.pipe(\n    debounceTime(500),\n    distinctUntilChanged(),\n    switchMap((v) => this.http.get('https://dummyjson.com/quotes/' + v))\n  );\n\n  // use as Signal\n  c = computed(() => this.a() * 3);\n\n  quote = toSignal(this.b);\n\n  increment() {\n    // \"a\" will not stop being a Signal after \n    // we used it as an Observable\n    this.a.update((v) => v + 1);\n  }\n\n  decrement() {\n    this.a.update((v) => Math.max(1, v - 1));\n  }\n}\n\nNG Extension Platform에서 이 기능을 찾을 수 있습니다. \n\n원하는 함수로 Signal을 확장할 수 있습니다. 여기서 상상력에는 거의 제한이 없습니다. 단, set, update, asReadonly라는 이름은 사용하지 않도록 주의하세요.\n\n<div class=\"content-ad\"></div>\n\n## 기존 메서드 재정의\n\n저희 Signal에 값을 입력 변환하거나 다른 곳에 정보를 복제하거나 디버깅을 위해 쓰기를 중간에서 가로채고 싶다고 가정해 봅시다.\n\nfunction skipNonEvenNumbers(s: WritableSignal<number>) {\n  const srcSet = s.set; // 재귀를 피하기 위해 소스 메서드가 필요합니다\n\n  s.set = (value: number) => {\n    if (value % 2 !== 0) {\n      console.warn('[set] skipping:', value);\n      return;\n    }\n    console.log('[set]:', value);\n    srcSet(value);\n  };\n  s.update = (updateFn: (value: number) => number) => {\n    const value = updateFn(s());\n    if (value % 2 !== 0) {\n      console.warn('[update] skipping:', value);\n      return;\n    }\n    console.log('[update]:', value);\n    srcSet(value);\n  };\n}\n\n사용 예시:\n\n<div class=\"content-ad\"></div>\n\n이 기법은 Reactive Storage: getWritableSignal()에서 사용됩니다.\n\n## 시그널 내부\n\nAngular 시그널은 단순히 함수가 아니라 객체입니다. 이 객체에는 흥미로운 데이터와 함수가 담긴 숨겨진 필드 SIGNAL이 있습니다. 이것을 가지고 있어서 좋고, 남용하지 않았으면 좋겠습니다. 왜냐하면 위의 기법들은 \"약간 꼼수적\"이었고, 아래의 기법들은 디버깅, 개발 도구 생성, 재미를 위해서만 사용할 수 있습니다.\n\n모든 Angular 시그널은 ReactiveNode를 확장합니다:\n\n<div class=\"content-ad\"></div>\n\n// packages/core/primitives/signals/src/graph.ts\n\nexport const REACTIVE_NODE: ReactiveNode = {\n  version: 0 as Version,\n  lastCleanEpoch: 0 as Version,\n  dirty: false,\n  producerNode: undefined,\n  producerLastReadVersion: undefined,\n  producerIndexOfThis: undefined,\n  nextProducerIndex: 0,\n  liveConsumerNode: undefined,\n  liveConsumerIndexOfThis: undefined,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {},\n  consumerMarkedDirty: () => {},\n  consumerOnSignalRead: () => {},\n};\n\n이렇게:\n\n// packages/core/primitives/signals/src/signal.ts\n\nexport const SIGNAL_NODE = {\n  ...REACTIVE_NODE,\n  equal: defaultEquals,\n  value: undefined,\n}\n\n하지만 실제로 Signal 객체가 인스턴스화되면 이들이 모두 직접적으로 포함되지 않습니다. 모두 Symbol을 이름으로 사용하는 필드 아래에 숨겨져 있습니다:\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n// packages/core/primitives/signals/src/signal.ts\n\nexport function createSignal<T>(initialValue: T): SignalGetter<T> {\n  const node: SignalNode<T> = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  const getter = (() => {\n                   producerAccessed(node);\n                   return node.value;\n                 }) as SignalGetter<T>;\n\n  // 다음 줄은 SIGNAL 필드에 SignalNode를 추가합니다:\n  (getter as any)[SIGNAL] = node;\n  return getter;\n}\n```\n\n그래서 signal $value를 가지고 있고 SIGNAL 필드에 액세스하는 경우, SIGNAL_NODE가 가지고 있는 모든 필드를 얻게 됩니다.\n\n어떻게 사용할 수 있을까요?\n\n우리는 필드를 읽고 액세스를 가로채어 디버깅에 사용하거나 Signal 내부에서 무슨 일이 일어나는지를 설명하는 멋진 도구를 생성하는 데 사용할 수 있습니다. 종속성 그래프를 렌더링할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n심지어 일부 필드를 엑세서로 변환할 수도 있습니다:\n\n```js\nfunction getSignalVersion<T>(s: WritableSignal<T>): Signal<number> {\n  const node = s[SIGNAL];\n  const $version = signal(0);\n\n  Object.defineProperty(node, 'version', {\n    get: () => {\n      const v = untracked($version);\n      console.log('🟢 reading:', v);\n      return v;\n    },\n    set: (v) => {\n      untracked(() => $version.set(v));\n      console.log('🔴 writing:', v);\n    },\n  });\n\n  return $version.asReadonly();\n}\n```\n\nStackBlitz:\n\n또는 `effect()` 없이 Signal 읽기를 감시할 수 있는 프록시를 생성할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction watchSignalReads<T, M extends Signal<T> | WritableSignal<T>>(s: M): M {\n  const node = s[SIGNAL];\n  const newGetter = () => {\n    const value = s();\n    console.log('Read:', value);\n    return value;\n  };\n  (newGetter as any)[SIGNAL] = node;\n  if (s.hasOwnProperty('set')) {\n    const w = s as WritableSignal<T>;\n    newGetter.set = w.set;\n    newGetter.update = w.update;\n    newGetter.asReadonly = w.asReadonly;\n  }\n\n  return newGetter as M;\n}\n```\n\n사용 예시:\n\n다시 말하지만, 이를 \"배포 환경\"에서 사용하지 말고, 대신에 멋진 도구를 만들고 인정을 받아 Angular 생태계를 풍요롭게 하는 데 활용하길 바래요 😎","ogImage":{"url":"/assets/img/2024-06-20-HackingAngularSignals_0.png"},"coverImage":"/assets/img/2024-06-20-HackingAngularSignals_0.png","tag":["Tech"],"readingTime":6},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>앵귤러 시그널이 무엇인지 살펴보고, 기능을 확장하고 디버깅하는 데 어떻게 활용할 수 있는지 알아봅시다.</p>\n<h2>앵귤러 시그널이란</h2>\n<p>앵귤러 시그널은 다음과 같은 메서드가 있는 함수입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> $val = <span class=\"hljs-title function_\">signal</span>(<span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-comment\">// 함수:</span>\n<span class=\"hljs-keyword\">const</span> value = $val();\n\n<span class=\"hljs-comment\">// 객체:</span>\n$val.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">4</span>);\n$val.<span class=\"hljs-title function_\">update</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =></span> v * <span class=\"hljs-number\">2</span>);\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>어떻게 가능한 걸까요? JavaScript에서는 함수가 객체이기 때문입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 함수 선언</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">double</span> = (<span class=\"hljs-params\">val: number</span>) => val * <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-comment\">// 메소드 추가</span>\ndouble.<span class=\"hljs-property\">isEven</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">number: number</span>) =></span> number % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>;\n\n<span class=\"hljs-comment\">// 객체처럼 사용하기</span>\ndouble.<span class=\"hljs-title function_\">isEven</span>(<span class=\"hljs-number\">15</span>) <span class=\"hljs-comment\">// false</span>\n\n<span class=\"hljs-comment\">// 함수처럼 사용하기</span>\n<span class=\"hljs-title function_\">double</span>(<span class=\"hljs-number\">8</span>) <span class=\"hljs-comment\">// 16</span>\n</code></pre>\n<p>어떻게 활용할 수 있을까요?</p>\n<p>우리는 가능합니다:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>새로운 메서드 추가하기</li>\n<li>수정 사항을 가로챌 수 있도록 set() 및 update() 메서드를 오버라이딩하기</li>\n<li>신호의 내부 상태 변수 및 메서드 읽기</li>\n<li>읽기를 가로챌 프록시 신호 생성하기</li>\n</ul>\n<h2>신호 확장하기</h2>\n<p>가끔 변수를 신호로 사용해야 하지만 코드의 일부는 대신 Observable로 사용하려고 할 수 있습니다.</p>\n<p>다행히도 신호 및 Observable의 인터페이스는 메서드 이름에서 충돌이 없습니다. 그러니 하이브리드를 만들어 보겠습니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// 여기서는 단순히 기존 객체에 새로운 메서드를 추가하고 있습니다.</span>\n\n또는 <span class=\"hljs-title class_\">Proxy</span> 객체를 만들어서 요청된 메서드를 가지고 있지 않은 <span class=\"hljs-title class_\">Signal</span>에 대해서만 <span class=\"hljs-title class_\">Observable</span>의 메서드를 반환할 수 있습니다:\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> toObservableSignal&#x3C;T>(<span class=\"hljs-attr\">s</span>: <span class=\"hljs-title class_\">Signal</span>&#x3C;T>) {\n\n  <span class=\"hljs-keyword\">const</span> obs = <span class=\"hljs-title function_\">toObservable</span>(s, options); \n   \n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(s, {\n    <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\">_, prop</span>) {\n      <span class=\"hljs-keyword\">if</span> (prop <span class=\"hljs-keyword\">in</span> s) {\n        <span class=\"hljs-keyword\">return</span> (s <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>)[prop];\n      }\n      <span class=\"hljs-keyword\">return</span> (obs <span class=\"hljs-keyword\">as</span> <span class=\"hljs-built_in\">any</span>)[prop];\n    }\n  });\n}\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n아래는 사용 예시입니다:\n\n<span class=\"hljs-meta\">@Component</span>({\n  <span class=\"hljs-comment\">//...</span>\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &#x3C;h4>Signal A: { a() }&#x3C;/h4>\n    &#x3C;h4>Observable A: {a|async}&#x3C;/h4>\n    &#x3C;h4>Signal C (computed() A*3): {c()}&#x3C;/h4>\n\n    {quote()}\n  `</span>,\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">App</span> {\n  a = <span class=\"hljs-title function_\">toObservableSignal</span>(signal&#x3C;<span class=\"hljs-built_in\">number</span>>(<span class=\"hljs-number\">1</span>));\n\n  <span class=\"hljs-comment\">// use as Observable</span>\n  b = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>.<span class=\"hljs-title function_\">pipe</span>(\n    <span class=\"hljs-title function_\">debounceTime</span>(<span class=\"hljs-number\">500</span>),\n    <span class=\"hljs-title function_\">distinctUntilChanged</span>(),\n    <span class=\"hljs-title function_\">switchMap</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =></span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">http</span>.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">'https://dummyjson.com/quotes/'</span> + v))\n  );\n\n  <span class=\"hljs-comment\">// use as Signal</span>\n  c = <span class=\"hljs-title function_\">computed</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">a</span>() * <span class=\"hljs-number\">3</span>);\n\n  quote = <span class=\"hljs-title function_\">toSignal</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">b</span>);\n\n  <span class=\"hljs-title function_\">increment</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// \"a\" will not stop being a Signal after </span>\n    <span class=\"hljs-comment\">// we used it as an Observable</span>\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>.<span class=\"hljs-title function_\">update</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =></span> v + <span class=\"hljs-number\">1</span>);\n  }\n\n  <span class=\"hljs-title function_\">decrement</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">a</span>.<span class=\"hljs-title function_\">update</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =></span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(<span class=\"hljs-number\">1</span>, v - <span class=\"hljs-number\">1</span>));\n  }\n}\n\n<span class=\"hljs-variable constant_\">NG</span> <span class=\"hljs-title class_\">Extension</span> <span class=\"hljs-title class_\">Platform</span>에서 이 기능을 찾을 수 있습니다. \n\n원하는 함수로 <span class=\"hljs-title class_\">Signal</span>을 확장할 수 있습니다. 여기서 상상력에는 거의 제한이 없습니다. 단, set, update, asReadonly라는 이름은 사용하지 않도록 주의하세요.\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n## 기존 메서드 재정의\n\n저희 <span class=\"hljs-title class_\">Signal</span>에 값을 입력 변환하거나 다른 곳에 정보를 복제하거나 디버깅을 위해 쓰기를 중간에서 가로채고 싶다고 가정해 봅시다.\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">skipNonEvenNumbers</span>(<span class=\"hljs-params\">s: WritableSignal&#x3C;<span class=\"hljs-built_in\">number</span>></span>) {\n  <span class=\"hljs-keyword\">const</span> srcSet = s.<span class=\"hljs-property\">set</span>; <span class=\"hljs-comment\">// 재귀를 피하기 위해 소스 메서드가 필요합니다</span>\n\n  s.<span class=\"hljs-property\">set</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">value: <span class=\"hljs-built_in\">number</span></span>) =></span> {\n    <span class=\"hljs-keyword\">if</span> (value % <span class=\"hljs-number\">2</span> !== <span class=\"hljs-number\">0</span>) {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">'[set] skipping:'</span>, value);\n      <span class=\"hljs-keyword\">return</span>;\n    }\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'[set]:'</span>, value);\n    <span class=\"hljs-title function_\">srcSet</span>(value);\n  };\n  s.<span class=\"hljs-property\">update</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">updateFn: (value: <span class=\"hljs-built_in\">number</span>) => <span class=\"hljs-built_in\">number</span></span>) =></span> {\n    <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-title function_\">updateFn</span>(<span class=\"hljs-title function_\">s</span>());\n    <span class=\"hljs-keyword\">if</span> (value % <span class=\"hljs-number\">2</span> !== <span class=\"hljs-number\">0</span>) {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">'[update] skipping:'</span>, value);\n      <span class=\"hljs-keyword\">return</span>;\n    }\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'[update]:'</span>, value);\n    <span class=\"hljs-title function_\">srcSet</span>(value);\n  };\n}\n\n사용 예시:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n이 기법은 <span class=\"hljs-title class_\">Reactive</span> <span class=\"hljs-title class_\">Storage</span>: <span class=\"hljs-title function_\">getWritableSignal</span>()에서 사용됩니다.\n\n## 시그널 내부\n\n<span class=\"hljs-title class_\">Angular</span> 시그널은 단순히 함수가 아니라 객체입니다. 이 객체에는 흥미로운 데이터와 함수가 담긴 숨겨진 필드 <span class=\"hljs-variable constant_\">SIGNAL</span>이 있습니다. 이것을 가지고 있어서 좋고, 남용하지 않았으면 좋겠습니다. 왜냐하면 위의 기법들은 <span class=\"hljs-string\">\"약간 꼼수적\"</span>이었고, 아래의 기법들은 디버깅, 개발 도구 생성, 재미를 위해서만 사용할 수 있습니다.\n\n모든 <span class=\"hljs-title class_\">Angular</span> 시그널은 <span class=\"hljs-title class_\">ReactiveNode</span>를 확장합니다:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-comment\">// packages/core/primitives/signals/src/graph.ts</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">REACTIVE_NODE</span>: <span class=\"hljs-title class_\">ReactiveNode</span> = {\n  <span class=\"hljs-attr\">version</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Version</span>,\n  <span class=\"hljs-attr\">lastCleanEpoch</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Version</span>,\n  <span class=\"hljs-attr\">dirty</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">producerNode</span>: <span class=\"hljs-literal\">undefined</span>,\n  <span class=\"hljs-attr\">producerLastReadVersion</span>: <span class=\"hljs-literal\">undefined</span>,\n  <span class=\"hljs-attr\">producerIndexOfThis</span>: <span class=\"hljs-literal\">undefined</span>,\n  <span class=\"hljs-attr\">nextProducerIndex</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">liveConsumerNode</span>: <span class=\"hljs-literal\">undefined</span>,\n  <span class=\"hljs-attr\">liveConsumerIndexOfThis</span>: <span class=\"hljs-literal\">undefined</span>,\n  <span class=\"hljs-attr\">consumerAllowSignalWrites</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">consumerIsAlwaysLive</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">producerMustRecompute</span>: <span class=\"hljs-function\">() =></span> <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">producerRecomputeValue</span>: <span class=\"hljs-function\">() =></span> {},\n  <span class=\"hljs-attr\">consumerMarkedDirty</span>: <span class=\"hljs-function\">() =></span> {},\n  <span class=\"hljs-attr\">consumerOnSignalRead</span>: <span class=\"hljs-function\">() =></span> {},\n};\n\n이렇게:\n\n<span class=\"hljs-comment\">// packages/core/primitives/signals/src/signal.ts</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">SIGNAL_NODE</span> = {\n  ...<span class=\"hljs-variable constant_\">REACTIVE_NODE</span>,\n  <span class=\"hljs-attr\">equal</span>: defaultEquals,\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-literal\">undefined</span>,\n}\n\n하지만 실제로 <span class=\"hljs-title class_\">Signal</span> 객체가 인스턴스화되면 이들이 모두 직접적으로 포함되지 않습니다. 모두 <span class=\"hljs-title class_\">Symbol</span>을 이름으로 사용하는 필드 아래에 숨겨져 있습니다:\n</code></pre>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// packages/core/primitives/signals/src/signal.ts</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> createSignal&#x3C;T>(<span class=\"hljs-attr\">initialValue</span>: T): <span class=\"hljs-title class_\">SignalGetter</span>&#x3C;T> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">node</span>: <span class=\"hljs-title class_\">SignalNode</span>&#x3C;T> = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-variable constant_\">SIGNAL_NODE</span>);\n  node.<span class=\"hljs-property\">value</span> = initialValue;\n  <span class=\"hljs-keyword\">const</span> getter = (<span class=\"hljs-function\">() =></span> {\n                   <span class=\"hljs-title function_\">producerAccessed</span>(node);\n                   <span class=\"hljs-keyword\">return</span> node.<span class=\"hljs-property\">value</span>;\n                 }) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">SignalGetter</span>&#x3C;T>;\n\n  <span class=\"hljs-comment\">// 다음 줄은 SIGNAL 필드에 SignalNode를 추가합니다:</span>\n  (getter <span class=\"hljs-keyword\">as</span> any)[<span class=\"hljs-variable constant_\">SIGNAL</span>] = node;\n  <span class=\"hljs-keyword\">return</span> getter;\n}\n</code></pre>\n<p>그래서 signal $value를 가지고 있고 SIGNAL 필드에 액세스하는 경우, SIGNAL_NODE가 가지고 있는 모든 필드를 얻게 됩니다.</p>\n<p>어떻게 사용할 수 있을까요?</p>\n<p>우리는 필드를 읽고 액세스를 가로채어 디버깅에 사용하거나 Signal 내부에서 무슨 일이 일어나는지를 설명하는 멋진 도구를 생성하는 데 사용할 수 있습니다. 종속성 그래프를 렌더링할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>심지어 일부 필드를 엑세서로 변환할 수도 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> getSignalVersion&#x3C;T>(<span class=\"hljs-attr\">s</span>: <span class=\"hljs-title class_\">WritableSignal</span>&#x3C;T>): <span class=\"hljs-title class_\">Signal</span>&#x3C;number> {\n  <span class=\"hljs-keyword\">const</span> node = s[<span class=\"hljs-variable constant_\">SIGNAL</span>];\n  <span class=\"hljs-keyword\">const</span> $version = <span class=\"hljs-title function_\">signal</span>(<span class=\"hljs-number\">0</span>);\n\n  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(node, <span class=\"hljs-string\">'version'</span>, {\n    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-keyword\">const</span> v = <span class=\"hljs-title function_\">untracked</span>($version);\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'🟢 reading:'</span>, v);\n      <span class=\"hljs-keyword\">return</span> v;\n    },\n    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =></span> {\n      <span class=\"hljs-title function_\">untracked</span>(<span class=\"hljs-function\">() =></span> $version.<span class=\"hljs-title function_\">set</span>(v));\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'🔴 writing:'</span>, v);\n    },\n  });\n\n  <span class=\"hljs-keyword\">return</span> $version.<span class=\"hljs-title function_\">asReadonly</span>();\n}\n</code></pre>\n<p>StackBlitz:</p>\n<p>또는 <code>effect()</code> 없이 Signal 읽기를 감시할 수 있는 프록시를 생성할 수도 있습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> watchSignalReads&#x3C;T, M <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Signal</span>&#x3C;T> | <span class=\"hljs-title class_\">WritableSignal</span>&#x3C;T>>(<span class=\"hljs-attr\">s</span>: M): M {\n  <span class=\"hljs-keyword\">const</span> node = s[<span class=\"hljs-variable constant_\">SIGNAL</span>];\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">newGetter</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-title function_\">s</span>();\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Read:'</span>, value);\n    <span class=\"hljs-keyword\">return</span> value;\n  };\n  (newGetter <span class=\"hljs-keyword\">as</span> any)[<span class=\"hljs-variable constant_\">SIGNAL</span>] = node;\n  <span class=\"hljs-keyword\">if</span> (s.<span class=\"hljs-title function_\">hasOwnProperty</span>(<span class=\"hljs-string\">'set'</span>)) {\n    <span class=\"hljs-keyword\">const</span> w = s <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">WritableSignal</span>&#x3C;T>;\n    newGetter.<span class=\"hljs-property\">set</span> = w.<span class=\"hljs-property\">set</span>;\n    newGetter.<span class=\"hljs-property\">update</span> = w.<span class=\"hljs-property\">update</span>;\n    newGetter.<span class=\"hljs-property\">asReadonly</span> = w.<span class=\"hljs-property\">asReadonly</span>;\n  }\n\n  <span class=\"hljs-keyword\">return</span> newGetter <span class=\"hljs-keyword\">as</span> M;\n}\n</code></pre>\n<p>사용 예시:</p>\n<p>다시 말하지만, 이를 \"배포 환경\"에서 사용하지 말고, 대신에 멋진 도구를 만들고 인정을 받아 Angular 생태계를 풍요롭게 하는 데 활용하길 바래요 😎</p>\n</body>\n</html>\n"},"__N_SSG":true}