{"pageProps":{"post":{"title":"앵귤러 애플리케이션 보안 자바스크립트 난독화","description":"","date":"2024-05-12 20:49","slug":"2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation","content":"\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*wEYlPHz1sMXAZ6802MPrrw.gif\" />\n\n앵귤러는 주로 클라이언트 측 애플리케이션이기 때문에 코드가 사용자에게 노출됩니다. 적절한 기술을 갖추면 애플리케이션을 역공학하거나 내부 로직을 이해할 수 있습니다. 이를 방지하기 위해 코드를 암호화하여 명확함을 줄이고 이해하기 어렵게 만드는 것이 좋습니다.\n\n<img src=\"/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_0.png\" />\n\n기본 제공된 앵귤러를 사용할 때 노출되는 것들:\n\n\n\n- 서비스\n- 구성요소\n- 설정\n\n우리 애플리케이션을 안전하게 보호하기 위해 비즈니스 로직을 보호해야 합니다. 데이터를 안전하게 유지하기 위해 코드베이스를 난독화해야 합니다. 그러나 uglifyjs와 같은 도구를 사용할 수 있습니다. 이러한 도구들은 일정한 수준에서 유용하지만, 난독화가 더 나은 결과를 제공합니다.\n\n# 목차\n\n- JavaScript 난독화란 무엇인가요?\n- JavaScript 난독화 기법:\n- JavaScript 난독화 예시:\n- 설치 및 설정\n- 빌드 구성 업데이트:\n- JavaScript 난독화기에서 제공하는 옵션:\n- 결론\n- 다음 단계?\n\n\n\n# 자바스크립트 난독화란 무엇인가요?\n\n자바스크립트 난독화란 직관적이고 쉽게 읽을 수 있는 자바스크립트 코드를 어렵게 만들어서 이해하기 어렵고 역공학으로 해독하기 어렵도록 변환하는 일련의 코드 변환 기술을 말합니다.\n\n# 자바스크립트 난독화 기술 :\n\n자바스크립트 난독화 기술은 코드를 이해하기 어렵게 하거나 역공학을 어렵게 하거나 변경하기 어렵게 만들기 위해 사용됩니다. 이러한 기술은 코드의 논리와 구조를 흐리게 하면서 기능을 유지하는 것을 목표로 합니다. 여기에 몇 가지 자주 사용되는 자바스크립트 난독화 기술이 있습니다:\n\n\n\n변수 이름 변경:\n\n변수 이름을 설명적이지 않거나 짧거나 한 글자로 변경합니다. 이렇게 하면 각 변수의 목적을 이해하기 어려워집니다.\n\n함수 이름 변경:\n\n변수 이름 변경과 마찬가지로 함수의 이름을 변경하여 그 의도된 기능을 숨길 수 있습니다.\n\n\n\n문자열 암호화:\n\n코드에서 문자열 리터럴을 암호화하고 런타임에서 복호화하는 것입니다. 이는 코드를 이해하려는 누구에게 추가적인 복잡성을 더합니다.\n\n코드 분할:\n\n코드를 여러 작은 함수 또는 파일로 나눈 다음 동적으로 로딩하거나 결합하는 것을 말합니다. 이렇게 하면 코드 구조가 덜 명백해집니다.\n\n\n\n통제 흐름 난독화:\n\n코드의 논리를 혼란스럽게 만들기 위해 불필요하거나 오도하는 제어 흐름 문장(추가 루프 또는 조건문 등)을 도입합니다.\n\n죽은 코드 주입:\n\n사용되지 않거나 관련 없는 코드 조각을 주입하여 혼란을 빚습니다. 이로써 코드의 중요한 부분과 중요하지 않은 부분을 구분하는 것이 어려워집니다.\n\n\n\n문자열 연결:\n\n문자열을 분해하고 실행 중에 동적으로 연결하는 것을 말합니다. 이로 인해 코드에서 사용된 실제 문자열을 식별하기 어려워집니다.\n\n인코딩 및 디코딩:\n\n코드의 일부를 인코딩하고 실행 중에 디코딩하는 작업을 의미합니다. 이 과정에는 Base64 인코딩과 같은 기술을 사용합니다.\n\n\n\n숫자 변형:\n\n숫자를 수학적 표현이나 다른 숫자 표현으로 대체하여 상수 값을 숨기는 것입니다.\n\n디버깅 방지 기술:\n\n디버거 환경에서 애플리케이션이 실행 중인지 감지하는 코드를 포함하고, 코드의 동작을 이에 맞게 변경하는 것입니다.\n\n\n\n# JavaScript 난독화 예제:\n\n다음 코드를 고려해보세요:\n\n```js\nfunction getUserData() {\n  if(!user) {\n      return {};\n    }\n    let data = user.auth.providerData[0];\n    return {\n      name: data.displayName,\n      avatar: data.photoURL,\n      email: data.email,\n      provider: data.providerId,\n      uid: user.auth.uid\n    };\n}\nconsole.log(getUserData());\n```\n\n난독화/압축된 코드:\n\n\n\n```js\nfunction getUserData() {\n  if (!user) return {};\n  let e = user.auth.providerData[0];\n  return {\n    name: e.displayName,\n    avatar: e.photoURL,\n    email: e.email,\n    provider: e.providerId,\n    uid: user.auth.uid\n  };\n}\n\nconsole.log(getUserData());\n```\n\n여기서 코드가 변형되었습니다. 더 자세히 살펴보거나 포매터를 사용하면 코드의 기본 논리를 이해할 수 있습니다.\n\n다른 시나리오에서 억제된 후 :\n\n```js\n(function(_0x49e7cc, _0x35d5f6) {\n  const _0xdfe59 = _0x3b90,\n    _0xd4b26e = _0x49e7cc();\n\n  while (!![]) {\n    try {\n      const _0x20c64f = parseInt(_0xdfe59(0xf9)) / 0x1 * (-parseInt(_0xdfe59(0xfa)) / 0x2) + -parseInt(_0xdfe59(0xf7)) / 0x3 * (parseInt(_0xdfe59(0xfc)) / 0x4) + parseInt(_0xdfe59(0xee)) / 0x5 * (-parseInt(_0xdfe59(0xf1)) / 0x6) + parseInt(_0xdfe59(0xf5)) / 0x7 + \n        -parseInt(_0xdfe59(0xf4)) / 0x8 + -parseInt(_0xdfe59(0xf2)) / 0x9 + parseInt(_0xdfe59(0xf6)) / 0xa * (parseInt(_0xdfe59(0xf0)) / 0xb);\n      \n      if (_0x20c64f === _0x35d5f6) break;\n      else _0xd4b26e['push'](_0xd4b26e['shift']());\n    } catch (_0x29db07) {\n      _0xd4b26e['push'](_0xd4b26e['shift']());\n    }\n  })(_0x53ef, 0xd14a3);\n\nfunction getUserData() {\n  const _0x2d7b7b = _0x3b90;\n  if (!user) return {};\n  let _0x4c86a3 = user[_0x2d7b7b(0xef)]['providerData'][0x0];\n  return {\n    'name': _0x4c86a3['displayName'],\n    'avatar': _0x4c86a3[_0x2d7b7b(0xfb)],\n    'email': _0x4c86a3['email'],\n    'provider': _0x4c86a3[_0x2d7b7b(0xf8)],\n    'uid': user[_0x2d7b7b(0xef)][_0x2d7b7b(0xf3)]\n  };\n}\n\nfunction _0x3b90(_0x40fb4f, _0x21bcc3) {\n  const _0x53ef2b = _0x53ef();\n  return _0x3b90 = function(_0x3b900f, _0x3ce21b) {\n    _0x3b900f = _0x3b900f - 0xee;\n    let _0x3732d2 = _0x53ef2b[_0x3b900f];\n    return _0x3732d2;\n  }, _0x3b90(_0x40fb4f, _0x21bcc3);\n}\n\nfunction _0x53ef() {\n  const _0x2e2efd = ['providerId', '254438AtTuWZ', '10GIuQhB', 'photoURL', '4aVsWJI', '20vNbtpg', 'auth', '3729QVEYgK', '340284BhPkpf', '4165182zMXsCd', 'uid', '13082696dHfPHS', '10353784ybaJZp', '98830ItJwbd', '1125051BYspDY'];\n\n  _0x53ef = function() {\n    return _0x2e2efd;\n  };\n\n  return _0x53ef();\n}\n\nconsole['log'](getUserData());\n```\n\n\n\n위 코드는 이제 훨씬 복잡하고 이해하기 어려워졌는데, 이는 초기 접근 방식보다 훨씬 나은 결과입니다. 사실 더 많은 난독화 수준을 추가할 수 있으며, 이에 대해 더 이야기할 것입니다.\n\n이제 난독화를 위해 우리의 Angular 애플리케이션을 설정해 봅시다.\n\n# 설치 및 설정:\n\n우리는 javascript-obfuscator 및 wepack-obfuscator 플러그인을 사용하여 코드를 난독화할 것입니다.\n\n\n\n귀하는 Angular 어플리케이션에서 위의 패키지들을 다음 명령어를 사용하여 설치할 수 있습니다.\n\n```js\nnpm install --save-dev javascript-obfuscator webpack-obfuscator\n```\n\n웹팩 설정 파일 생성/업데이트 :\n\n위의 플러그인을 설치한 웹팩 설정 파일을 생성하거나 업데이트하려면 기존 웹팩 설정 파일을 다음과 같이 업데이트하실 수 있습니다.\n\n\n\n```js\nvar WebpackObfuscator = require('webpack-obfuscator');\nmodule.exports = {\n module: {\n  ...//옵션\n  },\n```\n\n```js\n// Webpack 플러그인 배열\nplugins: [\n    new WebpackObfuscator ({\n       debugProtection: true\n    }, ['vendor.js'])\n   ]\n}\n```\n\n우리는 앵귤러 애플리케이션의 빌드/배포를 구성할 것이며, 앞서 작성한 위의 webpack.config를 포함하기 위해 custom-webpack 빌더를 사용하는 angular.json을 업데이트할 것입니다.\n\n## 빌드 구성 업데이트:\n\n\n\n아래 명령어를 사용하여 custom-webpack 빌더를 설치하십시오:\n\n- 아래 명령어를 사용하여 앵귤러 커스텀 빌더를 설치하십시오:\n\n```js\nnpm i @angular-builders/custom-webpack\n```\n\n- 아래 코드를 사용하여 angular.json 빌더를 업데이트하십시오.\n\n\n\n```js\n{\n   ...\n   \"architect\": {\n        \"build\": {\n          \"builder\": \"@angular-builders/custom-webpack:browser\",\n          \"options\": {\n            \"customWebpackConfig\": {\n              \"path\": \"./extra-webpack.config.js\",\n              \"mergeStrategies\": {\n                \"module.rules\": \"prepend\"\n              },\n            },\n            \"outputPath\": \"dist\",\n            ...          \n          }\n        }\n   }\n}\n```\n\n이렇게 하면 우리 애플리케이션을 빌드하여 응용 프로그램의 난독화된 코드를 생성할 수 있습니다.\n\n난독화된 빌드 생성:\n\nAngular CLI 옵션을 사용하여 애플리케이션을 빌드하면 됩니다:\n\n\n\n\n```js\nng build\n```\n\n빌드 후 우리 애플리케이션에서 노출된 키가 더 이상 보이지 않는 것을 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_1.png\" />\n\n# JavaScript 난독화기에서 제공하는 옵션:\n\n\n\n위의 예제에서는 debugProtection을 true로 전달했을 때, 앱 내에서 디버깅을 방지하고 디버거를 활성화한 익명 함수를 삽입하는 결과를 가져옵니다.\n\n![이미지](/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_2.png)\n\n주요 옵션 몇 가지:\n\n- stringArray:\n문자열 리터럴을 제거하고 특수 배열에 배치합니다. 예를 들어, var m = \"Hello World\";의 \"Hello World\" 문자열은 var m = _0x13a678[0x2];와 같은 것으로 대체됩니다.\n- stringArrayThreshold:\n문자열 리터럴이 stringArray에 삽입될 확률을 조정하는 데 사용할 수 있습니다(0부터 1까지). 기본값은 0.8입니다(1로 유지하면 일부 단계에서 코드가 중단됩니다).\n- debugProtection:\n위에서 보았듯이 디버깅 보호를 활성화합니다. 활성화된 디버깅 보호 간격(밀리초 단위).\n- transformObjectKeys:\n객체 키에 대한 변환을 적용할지 여부를 결정합니다(기본값: false).\n- forceTransformStrings:\n문자열 리터럴 추가가 확률에 기반하기 때문에 특정 키를 강제로 문자열 배열에 추가할 수 있습니다. 정규 표현식 배열을 수락합니다(특수 문자를 포함하는 문자열을 사용할 때 이스케이프 문자를 사용하세요).\n- stringArrayEncoding:\n문자열 리터럴을 base64 또는 rc4를 사용하여 인코딩합니다. 배열을 수락합니다. 아래 구성에서 stringArray 값은 인코딩되지 않으며 일부 값은 base64 및 rc4 인코딩으로 인코딩됩니다:\n\n\n\n```kotlin\nstringArrayEncoding: [\n    'none',\n    'base64',\n    'rc4'\n]\n```\n\n이것들은 유용할 수 있는 몇 가지 인기있는 키들입니다. 관련 정보를 더 읽어보고 여기에서 시도해 볼 수 있어요.\n\n코드 문제가 발생할 경우(정의되지 않은 속성을 가져올 때, 정의되지 않은 속성을 누를 때 또는 prototype이 정의되지 않았을 때 등 몇 가지를 들어봤어요) 아래 구성을 사용해 보세요:\n\n```kotlin\nnew WebpackObfuscator({\n        compact: true,\n        controlFlowFlattening: false,\n        deadCodeInjection: false,\n        debugProtection: false,\n        identifierNamesGenerator: 'hexadecimal',\n        numbersToExpressions: false,\n        renameGlobals: false,\n        selfDefending: false,\n        simplify: false,\n        splitStrings: false,\n        stringArray: true,\n        transformObjectKeys: false,\n        stringArrayCallsTransform: false,\n        stringArrayEncoding: [],\n        stringArrayIndexShift: false,\n        stringArrayRotate: false,\n        stringArrayShuffle: false,\n        stringArrayWrappersCount: 0,\n        stringArrayWrappersChainedCalls: false,\n        stringArrayWrappersParametersMaxCount: 2,\n        stringArrayWrappersType: 'variable',\n        stringArrayThreshold: 1,\n        unicodeEscapeSequence: false,\n        renamePropertiesMode: 'safe',\n        renameProperties: false\n    },['vendor.js']),\n```\n\n\n\nangular 프레임워크 관련 오류를 위해 vendor.js를 포함했어요 (선택 사항입니다). 몇 가지 기본 옵션이 복원되었으며 제거할 수 있어요.\n\n# 결론\n\n우리는 우리의 Angular 코드베이스를 난독화하여 더 안전한 코드로 한 걸음 더 가까워졌어요. 우리가 Angular에 구현했지만, 리액트와 같은 다른 프레임워크에도 구현할 수 있어요.\n\n# 다음은 무엇인가요?\n\n\n\n암호화: AES 및 RSA를 사용하여 네트워크 요청을 암호화하여 데이터를 기밀 유지합니다.\n\n참고 문헌:","ogImage":{"url":"/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_0.png"},"coverImage":"/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*wEYlPHz1sMXAZ6802MPrrw.gif\">\n<p>앵귤러는 주로 클라이언트 측 애플리케이션이기 때문에 코드가 사용자에게 노출됩니다. 적절한 기술을 갖추면 애플리케이션을 역공학하거나 내부 로직을 이해할 수 있습니다. 이를 방지하기 위해 코드를 암호화하여 명확함을 줄이고 이해하기 어렵게 만드는 것이 좋습니다.</p>\n<img src=\"/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_0.png\">\n<p>기본 제공된 앵귤러를 사용할 때 노출되는 것들:</p>\n<ul>\n<li>서비스</li>\n<li>구성요소</li>\n<li>설정</li>\n</ul>\n<p>우리 애플리케이션을 안전하게 보호하기 위해 비즈니스 로직을 보호해야 합니다. 데이터를 안전하게 유지하기 위해 코드베이스를 난독화해야 합니다. 그러나 uglifyjs와 같은 도구를 사용할 수 있습니다. 이러한 도구들은 일정한 수준에서 유용하지만, 난독화가 더 나은 결과를 제공합니다.</p>\n<h1>목차</h1>\n<ul>\n<li>JavaScript 난독화란 무엇인가요?</li>\n<li>JavaScript 난독화 기법:</li>\n<li>JavaScript 난독화 예시:</li>\n<li>설치 및 설정</li>\n<li>빌드 구성 업데이트:</li>\n<li>JavaScript 난독화기에서 제공하는 옵션:</li>\n<li>결론</li>\n<li>다음 단계?</li>\n</ul>\n<h1>자바스크립트 난독화란 무엇인가요?</h1>\n<p>자바스크립트 난독화란 직관적이고 쉽게 읽을 수 있는 자바스크립트 코드를 어렵게 만들어서 이해하기 어렵고 역공학으로 해독하기 어렵도록 변환하는 일련의 코드 변환 기술을 말합니다.</p>\n<h1>자바스크립트 난독화 기술 :</h1>\n<p>자바스크립트 난독화 기술은 코드를 이해하기 어렵게 하거나 역공학을 어렵게 하거나 변경하기 어렵게 만들기 위해 사용됩니다. 이러한 기술은 코드의 논리와 구조를 흐리게 하면서 기능을 유지하는 것을 목표로 합니다. 여기에 몇 가지 자주 사용되는 자바스크립트 난독화 기술이 있습니다:</p>\n<p>변수 이름 변경:</p>\n<p>변수 이름을 설명적이지 않거나 짧거나 한 글자로 변경합니다. 이렇게 하면 각 변수의 목적을 이해하기 어려워집니다.</p>\n<p>함수 이름 변경:</p>\n<p>변수 이름 변경과 마찬가지로 함수의 이름을 변경하여 그 의도된 기능을 숨길 수 있습니다.</p>\n<p>문자열 암호화:</p>\n<p>코드에서 문자열 리터럴을 암호화하고 런타임에서 복호화하는 것입니다. 이는 코드를 이해하려는 누구에게 추가적인 복잡성을 더합니다.</p>\n<p>코드 분할:</p>\n<p>코드를 여러 작은 함수 또는 파일로 나눈 다음 동적으로 로딩하거나 결합하는 것을 말합니다. 이렇게 하면 코드 구조가 덜 명백해집니다.</p>\n<p>통제 흐름 난독화:</p>\n<p>코드의 논리를 혼란스럽게 만들기 위해 불필요하거나 오도하는 제어 흐름 문장(추가 루프 또는 조건문 등)을 도입합니다.</p>\n<p>죽은 코드 주입:</p>\n<p>사용되지 않거나 관련 없는 코드 조각을 주입하여 혼란을 빚습니다. 이로써 코드의 중요한 부분과 중요하지 않은 부분을 구분하는 것이 어려워집니다.</p>\n<p>문자열 연결:</p>\n<p>문자열을 분해하고 실행 중에 동적으로 연결하는 것을 말합니다. 이로 인해 코드에서 사용된 실제 문자열을 식별하기 어려워집니다.</p>\n<p>인코딩 및 디코딩:</p>\n<p>코드의 일부를 인코딩하고 실행 중에 디코딩하는 작업을 의미합니다. 이 과정에는 Base64 인코딩과 같은 기술을 사용합니다.</p>\n<p>숫자 변형:</p>\n<p>숫자를 수학적 표현이나 다른 숫자 표현으로 대체하여 상수 값을 숨기는 것입니다.</p>\n<p>디버깅 방지 기술:</p>\n<p>디버거 환경에서 애플리케이션이 실행 중인지 감지하는 코드를 포함하고, 코드의 동작을 이에 맞게 변경하는 것입니다.</p>\n<h1>JavaScript 난독화 예제:</h1>\n<p>다음 코드를 고려해보세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getUserData</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">if</span>(!user) {\n      <span class=\"hljs-keyword\">return</span> {};\n    }\n    <span class=\"hljs-keyword\">let</span> data = user.<span class=\"hljs-property\">auth</span>.<span class=\"hljs-property\">providerData</span>[<span class=\"hljs-number\">0</span>];\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">name</span>: data.<span class=\"hljs-property\">displayName</span>,\n      <span class=\"hljs-attr\">avatar</span>: data.<span class=\"hljs-property\">photoURL</span>,\n      <span class=\"hljs-attr\">email</span>: data.<span class=\"hljs-property\">email</span>,\n      <span class=\"hljs-attr\">provider</span>: data.<span class=\"hljs-property\">providerId</span>,\n      <span class=\"hljs-attr\">uid</span>: user.<span class=\"hljs-property\">auth</span>.<span class=\"hljs-property\">uid</span>\n    };\n}\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">getUserData</span>());\n</code></pre>\n<p>난독화/압축된 코드:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getUserData</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">if</span> (!user) <span class=\"hljs-keyword\">return</span> {};\n  <span class=\"hljs-keyword\">let</span> e = user.<span class=\"hljs-property\">auth</span>.<span class=\"hljs-property\">providerData</span>[<span class=\"hljs-number\">0</span>];\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">name</span>: e.<span class=\"hljs-property\">displayName</span>,\n    <span class=\"hljs-attr\">avatar</span>: e.<span class=\"hljs-property\">photoURL</span>,\n    <span class=\"hljs-attr\">email</span>: e.<span class=\"hljs-property\">email</span>,\n    <span class=\"hljs-attr\">provider</span>: e.<span class=\"hljs-property\">providerId</span>,\n    <span class=\"hljs-attr\">uid</span>: user.<span class=\"hljs-property\">auth</span>.<span class=\"hljs-property\">uid</span>\n  };\n}\n\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">getUserData</span>());\n</code></pre>\n<p>여기서 코드가 변형되었습니다. 더 자세히 살펴보거나 포매터를 사용하면 코드의 기본 논리를 이해할 수 있습니다.</p>\n<p>다른 시나리오에서 억제된 후 :</p>\n<pre><code class=\"hljs language-js\">(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">_0x49e7cc, _0x35d5f6</span>) {\n  <span class=\"hljs-keyword\">const</span> _0xdfe59 = _0x3b90,\n    _0xd4b26e = <span class=\"hljs-title function_\">_0x49e7cc</span>();\n\n  <span class=\"hljs-keyword\">while</span> (!![]) {\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-keyword\">const</span> _0x20c64f = <span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-title function_\">_0xdfe59</span>(<span class=\"hljs-number\">0xf9</span>)) / <span class=\"hljs-number\">0x1</span> * (-<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-title function_\">_0xdfe59</span>(<span class=\"hljs-number\">0xfa</span>)) / <span class=\"hljs-number\">0x2</span>) + -<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-title function_\">_0xdfe59</span>(<span class=\"hljs-number\">0xf7</span>)) / <span class=\"hljs-number\">0x3</span> * (<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-title function_\">_0xdfe59</span>(<span class=\"hljs-number\">0xfc</span>)) / <span class=\"hljs-number\">0x4</span>) + <span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-title function_\">_0xdfe59</span>(<span class=\"hljs-number\">0xee</span>)) / <span class=\"hljs-number\">0x5</span> * (-<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-title function_\">_0xdfe59</span>(<span class=\"hljs-number\">0xf1</span>)) / <span class=\"hljs-number\">0x6</span>) + <span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-title function_\">_0xdfe59</span>(<span class=\"hljs-number\">0xf5</span>)) / <span class=\"hljs-number\">0x7</span> + \n        -<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-title function_\">_0xdfe59</span>(<span class=\"hljs-number\">0xf4</span>)) / <span class=\"hljs-number\">0x8</span> + -<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-title function_\">_0xdfe59</span>(<span class=\"hljs-number\">0xf2</span>)) / <span class=\"hljs-number\">0x9</span> + <span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-title function_\">_0xdfe59</span>(<span class=\"hljs-number\">0xf6</span>)) / <span class=\"hljs-number\">0xa</span> * (<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-title function_\">_0xdfe59</span>(<span class=\"hljs-number\">0xf0</span>)) / <span class=\"hljs-number\">0xb</span>);\n      \n      <span class=\"hljs-keyword\">if</span> (_0x20c64f === _0x35d5f6) <span class=\"hljs-keyword\">break</span>;\n      <span class=\"hljs-keyword\">else</span> _0xd4b26e[<span class=\"hljs-string\">'push'</span>](_0xd4b26e[<span class=\"hljs-string\">'shift'</span>]());\n    } <span class=\"hljs-keyword\">catch</span> (_0x29db07) {\n      _0xd4b26e[<span class=\"hljs-string\">'push'</span>](_0xd4b26e[<span class=\"hljs-string\">'shift'</span>]());\n    }\n  })(_0x53ef, <span class=\"hljs-number\">0xd14a3</span>);\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getUserData</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> _0x2d7b7b = _0x3b90;\n  <span class=\"hljs-keyword\">if</span> (!user) <span class=\"hljs-keyword\">return</span> {};\n  <span class=\"hljs-keyword\">let</span> _0x4c86a3 = user[<span class=\"hljs-title function_\">_0x2d7b7b</span>(<span class=\"hljs-number\">0xef</span>)][<span class=\"hljs-string\">'providerData'</span>][<span class=\"hljs-number\">0x0</span>];\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-string\">'name'</span>: _0x4c86a3[<span class=\"hljs-string\">'displayName'</span>],\n    <span class=\"hljs-string\">'avatar'</span>: _0x4c86a3[<span class=\"hljs-title function_\">_0x2d7b7b</span>(<span class=\"hljs-number\">0xfb</span>)],\n    <span class=\"hljs-string\">'email'</span>: _0x4c86a3[<span class=\"hljs-string\">'email'</span>],\n    <span class=\"hljs-string\">'provider'</span>: _0x4c86a3[<span class=\"hljs-title function_\">_0x2d7b7b</span>(<span class=\"hljs-number\">0xf8</span>)],\n    <span class=\"hljs-string\">'uid'</span>: user[<span class=\"hljs-title function_\">_0x2d7b7b</span>(<span class=\"hljs-number\">0xef</span>)][<span class=\"hljs-title function_\">_0x2d7b7b</span>(<span class=\"hljs-number\">0xf3</span>)]\n  };\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_0x3b90</span>(<span class=\"hljs-params\">_0x40fb4f, _0x21bcc3</span>) {\n  <span class=\"hljs-keyword\">const</span> _0x53ef2b = <span class=\"hljs-title function_\">_0x53ef</span>();\n  <span class=\"hljs-keyword\">return</span> _0x3b90 = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">_0x3b900f, _0x3ce21b</span>) {\n    _0x3b900f = _0x3b900f - <span class=\"hljs-number\">0xee</span>;\n    <span class=\"hljs-keyword\">let</span> _0x3732d2 = _0x53ef2b[_0x3b900f];\n    <span class=\"hljs-keyword\">return</span> _0x3732d2;\n  }, <span class=\"hljs-title function_\">_0x3b90</span>(_0x40fb4f, _0x21bcc3);\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_0x53ef</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> _0x2e2efd = [<span class=\"hljs-string\">'providerId'</span>, <span class=\"hljs-string\">'254438AtTuWZ'</span>, <span class=\"hljs-string\">'10GIuQhB'</span>, <span class=\"hljs-string\">'photoURL'</span>, <span class=\"hljs-string\">'4aVsWJI'</span>, <span class=\"hljs-string\">'20vNbtpg'</span>, <span class=\"hljs-string\">'auth'</span>, <span class=\"hljs-string\">'3729QVEYgK'</span>, <span class=\"hljs-string\">'340284BhPkpf'</span>, <span class=\"hljs-string\">'4165182zMXsCd'</span>, <span class=\"hljs-string\">'uid'</span>, <span class=\"hljs-string\">'13082696dHfPHS'</span>, <span class=\"hljs-string\">'10353784ybaJZp'</span>, <span class=\"hljs-string\">'98830ItJwbd'</span>, <span class=\"hljs-string\">'1125051BYspDY'</span>];\n\n  _0x53ef = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> _0x2e2efd;\n  };\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">_0x53ef</span>();\n}\n\n<span class=\"hljs-variable language_\">console</span>[<span class=\"hljs-string\">'log'</span>](<span class=\"hljs-title function_\">getUserData</span>());\n</code></pre>\n<p>위 코드는 이제 훨씬 복잡하고 이해하기 어려워졌는데, 이는 초기 접근 방식보다 훨씬 나은 결과입니다. 사실 더 많은 난독화 수준을 추가할 수 있으며, 이에 대해 더 이야기할 것입니다.</p>\n<p>이제 난독화를 위해 우리의 Angular 애플리케이션을 설정해 봅시다.</p>\n<h1>설치 및 설정:</h1>\n<p>우리는 javascript-obfuscator 및 wepack-obfuscator 플러그인을 사용하여 코드를 난독화할 것입니다.</p>\n<p>귀하는 Angular 어플리케이션에서 위의 패키지들을 다음 명령어를 사용하여 설치할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">npm install --save-dev javascript-obfuscator webpack-obfuscator\n</code></pre>\n<p>웹팩 설정 파일 생성/업데이트 :</p>\n<p>위의 플러그인을 설치한 웹팩 설정 파일을 생성하거나 업데이트하려면 기존 웹팩 설정 파일을 다음과 같이 업데이트하실 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">WebpackObfuscator</span> = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'webpack-obfuscator'</span>);\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n <span class=\"hljs-attr\">module</span>: {\n  ...<span class=\"hljs-comment\">//옵션</span>\n  },\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Webpack 플러그인 배열</span>\n<span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebpackObfuscator</span> ({\n       <span class=\"hljs-attr\">debugProtection</span>: <span class=\"hljs-literal\">true</span>\n    }, [<span class=\"hljs-string\">'vendor.js'</span>])\n   ]\n}\n</code></pre>\n<p>우리는 앵귤러 애플리케이션의 빌드/배포를 구성할 것이며, 앞서 작성한 위의 webpack.config를 포함하기 위해 custom-webpack 빌더를 사용하는 angular.json을 업데이트할 것입니다.</p>\n<h2>빌드 구성 업데이트:</h2>\n<p>아래 명령어를 사용하여 custom-webpack 빌더를 설치하십시오:</p>\n<ul>\n<li>아래 명령어를 사용하여 앵귤러 커스텀 빌더를 설치하십시오:</li>\n</ul>\n<pre><code class=\"hljs language-js\">npm i @angular-builders/custom-webpack\n</code></pre>\n<ul>\n<li>아래 코드를 사용하여 angular.json 빌더를 업데이트하십시오.</li>\n</ul>\n<pre><code class=\"hljs language-js\">{\n   ...\n   <span class=\"hljs-string\">\"architect\"</span>: {\n        <span class=\"hljs-string\">\"build\"</span>: {\n          <span class=\"hljs-string\">\"builder\"</span>: <span class=\"hljs-string\">\"@angular-builders/custom-webpack:browser\"</span>,\n          <span class=\"hljs-string\">\"options\"</span>: {\n            <span class=\"hljs-string\">\"customWebpackConfig\"</span>: {\n              <span class=\"hljs-string\">\"path\"</span>: <span class=\"hljs-string\">\"./extra-webpack.config.js\"</span>,\n              <span class=\"hljs-string\">\"mergeStrategies\"</span>: {\n                <span class=\"hljs-string\">\"module.rules\"</span>: <span class=\"hljs-string\">\"prepend\"</span>\n              },\n            },\n            <span class=\"hljs-string\">\"outputPath\"</span>: <span class=\"hljs-string\">\"dist\"</span>,\n            ...          \n          }\n        }\n   }\n}\n</code></pre>\n<p>이렇게 하면 우리 애플리케이션을 빌드하여 응용 프로그램의 난독화된 코드를 생성할 수 있습니다.</p>\n<p>난독화된 빌드 생성:</p>\n<p>Angular CLI 옵션을 사용하여 애플리케이션을 빌드하면 됩니다:</p>\n<pre><code class=\"hljs language-js\">ng build\n</code></pre>\n<p>빌드 후 우리 애플리케이션에서 노출된 키가 더 이상 보이지 않는 것을 확인할 수 있습니다.</p>\n<img src=\"/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_1.png\">\n<h1>JavaScript 난독화기에서 제공하는 옵션:</h1>\n<p>위의 예제에서는 debugProtection을 true로 전달했을 때, 앱 내에서 디버깅을 방지하고 디버거를 활성화한 익명 함수를 삽입하는 결과를 가져옵니다.</p>\n<p><img src=\"/assets/img/2024-05-12-SecuringyourAngularApplicationJavaScriptObfuscation_2.png\" alt=\"이미지\"></p>\n<p>주요 옵션 몇 가지:</p>\n<ul>\n<li>stringArray:\n문자열 리터럴을 제거하고 특수 배열에 배치합니다. 예를 들어, var m = \"Hello World\";의 \"Hello World\" 문자열은 var m = _0x13a678[0x2];와 같은 것으로 대체됩니다.</li>\n<li>stringArrayThreshold:\n문자열 리터럴이 stringArray에 삽입될 확률을 조정하는 데 사용할 수 있습니다(0부터 1까지). 기본값은 0.8입니다(1로 유지하면 일부 단계에서 코드가 중단됩니다).</li>\n<li>debugProtection:\n위에서 보았듯이 디버깅 보호를 활성화합니다. 활성화된 디버깅 보호 간격(밀리초 단위).</li>\n<li>transformObjectKeys:\n객체 키에 대한 변환을 적용할지 여부를 결정합니다(기본값: false).</li>\n<li>forceTransformStrings:\n문자열 리터럴 추가가 확률에 기반하기 때문에 특정 키를 강제로 문자열 배열에 추가할 수 있습니다. 정규 표현식 배열을 수락합니다(특수 문자를 포함하는 문자열을 사용할 때 이스케이프 문자를 사용하세요).</li>\n<li>stringArrayEncoding:\n문자열 리터럴을 base64 또는 rc4를 사용하여 인코딩합니다. 배열을 수락합니다. 아래 구성에서 stringArray 값은 인코딩되지 않으며 일부 값은 base64 및 rc4 인코딩으로 인코딩됩니다:</li>\n</ul>\n<pre><code class=\"hljs language-kotlin\">stringArrayEncoding: [\n    <span class=\"hljs-string\">'none'</span>,\n    <span class=\"hljs-string\">'base64'</span>,\n    <span class=\"hljs-string\">'rc4'</span>\n]\n</code></pre>\n<p>이것들은 유용할 수 있는 몇 가지 인기있는 키들입니다. 관련 정보를 더 읽어보고 여기에서 시도해 볼 수 있어요.</p>\n<p>코드 문제가 발생할 경우(정의되지 않은 속성을 가져올 때, 정의되지 않은 속성을 누를 때 또는 prototype이 정의되지 않았을 때 등 몇 가지를 들어봤어요) 아래 구성을 사용해 보세요:</p>\n<pre><code class=\"hljs language-kotlin\">new WebpackObfuscator({\n        compact: <span class=\"hljs-literal\">true</span>,\n        controlFlowFlattening: <span class=\"hljs-literal\">false</span>,\n        deadCodeInjection: <span class=\"hljs-literal\">false</span>,\n        debugProtection: <span class=\"hljs-literal\">false</span>,\n        identifierNamesGenerator: <span class=\"hljs-string\">'hexadecimal'</span>,\n        numbersToExpressions: <span class=\"hljs-literal\">false</span>,\n        renameGlobals: <span class=\"hljs-literal\">false</span>,\n        selfDefending: <span class=\"hljs-literal\">false</span>,\n        simplify: <span class=\"hljs-literal\">false</span>,\n        splitStrings: <span class=\"hljs-literal\">false</span>,\n        stringArray: <span class=\"hljs-literal\">true</span>,\n        transformObjectKeys: <span class=\"hljs-literal\">false</span>,\n        stringArrayCallsTransform: <span class=\"hljs-literal\">false</span>,\n        stringArrayEncoding: [],\n        stringArrayIndexShift: <span class=\"hljs-literal\">false</span>,\n        stringArrayRotate: <span class=\"hljs-literal\">false</span>,\n        stringArrayShuffle: <span class=\"hljs-literal\">false</span>,\n        stringArrayWrappersCount: <span class=\"hljs-number\">0</span>,\n        stringArrayWrappersChainedCalls: <span class=\"hljs-literal\">false</span>,\n        stringArrayWrappersParametersMaxCount: <span class=\"hljs-number\">2</span>,\n        stringArrayWrappersType: <span class=\"hljs-string\">'variable'</span>,\n        stringArrayThreshold: <span class=\"hljs-number\">1</span>,\n        unicodeEscapeSequence: <span class=\"hljs-literal\">false</span>,\n        renamePropertiesMode: <span class=\"hljs-string\">'safe'</span>,\n        renameProperties: <span class=\"hljs-literal\">false</span>\n    },[<span class=\"hljs-string\">'vendor.js'</span>]),\n</code></pre>\n<p>angular 프레임워크 관련 오류를 위해 vendor.js를 포함했어요 (선택 사항입니다). 몇 가지 기본 옵션이 복원되었으며 제거할 수 있어요.</p>\n<h1>결론</h1>\n<p>우리는 우리의 Angular 코드베이스를 난독화하여 더 안전한 코드로 한 걸음 더 가까워졌어요. 우리가 Angular에 구현했지만, 리액트와 같은 다른 프레임워크에도 구현할 수 있어요.</p>\n<h1>다음은 무엇인가요?</h1>\n<p>암호화: AES 및 RSA를 사용하여 네트워크 요청을 암호화하여 데이터를 기밀 유지합니다.</p>\n<p>참고 문헌:</p>\n</body>\n</html>\n"},"__N_SSG":true}