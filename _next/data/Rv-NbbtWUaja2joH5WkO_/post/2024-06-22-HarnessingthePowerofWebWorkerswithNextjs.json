{"pageProps":{"post":{"title":"Nextjs에서 Web Worker 활용하는 방법","description":"","date":"2024-06-22 14:28","slug":"2024-06-22-HarnessingthePowerofWebWorkerswithNextjs","content":"\n\n![2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png](/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png)\n\n웹 애플리케이션의 응답성을 유지하는 데 실시간 데이터를 효율적으로 제공하는 것이 중요합니다. 이 게시물은 금융에 관한 것은 아니지만, 암호화폐 가격과 같은 데이터는 급속하게 변동할 수 있기 때문에 Web Worker에 적합한 사용 사례입니다. 이 데이터를 처리하는 기존 방법은 메인 스레드를 지연시킬 수 있어 웹 앱의 반응이 둔해질 수 있습니다. 그러나 Web Worker의 능력을 활용하면 이 데이터 처리를 별도 스레드로 옮겨 UI를 빠르고 반응적으로 유지할 수 있습니다. 이 게시물에서는 Next.js 애플리케이션에서 Web Worker를 사용하여 실시간 암호화폐 데이터를 관리한 방법을 안내합니다. 아래는 UI의 스크린샷입니다.\n\n![2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_1.png](/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_1.png)\n\n# 웹 워커란 무엇인가\n\n<div class=\"content-ad\"></div>\n\n간단히 말해서, 웹 워커는 백그라운드 스레드에서 스크립트를 실행할 수 있는 방법을 제공합니다. 워커 스레드는 사용자 인터페이스를 방해하지 않고 작업을 수행할 수 있습니다. 게다가, 주요 JavaScript 스레드로 메시지를 보낼 수 있어서 애플리케이션이 반응성을 유지할 수 있습니다.\n\n# 준비 과정: Next.js와 웹 워커\n\nNext.js는 개발자가 서버 측 렌더링 및 정적 웹 애플리케이션을 만들 수 있도록 하는 React 프레임워크입니다. 저는 Next.js를 업무에서 사용하고 있고 매우 인기가 있기 때문에 Web Workers를 Next.js와 함께 사용하는 방법을 알고 싶었습니다. 특히 극복하고자 했던 어려움은 다음과 같습니다.\n\n- TypeScript 사용\n- 웹 워커 파일 경로를 모든 컴포넌트에서 사용 가능하게 하기\n- 현재 tsconfig.json 파일을 오염시키지 않거나 모든 파일을 public 디렉토리에 넣지 않기\n\n<div class=\"content-ad\"></div>\n\n# 빌드 단계\n\n실제 웹 워커 작업에 들어가기 전에 지루한 작업을 먼저 해보겠습니다. 웹 워커를 런타임에서 사용할 수 있도록 하려면 /public 디렉토리에 저장해야 합니다. public 디렉토리에 대해 간단히 설명하자면 이미지, 폰트, 스크립트, HTML 파일 같은 정적 파일을 브라우저를 통해 직접 액세스해야 하는 경우에 사용됩니다. 이 디렉토리에 위치한 모든 것은 Next.js에서 정적 리소스로 제공됩니다. 이 설정은 몇 가지 보안 고려 사항을 동반합니다. 민감한 사용자 데이터를 피하고 적절한 보안 헤더를 사용하며 이 파일에 API 키를 저장하지 마십시오.\n\n# 새로운 tsconfig.json 파일 만들기\n\ntsconfig.worker.json이라는 새 파일을 생성하여 특정 웹 워커 파일을 /public 디렉토리로 컴파일하기 위해 기존 tsconfig.json을 확장합니다. 동일한 JSON을 기본 구성에 넣으면 컴파일러 옵션 -` outDir가 모든 것을 /public 디렉토리에 넣을 것으로 생각됩니다.\n\n<div class=\"content-ad\"></div>\n\n```json\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \". /public/workers\",\n    \"module\": \"ES6\",\n    \"noEmit\": false\n  },\n  \"include\": [\"workers/**/*.ts\"]\n}\n```\n\n이제는 /workers 폴더 안의 모든 파일을 JavaScript로 컴파일하여 /public/workers 디렉토리에 넣어줍니다. 이렇게하면 컴포넌트에서 어디에서든 액세스할 수 있습니다.\n\n# Package.json 업데이트\n\npackage.json 파일에서 스크립트를 업데이트해야합니다. 이렇게하면 worker 파일이 저장될 때마다 빌드됩니다. 제가 일단 빌드를 실행할 수있는 스크립트 명령어를 추가했습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n\"build:workers\": \"tsc -p tsconfig.worker.json\", \n```\n\n이후에는 변경 사항이 발생할 때마다 worker 폴더를 감시하고 저장한 후 빌드하는 명령을 추가했습니다. 이 명령을 개발 명령과 병렬로 실행했습니다. 그러나 모든 작업을 한 번에 수행하도록 개발 명령을 업데이트할 수도 있습니다.\n\n```js\n\"watch:workers\": \"tsc -p tsconfig.worker.json --watch\",\n\"dev\": \"next dev -H 127.0.0.1 -p 3111\",\n```\n\n# 웹 워커\n\n\n<div class=\"content-ad\"></div>\n\n웹 워커는 굉장히 복잡하지 않아요. 사실, 마지막에는 메소드 4개와 속성 2개만 가지고 있어요. 이 메소드들은 워커 내부로 메시지를 보내거나 받기 위해 사용하고, 속성들은 이벤트를 듣기 위해 사용돼요.\n\n## 메소드\n\n- postMessage(): 워커의 내부 스코프로 메시지를 보냅니다. 어떤 값 또는 자바스크립트 객체든 보낼 수 있지만 함수나 오류 객체는 보낼 수 없어요.\n\n```js\nworker.postMessage(data);\n```\n\n<div class=\"content-ad\"></div>\n\n- terminate():\n    워커를 즉시 종료합니다. 이렇게하면 워커 범위 내의 모든 작업이 중지되며, 모든 네트워크 연결이 해제되며, 모든 리소스가 해제됩니다. `terminate()`을 호출한 후에는 워커를 다시 시작할 수 없습니다.\n\n```js\nworker.terminate();\n```\n\n- addEventListener():\n    `message` 및 `error`와 같은 이벤트를 처리하기 위해 워커에 직접 속성을 설정하는 대신 사용할 수 있는 대체 방법입니다.\n\n```js\nworker.addEventListener('message', handlerFunction);\n```\n\n<div class=\"content-ad\"></div>\n\n- removeEventListener():\naddEventListener()로 이전에 등록된 이벤트 리스너를 제거합니다.\n\n```js\nworker.removeEventListener('message', handlerFunction);\n```\n\n## 속성\n\n- onmessage: worker가 `postMessage()`를 사용하여 메인 스레드로부터 메시지를 수신할 때 호출되는 이벤트 핸들러입니다.\n\n<div class=\"content-ad\"></div>\n\n```js \nworker.onmessage = function(event) { \n  console.log(event.data); \n};\n```\n\n- **onerror**: 설명: 워커에서 오류가 발생했을 때 호출되는 이벤트 핸들러입니다. 이 이벤트 핸들러는 오류에 관한 정보를 포함하는 `ErrorEvent` 객체를 받을 수 있습니다.\n\n```js\nworker.onerror = function(event) { console.error(event.message); };\n```\n\n`postMessage` 메서드를 사용할 때 직접 'init' 또는 'data'와 같은 메시지 유형을 만들면 구성 및 유연성이 증가할 수 있습니다. 예를 들어 이 프로젝트에서는 페이로드를 웹 워커의 특정 알고리즘으로 연결하기 위한 메시지 유형을 나타내는 TypeScript 유형을 사용했습니다. 'type'이라는 단어를 많이 사용했는데, 예시를 보여드릴까요?\n\n<div class=\"content-ad\"></div>\n\ntypes.ts\n\n```js\nexport type WorkerMessageT<T> = {\n  type: 'init' | 'data' | 'error' | 'stop'\n  payload?: {\n    id?: string\n    data: T\n  }\n}\n\nexport type CryptoWorkConfigT = {\n  assets: string // 비트코인, 이더리움, 모네로, 라이트코인\n}\n```\n\n다른 방법으로는 addEventListener()를 활용할 수도 있습니다.\n\ncrypto.ts\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { WorkerMessageT, CryptoWorkConfigT } from '../types'\n\n// 워커의 최상위 범위에서 pricesWs를 정의합니다\nlet pricesWs: WebSocket | null = null\n\nself.onmessage = (e) => {\n  const BASE_URL = 'wss://ws.coincap.io/prices'\n  switch (e.data.type) {\n    case 'init':\n      const message: WorkerMessageT<CryptoWorkConfigT> = e.data\n\n      // 웹 소켓 연결을 초기화합니다\n      pricesWs = new WebSocket(\n        `${BASE_URL}?assets=${message.payload?.data.assets}`,\n      )\n\n      const initSubscription = () => {\n        pricesWs?.addEventListener('message', function (event) {\n          self.postMessage(JSON.parse(event.data))\n        })\n      }\n\n      initSubscription()\n\n      break\n\n    case 'stop':\n      // 열려 있는 웹 소켓을 안전하게 닫습니다\n      if (pricesWs) {\n        console.log('WebSocket 연결을 종료합니다...', pricesWs)\n        pricesWs.close()\n        pricesWs = null // 닫은 후에 참조를 지웁니다\n      }\n      break\n\n    case 'error':\n      // 오류 발생 시, 웹 소켓을 닫습니다\n      if (pricesWs) {\n        pricesWs.close()\n        pricesWs = null // 오류 발생 시 정리합니다\n      }\n      // 여기에 추가적인 오류 처리 로직을 구현할 수 있습니다\n      break\n\n    default:\n      // 명시적으로 언급되지 않은 모든 케이스 처리\n      console.error('처리되지 않은 메시지 유형:', e.data.type)\n  }\n}\n```\n\n먼저 몇 가지 타입을 가져오고, Coincap API와 통신하기 위해 사용할 웹 소켓 변수를 초기화합니다. 그런 다음 첫 번째 웹 워커 메서드 self.onmessage가 나타납니다. 메시지 유형이 즉시 유용하며 적절한 알고리즘으로 이벤트를 분기합니다. 'init' 케이스에서는 수신된 메시지 데이터를 수집하고 Coincap 웹 소켓에 구독합니다. 웹 소켓 이벤트 핸들러에서 postMessage() 메서드를 사용하여 데이터를 전파합니다. 여기까지입니다! 이제 웹 워커와 통신하는 UI로 이동해봅시다.\n\npage.ts\n\n```js\n'use client'\n\nimport { useEffect, useRef, useState } from 'react'\nimport { Button } from '@mozilla/lilypad-ui'\nimport styles from './page.module.scss'\nimport { CryptoWorkConfigT, WorkerMessageT } from 'workers/types'\nimport Card from '@Shared/Card/Card'\n\ntype CryptoDataT = {\n  bitcoin: string\n  ethereum: string\n  monero: string\n  litecoin: string\n}\n\nconst page = () => {\n  const workerRef = useRef<Worker>()\n  const initPrice = '데이터를 기다리는 중...'\n  const [status, setStatus] = useState<string>('중지됨')\n  const [prices, setPrices] = useState<CryptoDataT>({\n    bitcoin: '',\n    ethereum: '',\n    monero: '',\n    litecoin: '',\n  })\n\n  useEffect(() => {\n    workerRef.current = new Worker('/workers/crypto/crypto.js', {\n      type: 'module',\n    })\n    workerRef.current.onmessage = (event) => {\n      setPrices((prev) => {\n        const newState = { ...prev, ...event.data }\n        return newState\n      })\n    }\n    workerRef.current.onerror = (error) => {\n      console.error('워커 오류:', error)\n    }\n    return () => {\n      if (workerRef.current) {\n        workerRef.current.terminate()\n      }\n    }\n  }, [])\n\n  const startWorker = () => {\n    setStatus('실행 중')\n\n    const workerMessage: WorkerMessageT<CryptoWorkConfigT> = {\n      type: 'init',\n      payload: {\n        data: {\n          assets: 'bitcoin,ethereum,monero,litecoin',\n        },\n      },\n    }\n    if (workerRef.current) {\n      workerRef.current.postMessage(workerMessage)\n    }\n  }\n\n  const stopWorker = () => {\n    setStatus('중지됨')\n    const workerMessage: WorkerMessageT<CryptoWorkConfigT> = {\n      type: 'stop',\n    }\n    if (workerRef.current) {\n      workerRef.current.postMessage(workerMessage)\n    }\n  }\n\n  const terminateWorker = () => {\n    setStatus('종료됨')\n    const workerMessage: WorkerMessageT<CryptoWorkConfigT> = {\n      type: 'stop',\n    }\n    if (workerRef.current) {\n      workerRef.current.postMessage(workerMessage)\n      workerRef.current.terminate()\n    }\n  }\n\n  return (\n    <section className={styles.page}>\n      <Card size=\"large\" classProp={styles.card}>\n        <div className=\"mb-40 gap-12\">\n          <Button onClick={startWorker} text=\"스트림 시작\" />\n          <Button\n            onClick={stopWorker}\n            text=\"스트림 중지\"\n            category=\"primary_outline\"\n          />\n          <Button\n            icon=\"trash\"\n            onClick={terminateWorker}\n            text=\"워커 종료\"\n            category=\"primary_clear\"\n          />\n        </div>\n        <div>\n          <h2 className=\"heading-md mb-12\">데이터 스트림: {status}</h2>\n          <p className=\"mb-40 body-sm\">\n            이 페이지는 CoinCap.io에서 암호화폐 가격을 스트리밍하는 웹 워커를 사용합니다. \"스트림 시작\" 버튼을 클릭하면 워커가 시작되고 \"스트림 중지\" 버튼을 클릭하면 워커가 중지됩니다.\n          </p>\n          <div className=\"gap-12 flex-column\">\n            {Object.keys(prices).map((key) => {\n              const price = prices[key as keyof CryptoDataT]\n              return (\n                <div key={key}>\n                  <span className=\"mr-12 capitalize\">{key}:</span>\n                  <span className={`${!price && 'opacity-20'}`}>\n                    {price ? '$' + price : initPrice}\n                  </span>\n                </div>\n              )\n            })}\n          </div>\n        </div>\n      </Card>\n    </section>\n  )\n}\n\nexport default page\n```\n\n<div class=\"content-ad\"></div>\n\n우선, useEffect에서 웹 워커를 생성하고 해당 이벤트를 구독했습니다(JSON 파일 경로는 /public 디렉토리에 컴파일될 파일로 지정해야 합니다). onmessage 이벤트에서 컴포넌트 상태를 업데이트하여 가장 최신의 암호화폐 가격을 반영하도록 했습니다. JSX에서는 웹 워커를 켜는 버튼을 만들었지만, useEffect에서 페이지 로드 시 프로세스를 시작하는 방법도 있습니다.\n\n클릭 핸들러 \"startWorker\", \"stopWorker\", \"terminateWorker\"에 추가 기능이 있습니다. 이 핸들러는 필수 사항은 아니지만 기능을 조직하는 좋은 방법이라고 생각했습니다. 이들의 이름은 수행하는 작업이 명확하지만, 메시지의 \"유형\"을 잘 고려하면 웹 워커 통신을 더 예측 가능하게 만들 수 있다는 것을 다시 한 번 살펴보시면 더 나은 이해가 될 것입니다.\n\n# 결론\n\n이 예제 이외에도 더 흥미로운 용도로 웹 워커를 사용할 수 있지만, 이 소개가 개념을 파악하는 데 도움이 되었으면 좋겠습니다. 혹시 저와 같이 Next.js에서 웹 워커를 사용하는 데 어려움을 겪었다면, 이것이 적어도 올바른 방향으로 가도록 도움이 될 것입니다.","ogImage":{"url":"/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png"},"coverImage":"/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png","tag":["Tech"],"readingTime":10},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png\" alt=\"2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png\"></p>\n<p>웹 애플리케이션의 응답성을 유지하는 데 실시간 데이터를 효율적으로 제공하는 것이 중요합니다. 이 게시물은 금융에 관한 것은 아니지만, 암호화폐 가격과 같은 데이터는 급속하게 변동할 수 있기 때문에 Web Worker에 적합한 사용 사례입니다. 이 데이터를 처리하는 기존 방법은 메인 스레드를 지연시킬 수 있어 웹 앱의 반응이 둔해질 수 있습니다. 그러나 Web Worker의 능력을 활용하면 이 데이터 처리를 별도 스레드로 옮겨 UI를 빠르고 반응적으로 유지할 수 있습니다. 이 게시물에서는 Next.js 애플리케이션에서 Web Worker를 사용하여 실시간 암호화폐 데이터를 관리한 방법을 안내합니다. 아래는 UI의 스크린샷입니다.</p>\n<p><img src=\"/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_1.png\" alt=\"2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_1.png\"></p>\n<h1>웹 워커란 무엇인가</h1>\n<div class=\"content-ad\"></div>\n<p>간단히 말해서, 웹 워커는 백그라운드 스레드에서 스크립트를 실행할 수 있는 방법을 제공합니다. 워커 스레드는 사용자 인터페이스를 방해하지 않고 작업을 수행할 수 있습니다. 게다가, 주요 JavaScript 스레드로 메시지를 보낼 수 있어서 애플리케이션이 반응성을 유지할 수 있습니다.</p>\n<h1>준비 과정: Next.js와 웹 워커</h1>\n<p>Next.js는 개발자가 서버 측 렌더링 및 정적 웹 애플리케이션을 만들 수 있도록 하는 React 프레임워크입니다. 저는 Next.js를 업무에서 사용하고 있고 매우 인기가 있기 때문에 Web Workers를 Next.js와 함께 사용하는 방법을 알고 싶었습니다. 특히 극복하고자 했던 어려움은 다음과 같습니다.</p>\n<ul>\n<li>TypeScript 사용</li>\n<li>웹 워커 파일 경로를 모든 컴포넌트에서 사용 가능하게 하기</li>\n<li>현재 tsconfig.json 파일을 오염시키지 않거나 모든 파일을 public 디렉토리에 넣지 않기</li>\n</ul>\n<div class=\"content-ad\"></div>\n<h1>빌드 단계</h1>\n<p>실제 웹 워커 작업에 들어가기 전에 지루한 작업을 먼저 해보겠습니다. 웹 워커를 런타임에서 사용할 수 있도록 하려면 /public 디렉토리에 저장해야 합니다. public 디렉토리에 대해 간단히 설명하자면 이미지, 폰트, 스크립트, HTML 파일 같은 정적 파일을 브라우저를 통해 직접 액세스해야 하는 경우에 사용됩니다. 이 디렉토리에 위치한 모든 것은 Next.js에서 정적 리소스로 제공됩니다. 이 설정은 몇 가지 보안 고려 사항을 동반합니다. 민감한 사용자 데이터를 피하고 적절한 보안 헤더를 사용하며 이 파일에 API 키를 저장하지 마십시오.</p>\n<h1>새로운 tsconfig.json 파일 만들기</h1>\n<p>tsconfig.worker.json이라는 새 파일을 생성하여 특정 웹 워커 파일을 /public 디렉토리로 컴파일하기 위해 기존 tsconfig.json을 확장합니다. 동일한 JSON을 기본 구성에 넣으면 컴파일러 옵션 -` outDir가 모든 것을 /public 디렉토리에 넣을 것으로 생각됩니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"extends\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"./tsconfig.json\"</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"compilerOptions\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">\"outDir\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\". /public/workers\"</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"module\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"ES6\"</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"noEmit\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">false</span></span>\n  <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"include\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-string\">\"workers/**/*.ts\"</span><span class=\"hljs-punctuation\">]</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>이제는 /workers 폴더 안의 모든 파일을 JavaScript로 컴파일하여 /public/workers 디렉토리에 넣어줍니다. 이렇게하면 컴포넌트에서 어디에서든 액세스할 수 있습니다.</p>\n<h1>Package.json 업데이트</h1>\n<p>package.json 파일에서 스크립트를 업데이트해야합니다. 이렇게하면 worker 파일이 저장될 때마다 빌드됩니다. 제가 일단 빌드를 실행할 수있는 스크립트 명령어를 추가했습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">\"build:workers\"</span>: <span class=\"hljs-string\">\"tsc -p tsconfig.worker.json\"</span>, \n</code></pre>\n<p>이후에는 변경 사항이 발생할 때마다 worker 폴더를 감시하고 저장한 후 빌드하는 명령을 추가했습니다. 이 명령을 개발 명령과 병렬로 실행했습니다. 그러나 모든 작업을 한 번에 수행하도록 개발 명령을 업데이트할 수도 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">\"watch:workers\"</span>: <span class=\"hljs-string\">\"tsc -p tsconfig.worker.json --watch\"</span>,\n<span class=\"hljs-string\">\"dev\"</span>: <span class=\"hljs-string\">\"next dev -H 127.0.0.1 -p 3111\"</span>,\n</code></pre>\n<h1>웹 워커</h1>\n<div class=\"content-ad\"></div>\n<p>웹 워커는 굉장히 복잡하지 않아요. 사실, 마지막에는 메소드 4개와 속성 2개만 가지고 있어요. 이 메소드들은 워커 내부로 메시지를 보내거나 받기 위해 사용하고, 속성들은 이벤트를 듣기 위해 사용돼요.</p>\n<h2>메소드</h2>\n<ul>\n<li>postMessage(): 워커의 내부 스코프로 메시지를 보냅니다. 어떤 값 또는 자바스크립트 객체든 보낼 수 있지만 함수나 오류 객체는 보낼 수 없어요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">worker.<span class=\"hljs-title function_\">postMessage</span>(data);\n</code></pre>\n<div class=\"content-ad\"></div>\n<ul>\n<li>terminate():\n워커를 즉시 종료합니다. 이렇게하면 워커 범위 내의 모든 작업이 중지되며, 모든 네트워크 연결이 해제되며, 모든 리소스가 해제됩니다. <code>terminate()</code>을 호출한 후에는 워커를 다시 시작할 수 없습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">worker.<span class=\"hljs-title function_\">terminate</span>();\n</code></pre>\n<ul>\n<li>addEventListener():\n<code>message</code> 및 <code>error</code>와 같은 이벤트를 처리하기 위해 워커에 직접 속성을 설정하는 대신 사용할 수 있는 대체 방법입니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">worker.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'message'</span>, handlerFunction);\n</code></pre>\n<div class=\"content-ad\"></div>\n<ul>\n<li>removeEventListener():\naddEventListener()로 이전에 등록된 이벤트 리스너를 제거합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">worker.<span class=\"hljs-title function_\">removeEventListener</span>(<span class=\"hljs-string\">'message'</span>, handlerFunction);\n</code></pre>\n<h2>속성</h2>\n<ul>\n<li>onmessage: worker가 <code>postMessage()</code>를 사용하여 메인 스레드로부터 메시지를 수신할 때 호출되는 이벤트 핸들러입니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">worker.<span class=\"hljs-property\">onmessage</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) { \n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(event.<span class=\"hljs-property\">data</span>); \n};\n</code></pre>\n<ul>\n<li><strong>onerror</strong>: 설명: 워커에서 오류가 발생했을 때 호출되는 이벤트 핸들러입니다. 이 이벤트 핸들러는 오류에 관한 정보를 포함하는 <code>ErrorEvent</code> 객체를 받을 수 있습니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">worker.<span class=\"hljs-property\">onerror</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) { <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(event.<span class=\"hljs-property\">message</span>); };\n</code></pre>\n<p><code>postMessage</code> 메서드를 사용할 때 직접 'init' 또는 'data'와 같은 메시지 유형을 만들면 구성 및 유연성이 증가할 수 있습니다. 예를 들어 이 프로젝트에서는 페이로드를 웹 워커의 특정 알고리즘으로 연결하기 위한 메시지 유형을 나타내는 TypeScript 유형을 사용했습니다. 'type'이라는 단어를 많이 사용했는데, 예시를 보여드릴까요?</p>\n<div class=\"content-ad\"></div>\n<p>types.ts</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">WorkerMessageT</span>&#x3C;T> = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'init'</span> | <span class=\"hljs-string\">'data'</span> | <span class=\"hljs-string\">'error'</span> | <span class=\"hljs-string\">'stop'</span>\n  payload?: {\n    id?: string\n    <span class=\"hljs-attr\">data</span>: T\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> type <span class=\"hljs-title class_\">CryptoWorkConfigT</span> = {\n  <span class=\"hljs-attr\">assets</span>: string <span class=\"hljs-comment\">// 비트코인, 이더리움, 모네로, 라이트코인</span>\n}\n</code></pre>\n<p>다른 방법으로는 addEventListener()를 활용할 수도 있습니다.</p>\n<p>crypto.ts</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">WorkerMessageT</span>, <span class=\"hljs-title class_\">CryptoWorkConfigT</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../types'</span>\n\n<span class=\"hljs-comment\">// 워커의 최상위 범위에서 pricesWs를 정의합니다</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">pricesWs</span>: <span class=\"hljs-title class_\">WebSocket</span> | <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>\n\nself.<span class=\"hljs-property\">onmessage</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">BASE_URL</span> = <span class=\"hljs-string\">'wss://ws.coincap.io/prices'</span>\n  <span class=\"hljs-keyword\">switch</span> (e.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">type</span>) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'init'</span>:\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">message</span>: <span class=\"hljs-title class_\">WorkerMessageT</span>&#x3C;<span class=\"hljs-title class_\">CryptoWorkConfigT</span>> = e.<span class=\"hljs-property\">data</span>\n\n      <span class=\"hljs-comment\">// 웹 소켓 연결을 초기화합니다</span>\n      pricesWs = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>(\n        <span class=\"hljs-string\">`<span class=\"hljs-subst\">${BASE_URL}</span>?assets=<span class=\"hljs-subst\">${message.payload?.data.assets}</span>`</span>,\n      )\n\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">initSubscription</span> = (<span class=\"hljs-params\"></span>) => {\n        pricesWs?.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">'message'</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) {\n          self.<span class=\"hljs-title function_\">postMessage</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(event.<span class=\"hljs-property\">data</span>))\n        })\n      }\n\n      <span class=\"hljs-title function_\">initSubscription</span>()\n\n      <span class=\"hljs-keyword\">break</span>\n\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'stop'</span>:\n      <span class=\"hljs-comment\">// 열려 있는 웹 소켓을 안전하게 닫습니다</span>\n      <span class=\"hljs-keyword\">if</span> (pricesWs) {\n        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'WebSocket 연결을 종료합니다...'</span>, pricesWs)\n        pricesWs.<span class=\"hljs-title function_\">close</span>()\n        pricesWs = <span class=\"hljs-literal\">null</span> <span class=\"hljs-comment\">// 닫은 후에 참조를 지웁니다</span>\n      }\n      <span class=\"hljs-keyword\">break</span>\n\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'error'</span>:\n      <span class=\"hljs-comment\">// 오류 발생 시, 웹 소켓을 닫습니다</span>\n      <span class=\"hljs-keyword\">if</span> (pricesWs) {\n        pricesWs.<span class=\"hljs-title function_\">close</span>()\n        pricesWs = <span class=\"hljs-literal\">null</span> <span class=\"hljs-comment\">// 오류 발생 시 정리합니다</span>\n      }\n      <span class=\"hljs-comment\">// 여기에 추가적인 오류 처리 로직을 구현할 수 있습니다</span>\n      <span class=\"hljs-keyword\">break</span>\n\n    <span class=\"hljs-attr\">default</span>:\n      <span class=\"hljs-comment\">// 명시적으로 언급되지 않은 모든 케이스 처리</span>\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'처리되지 않은 메시지 유형:'</span>, e.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">type</span>)\n  }\n}\n</code></pre>\n<p>먼저 몇 가지 타입을 가져오고, Coincap API와 통신하기 위해 사용할 웹 소켓 변수를 초기화합니다. 그런 다음 첫 번째 웹 워커 메서드 self.onmessage가 나타납니다. 메시지 유형이 즉시 유용하며 적절한 알고리즘으로 이벤트를 분기합니다. 'init' 케이스에서는 수신된 메시지 데이터를 수집하고 Coincap 웹 소켓에 구독합니다. 웹 소켓 이벤트 핸들러에서 postMessage() 메서드를 사용하여 데이터를 전파합니다. 여기까지입니다! 이제 웹 워커와 통신하는 UI로 이동해봅시다.</p>\n<p>page.ts</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-string\">'use client'</span>\n\n<span class=\"hljs-keyword\">import</span> { useEffect, useRef, useState } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'react'</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Button</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@mozilla/lilypad-ui'</span>\n<span class=\"hljs-keyword\">import</span> styles <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./page.module.scss'</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">CryptoWorkConfigT</span>, <span class=\"hljs-title class_\">WorkerMessageT</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'workers/types'</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Card</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@Shared/Card/Card'</span>\n\ntype <span class=\"hljs-title class_\">CryptoDataT</span> = {\n  <span class=\"hljs-attr\">bitcoin</span>: string\n  <span class=\"hljs-attr\">ethereum</span>: string\n  <span class=\"hljs-attr\">monero</span>: string\n  <span class=\"hljs-attr\">litecoin</span>: string\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">page</span> = (<span class=\"hljs-params\"></span>) => {\n  <span class=\"hljs-keyword\">const</span> workerRef = useRef&#x3C;<span class=\"hljs-title class_\">Worker</span>>()\n  <span class=\"hljs-keyword\">const</span> initPrice = <span class=\"hljs-string\">'데이터를 기다리는 중...'</span>\n  <span class=\"hljs-keyword\">const</span> [status, setStatus] = useState&#x3C;string>(<span class=\"hljs-string\">'중지됨'</span>)\n  <span class=\"hljs-keyword\">const</span> [prices, setPrices] = useState&#x3C;<span class=\"hljs-title class_\">CryptoDataT</span>>({\n    <span class=\"hljs-attr\">bitcoin</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">ethereum</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">monero</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">litecoin</span>: <span class=\"hljs-string\">''</span>,\n  })\n\n  <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =></span> {\n    workerRef.<span class=\"hljs-property\">current</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Worker</span>(<span class=\"hljs-string\">'/workers/crypto/crypto.js'</span>, {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'module'</span>,\n    })\n    workerRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">onmessage</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">event</span>) =></span> {\n      <span class=\"hljs-title function_\">setPrices</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">prev</span>) =></span> {\n        <span class=\"hljs-keyword\">const</span> newState = { ...prev, ...event.<span class=\"hljs-property\">data</span> }\n        <span class=\"hljs-keyword\">return</span> newState\n      })\n    }\n    workerRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">onerror</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =></span> {\n      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">'워커 오류:'</span>, error)\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =></span> {\n      <span class=\"hljs-keyword\">if</span> (workerRef.<span class=\"hljs-property\">current</span>) {\n        workerRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">terminate</span>()\n      }\n    }\n  }, [])\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">startWorker</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-title function_\">setStatus</span>(<span class=\"hljs-string\">'실행 중'</span>)\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">workerMessage</span>: <span class=\"hljs-title class_\">WorkerMessageT</span>&#x3C;<span class=\"hljs-title class_\">CryptoWorkConfigT</span>> = {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'init'</span>,\n      <span class=\"hljs-attr\">payload</span>: {\n        <span class=\"hljs-attr\">data</span>: {\n          <span class=\"hljs-attr\">assets</span>: <span class=\"hljs-string\">'bitcoin,ethereum,monero,litecoin'</span>,\n        },\n      },\n    }\n    <span class=\"hljs-keyword\">if</span> (workerRef.<span class=\"hljs-property\">current</span>) {\n      workerRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">postMessage</span>(workerMessage)\n    }\n  }\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">stopWorker</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-title function_\">setStatus</span>(<span class=\"hljs-string\">'중지됨'</span>)\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">workerMessage</span>: <span class=\"hljs-title class_\">WorkerMessageT</span>&#x3C;<span class=\"hljs-title class_\">CryptoWorkConfigT</span>> = {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'stop'</span>,\n    }\n    <span class=\"hljs-keyword\">if</span> (workerRef.<span class=\"hljs-property\">current</span>) {\n      workerRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">postMessage</span>(workerMessage)\n    }\n  }\n\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">terminateWorker</span> = (<span class=\"hljs-params\"></span>) => {\n    <span class=\"hljs-title function_\">setStatus</span>(<span class=\"hljs-string\">'종료됨'</span>)\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-attr\">workerMessage</span>: <span class=\"hljs-title class_\">WorkerMessageT</span>&#x3C;<span class=\"hljs-title class_\">CryptoWorkConfigT</span>> = {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'stop'</span>,\n    }\n    <span class=\"hljs-keyword\">if</span> (workerRef.<span class=\"hljs-property\">current</span>) {\n      workerRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">postMessage</span>(workerMessage)\n      workerRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">terminate</span>()\n    }\n  }\n\n  <span class=\"hljs-keyword\">return</span> (\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">section</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{styles.page}</span>></span>\n      <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Card</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">\"large\"</span> <span class=\"hljs-attr\">classProp</span>=<span class=\"hljs-string\">{styles.card}</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"mb-40 gap-12\"</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{startWorker}</span> <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">\"스트림 시작\"</span> /></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Button</span>\n            <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{stopWorker}</span>\n            <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">\"스트림 중지\"</span>\n            <span class=\"hljs-attr\">category</span>=<span class=\"hljs-string\">\"primary_outline\"</span>\n          /></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Button</span>\n            <span class=\"hljs-attr\">icon</span>=<span class=\"hljs-string\">\"trash\"</span>\n            <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">{terminateWorker}</span>\n            <span class=\"hljs-attr\">text</span>=<span class=\"hljs-string\">\"워커 종료\"</span>\n            <span class=\"hljs-attr\">category</span>=<span class=\"hljs-string\">\"primary_clear\"</span>\n          /></span>\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n        <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">h2</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"heading-md mb-12\"</span>></span>데이터 스트림: {status}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">h2</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"mb-40 body-sm\"</span>></span>\n            이 페이지는 CoinCap.io에서 암호화폐 가격을 스트리밍하는 웹 워커를 사용합니다. \"스트림 시작\" 버튼을 클릭하면 워커가 시작되고 \"스트림 중지\" 버튼을 클릭하면 워커가 중지됩니다.\n          <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">p</span>></span>\n          <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"gap-12 flex-column\"</span>></span>\n            {Object.keys(prices).map((key) => {\n              const price = prices[key as keyof CryptoDataT]\n              return (\n                <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">{key}</span>></span>\n                  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">\"mr-12 capitalize\"</span>></span>{key}:<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">span</span>></span>\n                  <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{</span>`${!<span class=\"hljs-attr\">price</span> &#x26;&#x26; '<span class=\"hljs-attr\">opacity-20</span>'}`}></span>\n                    {price ? '$' + price : initPrice}\n                  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">span</span>></span>\n                <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n              )\n            })}\n          <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span>\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">Card</span>></span>\n    <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">section</span>></span></span>\n  )\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> page\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>우선, useEffect에서 웹 워커를 생성하고 해당 이벤트를 구독했습니다(JSON 파일 경로는 /public 디렉토리에 컴파일될 파일로 지정해야 합니다). onmessage 이벤트에서 컴포넌트 상태를 업데이트하여 가장 최신의 암호화폐 가격을 반영하도록 했습니다. JSX에서는 웹 워커를 켜는 버튼을 만들었지만, useEffect에서 페이지 로드 시 프로세스를 시작하는 방법도 있습니다.</p>\n<p>클릭 핸들러 \"startWorker\", \"stopWorker\", \"terminateWorker\"에 추가 기능이 있습니다. 이 핸들러는 필수 사항은 아니지만 기능을 조직하는 좋은 방법이라고 생각했습니다. 이들의 이름은 수행하는 작업이 명확하지만, 메시지의 \"유형\"을 잘 고려하면 웹 워커 통신을 더 예측 가능하게 만들 수 있다는 것을 다시 한 번 살펴보시면 더 나은 이해가 될 것입니다.</p>\n<h1>결론</h1>\n<p>이 예제 이외에도 더 흥미로운 용도로 웹 워커를 사용할 수 있지만, 이 소개가 개념을 파악하는 데 도움이 되었으면 좋겠습니다. 혹시 저와 같이 Next.js에서 웹 워커를 사용하는 데 어려움을 겪었다면, 이것이 적어도 올바른 방향으로 가도록 도움이 될 것입니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}