{"pageProps":{"post":{"title":"앵귤러 Observable의 포괄적 가이드","description":"","date":"2024-06-20 00:41","slug":"2024-06-20-AComprehensiveGuidetoAngularObservables","content":"\n\n<img src=\"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png\" />\n\n# 소개\n\nAngular에서 Observables는 반응형 프로그래밍의 필수 요소로, 데이터 스트림을 통한 변경 전파에 중점을 둔 프로그래밍 패러다임입니다. Observables는 개발자가 콜백 또는 프로미스와 같은 전통적인 기술보다 비동기 데이터와 이벤트를 보다 간단하고 효율적으로 처리할 수 있게 합니다.\n\nObservables는 실시간 데이터 업데이트, 이벤트 처리 및 더 많은 기능을 필요로 하는 복잡한 애플리케이션을 구축하는 강력한 도구입니다. 이 글에서는 Angular에서 Observables의 기본 개념, 작동 방식 및 가장 일반적인 사용 사례에 대해 알아보겠습니다. 이 글을 마치면 Observables가 어떻게 더 나은 Angular 애플리케이션을 구축하는 데 도움을 줄 수 있는지에 대해 확고한 이해를 갖게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 옵저버블이란 무엇인가요?\n\n옵저버블은 Angular에서 반응형 프로그래밍의 핵심 기능입니다. 옵저버블은 시간에 따라 관찰할 수 있는 데이터 스트림입니다. 옵저버블은 배열이나 다른 데이터 구조와 유사하지만 몇 가지 주요 차이점이 있습니다:\n\n- 옵저버블은 시간에 따라 여러 값을 반환할 수 있지만 배열은 정적이며 고정된 값 집합을 포함합니다.\n- 옵저버블은 사용자 입력, 네트워크 요청 및 타이머와 같은 비동기 데이터 소스를 다룰 수 있지만 배열과 같은 동기 데이터 구조는 그렇지 않습니다.\n- 옵저버블은 다양한 방식으로 결합, 변환 및 조합되어 더 복잡한 데이터 스트림을 생성할 수 있습니다.\n\n옵저버블은 Angular 프레임워크의 중심 요소이며 이벤트 처리, 데이터 바인딩 및 비동기 프로그래밍에 널리 사용됩니다. 다음 섹션에서 Angular에서 옵저버블을 어떻게 생성하는지 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# Observable Creation\n\n앵귤러에서 Observable을 생성하는 여러 가지 방법이 있습니다. 사용 사례와 작업 중인 데이터 소스에 따라 다릅니다. 여기 몇 가지 일반적인 기술이 있습니다:\n\n- 처음부터 Observable 생성: Observable 생성자를 사용하여 처음부터 Observable을 만들 수 있습니다. 이를 사용하면 사용자 지정 데이터 스트림을 정의하고 next() 메서드를 사용하여 수동으로 값을 전달할 수 있습니다. 다음은 예시입니다:\n\n```js\nconst myObservable = new Observable(observer => {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n});\n```\n\n<div class=\"content-ad\"></div>\n\n- RxJS 연산자 사용하기: RxJS는 Angular에서 Observables와 함께 작업하는 데 널리 사용되는 라이브러리로, Observables을 생성, 변환 및 결합하는 다양한 연산자를 제공합니다. 예를 들어, of() 연산자를 사용하여 다음과 같이 일정한 값 집합을 방출하는 Observable을 생성할 수 있습니다:\n\n```js\nimport { of } from 'rxjs';\n\nconst myObservable = of(1, 2, 3);\n```\n\n- 이벤트에서 Observables 생성하기: DOM 이벤트나 다른 이벤트 소스로부터 Observable을 만들 수 있습니다. 이를 위해 fromEvent() 연산자를 사용할 수 있습니다. 이를 사용하면 사용자 입력이나 다른 이벤트를 반응적이고 효율적으로 처리할 수 있습니다. 다음은 예제입니다:\n\n```js\nimport { fromEvent } from 'rxjs';\n\nconst button = document.getElementById('myButton');\nconst clickObservable = fromEvent(button, 'click');\n```\n\n<div class=\"content-ad\"></div>\n\nAngular에서 Observable을 만드는 많은 다른 기술들 중에는 promises, timers, 그리고 HTTP 요청과 함께 작업하는 방법이 포함됩니다. 다음 섹션에서는 operators를 사용하여 Observables를 다루는 방법을 살펴볼 것입니다.\n\n# Observables와 Operators\n\nOperators는 Angular에서 Observables를 다루는 핵심 기능입니다. Operators는 Observables를 다양한 방법으로 변환하거나 조작할 수 있게 해주는 함수들입니다. Angular에서 가장 일반적으로 사용되는 operators 중 일부는 다음과 같습니다:\n\n- map(): map() operator는 Observable이 방출하는 각 값에 함수를 적용하여 변환합니다. 예를 들어, map()을 사용하여 숫자 스트림을 이들의 제곱 스트림으로 변환할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst numbers = of(1, 2, 3);\nconst squared = numbers.pipe(map(x => x * x));\n\nsquared.subscribe(x => console.log(x)); // 출력: 1, 4, 9\n```\n\n- filter(): filter() 연산자는 Observable이 지정된 조건을 충족하지 않는 값을 방출하지 않도록 필터링합니다. 예를 들어, filter()를 사용하여 스트림에서 짝수만 방출할 수 있습니다. 아래와 같이:\n\n```js\nimport { of } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nconst numbers = of(1, 2, 3, 4, 5);\nconst evenNumbers = numbers.pipe(filter(x => x % 2 === 0));\n\nevenNumbers.subscribe(x => console.log(x)); // 출력: 2, 4\n```\n\n- merge(): merge() 연산자는 여러 Observable을 하나의 값 스트림으로 결합합니다. 예를 들어, 두 개의 숫자 스트림을 단일 스트림으로 결합할 때 merge()를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { of, merge } from 'rxjs';\n\nconst numbers1 = of(1, 2, 3);\nconst numbers2 = of(4, 5, 6);\nconst merged = merge(numbers1, numbers2);\n\nmerged.subscribe(x => console.log(x)); // Output: 1, 2, 3, 4, 5, 6\n```\n\nAngular에는 tap(), switchMap(), 그리고 catchError()와 같은 다양한 연산자가 있습니다. 이러한 연산자들은 Angular 애플리케이션에서 더 강력하고 효율적인 데이터 스트림을 생성하는 데 도움이 될 수 있습니다.\n\n# Observables 구독하기\n\nObservable이 방출하는 데이터를 사용하려면 해당 Observable을 구독해야 합니다. Observable을 구독하는 것은 이벤트 리스너를 등록하는 것과 유사하며, Observable이 방출하는 값을 받아 처리할 수 있게 해줍니다. 다음은 Observable을 구독하는 예제입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { of } from 'rxjs';\n\nconst numbers = of(1, 2, 3);\nnumbers.subscribe(\n  value => console.log(value),\n  error => console.error(error),\n  () => console.log('Completed')\n);\n```\n\n이 예제에서는 of() 연산자를 사용하여 Observable을 만들어 정해진 값 집합을 방출합니다. 그런 다음 Observable을 구독하고 세 가지 콜백 함수를 인수로 제공합니다:\n\n- 첫 번째 함수는 Observable에서 방출된 각 값에 대해 처리하고 콘솔에 기록합니다.\n- 두 번째 함수는 Observable 스트림 중 발생한 오류를 처리하고 콘솔에 기록합니다.\n- 세 번째 함수는 Observable이 완료될 때 호출되어 콘솔에 메시지를 기록합니다.\n\n이 코드를 실행하면 콘솔에 1, 2, 3 값이 기록된 후 \"Completed\" 메시지가 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\nObservables는 게으르다는 것이 중요합니다. 이는 구독하지 않는 한 값을 방출하지 않는다는 뜻입니다. Angular 애플리케이션에서 데이터를 검색하고 처리하는 방법과 시기를 제어할 수 있게 해줍니다. 그러나 Observables를 사용한 작업이 끝난 후에는 구독을 해제하여 메모리 누수와 다른 문제를 방지하는 것도 중요합니다.\n\n# Angular 서비스에서 Observables 사용하기\n\nAngular에서 Observables를 사용하는 가장 일반적인 사례 중 하나는 서비스에서 사용됩니다. 여기서 Observables를 사용하여 API, 데이터베이스 또는 기타 소스에서 데이터를 가져오고 조작할 수 있습니다. 다음은 가짜 API에서 데이터를 가져오기 위해 Observables를 사용하는 간단한 서비스 예제입니다:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n  private apiUrl = '<https://jsonplaceholder.typicode.com/posts>';\n  constructor(private http: HttpClient) {}\n  getPosts(): Observable<any[]> {\n    return this.http.get<any[]>(this.apiUrl);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 Angular의 내장 HttpClient를 사용하여 URL이 https://jsonplaceholder.typicode.com/posts인 가짜 API에 GET 요청을 하는 DataService라는 서비스를 만듭니다. 우리는 any[] 유형의 Observable을 반환하는 getPosts() 메서드를 정의합니다. \n\n컴포넌트에서 이 서비스를 사용하려면 생성자에 주입하고 getPosts() 메서드를 호출하면 됩니다:\n\n```js\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-root',\n  template: `\n    <h1>Posts</h1>\n    <ul>\n      <li *ngFor=\"let post of posts\">{{ post.title }}</li>\n    </ul>\n  `\n})\nexport class AppComponent {\n  posts: any[];\n  constructor(private dataService: DataService) {}\n  ngOnInit() {\n    this.dataService.getPosts().subscribe(\n      data => this.posts = data,\n      error => console.error(error),\n      () => console.log('Posts loaded')\n    );\n  }\n}\n```\n\n이 예제에서는 AppComponent라는 컴포넌트를 만들어 DataService를 사용하여 가짜 API에서 게시물 목록을 가져옵니다. ngOnInit() 메서드를 정의하여 getPosts() Observable을 구독하고 전달된 값들을 처리합니다. Observable이 완료되면 컴포넌트의 posts 속성을 검색된 데이터로 설정합니다.\n\n<div class=\"content-ad\"></div>\n\n이 방법으로 Obserbables와 서비스를 사용하면 Angular 애플리케이션에서 강력하고 유연한 데이터 파이프라인을 만들 수 있어요.\n\n# Observables 조합하기\n\nObservables의 가장 강력한 기능 중 하나는 다양한 방법으로 조합하고 조작할 수 있는 기능입니다. 이를 통해 다양한 유즈 케이스를 처리하는 복잡한 데이터 파이프라인을 만들 수 있어요. Angular에서 Observables를 조합하는 방법의 예시 몇 가지는 다음과 같아요:\n\n- Merge: merge() 연산자를 사용하면 여러 Observables을 단일 스트림으로 결합할 수 있어요. 여기에 예시가 있어요:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nimport { interval, merge } from 'rxjs';\r\n\r\nconst source1 = interval(1000);\r\nconst source2 = interval(2000);\r\nconst merged = merge(source1, source2);\r\nmerged.subscribe(\r\n  value => console.log(value)\r\n);\r\n```\r\n\r\n이 예시에서는 interval() 연산자를 사용하여 1초마다 값과 2초마다 값이 발행되는 두 개의 Observable을 생성합니다. 그런 다음 merge() 연산자를 사용하여 이 두 개의 Observable을 하나의 스트림으로 병합합니다. 마지막으로 병합된 Observable을 구독하고 각 발행된 값마다 콘솔에 기록합니다.\r\n\r\n- CombineLatest: combineLatest() 연산자를 사용하면 여러 Observable이 발행한 최신 값들을 하나의 스트림으로 결합할 수 있습니다. 다음은 예시입니다:\r\n\r\n```js\r\nimport { interval, combineLatest } from 'rxjs';\r\n\r\nconst source1 = interval(1000);\r\nconst source2 = interval(2000);\r\nconst combined = combineLatest(source1, source2);\r\ncombined.subscribe(\r\n  value => console.log(value)\r\n);\r\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 interval() 연산자를 사용하여 각각 1초마다 값과 2초마다 값이 방출되는 두 Observables을 만듭니다. 그런 다음 combineLatest() 연산자를 사용하여 두 Observables에서 최신 값들을 결합하여 단일 스트림으로 만듭니다. 마지막으로 결합된 Observable에 구독하여 각 방출된 값을 콘솔에 기록합니다.\n\n- Zip: zip() 연산자를 사용하면 여러 Observables에서 방출된 값들을 배열로 결합할 수 있습니다. 다음은 예시입니다:\n\n```js\nimport { of, zip } from 'rxjs';\n\nconst source1 = of(1, 2, 3);\nconst source2 = of('a', 'b', 'c');\nconst zipped = zip(source1, source2);\nzipped.subscribe(\n  value => console.log(value)\n);\n```\n\n이 예제에서는 of() 연산자를 사용하여 일정한 값 집합을 방출하는 두 Observables을 만듭니다. 그런 다음 zip() 연산자를 사용하여 두 Observables에서 방출한 값을 배열로 결합합니다. 마지막으로 zipped Observable을 구독하여 각 방출된 값을 콘솔에 기록합니다.\n\n<div class=\"content-ad\"></div>\n\n이 방식으로 옵저버블을 결합하고 조작함으로써, Angular 애플리케이션에서 다양한 유즈 케이스를 처리할 수 있는 복잡한 데이터 파이프라인을 만들 수 있습니다.\n\n# 데이터를 변형하고 필터링하기 위해 오퍼레이터 사용하기\n\n오퍼레이터는 옵저버블이 방출한 데이터를 변형하거나 필터링하거나 기타 방식으로 조작할 수 있는 함수들입니다. Angular 옵저버블과 함께 사용할 수 있는 많은 오퍼레이터가 RxJS 라이브러리에 제공되며, 여기에 몇 가지 예시가 있습니다:\n\n- Map: map() 오퍼레이터를 사용하면 옵저버블에서 방출된 각 값을 새 값으로 변환할 수 있습니다. 다음은 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\nconst mapped = source.pipe(map(value => value * 2));\nmapped.subscribe(\n  value => console.log(value)\n);\n```\n\n이 예제에서는 of() 연산자를 사용하여 값을 고정된 세트로 방출하는 Observable을 생성합니다. 그런 다음 map() 연산자를 사용하여 각 방출된 값에 2를 곱해 변환합니다. 마지막으로 매핑된 Observable에 구독하고 각 방출된 값을 콘솔에 로깅합니다.\n\n- Filter: filter() 연산자를 사용하면 주어진 조건에 따라 Observable에서 방출된 값을 필터링할 수 있습니다. 다음은 예시입니다:\n\n```js\nimport { of } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\nconst filtered = source.pipe(filter(value => value % 2 === 0));\nfiltered.subscribe(\n  value => console.log(value)\n);\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 of() 연산자를 사용하여 Observable을 만듭니다. 이 연산자는 고정된 값 집합을 방출합니다. 그런 다음 filter() 연산자를 사용하여 짝수인 값만 방출하도록합니다. 마지막으로 필터링된 Observable을 구독하고 콘솔에 각 방출된 값을 기록합니다.\n\n- Reduce: reduce() 연산자를 사용하면 Observable이 방출하는 값들을 누적하고 단일 값으로 반환할 수 있습니다. 다음은 예제입니다:\n\n```js\nimport { of } from 'rxjs';\nimport { reduce } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\nconst reduced = source.pipe(reduce((acc, value) => acc + value));\nreduced.subscribe(\n  value => console.log(value)\n);\n```\n\n이 예시에서는 of() 연산자를 사용하여 고정된 값 집합을 방출하는 Observable을 만듭니다. 그런 다음 reduce() 연산자를 사용하여 Observable이 방출하는 값들을 누적하고 그 합계를 반환합니다. 마지막으로 누적된 Observable을 구독하고 콘솔에 최종 누적 값의 로그를 남깁니다.\n\n<div class=\"content-ad\"></div>\n\n연산자인 map(), filter(), reduce()와 같은 것을 사용하여 Observable이 방출하는 데이터를 변환, 필터링하고 조작하여 Angular 애플리케이션에서 특정한 사용 사례에 맞게 맞출 수 있습니다.\n\n# Subjects를 사용하여 값을 방출하기\n\nObservable 외에도 RxJS 라이브러리는 여러 구독자에게 값을 방출할 수 있는 Subject 클래스를 제공합니다. Subject는 Observable과 Observer 둘 다이므로 값을 방출하고 다른 Observables에 구독할 수 있습니다.\n\n다음은 Angular에서 Subject를 생성하는 예제입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { Subject } from 'rxjs';\n\nexport class MyComponent {\n  mySubject = new Subject<string>();\n  emitValue(value: string) {\n    this.mySubject.next(value);\n  }\n}\n```\n\n이 예시에서는 문자열 유형의 Subject를 생성하고 MyComponent 클래스의 속성으로 저장합니다. 그런 다음 emitValue() 메서드를 정의하고 해당 값을 mySubject 객체의 next() 메서드를 호출하여 구독자에게 해당 값을 방출합니다.\n\nSubject를 다른 Observable처럼 구독할 수 있습니다:\n\n```js\nmyComponent.mySubject.subscribe(\n  value => console.log(value)\n)\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서는 myComponent 객체의 mySubject Subject에 구독(subscribe)하여 발생한 모든 값들을 콘솔에 기록합니다.\n\n한 가지 주의할 점은 Subject를 구독할 때 Subject가 생성된 이후에 발생한 모든 값들을 받게 되는 것입니다. 구독 이후에 발생한 값들만 받고 싶다면 BehaviorSubject를 사용할 수 있습니다:\n\n```js\nimport { BehaviorSubject } from 'rxjs';\n\nexport class MyComponent {\n  mySubject = new BehaviorSubject<string>('initial value');\n  emitValue(value: string) {\n    this.mySubject.next(value);\n  }\n}\n```\n\n이 예시에서는 string 타입의 BehaviorSubject를 생성하고 초기값을 `initial value`로 설정합니다. BehaviorSubject를 구독하면 초기값을 먼저 받은 뒤에 구독 이후에 발생한 모든 값들을 받게 됩니다.\n\n<div class=\"content-ad\"></div>\n\nSubject 및 BehaviorSubject을 사용하면 Angular 애플리케이션에서 값들을 발행하고 구독하는 강력한 방법이 될 수 있습니다. 이를 통해 컴포넌트와 서비스 간에 데이터를 쉽게 공유할 수 있으며 복잡한 데이터 흐름 시나리오를 간단화할 수 있습니다.\n\n# 결론\n\nAngular Observables은 Angular 애플리케이션의 비동기 데이터 흐름을 관리하는 강력한 도구입니다. RxJS 라이브러리의 도움으로 사용자 입력부터 HTTP 요청까지 모두 처리할 수 있는 Observables을 만들고 조작할 수 있습니다.\n\n이 글에서는 Observables의 기본을 다룰 때, 생성하고 구독하는 방법 및 연산자를 사용하여 발행된 값들을 변환하고 필터링하는 방법을 다뤘습니다. 또한 Subject을 사용하여 여러 구독자에게 값을 발행하는 고급 주제도 살펴보았습니다.\n\n<div class=\"content-ad\"></div>\n\n앵귤러 옵저버블을 효과적으로 활용하는 방법을 이해하면, 더 반응형이고 빠른 응용 프로그램을 만들어 사용자 경험을 향상시킬 수 있습니다. 간단한 양식 데이터든 복잡한 데이터 스트림이든 옵저버블을 사용하면 쉽게 관리할 수 있습니다.\n\n다음에 앵귤러 응용 프로그램을 작성할 때는 데이터 흐름 요구 사항을 처리하기 위해 옵저버블을 사용해보세요. 강력한 기능과 다양한 기능 세트로, 보다 견고하고 유연하며 확장 가능한 응용 프로그램을 만들 수 있을 것입니다.","ogImage":{"url":"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png"},"coverImage":"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png","tag":["Tech"],"readingTime":12},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png\">\n<h1>소개</h1>\n<p>Angular에서 Observables는 반응형 프로그래밍의 필수 요소로, 데이터 스트림을 통한 변경 전파에 중점을 둔 프로그래밍 패러다임입니다. Observables는 개발자가 콜백 또는 프로미스와 같은 전통적인 기술보다 비동기 데이터와 이벤트를 보다 간단하고 효율적으로 처리할 수 있게 합니다.</p>\n<p>Observables는 실시간 데이터 업데이트, 이벤트 처리 및 더 많은 기능을 필요로 하는 복잡한 애플리케이션을 구축하는 강력한 도구입니다. 이 글에서는 Angular에서 Observables의 기본 개념, 작동 방식 및 가장 일반적인 사용 사례에 대해 알아보겠습니다. 이 글을 마치면 Observables가 어떻게 더 나은 Angular 애플리케이션을 구축하는 데 도움을 줄 수 있는지에 대해 확고한 이해를 갖게 될 것입니다.</p>\n<div class=\"content-ad\"></div>\n<h1>옵저버블이란 무엇인가요?</h1>\n<p>옵저버블은 Angular에서 반응형 프로그래밍의 핵심 기능입니다. 옵저버블은 시간에 따라 관찰할 수 있는 데이터 스트림입니다. 옵저버블은 배열이나 다른 데이터 구조와 유사하지만 몇 가지 주요 차이점이 있습니다:</p>\n<ul>\n<li>옵저버블은 시간에 따라 여러 값을 반환할 수 있지만 배열은 정적이며 고정된 값 집합을 포함합니다.</li>\n<li>옵저버블은 사용자 입력, 네트워크 요청 및 타이머와 같은 비동기 데이터 소스를 다룰 수 있지만 배열과 같은 동기 데이터 구조는 그렇지 않습니다.</li>\n<li>옵저버블은 다양한 방식으로 결합, 변환 및 조합되어 더 복잡한 데이터 스트림을 생성할 수 있습니다.</li>\n</ul>\n<p>옵저버블은 Angular 프레임워크의 중심 요소이며 이벤트 처리, 데이터 바인딩 및 비동기 프로그래밍에 널리 사용됩니다. 다음 섹션에서 Angular에서 옵저버블을 어떻게 생성하는지 살펴보겠습니다.</p>\n<div class=\"content-ad\"></div>\n<h1>Observable Creation</h1>\n<p>앵귤러에서 Observable을 생성하는 여러 가지 방법이 있습니다. 사용 사례와 작업 중인 데이터 소스에 따라 다릅니다. 여기 몇 가지 일반적인 기술이 있습니다:</p>\n<ul>\n<li>처음부터 Observable 생성: Observable 생성자를 사용하여 처음부터 Observable을 만들 수 있습니다. 이를 사용하면 사용자 지정 데이터 스트림을 정의하고 next() 메서드를 사용하여 수동으로 값을 전달할 수 있습니다. 다음은 예시입니다:</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myObservable = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Observable</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">observer</span> =></span> {\n  observer.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-number\">1</span>);\n  observer.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-number\">2</span>);\n  observer.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-number\">3</span>);\n});\n</code></pre>\n<div class=\"content-ad\"></div>\n<ul>\n<li>RxJS 연산자 사용하기: RxJS는 Angular에서 Observables와 함께 작업하는 데 널리 사용되는 라이브러리로, Observables을 생성, 변환 및 결합하는 다양한 연산자를 제공합니다. 예를 들어, of() 연산자를 사용하여 다음과 같이 일정한 값 집합을 방출하는 Observable을 생성할 수 있습니다:</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">of</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n<span class=\"hljs-keyword\">const</span> myObservable = <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n</code></pre>\n<ul>\n<li>이벤트에서 Observables 생성하기: DOM 이벤트나 다른 이벤트 소스로부터 Observable을 만들 수 있습니다. 이를 위해 fromEvent() 연산자를 사용할 수 있습니다. 이를 사용하면 사용자 입력이나 다른 이벤트를 반응적이고 효율적으로 처리할 수 있습니다. 다음은 예제입니다:</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { fromEvent } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n<span class=\"hljs-keyword\">const</span> button = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'myButton'</span>);\n<span class=\"hljs-keyword\">const</span> clickObservable = <span class=\"hljs-title function_\">fromEvent</span>(button, <span class=\"hljs-string\">'click'</span>);\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>Angular에서 Observable을 만드는 많은 다른 기술들 중에는 promises, timers, 그리고 HTTP 요청과 함께 작업하는 방법이 포함됩니다. 다음 섹션에서는 operators를 사용하여 Observables를 다루는 방법을 살펴볼 것입니다.</p>\n<h1>Observables와 Operators</h1>\n<p>Operators는 Angular에서 Observables를 다루는 핵심 기능입니다. Operators는 Observables를 다양한 방법으로 변환하거나 조작할 수 있게 해주는 함수들입니다. Angular에서 가장 일반적으로 사용되는 operators 중 일부는 다음과 같습니다:</p>\n<ul>\n<li>map(): map() operator는 Observable이 방출하는 각 값에 함수를 적용하여 변환합니다. 예를 들어, map()을 사용하여 숫자 스트림을 이들의 제곱 스트림으로 변환할 수 있습니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">of</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">import</span> { map } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs/operators'</span>;\n\n<span class=\"hljs-keyword\">const</span> numbers = <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n<span class=\"hljs-keyword\">const</span> squared = numbers.<span class=\"hljs-title function_\">pipe</span>(<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x * x));\n\nsquared.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x)); <span class=\"hljs-comment\">// 출력: 1, 4, 9</span>\n</code></pre>\n<ul>\n<li>filter(): filter() 연산자는 Observable이 지정된 조건을 충족하지 않는 값을 방출하지 않도록 필터링합니다. 예를 들어, filter()를 사용하여 스트림에서 짝수만 방출할 수 있습니다. 아래와 같이:</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">of</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">import</span> { filter } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs/operators'</span>;\n\n<span class=\"hljs-keyword\">const</span> numbers = <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>);\n<span class=\"hljs-keyword\">const</span> evenNumbers = numbers.<span class=\"hljs-title function_\">pipe</span>(<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>));\n\nevenNumbers.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x)); <span class=\"hljs-comment\">// 출력: 2, 4</span>\n</code></pre>\n<ul>\n<li>merge(): merge() 연산자는 여러 Observable을 하나의 값 스트림으로 결합합니다. 예를 들어, 두 개의 숫자 스트림을 단일 스트림으로 결합할 때 merge()를 사용할 수 있습니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">of</span>, merge } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n<span class=\"hljs-keyword\">const</span> numbers1 = <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n<span class=\"hljs-keyword\">const</span> numbers2 = <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>);\n<span class=\"hljs-keyword\">const</span> merged = <span class=\"hljs-title function_\">merge</span>(numbers1, numbers2);\n\nmerged.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x)); <span class=\"hljs-comment\">// Output: 1, 2, 3, 4, 5, 6</span>\n</code></pre>\n<p>Angular에는 tap(), switchMap(), 그리고 catchError()와 같은 다양한 연산자가 있습니다. 이러한 연산자들은 Angular 애플리케이션에서 더 강력하고 효율적인 데이터 스트림을 생성하는 데 도움이 될 수 있습니다.</p>\n<h1>Observables 구독하기</h1>\n<p>Observable이 방출하는 데이터를 사용하려면 해당 Observable을 구독해야 합니다. Observable을 구독하는 것은 이벤트 리스너를 등록하는 것과 유사하며, Observable이 방출하는 값을 받아 처리할 수 있게 해줍니다. 다음은 Observable을 구독하는 예제입니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">of</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n<span class=\"hljs-keyword\">const</span> numbers = <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\nnumbers.<span class=\"hljs-title function_\">subscribe</span>(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value),\n  <span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(error),\n  <span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Completed'</span>)\n);\n</code></pre>\n<p>이 예제에서는 of() 연산자를 사용하여 Observable을 만들어 정해진 값 집합을 방출합니다. 그런 다음 Observable을 구독하고 세 가지 콜백 함수를 인수로 제공합니다:</p>\n<ul>\n<li>첫 번째 함수는 Observable에서 방출된 각 값에 대해 처리하고 콘솔에 기록합니다.</li>\n<li>두 번째 함수는 Observable 스트림 중 발생한 오류를 처리하고 콘솔에 기록합니다.</li>\n<li>세 번째 함수는 Observable이 완료될 때 호출되어 콘솔에 메시지를 기록합니다.</li>\n</ul>\n<p>이 코드를 실행하면 콘솔에 1, 2, 3 값이 기록된 후 \"Completed\" 메시지가 표시됩니다.</p>\n<div class=\"content-ad\"></div>\n<p>Observables는 게으르다는 것이 중요합니다. 이는 구독하지 않는 한 값을 방출하지 않는다는 뜻입니다. Angular 애플리케이션에서 데이터를 검색하고 처리하는 방법과 시기를 제어할 수 있게 해줍니다. 그러나 Observables를 사용한 작업이 끝난 후에는 구독을 해제하여 메모리 누수와 다른 문제를 방지하는 것도 중요합니다.</p>\n<h1>Angular 서비스에서 Observables 사용하기</h1>\n<p>Angular에서 Observables를 사용하는 가장 일반적인 사례 중 하나는 서비스에서 사용됩니다. 여기서 Observables를 사용하여 API, 데이터베이스 또는 기타 소스에서 데이터를 가져오고 조작할 수 있습니다. 다음은 가짜 API에서 데이터를 가져오기 위해 Observables를 사용하는 간단한 서비스 예제입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">HttpClient</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/common/http'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Observable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n@<span class=\"hljs-title class_\">Injectable</span>({\n  <span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">'root'</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DataService</span> {\n  private apiUrl = <span class=\"hljs-string\">'&#x3C;https://jsonplaceholder.typicode.com/posts>'</span>;\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">private http: HttpClient</span>) {}\n  <span class=\"hljs-title function_\">getPosts</span>(): <span class=\"hljs-title class_\">Observable</span>&#x3C;any[]> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">get</span>&#x3C;any[]>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">apiUrl</span>);\n  }\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이 예제에서는 Angular의 내장 HttpClient를 사용하여 URL이 <a href=\"https://jsonplaceholder.typicode.com/posts%EC%9D%B8\" rel=\"nofollow\" target=\"_blank\">https://jsonplaceholder.typicode.com/posts인</a> 가짜 API에 GET 요청을 하는 DataService라는 서비스를 만듭니다. 우리는 any[] 유형의 Observable을 반환하는 getPosts() 메서드를 정의합니다.</p>\n<p>컴포넌트에서 이 서비스를 사용하려면 생성자에 주입하고 getPosts() 메서드를 호출하면 됩니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Component</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">DataService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./data.service'</span>;\n\n@<span class=\"hljs-title class_\">Component</span>({\n  <span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">'app-root'</span>,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &#x3C;h1>Posts&#x3C;/h1>\n    &#x3C;ul>\n      &#x3C;li *ngFor=\"let post of posts\">{{ post.title }}&#x3C;/li>\n    &#x3C;/ul>\n  `</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppComponent</span> {\n  <span class=\"hljs-attr\">posts</span>: any[];\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">private dataService: DataService</span>) {}\n  <span class=\"hljs-title function_\">ngOnInit</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">dataService</span>.<span class=\"hljs-title function_\">getPosts</span>().<span class=\"hljs-title function_\">subscribe</span>(\n      <span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =></span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">posts</span> = data,\n      <span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(error),\n      <span class=\"hljs-function\">() =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'Posts loaded'</span>)\n    );\n  }\n}\n</code></pre>\n<p>이 예제에서는 AppComponent라는 컴포넌트를 만들어 DataService를 사용하여 가짜 API에서 게시물 목록을 가져옵니다. ngOnInit() 메서드를 정의하여 getPosts() Observable을 구독하고 전달된 값들을 처리합니다. Observable이 완료되면 컴포넌트의 posts 속성을 검색된 데이터로 설정합니다.</p>\n<div class=\"content-ad\"></div>\n<p>이 방법으로 Obserbables와 서비스를 사용하면 Angular 애플리케이션에서 강력하고 유연한 데이터 파이프라인을 만들 수 있어요.</p>\n<h1>Observables 조합하기</h1>\n<p>Observables의 가장 강력한 기능 중 하나는 다양한 방법으로 조합하고 조작할 수 있는 기능입니다. 이를 통해 다양한 유즈 케이스를 처리하는 복잡한 데이터 파이프라인을 만들 수 있어요. Angular에서 Observables를 조합하는 방법의 예시 몇 가지는 다음과 같아요:</p>\n<ul>\n<li>Merge: merge() 연산자를 사용하면 여러 Observables을 단일 스트림으로 결합할 수 있어요. 여기에 예시가 있어요:</li>\n</ul>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { interval, merge } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\r\n\r\n<span class=\"hljs-keyword\">const</span> source1 = <span class=\"hljs-title function_\">interval</span>(<span class=\"hljs-number\">1000</span>);\r\n<span class=\"hljs-keyword\">const</span> source2 = <span class=\"hljs-title function_\">interval</span>(<span class=\"hljs-number\">2000</span>);\r\n<span class=\"hljs-keyword\">const</span> merged = <span class=\"hljs-title function_\">merge</span>(source1, source2);\r\nmerged.<span class=\"hljs-title function_\">subscribe</span>(\r\n  <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value)\r\n);\n</code></pre>\n<p>이 예시에서는 interval() 연산자를 사용하여 1초마다 값과 2초마다 값이 발행되는 두 개의 Observable을 생성합니다. 그런 다음 merge() 연산자를 사용하여 이 두 개의 Observable을 하나의 스트림으로 병합합니다. 마지막으로 병합된 Observable을 구독하고 각 발행된 값마다 콘솔에 기록합니다.</p>\n<ul>\n<li>CombineLatest: combineLatest() 연산자를 사용하면 여러 Observable이 발행한 최신 값들을 하나의 스트림으로 결합할 수 있습니다. 다음은 예시입니다:</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { interval, combineLatest } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\r\n\r\n<span class=\"hljs-keyword\">const</span> source1 = <span class=\"hljs-title function_\">interval</span>(<span class=\"hljs-number\">1000</span>);\r\n<span class=\"hljs-keyword\">const</span> source2 = <span class=\"hljs-title function_\">interval</span>(<span class=\"hljs-number\">2000</span>);\r\n<span class=\"hljs-keyword\">const</span> combined = <span class=\"hljs-title function_\">combineLatest</span>(source1, source2);\r\ncombined.<span class=\"hljs-title function_\">subscribe</span>(\r\n  <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value)\r\n);\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이 예제에서는 interval() 연산자를 사용하여 각각 1초마다 값과 2초마다 값이 방출되는 두 Observables을 만듭니다. 그런 다음 combineLatest() 연산자를 사용하여 두 Observables에서 최신 값들을 결합하여 단일 스트림으로 만듭니다. 마지막으로 결합된 Observable에 구독하여 각 방출된 값을 콘솔에 기록합니다.</p>\n<ul>\n<li>Zip: zip() 연산자를 사용하면 여러 Observables에서 방출된 값들을 배열로 결합할 수 있습니다. 다음은 예시입니다:</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">of</span>, zip } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n<span class=\"hljs-keyword\">const</span> source1 = <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n<span class=\"hljs-keyword\">const</span> source2 = <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'c'</span>);\n<span class=\"hljs-keyword\">const</span> zipped = <span class=\"hljs-title function_\">zip</span>(source1, source2);\nzipped.<span class=\"hljs-title function_\">subscribe</span>(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value)\n);\n</code></pre>\n<p>이 예제에서는 of() 연산자를 사용하여 일정한 값 집합을 방출하는 두 Observables을 만듭니다. 그런 다음 zip() 연산자를 사용하여 두 Observables에서 방출한 값을 배열로 결합합니다. 마지막으로 zipped Observable을 구독하여 각 방출된 값을 콘솔에 기록합니다.</p>\n<div class=\"content-ad\"></div>\n<p>이 방식으로 옵저버블을 결합하고 조작함으로써, Angular 애플리케이션에서 다양한 유즈 케이스를 처리할 수 있는 복잡한 데이터 파이프라인을 만들 수 있습니다.</p>\n<h1>데이터를 변형하고 필터링하기 위해 오퍼레이터 사용하기</h1>\n<p>오퍼레이터는 옵저버블이 방출한 데이터를 변형하거나 필터링하거나 기타 방식으로 조작할 수 있는 함수들입니다. Angular 옵저버블과 함께 사용할 수 있는 많은 오퍼레이터가 RxJS 라이브러리에 제공되며, 여기에 몇 가지 예시가 있습니다:</p>\n<ul>\n<li>Map: map() 오퍼레이터를 사용하면 옵저버블에서 방출된 각 값을 새 값으로 변환할 수 있습니다. 다음은 예시입니다:</li>\n</ul>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">of</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">import</span> { map } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs/operators'</span>;\n\n<span class=\"hljs-keyword\">const</span> source = <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n<span class=\"hljs-keyword\">const</span> mapped = source.<span class=\"hljs-title function_\">pipe</span>(<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> value * <span class=\"hljs-number\">2</span>));\nmapped.<span class=\"hljs-title function_\">subscribe</span>(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value)\n);\n</code></pre>\n<p>이 예제에서는 of() 연산자를 사용하여 값을 고정된 세트로 방출하는 Observable을 생성합니다. 그런 다음 map() 연산자를 사용하여 각 방출된 값에 2를 곱해 변환합니다. 마지막으로 매핑된 Observable에 구독하고 각 방출된 값을 콘솔에 로깅합니다.</p>\n<ul>\n<li>Filter: filter() 연산자를 사용하면 주어진 조건에 따라 Observable에서 방출된 값을 필터링할 수 있습니다. 다음은 예시입니다:</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">of</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">import</span> { filter } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs/operators'</span>;\n\n<span class=\"hljs-keyword\">const</span> source = <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n<span class=\"hljs-keyword\">const</span> filtered = source.<span class=\"hljs-title function_\">pipe</span>(<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> value % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>));\nfiltered.<span class=\"hljs-title function_\">subscribe</span>(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value)\n);\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이 예시에서는 of() 연산자를 사용하여 Observable을 만듭니다. 이 연산자는 고정된 값 집합을 방출합니다. 그런 다음 filter() 연산자를 사용하여 짝수인 값만 방출하도록합니다. 마지막으로 필터링된 Observable을 구독하고 콘솔에 각 방출된 값을 기록합니다.</p>\n<ul>\n<li>Reduce: reduce() 연산자를 사용하면 Observable이 방출하는 값들을 누적하고 단일 값으로 반환할 수 있습니다. 다음은 예제입니다:</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">of</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">import</span> { reduce } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs/operators'</span>;\n\n<span class=\"hljs-keyword\">const</span> source = <span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n<span class=\"hljs-keyword\">const</span> reduced = source.<span class=\"hljs-title function_\">pipe</span>(<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">acc, value</span>) =></span> acc + value));\nreduced.<span class=\"hljs-title function_\">subscribe</span>(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value)\n);\n</code></pre>\n<p>이 예시에서는 of() 연산자를 사용하여 고정된 값 집합을 방출하는 Observable을 만듭니다. 그런 다음 reduce() 연산자를 사용하여 Observable이 방출하는 값들을 누적하고 그 합계를 반환합니다. 마지막으로 누적된 Observable을 구독하고 콘솔에 최종 누적 값의 로그를 남깁니다.</p>\n<div class=\"content-ad\"></div>\n<p>연산자인 map(), filter(), reduce()와 같은 것을 사용하여 Observable이 방출하는 데이터를 변환, 필터링하고 조작하여 Angular 애플리케이션에서 특정한 사용 사례에 맞게 맞출 수 있습니다.</p>\n<h1>Subjects를 사용하여 값을 방출하기</h1>\n<p>Observable 외에도 RxJS 라이브러리는 여러 구독자에게 값을 방출할 수 있는 Subject 클래스를 제공합니다. Subject는 Observable과 Observer 둘 다이므로 값을 방출하고 다른 Observables에 구독할 수 있습니다.</p>\n<p>다음은 Angular에서 Subject를 생성하는 예제입니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Subject</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  mySubject = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Subject</span>&#x3C;string>();\n  <span class=\"hljs-title function_\">emitValue</span>(<span class=\"hljs-params\">value: string</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">mySubject</span>.<span class=\"hljs-title function_\">next</span>(value);\n  }\n}\n</code></pre>\n<p>이 예시에서는 문자열 유형의 Subject를 생성하고 MyComponent 클래스의 속성으로 저장합니다. 그런 다음 emitValue() 메서드를 정의하고 해당 값을 mySubject 객체의 next() 메서드를 호출하여 구독자에게 해당 값을 방출합니다.</p>\n<p>Subject를 다른 Observable처럼 구독할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">myComponent.<span class=\"hljs-property\">mySubject</span>.<span class=\"hljs-title function_\">subscribe</span>(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =></span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value)\n)\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이 예시에서는 myComponent 객체의 mySubject Subject에 구독(subscribe)하여 발생한 모든 값들을 콘솔에 기록합니다.</p>\n<p>한 가지 주의할 점은 Subject를 구독할 때 Subject가 생성된 이후에 발생한 모든 값들을 받게 되는 것입니다. 구독 이후에 발생한 값들만 받고 싶다면 BehaviorSubject를 사용할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">BehaviorSubject</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyComponent</span> {\n  mySubject = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BehaviorSubject</span>&#x3C;string>(<span class=\"hljs-string\">'initial value'</span>);\n  <span class=\"hljs-title function_\">emitValue</span>(<span class=\"hljs-params\">value: string</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">mySubject</span>.<span class=\"hljs-title function_\">next</span>(value);\n  }\n}\n</code></pre>\n<p>이 예시에서는 string 타입의 BehaviorSubject를 생성하고 초기값을 <code>initial value</code>로 설정합니다. BehaviorSubject를 구독하면 초기값을 먼저 받은 뒤에 구독 이후에 발생한 모든 값들을 받게 됩니다.</p>\n<div class=\"content-ad\"></div>\n<p>Subject 및 BehaviorSubject을 사용하면 Angular 애플리케이션에서 값들을 발행하고 구독하는 강력한 방법이 될 수 있습니다. 이를 통해 컴포넌트와 서비스 간에 데이터를 쉽게 공유할 수 있으며 복잡한 데이터 흐름 시나리오를 간단화할 수 있습니다.</p>\n<h1>결론</h1>\n<p>Angular Observables은 Angular 애플리케이션의 비동기 데이터 흐름을 관리하는 강력한 도구입니다. RxJS 라이브러리의 도움으로 사용자 입력부터 HTTP 요청까지 모두 처리할 수 있는 Observables을 만들고 조작할 수 있습니다.</p>\n<p>이 글에서는 Observables의 기본을 다룰 때, 생성하고 구독하는 방법 및 연산자를 사용하여 발행된 값들을 변환하고 필터링하는 방법을 다뤘습니다. 또한 Subject을 사용하여 여러 구독자에게 값을 발행하는 고급 주제도 살펴보았습니다.</p>\n<div class=\"content-ad\"></div>\n<p>앵귤러 옵저버블을 효과적으로 활용하는 방법을 이해하면, 더 반응형이고 빠른 응용 프로그램을 만들어 사용자 경험을 향상시킬 수 있습니다. 간단한 양식 데이터든 복잡한 데이터 스트림이든 옵저버블을 사용하면 쉽게 관리할 수 있습니다.</p>\n<p>다음에 앵귤러 응용 프로그램을 작성할 때는 데이터 흐름 요구 사항을 처리하기 위해 옵저버블을 사용해보세요. 강력한 기능과 다양한 기능 세트로, 보다 견고하고 유연하며 확장 가능한 응용 프로그램을 만들 수 있을 것입니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}