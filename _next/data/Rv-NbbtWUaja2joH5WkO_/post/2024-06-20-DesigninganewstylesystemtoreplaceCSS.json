{"pageProps":{"post":{"title":"CSS를 대체할 새로운 스타일 시스템 설계하기","description":"","date":"2024-06-20 00:49","slug":"2024-06-20-DesigninganewstylesystemtoreplaceCSS","content":"\n\n## 자바스크립트 UI — 개발블로그 #3\n\n![이미지](/assets/img/2024-06-20-DesigninganewstylesystemtoreplaceCSS_0.png)\n\n## 소개\n\n저번 주에 자바스크립트 UI에서 기본 뷰 몇 가지를 소개하고, 웹 사이트/웹 앱에서 HTML이 필요 없게끔 뷰 트리를 구현한 내 방법에 대해 이야기했어요.\n\n<div class=\"content-ad\"></div>\n\n이번 주에는 CSS가 희생양이 되었습니다.\n\n## JavaScript 내 CSS\n\n간단히 말해서 JavaScriptUI는 CSS-in-JavaScript 솔루션입니다. DOM API가 HTML의 기능을 JavaScript로 이동하는 데 사용될 수 있는 것과 유사하게 우리는 CSS도 마찬가지로 할 수 있습니다. 이에 대한 두 가지 이유가 있습니다.\n\n먼저, 변수, 연산자, 조건문, 반복문 및 함수와 같은 적절한 프로그래밍 개념을 사용하는 것은 스타일링과 레이아웃 구축에 훨씬 강력한 방법입니다. 손에 들고 있는 손가락 수만 있어도 우리가 원하는 거의 모든 것을 달성할 수 있습니다. 이러한 도구들은 CSS조차도 시작했기 때문에 널리 사용되는데, 그것은 어설픈 방식으로 도입되었습니다. 그러면 JavaScript가 처음부터 이 도구들을 가지고 있고 훨씬 더 나은 구현을 가지고 있을 때는 왜 CSS도 이 도구들을 도입하려고 하는지 생각해 보게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n두 번째로, CSS에는 이해하기 어려운 몇 가지 개념이 있어서 이를 이해하고 학습하며 생산적으로 활용하기가 매우 어려운 점이 있습니다. 이 추상화는 스타일링 및 레이아웃 작업 방식을 재설계할 수 있는 기회를 제공할 것입니다. 이에 대해 보통 제 사용하는 네 가지 범주는 다음과 같습니다:\n\n- 현재 상태를 유지해야 하는 충분히 좋은 개념\n- 좋지만 이름을 변경해야 하는 개념\n- 잘못 설계되어 있어서 재설계가 필요한 개념\n- 잘못된 개념이지만 재설계할 수 없는 경우\n\n그럼 시작해 봅시다.\n\n## 이 가독성이 떨어지는 방식\n\n<div class=\"content-ad\"></div>\n\n일단 시작하면 \"최상의\" 관행을 위반해서 Views를 직접 대상으로 삼을 거에요. CSS가 이를 피하려고 애를 쓰는 것을 굉장히 재밌게 생각하죠. 어떤 옵션이 있는지 알아보죠:\n\n- 인라인 스타일 사용:\n\n```js\n<p style=\"font-family: Helvetica; color: black; opacity: 0.5\">Hello World</p>\n```\n\n- 외부 스타일 사용:\n\n<div class=\"content-ad\"></div>\n\n\n```js\n#foo {\n    font-family: Helvetica;\n    color: black;\n    opacity: 0.5\n}\n```\n\n- JavaScript로 스타일 사용:\n\n```js\n<p id=\"foo\">Hello World</p>\n```\n\n<div class=\"content-ad\"></div>\n\n```javascript\nconst foo = document.getElementById(\"foo\");\nfoo.style.fontFamily = \"Helvetica\";\nfoo.style.color = \"black\";\nfoo.style.opacity = 0.5;\n```\n\n이게 참으로 간단한 것인데 이렇게 못생겼게 보일 수 있는 건 정말 놀랍죠. 프론트엔드 개발 배울 때 아무나 시도해보는 가장 기본적인 것인데도 CSS가 왜 학습 곡선이 가파른지 궁금해지죠.\n\n## 현재 브라우저 API의 주요 문제점\n\n자바스크립트에서 스타일을 설정하는 방법은 두 가지가 있습니다: 개별 속성을 설정할 수도 있고, 뷰에서 클래스를 추가/제거할 수도 있습니다. 동적으로 클래스를 만드는 건 그다지 깔끔하지 않아서 저는 첫 번째 옵션에 집중하고 싶었어요.\n\n\n<div class=\"content-ad\"></div>\n\n우리의 Views가 HTMLElements이기 때문에 이미 접근하여 스타일 속성을 설정할 수 있습니다. 이는 JavaScript의 기본적인 옵션인데, 몇 가지 문제가 있어서 별로 좋아하지 않습니다:\n\n- 스타일 속성은 View 자체의 속성이 아니라 스타일 객체의 속성이므로 보일러플레이트가 추가되고 사용하기 어려워집니다.\n- 여러 속성 이름과 값이 나쁘고 일관성이 없거나 의미가 없습니다.\n- 타입 변환 및 단위 처리가 JavaScript의 동적 특성에 비해 꽤 좋지 않습니다.\n\n그래서 단순히 Views에 스타일 속성을 추가하는 것만으로는 해결되지 않았습니다. 나머지 문제들도 해결할 수 있는 스타일 시스템이 필요했습니다.\n\n```js\n//이것도 그다지 좋지 않습니다.\nconst text = Text(\"style me\");\ntext.fontFamily = \"Helvetica\"; \ntext.color = \"black\";\ntext.opacity = 0.5;\n```\n\n<div class=\"content-ad\"></div>\n\n## Getter/setter\n\n또 다른 흔한 방법은 값을 가져오거나 설정하기 전에 값을 처리하는 getter/setter 메소드를 사용하는 것입니다. 이를 여러 가지 방법으로 달성할 수 있습니다:\n\n- 일반 속성과 접근자 설명자 사용\n- Proxy 객체 사용\n- getter/setter 메소드 쌍 사용\n\n모든 옵션에는 중요한 단점이 있습니다: 일반 속성을 사용하는 것은 여전히 장황하며, Proxy를 추가하는 것은 지나친 것 같고 (그리고 현재는 HTML 요소를 래핑하는 것을 절대 피하고 싶습니다), 모든 속성을 두 가지 메소드로 정의하고 사용하는 것은 비대합니다. 제가 원했던 것은 훨씬 더 나은 것이면서 더 간결하며 물론 새로운 뷰 계층과 호환되어야 했습니다.\n\n<div class=\"content-ad\"></div>\n\n## 아름다움이야말로 미인\n\n얼마의 실험이 있었지만, 결국 getter/setter 메서드 구문을 결합하기로 결정했습니다. 여기 JavaScriptUI를 사용한 동일한 예제입니다:\n\n```js\nText(\"Hello World\")\n    .fontFamily(\"Helvetica\")\n    .fontColor(\"black\")\n    .opacity(0.5);\n```\n\n이 방식에는 여러 가지 이점이 있습니다. 간결하고 균일하며 복잡한 작업을 내부에서 처리할 수 있습니다. 또한 메서드를 연쇄적으로 사용하여 선언적 뷰 트리와 호환됩니다.\n\n<div class=\"content-ad\"></div>\n\n각 속성은 getter/setter 메서드를 사용하여 정의됩니다. 이 메서드는 인수가 있으면 setter로 작동하고 인수가 없으면 getter로 작동합니다. 이는 JavaScript에서는 지원되지 않지만 메서드 내부에서 전달된 인수의 개수를 확인하는 간단한 조건문으로 가짜로 만들 수 있습니다.\n\n놀랍게도, setter는 View 자체를 반환할 수도 있어서 메소드 체이닝을 지원합니다.\n\n따라서 다음과 같이:\n\n```js\nconst text = Text(\"Hello World\");\ntext.setFontFamily(\"Helvetica\");\ntext.getFontFamily();\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 이렇게 할 수 있어요:\n\n```js\nText(\"안녕하세요 세계\")\n    .fontFamily(\"Helvetica\")\n    .fontFamily(); // 현재 글꼴 가져오기\n```\n\n이러한 메서드들은 CSS와 비교하면 더 나은 이름, 더 좋은 값, 더 좋은 값 유형, 심지어는 더 나은 인수(더 나은 숫자 및/또는 더 좋은 순서의 인수)를 가질 수 있어요. 이것 또한 유효한 JavaScript이므로 브라우저에서 그냥 실행하기 전에 컴파일, 트랜스파일, 빌드 또는 수정할 필요가 전혀 없어요.\n\n<div class=\"content-ad\"></div>\n\n## 메탈을 밟으세요\n\n우리가 뷰 트리로 할 때처럼 스크립팅 언어로 이동하면 거의 끝없이 새로운 가능성이 열립니다. 여기에서 JavaScriptUI가 할 수 있는 몇 가지 아이디어를 간략히 소개해 드리겠습니다:\n\n- 값을 저장하기 위해 적절한 변수와 상수 사용\n\n```javascript\nconst color = \"darkgray\";\n\nStack(\n    Text(\"Hello World\")\n        .fontColor(color),\n\n    Text(\"Hola mundo\")\n        .fontColor(color)\n);\n```\n\n<div class=\"content-ad\"></div>\n\n- 값을 평가하는 연산자를 사용합니다\n\n```js\nlet darkMode = true;\n\nText(\"Hello World\")\n    .fontColor(darkMode ? \"white\" : \"black);\n```\n\n- 개체의 속성을 참조합니다\n\n```js\nconst catImage = Image(\"cat.jpeg\")\n    .width(100)\n    .height(300);\n\nconst dogImage = Image(\"dog.jpeg\")\n    .width(catImage.width())\n    .height(catImage.height());\n```\n\n<div class=\"content-ad\"></div>\n\n- 더 복잡한 로직을 정의하기 위해 콜백(callbacks)을 사용하세요\n\n```js\nImage(\"hero.jpeg\")\n    .width(() => {\n        if (device === \"mobile\") {\n            return 400;\n        }\n        \n        if (device === \"tablet\") {\n            return 600;\n        }\n        \n        if (device === \"desktop\") {\n            return 1200;\n        }\n    });\n```\n\n- 컴포넌트를 생성하고 스타일 관리를 중앙 집중화하기 위해 사용자 정의 클래스를 사용하세요\n\n```js\nfunction Button(label) {\n    return Text(label)\n        .width(\"content\")\n        .height(\"content\")\n        .padding(12, 40, 12, 40)\n        .cornerRadius(50)\n        .backgroundColor(\"lightblue\");\n}\n\nStack(\n    Button(\"Log in\"),\n    Button(\"Subscribe\")\n);\n```\n\n<div class=\"content-ad\"></div>\n\n- 반응형 프로그래밍을 위해 상태 값(즉, 시그널)를 사용합니다.\n\n```js\nImage(\"welcome.png\")\n    .width(viewport.width) // viewport.width가 변경될 때마다 재계산됩니다.\n    .height(viewport.height); // viewport.height가 변경될 때마다 재계산됩니다.\n```\n\n이것은 JavaScriptUI에서 이미 사용 가능한 아이디어 중 일부에 불과하며, 앞으로 더 많은 아이디어가 있고 더 실험 중인 것도 많습니다.\n\n## 그럼 이만큼입니다.\n\n<div class=\"content-ad\"></div>\n\n여러분께 보여드릴 기능이 아직 많지만, 지금은 여기까지 하겠습니다. 앞으로 몇 주 동안 JavaScriptUI가 레이아웃 작성을 어떻게 간소화하는지, 상호 작용을 어떻게 처리하는지, 다양한 상태/신호 구현을 어떻게 실험하는지, 그리고 전체적인 프론트엔드 개발을 개선하기 위해 여러 가지 HTML 및 CSS 개념을 어떻게 수정했는지를 보여드릴 예정입니다.\n\n그러니 기대해 주시고, JavaScriptUI를 좋아하신다면 박수를 치거나 댓글을 달거나 다른 사람들과 공유해 주시기 바랍니다.\n\n감사합니다. 즐거운 한 주 되세요.\n\n⬅️ JavaScriptUI — 개발블로그 #2, `rip`HTML`/rip`","ogImage":{"url":"/assets/img/2024-06-20-DesigninganewstylesystemtoreplaceCSS_0.png"},"coverImage":"/assets/img/2024-06-20-DesigninganewstylesystemtoreplaceCSS_0.png","tag":["Tech"],"readingTime":6},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>자바스크립트 UI — 개발블로그 #3</h2>\n<p><img src=\"/assets/img/2024-06-20-DesigninganewstylesystemtoreplaceCSS_0.png\" alt=\"이미지\"></p>\n<h2>소개</h2>\n<p>저번 주에 자바스크립트 UI에서 기본 뷰 몇 가지를 소개하고, 웹 사이트/웹 앱에서 HTML이 필요 없게끔 뷰 트리를 구현한 내 방법에 대해 이야기했어요.</p>\n<div class=\"content-ad\"></div>\n<p>이번 주에는 CSS가 희생양이 되었습니다.</p>\n<h2>JavaScript 내 CSS</h2>\n<p>간단히 말해서 JavaScriptUI는 CSS-in-JavaScript 솔루션입니다. DOM API가 HTML의 기능을 JavaScript로 이동하는 데 사용될 수 있는 것과 유사하게 우리는 CSS도 마찬가지로 할 수 있습니다. 이에 대한 두 가지 이유가 있습니다.</p>\n<p>먼저, 변수, 연산자, 조건문, 반복문 및 함수와 같은 적절한 프로그래밍 개념을 사용하는 것은 스타일링과 레이아웃 구축에 훨씬 강력한 방법입니다. 손에 들고 있는 손가락 수만 있어도 우리가 원하는 거의 모든 것을 달성할 수 있습니다. 이러한 도구들은 CSS조차도 시작했기 때문에 널리 사용되는데, 그것은 어설픈 방식으로 도입되었습니다. 그러면 JavaScript가 처음부터 이 도구들을 가지고 있고 훨씬 더 나은 구현을 가지고 있을 때는 왜 CSS도 이 도구들을 도입하려고 하는지 생각해 보게 됩니다.</p>\n<div class=\"content-ad\"></div>\n<p>두 번째로, CSS에는 이해하기 어려운 몇 가지 개념이 있어서 이를 이해하고 학습하며 생산적으로 활용하기가 매우 어려운 점이 있습니다. 이 추상화는 스타일링 및 레이아웃 작업 방식을 재설계할 수 있는 기회를 제공할 것입니다. 이에 대해 보통 제 사용하는 네 가지 범주는 다음과 같습니다:</p>\n<ul>\n<li>현재 상태를 유지해야 하는 충분히 좋은 개념</li>\n<li>좋지만 이름을 변경해야 하는 개념</li>\n<li>잘못 설계되어 있어서 재설계가 필요한 개념</li>\n<li>잘못된 개념이지만 재설계할 수 없는 경우</li>\n</ul>\n<p>그럼 시작해 봅시다.</p>\n<h2>이 가독성이 떨어지는 방식</h2>\n<div class=\"content-ad\"></div>\n<p>일단 시작하면 \"최상의\" 관행을 위반해서 Views를 직접 대상으로 삼을 거에요. CSS가 이를 피하려고 애를 쓰는 것을 굉장히 재밌게 생각하죠. 어떤 옵션이 있는지 알아보죠:</p>\n<ul>\n<li>인라인 스타일 사용:</li>\n</ul>\n<pre><code class=\"hljs language-js\">&#x3C;p style=<span class=\"hljs-string\">\"font-family: Helvetica; color: black; opacity: 0.5\"</span>><span class=\"hljs-title class_\">Hello</span> <span class=\"hljs-title class_\">World</span>&#x3C;/p>\n</code></pre>\n<ul>\n<li>외부 스타일 사용:</li>\n</ul>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">#foo {\n    font-<span class=\"hljs-attr\">family</span>: <span class=\"hljs-title class_\">Helvetica</span>;\n    <span class=\"hljs-attr\">color</span>: black;\n    <span class=\"hljs-attr\">opacity</span>: <span class=\"hljs-number\">0.5</span>\n}\n</code></pre>\n<ul>\n<li>JavaScript로 스타일 사용:</li>\n</ul>\n<pre><code class=\"hljs language-js\">&#x3C;p id=<span class=\"hljs-string\">\"foo\"</span>><span class=\"hljs-title class_\">Hello</span> <span class=\"hljs-title class_\">World</span>&#x3C;/p>\n</code></pre>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> foo = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">\"foo\"</span>);\nfoo.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">fontFamily</span> = <span class=\"hljs-string\">\"Helvetica\"</span>;\nfoo.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">\"black\"</span>;\nfoo.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">opacity</span> = <span class=\"hljs-number\">0.5</span>;\n</code></pre>\n<p>이게 참으로 간단한 것인데 이렇게 못생겼게 보일 수 있는 건 정말 놀랍죠. 프론트엔드 개발 배울 때 아무나 시도해보는 가장 기본적인 것인데도 CSS가 왜 학습 곡선이 가파른지 궁금해지죠.</p>\n<h2>현재 브라우저 API의 주요 문제점</h2>\n<p>자바스크립트에서 스타일을 설정하는 방법은 두 가지가 있습니다: 개별 속성을 설정할 수도 있고, 뷰에서 클래스를 추가/제거할 수도 있습니다. 동적으로 클래스를 만드는 건 그다지 깔끔하지 않아서 저는 첫 번째 옵션에 집중하고 싶었어요.</p>\n<div class=\"content-ad\"></div>\n<p>우리의 Views가 HTMLElements이기 때문에 이미 접근하여 스타일 속성을 설정할 수 있습니다. 이는 JavaScript의 기본적인 옵션인데, 몇 가지 문제가 있어서 별로 좋아하지 않습니다:</p>\n<ul>\n<li>스타일 속성은 View 자체의 속성이 아니라 스타일 객체의 속성이므로 보일러플레이트가 추가되고 사용하기 어려워집니다.</li>\n<li>여러 속성 이름과 값이 나쁘고 일관성이 없거나 의미가 없습니다.</li>\n<li>타입 변환 및 단위 처리가 JavaScript의 동적 특성에 비해 꽤 좋지 않습니다.</li>\n</ul>\n<p>그래서 단순히 Views에 스타일 속성을 추가하는 것만으로는 해결되지 않았습니다. 나머지 문제들도 해결할 수 있는 스타일 시스템이 필요했습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//이것도 그다지 좋지 않습니다.</span>\n<span class=\"hljs-keyword\">const</span> text = <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"style me\"</span>);\ntext.<span class=\"hljs-property\">fontFamily</span> = <span class=\"hljs-string\">\"Helvetica\"</span>; \ntext.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">\"black\"</span>;\ntext.<span class=\"hljs-property\">opacity</span> = <span class=\"hljs-number\">0.5</span>;\n</code></pre>\n<div class=\"content-ad\"></div>\n<h2>Getter/setter</h2>\n<p>또 다른 흔한 방법은 값을 가져오거나 설정하기 전에 값을 처리하는 getter/setter 메소드를 사용하는 것입니다. 이를 여러 가지 방법으로 달성할 수 있습니다:</p>\n<ul>\n<li>일반 속성과 접근자 설명자 사용</li>\n<li>Proxy 객체 사용</li>\n<li>getter/setter 메소드 쌍 사용</li>\n</ul>\n<p>모든 옵션에는 중요한 단점이 있습니다: 일반 속성을 사용하는 것은 여전히 장황하며, Proxy를 추가하는 것은 지나친 것 같고 (그리고 현재는 HTML 요소를 래핑하는 것을 절대 피하고 싶습니다), 모든 속성을 두 가지 메소드로 정의하고 사용하는 것은 비대합니다. 제가 원했던 것은 훨씬 더 나은 것이면서 더 간결하며 물론 새로운 뷰 계층과 호환되어야 했습니다.</p>\n<div class=\"content-ad\"></div>\n<h2>아름다움이야말로 미인</h2>\n<p>얼마의 실험이 있었지만, 결국 getter/setter 메서드 구문을 결합하기로 결정했습니다. 여기 JavaScriptUI를 사용한 동일한 예제입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"Hello World\"</span>)\n    .<span class=\"hljs-title function_\">fontFamily</span>(<span class=\"hljs-string\">\"Helvetica\"</span>)\n    .<span class=\"hljs-title function_\">fontColor</span>(<span class=\"hljs-string\">\"black\"</span>)\n    .<span class=\"hljs-title function_\">opacity</span>(<span class=\"hljs-number\">0.5</span>);\n</code></pre>\n<p>이 방식에는 여러 가지 이점이 있습니다. 간결하고 균일하며 복잡한 작업을 내부에서 처리할 수 있습니다. 또한 메서드를 연쇄적으로 사용하여 선언적 뷰 트리와 호환됩니다.</p>\n<div class=\"content-ad\"></div>\n<p>각 속성은 getter/setter 메서드를 사용하여 정의됩니다. 이 메서드는 인수가 있으면 setter로 작동하고 인수가 없으면 getter로 작동합니다. 이는 JavaScript에서는 지원되지 않지만 메서드 내부에서 전달된 인수의 개수를 확인하는 간단한 조건문으로 가짜로 만들 수 있습니다.</p>\n<p>놀랍게도, setter는 View 자체를 반환할 수도 있어서 메소드 체이닝을 지원합니다.</p>\n<p>따라서 다음과 같이:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> text = <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"Hello World\"</span>);\ntext.<span class=\"hljs-title function_\">setFontFamily</span>(<span class=\"hljs-string\">\"Helvetica\"</span>);\ntext.<span class=\"hljs-title function_\">getFontFamily</span>();\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>우리는 이렇게 할 수 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"안녕하세요 세계\"</span>)\n    .<span class=\"hljs-title function_\">fontFamily</span>(<span class=\"hljs-string\">\"Helvetica\"</span>)\n    .<span class=\"hljs-title function_\">fontFamily</span>(); <span class=\"hljs-comment\">// 현재 글꼴 가져오기</span>\n</code></pre>\n<p>이러한 메서드들은 CSS와 비교하면 더 나은 이름, 더 좋은 값, 더 좋은 값 유형, 심지어는 더 나은 인수(더 나은 숫자 및/또는 더 좋은 순서의 인수)를 가질 수 있어요. 이것 또한 유효한 JavaScript이므로 브라우저에서 그냥 실행하기 전에 컴파일, 트랜스파일, 빌드 또는 수정할 필요가 전혀 없어요.</p>\n<div class=\"content-ad\"></div>\n<h2>메탈을 밟으세요</h2>\n<p>우리가 뷰 트리로 할 때처럼 스크립팅 언어로 이동하면 거의 끝없이 새로운 가능성이 열립니다. 여기에서 JavaScriptUI가 할 수 있는 몇 가지 아이디어를 간략히 소개해 드리겠습니다:</p>\n<ul>\n<li>값을 저장하기 위해 적절한 변수와 상수 사용</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> color = <span class=\"hljs-string\">\"darkgray\"</span>;\n\n<span class=\"hljs-title class_\">Stack</span>(\n    <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"Hello World\"</span>)\n        .<span class=\"hljs-title function_\">fontColor</span>(color),\n\n    <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"Hola mundo\"</span>)\n        .<span class=\"hljs-title function_\">fontColor</span>(color)\n);\n</code></pre>\n<div class=\"content-ad\"></div>\n<ul>\n<li>값을 평가하는 연산자를 사용합니다</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> darkMode = <span class=\"hljs-literal\">true</span>;\n\n<span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"Hello World\"</span>)\n    .<span class=\"hljs-title function_\">fontColor</span>(darkMode ? <span class=\"hljs-string\">\"white\"</span> : <span class=\"hljs-string\">\"black);\n</span></code></pre>\n<ul>\n<li>개체의 속성을 참조합니다</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> catImage = <span class=\"hljs-title class_\">Image</span>(<span class=\"hljs-string\">\"cat.jpeg\"</span>)\n    .<span class=\"hljs-title function_\">width</span>(<span class=\"hljs-number\">100</span>)\n    .<span class=\"hljs-title function_\">height</span>(<span class=\"hljs-number\">300</span>);\n\n<span class=\"hljs-keyword\">const</span> dogImage = <span class=\"hljs-title class_\">Image</span>(<span class=\"hljs-string\">\"dog.jpeg\"</span>)\n    .<span class=\"hljs-title function_\">width</span>(catImage.<span class=\"hljs-title function_\">width</span>())\n    .<span class=\"hljs-title function_\">height</span>(catImage.<span class=\"hljs-title function_\">height</span>());\n</code></pre>\n<div class=\"content-ad\"></div>\n<ul>\n<li>더 복잡한 로직을 정의하기 위해 콜백(callbacks)을 사용하세요</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Image</span>(<span class=\"hljs-string\">\"hero.jpeg\"</span>)\n    .<span class=\"hljs-title function_\">width</span>(<span class=\"hljs-function\">() =></span> {\n        <span class=\"hljs-keyword\">if</span> (device === <span class=\"hljs-string\">\"mobile\"</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">400</span>;\n        }\n        \n        <span class=\"hljs-keyword\">if</span> (device === <span class=\"hljs-string\">\"tablet\"</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">600</span>;\n        }\n        \n        <span class=\"hljs-keyword\">if</span> (device === <span class=\"hljs-string\">\"desktop\"</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1200</span>;\n        }\n    });\n</code></pre>\n<ul>\n<li>컴포넌트를 생성하고 스타일 관리를 중앙 집중화하기 위해 사용자 정의 클래스를 사용하세요</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Button</span>(<span class=\"hljs-params\">label</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Text</span>(label)\n        .<span class=\"hljs-title function_\">width</span>(<span class=\"hljs-string\">\"content\"</span>)\n        .<span class=\"hljs-title function_\">height</span>(<span class=\"hljs-string\">\"content\"</span>)\n        .<span class=\"hljs-title function_\">padding</span>(<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">40</span>)\n        .<span class=\"hljs-title function_\">cornerRadius</span>(<span class=\"hljs-number\">50</span>)\n        .<span class=\"hljs-title function_\">backgroundColor</span>(<span class=\"hljs-string\">\"lightblue\"</span>);\n}\n\n<span class=\"hljs-title class_\">Stack</span>(\n    <span class=\"hljs-title class_\">Button</span>(<span class=\"hljs-string\">\"Log in\"</span>),\n    <span class=\"hljs-title class_\">Button</span>(<span class=\"hljs-string\">\"Subscribe\"</span>)\n);\n</code></pre>\n<div class=\"content-ad\"></div>\n<ul>\n<li>반응형 프로그래밍을 위해 상태 값(즉, 시그널)를 사용합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Image</span>(<span class=\"hljs-string\">\"welcome.png\"</span>)\n    .<span class=\"hljs-title function_\">width</span>(viewport.<span class=\"hljs-property\">width</span>) <span class=\"hljs-comment\">// viewport.width가 변경될 때마다 재계산됩니다.</span>\n    .<span class=\"hljs-title function_\">height</span>(viewport.<span class=\"hljs-property\">height</span>); <span class=\"hljs-comment\">// viewport.height가 변경될 때마다 재계산됩니다.</span>\n</code></pre>\n<p>이것은 JavaScriptUI에서 이미 사용 가능한 아이디어 중 일부에 불과하며, 앞으로 더 많은 아이디어가 있고 더 실험 중인 것도 많습니다.</p>\n<h2>그럼 이만큼입니다.</h2>\n<div class=\"content-ad\"></div>\n<p>여러분께 보여드릴 기능이 아직 많지만, 지금은 여기까지 하겠습니다. 앞으로 몇 주 동안 JavaScriptUI가 레이아웃 작성을 어떻게 간소화하는지, 상호 작용을 어떻게 처리하는지, 다양한 상태/신호 구현을 어떻게 실험하는지, 그리고 전체적인 프론트엔드 개발을 개선하기 위해 여러 가지 HTML 및 CSS 개념을 어떻게 수정했는지를 보여드릴 예정입니다.</p>\n<p>그러니 기대해 주시고, JavaScriptUI를 좋아하신다면 박수를 치거나 댓글을 달거나 다른 사람들과 공유해 주시기 바랍니다.</p>\n<p>감사합니다. 즐거운 한 주 되세요.</p>\n<p>⬅️ JavaScriptUI — 개발블로그 #2, <code>rip</code>HTML<code>/rip</code></p>\n</body>\n</html>\n"},"__N_SSG":true}