{"pageProps":{"post":{"title":"확장 가능한 Nestjs 프로젝트를 위한 마이크로서비스 아키텍처 구축 방법","description":"","date":"2024-06-22 14:00","slug":"2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects","content":"\n\n요즘에는 마이크로서비스 아키텍처가 확장 가능하고 유지보수가 용이하며 유연한 애플리케이션을 개발할 수 있는 능력 때문에 상당한 인기를 얻고 있습니다. Nest.js는 점진적인 Node.js 프레임워크로, 마이크로서비스를 구축하기에 적합합니다. 본 문서에서는 Nest.js 프로젝트를 위한 마이크로서비스 아키텍처를 설계하고 구현하는 방법을 살펴볼 것입니다. 마이크로서비스를 구축하는 데 필요한 주요 개념, 장점 및 최선의 방법, 그리고 구현을 설명하는 실용적인 코드 예제를 포함하고 있습니다.\n\n![마이크로서비스 아키텍처 구축](/assets/img/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects_0.png)\n\n## 목차\n\n- 마이크로서비스 소개\n- 마이크로서비스 아키텍처의 장점\n- Nest.js 프레임워크 이해\n- 마이크로서비스 아키텍처 설계\n  - 서비스 검색 및 레지스트리\n  - 부하 분산과 게이트웨이\n  - 데이터 저장 및 지속성\n  - 마이크로서비스 간 통신\n  - 오류 처리와 회복\n- Nest.js로 마이크로서비스 구현\n- Docker를 사용한 마이크로서비스 구축\n- 클라우드에 마이크로서비스 배포\n- 마이크로서비스 모니터링 및 확장\n- 마이크로서비스 테스트 및 디버깅\n- 마이크로서비스 개발을 위한 최선의 방법\n- 결론\n\n<div class=\"content-ad\"></div>\n\n# 1. 마이크로서비스 소개\n\n마이크로서비스는 응용 프로그램을 작은, 독립적이며 느슨하게 결합된 서비스 집합으로 나누는 아키텍처 스타일입니다. 각 마이크로서비스는 특정 업무 기능을 수행하며 다른 서비스와 API를 통해 통신합니다. 이 모듈식 접근법을 통해 팀은 각 서비스를 개발, 배포 및 확장할 수 있어 더 큰 유연성과 더 빠른 개발 주기를 제공합니다.\n\n# 2. 마이크로서비스 아키텍처의 장점\n\n마이크로서비스 아키텍처는 다음과 같은 여러 가지 장점을 제공합니다:\n\n<div class=\"content-ad\"></div>\n\n- 확장성: 각 마이크로서비스는 독립적으로 확장 가능하여 고효율로 대량 처리를 처리할 수 있습니다.\n- 유지보수성: 서비스들은 전체 애플리케이션에 영향을 주지 않고 독립적으로 유지보수 및 업데이트할 수 있습니다.\n- 유연성: 팀은 각 서비스의 요구 사항에 따라 다른 기술을 선택할 수 있습니다.\n- 오류 격리: 한 서비스가 실패해도 전체 시스템에 영향을 미치지 않아 높은 가용성을 보장합니다.\n- 빠른 개발: 작고 집중된 팀은 특정 서비스에 독립적으로 작업하여 개발 속도를 높일 수 있습니다.\n- 지속적인 배포: 서비스는 다른 구성 요소에 영향을 미치지 않고 개별적으로 배포할 수 있습니다.\n\n# 3. Nest.js 프레임워크 이해\n\nNest.js는 효율적이고 확장 가능하며 유지보수가 용이한 서버 측 애플리케이션을 구축하기 위해 설계된 강력한 Node.js 프레임워크입니다. API 생성, 의존성 주입 및 모듈화 아키텍처를 작성하는 데 내장 지원을 제공합니다. Nest.js는 Express.js 위에 구축되었으며 TypeScript를 활용하여 강한 타입 지정 및 향상된 생산성을 가능하게 합니다.\n\n# 4. 마이크로서비스 아키텍처 설계\n\n<div class=\"content-ad\"></div>\n\n코드 구현에 들어가기 전에, Nest.js 프로젝트를 위한 마이크로서비스 아키텍처를 설계해 봅시다.\n\n## 서비스 검색 및 레지스트리\n\n마이크로서비스 아키텍처에서는 서비스들이 서로를 발견하고 통신해야 합니다. Consul이나 Eureka와 같은 서비스 레지스트리를 사용하여 마이크로서비스를 등록하고 찾을 수 있습니다.\n\n## 부하 분산 및 게이트웨이\n\n<div class=\"content-ad\"></div>\n\n여러 인스턴스의 서비스 간에 오는 요청을 균등하게 분산시키기 위해 로드 밸런서가 필요합니다. 게이트웨이는 클라이언트의 입구 역할을 하고 요청을 적절한 마이크로서비스로 라우팅합니다.\n\n## 데이터 저장 및 지속성\n\n각 마이크로서비스는 독립적인 데이터 관리를 유지하기 위해 자체 데이터베이스나 데이터 저장소를 가져야 합니다.\n\n## 마이크로서비스 간 통신\n\n<div class=\"content-ad\"></div>\n\n마이크로서비스는 RabbitMQ나 Kafka와 같은 RESTful API 또는 메시지 큐를 통해 통신합니다.\n\n## 오류 처리와 내구성\n\n시스템이 실패에서 우아하게 복구할 수 있도록 견고한 오류 처리 및 내구성 패턴을 구현하세요.\n\n# 5. Nest.js로 마이크로서비스 구현하기\n\n<div class=\"content-ad\"></div>\n\n자, 이제 우리의 디자인을 실행하여 Nest.js를 사용하여 마이크로서비스를 구현해 봅시다.\n\n단계 1: 새로운 Nest.js 프로젝트 생성\n시작하려면 Nest.js CLI를 설치하고 새 프로젝트를 만듭니다:\n\n```js\nnpm install -g @nestjs/cli\nnest new microservices-project\ncd microservices-project\n```\n\n단계 2: 종속성 설치\n다음으로, 마이크로서비스를 위해 필요한 종속성을 설치하세요:\n\n<div class=\"content-ad\"></div>\n\n\nnpm install @nestjs/microservices @nestjs/typeorm typeorm mysql\r\n\n\r\nStep 3: Create Microservice Modules\r\n각각의 마이크로서비스를 위한 별도의 모듈을 만듭니다:\r\n\r\n```typescript\r\n// app.module.ts (Gateway)\r\nimport { Module } from '@nestjs/common';\r\nimport { AppController } from './app.controller';\r\nimport { AppService } from './app.service';\r\nimport { ClientsModule, Transport } from '@nestjs/microservices';\r\n\r\n@Module({\r\n  imports: [\r\n    ClientsModule.register([\r\n      {\r\n        name: 'SERVICE_A',\r\n        transport: Transport.TCP,\r\n        options: {\r\n          host: 'localhost',\r\n          port: 3001,\r\n        },\r\n      },\r\n      {\r\n        name: 'SERVICE_B',\r\n        transport: Transport.TCP,\r\n        options: {\r\n          host: 'localhost',\r\n          port: 3002,\r\n        },\r\n      },\r\n    ]),\r\n  ],\r\n  controllers: [AppController],\r\n  providers: [AppService],\r\n})\r\nexport class AppModule {}\r\n```\r\n\r\n```typescript\r\n// service-a.module.ts\r\nimport { Module } from '@nestjs/common';\r\nimport { ServiceAController } from './service-a.controller';\r\nimport { ServiceAService } from './service-a.service';\r\n\r\n@Module({\r\n  controllers: [ServiceAController],\r\n  providers: [ServiceAService],\r\n})\r\nexport class ServiceAModule {}\r\n```\n\n<div class=\"content-ad\"></div>\n\n```typescript\n// service-b.module.ts\nimport { Module } from '@nestjs/common';\nimport { ServiceBController } from './service-b.controller';\nimport { ServiceBService } from './service-b.service';\n\n@Module({\n  controllers: [ServiceBController],\n  providers: [ServiceBService],\n})\nexport class ServiceBModule {}\n```\n\nStep 4: 각 Microservice를 위한 Controllers 및 Services 구현\n각 Microservice에 대한 controllers 및 services를 생성하십시오:\n\n```typescript\n// app.controller.ts (Gateway)\nimport { Controller, Get, Inject } from '@nestjs/common';\nimport { AppService } from './app.service';\nimport { ClientProxy } from '@nestjs/microservices';\n\n@Controller()\nexport class AppController {\n  constructor(private readonly appService: AppService, @Inject('SERVICE_A') private readonly clientA: ClientProxy, @Inject('SERVICE_B') private readonly clientB: ClientProxy) {}\n\n  @Get()\n  async getHello(): Promise<string> {\n    const resultA = await this.clientA.send('getHello', '').toPromise();\n    const resultB = await this.clientB.send('getHello', '').toPromise();\n    return this.appService.getHello(resultA, resultB);\n  }\n}\n```\n\n```typescript\n// service-a.controller.ts\nimport { Controller, Get } from '@nestjs/common';\nimport { ServiceAService } from './service-a.service';\n\n@Controller()\nexport class ServiceAController {\n  constructor(private readonly serviceAService: ServiceAService) {}\n\n  @Get()\n  getHello(): string {\n    return this.serviceAService.getHello();\n  }\n}\n```  \n\n<div class=\"content-ad\"></div>\n\n```js\n// service-b.controller.ts\nimport { Controller, Get } from '@nestjs/common';\nimport { ServiceBService } from './service-b.service';\n\n@Controller()\nexport class ServiceBController {\n  constructor(private readonly serviceBService: ServiceBService) {}\n\n  @Get()\n  getHello(): string {\n    return this.serviceBService.getHello();\n  }\n}\n```\n\nStep 5: 서비스 로직 구현\n각 마이크로서비스에 대한 비즈니스 로직을 추가하십시오:\n\n```js\n// app.service.ts (게이트웨이)\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class AppService {\n  getHello(serviceA: string, serviceB: string): string {\n    return `서비스 A가 말합니다: ${serviceA}, 서비스 B가 말합니다: ${serviceB}`;\n  }\n}\n```\n\n```js\n// service-a.service.ts\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class ServiceAService {\n  getHello(): string {\n    return '서비스 A에서 안녕하세요';\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n// service-b.service.ts\nimport { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class ServiceBService {\n  getHello(): string {\n    return 'Hello from Service B';\n  }\n}\n```\n\n# 결론\n\n축하합니다! Nest.js 프로젝트를 위한 마이크로서비스 아키텍처를 성공적으로 구축했습니다. 마이크로서비스는 확장성, 유지보수성 및 장애 분리와 같은 여러 가지 이점을 제공합니다. 응용 프로그램을 더 작고 독립적인 서비스로 나누면 매우 유연하고 견고한 시스템을 구축할 수 있습니다. 마이크로서비스 개발을 위한 최상의 방법론을 따르는 것이 중요합니다. 서비스 검색, 부하 분산 및 적절한 오류 처리를 구현하는 것과 같은 것들을 잊지마세요.\n","ogImage":{"url":"/assets/img/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects_0.png","tag":["Tech"],"readingTime":7},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>요즘에는 마이크로서비스 아키텍처가 확장 가능하고 유지보수가 용이하며 유연한 애플리케이션을 개발할 수 있는 능력 때문에 상당한 인기를 얻고 있습니다. Nest.js는 점진적인 Node.js 프레임워크로, 마이크로서비스를 구축하기에 적합합니다. 본 문서에서는 Nest.js 프로젝트를 위한 마이크로서비스 아키텍처를 설계하고 구현하는 방법을 살펴볼 것입니다. 마이크로서비스를 구축하는 데 필요한 주요 개념, 장점 및 최선의 방법, 그리고 구현을 설명하는 실용적인 코드 예제를 포함하고 있습니다.</p>\n<p><img src=\"/assets/img/2024-06-22-BuildingaScalableMicroserviceArchitectureforNestjsProjects_0.png\" alt=\"마이크로서비스 아키텍처 구축\"></p>\n<h2>목차</h2>\n<ul>\n<li>마이크로서비스 소개</li>\n<li>마이크로서비스 아키텍처의 장점</li>\n<li>Nest.js 프레임워크 이해</li>\n<li>마이크로서비스 아키텍처 설계\n<ul>\n<li>서비스 검색 및 레지스트리</li>\n<li>부하 분산과 게이트웨이</li>\n<li>데이터 저장 및 지속성</li>\n<li>마이크로서비스 간 통신</li>\n<li>오류 처리와 회복</li>\n</ul>\n</li>\n<li>Nest.js로 마이크로서비스 구현</li>\n<li>Docker를 사용한 마이크로서비스 구축</li>\n<li>클라우드에 마이크로서비스 배포</li>\n<li>마이크로서비스 모니터링 및 확장</li>\n<li>마이크로서비스 테스트 및 디버깅</li>\n<li>마이크로서비스 개발을 위한 최선의 방법</li>\n<li>결론</li>\n</ul>\n<div class=\"content-ad\"></div>\n<h1>1. 마이크로서비스 소개</h1>\n<p>마이크로서비스는 응용 프로그램을 작은, 독립적이며 느슨하게 결합된 서비스 집합으로 나누는 아키텍처 스타일입니다. 각 마이크로서비스는 특정 업무 기능을 수행하며 다른 서비스와 API를 통해 통신합니다. 이 모듈식 접근법을 통해 팀은 각 서비스를 개발, 배포 및 확장할 수 있어 더 큰 유연성과 더 빠른 개발 주기를 제공합니다.</p>\n<h1>2. 마이크로서비스 아키텍처의 장점</h1>\n<p>마이크로서비스 아키텍처는 다음과 같은 여러 가지 장점을 제공합니다:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>확장성: 각 마이크로서비스는 독립적으로 확장 가능하여 고효율로 대량 처리를 처리할 수 있습니다.</li>\n<li>유지보수성: 서비스들은 전체 애플리케이션에 영향을 주지 않고 독립적으로 유지보수 및 업데이트할 수 있습니다.</li>\n<li>유연성: 팀은 각 서비스의 요구 사항에 따라 다른 기술을 선택할 수 있습니다.</li>\n<li>오류 격리: 한 서비스가 실패해도 전체 시스템에 영향을 미치지 않아 높은 가용성을 보장합니다.</li>\n<li>빠른 개발: 작고 집중된 팀은 특정 서비스에 독립적으로 작업하여 개발 속도를 높일 수 있습니다.</li>\n<li>지속적인 배포: 서비스는 다른 구성 요소에 영향을 미치지 않고 개별적으로 배포할 수 있습니다.</li>\n</ul>\n<h1>3. Nest.js 프레임워크 이해</h1>\n<p>Nest.js는 효율적이고 확장 가능하며 유지보수가 용이한 서버 측 애플리케이션을 구축하기 위해 설계된 강력한 Node.js 프레임워크입니다. API 생성, 의존성 주입 및 모듈화 아키텍처를 작성하는 데 내장 지원을 제공합니다. Nest.js는 Express.js 위에 구축되었으며 TypeScript를 활용하여 강한 타입 지정 및 향상된 생산성을 가능하게 합니다.</p>\n<h1>4. 마이크로서비스 아키텍처 설계</h1>\n<div class=\"content-ad\"></div>\n<p>코드 구현에 들어가기 전에, Nest.js 프로젝트를 위한 마이크로서비스 아키텍처를 설계해 봅시다.</p>\n<h2>서비스 검색 및 레지스트리</h2>\n<p>마이크로서비스 아키텍처에서는 서비스들이 서로를 발견하고 통신해야 합니다. Consul이나 Eureka와 같은 서비스 레지스트리를 사용하여 마이크로서비스를 등록하고 찾을 수 있습니다.</p>\n<h2>부하 분산 및 게이트웨이</h2>\n<div class=\"content-ad\"></div>\n<p>여러 인스턴스의 서비스 간에 오는 요청을 균등하게 분산시키기 위해 로드 밸런서가 필요합니다. 게이트웨이는 클라이언트의 입구 역할을 하고 요청을 적절한 마이크로서비스로 라우팅합니다.</p>\n<h2>데이터 저장 및 지속성</h2>\n<p>각 마이크로서비스는 독립적인 데이터 관리를 유지하기 위해 자체 데이터베이스나 데이터 저장소를 가져야 합니다.</p>\n<h2>마이크로서비스 간 통신</h2>\n<div class=\"content-ad\"></div>\n<p>마이크로서비스는 RabbitMQ나 Kafka와 같은 RESTful API 또는 메시지 큐를 통해 통신합니다.</p>\n<h2>오류 처리와 내구성</h2>\n<p>시스템이 실패에서 우아하게 복구할 수 있도록 견고한 오류 처리 및 내구성 패턴을 구현하세요.</p>\n<h1>5. Nest.js로 마이크로서비스 구현하기</h1>\n<div class=\"content-ad\"></div>\n<p>자, 이제 우리의 디자인을 실행하여 Nest.js를 사용하여 마이크로서비스를 구현해 봅시다.</p>\n<p>단계 1: 새로운 Nest.js 프로젝트 생성\n시작하려면 Nest.js CLI를 설치하고 새 프로젝트를 만듭니다:</p>\n<pre><code class=\"hljs language-js\">npm install -g @nestjs/cli\nnest <span class=\"hljs-keyword\">new</span> microservices-project\ncd microservices-project\n</code></pre>\n<p>단계 2: 종속성 설치\n다음으로, 마이크로서비스를 위해 필요한 종속성을 설치하세요:</p>\n<div class=\"content-ad\"></div>\n<p>npm install @nestjs/microservices @nestjs/typeorm typeorm mysql</p>\n<p>Step 3: Create Microservice Modules\r\n각각의 마이크로서비스를 위한 별도의 모듈을 만듭니다:</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// app.module.ts (Gateway)</span>\r\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Module</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\r\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AppController</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./app.controller'</span>;\r\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AppService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./app.service'</span>;\r\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ClientsModule</span>, <span class=\"hljs-title class_\">Transport</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/microservices'</span>;\r\n\r\n<span class=\"hljs-meta\">@Module</span>({\r\n  <span class=\"hljs-attr\">imports</span>: [\r\n    <span class=\"hljs-title class_\">ClientsModule</span>.<span class=\"hljs-title function_\">register</span>([\r\n      {\r\n        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'SERVICE_A'</span>,\r\n        <span class=\"hljs-attr\">transport</span>: <span class=\"hljs-title class_\">Transport</span>.<span class=\"hljs-property\">TCP</span>,\r\n        <span class=\"hljs-attr\">options</span>: {\r\n          <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">'localhost'</span>,\r\n          <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">3001</span>,\r\n        },\r\n      },\r\n      {\r\n        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'SERVICE_B'</span>,\r\n        <span class=\"hljs-attr\">transport</span>: <span class=\"hljs-title class_\">Transport</span>.<span class=\"hljs-property\">TCP</span>,\r\n        <span class=\"hljs-attr\">options</span>: {\r\n          <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">'localhost'</span>,\r\n          <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">3002</span>,\r\n        },\r\n      },\r\n    ]),\r\n  ],\r\n  <span class=\"hljs-attr\">controllers</span>: [<span class=\"hljs-title class_\">AppController</span>],\r\n  <span class=\"hljs-attr\">providers</span>: [<span class=\"hljs-title class_\">AppService</span>],\r\n})\r\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppModule</span> {}\n</code></pre>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// service-a.module.ts</span>\r\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Module</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\r\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ServiceAController</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./service-a.controller'</span>;\r\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ServiceAService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./service-a.service'</span>;\r\n\r\n<span class=\"hljs-meta\">@Module</span>({\r\n  <span class=\"hljs-attr\">controllers</span>: [<span class=\"hljs-title class_\">ServiceAController</span>],\r\n  <span class=\"hljs-attr\">providers</span>: [<span class=\"hljs-title class_\">ServiceAService</span>],\r\n})\r\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ServiceAModule</span> {}\n</code></pre>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// service-b.module.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Module</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ServiceBController</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./service-b.controller'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ServiceBService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./service-b.service'</span>;\n\n<span class=\"hljs-meta\">@Module</span>({\n  <span class=\"hljs-attr\">controllers</span>: [<span class=\"hljs-title class_\">ServiceBController</span>],\n  <span class=\"hljs-attr\">providers</span>: [<span class=\"hljs-title class_\">ServiceBService</span>],\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ServiceBModule</span> {}\n</code></pre>\n<p>Step 4: 각 Microservice를 위한 Controllers 및 Services 구현\n각 Microservice에 대한 controllers 및 services를 생성하십시오:</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// app.controller.ts (Gateway)</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Controller</span>, <span class=\"hljs-title class_\">Get</span>, <span class=\"hljs-title class_\">Inject</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AppService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./app.service'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ClientProxy</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/microservices'</span>;\n\n<span class=\"hljs-meta\">@Controller</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppController</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">readonly</span> appService: AppService, <span class=\"hljs-meta\">@Inject</span>(<span class=\"hljs-string\">'SERVICE_A'</span>) <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">readonly</span> clientA: ClientProxy, <span class=\"hljs-meta\">@Inject</span>(<span class=\"hljs-string\">'SERVICE_B'</span>) <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">readonly</span> clientB: ClientProxy</span>) {}\n\n  <span class=\"hljs-meta\">@Get</span>()\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">getHello</span>(): <span class=\"hljs-title class_\">Promise</span>&#x3C;<span class=\"hljs-built_in\">string</span>> {\n    <span class=\"hljs-keyword\">const</span> resultA = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clientA</span>.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">'getHello'</span>, <span class=\"hljs-string\">''</span>).<span class=\"hljs-title function_\">toPromise</span>();\n    <span class=\"hljs-keyword\">const</span> resultB = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">clientB</span>.<span class=\"hljs-title function_\">send</span>(<span class=\"hljs-string\">'getHello'</span>, <span class=\"hljs-string\">''</span>).<span class=\"hljs-title function_\">toPromise</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">appService</span>.<span class=\"hljs-title function_\">getHello</span>(resultA, resultB);\n  }\n}\n</code></pre>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-comment\">// service-a.controller.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Controller</span>, <span class=\"hljs-title class_\">Get</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ServiceAService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./service-a.service'</span>;\n\n<span class=\"hljs-meta\">@Controller</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ServiceAController</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">readonly</span> serviceAService: ServiceAService</span>) {}\n\n  <span class=\"hljs-meta\">@Get</span>()\n  <span class=\"hljs-title function_\">getHello</span>(): <span class=\"hljs-built_in\">string</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">serviceAService</span>.<span class=\"hljs-title function_\">getHello</span>();\n  }\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// service-b.controller.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Controller</span>, <span class=\"hljs-title class_\">Get</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">ServiceBService</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./service-b.service'</span>;\n\n@<span class=\"hljs-title class_\">Controller</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ServiceBController</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">private readonly serviceBService: ServiceBService</span>) {}\n\n  @<span class=\"hljs-title class_\">Get</span>()\n  <span class=\"hljs-title function_\">getHello</span>(): string {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">serviceBService</span>.<span class=\"hljs-title function_\">getHello</span>();\n  }\n}\n</code></pre>\n<p>Step 5: 서비스 로직 구현\n각 마이크로서비스에 대한 비즈니스 로직을 추가하십시오:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// app.service.ts (게이트웨이)</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\n\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AppService</span> {\n  <span class=\"hljs-title function_\">getHello</span>(<span class=\"hljs-attr\">serviceA</span>: string, <span class=\"hljs-attr\">serviceB</span>: string): string {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`서비스 A가 말합니다: <span class=\"hljs-subst\">${serviceA}</span>, 서비스 B가 말합니다: <span class=\"hljs-subst\">${serviceB}</span>`</span>;\n  }\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// service-a.service.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\n\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ServiceAService</span> {\n  <span class=\"hljs-title function_\">getHello</span>(): string {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'서비스 A에서 안녕하세요'</span>;\n  }\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// service-b.service.ts</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Injectable</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@nestjs/common'</span>;\n\n@<span class=\"hljs-title class_\">Injectable</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ServiceBService</span> {\n  <span class=\"hljs-title function_\">getHello</span>(): string {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'Hello from Service B'</span>;\n  }\n}\n</code></pre>\n<h1>결론</h1>\n<p>축하합니다! Nest.js 프로젝트를 위한 마이크로서비스 아키텍처를 성공적으로 구축했습니다. 마이크로서비스는 확장성, 유지보수성 및 장애 분리와 같은 여러 가지 이점을 제공합니다. 응용 프로그램을 더 작고 독립적인 서비스로 나누면 매우 유연하고 견고한 시스템을 구축할 수 있습니다. 마이크로서비스 개발을 위한 최상의 방법론을 따르는 것이 중요합니다. 서비스 검색, 부하 분산 및 적절한 오류 처리를 구현하는 것과 같은 것들을 잊지마세요.</p>\n</body>\n</html>\n"},"__N_SSG":true}