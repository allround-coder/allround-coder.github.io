<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>환상적인 CSS 테두리 애니메이션 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-FantasticCSSborderanimation" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="환상적인 CSS 테두리 애니메이션 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="환상적인 CSS 테두리 애니메이션 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-FantasticCSSborderanimation_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-FantasticCSSborderanimation" data-gatsby-head="true"/><meta name="twitter:title" content="환상적인 CSS 테두리 애니메이션 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-FantasticCSSborderanimation_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 06:05" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">환상적인 CSS 테두리 애니메이션</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="환상적인 CSS 테두리 애니메이션" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-FantasticCSSborderanimation&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>오늘 나는 블로그 사이트인 shoptalkshow를 방문했는데, 그 사이트에서 다음과 같은 스타일을 보게 되어 정말 흥미로웠어요:</p>
<img src="/assets/img/2024-06-20-FantasticCSSborderanimation_0.png">
<p>그 사이트의 스타일은 유니크하다고 생각되며, 특히 일부 베젤들이 돋보였어요.</p>
<p>따라서, 이 글에서는 CSS를 사용하여 다양하고 멋진 테두리 효과를 만들어볼 거예요.</p>
<div class="content-ad"></div>
<h1>CSS Border 속성</h1>
<p>테두리에 관한 이야기를 할 때, 가장 흔히 사용되는 속성은 solid와 dashed가 생각나는데, 위 그림에서는 dashed가 나타납니다.</p>
<p>가장 일반적인 solid와 dashed 외에도, CSS 테두리는 none, hidden, dotted, double, groove, ridge, inset, outset 등 다른 스타일도 지원합니다. 모든 네이티브 지원 테두리 스타일을 보려면 none, hidden을 제거해주세요:</p>
<p><img src="/assets/img/2024-06-20-FantasticCSSborderanimation_1.png" alt="Fantastic CSS Border Animation"></p>
<div class="content-ad"></div>
<p>이것들은 기본 사항들입니다. 다른 스타일의 테두리를 구현하거나 테두리에 애니메이션을 추가하려면 몇 가지 다른 속성과 협력하거나 마음을 열어야 합니다. 좋아요, 몇 가지 추가로 흥미로운 테두리를 살펴보겠습니다.</p>
<h1>테두리 길이 변경</h1>
<p>간단한 것부터 시작하여 다음과 같은 효과의 테두리를 얻는 방법을 살펴보겠습니다:</p>
<img src="/assets/img/2024-06-20-FantasticCSSborderanimation_2.png">
<div class="content-ad"></div>
<p>사실 이것은 두 가지 의사 요소가 요소를 빌려 사용하는 것입니다. 두 의사 요소의 상단 및 왼쪽 테두리, 아래쪽 및 오른쪽 테두리가 각각 설정되어 있으며, hover을 통해 두 가지 의사 요소의 높이와 너비를 변경할 수 있습니다. 이해하기 매우 쉽습니다.</p>
<pre><code class="hljs language-js">div {
    <span class="hljs-attr">position</span>: relative;
    <span class="hljs-attr">border</span>: 1px solid #03A9F3;
    
    &#x26;::before,
    &#x26;::after {
        <span class="hljs-attr">content</span>: <span class="hljs-string">""</span>;
        <span class="hljs-attr">position</span>: absolute;
        <span class="hljs-attr">width</span>: 20px;
        <span class="hljs-attr">height</span>: 20px;
    }
    
    &#x26;::before {
        <span class="hljs-attr">top</span>: -5px;
        <span class="hljs-attr">left</span>: -5px;
        border-<span class="hljs-attr">top</span>: 1px solid <span class="hljs-title function_">var</span>(--borderColor);
        border-<span class="hljs-attr">left</span>: 1px solid <span class="hljs-title function_">var</span>(--borderColor);
    }
    
    &#x26;::after {
        <span class="hljs-attr">right</span>: -5px;
        <span class="hljs-attr">bottom</span>: -5px;
        border-<span class="hljs-attr">bottom</span>: 1px solid <span class="hljs-title function_">var</span>(--borderColor);
        border-<span class="hljs-attr">right</span>: 1px solid <span class="hljs-title function_">var</span>(--borderColor);
    }
    
    &#x26;:<span class="hljs-attr">hover</span>::before,
    &#x26;:<span class="hljs-attr">hover</span>::after {
        <span class="hljs-attr">width</span>: <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span>% + 9px);
        <span class="hljs-attr">height</span>: <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span>% + 9px);
    }
}
</code></pre>
<p>CodePen Demo — 너비 테두리 애니메이션</p>
<p>다음으로 난이도를 조금 더 심화해 볼 예정입니다.</p>
<div class="content-ad"></div>
<h1>점선 테두리 애니메이션</h1>
<p><code>dashed</code> 키워드를 사용하여 쉽게 점선 테두리를 만들 수 있어요.</p>
<pre><code class="hljs language-js">div {
    <span class="hljs-attr">border</span>: 1px dashed #<span class="hljs-number">333</span>;
}
</code></pre>
<p><img src="/assets/img/2024-06-20-FantasticCSSborderanimation_3.png" alt="Fantastic CSS border animation"></p>
<div class="content-ad"></div>
<p>물론, 테이블 태그를 마크다운 형식으로 변경하겠습니다.</p>

























<table><thead><tr><th>브라우저</th><th>지원 여부</th></tr></thead><tbody><tr><td>Chrome</td><td>예</td></tr><tr><td>Firefox</td><td>예</td></tr><tr><td>Safari</td><td>예</td></tr><tr><td>Edge</td><td>예</td></tr></tbody></table>
<div class="content-ad"></div>
<p>그래디언트는 여러 개의 그래디언트를 지원해요. 우리는 모든 컨테이너의 네 면을 나타내기 위해 그래디언트를 사용할 수 있어요:</p>
<pre><code class="hljs language-js">div {
    <span class="hljs-attr">background</span>: 
        linear-<span class="hljs-title function_">gradient</span>(90deg, #<span class="hljs-number">333</span> <span class="hljs-number">50</span>%, transparent <span class="hljs-number">0</span>) repeat-x,
        linear-<span class="hljs-title function_">gradient</span>(90deg, #<span class="hljs-number">333</span> <span class="hljs-number">50</span>%, transparent <span class="hljs-number">0</span>) repeat-x,
        linear-<span class="hljs-title function_">gradient</span>(0deg, #<span class="hljs-number">333</span> <span class="hljs-number">50</span>%, transparent <span class="hljs-number">0</span>) repeat-y,
        linear-<span class="hljs-title function_">gradient</span>(0deg, #<span class="hljs-number">333</span> <span class="hljs-number">50</span>%, transparent <span class="hljs-number">0</span>) repeat-y;
    background-<span class="hljs-attr">size</span>: 4px 1px, 4px 1px, 1px 4px, 1px 4px;
    background-<span class="hljs-attr">position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-number">100</span>%, <span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">100</span>% <span class="hljs-number">0</span>;
}
</code></pre>
<p>효과는 다음과 같아요:</p>
<img src="/assets/img/2024-06-20-FantasticCSSborderanimation_5.png">
<div class="content-ad"></div>
<p>좋아요, 지금까지 우리의 점선 테두리 애니메이션이 사실상 절반 이상 완료되었습니다. 애니메이션에서 border-style: dashed가 지원되지는 않지만 gradients는 지원됩니다. 우리는 hover 효과를 추가하고 animation을 추가할 때, 배경 위치를 변경할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">div</span>:hover {
    <span class="hljs-attr">animation</span>: linearGradientMove <span class="hljs-number">.3</span>초 무한 선형;
}

@keyframes linearGradientMove {
    <span class="hljs-number">100</span>% {
        background-<span class="hljs-attr">position</span>: 4px <span class="hljs-number">0</span>, -4px <span class="hljs-number">100</span>%, <span class="hljs-number">0</span> -4px, <span class="hljs-number">100</span>% 4px;
    }
}
</code></pre>
<p>이제 효과를 보세요. hover가 발생할 때 테두리가 이동할 수 있습니다. 애니메이션 전체가 끝에서 끝으로 연결되어 있으므로 무한 루프 애니메이션은 항상 점선 테두리가 계속 이동하는 것처럼 보입니다. 이것은 작은 꼼수나 트릭입니다:</p>
<img src="/assets/img/2024-06-20-FantasticCSSborderanimation_6.png">
<div class="content-ad"></div>
<p>여기 또 하나의 작은 꿀팁이 있어요. 만약 주어진 그림자 테두리 애니메이션을 다른 테두리에서 대시 테두리로 전환하고 싶은 경우, 애니메이션을 시뮬레이션하는 것이 가능해요. 예를 들어 다음과 같을 거예요:</p>
<pre><code class="hljs language-js">div {
    <span class="hljs-attr">border</span>: 1px solid #<span class="hljs-number">333</span>;

    &#x26;:hover {
        <span class="hljs-attr">border</span>: none;
        <span class="hljs-attr">background</span>: 
            linear-<span class="hljs-title function_">gradient</span>(90deg, #<span class="hljs-number">333</span> <span class="hljs-number">50</span>%, transparent <span class="hljs-number">0</span>) repeat-x,
            linear-<span class="hljs-title function_">gradient</span>(90deg, #<span class="hljs-number">333</span> <span class="hljs-number">50</span>%, transparent <span class="hljs-number">0</span>) repeat-x,
            linear-<span class="hljs-title function_">gradient</span>(0deg, #<span class="hljs-number">333</span> <span class="hljs-number">50</span>%, transparent <span class="hljs-number">0</span>) repeat-y,
            linear-<span class="hljs-title function_">gradient</span>(0deg, #<span class="hljs-number">333</span> <span class="hljs-number">50</span>%, transparent <span class="hljs-number">0</span>) repeat-y;
        background-<span class="hljs-attr">size</span>: 4px 1px, 4px 1px, 1px 4px, 1px 4px;
        background-<span class="hljs-attr">position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span> <span class="hljs-number">100</span>%, <span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">100</span>% <span class="hljs-number">0</span>;
    }
}
</code></pre>
<p>박스 모델에서 테두리와 배경의 위치 차이로 인해 시각적인 정렬 오류가 발생할 수 있어요.</p>
<p><img src="/assets/img/2024-06-20-FantasticCSSborderanimation_7.png" alt="예시 이미지"></p>
<div class="content-ad"></div>
<p>위 문제를 해결하기 위해 테이블 태그를 마크다운 형식으로 변경할 수 있습니다.</p>
<pre><code class="hljs language-js">div {
    <span class="hljs-attr">outline</span>: 1px solid #<span class="hljs-number">333</span>;
    outline-<span class="hljs-attr">offset</span>: -1px;
    
    &#x26;:hover {
        <span class="hljs-attr">outline</span>: none;
    }
}
</code></pre>
<p>실제 버튼에 적용된 효과를 살펴보세요:</p>
<p><img src="/assets/img/2024-06-20-FantasticCSSborderanimation_8.png" alt="버튼 효과"></p>
<div class="content-ad"></div>
<p>위 Demo의 전체 코드는 다음과 같습니다:</p>
<p>CodePen 데모 - 대시 테두리 애니메이션</p>
<h1>그라데이션의 다른 멋진 사용법</h1>
<p>그라데이션을 사용하면 위의 효과뿐만 아니라 더 많은 효과를 얻을 수 있습니다.</p>
<div class="content-ad"></div>
<p>그라데이션에 대해 자세히 들어가서 이러한 배경을 만들기 위해 그라데이션을 사용하고 있어요:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">position</span>: relative;

    &#x26;<span class="hljs-selector-pseudo">::after</span> {
        <span class="hljs-attribute">content</span>: <span class="hljs-string">''</span>;
        <span class="hljs-attribute">position</span>: absolute;
        <span class="hljs-attribute">left</span>: -<span class="hljs-number">50%</span>;
        <span class="hljs-attribute">top</span>: -<span class="hljs-number">50%</span>;
        <span class="hljs-attribute">width</span>: <span class="hljs-number">200%</span>;
        <span class="hljs-attribute">height</span>: <span class="hljs-number">200%</span>;
        <span class="hljs-attribute">background-repeat</span>: no-repeat;
        <span class="hljs-attribute">background-size</span>: <span class="hljs-number">50%</span> <span class="hljs-number">50%</span>, <span class="hljs-number">50%</span> <span class="hljs-number">50%</span>;
        <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>, <span class="hljs-number">100%</span> <span class="hljs-number">0</span>, <span class="hljs-number">100%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">0</span> <span class="hljs-number">100%</span>;
        <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">#399953</span>, <span class="hljs-number">#399953</span>), <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">#fbb300</span>, <span class="hljs-number">#fbb300</span>), <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">#d53e33</span>, <span class="hljs-number">#d53e33</span>), <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">#377af5</span>, <span class="hljs-number">#377af5</span>);
    }
}
</code></pre>
<p>여기에서 요소의 가상 요소로 생성된 그래픽을 사용하고 있으며, 부모 요소의 너비와 높이는 200%이고, <code>overflow: hidden</code>으로 설정되어 있습니다.</p>
<p><img src="/assets/img/2024-06-20-FantasticCSSborderanimation_9.png" alt="FantasticCSSborderanimation_9"></p>
<div class="content-ad"></div>
<p>다음으로, 그것에 회전을 추가해 보세요:</p>
<pre><code class="hljs language-js">div {
    <span class="hljs-attr">animation</span>: rotate 4s linear infinite;
}

@keyframes rotate {
    <span class="hljs-number">100</span>% {
        <span class="hljs-attr">transform</span>: <span class="hljs-title function_">rotate</span>(1turn);
    }
}
</code></pre>
<p>효과를 확인해 보세요:</p>
<img src="/assets/img/2024-06-20-FantasticCSSborderanimation_10.png">
<div class="content-ad"></div>
<p>마지막으로 가상 요소를 사용하여 중간 부분을 가리고 멋진 테두리 애니메이션이 나오게 할 수 있어요. (투명한 요소들이 애니메이션 속에서 나타나면, 원리를 이해하는 데 도움이 될 거예요):</p>
<p><img src="/assets/img/2024-06-20-FantasticCSSborderanimation_11.png" alt="gradient border animation"></p>
<p>위 Demo의 완전한 코드는 다음과 같아요. 이 효과를 처음 본 곳은 이 저자 - Jesse B의 저자.</p>
<p>CodePen Demo - 그라데이션 테두리 애니메이션</p>
<div class="content-ad"></div>
<h1>그라데이션 색상 변경</h1>
<p>위의 기본 기술을 익힌 후에는 그라데이션의 색상을 조정할 수 있습니다. 4가지 색상을 1가지 색상으로 변환할 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">div</span>::after {
    <span class="hljs-attr">content</span>: <span class="hljs-string">''</span>;
    <span class="hljs-attr">position</span>: absolute;
    <span class="hljs-attr">left</span>: -<span class="hljs-number">50</span>%;
    <span class="hljs-attr">top</span>: -<span class="hljs-number">50</span>%;
    <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>%;
    <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>%;
    background-<span class="hljs-attr">color</span>: #fff;
    background-<span class="hljs-attr">repeat</span>: no-repeat;
    background-<span class="hljs-attr">size</span>: <span class="hljs-number">50</span>% <span class="hljs-number">50</span>%;
    background-<span class="hljs-attr">position</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;
    background-<span class="hljs-attr">image</span>: linear-<span class="hljs-title function_">gradient</span>(#<span class="hljs-number">399953</span>, #<span class="hljs-number">399953</span>);
}
</code></pre>
<p>이와 같은 그래픽을 얻을 수 있습니다:</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-20-FantasticCSSborderanimation_12.png">
<p>다시 한 번 함께 돌려보고 단색 추격 테두리 애니메이션이 나옵니다:</p>
<img src="/assets/img/2024-06-20-FantasticCSSborderanimation_13.png">
<p>CodePen 데모 - 그라데이션 테두리 애니메이션 2</p>
<div class="content-ad"></div>
<p>와우, 정말 멋지네요. 그러나 한 줄인 경우 뚜렷한 결함이 있습니다. 즉, 테두리 끝이 작은 삼각형인 대신 수직인 경우가 있습니다. 이는 특정 시나리오에서 적용되지 않거나 PM이 이를 수용하지 않을 수 있습니다.</p>
<img src="/assets/img/2024-06-20-FantasticCSSborderanimation_14.png">
<p>이러한 작은 삼각형을 제거할 방법이 있을까요? 네, 아래에서는 clip-path를 사용하여 이러한 작은 삼각형을 제거하는 다른 방법을 소개하겠습니다.</p>
<h1>코닉 그래디언트의 스마트한 사용</h1>
<div class="content-ad"></div>
<p>우리가 clip-path에 대해서 더 이상 진행하기 전에, 우선 각도 그라데이션에 대해 이야기해 봅시다.</p>
<p>위에서 언급된 내용은 주로 선형 그라데이션인 linear-gradient에 사용됩니다. 실제로 conic-gradient도 사용할 수 있습니다.</p>
<p>한 번 darker style로 conic-gradient을 시도해 보죠. 아래는 핵심 코드입니다:</p>
<pre><code class="hljs language-js">.<span class="hljs-property">conic</span> {
    <span class="hljs-attr">position</span>: relative;
    
    &#x26;::before {
        <span class="hljs-attr">content</span>: <span class="hljs-string">''</span>;
        <span class="hljs-attr">position</span>: absolute;
        <span class="hljs-attr">left</span>: -<span class="hljs-number">50</span>%;
        <span class="hljs-attr">top</span>: -<span class="hljs-number">50</span>%;
        <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>%;
        <span class="hljs-attr">height</span>: <span class="hljs-number">200</span>%;
        <span class="hljs-attr">background</span>: conic-<span class="hljs-title function_">gradient</span>(transparent, <span class="hljs-title function_">rgba</span>(<span class="hljs-number">168</span>, <span class="hljs-number">239</span>, <span class="hljs-number">255</span>, <span class="hljs-number">1</span>), transparent <span class="hljs-number">30</span>%);
        <span class="hljs-attr">animation</span>: rotate 4s linear infinite;
    }
}
@keyframes rotate {
    <span class="hljs-number">100</span>% {
        <span class="hljs-attr">transform</span>: <span class="hljs-title function_">rotate</span>(1turn);
    }
}
</code></pre>
<div class="content-ad"></div>
<p>다음은 렌더링 및 개요도입니다. 부분 각도 그라데이션을 사용하여 그래프를 회전하고, 다른 가상 요소를 사용하여 중간 부분을 마스킹하여 선 부분 만이 노출되도록합니다:</p>
<p><img src="/assets/img/2024-06-20-FantasticCSSborderanimation_15.png" alt="이미지"></p>
<p>CodePen 데모 - 회전 테두리 3</p>
<h1>클립 경로의 스마트한 사용</h1>
<div class="content-ad"></div>
<p>이전에 친한 친구 clip-path가 다시 나타났습니다. 재미있는 일은 결코 없을 것입니다.</p>
<p>clip-path는 좌표점 자체를 애니메이션화하여 하나의 클리핑 모양에서 다른 클리핑 모양으로 변환할 수 있습니다.</p>
<p>이 기능을 사용하여 테두리 따라오는 효과를 잘 구현할 수 있습니다. 의사 코드는 다음과 같습니다:</p>
<pre><code class="hljs language-js">div {
    <span class="hljs-attr">position</span>: relative;

    &#x26;::before {
        <span class="hljs-attr">content</span>: <span class="hljs-string">""</span>;
        <span class="hljs-attr">position</span>: absolute;
        <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attr">right</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attr">bottom</span>: <span class="hljs-number">0</span>;
        <span class="hljs-attr">border</span>: 2px solid gold;
        <span class="hljs-attr">animation</span>: clippath 3s infinite linear;
    }
}

@keyframes clippath {
    <span class="hljs-number">0</span>%,
    <span class="hljs-number">100</span>% {
        clip-<span class="hljs-attr">path</span>: <span class="hljs-title function_">inset</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">95</span>% <span class="hljs-number">0</span>);
    }
    <span class="hljs-number">25</span>% {
        clip-<span class="hljs-attr">path</span>: <span class="hljs-title function_">inset</span>(<span class="hljs-number">0</span> <span class="hljs-number">95</span>% <span class="hljs-number">0</span> <span class="hljs-number">0</span>);
    }
    <span class="hljs-number">50</span>% {
        clip-<span class="hljs-attr">path</span>: <span class="hljs-title function_">inset</span>(<span class="hljs-number">95</span>% <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>);
    }
    <span class="hljs-number">75</span>% {
        clip-<span class="hljs-attr">path</span>: <span class="hljs-title function_">inset</span>(<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">95</span>%);
    }
}
</code></pre>
<div class="content-ad"></div>
<p>다음은 스키매틱 다이어그램과 함께 렌더링 내용입니다:</p>
<p><img src="/assets/img/2024-06-20-FantasticCSSborderanimation_16.png" alt="FantasticCSSborderanimation_16"></p>
<p>CodePen - 클립 패스 보더 애니메이션</p>
<p>여기서는 요소가 클립된다는 점을 감안하고 가상 요소를 사용하여 클리핑 및 애니메이션용 배경으로 사용할 수 있습니다. clip-path를 사용하면 잘려진 보더가 작은 삼각형을 생성하지 않는다는 것을 기억해 주세요. 동시에 이 방법은 둥근 border-radius모서리도 지원합니다.</p>
<div class="content-ad"></div>
<p>만약 다른 가상 요소를 사용하여 실제로 버튼 스타일을 구현한다면 다음과 같은 효과를 얻을 수 있습니다:</p>
<p><img src="/assets/img/2024-06-20-FantasticCSSborderanimation_17.png" alt="이미지"></p>
<p>CodePen — clip-path border animation 2</p>
<h1>overflow의 스마트한 활용</h1>
<div class="content-ad"></div>
<p>다음 트릭은 오버플로우를 사용하여 구현되었습니다. 이러한 테두리 애니메이션을 구현해보세요:</p>
<p><img src="/assets/img/2024-06-20-FantasticCSSborderanimation_18.png" alt="border animation"></p>
<p>왜 오버플로우로 구현했다고 말하는 건가요?</p>
<p>도표를 붙여주세요:</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-20-FantasticCSSborderanimation_19.png">
<p>CodePen Demo — Using overflow and transform to achieve line hover effect</p>
<p>Two core points:</p>
<ul>
<li>We use overflow: hiddento hide an entire element that was originally outside the container</li>
<li>used transform-origin, controls the center of rotation of the element</li>
</ul>
<div class="content-ad"></div>
<p>사실 흥미로운 CSS 효과 대부분이 비슷한 기술을 사용한다는 것을 발견했나요?</p>
<p>간단히 말해, 우리가 보는 애니메이션은 원래 현상의 일부에 불과합니다. 특정한 잘라내기, 투명도 변경, 마스크 등을 통해 우리는 결국 원래 현상의 일부만을 보게 됩니다.</p>
<h1>Border-image의 스마트한 활용</h1>
<p>border-image를 사용하여 흥미로운 테두리 애니메이션도 구현할 수 있습니다. border-image에 대해 매우 좋은 설명글이 있습니다 -- border-image의 올바른 사용법, 이 글은 기본 정의에 대해 자세히 설명하지 않습니다.</p>
<div class="content-ad"></div>
<p>만약 이런 그래프가 있다면:</p>
<img src="/assets/img/2024-06-20-FantasticCSSborderanimation_20.png">
<p>비슷한 테두리 패턴을 얻기 위해 다음과 같이 사용할 수 있습니다:</p>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">div</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">120px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">24px</span> solid;
  <span class="hljs-attribute">border-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">image-url</span>);
  <span class="hljs-attribute">border-image-slice</span>: <span class="hljs-number">32</span>;
  <span class="hljs-attribute">border-image-repeat</span>: round;
}
</code></pre>
<div class="content-ad"></div>
<p>위와 같이 요소의 높이와 너비를 마음대로 변경할 수 있으므로, 컨테이너 테두리의 크기에 맞춰 확장할 수 있습니다:</p>
<p><img src="/assets/img/2024-06-20-FantasticCSSborderanimation_21.png" alt="이미지"></p>
<p>코드펜 데모 — border-image 데모</p>
<p>그리고, 이 기사인 — border-image를 사용한 SVG 애니메이션 방법 에서도, 매우 멋진 효과를 낼 수 있는 border animation를 설명했었어요.</p>
<div class="content-ad"></div>
<p>위 예제와의 차이점은 우리가 패턴을 움직이게 할 필요가 있다는 점입니다. 즉, 이러한 배경 이미지가 필요합니다:</p>
<p><img src="/assets/img/2024-06-20-FantasticCSSborderanimation_22.png" alt="이미지"></p>
<p>그럼, 우리도 움직이는 테두리 맵을 얻을 수 있습니다. 코드는 정확히 같지만, 테두리가 움직입니다:</p>
<p><img src="/assets/img/2024-06-20-FantasticCSSborderanimation_23.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>CodePen 데모 — 춤추는 해골 테두리</p>
<h1>border-image 및 그라데이션</h1>
<p>border-image는 텍스처 참조 url에 추가하여 직접 색상 또는 그라데이션을 채울 수 있습니다.</p>
<p>border-image와 filter, clip-path를 사용하여 그라데이션 변환을 가진 둥근 테두리를 만들 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">.<span class="hljs-property">border</span>-image-clip-path {
    <span class="hljs-attr">width</span>: 200px;
    <span class="hljs-attr">height</span>: 100px;
    <span class="hljs-attr">border</span>: 10px solid;
    border-<span class="hljs-attr">image</span>: linear-<span class="hljs-title function_">gradient</span>(45deg, gold, deeppink) <span class="hljs-number">1</span>;
    clip-<span class="hljs-attr">path</span>: <span class="hljs-title function_">inset</span>(0px round 10px);
    <span class="hljs-attr">animation</span>: huerotate 6s infinite linear;
    <span class="hljs-attr">filter</span>: hue-<span class="hljs-title function_">rotate</span>(360deg);
}

@keyframes huerotate {
    <span class="hljs-number">0</span>% {
        <span class="hljs-attr">filter</span>: hue-<span class="hljs-title function_">rotate</span>(0deg);
    }
    <span class="hljs-number">100</span>% {
        <span class="hljs-attr">filter</span>: hue-<span class="hljs-title function_">rotate</span>(360deg);
    }
}
</code></pre>
<img src="/assets/img/2024-06-20-FantasticCSSborderanimation_24.png">
<p>코드펜 데모 - clip-path, border-image 및 필터를 사용하여 둥근 그라데이션 테두리 구현하기</p>
<h1>마무리하기</h1>
<div class="content-ad"></div>
<p>iCSS에 좀 더 멋진 CSS 기술 관련 문서들이 요약되어 있어요.</p>
<p>그리고 아마도 제 CodePen을 좋아하실 거에요. 여기에는 놀라운 CSS 효과가 많아요.</p>
<p>여튼, 이 기사는 여기까지입니다. 도움이 되길 바라요. :)</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"환상적인 CSS 테두리 애니메이션","description":"","date":"2024-06-20 06:05","slug":"2024-06-20-FantasticCSSborderanimation","content":"\n\n오늘 나는 블로그 사이트인 shoptalkshow를 방문했는데, 그 사이트에서 다음과 같은 스타일을 보게 되어 정말 흥미로웠어요:\n\n\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_0.png\" /\u003e\n\n\n그 사이트의 스타일은 유니크하다고 생각되며, 특히 일부 베젤들이 돋보였어요.\n\n따라서, 이 글에서는 CSS를 사용하여 다양하고 멋진 테두리 효과를 만들어볼 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# CSS Border 속성\n\n테두리에 관한 이야기를 할 때, 가장 흔히 사용되는 속성은 solid와 dashed가 생각나는데, 위 그림에서는 dashed가 나타납니다.\n\n가장 일반적인 solid와 dashed 외에도, CSS 테두리는 none, hidden, dotted, double, groove, ridge, inset, outset 등 다른 스타일도 지원합니다. 모든 네이티브 지원 테두리 스타일을 보려면 none, hidden을 제거해주세요:\n\n![Fantastic CSS Border Animation](/assets/img/2024-06-20-FantasticCSSborderanimation_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것들은 기본 사항들입니다. 다른 스타일의 테두리를 구현하거나 테두리에 애니메이션을 추가하려면 몇 가지 다른 속성과 협력하거나 마음을 열어야 합니다. 좋아요, 몇 가지 추가로 흥미로운 테두리를 살펴보겠습니다.\n\n# 테두리 길이 변경\n\n간단한 것부터 시작하여 다음과 같은 효과의 테두리를 얻는 방법을 살펴보겠습니다:\n\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사실 이것은 두 가지 의사 요소가 요소를 빌려 사용하는 것입니다. 두 의사 요소의 상단 및 왼쪽 테두리, 아래쪽 및 오른쪽 테두리가 각각 설정되어 있으며, hover을 통해 두 가지 의사 요소의 높이와 너비를 변경할 수 있습니다. 이해하기 매우 쉽습니다.\n\n```js\ndiv {\n    position: relative;\n    border: 1px solid #03A9F3;\n    \n    \u0026::before,\n    \u0026::after {\n        content: \"\";\n        position: absolute;\n        width: 20px;\n        height: 20px;\n    }\n    \n    \u0026::before {\n        top: -5px;\n        left: -5px;\n        border-top: 1px solid var(--borderColor);\n        border-left: 1px solid var(--borderColor);\n    }\n    \n    \u0026::after {\n        right: -5px;\n        bottom: -5px;\n        border-bottom: 1px solid var(--borderColor);\n        border-right: 1px solid var(--borderColor);\n    }\n    \n    \u0026:hover::before,\n    \u0026:hover::after {\n        width: calc(100% + 9px);\n        height: calc(100% + 9px);\n    }\n}\n```\n\nCodePen Demo — 너비 테두리 애니메이션\n\n다음으로 난이도를 조금 더 심화해 볼 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 점선 테두리 애니메이션\n\n`dashed` 키워드를 사용하여 쉽게 점선 테두리를 만들 수 있어요.\n\n```js\ndiv {\n    border: 1px dashed #333;\n}\n```\n\n![Fantastic CSS border animation](/assets/img/2024-06-20-FantasticCSSborderanimation_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n물론, 테이블 태그를 마크다운 형식으로 변경하겠습니다.\n\n\n| 브라우저 | 지원 여부 |\n| ------- | --------- |\n| Chrome  | 예        |\n| Firefox | 예        |\n| Safari  | 예        |\n| Edge    | 예        |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래디언트는 여러 개의 그래디언트를 지원해요. 우리는 모든 컨테이너의 네 면을 나타내기 위해 그래디언트를 사용할 수 있어요:\n\n```js\ndiv {\n    background: \n        linear-gradient(90deg, #333 50%, transparent 0) repeat-x,\n        linear-gradient(90deg, #333 50%, transparent 0) repeat-x,\n        linear-gradient(0deg, #333 50%, transparent 0) repeat-y,\n        linear-gradient(0deg, #333 50%, transparent 0) repeat-y;\n    background-size: 4px 1px, 4px 1px, 1px 4px, 1px 4px;\n    background-position: 0 0, 0 100%, 0 0, 100% 0;\n}\n```\n\n효과는 다음과 같아요:\n\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_5.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요, 지금까지 우리의 점선 테두리 애니메이션이 사실상 절반 이상 완료되었습니다. 애니메이션에서 border-style: dashed가 지원되지는 않지만 gradients는 지원됩니다. 우리는 hover 효과를 추가하고 animation을 추가할 때, 배경 위치를 변경할 수 있습니다.\n\n```js\ndiv:hover {\n    animation: linearGradientMove .3초 무한 선형;\n}\n\n@keyframes linearGradientMove {\n    100% {\n        background-position: 4px 0, -4px 100%, 0 -4px, 100% 4px;\n    }\n}\n```\n\n이제 효과를 보세요. hover가 발생할 때 테두리가 이동할 수 있습니다. 애니메이션 전체가 끝에서 끝으로 연결되어 있으므로 무한 루프 애니메이션은 항상 점선 테두리가 계속 이동하는 것처럼 보입니다. 이것은 작은 꼼수나 트릭입니다:\n\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_6.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 또 하나의 작은 꿀팁이 있어요. 만약 주어진 그림자 테두리 애니메이션을 다른 테두리에서 대시 테두리로 전환하고 싶은 경우, 애니메이션을 시뮬레이션하는 것이 가능해요. 예를 들어 다음과 같을 거예요:\n\n```js\ndiv {\n    border: 1px solid #333;\n\n    \u0026:hover {\n        border: none;\n        background: \n            linear-gradient(90deg, #333 50%, transparent 0) repeat-x,\n            linear-gradient(90deg, #333 50%, transparent 0) repeat-x,\n            linear-gradient(0deg, #333 50%, transparent 0) repeat-y,\n            linear-gradient(0deg, #333 50%, transparent 0) repeat-y;\n        background-size: 4px 1px, 4px 1px, 1px 4px, 1px 4px;\n        background-position: 0 0, 0 100%, 0 0, 100% 0;\n    }\n}\n```\n\n박스 모델에서 테두리와 배경의 위치 차이로 인해 시각적인 정렬 오류가 발생할 수 있어요.\n\n![예시 이미지](/assets/img/2024-06-20-FantasticCSSborderanimation_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 문제를 해결하기 위해 테이블 태그를 마크다운 형식으로 변경할 수 있습니다. \n\n```js\ndiv {\n    outline: 1px solid #333;\n    outline-offset: -1px;\n    \n    \u0026:hover {\n        outline: none;\n    }\n}\n```\n\n실제 버튼에 적용된 효과를 살펴보세요:\n\n![버튼 효과](/assets/img/2024-06-20-FantasticCSSborderanimation_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 Demo의 전체 코드는 다음과 같습니다:\n\nCodePen 데모 - 대시 테두리 애니메이션\n\n# 그라데이션의 다른 멋진 사용법\n\n그라데이션을 사용하면 위의 효과뿐만 아니라 더 많은 효과를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그라데이션에 대해 자세히 들어가서 이러한 배경을 만들기 위해 그라데이션을 사용하고 있어요:\n\n```css\ndiv {\n    position: relative;\n\n    \u0026::after {\n        content: '';\n        position: absolute;\n        left: -50%;\n        top: -50%;\n        width: 200%;\n        height: 200%;\n        background-repeat: no-repeat;\n        background-size: 50% 50%, 50% 50%;\n        background-position: 0 0, 100% 0, 100% 100%, 0 100%;\n        background-image: linear-gradient(#399953, #399953), linear-gradient(#fbb300, #fbb300), linear-gradient(#d53e33, #d53e33), linear-gradient(#377af5, #377af5);\n    }\n}\n```\n\n여기에서 요소의 가상 요소로 생성된 그래픽을 사용하고 있으며, 부모 요소의 너비와 높이는 200%이고, `overflow: hidden`으로 설정되어 있습니다.\n\n![FantasticCSSborderanimation_9](/assets/img/2024-06-20-FantasticCSSborderanimation_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, 그것에 회전을 추가해 보세요:\n\n```js\ndiv {\n    animation: rotate 4s linear infinite;\n}\n\n@keyframes rotate {\n    100% {\n        transform: rotate(1turn);\n    }\n}\n```\n\n효과를 확인해 보세요:\n\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_10.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 가상 요소를 사용하여 중간 부분을 가리고 멋진 테두리 애니메이션이 나오게 할 수 있어요. (투명한 요소들이 애니메이션 속에서 나타나면, 원리를 이해하는 데 도움이 될 거예요):\n\n![gradient border animation](/assets/img/2024-06-20-FantasticCSSborderanimation_11.png)\n\n위 Demo의 완전한 코드는 다음과 같아요. 이 효과를 처음 본 곳은 이 저자 - Jesse B의 저자.\n\nCodePen Demo - 그라데이션 테두리 애니메이션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 그라데이션 색상 변경\n\n위의 기본 기술을 익힌 후에는 그라데이션의 색상을 조정할 수 있습니다. 4가지 색상을 1가지 색상으로 변환할 것입니다:\n\n```js\ndiv::after {\n    content: '';\n    position: absolute;\n    left: -50%;\n    top: -50%;\n    width: 200%;\n    height: 200%;\n    background-color: #fff;\n    background-repeat: no-repeat;\n    background-size: 50% 50%;\n    background-position: 0 0;\n    background-image: linear-gradient(#399953, #399953);\n}\n```\n\n이와 같은 그래픽을 얻을 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_12.png\" /\u003e\n\n다시 한 번 함께 돌려보고 단색 추격 테두리 애니메이션이 나옵니다:\n\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_13.png\" /\u003e\n\nCodePen 데모 - 그라데이션 테두리 애니메이션 2\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n와우, 정말 멋지네요. 그러나 한 줄인 경우 뚜렷한 결함이 있습니다. 즉, 테두리 끝이 작은 삼각형인 대신 수직인 경우가 있습니다. 이는 특정 시나리오에서 적용되지 않거나 PM이 이를 수용하지 않을 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_14.png\" /\u003e\n\n이러한 작은 삼각형을 제거할 방법이 있을까요? 네, 아래에서는 clip-path를 사용하여 이러한 작은 삼각형을 제거하는 다른 방법을 소개하겠습니다.\n\n# 코닉 그래디언트의 스마트한 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 clip-path에 대해서 더 이상 진행하기 전에, 우선 각도 그라데이션에 대해 이야기해 봅시다.\n\n위에서 언급된 내용은 주로 선형 그라데이션인 linear-gradient에 사용됩니다. 실제로 conic-gradient도 사용할 수 있습니다.\n\n한 번 darker style로 conic-gradient을 시도해 보죠. 아래는 핵심 코드입니다:\n\n```js\n.conic {\n    position: relative;\n    \n    \u0026::before {\n        content: '';\n        position: absolute;\n        left: -50%;\n        top: -50%;\n        width: 200%;\n        height: 200%;\n        background: conic-gradient(transparent, rgba(168, 239, 255, 1), transparent 30%);\n        animation: rotate 4s linear infinite;\n    }\n}\n@keyframes rotate {\n    100% {\n        transform: rotate(1turn);\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 렌더링 및 개요도입니다. 부분 각도 그라데이션을 사용하여 그래프를 회전하고, 다른 가상 요소를 사용하여 중간 부분을 마스킹하여 선 부분 만이 노출되도록합니다:\n\n![이미지](/assets/img/2024-06-20-FantasticCSSborderanimation_15.png)\n\nCodePen 데모 - 회전 테두리 3\n\n# 클립 경로의 스마트한 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에 친한 친구 clip-path가 다시 나타났습니다. 재미있는 일은 결코 없을 것입니다.\n\nclip-path는 좌표점 자체를 애니메이션화하여 하나의 클리핑 모양에서 다른 클리핑 모양으로 변환할 수 있습니다.\n\n이 기능을 사용하여 테두리 따라오는 효과를 잘 구현할 수 있습니다. 의사 코드는 다음과 같습니다:\n\n```js\ndiv {\n    position: relative;\n\n    \u0026::before {\n        content: \"\";\n        position: absolute;\n        top: 0;\n        left: 0;\n        right: 0;\n        bottom: 0;\n        border: 2px solid gold;\n        animation: clippath 3s infinite linear;\n    }\n}\n\n@keyframes clippath {\n    0%,\n    100% {\n        clip-path: inset(0 0 95% 0);\n    }\n    25% {\n        clip-path: inset(0 95% 0 0);\n    }\n    50% {\n        clip-path: inset(95% 0 0 0);\n    }\n    75% {\n        clip-path: inset(0 0 0 95%);\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 스키매틱 다이어그램과 함께 렌더링 내용입니다:\n\n![FantasticCSSborderanimation_16](/assets/img/2024-06-20-FantasticCSSborderanimation_16.png)\n\nCodePen - 클립 패스 보더 애니메이션\n\n여기서는 요소가 클립된다는 점을 감안하고 가상 요소를 사용하여 클리핑 및 애니메이션용 배경으로 사용할 수 있습니다. clip-path를 사용하면 잘려진 보더가 작은 삼각형을 생성하지 않는다는 것을 기억해 주세요. 동시에 이 방법은 둥근 border-radius모서리도 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 다른 가상 요소를 사용하여 실제로 버튼 스타일을 구현한다면 다음과 같은 효과를 얻을 수 있습니다:\n\n![이미지](/assets/img/2024-06-20-FantasticCSSborderanimation_17.png)\n\nCodePen — clip-path border animation 2\n\n# overflow의 스마트한 활용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 트릭은 오버플로우를 사용하여 구현되었습니다. 이러한 테두리 애니메이션을 구현해보세요:\n\n![border animation](/assets/img/2024-06-20-FantasticCSSborderanimation_18.png)\n\n왜 오버플로우로 구현했다고 말하는 건가요?\n\n도표를 붙여주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_19.png\" /\u003e\n\nCodePen Demo — Using overflow and transform to achieve line hover effect\n\nTwo core points:\n\n- We use overflow: hiddento hide an entire element that was originally outside the container\n- used transform-origin, controls the center of rotation of the element\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사실 흥미로운 CSS 효과 대부분이 비슷한 기술을 사용한다는 것을 발견했나요?\n\n간단히 말해, 우리가 보는 애니메이션은 원래 현상의 일부에 불과합니다. 특정한 잘라내기, 투명도 변경, 마스크 등을 통해 우리는 결국 원래 현상의 일부만을 보게 됩니다.\n\n# Border-image의 스마트한 활용\n\nborder-image를 사용하여 흥미로운 테두리 애니메이션도 구현할 수 있습니다. border-image에 대해 매우 좋은 설명글이 있습니다 -- border-image의 올바른 사용법, 이 글은 기본 정의에 대해 자세히 설명하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이런 그래프가 있다면:\n\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_20.png\" /\u003e\n\n비슷한 테두리 패턴을 얻기 위해 다음과 같이 사용할 수 있습니다:\n\n```css\ndiv {\n  width: 200px;\n  height: 120px;\n  border: 24px solid;\n  border-image: url(image-url);\n  border-image-slice: 32;\n  border-image-repeat: round;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위와 같이 요소의 높이와 너비를 마음대로 변경할 수 있으므로, 컨테이너 테두리의 크기에 맞춰 확장할 수 있습니다:\n\n![이미지](/assets/img/2024-06-20-FantasticCSSborderanimation_21.png)\n\n코드펜 데모 — border-image 데모\n\n그리고, 이 기사인 — border-image를 사용한 SVG 애니메이션 방법 에서도, 매우 멋진 효과를 낼 수 있는 border animation를 설명했었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 예제와의 차이점은 우리가 패턴을 움직이게 할 필요가 있다는 점입니다. 즉, 이러한 배경 이미지가 필요합니다:\n\n![이미지](/assets/img/2024-06-20-FantasticCSSborderanimation_22.png)\n\n그럼, 우리도 움직이는 테두리 맵을 얻을 수 있습니다. 코드는 정확히 같지만, 테두리가 움직입니다:\n\n![이미지](/assets/img/2024-06-20-FantasticCSSborderanimation_23.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCodePen 데모 — 춤추는 해골 테두리\n\n# border-image 및 그라데이션\n\nborder-image는 텍스처 참조 url에 추가하여 직접 색상 또는 그라데이션을 채울 수 있습니다.\n\nborder-image와 filter, clip-path를 사용하여 그라데이션 변환을 가진 둥근 테두리를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n.border-image-clip-path {\n    width: 200px;\n    height: 100px;\n    border: 10px solid;\n    border-image: linear-gradient(45deg, gold, deeppink) 1;\n    clip-path: inset(0px round 10px);\n    animation: huerotate 6s infinite linear;\n    filter: hue-rotate(360deg);\n}\n\n@keyframes huerotate {\n    0% {\n        filter: hue-rotate(0deg);\n    }\n    100% {\n        filter: hue-rotate(360deg);\n    }\n}\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_24.png\" /\u003e\n\n코드펜 데모 - clip-path, border-image 및 필터를 사용하여 둥근 그라데이션 테두리 구현하기\n\n# 마무리하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niCSS에 좀 더 멋진 CSS 기술 관련 문서들이 요약되어 있어요.\n\n그리고 아마도 제 CodePen을 좋아하실 거에요. 여기에는 놀라운 CSS 효과가 많아요.\n\n여튼, 이 기사는 여기까지입니다. 도움이 되길 바라요. :)","ogImage":{"url":"/assets/img/2024-06-20-FantasticCSSborderanimation_0.png"},"coverImage":"/assets/img/2024-06-20-FantasticCSSborderanimation_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e오늘 나는 블로그 사이트인 shoptalkshow를 방문했는데, 그 사이트에서 다음과 같은 스타일을 보게 되어 정말 흥미로웠어요:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_0.png\"\u003e\n\u003cp\u003e그 사이트의 스타일은 유니크하다고 생각되며, 특히 일부 베젤들이 돋보였어요.\u003c/p\u003e\n\u003cp\u003e따라서, 이 글에서는 CSS를 사용하여 다양하고 멋진 테두리 효과를 만들어볼 거예요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eCSS Border 속성\u003c/h1\u003e\n\u003cp\u003e테두리에 관한 이야기를 할 때, 가장 흔히 사용되는 속성은 solid와 dashed가 생각나는데, 위 그림에서는 dashed가 나타납니다.\u003c/p\u003e\n\u003cp\u003e가장 일반적인 solid와 dashed 외에도, CSS 테두리는 none, hidden, dotted, double, groove, ridge, inset, outset 등 다른 스타일도 지원합니다. 모든 네이티브 지원 테두리 스타일을 보려면 none, hidden을 제거해주세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_1.png\" alt=\"Fantastic CSS Border Animation\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이것들은 기본 사항들입니다. 다른 스타일의 테두리를 구현하거나 테두리에 애니메이션을 추가하려면 몇 가지 다른 속성과 협력하거나 마음을 열어야 합니다. 좋아요, 몇 가지 추가로 흥미로운 테두리를 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003e테두리 길이 변경\u003c/h1\u003e\n\u003cp\u003e간단한 것부터 시작하여 다음과 같은 효과의 테두리를 얻는 방법을 살펴보겠습니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_2.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e사실 이것은 두 가지 의사 요소가 요소를 빌려 사용하는 것입니다. 두 의사 요소의 상단 및 왼쪽 테두리, 아래쪽 및 오른쪽 테두리가 각각 설정되어 있으며, hover을 통해 두 가지 의사 요소의 높이와 너비를 변경할 수 있습니다. 이해하기 매우 쉽습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ediv {\n    \u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: relative;\n    \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: 1px solid #03A9F3;\n    \n    \u0026#x26;::before,\n    \u0026#x26;::after {\n        \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e;\n        \u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: absolute;\n        \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: 20px;\n        \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: 20px;\n    }\n    \n    \u0026#x26;::before {\n        \u003cspan class=\"hljs-attr\"\u003etop\u003c/span\u003e: -5px;\n        \u003cspan class=\"hljs-attr\"\u003eleft\u003c/span\u003e: -5px;\n        border-\u003cspan class=\"hljs-attr\"\u003etop\u003c/span\u003e: 1px solid \u003cspan class=\"hljs-title function_\"\u003evar\u003c/span\u003e(--borderColor);\n        border-\u003cspan class=\"hljs-attr\"\u003eleft\u003c/span\u003e: 1px solid \u003cspan class=\"hljs-title function_\"\u003evar\u003c/span\u003e(--borderColor);\n    }\n    \n    \u0026#x26;::after {\n        \u003cspan class=\"hljs-attr\"\u003eright\u003c/span\u003e: -5px;\n        \u003cspan class=\"hljs-attr\"\u003ebottom\u003c/span\u003e: -5px;\n        border-\u003cspan class=\"hljs-attr\"\u003ebottom\u003c/span\u003e: 1px solid \u003cspan class=\"hljs-title function_\"\u003evar\u003c/span\u003e(--borderColor);\n        border-\u003cspan class=\"hljs-attr\"\u003eright\u003c/span\u003e: 1px solid \u003cspan class=\"hljs-title function_\"\u003evar\u003c/span\u003e(--borderColor);\n    }\n    \n    \u0026#x26;:\u003cspan class=\"hljs-attr\"\u003ehover\u003c/span\u003e::before,\n    \u0026#x26;:\u003cspan class=\"hljs-attr\"\u003ehover\u003c/span\u003e::after {\n        \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003ecalc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e% + 9px);\n        \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003ecalc\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e% + 9px);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCodePen Demo — 너비 테두리 애니메이션\u003c/p\u003e\n\u003cp\u003e다음으로 난이도를 조금 더 심화해 볼 예정입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e점선 테두리 애니메이션\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003edashed\u003c/code\u003e 키워드를 사용하여 쉽게 점선 테두리를 만들 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ediv {\n    \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: 1px dashed #\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_3.png\" alt=\"Fantastic CSS border animation\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e물론, 테이블 태그를 마크다운 형식으로 변경하겠습니다.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e브라우저\u003c/th\u003e\u003cth\u003e지원 여부\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eChrome\u003c/td\u003e\u003ctd\u003e예\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eFirefox\u003c/td\u003e\u003ctd\u003e예\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSafari\u003c/td\u003e\u003ctd\u003e예\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eEdge\u003c/td\u003e\u003ctd\u003e예\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그래디언트는 여러 개의 그래디언트를 지원해요. 우리는 모든 컨테이너의 네 면을 나타내기 위해 그래디언트를 사용할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ediv {\n    \u003cspan class=\"hljs-attr\"\u003ebackground\u003c/span\u003e: \n        linear-\u003cspan class=\"hljs-title function_\"\u003egradient\u003c/span\u003e(90deg, #\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%, transparent \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) repeat-x,\n        linear-\u003cspan class=\"hljs-title function_\"\u003egradient\u003c/span\u003e(90deg, #\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%, transparent \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) repeat-x,\n        linear-\u003cspan class=\"hljs-title function_\"\u003egradient\u003c/span\u003e(0deg, #\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%, transparent \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) repeat-y,\n        linear-\u003cspan class=\"hljs-title function_\"\u003egradient\u003c/span\u003e(0deg, #\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%, transparent \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) repeat-y;\n    background-\u003cspan class=\"hljs-attr\"\u003esize\u003c/span\u003e: 4px 1px, 4px 1px, 1px 4px, 1px 4px;\n    background-\u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e%, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e% \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e효과는 다음과 같아요:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_5.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e좋아요, 지금까지 우리의 점선 테두리 애니메이션이 사실상 절반 이상 완료되었습니다. 애니메이션에서 border-style: dashed가 지원되지는 않지만 gradients는 지원됩니다. 우리는 hover 효과를 추가하고 animation을 추가할 때, 배경 위치를 변경할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003ediv\u003c/span\u003e:hover {\n    \u003cspan class=\"hljs-attr\"\u003eanimation\u003c/span\u003e: linearGradientMove \u003cspan class=\"hljs-number\"\u003e.3\u003c/span\u003e초 무한 선형;\n}\n\n@keyframes linearGradientMove {\n    \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e% {\n        background-\u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: 4px \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, -4px \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e%, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e -4px, \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e% 4px;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 효과를 보세요. hover가 발생할 때 테두리가 이동할 수 있습니다. 애니메이션 전체가 끝에서 끝으로 연결되어 있으므로 무한 루프 애니메이션은 항상 점선 테두리가 계속 이동하는 것처럼 보입니다. 이것은 작은 꼼수나 트릭입니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_6.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기 또 하나의 작은 꿀팁이 있어요. 만약 주어진 그림자 테두리 애니메이션을 다른 테두리에서 대시 테두리로 전환하고 싶은 경우, 애니메이션을 시뮬레이션하는 것이 가능해요. 예를 들어 다음과 같을 거예요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ediv {\n    \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: 1px solid #\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e;\n\n    \u0026#x26;:hover {\n        \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: none;\n        \u003cspan class=\"hljs-attr\"\u003ebackground\u003c/span\u003e: \n            linear-\u003cspan class=\"hljs-title function_\"\u003egradient\u003c/span\u003e(90deg, #\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%, transparent \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) repeat-x,\n            linear-\u003cspan class=\"hljs-title function_\"\u003egradient\u003c/span\u003e(90deg, #\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%, transparent \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) repeat-x,\n            linear-\u003cspan class=\"hljs-title function_\"\u003egradient\u003c/span\u003e(0deg, #\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%, transparent \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) repeat-y,\n            linear-\u003cspan class=\"hljs-title function_\"\u003egradient\u003c/span\u003e(0deg, #\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%, transparent \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) repeat-y;\n        background-\u003cspan class=\"hljs-attr\"\u003esize\u003c/span\u003e: 4px 1px, 4px 1px, 1px 4px, 1px 4px;\n        background-\u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e%, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e% \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e박스 모델에서 테두리와 배경의 위치 차이로 인해 시각적인 정렬 오류가 발생할 수 있어요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_7.png\" alt=\"예시 이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위 문제를 해결하기 위해 테이블 태그를 마크다운 형식으로 변경할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ediv {\n    \u003cspan class=\"hljs-attr\"\u003eoutline\u003c/span\u003e: 1px solid #\u003cspan class=\"hljs-number\"\u003e333\u003c/span\u003e;\n    outline-\u003cspan class=\"hljs-attr\"\u003eoffset\u003c/span\u003e: -1px;\n    \n    \u0026#x26;:hover {\n        \u003cspan class=\"hljs-attr\"\u003eoutline\u003c/span\u003e: none;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e실제 버튼에 적용된 효과를 살펴보세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_8.png\" alt=\"버튼 효과\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위 Demo의 전체 코드는 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003eCodePen 데모 - 대시 테두리 애니메이션\u003c/p\u003e\n\u003ch1\u003e그라데이션의 다른 멋진 사용법\u003c/h1\u003e\n\u003cp\u003e그라데이션을 사용하면 위의 효과뿐만 아니라 더 많은 효과를 얻을 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그라데이션에 대해 자세히 들어가서 이러한 배경을 만들기 위해 그라데이션을 사용하고 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-css\"\u003e\u003cspan class=\"hljs-selector-tag\"\u003ediv\u003c/span\u003e {\n    \u003cspan class=\"hljs-attribute\"\u003eposition\u003c/span\u003e: relative;\n\n    \u0026#x26;\u003cspan class=\"hljs-selector-pseudo\"\u003e::after\u003c/span\u003e {\n        \u003cspan class=\"hljs-attribute\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e;\n        \u003cspan class=\"hljs-attribute\"\u003eposition\u003c/span\u003e: absolute;\n        \u003cspan class=\"hljs-attribute\"\u003eleft\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e50%\u003c/span\u003e;\n        \u003cspan class=\"hljs-attribute\"\u003etop\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e50%\u003c/span\u003e;\n        \u003cspan class=\"hljs-attribute\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200%\u003c/span\u003e;\n        \u003cspan class=\"hljs-attribute\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200%\u003c/span\u003e;\n        \u003cspan class=\"hljs-attribute\"\u003ebackground-repeat\u003c/span\u003e: no-repeat;\n        \u003cspan class=\"hljs-attribute\"\u003ebackground-size\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e50%\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50%\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e50%\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50%\u003c/span\u003e;\n        \u003cspan class=\"hljs-attribute\"\u003ebackground-position\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e100%\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e100%\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e100%\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e100%\u003c/span\u003e;\n        \u003cspan class=\"hljs-attribute\"\u003ebackground-image\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003elinear-gradient\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e#399953\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e#399953\u003c/span\u003e), \u003cspan class=\"hljs-built_in\"\u003elinear-gradient\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e#fbb300\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e#fbb300\u003c/span\u003e), \u003cspan class=\"hljs-built_in\"\u003elinear-gradient\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e#d53e33\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e#d53e33\u003c/span\u003e), \u003cspan class=\"hljs-built_in\"\u003elinear-gradient\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e#377af5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e#377af5\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에서 요소의 가상 요소로 생성된 그래픽을 사용하고 있으며, 부모 요소의 너비와 높이는 200%이고, \u003ccode\u003eoverflow: hidden\u003c/code\u003e으로 설정되어 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_9.png\" alt=\"FantasticCSSborderanimation_9\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음으로, 그것에 회전을 추가해 보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ediv {\n    \u003cspan class=\"hljs-attr\"\u003eanimation\u003c/span\u003e: rotate 4s linear infinite;\n}\n\n@keyframes rotate {\n    \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e% {\n        \u003cspan class=\"hljs-attr\"\u003etransform\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003erotate\u003c/span\u003e(1turn);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e효과를 확인해 보세요:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_10.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e마지막으로 가상 요소를 사용하여 중간 부분을 가리고 멋진 테두리 애니메이션이 나오게 할 수 있어요. (투명한 요소들이 애니메이션 속에서 나타나면, 원리를 이해하는 데 도움이 될 거예요):\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_11.png\" alt=\"gradient border animation\"\u003e\u003c/p\u003e\n\u003cp\u003e위 Demo의 완전한 코드는 다음과 같아요. 이 효과를 처음 본 곳은 이 저자 - Jesse B의 저자.\u003c/p\u003e\n\u003cp\u003eCodePen Demo - 그라데이션 테두리 애니메이션\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e그라데이션 색상 변경\u003c/h1\u003e\n\u003cp\u003e위의 기본 기술을 익힌 후에는 그라데이션의 색상을 조정할 수 있습니다. 4가지 색상을 1가지 색상으로 변환할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003ediv\u003c/span\u003e::after {\n    \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e;\n    \u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: absolute;\n    \u003cspan class=\"hljs-attr\"\u003eleft\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%;\n    \u003cspan class=\"hljs-attr\"\u003etop\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%;\n    \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e%;\n    \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e%;\n    background-\u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: #fff;\n    background-\u003cspan class=\"hljs-attr\"\u003erepeat\u003c/span\u003e: no-repeat;\n    background-\u003cspan class=\"hljs-attr\"\u003esize\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e% \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%;\n    background-\u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n    background-\u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e: linear-\u003cspan class=\"hljs-title function_\"\u003egradient\u003c/span\u003e(#\u003cspan class=\"hljs-number\"\u003e399953\u003c/span\u003e, #\u003cspan class=\"hljs-number\"\u003e399953\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이와 같은 그래픽을 얻을 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_12.png\"\u003e\n\u003cp\u003e다시 한 번 함께 돌려보고 단색 추격 테두리 애니메이션이 나옵니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_13.png\"\u003e\n\u003cp\u003eCodePen 데모 - 그라데이션 테두리 애니메이션 2\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e와우, 정말 멋지네요. 그러나 한 줄인 경우 뚜렷한 결함이 있습니다. 즉, 테두리 끝이 작은 삼각형인 대신 수직인 경우가 있습니다. 이는 특정 시나리오에서 적용되지 않거나 PM이 이를 수용하지 않을 수 있습니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_14.png\"\u003e\n\u003cp\u003e이러한 작은 삼각형을 제거할 방법이 있을까요? 네, 아래에서는 clip-path를 사용하여 이러한 작은 삼각형을 제거하는 다른 방법을 소개하겠습니다.\u003c/p\u003e\n\u003ch1\u003e코닉 그래디언트의 스마트한 사용\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리가 clip-path에 대해서 더 이상 진행하기 전에, 우선 각도 그라데이션에 대해 이야기해 봅시다.\u003c/p\u003e\n\u003cp\u003e위에서 언급된 내용은 주로 선형 그라데이션인 linear-gradient에 사용됩니다. 실제로 conic-gradient도 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e한 번 darker style로 conic-gradient을 시도해 보죠. 아래는 핵심 코드입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e.\u003cspan class=\"hljs-property\"\u003econic\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: relative;\n    \n    \u0026#x26;::before {\n        \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e;\n        \u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: absolute;\n        \u003cspan class=\"hljs-attr\"\u003eleft\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%;\n        \u003cspan class=\"hljs-attr\"\u003etop\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%;\n        \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e%;\n        \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e%;\n        \u003cspan class=\"hljs-attr\"\u003ebackground\u003c/span\u003e: conic-\u003cspan class=\"hljs-title function_\"\u003egradient\u003c/span\u003e(transparent, \u003cspan class=\"hljs-title function_\"\u003ergba\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e168\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e239\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), transparent \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e%);\n        \u003cspan class=\"hljs-attr\"\u003eanimation\u003c/span\u003e: rotate 4s linear infinite;\n    }\n}\n@keyframes rotate {\n    \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e% {\n        \u003cspan class=\"hljs-attr\"\u003etransform\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003erotate\u003c/span\u003e(1turn);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음은 렌더링 및 개요도입니다. 부분 각도 그라데이션을 사용하여 그래프를 회전하고, 다른 가상 요소를 사용하여 중간 부분을 마스킹하여 선 부분 만이 노출되도록합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_15.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eCodePen 데모 - 회전 테두리 3\u003c/p\u003e\n\u003ch1\u003e클립 경로의 스마트한 사용\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이전에 친한 친구 clip-path가 다시 나타났습니다. 재미있는 일은 결코 없을 것입니다.\u003c/p\u003e\n\u003cp\u003eclip-path는 좌표점 자체를 애니메이션화하여 하나의 클리핑 모양에서 다른 클리핑 모양으로 변환할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 기능을 사용하여 테두리 따라오는 효과를 잘 구현할 수 있습니다. 의사 코드는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ediv {\n    \u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: relative;\n\n    \u0026#x26;::before {\n        \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e;\n        \u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: absolute;\n        \u003cspan class=\"hljs-attr\"\u003etop\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n        \u003cspan class=\"hljs-attr\"\u003eleft\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n        \u003cspan class=\"hljs-attr\"\u003eright\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n        \u003cspan class=\"hljs-attr\"\u003ebottom\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n        \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: 2px solid gold;\n        \u003cspan class=\"hljs-attr\"\u003eanimation\u003c/span\u003e: clippath 3s infinite linear;\n    }\n}\n\n@keyframes clippath {\n    \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e%,\n    \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e% {\n        clip-\u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003einset\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e95\u003c/span\u003e% \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e% {\n        clip-\u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003einset\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e95\u003c/span\u003e% \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e% {\n        clip-\u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003einset\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e95\u003c/span\u003e% \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e% {\n        clip-\u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003einset\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e95\u003c/span\u003e%);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음은 스키매틱 다이어그램과 함께 렌더링 내용입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_16.png\" alt=\"FantasticCSSborderanimation_16\"\u003e\u003c/p\u003e\n\u003cp\u003eCodePen - 클립 패스 보더 애니메이션\u003c/p\u003e\n\u003cp\u003e여기서는 요소가 클립된다는 점을 감안하고 가상 요소를 사용하여 클리핑 및 애니메이션용 배경으로 사용할 수 있습니다. clip-path를 사용하면 잘려진 보더가 작은 삼각형을 생성하지 않는다는 것을 기억해 주세요. 동시에 이 방법은 둥근 border-radius모서리도 지원합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 다른 가상 요소를 사용하여 실제로 버튼 스타일을 구현한다면 다음과 같은 효과를 얻을 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_17.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eCodePen — clip-path border animation 2\u003c/p\u003e\n\u003ch1\u003eoverflow의 스마트한 활용\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음 트릭은 오버플로우를 사용하여 구현되었습니다. 이러한 테두리 애니메이션을 구현해보세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_18.png\" alt=\"border animation\"\u003e\u003c/p\u003e\n\u003cp\u003e왜 오버플로우로 구현했다고 말하는 건가요?\u003c/p\u003e\n\u003cp\u003e도표를 붙여주세요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_19.png\"\u003e\n\u003cp\u003eCodePen Demo — Using overflow and transform to achieve line hover effect\u003c/p\u003e\n\u003cp\u003eTwo core points:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe use overflow: hiddento hide an entire element that was originally outside the container\u003c/li\u003e\n\u003cli\u003eused transform-origin, controls the center of rotation of the element\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e사실 흥미로운 CSS 효과 대부분이 비슷한 기술을 사용한다는 것을 발견했나요?\u003c/p\u003e\n\u003cp\u003e간단히 말해, 우리가 보는 애니메이션은 원래 현상의 일부에 불과합니다. 특정한 잘라내기, 투명도 변경, 마스크 등을 통해 우리는 결국 원래 현상의 일부만을 보게 됩니다.\u003c/p\u003e\n\u003ch1\u003eBorder-image의 스마트한 활용\u003c/h1\u003e\n\u003cp\u003eborder-image를 사용하여 흥미로운 테두리 애니메이션도 구현할 수 있습니다. border-image에 대해 매우 좋은 설명글이 있습니다 -- border-image의 올바른 사용법, 이 글은 기본 정의에 대해 자세히 설명하지 않습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 이런 그래프가 있다면:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_20.png\"\u003e\n\u003cp\u003e비슷한 테두리 패턴을 얻기 위해 다음과 같이 사용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-css\"\u003e\u003cspan class=\"hljs-selector-tag\"\u003ediv\u003c/span\u003e {\n  \u003cspan class=\"hljs-attribute\"\u003ewidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e200px\u003c/span\u003e;\n  \u003cspan class=\"hljs-attribute\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e120px\u003c/span\u003e;\n  \u003cspan class=\"hljs-attribute\"\u003eborder\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e24px\u003c/span\u003e solid;\n  \u003cspan class=\"hljs-attribute\"\u003eborder-image\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eurl\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003eimage-url\u003c/span\u003e);\n  \u003cspan class=\"hljs-attribute\"\u003eborder-image-slice\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e32\u003c/span\u003e;\n  \u003cspan class=\"hljs-attribute\"\u003eborder-image-repeat\u003c/span\u003e: round;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위와 같이 요소의 높이와 너비를 마음대로 변경할 수 있으므로, 컨테이너 테두리의 크기에 맞춰 확장할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_21.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e코드펜 데모 — border-image 데모\u003c/p\u003e\n\u003cp\u003e그리고, 이 기사인 — border-image를 사용한 SVG 애니메이션 방법 에서도, 매우 멋진 효과를 낼 수 있는 border animation를 설명했었어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위 예제와의 차이점은 우리가 패턴을 움직이게 할 필요가 있다는 점입니다. 즉, 이러한 배경 이미지가 필요합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_22.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e그럼, 우리도 움직이는 테두리 맵을 얻을 수 있습니다. 코드는 정확히 같지만, 테두리가 움직입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_23.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eCodePen 데모 — 춤추는 해골 테두리\u003c/p\u003e\n\u003ch1\u003eborder-image 및 그라데이션\u003c/h1\u003e\n\u003cp\u003eborder-image는 텍스처 참조 url에 추가하여 직접 색상 또는 그라데이션을 채울 수 있습니다.\u003c/p\u003e\n\u003cp\u003eborder-image와 filter, clip-path를 사용하여 그라데이션 변환을 가진 둥근 테두리를 만들 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e.\u003cspan class=\"hljs-property\"\u003eborder\u003c/span\u003e-image-clip-path {\n    \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: 200px;\n    \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: 100px;\n    \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: 10px solid;\n    border-\u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e: linear-\u003cspan class=\"hljs-title function_\"\u003egradient\u003c/span\u003e(45deg, gold, deeppink) \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n    clip-\u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003einset\u003c/span\u003e(0px round 10px);\n    \u003cspan class=\"hljs-attr\"\u003eanimation\u003c/span\u003e: huerotate 6s infinite linear;\n    \u003cspan class=\"hljs-attr\"\u003efilter\u003c/span\u003e: hue-\u003cspan class=\"hljs-title function_\"\u003erotate\u003c/span\u003e(360deg);\n}\n\n@keyframes huerotate {\n    \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e% {\n        \u003cspan class=\"hljs-attr\"\u003efilter\u003c/span\u003e: hue-\u003cspan class=\"hljs-title function_\"\u003erotate\u003c/span\u003e(0deg);\n    }\n    \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e% {\n        \u003cspan class=\"hljs-attr\"\u003efilter\u003c/span\u003e: hue-\u003cspan class=\"hljs-title function_\"\u003erotate\u003c/span\u003e(360deg);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-20-FantasticCSSborderanimation_24.png\"\u003e\n\u003cp\u003e코드펜 데모 - clip-path, border-image 및 필터를 사용하여 둥근 그라데이션 테두리 구현하기\u003c/p\u003e\n\u003ch1\u003e마무리하기\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eiCSS에 좀 더 멋진 CSS 기술 관련 문서들이 요약되어 있어요.\u003c/p\u003e\n\u003cp\u003e그리고 아마도 제 CodePen을 좋아하실 거에요. 여기에는 놀라운 CSS 효과가 많아요.\u003c/p\u003e\n\u003cp\u003e여튼, 이 기사는 여기까지입니다. 도움이 되길 바라요. :)\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-FantasticCSSborderanimation"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>