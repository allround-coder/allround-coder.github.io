<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>React Virtualized로 Masonry 레이아웃 구현하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-ReactVirtualizedMasonry" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="React Virtualized로 Masonry 레이아웃 구현하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="React Virtualized로 Masonry 레이아웃 구현하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-ReactVirtualizedMasonry" data-gatsby-head="true"/><meta name="twitter:title" content="React Virtualized로 Masonry 레이아웃 구현하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 14:51" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">React Virtualized로 Masonry 레이아웃 구현하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="React Virtualized로 Masonry 레이아웃 구현하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-ReactVirtualizedMasonry&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png" alt="React Virtualized Masonry"></p>
<p>웹 개발 분야에서 특히 대규모 데이터셋과 복잡한 레이아웃을 다룰 때는 성능을 유지하면서 부드러운 사용자 경험을 제공하는 것이 중요합니다. 이 균형을 달성하는 강력한 방법 중 하나는 React Virtualized와 Masonry를 함께 사용하는 것입니다. 이 다이내믹한 콤보는 다양한 높이의 항목 그리드를 렌더링하고 관리하는 효율적인 솔루션을 제공하여 가시적인 항목만 렌더링함으로써 최적의 성능을 보장합니다.</p>
<h1>Masonry 사용 이유</h1>
<p>Masonry 컴포넌트 소개</p>
<div class="content-ad"></div>
<p>Masonry 구성 요소는 윈도잉 기술을 사용하여 동적으로 크기가 조정되고 사용자가 위치를 지정한 셀을 효율적으로 표시합니다. 셀의 위치는 삽입된 cellPositioner 속성으로 제어됩니다. 윈도잉은 수직 방향이며, 이 구성 요소는 수평 스크롤을 지원하지 않습니다.</p>
<p>향상된 사용자 경험</p>
<p>인터페이스를 직관적으로 만들어 Masonry는 사용자들의 학습 곡선을 줄입니다. 사용자들이 자연스럽게 요소와 상호 작용할 수 있게 하여 참여도와 만족도를 높입니다.</p>
<p>생산성 향상</p>
<div class="content-ad"></div>
<p>사용자들은 요소를 빠르게 재배열할 수 있어서 더 효율적인 작업 흐름을 이끌어냅니다. 특히 프로젝트 관리 도구나 디자인 소프트웨어와 같이 구성 요소를 자주 재조직해야 하는 애플리케이션에서 특히 유용합니다.</p>
<p>유연성</p>
<p>매소네리는 파일 관리 시스템부터 복잡한 웹 애플리케이션까지 다양한 용례에 적응할 수 있습니다. 다양한 플랫폼에서 일관된 상호작용 모델을 제공합니다.</p>
<p>미적 매력</p>
<div class="content-ad"></div>
<p>현대적이고 세련된 외관으로, Masonry는 응용 프로그램을 시각적으로 매력적으로 만듭니다. 부드러운 전환과 애니메이션은 정교한 사용자 인터페이스를 형성하며 전반적인 사용자 경험을 향상시킵니다.</p>
<h1>Masonry의 주요 기능</h1>
<p>측정 및 레이아웃</p>
<ul>
<li>측정: 처음에 Masonry는 셀MeasurerCache 속성에서 제공된 추정된 셀 크기를 사용하여 배치에서 얼마나 많은 셀을 측정할지 결정합니다.</li>
<li>레이아웃 알고리즘: 빠르고 단순한 레이아웃 알고리즘은 이미지를 순서대로 쌓아 뷰포트가 채워질 때까지 진행됩니다.</li>
<li>캐싱: 모든 측정값은 성능을 위해 캐시되며, keyMapper에서 제공된 키를 사용합니다.</li>
</ul>
<div class="content-ad"></div>
<p>위치 지정 및 캐싱</p>
<ul>
<li>위치 지정: 외부 cellPositioner는 캐싸이즈 측정을 사용하여 셀을 위치시킵니다.</li>
<li>캐싱: 위치 지정기가 반환하는 위치는 Masonry에 의해 빠르게 액세스할 수 있도록 캐시됩니다.</li>
<li>재계산: 사용자가 현재 레이아웃 경계를 벗어나거나 레이아웃이 무효화된 경우, 캐시된 위치를 지우고 recomputeCellPositions() 또는 clearCellPositions()를 사용하여 다시 계산할 수 있습니다.</li>
</ul>
<p>애니메이션 및 레이아웃 제약 조건</p>
<ul>
<li>간단한 애니메이션: 기본 애니메이션으로 사용자 경험을 향상시킵니다.</li>
<li>복잡한 애니메이션: 더 복잡한 애니메이션은 지원되지 않으며, 성능과 간단함에 중점을 두고 있습니다.</li>
<li>다중 열 레이아웃: 각 항목이 고유한 게으르게 측정된 높이를 가질 수 있도록 지원하는 다중 열을 지원합니다.</li>
<li>폭 동일: 열의 모든 항목은 동일한 너비를 가져야 합니다. 항목은 여러 열에 걸칠 수 없습니다.</li>
<li>동기식 측정: 빈번한 레이아웃 무효화를 피하기 위해 셀 측정은 동기적이어야 합니다.</li>
</ul>
<div class="content-ad"></div>
<h1>공용 메소드</h1>
<ul>
<li>clearCellPositions: 내부 위치 캐시를 지우고 강제 업데이트를 수행하여 레이아웃을 무효화하는 데 유용합니다.</li>
<li>recomputeCellPositions: 내부 위치 캐시를 재설정하고 위치를 다시 계산하여 업데이트를 강제하여 레이아웃이 정확하도록합니다.</li>
<li>cellRenderer: 셀의 인덱스를 제공하여 단일 셀을 렌더링하는 데 책임이 있으며 셀이 표시되는 방식에 유연성을 제공합니다.</li>
<li>createMasonryCellPositioner: 간단한 레이아웃을 위한 내장 위치지정자를 제공하여 설정 프로세스를 간소화합니다.</li>
</ul>
<p><img src="/assets/img/2024-06-22-ReactVirtualizedMasonry_1.png" alt="이미지"></p>
<h1>속성 유형</h1>
<div class="content-ad"></div>
<p>React Virtualized Masonry에서 Prop Types는 컴포넌트에서 사용되는 다양한 속성(prop)의 예상 데이터 유형을 정의하고 강제하는 방법입니다. 이들은 올바른 데이터가 컴포넌트로 전달되도록 보장하여 잠재적인 오류를 줄이고 코드 신뢰성을 향상시키는 데 도움이 됩니다.</p>
<p>Prop types에 대한 자세한 정보는 👉 여기에서 찾을 수 있습니다.</p>
<h1>React Virtualized Masonry 구현</h1>
<p>다음은 React Virtualized를 사용하여 Masonry 레이아웃을 만드는 방법을 실제 예제로 보여줍니다. 이 예제는 항목 목록을 만들고 CellMeasurerCache를 사용하여 항목의 크기를 캐시합니다. cellPositioner는 셀을 세 개의 열이 있는 그리드에 배치하는 데 도움을 줍니다. 각 셀은 항목의 이미지와 캡션을 포함하는 CellMeasurer 컴포넌트를 반환하는 cellRenderer 함수를 사용하여 렌더링됩니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> cellPositioner = <span class="hljs-title function_">createMasonry</span>(cellPositionerConfig);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">MasonryComponent</span> = (<span class="hljs-params">{ itemsWithSizes, setRef }</span>) => {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">cellRenderer</span> = (<span class="hljs-params">{ index, key, parent, style }</span>) => {
    <span class="hljs-keyword">const</span> { item, size } = itemsWithSizes[index];
    <span class="hljs-keyword">const</span> height = columnWidth * (size.<span class="hljs-property">height</span> / size.<span class="hljs-property">width</span>) || defaultHeight;

    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">CellMeasurer</span> <span class="hljs-attr">cache</span>=<span class="hljs-string">{cache}</span> <span class="hljs-attr">index</span>=<span class="hljs-string">{index}</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{key}</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">{parent}</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>{item.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
          {item.image &#x26;&#x26; (
            <span class="hljs-tag">&#x3C;<span class="hljs-name">img</span>
              <span class="hljs-attr">src</span>=<span class="hljs-string">{item.image}</span>
              <span class="hljs-attr">alt</span>=<span class="hljs-string">{item.title}</span>
              <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
                <span class="hljs-attr">height:</span> <span class="hljs-attr">height</span>,
                <span class="hljs-attr">width:</span> <span class="hljs-attr">columnWidth</span>,
                <span class="hljs-attr">display:</span> "<span class="hljs-attr">block</span>",
              }}
            /></span>
          )}
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">CellMeasurer</span>></span></span>
    );
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Masonry</span>
      <span class="hljs-attr">cellCount</span>=<span class="hljs-string">{itemsWithSizes.length}</span>
      <span class="hljs-attr">cellMeasurerCache</span>=<span class="hljs-string">{cache}</span>
      <span class="hljs-attr">cellPositioner</span>=<span class="hljs-string">{cellPositioner}</span>
      <span class="hljs-attr">cellRenderer</span>=<span class="hljs-string">{cellRenderer}</span>
      <span class="hljs-attr">height</span>=<span class="hljs-string">{600}</span>
      <span class="hljs-attr">width</span>=<span class="hljs-string">{800}</span>
      <span class="hljs-attr">keyMapper</span>=<span class="hljs-string">{keyMapper}</span>
      <span class="hljs-attr">ref</span>=<span class="hljs-string">{setRef}</span>
    /></span></span>
  );
};
</code></pre>
<p>전체 코드 예제는 👉 codesandbox에서 확인할 수 있습니다.</p>
<img src="https://miro.medium.com/v2/resize:fit:1200/1*Tb6VpBuPf_6Oav1kin8-Og.gif">
<h1>마무리</h1>
<div class="content-ad"></div>
<p>React Virtualized과 Masonry를 결합하면 그리드 내에서 동적 크기의 사용자 위치 지정 셀을 처리하는 효율적인 방법을 제공합니다. 예제 코드는 측정 및 레이아웃 단계가 최적의 성능을 위해 중요함을 강조하며 통합을 보여줍니다. 이 조합은 대규모 데이터셋을 다루는 복잡한 레이아웃을 React 애플리케이션에서 효과적으로 관리하는 견고한 해결책이며 반응성과 부드러운 사용자 경험을 보장합니다.</p>
<p>텔레그램 / 인스타그램 / 페이스북 / 스레드 / 깃허브</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React Virtualized로 Masonry 레이아웃 구현하는 방법","description":"","date":"2024-06-22 14:51","slug":"2024-06-22-ReactVirtualizedMasonry","content":"\n\n\n![React Virtualized Masonry](/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png)\n\n웹 개발 분야에서 특히 대규모 데이터셋과 복잡한 레이아웃을 다룰 때는 성능을 유지하면서 부드러운 사용자 경험을 제공하는 것이 중요합니다. 이 균형을 달성하는 강력한 방법 중 하나는 React Virtualized와 Masonry를 함께 사용하는 것입니다. 이 다이내믹한 콤보는 다양한 높이의 항목 그리드를 렌더링하고 관리하는 효율적인 솔루션을 제공하여 가시적인 항목만 렌더링함으로써 최적의 성능을 보장합니다.\n\n# Masonry 사용 이유\n\nMasonry 컴포넌트 소개\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMasonry 구성 요소는 윈도잉 기술을 사용하여 동적으로 크기가 조정되고 사용자가 위치를 지정한 셀을 효율적으로 표시합니다. 셀의 위치는 삽입된 cellPositioner 속성으로 제어됩니다. 윈도잉은 수직 방향이며, 이 구성 요소는 수평 스크롤을 지원하지 않습니다.\n\n향상된 사용자 경험\n\n인터페이스를 직관적으로 만들어 Masonry는 사용자들의 학습 곡선을 줄입니다. 사용자들이 자연스럽게 요소와 상호 작용할 수 있게 하여 참여도와 만족도를 높입니다.\n\n생산성 향상\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자들은 요소를 빠르게 재배열할 수 있어서 더 효율적인 작업 흐름을 이끌어냅니다. 특히 프로젝트 관리 도구나 디자인 소프트웨어와 같이 구성 요소를 자주 재조직해야 하는 애플리케이션에서 특히 유용합니다.\n\n유연성\n\n매소네리는 파일 관리 시스템부터 복잡한 웹 애플리케이션까지 다양한 용례에 적응할 수 있습니다. 다양한 플랫폼에서 일관된 상호작용 모델을 제공합니다.\n\n미적 매력\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현대적이고 세련된 외관으로, Masonry는 응용 프로그램을 시각적으로 매력적으로 만듭니다. 부드러운 전환과 애니메이션은 정교한 사용자 인터페이스를 형성하며 전반적인 사용자 경험을 향상시킵니다.\n\n# Masonry의 주요 기능\n\n측정 및 레이아웃\n\n- 측정: 처음에 Masonry는 셀MeasurerCache 속성에서 제공된 추정된 셀 크기를 사용하여 배치에서 얼마나 많은 셀을 측정할지 결정합니다.\n- 레이아웃 알고리즘: 빠르고 단순한 레이아웃 알고리즘은 이미지를 순서대로 쌓아 뷰포트가 채워질 때까지 진행됩니다.\n- 캐싱: 모든 측정값은 성능을 위해 캐시되며, keyMapper에서 제공된 키를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위치 지정 및 캐싱\n\n- 위치 지정: 외부 cellPositioner는 캐싸이즈 측정을 사용하여 셀을 위치시킵니다.\n- 캐싱: 위치 지정기가 반환하는 위치는 Masonry에 의해 빠르게 액세스할 수 있도록 캐시됩니다.\n- 재계산: 사용자가 현재 레이아웃 경계를 벗어나거나 레이아웃이 무효화된 경우, 캐시된 위치를 지우고 recomputeCellPositions() 또는 clearCellPositions()를 사용하여 다시 계산할 수 있습니다.\n\n애니메이션 및 레이아웃 제약 조건\n\n- 간단한 애니메이션: 기본 애니메이션으로 사용자 경험을 향상시킵니다.\n- 복잡한 애니메이션: 더 복잡한 애니메이션은 지원되지 않으며, 성능과 간단함에 중점을 두고 있습니다.\n- 다중 열 레이아웃: 각 항목이 고유한 게으르게 측정된 높이를 가질 수 있도록 지원하는 다중 열을 지원합니다.\n- 폭 동일: 열의 모든 항목은 동일한 너비를 가져야 합니다. 항목은 여러 열에 걸칠 수 없습니다.\n- 동기식 측정: 빈번한 레이아웃 무효화를 피하기 위해 셀 측정은 동기적이어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 공용 메소드\n\n- clearCellPositions: 내부 위치 캐시를 지우고 강제 업데이트를 수행하여 레이아웃을 무효화하는 데 유용합니다.\n- recomputeCellPositions: 내부 위치 캐시를 재설정하고 위치를 다시 계산하여 업데이트를 강제하여 레이아웃이 정확하도록합니다.\n- cellRenderer: 셀의 인덱스를 제공하여 단일 셀을 렌더링하는 데 책임이 있으며 셀이 표시되는 방식에 유연성을 제공합니다.\n- createMasonryCellPositioner: 간단한 레이아웃을 위한 내장 위치지정자를 제공하여 설정 프로세스를 간소화합니다.\n\n![이미지](/assets/img/2024-06-22-ReactVirtualizedMasonry_1.png)\n\n# 속성 유형\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact Virtualized Masonry에서 Prop Types는 컴포넌트에서 사용되는 다양한 속성(prop)의 예상 데이터 유형을 정의하고 강제하는 방법입니다. 이들은 올바른 데이터가 컴포넌트로 전달되도록 보장하여 잠재적인 오류를 줄이고 코드 신뢰성을 향상시키는 데 도움이 됩니다.\n\nProp types에 대한 자세한 정보는 👉 여기에서 찾을 수 있습니다.\n\n# React Virtualized Masonry 구현\n\n다음은 React Virtualized를 사용하여 Masonry 레이아웃을 만드는 방법을 실제 예제로 보여줍니다. 이 예제는 항목 목록을 만들고 CellMeasurerCache를 사용하여 항목의 크기를 캐시합니다. cellPositioner는 셀을 세 개의 열이 있는 그리드에 배치하는 데 도움을 줍니다. 각 셀은 항목의 이미지와 캡션을 포함하는 CellMeasurer 컴포넌트를 반환하는 cellRenderer 함수를 사용하여 렌더링됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst cellPositioner = createMasonry(cellPositionerConfig);\n\nconst MasonryComponent = ({ itemsWithSizes, setRef }) =\u003e {\n  const cellRenderer = ({ index, key, parent, style }) =\u003e {\n    const { item, size } = itemsWithSizes[index];\n    const height = columnWidth * (size.height / size.width) || defaultHeight;\n\n    return (\n      \u003cCellMeasurer cache={cache} index={index} key={key} parent={parent}\u003e\n        \u003cdiv style={style}\u003e\n          \u003cdiv\u003e{item.title}\u003c/div\u003e\n          {item.image \u0026\u0026 (\n            \u003cimg\n              src={item.image}\n              alt={item.title}\n              style={{\n                height: height,\n                width: columnWidth,\n                display: \"block\",\n              }}\n            /\u003e\n          )}\n        \u003c/div\u003e\n      \u003c/CellMeasurer\u003e\n    );\n  };\n\n  return (\n    \u003cMasonry\n      cellCount={itemsWithSizes.length}\n      cellMeasurerCache={cache}\n      cellPositioner={cellPositioner}\n      cellRenderer={cellRenderer}\n      height={600}\n      width={800}\n      keyMapper={keyMapper}\n      ref={setRef}\n    /\u003e\n  );\n};\n```\n\n전체 코드 예제는 👉 codesandbox에서 확인할 수 있습니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*Tb6VpBuPf_6Oav1kin8-Og.gif\" /\u003e\n\n# 마무리\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact Virtualized과 Masonry를 결합하면 그리드 내에서 동적 크기의 사용자 위치 지정 셀을 처리하는 효율적인 방법을 제공합니다. 예제 코드는 측정 및 레이아웃 단계가 최적의 성능을 위해 중요함을 강조하며 통합을 보여줍니다. 이 조합은 대규모 데이터셋을 다루는 복잡한 레이아웃을 React 애플리케이션에서 효과적으로 관리하는 견고한 해결책이며 반응성과 부드러운 사용자 경험을 보장합니다.\n\n텔레그램 / 인스타그램 / 페이스북 / 스레드 / 깃허브","ogImage":{"url":"/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png"},"coverImage":"/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-ReactVirtualizedMasonry_0.png\" alt=\"React Virtualized Masonry\"\u003e\u003c/p\u003e\n\u003cp\u003e웹 개발 분야에서 특히 대규모 데이터셋과 복잡한 레이아웃을 다룰 때는 성능을 유지하면서 부드러운 사용자 경험을 제공하는 것이 중요합니다. 이 균형을 달성하는 강력한 방법 중 하나는 React Virtualized와 Masonry를 함께 사용하는 것입니다. 이 다이내믹한 콤보는 다양한 높이의 항목 그리드를 렌더링하고 관리하는 효율적인 솔루션을 제공하여 가시적인 항목만 렌더링함으로써 최적의 성능을 보장합니다.\u003c/p\u003e\n\u003ch1\u003eMasonry 사용 이유\u003c/h1\u003e\n\u003cp\u003eMasonry 컴포넌트 소개\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eMasonry 구성 요소는 윈도잉 기술을 사용하여 동적으로 크기가 조정되고 사용자가 위치를 지정한 셀을 효율적으로 표시합니다. 셀의 위치는 삽입된 cellPositioner 속성으로 제어됩니다. 윈도잉은 수직 방향이며, 이 구성 요소는 수평 스크롤을 지원하지 않습니다.\u003c/p\u003e\n\u003cp\u003e향상된 사용자 경험\u003c/p\u003e\n\u003cp\u003e인터페이스를 직관적으로 만들어 Masonry는 사용자들의 학습 곡선을 줄입니다. 사용자들이 자연스럽게 요소와 상호 작용할 수 있게 하여 참여도와 만족도를 높입니다.\u003c/p\u003e\n\u003cp\u003e생산성 향상\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e사용자들은 요소를 빠르게 재배열할 수 있어서 더 효율적인 작업 흐름을 이끌어냅니다. 특히 프로젝트 관리 도구나 디자인 소프트웨어와 같이 구성 요소를 자주 재조직해야 하는 애플리케이션에서 특히 유용합니다.\u003c/p\u003e\n\u003cp\u003e유연성\u003c/p\u003e\n\u003cp\u003e매소네리는 파일 관리 시스템부터 복잡한 웹 애플리케이션까지 다양한 용례에 적응할 수 있습니다. 다양한 플랫폼에서 일관된 상호작용 모델을 제공합니다.\u003c/p\u003e\n\u003cp\u003e미적 매력\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e현대적이고 세련된 외관으로, Masonry는 응용 프로그램을 시각적으로 매력적으로 만듭니다. 부드러운 전환과 애니메이션은 정교한 사용자 인터페이스를 형성하며 전반적인 사용자 경험을 향상시킵니다.\u003c/p\u003e\n\u003ch1\u003eMasonry의 주요 기능\u003c/h1\u003e\n\u003cp\u003e측정 및 레이아웃\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e측정: 처음에 Masonry는 셀MeasurerCache 속성에서 제공된 추정된 셀 크기를 사용하여 배치에서 얼마나 많은 셀을 측정할지 결정합니다.\u003c/li\u003e\n\u003cli\u003e레이아웃 알고리즘: 빠르고 단순한 레이아웃 알고리즘은 이미지를 순서대로 쌓아 뷰포트가 채워질 때까지 진행됩니다.\u003c/li\u003e\n\u003cli\u003e캐싱: 모든 측정값은 성능을 위해 캐시되며, keyMapper에서 제공된 키를 사용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위치 지정 및 캐싱\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e위치 지정: 외부 cellPositioner는 캐싸이즈 측정을 사용하여 셀을 위치시킵니다.\u003c/li\u003e\n\u003cli\u003e캐싱: 위치 지정기가 반환하는 위치는 Masonry에 의해 빠르게 액세스할 수 있도록 캐시됩니다.\u003c/li\u003e\n\u003cli\u003e재계산: 사용자가 현재 레이아웃 경계를 벗어나거나 레이아웃이 무효화된 경우, 캐시된 위치를 지우고 recomputeCellPositions() 또는 clearCellPositions()를 사용하여 다시 계산할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e애니메이션 및 레이아웃 제약 조건\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e간단한 애니메이션: 기본 애니메이션으로 사용자 경험을 향상시킵니다.\u003c/li\u003e\n\u003cli\u003e복잡한 애니메이션: 더 복잡한 애니메이션은 지원되지 않으며, 성능과 간단함에 중점을 두고 있습니다.\u003c/li\u003e\n\u003cli\u003e다중 열 레이아웃: 각 항목이 고유한 게으르게 측정된 높이를 가질 수 있도록 지원하는 다중 열을 지원합니다.\u003c/li\u003e\n\u003cli\u003e폭 동일: 열의 모든 항목은 동일한 너비를 가져야 합니다. 항목은 여러 열에 걸칠 수 없습니다.\u003c/li\u003e\n\u003cli\u003e동기식 측정: 빈번한 레이아웃 무효화를 피하기 위해 셀 측정은 동기적이어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e공용 메소드\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eclearCellPositions: 내부 위치 캐시를 지우고 강제 업데이트를 수행하여 레이아웃을 무효화하는 데 유용합니다.\u003c/li\u003e\n\u003cli\u003erecomputeCellPositions: 내부 위치 캐시를 재설정하고 위치를 다시 계산하여 업데이트를 강제하여 레이아웃이 정확하도록합니다.\u003c/li\u003e\n\u003cli\u003ecellRenderer: 셀의 인덱스를 제공하여 단일 셀을 렌더링하는 데 책임이 있으며 셀이 표시되는 방식에 유연성을 제공합니다.\u003c/li\u003e\n\u003cli\u003ecreateMasonryCellPositioner: 간단한 레이아웃을 위한 내장 위치지정자를 제공하여 설정 프로세스를 간소화합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-ReactVirtualizedMasonry_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e속성 유형\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eReact Virtualized Masonry에서 Prop Types는 컴포넌트에서 사용되는 다양한 속성(prop)의 예상 데이터 유형을 정의하고 강제하는 방법입니다. 이들은 올바른 데이터가 컴포넌트로 전달되도록 보장하여 잠재적인 오류를 줄이고 코드 신뢰성을 향상시키는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003eProp types에 대한 자세한 정보는 👉 여기에서 찾을 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eReact Virtualized Masonry 구현\u003c/h1\u003e\n\u003cp\u003e다음은 React Virtualized를 사용하여 Masonry 레이아웃을 만드는 방법을 실제 예제로 보여줍니다. 이 예제는 항목 목록을 만들고 CellMeasurerCache를 사용하여 항목의 크기를 캐시합니다. cellPositioner는 셀을 세 개의 열이 있는 그리드에 배치하는 데 도움을 줍니다. 각 셀은 항목의 이미지와 캡션을 포함하는 CellMeasurer 컴포넌트를 반환하는 cellRenderer 함수를 사용하여 렌더링됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e cellPositioner = \u003cspan class=\"hljs-title function_\"\u003ecreateMasonry\u003c/span\u003e(cellPositionerConfig);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMasonryComponent\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ itemsWithSizes, setRef }\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecellRenderer\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ index, key, parent, style }\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { item, size } = itemsWithSizes[index];\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e height = columnWidth * (size.\u003cspan class=\"hljs-property\"\u003eheight\u003c/span\u003e / size.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e) || defaultHeight;\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n      \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eCellMeasurer\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecache\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{cache}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eindex\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{index}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{key}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eparent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{parent}\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{style}\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e{item.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n          {item.image \u0026#x26;\u0026#x26; (\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item.image}\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item.title}\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003eheight:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e,\n                \u003cspan class=\"hljs-attr\"\u003ewidth:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecolumnWidth\u003c/span\u003e,\n                \u003cspan class=\"hljs-attr\"\u003edisplay:\u003c/span\u003e \"\u003cspan class=\"hljs-attr\"\u003eblock\u003c/span\u003e\",\n              }}\n            /\u003e\u003c/span\u003e\n          )}\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eCellMeasurer\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n    );\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMasonry\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ecellCount\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{itemsWithSizes.length}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ecellMeasurerCache\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{cache}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ecellPositioner\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{cellPositioner}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ecellRenderer\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{cellRenderer}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{600}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{800}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ekeyMapper\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{keyMapper}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{setRef}\u003c/span\u003e\n    /\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e전체 코드 예제는 👉 codesandbox에서 확인할 수 있습니다.\u003c/p\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*Tb6VpBuPf_6Oav1kin8-Og.gif\"\u003e\n\u003ch1\u003e마무리\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eReact Virtualized과 Masonry를 결합하면 그리드 내에서 동적 크기의 사용자 위치 지정 셀을 처리하는 효율적인 방법을 제공합니다. 예제 코드는 측정 및 레이아웃 단계가 최적의 성능을 위해 중요함을 강조하며 통합을 보여줍니다. 이 조합은 대규모 데이터셋을 다루는 복잡한 레이아웃을 React 애플리케이션에서 효과적으로 관리하는 견고한 해결책이며 반응성과 부드러운 사용자 경험을 보장합니다.\u003c/p\u003e\n\u003cp\u003e텔레그램 / 인스타그램 / 페이스북 / 스레드 / 깃허브\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-ReactVirtualizedMasonry"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>