<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Angular HttpClient와 Signals를 연결하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Angular HttpClient와 Signals를 연결하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Angular HttpClient와 Signals를 연결하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals" data-gatsby-head="true"/><meta name="twitter:title" content="Angular HttpClient와 Signals를 연결하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 14:04" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Angular HttpClient와 Signals를 연결하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Angular HttpClient와 Signals를 연결하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>Ever since the 18th release and the new upcoming releases of the Angular framework, the entire Angular community has been experiencing significant changes, such as zoneless apps and reduced usage of RxJS in everyday code. It’s essential to consider whether or not to use RxJS carefully. Still, you should understand and use both the main concepts of the reactive mechanisms we have in our applications without neglecting either of them. I recommend using signals for the state and RxJS to manage events and complex logic.</p>
<p>But first, let’s touch on the article’s topic: how we should interact with HttpClient-based services when connecting them with signal-based components. This involves managing the transition from HttpClient’s Observable-based responses to the Signal-based properties used in signal-based components.</p>
<p>Amidst the discussions about using the fetch API instead of HttpClient, I want to reiterate my advice: it’s not necessary to drop HttpClient. It offers useful out-of-the-box features that we can benefit from. Remember, we have the tools to handle the Observable-to-Signal bridge without any issues.</p>
<div class="content-ad"></div>
<h2>RxJS 직접 구독</h2>
<p>가장 직접적이고 명확한 방법은 구독을 사용하는 것입니다. HTTP 호출은 한 번만 값을 반환하는 Observable이기 때문에 구독을 해제하는 것에 대해 크게 걱정할 필요가 없습니다. 또한 RxJS 오류 처리 방식을 활용할 수 있습니다(pipe 내에서 또는 오류 콜백을 통해). 가장 명확하면서도 가장 쉬운 방식으로 상황을 처리하는 방법입니다.</p>
<pre><code class="hljs language-js">public data = signal&#x3C;number[]>([])
....
<span class="hljs-title function_">constructor</span>(<span class="hljs-params">private testService: TestService</span>) {}
....
public <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">testService</span>.<span class="hljs-title function_">getItems</span>().<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">items</span>) =></span> {
    <span class="hljs-comment">// 시그널 덮어쓰기/생성</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-title function_">signal</span>(items);
    <span class="hljs-comment">// 또는 값 직접 설정</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-title function_">set</span>(items);
  });
}
</code></pre>
<h2>Promises 활용하기</h2>
<div class="content-ad"></div>
<p>두 번째 방법은 프로미스를 활용하는 것입니다. 표준 then/catch 또는 async/await을 사용할 수 있습니다. 이것은 조금 까다로울 수도 있습니다, 특히 async/await의 구체적인 내용을 잊게 되었거나 모르는 경우입니다. RxJS의 firstValueFrom 함수를 사용하여 첫 번째 발행된 값을 observable로 변환할 수 있습니다(일반적으로 API 응답은 한 가지 값이기 때문에 잘 맞습니다). 여기에는 두 가지 주의해야 할 점이 있습니다:</p>
<ul>
<li>async/await 구문을 사용하면 프로미스가 값을 반환하거나 오류가 발생할 때까지 함수 실행이 중지된다는 것을 유의해야 합니다. 따라서 코드의 나머지 부분은 여전히 실행을 기다리고 있게 됩니다. 따라서 async/await 함정에 빠지지 않도록 주의하십시오.</li>
<li>또한 firstValueFrom은 즉시 observable 소스에 구독을 시작합니다. 이것이 문제가 될 수는 없지만, 게으르게 시작하려면 잘 작동하지 않을 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js">public <span class="hljs-keyword">async</span> <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// observable 소스를 즉시 구독합니다</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-title function_">signal</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">firstValueFrom</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">testService</span>.<span class="hljs-title function_">getItems</span>()));
  <span class="hljs-comment">// 주의! 이 코드는 서비스가 값을 반환할 때까지 실행되지 않음</span>
</code></pre>
<p>코드 실행을 중지하지 않으려면 전용 함수 래퍼를 사용할 수 있습니다. 다른 방법은 IIFE를 사용하는 것입니다. 이 방법이 더 일관된 것으로 생각될 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">public <span class="hljs-keyword">async</span> <span class="hljs-title function_">initData</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-title function_">signal</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">firstValueFrom</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">testService</span>.<span class="hljs-title function_">getItems</span>()));
}

public <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {   
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initData</span>();
  ....
}
</code></pre>
<pre><code class="hljs language-js">public <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {    
  (<span class="hljs-keyword">async</span> () => {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-title function_">signal</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">firstValueFrom</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">testService</span>.<span class="hljs-title function_">getItems</span>()));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'data inited'</span>);
  })();
  ....
}
</code></pre>
<p>다른 방법은 old-faithful then을 사용하는 것입니다. 위의 모든 프로미스 케이스에서 then 콜백 실행을 마이크로태스크로 생각할 때, 그것은 자체적인 특징이 있으며 어떤 경우에는 예측할 수 없는 결과를 줄 수 있음을 잊지 마세요.</p>
<pre><code class="hljs language-js">public <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {   
  <span class="hljs-title function_">firstValueFrom</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">testService</span>.<span class="hljs-title function_">getItems</span>()).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">items</span>) =></span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-title function_">signal</span>(items);
  });
}
</code></pre>
<div class="content-ad"></div>
<h2>rxjs-interop을 사용하여 toSignal을 활용해보세요</h2>
<p>rxjs-interop은 우리에게 세 번째 방법을 제공했는데, 그것은 toSignal이라고 불립니다. 간단히 말하면, 이 함수는 소스 observable을 구독하고 모든 값을 signal로 보냅니다. 그러나 HttpClient 응답을 signal로 변환하는 가장 tricky한 방법 중 하나입니다. 그래서 이러한 사항들을 주의해야 합니다:</p>
<ul>
<li>주목할 점 중 하나는 firstValueFrom과 유사하게, toSignal은 실행 시 즉시 구독합니다.</li>
<li>default 값을 제공하지 않으면 처음 값 (undefined)을 즉시 발행합니다.</li>
<li>API 호출을 라이프사이클 훅이나 컴포넌트 클래스 메소드 어딘가에서 수행하는 경우 'Error: NG0203: toSignal() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext’' 라는 오류가 발생할 수 있습니다. 이를 극복하기 위해 injector를 주입하고 제공하거나 runInInjectionContext를 사용해야 합니다.</li>
<li>읽기 전용 signal을 제공합니다. 따라서 나중에 signal과 상호작용하려면 (설정/업데이트) 여기서 장애물을 처리해야 합니다.</li>
</ul>
<pre><code class="hljs language-js">private _injector = <span class="hljs-title function_">inject</span>(<span class="hljs-title class_">Injector</span>);

public <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-title function_">toSignal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">testService</span>.<span class="hljs-title function_">getItems</span>(), {
    <span class="hljs-comment">// injector에 대한 참조 제공</span>
    <span class="hljs-attr">injector</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">_injector</span>,
    <span class="hljs-comment">// default 값을 제공</span>
    <span class="hljs-attr">initialValue</span>: [],
  });

  <span class="hljs-comment">// 또는 runInInjectionContext를 사용</span>
  <span class="hljs-title function_">runInInjectionContext</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_injector</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-title function_">toSignal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">testService</span>.<span class="hljs-title function_">getItems</span>(), {
      <span class="hljs-attr">initialValue</span>: [],
    });
  });
  ....
}
</code></pre>
<div class="content-ad"></div>
<h2>결론:</h2>
<p>현재, 표준 observable 구독을 사용하는 것이 가능한 처리하기 쉬운 변형으로 보입니다. 가능한 함정과 어려움에서 보호해 줄 것입니다. 프로미스를 사용하는 것도 편리할 수 있지만, 당신과 팀원들은 async/await 및 다른 프로미스의 구체적인 부분을 알고 있어야 합니다. toSignal을 사용하는 것이 가장 번거로워 보입니다.</p>
<p>유용한 링크:
<a href="https://angular.dev/guide/signals" rel="nofollow" target="_blank">https://angular.dev/guide/signals</a>
<a href="https://angular.dev/guide/di/dependency-injection-context#run-within-an-injection-context" rel="nofollow" target="_blank">https://angular.dev/guide/di/dependency-injection-context#run-within-an-injection-context</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Angular HttpClient와 Signals를 연결하는 방법","description":"","date":"2024-06-23 14:04","slug":"2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals","content":"\n\nEver since the 18th release and the new upcoming releases of the Angular framework, the entire Angular community has been experiencing significant changes, such as zoneless apps and reduced usage of RxJS in everyday code. It’s essential to consider whether or not to use RxJS carefully. Still, you should understand and use both the main concepts of the reactive mechanisms we have in our applications without neglecting either of them. I recommend using signals for the state and RxJS to manage events and complex logic.\n\nBut first, let’s touch on the article’s topic: how we should interact with HttpClient-based services when connecting them with signal-based components. This involves managing the transition from HttpClient’s Observable-based responses to the Signal-based properties used in signal-based components.\n\nAmidst the discussions about using the fetch API instead of HttpClient, I want to reiterate my advice: it’s not necessary to drop HttpClient. It offers useful out-of-the-box features that we can benefit from. Remember, we have the tools to handle the Observable-to-Signal bridge without any issues.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## RxJS 직접 구독\n\n가장 직접적이고 명확한 방법은 구독을 사용하는 것입니다. HTTP 호출은 한 번만 값을 반환하는 Observable이기 때문에 구독을 해제하는 것에 대해 크게 걱정할 필요가 없습니다. 또한 RxJS 오류 처리 방식을 활용할 수 있습니다(pipe 내에서 또는 오류 콜백을 통해). 가장 명확하면서도 가장 쉬운 방식으로 상황을 처리하는 방법입니다.\n\n```js\npublic data = signal\u003cnumber[]\u003e([])\n....\nconstructor(private testService: TestService) {}\n....\npublic ngOnInit() {\n  this.testService.getItems().subscribe((items) =\u003e {\n    // 시그널 덮어쓰기/생성\n    this.data = signal(items);\n    // 또는 값 직접 설정\n    this.data.set(items);\n  });\n}\n```\n\n## Promises 활용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 번째 방법은 프로미스를 활용하는 것입니다. 표준 then/catch 또는 async/await을 사용할 수 있습니다. 이것은 조금 까다로울 수도 있습니다, 특히 async/await의 구체적인 내용을 잊게 되었거나 모르는 경우입니다. RxJS의 firstValueFrom 함수를 사용하여 첫 번째 발행된 값을 observable로 변환할 수 있습니다(일반적으로 API 응답은 한 가지 값이기 때문에 잘 맞습니다). 여기에는 두 가지 주의해야 할 점이 있습니다:\n\n- async/await 구문을 사용하면 프로미스가 값을 반환하거나 오류가 발생할 때까지 함수 실행이 중지된다는 것을 유의해야 합니다. 따라서 코드의 나머지 부분은 여전히 실행을 기다리고 있게 됩니다. 따라서 async/await 함정에 빠지지 않도록 주의하십시오.\n- 또한 firstValueFrom은 즉시 observable 소스에 구독을 시작합니다. 이것이 문제가 될 수는 없지만, 게으르게 시작하려면 잘 작동하지 않을 수 있습니다.\n\n```js\npublic async ngOnInit() {\n  // observable 소스를 즉시 구독합니다\n  this.data = signal(await firstValueFrom(this.testService.getItems()));\n  // 주의! 이 코드는 서비스가 값을 반환할 때까지 실행되지 않음\n```\n\n코드 실행을 중지하지 않으려면 전용 함수 래퍼를 사용할 수 있습니다. 다른 방법은 IIFE를 사용하는 것입니다. 이 방법이 더 일관된 것으로 생각될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\npublic async initData() {\n  this.data = signal(await firstValueFrom(this.testService.getItems()));\n}\n\npublic ngOnInit() {   \n  this.initData();\n  ....\n}\n```\n\n```js\npublic ngOnInit() {    \n  (async () =\u003e {\n    this.data = signal(await firstValueFrom(this.testService.getItems()));\n    console.log('data inited');\n  })();\n  ....\n}\n```\n\n다른 방법은 old-faithful then을 사용하는 것입니다. 위의 모든 프로미스 케이스에서 then 콜백 실행을 마이크로태스크로 생각할 때, 그것은 자체적인 특징이 있으며 어떤 경우에는 예측할 수 없는 결과를 줄 수 있음을 잊지 마세요.\n\n```js\npublic ngOnInit() {   \n  firstValueFrom(this.testService.getItems()).then((items) =\u003e {\n    this.data = signal(items);\n  });\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## rxjs-interop을 사용하여 toSignal을 활용해보세요\n\nrxjs-interop은 우리에게 세 번째 방법을 제공했는데, 그것은 toSignal이라고 불립니다. 간단히 말하면, 이 함수는 소스 observable을 구독하고 모든 값을 signal로 보냅니다. 그러나 HttpClient 응답을 signal로 변환하는 가장 tricky한 방법 중 하나입니다. 그래서 이러한 사항들을 주의해야 합니다:\n\n- 주목할 점 중 하나는 firstValueFrom과 유사하게, toSignal은 실행 시 즉시 구독합니다.\n- default 값을 제공하지 않으면 처음 값 (undefined)을 즉시 발행합니다.\n- API 호출을 라이프사이클 훅이나 컴포넌트 클래스 메소드 어딘가에서 수행하는 경우 'Error: NG0203: toSignal() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext’' 라는 오류가 발생할 수 있습니다. 이를 극복하기 위해 injector를 주입하고 제공하거나 runInInjectionContext를 사용해야 합니다.\n- 읽기 전용 signal을 제공합니다. 따라서 나중에 signal과 상호작용하려면 (설정/업데이트) 여기서 장애물을 처리해야 합니다.\n\n```js\nprivate _injector = inject(Injector);\n\npublic ngOnInit() {  \n  this.data = toSignal(this.testService.getItems(), {\n    // injector에 대한 참조 제공\n    injector: this._injector,\n    // default 값을 제공\n    initialValue: [],\n  });\n\n  // 또는 runInInjectionContext를 사용\n  runInInjectionContext(this._injector, () =\u003e {\n    toSignal(this.testService.getItems(), {\n      initialValue: [],\n    });\n  });\n  ....\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론:\n\n현재, 표준 observable 구독을 사용하는 것이 가능한 처리하기 쉬운 변형으로 보입니다. 가능한 함정과 어려움에서 보호해 줄 것입니다. 프로미스를 사용하는 것도 편리할 수 있지만, 당신과 팀원들은 async/await 및 다른 프로미스의 구체적인 부분을 알고 있어야 합니다. toSignal을 사용하는 것이 가장 번거로워 보입니다.\n\n유용한 링크:\nhttps://angular.dev/guide/signals\nhttps://angular.dev/guide/di/dependency-injection-context#run-within-an-injection-context","ogImage":{"url":"/assets/img/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals_0.png"},"coverImage":"/assets/img/2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003eEver since the 18th release and the new upcoming releases of the Angular framework, the entire Angular community has been experiencing significant changes, such as zoneless apps and reduced usage of RxJS in everyday code. It’s essential to consider whether or not to use RxJS carefully. Still, you should understand and use both the main concepts of the reactive mechanisms we have in our applications without neglecting either of them. I recommend using signals for the state and RxJS to manage events and complex logic.\u003c/p\u003e\n\u003cp\u003eBut first, let’s touch on the article’s topic: how we should interact with HttpClient-based services when connecting them with signal-based components. This involves managing the transition from HttpClient’s Observable-based responses to the Signal-based properties used in signal-based components.\u003c/p\u003e\n\u003cp\u003eAmidst the discussions about using the fetch API instead of HttpClient, I want to reiterate my advice: it’s not necessary to drop HttpClient. It offers useful out-of-the-box features that we can benefit from. Remember, we have the tools to handle the Observable-to-Signal bridge without any issues.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003eRxJS 직접 구독\u003c/h2\u003e\n\u003cp\u003e가장 직접적이고 명확한 방법은 구독을 사용하는 것입니다. HTTP 호출은 한 번만 값을 반환하는 Observable이기 때문에 구독을 해제하는 것에 대해 크게 걱정할 필요가 없습니다. 또한 RxJS 오류 처리 방식을 활용할 수 있습니다(pipe 내에서 또는 오류 콜백을 통해). 가장 명확하면서도 가장 쉬운 방식으로 상황을 처리하는 방법입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic data = signal\u0026#x3C;number[]\u003e([])\n....\n\u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate testService: TestService\u003c/span\u003e) {}\n....\npublic \u003cspan class=\"hljs-title function_\"\u003engOnInit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etestService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetItems\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eitems\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 시그널 덮어쓰기/생성\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003esignal\u003c/span\u003e(items);\n    \u003cspan class=\"hljs-comment\"\u003e// 또는 값 직접 설정\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(items);\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003ePromises 활용하기\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e두 번째 방법은 프로미스를 활용하는 것입니다. 표준 then/catch 또는 async/await을 사용할 수 있습니다. 이것은 조금 까다로울 수도 있습니다, 특히 async/await의 구체적인 내용을 잊게 되었거나 모르는 경우입니다. RxJS의 firstValueFrom 함수를 사용하여 첫 번째 발행된 값을 observable로 변환할 수 있습니다(일반적으로 API 응답은 한 가지 값이기 때문에 잘 맞습니다). 여기에는 두 가지 주의해야 할 점이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003easync/await 구문을 사용하면 프로미스가 값을 반환하거나 오류가 발생할 때까지 함수 실행이 중지된다는 것을 유의해야 합니다. 따라서 코드의 나머지 부분은 여전히 실행을 기다리고 있게 됩니다. 따라서 async/await 함정에 빠지지 않도록 주의하십시오.\u003c/li\u003e\n\u003cli\u003e또한 firstValueFrom은 즉시 observable 소스에 구독을 시작합니다. 이것이 문제가 될 수는 없지만, 게으르게 시작하려면 잘 작동하지 않을 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003engOnInit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// observable 소스를 즉시 구독합니다\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003esignal\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efirstValueFrom\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etestService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetItems\u003c/span\u003e()));\n  \u003cspan class=\"hljs-comment\"\u003e// 주의! 이 코드는 서비스가 값을 반환할 때까지 실행되지 않음\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e코드 실행을 중지하지 않으려면 전용 함수 래퍼를 사용할 수 있습니다. 다른 방법은 IIFE를 사용하는 것입니다. 이 방법이 더 일관된 것으로 생각될 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003esignal\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efirstValueFrom\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etestService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetItems\u003c/span\u003e()));\n}\n\npublic \u003cspan class=\"hljs-title function_\"\u003engOnInit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {   \n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitData\u003c/span\u003e();\n  ....\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic \u003cspan class=\"hljs-title function_\"\u003engOnInit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {    \n  (\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003esignal\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efirstValueFrom\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etestService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetItems\u003c/span\u003e()));\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'data inited'\u003c/span\u003e);\n  })();\n  ....\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 방법은 old-faithful then을 사용하는 것입니다. 위의 모든 프로미스 케이스에서 then 콜백 실행을 마이크로태스크로 생각할 때, 그것은 자체적인 특징이 있으며 어떤 경우에는 예측할 수 없는 결과를 줄 수 있음을 잊지 마세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epublic \u003cspan class=\"hljs-title function_\"\u003engOnInit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {   \n  \u003cspan class=\"hljs-title function_\"\u003efirstValueFrom\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etestService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetItems\u003c/span\u003e()).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eitems\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003esignal\u003c/span\u003e(items);\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003erxjs-interop을 사용하여 toSignal을 활용해보세요\u003c/h2\u003e\n\u003cp\u003erxjs-interop은 우리에게 세 번째 방법을 제공했는데, 그것은 toSignal이라고 불립니다. 간단히 말하면, 이 함수는 소스 observable을 구독하고 모든 값을 signal로 보냅니다. 그러나 HttpClient 응답을 signal로 변환하는 가장 tricky한 방법 중 하나입니다. 그래서 이러한 사항들을 주의해야 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e주목할 점 중 하나는 firstValueFrom과 유사하게, toSignal은 실행 시 즉시 구독합니다.\u003c/li\u003e\n\u003cli\u003edefault 값을 제공하지 않으면 처음 값 (undefined)을 즉시 발행합니다.\u003c/li\u003e\n\u003cli\u003eAPI 호출을 라이프사이클 훅이나 컴포넌트 클래스 메소드 어딘가에서 수행하는 경우 'Error: NG0203: toSignal() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext’' 라는 오류가 발생할 수 있습니다. 이를 극복하기 위해 injector를 주입하고 제공하거나 runInInjectionContext를 사용해야 합니다.\u003c/li\u003e\n\u003cli\u003e읽기 전용 signal을 제공합니다. 따라서 나중에 signal과 상호작용하려면 (설정/업데이트) 여기서 장애물을 처리해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate _injector = \u003cspan class=\"hljs-title function_\"\u003einject\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eInjector\u003c/span\u003e);\n\npublic \u003cspan class=\"hljs-title function_\"\u003engOnInit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {  \n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003etoSignal\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etestService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetItems\u003c/span\u003e(), {\n    \u003cspan class=\"hljs-comment\"\u003e// injector에 대한 참조 제공\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003einjector\u003c/span\u003e: \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_injector\u003c/span\u003e,\n    \u003cspan class=\"hljs-comment\"\u003e// default 값을 제공\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003einitialValue\u003c/span\u003e: [],\n  });\n\n  \u003cspan class=\"hljs-comment\"\u003e// 또는 runInInjectionContext를 사용\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003erunInInjectionContext\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_injector\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003etoSignal\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etestService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetItems\u003c/span\u003e(), {\n      \u003cspan class=\"hljs-attr\"\u003einitialValue\u003c/span\u003e: [],\n    });\n  });\n  ....\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e결론:\u003c/h2\u003e\n\u003cp\u003e현재, 표준 observable 구독을 사용하는 것이 가능한 처리하기 쉬운 변형으로 보입니다. 가능한 함정과 어려움에서 보호해 줄 것입니다. 프로미스를 사용하는 것도 편리할 수 있지만, 당신과 팀원들은 async/await 및 다른 프로미스의 구체적인 부분을 알고 있어야 합니다. toSignal을 사용하는 것이 가장 번거로워 보입니다.\u003c/p\u003e\n\u003cp\u003e유용한 링크:\n\u003ca href=\"https://angular.dev/guide/signals\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.dev/guide/signals\u003c/a\u003e\n\u003ca href=\"https://angular.dev/guide/di/dependency-injection-context#run-within-an-injection-context\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.dev/guide/di/dependency-injection-context#run-within-an-injection-context\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-AngularmakingbridgesbetweenHttpClientandSignals"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>