<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nextjs에서 이미지 로딩을 흐릿하게 만들기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-MakeYourImageLoadingBlurryinNextjs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nextjs에서 이미지 로딩을 흐릿하게 만들기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Nextjs에서 이미지 로딩을 흐릿하게 만들기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-MakeYourImageLoadingBlurryinNextjs_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-MakeYourImageLoadingBlurryinNextjs" data-gatsby-head="true"/><meta name="twitter:title" content="Nextjs에서 이미지 로딩을 흐릿하게 만들기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-MakeYourImageLoadingBlurryinNextjs_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 20:06" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_buildManifest.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nextjs에서 이미지 로딩을 흐릿하게 만들기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nextjs에서 이미지 로딩을 흐릿하게 만들기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-MakeYourImageLoadingBlurryinNextjs&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>웹 이미지는 사이트 성능 측면에서 중요하며 솔직히 말하자면 번거로운 부분이기도 합니다. Next.js의 최고의 기능 중 하나는 이미지 컴포넌트로, 이미지를 최적화해 줍니다. 이 컴포넌트는 화면 크기에 맞춰 WebP와 같은 현대적인 포맷의 이미지를 자동으로 생성하여 이미지 크기를 줄여줍니다. 또한 이미지가 뷰포트에 진입할 때 이미지를 불러오는 lazy loading과 레이아웃 이동을 방지하는 시각적 안정성이 구현되어 있습니다. 만약 이미지 컴포넌트에 익숙하지 않다면 Lee Robinson의 이 비디오를 추천합니다. 이 글에서는 실제 이미지가 로드되는 동안 흐린 이미지를 추가하는 것에 초점을 맞추고자 합니다.</p>
<h2>이미지 컴포넌트의 기본 이미지 흐림</h2>
<p>이미지 컴포넌트에는 한 가지 제한이 있지만, 기본 옵션으로 이미지를 흐리게 만들어 줄 수도 있습니다! 제 포트폴리오 웹사이트에서 한 예시를 보여드리겠습니다.</p>
<p>기본 로딩보다 훨씬 나아요. 앞서 언급한 대로 한 가지 제한이 있습니다: 이미지를 정적으로 가져와야 합니다. 특히 이미지 동적 또는 클라우드 서비스를 사용하는 경우에는 이미지를 정적으로 가져오는 것이 불가능할 수 있습니다. 이 제한을 다음 기술에서 극복하겠지만, 지금은 이 기본 흐린 이미지를 가능하게 하는 코드를 살펴보도록 하죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> furkanpicture <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/public/pics/furkan.png&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;next/image&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">AboutImage</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Image</span>
        <span class="hljs-attr">src</span>=<span class="hljs-string">{furkanpicture}</span>
        <span class="hljs-attr">alt</span>=<span class="hljs-string">{</span>&quot;<span class="hljs-attr">Furkan</span> <span class="hljs-attr">Cengiz</span>&quot;}
        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;blur&quot;</span> //<span class="hljs-attr">기본값은</span> &quot;<span class="hljs-attr">empty</span>&quot;<span class="hljs-attr">입니다</span>
      /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span></span>
  );
}
</code></pre>
<p>placeholder prop을 blur로 전달하고 src prop을 정적으로 가져온 이미지 개체로 전달할 때 Image 컴포넌트는 비디오에서 보는 것처럼 흐린 이미지를 생성합니다! 정적 페이지나 웹사이트를 구축 중이라면 기본적인 블러 동작을 활용할 수 있습니다!</p>
<h2>Plaiceholder를 사용하여 dataURL 생성하기</h2>
<p>정적 이미지를 사용하는 경우 로딩 상태에 대한 흐린 이미지를 추가할 수 있습니다. 이제 이전 방법의 한계를 극복해야 합니다.</p>
<pre><code>


문서에 따르면 동적 이미지를 위해 Image 컴포넌트의 blurDataUrl 속성에 dataURL을 전달해야 합니다. dataURL은 기본적으로 base64 형식으로 흐린 이미지 데이터를 보유하는 문자열입니다.

```js
dataURL 예시
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAYAAAB/qH1jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAJ0lEQVR4nGPY2fXjv458/H9Bbtf/IDbD/7v//8/Mvfq/J+nEfxAbAF3NFsFiuaE1AAAAAElFTkSuQmCC
</code></pre>
<p>우리는 이제 무엇이 필요한지 알았지만, 이렇게 데이터URL을 생성하는 방법이 무엇인지 궁금할 것입니다. 문서에서 제안한대로, plaiceholder는 이를 가능하게 해줍니다!</p>
<p>우선, sharp와 plaiceholder 두 가지 패키지를 설치해야 합니다. 설치 방법은 이 페이지를 참고해주세요.</p>
<p>Next.js를 사용하고 있다고 가정합니다. 다음 페이지를 따라서 next.config.ts 또는 next.config.mjs 파일을 구성해 주세요.</p>
<p>설치가 완료되었습니다! 이제 서버 측에서 실행되는 사용자 정의 함수를 구현해야 합니다. 이 함수는 우리가 필요한 데이터URL을 생성합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;node:fs/promises&quot;</span>;
<span class="hljs-keyword">import</span> { getPlaiceholder } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;plaiceholder&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getBase64</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">imgPath: string</span>) =&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> file = <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">`public/<span class="hljs-subst">${imgPath}</span>`</span>)
    <span class="hljs-keyword">const</span> { base64 } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getPlaiceholder</span>(file)
    <span class="hljs-keyword">return</span> base64
  } <span class="hljs-keyword">catch</span> (<span class="hljs-attr">error</span>: unknown) {
    <span class="hljs-comment">// 에러 처리</span>
    <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>) <span class="hljs-keyword">return</span> error.<span class="hljs-property">message</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error &amp;&amp; <span class="hljs-keyword">typeof</span> error === <span class="hljs-string">&quot;object&quot;</span> &amp;&amp; <span class="hljs-string">&quot;message&quot;</span> <span class="hljs-keyword">in</span> error)
      <span class="hljs-keyword">return</span> error.<span class="hljs-property">message</span> <span class="hljs-keyword">as</span> string
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> error === <span class="hljs-string">&quot;string&quot;</span>) <span class="hljs-keyword">return</span> error;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;예기치 않은 오류 발생!&quot;</span>
  }
}
</code></pre>
<p>저는 문서에서처럼 then 또는 catch 메서드 대신 async-await 키워드를 사용하여 구현했습니다. getPlaiceholder 함수가 필요한 파일을 읽어야 합니다. 파일 경로에 &quot;public&quot; 접두사를 추가했습니다. 그런 다음 파일을 getPlaiceholder 함수에 전달했습니다. 이 함수는 css, color, pixels, base64 등과 같은 여러 객체를 반환합니다. 반환된 객체를 비구조화하여 base64 값을 추출하고 반환하세요!</p>
<p>필요한 데이터URL을 생성하는 함수가 완성되었습니다. 이제 중요한 마지막 단계가 나왔어요!</p>
<h2>getBase64 함수 사용하기</h2>
<p>함수에서 node<div></div>/promises를 가져오는 함수를 통해 파일을 읽었음을 알 수 있어요. 이는 이 함수가 노드 환경에서만 실행될 수 있다는 뜻이에요. 그러므로, 클라이언트 구성 요소에서 이 함수를 사용할 수는 없다는 점을 명심하는 것이 중요해요. 그치만 걱정할 필요는 아직 없어요. 왜냐하면 서버 구성 요소는 있거든요. 클라이언트 구성 요소에서 이 함수를 사용할 수 없더라도, 여전히 서버 구성 요소에서 이 async 함수를 호출하고 반환된 값을 클라이언트 구성 요소로 전달할 수 있어요.</p>
<p>저의 포트폴리오 프로젝트에서 예제를 확인할 수 있어요. (이미 서버 구성 요소에서 이미지 구성 요소를 사용 중이라면, 이 마지막 단계는 필요하지 않아요. 클라이언트 구성 요소에 base64 문자열을 blurDataUrl 속성에 전달하려면 단순히 구성 요소를 async로 만들고 함수를 호출하면 됩니다.)</p>
<p>위의 코드에서 여러 개의 base64 문자열을 생성하고 각각의 클라이언트 컴포넌트로 전달하고 있어요. (개별 이미지의 경로 문자열을 getBase64 함수에 전달하고 기다리면 단일 base64 문자열을 생성할 수 있어요)</p>
<p>그래서 지금 우리는 흐린 이미지를 준비했어요!</p>
<p>마지막으로, 플레이스홀더를 사용하여 SVG 및 색상과 같은 다른 기술을 활용할 수 있습니다. 그 외에도 시도해 볼 수 있는 기술이 많으니 플레이스홀더의 데모를 방문해 모든 기술을 확인해보세요.</p>
<p>로딩 상태에서 흐릿한 이미지는 정말 좋아하는 기술입니다. 많은 웹사이트와 심지어 Discord와 같은 Windows 애플리케이션이 사용하는 기술인데, 우아함의 요소를 더해준다고 생각합니다. 이 기사가 도움이 되었으면 좋겠어요. 제 최신 작업 소식을 받아보려면 Medium이나 LinkedIn에서 팔로우해주세요. 다음 글에서 뵙길 기대하겠습니다!</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nextjs에서 이미지 로딩을 흐릿하게 만들기","description":"","date":"2024-05-12 20:06","slug":"2024-05-12-MakeYourImageLoadingBlurryinNextjs","content":"\n\n웹 이미지는 사이트 성능 측면에서 중요하며 솔직히 말하자면 번거로운 부분이기도 합니다. Next.js의 최고의 기능 중 하나는 이미지 컴포넌트로, 이미지를 최적화해 줍니다. 이 컴포넌트는 화면 크기에 맞춰 WebP와 같은 현대적인 포맷의 이미지를 자동으로 생성하여 이미지 크기를 줄여줍니다. 또한 이미지가 뷰포트에 진입할 때 이미지를 불러오는 lazy loading과 레이아웃 이동을 방지하는 시각적 안정성이 구현되어 있습니다. 만약 이미지 컴포넌트에 익숙하지 않다면 Lee Robinson의 이 비디오를 추천합니다. 이 글에서는 실제 이미지가 로드되는 동안 흐린 이미지를 추가하는 것에 초점을 맞추고자 합니다.\n\n## 이미지 컴포넌트의 기본 이미지 흐림\n\n이미지 컴포넌트에는 한 가지 제한이 있지만, 기본 옵션으로 이미지를 흐리게 만들어 줄 수도 있습니다! 제 포트폴리오 웹사이트에서 한 예시를 보여드리겠습니다.\n\n기본 로딩보다 훨씬 나아요. 앞서 언급한 대로 한 가지 제한이 있습니다: 이미지를 정적으로 가져와야 합니다. 특히 이미지 동적 또는 클라우드 서비스를 사용하는 경우에는 이미지를 정적으로 가져오는 것이 불가능할 수 있습니다. 이 제한을 다음 기술에서 극복하겠지만, 지금은 이 기본 흐린 이미지를 가능하게 하는 코드를 살펴보도록 하죠.\n\n\n\n```js\nimport furkanpicture from \"@/public/pics/furkan.png\";\nimport Image from \"next/image\";\nimport React from \"react\";\n\nexport default function AboutImage() {\n  return (\n    \u003cfigure\u003e\n      \u003cImage\n        src={furkanpicture}\n        alt={\"Furkan Cengiz\"}\n        placeholder=\"blur\" //기본값은 \"empty\"입니다\n      /\u003e\n    \u003c/figure\u003e\n  );\n}\n```\n\nplaceholder prop을 blur로 전달하고 src prop을 정적으로 가져온 이미지 개체로 전달할 때 Image 컴포넌트는 비디오에서 보는 것처럼 흐린 이미지를 생성합니다! 정적 페이지나 웹사이트를 구축 중이라면 기본적인 블러 동작을 활용할 수 있습니다!\n\n## Plaiceholder를 사용하여 dataURL 생성하기\n\n정적 이미지를 사용하는 경우 로딩 상태에 대한 흐린 이미지를 추가할 수 있습니다. 이제 이전 방법의 한계를 극복해야 합니다.\n```\n\n\n\n문서에 따르면 동적 이미지를 위해 Image 컴포넌트의 blurDataUrl 속성에 dataURL을 전달해야 합니다. dataURL은 기본적으로 base64 형식으로 흐린 이미지 데이터를 보유하는 문자열입니다.\n\n```js\ndataURL 예시\ndata:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAYAAAB/qH1jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAJ0lEQVR4nGPY2fXjv458/H9Bbtf/IDbD/7v//8/Mvfq/J+nEfxAbAF3NFsFiuaE1AAAAAElFTkSuQmCC\n```\n\n우리는 이제 무엇이 필요한지 알았지만, 이렇게 데이터URL을 생성하는 방법이 무엇인지 궁금할 것입니다. 문서에서 제안한대로, plaiceholder는 이를 가능하게 해줍니다!\n\n우선, sharp와 plaiceholder 두 가지 패키지를 설치해야 합니다. 설치 방법은 이 페이지를 참고해주세요.\n\n\n\nNext.js를 사용하고 있다고 가정합니다. 다음 페이지를 따라서 next.config.ts 또는 next.config.mjs 파일을 구성해 주세요.\n\n설치가 완료되었습니다! 이제 서버 측에서 실행되는 사용자 정의 함수를 구현해야 합니다. 이 함수는 우리가 필요한 데이터URL을 생성합니다.\n\n```js\nimport fs from \"node:fs/promises\";\nimport { getPlaiceholder } from \"plaiceholder\";\n\nexport const getBase64 = async (imgPath: string) =\u003e {\n  try {\n    const file = await fs.readFile(`public/${imgPath}`)\n    const { base64 } = await getPlaiceholder(file)\n    return base64\n  } catch (error: unknown) {\n    // 에러 처리\n    if (error instanceof Error) return error.message\n    else if (error \u0026\u0026 typeof error === \"object\" \u0026\u0026 \"message\" in error)\n      return error.message as string\n    else if (typeof error === \"string\") return error;\n    else return \"예기치 않은 오류 발생!\"\n  }\n}\n```\n\n저는 문서에서처럼 then 또는 catch 메서드 대신 async-await 키워드를 사용하여 구현했습니다. getPlaiceholder 함수가 필요한 파일을 읽어야 합니다. 파일 경로에 \"public\" 접두사를 추가했습니다. 그런 다음 파일을 getPlaiceholder 함수에 전달했습니다. 이 함수는 css, color, pixels, base64 등과 같은 여러 객체를 반환합니다. 반환된 객체를 비구조화하여 base64 값을 추출하고 반환하세요!\n\n\n\n필요한 데이터URL을 생성하는 함수가 완성되었습니다. 이제 중요한 마지막 단계가 나왔어요!\n\n## getBase64 함수 사용하기\n\n함수에서 node:fs/promises를 가져오는 함수를 통해 파일을 읽었음을 알 수 있어요. 이는 이 함수가 노드 환경에서만 실행될 수 있다는 뜻이에요. 그러므로, 클라이언트 구성 요소에서 이 함수를 사용할 수는 없다는 점을 명심하는 것이 중요해요. 그치만 걱정할 필요는 아직 없어요. 왜냐하면 서버 구성 요소는 있거든요. 클라이언트 구성 요소에서 이 함수를 사용할 수 없더라도, 여전히 서버 구성 요소에서 이 async 함수를 호출하고 반환된 값을 클라이언트 구성 요소로 전달할 수 있어요.\n\n저의 포트폴리오 프로젝트에서 예제를 확인할 수 있어요. (이미 서버 구성 요소에서 이미지 구성 요소를 사용 중이라면, 이 마지막 단계는 필요하지 않아요. 클라이언트 구성 요소에 base64 문자열을 blurDataUrl 속성에 전달하려면 단순히 구성 요소를 async로 만들고 함수를 호출하면 됩니다.)\n\n\n\n위의 코드에서 여러 개의 base64 문자열을 생성하고 각각의 클라이언트 컴포넌트로 전달하고 있어요. (개별 이미지의 경로 문자열을 getBase64 함수에 전달하고 기다리면 단일 base64 문자열을 생성할 수 있어요)\n\n그래서 지금 우리는 흐린 이미지를 준비했어요!\n\n\n\n마지막으로, 플레이스홀더를 사용하여 SVG 및 색상과 같은 다른 기술을 활용할 수 있습니다. 그 외에도 시도해 볼 수 있는 기술이 많으니 플레이스홀더의 데모를 방문해 모든 기술을 확인해보세요.\n\n로딩 상태에서 흐릿한 이미지는 정말 좋아하는 기술입니다. 많은 웹사이트와 심지어 Discord와 같은 Windows 애플리케이션이 사용하는 기술인데, 우아함의 요소를 더해준다고 생각합니다. 이 기사가 도움이 되었으면 좋겠어요. 제 최신 작업 소식을 받아보려면 Medium이나 LinkedIn에서 팔로우해주세요. 다음 글에서 뵙길 기대하겠습니다!","ogImage":{"url":"/assets/img/2024-05-12-MakeYourImageLoadingBlurryinNextjs_0.png"},"coverImage":"/assets/img/2024-05-12-MakeYourImageLoadingBlurryinNextjs_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    div: \"div\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"웹 이미지는 사이트 성능 측면에서 중요하며 솔직히 말하자면 번거로운 부분이기도 합니다. Next.js의 최고의 기능 중 하나는 이미지 컴포넌트로, 이미지를 최적화해 줍니다. 이 컴포넌트는 화면 크기에 맞춰 WebP와 같은 현대적인 포맷의 이미지를 자동으로 생성하여 이미지 크기를 줄여줍니다. 또한 이미지가 뷰포트에 진입할 때 이미지를 불러오는 lazy loading과 레이아웃 이동을 방지하는 시각적 안정성이 구현되어 있습니다. 만약 이미지 컴포넌트에 익숙하지 않다면 Lee Robinson의 이 비디오를 추천합니다. 이 글에서는 실제 이미지가 로드되는 동안 흐린 이미지를 추가하는 것에 초점을 맞추고자 합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"이미지 컴포넌트의 기본 이미지 흐림\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이미지 컴포넌트에는 한 가지 제한이 있지만, 기본 옵션으로 이미지를 흐리게 만들어 줄 수도 있습니다! 제 포트폴리오 웹사이트에서 한 예시를 보여드리겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본 로딩보다 훨씬 나아요. 앞서 언급한 대로 한 가지 제한이 있습니다: 이미지를 정적으로 가져와야 합니다. 특히 이미지 동적 또는 클라우드 서비스를 사용하는 경우에는 이미지를 정적으로 가져오는 것이 불가능할 수 있습니다. 이 제한을 다음 기술에서 극복하겠지만, 지금은 이 기본 흐린 이미지를 가능하게 하는 코드를 살펴보도록 하죠.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" furkanpicture \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/public/pics/furkan.png\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Image\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"next/image\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"react\\\"\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"AboutImage\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"figure\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Image\"\n            }), \"\\n        \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"src\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{furkanpicture}\"\n            }), \"\\n        \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"alt\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{\"\n            }), \"\\\"\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"Furkan\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"Cengiz\"\n            }), \"\\\"}\\n        \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"placeholder\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"blur\\\"\"\n            }), \" //\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"기본값은\"\n            }), \" \\\"\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"empty\"\n            }), \"\\\"\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"입니다\"\n            }), \"\\n      /\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"figure\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"placeholder prop을 blur로 전달하고 src prop을 정적으로 가져온 이미지 개체로 전달할 때 Image 컴포넌트는 비디오에서 보는 것처럼 흐린 이미지를 생성합니다! 정적 페이지나 웹사이트를 구축 중이라면 기본적인 블러 동작을 활용할 수 있습니다!\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Plaiceholder를 사용하여 dataURL 생성하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정적 이미지를 사용하는 경우 로딩 상태에 대한 흐린 이미지를 추가할 수 있습니다. 이제 이전 방법의 한계를 극복해야 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"\\n\\n\\n문서에 따르면 동적 이미지를 위해 Image 컴포넌트의 blurDataUrl 속성에 dataURL을 전달해야 합니다. dataURL은 기본적으로 base64 형식으로 흐린 이미지 데이터를 보유하는 문자열입니다.\\n\\n```js\\ndataURL 예시\\ndata:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAYAAAB/qH1jAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAJ0lEQVR4nGPY2fXjv458/H9Bbtf/IDbD/7v//8/Mvfq/J+nEfxAbAF3NFsFiuaE1AAAAAElFTkSuQmCC\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 이제 무엇이 필요한지 알았지만, 이렇게 데이터URL을 생성하는 방법이 무엇인지 궁금할 것입니다. 문서에서 제안한대로, plaiceholder는 이를 가능하게 해줍니다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우선, sharp와 plaiceholder 두 가지 패키지를 설치해야 합니다. 설치 방법은 이 페이지를 참고해주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next.js를 사용하고 있다고 가정합니다. 다음 페이지를 따라서 next.config.ts 또는 next.config.mjs 파일을 구성해 주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"설치가 완료되었습니다! 이제 서버 측에서 실행되는 사용자 정의 함수를 구현해야 합니다. 이 함수는 우리가 필요한 데이터URL을 생성합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" fs \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"node:fs/promises\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { getPlaiceholder } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"plaiceholder\\\"\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getBase64\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"imgPath: string\"\n        }), \") =\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" file = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" fs.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"readFile\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`public/\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${imgPath}\"\n          }), \"`\"]\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" { base64 } = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getPlaiceholder\"\n        }), \"(file)\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" base64\\n  } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"catch\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"error\"\n        }), \": unknown) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 에러 처리\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (error \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"instanceof\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Error\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" error.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"message\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (error \u0026\u0026 \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"typeof\"\n        }), \" error === \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"object\\\"\"\n        }), \" \u0026\u0026 \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"message\\\"\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" error)\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" error.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"message\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" string\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"typeof\"\n        }), \" error === \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"string\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" error;\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"예기치 않은 오류 발생!\\\"\"\n        }), \"\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저는 문서에서처럼 then 또는 catch 메서드 대신 async-await 키워드를 사용하여 구현했습니다. getPlaiceholder 함수가 필요한 파일을 읽어야 합니다. 파일 경로에 \\\"public\\\" 접두사를 추가했습니다. 그런 다음 파일을 getPlaiceholder 함수에 전달했습니다. 이 함수는 css, color, pixels, base64 등과 같은 여러 객체를 반환합니다. 반환된 객체를 비구조화하여 base64 값을 추출하고 반환하세요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"필요한 데이터URL을 생성하는 함수가 완성되었습니다. 이제 중요한 마지막 단계가 나왔어요!\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"getBase64 함수 사용하기\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"함수에서 node\", _jsx(_components.div, {}), \"/promises를 가져오는 함수를 통해 파일을 읽었음을 알 수 있어요. 이는 이 함수가 노드 환경에서만 실행될 수 있다는 뜻이에요. 그러므로, 클라이언트 구성 요소에서 이 함수를 사용할 수는 없다는 점을 명심하는 것이 중요해요. 그치만 걱정할 필요는 아직 없어요. 왜냐하면 서버 구성 요소는 있거든요. 클라이언트 구성 요소에서 이 함수를 사용할 수 없더라도, 여전히 서버 구성 요소에서 이 async 함수를 호출하고 반환된 값을 클라이언트 구성 요소로 전달할 수 있어요.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저의 포트폴리오 프로젝트에서 예제를 확인할 수 있어요. (이미 서버 구성 요소에서 이미지 구성 요소를 사용 중이라면, 이 마지막 단계는 필요하지 않아요. 클라이언트 구성 요소에 base64 문자열을 blurDataUrl 속성에 전달하려면 단순히 구성 요소를 async로 만들고 함수를 호출하면 됩니다.)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 코드에서 여러 개의 base64 문자열을 생성하고 각각의 클라이언트 컴포넌트로 전달하고 있어요. (개별 이미지의 경로 문자열을 getBase64 함수에 전달하고 기다리면 단일 base64 문자열을 생성할 수 있어요)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서 지금 우리는 흐린 이미지를 준비했어요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, 플레이스홀더를 사용하여 SVG 및 색상과 같은 다른 기술을 활용할 수 있습니다. 그 외에도 시도해 볼 수 있는 기술이 많으니 플레이스홀더의 데모를 방문해 모든 기술을 확인해보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"로딩 상태에서 흐릿한 이미지는 정말 좋아하는 기술입니다. 많은 웹사이트와 심지어 Discord와 같은 Windows 애플리케이션이 사용하는 기술인데, 우아함의 요소를 더해준다고 생각합니다. 이 기사가 도움이 되었으면 좋겠어요. 제 최신 작업 소식을 받아보려면 Medium이나 LinkedIn에서 팔로우해주세요. 다음 글에서 뵙길 기대하겠습니다!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-MakeYourImageLoadingBlurryinNextjs"},"buildId":"K-h7XvEVBqnNx_uXMgZoe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>