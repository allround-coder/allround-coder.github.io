<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>모듈 페더레이션에서 범위 지정된 스타일 관리하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-ManagingScopedStylesinModuleFederation" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="모듈 페더레이션에서 범위 지정된 스타일 관리하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="모듈 페더레이션에서 범위 지정된 스타일 관리하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-ManagingScopedStylesinModuleFederation_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-ManagingScopedStylesinModuleFederation" data-gatsby-head="true"/><meta name="twitter:title" content="모듈 페더레이션에서 범위 지정된 스타일 관리하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-ManagingScopedStylesinModuleFederation_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 03:46" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">모듈 페더레이션에서 범위 지정된 스타일 관리하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="모듈 페더레이션에서 범위 지정된 스타일 관리하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-ManagingScopedStylesinModuleFederation&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-22-ManagingScopedStylesinModuleFederation_0.png">
<p>현대 웹 개발 세계에서, 마이크로 프론트엔드가 점점 더 인기를 얻고 있습니다. 마이크로 프론트엔드를 가능하게 하는 주요 기술 중 하나는 Webpack의 Module Federation입니다. 이 기능을 통해 다른 Webpack 빌드가 런타임에서 함께 작동하고 코드를 공유할 수 있습니다. 그러나 Module Federation 애플리케이션에서 CSS를 관리하는 것은 어려운 과제일 수 있습니다.</p>
<p>이 글에서는 우리가 이러한 CSS 도전 과제를 어떻게 처리했는지 설명하겠습니다. 우리가 사용한 전략과 개발한 사용자 정의 PostCSS 플러그인을 공유할 것입니다. 우리의 접근 방식을 공유함으로써, 우리의 마이크로 프론트엔드 프로젝트에서 비슷한 문제에 직면한 다른 개발자들에게 도움이 되기를 희망합니다.</p>
<h1>CSS 도전적 과제</h1>
<div class="content-ad"></div>
<p>CSS에 대해 이야기할 때, 전통적인 스타일 포함 방법은 갈등과 일관성 부족으로 이어질 수 있습니다. 이는 여러 팀이 다른 CSS 방법론, 전처리기 또는 프레임워크를 사용할 수 있는 모듈 연합 설정에서 특히 문제가 될 수 있습니다. 주요 도전 과제는 다음과 같습니다:</p>
<ul>
<li>CSS 범위 격리: 서로 다른 마이크로 프론트엔드 간의 스타일 충돌을 피하는 것.</li>
<li>CSS 로딩 순서: 스타일이 올바른 순서로 로드되도록 보장하는 것.</li>
<li>공유 스타일: 서로 다른 마이크로 프론트엔드 간에 공유되는 일반적인 스타일을 관리하는 것.</li>
</ul>
<p>저희 프로젝트에서는 Tailwind CSS 프레임워크를 사용하고 있었습니다. Tailwind를 마이크로 프론트엔드 애플리케이션에 통합할 때, 원치 않는 화면이 발생하는 충돌이 있었던 일이 있습니다.</p>
<h1>초기 해결책: 접두사 추가</h1>
<div class="content-ad"></div>
<p>가장 간단한 해결책은 각 클래스명에 접두사를 추가하는 것이었습니다. Tailwind의 구성에서 접두사를 추가할 수 있는 옵션이 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">prefix</span>: <span class="hljs-string">'app1-'</span>,
  <span class="hljs-attr">darkMode</span>: [<span class="hljs-string">'class'</span>],
  <span class="hljs-attr">content</span>: [<span class="hljs-string">'./app/**/*.{js,ts,tsx,html}'</span>, <span class="hljs-string">'./src/**/*.{js,ts,tsx,html}'</span>]
}
</code></pre>
<p>그러나 이 방식으로 구성하려면 모든 클래스명을 접두사로 시작하도록 변경해야 했습니다:</p>
<pre><code class="hljs language-js">&#x3C;!-- 변경 전 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex gap-3 mb-2 w-full"</span>/></span></span>

&#x3C;!-- 변경 후 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"app1-flex app1-gap-3 app1-mb-2 app1-w-full"</span>/></span></span>
</code></pre>
<div class="content-ad"></div>
<p>이 접근 방식은 작동했지만 코드 작성과 유지 관리가 어려워졌어요. 예를 들어, 접두사를 추가하는 걸 잊고 이런 경우에 이슈를 찾으려고 했어요. 우리는 다른 해결책이 필요했어요.</p>
<h1>우리의 해결책: 사용자 정의 PostCSS 플러그인</h1>
<p>더 우아하게 이 문제를 해결하기 위해 우리는 모든 CSS 선택기를 특정 부모 선택기로 래핑하는 사용자 정의 PostCSS 플러그인을 개발했어요. 이렇게 함으로써 스타일이 특정한 마이크로 프런트엔드에 대해 스코프가 지정되어 애플리케이션의 다른 부분과 충돌하는 것을 방지했어요.</p>
<h2>사용자 정의 PostCSS 플러그인 예시</h2>
<div class="content-ad"></div>
<p>우리가 만든 사용자 정의 PostCSS 플러그인을 보여드릴게요:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// postcss.config.js</span>
<span class="hljs-keyword">const</span> tailwindcss = <span class="hljs-built_in">require</span>(<span class="hljs-string">'tailwindcss'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title function_">wrapSelector</span> = (<span class="hljs-params">opts = {}</span>) => ({
  <span class="hljs-attr">postcssPlugin</span>: <span class="hljs-string">'wrap-selector'</span>,
  <span class="hljs-title class_">Once</span>(root) {
    root.<span class="hljs-title function_">walkRules</span>(<span class="hljs-function">(<span class="hljs-params">rule</span>) =></span> {
      <span class="hljs-keyword">if</span> (!rule.<span class="hljs-property">selectors</span>) <span class="hljs-keyword">return</span> rule;
      rule.<span class="hljs-property">selectors</span> = rule.<span class="hljs-property">selectors</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">selector</span>) =></span> <span class="hljs-string">`<span class="hljs-subst">${opts.wrapper}</span> <span class="hljs-subst">${selector}</span>`</span>);
    });
  },
});
wrapSelector.<span class="hljs-property">postcss</span> = <span class="hljs-literal">true</span>;

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">'postcss-preset-env'</span>, tailwindcss, <span class="hljs-title function_">wrapSelector</span>({ <span class="hljs-attr">wrapper</span>: <span class="hljs-string">'#app1-id'</span> })],
};
</code></pre>
<h2>작동 방법</h2>
<ul>
<li>플러그인 정의: wrapSelector 함수는 PostCSS 플러그인으로 정의됩니다. opts 객체를 입력값으로 받아들이는데, 이 객체에는 기존 CSS 선택자 주변에 감쌀 부모 선택자인 wrapper 속성이 포함되어 있습니다.</li>
<li>규칙 탐색: Once 메서드는 모든 CSS 규칙을 탐색합니다. 선택자가 있는 각 규칙마다 해당하는 wrapper와 함께 접두어를 붙인 새 선택자로 매핑합니다.</li>
<li>PostCSS 설정: 이 플러그인은 postcss-preset-env 및 tailwindcss와 같은 다른 플러그인과 함께 PostCSS 구성에 포함됩니다.</li>
</ul>
<div class="content-ad"></div>
<h1>모듈 연합에서의 사용법</h1>
<p>이 사용자 지정 PostCSS 플러그인을 모듈 연합 설정에서 사용하려면 다음 단계를 따르세요:</p>
<ul>
<li>PostCSS 구성: 위에 표시된대로 사용자 지정 플러그인이 포함된 PostCSS 구성을 확인하십시오.</li>
<li>스코프 스타일 적용: CSS 선택자를 래핑하여 마이크로 프론트엔드 애플리케이션에서 스타일이 적절히 스코프화되도록합니다.</li>
</ul>
<h2>웹팩에서의 구성 예시</h2>
<div class="content-ad"></div>
<p>웹팩 구성에 PostCSS 플러그인을 통합하는 방법은 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>, <span class="hljs-string">'postcss-loader'</span>],
      }
    ],
  },
};
</code></pre>
<h2>리액트 컴포넌트에서의 예시 사용법</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app1-id"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"text-2xl font-bold"</span>></span>안녕하세요, App 1에서 인사드립니다<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<div class="content-ad"></div>
<h1>결론</h1>
<p>Module Federation 애플리케이션에서 CSS를 다루려면 범위 격리, 로딩 순서 및 공유 스타일을 신중히 고려해야 합니다. 위에서 소개한 것과 같이 커스텀 PostCSS 플러그인을 활용하여 CSS를 효과적으로 관리하고 스타일이 개별 마이크로 프론트엔드에 적절하게 스코프되도록 할 수 있습니다. 이 접근 방식을 통해 마이크로 프론트엔드 애플리케이션에서 모듈식이며 충돌이 없는 CSS 아키텍처를 유지할 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"모듈 페더레이션에서 범위 지정된 스타일 관리하는 방법","description":"","date":"2024-06-22 03:46","slug":"2024-06-22-ManagingScopedStylesinModuleFederation","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-ManagingScopedStylesinModuleFederation_0.png\" /\u003e\n\n현대 웹 개발 세계에서, 마이크로 프론트엔드가 점점 더 인기를 얻고 있습니다. 마이크로 프론트엔드를 가능하게 하는 주요 기술 중 하나는 Webpack의 Module Federation입니다. 이 기능을 통해 다른 Webpack 빌드가 런타임에서 함께 작동하고 코드를 공유할 수 있습니다. 그러나 Module Federation 애플리케이션에서 CSS를 관리하는 것은 어려운 과제일 수 있습니다.\n\n이 글에서는 우리가 이러한 CSS 도전 과제를 어떻게 처리했는지 설명하겠습니다. 우리가 사용한 전략과 개발한 사용자 정의 PostCSS 플러그인을 공유할 것입니다. 우리의 접근 방식을 공유함으로써, 우리의 마이크로 프론트엔드 프로젝트에서 비슷한 문제에 직면한 다른 개발자들에게 도움이 되기를 희망합니다.\n\n# CSS 도전적 과제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCSS에 대해 이야기할 때, 전통적인 스타일 포함 방법은 갈등과 일관성 부족으로 이어질 수 있습니다. 이는 여러 팀이 다른 CSS 방법론, 전처리기 또는 프레임워크를 사용할 수 있는 모듈 연합 설정에서 특히 문제가 될 수 있습니다. 주요 도전 과제는 다음과 같습니다:\n\n- CSS 범위 격리: 서로 다른 마이크로 프론트엔드 간의 스타일 충돌을 피하는 것.\n- CSS 로딩 순서: 스타일이 올바른 순서로 로드되도록 보장하는 것.\n- 공유 스타일: 서로 다른 마이크로 프론트엔드 간에 공유되는 일반적인 스타일을 관리하는 것.\n\n저희 프로젝트에서는 Tailwind CSS 프레임워크를 사용하고 있었습니다. Tailwind를 마이크로 프론트엔드 애플리케이션에 통합할 때, 원치 않는 화면이 발생하는 충돌이 있었던 일이 있습니다.\n\n# 초기 해결책: 접두사 추가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 간단한 해결책은 각 클래스명에 접두사를 추가하는 것이었습니다. Tailwind의 구성에서 접두사를 추가할 수 있는 옵션이 있습니다:\n\n```js\nmodule.exports = {\n  prefix: 'app1-',\n  darkMode: ['class'],\n  content: ['./app/**/*.{js,ts,tsx,html}', './src/**/*.{js,ts,tsx,html}']\n}\n```\n\n그러나 이 방식으로 구성하려면 모든 클래스명을 접두사로 시작하도록 변경해야 했습니다:\n\n```js\n\u003c!-- 변경 전 --\u003e\n\u003cdiv className=\"flex gap-3 mb-2 w-full\"/\u003e\n\n\u003c!-- 변경 후 --\u003e\n\u003cdiv className=\"app1-flex app1-gap-3 app1-mb-2 app1-w-full\"/\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 접근 방식은 작동했지만 코드 작성과 유지 관리가 어려워졌어요. 예를 들어, 접두사를 추가하는 걸 잊고 이런 경우에 이슈를 찾으려고 했어요. 우리는 다른 해결책이 필요했어요.\n\n# 우리의 해결책: 사용자 정의 PostCSS 플러그인\n\n더 우아하게 이 문제를 해결하기 위해 우리는 모든 CSS 선택기를 특정 부모 선택기로 래핑하는 사용자 정의 PostCSS 플러그인을 개발했어요. 이렇게 함으로써 스타일이 특정한 마이크로 프런트엔드에 대해 스코프가 지정되어 애플리케이션의 다른 부분과 충돌하는 것을 방지했어요.\n\n## 사용자 정의 PostCSS 플러그인 예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 만든 사용자 정의 PostCSS 플러그인을 보여드릴게요:\n\n```js\n// postcss.config.js\nconst tailwindcss = require('tailwindcss');\nconst wrapSelector = (opts = {}) =\u003e ({\n  postcssPlugin: 'wrap-selector',\n  Once(root) {\n    root.walkRules((rule) =\u003e {\n      if (!rule.selectors) return rule;\n      rule.selectors = rule.selectors.map((selector) =\u003e `${opts.wrapper} ${selector}`);\n    });\n  },\n});\nwrapSelector.postcss = true;\n\nmodule.exports = {\n  plugins: ['postcss-preset-env', tailwindcss, wrapSelector({ wrapper: '#app1-id' })],\n};\n```\n\n## 작동 방법\n\n- 플러그인 정의: wrapSelector 함수는 PostCSS 플러그인으로 정의됩니다. opts 객체를 입력값으로 받아들이는데, 이 객체에는 기존 CSS 선택자 주변에 감쌀 부모 선택자인 wrapper 속성이 포함되어 있습니다.\n- 규칙 탐색: Once 메서드는 모든 CSS 규칙을 탐색합니다. 선택자가 있는 각 규칙마다 해당하는 wrapper와 함께 접두어를 붙인 새 선택자로 매핑합니다.\n- PostCSS 설정: 이 플러그인은 postcss-preset-env 및 tailwindcss와 같은 다른 플러그인과 함께 PostCSS 구성에 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 모듈 연합에서의 사용법\n\n이 사용자 지정 PostCSS 플러그인을 모듈 연합 설정에서 사용하려면 다음 단계를 따르세요:\n\n- PostCSS 구성: 위에 표시된대로 사용자 지정 플러그인이 포함된 PostCSS 구성을 확인하십시오.\n- 스코프 스타일 적용: CSS 선택자를 래핑하여 마이크로 프론트엔드 애플리케이션에서 스타일이 적절히 스코프화되도록합니다.\n\n## 웹팩에서의 구성 예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹팩 구성에 PostCSS 플러그인을 통합하는 방법은 다음과 같습니다:\n\n```js\n// webpack.config.js\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/i,\n        use: ['style-loader', 'css-loader', 'postcss-loader'],\n      }\n    ],\n  },\n};\n```\n\n## 리액트 컴포넌트에서의 예시 사용법\n\n```js\nimport React from 'react';\n\nconst App = () =\u003e {\n  return (\n    \u003cdiv id=\"app1-id\"\u003e\n      \u003ch1 className=\"text-2xl font-bold\"\u003e안녕하세요, App 1에서 인사드립니다\u003c/h1\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default App;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nModule Federation 애플리케이션에서 CSS를 다루려면 범위 격리, 로딩 순서 및 공유 스타일을 신중히 고려해야 합니다. 위에서 소개한 것과 같이 커스텀 PostCSS 플러그인을 활용하여 CSS를 효과적으로 관리하고 스타일이 개별 마이크로 프론트엔드에 적절하게 스코프되도록 할 수 있습니다. 이 접근 방식을 통해 마이크로 프론트엔드 애플리케이션에서 모듈식이며 충돌이 없는 CSS 아키텍처를 유지할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-ManagingScopedStylesinModuleFederation_0.png"},"coverImage":"/assets/img/2024-06-22-ManagingScopedStylesinModuleFederation_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-22-ManagingScopedStylesinModuleFederation_0.png\"\u003e\n\u003cp\u003e현대 웹 개발 세계에서, 마이크로 프론트엔드가 점점 더 인기를 얻고 있습니다. 마이크로 프론트엔드를 가능하게 하는 주요 기술 중 하나는 Webpack의 Module Federation입니다. 이 기능을 통해 다른 Webpack 빌드가 런타임에서 함께 작동하고 코드를 공유할 수 있습니다. 그러나 Module Federation 애플리케이션에서 CSS를 관리하는 것은 어려운 과제일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 글에서는 우리가 이러한 CSS 도전 과제를 어떻게 처리했는지 설명하겠습니다. 우리가 사용한 전략과 개발한 사용자 정의 PostCSS 플러그인을 공유할 것입니다. 우리의 접근 방식을 공유함으로써, 우리의 마이크로 프론트엔드 프로젝트에서 비슷한 문제에 직면한 다른 개발자들에게 도움이 되기를 희망합니다.\u003c/p\u003e\n\u003ch1\u003eCSS 도전적 과제\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eCSS에 대해 이야기할 때, 전통적인 스타일 포함 방법은 갈등과 일관성 부족으로 이어질 수 있습니다. 이는 여러 팀이 다른 CSS 방법론, 전처리기 또는 프레임워크를 사용할 수 있는 모듈 연합 설정에서 특히 문제가 될 수 있습니다. 주요 도전 과제는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCSS 범위 격리: 서로 다른 마이크로 프론트엔드 간의 스타일 충돌을 피하는 것.\u003c/li\u003e\n\u003cli\u003eCSS 로딩 순서: 스타일이 올바른 순서로 로드되도록 보장하는 것.\u003c/li\u003e\n\u003cli\u003e공유 스타일: 서로 다른 마이크로 프론트엔드 간에 공유되는 일반적인 스타일을 관리하는 것.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e저희 프로젝트에서는 Tailwind CSS 프레임워크를 사용하고 있었습니다. Tailwind를 마이크로 프론트엔드 애플리케이션에 통합할 때, 원치 않는 화면이 발생하는 충돌이 있었던 일이 있습니다.\u003c/p\u003e\n\u003ch1\u003e초기 해결책: 접두사 추가\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e가장 간단한 해결책은 각 클래스명에 접두사를 추가하는 것이었습니다. Tailwind의 구성에서 접두사를 추가할 수 있는 옵션이 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eprefix\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app1-'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003edarkMode\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'class'\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'./app/**/*.{js,ts,tsx,html}'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'./src/**/*.{js,ts,tsx,html}'\u003c/span\u003e]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 이 방식으로 구성하려면 모든 클래스명을 접두사로 시작하도록 변경해야 했습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;!-- 변경 전 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"flex gap-3 mb-2 w-full\"\u003c/span\u003e/\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u0026#x3C;!-- 변경 후 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"app1-flex app1-gap-3 app1-mb-2 app1-w-full\"\u003c/span\u003e/\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 접근 방식은 작동했지만 코드 작성과 유지 관리가 어려워졌어요. 예를 들어, 접두사를 추가하는 걸 잊고 이런 경우에 이슈를 찾으려고 했어요. 우리는 다른 해결책이 필요했어요.\u003c/p\u003e\n\u003ch1\u003e우리의 해결책: 사용자 정의 PostCSS 플러그인\u003c/h1\u003e\n\u003cp\u003e더 우아하게 이 문제를 해결하기 위해 우리는 모든 CSS 선택기를 특정 부모 선택기로 래핑하는 사용자 정의 PostCSS 플러그인을 개발했어요. 이렇게 함으로써 스타일이 특정한 마이크로 프런트엔드에 대해 스코프가 지정되어 애플리케이션의 다른 부분과 충돌하는 것을 방지했어요.\u003c/p\u003e\n\u003ch2\u003e사용자 정의 PostCSS 플러그인 예시\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리가 만든 사용자 정의 PostCSS 플러그인을 보여드릴게요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// postcss.config.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tailwindcss = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'tailwindcss'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ewrapSelector\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eopts = {}\u003c/span\u003e) =\u003e ({\n  \u003cspan class=\"hljs-attr\"\u003epostcssPlugin\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'wrap-selector'\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eOnce\u003c/span\u003e(root) {\n    root.\u003cspan class=\"hljs-title function_\"\u003ewalkRules\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003erule\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!rule.\u003cspan class=\"hljs-property\"\u003eselectors\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e rule;\n      rule.\u003cspan class=\"hljs-property\"\u003eselectors\u003c/span\u003e = rule.\u003cspan class=\"hljs-property\"\u003eselectors\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eselector\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${opts.wrapper}\u003c/span\u003e \u003cspan class=\"hljs-subst\"\u003e${selector}\u003c/span\u003e`\u003c/span\u003e);\n    });\n  },\n});\nwrapSelector.\u003cspan class=\"hljs-property\"\u003epostcss\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'postcss-preset-env'\u003c/span\u003e, tailwindcss, \u003cspan class=\"hljs-title function_\"\u003ewrapSelector\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ewrapper\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#app1-id'\u003c/span\u003e })],\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e작동 방법\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e플러그인 정의: wrapSelector 함수는 PostCSS 플러그인으로 정의됩니다. opts 객체를 입력값으로 받아들이는데, 이 객체에는 기존 CSS 선택자 주변에 감쌀 부모 선택자인 wrapper 속성이 포함되어 있습니다.\u003c/li\u003e\n\u003cli\u003e규칙 탐색: Once 메서드는 모든 CSS 규칙을 탐색합니다. 선택자가 있는 각 규칙마다 해당하는 wrapper와 함께 접두어를 붙인 새 선택자로 매핑합니다.\u003c/li\u003e\n\u003cli\u003ePostCSS 설정: 이 플러그인은 postcss-preset-env 및 tailwindcss와 같은 다른 플러그인과 함께 PostCSS 구성에 포함됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e모듈 연합에서의 사용법\u003c/h1\u003e\n\u003cp\u003e이 사용자 지정 PostCSS 플러그인을 모듈 연합 설정에서 사용하려면 다음 단계를 따르세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePostCSS 구성: 위에 표시된대로 사용자 지정 플러그인이 포함된 PostCSS 구성을 확인하십시오.\u003c/li\u003e\n\u003cli\u003e스코프 스타일 적용: CSS 선택자를 래핑하여 마이크로 프론트엔드 애플리케이션에서 스타일이 적절히 스코프화되도록합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e웹팩에서의 구성 예시\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e웹팩 구성에 PostCSS 플러그인을 통합하는 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// webpack.config.js\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003erules\u003c/span\u003e: [\n      {\n        \u003cspan class=\"hljs-attr\"\u003etest\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/\\.css$/i\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003euse\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'style-loader'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'css-loader'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'postcss-loader'\u003c/span\u003e],\n      }\n    ],\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e리액트 컴포넌트에서의 예시 사용법\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"app1-id\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"text-2xl font-bold\"\u003c/span\u003e\u003e\u003c/span\u003e안녕하세요, App 1에서 인사드립니다\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eModule Federation 애플리케이션에서 CSS를 다루려면 범위 격리, 로딩 순서 및 공유 스타일을 신중히 고려해야 합니다. 위에서 소개한 것과 같이 커스텀 PostCSS 플러그인을 활용하여 CSS를 효과적으로 관리하고 스타일이 개별 마이크로 프론트엔드에 적절하게 스코프되도록 할 수 있습니다. 이 접근 방식을 통해 마이크로 프론트엔드 애플리케이션에서 모듈식이며 충돌이 없는 CSS 아키텍처를 유지할 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-ManagingScopedStylesinModuleFederation"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>