<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>앵귤러 라우트를 제대로 사용하는 방법 3가지 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="앵귤러 라우트를 제대로 사용하는 방법 3가지 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="앵귤러 라우트를 제대로 사용하는 방법 3가지 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes" data-gatsby-head="true"/><meta name="twitter:title" content="앵귤러 라우트를 제대로 사용하는 방법 3가지 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 20:22" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">앵귤러 라우트를 제대로 사용하는 방법 3가지</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="앵귤러 라우트를 제대로 사용하는 방법 3가지" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png" alt="Angular"/></p>
<p>정직하게 말하자면, 나는 Angular과 사랑과 미움이 공존하는 관계를 가지고 있어. 모든 것이 제대로 작동할 때는 정말 멋져. 그렇지만 그렇지 않고 나에게 힌트나 &#x27;더 어려운&#x27; 자료가 없는 경우, 그때는 너무나 짜증이 나.</p>
<p>하지만 결국, 어떤 라이브러리, 프레임워크 또는 구글에 직면한 직관적인 답변이 없는 이상한 오류도 마찬가지로 그렇다.</p>
<p>많은 사람들에게 Angular 라우팅은 포기하고 싶게 만드는 문제다. 일부로, 온라인 튜토리얼 중 많은 것들이 기본 라우트를 구현하는 예제들뿐이기 때문이다. 복잡한 시나리오에 적합한 것을 찾는 것은 갑자기 시간 소모적인 시행착오 과정이 될 수 있다.</p>
<div class="content-ad"></div>
<p>앵귤러는 프레임워크이기 때문에 내재적으로 이해하는 데 시간이 걸릴 수 있어도 라우팅 방식이 구현되는 방식은 때로는 지루하게 느껴질 수 있습니다. 그러나 이해하고 난 뒤에는 실제로 과소평가된 보석이라고 생각해요.</p>
<p>리액트와 같은 것과 비교해보면, 리액트는 다양한 방법론의 아드혹 패치워크일 수 있지만, 앵귤러의 &#x27;이게 우리가 하는 방식이다&#x27; 접근 방식은 여러 팀 간 협업 시 덜 괴로울 수 있어요.</p>
<p>앵귤러에서는 라우트를 별도 모듈(일반적으로 AppRoutingModule)에서 정의하고 RouterModule.forRoot() 메서드를 사용하여 라우트를 등록해요. 라우트는 객체 배열로 정의되며, 각 객체는 경로와 연결된 컴포넌트를 포함해요. 반면 리액트에서는 라우트가 Route, Switch, BrowserRouter와 같은 React Router 라이브러리에서 제공되는 컴포넌트를 사용하여 정의돼요. 이러한 컴포넌트들은 JSX 코드 내에서 직접 사용되며, 라우트 구성이 더 선언적이에요.</p>
<p>앵귤러 라우팅의 장점(AppRoutingModule 및 RouterModule.forRoot()을 통해)은 구성이 중앙 집중화되어 있고 강력한 타입 지정으로 일관된 접근 방식을 제공한다는 점이에요. 반면, 리액트 라우팅(Route, Switch, BrowserRouter 컴포넌트를 통해)은 중앙 집중화가 부족하고 내장된 유형 확인이 없으며, 일관성 부족으로 인한 높은 불일치가 발생할 수 있어요.</p>
<div class="content-ad"></div>
<p>제 이야기는 여기까지 하고, 본문의 요점으로 넘어가 봅시다. 이 글에서 다루는 Angular 라우팅 시나리오/레시피 중 가장 중요한 것은 바로 세 가지입니다. 이 세 가지는 모든 앱 개발 작업과 프로젝트를 다루며, 이해하기 어려웠던 부분을 간단하게 설명해줬으면 했던 것들입니다.</p>
<h1>레시피 1: 여러 수준과 동적 경로를 가진 중첩 라우팅</h1>
<p>Angular 라우트에서 동적 경로를 가진 다중 수준의 탐색 구조는 정보가 층층이 쌓인 정체를 푸는 것 같은 신비한 상자와 같은 느낌을 줄 수 있습니다.</p>
<p>라우팅을 처음 배울 때, 우리는 종종 한 수준에서 시작하여 종료하는, 다음 페이지로 이동하고 다시 돌아오는 정도의 시나리오로 끝나곤 합니다. 하지만 90년대가 아니라는 것을 기억해야 합니다. 실제로 레알 앱/사이트는 카테고리, 서브카테고리, 사용자가 작성한 콘텐츠를 통해 동적 경로로 이어지는 필수 요소들이 많습니다.</p>
<div class="content-ad"></div>
<p>이 예시를 위해 상상해 봅시다. 우리는 그것만 있는 전자상거래 애플리케이션을 개발하고 있다고 상상해 봅시다.</p>
<h2>단계 1: 카테고리, 하위 카테고리 및 제품 컴포넌트를 생성합시다</h2>
<pre><code class="hljs language-js">ng generate component category
ng generate component subcategory
ng generate component product
</code></pre>
<h2>단계 2: AppRoutingModule에서 라우트를 정의합시다</h2>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NgModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RouterModule</span>, <span class="hljs-title class_">Routes</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/router&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CategoryComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./category/category.component&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">SubcategoryComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./subcategory/subcategory.component&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ProductComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./product/product.component&#x27;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Routes</span> = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;category/:categoryId&#x27;</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">CategoryComponent</span>,
    <span class="hljs-attr">children</span>: [
      {
        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;subcategory/:subcategoryId&#x27;</span>,
        <span class="hljs-attr">component</span>: <span class="hljs-title class_">SubcategoryComponent</span>,
        <span class="hljs-attr">children</span>: [
          {
            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;product/:productId&#x27;</span>,
            <span class="hljs-attr">component</span>: <span class="hljs-title class_">ProductComponent</span>,
          },
        ],
      },
    ],
  },
];

@<span class="hljs-title class_">NgModule</span>({
  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">RouterModule</span>.<span class="hljs-title function_">forRoot</span>(routes)],
  <span class="hljs-attr">exports</span>: [<span class="hljs-title class_">RouterModule</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppRoutingModule</span> {}
</code></pre>
<p>위 예제에서는 전자 상거래 앱의 각 수준에 대한 경로를 정의했습니다. 경로에서 <div></div>, <div></div> 및 <div></div> 자리 표시 자를 사용한 점에 주목하세요. 이러한 세그먼트는 앱을 통해 탐색할 때 실제 값으로 대체됩니다.</p>
<h2>단계 3: 컴포넌트 템플릿에 라우터 아웃렛을 추가하여 Angular이 자식 컴포넌트를 렌더링할 위치를 알 수 있도록 합니다:</h2>
<pre><code class="hljs language-js">&lt;!-- category.<span class="hljs-property">component</span>.<span class="hljs-property">html</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Category<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span></span>

&lt;!-- subcategory.<span class="hljs-property">component</span>.<span class="hljs-property">html</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Subcategory<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span></span>

&lt;!-- product.<span class="hljs-property">component</span>.<span class="hljs-property">html</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Product<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span>
</code></pre>
<div class="content-ad"></div>
<h2>단계 4: 앱을 통해 이동할 수 있는 몇 가지 라우터 링크를 생성합니다</h2>
<pre><code class="hljs language-js">&lt;!-- app.<span class="hljs-property">component</span>.<span class="hljs-property">html</span> --&gt;
 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let category of categories&quot;</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">a</span> [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">&quot;[&#x27;/category&#x27;, category.id]&quot;</span>&gt;</span>{ category.name }<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span></span>
 <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span></span>
 
</code></pre>
<p>이 예에서는 카테고리 배열이 id와 name 속성이 있는 카테고리 데이터를 포함하고 있다고 가정합니다. [routerLink] 지시문은 카테고리, 하위 카테고리 및 제품을 통해 이동할 때 적절한 URL을 생성합니다.</p>
<p>그게 다입니다! 이제 다중 수준 및 동적 경로를 포함하는 중첩 라우팅 구조의 기본 뼈대가 완성되었습니다. 사용자는 이제 카테고리, 하위 카테고리, 제품을 손쉽게 탐색할 수 있으며 앱의 구조는 깔끔하고 조직적입니다.</p>
<div class="content-ad"></div>
<h1>레시피 2: 라우트 가드 및 역할 기반 액세스와 canActivate</h1>
<p>오케이, 멋져요. 중첩된 내용들이 있고, 특정 사람들에게만 보기 권한을 부여하고 특정 작업을 할 수 있게끔 하는 건 어떻게 하는지 궁금하신가요? 예를 들어, 사용자들?</p>
<p>이것이 바로 canActivate 및 RoleGuard의 역할입니다.</p>
<p>Angular에서 역할 기반 액세스 제어를 구현하는 데 Route guards와 canActivate 가드를 사용할 수 있습니다. 이를 통해 응용 프로그램의 특정 부분에 대한 액세스 권한이 있는 사용자만 해당 부분에 액세스할 수 있도록 할 수 있습니다.</p>
<div class="content-ad"></div>
<p>일반 사용자와 관리자 사용자가 있는 응용 프로그램을 개발 중이라고 상상해 봅시다. 이제 사용자의 역할에 따라 특정 경로로의 액세스를 제한하려고 합니다. 이를 위해 RoleGuard라는 사용자 지정 라우트 가드를 만들 수 있습니다.</p>
<h2>단계 1: RoleGuard 생성</h2>
<pre><code class="hljs language-js">ng generate guard role
</code></pre>
<h2>단계 2: RoleGuard를 생성하고 CanActivate 인터페이스를 구현하여 사용자의 역할을 확인하도록 수정하세요.</h2>
<div class="content-ad"></div>
<p>위의 예시에서는 사용자 역할을 확인하고 해당 사용자가 관리자인 경우 true를 반환합니다. 사용자가 관리자가 아닌 경우 홈 페이지로 리디렉션하고 false를 반환합니다.</p>
<p>RoleGuard를 CanActivate 인터페이스를 구현하도록 수정하면, Angular에게이 가드가 사용자의 역할에 기반하여 경로를 활성화 할 수 있는지를 결정해야한다고 말하는 것과 같습니다. 이 경우 사용자의 역할을 확인하는 사용자 정의 로직을 검사합니다.</p>
<p>CanActivate 인터페이스를 구현하려면, 경로를 활성화 할 수 있는지(true) 아니면 할 수 없는지(false)를 나타내는 boolean 또는 boolean을 해결하는 observable 또는 promise를 반환하는 canActivate 메서드를 제공해야합니다. canActivate 메서드가 false를 반환하면, 탐색이 취소되고 사용자가 경로에 액세스하는 것이 방지됩니다.</p>
<div class="content-ad"></div>
<p>사용자의 역할을 확인하여 canActivate 메서드 내에서 특정 라우트에 대한 액세스를 제어할 수 있습니다. 예를 들어 응용 프로그램에 관리자 영역이 있다면, 사용자가 관리자인지 확인하는 canActivate 메서드가 포함된 RoleGuard를 사용하여 액세스를 허용하기 전에 확인할 수 있습니다. 사용자가 관리자가 아닌 경우 가드가 false를 반환하고 탐색이 취소되어 권한이없는 액세스를 방지합니다.</p>
<p>특정 라우트에 대한 액세스를 제어하는 유연하고 안전한 방식을 제공하기 위해 RoleGuard를 수정하여 CanActivate 인터페이스를 구현하고 사용자의 역할을 확인해야합니다. 이는 Angular 응용 프로그램 내에서 사용자 역할이나 권한에 따라 액세스 제어하는 방식입니다.</p>
<h2>단계 3: 관리자만 액세스할 수 있는 관리자 구성 요소 생성</h2>
<pre><code class="hljs language-js">ng generate component admin
</code></pre>
<div class="content-ad"></div>
<h2>단계 4: AppRoutingModule에 관리자 컴포넌트를 위한 새 경로를 추가하고 RoleGuard를 canActivate 가드로 사용하세요.</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NgModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RouterModule</span>, <span class="hljs-title class_">Routes</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/router&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AdminComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./admin/admin.component&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RoleGuard</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./role.guard&#x27;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Routes</span> = [
  <span class="hljs-comment">// ... 다른 경로들 ...</span>
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">AdminComponent</span>,
    <span class="hljs-attr">canActivate</span>: [<span class="hljs-title class_">RoleGuard</span>]
  },
];

@<span class="hljs-title class_">NgModule</span>({
  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">RouterModule</span>.<span class="hljs-title function_">forRoot</span>(routes)],
  <span class="hljs-attr">exports</span>: [<span class="hljs-title class_">RouterModule</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppRoutingModule</span> {}
</code></pre>
<h2>단계 5: 관리자 페이지로 이동하는 라우터 링크 생성하기</h2>
<pre><code class="hljs language-js">&lt;!-- app.<span class="hljs-property">component</span>.<span class="hljs-property">html</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- ... 다른 링크들 ... --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">&quot;/admin&quot;</span>&gt;</span>Admin<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span></span>
</code></pre>
<div class="content-ad"></div>
<p>그걸로 끝이에요! ‘admin’ 역할을 가진 사용자만 관리자 경로에 액세스할 수 있고, 다른 사용자는 홈페이지로 리디렉트됩니다.</p>
<h1>레시피 3: 404 오류 및 리디렉션 처리</h1>
<p>언젠가는 사용자가 리디렉트나 404 에러를 만나게 될 것이고, 이를 다룰 필요가 있을 겁니다. 다음은 그 방법입니다.</p>
<h2>단계 1: 존재하지 않는 경로에 방문한 사용자에게 표시될 NotFoundComponent를 생성하세요</h2>
<div class="content-ad"></div>
<pre><code class="hljs language-js">ng generate component not-found
</code></pre>
<h2>Step 2: NotFoundComponent 템플릿을 수정하여 친근한 에러 메시지를 표시하도록 사용자 정의하기</h2>
<pre><code class="hljs language-js">&lt;!-- not-found.<span class="hljs-property">component</span>.<span class="hljs-property">html</span> --&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>이런!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>찾고 있는 페이지가 없는 것 같아요.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>홈페이지로 돌아가기<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>
</code></pre>
<h2>Step 3: AppRoutingModule에 NotFoundComponent를 위한 라우트 추가하기.</h2>
<div class="content-ad"></div>
<p>모든 일치하지 않는 경로를 캐치할 수 있는 ** 경로와 와일드카드 라우트를 사용할 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">NgModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RouterModule</span>, <span class="hljs-title class_">Routes</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/router&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">NotFoundComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./not-found/not-found.component&#x27;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Routes</span> = [
  <span class="hljs-comment">// ... 다른 라우트 ...</span>
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;**&#x27;</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">NotFoundComponent</span>
  },
];

@<span class="hljs-title class_">NgModule</span>({
  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">RouterModule</span>.<span class="hljs-title function_">forRoot</span>(routes)],
  <span class="hljs-attr">exports</span>: [<span class="hljs-title class_">RouterModule</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppRoutingModule</span> {}
</code></pre>
<p>이 설정을 사용하면 사용자가 존재하지 않는 경로로 이동할 때마다 NotFoundComponent가 표시됩니다.</p>
<h1>그렇다면 리다이렉트는 어떻게 하죠?</h1>
<div class="content-ad"></div>
<p>예전 경로에서 새 경로로 사용자를 리디렉션하고 싶을 때 AppRoutingModule에 리디렉트 경로를 추가하여 이 작업을 수행할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Routes</span> = [
   <span class="hljs-comment">// ... 다른 경로들 ...</span>
   {
     <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;old-route&#x27;</span>,
     <span class="hljs-attr">redirectTo</span>: <span class="hljs-string">&#x27;/new-route&#x27;</span>,
     <span class="hljs-attr">pathMatch</span>: <span class="hljs-string">&#x27;full&#x27;</span>
   },
   {
     <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;**&#x27;</span>,
     <span class="hljs-attr">component</span>: <span class="hljs-title class_">NotFoundComponent</span>
   },
 ];
</code></pre>
<p>이 예제에서 /old-route를 방문하는 사용자는 /new-route로 리디렉션이 됩니다. pathMatch: <code>full</code> 옵션은 전체 URL 경로가 일치해야 리디렉션이 발생합니다.</p>
<p>다양한 리디렉트 유형에 대한 설명은 다음과 같습니다.</p>
<div class="content-ad"></div>
<h2>기본 리다이렉트</h2>
<p>기본적으로는 방금 한 것과 똑같지만 목록을 대충 훑는 사람들을 위해 여기에 가져 두는 게 좋다고요.</p>
<pre><code class="hljs language-js">{
   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;old-page&#x27;</span>,
   <span class="hljs-attr">redirectTo</span>: <span class="hljs-string">&#x27;/new-page&#x27;</span>,
   <span class="hljs-attr">pathMatch</span>: <span class="hljs-string">&#x27;full&#x27;</span>
}
</code></pre>
<h2>매개변수를 사용한 리다이렉트</h2>
<div class="content-ad"></div>
<pre><code class="hljs language-js">{
   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;user/:userId/profile&#x27;</span>,
   <span class="hljs-attr">redirectTo</span>: <span class="hljs-string">&#x27;/profile/:userId&#x27;</span>,
   <span class="hljs-attr">pathMatch</span>: <span class="hljs-string">&#x27;full&#x27;</span>
 }
</code></pre>
<p>이 경우, /user/123/profile을 방문하는 사용자는 /profile/123로 리디렉션이 됩니다. 경로의 <div></div> 매개변수가 자동으로 새 경로로 전달됩니다.</p>
<h2>와일드카드를 사용한 리디렉션</h2>
<pre><code class="hljs language-js">{
   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;legacy/**&#x27;</span>,
   <span class="hljs-attr">redirectTo</span>: <span class="hljs-string">&#x27;/new-section&#x27;</span>
 }
</code></pre>
<div class="content-ad"></div>
<p>/legacy/로 시작하는 모든 경로를 방문하는 사용자(e.g., /legacy/some-page, /legacy/another-page)들은 /new-section으로 리디렉션됩니다. ** 와일드카드는 legacy/ 뒤의 모든 하위 경로와 일치시키기 위해 사용됩니다.</p>
<h2>쿼리 매개변수와 함께 리디렉션하기</h2>
<p>쿼리 매개변수를 유지하면서 리디렉션하기 위해서 컴포넌트의 로직을 수정해야 합니다. 다음은 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ActivatedRoute</span>, <span class="hljs-title class_">Router</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/router&#x27;</span>;

 <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private route: ActivatedRoute, private router: Router</span>) {}
 
 <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {
   <span class="hljs-keyword">const</span> queryParams = <span class="hljs-variable language_">this</span>.<span class="hljs-property">route</span>.<span class="hljs-property">snapshot</span>.<span class="hljs-property">queryParams</span>;
   <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-title function_">navigate</span>([<span class="hljs-string">&#x27;/new-route&#x27;</span>], { queryParams });
 }
</code></pre>
<div class="content-ad"></div>
<p>이 예시에서는 이전 경로와 관련된 컴포넌트가 초기화될 때 현재 쿼리 매개변수를 읽고, 쿼리 매개변수를 보존한 채 새 경로로 이동합니다.</p>
<h2>조건부 리디렉션</h2>
<p>조건부 리디렉션을 수행하려면 Route Guards를 사용할 수 있습니다. 이전 예시에서 RoleGuard로 보여졌듯이 사용자 지정 Route Guard를 생성하여 특정 조건을 확인하고 그에 따라 리디렉션할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CanActivate</span>, <span class="hljs-title class_">ActivatedRouteSnapshot</span>, <span class="hljs-title class_">RouterStateSnapshot</span>, <span class="hljs-title class_">Router</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/router&#x27;</span>;

@<span class="hljs-title class_">Injectable</span>({
  <span class="hljs-attr">providedIn</span>: <span class="hljs-string">&#x27;root&#x27;</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionalRedirectGuard</span> implements <span class="hljs-title class_">CanActivate</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private router: Router</span>) {}

  <span class="hljs-title function_">canActivate</span>(<span class="hljs-attr">route</span>: <span class="hljs-title class_">ActivatedRouteSnapshot</span>, <span class="hljs-attr">state</span>: <span class="hljs-title class_">RouterStateSnapshot</span>): boolean {
    <span class="hljs-keyword">const</span> condition = <span class="hljs-comment">// 여러분의 사용자 정의 조건;</span>

    <span class="hljs-keyword">if</span> (condition) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-title function_">navigate</span>([<span class="hljs-string">&#x27;/new-route&#x27;</span>]);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
}
</code></pre>
<div class="content-ad"></div>
<p>그럼, 다음 가드를 라우트 구성에 사용해 보세요:</p>
<pre><code class="hljs language-js">{
   <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;some-page&#x27;</span>,
   <span class="hljs-attr">component</span>: <span class="hljs-title class_">SomePageComponent</span>,
   <span class="hljs-attr">canActivate</span>: [<span class="hljs-title class_">ConditionalRedirectGuard</span>]
 }
</code></pre>
<h1>마무리</h1>
<p>거의 다 다룬 것 같아요. 이 내용이 유용하게 사용되기를 바라요. Angular 라우팅에는 여기서 다룬 것 이외에도 보안 취약점을 다루고 앱을 망가뜨리는 것을 방지하는 방법 등이 있어요. 하지만 아마도 그건 다음에 해보죠. 지금은 Angular 라우트를 구현하는 방법, 조각으로 만들어둔 레시피에 대해 이야기해 봤어요.</p>
<div class="content-ad"></div>
<p>끝까지 와 주셔서 감사합니다!</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"앵귤러 라우트를 제대로 사용하는 방법 3가지","description":"","date":"2024-05-17 20:22","slug":"2024-05-17-3KeyRecipestoNavigateYourAngularRoutes","content":"\n\n![Angular](/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png)\n\n정직하게 말하자면, 나는 Angular과 사랑과 미움이 공존하는 관계를 가지고 있어. 모든 것이 제대로 작동할 때는 정말 멋져. 그렇지만 그렇지 않고 나에게 힌트나 '더 어려운' 자료가 없는 경우, 그때는 너무나 짜증이 나.\n\n하지만 결국, 어떤 라이브러리, 프레임워크 또는 구글에 직면한 직관적인 답변이 없는 이상한 오류도 마찬가지로 그렇다.\n\n많은 사람들에게 Angular 라우팅은 포기하고 싶게 만드는 문제다. 일부로, 온라인 튜토리얼 중 많은 것들이 기본 라우트를 구현하는 예제들뿐이기 때문이다. 복잡한 시나리오에 적합한 것을 찾는 것은 갑자기 시간 소모적인 시행착오 과정이 될 수 있다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앵귤러는 프레임워크이기 때문에 내재적으로 이해하는 데 시간이 걸릴 수 있어도 라우팅 방식이 구현되는 방식은 때로는 지루하게 느껴질 수 있습니다. 그러나 이해하고 난 뒤에는 실제로 과소평가된 보석이라고 생각해요.\n\n리액트와 같은 것과 비교해보면, 리액트는 다양한 방법론의 아드혹 패치워크일 수 있지만, 앵귤러의 '이게 우리가 하는 방식이다' 접근 방식은 여러 팀 간 협업 시 덜 괴로울 수 있어요.\n\n앵귤러에서는 라우트를 별도 모듈(일반적으로 AppRoutingModule)에서 정의하고 RouterModule.forRoot() 메서드를 사용하여 라우트를 등록해요. 라우트는 객체 배열로 정의되며, 각 객체는 경로와 연결된 컴포넌트를 포함해요. 반면 리액트에서는 라우트가 Route, Switch, BrowserRouter와 같은 React Router 라이브러리에서 제공되는 컴포넌트를 사용하여 정의돼요. 이러한 컴포넌트들은 JSX 코드 내에서 직접 사용되며, 라우트 구성이 더 선언적이에요.\n\n앵귤러 라우팅의 장점(AppRoutingModule 및 RouterModule.forRoot()을 통해)은 구성이 중앙 집중화되어 있고 강력한 타입 지정으로 일관된 접근 방식을 제공한다는 점이에요. 반면, 리액트 라우팅(Route, Switch, BrowserRouter 컴포넌트를 통해)은 중앙 집중화가 부족하고 내장된 유형 확인이 없으며, 일관성 부족으로 인한 높은 불일치가 발생할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 이야기는 여기까지 하고, 본문의 요점으로 넘어가 봅시다. 이 글에서 다루는 Angular 라우팅 시나리오/레시피 중 가장 중요한 것은 바로 세 가지입니다. 이 세 가지는 모든 앱 개발 작업과 프로젝트를 다루며, 이해하기 어려웠던 부분을 간단하게 설명해줬으면 했던 것들입니다.\n\n# 레시피 1: 여러 수준과 동적 경로를 가진 중첩 라우팅\n\nAngular 라우트에서 동적 경로를 가진 다중 수준의 탐색 구조는 정보가 층층이 쌓인 정체를 푸는 것 같은 신비한 상자와 같은 느낌을 줄 수 있습니다.\n\n라우팅을 처음 배울 때, 우리는 종종 한 수준에서 시작하여 종료하는, 다음 페이지로 이동하고 다시 돌아오는 정도의 시나리오로 끝나곤 합니다. 하지만 90년대가 아니라는 것을 기억해야 합니다. 실제로 레알 앱/사이트는 카테고리, 서브카테고리, 사용자가 작성한 콘텐츠를 통해 동적 경로로 이어지는 필수 요소들이 많습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시를 위해 상상해 봅시다. 우리는 그것만 있는 전자상거래 애플리케이션을 개발하고 있다고 상상해 봅시다.\n\n## 단계 1: 카테고리, 하위 카테고리 및 제품 컴포넌트를 생성합시다\n\n```js\nng generate component category\nng generate component subcategory\nng generate component product\n```\n\n## 단계 2: AppRoutingModule에서 라우트를 정의합시다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { CategoryComponent } from './category/category.component';\nimport { SubcategoryComponent } from './subcategory/subcategory.component';\nimport { ProductComponent } from './product/product.component';\n\nconst routes: Routes = [\n  {\n    path: 'category/:categoryId',\n    component: CategoryComponent,\n    children: [\n      {\n        path: 'subcategory/:subcategoryId',\n        component: SubcategoryComponent,\n        children: [\n          {\n            path: 'product/:productId',\n            component: ProductComponent,\n          },\n        ],\n      },\n    ],\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n위 예제에서는 전자 상거래 앱의 각 수준에 대한 경로를 정의했습니다. 경로에서 :categoryId, :subcategoryId 및 :productId 자리 표시 자를 사용한 점에 주목하세요. 이러한 세그먼트는 앱을 통해 탐색할 때 실제 값으로 대체됩니다.\n\n## 단계 3: 컴포넌트 템플릿에 라우터 아웃렛을 추가하여 Angular이 자식 컴포넌트를 렌더링할 위치를 알 수 있도록 합니다:\n\n```js\n\u003c!-- category.component.html --\u003e\n\u003ch1\u003eCategory\u003c/h1\u003e\n\u003crouter-outlet\u003e\u003c/router-outlet\u003e\n\n\u003c!-- subcategory.component.html --\u003e\n\u003ch2\u003eSubcategory\u003c/h2\u003e\n\u003crouter-outlet\u003e\u003c/router-outlet\u003e\n\n\u003c!-- product.component.html --\u003e\n\u003ch3\u003eProduct\u003c/h3\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 4: 앱을 통해 이동할 수 있는 몇 가지 라우터 링크를 생성합니다\n\n```js\n\u003c!-- app.component.html --\u003e\n \u003cnav\u003e\n   \u003cul\u003e\n     \u003cli *ngFor=\"let category of categories\"\u003e\n       \u003ca [routerLink]=\"['/category', category.id]\"\u003e{ category.name }\u003c/a\u003e\n     \u003c/li\u003e\n   \u003c/ul\u003e\n \u003c/nav\u003e\n \u003crouter-outlet\u003e\u003c/router-outlet\u003e\n \n```\n\n이 예에서는 카테고리 배열이 id와 name 속성이 있는 카테고리 데이터를 포함하고 있다고 가정합니다. [routerLink] 지시문은 카테고리, 하위 카테고리 및 제품을 통해 이동할 때 적절한 URL을 생성합니다.\n\n그게 다입니다! 이제 다중 수준 및 동적 경로를 포함하는 중첩 라우팅 구조의 기본 뼈대가 완성되었습니다. 사용자는 이제 카테고리, 하위 카테고리, 제품을 손쉽게 탐색할 수 있으며 앱의 구조는 깔끔하고 조직적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 레시피 2: 라우트 가드 및 역할 기반 액세스와 canActivate\n\n오케이, 멋져요. 중첩된 내용들이 있고, 특정 사람들에게만 보기 권한을 부여하고 특정 작업을 할 수 있게끔 하는 건 어떻게 하는지 궁금하신가요? 예를 들어, 사용자들?\n\n이것이 바로 canActivate 및 RoleGuard의 역할입니다.\n\nAngular에서 역할 기반 액세스 제어를 구현하는 데 Route guards와 canActivate 가드를 사용할 수 있습니다. 이를 통해 응용 프로그램의 특정 부분에 대한 액세스 권한이 있는 사용자만 해당 부분에 액세스할 수 있도록 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반 사용자와 관리자 사용자가 있는 응용 프로그램을 개발 중이라고 상상해 봅시다. 이제 사용자의 역할에 따라 특정 경로로의 액세스를 제한하려고 합니다. 이를 위해 RoleGuard라는 사용자 지정 라우트 가드를 만들 수 있습니다.\n\n## 단계 1: RoleGuard 생성\n\n```js\nng generate guard role\n```\n\n## 단계 2: RoleGuard를 생성하고 CanActivate 인터페이스를 구현하여 사용자의 역할을 확인하도록 수정하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예시에서는 사용자 역할을 확인하고 해당 사용자가 관리자인 경우 true를 반환합니다. 사용자가 관리자가 아닌 경우 홈 페이지로 리디렉션하고 false를 반환합니다.\n\nRoleGuard를 CanActivate 인터페이스를 구현하도록 수정하면, Angular에게이 가드가 사용자의 역할에 기반하여 경로를 활성화 할 수 있는지를 결정해야한다고 말하는 것과 같습니다. 이 경우 사용자의 역할을 확인하는 사용자 정의 로직을 검사합니다.\n\nCanActivate 인터페이스를 구현하려면, 경로를 활성화 할 수 있는지(true) 아니면 할 수 없는지(false)를 나타내는 boolean 또는 boolean을 해결하는 observable 또는 promise를 반환하는 canActivate 메서드를 제공해야합니다. canActivate 메서드가 false를 반환하면, 탐색이 취소되고 사용자가 경로에 액세스하는 것이 방지됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자의 역할을 확인하여 canActivate 메서드 내에서 특정 라우트에 대한 액세스를 제어할 수 있습니다. 예를 들어 응용 프로그램에 관리자 영역이 있다면, 사용자가 관리자인지 확인하는 canActivate 메서드가 포함된 RoleGuard를 사용하여 액세스를 허용하기 전에 확인할 수 있습니다. 사용자가 관리자가 아닌 경우 가드가 false를 반환하고 탐색이 취소되어 권한이없는 액세스를 방지합니다.\n\n특정 라우트에 대한 액세스를 제어하는 유연하고 안전한 방식을 제공하기 위해 RoleGuard를 수정하여 CanActivate 인터페이스를 구현하고 사용자의 역할을 확인해야합니다. 이는 Angular 응용 프로그램 내에서 사용자 역할이나 권한에 따라 액세스 제어하는 방식입니다.\n\n## 단계 3: 관리자만 액세스할 수 있는 관리자 구성 요소 생성\n\n```js\nng generate component admin\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 4: AppRoutingModule에 관리자 컴포넌트를 위한 새 경로를 추가하고 RoleGuard를 canActivate 가드로 사용하세요.\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { AdminComponent } from './admin/admin.component';\nimport { RoleGuard } from './role.guard';\n\nconst routes: Routes = [\n  // ... 다른 경로들 ...\n  {\n    path: 'admin',\n    component: AdminComponent,\n    canActivate: [RoleGuard]\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n## 단계 5: 관리자 페이지로 이동하는 라우터 링크 생성하기\n\n```js\n\u003c!-- app.component.html --\u003e\n\u003cnav\u003e\n  \u003cul\u003e\n    \u003c!-- ... 다른 링크들 ... --\u003e\n    \u003cli\u003e\n      \u003ca routerLink=\"/admin\"\u003eAdmin\u003c/a\u003e\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/nav\u003e\n\u003crouter-outlet\u003e\u003c/router-outlet\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그걸로 끝이에요! ‘admin’ 역할을 가진 사용자만 관리자 경로에 액세스할 수 있고, 다른 사용자는 홈페이지로 리디렉트됩니다.\n\n# 레시피 3: 404 오류 및 리디렉션 처리\n\n언젠가는 사용자가 리디렉트나 404 에러를 만나게 될 것이고, 이를 다룰 필요가 있을 겁니다. 다음은 그 방법입니다.\n\n## 단계 1: 존재하지 않는 경로에 방문한 사용자에게 표시될 NotFoundComponent를 생성하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nng generate component not-found\n```\n\n## Step 2: NotFoundComponent 템플릿을 수정하여 친근한 에러 메시지를 표시하도록 사용자 정의하기\n\n```js\n\u003c!-- not-found.component.html --\u003e\n\u003ch1\u003e이런!\u003c/h1\u003e\n\u003cp\u003e찾고 있는 페이지가 없는 것 같아요.\u003c/p\u003e\n\u003ca routerLink=\"/\"\u003e홈페이지로 돌아가기\u003c/a\u003e\n```\n\n## Step 3: AppRoutingModule에 NotFoundComponent를 위한 라우트 추가하기.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 일치하지 않는 경로를 캐치할 수 있는 ** 경로와 와일드카드 라우트를 사용할 것입니다.\n\n```js\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { NotFoundComponent } from './not-found/not-found.component';\n\nconst routes: Routes = [\n  // ... 다른 라우트 ...\n  {\n    path: '**',\n    component: NotFoundComponent\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n이 설정을 사용하면 사용자가 존재하지 않는 경로로 이동할 때마다 NotFoundComponent가 표시됩니다.\n\n# 그렇다면 리다이렉트는 어떻게 하죠?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예전 경로에서 새 경로로 사용자를 리디렉션하고 싶을 때 AppRoutingModule에 리디렉트 경로를 추가하여 이 작업을 수행할 수 있습니다:\n\n```js\nconst routes: Routes = [\n   // ... 다른 경로들 ...\n   {\n     path: 'old-route',\n     redirectTo: '/new-route',\n     pathMatch: 'full'\n   },\n   {\n     path: '**',\n     component: NotFoundComponent\n   },\n ];\n```\n\n이 예제에서 /old-route를 방문하는 사용자는 /new-route로 리디렉션이 됩니다. pathMatch: `full` 옵션은 전체 URL 경로가 일치해야 리디렉션이 발생합니다.\n\n다양한 리디렉트 유형에 대한 설명은 다음과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기본 리다이렉트\n\n기본적으로는 방금 한 것과 똑같지만 목록을 대충 훑는 사람들을 위해 여기에 가져 두는 게 좋다고요.\n\n```js\n{\n   path: 'old-page',\n   redirectTo: '/new-page',\n   pathMatch: 'full'\n}\n```\n\n## 매개변수를 사용한 리다이렉트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n   path: 'user/:userId/profile',\n   redirectTo: '/profile/:userId',\n   pathMatch: 'full'\n }\n```\n\n이 경우, /user/123/profile을 방문하는 사용자는 /profile/123로 리디렉션이 됩니다. 경로의 :userId 매개변수가 자동으로 새 경로로 전달됩니다.\n\n## 와일드카드를 사용한 리디렉션\n\n```js\n{\n   path: 'legacy/**',\n   redirectTo: '/new-section'\n }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n/legacy/로 시작하는 모든 경로를 방문하는 사용자(e.g., /legacy/some-page, /legacy/another-page)들은 /new-section으로 리디렉션됩니다. ** 와일드카드는 legacy/ 뒤의 모든 하위 경로와 일치시키기 위해 사용됩니다.\n\n## 쿼리 매개변수와 함께 리디렉션하기\n\n쿼리 매개변수를 유지하면서 리디렉션하기 위해서 컴포넌트의 로직을 수정해야 합니다. 다음은 예시입니다:\n\n```js\nimport { ActivatedRoute, Router } from '@angular/router';\n\n constructor(private route: ActivatedRoute, private router: Router) {}\n \n ngOnInit() {\n   const queryParams = this.route.snapshot.queryParams;\n   this.router.navigate(['/new-route'], { queryParams });\n }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 이전 경로와 관련된 컴포넌트가 초기화될 때 현재 쿼리 매개변수를 읽고, 쿼리 매개변수를 보존한 채 새 경로로 이동합니다.\n\n## 조건부 리디렉션\n\n조건부 리디렉션을 수행하려면 Route Guards를 사용할 수 있습니다. 이전 예시에서 RoleGuard로 보여졌듯이 사용자 지정 Route Guard를 생성하여 특정 조건을 확인하고 그에 따라 리디렉션할 수 있습니다.\n\n```js\nimport { Injectable } from '@angular/core';\nimport { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from '@angular/router';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ConditionalRedirectGuard implements CanActivate {\n  constructor(private router: Router) {}\n\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {\n    const condition = // 여러분의 사용자 정의 조건;\n\n    if (condition) {\n      this.router.navigate(['/new-route']);\n      return false;\n    }\n\n    return true;\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼, 다음 가드를 라우트 구성에 사용해 보세요:\n\n```js\n{\n   path: 'some-page',\n   component: SomePageComponent,\n   canActivate: [ConditionalRedirectGuard]\n }\n```\n\n# 마무리\n\n거의 다 다룬 것 같아요. 이 내용이 유용하게 사용되기를 바라요. Angular 라우팅에는 여기서 다룬 것 이외에도 보안 취약점을 다루고 앱을 망가뜨리는 것을 방지하는 방법 등이 있어요. 하지만 아마도 그건 다음에 해보죠. 지금은 Angular 라우트를 구현하는 방법, 조각으로 만들어둔 레시피에 대해 이야기해 봤어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n끝까지 와 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png"},"coverImage":"/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png","tag":["Tech"],"readingTime":11},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    div: \"div\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-3KeyRecipestoNavigateYourAngularRoutes_0.png\",\n        alt: \"Angular\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정직하게 말하자면, 나는 Angular과 사랑과 미움이 공존하는 관계를 가지고 있어. 모든 것이 제대로 작동할 때는 정말 멋져. 그렇지만 그렇지 않고 나에게 힌트나 '더 어려운' 자료가 없는 경우, 그때는 너무나 짜증이 나.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 결국, 어떤 라이브러리, 프레임워크 또는 구글에 직면한 직관적인 답변이 없는 이상한 오류도 마찬가지로 그렇다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"많은 사람들에게 Angular 라우팅은 포기하고 싶게 만드는 문제다. 일부로, 온라인 튜토리얼 중 많은 것들이 기본 라우트를 구현하는 예제들뿐이기 때문이다. 복잡한 시나리오에 적합한 것을 찾는 것은 갑자기 시간 소모적인 시행착오 과정이 될 수 있다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"앵귤러는 프레임워크이기 때문에 내재적으로 이해하는 데 시간이 걸릴 수 있어도 라우팅 방식이 구현되는 방식은 때로는 지루하게 느껴질 수 있습니다. 그러나 이해하고 난 뒤에는 실제로 과소평가된 보석이라고 생각해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리액트와 같은 것과 비교해보면, 리액트는 다양한 방법론의 아드혹 패치워크일 수 있지만, 앵귤러의 '이게 우리가 하는 방식이다' 접근 방식은 여러 팀 간 협업 시 덜 괴로울 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"앵귤러에서는 라우트를 별도 모듈(일반적으로 AppRoutingModule)에서 정의하고 RouterModule.forRoot() 메서드를 사용하여 라우트를 등록해요. 라우트는 객체 배열로 정의되며, 각 객체는 경로와 연결된 컴포넌트를 포함해요. 반면 리액트에서는 라우트가 Route, Switch, BrowserRouter와 같은 React Router 라이브러리에서 제공되는 컴포넌트를 사용하여 정의돼요. 이러한 컴포넌트들은 JSX 코드 내에서 직접 사용되며, 라우트 구성이 더 선언적이에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"앵귤러 라우팅의 장점(AppRoutingModule 및 RouterModule.forRoot()을 통해)은 구성이 중앙 집중화되어 있고 강력한 타입 지정으로 일관된 접근 방식을 제공한다는 점이에요. 반면, 리액트 라우팅(Route, Switch, BrowserRouter 컴포넌트를 통해)은 중앙 집중화가 부족하고 내장된 유형 확인이 없으며, 일관성 부족으로 인한 높은 불일치가 발생할 수 있어요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 이야기는 여기까지 하고, 본문의 요점으로 넘어가 봅시다. 이 글에서 다루는 Angular 라우팅 시나리오/레시피 중 가장 중요한 것은 바로 세 가지입니다. 이 세 가지는 모든 앱 개발 작업과 프로젝트를 다루며, 이해하기 어려웠던 부분을 간단하게 설명해줬으면 했던 것들입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"레시피 1: 여러 수준과 동적 경로를 가진 중첩 라우팅\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Angular 라우트에서 동적 경로를 가진 다중 수준의 탐색 구조는 정보가 층층이 쌓인 정체를 푸는 것 같은 신비한 상자와 같은 느낌을 줄 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"라우팅을 처음 배울 때, 우리는 종종 한 수준에서 시작하여 종료하는, 다음 페이지로 이동하고 다시 돌아오는 정도의 시나리오로 끝나곤 합니다. 하지만 90년대가 아니라는 것을 기억해야 합니다. 실제로 레알 앱/사이트는 카테고리, 서브카테고리, 사용자가 작성한 콘텐츠를 통해 동적 경로로 이어지는 필수 요소들이 많습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예시를 위해 상상해 봅시다. 우리는 그것만 있는 전자상거래 애플리케이션을 개발하고 있다고 상상해 봅시다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단계 1: 카테고리, 하위 카테고리 및 제품 컴포넌트를 생성합시다\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"ng generate component category\\nng generate component subcategory\\nng generate component product\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단계 2: AppRoutingModule에서 라우트를 정의합시다\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NgModule\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/core'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RouterModule\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Routes\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/router'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"CategoryComponent\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./category/category.component'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SubcategoryComponent\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./subcategory/subcategory.component'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductComponent\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./product/product.component'\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"routes\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Routes\"\n        }), \" = [\\n  {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"path\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'category/:categoryId'\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"component\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"CategoryComponent\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"children\"\n        }), \": [\\n      {\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"path\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'subcategory/:subcategoryId'\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"component\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SubcategoryComponent\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"children\"\n        }), \": [\\n          {\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"path\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'product/:productId'\"\n        }), \",\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"component\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductComponent\"\n        }), \",\\n          },\\n        ],\\n      },\\n    ],\\n  },\\n];\\n\\n@\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NgModule\"\n        }), \"({\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"imports\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RouterModule\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"forRoot\"\n        }), \"(routes)],\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"exports\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RouterModule\"\n        }), \"],\\n})\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"AppRoutingModule\"\n        }), \" {}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"위 예제에서는 전자 상거래 앱의 각 수준에 대한 경로를 정의했습니다. 경로에서 \", _jsx(_components.div, {}), \", \", _jsx(_components.div, {}), \" 및 \", _jsx(_components.div, {}), \" 자리 표시 자를 사용한 점에 주목하세요. 이러한 세그먼트는 앱을 통해 탐색할 때 실제 값으로 대체됩니다.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단계 3: 컴포넌트 템플릿에 라우터 아웃렛을 추가하여 Angular이 자식 컴포넌트를 렌더링할 위치를 알 수 있도록 합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003c!-- category.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"component\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"html\"\n        }), \" --\u003e\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \"\u003e\"]\n          }), \"Category\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"router-outlet\"\n            }), \"\u003e\"]\n          }), _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"router-outlet\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\\n\u003c!-- subcategory.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"component\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"html\"\n        }), \" --\u003e\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h2\"\n            }), \"\u003e\"]\n          }), \"Subcategory\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h2\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"router-outlet\"\n            }), \"\u003e\"]\n          }), _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"router-outlet\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\\n\u003c!-- product.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"component\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"html\"\n        }), \" --\u003e\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h3\"\n            }), \"\u003e\"]\n          }), \"Product\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h3\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단계 4: 앱을 통해 이동할 수 있는 몇 가지 라우터 링크를 생성합니다\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003c!-- app.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"component\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"html\"\n        }), \" --\u003e\\n \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"nav\"\n            }), \"\u003e\"]\n          }), \"\\n   \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"ul\"\n            }), \"\u003e\"]\n          }), \"\\n     \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"li\"\n            }), \" *\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"ngFor\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"let category of categories\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n       \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \" [\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"routerLink\"\n            }), \"]=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"['/category', category.id]\\\"\"\n            }), \"\u003e\"]\n          }), \"{ category.name }\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \"\u003e\"]\n          }), \"\\n     \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"li\"\n            }), \"\u003e\"]\n          }), \"\\n   \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"ul\"\n            }), \"\u003e\"]\n          }), \"\\n \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"nav\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"router-outlet\"\n            }), \"\u003e\"]\n          }), _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"router-outlet\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n \\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예에서는 카테고리 배열이 id와 name 속성이 있는 카테고리 데이터를 포함하고 있다고 가정합니다. [routerLink] 지시문은 카테고리, 하위 카테고리 및 제품을 통해 이동할 때 적절한 URL을 생성합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그게 다입니다! 이제 다중 수준 및 동적 경로를 포함하는 중첩 라우팅 구조의 기본 뼈대가 완성되었습니다. 사용자는 이제 카테고리, 하위 카테고리, 제품을 손쉽게 탐색할 수 있으며 앱의 구조는 깔끔하고 조직적입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"레시피 2: 라우트 가드 및 역할 기반 액세스와 canActivate\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오케이, 멋져요. 중첩된 내용들이 있고, 특정 사람들에게만 보기 권한을 부여하고 특정 작업을 할 수 있게끔 하는 건 어떻게 하는지 궁금하신가요? 예를 들어, 사용자들?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것이 바로 canActivate 및 RoleGuard의 역할입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Angular에서 역할 기반 액세스 제어를 구현하는 데 Route guards와 canActivate 가드를 사용할 수 있습니다. 이를 통해 응용 프로그램의 특정 부분에 대한 액세스 권한이 있는 사용자만 해당 부분에 액세스할 수 있도록 할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"일반 사용자와 관리자 사용자가 있는 응용 프로그램을 개발 중이라고 상상해 봅시다. 이제 사용자의 역할에 따라 특정 경로로의 액세스를 제한하려고 합니다. 이를 위해 RoleGuard라는 사용자 지정 라우트 가드를 만들 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단계 1: RoleGuard 생성\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"ng generate guard role\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단계 2: RoleGuard를 생성하고 CanActivate 인터페이스를 구현하여 사용자의 역할을 확인하도록 수정하세요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 예시에서는 사용자 역할을 확인하고 해당 사용자가 관리자인 경우 true를 반환합니다. 사용자가 관리자가 아닌 경우 홈 페이지로 리디렉션하고 false를 반환합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RoleGuard를 CanActivate 인터페이스를 구현하도록 수정하면, Angular에게이 가드가 사용자의 역할에 기반하여 경로를 활성화 할 수 있는지를 결정해야한다고 말하는 것과 같습니다. 이 경우 사용자의 역할을 확인하는 사용자 정의 로직을 검사합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"CanActivate 인터페이스를 구현하려면, 경로를 활성화 할 수 있는지(true) 아니면 할 수 없는지(false)를 나타내는 boolean 또는 boolean을 해결하는 observable 또는 promise를 반환하는 canActivate 메서드를 제공해야합니다. canActivate 메서드가 false를 반환하면, 탐색이 취소되고 사용자가 경로에 액세스하는 것이 방지됩니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자의 역할을 확인하여 canActivate 메서드 내에서 특정 라우트에 대한 액세스를 제어할 수 있습니다. 예를 들어 응용 프로그램에 관리자 영역이 있다면, 사용자가 관리자인지 확인하는 canActivate 메서드가 포함된 RoleGuard를 사용하여 액세스를 허용하기 전에 확인할 수 있습니다. 사용자가 관리자가 아닌 경우 가드가 false를 반환하고 탐색이 취소되어 권한이없는 액세스를 방지합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"특정 라우트에 대한 액세스를 제어하는 유연하고 안전한 방식을 제공하기 위해 RoleGuard를 수정하여 CanActivate 인터페이스를 구현하고 사용자의 역할을 확인해야합니다. 이는 Angular 응용 프로그램 내에서 사용자 역할이나 권한에 따라 액세스 제어하는 방식입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단계 3: 관리자만 액세스할 수 있는 관리자 구성 요소 생성\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"ng generate component admin\\n\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단계 4: AppRoutingModule에 관리자 컴포넌트를 위한 새 경로를 추가하고 RoleGuard를 canActivate 가드로 사용하세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NgModule\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/core'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RouterModule\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Routes\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/router'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"AdminComponent\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./admin/admin.component'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RoleGuard\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./role.guard'\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"routes\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Routes\"\n        }), \" = [\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ... 다른 경로들 ...\"\n        }), \"\\n  {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"path\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'admin'\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"component\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"AdminComponent\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"canActivate\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RoleGuard\"\n        }), \"]\\n  },\\n];\\n\\n@\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NgModule\"\n        }), \"({\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"imports\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RouterModule\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"forRoot\"\n        }), \"(routes)],\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"exports\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RouterModule\"\n        }), \"],\\n})\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"AppRoutingModule\"\n        }), \" {}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단계 5: 관리자 페이지로 이동하는 라우터 링크 생성하기\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003c!-- app.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"component\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"html\"\n        }), \" --\u003e\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"nav\"\n            }), \"\u003e\"]\n          }), \"\\n  \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"ul\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"\u003c!-- ... 다른 링크들 ... --\u003e\"\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"li\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"routerLink\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"/admin\\\"\"\n            }), \"\u003e\"]\n          }), \"Admin\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"li\"\n            }), \"\u003e\"]\n          }), \"\\n  \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"ul\"\n            }), \"\u003e\"]\n          }), \"\\n\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"nav\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"router-outlet\"\n            }), \"\u003e\"]\n          }), _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"router-outlet\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그걸로 끝이에요! ‘admin’ 역할을 가진 사용자만 관리자 경로에 액세스할 수 있고, 다른 사용자는 홈페이지로 리디렉트됩니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"레시피 3: 404 오류 및 리디렉션 처리\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"언젠가는 사용자가 리디렉트나 404 에러를 만나게 될 것이고, 이를 다룰 필요가 있을 겁니다. 다음은 그 방법입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단계 1: 존재하지 않는 경로에 방문한 사용자에게 표시될 NotFoundComponent를 생성하세요\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"ng generate component not-found\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Step 2: NotFoundComponent 템플릿을 수정하여 친근한 에러 메시지를 표시하도록 사용자 정의하기\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003c!-- not-found.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"component\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"html\"\n        }), \" --\u003e\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \"\u003e\"]\n          }), \"이런!\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"찾고 있는 페이지가 없는 것 같아요.\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"routerLink\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"/\\\"\"\n            }), \"\u003e\"]\n          }), \"홈페이지로 돌아가기\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Step 3: AppRoutingModule에 NotFoundComponent를 위한 라우트 추가하기.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모든 일치하지 않는 경로를 캐치할 수 있는 ** 경로와 와일드카드 라우트를 사용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NgModule\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/core'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RouterModule\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Routes\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/router'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NotFoundComponent\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./not-found/not-found.component'\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"routes\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Routes\"\n        }), \" = [\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ... 다른 라우트 ...\"\n        }), \"\\n  {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"path\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'**'\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"component\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NotFoundComponent\"\n        }), \"\\n  },\\n];\\n\\n@\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NgModule\"\n        }), \"({\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"imports\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RouterModule\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"forRoot\"\n        }), \"(routes)],\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"exports\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RouterModule\"\n        }), \"],\\n})\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"AppRoutingModule\"\n        }), \" {}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 설정을 사용하면 사용자가 존재하지 않는 경로로 이동할 때마다 NotFoundComponent가 표시됩니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"그렇다면 리다이렉트는 어떻게 하죠?\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예전 경로에서 새 경로로 사용자를 리디렉션하고 싶을 때 AppRoutingModule에 리디렉트 경로를 추가하여 이 작업을 수행할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"routes\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Routes\"\n        }), \" = [\\n   \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ... 다른 경로들 ...\"\n        }), \"\\n   {\\n     \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"path\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'old-route'\"\n        }), \",\\n     \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"redirectTo\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/new-route'\"\n        }), \",\\n     \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"pathMatch\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'full'\"\n        }), \"\\n   },\\n   {\\n     \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"path\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'**'\"\n        }), \",\\n     \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"component\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"NotFoundComponent\"\n        }), \"\\n   },\\n ];\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이 예제에서 /old-route를 방문하는 사용자는 /new-route로 리디렉션이 됩니다. pathMatch: \", _jsx(_components.code, {\n        children: \"full\"\n      }), \" 옵션은 전체 URL 경로가 일치해야 리디렉션이 발생합니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다양한 리디렉트 유형에 대한 설명은 다음과 같습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"기본 리다이렉트\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본적으로는 방금 한 것과 똑같지만 목록을 대충 훑는 사람들을 위해 여기에 가져 두는 게 좋다고요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n   \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"path\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'old-page'\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"redirectTo\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/new-page'\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"pathMatch\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'full'\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"매개변수를 사용한 리다이렉트\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n   \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"path\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'user/:userId/profile'\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"redirectTo\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/profile/:userId'\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"pathMatch\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'full'\"\n        }), \"\\n }\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이 경우, /user/123/profile을 방문하는 사용자는 /profile/123로 리디렉션이 됩니다. 경로의 \", _jsx(_components.div, {}), \" 매개변수가 자동으로 새 경로로 전달됩니다.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"와일드카드를 사용한 리디렉션\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n   \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"path\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'legacy/**'\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"redirectTo\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/new-section'\"\n        }), \"\\n }\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"/legacy/로 시작하는 모든 경로를 방문하는 사용자(e.g., /legacy/some-page, /legacy/another-page)들은 /new-section으로 리디렉션됩니다. ** 와일드카드는 legacy/ 뒤의 모든 하위 경로와 일치시키기 위해 사용됩니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"쿼리 매개변수와 함께 리디렉션하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"쿼리 매개변수를 유지하면서 리디렉션하기 위해서 컴포넌트의 로직을 수정해야 합니다. 다음은 예시입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ActivatedRoute\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Router\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/router'\"\n        }), \";\\n\\n \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"constructor\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"private route: ActivatedRoute, private router: Router\"\n        }), \") {}\\n \\n \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ngOnInit\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n   \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" queryParams = \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"route\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"snapshot\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"queryParams\"\n        }), \";\\n   \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"router\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"navigate\"\n        }), \"([\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/new-route'\"\n        }), \"], { queryParams });\\n }\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예시에서는 이전 경로와 관련된 컴포넌트가 초기화될 때 현재 쿼리 매개변수를 읽고, 쿼리 매개변수를 보존한 채 새 경로로 이동합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"조건부 리디렉션\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"조건부 리디렉션을 수행하려면 Route Guards를 사용할 수 있습니다. 이전 예시에서 RoleGuard로 보여졌듯이 사용자 지정 Route Guard를 생성하여 특정 조건을 확인하고 그에 따라 리디렉션할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Injectable\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/core'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"CanActivate\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ActivatedRouteSnapshot\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RouterStateSnapshot\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Router\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/router'\"\n        }), \";\\n\\n@\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Injectable\"\n        }), \"({\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"providedIn\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'root'\"\n        }), \"\\n})\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ConditionalRedirectGuard\"\n        }), \" implements \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"CanActivate\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"constructor\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"private router: Router\"\n        }), \") {}\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"canActivate\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"route\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ActivatedRouteSnapshot\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"state\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"RouterStateSnapshot\"\n        }), \"): boolean {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" condition = \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 여러분의 사용자 정의 조건;\"\n        }), \"\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (condition) {\\n      \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"router\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"navigate\"\n        }), \"([\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/new-route'\"\n        }), \"]);\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \";\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \";\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그럼, 다음 가드를 라우트 구성에 사용해 보세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n   \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"path\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'some-page'\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"component\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SomePageComponent\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"canActivate\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ConditionalRedirectGuard\"\n        }), \"]\\n }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"마무리\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"거의 다 다룬 것 같아요. 이 내용이 유용하게 사용되기를 바라요. Angular 라우팅에는 여기서 다룬 것 이외에도 보안 취약점을 다루고 앱을 망가뜨리는 것을 방지하는 방법 등이 있어요. 하지만 아마도 그건 다음에 해보죠. 지금은 Angular 라우트를 구현하는 방법, 조각으로 만들어둔 레시피에 대해 이야기해 봤어요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"끝까지 와 주셔서 감사합니다!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-3KeyRecipestoNavigateYourAngularRoutes"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>