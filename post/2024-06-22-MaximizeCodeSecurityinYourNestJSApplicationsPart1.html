<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>NestJS 애플리케이션의 코드 보안을 극대화하는 방법 파트 1 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="NestJS 애플리케이션의 코드 보안을 극대화하는 방법 파트 1 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="NestJS 애플리케이션의 코드 보안을 극대화하는 방법 파트 1 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1" data-gatsby-head="true"/><meta name="twitter:title" content="NestJS 애플리케이션의 코드 보안을 극대화하는 방법 파트 1 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 02:07" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">NestJS 애플리케이션의 코드 보안을 극대화하는 방법 파트 1</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="NestJS 애플리케이션의 코드 보안을 극대화하는 방법 파트 1" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>NestJS 개발자를 위한 최고의 안전한 코드 작성 방법</p>
<p><img src="/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_0.png" alt="이미지"></p>
<p>개발자로서, 우리는 모두 코드 보안이 얼마나 중요한지 알고 있습니다. Optus와 Medibank에서 발생한 최근 데이터 침해 사례는 코드 보안의 중요성을 다시 한 번 강조합니다. 그래서, 질문은 다음과 같습니다: 우리는 어떻게 안전한 코드를 작성하여 웹 애플리케이션에서 다양한 유형의 공격을 방지할 수 있을까요? 안전한 코드를 작성하기 위한 최고의 방법을 따르는 것은 취약점과 위협으로부터 우리 앱을 보호하는 데 필수적입니다.</p>
<p>우리가 어떻게 보안 위험을 방지할 수 있는지에 대해 들어가기 전에, 먼저 가장 흔한 유형의 보안 위험을 살펴보겠습니다. 이것은 우리 앱을 보호하는 과제에 대한 더 나은 이해를 제공할 것입니다.</p>
<div class="content-ad"></div>
<p>OWASP Top 10은 웹 애플리케이션의 가장 중요한 보안 위험을 널리 인정받는 목록으로, 산업 전문가들 간의 합의를 통해 결정됩니다. 아래는 2017년과 2021년의 상위 10위 위험 목록입니다.</p>
<p><img src="/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_1.png" alt="OWASP Top 10"></p>
<p>상위 10위 중 많은 것들이 웹 앱의 보안에 매우 중요합니다.</p>
<p>두 부분으로 구성된 글의 첫 번째 부분으로, 몇 가지 위험과 위험을 방지하는 데 따를 수 있는 최상의 실천 방법에 대해 설명하겠습니다.</p>
<div class="content-ad"></div>
<p>아래와 같습니다:</p>
<ul>
<li>액세스 제어 오류</li>
<li>서버 측 요청 위조 (SSRF)</li>
<li>대량 할당</li>
<li>민감한 정보 노출</li>
</ul>
<h2>액세스 제어 오류</h2>
<p>액세스 제어 오류는 가장 흔한 위험 중 하나입니다. 공격자가 무단으로 기능이나 자원에 액세스할 수 있는 경우 발생합니다. 2014년 1월 Snapchat 사건이 실제로 발생한 사례 중 하나입니다.</p>
<div class="content-ad"></div>
<p>이러한 위험을 방지하기 위해 최소 권한 원칙을 따르는 것이 중요합니다. 액세스는 기본적으로 거부되어야하며 권한은 필요한 경우에만 부여해야합니다.</p>
<p>사용자의 역할이나 권한에 기반하여 기능이나 자원에 대한 액세스를 제한하는 역할 기반 액세스 제어 (RBAC) 또는 액세스 제어 목록 (ACL)과 같은 액세스 제어 메커니즘을 사용할 수 있습니다.</p>
<p>다음은 NestJS 애플리케이션에서 가드를 사용한 RBAC의 예입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span>, <span class="hljs-title class_">CanActivate</span>, <span class="hljs-title class_">ExecutionContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminRoleGuard</span> implements <span class="hljs-title class_">CanActivate</span> {
  <span class="hljs-title function_">canActivate</span>(<span class="hljs-attr">context</span>: <span class="hljs-title class_">ExecutionContext</span>): boolean {
    <span class="hljs-keyword">const</span> request = context.<span class="hljs-title function_">switchToHttp</span>().<span class="hljs-title function_">getRequest</span>();
    <span class="hljs-keyword">const</span> user = request.<span class="hljs-property">user</span>;
    <span class="hljs-keyword">return</span> user.<span class="hljs-property">role</span> === <span class="hljs-string">'admin'</span>;
  }
}

@<span class="hljs-title class_">Controller</span>(<span class="hljs-string">'cats'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CatsController</span> {
  @<span class="hljs-title class_">UseGuards</span>(<span class="hljs-title class_">AdminRoleGuard</span>)
  @<span class="hljs-title class_">Get</span>()
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">findAll</span>(): <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">Cat</span>[]> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">catsService</span>.<span class="hljs-title function_">findAll</span>();
  }
}
</code></pre>
<div class="content-ad"></div>
<p>위의 코드 스니펫에서는 CanActivate 인터페이스를 구현하는 AdminRoleGuard를 생성합니다. 현재 사용자의 역할을 확인하여 사용자가 관리자 인 경우 true를 반환합니다. 그런 다음 @UseGuards 데코레이터를 사용하여 AdminRoleGuard를 findAll 메서드에 적용하고 상세하게 접근을 제한하여 관리자 역할을 가진 사용자에게만 엔드포인트에 액세스 할 수 있도록 합니다.</p>
<p>접근 제어 메커니즘은 안전하고 유지 관리하기 쉬운 프레임워크에서 중앙 집중식 함수를 사용하여 적용해야 합니다.</p>
<p>또한 컨트롤러에 적용된 필수 가드를 테스트하는 단위 테스트를 작성하는 것이 좋습니다. 따라서 가드가 실수로 제거되었을 때 단위 테스트가 문제를 감지할 것입니다.</p>
<h2>서버 측 요청 위조 (SSRF)</h2>
<div class="content-ad"></div>
<p>SSRF는 공격자가 서버에 의도하지 않은 요청을 보내게 하는 사이버 공격입니다. 이러한 요청은 내부 네트워크의 제한된 자원에 액세스하는 데 사용될 수 있습니다.</p>
<p>SSRF를 방지하려면 사용자 입력을 적절히 확인하는 것이 중요합니다. 아래는 SSRF 위험에 노출된 엔드포인트의 예시입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span>, <span class="hljs-title class_">Res</span>, <span class="hljs-title class_">HttpStatus</span>, <span class="hljs-title class_">Query</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

@<span class="hljs-title class_">Controller</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CatsController</span> {
  @<span class="hljs-title class_">Get</span>()
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params">@Query(<span class="hljs-string">'url'</span>) url: string, @Res() res</span>) {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
  }
}
</code></pre>
<p>위 예시에서 앱은 url 쿼리 매개변수에서 가져온 URL로 요청을 보내고 응답 데이터를 클라이언트에 반환합니다. 공격자가 내부 네트워크의 제한된 자원에 액세스하는 악성 URL을 포함한 요청을 서버로 보낼 수 있기 때문에 명백히 SSRF 공격에 취약합니다.</p>
<div class="content-ad"></div>
<p>아래의 위험을 방지하기 위해 URL 매개변수를 유효성 검사해야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span>, <span class="hljs-title class_">Res</span>, <span class="hljs-title class_">HttpStatus</span>, <span class="hljs-title class_">Query</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { isURL } <span class="hljs-keyword">from</span> <span class="hljs-string">'validator'</span>;

@<span class="hljs-title class_">Controller</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CatsController</span> {
  @<span class="hljs-title class_">Get</span>()
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params">@Query(<span class="hljs-string">'url'</span>) url: string, @Res() res</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isURL</span>(url)) {
      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">BAD_REQUEST</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">'유효하지 않은 URL입니다'</span>);
    }

    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
  }
}
</code></pre>
<p>더 나아가 보안을 더 강화하기 위해 사용자가 직접 쿼리 매개변수에 URL을 전달하도록 허용해선 안 됩니다. 대신 신뢰할 수 있는 API에서 데이터를 가져 오기 위해 기존 서비스를 사용해야 합니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Controller</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CatsController</span> {
  @<span class="hljs-title class_">Get</span>()
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params">@Query(<span class="hljs-string">'name'</span>) dataName: string, @Res() res</span>) {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> dataService.<span class="hljs-title class_">GetDataByName</span>(dataName);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
  }
}
</code></pre>
<div class="content-ad"></div>
<p>SSRF 공격을 방지하는 다른 방법이 있습니다:</p>
<ul>
<li>신뢰할 수 있는 소스(즉, 알려진 API 또는 서비스)로만 요청을 보냅니다.</li>
<li>보안 헤더를 구현합니다(예: “X-Frame-Options”와 같은 헤더) 클릭재킹 공격 및 기타 악의적 요청을 방지합니다.</li>
<li>CSP(Content Security Policy)를 사용하여 응용 프로그램 대신 요청을 허용할 소스를 지정합니다.</li>
</ul>
<p>NestJS에서는 helmet을 사용하여 보안 헤더 및 CSP를 쉽게 설정할 수 있습니다.</p>
<h2>대량 할당</h2>
<div class="content-ad"></div>
<p>대량 할당은 취약점입니다. 공격자가 앱에 악의적인 요청을 보내어 여러 객체 속성을 수정할 수 있기 때문입니다.</p>
<p>아래 예시에서, 요청 본문에서 오는 데이터를 기반으로 새 사용자가 생성됩니다. 이것은 대량 할당 공격에 취약합니다. 왜냐하면 공격자가 클라이언트 객체의 중요한 필드(예: 역할 또는 비밀번호)를 덮어쓰는 악의적인 데이터를 보낼 수 있기 때문입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Post</span>, <span class="hljs-title class_">Body</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

@<span class="hljs-title class_">Controller</span>(<span class="hljs-string">"client"</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientController</span> {
  @<span class="hljs-title class_">Post</span>()
  <span class="hljs-title function_">create</span>(<span class="hljs-params">@Body() body</span>) {
    <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>(body);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">save</span>();
  }
}
</code></pre>
<p>대량 할당을 방지하기 위해 우리는 각 객체에 허용된 속성 목록을 정의할 수 있습니다. 우리는 아래 예시에서 중요한 필드를 덮어쓰는 것을 막기 위해 속성의 화이트리스트를 구현했습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Entity</span>, <span class="hljs-title class_">Column</span>, <span class="hljs-title class_">PrimaryGeneratedColumn</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'typeorm'</span>;

@<span class="hljs-title class_">Entity</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span>{
  @<span class="hljs-title class_">PrimaryGeneratedColumn</span>()
  <span class="hljs-attr">id</span>: number;

  @<span class="hljs-title class_">Column</span>()
  <span class="hljs-attr">name</span>: string;

  @<span class="hljs-title class_">Column</span>()
  <span class="hljs-attr">role</span>: string;

  @<span class="hljs-title class_">Column</span>()
  <span class="hljs-attr">password</span>: string;

  @<span class="hljs-title class_">Column</span>(})
  <span class="hljs-attr">email</span>: string;
}

@<span class="hljs-title class_">Controller</span>(<span class="hljs-string">'client'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientController</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private clientService: ClientService</span>) {}

  @<span class="hljs-title class_">Post</span>()
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">@Body() client: Pick&#x3C;User, <span class="hljs-string">'name'</span> | <span class="hljs-string">'email'</span>></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">clientService</span>.<span class="hljs-title function_">create</span>(client);
  }
}
</code></pre>
<p>여기서 TypeScript의 Pick 유형을 사용하여 User 엔티티의 속성을 화이트리스트로 정의합니다. 그런 다음 @Body 데코레이터를 사용하여 요청 본문을 user 매개변수에 바인딩합니다. 이 매개변수에는 허용된 속성만 포함될 것입니다. 이를 통해 공격자가 대량 할당을 통해 다른 엔티티 속성을 수정하는 것을 방지합니다.</p>
<p>대량 할당을 방지하는 다른 방법은 다음과 같습니다:</p>
<ul>
<li>일반 DTO 대신 축소된 DTO를 사용합니다. 예를 들어 InsertClientEntity 및 UpdateClientEntity를 만듭니다. 이러한 DTO에는 삽입 및 업데이트 작업에서 허용된 속성만 포함됩니다.</li>
<li>클라이언트 측에서 오는 객체에 직접 바인딩하지 않습니다.</li>
</ul>
<div class="content-ad"></div>
<h2>민감한 정보 노출</h2>
<p>민감한 정보에는 암호, API 키 및 기타 비밀 데이터가 포함됩니다. 개인 정보나 결제 관련 정보가 포함된 데이터는 모두 민감합니다.</p>
<p>웹 API를 설계할 때, 종종 클라이언트로 과도한 데이터가 반환됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span>, <span class="hljs-title class_">Param</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Client</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'./client/client.entity'</span>;

@<span class="hljs-title class_">Controller</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientController</span> {
  @<span class="hljs-title class_">Get</span>(<span class="hljs-string">'clients/:id'</span>)
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getClient</span>(@<span class="hljs-title class_">Param</span>(<span class="hljs-string">'id'</span>) <span class="hljs-attr">id</span>: string): <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">Client</span>> {
    <span class="hljs-comment">// 클라이언트를 위한 모든 필드를 반환합니다</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title class_">Client</span>.<span class="hljs-title function_">findById</span>(id);
  }
}
</code></pre>
<div class="content-ad"></div>
<p>이 예시에서는 getClient 메서드가 클라이언트에 대한 모든 필드를 반환하는데, 이는 role 또는 비밀번호와 같은 민감한 데이터를 포함합니다. 클라이언트는 이러한 데이터를 사용하거나 표시하지 않지만, 공격자가 이를 가로채어 노출시킬 수 있습니다.</p>
<p>민감한 개인 데이터 노출을 방지하기 위해, 우리는 클라이언트가 필요로 하는 데이터인 이름과 이메일 필드만을 반환해야 합니다. 요약하자면, 최소한의 데이터만 노출해야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span>, <span class="hljs-title class_">Param</span>, <span class="hljs-title class_">UseGuards</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Client</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'./client/client.entity'</span>;

@<span class="hljs-title class_">Controller</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientController</span> {
  @<span class="hljs-title class_">Get</span>(<span class="hljs-string">'clients/:id'</span>)
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getClient</span>(@<span class="hljs-title class_">Param</span>(<span class="hljs-string">'id'</span>) <span class="hljs-attr">id</span>: string): <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">Client</span>> {
    <span class="hljs-comment">// Only return the name and email</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title class_">Client</span>.<span class="hljs-title function_">findById</span>(id).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">c</span> =></span> {c.<span class="hljs-property">name</span>, c.<span class="hljs-property">email</span>});
  }
}
</code></pre>
<p>민감한 데이터 노출을 방지하기 위해, 아래는 따라야 할 다른 지침들입니다:</p>
<div class="content-ad"></div>
<ul>
<li>민감한 정보를 버전 관리에 저장하지 마세요. 이 정보에는 환경 변수 또는 구성 파일이 포함됩니다.</li>
<li>시스템 내의 민감한 정보 (GDPR, PCI, 및 PII 데이터)를 식별하고 암호화를 통해 안전하게 보호하세요.</li>
<li>앱이 클라이언트와 서버를 연결할 때 HTTPS를 사용하도록 하세요. 이렇게 하면 민감한 데이터가 전송 중 가로채지 못하게 할 수 있습니다.</li>
</ul>
<h2>요약</h2>
<p>이 글은 NestJS의 맥락에서 발생하는 네 가지 일반적인 위험과 그 방지를 위한 모범 사례에 대해 논의합니다.</p>
<p>이러한 모범 사례를 따르면 NestJS 앱의 보안을 보장할 수 있는 안전한 코드를 작성할 수 있습니다.</p>
<div class="content-ad"></div>
<p>위 글의 제 2부에서는 다른 상위 OWASP 위험에 대해 계속 논의하고 있어요.</p>
<p>만일 이미 Medium의 유료 구독자가 아니라면, 이 링크를 방문하여 구독할 수 있어요. Medium의 모든 이야기에 무제한으로 접근할 수 있을 거에요. 저는 회원 비용의 일부를 추천 수수료로 받게 될 거에요.</p>
<p>즐거운 프로그래밍 되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"NestJS 애플리케이션의 코드 보안을 극대화하는 방법 파트 1","description":"","date":"2024-06-22 02:07","slug":"2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1","content":"\n\nNestJS 개발자를 위한 최고의 안전한 코드 작성 방법\n\n![이미지](/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_0.png)\n\n개발자로서, 우리는 모두 코드 보안이 얼마나 중요한지 알고 있습니다. Optus와 Medibank에서 발생한 최근 데이터 침해 사례는 코드 보안의 중요성을 다시 한 번 강조합니다. 그래서, 질문은 다음과 같습니다: 우리는 어떻게 안전한 코드를 작성하여 웹 애플리케이션에서 다양한 유형의 공격을 방지할 수 있을까요? 안전한 코드를 작성하기 위한 최고의 방법을 따르는 것은 취약점과 위협으로부터 우리 앱을 보호하는 데 필수적입니다.\n\n우리가 어떻게 보안 위험을 방지할 수 있는지에 대해 들어가기 전에, 먼저 가장 흔한 유형의 보안 위험을 살펴보겠습니다. 이것은 우리 앱을 보호하는 과제에 대한 더 나은 이해를 제공할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOWASP Top 10은 웹 애플리케이션의 가장 중요한 보안 위험을 널리 인정받는 목록으로, 산업 전문가들 간의 합의를 통해 결정됩니다. 아래는 2017년과 2021년의 상위 10위 위험 목록입니다.\n\n![OWASP Top 10](/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_1.png)\n\n상위 10위 중 많은 것들이 웹 앱의 보안에 매우 중요합니다.\n\n두 부분으로 구성된 글의 첫 번째 부분으로, 몇 가지 위험과 위험을 방지하는 데 따를 수 있는 최상의 실천 방법에 대해 설명하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같습니다:\n\n- 액세스 제어 오류\n- 서버 측 요청 위조 (SSRF)\n- 대량 할당\n- 민감한 정보 노출\n\n## 액세스 제어 오류\n\n액세스 제어 오류는 가장 흔한 위험 중 하나입니다. 공격자가 무단으로 기능이나 자원에 액세스할 수 있는 경우 발생합니다. 2014년 1월 Snapchat 사건이 실제로 발생한 사례 중 하나입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 위험을 방지하기 위해 최소 권한 원칙을 따르는 것이 중요합니다. 액세스는 기본적으로 거부되어야하며 권한은 필요한 경우에만 부여해야합니다.\n\n사용자의 역할이나 권한에 기반하여 기능이나 자원에 대한 액세스를 제한하는 역할 기반 액세스 제어 (RBAC) 또는 액세스 제어 목록 (ACL)과 같은 액세스 제어 메커니즘을 사용할 수 있습니다.\n\n다음은 NestJS 애플리케이션에서 가드를 사용한 RBAC의 예입니다:\n\n```js\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\n\n@Injectable()\nexport class AdminRoleGuard implements CanActivate {\n  canActivate(context: ExecutionContext): boolean {\n    const request = context.switchToHttp().getRequest();\n    const user = request.user;\n    return user.role === 'admin';\n  }\n}\n\n@Controller('cats')\nexport class CatsController {\n  @UseGuards(AdminRoleGuard)\n  @Get()\n  async findAll(): Promise\u003cCat[]\u003e {\n    return this.catsService.findAll();\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드 스니펫에서는 CanActivate 인터페이스를 구현하는 AdminRoleGuard를 생성합니다. 현재 사용자의 역할을 확인하여 사용자가 관리자 인 경우 true를 반환합니다. 그런 다음 @UseGuards 데코레이터를 사용하여 AdminRoleGuard를 findAll 메서드에 적용하고 상세하게 접근을 제한하여 관리자 역할을 가진 사용자에게만 엔드포인트에 액세스 할 수 있도록 합니다.\n\n접근 제어 메커니즘은 안전하고 유지 관리하기 쉬운 프레임워크에서 중앙 집중식 함수를 사용하여 적용해야 합니다.\n\n또한 컨트롤러에 적용된 필수 가드를 테스트하는 단위 테스트를 작성하는 것이 좋습니다. 따라서 가드가 실수로 제거되었을 때 단위 테스트가 문제를 감지할 것입니다.\n\n## 서버 측 요청 위조 (SSRF)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSSRF는 공격자가 서버에 의도하지 않은 요청을 보내게 하는 사이버 공격입니다. 이러한 요청은 내부 네트워크의 제한된 자원에 액세스하는 데 사용될 수 있습니다.\n\nSSRF를 방지하려면 사용자 입력을 적절히 확인하는 것이 중요합니다. 아래는 SSRF 위험에 노출된 엔드포인트의 예시입니다.\n\n```js\nimport { Controller, Get, Res, HttpStatus, Query } from '@nestjs/common';\n\n@Controller()\nexport class CatsController {\n  @Get()\n  async getData(@Query('url') url: string, @Res() res) {\n    const response = await fetch(url);\n    return await response.json();\n  }\n}\n```\n\n위 예시에서 앱은 url 쿼리 매개변수에서 가져온 URL로 요청을 보내고 응답 데이터를 클라이언트에 반환합니다. 공격자가 내부 네트워크의 제한된 자원에 액세스하는 악성 URL을 포함한 요청을 서버로 보낼 수 있기 때문에 명백히 SSRF 공격에 취약합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 위험을 방지하기 위해 URL 매개변수를 유효성 검사해야 합니다.\n\n```js\nimport { Controller, Get, Res, HttpStatus, Query } from '@nestjs/common';\nimport { isURL } from 'validator';\n\n@Controller()\nexport class CatsController {\n  @Get()\n  async getData(@Query('url') url: string, @Res() res) {\n    if (!isURL(url)) {\n      return res.status(HttpStatus.BAD_REQUEST).send('유효하지 않은 URL입니다');\n    }\n\n    const response = await fetch(url);\n    return await response.json();\n  }\n}\n```\n\n더 나아가 보안을 더 강화하기 위해 사용자가 직접 쿼리 매개변수에 URL을 전달하도록 허용해선 안 됩니다. 대신 신뢰할 수 있는 API에서 데이터를 가져 오기 위해 기존 서비스를 사용해야 합니다.\n\n```js\n@Controller()\nexport class CatsController {\n  @Get()\n  async getData(@Query('name') dataName: string, @Res() res) {\n    const response = await dataService.GetDataByName(dataName);\n    return await response.json();\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSSRF 공격을 방지하는 다른 방법이 있습니다:\n\n- 신뢰할 수 있는 소스(즉, 알려진 API 또는 서비스)로만 요청을 보냅니다.\n- 보안 헤더를 구현합니다(예: “X-Frame-Options”와 같은 헤더) 클릭재킹 공격 및 기타 악의적 요청을 방지합니다.\n- CSP(Content Security Policy)를 사용하여 응용 프로그램 대신 요청을 허용할 소스를 지정합니다.\n\nNestJS에서는 helmet을 사용하여 보안 헤더 및 CSP를 쉽게 설정할 수 있습니다.\n\n## 대량 할당\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대량 할당은 취약점입니다. 공격자가 앱에 악의적인 요청을 보내어 여러 객체 속성을 수정할 수 있기 때문입니다.\n\n아래 예시에서, 요청 본문에서 오는 데이터를 기반으로 새 사용자가 생성됩니다. 이것은 대량 할당 공격에 취약합니다. 왜냐하면 공격자가 클라이언트 객체의 중요한 필드(예: 역할 또는 비밀번호)를 덮어쓰는 악의적인 데이터를 보낼 수 있기 때문입니다.\n\n```js\nimport { Controller, Post, Body } from '@nestjs/common';\n\n@Controller(\"client\")\nexport class ClientController {\n  @Post()\n  create(@Body() body) {\n    const client = new Client(body);\n    return await client.save();\n  }\n}\n```\n\n대량 할당을 방지하기 위해 우리는 각 객체에 허용된 속성 목록을 정의할 수 있습니다. 우리는 아래 예시에서 중요한 필드를 덮어쓰는 것을 막기 위해 속성의 화이트리스트를 구현했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';\n\n@Entity()\nexport class Client{\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  name: string;\n\n  @Column()\n  role: string;\n\n  @Column()\n  password: string;\n\n  @Column(})\n  email: string;\n}\n\n@Controller('client')\nexport class ClientController {\n  constructor(private clientService: ClientService) {}\n\n  @Post()\n  async create(@Body() client: Pick\u003cUser, 'name' | 'email'\u003e) {\n    return await this.clientService.create(client);\n  }\n}\n```\n\n여기서 TypeScript의 Pick 유형을 사용하여 User 엔티티의 속성을 화이트리스트로 정의합니다. 그런 다음 @Body 데코레이터를 사용하여 요청 본문을 user 매개변수에 바인딩합니다. 이 매개변수에는 허용된 속성만 포함될 것입니다. 이를 통해 공격자가 대량 할당을 통해 다른 엔티티 속성을 수정하는 것을 방지합니다.\n\n대량 할당을 방지하는 다른 방법은 다음과 같습니다:\n\n- 일반 DTO 대신 축소된 DTO를 사용합니다. 예를 들어 InsertClientEntity 및 UpdateClientEntity를 만듭니다. 이러한 DTO에는 삽입 및 업데이트 작업에서 허용된 속성만 포함됩니다.\n- 클라이언트 측에서 오는 객체에 직접 바인딩하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 민감한 정보 노출\n\n민감한 정보에는 암호, API 키 및 기타 비밀 데이터가 포함됩니다. 개인 정보나 결제 관련 정보가 포함된 데이터는 모두 민감합니다.\n\n웹 API를 설계할 때, 종종 클라이언트로 과도한 데이터가 반환됩니다.\n\n```js\nimport { Controller, Get, Param } from '@nestjs/common';\nimport { Client} from './client/client.entity';\n\n@Controller()\nexport class ClientController {\n  @Get('clients/:id')\n  async getClient(@Param('id') id: string): Promise\u003cClient\u003e {\n    // 클라이언트를 위한 모든 필드를 반환합니다\n    return await Client.findById(id);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 getClient 메서드가 클라이언트에 대한 모든 필드를 반환하는데, 이는 role 또는 비밀번호와 같은 민감한 데이터를 포함합니다. 클라이언트는 이러한 데이터를 사용하거나 표시하지 않지만, 공격자가 이를 가로채어 노출시킬 수 있습니다.\n\n민감한 개인 데이터 노출을 방지하기 위해, 우리는 클라이언트가 필요로 하는 데이터인 이름과 이메일 필드만을 반환해야 합니다. 요약하자면, 최소한의 데이터만 노출해야 합니다.\n\n```js\nimport { Controller, Get, Param, UseGuards } from '@nestjs/common';\nimport { Client} from './client/client.entity';\n\n@Controller()\nexport class ClientController {\n  @Get('clients/:id')\n  async getClient(@Param('id') id: string): Promise\u003cClient\u003e {\n    // Only return the name and email\n    return await Client.findById(id).map(c =\u003e {c.name, c.email});\n  }\n}\n```\n\n민감한 데이터 노출을 방지하기 위해, 아래는 따라야 할 다른 지침들입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 민감한 정보를 버전 관리에 저장하지 마세요. 이 정보에는 환경 변수 또는 구성 파일이 포함됩니다.\n- 시스템 내의 민감한 정보 (GDPR, PCI, 및 PII 데이터)를 식별하고 암호화를 통해 안전하게 보호하세요.\n- 앱이 클라이언트와 서버를 연결할 때 HTTPS를 사용하도록 하세요. 이렇게 하면 민감한 데이터가 전송 중 가로채지 못하게 할 수 있습니다.\n\n## 요약\n\n이 글은 NestJS의 맥락에서 발생하는 네 가지 일반적인 위험과 그 방지를 위한 모범 사례에 대해 논의합니다.\n\n이러한 모범 사례를 따르면 NestJS 앱의 보안을 보장할 수 있는 안전한 코드를 작성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 글의 제 2부에서는 다른 상위 OWASP 위험에 대해 계속 논의하고 있어요.\n\n만일 이미 Medium의 유료 구독자가 아니라면, 이 링크를 방문하여 구독할 수 있어요. Medium의 모든 이야기에 무제한으로 접근할 수 있을 거에요. 저는 회원 비용의 일부를 추천 수수료로 받게 될 거에요.\n\n즐거운 프로그래밍 되세요!","ogImage":{"url":"/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_0.png"},"coverImage":"/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003eNestJS 개발자를 위한 최고의 안전한 코드 작성 방법\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e개발자로서, 우리는 모두 코드 보안이 얼마나 중요한지 알고 있습니다. Optus와 Medibank에서 발생한 최근 데이터 침해 사례는 코드 보안의 중요성을 다시 한 번 강조합니다. 그래서, 질문은 다음과 같습니다: 우리는 어떻게 안전한 코드를 작성하여 웹 애플리케이션에서 다양한 유형의 공격을 방지할 수 있을까요? 안전한 코드를 작성하기 위한 최고의 방법을 따르는 것은 취약점과 위협으로부터 우리 앱을 보호하는 데 필수적입니다.\u003c/p\u003e\n\u003cp\u003e우리가 어떻게 보안 위험을 방지할 수 있는지에 대해 들어가기 전에, 먼저 가장 흔한 유형의 보안 위험을 살펴보겠습니다. 이것은 우리 앱을 보호하는 과제에 대한 더 나은 이해를 제공할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eOWASP Top 10은 웹 애플리케이션의 가장 중요한 보안 위험을 널리 인정받는 목록으로, 산업 전문가들 간의 합의를 통해 결정됩니다. 아래는 2017년과 2021년의 상위 10위 위험 목록입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1_1.png\" alt=\"OWASP Top 10\"\u003e\u003c/p\u003e\n\u003cp\u003e상위 10위 중 많은 것들이 웹 앱의 보안에 매우 중요합니다.\u003c/p\u003e\n\u003cp\u003e두 부분으로 구성된 글의 첫 번째 부분으로, 몇 가지 위험과 위험을 방지하는 데 따를 수 있는 최상의 실천 방법에 대해 설명하겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래와 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e액세스 제어 오류\u003c/li\u003e\n\u003cli\u003e서버 측 요청 위조 (SSRF)\u003c/li\u003e\n\u003cli\u003e대량 할당\u003c/li\u003e\n\u003cli\u003e민감한 정보 노출\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e액세스 제어 오류\u003c/h2\u003e\n\u003cp\u003e액세스 제어 오류는 가장 흔한 위험 중 하나입니다. 공격자가 무단으로 기능이나 자원에 액세스할 수 있는 경우 발생합니다. 2014년 1월 Snapchat 사건이 실제로 발생한 사례 중 하나입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이러한 위험을 방지하기 위해 최소 권한 원칙을 따르는 것이 중요합니다. 액세스는 기본적으로 거부되어야하며 권한은 필요한 경우에만 부여해야합니다.\u003c/p\u003e\n\u003cp\u003e사용자의 역할이나 권한에 기반하여 기능이나 자원에 대한 액세스를 제한하는 역할 기반 액세스 제어 (RBAC) 또는 액세스 제어 목록 (ACL)과 같은 액세스 제어 메커니즘을 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 NestJS 애플리케이션에서 가드를 사용한 RBAC의 예입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eCanActivate\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eExecutionContext\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAdminRoleGuard\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eCanActivate\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003ecanActivate\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtext\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eExecutionContext\u003c/span\u003e): boolean {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e request = context.\u003cspan class=\"hljs-title function_\"\u003eswitchToHttp\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003egetRequest\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = request.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e user.\u003cspan class=\"hljs-property\"\u003erole\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'admin'\u003c/span\u003e;\n  }\n}\n\n@\u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'cats'\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCatsController\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title class_\"\u003eUseGuards\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eAdminRoleGuard\u003c/span\u003e)\n  @\u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efindAll\u003c/span\u003e(): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eCat\u003c/span\u003e[]\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecatsService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efindAll\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 코드 스니펫에서는 CanActivate 인터페이스를 구현하는 AdminRoleGuard를 생성합니다. 현재 사용자의 역할을 확인하여 사용자가 관리자 인 경우 true를 반환합니다. 그런 다음 @UseGuards 데코레이터를 사용하여 AdminRoleGuard를 findAll 메서드에 적용하고 상세하게 접근을 제한하여 관리자 역할을 가진 사용자에게만 엔드포인트에 액세스 할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e접근 제어 메커니즘은 안전하고 유지 관리하기 쉬운 프레임워크에서 중앙 집중식 함수를 사용하여 적용해야 합니다.\u003c/p\u003e\n\u003cp\u003e또한 컨트롤러에 적용된 필수 가드를 테스트하는 단위 테스트를 작성하는 것이 좋습니다. 따라서 가드가 실수로 제거되었을 때 단위 테스트가 문제를 감지할 것입니다.\u003c/p\u003e\n\u003ch2\u003e서버 측 요청 위조 (SSRF)\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eSSRF는 공격자가 서버에 의도하지 않은 요청을 보내게 하는 사이버 공격입니다. 이러한 요청은 내부 네트워크의 제한된 자원에 액세스하는 데 사용될 수 있습니다.\u003c/p\u003e\n\u003cp\u003eSSRF를 방지하려면 사용자 입력을 적절히 확인하는 것이 중요합니다. 아래는 SSRF 위험에 노출된 엔드포인트의 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eRes\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eHttpStatus\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eQuery\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCatsController\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e@Query(\u003cspan class=\"hljs-string\"\u003e'url'\u003c/span\u003e) url: string, @Res() res\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(url);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예시에서 앱은 url 쿼리 매개변수에서 가져온 URL로 요청을 보내고 응답 데이터를 클라이언트에 반환합니다. 공격자가 내부 네트워크의 제한된 자원에 액세스하는 악성 URL을 포함한 요청을 서버로 보낼 수 있기 때문에 명백히 SSRF 공격에 취약합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래의 위험을 방지하기 위해 URL 매개변수를 유효성 검사해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eRes\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eHttpStatus\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eQuery\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { isURL } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'validator'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCatsController\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e@Query(\u003cspan class=\"hljs-string\"\u003e'url'\u003c/span\u003e) url: string, @Res() res\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!\u003cspan class=\"hljs-title function_\"\u003eisURL\u003c/span\u003e(url)) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eHttpStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBAD_REQUEST\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'유효하지 않은 URL입니다'\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(url);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e더 나아가 보안을 더 강화하기 위해 사용자가 직접 쿼리 매개변수에 URL을 전달하도록 허용해선 안 됩니다. 대신 신뢰할 수 있는 API에서 데이터를 가져 오기 위해 기존 서비스를 사용해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCatsController\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e@Query(\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e) dataName: string, @Res() res\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e dataService.\u003cspan class=\"hljs-title class_\"\u003eGetDataByName\u003c/span\u003e(dataName);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eSSRF 공격을 방지하는 다른 방법이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e신뢰할 수 있는 소스(즉, 알려진 API 또는 서비스)로만 요청을 보냅니다.\u003c/li\u003e\n\u003cli\u003e보안 헤더를 구현합니다(예: “X-Frame-Options”와 같은 헤더) 클릭재킹 공격 및 기타 악의적 요청을 방지합니다.\u003c/li\u003e\n\u003cli\u003eCSP(Content Security Policy)를 사용하여 응용 프로그램 대신 요청을 허용할 소스를 지정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNestJS에서는 helmet을 사용하여 보안 헤더 및 CSP를 쉽게 설정할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e대량 할당\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e대량 할당은 취약점입니다. 공격자가 앱에 악의적인 요청을 보내어 여러 객체 속성을 수정할 수 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e아래 예시에서, 요청 본문에서 오는 데이터를 기반으로 새 사용자가 생성됩니다. 이것은 대량 할당 공격에 취약합니다. 왜냐하면 공격자가 클라이언트 객체의 중요한 필드(예: 역할 또는 비밀번호)를 덮어쓰는 악의적인 데이터를 보낼 수 있기 때문입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003ePost\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eBody\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"client\"\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eClientController\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title class_\"\u003ePost\u003c/span\u003e()\n  \u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e@Body() body\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e client = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eClient\u003c/span\u003e(body);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e client.\u003cspan class=\"hljs-title function_\"\u003esave\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e대량 할당을 방지하기 위해 우리는 각 객체에 허용된 속성 목록을 정의할 수 있습니다. 우리는 아래 예시에서 중요한 필드를 덮어쓰는 것을 막기 위해 속성의 화이트리스트를 구현했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eEntity\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003ePrimaryGeneratedColumn\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'typeorm'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eEntity\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eClient\u003c/span\u003e{\n  @\u003cspan class=\"hljs-title class_\"\u003ePrimaryGeneratedColumn\u003c/span\u003e()\n  \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: number;\n\n  @\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e()\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string;\n\n  @\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e()\n  \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: string;\n\n  @\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e()\n  \u003cspan class=\"hljs-attr\"\u003epassword\u003c/span\u003e: string;\n\n  @\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(})\n  \u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: string;\n}\n\n@\u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'client'\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eClientController\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate clientService: ClientService\u003c/span\u003e) {}\n\n  @\u003cspan class=\"hljs-title class_\"\u003ePost\u003c/span\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e@Body() client: Pick\u0026#x3C;User, \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eclientService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(client);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 TypeScript의 Pick 유형을 사용하여 User 엔티티의 속성을 화이트리스트로 정의합니다. 그런 다음 @Body 데코레이터를 사용하여 요청 본문을 user 매개변수에 바인딩합니다. 이 매개변수에는 허용된 속성만 포함될 것입니다. 이를 통해 공격자가 대량 할당을 통해 다른 엔티티 속성을 수정하는 것을 방지합니다.\u003c/p\u003e\n\u003cp\u003e대량 할당을 방지하는 다른 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e일반 DTO 대신 축소된 DTO를 사용합니다. 예를 들어 InsertClientEntity 및 UpdateClientEntity를 만듭니다. 이러한 DTO에는 삽입 및 업데이트 작업에서 허용된 속성만 포함됩니다.\u003c/li\u003e\n\u003cli\u003e클라이언트 측에서 오는 객체에 직접 바인딩하지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e민감한 정보 노출\u003c/h2\u003e\n\u003cp\u003e민감한 정보에는 암호, API 키 및 기타 비밀 데이터가 포함됩니다. 개인 정보나 결제 관련 정보가 포함된 데이터는 모두 민감합니다.\u003c/p\u003e\n\u003cp\u003e웹 API를 설계할 때, 종종 클라이언트로 과도한 데이터가 반환됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eParam\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eClient\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./client/client.entity'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eClientController\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'clients/:id'\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetClient\u003c/span\u003e(@\u003cspan class=\"hljs-title class_\"\u003eParam\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e) \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: string): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eClient\u003c/span\u003e\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 클라이언트를 위한 모든 필드를 반환합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eClient\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efindById\u003c/span\u003e(id);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 예시에서는 getClient 메서드가 클라이언트에 대한 모든 필드를 반환하는데, 이는 role 또는 비밀번호와 같은 민감한 데이터를 포함합니다. 클라이언트는 이러한 데이터를 사용하거나 표시하지 않지만, 공격자가 이를 가로채어 노출시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e민감한 개인 데이터 노출을 방지하기 위해, 우리는 클라이언트가 필요로 하는 데이터인 이름과 이메일 필드만을 반환해야 합니다. 요약하자면, 최소한의 데이터만 노출해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eParam\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eUseGuards\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eClient\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./client/client.entity'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eClientController\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'clients/:id'\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetClient\u003c/span\u003e(@\u003cspan class=\"hljs-title class_\"\u003eParam\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e) \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: string): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eClient\u003c/span\u003e\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// Only return the name and email\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eClient\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efindById\u003c/span\u003e(id).\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ec\u003c/span\u003e =\u003e\u003c/span\u003e {c.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e, c.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e});\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e민감한 데이터 노출을 방지하기 위해, 아래는 따라야 할 다른 지침들입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e민감한 정보를 버전 관리에 저장하지 마세요. 이 정보에는 환경 변수 또는 구성 파일이 포함됩니다.\u003c/li\u003e\n\u003cli\u003e시스템 내의 민감한 정보 (GDPR, PCI, 및 PII 데이터)를 식별하고 암호화를 통해 안전하게 보호하세요.\u003c/li\u003e\n\u003cli\u003e앱이 클라이언트와 서버를 연결할 때 HTTPS를 사용하도록 하세요. 이렇게 하면 민감한 데이터가 전송 중 가로채지 못하게 할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e요약\u003c/h2\u003e\n\u003cp\u003e이 글은 NestJS의 맥락에서 발생하는 네 가지 일반적인 위험과 그 방지를 위한 모범 사례에 대해 논의합니다.\u003c/p\u003e\n\u003cp\u003e이러한 모범 사례를 따르면 NestJS 앱의 보안을 보장할 수 있는 안전한 코드를 작성할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위 글의 제 2부에서는 다른 상위 OWASP 위험에 대해 계속 논의하고 있어요.\u003c/p\u003e\n\u003cp\u003e만일 이미 Medium의 유료 구독자가 아니라면, 이 링크를 방문하여 구독할 수 있어요. Medium의 모든 이야기에 무제한으로 접근할 수 있을 거에요. 저는 회원 비용의 일부를 추천 수수료로 받게 될 거에요.\u003c/p\u003e\n\u003cp\u003e즐거운 프로그래밍 되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-MaximizeCodeSecurityinYourNestJSApplicationsPart1"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>