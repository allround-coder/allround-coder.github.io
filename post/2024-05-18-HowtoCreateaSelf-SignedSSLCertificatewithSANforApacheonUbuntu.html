<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu" data-gatsby-head="true"/><meta name="twitter:title" content="우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 21:44" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-742e6c91a18eb160.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>웹 응용 프로그램을 SSL 인증서로 안전하게 보호하는 것은 클라이언트와 서버 간에 전송되는 데이터의 기밀성과 무결성을 보장하기 위해 중요합니다. 이 튜토리얼에서는 Ubuntu 운영 체제의 Apache 웹 서버에 대한 서브젝트 대체 이름 (SAN)이 포함된 자체 서명 SSL 인증서를 생성하는 과정을 안내합니다.</p>
<h1>필수 사항</h1>
<p>시작하기 전에 다음 사항을 확인하세요:</p>
<ul>
<li>Apache가 설치된 Ubuntu 서버</li>
<li>openssl 도구가 설치되어 있습니다.</li>
</ul>
<p>우선, 프론트엔드 폴더로 이동해주세요.</p>
<h3>단계 1: 디렉토리 생성</h3>
<p>인증서를 위한 디렉토리를 생성하세요.</p>
<pre><code class="hljs language-js">mkdir certificates
cd certificates
</code></pre>
<h1>단계 2: 개인 키 생성</h1>
<pre><code class="hljs language-js">openssl genpkey -algorithm <span class="hljs-variable constant_">RSA</span> -out private.<span class="hljs-property">key</span>
</code></pre>
<ul>
<li>genpkey: 이 하위 명령어는 개인 키를 생성하는 데 사용됩니다.</li>
<li>-algorithm RSA: 키 생성에 사용할 알고리즘을 지정합니다. 이 경우 RSA (Rivest–Shamir–Adleman) 알고리즘을 사용합니다. RSA는 널리 사용되는 비대칭 암호 알고리즘입니다.</li>
<li>-out private.key: 생성된 개인 키를 저장할 출력 파일을 지정합니다. 이 예에서는 개인 키가 private.key라는 파일에 저장됩니다.</li>
</ul>
<p>[비권장] 만약 당신의 private.key가 암호로 보호되기를 원한다면 -</p>
<pre><code class="hljs language-js">openssl genpkey -algorithm <span class="hljs-variable constant_">RSA</span> -aes256 -out private.<span class="hljs-property">key</span>
</code></pre>
<p>-aes256:</p>
<ul>
<li>이 매개변수는 개인 키에 사용할 암호화 알고리즘을 나타냅니다. 이 경우 AES (고급 암호화 표준)와 키 길이가 256비트인 AES-256를 사용합니다. 이 매개변수는 추가 보안을 위해 개인 키를 AES-256로 암호화하는 것을 보장합니다. 사용자는 키 생성 과정 중에 암호를 입력하도록 요청받으며, 이 암호는 개인 키를 암호화하는 데 사용됩니다.</li>
</ul>
<p>안녕하세요! 아래의 정보를 Markdown 형식으로 변환해 드릴게요.</p>
<pre><code>You’ll be prompted to enter a passphrase; remember this passphrase as you’ll need it later.

## Step 3: Create a SAN Configuration File

Create a file named san.conf with the following content:

```js
[req]
distinguished_name = req_distinguished_name
req_extensions = req_ext
prompt = no

[req_distinguished_name]
CN = localhost
C = BD
ST = Dhaka
L = Motijheel
O = Robist
OU = Developers
emailAddress = smazoomder@gmail.com

[req_ext]
subjectAltName = IP:192.168.0.88
</code></pre>
<p>(당신의 IP를 Ip 자리에 넣으세요)</p>
<ul>
<li>[req]: 이 섹션은 인증서 요청에 대한 속성을 지정합니다.</li>
<li>distinguished_name = req_distinguished_name: 인증서를 요청하는 엔티티에 대한 다양한 세부 정보를 정의하는 식별 이름 섹션을 가리킵니다.</li>
<li>req_extensions = req_ext: 인증서에 추가 정보를 포함할 수 있는 확장 섹션을 가리킵니다.</li>
<li>prompt = no: 인증서 생성 과정 중에 인증서 세부 정보에 대한 프롬프트를 비활성화합니다.</li>
<li>[req_distinguished_name]: 공통 이름 (CN), 국가 (C), 주 (ST), 지역 (L), 조직 (O), 조직 단위 (OU) 및 이메일 주소와 같은 다양한 식별 이름 속성을 정의합니다.</li>
<li>CN = localhost: 일반적으로 인증서와 관련된 도메인 이름인 공통 이름(CN)을 지정합니다.</li>
<li>C = BD: 국가 속성으로 방글라데시를 나타냅니다.</li>
<li>ST = Dhaka: 주 속성으로 다카를 지정합니다.</li>
<li>L = Motijheel: 지역 속성으로 모티제엘을 나타냅니다.</li>
<li>O = Robist: 조직 속성으로 로비스트를 나타냅니다.</li>
<li>OU = Developers: 조직 단위 속성으로 개발자를 나타냅니다.</li>
<li>emailAddress = <a href="mailto:smazoomder@gmail.com">smazoomder@gmail.com</a>: 인증서와 관련된 이메일 주소입니다.</li>
<li>[req_ext]: 추가 확장을 인증서에 포함할 수 있는 확장 섹션입니다.</li>
<li>subjectAltName = IP:192.168.0.88: 대체 식별자로 IP 주소(192.168.0.88)를 포함하는 Subject Alternative Name (SAN) 확장을 지정합니다.</li>
</ul>
<h2>Subject Alternative Name (SAN)의 내용 :</h2>
<ul>
<li>Subject: SSL/TLS 인증서의 맥락에서 "주체"는 일반적으로 인증서가 발행된 엔티티(웹사이트 또는 서버 등)를 가리킵니다. 일반적으로 공통 이름(CN), 조직 및 위치와 같은 정보를 포함합니다.</li>
<li>Alternative Name: "대체 이름"은 SSL/TLS 인증서에 포함될 수 있는 추가 식별자를 가리킵니다. 이러한 식별자는 공통 이름(CN)을 넘어서 유효한 인증서에 대한 다른 이름을 세분화하여 지정할 수 있습니다.</li>
</ul>
<h2>SAN 사용 이유:</h2>
<ul>
<li>다중 식별자 지원: SAN을 통해 하나의 SSL/TLS 인증서가 여러 식별자에 대해 유효할 수 있습니다. 기존에는 SSL 인증서가 주된 도메인을 나타내는 공통 이름(CN) 필드를 기반으로 발급되었습니다. 그러나 유연성이 커지면서 SAN을 통해 추가 이름을 포함할 수 있게 되었습니다.</li>
<li>다중 도메인 인증서: SAN은 하나의 인증서가 여러 도메인이나 서브도메인을 커버해야 하는 상황에서 특히 유용합니다. 각 도메인마다 별도의 인증서를 얻는 대신 SAN 확장을 지원하는 다중 도메인 인증서를 사용할 수 있습니다.</li>
<li>IP 주소 및 이메일 주소: SAN은 도메인 이름에만 국한되지 않습니다. IP 주소와 이메일 주소를 대체 식별자로 포함할 수도 있습니다. IP 주소를 통해 접근되는 서비스나 이메일 통신을 커버해야 하는 경우 유용합니다.</li>
<li>와일드카드 인증서: SAN은 와일드카드 인증서와 함께 일반적으로 사용됩니다. 와일드카드 인증서는 도메인과 서브도메인을 커버하며, SAN은 추가 도메인을 더 확장할 수 있습니다.</li>
<li>인증서 불일치 문제 회피: SAN을 포함하면 인증서 불일치 문제를 예방할 수 있습니다. 대체 이름을 통해 서비스에 액세스할 때, SAN의 존재로 인해 인증서가 여전히 유효하다고 간주됩니다.</li>
</ul>
<p>요약하면, Subject Alternative Name (SAN)은 SSL/TLS 인증서에 다중 식별자를 포함할 수 있는 확장 기능으로, 안전한 통신에서 다양한 명명 시나리오에 대한 유연성과 광범위한 커버리지를 제공합니다.</p>
<h1>단계 4: 인증서 서명 요청(CSR) 생성</h1>
<pre><code class="hljs language-js">openssl req -<span class="hljs-keyword">new</span> -key private.<span class="hljs-property">key</span> -out certificate.<span class="hljs-property">csr</span> -config san.<span class="hljs-property">conf</span>
</code></pre>
<p>openssl req:</p>
<ul>
<li>이 명령어는 OpenSSL에서 인증서 요청을 생성하고 처리하는 데 사용됩니다.</li>
</ul>
<p>-new:</p>
<ul>
<li>
<p>새로운 CSR (인증서 서명 요청)이 생성되고 있음을 나타냅니다.</p>
</li>
<li>
<p>-key private.key:</p>
</li>
<li>
<p>CSR을 생성하는 데 사용될 개인 키 파일을 지정합니다. 이전 단계에서 생성 된 개인 키 (private.key)가 여기에서 사용됩니다.</p>
</li>
<li>
<p>-out certificate.csr:</p>
</li>
</ul>
<ul>
<li>
<p>생성된 CSR이 저장될 출력 파일을 지정합니다. 이 예시에서는 CSR이 certificate.csr이라는 파일에 저장됩니다.</p>
</li>
<li>
<p><code>config san.conf</code>:</p>
</li>
<li>
<p>인증서에 대한 부가 설정 및 Subject Alternative Names (SANs)을 포함하는 구성 파일 (san.conf)을 지정합니다.</p>
</li>
</ul>
<h1>단계 5: 자체 서명 인증서 생성</h1>
<pre><code class="hljs language-bash">openssl x509 -req -<span class="hljs-keyword">in</span> certificate.csr -signkey private.key -out server.cert -days 365
</code></pre>
<p>openssl x509:</p>
<ul>
<li>X.509 인증서 파일에 서명하고 표시하는 데 사용되는 OpenSSL 명령입니다.</li>
</ul>
<p>-req:</p>
<ul>
<li>
<p>입력 파일(certificate.csr)이 인증 요청서(CSR)임을 나타냅니다.</p>
</li>
<li>
<p>certificate.csr 파일 안에:</p>
</li>
<li>
<p>서명이 필요한 인증 요청서(CSR)가 포함된 입력 파일을 지정합니다. 이 예에서 CSR 파일은 certificate.csr입니다.</p>
</li>
<li>
<p>signkey private.key:</p>
</li>
</ul>
<ul>
<li>
<p>CSR을 서명하고 인증서를 생성할 때 사용할 개인 키(private.key)를 지정합니다.</p>
</li>
<li>
<p>server.cert에 저장됩니다:</p>
</li>
<li>
<p>서명된 X.509 인증서가 저장될 출력 파일을 지정합니다. 이 예시에서는 인증서 파일의 이름을 server.cert로 지정합니다.</p>
</li>
<li>
<p>365일 동안 유효합니다:</p>
</li>
</ul>
<ul>
<li>인증서의 유효 기간을 일(day) 단위로 지정합니다.이 경우 인증서는 365일(1년) 동안 유효합니다.</li>
</ul>
<h2>X.509 인증서 소개</h2>
<p>X.509 인증서는 공개 키 인증서의 형식과 구조를 정의하는 X.509 표준을 따르는 디지털 인증서입니다. 이러한 인증서는 TLS/SSL을 포함한 인터넷 보안 프로토콜에서 널리 사용됩니다. 아래는 X.509 인증서의 구성 요소입니다:</p>
<ul>
<li>버전: X.509 표준의 버전을 나타냅니다. (예: 버전 1, 2 또는 3)</li>
<li>일련 번호: 인증서 발급자 (인증 기관)가 할당한 고유 식별자로, 인증서를 구분합니다.</li>
<li>서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용한 암호화 알고리즘을 지정합니다.</li>
<li>발급자: 인증서를 발급한 엔터티 (일반적으로 인증 기관)를 식별합니다.</li>
<li>유효 기간: 인증서의 유효성을 나타내는 시간 범위를 정의합니다. "발효일"과 "만료일"이 포함됩니다.</li>
<li>주체: 인증서의 공개 키와 관련된 엔터티 (예: 사람, 조직 또는 장치)를 식별합니다.</li>
<li>주체 공개 키 정보: 주체가 사용하는 공개 키와 알고리즘을 포함합니다.</li>
<li>확장: 인증서와 관련된 추가 정보 또는 속성을 포함합니다. 주체 대체 이름 (SAN), 키 사용 등이 포함될 수 있습니다.</li>
<li>인증서 서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용하는 알고리즘을 지정합니다.</li>
<li>인증서 서명 값: 인증 기관에 의해 생성된 디지털 서명을 포함하여 인증서의 무결성과 신뢰성을 보장합니다.</li>
</ul>
<h1>X.509 인증서의 목적:</h1>
<ul>
<li>인증: 인증서 소지자의 신원을 확인합니다.</li>
<li>암호화: 공개 키를 사용하여 데이터를 암호화하여 안전한 통신을 지원합니다.</li>
<li>디지털 서명: 디지털 서명의 생성과 검증을 통해 데이터 무결성을 보장합니다.</li>
<li>키 교환: 안전한 통신 프로토콜에서 암호 키 교환을 지원합니다.</li>
</ul>
<h1>SSL/TLS에서의 사용:</h1>
<ul>
<li>SSL/TLS 프로토콜에서 X.509 인증서는 클라이언트와 서버 간 안전한 연결을 설정하는 데 필수적입니다. 클라이언트가 안전한 웹 사이트에 연결할 때, 서버는 자체 X.509 인증서를 제출하고 클라이언트는 이를 확인하여 안전하고 신뢰할 수 있는 연결을 보장합니다.</li>
<li>X.509 인증서는 내부 사용을 위해 자체 서명될 수도 있고, 공개적인 웹 사이트를 위해 신뢰할 수 있는 인증 기관에 의해 서명될 수도 있습니다.</li>
</ul>
<p>웹 보안, 시스템 관리 또는 소프트웨어 개발에 관여하는 모든 사람에게 X.509 인증서를 이해하는 것이 중요합니다.</p>
<h1>단계 6: Apache 구성 업데이트</h1>
<p>Apache 가상 호스트 구성을 업데이트하세요 (/etc/apache2/sites-available/your-site.conf):</p>
<h1>가상 호스트 설정:</h1>
<ul>
<li>
<p><strong><code>VirtualHost *:443</code></strong>: 443 포트에서 HTTPS 통신을 위한 가상 호스트 블록을 정의합니다.</p>
</li>
<li>
<p><strong><code>ServerName localhost</code></strong>: 이 가상 호스트와 연결된 기본 도메인 이름을 지정합니다. 이 경우 "localhost"로 설정되어 있습니다.</p>
</li>
</ul>
<p>ServerAdmin webmaster@localhost: 서버 관리자의 이메일 주소.</p>
<p>DocumentRoot /var/www/html/your-project/backend/public: 이 VirtualHost의 문서 루트 디렉터리를 설정합니다. 이것은 웹 서버가 파일을 제공하는 위치입니다.</p>
<p>SSLEngine on: SSL 연결을 처리해야 함을 나타내는이 VirtualHost를위한 SSL 엔진을 활성화합니다.</p>
<p>SSLUseStapling off: SSL 스테이플링을 비활성화합니다. SSL 스테이플링은 SSL/TLS 인증서 확인을 강화하는 메커니즘입니다. 그러나이 예제에서는 비활성화되어 있습니다.</p>
<p>SSLCertificateFile /var/www/html/your-project/certificates/server.cert: SSL 인증서 파일의 경로를 지정합니다. 이는 이전 단계에서 생성된 공개 키 인증서 파일입니다.</p>
<p>SSLCertificateKeyFile /var/www/html/your-project/certificates/private.key: SSL 인증서와 관련된 개인 키 파일의 경로를 지정합니다.</p>
<p>ServerAlias 192.168.0.88: 이 VirtualHost가 응답해야 하는 추가 도메인 이름 또는 IP 주소를 지정합니다. 여기서는 IP 주소 192.168.0.88이 포함됩니다.</p>
<p><code>Directory "/var/www/html/your-project/backend/public"</code>: 지정된 디렉토리에 대한 구성 블록을 시작합니다.</p>
<p>Options All: 이 디렉토리에 대해 사용 가능한 모든 옵션을 허용합니다.</p>
<p>AllowOverride All: 이 디렉토리에서 .htaccess 파일을 사용하여 구성 재정의를 허용합니다.</p>
<p>Require all granted: 모든 사용자에게 액세스를 부여합니다.</p>
<p><code>/Directory</code>: 지정된 디렉토리에 대한 구성 블록을 종료합니다.</p>
<p><code>/VirtualHost</code> : VirtualHost 블록을 종료합니다.</p>
<h1>설정 목적:</h1>
<ul>
<li>이 구성 블록은 Apache가 지정된 도메인 (localhost 및 192.168.0.88)에 대한 SSL 연결을 어떻게 처리해야 하는지를 보장합니다. SSL 인증서 파일을 가리키고 연관 디렉토리에 대한 액세스 설정을 정의합니다.</li>
<li>"/var/www/html/your-project"와 같은 자리 표시자를 프로젝트에서 실제 사용하는 경로로 교체해야 합니다.</li>
</ul>
<p>그런 다음 활성화하세요:</p>
<pre><code class="hljs language-js">sudo a2ensite your-site.<span class="hljs-property">conf</span>
</code></pre>
<h1>단계 7: 아파치 재시작</h1>
<pre><code class="hljs language-js">sudo systemctl restart apache2
</code></pre>
<p>SSL/TLS 키의 암호를 입력하라는 프롬프트가 표시됩니다.</p>
<h1>단계 8: Apache 오류 로그 확인</h1>
<pre><code class="hljs language-bash">sudo <span class="hljs-built_in">tail</span> -f /var/log/apache2/error.log
</code></pre>
<p>SSL과 관련된 오류 메시지를 확인해 보세요.</p>
<h1>단계 9: 라라벨 저장소 권한 설정</h1>
<pre><code class="hljs language-js">cd /<span class="hljs-keyword">var</span>/www/html/your-project/backend
sudo chmod -R <span class="hljs-number">775</span> storage
sudo chown -R www-<span class="hljs-attr">data</span>:www-data storage
</code></pre>
<p>이제 <a href="https://192.168.0.88" rel="nofollow" target="_blank">https://192.168.0.88</a> (당신의 IP)에서 애플리케이션에 안전하게 액세스할 수 있어야 합니다.</p>
<h1>단계 10: React/Laravel 애플리케이션을 실행 중이라면</h1>
<p>프론트엔드 환경에서:</p>
<p>REACT_APP_NAME = 'your-project'
REACT_APP_VERSION = v1.1.0
GENERATE_SOURCEMAP = false</p>
<p>REACT_APP_API_BASE_URL='<a href="https://192.168.0.88/api" rel="nofollow" target="_blank">https://192.168.0.88/api</a>'
REACT_APP_ASSET_BASE_URL='<a href="https://192.168.0.88/storage" rel="nofollow" target="_blank">https://192.168.0.88/storage</a>'
REACT_APP_MAIN_DOMAIN='192.168.0.88:3000'
REACT_APP_API_DOMAIN='<a href="https://192.168.0.88" rel="nofollow" target="_blank">https://192.168.0.88</a>'
REACT_APP_BACK_DOMAIN = '<a href="https://192.168.0.88" rel="nofollow" target="_blank">https://192.168.0.88</a>'</p>
<p>REACT_APP_SITE_KEY = 'your-key'</p>
<p>in backend env :</p>
<p>APP_URL=<a href="https://192.168.0.88" rel="nofollow" target="_blank">https://192.168.0.88</a>
APP_SITE_URL="<a href="https://192.168.0.88:3000" rel="nofollow" target="_blank">https://192.168.0.88:3000</a>"</p>
<p>축하합니다! Ubuntu에서 Apache 웹 서버에 대한 Subject Alternative Name이 포함된 자체 서명 SSL 인증서를 성공적으로 생성했습니다.</p>
<p>문제가 있으면 다음을 실행해 보세요</p>
<pre><code class="hljs language-js">sudo systemctl restart apache2
</code></pre>
<pre><code class="hljs language-js">cd /<span class="hljs-keyword">var</span>/www/html/your-project/backend
sudo chmod -R <span class="hljs-number">775</span> storage
sudo chown -R www-<span class="hljs-attr">data</span>:www-data storage
</code></pre>
<h1>(선택 사항) /etc/hosts 파일 업데이트</h1>
<p>친구야, 아래와 같이 /etc/hosts 파일에 localhost와 192.168.0.88(IP 주소)의 항목이 있는지 확인해 주세요.</p>
<h1>(선택 사항) Chrome에서 인증서를 가져오는 방법:</h1>
<ul>
<li>권한 생성 및 인증서를 CRT 형식으로 변환:</li>
</ul>
<pre><code class="hljs language-js">openssl x509 -<span class="hljs-keyword">in</span> server.<span class="hljs-property">cert</span> -out server.<span class="hljs-property">crt</span>
</code></pre>
<ul>
<li>PKCS#12 형식으로 인증서 및 키 변환하기:</li>
</ul>
<pre><code class="hljs language-js">openssl pkcs12 -<span class="hljs-keyword">export</span> -out certificate.<span class="hljs-property">pfx</span> -inkey private.<span class="hljs-property">key</span> -<span class="hljs-keyword">in</span> server.<span class="hljs-property">cert</span>
</code></pre>
<p>개인 키의 암호를 입력하라는 프롬프트가 표시됩니다.</p>
<ol start="3">
<li>Chrome에 인증서 가져오기:</li>
</ol>
<ul>
<li>크롬을 열고 설정으로 이동합니다.</li>
<li>아래로 스크롤하여 고급을 클릭합니다.</li>
<li>개인 정보 및 보안 아래에서 인증서 관리를 클릭합니다.</li>
<li>인증서 창에서 개인 탭으로 이동합니다.</li>
<li>가져오기를 클릭하고 생성한 certificate.pfx 파일을 선택합니다.</li>
<li>가져오기 마법사를 따라가고 암호를 입력하고 나오면 상점을 선택합니다.</li>
</ul>
<ol start="4">
<li>신뢰할 수 있는 인증 기관(CA)을 추가하려면 다음을 수행하십시오:</li>
</ol>
<pre><code class="hljs language-js">sudo cp server.<span class="hljs-property">crt</span> /usr/local/share/ca-certificates/server.<span class="hljs-property">crt</span>
sudo update-ca-certificates
</code></pre>
<p>다음 명령을 사용하여 인증서가 신뢰 목록에 추가되었는지 확인하십시오:</p>
<pre><code class="hljs language-js">awk -v cmd=<span class="hljs-string">'openssl x509 -noout -subject'</span> <span class="hljs-string">' /BEGIN/{close(cmd)};{print | cmd}'</span> &#x3C; <span class="hljs-regexp">/etc/</span>ssl/certs/ca-certificates.<span class="hljs-property">crt</span> | grep -i localhost
</code></pre>
<p>인증서의 전체 세부 정보를 확인하려면 OpenSSL 또는 다른 도구를 사용할 수 있습니다. 예를 들어 OpenSSL을 사용하여 다음과 같이 실행할 수 있습니다.</p>
<pre><code class="hljs language-js">openssl x509 -<span class="hljs-keyword">in</span> server.<span class="hljs-property">cert</span> -text -noout
</code></pre>
<p>만료 날짜 확인: SSL 인증서가 만료되지 않았는지 확인하십시오. 다음 OpenSSL 명령어를 사용하여 만료 날짜를 확인할 수 있습니다.```</p>
<pre><code class="hljs language-js">openssl x509 -enddate -noout -<span class="hljs-keyword">in</span> server.<span class="hljs-property">cert</span>
</code></pre>
<p>인증서 내용 확인:</p>
<p>OpenSSL을 사용하여 인증서 및 개인 키 파일의 내용을 확인할 수 있습니다. 원하는 정보가 포함되어 있는지 확인하세요:</p>
<pre><code class="hljs language-js">openssl x509 -<span class="hljs-keyword">in</span> server.<span class="hljs-property">cert</span> -text -noout
openssl rsa -<span class="hljs-keyword">in</span> private.<span class="hljs-property">key</span> -text -noout
</code></pre>
<p>만약 필요하다면, 개인 키 파일은 암호로 보호되지 않습니다. 암호로 보호되어 있다면 개인 키에서 암호구를 제거해야 할 수도 있습니다.</p>
<pre><code class="hljs language-js">openssl rsa -<span class="hljs-keyword">in</span> private.<span class="hljs-property">key</span> -out private.<span class="hljs-property">key</span>
</code></pre>
<p>인증서를 확인하려면</p>
<pre><code class="hljs language-js">openssl verify server.<span class="hljs-property">crt</span>
</code></pre>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"우분투에서 아파치용 SAN이 포함된 Self-Signed SSL 인증서 만들기 방법","description":"","date":"2024-05-18 21:44","slug":"2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu","content":"\n\n웹 응용 프로그램을 SSL 인증서로 안전하게 보호하는 것은 클라이언트와 서버 간에 전송되는 데이터의 기밀성과 무결성을 보장하기 위해 중요합니다. 이 튜토리얼에서는 Ubuntu 운영 체제의 Apache 웹 서버에 대한 서브젝트 대체 이름 (SAN)이 포함된 자체 서명 SSL 인증서를 생성하는 과정을 안내합니다.\n\n# 필수 사항\n\n시작하기 전에 다음 사항을 확인하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Apache가 설치된 Ubuntu 서버\n- openssl 도구가 설치되어 있습니다.\n\n우선, 프론트엔드 폴더로 이동해주세요.\n\n### 단계 1: 디렉토리 생성\n\n인증서를 위한 디렉토리를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmkdir certificates\ncd certificates\n```\n\n# 단계 2: 개인 키 생성\n\n```js\nopenssl genpkey -algorithm RSA -out private.key\n```\n\n- genpkey: 이 하위 명령어는 개인 키를 생성하는 데 사용됩니다.\n- -algorithm RSA: 키 생성에 사용할 알고리즘을 지정합니다. 이 경우 RSA (Rivest–Shamir–Adleman) 알고리즘을 사용합니다. RSA는 널리 사용되는 비대칭 암호 알고리즘입니다.\n- -out private.key: 생성된 개인 키를 저장할 출력 파일을 지정합니다. 이 예에서는 개인 키가 private.key라는 파일에 저장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[비권장] 만약 당신의 private.key가 암호로 보호되기를 원한다면 -\n\n```js\nopenssl genpkey -algorithm RSA -aes256 -out private.key\n```\n\n-aes256:\n\n- 이 매개변수는 개인 키에 사용할 암호화 알고리즘을 나타냅니다. 이 경우 AES (고급 암호화 표준)와 키 길이가 256비트인 AES-256를 사용합니다. 이 매개변수는 추가 보안을 위해 개인 키를 AES-256로 암호화하는 것을 보장합니다. 사용자는 키 생성 과정 중에 암호를 입력하도록 요청받으며, 이 암호는 개인 키를 암호화하는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 아래의 정보를 Markdown 형식으로 변환해 드릴게요.\n\n```\nYou’ll be prompted to enter a passphrase; remember this passphrase as you’ll need it later.\n\n## Step 3: Create a SAN Configuration File\n\nCreate a file named san.conf with the following content:\n\n```js\n[req]\ndistinguished_name = req_distinguished_name\nreq_extensions = req_ext\nprompt = no\n\n[req_distinguished_name]\nCN = localhost\nC = BD\nST = Dhaka\nL = Motijheel\nO = Robist\nOU = Developers\nemailAddress = smazoomder@gmail.com\n\n[req_ext]\nsubjectAltName = IP:192.168.0.88\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n(당신의 IP를 Ip 자리에 넣으세요)\n\n- [req]: 이 섹션은 인증서 요청에 대한 속성을 지정합니다.\n- distinguished_name = req_distinguished_name: 인증서를 요청하는 엔티티에 대한 다양한 세부 정보를 정의하는 식별 이름 섹션을 가리킵니다.\n- req_extensions = req_ext: 인증서에 추가 정보를 포함할 수 있는 확장 섹션을 가리킵니다.\n- prompt = no: 인증서 생성 과정 중에 인증서 세부 정보에 대한 프롬프트를 비활성화합니다.\n- [req_distinguished_name]: 공통 이름 (CN), 국가 (C), 주 (ST), 지역 (L), 조직 (O), 조직 단위 (OU) 및 이메일 주소와 같은 다양한 식별 이름 속성을 정의합니다.\n- CN = localhost: 일반적으로 인증서와 관련된 도메인 이름인 공통 이름(CN)을 지정합니다.\n- C = BD: 국가 속성으로 방글라데시를 나타냅니다.\n- ST = Dhaka: 주 속성으로 다카를 지정합니다.\n- L = Motijheel: 지역 속성으로 모티제엘을 나타냅니다.\n- O = Robist: 조직 속성으로 로비스트를 나타냅니다.\n- OU = Developers: 조직 단위 속성으로 개발자를 나타냅니다.\n- emailAddress = smazoomder@gmail.com: 인증서와 관련된 이메일 주소입니다.\n- [req_ext]: 추가 확장을 인증서에 포함할 수 있는 확장 섹션입니다.\n- subjectAltName = IP:192.168.0.88: 대체 식별자로 IP 주소(192.168.0.88)를 포함하는 Subject Alternative Name (SAN) 확장을 지정합니다.\n\n## Subject Alternative Name (SAN)의 내용 :\n\n- Subject: SSL/TLS 인증서의 맥락에서 \"주체\"는 일반적으로 인증서가 발행된 엔티티(웹사이트 또는 서버 등)를 가리킵니다. 일반적으로 공통 이름(CN), 조직 및 위치와 같은 정보를 포함합니다.\n- Alternative Name: \"대체 이름\"은 SSL/TLS 인증서에 포함될 수 있는 추가 식별자를 가리킵니다. 이러한 식별자는 공통 이름(CN)을 넘어서 유효한 인증서에 대한 다른 이름을 세분화하여 지정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## SAN 사용 이유:\n\n- 다중 식별자 지원: SAN을 통해 하나의 SSL/TLS 인증서가 여러 식별자에 대해 유효할 수 있습니다. 기존에는 SSL 인증서가 주된 도메인을 나타내는 공통 이름(CN) 필드를 기반으로 발급되었습니다. 그러나 유연성이 커지면서 SAN을 통해 추가 이름을 포함할 수 있게 되었습니다.\n- 다중 도메인 인증서: SAN은 하나의 인증서가 여러 도메인이나 서브도메인을 커버해야 하는 상황에서 특히 유용합니다. 각 도메인마다 별도의 인증서를 얻는 대신 SAN 확장을 지원하는 다중 도메인 인증서를 사용할 수 있습니다.\n- IP 주소 및 이메일 주소: SAN은 도메인 이름에만 국한되지 않습니다. IP 주소와 이메일 주소를 대체 식별자로 포함할 수도 있습니다. IP 주소를 통해 접근되는 서비스나 이메일 통신을 커버해야 하는 경우 유용합니다.\n- 와일드카드 인증서: SAN은 와일드카드 인증서와 함께 일반적으로 사용됩니다. 와일드카드 인증서는 도메인과 서브도메인을 커버하며, SAN은 추가 도메인을 더 확장할 수 있습니다.\n- 인증서 불일치 문제 회피: SAN을 포함하면 인증서 불일치 문제를 예방할 수 있습니다. 대체 이름을 통해 서비스에 액세스할 때, SAN의 존재로 인해 인증서가 여전히 유효하다고 간주됩니다.\n\n요약하면, Subject Alternative Name (SAN)은 SSL/TLS 인증서에 다중 식별자를 포함할 수 있는 확장 기능으로, 안전한 통신에서 다양한 명명 시나리오에 대한 유연성과 광범위한 커버리지를 제공합니다.\n\n# 단계 4: 인증서 서명 요청(CSR) 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nopenssl req -new -key private.key -out certificate.csr -config san.conf\n```\n\nopenssl req:\n\n- 이 명령어는 OpenSSL에서 인증서 요청을 생성하고 처리하는 데 사용됩니다.\n\n-new:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 새로운 CSR (인증서 서명 요청)이 생성되고 있음을 나타냅니다.\n\n- -key private.key:\n\n- CSR을 생성하는 데 사용될 개인 키 파일을 지정합니다. 이전 단계에서 생성 된 개인 키 (private.key)가 여기에서 사용됩니다.\n\n- -out certificate.csr:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 생성된 CSR이 저장될 출력 파일을 지정합니다. 이 예시에서는 CSR이 certificate.csr이라는 파일에 저장됩니다.\n\n- `config san.conf`:\n\n- 인증서에 대한 부가 설정 및 Subject Alternative Names (SANs)을 포함하는 구성 파일 (san.conf)을 지정합니다.\n\n# 단계 5: 자체 서명 인증서 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\nopenssl x509 -req -in certificate.csr -signkey private.key -out server.cert -days 365\n```\n\nopenssl x509:\n\n- X.509 인증서 파일에 서명하고 표시하는 데 사용되는 OpenSSL 명령입니다.\n\n-req:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 입력 파일(certificate.csr)이 인증 요청서(CSR)임을 나타냅니다.\n\n- certificate.csr 파일 안에:\n\n- 서명이 필요한 인증 요청서(CSR)가 포함된 입력 파일을 지정합니다. 이 예에서 CSR 파일은 certificate.csr입니다.\n\n- signkey private.key:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- CSR을 서명하고 인증서를 생성할 때 사용할 개인 키(private.key)를 지정합니다.\n\n- server.cert에 저장됩니다:\n\n- 서명된 X.509 인증서가 저장될 출력 파일을 지정합니다. 이 예시에서는 인증서 파일의 이름을 server.cert로 지정합니다.\n\n- 365일 동안 유효합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 인증서의 유효 기간을 일(day) 단위로 지정합니다.이 경우 인증서는 365일(1년) 동안 유효합니다.\n\n## X.509 인증서 소개\n\nX.509 인증서는 공개 키 인증서의 형식과 구조를 정의하는 X.509 표준을 따르는 디지털 인증서입니다. 이러한 인증서는 TLS/SSL을 포함한 인터넷 보안 프로토콜에서 널리 사용됩니다. 아래는 X.509 인증서의 구성 요소입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 버전: X.509 표준의 버전을 나타냅니다. (예: 버전 1, 2 또는 3)\n- 일련 번호: 인증서 발급자 (인증 기관)가 할당한 고유 식별자로, 인증서를 구분합니다.\n- 서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용한 암호화 알고리즘을 지정합니다.\n- 발급자: 인증서를 발급한 엔터티 (일반적으로 인증 기관)를 식별합니다.\n- 유효 기간: 인증서의 유효성을 나타내는 시간 범위를 정의합니다. \"발효일\"과 \"만료일\"이 포함됩니다.\n- 주체: 인증서의 공개 키와 관련된 엔터티 (예: 사람, 조직 또는 장치)를 식별합니다.\n- 주체 공개 키 정보: 주체가 사용하는 공개 키와 알고리즘을 포함합니다.\n- 확장: 인증서와 관련된 추가 정보 또는 속성을 포함합니다. 주체 대체 이름 (SAN), 키 사용 등이 포함될 수 있습니다.\n- 인증서 서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용하는 알고리즘을 지정합니다.\n- 인증서 서명 값: 인증 기관에 의해 생성된 디지털 서명을 포함하여 인증서의 무결성과 신뢰성을 보장합니다.\n\n# X.509 인증서의 목적:\n\n- 인증: 인증서 소지자의 신원을 확인합니다.\n- 암호화: 공개 키를 사용하여 데이터를 암호화하여 안전한 통신을 지원합니다.\n- 디지털 서명: 디지털 서명의 생성과 검증을 통해 데이터 무결성을 보장합니다.\n- 키 교환: 안전한 통신 프로토콜에서 암호 키 교환을 지원합니다.\n\n# SSL/TLS에서의 사용:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- SSL/TLS 프로토콜에서 X.509 인증서는 클라이언트와 서버 간 안전한 연결을 설정하는 데 필수적입니다. 클라이언트가 안전한 웹 사이트에 연결할 때, 서버는 자체 X.509 인증서를 제출하고 클라이언트는 이를 확인하여 안전하고 신뢰할 수 있는 연결을 보장합니다.\n- X.509 인증서는 내부 사용을 위해 자체 서명될 수도 있고, 공개적인 웹 사이트를 위해 신뢰할 수 있는 인증 기관에 의해 서명될 수도 있습니다.\n\n웹 보안, 시스템 관리 또는 소프트웨어 개발에 관여하는 모든 사람에게 X.509 인증서를 이해하는 것이 중요합니다.\n\n# 단계 6: Apache 구성 업데이트\n\nApache 가상 호스트 구성을 업데이트하세요 (/etc/apache2/sites-available/your-site.conf):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 가상 호스트 설정:\n\n- **`VirtualHost *:443`**: 443 포트에서 HTTPS 통신을 위한 가상 호스트 블록을 정의합니다.\n\n- **`ServerName localhost`**: 이 가상 호스트와 연결된 기본 도메인 이름을 지정합니다. 이 경우 \"localhost\"로 설정되어 있습니다.\n \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nServerAdmin webmaster@localhost: 서버 관리자의 이메일 주소.\n\nDocumentRoot /var/www/html/your-project/backend/public: 이 VirtualHost의 문서 루트 디렉터리를 설정합니다. 이것은 웹 서버가 파일을 제공하는 위치입니다.\n\nSSLEngine on: SSL 연결을 처리해야 함을 나타내는이 VirtualHost를위한 SSL 엔진을 활성화합니다.\n\nSSLUseStapling off: SSL 스테이플링을 비활성화합니다. SSL 스테이플링은 SSL/TLS 인증서 확인을 강화하는 메커니즘입니다. 그러나이 예제에서는 비활성화되어 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSSLCertificateFile /var/www/html/your-project/certificates/server.cert: SSL 인증서 파일의 경로를 지정합니다. 이는 이전 단계에서 생성된 공개 키 인증서 파일입니다.\n\nSSLCertificateKeyFile /var/www/html/your-project/certificates/private.key: SSL 인증서와 관련된 개인 키 파일의 경로를 지정합니다.\n\nServerAlias 192.168.0.88: 이 VirtualHost가 응답해야 하는 추가 도메인 이름 또는 IP 주소를 지정합니다. 여기서는 IP 주소 192.168.0.88이 포함됩니다.\n\n`Directory \"/var/www/html/your-project/backend/public\"`: 지정된 디렉토리에 대한 구성 블록을 시작합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOptions All: 이 디렉토리에 대해 사용 가능한 모든 옵션을 허용합니다.\n\nAllowOverride All: 이 디렉토리에서 .htaccess 파일을 사용하여 구성 재정의를 허용합니다.\n\nRequire all granted: 모든 사용자에게 액세스를 부여합니다.\n\n`/Directory`: 지정된 디렉토리에 대한 구성 블록을 종료합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`/VirtualHost` : VirtualHost 블록을 종료합니다.\n\n# 설정 목적:\n\n- 이 구성 블록은 Apache가 지정된 도메인 (localhost 및 192.168.0.88)에 대한 SSL 연결을 어떻게 처리해야 하는지를 보장합니다. SSL 인증서 파일을 가리키고 연관 디렉토리에 대한 액세스 설정을 정의합니다.\n- \"/var/www/html/your-project\"와 같은 자리 표시자를 프로젝트에서 실제 사용하는 경로로 교체해야 합니다.\n\n그런 다음 활성화하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsudo a2ensite your-site.conf\n```\n\n# 단계 7: 아파치 재시작\n\n```js\nsudo systemctl restart apache2\n```\n\nSSL/TLS 키의 암호를 입력하라는 프롬프트가 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 8: Apache 오류 로그 확인\n\n```bash\nsudo tail -f /var/log/apache2/error.log\n```\n\nSSL과 관련된 오류 메시지를 확인해 보세요.\n\n# 단계 9: 라라벨 저장소 권한 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncd /var/www/html/your-project/backend\nsudo chmod -R 775 storage\nsudo chown -R www-data:www-data storage\n```\n\n이제 https://192.168.0.88 (당신의 IP)에서 애플리케이션에 안전하게 액세스할 수 있어야 합니다.\n\n# 단계 10: React/Laravel 애플리케이션을 실행 중이라면\n\n프론트엔드 환경에서:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nREACT_APP_NAME = 'your-project'\nREACT_APP_VERSION = v1.1.0\nGENERATE_SOURCEMAP = false\n\nREACT_APP_API_BASE_URL='https://192.168.0.88/api'\nREACT_APP_ASSET_BASE_URL='https://192.168.0.88/storage'\nREACT_APP_MAIN_DOMAIN='192.168.0.88:3000'\nREACT_APP_API_DOMAIN='https://192.168.0.88'\nREACT_APP_BACK_DOMAIN = 'https://192.168.0.88'\n\nREACT_APP_SITE_KEY = 'your-key'\n\n\nin backend env :\n\n\nAPP_URL=https://192.168.0.88\nAPP_SITE_URL=\"https://192.168.0.88:3000\"\n\n\n축하합니다! Ubuntu에서 Apache 웹 서버에 대한 Subject Alternative Name이 포함된 자체 서명 SSL 인증서를 성공적으로 생성했습니다.\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제가 있으면 다음을 실행해 보세요\n\n```js\nsudo systemctl restart apache2\n```\n\n```js\ncd /var/www/html/your-project/backend\nsudo chmod -R 775 storage\nsudo chown -R www-data:www-data storage\n```\n\n# (선택 사항) /etc/hosts 파일 업데이트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n친구야, 아래와 같이 /etc/hosts 파일에 localhost와 192.168.0.88(IP 주소)의 항목이 있는지 확인해 주세요.\n\n# (선택 사항) Chrome에서 인증서를 가져오는 방법:\n\n- 권한 생성 및 인증서를 CRT 형식으로 변환:\n\n```js\nopenssl x509 -in server.cert -out server.crt\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- PKCS#12 형식으로 인증서 및 키 변환하기:\n\n```js\nopenssl pkcs12 -export -out certificate.pfx -inkey private.key -in server.cert\n```\n\n개인 키의 암호를 입력하라는 프롬프트가 표시됩니다.\n\n3. Chrome에 인증서 가져오기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 크롬을 열고 설정으로 이동합니다.\n- 아래로 스크롤하여 고급을 클릭합니다.\n- 개인 정보 및 보안 아래에서 인증서 관리를 클릭합니다.\n- 인증서 창에서 개인 탭으로 이동합니다.\n- 가져오기를 클릭하고 생성한 certificate.pfx 파일을 선택합니다.\n- 가져오기 마법사를 따라가고 암호를 입력하고 나오면 상점을 선택합니다.\n\n4. 신뢰할 수 있는 인증 기관(CA)을 추가하려면 다음을 수행하십시오:\n\n```js\nsudo cp server.crt /usr/local/share/ca-certificates/server.crt\nsudo update-ca-certificates\n```\n\n다음 명령을 사용하여 인증서가 신뢰 목록에 추가되었는지 확인하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nawk -v cmd='openssl x509 -noout -subject' ' /BEGIN/{close(cmd)};{print | cmd}' \u003c /etc/ssl/certs/ca-certificates.crt | grep -i localhost\n```\n\n인증서의 전체 세부 정보를 확인하려면 OpenSSL 또는 다른 도구를 사용할 수 있습니다. 예를 들어 OpenSSL을 사용하여 다음과 같이 실행할 수 있습니다.\n\n```js\nopenssl x509 -in server.cert -text -noout\n```\n\n만료 날짜 확인: SSL 인증서가 만료되지 않았는지 확인하십시오. 다음 OpenSSL 명령어를 사용하여 만료 날짜를 확인할 수 있습니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nopenssl x509 -enddate -noout -in server.cert\n```\n\n인증서 내용 확인:\n\nOpenSSL을 사용하여 인증서 및 개인 키 파일의 내용을 확인할 수 있습니다. 원하는 정보가 포함되어 있는지 확인하세요:\n\n```js\nopenssl x509 -in server.cert -text -noout\nopenssl rsa -in private.key -text -noout\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 필요하다면, 개인 키 파일은 암호로 보호되지 않습니다. 암호로 보호되어 있다면 개인 키에서 암호구를 제거해야 할 수도 있습니다.\n\n```js\nopenssl rsa -in private.key -out private.key\n```\n\n인증서를 확인하려면\n\n```js\nopenssl verify server.crt\n```","ogImage":{"url":"/assets/img/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu_0.png"},"coverImage":"/assets/img/2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e웹 응용 프로그램을 SSL 인증서로 안전하게 보호하는 것은 클라이언트와 서버 간에 전송되는 데이터의 기밀성과 무결성을 보장하기 위해 중요합니다. 이 튜토리얼에서는 Ubuntu 운영 체제의 Apache 웹 서버에 대한 서브젝트 대체 이름 (SAN)이 포함된 자체 서명 SSL 인증서를 생성하는 과정을 안내합니다.\u003c/p\u003e\n\u003ch1\u003e필수 사항\u003c/h1\u003e\n\u003cp\u003e시작하기 전에 다음 사항을 확인하세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApache가 설치된 Ubuntu 서버\u003c/li\u003e\n\u003cli\u003eopenssl 도구가 설치되어 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e우선, 프론트엔드 폴더로 이동해주세요.\u003c/p\u003e\n\u003ch3\u003e단계 1: 디렉토리 생성\u003c/h3\u003e\n\u003cp\u003e인증서를 위한 디렉토리를 생성하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emkdir certificates\ncd certificates\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 2: 개인 키 생성\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eopenssl genpkey -algorithm \u003cspan class=\"hljs-variable constant_\"\u003eRSA\u003c/span\u003e -out private.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003egenpkey: 이 하위 명령어는 개인 키를 생성하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e-algorithm RSA: 키 생성에 사용할 알고리즘을 지정합니다. 이 경우 RSA (Rivest–Shamir–Adleman) 알고리즘을 사용합니다. RSA는 널리 사용되는 비대칭 암호 알고리즘입니다.\u003c/li\u003e\n\u003cli\u003e-out private.key: 생성된 개인 키를 저장할 출력 파일을 지정합니다. 이 예에서는 개인 키가 private.key라는 파일에 저장됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e[비권장] 만약 당신의 private.key가 암호로 보호되기를 원한다면 -\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eopenssl genpkey -algorithm \u003cspan class=\"hljs-variable constant_\"\u003eRSA\u003c/span\u003e -aes256 -out private.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e-aes256:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 매개변수는 개인 키에 사용할 암호화 알고리즘을 나타냅니다. 이 경우 AES (고급 암호화 표준)와 키 길이가 256비트인 AES-256를 사용합니다. 이 매개변수는 추가 보안을 위해 개인 키를 AES-256로 암호화하는 것을 보장합니다. 사용자는 키 생성 과정 중에 암호를 입력하도록 요청받으며, 이 암호는 개인 키를 암호화하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e안녕하세요! 아래의 정보를 Markdown 형식으로 변환해 드릴게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eYou’ll be prompted to enter a passphrase; remember this passphrase as you’ll need it later.\n\n## Step 3: Create a SAN Configuration File\n\nCreate a file named san.conf with the following content:\n\n```js\n[req]\ndistinguished_name = req_distinguished_name\nreq_extensions = req_ext\nprompt = no\n\n[req_distinguished_name]\nCN = localhost\nC = BD\nST = Dhaka\nL = Motijheel\nO = Robist\nOU = Developers\nemailAddress = smazoomder@gmail.com\n\n[req_ext]\nsubjectAltName = IP:192.168.0.88\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(당신의 IP를 Ip 자리에 넣으세요)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e[req]: 이 섹션은 인증서 요청에 대한 속성을 지정합니다.\u003c/li\u003e\n\u003cli\u003edistinguished_name = req_distinguished_name: 인증서를 요청하는 엔티티에 대한 다양한 세부 정보를 정의하는 식별 이름 섹션을 가리킵니다.\u003c/li\u003e\n\u003cli\u003ereq_extensions = req_ext: 인증서에 추가 정보를 포함할 수 있는 확장 섹션을 가리킵니다.\u003c/li\u003e\n\u003cli\u003eprompt = no: 인증서 생성 과정 중에 인증서 세부 정보에 대한 프롬프트를 비활성화합니다.\u003c/li\u003e\n\u003cli\u003e[req_distinguished_name]: 공통 이름 (CN), 국가 (C), 주 (ST), 지역 (L), 조직 (O), 조직 단위 (OU) 및 이메일 주소와 같은 다양한 식별 이름 속성을 정의합니다.\u003c/li\u003e\n\u003cli\u003eCN = localhost: 일반적으로 인증서와 관련된 도메인 이름인 공통 이름(CN)을 지정합니다.\u003c/li\u003e\n\u003cli\u003eC = BD: 국가 속성으로 방글라데시를 나타냅니다.\u003c/li\u003e\n\u003cli\u003eST = Dhaka: 주 속성으로 다카를 지정합니다.\u003c/li\u003e\n\u003cli\u003eL = Motijheel: 지역 속성으로 모티제엘을 나타냅니다.\u003c/li\u003e\n\u003cli\u003eO = Robist: 조직 속성으로 로비스트를 나타냅니다.\u003c/li\u003e\n\u003cli\u003eOU = Developers: 조직 단위 속성으로 개발자를 나타냅니다.\u003c/li\u003e\n\u003cli\u003eemailAddress = \u003ca href=\"mailto:smazoomder@gmail.com\"\u003esmazoomder@gmail.com\u003c/a\u003e: 인증서와 관련된 이메일 주소입니다.\u003c/li\u003e\n\u003cli\u003e[req_ext]: 추가 확장을 인증서에 포함할 수 있는 확장 섹션입니다.\u003c/li\u003e\n\u003cli\u003esubjectAltName = IP:192.168.0.88: 대체 식별자로 IP 주소(192.168.0.88)를 포함하는 Subject Alternative Name (SAN) 확장을 지정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eSubject Alternative Name (SAN)의 내용 :\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSubject: SSL/TLS 인증서의 맥락에서 \"주체\"는 일반적으로 인증서가 발행된 엔티티(웹사이트 또는 서버 등)를 가리킵니다. 일반적으로 공통 이름(CN), 조직 및 위치와 같은 정보를 포함합니다.\u003c/li\u003e\n\u003cli\u003eAlternative Name: \"대체 이름\"은 SSL/TLS 인증서에 포함될 수 있는 추가 식별자를 가리킵니다. 이러한 식별자는 공통 이름(CN)을 넘어서 유효한 인증서에 대한 다른 이름을 세분화하여 지정할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eSAN 사용 이유:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e다중 식별자 지원: SAN을 통해 하나의 SSL/TLS 인증서가 여러 식별자에 대해 유효할 수 있습니다. 기존에는 SSL 인증서가 주된 도메인을 나타내는 공통 이름(CN) 필드를 기반으로 발급되었습니다. 그러나 유연성이 커지면서 SAN을 통해 추가 이름을 포함할 수 있게 되었습니다.\u003c/li\u003e\n\u003cli\u003e다중 도메인 인증서: SAN은 하나의 인증서가 여러 도메인이나 서브도메인을 커버해야 하는 상황에서 특히 유용합니다. 각 도메인마다 별도의 인증서를 얻는 대신 SAN 확장을 지원하는 다중 도메인 인증서를 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eIP 주소 및 이메일 주소: SAN은 도메인 이름에만 국한되지 않습니다. IP 주소와 이메일 주소를 대체 식별자로 포함할 수도 있습니다. IP 주소를 통해 접근되는 서비스나 이메일 통신을 커버해야 하는 경우 유용합니다.\u003c/li\u003e\n\u003cli\u003e와일드카드 인증서: SAN은 와일드카드 인증서와 함께 일반적으로 사용됩니다. 와일드카드 인증서는 도메인과 서브도메인을 커버하며, SAN은 추가 도메인을 더 확장할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e인증서 불일치 문제 회피: SAN을 포함하면 인증서 불일치 문제를 예방할 수 있습니다. 대체 이름을 통해 서비스에 액세스할 때, SAN의 존재로 인해 인증서가 여전히 유효하다고 간주됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e요약하면, Subject Alternative Name (SAN)은 SSL/TLS 인증서에 다중 식별자를 포함할 수 있는 확장 기능으로, 안전한 통신에서 다양한 명명 시나리오에 대한 유연성과 광범위한 커버리지를 제공합니다.\u003c/p\u003e\n\u003ch1\u003e단계 4: 인증서 서명 요청(CSR) 생성\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eopenssl req -\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e -key private.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e -out certificate.\u003cspan class=\"hljs-property\"\u003ecsr\u003c/span\u003e -config san.\u003cspan class=\"hljs-property\"\u003econf\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eopenssl req:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 명령어는 OpenSSL에서 인증서 요청을 생성하고 처리하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e-new:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e새로운 CSR (인증서 서명 요청)이 생성되고 있음을 나타냅니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e-key private.key:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCSR을 생성하는 데 사용될 개인 키 파일을 지정합니다. 이전 단계에서 생성 된 개인 키 (private.key)가 여기에서 사용됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e-out certificate.csr:\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e생성된 CSR이 저장될 출력 파일을 지정합니다. 이 예시에서는 CSR이 certificate.csr이라는 파일에 저장됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003econfig san.conf\u003c/code\u003e:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e인증서에 대한 부가 설정 및 Subject Alternative Names (SANs)을 포함하는 구성 파일 (san.conf)을 지정합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e단계 5: 자체 서명 인증서 생성\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003eopenssl x509 -req -\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e certificate.csr -signkey private.key -out server.cert -days 365\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eopenssl x509:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eX.509 인증서 파일에 서명하고 표시하는 데 사용되는 OpenSSL 명령입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e-req:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e입력 파일(certificate.csr)이 인증 요청서(CSR)임을 나타냅니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ecertificate.csr 파일 안에:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e서명이 필요한 인증 요청서(CSR)가 포함된 입력 파일을 지정합니다. 이 예에서 CSR 파일은 certificate.csr입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003esignkey private.key:\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eCSR을 서명하고 인증서를 생성할 때 사용할 개인 키(private.key)를 지정합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eserver.cert에 저장됩니다:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e서명된 X.509 인증서가 저장될 출력 파일을 지정합니다. 이 예시에서는 인증서 파일의 이름을 server.cert로 지정합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e365일 동안 유효합니다:\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e인증서의 유효 기간을 일(day) 단위로 지정합니다.이 경우 인증서는 365일(1년) 동안 유효합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eX.509 인증서 소개\u003c/h2\u003e\n\u003cp\u003eX.509 인증서는 공개 키 인증서의 형식과 구조를 정의하는 X.509 표준을 따르는 디지털 인증서입니다. 이러한 인증서는 TLS/SSL을 포함한 인터넷 보안 프로토콜에서 널리 사용됩니다. 아래는 X.509 인증서의 구성 요소입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e버전: X.509 표준의 버전을 나타냅니다. (예: 버전 1, 2 또는 3)\u003c/li\u003e\n\u003cli\u003e일련 번호: 인증서 발급자 (인증 기관)가 할당한 고유 식별자로, 인증서를 구분합니다.\u003c/li\u003e\n\u003cli\u003e서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용한 암호화 알고리즘을 지정합니다.\u003c/li\u003e\n\u003cli\u003e발급자: 인증서를 발급한 엔터티 (일반적으로 인증 기관)를 식별합니다.\u003c/li\u003e\n\u003cli\u003e유효 기간: 인증서의 유효성을 나타내는 시간 범위를 정의합니다. \"발효일\"과 \"만료일\"이 포함됩니다.\u003c/li\u003e\n\u003cli\u003e주체: 인증서의 공개 키와 관련된 엔터티 (예: 사람, 조직 또는 장치)를 식별합니다.\u003c/li\u003e\n\u003cli\u003e주체 공개 키 정보: 주체가 사용하는 공개 키와 알고리즘을 포함합니다.\u003c/li\u003e\n\u003cli\u003e확장: 인증서와 관련된 추가 정보 또는 속성을 포함합니다. 주체 대체 이름 (SAN), 키 사용 등이 포함될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e인증서 서명 알고리즘: 인증 기관이 인증서에 서명하는 데 사용하는 알고리즘을 지정합니다.\u003c/li\u003e\n\u003cli\u003e인증서 서명 값: 인증 기관에 의해 생성된 디지털 서명을 포함하여 인증서의 무결성과 신뢰성을 보장합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eX.509 인증서의 목적:\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e인증: 인증서 소지자의 신원을 확인합니다.\u003c/li\u003e\n\u003cli\u003e암호화: 공개 키를 사용하여 데이터를 암호화하여 안전한 통신을 지원합니다.\u003c/li\u003e\n\u003cli\u003e디지털 서명: 디지털 서명의 생성과 검증을 통해 데이터 무결성을 보장합니다.\u003c/li\u003e\n\u003cli\u003e키 교환: 안전한 통신 프로토콜에서 암호 키 교환을 지원합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eSSL/TLS에서의 사용:\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eSSL/TLS 프로토콜에서 X.509 인증서는 클라이언트와 서버 간 안전한 연결을 설정하는 데 필수적입니다. 클라이언트가 안전한 웹 사이트에 연결할 때, 서버는 자체 X.509 인증서를 제출하고 클라이언트는 이를 확인하여 안전하고 신뢰할 수 있는 연결을 보장합니다.\u003c/li\u003e\n\u003cli\u003eX.509 인증서는 내부 사용을 위해 자체 서명될 수도 있고, 공개적인 웹 사이트를 위해 신뢰할 수 있는 인증 기관에 의해 서명될 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e웹 보안, 시스템 관리 또는 소프트웨어 개발에 관여하는 모든 사람에게 X.509 인증서를 이해하는 것이 중요합니다.\u003c/p\u003e\n\u003ch1\u003e단계 6: Apache 구성 업데이트\u003c/h1\u003e\n\u003cp\u003eApache 가상 호스트 구성을 업데이트하세요 (/etc/apache2/sites-available/your-site.conf):\u003c/p\u003e\n\u003ch1\u003e가상 호스트 설정:\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eVirtualHost *:443\u003c/code\u003e\u003c/strong\u003e: 443 포트에서 HTTPS 통신을 위한 가상 호스트 블록을 정의합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eServerName localhost\u003c/code\u003e\u003c/strong\u003e: 이 가상 호스트와 연결된 기본 도메인 이름을 지정합니다. 이 경우 \"localhost\"로 설정되어 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eServerAdmin webmaster@localhost: 서버 관리자의 이메일 주소.\u003c/p\u003e\n\u003cp\u003eDocumentRoot /var/www/html/your-project/backend/public: 이 VirtualHost의 문서 루트 디렉터리를 설정합니다. 이것은 웹 서버가 파일을 제공하는 위치입니다.\u003c/p\u003e\n\u003cp\u003eSSLEngine on: SSL 연결을 처리해야 함을 나타내는이 VirtualHost를위한 SSL 엔진을 활성화합니다.\u003c/p\u003e\n\u003cp\u003eSSLUseStapling off: SSL 스테이플링을 비활성화합니다. SSL 스테이플링은 SSL/TLS 인증서 확인을 강화하는 메커니즘입니다. 그러나이 예제에서는 비활성화되어 있습니다.\u003c/p\u003e\n\u003cp\u003eSSLCertificateFile /var/www/html/your-project/certificates/server.cert: SSL 인증서 파일의 경로를 지정합니다. 이는 이전 단계에서 생성된 공개 키 인증서 파일입니다.\u003c/p\u003e\n\u003cp\u003eSSLCertificateKeyFile /var/www/html/your-project/certificates/private.key: SSL 인증서와 관련된 개인 키 파일의 경로를 지정합니다.\u003c/p\u003e\n\u003cp\u003eServerAlias 192.168.0.88: 이 VirtualHost가 응답해야 하는 추가 도메인 이름 또는 IP 주소를 지정합니다. 여기서는 IP 주소 192.168.0.88이 포함됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eDirectory \"/var/www/html/your-project/backend/public\"\u003c/code\u003e: 지정된 디렉토리에 대한 구성 블록을 시작합니다.\u003c/p\u003e\n\u003cp\u003eOptions All: 이 디렉토리에 대해 사용 가능한 모든 옵션을 허용합니다.\u003c/p\u003e\n\u003cp\u003eAllowOverride All: 이 디렉토리에서 .htaccess 파일을 사용하여 구성 재정의를 허용합니다.\u003c/p\u003e\n\u003cp\u003eRequire all granted: 모든 사용자에게 액세스를 부여합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e/Directory\u003c/code\u003e: 지정된 디렉토리에 대한 구성 블록을 종료합니다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e/VirtualHost\u003c/code\u003e : VirtualHost 블록을 종료합니다.\u003c/p\u003e\n\u003ch1\u003e설정 목적:\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e이 구성 블록은 Apache가 지정된 도메인 (localhost 및 192.168.0.88)에 대한 SSL 연결을 어떻게 처리해야 하는지를 보장합니다. SSL 인증서 파일을 가리키고 연관 디렉토리에 대한 액세스 설정을 정의합니다.\u003c/li\u003e\n\u003cli\u003e\"/var/www/html/your-project\"와 같은 자리 표시자를 프로젝트에서 실제 사용하는 경로로 교체해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그런 다음 활성화하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esudo a2ensite your-site.\u003cspan class=\"hljs-property\"\u003econf\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 7: 아파치 재시작\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esudo systemctl restart apache2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSSL/TLS 키의 암호를 입력하라는 프롬프트가 표시됩니다.\u003c/p\u003e\n\u003ch1\u003e단계 8: Apache 오류 로그 확인\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003esudo \u003cspan class=\"hljs-built_in\"\u003etail\u003c/span\u003e -f /var/log/apache2/error.log\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSSL과 관련된 오류 메시지를 확인해 보세요.\u003c/p\u003e\n\u003ch1\u003e단계 9: 라라벨 저장소 권한 설정\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd /\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e/www/html/your-project/backend\nsudo chmod -R \u003cspan class=\"hljs-number\"\u003e775\u003c/span\u003e storage\nsudo chown -R www-\u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e:www-data storage\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 \u003ca href=\"https://192.168.0.88\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://192.168.0.88\u003c/a\u003e (당신의 IP)에서 애플리케이션에 안전하게 액세스할 수 있어야 합니다.\u003c/p\u003e\n\u003ch1\u003e단계 10: React/Laravel 애플리케이션을 실행 중이라면\u003c/h1\u003e\n\u003cp\u003e프론트엔드 환경에서:\u003c/p\u003e\n\u003cp\u003eREACT_APP_NAME = 'your-project'\nREACT_APP_VERSION = v1.1.0\nGENERATE_SOURCEMAP = false\u003c/p\u003e\n\u003cp\u003eREACT_APP_API_BASE_URL='\u003ca href=\"https://192.168.0.88/api\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://192.168.0.88/api\u003c/a\u003e'\nREACT_APP_ASSET_BASE_URL='\u003ca href=\"https://192.168.0.88/storage\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://192.168.0.88/storage\u003c/a\u003e'\nREACT_APP_MAIN_DOMAIN='192.168.0.88:3000'\nREACT_APP_API_DOMAIN='\u003ca href=\"https://192.168.0.88\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://192.168.0.88\u003c/a\u003e'\nREACT_APP_BACK_DOMAIN = '\u003ca href=\"https://192.168.0.88\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://192.168.0.88\u003c/a\u003e'\u003c/p\u003e\n\u003cp\u003eREACT_APP_SITE_KEY = 'your-key'\u003c/p\u003e\n\u003cp\u003ein backend env :\u003c/p\u003e\n\u003cp\u003eAPP_URL=\u003ca href=\"https://192.168.0.88\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://192.168.0.88\u003c/a\u003e\nAPP_SITE_URL=\"\u003ca href=\"https://192.168.0.88:3000\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://192.168.0.88:3000\u003c/a\u003e\"\u003c/p\u003e\n\u003cp\u003e축하합니다! Ubuntu에서 Apache 웹 서버에 대한 Subject Alternative Name이 포함된 자체 서명 SSL 인증서를 성공적으로 생성했습니다.\u003c/p\u003e\n\u003cp\u003e문제가 있으면 다음을 실행해 보세요\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esudo systemctl restart apache2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd /\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e/www/html/your-project/backend\nsudo chmod -R \u003cspan class=\"hljs-number\"\u003e775\u003c/span\u003e storage\nsudo chown -R www-\u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e:www-data storage\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e(선택 사항) /etc/hosts 파일 업데이트\u003c/h1\u003e\n\u003cp\u003e친구야, 아래와 같이 /etc/hosts 파일에 localhost와 192.168.0.88(IP 주소)의 항목이 있는지 확인해 주세요.\u003c/p\u003e\n\u003ch1\u003e(선택 사항) Chrome에서 인증서를 가져오는 방법:\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e권한 생성 및 인증서를 CRT 형식으로 변환:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eopenssl x509 -\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e server.\u003cspan class=\"hljs-property\"\u003ecert\u003c/span\u003e -out server.\u003cspan class=\"hljs-property\"\u003ecrt\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003ePKCS#12 형식으로 인증서 및 키 변환하기:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eopenssl pkcs12 -\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e -out certificate.\u003cspan class=\"hljs-property\"\u003epfx\u003c/span\u003e -inkey private.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e -\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e server.\u003cspan class=\"hljs-property\"\u003ecert\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e개인 키의 암호를 입력하라는 프롬프트가 표시됩니다.\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eChrome에 인증서 가져오기:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e크롬을 열고 설정으로 이동합니다.\u003c/li\u003e\n\u003cli\u003e아래로 스크롤하여 고급을 클릭합니다.\u003c/li\u003e\n\u003cli\u003e개인 정보 및 보안 아래에서 인증서 관리를 클릭합니다.\u003c/li\u003e\n\u003cli\u003e인증서 창에서 개인 탭으로 이동합니다.\u003c/li\u003e\n\u003cli\u003e가져오기를 클릭하고 생성한 certificate.pfx 파일을 선택합니다.\u003c/li\u003e\n\u003cli\u003e가져오기 마법사를 따라가고 암호를 입력하고 나오면 상점을 선택합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e신뢰할 수 있는 인증 기관(CA)을 추가하려면 다음을 수행하십시오:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esudo cp server.\u003cspan class=\"hljs-property\"\u003ecrt\u003c/span\u003e /usr/local/share/ca-certificates/server.\u003cspan class=\"hljs-property\"\u003ecrt\u003c/span\u003e\nsudo update-ca-certificates\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 명령을 사용하여 인증서가 신뢰 목록에 추가되었는지 확인하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eawk -v cmd=\u003cspan class=\"hljs-string\"\u003e'openssl x509 -noout -subject'\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e' /BEGIN/{close(cmd)};{print | cmd}'\u003c/span\u003e \u0026#x3C; \u003cspan class=\"hljs-regexp\"\u003e/etc/\u003c/span\u003essl/certs/ca-certificates.\u003cspan class=\"hljs-property\"\u003ecrt\u003c/span\u003e | grep -i localhost\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e인증서의 전체 세부 정보를 확인하려면 OpenSSL 또는 다른 도구를 사용할 수 있습니다. 예를 들어 OpenSSL을 사용하여 다음과 같이 실행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eopenssl x509 -\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e server.\u003cspan class=\"hljs-property\"\u003ecert\u003c/span\u003e -text -noout\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만료 날짜 확인: SSL 인증서가 만료되지 않았는지 확인하십시오. 다음 OpenSSL 명령어를 사용하여 만료 날짜를 확인할 수 있습니다.```\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eopenssl x509 -enddate -noout -\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e server.\u003cspan class=\"hljs-property\"\u003ecert\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e인증서 내용 확인:\u003c/p\u003e\n\u003cp\u003eOpenSSL을 사용하여 인증서 및 개인 키 파일의 내용을 확인할 수 있습니다. 원하는 정보가 포함되어 있는지 확인하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eopenssl x509 -\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e server.\u003cspan class=\"hljs-property\"\u003ecert\u003c/span\u003e -text -noout\nopenssl rsa -\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e private.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e -text -noout\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 필요하다면, 개인 키 파일은 암호로 보호되지 않습니다. 암호로 보호되어 있다면 개인 키에서 암호구를 제거해야 할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eopenssl rsa -\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e private.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e -out private.\u003cspan class=\"hljs-property\"\u003ekey\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e인증서를 확인하려면\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eopenssl verify server.\u003cspan class=\"hljs-property\"\u003ecrt\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-HowtoCreateaSelf-SignedSSLCertificatewithSANforApacheonUbuntu"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>