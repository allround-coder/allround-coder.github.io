<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ApolloClient와 함께 Fragment Colocation | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-FragmentColocationwithApolloClient" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ApolloClient와 함께 Fragment Colocation | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="ApolloClient와 함께 Fragment Colocation | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-FragmentColocationwithApolloClient_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-FragmentColocationwithApolloClient" data-gatsby-head="true"/><meta name="twitter:title" content="ApolloClient와 함께 Fragment Colocation | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-FragmentColocationwithApolloClient_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 00:20" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">ApolloClient와 함께 Fragment Colocation</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="ApolloClient와 함께 Fragment Colocation" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-FragmentColocationwithApolloClient&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>Fragment이란 무엇인가요?</h1>
<p>Fragment Colocation에 대해 논의하기 전에, 먼저 Fragment가 무엇인지 간단히 설명하겠습니다.</p>
<p>GraphQL에서 Fragment는 쿼리의 재사용 가능한 조각입니다. Fragment를 사용하면 코드 중복을 피하고 쿼리를 구성할 때 특히 여러 쿼리에서 같은 데이터 조각을 검색할 때 쿼리를 조직화할 수 있습니다.</p>
<pre><code class="hljs language-js">fragment <span class="hljs-title class_">UserDetails</span> on <span class="hljs-title class_">User</span> {
  id
  name
  email
}

query <span class="hljs-title class_">GetUser</span> {
  <span class="hljs-title function_">user</span>(<span class="hljs-params">id: <span class="hljs-number">1</span></span>) {
    ...<span class="hljs-title class_">UserDetails</span>
  }
}

query <span class="hljs-title class_">GetAllUsers</span> {
  users {
    ...<span class="hljs-title class_">UserDetails</span>
  }
}
</code></pre>
<p>이 예제에서는 UserDetails라는 fragment가 정의되었고 GetUser 및 GetAllUsers 쿼리 내에서 재사용됩니다. 이렇게 하면 동일한 데이터 부분을 여러 번 작성할 필요가 없어집니다. (이 코드는 ChatGPT에 의해 생성됨.)</p>
<h1>Fragment Colocation이란</h1>
<p>일본에서는 Fragment Colocation(apollo Client에서 fragment 일치)라고도 합니다.</p>
<p>Fragment Colocation은 GraphQL fragments가 해당 컴포넌트와 함께 배치되는 디자인 접근 방식입니다. 이 방식은 어떤 컴포넌트가 어떤 데이터를 필요로 하는지 명확히 알려주어 데이터 의존성을 관리하기 쉽게 만들어줍니다.</p>
<p>현대 프런트엔드 개발에서 데이터 가져오기와 표시는 밀접한 관련이 있습니다. 전통적인 방법은 종종 데이터 가져오기 로직을 여러 곳에 분산시켜 유지보수성과 재사용성이 감소하게 됩니다. Fragment Colocation은 이러한 문제를 중앙화하고 효율적으로 데이터 의존성을 조직화함으로써 해결합니다.</p>
<h1>Shippio의 문제점 ⛴</h1>
<p>Shippio에서는 Apollo Client를 GraphQL 클라이언트 라이브러리로 사용합니다.</p>
<p>그러나 몇 가지 문제가 발생했습니다:</p>
<ul>
<li>자식 컴포넌트가 의존하지 않는 필드를 포함하여 불필요한 props가 전달됩니다.</li>
<li>필요한 필드를 추가하려면 부모 컴포넌트의 쿼리 필드를 수정해야 했는데, 이는 상당한 영향을 미쳤습니다.</li>
<li>props를 통해 전달된 값이 서버에서 가져온 것인지 클라이언트에서 생성된 것인지 명확하지 않았습니다.</li>
<li>위 문제를 해결하기 위해 여러 자식 컴포넌트에서 useQuery를 사용하여 필요한 값만 가져오도록 했지만, 이는 GraphQL 같지 않았고 요청 수가 증가했습니다.</li>
<li>모든 쿼리를 단일 gql 디렉토리에 중앙 집중시키면 의존하는 컴포넌트를 식별하기 어려워졌습니다.</li>
</ul>
<h2>코드 샘플 (실제 코드가 아닙니다)</h2>
<pre><code class="hljs language-js"><span class="hljs-comment">// 파일 트리</span>

src
├── <span class="hljs-title class_">App</span>.<span class="hljs-property">tsx</span>
├── components
│   ├── <span class="hljs-title class_">ShipmentList</span>.<span class="hljs-property">tsx</span>
│   ├── <span class="hljs-title class_">ShipmentListHeader</span>.<span class="hljs-property">tsx</span> (<span class="hljs-title class_">ShipmentList</span>.<span class="hljs-property">tsx</span>의 자식 컴포넌트)
│   ├── <span class="hljs-title class_">ShipmentListItem</span>.<span class="hljs-property">tsx</span> (<span class="hljs-title class_">ShipmentList</span>.<span class="hljs-property">tsx</span>의 자식 컴포넌트)
└── gql
    ├── <span class="hljs-title class_">ShipmentListQuery</span>.<span class="hljs-property">ts</span> (쿼리)
</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// gql 폴더의 ShipmentListQuery</span>

<span class="hljs-keyword">import</span> { graphql } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/__codegen__'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ShipmentListQuery</span> = <span class="hljs-title function_">graphql</span>(<span class="hljs-string">`
  query ShipmentListQuery(
    $shipmentId: ID
    ...
  ) {
    shipmentSearch(
      shipmentId: $shipmentId
      ...
    ) {
      team {
       name
      }
      milestones {
        id
        milestoneType
        status
        completionDoneAt
      }
    }
  }
`</span>);

<span class="hljs-keyword">export</span> type <span class="hljs-title class_">ShipmentListQueryItem</span> = <span class="hljs-title class_">ArrayType</span>&#x3C;<span class="hljs-title class_">Query</span>[<span class="hljs-string">'shipmentSearch'</span>]>;
</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// ShipmentList.tsx (루트 컴포넌트)</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">ShipmentList</span> = (<span class="hljs-params"></span>) => {
  
   <span class="hljs-keyword">const</span> { data } = <span class="hljs-title function_">useQuery</span>(<span class="hljs-title class_">ShipmentListQuery</span>, 
    { <span class="hljs-attr">variables</span>: { ... } }
  )
  
  <span class="hljs-keyword">return</span> (
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Stack</span>></span>
     <span class="hljs-tag">&#x3C;<span class="hljs-name">ShipmentListHeader</span> <span class="hljs-attr">shipment</span>=<span class="hljs-string">{data.shipment}</span> /></span>
     <span class="hljs-tag">&#x3C;<span class="hljs-name">ShipmentListItem</span> <span class="hljs-attr">shipment</span>=<span class="hljs-string">{data.shipment}</span> /></span>
   <span class="hljs-tag">&#x3C;/<span class="hljs-name">Stack</span>></span></span>
}
</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// ShipmentListItem.tsx (ShipmentList.tsx의 하위 컴포넌트)</span>

type <span class="hljs-title class_">Props</span> = {
 <span class="hljs-attr">shipment</span>: <span class="hljs-title class_">ShipmentListQueryItem</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">ShipmentListItems</span> = (<span class="hljs-params">{ shipment }: Props</span>) => { 
  <span class="hljs-keyword">return</span> (
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Stack</span>></span>
     {shipment.milestones.map((milestone) => (
       <span class="hljs-tag">&#x3C;<span class="hljs-name">Box</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{milestone.id}</span>></span>
         <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span>></span>{milestone.milestoneType}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
           <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span>></span>{milestone.status}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
           <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span>></span>{milestone.completionDoneAt}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
         <span class="hljs-tag">&#x3C;/<span class="hljs-name">Box</span>></span>
     )}
   &#x3C;/Stack
}
</span></code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// ShipmentListHeader.tsx (ShipmentList.tsx의 하위 컴포넌트)</span>

type <span class="hljs-title class_">Props</span> = {
 <span class="hljs-attr">shipment</span>: <span class="hljs-title class_">ShipmentListQueryItem</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">ShipmentListHeader</span> = (<span class="hljs-params">{ shipment }: Props</span>) => { 
  <span class="hljs-keyword">return</span> (
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Stack</span>></span>
     <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span>></span>{shipment.team.name}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
   <span class="hljs-tag">&#x3C;/<span class="hljs-name">Stack</span>></span></span>
}
</code></pre>
<p>처음에는 이 접근 방식이 좋아 보입니다. 하지만 컴포넌트가 더 복잡해지고 구조가 더 중첩되면 위에서 언급한 문제가 발생할 수 있습니다.</p>
<h2>이슈 예시</h2>
<ul>
<li>ShipmentListHeader에서 팀 ID를 표시하려면 부모인 ShipmentList 컴포넌트의 쿼리를 수정해야 합니다. (자식 컴포넌트의 변경 사항이 부모 컴포넌트에 영향을 미칩니다.)</li>
<li>전체 data.shipment 객체를 전달하는 것은 의도하지 않은 처리로 이어질 수 있습니다.</li>
<li>ShipmentListItem은 마일스톤만 필요하지만 팀 정보도 받습니다.</li>
<li>ShipmentListHeader는 팀 정보만 필요하지만 마일스톤도 받습니다.</li>
</ul>
<h1>Apollo Client를 사용한 Fragment Colocation 연습</h1>
<p>위의 코드를 Fragment Colocation을 활용하여 개선해 봅시다.</p>
<p>이 글을 사용하기 위해 다음 패키지들이 필요합니다.</p>
<pre><code class="hljs language-js">@apollo/client
@graphql-codegen/cli
@graphql-codegen/client-preset
</code></pre>
<p>codegen.ts 파일의 설정은 아래와 같습니다. preset을 client로 설정하여 client-preset의 대부분 기능을 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// codegen.ts</span>

<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CodegenConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@graphql-codegen/cli'</span>
 
<span class="hljs-keyword">const</span> <span class="hljs-attr">config</span>: <span class="hljs-title class_">CodegenConfig</span> = {
  <span class="hljs-attr">schema</span>: <span class="hljs-string">'&#x3C;schema 경로>'</span>,
  <span class="hljs-attr">documents</span>: [<span class="hljs-string">'src/**/*.tsx'</span>],
  <span class="hljs-attr">ignoreNoDocuments</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">generates</span>: {
    <span class="hljs-string">'./src/__codegen__/'</span>: {
      <span class="hljs-attr">preset</span>: <span class="hljs-string">'client'</span>
    }
  }
}
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> config
</code></pre>
<p>참고 링크: <a href="https://the-guild.dev/graphql/codegen/docs/guides/react-vue" rel="nofollow" target="_blank">https://the-guild.dev/graphql/codegen/docs/guides/react-vue</a></p>
<h2>Fragment Colocation을 사용한 코드 재작성</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { graphql } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/__codegen__'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ShipmentListQuery</span> = <span class="hljs-title function_">graphql</span>(<span class="hljs-string">`
  query ShipmentListQuery(
    $shipmentId: ID
    ...
  ) {
    shipmentSearch(
      shipmentId: $shipmentId
      ...
    ) {
      ...ShipmentListHeaderFragment
      ...ShipmentListItemFragment
    }
  }
`</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">ShipmentList</span> = (<span class="hljs-params"></span>) => {
  
   <span class="hljs-keyword">const</span> { data } = <span class="hljs-title function_">useQuery</span>(<span class="hljs-title class_">ShipmentListQuery</span>, 
    { <span class="hljs-attr">variables</span>: { ... } }
  )
  
  <span class="hljs-keyword">return</span> (
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Stack</span>></span>
     <span class="hljs-tag">&#x3C;<span class="hljs-name">ShipmentListHeader</span> <span class="hljs-attr">shipment</span>=<span class="hljs-string">{data.shipment}</span> /></span>
     <span class="hljs-tag">&#x3C;<span class="hljs-name">ShipmentListItem</span> <span class="hljs-attr">shipment</span>=<span class="hljs-string">{data.shipment}</span> /></span>
   <span class="hljs-tag">&#x3C;/<span class="hljs-name">Stack</span>></span></span>
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FragmentType</span>, graphql, useFragment } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/__codegen__/"</span>

<span class="hljs-keyword">const</span> fragment = <span class="hljs-title function_">graphql</span>(<span class="hljs-string">`
  fragment ShipmentListItemFragment on Milestone {
      milestones {
        id
        milestoneType
        status
        completionDoneAt
      }
  }
`</span>)

type <span class="hljs-title class_">Props</span> = {
 <span class="hljs-attr">shipmentListItems</span>: <span class="hljs-title class_">FragmentType</span>&#x3C;<span class="hljs-keyword">typeof</span> fragment>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">ShipmentListItems</span> = (<span class="hljs-params">{ shipmentListItems }: Props</span>) => { 
   <span class="hljs-keyword">const</span> fragmentData = <span class="hljs-title function_">useFragment</span>(fragment, shipmentListItems)
   
  <span class="hljs-keyword">return</span> (
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Stack</span>></span>
     {fragmentData.map((milestone) => (
       <span class="hljs-tag">&#x3C;<span class="hljs-name">Box</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{milestone.id}</span>></span>
         <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span>></span>{milestone.milestoneType}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
           <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span>></span>{milestone.status}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
           <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span>></span>{milestone.completionDoneAt}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
         <span class="hljs-tag">&#x3C;/<span class="hljs-name">Box</span>></span>
     )}
   <span class="hljs-tag">&#x3C;/<span class="hljs-name">Stack</span>></span></span>
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FragmentType</span>, graphql, useFragment } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/__codegen__/"</span>

<span class="hljs-keyword">const</span> fragment = <span class="hljs-title function_">graphql</span>(<span class="hljs-string">`
  fragment ShipmentListHeaderFragment on Shipment {
      team {
       name
      }
  }
`</span>)

type <span class="hljs-title class_">Props</span> = {
 <span class="hljs-attr">shipmentHeader</span>: <span class="hljs-title class_">ShipmentListQueryItem</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">ShipmentListHeader</span> = (<span class="hljs-params">{ shipmentHeader }: Props</span>) => { 
   <span class="hljs-keyword">const</span> fragmentData = <span class="hljs-title function_">useFragment</span>(fragment, shipmentHeader)
   
  <span class="hljs-keyword">return</span> (
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Stack</span>></span>
     <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span>></span>{fragmentData.team.name}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
   <span class="hljs-tag">&#x3C;/<span class="hljs-name">Stack</span>></span></span>
}
</code></pre>
<p>위 코드에서 다음과 같은 이점을 얻을 수 있습니다:</p>
<ul>
<li>명확한 데이터 종속성: 각 컴포넌트는 필요한 데이터를 명시적으로 정의하여 종속성이 명확해집니다. 자식 컴포넌트에서 GraphQL 서버에서 가져오는 값을 조사하는 것이 더 쉬워집니다.</li>
<li>재사용성 향상: Fragment 사용은 코드 재사용을 촉진합니다. Fragment 유형도 생성되므로 타입 재사용이 가능합니다.</li>
<li>유지보수성 향상: 쿼리에 대한 변경 사항이 지역화되어 유지보수가 쉬워집니다. 상위 컴포넌트의 쿼리를 수정할 필요가 없습니다.</li>
<li>1 기능 컴포넌트에 1 루트 쿼리</li>
<li>데이터 캡슐화: Fragment 마스킹을 사용하여 종속성이 없는 컴포넌트에서 의도하지 않은 필드 사용을 차단할 수 있습니다.</li>
</ul>
<h1>보충: Fragment Masking</h1>
<p>Fragment Masking을 사용하면 Fragment 데이터의 속성을 상위 수준 구성 요소에서 숨기고 데이터 가시성을 제어할 수 있습니다. 다시 말해, 캡슐화를 강제합니다.</p>
<p><img src="/assets/img/2024-06-20-FragmentColocationwithApolloClient_1.png" alt="이미지"></p>
<p>참고: <a href="https://the-guild.dev/blog/unleash-the-power-of-fragments-with-graphql-codegen" rel="nofollow" target="_blank">https://the-guild.dev/blog/unleash-the-power-of-fragments-with-graphql-codegen</a></p>
<h1>결론</h1>
<p>Fragment Colocation은 React와 GraphQL을 사용하는 현대 프론트엔드 개발에서 매우 유용한 패턴입니다. 데이터 종속성을 명확히하고 재사용성과 유지보수성을 향상시킴으로써, 개발자는 더 효율적으로 고품질의 코드를 작성할 수 있습니다. 여러분의 프로젝트에서 이 접근 방식을 채택해보고 직접 이점을 경험해보는 것도 좋을 것입니다.</p>
<hr>
<p>만약 이 글이 여러분의 흥미를 자극했고, 이 지식을 활용하고 싶다면, 우리가 채용 중이니 확인해보세요!</p>
<p>아래 링크를 확인해보세요.
▼ 직업 기회</p>
<p><strong>▼ 연락처</strong>
LinkedIn: <a href="https://www.linkedin.com/company/shippioinc/" rel="nofollow" target="_blank">Shippio Inc.</a>
Shippio 인사팀 이메일 주소: <a href="mailto:shippiohr@shippio.io">shippiohr@shippio.io</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"ApolloClient와 함께 Fragment Colocation","description":"","date":"2024-06-20 00:20","slug":"2024-06-20-FragmentColocationwithApolloClient","content":"\n\n\n\u003cimg src=\"/assets/img/2024-06-20-FragmentColocationwithApolloClient_0.png\" /\u003e\n\n# Fragment이란 무엇인가요?\n\nFragment Colocation에 대해 논의하기 전에, 먼저 Fragment가 무엇인지 간단히 설명하겠습니다.\n\nGraphQL에서 Fragment는 쿼리의 재사용 가능한 조각입니다. Fragment를 사용하면 코드 중복을 피하고 쿼리를 구성할 때 특히 여러 쿼리에서 같은 데이터 조각을 검색할 때 쿼리를 조직화할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfragment UserDetails on User {\n  id\n  name\n  email\n}\n\nquery GetUser {\n  user(id: 1) {\n    ...UserDetails\n  }\n}\n\nquery GetAllUsers {\n  users {\n    ...UserDetails\n  }\n}\n```\n\n이 예제에서는 UserDetails라는 fragment가 정의되었고 GetUser 및 GetAllUsers 쿼리 내에서 재사용됩니다. 이렇게 하면 동일한 데이터 부분을 여러 번 작성할 필요가 없어집니다. (이 코드는 ChatGPT에 의해 생성됨.)\n\n# Fragment Colocation이란\n\n일본에서는 Fragment Colocation(apollo Client에서 fragment 일치)라고도 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFragment Colocation은 GraphQL fragments가 해당 컴포넌트와 함께 배치되는 디자인 접근 방식입니다. 이 방식은 어떤 컴포넌트가 어떤 데이터를 필요로 하는지 명확히 알려주어 데이터 의존성을 관리하기 쉽게 만들어줍니다.\n\n현대 프런트엔드 개발에서 데이터 가져오기와 표시는 밀접한 관련이 있습니다. 전통적인 방법은 종종 데이터 가져오기 로직을 여러 곳에 분산시켜 유지보수성과 재사용성이 감소하게 됩니다. Fragment Colocation은 이러한 문제를 중앙화하고 효율적으로 데이터 의존성을 조직화함으로써 해결합니다.\n\n# Shippio의 문제점 ⛴\n\nShippio에서는 Apollo Client를 GraphQL 클라이언트 라이브러리로 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 몇 가지 문제가 발생했습니다:\n\n- 자식 컴포넌트가 의존하지 않는 필드를 포함하여 불필요한 props가 전달됩니다.\n- 필요한 필드를 추가하려면 부모 컴포넌트의 쿼리 필드를 수정해야 했는데, 이는 상당한 영향을 미쳤습니다.\n- props를 통해 전달된 값이 서버에서 가져온 것인지 클라이언트에서 생성된 것인지 명확하지 않았습니다.\n- 위 문제를 해결하기 위해 여러 자식 컴포넌트에서 useQuery를 사용하여 필요한 값만 가져오도록 했지만, 이는 GraphQL 같지 않았고 요청 수가 증가했습니다.\n- 모든 쿼리를 단일 gql 디렉토리에 중앙 집중시키면 의존하는 컴포넌트를 식별하기 어려워졌습니다.\n\n## 코드 샘플 (실제 코드가 아닙니다)\n\n```js\n// 파일 트리\n\nsrc\n├── App.tsx\n├── components\n│   ├── ShipmentList.tsx\n│   ├── ShipmentListHeader.tsx (ShipmentList.tsx의 자식 컴포넌트)\n│   ├── ShipmentListItem.tsx (ShipmentList.tsx의 자식 컴포넌트)\n└── gql\n    ├── ShipmentListQuery.ts (쿼리)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\n// gql 폴더의 ShipmentListQuery\n\nimport { graphql } from '@/__codegen__';\n\nexport const ShipmentListQuery = graphql(`\n  query ShipmentListQuery(\n    $shipmentId: ID\n    ...\n  ) {\n    shipmentSearch(\n      shipmentId: $shipmentId\n      ...\n    ) {\n      team {\n       name\n      }\n      milestones {\n        id\n        milestoneType\n        status\n        completionDoneAt\n      }\n    }\n  }\n`);\n\nexport type ShipmentListQueryItem = ArrayType\u003cQuery['shipmentSearch']\u003e;\n```\n\n```javascript\n// ShipmentList.tsx (루트 컴포넌트)\n\nexport const ShipmentList = () =\u003e {\n  \n   const { data } = useQuery(ShipmentListQuery, \n    { variables: { ... } }\n  )\n  \n  return (\n   \u003cStack\u003e\n     \u003cShipmentListHeader shipment={data.shipment} /\u003e\n     \u003cShipmentListItem shipment={data.shipment} /\u003e\n   \u003c/Stack\u003e\n}\n```\n\n```javascript\n// ShipmentListItem.tsx (ShipmentList.tsx의 하위 컴포넌트)\n\ntype Props = {\n shipment: ShipmentListQueryItem;\n}\nexport const ShipmentListItems = ({ shipment }: Props) =\u003e { \n  return (\n   \u003cStack\u003e\n     {shipment.milestones.map((milestone) =\u003e (\n       \u003cBox key={milestone.id}\u003e\n         \u003cText\u003e{milestone.milestoneType}\u003c/Text\u003e\n           \u003cText\u003e{milestone.status}\u003c/Text\u003e\n           \u003cText\u003e{milestone.completionDoneAt}\u003c/Text\u003e\n         \u003c/Box\u003e\n     )}\n   \u003c/Stack\n}\n```\n\n```javascript\n// ShipmentListHeader.tsx (ShipmentList.tsx의 하위 컴포넌트)\n\ntype Props = {\n shipment: ShipmentListQueryItem;\n}\n\nexport const ShipmentListHeader = ({ shipment }: Props) =\u003e { \n  return (\n   \u003cStack\u003e\n     \u003cText\u003e{shipment.team.name}\u003c/Text\u003e\n   \u003c/Stack\u003e\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n처음에는 이 접근 방식이 좋아 보입니다. 하지만 컴포넌트가 더 복잡해지고 구조가 더 중첩되면 위에서 언급한 문제가 발생할 수 있습니다.\n\n## 이슈 예시\n\n- ShipmentListHeader에서 팀 ID를 표시하려면 부모인 ShipmentList 컴포넌트의 쿼리를 수정해야 합니다. (자식 컴포넌트의 변경 사항이 부모 컴포넌트에 영향을 미칩니다.)\n- 전체 data.shipment 객체를 전달하는 것은 의도하지 않은 처리로 이어질 수 있습니다.\n- ShipmentListItem은 마일스톤만 필요하지만 팀 정보도 받습니다.\n- ShipmentListHeader는 팀 정보만 필요하지만 마일스톤도 받습니다.\n\n# Apollo Client를 사용한 Fragment Colocation 연습\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드를 Fragment Colocation을 활용하여 개선해 봅시다.\n\n이 글을 사용하기 위해 다음 패키지들이 필요합니다.\n\n```js\n@apollo/client\n@graphql-codegen/cli\n@graphql-codegen/client-preset\n```\n\ncodegen.ts 파일의 설정은 아래와 같습니다. preset을 client로 설정하여 client-preset의 대부분 기능을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n// codegen.ts\n\nimport { CodegenConfig } from '@graphql-codegen/cli'\n \nconst config: CodegenConfig = {\n  schema: '\u003cschema 경로\u003e',\n  documents: ['src/**/*.tsx'],\n  ignoreNoDocuments: true,\n  generates: {\n    './src/__codegen__/': {\n      preset: 'client'\n    }\n  }\n}\n \nexport default config\r\n```\n\n참고 링크: https://the-guild.dev/graphql/codegen/docs/guides/react-vue\n\n## Fragment Colocation을 사용한 코드 재작성\n\n```js\r\nimport { graphql } from '@/__codegen__';\n\nexport const ShipmentListQuery = graphql(`\n  query ShipmentListQuery(\n    $shipmentId: ID\n    ...\n  ) {\n    shipmentSearch(\n      shipmentId: $shipmentId\n      ...\n    ) {\n      ...ShipmentListHeaderFragment\n      ...ShipmentListItemFragment\n    }\n  }\n`);\n\nexport const ShipmentList = () =\u003e {\n  \n   const { data } = useQuery(ShipmentListQuery, \n    { variables: { ... } }\n  )\n  \n  return (\n   \u003cStack\u003e\n     \u003cShipmentListHeader shipment={data.shipment} /\u003e\n     \u003cShipmentListItem shipment={data.shipment} /\u003e\n   \u003c/Stack\u003e\n}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { FragmentType, graphql, useFragment } from \"@/__codegen__/\"\n\nconst fragment = graphql(`\n  fragment ShipmentListItemFragment on Milestone {\n      milestones {\n        id\n        milestoneType\n        status\n        completionDoneAt\n      }\n  }\n`)\n\ntype Props = {\n shipmentListItems: FragmentType\u003ctypeof fragment\u003e\n}\n\nexport const ShipmentListItems = ({ shipmentListItems }: Props) =\u003e { \n   const fragmentData = useFragment(fragment, shipmentListItems)\n   \n  return (\n   \u003cStack\u003e\n     {fragmentData.map((milestone) =\u003e (\n       \u003cBox key={milestone.id}\u003e\n         \u003cText\u003e{milestone.milestoneType}\u003c/Text\u003e\n           \u003cText\u003e{milestone.status}\u003c/Text\u003e\n           \u003cText\u003e{milestone.completionDoneAt}\u003c/Text\u003e\n         \u003c/Box\u003e\n     )}\n   \u003c/Stack\u003e\n}\n```\n\n```js\nimport { FragmentType, graphql, useFragment } from \"@/__codegen__/\"\n\nconst fragment = graphql(`\n  fragment ShipmentListHeaderFragment on Shipment {\n      team {\n       name\n      }\n  }\n`)\n\ntype Props = {\n shipmentHeader: ShipmentListQueryItem;\n}\n\nexport const ShipmentListHeader = ({ shipmentHeader }: Props) =\u003e { \n   const fragmentData = useFragment(fragment, shipmentHeader)\n   \n  return (\n   \u003cStack\u003e\n     \u003cText\u003e{fragmentData.team.name}\u003c/Text\u003e\n   \u003c/Stack\u003e\n}\n```\n\n위 코드에서 다음과 같은 이점을 얻을 수 있습니다:\n\n- 명확한 데이터 종속성: 각 컴포넌트는 필요한 데이터를 명시적으로 정의하여 종속성이 명확해집니다. 자식 컴포넌트에서 GraphQL 서버에서 가져오는 값을 조사하는 것이 더 쉬워집니다.\n- 재사용성 향상: Fragment 사용은 코드 재사용을 촉진합니다. Fragment 유형도 생성되므로 타입 재사용이 가능합니다.\n- 유지보수성 향상: 쿼리에 대한 변경 사항이 지역화되어 유지보수가 쉬워집니다. 상위 컴포넌트의 쿼리를 수정할 필요가 없습니다.\n- 1 기능 컴포넌트에 1 루트 쿼리\n- 데이터 캡슐화: Fragment 마스킹을 사용하여 종속성이 없는 컴포넌트에서 의도하지 않은 필드 사용을 차단할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 보충: Fragment Masking\n\nFragment Masking을 사용하면 Fragment 데이터의 속성을 상위 수준 구성 요소에서 숨기고 데이터 가시성을 제어할 수 있습니다. 다시 말해, 캡슐화를 강제합니다.\n\n![이미지](/assets/img/2024-06-20-FragmentColocationwithApolloClient_1.png)\n\n참고: [https://the-guild.dev/blog/unleash-the-power-of-fragments-with-graphql-codegen](https://the-guild.dev/blog/unleash-the-power-of-fragments-with-graphql-codegen)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nFragment Colocation은 React와 GraphQL을 사용하는 현대 프론트엔드 개발에서 매우 유용한 패턴입니다. 데이터 종속성을 명확히하고 재사용성과 유지보수성을 향상시킴으로써, 개발자는 더 효율적으로 고품질의 코드를 작성할 수 있습니다. 여러분의 프로젝트에서 이 접근 방식을 채택해보고 직접 이점을 경험해보는 것도 좋을 것입니다.\n\n- - - - -\n만약 이 글이 여러분의 흥미를 자극했고, 이 지식을 활용하고 싶다면, 우리가 채용 중이니 확인해보세요!\n\n아래 링크를 확인해보세요.\n▼ 직업 기회\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**▼ 연락처**\nLinkedIn: [Shippio Inc.](https://www.linkedin.com/company/shippioinc/)\nShippio 인사팀 이메일 주소: shippiohr@shippio.io","ogImage":{"url":"/assets/img/2024-06-20-FragmentColocationwithApolloClient_0.png"},"coverImage":"/assets/img/2024-06-20-FragmentColocationwithApolloClient_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eFragment이란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003eFragment Colocation에 대해 논의하기 전에, 먼저 Fragment가 무엇인지 간단히 설명하겠습니다.\u003c/p\u003e\n\u003cp\u003eGraphQL에서 Fragment는 쿼리의 재사용 가능한 조각입니다. Fragment를 사용하면 코드 중복을 피하고 쿼리를 구성할 때 특히 여러 쿼리에서 같은 데이터 조각을 검색할 때 쿼리를 조직화할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efragment \u003cspan class=\"hljs-title class_\"\u003eUserDetails\u003c/span\u003e on \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  id\n  name\n  email\n}\n\nquery \u003cspan class=\"hljs-title class_\"\u003eGetUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003euser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eid: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\u003c/span\u003e) {\n    ...\u003cspan class=\"hljs-title class_\"\u003eUserDetails\u003c/span\u003e\n  }\n}\n\nquery \u003cspan class=\"hljs-title class_\"\u003eGetAllUsers\u003c/span\u003e {\n  users {\n    ...\u003cspan class=\"hljs-title class_\"\u003eUserDetails\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 UserDetails라는 fragment가 정의되었고 GetUser 및 GetAllUsers 쿼리 내에서 재사용됩니다. 이렇게 하면 동일한 데이터 부분을 여러 번 작성할 필요가 없어집니다. (이 코드는 ChatGPT에 의해 생성됨.)\u003c/p\u003e\n\u003ch1\u003eFragment Colocation이란\u003c/h1\u003e\n\u003cp\u003e일본에서는 Fragment Colocation(apollo Client에서 fragment 일치)라고도 합니다.\u003c/p\u003e\n\u003cp\u003eFragment Colocation은 GraphQL fragments가 해당 컴포넌트와 함께 배치되는 디자인 접근 방식입니다. 이 방식은 어떤 컴포넌트가 어떤 데이터를 필요로 하는지 명확히 알려주어 데이터 의존성을 관리하기 쉽게 만들어줍니다.\u003c/p\u003e\n\u003cp\u003e현대 프런트엔드 개발에서 데이터 가져오기와 표시는 밀접한 관련이 있습니다. 전통적인 방법은 종종 데이터 가져오기 로직을 여러 곳에 분산시켜 유지보수성과 재사용성이 감소하게 됩니다. Fragment Colocation은 이러한 문제를 중앙화하고 효율적으로 데이터 의존성을 조직화함으로써 해결합니다.\u003c/p\u003e\n\u003ch1\u003eShippio의 문제점 ⛴\u003c/h1\u003e\n\u003cp\u003eShippio에서는 Apollo Client를 GraphQL 클라이언트 라이브러리로 사용합니다.\u003c/p\u003e\n\u003cp\u003e그러나 몇 가지 문제가 발생했습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e자식 컴포넌트가 의존하지 않는 필드를 포함하여 불필요한 props가 전달됩니다.\u003c/li\u003e\n\u003cli\u003e필요한 필드를 추가하려면 부모 컴포넌트의 쿼리 필드를 수정해야 했는데, 이는 상당한 영향을 미쳤습니다.\u003c/li\u003e\n\u003cli\u003eprops를 통해 전달된 값이 서버에서 가져온 것인지 클라이언트에서 생성된 것인지 명확하지 않았습니다.\u003c/li\u003e\n\u003cli\u003e위 문제를 해결하기 위해 여러 자식 컴포넌트에서 useQuery를 사용하여 필요한 값만 가져오도록 했지만, 이는 GraphQL 같지 않았고 요청 수가 증가했습니다.\u003c/li\u003e\n\u003cli\u003e모든 쿼리를 단일 gql 디렉토리에 중앙 집중시키면 의존하는 컴포넌트를 식별하기 어려워졌습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e코드 샘플 (실제 코드가 아닙니다)\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 파일 트리\u003c/span\u003e\n\nsrc\n├── \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etsx\u003c/span\u003e\n├── components\n│   ├── \u003cspan class=\"hljs-title class_\"\u003eShipmentList\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etsx\u003c/span\u003e\n│   ├── \u003cspan class=\"hljs-title class_\"\u003eShipmentListHeader\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etsx\u003c/span\u003e (\u003cspan class=\"hljs-title class_\"\u003eShipmentList\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etsx\u003c/span\u003e의 자식 컴포넌트)\n│   ├── \u003cspan class=\"hljs-title class_\"\u003eShipmentListItem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etsx\u003c/span\u003e (\u003cspan class=\"hljs-title class_\"\u003eShipmentList\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etsx\u003c/span\u003e의 자식 컴포넌트)\n└── gql\n    ├── \u003cspan class=\"hljs-title class_\"\u003eShipmentListQuery\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ets\u003c/span\u003e (쿼리)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// gql 폴더의 ShipmentListQuery\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { graphql } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/__codegen__'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eShipmentListQuery\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003egraphql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\n  query ShipmentListQuery(\n    $shipmentId: ID\n    ...\n  ) {\n    shipmentSearch(\n      shipmentId: $shipmentId\n      ...\n    ) {\n      team {\n       name\n      }\n      milestones {\n        id\n        milestoneType\n        status\n        completionDoneAt\n      }\n    }\n  }\n`\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e type \u003cspan class=\"hljs-title class_\"\u003eShipmentListQueryItem\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eArrayType\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eQuery\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'shipmentSearch'\u003c/span\u003e]\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ShipmentList.tsx (루트 컴포넌트)\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eShipmentList\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \n   \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { data } = \u003cspan class=\"hljs-title function_\"\u003euseQuery\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eShipmentListQuery\u003c/span\u003e, \n    { \u003cspan class=\"hljs-attr\"\u003evariables\u003c/span\u003e: { ... } }\n  )\n  \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eStack\u003c/span\u003e\u003e\u003c/span\u003e\n     \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eShipmentListHeader\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eshipment\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{data.shipment}\u003c/span\u003e /\u003e\u003c/span\u003e\n     \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eShipmentListItem\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eshipment\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{data.shipment}\u003c/span\u003e /\u003e\u003c/span\u003e\n   \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eStack\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ShipmentListItem.tsx (ShipmentList.tsx의 하위 컴포넌트)\u003c/span\u003e\n\ntype \u003cspan class=\"hljs-title class_\"\u003eProps\u003c/span\u003e = {\n \u003cspan class=\"hljs-attr\"\u003eshipment\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eShipmentListQueryItem\u003c/span\u003e;\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eShipmentListItems\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ shipment }: Props\u003c/span\u003e) =\u003e { \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eStack\u003c/span\u003e\u003e\u003c/span\u003e\n     {shipment.milestones.map((milestone) =\u003e (\n       \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eBox\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{milestone.id}\u003c/span\u003e\u003e\u003c/span\u003e\n         \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e{milestone.milestoneType}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n           \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e{milestone.status}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n           \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e{milestone.completionDoneAt}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n         \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eBox\u003c/span\u003e\u003e\u003c/span\u003e\n     )}\n   \u0026#x3C;/Stack\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ShipmentListHeader.tsx (ShipmentList.tsx의 하위 컴포넌트)\u003c/span\u003e\n\ntype \u003cspan class=\"hljs-title class_\"\u003eProps\u003c/span\u003e = {\n \u003cspan class=\"hljs-attr\"\u003eshipment\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eShipmentListQueryItem\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eShipmentListHeader\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ shipment }: Props\u003c/span\u003e) =\u003e { \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eStack\u003c/span\u003e\u003e\u003c/span\u003e\n     \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e{shipment.team.name}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n   \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eStack\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e처음에는 이 접근 방식이 좋아 보입니다. 하지만 컴포넌트가 더 복잡해지고 구조가 더 중첩되면 위에서 언급한 문제가 발생할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e이슈 예시\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eShipmentListHeader에서 팀 ID를 표시하려면 부모인 ShipmentList 컴포넌트의 쿼리를 수정해야 합니다. (자식 컴포넌트의 변경 사항이 부모 컴포넌트에 영향을 미칩니다.)\u003c/li\u003e\n\u003cli\u003e전체 data.shipment 객체를 전달하는 것은 의도하지 않은 처리로 이어질 수 있습니다.\u003c/li\u003e\n\u003cli\u003eShipmentListItem은 마일스톤만 필요하지만 팀 정보도 받습니다.\u003c/li\u003e\n\u003cli\u003eShipmentListHeader는 팀 정보만 필요하지만 마일스톤도 받습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eApollo Client를 사용한 Fragment Colocation 연습\u003c/h1\u003e\n\u003cp\u003e위의 코드를 Fragment Colocation을 활용하여 개선해 봅시다.\u003c/p\u003e\n\u003cp\u003e이 글을 사용하기 위해 다음 패키지들이 필요합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@apollo/client\n@graphql-codegen/cli\n@graphql-codegen/client-preset\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecodegen.ts 파일의 설정은 아래와 같습니다. preset을 client로 설정하여 client-preset의 대부분 기능을 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// codegen.ts\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eCodegenConfig\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@graphql-codegen/cli'\u003c/span\u003e\n \n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econfig\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCodegenConfig\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eschema\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;schema 경로\u003e'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003edocuments\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'src/**/*.tsx'\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003eignoreNoDocuments\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003egenerates\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e'./src/__codegen__/'\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003epreset\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'client'\u003c/span\u003e\n    }\n  }\n}\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e config\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참고 링크: \u003ca href=\"https://the-guild.dev/graphql/codegen/docs/guides/react-vue\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://the-guild.dev/graphql/codegen/docs/guides/react-vue\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003eFragment Colocation을 사용한 코드 재작성\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { graphql } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/__codegen__'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eShipmentListQuery\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003egraphql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\n  query ShipmentListQuery(\n    $shipmentId: ID\n    ...\n  ) {\n    shipmentSearch(\n      shipmentId: $shipmentId\n      ...\n    ) {\n      ...ShipmentListHeaderFragment\n      ...ShipmentListItemFragment\n    }\n  }\n`\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eShipmentList\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \n   \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { data } = \u003cspan class=\"hljs-title function_\"\u003euseQuery\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eShipmentListQuery\u003c/span\u003e, \n    { \u003cspan class=\"hljs-attr\"\u003evariables\u003c/span\u003e: { ... } }\n  )\n  \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eStack\u003c/span\u003e\u003e\u003c/span\u003e\n     \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eShipmentListHeader\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eshipment\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{data.shipment}\u003c/span\u003e /\u003e\u003c/span\u003e\n     \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eShipmentListItem\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eshipment\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{data.shipment}\u003c/span\u003e /\u003e\u003c/span\u003e\n   \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eStack\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eFragmentType\u003c/span\u003e, graphql, useFragment } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@/__codegen__/\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fragment = \u003cspan class=\"hljs-title function_\"\u003egraphql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\n  fragment ShipmentListItemFragment on Milestone {\n      milestones {\n        id\n        milestoneType\n        status\n        completionDoneAt\n      }\n  }\n`\u003c/span\u003e)\n\ntype \u003cspan class=\"hljs-title class_\"\u003eProps\u003c/span\u003e = {\n \u003cspan class=\"hljs-attr\"\u003eshipmentListItems\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFragmentType\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e fragment\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eShipmentListItems\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ shipmentListItems }: Props\u003c/span\u003e) =\u003e { \n   \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fragmentData = \u003cspan class=\"hljs-title function_\"\u003euseFragment\u003c/span\u003e(fragment, shipmentListItems)\n   \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eStack\u003c/span\u003e\u003e\u003c/span\u003e\n     {fragmentData.map((milestone) =\u003e (\n       \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eBox\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{milestone.id}\u003c/span\u003e\u003e\u003c/span\u003e\n         \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e{milestone.milestoneType}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n           \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e{milestone.status}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n           \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e{milestone.completionDoneAt}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n         \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eBox\u003c/span\u003e\u003e\u003c/span\u003e\n     )}\n   \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eStack\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eFragmentType\u003c/span\u003e, graphql, useFragment } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@/__codegen__/\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fragment = \u003cspan class=\"hljs-title function_\"\u003egraphql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\n  fragment ShipmentListHeaderFragment on Shipment {\n      team {\n       name\n      }\n  }\n`\u003c/span\u003e)\n\ntype \u003cspan class=\"hljs-title class_\"\u003eProps\u003c/span\u003e = {\n \u003cspan class=\"hljs-attr\"\u003eshipmentHeader\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eShipmentListQueryItem\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eShipmentListHeader\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ shipmentHeader }: Props\u003c/span\u003e) =\u003e { \n   \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fragmentData = \u003cspan class=\"hljs-title function_\"\u003euseFragment\u003c/span\u003e(fragment, shipmentHeader)\n   \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eStack\u003c/span\u003e\u003e\u003c/span\u003e\n     \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e{fragmentData.team.name}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n   \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eStack\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 다음과 같은 이점을 얻을 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e명확한 데이터 종속성: 각 컴포넌트는 필요한 데이터를 명시적으로 정의하여 종속성이 명확해집니다. 자식 컴포넌트에서 GraphQL 서버에서 가져오는 값을 조사하는 것이 더 쉬워집니다.\u003c/li\u003e\n\u003cli\u003e재사용성 향상: Fragment 사용은 코드 재사용을 촉진합니다. Fragment 유형도 생성되므로 타입 재사용이 가능합니다.\u003c/li\u003e\n\u003cli\u003e유지보수성 향상: 쿼리에 대한 변경 사항이 지역화되어 유지보수가 쉬워집니다. 상위 컴포넌트의 쿼리를 수정할 필요가 없습니다.\u003c/li\u003e\n\u003cli\u003e1 기능 컴포넌트에 1 루트 쿼리\u003c/li\u003e\n\u003cli\u003e데이터 캡슐화: Fragment 마스킹을 사용하여 종속성이 없는 컴포넌트에서 의도하지 않은 필드 사용을 차단할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e보충: Fragment Masking\u003c/h1\u003e\n\u003cp\u003eFragment Masking을 사용하면 Fragment 데이터의 속성을 상위 수준 구성 요소에서 숨기고 데이터 가시성을 제어할 수 있습니다. 다시 말해, 캡슐화를 강제합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FragmentColocationwithApolloClient_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e참고: \u003ca href=\"https://the-guild.dev/blog/unleash-the-power-of-fragments-with-graphql-codegen\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://the-guild.dev/blog/unleash-the-power-of-fragments-with-graphql-codegen\u003c/a\u003e\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eFragment Colocation은 React와 GraphQL을 사용하는 현대 프론트엔드 개발에서 매우 유용한 패턴입니다. 데이터 종속성을 명확히하고 재사용성과 유지보수성을 향상시킴으로써, 개발자는 더 효율적으로 고품질의 코드를 작성할 수 있습니다. 여러분의 프로젝트에서 이 접근 방식을 채택해보고 직접 이점을 경험해보는 것도 좋을 것입니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e만약 이 글이 여러분의 흥미를 자극했고, 이 지식을 활용하고 싶다면, 우리가 채용 중이니 확인해보세요!\u003c/p\u003e\n\u003cp\u003e아래 링크를 확인해보세요.\n▼ 직업 기회\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e▼ 연락처\u003c/strong\u003e\nLinkedIn: \u003ca href=\"https://www.linkedin.com/company/shippioinc/\" rel=\"nofollow\" target=\"_blank\"\u003eShippio Inc.\u003c/a\u003e\nShippio 인사팀 이메일 주소: \u003ca href=\"mailto:shippiohr@shippio.io\"\u003eshippiohr@shippio.io\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-FragmentColocationwithApolloClient"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>