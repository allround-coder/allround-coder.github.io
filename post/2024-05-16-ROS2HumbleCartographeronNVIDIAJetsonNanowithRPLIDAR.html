<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ROS2에서 NVIDIA Jetson Nano에 RPLIDAR를 이용한 친절한 Cartographer 설정 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ROS2에서 NVIDIA Jetson Nano에 RPLIDAR를 이용한 친절한 Cartographer 설정 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="ROS2에서 NVIDIA Jetson Nano에 RPLIDAR를 이용한 친절한 Cartographer 설정 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR" data-gatsby-head="true"/><meta name="twitter:title" content="ROS2에서 NVIDIA Jetson Nano에 RPLIDAR를 이용한 친절한 Cartographer 설정 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-16 04:13" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_buildManifest.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">ROS2에서 NVIDIA Jetson Nano에 RPLIDAR를 이용한 친절한 Cartographer 설정</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="ROS2에서 NVIDIA Jetson Nano에 RPLIDAR를 이용한 친절한 Cartographer 설정" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 16, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_0.png" alt="image"/></p>
<p>소개:</p>
<p>ROS2 (로봇 운영 시스템 2)는 로봇 공학 분야를 혁신시킨 프레임워크로, 유연하고 강력한 기능을 제공합니다. 이 블로그 게시물에서는 인기 있는 싱글 보드 컴퓨터인 NVIDIA Jetson Nano에서 ROS2를 사용하여 카토그래퍼를 설정하는 방법과 RPLIDAR를 이용한 맵핑 작업에 대해 살펴볼 것입니다.</p>
<p>NVIDIA Jetson Nano에 ROS2 설정하기:</p>
<p>카토그래퍼 설정에 도입되기 전에, NVIDIA Jetson Nano에 ROS2가 적절히 설치되었는지 확인하고 작업 공간을 설정하고 모든 종속성이 충족되었는지 확인합시다.</p>
<pre><code class="hljs language-js">sudo apt install ros-humble-cartographer
</code></pre>
<p>RPLIDAR를 소개합니다:</p>
<p>RPLIDAR는 매핑 및 내비게이션을 위해로봇학에서 널리 사용되는 저가격 LIDAR 센서입니다. 가벼운 디자인과 저렴한 가격으로 취미로봇 및 소규모 로봇 프로젝트에 이상적인 선택지입니다. 우리는 RPLIDAR를 USB로 Jetson Nano에 연결하고 매핑 응용 프로그램에 통합하기 위해 ROS2와 통합할 것입니다.</p>
<p>RPLIDAR 설정을 시작해 보세요:</p>
<p>Github에서 rplidar 드라이버를 복제하세요.</p>
<p>https://github.com/Slamtec/sllidar_ros2.git</p>
<p>포트를 확인하고 활성화하세요.</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">ls</span> -l /dev |grep ttyUSB

sudo <span class="hljs-built_in">chmod</span> 666 /dev/ttyUSB0
</code></pre>
<p>Cartographer 구성:</p>
<p>카토그래퍼는 Google에서 개발한 강력한 오픈 소스 SLAM(Simultaneous Localization and Mapping) 라이브러리입니다. 우리는 ROS2 및 Jetson Nano에서 RPLIDAR 센서와 함께 카토그래퍼를 구성할 것입니다. 이는 센서 구성을 정의하고 매개변수를 조정하며 매핑 워크플로우를 설정하는 작업을 수행합니다.</p>
<p>매개변수 튜닝하기</p>
<pre><code class="hljs language-js">-- <span class="hljs-number">2016</span>년 카티그래퍼 저작권
--
-- <span class="hljs-title class_">Apache</span> 라이선스 <span class="hljs-number">2.0</span> 하에 라이선스가 부여됨
-- 라이선스를 준수하는 경우에만이 파일을 사용할 수 있습니다.
-- 라이선스 사본은 다음 위치에서 확인할 수 있습니다.
--
--      <span class="hljs-attr">http</span>:<span class="hljs-comment">//www.apache.org/licenses/LICENSE-2.0</span>
--
-- 관련 법률에 의해 필요한 경우나 합의된 경우를 제외하고
-- 라이선스에 따라 배포되는 소프트웨어는 <span class="hljs-string">&quot;있는 그대로&quot;</span>제공 됨
-- 보증이나 어떠한 종류의 조건도 없이.
-- 특정 언어에 대한 허가증을 위한 라이선스를 참조하고
-- 제한 사항은 라이선스 하에 지배하는 권한 및
-- 조건.

맵 빌더 설정:
- map_builder 를 <span class="hljs-variable constant_">MAP_BUILDER</span>로 설정
- trajectory_builder 를 <span class="hljs-variable constant_">TRAJECTORY_BUILDER</span>로 설정
- map_frame 은 <span class="hljs-string">&quot;map&quot;</span>
- tracking_frame 은 <span class="hljs-string">&quot;base_link&quot;</span>
- published_frame 은 <span class="hljs-string">&quot;base_link&quot;</span>
- odom_frame 은 <span class="hljs-string">&quot;odom&quot;</span>
- provide_odom_frame 을 <span class="hljs-literal">true</span>로 설정
- publish_frame_projected_to_2d 를 <span class="hljs-literal">true</span>로 설정
- use_odometry 를 <span class="hljs-literal">false</span>로 설정
- use_nav_sat 를 <span class="hljs-literal">false</span>로 설정
- use_landmarks 를 <span class="hljs-literal">false</span>로 설정

<span class="hljs-variable constant_">TRAJECTORY_BUILDER_2D</span> 파라미터:
- min_range 와 <span class="hljs-attr">max_range</span>: 센서 특성 및 환경에 따라 성능을 향상시킬 수 있음
- <span class="hljs-attr">missing_data_ray_length</span>: 누락된 데이터를 처리하기 위해 적절히 설정해야 함
- <span class="hljs-attr">use_imu_data</span>: 시스템이 신뢰할 수 있고 <span class="hljs-variable constant_">IMU</span> 데이터를 가지고 있다면, 이 값을 <span class="hljs-literal">true</span>로 설정하여 움직임 추정을 더 잘 할 수 있음

<span class="hljs-variable constant_">IMU</span> 인터페이스가 필요하다면 이 블로그를 참고하세요
</code></pre>
<p>https://medium.com/@kabilankb2003/ros2-humble-mpu6050-imu-sensor-interface-for-nvidia-jetson-nano-c4d616647ee5</p>
<ul>
<li>use_online_correlative_scan_matching: 실시간 성능 요구 사항에 따라 토글할 수 있습니다.</li>
</ul>
<p>실시간 Correlative Scan Matcher 매개변수:</p>
<ul>
<li>linear_search_window: 이 매개변수는 검색 창의 크기를 정의합니다. 조심히 조정하면 정확도를 희생하지 않고 일치 속도를 향상시킬 수 있습니다.</li>
<li>translation_delta_cost_weight 및 rotation_delta_cost_weight: 이러한 가중치는 스캔 매칭 중 번역 및 회전을 균형있게 조정합니다. 세심하게 조정하면 성능을 향상시킬 수 있습니다.</li>
</ul>
<p>움직임 필터 매개변수:</p>
<ul>
<li>max_angle_radians: 연속 스캔 간의 예상 최대 방향 변경에 따라 설정합니다.</li>
</ul>
<p>포즈 그래프 최적화 매개변수:</p>
<ul>
<li>min_score 매개변수 in constraint_builder: 이를 조정하여 잘못된 제약 조건을 걸러내는 데 도움이 될 수 있습니다.</li>
<li>huber_scale: 이는 최적화의 견고성에 영향을 미칩니다. 더 큰 값은 이상 값 제약 조건을 거부하는 데 도움이 될 수 있습니다.</li>
<li>optimize_every_n_nodes: 포즈 그래프 최적화의 빈도를 균형있게 조절합니다. 계산 리소스와 매핑 요구 사항에 따라 조정하세요.</li>
</ul>
<p>RPLIDAR을 실행하세요.</p>
<p><img src="/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_1.png" alt="image"/></p>
<p>파라미터 및 런치 파일 구성 후 카토그래퍼 노드를 실행하세요.</p>
<p>카토그래퍼가 구성되면, Jetson Nano에서 매핑 노드를 실행할 거에요. 이 노드는 RPLIDAR 센서로부터 데이터를 구독하고, 실시간 SLAM 알고리즘을 수행하여 환경의 2D 지도를 생성할 거에요. 우리는 Cartographer가 제공하는 다양한 매핑 전략과 옵션을 탐색하여 매핑 성능을 최적화할 거에요.</p>
<p><img src="/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_2.png" alt="image"/></p>
<p>Then launch rviz</p>
<p><img src="/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_3.png" alt="image"/></p>
<p>Enable the map in topic</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*M10X6RQLyhSEk521t2-X9g.gif" alt="TF Tranform"/></p>
<p>Cartographer Mapping</p>
<p>이미지:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*1Dumd45ScQu5y1a55SV4Vg.gif" alt="이미지"/></p>
<p>결론:</p>
<p>이 블로그 포스트에서는 NVIDIA Jetson Nano에서 ROS2를 사용하여 RPLIDAR 센서를 사용한 겸손한 지도 작성기를 설정하는 방법을 보여주었습니다. ROS2 및 Cartographer와 같은 오픈 소스 도구를 활용하여 취미로 로봇공학 및 로보틱스 열렬가들이 저렴한 하드웨어 플랫폼에서 복잡한 매핑 시스템을 구축할 수 있습니다. 로봇공학을 취미로 삼고 있거나 실제 응용 프로그램을 위한 솔루션을 개발하고 있다면, ROS2와 Jetson Nano는 매핑 및 내비게이션 작업에 대해 매력적인 조합을 제공합니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"ROS2에서 NVIDIA Jetson Nano에 RPLIDAR를 이용한 친절한 Cartographer 설정","description":"","date":"2024-05-16 04:13","slug":"2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR","content":"\n\n![image](/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_0.png)\n\n소개:\n\nROS2 (로봇 운영 시스템 2)는 로봇 공학 분야를 혁신시킨 프레임워크로, 유연하고 강력한 기능을 제공합니다. 이 블로그 게시물에서는 인기 있는 싱글 보드 컴퓨터인 NVIDIA Jetson Nano에서 ROS2를 사용하여 카토그래퍼를 설정하는 방법과 RPLIDAR를 이용한 맵핑 작업에 대해 살펴볼 것입니다.\n\nNVIDIA Jetson Nano에 ROS2 설정하기:\n\n\n\n카토그래퍼 설정에 도입되기 전에, NVIDIA Jetson Nano에 ROS2가 적절히 설치되었는지 확인하고 작업 공간을 설정하고 모든 종속성이 충족되었는지 확인합시다.\n\n```js\nsudo apt install ros-humble-cartographer\n```\n\nRPLIDAR를 소개합니다:\n\nRPLIDAR는 매핑 및 내비게이션을 위해로봇학에서 널리 사용되는 저가격 LIDAR 센서입니다. 가벼운 디자인과 저렴한 가격으로 취미로봇 및 소규모 로봇 프로젝트에 이상적인 선택지입니다. 우리는 RPLIDAR를 USB로 Jetson Nano에 연결하고 매핑 응용 프로그램에 통합하기 위해 ROS2와 통합할 것입니다.\n\n\n\nRPLIDAR 설정을 시작해 보세요:\n\nGithub에서 rplidar 드라이버를 복제하세요.\n\n\nhttps://github.com/Slamtec/sllidar_ros2.git\n\n\n포트를 확인하고 활성화하세요.\n\n\n\n```bash\nls -l /dev |grep ttyUSB\n\nsudo chmod 666 /dev/ttyUSB0\n```\n\nCartographer 구성:\n\n카토그래퍼는 Google에서 개발한 강력한 오픈 소스 SLAM(Simultaneous Localization and Mapping) 라이브러리입니다. 우리는 ROS2 및 Jetson Nano에서 RPLIDAR 센서와 함께 카토그래퍼를 구성할 것입니다. 이는 센서 구성을 정의하고 매개변수를 조정하며 매핑 워크플로우를 설정하는 작업을 수행합니다.\n\n매개변수 튜닝하기\n\n\n\n\n```js\n-- 2016년 카티그래퍼 저작권\n--\n-- Apache 라이선스 2.0 하에 라이선스가 부여됨\n-- 라이선스를 준수하는 경우에만이 파일을 사용할 수 있습니다.\n-- 라이선스 사본은 다음 위치에서 확인할 수 있습니다.\n--\n--      http://www.apache.org/licenses/LICENSE-2.0\n--\n-- 관련 법률에 의해 필요한 경우나 합의된 경우를 제외하고\n-- 라이선스에 따라 배포되는 소프트웨어는 \"있는 그대로\"제공 됨\n-- 보증이나 어떠한 종류의 조건도 없이.\n-- 특정 언어에 대한 허가증을 위한 라이선스를 참조하고\n-- 제한 사항은 라이선스 하에 지배하는 권한 및\n-- 조건.\n\n맵 빌더 설정:\n- map_builder 를 MAP_BUILDER로 설정\n- trajectory_builder 를 TRAJECTORY_BUILDER로 설정\n- map_frame 은 \"map\"\n- tracking_frame 은 \"base_link\"\n- published_frame 은 \"base_link\"\n- odom_frame 은 \"odom\"\n- provide_odom_frame 을 true로 설정\n- publish_frame_projected_to_2d 를 true로 설정\n- use_odometry 를 false로 설정\n- use_nav_sat 를 false로 설정\n- use_landmarks 를 false로 설정\n\nTRAJECTORY_BUILDER_2D 파라미터:\n- min_range 와 max_range: 센서 특성 및 환경에 따라 성능을 향상시킬 수 있음\n- missing_data_ray_length: 누락된 데이터를 처리하기 위해 적절히 설정해야 함\n- use_imu_data: 시스템이 신뢰할 수 있고 IMU 데이터를 가지고 있다면, 이 값을 true로 설정하여 움직임 추정을 더 잘 할 수 있음\n\nIMU 인터페이스가 필요하다면 이 블로그를 참고하세요\n```\n\n\n\nhttps://medium.com/@kabilankb2003/ros2-humble-mpu6050-imu-sensor-interface-for-nvidia-jetson-nano-c4d616647ee5\n\n- use_online_correlative_scan_matching: 실시간 성능 요구 사항에 따라 토글할 수 있습니다.\n\n실시간 Correlative Scan Matcher 매개변수:\n\n- linear_search_window: 이 매개변수는 검색 창의 크기를 정의합니다. 조심히 조정하면 정확도를 희생하지 않고 일치 속도를 향상시킬 수 있습니다.\n- translation_delta_cost_weight 및 rotation_delta_cost_weight: 이러한 가중치는 스캔 매칭 중 번역 및 회전을 균형있게 조정합니다. 세심하게 조정하면 성능을 향상시킬 수 있습니다.\n\n\n\n움직임 필터 매개변수:\n\n- max_angle_radians: 연속 스캔 간의 예상 최대 방향 변경에 따라 설정합니다.\n\n포즈 그래프 최적화 매개변수:\n\n- min_score 매개변수 in constraint_builder: 이를 조정하여 잘못된 제약 조건을 걸러내는 데 도움이 될 수 있습니다.\n- huber_scale: 이는 최적화의 견고성에 영향을 미칩니다. 더 큰 값은 이상 값 제약 조건을 거부하는 데 도움이 될 수 있습니다.\n- optimize_every_n_nodes: 포즈 그래프 최적화의 빈도를 균형있게 조절합니다. 계산 리소스와 매핑 요구 사항에 따라 조정하세요.\n\n\n\nRPLIDAR을 실행하세요.\n\n![image](/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_1.png)\n\n파라미터 및 런치 파일 구성 후 카토그래퍼 노드를 실행하세요.\n\n카토그래퍼가 구성되면, Jetson Nano에서 매핑 노드를 실행할 거에요. 이 노드는 RPLIDAR 센서로부터 데이터를 구독하고, 실시간 SLAM 알고리즘을 수행하여 환경의 2D 지도를 생성할 거에요. 우리는 Cartographer가 제공하는 다양한 매핑 전략과 옵션을 탐색하여 매핑 성능을 최적화할 거에요.\n\n\n\n\n![image](/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_2.png)\n\nThen launch rviz\n\n![image](/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_3.png)\n\nEnable the map in topic\n\n\n\n\n\n![TF Tranform](https://miro.medium.com/v2/resize:fit:1400/1*M10X6RQLyhSEk521t2-X9g.gif)\n\nCartographer Mapping\n\n\n\n\n이미지:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*1Dumd45ScQu5y1a55SV4Vg.gif)\n\n결론:\n\n이 블로그 포스트에서는 NVIDIA Jetson Nano에서 ROS2를 사용하여 RPLIDAR 센서를 사용한 겸손한 지도 작성기를 설정하는 방법을 보여주었습니다. ROS2 및 Cartographer와 같은 오픈 소스 도구를 활용하여 취미로 로봇공학 및 로보틱스 열렬가들이 저렴한 하드웨어 플랫폼에서 복잡한 매핑 시스템을 구축할 수 있습니다. 로봇공학을 취미로 삼고 있거나 실제 응용 프로그램을 위한 솔루션을 개발하고 있다면, ROS2와 Jetson Nano는 매핑 및 내비게이션 작업에 대해 매력적인 조합을 제공합니다.","ogImage":{"url":"/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_0.png"},"coverImage":"/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_0.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"소개:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ROS2 (로봇 운영 시스템 2)는 로봇 공학 분야를 혁신시킨 프레임워크로, 유연하고 강력한 기능을 제공합니다. 이 블로그 게시물에서는 인기 있는 싱글 보드 컴퓨터인 NVIDIA Jetson Nano에서 ROS2를 사용하여 카토그래퍼를 설정하는 방법과 RPLIDAR를 이용한 맵핑 작업에 대해 살펴볼 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"NVIDIA Jetson Nano에 ROS2 설정하기:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"카토그래퍼 설정에 도입되기 전에, NVIDIA Jetson Nano에 ROS2가 적절히 설치되었는지 확인하고 작업 공간을 설정하고 모든 종속성이 충족되었는지 확인합시다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"sudo apt install ros-humble-cartographer\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RPLIDAR를 소개합니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RPLIDAR는 매핑 및 내비게이션을 위해로봇학에서 널리 사용되는 저가격 LIDAR 센서입니다. 가벼운 디자인과 저렴한 가격으로 취미로봇 및 소규모 로봇 프로젝트에 이상적인 선택지입니다. 우리는 RPLIDAR를 USB로 Jetson Nano에 연결하고 매핑 응용 프로그램에 통합하기 위해 ROS2와 통합할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RPLIDAR 설정을 시작해 보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Github에서 rplidar 드라이버를 복제하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"https://github.com/Slamtec/sllidar_ros2.git\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"포트를 확인하고 활성화하세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-bash\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"ls\"\n        }), \" -l /dev |grep ttyUSB\\n\\nsudo \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"chmod\"\n        }), \" 666 /dev/ttyUSB0\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cartographer 구성:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"카토그래퍼는 Google에서 개발한 강력한 오픈 소스 SLAM(Simultaneous Localization and Mapping) 라이브러리입니다. 우리는 ROS2 및 Jetson Nano에서 RPLIDAR 센서와 함께 카토그래퍼를 구성할 것입니다. 이는 센서 구성을 정의하고 매개변수를 조정하며 매핑 워크플로우를 설정하는 작업을 수행합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"매개변수 튜닝하기\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"-- \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2016\"\n        }), \"년 카티그래퍼 저작권\\n--\\n-- \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Apache\"\n        }), \" 라이선스 \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2.0\"\n        }), \" 하에 라이선스가 부여됨\\n-- 라이선스를 준수하는 경우에만이 파일을 사용할 수 있습니다.\\n-- 라이선스 사본은 다음 위치에서 확인할 수 있습니다.\\n--\\n--      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"http\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//www.apache.org/licenses/LICENSE-2.0\"\n        }), \"\\n--\\n-- 관련 법률에 의해 필요한 경우나 합의된 경우를 제외하고\\n-- 라이선스에 따라 배포되는 소프트웨어는 \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"있는 그대로\\\"\"\n        }), \"제공 됨\\n-- 보증이나 어떠한 종류의 조건도 없이.\\n-- 특정 언어에 대한 허가증을 위한 라이선스를 참조하고\\n-- 제한 사항은 라이선스 하에 지배하는 권한 및\\n-- 조건.\\n\\n맵 빌더 설정:\\n- map_builder 를 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"MAP_BUILDER\"\n        }), \"로 설정\\n- trajectory_builder 를 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"TRAJECTORY_BUILDER\"\n        }), \"로 설정\\n- map_frame 은 \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"map\\\"\"\n        }), \"\\n- tracking_frame 은 \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"base_link\\\"\"\n        }), \"\\n- published_frame 은 \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"base_link\\\"\"\n        }), \"\\n- odom_frame 은 \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"odom\\\"\"\n        }), \"\\n- provide_odom_frame 을 \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"로 설정\\n- publish_frame_projected_to_2d 를 \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"로 설정\\n- use_odometry 를 \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"로 설정\\n- use_nav_sat 를 \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"로 설정\\n- use_landmarks 를 \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"로 설정\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"TRAJECTORY_BUILDER_2D\"\n        }), \" 파라미터:\\n- min_range 와 \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"max_range\"\n        }), \": 센서 특성 및 환경에 따라 성능을 향상시킬 수 있음\\n- \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"missing_data_ray_length\"\n        }), \": 누락된 데이터를 처리하기 위해 적절히 설정해야 함\\n- \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"use_imu_data\"\n        }), \": 시스템이 신뢰할 수 있고 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"IMU\"\n        }), \" 데이터를 가지고 있다면, 이 값을 \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"로 설정하여 움직임 추정을 더 잘 할 수 있음\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"IMU\"\n        }), \" 인터페이스가 필요하다면 이 블로그를 참고하세요\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"https://medium.com/@kabilankb2003/ros2-humble-mpu6050-imu-sensor-interface-for-nvidia-jetson-nano-c4d616647ee5\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"use_online_correlative_scan_matching: 실시간 성능 요구 사항에 따라 토글할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실시간 Correlative Scan Matcher 매개변수:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"linear_search_window: 이 매개변수는 검색 창의 크기를 정의합니다. 조심히 조정하면 정확도를 희생하지 않고 일치 속도를 향상시킬 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"translation_delta_cost_weight 및 rotation_delta_cost_weight: 이러한 가중치는 스캔 매칭 중 번역 및 회전을 균형있게 조정합니다. 세심하게 조정하면 성능을 향상시킬 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"움직임 필터 매개변수:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"max_angle_radians: 연속 스캔 간의 예상 최대 방향 변경에 따라 설정합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"포즈 그래프 최적화 매개변수:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"min_score 매개변수 in constraint_builder: 이를 조정하여 잘못된 제약 조건을 걸러내는 데 도움이 될 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"huber_scale: 이는 최적화의 견고성에 영향을 미칩니다. 더 큰 값은 이상 값 제약 조건을 거부하는 데 도움이 될 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"optimize_every_n_nodes: 포즈 그래프 최적화의 빈도를 균형있게 조절합니다. 계산 리소스와 매핑 요구 사항에 따라 조정하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RPLIDAR을 실행하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_1.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"파라미터 및 런치 파일 구성 후 카토그래퍼 노드를 실행하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"카토그래퍼가 구성되면, Jetson Nano에서 매핑 노드를 실행할 거에요. 이 노드는 RPLIDAR 센서로부터 데이터를 구독하고, 실시간 SLAM 알고리즘을 수행하여 환경의 2D 지도를 생성할 거에요. 우리는 Cartographer가 제공하는 다양한 매핑 전략과 옵션을 탐색하여 매핑 성능을 최적화할 거에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_2.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Then launch rviz\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR_3.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Enable the map in topic\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*M10X6RQLyhSEk521t2-X9g.gif\",\n        alt: \"TF Tranform\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cartographer Mapping\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이미지:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*1Dumd45ScQu5y1a55SV4Vg.gif\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결론:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 블로그 포스트에서는 NVIDIA Jetson Nano에서 ROS2를 사용하여 RPLIDAR 센서를 사용한 겸손한 지도 작성기를 설정하는 방법을 보여주었습니다. ROS2 및 Cartographer와 같은 오픈 소스 도구를 활용하여 취미로 로봇공학 및 로보틱스 열렬가들이 저렴한 하드웨어 플랫폼에서 복잡한 매핑 시스템을 구축할 수 있습니다. 로봇공학을 취미로 삼고 있거나 실제 응용 프로그램을 위한 솔루션을 개발하고 있다면, ROS2와 Jetson Nano는 매핑 및 내비게이션 작업에 대해 매력적인 조합을 제공합니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-16-ROS2HumbleCartographeronNVIDIAJetsonNanowithRPLIDAR"},"buildId":"837W-BjvPVBgft6aM4api","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>