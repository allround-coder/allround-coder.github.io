<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>고급 자료 구조와 알고리즘 초기 이진 인덱스 트리 구현 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="고급 자료 구조와 알고리즘 초기 이진 인덱스 트리 구현 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="고급 자료 구조와 알고리즘 초기 이진 인덱스 트리 구현 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree" data-gatsby-head="true"/><meta name="twitter:title" content="고급 자료 구조와 알고리즘 초기 이진 인덱스 트리 구현 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 02:03" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">고급 자료 구조와 알고리즘 초기 이진 인덱스 트리 구현 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="고급 자료 구조와 알고리즘 초기 이진 인덱스 트리 구현 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>최적화에 실패한 보통의 데이터 구조</h2>
<p><img src="/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png" alt="이미지"></p>
<p>가끔 데이터 구조는 직접적이고 매우 실용적인 사용 사례를 가지고 있어 누군가 그것을 고안할 만한 이유를 이해할 수 있습니다.</p>
<p>그런데 항상 그렇지만은 않습니다. 때로는 데이터 구조가 그저 어떤 이점이나 성능 향상을 제공하기 위해 존재하는 경우도 있습니다. 항상 사용하실 건가요? 아마도 그렇지 않을 것입니다. 하지만 실제로 유용하게 사용할 때 알아 두어서 기뻐할 것입니다.</p>
<div class="content-ad"></div>
<p>오늘은 BIT 또는 다른 말로 이진 인덱스 트리에 대해 이야기하고 싶어요. 이 데이터 구조는 검색 및 삽입을 최적화하려고 노력하지만 그것을 실패하는 특징을 가지고 있어요.</p>
<h1>BITs 뒤에 숨겨진 의도</h1>
<p>BITs를 "보통인 데이터 구조"라고 부르고 싶어요. 다른 데이터 구조들이 트리에서 삽입 또는 읽기 연산 중 하나를 최적화하려고 하는데 그 결과를 O(1)로 만들고 다른 하나는 O(n)으로 놓는 것에 집중하는 반면, BITs는 두 가지 모두를 개선하려고 해요.</p>
<p>그런데 트리에 삽입하고 읽기를 상수 시간 안에 수행하는 것은 불가능하기 때문에, 이 구조체가 시도하는 것에 실패한다고 말하는 건 정말 그렇게 생각해요.</p>
<div class="content-ad"></div>
<p>말이 그렇게 되면, 실제로 BITs는 O(Log n) 성능으로 데이터를 삽입하고 읽을 수 있게 해줍니다. 대단하지도 않고 최악도 아니라서, 그러니까 그냥 보통 정도입니다.</p>
<p>농담은 그만두고, BITs를 사용하면 트리를 쿼리하고 업데이트하는 데 합리적인 성능을 제공합니다. 따라서 트리 모양의 구조물을 다루고 논리가 그것에 많은 읽기 및 쓰기를 수행하는 경우, 이것이 당신에게 적합한 데이터 구조일 수 있습니다.</p>
<p>이 데이터 구조의 주요 사용 사례는 배열 내 요소들의 효율적인 접두사 합계(즉, n번째까지의 모든 요소의 합)를 가질 수 있는 능력입니다. 이것은 산술 코딩을 사용할 때 편리하다고 합니다. 그러나 우리는 지금 그 무한한 토끼굴에 들어가지 않겠습니다.</p>
<h1>JavaScript에서 이진 색인 트리 구현</h1>
<div class="content-ad"></div>
<p>이 코드를 구현할 때, 예상과는 다르게 할 것입니다. 클래스로 트리 구조를 구현하는 대신, 이 구조를 배열로 나타내고 트래버스하는 방법으로 이해할 수 있도록 특수한 비트 연산을 사용할 것입니다.</p>
<p>두 가지 작업에 초점을 맞출 것입니다: 업데이트와 특정 위치까지의 합을 얻는 것입니다.</p>
<p>업데이트 작업은 주어진 값을 원하는 위치에 추가하고, 또한 구조를 트래버스하여 모든 하위 항목을 업데이트 할 것입니다.</p>
<p>"getSum" 작업은 원하는 노드까지의 서브트리의 합을 반환할 것입니다.</p>
<div class="content-ad"></div>
<h2>BIT 생성하기</h2>
<p>처음 다룰 주제는 어떻게 만드는 지입니다. 앞서 말했듯이 배열로 표현하고, 현재 인덱스의 마지막 설정 비트를 계산하여 이동하며, 트리를 탐색할 때 이를 추가하거나 제거합니다.</p>
<p>먼저, BIT를 초기 생성할 때는 아래로 이동하므로, 마지막 설정된 비트를 추가합니다.</p>
<p>초기에 BIT 배열은 모두 0으로 설정되어 있고, 우리는 원본 값의 배열을 지나가며 이 논리를 따릅니다:</p>
<div class="content-ad"></div>
<ul>
<li>첫 번째 인덱스(이 경우에는 0)부터 시작합니다.</li>
<li>인덱스에 1을 추가합니다(BIT 배열은 초기 요소가 비어 있는 상태입니다).</li>
<li>현재 인덱스의 배열 값과 BIT 배열 내의 새 위치에 값을 추가합니다.</li>
<li>인덱스의 마지막으로 설정된 비트(즉, 1)을 가져와 인덱스에 추가하여 2로 바꿉니다.</li>
<li>단계 1로 돌아갑니다.</li>
</ul>
<p>시작할 배열이 다음과 같다고 가정해 봅시다: [2, 1, 1, 3, 2, 3], 그리고 BIT에 접두사 합을 저장하려고 할 때:</p>
<ul>
<li>인덱스 0에서 2의 값을 얻습니다.</li>
<li>BIT 배열에 가서 1을 추가하여 BIT 인덱스를 1로 만듭니다.</li>
<li>BIT 배열의 위치 1에 있는 값에 2를 추가하여 2로 만듭니다.</li>
<li>1의 마지막 설정된 비트인 1을 가져와 BIT 인덱스에 추가하여 2로 만듭니다.</li>
<li>BIT 배열의 인덱스 2에서는 다시 2를 추가하여 2가 됩니다.</li>
<li>2의 마지막 설정된 비트(10)는 2이므로 BIT 인덱스 4로 이동합니다.</li>
<li>BIT 인덱스 4에 2를 추가하여 마찬가지로 2가 됩니다.</li>
<li>4의 마지막 설정된 비트(100)도 4이므로 존재하지 않는 8로 이동하게 되고 여기서 종료됩니다.</li>
</ul>
<p>이 시점에서 BIT 배열은 다음과 같이 보입니다: [0, 2, 2, 0, 2, 0, 0]</p>
<div class="content-ad"></div>
<p>그리고 우리는 원래 배열의 첫 번째 2개만 추가했습니다. 이제 우리 배열의 두 번째 요소에도 같은 작업을 수행합니다(위치 1):</p>
<ul>
<li>원래 인덱스 1은 BIT 인덱스 2를 의미합니다(시작 시 인덱스에 1을 추가하는 것을 기억하세요).</li>
<li>우리는 BITArray[2]의 값에 1을 추가하여 3으로 만듭니다.</li>
<li>2가 4로 변하기 때문에 BIT 배열의 4번째 위치에 1을 추가하여 또한 3으로 만듭니다.</li>
<li>그리고 이제 4가 8로 변하면서 다시 범위를 벗어나게 되므로 여기서 멈춥니다.</li>
</ul>
<p>이 시점에서 BIT 배열은 다음과 같이 보입니다: [0, 2, 3, 0, 3, 0, 0]</p>
<p>그리고 계속 진행하면 다음과 같은 결과를 얻게 됩니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-title class_">Idx</span> — <span class="hljs-variable constant_">BIT</span> 배열
<span class="hljs-number">0</span> — [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>] - 초기 상태
<span class="hljs-number">1</span> — [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>] - 첫 번째 반복
<span class="hljs-number">2</span> — [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>] - 두 번째 반복 (위에서 설명한대로)
<span class="hljs-number">3</span> — [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
<span class="hljs-number">4</span> — [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
<span class="hljs-number">5</span> — [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]
<span class="hljs-number">6</span> — [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]
</code></pre>
<p>모든 값을 BIT 배열에 추가한 후에는 [0, 2, 3, 1, 7, 2, 5]가 됩니다.</p>
<p>이해를 돕기 위해 다음과 같이 구현을 살펴보겠습니다:</p>
<p>constructBITree 함수는 배열을 초기화하고 각 값에 대해 업데이트하는 역할을 합니다.</p>
<div class="content-ad"></div>
<p>이제 배열이 설정되면, 원하는 색인까지의 접두사 합을 요청할 수 있는 쿼리를 시작할 수 있습니다.</p>
<h2>트리 쿼리</h2>
<p>트리를 쿼리하는 것은 이전과 유사한 접근 방식을 따릅니다만, 역으로 진행됩니다.</p>
<p>인덱스 0 대신 우리가 찾고 있는 인덱스에서 (물론 1을 더한 값으로) 시작하고, 해당 인덱스의 마지막 비트를 제거하여 0 또는 그 이하로 이동하면서 트리를 "위로" 이동합니다.</p>
<div class="content-ad"></div>
<p>우리의 BIT 배열 [0, 2, 3, 1, 7, 2, 5]에서 트리에 쿼리하여 5번째 요소의 접두사 합을 얻고 싶다고 합시다. 물론, 이는 원래 배열의 모든 값을 더하는 것과 동일하다는 것을 의미합니다 (6개의 값이 있음).</p>
<ul>
<li>이제, 인덱스 5에서 시작하지만 1을 추가하여 6이 되었습니다.</li>
<li>BIT 배열의 6번째 인덱스의 값은 5입니다.</li>
<li>이제, 인덱스의 마지막 설정된 비트 (6이며 2진법으로 110입니다)를 빼서 4로 만듭니다.</li>
<li>우리의 BIT 배열에서 4번째 인덱스의 값은 7이므로 5에 추가하여 약 12가 됩니다.</li>
<li>4의 마지막 설정된 비트는 4이므로, 빼서 0이 됩니다.</li>
<li>끝났습니다.</li>
</ul>
<p>원래 배열을 모두 순회하여 모든 숫자를 더하는 대신, 우리는 BIT 배열에서 2개의 값을 필요로 했습니다. 이 변경으로 O(n)을 O(Log2(n)) 알고리즘으로 변환했습니다. 꽤 멋지죠?!</p>
<div class="content-ad"></div>
<p>자, 이제 구현을 살펴봅시다:</p>
<p>이것은 간단한 구현입니다. 핵심은 8번 라인이며, 여기서 현재 인덱스에서 마지막으로 설정된 비트를 뺍니다. 여기서 모든 마법이 벌어집니다.</p>
<p>읽어주셨나요? IT 산업에서 2 십년의 지혜를 무료로 공유하는 제 뉴스레터를 구독해보세요. "늙은 개발자의 헛소리"에 가입하세요!</p>
<p>이진 색인 트리는 그 뒤의 논리를 이해하면 매우 멋집니다. 첫 시도에서 이해하기 어려워 해도 걱정하지 마세요. "이해하는 데 오랜 시간이 걸렸어요". 중간값을 저장된 배열에서 확인하고 위에 보여준 단계를 따라 가는 것이 내 추천입니다.</p>
<div class="content-ad"></div>
<p>BITs를 사용해 보신 적이 있나요? 그것으로 무엇을 하셨나요? 이 데이터 구조의 실제 구현에 대해 알고 싶어요! 그러니까 의견란에 공유해 주세요!</p>
<h1>레고처럼 재사용 가능한 구성 요소로 앱 구축하기</h1>
<p><img src="/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_1.png" alt="이미지"></p>
<p>Bit의 오픈소스 도구는 25만 명 이상의 개발자가 구성 요소로 앱을 만드는 데 도와주고 있어요.</p>
<div class="content-ad"></div>
<p>어떤 UI, 기능 또는 페이지를 재사용 가능한 구성 요소로 변환하여 여러 애플리케이션 간에 공유하세요. 협업하기가 더 쉽고 빠르게 빌드할 수 있어요.</p>
<p>→ 자세히 알아보기</p>
<p>앱을 구성 요소로 분할하여 앱 개발을 더 쉽게 만들고 원하는 작업 흐름에 대한 최상의 경험을 누리세요:</p>
<h2>→ 마이크로 프론트엔드</h2>
<div class="content-ad"></div>
<h2>→ 디자인 시스템</h2>
<h2>→ 코드 공유 및 재사용</h2>
<h2>→ 모노 저장소</h2>
<h1>더 알아보기</h1>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"고급 자료 구조와 알고리즘 초기 이진 인덱스 트리 구현 방법","description":"","date":"2024-06-22 02:03","slug":"2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree","content":"\n\n## 최적화에 실패한 보통의 데이터 구조\n\n![이미지](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png)\n\n가끔 데이터 구조는 직접적이고 매우 실용적인 사용 사례를 가지고 있어 누군가 그것을 고안할 만한 이유를 이해할 수 있습니다.\n\n그런데 항상 그렇지만은 않습니다. 때로는 데이터 구조가 그저 어떤 이점이나 성능 향상을 제공하기 위해 존재하는 경우도 있습니다. 항상 사용하실 건가요? 아마도 그렇지 않을 것입니다. 하지만 실제로 유용하게 사용할 때 알아 두어서 기뻐할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오늘은 BIT 또는 다른 말로 이진 인덱스 트리에 대해 이야기하고 싶어요. 이 데이터 구조는 검색 및 삽입을 최적화하려고 노력하지만 그것을 실패하는 특징을 가지고 있어요.\n\n# BITs 뒤에 숨겨진 의도\n\nBITs를 \"보통인 데이터 구조\"라고 부르고 싶어요. 다른 데이터 구조들이 트리에서 삽입 또는 읽기 연산 중 하나를 최적화하려고 하는데 그 결과를 O(1)로 만들고 다른 하나는 O(n)으로 놓는 것에 집중하는 반면, BITs는 두 가지 모두를 개선하려고 해요.\n\n그런데 트리에 삽입하고 읽기를 상수 시간 안에 수행하는 것은 불가능하기 때문에, 이 구조체가 시도하는 것에 실패한다고 말하는 건 정말 그렇게 생각해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n말이 그렇게 되면, 실제로 BITs는 O(Log n) 성능으로 데이터를 삽입하고 읽을 수 있게 해줍니다. 대단하지도 않고 최악도 아니라서, 그러니까 그냥 보통 정도입니다.\n\n농담은 그만두고, BITs를 사용하면 트리를 쿼리하고 업데이트하는 데 합리적인 성능을 제공합니다. 따라서 트리 모양의 구조물을 다루고 논리가 그것에 많은 읽기 및 쓰기를 수행하는 경우, 이것이 당신에게 적합한 데이터 구조일 수 있습니다.\n\n이 데이터 구조의 주요 사용 사례는 배열 내 요소들의 효율적인 접두사 합계(즉, n번째까지의 모든 요소의 합)를 가질 수 있는 능력입니다. 이것은 산술 코딩을 사용할 때 편리하다고 합니다. 그러나 우리는 지금 그 무한한 토끼굴에 들어가지 않겠습니다.\n\n# JavaScript에서 이진 색인 트리 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드를 구현할 때, 예상과는 다르게 할 것입니다. 클래스로 트리 구조를 구현하는 대신, 이 구조를 배열로 나타내고 트래버스하는 방법으로 이해할 수 있도록 특수한 비트 연산을 사용할 것입니다.\n\n두 가지 작업에 초점을 맞출 것입니다: 업데이트와 특정 위치까지의 합을 얻는 것입니다.\n\n업데이트 작업은 주어진 값을 원하는 위치에 추가하고, 또한 구조를 트래버스하여 모든 하위 항목을 업데이트 할 것입니다.\n\n\"getSum\" 작업은 원하는 노드까지의 서브트리의 합을 반환할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## BIT 생성하기\n\n처음 다룰 주제는 어떻게 만드는 지입니다. 앞서 말했듯이 배열로 표현하고, 현재 인덱스의 마지막 설정 비트를 계산하여 이동하며, 트리를 탐색할 때 이를 추가하거나 제거합니다.\n\n먼저, BIT를 초기 생성할 때는 아래로 이동하므로, 마지막 설정된 비트를 추가합니다.\n\n초기에 BIT 배열은 모두 0으로 설정되어 있고, 우리는 원본 값의 배열을 지나가며 이 논리를 따릅니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 첫 번째 인덱스(이 경우에는 0)부터 시작합니다.\n- 인덱스에 1을 추가합니다(BIT 배열은 초기 요소가 비어 있는 상태입니다).\n- 현재 인덱스의 배열 값과 BIT 배열 내의 새 위치에 값을 추가합니다.\n- 인덱스의 마지막으로 설정된 비트(즉, 1)을 가져와 인덱스에 추가하여 2로 바꿉니다.\n- 단계 1로 돌아갑니다.\n\n시작할 배열이 다음과 같다고 가정해 봅시다: [2, 1, 1, 3, 2, 3], 그리고 BIT에 접두사 합을 저장하려고 할 때:\n\n- 인덱스 0에서 2의 값을 얻습니다.\n- BIT 배열에 가서 1을 추가하여 BIT 인덱스를 1로 만듭니다.\n- BIT 배열의 위치 1에 있는 값에 2를 추가하여 2로 만듭니다.\n- 1의 마지막 설정된 비트인 1을 가져와 BIT 인덱스에 추가하여 2로 만듭니다.\n- BIT 배열의 인덱스 2에서는 다시 2를 추가하여 2가 됩니다.\n- 2의 마지막 설정된 비트(10)는 2이므로 BIT 인덱스 4로 이동합니다.\n- BIT 인덱스 4에 2를 추가하여 마찬가지로 2가 됩니다.\n- 4의 마지막 설정된 비트(100)도 4이므로 존재하지 않는 8로 이동하게 되고 여기서 종료됩니다.\n\n이 시점에서 BIT 배열은 다음과 같이 보입니다: [0, 2, 2, 0, 2, 0, 0]\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 우리는 원래 배열의 첫 번째 2개만 추가했습니다. 이제 우리 배열의 두 번째 요소에도 같은 작업을 수행합니다(위치 1):\n\n- 원래 인덱스 1은 BIT 인덱스 2를 의미합니다(시작 시 인덱스에 1을 추가하는 것을 기억하세요).\n- 우리는 BITArray[2]의 값에 1을 추가하여 3으로 만듭니다.\n- 2가 4로 변하기 때문에 BIT 배열의 4번째 위치에 1을 추가하여 또한 3으로 만듭니다.\n- 그리고 이제 4가 8로 변하면서 다시 범위를 벗어나게 되므로 여기서 멈춥니다.\n\n이 시점에서 BIT 배열은 다음과 같이 보입니다: [0, 2, 3, 0, 3, 0, 0]\n\n그리고 계속 진행하면 다음과 같은 결과를 얻게 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nIdx — BIT 배열\n0 — [0, 0, 0, 0, 0, 0, 0] - 초기 상태\n1 — [0, 2, 2, 0, 2, 0, 0] - 첫 번째 반복\n2 — [0, 2, 3, 0, 3, 0, 0] - 두 번째 반복 (위에서 설명한대로)\n3 — [0, 2, 3, 1, 4, 0, 0]\n4 — [0, 2, 3, 1, 7, 0, 0]\n5 — [0, 2, 3, 1, 7, 2, 2]\n6 — [0, 2, 3, 1, 7, 2, 5]\r\n```\n\n모든 값을 BIT 배열에 추가한 후에는 [0, 2, 3, 1, 7, 2, 5]가 됩니다.\n\n이해를 돕기 위해 다음과 같이 구현을 살펴보겠습니다:\n\nconstructBITree 함수는 배열을 초기화하고 각 값에 대해 업데이트하는 역할을 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 배열이 설정되면, 원하는 색인까지의 접두사 합을 요청할 수 있는 쿼리를 시작할 수 있습니다.\n\n## 트리 쿼리\n\n트리를 쿼리하는 것은 이전과 유사한 접근 방식을 따릅니다만, 역으로 진행됩니다.\n\n인덱스 0 대신 우리가 찾고 있는 인덱스에서 (물론 1을 더한 값으로) 시작하고, 해당 인덱스의 마지막 비트를 제거하여 0 또는 그 이하로 이동하면서 트리를 \"위로\" 이동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 BIT 배열 [0, 2, 3, 1, 7, 2, 5]에서 트리에 쿼리하여 5번째 요소의 접두사 합을 얻고 싶다고 합시다. 물론, 이는 원래 배열의 모든 값을 더하는 것과 동일하다는 것을 의미합니다 (6개의 값이 있음).\n\n- 이제, 인덱스 5에서 시작하지만 1을 추가하여 6이 되었습니다.\n- BIT 배열의 6번째 인덱스의 값은 5입니다.\n- 이제, 인덱스의 마지막 설정된 비트 (6이며 2진법으로 110입니다)를 빼서 4로 만듭니다.\n- 우리의 BIT 배열에서 4번째 인덱스의 값은 7이므로 5에 추가하여 약 12가 됩니다.\n- 4의 마지막 설정된 비트는 4이므로, 빼서 0이 됩니다.\n- 끝났습니다.\n\n원래 배열을 모두 순회하여 모든 숫자를 더하는 대신, 우리는 BIT 배열에서 2개의 값을 필요로 했습니다. 이 변경으로 O(n)을 O(Log2(n)) 알고리즘으로 변환했습니다. 꽤 멋지죠?!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이제 구현을 살펴봅시다:\n\n이것은 간단한 구현입니다. 핵심은 8번 라인이며, 여기서 현재 인덱스에서 마지막으로 설정된 비트를 뺍니다. 여기서 모든 마법이 벌어집니다.\n\n읽어주셨나요? IT 산업에서 2 십년의 지혜를 무료로 공유하는 제 뉴스레터를 구독해보세요. \"늙은 개발자의 헛소리\"에 가입하세요!\n\n이진 색인 트리는 그 뒤의 논리를 이해하면 매우 멋집니다. 첫 시도에서 이해하기 어려워 해도 걱정하지 마세요. \"이해하는 데 오랜 시간이 걸렸어요\". 중간값을 저장된 배열에서 확인하고 위에 보여준 단계를 따라 가는 것이 내 추천입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBITs를 사용해 보신 적이 있나요? 그것으로 무엇을 하셨나요? 이 데이터 구조의 실제 구현에 대해 알고 싶어요! 그러니까 의견란에 공유해 주세요!\n\n# 레고처럼 재사용 가능한 구성 요소로 앱 구축하기\n\n![이미지](/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_1.png)\n\nBit의 오픈소스 도구는 25만 명 이상의 개발자가 구성 요소로 앱을 만드는 데 도와주고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 UI, 기능 또는 페이지를 재사용 가능한 구성 요소로 변환하여 여러 애플리케이션 간에 공유하세요. 협업하기가 더 쉽고 빠르게 빌드할 수 있어요.\n\n→ 자세히 알아보기\n\n앱을 구성 요소로 분할하여 앱 개발을 더 쉽게 만들고 원하는 작업 흐름에 대한 최상의 경험을 누리세요:\n\n## → 마이크로 프론트엔드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## → 디자인 시스템\n\n## → 코드 공유 및 재사용\n\n## → 모노 저장소\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png"},"coverImage":"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e최적화에 실패한 보통의 데이터 구조\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e가끔 데이터 구조는 직접적이고 매우 실용적인 사용 사례를 가지고 있어 누군가 그것을 고안할 만한 이유를 이해할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그런데 항상 그렇지만은 않습니다. 때로는 데이터 구조가 그저 어떤 이점이나 성능 향상을 제공하기 위해 존재하는 경우도 있습니다. 항상 사용하실 건가요? 아마도 그렇지 않을 것입니다. 하지만 실제로 유용하게 사용할 때 알아 두어서 기뻐할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e오늘은 BIT 또는 다른 말로 이진 인덱스 트리에 대해 이야기하고 싶어요. 이 데이터 구조는 검색 및 삽입을 최적화하려고 노력하지만 그것을 실패하는 특징을 가지고 있어요.\u003c/p\u003e\n\u003ch1\u003eBITs 뒤에 숨겨진 의도\u003c/h1\u003e\n\u003cp\u003eBITs를 \"보통인 데이터 구조\"라고 부르고 싶어요. 다른 데이터 구조들이 트리에서 삽입 또는 읽기 연산 중 하나를 최적화하려고 하는데 그 결과를 O(1)로 만들고 다른 하나는 O(n)으로 놓는 것에 집중하는 반면, BITs는 두 가지 모두를 개선하려고 해요.\u003c/p\u003e\n\u003cp\u003e그런데 트리에 삽입하고 읽기를 상수 시간 안에 수행하는 것은 불가능하기 때문에, 이 구조체가 시도하는 것에 실패한다고 말하는 건 정말 그렇게 생각해요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e말이 그렇게 되면, 실제로 BITs는 O(Log n) 성능으로 데이터를 삽입하고 읽을 수 있게 해줍니다. 대단하지도 않고 최악도 아니라서, 그러니까 그냥 보통 정도입니다.\u003c/p\u003e\n\u003cp\u003e농담은 그만두고, BITs를 사용하면 트리를 쿼리하고 업데이트하는 데 합리적인 성능을 제공합니다. 따라서 트리 모양의 구조물을 다루고 논리가 그것에 많은 읽기 및 쓰기를 수행하는 경우, 이것이 당신에게 적합한 데이터 구조일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 데이터 구조의 주요 사용 사례는 배열 내 요소들의 효율적인 접두사 합계(즉, n번째까지의 모든 요소의 합)를 가질 수 있는 능력입니다. 이것은 산술 코딩을 사용할 때 편리하다고 합니다. 그러나 우리는 지금 그 무한한 토끼굴에 들어가지 않겠습니다.\u003c/p\u003e\n\u003ch1\u003eJavaScript에서 이진 색인 트리 구현\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 코드를 구현할 때, 예상과는 다르게 할 것입니다. 클래스로 트리 구조를 구현하는 대신, 이 구조를 배열로 나타내고 트래버스하는 방법으로 이해할 수 있도록 특수한 비트 연산을 사용할 것입니다.\u003c/p\u003e\n\u003cp\u003e두 가지 작업에 초점을 맞출 것입니다: 업데이트와 특정 위치까지의 합을 얻는 것입니다.\u003c/p\u003e\n\u003cp\u003e업데이트 작업은 주어진 값을 원하는 위치에 추가하고, 또한 구조를 트래버스하여 모든 하위 항목을 업데이트 할 것입니다.\u003c/p\u003e\n\u003cp\u003e\"getSum\" 작업은 원하는 노드까지의 서브트리의 합을 반환할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003eBIT 생성하기\u003c/h2\u003e\n\u003cp\u003e처음 다룰 주제는 어떻게 만드는 지입니다. 앞서 말했듯이 배열로 표현하고, 현재 인덱스의 마지막 설정 비트를 계산하여 이동하며, 트리를 탐색할 때 이를 추가하거나 제거합니다.\u003c/p\u003e\n\u003cp\u003e먼저, BIT를 초기 생성할 때는 아래로 이동하므로, 마지막 설정된 비트를 추가합니다.\u003c/p\u003e\n\u003cp\u003e초기에 BIT 배열은 모두 0으로 설정되어 있고, 우리는 원본 값의 배열을 지나가며 이 논리를 따릅니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e첫 번째 인덱스(이 경우에는 0)부터 시작합니다.\u003c/li\u003e\n\u003cli\u003e인덱스에 1을 추가합니다(BIT 배열은 초기 요소가 비어 있는 상태입니다).\u003c/li\u003e\n\u003cli\u003e현재 인덱스의 배열 값과 BIT 배열 내의 새 위치에 값을 추가합니다.\u003c/li\u003e\n\u003cli\u003e인덱스의 마지막으로 설정된 비트(즉, 1)을 가져와 인덱스에 추가하여 2로 바꿉니다.\u003c/li\u003e\n\u003cli\u003e단계 1로 돌아갑니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e시작할 배열이 다음과 같다고 가정해 봅시다: [2, 1, 1, 3, 2, 3], 그리고 BIT에 접두사 합을 저장하려고 할 때:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e인덱스 0에서 2의 값을 얻습니다.\u003c/li\u003e\n\u003cli\u003eBIT 배열에 가서 1을 추가하여 BIT 인덱스를 1로 만듭니다.\u003c/li\u003e\n\u003cli\u003eBIT 배열의 위치 1에 있는 값에 2를 추가하여 2로 만듭니다.\u003c/li\u003e\n\u003cli\u003e1의 마지막 설정된 비트인 1을 가져와 BIT 인덱스에 추가하여 2로 만듭니다.\u003c/li\u003e\n\u003cli\u003eBIT 배열의 인덱스 2에서는 다시 2를 추가하여 2가 됩니다.\u003c/li\u003e\n\u003cli\u003e2의 마지막 설정된 비트(10)는 2이므로 BIT 인덱스 4로 이동합니다.\u003c/li\u003e\n\u003cli\u003eBIT 인덱스 4에 2를 추가하여 마찬가지로 2가 됩니다.\u003c/li\u003e\n\u003cli\u003e4의 마지막 설정된 비트(100)도 4이므로 존재하지 않는 8로 이동하게 되고 여기서 종료됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 시점에서 BIT 배열은 다음과 같이 보입니다: [0, 2, 2, 0, 2, 0, 0]\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그리고 우리는 원래 배열의 첫 번째 2개만 추가했습니다. 이제 우리 배열의 두 번째 요소에도 같은 작업을 수행합니다(위치 1):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e원래 인덱스 1은 BIT 인덱스 2를 의미합니다(시작 시 인덱스에 1을 추가하는 것을 기억하세요).\u003c/li\u003e\n\u003cli\u003e우리는 BITArray[2]의 값에 1을 추가하여 3으로 만듭니다.\u003c/li\u003e\n\u003cli\u003e2가 4로 변하기 때문에 BIT 배열의 4번째 위치에 1을 추가하여 또한 3으로 만듭니다.\u003c/li\u003e\n\u003cli\u003e그리고 이제 4가 8로 변하면서 다시 범위를 벗어나게 되므로 여기서 멈춥니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 시점에서 BIT 배열은 다음과 같이 보입니다: [0, 2, 3, 0, 3, 0, 0]\u003c/p\u003e\n\u003cp\u003e그리고 계속 진행하면 다음과 같은 결과를 얻게 됩니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eIdx\u003c/span\u003e — \u003cspan class=\"hljs-variable constant_\"\u003eBIT\u003c/span\u003e 배열\n\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e — [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] - 초기 상태\n\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e — [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] - 첫 번째 반복\n\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e — [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] - 두 번째 반복 (위에서 설명한대로)\n\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e — [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e — [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e — [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]\n\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e — [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모든 값을 BIT 배열에 추가한 후에는 [0, 2, 3, 1, 7, 2, 5]가 됩니다.\u003c/p\u003e\n\u003cp\u003e이해를 돕기 위해 다음과 같이 구현을 살펴보겠습니다:\u003c/p\u003e\n\u003cp\u003econstructBITree 함수는 배열을 초기화하고 각 값에 대해 업데이트하는 역할을 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 배열이 설정되면, 원하는 색인까지의 접두사 합을 요청할 수 있는 쿼리를 시작할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e트리 쿼리\u003c/h2\u003e\n\u003cp\u003e트리를 쿼리하는 것은 이전과 유사한 접근 방식을 따릅니다만, 역으로 진행됩니다.\u003c/p\u003e\n\u003cp\u003e인덱스 0 대신 우리가 찾고 있는 인덱스에서 (물론 1을 더한 값으로) 시작하고, 해당 인덱스의 마지막 비트를 제거하여 0 또는 그 이하로 이동하면서 트리를 \"위로\" 이동합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리의 BIT 배열 [0, 2, 3, 1, 7, 2, 5]에서 트리에 쿼리하여 5번째 요소의 접두사 합을 얻고 싶다고 합시다. 물론, 이는 원래 배열의 모든 값을 더하는 것과 동일하다는 것을 의미합니다 (6개의 값이 있음).\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이제, 인덱스 5에서 시작하지만 1을 추가하여 6이 되었습니다.\u003c/li\u003e\n\u003cli\u003eBIT 배열의 6번째 인덱스의 값은 5입니다.\u003c/li\u003e\n\u003cli\u003e이제, 인덱스의 마지막 설정된 비트 (6이며 2진법으로 110입니다)를 빼서 4로 만듭니다.\u003c/li\u003e\n\u003cli\u003e우리의 BIT 배열에서 4번째 인덱스의 값은 7이므로 5에 추가하여 약 12가 됩니다.\u003c/li\u003e\n\u003cli\u003e4의 마지막 설정된 비트는 4이므로, 빼서 0이 됩니다.\u003c/li\u003e\n\u003cli\u003e끝났습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e원래 배열을 모두 순회하여 모든 숫자를 더하는 대신, 우리는 BIT 배열에서 2개의 값을 필요로 했습니다. 이 변경으로 O(n)을 O(Log2(n)) 알고리즘으로 변환했습니다. 꽤 멋지죠?!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e자, 이제 구현을 살펴봅시다:\u003c/p\u003e\n\u003cp\u003e이것은 간단한 구현입니다. 핵심은 8번 라인이며, 여기서 현재 인덱스에서 마지막으로 설정된 비트를 뺍니다. 여기서 모든 마법이 벌어집니다.\u003c/p\u003e\n\u003cp\u003e읽어주셨나요? IT 산업에서 2 십년의 지혜를 무료로 공유하는 제 뉴스레터를 구독해보세요. \"늙은 개발자의 헛소리\"에 가입하세요!\u003c/p\u003e\n\u003cp\u003e이진 색인 트리는 그 뒤의 논리를 이해하면 매우 멋집니다. 첫 시도에서 이해하기 어려워 해도 걱정하지 마세요. \"이해하는 데 오랜 시간이 걸렸어요\". 중간값을 저장된 배열에서 확인하고 위에 보여준 단계를 따라 가는 것이 내 추천입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eBITs를 사용해 보신 적이 있나요? 그것으로 무엇을 하셨나요? 이 데이터 구조의 실제 구현에 대해 알고 싶어요! 그러니까 의견란에 공유해 주세요!\u003c/p\u003e\n\u003ch1\u003e레고처럼 재사용 가능한 구성 요소로 앱 구축하기\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eBit의 오픈소스 도구는 25만 명 이상의 개발자가 구성 요소로 앱을 만드는 데 도와주고 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e어떤 UI, 기능 또는 페이지를 재사용 가능한 구성 요소로 변환하여 여러 애플리케이션 간에 공유하세요. 협업하기가 더 쉽고 빠르게 빌드할 수 있어요.\u003c/p\u003e\n\u003cp\u003e→ 자세히 알아보기\u003c/p\u003e\n\u003cp\u003e앱을 구성 요소로 분할하여 앱 개발을 더 쉽게 만들고 원하는 작업 흐름에 대한 최상의 경험을 누리세요:\u003c/p\u003e\n\u003ch2\u003e→ 마이크로 프론트엔드\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e→ 디자인 시스템\u003c/h2\u003e\n\u003ch2\u003e→ 코드 공유 및 재사용\u003c/h2\u003e\n\u003ch2\u003e→ 모노 저장소\u003c/h2\u003e\n\u003ch1\u003e더 알아보기\u003c/h1\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-AdvancedDataStructuresandAlgorithmsImplementingyourfirstBinaryIndexedTree"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>