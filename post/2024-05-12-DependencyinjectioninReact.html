<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트에서의 의존성 주입 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-DependencyinjectioninReact" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트에서의 의존성 주입 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트에서의 의존성 주입 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-DependencyinjectioninReact_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-DependencyinjectioninReact" data-gatsby-head="true"/><meta name="twitter:title" content="리액트에서의 의존성 주입 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-DependencyinjectioninReact_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 21:18" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트에서의 의존성 주입</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트에서의 의존성 주입" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-DependencyinjectioninReact&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>리액트 컴포넌트에는 비즈니스 로직이 포함되어서는 안 된다고 생각하시나요? 만약 그렇다면 계속 읽어주세요. 아니라면 지금 멈추세요. 이 기사는 다른 사람을 위한 것입니다.</p>
<h2>TL; DR;</h2>
<p>리액트 프로젝트에 의존성 주입을 3단계로 추가해보세요:</p>
<ul>
<li>의존성을 넣을 "컨테이너"를 만드세요</li>
<li>의존성을 검색하는 hook useInject를 만드세요</li>
<li>컴포넌트에서 해당 훅을 사용하세요</li>
</ul>
<h2>상세 버전</h2>
<p>답안이 망설여진다면, 이유에 대해 몇 가지 통찰을 제공해 드리겠습니다:</p>
<ul>
<li>React는 사용자 인터페이스를 만들기 위한 라이브러리입니다; 이 정의를 통해 컴포넌트에 비즈니스 로직을 넣지 말아야 한다는 것을 알 수 있습니다.</li>
<li>비즈니스 로직을 포함하는 컴포넌트는 읽기, 유지 관리, 테스트하기 어렵습니다.</li>
<li>컴포넌트에서 비즈니스 로직을 추출하는 것은 재사용 가능한 좋은 아이디어입니다.</li>
</ul>
<p>그렇다면, 컴포넌트에서 비즈니스 로직을 분리하면 외부 클래스나 함수와 같은 곳에 쓰여져야 합니다. 어떻게 하면 될까요? 의존성 주입을 사용하여!</p>
<h2>의존성 주입이란 무엇이며 왜 사용해야 할까요</h2>
<p>의존성 주입(Dependency Injection, DI)은 객체 생성을 객체 사용과 분리하는 소프트웨어 디자인 패턴입니다. 실제로, 사용하는 코드 내에서 물건을 만들지 않고, 객체의 인스턴스화는 객체를 만들고 그것을 필요로 하는 구성 요소에 제공하는 외부 개체로 위임됩니다.</p>
<p>의존성 주입은 코드를 더 유연하고 모듈식으로 만들어주며, 쉽게 테스트할 수 있도록 합니다. 강하게 결합된 코드 대신, 모듈식 구성 요소를 제공하여 필요에 따라 코드를 변경하지 않고 쉽게 교체하거나 확장할 수 있습니다.</p>
<p>또한, DI는 코드의 가독성과 유지 보수성을 향상시키는 데 도움을 줍니다. 구성 요소 간의 의존성을 명시적으로 만들어 복잡한 의존성을 관리하는 것을 용이하게 합니다.</p>
<p>요약하자면, 의존성 주입은 다음과 같은 목적으로 사용됩니다:</p>
<ul>
<li>객체의 생성과 사용을 분리합니다.</li>
<li>코드를 더 유연하고 모듈화되며 쉽게 테스트할 수 있게 만듭니다.</li>
<li>코드의 가독성과 유지보수성을 향상시킵니다.</li>
</ul>
<h2>React에서 의존성 주입</h2>
<p>React 애플리케이션을 개발해야 한다고 상상해봅시다. 할 일 목록을 관리하는 React 애플리케이션을 만들어보겠습니다. (얼마나 멋져요 😅)</p>
<p>할 일 목록을 표시하는 컴포넌트가 있습니다.
컴포넌트가 렌더링될 때 목록을 API에서 로드하고 싶습니다. 그리고 컴포넌트에서 비즈니스 로직을 작성하지 않으려면 API 호출을 수행하는 서비스가 필요합니다. 아래 다이어그램에서 보여지는 것처럼요.</p>
<pre><code class="hljs language-js">              <span class="hljs-title class_">Component</span>                  <span class="hljs-title class_">Service</span>                       <span class="hljs-variable constant_">API</span>
                  |                          |                          |
                  |                          |                          |
                  |    데이터 요청           |                          |
                  |------------------------->|                          |
                  |                          |                          |
                  |                          |  <span class="hljs-variable constant_">API</span>에서 데이터 검색      |
                  |                          |------------------------->|
                  |                          |                          |
                  |                          |    데이터 처리            |
                  |                          |&#x3C;-------------------------|
                  |                          |                          |
                  |  데이터 수신             |                          |
                  |&#x3C;-------------------------|                          |
                  |                          |                          |
</code></pre>
<p>이 순서 다이어그램에서 컴포넌트는 메소드나 함수를 호출하여 서비스에 데이터 요청을 보냅니다. 그런 다음 서비스는 요청을 보내어 외부 API에서 데이터를 검색합니다. 데이터를 받은 후 서비스가 처리하고 컴포넌트로 반환합니다.</p>
<p>다이어그램에서 화살표로 표시되는 이벤트 시퀀스를 볼 수 있습니다. API에서 서비스로의 점선 화살표는 API에서 데이터를 검색하는 것을 나타내며, 서비스에서 컴포넌트로의 실선 화살표는 처리된 데이터를 컴포넌트로 반환하는 것을 나타냅니다.</p>
<p>구현 수준에서 코드는 이렇게 보일 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">TodoService</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoService'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [todos, setTodos] = <span class="hljs-title function_">useState</span>([]);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchTodos</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> todos = <span class="hljs-keyword">await</span> <span class="hljs-title class_">TodoService</span>.<span class="hljs-title function_">getTodos</span>(); <span class="hljs-comment">// TodoService를 호출하여 할 일 가져오기</span>
        <span class="hljs-title function_">setTodos</span>(todos);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);
      }
    }
    <span class="hljs-title function_">fetchTodos</span>();
  }, []);

  <span class="hljs-keyword">return</span> (
    - 목록
      {todos.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =></span> (
        - 아이디: {todo.<span class="hljs-property">id</span>}, 제목: {todo.<span class="hljs-property">title</span>}
      ))}
    - 
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">TodoList</span>;
</code></pre>
<p>이 코드에서는 TodoService에서 getTodos 메서드를 호출하는 TodoList 컴포넌트를 정의합니다. useState 훅을 사용하여 서비스에서 반환된 할 일을 추적하고, useEffect 훅을 사용하여 컴포넌트가 마운트될 때 할 일을 가져옵니다.</p>
<p>fetchTodos 함수가 호출될 때 await 키워드를 사용하여 getTodos 메서드가 할 일을 반환할 때까지 기다리며, 할 일이 반환되면 setTodos 함수를 사용하여 todos 상태 변수에 할 일을 설정합니다.</p>
<p>마침내, map 함수를 사용하여 할 일 목록을 렌더링하고 각 할 일의 제목을 표시합니다. 이것은 간소화된 예제이며 TodoService의 구현은 사용된 API에 따라 달라질 수 있습니다.</p>
<h2>props를 사용한 의존성 주입</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params">{ todoService }</span>) {
  <span class="hljs-keyword">const</span> [todos, setTodos] = <span class="hljs-title function_">useState</span>([]);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchTodos</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> todos = <span class="hljs-keyword">await</span> todoService.<span class="hljs-title function_">getTodos</span>(); <span class="hljs-comment">// 주입된 TodoService를 호출하여 할 일을 가져옴</span>
        <span class="hljs-title function_">setTodos</span>(todos);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);
      }
    }
    <span class="hljs-title function_">fetchTodos</span>();
  }, [todoService]);

  <span class="hljs-keyword">return</span> (
    - 목록
      {todos.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =></span> (
        - 고유 키{todo.<span class="hljs-property">id</span>}{todo.<span class="hljs-property">title</span>}
      ))}
    - 목록 종료
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">TodoList</span>;
</code></pre>
<p>이 업데이트된 코드에서는 TodoService를 TodoList 구성 요소의 prop으로 주입합니다. 구성 요소는 더 이상 TodoService를 직접 가져오지 않고 주입된 서비스를 사용하여 할 일을 가져옵니다.</p>
<p>컴포넌트가 마운트될 때 fetchTodos 함수는 주입된 todoService를 사용하여 할 일을 검색합니다. 이렇게 함으로써 TodoService의 구현을 손쉽게 교체할 수 있습니다. 다른 서비스 구현체를 TodoList 컴포넌트에 전달하여 TodoService의 특정 구현체를 사용하려면 다음과 같이 서비스를 prop으로 전달합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">TodoService</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoService'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">TodoList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoList'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">TodoList</span> <span class="hljs-attr">todoService</span>=<span class="hljs-string">{TodoService}</span> /></span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>TodoService를 TodoList 컴포넌트에 prop으로 전달함으로써 TodoService의 특정 구현체를 사용할 수 있습니다. TodoList 컴포넌트를 수정하지 않고 TodoService의 다른 구현체간 쉽게 전환이 가능해지므로, 보다 모듈식이고 유연한 디자인을 구현할 수 있습니다.</p>
<p>이 내용은 Component에 대한 테스트를 작성할 때 매우 유용할 수 있습니다.</p>
<p>여기서 우리가 해결해야 할 두 가지 문제가 있습니다:</p>
<ul>
<li>우리는 아직도 의존성 주입을 사용하지 않는 App Component에 TodoService를 가져와야 합니다.</li>
<li>Props는 응용 프로그램 전체에서 데이터를 전달하는 효과적인 방법 중 하나일 뿐이며, 중첩 레이어와만 잘 작동합니다.</li>
</ul>
<pre><code class="hljs language-js">              부모 <span class="hljs-title class_">Component</span>
                         |
                         <span class="hljs-title class_">SubComponent</span> A로 <span class="hljs-title class_">Prop</span> 전달
                         |
                         |-<span class="hljs-title class_">SubComponent</span> A
                         |
                         |
                         <span class="hljs-title class_">SubComponent</span> B로 <span class="hljs-title class_">Prop</span> 전달
                         |
                         |
                         |--<span class="hljs-title class_">SubComponent</span> B
                         |
                         |
                         <span class="hljs-title class_">SubComponent</span> C로 <span class="hljs-title class_">Prop</span> 전달
                         |
                         |
                         |---<span class="hljs-title class_">SubComponent</span> C
</code></pre>
<p>이 다이어그램은 프롭스가 컴포넌트의 계층 구조를 통해 전달되는 방법을 보여줍니다. 컴포넌트가 더 들여쓰여 있을수록 컴포넌트 트리에서 더 깊게 중첩됩니다. 이 중첩을 원치 않아요. 😨</p>
<h2>React Context를 사용한 의존성 주입</h2>
<p>다음은 TodoContext를 사용하여 컴포넌트에서 TodoService를 호출하는 React 코드의 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect, useContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">TodoContext</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoContext'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">TodoList</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [todos, setTodos] = <span class="hljs-title function_">useState</span>([]);
  <span class="hljs-keyword">const</span> todoService = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">TodoContext</span>); <span class="hljs-comment">// TodoContext에서 TodoService를 가져옴</span>

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchTodos</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> todos = <span class="hljs-keyword">await</span> todoService.<span class="hljs-title function_">getTodos</span>(); <span class="hljs-comment">// TodoContext에서 TodoService를 호출하여 todos 가져오기</span>
        <span class="hljs-title function_">setTodos</span>(todos);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);
      }
    }
    <span class="hljs-title function_">fetchTodos</span>();
  }, [todoService]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>
      {todos.map(todo => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{todo.id}</span>></span>{todo.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ul</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">TodoList</span>;
</code></pre>
<p>이 코드에서는 useContext 훅을 사용하여 TodoContext에서 TodoService를 가져옵니다. 그런 다음 가져온 todoService를 사용하여 할 일을 불러옵니다.</p>
<p>useEffect 훅은 컴포넌트가 마운트될 때 할 일을 불러오는 데 사용됩니다. fetchTodos 함수는 가져온 todoService를 사용하여 할 일을 불러와서 그것들을 할 일 상태 변수에 설정합니다.</p>
<p>이 컴포넌트를 사용하려면 먼저 TodoContext를 생성하고 해당 컴포넌트를 래핑해야 합니다. 다음과 같이:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">TodoContext</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoContext'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">TodoService</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoService'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">TodoList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoList'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">TodoContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{TodoService}</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">TodoList</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">TodoContext.Provider</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>이 예제에서는 TodoContext를 생성하고 TodoService를 해당 값으로 전달합니다. 그런 다음 TodoList 컴포넌트를 TodoContext.Provider 컴포넌트로 감싸서 useContext 훅을 사용하여 컨텍스트에서 TodoService를 검색할 수 있도록 합니다.</p>
<h2>의존성 주입과 제어 역전 컨테이너 (IoC)를 사용한 의존성 주입</h2>
<p>이러한 컨텍스트 개념을 사용하여 제어 역전 컨테이너를 이용해 한 발 더 나아갈 수 있습니다.</p>
<p>기다려봐요, 제어 역전 컨테이너 (IoC)란 무엇인가요?</p>
<p>React에서 IoC (Inversion of Control) 컨테이너는 여러 컴포넌트와 서비스 사이의 의존성을 관리하는 도구입니다. 이 도구를 사용하면 한 번에 서비스 또는 객체 (의존성)를 정의하고 등록한 다음, 이를 의존하는 다른 컴포넌트에 주입할 수 있습니다. 이를 통해 컴포넌트를 분리하고 응용 프로그램을 모듈식으로 만들고 유지보수하기 쉽게 할 수 있습니다.</p>
<p>React의 IoC 컨테이너는 대개 모든 의존성으로 사용할 수 있는 모든 객체를 참조하는 중앙 레지스트리를 제공함으로써 작동합니다. 컴포넌트는 직접 생성하는 대신에 이 컨테이너에서 이러한 의존성을 요청할 수 있습니다. 이 접근 방식은 또한 대체 구현으로 의존성을 교체하거나 테스트를 위해 목객체로 대체하기 쉽게 합니다.</p>
<p>React용 여러 인기있는 IoC 컨테이너로는 InversifyJS, Awilix, BottleJS 등이 있으며, 생성자 주입, 속성 주입, 자동 의존성 해결 등과 같은 다양한 기능을 제공합니다. 일부 IoC 컨테이너는 다른 것보다 더 복잡할 수 있으므로 프로젝트의 요구 사항과 복잡성 수준에 적합한 것을 선택하는 것이 중요합니다.</p>
<p>우리의 경우, 아래와 같이 처음부터 예제를 작성할 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { createContext, useContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-comment">// 컨테이너를 위한 새로운 컨텍스트를 생성합니다</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ContainerContext</span> = <span class="hljs-title function_">createContext</span>();

<span class="hljs-comment">// 컨테이너를 자식 컴포넌트에 제공하는 컴포넌트를 정의합니다</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">ContainerProvider</span> = (<span class="hljs-params">{ container, children }</span>) => {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ContainerContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{container}</span>></span>{children}<span class="hljs-tag">&#x3C;/<span class="hljs-name">ContainerContext.Provider</span>></span></span>;
};

<span class="hljs-comment">// 컴포넌트 내에서 컨테이너에 접근하기 위한 훅을 정의합니다</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">useContainer</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> container = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ContainerContext</span>);
  <span class="hljs-keyword">if</span> (!container) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'컨테이너를 찾을 수 없습니다. 컴포넌트를 ContainerProvider로 감싸는지 확인해주세요.'</span>);
  }
  <span class="hljs-keyword">return</span> container;
};

<span class="hljs-comment">// 컨테이너에서 의존성을 주입하는 훅을 정의합니다</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">useInject</span> = (<span class="hljs-params">identifier</span>) => {
  <span class="hljs-keyword">const</span> container = <span class="hljs-title function_">useContainer</span>();
  <span class="hljs-keyword">return</span> container.<span class="hljs-title function_">resolve</span>(identifier);
};

<span class="hljs-comment">// 예시 사용법:</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">MyService</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> };
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> myService = <span class="hljs-title function_">useInject</span>(<span class="hljs-string">'myService'</span>);
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>{myService.foo}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>; <span class="hljs-comment">// 결과: 'bar'</span>
};

<span class="hljs-keyword">const</span> container = {
  <span class="hljs-attr">registry</span>: {
    <span class="hljs-attr">myService</span>: <span class="hljs-title class_">MyService</span>()
  },
  <span class="hljs-title function_">resolve</span>(<span class="hljs-params">identifier</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">registry</span>.<span class="hljs-title function_">hasOwnProperty</span>(identifier)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`식별자 <span class="hljs-subst">${identifier}</span>로 식별되는 객체를 컨테이너에서 찾을 수 없습니다`</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">registry</span>[identifier];
  }
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ContainerProvider</span> <span class="hljs-attr">container</span>=<span class="hljs-string">{container}</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">MyComponent</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ContainerProvider</span>></span></span>
  );
};
</code></pre>
<p>이 예제에서는 컨테이너 오브젝트를 prop으로 전달받아 ContainerProvider 컴포넌트를 생성하여 ContainerContext 컨텍스트를 사용하여 자식에게 제공하는 방법을 보여줍니다. 그리고 컴포넌트 내에서 컨테이너를 검색하는 useContainer 훅을 정의합니다.</p>
<p>그런 다음 MyService 객체를 정의하고 컨테이너 오브젝트의 레지스트리 속성에 추가합니다. 또한 컨테이너 오브젝트에 식별자를 입력받아 해당 객체를 검색하는 resolve 메소드를 정의합니다. 이 경우 resolve 메소드는 MyService 객체를 반환합니다.</p>
<p>MyComponent를 ContainerProvider로 감싸고 컨테이너 오브젝트를 prop으로 전달한 후 MyComponent를 렌더하는 App 컴포넌트를 렌더합니다. MyComponent가 렌더되면 컨테이너에서 myService 의존성을 검색하고 화면에 해당하는 foo 속성을 렌더합니다.</p>
<p>이 코드에서는 식별자를 매개변수로 전달받는 useInject 훅을 추가합니다. 이 훅은 컨테이너에서 해당 객체를 검색합니다. useInject 훅은 내부적으로 useContainer를 호출하여 컨테이너를 검색하고, 그런 다음 컨테이너에서 resolve 메서드를 호출하여 객체를 검색합니다.</p>
<p>다음으로, useInject 훅을 사용하여 컨테이너에서 myService 의존성을 검색하고 그 foo 속성을 화면에 렌더링하는 MyComponent를 생성합니다.</p>
<p>마지막으로, ContainerProvider로 랩핑된 MyComponent를 렌더링하는 App 컴포넌트를 렌더링합니다. MyComponent가 렌더링되면 useInject 훅을 사용하여 컨테이너에서 myService 의존성을 검색하고 해당 foo 속성을 화면에 렌더링합니다.</p>
<p>요약하면, 의존성 주입은 더 유연하고 모듈식이며 쉽게 테스트할 수 있는 코드를 구현할 수 있는 디자인 패턴입니다. 이는 객체의 생성과 사용을 분리함으로써 컴포넌트 간의 의존성을 명시적으로 만들어 복잡한 의존성을 관리하기 쉽게 해줍니다.</p>
<p>리액트에서는 종속성 주입을 프롭스로 서비스를 주입하거나 후크를 사용하여 컨테이너를 통해 컴포넌트에 종속성을 제공하여 구현할 수 있습니다. 이 방법을 사용하면 더 깔끔하고 유지보수가 쉬운 코드를 작성할 수 있으며 비즈니스 로직을 재사용하고 종속성을 관리하는 일이 더 쉬워집니다.</p>
<p>이러한 패턴을 따르면 리액트 코드의 가독성, 유지보수성, 테스트 가능성이 향상될 수 있습니다.</p>
<p><img src="/assets/img/2024-05-12-DependencyinjectioninReact_0.png" alt="이미지"></p>
<p>와우, 마지막까지 왔군요. 이 기사는 실험이었습니다. 아이디어는 저의 것이지만 텍스트, 다이어그램 및 코드는 ChatGpt가 완전히 작성했습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트에서의 의존성 주입","description":"","date":"2024-05-12 21:18","slug":"2024-05-12-DependencyinjectioninReact","content":"\n\n리액트 컴포넌트에는 비즈니스 로직이 포함되어서는 안 된다고 생각하시나요? 만약 그렇다면 계속 읽어주세요. 아니라면 지금 멈추세요. 이 기사는 다른 사람을 위한 것입니다.\n\n## TL; DR;\n\n리액트 프로젝트에 의존성 주입을 3단계로 추가해보세요:\n\n- 의존성을 넣을 \"컨테이너\"를 만드세요\n- 의존성을 검색하는 hook useInject를 만드세요\n- 컴포넌트에서 해당 훅을 사용하세요\n\n\n\n## 상세 버전\n\n답안이 망설여진다면, 이유에 대해 몇 가지 통찰을 제공해 드리겠습니다:\n\n- React는 사용자 인터페이스를 만들기 위한 라이브러리입니다; 이 정의를 통해 컴포넌트에 비즈니스 로직을 넣지 말아야 한다는 것을 알 수 있습니다.\n- 비즈니스 로직을 포함하는 컴포넌트는 읽기, 유지 관리, 테스트하기 어렵습니다.\n- 컴포넌트에서 비즈니스 로직을 추출하는 것은 재사용 가능한 좋은 아이디어입니다.\n\n그렇다면, 컴포넌트에서 비즈니스 로직을 분리하면 외부 클래스나 함수와 같은 곳에 쓰여져야 합니다. 어떻게 하면 될까요? 의존성 주입을 사용하여!\n\n\n\n## 의존성 주입이란 무엇이며 왜 사용해야 할까요\n\n의존성 주입(Dependency Injection, DI)은 객체 생성을 객체 사용과 분리하는 소프트웨어 디자인 패턴입니다. 실제로, 사용하는 코드 내에서 물건을 만들지 않고, 객체의 인스턴스화는 객체를 만들고 그것을 필요로 하는 구성 요소에 제공하는 외부 개체로 위임됩니다.\n\n의존성 주입은 코드를 더 유연하고 모듈식으로 만들어주며, 쉽게 테스트할 수 있도록 합니다. 강하게 결합된 코드 대신, 모듈식 구성 요소를 제공하여 필요에 따라 코드를 변경하지 않고 쉽게 교체하거나 확장할 수 있습니다.\n\n또한, DI는 코드의 가독성과 유지 보수성을 향상시키는 데 도움을 줍니다. 구성 요소 간의 의존성을 명시적으로 만들어 복잡한 의존성을 관리하는 것을 용이하게 합니다.\n\n\n\n요약하자면, 의존성 주입은 다음과 같은 목적으로 사용됩니다:\n\n- 객체의 생성과 사용을 분리합니다.\n- 코드를 더 유연하고 모듈화되며 쉽게 테스트할 수 있게 만듭니다.\n- 코드의 가독성과 유지보수성을 향상시킵니다.\n\n## React에서 의존성 주입\n\nReact 애플리케이션을 개발해야 한다고 상상해봅시다. 할 일 목록을 관리하는 React 애플리케이션을 만들어보겠습니다. (얼마나 멋져요 😅)\n\n\n\n할 일 목록을 표시하는 컴포넌트가 있습니다.\n컴포넌트가 렌더링될 때 목록을 API에서 로드하고 싶습니다. 그리고 컴포넌트에서 비즈니스 로직을 작성하지 않으려면 API 호출을 수행하는 서비스가 필요합니다. 아래 다이어그램에서 보여지는 것처럼요.\n\n```js\n              Component                  Service                       API\n                  |                          |                          |\n                  |                          |                          |\n                  |    데이터 요청           |                          |\n                  |-------------------------\u003e|                          |\n                  |                          |                          |\n                  |                          |  API에서 데이터 검색      |\n                  |                          |-------------------------\u003e|\n                  |                          |                          |\n                  |                          |    데이터 처리            |\n                  |                          |\u003c-------------------------|\n                  |                          |                          |\n                  |  데이터 수신             |                          |\n                  |\u003c-------------------------|                          |\n                  |                          |                          |\r\n```\n\n이 순서 다이어그램에서 컴포넌트는 메소드나 함수를 호출하여 서비스에 데이터 요청을 보냅니다. 그런 다음 서비스는 요청을 보내어 외부 API에서 데이터를 검색합니다. 데이터를 받은 후 서비스가 처리하고 컴포넌트로 반환합니다.\n\n다이어그램에서 화살표로 표시되는 이벤트 시퀀스를 볼 수 있습니다. API에서 서비스로의 점선 화살표는 API에서 데이터를 검색하는 것을 나타내며, 서비스에서 컴포넌트로의 실선 화살표는 처리된 데이터를 컴포넌트로 반환하는 것을 나타냅니다.\n\n\n\n구현 수준에서 코드는 이렇게 보일 수 있습니다:\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport TodoService from './TodoService';\n\nfunction TodoList() {\n  const [todos, setTodos] = useState([]);\n\n  useEffect(() =\u003e {\n    async function fetchTodos() {\n      try {\n        const todos = await TodoService.getTodos(); // TodoService를 호출하여 할 일 가져오기\n        setTodos(todos);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    fetchTodos();\n  }, []);\n\n  return (\n    - 목록\n      {todos.map(todo =\u003e (\n        - 아이디: {todo.id}, 제목: {todo.title}\n      ))}\n    - \n  );\n}\n\nexport default TodoList;\n```\n\n이 코드에서는 TodoService에서 getTodos 메서드를 호출하는 TodoList 컴포넌트를 정의합니다. useState 훅을 사용하여 서비스에서 반환된 할 일을 추적하고, useEffect 훅을 사용하여 컴포넌트가 마운트될 때 할 일을 가져옵니다.\n\nfetchTodos 함수가 호출될 때 await 키워드를 사용하여 getTodos 메서드가 할 일을 반환할 때까지 기다리며, 할 일이 반환되면 setTodos 함수를 사용하여 todos 상태 변수에 할 일을 설정합니다.\n\n\n\n마침내, map 함수를 사용하여 할 일 목록을 렌더링하고 각 할 일의 제목을 표시합니다. 이것은 간소화된 예제이며 TodoService의 구현은 사용된 API에 따라 달라질 수 있습니다.\n\n## props를 사용한 의존성 주입\n\n```js\nimport React, { useState, useEffect } from 'react';\n\nfunction TodoList({ todoService }) {\n  const [todos, setTodos] = useState([]);\n\n  useEffect(() =\u003e {\n    async function fetchTodos() {\n      try {\n        const todos = await todoService.getTodos(); // 주입된 TodoService를 호출하여 할 일을 가져옴\n        setTodos(todos);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    fetchTodos();\n  }, [todoService]);\n\n  return (\n    - 목록\n      {todos.map(todo =\u003e (\n        - 고유 키{todo.id}{todo.title}\n      ))}\n    - 목록 종료\n  );\n}\n\nexport default TodoList;\n```\n\n이 업데이트된 코드에서는 TodoService를 TodoList 구성 요소의 prop으로 주입합니다. 구성 요소는 더 이상 TodoService를 직접 가져오지 않고 주입된 서비스를 사용하여 할 일을 가져옵니다.\n\n\n\n컴포넌트가 마운트될 때 fetchTodos 함수는 주입된 todoService를 사용하여 할 일을 검색합니다. 이렇게 함으로써 TodoService의 구현을 손쉽게 교체할 수 있습니다. 다른 서비스 구현체를 TodoList 컴포넌트에 전달하여 TodoService의 특정 구현체를 사용하려면 다음과 같이 서비스를 prop으로 전달합니다:\n\n```js\nimport React from 'react';\nimport TodoService from './TodoService';\nimport TodoList from './TodoList';\n\nfunction App() {\n  return \u003cTodoList todoService={TodoService} /\u003e;\n}\n\nexport default App;\n```\n\nTodoService를 TodoList 컴포넌트에 prop으로 전달함으로써 TodoService의 특정 구현체를 사용할 수 있습니다. TodoList 컴포넌트를 수정하지 않고 TodoService의 다른 구현체간 쉽게 전환이 가능해지므로, 보다 모듈식이고 유연한 디자인을 구현할 수 있습니다.\n\n\n\n이 내용은 Component에 대한 테스트를 작성할 때 매우 유용할 수 있습니다.\n\n여기서 우리가 해결해야 할 두 가지 문제가 있습니다:\n\n- 우리는 아직도 의존성 주입을 사용하지 않는 App Component에 TodoService를 가져와야 합니다.\n- Props는 응용 프로그램 전체에서 데이터를 전달하는 효과적인 방법 중 하나일 뿐이며, 중첩 레이어와만 잘 작동합니다.\n\n```js\n              부모 Component\n                         |\n                         SubComponent A로 Prop 전달\n                         |\n                         |-SubComponent A\n                         |\n                         |\n                         SubComponent B로 Prop 전달\n                         |\n                         |\n                         |--SubComponent B\n                         |\n                         |\n                         SubComponent C로 Prop 전달\n                         |\n                         |\n                         |---SubComponent C\n```\n\n\n\n이 다이어그램은 프롭스가 컴포넌트의 계층 구조를 통해 전달되는 방법을 보여줍니다. 컴포넌트가 더 들여쓰여 있을수록 컴포넌트 트리에서 더 깊게 중첩됩니다. 이 중첩을 원치 않아요. 😨\n\n## React Context를 사용한 의존성 주입\n\n다음은 TodoContext를 사용하여 컴포넌트에서 TodoService를 호출하는 React 코드의 예시입니다:\n\n```js\nimport React, { useState, useEffect, useContext } from 'react';\nimport TodoContext from './TodoContext';\n\nfunction TodoList() {\n  const [todos, setTodos] = useState([]);\n  const todoService = useContext(TodoContext); // TodoContext에서 TodoService를 가져옴\n\n  useEffect(() =\u003e {\n    async function fetchTodos() {\n      try {\n        const todos = await todoService.getTodos(); // TodoContext에서 TodoService를 호출하여 todos 가져오기\n        setTodos(todos);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    fetchTodos();\n  }, [todoService]);\n\n  return (\n    \u003cul\u003e\n      {todos.map(todo =\u003e (\n        \u003cli key={todo.id}\u003e{todo.title}\u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n}\n\nexport default TodoList;\n```\n\n\n\n이 코드에서는 useContext 훅을 사용하여 TodoContext에서 TodoService를 가져옵니다. 그런 다음 가져온 todoService를 사용하여 할 일을 불러옵니다.\n\nuseEffect 훅은 컴포넌트가 마운트될 때 할 일을 불러오는 데 사용됩니다. fetchTodos 함수는 가져온 todoService를 사용하여 할 일을 불러와서 그것들을 할 일 상태 변수에 설정합니다.\n\n이 컴포넌트를 사용하려면 먼저 TodoContext를 생성하고 해당 컴포넌트를 래핑해야 합니다. 다음과 같이:\n\n```js\nimport React from 'react';\nimport TodoContext from './TodoContext';\nimport TodoService from './TodoService';\nimport TodoList from './TodoList';\n\nfunction App() {\n  return (\n    \u003cTodoContext.Provider value={TodoService}\u003e\n      \u003cTodoList /\u003e\n    \u003c/TodoContext.Provider\u003e\n  );\n}\n\nexport default App;\n```\n\n\n\n이 예제에서는 TodoContext를 생성하고 TodoService를 해당 값으로 전달합니다. 그런 다음 TodoList 컴포넌트를 TodoContext.Provider 컴포넌트로 감싸서 useContext 훅을 사용하여 컨텍스트에서 TodoService를 검색할 수 있도록 합니다.\n\n## 의존성 주입과 제어 역전 컨테이너 (IoC)를 사용한 의존성 주입\n\n이러한 컨텍스트 개념을 사용하여 제어 역전 컨테이너를 이용해 한 발 더 나아갈 수 있습니다.\n\n기다려봐요, 제어 역전 컨테이너 (IoC)란 무엇인가요?\n\n\n\nReact에서 IoC (Inversion of Control) 컨테이너는 여러 컴포넌트와 서비스 사이의 의존성을 관리하는 도구입니다. 이 도구를 사용하면 한 번에 서비스 또는 객체 (의존성)를 정의하고 등록한 다음, 이를 의존하는 다른 컴포넌트에 주입할 수 있습니다. 이를 통해 컴포넌트를 분리하고 응용 프로그램을 모듈식으로 만들고 유지보수하기 쉽게 할 수 있습니다.\n\nReact의 IoC 컨테이너는 대개 모든 의존성으로 사용할 수 있는 모든 객체를 참조하는 중앙 레지스트리를 제공함으로써 작동합니다. 컴포넌트는 직접 생성하는 대신에 이 컨테이너에서 이러한 의존성을 요청할 수 있습니다. 이 접근 방식은 또한 대체 구현으로 의존성을 교체하거나 테스트를 위해 목객체로 대체하기 쉽게 합니다.\n\nReact용 여러 인기있는 IoC 컨테이너로는 InversifyJS, Awilix, BottleJS 등이 있으며, 생성자 주입, 속성 주입, 자동 의존성 해결 등과 같은 다양한 기능을 제공합니다. 일부 IoC 컨테이너는 다른 것보다 더 복잡할 수 있으므로 프로젝트의 요구 사항과 복잡성 수준에 적합한 것을 선택하는 것이 중요합니다.\n\n우리의 경우, 아래와 같이 처음부터 예제를 작성할 것입니다:\n\n\n\n```js\r\nimport React, { createContext, useContext } from 'react';\n\n// 컨테이너를 위한 새로운 컨텍스트를 생성합니다\nconst ContainerContext = createContext();\n\n// 컨테이너를 자식 컴포넌트에 제공하는 컴포넌트를 정의합니다\nconst ContainerProvider = ({ container, children }) =\u003e {\n  return \u003cContainerContext.Provider value={container}\u003e{children}\u003c/ContainerContext.Provider\u003e;\n};\n\n// 컴포넌트 내에서 컨테이너에 접근하기 위한 훅을 정의합니다\nconst useContainer = () =\u003e {\n  const container = useContext(ContainerContext);\n  if (!container) {\n    throw new Error('컨테이너를 찾을 수 없습니다. 컴포넌트를 ContainerProvider로 감싸는지 확인해주세요.');\n  }\n  return container;\n};\n\n// 컨테이너에서 의존성을 주입하는 훅을 정의합니다\nconst useInject = (identifier) =\u003e {\n  const container = useContainer();\n  return container.resolve(identifier);\n};\n\n// 예시 사용법:\nconst MyService = () =\u003e {\n  return { foo: 'bar' };\n};\n\nconst MyComponent = () =\u003e {\n  const myService = useInject('myService');\n  return \u003cdiv\u003e{myService.foo}\u003c/div\u003e; // 결과: 'bar'\n};\n\nconst container = {\n  registry: {\n    myService: MyService()\n  },\n  resolve(identifier) {\n    if (!this.registry.hasOwnProperty(identifier)) {\n      throw new Error(`식별자 ${identifier}로 식별되는 객체를 컨테이너에서 찾을 수 없습니다`);\n    }\n    return this.registry[identifier];\n  }\n};\n\nconst App = () =\u003e {\n  return (\n    \u003cContainerProvider container={container}\u003e\n      \u003cMyComponent /\u003e\n    \u003c/ContainerProvider\u003e\n  );\n};\r\n```\n\n이 예제에서는 컨테이너 오브젝트를 prop으로 전달받아 ContainerProvider 컴포넌트를 생성하여 ContainerContext 컨텍스트를 사용하여 자식에게 제공하는 방법을 보여줍니다. 그리고 컴포넌트 내에서 컨테이너를 검색하는 useContainer 훅을 정의합니다.\n\n그런 다음 MyService 객체를 정의하고 컨테이너 오브젝트의 레지스트리 속성에 추가합니다. 또한 컨테이너 오브젝트에 식별자를 입력받아 해당 객체를 검색하는 resolve 메소드를 정의합니다. 이 경우 resolve 메소드는 MyService 객체를 반환합니다.\n\nMyComponent를 ContainerProvider로 감싸고 컨테이너 오브젝트를 prop으로 전달한 후 MyComponent를 렌더하는 App 컴포넌트를 렌더합니다. MyComponent가 렌더되면 컨테이너에서 myService 의존성을 검색하고 화면에 해당하는 foo 속성을 렌더합니다.\n\n\n\n이 코드에서는 식별자를 매개변수로 전달받는 useInject 훅을 추가합니다. 이 훅은 컨테이너에서 해당 객체를 검색합니다. useInject 훅은 내부적으로 useContainer를 호출하여 컨테이너를 검색하고, 그런 다음 컨테이너에서 resolve 메서드를 호출하여 객체를 검색합니다.\n\n다음으로, useInject 훅을 사용하여 컨테이너에서 myService 의존성을 검색하고 그 foo 속성을 화면에 렌더링하는 MyComponent를 생성합니다.\n\n마지막으로, ContainerProvider로 랩핑된 MyComponent를 렌더링하는 App 컴포넌트를 렌더링합니다. MyComponent가 렌더링되면 useInject 훅을 사용하여 컨테이너에서 myService 의존성을 검색하고 해당 foo 속성을 화면에 렌더링합니다.\n\n요약하면, 의존성 주입은 더 유연하고 모듈식이며 쉽게 테스트할 수 있는 코드를 구현할 수 있는 디자인 패턴입니다. 이는 객체의 생성과 사용을 분리함으로써 컴포넌트 간의 의존성을 명시적으로 만들어 복잡한 의존성을 관리하기 쉽게 해줍니다.\n\n\n\n리액트에서는 종속성 주입을 프롭스로 서비스를 주입하거나 후크를 사용하여 컨테이너를 통해 컴포넌트에 종속성을 제공하여 구현할 수 있습니다. 이 방법을 사용하면 더 깔끔하고 유지보수가 쉬운 코드를 작성할 수 있으며 비즈니스 로직을 재사용하고 종속성을 관리하는 일이 더 쉬워집니다.\n\n이러한 패턴을 따르면 리액트 코드의 가독성, 유지보수성, 테스트 가능성이 향상될 수 있습니다.\n\n![이미지](/assets/img/2024-05-12-DependencyinjectioninReact_0.png)\n\n와우, 마지막까지 왔군요. 이 기사는 실험이었습니다. 아이디어는 저의 것이지만 텍스트, 다이어그램 및 코드는 ChatGpt가 완전히 작성했습니다.","ogImage":{"url":"/assets/img/2024-05-12-DependencyinjectioninReact_0.png"},"coverImage":"/assets/img/2024-05-12-DependencyinjectioninReact_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e리액트 컴포넌트에는 비즈니스 로직이 포함되어서는 안 된다고 생각하시나요? 만약 그렇다면 계속 읽어주세요. 아니라면 지금 멈추세요. 이 기사는 다른 사람을 위한 것입니다.\u003c/p\u003e\n\u003ch2\u003eTL; DR;\u003c/h2\u003e\n\u003cp\u003e리액트 프로젝트에 의존성 주입을 3단계로 추가해보세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e의존성을 넣을 \"컨테이너\"를 만드세요\u003c/li\u003e\n\u003cli\u003e의존성을 검색하는 hook useInject를 만드세요\u003c/li\u003e\n\u003cli\u003e컴포넌트에서 해당 훅을 사용하세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e상세 버전\u003c/h2\u003e\n\u003cp\u003e답안이 망설여진다면, 이유에 대해 몇 가지 통찰을 제공해 드리겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eReact는 사용자 인터페이스를 만들기 위한 라이브러리입니다; 이 정의를 통해 컴포넌트에 비즈니스 로직을 넣지 말아야 한다는 것을 알 수 있습니다.\u003c/li\u003e\n\u003cli\u003e비즈니스 로직을 포함하는 컴포넌트는 읽기, 유지 관리, 테스트하기 어렵습니다.\u003c/li\u003e\n\u003cli\u003e컴포넌트에서 비즈니스 로직을 추출하는 것은 재사용 가능한 좋은 아이디어입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그렇다면, 컴포넌트에서 비즈니스 로직을 분리하면 외부 클래스나 함수와 같은 곳에 쓰여져야 합니다. 어떻게 하면 될까요? 의존성 주입을 사용하여!\u003c/p\u003e\n\u003ch2\u003e의존성 주입이란 무엇이며 왜 사용해야 할까요\u003c/h2\u003e\n\u003cp\u003e의존성 주입(Dependency Injection, DI)은 객체 생성을 객체 사용과 분리하는 소프트웨어 디자인 패턴입니다. 실제로, 사용하는 코드 내에서 물건을 만들지 않고, 객체의 인스턴스화는 객체를 만들고 그것을 필요로 하는 구성 요소에 제공하는 외부 개체로 위임됩니다.\u003c/p\u003e\n\u003cp\u003e의존성 주입은 코드를 더 유연하고 모듈식으로 만들어주며, 쉽게 테스트할 수 있도록 합니다. 강하게 결합된 코드 대신, 모듈식 구성 요소를 제공하여 필요에 따라 코드를 변경하지 않고 쉽게 교체하거나 확장할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또한, DI는 코드의 가독성과 유지 보수성을 향상시키는 데 도움을 줍니다. 구성 요소 간의 의존성을 명시적으로 만들어 복잡한 의존성을 관리하는 것을 용이하게 합니다.\u003c/p\u003e\n\u003cp\u003e요약하자면, 의존성 주입은 다음과 같은 목적으로 사용됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e객체의 생성과 사용을 분리합니다.\u003c/li\u003e\n\u003cli\u003e코드를 더 유연하고 모듈화되며 쉽게 테스트할 수 있게 만듭니다.\u003c/li\u003e\n\u003cli\u003e코드의 가독성과 유지보수성을 향상시킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eReact에서 의존성 주입\u003c/h2\u003e\n\u003cp\u003eReact 애플리케이션을 개발해야 한다고 상상해봅시다. 할 일 목록을 관리하는 React 애플리케이션을 만들어보겠습니다. (얼마나 멋져요 😅)\u003c/p\u003e\n\u003cp\u003e할 일 목록을 표시하는 컴포넌트가 있습니다.\n컴포넌트가 렌더링될 때 목록을 API에서 로드하고 싶습니다. 그리고 컴포넌트에서 비즈니스 로직을 작성하지 않으려면 API 호출을 수행하는 서비스가 필요합니다. 아래 다이어그램에서 보여지는 것처럼요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e              \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e                  \u003cspan class=\"hljs-title class_\"\u003eService\u003c/span\u003e                       \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e\n                  |                          |                          |\n                  |                          |                          |\n                  |    데이터 요청           |                          |\n                  |-------------------------\u003e|                          |\n                  |                          |                          |\n                  |                          |  \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e에서 데이터 검색      |\n                  |                          |-------------------------\u003e|\n                  |                          |                          |\n                  |                          |    데이터 처리            |\n                  |                          |\u0026#x3C;-------------------------|\n                  |                          |                          |\n                  |  데이터 수신             |                          |\n                  |\u0026#x3C;-------------------------|                          |\n                  |                          |                          |\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 순서 다이어그램에서 컴포넌트는 메소드나 함수를 호출하여 서비스에 데이터 요청을 보냅니다. 그런 다음 서비스는 요청을 보내어 외부 API에서 데이터를 검색합니다. 데이터를 받은 후 서비스가 처리하고 컴포넌트로 반환합니다.\u003c/p\u003e\n\u003cp\u003e다이어그램에서 화살표로 표시되는 이벤트 시퀀스를 볼 수 있습니다. API에서 서비스로의 점선 화살표는 API에서 데이터를 검색하는 것을 나타내며, 서비스에서 컴포넌트로의 실선 화살표는 처리된 데이터를 컴포넌트로 반환하는 것을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e구현 수준에서 코드는 이렇게 보일 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState, useEffect } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodoService\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./TodoService'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTodoList\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [todos, setTodos] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e([]);\n\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchTodos\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e todos = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodoService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetTodos\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// TodoService를 호출하여 할 일 가져오기\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003esetTodos\u003c/span\u003e(todos);\n      } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(error);\n      }\n    }\n    \u003cspan class=\"hljs-title function_\"\u003efetchTodos\u003c/span\u003e();\n  }, []);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    - 목록\n      {todos.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003etodo\u003c/span\u003e =\u003e\u003c/span\u003e (\n        - 아이디: {todo.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e}, 제목: {todo.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e}\n      ))}\n    - \n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodoList\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드에서는 TodoService에서 getTodos 메서드를 호출하는 TodoList 컴포넌트를 정의합니다. useState 훅을 사용하여 서비스에서 반환된 할 일을 추적하고, useEffect 훅을 사용하여 컴포넌트가 마운트될 때 할 일을 가져옵니다.\u003c/p\u003e\n\u003cp\u003efetchTodos 함수가 호출될 때 await 키워드를 사용하여 getTodos 메서드가 할 일을 반환할 때까지 기다리며, 할 일이 반환되면 setTodos 함수를 사용하여 todos 상태 변수에 할 일을 설정합니다.\u003c/p\u003e\n\u003cp\u003e마침내, map 함수를 사용하여 할 일 목록을 렌더링하고 각 할 일의 제목을 표시합니다. 이것은 간소화된 예제이며 TodoService의 구현은 사용된 API에 따라 달라질 수 있습니다.\u003c/p\u003e\n\u003ch2\u003eprops를 사용한 의존성 주입\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState, useEffect } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTodoList\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ todoService }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [todos, setTodos] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e([]);\n\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchTodos\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e todos = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e todoService.\u003cspan class=\"hljs-title function_\"\u003egetTodos\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 주입된 TodoService를 호출하여 할 일을 가져옴\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003esetTodos\u003c/span\u003e(todos);\n      } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(error);\n      }\n    }\n    \u003cspan class=\"hljs-title function_\"\u003efetchTodos\u003c/span\u003e();\n  }, [todoService]);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    - 목록\n      {todos.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003etodo\u003c/span\u003e =\u003e\u003c/span\u003e (\n        - 고유 키{todo.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e}{todo.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e}\n      ))}\n    - 목록 종료\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodoList\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 업데이트된 코드에서는 TodoService를 TodoList 구성 요소의 prop으로 주입합니다. 구성 요소는 더 이상 TodoService를 직접 가져오지 않고 주입된 서비스를 사용하여 할 일을 가져옵니다.\u003c/p\u003e\n\u003cp\u003e컴포넌트가 마운트될 때 fetchTodos 함수는 주입된 todoService를 사용하여 할 일을 검색합니다. 이렇게 함으로써 TodoService의 구현을 손쉽게 교체할 수 있습니다. 다른 서비스 구현체를 TodoList 컴포넌트에 전달하여 TodoService의 특정 구현체를 사용하려면 다음과 같이 서비스를 prop으로 전달합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodoService\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./TodoService'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodoList\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./TodoList'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eTodoList\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etodoService\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{TodoService}\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTodoService를 TodoList 컴포넌트에 prop으로 전달함으로써 TodoService의 특정 구현체를 사용할 수 있습니다. TodoList 컴포넌트를 수정하지 않고 TodoService의 다른 구현체간 쉽게 전환이 가능해지므로, 보다 모듈식이고 유연한 디자인을 구현할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 내용은 Component에 대한 테스트를 작성할 때 매우 유용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e여기서 우리가 해결해야 할 두 가지 문제가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e우리는 아직도 의존성 주입을 사용하지 않는 App Component에 TodoService를 가져와야 합니다.\u003c/li\u003e\n\u003cli\u003eProps는 응용 프로그램 전체에서 데이터를 전달하는 효과적인 방법 중 하나일 뿐이며, 중첩 레이어와만 잘 작동합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e              부모 \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e\n                         |\n                         \u003cspan class=\"hljs-title class_\"\u003eSubComponent\u003c/span\u003e A로 \u003cspan class=\"hljs-title class_\"\u003eProp\u003c/span\u003e 전달\n                         |\n                         |-\u003cspan class=\"hljs-title class_\"\u003eSubComponent\u003c/span\u003e A\n                         |\n                         |\n                         \u003cspan class=\"hljs-title class_\"\u003eSubComponent\u003c/span\u003e B로 \u003cspan class=\"hljs-title class_\"\u003eProp\u003c/span\u003e 전달\n                         |\n                         |\n                         |--\u003cspan class=\"hljs-title class_\"\u003eSubComponent\u003c/span\u003e B\n                         |\n                         |\n                         \u003cspan class=\"hljs-title class_\"\u003eSubComponent\u003c/span\u003e C로 \u003cspan class=\"hljs-title class_\"\u003eProp\u003c/span\u003e 전달\n                         |\n                         |\n                         |---\u003cspan class=\"hljs-title class_\"\u003eSubComponent\u003c/span\u003e C\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 다이어그램은 프롭스가 컴포넌트의 계층 구조를 통해 전달되는 방법을 보여줍니다. 컴포넌트가 더 들여쓰여 있을수록 컴포넌트 트리에서 더 깊게 중첩됩니다. 이 중첩을 원치 않아요. 😨\u003c/p\u003e\n\u003ch2\u003eReact Context를 사용한 의존성 주입\u003c/h2\u003e\n\u003cp\u003e다음은 TodoContext를 사용하여 컴포넌트에서 TodoService를 호출하는 React 코드의 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState, useEffect, useContext } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodoContext\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./TodoContext'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTodoList\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [todos, setTodos] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e([]);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e todoService = \u003cspan class=\"hljs-title function_\"\u003euseContext\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTodoContext\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// TodoContext에서 TodoService를 가져옴\u003c/span\u003e\n\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchTodos\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e todos = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e todoService.\u003cspan class=\"hljs-title function_\"\u003egetTodos\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// TodoContext에서 TodoService를 호출하여 todos 가져오기\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003esetTodos\u003c/span\u003e(todos);\n      } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(error);\n      }\n    }\n    \u003cspan class=\"hljs-title function_\"\u003efetchTodos\u003c/span\u003e();\n  }, [todoService]);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\n      {todos.map(todo =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{todo.id}\u003c/span\u003e\u003e\u003c/span\u003e{todo.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\n      ))}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodoList\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드에서는 useContext 훅을 사용하여 TodoContext에서 TodoService를 가져옵니다. 그런 다음 가져온 todoService를 사용하여 할 일을 불러옵니다.\u003c/p\u003e\n\u003cp\u003euseEffect 훅은 컴포넌트가 마운트될 때 할 일을 불러오는 데 사용됩니다. fetchTodos 함수는 가져온 todoService를 사용하여 할 일을 불러와서 그것들을 할 일 상태 변수에 설정합니다.\u003c/p\u003e\n\u003cp\u003e이 컴포넌트를 사용하려면 먼저 TodoContext를 생성하고 해당 컴포넌트를 래핑해야 합니다. 다음과 같이:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodoContext\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./TodoContext'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodoService\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./TodoService'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTodoList\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./TodoList'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eTodoContext.Provider\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{TodoService}\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eTodoList\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eTodoContext.Provider\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 TodoContext를 생성하고 TodoService를 해당 값으로 전달합니다. 그런 다음 TodoList 컴포넌트를 TodoContext.Provider 컴포넌트로 감싸서 useContext 훅을 사용하여 컨텍스트에서 TodoService를 검색할 수 있도록 합니다.\u003c/p\u003e\n\u003ch2\u003e의존성 주입과 제어 역전 컨테이너 (IoC)를 사용한 의존성 주입\u003c/h2\u003e\n\u003cp\u003e이러한 컨텍스트 개념을 사용하여 제어 역전 컨테이너를 이용해 한 발 더 나아갈 수 있습니다.\u003c/p\u003e\n\u003cp\u003e기다려봐요, 제어 역전 컨테이너 (IoC)란 무엇인가요?\u003c/p\u003e\n\u003cp\u003eReact에서 IoC (Inversion of Control) 컨테이너는 여러 컴포넌트와 서비스 사이의 의존성을 관리하는 도구입니다. 이 도구를 사용하면 한 번에 서비스 또는 객체 (의존성)를 정의하고 등록한 다음, 이를 의존하는 다른 컴포넌트에 주입할 수 있습니다. 이를 통해 컴포넌트를 분리하고 응용 프로그램을 모듈식으로 만들고 유지보수하기 쉽게 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eReact의 IoC 컨테이너는 대개 모든 의존성으로 사용할 수 있는 모든 객체를 참조하는 중앙 레지스트리를 제공함으로써 작동합니다. 컴포넌트는 직접 생성하는 대신에 이 컨테이너에서 이러한 의존성을 요청할 수 있습니다. 이 접근 방식은 또한 대체 구현으로 의존성을 교체하거나 테스트를 위해 목객체로 대체하기 쉽게 합니다.\u003c/p\u003e\n\u003cp\u003eReact용 여러 인기있는 IoC 컨테이너로는 InversifyJS, Awilix, BottleJS 등이 있으며, 생성자 주입, 속성 주입, 자동 의존성 해결 등과 같은 다양한 기능을 제공합니다. 일부 IoC 컨테이너는 다른 것보다 더 복잡할 수 있으므로 프로젝트의 요구 사항과 복잡성 수준에 적합한 것을 선택하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e우리의 경우, 아래와 같이 처음부터 예제를 작성할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { createContext, useContext } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 컨테이너를 위한 새로운 컨텍스트를 생성합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eContainerContext\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ecreateContext\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 컨테이너를 자식 컴포넌트에 제공하는 컴포넌트를 정의합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eContainerProvider\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ container, children }\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eContainerContext.Provider\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{container}\u003c/span\u003e\u003e\u003c/span\u003e{children}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eContainerContext.Provider\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// 컴포넌트 내에서 컨테이너에 접근하기 위한 훅을 정의합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003euseContainer\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = \u003cspan class=\"hljs-title function_\"\u003euseContext\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eContainerContext\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!container) {\n    \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'컨테이너를 찾을 수 없습니다. 컴포넌트를 ContainerProvider로 감싸는지 확인해주세요.'\u003c/span\u003e);\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e container;\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// 컨테이너에서 의존성을 주입하는 훅을 정의합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003euseInject\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eidentifier\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = \u003cspan class=\"hljs-title function_\"\u003euseContainer\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e container.\u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(identifier);\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// 예시 사용법:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyService\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e { \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'bar'\u003c/span\u003e };\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyComponent\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myService = \u003cspan class=\"hljs-title function_\"\u003euseInject\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'myService'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e{myService.foo}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 결과: 'bar'\u003c/span\u003e\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = {\n  \u003cspan class=\"hljs-attr\"\u003eregistry\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003emyService\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMyService\u003c/span\u003e()\n  },\n  \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eidentifier\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eregistry\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasOwnProperty\u003c/span\u003e(identifier)) {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`식별자 \u003cspan class=\"hljs-subst\"\u003e${identifier}\u003c/span\u003e로 식별되는 객체를 컨테이너에서 찾을 수 없습니다`\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eregistry\u003c/span\u003e[identifier];\n  }\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eContainerProvider\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtainer\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{container}\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMyComponent\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eContainerProvider\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 컨테이너 오브젝트를 prop으로 전달받아 ContainerProvider 컴포넌트를 생성하여 ContainerContext 컨텍스트를 사용하여 자식에게 제공하는 방법을 보여줍니다. 그리고 컴포넌트 내에서 컨테이너를 검색하는 useContainer 훅을 정의합니다.\u003c/p\u003e\n\u003cp\u003e그런 다음 MyService 객체를 정의하고 컨테이너 오브젝트의 레지스트리 속성에 추가합니다. 또한 컨테이너 오브젝트에 식별자를 입력받아 해당 객체를 검색하는 resolve 메소드를 정의합니다. 이 경우 resolve 메소드는 MyService 객체를 반환합니다.\u003c/p\u003e\n\u003cp\u003eMyComponent를 ContainerProvider로 감싸고 컨테이너 오브젝트를 prop으로 전달한 후 MyComponent를 렌더하는 App 컴포넌트를 렌더합니다. MyComponent가 렌더되면 컨테이너에서 myService 의존성을 검색하고 화면에 해당하는 foo 속성을 렌더합니다.\u003c/p\u003e\n\u003cp\u003e이 코드에서는 식별자를 매개변수로 전달받는 useInject 훅을 추가합니다. 이 훅은 컨테이너에서 해당 객체를 검색합니다. useInject 훅은 내부적으로 useContainer를 호출하여 컨테이너를 검색하고, 그런 다음 컨테이너에서 resolve 메서드를 호출하여 객체를 검색합니다.\u003c/p\u003e\n\u003cp\u003e다음으로, useInject 훅을 사용하여 컨테이너에서 myService 의존성을 검색하고 그 foo 속성을 화면에 렌더링하는 MyComponent를 생성합니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, ContainerProvider로 랩핑된 MyComponent를 렌더링하는 App 컴포넌트를 렌더링합니다. MyComponent가 렌더링되면 useInject 훅을 사용하여 컨테이너에서 myService 의존성을 검색하고 해당 foo 속성을 화면에 렌더링합니다.\u003c/p\u003e\n\u003cp\u003e요약하면, 의존성 주입은 더 유연하고 모듈식이며 쉽게 테스트할 수 있는 코드를 구현할 수 있는 디자인 패턴입니다. 이는 객체의 생성과 사용을 분리함으로써 컴포넌트 간의 의존성을 명시적으로 만들어 복잡한 의존성을 관리하기 쉽게 해줍니다.\u003c/p\u003e\n\u003cp\u003e리액트에서는 종속성 주입을 프롭스로 서비스를 주입하거나 후크를 사용하여 컨테이너를 통해 컴포넌트에 종속성을 제공하여 구현할 수 있습니다. 이 방법을 사용하면 더 깔끔하고 유지보수가 쉬운 코드를 작성할 수 있으며 비즈니스 로직을 재사용하고 종속성을 관리하는 일이 더 쉬워집니다.\u003c/p\u003e\n\u003cp\u003e이러한 패턴을 따르면 리액트 코드의 가독성, 유지보수성, 테스트 가능성이 향상될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-DependencyinjectioninReact_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e와우, 마지막까지 왔군요. 이 기사는 실험이었습니다. 아이디어는 저의 것이지만 텍스트, 다이어그램 및 코드는 ChatGpt가 완전히 작성했습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-DependencyinjectioninReact"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>