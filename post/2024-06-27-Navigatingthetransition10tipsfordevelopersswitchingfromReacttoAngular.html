<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>React에서 Angular로 전환하는 개발자를 위한 10가지 팁 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="React에서 Angular로 전환하는 개발자를 위한 10가지 팁 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="React에서 Angular로 전환하는 개발자를 위한 10가지 팁 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular" data-gatsby-head="true"/><meta name="twitter:title" content="React에서 Angular로 전환하는 개발자를 위한 10가지 팁 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-27 17:59" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">React에서 Angular로 전환하는 개발자를 위한 10가지 팁</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="React에서 Angular로 전환하는 개발자를 위한 10가지 팁" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 27, 2024</span><span class="posts_reading_time__f7YPP">14<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular_0.png" alt="이미지"></p>
<p>React에서 Angular로 전환하는 것은 개발자들에게 도전적이면서 보상이 있는 여정일 수 있습니다. 각 프레임워크마다 고유한 원칙, 구문 및 관습이 있어 전환 과정은 신중히 진행되어야 합니다.</p>
<p>Fever에서는 특정 언어나 프레임워크의 경험보다는 기술에 기반하여 최고 수준의 엔지니어를 채용하기를 우선시합니다. 따라서, React에서 Angular로의 전환은 우리 엔지니어들에게 일상적인 일입니다.</p>
<p>본 글에서는 React에서 Angular로의 개발자 전환을 원활히 돕기 위해 우리에게 유용했던 10가지 팁을 살펴보겠습니다.</p>
<div class="content-ad"></div>
<h2>팁 01: ngIf 구조 지시문 사용하기</h2>
<p>● React에서는 조건부 렌더링을 사용하여 컴포넌트나 요소를 렌더링할지 여부를 결정할 수 있습니다. 다음은 이를 구현한 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">ConditionalComponent</span> = (<span class="hljs-params">{ shouldRender }</span>) => {
  <span class="hljs-keyword">return</span> shouldRender ? <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>조건에 따라 렌더링됩니다<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span> : <span class="hljs-literal">null</span>;
};
</code></pre>
<p>● Angular에서는 템플릿에서 *ngIf 구조 지시문을 사용하여 요소를 조건부로 렌더링하는 것이 일반적합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">&#x3C;ng-container *ngIf=<span class="hljs-string">"shouldRender"</span>>
  <span class="hljs-title class_">This</span> is rendered conditionally
&#x3C;/ng-container>
</code></pre>
<p>*Angular v17 will have a new built-in control flow template syntax for if block conditionals</p>
<h2>Tip 02: Using ngFor structural directive</h2>
<ul>
<li>In React, you use the map function to iterate over an array and create a list of elements.</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">ListComponent</span> = (<span class="hljs-params">{ items }</span>) => {
  <span class="hljs-keyword">return</span> (
    - 목록
      - {items.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =></span> (
        - <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>></span>
          - {index + 1}. {item.name}
      - ))}
  );
};
</span></code></pre>
<ul>
<li>Angular에서는 *ngFor 구조 지시자를 사용하여 템플릿에서 요소를 반복할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js">- 목록
    - <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of items; let i = index"</span>></span>
        { i + 1 }. { item.name }
    - <span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span></span>
</code></pre>
<ul>
<li>Angular v17에서는 블록 반복기를 위한 새로운 내장 제어 흐름 템플릿 구문이 제공될 것입니다.</li>
</ul>
<div class="content-ad"></div>
<h2>팁 03: TrackByFunction을 사용하여 목록 렌더링 개선하기:</h2>
<p>● React에서 요소 목록을 렌더링할 때는 각 요소에 고유한 key 속성을 할당해야 합니다. 이를 통해 React가 각 요소를 고유하게 식별하고 효율적으로 DOM을 업데이트할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">ListComponent</span> = (<span class="hljs-params">{ items }</span>) => {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>
      {items.map((item, index) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>></span>
          {index + 1}. {item.name}
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ul</span>></span></span>
  );
};
</code></pre>
<p>● Angular에서는 trackBy 함수를 사용하여 동일한 결과를 얻을 수 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

interface <span class="hljs-title class_">ListItem</span> {
  <span class="hljs-attr">id</span>: number;
  <span class="hljs-attr">name</span>: string;
}

@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-list'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &#x3C;ul>
      &#x3C;li *ngFor="let item of items; trackBy: trackByFn">
        { item.id } - { item.name }
      &#x3C;/li>
    &#x3C;/ul>
  `</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListComponent</span> {
  <span class="hljs-attr">items</span>: <span class="hljs-title class_">Array</span>&#x3C;<span class="hljs-title class_">ListItem</span>> = [ 
    { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Item 1'</span> }, 
    { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Item 2'</span> }
  ];

  <span class="hljs-title function_">trackByFn</span>(<span class="hljs-attr">index</span>: number, <span class="hljs-attr">item</span>: <span class="hljs-title class_">ListItem</span>): number {
    <span class="hljs-keyword">return</span> item.<span class="hljs-property">id</span>; <span class="hljs-comment">// Return a unique identifier for each item</span>
  }
}
</code></pre>
<h2>팁 04: 프로퍼티 바인딩</h2>
<p>● React에서는 데이터가 부모 구성 요소에서 자식 구성 요소로 props로 전달됩니다. 자식 구성 요소는 이러한 props을 받아 렌더링에 사용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">ImageComponent</span> = (<span class="hljs-params">{ imageUrl }</span>) => {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{imageUrl}</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"React Image"</span> /></span></span>;
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ImageComponent</span>;
</code></pre>
<div class="content-ad"></div>
<p>안녕하세요! 다음은 Angular에서 속성 바인딩을 사용하는 방법입니다. 속성 바인딩은 컴포넌트의 속성을 HTML 요소 속성이나 디렉티브에 바인딩하는 데 사용됩니다.</p>
<pre><code class="hljs language-js">&#x3C;img [src]=<span class="hljs-string">"imageUrl"</span> alt=<span class="hljs-string">"Angular Image"</span> />
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-example'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">'&#x3C;img [src]="imageUrl" alt="Angular Image" />'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleComponent</span> {
  @<span class="hljs-title class_">Input</span>() <span class="hljs-attr">imageUrl</span>: string;
}
</code></pre>
<h2>팁 05: 이벤트 바인딩</h2>
<div class="content-ad"></div>
<p>● React에서는 콜백 함수를 전달하기 위해 props를 사용하여 동일한 기능을 구현할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">ChildComponent</span> = (<span class="hljs-params">{ onCustomEvent }</span>) => (
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onCustomEvent}</span>></span>Click me<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> [message, setMessage] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleCustomEvent</span> = (<span class="hljs-params"></span>) => {...};

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">onCustomEvent</span>=<span class="hljs-string">{handleCustomEvent}</span> /></span></span>
  );
};
</code></pre>
<p>● Angular에서는 이벤트 바인딩을 통해 사용자 작업 (키 입력, 마우스 이동, 클릭, 터치 등)을 감지하고 대응할 수 있습니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-child'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &#x3C;button (click)="doSomething()">Click me&#x3C;/button>
  `</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildComponent</span> {
  <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) {...}
}
</code></pre>
<div class="content-ad"></div>
<p>만일 자료를 부모 컴포넌트로 전달하고 싶다면, 자식 컴포넌트에서 @Output() 데코레이터를 사용할 수 있어요. 이 데코레이터가 있는 속성은 EventEmitter 유형이어야하며, 사용자 정의 이벤트를 발생시킬 때 사용돼요.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-child'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &#x3C;button (click)="customEvent.emit()">Click me&#x3C;/button>
  `</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildComponent</span> {
  @<span class="hljs-title class_">Output</span>() <span class="hljs-attr">customEvent</span>: <span class="hljs-title class_">EventEmitter</span>&#x3C;<span class="hljs-keyword">void</span>> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>&#x3C;<span class="hljs-keyword">void</span>>();
}

@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&#x3C;app-child (customEvent)="handleCustomEvent()">&#x3C;/app-child>`</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppComponent</span> {
  <span class="hljs-title function_">handleCustomEvent</span>(): <span class="hljs-keyword">void</span> {...}
}
</code></pre>
<h2>팁 06: 의존성 주입</h2>
<p>● React에서 의존성 주입을 관리하는 일반적인 방법 몇 가지가 있어요:</p>
<div class="content-ad"></div>
<ul>
<li>Props</li>
<li>Context API</li>
<li>Higher-Order Components (HOCs)</li>
<li>Render Props</li>
<li>React Hooks</li>
</ul>
<p>● Angular에서는 의존성 주입이 프레임워크의 핵심 부분입니다. Angular는 서비스의 인스턴스를 생성하고 관리하는 역할을 담당하는 인젝터를 제공합니다. 간단한 예시를 확인해보세요:</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Injectable</span>({
  <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> {
  <span class="hljs-title function_">getData</span>(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Angular 서비스로부터의 데이터'</span>;
  }
}

@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`&#x3C;p>{ message }&#x3C;/p>`</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppComponent</span> implements <span class="hljs-title class_">OnInit</span> {
  <span class="hljs-attr">message</span>: string;
  private readonly myService = <span class="hljs-title function_">inject</span>(<span class="hljs-title class_">MyService</span>);

  <span class="hljs-title function_">ngOnInit</span>(): <span class="hljs-keyword">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">myService</span>.<span class="hljs-title function_">getData</span>();
  }
}
</code></pre>
<h2>팁 07: 리졸버</h2>
<div class="content-ad"></div>
<p>React에는 Angular의 resolver 기능과 직접적인 동등물이 없습니다. 데이터 가져오기는 보통 컴포넌트 자체 내에서 또는 라이프사이클 메서드, 훅, 또는 외부 라이브러리의 도움으로 처리됩니다. React 컴포넌트에서 사용자 정의 훅을 사용한 간단한 예제가 여기 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">useCustomHook</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) => {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data'</span>);
        <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
        <span class="hljs-title function_">setData</span>(result);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error fetching data:'</span>, error);
      }
    };
    <span class="hljs-title function_">fetchData</span>();
  }, []); <span class="hljs-comment">// 의존성 배열이 비어있어서 효과가 마운트시 한 번만 실행됨</span>
  <span class="hljs-keyword">return</span> data;
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> { data } = <span class="hljs-title function_">useCustomHook</span>();
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      {data ? (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Data from React component: {data}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
      ) : (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Loading...<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
      )}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyComponent</span>;
</code></pre>
<p>Angular에서는 resolver를 사용하여 라우트가 활성화되기 전 데이터를 가져와 해당 컴포넌트가 렌더링되기 전에 필요한 데이터를 보장합니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Injectable</span>({
  <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDataResolver</span> implements <span class="hljs-title class_">Resolve</span>&#x3C;string> {
  private readonly myDataService = <span class="hljs-title function_">inject</span>(<span class="hljs-title class_">MyDataService</span>);

  <span class="hljs-title function_">resolve</span>(): <span class="hljs-title class_">Observable</span>&#x3C;string> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">myDataService</span>.<span class="hljs-title function_">fetchData</span>();
  }
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">Routes</span> = [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'my-route'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">MyComponent</span>,
    <span class="hljs-attr">resolve</span>: {
      <span class="hljs-attr">myData</span>: <span class="hljs-title class_">MyDataResolver</span>,
    },
  },
];

@<span class="hljs-title class_">NgModule</span>({
  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">RouterModule</span>.<span class="hljs-title function_">forRoot</span>(routes)],
  <span class="hljs-attr">exports</span>: [<span class="hljs-title class_">RouterModule</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppRoutingModule</span> {}
</code></pre>
<div class="content-ad"></div>
<h2>팁 08: 인터셉터</h2>
<p>● React에서는 Redux와 같은 상태 관리 미들웨어를 통해 HTTP 인터셉터 기능을 구현할 수 있습니다. 미들웨어는 액션이 리듀서에 도달하기 전에 해당 액션을 가로챌 수 있고 수정하거나 새로운 액션을 디스패치하거나 비동기 작업을 수행할 수 있습니다. Redux 미들웨어를 사용한 간단한 예시를 살펴보겠습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">myMiddleware</span> = (<span class="hljs-params">store</span>) => <span class="hljs-function">(<span class="hljs-params">next</span>) =></span> <span class="hljs-function">(<span class="hljs-params">action</span>) =></span> {
  <span class="hljs-comment">// 액션 수정 또는 다른 작업 수행</span>

  <span class="hljs-comment">// 예를 들어, 액션이 리듀서에 도달하기 전에 액션을 로깅하는 경우</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Action:'</span>, action);

  <span class="hljs-comment">// 다음 미들웨어나 리듀서에 액션 전달</span>
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>(action);
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> myMiddleware;
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(rootReducer, <span class="hljs-title function_">applyMiddleware</span>(myMiddleware));

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;
</code></pre>
<div class="content-ad"></div>
<p>● Angular에서 인터셉터는 HttpClient와 등록하여 HTTP 요청이나 응답을 가로챌 수 있는 서비스입니다. React의 미들웨어와는 달리 내장된 HTTPClient에만 작동합니다.</p>
<p>인터셉터를 사용하면 모든 HTTP 요청이나 응답에 전역적으로 공통 동작이나 수정을 적용할 수 있습니다. 아래는 간단한 Angular 인터셉터 예제입니다:</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> implements <span class="hljs-title class_">HttpInterceptor</span> {
  <span class="hljs-title function_">intercept</span>(
    <span class="hljs-attr">request</span>: <span class="hljs-title class_">HttpRequest</span>&#x3C;any>,
    <span class="hljs-attr">next</span>: <span class="hljs-title class_">HttpHandler</span>
  ): <span class="hljs-title class_">Observable</span>&#x3C;<span class="hljs-title class_">HttpEvent</span>&#x3C;any>> {
    <span class="hljs-comment">// 요청을 수정하거나 응답을 전역적으로 처리합니다</span>

    <span class="hljs-comment">// 예를 들어, 각 요청에 사용자 지정 헤더 추가</span>
    <span class="hljs-keyword">const</span> modifiedRequest = request.<span class="hljs-title function_">clone</span>({
      <span class="hljs-attr">setHeaders</span>: { <span class="hljs-string">'X-Custom-Header'</span>: <span class="hljs-string">'Custom Value'</span> },
    });

    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>(modifiedRequest);
  }
}

@<span class="hljs-title class_">NgModule</span>({
  <span class="hljs-attr">declarations</span>: [<span class="hljs-title class_">AppComponent</span>],
  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">BrowserModule</span>, <span class="hljs-title class_">HttpClientModule</span>],
  <span class="hljs-attr">providers</span>: [
    {
      <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">HTTP_INTERCEPTORS</span>,
      <span class="hljs-attr">useClass</span>: <span class="hljs-title class_">MyInterceptor</span>,
      <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>,
    },
  ],
  <span class="hljs-attr">bootstrap</span>: [<span class="hljs-title class_">AppComponent</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> {}
</code></pre>
<h2>팁 09: Rxjs</h2>
<div class="content-ad"></div>
<p>RxJS 라이브러리는 비동기 및 이벤트 기반 프로그래밍을 더 선언적이고 조립 가능한 방식으로 처리할 수 있는 도구 세트를 제공합니다. Angular에서 널리 사용됩니다. 간단히 설명하면 다음과 같습니다:</p>
<p>Observables:</p>
<ul>
<li>Observable은 시간에 따른 데이터 스트림의 표현입니다.</li>
<li>비동기적으로 여러 값을 방출할 수 있습니다.</li>
<li>Observables는 이벤트, 프로미스 또는 수동으로 생성할 수 있는 다양한 소스에서 만들어질 수 있습니다.</li>
</ul>
<p>Observers:</p>
<div class="content-ad"></div>
<ul>
<li>Observer는 Observable에 가입하여 Observable이 방출한 변경 사항이나 새 값에 대한 알림을 받습니다.</li>
<li>Observer에는 next(다음 값 처리), error(오류 처리), complete(작업 완료 처리)와 같이 세 가지 콜백 함수가 있습니다.</li>
</ul>
<p>주요 RxJS 연산자:</p>
<ul>
<li>map: 제공된 함수를 사용하여 Observable이 방출한 값을 변환합니다.</li>
<li>filter: 주어진 조건에 따라 Observable이 방출한 값을 필터링합니다.</li>
<li>mergeMap: 각 소스 값을 Observable로 프로젝트하고 결과 Observable을 하나의 Observable 스트림으로 병합합니다.</li>
<li>combineLatest: 여러 Observables에서 최신 값들을 합쳐 하나의 Observable로 조합합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-comment">// 버튼 클릭에서 Observable 생성</span>
    <span class="hljs-keyword">const</span> buttonClick$ = <span class="hljs-title function_">fromEvent</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'myButton'</span>), <span class="hljs-string">'click'</span>);

    <span class="hljs-comment">// 각 클릭 이벤트를 처리하고 API 호출을 트리거하는 mergeMap 사용</span>
    <span class="hljs-keyword">const</span> apiCall$ = buttonClick$.<span class="hljs-title function_">pipe</span>(
      <span class="hljs-title function_">mergeMap</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data'</span>)),
      <span class="hljs-title function_">mergeMap</span>(<span class="hljs-function"><span class="hljs-params">response</span> =></span> response.<span class="hljs-title function_">json</span>())
    );

    <span class="hljs-comment">// API 응답에서 원하는 특정 데이터를 추출하기 위해 map을 사용</span>
    <span class="hljs-keyword">const</span> subscription = apiCall$.<span class="hljs-title function_">subscribe</span>(
      <span class="hljs-function"><span class="hljs-params">responseData</span> =></span> <span class="hljs-title function_">setData</span>(responseData.<span class="hljs-property">data</span>),
      <span class="hljs-function"><span class="hljs-params">error</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'오류:'</span>, error)
    );

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> subscription.<span class="hljs-title function_">unsubscribe</span>(); <span class="hljs-comment">// 컴포넌트 해제 시 정리</span>
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"myButton"</span>></span>클릭하세요<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{data}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<div class="content-ad"></div>
<p>여기서 연산자의 전체 리스트를 확인할 수 있습니다: <a href="https://rxjs.dev/guide/operators#categories-of-operators" rel="nofollow" target="_blank">Operators List</a>.</p>
<h2>팁 10: Rxjs 구독 취소 시점</h2>
<p>Angular에서 메모리 누수를 방지하기 위해 옵저버블의 구독을 해제하는 것이 중요합니다. 옵저버블을 구독하면 옵저버와 옵저버블 사이에 연결이 생성되는데, 이 연결은 더 이상 필요하지 않을 때 닫혀야 합니다. 구독을 해제하지 않으면 잔류 참조와 메모리 누수로 이어질 수 있습니다.</p>
<p>Angular에서 구독을 취소해야 하는 일반적인 시나리오 몇 가지를 살펴보겠습니다:</p>
<div class="content-ad"></div>
<ul>
<li>컴포넌트 파괴:</li>
</ul>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-my-component'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> implements <span class="hljs-title class_">OnInit</span>, <span class="hljs-title class_">OnDestroy</span> {
  private <span class="hljs-attr">subscription</span>: <span class="hljs-title class_">Subscription</span>;

  <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscription</span> = someObservable.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">data</span> =></span> {
      <span class="hljs-comment">// 데이터 처리</span>
    });
  }

  <span class="hljs-title function_">ngOnDestroy</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscription</span>.<span class="hljs-title function_">unsubscribe</span>();
  }
}
</code></pre>
<ol start="2">
<li>무한 옵저버블:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> implements <span class="hljs-title class_">OnInit</span>, <span class="hljs-title class_">OnDestroy</span> {
  private <span class="hljs-attr">subscription</span>: <span class="hljs-title class_">Subscription</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private infiniteObservableService: InfiniteObservableService</span>) {}

  <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscription</span> = <span class="hljs-title function_">interval</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">pipe</span>(
      <span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =></span> {
        <span class="hljs-comment">// 필요에 따라 발행된 값 변환</span>
        <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;
      })
      .<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">infiniteData</span> = data;
      });
  }

  <span class="hljs-title function_">ngOnDestroy</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscription</span>.<span class="hljs-title function_">unsubscribe</span>();
  }
}
</code></pre>
<div class="content-ad"></div>
<ol start="3">
<li>라우터 이벤트:</li>
</ol>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-my-component'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> implements <span class="hljs-title class_">OnDestroy</span>, <span class="hljs-title class_">OnInit</span> {
  private <span class="hljs-attr">subscription</span>: <span class="hljs-title class_">Subscription</span>;
  private router = <span class="hljs-title function_">inject</span>(<span class="hljs-title class_">Router</span>);

  <span class="hljs-title function_">ngOnInit</span>(): <span class="hljs-keyword">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscription</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">events</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">event</span> =></span> {...});
  }

  <span class="hljs-title function_">ngOnDestroy</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscription</span>.<span class="hljs-title function_">unsubscribe</span>();
  }
}
</code></pre>
<ol start="4">
<li>AsyncPipe</li>
</ol>
<p>Angular에서 async 파이프는 Observable에 대한 구독을 자동화하고 구성 요소가 파기될 때 구독 해제를 처리합니다. 이는 템플릿에서 비동기 데이터를 다루는 과정을 간소화합니다.</p>
<div class="content-ad"></div>
<p><code>async</code> 파이프를 활용하면 Angular 템플릿에서 Observable에 직접 구독하고 값을 끊임없이 바인딩할 수 있습니다:</p>
<pre><code class="hljs language-js">&#x3C;div>{ observable$ | <span class="hljs-keyword">async</span> }&#x3C;/div>
</code></pre>
<p>실제로는 async 파이프가 구독 및 구독 해제 수명주기를 관리해주므며, 깔끔한 자원 관리를 보장하고 메모리 누수를 방지합니다.</p>
<ul>
<li>Angular에는 고유한 용어가 있습니다. 익숙하지 않다면 Angular 용어집이 유용할 것입니다: Angular 용어집.</li>
</ul>
<div class="content-ad"></div>
<h1>영감을 받은 곳:</h1>
<p><a href="https://netbasal.com/when-to-unsubscribe-in-angular-d61c6b21bad3" rel="nofollow" target="_blank">https://netbasal.com/when-to-unsubscribe-in-angular-d61c6b21bad3</a></p>
<p><a href="https://dev.to/yashjsalian/switching-to-angular-after-working-with-react-5bam" rel="nofollow" target="_blank">https://dev.to/yashjsalian/switching-to-angular-after-working-with-react-5bam</a></p>
<h1>참고:</h1>
<div class="content-ad"></div>
<p><a href="https://angular.io/api/common/NgIf" rel="nofollow" target="_blank">https://angular.io/api/common/NgIf</a></p>
<p><a href="https://angular.io/guide/control_flow#if-block-conditionals" rel="nofollow" target="_blank">https://angular.io/guide/control_flow#if-block-conditionals</a></p>
<p><a href="https://angular.io/api/common/NgFor" rel="nofollow" target="_blank">https://angular.io/api/common/NgFor</a></p>
<p><a href="https://angular.io/guide/control_flow#for-block---repeaters" rel="nofollow" target="_blank">https://angular.io/guide/control_flow#for-block---repeaters</a></p>
<div class="content-ad"></div>
<ul>
<li><a href="https://angular.io/api/core/TrackByFunction" rel="nofollow" target="_blank">TrackByFunction</a></li>
<li><a href="https://angular.io/guide/property-binding" rel="nofollow" target="_blank">Property Binding</a></li>
<li><a href="https://angular.io/guide/event-binding" rel="nofollow" target="_blank">Event Binding</a></li>
<li><a href="https://angular.io/guide/inputs-outputs#sending-data-to-a-parent-component" rel="nofollow" target="_blank">inputs-outputs#sending-data-to-a-parent-component</a></li>
</ul>
<div class="content-ad"></div>
<p><a href="https://angular.io/api/core/EventEmitter" rel="nofollow" target="_blank">https://angular.io/api/core/EventEmitter</a></p>
<p><a href="https://angular.io/api/core/Output" rel="nofollow" target="_blank">https://angular.io/api/core/Output</a></p>
<p><a href="https://angular.io/guide/http-intercept-requests-and-responses" rel="nofollow" target="_blank">https://angular.io/guide/http-intercept-requests-and-responses</a></p>
<p><a href="https://angular.io/api/common/http/HttpClient" rel="nofollow" target="_blank">https://angular.io/api/common/http/HttpClient</a></p>
<div class="content-ad"></div>
<p><a href="https://angular.io/api/router/Resolve" rel="nofollow" target="_blank">https://angular.io/api/router/Resolve</a></p>
<p><a href="https://angular.io/guide/rx-library" rel="nofollow" target="_blank">https://angular.io/guide/rx-library</a></p>
<p><a href="https://rxjs.dev/guide/operators#categories-of-operators" rel="nofollow" target="_blank">https://rxjs.dev/guide/operators#categories-of-operators</a></p>
<p><a href="https://angular.io/api/common/AsyncPipe" rel="nofollow" target="_blank">https://angular.io/api/common/AsyncPipe</a></p>
<div class="content-ad"></div>
<p><a href="https://angular.io/guide/glossary" rel="nofollow" target="_blank">https://angular.io/guide/glossary</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React에서 Angular로 전환하는 개발자를 위한 10가지 팁","description":"","date":"2024-06-27 17:59","slug":"2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular","content":"\n\n\n![이미지](/assets/img/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular_0.png)\n\nReact에서 Angular로 전환하는 것은 개발자들에게 도전적이면서 보상이 있는 여정일 수 있습니다. 각 프레임워크마다 고유한 원칙, 구문 및 관습이 있어 전환 과정은 신중히 진행되어야 합니다.\n\nFever에서는 특정 언어나 프레임워크의 경험보다는 기술에 기반하여 최고 수준의 엔지니어를 채용하기를 우선시합니다. 따라서, React에서 Angular로의 전환은 우리 엔지니어들에게 일상적인 일입니다.\n\n본 글에서는 React에서 Angular로의 개발자 전환을 원활히 돕기 위해 우리에게 유용했던 10가지 팁을 살펴보겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 팁 01: ngIf 구조 지시문 사용하기\n\n● React에서는 조건부 렌더링을 사용하여 컴포넌트나 요소를 렌더링할지 여부를 결정할 수 있습니다. 다음은 이를 구현한 예시입니다:\n\n```js\nconst ConditionalComponent = ({ shouldRender }) =\u003e {\n  return shouldRender ? \u003cdiv\u003e조건에 따라 렌더링됩니다\u003c/div\u003e : null;\n};\n```\n\n● Angular에서는 템플릿에서 *ngIf 구조 지시문을 사용하여 요소를 조건부로 렌더링하는 것이 일반적합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cng-container *ngIf=\"shouldRender\"\u003e\n  This is rendered conditionally\n\u003c/ng-container\u003e\n```\n\n*Angular v17 will have a new built-in control flow template syntax for if block conditionals\n\n## Tip 02: Using ngFor structural directive\n\n- In React, you use the map function to iterate over an array and create a list of elements.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst ListComponent = ({ items }) =\u003e {\n  return (\n    - 목록\n      - {items.map((item, index) =\u003e (\n        - \u003cli key={item.id}\u003e\n          - {index + 1}. {item.name}\n      - ))}\n  );\n};\n```\n\n* Angular에서는 *ngFor 구조 지시자를 사용하여 템플릿에서 요소를 반복할 수 있습니다.\n\n```js\n- 목록\n    - \u003cli *ngFor=\"let item of items; let i = index\"\u003e\n        { i + 1 }. { item.name }\n    - \u003c/li\u003e\n```\n\n* Angular v17에서는 블록 반복기를 위한 새로운 내장 제어 흐름 템플릿 구문이 제공될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 팁 03: TrackByFunction을 사용하여 목록 렌더링 개선하기:\n\n● React에서 요소 목록을 렌더링할 때는 각 요소에 고유한 key 속성을 할당해야 합니다. 이를 통해 React가 각 요소를 고유하게 식별하고 효율적으로 DOM을 업데이트할 수 있습니다.\n\n```js\nconst ListComponent = ({ items }) =\u003e {\n  return (\n    \u003cul\u003e\n      {items.map((item, index) =\u003e (\n        \u003cli key={item.id}\u003e\n          {index + 1}. {item.name}\n        \u003c/li\u003e\n      ))}\n    \u003c/ul\u003e\n  );\n};\n```\n\n● Angular에서는 trackBy 함수를 사용하여 동일한 결과를 얻을 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Component } from '@angular/core';\n\ninterface ListItem {\n  id: number;\n  name: string;\n}\n\n@Component({\n  selector: 'app-list',\n  template: `\n    \u003cul\u003e\n      \u003cli *ngFor=\"let item of items; trackBy: trackByFn\"\u003e\n        { item.id } - { item.name }\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  `,\n})\nexport class ListComponent {\n  items: Array\u003cListItem\u003e = [ \n    { id: 1, name: 'Item 1' }, \n    { id: 2, name: 'Item 2' }\n  ];\n\n  trackByFn(index: number, item: ListItem): number {\n    return item.id; // Return a unique identifier for each item\n  }\n}\n```\n\n## 팁 04: 프로퍼티 바인딩\n\n● React에서는 데이터가 부모 구성 요소에서 자식 구성 요소로 props로 전달됩니다. 자식 구성 요소는 이러한 props을 받아 렌더링에 사용합니다.\n\n```js\nimport React from 'react';\n\nconst ImageComponent = ({ imageUrl }) =\u003e {\n  return \u003cimg src={imageUrl} alt=\"React Image\" /\u003e;\n};\n\nexport default ImageComponent;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 다음은 Angular에서 속성 바인딩을 사용하는 방법입니다. 속성 바인딩은 컴포넌트의 속성을 HTML 요소 속성이나 디렉티브에 바인딩하는 데 사용됩니다.\n\n```js\n\u003cimg [src]=\"imageUrl\" alt=\"Angular Image\" /\u003e\n```\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: '\u003cimg [src]=\"imageUrl\" alt=\"Angular Image\" /\u003e',\n})\nexport class ExampleComponent {\n  @Input() imageUrl: string;\n}\n```\n\n## 팁 05: 이벤트 바인딩\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n● React에서는 콜백 함수를 전달하기 위해 props를 사용하여 동일한 기능을 구현할 수 있습니다.\n\n```js\nconst ChildComponent = ({ onCustomEvent }) =\u003e (\n  \u003cbutton onClick={onCustomEvent}\u003eClick me\u003c/button\u003e\n);\n\nconst App = () =\u003e {\n  const [message, setMessage] = useState('');\n\n  const handleCustomEvent = () =\u003e {...};\n\n  return (\n    \u003cChildComponent onCustomEvent={handleCustomEvent} /\u003e\n  );\n};\n```\n\n● Angular에서는 이벤트 바인딩을 통해 사용자 작업 (키 입력, 마우스 이동, 클릭, 터치 등)을 감지하고 대응할 수 있습니다.\n\n```js\n@Component({\n  selector: 'app-child',\n  template: `\n    \u003cbutton (click)=\"doSomething()\"\u003eClick me\u003c/button\u003e\n  `,\n})\nexport class ChildComponent {\n  doSomething() {...}\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만일 자료를 부모 컴포넌트로 전달하고 싶다면, 자식 컴포넌트에서 @Output() 데코레이터를 사용할 수 있어요. 이 데코레이터가 있는 속성은 EventEmitter 유형이어야하며, 사용자 정의 이벤트를 발생시킬 때 사용돼요.\n\n```js\n@Component({\n  selector: 'app-child',\n  template: `\n    \u003cbutton (click)=\"customEvent.emit()\"\u003eClick me\u003c/button\u003e\n  `,\n})\nexport class ChildComponent {\n  @Output() customEvent: EventEmitter\u003cvoid\u003e = new EventEmitter\u003cvoid\u003e();\n}\n\n@Component({\n  selector: 'app-root',\n  template: `\u003capp-child (customEvent)=\"handleCustomEvent()\"\u003e\u003c/app-child\u003e`,\n})\nexport class AppComponent {\n  handleCustomEvent(): void {...}\n}\n```\n\n## 팁 06: 의존성 주입\n\n● React에서 의존성 주입을 관리하는 일반적인 방법 몇 가지가 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Props\n- Context API\n- Higher-Order Components (HOCs)\n- Render Props\n- React Hooks\n\n● Angular에서는 의존성 주입이 프레임워크의 핵심 부분입니다. Angular는 서비스의 인스턴스를 생성하고 관리하는 역할을 담당하는 인젝터를 제공합니다. 간단한 예시를 확인해보세요:\n\n```js\n@Injectable({\n  providedIn: 'root',\n})\nexport class MyService {\n  getData(): string {\n    return 'Angular 서비스로부터의 데이터';\n  }\n}\n\n@Component({\n  selector: 'app-root',\n  template: `\u003cp\u003e{ message }\u003c/p\u003e`,\n})\nexport class AppComponent implements OnInit {\n  message: string;\n  private readonly myService = inject(MyService);\n\n  ngOnInit(): void {\n    this.message = this.myService.getData();\n  }\n}\n```\n\n## 팁 07: 리졸버\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact에는 Angular의 resolver 기능과 직접적인 동등물이 없습니다. 데이터 가져오기는 보통 컴포넌트 자체 내에서 또는 라이프사이클 메서드, 훅, 또는 외부 라이브러리의 도움으로 처리됩니다. React 컴포넌트에서 사용자 정의 훅을 사용한 간단한 예제가 여기 있어요:\n\n```js\nconst useCustomHook = () =\u003e {\n  const [data, setData] = useState(null);\n  useEffect(() =\u003e {\n    const fetchData = async () =\u003e {\n      try {\n        const response = await fetch('https://api.example.com/data');\n        const result = await response.json();\n        setData(result);\n      } catch (error) {\n        console.error('Error fetching data:', error);\n      }\n    };\n    fetchData();\n  }, []); // 의존성 배열이 비어있어서 효과가 마운트시 한 번만 실행됨\n  return data;\n};\n\nconst MyComponent = () =\u003e {\n  const { data } = useCustomHook();\n  return (\n    \u003cdiv\u003e\n      {data ? (\n        \u003cp\u003eData from React component: {data}\u003c/p\u003e\n      ) : (\n        \u003cp\u003eLoading...\u003c/p\u003e\n      )}\n    \u003c/div\u003e\n  );\n};\nexport default MyComponent;\n```\n\nAngular에서는 resolver를 사용하여 라우트가 활성화되기 전 데이터를 가져와 해당 컴포넌트가 렌더링되기 전에 필요한 데이터를 보장합니다.\n\n```js\n@Injectable({\n  providedIn: 'root',\n})\nexport class MyDataResolver implements Resolve\u003cstring\u003e {\n  private readonly myDataService = inject(MyDataService);\n\n  resolve(): Observable\u003cstring\u003e {\n    return this.myDataService.fetchData();\n  }\n}\n\nconst routes: Routes = [\n  {\n    path: 'my-route',\n    component: MyComponent,\n    resolve: {\n      myData: MyDataResolver,\n    },\n  },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 팁 08: 인터셉터\n\n● React에서는 Redux와 같은 상태 관리 미들웨어를 통해 HTTP 인터셉터 기능을 구현할 수 있습니다. 미들웨어는 액션이 리듀서에 도달하기 전에 해당 액션을 가로챌 수 있고 수정하거나 새로운 액션을 디스패치하거나 비동기 작업을 수행할 수 있습니다. Redux 미들웨어를 사용한 간단한 예시를 살펴보겠습니다:\n\n```js\nconst myMiddleware = (store) =\u003e (next) =\u003e (action) =\u003e {\n  // 액션 수정 또는 다른 작업 수행\n\n  // 예를 들어, 액션이 리듀서에 도달하기 전에 액션을 로깅하는 경우\n  console.log('Action:', action);\n\n  // 다음 미들웨어나 리듀서에 액션 전달\n  return next(action);\n};\n\nexport default myMiddleware;\n```\n\n```js\nconst store = createStore(rootReducer, applyMiddleware(myMiddleware));\n\nexport default store;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n● Angular에서 인터셉터는 HttpClient와 등록하여 HTTP 요청이나 응답을 가로챌 수 있는 서비스입니다. React의 미들웨어와는 달리 내장된 HTTPClient에만 작동합니다.\n\n인터셉터를 사용하면 모든 HTTP 요청이나 응답에 전역적으로 공통 동작이나 수정을 적용할 수 있습니다. 아래는 간단한 Angular 인터셉터 예제입니다:\n\n```js\n@Injectable()\nexport class MyInterceptor implements HttpInterceptor {\n  intercept(\n    request: HttpRequest\u003cany\u003e,\n    next: HttpHandler\n  ): Observable\u003cHttpEvent\u003cany\u003e\u003e {\n    // 요청을 수정하거나 응답을 전역적으로 처리합니다\n\n    // 예를 들어, 각 요청에 사용자 지정 헤더 추가\n    const modifiedRequest = request.clone({\n      setHeaders: { 'X-Custom-Header': 'Custom Value' },\n    });\n\n    return next.handle(modifiedRequest);\n  }\n}\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule, HttpClientModule],\n  providers: [\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: MyInterceptor,\n      multi: true,\n    },\n  ],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n## 팁 09: Rxjs\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRxJS 라이브러리는 비동기 및 이벤트 기반 프로그래밍을 더 선언적이고 조립 가능한 방식으로 처리할 수 있는 도구 세트를 제공합니다. Angular에서 널리 사용됩니다. 간단히 설명하면 다음과 같습니다:\n\nObservables:\n\n- Observable은 시간에 따른 데이터 스트림의 표현입니다.\n- 비동기적으로 여러 값을 방출할 수 있습니다.\n- Observables는 이벤트, 프로미스 또는 수동으로 생성할 수 있는 다양한 소스에서 만들어질 수 있습니다.\n\nObservers:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Observer는 Observable에 가입하여 Observable이 방출한 변경 사항이나 새 값에 대한 알림을 받습니다.\n- Observer에는 next(다음 값 처리), error(오류 처리), complete(작업 완료 처리)와 같이 세 가지 콜백 함수가 있습니다.\n\n주요 RxJS 연산자:\n\n- map: 제공된 함수를 사용하여 Observable이 방출한 값을 변환합니다.\n- filter: 주어진 조건에 따라 Observable이 방출한 값을 필터링합니다.\n- mergeMap: 각 소스 값을 Observable로 프로젝트하고 결과 Observable을 하나의 Observable 스트림으로 병합합니다.\n- combineLatest: 여러 Observables에서 최신 값들을 합쳐 하나의 Observable로 조합합니다.\n\n```js\nconst App = () =\u003e {\n  const [data, setData] = useState('');\n\n  useEffect(() =\u003e {\n    // 버튼 클릭에서 Observable 생성\n    const buttonClick$ = fromEvent(document.getElementById('myButton'), 'click');\n\n    // 각 클릭 이벤트를 처리하고 API 호출을 트리거하는 mergeMap 사용\n    const apiCall$ = buttonClick$.pipe(\n      mergeMap(() =\u003e fetch('https://api.example.com/data')),\n      mergeMap(response =\u003e response.json())\n    );\n\n    // API 응답에서 원하는 특정 데이터를 추출하기 위해 map을 사용\n    const subscription = apiCall$.subscribe(\n      responseData =\u003e setData(responseData.data),\n      error =\u003e console.error('오류:', error)\n    );\n\n    return () =\u003e subscription.unsubscribe(); // 컴포넌트 해제 시 정리\n  }, []);\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton id=\"myButton\"\u003e클릭하세요\u003c/button\u003e\n      \u003cp\u003e{data}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default App;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 연산자의 전체 리스트를 확인할 수 있습니다: [Operators List](https://rxjs.dev/guide/operators#categories-of-operators).\n\n## 팁 10: Rxjs 구독 취소 시점\n\nAngular에서 메모리 누수를 방지하기 위해 옵저버블의 구독을 해제하는 것이 중요합니다. 옵저버블을 구독하면 옵저버와 옵저버블 사이에 연결이 생성되는데, 이 연결은 더 이상 필요하지 않을 때 닫혀야 합니다. 구독을 해제하지 않으면 잔류 참조와 메모리 누수로 이어질 수 있습니다.\n\nAngular에서 구독을 취소해야 하는 일반적인 시나리오 몇 가지를 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 컴포넌트 파괴:\n\n```js\n@Component({\n  selector: 'app-my-component',\n})\nexport class MyComponent implements OnInit, OnDestroy {\n  private subscription: Subscription;\n\n  ngOnInit() {\n    this.subscription = someObservable.subscribe(data =\u003e {\n      // 데이터 처리\n    });\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n}\n```\n\n2. 무한 옵저버블:\n\n```js\nexport class MyComponent implements OnInit, OnDestroy {\n  private subscription: Subscription;\n\n  constructor(private infiniteObservableService: InfiniteObservableService) {}\n\n  ngOnInit() {\n    this.subscription = interval(1000).pipe(\n      map((value) =\u003e {\n        // 필요에 따라 발행된 값 변환\n        return value * 2;\n      })\n      .subscribe((data) =\u003e {\n        this.infiniteData = data;\n      });\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 라우터 이벤트:\n\n```js\n@Component({\n  selector: 'app-my-component',\n})\nexport class MyComponent implements OnDestroy, OnInit {\n  private subscription: Subscription;\n  private router = inject(Router);\n\n  ngOnInit(): void {\n    this.subscription = this.router.events.subscribe(event =\u003e {...});\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n}\n```\n\n4. AsyncPipe\n\nAngular에서 async 파이프는 Observable에 대한 구독을 자동화하고 구성 요소가 파기될 때 구독 해제를 처리합니다. 이는 템플릿에서 비동기 데이터를 다루는 과정을 간소화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`async` 파이프를 활용하면 Angular 템플릿에서 Observable에 직접 구독하고 값을 끊임없이 바인딩할 수 있습니다:\n\n```js\n\u003cdiv\u003e{ observable$ | async }\u003c/div\u003e\n```\n\n실제로는 async 파이프가 구독 및 구독 해제 수명주기를 관리해주므며, 깔끔한 자원 관리를 보장하고 메모리 누수를 방지합니다.\n\n- Angular에는 고유한 용어가 있습니다. 익숙하지 않다면 Angular 용어집이 유용할 것입니다: Angular 용어집.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 영감을 받은 곳:\n\n[https://netbasal.com/when-to-unsubscribe-in-angular-d61c6b21bad3](https://netbasal.com/when-to-unsubscribe-in-angular-d61c6b21bad3)\n\n[https://dev.to/yashjsalian/switching-to-angular-after-working-with-react-5bam](https://dev.to/yashjsalian/switching-to-angular-after-working-with-react-5bam)\n\n# 참고:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://angular.io/api/common/NgIf\n\nhttps://angular.io/guide/control_flow#if-block-conditionals\n\nhttps://angular.io/api/common/NgFor\n\nhttps://angular.io/guide/control_flow#for-block---repeaters\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- [TrackByFunction](https://angular.io/api/core/TrackByFunction)\n- [Property Binding](https://angular.io/guide/property-binding)\n- [Event Binding](https://angular.io/guide/event-binding)\n- [inputs-outputs#sending-data-to-a-parent-component](https://angular.io/guide/inputs-outputs#sending-data-to-a-parent-component)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[https://angular.io/api/core/EventEmitter](https://angular.io/api/core/EventEmitter)\n\n[https://angular.io/api/core/Output](https://angular.io/api/core/Output)\n\n[https://angular.io/guide/http-intercept-requests-and-responses](https://angular.io/guide/http-intercept-requests-and-responses)\n\n[https://angular.io/api/common/http/HttpClient](https://angular.io/api/common/http/HttpClient)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://angular.io/api/router/Resolve\n\nhttps://angular.io/guide/rx-library\n\nhttps://rxjs.dev/guide/operators#categories-of-operators\n\nhttps://angular.io/api/common/AsyncPipe\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://angular.io/guide/glossary","ogImage":{"url":"/assets/img/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular_0.png"},"coverImage":"/assets/img/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular_0.png","tag":["Tech"],"readingTime":14},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eReact에서 Angular로 전환하는 것은 개발자들에게 도전적이면서 보상이 있는 여정일 수 있습니다. 각 프레임워크마다 고유한 원칙, 구문 및 관습이 있어 전환 과정은 신중히 진행되어야 합니다.\u003c/p\u003e\n\u003cp\u003eFever에서는 특정 언어나 프레임워크의 경험보다는 기술에 기반하여 최고 수준의 엔지니어를 채용하기를 우선시합니다. 따라서, React에서 Angular로의 전환은 우리 엔지니어들에게 일상적인 일입니다.\u003c/p\u003e\n\u003cp\u003e본 글에서는 React에서 Angular로의 개발자 전환을 원활히 돕기 위해 우리에게 유용했던 10가지 팁을 살펴보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e팁 01: ngIf 구조 지시문 사용하기\u003c/h2\u003e\n\u003cp\u003e● React에서는 조건부 렌더링을 사용하여 컴포넌트나 요소를 렌더링할지 여부를 결정할 수 있습니다. 다음은 이를 구현한 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eConditionalComponent\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ shouldRender }\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e shouldRender ? \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e조건에 따라 렌더링됩니다\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e● Angular에서는 템플릿에서 *ngIf 구조 지시문을 사용하여 요소를 조건부로 렌더링하는 것이 일반적합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;ng-container *ngIf=\u003cspan class=\"hljs-string\"\u003e\"shouldRender\"\u003c/span\u003e\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eThis\u003c/span\u003e is rendered conditionally\n\u0026#x3C;/ng-container\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e*Angular v17 will have a new built-in control flow template syntax for if block conditionals\u003c/p\u003e\n\u003ch2\u003eTip 02: Using ngFor structural directive\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eIn React, you use the map function to iterate over an array and create a list of elements.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eListComponent\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ items }\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    - 목록\n      - {items.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eitem, index\u003c/span\u003e) =\u003e\u003c/span\u003e (\n        - \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item.id}\u003c/span\u003e\u003e\u003c/span\u003e\n          - {index + 1}. {item.name}\n      - ))}\n  );\n};\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eAngular에서는 *ngFor 구조 지시자를 사용하여 템플릿에서 요소를 반복할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e- 목록\n    - \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e *\u003cspan class=\"hljs-attr\"\u003engFor\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"let item of items; let i = index\"\u003c/span\u003e\u003e\u003c/span\u003e\n        { i + 1 }. { item.name }\n    - \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eAngular v17에서는 블록 반복기를 위한 새로운 내장 제어 흐름 템플릿 구문이 제공될 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e팁 03: TrackByFunction을 사용하여 목록 렌더링 개선하기:\u003c/h2\u003e\n\u003cp\u003e● React에서 요소 목록을 렌더링할 때는 각 요소에 고유한 key 속성을 할당해야 합니다. 이를 통해 React가 각 요소를 고유하게 식별하고 효율적으로 DOM을 업데이트할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eListComponent\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ items }\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\n      {items.map((item, index) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item.id}\u003c/span\u003e\u003e\u003c/span\u003e\n          {index + 1}. {item.name}\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\n      ))}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e● Angular에서는 trackBy 함수를 사용하여 동일한 결과를 얻을 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\ninterface \u003cspan class=\"hljs-title class_\"\u003eListItem\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: number;\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string;\n}\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-list'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\n    \u0026#x3C;ul\u003e\n      \u0026#x3C;li *ngFor=\"let item of items; trackBy: trackByFn\"\u003e\n        { item.id } - { item.name }\n      \u0026#x3C;/li\u003e\n    \u0026#x3C;/ul\u003e\n  `\u003c/span\u003e,\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eListComponent\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eitems\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eListItem\u003c/span\u003e\u003e = [ \n    { \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Item 1'\u003c/span\u003e }, \n    { \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Item 2'\u003c/span\u003e }\n  ];\n\n  \u003cspan class=\"hljs-title function_\"\u003etrackByFn\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eindex\u003c/span\u003e: number, \u003cspan class=\"hljs-attr\"\u003eitem\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eListItem\u003c/span\u003e): number {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e item.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// Return a unique identifier for each item\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e팁 04: 프로퍼티 바인딩\u003c/h2\u003e\n\u003cp\u003e● React에서는 데이터가 부모 구성 요소에서 자식 구성 요소로 props로 전달됩니다. 자식 구성 요소는 이러한 props을 받아 렌더링에 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eImageComponent\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ imageUrl }\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{imageUrl}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"React Image\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImageComponent\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e안녕하세요! 다음은 Angular에서 속성 바인딩을 사용하는 방법입니다. 속성 바인딩은 컴포넌트의 속성을 HTML 요소 속성이나 디렉티브에 바인딩하는 데 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;img [src]=\u003cspan class=\"hljs-string\"\u003e\"imageUrl\"\u003c/span\u003e alt=\u003cspan class=\"hljs-string\"\u003e\"Angular Image\"\u003c/span\u003e /\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-example'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;img [src]=\"imageUrl\" alt=\"Angular Image\" /\u003e'\u003c/span\u003e,\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExampleComponent\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title class_\"\u003eInput\u003c/span\u003e() \u003cspan class=\"hljs-attr\"\u003eimageUrl\u003c/span\u003e: string;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e팁 05: 이벤트 바인딩\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e● React에서는 콜백 함수를 전달하기 위해 props를 사용하여 동일한 기능을 구현할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eChildComponent\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ onCustomEvent }\u003c/span\u003e) =\u003e (\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{onCustomEvent}\u003c/span\u003e\u003e\u003c/span\u003eClick me\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [message, setMessage] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleCustomEvent\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {...};\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eChildComponent\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonCustomEvent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleCustomEvent}\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e● Angular에서는 이벤트 바인딩을 통해 사용자 작업 (키 입력, 마우스 이동, 클릭, 터치 등)을 감지하고 대응할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-child'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\n    \u0026#x3C;button (click)=\"doSomething()\"\u003eClick me\u0026#x3C;/button\u003e\n  `\u003c/span\u003e,\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChildComponent\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {...}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만일 자료를 부모 컴포넌트로 전달하고 싶다면, 자식 컴포넌트에서 @Output() 데코레이터를 사용할 수 있어요. 이 데코레이터가 있는 속성은 EventEmitter 유형이어야하며, 사용자 정의 이벤트를 발생시킬 때 사용돼요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-child'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\n    \u0026#x3C;button (click)=\"customEvent.emit()\"\u003eClick me\u0026#x3C;/button\u003e\n  `\u003c/span\u003e,\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChildComponent\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title class_\"\u003eOutput\u003c/span\u003e() \u003cspan class=\"hljs-attr\"\u003ecustomEvent\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eEventEmitter\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEventEmitter\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e();\n}\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-root'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\u0026#x3C;app-child (customEvent)=\"handleCustomEvent()\"\u003e\u0026#x3C;/app-child\u003e`\u003c/span\u003e,\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003ehandleCustomEvent\u003c/span\u003e(): \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e {...}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e팁 06: 의존성 주입\u003c/h2\u003e\n\u003cp\u003e● React에서 의존성 주입을 관리하는 일반적인 방법 몇 가지가 있어요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eProps\u003c/li\u003e\n\u003cli\u003eContext API\u003c/li\u003e\n\u003cli\u003eHigher-Order Components (HOCs)\u003c/li\u003e\n\u003cli\u003eRender Props\u003c/li\u003e\n\u003cli\u003eReact Hooks\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e● Angular에서는 의존성 주입이 프레임워크의 핵심 부분입니다. Angular는 서비스의 인스턴스를 생성하고 관리하는 역할을 담당하는 인젝터를 제공합니다. 간단한 예시를 확인해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eprovidedIn\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e,\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyService\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e(): string {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'Angular 서비스로부터의 데이터'\u003c/span\u003e;\n  }\n}\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-root'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\u0026#x3C;p\u003e{ message }\u0026#x3C;/p\u003e`\u003c/span\u003e,\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eOnInit\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: string;\n  private readonly myService = \u003cspan class=\"hljs-title function_\"\u003einject\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMyService\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title function_\"\u003engOnInit\u003c/span\u003e(): \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emyService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e팁 07: 리졸버\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eReact에는 Angular의 resolver 기능과 직접적인 동등물이 없습니다. 데이터 가져오기는 보통 컴포넌트 자체 내에서 또는 라이프사이클 메서드, 훅, 또는 외부 라이브러리의 도움으로 처리됩니다. React 컴포넌트에서 사용자 정의 훅을 사용한 간단한 예제가 여기 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003euseCustomHook\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [data, setData] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/data'\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n        \u003cspan class=\"hljs-title function_\"\u003esetData\u003c/span\u003e(result);\n      } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Error fetching data:'\u003c/span\u003e, error);\n      }\n    };\n    \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e();\n  }, []); \u003cspan class=\"hljs-comment\"\u003e// 의존성 배열이 비어있어서 효과가 마운트시 한 번만 실행됨\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e data;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyComponent\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { data } = \u003cspan class=\"hljs-title function_\"\u003euseCustomHook\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      {data ? (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003eData from React component: {data}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n      ) : (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003eLoading...\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n      )}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyComponent\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAngular에서는 resolver를 사용하여 라우트가 활성화되기 전 데이터를 가져와 해당 컴포넌트가 렌더링되기 전에 필요한 데이터를 보장합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eprovidedIn\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e,\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyDataResolver\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eResolve\u003c/span\u003e\u0026#x3C;string\u003e {\n  private readonly myDataService = \u003cspan class=\"hljs-title function_\"\u003einject\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMyDataService\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(): \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e\u0026#x3C;string\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emyDataService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e();\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eroutes\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRoutes\u003c/span\u003e = [\n  {\n    \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'my-route'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMyComponent\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eresolve\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003emyData\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMyDataResolver\u003c/span\u003e,\n    },\n  },\n];\n\n@\u003cspan class=\"hljs-title class_\"\u003eNgModule\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eimports\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eRouterModule\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eforRoot\u003c/span\u003e(routes)],\n  \u003cspan class=\"hljs-attr\"\u003eexports\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eRouterModule\u003c/span\u003e],\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppRoutingModule\u003c/span\u003e {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e팁 08: 인터셉터\u003c/h2\u003e\n\u003cp\u003e● React에서는 Redux와 같은 상태 관리 미들웨어를 통해 HTTP 인터셉터 기능을 구현할 수 있습니다. 미들웨어는 액션이 리듀서에 도달하기 전에 해당 액션을 가로챌 수 있고 수정하거나 새로운 액션을 디스패치하거나 비동기 작업을 수행할 수 있습니다. Redux 미들웨어를 사용한 간단한 예시를 살펴보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emyMiddleware\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003estore\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003enext\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eaction\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 액션 수정 또는 다른 작업 수행\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// 예를 들어, 액션이 리듀서에 도달하기 전에 액션을 로깅하는 경우\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Action:'\u003c/span\u003e, action);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 다음 미들웨어나 리듀서에 액션 전달\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(action);\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e myMiddleware;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e store = \u003cspan class=\"hljs-title function_\"\u003ecreateStore\u003c/span\u003e(rootReducer, \u003cspan class=\"hljs-title function_\"\u003eapplyMiddleware\u003c/span\u003e(myMiddleware));\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e store;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e● Angular에서 인터셉터는 HttpClient와 등록하여 HTTP 요청이나 응답을 가로챌 수 있는 서비스입니다. React의 미들웨어와는 달리 내장된 HTTPClient에만 작동합니다.\u003c/p\u003e\n\u003cp\u003e인터셉터를 사용하면 모든 HTTP 요청이나 응답에 전역적으로 공통 동작이나 수정을 적용할 수 있습니다. 아래는 간단한 Angular 인터셉터 예제입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyInterceptor\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eHttpInterceptor\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003eintercept\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003erequest\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHttpRequest\u003c/span\u003e\u0026#x3C;any\u003e,\n    \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHttpHandler\u003c/span\u003e\n  ): \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHttpEvent\u003c/span\u003e\u0026#x3C;any\u003e\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 요청을 수정하거나 응답을 전역적으로 처리합니다\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e// 예를 들어, 각 요청에 사용자 지정 헤더 추가\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e modifiedRequest = request.\u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003esetHeaders\u003c/span\u003e: { \u003cspan class=\"hljs-string\"\u003e'X-Custom-Header'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Custom Value'\u003c/span\u003e },\n    });\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e next.\u003cspan class=\"hljs-title function_\"\u003ehandle\u003c/span\u003e(modifiedRequest);\n  }\n}\n\n@\u003cspan class=\"hljs-title class_\"\u003eNgModule\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003edeclarations\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003eimports\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eBrowserModule\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eHttpClientModule\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003eproviders\u003c/span\u003e: [\n    {\n      \u003cspan class=\"hljs-attr\"\u003eprovide\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eHTTP_INTERCEPTORS\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003euseClass\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMyInterceptor\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003emulti\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    },\n  ],\n  \u003cspan class=\"hljs-attr\"\u003ebootstrap\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e],\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppModule\u003c/span\u003e {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e팁 09: Rxjs\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eRxJS 라이브러리는 비동기 및 이벤트 기반 프로그래밍을 더 선언적이고 조립 가능한 방식으로 처리할 수 있는 도구 세트를 제공합니다. Angular에서 널리 사용됩니다. 간단히 설명하면 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003eObservables:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eObservable은 시간에 따른 데이터 스트림의 표현입니다.\u003c/li\u003e\n\u003cli\u003e비동기적으로 여러 값을 방출할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eObservables는 이벤트, 프로미스 또는 수동으로 생성할 수 있는 다양한 소스에서 만들어질 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eObservers:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eObserver는 Observable에 가입하여 Observable이 방출한 변경 사항이나 새 값에 대한 알림을 받습니다.\u003c/li\u003e\n\u003cli\u003eObserver에는 next(다음 값 처리), error(오류 처리), complete(작업 완료 처리)와 같이 세 가지 콜백 함수가 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e주요 RxJS 연산자:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emap: 제공된 함수를 사용하여 Observable이 방출한 값을 변환합니다.\u003c/li\u003e\n\u003cli\u003efilter: 주어진 조건에 따라 Observable이 방출한 값을 필터링합니다.\u003c/li\u003e\n\u003cli\u003emergeMap: 각 소스 값을 Observable로 프로젝트하고 결과 Observable을 하나의 Observable 스트림으로 병합합니다.\u003c/li\u003e\n\u003cli\u003ecombineLatest: 여러 Observables에서 최신 값들을 합쳐 하나의 Observable로 조합합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [data, setData] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 버튼 클릭에서 Observable 생성\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e buttonClick$ = \u003cspan class=\"hljs-title function_\"\u003efromEvent\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'myButton'\u003c/span\u003e), \u003cspan class=\"hljs-string\"\u003e'click'\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 각 클릭 이벤트를 처리하고 API 호출을 트리거하는 mergeMap 사용\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e apiCall$ = buttonClick$.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\n      \u003cspan class=\"hljs-title function_\"\u003emergeMap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/data'\u003c/span\u003e)),\n      \u003cspan class=\"hljs-title function_\"\u003emergeMap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u003e\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n    );\n\n    \u003cspan class=\"hljs-comment\"\u003e// API 응답에서 원하는 특정 데이터를 추출하기 위해 map을 사용\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subscription = apiCall$.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n      \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponseData\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetData\u003c/span\u003e(responseData.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e),\n      \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'오류:'\u003c/span\u003e, error)\n    );\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e subscription.\u003cspan class=\"hljs-title function_\"\u003eunsubscribe\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 컴포넌트 해제 시 정리\u003c/span\u003e\n  }, []);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"myButton\"\u003c/span\u003e\u003e\u003c/span\u003e클릭하세요\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{data}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기서 연산자의 전체 리스트를 확인할 수 있습니다: \u003ca href=\"https://rxjs.dev/guide/operators#categories-of-operators\" rel=\"nofollow\" target=\"_blank\"\u003eOperators List\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003e팁 10: Rxjs 구독 취소 시점\u003c/h2\u003e\n\u003cp\u003eAngular에서 메모리 누수를 방지하기 위해 옵저버블의 구독을 해제하는 것이 중요합니다. 옵저버블을 구독하면 옵저버와 옵저버블 사이에 연결이 생성되는데, 이 연결은 더 이상 필요하지 않을 때 닫혀야 합니다. 구독을 해제하지 않으면 잔류 참조와 메모리 누수로 이어질 수 있습니다.\u003c/p\u003e\n\u003cp\u003eAngular에서 구독을 취소해야 하는 일반적인 시나리오 몇 가지를 살펴보겠습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e컴포넌트 파괴:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-my-component'\u003c/span\u003e,\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyComponent\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eOnInit\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOnDestroy\u003c/span\u003e {\n  private \u003cspan class=\"hljs-attr\"\u003esubscription\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSubscription\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-title function_\"\u003engOnInit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esubscription\u003c/span\u003e = someObservable.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 데이터 처리\u003c/span\u003e\n    });\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003engOnDestroy\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esubscription\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eunsubscribe\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e무한 옵저버블:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyComponent\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eOnInit\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOnDestroy\u003c/span\u003e {\n  private \u003cspan class=\"hljs-attr\"\u003esubscription\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSubscription\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate infiniteObservableService: InfiniteObservableService\u003c/span\u003e) {}\n\n  \u003cspan class=\"hljs-title function_\"\u003engOnInit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esubscription\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003einterval\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\n      \u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e) =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 필요에 따라 발행된 값 변환\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e value * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n      })\n      .\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einfiniteData\u003c/span\u003e = data;\n      });\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003engOnDestroy\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esubscription\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eunsubscribe\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e라우터 이벤트:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-my-component'\u003c/span\u003e,\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyComponent\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eOnDestroy\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOnInit\u003c/span\u003e {\n  private \u003cspan class=\"hljs-attr\"\u003esubscription\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSubscription\u003c/span\u003e;\n  private router = \u003cspan class=\"hljs-title function_\"\u003einject\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eRouter\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title function_\"\u003engOnInit\u003c/span\u003e(): \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esubscription\u003c/span\u003e = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erouter\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eevents\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e =\u003e\u003c/span\u003e {...});\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003engOnDestroy\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esubscription\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eunsubscribe\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eAsyncPipe\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAngular에서 async 파이프는 Observable에 대한 구독을 자동화하고 구성 요소가 파기될 때 구독 해제를 처리합니다. 이는 템플릿에서 비동기 데이터를 다루는 과정을 간소화합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003easync\u003c/code\u003e 파이프를 활용하면 Angular 템플릿에서 Observable에 직접 구독하고 값을 끊임없이 바인딩할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;div\u003e{ observable$ | \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e }\u0026#x3C;/div\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e실제로는 async 파이프가 구독 및 구독 해제 수명주기를 관리해주므며, 깔끔한 자원 관리를 보장하고 메모리 누수를 방지합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAngular에는 고유한 용어가 있습니다. 익숙하지 않다면 Angular 용어집이 유용할 것입니다: Angular 용어집.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e영감을 받은 곳:\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://netbasal.com/when-to-unsubscribe-in-angular-d61c6b21bad3\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://netbasal.com/when-to-unsubscribe-in-angular-d61c6b21bad3\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://dev.to/yashjsalian/switching-to-angular-after-working-with-react-5bam\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://dev.to/yashjsalian/switching-to-angular-after-working-with-react-5bam\u003c/a\u003e\u003c/p\u003e\n\u003ch1\u003e참고:\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003ca href=\"https://angular.io/api/common/NgIf\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.io/api/common/NgIf\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://angular.io/guide/control_flow#if-block-conditionals\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.io/guide/control_flow#if-block-conditionals\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://angular.io/api/common/NgFor\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.io/api/common/NgFor\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://angular.io/guide/control_flow#for-block---repeaters\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.io/guide/control_flow#for-block---repeaters\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://angular.io/api/core/TrackByFunction\" rel=\"nofollow\" target=\"_blank\"\u003eTrackByFunction\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://angular.io/guide/property-binding\" rel=\"nofollow\" target=\"_blank\"\u003eProperty Binding\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://angular.io/guide/event-binding\" rel=\"nofollow\" target=\"_blank\"\u003eEvent Binding\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://angular.io/guide/inputs-outputs#sending-data-to-a-parent-component\" rel=\"nofollow\" target=\"_blank\"\u003einputs-outputs#sending-data-to-a-parent-component\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003ca href=\"https://angular.io/api/core/EventEmitter\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.io/api/core/EventEmitter\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://angular.io/api/core/Output\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.io/api/core/Output\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://angular.io/guide/http-intercept-requests-and-responses\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.io/guide/http-intercept-requests-and-responses\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://angular.io/api/common/http/HttpClient\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.io/api/common/http/HttpClient\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003ca href=\"https://angular.io/api/router/Resolve\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.io/api/router/Resolve\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://angular.io/guide/rx-library\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.io/guide/rx-library\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://rxjs.dev/guide/operators#categories-of-operators\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://rxjs.dev/guide/operators#categories-of-operators\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://angular.io/api/common/AsyncPipe\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.io/api/common/AsyncPipe\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003ca href=\"https://angular.io/guide/glossary\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://angular.io/guide/glossary\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-27-Navigatingthetransition10tipsfordevelopersswitchingfromReacttoAngular"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>