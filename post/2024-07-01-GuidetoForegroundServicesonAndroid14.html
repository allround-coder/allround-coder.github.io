<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>안드로이드 14 포어그라운드 서비스 가이드 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-07-01-GuidetoForegroundServicesonAndroid14" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="안드로이드 14 포어그라운드 서비스 가이드 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="안드로이드 14 포어그라운드 서비스 가이드 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-07-01-GuidetoForegroundServicesonAndroid14" data-gatsby-head="true"/><meta name="twitter:title" content="안드로이드 14 포어그라운드 서비스 가이드 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-01 20:13" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">안드로이드 14 포어그라운드 서비스 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="안드로이드 14 포어그라운드 서비스 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 1, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-01-GuidetoForegroundServicesonAndroid14&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>안녕하세요! 안드로이드 14에는 SDK 버전 34를 타겼다면 포그라운드 서비스와 관련된 중요 변경 사항이 포함되어 있습니다. 이 변경 사항을 적용하려면 어떤 작업을 해야 하는지 살펴보겠습니다.</p>
<p>또한 나타날 수 있는 일반적인 예외 상황과 그들을 어떻게 해결할 수 있는지도 다룰 예정입니다.</p>
<p>이 글의 끝에는 포그라운드 서비스를 올바르게 구현하는 방법을 보여주는 샘플 프로젝트도 찾아보실 수 있습니다.</p>
<p><img src="/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png" alt="Foreground Services on Android 14"></p>
<div class="content-ad"></div>
<h2>포그라운드 서비스란 무엇인가요?</h2>
<p>포그라운드 서비스는 사용자에게 표시되는 작업이나 작동을 수행하는 서비스로, 사용자가 앱과 직접 상호 작용하지 않을 때에도 실행을 계속할 수 있습니다. 이러한 서비스는 활성 상태임을 사용자에게 인식시키기 위해 시스템 알림을 표시해야 합니다.</p>
<p>포그라운드 서비스를 사용하는 앱의 예시로는 아래와 같은 것들이 있습니다:</p>
<ul>
<li>사용자가 앱을 나갔을 때에도 음악을 재생하는 음악 플레이어 앱(예: Spotify),</li>
<li>폰이 잠겨 있을 때에도 걸음 수를 추적하는 피트니스 앱(예: Google Fit),</li>
<li>운전 방향을 제공하는 네비게이션 앱(예: Google Maps) 등이 있습니다.</li>
</ul>
<div class="content-ad"></div>
<h2>포그라운드 서비스 유형</h2>
<p>Android 10에서는 <code>service</code> 요소 내에 있는 android:foregroundServiceType 속성을 소개했습니다. 이 아이디어는 서비스가 하는 일의 종류를 명시적으로 지정하는 것입니다. 지금까지는 서비스가 위치, 카메라 또는 마이크 권한을 사용하는 경우에만 유형을 지정해야 했습니다.</p>
<p>Android 14에서는 포그라운드 서비스 유형을 지정하는 것이 필수적으로 되었습니다. 이는 포그라운드 서비스의 올바른 사용과 기기 제조업체 간의 일관성을 보장하기 위한 조치입니다.</p>
<p>현재 지원되는 유형은 다음과 같습니다:</p>
<div class="content-ad"></div>
<ul>
<li>카메라 (Android 11에서 필수) — 비디오 통화 앱과 같이 백그라운드에서 카메라에 액세스할 때</li>
<li>connectedDevice — Bluetooth 피트니스 장치와 상호 작용할 때</li>
<li>dataSync — 데이터를 업로드하거나 다운로드할 때, Deprecated될 예정이며 DownloadManager, BackupManager, 또는 WorkManager와 같은 대안을 대신 사용해야 함</li>
<li>health (Android 14에서 새롭게 추가) — 운동 추적 앱과 같은 피트니스 앱용</li>
<li>위치 (Android 10에서 필수) — 위치가 필요한 경우, 네비게이션과 같이</li>
<li>mediaPlayback — Spotify나 Netflix와 같은 앱과 같이 백그라운드에서 오디오 또는 비디오 재생을 계속할 때</li>
<li>mediaProjection — 외부 장치나 화면에 콘텐츠를 투영할 때</li>
<li>마이크 (Android 11에서 필수) — 호출 앱과 같이 백그라운드에서 마이크에 액세스할 때</li>
<li>phoneCall — 계속 중인 통화를 할 때</li>
<li>remoteMessaging (Android 14에서 새롭게 추가) — 한 기기에서 다른 기기로 문자 메시지를 전송할 때</li>
<li>shortService — 중단할 수 없는 중요한 작업을 빠르게 완료해야 할 때, 약 3분 동안만 실행 가능</li>
<li>specialUse — 다른 유형이 사용 사례를 수용하지 못할 때</li>
<li>systemExempted — 시스템 앱을 위해 예약</li>
</ul>
<p>백그라운드 서비스 유형 선언
Android 14를 지원하기 위한 첫 번째 단계는 AndroidManifest 파일에서 서비스 선언을 업데이트하고 올바른 포그라운드 서비스 유형을 지정하는 것입니다.</p>
<p>서비스가 여러 유형을 필요로 하는 경우 다음과 같이 | 연산자를 사용하여 결합할 수 있습니다:</p>
<pre><code class="hljs language-js">&#x3C;manifest <span class="hljs-attr">xmlns</span>:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span> ...>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">service</span>
        <span class="hljs-attr">android:name</span>=<span class="hljs-string">".MyForegroundService"</span>
        <span class="hljs-attr">android:foregroundServiceType</span>=<span class="hljs-string">"camera|location|microphone"</span>
        <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"false"</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">service</span>></span></span>
&#x3C;/manifest>
</code></pre>
<div class="content-ad"></div>
<p>만약 매니페스트에서 해당 서비스의 유형을 선언하지 않고 foreground service를 시작하려고 하면 startForeground()를 호출할 때 시스템에서 MissingForegroundServiceTypeException을 throw할 것입니다.</p>
<h2>특정 foreground service 권한 요청</h2>
<p>Android 9 (API 28)부터 앱은 앱 매니페스트에서 FOREGROUND_SERVICE 권한을 요청해야 했으며, 이는 시스템에서 자동으로 부여되었습니다.</p>
<pre><code class="hljs language-js">&#x3C;uses-permission <span class="hljs-attr">android</span>:name=<span class="hljs-string">"android.permission.FOREGROUND_SERVICE"</span>/>
</code></pre>
<div class="content-ad"></div>
<p>Android 14(API 34)부터 앱은 전경 서비스의 유형에 따라 추가 권한을 요청해야 합니다. 따라서, 서비스가 외부 블루투스 장치에 연결되면 FOREGROUND_SERVICE_CONNECTED_DEVICE를 지정해야 합니다. 시스템에서 권한이 자동으로 부여됩니다.</p>
<pre><code class="hljs language-js">&#x3C;uses-permission <span class="hljs-attr">android</span>:name=<span class="hljs-string">"android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE"</span>/>
</code></pre>
<p>만약 서비스가 여러 유형이 필요하다면, 각 유형마다 해당 권한을 선언해야 합니다.</p>
<p>두 권한 중 하나라도 선언을 잊어버리면, 정확한 이유를 설명하는 SecurityException을 받게 됩니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">java.<span class="hljs-property">lang</span>.<span class="hljs-property">SecurityException</span>: 
     <span class="hljs-title class_">Permission</span> <span class="hljs-title class_">Denial</span>: startForeground <span class="hljs-keyword">from</span> pid=<span class="hljs-number">8589</span>, uid=<span class="hljs-number">10623</span> 
     requires android.<span class="hljs-property">permission</span>.<span class="hljs-property">FOREGROUND_SERVICE</span>

or

java.<span class="hljs-property">lang</span>.<span class="hljs-property">SecurityException</span>: 
     <span class="hljs-title class_">Starting</span> <span class="hljs-variable constant_">FGS</span> <span class="hljs-keyword">with</span> type mediaPlayback targetSDK=<span class="hljs-number">34</span> 
     requires <span class="hljs-attr">permissions</span>: 
        all <span class="hljs-keyword">of</span> the permissions allOf=<span class="hljs-literal">true</span> 
        [android.<span class="hljs-property">permission</span>.<span class="hljs-property">FOREGROUND_SERVICE_MEDIA_PLAYBACK</span>]
</code></pre>
<h2>startForeground() 함수에서 서비스 유형 지정</h2>
<p>manifest에서 foreground service 유형을 선언하는 것 외에도 startForeground() 함수를 호출할 때 이를 명시해야 합니다.</p>
<p>서비스를 foreground에서 실행하려면 서비스 내에서 ServiceCompat.startForeground()를 호출해야 합니다. 보통 onStartCommand()에서 호출됩니다. 이 함수는 서비스, 알림의 ID, 알림 객체, 그리고 서비스가 수행하는 작업을 나타내는 foreground service 유형을 인자로 받습니다.</p>
<div class="content-ad"></div>
<p>안드로이드 이전 버전에서는 foregroundServiceType 인수에 0을 전달하기만 하면 됐었지만, 이제는 매니페스트에 선언된 올바른 타입 또는 타입의 하위 집합을 전달해야 합니다. 사용 사례에 따라 추가된 타입으로 startForeground()를 여러 번 호출하는 것이 가능합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">ServiceCompat</span>.<span class="hljs-title function_">startForeground</span>(
    <span class="hljs-variable language_">this</span>,
    id,
    notification,
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Build</span>.<span class="hljs-property">VERSION</span>.<span class="hljs-property">SDK_INT</span> >= <span class="hljs-title class_">Build</span>.<span class="hljs-property">VERSION_CODES</span>.<span class="hljs-property">R</span>) {
        <span class="hljs-title class_">ServiceInfo</span>.<span class="hljs-property">FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-number">0</span>
    }
)
</code></pre>
<p>foregroundServiceType에 0을 전달하여 startForeground()를 시도하면 예외가 발생합니다:</p>
<pre><code class="hljs language-js">android.<span class="hljs-property">app</span>.<span class="hljs-property">InvalidForegroundServiceTypeException</span>: 
  <span class="hljs-title class_">Starting</span> <span class="hljs-variable constant_">FGS</span> <span class="hljs-keyword">with</span> type none 
  targetSDK=<span class="hljs-number">34</span> has been prohibited
</code></pre>
<div class="content-ad"></div>
<p>만약 매니페스트에 선언하지 않은 타입을 전달하면, 이와 유사한 예외를 받게 됩니다:</p>
<pre><code class="hljs language-js">java.<span class="hljs-property">lang</span>.<span class="hljs-property">IllegalArgumentException</span>: 
  foregroundServiceType <span class="hljs-number">0x00000002</span> is not a subset <span class="hljs-keyword">of</span> 
  foregroundServiceType attribute <span class="hljs-number">0x00000000</span> <span class="hljs-keyword">in</span> service 
  element <span class="hljs-keyword">of</span> manifest file
</code></pre>
<pre><code class="hljs language-js">android.<span class="hljs-property">app</span>.<span class="hljs-property">ForegroundServiceDidNotStartInTimeException</span>: 
  <span class="hljs-title class_">Context</span>.<span class="hljs-title function_">startForegroundService</span>() did not then call <span class="hljs-title class_">Service</span>.<span class="hljs-title function_">startForeground</span>()
</code></pre>
<h2>런타임 권한 요청하기</h2>
<div class="content-ad"></div>
<p>각 전경 서비스 유형에는 필요한 권한 목록이 있습니다. 전경 서비스를 시작하기 전에 필요한 런타임 권한을 요청하고 승인받아야 합니다. 권한이 승인되지 않은 상태에서 서비스를 시작하려고 하면 해당 서비스에서 예외가 발생합니다.</p>
<p>예를 들어, 앱이 백그라운드에 있을 때도 카메라를 사용해야 하는 서비스라면 android.permission.CAMERA 권한을 요청해야 합니다.</p>
<p>그리고 서비스가 Bluetooth 장치에 연결해야 한다면 다음 중 하나 이상의 조건이 성립해야 합니다.</p>
<ul>
<li>매니페스트에 다음 중 하나 이상의 권한을 선언:</li>
<li>CHANGE_NETWORK_STATE</li>
<li>CHANGE_WIFI_STATE</li>
<li>CHANGE_WIFI_MULTICAST_STATE</li>
<li>NFC</li>
<li>TRANSMIT_IR</li>
<li>다음 중 하나 이상의 런타임 권한을 요청하고 승인받아야 합니다:</li>
<li>BLUETOOTH_CONNECT</li>
<li>BLUETOOTH_ADVERTICE</li>
<li>BLUETOOTH_SCAN</li>
<li>UWB_RANGING</li>
<li>UsbManager.requestPermission() 호출하기</li>
</ul>
<div class="content-ad"></div>
<p>만약 서비스 시작 전 조건을 충족하지 않을 경우, 해당 조건이 충족되지 않았다는 정보를 포함한 예외가 발생합니다. 아래 예시에서는 앱이 필요한 권한을 부여받지 못한 상태입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Starting</span> <span class="hljs-variable constant_">FGS</span> <span class="hljs-keyword">with</span> type connectedDevice targetSDK=<span class="hljs-number">34</span> requires <span class="hljs-attr">permissions</span>: 
- all <span class="hljs-keyword">of</span> the permissions allOf=<span class="hljs-literal">true</span> 
  - [android.<span class="hljs-property">permission</span>.<span class="hljs-property">FOREGROUND_SERVICE_CONNECTED_DEVICE</span>] 
- any <span class="hljs-keyword">of</span> the permissions allOf=<span class="hljs-literal">false</span> 
  - [android.<span class="hljs-property">permission</span>.<span class="hljs-property">BLUETOOTH_ADVERTISE</span>, 
     android.<span class="hljs-property">permission</span>.<span class="hljs-property">BLUETOOTH_CONNECT</span>, 
     android.<span class="hljs-property">permission</span>.<span class="hljs-property">BLUETOOTH_SCAN</span>, 
     android.<span class="hljs-property">permission</span>.<span class="hljs-property">CHANGE_NETWORK_STATE</span>, 
     android.<span class="hljs-property">permission</span>.<span class="hljs-property">CHANGE_WIFI_STATE</span>, 
     android.<span class="hljs-property">permission</span>.<span class="hljs-property">CHANGE_WIFI_MULTICAST_STATE</span>, 
     android.<span class="hljs-property">permission</span>.<span class="hljs-property">NFC</span>, 
     android.<span class="hljs-property">permission</span>.<span class="hljs-property">TRANSMIT_IR</span>, 
     android.<span class="hljs-property">permission</span>.<span class="hljs-property">UWB_RANGING</span>, 
     <span class="hljs-variable constant_">USB</span> <span class="hljs-title class_">Device</span>, 
     <span class="hljs-variable constant_">USB</span> <span class="hljs-title class_">Accessory</span>]
</code></pre>
<h2>알림이 올바르게 설정되어 있는지 확인해주세요</h2>
<p>백그라운드 서비스를 시작할 때, 서비스 실행 기간 동안 사용자에게 보여질 알림을 제공해야 합니다. Android 13에서는 알림을 게시하는 런타임 권한이 도입되었는데, 이에 따라 앱이 이 권한을 요청하고 사용자가 명시적으로 부여해야만 알림이 표시됩니다. 그렇지 않으면 알림이 보이지 않습니다.</p>
<div class="content-ad"></div>
<ul>
<li>POST_NOTIFICATIONS 권한을 요청하고 사용자가 수락하면 알림이 정상적으로 표시됩니다.</li>
</ul>
<p><img src="/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_1.png" alt="이미지"></p>
<ul>
<li>권한을 요청하고 사용자가 거부하면 알림이 표시되지 않지만 서비스는 의도한 대로 작동합니다. 사용자들은 작업 관리자에서 백그라운드 작업을 수행하는 앱임을 확인할 수 있습니다.</li>
<li>알림 권한을 요청하지 않고도 알림을 게시하려고 하면, 앞의 내용과 동일하게 앱이 작동합니다.</li>
</ul>
<p><img src="/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_2.png" alt="이미지"></p>
<div class="content-ad"></div>
<h2>Google Play 콘솔의 사용 사례에 대한 세부 정보 제공</h2>
<p>Google Play 콘솔에 새 버전의 앱을 업로드하고 Android 14를 대상으로 하며 foreground service 유형을 사용하는 경우, 콘솔에서 사용법에 대한 추가 세부 정보를 제공하라는 메시지가 표시됩니다.</p>
<p>Google은 앱이 foreground 서비스를 적절하게 사용하고 있는지 확인하기 위해, App content 페이지 (정책 - 앱 콘텐츠)에서 새로운 선언을 제출해야 합니다.</p>
<p>선언한 각 foreground 서비스 유형에 대해 다음을 수행해야 합니다:</p>
<div class="content-ad"></div>
<ul>
<li>어떤 전경 서비스 유형을 사용하는 앱의 기능을 설명합니다.</li>
<li>시스템에 의해 작업이 지연되거나 중단될 경우 사용자에게 미치는 영향을 설명합니다.</li>
<li>각 전경 서비스 기능을 보여주는 비디오 링크를 포함합니다. 비디오에서는 사용자가 앱에서 기능을 트리거하기 위해 취해야 하는 단계를 보여주어야 합니다.</li>
<li>각 전경 서비스 유형에 대한 구체적인 사용 사례를 선택하십시오. 여기에 나열된 사전 설정된 사용 사례 중 하나를 선택하거나 수동으로 입력할 수 있습니다.</li>
</ul>
<h2>삼성 기기를 위한 개선 사항</h2>
<p>삼성은 안드로이드 14 이상을 실행하는 갤럭시 기기에서 전경 서비스가 의도대로 작동하도록 한 통합 정책에 관해 Google와 협력했습니다. 이는 삼성이 34%¹의 시장 점유율을 가지고 있고, 이전에는 전경 서비스가 경우에 따라 Pixels와 같은 기기와 비교했을 때 다르게 작동했기 때문에 통합된 안드로이드 플랫폼으로 나아가는 중요한 한 걸음입니다.</p>
<div class="content-ad"></div>
<p>여기 인용문이 있습니다:</p>
<h1>샘플 앱</h1>
<p>안드로이드 14에서 포그라운드 서비스를 만들고 시작하는 방법을 보여주는 간단한 샘플 앱을 준비했습니다. 다음 기능이 포함되어 있습니다:</p>
<ul>
<li>위치를 포그라운드 서비스 형태로 선언하여 포그라운드 서비스 시작</li>
<li>서비스 시작 전에 위치 권한 요청</li>
<li>Activity에서 포그라운드 서비스에 바인딩하여 서비스 상태를 표시하고 위치 업데이트 수신</li>
<li>액티비티에서 서비스 중지</li>
<li>포그라운드 서비스 알림을 표시하기 위해 알림 권한 요청</li>
</ul>
<div class="content-ad"></div>
<h1>결론</h1>
<p>안드로이드 14에서는 전경 서비스와 관련된 여러 가지 변경 사항이 있어, 앱이 API 34를 대상으로 설정되도록 만들기 위해 개발자들이 추가 작업을 해야 합니다. 가장 큰 변경 사항은 전경 서비스 유형이 이제 필수 요소가 되었는데, 이는 서비스를 시작하기 전에 모든 요구 사항을 충족해야 한다는 것을 의미합니다.</p>
<p>새로운 변경 사항은 전경 서비스에 대해 더 표준화된 접근 방식을 의미하며 다양한 제조업체로부터 더 나은 지원을 기대할 수 있습니다.</p>
<p>이 안내서가 유용했기를 바라며, 샘플 앱을 검토하고 아래 링크된 추가 자료를 확인하여 더 많은 정보를 얻기를 권장합니다.</p>
<div class="content-ad"></div>
<p>자원:</p>
<ul>
<li><a href="https://developer.android.com/develop/background-work/services/foreground-services" rel="nofollow" target="_blank">https://developer.android.com/develop/background-work/services/foreground-services</a> — foreground 서비스에 대한 공식 문서</li>
<li><a href="https://developer.android.com/about/versions/14/changes/fgs-types-required" rel="nofollow" target="_blank">https://developer.android.com/about/versions/14/changes/fgs-types-required</a> — 모든 foreground 서비스 유형에 대한 요구 사항을 자세히 설명합니다.</li>
<li><a href="https://www.droidcon.com/2023/11/15/a-guide-to-using-foreground-services-and-background-work-in-android-14/" rel="nofollow" target="_blank">https://www.droidcon.com/2023/11/15/a-guide-to-using-foreground-services-and-background-work-in-android-14/</a> — 앨리스 유안(Alice Yuan)이 Droidcon London 23에서 진행한 훌륭한 강연. 안드로이드에서 백그라운드 작업을 위한 Google의 공식 가이드라인과 모범 사례를 다룹니다.</li>
</ul>
<p>참고 자료:</p>
<ul>
<li>[1] <a href="https://www.demandsage.com/android-statistics/" rel="nofollow" target="_blank">https://www.demandsage.com/android-statistics/</a></li>
<li>[2] <a href="https://android-developers.googleblog.com/2023/05/improving-consistency-of-background-work-on-android.html" rel="nofollow" target="_blank">https://android-developers.googleblog.com/2023/05/improving-consistency-of-background-work-on-android.html</a></li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"안드로이드 14 포어그라운드 서비스 가이드","description":"","date":"2024-07-01 20:13","slug":"2024-07-01-GuidetoForegroundServicesonAndroid14","content":"\n\n안녕하세요! 안드로이드 14에는 SDK 버전 34를 타겼다면 포그라운드 서비스와 관련된 중요 변경 사항이 포함되어 있습니다. 이 변경 사항을 적용하려면 어떤 작업을 해야 하는지 살펴보겠습니다.\n\n또한 나타날 수 있는 일반적인 예외 상황과 그들을 어떻게 해결할 수 있는지도 다룰 예정입니다.\n\n이 글의 끝에는 포그라운드 서비스를 올바르게 구현하는 방법을 보여주는 샘플 프로젝트도 찾아보실 수 있습니다.\n\n![Foreground Services on Android 14](/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 포그라운드 서비스란 무엇인가요?\n\n포그라운드 서비스는 사용자에게 표시되는 작업이나 작동을 수행하는 서비스로, 사용자가 앱과 직접 상호 작용하지 않을 때에도 실행을 계속할 수 있습니다. 이러한 서비스는 활성 상태임을 사용자에게 인식시키기 위해 시스템 알림을 표시해야 합니다.\n\n포그라운드 서비스를 사용하는 앱의 예시로는 아래와 같은 것들이 있습니다:\n\n- 사용자가 앱을 나갔을 때에도 음악을 재생하는 음악 플레이어 앱(예: Spotify),\n- 폰이 잠겨 있을 때에도 걸음 수를 추적하는 피트니스 앱(예: Google Fit),\n- 운전 방향을 제공하는 네비게이션 앱(예: Google Maps) 등이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 포그라운드 서비스 유형\n\nAndroid 10에서는 `service` 요소 내에 있는 android:foregroundServiceType 속성을 소개했습니다. 이 아이디어는 서비스가 하는 일의 종류를 명시적으로 지정하는 것입니다. 지금까지는 서비스가 위치, 카메라 또는 마이크 권한을 사용하는 경우에만 유형을 지정해야 했습니다.\n\nAndroid 14에서는 포그라운드 서비스 유형을 지정하는 것이 필수적으로 되었습니다. 이는 포그라운드 서비스의 올바른 사용과 기기 제조업체 간의 일관성을 보장하기 위한 조치입니다.\n\n현재 지원되는 유형은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 카메라 (Android 11에서 필수) — 비디오 통화 앱과 같이 백그라운드에서 카메라에 액세스할 때\n- connectedDevice — Bluetooth 피트니스 장치와 상호 작용할 때\n- dataSync — 데이터를 업로드하거나 다운로드할 때, Deprecated될 예정이며 DownloadManager, BackupManager, 또는 WorkManager와 같은 대안을 대신 사용해야 함\n- health (Android 14에서 새롭게 추가) — 운동 추적 앱과 같은 피트니스 앱용\n- 위치 (Android 10에서 필수) — 위치가 필요한 경우, 네비게이션과 같이\n- mediaPlayback — Spotify나 Netflix와 같은 앱과 같이 백그라운드에서 오디오 또는 비디오 재생을 계속할 때\n- mediaProjection — 외부 장치나 화면에 콘텐츠를 투영할 때\n- 마이크 (Android 11에서 필수) — 호출 앱과 같이 백그라운드에서 마이크에 액세스할 때\n- phoneCall — 계속 중인 통화를 할 때\n- remoteMessaging (Android 14에서 새롭게 추가) — 한 기기에서 다른 기기로 문자 메시지를 전송할 때\n- shortService — 중단할 수 없는 중요한 작업을 빠르게 완료해야 할 때, 약 3분 동안만 실행 가능\n- specialUse — 다른 유형이 사용 사례를 수용하지 못할 때\n- systemExempted — 시스템 앱을 위해 예약\n\n백그라운드 서비스 유형 선언\nAndroid 14를 지원하기 위한 첫 번째 단계는 AndroidManifest 파일에서 서비스 선언을 업데이트하고 올바른 포그라운드 서비스 유형을 지정하는 것입니다.\n\n서비스가 여러 유형을 필요로 하는 경우 다음과 같이 | 연산자를 사용하여 결합할 수 있습니다:\n\n```js\n\u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...\u003e\n    \u003cservice\n        android:name=\".MyForegroundService\"\n        android:foregroundServiceType=\"camera|location|microphone\"\n        android:exported=\"false\"\u003e\n    \u003c/service\u003e\n\u003c/manifest\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 매니페스트에서 해당 서비스의 유형을 선언하지 않고 foreground service를 시작하려고 하면 startForeground()를 호출할 때 시스템에서 MissingForegroundServiceTypeException을 throw할 것입니다.\n\n## 특정 foreground service 권한 요청\n\nAndroid 9 (API 28)부터 앱은 앱 매니페스트에서 FOREGROUND_SERVICE 권한을 요청해야 했으며, 이는 시스템에서 자동으로 부여되었습니다.\n\n```js\n\u003cuses-permission android:name=\"android.permission.FOREGROUND_SERVICE\"/\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAndroid 14(API 34)부터 앱은 전경 서비스의 유형에 따라 추가 권한을 요청해야 합니다. 따라서, 서비스가 외부 블루투스 장치에 연결되면 FOREGROUND_SERVICE_CONNECTED_DEVICE를 지정해야 합니다. 시스템에서 권한이 자동으로 부여됩니다.\n\n```js\n\u003cuses-permission android:name=\"android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE\"/\u003e\n```\n\n만약 서비스가 여러 유형이 필요하다면, 각 유형마다 해당 권한을 선언해야 합니다.\n\n두 권한 중 하나라도 선언을 잊어버리면, 정확한 이유를 설명하는 SecurityException을 받게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\njava.lang.SecurityException: \n     Permission Denial: startForeground from pid=8589, uid=10623 \n     requires android.permission.FOREGROUND_SERVICE\n\nor\n\njava.lang.SecurityException: \n     Starting FGS with type mediaPlayback targetSDK=34 \n     requires permissions: \n        all of the permissions allOf=true \n        [android.permission.FOREGROUND_SERVICE_MEDIA_PLAYBACK]\n```\n\n## startForeground() 함수에서 서비스 유형 지정\n\nmanifest에서 foreground service 유형을 선언하는 것 외에도 startForeground() 함수를 호출할 때 이를 명시해야 합니다.\n\n서비스를 foreground에서 실행하려면 서비스 내에서 ServiceCompat.startForeground()를 호출해야 합니다. 보통 onStartCommand()에서 호출됩니다. 이 함수는 서비스, 알림의 ID, 알림 객체, 그리고 서비스가 수행하는 작업을 나타내는 foreground service 유형을 인자로 받습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안드로이드 이전 버전에서는 foregroundServiceType 인수에 0을 전달하기만 하면 됐었지만, 이제는 매니페스트에 선언된 올바른 타입 또는 타입의 하위 집합을 전달해야 합니다. 사용 사례에 따라 추가된 타입으로 startForeground()를 여러 번 호출하는 것이 가능합니다.\n\n```js\nServiceCompat.startForeground(\n    this,\n    id,\n    notification,\n    if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.R) {\n        ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK\n    } else {\n        0\n    }\n)\n```\n\nforegroundServiceType에 0을 전달하여 startForeground()를 시도하면 예외가 발생합니다:\n\n```js\nandroid.app.InvalidForegroundServiceTypeException: \n  Starting FGS with type none \n  targetSDK=34 has been prohibited\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 매니페스트에 선언하지 않은 타입을 전달하면, 이와 유사한 예외를 받게 됩니다:\n\n```js\njava.lang.IllegalArgumentException: \n  foregroundServiceType 0x00000002 is not a subset of \n  foregroundServiceType attribute 0x00000000 in service \n  element of manifest file\n```\n\n```js\nandroid.app.ForegroundServiceDidNotStartInTimeException: \n  Context.startForegroundService() did not then call Service.startForeground()\n```\n\n## 런타임 권한 요청하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 전경 서비스 유형에는 필요한 권한 목록이 있습니다. 전경 서비스를 시작하기 전에 필요한 런타임 권한을 요청하고 승인받아야 합니다. 권한이 승인되지 않은 상태에서 서비스를 시작하려고 하면 해당 서비스에서 예외가 발생합니다.\n\n예를 들어, 앱이 백그라운드에 있을 때도 카메라를 사용해야 하는 서비스라면 android.permission.CAMERA 권한을 요청해야 합니다.\n\n그리고 서비스가 Bluetooth 장치에 연결해야 한다면 다음 중 하나 이상의 조건이 성립해야 합니다.\n\n- 매니페스트에 다음 중 하나 이상의 권한을 선언:\n- CHANGE_NETWORK_STATE\n- CHANGE_WIFI_STATE\n- CHANGE_WIFI_MULTICAST_STATE\n- NFC\n- TRANSMIT_IR\n- 다음 중 하나 이상의 런타임 권한을 요청하고 승인받아야 합니다:\n- BLUETOOTH_CONNECT\n- BLUETOOTH_ADVERTICE\n- BLUETOOTH_SCAN\n- UWB_RANGING\n- UsbManager.requestPermission() 호출하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 서비스 시작 전 조건을 충족하지 않을 경우, 해당 조건이 충족되지 않았다는 정보를 포함한 예외가 발생합니다. 아래 예시에서는 앱이 필요한 권한을 부여받지 못한 상태입니다.\n\n```js\nStarting FGS with type connectedDevice targetSDK=34 requires permissions: \n- all of the permissions allOf=true \n  - [android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE] \n- any of the permissions allOf=false \n  - [android.permission.BLUETOOTH_ADVERTISE, \n     android.permission.BLUETOOTH_CONNECT, \n     android.permission.BLUETOOTH_SCAN, \n     android.permission.CHANGE_NETWORK_STATE, \n     android.permission.CHANGE_WIFI_STATE, \n     android.permission.CHANGE_WIFI_MULTICAST_STATE, \n     android.permission.NFC, \n     android.permission.TRANSMIT_IR, \n     android.permission.UWB_RANGING, \n     USB Device, \n     USB Accessory]\n```\n\n## 알림이 올바르게 설정되어 있는지 확인해주세요\n\n백그라운드 서비스를 시작할 때, 서비스 실행 기간 동안 사용자에게 보여질 알림을 제공해야 합니다. Android 13에서는 알림을 게시하는 런타임 권한이 도입되었는데, 이에 따라 앱이 이 권한을 요청하고 사용자가 명시적으로 부여해야만 알림이 표시됩니다. 그렇지 않으면 알림이 보이지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- POST_NOTIFICATIONS 권한을 요청하고 사용자가 수락하면 알림이 정상적으로 표시됩니다.\n\n![이미지](/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_1.png)\n\n- 권한을 요청하고 사용자가 거부하면 알림이 표시되지 않지만 서비스는 의도한 대로 작동합니다. 사용자들은 작업 관리자에서 백그라운드 작업을 수행하는 앱임을 확인할 수 있습니다.\n- 알림 권한을 요청하지 않고도 알림을 게시하려고 하면, 앞의 내용과 동일하게 앱이 작동합니다.\n\n![이미지](/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Google Play 콘솔의 사용 사례에 대한 세부 정보 제공\n\nGoogle Play 콘솔에 새 버전의 앱을 업로드하고 Android 14를 대상으로 하며 foreground service 유형을 사용하는 경우, 콘솔에서 사용법에 대한 추가 세부 정보를 제공하라는 메시지가 표시됩니다.\n\nGoogle은 앱이 foreground 서비스를 적절하게 사용하고 있는지 확인하기 위해, App content 페이지 (정책 - 앱 콘텐츠)에서 새로운 선언을 제출해야 합니다.\n\n선언한 각 foreground 서비스 유형에 대해 다음을 수행해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 어떤 전경 서비스 유형을 사용하는 앱의 기능을 설명합니다.\n- 시스템에 의해 작업이 지연되거나 중단될 경우 사용자에게 미치는 영향을 설명합니다.\n- 각 전경 서비스 기능을 보여주는 비디오 링크를 포함합니다. 비디오에서는 사용자가 앱에서 기능을 트리거하기 위해 취해야 하는 단계를 보여주어야 합니다.\n- 각 전경 서비스 유형에 대한 구체적인 사용 사례를 선택하십시오. 여기에 나열된 사전 설정된 사용 사례 중 하나를 선택하거나 수동으로 입력할 수 있습니다.\n\n## 삼성 기기를 위한 개선 사항\n\n삼성은 안드로이드 14 이상을 실행하는 갤럭시 기기에서 전경 서비스가 의도대로 작동하도록 한 통합 정책에 관해 Google와 협력했습니다. 이는 삼성이 34%¹의 시장 점유율을 가지고 있고, 이전에는 전경 서비스가 경우에 따라 Pixels와 같은 기기와 비교했을 때 다르게 작동했기 때문에 통합된 안드로이드 플랫폼으로 나아가는 중요한 한 걸음입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 인용문이 있습니다:\n\n# 샘플 앱\n\n안드로이드 14에서 포그라운드 서비스를 만들고 시작하는 방법을 보여주는 간단한 샘플 앱을 준비했습니다. 다음 기능이 포함되어 있습니다:\n\n- 위치를 포그라운드 서비스 형태로 선언하여 포그라운드 서비스 시작\n- 서비스 시작 전에 위치 권한 요청\n- Activity에서 포그라운드 서비스에 바인딩하여 서비스 상태를 표시하고 위치 업데이트 수신\n- 액티비티에서 서비스 중지\n- 포그라운드 서비스 알림을 표시하기 위해 알림 권한 요청\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n안드로이드 14에서는 전경 서비스와 관련된 여러 가지 변경 사항이 있어, 앱이 API 34를 대상으로 설정되도록 만들기 위해 개발자들이 추가 작업을 해야 합니다. 가장 큰 변경 사항은 전경 서비스 유형이 이제 필수 요소가 되었는데, 이는 서비스를 시작하기 전에 모든 요구 사항을 충족해야 한다는 것을 의미합니다.\n\n새로운 변경 사항은 전경 서비스에 대해 더 표준화된 접근 방식을 의미하며 다양한 제조업체로부터 더 나은 지원을 기대할 수 있습니다.\n\n이 안내서가 유용했기를 바라며, 샘플 앱을 검토하고 아래 링크된 추가 자료를 확인하여 더 많은 정보를 얻기를 권장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자원:\n\n- https://developer.android.com/develop/background-work/services/foreground-services — foreground 서비스에 대한 공식 문서\n- https://developer.android.com/about/versions/14/changes/fgs-types-required — 모든 foreground 서비스 유형에 대한 요구 사항을 자세히 설명합니다.\n- https://www.droidcon.com/2023/11/15/a-guide-to-using-foreground-services-and-background-work-in-android-14/ — 앨리스 유안(Alice Yuan)이 Droidcon London 23에서 진행한 훌륭한 강연. 안드로이드에서 백그라운드 작업을 위한 Google의 공식 가이드라인과 모범 사례를 다룹니다.\n\n참고 자료:\n\n- [1] https://www.demandsage.com/android-statistics/\n- [2] https://android-developers.googleblog.com/2023/05/improving-consistency-of-background-work-on-android.html","ogImage":{"url":"/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png"},"coverImage":"/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e안녕하세요! 안드로이드 14에는 SDK 버전 34를 타겼다면 포그라운드 서비스와 관련된 중요 변경 사항이 포함되어 있습니다. 이 변경 사항을 적용하려면 어떤 작업을 해야 하는지 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e또한 나타날 수 있는 일반적인 예외 상황과 그들을 어떻게 해결할 수 있는지도 다룰 예정입니다.\u003c/p\u003e\n\u003cp\u003e이 글의 끝에는 포그라운드 서비스를 올바르게 구현하는 방법을 보여주는 샘플 프로젝트도 찾아보실 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_0.png\" alt=\"Foreground Services on Android 14\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e포그라운드 서비스란 무엇인가요?\u003c/h2\u003e\n\u003cp\u003e포그라운드 서비스는 사용자에게 표시되는 작업이나 작동을 수행하는 서비스로, 사용자가 앱과 직접 상호 작용하지 않을 때에도 실행을 계속할 수 있습니다. 이러한 서비스는 활성 상태임을 사용자에게 인식시키기 위해 시스템 알림을 표시해야 합니다.\u003c/p\u003e\n\u003cp\u003e포그라운드 서비스를 사용하는 앱의 예시로는 아래와 같은 것들이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자가 앱을 나갔을 때에도 음악을 재생하는 음악 플레이어 앱(예: Spotify),\u003c/li\u003e\n\u003cli\u003e폰이 잠겨 있을 때에도 걸음 수를 추적하는 피트니스 앱(예: Google Fit),\u003c/li\u003e\n\u003cli\u003e운전 방향을 제공하는 네비게이션 앱(예: Google Maps) 등이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e포그라운드 서비스 유형\u003c/h2\u003e\n\u003cp\u003eAndroid 10에서는 \u003ccode\u003eservice\u003c/code\u003e 요소 내에 있는 android:foregroundServiceType 속성을 소개했습니다. 이 아이디어는 서비스가 하는 일의 종류를 명시적으로 지정하는 것입니다. 지금까지는 서비스가 위치, 카메라 또는 마이크 권한을 사용하는 경우에만 유형을 지정해야 했습니다.\u003c/p\u003e\n\u003cp\u003eAndroid 14에서는 포그라운드 서비스 유형을 지정하는 것이 필수적으로 되었습니다. 이는 포그라운드 서비스의 올바른 사용과 기기 제조업체 간의 일관성을 보장하기 위한 조치입니다.\u003c/p\u003e\n\u003cp\u003e현재 지원되는 유형은 다음과 같습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e카메라 (Android 11에서 필수) — 비디오 통화 앱과 같이 백그라운드에서 카메라에 액세스할 때\u003c/li\u003e\n\u003cli\u003econnectedDevice — Bluetooth 피트니스 장치와 상호 작용할 때\u003c/li\u003e\n\u003cli\u003edataSync — 데이터를 업로드하거나 다운로드할 때, Deprecated될 예정이며 DownloadManager, BackupManager, 또는 WorkManager와 같은 대안을 대신 사용해야 함\u003c/li\u003e\n\u003cli\u003ehealth (Android 14에서 새롭게 추가) — 운동 추적 앱과 같은 피트니스 앱용\u003c/li\u003e\n\u003cli\u003e위치 (Android 10에서 필수) — 위치가 필요한 경우, 네비게이션과 같이\u003c/li\u003e\n\u003cli\u003emediaPlayback — Spotify나 Netflix와 같은 앱과 같이 백그라운드에서 오디오 또는 비디오 재생을 계속할 때\u003c/li\u003e\n\u003cli\u003emediaProjection — 외부 장치나 화면에 콘텐츠를 투영할 때\u003c/li\u003e\n\u003cli\u003e마이크 (Android 11에서 필수) — 호출 앱과 같이 백그라운드에서 마이크에 액세스할 때\u003c/li\u003e\n\u003cli\u003ephoneCall — 계속 중인 통화를 할 때\u003c/li\u003e\n\u003cli\u003eremoteMessaging (Android 14에서 새롭게 추가) — 한 기기에서 다른 기기로 문자 메시지를 전송할 때\u003c/li\u003e\n\u003cli\u003eshortService — 중단할 수 없는 중요한 작업을 빠르게 완료해야 할 때, 약 3분 동안만 실행 가능\u003c/li\u003e\n\u003cli\u003especialUse — 다른 유형이 사용 사례를 수용하지 못할 때\u003c/li\u003e\n\u003cli\u003esystemExempted — 시스템 앱을 위해 예약\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e백그라운드 서비스 유형 선언\nAndroid 14를 지원하기 위한 첫 번째 단계는 AndroidManifest 파일에서 서비스 선언을 업데이트하고 올바른 포그라운드 서비스 유형을 지정하는 것입니다.\u003c/p\u003e\n\u003cp\u003e서비스가 여러 유형을 필요로 하는 경우 다음과 같이 | 연산자를 사용하여 결합할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;manifest \u003cspan class=\"hljs-attr\"\u003exmlns\u003c/span\u003e:android=\u003cspan class=\"hljs-string\"\u003e\"http://schemas.android.com/apk/res/android\"\u003c/span\u003e ...\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eservice\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eandroid:name\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\".MyForegroundService\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eandroid:foregroundServiceType\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"camera|location|microphone\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eandroid:exported\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"false\"\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eservice\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/manifest\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 매니페스트에서 해당 서비스의 유형을 선언하지 않고 foreground service를 시작하려고 하면 startForeground()를 호출할 때 시스템에서 MissingForegroundServiceTypeException을 throw할 것입니다.\u003c/p\u003e\n\u003ch2\u003e특정 foreground service 권한 요청\u003c/h2\u003e\n\u003cp\u003eAndroid 9 (API 28)부터 앱은 앱 매니페스트에서 FOREGROUND_SERVICE 권한을 요청해야 했으며, 이는 시스템에서 자동으로 부여되었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;uses-permission \u003cspan class=\"hljs-attr\"\u003eandroid\u003c/span\u003e:name=\u003cspan class=\"hljs-string\"\u003e\"android.permission.FOREGROUND_SERVICE\"\u003c/span\u003e/\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eAndroid 14(API 34)부터 앱은 전경 서비스의 유형에 따라 추가 권한을 요청해야 합니다. 따라서, 서비스가 외부 블루투스 장치에 연결되면 FOREGROUND_SERVICE_CONNECTED_DEVICE를 지정해야 합니다. 시스템에서 권한이 자동으로 부여됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;uses-permission \u003cspan class=\"hljs-attr\"\u003eandroid\u003c/span\u003e:name=\u003cspan class=\"hljs-string\"\u003e\"android.permission.FOREGROUND_SERVICE_CONNECTED_DEVICE\"\u003c/span\u003e/\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 서비스가 여러 유형이 필요하다면, 각 유형마다 해당 권한을 선언해야 합니다.\u003c/p\u003e\n\u003cp\u003e두 권한 중 하나라도 선언을 잊어버리면, 정확한 이유를 설명하는 SecurityException을 받게 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ejava.\u003cspan class=\"hljs-property\"\u003elang\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eSecurityException\u003c/span\u003e: \n     \u003cspan class=\"hljs-title class_\"\u003ePermission\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDenial\u003c/span\u003e: startForeground \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e pid=\u003cspan class=\"hljs-number\"\u003e8589\u003c/span\u003e, uid=\u003cspan class=\"hljs-number\"\u003e10623\u003c/span\u003e \n     requires android.\u003cspan class=\"hljs-property\"\u003epermission\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFOREGROUND_SERVICE\u003c/span\u003e\n\nor\n\njava.\u003cspan class=\"hljs-property\"\u003elang\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eSecurityException\u003c/span\u003e: \n     \u003cspan class=\"hljs-title class_\"\u003eStarting\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eFGS\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e type mediaPlayback targetSDK=\u003cspan class=\"hljs-number\"\u003e34\u003c/span\u003e \n     requires \u003cspan class=\"hljs-attr\"\u003epermissions\u003c/span\u003e: \n        all \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e the permissions allOf=\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e \n        [android.\u003cspan class=\"hljs-property\"\u003epermission\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFOREGROUND_SERVICE_MEDIA_PLAYBACK\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003estartForeground() 함수에서 서비스 유형 지정\u003c/h2\u003e\n\u003cp\u003emanifest에서 foreground service 유형을 선언하는 것 외에도 startForeground() 함수를 호출할 때 이를 명시해야 합니다.\u003c/p\u003e\n\u003cp\u003e서비스를 foreground에서 실행하려면 서비스 내에서 ServiceCompat.startForeground()를 호출해야 합니다. 보통 onStartCommand()에서 호출됩니다. 이 함수는 서비스, 알림의 ID, 알림 객체, 그리고 서비스가 수행하는 작업을 나타내는 foreground service 유형을 인자로 받습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e안드로이드 이전 버전에서는 foregroundServiceType 인수에 0을 전달하기만 하면 됐었지만, 이제는 매니페스트에 선언된 올바른 타입 또는 타입의 하위 집합을 전달해야 합니다. 사용 사례에 따라 추가된 타입으로 startForeground()를 여러 번 호출하는 것이 가능합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eServiceCompat\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estartForeground\u003c/span\u003e(\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e,\n    id,\n    notification,\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title class_\"\u003eBuild\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eVERSION\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eSDK_INT\u003c/span\u003e \u003e= \u003cspan class=\"hljs-title class_\"\u003eBuild\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eVERSION_CODES\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eR\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title class_\"\u003eServiceInfo\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK\u003c/span\u003e\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n    }\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eforegroundServiceType에 0을 전달하여 startForeground()를 시도하면 예외가 발생합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eandroid.\u003cspan class=\"hljs-property\"\u003eapp\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eInvalidForegroundServiceTypeException\u003c/span\u003e: \n  \u003cspan class=\"hljs-title class_\"\u003eStarting\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eFGS\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e type none \n  targetSDK=\u003cspan class=\"hljs-number\"\u003e34\u003c/span\u003e has been prohibited\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 매니페스트에 선언하지 않은 타입을 전달하면, 이와 유사한 예외를 받게 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ejava.\u003cspan class=\"hljs-property\"\u003elang\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eIllegalArgumentException\u003c/span\u003e: \n  foregroundServiceType \u003cspan class=\"hljs-number\"\u003e0x00000002\u003c/span\u003e is not a subset \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e \n  foregroundServiceType attribute \u003cspan class=\"hljs-number\"\u003e0x00000000\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e service \n  element \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e manifest file\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eandroid.\u003cspan class=\"hljs-property\"\u003eapp\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eForegroundServiceDidNotStartInTimeException\u003c/span\u003e: \n  \u003cspan class=\"hljs-title class_\"\u003eContext\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estartForegroundService\u003c/span\u003e() did not then call \u003cspan class=\"hljs-title class_\"\u003eService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estartForeground\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e런타임 권한 요청하기\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e각 전경 서비스 유형에는 필요한 권한 목록이 있습니다. 전경 서비스를 시작하기 전에 필요한 런타임 권한을 요청하고 승인받아야 합니다. 권한이 승인되지 않은 상태에서 서비스를 시작하려고 하면 해당 서비스에서 예외가 발생합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 앱이 백그라운드에 있을 때도 카메라를 사용해야 하는 서비스라면 android.permission.CAMERA 권한을 요청해야 합니다.\u003c/p\u003e\n\u003cp\u003e그리고 서비스가 Bluetooth 장치에 연결해야 한다면 다음 중 하나 이상의 조건이 성립해야 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e매니페스트에 다음 중 하나 이상의 권한을 선언:\u003c/li\u003e\n\u003cli\u003eCHANGE_NETWORK_STATE\u003c/li\u003e\n\u003cli\u003eCHANGE_WIFI_STATE\u003c/li\u003e\n\u003cli\u003eCHANGE_WIFI_MULTICAST_STATE\u003c/li\u003e\n\u003cli\u003eNFC\u003c/li\u003e\n\u003cli\u003eTRANSMIT_IR\u003c/li\u003e\n\u003cli\u003e다음 중 하나 이상의 런타임 권한을 요청하고 승인받아야 합니다:\u003c/li\u003e\n\u003cli\u003eBLUETOOTH_CONNECT\u003c/li\u003e\n\u003cli\u003eBLUETOOTH_ADVERTICE\u003c/li\u003e\n\u003cli\u003eBLUETOOTH_SCAN\u003c/li\u003e\n\u003cli\u003eUWB_RANGING\u003c/li\u003e\n\u003cli\u003eUsbManager.requestPermission() 호출하기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 서비스 시작 전 조건을 충족하지 않을 경우, 해당 조건이 충족되지 않았다는 정보를 포함한 예외가 발생합니다. 아래 예시에서는 앱이 필요한 권한을 부여받지 못한 상태입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eStarting\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eFGS\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e type connectedDevice targetSDK=\u003cspan class=\"hljs-number\"\u003e34\u003c/span\u003e requires \u003cspan class=\"hljs-attr\"\u003epermissions\u003c/span\u003e: \n- all \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e the permissions allOf=\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e \n  - [android.\u003cspan class=\"hljs-property\"\u003epermission\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFOREGROUND_SERVICE_CONNECTED_DEVICE\u003c/span\u003e] \n- any \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e the permissions allOf=\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e \n  - [android.\u003cspan class=\"hljs-property\"\u003epermission\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBLUETOOTH_ADVERTISE\u003c/span\u003e, \n     android.\u003cspan class=\"hljs-property\"\u003epermission\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBLUETOOTH_CONNECT\u003c/span\u003e, \n     android.\u003cspan class=\"hljs-property\"\u003epermission\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBLUETOOTH_SCAN\u003c/span\u003e, \n     android.\u003cspan class=\"hljs-property\"\u003epermission\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCHANGE_NETWORK_STATE\u003c/span\u003e, \n     android.\u003cspan class=\"hljs-property\"\u003epermission\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCHANGE_WIFI_STATE\u003c/span\u003e, \n     android.\u003cspan class=\"hljs-property\"\u003epermission\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCHANGE_WIFI_MULTICAST_STATE\u003c/span\u003e, \n     android.\u003cspan class=\"hljs-property\"\u003epermission\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNFC\u003c/span\u003e, \n     android.\u003cspan class=\"hljs-property\"\u003epermission\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eTRANSMIT_IR\u003c/span\u003e, \n     android.\u003cspan class=\"hljs-property\"\u003epermission\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eUWB_RANGING\u003c/span\u003e, \n     \u003cspan class=\"hljs-variable constant_\"\u003eUSB\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDevice\u003c/span\u003e, \n     \u003cspan class=\"hljs-variable constant_\"\u003eUSB\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAccessory\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e알림이 올바르게 설정되어 있는지 확인해주세요\u003c/h2\u003e\n\u003cp\u003e백그라운드 서비스를 시작할 때, 서비스 실행 기간 동안 사용자에게 보여질 알림을 제공해야 합니다. Android 13에서는 알림을 게시하는 런타임 권한이 도입되었는데, 이에 따라 앱이 이 권한을 요청하고 사용자가 명시적으로 부여해야만 알림이 표시됩니다. 그렇지 않으면 알림이 보이지 않습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003ePOST_NOTIFICATIONS 권한을 요청하고 사용자가 수락하면 알림이 정상적으로 표시됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e권한을 요청하고 사용자가 거부하면 알림이 표시되지 않지만 서비스는 의도한 대로 작동합니다. 사용자들은 작업 관리자에서 백그라운드 작업을 수행하는 앱임을 확인할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e알림 권한을 요청하지 않고도 알림을 게시하려고 하면, 앞의 내용과 동일하게 앱이 작동합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-GuidetoForegroundServicesonAndroid14_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003eGoogle Play 콘솔의 사용 사례에 대한 세부 정보 제공\u003c/h2\u003e\n\u003cp\u003eGoogle Play 콘솔에 새 버전의 앱을 업로드하고 Android 14를 대상으로 하며 foreground service 유형을 사용하는 경우, 콘솔에서 사용법에 대한 추가 세부 정보를 제공하라는 메시지가 표시됩니다.\u003c/p\u003e\n\u003cp\u003eGoogle은 앱이 foreground 서비스를 적절하게 사용하고 있는지 확인하기 위해, App content 페이지 (정책 - 앱 콘텐츠)에서 새로운 선언을 제출해야 합니다.\u003c/p\u003e\n\u003cp\u003e선언한 각 foreground 서비스 유형에 대해 다음을 수행해야 합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e어떤 전경 서비스 유형을 사용하는 앱의 기능을 설명합니다.\u003c/li\u003e\n\u003cli\u003e시스템에 의해 작업이 지연되거나 중단될 경우 사용자에게 미치는 영향을 설명합니다.\u003c/li\u003e\n\u003cli\u003e각 전경 서비스 기능을 보여주는 비디오 링크를 포함합니다. 비디오에서는 사용자가 앱에서 기능을 트리거하기 위해 취해야 하는 단계를 보여주어야 합니다.\u003c/li\u003e\n\u003cli\u003e각 전경 서비스 유형에 대한 구체적인 사용 사례를 선택하십시오. 여기에 나열된 사전 설정된 사용 사례 중 하나를 선택하거나 수동으로 입력할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e삼성 기기를 위한 개선 사항\u003c/h2\u003e\n\u003cp\u003e삼성은 안드로이드 14 이상을 실행하는 갤럭시 기기에서 전경 서비스가 의도대로 작동하도록 한 통합 정책에 관해 Google와 협력했습니다. 이는 삼성이 34%¹의 시장 점유율을 가지고 있고, 이전에는 전경 서비스가 경우에 따라 Pixels와 같은 기기와 비교했을 때 다르게 작동했기 때문에 통합된 안드로이드 플랫폼으로 나아가는 중요한 한 걸음입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기 인용문이 있습니다:\u003c/p\u003e\n\u003ch1\u003e샘플 앱\u003c/h1\u003e\n\u003cp\u003e안드로이드 14에서 포그라운드 서비스를 만들고 시작하는 방법을 보여주는 간단한 샘플 앱을 준비했습니다. 다음 기능이 포함되어 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e위치를 포그라운드 서비스 형태로 선언하여 포그라운드 서비스 시작\u003c/li\u003e\n\u003cli\u003e서비스 시작 전에 위치 권한 요청\u003c/li\u003e\n\u003cli\u003eActivity에서 포그라운드 서비스에 바인딩하여 서비스 상태를 표시하고 위치 업데이트 수신\u003c/li\u003e\n\u003cli\u003e액티비티에서 서비스 중지\u003c/li\u003e\n\u003cli\u003e포그라운드 서비스 알림을 표시하기 위해 알림 권한 요청\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e안드로이드 14에서는 전경 서비스와 관련된 여러 가지 변경 사항이 있어, 앱이 API 34를 대상으로 설정되도록 만들기 위해 개발자들이 추가 작업을 해야 합니다. 가장 큰 변경 사항은 전경 서비스 유형이 이제 필수 요소가 되었는데, 이는 서비스를 시작하기 전에 모든 요구 사항을 충족해야 한다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e새로운 변경 사항은 전경 서비스에 대해 더 표준화된 접근 방식을 의미하며 다양한 제조업체로부터 더 나은 지원을 기대할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 안내서가 유용했기를 바라며, 샘플 앱을 검토하고 아래 링크된 추가 자료를 확인하여 더 많은 정보를 얻기를 권장합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e자원:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.android.com/develop/background-work/services/foreground-services\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://developer.android.com/develop/background-work/services/foreground-services\u003c/a\u003e — foreground 서비스에 대한 공식 문서\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.android.com/about/versions/14/changes/fgs-types-required\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://developer.android.com/about/versions/14/changes/fgs-types-required\u003c/a\u003e — 모든 foreground 서비스 유형에 대한 요구 사항을 자세히 설명합니다.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.droidcon.com/2023/11/15/a-guide-to-using-foreground-services-and-background-work-in-android-14/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.droidcon.com/2023/11/15/a-guide-to-using-foreground-services-and-background-work-in-android-14/\u003c/a\u003e — 앨리스 유안(Alice Yuan)이 Droidcon London 23에서 진행한 훌륭한 강연. 안드로이드에서 백그라운드 작업을 위한 Google의 공식 가이드라인과 모범 사례를 다룹니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e참고 자료:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e[1] \u003ca href=\"https://www.demandsage.com/android-statistics/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.demandsage.com/android-statistics/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e[2] \u003ca href=\"https://android-developers.googleblog.com/2023/05/improving-consistency-of-background-work-on-android.html\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://android-developers.googleblog.com/2023/05/improving-consistency-of-background-work-on-android.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-01-GuidetoForegroundServicesonAndroid14"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>