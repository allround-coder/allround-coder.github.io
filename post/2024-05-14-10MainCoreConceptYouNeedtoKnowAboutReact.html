<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트에 대해 꼭 알아야 할 10가지 핵심 개념 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트에 대해 꼭 알아야 할 10가지 핵심 개념 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트에 대해 꼭 알아야 할 10가지 핵심 개념 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact" data-gatsby-head="true"/><meta name="twitter:title" content="리액트에 대해 꼭 알아야 할 10가지 핵심 개념 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 10:45" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_buildManifest.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트에 대해 꼭 알아야 할 10가지 핵심 개념</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트에 대해 꼭 알아야 할 10가지 핵심 개념" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><img src="/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_0.png"/>
<ul>
<li>React Js를 배워야 하는 이유</li>
</ul>
<p>React의 가장 중요한 개념인 JSX, 클래스 및 함수 컴포넌트, 프롭스, 상태, 라이프사이클 메서드 및 훅에 대한 굳은 이해를 갖게 될 것입니다. 이러한 아이디어들을 React의 모듈식 프로그래밍 스타일로 결합할 수 있습니다.</p>
<p>저는 지금까지 React를 사용해왔습니다. 또한 사람들이 처음부터 배우도록 지도하는 훈련을 진행하고 있습니다. 매 훈련 세션마다 같은 개념 세트를 반복해서 설명하고 있다는 것을 알게 되었습니다. 제가 생각하기에 그 개념들은 React를 &quot;구사하려면&quot; 필수적입니다. 지금 학습 중이라면 이 글을 읽는 것에 관심이 있을 것입니다.</p>
<h2>프레임워크가 아닙니다</h2>
<p>Angular나 Ember는 이미 몇 가지 결정이 완료된 프레임워크입니다. React는 라이브러리일 뿐이며 모든 결정을 직접 내려야 합니다. React는 컴포넌트를 사용하여 사용자 인터페이스를 구축하는 데 도움을 주는 데에 중점을 둡니다.</p>
<ol start="2">
<li>JSX 내에서 표현식</li>
</ol>
<p>JSX 내에서 중괄호를 사용하여 어떤 곳에서든 JavaScript 표현식을 포함할 수 있습니다.</p>
<h2>중첩된 JSX 엘리먼트</h2>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> myClasses = (
	<span class="xml"><span class="hljs-tag">&lt;&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.payal.com&quot;</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>가입하기!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
	<span class="hljs-tag">&lt;/&gt;</span></span>
);
</code></pre>
<p>아래 코드 블록에서 <code>a</code> 태그가 가장 바깥에 있는 요소여야 합니다.</p>
<p>JSX는 JavaScript의 구문 확장입니다. React DOM에서 렌더링되는 DOM 요소를 생성하는 데 사용됩니다.</p>
<p>JSX를 포함한 JavaScript 파일은 웹 브라우저에 도달하기 전에 컴파일해야 합니다. 아래 코드 블록은 컴파일이 필요한 일부 예제 JavaScript 코드를 보여줍니다.</p>
<ol start="3">
<li>React Virtual DOM</li>
</ol>
<p>React를 사용하거나 배우고 있다면, &quot;Virtual DOM&quot;이라는 용어를 들어봤을 것입니다. 그렇다면 Virtual DOM은 무엇이고, React가 왜 사용하는 걸까요?</p>
<h2>Virtual DOM</h2>
<p>가상 DOM의 개념이 중요한 이유입니다. 실제 DOM보다 훨씬 뛰어난 성능을 발휘합니다. 가상 DOM은 DOM의 가상 표현입니다. 애플리케이션의 상태가 변경될 때마다 실제 DOM이 아닌 가상 DOM이 업데이트됩니다.</p>
<p>가상 DOM이 훨씬 빠르고 효율적인 이유는 다음과 같습니다.</p>
<h2>가상 DOM이 더 빠른 이유는 무엇인가요?</h2>
<p>UI에 새로운 요소가 추가되면 트리로 표시되는 가상 DOM이 생성됩니다. 각 요소는 이 트리의 노드입니다. 이러한 요소 중 하나의 상태가 변경되면 새로운 가상 DOM 트리가 생성됩니다. 그런 다음이 트리는 이전 가상 DOM 트리와 비교됩니다(&quot;diffed&quot;).</p>
<p>이 작업이 완료되면 가상 DOM은 실제 DOM에 이러한 변경사항을 적용하는 최상의 방법을 계산합니다. 이를 통해 실제 DOM에 대한 작업이 최소화됩니다. 따라서 실제 DOM을 업데이트하는 성능 비용이 줄어듭니다.</p>
<p>아래 이미지는 가상 DOM 트리와 차이 비교 과정을 보여줍니다.</p>
<p><img src="/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_1.png" alt="가상 DOM 트리 및 차이 비교"/></p>
<ol start="4">
<li>React는 어떻게 가상 DOM을 사용할까요?</li>
</ol>
<p>이제 Virtual DOM이 무엇인지에 대한 이해가 어느 정도 되었으니, 어떻게 React가 가상 DOM을 활용하는지 알아보겠습니다.</p>
<p>React에서 모든 UI 조각은 컴포넌트이며, 각 컴포넌트는 상태를 가지고 있습니다. React는 관찰 가능한 패턴을 따르며 상태 변경을 감지합니다. 컴포넌트의 상태가 변경되면 React는 가상 DOM 트리를 업데이트합니다. 가상 DOM이 업데이트된 후, React는 현재 가상 DOM 버전을 이전 가상 DOM 버전과 비교합니다. 이 과정을 &quot;diffing(차이 찾기)&quot;이라고 합니다.</p>
<p>React는 어떤 가상 DOM 객체가 변경되었는지 알고 나면, 실제 DOM에서 해당 객체만 업데이트합니다. 이는 실제 DOM을 직접 조작하는 것과 비교했을 때 성능이 훨씬 우수합니다. 이로 인해 React는 고성능 JavaScript 라이브러리로 인정받게 되었습니다.</p>
<p>이러한 세부 사항은 React 개발자로부터 추상화되어 있습니다. 당신이 해야 할 일은 컴포넌트의 상태를 필요할 때 업데이트하고 나머지는 React가 처리하도록 하는 것뿐입니다. 이는 React를 사용할 때 우수한 개발자 경험을 보장합니다.</p>
<ol start="5">
<li>JSX에서 속성</li>
</ol>
<p>JSX에서 속성을 지정하는 여러 가지 방법이 있습니다.</p>
<p>&#x27;&#x27;. 예를 들어, 다음 JSX에서:</p>
<pre><code class="hljs language-js">&lt;<span class="hljs-title class_">MyComponent</span> foo={<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span>} /&gt;
</code></pre>
<p>MyComponent에 대한 경우, props.foo의 값은 1 + 2 + 3 + 4가 평가되기 때문에 10이 될 것입니다.</p>
<p>자바스크립트에서 if 문과 for 루프는 표현식이 아니기 때문에 JSX에서 직접 사용할 수 없습니다. 대신 주변 코드에 넣을 수 있습니다. 예를 들어:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">NumberDescriber</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-keyword">let</span> description;
  <span class="hljs-keyword">if</span> (props.<span class="hljs-property">number</span> % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
    description = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>even<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span></span>;
  } <span class="hljs-keyword">else</span> {
    description = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>odd<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span>;
  }
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{props.number}는 {description} 숫자입니다<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<p>해당 섹션에서 조건부 렌더링 및 반복문에 대해 더 자세히 알아볼 수 있습니다.</p>
<p>프로퍼티에 값을 전달하지 않으면 true로 기본 설정됩니다. 다음 두 JSX 표현식은 동등합니다:</p>
<pre><code class="hljs language-js">&lt;<span class="hljs-title class_">MyTextBox</span> autocomplete /&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyTextBox</span> <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">{true}</span> /&gt;</span></span>
</code></pre>
<p>일반적으로 프로퍼티에 값을 지정하지 않는 것을 권장하지 않습니다. 왜냐하면 ES6 객체 단축 구문인 &#x27;foo&#x27;가 &#x27;foo: foo&#x27; 대신 &#x27;foo: true&#x27;로 간주될 수 있기 때문입니다. 이 동작은 HTML의 동작과 일치하도록 만들어졌습니다.</p>
<ol start="6">
<li>ReactJS — 컴포넌트</li>
</ol>
<p>이 장에서는 컴포넌트를 결합하여 앱을 유지보수하기 쉽게 만드는 방법을 배울 것입니다. 이 접근 방식을 통해 컴포넌트를 업데이트하고 변경할 수 있습니다. 페이지의 나머지 부분에 영향을 미치지 않으면서 컴포넌트를 업데이트하고 변경할 수 있습니다.</p>
<p>다음 예제에서 첫 번째 컴포넌트는 App입니다. 이 컴포넌트는 Header와 Content의 소유자입니다. 우리는 Header와 Content를 별도로 생성하고 App 컴포넌트의 JSX 트리 내에 추가하기만 하면 됩니다. 내보내기해야 하는 것은 App 컴포넌트뿐입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
   <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> (
         <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Header</span>/&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Content</span>/&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
      );
   }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Header</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
   <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> (
         <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Header<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
      );
   }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Content</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
   <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> (
         <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Content<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>컨텐츠 텍스트!!!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
         <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
      );
   }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<h2>7. Props 및 PropTypes React</h2>
<p>Props와 PropTypes는 React 컴포넌트 간에 정보를 전달하는 중요한 메커니즘입니다. 이번에는 이에 대해 자세히 살펴보도록 하겠습니다. 이 튜토리얼에서는 props, props 전달 및 접근, 그리고 props를 사용하여 어떤 컴포넌트에 정보를 전달하는지에 대한 세부 사항을 소개할 것입니다. 그러나 props를 통해 받는 데이터를 PropTypes를 사용하여 유효성 검사하는 것은 항상 좋은 습관입니다. 따라서 React에서 PropTypes를 어떻게 통합하는지도 배우게 됩니다.</p>
<p>React는 props라고 불리는 것을 사용하여 컴포넌트에 정보를 전달할 수 있도록 합니다 (props는 properties의 약자). React는 여러 컴포넌트로 구성되어 있기 때문에, props를 사용하면 해당 정보가 필요한 컴포넌트 간에 동일한 데이터를 공유할 수 있습니다. 이는 단방향 데이터 흐름(부모에서 자식 컴포넌트로)을 사용합니다. 그러나 콜백 함수를 사용하면 자식 컴포넌트에서 다시 부모 컴포넌트로 props를 전달하는 것이 가능합니다.</p>
<p>이러한 데이터는 숫자, 문자열, 배열, 함수, 객체 등 다양한 형식으로 올 수 있습니다. 우리는 HTML 태그의 속성을 선언하는 것과 같이 어떤 컴포넌트에도 props를 전달할 수 있습니다. 아래 코드를 살펴보세요:</p>
<pre><code class="hljs language-js">&lt;<span class="hljs-title class_">PostList</span> posts={postsList} /&gt;
</code></pre>
<p>이 코드 스니펫에서는 &#x27;postsList&#x27; 값을 가진 posts라는 prop을 PostList라는 컴포넌트로 전달하고 있습니다. 데이터에 액세스하고 전달하는 방법을 알아봅시다.</p>
<ol start="8">
<li>React 앱의 성능 최적화</li>
</ol>
<p>React가 등장한 이후로 프런트엔드 개발자들이 웹 애플리케이션을 구축하는 방식을 변화시켰으며, 가상 DOM은 컴포넌트를 효과적으로 렌더링하는 데 유명합니다. 이 튜토리얼에서는 React 애플리케이션의 성능을 최적화하는 다양한 방법과 성능을 향상시킬 수 있는 React의 기능에 대해 논의할 것입니다.</p>
<p>처음 렌더링 과정에서 React는 컴포넌트들의 DOM 트리를 구성합니다. 따라서 DOM 트리 내에서 데이터가 변경되면 변경에 영향을 받는 컴포넌트들만 다시 렌더링되도록 하고, 변경사항에 영향을 받지 않는 다른 컴포넌트들은 건너뛰도록 React에 요청합니다.</p>
<p>그러나 React에서는 모든 구성 요소를 다시 렌더링할 수 있습니다. 실제로 영향을 받은 구성 요소가 아닌 경우에도 모든 구성 요소를 다시 렌더링할 수 있습니다. 이는 더 오랜로딩 시간이 소요되고, 시간과 CPU 자원이 낭비될 수 있습니다. 이를 방지해야 합니다. 따라서, 우리는 최적화를 위해 노력할 곳입니다.</p>
<ol start="9">
<li>React에서의 상태</li>
</ol>
<p>지금까지 정적 데이터가 구성 요소 트리를 통해 전달되는 정적 구성 요소에 대해서만 논의했습니다. 종종, 시간이 지남에 따라 상태가 변하는 상태지향 구성 요소를 만들어야 합니다.</p>
<p>아래에 표시되는 텍스트를 입력할 수 있는 &quot;input&quot;을 고려해 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">InputBox</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createClass</span>({
getInitialState () {
<span class="hljs-keyword">return</span> {
<span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;&#x27;</span>
}
},
changeText (event) {
<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({<span class="hljs-attr">text</span>: event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>})
},
render () {
<span class="hljs-keyword">return</span> (
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text&#x27;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.changeText}</span>
<span class="hljs-attr">placeholder</span>=<span class="hljs-string">&#x27;text&#x27;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state.text}</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{this.state.text}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
)
}
})
</code></pre>
<p>우선, 컴포넌트의 기본 상태를 설정합니다. 이 경우에는 빈 텍스트 값을 갖고 싶습니다. 컴포넌트 메서드인 getInitialState()를 사용하여 컴포넌트를 위한 상태 객체를 반환해야 합니다.</p>
<p>상태를 업데이트하기 위해 onChange 이벤트에 changeText() 이벤트 핸들러가 할당됩니다. 상태를 업데이트하기 위해서는 내장된 setState() 메서드를 사용해야 합니다.</p>
<p>상태 업데이트는 예약되고 컴포넌트는 다시 렌더링됩니다. setState() 호출은 React에 대기 중인 상태 변경에 대해 알리기 위해 사용되어야 합니다. 변경 사항이 적용되도록 하기 위해 사용되므로 루프가 변경 사항을 추적하지 않습니다.</p>
<p>setState()은 비동기적으로 작동한다는 것을 기억해야 합니다. 결과가 즉시 반영되지 않을 수 있습니다. 아래 예시에서는 상태 변경 즉시 접근하는 나쁜 방법과 좋은 방법을 보여줍니다.</p>
<h3>10. React Hooks</h3>
<p>Hooks는 React 16.8 버전에서 소개된 새로운 기능입니다. 클래스를 작성하지 않고도 상태와 다른 React 기능을 사용할 수 있게 해줍니다. Hooks는 함수 컴포넌트에서 React 상태와 라이프사이클 기능에 &quot;갈고리를 걸어&quot; 사용하는 함수입니다. 클래스 내에서는 작동하지 않습니다.</p>
<p>Hooks는 하위 호환성이 있어서 기존의 React 개념을 대체하지 않고, 변경 사항이 없다는 것을 의미합니다.</p>
<p>함수 컴포넌트를 작성한 후에 상태를 추가하고 싶을 때는 이전에는 클래스로 변환하여 작업했지만, 지금은 기존 함수 컴포넌트 내에서 Hook을 사용하여 할 수 있습니다.</p>
<p>Hook은 JavaScript 함수와 비슷하지만 사용할 때 두 가지 규칙을 따라야 합니다. Hook 규칙을 따르면 컴포넌트의 상태 논리가 해당 소스 코드에 보이도록할 수 있습니다. 이 규칙은 다음과 같습니다:</p>
<ul>
<li>반복문, 조건문 또는 중첩 함수 내에서 Hook을 호출하지 마십시오. React 함수의 최상위 수준에서만 Hook을 사용해야 합니다. 이 규칙은 Hook이 컴포넌트가 렌더링될 때마다 동일한 순서로 호출되도록 보장합니다.</li>
<li>일반 JavaScript 함수에서 Hook을 호출할 수 없습니다. 대신 React 함수 컴포넌트에서 Hook을 호출해야 합니다. Hook은 맞춤 Hook에서도 호출할 수 있습니다.</li>
</ul>
<img src="/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_2.png"/>
<h1>결론</h1>
<p>이제 ReactJs의 핵심 개념을 배웠습니다. 이를 기반으로 조금 더 발전시키고 싶다면, 힘내세요! Cheers!</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트에 대해 꼭 알아야 할 10가지 핵심 개념","description":"","date":"2024-05-14 10:45","slug":"2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_0.png\" /\u003e\n\n- React Js를 배워야 하는 이유\n\nReact의 가장 중요한 개념인 JSX, 클래스 및 함수 컴포넌트, 프롭스, 상태, 라이프사이클 메서드 및 훅에 대한 굳은 이해를 갖게 될 것입니다. 이러한 아이디어들을 React의 모듈식 프로그래밍 스타일로 결합할 수 있습니다.\n\n저는 지금까지 React를 사용해왔습니다. 또한 사람들이 처음부터 배우도록 지도하는 훈련을 진행하고 있습니다. 매 훈련 세션마다 같은 개념 세트를 반복해서 설명하고 있다는 것을 알게 되었습니다. 제가 생각하기에 그 개념들은 React를 \"구사하려면\" 필수적입니다. 지금 학습 중이라면 이 글을 읽는 것에 관심이 있을 것입니다.\n\n\n\n## 프레임워크가 아닙니다\n\nAngular나 Ember는 이미 몇 가지 결정이 완료된 프레임워크입니다. React는 라이브러리일 뿐이며 모든 결정을 직접 내려야 합니다. React는 컴포넌트를 사용하여 사용자 인터페이스를 구축하는 데 도움을 주는 데에 중점을 둡니다.\n\n2. JSX 내에서 표현식\n\nJSX 내에서 중괄호를 사용하여 어떤 곳에서든 JavaScript 표현식을 포함할 수 있습니다.\n\n\n\n## 중첩된 JSX 엘리먼트\n\n```javascript\nconst myClasses = (\n\t\u003c\u003e\n\t\t\u003ca href=\"https://www.payal.com\"\u003e\n\t\t\t\u003ch1\u003e가입하기!\u003c/h1\u003e\n\t\t\u003c/a\u003e\n\t\u003c/\u003e\n);\n```\n\n\n\n아래 코드 블록에서 `a` 태그가 가장 바깥에 있는 요소여야 합니다.\n\nJSX는 JavaScript의 구문 확장입니다. React DOM에서 렌더링되는 DOM 요소를 생성하는 데 사용됩니다.\n\n\n\nJSX를 포함한 JavaScript 파일은 웹 브라우저에 도달하기 전에 컴파일해야 합니다. 아래 코드 블록은 컴파일이 필요한 일부 예제 JavaScript 코드를 보여줍니다.\n\n3. React Virtual DOM\n\nReact를 사용하거나 배우고 있다면, \"Virtual DOM\"이라는 용어를 들어봤을 것입니다. 그렇다면 Virtual DOM은 무엇이고, React가 왜 사용하는 걸까요?\n\n## Virtual DOM\n\n\n\n가상 DOM의 개념이 중요한 이유입니다. 실제 DOM보다 훨씬 뛰어난 성능을 발휘합니다. 가상 DOM은 DOM의 가상 표현입니다. 애플리케이션의 상태가 변경될 때마다 실제 DOM이 아닌 가상 DOM이 업데이트됩니다.\n\n가상 DOM이 훨씬 빠르고 효율적인 이유는 다음과 같습니다.\n\n## 가상 DOM이 더 빠른 이유는 무엇인가요?\n\nUI에 새로운 요소가 추가되면 트리로 표시되는 가상 DOM이 생성됩니다. 각 요소는 이 트리의 노드입니다. 이러한 요소 중 하나의 상태가 변경되면 새로운 가상 DOM 트리가 생성됩니다. 그런 다음이 트리는 이전 가상 DOM 트리와 비교됩니다(\"diffed\").\n\n\n\n이 작업이 완료되면 가상 DOM은 실제 DOM에 이러한 변경사항을 적용하는 최상의 방법을 계산합니다. 이를 통해 실제 DOM에 대한 작업이 최소화됩니다. 따라서 실제 DOM을 업데이트하는 성능 비용이 줄어듭니다.\n\n아래 이미지는 가상 DOM 트리와 차이 비교 과정을 보여줍니다.\n\n![가상 DOM 트리 및 차이 비교](/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_1.png)\n\n4. React는 어떻게 가상 DOM을 사용할까요?\n\n\n\n이제 Virtual DOM이 무엇인지에 대한 이해가 어느 정도 되었으니, 어떻게 React가 가상 DOM을 활용하는지 알아보겠습니다.\n\nReact에서 모든 UI 조각은 컴포넌트이며, 각 컴포넌트는 상태를 가지고 있습니다. React는 관찰 가능한 패턴을 따르며 상태 변경을 감지합니다. 컴포넌트의 상태가 변경되면 React는 가상 DOM 트리를 업데이트합니다. 가상 DOM이 업데이트된 후, React는 현재 가상 DOM 버전을 이전 가상 DOM 버전과 비교합니다. 이 과정을 \"diffing(차이 찾기)\"이라고 합니다.\n\nReact는 어떤 가상 DOM 객체가 변경되었는지 알고 나면, 실제 DOM에서 해당 객체만 업데이트합니다. 이는 실제 DOM을 직접 조작하는 것과 비교했을 때 성능이 훨씬 우수합니다. 이로 인해 React는 고성능 JavaScript 라이브러리로 인정받게 되었습니다.\n\n이러한 세부 사항은 React 개발자로부터 추상화되어 있습니다. 당신이 해야 할 일은 컴포넌트의 상태를 필요할 때 업데이트하고 나머지는 React가 처리하도록 하는 것뿐입니다. 이는 React를 사용할 때 우수한 개발자 경험을 보장합니다.\n\n\n\n5. JSX에서 속성\n\nJSX에서 속성을 지정하는 여러 가지 방법이 있습니다.\n\n''. 예를 들어, 다음 JSX에서:\n\n```js\n\u003cMyComponent foo={1 + 2 + 3 + 4} /\u003e\n```\n\n\n\nMyComponent에 대한 경우, props.foo의 값은 1 + 2 + 3 + 4가 평가되기 때문에 10이 될 것입니다.\n\n자바스크립트에서 if 문과 for 루프는 표현식이 아니기 때문에 JSX에서 직접 사용할 수 없습니다. 대신 주변 코드에 넣을 수 있습니다. 예를 들어:\n\n```js\nfunction NumberDescriber(props) {\n  let description;\n  if (props.number % 2 == 0) {\n    description = \u003cstrong\u003eeven\u003c/strong\u003e;\n  } else {\n    description = \u003ci\u003eodd\u003c/i\u003e;\n  }\n  return \u003cdiv\u003e{props.number}는 {description} 숫자입니다\u003c/div\u003e;\n}\n```\n\n해당 섹션에서 조건부 렌더링 및 반복문에 대해 더 자세히 알아볼 수 있습니다.\n\n\n\n프로퍼티에 값을 전달하지 않으면 true로 기본 설정됩니다. 다음 두 JSX 표현식은 동등합니다:\n\n```js\n\u003cMyTextBox autocomplete /\u003e\n\u003cMyTextBox autocomplete={true} /\u003e\n```\n\n일반적으로 프로퍼티에 값을 지정하지 않는 것을 권장하지 않습니다. 왜냐하면 ES6 객체 단축 구문인 'foo'가 'foo: foo' 대신 'foo: true'로 간주될 수 있기 때문입니다. 이 동작은 HTML의 동작과 일치하도록 만들어졌습니다.\n\n6. ReactJS — 컴포넌트\n\n\n\n이 장에서는 컴포넌트를 결합하여 앱을 유지보수하기 쉽게 만드는 방법을 배울 것입니다. 이 접근 방식을 통해 컴포넌트를 업데이트하고 변경할 수 있습니다. 페이지의 나머지 부분에 영향을 미치지 않으면서 컴포넌트를 업데이트하고 변경할 수 있습니다.\n\n다음 예제에서 첫 번째 컴포넌트는 App입니다. 이 컴포넌트는 Header와 Content의 소유자입니다. 우리는 Header와 Content를 별도로 생성하고 App 컴포넌트의 JSX 트리 내에 추가하기만 하면 됩니다. 내보내기해야 하는 것은 App 컴포넌트뿐입니다.\n\n```js\nimport React from 'react';\nclass App extends React.Component {\n   render() {\n      return (\n         \u003cdiv\u003e\n            \u003cHeader/\u003e\n            \u003cContent/\u003e\n         \u003c/div\u003e\n      );\n   }\n}\nclass Header extends React.Component {\n   render() {\n      return (\n         \u003cdiv\u003e\n            \u003ch1\u003eHeader\u003c/h1\u003e\n         \u003c/div\u003e\n      );\n   }\n}\nclass Content extends React.Component {\n   render() {\n      return (\n         \u003cdiv\u003e\n            \u003ch2\u003eContent\u003c/h2\u003e\n            \u003cp\u003e컨텐츠 텍스트!!!\u003c/p\u003e\n         \u003c/div\u003e\n      );\n   }\n}\nexport default App;\n```\n\n## 7. Props 및 PropTypes React\n\n\n\nProps와 PropTypes는 React 컴포넌트 간에 정보를 전달하는 중요한 메커니즘입니다. 이번에는 이에 대해 자세히 살펴보도록 하겠습니다. 이 튜토리얼에서는 props, props 전달 및 접근, 그리고 props를 사용하여 어떤 컴포넌트에 정보를 전달하는지에 대한 세부 사항을 소개할 것입니다. 그러나 props를 통해 받는 데이터를 PropTypes를 사용하여 유효성 검사하는 것은 항상 좋은 습관입니다. 따라서 React에서 PropTypes를 어떻게 통합하는지도 배우게 됩니다.\n\nReact는 props라고 불리는 것을 사용하여 컴포넌트에 정보를 전달할 수 있도록 합니다 (props는 properties의 약자). React는 여러 컴포넌트로 구성되어 있기 때문에, props를 사용하면 해당 정보가 필요한 컴포넌트 간에 동일한 데이터를 공유할 수 있습니다. 이는 단방향 데이터 흐름(부모에서 자식 컴포넌트로)을 사용합니다. 그러나 콜백 함수를 사용하면 자식 컴포넌트에서 다시 부모 컴포넌트로 props를 전달하는 것이 가능합니다.\n\n이러한 데이터는 숫자, 문자열, 배열, 함수, 객체 등 다양한 형식으로 올 수 있습니다. 우리는 HTML 태그의 속성을 선언하는 것과 같이 어떤 컴포넌트에도 props를 전달할 수 있습니다. 아래 코드를 살펴보세요:\n\n```js\n\u003cPostList posts={postsList} /\u003e\n```\n\n\n\n이 코드 스니펫에서는 'postsList' 값을 가진 posts라는 prop을 PostList라는 컴포넌트로 전달하고 있습니다. 데이터에 액세스하고 전달하는 방법을 알아봅시다.\n\n8. React 앱의 성능 최적화\n\nReact가 등장한 이후로 프런트엔드 개발자들이 웹 애플리케이션을 구축하는 방식을 변화시켰으며, 가상 DOM은 컴포넌트를 효과적으로 렌더링하는 데 유명합니다. 이 튜토리얼에서는 React 애플리케이션의 성능을 최적화하는 다양한 방법과 성능을 향상시킬 수 있는 React의 기능에 대해 논의할 것입니다.\n\n처음 렌더링 과정에서 React는 컴포넌트들의 DOM 트리를 구성합니다. 따라서 DOM 트리 내에서 데이터가 변경되면 변경에 영향을 받는 컴포넌트들만 다시 렌더링되도록 하고, 변경사항에 영향을 받지 않는 다른 컴포넌트들은 건너뛰도록 React에 요청합니다.\n\n\n\n그러나 React에서는 모든 구성 요소를 다시 렌더링할 수 있습니다. 실제로 영향을 받은 구성 요소가 아닌 경우에도 모든 구성 요소를 다시 렌더링할 수 있습니다. 이는 더 오랜로딩 시간이 소요되고, 시간과 CPU 자원이 낭비될 수 있습니다. 이를 방지해야 합니다. 따라서, 우리는 최적화를 위해 노력할 곳입니다.\n\n9. React에서의 상태\n\n지금까지 정적 데이터가 구성 요소 트리를 통해 전달되는 정적 구성 요소에 대해서만 논의했습니다. 종종, 시간이 지남에 따라 상태가 변하는 상태지향 구성 요소를 만들어야 합니다.\n\n아래에 표시되는 텍스트를 입력할 수 있는 \"input\"을 고려해 봅시다.\n\n\n\n```js\nconst InputBox = React.createClass({\ngetInitialState () {\nreturn {\ntext: ''\n}\n},\nchangeText (event) {\nthis.setState({text: event.target.value})\n},\nrender () {\nreturn (\n\u003cdiv\u003e\n\u003cinput type='text' onChange={this.changeText}\nplaceholder='text' value={this.state.text} /\u003e\n\u003cspan\u003e{this.state.text}\u003c/span\u003e\n\u003c/div\u003e\n)\n}\n})\n```\n\n우선, 컴포넌트의 기본 상태를 설정합니다. 이 경우에는 빈 텍스트 값을 갖고 싶습니다. 컴포넌트 메서드인 getInitialState()를 사용하여 컴포넌트를 위한 상태 객체를 반환해야 합니다.\n\n상태를 업데이트하기 위해 onChange 이벤트에 changeText() 이벤트 핸들러가 할당됩니다. 상태를 업데이트하기 위해서는 내장된 setState() 메서드를 사용해야 합니다.\n\n상태 업데이트는 예약되고 컴포넌트는 다시 렌더링됩니다. setState() 호출은 React에 대기 중인 상태 변경에 대해 알리기 위해 사용되어야 합니다. 변경 사항이 적용되도록 하기 위해 사용되므로 루프가 변경 사항을 추적하지 않습니다.\n\n\n\n\nsetState()은 비동기적으로 작동한다는 것을 기억해야 합니다. 결과가 즉시 반영되지 않을 수 있습니다. 아래 예시에서는 상태 변경 즉시 접근하는 나쁜 방법과 좋은 방법을 보여줍니다.\n\n### 10. React Hooks\n\nHooks는 React 16.8 버전에서 소개된 새로운 기능입니다. 클래스를 작성하지 않고도 상태와 다른 React 기능을 사용할 수 있게 해줍니다. Hooks는 함수 컴포넌트에서 React 상태와 라이프사이클 기능에 \"갈고리를 걸어\" 사용하는 함수입니다. 클래스 내에서는 작동하지 않습니다.\n\nHooks는 하위 호환성이 있어서 기존의 React 개념을 대체하지 않고, 변경 사항이 없다는 것을 의미합니다.\n\n\n\n함수 컴포넌트를 작성한 후에 상태를 추가하고 싶을 때는 이전에는 클래스로 변환하여 작업했지만, 지금은 기존 함수 컴포넌트 내에서 Hook을 사용하여 할 수 있습니다.\n\nHook은 JavaScript 함수와 비슷하지만 사용할 때 두 가지 규칙을 따라야 합니다. Hook 규칙을 따르면 컴포넌트의 상태 논리가 해당 소스 코드에 보이도록할 수 있습니다. 이 규칙은 다음과 같습니다:\n\n- 반복문, 조건문 또는 중첩 함수 내에서 Hook을 호출하지 마십시오. React 함수의 최상위 수준에서만 Hook을 사용해야 합니다. 이 규칙은 Hook이 컴포넌트가 렌더링될 때마다 동일한 순서로 호출되도록 보장합니다.\n- 일반 JavaScript 함수에서 Hook을 호출할 수 없습니다. 대신 React 함수 컴포넌트에서 Hook을 호출해야 합니다. Hook은 맞춤 Hook에서도 호출할 수 있습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_2.png\" /\u003e\n\n# 결론\n\n이제 ReactJs의 핵심 개념을 배웠습니다. 이를 기반으로 조금 더 발전시키고 싶다면, 힘내세요! Cheers!","ogImage":{"url":"/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_0.png"},"coverImage":"/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_0.png","tag":["Tech"],"readingTime":8},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    ul: \"ul\",\n    li: \"li\",\n    p: \"p\",\n    h2: \"h2\",\n    ol: \"ol\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    img: \"img\",\n    h3: \"h3\",\n    h1: \"h1\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_0.png\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"React Js를 배워야 하는 이유\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React의 가장 중요한 개념인 JSX, 클래스 및 함수 컴포넌트, 프롭스, 상태, 라이프사이클 메서드 및 훅에 대한 굳은 이해를 갖게 될 것입니다. 이러한 아이디어들을 React의 모듈식 프로그래밍 스타일로 결합할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저는 지금까지 React를 사용해왔습니다. 또한 사람들이 처음부터 배우도록 지도하는 훈련을 진행하고 있습니다. 매 훈련 세션마다 같은 개념 세트를 반복해서 설명하고 있다는 것을 알게 되었습니다. 제가 생각하기에 그 개념들은 React를 \\\"구사하려면\\\" 필수적입니다. 지금 학습 중이라면 이 글을 읽는 것에 관심이 있을 것입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"프레임워크가 아닙니다\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Angular나 Ember는 이미 몇 가지 결정이 완료된 프레임워크입니다. React는 라이브러리일 뿐이며 모든 결정을 직접 내려야 합니다. React는 컴포넌트를 사용하여 사용자 인터페이스를 구축하는 데 도움을 주는 데에 중점을 둡니다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"JSX 내에서 표현식\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"JSX 내에서 중괄호를 사용하여 어떤 곳에서든 JavaScript 표현식을 포함할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"중첩된 JSX 엘리먼트\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-javascript\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" myClasses = (\\n\\t\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-tag\",\n            children: \"\u003c\u003e\"\n          }), \"\\n\\t\\t\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"href\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"https://www.payal.com\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n\\t\\t\\t\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \"\u003e\"]\n          }), \"가입하기!\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \"\u003e\"]\n          }), \"\\n\\t\\t\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \"\u003e\"]\n          }), \"\\n\\t\", _jsx(_components.span, {\n            className: \"hljs-tag\",\n            children: \"\u003c/\u003e\"\n          })]\n        }), \"\\n);\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"아래 코드 블록에서 \", _jsx(_components.code, {\n        children: \"a\"\n      }), \" 태그가 가장 바깥에 있는 요소여야 합니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"JSX는 JavaScript의 구문 확장입니다. React DOM에서 렌더링되는 DOM 요소를 생성하는 데 사용됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"JSX를 포함한 JavaScript 파일은 웹 브라우저에 도달하기 전에 컴파일해야 합니다. 아래 코드 블록은 컴파일이 필요한 일부 예제 JavaScript 코드를 보여줍니다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"React Virtual DOM\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React를 사용하거나 배우고 있다면, \\\"Virtual DOM\\\"이라는 용어를 들어봤을 것입니다. 그렇다면 Virtual DOM은 무엇이고, React가 왜 사용하는 걸까요?\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Virtual DOM\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가상 DOM의 개념이 중요한 이유입니다. 실제 DOM보다 훨씬 뛰어난 성능을 발휘합니다. 가상 DOM은 DOM의 가상 표현입니다. 애플리케이션의 상태가 변경될 때마다 실제 DOM이 아닌 가상 DOM이 업데이트됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가상 DOM이 훨씬 빠르고 효율적인 이유는 다음과 같습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"가상 DOM이 더 빠른 이유는 무엇인가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"UI에 새로운 요소가 추가되면 트리로 표시되는 가상 DOM이 생성됩니다. 각 요소는 이 트리의 노드입니다. 이러한 요소 중 하나의 상태가 변경되면 새로운 가상 DOM 트리가 생성됩니다. 그런 다음이 트리는 이전 가상 DOM 트리와 비교됩니다(\\\"diffed\\\").\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 작업이 완료되면 가상 DOM은 실제 DOM에 이러한 변경사항을 적용하는 최상의 방법을 계산합니다. 이를 통해 실제 DOM에 대한 작업이 최소화됩니다. 따라서 실제 DOM을 업데이트하는 성능 비용이 줄어듭니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래 이미지는 가상 DOM 트리와 차이 비교 과정을 보여줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_1.png\",\n        alt: \"가상 DOM 트리 및 차이 비교\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"4\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"React는 어떻게 가상 DOM을 사용할까요?\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 Virtual DOM이 무엇인지에 대한 이해가 어느 정도 되었으니, 어떻게 React가 가상 DOM을 활용하는지 알아보겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React에서 모든 UI 조각은 컴포넌트이며, 각 컴포넌트는 상태를 가지고 있습니다. React는 관찰 가능한 패턴을 따르며 상태 변경을 감지합니다. 컴포넌트의 상태가 변경되면 React는 가상 DOM 트리를 업데이트합니다. 가상 DOM이 업데이트된 후, React는 현재 가상 DOM 버전을 이전 가상 DOM 버전과 비교합니다. 이 과정을 \\\"diffing(차이 찾기)\\\"이라고 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React는 어떤 가상 DOM 객체가 변경되었는지 알고 나면, 실제 DOM에서 해당 객체만 업데이트합니다. 이는 실제 DOM을 직접 조작하는 것과 비교했을 때 성능이 훨씬 우수합니다. 이로 인해 React는 고성능 JavaScript 라이브러리로 인정받게 되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 세부 사항은 React 개발자로부터 추상화되어 있습니다. 당신이 해야 할 일은 컴포넌트의 상태를 필요할 때 업데이트하고 나머지는 React가 처리하도록 하는 것뿐입니다. 이는 React를 사용할 때 우수한 개발자 경험을 보장합니다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"5\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"JSX에서 속성\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"JSX에서 속성을 지정하는 여러 가지 방법이 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"''. 예를 들어, 다음 JSX에서:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MyComponent\"\n        }), \" foo={\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \"} /\u003e\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"MyComponent에 대한 경우, props.foo의 값은 1 + 2 + 3 + 4가 평가되기 때문에 10이 될 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자바스크립트에서 if 문과 for 루프는 표현식이 아니기 때문에 JSX에서 직접 사용할 수 없습니다. 대신 주변 코드에 넣을 수 있습니다. 예를 들어:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"NumberDescriber\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"props\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" description;\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (props.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"number\"\n        }), \" % \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \") {\\n    description = \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"strong\"\n            }), \"\u003e\"]\n          }), \"even\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"strong\"\n            }), \"\u003e\"]\n          })]\n        }), \";\\n  } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n    description = \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"i\"\n            }), \"\u003e\"]\n          }), \"odd\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"i\"\n            }), \"\u003e\"]\n          })]\n        }), \";\\n  }\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"{props.number}는 {description} 숫자입니다\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"해당 섹션에서 조건부 렌더링 및 반복문에 대해 더 자세히 알아볼 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로퍼티에 값을 전달하지 않으면 true로 기본 설정됩니다. 다음 두 JSX 표현식은 동등합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MyTextBox\"\n        }), \" autocomplete /\u003e\\n\", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"MyTextBox\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"autocomplete\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{true}\"\n            }), \" /\u003e\"]\n          })\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"일반적으로 프로퍼티에 값을 지정하지 않는 것을 권장하지 않습니다. 왜냐하면 ES6 객체 단축 구문인 'foo'가 'foo: foo' 대신 'foo: true'로 간주될 수 있기 때문입니다. 이 동작은 HTML의 동작과 일치하도록 만들어졌습니다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"6\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"ReactJS — 컴포넌트\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 장에서는 컴포넌트를 결합하여 앱을 유지보수하기 쉽게 만드는 방법을 배울 것입니다. 이 접근 방식을 통해 컴포넌트를 업데이트하고 변경할 수 있습니다. 페이지의 나머지 부분에 영향을 미치지 않으면서 컴포넌트를 업데이트하고 변경할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 예제에서 첫 번째 컴포넌트는 App입니다. 이 컴포넌트는 Header와 Content의 소유자입니다. 우리는 Header와 Content를 별도로 생성하고 App 컴포넌트의 JSX 트리 내에 추가하기만 하면 됩니다. 내보내기해야 하는 것은 App 컴포넌트뿐입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"App\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_ inherited__\",\n          children: \"React.Component\"\n        }), \" {\\n   \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"render\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n         \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n            \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Header\"\n            }), \"/\u003e\"]\n          }), \"\\n            \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Content\"\n            }), \"/\u003e\"]\n          }), \"\\n         \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n      );\\n   }\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Header\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_ inherited__\",\n          children: \"React.Component\"\n        }), \" {\\n   \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"render\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n         \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n            \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \"\u003e\"]\n          }), \"Header\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \"\u003e\"]\n          }), \"\\n         \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n      );\\n   }\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Content\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_ inherited__\",\n          children: \"React.Component\"\n        }), \" {\\n   \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"render\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n         \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n            \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h2\"\n            }), \"\u003e\"]\n          }), \"Content\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h2\"\n            }), \"\u003e\"]\n          }), \"\\n            \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"컨텐츠 텍스트!!!\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n         \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n      );\\n   }\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"App\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"7. Props 및 PropTypes React\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Props와 PropTypes는 React 컴포넌트 간에 정보를 전달하는 중요한 메커니즘입니다. 이번에는 이에 대해 자세히 살펴보도록 하겠습니다. 이 튜토리얼에서는 props, props 전달 및 접근, 그리고 props를 사용하여 어떤 컴포넌트에 정보를 전달하는지에 대한 세부 사항을 소개할 것입니다. 그러나 props를 통해 받는 데이터를 PropTypes를 사용하여 유효성 검사하는 것은 항상 좋은 습관입니다. 따라서 React에서 PropTypes를 어떻게 통합하는지도 배우게 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React는 props라고 불리는 것을 사용하여 컴포넌트에 정보를 전달할 수 있도록 합니다 (props는 properties의 약자). React는 여러 컴포넌트로 구성되어 있기 때문에, props를 사용하면 해당 정보가 필요한 컴포넌트 간에 동일한 데이터를 공유할 수 있습니다. 이는 단방향 데이터 흐름(부모에서 자식 컴포넌트로)을 사용합니다. 그러나 콜백 함수를 사용하면 자식 컴포넌트에서 다시 부모 컴포넌트로 props를 전달하는 것이 가능합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 데이터는 숫자, 문자열, 배열, 함수, 객체 등 다양한 형식으로 올 수 있습니다. 우리는 HTML 태그의 속성을 선언하는 것과 같이 어떤 컴포넌트에도 props를 전달할 수 있습니다. 아래 코드를 살펴보세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PostList\"\n        }), \" posts={postsList} /\u003e\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 코드 스니펫에서는 'postsList' 값을 가진 posts라는 prop을 PostList라는 컴포넌트로 전달하고 있습니다. 데이터에 액세스하고 전달하는 방법을 알아봅시다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"8\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"React 앱의 성능 최적화\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React가 등장한 이후로 프런트엔드 개발자들이 웹 애플리케이션을 구축하는 방식을 변화시켰으며, 가상 DOM은 컴포넌트를 효과적으로 렌더링하는 데 유명합니다. 이 튜토리얼에서는 React 애플리케이션의 성능을 최적화하는 다양한 방법과 성능을 향상시킬 수 있는 React의 기능에 대해 논의할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"처음 렌더링 과정에서 React는 컴포넌트들의 DOM 트리를 구성합니다. 따라서 DOM 트리 내에서 데이터가 변경되면 변경에 영향을 받는 컴포넌트들만 다시 렌더링되도록 하고, 변경사항에 영향을 받지 않는 다른 컴포넌트들은 건너뛰도록 React에 요청합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 React에서는 모든 구성 요소를 다시 렌더링할 수 있습니다. 실제로 영향을 받은 구성 요소가 아닌 경우에도 모든 구성 요소를 다시 렌더링할 수 있습니다. 이는 더 오랜로딩 시간이 소요되고, 시간과 CPU 자원이 낭비될 수 있습니다. 이를 방지해야 합니다. 따라서, 우리는 최적화를 위해 노력할 곳입니다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"9\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"React에서의 상태\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금까지 정적 데이터가 구성 요소 트리를 통해 전달되는 정적 구성 요소에 대해서만 논의했습니다. 종종, 시간이 지남에 따라 상태가 변하는 상태지향 구성 요소를 만들어야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래에 표시되는 텍스트를 입력할 수 있는 \\\"input\\\"을 고려해 봅시다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"InputBox\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"createClass\"\n        }), \"({\\ngetInitialState () {\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" {\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"text\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \"\\n}\\n},\\nchangeText (event) {\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setState\"\n        }), \"({\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"text\"\n        }), \": event.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"target\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \"})\\n},\\nrender () {\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"input\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"type\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"'text'\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onChange\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{this.changeText}\"\n            }), \"\\n\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"placeholder\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"'text'\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"value\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{this.state.text}\"\n            }), \" /\u003e\"]\n          }), \"\\n\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"span\"\n            }), \"\u003e\"]\n          }), \"{this.state.text}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"span\"\n            }), \"\u003e\"]\n          }), \"\\n\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n)\\n}\\n})\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우선, 컴포넌트의 기본 상태를 설정합니다. 이 경우에는 빈 텍스트 값을 갖고 싶습니다. 컴포넌트 메서드인 getInitialState()를 사용하여 컴포넌트를 위한 상태 객체를 반환해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"상태를 업데이트하기 위해 onChange 이벤트에 changeText() 이벤트 핸들러가 할당됩니다. 상태를 업데이트하기 위해서는 내장된 setState() 메서드를 사용해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"상태 업데이트는 예약되고 컴포넌트는 다시 렌더링됩니다. setState() 호출은 React에 대기 중인 상태 변경에 대해 알리기 위해 사용되어야 합니다. 변경 사항이 적용되도록 하기 위해 사용되므로 루프가 변경 사항을 추적하지 않습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"setState()은 비동기적으로 작동한다는 것을 기억해야 합니다. 결과가 즉시 반영되지 않을 수 있습니다. 아래 예시에서는 상태 변경 즉시 접근하는 나쁜 방법과 좋은 방법을 보여줍니다.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"10. React Hooks\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Hooks는 React 16.8 버전에서 소개된 새로운 기능입니다. 클래스를 작성하지 않고도 상태와 다른 React 기능을 사용할 수 있게 해줍니다. Hooks는 함수 컴포넌트에서 React 상태와 라이프사이클 기능에 \\\"갈고리를 걸어\\\" 사용하는 함수입니다. 클래스 내에서는 작동하지 않습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Hooks는 하위 호환성이 있어서 기존의 React 개념을 대체하지 않고, 변경 사항이 없다는 것을 의미합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"함수 컴포넌트를 작성한 후에 상태를 추가하고 싶을 때는 이전에는 클래스로 변환하여 작업했지만, 지금은 기존 함수 컴포넌트 내에서 Hook을 사용하여 할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Hook은 JavaScript 함수와 비슷하지만 사용할 때 두 가지 규칙을 따라야 합니다. Hook 규칙을 따르면 컴포넌트의 상태 논리가 해당 소스 코드에 보이도록할 수 있습니다. 이 규칙은 다음과 같습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"반복문, 조건문 또는 중첩 함수 내에서 Hook을 호출하지 마십시오. React 함수의 최상위 수준에서만 Hook을 사용해야 합니다. 이 규칙은 Hook이 컴포넌트가 렌더링될 때마다 동일한 순서로 호출되도록 보장합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"일반 JavaScript 함수에서 Hook을 호출할 수 없습니다. 대신 React 함수 컴포넌트에서 Hook을 호출해야 합니다. Hook은 맞춤 Hook에서도 호출할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact_2.png\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 ReactJs의 핵심 개념을 배웠습니다. 이를 기반으로 조금 더 발전시키고 싶다면, 힘내세요! Cheers!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-10MainCoreConceptYouNeedtoKnowAboutReact"},"buildId":"uXJWf9GNc_Ux38RlnQJQc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>