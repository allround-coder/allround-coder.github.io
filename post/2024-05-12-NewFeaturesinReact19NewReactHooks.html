<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트 19의 새로운 기능 - 새로운 리액트 훅 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-NewFeaturesinReact19NewReactHooks" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트 19의 새로운 기능 - 새로운 리액트 훅 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트 19의 새로운 기능 - 새로운 리액트 훅 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-NewFeaturesinReact19NewReactHooks" data-gatsby-head="true"/><meta name="twitter:title" content="리액트 19의 새로운 기능 - 새로운 리액트 훅 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 21:07" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트 19의 새로운 기능 - 새로운 리액트 훅</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트 19의 새로운 기능 - 새로운 리액트 훅" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-NewFeaturesinReact19NewReactHooks&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>🚀 React 19의 새로운 시대를 탐험하다: 혁명적인 훅의 일단 봐 🌟</p>
<p><img src="/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png" alt="이미지"></p>
<p>안녕하세요, React 팬 여러분! 우리의 컴포넌트와 상호 작용하는 방법을 재정의할 새로운 훅이 등장하는 React 19의 미래로 여행을 떠나 봅시다. React Hooks의 팬이라면, 놀라운 일이 기다리고 있어요!</p>
<p>React Hooks의 진화:</p>
<p>리액트 훅스는 처음 소개된 이후로 게임 체인저 역할을 했어요. 상태 관리와 라이프사이클 메서드를 간편하게 만들어주죠. 만약 리액트의 내장 훅을 사용하거나 사용자 정의 훅을 만들었다면, 당신의 애플리케이션에 가져다주는 힘과 유연성을 고맙게 느낄 거예요.</p>
<p>리액트 19에서는 useMemo, forwardRef, useEffect, useContext의 사용 방법이 바뀔 거에요. 이는 새로운 훅, use가 소개되기 때문이죠.</p>
<p>useMemo()로 간단한 메모이제이션:</p>
<p>주목할만한 변경 중 하나는 useMemo() 훅의 단순화입니다. 리액트 19 이후에는 useMemo()을 명시적으로 사용할 필요가 없어요. 새 리액트 컴파일러가 메모이제이션을 자동으로 처리할 거예요. 이는 더 깨끗한 코드와 향상된 성능을 가져다줘요. 아래 예시에서 보여드릴게요:</p>
<p>React 19 이전:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ExampleComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [inputValue, setInputValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);

  <span class="hljs-comment">// 입력 값이 비어 있는지 확인 결과를 메모이제이션합니다</span>
  <span class="hljs-keyword">const</span> isInputEmpty = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'입력 값이 비어 있는지 확인 중...'</span>);
    <span class="hljs-keyword">return</span> inputValue.<span class="hljs-title function_">trim</span>() === <span class="hljs-string">''</span>;
  }, [inputValue]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span>
        <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
        <span class="hljs-attr">value</span>=<span class="hljs-string">{inputValue}</span>
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> setInputValue(e.target.value)}
        placeholder="뭔가 입력해 보세요..."
      />
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{isInputEmpty ? '입력 값이 비었습니다' : '입력 값이 비어 있지 않습니다'}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ExampleComponent</span>;
</code></pre>
<p>React 19 이후:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ExampleComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [inputValue, setInputValue] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">isInputEmpty</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'입력 값이 비어 있는지 확인 중...'</span>);
    <span class="hljs-keyword">return</span> inputValue.<span class="hljs-title function_">trim</span>() === <span class="hljs-string">''</span>;
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span>
        <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
        <span class="hljs-attr">value</span>=<span class="hljs-string">{inputValue}</span>
        <span class="hljs-attr">onChange</span>=<span class="hljs-string">{(e)</span> =></span> setInputValue(e.target.value)}
        placeholder="뭔가 입력해 보세요..."
      />
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{isInputEmpty ? '입력 값이 비었습니다' : '입력 값이 비어 있지 않습니다'}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ExampleComponent</span>;
</code></pre>
<p>아래 예제에서 확인할 수 있듯이 React19 이후에는 값에 memo를 적용할 필요가 없습니다. React19에서는 이 기능을 자체적으로 처리합니다. 코드가 훨씬 깔끔해졌죠.</p>
<p>forwardRef()로 리팩터링:</p>
<p>React 19에서 forwardRef()를 사용하는 컴포넌트를 리팩터링하는 것은 간단해졌습니다. forwardRef()를 사용하는 대신 ref를 직접 속성으로 전달할 수 있으며, 코드의 복잡성을 줄일 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// React 19 이전</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ExampleButton</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =></span> (
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span>></span>
    {props.children}
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
));

<span class="hljs-comment">// React 19 이후</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">ExampleButton</span> = (<span class="hljs-params">{ ref, children }</span>) => (
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span>></span>
    {children}
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
);
</code></pre>
<p>새로운 'use' Hook을 소개합니다:</p>
<p>React 19에서 가장 흥미로운 추가 기능은 'use' 훅인데요, 이를 통해 우리는 약속, 비동기 코드 및 컨텍스트를 다루는 방법을 단순화할 수 있습니다. 이 훅은 다음 예시에서 보여지는 것처럼 더 깔끔하고 간결한 코드를 작성할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> users = <span class="hljs-title function_">use</span>(<span class="hljs-title function_">fetchUsers</span>());
</code></pre>
<p>'use' 훅을 통해 비동기 작업 및 컨텍스트를 처리하는 새로운 가능성을 엽니다.</p>
<p>아래 코드는 fetch 요청이 ne "use" 훅과 함께 처리되는 방법을 보여줍니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { use } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUsers</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) => {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://jsonplaceholder.typicode.com/users'</span>);
    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">UsersItems</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-keyword">const</span> users = <span class="hljs-title function_">use</span>(<span class="hljs-title function_">fetchUsers</span>());

    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ul</span>></span>
            {users.map((user) => (
                <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{user.id}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'bg-blue-50 p-2 my-4 rounded-lg'</span>></span>
                    <span class="hljs-tag">&#x3C;<span class="hljs-name">h2</span> <span class="hljs-attr">className</span>=<span class="hljs-string">'text-xl font-bold'</span>></span>{user.name}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h2</span>></span>
                    <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{user.email}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
                <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
            ))}
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">ul</span>></span></span>
    );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">UsersItems</span>;
</code></pre>
<p>이 코드는 다음과 같은 방식으로 작동합니다: fetchUsers 함수가 GET 요청을 처리합니다.
use 훅을 사용하여 fetchUsers 함수를 실행합니다. useEffect나 useState 훅을 사용하는 대신에 사용합니다.
useState 훅의 반환값은 사용자가 될 것이고, 이는 GET 요청의 응답(사용자)을 갖게 됩니다.
return 블록에서는 사용자를 사용하여 매핑하고 목록을 생성합니다.</p>
<p>새로운 훅을 사용할 수 있는 다른 곳은 Context입니다. React에서 Context API는 외부 상태 관리 라이브러리를 필요로하지 않고 컴포넌트 전체에서 전역 상태를 효과적으로 관리하는 강력한 방법을 제공합니다. use 훅의 도입으로 Context 작업이 더욱 간단해졌습니다.</p>
<p>표 태그를 마크다운 형식으로 변경하세요.</p>
<p>두 번째 예시는 테이블 태그가 아닌 HTML5로 렌더링된 SVG이미지를 사용하는 방법입니다. HTML5의 캔버스 요소를 사용하여 그래픽을 생성하고 작업할 수 있습니다. 이 예시에서는 표시되는 SVG이미지와 사용된 JavaScript 코드를 확인할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { status } = <span class="hljs-title function_">useFormStatus</span>()
</code></pre>
<p>pending: Form이 보류 상태에 있으면 true가 되고, 그렇지 않으면 false가 됩니다.
data: parent <code>form</code>이 제출하는 데이터가 포함된 FormData 인터페이스를 구현한 객체입니다.
method: HTTP 메소드 — GET 또는 POST. 기본적으로 GET일 것입니다.
action: 함수 참조</p>
<p>useFormStatus()를 사용하여 Form 제출 상태에 따라 UI를 업데이트하는 반응형 Form을 만들 수 있습니다.</p>
<p>다음은 코드 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { useFormStatus } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Submit</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> status = <span class="hljs-title function_">useFormStatus</span>();
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">{status.pending}</span>></span>{status.pending ? '제출 중...' : '제출'}<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">formAction</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) => {
  <span class="hljs-comment">// 2초 지연 시뮬레이션</span>
  <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">3000</span>));
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">FormStatus</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">{formAction}</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Submit</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">form</span>></span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">FormStatus</span>;
</code></pre>
<p>위의 코드에서, 폼을 제출하면 useFormStatus 훅에서 보류 상태를 가져옵니다. 보류 중일 때 UI에 "제출 중..."이라는 텍스트가 표시됩니다. 보류가 false가 되면 "제출"으로 텍스트가 변경됩니다.</p>
<p>useFormState() 훅</p>
<p>useFormState() 훅을 사용하면 폼 제출 결과를 기반으로 상태를 업데이트할 수 있습니다. 이는 특히 폼의 결과에 따라 UI 요소를 업데이트하거나 동작을 트리거하는 데 유용합니다:</p>
<p>여기가 문법입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [state, formAction] = <span class="hljs-title function_">useFormState</span>(fn, initialState, permalink?);
</code></pre>
<p>fn: 폼이 제출되거나 버튼이 눌릴 때 호출되는 함수입니다.
initialState: 상태가 초기에 가질 값입니다. 직렬화 가능한 값이어야 합니다. 이 인수는 처음 액션이 호출된 후 무시됩니다.
permalink: 옵션입니다. fn이 서버에서 실행될 경우 페이지가 permalink으로 리디렉트됩니다.</p>
<p>이 훅은 반환할 것입니다:</p>
<p>초기 상태: initialState로 전달한 값이 초기 상태로 설정됩니다.
formAction: 폼 액션으로 전달될 액션입니다. 이 값의 반환값이 상태에서 사용 가능합니다.</p>
<p>useFormState()를 사용하면 복잡한 상태 관리 로직 없이 폼 상태를 쉽게 관리하고 폼 제출에 기반한 작업을 수행할 수 있습니다.</p>
<p>useOptimistic() 훅:</p>
<p>useOptimistic() 훅을 사용하면 비동기 작업이 진행 중일 때 다른 상태를 표시하여 더 반응성 있는 사용자 경험을 제공할 수 있습니다. 요청이 성공할 것이라 가정하고 즉시 UI를 업데이트하여 서버로부터 응답을 받기 전에도 UI가 갱신됩니다.</p>
<p>여기 문법이에요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [ optimisticMessage, addOptimisticMessage] = <span class="hljs-title function_">useOptimistic</span>(state, updatefn)
</code></pre>
<p>예를 들어, 응답이 오는 중일 때 사용자에게 즉각적인 응답을 제공하기 위해 "상태"를 표시할 수 있어요. 실제 응답이 서버로부터 반환되면 "낙관적" 상태가 그것으로 대체될 거예요.</p>
<p><code>useOptimistic</code> 훅은 요청이 성공할 것으로 가정하고 즉시 UI를 업데이트할 거예요. 이름이 "낙관적"인 이유는 사용자가 작업을 수행하는 낙관적(성공) 결과를 보게 되지만 실제 작업 완료까지 시간이 걸리기 때문이에요.</p>
<p>useOptimistic()을 사용하면 양식의 인지 성능을 향상시키고 사용자에게 즉각적인 피드백을 제공할 수 있습니다.</p>
<p>다음 섹션에서는 useOptimistic 훅의 실제 구현에 대해 실제 예제로 자세히 살펴보겠습니다. 코드 실습과 즐거운 코딩을 기대해주세요!! 🚀</p>
<p>관련 링크</p>
<p>React 19의 새로운 기능</p>
<p>React 19의 새로운 기능 — React 컴파일러</p>
<p>React 19의 새로운 기능 — 서버 컴포넌트</p>
<p>React 19의 새로운 기능 — 액션</p>
<p>React 19의 새로운 기능 — 웹 컴포넌트</p>
<p>React 19의 새로운 기능 — 문서 메타데이터</p>
<p>React 19의 새로운 기능 — 자산 로딩</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트 19의 새로운 기능 - 새로운 리액트 훅","description":"","date":"2024-05-12 21:07","slug":"2024-05-12-NewFeaturesinReact19NewReactHooks","content":"\n\n🚀 React 19의 새로운 시대를 탐험하다: 혁명적인 훅의 일단 봐 🌟\n\n![이미지](/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png)\n\n안녕하세요, React 팬 여러분! 우리의 컴포넌트와 상호 작용하는 방법을 재정의할 새로운 훅이 등장하는 React 19의 미래로 여행을 떠나 봅시다. React Hooks의 팬이라면, 놀라운 일이 기다리고 있어요!\n\nReact Hooks의 진화:\n\n\n\n리액트 훅스는 처음 소개된 이후로 게임 체인저 역할을 했어요. 상태 관리와 라이프사이클 메서드를 간편하게 만들어주죠. 만약 리액트의 내장 훅을 사용하거나 사용자 정의 훅을 만들었다면, 당신의 애플리케이션에 가져다주는 힘과 유연성을 고맙게 느낄 거예요.\n\n리액트 19에서는 useMemo, forwardRef, useEffect, useContext의 사용 방법이 바뀔 거에요. 이는 새로운 훅, use가 소개되기 때문이죠.\n\nuseMemo()로 간단한 메모이제이션:\n\n주목할만한 변경 중 하나는 useMemo() 훅의 단순화입니다. 리액트 19 이후에는 useMemo()을 명시적으로 사용할 필요가 없어요. 새 리액트 컴파일러가 메모이제이션을 자동으로 처리할 거예요. 이는 더 깨끗한 코드와 향상된 성능을 가져다줘요. 아래 예시에서 보여드릴게요:\n\n\n\nReact 19 이전:\n\n```js\nimport React, { useState, useMemo } from 'react';\n\nfunction ExampleComponent() {\n  const [inputValue, setInputValue] = useState('');\n\n  // 입력 값이 비어 있는지 확인 결과를 메모이제이션합니다\n  const isInputEmpty = useMemo(() =\u003e {\n    console.log('입력 값이 비어 있는지 확인 중...');\n    return inputValue.trim() === '';\n  }, [inputValue]);\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) =\u003e setInputValue(e.target.value)}\n        placeholder=\"뭔가 입력해 보세요...\"\n      /\u003e\n      \u003cp\u003e{isInputEmpty ? '입력 값이 비었습니다' : '입력 값이 비어 있지 않습니다'}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default ExampleComponent;\n```\n\nReact 19 이후:\n\n```js\nimport React, { useState } from 'react';\n\nfunction ExampleComponent() {\n  const [inputValue, setInputValue] = useState('');\n\n  const isInputEmpty = () =\u003e {\n    console.log('입력 값이 비어 있는지 확인 중...');\n    return inputValue.trim() === '';\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cinput\n        type=\"text\"\n        value={inputValue}\n        onChange={(e) =\u003e setInputValue(e.target.value)}\n        placeholder=\"뭔가 입력해 보세요...\"\n      /\u003e\n      \u003cp\u003e{isInputEmpty ? '입력 값이 비었습니다' : '입력 값이 비어 있지 않습니다'}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default ExampleComponent;\n```\n\n\n\n아래 예제에서 확인할 수 있듯이 React19 이후에는 값에 memo를 적용할 필요가 없습니다. React19에서는 이 기능을 자체적으로 처리합니다. 코드가 훨씬 깔끔해졌죠.\n\nforwardRef()로 리팩터링:\n\nReact 19에서 forwardRef()를 사용하는 컴포넌트를 리팩터링하는 것은 간단해졌습니다. forwardRef()를 사용하는 대신 ref를 직접 속성으로 전달할 수 있으며, 코드의 복잡성을 줄일 수 있습니다:\n\n```js\n// React 19 이전\nconst ExampleButton = forwardRef((props, ref) =\u003e (\n  \u003cbutton ref={ref}\u003e\n    {props.children}\n  \u003c/button\u003e\n));\n\n// React 19 이후\nconst ExampleButton = ({ ref, children }) =\u003e (\n  \u003cbutton ref={ref}\u003e\n    {children}\n  \u003c/button\u003e\n);\n```\n\n\n\n새로운 'use' Hook을 소개합니다:\n\nReact 19에서 가장 흥미로운 추가 기능은 'use' 훅인데요, 이를 통해 우리는 약속, 비동기 코드 및 컨텍스트를 다루는 방법을 단순화할 수 있습니다. 이 훅은 다음 예시에서 보여지는 것처럼 더 깔끔하고 간결한 코드를 작성할 수 있습니다:\n\n```js\nconst users = use(fetchUsers());\n```\n\n'use' 훅을 통해 비동기 작업 및 컨텍스트를 처리하는 새로운 가능성을 엽니다.\n\n\n\n아래 코드는 fetch 요청이 ne \"use\" 훅과 함께 처리되는 방법을 보여줍니다.\n\n```js\nimport { use } from \"react\";\n\nconst fetchUsers = async () =\u003e {\n    const res = await fetch('https://jsonplaceholder.typicode.com/users');\n    return res.json();\n};\n\nconst UsersItems = () =\u003e {\n    const users = use(fetchUsers());\n\n    return (\n        \u003cul\u003e\n            {users.map((user) =\u003e (\n                \u003cdiv key={user.id} className='bg-blue-50 p-2 my-4 rounded-lg'\u003e\n                    \u003ch2 className='text-xl font-bold'\u003e{user.name}\u003c/h2\u003e\n                    \u003cp\u003e{user.email}\u003c/p\u003e\n                \u003c/div\u003e\n            ))}\n        \u003c/ul\u003e\n    );\n};\n\nexport default UsersItems;\n```\n\n이 코드는 다음과 같은 방식으로 작동합니다: fetchUsers 함수가 GET 요청을 처리합니다.\nuse 훅을 사용하여 fetchUsers 함수를 실행합니다. useEffect나 useState 훅을 사용하는 대신에 사용합니다.\nuseState 훅의 반환값은 사용자가 될 것이고, 이는 GET 요청의 응답(사용자)을 갖게 됩니다.\nreturn 블록에서는 사용자를 사용하여 매핑하고 목록을 생성합니다.\n\n새로운 훅을 사용할 수 있는 다른 곳은 Context입니다. React에서 Context API는 외부 상태 관리 라이브러리를 필요로하지 않고 컴포넌트 전체에서 전역 상태를 효과적으로 관리하는 강력한 방법을 제공합니다. use 훅의 도입으로 Context 작업이 더욱 간단해졌습니다.\n\n\n\n표 태그를 마크다운 형식으로 변경하세요.\n\n\n\n두 번째 예시는 테이블 태그가 아닌 HTML5로 렌더링된 SVG이미지를 사용하는 방법입니다. HTML5의 캔버스 요소를 사용하여 그래픽을 생성하고 작업할 수 있습니다. 이 예시에서는 표시되는 SVG이미지와 사용된 JavaScript 코드를 확인할 수 있습니다.\n\n\n\n```js\nconst { status } = useFormStatus()\n```\n\npending: Form이 보류 상태에 있으면 true가 되고, 그렇지 않으면 false가 됩니다.\ndata: parent `form`이 제출하는 데이터가 포함된 FormData 인터페이스를 구현한 객체입니다.\nmethod: HTTP 메소드 — GET 또는 POST. 기본적으로 GET일 것입니다.\naction: 함수 참조\n\nuseFormStatus()를 사용하여 Form 제출 상태에 따라 UI를 업데이트하는 반응형 Form을 만들 수 있습니다.\n\n다음은 코드 예시입니다:\n\n\n\n```js\nimport { useFormStatus } from \"react-dom\";\n\nfunction Submit() {\n  const status = useFormStatus();\n  return \u003cbutton disabled={status.pending}\u003e{status.pending ? '제출 중...' : '제출'}\u003c/button\u003e;\n}\n\nconst formAction = async () =\u003e {\n  // 2초 지연 시뮬레이션\n  await new Promise((resolve) =\u003e setTimeout(resolve, 3000));\n}\n\nconst FormStatus = () =\u003e {\n  return (\n    \u003cform action={formAction}\u003e\n      \u003cSubmit /\u003e\n    \u003c/form\u003e\n  );\n};\n\nexport default FormStatus;\n```\n\n위의 코드에서, 폼을 제출하면 useFormStatus 훅에서 보류 상태를 가져옵니다. 보류 중일 때 UI에 \"제출 중...\"이라는 텍스트가 표시됩니다. 보류가 false가 되면 \"제출\"으로 텍스트가 변경됩니다.\n\nuseFormState() 훅\n\nuseFormState() 훅을 사용하면 폼 제출 결과를 기반으로 상태를 업데이트할 수 있습니다. 이는 특히 폼의 결과에 따라 UI 요소를 업데이트하거나 동작을 트리거하는 데 유용합니다:\n\n\n\n\n여기가 문법입니다:\n\n```js\nconst [state, formAction] = useFormState(fn, initialState, permalink?);\n```\n\nfn: 폼이 제출되거나 버튼이 눌릴 때 호출되는 함수입니다.\ninitialState: 상태가 초기에 가질 값입니다. 직렬화 가능한 값이어야 합니다. 이 인수는 처음 액션이 호출된 후 무시됩니다.\npermalink: 옵션입니다. fn이 서버에서 실행될 경우 페이지가 permalink으로 리디렉트됩니다.\n\n이 훅은 반환할 것입니다:\n\n\n\n초기 상태: initialState로 전달한 값이 초기 상태로 설정됩니다.\nformAction: 폼 액션으로 전달될 액션입니다. 이 값의 반환값이 상태에서 사용 가능합니다.\n\nuseFormState()를 사용하면 복잡한 상태 관리 로직 없이 폼 상태를 쉽게 관리하고 폼 제출에 기반한 작업을 수행할 수 있습니다.\n\nuseOptimistic() 훅:\n\nuseOptimistic() 훅을 사용하면 비동기 작업이 진행 중일 때 다른 상태를 표시하여 더 반응성 있는 사용자 경험을 제공할 수 있습니다. 요청이 성공할 것이라 가정하고 즉시 UI를 업데이트하여 서버로부터 응답을 받기 전에도 UI가 갱신됩니다.\n\n\n\n여기 문법이에요:\n\n```js\nconst [ optimisticMessage, addOptimisticMessage] = useOptimistic(state, updatefn)\n```\n\n예를 들어, 응답이 오는 중일 때 사용자에게 즉각적인 응답을 제공하기 위해 \"상태\"를 표시할 수 있어요. 실제 응답이 서버로부터 반환되면 \"낙관적\" 상태가 그것으로 대체될 거예요.\n\n`useOptimistic` 훅은 요청이 성공할 것으로 가정하고 즉시 UI를 업데이트할 거예요. 이름이 \"낙관적\"인 이유는 사용자가 작업을 수행하는 낙관적(성공) 결과를 보게 되지만 실제 작업 완료까지 시간이 걸리기 때문이에요.\n\n\n\nuseOptimistic()을 사용하면 양식의 인지 성능을 향상시키고 사용자에게 즉각적인 피드백을 제공할 수 있습니다.\n\n다음 섹션에서는 useOptimistic 훅의 실제 구현에 대해 실제 예제로 자세히 살펴보겠습니다. 코드 실습과 즐거운 코딩을 기대해주세요!! 🚀\n\n관련 링크\n\nReact 19의 새로운 기능\n\n\n\nReact 19의 새로운 기능 — React 컴파일러\n\nReact 19의 새로운 기능 — 서버 컴포넌트\n\nReact 19의 새로운 기능 — 액션\n\nReact 19의 새로운 기능 — 웹 컴포넌트\n\n\n\nReact 19의 새로운 기능 — 문서 메타데이터\n\nReact 19의 새로운 기능 — 자산 로딩","ogImage":{"url":"/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png"},"coverImage":"/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e🚀 React 19의 새로운 시대를 탐험하다: 혁명적인 훅의 일단 봐 🌟\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-NewFeaturesinReact19NewReactHooks_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요, React 팬 여러분! 우리의 컴포넌트와 상호 작용하는 방법을 재정의할 새로운 훅이 등장하는 React 19의 미래로 여행을 떠나 봅시다. React Hooks의 팬이라면, 놀라운 일이 기다리고 있어요!\u003c/p\u003e\n\u003cp\u003eReact Hooks의 진화:\u003c/p\u003e\n\u003cp\u003e리액트 훅스는 처음 소개된 이후로 게임 체인저 역할을 했어요. 상태 관리와 라이프사이클 메서드를 간편하게 만들어주죠. 만약 리액트의 내장 훅을 사용하거나 사용자 정의 훅을 만들었다면, 당신의 애플리케이션에 가져다주는 힘과 유연성을 고맙게 느낄 거예요.\u003c/p\u003e\n\u003cp\u003e리액트 19에서는 useMemo, forwardRef, useEffect, useContext의 사용 방법이 바뀔 거에요. 이는 새로운 훅, use가 소개되기 때문이죠.\u003c/p\u003e\n\u003cp\u003euseMemo()로 간단한 메모이제이션:\u003c/p\u003e\n\u003cp\u003e주목할만한 변경 중 하나는 useMemo() 훅의 단순화입니다. 리액트 19 이후에는 useMemo()을 명시적으로 사용할 필요가 없어요. 새 리액트 컴파일러가 메모이제이션을 자동으로 처리할 거예요. 이는 더 깨끗한 코드와 향상된 성능을 가져다줘요. 아래 예시에서 보여드릴게요:\u003c/p\u003e\n\u003cp\u003eReact 19 이전:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState, useMemo } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eExampleComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [inputValue, setInputValue] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 입력 값이 비어 있는지 확인 결과를 메모이제이션합니다\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isInputEmpty = \u003cspan class=\"hljs-title function_\"\u003euseMemo\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'입력 값이 비어 있는지 확인 중...'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e inputValue.\u003cspan class=\"hljs-title function_\"\u003etrim\u003c/span\u003e() === \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e;\n  }, [inputValue]);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{inputValue}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(e)\u003c/span\u003e =\u003e\u003c/span\u003e setInputValue(e.target.value)}\n        placeholder=\"뭔가 입력해 보세요...\"\n      /\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{isInputEmpty ? '입력 값이 비었습니다' : '입력 값이 비어 있지 않습니다'}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExampleComponent\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReact 19 이후:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eExampleComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [inputValue, setInputValue] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisInputEmpty\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'입력 값이 비어 있는지 확인 중...'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e inputValue.\u003cspan class=\"hljs-title function_\"\u003etrim\u003c/span\u003e() === \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e;\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{inputValue}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(e)\u003c/span\u003e =\u003e\u003c/span\u003e setInputValue(e.target.value)}\n        placeholder=\"뭔가 입력해 보세요...\"\n      /\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{isInputEmpty ? '입력 값이 비었습니다' : '입력 값이 비어 있지 않습니다'}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExampleComponent\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래 예제에서 확인할 수 있듯이 React19 이후에는 값에 memo를 적용할 필요가 없습니다. React19에서는 이 기능을 자체적으로 처리합니다. 코드가 훨씬 깔끔해졌죠.\u003c/p\u003e\n\u003cp\u003eforwardRef()로 리팩터링:\u003c/p\u003e\n\u003cp\u003eReact 19에서 forwardRef()를 사용하는 컴포넌트를 리팩터링하는 것은 간단해졌습니다. forwardRef()를 사용하는 대신 ref를 직접 속성으로 전달할 수 있으며, 코드의 복잡성을 줄일 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// React 19 이전\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExampleButton\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003eforwardRef\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprops, ref\u003c/span\u003e) =\u003e\u003c/span\u003e (\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{ref}\u003c/span\u003e\u003e\u003c/span\u003e\n    {props.children}\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n));\n\n\u003cspan class=\"hljs-comment\"\u003e// React 19 이후\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eExampleButton\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ ref, children }\u003c/span\u003e) =\u003e (\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{ref}\u003c/span\u003e\u003e\u003c/span\u003e\n    {children}\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로운 'use' Hook을 소개합니다:\u003c/p\u003e\n\u003cp\u003eReact 19에서 가장 흥미로운 추가 기능은 'use' 훅인데요, 이를 통해 우리는 약속, 비동기 코드 및 컨텍스트를 다루는 방법을 단순화할 수 있습니다. 이 훅은 다음 예시에서 보여지는 것처럼 더 깔끔하고 간결한 코드를 작성할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = \u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efetchUsers\u003c/span\u003e());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e'use' 훅을 통해 비동기 작업 및 컨텍스트를 처리하는 새로운 가능성을 엽니다.\u003c/p\u003e\n\u003cp\u003e아래 코드는 fetch 요청이 ne \"use\" 훅과 함께 처리되는 방법을 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { use } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchUsers\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://jsonplaceholder.typicode.com/users'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUsersItems\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = \u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efetchUsers\u003c/span\u003e());\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n        \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\n            {users.map((user) =\u003e (\n                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{user.id}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e'bg-blue-50 p-2 my-4 rounded-lg'\u003c/span\u003e\u003e\u003c/span\u003e\n                    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh2\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e'text-xl font-bold'\u003c/span\u003e\u003e\u003c/span\u003e{user.name}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh2\u003c/span\u003e\u003e\u003c/span\u003e\n                    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{user.email}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n            ))}\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n    );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUsersItems\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 다음과 같은 방식으로 작동합니다: fetchUsers 함수가 GET 요청을 처리합니다.\nuse 훅을 사용하여 fetchUsers 함수를 실행합니다. useEffect나 useState 훅을 사용하는 대신에 사용합니다.\nuseState 훅의 반환값은 사용자가 될 것이고, 이는 GET 요청의 응답(사용자)을 갖게 됩니다.\nreturn 블록에서는 사용자를 사용하여 매핑하고 목록을 생성합니다.\u003c/p\u003e\n\u003cp\u003e새로운 훅을 사용할 수 있는 다른 곳은 Context입니다. React에서 Context API는 외부 상태 관리 라이브러리를 필요로하지 않고 컴포넌트 전체에서 전역 상태를 효과적으로 관리하는 강력한 방법을 제공합니다. use 훅의 도입으로 Context 작업이 더욱 간단해졌습니다.\u003c/p\u003e\n\u003cp\u003e표 태그를 마크다운 형식으로 변경하세요.\u003c/p\u003e\n\u003cp\u003e두 번째 예시는 테이블 태그가 아닌 HTML5로 렌더링된 SVG이미지를 사용하는 방법입니다. HTML5의 캔버스 요소를 사용하여 그래픽을 생성하고 작업할 수 있습니다. 이 예시에서는 표시되는 SVG이미지와 사용된 JavaScript 코드를 확인할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { status } = \u003cspan class=\"hljs-title function_\"\u003euseFormStatus\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003epending: Form이 보류 상태에 있으면 true가 되고, 그렇지 않으면 false가 됩니다.\ndata: parent \u003ccode\u003eform\u003c/code\u003e이 제출하는 데이터가 포함된 FormData 인터페이스를 구현한 객체입니다.\nmethod: HTTP 메소드 — GET 또는 POST. 기본적으로 GET일 것입니다.\naction: 함수 참조\u003c/p\u003e\n\u003cp\u003euseFormStatus()를 사용하여 Form 제출 상태에 따라 UI를 업데이트하는 반응형 Form을 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 코드 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useFormStatus } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react-dom\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eSubmit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e status = \u003cspan class=\"hljs-title function_\"\u003euseFormStatus\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edisabled\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{status.pending}\u003c/span\u003e\u003e\u003c/span\u003e{status.pending ? '제출 중...' : '제출'}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eformAction\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 2초 지연 시뮬레이션\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(resolve, \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e));\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eFormStatus\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eform\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{formAction}\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eSubmit\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eform\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormStatus\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 코드에서, 폼을 제출하면 useFormStatus 훅에서 보류 상태를 가져옵니다. 보류 중일 때 UI에 \"제출 중...\"이라는 텍스트가 표시됩니다. 보류가 false가 되면 \"제출\"으로 텍스트가 변경됩니다.\u003c/p\u003e\n\u003cp\u003euseFormState() 훅\u003c/p\u003e\n\u003cp\u003euseFormState() 훅을 사용하면 폼 제출 결과를 기반으로 상태를 업데이트할 수 있습니다. 이는 특히 폼의 결과에 따라 UI 요소를 업데이트하거나 동작을 트리거하는 데 유용합니다:\u003c/p\u003e\n\u003cp\u003e여기가 문법입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [state, formAction] = \u003cspan class=\"hljs-title function_\"\u003euseFormState\u003c/span\u003e(fn, initialState, permalink?);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efn: 폼이 제출되거나 버튼이 눌릴 때 호출되는 함수입니다.\ninitialState: 상태가 초기에 가질 값입니다. 직렬화 가능한 값이어야 합니다. 이 인수는 처음 액션이 호출된 후 무시됩니다.\npermalink: 옵션입니다. fn이 서버에서 실행될 경우 페이지가 permalink으로 리디렉트됩니다.\u003c/p\u003e\n\u003cp\u003e이 훅은 반환할 것입니다:\u003c/p\u003e\n\u003cp\u003e초기 상태: initialState로 전달한 값이 초기 상태로 설정됩니다.\nformAction: 폼 액션으로 전달될 액션입니다. 이 값의 반환값이 상태에서 사용 가능합니다.\u003c/p\u003e\n\u003cp\u003euseFormState()를 사용하면 복잡한 상태 관리 로직 없이 폼 상태를 쉽게 관리하고 폼 제출에 기반한 작업을 수행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003euseOptimistic() 훅:\u003c/p\u003e\n\u003cp\u003euseOptimistic() 훅을 사용하면 비동기 작업이 진행 중일 때 다른 상태를 표시하여 더 반응성 있는 사용자 경험을 제공할 수 있습니다. 요청이 성공할 것이라 가정하고 즉시 UI를 업데이트하여 서버로부터 응답을 받기 전에도 UI가 갱신됩니다.\u003c/p\u003e\n\u003cp\u003e여기 문법이에요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [ optimisticMessage, addOptimisticMessage] = \u003cspan class=\"hljs-title function_\"\u003euseOptimistic\u003c/span\u003e(state, updatefn)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어, 응답이 오는 중일 때 사용자에게 즉각적인 응답을 제공하기 위해 \"상태\"를 표시할 수 있어요. 실제 응답이 서버로부터 반환되면 \"낙관적\" 상태가 그것으로 대체될 거예요.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003euseOptimistic\u003c/code\u003e 훅은 요청이 성공할 것으로 가정하고 즉시 UI를 업데이트할 거예요. 이름이 \"낙관적\"인 이유는 사용자가 작업을 수행하는 낙관적(성공) 결과를 보게 되지만 실제 작업 완료까지 시간이 걸리기 때문이에요.\u003c/p\u003e\n\u003cp\u003euseOptimistic()을 사용하면 양식의 인지 성능을 향상시키고 사용자에게 즉각적인 피드백을 제공할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음 섹션에서는 useOptimistic 훅의 실제 구현에 대해 실제 예제로 자세히 살펴보겠습니다. 코드 실습과 즐거운 코딩을 기대해주세요!! 🚀\u003c/p\u003e\n\u003cp\u003e관련 링크\u003c/p\u003e\n\u003cp\u003eReact 19의 새로운 기능\u003c/p\u003e\n\u003cp\u003eReact 19의 새로운 기능 — React 컴파일러\u003c/p\u003e\n\u003cp\u003eReact 19의 새로운 기능 — 서버 컴포넌트\u003c/p\u003e\n\u003cp\u003eReact 19의 새로운 기능 — 액션\u003c/p\u003e\n\u003cp\u003eReact 19의 새로운 기능 — 웹 컴포넌트\u003c/p\u003e\n\u003cp\u003eReact 19의 새로운 기능 — 문서 메타데이터\u003c/p\u003e\n\u003cp\u003eReact 19의 새로운 기능 — 자산 로딩\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-NewFeaturesinReact19NewReactHooks"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>