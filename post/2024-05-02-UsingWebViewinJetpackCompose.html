<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>제트팩 컴포즈에서 WebView 사용하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-02-UsingWebViewinJetpackCompose" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="제트팩 컴포즈에서 WebView 사용하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="제트팩 컴포즈에서 WebView 사용하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-02-UsingWebViewinJetpackCompose_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-02-UsingWebViewinJetpackCompose" data-gatsby-head="true"/><meta name="twitter:title" content="제트팩 컴포즈에서 WebView 사용하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-02-UsingWebViewinJetpackCompose_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-02 00:21" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">제트팩 컴포즈에서 WebView 사용하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="제트팩 컴포즈에서 WebView 사용하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 2, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-02-UsingWebViewinJetpackCompose&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>웹뷰는 앱 개발에서 자주 사용하는 구성 요소로, 동적 HTML 페이지를 표시하는 데 사용할 수 있습니다. Android View 시스템에서는 XML에 직접 WebView 구성 요소를 추가하여 사용할 수 있지만, Jetpack Compose에는 직접 사용할 수 있는 WebView 구성 요소가 없습니다. 그렇다면 Compose에서 WebView를 어떻게 사용해야 할까요?</p>
<p>이 기사에서는 Jetpack Compose에서 WebView를 사용하는 방법과 기본 기능을 활용하는 방법에 대해 소개하겠습니다.</p>
<h1>권한</h1>
<p>먼저 Android Manifest에 권한을 추가해야 합니다:</p>
<pre><code class="hljs language-js">&#x3C;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">"http://schemas.android.com/tools"</span>></span>

    <span class="hljs-tag">&#x3C;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.INTERNET"</span> /></span>

    <span class="hljs-tag">&#x3C;<span class="hljs-name">application</span>
        <span class="hljs-attr">android:usesCleartextTraffic</span>=<span class="hljs-string">"true"</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">application</span>></span>

<span class="hljs-tag">&#x3C;/<span class="hljs-name">manifest</span>></span></span>
</code></pre>
<h1>AndroidView</h1>
<p>그런 다음 웹 페이지를 표시하는 Composable 컴포넌트를 만들어야 합니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Composable</span>
fun <span class="hljs-title class_">WebView</span>(){
  
    <span class="hljs-comment">// URL을 포함한 문자열 선언</span>
    val mUrl = <span class="hljs-string">"https://www.google.com"</span>
  
    <span class="hljs-comment">// AndroidView 내에 WebView를 추가</span>
    <span class="hljs-comment">// 전체 화면 레이아웃</span>
    <span class="hljs-title class_">AndroidView</span>(factory = {
        <span class="hljs-title class_">WebView</span>(it).<span class="hljs-property">apply</span> {
            layoutParams = <span class="hljs-title class_">ViewGroup</span>.<span class="hljs-title class_">LayoutParams</span>(
                <span class="hljs-title class_">ViewGroup</span>.<span class="hljs-property">LayoutParams</span>.<span class="hljs-property">MATCH_PARENT</span>,
                <span class="hljs-title class_">ViewGroup</span>.<span class="hljs-property">LayoutParams</span>.<span class="hljs-property">MATCH_PARENT</span>
            )
        }
    }, update = {
        it.<span class="hljs-title function_">loadUrl</span>(mUrl)
    })
}
</code></pre>
<p>우리는 AndroidView를 사용하여 WebView 구성 요소를 래핑했습니다. factory 메서드에서는 AndroidX WebView를 디스플레이 구성 요소로 생성하고 그의 layoutParams를 설정합니다. 마지막으로 update 메서드에서 loadUrl 메서드를 사용하여 URL을 로드합니다.</p>
<h1>WebViewClient</h1>
<p>특정 URL을 가로채야 할 때는 어떻게 할까요? View와 유사하게 WebViewClient를 사용자 정의하고 shouldOverrideUrlLoading 메서드를 재정의하면 됩니다.</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@Composable</span>
fun <span class="hljs-title function_">WebView</span><span class="hljs-params">()</span>{
  
    <span class="hljs-comment">// URL을 포함하는 문자열 선언</span>
    <span class="hljs-type">val</span> <span class="hljs-variable">mUrl</span> <span class="hljs-operator">=</span> <span class="hljs-string">"https://www.google.com"</span>
  
    <span class="hljs-comment">// 전체 화면 레이아웃의 AndroidView 내부에 WebView 추가</span>
    AndroidView(factory = {
        WebView(it).apply {
            <span class="hljs-built_in">this</span>.layoutParams = ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.MATCH_PARENT
            )
            <span class="hljs-built_in">this</span>.webViewClient = CustomWebViewClient()
        }
    }, update = {
        it.loadUrl(mUrl)
    })
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomWebViewClient</span>: WebViewClient(){
    override fun <span class="hljs-title function_">shouldOverrideUrlLoading</span><span class="hljs-params">(view: WebView?, url: String?)</span>: Boolean {
        <span class="hljs-keyword">if</span>(url != <span class="hljs-literal">null</span> &#x26;&#x26; url.startsWith(<span class="hljs-string">"https://google.com"</span>)){
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
}
</code></pre>
<h1>WebChromeClient</h1>
<p>더불어, 특정 웹 이벤트를 수신하기 위해 WebChromeClient를 사용자 정의할 수 있습니다:</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@Composable</span>
fun <span class="hljs-title function_">WebView</span><span class="hljs-params">()</span>{
  
    <span class="hljs-comment">// URL을 포함하는 문자열 선언</span>
    <span class="hljs-type">val</span> <span class="hljs-variable">mUrl</span> <span class="hljs-operator">=</span> <span class="hljs-string">"https://www.google.com"</span>
  
    <span class="hljs-comment">// 전체 화면 레이아웃의 AndroidView 내부에 WebView 추가</span>
    AndroidView(factory = {
        WebView(it).apply {
            <span class="hljs-built_in">this</span>.layoutParams = ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.MATCH_PARENT
            )
            <span class="hljs-built_in">this</span>.webChromeClient = CustomWebChromeClient()
        }
    }, update = {
        it.loadUrl(mUrl)
    })
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomWebChromeClient</span> : WebChromeClient() {
    override fun <span class="hljs-title function_">onCloseWindow</span><span class="hljs-params">(window: WebView?)</span> {}
    
    override fun <span class="hljs-title function_">onConsoleMessage</span><span class="hljs-params">(consoleMessage: ConsoleMessage?)</span>: Boolean {}
}
</code></pre>
<h1>라이브러리</h1>
<p>그러나 이 방법은 상태가없는 단일 로드에만 적용됩니다. 만약 우리가 웹페이지의 제목, 로딩 상태 및 현재로드된 URL을 얻어야한다면 어떻게 될까요?</p>
<p>비슷하게, 웹페이지에서 새 링크의 앞뒤로 넘기기 및 로딩을 제어해야하는 경우도 있습니다. 더 복잡한 것은 HTML 코드의 로드를 지원해야하는 경우입니다.</p>
<p>다행히도 이미 이러한 기능을 제공하는 라이브러리가 있었습니다. Compose 내에서 직접 사용할 수있는 WebView 구성 요소를 제공하여 개발자가 WebView의 캡슐화 논리를 직접 작성할 필요가 없게합니다. 또한 웹 페이지 속성을 가져 오고 로딩 상태를 수신하는 기능과 같은 기능을 제공하여, 모두 사용 가능합니다.</p>
<p>기본적인 사용법은 아래와 같이 매우 간단합니다. URL을 로드하고 표시하는 데 사용할 수 있습니다.</p>
<pre><code class="hljs language-js">val state = <span class="hljs-title function_">rememberWebViewState</span>(<span class="hljs-string">"https://example.com"</span>)

<span class="hljs-title class_">WebView</span>(
    state
)
</code></pre>
<p>자세한 사용 방법은 다음 기사를 참조해 주세요:</p>
<h1>이어서 읽을 내용</h1>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"제트팩 컴포즈에서 WebView 사용하기","description":"","date":"2024-05-02 00:21","slug":"2024-05-02-UsingWebViewinJetpackCompose","content":"\n\n\u003cimg src=\"/assets/img/2024-05-02-UsingWebViewinJetpackCompose_0.png\" /\u003e\n\n웹뷰는 앱 개발에서 자주 사용하는 구성 요소로, 동적 HTML 페이지를 표시하는 데 사용할 수 있습니다. Android View 시스템에서는 XML에 직접 WebView 구성 요소를 추가하여 사용할 수 있지만, Jetpack Compose에는 직접 사용할 수 있는 WebView 구성 요소가 없습니다. 그렇다면 Compose에서 WebView를 어떻게 사용해야 할까요?\n\n이 기사에서는 Jetpack Compose에서 WebView를 사용하는 방법과 기본 기능을 활용하는 방법에 대해 소개하겠습니다.\n\n# 권한\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 Android Manifest에 권한을 추가해야 합니다:\n\n```js\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\u003e\n\n    \u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e\n\n    \u003capplication\n        android:usesCleartextTraffic=\"true\"\u003e\n    \u003c/application\u003e\n\n\u003c/manifest\u003e\n```\n\n# AndroidView\n\n그런 다음 웹 페이지를 표시하는 Composable 컴포넌트를 만들어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@Composable\nfun WebView(){\n  \n    // URL을 포함한 문자열 선언\n    val mUrl = \"https://www.google.com\"\n  \n    // AndroidView 내에 WebView를 추가\n    // 전체 화면 레이아웃\n    AndroidView(factory = {\n        WebView(it).apply {\n            layoutParams = ViewGroup.LayoutParams(\n                ViewGroup.LayoutParams.MATCH_PARENT,\n                ViewGroup.LayoutParams.MATCH_PARENT\n            )\n        }\n    }, update = {\n        it.loadUrl(mUrl)\n    })\n}\n```\n\n우리는 AndroidView를 사용하여 WebView 구성 요소를 래핑했습니다. factory 메서드에서는 AndroidX WebView를 디스플레이 구성 요소로 생성하고 그의 layoutParams를 설정합니다. 마지막으로 update 메서드에서 loadUrl 메서드를 사용하여 URL을 로드합니다.\n\n# WebViewClient\n\n특정 URL을 가로채야 할 때는 어떻게 할까요? View와 유사하게 WebViewClient를 사용자 정의하고 shouldOverrideUrlLoading 메서드를 재정의하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\n@Composable\nfun WebView(){\n  \n    // URL을 포함하는 문자열 선언\n    val mUrl = \"https://www.google.com\"\n  \n    // 전체 화면 레이아웃의 AndroidView 내부에 WebView 추가\n    AndroidView(factory = {\n        WebView(it).apply {\n            this.layoutParams = ViewGroup.LayoutParams(\n                ViewGroup.LayoutParams.MATCH_PARENT,\n                ViewGroup.LayoutParams.MATCH_PARENT\n            )\n            this.webViewClient = CustomWebViewClient()\n        }\n    }, update = {\n        it.loadUrl(mUrl)\n    })\n}\n\nclass CustomWebViewClient: WebViewClient(){\n    override fun shouldOverrideUrlLoading(view: WebView?, url: String?): Boolean {\n        if(url != null \u0026\u0026 url.startsWith(\"https://google.com\")){\n            return true\n        }\n        return false\n    }\n}\n```\n\n# WebChromeClient\n\n더불어, 특정 웹 이벤트를 수신하기 위해 WebChromeClient를 사용자 정의할 수 있습니다:\n\n```java\n@Composable\nfun WebView(){\n  \n    // URL을 포함하는 문자열 선언\n    val mUrl = \"https://www.google.com\"\n  \n    // 전체 화면 레이아웃의 AndroidView 내부에 WebView 추가\n    AndroidView(factory = {\n        WebView(it).apply {\n            this.layoutParams = ViewGroup.LayoutParams(\n                ViewGroup.LayoutParams.MATCH_PARENT,\n                ViewGroup.LayoutParams.MATCH_PARENT\n            )\n            this.webChromeClient = CustomWebChromeClient()\n        }\n    }, update = {\n        it.loadUrl(mUrl)\n    })\n}\n\nclass CustomWebChromeClient : WebChromeClient() {\n    override fun onCloseWindow(window: WebView?) {}\n    \n    override fun onConsoleMessage(consoleMessage: ConsoleMessage?): Boolean {}\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 라이브러리\n\n그러나 이 방법은 상태가없는 단일 로드에만 적용됩니다. 만약 우리가 웹페이지의 제목, 로딩 상태 및 현재로드된 URL을 얻어야한다면 어떻게 될까요?\n\n비슷하게, 웹페이지에서 새 링크의 앞뒤로 넘기기 및 로딩을 제어해야하는 경우도 있습니다. 더 복잡한 것은 HTML 코드의 로드를 지원해야하는 경우입니다.\n\n다행히도 이미 이러한 기능을 제공하는 라이브러리가 있었습니다. Compose 내에서 직접 사용할 수있는 WebView 구성 요소를 제공하여 개발자가 WebView의 캡슐화 논리를 직접 작성할 필요가 없게합니다. 또한 웹 페이지 속성을 가져 오고 로딩 상태를 수신하는 기능과 같은 기능을 제공하여, 모두 사용 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적인 사용법은 아래와 같이 매우 간단합니다. URL을 로드하고 표시하는 데 사용할 수 있습니다.\n\n```js\nval state = rememberWebViewState(\"https://example.com\")\n\nWebView(\n    state\n)\n```\n\n자세한 사용 방법은 다음 기사를 참조해 주세요:\n\n# 이어서 읽을 내용","ogImage":{"url":"/assets/img/2024-05-02-UsingWebViewinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-02-UsingWebViewinJetpackCompose_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e웹뷰는 앱 개발에서 자주 사용하는 구성 요소로, 동적 HTML 페이지를 표시하는 데 사용할 수 있습니다. Android View 시스템에서는 XML에 직접 WebView 구성 요소를 추가하여 사용할 수 있지만, Jetpack Compose에는 직접 사용할 수 있는 WebView 구성 요소가 없습니다. 그렇다면 Compose에서 WebView를 어떻게 사용해야 할까요?\u003c/p\u003e\n\u003cp\u003e이 기사에서는 Jetpack Compose에서 WebView를 사용하는 방법과 기본 기능을 활용하는 방법에 대해 소개하겠습니다.\u003c/p\u003e\n\u003ch1\u003e권한\u003c/h1\u003e\n\u003cp\u003e먼저 Android Manifest에 권한을 추가해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;?xml version=\u003cspan class=\"hljs-string\"\u003e\"1.0\"\u003c/span\u003e encoding=\u003cspan class=\"hljs-string\"\u003e\"utf-8\"\u003c/span\u003e?\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003emanifest\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003exmlns:android\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"http://schemas.android.com/apk/res/android\"\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003exmlns:tools\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"http://schemas.android.com/tools\"\u003c/span\u003e\u003e\u003c/span\u003e\n\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003euses-permission\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eandroid:name\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"android.permission.INTERNET\"\u003c/span\u003e /\u003e\u003c/span\u003e\n\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eapplication\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eandroid:usesCleartextTraffic\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eapplication\u003c/span\u003e\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003emanifest\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eAndroidView\u003c/h1\u003e\n\u003cp\u003e그런 다음 웹 페이지를 표시하는 Composable 컴포넌트를 만들어야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eComposable\u003c/span\u003e\nfun \u003cspan class=\"hljs-title class_\"\u003eWebView\u003c/span\u003e(){\n  \n    \u003cspan class=\"hljs-comment\"\u003e// URL을 포함한 문자열 선언\u003c/span\u003e\n    val mUrl = \u003cspan class=\"hljs-string\"\u003e\"https://www.google.com\"\u003c/span\u003e\n  \n    \u003cspan class=\"hljs-comment\"\u003e// AndroidView 내에 WebView를 추가\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 전체 화면 레이아웃\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eAndroidView\u003c/span\u003e(factory = {\n        \u003cspan class=\"hljs-title class_\"\u003eWebView\u003c/span\u003e(it).\u003cspan class=\"hljs-property\"\u003eapply\u003c/span\u003e {\n            layoutParams = \u003cspan class=\"hljs-title class_\"\u003eViewGroup\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eLayoutParams\u003c/span\u003e(\n                \u003cspan class=\"hljs-title class_\"\u003eViewGroup\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eLayoutParams\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMATCH_PARENT\u003c/span\u003e,\n                \u003cspan class=\"hljs-title class_\"\u003eViewGroup\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eLayoutParams\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMATCH_PARENT\u003c/span\u003e\n            )\n        }\n    }, update = {\n        it.\u003cspan class=\"hljs-title function_\"\u003eloadUrl\u003c/span\u003e(mUrl)\n    })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 AndroidView를 사용하여 WebView 구성 요소를 래핑했습니다. factory 메서드에서는 AndroidX WebView를 디스플레이 구성 요소로 생성하고 그의 layoutParams를 설정합니다. 마지막으로 update 메서드에서 loadUrl 메서드를 사용하여 URL을 로드합니다.\u003c/p\u003e\n\u003ch1\u003eWebViewClient\u003c/h1\u003e\n\u003cp\u003e특정 URL을 가로채야 할 때는 어떻게 할까요? View와 유사하게 WebViewClient를 사용자 정의하고 shouldOverrideUrlLoading 메서드를 재정의하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Composable\u003c/span\u003e\nfun \u003cspan class=\"hljs-title function_\"\u003eWebView\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e{\n  \n    \u003cspan class=\"hljs-comment\"\u003e// URL을 포함하는 문자열 선언\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003eval\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003emUrl\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"https://www.google.com\"\u003c/span\u003e\n  \n    \u003cspan class=\"hljs-comment\"\u003e// 전체 화면 레이아웃의 AndroidView 내부에 WebView 추가\u003c/span\u003e\n    AndroidView(factory = {\n        WebView(it).apply {\n            \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.layoutParams = ViewGroup.LayoutParams(\n                ViewGroup.LayoutParams.MATCH_PARENT,\n                ViewGroup.LayoutParams.MATCH_PARENT\n            )\n            \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.webViewClient = CustomWebViewClient()\n        }\n    }, update = {\n        it.loadUrl(mUrl)\n    })\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCustomWebViewClient\u003c/span\u003e: WebViewClient(){\n    override fun \u003cspan class=\"hljs-title function_\"\u003eshouldOverrideUrlLoading\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(view: WebView?, url: String?)\u003c/span\u003e: Boolean {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(url != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026#x26;\u0026#x26; url.startsWith(\u003cspan class=\"hljs-string\"\u003e\"https://google.com\"\u003c/span\u003e)){\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n        }\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eWebChromeClient\u003c/h1\u003e\n\u003cp\u003e더불어, 특정 웹 이벤트를 수신하기 위해 WebChromeClient를 사용자 정의할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Composable\u003c/span\u003e\nfun \u003cspan class=\"hljs-title function_\"\u003eWebView\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e{\n  \n    \u003cspan class=\"hljs-comment\"\u003e// URL을 포함하는 문자열 선언\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003eval\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003emUrl\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"https://www.google.com\"\u003c/span\u003e\n  \n    \u003cspan class=\"hljs-comment\"\u003e// 전체 화면 레이아웃의 AndroidView 내부에 WebView 추가\u003c/span\u003e\n    AndroidView(factory = {\n        WebView(it).apply {\n            \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.layoutParams = ViewGroup.LayoutParams(\n                ViewGroup.LayoutParams.MATCH_PARENT,\n                ViewGroup.LayoutParams.MATCH_PARENT\n            )\n            \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.webChromeClient = CustomWebChromeClient()\n        }\n    }, update = {\n        it.loadUrl(mUrl)\n    })\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCustomWebChromeClient\u003c/span\u003e : WebChromeClient() {\n    override fun \u003cspan class=\"hljs-title function_\"\u003eonCloseWindow\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(window: WebView?)\u003c/span\u003e {}\n    \n    override fun \u003cspan class=\"hljs-title function_\"\u003eonConsoleMessage\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(consoleMessage: ConsoleMessage?)\u003c/span\u003e: Boolean {}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e라이브러리\u003c/h1\u003e\n\u003cp\u003e그러나 이 방법은 상태가없는 단일 로드에만 적용됩니다. 만약 우리가 웹페이지의 제목, 로딩 상태 및 현재로드된 URL을 얻어야한다면 어떻게 될까요?\u003c/p\u003e\n\u003cp\u003e비슷하게, 웹페이지에서 새 링크의 앞뒤로 넘기기 및 로딩을 제어해야하는 경우도 있습니다. 더 복잡한 것은 HTML 코드의 로드를 지원해야하는 경우입니다.\u003c/p\u003e\n\u003cp\u003e다행히도 이미 이러한 기능을 제공하는 라이브러리가 있었습니다. Compose 내에서 직접 사용할 수있는 WebView 구성 요소를 제공하여 개발자가 WebView의 캡슐화 논리를 직접 작성할 필요가 없게합니다. 또한 웹 페이지 속성을 가져 오고 로딩 상태를 수신하는 기능과 같은 기능을 제공하여, 모두 사용 가능합니다.\u003c/p\u003e\n\u003cp\u003e기본적인 사용법은 아래와 같이 매우 간단합니다. URL을 로드하고 표시하는 데 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eval state = \u003cspan class=\"hljs-title function_\"\u003erememberWebViewState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"https://example.com\"\u003c/span\u003e)\n\n\u003cspan class=\"hljs-title class_\"\u003eWebView\u003c/span\u003e(\n    state\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e자세한 사용 방법은 다음 기사를 참조해 주세요:\u003c/p\u003e\n\u003ch1\u003e이어서 읽을 내용\u003c/h1\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-02-UsingWebViewinJetpackCompose"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>