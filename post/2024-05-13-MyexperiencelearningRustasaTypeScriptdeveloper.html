<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper" data-gatsby-head="true"/><meta name="twitter:title" content="TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-13 00:10" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 13, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png" alt="My experience learning Rust as a TypeScript developer"></p>
<p>많은 개발자들처럼, 나 또한 웹 기술에 중점을 두며 프로그래밍 경력을 시작했습니다. 이것은 시작하기에 좋은 곳이라고 생각하며, 인터넷의 언어이자 많은 기능을 갖춘 JavaScript는 매우 다재다능한 선택이라고 생각합니다.</p>
<p>저는 JavaScript와 같은 고수준 언어에 대한 경험이 쌓을수록, 어떻게 작동하는지에 대해 더 많은 관심을 가지기 시작했습니다. 그들은 어떤 선택과 타협을 하고 있는지, 고수준 추상화의 혜택과 비용은 무엇인지 궁금해졌습니다.</p>
<p>저에게 이러한 깊은 이해를 얻는 가장 좋은 방법 중 하나는 저수준 프로그래밍 언어를 배우는 것입니다. 결국 이러한 언어들은 일반적으로 JavaScript 코드를 구문 분석하고 해석하는 언어입니다. 예를 들어, Google Chrome 및 Node.js에서 사용되는 V8 엔진 및 Safari 및 Bun에서 사용되는 WebKit은 모두 C++로 작성되어 있습니다. 그러나 저수준 프로그래밍의 주력언어인 C++이 내 선택 언어는 아니었습니다...</p>
<h1>왜 Rust를 선택해야 할까요?</h1>
<p>저에게 가장 흥미로운 저수준 프로그래밍 언어 중 하나인 Rust는 매우 흥미롭습니다. 작년에도 8년 연속으로 Rust가 Stack Overflow의 연간 설문 조사에서 가장 존경받는 프로그래밍 언어였습니다.</p>
<p>Rust 언어는 C 및 C++과 같은 런타임 성능을 약속하면서도 엄격한 타입 시스템, 많은 메모리 안전 기능 및 보다 적극적인 오류 처리 접근 방식을 제공합니다. 따라서 쓰레기 수집기의 오버헤드를 피하고, C와 같은 언어에서 만들기 쉬운 메모리 누수의 위험에서 안전합니다.</p>
<p>Rust는 다중 패러다임을 갖추고 있어 객체 지향 및 함수형 프로그래밍에서의 개념들을 결합하고 있습니다. Web Assembly을 위해 가장 많이 사용되는 언어로 세 번째 해를 맞이하고, Linux 커널에서도 중요한 언어로 자리매김하고 있습니다. Rust는 JavaScript 세계에서도 주목을 받고 있으며, Deno와 같은 중요한 프로젝트 및 최근에는 LLRT (Amazon의 서버리스 함수용 저지연 런타임)과 같은 프로젝트를 개발하는 데 사용되고 있습니다.</p>
<h1>러스트 배우는 방법</h1>
<p>다른 프로그래밍 언어와 마찬가지로, 러스트를 배우는 가장 좋은 방법은 그 언어로 무언가를 프로그래밍해 보는 것이라고 생각해요.</p>
<p>다만, 러스트의 초기 학습 곡선이 최근 몇 년 동안 시도해 본 다른 언어들보다 가파르다는 느낌을 받으셔서, 그 언어를 사용하기 전에 입문 자료를 더 여유롭게 공부하는 것이 가치가 있다고 생각해요.</p>
<p>러스트 기관의 웹사이트에는 좋은 권장사항들이 있어요. 현재로는 더 테스트하기, Rustlings 코스, Rust by Example이 그렇고요. 또한 Rust by Practice도 추천해요. 이것은 Rustlings와 유사한 대화형 코스예요.</p>
<p>유튜브에서 NoBoilerplate 채널을 통해 언어에 대해 흥분하게 되었고 일반 Rust 개념에 대한 좋은 설명 소스입니다. Rust를 호스팅에 관심이 있다면, AWS는 플랫폼에서 Rust 지원을 확대하는 좋은 블로그 게시물이 있습니다.</p>
<p>본문의 나머지는 Rust에 대한 초심자 안내서가 아닙니다. 그런 정보를 찾고 계시다면, 위의 링크를 따라가는 것을 추천합니다. 대신, 전문가로서 매일 사용하는 TypeScript와 비교하여 Rust를 사용할 때 개발자 경험에서 가장 중요한 차이점 중 일부에 대한 나의 생각을 공유하겠습니다.</p>
<h1>컴파일러</h1>
<p>Rust 컴파일러는 종종 Rust의 가장 좋은 부분 중 하나로 인용되지만 초심자들에게는 가장 짜증이 나는 부분으로 느껴질 수도 있습니다!</p>
<p>TypeScript에서 왔는데, 컴파일러가 코딩 경험을 얼마나 바꾸는지 놀랐어요. 많은 개발자들처럼, 보통 제가 값들을 자유롭게 로깅하는 방식의 적절한 디버깅 도구를 피하곤 해왔어요. 하지만 Rust에서는, 컴파일러가 만족할 때까지만 값들을 로깅할 수 있어요.</p>
<p>이런 경우에 당황했던 일들이 있어요: 예를 들어, 역직렬화 단계의 엄격한 유형을 작성하기 전에 요청된 JSON 페이로드를 로그로 남기고 싶었어요. (나중에, serde_json::Value 유형을 사용하면 이것을 할 수 있다는 것을 배웠어요).</p>
<p>그러나 일반적으로, 컴파일러를 만족시키기 위해 노력하는 것은 보통 제 코드를 실행했을 때, 기대했던 대로 동작한다는 것을 의미했어요. 여기서의 절충안은 꽤 명확해 보여요. 적어도 초보자들에게는 코드를 실행하는 데 더 많은 시간이 걸리지만, 코드가 실행될 때, 더 안전하고 예측 가능하며 성능이 더 좋아요. 쓰기 단계에서 더 많은 작업을 해야하지만, 오류나 메모리 또는 성능 문제의 가능성이 더 낮아지는 경향이 있어요 — 그리고 이러한 이점들은 점점 중요해지는 대형, 커지는 프로젝트의 맥락에서 더욱 중요하게 느껴져요.</p>
<p>오류 메시지가 덜 유용한 언어에서 온 개발자들은 오류를 빨리 훑어 넘어가야 한다는 성격을 갖고 있을 수 있어요. 그러나 지금까지 제가 발견한 Rust 컴파일러 오류는 매우 좋았어요. 종종 코드를 실행시키기 위해 무엇을 해야하는지 정확히 말해줘요— 언어와 그 유형에 대해 더 많은 경험과 지식을 쌓을수록, 컴파일러가 무엇을 말하려는지 이해하는 데 더 능숙해지고 있는 것 같아요!</p>
<h1>유형 시스템</h1>
<p>모든 JavaScript 개발자가 TypeScript을 좋아하지는 않는다는 것을 알고 있어요. 예를 들어, 이 유명한 블로그 포스트를 보세요. 하지만 저는 타입 없이 큰 JavaScript 앱을 작성하는 것이 상상이 되지 않아요. 그러나 TypeScript에도 약점이 있고, 타입이 일등 시민인 언어를 가지는 것에는 많은 장점이 있다는 것을 깨달았어요. Rust의 유형 시스템은 그 중에서도 최고의 기능 중 하나로 칭찬을 받는 편이에요.</p>
<p>그렇지만, 저에겐 새로운 개념인 Rust의 유형 시스템의 일부는 Rust에만 있는 것은 아니라는 걸 알았어요. 대부분의 저수준 언어와 마찬가지로, Rust는 변수가 메모리에서 얼마만큼의 공간을 차지할지 매우 구체적으로 지정할 수 있도록 해줘요. 예를 들어, 숫자 값이 항상 0에서 255 사이의 정수일 것을 알고 있다면 8비트 길이를 가진 u8에 할당할 수 있어요. 또는 숫자가 255 이상일 수 있지만, 65,535 미만이라는 것을 알고 있다면, 16비트 u16 유형에 할당할 수 있어요 — 그리고 계속해서 할당해 나갈 수 있어요.</p>
<p>그러나 Rust도 다른 저수준 언어보다 한 걸음 더 나아간다고 할 수 있어요. 예를 들어, C의 char[] 유형 대신에 적어도 여덟 가지 문자열 유형을 제공하며, 우리에게 '발목을 쐐는 일'을 피할 수 있도록 도와줘요. (물론, 걱정하지 마세요, 대부분의 사용 사례는 &#x26;str과 String으로 충분히 커버돼 있어요!)</p>
<p>물론 TypeScript는 메모리 관리에 대한 이러한 세밀한 수준을 제공하지 않습니다. 왜냐하면 JavaScript는 메모리 관리에 대해 걱정하지 않도록 설계되어 있기 때문에 메모리를 할당합니다. 이는 우리에게 일을 줄여주지만 JavaScript 엔진은 프로그램이 실행되는 동안 동적으로 메모리를 할당해야 하므로 덜 효율적입니다. 소규모로는 큰 차이가 없지만 대규모 응용 프로그램에서 더 효율적이고 목적적인 메모리 할당은 프로그램이 훨씬 작은 메모리 공간을 차지할 수 있게 해줍니다.</p>
<h2>메모리 할당</h2>
<p>TypeScript에서는 우리의 타입을 읽지 않는 JavaScript 위에 타입 주석을 덧붙입니다. TypeScript 코드가 빌드될 때마다 이 주석들은 제거됩니다.</p>
<p>Rust와 같이 타입이 일급 시민인 다른 언어들에서는 타입 주석이 주석 이상의 역할을 하며 해당 특정 타입에 대해 메모리를 할당하고 그 값이 주어진 타입을 가질 것임을 우리에게 보장합니다.</p>
<p>예를 들어, 아래의 parse 메서드에 i8 타입을 전달하면 small_int에 8비트의 메모리가 예약됩니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">small_int</span> = <span class="hljs-string">"127"</span>.parse::&#x3C;<span class="hljs-type">i8</span>>().<span class="hljs-title function_ invoke__">unwrap</span>();
</code></pre>
<p>parse 메서드는 변수의 타입에서도 타입을 추론할 수 있기 때문에 다음과 같이도 작성할 수 있습니다:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">small_int</span>: <span class="hljs-type">i8</span> = <span class="hljs-string">"127"</span>.<span class="hljs-title function_ invoke__">parse</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
</code></pre>
<p>이 경우, 컴파일러는 주어진 형식이 허용하는 메모리를 초과하려고 시도하면 우리에게 소리를 질립니다. 따라서 문자열 "128"을 i8로 구문 분석하려고 하면 컴파일할 수 없게 됩니다.</p>
<p>타입스크립트와 비교해보면, 타입 표시는 단지 마커일 뿐입니다. 그들은 밑바탕 타입이나 할당된 메모리를 변화시키지 않습니다. 아래 예시에서 타입스크립트는 x가 문자열이라고 예상합니다. 그러나 밑바탕 자바스크립트에서는 숫자로 취급됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-number">10</span> <span class="hljs-keyword">as</span> unknown <span class="hljs-keyword">as</span> string;
</code></pre>
<p>이 예는 조금 불합리한 예제입니다; 우리는 잘못된 타입을 강제로 할당하려고 unknown을 탈출구로 사용하고 있습니다!</p>
<p>그러나 이것은 이해하기 쉬운 간단한 예제입니다. 실제 응용 프로그램에서는 더 복잡한 데이터 유형이나 제3자로부터 가져온 데이터를 다룰 때 TypeScript가 현실을 잘못 표현하기 쉬워집니다.</p>
<h1>오류 처리</h1>
<p>다시 한번 문자열을 정수로 변환하는 예제를 살펴봅시다. 이번에는 사용자가 제공한 문자열을 정수로 취급하니, 우리가 정확히 파싱할 수 있다고 보장할 수 없게 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> parsed_int = submitted_str.<span class="hljs-property">parse</span>::&#x3C;i32>().<span class="hljs-title function_">unwrap</span>();
</code></pre>
<p>여기서는 성공적으로 구문 분석한 값을 가져오기 위해 unwrap을 사용하고 있습니다. 그러나 이 방식은 일반적으로 권장되지 않습니다. 대신 Rust는 오류를 수동으로 처리하도록 강제하는 Result 열거형을 제공합니다.</p>
<p>우리는 여전히 panic! 매크로를 사용하여 프로그램을 패닉 상태로 만들 수 있지만, 잘못된 내용을 빠르게 이해할 수 있는 사용자 정의 오류 메시지를 전달할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> parsed_int_result = submitted_str.<span class="hljs-property">parse</span>::&#x3C;i32>();

<span class="hljs-keyword">let</span> parsed_int = match parsed_int_result {
    <span class="hljs-title class_">Ok</span>(data) => data,
    <span class="hljs-title class_">Err</span>(error) => panic!(
        <span class="hljs-string">"주어진 문자열을 정수로 구문 분석할 수 없습니다: {:?}"</span>,
        error
    ),
};
</code></pre>
<p>또는 기본값을 반환할 수도 있습니다 — 이 경우에는 0:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> parsed_int_result = submitted_str.<span class="hljs-property">parse</span>::&#x3C;i32>();

<span class="hljs-keyword">let</span> parsed_int = match parsed_int_result {
    <span class="hljs-title class_">Ok</span>(data) => data,
    <span class="hljs-title class_">Err</span>(error) => <span class="hljs-number">0</span>,
};
</code></pre>
<p>이 작업에 대한 단축 방법도 있습니다: unwrap_or_default .</p>
<p>물론 JavaScript에서도 이런 종류의 동작이 가능하지만, 차이점은 JavaScript에서는 선택으로 참여해야 하지만 Rust에서는 unwrap을 사용하여 선택으로 제외해야 합니다.</p>
<p>또 다른 말로는 JavaScript에서는 에러를 의식적으로 처리해야 합니다. 반면에 Rust에서는 에러를 처리하든지 성공적인 경로만 신경 쓸 것이라고 의식적으로 결정해야 합니다.</p>
<h1>선택적 값</h1>
<p>Rust는 선택적인 값 처리에 비슷한 접근법을 사용합니다. TypeScript에서는 편리한 ?를 사용하여 값이 정의되지 않을 수 있다는 것을 나타낼 수 있습니다.</p>
<pre><code class="hljs language-js">interface <span class="hljs-title class_">User</span> {
  <span class="hljs-attr">_id</span>: string;
  name?: string;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">user: User</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">${user.name}</span>!`</span>;
}
</code></pre>
<p>이 TypeScript 코드는 문제없이 컴파일될 것이지만, 우리가 원치 않는 값을 반환할 위험이 있습니다!</p>
<p>하지만 Option 열거형을 사용하여 Rust에서 비슬한 내용을 작성하면 컴파일 시간 오류가 발생합니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> {
  _id: <span class="hljs-type">String</span>,
  name: <span class="hljs-type">Option</span>&#x3C;<span class="hljs-type">String</span>>,
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">say_hello</span>(user: User) <span class="hljs-punctuation">-></span> <span class="hljs-type">String</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = user.name;
    <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Hello {name}!"</span>)
}
</code></pre>
<p>위의 코드는 Option을 format! 매크로 안에 사용할 수 없다는 경고를 보여줍니다. 이것은 예상치 못한 결과를 반환하는 것을 방지합니다. 대신, 이 가능성을 처리하도록 강제됩니다. 다음은 match를 사용한 하나의 해결책입니다:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> {
  _id: <span class="hljs-type">String</span>,
  name: <span class="hljs-type">Option</span>&#x3C;<span class="hljs-type">String</span>>,
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">say_hello</span>(user: User) <span class="hljs-punctuation">-></span> <span class="hljs-type">String</span> {
  <span class="hljs-keyword">let</span> <span class="hljs-variable">name</span>: <span class="hljs-type">String</span> = <span class="hljs-keyword">match</span> user.name {
    <span class="hljs-title function_ invoke__">Some</span>(name) => name,
    <span class="hljs-literal">None</span> => <span class="hljs-string">"world"</span>.<span class="hljs-title function_ invoke__">to_string</span>(),
  };

  <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Hello {name}!"</span>)
}
</code></pre>
<p>한 번 더 말하지만, TypeScript에서는 이것을 달성할 수 있습니다. 그리고 더 간결합니다. 하지만 두 언어 간의 주요 차이점은 TypeScript에서는 개발자가 잠재적 문제를 인식해야 한다는 점입니다. 그래서 "Hello undefined"를 반환하지 않도록 주의를 기울여야 합니다. 그러나 Rust에서는 name이 사용 불가능한 시나리오를 처리하지 않을 경우 코드가 컴파일되지 않습니다.</p>
<p>이 예제와 같이 간단한 경우에는 보다 번거로운 접근 방식의 이점을 인식하기가 어려울 수 있습니다. 왜냐하면 무엇이 잘못될 수 있는지 쉽게 알아볼 수 있기 때문입니다. 하지만 한 번이라도 대규모 응용 프로그램을 작업해본 적이 있다면, Rust의 opt-out 접근 방식이 많은 잠재적 사고로부터 우리를 구해낼 수 있다는 것이 분명해집니다.</p>
<h1>소유권과 대여</h1>
<p>마지막으로, 소유권과 대여에 대해 얘기하고 싶습니다. 이 개념들은 Rust와 같은 저수준 언어에서는 높은 수준의 TypeScript와는 달리 의미가 훨씬 크다는 것을 감안하면서요.</p>
<p>TypeScript에서는 값을 변이(mutate)하거나 복제(clone)하는지 주의해야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-attr">arrayToBeMutated</span>: string[] = [<span class="hljs-string">"d"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"a"</span>];
<span class="hljs-keyword">const</span> <span class="hljs-attr">arrayToBeCloned</span>: string[] = [<span class="hljs-string">"d"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"a"</span>];

arrayToBeMutated.<span class="hljs-title function_">sort</span>();
arrayToBeCloned.<span class="hljs-title function_">toSorted</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrayToBeMutated);  <span class="hljs-comment">// ["a", "b", "c", "d"]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrayToBeCloned);   <span class="hljs-comment">// ["d", "c", "b", "a"]</span>
</code></pre>
<p>위의 TypeScript 코드에서 sort는 배열을 현재 위치에서 정렬하여 원래 값을 변경하여 변이합니다. 그러나 toSorted는 복제본을 생성하여 새 변수에 할당할 수 있으며, 원래 배열을 그대로 유지합니다.</p>
<p>일반적으로 TypeScript와 같은 언어에서는 변이(mutate)를 피하기 위해 toSorted와 같은 비파괴적 메서드가 종종 선호됩니다. 변이된 변수를 추적하는 것은 까다로울 수 있고, 메모리나 성능에 명확한 이점이 없는 한 전혀 하지 않는 것이 보편적으로 더 나은 방법으로 여겨집니다.</p>
<p>하지만 Rust를 사용하면 더 깊게 들어갈 수 있고, 값을 변이하거나 복제하는 데 훨씬 명시적일 수 있어서 메모리를 효율적으로 사용하고 값이 그 영광스러운 목적을 수행한 후에도 메모리를 더 쉽게 해제할 수 있습니다.</p>
<p>먼저, 모든 변수는 기본적으로 불변이며, mut 키워드로 명시적으로 변경 가능하도록 표시해야 합니다.</p>
<p>다음 코드는 오류를 발생시킵니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> foo = <span class="hljs-number">10</span>;
foo += <span class="hljs-number">10</span>;
</code></pre>
<p>이 코드는 다음을 수행하지 않습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> mut foo = <span class="hljs-number">10</span>;
foo += <span class="hljs-number">10</span>;
</code></pre>
<p>이것은 JavaScript에서의 let와 const와 대략 동등한 것처럼 느껴집니다. 그러나 Rust는 더 나아갑니다.</p>
<p>예를 들어, JavaScript에서는 배열과 같은 일부 변수 유형이 항상 가변적(mutable)입니다. const를 사용하여 생성하더라도 push, pop 및 인덱스 재할당을 할 수 있습니다. 그러나 Rust에서는 이 작업을 수행하려면 mut이 필요합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> mut <span class="hljs-attr">nums</span>: <span class="hljs-title class_">Vec</span>&#x3C;i32> = vec![<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
nums.<span class="hljs-title function_">push</span>(<span class="hljs-number">6</span>);
</code></pre>
<p>러스트는 또한 우리가 변수에서 다른 변수로 값을 소유권을 옮길 수 있도록 하는 기능을 제공합니다. 아래 예시를 살펴보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> <span class="hljs-attr">nums</span>: <span class="hljs-title class_">Vec</span>&#x3C;i32> = vec![<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">let</span> <span class="hljs-attr">doubles</span>: <span class="hljs-title class_">Vec</span>&#x3C;i32> = nums.<span class="hljs-title function_">into_iter</span>().<span class="hljs-title function_">map</span>(|n| n * <span class="hljs-number">2</span>).<span class="hljs-title function_">collect</span>();

dbg!(nums);     <span class="hljs-comment">// 이 코드는 오류를 발생시킵니다.</span>
dbg!(doubles);
</code></pre>
<p>위 코드는 오류가 발생합니다. 왜냐하면 into_iter 메서드는 "소비형 반복자(consuming iterator)"를 생성하는데, 다시 말해 nums로부터 소유권을 가져와 doubles에게 주기 때문입니다. 그렇기 때문에 doubles를 만든 후에는 dbg!(nums)를 호출할 수 없습니다.</p>
<p>nums에 액세스할 수는 있지만 값을 복제하고 싶을 때, into_iter 대신에 iter 메서드를 사용할 수 있습니다. 중요한 점은 Rust가 우리에게 선택권을 주고 소유권을 전달할 수 있는 능력을 통해 메모리 할당을 더 효율적으로 관리할 수 있다는 것입니다.
간단한 값을 이동시키는 것도 가능합니다. 아래 코드에서 str 변수가 calculate_length의 인수로 사용될 때, 해당 변수에 더 이상 액세스할 수 없게 됩니다.</p>
<pre><code class="hljs language-js">fn <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> str = <span class="hljs-title class_">String</span>::<span class="hljs-title function_">from</span>(<span class="hljs-string">"Hello world!"</span>);
    <span class="hljs-keyword">let</span> len = <span class="hljs-title function_">calculate_length</span>(str);
    dbg!(str); <span class="hljs-comment">// 오류 발생</span>
}

fn <span class="hljs-title function_">calculate_length</span>(<span class="hljs-attr">s</span>: <span class="hljs-title class_">String</span>) -> usize {
    s.<span class="hljs-title function_">len</span>()
}
</code></pre>
<p>여기서 우리는 문자열을 전달하는 대신에 문자열의 참조를 전달하기 위해 앰퍼샌드 &#x26;를 사용하여 이 문제를 해결할 수 있습니다. 또한 함수의 인수를 참조를 기대하는 형태로 업데이트해야 합니다:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">str</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"hello"</span>);
    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&#x26;<span class="hljs-type">str</span>);
    dbg!(<span class="hljs-type">str</span>, len);
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &#x26;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">usize</span> {
    s.<span class="hljs-title function_ invoke__">len</span>()
}
</code></pre>
<p>또 반대로 값을 역참조하기 위해 별표 * 를 사용할 수 있습니다. 이러한 기능들은 우리가 메모리를 안전하고 효율적으로 제어하는 데 도움이 됩니다. 이로 인해 Rust는 가비지 컬렉터에 의존할 필요가 없으며, C와 같은 언어에서의 위험을 피하면서 더 높은 성능 수준을 발휘할 수 있게 됩니다. C 언어처럼 개발자에게 막대한 책임을 요구하는 언어와 다르게 안전하고 효율적으로 메모리를 관리할 수 있습니다!</p>
<p>내가 Rust를 배우고 사용한 초기 경험은 매우 긍정적이었습니다. 다른 언어들에 비해서 시작하기가 조금 어려웠지만, Rust를 배우면서 내가 매일 사용하는 고수준 언어들의 기본적인 작동 방식에 대해 더 많은 인식을 가질 수 있었다고 느꼈습니다. 개인 프로젝트에서 더 많이 사용할 기대감이 있습니다.</p>
<p>Rust에 처음 입문하거나 해당 언어를 배워보고자 하는 분들에게, 특히 다른 고수준 언어에서 왔다면, 이 글이 유용했으면 좋겠습니다. 물론 이 글은 단순한 내용이며, 특성(traits)이나 라이프타임(lifetimes)과 같은 여러 주제들이 있으나 이 글의 범위를 벗어납니다. 더 알고 싶으면 The Book을 참고하고 아래 댓글에서 여러분의 경험을 공유해보세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"TypeScript 개발자로서 Rust를 배우면서 느낀 나의 경험","description":"","date":"2024-05-13 00:10","slug":"2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper","content":"\n\n![My experience learning Rust as a TypeScript developer](/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png)\n\n많은 개발자들처럼, 나 또한 웹 기술에 중점을 두며 프로그래밍 경력을 시작했습니다. 이것은 시작하기에 좋은 곳이라고 생각하며, 인터넷의 언어이자 많은 기능을 갖춘 JavaScript는 매우 다재다능한 선택이라고 생각합니다.\n\n저는 JavaScript와 같은 고수준 언어에 대한 경험이 쌓을수록, 어떻게 작동하는지에 대해 더 많은 관심을 가지기 시작했습니다. 그들은 어떤 선택과 타협을 하고 있는지, 고수준 추상화의 혜택과 비용은 무엇인지 궁금해졌습니다.\n\n저에게 이러한 깊은 이해를 얻는 가장 좋은 방법 중 하나는 저수준 프로그래밍 언어를 배우는 것입니다. 결국 이러한 언어들은 일반적으로 JavaScript 코드를 구문 분석하고 해석하는 언어입니다. 예를 들어, Google Chrome 및 Node.js에서 사용되는 V8 엔진 및 Safari 및 Bun에서 사용되는 WebKit은 모두 C++로 작성되어 있습니다. 그러나 저수준 프로그래밍의 주력언어인 C++이 내 선택 언어는 아니었습니다...\n\n\n\n# 왜 Rust를 선택해야 할까요?\n\n저에게 가장 흥미로운 저수준 프로그래밍 언어 중 하나인 Rust는 매우 흥미롭습니다. 작년에도 8년 연속으로 Rust가 Stack Overflow의 연간 설문 조사에서 가장 존경받는 프로그래밍 언어였습니다.\n\nRust 언어는 C 및 C++과 같은 런타임 성능을 약속하면서도 엄격한 타입 시스템, 많은 메모리 안전 기능 및 보다 적극적인 오류 처리 접근 방식을 제공합니다. 따라서 쓰레기 수집기의 오버헤드를 피하고, C와 같은 언어에서 만들기 쉬운 메모리 누수의 위험에서 안전합니다.\n\nRust는 다중 패러다임을 갖추고 있어 객체 지향 및 함수형 프로그래밍에서의 개념들을 결합하고 있습니다. Web Assembly을 위해 가장 많이 사용되는 언어로 세 번째 해를 맞이하고, Linux 커널에서도 중요한 언어로 자리매김하고 있습니다. Rust는 JavaScript 세계에서도 주목을 받고 있으며, Deno와 같은 중요한 프로젝트 및 최근에는 LLRT (Amazon의 서버리스 함수용 저지연 런타임)과 같은 프로젝트를 개발하는 데 사용되고 있습니다.\n\n\n\n# 러스트 배우는 방법\n\n다른 프로그래밍 언어와 마찬가지로, 러스트를 배우는 가장 좋은 방법은 그 언어로 무언가를 프로그래밍해 보는 것이라고 생각해요.\n\n다만, 러스트의 초기 학습 곡선이 최근 몇 년 동안 시도해 본 다른 언어들보다 가파르다는 느낌을 받으셔서, 그 언어를 사용하기 전에 입문 자료를 더 여유롭게 공부하는 것이 가치가 있다고 생각해요.\n\n러스트 기관의 웹사이트에는 좋은 권장사항들이 있어요. 현재로는 더 테스트하기, Rustlings 코스, Rust by Example이 그렇고요. 또한 Rust by Practice도 추천해요. 이것은 Rustlings와 유사한 대화형 코스예요.\n\n\n\n유튜브에서 NoBoilerplate 채널을 통해 언어에 대해 흥분하게 되었고 일반 Rust 개념에 대한 좋은 설명 소스입니다. Rust를 호스팅에 관심이 있다면, AWS는 플랫폼에서 Rust 지원을 확대하는 좋은 블로그 게시물이 있습니다.\n\n본문의 나머지는 Rust에 대한 초심자 안내서가 아닙니다. 그런 정보를 찾고 계시다면, 위의 링크를 따라가는 것을 추천합니다. 대신, 전문가로서 매일 사용하는 TypeScript와 비교하여 Rust를 사용할 때 개발자 경험에서 가장 중요한 차이점 중 일부에 대한 나의 생각을 공유하겠습니다.\n\n# 컴파일러\n\nRust 컴파일러는 종종 Rust의 가장 좋은 부분 중 하나로 인용되지만 초심자들에게는 가장 짜증이 나는 부분으로 느껴질 수도 있습니다!\n\n\n\nTypeScript에서 왔는데, 컴파일러가 코딩 경험을 얼마나 바꾸는지 놀랐어요. 많은 개발자들처럼, 보통 제가 값들을 자유롭게 로깅하는 방식의 적절한 디버깅 도구를 피하곤 해왔어요. 하지만 Rust에서는, 컴파일러가 만족할 때까지만 값들을 로깅할 수 있어요.\n\n이런 경우에 당황했던 일들이 있어요: 예를 들어, 역직렬화 단계의 엄격한 유형을 작성하기 전에 요청된 JSON 페이로드를 로그로 남기고 싶었어요. (나중에, serde_json::Value 유형을 사용하면 이것을 할 수 있다는 것을 배웠어요).\n\n그러나 일반적으로, 컴파일러를 만족시키기 위해 노력하는 것은 보통 제 코드를 실행했을 때, 기대했던 대로 동작한다는 것을 의미했어요. 여기서의 절충안은 꽤 명확해 보여요. 적어도 초보자들에게는 코드를 실행하는 데 더 많은 시간이 걸리지만, 코드가 실행될 때, 더 안전하고 예측 가능하며 성능이 더 좋아요. 쓰기 단계에서 더 많은 작업을 해야하지만, 오류나 메모리 또는 성능 문제의 가능성이 더 낮아지는 경향이 있어요 — 그리고 이러한 이점들은 점점 중요해지는 대형, 커지는 프로젝트의 맥락에서 더욱 중요하게 느껴져요.\n\n오류 메시지가 덜 유용한 언어에서 온 개발자들은 오류를 빨리 훑어 넘어가야 한다는 성격을 갖고 있을 수 있어요. 그러나 지금까지 제가 발견한 Rust 컴파일러 오류는 매우 좋았어요. 종종 코드를 실행시키기 위해 무엇을 해야하는지 정확히 말해줘요— 언어와 그 유형에 대해 더 많은 경험과 지식을 쌓을수록, 컴파일러가 무엇을 말하려는지 이해하는 데 더 능숙해지고 있는 것 같아요!\n\n\n\n# 유형 시스템\n\n모든 JavaScript 개발자가 TypeScript을 좋아하지는 않는다는 것을 알고 있어요. 예를 들어, 이 유명한 블로그 포스트를 보세요. 하지만 저는 타입 없이 큰 JavaScript 앱을 작성하는 것이 상상이 되지 않아요. 그러나 TypeScript에도 약점이 있고, 타입이 일등 시민인 언어를 가지는 것에는 많은 장점이 있다는 것을 깨달았어요. Rust의 유형 시스템은 그 중에서도 최고의 기능 중 하나로 칭찬을 받는 편이에요.\n\n그렇지만, 저에겐 새로운 개념인 Rust의 유형 시스템의 일부는 Rust에만 있는 것은 아니라는 걸 알았어요. 대부분의 저수준 언어와 마찬가지로, Rust는 변수가 메모리에서 얼마만큼의 공간을 차지할지 매우 구체적으로 지정할 수 있도록 해줘요. 예를 들어, 숫자 값이 항상 0에서 255 사이의 정수일 것을 알고 있다면 8비트 길이를 가진 u8에 할당할 수 있어요. 또는 숫자가 255 이상일 수 있지만, 65,535 미만이라는 것을 알고 있다면, 16비트 u16 유형에 할당할 수 있어요 — 그리고 계속해서 할당해 나갈 수 있어요.\n\n그러나 Rust도 다른 저수준 언어보다 한 걸음 더 나아간다고 할 수 있어요. 예를 들어, C의 char[] 유형 대신에 적어도 여덟 가지 문자열 유형을 제공하며, 우리에게 '발목을 쐐는 일'을 피할 수 있도록 도와줘요. (물론, 걱정하지 마세요, 대부분의 사용 사례는 \u0026str과 String으로 충분히 커버돼 있어요!)\n\n\n\n물론 TypeScript는 메모리 관리에 대한 이러한 세밀한 수준을 제공하지 않습니다. 왜냐하면 JavaScript는 메모리 관리에 대해 걱정하지 않도록 설계되어 있기 때문에 메모리를 할당합니다. 이는 우리에게 일을 줄여주지만 JavaScript 엔진은 프로그램이 실행되는 동안 동적으로 메모리를 할당해야 하므로 덜 효율적입니다. 소규모로는 큰 차이가 없지만 대규모 응용 프로그램에서 더 효율적이고 목적적인 메모리 할당은 프로그램이 훨씬 작은 메모리 공간을 차지할 수 있게 해줍니다.\n\n## 메모리 할당\n\nTypeScript에서는 우리의 타입을 읽지 않는 JavaScript 위에 타입 주석을 덧붙입니다. TypeScript 코드가 빌드될 때마다 이 주석들은 제거됩니다.\n\nRust와 같이 타입이 일급 시민인 다른 언어들에서는 타입 주석이 주석 이상의 역할을 하며 해당 특정 타입에 대해 메모리를 할당하고 그 값이 주어진 타입을 가질 것임을 우리에게 보장합니다.\n\n\n\n예를 들어, 아래의 parse 메서드에 i8 타입을 전달하면 small_int에 8비트의 메모리가 예약됩니다.\n\n```rust\nlet small_int = \"127\".parse::\u003ci8\u003e().unwrap();\n```\n\nparse 메서드는 변수의 타입에서도 타입을 추론할 수 있기 때문에 다음과 같이도 작성할 수 있습니다:\n\n```rust\nlet small_int: i8 = \"127\".parse().unwrap();\n```\n\n\n\n이 경우, 컴파일러는 주어진 형식이 허용하는 메모리를 초과하려고 시도하면 우리에게 소리를 질립니다. 따라서 문자열 \"128\"을 i8로 구문 분석하려고 하면 컴파일할 수 없게 됩니다.\n\n타입스크립트와 비교해보면, 타입 표시는 단지 마커일 뿐입니다. 그들은 밑바탕 타입이나 할당된 메모리를 변화시키지 않습니다. 아래 예시에서 타입스크립트는 x가 문자열이라고 예상합니다. 그러나 밑바탕 자바스크립트에서는 숫자로 취급됩니다.\n\n```js\nconst x = 10 as unknown as string;\n```\n\n이 예는 조금 불합리한 예제입니다; 우리는 잘못된 타입을 강제로 할당하려고 unknown을 탈출구로 사용하고 있습니다!\n\n\n\n그러나 이것은 이해하기 쉬운 간단한 예제입니다. 실제 응용 프로그램에서는 더 복잡한 데이터 유형이나 제3자로부터 가져온 데이터를 다룰 때 TypeScript가 현실을 잘못 표현하기 쉬워집니다.\n\n# 오류 처리\n\n다시 한번 문자열을 정수로 변환하는 예제를 살펴봅시다. 이번에는 사용자가 제공한 문자열을 정수로 취급하니, 우리가 정확히 파싱할 수 있다고 보장할 수 없게 됩니다.\n\n```js\nlet parsed_int = submitted_str.parse::\u003ci32\u003e().unwrap();\n```\n\n\n\n여기서는 성공적으로 구문 분석한 값을 가져오기 위해 unwrap을 사용하고 있습니다. 그러나 이 방식은 일반적으로 권장되지 않습니다. 대신 Rust는 오류를 수동으로 처리하도록 강제하는 Result 열거형을 제공합니다.\n\n우리는 여전히 panic! 매크로를 사용하여 프로그램을 패닉 상태로 만들 수 있지만, 잘못된 내용을 빠르게 이해할 수 있는 사용자 정의 오류 메시지를 전달할 수 있습니다:\n\n```js\nlet parsed_int_result = submitted_str.parse::\u003ci32\u003e();\n\nlet parsed_int = match parsed_int_result {\n    Ok(data) =\u003e data,\n    Err(error) =\u003e panic!(\n        \"주어진 문자열을 정수로 구문 분석할 수 없습니다: {:?}\",\n        error\n    ),\n};\n```\n\n또는 기본값을 반환할 수도 있습니다 — 이 경우에는 0:\n\n\n\n```js\nlet parsed_int_result = submitted_str.parse::\u003ci32\u003e();\n\nlet parsed_int = match parsed_int_result {\n    Ok(data) =\u003e data,\n    Err(error) =\u003e 0,\n};\n```\n\n이 작업에 대한 단축 방법도 있습니다: unwrap_or_default .\n\n물론 JavaScript에서도 이런 종류의 동작이 가능하지만, 차이점은 JavaScript에서는 선택으로 참여해야 하지만 Rust에서는 unwrap을 사용하여 선택으로 제외해야 합니다.\n\n또 다른 말로는 JavaScript에서는 에러를 의식적으로 처리해야 합니다. 반면에 Rust에서는 에러를 처리하든지 성공적인 경로만 신경 쓸 것이라고 의식적으로 결정해야 합니다.\n\n\n\n# 선택적 값\n\nRust는 선택적인 값 처리에 비슷한 접근법을 사용합니다. TypeScript에서는 편리한 ?를 사용하여 값이 정의되지 않을 수 있다는 것을 나타낼 수 있습니다.\n\n```js\ninterface User {\n  _id: string;\n  name?: string;\n}\n\nfunction sayHello(user: User) {\n  return `Hello ${user.name}!`;\n}\n```\n\n이 TypeScript 코드는 문제없이 컴파일될 것이지만, 우리가 원치 않는 값을 반환할 위험이 있습니다!\n\n\n\n하지만 Option 열거형을 사용하여 Rust에서 비슬한 내용을 작성하면 컴파일 시간 오류가 발생합니다.\n\n```rust\nstruct User {\n  _id: String,\n  name: Option\u003cString\u003e,\n}\n\nfn say_hello(user: User) -\u003e String {\n    let name = user.name;\n    format!(\"Hello {name}!\")\n}\n```\n\n위의 코드는 Option을 format! 매크로 안에 사용할 수 없다는 경고를 보여줍니다. 이것은 예상치 못한 결과를 반환하는 것을 방지합니다. 대신, 이 가능성을 처리하도록 강제됩니다. 다음은 match를 사용한 하나의 해결책입니다:\n\n```rust\nstruct User {\n  _id: String,\n  name: Option\u003cString\u003e,\n}\n\nfn say_hello(user: User) -\u003e String {\n  let name: String = match user.name {\n    Some(name) =\u003e name,\n    None =\u003e \"world\".to_string(),\n  };\n\n  format!(\"Hello {name}!\")\n}\n```\n\n\n\n한 번 더 말하지만, TypeScript에서는 이것을 달성할 수 있습니다. 그리고 더 간결합니다. 하지만 두 언어 간의 주요 차이점은 TypeScript에서는 개발자가 잠재적 문제를 인식해야 한다는 점입니다. 그래서 \"Hello undefined\"를 반환하지 않도록 주의를 기울여야 합니다. 그러나 Rust에서는 name이 사용 불가능한 시나리오를 처리하지 않을 경우 코드가 컴파일되지 않습니다.\n\n이 예제와 같이 간단한 경우에는 보다 번거로운 접근 방식의 이점을 인식하기가 어려울 수 있습니다. 왜냐하면 무엇이 잘못될 수 있는지 쉽게 알아볼 수 있기 때문입니다. 하지만 한 번이라도 대규모 응용 프로그램을 작업해본 적이 있다면, Rust의 opt-out 접근 방식이 많은 잠재적 사고로부터 우리를 구해낼 수 있다는 것이 분명해집니다.\n\n# 소유권과 대여\n\n마지막으로, 소유권과 대여에 대해 얘기하고 싶습니다. 이 개념들은 Rust와 같은 저수준 언어에서는 높은 수준의 TypeScript와는 달리 의미가 훨씬 크다는 것을 감안하면서요.\n\n\n\nTypeScript에서는 값을 변이(mutate)하거나 복제(clone)하는지 주의해야 합니다.\n\n```js\nconst arrayToBeMutated: string[] = [\"d\", \"c\", \"b\", \"a\"];\nconst arrayToBeCloned: string[] = [\"d\", \"c\", \"b\", \"a\"];\n\narrayToBeMutated.sort();\narrayToBeCloned.toSorted();\n\nconsole.log(arrayToBeMutated);  // [\"a\", \"b\", \"c\", \"d\"]\nconsole.log(arrayToBeCloned);   // [\"d\", \"c\", \"b\", \"a\"]\n```\n\n위의 TypeScript 코드에서 sort는 배열을 현재 위치에서 정렬하여 원래 값을 변경하여 변이합니다. 그러나 toSorted는 복제본을 생성하여 새 변수에 할당할 수 있으며, 원래 배열을 그대로 유지합니다.\n\n일반적으로 TypeScript와 같은 언어에서는 변이(mutate)를 피하기 위해 toSorted와 같은 비파괴적 메서드가 종종 선호됩니다. 변이된 변수를 추적하는 것은 까다로울 수 있고, 메모리나 성능에 명확한 이점이 없는 한 전혀 하지 않는 것이 보편적으로 더 나은 방법으로 여겨집니다.\n\n\n\n하지만 Rust를 사용하면 더 깊게 들어갈 수 있고, 값을 변이하거나 복제하는 데 훨씬 명시적일 수 있어서 메모리를 효율적으로 사용하고 값이 그 영광스러운 목적을 수행한 후에도 메모리를 더 쉽게 해제할 수 있습니다.\n\n먼저, 모든 변수는 기본적으로 불변이며, mut 키워드로 명시적으로 변경 가능하도록 표시해야 합니다.\n\n다음 코드는 오류를 발생시킵니다:\n\n```js\nlet foo = 10;\nfoo += 10;\n```\n\n\n\n이 코드는 다음을 수행하지 않습니다:\n\n```js\nlet mut foo = 10;\nfoo += 10;\n```\n\n이것은 JavaScript에서의 let와 const와 대략 동등한 것처럼 느껴집니다. 그러나 Rust는 더 나아갑니다.\n\n예를 들어, JavaScript에서는 배열과 같은 일부 변수 유형이 항상 가변적(mutable)입니다. const를 사용하여 생성하더라도 push, pop 및 인덱스 재할당을 할 수 있습니다. 그러나 Rust에서는 이 작업을 수행하려면 mut이 필요합니다:\n\n\n\n```js\nlet mut nums: Vec\u003ci32\u003e = vec![1, 2, 3, 4, 5];\nnums.push(6);\n```\n\n러스트는 또한 우리가 변수에서 다른 변수로 값을 소유권을 옮길 수 있도록 하는 기능을 제공합니다. 아래 예시를 살펴보세요:\n\n```js\nlet nums: Vec\u003ci32\u003e = vec![1, 2, 3, 4, 5];\nlet doubles: Vec\u003ci32\u003e = nums.into_iter().map(|n| n * 2).collect();\n\ndbg!(nums);     // 이 코드는 오류를 발생시킵니다.\ndbg!(doubles);\n```\n\n위 코드는 오류가 발생합니다. 왜냐하면 into_iter 메서드는 \"소비형 반복자(consuming iterator)\"를 생성하는데, 다시 말해 nums로부터 소유권을 가져와 doubles에게 주기 때문입니다. 그렇기 때문에 doubles를 만든 후에는 dbg!(nums)를 호출할 수 없습니다.\n\n\n\nnums에 액세스할 수는 있지만 값을 복제하고 싶을 때, into_iter 대신에 iter 메서드를 사용할 수 있습니다. 중요한 점은 Rust가 우리에게 선택권을 주고 소유권을 전달할 수 있는 능력을 통해 메모리 할당을 더 효율적으로 관리할 수 있다는 것입니다.\n간단한 값을 이동시키는 것도 가능합니다. 아래 코드에서 str 변수가 calculate_length의 인수로 사용될 때, 해당 변수에 더 이상 액세스할 수 없게 됩니다.\n\n```js\nfn main() {\n    let str = String::from(\"Hello world!\");\n    let len = calculate_length(str);\n    dbg!(str); // 오류 발생\n}\n\nfn calculate_length(s: String) -\u003e usize {\n    s.len()\n}\n```\n\n여기서 우리는 문자열을 전달하는 대신에 문자열의 참조를 전달하기 위해 앰퍼샌드 \u0026를 사용하여 이 문제를 해결할 수 있습니다. 또한 함수의 인수를 참조를 기대하는 형태로 업데이트해야 합니다:\n\n\n\n```rust\nfn main() {\n    let str = String::from(\"hello\");\n    let len = calculate_length(\u0026str);\n    dbg!(str, len);\n}\n\nfn calculate_length(s: \u0026String) -\u003e usize {\n    s.len()\n}\n```\n\n또 반대로 값을 역참조하기 위해 별표 * 를 사용할 수 있습니다. 이러한 기능들은 우리가 메모리를 안전하고 효율적으로 제어하는 데 도움이 됩니다. 이로 인해 Rust는 가비지 컬렉터에 의존할 필요가 없으며, C와 같은 언어에서의 위험을 피하면서 더 높은 성능 수준을 발휘할 수 있게 됩니다. C 언어처럼 개발자에게 막대한 책임을 요구하는 언어와 다르게 안전하고 효율적으로 메모리를 관리할 수 있습니다!\n\n내가 Rust를 배우고 사용한 초기 경험은 매우 긍정적이었습니다. 다른 언어들에 비해서 시작하기가 조금 어려웠지만, Rust를 배우면서 내가 매일 사용하는 고수준 언어들의 기본적인 작동 방식에 대해 더 많은 인식을 가질 수 있었다고 느꼈습니다. 개인 프로젝트에서 더 많이 사용할 기대감이 있습니다.\n\nRust에 처음 입문하거나 해당 언어를 배워보고자 하는 분들에게, 특히 다른 고수준 언어에서 왔다면, 이 글이 유용했으면 좋겠습니다. 물론 이 글은 단순한 내용이며, 특성(traits)이나 라이프타임(lifetimes)과 같은 여러 주제들이 있으나 이 글의 범위를 벗어납니다. 더 알고 싶으면 The Book을 참고하고 아래 댓글에서 여러분의 경험을 공유해보세요!\n","ogImage":{"url":"/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png"},"coverImage":"/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper_0.png\" alt=\"My experience learning Rust as a TypeScript developer\"\u003e\u003c/p\u003e\n\u003cp\u003e많은 개발자들처럼, 나 또한 웹 기술에 중점을 두며 프로그래밍 경력을 시작했습니다. 이것은 시작하기에 좋은 곳이라고 생각하며, 인터넷의 언어이자 많은 기능을 갖춘 JavaScript는 매우 다재다능한 선택이라고 생각합니다.\u003c/p\u003e\n\u003cp\u003e저는 JavaScript와 같은 고수준 언어에 대한 경험이 쌓을수록, 어떻게 작동하는지에 대해 더 많은 관심을 가지기 시작했습니다. 그들은 어떤 선택과 타협을 하고 있는지, 고수준 추상화의 혜택과 비용은 무엇인지 궁금해졌습니다.\u003c/p\u003e\n\u003cp\u003e저에게 이러한 깊은 이해를 얻는 가장 좋은 방법 중 하나는 저수준 프로그래밍 언어를 배우는 것입니다. 결국 이러한 언어들은 일반적으로 JavaScript 코드를 구문 분석하고 해석하는 언어입니다. 예를 들어, Google Chrome 및 Node.js에서 사용되는 V8 엔진 및 Safari 및 Bun에서 사용되는 WebKit은 모두 C++로 작성되어 있습니다. 그러나 저수준 프로그래밍의 주력언어인 C++이 내 선택 언어는 아니었습니다...\u003c/p\u003e\n\u003ch1\u003e왜 Rust를 선택해야 할까요?\u003c/h1\u003e\n\u003cp\u003e저에게 가장 흥미로운 저수준 프로그래밍 언어 중 하나인 Rust는 매우 흥미롭습니다. 작년에도 8년 연속으로 Rust가 Stack Overflow의 연간 설문 조사에서 가장 존경받는 프로그래밍 언어였습니다.\u003c/p\u003e\n\u003cp\u003eRust 언어는 C 및 C++과 같은 런타임 성능을 약속하면서도 엄격한 타입 시스템, 많은 메모리 안전 기능 및 보다 적극적인 오류 처리 접근 방식을 제공합니다. 따라서 쓰레기 수집기의 오버헤드를 피하고, C와 같은 언어에서 만들기 쉬운 메모리 누수의 위험에서 안전합니다.\u003c/p\u003e\n\u003cp\u003eRust는 다중 패러다임을 갖추고 있어 객체 지향 및 함수형 프로그래밍에서의 개념들을 결합하고 있습니다. Web Assembly을 위해 가장 많이 사용되는 언어로 세 번째 해를 맞이하고, Linux 커널에서도 중요한 언어로 자리매김하고 있습니다. Rust는 JavaScript 세계에서도 주목을 받고 있으며, Deno와 같은 중요한 프로젝트 및 최근에는 LLRT (Amazon의 서버리스 함수용 저지연 런타임)과 같은 프로젝트를 개발하는 데 사용되고 있습니다.\u003c/p\u003e\n\u003ch1\u003e러스트 배우는 방법\u003c/h1\u003e\n\u003cp\u003e다른 프로그래밍 언어와 마찬가지로, 러스트를 배우는 가장 좋은 방법은 그 언어로 무언가를 프로그래밍해 보는 것이라고 생각해요.\u003c/p\u003e\n\u003cp\u003e다만, 러스트의 초기 학습 곡선이 최근 몇 년 동안 시도해 본 다른 언어들보다 가파르다는 느낌을 받으셔서, 그 언어를 사용하기 전에 입문 자료를 더 여유롭게 공부하는 것이 가치가 있다고 생각해요.\u003c/p\u003e\n\u003cp\u003e러스트 기관의 웹사이트에는 좋은 권장사항들이 있어요. 현재로는 더 테스트하기, Rustlings 코스, Rust by Example이 그렇고요. 또한 Rust by Practice도 추천해요. 이것은 Rustlings와 유사한 대화형 코스예요.\u003c/p\u003e\n\u003cp\u003e유튜브에서 NoBoilerplate 채널을 통해 언어에 대해 흥분하게 되었고 일반 Rust 개념에 대한 좋은 설명 소스입니다. Rust를 호스팅에 관심이 있다면, AWS는 플랫폼에서 Rust 지원을 확대하는 좋은 블로그 게시물이 있습니다.\u003c/p\u003e\n\u003cp\u003e본문의 나머지는 Rust에 대한 초심자 안내서가 아닙니다. 그런 정보를 찾고 계시다면, 위의 링크를 따라가는 것을 추천합니다. 대신, 전문가로서 매일 사용하는 TypeScript와 비교하여 Rust를 사용할 때 개발자 경험에서 가장 중요한 차이점 중 일부에 대한 나의 생각을 공유하겠습니다.\u003c/p\u003e\n\u003ch1\u003e컴파일러\u003c/h1\u003e\n\u003cp\u003eRust 컴파일러는 종종 Rust의 가장 좋은 부분 중 하나로 인용되지만 초심자들에게는 가장 짜증이 나는 부분으로 느껴질 수도 있습니다!\u003c/p\u003e\n\u003cp\u003eTypeScript에서 왔는데, 컴파일러가 코딩 경험을 얼마나 바꾸는지 놀랐어요. 많은 개발자들처럼, 보통 제가 값들을 자유롭게 로깅하는 방식의 적절한 디버깅 도구를 피하곤 해왔어요. 하지만 Rust에서는, 컴파일러가 만족할 때까지만 값들을 로깅할 수 있어요.\u003c/p\u003e\n\u003cp\u003e이런 경우에 당황했던 일들이 있어요: 예를 들어, 역직렬화 단계의 엄격한 유형을 작성하기 전에 요청된 JSON 페이로드를 로그로 남기고 싶었어요. (나중에, serde_json::Value 유형을 사용하면 이것을 할 수 있다는 것을 배웠어요).\u003c/p\u003e\n\u003cp\u003e그러나 일반적으로, 컴파일러를 만족시키기 위해 노력하는 것은 보통 제 코드를 실행했을 때, 기대했던 대로 동작한다는 것을 의미했어요. 여기서의 절충안은 꽤 명확해 보여요. 적어도 초보자들에게는 코드를 실행하는 데 더 많은 시간이 걸리지만, 코드가 실행될 때, 더 안전하고 예측 가능하며 성능이 더 좋아요. 쓰기 단계에서 더 많은 작업을 해야하지만, 오류나 메모리 또는 성능 문제의 가능성이 더 낮아지는 경향이 있어요 — 그리고 이러한 이점들은 점점 중요해지는 대형, 커지는 프로젝트의 맥락에서 더욱 중요하게 느껴져요.\u003c/p\u003e\n\u003cp\u003e오류 메시지가 덜 유용한 언어에서 온 개발자들은 오류를 빨리 훑어 넘어가야 한다는 성격을 갖고 있을 수 있어요. 그러나 지금까지 제가 발견한 Rust 컴파일러 오류는 매우 좋았어요. 종종 코드를 실행시키기 위해 무엇을 해야하는지 정확히 말해줘요— 언어와 그 유형에 대해 더 많은 경험과 지식을 쌓을수록, 컴파일러가 무엇을 말하려는지 이해하는 데 더 능숙해지고 있는 것 같아요!\u003c/p\u003e\n\u003ch1\u003e유형 시스템\u003c/h1\u003e\n\u003cp\u003e모든 JavaScript 개발자가 TypeScript을 좋아하지는 않는다는 것을 알고 있어요. 예를 들어, 이 유명한 블로그 포스트를 보세요. 하지만 저는 타입 없이 큰 JavaScript 앱을 작성하는 것이 상상이 되지 않아요. 그러나 TypeScript에도 약점이 있고, 타입이 일등 시민인 언어를 가지는 것에는 많은 장점이 있다는 것을 깨달았어요. Rust의 유형 시스템은 그 중에서도 최고의 기능 중 하나로 칭찬을 받는 편이에요.\u003c/p\u003e\n\u003cp\u003e그렇지만, 저에겐 새로운 개념인 Rust의 유형 시스템의 일부는 Rust에만 있는 것은 아니라는 걸 알았어요. 대부분의 저수준 언어와 마찬가지로, Rust는 변수가 메모리에서 얼마만큼의 공간을 차지할지 매우 구체적으로 지정할 수 있도록 해줘요. 예를 들어, 숫자 값이 항상 0에서 255 사이의 정수일 것을 알고 있다면 8비트 길이를 가진 u8에 할당할 수 있어요. 또는 숫자가 255 이상일 수 있지만, 65,535 미만이라는 것을 알고 있다면, 16비트 u16 유형에 할당할 수 있어요 — 그리고 계속해서 할당해 나갈 수 있어요.\u003c/p\u003e\n\u003cp\u003e그러나 Rust도 다른 저수준 언어보다 한 걸음 더 나아간다고 할 수 있어요. 예를 들어, C의 char[] 유형 대신에 적어도 여덟 가지 문자열 유형을 제공하며, 우리에게 '발목을 쐐는 일'을 피할 수 있도록 도와줘요. (물론, 걱정하지 마세요, 대부분의 사용 사례는 \u0026#x26;str과 String으로 충분히 커버돼 있어요!)\u003c/p\u003e\n\u003cp\u003e물론 TypeScript는 메모리 관리에 대한 이러한 세밀한 수준을 제공하지 않습니다. 왜냐하면 JavaScript는 메모리 관리에 대해 걱정하지 않도록 설계되어 있기 때문에 메모리를 할당합니다. 이는 우리에게 일을 줄여주지만 JavaScript 엔진은 프로그램이 실행되는 동안 동적으로 메모리를 할당해야 하므로 덜 효율적입니다. 소규모로는 큰 차이가 없지만 대규모 응용 프로그램에서 더 효율적이고 목적적인 메모리 할당은 프로그램이 훨씬 작은 메모리 공간을 차지할 수 있게 해줍니다.\u003c/p\u003e\n\u003ch2\u003e메모리 할당\u003c/h2\u003e\n\u003cp\u003eTypeScript에서는 우리의 타입을 읽지 않는 JavaScript 위에 타입 주석을 덧붙입니다. TypeScript 코드가 빌드될 때마다 이 주석들은 제거됩니다.\u003c/p\u003e\n\u003cp\u003eRust와 같이 타입이 일급 시민인 다른 언어들에서는 타입 주석이 주석 이상의 역할을 하며 해당 특정 타입에 대해 메모리를 할당하고 그 값이 주어진 타입을 가질 것임을 우리에게 보장합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 아래의 parse 메서드에 i8 타입을 전달하면 small_int에 8비트의 메모리가 예약됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003esmall_int\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"127\"\u003c/span\u003e.parse::\u0026#x3C;\u003cspan class=\"hljs-type\"\u003ei8\u003c/span\u003e\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eparse 메서드는 변수의 타입에서도 타입을 추론할 수 있기 때문에 다음과 같이도 작성할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003esmall_int\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003ei8\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"127\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eparse\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 경우, 컴파일러는 주어진 형식이 허용하는 메모리를 초과하려고 시도하면 우리에게 소리를 질립니다. 따라서 문자열 \"128\"을 i8로 구문 분석하려고 하면 컴파일할 수 없게 됩니다.\u003c/p\u003e\n\u003cp\u003e타입스크립트와 비교해보면, 타입 표시는 단지 마커일 뿐입니다. 그들은 밑바탕 타입이나 할당된 메모리를 변화시키지 않습니다. 아래 예시에서 타입스크립트는 x가 문자열이라고 예상합니다. 그러나 밑바탕 자바스크립트에서는 숫자로 취급됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e unknown \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e string;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예는 조금 불합리한 예제입니다; 우리는 잘못된 타입을 강제로 할당하려고 unknown을 탈출구로 사용하고 있습니다!\u003c/p\u003e\n\u003cp\u003e그러나 이것은 이해하기 쉬운 간단한 예제입니다. 실제 응용 프로그램에서는 더 복잡한 데이터 유형이나 제3자로부터 가져온 데이터를 다룰 때 TypeScript가 현실을 잘못 표현하기 쉬워집니다.\u003c/p\u003e\n\u003ch1\u003e오류 처리\u003c/h1\u003e\n\u003cp\u003e다시 한번 문자열을 정수로 변환하는 예제를 살펴봅시다. 이번에는 사용자가 제공한 문자열을 정수로 취급하니, 우리가 정확히 파싱할 수 있다고 보장할 수 없게 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e parsed_int = submitted_str.\u003cspan class=\"hljs-property\"\u003eparse\u003c/span\u003e::\u0026#x3C;i32\u003e().\u003cspan class=\"hljs-title function_\"\u003eunwrap\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서는 성공적으로 구문 분석한 값을 가져오기 위해 unwrap을 사용하고 있습니다. 그러나 이 방식은 일반적으로 권장되지 않습니다. 대신 Rust는 오류를 수동으로 처리하도록 강제하는 Result 열거형을 제공합니다.\u003c/p\u003e\n\u003cp\u003e우리는 여전히 panic! 매크로를 사용하여 프로그램을 패닉 상태로 만들 수 있지만, 잘못된 내용을 빠르게 이해할 수 있는 사용자 정의 오류 메시지를 전달할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e parsed_int_result = submitted_str.\u003cspan class=\"hljs-property\"\u003eparse\u003c/span\u003e::\u0026#x3C;i32\u003e();\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e parsed_int = match parsed_int_result {\n    \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(data) =\u003e data,\n    \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(error) =\u003e panic!(\n        \u003cspan class=\"hljs-string\"\u003e\"주어진 문자열을 정수로 구문 분석할 수 없습니다: {:?}\"\u003c/span\u003e,\n        error\n    ),\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 기본값을 반환할 수도 있습니다 — 이 경우에는 0:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e parsed_int_result = submitted_str.\u003cspan class=\"hljs-property\"\u003eparse\u003c/span\u003e::\u0026#x3C;i32\u003e();\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e parsed_int = match parsed_int_result {\n    \u003cspan class=\"hljs-title class_\"\u003eOk\u003c/span\u003e(data) =\u003e data,\n    \u003cspan class=\"hljs-title class_\"\u003eErr\u003c/span\u003e(error) =\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 작업에 대한 단축 방법도 있습니다: unwrap_or_default .\u003c/p\u003e\n\u003cp\u003e물론 JavaScript에서도 이런 종류의 동작이 가능하지만, 차이점은 JavaScript에서는 선택으로 참여해야 하지만 Rust에서는 unwrap을 사용하여 선택으로 제외해야 합니다.\u003c/p\u003e\n\u003cp\u003e또 다른 말로는 JavaScript에서는 에러를 의식적으로 처리해야 합니다. 반면에 Rust에서는 에러를 처리하든지 성공적인 경로만 신경 쓸 것이라고 의식적으로 결정해야 합니다.\u003c/p\u003e\n\u003ch1\u003e선택적 값\u003c/h1\u003e\n\u003cp\u003eRust는 선택적인 값 처리에 비슷한 접근법을 사용합니다. TypeScript에서는 편리한 ?를 사용하여 값이 정의되지 않을 수 있다는 것을 나타낼 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einterface \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003e_id\u003c/span\u003e: string;\n  name?: string;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esayHello\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003euser: User\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`Hello \u003cspan class=\"hljs-subst\"\u003e${user.name}\u003c/span\u003e!`\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 TypeScript 코드는 문제없이 컴파일될 것이지만, 우리가 원치 않는 값을 반환할 위험이 있습니다!\u003c/p\u003e\n\u003cp\u003e하지만 Option 열거형을 사용하여 Rust에서 비슬한 내용을 작성하면 컴파일 시간 오류가 발생합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  _id: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e,\n  name: \u003cspan class=\"hljs-type\"\u003eOption\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e\u003e,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esay_hello\u003c/span\u003e(user: User) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ename\u003c/span\u003e = user.name;\n    \u003cspan class=\"hljs-built_in\"\u003eformat!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Hello {name}!\"\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 코드는 Option을 format! 매크로 안에 사용할 수 없다는 경고를 보여줍니다. 이것은 예상치 못한 결과를 반환하는 것을 방지합니다. 대신, 이 가능성을 처리하도록 강제됩니다. 다음은 match를 사용한 하나의 해결책입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  _id: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e,\n  name: \u003cspan class=\"hljs-type\"\u003eOption\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e\u003e,\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esay_hello\u003c/span\u003e(user: User) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003ematch\u003c/span\u003e user.name {\n    \u003cspan class=\"hljs-title function_ invoke__\"\u003eSome\u003c/span\u003e(name) =\u003e name,\n    \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e =\u003e \u003cspan class=\"hljs-string\"\u003e\"world\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_ invoke__\"\u003eto_string\u003c/span\u003e(),\n  };\n\n  \u003cspan class=\"hljs-built_in\"\u003eformat!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Hello {name}!\"\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e한 번 더 말하지만, TypeScript에서는 이것을 달성할 수 있습니다. 그리고 더 간결합니다. 하지만 두 언어 간의 주요 차이점은 TypeScript에서는 개발자가 잠재적 문제를 인식해야 한다는 점입니다. 그래서 \"Hello undefined\"를 반환하지 않도록 주의를 기울여야 합니다. 그러나 Rust에서는 name이 사용 불가능한 시나리오를 처리하지 않을 경우 코드가 컴파일되지 않습니다.\u003c/p\u003e\n\u003cp\u003e이 예제와 같이 간단한 경우에는 보다 번거로운 접근 방식의 이점을 인식하기가 어려울 수 있습니다. 왜냐하면 무엇이 잘못될 수 있는지 쉽게 알아볼 수 있기 때문입니다. 하지만 한 번이라도 대규모 응용 프로그램을 작업해본 적이 있다면, Rust의 opt-out 접근 방식이 많은 잠재적 사고로부터 우리를 구해낼 수 있다는 것이 분명해집니다.\u003c/p\u003e\n\u003ch1\u003e소유권과 대여\u003c/h1\u003e\n\u003cp\u003e마지막으로, 소유권과 대여에 대해 얘기하고 싶습니다. 이 개념들은 Rust와 같은 저수준 언어에서는 높은 수준의 TypeScript와는 달리 의미가 훨씬 크다는 것을 감안하면서요.\u003c/p\u003e\n\u003cp\u003eTypeScript에서는 값을 변이(mutate)하거나 복제(clone)하는지 주의해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003earrayToBeMutated\u003c/span\u003e: string[] = [\u003cspan class=\"hljs-string\"\u003e\"d\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"c\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"b\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003earrayToBeCloned\u003c/span\u003e: string[] = [\u003cspan class=\"hljs-string\"\u003e\"d\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"c\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"b\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e];\n\narrayToBeMutated.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e();\narrayToBeCloned.\u003cspan class=\"hljs-title function_\"\u003etoSorted\u003c/span\u003e();\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arrayToBeMutated);  \u003cspan class=\"hljs-comment\"\u003e// [\"a\", \"b\", \"c\", \"d\"]\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arrayToBeCloned);   \u003cspan class=\"hljs-comment\"\u003e// [\"d\", \"c\", \"b\", \"a\"]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 TypeScript 코드에서 sort는 배열을 현재 위치에서 정렬하여 원래 값을 변경하여 변이합니다. 그러나 toSorted는 복제본을 생성하여 새 변수에 할당할 수 있으며, 원래 배열을 그대로 유지합니다.\u003c/p\u003e\n\u003cp\u003e일반적으로 TypeScript와 같은 언어에서는 변이(mutate)를 피하기 위해 toSorted와 같은 비파괴적 메서드가 종종 선호됩니다. 변이된 변수를 추적하는 것은 까다로울 수 있고, 메모리나 성능에 명확한 이점이 없는 한 전혀 하지 않는 것이 보편적으로 더 나은 방법으로 여겨집니다.\u003c/p\u003e\n\u003cp\u003e하지만 Rust를 사용하면 더 깊게 들어갈 수 있고, 값을 변이하거나 복제하는 데 훨씬 명시적일 수 있어서 메모리를 효율적으로 사용하고 값이 그 영광스러운 목적을 수행한 후에도 메모리를 더 쉽게 해제할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e먼저, 모든 변수는 기본적으로 불변이며, mut 키워드로 명시적으로 변경 가능하도록 표시해야 합니다.\u003c/p\u003e\n\u003cp\u003e다음 코드는 오류를 발생시킵니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e foo = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\nfoo += \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 다음을 수행하지 않습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mut foo = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\nfoo += \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 JavaScript에서의 let와 const와 대략 동등한 것처럼 느껴집니다. 그러나 Rust는 더 나아갑니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, JavaScript에서는 배열과 같은 일부 변수 유형이 항상 가변적(mutable)입니다. const를 사용하여 생성하더라도 push, pop 및 인덱스 재할당을 할 수 있습니다. 그러나 Rust에서는 이 작업을 수행하려면 mut이 필요합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mut \u003cspan class=\"hljs-attr\"\u003enums\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eVec\u003c/span\u003e\u0026#x3C;i32\u003e = vec![\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\nnums.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e러스트는 또한 우리가 변수에서 다른 변수로 값을 소유권을 옮길 수 있도록 하는 기능을 제공합니다. 아래 예시를 살펴보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enums\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eVec\u003c/span\u003e\u0026#x3C;i32\u003e = vec![\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edoubles\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eVec\u003c/span\u003e\u0026#x3C;i32\u003e = nums.\u003cspan class=\"hljs-title function_\"\u003einto_iter\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(|n| n * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ecollect\u003c/span\u003e();\n\ndbg!(nums);     \u003cspan class=\"hljs-comment\"\u003e// 이 코드는 오류를 발생시킵니다.\u003c/span\u003e\ndbg!(doubles);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 오류가 발생합니다. 왜냐하면 into_iter 메서드는 \"소비형 반복자(consuming iterator)\"를 생성하는데, 다시 말해 nums로부터 소유권을 가져와 doubles에게 주기 때문입니다. 그렇기 때문에 doubles를 만든 후에는 dbg!(nums)를 호출할 수 없습니다.\u003c/p\u003e\n\u003cp\u003enums에 액세스할 수는 있지만 값을 복제하고 싶을 때, into_iter 대신에 iter 메서드를 사용할 수 있습니다. 중요한 점은 Rust가 우리에게 선택권을 주고 소유권을 전달할 수 있는 능력을 통해 메모리 할당을 더 효율적으로 관리할 수 있다는 것입니다.\n간단한 값을 이동시키는 것도 가능합니다. 아래 코드에서 str 변수가 calculate_length의 인수로 사용될 때, 해당 변수에 더 이상 액세스할 수 없게 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efn \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e str = \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Hello world!\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e len = \u003cspan class=\"hljs-title function_\"\u003ecalculate_length\u003c/span\u003e(str);\n    dbg!(str); \u003cspan class=\"hljs-comment\"\u003e// 오류 발생\u003c/span\u003e\n}\n\nfn \u003cspan class=\"hljs-title function_\"\u003ecalculate_length\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003es\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e) -\u003e usize {\n    s.\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 우리는 문자열을 전달하는 대신에 문자열의 참조를 전달하기 위해 앰퍼샌드 \u0026#x26;를 사용하여 이 문제를 해결할 수 있습니다. 또한 함수의 인수를 참조를 기대하는 형태로 업데이트해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003estr\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"hello\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003elen\u003c/span\u003e = \u003cspan class=\"hljs-title function_ invoke__\"\u003ecalculate_length\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-type\"\u003estr\u003c/span\u003e);\n    dbg!(\u003cspan class=\"hljs-type\"\u003estr\u003c/span\u003e, len);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculate_length\u003c/span\u003e(s: \u0026#x26;\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eusize\u003c/span\u003e {\n    s.\u003cspan class=\"hljs-title function_ invoke__\"\u003elen\u003c/span\u003e()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또 반대로 값을 역참조하기 위해 별표 * 를 사용할 수 있습니다. 이러한 기능들은 우리가 메모리를 안전하고 효율적으로 제어하는 데 도움이 됩니다. 이로 인해 Rust는 가비지 컬렉터에 의존할 필요가 없으며, C와 같은 언어에서의 위험을 피하면서 더 높은 성능 수준을 발휘할 수 있게 됩니다. C 언어처럼 개발자에게 막대한 책임을 요구하는 언어와 다르게 안전하고 효율적으로 메모리를 관리할 수 있습니다!\u003c/p\u003e\n\u003cp\u003e내가 Rust를 배우고 사용한 초기 경험은 매우 긍정적이었습니다. 다른 언어들에 비해서 시작하기가 조금 어려웠지만, Rust를 배우면서 내가 매일 사용하는 고수준 언어들의 기본적인 작동 방식에 대해 더 많은 인식을 가질 수 있었다고 느꼈습니다. 개인 프로젝트에서 더 많이 사용할 기대감이 있습니다.\u003c/p\u003e\n\u003cp\u003eRust에 처음 입문하거나 해당 언어를 배워보고자 하는 분들에게, 특히 다른 고수준 언어에서 왔다면, 이 글이 유용했으면 좋겠습니다. 물론 이 글은 단순한 내용이며, 특성(traits)이나 라이프타임(lifetimes)과 같은 여러 주제들이 있으나 이 글의 범위를 벗어납니다. 더 알고 싶으면 The Book을 참고하고 아래 댓글에서 여러분의 경험을 공유해보세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-13-MyexperiencelearningRustasaTypeScriptdeveloper"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>