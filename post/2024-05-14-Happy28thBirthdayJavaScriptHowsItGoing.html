<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>JavaScript의 28번째 생일 축하해요 어떻게 지내고 있나요 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="JavaScript의 28번째 생일 축하해요 어떻게 지내고 있나요 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="JavaScript의 28번째 생일 축하해요 어떻게 지내고 있나요 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing" data-gatsby-head="true"/><meta name="twitter:title" content="JavaScript의 28번째 생일 축하해요 어떻게 지내고 있나요 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 13:41" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">JavaScript의 28번째 생일 축하해요 어떻게 지내고 있나요</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="JavaScript의 28번째 생일 축하해요 어떻게 지내고 있나요" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>JavaScript과 나는 생일이 같아요. 난 어린이였던 그 때에는 레고, 책, 그리고 곱셈표를 발견한 바로 그 때였어요. 1995년, 난 컴퓨터를 한 번도 보지 못했어요. 베를린의 장벽이 무너져내리고 철의 커튼이 열리기까지도 어딘가에서는 일어난 일들이었어요. 동유럽에서는 컴퓨터는 마음속에서 가장 먼 곳에 있었죠. 하지만 세계 반대편에서 중요한 일이 있었어요. 오늘날 우리가 알고 있는 웹과 기술을 가능케 한 일이죠. 그것이 바로 JavaScript인데, 누구도 중요하게 여기지 않았습니다. 윈도우 1995가 열광의 중심이었을 때, 누구나 어떤 어린 스크립트 언어에 대해 신경 쓸 이유가 있었을까요?</p>
<h2>JavaScript의 역사로 가는 롤러코스터</h2>
<p>아마도 브랜든 아이치, 넷스케이프, 썬 마이크로시스템즈의 리더십을 제외하고는, 현재의 모든 인터넷 사용자를 위한 12월 4일의 순간이 얼마나 중요해질지 정말 아무도 몰랐을 거예요.</p>
<p>JavaScript가 시작되었던 사실 중에 잘 알려지지 않은 것 하나는 그것이 언어가 되기로 의도된 것이 아니었다는 것이에요. 브랜든 아이치를 고용했을 때의 목표는 넷스케이프에 스킴 언어를 통합하는 것이었지만, 동시에 자바도 통합하려고 노력했습니다. 그러나 헝가리 속담에는 &quot;두 마리 토끼를 쫓다가 한 마리도 잡지 못한다&quot;라는 말이 있는데, 여기서도 적용되죠. 우리가 지금 알게 된 대로, 자바나 스킴은 브라우저에 통합되지 않았고, 넷스케이프의 경영진은 토끼를 쫓는 것을 멈추고 자바보다는 자바와 가까운 문법이 적용된 새로운 언어를 개발하기로 결정했어요.</p>
<p>공식 릴리스가 된 12월까지는 이 언어가 JavaScript가 아니라 LiveScript라는 이름을 갖지 않았어요. 28년이 지난 지금도 제 생각에는 그 이름이 넷스케이프 경영진이 선택한 이름보다 훨씬 적합하다고 생각해요. 특히 Web 2.0과 Ajax의 소개 이후로 JavaScript의 주요 이점 중 하나는 페이지 새로 고침이 필요하지 않는 실시간 웹 애플리케이션을 가능하게 하는 능력이에요.</p>
<p>10년이 흘러 2006년에는 우리가 사랑하고 미워하는 jQuery가 나왔어요. 단독으로 StackOverflow를 웹 개발자들에게 지옥으로 만든 라이브러리예요. 그리고 그래서 태어났죠. 단순한 JavaScript로 작성된 코드에 손 대지 않을 JS 엘리트들도 있는 반면 jQuery &quot;개발자&quot;를 어디서든 비하하는 JS 스노브도 있어요. 제 경우 어느 캠프에도 속하지 않는 것 같아요.</p>
<p>물론 모든 상황에 이상적인 선택은 아니에요. 예를 들어 버전 3.0.0의 주요 문제는 dataType 옵션이 지정되지 않은 상태에서 교차 도메인 Ajax 요청을 수행했을 때 크로스사이트 스크립팅(XSS) 공격에 취약하다는 점이에요. jQuery 열차에 올라타기 전에 모든 개발자들이 알아야 할 실제적인 문제지요.</p>
<p>jQuery의 인기에서 영감을 받았거나 &quot;JS를 더 나아지게 만들어야 한다&quot;는 지속적인 요구에 의해 2009년 3년 뒤에는 아무도 실제로 요청하지 않았던 CoffeeScript가 등장했어요. &quot;Java&quot;가 &quot;커피&quot;를 뜻하기도 하니 그 새 언어의 이름으로는 너무나 분명한 선택이었을 지도 모르지만, 우리 개발자들은 명명하는 것에서 진짜 열악해요. 그래서 그 이름은 자리를 지켰죠. 브랜든 아이크는 자신의 생각에 JavaScript의 미래에 영향을 미치는 요인으로서 이 언어를 언급했어요. 그 말로 우스움 있어도 사랑받은 것이죠. 하게, Ruby on Rails 3.1에는 CoffeeScript를 내장 지원하는 기능이 있었는데, RoR이 얼마나 인기가 있었는지(시대에 따라 아직도 그렇죠.) 생각해보면 전혀 작지 않은 일이죠.</p>
<p>세 년 뒤인 2012년에, 바닐라 JS 애호가들이 겸허함을 배우는 때가 왔습니다. 마이크로소프트가 JavaScript를 &quot;개선&quot;하기로 결정하는 바람에요. 그러나 그들의 엔지니어들은 CoffeeScript처럼 JS로 컴파일되는 새 언어를 만들지 않고, 덜 고통스러운 슈퍼셋 경로를 선택했어요. 위키피디아에 따르면:</p>
<p>누군가는 이것에 논쟁할지도 모르지만, 그 인기는 부정할 수 없죠. 이것은 많은 소프트웨어 엔지니어들의 상상력과 주의를 사로잡았습니다. 그것은 갑자기 강력하게 타입이 지정된 언어를 좋아하는 많은 소프트웨어 엔지니어들의 관심을 끌었기 때문에, 갑자기 바닐라 JS 애호가들은 TS보다 JS를 지지하게 되었어요. 2023년에는 원래의 언어와 그 슈퍼셋 간에 어느 정도 균형이 이루어졌지만, 최근에는 Svelte와 Turbo 8와 같은 프레임워크가 TypeScript를 버리고 부담이 적은 다른 솔루션을 선호하는 모습을 보여주기도 해서, 마이크로소프트의 개선된 JS의 미래는 확실하지 않습니다.</p>
<p>한편, 자바스크립트 뒤의 ECMAScript 표준은 멈추지 않았습니다. 그래서 또 세 년 후인 2015년에, 웹 개발자들은 드디어 브라우저에서 자연스럽게 실행되는 자신들의 가장 좋아하는 언어에 중요한 업데이트를 얻었어요. ES6 (ECMAScript 2015)는 오랜 시간 동안 가장 중요한 변화였으며, 모든 변화가 개발자들에 의해 매우 환영을 받았어요. 몇 주 안에, 개발자들은 화살표 함수, 템플릿 문자열 및 상수를 사랑하게 되었죠. 물론 이것들은 빙산의 일각에 불과했습니다.</p>
<p>2015년 이후로 매년 새로운 표준 및 JavaScript로의 업데이트 세트가 도입되고 있습니다. 2023년에는 모든 주요 브라우저에서 심지어 ES7도 아주 잘 지원되며, 실시간 및 동적 애플리케이션 개발이 이전보다 더 직관적이고 편리해지고 있습니다.</p>
<h2>JS 이상의 존재</h2>
<p>자바스크립트의 가장 흥미로운 측면 중 하나는 브라우저에서 동작하는 역사를 가졌다는 것 뿐만 아니라, 어디서든 실행되는 언어가 되었다는 점입니다. 일부 사람들은 &quot;할 수 없다고 해서 반드시 해서는 안 된다&quot;고 강력히 이야기할지 모르지만, 자바스크립트는 가장 이색적인 플랫폼에서도 다양한 해결책을 개발할 수 있도록 해주었습니다.</p>
<p>JS를 백엔드에서 실행하거나 OS에서 실행하고 싶나요? 가능합니다. Node.js, Deno 그리고 이제 Bun까지 모두 사용하실 수 있습니다. 흔히 사용되는 많은 경우를 위해 바퀴를 다시 발명할 필요 없이 최신 UI를 구축하고 싶다면, React, Vue, Svelte, Angular 및 기타 다양한 UI 라이브러리와 프레임워크를 선택할 수 있습니다. 대부분의 경우 서버 사이드 렌더링을 기본으로 지원하기 때문에 따로 추가 패키지가 필요하지 않습니다. 데스크톱 및 모바일용 네이티브 애플리케이션을 만들 수도 있습니다. 필요한 것은 Electron이나 Ionic 뿐입니다.</p>
<p>하지만 JS는 더 나아갑니다. 작은 퍽을 블루투스 파워포인트 프레젠터 리모컨으로 변신시킨 것처럼 임베디드 시스템이나 마이크로컨트롤러에서 실행할 수도 있습니다. 놀랍게도, 자바스크립트는 게임 개발에도 탁월합니다. 따라서 플래피 버드나 요즘 아이들이 하는 게임을 만드는 데 어려움은 없을 것입니다. 저는 게이머가 아니며 게임을 즐기기에 충분히 심심하지 않습니다. LEGO를 쌓는 것이 취미죠. 😁</p>
<p>자바스크립트는 겸손한 언어에서 전체 스택으로 발전했는데, 이것은 소프트웨어 개발 세계에서 엄청난 파워를 발휘합니다. 개발자 뿐만 아니라 스마트한 비용 절약 결정을 내리고 싶은 기업에게도 이점이 있죠. 자바스크립트는 더 이상 개발자의 선호도에 그치는 것이 아니라, 훨씬 더 큰 기업 전략 대화로 진화하고 있습니다. 자바스크립트는 현실적으로 돈을 절약하고 벌 수 있으며, 소프트웨어 엔지니어의 기술 세트를 매우 재사용 가능하게 만들어, 그들이 그 외의 경우에 비해 훨씬 더 가치 있게 만듭니다. 동일한 언어를 모든 곳에서 사용할 수 있는 능력은 무척 강력하고 만족스럽습니다.</p>
<h2>&#x27;2023년, 꽤 좋았던 해였어요&#x27;</h2>
<p>2023년은 일반적으로 세상을 볼 때 최고의 해는 아니었을지许는데, 그러나 자바스크립트 팬들로서 우리는 새로운 업데이트를 풍부하게 받았고 그중에서 지루하지 않았죠.</p>
<p>아마도 가장 주목할 만한 유틸리티 함수는 새로운 Object.groupBy()일 거예요. 이제 객체의 속성을 다른 속성 값에 따라 그룹화할 수 있게 되었는데, 에러가 발생하기 쉬운 끝도 없는 코드를 작성하지 않고도 가능하며, 이 과정은 다음과 같이 간단합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> inventory = [
  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;asparagus&quot;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;vegetables&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">5</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;bananas&quot;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;fruit&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">0</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;goat&quot;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;meat&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">23</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cherries&quot;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;fruit&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">5</span> },
  { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;fish&quot;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;meat&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">22</span> },
];

<span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">groupBy</span>(inventory, <span class="hljs-function">(<span class="hljs-params">{ type }</span>) =&gt;</span> type);
</code></pre>
<p>결과는 다음과 같습니다:</p>
<pre><code class="hljs language-js">{
  <span class="hljs-attr">vegetables</span>: [
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;asparagus&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;vegetables&#x27;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">5</span> },
  ],
  <span class="hljs-attr">fruit</span>: [
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;bananas&quot;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;fruit&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">0</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;cherries&quot;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;fruit&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">5</span> }
  ],
  <span class="hljs-attr">meat</span>: [
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;goat&quot;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;meat&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">23</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;fish&quot;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;meat&quot;</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">22</span> }
  ]
}
</code></pre>
<p>이것이 아름다운 것이 아니라면, 무엇이 아름다운지 모르겠어요. 🙂</p>
<p>마침내 배열을 복제하지 않고도 변이를 피하기 위해 원래 배열을 변형하지 않고 배열을 뒤집거나 분할하고 정렬할 수도 있게 되었습니다. 여기에서 작동하는 toReversed(), toSpliced() 및 toSorted()을 살펴봅시다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// toReversed()</span>

<span class="hljs-keyword">const</span> items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(items); <span class="hljs-comment">// [1, 2, 3]</span>

<span class="hljs-keyword">const</span> reversedItems = items.<span class="hljs-title function_">toReversed</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reversedItems); <span class="hljs-comment">// [3, 2, 1]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(items); <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-comment">// toSpliced()</span>

<span class="hljs-keyword">const</span> months = [<span class="hljs-string">&quot;Jan&quot;</span>, <span class="hljs-string">&quot;Mar&quot;</span>, <span class="hljs-string">&quot;Apr&quot;</span>, <span class="hljs-string">&quot;May&quot;</span>];

<span class="hljs-comment">// 인덱스 1에 요소 삽입</span>
<span class="hljs-keyword">const</span> months2 = months.<span class="hljs-title function_">toSpliced</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Feb&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(months2); <span class="hljs-comment">// [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;]</span>

<span class="hljs-comment">// 인덱스 2부터 두 요소 삭제</span>
<span class="hljs-keyword">const</span> months3 = months2.<span class="hljs-title function_">toSpliced</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(months3); <span class="hljs-comment">// [&quot;Jan&quot;, &quot;Feb&quot;, &quot;May&quot;]</span>

<span class="hljs-comment">// 인덱스 1의 요소를 새로운 두 요소로 대체</span>
<span class="hljs-keyword">const</span> months4 = months3.<span class="hljs-title function_">toSpliced</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Feb&quot;</span>, <span class="hljs-string">&quot;Mar&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(months4); <span class="hljs-comment">// [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;May&quot;]</span>

<span class="hljs-comment">// 원본 배열이 수정되지 않음</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(months); <span class="hljs-comment">// [&quot;Jan&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;]</span>
<span class="hljs-comment">// toSorted()</span>

<span class="hljs-keyword">const</span> months = [<span class="hljs-string">&quot;Mar&quot;</span>, <span class="hljs-string">&quot;Jan&quot;</span>, <span class="hljs-string">&quot;Feb&quot;</span>, <span class="hljs-string">&quot;Dec&quot;</span>];
<span class="hljs-keyword">const</span> sortedMonths = months.<span class="hljs-title function_">toSorted</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sortedMonths); <span class="hljs-comment">// [&#x27;Dec&#x27;, &#x27;Feb&#x27;, &#x27;Jan&#x27;, &#x27;Mar&#x27;]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(months); <span class="hljs-comment">// [&#x27;Mar&#x27;, &#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Dec&#x27;]</span>

<span class="hljs-keyword">const</span> values = [<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">21</span>, <span class="hljs-number">2</span>];
<span class="hljs-keyword">const</span> sortedValues = values.<span class="hljs-title function_">toSorted</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sortedValues); <span class="hljs-comment">// [1, 2, 10, 21]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(values); <span class="hljs-comment">// [1, 10, 21, 2]</span>
</code></pre>
<p>JavaScript의 특이한 점들은 나를 거의 짜증나게 하지 않지만, 이러한 개선 사항은 확실히 환영받을 만하며 앞으로 훨씬 깔끔한 코드 베이스로 이어집니다.</p>
<p>올해 나를 흥분하게 한 마지막 것은 HTML5의 dialog 태그이며, 이제 내장된 showModal() 및 close() 함수가 있습니다. 이제 대화 상자나 모달을 열고 닫을 수 있습니다:</p>
<pre><code class="hljs language-js">dialog.<span class="hljs-title function_">showModal</span>();
<span class="hljs-title function_">close</span>(); <span class="hljs-comment">// 당신은 안쪽에 값도 반환할 수 있어</span>
</code></pre>
<p>이거 정말 멋지지 않아요!</p>
<p>물론, 대부분의 주요 JS 프레임워크도 상당한 변화를 겪었죠. create-react-app은 사라졌고 이제 Next.js가 대부분의 미래 React 애플리케이션과 동의어가 되었습니다. 또한, Next.js v13에서 채택된 React 서버 사이드 컴포넌트로 API를 호출할 수도 있어요.</p>
<p>Svelte도 눈에 띄게 변화하고자 했고, 웹에서 &quot;반응성&quot;을 다시 생각하기 위해 &quot;룬&quot; 개념을 도입했어요. 기본적으로 컴파일 시간 반응성에서 섬세한 단위의 반응성으로 전환하는 것이죠. 그들이 말하는 바에 따르면:```</p>
<p>하지만 Angular 17보다 더 빠를까요? 여전히 제 마음 속에 가장 가까운 JS 프레임워크는 2023년 11월에 17버전에 도달했으며, 오랜 시간 만에 가장 큰 변화 중 하나를 가져왔습니다. 누구나 새로운 템플릿 구문을 바로 알아차릴 것입니다. 즉, 이제 ngIf와 ngFor를 작별하게 되었습니다.</p>
<p>이것은 프론트엔드에서의 변화 중 하나일 뿐입니다. 백엔드에서도 Node.js는 조용히 개선되고 있습니다. 그중 하나의 주목할만한 업데이트는 --experimental-websocket 플래그인 도입으로 Node 21에서 자체 웹소켓 클라이언트를 소개했습니다.</p>
<p>Node.js가 명백히 매우 인기가 많다는 것은 2023년에 새로운 경쟁 상대가 나타나지 않았다는 것을 의미하지 않습니다. Bun.js는 올인원 JavaScript 런타임이며, 특정 환경에서 Node보다 5배 이상 빠르다고 합니다. Bun 팀은 다음과 같이 주장합니다:</p>
<p>아직 초기 단계이지만 확실히 약속을 보여줍니다. 하지만 저는 여전히 Node나 Deno를 한동안 사용하는 것을 선호합니다.</p>
<h2>JS의 다음은 무엇일까요?</h2>
<p>그래서, 28년 만에 JavaScript의 다음은 무엇일까요? 실제 기능 측면에서는, 우리는 무엇을 기대해야 하는지 알고 있습니다. ES 제안의 제3 단계 후보는 상당히 많은데요 — 총 14개 — 모두 충분히 흥미롭어서 곧 현실이 될 것으로 예상됩니다. 초안에서는 23개 제안이 있으며, 그 중 일부는 수천 표를 받았습니다. 반면 제안 단계 1에서는 총 90개가 있습니다. 하지만 그 중 대부분은 단계 2 또는 3에 도달할 가능성이 적을 것으로 생각합니다.</p>
<p>생태계 측면에서, JavaScript는 계속 번창할 것으로 생각됩니다. IEEE.org에 따르면, 2023년에 가장 인기 있는 언어 중 3위에 올랐으며, 앞으로 몇 년 동안 이것이 크게 변할 것 같지는 않습니다. 직업 기회 측면에서 보면, SQL, Python, 그리고 Java 다음으로 가장 많이 찾는 기술이 되었습니다. 🎉</p>
<p><img src="/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_1.png" alt="JavaScript Birthday"/></p>
<p>사랑하든 싫어하든, JavaScript는 활기차고 성숙하며 열정적인 커뮤니티를 갖고 있습니다. 이 커뮤니티는 JavaScript를 오롯이 유지하는 것뿐만 아니라 새로운 높이로 끌어올리고 있습니다. JS로 무엇이든 구축하는 방법에 대한 정보는 파이썬만큼이나 풍부합니다. 이는 프로그래밍에 새로운 사람들에게 접근하기 쉬운 언어이며, 아마도 파이썬보다 더 쉽게 접근할 수 있다고 말해도 좋을 것입니다. 네, 이상한 점들이 있지만, 저는 한 사람으로서 이를 사랑하고 함께 일하며 조정하기를 배웠습니다.</p>
<p>생일 축하, JavaScript! 🍻🎂</p>
<p>Attila Vago - 세상을 하나의 코드 줄씩 개선하는 소프트웨어 엔지니어. 영원한 멋쟁이, 코드와 블로그의 작가. 웹 접근성 옹호자, 레고 팬, 비닐 레코드 컬렉터. 수제 맥주를 좋아합니다! 제 &quot;안녕 이야기&quot;를 여기서 읽어보세요! 레고, 기술, 코딩 및 접근성에 관한 더 많은 이야기를 구독하세요! 가끔씩 방문하시는 독자분들을 위해 랜덤 이야기와 글도 써봅니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JavaScript의 28번째 생일 축하해요 어떻게 지내고 있나요","description":"","date":"2024-05-14 13:41","slug":"2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing","content":"\n\nJavaScript과 나는 생일이 같아요. 난 어린이였던 그 때에는 레고, 책, 그리고 곱셈표를 발견한 바로 그 때였어요. 1995년, 난 컴퓨터를 한 번도 보지 못했어요. 베를린의 장벽이 무너져내리고 철의 커튼이 열리기까지도 어딘가에서는 일어난 일들이었어요. 동유럽에서는 컴퓨터는 마음속에서 가장 먼 곳에 있었죠. 하지만 세계 반대편에서 중요한 일이 있었어요. 오늘날 우리가 알고 있는 웹과 기술을 가능케 한 일이죠. 그것이 바로 JavaScript인데, 누구도 중요하게 여기지 않았습니다. 윈도우 1995가 열광의 중심이었을 때, 누구나 어떤 어린 스크립트 언어에 대해 신경 쓸 이유가 있었을까요?\n\n## JavaScript의 역사로 가는 롤러코스터\n\n아마도 브랜든 아이치, 넷스케이프, 썬 마이크로시스템즈의 리더십을 제외하고는, 현재의 모든 인터넷 사용자를 위한 12월 4일의 순간이 얼마나 중요해질지 정말 아무도 몰랐을 거예요.\n\nJavaScript가 시작되었던 사실 중에 잘 알려지지 않은 것 하나는 그것이 언어가 되기로 의도된 것이 아니었다는 것이에요. 브랜든 아이치를 고용했을 때의 목표는 넷스케이프에 스킴 언어를 통합하는 것이었지만, 동시에 자바도 통합하려고 노력했습니다. 그러나 헝가리 속담에는 \"두 마리 토끼를 쫓다가 한 마리도 잡지 못한다\"라는 말이 있는데, 여기서도 적용되죠. 우리가 지금 알게 된 대로, 자바나 스킴은 브라우저에 통합되지 않았고, 넷스케이프의 경영진은 토끼를 쫓는 것을 멈추고 자바보다는 자바와 가까운 문법이 적용된 새로운 언어를 개발하기로 결정했어요.\n\n\n\n공식 릴리스가 된 12월까지는 이 언어가 JavaScript가 아니라 LiveScript라는 이름을 갖지 않았어요. 28년이 지난 지금도 제 생각에는 그 이름이 넷스케이프 경영진이 선택한 이름보다 훨씬 적합하다고 생각해요. 특히 Web 2.0과 Ajax의 소개 이후로 JavaScript의 주요 이점 중 하나는 페이지 새로 고침이 필요하지 않는 실시간 웹 애플리케이션을 가능하게 하는 능력이에요.\n\n10년이 흘러 2006년에는 우리가 사랑하고 미워하는 jQuery가 나왔어요. 단독으로 StackOverflow를 웹 개발자들에게 지옥으로 만든 라이브러리예요. 그리고 그래서 태어났죠. 단순한 JavaScript로 작성된 코드에 손 대지 않을 JS 엘리트들도 있는 반면 jQuery \"개발자\"를 어디서든 비하하는 JS 스노브도 있어요. 제 경우 어느 캠프에도 속하지 않는 것 같아요.\n\n물론 모든 상황에 이상적인 선택은 아니에요. 예를 들어 버전 3.0.0의 주요 문제는 dataType 옵션이 지정되지 않은 상태에서 교차 도메인 Ajax 요청을 수행했을 때 크로스사이트 스크립팅(XSS) 공격에 취약하다는 점이에요. jQuery 열차에 올라타기 전에 모든 개발자들이 알아야 할 실제적인 문제지요.\n\njQuery의 인기에서 영감을 받았거나 \"JS를 더 나아지게 만들어야 한다\"는 지속적인 요구에 의해 2009년 3년 뒤에는 아무도 실제로 요청하지 않았던 CoffeeScript가 등장했어요. \"Java\"가 \"커피\"를 뜻하기도 하니 그 새 언어의 이름으로는 너무나 분명한 선택이었을 지도 모르지만, 우리 개발자들은 명명하는 것에서 진짜 열악해요. 그래서 그 이름은 자리를 지켰죠. 브랜든 아이크는 자신의 생각에 JavaScript의 미래에 영향을 미치는 요인으로서 이 언어를 언급했어요. 그 말로 우스움 있어도 사랑받은 것이죠. 하게, Ruby on Rails 3.1에는 CoffeeScript를 내장 지원하는 기능이 있었는데, RoR이 얼마나 인기가 있었는지(시대에 따라 아직도 그렇죠.) 생각해보면 전혀 작지 않은 일이죠.\n\n\n\n세 년 뒤인 2012년에, 바닐라 JS 애호가들이 겸허함을 배우는 때가 왔습니다. 마이크로소프트가 JavaScript를 \"개선\"하기로 결정하는 바람에요. 그러나 그들의 엔지니어들은 CoffeeScript처럼 JS로 컴파일되는 새 언어를 만들지 않고, 덜 고통스러운 슈퍼셋 경로를 선택했어요. 위키피디아에 따르면:\n\n누군가는 이것에 논쟁할지도 모르지만, 그 인기는 부정할 수 없죠. 이것은 많은 소프트웨어 엔지니어들의 상상력과 주의를 사로잡았습니다. 그것은 갑자기 강력하게 타입이 지정된 언어를 좋아하는 많은 소프트웨어 엔지니어들의 관심을 끌었기 때문에, 갑자기 바닐라 JS 애호가들은 TS보다 JS를 지지하게 되었어요. 2023년에는 원래의 언어와 그 슈퍼셋 간에 어느 정도 균형이 이루어졌지만, 최근에는 Svelte와 Turbo 8와 같은 프레임워크가 TypeScript를 버리고 부담이 적은 다른 솔루션을 선호하는 모습을 보여주기도 해서, 마이크로소프트의 개선된 JS의 미래는 확실하지 않습니다.\n\n한편, 자바스크립트 뒤의 ECMAScript 표준은 멈추지 않았습니다. 그래서 또 세 년 후인 2015년에, 웹 개발자들은 드디어 브라우저에서 자연스럽게 실행되는 자신들의 가장 좋아하는 언어에 중요한 업데이트를 얻었어요. ES6 (ECMAScript 2015)는 오랜 시간 동안 가장 중요한 변화였으며, 모든 변화가 개발자들에 의해 매우 환영을 받았어요. 몇 주 안에, 개발자들은 화살표 함수, 템플릿 문자열 및 상수를 사랑하게 되었죠. 물론 이것들은 빙산의 일각에 불과했습니다.\n\n2015년 이후로 매년 새로운 표준 및 JavaScript로의 업데이트 세트가 도입되고 있습니다. 2023년에는 모든 주요 브라우저에서 심지어 ES7도 아주 잘 지원되며, 실시간 및 동적 애플리케이션 개발이 이전보다 더 직관적이고 편리해지고 있습니다.\n\n\n\n## JS 이상의 존재\n\n자바스크립트의 가장 흥미로운 측면 중 하나는 브라우저에서 동작하는 역사를 가졌다는 것 뿐만 아니라, 어디서든 실행되는 언어가 되었다는 점입니다. 일부 사람들은 \"할 수 없다고 해서 반드시 해서는 안 된다\"고 강력히 이야기할지 모르지만, 자바스크립트는 가장 이색적인 플랫폼에서도 다양한 해결책을 개발할 수 있도록 해주었습니다.\n\nJS를 백엔드에서 실행하거나 OS에서 실행하고 싶나요? 가능합니다. Node.js, Deno 그리고 이제 Bun까지 모두 사용하실 수 있습니다. 흔히 사용되는 많은 경우를 위해 바퀴를 다시 발명할 필요 없이 최신 UI를 구축하고 싶다면, React, Vue, Svelte, Angular 및 기타 다양한 UI 라이브러리와 프레임워크를 선택할 수 있습니다. 대부분의 경우 서버 사이드 렌더링을 기본으로 지원하기 때문에 따로 추가 패키지가 필요하지 않습니다. 데스크톱 및 모바일용 네이티브 애플리케이션을 만들 수도 있습니다. 필요한 것은 Electron이나 Ionic 뿐입니다.\n\n하지만 JS는 더 나아갑니다. 작은 퍽을 블루투스 파워포인트 프레젠터 리모컨으로 변신시킨 것처럼 임베디드 시스템이나 마이크로컨트롤러에서 실행할 수도 있습니다. 놀랍게도, 자바스크립트는 게임 개발에도 탁월합니다. 따라서 플래피 버드나 요즘 아이들이 하는 게임을 만드는 데 어려움은 없을 것입니다. 저는 게이머가 아니며 게임을 즐기기에 충분히 심심하지 않습니다. LEGO를 쌓는 것이 취미죠. 😁\n\n\n\n자바스크립트는 겸손한 언어에서 전체 스택으로 발전했는데, 이것은 소프트웨어 개발 세계에서 엄청난 파워를 발휘합니다. 개발자 뿐만 아니라 스마트한 비용 절약 결정을 내리고 싶은 기업에게도 이점이 있죠. 자바스크립트는 더 이상 개발자의 선호도에 그치는 것이 아니라, 훨씬 더 큰 기업 전략 대화로 진화하고 있습니다. 자바스크립트는 현실적으로 돈을 절약하고 벌 수 있으며, 소프트웨어 엔지니어의 기술 세트를 매우 재사용 가능하게 만들어, 그들이 그 외의 경우에 비해 훨씬 더 가치 있게 만듭니다. 동일한 언어를 모든 곳에서 사용할 수 있는 능력은 무척 강력하고 만족스럽습니다.\n\n## '2023년, 꽤 좋았던 해였어요'\n\n2023년은 일반적으로 세상을 볼 때 최고의 해는 아니었을지许는데, 그러나 자바스크립트 팬들로서 우리는 새로운 업데이트를 풍부하게 받았고 그중에서 지루하지 않았죠.\n\n아마도 가장 주목할 만한 유틸리티 함수는 새로운 Object.groupBy()일 거예요. 이제 객체의 속성을 다른 속성 값에 따라 그룹화할 수 있게 되었는데, 에러가 발생하기 쉬운 끝도 없는 코드를 작성하지 않고도 가능하며, 이 과정은 다음과 같이 간단합니다:\n\n\n\n```js\nconst inventory = [\n  { name: \"asparagus\", type: \"vegetables\", quantity: 5 },\n  { name: \"bananas\", type: \"fruit\", quantity: 0 },\n  { name: \"goat\", type: \"meat\", quantity: 23 },\n  { name: \"cherries\", type: \"fruit\", quantity: 5 },\n  { name: \"fish\", type: \"meat\", quantity: 22 },\n];\n\nconst result = Object.groupBy(inventory, ({ type }) =\u003e type);\n```\n\n결과는 다음과 같습니다:\n\n```js\n{\n  vegetables: [\n    { name: 'asparagus', type: 'vegetables', quantity: 5 },\n  ],\n  fruit: [\n    { name: \"bananas\", type: \"fruit\", quantity: 0 },\n    { name: \"cherries\", type: \"fruit\", quantity: 5 }\n  ],\n  meat: [\n    { name: \"goat\", type: \"meat\", quantity: 23 },\n    { name: \"fish\", type: \"meat\", quantity: 22 }\n  ]\n}\n```\n\n이것이 아름다운 것이 아니라면, 무엇이 아름다운지 모르겠어요. 🙂\n\n\n\n\n마침내 배열을 복제하지 않고도 변이를 피하기 위해 원래 배열을 변형하지 않고 배열을 뒤집거나 분할하고 정렬할 수도 있게 되었습니다. 여기에서 작동하는 toReversed(), toSpliced() 및 toSorted()을 살펴봅시다:\n\n```js\n// toReversed()\n\nconst items = [1, 2, 3];\nconsole.log(items); // [1, 2, 3]\n\nconst reversedItems = items.toReversed();\nconsole.log(reversedItems); // [3, 2, 1]\nconsole.log(items); // [1, 2, 3]\n// toSpliced()\n\nconst months = [\"Jan\", \"Mar\", \"Apr\", \"May\"];\n\n// 인덱스 1에 요소 삽입\nconst months2 = months.toSpliced(1, 0, \"Feb\");\nconsole.log(months2); // [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\"]\n\n// 인덱스 2부터 두 요소 삭제\nconst months3 = months2.toSpliced(2, 2);\nconsole.log(months3); // [\"Jan\", \"Feb\", \"May\"]\n\n// 인덱스 1의 요소를 새로운 두 요소로 대체\nconst months4 = months3.toSpliced(1, 1, \"Feb\", \"Mar\");\nconsole.log(months4); // [\"Jan\", \"Feb\", \"Mar\", \"May\"]\n\n// 원본 배열이 수정되지 않음\nconsole.log(months); // [\"Jan\", \"Mar\", \"Apr\", \"May\"]\n// toSorted()\n\nconst months = [\"Mar\", \"Jan\", \"Feb\", \"Dec\"];\nconst sortedMonths = months.toSorted();\nconsole.log(sortedMonths); // ['Dec', 'Feb', 'Jan', 'Mar']\nconsole.log(months); // ['Mar', 'Jan', 'Feb', 'Dec']\n\nconst values = [1, 10, 21, 2];\nconst sortedValues = values.toSorted((a, b) =\u003e a - b);\nconsole.log(sortedValues); // [1, 2, 10, 21]\nconsole.log(values); // [1, 10, 21, 2]\n```\n\nJavaScript의 특이한 점들은 나를 거의 짜증나게 하지 않지만, 이러한 개선 사항은 확실히 환영받을 만하며 앞으로 훨씬 깔끔한 코드 베이스로 이어집니다.\n\n올해 나를 흥분하게 한 마지막 것은 HTML5의 dialog 태그이며, 이제 내장된 showModal() 및 close() 함수가 있습니다. 이제 대화 상자나 모달을 열고 닫을 수 있습니다:\n\n\n\n\n```js\ndialog.showModal();\nclose(); // 당신은 안쪽에 값도 반환할 수 있어\n```\n\n이거 정말 멋지지 않아요!\n\n물론, 대부분의 주요 JS 프레임워크도 상당한 변화를 겪었죠. create-react-app은 사라졌고 이제 Next.js가 대부분의 미래 React 애플리케이션과 동의어가 되었습니다. 또한, Next.js v13에서 채택된 React 서버 사이드 컴포넌트로 API를 호출할 수도 있어요.\n\nSvelte도 눈에 띄게 변화하고자 했고, 웹에서 \"반응성\"을 다시 생각하기 위해 \"룬\" 개념을 도입했어요. 기본적으로 컴파일 시간 반응성에서 섬세한 단위의 반응성으로 전환하는 것이죠. 그들이 말하는 바에 따르면:```\n\n\n\n하지만 Angular 17보다 더 빠를까요? 여전히 제 마음 속에 가장 가까운 JS 프레임워크는 2023년 11월에 17버전에 도달했으며, 오랜 시간 만에 가장 큰 변화 중 하나를 가져왔습니다. 누구나 새로운 템플릿 구문을 바로 알아차릴 것입니다. 즉, 이제 ngIf와 ngFor를 작별하게 되었습니다.\n\n이것은 프론트엔드에서의 변화 중 하나일 뿐입니다. 백엔드에서도 Node.js는 조용히 개선되고 있습니다. 그중 하나의 주목할만한 업데이트는 --experimental-websocket 플래그인 도입으로 Node 21에서 자체 웹소켓 클라이언트를 소개했습니다.\n\nNode.js가 명백히 매우 인기가 많다는 것은 2023년에 새로운 경쟁 상대가 나타나지 않았다는 것을 의미하지 않습니다. Bun.js는 올인원 JavaScript 런타임이며, 특정 환경에서 Node보다 5배 이상 빠르다고 합니다. Bun 팀은 다음과 같이 주장합니다:\n\n아직 초기 단계이지만 확실히 약속을 보여줍니다. 하지만 저는 여전히 Node나 Deno를 한동안 사용하는 것을 선호합니다.\n\n\n\n## JS의 다음은 무엇일까요?\n\n그래서, 28년 만에 JavaScript의 다음은 무엇일까요? 실제 기능 측면에서는, 우리는 무엇을 기대해야 하는지 알고 있습니다. ES 제안의 제3 단계 후보는 상당히 많은데요 — 총 14개 — 모두 충분히 흥미롭어서 곧 현실이 될 것으로 예상됩니다. 초안에서는 23개 제안이 있으며, 그 중 일부는 수천 표를 받았습니다. 반면 제안 단계 1에서는 총 90개가 있습니다. 하지만 그 중 대부분은 단계 2 또는 3에 도달할 가능성이 적을 것으로 생각합니다.\n\n생태계 측면에서, JavaScript는 계속 번창할 것으로 생각됩니다. IEEE.org에 따르면, 2023년에 가장 인기 있는 언어 중 3위에 올랐으며, 앞으로 몇 년 동안 이것이 크게 변할 것 같지는 않습니다. 직업 기회 측면에서 보면, SQL, Python, 그리고 Java 다음으로 가장 많이 찾는 기술이 되었습니다. 🎉\n\n\n\n![JavaScript Birthday](/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_1.png)\n\n사랑하든 싫어하든, JavaScript는 활기차고 성숙하며 열정적인 커뮤니티를 갖고 있습니다. 이 커뮤니티는 JavaScript를 오롯이 유지하는 것뿐만 아니라 새로운 높이로 끌어올리고 있습니다. JS로 무엇이든 구축하는 방법에 대한 정보는 파이썬만큼이나 풍부합니다. 이는 프로그래밍에 새로운 사람들에게 접근하기 쉬운 언어이며, 아마도 파이썬보다 더 쉽게 접근할 수 있다고 말해도 좋을 것입니다. 네, 이상한 점들이 있지만, 저는 한 사람으로서 이를 사랑하고 함께 일하며 조정하기를 배웠습니다.\n\n생일 축하, JavaScript! 🍻🎂\n\nAttila Vago - 세상을 하나의 코드 줄씩 개선하는 소프트웨어 엔지니어. 영원한 멋쟁이, 코드와 블로그의 작가. 웹 접근성 옹호자, 레고 팬, 비닐 레코드 컬렉터. 수제 맥주를 좋아합니다! 제 \"안녕 이야기\"를 여기서 읽어보세요! 레고, 기술, 코딩 및 접근성에 관한 더 많은 이야기를 구독하세요! 가끔씩 방문하시는 독자분들을 위해 랜덤 이야기와 글도 써봅니다.","ogImage":{"url":"/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_0.png"},"coverImage":"/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_0.png","tag":["Tech"],"readingTime":9},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"JavaScript과 나는 생일이 같아요. 난 어린이였던 그 때에는 레고, 책, 그리고 곱셈표를 발견한 바로 그 때였어요. 1995년, 난 컴퓨터를 한 번도 보지 못했어요. 베를린의 장벽이 무너져내리고 철의 커튼이 열리기까지도 어딘가에서는 일어난 일들이었어요. 동유럽에서는 컴퓨터는 마음속에서 가장 먼 곳에 있었죠. 하지만 세계 반대편에서 중요한 일이 있었어요. 오늘날 우리가 알고 있는 웹과 기술을 가능케 한 일이죠. 그것이 바로 JavaScript인데, 누구도 중요하게 여기지 않았습니다. 윈도우 1995가 열광의 중심이었을 때, 누구나 어떤 어린 스크립트 언어에 대해 신경 쓸 이유가 있었을까요?\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"JavaScript의 역사로 가는 롤러코스터\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아마도 브랜든 아이치, 넷스케이프, 썬 마이크로시스템즈의 리더십을 제외하고는, 현재의 모든 인터넷 사용자를 위한 12월 4일의 순간이 얼마나 중요해질지 정말 아무도 몰랐을 거예요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"JavaScript가 시작되었던 사실 중에 잘 알려지지 않은 것 하나는 그것이 언어가 되기로 의도된 것이 아니었다는 것이에요. 브랜든 아이치를 고용했을 때의 목표는 넷스케이프에 스킴 언어를 통합하는 것이었지만, 동시에 자바도 통합하려고 노력했습니다. 그러나 헝가리 속담에는 \\\"두 마리 토끼를 쫓다가 한 마리도 잡지 못한다\\\"라는 말이 있는데, 여기서도 적용되죠. 우리가 지금 알게 된 대로, 자바나 스킴은 브라우저에 통합되지 않았고, 넷스케이프의 경영진은 토끼를 쫓는 것을 멈추고 자바보다는 자바와 가까운 문법이 적용된 새로운 언어를 개발하기로 결정했어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"공식 릴리스가 된 12월까지는 이 언어가 JavaScript가 아니라 LiveScript라는 이름을 갖지 않았어요. 28년이 지난 지금도 제 생각에는 그 이름이 넷스케이프 경영진이 선택한 이름보다 훨씬 적합하다고 생각해요. 특히 Web 2.0과 Ajax의 소개 이후로 JavaScript의 주요 이점 중 하나는 페이지 새로 고침이 필요하지 않는 실시간 웹 애플리케이션을 가능하게 하는 능력이에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"10년이 흘러 2006년에는 우리가 사랑하고 미워하는 jQuery가 나왔어요. 단독으로 StackOverflow를 웹 개발자들에게 지옥으로 만든 라이브러리예요. 그리고 그래서 태어났죠. 단순한 JavaScript로 작성된 코드에 손 대지 않을 JS 엘리트들도 있는 반면 jQuery \\\"개발자\\\"를 어디서든 비하하는 JS 스노브도 있어요. 제 경우 어느 캠프에도 속하지 않는 것 같아요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"물론 모든 상황에 이상적인 선택은 아니에요. 예를 들어 버전 3.0.0의 주요 문제는 dataType 옵션이 지정되지 않은 상태에서 교차 도메인 Ajax 요청을 수행했을 때 크로스사이트 스크립팅(XSS) 공격에 취약하다는 점이에요. jQuery 열차에 올라타기 전에 모든 개발자들이 알아야 할 실제적인 문제지요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"jQuery의 인기에서 영감을 받았거나 \\\"JS를 더 나아지게 만들어야 한다\\\"는 지속적인 요구에 의해 2009년 3년 뒤에는 아무도 실제로 요청하지 않았던 CoffeeScript가 등장했어요. \\\"Java\\\"가 \\\"커피\\\"를 뜻하기도 하니 그 새 언어의 이름으로는 너무나 분명한 선택이었을 지도 모르지만, 우리 개발자들은 명명하는 것에서 진짜 열악해요. 그래서 그 이름은 자리를 지켰죠. 브랜든 아이크는 자신의 생각에 JavaScript의 미래에 영향을 미치는 요인으로서 이 언어를 언급했어요. 그 말로 우스움 있어도 사랑받은 것이죠. 하게, Ruby on Rails 3.1에는 CoffeeScript를 내장 지원하는 기능이 있었는데, RoR이 얼마나 인기가 있었는지(시대에 따라 아직도 그렇죠.) 생각해보면 전혀 작지 않은 일이죠.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"세 년 뒤인 2012년에, 바닐라 JS 애호가들이 겸허함을 배우는 때가 왔습니다. 마이크로소프트가 JavaScript를 \\\"개선\\\"하기로 결정하는 바람에요. 그러나 그들의 엔지니어들은 CoffeeScript처럼 JS로 컴파일되는 새 언어를 만들지 않고, 덜 고통스러운 슈퍼셋 경로를 선택했어요. 위키피디아에 따르면:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"누군가는 이것에 논쟁할지도 모르지만, 그 인기는 부정할 수 없죠. 이것은 많은 소프트웨어 엔지니어들의 상상력과 주의를 사로잡았습니다. 그것은 갑자기 강력하게 타입이 지정된 언어를 좋아하는 많은 소프트웨어 엔지니어들의 관심을 끌었기 때문에, 갑자기 바닐라 JS 애호가들은 TS보다 JS를 지지하게 되었어요. 2023년에는 원래의 언어와 그 슈퍼셋 간에 어느 정도 균형이 이루어졌지만, 최근에는 Svelte와 Turbo 8와 같은 프레임워크가 TypeScript를 버리고 부담이 적은 다른 솔루션을 선호하는 모습을 보여주기도 해서, 마이크로소프트의 개선된 JS의 미래는 확실하지 않습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한편, 자바스크립트 뒤의 ECMAScript 표준은 멈추지 않았습니다. 그래서 또 세 년 후인 2015년에, 웹 개발자들은 드디어 브라우저에서 자연스럽게 실행되는 자신들의 가장 좋아하는 언어에 중요한 업데이트를 얻었어요. ES6 (ECMAScript 2015)는 오랜 시간 동안 가장 중요한 변화였으며, 모든 변화가 개발자들에 의해 매우 환영을 받았어요. 몇 주 안에, 개발자들은 화살표 함수, 템플릿 문자열 및 상수를 사랑하게 되었죠. 물론 이것들은 빙산의 일각에 불과했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"2015년 이후로 매년 새로운 표준 및 JavaScript로의 업데이트 세트가 도입되고 있습니다. 2023년에는 모든 주요 브라우저에서 심지어 ES7도 아주 잘 지원되며, 실시간 및 동적 애플리케이션 개발이 이전보다 더 직관적이고 편리해지고 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"JS 이상의 존재\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자바스크립트의 가장 흥미로운 측면 중 하나는 브라우저에서 동작하는 역사를 가졌다는 것 뿐만 아니라, 어디서든 실행되는 언어가 되었다는 점입니다. 일부 사람들은 \\\"할 수 없다고 해서 반드시 해서는 안 된다\\\"고 강력히 이야기할지 모르지만, 자바스크립트는 가장 이색적인 플랫폼에서도 다양한 해결책을 개발할 수 있도록 해주었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"JS를 백엔드에서 실행하거나 OS에서 실행하고 싶나요? 가능합니다. Node.js, Deno 그리고 이제 Bun까지 모두 사용하실 수 있습니다. 흔히 사용되는 많은 경우를 위해 바퀴를 다시 발명할 필요 없이 최신 UI를 구축하고 싶다면, React, Vue, Svelte, Angular 및 기타 다양한 UI 라이브러리와 프레임워크를 선택할 수 있습니다. 대부분의 경우 서버 사이드 렌더링을 기본으로 지원하기 때문에 따로 추가 패키지가 필요하지 않습니다. 데스크톱 및 모바일용 네이티브 애플리케이션을 만들 수도 있습니다. 필요한 것은 Electron이나 Ionic 뿐입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 JS는 더 나아갑니다. 작은 퍽을 블루투스 파워포인트 프레젠터 리모컨으로 변신시킨 것처럼 임베디드 시스템이나 마이크로컨트롤러에서 실행할 수도 있습니다. 놀랍게도, 자바스크립트는 게임 개발에도 탁월합니다. 따라서 플래피 버드나 요즘 아이들이 하는 게임을 만드는 데 어려움은 없을 것입니다. 저는 게이머가 아니며 게임을 즐기기에 충분히 심심하지 않습니다. LEGO를 쌓는 것이 취미죠. 😁\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자바스크립트는 겸손한 언어에서 전체 스택으로 발전했는데, 이것은 소프트웨어 개발 세계에서 엄청난 파워를 발휘합니다. 개발자 뿐만 아니라 스마트한 비용 절약 결정을 내리고 싶은 기업에게도 이점이 있죠. 자바스크립트는 더 이상 개발자의 선호도에 그치는 것이 아니라, 훨씬 더 큰 기업 전략 대화로 진화하고 있습니다. 자바스크립트는 현실적으로 돈을 절약하고 벌 수 있으며, 소프트웨어 엔지니어의 기술 세트를 매우 재사용 가능하게 만들어, 그들이 그 외의 경우에 비해 훨씬 더 가치 있게 만듭니다. 동일한 언어를 모든 곳에서 사용할 수 있는 능력은 무척 강력하고 만족스럽습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"'2023년, 꽤 좋았던 해였어요'\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"2023년은 일반적으로 세상을 볼 때 최고의 해는 아니었을지许는데, 그러나 자바스크립트 팬들로서 우리는 새로운 업데이트를 풍부하게 받았고 그중에서 지루하지 않았죠.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아마도 가장 주목할 만한 유틸리티 함수는 새로운 Object.groupBy()일 거예요. 이제 객체의 속성을 다른 속성 값에 따라 그룹화할 수 있게 되었는데, 에러가 발생하기 쉬운 끝도 없는 코드를 작성하지 않고도 가능하며, 이 과정은 다음과 같이 간단합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" inventory = [\\n  { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"asparagus\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"vegetables\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"quantity\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \" },\\n  { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"bananas\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"fruit\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"quantity\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" },\\n  { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"goat\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"meat\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"quantity\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"23\"\n        }), \" },\\n  { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"cherries\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"fruit\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"quantity\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \" },\\n  { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"fish\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"meat\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"quantity\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"22\"\n        }), \" },\\n];\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" result = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Object\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"groupBy\"\n        }), \"(inventory, \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"{ type }\"\n          }), \") =\u003e\"]\n        }), \" type);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결과는 다음과 같습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"vegetables\"\n        }), \": [\\n    { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'asparagus'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'vegetables'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"quantity\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \" },\\n  ],\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"fruit\"\n        }), \": [\\n    { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"bananas\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"fruit\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"quantity\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" },\\n    { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"cherries\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"fruit\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"quantity\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \" }\\n  ],\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"meat\"\n        }), \": [\\n    { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"goat\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"meat\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"quantity\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"23\"\n        }), \" },\\n    { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"fish\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"meat\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"quantity\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"22\"\n        }), \" }\\n  ]\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것이 아름다운 것이 아니라면, 무엇이 아름다운지 모르겠어요. 🙂\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마침내 배열을 복제하지 않고도 변이를 피하기 위해 원래 배열을 변형하지 않고 배열을 뒤집거나 분할하고 정렬할 수도 있게 되었습니다. 여기에서 작동하는 toReversed(), toSpliced() 및 toSorted()을 살펴봅시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// toReversed()\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" items = [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \"];\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(items); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// [1, 2, 3]\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" reversedItems = items.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toReversed\"\n        }), \"();\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(reversedItems); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// [3, 2, 1]\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(items); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// [1, 2, 3]\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// toSpliced()\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" months = [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Jan\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Mar\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Apr\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"May\\\"\"\n        }), \"];\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 인덱스 1에 요소 삽입\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" months2 = months.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toSpliced\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Feb\\\"\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(months2); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// [\\\"Jan\\\", \\\"Feb\\\", \\\"Mar\\\", \\\"Apr\\\", \\\"May\\\"]\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 인덱스 2부터 두 요소 삭제\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" months3 = months2.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toSpliced\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(months3); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// [\\\"Jan\\\", \\\"Feb\\\", \\\"May\\\"]\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 인덱스 1의 요소를 새로운 두 요소로 대체\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" months4 = months3.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toSpliced\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Feb\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Mar\\\"\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(months4); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// [\\\"Jan\\\", \\\"Feb\\\", \\\"Mar\\\", \\\"May\\\"]\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 원본 배열이 수정되지 않음\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(months); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// [\\\"Jan\\\", \\\"Mar\\\", \\\"Apr\\\", \\\"May\\\"]\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// toSorted()\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" months = [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Mar\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Jan\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Feb\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Dec\\\"\"\n        }), \"];\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" sortedMonths = months.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toSorted\"\n        }), \"();\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(sortedMonths); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ['Dec', 'Feb', 'Jan', 'Mar']\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(months); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ['Mar', 'Jan', 'Feb', 'Dec']\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" values = [\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"21\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \"];\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" sortedValues = values.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toSorted\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"a, b\"\n          }), \") =\u003e\"]\n        }), \" a - b);\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(sortedValues); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// [1, 2, 10, 21]\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(values); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// [1, 10, 21, 2]\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"JavaScript의 특이한 점들은 나를 거의 짜증나게 하지 않지만, 이러한 개선 사항은 확실히 환영받을 만하며 앞으로 훨씬 깔끔한 코드 베이스로 이어집니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"올해 나를 흥분하게 한 마지막 것은 HTML5의 dialog 태그이며, 이제 내장된 showModal() 및 close() 함수가 있습니다. 이제 대화 상자나 모달을 열고 닫을 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"dialog.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"showModal\"\n        }), \"();\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"close\"\n        }), \"(); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 당신은 안쪽에 값도 반환할 수 있어\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이거 정말 멋지지 않아요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"물론, 대부분의 주요 JS 프레임워크도 상당한 변화를 겪었죠. create-react-app은 사라졌고 이제 Next.js가 대부분의 미래 React 애플리케이션과 동의어가 되었습니다. 또한, Next.js v13에서 채택된 React 서버 사이드 컴포넌트로 API를 호출할 수도 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Svelte도 눈에 띄게 변화하고자 했고, 웹에서 \\\"반응성\\\"을 다시 생각하기 위해 \\\"룬\\\" 개념을 도입했어요. 기본적으로 컴파일 시간 반응성에서 섬세한 단위의 반응성으로 전환하는 것이죠. 그들이 말하는 바에 따르면:```\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 Angular 17보다 더 빠를까요? 여전히 제 마음 속에 가장 가까운 JS 프레임워크는 2023년 11월에 17버전에 도달했으며, 오랜 시간 만에 가장 큰 변화 중 하나를 가져왔습니다. 누구나 새로운 템플릿 구문을 바로 알아차릴 것입니다. 즉, 이제 ngIf와 ngFor를 작별하게 되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 프론트엔드에서의 변화 중 하나일 뿐입니다. 백엔드에서도 Node.js는 조용히 개선되고 있습니다. 그중 하나의 주목할만한 업데이트는 --experimental-websocket 플래그인 도입으로 Node 21에서 자체 웹소켓 클라이언트를 소개했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Node.js가 명백히 매우 인기가 많다는 것은 2023년에 새로운 경쟁 상대가 나타나지 않았다는 것을 의미하지 않습니다. Bun.js는 올인원 JavaScript 런타임이며, 특정 환경에서 Node보다 5배 이상 빠르다고 합니다. Bun 팀은 다음과 같이 주장합니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아직 초기 단계이지만 확실히 약속을 보여줍니다. 하지만 저는 여전히 Node나 Deno를 한동안 사용하는 것을 선호합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"JS의 다음은 무엇일까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서, 28년 만에 JavaScript의 다음은 무엇일까요? 실제 기능 측면에서는, 우리는 무엇을 기대해야 하는지 알고 있습니다. ES 제안의 제3 단계 후보는 상당히 많은데요 — 총 14개 — 모두 충분히 흥미롭어서 곧 현실이 될 것으로 예상됩니다. 초안에서는 23개 제안이 있으며, 그 중 일부는 수천 표를 받았습니다. 반면 제안 단계 1에서는 총 90개가 있습니다. 하지만 그 중 대부분은 단계 2 또는 3에 도달할 가능성이 적을 것으로 생각합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"생태계 측면에서, JavaScript는 계속 번창할 것으로 생각됩니다. IEEE.org에 따르면, 2023년에 가장 인기 있는 언어 중 3위에 올랐으며, 앞으로 몇 년 동안 이것이 크게 변할 것 같지는 않습니다. 직업 기회 측면에서 보면, SQL, Python, 그리고 Java 다음으로 가장 많이 찾는 기술이 되었습니다. 🎉\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing_1.png\",\n        alt: \"JavaScript Birthday\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사랑하든 싫어하든, JavaScript는 활기차고 성숙하며 열정적인 커뮤니티를 갖고 있습니다. 이 커뮤니티는 JavaScript를 오롯이 유지하는 것뿐만 아니라 새로운 높이로 끌어올리고 있습니다. JS로 무엇이든 구축하는 방법에 대한 정보는 파이썬만큼이나 풍부합니다. 이는 프로그래밍에 새로운 사람들에게 접근하기 쉬운 언어이며, 아마도 파이썬보다 더 쉽게 접근할 수 있다고 말해도 좋을 것입니다. 네, 이상한 점들이 있지만, 저는 한 사람으로서 이를 사랑하고 함께 일하며 조정하기를 배웠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"생일 축하, JavaScript! 🍻🎂\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Attila Vago - 세상을 하나의 코드 줄씩 개선하는 소프트웨어 엔지니어. 영원한 멋쟁이, 코드와 블로그의 작가. 웹 접근성 옹호자, 레고 팬, 비닐 레코드 컬렉터. 수제 맥주를 좋아합니다! 제 \\\"안녕 이야기\\\"를 여기서 읽어보세요! 레고, 기술, 코딩 및 접근성에 관한 더 많은 이야기를 구독하세요! 가끔씩 방문하시는 독자분들을 위해 랜덤 이야기와 글도 써봅니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-Happy28thBirthdayJavaScriptHowsItGoing"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>