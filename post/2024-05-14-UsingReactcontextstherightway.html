<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트 컨텍스트를 올바르게 활용하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-UsingReactcontextstherightway" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트 컨텍스트를 올바르게 활용하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트 컨텍스트를 올바르게 활용하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-UsingReactcontextstherightway_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-UsingReactcontextstherightway" data-gatsby-head="true"/><meta name="twitter:title" content="리액트 컨텍스트를 올바르게 활용하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-UsingReactcontextstherightway_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 12:12" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트 컨텍스트를 올바르게 활용하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트 컨텍스트를 올바르게 활용하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-UsingReactcontextstherightway&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>리액트 컨텍스트는 리액트의 가장 강력하면서도 가장 오해를 많이 받는 기능 중 하나입니다. 많은 사람들이 useContext를 호출하거나 컴포넌트 내에서 직접 컨텍스트 제공자를 생성하는데, 이러한 방식은 코드베이스가 발전함에 따라 변경사항을 만들거나 파생 상태를 계산하기가 쉽지 않습니다.</p>
<p>적어도 컴포넌트를 사용하는 내용물로 만들어져 상태 관리에 대해 독립적인 것이 중요합니다. 또한, 내부에서 파생된 상태를 계산하고 호춣을 통해 컴포넌트에 노출하는 데 아주 좋습니다.</p>
<p><img src="/assets/img/2024-05-14-UsingReactcontextstherightway_0.png" alt="이미지"></p>
<h1>컨텍스트를 작성하는 방식의 관용적인 방법</h1>
<p>제공자를 먼저 작성해 보겠습니다. 블로깅 앱 예시를 들겠습니다. 여러 다른 구성 요소에서 접근할 수 있도록 일부 게시물 필터링 상태를 저장해야 하는 상황입니다.</p>
<p>이를 위해 특정 구성 요소 및 훅만 내보낸 별도의 파일에서 수행합니다. 이를 통해 캡슐화를 보장합니다. 코드를 사용하는 사람이 내부적으로 컨텍스트를 사용하고 있는지 알 필요가 없습니다. 이는 이후 쉬운 구현 변경을 가능하게 합니다.</p>
<p>상태는 일반적인 useState 호출로 구현되며, 값과 설정자는 useMemo로 생성된 객체 내에 설정되고 이 객체는 Provider의 값 속성에 제공됩니다.</p>
<p>그런 다음 동일한 파일에서 훅을 구현할 수 있습니다.</p>
<p>저희 코드를 사용하는 사용자가 제공자를 설정하지 않았을 때(when useContext returns null) 다루는 훅이 하나 있습니다. 이것은 구현 세부 정보이므로 훅은 내보내지 않고, 이 파일 내에서 훅을 사용할 때만 사용됩니다.</p>
<p>저희는 두 가지 훅을 내보냅니다. 하나는 컨텍스트의 읽기 전용 속성만 제공하는 것이며, 저희 앱에서 이 상태를 읽기만 하는 곳이 많을 것을 알고 있기 때문입니다. 마지막으로 읽기 및 쓰기 속성(전체 컨텍스트)을 모두 제공하는 훅이 있습니다. 아마도 여기서 필터를 업데이트하는 버튼이 있는 곳에서 사용될 것입니다.</p>
<p>이제 포스트 목록을 표시하는 페이지 상단에 제공자를 설정할 수 있습니다:</p>
<p>그리고 이제 아래의 컴포넌트 어디에서나 사용할 준비가 되었습니다:</p>
<p>훅 또는 프로바이더를 사용한 곳에서는 React의 네이티브 컨텍스트 익스포트인 useContext나 Context.Provider 같은 것을 사용하지 않았습니다. 이를 통해 코드를 작은 부분만 수정하여 필터 상태의 동작에 대한 전역 변경을 수행할 수 있게 되었습니다.</p>
<p>한 가지씩 몇 가지 예시를 살펴보겠습니다.</p>
<h2>URL에 상태 저장하기</h2>
<p>두 개의 훅만 변경하여 이제 필터 상태가 URL에 저장됩니다. 페이지를 새로고침해도 필터가 유지됩니다. useSearchParam 훅이 이미 있어야 한다고 가정하며, 웹에서 많은 구현을 찾을 수 있습니다.</p>
<h2>로컬 스토리지에 상태 저장하기</h2>
<p>마찬가지로, 우리는 상태를 로컬 스토리지에 저장하여 페이지 새로고침 간에 지속될 수 있도록 할 수 있습니다.</p>
<p>마지막 두 예제는 전역 상태 저장소(URL 또는 로컬 스토리지)에 의존하므로, 제공자를 잊고 소비자 수준에서만 훅을 사용하여 작동합니다:</p>
<p>이 경우에는 useLocalStorage 또는 useSearchParams 훅이 여러 곳에 장착된 이 훅의 여러 인스턴스간 동기화를 다룰 수 있도록 잘 구현되어야 함을 주의하십시오.</p>
<h2>파생 상태 노출 및 사용자 정의 작업 노출하기</h2>
<p>Provider + useState 변형으로 돌아오면, context 내에서 캡슐화된 파생 상태 및 사용자 정의 작업을 쉽게 추가할 수 있습니다.</p>
<p>다시 한 번 강조하지만, 코드를 사용할 때는 내부에서 무슨 일이 일어나고 있는지 몰라도 useHasFilters 또는 useResetFilters를 호출할 수 있습니다. 모든 상태 관리는 UI 구성 요소 외부에서 단일 파일에서 처리합니다.</p>
<p>이전 예제마다 URL이나 로컬 저장소에 상태를 저장하거나 사용자 정의 파생 상태와 작업을 추가하는 등 상태 관리 변경을 수행할 수 있었습니다. 이를 통해 상태를 사용하는 수천 곳의 대규모 앱이라도 한 파일만 수정하면 됩니다. Redux나 Zustand와 같은 상태 관리 도구를 직접 사용할 때는 이러한 작업이 불가능합니다.</p>
<h1>컨텍스트 생성을 덜 번거롭게 만들기</h1>
<p>일부 사람들은 컨텍스트가 너무 말이 많다고 주장합니다. 사실 그래요. 하지만 저는 캡슐화되었을 때 추가되는 가치와 비교했을 때, 한 파일에만 영향을 미치는 추가적인 말이 많음은 그랬다간 않다고 생각해요.</p>
<p>그래도, 한 줄로 컨텍스트를 만드는 기술이 있답니다: 컨텍스트 팩토리 기술이죠.</p>
<p>앞서 한 모든 것들을 하나의 함수로 감싸는 것을 볼 수 있어요. 또한, 함수 내에서 인터페이스도 만들고 제네릭을 사용할 수 있게 해줍니다. 그리고, 우리가 상태의 초기 값을 프로바이더의 속성으로 전달한다는 것을 주목해주세요.</p>
<p>다음과 같이 전역 범위에서 사용할 수 있습니다:</p>
<p>이제 이전의 모든 것을 하나의 코드 라인으로 갖고 있습니다 😃✨. 이것은 일반 useState처럼 거의 동일하지만, 특정 제공자 하위 모든 사용자 사이에서 공유됩니다. 이렇게 하면 모듈식 "의사 전역" 상태를 매우 쉽게 생성할 수 있습니다.</p>
<p>여러 값을 저장해야 하는 경우에는 여러 제공자를 생성하거나 하나의 제공자 내에 (작은) 객체를 넣어야 합니다.</p>
<h2>기타 장점</h2>
<p>요약을 위해 모든 것을 다 다루진 않았지만, 다른 장점으로는 다음과 같은 것이 있습니다:</p>
<ul>
<li>다중 공급자 사용 가능: 각 공급자마다 상태가 복제됩니다 (전역 범위에서 상태를 생성하는 Redux, Recoil 등에서 불가능한 것입니다)</li>
<li>중첩된 공급자 사용 가능: React 문서에 이에 대한 예제가 있습니다. 한 공급자는 같은 유형의 부모 컨텍스트를 찾아 중첩 수준을 알 수 있습니다.</li>
<li>내부적으로 상태 관리 라이브러리 사용 가능: 공급자는 Zustand, Recoil 또는 Redux를 내부적으로 사용하여 UI 구성 요소에 특정 라이브러리 기능을 노출하지 않고 무용의 리렌더링을 피할 수 있습니다.</li>
<li>데이터베이스에 상태 저장 가능한 경우, useState 또는 라이브러리와 같은 클라이언트 상태 관리 도구없이 모두 서버 상태에서 처리할 수 있습니다.</li>
</ul>
<h1>결론</h1>
<p>캡슐화와 함께 올바르게 사용한다면 컨텍스트는 매우 강력한 도구입니다. 그들의 장황함은 도우미 함수로 완화될 수 있습니다.</p>
<p>내 프로젝트에서 사용하는 도우미 함수가 있어요. 렌더 프롭과 외부 상태를 받아들일 수 있는 추가 기능을 가지고 있어서, 이를 참고하여 영감을 받을 수 있을 거에요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트 컨텍스트를 올바르게 활용하기","description":"","date":"2024-05-14 12:12","slug":"2024-05-14-UsingReactcontextstherightway","content":"\n\n리액트 컨텍스트는 리액트의 가장 강력하면서도 가장 오해를 많이 받는 기능 중 하나입니다. 많은 사람들이 useContext를 호출하거나 컴포넌트 내에서 직접 컨텍스트 제공자를 생성하는데, 이러한 방식은 코드베이스가 발전함에 따라 변경사항을 만들거나 파생 상태를 계산하기가 쉽지 않습니다.\n\n적어도 컴포넌트를 사용하는 내용물로 만들어져 상태 관리에 대해 독립적인 것이 중요합니다. 또한, 내부에서 파생된 상태를 계산하고 호춣을 통해 컴포넌트에 노출하는 데 아주 좋습니다.\n\n![이미지](/assets/img/2024-05-14-UsingReactcontextstherightway_0.png)\n\n# 컨텍스트를 작성하는 방식의 관용적인 방법\n\n\n\n제공자를 먼저 작성해 보겠습니다. 블로깅 앱 예시를 들겠습니다. 여러 다른 구성 요소에서 접근할 수 있도록 일부 게시물 필터링 상태를 저장해야 하는 상황입니다.\n\n이를 위해 특정 구성 요소 및 훅만 내보낸 별도의 파일에서 수행합니다. 이를 통해 캡슐화를 보장합니다. 코드를 사용하는 사람이 내부적으로 컨텍스트를 사용하고 있는지 알 필요가 없습니다. 이는 이후 쉬운 구현 변경을 가능하게 합니다.\n\n상태는 일반적인 useState 호출로 구현되며, 값과 설정자는 useMemo로 생성된 객체 내에 설정되고 이 객체는 Provider의 값 속성에 제공됩니다.\n\n그런 다음 동일한 파일에서 훅을 구현할 수 있습니다.\n\n\n\n저희 코드를 사용하는 사용자가 제공자를 설정하지 않았을 때(when useContext returns null) 다루는 훅이 하나 있습니다. 이것은 구현 세부 정보이므로 훅은 내보내지 않고, 이 파일 내에서 훅을 사용할 때만 사용됩니다.\n\n저희는 두 가지 훅을 내보냅니다. 하나는 컨텍스트의 읽기 전용 속성만 제공하는 것이며, 저희 앱에서 이 상태를 읽기만 하는 곳이 많을 것을 알고 있기 때문입니다. 마지막으로 읽기 및 쓰기 속성(전체 컨텍스트)을 모두 제공하는 훅이 있습니다. 아마도 여기서 필터를 업데이트하는 버튼이 있는 곳에서 사용될 것입니다.\n\n이제 포스트 목록을 표시하는 페이지 상단에 제공자를 설정할 수 있습니다:\n\n그리고 이제 아래의 컴포넌트 어디에서나 사용할 준비가 되었습니다:\n\n\n\n훅 또는 프로바이더를 사용한 곳에서는 React의 네이티브 컨텍스트 익스포트인 useContext나 Context.Provider 같은 것을 사용하지 않았습니다. 이를 통해 코드를 작은 부분만 수정하여 필터 상태의 동작에 대한 전역 변경을 수행할 수 있게 되었습니다.\n\n한 가지씩 몇 가지 예시를 살펴보겠습니다.\n\n## URL에 상태 저장하기\n\n두 개의 훅만 변경하여 이제 필터 상태가 URL에 저장됩니다. 페이지를 새로고침해도 필터가 유지됩니다. useSearchParam 훅이 이미 있어야 한다고 가정하며, 웹에서 많은 구현을 찾을 수 있습니다.\n\n\n\n## 로컬 스토리지에 상태 저장하기\n\n마찬가지로, 우리는 상태를 로컬 스토리지에 저장하여 페이지 새로고침 간에 지속될 수 있도록 할 수 있습니다.\n\n마지막 두 예제는 전역 상태 저장소(URL 또는 로컬 스토리지)에 의존하므로, 제공자를 잊고 소비자 수준에서만 훅을 사용하여 작동합니다:\n\n이 경우에는 useLocalStorage 또는 useSearchParams 훅이 여러 곳에 장착된 이 훅의 여러 인스턴스간 동기화를 다룰 수 있도록 잘 구현되어야 함을 주의하십시오.\n\n\n\n## 파생 상태 노출 및 사용자 정의 작업 노출하기\n\nProvider + useState 변형으로 돌아오면, context 내에서 캡슐화된 파생 상태 및 사용자 정의 작업을 쉽게 추가할 수 있습니다.\n\n다시 한 번 강조하지만, 코드를 사용할 때는 내부에서 무슨 일이 일어나고 있는지 몰라도 useHasFilters 또는 useResetFilters를 호출할 수 있습니다. 모든 상태 관리는 UI 구성 요소 외부에서 단일 파일에서 처리합니다.\n\n이전 예제마다 URL이나 로컬 저장소에 상태를 저장하거나 사용자 정의 파생 상태와 작업을 추가하는 등 상태 관리 변경을 수행할 수 있었습니다. 이를 통해 상태를 사용하는 수천 곳의 대규모 앱이라도 한 파일만 수정하면 됩니다. Redux나 Zustand와 같은 상태 관리 도구를 직접 사용할 때는 이러한 작업이 불가능합니다.\n\n\n\n# 컨텍스트 생성을 덜 번거롭게 만들기\n\n일부 사람들은 컨텍스트가 너무 말이 많다고 주장합니다. 사실 그래요. 하지만 저는 캡슐화되었을 때 추가되는 가치와 비교했을 때, 한 파일에만 영향을 미치는 추가적인 말이 많음은 그랬다간 않다고 생각해요.\n\n그래도, 한 줄로 컨텍스트를 만드는 기술이 있답니다: 컨텍스트 팩토리 기술이죠.\n\n앞서 한 모든 것들을 하나의 함수로 감싸는 것을 볼 수 있어요. 또한, 함수 내에서 인터페이스도 만들고 제네릭을 사용할 수 있게 해줍니다. 그리고, 우리가 상태의 초기 값을 프로바이더의 속성으로 전달한다는 것을 주목해주세요.\n\n\n\n다음과 같이 전역 범위에서 사용할 수 있습니다:\n\n이제 이전의 모든 것을 하나의 코드 라인으로 갖고 있습니다 😃✨. 이것은 일반 useState처럼 거의 동일하지만, 특정 제공자 하위 모든 사용자 사이에서 공유됩니다. 이렇게 하면 모듈식 \"의사 전역\" 상태를 매우 쉽게 생성할 수 있습니다.\n\n여러 값을 저장해야 하는 경우에는 여러 제공자를 생성하거나 하나의 제공자 내에 (작은) 객체를 넣어야 합니다.\n\n## 기타 장점\n\n\n\n요약을 위해 모든 것을 다 다루진 않았지만, 다른 장점으로는 다음과 같은 것이 있습니다:\n\n- 다중 공급자 사용 가능: 각 공급자마다 상태가 복제됩니다 (전역 범위에서 상태를 생성하는 Redux, Recoil 등에서 불가능한 것입니다)\n- 중첩된 공급자 사용 가능: React 문서에 이에 대한 예제가 있습니다. 한 공급자는 같은 유형의 부모 컨텍스트를 찾아 중첩 수준을 알 수 있습니다.\n- 내부적으로 상태 관리 라이브러리 사용 가능: 공급자는 Zustand, Recoil 또는 Redux를 내부적으로 사용하여 UI 구성 요소에 특정 라이브러리 기능을 노출하지 않고 무용의 리렌더링을 피할 수 있습니다.\n- 데이터베이스에 상태 저장 가능한 경우, useState 또는 라이브러리와 같은 클라이언트 상태 관리 도구없이 모두 서버 상태에서 처리할 수 있습니다.\n\n# 결론\n\n캡슐화와 함께 올바르게 사용한다면 컨텍스트는 매우 강력한 도구입니다. 그들의 장황함은 도우미 함수로 완화될 수 있습니다.\n\n\n\n내 프로젝트에서 사용하는 도우미 함수가 있어요. 렌더 프롭과 외부 상태를 받아들일 수 있는 추가 기능을 가지고 있어서, 이를 참고하여 영감을 받을 수 있을 거에요.","ogImage":{"url":"/assets/img/2024-05-14-UsingReactcontextstherightway_0.png"},"coverImage":"/assets/img/2024-05-14-UsingReactcontextstherightway_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e리액트 컨텍스트는 리액트의 가장 강력하면서도 가장 오해를 많이 받는 기능 중 하나입니다. 많은 사람들이 useContext를 호출하거나 컴포넌트 내에서 직접 컨텍스트 제공자를 생성하는데, 이러한 방식은 코드베이스가 발전함에 따라 변경사항을 만들거나 파생 상태를 계산하기가 쉽지 않습니다.\u003c/p\u003e\n\u003cp\u003e적어도 컴포넌트를 사용하는 내용물로 만들어져 상태 관리에 대해 독립적인 것이 중요합니다. 또한, 내부에서 파생된 상태를 계산하고 호춣을 통해 컴포넌트에 노출하는 데 아주 좋습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-UsingReactcontextstherightway_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e컨텍스트를 작성하는 방식의 관용적인 방법\u003c/h1\u003e\n\u003cp\u003e제공자를 먼저 작성해 보겠습니다. 블로깅 앱 예시를 들겠습니다. 여러 다른 구성 요소에서 접근할 수 있도록 일부 게시물 필터링 상태를 저장해야 하는 상황입니다.\u003c/p\u003e\n\u003cp\u003e이를 위해 특정 구성 요소 및 훅만 내보낸 별도의 파일에서 수행합니다. 이를 통해 캡슐화를 보장합니다. 코드를 사용하는 사람이 내부적으로 컨텍스트를 사용하고 있는지 알 필요가 없습니다. 이는 이후 쉬운 구현 변경을 가능하게 합니다.\u003c/p\u003e\n\u003cp\u003e상태는 일반적인 useState 호출로 구현되며, 값과 설정자는 useMemo로 생성된 객체 내에 설정되고 이 객체는 Provider의 값 속성에 제공됩니다.\u003c/p\u003e\n\u003cp\u003e그런 다음 동일한 파일에서 훅을 구현할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e저희 코드를 사용하는 사용자가 제공자를 설정하지 않았을 때(when useContext returns null) 다루는 훅이 하나 있습니다. 이것은 구현 세부 정보이므로 훅은 내보내지 않고, 이 파일 내에서 훅을 사용할 때만 사용됩니다.\u003c/p\u003e\n\u003cp\u003e저희는 두 가지 훅을 내보냅니다. 하나는 컨텍스트의 읽기 전용 속성만 제공하는 것이며, 저희 앱에서 이 상태를 읽기만 하는 곳이 많을 것을 알고 있기 때문입니다. 마지막으로 읽기 및 쓰기 속성(전체 컨텍스트)을 모두 제공하는 훅이 있습니다. 아마도 여기서 필터를 업데이트하는 버튼이 있는 곳에서 사용될 것입니다.\u003c/p\u003e\n\u003cp\u003e이제 포스트 목록을 표시하는 페이지 상단에 제공자를 설정할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e그리고 이제 아래의 컴포넌트 어디에서나 사용할 준비가 되었습니다:\u003c/p\u003e\n\u003cp\u003e훅 또는 프로바이더를 사용한 곳에서는 React의 네이티브 컨텍스트 익스포트인 useContext나 Context.Provider 같은 것을 사용하지 않았습니다. 이를 통해 코드를 작은 부분만 수정하여 필터 상태의 동작에 대한 전역 변경을 수행할 수 있게 되었습니다.\u003c/p\u003e\n\u003cp\u003e한 가지씩 몇 가지 예시를 살펴보겠습니다.\u003c/p\u003e\n\u003ch2\u003eURL에 상태 저장하기\u003c/h2\u003e\n\u003cp\u003e두 개의 훅만 변경하여 이제 필터 상태가 URL에 저장됩니다. 페이지를 새로고침해도 필터가 유지됩니다. useSearchParam 훅이 이미 있어야 한다고 가정하며, 웹에서 많은 구현을 찾을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e로컬 스토리지에 상태 저장하기\u003c/h2\u003e\n\u003cp\u003e마찬가지로, 우리는 상태를 로컬 스토리지에 저장하여 페이지 새로고침 간에 지속될 수 있도록 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e마지막 두 예제는 전역 상태 저장소(URL 또는 로컬 스토리지)에 의존하므로, 제공자를 잊고 소비자 수준에서만 훅을 사용하여 작동합니다:\u003c/p\u003e\n\u003cp\u003e이 경우에는 useLocalStorage 또는 useSearchParams 훅이 여러 곳에 장착된 이 훅의 여러 인스턴스간 동기화를 다룰 수 있도록 잘 구현되어야 함을 주의하십시오.\u003c/p\u003e\n\u003ch2\u003e파생 상태 노출 및 사용자 정의 작업 노출하기\u003c/h2\u003e\n\u003cp\u003eProvider + useState 변형으로 돌아오면, context 내에서 캡슐화된 파생 상태 및 사용자 정의 작업을 쉽게 추가할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다시 한 번 강조하지만, 코드를 사용할 때는 내부에서 무슨 일이 일어나고 있는지 몰라도 useHasFilters 또는 useResetFilters를 호출할 수 있습니다. 모든 상태 관리는 UI 구성 요소 외부에서 단일 파일에서 처리합니다.\u003c/p\u003e\n\u003cp\u003e이전 예제마다 URL이나 로컬 저장소에 상태를 저장하거나 사용자 정의 파생 상태와 작업을 추가하는 등 상태 관리 변경을 수행할 수 있었습니다. 이를 통해 상태를 사용하는 수천 곳의 대규모 앱이라도 한 파일만 수정하면 됩니다. Redux나 Zustand와 같은 상태 관리 도구를 직접 사용할 때는 이러한 작업이 불가능합니다.\u003c/p\u003e\n\u003ch1\u003e컨텍스트 생성을 덜 번거롭게 만들기\u003c/h1\u003e\n\u003cp\u003e일부 사람들은 컨텍스트가 너무 말이 많다고 주장합니다. 사실 그래요. 하지만 저는 캡슐화되었을 때 추가되는 가치와 비교했을 때, 한 파일에만 영향을 미치는 추가적인 말이 많음은 그랬다간 않다고 생각해요.\u003c/p\u003e\n\u003cp\u003e그래도, 한 줄로 컨텍스트를 만드는 기술이 있답니다: 컨텍스트 팩토리 기술이죠.\u003c/p\u003e\n\u003cp\u003e앞서 한 모든 것들을 하나의 함수로 감싸는 것을 볼 수 있어요. 또한, 함수 내에서 인터페이스도 만들고 제네릭을 사용할 수 있게 해줍니다. 그리고, 우리가 상태의 초기 값을 프로바이더의 속성으로 전달한다는 것을 주목해주세요.\u003c/p\u003e\n\u003cp\u003e다음과 같이 전역 범위에서 사용할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e이제 이전의 모든 것을 하나의 코드 라인으로 갖고 있습니다 😃✨. 이것은 일반 useState처럼 거의 동일하지만, 특정 제공자 하위 모든 사용자 사이에서 공유됩니다. 이렇게 하면 모듈식 \"의사 전역\" 상태를 매우 쉽게 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e여러 값을 저장해야 하는 경우에는 여러 제공자를 생성하거나 하나의 제공자 내에 (작은) 객체를 넣어야 합니다.\u003c/p\u003e\n\u003ch2\u003e기타 장점\u003c/h2\u003e\n\u003cp\u003e요약을 위해 모든 것을 다 다루진 않았지만, 다른 장점으로는 다음과 같은 것이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e다중 공급자 사용 가능: 각 공급자마다 상태가 복제됩니다 (전역 범위에서 상태를 생성하는 Redux, Recoil 등에서 불가능한 것입니다)\u003c/li\u003e\n\u003cli\u003e중첩된 공급자 사용 가능: React 문서에 이에 대한 예제가 있습니다. 한 공급자는 같은 유형의 부모 컨텍스트를 찾아 중첩 수준을 알 수 있습니다.\u003c/li\u003e\n\u003cli\u003e내부적으로 상태 관리 라이브러리 사용 가능: 공급자는 Zustand, Recoil 또는 Redux를 내부적으로 사용하여 UI 구성 요소에 특정 라이브러리 기능을 노출하지 않고 무용의 리렌더링을 피할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e데이터베이스에 상태 저장 가능한 경우, useState 또는 라이브러리와 같은 클라이언트 상태 관리 도구없이 모두 서버 상태에서 처리할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e캡슐화와 함께 올바르게 사용한다면 컨텍스트는 매우 강력한 도구입니다. 그들의 장황함은 도우미 함수로 완화될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e내 프로젝트에서 사용하는 도우미 함수가 있어요. 렌더 프롭과 외부 상태를 받아들일 수 있는 추가 기능을 가지고 있어서, 이를 참고하여 영감을 받을 수 있을 거에요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-UsingReactcontextstherightway"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>