<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>자바스크립트 HTML 리치 텍스트 편집기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-JavascriptHTMLRich-TextEditors" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="자바스크립트 HTML 리치 텍스트 편집기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="자바스크립트 HTML 리치 텍스트 편집기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-JavascriptHTMLRich-TextEditors" data-gatsby-head="true"/><meta name="twitter:title" content="자바스크립트 HTML 리치 텍스트 편집기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 03:27" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">자바스크립트 HTML 리치 텍스트 편집기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="자바스크립트 HTML 리치 텍스트 편집기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-JavascriptHTMLRich-TextEditors&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>리치 텍스트 편집기 또는 WYSIWYG 편집기를 사용하면 사용자가 스타일이 적용된 텍스트, 이미지, 목록, 코드 블록 등을 입력할 수 있습니다. 만약 여러분이 마크다운으로 작성할 수 없는 사용자를 대상으로 한 웹사이트에서 텍스트/문서 입력을 구축 중이라면 이 접근 방식이 유용할 것입니다.</p>
<p>이 글에서는 모든 현대적인 웹에 쉽게 통합할 수 있는 뛰어난 무료 오픈 소스 WYSIWYG인 Quill로 이러한 편집기를 만드는 방법을 안내해 드릴 것입니다.</p>
<h1>기본 예제</h1>
<p>우리의 프로젝트에 필요한 JavaScript 및 CSS 파일을 포함시켜 시작하겠습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">&#x3C;!-- 스타일시트 포함 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.quilljs.com/1.3.6/quill.snow.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>></span>
<span class="hljs-comment">&#x3C;!-- Quill 라이브러리 포함 --></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.quilljs.com/1.3.6/quill.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span>
</span></code></pre>
<p>또는 저처럼 코드 펜을 사용하는 경우 설정을 클릭하고 위의 Css 및 Js 링크를 추가해주세요.</p>
<img src="/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_0.png">
<p>가장 간단한 형태로 시작해보겠습니다.</p>
<div class="content-ad"></div>
<p>Markdown</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> quill = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quill</span>(<span class="hljs-string">'#editor'</span>, {
    <span class="hljs-attr">theme</span>: <span class="hljs-string">'snow'</span>
});
</code></pre>
<div class="content-ad"></div>
<p>CSS: 없음</p>
<p>그래, 이 간단한 리치 텍스트 편집기를 얻기 위해 해야 할 일은 이것뿐이에요. 여기서 글꼴 크기를 변경하거나 스타일을 추가/삭제할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_1.png" alt="리치 텍스트 편집기"></p>
<p>editor라는 id를 설정하고 Quill 편집기를 초기화하는 데 사용하고 있습니다. 그러나 CSS 선택기나 DOM 객체를 전달할 수도 있어요.</p>
<div class="content-ad"></div>
<p>예를 들어, 다음과 같이 classname editor를 전달하면 Quill이 첫 번째 일치하는 요소에 에디터를 생성합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> editor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quill</span>(<span class="hljs-string">'.editor'</span>);  
</code></pre>
<p>또는 DOM 객체를 전달할 수도 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'editor'</span>);
<span class="hljs-keyword">var</span> editor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quill</span>(container);
</code></pre>
<div class="content-ad"></div>
<p>만약 툴바에 폭과 같은 추가 스타일링을 하고 싶다면, 에디터 자체의 스타일을 변경하는 것은 작동하지 않을 것입니다. 다음과 같이 결과물이 나올 것입니다.</p>
<p><img src="/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_2.png" alt="example image"></p>
<p>이를 수행하는 방법은 3가지가 있습니다.</p>
<p>Quill은 툴바를 위한 클래스인 ql-toolbar를 사용하므로 아래와 같이 스타일을 오버라이드할 수 있습니다.</p>
<div class="content-ad"></div>
<p>아래는 Markdown 형식으로 변경한 내용입니다.</p>
<p><img src="/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_3.png" alt="이미지"></p>
<p>또는 전체 편집기를 사용자 정의 컨테이너에 임베드하고 컨테이너 너비를 변경할 수도 있습니다.</p>
<p><img src="/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_4.png" alt="이미지"></p>
<p>세 번째 옵션은 new Quill()를 호출하고 편집기를 만들 때 추가 구성을 추가하는 것입니다. 다음 부분에서 이에 대해 자세히 살펴보겠습니다.</p>
<div class="content-ad"></div>
<p>좋아요! 이제 리치 텍스트 편집기가 아닌 스타일이 좀 적은 편집기가 되었네요!</p>
<h2>사용자 정의</h2>
<p>Quill로 더 풍부하게 만들어 보겠습니다.</p>
<p>이 라이브러리는 사용자 정의와 확장을 염두에 두고 설계되었습니다. 우리의 요구에 맞게 커스터마이즈하는 다양한 방법이 있습니다.</p>
<div class="content-ad"></div>
<ul>
<li>Configuration: 기존 기능을 조정하는 데 사용됩니다</li>
<li>Modules: 새로운 기능을 추가하는 데 사용됩니다</li>
<li>Themes: 스타일링을 위해 사용됩니다</li>
</ul>
<h1>구성</h1>
<p>먼저 기존 기능을 어떻게 조정할 수 있는지 살펴보겠습니다.</p>
<p>우리가 위에서 사용한 javascript에서 'theme: ‘snow’'를 추가했다는 점을 유의해주세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> quill = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quill</span>(<span class="hljs-string">'#editor'</span>, {
  <span class="hljs-attr">theme</span>: <span class="hljs-string">'snow'</span>
});
</code></pre>
<p>이것은 Quill에서 인식하는 옵션 중 하나입니다. 전체 목록을 확인할 수 있고, 저는 발견한 몇 가지를 여러분에게 보여드릴게요.</p>
<h2>모듈</h2>
<p>새 기능을 추가할 때 사용할 키입니다. 곧 자세히 살펴볼 예정입니다.</p>
<div class="content-ad"></div>
<p>이외에도 몇 가지 매우 중요한 미리 만들어진 것들이 있어요.</p>
<ul>
<li>툴바</li>
</ul>
<p>아래에는 위에서 보여드렸던 기본적인 것이 있어요</p>
<p><img src="/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_5.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>테이블 태그를 마크다운 형식으로 변경하면 됩니다.</p>
<div class="content-ad"></div>
<p>아래에 보이는 내용입니다.</p>
<p><img src="/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_6.png" alt="이미지"></p>
<p>색상 및 배경에 대해 빈 배열을 가지고 있더라도 여전히 선택할 수 있는 멋진 색 팔레트를 얻을 수 있습니다.</p>
<p>이는 테마가 드롭다운을 위해 기본값을 지정할 수 있기 때문입니다. 위의 예에서 우리는 Snow를 사용하고 있으며, 색상 및 배경 형식에 대해 빈 배열로 설정하면 색상 목록에서 기본값으로 35가지 색상을 제공합니다.</p>
<div class="content-ad"></div>
<p>위의 예시에서는 단순히 기존의 어트리뷰터를 선택했습니다. 그러나 여러분은 이를 사용자 정의할 수도 있어요. 예를 들어, 사용자 지정 글꼴을 추가하려면:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">FontAttributor</span> = <span class="hljs-title class_">Quill</span>.<span class="hljs-keyword">import</span>(<span class="hljs-string">'attributors/class/font'</span>);
<span class="hljs-title class_">FontAttributor</span>.<span class="hljs-property">whitelist</span> = [
  <span class="hljs-string">'sofia'</span>, <span class="hljs-string">'slabo'</span>, <span class="hljs-string">'roboto'</span>, <span class="hljs-string">'inconsolata'</span>, <span class="hljs-string">'ubuntu'</span>
];
<span class="hljs-title class_">Quill</span>.<span class="hljs-title function_">register</span>(<span class="hljs-title class_">FontAttributor</span>, <span class="hljs-literal">true</span>);
</code></pre>
<pre><code class="hljs language-js">.<span class="hljs-property">ql</span>-font-roboto {
  font-<span class="hljs-attr">family</span>: <span class="hljs-string">'Roboto'</span>, sans-serif;
}
</code></pre>
<p>더 많은 사용자 정의와 제어를 원하신다면, HTML에서 직접 툴바를 만들고 DOM 요소나 셀렉터를 Quill에 전달할 수 있어요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">&#x3C;!-- 툴바 컨테이너 생성 -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"toolbarContainer"</span>></span>
  <span class="hljs-comment">&#x3C;!-- 글꼴 크기 드롭다운 추가 --></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">select</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ql-size"</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"small"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">option</span>></span>
    <span class="hljs-comment">&#x3C;!-- 주의: 값이 없어서 기본 값으로 재설정됨 --></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">option</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"large"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">option</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"huge"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">option</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">select</span>></span>
  <span class="hljs-comment">&#x3C;!-- 굵게 버튼 추가 --></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ql-bold"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
  <span class="hljs-comment">&#x3C;!-- 아래 첨자 및 위첨자 버튼 추가 --></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ql-script"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"sub"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ql-script"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"super"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"editor"</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> options = {
  <span class="hljs-attr">modules</span>: {
    <span class="hljs-attr">toolbar</span>: {
      <span class="hljs-attr">container</span>: <span class="hljs-string">'#toolbarContainer'</span>,  
      <span class="hljs-attr">handlers</span>: {
        <span class="hljs-string">'bold'</span>: customBoldHandler
      }
    }
  },
  <span class="hljs-attr">theme</span>: <span class="hljs-string">'snow'</span>
};

<span class="hljs-keyword">var</span> quill = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quill</span>(<span class="hljs-string">'#editor'</span>, options);
</code></pre>
<p>만약 사용자 정의 컨테이너를 사용한다면, 컨트롤도 직접 설정해야 합니다. 그렇지 않으면 빈 툴바가 나타날 수 있습니다. 아래와 같이 확인하세요.</p>
<img src="/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_7.png">
<div class="content-ad"></div>
<p>테이블 태그를 Markdown 형식으로 변경하면 됩니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> toolbarHanlderOptions = {
  <span class="hljs-attr">handlers</span>: {
    <span class="hljs-string">'link'</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
      <span class="hljs-keyword">if</span> (value) {
        <span class="hljs-keyword">var</span> href = <span class="hljs-title function_">prompt</span>(<span class="hljs-string">'URL을 입력하세요'</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">quill</span>.<span class="hljs-title function_">format</span>(<span class="hljs-string">'link'</span>, href);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">quill</span>.<span class="hljs-title function_">format</span>(<span class="hljs-string">'link'</span>, <span class="hljs-literal">false</span>);
      }
    }
  }
}

<span class="hljs-keyword">var</span> options = {
  <span class="hljs-attr">modules</span>: {
    <span class="hljs-attr">toolbar</span>: toolbarHanlderOptions,
  },
  <span class="hljs-attr">theme</span>: <span class="hljs-string">'snow'</span>
};

<span class="hljs-keyword">var</span> quill = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quill</span>(<span class="hljs-string">'#editor'</span>, options);
</code></pre>
<p>우리는 다음을 받게 될 것입니다</p>
<img src="https://miro.medium.com/v2/resize:fit:1400/1*QpD3jR3s6v4M_nUWwLOFdg.gif">
<p>핸들러 함수는 툴바에 바인딩되어 있으므로 this를 사용하면 툴바 인스턴스를 참조하게 됩니다.</p>
<div class="content-ad"></div>
<p>위 조정 도구 모양에 대한 자세한 내용은 여기에서 확인할 수 있어요.</p>
<ul>
<li>구문</li>
</ul>
<p>이 모듈은 구문 강조 효과를 적용하여 코드 블록 포맷을 강화합니다. 코드 블록을 자동으로 감지하고 구문 강조를 적용하기 위해 훌륭한 highlight.js 라이브러리가 사용됩니다.</p>
<p>사용하려면 먼저 마음에 드는 highlight.js 스타일 시트를 추가하고 highlight.js 라이브러리를 포함시키세요.</p>
<div class="content-ad"></div>
<p>만약 제가 사용하고 있는 것처럼 codepan.io를 사용 중이라면, 설정 옵션을 통해이를 추가하는 것이 작동하지 않을 수 있으며 수동으로 HTML에 다음과 같이 추가해야 합니다.</p>
<pre><code class="hljs language-js">&#x3C;link rel=<span class="hljs-string">"stylesheet"</span> href=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"</span>>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">script</span>></span></span>
</code></pre>
<p>그런 다음 툴바 옵션에 코드 블록을 포함시키십시오. 저 위의 예제를 사용 중이라면 이미 포함되어 있어야 합니다.</p>
<p>모듈에 구문 키를 추가하고 구문 모듈을 포함하려면 true로 설정하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> quill = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quill</span>(<span class="hljs-string">'#editor'</span>, {
  <span class="hljs-attr">modules</span>: {
    <span class="hljs-attr">syntax</span>: <span class="hljs-literal">true</span>,              
    <span class="hljs-attr">toolbar</span>: [[<span class="hljs-string">'code-block'</span>]]  
  },
  <span class="hljs-attr">theme</span>: <span class="hljs-string">'snow'</span>
});
</code></pre>
<p>아래와 같이 특정 언어 또는 모든 언어로 구성할 수도 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 선택적으로 hljs 구성</span>
hljs.<span class="hljs-title function_">configure</span>({   
    <span class="hljs-attr">languages</span>: [<span class="hljs-string">'javascript'</span>, <span class="hljs-string">'ruby'</span>, <span class="hljs-string">'python'</span>]
});

<span class="hljs-comment">// 또는 모든 언어 강조</span>
hljs.<span class="hljs-title function_">highlightAll</span>();
</code></pre>
<h2>placeholder</h2>
<div class="content-ad"></div>
<p>이 옵션 키는 편집기가 비어 있을 때 표시할 자리 표시자 텍스트를 구성하는 데 사용됩니다.</p>
<p>다음과 같은 옵션을 사용하면</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> options = {
  <span class="hljs-attr">placeholder</span>: <span class="hljs-string">'말해보세요!'</span>,
  <span class="hljs-attr">theme</span>: <span class="hljs-string">'snow'</span>
};


<span class="hljs-keyword">var</span> quill = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quill</span>(<span class="hljs-string">'#editor'</span>, options);
</code></pre>
<p>다음은 우리가 얻게 될 것입니다!</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_8.png">
<h2>readOnly</h2>
<p>이 값은 에디터를 읽기 전용 모드로 초기화할지 여부를 나타냅니다. 기본값은 false입니다.</p>
<p>사용자가 더 이상 수정할 수 없게 하고 입력한 내용을 확인해야 하는 확인 페이지를 만들고 싶을 때 이 값은 정말 유용합니다. 이 경우 툴바를 false로 설정하고 싶을 수도 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> options = {
  <span class="hljs-attr">modules</span>: {
      <span class="hljs-attr">toolbar</span>: <span class="hljs-literal">false</span>
  },
  <span class="hljs-attr">readOnly</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">theme</span>: <span class="hljs-string">'snow'</span>
}

<span class="hljs-keyword">var</span> quill = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quill</span>(<span class="hljs-string">'#editor'</span>, options);
</code></pre>
<h2>테마</h2>
<p>이 키는 전체 스타일링을 구성하는 데 사용할 키이며 곧 자세히 살펴볼 것입니다.</p>
<h1>모듈</h1>
<div class="content-ad"></div>
<p>이전 섹션에서 툴바와 같은 몇 가지 미리 구축된 모듈을 이미 살펴보았습니다. 이 모듈은 확장되어 원본 모듈을 대체하거나 다시 등록할 수도 있습니다.</p>
<p>예를 들어, 이를 통해 클립보드 모듈이 Quill과 외부 애플리케이션 간에 복사, 잘라내기 및 붙여넣기를 어떻게 처리할지 구성할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">Clipboard</span> = <span class="hljs-title class_">Quill</span>.<span class="hljs-keyword">import</span>(<span class="hljs-string">'modules/clipboard'</span>);
<span class="hljs-keyword">var</span> <span class="hljs-title class_">Delta</span> = <span class="hljs-title class_">Quill</span>.<span class="hljs-keyword">import</span>(<span class="hljs-string">'delta'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PlainClipboard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Clipboard</span> {
  <span class="hljs-title function_">convert</span>(<span class="hljs-params">html = <span class="hljs-literal">null</span></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> html === <span class="hljs-string">'string'</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">innerHTML</span> = html;
    }
    <span class="hljs-keyword">let</span> text = <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">innerText</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Delta</span>().<span class="hljs-title function_">insert</span>(text);
  }
}

<span class="hljs-title class_">Quill</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">'modules/clipboard'</span>, <span class="hljs-title class_">PlainClipboard</span>, <span class="hljs-literal">true</span>);

<span class="hljs-keyword">var</span> quill = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Quill</span>(<span class="hljs-string">'#editor'</span>);
</code></pre>
<p>그러나 때로는 (사실 대부분의 경우) 기존 모듈을 사용하거나 구성하는 것이 더 쉬울 수 있습니다. 위 예에서 기존 Clipboard의 addMatcher API가 더 적합합니다.</p>
<div class="content-ad"></div>
<p>리치 텍스트 편집기에 대한 API가 무엇인지 궁금하신가요? 조금 더 자세히 설명해 드릴게요. 실제로 이게 Quill의 가장 멋진 부분이라고 생각해요.</p>
<h1>테마</h1>
<p>우리는 이미 여러 차례 이 키를 사용했어요. 사용할 테마 이름입니다. 내장된 옵션은 bubble 또는 snow입니다. 잘못된 값은 기본 최소 테마를 로드합니다.</p>
<ul>
<li>bubble: 간단한 툴팁 기반 테마입니다.</li>
<li>snow: 깨끗하고 평평한 툴바 테마이며, 위에서 반복적으로 사용한 것입니다.</li>
</ul>
<div class="content-ad"></div>
<p>테마의 구체적인 스타일시트는 여전히 수동으로 포함해야 합니다. 더 많은 정보 및 추가 사용자 정의를 위해 테마를 확인해보세요!</p>
<h1>API 주도 설계</h1>
<p>자바스크립트와 HTML을 사용하여 간단한 리치 텍스트 편집기를 만드는 방법을 보여드렸습니다. 그러나 Quill에서 가장 독특한 요소 중 하나(제 개인적인 의견으로)는 API 주도 설계입니다.</p>
<p>대부분의 리치 텍스트 편집기는 사용자가 작성한 텍스트를 알지 못하며, 내용을 웹 개발자가 보는 렌즈로 보게 됩니다: DOM입니다. 이는 DOM이 불균형 트리로 구성된 노드로 이루어져 있지만 텍스트는 줄, 단어 및 문자로 이루어져 있기 때문에 임피던스 불일치를 초래합니다.</p>
<div class="content-ad"></div>
<p>문자가 측정 단위인 DOM API가 없습니다. 이 제한으로 대부분의 리치 텍스트 에디터는 "이 범위에 어떤 텍스트가 있는가?" 또는 "커서가 굵은 텍스트에 있는가?" 같은 간단한 질문에 대답할 수 없습니다.</p>
<p>그에 반대로, API 주도 설계를 통해 Quill은 굵은 텍스트인지 확인하려면 <code>b</code>나 <code>strong</code> 노드 또는 글꼴 두께 스타일 속성을 찾는 DOM 탐색이 필요하지 않습니다.</p>
<p>할 일은 getFormat(5, 1) API를 호출하는 것 뿐입니다. 모든 핵심 API 호출은 임의의 인덱스와 길이로 액세스하거나 수정할 수 있습니다. 그리고 해당 이벤트 API는 직관적인 JSON 형식으로 변경 사항을 보고하며 HTML 구문 분석이나 DOM 트리 비교가 필요하지 않습니다.</p>
<p>그러므로 Quill은 나만의 리치 텍스트 에디터 솔루션을 설계할 때 더 많은 옵션과 자유를 제공하며 더 간단한 해결책으로 이어줍니다!</p>
<div class="content-ad"></div>
<p>그거 오늘은 여기까지야!</p>
<p>리치 텍스트 편집기를 만들어서 부자가 되어보자(아마?)!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"자바스크립트 HTML 리치 텍스트 편집기","description":"","date":"2024-06-20 03:27","slug":"2024-06-20-JavascriptHTMLRich-TextEditors","content":"\n\n리치 텍스트 편집기 또는 WYSIWYG 편집기를 사용하면 사용자가 스타일이 적용된 텍스트, 이미지, 목록, 코드 블록 등을 입력할 수 있습니다. 만약 여러분이 마크다운으로 작성할 수 없는 사용자를 대상으로 한 웹사이트에서 텍스트/문서 입력을 구축 중이라면 이 접근 방식이 유용할 것입니다.\n\n이 글에서는 모든 현대적인 웹에 쉽게 통합할 수 있는 뛰어난 무료 오픈 소스 WYSIWYG인 Quill로 이러한 편집기를 만드는 방법을 안내해 드릴 것입니다.\n\n# 기본 예제\n\n우리의 프로젝트에 필요한 JavaScript 및 CSS 파일을 포함시켜 시작하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!-- 스타일시트 포함 --\u003e\n\u003clink href=\"https://cdn.quilljs.com/1.3.6/quill.snow.css\" rel=\"stylesheet\"\u003e\n\u003c!-- Quill 라이브러리 포함 --\u003e\n\u003cscript src=\"https://cdn.quilljs.com/1.3.6/quill.js\"\u003e\u003c/script\u003e\n```\n\n또는 저처럼 코드 펜을 사용하는 경우 설정을 클릭하고 위의 Css 및 Js 링크를 추가해주세요.\n\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_0.png\" /\u003e\n\n가장 간단한 형태로 시작해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMarkdown\n\n```js\nvar quill = new Quill('#editor', {\n    theme: 'snow'\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCSS: 없음\n\n그래, 이 간단한 리치 텍스트 편집기를 얻기 위해 해야 할 일은 이것뿐이에요. 여기서 글꼴 크기를 변경하거나 스타일을 추가/삭제할 수 있습니다.\n\n![리치 텍스트 편집기](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_1.png)\n\neditor라는 id를 설정하고 Quill 편집기를 초기화하는 데 사용하고 있습니다. 그러나 CSS 선택기나 DOM 객체를 전달할 수도 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 다음과 같이 classname editor를 전달하면 Quill이 첫 번째 일치하는 요소에 에디터를 생성합니다.\n\n```js\nvar editor = new Quill('.editor');  \n```\n\n또는 DOM 객체를 전달할 수도 있습니다.\n\n```js\nvar container = document.getElementById('editor');\nvar editor = new Quill(container);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 툴바에 폭과 같은 추가 스타일링을 하고 싶다면, 에디터 자체의 스타일을 변경하는 것은 작동하지 않을 것입니다. 다음과 같이 결과물이 나올 것입니다.\n\n![example image](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_2.png)\n\n이를 수행하는 방법은 3가지가 있습니다.\n\nQuill은 툴바를 위한 클래스인 ql-toolbar를 사용하므로 아래와 같이 스타일을 오버라이드할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 변경한 내용입니다.\n\n\n![이미지](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_3.png)\n\n또는 전체 편집기를 사용자 정의 컨테이너에 임베드하고 컨테이너 너비를 변경할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_4.png)\n\n세 번째 옵션은 new Quill()를 호출하고 편집기를 만들 때 추가 구성을 추가하는 것입니다. 다음 부분에서 이에 대해 자세히 살펴보겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요! 이제 리치 텍스트 편집기가 아닌 스타일이 좀 적은 편집기가 되었네요!\n\n## 사용자 정의\n\nQuill로 더 풍부하게 만들어 보겠습니다.\n\n이 라이브러리는 사용자 정의와 확장을 염두에 두고 설계되었습니다. 우리의 요구에 맞게 커스터마이즈하는 다양한 방법이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Configuration: 기존 기능을 조정하는 데 사용됩니다\n- Modules: 새로운 기능을 추가하는 데 사용됩니다\n- Themes: 스타일링을 위해 사용됩니다\n\n# 구성\n\n먼저 기존 기능을 어떻게 조정할 수 있는지 살펴보겠습니다.\n\n우리가 위에서 사용한 javascript에서 'theme: ‘snow’'를 추가했다는 점을 유의해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar quill = new Quill('#editor', {\n  theme: 'snow'\n});\n```\n\n이것은 Quill에서 인식하는 옵션 중 하나입니다. 전체 목록을 확인할 수 있고, 저는 발견한 몇 가지를 여러분에게 보여드릴게요.\n\n## 모듈\n\n새 기능을 추가할 때 사용할 키입니다. 곧 자세히 살펴볼 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이외에도 몇 가지 매우 중요한 미리 만들어진 것들이 있어요.\n\n- 툴바\n\n아래에는 위에서 보여드렸던 기본적인 것이 있어요\n\n\n![이미지](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_5.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에 보이는 내용입니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_6.png)\n\n색상 및 배경에 대해 빈 배열을 가지고 있더라도 여전히 선택할 수 있는 멋진 색 팔레트를 얻을 수 있습니다.\n\n이는 테마가 드롭다운을 위해 기본값을 지정할 수 있기 때문입니다. 위의 예에서 우리는 Snow를 사용하고 있으며, 색상 및 배경 형식에 대해 빈 배열로 설정하면 색상 목록에서 기본값으로 35가지 색상을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예시에서는 단순히 기존의 어트리뷰터를 선택했습니다. 그러나 여러분은 이를 사용자 정의할 수도 있어요. 예를 들어, 사용자 지정 글꼴을 추가하려면:\n\n```js\nvar FontAttributor = Quill.import('attributors/class/font');\nFontAttributor.whitelist = [\n  'sofia', 'slabo', 'roboto', 'inconsolata', 'ubuntu'\n];\nQuill.register(FontAttributor, true);\n```\n\n```js\n.ql-font-roboto {\n  font-family: 'Roboto', sans-serif;\n}\n```\n\n더 많은 사용자 정의와 제어를 원하신다면, HTML에서 직접 툴바를 만들고 DOM 요소나 셀렉터를 Quill에 전달할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!-- 툴바 컨테이너 생성 --\u003e\n\u003cdiv id=\"toolbarContainer\"\u003e\n  \u003c!-- 글꼴 크기 드롭다운 추가 --\u003e\n  \u003cselect class=\"ql-size\"\u003e\n    \u003coption value=\"small\"\u003e\u003c/option\u003e\n    \u003c!-- 주의: 값이 없어서 기본 값으로 재설정됨 --\u003e\n    \u003coption selected\u003e\u003c/option\u003e\n    \u003coption value=\"large\"\u003e\u003c/option\u003e\n    \u003coption value=\"huge\"\u003e\u003c/option\u003e\n  \u003c/select\u003e\n  \u003c!-- 굵게 버튼 추가 --\u003e\n  \u003cbutton class=\"ql-bold\"\u003e\u003c/button\u003e\n  \u003c!-- 아래 첨자 및 위첨자 버튼 추가 --\u003e\n  \u003cbutton class=\"ql-script\" value=\"sub\"\u003e\u003c/button\u003e\n  \u003cbutton class=\"ql-script\" value=\"super\"\u003e\u003c/button\u003e\n\u003c/div\u003e\n\u003cdiv id=\"editor\"\u003e\n\u003c/div\u003e\n```\n\n```js\nvar options = {\n  modules: {\n    toolbar: {\n      container: '#toolbarContainer',  \n      handlers: {\n        'bold': customBoldHandler\n      }\n    }\n  },\n  theme: 'snow'\n};\n\nvar quill = new Quill('#editor', options);\n```\n\n만약 사용자 정의 컨테이너를 사용한다면, 컨트롤도 직접 설정해야 합니다. 그렇지 않으면 빈 툴바가 나타날 수 있습니다. 아래와 같이 확인하세요.\n\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_7.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar toolbarHanlderOptions = {\n  handlers: {\n    'link': function(value) {\n      if (value) {\n        var href = prompt('URL을 입력하세요');\n        this.quill.format('link', href);\n      } else {\n        this.quill.format('link', false);\n      }\n    }\n  }\n}\n\nvar options = {\n  modules: {\n    toolbar: toolbarHanlderOptions,\n  },\n  theme: 'snow'\n};\n\nvar quill = new Quill('#editor', options);\n```\n\n우리는 다음을 받게 될 것입니다\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*QpD3jR3s6v4M_nUWwLOFdg.gif\" /\u003e\n\n핸들러 함수는 툴바에 바인딩되어 있으므로 this를 사용하면 툴바 인스턴스를 참조하게 됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 조정 도구 모양에 대한 자세한 내용은 여기에서 확인할 수 있어요.\n\n- 구문\n\n이 모듈은 구문 강조 효과를 적용하여 코드 블록 포맷을 강화합니다. 코드 블록을 자동으로 감지하고 구문 강조를 적용하기 위해 훌륭한 highlight.js 라이브러리가 사용됩니다.\n\n사용하려면 먼저 마음에 드는 highlight.js 스타일 시트를 추가하고 highlight.js 라이브러리를 포함시키세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 제가 사용하고 있는 것처럼 codepan.io를 사용 중이라면, 설정 옵션을 통해이를 추가하는 것이 작동하지 않을 수 있으며 수동으로 HTML에 다음과 같이 추가해야 합니다.\n\n```js\n\u003clink rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css\"\u003e\n\u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js\"\u003e\u003c/script\u003e\n```\n\n그런 다음 툴바 옵션에 코드 블록을 포함시키십시오. 저 위의 예제를 사용 중이라면 이미 포함되어 있어야 합니다.\n\n모듈에 구문 키를 추가하고 구문 모듈을 포함하려면 true로 설정하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar quill = new Quill('#editor', {\n  modules: {\n    syntax: true,              \n    toolbar: [['code-block']]  \n  },\n  theme: 'snow'\n});\n```\n\n아래와 같이 특정 언어 또는 모든 언어로 구성할 수도 있습니다.\n\n```js\n// 선택적으로 hljs 구성\nhljs.configure({   \n    languages: ['javascript', 'ruby', 'python']\n});\n\n// 또는 모든 언어 강조\nhljs.highlightAll();\n```\n\n## placeholder\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 옵션 키는 편집기가 비어 있을 때 표시할 자리 표시자 텍스트를 구성하는 데 사용됩니다.\n\n다음과 같은 옵션을 사용하면\n\n```js\nvar options = {\n  placeholder: '말해보세요!',\n  theme: 'snow'\n};\n\n\nvar quill = new Quill('#editor', options);\n```\n\n다음은 우리가 얻게 될 것입니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_8.png\" /\u003e\n\n## readOnly\n\n이 값은 에디터를 읽기 전용 모드로 초기화할지 여부를 나타냅니다. 기본값은 false입니다.\n\n사용자가 더 이상 수정할 수 없게 하고 입력한 내용을 확인해야 하는 확인 페이지를 만들고 싶을 때 이 값은 정말 유용합니다. 이 경우 툴바를 false로 설정하고 싶을 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar options = {\n  modules: {\n      toolbar: false\n  },\n  readOnly: true,\n  theme: 'snow'\n}\n\nvar quill = new Quill('#editor', options);\n```\n\n## 테마\n\n이 키는 전체 스타일링을 구성하는 데 사용할 키이며 곧 자세히 살펴볼 것입니다.\n\n# 모듈\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 섹션에서 툴바와 같은 몇 가지 미리 구축된 모듈을 이미 살펴보았습니다. 이 모듈은 확장되어 원본 모듈을 대체하거나 다시 등록할 수도 있습니다.\n\n예를 들어, 이를 통해 클립보드 모듈이 Quill과 외부 애플리케이션 간에 복사, 잘라내기 및 붙여넣기를 어떻게 처리할지 구성할 수 있습니다.\n\n```js\nvar Clipboard = Quill.import('modules/clipboard');\nvar Delta = Quill.import('delta');\n\nclass PlainClipboard extends Clipboard {\n  convert(html = null) {\n    if (typeof html === 'string') {\n      this.container.innerHTML = html;\n    }\n    let text = this.container.innerText;\n    this.container.innerHTML = '';\n    return new Delta().insert(text);\n  }\n}\n\nQuill.register('modules/clipboard', PlainClipboard, true);\n\nvar quill = new Quill('#editor');\n```\n\n그러나 때로는 (사실 대부분의 경우) 기존 모듈을 사용하거나 구성하는 것이 더 쉬울 수 있습니다. 위 예에서 기존 Clipboard의 addMatcher API가 더 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리치 텍스트 편집기에 대한 API가 무엇인지 궁금하신가요? 조금 더 자세히 설명해 드릴게요. 실제로 이게 Quill의 가장 멋진 부분이라고 생각해요.\n\n# 테마\n\n우리는 이미 여러 차례 이 키를 사용했어요. 사용할 테마 이름입니다. 내장된 옵션은 bubble 또는 snow입니다. 잘못된 값은 기본 최소 테마를 로드합니다.\n\n- bubble: 간단한 툴팁 기반 테마입니다.\n- snow: 깨끗하고 평평한 툴바 테마이며, 위에서 반복적으로 사용한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테마의 구체적인 스타일시트는 여전히 수동으로 포함해야 합니다. 더 많은 정보 및 추가 사용자 정의를 위해 테마를 확인해보세요!\n\n# API 주도 설계\n\n자바스크립트와 HTML을 사용하여 간단한 리치 텍스트 편집기를 만드는 방법을 보여드렸습니다. 그러나 Quill에서 가장 독특한 요소 중 하나(제 개인적인 의견으로)는 API 주도 설계입니다.\n\n대부분의 리치 텍스트 편집기는 사용자가 작성한 텍스트를 알지 못하며, 내용을 웹 개발자가 보는 렌즈로 보게 됩니다: DOM입니다. 이는 DOM이 불균형 트리로 구성된 노드로 이루어져 있지만 텍스트는 줄, 단어 및 문자로 이루어져 있기 때문에 임피던스 불일치를 초래합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문자가 측정 단위인 DOM API가 없습니다. 이 제한으로 대부분의 리치 텍스트 에디터는 \"이 범위에 어떤 텍스트가 있는가?\" 또는 \"커서가 굵은 텍스트에 있는가?\" 같은 간단한 질문에 대답할 수 없습니다.\n\n그에 반대로, API 주도 설계를 통해 Quill은 굵은 텍스트인지 확인하려면 `b`나 `strong` 노드 또는 글꼴 두께 스타일 속성을 찾는 DOM 탐색이 필요하지 않습니다.\n\n할 일은 getFormat(5, 1) API를 호출하는 것 뿐입니다. 모든 핵심 API 호출은 임의의 인덱스와 길이로 액세스하거나 수정할 수 있습니다. 그리고 해당 이벤트 API는 직관적인 JSON 형식으로 변경 사항을 보고하며 HTML 구문 분석이나 DOM 트리 비교가 필요하지 않습니다.\n\n그러므로 Quill은 나만의 리치 텍스트 에디터 솔루션을 설계할 때 더 많은 옵션과 자유를 제공하며 더 간단한 해결책으로 이어줍니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그거 오늘은 여기까지야!\n\n리치 텍스트 편집기를 만들어서 부자가 되어보자(아마?)!","ogImage":{"url":"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_0.png"},"coverImage":"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e리치 텍스트 편집기 또는 WYSIWYG 편집기를 사용하면 사용자가 스타일이 적용된 텍스트, 이미지, 목록, 코드 블록 등을 입력할 수 있습니다. 만약 여러분이 마크다운으로 작성할 수 없는 사용자를 대상으로 한 웹사이트에서 텍스트/문서 입력을 구축 중이라면 이 접근 방식이 유용할 것입니다.\u003c/p\u003e\n\u003cp\u003e이 글에서는 모든 현대적인 웹에 쉽게 통합할 수 있는 뛰어난 무료 오픈 소스 WYSIWYG인 Quill로 이러한 편집기를 만드는 방법을 안내해 드릴 것입니다.\u003c/p\u003e\n\u003ch1\u003e기본 예제\u003c/h1\u003e\n\u003cp\u003e우리의 프로젝트에 필요한 JavaScript 및 CSS 파일을 포함시켜 시작하겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;!-- 스타일시트 포함 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003elink\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"https://cdn.quilljs.com/1.3.6/quill.snow.css\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erel\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"stylesheet\"\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- Quill 라이브러리 포함 --\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"https://cdn.quilljs.com/1.3.6/quill.js\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 저처럼 코드 펜을 사용하는 경우 설정을 클릭하고 위의 Css 및 Js 링크를 추가해주세요.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_0.png\"\u003e\n\u003cp\u003e가장 간단한 형태로 시작해보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eMarkdown\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e quill = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#editor'\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003etheme\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'snow'\u003c/span\u003e\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eCSS: 없음\u003c/p\u003e\n\u003cp\u003e그래, 이 간단한 리치 텍스트 편집기를 얻기 위해 해야 할 일은 이것뿐이에요. 여기서 글꼴 크기를 변경하거나 스타일을 추가/삭제할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_1.png\" alt=\"리치 텍스트 편집기\"\u003e\u003c/p\u003e\n\u003cp\u003eeditor라는 id를 설정하고 Quill 편집기를 초기화하는 데 사용하고 있습니다. 그러나 CSS 선택기나 DOM 객체를 전달할 수도 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예를 들어, 다음과 같이 classname editor를 전달하면 Quill이 첫 번째 일치하는 요소에 에디터를 생성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e editor = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'.editor'\u003c/span\u003e);  \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 DOM 객체를 전달할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e container = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'editor'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e editor = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e(container);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 툴바에 폭과 같은 추가 스타일링을 하고 싶다면, 에디터 자체의 스타일을 변경하는 것은 작동하지 않을 것입니다. 다음과 같이 결과물이 나올 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_2.png\" alt=\"example image\"\u003e\u003c/p\u003e\n\u003cp\u003e이를 수행하는 방법은 3가지가 있습니다.\u003c/p\u003e\n\u003cp\u003eQuill은 툴바를 위한 클래스인 ql-toolbar를 사용하므로 아래와 같이 스타일을 오버라이드할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 Markdown 형식으로 변경한 내용입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e또는 전체 편집기를 사용자 정의 컨테이너에 임베드하고 컨테이너 너비를 변경할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e세 번째 옵션은 new Quill()를 호출하고 편집기를 만들 때 추가 구성을 추가하는 것입니다. 다음 부분에서 이에 대해 자세히 살펴보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e좋아요! 이제 리치 텍스트 편집기가 아닌 스타일이 좀 적은 편집기가 되었네요!\u003c/p\u003e\n\u003ch2\u003e사용자 정의\u003c/h2\u003e\n\u003cp\u003eQuill로 더 풍부하게 만들어 보겠습니다.\u003c/p\u003e\n\u003cp\u003e이 라이브러리는 사용자 정의와 확장을 염두에 두고 설계되었습니다. 우리의 요구에 맞게 커스터마이즈하는 다양한 방법이 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eConfiguration: 기존 기능을 조정하는 데 사용됩니다\u003c/li\u003e\n\u003cli\u003eModules: 새로운 기능을 추가하는 데 사용됩니다\u003c/li\u003e\n\u003cli\u003eThemes: 스타일링을 위해 사용됩니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e구성\u003c/h1\u003e\n\u003cp\u003e먼저 기존 기능을 어떻게 조정할 수 있는지 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e우리가 위에서 사용한 javascript에서 'theme: ‘snow’'를 추가했다는 점을 유의해주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e quill = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#editor'\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003etheme\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'snow'\u003c/span\u003e\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 Quill에서 인식하는 옵션 중 하나입니다. 전체 목록을 확인할 수 있고, 저는 발견한 몇 가지를 여러분에게 보여드릴게요.\u003c/p\u003e\n\u003ch2\u003e모듈\u003c/h2\u003e\n\u003cp\u003e새 기능을 추가할 때 사용할 키입니다. 곧 자세히 살펴볼 예정입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이외에도 몇 가지 매우 중요한 미리 만들어진 것들이 있어요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e툴바\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래에는 위에서 보여드렸던 기본적인 것이 있어요\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e테이블 태그를 마크다운 형식으로 변경하면 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래에 보이는 내용입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e색상 및 배경에 대해 빈 배열을 가지고 있더라도 여전히 선택할 수 있는 멋진 색 팔레트를 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이는 테마가 드롭다운을 위해 기본값을 지정할 수 있기 때문입니다. 위의 예에서 우리는 Snow를 사용하고 있으며, 색상 및 배경 형식에 대해 빈 배열로 설정하면 색상 목록에서 기본값으로 35가지 색상을 제공합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 예시에서는 단순히 기존의 어트리뷰터를 선택했습니다. 그러나 여러분은 이를 사용자 정의할 수도 있어요. 예를 들어, 사용자 지정 글꼴을 추가하려면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFontAttributor\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e.\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'attributors/class/font'\u003c/span\u003e);\n\u003cspan class=\"hljs-title class_\"\u003eFontAttributor\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ewhitelist\u003c/span\u003e = [\n  \u003cspan class=\"hljs-string\"\u003e'sofia'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'slabo'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'roboto'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'inconsolata'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'ubuntu'\u003c/span\u003e\n];\n\u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eregister\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eFontAttributor\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e.\u003cspan class=\"hljs-property\"\u003eql\u003c/span\u003e-font-roboto {\n  font-\u003cspan class=\"hljs-attr\"\u003efamily\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Roboto'\u003c/span\u003e, sans-serif;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e더 많은 사용자 정의와 제어를 원하신다면, HTML에서 직접 툴바를 만들고 DOM 요소나 셀렉터를 Quill에 전달할 수 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;!-- 툴바 컨테이너 생성 --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"toolbarContainer\"\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- 글꼴 크기 드롭다운 추가 --\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eselect\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ql-size\"\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"small\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- 주의: 값이 없어서 기본 값으로 재설정됨 --\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eselected\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"large\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"huge\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eoption\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eselect\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- 굵게 버튼 추가 --\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ql-bold\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- 아래 첨자 및 위첨자 버튼 추가 --\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ql-script\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"sub\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ql-script\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"super\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"editor\"\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e options = {\n  \u003cspan class=\"hljs-attr\"\u003emodules\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003etoolbar\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003econtainer\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#toolbarContainer'\u003c/span\u003e,  \n      \u003cspan class=\"hljs-attr\"\u003ehandlers\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e'bold'\u003c/span\u003e: customBoldHandler\n      }\n    }\n  },\n  \u003cspan class=\"hljs-attr\"\u003etheme\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'snow'\u003c/span\u003e\n};\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e quill = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#editor'\u003c/span\u003e, options);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 사용자 정의 컨테이너를 사용한다면, 컨트롤도 직접 설정해야 합니다. 그렇지 않으면 빈 툴바가 나타날 수 있습니다. 아래와 같이 확인하세요.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_7.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e테이블 태그를 Markdown 형식으로 변경하면 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e toolbarHanlderOptions = {\n  \u003cspan class=\"hljs-attr\"\u003ehandlers\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e'link'\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (value) {\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e href = \u003cspan class=\"hljs-title function_\"\u003eprompt\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'URL을 입력하세요'\u003c/span\u003e);\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003equill\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'link'\u003c/span\u003e, href);\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003equill\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'link'\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n      }\n    }\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e options = {\n  \u003cspan class=\"hljs-attr\"\u003emodules\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003etoolbar\u003c/span\u003e: toolbarHanlderOptions,\n  },\n  \u003cspan class=\"hljs-attr\"\u003etheme\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'snow'\u003c/span\u003e\n};\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e quill = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#editor'\u003c/span\u003e, options);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 다음을 받게 될 것입니다\u003c/p\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*QpD3jR3s6v4M_nUWwLOFdg.gif\"\u003e\n\u003cp\u003e핸들러 함수는 툴바에 바인딩되어 있으므로 this를 사용하면 툴바 인스턴스를 참조하게 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위 조정 도구 모양에 대한 자세한 내용은 여기에서 확인할 수 있어요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e구문\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 모듈은 구문 강조 효과를 적용하여 코드 블록 포맷을 강화합니다. 코드 블록을 자동으로 감지하고 구문 강조를 적용하기 위해 훌륭한 highlight.js 라이브러리가 사용됩니다.\u003c/p\u003e\n\u003cp\u003e사용하려면 먼저 마음에 드는 highlight.js 스타일 시트를 추가하고 highlight.js 라이브러리를 포함시키세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 제가 사용하고 있는 것처럼 codepan.io를 사용 중이라면, 설정 옵션을 통해이를 추가하는 것이 작동하지 않을 수 있으며 수동으로 HTML에 다음과 같이 추가해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;link rel=\u003cspan class=\"hljs-string\"\u003e\"stylesheet\"\u003c/span\u003e href=\u003cspan class=\"hljs-string\"\u003e\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css\"\u003c/span\u003e\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 툴바 옵션에 코드 블록을 포함시키십시오. 저 위의 예제를 사용 중이라면 이미 포함되어 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e모듈에 구문 키를 추가하고 구문 모듈을 포함하려면 true로 설정하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e quill = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#editor'\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003emodules\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003esyntax\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,              \n    \u003cspan class=\"hljs-attr\"\u003etoolbar\u003c/span\u003e: [[\u003cspan class=\"hljs-string\"\u003e'code-block'\u003c/span\u003e]]  \n  },\n  \u003cspan class=\"hljs-attr\"\u003etheme\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'snow'\u003c/span\u003e\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래와 같이 특정 언어 또는 모든 언어로 구성할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 선택적으로 hljs 구성\u003c/span\u003e\nhljs.\u003cspan class=\"hljs-title function_\"\u003econfigure\u003c/span\u003e({   \n    \u003cspan class=\"hljs-attr\"\u003elanguages\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'javascript'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'ruby'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'python'\u003c/span\u003e]\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 또는 모든 언어 강조\u003c/span\u003e\nhljs.\u003cspan class=\"hljs-title function_\"\u003ehighlightAll\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eplaceholder\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 옵션 키는 편집기가 비어 있을 때 표시할 자리 표시자 텍스트를 구성하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e다음과 같은 옵션을 사용하면\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e options = {\n  \u003cspan class=\"hljs-attr\"\u003eplaceholder\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'말해보세요!'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etheme\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'snow'\u003c/span\u003e\n};\n\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e quill = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#editor'\u003c/span\u003e, options);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음은 우리가 얻게 될 것입니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptHTMLRich-TextEditors_8.png\"\u003e\n\u003ch2\u003ereadOnly\u003c/h2\u003e\n\u003cp\u003e이 값은 에디터를 읽기 전용 모드로 초기화할지 여부를 나타냅니다. 기본값은 false입니다.\u003c/p\u003e\n\u003cp\u003e사용자가 더 이상 수정할 수 없게 하고 입력한 내용을 확인해야 하는 확인 페이지를 만들고 싶을 때 이 값은 정말 유용합니다. 이 경우 툴바를 false로 설정하고 싶을 수도 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e options = {\n  \u003cspan class=\"hljs-attr\"\u003emodules\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003etoolbar\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n  },\n  \u003cspan class=\"hljs-attr\"\u003ereadOnly\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etheme\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'snow'\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e quill = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#editor'\u003c/span\u003e, options);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e테마\u003c/h2\u003e\n\u003cp\u003e이 키는 전체 스타일링을 구성하는 데 사용할 키이며 곧 자세히 살펴볼 것입니다.\u003c/p\u003e\n\u003ch1\u003e모듈\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이전 섹션에서 툴바와 같은 몇 가지 미리 구축된 모듈을 이미 살펴보았습니다. 이 모듈은 확장되어 원본 모듈을 대체하거나 다시 등록할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 이를 통해 클립보드 모듈이 Quill과 외부 애플리케이션 간에 복사, 잘라내기 및 붙여넣기를 어떻게 처리할지 구성할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eClipboard\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e.\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'modules/clipboard'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDelta\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e.\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'delta'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePlainClipboard\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eClipboard\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econvert\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ehtml = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e html === \u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003econtainer\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einnerHTML\u003c/span\u003e = html;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e text = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003econtainer\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einnerText\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003econtainer\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einnerHTML\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDelta\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003einsert\u003c/span\u003e(text);\n  }\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eregister\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'modules/clipboard'\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003ePlainClipboard\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e quill = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eQuill\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#editor'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 때로는 (사실 대부분의 경우) 기존 모듈을 사용하거나 구성하는 것이 더 쉬울 수 있습니다. 위 예에서 기존 Clipboard의 addMatcher API가 더 적합합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e리치 텍스트 편집기에 대한 API가 무엇인지 궁금하신가요? 조금 더 자세히 설명해 드릴게요. 실제로 이게 Quill의 가장 멋진 부분이라고 생각해요.\u003c/p\u003e\n\u003ch1\u003e테마\u003c/h1\u003e\n\u003cp\u003e우리는 이미 여러 차례 이 키를 사용했어요. 사용할 테마 이름입니다. 내장된 옵션은 bubble 또는 snow입니다. 잘못된 값은 기본 최소 테마를 로드합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ebubble: 간단한 툴팁 기반 테마입니다.\u003c/li\u003e\n\u003cli\u003esnow: 깨끗하고 평평한 툴바 테마이며, 위에서 반복적으로 사용한 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e테마의 구체적인 스타일시트는 여전히 수동으로 포함해야 합니다. 더 많은 정보 및 추가 사용자 정의를 위해 테마를 확인해보세요!\u003c/p\u003e\n\u003ch1\u003eAPI 주도 설계\u003c/h1\u003e\n\u003cp\u003e자바스크립트와 HTML을 사용하여 간단한 리치 텍스트 편집기를 만드는 방법을 보여드렸습니다. 그러나 Quill에서 가장 독특한 요소 중 하나(제 개인적인 의견으로)는 API 주도 설계입니다.\u003c/p\u003e\n\u003cp\u003e대부분의 리치 텍스트 편집기는 사용자가 작성한 텍스트를 알지 못하며, 내용을 웹 개발자가 보는 렌즈로 보게 됩니다: DOM입니다. 이는 DOM이 불균형 트리로 구성된 노드로 이루어져 있지만 텍스트는 줄, 단어 및 문자로 이루어져 있기 때문에 임피던스 불일치를 초래합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문자가 측정 단위인 DOM API가 없습니다. 이 제한으로 대부분의 리치 텍스트 에디터는 \"이 범위에 어떤 텍스트가 있는가?\" 또는 \"커서가 굵은 텍스트에 있는가?\" 같은 간단한 질문에 대답할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e그에 반대로, API 주도 설계를 통해 Quill은 굵은 텍스트인지 확인하려면 \u003ccode\u003eb\u003c/code\u003e나 \u003ccode\u003estrong\u003c/code\u003e 노드 또는 글꼴 두께 스타일 속성을 찾는 DOM 탐색이 필요하지 않습니다.\u003c/p\u003e\n\u003cp\u003e할 일은 getFormat(5, 1) API를 호출하는 것 뿐입니다. 모든 핵심 API 호출은 임의의 인덱스와 길이로 액세스하거나 수정할 수 있습니다. 그리고 해당 이벤트 API는 직관적인 JSON 형식으로 변경 사항을 보고하며 HTML 구문 분석이나 DOM 트리 비교가 필요하지 않습니다.\u003c/p\u003e\n\u003cp\u003e그러므로 Quill은 나만의 리치 텍스트 에디터 솔루션을 설계할 때 더 많은 옵션과 자유를 제공하며 더 간단한 해결책으로 이어줍니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그거 오늘은 여기까지야!\u003c/p\u003e\n\u003cp\u003e리치 텍스트 편집기를 만들어서 부자가 되어보자(아마?)!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-JavascriptHTMLRich-TextEditors"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>