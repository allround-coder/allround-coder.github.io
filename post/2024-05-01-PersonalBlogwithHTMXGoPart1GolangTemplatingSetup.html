<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>개인 블로그를 HTMX + Go로 만들기1 - Golang 템플릿 설정 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="개인 블로그를 HTMX + Go로 만들기1 - Golang 템플릿 설정 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="개인 블로그를 HTMX + Go로 만들기1 - Golang 템플릿 설정 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup" data-gatsby-head="true"/><meta name="twitter:title" content="개인 블로그를 HTMX + Go로 만들기1 - Golang 템플릿 설정 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-01 23:15" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">개인 블로그를 HTMX + Go로 만들기1 - Golang 템플릿 설정</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="개인 블로그를 HTMX + Go로 만들기1 - Golang 템플릿 설정" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 1, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이 블로그 포스트는 내 개인 블로그에도 게시되어 있으며 여기에서 액세스할 수 있습니다.</p>
<h1>서문</h1>
<p>최근에 저는 HTMX와 Golang을 사용하여 제 개인 블로그를 처음부터 만들었다는 것을 발표하는 포스트를 작성했습니다. JavaScript 프레임워크를 완전히 생략했습니다. 해당 블로그 포스트는 여기에서 읽을 수 있습니다.</p>
<p>이것은 HTMX + Go 여정의 첫 번째이며, 제 개인 블로그를 위해 HTMX를 처음으로 설정하는 과정을 기록할 것입니다 (만약 이 기사를 Medium에서 읽는다면 여기를 방문할 수 있습니다).</p>
<div class="content-ad"></div>
<p>세부적인 튜토리얼처럼 프로세스를 상세히 다루지는 않겠습니다. 대신, 제가 무엇을 하고 있는지, 무엇이 저를 방해하는지, 그리고 어떻게 극복했는지(또는 우회했는지)를 문서화하는 저의 일지처럼 다룰 예정입니다. 그리고 그 과정 중에 발견한 다양한 잡다한 것들도 함께 공유할 거에요.</p>
<p>이 시리즈는 많은 기본적인 부분을 건너뛸 것이기 때문에 처음 시작하는 사람들이 함께하길 기대하지는 않습니다. 그래도 질문은 언제든 환영하니 아래 댓글에 망설이지 말고 바로 날 물어봐주세요!</p>
<h1>설정하기</h1>
<h1>템플릿 랜더러</h1>
<div class="content-ad"></div>
<p>우선 Labstack Echo를 사용하여 HTML 파일을 제공할 수 있는지 확인해야 합니다. 나는 개인적으로 HTTP 라우터로 선택한 것이기 때문에. Echo의 가이드에서 템플릿 섹션을 따르면 Echo의 Renderer 인터페이스를 구현하는 "템플릿 렌더러"를 제공해야 합니다.</p>
<p>그것을 위해, 다음과 같은 코드를 만들었습니다:</p>
<pre><code class="hljs language-js">type <span class="hljs-title class_">Template</span> struct {
    <span class="hljs-title class_">Templates</span> *template.<span class="hljs-property">Template</span>
}

func (t *<span class="hljs-title class_">Template</span>) <span class="hljs-title class_">Render</span>(w io.<span class="hljs-property">Writer</span>, name string, data interface{}, c echo.<span class="hljs-property">Context</span>) error {
    <span class="hljs-keyword">return</span> t.<span class="hljs-property">Templates</span>.<span class="hljs-title class_">ExecuteTemplate</span>(w, name, data)
}

func <span class="hljs-title class_">NewTemplateRenderer</span>(e *echo.<span class="hljs-property">Echo</span>, paths ...string) {
    tmpl := &#x26;template.<span class="hljs-property">Template</span>{}
    <span class="hljs-keyword">for</span> i := range paths {
        template.<span class="hljs-title class_">Must</span>(tmpl.<span class="hljs-title class_">ParseGlob</span>(paths[i]))
    }
    t := <span class="hljs-title function_">newTemplate</span>(tmpl)
    e.<span class="hljs-property">Renderer</span> = t
}

func <span class="hljs-title function_">newTemplate</span>(templates *template.<span class="hljs-property">Template</span>) echo.<span class="hljs-property">Renderer</span> {
    <span class="hljs-keyword">return</span> &#x26;<span class="hljs-title class_">Template</span>{
        <span class="hljs-title class_">Templates</span>: templates,
    }
}
</code></pre>
<p>이 템플릿 렌더러의 아이디어는 HTML 템플릿 파일을 넣은 경로를 나타내는 문자열의 가변 매개변수를 제공할 수 있다는 것입니다. 이것은 template.ParseGlob이 재귀적으로 템플릿 파일을 찾을 수 없기 때문에 필요합니다. 또한, html/template을 가져오지 말고 text/template을 가져와야 한다는 것을 잊지 마세요!</p>
<div class="content-ad"></div>
<h1>안녕, 세상아</h1>
<p>우리는 간단한 에코 서버를 만들고 간단한 HTML 파일을 제공해보면서 테스트할 수 있습니다. 먼저 public 경로에 새로운 index.html 파일을 생성하여 Hello World를 시작해 보겠습니다:</p>
<pre><code class="hljs language-js">{define <span class="hljs-string">"index"</span>}
&#x3C;!<span class="hljs-variable constant_">DOCTYPE</span> html>
&#x3C;html lang="en">
&#x3C;head>
    &#x3C;meta charset="UTF-8">
    &#x3C;meta name="viewport" content="width=device-width, initial-scale=1.0">
    &#x3C;title>Hello, World!&#x3C;/title>
&#x3C;/head>
&#x3C;body>
    &#x3C;p>Hello, World!&#x3C;/p>
&#x3C;/body>
&#x3C;/html>
{end}
</code></pre>
<p>이것은 그저 간단한 HTML 파일입니다. 그러나 HTML 파일을 감싸는 이중 중괄호({})에 주목해주세요. 이는 Go 템플릿 태그입니다. 위 예시에서는 단순히 나중에 Go 코드에서 직접 액세스할 수 있는 index라는 이름의 새로운 템플릿을 정의했습니다.</p>
<div class="content-ad"></div>
<p>이제 간단한 echo 서버를 만들어 봅시다:</p>
<pre><code class="hljs language-js">func <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    e := echo.<span class="hljs-title class_">New</span>()
    
    <span class="hljs-comment">// 약간의 미들웨어를 추가하여 housekeeping</span>
    e.<span class="hljs-title class_">Pre</span>(middleware.<span class="hljs-title class_">RemoveTrailingSlash</span>())
    e.<span class="hljs-title class_">Use</span>(middleware.<span class="hljs-title class_">Recover</span>())
    e.<span class="hljs-title class_">Use</span>(middleware.<span class="hljs-title class_">RateLimiter</span>(middleware.<span class="hljs-title class_">NewRateLimiterMemoryStore</span>(
        rate.<span class="hljs-title class_">Limit</span>(<span class="hljs-number">20</span>),
    )))

    <span class="hljs-comment">// 이것은 템플릿 렌더러를 초기화합니다.</span>
    template.<span class="hljs-title class_">NewTemplateRenderer</span>(e, <span class="hljs-string">"public/*.html"</span>)
    e.<span class="hljs-title function_">GET</span>(<span class="hljs-string">"/hello"</span>, <span class="hljs-title function_">func</span>(e echo.<span class="hljs-property">Context</span>) error {
        <span class="hljs-keyword">return</span> c.<span class="hljs-title class_">Render</span>(http.<span class="hljs-property">StatusOK</span>, <span class="hljs-string">"index"</span>, nil)
    })

    e.<span class="hljs-property">Logger</span>.<span class="hljs-title class_">Fatal</span>(e.<span class="hljs-title class_">Start</span>(<span class="hljs-string">":4040"</span>))
}
</code></pre>
<p>이 echo 서버는 포트 :4040에서 실행되며 public 디렉토리에 위치한 .html 파일을 렌더링합니다. 그리고 /hello라는 새로운 엔드포인트를 생성하여 index를 제공할 것입니다. 실행해 보면 아마도 이렇게 될 것입니다:</p>
<img src="/assets/img/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup_0.png">
<div class="content-ad"></div>
<h1>템플릿에 값 전달하기</h1>
<p>이제 템플릿에 동적 값들을 전달할 수 있는지 확인해봐야 해요. 결국 템플릿의 목적이죠. 먼저 index.html 코드를 약간 수정해야 해요:</p>
<pre><code class="hljs language-js">&#x3C;p><span class="hljs-title class_">Hello</span>, <span class="hljs-title class_">World</span>!&#x3C;/p>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Greetings, {.Name}!<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>
</code></pre>
<p>다시 한 번 중괄호를 두 개 사용했네요. 이 예제에서는 html 파일로 Name이라는 값을 전달하려고 합니다. 그러면 서버도 조금 수정해야겠죠?</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">e.<span class="hljs-title function_">GET</span>(<span class="hljs-string">"/hello"</span>, <span class="hljs-title function_">func</span>(e echo.<span class="hljs-property">Context</span>) error {
    res := map[string]interface{}{
        <span class="hljs-string">"Name"</span>: <span class="hljs-string">"Wyndham"</span>,
    }
    <span class="hljs-keyword">return</span> c.<span class="hljs-title class_">Render</span>(http.<span class="hljs-property">StatusOK</span>, <span class="hljs-string">"index"</span>, res)
})
</code></pre>
<p>이렇게 하면 렌더러가 res의 값을 루트 값으로 취하고 Name 키를 가진 자식 값을 찾습니다. 그럼 다음과 같이 결과를 렌더링해야 합니다:</p>
<img src="/assets/img/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup_1.png">
<h1>중첩 템플릿 및 템플릿 간 값 전달하기</h1>
<div class="content-ad"></div>
<p>이제 HTMX를 다루기 전에 마지막으로 확인할 사항은 index 템플릿 내에 다른 템플릿을 중첩할 수 있는지입니다. 이를 위해 name_card.html이라는 간단한 템플릿 파일을 만들었습니다:</p>
<pre><code class="hljs language-js">{define <span class="hljs-string">"name_card"</span>}
&#x3C;div>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>사용자 개인 정보:<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ol</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span>></span>이름: {.Name}<span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span>></span>전화번호: {.Phone}<span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">li</span>></span>이메일: {.Email}<span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ol</span>></span></span>
&#x3C;/div>
{end}
</code></pre>
<p>그런 다음 index.html을 약간 수정해야 합니다. 먼저 인사 문구를 삭제한 다음 다음을 추가하십시오:</p>
<pre><code class="hljs language-js">&#x3C;p><span class="hljs-title class_">Hello</span>, <span class="hljs-title class_">World</span>!&#x3C;/p>
&#x3C;!-- 이 줄 삭제 &#x3C;p><span class="hljs-title class_">Greetings</span>, {.<span class="hljs-property">Name</span>}!&#x3C;/p> -->
{template <span class="hljs-string">"name_card"</span> .}
</code></pre>
<div class="content-ad"></div>
<p>그러면 우리는 다시 한번 서버를 수정해야 합니다:</p>
<pre><code class="hljs language-js">e.<span class="hljs-title function_">GET</span>(<span class="hljs-string">"/hello"</span>, <span class="hljs-title function_">func</span>(e echo.<span class="hljs-property">Context</span>) error {
    res := map[string]interface{}{
        <span class="hljs-string">"Name"</span>: <span class="hljs-string">"Wyndham"</span>,
        <span class="hljs-string">"Phone"</span>: <span class="hljs-string">"8888888"</span>,
        <span class="hljs-string">"Email"</span>: <span class="hljs-string">"skyscraper@gmail.com"</span>,
    }
    <span class="hljs-keyword">return</span> c.<span class="hljs-title class_">Render</span>(http.<span class="hljs-property">StatusOK</span>, <span class="hljs-string">"index"</span>, res)
})
</code></pre>
<p>이제 여기서 맞다면, 이렇게 개인 정보를 렌더링할 수 있어야 합니다. 여기서 로직은, Name, Phone, Email을 포함한 3쌍의 키-값을 가진 인터페이스 맵을 전달한다는 것입니다.</p>
<p>그리고 우리는 중괄호를 사용하여 name_card에서 해당 값을 액세스합니다. 그러나 name_card 템플릿이 값을 받도록 하려면 index.html 내에서 template "name_card" .의 내부에서 추가 . 를 통해 res 값을 전달해야 합니다.</p>
<div class="content-ad"></div>
<p>그리고 당연히:</p>
<img src="/assets/img/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup_2.png">
<p>우리는 여러 템플릿 파일을 중첩시키고 변수를 전달하는 데 성공했습니다! 이제 템플릿 설정이 끝났으니, HTMX에 대해서 조금 더 살펴봅시다.</p>
<h1>HTMX를 사용하여 연락처 정보 공개하기</h1>
<div class="content-ad"></div>
<p>간단한 뷰를 만들려고 해요. 이름과 그 옆에 연락처 정보를 공개하기 위한 버튼이 있는 목록을 만들 거예요. 이를 위해서 먼저 이 프로젝트에 HTMX를 추가해야 해요. 일단 CDN을 통해 추가할 거에요:</p>
<pre><code class="hljs language-js">&#x3C;head>
    ...
    &#x3C;script src=<span class="hljs-string">"https://unpkg.com/htmx.org@1.9.5"</span> integrity=<span class="hljs-string">"sha384-xcuj3WpfgjlKF+FXhSQFQ0ZNr39ln+hwjN3npfM9VBnUskLolQAcN80McRIVOPuO"</span> crossorigin=<span class="hljs-string">"anonymous"</span>>&#x3C;/script>
&#x3C;/head>
</code></pre>
<p>위 코드를 통해 HTMX를 CDN을 통해 추가할 거예요. 이제 사용자 정보를 직접 공개하지 않도록 index.html을 다시 수정해야 해요:</p>
<pre><code class="hljs language-js">&#x3C;p><span class="hljs-title class_">Hello</span>, <span class="hljs-title class_">World</span>!&#x3C;/p>
&#x3C;!-- 이 줄을 삭제하세요 {template <span class="hljs-string">"name_card"</span> .} -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user-info"</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{.Name}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">hx-get</span>=<span class="hljs-string">"/get-info"</span> <span class="hljs-attr">hx-target</span>=<span class="hljs-string">"#user-info"</span> <span class="hljs-attr">hx-swap</span>=<span class="hljs-string">"innerHTML"</span>></span>정보 공개<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
</code></pre>
<div class="content-ad"></div>
<p>이렇게 하면 UI가 이름 부분만 표시되도록 설정되며, /get-info 엔드포인트를 호출할 버튼을 설정하고 #user-info 요소를 대상으로 하여 대상 요소의 내부 부분을 바꿀 것입니다 (기본적으로 <code>div</code>를 그대로 두고 <code>div</code> 내부의 모든 것을 변경합니다).</p>
<p>알겠어요. 많은 용어가 있네요. 여기서는 이 내용을 더 잘 설명한 htmx 웹페이지에서 확인할 수 있습니다. 이제 /get-info 경로를 처리하는 새 엔드포인트 핸들러를 생성하여 계속 진행해 보겠습니다:</p>
<pre><code class="hljs language-js">e.<span class="hljs-title function_">GET</span>(<span class="hljs-string">"/get-info"</span>, <span class="hljs-title function_">func</span>(c echo.<span class="hljs-property">Context</span>) error {
    res := map[string]interface{}{
        <span class="hljs-string">"Name"</span>: <span class="hljs-string">"Wyndham"</span>,
        <span class="hljs-string">"Phone"</span>: <span class="hljs-string">"8888888"</span>,
        <span class="hljs-string">"Email"</span>: <span class="hljs-string">"skyscraper@gmail.com"</span>,
    }
    <span class="hljs-keyword">return</span> c.<span class="hljs-title class_">Render</span>(http.<span class="hljs-property">StatusOK</span>, <span class="hljs-string">"name_card"</span>, res)
})
</code></pre>
<p>이는 거의 /hello와 동일하지만 두 가지 주요 차이점이 있습니다:</p>
<div class="content-ad"></div>
<ul>
<li>경로를 명확하게 /get-info로 변경해주세요.</li>
<li>대상 템플릿을 name_card로 변경해주세요.</li>
</ul>
<p>하지만! name_card는 유효한 HTML 파일이 아니었나요? doctype도 없고 헤더도 없죠. 맞아요, 맞습니다. 하지만 이것은 HTMX가 동작하는 방식입니다. 전체 페이지를 교체하지 않고 우리가 index.html에서 지정한 user-info 요소만 교체할 거예요.</p>
<p>그럼, 더 이상 말을 더하지않고 서버를 실행해서 무슨 일이 일어났는지 봅시다:</p>
<p>와우! 제작품이 동작합니다! 이제 HTMX가 Go 템플릿과 잘 동작한다는 것을 알게 되었으니, 드디어 블로깅 사이트를 작업할 수 있겠네요. 그러나 불행히도 이 기사에서는 다루지 않을 거예요. 하지만 곧 돌아올 테니까, 그렇게 길지 않겠죠!</p>
<div class="content-ad"></div>
<h1>결론</h1>
<p>이 블로그를 읽어 주셔서 감사합니다. 여기서 중요한 점은 Go 템플릿을 사용하기 매우 유연하며, 이 작은 범위에서 HTMX와도 잘 작동한다는 것입니다. 다음 블로그에서는 기본 CRUD를 생성하여 DB에 기사를 저장하고 브라우저에서 액세스할 것입니다.</p>
<p>조금 스포일러를 하자면: 거기에 많이 HTMX를 사용하지는 않을 것이고, 그 다음 시점에도 그 후에도 마찬가지입니다. 게시 물 웹사이트에서는 HTMX가 많이 필요하지 않다는 것이 확인되었습니다. 놀랍죠. 그러나 페이지네이션, 검색, 실시간 Markdown 렌더러를 만드는 부분에 도달하면 HTMX를 적극 활용할 것입니다.</p>
<p>그러니 기대해 주세요! 읽어 주셔서 감사합니다!</p>
<div class="content-ad"></div>
<p>수정되었습니다! 두 번째 부분이 나왔어요! 다음 링크에서 읽을 수 있어요:</p>
<p><a href="https://medium.com/gravel-engineering/personal-blog-with-htmx-go-part-2-integrating-tailwindcss-412ebc4dcc97" rel="nofollow" target="_blank">https://medium.com/gravel-engineering/personal-blog-with-htmx-go-part-2-integrating-tailwindcss-412ebc4dcc97</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"개인 블로그를 HTMX + Go로 만들기1 - Golang 템플릿 설정","description":"","date":"2024-05-01 23:15","slug":"2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup","content":"\n\n이 블로그 포스트는 내 개인 블로그에도 게시되어 있으며 여기에서 액세스할 수 있습니다.\n\n# 서문\n\n최근에 저는 HTMX와 Golang을 사용하여 제 개인 블로그를 처음부터 만들었다는 것을 발표하는 포스트를 작성했습니다. JavaScript 프레임워크를 완전히 생략했습니다. 해당 블로그 포스트는 여기에서 읽을 수 있습니다.\n\n이것은 HTMX + Go 여정의 첫 번째이며, 제 개인 블로그를 위해 HTMX를 처음으로 설정하는 과정을 기록할 것입니다 (만약 이 기사를 Medium에서 읽는다면 여기를 방문할 수 있습니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세부적인 튜토리얼처럼 프로세스를 상세히 다루지는 않겠습니다. 대신, 제가 무엇을 하고 있는지, 무엇이 저를 방해하는지, 그리고 어떻게 극복했는지(또는 우회했는지)를 문서화하는 저의 일지처럼 다룰 예정입니다. 그리고 그 과정 중에 발견한 다양한 잡다한 것들도 함께 공유할 거에요.\n\n이 시리즈는 많은 기본적인 부분을 건너뛸 것이기 때문에 처음 시작하는 사람들이 함께하길 기대하지는 않습니다. 그래도 질문은 언제든 환영하니 아래 댓글에 망설이지 말고 바로 날 물어봐주세요!\n\n# 설정하기\n\n# 템플릿 랜더러\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선 Labstack Echo를 사용하여 HTML 파일을 제공할 수 있는지 확인해야 합니다. 나는 개인적으로 HTTP 라우터로 선택한 것이기 때문에. Echo의 가이드에서 템플릿 섹션을 따르면 Echo의 Renderer 인터페이스를 구현하는 \"템플릿 렌더러\"를 제공해야 합니다.\n\n그것을 위해, 다음과 같은 코드를 만들었습니다:\n\n```js\ntype Template struct {\n    Templates *template.Template\n}\n\nfunc (t *Template) Render(w io.Writer, name string, data interface{}, c echo.Context) error {\n    return t.Templates.ExecuteTemplate(w, name, data)\n}\n\nfunc NewTemplateRenderer(e *echo.Echo, paths ...string) {\n    tmpl := \u0026template.Template{}\n    for i := range paths {\n        template.Must(tmpl.ParseGlob(paths[i]))\n    }\n    t := newTemplate(tmpl)\n    e.Renderer = t\n}\n\nfunc newTemplate(templates *template.Template) echo.Renderer {\n    return \u0026Template{\n        Templates: templates,\n    }\n}\n```\n\n이 템플릿 렌더러의 아이디어는 HTML 템플릿 파일을 넣은 경로를 나타내는 문자열의 가변 매개변수를 제공할 수 있다는 것입니다. 이것은 template.ParseGlob이 재귀적으로 템플릿 파일을 찾을 수 없기 때문에 필요합니다. 또한, html/template을 가져오지 말고 text/template을 가져와야 한다는 것을 잊지 마세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 안녕, 세상아\n\n우리는 간단한 에코 서버를 만들고 간단한 HTML 파일을 제공해보면서 테스트할 수 있습니다. 먼저 public 경로에 새로운 index.html 파일을 생성하여 Hello World를 시작해 보겠습니다:\n\n```js\n{define \"index\"}\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003ctitle\u003eHello, World!\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n    \u003cp\u003eHello, World!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n{end}\n```\n\n이것은 그저 간단한 HTML 파일입니다. 그러나 HTML 파일을 감싸는 이중 중괄호({})에 주목해주세요. 이는 Go 템플릿 태그입니다. 위 예시에서는 단순히 나중에 Go 코드에서 직접 액세스할 수 있는 index라는 이름의 새로운 템플릿을 정의했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 간단한 echo 서버를 만들어 봅시다:\n\n```js\nfunc main() {\n    e := echo.New()\n    \n    // 약간의 미들웨어를 추가하여 housekeeping\n    e.Pre(middleware.RemoveTrailingSlash())\n    e.Use(middleware.Recover())\n    e.Use(middleware.RateLimiter(middleware.NewRateLimiterMemoryStore(\n        rate.Limit(20),\n    )))\n\n    // 이것은 템플릿 렌더러를 초기화합니다.\n    template.NewTemplateRenderer(e, \"public/*.html\")\n    e.GET(\"/hello\", func(e echo.Context) error {\n        return c.Render(http.StatusOK, \"index\", nil)\n    })\n\n    e.Logger.Fatal(e.Start(\":4040\"))\n}\n```\n\n이 echo 서버는 포트 :4040에서 실행되며 public 디렉토리에 위치한 .html 파일을 렌더링합니다. 그리고 /hello라는 새로운 엔드포인트를 생성하여 index를 제공할 것입니다. 실행해 보면 아마도 이렇게 될 것입니다:\n\n\u003cimg src=\"/assets/img/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup_0.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 템플릿에 값 전달하기\n\n이제 템플릿에 동적 값들을 전달할 수 있는지 확인해봐야 해요. 결국 템플릿의 목적이죠. 먼저 index.html 코드를 약간 수정해야 해요:\n\n```js\n\u003cp\u003eHello, World!\u003c/p\u003e\n\u003cp\u003eGreetings, {.Name}!\u003c/p\u003e\n```\n\n다시 한 번 중괄호를 두 개 사용했네요. 이 예제에서는 html 파일로 Name이라는 값을 전달하려고 합니다. 그러면 서버도 조금 수정해야겠죠?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ne.GET(\"/hello\", func(e echo.Context) error {\n    res := map[string]interface{}{\n        \"Name\": \"Wyndham\",\n    }\n    return c.Render(http.StatusOK, \"index\", res)\n})\n```\n\n이렇게 하면 렌더러가 res의 값을 루트 값으로 취하고 Name 키를 가진 자식 값을 찾습니다. 그럼 다음과 같이 결과를 렌더링해야 합니다:\n\n\u003cimg src=\"/assets/img/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup_1.png\" /\u003e\n\n# 중첩 템플릿 및 템플릿 간 값 전달하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 HTMX를 다루기 전에 마지막으로 확인할 사항은 index 템플릿 내에 다른 템플릿을 중첩할 수 있는지입니다. 이를 위해 name_card.html이라는 간단한 템플릿 파일을 만들었습니다:\n\n```js\n{define \"name_card\"}\n\u003cdiv\u003e\n    \u003cp\u003e사용자 개인 정보:\u003c/p\u003e\n    \u003col\u003e\n        \u003cli\u003e이름: {.Name}\u003c/li\u003e\n        \u003cli\u003e전화번호: {.Phone}\u003c/li\u003e\n        \u003cli\u003e이메일: {.Email}\u003c/li\u003e\n    \u003c/ol\u003e\n\u003c/div\u003e\n{end}\n```\n\n그런 다음 index.html을 약간 수정해야 합니다. 먼저 인사 문구를 삭제한 다음 다음을 추가하십시오:\n\n```js\n\u003cp\u003eHello, World!\u003c/p\u003e\n\u003c!-- 이 줄 삭제 \u003cp\u003eGreetings, {.Name}!\u003c/p\u003e --\u003e\n{template \"name_card\" .}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면 우리는 다시 한번 서버를 수정해야 합니다:\n\n```js\ne.GET(\"/hello\", func(e echo.Context) error {\n    res := map[string]interface{}{\n        \"Name\": \"Wyndham\",\n        \"Phone\": \"8888888\",\n        \"Email\": \"skyscraper@gmail.com\",\n    }\n    return c.Render(http.StatusOK, \"index\", res)\n})\n```\n\n이제 여기서 맞다면, 이렇게 개인 정보를 렌더링할 수 있어야 합니다. 여기서 로직은, Name, Phone, Email을 포함한 3쌍의 키-값을 가진 인터페이스 맵을 전달한다는 것입니다.\n\n그리고 우리는 중괄호를 사용하여 name_card에서 해당 값을 액세스합니다. 그러나 name_card 템플릿이 값을 받도록 하려면 index.html 내에서 template \"name_card\" .의 내부에서 추가 . 를 통해 res 값을 전달해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 당연히:\n\n\u003cimg src=\"/assets/img/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup_2.png\" /\u003e\n\n우리는 여러 템플릿 파일을 중첩시키고 변수를 전달하는 데 성공했습니다! 이제 템플릿 설정이 끝났으니, HTMX에 대해서 조금 더 살펴봅시다.\n\n# HTMX를 사용하여 연락처 정보 공개하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 뷰를 만들려고 해요. 이름과 그 옆에 연락처 정보를 공개하기 위한 버튼이 있는 목록을 만들 거예요. 이를 위해서 먼저 이 프로젝트에 HTMX를 추가해야 해요. 일단 CDN을 통해 추가할 거에요:\n\n```js\n\u003chead\u003e\n    ...\n    \u003cscript src=\"https://unpkg.com/htmx.org@1.9.5\" integrity=\"sha384-xcuj3WpfgjlKF+FXhSQFQ0ZNr39ln+hwjN3npfM9VBnUskLolQAcN80McRIVOPuO\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e\n\u003c/head\u003e\n```\n\n위 코드를 통해 HTMX를 CDN을 통해 추가할 거예요. 이제 사용자 정보를 직접 공개하지 않도록 index.html을 다시 수정해야 해요:\n\n```js\n\u003cp\u003eHello, World!\u003c/p\u003e\n\u003c!-- 이 줄을 삭제하세요 {template \"name_card\" .} --\u003e\n\u003cdiv id=\"user-info\"\u003e\n    \u003cp\u003e{.Name}\u003c/p\u003e\n    \u003cbutton hx-get=\"/get-info\" hx-target=\"#user-info\" hx-swap=\"innerHTML\"\u003e정보 공개\u003c/button\u003e\n\u003c/div\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 UI가 이름 부분만 표시되도록 설정되며, /get-info 엔드포인트를 호출할 버튼을 설정하고 #user-info 요소를 대상으로 하여 대상 요소의 내부 부분을 바꿀 것입니다 (기본적으로 `div`를 그대로 두고 `div` 내부의 모든 것을 변경합니다).\n\n알겠어요. 많은 용어가 있네요. 여기서는 이 내용을 더 잘 설명한 htmx 웹페이지에서 확인할 수 있습니다. 이제 /get-info 경로를 처리하는 새 엔드포인트 핸들러를 생성하여 계속 진행해 보겠습니다:\n\n```js\ne.GET(\"/get-info\", func(c echo.Context) error {\n    res := map[string]interface{}{\n        \"Name\": \"Wyndham\",\n        \"Phone\": \"8888888\",\n        \"Email\": \"skyscraper@gmail.com\",\n    }\n    return c.Render(http.StatusOK, \"name_card\", res)\n})\n```\n\n이는 거의 /hello와 동일하지만 두 가지 주요 차이점이 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 경로를 명확하게 /get-info로 변경해주세요.\n- 대상 템플릿을 name_card로 변경해주세요.\n\n하지만! name_card는 유효한 HTML 파일이 아니었나요? doctype도 없고 헤더도 없죠. 맞아요, 맞습니다. 하지만 이것은 HTMX가 동작하는 방식입니다. 전체 페이지를 교체하지 않고 우리가 index.html에서 지정한 user-info 요소만 교체할 거예요.\n\n그럼, 더 이상 말을 더하지않고 서버를 실행해서 무슨 일이 일어났는지 봅시다:\n\n와우! 제작품이 동작합니다! 이제 HTMX가 Go 템플릿과 잘 동작한다는 것을 알게 되었으니, 드디어 블로깅 사이트를 작업할 수 있겠네요. 그러나 불행히도 이 기사에서는 다루지 않을 거예요. 하지만 곧 돌아올 테니까, 그렇게 길지 않겠죠!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 블로그를 읽어 주셔서 감사합니다. 여기서 중요한 점은 Go 템플릿을 사용하기 매우 유연하며, 이 작은 범위에서 HTMX와도 잘 작동한다는 것입니다. 다음 블로그에서는 기본 CRUD를 생성하여 DB에 기사를 저장하고 브라우저에서 액세스할 것입니다.\n\n조금 스포일러를 하자면: 거기에 많이 HTMX를 사용하지는 않을 것이고, 그 다음 시점에도 그 후에도 마찬가지입니다. 게시 물 웹사이트에서는 HTMX가 많이 필요하지 않다는 것이 확인되었습니다. 놀랍죠. 그러나 페이지네이션, 검색, 실시간 Markdown 렌더러를 만드는 부분에 도달하면 HTMX를 적극 활용할 것입니다.\n\n그러니 기대해 주세요! 읽어 주셔서 감사합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수정되었습니다! 두 번째 부분이 나왔어요! 다음 링크에서 읽을 수 있어요:\n\n[https://medium.com/gravel-engineering/personal-blog-with-htmx-go-part-2-integrating-tailwindcss-412ebc4dcc97](https://medium.com/gravel-engineering/personal-blog-with-htmx-go-part-2-integrating-tailwindcss-412ebc4dcc97)","ogImage":{"url":"/assets/img/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup_0.png"},"coverImage":"/assets/img/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이 블로그 포스트는 내 개인 블로그에도 게시되어 있으며 여기에서 액세스할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e서문\u003c/h1\u003e\n\u003cp\u003e최근에 저는 HTMX와 Golang을 사용하여 제 개인 블로그를 처음부터 만들었다는 것을 발표하는 포스트를 작성했습니다. JavaScript 프레임워크를 완전히 생략했습니다. 해당 블로그 포스트는 여기에서 읽을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이것은 HTMX + Go 여정의 첫 번째이며, 제 개인 블로그를 위해 HTMX를 처음으로 설정하는 과정을 기록할 것입니다 (만약 이 기사를 Medium에서 읽는다면 여기를 방문할 수 있습니다).\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e세부적인 튜토리얼처럼 프로세스를 상세히 다루지는 않겠습니다. 대신, 제가 무엇을 하고 있는지, 무엇이 저를 방해하는지, 그리고 어떻게 극복했는지(또는 우회했는지)를 문서화하는 저의 일지처럼 다룰 예정입니다. 그리고 그 과정 중에 발견한 다양한 잡다한 것들도 함께 공유할 거에요.\u003c/p\u003e\n\u003cp\u003e이 시리즈는 많은 기본적인 부분을 건너뛸 것이기 때문에 처음 시작하는 사람들이 함께하길 기대하지는 않습니다. 그래도 질문은 언제든 환영하니 아래 댓글에 망설이지 말고 바로 날 물어봐주세요!\u003c/p\u003e\n\u003ch1\u003e설정하기\u003c/h1\u003e\n\u003ch1\u003e템플릿 랜더러\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우선 Labstack Echo를 사용하여 HTML 파일을 제공할 수 있는지 확인해야 합니다. 나는 개인적으로 HTTP 라우터로 선택한 것이기 때문에. Echo의 가이드에서 템플릿 섹션을 따르면 Echo의 Renderer 인터페이스를 구현하는 \"템플릿 렌더러\"를 제공해야 합니다.\u003c/p\u003e\n\u003cp\u003e그것을 위해, 다음과 같은 코드를 만들었습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype \u003cspan class=\"hljs-title class_\"\u003eTemplate\u003c/span\u003e struct {\n    \u003cspan class=\"hljs-title class_\"\u003eTemplates\u003c/span\u003e *template.\u003cspan class=\"hljs-property\"\u003eTemplate\u003c/span\u003e\n}\n\nfunc (t *\u003cspan class=\"hljs-title class_\"\u003eTemplate\u003c/span\u003e) \u003cspan class=\"hljs-title class_\"\u003eRender\u003c/span\u003e(w io.\u003cspan class=\"hljs-property\"\u003eWriter\u003c/span\u003e, name string, data interface{}, c echo.\u003cspan class=\"hljs-property\"\u003eContext\u003c/span\u003e) error {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e t.\u003cspan class=\"hljs-property\"\u003eTemplates\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eExecuteTemplate\u003c/span\u003e(w, name, data)\n}\n\nfunc \u003cspan class=\"hljs-title class_\"\u003eNewTemplateRenderer\u003c/span\u003e(e *echo.\u003cspan class=\"hljs-property\"\u003eEcho\u003c/span\u003e, paths ...string) {\n    tmpl := \u0026#x26;template.\u003cspan class=\"hljs-property\"\u003eTemplate\u003c/span\u003e{}\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i := range paths {\n        template.\u003cspan class=\"hljs-title class_\"\u003eMust\u003c/span\u003e(tmpl.\u003cspan class=\"hljs-title class_\"\u003eParseGlob\u003c/span\u003e(paths[i]))\n    }\n    t := \u003cspan class=\"hljs-title function_\"\u003enewTemplate\u003c/span\u003e(tmpl)\n    e.\u003cspan class=\"hljs-property\"\u003eRenderer\u003c/span\u003e = t\n}\n\nfunc \u003cspan class=\"hljs-title function_\"\u003enewTemplate\u003c/span\u003e(templates *template.\u003cspan class=\"hljs-property\"\u003eTemplate\u003c/span\u003e) echo.\u003cspan class=\"hljs-property\"\u003eRenderer\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u0026#x26;\u003cspan class=\"hljs-title class_\"\u003eTemplate\u003c/span\u003e{\n        \u003cspan class=\"hljs-title class_\"\u003eTemplates\u003c/span\u003e: templates,\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 템플릿 렌더러의 아이디어는 HTML 템플릿 파일을 넣은 경로를 나타내는 문자열의 가변 매개변수를 제공할 수 있다는 것입니다. 이것은 template.ParseGlob이 재귀적으로 템플릿 파일을 찾을 수 없기 때문에 필요합니다. 또한, html/template을 가져오지 말고 text/template을 가져와야 한다는 것을 잊지 마세요!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e안녕, 세상아\u003c/h1\u003e\n\u003cp\u003e우리는 간단한 에코 서버를 만들고 간단한 HTML 파일을 제공해보면서 테스트할 수 있습니다. 먼저 public 경로에 새로운 index.html 파일을 생성하여 Hello World를 시작해 보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{define \u003cspan class=\"hljs-string\"\u003e\"index\"\u003c/span\u003e}\n\u0026#x3C;!\u003cspan class=\"hljs-variable constant_\"\u003eDOCTYPE\u003c/span\u003e html\u003e\n\u0026#x3C;html lang=\"en\"\u003e\n\u0026#x3C;head\u003e\n    \u0026#x3C;meta charset=\"UTF-8\"\u003e\n    \u0026#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u0026#x3C;title\u003eHello, World!\u0026#x3C;/title\u003e\n\u0026#x3C;/head\u003e\n\u0026#x3C;body\u003e\n    \u0026#x3C;p\u003eHello, World!\u0026#x3C;/p\u003e\n\u0026#x3C;/body\u003e\n\u0026#x3C;/html\u003e\n{end}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 그저 간단한 HTML 파일입니다. 그러나 HTML 파일을 감싸는 이중 중괄호({})에 주목해주세요. 이는 Go 템플릿 태그입니다. 위 예시에서는 단순히 나중에 Go 코드에서 직접 액세스할 수 있는 index라는 이름의 새로운 템플릿을 정의했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 간단한 echo 서버를 만들어 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efunc \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    e := echo.\u003cspan class=\"hljs-title class_\"\u003eNew\u003c/span\u003e()\n    \n    \u003cspan class=\"hljs-comment\"\u003e// 약간의 미들웨어를 추가하여 housekeeping\u003c/span\u003e\n    e.\u003cspan class=\"hljs-title class_\"\u003ePre\u003c/span\u003e(middleware.\u003cspan class=\"hljs-title class_\"\u003eRemoveTrailingSlash\u003c/span\u003e())\n    e.\u003cspan class=\"hljs-title class_\"\u003eUse\u003c/span\u003e(middleware.\u003cspan class=\"hljs-title class_\"\u003eRecover\u003c/span\u003e())\n    e.\u003cspan class=\"hljs-title class_\"\u003eUse\u003c/span\u003e(middleware.\u003cspan class=\"hljs-title class_\"\u003eRateLimiter\u003c/span\u003e(middleware.\u003cspan class=\"hljs-title class_\"\u003eNewRateLimiterMemoryStore\u003c/span\u003e(\n        rate.\u003cspan class=\"hljs-title class_\"\u003eLimit\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e),\n    )))\n\n    \u003cspan class=\"hljs-comment\"\u003e// 이것은 템플릿 렌더러를 초기화합니다.\u003c/span\u003e\n    template.\u003cspan class=\"hljs-title class_\"\u003eNewTemplateRenderer\u003c/span\u003e(e, \u003cspan class=\"hljs-string\"\u003e\"public/*.html\"\u003c/span\u003e)\n    e.\u003cspan class=\"hljs-title function_\"\u003eGET\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/hello\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e(e echo.\u003cspan class=\"hljs-property\"\u003eContext\u003c/span\u003e) error {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e c.\u003cspan class=\"hljs-title class_\"\u003eRender\u003c/span\u003e(http.\u003cspan class=\"hljs-property\"\u003eStatusOK\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"index\"\u003c/span\u003e, nil)\n    })\n\n    e.\u003cspan class=\"hljs-property\"\u003eLogger\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eFatal\u003c/span\u003e(e.\u003cspan class=\"hljs-title class_\"\u003eStart\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\":4040\"\u003c/span\u003e))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 echo 서버는 포트 :4040에서 실행되며 public 디렉토리에 위치한 .html 파일을 렌더링합니다. 그리고 /hello라는 새로운 엔드포인트를 생성하여 index를 제공할 것입니다. 실행해 보면 아마도 이렇게 될 것입니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup_0.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e템플릿에 값 전달하기\u003c/h1\u003e\n\u003cp\u003e이제 템플릿에 동적 값들을 전달할 수 있는지 확인해봐야 해요. 결국 템플릿의 목적이죠. 먼저 index.html 코드를 약간 수정해야 해요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;p\u003e\u003cspan class=\"hljs-title class_\"\u003eHello\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eWorld\u003c/span\u003e!\u0026#x3C;/p\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003eGreetings, {.Name}!\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다시 한 번 중괄호를 두 개 사용했네요. 이 예제에서는 html 파일로 Name이라는 값을 전달하려고 합니다. 그러면 서버도 조금 수정해야겠죠?\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ee.\u003cspan class=\"hljs-title function_\"\u003eGET\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/hello\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e(e echo.\u003cspan class=\"hljs-property\"\u003eContext\u003c/span\u003e) error {\n    res := map[string]interface{}{\n        \u003cspan class=\"hljs-string\"\u003e\"Name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Wyndham\"\u003c/span\u003e,\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e c.\u003cspan class=\"hljs-title class_\"\u003eRender\u003c/span\u003e(http.\u003cspan class=\"hljs-property\"\u003eStatusOK\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"index\"\u003c/span\u003e, res)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 렌더러가 res의 값을 루트 값으로 취하고 Name 키를 가진 자식 값을 찾습니다. 그럼 다음과 같이 결과를 렌더링해야 합니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup_1.png\"\u003e\n\u003ch1\u003e중첩 템플릿 및 템플릿 간 값 전달하기\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 HTMX를 다루기 전에 마지막으로 확인할 사항은 index 템플릿 내에 다른 템플릿을 중첩할 수 있는지입니다. 이를 위해 name_card.html이라는 간단한 템플릿 파일을 만들었습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{define \u003cspan class=\"hljs-string\"\u003e\"name_card\"\u003c/span\u003e}\n\u0026#x3C;div\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e사용자 개인 정보:\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eol\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e이름: {.Name}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e전화번호: {.Phone}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e이메일: {.Email}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eol\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/div\u003e\n{end}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 index.html을 약간 수정해야 합니다. 먼저 인사 문구를 삭제한 다음 다음을 추가하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;p\u003e\u003cspan class=\"hljs-title class_\"\u003eHello\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eWorld\u003c/span\u003e!\u0026#x3C;/p\u003e\n\u0026#x3C;!-- 이 줄 삭제 \u0026#x3C;p\u003e\u003cspan class=\"hljs-title class_\"\u003eGreetings\u003c/span\u003e, {.\u003cspan class=\"hljs-property\"\u003eName\u003c/span\u003e}!\u0026#x3C;/p\u003e --\u003e\n{template \u003cspan class=\"hljs-string\"\u003e\"name_card\"\u003c/span\u003e .}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그러면 우리는 다시 한번 서버를 수정해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ee.\u003cspan class=\"hljs-title function_\"\u003eGET\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/hello\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e(e echo.\u003cspan class=\"hljs-property\"\u003eContext\u003c/span\u003e) error {\n    res := map[string]interface{}{\n        \u003cspan class=\"hljs-string\"\u003e\"Name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Wyndham\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"Phone\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"8888888\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"Email\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"skyscraper@gmail.com\"\u003c/span\u003e,\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e c.\u003cspan class=\"hljs-title class_\"\u003eRender\u003c/span\u003e(http.\u003cspan class=\"hljs-property\"\u003eStatusOK\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"index\"\u003c/span\u003e, res)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 여기서 맞다면, 이렇게 개인 정보를 렌더링할 수 있어야 합니다. 여기서 로직은, Name, Phone, Email을 포함한 3쌍의 키-값을 가진 인터페이스 맵을 전달한다는 것입니다.\u003c/p\u003e\n\u003cp\u003e그리고 우리는 중괄호를 사용하여 name_card에서 해당 값을 액세스합니다. 그러나 name_card 템플릿이 값을 받도록 하려면 index.html 내에서 template \"name_card\" .의 내부에서 추가 . 를 통해 res 값을 전달해야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그리고 당연히:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup_2.png\"\u003e\n\u003cp\u003e우리는 여러 템플릿 파일을 중첩시키고 변수를 전달하는 데 성공했습니다! 이제 템플릿 설정이 끝났으니, HTMX에 대해서 조금 더 살펴봅시다.\u003c/p\u003e\n\u003ch1\u003eHTMX를 사용하여 연락처 정보 공개하기\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e간단한 뷰를 만들려고 해요. 이름과 그 옆에 연락처 정보를 공개하기 위한 버튼이 있는 목록을 만들 거예요. 이를 위해서 먼저 이 프로젝트에 HTMX를 추가해야 해요. 일단 CDN을 통해 추가할 거에요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;head\u003e\n    ...\n    \u0026#x3C;script src=\u003cspan class=\"hljs-string\"\u003e\"https://unpkg.com/htmx.org@1.9.5\"\u003c/span\u003e integrity=\u003cspan class=\"hljs-string\"\u003e\"sha384-xcuj3WpfgjlKF+FXhSQFQ0ZNr39ln+hwjN3npfM9VBnUskLolQAcN80McRIVOPuO\"\u003c/span\u003e crossorigin=\u003cspan class=\"hljs-string\"\u003e\"anonymous\"\u003c/span\u003e\u003e\u0026#x3C;/script\u003e\n\u0026#x3C;/head\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드를 통해 HTMX를 CDN을 통해 추가할 거예요. 이제 사용자 정보를 직접 공개하지 않도록 index.html을 다시 수정해야 해요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;p\u003e\u003cspan class=\"hljs-title class_\"\u003eHello\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eWorld\u003c/span\u003e!\u0026#x3C;/p\u003e\n\u0026#x3C;!-- 이 줄을 삭제하세요 {template \u003cspan class=\"hljs-string\"\u003e\"name_card\"\u003c/span\u003e .} --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"user-info\"\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{.Name}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehx-get\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"/get-info\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehx-target\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"#user-info\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehx-swap\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"innerHTML\"\u003c/span\u003e\u003e\u003c/span\u003e정보 공개\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이렇게 하면 UI가 이름 부분만 표시되도록 설정되며, /get-info 엔드포인트를 호출할 버튼을 설정하고 #user-info 요소를 대상으로 하여 대상 요소의 내부 부분을 바꿀 것입니다 (기본적으로 \u003ccode\u003ediv\u003c/code\u003e를 그대로 두고 \u003ccode\u003ediv\u003c/code\u003e 내부의 모든 것을 변경합니다).\u003c/p\u003e\n\u003cp\u003e알겠어요. 많은 용어가 있네요. 여기서는 이 내용을 더 잘 설명한 htmx 웹페이지에서 확인할 수 있습니다. 이제 /get-info 경로를 처리하는 새 엔드포인트 핸들러를 생성하여 계속 진행해 보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ee.\u003cspan class=\"hljs-title function_\"\u003eGET\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/get-info\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e(c echo.\u003cspan class=\"hljs-property\"\u003eContext\u003c/span\u003e) error {\n    res := map[string]interface{}{\n        \u003cspan class=\"hljs-string\"\u003e\"Name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Wyndham\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"Phone\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"8888888\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"Email\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"skyscraper@gmail.com\"\u003c/span\u003e,\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e c.\u003cspan class=\"hljs-title class_\"\u003eRender\u003c/span\u003e(http.\u003cspan class=\"hljs-property\"\u003eStatusOK\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"name_card\"\u003c/span\u003e, res)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 거의 /hello와 동일하지만 두 가지 주요 차이점이 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e경로를 명확하게 /get-info로 변경해주세요.\u003c/li\u003e\n\u003cli\u003e대상 템플릿을 name_card로 변경해주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e하지만! name_card는 유효한 HTML 파일이 아니었나요? doctype도 없고 헤더도 없죠. 맞아요, 맞습니다. 하지만 이것은 HTMX가 동작하는 방식입니다. 전체 페이지를 교체하지 않고 우리가 index.html에서 지정한 user-info 요소만 교체할 거예요.\u003c/p\u003e\n\u003cp\u003e그럼, 더 이상 말을 더하지않고 서버를 실행해서 무슨 일이 일어났는지 봅시다:\u003c/p\u003e\n\u003cp\u003e와우! 제작품이 동작합니다! 이제 HTMX가 Go 템플릿과 잘 동작한다는 것을 알게 되었으니, 드디어 블로깅 사이트를 작업할 수 있겠네요. 그러나 불행히도 이 기사에서는 다루지 않을 거예요. 하지만 곧 돌아올 테니까, 그렇게 길지 않겠죠!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 블로그를 읽어 주셔서 감사합니다. 여기서 중요한 점은 Go 템플릿을 사용하기 매우 유연하며, 이 작은 범위에서 HTMX와도 잘 작동한다는 것입니다. 다음 블로그에서는 기본 CRUD를 생성하여 DB에 기사를 저장하고 브라우저에서 액세스할 것입니다.\u003c/p\u003e\n\u003cp\u003e조금 스포일러를 하자면: 거기에 많이 HTMX를 사용하지는 않을 것이고, 그 다음 시점에도 그 후에도 마찬가지입니다. 게시 물 웹사이트에서는 HTMX가 많이 필요하지 않다는 것이 확인되었습니다. 놀랍죠. 그러나 페이지네이션, 검색, 실시간 Markdown 렌더러를 만드는 부분에 도달하면 HTMX를 적극 활용할 것입니다.\u003c/p\u003e\n\u003cp\u003e그러니 기대해 주세요! 읽어 주셔서 감사합니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e수정되었습니다! 두 번째 부분이 나왔어요! 다음 링크에서 읽을 수 있어요:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://medium.com/gravel-engineering/personal-blog-with-htmx-go-part-2-integrating-tailwindcss-412ebc4dcc97\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://medium.com/gravel-engineering/personal-blog-with-htmx-go-part-2-integrating-tailwindcss-412ebc4dcc97\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-01-PersonalBlogwithHTMXGoPart1GolangTemplatingSetup"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>