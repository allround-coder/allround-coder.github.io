<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications" data-gatsby-head="true"/><meta name="twitter:title" content="서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-16 03:14" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-742e6c91a18eb160.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 16, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이 게시물은 수분 섭취에 대해 자세히 다루며, 그것이 무엇인지, 왜 중요한지, 그리고 사용자에게 웹 사이트를 부드럽고 빠르게 느끼게 하는 방법을 설명합니다. 하지만 주의하세요, 수분 섭취는 모든 게 해피 엔딩인 것은 아닙니다. 잠재적인 장애물을 탐구하고 이를 극복하여 웹 사이트가 번개처럼 빠르고 사용자 친화적인 상태를 유지할 수 있도록 안내할 것입니다.</p>
<p><img src="/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png" alt="이미지"></p>
<h1>수분 섭취란?</h1>
<p>요리를 준비하고 있다고 상상해보세요. 수분 섭취는 요리의 대부분을 미리 준비(서버 측 렌더링)하고 식사 직전에 마무리 손질을 하는 것(클라이언트 측 렌더링)과 같습니다. 이를 통해 식사가 빨리 준비되고 맛있게 느껴지는 것처럼 빠르게 로딩되고 상호작용하는 웹 페이지를 만들 수 있습니다.</p>
<p>이제 수분 보충이 작동하는 방식을 살펴보겠습니다:</p>
<ul>
<li>서버는 코드를 컴파일하고 정적 HTML을 생성합니다.</li>
<li>HTML은 CSS와 JavaScript와 함께 클라이언트(브라우저)로 전송됩니다.</li>
<li>브라우저는 서버에서 JavaScript 파일을 실행하고 정적 페이지를 대화형 HTML 페이지로 변환합니다.</li>
</ul>
<h1>수분 보충 불일치 오류</h1>
<p>수분 보충 불일치 오류는 서버에서 렌더링된 HTML과 Vue 애플리케이션의 클라이언트 측 렌더링된 HTML이 최종 구조에 대해 동의하지 않을 때 발생합니다. 미리 렌더링된 HTML의 DOM 구조가 클라이언트 측 앱의 예상 출력과 일치하지 않으면 수분 보충 불일치 오류가 발생합니다.</p>
<h2>수분 불일치의 일반 원인:</h2>
<h2>잘못된 HTML</h2>
<p>서버 렌더링 출력물에 형식이 잘못된 또는 유효하지 않은 HTML이 포함되어 있으면 클라이언트 측 수분화 과정 중에 문제가 발생할 수 있습니다.</p>
<p>예시:</p>
<p>&#x3C;a
class="Invalid A tag"
href="<a href="https://www.google.com/" rel="nofollow" target="_blank">https://www.google.com/</a>"</p>
<blockquote>
</blockquote>
<p>Hello</p>
<p>이 HTML은 아래 이미지에 나와 있는 오류를 발생시킵니다.</p>
<p><img src="/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png" alt="2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png"></p>
<p>이 코드에는 중첩 오류가 두 가지 있습니다:</p>
<ul>
<li>다른 'a' 태그 안에 중첩된 'a' 태그.</li>
<li>'p' 태그 안에 중첩된 'div' 태그.</li>
</ul>
<p>그리고 브라우저는 코드를 다음과 같이 렌더링합니다.</p>
<pre><code class="hljs language-js">&#x3C;a <span class="hljs-keyword">class</span>=<span class="hljs-string">"Invalid A tag"</span> href=<span class="hljs-string">"https://www.google.com/"</span>>
  <span class="hljs-title class_">Hello</span>
&#x3C;/a>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Invalid A tag"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://www.google.com/"</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">a</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://www.youtube.com/"</span>></span>
    World
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">a</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
</code></pre>
<p>이 템플릿은 유효하지 않은 HTML 중첩 구조를 포함하고 있으며, 브라우저의 네이티브 HTML 구문 해석 동작에 의해 렌더링된 HTML이 "수정"되었습니다.</p>
<h2>HTML을 수정하는 스크립트들</h2>
<p>서버에서 실행 중인 스크립트들은 초기 HTML 구조를 수정할 수 있기 때문에, 클라이언트가 이를 수분화하려고 할 때 불일치가 발생할 수 있습니다.
특히 Vue가 제어를 쥐기 전에 서버 측에서 DOM을 과도하게 조작하는 것을 피하십시오.</p>
<p>예시:
Vue가 클라이언트에서 렌더링하기 전에 서버 측에 양식을 넣으면, 일치하지 않을 수 있습니다.</p>
<h2>상태 불일치</h2>
<p>서버 및 클라이언트에서 렌더링하는 데 사용되는 데이터(상태)의 차이로 인해 수분화 불일치가 발생할 수 있습니다. 비동기 데이터 가져오기나 동적 사용자 상호작용 시에 이는 일반적입니다.</p>
<p>예시</p>
<pre><code class="hljs language-js">&#x3C;script setup>
<span class="hljs-keyword">const</span> articles = <span class="hljs-title function_">useAsyncData</span>(<span class="hljs-string">'articles'</span>, <span class="hljs-keyword">async</span> () => {
  <span class="hljs-comment">// 클라이언트에서만 기사 데이터 가져오기</span>
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/api/articles'</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
})
&#x3C;/script>


<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">template</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
    { articles.length === 0 ? '로딩 중...' : '' }
    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"articles.length > 0"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"article in articles"</span>></span>
        {  article }
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">template</span>></span></span>
</code></pre>
<p>이 예시에서 서버 측 렌더링에는 어떤 기사 데이터도 없으므로 "로딩 중…" 텍스트가 표시됩니다. 그러나 클라이언트 측에서 데이터를 가져온 후에는 "로딩 중…" 텍스트가 표시되지 않습니다. 초기 상태의 차이로 인해 수분화 불일치가 발생합니다.</p>
<h2>날짜, 타임스탬프 및 무작위화</h2>
<p>날짜, 타임스탬프 또는 무작위 콘텐츠와 관련된 구성 요소는 서버와 클라이언트에서 다른 출력물을 생성할 수 있으므로 수분화 불일치 오류가 발생할 수 있습니다.</p>
<p>예시</p>
<pre><code class="hljs language-js">&#x3C;div>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>
    { Math.random() }
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>
&#x3C;/div>
</code></pre>
<p>서버와 클라이언트에서 Math.random()을 사용하면 서로 다른 난수가 생성되어 일치하지 않을 수 있습니다.</p>
<h1>수분 불일치 해소</h1>
<p><img src="/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_2.png" alt="이미지"></p>
<p>실제 해결책으로 수분 불일치에 대응해 보겠습니다:</p>
<h2>올바른 HTML 보장하기</h2>
<ul>
<li>올바르게 구조화된 HTML 구조를 유지하세요. 초기 서버 렌더링된 HTML의 오류나 일관성 부족은 클라이언트 측 JavaScript가 상호 작용할 때 일치하지 않을 수 있습니다.</li>
<li>린터(linter)나 유효성 검사기와 같은 도구를 사용하여 문제가 발생하기 전에 HTML 구문 오류를 잡아내세요.</li>
</ul>
<p>예시 (위의 잘못된 HTML에 대한 해결책)</p>
<pre><code class="hljs language-js">&#x3C;a
  <span class="hljs-keyword">class</span>=<span class="hljs-string">"Valid A tag"</span>
  href=<span class="hljs-string">"https://www.google.com/"</span>
>
  <span class="hljs-title class_">Hello</span>
&#x3C;/a>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://www.youtube.com/"</span>></span>
  World
<span class="hljs-tag">&#x3C;/<span class="hljs-name">a</span>></span></span>
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"Valid P tag"</span>></span>
  Bye World
<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>
</code></pre>
<p>이 예시에서는 잘못된 HTML을 수정한 방법은 다음과 같습니다:</p>
<ul>
<li>중첩된 <code>a</code> 태그를 제거했습니다. <code>a</code> 태그 안에 또 다른 <code>a</code> 태그를 넣을 수 없습니다.</li>
<li><code>p</code> 태그 내에 불필요한 <code>div</code> 태그를 제거했습니다. 단락 (<code>p</code>)은 텍스트 콘텐츠를 직접 포함해야 하며 <code>div</code>와 같은 추가적인 블록 수준 요소를 포함할 수 없습니다.</li>
</ul>
<h2>서버와 클라이언트 간 상태 불일치 해결하기</h2>
<ul>
<li>서버에서 HTML을 렌더링하는 데 사용되는 데이터와 클라이언트에서 사용 가능한 데이터가 다를 때 발생하는 수분화 불일치를 해결했습니다.</li>
<li>Nuxt 3와 같은 프레임워크가 제공하는 디버깅 도구를 사용하면 어디서 불일치가 발생했는지 정확히 파악하고 신속하게 해결할 수 있습니다.</li>
<li>Nuxt 3는 서버 및 클라이언트 측의 상태를 유지하기 위한 사용 가능한 UseHydration도 제공합니다.</li>
</ul>
<h2>최종 탈출</h2>
<h2><code>ClientOnly</code> 컴포넌트</h2>
<p><code>ClientOnly</code> 컴포넌트는 목적에 맞게 클라이언트 측에서만 컴포넌트를 렌더링하는 데 사용됩니다.</p>
<ul>
<li>이 지시문은 Nuxt에게 해당 컴포넌트에 대해 서버 측 렌더링을 완전히 건너뛰고 클라이언트 측에서만 렌더링하도록 지시합니다.</li>
<li>이 옵션을 사용할 때 SEO 및 초기 로드 성능에 영향을 줄 수 있으므로 신중하게 사용하세요.</li>
</ul>
<h2>.client과 .server 접미사 사용하기</h2>
<p>특정 코드가 실행되는 시점을 제어하기 위해 .server 또는 .client 접미사가 붙은 파일을 생성할 수 있습니다.</p>
<p>.server:</p>
<ul>
<li>파일은 초기 렌더링 중에 서버에서만 실행됩니다.</li>
<li>초기 로드 및 SEO를 개선합니다.</li>
<li>창 객체나 클라이언트 측 API에 접근할 수 없습니다.</li>
</ul>
<p>.client:</p>
<ul>
<li>파일은 클라이언트 측에서만 실행됩니다.</li>
<li>상호작용을 위해 완전한 브라우저 환경을 활용합니다.</li>
<li>사용자 입력 및 동적 기능에 이상적입니다.</li>
</ul>
<h2>NuxtLazyHydrate</h2>
<ul>
<li>NuxtLazyHydrate 라이브러리는 렌더링이 필요 없는 컴포넌트, 컴포저블 및 임포트 래퍼를 제공하여 사전 렌더링된 HTML의 수분화를 지연시킵니다. 비중요 구성 요소를 상호작용 가능하게 하는 컴포넌트를 제공하여 초기로드 및 반응성이 향상됩니다.</li>
<li>지연 로딩과 같이 중요한 콘텐츠를 우선해서 불러오고 필요할 때까지 중요하지 않은 요소는 정적으로 유지합니다.</li>
</ul>
<h1>읽어 주셔서 감사합니다!</h1>
<p>이 코딩 모험에 함께해 주셔서 대단히 감사합니다! 댓글로 의견을 알려주시고, 더 자세히 알아보고 싶은 다른 코딩 주제가 있으면 알려주세요. 계속해서 멋진 것들을 코딩하고 만들어봐요!</p>
<p><img src="/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_3.png" alt="image"></p>
<h1>참고문헌</h1>
<ul>
<li>Vue 2 하이드레이션 실패 시 어떻게 해야 할까요?— Alexander Lichter</li>
<li>서버 사이드 렌더링 (SSR) | Vue.js</li>
<li>Nuxt 3 "Hydration Mismatch" 오류 · Harlan Wilton</li>
<li>Nuxt에서의 Lazy Hydration 및 서버 컴포넌트 — Vue.js 3 성능 — Vue School Articles</li>
<li>Baroshem/nuxt-lazy-hydrate</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기","description":"","date":"2024-05-16 03:14","slug":"2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications","content":"\n\n이 게시물은 수분 섭취에 대해 자세히 다루며, 그것이 무엇인지, 왜 중요한지, 그리고 사용자에게 웹 사이트를 부드럽고 빠르게 느끼게 하는 방법을 설명합니다. 하지만 주의하세요, 수분 섭취는 모든 게 해피 엔딩인 것은 아닙니다. 잠재적인 장애물을 탐구하고 이를 극복하여 웹 사이트가 번개처럼 빠르고 사용자 친화적인 상태를 유지할 수 있도록 안내할 것입니다.\n\n![이미지](/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png)\n\n# 수분 섭취란?\n\n요리를 준비하고 있다고 상상해보세요. 수분 섭취는 요리의 대부분을 미리 준비(서버 측 렌더링)하고 식사 직전에 마무리 손질을 하는 것(클라이언트 측 렌더링)과 같습니다. 이를 통해 식사가 빨리 준비되고 맛있게 느껴지는 것처럼 빠르게 로딩되고 상호작용하는 웹 페이지를 만들 수 있습니다.\n\n\n\n이제 수분 보충이 작동하는 방식을 살펴보겠습니다:\n\n- 서버는 코드를 컴파일하고 정적 HTML을 생성합니다.\n- HTML은 CSS와 JavaScript와 함께 클라이언트(브라우저)로 전송됩니다.\n- 브라우저는 서버에서 JavaScript 파일을 실행하고 정적 페이지를 대화형 HTML 페이지로 변환합니다.\n\n# 수분 보충 불일치 오류\n\n수분 보충 불일치 오류는 서버에서 렌더링된 HTML과 Vue 애플리케이션의 클라이언트 측 렌더링된 HTML이 최종 구조에 대해 동의하지 않을 때 발생합니다. 미리 렌더링된 HTML의 DOM 구조가 클라이언트 측 앱의 예상 출력과 일치하지 않으면 수분 보충 불일치 오류가 발생합니다.\n\n\n\n## 수분 불일치의 일반 원인:\n\n## 잘못된 HTML\n\n서버 렌더링 출력물에 형식이 잘못된 또는 유효하지 않은 HTML이 포함되어 있으면 클라이언트 측 수분화 과정 중에 문제가 발생할 수 있습니다.\n\n예시:\n\n\n\n\n\u003ca\n  class=\"Invalid A tag\"\n  href=\"https://www.google.com/\"\n\u003e\n  Hello\n  \u003cdiv\u003e\n    \u003ca href=\"https://www.youtube.com/\"\u003e\n      World\n    \u003c/a\u003e\n  \u003c/div\u003e\n\u003c/a\u003e\n\u003cp class=\"Invalid P tag\"\u003e\n  \u003cdiv\u003eBye World\u003c/div\u003e\n\u003c/p\u003e\n\n\n이 HTML은 아래 이미지에 나와 있는 오류를 발생시킵니다.\n\n![2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png](/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png)\n\n이 코드에는 중첩 오류가 두 가지 있습니다:\n\n\n\n\n- 다른 'a' 태그 안에 중첩된 'a' 태그.\n- 'p' 태그 안에 중첩된 'div' 태그.\n\n그리고 브라우저는 코드를 다음과 같이 렌더링합니다.\n\n```js\n\u003ca class=\"Invalid A tag\" href=\"https://www.google.com/\"\u003e\n  Hello\n\u003c/a\u003e\n\u003cdiv\u003e\n  \u003ca class=\"Invalid A tag\" href=\"https://www.google.com/\"\u003e\n  \u003c/a\u003e\n  \u003ca href=\"https://www.youtube.com/\"\u003e\n    World\n  \u003c/a\u003e\n\u003c/div\u003e\n```\n\n이 템플릿은 유효하지 않은 HTML 중첩 구조를 포함하고 있으며, 브라우저의 네이티브 HTML 구문 해석 동작에 의해 렌더링된 HTML이 \"수정\"되었습니다.\n\n\n\n## HTML을 수정하는 스크립트들\n\n서버에서 실행 중인 스크립트들은 초기 HTML 구조를 수정할 수 있기 때문에, 클라이언트가 이를 수분화하려고 할 때 불일치가 발생할 수 있습니다.\n특히 Vue가 제어를 쥐기 전에 서버 측에서 DOM을 과도하게 조작하는 것을 피하십시오.\n\n예시:\nVue가 클라이언트에서 렌더링하기 전에 서버 측에 양식을 넣으면, 일치하지 않을 수 있습니다.\n\n## 상태 불일치\n\n\n\n서버 및 클라이언트에서 렌더링하는 데 사용되는 데이터(상태)의 차이로 인해 수분화 불일치가 발생할 수 있습니다. 비동기 데이터 가져오기나 동적 사용자 상호작용 시에 이는 일반적입니다.\n\n예시\n\n```js\n\u003cscript setup\u003e\nconst articles = useAsyncData('articles', async () =\u003e {\n  // 클라이언트에서만 기사 데이터 가져오기\n  const response = await fetch('/api/articles');\n  return await response.json();\n})\n\u003c/script\u003e\n\n\n\u003ctemplate\u003e\n  \u003cdiv\u003e\n    { articles.length === 0 ? '로딩 중...' : '' }\n    \u003cdiv v-if=\"articles.length \u003e 0\"\u003e\n      \u003cp v-for=\"article in articles\"\u003e\n        {  article }\n      \u003c/p\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n```\n\n이 예시에서 서버 측 렌더링에는 어떤 기사 데이터도 없으므로 \"로딩 중…\" 텍스트가 표시됩니다. 그러나 클라이언트 측에서 데이터를 가져온 후에는 \"로딩 중…\" 텍스트가 표시되지 않습니다. 초기 상태의 차이로 인해 수분화 불일치가 발생합니다.\n\n\n\n## 날짜, 타임스탬프 및 무작위화\n\n날짜, 타임스탬프 또는 무작위 콘텐츠와 관련된 구성 요소는 서버와 클라이언트에서 다른 출력물을 생성할 수 있으므로 수분화 불일치 오류가 발생할 수 있습니다.\n\n예시\n\n```js\n\u003cdiv\u003e\n  \u003cp\u003e\n    { Math.random() }\n  \u003c/p\u003e\n\u003c/div\u003e\n```\n\n\n\n서버와 클라이언트에서 Math.random()을 사용하면 서로 다른 난수가 생성되어 일치하지 않을 수 있습니다.\n\n# 수분 불일치 해소\n\n![이미지](/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_2.png)\n\n실제 해결책으로 수분 불일치에 대응해 보겠습니다:\n\n\n\n## 올바른 HTML 보장하기\n\n- 올바르게 구조화된 HTML 구조를 유지하세요. 초기 서버 렌더링된 HTML의 오류나 일관성 부족은 클라이언트 측 JavaScript가 상호 작용할 때 일치하지 않을 수 있습니다.\n- 린터(linter)나 유효성 검사기와 같은 도구를 사용하여 문제가 발생하기 전에 HTML 구문 오류를 잡아내세요.\n\n예시 (위의 잘못된 HTML에 대한 해결책)\n\n```js\n\u003ca\n  class=\"Valid A tag\"\n  href=\"https://www.google.com/\"\n\u003e\n  Hello\n\u003c/a\u003e\n\u003ca href=\"https://www.youtube.com/\"\u003e\n  World\n\u003c/a\u003e\n\u003cp class=\"Valid P tag\"\u003e\n  Bye World\n\u003c/p\u003e\n```\n\n\n\n이 예시에서는 잘못된 HTML을 수정한 방법은 다음과 같습니다:\n\n- 중첩된 `a` 태그를 제거했습니다. `a` 태그 안에 또 다른 `a` 태그를 넣을 수 없습니다.\n- `p` 태그 내에 불필요한 `div` 태그를 제거했습니다. 단락 (`p`)은 텍스트 콘텐츠를 직접 포함해야 하며 `div`와 같은 추가적인 블록 수준 요소를 포함할 수 없습니다.\n\n## 서버와 클라이언트 간 상태 불일치 해결하기\n\n- 서버에서 HTML을 렌더링하는 데 사용되는 데이터와 클라이언트에서 사용 가능한 데이터가 다를 때 발생하는 수분화 불일치를 해결했습니다.\n- Nuxt 3와 같은 프레임워크가 제공하는 디버깅 도구를 사용하면 어디서 불일치가 발생했는지 정확히 파악하고 신속하게 해결할 수 있습니다.\n- Nuxt 3는 서버 및 클라이언트 측의 상태를 유지하기 위한 사용 가능한 UseHydration도 제공합니다.\n\n\n\n## 최종 탈출\n\n## `ClientOnly` 컴포넌트\n\n`ClientOnly` 컴포넌트는 목적에 맞게 클라이언트 측에서만 컴포넌트를 렌더링하는 데 사용됩니다.\n\n- 이 지시문은 Nuxt에게 해당 컴포넌트에 대해 서버 측 렌더링을 완전히 건너뛰고 클라이언트 측에서만 렌더링하도록 지시합니다.\n- 이 옵션을 사용할 때 SEO 및 초기 로드 성능에 영향을 줄 수 있으므로 신중하게 사용하세요.\n\n\n\n## .client과 .server 접미사 사용하기\n\n특정 코드가 실행되는 시점을 제어하기 위해 .server 또는 .client 접미사가 붙은 파일을 생성할 수 있습니다.\n\n.server:\n\n- 파일은 초기 렌더링 중에 서버에서만 실행됩니다.\n- 초기 로드 및 SEO를 개선합니다.\n- 창 객체나 클라이언트 측 API에 접근할 수 없습니다.\n\n\n\n.client:\n\n- 파일은 클라이언트 측에서만 실행됩니다.\n- 상호작용을 위해 완전한 브라우저 환경을 활용합니다.\n- 사용자 입력 및 동적 기능에 이상적입니다.\n\n## NuxtLazyHydrate\n\n- NuxtLazyHydrate 라이브러리는 렌더링이 필요 없는 컴포넌트, 컴포저블 및 임포트 래퍼를 제공하여 사전 렌더링된 HTML의 수분화를 지연시킵니다. 비중요 구성 요소를 상호작용 가능하게 하는 컴포넌트를 제공하여 초기로드 및 반응성이 향상됩니다.\n- 지연 로딩과 같이 중요한 콘텐츠를 우선해서 불러오고 필요할 때까지 중요하지 않은 요소는 정적으로 유지합니다.\n\n\n\n# 읽어 주셔서 감사합니다!\n\n이 코딩 모험에 함께해 주셔서 대단히 감사합니다! 댓글로 의견을 알려주시고, 더 자세히 알아보고 싶은 다른 코딩 주제가 있으면 알려주세요. 계속해서 멋진 것들을 코딩하고 만들어봐요!\n\n![image](/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_3.png)\n\n# 참고문헌\n\n\n\n- Vue 2 하이드레이션 실패 시 어떻게 해야 할까요?— Alexander Lichter\n- 서버 사이드 렌더링 (SSR) | Vue.js\n- Nuxt 3 \"Hydration Mismatch\" 오류 · Harlan Wilton\n- Nuxt에서의 Lazy Hydration 및 서버 컴포넌트 — Vue.js 3 성능 — Vue School Articles\n- Baroshem/nuxt-lazy-hydrate","ogImage":{"url":"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png"},"coverImage":"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이 게시물은 수분 섭취에 대해 자세히 다루며, 그것이 무엇인지, 왜 중요한지, 그리고 사용자에게 웹 사이트를 부드럽고 빠르게 느끼게 하는 방법을 설명합니다. 하지만 주의하세요, 수분 섭취는 모든 게 해피 엔딩인 것은 아닙니다. 잠재적인 장애물을 탐구하고 이를 극복하여 웹 사이트가 번개처럼 빠르고 사용자 친화적인 상태를 유지할 수 있도록 안내할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e수분 섭취란?\u003c/h1\u003e\n\u003cp\u003e요리를 준비하고 있다고 상상해보세요. 수분 섭취는 요리의 대부분을 미리 준비(서버 측 렌더링)하고 식사 직전에 마무리 손질을 하는 것(클라이언트 측 렌더링)과 같습니다. 이를 통해 식사가 빨리 준비되고 맛있게 느껴지는 것처럼 빠르게 로딩되고 상호작용하는 웹 페이지를 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 수분 보충이 작동하는 방식을 살펴보겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e서버는 코드를 컴파일하고 정적 HTML을 생성합니다.\u003c/li\u003e\n\u003cli\u003eHTML은 CSS와 JavaScript와 함께 클라이언트(브라우저)로 전송됩니다.\u003c/li\u003e\n\u003cli\u003e브라우저는 서버에서 JavaScript 파일을 실행하고 정적 페이지를 대화형 HTML 페이지로 변환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e수분 보충 불일치 오류\u003c/h1\u003e\n\u003cp\u003e수분 보충 불일치 오류는 서버에서 렌더링된 HTML과 Vue 애플리케이션의 클라이언트 측 렌더링된 HTML이 최종 구조에 대해 동의하지 않을 때 발생합니다. 미리 렌더링된 HTML의 DOM 구조가 클라이언트 측 앱의 예상 출력과 일치하지 않으면 수분 보충 불일치 오류가 발생합니다.\u003c/p\u003e\n\u003ch2\u003e수분 불일치의 일반 원인:\u003c/h2\u003e\n\u003ch2\u003e잘못된 HTML\u003c/h2\u003e\n\u003cp\u003e서버 렌더링 출력물에 형식이 잘못된 또는 유효하지 않은 HTML이 포함되어 있으면 클라이언트 측 수분화 과정 중에 문제가 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cp\u003e\u0026#x3C;a\nclass=\"Invalid A tag\"\nhref=\"\u003ca href=\"https://www.google.com/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.google.com/\u003c/a\u003e\"\u003c/p\u003e\n\u003cblockquote\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eHello\u003c/p\u003e\n\u003cp\u003e이 HTML은 아래 이미지에 나와 있는 오류를 발생시킵니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png\" alt=\"2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e이 코드에는 중첩 오류가 두 가지 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e다른 'a' 태그 안에 중첩된 'a' 태그.\u003c/li\u003e\n\u003cli\u003e'p' 태그 안에 중첩된 'div' 태그.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그리고 브라우저는 코드를 다음과 같이 렌더링합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;a \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Invalid A tag\"\u003c/span\u003e href=\u003cspan class=\"hljs-string\"\u003e\"https://www.google.com/\"\u003c/span\u003e\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eHello\u003c/span\u003e\n\u0026#x3C;/a\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Invalid A tag\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"https://www.google.com/\"\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"https://www.youtube.com/\"\u003c/span\u003e\u003e\u003c/span\u003e\n    World\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 템플릿은 유효하지 않은 HTML 중첩 구조를 포함하고 있으며, 브라우저의 네이티브 HTML 구문 해석 동작에 의해 렌더링된 HTML이 \"수정\"되었습니다.\u003c/p\u003e\n\u003ch2\u003eHTML을 수정하는 스크립트들\u003c/h2\u003e\n\u003cp\u003e서버에서 실행 중인 스크립트들은 초기 HTML 구조를 수정할 수 있기 때문에, 클라이언트가 이를 수분화하려고 할 때 불일치가 발생할 수 있습니다.\n특히 Vue가 제어를 쥐기 전에 서버 측에서 DOM을 과도하게 조작하는 것을 피하십시오.\u003c/p\u003e\n\u003cp\u003e예시:\nVue가 클라이언트에서 렌더링하기 전에 서버 측에 양식을 넣으면, 일치하지 않을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e상태 불일치\u003c/h2\u003e\n\u003cp\u003e서버 및 클라이언트에서 렌더링하는 데 사용되는 데이터(상태)의 차이로 인해 수분화 불일치가 발생할 수 있습니다. 비동기 데이터 가져오기나 동적 사용자 상호작용 시에 이는 일반적입니다.\u003c/p\u003e\n\u003cp\u003e예시\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;script setup\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e articles = \u003cspan class=\"hljs-title function_\"\u003euseAsyncData\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'articles'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 클라이언트에서만 기사 데이터 가져오기\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/api/articles'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n})\n\u0026#x3C;/script\u003e\n\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n    { articles.length === 0 ? '로딩 중...' : '' }\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ev-if\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"articles.length \u003e 0\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ev-for\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"article in articles\"\u003c/span\u003e\u003e\u003c/span\u003e\n        {  article }\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서 서버 측 렌더링에는 어떤 기사 데이터도 없으므로 \"로딩 중…\" 텍스트가 표시됩니다. 그러나 클라이언트 측에서 데이터를 가져온 후에는 \"로딩 중…\" 텍스트가 표시되지 않습니다. 초기 상태의 차이로 인해 수분화 불일치가 발생합니다.\u003c/p\u003e\n\u003ch2\u003e날짜, 타임스탬프 및 무작위화\u003c/h2\u003e\n\u003cp\u003e날짜, 타임스탬프 또는 무작위 콘텐츠와 관련된 구성 요소는 서버와 클라이언트에서 다른 출력물을 생성할 수 있으므로 수분화 불일치 오류가 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예시\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;div\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    { Math.random() }\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/div\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서버와 클라이언트에서 Math.random()을 사용하면 서로 다른 난수가 생성되어 일치하지 않을 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e수분 불일치 해소\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e실제 해결책으로 수분 불일치에 대응해 보겠습니다:\u003c/p\u003e\n\u003ch2\u003e올바른 HTML 보장하기\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e올바르게 구조화된 HTML 구조를 유지하세요. 초기 서버 렌더링된 HTML의 오류나 일관성 부족은 클라이언트 측 JavaScript가 상호 작용할 때 일치하지 않을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e린터(linter)나 유효성 검사기와 같은 도구를 사용하여 문제가 발생하기 전에 HTML 구문 오류를 잡아내세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시 (위의 잘못된 HTML에 대한 해결책)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;a\n  \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Valid A tag\"\u003c/span\u003e\n  href=\u003cspan class=\"hljs-string\"\u003e\"https://www.google.com/\"\u003c/span\u003e\n\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eHello\u003c/span\u003e\n\u0026#x3C;/a\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"https://www.youtube.com/\"\u003c/span\u003e\u003e\u003c/span\u003e\n  World\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Valid P tag\"\u003c/span\u003e\u003e\u003c/span\u003e\n  Bye World\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서는 잘못된 HTML을 수정한 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e중첩된 \u003ccode\u003ea\u003c/code\u003e 태그를 제거했습니다. \u003ccode\u003ea\u003c/code\u003e 태그 안에 또 다른 \u003ccode\u003ea\u003c/code\u003e 태그를 넣을 수 없습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ep\u003c/code\u003e 태그 내에 불필요한 \u003ccode\u003ediv\u003c/code\u003e 태그를 제거했습니다. 단락 (\u003ccode\u003ep\u003c/code\u003e)은 텍스트 콘텐츠를 직접 포함해야 하며 \u003ccode\u003ediv\u003c/code\u003e와 같은 추가적인 블록 수준 요소를 포함할 수 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e서버와 클라이언트 간 상태 불일치 해결하기\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e서버에서 HTML을 렌더링하는 데 사용되는 데이터와 클라이언트에서 사용 가능한 데이터가 다를 때 발생하는 수분화 불일치를 해결했습니다.\u003c/li\u003e\n\u003cli\u003eNuxt 3와 같은 프레임워크가 제공하는 디버깅 도구를 사용하면 어디서 불일치가 발생했는지 정확히 파악하고 신속하게 해결할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eNuxt 3는 서버 및 클라이언트 측의 상태를 유지하기 위한 사용 가능한 UseHydration도 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e최종 탈출\u003c/h2\u003e\n\u003ch2\u003e\u003ccode\u003eClientOnly\u003c/code\u003e 컴포넌트\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eClientOnly\u003c/code\u003e 컴포넌트는 목적에 맞게 클라이언트 측에서만 컴포넌트를 렌더링하는 데 사용됩니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 지시문은 Nuxt에게 해당 컴포넌트에 대해 서버 측 렌더링을 완전히 건너뛰고 클라이언트 측에서만 렌더링하도록 지시합니다.\u003c/li\u003e\n\u003cli\u003e이 옵션을 사용할 때 SEO 및 초기 로드 성능에 영향을 줄 수 있으므로 신중하게 사용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e.client과 .server 접미사 사용하기\u003c/h2\u003e\n\u003cp\u003e특정 코드가 실행되는 시점을 제어하기 위해 .server 또는 .client 접미사가 붙은 파일을 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e.server:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e파일은 초기 렌더링 중에 서버에서만 실행됩니다.\u003c/li\u003e\n\u003cli\u003e초기 로드 및 SEO를 개선합니다.\u003c/li\u003e\n\u003cli\u003e창 객체나 클라이언트 측 API에 접근할 수 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e.client:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e파일은 클라이언트 측에서만 실행됩니다.\u003c/li\u003e\n\u003cli\u003e상호작용을 위해 완전한 브라우저 환경을 활용합니다.\u003c/li\u003e\n\u003cli\u003e사용자 입력 및 동적 기능에 이상적입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eNuxtLazyHydrate\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eNuxtLazyHydrate 라이브러리는 렌더링이 필요 없는 컴포넌트, 컴포저블 및 임포트 래퍼를 제공하여 사전 렌더링된 HTML의 수분화를 지연시킵니다. 비중요 구성 요소를 상호작용 가능하게 하는 컴포넌트를 제공하여 초기로드 및 반응성이 향상됩니다.\u003c/li\u003e\n\u003cli\u003e지연 로딩과 같이 중요한 콘텐츠를 우선해서 불러오고 필요할 때까지 중요하지 않은 요소는 정적으로 유지합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e읽어 주셔서 감사합니다!\u003c/h1\u003e\n\u003cp\u003e이 코딩 모험에 함께해 주셔서 대단히 감사합니다! 댓글로 의견을 알려주시고, 더 자세히 알아보고 싶은 다른 코딩 주제가 있으면 알려주세요. 계속해서 멋진 것들을 코딩하고 만들어봐요!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_3.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003e참고문헌\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eVue 2 하이드레이션 실패 시 어떻게 해야 할까요?— Alexander Lichter\u003c/li\u003e\n\u003cli\u003e서버 사이드 렌더링 (SSR) | Vue.js\u003c/li\u003e\n\u003cli\u003eNuxt 3 \"Hydration Mismatch\" 오류 · Harlan Wilton\u003c/li\u003e\n\u003cli\u003eNuxt에서의 Lazy Hydration 및 서버 컴포넌트 — Vue.js 3 성능 — Vue School Articles\u003c/li\u003e\n\u003cli\u003eBaroshem/nuxt-lazy-hydrate\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>