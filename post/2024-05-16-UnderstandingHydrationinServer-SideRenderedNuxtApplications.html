<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications" data-gatsby-head="true"/><meta name="twitter:title" content="서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-16 03:14" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_buildManifest.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 16, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>이 게시물은 수분 섭취에 대해 자세히 다루며, 그것이 무엇인지, 왜 중요한지, 그리고 사용자에게 웹 사이트를 부드럽고 빠르게 느끼게 하는 방법을 설명합니다. 하지만 주의하세요, 수분 섭취는 모든 게 해피 엔딩인 것은 아닙니다. 잠재적인 장애물을 탐구하고 이를 극복하여 웹 사이트가 번개처럼 빠르고 사용자 친화적인 상태를 유지할 수 있도록 안내할 것입니다.</p>
<p><img src="/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png" alt="이미지"/></p>
<h1>수분 섭취란?</h1>
<p>요리를 준비하고 있다고 상상해보세요. 수분 섭취는 요리의 대부분을 미리 준비(서버 측 렌더링)하고 식사 직전에 마무리 손질을 하는 것(클라이언트 측 렌더링)과 같습니다. 이를 통해 식사가 빨리 준비되고 맛있게 느껴지는 것처럼 빠르게 로딩되고 상호작용하는 웹 페이지를 만들 수 있습니다.</p>
<p>이제 수분 보충이 작동하는 방식을 살펴보겠습니다:</p>
<ul>
<li>서버는 코드를 컴파일하고 정적 HTML을 생성합니다.</li>
<li>HTML은 CSS와 JavaScript와 함께 클라이언트(브라우저)로 전송됩니다.</li>
<li>브라우저는 서버에서 JavaScript 파일을 실행하고 정적 페이지를 대화형 HTML 페이지로 변환합니다.</li>
</ul>
<h1>수분 보충 불일치 오류</h1>
<p>수분 보충 불일치 오류는 서버에서 렌더링된 HTML과 Vue 애플리케이션의 클라이언트 측 렌더링된 HTML이 최종 구조에 대해 동의하지 않을 때 발생합니다. 미리 렌더링된 HTML의 DOM 구조가 클라이언트 측 앱의 예상 출력과 일치하지 않으면 수분 보충 불일치 오류가 발생합니다.</p>
<h2>수분 불일치의 일반 원인:</h2>
<h2>잘못된 HTML</h2>
<p>서버 렌더링 출력물에 형식이 잘못된 또는 유효하지 않은 HTML이 포함되어 있으면 클라이언트 측 수분화 과정 중에 문제가 발생할 수 있습니다.</p>
<p>예시:</p>
<a class="Invalid A tag" href="https://www.google.com/"><p>Hello</p><div><a href="https://www.youtube.com/"><p>World</p></a></div></a>
<p class="Invalid P tag"><div>Bye World</div></p>
<p>이 HTML은 아래 이미지에 나와 있는 오류를 발생시킵니다.</p>
<p><img src="/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png" alt="2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png"/></p>
<p>이 코드에는 중첩 오류가 두 가지 있습니다:</p>
<ul>
<li>다른 &#x27;a&#x27; 태그 안에 중첩된 &#x27;a&#x27; 태그.</li>
<li>&#x27;p&#x27; 태그 안에 중첩된 &#x27;div&#x27; 태그.</li>
</ul>
<p>그리고 브라우저는 코드를 다음과 같이 렌더링합니다.</p>
<pre><code class="hljs language-js">&lt;a <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;Invalid A tag&quot;</span> href=<span class="hljs-string">&quot;https://www.google.com/&quot;</span>&gt;
  <span class="hljs-title class_">Hello</span>
&lt;/a&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Invalid A tag&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.google.com/&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.youtube.com/&quot;</span>&gt;</span>
    World
  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</code></pre>
<p>이 템플릿은 유효하지 않은 HTML 중첩 구조를 포함하고 있으며, 브라우저의 네이티브 HTML 구문 해석 동작에 의해 렌더링된 HTML이 &quot;수정&quot;되었습니다.</p>
<h2>HTML을 수정하는 스크립트들</h2>
<p>서버에서 실행 중인 스크립트들은 초기 HTML 구조를 수정할 수 있기 때문에, 클라이언트가 이를 수분화하려고 할 때 불일치가 발생할 수 있습니다.
특히 Vue가 제어를 쥐기 전에 서버 측에서 DOM을 과도하게 조작하는 것을 피하십시오.</p>
<p>예시:
Vue가 클라이언트에서 렌더링하기 전에 서버 측에 양식을 넣으면, 일치하지 않을 수 있습니다.</p>
<h2>상태 불일치</h2>
<p>서버 및 클라이언트에서 렌더링하는 데 사용되는 데이터(상태)의 차이로 인해 수분화 불일치가 발생할 수 있습니다. 비동기 데이터 가져오기나 동적 사용자 상호작용 시에 이는 일반적입니다.</p>
<p>예시</p>
<pre><code class="hljs language-js">&lt;script setup&gt;
<span class="hljs-keyword">const</span> articles = <span class="hljs-title function_">useAsyncData</span>(<span class="hljs-string">&#x27;articles&#x27;</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">// 클라이언트에서만 기사 데이터 가져오기</span>
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/articles&#x27;</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
})
&lt;/script&gt;


<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    { articles.length === 0 ? &#x27;로딩 중...&#x27; : &#x27;&#x27; }
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;articles.length &gt; 0&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;article in articles&quot;</span>&gt;</span>
        {  article }
      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<p>이 예시에서 서버 측 렌더링에는 어떤 기사 데이터도 없으므로 &quot;로딩 중…&quot; 텍스트가 표시됩니다. 그러나 클라이언트 측에서 데이터를 가져온 후에는 &quot;로딩 중…&quot; 텍스트가 표시되지 않습니다. 초기 상태의 차이로 인해 수분화 불일치가 발생합니다.</p>
<h2>날짜, 타임스탬프 및 무작위화</h2>
<p>날짜, 타임스탬프 또는 무작위 콘텐츠와 관련된 구성 요소는 서버와 클라이언트에서 다른 출력물을 생성할 수 있으므로 수분화 불일치 오류가 발생할 수 있습니다.</p>
<p>예시</p>
<pre><code class="hljs language-js">&lt;div&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
    { Math.random() }
  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
&lt;/div&gt;
</code></pre>
<p>서버와 클라이언트에서 Math.random()을 사용하면 서로 다른 난수가 생성되어 일치하지 않을 수 있습니다.</p>
<h1>수분 불일치 해소</h1>
<p><img src="/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_2.png" alt="이미지"/></p>
<p>실제 해결책으로 수분 불일치에 대응해 보겠습니다:</p>
<h2>올바른 HTML 보장하기</h2>
<ul>
<li>올바르게 구조화된 HTML 구조를 유지하세요. 초기 서버 렌더링된 HTML의 오류나 일관성 부족은 클라이언트 측 JavaScript가 상호 작용할 때 일치하지 않을 수 있습니다.</li>
<li>린터(linter)나 유효성 검사기와 같은 도구를 사용하여 문제가 발생하기 전에 HTML 구문 오류를 잡아내세요.</li>
</ul>
<p>예시 (위의 잘못된 HTML에 대한 해결책)</p>
<pre><code class="hljs language-js">&lt;a
  <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;Valid A tag&quot;</span>
  href=<span class="hljs-string">&quot;https://www.google.com/&quot;</span>
&gt;
  <span class="hljs-title class_">Hello</span>
&lt;/a&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.youtube.com/&quot;</span>&gt;</span>
  World
<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;Valid P tag&quot;</span>&gt;</span>
  Bye World
<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
</code></pre>
<p>이 예시에서는 잘못된 HTML을 수정한 방법은 다음과 같습니다:</p>
<ul>
<li>중첩된 <code>a</code> 태그를 제거했습니다. <code>a</code> 태그 안에 또 다른 <code>a</code> 태그를 넣을 수 없습니다.</li>
<li><code>p</code> 태그 내에 불필요한 <code>div</code> 태그를 제거했습니다. 단락 (<code>p</code>)은 텍스트 콘텐츠를 직접 포함해야 하며 <code>div</code>와 같은 추가적인 블록 수준 요소를 포함할 수 없습니다.</li>
</ul>
<h2>서버와 클라이언트 간 상태 불일치 해결하기</h2>
<ul>
<li>서버에서 HTML을 렌더링하는 데 사용되는 데이터와 클라이언트에서 사용 가능한 데이터가 다를 때 발생하는 수분화 불일치를 해결했습니다.</li>
<li>Nuxt 3와 같은 프레임워크가 제공하는 디버깅 도구를 사용하면 어디서 불일치가 발생했는지 정확히 파악하고 신속하게 해결할 수 있습니다.</li>
<li>Nuxt 3는 서버 및 클라이언트 측의 상태를 유지하기 위한 사용 가능한 UseHydration도 제공합니다.</li>
</ul>
<h2>최종 탈출</h2>
<h2><code>ClientOnly</code> 컴포넌트</h2>
<p><code>ClientOnly</code> 컴포넌트는 목적에 맞게 클라이언트 측에서만 컴포넌트를 렌더링하는 데 사용됩니다.</p>
<ul>
<li>이 지시문은 Nuxt에게 해당 컴포넌트에 대해 서버 측 렌더링을 완전히 건너뛰고 클라이언트 측에서만 렌더링하도록 지시합니다.</li>
<li>이 옵션을 사용할 때 SEO 및 초기 로드 성능에 영향을 줄 수 있으므로 신중하게 사용하세요.</li>
</ul>
<h2>.client과 .server 접미사 사용하기</h2>
<p>특정 코드가 실행되는 시점을 제어하기 위해 .server 또는 .client 접미사가 붙은 파일을 생성할 수 있습니다.</p>
<p>.server:</p>
<ul>
<li>파일은 초기 렌더링 중에 서버에서만 실행됩니다.</li>
<li>초기 로드 및 SEO를 개선합니다.</li>
<li>창 객체나 클라이언트 측 API에 접근할 수 없습니다.</li>
</ul>
<p>.client:</p>
<ul>
<li>파일은 클라이언트 측에서만 실행됩니다.</li>
<li>상호작용을 위해 완전한 브라우저 환경을 활용합니다.</li>
<li>사용자 입력 및 동적 기능에 이상적입니다.</li>
</ul>
<h2>NuxtLazyHydrate</h2>
<ul>
<li>NuxtLazyHydrate 라이브러리는 렌더링이 필요 없는 컴포넌트, 컴포저블 및 임포트 래퍼를 제공하여 사전 렌더링된 HTML의 수분화를 지연시킵니다. 비중요 구성 요소를 상호작용 가능하게 하는 컴포넌트를 제공하여 초기로드 및 반응성이 향상됩니다.</li>
<li>지연 로딩과 같이 중요한 콘텐츠를 우선해서 불러오고 필요할 때까지 중요하지 않은 요소는 정적으로 유지합니다.</li>
</ul>
<h1>읽어 주셔서 감사합니다!</h1>
<p>이 코딩 모험에 함께해 주셔서 대단히 감사합니다! 댓글로 의견을 알려주시고, 더 자세히 알아보고 싶은 다른 코딩 주제가 있으면 알려주세요. 계속해서 멋진 것들을 코딩하고 만들어봐요!</p>
<p><img src="/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_3.png" alt="image"/></p>
<h1>참고문헌</h1>
<ul>
<li>Vue 2 하이드레이션 실패 시 어떻게 해야 할까요?— Alexander Lichter</li>
<li>서버 사이드 렌더링 (SSR) | Vue.js</li>
<li>Nuxt 3 &quot;Hydration Mismatch&quot; 오류 · Harlan Wilton</li>
<li>Nuxt에서의 Lazy Hydration 및 서버 컴포넌트 — Vue.js 3 성능 — Vue School Articles</li>
<li>Baroshem/nuxt-lazy-hydrate</li>
</ul></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"서버 측 렌더링된 눅트 애플리케이션에서 수분 공급 이해하기","description":"","date":"2024-05-16 03:14","slug":"2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications","content":"\n\n이 게시물은 수분 섭취에 대해 자세히 다루며, 그것이 무엇인지, 왜 중요한지, 그리고 사용자에게 웹 사이트를 부드럽고 빠르게 느끼게 하는 방법을 설명합니다. 하지만 주의하세요, 수분 섭취는 모든 게 해피 엔딩인 것은 아닙니다. 잠재적인 장애물을 탐구하고 이를 극복하여 웹 사이트가 번개처럼 빠르고 사용자 친화적인 상태를 유지할 수 있도록 안내할 것입니다.\n\n![이미지](/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png)\n\n# 수분 섭취란?\n\n요리를 준비하고 있다고 상상해보세요. 수분 섭취는 요리의 대부분을 미리 준비(서버 측 렌더링)하고 식사 직전에 마무리 손질을 하는 것(클라이언트 측 렌더링)과 같습니다. 이를 통해 식사가 빨리 준비되고 맛있게 느껴지는 것처럼 빠르게 로딩되고 상호작용하는 웹 페이지를 만들 수 있습니다.\n\n\n\n이제 수분 보충이 작동하는 방식을 살펴보겠습니다:\n\n- 서버는 코드를 컴파일하고 정적 HTML을 생성합니다.\n- HTML은 CSS와 JavaScript와 함께 클라이언트(브라우저)로 전송됩니다.\n- 브라우저는 서버에서 JavaScript 파일을 실행하고 정적 페이지를 대화형 HTML 페이지로 변환합니다.\n\n# 수분 보충 불일치 오류\n\n수분 보충 불일치 오류는 서버에서 렌더링된 HTML과 Vue 애플리케이션의 클라이언트 측 렌더링된 HTML이 최종 구조에 대해 동의하지 않을 때 발생합니다. 미리 렌더링된 HTML의 DOM 구조가 클라이언트 측 앱의 예상 출력과 일치하지 않으면 수분 보충 불일치 오류가 발생합니다.\n\n\n\n## 수분 불일치의 일반 원인:\n\n## 잘못된 HTML\n\n서버 렌더링 출력물에 형식이 잘못된 또는 유효하지 않은 HTML이 포함되어 있으면 클라이언트 측 수분화 과정 중에 문제가 발생할 수 있습니다.\n\n예시:\n\n\n\n\n\u003ca\n  class=\"Invalid A tag\"\n  href=\"https://www.google.com/\"\n\u003e\n  Hello\n  \u003cdiv\u003e\n    \u003ca href=\"https://www.youtube.com/\"\u003e\n      World\n    \u003c/a\u003e\n  \u003c/div\u003e\n\u003c/a\u003e\n\u003cp class=\"Invalid P tag\"\u003e\n  \u003cdiv\u003eBye World\u003c/div\u003e\n\u003c/p\u003e\n\n\n이 HTML은 아래 이미지에 나와 있는 오류를 발생시킵니다.\n\n![2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png](/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png)\n\n이 코드에는 중첩 오류가 두 가지 있습니다:\n\n\n\n\n- 다른 'a' 태그 안에 중첩된 'a' 태그.\n- 'p' 태그 안에 중첩된 'div' 태그.\n\n그리고 브라우저는 코드를 다음과 같이 렌더링합니다.\n\n```js\n\u003ca class=\"Invalid A tag\" href=\"https://www.google.com/\"\u003e\n  Hello\n\u003c/a\u003e\n\u003cdiv\u003e\n  \u003ca class=\"Invalid A tag\" href=\"https://www.google.com/\"\u003e\n  \u003c/a\u003e\n  \u003ca href=\"https://www.youtube.com/\"\u003e\n    World\n  \u003c/a\u003e\n\u003c/div\u003e\n```\n\n이 템플릿은 유효하지 않은 HTML 중첩 구조를 포함하고 있으며, 브라우저의 네이티브 HTML 구문 해석 동작에 의해 렌더링된 HTML이 \"수정\"되었습니다.\n\n\n\n## HTML을 수정하는 스크립트들\n\n서버에서 실행 중인 스크립트들은 초기 HTML 구조를 수정할 수 있기 때문에, 클라이언트가 이를 수분화하려고 할 때 불일치가 발생할 수 있습니다.\n특히 Vue가 제어를 쥐기 전에 서버 측에서 DOM을 과도하게 조작하는 것을 피하십시오.\n\n예시:\nVue가 클라이언트에서 렌더링하기 전에 서버 측에 양식을 넣으면, 일치하지 않을 수 있습니다.\n\n## 상태 불일치\n\n\n\n서버 및 클라이언트에서 렌더링하는 데 사용되는 데이터(상태)의 차이로 인해 수분화 불일치가 발생할 수 있습니다. 비동기 데이터 가져오기나 동적 사용자 상호작용 시에 이는 일반적입니다.\n\n예시\n\n```js\n\u003cscript setup\u003e\nconst articles = useAsyncData('articles', async () =\u003e {\n  // 클라이언트에서만 기사 데이터 가져오기\n  const response = await fetch('/api/articles');\n  return await response.json();\n})\n\u003c/script\u003e\n\n\n\u003ctemplate\u003e\n  \u003cdiv\u003e\n    { articles.length === 0 ? '로딩 중...' : '' }\n    \u003cdiv v-if=\"articles.length \u003e 0\"\u003e\n      \u003cp v-for=\"article in articles\"\u003e\n        {  article }\n      \u003c/p\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/template\u003e\n```\n\n이 예시에서 서버 측 렌더링에는 어떤 기사 데이터도 없으므로 \"로딩 중…\" 텍스트가 표시됩니다. 그러나 클라이언트 측에서 데이터를 가져온 후에는 \"로딩 중…\" 텍스트가 표시되지 않습니다. 초기 상태의 차이로 인해 수분화 불일치가 발생합니다.\n\n\n\n## 날짜, 타임스탬프 및 무작위화\n\n날짜, 타임스탬프 또는 무작위 콘텐츠와 관련된 구성 요소는 서버와 클라이언트에서 다른 출력물을 생성할 수 있으므로 수분화 불일치 오류가 발생할 수 있습니다.\n\n예시\n\n```js\n\u003cdiv\u003e\n  \u003cp\u003e\n    { Math.random() }\n  \u003c/p\u003e\n\u003c/div\u003e\n```\n\n\n\n서버와 클라이언트에서 Math.random()을 사용하면 서로 다른 난수가 생성되어 일치하지 않을 수 있습니다.\n\n# 수분 불일치 해소\n\n![이미지](/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_2.png)\n\n실제 해결책으로 수분 불일치에 대응해 보겠습니다:\n\n\n\n## 올바른 HTML 보장하기\n\n- 올바르게 구조화된 HTML 구조를 유지하세요. 초기 서버 렌더링된 HTML의 오류나 일관성 부족은 클라이언트 측 JavaScript가 상호 작용할 때 일치하지 않을 수 있습니다.\n- 린터(linter)나 유효성 검사기와 같은 도구를 사용하여 문제가 발생하기 전에 HTML 구문 오류를 잡아내세요.\n\n예시 (위의 잘못된 HTML에 대한 해결책)\n\n```js\n\u003ca\n  class=\"Valid A tag\"\n  href=\"https://www.google.com/\"\n\u003e\n  Hello\n\u003c/a\u003e\n\u003ca href=\"https://www.youtube.com/\"\u003e\n  World\n\u003c/a\u003e\n\u003cp class=\"Valid P tag\"\u003e\n  Bye World\n\u003c/p\u003e\n```\n\n\n\n이 예시에서는 잘못된 HTML을 수정한 방법은 다음과 같습니다:\n\n- 중첩된 `a` 태그를 제거했습니다. `a` 태그 안에 또 다른 `a` 태그를 넣을 수 없습니다.\n- `p` 태그 내에 불필요한 `div` 태그를 제거했습니다. 단락 (`p`)은 텍스트 콘텐츠를 직접 포함해야 하며 `div`와 같은 추가적인 블록 수준 요소를 포함할 수 없습니다.\n\n## 서버와 클라이언트 간 상태 불일치 해결하기\n\n- 서버에서 HTML을 렌더링하는 데 사용되는 데이터와 클라이언트에서 사용 가능한 데이터가 다를 때 발생하는 수분화 불일치를 해결했습니다.\n- Nuxt 3와 같은 프레임워크가 제공하는 디버깅 도구를 사용하면 어디서 불일치가 발생했는지 정확히 파악하고 신속하게 해결할 수 있습니다.\n- Nuxt 3는 서버 및 클라이언트 측의 상태를 유지하기 위한 사용 가능한 UseHydration도 제공합니다.\n\n\n\n## 최종 탈출\n\n## `ClientOnly` 컴포넌트\n\n`ClientOnly` 컴포넌트는 목적에 맞게 클라이언트 측에서만 컴포넌트를 렌더링하는 데 사용됩니다.\n\n- 이 지시문은 Nuxt에게 해당 컴포넌트에 대해 서버 측 렌더링을 완전히 건너뛰고 클라이언트 측에서만 렌더링하도록 지시합니다.\n- 이 옵션을 사용할 때 SEO 및 초기 로드 성능에 영향을 줄 수 있으므로 신중하게 사용하세요.\n\n\n\n## .client과 .server 접미사 사용하기\n\n특정 코드가 실행되는 시점을 제어하기 위해 .server 또는 .client 접미사가 붙은 파일을 생성할 수 있습니다.\n\n.server:\n\n- 파일은 초기 렌더링 중에 서버에서만 실행됩니다.\n- 초기 로드 및 SEO를 개선합니다.\n- 창 객체나 클라이언트 측 API에 접근할 수 없습니다.\n\n\n\n.client:\n\n- 파일은 클라이언트 측에서만 실행됩니다.\n- 상호작용을 위해 완전한 브라우저 환경을 활용합니다.\n- 사용자 입력 및 동적 기능에 이상적입니다.\n\n## NuxtLazyHydrate\n\n- NuxtLazyHydrate 라이브러리는 렌더링이 필요 없는 컴포넌트, 컴포저블 및 임포트 래퍼를 제공하여 사전 렌더링된 HTML의 수분화를 지연시킵니다. 비중요 구성 요소를 상호작용 가능하게 하는 컴포넌트를 제공하여 초기로드 및 반응성이 향상됩니다.\n- 지연 로딩과 같이 중요한 콘텐츠를 우선해서 불러오고 필요할 때까지 중요하지 않은 요소는 정적으로 유지합니다.\n\n\n\n# 읽어 주셔서 감사합니다!\n\n이 코딩 모험에 함께해 주셔서 대단히 감사합니다! 댓글로 의견을 알려주시고, 더 자세히 알아보고 싶은 다른 코딩 주제가 있으면 알려주세요. 계속해서 멋진 것들을 코딩하고 만들어봐요!\n\n![image](/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_3.png)\n\n# 참고문헌\n\n\n\n- Vue 2 하이드레이션 실패 시 어떻게 해야 할까요?— Alexander Lichter\n- 서버 사이드 렌더링 (SSR) | Vue.js\n- Nuxt 3 \"Hydration Mismatch\" 오류 · Harlan Wilton\n- Nuxt에서의 Lazy Hydration 및 서버 컴포넌트 — Vue.js 3 성능 — Vue School Articles\n- Baroshem/nuxt-lazy-hydrate","ogImage":{"url":"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png"},"coverImage":"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png","tag":["Tech"],"readingTime":6},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"이 게시물은 수분 섭취에 대해 자세히 다루며, 그것이 무엇인지, 왜 중요한지, 그리고 사용자에게 웹 사이트를 부드럽고 빠르게 느끼게 하는 방법을 설명합니다. 하지만 주의하세요, 수분 섭취는 모든 게 해피 엔딩인 것은 아닙니다. 잠재적인 장애물을 탐구하고 이를 극복하여 웹 사이트가 번개처럼 빠르고 사용자 친화적인 상태를 유지할 수 있도록 안내할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"수분 섭취란?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"요리를 준비하고 있다고 상상해보세요. 수분 섭취는 요리의 대부분을 미리 준비(서버 측 렌더링)하고 식사 직전에 마무리 손질을 하는 것(클라이언트 측 렌더링)과 같습니다. 이를 통해 식사가 빨리 준비되고 맛있게 느껴지는 것처럼 빠르게 로딩되고 상호작용하는 웹 페이지를 만들 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 수분 보충이 작동하는 방식을 살펴보겠습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"서버는 코드를 컴파일하고 정적 HTML을 생성합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"HTML은 CSS와 JavaScript와 함께 클라이언트(브라우저)로 전송됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"브라우저는 서버에서 JavaScript 파일을 실행하고 정적 페이지를 대화형 HTML 페이지로 변환합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"수분 보충 불일치 오류\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"수분 보충 불일치 오류는 서버에서 렌더링된 HTML과 Vue 애플리케이션의 클라이언트 측 렌더링된 HTML이 최종 구조에 대해 동의하지 않을 때 발생합니다. 미리 렌더링된 HTML의 DOM 구조가 클라이언트 측 앱의 예상 출력과 일치하지 않으면 수분 보충 불일치 오류가 발생합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"수분 불일치의 일반 원인:\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"잘못된 HTML\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서버 렌더링 출력물에 형식이 잘못된 또는 유효하지 않은 HTML이 포함되어 있으면 클라이언트 측 수분화 과정 중에 문제가 발생할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시:\"\n    }), \"\\n\", _jsxs(\"a\", {\n      class: \"Invalid A tag\",\n      href: \"https://www.google.com/\",\n      children: [_jsx(_components.p, {\n        children: \"Hello\"\n      }), _jsx(\"div\", {\n        children: _jsx(\"a\", {\n          href: \"https://www.youtube.com/\",\n          children: _jsx(_components.p, {\n            children: \"World\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsx(\"p\", {\n      class: \"Invalid P tag\",\n      children: _jsx(\"div\", {\n        children: \"Bye World\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 HTML은 아래 이미지에 나와 있는 오류를 발생시킵니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png\",\n        alt: \"2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_1.png\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 코드에는 중첩 오류가 두 가지 있습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"다른 'a' 태그 안에 중첩된 'a' 태그.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"'p' 태그 안에 중첩된 'div' 태그.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 브라우저는 코드를 다음과 같이 렌더링합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003ca \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Invalid A tag\\\"\"\n        }), \" href=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://www.google.com/\\\"\"\n        }), \"\u003e\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Hello\"\n        }), \"\\n\u003c/a\u003e\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n  \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"class\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"Invalid A tag\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"href\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"https://www.google.com/\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n  \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \"\u003e\"]\n          }), \"\\n  \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"href\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"https://www.youtube.com/\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n    World\\n  \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \"\u003e\"]\n          }), \"\\n\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 템플릿은 유효하지 않은 HTML 중첩 구조를 포함하고 있으며, 브라우저의 네이티브 HTML 구문 해석 동작에 의해 렌더링된 HTML이 \\\"수정\\\"되었습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"HTML을 수정하는 스크립트들\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서버에서 실행 중인 스크립트들은 초기 HTML 구조를 수정할 수 있기 때문에, 클라이언트가 이를 수분화하려고 할 때 불일치가 발생할 수 있습니다.\\n특히 Vue가 제어를 쥐기 전에 서버 측에서 DOM을 과도하게 조작하는 것을 피하십시오.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시:\\nVue가 클라이언트에서 렌더링하기 전에 서버 측에 양식을 넣으면, 일치하지 않을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"상태 불일치\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서버 및 클라이언트에서 렌더링하는 데 사용되는 데이터(상태)의 차이로 인해 수분화 불일치가 발생할 수 있습니다. 비동기 데이터 가져오기나 동적 사용자 상호작용 시에 이는 일반적입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003cscript setup\u003e\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" articles = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useAsyncData\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'articles'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" () =\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 클라이언트에서만 기사 데이터 가져오기\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" response = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/api/articles'\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" response.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"json\"\n        }), \"();\\n})\\n\u003c/script\u003e\\n\\n\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"template\"\n            }), \"\u003e\"]\n          }), \"\\n  \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n    { articles.length === 0 ? '로딩 중...' : '' }\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"v-if\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"articles.length \u003e 0\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"v-for\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"article in articles\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n        {  article }\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n  \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"template\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예시에서 서버 측 렌더링에는 어떤 기사 데이터도 없으므로 \\\"로딩 중…\\\" 텍스트가 표시됩니다. 그러나 클라이언트 측에서 데이터를 가져온 후에는 \\\"로딩 중…\\\" 텍스트가 표시되지 않습니다. 초기 상태의 차이로 인해 수분화 불일치가 발생합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"날짜, 타임스탬프 및 무작위화\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"날짜, 타임스탬프 또는 무작위 콘텐츠와 관련된 구성 요소는 서버와 클라이언트에서 다른 출력물을 생성할 수 있으므로 수분화 불일치 오류가 발생할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003cdiv\u003e\\n  \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n    { Math.random() }\\n  \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\u003c/div\u003e\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서버와 클라이언트에서 Math.random()을 사용하면 서로 다른 난수가 생성되어 일치하지 않을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"수분 불일치 해소\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_2.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실제 해결책으로 수분 불일치에 대응해 보겠습니다:\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"올바른 HTML 보장하기\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"올바르게 구조화된 HTML 구조를 유지하세요. 초기 서버 렌더링된 HTML의 오류나 일관성 부족은 클라이언트 측 JavaScript가 상호 작용할 때 일치하지 않을 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"린터(linter)나 유효성 검사기와 같은 도구를 사용하여 문제가 발생하기 전에 HTML 구문 오류를 잡아내세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시 (위의 잘못된 HTML에 대한 해결책)\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003ca\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \"=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Valid A tag\\\"\"\n        }), \"\\n  href=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://www.google.com/\\\"\"\n        }), \"\\n\u003e\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Hello\"\n        }), \"\\n\u003c/a\u003e\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"href\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"https://www.youtube.com/\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n  World\\n\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"class\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"Valid P tag\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n  Bye World\\n\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예시에서는 잘못된 HTML을 수정한 방법은 다음과 같습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"중첩된 \", _jsx(_components.code, {\n          children: \"a\"\n        }), \" 태그를 제거했습니다. \", _jsx(_components.code, {\n          children: \"a\"\n        }), \" 태그 안에 또 다른 \", _jsx(_components.code, {\n          children: \"a\"\n        }), \" 태그를 넣을 수 없습니다.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"p\"\n        }), \" 태그 내에 불필요한 \", _jsx(_components.code, {\n          children: \"div\"\n        }), \" 태그를 제거했습니다. 단락 (\", _jsx(_components.code, {\n          children: \"p\"\n        }), \")은 텍스트 콘텐츠를 직접 포함해야 하며 \", _jsx(_components.code, {\n          children: \"div\"\n        }), \"와 같은 추가적인 블록 수준 요소를 포함할 수 없습니다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"서버와 클라이언트 간 상태 불일치 해결하기\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"서버에서 HTML을 렌더링하는 데 사용되는 데이터와 클라이언트에서 사용 가능한 데이터가 다를 때 발생하는 수분화 불일치를 해결했습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Nuxt 3와 같은 프레임워크가 제공하는 디버깅 도구를 사용하면 어디서 불일치가 발생했는지 정확히 파악하고 신속하게 해결할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Nuxt 3는 서버 및 클라이언트 측의 상태를 유지하기 위한 사용 가능한 UseHydration도 제공합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"최종 탈출\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      children: [_jsx(_components.code, {\n        children: \"ClientOnly\"\n      }), \" 컴포넌트\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"ClientOnly\"\n      }), \" 컴포넌트는 목적에 맞게 클라이언트 측에서만 컴포넌트를 렌더링하는 데 사용됩니다.\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이 지시문은 Nuxt에게 해당 컴포넌트에 대해 서버 측 렌더링을 완전히 건너뛰고 클라이언트 측에서만 렌더링하도록 지시합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이 옵션을 사용할 때 SEO 및 초기 로드 성능에 영향을 줄 수 있으므로 신중하게 사용하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \".client과 .server 접미사 사용하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"특정 코드가 실행되는 시점을 제어하기 위해 .server 또는 .client 접미사가 붙은 파일을 생성할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \".server:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"파일은 초기 렌더링 중에 서버에서만 실행됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"초기 로드 및 SEO를 개선합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"창 객체나 클라이언트 측 API에 접근할 수 없습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \".client:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"파일은 클라이언트 측에서만 실행됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"상호작용을 위해 완전한 브라우저 환경을 활용합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"사용자 입력 및 동적 기능에 이상적입니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"NuxtLazyHydrate\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"NuxtLazyHydrate 라이브러리는 렌더링이 필요 없는 컴포넌트, 컴포저블 및 임포트 래퍼를 제공하여 사전 렌더링된 HTML의 수분화를 지연시킵니다. 비중요 구성 요소를 상호작용 가능하게 하는 컴포넌트를 제공하여 초기로드 및 반응성이 향상됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"지연 로딩과 같이 중요한 콘텐츠를 우선해서 불러오고 필요할 때까지 중요하지 않은 요소는 정적으로 유지합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"읽어 주셔서 감사합니다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 코딩 모험에 함께해 주셔서 대단히 감사합니다! 댓글로 의견을 알려주시고, 더 자세히 알아보고 싶은 다른 코딩 주제가 있으면 알려주세요. 계속해서 멋진 것들을 코딩하고 만들어봐요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications_3.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"참고문헌\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Vue 2 하이드레이션 실패 시 어떻게 해야 할까요?— Alexander Lichter\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"서버 사이드 렌더링 (SSR) | Vue.js\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Nuxt 3 \\\"Hydration Mismatch\\\" 오류 · Harlan Wilton\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Nuxt에서의 Lazy Hydration 및 서버 컴포넌트 — Vue.js 3 성능 — Vue School Articles\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Baroshem/nuxt-lazy-hydrate\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-16-UnderstandingHydrationinServer-SideRenderedNuxtApplications"},"buildId":"z1a6VTi5qHH9JJH7jaxL3","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>