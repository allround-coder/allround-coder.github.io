<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-23-MonorepoorNotMonorepo" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-MonorepoorNotMonorepo_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-23-MonorepoorNotMonorepo" data-gatsby-head="true"/><meta name="twitter:title" content="모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-MonorepoorNotMonorepo_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 13:51" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-MonorepoorNotMonorepo&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>소프트웨어 아키텍처를 결정할 때입니다. 점진적인 방식이 좋을까요, 아니면 처음부터 최상의 디자인을 찾아야 할까요? 우리는 모두 완벽을 추구합니다 — 최고의 라이브러리, 최고의 도구 등을. 하지만 “best”는 상대적인 개념이며, 선한 사람이 되는 것과 같이 주관적이며 상황에 따라 달라집니다. 좋은 소프트웨어를 설계할 때 여러 매개변수가 의사결정에 영향을 미치고 변화할 수 있다는 것을 염두에 두세요.</p>
<p>과도한 설계는 피해야 합니다. 더 가치 있는 것을 만들기 위해서는 더 많은 지식과 경험이 필요하지만, 아키텍처를 너무 복잡하게 만들지 않는 것이 중요합니다. 모노 레포와 이 방식을 채택할지 결정하는 데 고려해야 할 사항을 살펴봅시다.</p>
<h1>모노 레포란 무엇인가요?</h1>
<p>모노 레포는 “단일 저장소”를 줄인 용어로, 여러 프로젝트의 코드가 단일 저장소에 위치하는 버전 컨트롤 전략입니다. 이 방식은 각 프로젝트가 자체 저장소를 가지는 폴리 레포 모델과 대조됩니다.</p>
<div class="content-ad"></div>
<h1>Monorepos의 장점</h1>
<ol>
<li>통합된 코드베이스: Monorepo를 사용하면 모든 코드가 한 곳에 있어 다른 프로젝트 간에 코드를 쉽게 공유하고 재사용할 수 있습니다.</li>
<li>단순화된 의존성 관리: 모든 프로젝트가 같은 저장소를 공유하기 때문에 의존성 관리가 더 간단해집니다.</li>
<li>일관된 도구 및 구성: 단일 저장소를 통해 모든 프로젝트에서 도구와 구성을 일관되게 사용할 수 있습니다.</li>
<li>더 나은 협업: Monorepo에서 작업하는 팀은 모든 프로젝트의 변경 사항을 볼 수 있어 소통과 협업이 개선됩니다.</li>
</ol>
<h1>Monorepos의 도전과제</h1>
<ol>
<li>확장성 문제: 코드베이스가 커지면 저장소가 다루기 어려워져 관리가 더 어려워질 수 있습니다.</li>
<li>복잡한 빌드 프로세스: 한 부분의 변경이 다른 부분에 영향을 줄 수 있어 빌드 및 테스트가 더 복잡해질 수 있습니다.</li>
<li>접근 제어: 액세스 및 권한 관리는 특히 여러 팀이 있는 대규모 조직에서 도전적일 수 있습니다.</li>
</ol>
<div class="content-ad"></div>
<p>코드 예제: TurboRepo를 이용한 단일저장소 설정</p>
<p>TurboRepo는 JavaScript 및 TypeScript 코드베이스를 위한 고성능 빌드 시스템으로, 단일 저장소에 이상적입니다. 다음은 기본적인 설정 방법입니다:</p>
<ol>
<li>설치:</li>
</ol>
<pre><code class="hljs language-js">npx create-turbo@latest
cd my-turbo-repo
</code></pre>
<div class="content-ad"></div>
<ol start="2">
<li>애플리케이션과 패키지 추가하기:</li>
</ol>
<pre><code class="hljs language-js"> npx turbo run create next-app apps/myapp
 npx turbo run create react-lib packages/mylib
</code></pre>
<ol start="3">
<li>프로젝트 간 코드 공유하기:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-comment">// packages/mylib/src/index.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name: string</span>) {
<span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>!`</span>;
 }

<span class="hljs-comment">// apps/myapp/pages/index.tsx</span>
<span class="hljs-keyword">import</span> { greet } <span class="hljs-keyword">from</span> <span class="hljs-string">'mylib'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">Home</span> = (<span class="hljs-params"></span>) => {
 <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>{greet(‘World’)}<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
 }

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Home</span>;
</code></pre>
<div class="content-ad"></div>
<ol start="4">
<li>TurboRepo 구성:</li>
</ol>
<pre><code class="hljs language-js"> <span class="hljs-comment">// turbo.json</span>
 {
   <span class="hljs-string">"pipeline"</span>: {
     <span class="hljs-string">"build"</span>: {
       <span class="hljs-string">"dependsOn"</span>: [<span class="hljs-string">"^build"</span>],
       <span class="hljs-string">"outputs"</span>: [<span class="hljs-string">"dist/**"</span>]
     },
     <span class="hljs-string">"lint"</span>: {},
     <span class="hljs-string">"test"</span>: {}
   }
 }
</code></pre>
<ol start="5">
<li>TurboRepo 실행:</li>
</ol>
<pre><code class="hljs language-js">npx turbo run build
</code></pre>
<div class="content-ad"></div>
<h1>증분 빌드 및 캐싱</h1>
<p>TurboRepo는 대규모 코드베이스에 효율적인 증분 빌드와 캐싱을 제공하여 뛰어납니다.</p>
<ol>
<li>TurboRepo 캐싱:</li>
</ol>
<p>sa</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">
 <span class="hljs-comment">// turbo.json</span>
 {
   <span class="hljs-string">"pipeline"</span>: {
     <span class="hljs-string">"build"</span>: {
       <span class="hljs-string">"dependsOn"</span>: [<span class="hljs-string">"^build"</span>],
       <span class="hljs-string">"outputs"</span>: [<span class="hljs-string">"dist/**"</span>],
       <span class="hljs-string">"cache"</span>: <span class="hljs-literal">true</span>
     },
     <span class="hljs-string">"lint"</span>: {
       <span class="hljs-string">"cache"</span>: <span class="hljs-literal">true</span>
     },
     <span class="hljs-string">"test"</span>: {
       <span class="hljs-string">"cache"</span>: <span class="hljs-literal">true</span>
     }
   }
 }
</code></pre>
<h2>단일 저장소(monorepo)를 사용해야 하는 경우</h2>
<ul>
<li>꽉 결합: 프로젝트가 빈번하게 코드를 공유하고 서로 강하게 결합되어 있는 경우, 단일 저장소(monorepo)는 의존성 관리와 통합을 간소화할 수 있습니다.</li>
<li>소규모부터 중간 규모의 팀: 의사소통이 간단한 작은 팀에서는 단일 저장소(monorepo)가 더 관리하기 쉬울 수 있습니다.</li>
<li>일관된 표준: 프로젝트 간 일관된 코딩 표준, 도구 및 관행을 유지하는 것이 우선시되는 경우.</li>
</ul>
<h2>단일 저장소(monorepo)를 피해야 하는 경우</h2>
<div class="content-ad"></div>
<ul>
<li>대규모 다양한 팀: 서로 느슨하게 결합된 프로젝트에 참여하는 대규모 팀은 모노 레포를 사용하기 어려울 수 있습니다.</li>
<li>독립적인 배포: 프로젝트가 서로에게 영향을 미치지 않고 독립적으로 배포되어야 하는 경우, 폴리 레포가 더 적합할 수 있습니다.</li>
<li>확장성 고려: 코드베이스가 크게 성장할 것으로 예상된다면, 모노 레포가 그 규모를 처리할 수 있는지 고려해야 합니다.</li>
</ul>
<h1>결론</h1>
<p>소프트웨어 아키텍처에서 모노 레포와 폴리 레포 중 어떤 것을 선택할지 결정하는 것은 중요한 결정입니다. 각 접근 방식의 장단점을 여러분의 특정 요구 사항과 맥락에 대비해 고려하는 것이 중요합니다. 요구 사항을 충족시키면서 솔루션을 가능한 한 간단하게 유지함으로써 과도한 엔지니어링을 피할 수 있습니다. 모노 레포를 선택하든 말든, 주요한 것은 유연하고 유지 가능하며 확장 가능한 아키텍처를 구축하는 것입니다.</p>
<p>글의 비전에 보다 잘 맞게 각 섹션을 조정하거나 확장해도 괜찮습니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"모노레포 vs 비모노레포 어떤 것이 더 나은 선택일까","description":"","date":"2024-06-23 13:51","slug":"2024-06-23-MonorepoorNotMonorepo","content":"\n\n소프트웨어 아키텍처를 결정할 때입니다. 점진적인 방식이 좋을까요, 아니면 처음부터 최상의 디자인을 찾아야 할까요? 우리는 모두 완벽을 추구합니다 — 최고의 라이브러리, 최고의 도구 등을. 하지만 “best”는 상대적인 개념이며, 선한 사람이 되는 것과 같이 주관적이며 상황에 따라 달라집니다. 좋은 소프트웨어를 설계할 때 여러 매개변수가 의사결정에 영향을 미치고 변화할 수 있다는 것을 염두에 두세요.\n\n과도한 설계는 피해야 합니다. 더 가치 있는 것을 만들기 위해서는 더 많은 지식과 경험이 필요하지만, 아키텍처를 너무 복잡하게 만들지 않는 것이 중요합니다. 모노 레포와 이 방식을 채택할지 결정하는 데 고려해야 할 사항을 살펴봅시다.\n\n# 모노 레포란 무엇인가요?\n\n모노 레포는 “단일 저장소”를 줄인 용어로, 여러 프로젝트의 코드가 단일 저장소에 위치하는 버전 컨트롤 전략입니다. 이 방식은 각 프로젝트가 자체 저장소를 가지는 폴리 레포 모델과 대조됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Monorepos의 장점\n\n1. 통합된 코드베이스: Monorepo를 사용하면 모든 코드가 한 곳에 있어 다른 프로젝트 간에 코드를 쉽게 공유하고 재사용할 수 있습니다.\n2. 단순화된 의존성 관리: 모든 프로젝트가 같은 저장소를 공유하기 때문에 의존성 관리가 더 간단해집니다.\n3. 일관된 도구 및 구성: 단일 저장소를 통해 모든 프로젝트에서 도구와 구성을 일관되게 사용할 수 있습니다.\n4. 더 나은 협업: Monorepo에서 작업하는 팀은 모든 프로젝트의 변경 사항을 볼 수 있어 소통과 협업이 개선됩니다.\n\n# Monorepos의 도전과제\n\n1. 확장성 문제: 코드베이스가 커지면 저장소가 다루기 어려워져 관리가 더 어려워질 수 있습니다.\n2. 복잡한 빌드 프로세스: 한 부분의 변경이 다른 부분에 영향을 줄 수 있어 빌드 및 테스트가 더 복잡해질 수 있습니다.\n3. 접근 제어: 액세스 및 권한 관리는 특히 여러 팀이 있는 대규모 조직에서 도전적일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 예제: TurboRepo를 이용한 단일저장소 설정\n\nTurboRepo는 JavaScript 및 TypeScript 코드베이스를 위한 고성능 빌드 시스템으로, 단일 저장소에 이상적입니다. 다음은 기본적인 설정 방법입니다:\n\n1. 설치:\n\n```js\nnpx create-turbo@latest\ncd my-turbo-repo\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 애플리케이션과 패키지 추가하기:\n\n```js\n npx turbo run create next-app apps/myapp\n npx turbo run create react-lib packages/mylib\n```\n\n3. 프로젝트 간 코드 공유하기:\n\n```js\n// packages/mylib/src/index.ts\nexport function greet(name: string) {\nreturn `Hello, ${name}!`;\n }\n\n// apps/myapp/pages/index.tsx\nimport { greet } from 'mylib';\n\nconst Home = () =\u003e {\n return \u003cdiv\u003e{greet(‘World’)}\u003c/div\u003e;\n }\n\nexport default Home;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. TurboRepo 구성:\n\n```js\n // turbo.json\n {\n   \"pipeline\": {\n     \"build\": {\n       \"dependsOn\": [\"^build\"],\n       \"outputs\": [\"dist/**\"]\n     },\n     \"lint\": {},\n     \"test\": {}\n   }\n }\n```\n\n5. TurboRepo 실행:\n\n```js\nnpx turbo run build\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 증분 빌드 및 캐싱\n\nTurboRepo는 대규모 코드베이스에 효율적인 증분 빌드와 캐싱을 제공하여 뛰어납니다.\n\n1. TurboRepo 캐싱:\n\nsa\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\n // turbo.json\n {\n   \"pipeline\": {\n     \"build\": {\n       \"dependsOn\": [\"^build\"],\n       \"outputs\": [\"dist/**\"],\n       \"cache\": true\n     },\n     \"lint\": {\n       \"cache\": true\n     },\n     \"test\": {\n       \"cache\": true\n     }\n   }\n }\n```\n\n## 단일 저장소(monorepo)를 사용해야 하는 경우\n\n- 꽉 결합: 프로젝트가 빈번하게 코드를 공유하고 서로 강하게 결합되어 있는 경우, 단일 저장소(monorepo)는 의존성 관리와 통합을 간소화할 수 있습니다.\n- 소규모부터 중간 규모의 팀: 의사소통이 간단한 작은 팀에서는 단일 저장소(monorepo)가 더 관리하기 쉬울 수 있습니다.\n- 일관된 표준: 프로젝트 간 일관된 코딩 표준, 도구 및 관행을 유지하는 것이 우선시되는 경우.\n\n## 단일 저장소(monorepo)를 피해야 하는 경우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 대규모 다양한 팀: 서로 느슨하게 결합된 프로젝트에 참여하는 대규모 팀은 모노 레포를 사용하기 어려울 수 있습니다.\n- 독립적인 배포: 프로젝트가 서로에게 영향을 미치지 않고 독립적으로 배포되어야 하는 경우, 폴리 레포가 더 적합할 수 있습니다.\n- 확장성 고려: 코드베이스가 크게 성장할 것으로 예상된다면, 모노 레포가 그 규모를 처리할 수 있는지 고려해야 합니다.\n\n# 결론\n\n소프트웨어 아키텍처에서 모노 레포와 폴리 레포 중 어떤 것을 선택할지 결정하는 것은 중요한 결정입니다. 각 접근 방식의 장단점을 여러분의 특정 요구 사항과 맥락에 대비해 고려하는 것이 중요합니다. 요구 사항을 충족시키면서 솔루션을 가능한 한 간단하게 유지함으로써 과도한 엔지니어링을 피할 수 있습니다. 모노 레포를 선택하든 말든, 주요한 것은 유연하고 유지 가능하며 확장 가능한 아키텍처를 구축하는 것입니다.\n\n글의 비전에 보다 잘 맞게 각 섹션을 조정하거나 확장해도 괜찮습니다!","ogImage":{"url":"/assets/img/2024-06-23-MonorepoorNotMonorepo_0.png"},"coverImage":"/assets/img/2024-06-23-MonorepoorNotMonorepo_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e소프트웨어 아키텍처를 결정할 때입니다. 점진적인 방식이 좋을까요, 아니면 처음부터 최상의 디자인을 찾아야 할까요? 우리는 모두 완벽을 추구합니다 — 최고의 라이브러리, 최고의 도구 등을. 하지만 “best”는 상대적인 개념이며, 선한 사람이 되는 것과 같이 주관적이며 상황에 따라 달라집니다. 좋은 소프트웨어를 설계할 때 여러 매개변수가 의사결정에 영향을 미치고 변화할 수 있다는 것을 염두에 두세요.\u003c/p\u003e\n\u003cp\u003e과도한 설계는 피해야 합니다. 더 가치 있는 것을 만들기 위해서는 더 많은 지식과 경험이 필요하지만, 아키텍처를 너무 복잡하게 만들지 않는 것이 중요합니다. 모노 레포와 이 방식을 채택할지 결정하는 데 고려해야 할 사항을 살펴봅시다.\u003c/p\u003e\n\u003ch1\u003e모노 레포란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e모노 레포는 “단일 저장소”를 줄인 용어로, 여러 프로젝트의 코드가 단일 저장소에 위치하는 버전 컨트롤 전략입니다. 이 방식은 각 프로젝트가 자체 저장소를 가지는 폴리 레포 모델과 대조됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eMonorepos의 장점\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e통합된 코드베이스: Monorepo를 사용하면 모든 코드가 한 곳에 있어 다른 프로젝트 간에 코드를 쉽게 공유하고 재사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e단순화된 의존성 관리: 모든 프로젝트가 같은 저장소를 공유하기 때문에 의존성 관리가 더 간단해집니다.\u003c/li\u003e\n\u003cli\u003e일관된 도구 및 구성: 단일 저장소를 통해 모든 프로젝트에서 도구와 구성을 일관되게 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e더 나은 협업: Monorepo에서 작업하는 팀은 모든 프로젝트의 변경 사항을 볼 수 있어 소통과 협업이 개선됩니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1\u003eMonorepos의 도전과제\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e확장성 문제: 코드베이스가 커지면 저장소가 다루기 어려워져 관리가 더 어려워질 수 있습니다.\u003c/li\u003e\n\u003cli\u003e복잡한 빌드 프로세스: 한 부분의 변경이 다른 부분에 영향을 줄 수 있어 빌드 및 테스트가 더 복잡해질 수 있습니다.\u003c/li\u003e\n\u003cli\u003e접근 제어: 액세스 및 권한 관리는 특히 여러 팀이 있는 대규모 조직에서 도전적일 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e코드 예제: TurboRepo를 이용한 단일저장소 설정\u003c/p\u003e\n\u003cp\u003eTurboRepo는 JavaScript 및 TypeScript 코드베이스를 위한 고성능 빌드 시스템으로, 단일 저장소에 이상적입니다. 다음은 기본적인 설정 방법입니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e설치:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpx create-turbo@latest\ncd my-turbo-repo\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e애플리케이션과 패키지 추가하기:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e npx turbo run create next-app apps/myapp\n npx turbo run create react-lib packages/mylib\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e프로젝트 간 코드 공유하기:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// packages/mylib/src/index.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename: string\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`Hello, \u003cspan class=\"hljs-subst\"\u003e${name}\u003c/span\u003e!`\u003c/span\u003e;\n }\n\n\u003cspan class=\"hljs-comment\"\u003e// apps/myapp/pages/index.tsx\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { greet } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'mylib'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHome\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e{greet(‘World’)}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n }\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHome\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eTurboRepo 구성:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e \u003cspan class=\"hljs-comment\"\u003e// turbo.json\u003c/span\u003e\n {\n   \u003cspan class=\"hljs-string\"\u003e\"pipeline\"\u003c/span\u003e: {\n     \u003cspan class=\"hljs-string\"\u003e\"build\"\u003c/span\u003e: {\n       \u003cspan class=\"hljs-string\"\u003e\"dependsOn\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"^build\"\u003c/span\u003e],\n       \u003cspan class=\"hljs-string\"\u003e\"outputs\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"dist/**\"\u003c/span\u003e]\n     },\n     \u003cspan class=\"hljs-string\"\u003e\"lint\"\u003c/span\u003e: {},\n     \u003cspan class=\"hljs-string\"\u003e\"test\"\u003c/span\u003e: {}\n   }\n }\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003eTurboRepo 실행:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpx turbo run build\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e증분 빌드 및 캐싱\u003c/h1\u003e\n\u003cp\u003eTurboRepo는 대규모 코드베이스에 효율적인 증분 빌드와 캐싱을 제공하여 뛰어납니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTurboRepo 캐싱:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003esa\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\n \u003cspan class=\"hljs-comment\"\u003e// turbo.json\u003c/span\u003e\n {\n   \u003cspan class=\"hljs-string\"\u003e\"pipeline\"\u003c/span\u003e: {\n     \u003cspan class=\"hljs-string\"\u003e\"build\"\u003c/span\u003e: {\n       \u003cspan class=\"hljs-string\"\u003e\"dependsOn\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"^build\"\u003c/span\u003e],\n       \u003cspan class=\"hljs-string\"\u003e\"outputs\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"dist/**\"\u003c/span\u003e],\n       \u003cspan class=\"hljs-string\"\u003e\"cache\"\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n     },\n     \u003cspan class=\"hljs-string\"\u003e\"lint\"\u003c/span\u003e: {\n       \u003cspan class=\"hljs-string\"\u003e\"cache\"\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n     },\n     \u003cspan class=\"hljs-string\"\u003e\"test\"\u003c/span\u003e: {\n       \u003cspan class=\"hljs-string\"\u003e\"cache\"\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n     }\n   }\n }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e단일 저장소(monorepo)를 사용해야 하는 경우\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e꽉 결합: 프로젝트가 빈번하게 코드를 공유하고 서로 강하게 결합되어 있는 경우, 단일 저장소(monorepo)는 의존성 관리와 통합을 간소화할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e소규모부터 중간 규모의 팀: 의사소통이 간단한 작은 팀에서는 단일 저장소(monorepo)가 더 관리하기 쉬울 수 있습니다.\u003c/li\u003e\n\u003cli\u003e일관된 표준: 프로젝트 간 일관된 코딩 표준, 도구 및 관행을 유지하는 것이 우선시되는 경우.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e단일 저장소(monorepo)를 피해야 하는 경우\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e대규모 다양한 팀: 서로 느슨하게 결합된 프로젝트에 참여하는 대규모 팀은 모노 레포를 사용하기 어려울 수 있습니다.\u003c/li\u003e\n\u003cli\u003e독립적인 배포: 프로젝트가 서로에게 영향을 미치지 않고 독립적으로 배포되어야 하는 경우, 폴리 레포가 더 적합할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e확장성 고려: 코드베이스가 크게 성장할 것으로 예상된다면, 모노 레포가 그 규모를 처리할 수 있는지 고려해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e소프트웨어 아키텍처에서 모노 레포와 폴리 레포 중 어떤 것을 선택할지 결정하는 것은 중요한 결정입니다. 각 접근 방식의 장단점을 여러분의 특정 요구 사항과 맥락에 대비해 고려하는 것이 중요합니다. 요구 사항을 충족시키면서 솔루션을 가능한 한 간단하게 유지함으로써 과도한 엔지니어링을 피할 수 있습니다. 모노 레포를 선택하든 말든, 주요한 것은 유연하고 유지 가능하며 확장 가능한 아키텍처를 구축하는 것입니다.\u003c/p\u003e\n\u003cp\u003e글의 비전에 보다 잘 맞게 각 섹션을 조정하거나 확장해도 괜찮습니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-MonorepoorNotMonorepo"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>