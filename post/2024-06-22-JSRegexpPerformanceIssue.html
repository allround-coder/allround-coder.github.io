<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>JS 정규표현식 성능 문제 해결 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-JSRegexpPerformanceIssue" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="JS 정규표현식 성능 문제 해결 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="JS 정규표현식 성능 문제 해결 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-JSRegexpPerformanceIssue_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-JSRegexpPerformanceIssue" data-gatsby-head="true"/><meta name="twitter:title" content="JS 정규표현식 성능 문제 해결 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-JSRegexpPerformanceIssue_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 06:08" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">JS 정규표현식 성능 문제 해결 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="JS 정규표현식 성능 문제 해결 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">2<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-JSRegexpPerformanceIssue&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>자주, 우리는 잠재적인 성능 문제를 인식하지 못하고 간단한 문자열 검색을 위해 정규식 표현을 사용합니다.</h2>
<p><img src="/assets/img/2024-06-22-JSRegexpPerformanceIssue_0.png" alt="이미지"></p>
<p>입력 또는 문자열 유효성 검사의 성능 문제의 일반적인 이유 중 하나는 정규식 검사의 복잡성입니다.</p>
<p>크롬 기반 브라우저 (예: Chrome, Edge, Opera 등)에는 정규식 엔진과 관련된 알려진 문제가 있습니다. Firefox도 마찬가지 문제를 가지고 있습니다. 왜냐하면 SpiderMonkey 엔진이 Chrome의 정규식에 동일한 엔진을 사용하기 때문입니다. 문제는 엔진이 정규식을 테스트하는 방법 (백트래킹 알고리즘)에서 나옵니다. 엔진이 적합한 패턴을 찾을 수 없을 때 검색을 완료하는 데 필요한 시간복잡도가 기하급수적으로 높아지기 때문입니다.</p>
<div class="content-ad"></div>
<p>이 문제를 확인하려면 새 탭을 열고 about:blank로 이동하십시오. 콘솔에서 다음 코드 조각을 실행하십시오. URL에 사용된 ID의 길이에 따라 정규 표현식 검색을 완료하는 데 걸리는 시간이 다를 수 있습니다.</p>
<p>만약 숫자와 단어 "ID"가 연달아 나오는 형식의 ID가 있는지 확인하고 싶다면 아래의 코드를 실행해보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> url1 = <span class="hljs-string">"www.somesite1.com/18329719832791721285462id/user"</span>
<span class="hljs-keyword">const</span> url2 = <span class="hljs-string">"www.somesite2.com/18329719832791721285462/user"</span>

<span class="hljs-keyword">let</span> start = performance.<span class="hljs-title function_">now</span>();
<span class="hljs-regexp">/(\d*)*(id)/</span>.<span class="hljs-title function_">exec</span>(url1);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(performance.<span class="hljs-title function_">now</span>() - start)

start = performance.<span class="hljs-title function_">now</span>();
<span class="hljs-regexp">/(\d*)*(id)/</span>.<span class="hljs-title function_">exec</span>(url2);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(performance.<span class="hljs-title function_">now</span>() - start)
</code></pre>
<p>위 코드의 성능평가:</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-22-JSRegexpPerformanceIssue_1.png" alt="이미지"></p>
<p>만약 우리가 숫자로 구성된 ID 뒤에 "id"라는 단어가 오는 존재를 확인하려고 한다고 가정해봅시다. 우리의 정규 표현식에서는 (\d*) 표현식이 반복되는 숫자 시퀀스를 찾습니다. 하나의 추가와일드카드로 감싸면 엔진은 시퀀스의 시퀀스를 찾습니다. 와일드카드 하나를 제거하면 여전히 동일한 결과를 얻으면서 검색에 필요한 시간을 크게 줄일 수 있습니다.</p>
<p>(백트래킹 알고리즘의 문제에 대해 더 자세히 설명된 것은 여기에서 확인할 수 있습니다)</p>
<p>결론:</p>
<div class="content-ad"></div>
<ul>
<li>regexp는 필요한 경우에만 사용하고 기본 선택지로 사용하지 마세요. includes() 및 split() 메소드를 사용하여 동일한 결과를 얻을 수 있습니다.</li>
<li>때로는 성능 문제를 일으키지 않는 새로운 regexp 패턴을 수정하거나 만들 수 있습니다.</li>
<li>각 추가된 문자로 성능 문제가 크게 증가하거나 문자열 검색이 있는 경우 해당 함수가 regexp를 사용한 것일 수 있음을 나타낼 수 있습니다.</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JS 정규표현식 성능 문제 해결 방법","description":"","date":"2024-06-22 06:08","slug":"2024-06-22-JSRegexpPerformanceIssue","content":"\n\n## 자주, 우리는 잠재적인 성능 문제를 인식하지 못하고 간단한 문자열 검색을 위해 정규식 표현을 사용합니다.\n\n![이미지](/assets/img/2024-06-22-JSRegexpPerformanceIssue_0.png)\n\n입력 또는 문자열 유효성 검사의 성능 문제의 일반적인 이유 중 하나는 정규식 검사의 복잡성입니다.\n\n크롬 기반 브라우저 (예: Chrome, Edge, Opera 등)에는 정규식 엔진과 관련된 알려진 문제가 있습니다. Firefox도 마찬가지 문제를 가지고 있습니다. 왜냐하면 SpiderMonkey 엔진이 Chrome의 정규식에 동일한 엔진을 사용하기 때문입니다. 문제는 엔진이 정규식을 테스트하는 방법 (백트래킹 알고리즘)에서 나옵니다. 엔진이 적합한 패턴을 찾을 수 없을 때 검색을 완료하는 데 필요한 시간복잡도가 기하급수적으로 높아지기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제를 확인하려면 새 탭을 열고 about:blank로 이동하십시오. 콘솔에서 다음 코드 조각을 실행하십시오. URL에 사용된 ID의 길이에 따라 정규 표현식 검색을 완료하는 데 걸리는 시간이 다를 수 있습니다.\n\n만약 숫자와 단어 \"ID\"가 연달아 나오는 형식의 ID가 있는지 확인하고 싶다면 아래의 코드를 실행해보세요:\n\n```js\nconst url1 = \"www.somesite1.com/18329719832791721285462id/user\"\nconst url2 = \"www.somesite2.com/18329719832791721285462/user\"\n\nlet start = performance.now();\n/(\\d*)*(id)/.exec(url1);\nconsole.log(performance.now() - start)\n\nstart = performance.now();\n/(\\d*)*(id)/.exec(url2);\nconsole.log(performance.now() - start)\n```\n\n위 코드의 성능평가:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-JSRegexpPerformanceIssue_1.png)\n\n만약 우리가 숫자로 구성된 ID 뒤에 \"id\"라는 단어가 오는 존재를 확인하려고 한다고 가정해봅시다. 우리의 정규 표현식에서는 (\\d*) 표현식이 반복되는 숫자 시퀀스를 찾습니다. 하나의 추가와일드카드로 감싸면 엔진은 시퀀스의 시퀀스를 찾습니다. 와일드카드 하나를 제거하면 여전히 동일한 결과를 얻으면서 검색에 필요한 시간을 크게 줄일 수 있습니다.\n\n(백트래킹 알고리즘의 문제에 대해 더 자세히 설명된 것은 여기에서 확인할 수 있습니다)\n\n결론:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- regexp는 필요한 경우에만 사용하고 기본 선택지로 사용하지 마세요. includes() 및 split() 메소드를 사용하여 동일한 결과를 얻을 수 있습니다.\n- 때로는 성능 문제를 일으키지 않는 새로운 regexp 패턴을 수정하거나 만들 수 있습니다.\n- 각 추가된 문자로 성능 문제가 크게 증가하거나 문자열 검색이 있는 경우 해당 함수가 regexp를 사용한 것일 수 있음을 나타낼 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-JSRegexpPerformanceIssue_0.png"},"coverImage":"/assets/img/2024-06-22-JSRegexpPerformanceIssue_0.png","tag":["Tech"],"readingTime":2},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e자주, 우리는 잠재적인 성능 문제를 인식하지 못하고 간단한 문자열 검색을 위해 정규식 표현을 사용합니다.\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-JSRegexpPerformanceIssue_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e입력 또는 문자열 유효성 검사의 성능 문제의 일반적인 이유 중 하나는 정규식 검사의 복잡성입니다.\u003c/p\u003e\n\u003cp\u003e크롬 기반 브라우저 (예: Chrome, Edge, Opera 등)에는 정규식 엔진과 관련된 알려진 문제가 있습니다. Firefox도 마찬가지 문제를 가지고 있습니다. 왜냐하면 SpiderMonkey 엔진이 Chrome의 정규식에 동일한 엔진을 사용하기 때문입니다. 문제는 엔진이 정규식을 테스트하는 방법 (백트래킹 알고리즘)에서 나옵니다. 엔진이 적합한 패턴을 찾을 수 없을 때 검색을 완료하는 데 필요한 시간복잡도가 기하급수적으로 높아지기 때문입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 문제를 확인하려면 새 탭을 열고 about:blank로 이동하십시오. 콘솔에서 다음 코드 조각을 실행하십시오. URL에 사용된 ID의 길이에 따라 정규 표현식 검색을 완료하는 데 걸리는 시간이 다를 수 있습니다.\u003c/p\u003e\n\u003cp\u003e만약 숫자와 단어 \"ID\"가 연달아 나오는 형식의 ID가 있는지 확인하고 싶다면 아래의 코드를 실행해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e url1 = \u003cspan class=\"hljs-string\"\u003e\"www.somesite1.com/18329719832791721285462id/user\"\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e url2 = \u003cspan class=\"hljs-string\"\u003e\"www.somesite2.com/18329719832791721285462/user\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e start = performance.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e();\n\u003cspan class=\"hljs-regexp\"\u003e/(\\d*)*(id)/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(url1);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(performance.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e() - start)\n\nstart = performance.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e();\n\u003cspan class=\"hljs-regexp\"\u003e/(\\d*)*(id)/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(url2);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(performance.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e() - start)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드의 성능평가:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-JSRegexpPerformanceIssue_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e만약 우리가 숫자로 구성된 ID 뒤에 \"id\"라는 단어가 오는 존재를 확인하려고 한다고 가정해봅시다. 우리의 정규 표현식에서는 (\\d*) 표현식이 반복되는 숫자 시퀀스를 찾습니다. 하나의 추가와일드카드로 감싸면 엔진은 시퀀스의 시퀀스를 찾습니다. 와일드카드 하나를 제거하면 여전히 동일한 결과를 얻으면서 검색에 필요한 시간을 크게 줄일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e(백트래킹 알고리즘의 문제에 대해 더 자세히 설명된 것은 여기에서 확인할 수 있습니다)\u003c/p\u003e\n\u003cp\u003e결론:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eregexp는 필요한 경우에만 사용하고 기본 선택지로 사용하지 마세요. includes() 및 split() 메소드를 사용하여 동일한 결과를 얻을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e때로는 성능 문제를 일으키지 않는 새로운 regexp 패턴을 수정하거나 만들 수 있습니다.\u003c/li\u003e\n\u003cli\u003e각 추가된 문자로 성능 문제가 크게 증가하거나 문자열 검색이 있는 경우 해당 함수가 regexp를 사용한 것일 수 있음을 나타낼 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-JSRegexpPerformanceIssue"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>