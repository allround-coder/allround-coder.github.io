<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>게임 개발 시작하기 게임 데이터 저장 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-16-BeginningGameDevelopmentSavingGameData" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="게임 개발 시작하기 게임 데이터 저장 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="게임 개발 시작하기 게임 데이터 저장 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-16-BeginningGameDevelopmentSavingGameData" data-gatsby-head="true"/><meta name="twitter:title" content="게임 개발 시작하기 게임 데이터 저장 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-16 03:38" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">게임 개발 시작하기 게임 데이터 저장</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="게임 개발 시작하기 게임 데이터 저장" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 16, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-16-BeginningGameDevelopmentSavingGameData&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><h2>Unity에서 C#을 활용한 저장 게임 기능 구현하기: 메소드, 저장소, 그리고 개인정보 보호</h2>
<p><img src="/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png" alt="게임 개발 데이터 저장하기"/></p>
<p>안녕하세요! 플레이어 경험을 향상시키고 게임 진행 상태를 보장하기 위해 견고한 저장 게임 시스템은 필수입니다. Unity와 C#을 결합하면 다양한 저장 및 불러오기 기능을 구현할 수 있는 유연한 환경을 제공합니다. 이 글에서는 Unity에서 직렬화 기술을 활용하여 게임 상태, 플레이어 진행 상황, 그리고 동적인 게임 요소를 저장하는 방법에 대해 다루고 있습니다. 또한 로컬 저장과 원격 파일 저장의 장단점 및 플레이어 데이터 개인정보 보호에 대한 고려 사항을 살펴봅니다.</p>
<ol>
<li>Unity에서의 직렬화 기술 직렬화란 객체의 상태를 저장하고 나중에 다시 생성할 수 있는 형식으로 변환하는 프로세스입니다. Unity는 게임 상태를 저장하는 데 중요한 여러 직렬화 기술을 지원합니다.</li>
</ol>
<p>키 메서드:</p>
<ul>
<li>이진 직렬화: System.Runtime.Serialization.Formatters.Binary 네임스페이스를 사용하여 객체를 이진 형식으로 변환합니다. 이 방법은 빠르고 효율적이지만 사람이 읽기 어려워 디버깅을 복잡하게 할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js">using <span class="hljs-title class_">System</span>.<span class="hljs-property">IO</span>;
using <span class="hljs-title class_">System</span>.<span class="hljs-property">Runtime</span>.<span class="hljs-property">Serialization</span>.<span class="hljs-property">Formatters</span>.<span class="hljs-property">Binary</span>;
using <span class="hljs-title class_">UnityEngine</span>;
public <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveSystem</span>
{
    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title class_">SavePlayer</span>(<span class="hljs-title class_">PlayerData</span> player)
    {
        <span class="hljs-title class_">BinaryFormatter</span> formatter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryFormatter</span>();
        string path = <span class="hljs-title class_">Application</span>.<span class="hljs-property">persistentDataPath</span> + 
            <span class="hljs-string">&quot;/player.save&quot;</span>;
        <span class="hljs-title class_">FileStream</span> stream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileStream</span>(path, <span class="hljs-title class_">FileMode</span>.<span class="hljs-property">Create</span>);
        formatter.<span class="hljs-title class_">Serialize</span>(stream, player);
        stream.<span class="hljs-title class_">Close</span>();
    }
    public <span class="hljs-keyword">static</span> <span class="hljs-title class_">PlayerData</span> <span class="hljs-title class_">LoadPlayer</span>()
    {
        string path = <span class="hljs-title class_">Application</span>.<span class="hljs-property">persistentDataPath</span> + 
            <span class="hljs-string">&quot;/player.save&quot;</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">File</span>.<span class="hljs-title class_">Exists</span>(path))
        {
            <span class="hljs-title class_">BinaryFormatter</span> formatter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryFormatter</span>();
            <span class="hljs-title class_">FileStream</span> stream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileStream</span>(path, <span class="hljs-title class_">FileMode</span>.<span class="hljs-property">Open</span>);
            <span class="hljs-title class_">PlayerData</span> data = formatter.<span class="hljs-title class_">Deserialize</span>(stream) <span class="hljs-keyword">as</span> 
                <span class="hljs-title class_">PlayerData</span>;
            stream.<span class="hljs-title class_">Close</span>();
            <span class="hljs-keyword">return</span> data;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-title class_">Debug</span>.<span class="hljs-title class_">LogError</span>(<span class="hljs-string">&quot;Save file not found in &quot;</span> + path);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    }
}
</code></pre>
<p><img src="/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_1.png" alt="게임 개발 시작화면용 데이터 저장 이미지"/></p>
<ul>
<li>JSON 직렬화: Unity의 JsonUtility를 사용하면 객체를 JSON 형식으로 직렬화할 수 있습니다. JSON은 사람이 읽기 쉽고 수정하기 쉬워 설정 및 설정에 적합합니다.</li>
</ul>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SaveSystem</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SavePlayer</span>(<span class="hljs-params">PlayerData player</span>)</span>
    {
        <span class="hljs-built_in">string</span> json = JsonUtility.ToJson(player);
        System.IO.File.WriteAllText(Application.persistentDataPath + 
             <span class="hljs-string">&quot;/player.json&quot;</span>, json);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PlayerData <span class="hljs-title">LoadPlayer</span>()</span>
    {
        <span class="hljs-built_in">string</span> path = Application.persistentDataPath + 
              <span class="hljs-string">&quot;/player.json&quot;</span>;
        <span class="hljs-keyword">if</span> (System.IO.File.Exists(path))
        {
            <span class="hljs-built_in">string</span> json = System.IO.File.ReadAllText(path);
            PlayerData data = 
                 JsonUtility.FromJson&lt;PlayerData&gt;(json);
            <span class="hljs-keyword">return</span> data;
        }
        <span class="hljs-keyword">else</span>
        {
            Debug.LogError(<span class="hljs-string">&quot;저장 파일을 &quot;</span> + path + <span class="hljs-string">&quot;(으)로 찾을 수 없음&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    }
}
</code></pre>
<p><img src="/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_2.png" alt="게임 데이터 저장 개발 시작"/></p>
<ol start="2">
<li>로컬 vs. 원격 파일 저장소: 게임의 디자인과 목표에 따라 로컬 및 원격 저장소 중 어떤 것을 선택할지 결정하는 것이 중요합니다.</li>
</ol>
<p>로컬 저장소:</p>
<ul>
<li>장점: 빠른 액세스, 인터넷 연결이 필요하지 않으며 데이터에 대한 완전한 제어.</li>
<li>단점: 장치에 제한됨, 장치가 손상되거나 분실된 경우 데이터 손실 가능성, 플레이어가 조작하기 쉬울 수 있음.</li>
</ul>
<p>원격 저장소:</p>
<ul>
<li>장점: 모든 장치에서 액세스 가능, 데이터가 백업되어 손실 확률이 적음, 데이터 조작에 대한 보안이 높음.</li>
<li>단점: 인터넷 연결이 필요, 서버 유지보수에 지속적인 비용, 잠재적인 개인정보 보안 문제.</li>
</ul>
<ol start="3">
<li>플레이어 데이터 개인 정보 보호 저장한 게임 기능을 구현할 때 특히 원격 저장 시 개인 정보 보호는 최우선 과제여야 합니다.</li>
</ol>
<p>개인 정보 보호 규정:</p>
<ul>
<li>암호화: 저장된 데이터를 암호화하면 전송 중 및 휴식 상태에서 민감한 정보를 보호할 수 있습니다.</li>
<li>규정 준수: 게임은 플레이어 데이터를 저장하고 사용하는 방법을 규제하는 유럽의 GDPR과 같은 법적 기준을 준수해야 합니다.</li>
<li>명확한 사용자 허가: 플레이어에게 저장되는 데이터에 대해 알리고 원하는 경우 원격으로 데이터를 저장하지 않도록 선택할 수 있도록 허용하세요.</li>
</ul>
<p><img src="/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_3.png" alt="이미지"/></p>
<h2>결론</h2>
<p>Unity에서 C#을 사용하여 세이브 게임 기능을 구현하면 게임 상태와 플레이어 진행 상황을 효과적으로 관리할 수 있는 다양한 방법을 제공합니다. 로컬 또는 원격 저장소를 사용하더라도 각 방법은 보안과 플레이어 개인 정보 보호와 관련하여 장단점이 있습니다. Unity의 직렬화 기능을 이해하고 활용함으로써, 개발자는 플레이어에게 원활하고 안전한 게임 경험을 제공할 수 있습니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"게임 개발 시작하기 게임 데이터 저장","description":"","date":"2024-05-16 03:38","slug":"2024-05-16-BeginningGameDevelopmentSavingGameData","content":"\n\n## Unity에서 C#을 활용한 저장 게임 기능 구현하기: 메소드, 저장소, 그리고 개인정보 보호\n\n![게임 개발 데이터 저장하기](/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png)\n\n안녕하세요! 플레이어 경험을 향상시키고 게임 진행 상태를 보장하기 위해 견고한 저장 게임 시스템은 필수입니다. Unity와 C#을 결합하면 다양한 저장 및 불러오기 기능을 구현할 수 있는 유연한 환경을 제공합니다. 이 글에서는 Unity에서 직렬화 기술을 활용하여 게임 상태, 플레이어 진행 상황, 그리고 동적인 게임 요소를 저장하는 방법에 대해 다루고 있습니다. 또한 로컬 저장과 원격 파일 저장의 장단점 및 플레이어 데이터 개인정보 보호에 대한 고려 사항을 살펴봅니다.\n\n1. Unity에서의 직렬화 기술 직렬화란 객체의 상태를 저장하고 나중에 다시 생성할 수 있는 형식으로 변환하는 프로세스입니다. Unity는 게임 상태를 저장하는 데 중요한 여러 직렬화 기술을 지원합니다.\n\n\n\n키 메서드:\n\n- 이진 직렬화: System.Runtime.Serialization.Formatters.Binary 네임스페이스를 사용하여 객체를 이진 형식으로 변환합니다. 이 방법은 빠르고 효율적이지만 사람이 읽기 어려워 디버깅을 복잡하게 할 수 있습니다.\n\n```js\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing UnityEngine;\npublic static class SaveSystem\n{\n    public static void SavePlayer(PlayerData player)\n    {\n        BinaryFormatter formatter = new BinaryFormatter();\n        string path = Application.persistentDataPath + \n            \"/player.save\";\n        FileStream stream = new FileStream(path, FileMode.Create);\n        formatter.Serialize(stream, player);\n        stream.Close();\n    }\n    public static PlayerData LoadPlayer()\n    {\n        string path = Application.persistentDataPath + \n            \"/player.save\";\n        if (File.Exists(path))\n        {\n            BinaryFormatter formatter = new BinaryFormatter();\n            FileStream stream = new FileStream(path, FileMode.Open);\n            PlayerData data = formatter.Deserialize(stream) as \n                PlayerData;\n            stream.Close();\n            return data;\n        }\n        else\n        {\n            Debug.LogError(\"Save file not found in \" + path);\n            return null;\n        }\n    }\n}\n```\n\n![게임 개발 시작화면용 데이터 저장 이미지](/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_1.png)\n\n\n\n- JSON 직렬화: Unity의 JsonUtility를 사용하면 객체를 JSON 형식으로 직렬화할 수 있습니다. JSON은 사람이 읽기 쉽고 수정하기 쉬워 설정 및 설정에 적합합니다.\n\n```csharp\nusing UnityEngine;\npublic static class SaveSystem\n{\n    public static void SavePlayer(PlayerData player)\n    {\n        string json = JsonUtility.ToJson(player);\n        System.IO.File.WriteAllText(Application.persistentDataPath + \n             \"/player.json\", json);\n    }\n    public static PlayerData LoadPlayer()\n    {\n        string path = Application.persistentDataPath + \n              \"/player.json\";\n        if (System.IO.File.Exists(path))\n        {\n            string json = System.IO.File.ReadAllText(path);\n            PlayerData data = \n                 JsonUtility.FromJson\u003cPlayerData\u003e(json);\n            return data;\n        }\n        else\n        {\n            Debug.LogError(\"저장 파일을 \" + path + \"(으)로 찾을 수 없음\");\n            return null;\n        }\n    }\n}\n```\n\n![게임 데이터 저장 개발 시작](/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_2.png)\n\n2. 로컬 vs. 원격 파일 저장소: 게임의 디자인과 목표에 따라 로컬 및 원격 저장소 중 어떤 것을 선택할지 결정하는 것이 중요합니다.\n\n\n\n로컬 저장소:\n\n- 장점: 빠른 액세스, 인터넷 연결이 필요하지 않으며 데이터에 대한 완전한 제어.\n- 단점: 장치에 제한됨, 장치가 손상되거나 분실된 경우 데이터 손실 가능성, 플레이어가 조작하기 쉬울 수 있음.\n\n원격 저장소:\n\n- 장점: 모든 장치에서 액세스 가능, 데이터가 백업되어 손실 확률이 적음, 데이터 조작에 대한 보안이 높음.\n- 단점: 인터넷 연결이 필요, 서버 유지보수에 지속적인 비용, 잠재적인 개인정보 보안 문제.\n\n\n\n3. 플레이어 데이터 개인 정보 보호 저장한 게임 기능을 구현할 때 특히 원격 저장 시 개인 정보 보호는 최우선 과제여야 합니다.\n\n개인 정보 보호 규정:\n\n- 암호화: 저장된 데이터를 암호화하면 전송 중 및 휴식 상태에서 민감한 정보를 보호할 수 있습니다.\n- 규정 준수: 게임은 플레이어 데이터를 저장하고 사용하는 방법을 규제하는 유럽의 GDPR과 같은 법적 기준을 준수해야 합니다.\n- 명확한 사용자 허가: 플레이어에게 저장되는 데이터에 대해 알리고 원하는 경우 원격으로 데이터를 저장하지 않도록 선택할 수 있도록 허용하세요.\n\n![이미지](/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_3.png)\n\n\n\n## 결론\n\nUnity에서 C#을 사용하여 세이브 게임 기능을 구현하면 게임 상태와 플레이어 진행 상황을 효과적으로 관리할 수 있는 다양한 방법을 제공합니다. 로컬 또는 원격 저장소를 사용하더라도 각 방법은 보안과 플레이어 개인 정보 보호와 관련하여 장단점이 있습니다. Unity의 직렬화 기능을 이해하고 활용함으로써, 개발자는 플레이어에게 원활하고 안전한 게임 경험을 제공할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png"},"coverImage":"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    img: \"img\",\n    ol: \"ol\",\n    li: \"li\",\n    ul: \"ul\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"Unity에서 C#을 활용한 저장 게임 기능 구현하기: 메소드, 저장소, 그리고 개인정보 보호\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png\",\n        alt: \"게임 개발 데이터 저장하기\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"안녕하세요! 플레이어 경험을 향상시키고 게임 진행 상태를 보장하기 위해 견고한 저장 게임 시스템은 필수입니다. Unity와 C#을 결합하면 다양한 저장 및 불러오기 기능을 구현할 수 있는 유연한 환경을 제공합니다. 이 글에서는 Unity에서 직렬화 기술을 활용하여 게임 상태, 플레이어 진행 상황, 그리고 동적인 게임 요소를 저장하는 방법에 대해 다루고 있습니다. 또한 로컬 저장과 원격 파일 저장의 장단점 및 플레이어 데이터 개인정보 보호에 대한 고려 사항을 살펴봅니다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Unity에서의 직렬화 기술 직렬화란 객체의 상태를 저장하고 나중에 다시 생성할 수 있는 형식으로 변환하는 프로세스입니다. Unity는 게임 상태를 저장하는 데 중요한 여러 직렬화 기술을 지원합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"키 메서드:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이진 직렬화: System.Runtime.Serialization.Formatters.Binary 네임스페이스를 사용하여 객체를 이진 형식으로 변환합니다. 이 방법은 빠르고 효율적이지만 사람이 읽기 어려워 디버깅을 복잡하게 할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"using \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"System\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"IO\"\n        }), \";\\nusing \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"System\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Runtime\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Serialization\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Formatters\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Binary\"\n        }), \";\\nusing \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"UnityEngine\"\n        }), \";\\npublic \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SaveSystem\"\n        }), \"\\n{\\n    public \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"SavePlayer\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PlayerData\"\n        }), \" player)\\n    {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"BinaryFormatter\"\n        }), \" formatter = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"BinaryFormatter\"\n        }), \"();\\n        string path = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Application\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"persistentDataPath\"\n        }), \" + \\n            \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/player.save\\\"\"\n        }), \";\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FileStream\"\n        }), \" stream = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FileStream\"\n        }), \"(path, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FileMode\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Create\"\n        }), \");\\n        formatter.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Serialize\"\n        }), \"(stream, player);\\n        stream.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Close\"\n        }), \"();\\n    }\\n    public \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PlayerData\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"LoadPlayer\"\n        }), \"()\\n    {\\n        string path = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Application\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"persistentDataPath\"\n        }), \" + \\n            \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/player.save\\\"\"\n        }), \";\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"File\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Exists\"\n        }), \"(path))\\n        {\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"BinaryFormatter\"\n        }), \" formatter = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"BinaryFormatter\"\n        }), \"();\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FileStream\"\n        }), \" stream = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FileStream\"\n        }), \"(path, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FileMode\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Open\"\n        }), \");\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PlayerData\"\n        }), \" data = formatter.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Deserialize\"\n        }), \"(stream) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \\n                \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PlayerData\"\n        }), \";\\n            stream.\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Close\"\n        }), \"();\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" data;\\n        }\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \"\\n        {\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Debug\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"LogError\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Save file not found in \\\"\"\n        }), \" + path);\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \";\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_1.png\",\n        alt: \"게임 개발 시작화면용 데이터 저장 이미지\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"JSON 직렬화: Unity의 JsonUtility를 사용하면 객체를 JSON 형식으로 직렬화할 수 있습니다. JSON은 사람이 읽기 쉽고 수정하기 쉬워 설정 및 설정에 적합합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-csharp\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"using\"\n        }), \" UnityEngine;\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title\",\n          children: \"SaveSystem\"\n        }), \"\\n{\\n    \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"static\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"SavePlayer\"\n          }), \"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"PlayerData player\"\n          }), \")\"]\n        }), \"\\n    {\\n        \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"string\"\n        }), \" json = JsonUtility.ToJson(player);\\n        System.IO.File.WriteAllText(Application.persistentDataPath + \\n             \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/player.json\\\"\"\n        }), \", json);\\n    }\\n    \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"static\"\n          }), \" PlayerData \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"LoadPlayer\"\n          }), \"()\"]\n        }), \"\\n    {\\n        \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"string\"\n        }), \" path = Application.persistentDataPath + \\n              \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/player.json\\\"\"\n        }), \";\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (System.IO.File.Exists(path))\\n        {\\n            \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"string\"\n        }), \" json = System.IO.File.ReadAllText(path);\\n            PlayerData data = \\n                 JsonUtility.FromJson\u003cPlayerData\u003e(json);\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" data;\\n        }\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \"\\n        {\\n            Debug.LogError(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"저장 파일을 \\\"\"\n        }), \" + path + \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"(으)로 찾을 수 없음\\\"\"\n        }), \");\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \";\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_2.png\",\n        alt: \"게임 데이터 저장 개발 시작\"\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"로컬 vs. 원격 파일 저장소: 게임의 디자인과 목표에 따라 로컬 및 원격 저장소 중 어떤 것을 선택할지 결정하는 것이 중요합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"로컬 저장소:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"장점: 빠른 액세스, 인터넷 연결이 필요하지 않으며 데이터에 대한 완전한 제어.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"단점: 장치에 제한됨, 장치가 손상되거나 분실된 경우 데이터 손실 가능성, 플레이어가 조작하기 쉬울 수 있음.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"원격 저장소:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"장점: 모든 장치에서 액세스 가능, 데이터가 백업되어 손실 확률이 적음, 데이터 조작에 대한 보안이 높음.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"단점: 인터넷 연결이 필요, 서버 유지보수에 지속적인 비용, 잠재적인 개인정보 보안 문제.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"플레이어 데이터 개인 정보 보호 저장한 게임 기능을 구현할 때 특히 원격 저장 시 개인 정보 보호는 최우선 과제여야 합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"개인 정보 보호 규정:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"암호화: 저장된 데이터를 암호화하면 전송 중 및 휴식 상태에서 민감한 정보를 보호할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"규정 준수: 게임은 플레이어 데이터를 저장하고 사용하는 방법을 규제하는 유럽의 GDPR과 같은 법적 기준을 준수해야 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"명확한 사용자 허가: 플레이어에게 저장되는 데이터에 대해 알리고 원하는 경우 원격으로 데이터를 저장하지 않도록 선택할 수 있도록 허용하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_3.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Unity에서 C#을 사용하여 세이브 게임 기능을 구현하면 게임 상태와 플레이어 진행 상황을 효과적으로 관리할 수 있는 다양한 방법을 제공합니다. 로컬 또는 원격 저장소를 사용하더라도 각 방법은 보안과 플레이어 개인 정보 보호와 관련하여 장단점이 있습니다. Unity의 직렬화 기능을 이해하고 활용함으로써, 개발자는 플레이어에게 원활하고 안전한 게임 경험을 제공할 수 있습니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-16-BeginningGameDevelopmentSavingGameData"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>