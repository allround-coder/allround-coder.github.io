<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>게임 개발 시작하기 게임 데이터 저장 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-16-BeginningGameDevelopmentSavingGameData" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="게임 개발 시작하기 게임 데이터 저장 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="게임 개발 시작하기 게임 데이터 저장 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-16-BeginningGameDevelopmentSavingGameData" data-gatsby-head="true"/><meta name="twitter:title" content="게임 개발 시작하기 게임 데이터 저장 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-16 03:38" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">게임 개발 시작하기 게임 데이터 저장</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="게임 개발 시작하기 게임 데이터 저장" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 16, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-16-BeginningGameDevelopmentSavingGameData&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>Unity에서 C#을 활용한 저장 게임 기능 구현하기: 메소드, 저장소, 그리고 개인정보 보호</h2>
<p><img src="/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png" alt="게임 개발 데이터 저장하기"></p>
<p>안녕하세요! 플레이어 경험을 향상시키고 게임 진행 상태를 보장하기 위해 견고한 저장 게임 시스템은 필수입니다. Unity와 C#을 결합하면 다양한 저장 및 불러오기 기능을 구현할 수 있는 유연한 환경을 제공합니다. 이 글에서는 Unity에서 직렬화 기술을 활용하여 게임 상태, 플레이어 진행 상황, 그리고 동적인 게임 요소를 저장하는 방법에 대해 다루고 있습니다. 또한 로컬 저장과 원격 파일 저장의 장단점 및 플레이어 데이터 개인정보 보호에 대한 고려 사항을 살펴봅니다.</p>
<ol>
<li>Unity에서의 직렬화 기술 직렬화란 객체의 상태를 저장하고 나중에 다시 생성할 수 있는 형식으로 변환하는 프로세스입니다. Unity는 게임 상태를 저장하는 데 중요한 여러 직렬화 기술을 지원합니다.</li>
</ol>
<p>키 메서드:</p>
<ul>
<li>이진 직렬화: System.Runtime.Serialization.Formatters.Binary 네임스페이스를 사용하여 객체를 이진 형식으로 변환합니다. 이 방법은 빠르고 효율적이지만 사람이 읽기 어려워 디버깅을 복잡하게 할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js">using <span class="hljs-title class_">System</span>.<span class="hljs-property">IO</span>;
using <span class="hljs-title class_">System</span>.<span class="hljs-property">Runtime</span>.<span class="hljs-property">Serialization</span>.<span class="hljs-property">Formatters</span>.<span class="hljs-property">Binary</span>;
using <span class="hljs-title class_">UnityEngine</span>;
public <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveSystem</span>
{
    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title class_">SavePlayer</span>(<span class="hljs-title class_">PlayerData</span> player)
    {
        <span class="hljs-title class_">BinaryFormatter</span> formatter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryFormatter</span>();
        string path = <span class="hljs-title class_">Application</span>.<span class="hljs-property">persistentDataPath</span> + 
            <span class="hljs-string">"/player.save"</span>;
        <span class="hljs-title class_">FileStream</span> stream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileStream</span>(path, <span class="hljs-title class_">FileMode</span>.<span class="hljs-property">Create</span>);
        formatter.<span class="hljs-title class_">Serialize</span>(stream, player);
        stream.<span class="hljs-title class_">Close</span>();
    }
    public <span class="hljs-keyword">static</span> <span class="hljs-title class_">PlayerData</span> <span class="hljs-title class_">LoadPlayer</span>()
    {
        string path = <span class="hljs-title class_">Application</span>.<span class="hljs-property">persistentDataPath</span> + 
            <span class="hljs-string">"/player.save"</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">File</span>.<span class="hljs-title class_">Exists</span>(path))
        {
            <span class="hljs-title class_">BinaryFormatter</span> formatter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryFormatter</span>();
            <span class="hljs-title class_">FileStream</span> stream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileStream</span>(path, <span class="hljs-title class_">FileMode</span>.<span class="hljs-property">Open</span>);
            <span class="hljs-title class_">PlayerData</span> data = formatter.<span class="hljs-title class_">Deserialize</span>(stream) <span class="hljs-keyword">as</span> 
                <span class="hljs-title class_">PlayerData</span>;
            stream.<span class="hljs-title class_">Close</span>();
            <span class="hljs-keyword">return</span> data;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-title class_">Debug</span>.<span class="hljs-title class_">LogError</span>(<span class="hljs-string">"Save file not found in "</span> + path);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    }
}
</code></pre>
<p><img src="/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_1.png" alt="게임 개발 시작화면용 데이터 저장 이미지"></p>
<ul>
<li>JSON 직렬화: Unity의 JsonUtility를 사용하면 객체를 JSON 형식으로 직렬화할 수 있습니다. JSON은 사람이 읽기 쉽고 수정하기 쉬워 설정 및 설정에 적합합니다.</li>
</ul>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SaveSystem</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SavePlayer</span>(<span class="hljs-params">PlayerData player</span>)</span>
    {
        <span class="hljs-built_in">string</span> json = JsonUtility.ToJson(player);
        System.IO.File.WriteAllText(Application.persistentDataPath + 
             <span class="hljs-string">"/player.json"</span>, json);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PlayerData <span class="hljs-title">LoadPlayer</span>()</span>
    {
        <span class="hljs-built_in">string</span> path = Application.persistentDataPath + 
              <span class="hljs-string">"/player.json"</span>;
        <span class="hljs-keyword">if</span> (System.IO.File.Exists(path))
        {
            <span class="hljs-built_in">string</span> json = System.IO.File.ReadAllText(path);
            PlayerData data = 
                 JsonUtility.FromJson&#x3C;PlayerData>(json);
            <span class="hljs-keyword">return</span> data;
        }
        <span class="hljs-keyword">else</span>
        {
            Debug.LogError(<span class="hljs-string">"저장 파일을 "</span> + path + <span class="hljs-string">"(으)로 찾을 수 없음"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    }
}
</code></pre>
<p><img src="/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_2.png" alt="게임 데이터 저장 개발 시작"></p>
<ol start="2">
<li>로컬 vs. 원격 파일 저장소: 게임의 디자인과 목표에 따라 로컬 및 원격 저장소 중 어떤 것을 선택할지 결정하는 것이 중요합니다.</li>
</ol>
<p>로컬 저장소:</p>
<ul>
<li>장점: 빠른 액세스, 인터넷 연결이 필요하지 않으며 데이터에 대한 완전한 제어.</li>
<li>단점: 장치에 제한됨, 장치가 손상되거나 분실된 경우 데이터 손실 가능성, 플레이어가 조작하기 쉬울 수 있음.</li>
</ul>
<p>원격 저장소:</p>
<ul>
<li>장점: 모든 장치에서 액세스 가능, 데이터가 백업되어 손실 확률이 적음, 데이터 조작에 대한 보안이 높음.</li>
<li>단점: 인터넷 연결이 필요, 서버 유지보수에 지속적인 비용, 잠재적인 개인정보 보안 문제.</li>
</ul>
<ol start="3">
<li>플레이어 데이터 개인 정보 보호 저장한 게임 기능을 구현할 때 특히 원격 저장 시 개인 정보 보호는 최우선 과제여야 합니다.</li>
</ol>
<p>개인 정보 보호 규정:</p>
<ul>
<li>암호화: 저장된 데이터를 암호화하면 전송 중 및 휴식 상태에서 민감한 정보를 보호할 수 있습니다.</li>
<li>규정 준수: 게임은 플레이어 데이터를 저장하고 사용하는 방법을 규제하는 유럽의 GDPR과 같은 법적 기준을 준수해야 합니다.</li>
<li>명확한 사용자 허가: 플레이어에게 저장되는 데이터에 대해 알리고 원하는 경우 원격으로 데이터를 저장하지 않도록 선택할 수 있도록 허용하세요.</li>
</ul>
<p><img src="/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_3.png" alt="이미지"></p>
<h2>결론</h2>
<p>Unity에서 C#을 사용하여 세이브 게임 기능을 구현하면 게임 상태와 플레이어 진행 상황을 효과적으로 관리할 수 있는 다양한 방법을 제공합니다. 로컬 또는 원격 저장소를 사용하더라도 각 방법은 보안과 플레이어 개인 정보 보호와 관련하여 장단점이 있습니다. Unity의 직렬화 기능을 이해하고 활용함으로써, 개발자는 플레이어에게 원활하고 안전한 게임 경험을 제공할 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"게임 개발 시작하기 게임 데이터 저장","description":"","date":"2024-05-16 03:38","slug":"2024-05-16-BeginningGameDevelopmentSavingGameData","content":"\n\n## Unity에서 C#을 활용한 저장 게임 기능 구현하기: 메소드, 저장소, 그리고 개인정보 보호\n\n![게임 개발 데이터 저장하기](/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png)\n\n안녕하세요! 플레이어 경험을 향상시키고 게임 진행 상태를 보장하기 위해 견고한 저장 게임 시스템은 필수입니다. Unity와 C#을 결합하면 다양한 저장 및 불러오기 기능을 구현할 수 있는 유연한 환경을 제공합니다. 이 글에서는 Unity에서 직렬화 기술을 활용하여 게임 상태, 플레이어 진행 상황, 그리고 동적인 게임 요소를 저장하는 방법에 대해 다루고 있습니다. 또한 로컬 저장과 원격 파일 저장의 장단점 및 플레이어 데이터 개인정보 보호에 대한 고려 사항을 살펴봅니다.\n\n1. Unity에서의 직렬화 기술 직렬화란 객체의 상태를 저장하고 나중에 다시 생성할 수 있는 형식으로 변환하는 프로세스입니다. Unity는 게임 상태를 저장하는 데 중요한 여러 직렬화 기술을 지원합니다.\n\n\n\n키 메서드:\n\n- 이진 직렬화: System.Runtime.Serialization.Formatters.Binary 네임스페이스를 사용하여 객체를 이진 형식으로 변환합니다. 이 방법은 빠르고 효율적이지만 사람이 읽기 어려워 디버깅을 복잡하게 할 수 있습니다.\n\n```js\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing UnityEngine;\npublic static class SaveSystem\n{\n    public static void SavePlayer(PlayerData player)\n    {\n        BinaryFormatter formatter = new BinaryFormatter();\n        string path = Application.persistentDataPath + \n            \"/player.save\";\n        FileStream stream = new FileStream(path, FileMode.Create);\n        formatter.Serialize(stream, player);\n        stream.Close();\n    }\n    public static PlayerData LoadPlayer()\n    {\n        string path = Application.persistentDataPath + \n            \"/player.save\";\n        if (File.Exists(path))\n        {\n            BinaryFormatter formatter = new BinaryFormatter();\n            FileStream stream = new FileStream(path, FileMode.Open);\n            PlayerData data = formatter.Deserialize(stream) as \n                PlayerData;\n            stream.Close();\n            return data;\n        }\n        else\n        {\n            Debug.LogError(\"Save file not found in \" + path);\n            return null;\n        }\n    }\n}\n```\n\n![게임 개발 시작화면용 데이터 저장 이미지](/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_1.png)\n\n\n\n- JSON 직렬화: Unity의 JsonUtility를 사용하면 객체를 JSON 형식으로 직렬화할 수 있습니다. JSON은 사람이 읽기 쉽고 수정하기 쉬워 설정 및 설정에 적합합니다.\n\n```csharp\nusing UnityEngine;\npublic static class SaveSystem\n{\n    public static void SavePlayer(PlayerData player)\n    {\n        string json = JsonUtility.ToJson(player);\n        System.IO.File.WriteAllText(Application.persistentDataPath + \n             \"/player.json\", json);\n    }\n    public static PlayerData LoadPlayer()\n    {\n        string path = Application.persistentDataPath + \n              \"/player.json\";\n        if (System.IO.File.Exists(path))\n        {\n            string json = System.IO.File.ReadAllText(path);\n            PlayerData data = \n                 JsonUtility.FromJson\u003cPlayerData\u003e(json);\n            return data;\n        }\n        else\n        {\n            Debug.LogError(\"저장 파일을 \" + path + \"(으)로 찾을 수 없음\");\n            return null;\n        }\n    }\n}\n```\n\n![게임 데이터 저장 개발 시작](/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_2.png)\n\n2. 로컬 vs. 원격 파일 저장소: 게임의 디자인과 목표에 따라 로컬 및 원격 저장소 중 어떤 것을 선택할지 결정하는 것이 중요합니다.\n\n\n\n로컬 저장소:\n\n- 장점: 빠른 액세스, 인터넷 연결이 필요하지 않으며 데이터에 대한 완전한 제어.\n- 단점: 장치에 제한됨, 장치가 손상되거나 분실된 경우 데이터 손실 가능성, 플레이어가 조작하기 쉬울 수 있음.\n\n원격 저장소:\n\n- 장점: 모든 장치에서 액세스 가능, 데이터가 백업되어 손실 확률이 적음, 데이터 조작에 대한 보안이 높음.\n- 단점: 인터넷 연결이 필요, 서버 유지보수에 지속적인 비용, 잠재적인 개인정보 보안 문제.\n\n\n\n3. 플레이어 데이터 개인 정보 보호 저장한 게임 기능을 구현할 때 특히 원격 저장 시 개인 정보 보호는 최우선 과제여야 합니다.\n\n개인 정보 보호 규정:\n\n- 암호화: 저장된 데이터를 암호화하면 전송 중 및 휴식 상태에서 민감한 정보를 보호할 수 있습니다.\n- 규정 준수: 게임은 플레이어 데이터를 저장하고 사용하는 방법을 규제하는 유럽의 GDPR과 같은 법적 기준을 준수해야 합니다.\n- 명확한 사용자 허가: 플레이어에게 저장되는 데이터에 대해 알리고 원하는 경우 원격으로 데이터를 저장하지 않도록 선택할 수 있도록 허용하세요.\n\n![이미지](/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_3.png)\n\n\n\n## 결론\n\nUnity에서 C#을 사용하여 세이브 게임 기능을 구현하면 게임 상태와 플레이어 진행 상황을 효과적으로 관리할 수 있는 다양한 방법을 제공합니다. 로컬 또는 원격 저장소를 사용하더라도 각 방법은 보안과 플레이어 개인 정보 보호와 관련하여 장단점이 있습니다. Unity의 직렬화 기능을 이해하고 활용함으로써, 개발자는 플레이어에게 원활하고 안전한 게임 경험을 제공할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png"},"coverImage":"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003eUnity에서 C#을 활용한 저장 게임 기능 구현하기: 메소드, 저장소, 그리고 개인정보 보호\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_0.png\" alt=\"게임 개발 데이터 저장하기\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요! 플레이어 경험을 향상시키고 게임 진행 상태를 보장하기 위해 견고한 저장 게임 시스템은 필수입니다. Unity와 C#을 결합하면 다양한 저장 및 불러오기 기능을 구현할 수 있는 유연한 환경을 제공합니다. 이 글에서는 Unity에서 직렬화 기술을 활용하여 게임 상태, 플레이어 진행 상황, 그리고 동적인 게임 요소를 저장하는 방법에 대해 다루고 있습니다. 또한 로컬 저장과 원격 파일 저장의 장단점 및 플레이어 데이터 개인정보 보호에 대한 고려 사항을 살펴봅니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eUnity에서의 직렬화 기술 직렬화란 객체의 상태를 저장하고 나중에 다시 생성할 수 있는 형식으로 변환하는 프로세스입니다. Unity는 게임 상태를 저장하는 데 중요한 여러 직렬화 기술을 지원합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e키 메서드:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이진 직렬화: System.Runtime.Serialization.Formatters.Binary 네임스페이스를 사용하여 객체를 이진 형식으로 변환합니다. 이 방법은 빠르고 효율적이지만 사람이 읽기 어려워 디버깅을 복잡하게 할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eusing \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eIO\u003c/span\u003e;\nusing \u003cspan class=\"hljs-title class_\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eRuntime\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eSerialization\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFormatters\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBinary\u003c/span\u003e;\nusing \u003cspan class=\"hljs-title class_\"\u003eUnityEngine\u003c/span\u003e;\npublic \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSaveSystem\u003c/span\u003e\n{\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSavePlayer\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePlayerData\u003c/span\u003e player)\n    {\n        \u003cspan class=\"hljs-title class_\"\u003eBinaryFormatter\u003c/span\u003e formatter = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBinaryFormatter\u003c/span\u003e();\n        string path = \u003cspan class=\"hljs-title class_\"\u003eApplication\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003epersistentDataPath\u003c/span\u003e + \n            \u003cspan class=\"hljs-string\"\u003e\"/player.save\"\u003c/span\u003e;\n        \u003cspan class=\"hljs-title class_\"\u003eFileStream\u003c/span\u003e stream = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFileStream\u003c/span\u003e(path, \u003cspan class=\"hljs-title class_\"\u003eFileMode\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCreate\u003c/span\u003e);\n        formatter.\u003cspan class=\"hljs-title class_\"\u003eSerialize\u003c/span\u003e(stream, player);\n        stream.\u003cspan class=\"hljs-title class_\"\u003eClose\u003c/span\u003e();\n    }\n    public \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePlayerData\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLoadPlayer\u003c/span\u003e()\n    {\n        string path = \u003cspan class=\"hljs-title class_\"\u003eApplication\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003epersistentDataPath\u003c/span\u003e + \n            \u003cspan class=\"hljs-string\"\u003e\"/player.save\"\u003c/span\u003e;\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title class_\"\u003eFile\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eExists\u003c/span\u003e(path))\n        {\n            \u003cspan class=\"hljs-title class_\"\u003eBinaryFormatter\u003c/span\u003e formatter = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBinaryFormatter\u003c/span\u003e();\n            \u003cspan class=\"hljs-title class_\"\u003eFileStream\u003c/span\u003e stream = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFileStream\u003c/span\u003e(path, \u003cspan class=\"hljs-title class_\"\u003eFileMode\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eOpen\u003c/span\u003e);\n            \u003cspan class=\"hljs-title class_\"\u003ePlayerData\u003c/span\u003e data = formatter.\u003cspan class=\"hljs-title class_\"\u003eDeserialize\u003c/span\u003e(stream) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \n                \u003cspan class=\"hljs-title class_\"\u003ePlayerData\u003c/span\u003e;\n            stream.\u003cspan class=\"hljs-title class_\"\u003eClose\u003c/span\u003e();\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e data;\n        }\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e\n        {\n            \u003cspan class=\"hljs-title class_\"\u003eDebug\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eLogError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Save file not found in \"\u003c/span\u003e + path);\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_1.png\" alt=\"게임 개발 시작화면용 데이터 저장 이미지\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJSON 직렬화: Unity의 JsonUtility를 사용하면 객체를 JSON 형식으로 직렬화할 수 있습니다. JSON은 사람이 읽기 쉽고 수정하기 쉬워 설정 및 설정에 적합합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-csharp\"\u003e\u003cspan class=\"hljs-keyword\"\u003eusing\u003c/span\u003e UnityEngine;\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eSaveSystem\u003c/span\u003e\n{\n    \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eSavePlayer\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ePlayerData player\u003c/span\u003e)\u003c/span\u003e\n    {\n        \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e json = JsonUtility.ToJson(player);\n        System.IO.File.WriteAllText(Application.persistentDataPath + \n             \u003cspan class=\"hljs-string\"\u003e\"/player.json\"\u003c/span\u003e, json);\n    }\n    \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e PlayerData \u003cspan class=\"hljs-title\"\u003eLoadPlayer\u003c/span\u003e()\u003c/span\u003e\n    {\n        \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e path = Application.persistentDataPath + \n              \u003cspan class=\"hljs-string\"\u003e\"/player.json\"\u003c/span\u003e;\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (System.IO.File.Exists(path))\n        {\n            \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e json = System.IO.File.ReadAllText(path);\n            PlayerData data = \n                 JsonUtility.FromJson\u0026#x3C;PlayerData\u003e(json);\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e data;\n        }\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e\n        {\n            Debug.LogError(\u003cspan class=\"hljs-string\"\u003e\"저장 파일을 \"\u003c/span\u003e + path + \u003cspan class=\"hljs-string\"\u003e\"(으)로 찾을 수 없음\"\u003c/span\u003e);\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_2.png\" alt=\"게임 데이터 저장 개발 시작\"\u003e\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e로컬 vs. 원격 파일 저장소: 게임의 디자인과 목표에 따라 로컬 및 원격 저장소 중 어떤 것을 선택할지 결정하는 것이 중요합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e로컬 저장소:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e장점: 빠른 액세스, 인터넷 연결이 필요하지 않으며 데이터에 대한 완전한 제어.\u003c/li\u003e\n\u003cli\u003e단점: 장치에 제한됨, 장치가 손상되거나 분실된 경우 데이터 손실 가능성, 플레이어가 조작하기 쉬울 수 있음.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e원격 저장소:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e장점: 모든 장치에서 액세스 가능, 데이터가 백업되어 손실 확률이 적음, 데이터 조작에 대한 보안이 높음.\u003c/li\u003e\n\u003cli\u003e단점: 인터넷 연결이 필요, 서버 유지보수에 지속적인 비용, 잠재적인 개인정보 보안 문제.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e플레이어 데이터 개인 정보 보호 저장한 게임 기능을 구현할 때 특히 원격 저장 시 개인 정보 보호는 최우선 과제여야 합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e개인 정보 보호 규정:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e암호화: 저장된 데이터를 암호화하면 전송 중 및 휴식 상태에서 민감한 정보를 보호할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e규정 준수: 게임은 플레이어 데이터를 저장하고 사용하는 방법을 규제하는 유럽의 GDPR과 같은 법적 기준을 준수해야 합니다.\u003c/li\u003e\n\u003cli\u003e명확한 사용자 허가: 플레이어에게 저장되는 데이터에 대해 알리고 원하는 경우 원격으로 데이터를 저장하지 않도록 선택할 수 있도록 허용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-BeginningGameDevelopmentSavingGameData_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003eUnity에서 C#을 사용하여 세이브 게임 기능을 구현하면 게임 상태와 플레이어 진행 상황을 효과적으로 관리할 수 있는 다양한 방법을 제공합니다. 로컬 또는 원격 저장소를 사용하더라도 각 방법은 보안과 플레이어 개인 정보 보호와 관련하여 장단점이 있습니다. Unity의 직렬화 기능을 이해하고 활용함으로써, 개발자는 플레이어에게 원활하고 안전한 게임 경험을 제공할 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-16-BeginningGameDevelopmentSavingGameData"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>