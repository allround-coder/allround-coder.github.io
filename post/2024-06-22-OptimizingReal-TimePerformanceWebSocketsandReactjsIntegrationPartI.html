<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>실시간 성능 최적화 WebSockets와 Reactjs 통합하는 방법 Part I | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="실시간 성능 최적화 WebSockets와 Reactjs 통합하는 방법 Part I | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="실시간 성능 최적화 WebSockets와 Reactjs 통합하는 방법 Part I | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI" data-gatsby-head="true"/><meta name="twitter:title" content="실시간 성능 최적화 WebSockets와 Reactjs 통합하는 방법 Part I | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 03:04" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">실시간 성능 최적화 WebSockets와 Reactjs 통합하는 방법 Part I</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="실시간 성능 최적화 WebSockets와 Reactjs 통합하는 방법 Part I" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_0.png">
<p>요즘에는 많은 양의 데이터가 있는데, 그것을 빨리 얻고 모든 것이 잘 작동하는 것이 정말 중요해요. 하지만 때로는 예전 방식(HTTP 요청)을 사용해서 계속해서 데이터를 요청하는 것은 오늘날 앱에는 충분히 빠르지 않을 수도 있어요. 그런 상황에서 WebSockets가 등장해요. WebSockets는 거의 즉시 업데이트를 보낼 수 있어 마치 마법 같은 기술이에요. 이를 통해 최신 정보를 곧바로 받아볼 수 있어요.</p>
<p>그리고 React와 함께 사용한다면, 실시간으로 정보를 얻는 새로운 방식이 열립니다. React는 정말 빠른데, 너무 많은 것을 변경하면 신중하지 않으면, 앱이 느려지거나 작동을 멈출 수도 있어요. 그래서 React에서 일어나는 변경 사항을 신중하게 다루는 것은 중요해요, 특히 WebSockets를 사용할 때는요.</p>
<p>우선, 이를 최적화하지 않은 방법에 대해 먼저 이야기해볼게요. 나중에는 React와 WebSockets를 사용하는 최적화된 방법에 대해 더 깊이 탐구해볼 거에요. 기대해주세요, 우리는 응용 프로그램의 성능과 효율성을 극대화하기 위한 WebSockets를 활용하는 최상의 방법에 대해 탐구할 거예요.</p>
<div class="content-ad"></div>
<h1>먼저 WebSocket이란 무엇인가요? 웹소켓 이해하기</h1>
<p>웹소켓은 단일, 오래 지속되는 연결을 통해 전이편된 통신 채널을 제공합니다. 이를 통해 클라이언트(브라우저)와 서버 간 실시간 데이터 교환이 가능해집니다. 전통적인 HTTP 요청과는 달리 웹소켓은 클라이언트와 서버가 모두 통신을 시작할 수 있어 즉각적인 업데이트가 필요한 응용 프로그램에 이상적입니다.</p>
<p>실시간 데이터 스트리밍의 장점</p>
<ul>
<li>효율성 향상: 웹소켓을 통해 데이터 업데이트가 원활해집니다. 한 번 연결되면 데이터가 지연 없이 흘러가며 지속적인 요청 시간을 제거합니다.</li>
<li>즉각적인 업데이트: 웹소켓을 통해 즉각적으로 업데이트를 받을 수 있습니다. 시장 동향이나 암호화폐 가격 추이를 추적하는 경우에도 신속한 결정을 위해 항상 최신 정보를 얻을 수 있습니다.</li>
<li>양방향 대화: 웹소켓을 이용하면 서버와 클라이언트가 즉각적으로 양방향 대화를 할 수 있습니다. 모두가 듣고 듣는 빠른 대화와 같아서 팀워크가 쉬워집니다.</li>
<li>확장성: 데이터 요구가 증가함에 따라 웹소켓은 부하를 다룰 수 있습니다. 연결을 열어두기 때문에 많은 사용자가 있더라도 원활하게 작동합니다.</li>
</ul>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_1.png">
<h1>React에서 WebSockets 사용하기</h1>
<p>이제, 웹소켓의 강점을 React 애플리케이션으로 가져올 수 있는 "react-use-websocket"이라는 유용한 도구에 대해 이야기해보겠습니다. 이 라이브러리는 웹소켓을 React 컴포넌트에 통합하는 과정을 단순화하여 심지어 초보자들도 사용할 수 있게 해줍니다.</p>
<p>"react-use-websocket"을 사용하면 WebSocket 연결을 쉽게 설정할 수 있고, 메시지를 보내고 받을 수 있으며, 연결 오류를 처리할 수 있습니다 - 모두 React 컴포넌트 내에서 가능합니다. 시작하는 방법은 다음과 같습니다:</p>
<div class="content-ad"></div>
<ul>
<li>설치: 라이브러리를 설치하려면 npm 또는 yarn을 사용하여 다음과 같이 시작하세요:</li>
</ul>
<pre><code class="hljs language-js">npm install react-use-websocket
</code></pre>
<p>또는</p>
<pre><code class="hljs language-js">yarn add react-use-websocket
</code></pre>
<div class="content-ad"></div>
<ol start="2">
<li>사용 방법: 설치한 후에는 React 컴포넌트에서 useWebSocket 훅을 가져와 사용할 수 있습니다. 아래는 기본 예제입니다:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { useWebSocket } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-use-websocket'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">MyComponent</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> { sendMessage, lastMessage } = <span class="hljs-title function_">useWebSocket</span>(<span class="hljs-string">'wss://example.com/ws'</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-title function_">sendMessage</span>(<span class="hljs-string">'Hello, WebSocket!'</span>);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>></span>메시지 보내기<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>최근 메시지: {lastMessage ? lastMessage.data : '없음'}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyComponent</span>;
</code></pre>
<p>이 예제에서는 'wss://example.com/ws'로 WebSocket 연결을 설정하기 위해 useWebSocket 훅을 사용하고 있습니다. sendMessage 함수를 사용하여 메시지를 보내고, lastMessage 객체를 사용하여 최근 받은 메시지를 표시합니다.</p>
<ol start="3">
<li>이벤트 처리: "react-use-websocket"은 onOpen, onMessage, onError, onClose와 같은 다양한 WebSocket 이벤트를 처리하는 훅을 제공합니다. 이러한 훅을 사용하여 UI를 업데이트하거나 오류를 기록하는 등 다양한 WebSocket 이벤트에 기반한 작업을 수행할 수 있습니다.</li>
</ol>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { sendMessage, lastMessage, readyState } = <span class="hljs-title function_">useWebSocket</span>(<span class="hljs-string">'wss://example.com/ws'</span>, {
   <span class="hljs-attr">onOpen</span>: <span class="hljs-function">() =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'WebSocket connection opened!'</span>),
   <span class="hljs-attr">onClose</span>: <span class="hljs-function">() =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'WebSocket connection closed!'</span>),
   <span class="hljs-attr">onError</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'WebSocket error:'</span>, event),
   <span class="hljs-attr">onMessage</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Received message:'</span>, event.<span class="hljs-property">data</span>),
});
</code></pre>
<p>“리액트-유즈-웹소켓”을 사용하면 React 애플리케이션에 WebSocket을 쉽고 직관적으로 통합할 수 있습니다. 실시간 채팅 애플리케이션, 실시간 데이터 대시보드 또는 협업 도구를 구축하든, "리액트-유즈-웹소켓"을 사용하면 익숙한 React 환경에서 WebSocket의 강력함을 활용할 수 있습니다.</p>
<h1>좀 더 전체적인 예시를 살펴보겠습니다.</h1>
<p>이를 위해 cryptocompare와 같은 외부 웹소켓을 사용할 것인데, 그를 위해 무료 API 키를 생성하기 위해 계정을 생성해야 합니다. 자세한 지침은 여기를 참고하세요.</p>
<div class="content-ad"></div>
<p>API 키를 받은 후 다음 패키지를 추가하겠습니다:</p>
<pre><code class="hljs language-js">npm i react-use-websocket bootstrap react-bootstrap react-router-dom --save 
</code></pre>
<p>또는</p>
<pre><code class="hljs language-js">yarn add react-use-websocket bootstrap react-bootstrap react-router-dom
</code></pre>
<div class="content-ad"></div>
<p>부트스트랩 패키지는 스타일링을 위한 것입니다.</p>
<p>설치가 완료되면 Home.tsx 컴포넌트를 생성하겠습니다. 이 컴포넌트에는 입력 텍스트만 포함되어 있고 api 키를 제출하여 <a href="http://localhost:3000/dashboard%EB%A1%9C" rel="nofollow" target="_blank">http://localhost:3000/dashboard로</a> 리디렉션하고 api_key를 쿼리 매개변수로 추가할 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Modal</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-bootstrap/Modal"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-bootstrap/Button"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Form</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-bootstrap/Form"</span>;
<span class="hljs-keyword">import</span> { useNavigate } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">Home</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> [show, setShow] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">const</span> [apiKey, setApiKey] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">""</span>);
  <span class="hljs-keyword">const</span> navigate = <span class="hljs-title function_">useNavigate</span>();

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClose</span> = (<span class="hljs-params"></span>) => <span class="hljs-title function_">setShow</span>(<span class="hljs-literal">false</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChange</span> = (<span class="hljs-params">e: React.ChangeEvent&#x3C;HTMLInputElement></span>) => {
    <span class="hljs-title function_">setApiKey</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);
  };

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params">e: React.SyntheticEvent</span>) => {
    e.<span class="hljs-title function_">preventDefault</span>();
    <span class="hljs-title function_">navigate</span>(<span class="hljs-string">`/dashboard?api_key=<span class="hljs-subst">${apiKey}</span>`</span>);
  };
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Modal</span>
        <span class="hljs-attr">show</span>=<span class="hljs-string">{show}</span>
        <span class="hljs-attr">onHide</span>=<span class="hljs-string">{handleClose}</span>
        <span class="hljs-attr">data-bs-theme</span>=<span class="hljs-string">"dark"</span>
        <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color:</span> "<span class="hljs-attr">white</span>" }}
      ></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Modal.Header</span> <span class="hljs-attr">closeButton</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Modal.Title</span>></span>react use websocket<span class="hljs-tag">&#x3C;/<span class="hljs-name">Modal.Title</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">Modal.Header</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Modal.Body</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{handleSubmit}</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">Form.Group</span> <span class="hljs-attr">controlId</span>=<span class="hljs-string">"formBasicEmail"</span>></span>
              <span class="hljs-tag">&#x3C;<span class="hljs-name">Form.Label</span>></span>Api key:<span class="hljs-tag">&#x3C;/<span class="hljs-name">Form.Label</span>></span>
              <span class="hljs-tag">&#x3C;<span class="hljs-name">Form.Control</span>
                <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
                <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Please provide api key"</span>
                <span class="hljs-attr">value</span>=<span class="hljs-string">{apiKey}</span>
                <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleChange}</span>
              /></span>
            <span class="hljs-tag">&#x3C;/<span class="hljs-name">Form.Group</span>></span>
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">Form</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">Modal.Body</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Modal.Footer</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Button</span> <span class="hljs-attr">variant</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleSubmit}</span>></span>
            Submit
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">Button</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">Modal.Footer</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">Modal</span>></span>
    <span class="hljs-tag">&#x3C;/></span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Home</span>;
</code></pre>
<p>Dashboard.tsx 컴포넌트에는 웹소켓 응답 객체를 위한 인터페이스를 생성해야 합니다.</p>
<div class="content-ad"></div>
<p>위의 코드를 한글로 번역하면 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> interface <span class="hljs-title class_">CryptoMessage</span> {
  <span class="hljs-attr">TYPE</span>: string;
  <span class="hljs-attr">M</span>: string;
  <span class="hljs-attr">FSYM</span>: string;
  <span class="hljs-attr">TSYM</span>: string;
  <span class="hljs-attr">F</span>: string;
  <span class="hljs-variable constant_">ID</span>?: string;
  <span class="hljs-variable constant_">TS</span>?: string;
  Q?: number;
  P?: number;
  <span class="hljs-variable constant_">TOTAL</span>?: number;
  <span class="hljs-variable constant_">RTS</span>?: string;
  <span class="hljs-variable constant_">CCSEQ</span>?: number;
  <span class="hljs-variable constant_">TSNS</span>?: number;
  <span class="hljs-variable constant_">RTSNS</span>?: number;
}
</code></pre>
<p>그리고 useWebSocket 훅을 호출하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { readyState, sendJsonMessage, lastJsonMessage } =
    useWebSocket&#x3C;<span class="hljs-title class_">CryptoMessage</span>>(socketUrl, { <span class="hljs-attr">share</span>: <span class="hljs-literal">true</span> });
</code></pre>
<p>이제 readyState, sendJsonMessage, lastJsonMessage가 무엇인지 설명하겠습니다.</p>
<div class="content-ad"></div>
<p>ReadyState:</p>
<p>"useWebSocket" 훅에서 제공하는 readyState 속성은 현재 WebSocket 연결 상태를 나타냅니다. WebSocket 연결이 보류 중인지, 열린 상태인지, 닫히는 중인지 또는 닫힌 상태인지를 나타냅니다. readyState 속성은 다음 네 가지 값 중 하나를 가질 수 있는 정수 값입니다:</p>
<ul>
<li>CONNECTING (0): 이 상태는 WebSocket 연결이 설정 중인 상태를 나타냅니다. useWebSocket 훅을 초기 호출하고 WebSocket 연결을 시작할 때 연결이 성공적으로 설정될 때까지 CONNECTING 상태로 진입합니다.</li>
<li>OPEN (1): 이 상태는 WebSocket 연결이 열려 있고 메시지를 보내고 받을 준비가 된 상태를 나타냅니다. 연결이 성공적으로 설정되면 OPEN 상태로 전환되어 클라이언트와 서버 간에 양방향 통신이 가능해집니다.</li>
<li>CLOSING (2): 이 상태는 WebSocket 연결이 닫히는 중인 상태를 나타냅니다. useWebSocket 훅에서 제공하는 closeWebSocket 함수를 사용하여 WebSocket 연결을 종료하면 닫히기 전에 CLOSING 상태로 진입합니다.</li>
<li>CLOSED (3): 이 상태는 WebSocket 연결이 닫힌 상태를 나타냅니다. 연결이 서버에 의해 닫히거나 클라이언트가 명시적으로 closeWebSocket 함수를 사용하여 연결을 닫으면 발생합니다. 연결이 닫힌 후에는 새 WebSocket 연결을 초기화할 때까지 CLOSED 상태로 유지됩니다.</li>
</ul>
<div class="content-ad"></div>
<p>"useWebSocket" 라이브러리 내의 useWebSocket 훅에서 제공하는 sendJsonMessage 함수는 WebSocket 연결을 통해 JSON 형식의 메시지를 보내는 데 유용한 유틸리티 함수입니다. 이 함수는 JavaScript 객체를 JSON 문자열로 직렬화하는 번거로운 작업을 추상화하여 구조화된 데이터를 WebSocket 서버로 보내는 프로세스를 간소화합니다.</p>
<p>lastJsonMessage:</p>
<p>"useWebSocket" 라이브러리 내의 useWebSocket 훅에서 제공하는 lastJsonMessage 속성은 WebSocket 연결을 통해 수신한 JSON 형식의 최근 메시지를 나타냅니다. 이 속성을 사용하면 React 컴포넌트 내에서 받은 마지막 메시지에 포함된 데이터에 액세스하고 처리할 수 있습니다.</p>
<p>다음 코드는 현재 WebSocket 연결 상태를 UI에 표시합니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> useWebSocket, { <span class="hljs-title class_">ReadyState</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-use-websocket"</span>;
<span class="hljs-keyword">import</span> { useSearchParams } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-router-dom"</span>;

<span class="hljs-keyword">export</span> interface <span class="hljs-title class_">CryptoMessage</span> {
  <span class="hljs-attr">TYPE</span>: string;
  <span class="hljs-attr">M</span>: string;
  <span class="hljs-attr">FSYM</span>: string;
  <span class="hljs-attr">TSYM</span>: string;
  <span class="hljs-attr">F</span>: string;
  <span class="hljs-variable constant_">ID</span>?: string;
  <span class="hljs-variable constant_">TS</span>?: string;
  Q?: number;
  P?: number;
  <span class="hljs-variable constant_">TOTAL</span>?: number;
  <span class="hljs-variable constant_">RTS</span>?: string;
  <span class="hljs-variable constant_">CCSEQ</span>?: number;
  <span class="hljs-variable constant_">TSNS</span>?: number;
  <span class="hljs-variable constant_">RTSNS</span>?: number;
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">Dashboard</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> [searchParams] = <span class="hljs-title function_">useSearchParams</span>();
  <span class="hljs-keyword">const</span> api_key = searchParams.<span class="hljs-title function_">get</span>(<span class="hljs-string">"api_key"</span>);
  <span class="hljs-keyword">const</span> socketUrl = <span class="hljs-string">`wss://streamer.cryptocompare.com/v2?api_key=<span class="hljs-subst">${api_key}</span>`</span>;
  <span class="hljs-keyword">const</span> { readyState, sendJsonMessage, lastJsonMessage } =
    useWebSocket&#x3C;<span class="hljs-title class_">CryptoMessage</span>>(socketUrl, { <span class="hljs-attr">share</span>: <span class="hljs-literal">true</span> });

  <span class="hljs-keyword">const</span> connectionStatus = {
    [<span class="hljs-title class_">ReadyState</span>.<span class="hljs-property">CONNECTING</span>]: <span class="hljs-string">"연결 중"</span>,
    [<span class="hljs-title class_">ReadyState</span>.<span class="hljs-property">OPEN</span>]: <span class="hljs-string">"열림"</span>,
    [<span class="hljs-title class_">ReadyState</span>.<span class="hljs-property">CLOSING</span>]: <span class="hljs-string">"닫히는 중"</span>,
    [<span class="hljs-title class_">ReadyState</span>.<span class="hljs-property">CLOSED</span>]: <span class="hljs-string">"닫힘"</span>,
    [<span class="hljs-title class_">ReadyState</span>.<span class="hljs-property">UNINSTANTIATED</span>]: <span class="hljs-string">"미초기화"</span>,
  }[readyState];

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;></span>{connectionStatus} <span class="hljs-tag">&#x3C;/></span></span>;
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Dashboard</span>;
</code></pre>
<p>"열림" 상태를 받으면 WebSocket 서비스로 메시지를 보낼 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">if</span> (readyState === <span class="hljs-title class_">ReadyState</span>.<span class="hljs-property">OPEN</span>) {
      <span class="hljs-title function_">sendJsonMessage</span>({
        <span class="hljs-attr">action</span>: <span class="hljs-string">"SubAdd"</span>,
        <span class="hljs-attr">subs</span>: [
          <span class="hljs-string">"0~Coinbase~BTC~USD"</span>,
          <span class="hljs-string">"0~Coinbase~BTC~EUR"</span>,
          <span class="hljs-string">"0~Coinbase~ETH~USD"</span>,
          <span class="hljs-string">"0~Coinbase~ETH~EUR"</span>,
        ],
      });
    }
  }, [readyState, sendJsonMessage]);
</code></pre>
<p>sendJsonMessage 내에 있는 json 객체를 설명해보겠습니다:</p>
<div class="content-ad"></div>
<h1>작업:</h1>
<ul>
<li>해당 객체에는 값이 "SubAdd"인 action 속성이 포함되어 있습니다.</li>
<li>이는 WebSocket 서버에서 수행할 작업이 새 데이터 스트림에 구독하는 것임을 나타냅니다.</li>
</ul>
<h1>구독:</h1>
<ul>
<li>해당 객체에는 subs라는 속성이 포함되어 있으며 구독 문자열의 배열을 보유합니다.</li>
<li>각 구독 문자열은 클라이언트가 구독하려는 특정 데이터 스트림을 나타냅니다.</li>
<li>각 구독 문자열의 형식은 "0~'거래소'<del>'기초통화'</del>'견적통화'"입니다. 여기서:</li>
<li>"0": 스트리밍 데이터에 대한 구독을 나타냅니다 (역사적 데이터와 대조됨).</li>
<li>'거래소': 데이터를 제공하는 거래소의 이름을 나타냅니다 (예: "코인베이스").</li>
<li>'기초통화': 거래 페어의 기초 통화를 나타냅니다 (예: 비트코인의 경우 "BTC", 이더리움의 경우 "ETH").</li>
<li>'견적통화': 거래 페어의 견적 통화를 나타냅니다 (예: 미국 달러의 경우 "USD", 유로의 경우 "EUR").</li>
</ul>
<div class="content-ad"></div>
<p>요약하자면, 이 코드는 WebSocket 서버에게 새로운 데이터 스트리밍을 위한 구독을 추가하도록 지시합니다. subs 배열에 지정된 구독은 Coinbase 거래소의 다양한 거래 페어를 대상으로 하며, BTC/USD, BTC/EUR, ETH/USD 및 ETH/EUR 등이 포함됩니다. 이를 통해 클라이언트가 WebSocket 서버로부터 이러한 거래 페어의 실시간 업데이트를 받을 수 있게 됩니다.</p>
<p>이제 데이터를 가능한 한 빨리 받을 수 있게 되었으니, 남은 작업은 브라우저에 스트리밍 데이터를 표시하는 것 뿐입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">renderList</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-keyword">return</span> list.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">element: CryptoMessage, index: number</span>) =></span> {
      <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span>></span>
          {element.FSYM} - {element.P}
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">li</span>></span></span>
      );
    });
  };

<span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;></span>{readyState === ReadyState.OPEN? renderList() : connectionStatus} <span class="hljs-tag">&#x3C;/></span></span>;
</code></pre>
<p>각 요소에 대해, element.FSYM의 값 (암호화폐 심볼인지 ETH 또는 BTC인지)을 나타내는 JSX <code>li</code> 요소를 반환하고, 그 뒤에는 대시(-)와 element.P의 값(가격)을 나타냅니다. 결과는 다음과 같을 것입니다:</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_2.png" alt="2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_2"></p>
<p>우리 데이터를 그래프로 시각화하는 것이 훨씬 쉬울 것입니다. 이를 위해 react google charts를 설치해야 합니다.</p>
<pre><code class="hljs language-js">npm install --save react-google-charts
</code></pre>
<p>또는</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">yarn add react-google-charts
</code></pre>
<p>이후에 Chart를 가져와서 renderList 함수를 renderGraph로 변경합시다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-attr">graphData</span>: any[] = [[<span class="hljs-string">""</span>, <span class="hljs-string">"BTC"</span>, <span class="hljs-string">"ETH"</span>]];
      <span class="hljs-keyword">let</span> <span class="hljs-title class_">BTCPrice</span>;
      <span class="hljs-keyword">let</span> <span class="hljs-title class_">ETHPrice</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> element <span class="hljs-keyword">of</span> list) {
        <span class="hljs-keyword">if</span> (element.<span class="hljs-property">FSYM</span> === <span class="hljs-string">"BTC"</span>) {
          <span class="hljs-title class_">BTCPrice</span> = element.<span class="hljs-property">P</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-property">FSYM</span> === <span class="hljs-string">"ETH"</span>) {
          <span class="hljs-title class_">ETHPrice</span> = element.<span class="hljs-property">P</span>;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">BTCPrice</span> === <span class="hljs-string">"undefined"</span> || <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">ETHPrice</span> === <span class="hljs-string">"undefined"</span>) {
          <span class="hljs-keyword">continue</span>;
        } <span class="hljs-keyword">else</span> {
          graphData.<span class="hljs-title function_">push</span>([<span class="hljs-string">""</span>, <span class="hljs-title class_">BTCPrice</span>, <span class="hljs-title class_">ETHPrice</span>]);
        }
      }
      <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Chart</span>
          <span class="hljs-attr">graph_id</span>=<span class="hljs-string">"graph"</span>
          <span class="hljs-attr">chartType</span>=<span class="hljs-string">"LineChart"</span>
          <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span>
          <span class="hljs-attr">height</span>=<span class="hljs-string">"400px"</span>
          <span class="hljs-attr">data</span>=<span class="hljs-string">{graphData}</span>
          <span class="hljs-attr">options</span>=<span class="hljs-string">{options}</span>
        /></span></span>
      );
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;></span>{readyState === ReadyState.OPEN ? renderGraph() : connectionStatus} <span class="hljs-tag">&#x3C;/></span></span>
  );
</code></pre>
<p>결과는 다음과 같을 것입니다:</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_3.png">
<p>그리고 마지막으로 작동 예제가 있습니다.</p>
<h1>결론</h1>
<p>이는 웹소켓을 사용하는 매우 단순한 방법이지만 문제를 해결해야 할 두 가지 중요한 문제가 있습니다. 첫 번째는 끝없는 리스트로 브라우저를 휩쓸 것이라는 점이고, 두 번째는 배열을 "n"개의 요소로 나누어도 대규모 다시 렌더링 문제가 발생하여 응용 프로그램이 반응 없거나 느려질 수 있습니다. 애플리케이션을 빠르고 부드럽게 실행하기 위한 몇 가지 기술이 있지만 이 글을 너무 길게 만들고 싶지 않아 두 부분으로 나누기로 결정했습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"실시간 성능 최적화 WebSockets와 Reactjs 통합하는 방법 Part I","description":"","date":"2024-06-22 03:04","slug":"2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_0.png\" /\u003e\n\n요즘에는 많은 양의 데이터가 있는데, 그것을 빨리 얻고 모든 것이 잘 작동하는 것이 정말 중요해요. 하지만 때로는 예전 방식(HTTP 요청)을 사용해서 계속해서 데이터를 요청하는 것은 오늘날 앱에는 충분히 빠르지 않을 수도 있어요. 그런 상황에서 WebSockets가 등장해요. WebSockets는 거의 즉시 업데이트를 보낼 수 있어 마치 마법 같은 기술이에요. 이를 통해 최신 정보를 곧바로 받아볼 수 있어요.\n\n그리고 React와 함께 사용한다면, 실시간으로 정보를 얻는 새로운 방식이 열립니다. React는 정말 빠른데, 너무 많은 것을 변경하면 신중하지 않으면, 앱이 느려지거나 작동을 멈출 수도 있어요. 그래서 React에서 일어나는 변경 사항을 신중하게 다루는 것은 중요해요, 특히 WebSockets를 사용할 때는요.\n\n우선, 이를 최적화하지 않은 방법에 대해 먼저 이야기해볼게요. 나중에는 React와 WebSockets를 사용하는 최적화된 방법에 대해 더 깊이 탐구해볼 거에요. 기대해주세요, 우리는 응용 프로그램의 성능과 효율성을 극대화하기 위한 WebSockets를 활용하는 최상의 방법에 대해 탐구할 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 먼저 WebSocket이란 무엇인가요? 웹소켓 이해하기\n\n웹소켓은 단일, 오래 지속되는 연결을 통해 전이편된 통신 채널을 제공합니다. 이를 통해 클라이언트(브라우저)와 서버 간 실시간 데이터 교환이 가능해집니다. 전통적인 HTTP 요청과는 달리 웹소켓은 클라이언트와 서버가 모두 통신을 시작할 수 있어 즉각적인 업데이트가 필요한 응용 프로그램에 이상적입니다.\n\n실시간 데이터 스트리밍의 장점\n\n- 효율성 향상: 웹소켓을 통해 데이터 업데이트가 원활해집니다. 한 번 연결되면 데이터가 지연 없이 흘러가며 지속적인 요청 시간을 제거합니다.\n- 즉각적인 업데이트: 웹소켓을 통해 즉각적으로 업데이트를 받을 수 있습니다. 시장 동향이나 암호화폐 가격 추이를 추적하는 경우에도 신속한 결정을 위해 항상 최신 정보를 얻을 수 있습니다.\n- 양방향 대화: 웹소켓을 이용하면 서버와 클라이언트가 즉각적으로 양방향 대화를 할 수 있습니다. 모두가 듣고 듣는 빠른 대화와 같아서 팀워크가 쉬워집니다.\n- 확장성: 데이터 요구가 증가함에 따라 웹소켓은 부하를 다룰 수 있습니다. 연결을 열어두기 때문에 많은 사용자가 있더라도 원활하게 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_1.png\" /\u003e\n\n# React에서 WebSockets 사용하기\n\n이제, 웹소켓의 강점을 React 애플리케이션으로 가져올 수 있는 \"react-use-websocket\"이라는 유용한 도구에 대해 이야기해보겠습니다. 이 라이브러리는 웹소켓을 React 컴포넌트에 통합하는 과정을 단순화하여 심지어 초보자들도 사용할 수 있게 해줍니다.\n\n\"react-use-websocket\"을 사용하면 WebSocket 연결을 쉽게 설정할 수 있고, 메시지를 보내고 받을 수 있으며, 연결 오류를 처리할 수 있습니다 - 모두 React 컴포넌트 내에서 가능합니다. 시작하는 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 설치: 라이브러리를 설치하려면 npm 또는 yarn을 사용하여 다음과 같이 시작하세요:\n\n```js\nnpm install react-use-websocket\n```\n\n또는\n\n```js\nyarn add react-use-websocket\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 사용 방법: 설치한 후에는 React 컴포넌트에서 useWebSocket 훅을 가져와 사용할 수 있습니다. 아래는 기본 예제입니다:\n\n```js\nimport React from 'react';\nimport { useWebSocket } from 'react-use-websocket';\n\nconst MyComponent = () =\u003e {\n  const { sendMessage, lastMessage } = useWebSocket('wss://example.com/ws');\n\n  const handleClick = () =\u003e {\n    sendMessage('Hello, WebSocket!');\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={handleClick}\u003e메시지 보내기\u003c/button\u003e\n      \u003cp\u003e최근 메시지: {lastMessage ? lastMessage.data : '없음'}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\n\nexport default MyComponent;\n```\n\n이 예제에서는 'wss://example.com/ws'로 WebSocket 연결을 설정하기 위해 useWebSocket 훅을 사용하고 있습니다. sendMessage 함수를 사용하여 메시지를 보내고, lastMessage 객체를 사용하여 최근 받은 메시지를 표시합니다.\n\n3. 이벤트 처리: \"react-use-websocket\"은 onOpen, onMessage, onError, onClose와 같은 다양한 WebSocket 이벤트를 처리하는 훅을 제공합니다. 이러한 훅을 사용하여 UI를 업데이트하거나 오류를 기록하는 등 다양한 WebSocket 이벤트에 기반한 작업을 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst { sendMessage, lastMessage, readyState } = useWebSocket('wss://example.com/ws', {\n   onOpen: () =\u003e console.log('WebSocket connection opened!'),\n   onClose: () =\u003e console.log('WebSocket connection closed!'),\n   onError: (event) =\u003e console.error('WebSocket error:', event),\n   onMessage: (event) =\u003e console.log('Received message:', event.data),\n});\n```\n\n“리액트-유즈-웹소켓”을 사용하면 React 애플리케이션에 WebSocket을 쉽고 직관적으로 통합할 수 있습니다. 실시간 채팅 애플리케이션, 실시간 데이터 대시보드 또는 협업 도구를 구축하든, \"리액트-유즈-웹소켓\"을 사용하면 익숙한 React 환경에서 WebSocket의 강력함을 활용할 수 있습니다.\n\n# 좀 더 전체적인 예시를 살펴보겠습니다.\n\n이를 위해 cryptocompare와 같은 외부 웹소켓을 사용할 것인데, 그를 위해 무료 API 키를 생성하기 위해 계정을 생성해야 합니다. 자세한 지침은 여기를 참고하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI 키를 받은 후 다음 패키지를 추가하겠습니다:\n\n```js\nnpm i react-use-websocket bootstrap react-bootstrap react-router-dom --save \n```\n\n또는\n\n```js\nyarn add react-use-websocket bootstrap react-bootstrap react-router-dom\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n부트스트랩 패키지는 스타일링을 위한 것입니다.\n\n설치가 완료되면 Home.tsx 컴포넌트를 생성하겠습니다. 이 컴포넌트에는 입력 텍스트만 포함되어 있고 api 키를 제출하여 http://localhost:3000/dashboard로 리디렉션하고 api_key를 쿼리 매개변수로 추가할 것입니다.\n\n```js\nimport { useState } from \"react\";\nimport Modal from \"react-bootstrap/Modal\";\nimport Button from \"react-bootstrap/Button\";\nimport Form from \"react-bootstrap/Form\";\nimport { useNavigate } from \"react-router-dom\";\n\nconst Home = () =\u003e {\n  const [show, setShow] = useState(true);\n  const [apiKey, setApiKey] = useState(\"\");\n  const navigate = useNavigate();\n\n  const handleClose = () =\u003e setShow(false);\n\n  const handleChange = (e: React.ChangeEvent\u003cHTMLInputElement\u003e) =\u003e {\n    setApiKey(e.target.value);\n  };\n\n  const handleSubmit = (e: React.SyntheticEvent) =\u003e {\n    e.preventDefault();\n    navigate(`/dashboard?api_key=${apiKey}`);\n  };\n  return (\n    \u003c\u003e\n      \u003cModal\n        show={show}\n        onHide={handleClose}\n        data-bs-theme=\"dark\"\n        style={{ color: \"white\" }}\n      \u003e\n        \u003cModal.Header closeButton\u003e\n          \u003cModal.Title\u003ereact use websocket\u003c/Modal.Title\u003e\n        \u003c/Modal.Header\u003e\n        \u003cModal.Body\u003e\n          \u003cForm onSubmit={handleSubmit}\u003e\n            \u003cForm.Group controlId=\"formBasicEmail\"\u003e\n              \u003cForm.Label\u003eApi key:\u003c/Form.Label\u003e\n              \u003cForm.Control\n                type=\"text\"\n                placeholder=\"Please provide api key\"\n                value={apiKey}\n                onChange={handleChange}\n              /\u003e\n            \u003c/Form.Group\u003e\n          \u003c/Form\u003e\n        \u003c/Modal.Body\u003e\n        \u003cModal.Footer\u003e\n          \u003cButton variant=\"primary\" onClick={handleSubmit}\u003e\n            Submit\n          \u003c/Button\u003e\n        \u003c/Modal.Footer\u003e\n      \u003c/Modal\u003e\n    \u003c/\u003e\n  );\n};\n\nexport default Home;\n```\n\nDashboard.tsx 컴포넌트에는 웹소켓 응답 객체를 위한 인터페이스를 생성해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드를 한글로 번역하면 다음과 같습니다:\n\n```js\nexport interface CryptoMessage {\n  TYPE: string;\n  M: string;\n  FSYM: string;\n  TSYM: string;\n  F: string;\n  ID?: string;\n  TS?: string;\n  Q?: number;\n  P?: number;\n  TOTAL?: number;\n  RTS?: string;\n  CCSEQ?: number;\n  TSNS?: number;\n  RTSNS?: number;\n}\n```\n\n그리고 useWebSocket 훅을 호출하세요.\n\n```js\nconst { readyState, sendJsonMessage, lastJsonMessage } =\n    useWebSocket\u003cCryptoMessage\u003e(socketUrl, { share: true });\n```\n\n이제 readyState, sendJsonMessage, lastJsonMessage가 무엇인지 설명하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReadyState:\n\n\"useWebSocket\" 훅에서 제공하는 readyState 속성은 현재 WebSocket 연결 상태를 나타냅니다. WebSocket 연결이 보류 중인지, 열린 상태인지, 닫히는 중인지 또는 닫힌 상태인지를 나타냅니다. readyState 속성은 다음 네 가지 값 중 하나를 가질 수 있는 정수 값입니다:\n\n- CONNECTING (0): 이 상태는 WebSocket 연결이 설정 중인 상태를 나타냅니다. useWebSocket 훅을 초기 호출하고 WebSocket 연결을 시작할 때 연결이 성공적으로 설정될 때까지 CONNECTING 상태로 진입합니다.\n- OPEN (1): 이 상태는 WebSocket 연결이 열려 있고 메시지를 보내고 받을 준비가 된 상태를 나타냅니다. 연결이 성공적으로 설정되면 OPEN 상태로 전환되어 클라이언트와 서버 간에 양방향 통신이 가능해집니다.\n- CLOSING (2): 이 상태는 WebSocket 연결이 닫히는 중인 상태를 나타냅니다. useWebSocket 훅에서 제공하는 closeWebSocket 함수를 사용하여 WebSocket 연결을 종료하면 닫히기 전에 CLOSING 상태로 진입합니다.\n- CLOSED (3): 이 상태는 WebSocket 연결이 닫힌 상태를 나타냅니다. 연결이 서버에 의해 닫히거나 클라이언트가 명시적으로 closeWebSocket 함수를 사용하여 연결을 닫으면 발생합니다. 연결이 닫힌 후에는 새 WebSocket 연결을 초기화할 때까지 CLOSED 상태로 유지됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"useWebSocket\" 라이브러리 내의 useWebSocket 훅에서 제공하는 sendJsonMessage 함수는 WebSocket 연결을 통해 JSON 형식의 메시지를 보내는 데 유용한 유틸리티 함수입니다. 이 함수는 JavaScript 객체를 JSON 문자열로 직렬화하는 번거로운 작업을 추상화하여 구조화된 데이터를 WebSocket 서버로 보내는 프로세스를 간소화합니다.\n\nlastJsonMessage:\n\n\"useWebSocket\" 라이브러리 내의 useWebSocket 훅에서 제공하는 lastJsonMessage 속성은 WebSocket 연결을 통해 수신한 JSON 형식의 최근 메시지를 나타냅니다. 이 속성을 사용하면 React 컴포넌트 내에서 받은 마지막 메시지에 포함된 데이터에 액세스하고 처리할 수 있습니다.\n\n다음 코드는 현재 WebSocket 연결 상태를 UI에 표시합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nimport useWebSocket, { ReadyState } from \"react-use-websocket\";\r\nimport { useSearchParams } from \"react-router-dom\";\r\n\r\nexport interface CryptoMessage {\r\n  TYPE: string;\r\n  M: string;\r\n  FSYM: string;\r\n  TSYM: string;\r\n  F: string;\r\n  ID?: string;\r\n  TS?: string;\r\n  Q?: number;\r\n  P?: number;\r\n  TOTAL?: number;\r\n  RTS?: string;\r\n  CCSEQ?: number;\r\n  TSNS?: number;\r\n  RTSNS?: number;\r\n}\r\n\r\nconst Dashboard = () =\u003e {\r\n  const [searchParams] = useSearchParams();\r\n  const api_key = searchParams.get(\"api_key\");\r\n  const socketUrl = `wss://streamer.cryptocompare.com/v2?api_key=${api_key}`;\r\n  const { readyState, sendJsonMessage, lastJsonMessage } =\r\n    useWebSocket\u003cCryptoMessage\u003e(socketUrl, { share: true });\r\n\r\n  const connectionStatus = {\r\n    [ReadyState.CONNECTING]: \"연결 중\",\r\n    [ReadyState.OPEN]: \"열림\",\r\n    [ReadyState.CLOSING]: \"닫히는 중\",\r\n    [ReadyState.CLOSED]: \"닫힘\",\r\n    [ReadyState.UNINSTANTIATED]: \"미초기화\",\r\n  }[readyState];\r\n\r\n  return \u003c\u003e{connectionStatus} \u003c/\u003e;\r\n};\r\n\r\nexport default Dashboard;\r\n```\r\n\r\n\"열림\" 상태를 받으면 WebSocket 서비스로 메시지를 보낼 수 있습니다.\r\n\r\n```js\r\nuseEffect(() =\u003e {\r\n    if (readyState === ReadyState.OPEN) {\r\n      sendJsonMessage({\r\n        action: \"SubAdd\",\r\n        subs: [\r\n          \"0~Coinbase~BTC~USD\",\r\n          \"0~Coinbase~BTC~EUR\",\r\n          \"0~Coinbase~ETH~USD\",\r\n          \"0~Coinbase~ETH~EUR\",\r\n        ],\r\n      });\r\n    }\r\n  }, [readyState, sendJsonMessage]);\r\n```\r\n\r\nsendJsonMessage 내에 있는 json 객체를 설명해보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 작업:\n\n- 해당 객체에는 값이 \"SubAdd\"인 action 속성이 포함되어 있습니다.\n- 이는 WebSocket 서버에서 수행할 작업이 새 데이터 스트림에 구독하는 것임을 나타냅니다.\n\n# 구독:\n\n- 해당 객체에는 subs라는 속성이 포함되어 있으며 구독 문자열의 배열을 보유합니다.\n- 각 구독 문자열은 클라이언트가 구독하려는 특정 데이터 스트림을 나타냅니다.\n- 각 구독 문자열의 형식은 \"0~'거래소'~'기초통화'~'견적통화'\"입니다. 여기서:\n- \"0\": 스트리밍 데이터에 대한 구독을 나타냅니다 (역사적 데이터와 대조됨).\n- '거래소': 데이터를 제공하는 거래소의 이름을 나타냅니다 (예: \"코인베이스\").\n- '기초통화': 거래 페어의 기초 통화를 나타냅니다 (예: 비트코인의 경우 \"BTC\", 이더리움의 경우 \"ETH\").\n- '견적통화': 거래 페어의 견적 통화를 나타냅니다 (예: 미국 달러의 경우 \"USD\", 유로의 경우 \"EUR\").\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하자면, 이 코드는 WebSocket 서버에게 새로운 데이터 스트리밍을 위한 구독을 추가하도록 지시합니다. subs 배열에 지정된 구독은 Coinbase 거래소의 다양한 거래 페어를 대상으로 하며, BTC/USD, BTC/EUR, ETH/USD 및 ETH/EUR 등이 포함됩니다. 이를 통해 클라이언트가 WebSocket 서버로부터 이러한 거래 페어의 실시간 업데이트를 받을 수 있게 됩니다.\n\n이제 데이터를 가능한 한 빨리 받을 수 있게 되었으니, 남은 작업은 브라우저에 스트리밍 데이터를 표시하는 것 뿐입니다.\n\n```js\nconst renderList = () =\u003e {\n    return list.map((element: CryptoMessage, index: number) =\u003e {\n      return (\n        \u003cli key={index}\u003e\n          {element.FSYM} - {element.P}\n        \u003c/li\u003e\n      );\n    });\n  };\n\nreturn \u003c\u003e{readyState === ReadyState.OPEN? renderList() : connectionStatus} \u003c/\u003e;\n```\n\n각 요소에 대해, element.FSYM의 값 (암호화폐 심볼인지 ETH 또는 BTC인지)을 나타내는 JSX `li` 요소를 반환하고, 그 뒤에는 대시(-)와 element.P의 값(가격)을 나타냅니다. 결과는 다음과 같을 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_2](/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_2.png)\n\n우리 데이터를 그래프로 시각화하는 것이 훨씬 쉬울 것입니다. 이를 위해 react google charts를 설치해야 합니다.\n\n```js\nnpm install --save react-google-charts\n```\n\n또는\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nyarn add react-google-charts\n```\n\n이후에 Chart를 가져와서 renderList 함수를 renderGraph로 변경합시다:\n\n```js\nconst graphData: any[] = [[\"\", \"BTC\", \"ETH\"]];\n      let BTCPrice;\n      let ETHPrice;\n      for (const element of list) {\n        if (element.FSYM === \"BTC\") {\n          BTCPrice = element.P;\n        } else if (element.FSYM === \"ETH\") {\n          ETHPrice = element.P;\n        }\n        if (typeof BTCPrice === \"undefined\" || typeof ETHPrice === \"undefined\") {\n          continue;\n        } else {\n          graphData.push([\"\", BTCPrice, ETHPrice]);\n        }\n      }\n      return (\n        \u003cChart\n          graph_id=\"graph\"\n          chartType=\"LineChart\"\n          width=\"100%\"\n          height=\"400px\"\n          data={graphData}\n          options={options}\n        /\u003e\n      );\n  };\n\n  return (\n    \u003c\u003e{readyState === ReadyState.OPEN ? renderGraph() : connectionStatus} \u003c/\u003e\n  );\n```\n\n결과는 다음과 같을 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_3.png\" /\u003e\n\n그리고 마지막으로 작동 예제가 있습니다.\n\n# 결론\n\n이는 웹소켓을 사용하는 매우 단순한 방법이지만 문제를 해결해야 할 두 가지 중요한 문제가 있습니다. 첫 번째는 끝없는 리스트로 브라우저를 휩쓸 것이라는 점이고, 두 번째는 배열을 \"n\"개의 요소로 나누어도 대규모 다시 렌더링 문제가 발생하여 응용 프로그램이 반응 없거나 느려질 수 있습니다. 애플리케이션을 빠르고 부드럽게 실행하기 위한 몇 가지 기술이 있지만 이 글을 너무 길게 만들고 싶지 않아 두 부분으로 나누기로 결정했습니다.","ogImage":{"url":"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_0.png"},"coverImage":"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_0.png\"\u003e\n\u003cp\u003e요즘에는 많은 양의 데이터가 있는데, 그것을 빨리 얻고 모든 것이 잘 작동하는 것이 정말 중요해요. 하지만 때로는 예전 방식(HTTP 요청)을 사용해서 계속해서 데이터를 요청하는 것은 오늘날 앱에는 충분히 빠르지 않을 수도 있어요. 그런 상황에서 WebSockets가 등장해요. WebSockets는 거의 즉시 업데이트를 보낼 수 있어 마치 마법 같은 기술이에요. 이를 통해 최신 정보를 곧바로 받아볼 수 있어요.\u003c/p\u003e\n\u003cp\u003e그리고 React와 함께 사용한다면, 실시간으로 정보를 얻는 새로운 방식이 열립니다. React는 정말 빠른데, 너무 많은 것을 변경하면 신중하지 않으면, 앱이 느려지거나 작동을 멈출 수도 있어요. 그래서 React에서 일어나는 변경 사항을 신중하게 다루는 것은 중요해요, 특히 WebSockets를 사용할 때는요.\u003c/p\u003e\n\u003cp\u003e우선, 이를 최적화하지 않은 방법에 대해 먼저 이야기해볼게요. 나중에는 React와 WebSockets를 사용하는 최적화된 방법에 대해 더 깊이 탐구해볼 거에요. 기대해주세요, 우리는 응용 프로그램의 성능과 효율성을 극대화하기 위한 WebSockets를 활용하는 최상의 방법에 대해 탐구할 거예요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e먼저 WebSocket이란 무엇인가요? 웹소켓 이해하기\u003c/h1\u003e\n\u003cp\u003e웹소켓은 단일, 오래 지속되는 연결을 통해 전이편된 통신 채널을 제공합니다. 이를 통해 클라이언트(브라우저)와 서버 간 실시간 데이터 교환이 가능해집니다. 전통적인 HTTP 요청과는 달리 웹소켓은 클라이언트와 서버가 모두 통신을 시작할 수 있어 즉각적인 업데이트가 필요한 응용 프로그램에 이상적입니다.\u003c/p\u003e\n\u003cp\u003e실시간 데이터 스트리밍의 장점\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e효율성 향상: 웹소켓을 통해 데이터 업데이트가 원활해집니다. 한 번 연결되면 데이터가 지연 없이 흘러가며 지속적인 요청 시간을 제거합니다.\u003c/li\u003e\n\u003cli\u003e즉각적인 업데이트: 웹소켓을 통해 즉각적으로 업데이트를 받을 수 있습니다. 시장 동향이나 암호화폐 가격 추이를 추적하는 경우에도 신속한 결정을 위해 항상 최신 정보를 얻을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e양방향 대화: 웹소켓을 이용하면 서버와 클라이언트가 즉각적으로 양방향 대화를 할 수 있습니다. 모두가 듣고 듣는 빠른 대화와 같아서 팀워크가 쉬워집니다.\u003c/li\u003e\n\u003cli\u003e확장성: 데이터 요구가 증가함에 따라 웹소켓은 부하를 다룰 수 있습니다. 연결을 열어두기 때문에 많은 사용자가 있더라도 원활하게 작동합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_1.png\"\u003e\n\u003ch1\u003eReact에서 WebSockets 사용하기\u003c/h1\u003e\n\u003cp\u003e이제, 웹소켓의 강점을 React 애플리케이션으로 가져올 수 있는 \"react-use-websocket\"이라는 유용한 도구에 대해 이야기해보겠습니다. 이 라이브러리는 웹소켓을 React 컴포넌트에 통합하는 과정을 단순화하여 심지어 초보자들도 사용할 수 있게 해줍니다.\u003c/p\u003e\n\u003cp\u003e\"react-use-websocket\"을 사용하면 WebSocket 연결을 쉽게 설정할 수 있고, 메시지를 보내고 받을 수 있으며, 연결 오류를 처리할 수 있습니다 - 모두 React 컴포넌트 내에서 가능합니다. 시작하는 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e설치: 라이브러리를 설치하려면 npm 또는 yarn을 사용하여 다음과 같이 시작하세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install react-use-websocket\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eyarn add react-use-websocket\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e사용 방법: 설치한 후에는 React 컴포넌트에서 useWebSocket 훅을 가져와 사용할 수 있습니다. 아래는 기본 예제입니다:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useWebSocket } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-use-websocket'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMyComponent\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { sendMessage, lastMessage } = \u003cspan class=\"hljs-title function_\"\u003euseWebSocket\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'wss://example.com/ws'\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleClick\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esendMessage\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Hello, WebSocket!'\u003c/span\u003e);\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleClick}\u003c/span\u003e\u003e\u003c/span\u003e메시지 보내기\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e최근 메시지: {lastMessage ? lastMessage.data : '없음'}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyComponent\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 'wss://example.com/ws'로 WebSocket 연결을 설정하기 위해 useWebSocket 훅을 사용하고 있습니다. sendMessage 함수를 사용하여 메시지를 보내고, lastMessage 객체를 사용하여 최근 받은 메시지를 표시합니다.\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e이벤트 처리: \"react-use-websocket\"은 onOpen, onMessage, onError, onClose와 같은 다양한 WebSocket 이벤트를 처리하는 훅을 제공합니다. 이러한 훅을 사용하여 UI를 업데이트하거나 오류를 기록하는 등 다양한 WebSocket 이벤트에 기반한 작업을 수행할 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { sendMessage, lastMessage, readyState } = \u003cspan class=\"hljs-title function_\"\u003euseWebSocket\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'wss://example.com/ws'\u003c/span\u003e, {\n   \u003cspan class=\"hljs-attr\"\u003eonOpen\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'WebSocket connection opened!'\u003c/span\u003e),\n   \u003cspan class=\"hljs-attr\"\u003eonClose\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'WebSocket connection closed!'\u003c/span\u003e),\n   \u003cspan class=\"hljs-attr\"\u003eonError\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'WebSocket error:'\u003c/span\u003e, event),\n   \u003cspan class=\"hljs-attr\"\u003eonMessage\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Received message:'\u003c/span\u003e, event.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e),\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e“리액트-유즈-웹소켓”을 사용하면 React 애플리케이션에 WebSocket을 쉽고 직관적으로 통합할 수 있습니다. 실시간 채팅 애플리케이션, 실시간 데이터 대시보드 또는 협업 도구를 구축하든, \"리액트-유즈-웹소켓\"을 사용하면 익숙한 React 환경에서 WebSocket의 강력함을 활용할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e좀 더 전체적인 예시를 살펴보겠습니다.\u003c/h1\u003e\n\u003cp\u003e이를 위해 cryptocompare와 같은 외부 웹소켓을 사용할 것인데, 그를 위해 무료 API 키를 생성하기 위해 계정을 생성해야 합니다. 자세한 지침은 여기를 참고하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eAPI 키를 받은 후 다음 패키지를 추가하겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm i react-use-websocket bootstrap react-bootstrap react-router-dom --save \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eyarn add react-use-websocket bootstrap react-bootstrap react-router-dom\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e부트스트랩 패키지는 스타일링을 위한 것입니다.\u003c/p\u003e\n\u003cp\u003e설치가 완료되면 Home.tsx 컴포넌트를 생성하겠습니다. 이 컴포넌트에는 입력 텍스트만 포함되어 있고 api 키를 제출하여 \u003ca href=\"http://localhost:3000/dashboard%EB%A1%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:3000/dashboard로\u003c/a\u003e 리디렉션하고 api_key를 쿼리 매개변수로 추가할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eModal\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react-bootstrap/Modal\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react-bootstrap/Button\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eForm\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react-bootstrap/Form\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useNavigate } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react-router-dom\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHome\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [show, setShow] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [apiKey, setApiKey] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e navigate = \u003cspan class=\"hljs-title function_\"\u003euseNavigate\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleClose\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-title function_\"\u003esetShow\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleChange\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003ee: React.ChangeEvent\u0026#x3C;HTMLInputElement\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetApiKey\u003c/span\u003e(e.\u003cspan class=\"hljs-property\"\u003etarget\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e);\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleSubmit\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003ee: React.SyntheticEvent\u003c/span\u003e) =\u003e {\n    e.\u003cspan class=\"hljs-title function_\"\u003epreventDefault\u003c/span\u003e();\n    \u003cspan class=\"hljs-title function_\"\u003enavigate\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`/dashboard?api_key=\u003cspan class=\"hljs-subst\"\u003e${apiKey}\u003c/span\u003e`\u003c/span\u003e);\n  };\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eModal\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eshow\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{show}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eonHide\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleClose}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003edata-bs-theme\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"dark\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecolor:\u003c/span\u003e \"\u003cspan class=\"hljs-attr\"\u003ewhite\u003c/span\u003e\" }}\n      \u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eModal.Header\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecloseButton\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eModal.Title\u003c/span\u003e\u003e\u003c/span\u003ereact use websocket\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eModal.Title\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eModal.Header\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eModal.Body\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eForm\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonSubmit\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleSubmit}\u003c/span\u003e\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eForm.Group\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtrolId\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"formBasicEmail\"\u003c/span\u003e\u003e\u003c/span\u003e\n              \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eForm.Label\u003c/span\u003e\u003e\u003c/span\u003eApi key:\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eForm.Label\u003c/span\u003e\u003e\u003c/span\u003e\n              \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eForm.Control\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003eplaceholder\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Please provide api key\"\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{apiKey}\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleChange}\u003c/span\u003e\n              /\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eForm.Group\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eForm\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eModal.Body\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eModal.Footer\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evariant\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"primary\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleSubmit}\u003c/span\u003e\u003e\u003c/span\u003e\n            Submit\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eModal.Footer\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eModal\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHome\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDashboard.tsx 컴포넌트에는 웹소켓 응답 객체를 위한 인터페이스를 생성해야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 코드를 한글로 번역하면 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e interface \u003cspan class=\"hljs-title class_\"\u003eCryptoMessage\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eTYPE\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003eM\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003eFSYM\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003eTSYM\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003eF\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e?: string;\n  \u003cspan class=\"hljs-variable constant_\"\u003eTS\u003c/span\u003e?: string;\n  Q?: number;\n  P?: number;\n  \u003cspan class=\"hljs-variable constant_\"\u003eTOTAL\u003c/span\u003e?: number;\n  \u003cspan class=\"hljs-variable constant_\"\u003eRTS\u003c/span\u003e?: string;\n  \u003cspan class=\"hljs-variable constant_\"\u003eCCSEQ\u003c/span\u003e?: number;\n  \u003cspan class=\"hljs-variable constant_\"\u003eTSNS\u003c/span\u003e?: number;\n  \u003cspan class=\"hljs-variable constant_\"\u003eRTSNS\u003c/span\u003e?: number;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 useWebSocket 훅을 호출하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { readyState, sendJsonMessage, lastJsonMessage } =\n    useWebSocket\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eCryptoMessage\u003c/span\u003e\u003e(socketUrl, { \u003cspan class=\"hljs-attr\"\u003eshare\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 readyState, sendJsonMessage, lastJsonMessage가 무엇인지 설명하겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eReadyState:\u003c/p\u003e\n\u003cp\u003e\"useWebSocket\" 훅에서 제공하는 readyState 속성은 현재 WebSocket 연결 상태를 나타냅니다. WebSocket 연결이 보류 중인지, 열린 상태인지, 닫히는 중인지 또는 닫힌 상태인지를 나타냅니다. readyState 속성은 다음 네 가지 값 중 하나를 가질 수 있는 정수 값입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCONNECTING (0): 이 상태는 WebSocket 연결이 설정 중인 상태를 나타냅니다. useWebSocket 훅을 초기 호출하고 WebSocket 연결을 시작할 때 연결이 성공적으로 설정될 때까지 CONNECTING 상태로 진입합니다.\u003c/li\u003e\n\u003cli\u003eOPEN (1): 이 상태는 WebSocket 연결이 열려 있고 메시지를 보내고 받을 준비가 된 상태를 나타냅니다. 연결이 성공적으로 설정되면 OPEN 상태로 전환되어 클라이언트와 서버 간에 양방향 통신이 가능해집니다.\u003c/li\u003e\n\u003cli\u003eCLOSING (2): 이 상태는 WebSocket 연결이 닫히는 중인 상태를 나타냅니다. useWebSocket 훅에서 제공하는 closeWebSocket 함수를 사용하여 WebSocket 연결을 종료하면 닫히기 전에 CLOSING 상태로 진입합니다.\u003c/li\u003e\n\u003cli\u003eCLOSED (3): 이 상태는 WebSocket 연결이 닫힌 상태를 나타냅니다. 연결이 서버에 의해 닫히거나 클라이언트가 명시적으로 closeWebSocket 함수를 사용하여 연결을 닫으면 발생합니다. 연결이 닫힌 후에는 새 WebSocket 연결을 초기화할 때까지 CLOSED 상태로 유지됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\"useWebSocket\" 라이브러리 내의 useWebSocket 훅에서 제공하는 sendJsonMessage 함수는 WebSocket 연결을 통해 JSON 형식의 메시지를 보내는 데 유용한 유틸리티 함수입니다. 이 함수는 JavaScript 객체를 JSON 문자열로 직렬화하는 번거로운 작업을 추상화하여 구조화된 데이터를 WebSocket 서버로 보내는 프로세스를 간소화합니다.\u003c/p\u003e\n\u003cp\u003elastJsonMessage:\u003c/p\u003e\n\u003cp\u003e\"useWebSocket\" 라이브러리 내의 useWebSocket 훅에서 제공하는 lastJsonMessage 속성은 WebSocket 연결을 통해 수신한 JSON 형식의 최근 메시지를 나타냅니다. 이 속성을 사용하면 React 컴포넌트 내에서 받은 마지막 메시지에 포함된 데이터에 액세스하고 처리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음 코드는 현재 WebSocket 연결 상태를 UI에 표시합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e useWebSocket, { \u003cspan class=\"hljs-title class_\"\u003eReadyState\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react-use-websocket\"\u003c/span\u003e;\r\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useSearchParams } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react-router-dom\"\u003c/span\u003e;\r\n\r\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e interface \u003cspan class=\"hljs-title class_\"\u003eCryptoMessage\u003c/span\u003e {\r\n  \u003cspan class=\"hljs-attr\"\u003eTYPE\u003c/span\u003e: string;\r\n  \u003cspan class=\"hljs-attr\"\u003eM\u003c/span\u003e: string;\r\n  \u003cspan class=\"hljs-attr\"\u003eFSYM\u003c/span\u003e: string;\r\n  \u003cspan class=\"hljs-attr\"\u003eTSYM\u003c/span\u003e: string;\r\n  \u003cspan class=\"hljs-attr\"\u003eF\u003c/span\u003e: string;\r\n  \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e?: string;\r\n  \u003cspan class=\"hljs-variable constant_\"\u003eTS\u003c/span\u003e?: string;\r\n  Q?: number;\r\n  P?: number;\r\n  \u003cspan class=\"hljs-variable constant_\"\u003eTOTAL\u003c/span\u003e?: number;\r\n  \u003cspan class=\"hljs-variable constant_\"\u003eRTS\u003c/span\u003e?: string;\r\n  \u003cspan class=\"hljs-variable constant_\"\u003eCCSEQ\u003c/span\u003e?: number;\r\n  \u003cspan class=\"hljs-variable constant_\"\u003eTSNS\u003c/span\u003e?: number;\r\n  \u003cspan class=\"hljs-variable constant_\"\u003eRTSNS\u003c/span\u003e?: number;\r\n}\r\n\r\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eDashboard\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\r\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [searchParams] = \u003cspan class=\"hljs-title function_\"\u003euseSearchParams\u003c/span\u003e();\r\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e api_key = searchParams.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"api_key\"\u003c/span\u003e);\r\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e socketUrl = \u003cspan class=\"hljs-string\"\u003e`wss://streamer.cryptocompare.com/v2?api_key=\u003cspan class=\"hljs-subst\"\u003e${api_key}\u003c/span\u003e`\u003c/span\u003e;\r\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { readyState, sendJsonMessage, lastJsonMessage } =\r\n    useWebSocket\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eCryptoMessage\u003c/span\u003e\u003e(socketUrl, { \u003cspan class=\"hljs-attr\"\u003eshare\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e });\r\n\r\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e connectionStatus = {\r\n    [\u003cspan class=\"hljs-title class_\"\u003eReadyState\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCONNECTING\u003c/span\u003e]: \u003cspan class=\"hljs-string\"\u003e\"연결 중\"\u003c/span\u003e,\r\n    [\u003cspan class=\"hljs-title class_\"\u003eReadyState\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eOPEN\u003c/span\u003e]: \u003cspan class=\"hljs-string\"\u003e\"열림\"\u003c/span\u003e,\r\n    [\u003cspan class=\"hljs-title class_\"\u003eReadyState\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCLOSING\u003c/span\u003e]: \u003cspan class=\"hljs-string\"\u003e\"닫히는 중\"\u003c/span\u003e,\r\n    [\u003cspan class=\"hljs-title class_\"\u003eReadyState\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCLOSED\u003c/span\u003e]: \u003cspan class=\"hljs-string\"\u003e\"닫힘\"\u003c/span\u003e,\r\n    [\u003cspan class=\"hljs-title class_\"\u003eReadyState\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eUNINSTANTIATED\u003c/span\u003e]: \u003cspan class=\"hljs-string\"\u003e\"미초기화\"\u003c/span\u003e,\r\n  }[readyState];\r\n\r\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e{connectionStatus} \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e;\r\n};\r\n\r\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDashboard\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\"열림\" 상태를 받으면 WebSocket 서비스로 메시지를 보낼 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\r\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (readyState === \u003cspan class=\"hljs-title class_\"\u003eReadyState\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eOPEN\u003c/span\u003e) {\r\n      \u003cspan class=\"hljs-title function_\"\u003esendJsonMessage\u003c/span\u003e({\r\n        \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"SubAdd\"\u003c/span\u003e,\r\n        \u003cspan class=\"hljs-attr\"\u003esubs\u003c/span\u003e: [\r\n          \u003cspan class=\"hljs-string\"\u003e\"0~Coinbase~BTC~USD\"\u003c/span\u003e,\r\n          \u003cspan class=\"hljs-string\"\u003e\"0~Coinbase~BTC~EUR\"\u003c/span\u003e,\r\n          \u003cspan class=\"hljs-string\"\u003e\"0~Coinbase~ETH~USD\"\u003c/span\u003e,\r\n          \u003cspan class=\"hljs-string\"\u003e\"0~Coinbase~ETH~EUR\"\u003c/span\u003e,\r\n        ],\r\n      });\r\n    }\r\n  }, [readyState, sendJsonMessage]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003esendJsonMessage 내에 있는 json 객체를 설명해보겠습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e작업:\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e해당 객체에는 값이 \"SubAdd\"인 action 속성이 포함되어 있습니다.\u003c/li\u003e\n\u003cli\u003e이는 WebSocket 서버에서 수행할 작업이 새 데이터 스트림에 구독하는 것임을 나타냅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e구독:\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e해당 객체에는 subs라는 속성이 포함되어 있으며 구독 문자열의 배열을 보유합니다.\u003c/li\u003e\n\u003cli\u003e각 구독 문자열은 클라이언트가 구독하려는 특정 데이터 스트림을 나타냅니다.\u003c/li\u003e\n\u003cli\u003e각 구독 문자열의 형식은 \"0~'거래소'\u003cdel\u003e'기초통화'\u003c/del\u003e'견적통화'\"입니다. 여기서:\u003c/li\u003e\n\u003cli\u003e\"0\": 스트리밍 데이터에 대한 구독을 나타냅니다 (역사적 데이터와 대조됨).\u003c/li\u003e\n\u003cli\u003e'거래소': 데이터를 제공하는 거래소의 이름을 나타냅니다 (예: \"코인베이스\").\u003c/li\u003e\n\u003cli\u003e'기초통화': 거래 페어의 기초 통화를 나타냅니다 (예: 비트코인의 경우 \"BTC\", 이더리움의 경우 \"ETH\").\u003c/li\u003e\n\u003cli\u003e'견적통화': 거래 페어의 견적 통화를 나타냅니다 (예: 미국 달러의 경우 \"USD\", 유로의 경우 \"EUR\").\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e요약하자면, 이 코드는 WebSocket 서버에게 새로운 데이터 스트리밍을 위한 구독을 추가하도록 지시합니다. subs 배열에 지정된 구독은 Coinbase 거래소의 다양한 거래 페어를 대상으로 하며, BTC/USD, BTC/EUR, ETH/USD 및 ETH/EUR 등이 포함됩니다. 이를 통해 클라이언트가 WebSocket 서버로부터 이러한 거래 페어의 실시간 업데이트를 받을 수 있게 됩니다.\u003c/p\u003e\n\u003cp\u003e이제 데이터를 가능한 한 빨리 받을 수 있게 되었으니, 남은 작업은 브라우저에 스트리밍 데이터를 표시하는 것 뿐입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erenderList\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e list.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eelement: CryptoMessage, index: number\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n        \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{index}\u003c/span\u003e\u003e\u003c/span\u003e\n          {element.FSYM} - {element.P}\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n      );\n    });\n  };\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e{readyState === ReadyState.OPEN? renderList() : connectionStatus} \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e각 요소에 대해, element.FSYM의 값 (암호화폐 심볼인지 ETH 또는 BTC인지)을 나타내는 JSX \u003ccode\u003eli\u003c/code\u003e 요소를 반환하고, 그 뒤에는 대시(-)와 element.P의 값(가격)을 나타냅니다. 결과는 다음과 같을 것입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_2.png\" alt=\"2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_2\"\u003e\u003c/p\u003e\n\u003cp\u003e우리 데이터를 그래프로 시각화하는 것이 훨씬 쉬울 것입니다. 이를 위해 react google charts를 설치해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install --save react-google-charts\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eyarn add react-google-charts\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이후에 Chart를 가져와서 renderList 함수를 renderGraph로 변경합시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003egraphData\u003c/span\u003e: any[] = [[\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"BTC\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"ETH\"\u003c/span\u003e]];\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBTCPrice\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eETHPrice\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e element \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e list) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (element.\u003cspan class=\"hljs-property\"\u003eFSYM\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\"BTC\"\u003c/span\u003e) {\n          \u003cspan class=\"hljs-title class_\"\u003eBTCPrice\u003c/span\u003e = element.\u003cspan class=\"hljs-property\"\u003eP\u003c/span\u003e;\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (element.\u003cspan class=\"hljs-property\"\u003eFSYM\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\"ETH\"\u003c/span\u003e) {\n          \u003cspan class=\"hljs-title class_\"\u003eETHPrice\u003c/span\u003e = element.\u003cspan class=\"hljs-property\"\u003eP\u003c/span\u003e;\n        }\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBTCPrice\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\"undefined\"\u003c/span\u003e || \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eETHPrice\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\"undefined\"\u003c/span\u003e) {\n          \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n          graphData.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eBTCPrice\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eETHPrice\u003c/span\u003e]);\n        }\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n        \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eChart\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003egraph_id\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"graph\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003echartType\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"LineChart\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"100%\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"400px\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{graphData}\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{options}\u003c/span\u003e\n        /\u003e\u003c/span\u003e\u003c/span\u003e\n      );\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e{readyState === ReadyState.OPEN ? renderGraph() : connectionStatus} \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과는 다음과 같을 것입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI_3.png\"\u003e\n\u003cp\u003e그리고 마지막으로 작동 예제가 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이는 웹소켓을 사용하는 매우 단순한 방법이지만 문제를 해결해야 할 두 가지 중요한 문제가 있습니다. 첫 번째는 끝없는 리스트로 브라우저를 휩쓸 것이라는 점이고, 두 번째는 배열을 \"n\"개의 요소로 나누어도 대규모 다시 렌더링 문제가 발생하여 응용 프로그램이 반응 없거나 느려질 수 있습니다. 애플리케이션을 빠르고 부드럽게 실행하기 위한 몇 가지 기술이 있지만 이 글을 너무 길게 만들고 싶지 않아 두 부분으로 나누기로 결정했습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-OptimizingReal-TimePerformanceWebSocketsandReactjsIntegrationPartI"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>