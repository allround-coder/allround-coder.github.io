<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>렌더링 전략 모든 React 개발자가 알아야 할 것들 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="렌더링 전략 모든 React 개발자가 알아야 할 것들 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="렌더링 전략 모든 React 개발자가 알아야 할 것들 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow" data-gatsby-head="true"/><meta name="twitter:title" content="렌더링 전략 모든 React 개발자가 알아야 할 것들 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 23:51" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">렌더링 전략 모든 React 개발자가 알아야 할 것들</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="렌더링 전략 모든 React 개발자가 알아야 할 것들" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">20<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png" alt="Image"></p>
<h2>소개:</h2>
<p>React는 현대 웹 개발의 핵심입니다. 최대한 효과적으로 활용하려면 복잡한 렌더링 전략을 이해하고 사용해야 합니다. 이 글에서는 이러한 전략을 보여드릴 것입니다.</p>
<p>이러한 전략은 React 개발자가 더 빠르고 효율적인 앱을 만들 수 있도록 돕습니다. 개발을 쉽게 만들어주고 사용자에게 더 나은 경험을 제공합니다. 얼마나 많은 경험이 있든, 이러한 전략들은 여러분을 도와줄 수 있습니다.</p>
<div class="content-ad"></div>
<h2>렌더링 방법 이해하기</h2>
<p>React의 렌더링 프로세스는 UI를 효율적으로 업데이트하는 방법입니다. 두 가지 주요 단계가 있습니다: 렌더 및 커밋.</p>
<p><img src="/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_1.png" alt="이미지"></p>
<p>렌더 단계</p>
<div class="content-ad"></div>
<p>렌더 단계는 React가 가상 UI를 구축하는 렌더링의 첫 부분입니다. 이 단계에는 DOM 변경이나 데이터 가져오기와 같은 부작용이 없습니다. 이 단계에는 두 가지 주요 단계가 있습니다:</p>
<ul>
<li>가상 DOM 생성: 컴포넌트의 상태나 props가 변경될 때 React는 새 가상 DOM 트리를 생성합니다.</li>
<li>차이 비교: React는 새 가상 DOM 트리와 현재 피버 트리를 비교(se)합니다. 이 프로세스에서는 새 가상 DOM이 이전 것과 비교했을 때 무엇이 변경되었는지를 결정합니다.</li>
<li>작업 단위: 피버 노드(Fiber nodes)는 작업 단위를 나타냅니다. 각 피버 노드는 React 엘리먼트(컴포넌트 또는 DOM 엘리먼트)에 해당하며, 컴포넌트의 상태, props 및 기타 메타데이터 정보를 포함합니다.</li>
</ul>
<p>커밋 단계</p>
<p>이 단계에서는 렌더 단계 중에 플래그 처리된 변경 사항을 사용자에게 최신 UI 상태를 표시하기 위해 실제 DOM에 적용합니다.</p>
<div class="content-ad"></div>
<ul>
<li>DOM 변경 이전 단계: DOM 변경 이전에 실행해야 하는 부작용들이 여기서 처리됩니다.</li>
<li>DOM 변경 단계: Fiber 트리에서 식별된 변경 사항에 따라 실제 DOM 업데이트가 적용됩니다.</li>
<li>레이아웃 단계: DOM 변경 이후에 실행해야 하는 부작용들이 이 단계에서 처리됩니다.</li>
</ul>
<p>커밋 단계는 동기적으로 이루어지며 직접적인 DOM 조작을 포함하며 이로 인해 부작용이 발생할 수 있습니다.</p>
<p>주요 개념:</p>
<ul>
<li>Fiber 아키텍처: React의 Fiber 아키텍처는 조각 단위로 렌더링할 수 있게 합니다. 이는 React를 더 효율적으로 만들어주며 메인 스레드를 차단하지 않고 대규모 업데이트를 처리할 수 있습니다.</li>
<li>동시 모드: React 18에서 동시 모드가 도입되어 React가 동시에 여러 작업을 처리할 수 있습니다. 이로써 사용자 경험을 더 부드럽게 만들어주며 중요하지 않은 작업을 일시 중단하고 긴급한 업데이트에 집중할 수 있습니다.</li>
</ul>
<div class="content-ad"></div>
<p>테이블 태그를 Markdown 형식으로 변경해주세요.</p>
<div class="content-ad"></div>
<p>아래는 Markdown 형식으로 테이블 태그가 변경되었습니다.</p>
<p><img src="/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_2.png" alt="이미지"></p>
<p>주요 포인트:</p>
<ol>
<li>
<p>동적 콘텐츠 로딩: CSR은 전체 페이지 새로고침 없이 동적으로 콘텐츠를 로드할 수 있습니다.</p>
</li>
<li>
<p>향상된 사용자 상호작용: 렌더링이 클라이언트 측에서 발생하기 때문에 상호작용이 더 반응적일 수 있습니다.</p>
</li>
</ol>
<div class="content-ad"></div>
<ol start="3">
<li>
<p>SEO 도전: 검색 엔진은 JavaScript에 크게 의존하는 CSR 콘텐츠를 색인화하는 데 어려움을 겪을 수 있습니다.</p>
</li>
<li>
<p>초기로딩 시간: CSR은 브라우저가 콘텐츠를 렌더링하기 전에 JavaScript를 다운로드하고 실행해야 하므로 초기 로딩 시간이 느려질 수 있습니다.</p>
</li>
</ol>
<p>예시:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data'</span>)
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =></span> response.<span class="hljs-title function_">json</span>())
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =></span> <span class="hljs-title function_">setData</span>(data));
  }, []);

  <span class="hljs-keyword">if</span> (!data) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Loading...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>{data.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{data.content}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>));
</code></pre>
<div class="content-ad"></div>
<p>이 예시에서:</p>
<ul>
<li>useEffect 훅은 컴포넌트가 마운트될 때 API에서 데이터를 가져옵니다.</li>
<li>상태(data)가 가져온 데이터로 업데이트되고, 컴포넌트가 다시 렌더링되어 그것을 보여줍니다.</li>
<li>데이터가 가져와질 때까지 초기 콘텐츠로 표시되는 것은 로딩 메시지입니다.</li>
</ul>
<p>장점:</p>
<ul>
<li>상호 작용 요소로 풍부한 사용자 경험.</li>
<li>단일 페이지 애플리케이션(SPAs)을 위한 효율적인 데이터 가져오기 및 렌더링.</li>
</ul>
<div class="content-ad"></div>
<p>단점:</p>
<ul>
<li>첫 페이지가 로딩하는 데 시간이 걸립니다.</li>
<li>서버 측 렌더링 또는 사전 렌더링 없이 SEO를 하는 것이 어렵습니다.</li>
</ul>
<h2>서버 측 렌더링</h2>
<p>서버 측 렌더링(SSR)은 서버가 페이지의 HTML을 생성하고 클라이언트에게 보내는 기술입니다. 이 접근 방식은 서버에서 완전히 렌더링된 페이지를 직접 제공함으로써 웹 앱의 성능과 SEO를 개선합니다.</p>
<div class="content-ad"></div>
<p>아래는 테이블 태그를 Markdown 형식으로 변경하신 것입니다.</p>
<p>Key Points:</p>
<ol>
<li>
<p>향상된 SEO: 컨텐츠가 서버에서 완전히 렌더링되므로 검색 엔진이 페이지를 쉽게 크롤링하고 색인화할 수 있습니다.</p>
</li>
<li>
<p>초기 로드 속도 향상: 사용자들은 첫 요청 시 완전히 렌더링된 페이지를 받아들이므로 CSR에 비해 초기 로드가 더 빠를 수 있습니다.</p>
</li>
</ol>
<div class="content-ad"></div>
<ol start="3">
<li>Dynamic Content: SSR는 동적 콘텐츠를 처리할 수 있어서 페이지를 요청할 때마다 최신 정보를 제공합니다.</li>
</ol>
<p>예시:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> fetch = <span class="hljs-built_in">require</span>(<span class="hljs-string">'node-fetch'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">React</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactDOMServer</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-dom/server'</span>);

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/'</span>, <span class="hljs-keyword">async</span> (req, res) => {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data'</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();

  <span class="hljs-keyword">const</span> appString = <span class="hljs-title class_">ReactDOMServer</span>.<span class="hljs-title function_">renderToString</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Home</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span> /></span></span>);

  <span class="hljs-keyword">const</span> html = <span class="hljs-string">`
    &#x3C;!DOCTYPE html>
    &#x3C;html lang="en">
      &#x3C;head>
        &#x3C;meta charset="UTF-8">
        &#x3C;meta name="viewport" content="width=device-width, initial-scale=1.0">
        &#x3C;title>Server-Side Rendering with Express&#x3C;/title>
      &#x3C;/head>
      &#x3C;body>
        &#x3C;div id="root"><span class="hljs-subst">${appString}</span>&#x3C;/div>
        &#x3C;script>
          window.__INITIAL_DATA__ = <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(data)}</span>
        &#x3C;/script>
        &#x3C;script src="/client.js">&#x3C;/script>
      &#x3C;/body>
    &#x3C;/html>
  `</span>;

  res.<span class="hljs-title function_">send</span>(html);
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'서버가 http://localhost:3000에서 실행 중입니다.'</span>);
});
</code></pre>
<div class="content-ad"></div>
<ul>
<li>서버 설정: 예제는 Express 프레임워크를 사용하여 서버를 설정합니다. 루트 URL(<code>/</code>)로 요청이 들어오면, 외부 API에서 데이터를 가져옵니다.</li>
<li>데이터 가져오기: 서버는 node-fetch를 사용하여 API 엔드포인트(<a href="https://api.example.com/data)%EB%A1%9C" rel="nofollow" target="_blank">https://api.example.com/data)로</a> HTTP 요청을 보냅니다. 가져온 데이터는 JSON 형식으로 변환됩니다.</li>
<li>React 컴포넌트 렌더링: 서버는 ReactDOMServer.renderToString을 사용하여 Home React 컴포넌트를 HTML 문자열로 렌더링하고, 가져온 데이터를 prop으로 전달합니다.</li>
<li>HTML 응답 보내기: 서버는 HTML 템플릿을 작성하여 렌더링된 React 컴포넌트를 root ID가 있는 div 안에 삽입합니다. 또한 클라이언트 측 데이터를 초기화하고 클라이언트 측 JavaScript 파일(client.js)을 로드하기 위한 스크립트를 포함합니다.</li>
<li>클라이언트 측 수분화: 브라우저가 HTML을 수신하면 클라이언트 측 JavaScript(client.js)가 서버에서 렌더링된 HTML을 수분화하여 React 컴포넌트가 상호작용할 수 있게 합니다.</li>
</ul>
<p>장점:</p>
<ul>
<li>사전 렌더링된 HTML로 SEO가 유리해집니다.</li>
<li>더 빠른 로딩 속도.</li>
<li>페이지가 항상 최신 상태를 유지합니다.</li>
</ul>
<p>단점:</p>
<div class="content-ad"></div>
<ul>
<li>각 요청이 처리되는 데 더 오래 걸릴 수 있습니다.</li>
<li>CSR(Clinet-Side Rendering)을 사용하는 것보다 페이지 로드에 더 오랜 시간이 소요될 수 있습니다.</li>
<li>정적 렌더링보다 설정 및 유지 관리가 복잡합니다.</li>
</ul>
<h2>스트리밍 렌더링</h2>
<p>스트리밍 렌더링은 서버가 HTML의 일부를 클라이언트에게 가능한 즉시 전송하는 기술입니다. 이를 통해 브라우저가 페이지를 렌더링하기 시작함으로써 웹 애플리케이션의 성능이 향상됩니다.</p>
<p><img src="/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_4.png" alt="Rendering Strategies Every React Developer Should Know"></p>
<div class="content-ad"></div>
<p>중요한 포인트:</p>
<ol>
<li>
<p>느껴지는 성능 개선: 사용자는 나머지 부분이 렌더링되고 스트리밍되는 동안 페이지 일부와 상호 작용을 시작할 수 있습니다.</p>
</li>
<li>
<p>점진적 렌더링: 페이지의 핵심 부분이 먼저 전송되고 렌더링되어 사용자 경험을 향상시킵니다.</p>
</li>
<li>
<p>첫 번째 바이트로의 시간 단축(TTFB): 스트리밍을 통해 첫 번째 바이트로의 시간을 단축시켜 초기 로드가 빠르게 느껴질 수 있습니다.</p>
</li>
</ol>
<div class="content-ad"></div>
<p>React 18의 스트리밍 렌더링은 서버 사이드 렌더링을 위해 새로운 pipeToNodeWritable 메소드를 사용합니다. 이는 HTML 부분을 준비되는 대로 클라이언트로 보냅니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">React</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactDOMServer</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-dom/server'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params">{ data }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>{data.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{data.content}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/'</span>, <span class="hljs-keyword">async</span> (req, res) => {
  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data'</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();

  <span class="hljs-keyword">const</span> htmlStart = <span class="hljs-string">`
    &#x3C;!DOCTYPE html>
    &#x3C;html lang="en">
      &#x3C;head>
        &#x3C;meta charset="UTF-8">
        &#x3C;meta name="viewport" content="width=device-width, initial-scale=1.0">
        &#x3C;title>Streaming Rendering&#x3C;/title>
      &#x3C;/head>
      &#x3C;body>
        &#x3C;div id="root">
  `</span>;

  <span class="hljs-keyword">const</span> htmlEnd = <span class="hljs-string">`
        &#x3C;/div>
        &#x3C;script>
          window.__INITIAL_DATA__ = <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(data)}</span>
        &#x3C;/script>
        &#x3C;script src="/client.js">&#x3C;/script>
      &#x3C;/body>
    &#x3C;/html>
  `</span>;

  res.<span class="hljs-title function_">write</span>(htmlStart);

  <span class="hljs-keyword">const</span> writable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Writable</span>({
    <span class="hljs-title function_">write</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
      res.<span class="hljs-title function_">write</span>(chunk, encoding, callback);
    },
    <span class="hljs-title function_">final</span>(<span class="hljs-params">callback</span>) {
      res.<span class="hljs-title function_">write</span>(htmlEnd);
      res.<span class="hljs-title function_">end</span>();
      <span class="hljs-title function_">callback</span>();
    },
  });

  <span class="hljs-title class_">ReactDOMServer</span>.<span class="hljs-title function_">pipeToNodeWritable</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Home</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span> /></span></span>, writable);
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Server is running on http://localhost:3000'</span>);
});
</code></pre>
<p>작동 방식:</p>
<div class="content-ad"></div>
<ul>
<li>서버 측: 초기 HTML을 스트리밍하기 위해 ReactDOMServer.pipeToNodeWritable을 사용합니다.</li>
<li>클라이언트 측: 클라이언트는 HTML의 일부를 도착하는 대로 렌더링을 시작합니다.</li>
</ul>
<p>장점:</p>
<ul>
<li>사용자가 페이지 일부와 상호 작용할 수 있습니다.</li>
<li>핵심 콘텐츠가 먼저 표시되어 사용자 경험이 향상됩니다.</li>
<li>더 많은 콘텐츠가 로드됨에 따라 사용자 인터페이스가 점진적으로 향상됩니다.</li>
<li>페이지 전체를 한꺼번에 렌더링할 필요가 없기 때문에 서버 및 클라이언트 리소스를 적게 사용합니다.</li>
<li>검색 엔진이 콘텐츠를 더 빨리 찾을 수 있습니다.</li>
</ul>
<p>단점:</p>
<div class="content-ad"></div>
<ul>
<li>Implementation은 전통적 렌더링보다 복잡합니다.</li>
<li>올바른 렌더링을 보장하기 위해 종속성 및 스트리밍 순서를 관리해야 합니다.</li>
<li>모든 브라우저나 네트워크에서 스트리밍할 수 있는 것은 아닙니다.</li>
<li>비동기적인 성격 때문에 스트리밍 문제 해결이 더 어렵습니다.</li>
<li>제대로 관리되지 않으면 서버 및 클라이언트 렌더링된 콘텐츠 사이에 차이가 있을 수 있습니다.</li>
</ul>
<h2>정적 사이트 생성</h2>
<p>정적 사이트 생성은 HTML 페이지를 미리 렌더링하여 정적 파일로 제공하는 기술입니다. 이 접근 방식은 사전 렌더링된 HTML을 제공함으로써 성능을 향상시키고 서버 부하를 줄이며 보안을 강화할 수 있습니다.</p>
<p>주요 포인트:</p>
<div class="content-ad"></div>
<ol>
<li>
<p>성능: 페이지가 사전 렌더링되어 정적 파일로 제공되므로 로딩 속도가 매우 빠릅니다.</p>
</li>
<li>
<p>SEO: 사전 렌더링된 HTML은 검색 엔진이 쉽게 크롤링하여 SEO를 개선합니다.</p>
</li>
<li>
<p>보안: 정적 파일을 제공함으로써 서버 렌더링된 페이지와 비교하여 공격 표면이 줄어듭니다.</p>
</li>
</ol>
<p>예시:</p>
<div class="content-ad"></div>
<p>다음은 Next.js를 사용한 SSG의 예시입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// pages/index.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params">{ data }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>{data.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{data.content}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticProps</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data'</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">props</span>: {
      data,
    },
  };
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Home</span>;
</code></pre>
<p>이 예제에서는:</p>
<p>• getStaticProps 함수는 데이터를 빌드 시간에 가져오고 서버에서 실행됩니다.</p>
<div class="content-ad"></div>
<ul>
<li>
<p>홈 컴포넌트로 전달된 데이터는 props를 통해 전달됩니다.</p>
</li>
<li>
<p>HTML은 빌드 시 생성되어 정적 파일로 제공됩니다.</p>
</li>
</ul>
<p>장점:</p>
<ul>
<li>정적 파일의 빠른 로드 시간.</li>
<li>사전 렌더링된 HTML로 SEO 향상.</li>
<li>더 빠른 서버와 안전한 데이터.</li>
</ul>
<div class="content-ad"></div>
<p><strong>단점:</strong></p>
<ul>
<li>내용 변경에 대한 유연성이 부족합니다.</li>
<li>우선 구축해야 합니다.</li>
<li>대규모 사이트의 경우 빌드 시간이 더 오래 걸릴 수 있습니다.</li>
</ul>
<h2>증분 정적 재생</h2>
<p>증분 정적 재생(Incremental Static Regeneration, ISR)은 사이트를 빌드하고 배포한 후 정적 페이지를 업데이트할 수 있는 기능입니다. 이 접근 방식은 정적 사이트 생성의 이점과 내용을 업데이트할 수 있는 유연성을 결합합니다.</p>
<div class="content-ad"></div>
<p>중요한 점:</p>
<ol>
<li>
<p>요청 시 업데이트: 데이터 변경 시 전체 사이트 재구축이 필요하지 않고 페이지를 증분적으로 업데이트할 수 있습니다.</p>
</li>
<li>
<p>향상된 성능: 정적 컨텐츠를 제공하면서 특정 페이지를 새로 고침하고 업데이트할 수 있는 기능을 제공합니다.</p>
</li>
<li>
<p>유연성: 정적 사이트의 속도와 동적 콘텐츠 업데이트를 처리할 수 있는 능력을 결합합니다.</p>
</li>
</ol>
<div class="content-ad"></div>
<p>예시:</p>
<p>다음은 ISR을 보여주는 Next.js 사용 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// pages/index.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Home</span>(<span class="hljs-params">{ data }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>{data.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{data.content}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStaticProps</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data'</span>);
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">props</span>: {
      data,
    },
    <span class="hljs-attr">revalidate</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// 최대 10초마다 페이지를 다시 생성합니다.</span>
  };
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Home</span>;
</code></pre>
<p>이 예시에서:</p>
<div class="content-ad"></div>
<ul>
<li>getStaticProps 함수는 빌드 시간에 데이터를 가져옵니다.</li>
<li>revalidate 속성은 다시 유효화 기간(예: 10초)을 지정하여 해당 기간 동안 최대 한 번 페이지가 다시 생성되도록 하여 요청이 들어오면.</li>
<li>생성된 정적 HTML은 완전한 사이트 재구성 없이 새 데이터로 업데이트할 수 있습니다.</li>
</ul>
<p>장점:</p>
<ul>
<li>빠르고 유연합니다.</li>
<li>HTML로 인한 SEO 향상.</li>
<li>빈번한 재구성 요구를 줄여 시간과 리소스를 절약합니다.</li>
</ul>
<p>단점:</p>
<div class="content-ad"></div>
<ul>
<li>정적 사이트 생성보다 설정하는 것이 더 복잡합니다.</li>
<li>최신 콘텐츠가 사용자에게 즉시 표시되지 않을 수 있습니다.</li>
</ul>
<h2>재수전</h2>
<p>React에서 재수전은 서버에서 React 애플리케이션을 렌더링하여 초기 HTML을 생성한 다음 React가 클라이언트에서 페이지를 상호작용하도록 만드는 것을 의미합니다. 이 과정을 통해 사용자가 빠르게 시작하고 JavaScript가 준비되면 페이지와 상호 작용할 수 있도록 합니다.</p>
<p>주요 요점:</p>
<div class="content-ad"></div>
<ol>
<li>
<p>서버 측 렌더링 (SSR): 서버가 초기 HTML을 생성합니다.</p>
</li>
<li>
<p>클라이언트 측 재가동: 클라이언트 측 React 코드가 페이지를 대화식으로 만듭니다.</p>
</li>
</ol>
<p>예시:</p>
<p>다음은 React를 사용하여 재가동을 보여주는 간단한 예시입니다:</p>
<div class="content-ad"></div>
<p>서버 측</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">React</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactDOMServer</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-dom/server'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./App'</span>).<span class="hljs-property">default</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'build'</span>)));

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'*'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {
  <span class="hljs-keyword">const</span> appString = <span class="hljs-title class_">ReactDOMServer</span>.<span class="hljs-title function_">renderToString</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>);

  <span class="hljs-keyword">const</span> indexFile = path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'build'</span>, <span class="hljs-string">'index.html'</span>);
  fs.<span class="hljs-title function_">readFile</span>(indexFile, <span class="hljs-string">'utf8'</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =></span> {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'에러 발생:'</span>, err);
      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">'앗!'</span>);
    }

    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">send</span>(
      data.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'&#x3C;div id="root">&#x3C;/div>'</span>, <span class="hljs-string">`&#x3C;div id="root"><span class="hljs-subst">${appString}</span>&#x3C;/div>`</span>)
    );
  });
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'서버가 http://localhost:3000에서 실행 중입니다.'</span>);
});
</code></pre>
<p>클라이언트 측</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;

<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">hydrate</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>));
</code></pre>
<div class="content-ad"></div>
<p>작동 방식:</p>
<ol>
<li>
<p>서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 페이지 로드를 위한 HTML을 생성합니다. 이 HTML은 index.html 템플릿에 삽입됩니다.</p>
</li>
<li>
<p>클라이언트 측: 클라이언트가 페이지를 로드할 때, ReactDOM.hydrate가 정적 HTML을 가져와 상호 작용할 수 있도록 이벤트 리스너를 부착합니다.</p>
</li>
</ol>
<p>장점:</p>
<div class="content-ad"></div>
<ul>
<li>서버에서 미리 렌더링된 HTML로 인한 빠른 초기로드 시간.</li>
<li>미리 렌더링된 콘텐츠로 개선된 SEO.</li>
<li>클라이언트 측 JavaScript가 로드된 후 완전한 상호작용 가능.</li>
</ul>
<p>단점:</p>
<ul>
<li>JavaScript가 로드될 때까지 상호작용이 지연될 수 있음.</li>
<li>서버 및 클라이언트에서 렌더링된 콘텐츠가 일치하는지 확인하기 어려울 수 있음.</li>
</ul>
<h2>부분 유기화</h2>
<div class="content-ad"></div>
<p>부분 수분화는 웹 개발에서 일부 정적 HTML 페이지만 상호 작용적으로 만드는 기술입니다. 이 방식은 페이지의 일부만 상호 작용을 요구하는 부분에 대해 JavaScript를로드하고 실행해 성능을 향상시키며, 전반적인 JavaScript 페이로드를 줄입니다.</p>
<p><img src="/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_5.png" alt="Rendering Strategies Every React Developer Should Know"></p>
<p>주요 포인트:</p>
<ul>
<li>선택적 상호 작용: 페이지의 일부만로드됩니다.</li>
<li>더 빠른 성능: 덜 JavaScript를로드 및 실행하므로 페이지가 더 빨리로드되고 더 적은 리소스를 사용합니다.</li>
<li>점진적 향상: 페이지가 잘 작동하고 사용하기 쉬운지 확인합니다.</li>
</ul>
<div class="content-ad"></div>
<p>예시:</p>
<p>리액트를 사용하여 부분 하이드레이션을 보여주는 예시입니다:</p>
<p>클라이언트 측</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;

<span class="hljs-keyword">const</span> rootElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>);
<span class="hljs-keyword">if</span> (rootElement.<span class="hljs-title function_">hasChildNodes</span>()) {
  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">hydrate</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>, rootElement);
} <span class="hljs-keyword">else</span> {
  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>, rootElement);
}
</code></pre>
<div class="content-ad"></div>
<p>React Components (App.js와 InteractiveComponent.js)</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/App.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">InteractiveComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./InteractiveComponent'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>정적 콘텐츠<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">InteractiveComponent</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/InteractiveComponent.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">InteractiveComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> setCount(count + 1)}>클릭하세요<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{count}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">InteractiveComponent</span>;
</code></pre>
<p>작동 방식:</p>
<div class="content-ad"></div>
<ul>
<li>서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 페이지로드를 위한 HTML을 생성합니다. 이 HTML은 index.html 템플릿에 삽입됩니다.</li>
<li>클라이언트 측: 클라이언트가 페이지를 로드할 때, ReactDOM.hydrate는 필요한 인터랙션이 필요한 페이지 부분만 적용합니다.</li>
</ul>
<p>장점:</p>
<ul>
<li>더 작은 JavaScript 페이로드로 인해 더 빠른로드 시간.</li>
<li>페이지의 필요한 부분만 적용.</li>
<li>사용자들은 더 많은 인터랙션을 즐깁니다.</li>
</ul>
<p>단점:</p>
<div class="content-ad"></div>
<ul>
<li>전체 페이지 하이드레이션보다 더 복잡합니다.</li>
<li>주의 깊게 관리해야 합니다.</li>
</ul>
<h2>점진적 하이드레이션</h2>
<p>점진적 하이드레이션은 웹 페이지의 다른 부분이 하나씩 로드되는 기술입니다. 이 방법은 필수 부분의 하이드레이션을 우선시하여 비필수 부분의 하이드레이션을 지연시킴으로써 성능을 향상시킵니다.</p>
<p>주요 포인트:</p>
<div class="content-ad"></div>
<ul>
<li>점진적으로 수분을 보충하는 것: 페이지의 일부는 점차적으로 로드됩니다.</li>
<li>우선순위를 둔 상호작용: 중요 구성 요소가 먼저 수분 보충됩니다.</li>
<li>성능 최적화: 초기 JavaScript 페이로드를 줄이고 페이지 로드 시간을 개선합니다.</li>
</ul>
<p>예시:</p>
<p>React 및 Intersection Observer API를 사용하여 점진적 수분 보충을 보여주는 예시:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">hydrateComponent</span>(<span class="hljs-params">selector, Component</span>) {
  <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(selector);
  <span class="hljs-keyword">if</span> (element &#x26;&#x26; element.<span class="hljs-title function_">hasChildNodes</span>()) {
    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">hydrate</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Component</span> /></span></span>, element);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element) {
    <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Component</span> /></span></span>, element);
  }
}

<span class="hljs-title function_">hydrateComponent</span>(<span class="hljs-string">'#root'</span>, <span class="hljs-title class_">App</span>);
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/App.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =></span> {
      entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">entry</span>) =></span> {
        <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {
          <span class="hljs-keyword">import</span>(<span class="hljs-string">'./ProgressiveComponent'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">{ <span class="hljs-keyword">default</span>: Component }</span>) =></span> {
            <span class="hljs-title function_">hydrateComponent</span>(<span class="hljs-string">'#progressive'</span>, <span class="hljs-title class_">Component</span>);
          });
          observer.<span class="hljs-title function_">disconnect</span>();
        }
      });
    });

    observer.<span class="hljs-title function_">observe</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#progressive'</span>));

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> observer.<span class="hljs-title function_">disconnect</span>();
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>Static Content<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"progressive"</span>></span>Loading...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/ProgressiveComponent.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ProgressiveComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> setCount(count + 1)}>Click me<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{count}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ProgressiveComponent</span>;
</code></pre>
<p>동작 방식:</p>
<ul>
<li>서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 HTML을 생성합니다.</li>
<li>클라이언트 측: ReactDOM.hydrate은 주 응용 프로그램을 즉시 채웁니다.</li>
<li>점진적 구성 요소 수화: Intersection Observer는 ProgressiveComponent가 뷰포트에 진입할 때 그것을 수화합니다.</li>
</ul>
<div class="content-ad"></div>
<p>장점:</p>
<ul>
<li>필수 구성 요소만 먼저 로드하여 로드 시간을 개선했습니다.</li>
<li>사용자들이 더 나은 경험을 할 수 있습니다.</li>
<li>Javascript 파일이 줄어 듭니다.</li>
</ul>
<p>단점:</p>
<ul>
<li>전체 페이지 가득 채우기보다 복잡합니다.</li>
<li>문제를 피하기 위해 신중하게 관리해야 합니다.</li>
</ul>
<div class="content-ad"></div>
<h2>동적 렌더링</h2>
<p>동적 렌더링은 사용자가 원하는 내용을 기반으로 웹 페이지를 만드는 방법입니다. 이 방법은 크롤러와 사용자에게 서로 다른 내용을 제공함으로써 웹 사이트를 최적화하여 사용자와 검색 엔진을 위한 최적의 서비스를 제공합니다.</p>
<p><img src="/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_6.png" alt="랜더링 전략"></p>
<p>주요 포인트:</p>
<div class="content-ad"></div>
<ol>
<li>
<p>하이브리드 접근 방식: 서버 측 및 클라이언트 측 렌더링을 결합하여 성능 및 SEO를 최적화합니다.</p>
</li>
<li>
<p>SEO 최적화: 사전 렌더링된 HTML을 검색 엔진에 제공하여 크롤링 및 인덱싱을 개선합니다.</p>
</li>
<li>
<p>사용자 경험: 사용자가 사이트와 완전히 상호 작용할 수 있습니다.</p>
</li>
</ol>
<p>예시:</p>
<div class="content-ad"></div>
<p>Node.js와 Puppeteer를 사용한 동적 렌더링 예제가 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> puppeteer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'puppeteer'</span>);

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'*'</span>, <span class="hljs-keyword">async</span> (req, res) => {
  <span class="hljs-keyword">const</span> userAgent = req.<span class="hljs-property">headers</span>[<span class="hljs-string">'user-agent'</span>];
  
  <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/Googlebot|Bingbot|Baiduspider|YandexBot/i</span>.<span class="hljs-title function_">test</span>(userAgent)) {
    <span class="hljs-keyword">const</span> browser = <span class="hljs-keyword">await</span> puppeteer.<span class="hljs-title function_">launch</span>();
    <span class="hljs-keyword">const</span> page = <span class="hljs-keyword">await</span> browser.<span class="hljs-title function_">newPage</span>();
    <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">goto</span>(<span class="hljs-string">`http://localhost:3000<span class="hljs-subst">${req.originalUrl}</span>`</span>, {
      <span class="hljs-attr">waitUntil</span>: <span class="hljs-string">'networkidle2'</span>
    });
    <span class="hljs-keyword">const</span> html = <span class="hljs-keyword">await</span> page.<span class="hljs-title function_">content</span>();
    <span class="hljs-keyword">await</span> browser.<span class="hljs-title function_">close</span>();
    res.<span class="hljs-title function_">send</span>(html);
  } <span class="hljs-keyword">else</span> {
    res.<span class="hljs-title function_">sendFile</span>(__dirname + <span class="hljs-string">'/index.html'</span>);
  }
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'서버가 http://localhost:3000에서 실행 중입니다.'</span>);
});
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/index.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;

<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>));
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/App.js</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/api/data'</span>)
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =></span> response.<span class="hljs-title function_">json</span>())
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =></span> <span class="hljs-title function_">setData</span>(data));
  }, []);

  <span class="hljs-keyword">if</span> (!data) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Loading...<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>{data.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{data.content}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<div class="content-ad"></div>
<p>API 엔드포인트 (Node.js + Express)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/data'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {
  res.<span class="hljs-title function_">json</span>({
    <span class="hljs-attr">title</span>: <span class="hljs-string">'Dynamic Rendering Example'</span>,
    <span class="hljs-attr">content</span>: <span class="hljs-string">'This content is fetched from the server.'</span>
  });
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3001</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'API 서버가 http://localhost:3001에서 실행 중입니다.'</span>);
});
</code></pre>
<p>이 예제에서:</p>
<ul>
<li>서버는 사용자 에이전트 헤더를 확인하여 요청이 검색 엔진 봇에서 왔는지 확인합니다.</li>
<li>요청이 봇에서 왔다면, Puppeteer가 사전 렌더링된 HTML을 생성하고 반환합니다.</li>
<li>요청이 사용자에서 왔다면, 클라이언트 렌더링된 HTML이 제공되며, React 애플리케이션이 API 엔드포인트에서 데이터를 가져옵니다.</li>
</ul>
<div class="content-ad"></div>
<p>장점:</p>
<ul>
<li>서버 측 및 클라이언트 측 렌더링을 결합합니다.</li>
<li>검색 엔진 봇에 사전 렌더링된 콘텐츠를 제공하여 SEO를 최적화합니다.</li>
<li>사용자가 상호 작용할 수 있습니다.</li>
</ul>
<p>단점:</p>
<ul>
<li>서버 설치 및 유지 관리가 더 복잡합니다.</li>
<li>프리 렌더링을 위해 headless 브라우저가 필요하기 때문에 더 많은 리소스를 사용합니다.</li>
<li>사용자 에이전트 감지 및 동적 콘텐츠 생성에 주의를 기울여야 합니다.</li>
</ul>
<div class="content-ad"></div>
<h2>결론</h2>
<p>웹 개발의 빠르게 변화하는 세계에서는 웹 페이지를 멋지게 보이고 빠르게 로드하기 위한 다양한 방법을 이해하고 활용하는 것이 중요합니다. 각 렌더링 방법에는 다양한 장단이 있습니다.</p>
<p>중요 사항:</p>
<ol>
<li>클라이언트 측 렌더링 (CSR)은 사용자에게는 훌륭하지만 SEO 및 로딩 시간에 대비하여 다소 어려울 수 있습니다.</li>
</ol>
<div class="content-ad"></div>
<ol start="2">
<li>
<p>서버 사이드 렌더링 (SSR)은 초기 로드 속도를 향상시키고 SEO를 개선하지만 서버 부하와 복잡성을 증가시킬 수 있습니다.</p>
</li>
<li>
<p>스트리밍 렌더링은 HTML을 점진적으로 클라이언트로 전송하여 인식된 성능을 향상시킵니다.</p>
</li>
<li>
<p>정적 사이트 생성 (SSG)은 빠른 로드 시간과 향상된 보안을 제공하여 변경되지 않는 콘텐츠에 이상적입니다.</p>
</li>
<li>
<p>점진적 정적 재생성 (ISR)은 정적 및 동적 콘텐츠 업데이트의 이점을 결합하여 성능과 유연성을 균형 있게 제공합니다.</p>
</li>
</ol>
<div class="content-ad"></div>
<ol start="6">
<li>
<p>리하이드레이션은 서버에서 렌더링된 HTML과 클라이언트 측 상호 작용을 연결하여 부드러운 사용자 경험을 제공합니다.</p>
</li>
<li>
<p>부분 하이드레이션 및 점진적 하이드레이션은 필요에 따라 페이지의 일부를 선택적으로 상호 작용할 수 있도록 최적화하여 성능을 향상시킵니다.</p>
</li>
<li>
<p>동적 렌더링은 사전 렌더링된 콘텐츠를 검색 엔진 최적화를 위해 봇에 제공하면서 사용자에게 동적 콘텐츠를 제공하여 향상된 경험을 제공합니다.</p>
</li>
</ol>
<p>적절한 렌더링 전략은 앱의 요구 사항, 성능 및 사용자 경험에 따라 다릅니다. 이러한 기술을 사용함으로써 개발자들은 사용자와 검색 엔진에게 잘 작동하는 사용자 친화적인 웹 앱을 만들 수 있습니다.</p>
<div class="content-ad"></div>
<p>Web 기술이 발전함에 따라, 개발자들은 웹 앱을 빠르게 실행할 수 있는 최상의 방법을 항상 파악해야 합니다. 이러한 방법을 활용하여 훌륭한 디지털 경험을 만들어보세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"렌더링 전략 모든 React 개발자가 알아야 할 것들","description":"","date":"2024-06-19 23:51","slug":"2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow","content":"\n\n\n![Image](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png)\n\n## 소개:\n\nReact는 현대 웹 개발의 핵심입니다. 최대한 효과적으로 활용하려면 복잡한 렌더링 전략을 이해하고 사용해야 합니다. 이 글에서는 이러한 전략을 보여드릴 것입니다.\n\n이러한 전략은 React 개발자가 더 빠르고 효율적인 앱을 만들 수 있도록 돕습니다. 개발을 쉽게 만들어주고 사용자에게 더 나은 경험을 제공합니다. 얼마나 많은 경험이 있든, 이러한 전략들은 여러분을 도와줄 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 렌더링 방법 이해하기\n\nReact의 렌더링 프로세스는 UI를 효율적으로 업데이트하는 방법입니다. 두 가지 주요 단계가 있습니다: 렌더 및 커밋.\n\n![이미지](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_1.png)\n\n렌더 단계\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n렌더 단계는 React가 가상 UI를 구축하는 렌더링의 첫 부분입니다. 이 단계에는 DOM 변경이나 데이터 가져오기와 같은 부작용이 없습니다. 이 단계에는 두 가지 주요 단계가 있습니다:\n\n- 가상 DOM 생성: 컴포넌트의 상태나 props가 변경될 때 React는 새 가상 DOM 트리를 생성합니다.\n- 차이 비교: React는 새 가상 DOM 트리와 현재 피버 트리를 비교(se)합니다. 이 프로세스에서는 새 가상 DOM이 이전 것과 비교했을 때 무엇이 변경되었는지를 결정합니다.\n- 작업 단위: 피버 노드(Fiber nodes)는 작업 단위를 나타냅니다. 각 피버 노드는 React 엘리먼트(컴포넌트 또는 DOM 엘리먼트)에 해당하며, 컴포넌트의 상태, props 및 기타 메타데이터 정보를 포함합니다.\n\n커밋 단계\n\n이 단계에서는 렌더 단계 중에 플래그 처리된 변경 사항을 사용자에게 최신 UI 상태를 표시하기 위해 실제 DOM에 적용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DOM 변경 이전 단계: DOM 변경 이전에 실행해야 하는 부작용들이 여기서 처리됩니다.\n- DOM 변경 단계: Fiber 트리에서 식별된 변경 사항에 따라 실제 DOM 업데이트가 적용됩니다.\n- 레이아웃 단계: DOM 변경 이후에 실행해야 하는 부작용들이 이 단계에서 처리됩니다.\n\n커밋 단계는 동기적으로 이루어지며 직접적인 DOM 조작을 포함하며 이로 인해 부작용이 발생할 수 있습니다.\n\n주요 개념:\n\n- Fiber 아키텍처: React의 Fiber 아키텍처는 조각 단위로 렌더링할 수 있게 합니다. 이는 React를 더 효율적으로 만들어주며 메인 스레드를 차단하지 않고 대규모 업데이트를 처리할 수 있습니다.\n- 동시 모드: React 18에서 동시 모드가 도입되어 React가 동시에 여러 작업을 처리할 수 있습니다. 이로써 사용자 경험을 더 부드럽게 만들어주며 중요하지 않은 작업을 일시 중단하고 긴급한 업데이트에 집중할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 테이블 태그가 변경되었습니다.\n\n\n![이미지](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_2.png)\n\n주요 포인트:\n\n1. 동적 콘텐츠 로딩: CSR은 전체 페이지 새로고침 없이 동적으로 콘텐츠를 로드할 수 있습니다.\n\n2. 향상된 사용자 상호작용: 렌더링이 클라이언트 측에서 발생하기 때문에 상호작용이 더 반응적일 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. SEO 도전: 검색 엔진은 JavaScript에 크게 의존하는 CSR 콘텐츠를 색인화하는 데 어려움을 겪을 수 있습니다.\n\n4. 초기로딩 시간: CSR은 브라우저가 콘텐츠를 렌더링하기 전에 JavaScript를 다운로드하고 실행해야 하므로 초기 로딩 시간이 느려질 수 있습니다.\n\n예시:\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\n\nfunction App() {\n  const [data, setData] = useState(null);\n\n  useEffect(() =\u003e {\n    fetch('https://api.example.com/data')\n      .then(response =\u003e response.json())\n      .then(data =\u003e setData(data));\n  }, []);\n\n  if (!data) {\n    return \u003cdiv\u003eLoading...\u003c/div\u003e;\n  }\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      \u003cp\u003e{data.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서:\n\n- useEffect 훅은 컴포넌트가 마운트될 때 API에서 데이터를 가져옵니다.\n- 상태(data)가 가져온 데이터로 업데이트되고, 컴포넌트가 다시 렌더링되어 그것을 보여줍니다.\n- 데이터가 가져와질 때까지 초기 콘텐츠로 표시되는 것은 로딩 메시지입니다.\n\n장점:\n\n- 상호 작용 요소로 풍부한 사용자 경험.\n- 단일 페이지 애플리케이션(SPAs)을 위한 효율적인 데이터 가져오기 및 렌더링.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단점:\n\n- 첫 페이지가 로딩하는 데 시간이 걸립니다.\n- 서버 측 렌더링 또는 사전 렌더링 없이 SEO를 하는 것이 어렵습니다.\n\n## 서버 측 렌더링\n\n서버 측 렌더링(SSR)은 서버가 페이지의 HTML을 생성하고 클라이언트에게 보내는 기술입니다. 이 접근 방식은 서버에서 완전히 렌더링된 페이지를 직접 제공함으로써 웹 앱의 성능과 SEO를 개선합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 테이블 태그를 Markdown 형식으로 변경하신 것입니다.\n\nKey Points:\n\n1. 향상된 SEO: 컨텐츠가 서버에서 완전히 렌더링되므로 검색 엔진이 페이지를 쉽게 크롤링하고 색인화할 수 있습니다.\n\n2. 초기 로드 속도 향상: 사용자들은 첫 요청 시 완전히 렌더링된 페이지를 받아들이므로 CSR에 비해 초기 로드가 더 빠를 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. Dynamic Content: SSR는 동적 콘텐츠를 처리할 수 있어서 페이지를 요청할 때마다 최신 정보를 제공합니다.\n\n예시:\n\n```js\nconst express = require('express');\nconst fetch = require('node-fetch');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\n\nconst app = express();\n\napp.get('/', async (req, res) =\u003e {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n\n  const appString = ReactDOMServer.renderToString(\u003cHome data={data} /\u003e);\n\n  const html = `\n    \u003c!DOCTYPE html\u003e\n    \u003chtml lang=\"en\"\u003e\n      \u003chead\u003e\n        \u003cmeta charset=\"UTF-8\"\u003e\n        \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n        \u003ctitle\u003eServer-Side Rendering with Express\u003c/title\u003e\n      \u003c/head\u003e\n      \u003cbody\u003e\n        \u003cdiv id=\"root\"\u003e${appString}\u003c/div\u003e\n        \u003cscript\u003e\n          window.__INITIAL_DATA__ = ${JSON.stringify(data)}\n        \u003c/script\u003e\n        \u003cscript src=\"/client.js\"\u003e\u003c/script\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  `;\n\n  res.send(html);\n});\n\napp.listen(3000, () =\u003e {\n  console.log('서버가 http://localhost:3000에서 실행 중입니다.');\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서버 설정: 예제는 Express 프레임워크를 사용하여 서버를 설정합니다. 루트 URL(`/`)로 요청이 들어오면, 외부 API에서 데이터를 가져옵니다.\n- 데이터 가져오기: 서버는 node-fetch를 사용하여 API 엔드포인트(https://api.example.com/data)로 HTTP 요청을 보냅니다. 가져온 데이터는 JSON 형식으로 변환됩니다.\n- React 컴포넌트 렌더링: 서버는 ReactDOMServer.renderToString을 사용하여 Home React 컴포넌트를 HTML 문자열로 렌더링하고, 가져온 데이터를 prop으로 전달합니다.\n- HTML 응답 보내기: 서버는 HTML 템플릿을 작성하여 렌더링된 React 컴포넌트를 root ID가 있는 div 안에 삽입합니다. 또한 클라이언트 측 데이터를 초기화하고 클라이언트 측 JavaScript 파일(client.js)을 로드하기 위한 스크립트를 포함합니다.\n- 클라이언트 측 수분화: 브라우저가 HTML을 수신하면 클라이언트 측 JavaScript(client.js)가 서버에서 렌더링된 HTML을 수분화하여 React 컴포넌트가 상호작용할 수 있게 합니다.\n\n장점:\n\n- 사전 렌더링된 HTML로 SEO가 유리해집니다.\n- 더 빠른 로딩 속도.\n- 페이지가 항상 최신 상태를 유지합니다.\n\n단점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 각 요청이 처리되는 데 더 오래 걸릴 수 있습니다.\n- CSR(Clinet-Side Rendering)을 사용하는 것보다 페이지 로드에 더 오랜 시간이 소요될 수 있습니다.\n- 정적 렌더링보다 설정 및 유지 관리가 복잡합니다.\n\n## 스트리밍 렌더링\n\n스트리밍 렌더링은 서버가 HTML의 일부를 클라이언트에게 가능한 즉시 전송하는 기술입니다. 이를 통해 브라우저가 페이지를 렌더링하기 시작함으로써 웹 애플리케이션의 성능이 향상됩니다.\n\n![Rendering Strategies Every React Developer Should Know](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중요한 포인트:\n\n1. 느껴지는 성능 개선: 사용자는 나머지 부분이 렌더링되고 스트리밍되는 동안 페이지 일부와 상호 작용을 시작할 수 있습니다.\n\n2. 점진적 렌더링: 페이지의 핵심 부분이 먼저 전송되고 렌더링되어 사용자 경험을 향상시킵니다.\n\n3. 첫 번째 바이트로의 시간 단축(TTFB): 스트리밍을 통해 첫 번째 바이트로의 시간을 단축시켜 초기 로드가 빠르게 느껴질 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact 18의 스트리밍 렌더링은 서버 사이드 렌더링을 위해 새로운 pipeToNodeWritable 메소드를 사용합니다. 이는 HTML 부분을 준비되는 대로 클라이언트로 보냅니다.\n\n```js\nconst express = require('express');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst { Writable } = require('stream');\n\nconst app = express();\n\nfunction Home({ data }) {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      \u003cp\u003e{data.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\napp.get('/', async (req, res) =\u003e {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n\n  const htmlStart = `\n    \u003c!DOCTYPE html\u003e\n    \u003chtml lang=\"en\"\u003e\n      \u003chead\u003e\n        \u003cmeta charset=\"UTF-8\"\u003e\n        \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n        \u003ctitle\u003eStreaming Rendering\u003c/title\u003e\n      \u003c/head\u003e\n      \u003cbody\u003e\n        \u003cdiv id=\"root\"\u003e\n  `;\n\n  const htmlEnd = `\n        \u003c/div\u003e\n        \u003cscript\u003e\n          window.__INITIAL_DATA__ = ${JSON.stringify(data)}\n        \u003c/script\u003e\n        \u003cscript src=\"/client.js\"\u003e\u003c/script\u003e\n      \u003c/body\u003e\n    \u003c/html\u003e\n  `;\n\n  res.write(htmlStart);\n\n  const writable = new Writable({\n    write(chunk, encoding, callback) {\n      res.write(chunk, encoding, callback);\n    },\n    final(callback) {\n      res.write(htmlEnd);\n      res.end();\n      callback();\n    },\n  });\n\n  ReactDOMServer.pipeToNodeWritable(\u003cHome data={data} /\u003e, writable);\n});\n\napp.listen(3000, () =\u003e {\n  console.log('Server is running on http://localhost:3000');\n});\n```\n\n작동 방식:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서버 측: 초기 HTML을 스트리밍하기 위해 ReactDOMServer.pipeToNodeWritable을 사용합니다.\n- 클라이언트 측: 클라이언트는 HTML의 일부를 도착하는 대로 렌더링을 시작합니다.\n\n장점:\n\n- 사용자가 페이지 일부와 상호 작용할 수 있습니다.\n- 핵심 콘텐츠가 먼저 표시되어 사용자 경험이 향상됩니다.\n- 더 많은 콘텐츠가 로드됨에 따라 사용자 인터페이스가 점진적으로 향상됩니다.\n- 페이지 전체를 한꺼번에 렌더링할 필요가 없기 때문에 서버 및 클라이언트 리소스를 적게 사용합니다.\n- 검색 엔진이 콘텐츠를 더 빨리 찾을 수 있습니다.\n\n단점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Implementation은 전통적 렌더링보다 복잡합니다.\n- 올바른 렌더링을 보장하기 위해 종속성 및 스트리밍 순서를 관리해야 합니다.\n- 모든 브라우저나 네트워크에서 스트리밍할 수 있는 것은 아닙니다.\n- 비동기적인 성격 때문에 스트리밍 문제 해결이 더 어렵습니다.\n- 제대로 관리되지 않으면 서버 및 클라이언트 렌더링된 콘텐츠 사이에 차이가 있을 수 있습니다.\n\n## 정적 사이트 생성\n\n정적 사이트 생성은 HTML 페이지를 미리 렌더링하여 정적 파일로 제공하는 기술입니다. 이 접근 방식은 사전 렌더링된 HTML을 제공함으로써 성능을 향상시키고 서버 부하를 줄이며 보안을 강화할 수 있습니다.\n\n주요 포인트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 성능: 페이지가 사전 렌더링되어 정적 파일로 제공되므로 로딩 속도가 매우 빠릅니다.\n\n2. SEO: 사전 렌더링된 HTML은 검색 엔진이 쉽게 크롤링하여 SEO를 개선합니다.\n\n3. 보안: 정적 파일을 제공함으로써 서버 렌더링된 페이지와 비교하여 공격 표면이 줄어듭니다.\n\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 Next.js를 사용한 SSG의 예시입니다.\n\n```js\n// pages/index.js\nimport React from 'react';\n\nfunction Home({ data }) {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      \u003cp\u003e{data.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport async function getStaticProps() {\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n\n  return {\n    props: {\n      data,\n    },\n  };\n}\n\nexport default Home;\n```\n\n이 예제에서는:\n\n• getStaticProps 함수는 데이터를 빌드 시간에 가져오고 서버에서 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 홈 컴포넌트로 전달된 데이터는 props를 통해 전달됩니다.\n\n- HTML은 빌드 시 생성되어 정적 파일로 제공됩니다.\n\n장점:\n\n- 정적 파일의 빠른 로드 시간.\n- 사전 렌더링된 HTML로 SEO 향상.\n- 더 빠른 서버와 안전한 데이터.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**단점:**\n\n- 내용 변경에 대한 유연성이 부족합니다.\n- 우선 구축해야 합니다.\n- 대규모 사이트의 경우 빌드 시간이 더 오래 걸릴 수 있습니다.\n\n## 증분 정적 재생\n\n증분 정적 재생(Incremental Static Regeneration, ISR)은 사이트를 빌드하고 배포한 후 정적 페이지를 업데이트할 수 있는 기능입니다. 이 접근 방식은 정적 사이트 생성의 이점과 내용을 업데이트할 수 있는 유연성을 결합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중요한 점:\n\n1. 요청 시 업데이트: 데이터 변경 시 전체 사이트 재구축이 필요하지 않고 페이지를 증분적으로 업데이트할 수 있습니다.\n\n2. 향상된 성능: 정적 컨텐츠를 제공하면서 특정 페이지를 새로 고침하고 업데이트할 수 있는 기능을 제공합니다.\n\n3. 유연성: 정적 사이트의 속도와 동적 콘텐츠 업데이트를 처리할 수 있는 능력을 결합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n다음은 ISR을 보여주는 Next.js 사용 예시입니다:\n\n```js\n// pages/index.js\nimport React from 'react';\n\nfunction Home({ data }) {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      \u003cp\u003e{data.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport async function getStaticProps() {\n  const res = await fetch('https://api.example.com/data');\n  const data = await res.json();\n\n  return {\n    props: {\n      data,\n    },\n    revalidate: 10, // 최대 10초마다 페이지를 다시 생성합니다.\n  };\n}\n\nexport default Home;\n```\n\n이 예시에서:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- getStaticProps 함수는 빌드 시간에 데이터를 가져옵니다.\n- revalidate 속성은 다시 유효화 기간(예: 10초)을 지정하여 해당 기간 동안 최대 한 번 페이지가 다시 생성되도록 하여 요청이 들어오면.\n- 생성된 정적 HTML은 완전한 사이트 재구성 없이 새 데이터로 업데이트할 수 있습니다.\n\n장점:\n\n- 빠르고 유연합니다.\n- HTML로 인한 SEO 향상.\n- 빈번한 재구성 요구를 줄여 시간과 리소스를 절약합니다.\n\n단점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 정적 사이트 생성보다 설정하는 것이 더 복잡합니다.\n- 최신 콘텐츠가 사용자에게 즉시 표시되지 않을 수 있습니다.\n\n## 재수전\n\nReact에서 재수전은 서버에서 React 애플리케이션을 렌더링하여 초기 HTML을 생성한 다음 React가 클라이언트에서 페이지를 상호작용하도록 만드는 것을 의미합니다. 이 과정을 통해 사용자가 빠르게 시작하고 JavaScript가 준비되면 페이지와 상호 작용할 수 있도록 합니다.\n\n주요 요점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 서버 측 렌더링 (SSR): 서버가 초기 HTML을 생성합니다.\n\n2. 클라이언트 측 재가동: 클라이언트 측 React 코드가 페이지를 대화식으로 만듭니다.\n\n예시:\n\n다음은 React를 사용하여 재가동을 보여주는 간단한 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서버 측\n\n```js\nconst express = require('express');\nconst React = require('react');\nconst ReactDOMServer = require('react-dom/server');\nconst fs = require('fs');\nconst path = require('path');\n\nconst App = require('./App').default;\n\nconst app = express();\n\napp.use(express.static(path.resolve(__dirname, 'build')));\n\napp.get('*', (req, res) =\u003e {\n  const appString = ReactDOMServer.renderToString(\u003cApp /\u003e);\n\n  const indexFile = path.resolve(__dirname, 'build', 'index.html');\n  fs.readFile(indexFile, 'utf8', (err, data) =\u003e {\n    if (err) {\n      console.error('에러 발생:', err);\n      return res.status(500).send('앗!');\n    }\n\n    return res.send(\n      data.replace('\u003cdiv id=\"root\"\u003e\u003c/div\u003e', `\u003cdiv id=\"root\"\u003e${appString}\u003c/div\u003e`)\n    );\n  });\n});\n\napp.listen(3000, () =\u003e {\n  console.log('서버가 http://localhost:3000에서 실행 중입니다.');\n});\n```\n\n클라이언트 측\n\n```js\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.hydrate(\u003cApp /\u003e, document.getElementById('root'));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작동 방식:\n\n1. 서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 페이지 로드를 위한 HTML을 생성합니다. 이 HTML은 index.html 템플릿에 삽입됩니다.\n\n2. 클라이언트 측: 클라이언트가 페이지를 로드할 때, ReactDOM.hydrate가 정적 HTML을 가져와 상호 작용할 수 있도록 이벤트 리스너를 부착합니다.\n\n장점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서버에서 미리 렌더링된 HTML로 인한 빠른 초기로드 시간.\n- 미리 렌더링된 콘텐츠로 개선된 SEO.\n- 클라이언트 측 JavaScript가 로드된 후 완전한 상호작용 가능.\n\n단점:\n\n- JavaScript가 로드될 때까지 상호작용이 지연될 수 있음.\n- 서버 및 클라이언트에서 렌더링된 콘텐츠가 일치하는지 확인하기 어려울 수 있음.\n\n## 부분 유기화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n부분 수분화는 웹 개발에서 일부 정적 HTML 페이지만 상호 작용적으로 만드는 기술입니다. 이 방식은 페이지의 일부만 상호 작용을 요구하는 부분에 대해 JavaScript를로드하고 실행해 성능을 향상시키며, 전반적인 JavaScript 페이로드를 줄입니다.\n\n![Rendering Strategies Every React Developer Should Know](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_5.png)\n\n주요 포인트:\n\n- 선택적 상호 작용: 페이지의 일부만로드됩니다.\n- 더 빠른 성능: 덜 JavaScript를로드 및 실행하므로 페이지가 더 빨리로드되고 더 적은 리소스를 사용합니다.\n- 점진적 향상: 페이지가 잘 작동하고 사용하기 쉬운지 확인합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n리액트를 사용하여 부분 하이드레이션을 보여주는 예시입니다:\n\n클라이언트 측\n\n```js\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nconst rootElement = document.getElementById('root');\nif (rootElement.hasChildNodes()) {\n  ReactDOM.hydrate(\u003cApp /\u003e, rootElement);\n} else {\n  ReactDOM.render(\u003cApp /\u003e, rootElement);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact Components (App.js와 InteractiveComponent.js)\n\n```js\n// src/App.js\nimport React from 'react';\nimport InteractiveComponent from './InteractiveComponent';\n\nfunction App() {\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e정적 콘텐츠\u003c/h1\u003e\n      \u003cInteractiveComponent /\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n```js\n// src/InteractiveComponent.js\nimport React, { useState } from 'react';\n\nfunction InteractiveComponent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e클릭하세요\u003c/button\u003e\n      \u003cp\u003e{count}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default InteractiveComponent;\n```\n\n작동 방식:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 페이지로드를 위한 HTML을 생성합니다. 이 HTML은 index.html 템플릿에 삽입됩니다.\n- 클라이언트 측: 클라이언트가 페이지를 로드할 때, ReactDOM.hydrate는 필요한 인터랙션이 필요한 페이지 부분만 적용합니다.\n\n장점:\n- 더 작은 JavaScript 페이로드로 인해 더 빠른로드 시간.\n- 페이지의 필요한 부분만 적용.\n- 사용자들은 더 많은 인터랙션을 즐깁니다.\n\n단점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 전체 페이지 하이드레이션보다 더 복잡합니다.\n- 주의 깊게 관리해야 합니다.\n\n## 점진적 하이드레이션\n\n점진적 하이드레이션은 웹 페이지의 다른 부분이 하나씩 로드되는 기술입니다. 이 방법은 필수 부분의 하이드레이션을 우선시하여 비필수 부분의 하이드레이션을 지연시킴으로써 성능을 향상시킵니다.\n\n주요 포인트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 점진적으로 수분을 보충하는 것: 페이지의 일부는 점차적으로 로드됩니다.\n- 우선순위를 둔 상호작용: 중요 구성 요소가 먼저 수분 보충됩니다.\n- 성능 최적화: 초기 JavaScript 페이로드를 줄이고 페이지 로드 시간을 개선합니다.\n\n예시:\n\nReact 및 Intersection Observer API를 사용하여 점진적 수분 보충을 보여주는 예시:\n\n```js\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nfunction hydrateComponent(selector, Component) {\n  const element = document.querySelector(selector);\n  if (element \u0026\u0026 element.hasChildNodes()) {\n    ReactDOM.hydrate(\u003cComponent /\u003e, element);\n  } else if (element) {\n    ReactDOM.render(\u003cComponent /\u003e, element);\n  }\n}\n\nhydrateComponent('#root', App);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// src/App.js\nimport React, { useEffect } from 'react';\n\nfunction App() {\n  useEffect(() =\u003e {\n    const observer = new IntersectionObserver((entries) =\u003e {\n      entries.forEach((entry) =\u003e {\n        if (entry.isIntersecting) {\n          import('./ProgressiveComponent').then(({ default: Component }) =\u003e {\n            hydrateComponent('#progressive', Component);\n          });\n          observer.disconnect();\n        }\n      });\n    });\n\n    observer.observe(document.querySelector('#progressive'));\n\n    return () =\u003e observer.disconnect();\n  }, []);\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eStatic Content\u003c/h1\u003e\n      \u003cdiv id=\"progressive\"\u003eLoading...\u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n```js\n// src/ProgressiveComponent.js\nimport React, { useState } from 'react';\n\nfunction ProgressiveComponent() {\n  const [count, setCount] = useState(0);\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eClick me\u003c/button\u003e\n      \u003cp\u003e{count}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default ProgressiveComponent;\n```\n\n동작 방식:\n\n- 서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 HTML을 생성합니다.\n- 클라이언트 측: ReactDOM.hydrate은 주 응용 프로그램을 즉시 채웁니다.\n- 점진적 구성 요소 수화: Intersection Observer는 ProgressiveComponent가 뷰포트에 진입할 때 그것을 수화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n장점:\n\n- 필수 구성 요소만 먼저 로드하여 로드 시간을 개선했습니다.\n- 사용자들이 더 나은 경험을 할 수 있습니다.\n- Javascript 파일이 줄어 듭니다.\n\n단점:\n\n- 전체 페이지 가득 채우기보다 복잡합니다.\n- 문제를 피하기 위해 신중하게 관리해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 동적 렌더링\n\n동적 렌더링은 사용자가 원하는 내용을 기반으로 웹 페이지를 만드는 방법입니다. 이 방법은 크롤러와 사용자에게 서로 다른 내용을 제공함으로써 웹 사이트를 최적화하여 사용자와 검색 엔진을 위한 최적의 서비스를 제공합니다.\n\n![랜더링 전략](/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_6.png)\n\n주요 포인트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 하이브리드 접근 방식: 서버 측 및 클라이언트 측 렌더링을 결합하여 성능 및 SEO를 최적화합니다.\n\n2. SEO 최적화: 사전 렌더링된 HTML을 검색 엔진에 제공하여 크롤링 및 인덱싱을 개선합니다.\n\n3. 사용자 경험: 사용자가 사이트와 완전히 상호 작용할 수 있습니다.\n\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js와 Puppeteer를 사용한 동적 렌더링 예제가 있어요:\n\n```js\nconst express = require('express');\nconst puppeteer = require('puppeteer');\n\nconst app = express();\n\napp.get('*', async (req, res) =\u003e {\n  const userAgent = req.headers['user-agent'];\n  \n  if (/Googlebot|Bingbot|Baiduspider|YandexBot/i.test(userAgent)) {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.goto(`http://localhost:3000${req.originalUrl}`, {\n      waitUntil: 'networkidle2'\n    });\n    const html = await page.content();\n    await browser.close();\n    res.send(html);\n  } else {\n    res.sendFile(__dirname + '/index.html');\n  }\n});\n\napp.listen(3000, () =\u003e {\n  console.log('서버가 http://localhost:3000에서 실행 중입니다.');\n});\n```\n\n```js\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\u003cApp /\u003e, document.getElementById('root'));\n```\n\n```js\n// src/App.js\nimport React, { useState, useEffect } from 'react';\n\nfunction App() {\n  const [data, setData] = useState(null);\n\n  useEffect(() =\u003e {\n    fetch('/api/data')\n      .then(response =\u003e response.json())\n      .then(data =\u003e setData(data));\n  }, []);\n\n  if (!data) {\n    return \u003cdiv\u003eLoading...\u003c/div\u003e;\n  }\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{data.title}\u003c/h1\u003e\n      \u003cp\u003e{data.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default App;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI 엔드포인트 (Node.js + Express)\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.get('/api/data', (req, res) =\u003e {\n  res.json({\n    title: 'Dynamic Rendering Example',\n    content: 'This content is fetched from the server.'\n  });\n});\n\napp.listen(3001, () =\u003e {\n  console.log('API 서버가 http://localhost:3001에서 실행 중입니다.');\n});\n```\n\n이 예제에서:\n\n- 서버는 사용자 에이전트 헤더를 확인하여 요청이 검색 엔진 봇에서 왔는지 확인합니다.\n- 요청이 봇에서 왔다면, Puppeteer가 사전 렌더링된 HTML을 생성하고 반환합니다.\n- 요청이 사용자에서 왔다면, 클라이언트 렌더링된 HTML이 제공되며, React 애플리케이션이 API 엔드포인트에서 데이터를 가져옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n장점:\n\n- 서버 측 및 클라이언트 측 렌더링을 결합합니다.\n- 검색 엔진 봇에 사전 렌더링된 콘텐츠를 제공하여 SEO를 최적화합니다.\n- 사용자가 상호 작용할 수 있습니다.\n\n단점:\n\n- 서버 설치 및 유지 관리가 더 복잡합니다.\n- 프리 렌더링을 위해 headless 브라우저가 필요하기 때문에 더 많은 리소스를 사용합니다.\n- 사용자 에이전트 감지 및 동적 콘텐츠 생성에 주의를 기울여야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\n웹 개발의 빠르게 변화하는 세계에서는 웹 페이지를 멋지게 보이고 빠르게 로드하기 위한 다양한 방법을 이해하고 활용하는 것이 중요합니다. 각 렌더링 방법에는 다양한 장단이 있습니다.\n\n중요 사항:\n\n1. 클라이언트 측 렌더링 (CSR)은 사용자에게는 훌륭하지만 SEO 및 로딩 시간에 대비하여 다소 어려울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 서버 사이드 렌더링 (SSR)은 초기 로드 속도를 향상시키고 SEO를 개선하지만 서버 부하와 복잡성을 증가시킬 수 있습니다.\n\n3. 스트리밍 렌더링은 HTML을 점진적으로 클라이언트로 전송하여 인식된 성능을 향상시킵니다.\n\n4. 정적 사이트 생성 (SSG)은 빠른 로드 시간과 향상된 보안을 제공하여 변경되지 않는 콘텐츠에 이상적입니다.\n\n5. 점진적 정적 재생성 (ISR)은 정적 및 동적 콘텐츠 업데이트의 이점을 결합하여 성능과 유연성을 균형 있게 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n6. 리하이드레이션은 서버에서 렌더링된 HTML과 클라이언트 측 상호 작용을 연결하여 부드러운 사용자 경험을 제공합니다.\n\n7. 부분 하이드레이션 및 점진적 하이드레이션은 필요에 따라 페이지의 일부를 선택적으로 상호 작용할 수 있도록 최적화하여 성능을 향상시킵니다.\n\n9. 동적 렌더링은 사전 렌더링된 콘텐츠를 검색 엔진 최적화를 위해 봇에 제공하면서 사용자에게 동적 콘텐츠를 제공하여 향상된 경험을 제공합니다.\n\n적절한 렌더링 전략은 앱의 요구 사항, 성능 및 사용자 경험에 따라 다릅니다. 이러한 기술을 사용함으로써 개발자들은 사용자와 검색 엔진에게 잘 작동하는 사용자 친화적인 웹 앱을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWeb 기술이 발전함에 따라, 개발자들은 웹 앱을 빠르게 실행할 수 있는 최상의 방법을 항상 파악해야 합니다. 이러한 방법을 활용하여 훌륭한 디지털 경험을 만들어보세요.","ogImage":{"url":"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":20},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_0.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003ch2\u003e소개:\u003c/h2\u003e\n\u003cp\u003eReact는 현대 웹 개발의 핵심입니다. 최대한 효과적으로 활용하려면 복잡한 렌더링 전략을 이해하고 사용해야 합니다. 이 글에서는 이러한 전략을 보여드릴 것입니다.\u003c/p\u003e\n\u003cp\u003e이러한 전략은 React 개발자가 더 빠르고 효율적인 앱을 만들 수 있도록 돕습니다. 개발을 쉽게 만들어주고 사용자에게 더 나은 경험을 제공합니다. 얼마나 많은 경험이 있든, 이러한 전략들은 여러분을 도와줄 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e렌더링 방법 이해하기\u003c/h2\u003e\n\u003cp\u003eReact의 렌더링 프로세스는 UI를 효율적으로 업데이트하는 방법입니다. 두 가지 주요 단계가 있습니다: 렌더 및 커밋.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e렌더 단계\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e렌더 단계는 React가 가상 UI를 구축하는 렌더링의 첫 부분입니다. 이 단계에는 DOM 변경이나 데이터 가져오기와 같은 부작용이 없습니다. 이 단계에는 두 가지 주요 단계가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e가상 DOM 생성: 컴포넌트의 상태나 props가 변경될 때 React는 새 가상 DOM 트리를 생성합니다.\u003c/li\u003e\n\u003cli\u003e차이 비교: React는 새 가상 DOM 트리와 현재 피버 트리를 비교(se)합니다. 이 프로세스에서는 새 가상 DOM이 이전 것과 비교했을 때 무엇이 변경되었는지를 결정합니다.\u003c/li\u003e\n\u003cli\u003e작업 단위: 피버 노드(Fiber nodes)는 작업 단위를 나타냅니다. 각 피버 노드는 React 엘리먼트(컴포넌트 또는 DOM 엘리먼트)에 해당하며, 컴포넌트의 상태, props 및 기타 메타데이터 정보를 포함합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e커밋 단계\u003c/p\u003e\n\u003cp\u003e이 단계에서는 렌더 단계 중에 플래그 처리된 변경 사항을 사용자에게 최신 UI 상태를 표시하기 위해 실제 DOM에 적용합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eDOM 변경 이전 단계: DOM 변경 이전에 실행해야 하는 부작용들이 여기서 처리됩니다.\u003c/li\u003e\n\u003cli\u003eDOM 변경 단계: Fiber 트리에서 식별된 변경 사항에 따라 실제 DOM 업데이트가 적용됩니다.\u003c/li\u003e\n\u003cli\u003e레이아웃 단계: DOM 변경 이후에 실행해야 하는 부작용들이 이 단계에서 처리됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e커밋 단계는 동기적으로 이루어지며 직접적인 DOM 조작을 포함하며 이로 인해 부작용이 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e주요 개념:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFiber 아키텍처: React의 Fiber 아키텍처는 조각 단위로 렌더링할 수 있게 합니다. 이는 React를 더 효율적으로 만들어주며 메인 스레드를 차단하지 않고 대규모 업데이트를 처리할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e동시 모드: React 18에서 동시 모드가 도입되어 React가 동시에 여러 작업을 처리할 수 있습니다. 이로써 사용자 경험을 더 부드럽게 만들어주며 중요하지 않은 작업을 일시 중단하고 긴급한 업데이트에 집중할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e테이블 태그를 Markdown 형식으로 변경해주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 Markdown 형식으로 테이블 태그가 변경되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e주요 포인트:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e동적 콘텐츠 로딩: CSR은 전체 페이지 새로고침 없이 동적으로 콘텐츠를 로드할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e향상된 사용자 상호작용: 렌더링이 클라이언트 측에서 발생하기 때문에 상호작용이 더 반응적일 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e\n\u003cp\u003eSEO 도전: 검색 엔진은 JavaScript에 크게 의존하는 CSR 콘텐츠를 색인화하는 데 어려움을 겪을 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e초기로딩 시간: CSR은 브라우저가 콘텐츠를 렌더링하기 전에 JavaScript를 다운로드하고 실행해야 하므로 초기 로딩 시간이 느려질 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState, useEffect } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-dom'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [data, setData] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/data'\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u003e\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n      .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetData\u003c/span\u003e(data));\n  }, []);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!data) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eLoading...\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e{data.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{data.content}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e, \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 예시에서:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003euseEffect 훅은 컴포넌트가 마운트될 때 API에서 데이터를 가져옵니다.\u003c/li\u003e\n\u003cli\u003e상태(data)가 가져온 데이터로 업데이트되고, 컴포넌트가 다시 렌더링되어 그것을 보여줍니다.\u003c/li\u003e\n\u003cli\u003e데이터가 가져와질 때까지 초기 콘텐츠로 표시되는 것은 로딩 메시지입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e상호 작용 요소로 풍부한 사용자 경험.\u003c/li\u003e\n\u003cli\u003e단일 페이지 애플리케이션(SPAs)을 위한 효율적인 데이터 가져오기 및 렌더링.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e첫 페이지가 로딩하는 데 시간이 걸립니다.\u003c/li\u003e\n\u003cli\u003e서버 측 렌더링 또는 사전 렌더링 없이 SEO를 하는 것이 어렵습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e서버 측 렌더링\u003c/h2\u003e\n\u003cp\u003e서버 측 렌더링(SSR)은 서버가 페이지의 HTML을 생성하고 클라이언트에게 보내는 기술입니다. 이 접근 방식은 서버에서 완전히 렌더링된 페이지를 직접 제공함으로써 웹 앱의 성능과 SEO를 개선합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 테이블 태그를 Markdown 형식으로 변경하신 것입니다.\u003c/p\u003e\n\u003cp\u003eKey Points:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e향상된 SEO: 컨텐츠가 서버에서 완전히 렌더링되므로 검색 엔진이 페이지를 쉽게 크롤링하고 색인화할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e초기 로드 속도 향상: 사용자들은 첫 요청 시 완전히 렌더링된 페이지를 받아들이므로 CSR에 비해 초기 로드가 더 빠를 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eDynamic Content: SSR는 동적 콘텐츠를 처리할 수 있어서 페이지를 요청할 때마다 최신 정보를 제공합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e express = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'express'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fetch = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'node-fetch'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactDOMServer\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'react-dom/server'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e();\n\napp.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (req, res) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/data'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e appString = \u003cspan class=\"hljs-title class_\"\u003eReactDOMServer\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erenderToString\u003c/span\u003e(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eHome\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{data}\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e html = \u003cspan class=\"hljs-string\"\u003e`\n    \u0026#x3C;!DOCTYPE html\u003e\n    \u0026#x3C;html lang=\"en\"\u003e\n      \u0026#x3C;head\u003e\n        \u0026#x3C;meta charset=\"UTF-8\"\u003e\n        \u0026#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n        \u0026#x3C;title\u003eServer-Side Rendering with Express\u0026#x3C;/title\u003e\n      \u0026#x3C;/head\u003e\n      \u0026#x3C;body\u003e\n        \u0026#x3C;div id=\"root\"\u003e\u003cspan class=\"hljs-subst\"\u003e${appString}\u003c/span\u003e\u0026#x3C;/div\u003e\n        \u0026#x3C;script\u003e\n          window.__INITIAL_DATA__ = \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(data)}\u003c/span\u003e\n        \u0026#x3C;/script\u003e\n        \u0026#x3C;script src=\"/client.js\"\u003e\u0026#x3C;/script\u003e\n      \u0026#x3C;/body\u003e\n    \u0026#x3C;/html\u003e\n  `\u003c/span\u003e;\n\n  res.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(html);\n});\n\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'서버가 http://localhost:3000에서 실행 중입니다.'\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e서버 설정: 예제는 Express 프레임워크를 사용하여 서버를 설정합니다. 루트 URL(\u003ccode\u003e/\u003c/code\u003e)로 요청이 들어오면, 외부 API에서 데이터를 가져옵니다.\u003c/li\u003e\n\u003cli\u003e데이터 가져오기: 서버는 node-fetch를 사용하여 API 엔드포인트(\u003ca href=\"https://api.example.com/data)%EB%A1%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://api.example.com/data)로\u003c/a\u003e HTTP 요청을 보냅니다. 가져온 데이터는 JSON 형식으로 변환됩니다.\u003c/li\u003e\n\u003cli\u003eReact 컴포넌트 렌더링: 서버는 ReactDOMServer.renderToString을 사용하여 Home React 컴포넌트를 HTML 문자열로 렌더링하고, 가져온 데이터를 prop으로 전달합니다.\u003c/li\u003e\n\u003cli\u003eHTML 응답 보내기: 서버는 HTML 템플릿을 작성하여 렌더링된 React 컴포넌트를 root ID가 있는 div 안에 삽입합니다. 또한 클라이언트 측 데이터를 초기화하고 클라이언트 측 JavaScript 파일(client.js)을 로드하기 위한 스크립트를 포함합니다.\u003c/li\u003e\n\u003cli\u003e클라이언트 측 수분화: 브라우저가 HTML을 수신하면 클라이언트 측 JavaScript(client.js)가 서버에서 렌더링된 HTML을 수분화하여 React 컴포넌트가 상호작용할 수 있게 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사전 렌더링된 HTML로 SEO가 유리해집니다.\u003c/li\u003e\n\u003cli\u003e더 빠른 로딩 속도.\u003c/li\u003e\n\u003cli\u003e페이지가 항상 최신 상태를 유지합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e각 요청이 처리되는 데 더 오래 걸릴 수 있습니다.\u003c/li\u003e\n\u003cli\u003eCSR(Clinet-Side Rendering)을 사용하는 것보다 페이지 로드에 더 오랜 시간이 소요될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e정적 렌더링보다 설정 및 유지 관리가 복잡합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e스트리밍 렌더링\u003c/h2\u003e\n\u003cp\u003e스트리밍 렌더링은 서버가 HTML의 일부를 클라이언트에게 가능한 즉시 전송하는 기술입니다. 이를 통해 브라우저가 페이지를 렌더링하기 시작함으로써 웹 애플리케이션의 성능이 향상됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_4.png\" alt=\"Rendering Strategies Every React Developer Should Know\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e중요한 포인트:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e느껴지는 성능 개선: 사용자는 나머지 부분이 렌더링되고 스트리밍되는 동안 페이지 일부와 상호 작용을 시작할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e점진적 렌더링: 페이지의 핵심 부분이 먼저 전송되고 렌더링되어 사용자 경험을 향상시킵니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e첫 번째 바이트로의 시간 단축(TTFB): 스트리밍을 통해 첫 번째 바이트로의 시간을 단축시켜 초기 로드가 빠르게 느껴질 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eReact 18의 스트리밍 렌더링은 서버 사이드 렌더링을 위해 새로운 pipeToNodeWritable 메소드를 사용합니다. 이는 HTML 부분을 준비되는 대로 클라이언트로 보냅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e express = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'express'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactDOMServer\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'react-dom/server'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eWritable\u003c/span\u003e } = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'stream'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e();\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHome\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ data }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e{data.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{data.content}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\napp.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (req, res) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/data'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e htmlStart = \u003cspan class=\"hljs-string\"\u003e`\n    \u0026#x3C;!DOCTYPE html\u003e\n    \u0026#x3C;html lang=\"en\"\u003e\n      \u0026#x3C;head\u003e\n        \u0026#x3C;meta charset=\"UTF-8\"\u003e\n        \u0026#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n        \u0026#x3C;title\u003eStreaming Rendering\u0026#x3C;/title\u003e\n      \u0026#x3C;/head\u003e\n      \u0026#x3C;body\u003e\n        \u0026#x3C;div id=\"root\"\u003e\n  `\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e htmlEnd = \u003cspan class=\"hljs-string\"\u003e`\n        \u0026#x3C;/div\u003e\n        \u0026#x3C;script\u003e\n          window.__INITIAL_DATA__ = \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(data)}\u003c/span\u003e\n        \u0026#x3C;/script\u003e\n        \u0026#x3C;script src=\"/client.js\"\u003e\u0026#x3C;/script\u003e\n      \u0026#x3C;/body\u003e\n    \u0026#x3C;/html\u003e\n  `\u003c/span\u003e;\n\n  res.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(htmlStart);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e writable = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWritable\u003c/span\u003e({\n    \u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003echunk, encoding, callback\u003c/span\u003e) {\n      res.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(chunk, encoding, callback);\n    },\n    \u003cspan class=\"hljs-title function_\"\u003efinal\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecallback\u003c/span\u003e) {\n      res.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(htmlEnd);\n      res.\u003cspan class=\"hljs-title function_\"\u003eend\u003c/span\u003e();\n      \u003cspan class=\"hljs-title function_\"\u003ecallback\u003c/span\u003e();\n    },\n  });\n\n  \u003cspan class=\"hljs-title class_\"\u003eReactDOMServer\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epipeToNodeWritable\u003c/span\u003e(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eHome\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{data}\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e, writable);\n});\n\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Server is running on http://localhost:3000'\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e작동 방식:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e서버 측: 초기 HTML을 스트리밍하기 위해 ReactDOMServer.pipeToNodeWritable을 사용합니다.\u003c/li\u003e\n\u003cli\u003e클라이언트 측: 클라이언트는 HTML의 일부를 도착하는 대로 렌더링을 시작합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자가 페이지 일부와 상호 작용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e핵심 콘텐츠가 먼저 표시되어 사용자 경험이 향상됩니다.\u003c/li\u003e\n\u003cli\u003e더 많은 콘텐츠가 로드됨에 따라 사용자 인터페이스가 점진적으로 향상됩니다.\u003c/li\u003e\n\u003cli\u003e페이지 전체를 한꺼번에 렌더링할 필요가 없기 때문에 서버 및 클라이언트 리소스를 적게 사용합니다.\u003c/li\u003e\n\u003cli\u003e검색 엔진이 콘텐츠를 더 빨리 찾을 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eImplementation은 전통적 렌더링보다 복잡합니다.\u003c/li\u003e\n\u003cli\u003e올바른 렌더링을 보장하기 위해 종속성 및 스트리밍 순서를 관리해야 합니다.\u003c/li\u003e\n\u003cli\u003e모든 브라우저나 네트워크에서 스트리밍할 수 있는 것은 아닙니다.\u003c/li\u003e\n\u003cli\u003e비동기적인 성격 때문에 스트리밍 문제 해결이 더 어렵습니다.\u003c/li\u003e\n\u003cli\u003e제대로 관리되지 않으면 서버 및 클라이언트 렌더링된 콘텐츠 사이에 차이가 있을 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e정적 사이트 생성\u003c/h2\u003e\n\u003cp\u003e정적 사이트 생성은 HTML 페이지를 미리 렌더링하여 정적 파일로 제공하는 기술입니다. 이 접근 방식은 사전 렌더링된 HTML을 제공함으로써 성능을 향상시키고 서버 부하를 줄이며 보안을 강화할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e주요 포인트:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e성능: 페이지가 사전 렌더링되어 정적 파일로 제공되므로 로딩 속도가 매우 빠릅니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSEO: 사전 렌더링된 HTML은 검색 엔진이 쉽게 크롤링하여 SEO를 개선합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e보안: 정적 파일을 제공함으로써 서버 렌더링된 페이지와 비교하여 공격 표면이 줄어듭니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음은 Next.js를 사용한 SSG의 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// pages/index.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHome\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ data }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e{data.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{data.content}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetStaticProps\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/data'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: {\n      data,\n    },\n  };\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHome\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는:\u003c/p\u003e\n\u003cp\u003e• getStaticProps 함수는 데이터를 빌드 시간에 가져오고 서버에서 실행됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e홈 컴포넌트로 전달된 데이터는 props를 통해 전달됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHTML은 빌드 시 생성되어 정적 파일로 제공됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e정적 파일의 빠른 로드 시간.\u003c/li\u003e\n\u003cli\u003e사전 렌더링된 HTML로 SEO 향상.\u003c/li\u003e\n\u003cli\u003e더 빠른 서버와 안전한 데이터.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cstrong\u003e단점:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e내용 변경에 대한 유연성이 부족합니다.\u003c/li\u003e\n\u003cli\u003e우선 구축해야 합니다.\u003c/li\u003e\n\u003cli\u003e대규모 사이트의 경우 빌드 시간이 더 오래 걸릴 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e증분 정적 재생\u003c/h2\u003e\n\u003cp\u003e증분 정적 재생(Incremental Static Regeneration, ISR)은 사이트를 빌드하고 배포한 후 정적 페이지를 업데이트할 수 있는 기능입니다. 이 접근 방식은 정적 사이트 생성의 이점과 내용을 업데이트할 수 있는 유연성을 결합합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e중요한 점:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e요청 시 업데이트: 데이터 변경 시 전체 사이트 재구축이 필요하지 않고 페이지를 증분적으로 업데이트할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e향상된 성능: 정적 컨텐츠를 제공하면서 특정 페이지를 새로 고침하고 업데이트할 수 있는 기능을 제공합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e유연성: 정적 사이트의 속도와 동적 콘텐츠 업데이트를 처리할 수 있는 능력을 결합합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cp\u003e다음은 ISR을 보여주는 Next.js 사용 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// pages/index.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHome\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ data }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e{data.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{data.content}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetStaticProps\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/data'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eprops\u003c/span\u003e: {\n      data,\n    },\n    \u003cspan class=\"hljs-attr\"\u003erevalidate\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 최대 10초마다 페이지를 다시 생성합니다.\u003c/span\u003e\n  };\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHome\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003egetStaticProps 함수는 빌드 시간에 데이터를 가져옵니다.\u003c/li\u003e\n\u003cli\u003erevalidate 속성은 다시 유효화 기간(예: 10초)을 지정하여 해당 기간 동안 최대 한 번 페이지가 다시 생성되도록 하여 요청이 들어오면.\u003c/li\u003e\n\u003cli\u003e생성된 정적 HTML은 완전한 사이트 재구성 없이 새 데이터로 업데이트할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e빠르고 유연합니다.\u003c/li\u003e\n\u003cli\u003eHTML로 인한 SEO 향상.\u003c/li\u003e\n\u003cli\u003e빈번한 재구성 요구를 줄여 시간과 리소스를 절약합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e정적 사이트 생성보다 설정하는 것이 더 복잡합니다.\u003c/li\u003e\n\u003cli\u003e최신 콘텐츠가 사용자에게 즉시 표시되지 않을 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e재수전\u003c/h2\u003e\n\u003cp\u003eReact에서 재수전은 서버에서 React 애플리케이션을 렌더링하여 초기 HTML을 생성한 다음 React가 클라이언트에서 페이지를 상호작용하도록 만드는 것을 의미합니다. 이 과정을 통해 사용자가 빠르게 시작하고 JavaScript가 준비되면 페이지와 상호 작용할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e주요 요점:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e서버 측 렌더링 (SSR): 서버가 초기 HTML을 생성합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e클라이언트 측 재가동: 클라이언트 측 React 코드가 페이지를 대화식으로 만듭니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cp\u003e다음은 React를 사용하여 재가동을 보여주는 간단한 예시입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e서버 측\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e express = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'express'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactDOMServer\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'react-dom/server'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fs = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'fs'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e path = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'path'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./App'\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003edefault\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e();\n\napp.\u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(express.\u003cspan class=\"hljs-title function_\"\u003estatic\u003c/span\u003e(path.\u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(__dirname, \u003cspan class=\"hljs-string\"\u003e'build'\u003c/span\u003e)));\n\napp.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'*'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e appString = \u003cspan class=\"hljs-title class_\"\u003eReactDOMServer\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erenderToString\u003c/span\u003e(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e indexFile = path.\u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(__dirname, \u003cspan class=\"hljs-string\"\u003e'build'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'index.html'\u003c/span\u003e);\n  fs.\u003cspan class=\"hljs-title function_\"\u003ereadFile\u003c/span\u003e(indexFile, \u003cspan class=\"hljs-string\"\u003e'utf8'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerr, data\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'에러 발생:'\u003c/span\u003e, err);\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'앗!'\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\n      data.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;div id=\"root\"\u003e\u0026#x3C;/div\u003e'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e`\u0026#x3C;div id=\"root\"\u003e\u003cspan class=\"hljs-subst\"\u003e${appString}\u003c/span\u003e\u0026#x3C;/div\u003e`\u003c/span\u003e)\n    );\n  });\n});\n\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'서버가 http://localhost:3000에서 실행 중입니다.'\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e클라이언트 측\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/index.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-dom'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./App'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehydrate\u003c/span\u003e(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e, \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e작동 방식:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 페이지 로드를 위한 HTML을 생성합니다. 이 HTML은 index.html 템플릿에 삽입됩니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e클라이언트 측: 클라이언트가 페이지를 로드할 때, ReactDOM.hydrate가 정적 HTML을 가져와 상호 작용할 수 있도록 이벤트 리스너를 부착합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e서버에서 미리 렌더링된 HTML로 인한 빠른 초기로드 시간.\u003c/li\u003e\n\u003cli\u003e미리 렌더링된 콘텐츠로 개선된 SEO.\u003c/li\u003e\n\u003cli\u003e클라이언트 측 JavaScript가 로드된 후 완전한 상호작용 가능.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJavaScript가 로드될 때까지 상호작용이 지연될 수 있음.\u003c/li\u003e\n\u003cli\u003e서버 및 클라이언트에서 렌더링된 콘텐츠가 일치하는지 확인하기 어려울 수 있음.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e부분 유기화\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e부분 수분화는 웹 개발에서 일부 정적 HTML 페이지만 상호 작용적으로 만드는 기술입니다. 이 방식은 페이지의 일부만 상호 작용을 요구하는 부분에 대해 JavaScript를로드하고 실행해 성능을 향상시키며, 전반적인 JavaScript 페이로드를 줄입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_5.png\" alt=\"Rendering Strategies Every React Developer Should Know\"\u003e\u003c/p\u003e\n\u003cp\u003e주요 포인트:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e선택적 상호 작용: 페이지의 일부만로드됩니다.\u003c/li\u003e\n\u003cli\u003e더 빠른 성능: 덜 JavaScript를로드 및 실행하므로 페이지가 더 빨리로드되고 더 적은 리소스를 사용합니다.\u003c/li\u003e\n\u003cli\u003e점진적 향상: 페이지가 잘 작동하고 사용하기 쉬운지 확인합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cp\u003e리액트를 사용하여 부분 하이드레이션을 보여주는 예시입니다:\u003c/p\u003e\n\u003cp\u003e클라이언트 측\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/index.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-dom'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./App'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e rootElement = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (rootElement.\u003cspan class=\"hljs-title function_\"\u003ehasChildNodes\u003c/span\u003e()) {\n  \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehydrate\u003c/span\u003e(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e, rootElement);\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e, rootElement);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eReact Components (App.js와 InteractiveComponent.js)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/App.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInteractiveComponent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./InteractiveComponent'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e정적 콘텐츠\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eInteractiveComponent\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/InteractiveComponent.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eInteractiveComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [count, setCount] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e setCount(count + 1)}\u003e클릭하세요\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{count}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInteractiveComponent\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e작동 방식:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 페이지로드를 위한 HTML을 생성합니다. 이 HTML은 index.html 템플릿에 삽입됩니다.\u003c/li\u003e\n\u003cli\u003e클라이언트 측: 클라이언트가 페이지를 로드할 때, ReactDOM.hydrate는 필요한 인터랙션이 필요한 페이지 부분만 적용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e더 작은 JavaScript 페이로드로 인해 더 빠른로드 시간.\u003c/li\u003e\n\u003cli\u003e페이지의 필요한 부분만 적용.\u003c/li\u003e\n\u003cli\u003e사용자들은 더 많은 인터랙션을 즐깁니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e전체 페이지 하이드레이션보다 더 복잡합니다.\u003c/li\u003e\n\u003cli\u003e주의 깊게 관리해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e점진적 하이드레이션\u003c/h2\u003e\n\u003cp\u003e점진적 하이드레이션은 웹 페이지의 다른 부분이 하나씩 로드되는 기술입니다. 이 방법은 필수 부분의 하이드레이션을 우선시하여 비필수 부분의 하이드레이션을 지연시킴으로써 성능을 향상시킵니다.\u003c/p\u003e\n\u003cp\u003e주요 포인트:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e점진적으로 수분을 보충하는 것: 페이지의 일부는 점차적으로 로드됩니다.\u003c/li\u003e\n\u003cli\u003e우선순위를 둔 상호작용: 중요 구성 요소가 먼저 수분 보충됩니다.\u003c/li\u003e\n\u003cli\u003e성능 최적화: 초기 JavaScript 페이로드를 줄이고 페이지 로드 시간을 개선합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cp\u003eReact 및 Intersection Observer API를 사용하여 점진적 수분 보충을 보여주는 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/index.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-dom'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./App'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehydrateComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eselector, Component\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e element = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003equerySelector\u003c/span\u003e(selector);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (element \u0026#x26;\u0026#x26; element.\u003cspan class=\"hljs-title function_\"\u003ehasChildNodes\u003c/span\u003e()) {\n    \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehydrate\u003c/span\u003e(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eComponent\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e, element);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (element) {\n    \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eComponent\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e, element);\n  }\n}\n\n\u003cspan class=\"hljs-title function_\"\u003ehydrateComponent\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#root'\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/App.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useEffect } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e observer = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIntersectionObserver\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eentries\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      entries.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eentry\u003c/span\u003e) =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (entry.\u003cspan class=\"hljs-property\"\u003eisIntersecting\u003c/span\u003e) {\n          \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./ProgressiveComponent'\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e: Component }\u003c/span\u003e) =\u003e\u003c/span\u003e {\n            \u003cspan class=\"hljs-title function_\"\u003ehydrateComponent\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#progressive'\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e);\n          });\n          observer.\u003cspan class=\"hljs-title function_\"\u003edisconnect\u003c/span\u003e();\n        }\n      });\n    });\n\n    observer.\u003cspan class=\"hljs-title function_\"\u003eobserve\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003equerySelector\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#progressive'\u003c/span\u003e));\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e observer.\u003cspan class=\"hljs-title function_\"\u003edisconnect\u003c/span\u003e();\n  }, []);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003eStatic Content\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"progressive\"\u003c/span\u003e\u003e\u003c/span\u003eLoading...\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/ProgressiveComponent.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eProgressiveComponent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [count, setCount] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e setCount(count + 1)}\u003eClick me\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{count}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProgressiveComponent\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e동작 방식:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e서버 측: 서버는 ReactDOMServer.renderToString을 사용하여 초기 HTML을 생성합니다.\u003c/li\u003e\n\u003cli\u003e클라이언트 측: ReactDOM.hydrate은 주 응용 프로그램을 즉시 채웁니다.\u003c/li\u003e\n\u003cli\u003e점진적 구성 요소 수화: Intersection Observer는 ProgressiveComponent가 뷰포트에 진입할 때 그것을 수화합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e필수 구성 요소만 먼저 로드하여 로드 시간을 개선했습니다.\u003c/li\u003e\n\u003cli\u003e사용자들이 더 나은 경험을 할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eJavascript 파일이 줄어 듭니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e전체 페이지 가득 채우기보다 복잡합니다.\u003c/li\u003e\n\u003cli\u003e문제를 피하기 위해 신중하게 관리해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e동적 렌더링\u003c/h2\u003e\n\u003cp\u003e동적 렌더링은 사용자가 원하는 내용을 기반으로 웹 페이지를 만드는 방법입니다. 이 방법은 크롤러와 사용자에게 서로 다른 내용을 제공함으로써 웹 사이트를 최적화하여 사용자와 검색 엔진을 위한 최적의 서비스를 제공합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow_6.png\" alt=\"랜더링 전략\"\u003e\u003c/p\u003e\n\u003cp\u003e주요 포인트:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e하이브리드 접근 방식: 서버 측 및 클라이언트 측 렌더링을 결합하여 성능 및 SEO를 최적화합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSEO 최적화: 사전 렌더링된 HTML을 검색 엔진에 제공하여 크롤링 및 인덱싱을 개선합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e사용자 경험: 사용자가 사이트와 완전히 상호 작용할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eNode.js와 Puppeteer를 사용한 동적 렌더링 예제가 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e express = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'express'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e puppeteer = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'puppeteer'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e();\n\napp.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'*'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (req, res) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userAgent = req.\u003cspan class=\"hljs-property\"\u003eheaders\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'user-agent'\u003c/span\u003e];\n  \n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-regexp\"\u003e/Googlebot|Bingbot|Baiduspider|YandexBot/i\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(userAgent)) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e browser = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e puppeteer.\u003cspan class=\"hljs-title function_\"\u003elaunch\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e page = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e browser.\u003cspan class=\"hljs-title function_\"\u003enewPage\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e page.\u003cspan class=\"hljs-title function_\"\u003egoto\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`http://localhost:3000\u003cspan class=\"hljs-subst\"\u003e${req.originalUrl}\u003c/span\u003e`\u003c/span\u003e, {\n      \u003cspan class=\"hljs-attr\"\u003ewaitUntil\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'networkidle2'\u003c/span\u003e\n    });\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e html = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e page.\u003cspan class=\"hljs-title function_\"\u003econtent\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e browser.\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e();\n    res.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(html);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    res.\u003cspan class=\"hljs-title function_\"\u003esendFile\u003c/span\u003e(__dirname + \u003cspan class=\"hljs-string\"\u003e'/index.html'\u003c/span\u003e);\n  }\n});\n\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'서버가 http://localhost:3000에서 실행 중입니다.'\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/index.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-dom'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./App'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e, \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/App.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState, useEffect } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [data, setData] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/api/data'\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u003e\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n      .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetData\u003c/span\u003e(data));\n  }, []);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!data) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eLoading...\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e{data.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{data.content}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eAPI 엔드포인트 (Node.js + Express)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e express = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'express'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e();\n\napp.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/api/data'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Dynamic Rendering Example'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'This content is fetched from the server.'\u003c/span\u003e\n  });\n});\n\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3001\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'API 서버가 http://localhost:3001에서 실행 중입니다.'\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e서버는 사용자 에이전트 헤더를 확인하여 요청이 검색 엔진 봇에서 왔는지 확인합니다.\u003c/li\u003e\n\u003cli\u003e요청이 봇에서 왔다면, Puppeteer가 사전 렌더링된 HTML을 생성하고 반환합니다.\u003c/li\u003e\n\u003cli\u003e요청이 사용자에서 왔다면, 클라이언트 렌더링된 HTML이 제공되며, React 애플리케이션이 API 엔드포인트에서 데이터를 가져옵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e서버 측 및 클라이언트 측 렌더링을 결합합니다.\u003c/li\u003e\n\u003cli\u003e검색 엔진 봇에 사전 렌더링된 콘텐츠를 제공하여 SEO를 최적화합니다.\u003c/li\u003e\n\u003cli\u003e사용자가 상호 작용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e서버 설치 및 유지 관리가 더 복잡합니다.\u003c/li\u003e\n\u003cli\u003e프리 렌더링을 위해 headless 브라우저가 필요하기 때문에 더 많은 리소스를 사용합니다.\u003c/li\u003e\n\u003cli\u003e사용자 에이전트 감지 및 동적 콘텐츠 생성에 주의를 기울여야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003e웹 개발의 빠르게 변화하는 세계에서는 웹 페이지를 멋지게 보이고 빠르게 로드하기 위한 다양한 방법을 이해하고 활용하는 것이 중요합니다. 각 렌더링 방법에는 다양한 장단이 있습니다.\u003c/p\u003e\n\u003cp\u003e중요 사항:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e클라이언트 측 렌더링 (CSR)은 사용자에게는 훌륭하지만 SEO 및 로딩 시간에 대비하여 다소 어려울 수 있습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003cp\u003e서버 사이드 렌더링 (SSR)은 초기 로드 속도를 향상시키고 SEO를 개선하지만 서버 부하와 복잡성을 증가시킬 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e스트리밍 렌더링은 HTML을 점진적으로 클라이언트로 전송하여 인식된 성능을 향상시킵니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e정적 사이트 생성 (SSG)은 빠른 로드 시간과 향상된 보안을 제공하여 변경되지 않는 콘텐츠에 이상적입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e점진적 정적 재생성 (ISR)은 정적 및 동적 콘텐츠 업데이트의 이점을 결합하여 성능과 유연성을 균형 있게 제공합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003e\n\u003cp\u003e리하이드레이션은 서버에서 렌더링된 HTML과 클라이언트 측 상호 작용을 연결하여 부드러운 사용자 경험을 제공합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e부분 하이드레이션 및 점진적 하이드레이션은 필요에 따라 페이지의 일부를 선택적으로 상호 작용할 수 있도록 최적화하여 성능을 향상시킵니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e동적 렌더링은 사전 렌더링된 콘텐츠를 검색 엔진 최적화를 위해 봇에 제공하면서 사용자에게 동적 콘텐츠를 제공하여 향상된 경험을 제공합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e적절한 렌더링 전략은 앱의 요구 사항, 성능 및 사용자 경험에 따라 다릅니다. 이러한 기술을 사용함으로써 개발자들은 사용자와 검색 엔진에게 잘 작동하는 사용자 친화적인 웹 앱을 만들 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eWeb 기술이 발전함에 따라, 개발자들은 웹 앱을 빠르게 실행할 수 있는 최상의 방법을 항상 파악해야 합니다. 이러한 방법을 활용하여 훌륭한 디지털 경험을 만들어보세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-RenderingStrategiesEveryReactDeveloperShouldKnow"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>