<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>그래프 ML NetworkX 소개 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-GraphMLintroductiontoNetworkX" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="그래프 ML NetworkX 소개 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="그래프 ML NetworkX 소개 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-GraphMLintroductiontoNetworkX" data-gatsby-head="true"/><meta name="twitter:title" content="그래프 ML NetworkX 소개 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 04:49" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">그래프 ML NetworkX 소개</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="그래프 ML NetworkX 소개" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-GraphMLintroductiontoNetworkX&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>| GRAPH| GRAPH ML| NETWORKX| PYTHON|</h2>
<p><img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_0.png" alt="NetworkX"></p>
<p>NetworkX는 Python에서 그래프를 분석, 시각화 및 표현하는 주요 라이브러리입니다. NetworkX에는 많은 함수 모음이 포함되어 있으며, 본 튜토리얼에서는 Python에서 그래프를 시작하고 조작하는 기본 기능을 소개하겠습니다. 다음 튜토리얼에서는 더 복잡한 기능 및 그래프를 더 잘 시각화하는 방법을 살펴볼 예정이지만, 일단은 기초부터 단계별로 시작하는 것이 좋습니다.</p>
<p>이 글에서는 다음을 논의할 것입니다:</p>
<div class="content-ad"></div>
<ul>
<li>NetworkX를 사용하여 그래프를 다루는 방법</li>
<li>다양한 유형의 그래프 생성 방법</li>
<li>그래프를 그리는 방법</li>
</ul>
<p>이 자습서의 코드는 Google Colab에서 작성되었으며 테스트되었으며 컴퓨터에 별도로 설치할 필요없이 어떤 Colab 노트북에서도 실행할 수 있습니다.</p>
<h1>NetworkX 소개</h1>
<p>NetworkX에서 그래프는 일반적으로 객체(클래스)이며 이러한 객체에 적용할 수 있는 다양한 메서드와 함수가 있습니다. 또한 NetworkX는 그래프 데이터 세트를 읽고 객체를 저장하며 다양한 형식으로 저장하는 기능을 제공합니다. 라이브러리는 일부 고전적인 데이터 세트도 제공하여 사용하여 놀 수 있습니다(예: 카라테 클럽 데이터 세트).</p>
<div class="content-ad"></div>
<p>또한 NetworkX를 설치하고 사용하는 것이 실제로 쉽다는 것을 알 수 있을 것입니다 (Python의 기본 지식이 필요합니다). NetworkX는 확장성과 이식성으로 유명하며 이러한 이유로 Python에서 그래프를 처리하는 데 가장 많이 사용되는 라이브러리입니다. 이는 NetworkX와 호환되는 다른 데이터 과학자가 작성한 확장 프로그램의 생생한 생태계를 만들어냈습니다 (또는 NetworkX 그래프의 기반으로 사용됩니다).</p>
<p><img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_1.png" alt="그림"></p>
<p>어떻게 시작할까요?</p>
<p>첫 번째 단계는 라이브러리를 가져오는 것입니다 (이미 설치했다고 가정하거나 Colab을 사용 중이면 이미 설치되어 있을 것입니다).</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> nx
<span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt
</code></pre>
<p>그리고 이제는 어떻게 해야 할까요? 이전 튜토리얼에서 말했듯이 그래프는 단순히 객체(노드 또는 정점)들이 엣지를 통해 연결된 모음일 뿐입니다. 그래프는 이러한 노드들 사이의 관계를 나타내며, 이를 어떻게 표현할지 결정해야 합니다. 우리는 그래프가 직접적인 연결을 가지고 있는지, 또는 링크의 방향을 신경 쓰지 않는지를 결정해야 합니다.</p>
<p>예를 들어, 한 그룹 내에서 다른 사람들 간의 우정 관계를 표현하고 싶다고 가정해 봅시다. 이 경우 A가 B의 친구라면 B가 A의 친구라고 가정할 수 있으며 따라서 관계를 표시할 필요가 없습니다. 만약 A에서 B로 소포가 이동하는 운송 그래프를 표현하고 있다면, 방향성 있는 그래프를 사용하는 것이 좋습니다.</p>
<p>Networkx에서 방향성 있는 그래프나 무방향 그래프를 구축하는 것은 매우 쉽습니다:</p>
<div class="content-ad"></div>
<h1>무방향 그래프 G 생성</h1>
<p>G = nx.Graph()
print("그래프 G는 방향이 지정되어 있습니다: {}".format(G.is_directed()))</p>
<h1>유방향 그래프 H 생성</h1>
<p>H = nx.DiGraph()
print("그래프 H는 방향이 지정되어 있습니다: {}".format(H.is_directed()))</p>
<h1>엣지와 노드 수 얻기</h1>
<p>G.number_of_nodes(), G.number_of_edges()</p>
<p><img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_2.png" alt="이미지"></p>
<p>그래프를 구축한 후 추가 데이터를 수집하여 그래프를 업데이트해야 할 수 있습니다. NetworkX를 사용하면 노드를 추가하거나 다른 그래프를 직접 추가하기 쉽습니다.</p>
<h1>노드 추가</h1>
<p>G.add_node(1)
G.add_nodes_from([2, 3])</p>
<h1>다른 그래프에서 추가할 수도 있습니다</h1>
<p>H = nx.path_graph(3)
G.add_nodes_from(H)</p>
<h1>또는 그래프를 직접 추가할 수도 있습니다</h1>
<p>G.add_node(H)
G.number_of_nodes(), G.number_of_edges()</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_3.png" alt="Graph"></p>
<p>당연히 A가 B와 친구이고 나중에 C와도 친구가 될 수 있으므로, 또 다른 링크를 추가하려고 합니다.</p>
<pre><code class="hljs language-js">#엣지 추가하기
G.<span class="hljs-title function_">add_edge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
e = (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
G.<span class="hljs-title function_">add_edge</span>(e)
G.<span class="hljs-title function_">add_edges_from</span>([(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)])
G.<span class="hljs-title function_">add_edges_from</span>(H.<span class="hljs-title function_">edges</span>())
</code></pre>
<p>지금까지 그래프를 요소와 관계의 집합으로 삼았습니다. 노드는 모두 같았고, 관계도 단순한 연결이었습니다. 실제로 이는 축소된 것이며, 노드와 연결은 레이블 또는 기능과 연관될 수 있습니다.</p>
<div class="content-ad"></div>
<p>예를 들어, 소셜 네트워크를 만들 때 각 노드에 이름(label, 예: "Bob")을 부여하거나 클래스("스팸" 또는 "스팸 아님")를 지정할 수 있지만 특성(키, 나이, 관심사)도 부여할 수 있습니다. 앞으로 볼 것처럼 노드의 특성은 다양한 알고리즘에서 사용됩니다.</p>
<pre><code class="hljs language-js"># 무향 그래프 G를 생성합니다
G = nx.<span class="hljs-title class_">Graph</span>() # 비어 있습니다
# 첫 번째 노드에 노드 레벨 속성 추가
G.<span class="hljs-title function_">add_node</span>(<span class="hljs-number">0</span>, feature=<span class="hljs-number">3</span>, label=<span class="hljs-number">0</span>)

# 노드 <span class="hljs-number">0</span>의 속성을 가져옵니다
attr = G.<span class="hljs-property">nodes</span>[<span class="hljs-number">0</span>]
<span class="hljs-title function_">print</span>(<span class="hljs-string">"노드 0은 다음과 같은 속성을 가지고 있습니다: {}"</span>.<span class="hljs-title function_">format</span>(attr))
</code></pre>
<p><img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_4.png" alt="image"></p>
<p>이 경우 몇 개의 노드가 있는 그래프가 있지만, 종종 수천 개 또는 수백만 개의 노드가 있는 경우가 많으므로 더 효율적인 시스템이 필요할 수 있습니다. NetworkX를 사용하면 딕셔너리를 사용할 수 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 여러 노드에 속성을 포함한 노드를 추가할 수 있습니다
G.<span class="hljs-title function_">add_nodes_from</span>([
  (<span class="hljs-number">1</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">1</span>}),
  (<span class="hljs-number">2</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">2</span>})
]) 

# 노드를 순회할 수 있습니다
# 속성을 반환하려면 data=<span class="hljs-title class_">True</span> 인수를 사용합니다
<span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> G.<span class="hljs-title function_">nodes</span>(data=<span class="hljs-title class_">True</span>):
  <span class="hljs-title function_">print</span>(node)

# 노드 수를 얻을 수 있습니다
n_nodes = G.<span class="hljs-title function_">number_of_nodes</span>()
<span class="hljs-title function_">print</span>(<span class="hljs-string">"G에는 {}개의 노드가 있습니다"</span>.<span class="hljs-title function_">format</span>(n_nodes))
</code></pre>
<p><img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_5.png" alt="Graph"></p>
<p>앞서 말했듯이, 관계에는 다양한 특성이 있을 수 있습니다. 가장 흔한 경우는 서로 다른 연결에 값을 (또는 가중치) 연결하는 것입니다. 예를 들어, 교통 네트워크에서 노드는 장소를 나타내고 연결은 도로를 나타낼 수 있으며, 가중치는 거리나 이동 시간을 나타낼 수 있습니다. 이는 노드 A와 B 사이의 최단 경로를 찾고 싶은 경우에 중요한 정보입니다 (나중에 이를 계산하는 알고리즘이 있다는 것을 볼 것입니다).</p>
<pre><code class="hljs language-js"># 가중치가 <span class="hljs-number">0.5</span>인 하나의 엣지를 추가합니다
G.<span class="hljs-title function_">add_edge</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, weight=<span class="hljs-number">0.5</span>)

# 엣지 (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)의 속성을 가져옵니다
edge_0_1_attr = G.<span class="hljs-property">edges</span>[(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)]
<span class="hljs-title function_">print</span>(<span class="hljs-string">"(0, 1) 엣지는 다음과 같은 속성을 가지고 있습니다: {}"</span>.<span class="hljs-title function_">format</span>(edge_0_1_attr))
</code></pre>
<div class="content-ad"></div>
<p>당연히 노드 단위로 작업할 필요는 없어요:</p>
<pre><code class="hljs language-js"># 엣지 가중치를 가진 여러 엣지 추가
G.<span class="hljs-title function_">add_edges_from</span>([
  (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, {<span class="hljs-string">"weight"</span>: <span class="hljs-number">0.3</span>}),
  (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, {<span class="hljs-string">"weight"</span>: <span class="hljs-number">0.1</span>})
])

# 모든 엣지들에 루프 적용
# 여기서 data=<span class="hljs-title class_">True</span>가 없으므로 엣지만 반환됩니다
<span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> G.<span class="hljs-title function_">edges</span>():
  <span class="hljs-title function_">print</span>(edge)

# 엣지의 수 구하기
num_edges = G.<span class="hljs-title function_">number_of_edges</span>()
<span class="hljs-title function_">print</span>(<span class="hljs-string">"G에는 {}개의 엣지가 있습니다"</span>.<span class="hljs-title function_">format</span>(num_edges))
</code></pre>
<img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_7.png">
<div class="content-ad"></div>
<p>좋아요, 이제 멋진 그래프가 있어요! 그래프를 시각화해 보는 건 어떨까요?</p>
<pre><code class="hljs language-js"># 그래프 그리기
nx.<span class="hljs-title function_">draw</span>(G, with_labels=<span class="hljs-title class_">True</span>)
</code></pre>
<p><img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_8.png" alt="Graph"></p>
<p>노드가 몇 개의 이웃을 가지고 있는지 알아내는 것은 종종 중요한 정보입니다. 예를 들어, 우리는 그래프를 플로팅하지 않고도 노드가 연결된 다른 노드 수를 알고 싶어합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">node_id = <span class="hljs-number">1</span>

# 노드 <span class="hljs-number">1</span>의 차수
<span class="hljs-title function_">print</span>(<span class="hljs-string">"노드 {}의 차수는 {}"</span>.<span class="hljs-title function_">format</span>(node_id, G.<span class="hljs-property">degree</span>[node_id]))

# 노드 <span class="hljs-number">1</span>의 이웃 가져오기
<span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> G.<span class="hljs-title function_">neighbors</span>(node_id):
  <span class="hljs-title function_">print</span>(<span class="hljs-string">"노드 {}의 이웃은 {}"</span>.<span class="hljs-title function_">format</span>(node_id, neighbor))
</code></pre>
<img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_9.png">
<h1>서로 다른 그래프 유형</h1>
<p>이전 튜토리얼에서 우리는 그래프 유형이 다양하다는 것을 알 수 있었고 이러한 정보의 많은 부분이 인접 행렬에 요약되어 있다는 것을 알았습니다. 이제 이러한 그래프를 표현하고 시각화할 수 있는 모든 요소를 갖췄습니다.</p>
<div class="content-ad"></div>
<p>예를 들어, 가장 간단한 경우인 무방향 그래프로 시작해 보겠습니다:</p>
<pre><code class="hljs language-js">G = nx.<span class="hljs-title class_">Graph</span>()
G.<span class="hljs-title function_">add_nodes_from</span>([
  (<span class="hljs-number">1</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">1</span>}),
  (<span class="hljs-number">2</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">2</span>}),
  (<span class="hljs-number">3</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">3</span>}),
  (<span class="hljs-number">4</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">4</span>})
]) 
G.<span class="hljs-title function_">add_edges_from</span>([(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)])
# 그래프 그리기
nx.<span class="hljs-title function_">draw</span>(G, with_labels = <span class="hljs-title class_">True</span>)
A = nx.<span class="hljs-title function_">adjacency_matrix</span>(G)
<span class="hljs-title function_">print</span>(A.<span class="hljs-title function_">todense</span>())
</code></pre>
<img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_10.png">
<img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_11.png">
<div class="content-ad"></div>
<p>다이렉트 그래프는 다양한 응용 분야에서 사용됩니다. 소셜 네트워크(예: A가 B에게 돈을 빌려줌), 전기 회로, 프로젝트 일정, 운송 등등.</p>
<p>화살표는 일반적으로 관계의 방향을 나타내는 데 사용됩니다. 보시다시피 행렬도 다릅니다. 기술적으로 들어오는 간선과 나가는 간선을 나타내기 위해 두 개의 다른 행렬을 가져야합니다. 일반적으로, 우리는 나가는 간선을 나타내는 것을 사용합니다. 예를 들어, 여기서 간선을 시작하는 노드 1이 있고 이를 노드 4에 연결하는 간선이 있다면, 행렬에서 이 연결을 1로 나타냈습니다(위치는 1행 4열).</p>
<pre><code class="hljs language-python">G = nx.DiGraph()
G.add_nodes_from([
  (<span class="hljs-number">1</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">1</span>}),
  (<span class="hljs-number">2</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">2</span>}),
  (<span class="hljs-number">3</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">3</span>}),
  (<span class="hljs-number">4</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">4</span>})
]) 
G.add_edges_from([(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)])
<span class="hljs-comment"># 그래프 그리기</span>
A = nx.adjacency_matrix(G)
<span class="hljs-built_in">print</span>(A.todense())
nx.draw(G, with_labels = <span class="hljs-literal">True</span>)
</code></pre>
<img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_12.png">
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_13.png" alt="그래프"></p>
<p>앞서 언급했듯이 가중 그래프를 사용하는 경우가 있습니다. 예를 들어, 2D 매트릭스 게임, 그래프에 제약 조건을 적용해야 하는 경우 (제품 설계, 회로 설계). 또한 가중 그래프는 우선 순위 흐름을 지정하는 의존성 그래프와 같이 가중할 수도 있습니다.</p>
<pre><code class="hljs language-js">G = nx.<span class="hljs-title class_">Graph</span>()
G.<span class="hljs-title function_">add_nodes_from</span>([
  (<span class="hljs-number">1</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">1</span>}),
  (<span class="hljs-number">2</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">2</span>}),
  (<span class="hljs-number">3</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">3</span>}),
  (<span class="hljs-number">4</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">4</span>})
]) 
G.<span class="hljs-title function_">add_edges_from</span>([(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, {<span class="hljs-string">"weight"</span>: <span class="hljs-number">0.5</span>}),
                  (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, {<span class="hljs-string">"weight"</span>: <span class="hljs-number">4</span>}), 
                  (<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, {<span class="hljs-string">"weight"</span>: <span class="hljs-number">0.5</span>}), 
                  (<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,  {<span class="hljs-string">"weight"</span>: <span class="hljs-number">1</span>})])
# 그래프 그리기
# 노드
pos = nx.<span class="hljs-title function_">spring_layout</span>(G, seed=<span class="hljs-number">7</span>) 
A = nx.<span class="hljs-title function_">adjacency_matrix</span>(G)
<span class="hljs-title function_">print</span>(A.<span class="hljs-title function_">todense</span>())
nx.<span class="hljs-title function_">draw_networkx_nodes</span>(G, pos, node_size=<span class="hljs-number">50</span>)
width = []
<span class="hljs-keyword">for</span> node1, node2, data <span class="hljs-keyword">in</span> G.<span class="hljs-title function_">edges</span>(data=<span class="hljs-title class_">True</span>):
    width.<span class="hljs-title function_">append</span>(data[<span class="hljs-string">'weight'</span>])
nx.<span class="hljs-title function_">draw_networkx_edges</span>(G, pos,  width =width)
</code></pre>
<p><img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_14.png" alt="그래프"></p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_15.png" alt="image"></p>
<p>지금까지 우리는 자체 루프(노드가 자기 자신과 연결될 때)가 없다고 결론 지었습니다. 그러나 화학, 유전학, 게임, 대기 이론 등에서 유용한 경우도 있습니다. 이전에 대각선에 1이 없었는데 이제 있습니다(노드가 실제로 자기 자신과 연결되어 있음을 볼 수 있습니다).</p>
<pre><code class="hljs language-js">G = nx.<span class="hljs-title class_">Graph</span>()
G.<span class="hljs-title function_">add_nodes_from</span>([
  (<span class="hljs-number">1</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">1</span>}),
  (<span class="hljs-number">2</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">2</span>}),
  (<span class="hljs-number">3</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">3</span>}),
  (<span class="hljs-number">4</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">4</span>})
]) 
G.<span class="hljs-title function_">add_edges_from</span>([(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)])
# 그래프를 그립니다.
A = nx.<span class="hljs-title function_">adjacency_matrix</span>(G)
<span class="hljs-title function_">print</span>(A.<span class="hljs-title function_">todense</span>())
nx.<span class="hljs-title function_">draw</span>(G, with_labels=<span class="hljs-title class_">True</span>)
</code></pre>
<p><img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_16.png" alt="image"></p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_17.png">
<p>지금까지 각 노드 쌍 간에 하나의 연결만 있을 수 있다고 생각했지만, 이론적으로는 두 노드 사이에 더 많은 링크를 나타내야 할 수도 있습니다. 이 경우, Multigraph가 필요합니다.</p>
<pre><code class="hljs language-js">G = nx.<span class="hljs-title class_">MultiGraph</span>()
G.<span class="hljs-title function_">add_nodes_from</span>([
  (<span class="hljs-number">1</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">1</span>}),
  (<span class="hljs-number">2</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">2</span>}),
  (<span class="hljs-number">3</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">2</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">3</span>}),
  (<span class="hljs-number">4</span>, {<span class="hljs-string">"feature"</span>: <span class="hljs-number">1</span>, <span class="hljs-string">"label"</span>: <span class="hljs-number">4</span>})
]) 
G.<span class="hljs-title function_">add_edges_from</span>([(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">4</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">4</span>,<span class="hljs-number">3</span>), (<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)])
A = nx.<span class="hljs-title function_">adjacency_matrix</span>(G)
<span class="hljs-title function_">print</span>(A.<span class="hljs-title function_">todense</span>())
# <span class="hljs-title class_">Draw</span> the graph
pos = nx.<span class="hljs-title function_">random_layout</span>(G)
nx.<span class="hljs-title function_">draw_networkx_nodes</span>(G, pos, node_color = <span class="hljs-string">'r'</span>, node_size = <span class="hljs-number">100</span>, alpha = <span class="hljs-number">1</span>)
ax = plt.<span class="hljs-title function_">gca</span>()
<span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> G.<span class="hljs-property">edges</span>:
    ax.<span class="hljs-title function_">annotate</span>(<span class="hljs-string">""</span>,
                xy=pos[e[<span class="hljs-number">0</span>]], xycoords=<span class="hljs-string">'data'</span>,
                xytext=pos[e[<span class="hljs-number">1</span>]], textcoords=<span class="hljs-string">'data'</span>,
                arrowprops=<span class="hljs-title function_">dict</span>(arrowstyle=<span class="hljs-string">"->"</span>, color=<span class="hljs-string">"0.5"</span>,
                                shrinkA=<span class="hljs-number">5</span>, shrinkB=<span class="hljs-number">5</span>,
                                patchA=<span class="hljs-title class_">None</span>, patchB=<span class="hljs-title class_">None</span>,
                                connectionstyle=<span class="hljs-string">"arc3,rad=rrr"</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'rrr'</span>,<span class="hljs-title function_">str</span>(<span class="hljs-number">0.3</span>*e[<span class="hljs-number">2</span>])
                                ),
                                ),
                )
plt.<span class="hljs-title function_">axis</span>(<span class="hljs-string">'off'</span>)
</code></pre>
<img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_18.png">
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_19.png" alt="이미지"></p>
<p>양 부분 그래프(또는 이분 그래프)는 그래프 이론에 따르면 그래프의 꼭짓점을 두 가지 서로 다른 및 독립적인 집합으로 나눌 수 있는 그래프이며 각 간선이 꼭짓점을 서로 연결합니다. 양 부분 그래프는 암 검출, 전자 상거래 및 매칭 문제 등에서 사용됩니다.</p>
<pre><code class="hljs language-js">B = nx.<span class="hljs-title class_">Graph</span>()
# 노드 속성 <span class="hljs-string">"bipartite"</span>를 가진 노드 추가
B.<span class="hljs-title function_">add_nodes_from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], bipartite=<span class="hljs-number">0</span>)
B.<span class="hljs-title function_">add_nodes_from</span>([<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>], bipartite=<span class="hljs-number">1</span>)
# 서로 다른 노드 집합 간에만 엣지 추가
B.<span class="hljs-title function_">add_edges_from</span>([(<span class="hljs-number">1</span>, <span class="hljs-string">"a"</span>), (<span class="hljs-number">1</span>, <span class="hljs-string">"b"</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">"b"</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">"c"</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">"c"</span>), (<span class="hljs-number">4</span>, <span class="hljs-string">"a"</span>)])
# 그룹별로 분리
l, r = nx.<span class="hljs-property">bipartite</span>.<span class="hljs-title function_">sets</span>(B)
pos = {}

# 각 그룹에서 노드를 위한 위치 업데이트
pos.<span class="hljs-title function_">update</span>((node, (<span class="hljs-number">1</span>, index)) <span class="hljs-keyword">for</span> index, node <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(l))
pos.<span class="hljs-title function_">update</span>((node, (<span class="hljs-number">2</span>, index)) <span class="hljs-keyword">for</span> index, node <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(r))

nx.<span class="hljs-title function_">draw</span>(B, pos=pos)
plt.<span class="hljs-title function_">show</span>()
</code></pre>
<p><img src="/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_20.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>이전 글은 여기에서 찾을 수 있어요. 이 튜토리얼에서 사용된 모든 코드는 여기에서 찾을 수 있어요. 모든 튜토리얼 링크와 코드도 여기에 모아져 있을 거예요.</p>
<h1>결론</h1>
<p>이 튜토리얼에서는 NetworkX를 사용하여 그래프를 생성하고 노드와 엣지를 추가하고 피처를 할당하는 방법을 알아봤어요.
다양한 종류의 그래프가 있고 NetworkX를 통해 파이썬에서 이를 정의하고 시각화할 수 있다는 것을 보았어요.
다음 튜토리얼에서는 더 복잡한 경우와 추가적인 기능을 살펴볼 거예요. 또한, 노드를 분류하고, 노드 간 새로운 연결을 예측하거나, 노드를 커뮤니티로 그룹화하는 방법, 그래프 신경망 등을 적용하는 방법에 대해 논의할 거예요. 계속해서 주시길 바래요!</p>
<h1>이 내용이 흥미로웠다면:</h1>
<div class="content-ad"></div>
<p>다른 기사를 찾아보거나 LinkedIn에서 저와 연락할 수도 있어요. 매주 업데이트되는 기계 학습 및 인공 지능 뉴스가 포함된 이 저장소를 확인해보세요. 협업과 프로젝트에 열려 있고 LinkedIn을 통해 저에게 연락할 수 있습니다. 새 이야기를 게시할 때 알림을 받고 싶다면 무료로 구독할 수도 있어요.</p>
<p>여기 GitHub 저장소 링크입니다. 기계 학습, 인공 지능 및 기타 관련 자원을 수집하고 있어요.</p>
<p>또는 제 최근 기사 중 하나에 관심이 있을지도 모릅니다:</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"그래프 ML NetworkX 소개","description":"","date":"2024-06-20 04:49","slug":"2024-06-20-GraphMLintroductiontoNetworkX","content":"\n\n## | GRAPH| GRAPH ML| NETWORKX| PYTHON|\n\n![NetworkX](/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_0.png)\n\nNetworkX는 Python에서 그래프를 분석, 시각화 및 표현하는 주요 라이브러리입니다. NetworkX에는 많은 함수 모음이 포함되어 있으며, 본 튜토리얼에서는 Python에서 그래프를 시작하고 조작하는 기본 기능을 소개하겠습니다. 다음 튜토리얼에서는 더 복잡한 기능 및 그래프를 더 잘 시각화하는 방법을 살펴볼 예정이지만, 일단은 기초부터 단계별로 시작하는 것이 좋습니다.\n\n이 글에서는 다음을 논의할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- NetworkX를 사용하여 그래프를 다루는 방법\n- 다양한 유형의 그래프 생성 방법\n- 그래프를 그리는 방법\n\n이 자습서의 코드는 Google Colab에서 작성되었으며 테스트되었으며 컴퓨터에 별도로 설치할 필요없이 어떤 Colab 노트북에서도 실행할 수 있습니다.\n\n# NetworkX 소개\n\nNetworkX에서 그래프는 일반적으로 객체(클래스)이며 이러한 객체에 적용할 수 있는 다양한 메서드와 함수가 있습니다. 또한 NetworkX는 그래프 데이터 세트를 읽고 객체를 저장하며 다양한 형식으로 저장하는 기능을 제공합니다. 라이브러리는 일부 고전적인 데이터 세트도 제공하여 사용하여 놀 수 있습니다(예: 카라테 클럽 데이터 세트).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 NetworkX를 설치하고 사용하는 것이 실제로 쉽다는 것을 알 수 있을 것입니다 (Python의 기본 지식이 필요합니다). NetworkX는 확장성과 이식성으로 유명하며 이러한 이유로 Python에서 그래프를 처리하는 데 가장 많이 사용되는 라이브러리입니다. 이는 NetworkX와 호환되는 다른 데이터 과학자가 작성한 확장 프로그램의 생생한 생태계를 만들어냈습니다 (또는 NetworkX 그래프의 기반으로 사용됩니다).\n\n![그림](/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_1.png)\n\n어떻게 시작할까요?\n\n첫 번째 단계는 라이브러리를 가져오는 것입니다 (이미 설치했다고 가정하거나 Colab을 사용 중이면 이미 설치되어 있을 것입니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport networkx as nx\nimport matplotlib.pyplot as plt\n```\n\n그리고 이제는 어떻게 해야 할까요? 이전 튜토리얼에서 말했듯이 그래프는 단순히 객체(노드 또는 정점)들이 엣지를 통해 연결된 모음일 뿐입니다. 그래프는 이러한 노드들 사이의 관계를 나타내며, 이를 어떻게 표현할지 결정해야 합니다. 우리는 그래프가 직접적인 연결을 가지고 있는지, 또는 링크의 방향을 신경 쓰지 않는지를 결정해야 합니다.\n\n예를 들어, 한 그룹 내에서 다른 사람들 간의 우정 관계를 표현하고 싶다고 가정해 봅시다. 이 경우 A가 B의 친구라면 B가 A의 친구라고 가정할 수 있으며 따라서 관계를 표시할 필요가 없습니다. 만약 A에서 B로 소포가 이동하는 운송 그래프를 표현하고 있다면, 방향성 있는 그래프를 사용하는 것이 좋습니다.\n\nNetworkx에서 방향성 있는 그래프나 무방향 그래프를 구축하는 것은 매우 쉽습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 무방향 그래프 G 생성\nG = nx.Graph()\nprint(\"그래프 G는 방향이 지정되어 있습니다: {}\".format(G.is_directed()))\n\n# 유방향 그래프 H 생성\nH = nx.DiGraph()\nprint(\"그래프 H는 방향이 지정되어 있습니다: {}\".format(H.is_directed()))\n\n# 엣지와 노드 수 얻기\nG.number_of_nodes(), G.number_of_edges()\n\n\n![이미지](/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_2.png)\n\n그래프를 구축한 후 추가 데이터를 수집하여 그래프를 업데이트해야 할 수 있습니다. NetworkX를 사용하면 노드를 추가하거나 다른 그래프를 직접 추가하기 쉽습니다.\n\n\n# 노드 추가\nG.add_node(1)\nG.add_nodes_from([2, 3])\n# 다른 그래프에서 추가할 수도 있습니다\nH = nx.path_graph(3)\nG.add_nodes_from(H)\n# 또는 그래프를 직접 추가할 수도 있습니다\nG.add_node(H)\nG.number_of_nodes(), G.number_of_edges()\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Graph](/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_3.png)\n\n당연히 A가 B와 친구이고 나중에 C와도 친구가 될 수 있으므로, 또 다른 링크를 추가하려고 합니다.\n\n```js\n#엣지 추가하기\nG.add_edge(1, 2)\ne = (2, 3)\nG.add_edge(e)\nG.add_edges_from([(1, 2), (1, 3)])\nG.add_edges_from(H.edges())\n```\n\n지금까지 그래프를 요소와 관계의 집합으로 삼았습니다. 노드는 모두 같았고, 관계도 단순한 연결이었습니다. 실제로 이는 축소된 것이며, 노드와 연결은 레이블 또는 기능과 연관될 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 소셜 네트워크를 만들 때 각 노드에 이름(label, 예: \"Bob\")을 부여하거나 클래스(\"스팸\" 또는 \"스팸 아님\")를 지정할 수 있지만 특성(키, 나이, 관심사)도 부여할 수 있습니다. 앞으로 볼 것처럼 노드의 특성은 다양한 알고리즘에서 사용됩니다.\n\n```js\n# 무향 그래프 G를 생성합니다\nG = nx.Graph() # 비어 있습니다\n# 첫 번째 노드에 노드 레벨 속성 추가\nG.add_node(0, feature=3, label=0)\n\n# 노드 0의 속성을 가져옵니다\nattr = G.nodes[0]\nprint(\"노드 0은 다음과 같은 속성을 가지고 있습니다: {}\".format(attr))\n```\n\n![image](/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_4.png)\n\n이 경우 몇 개의 노드가 있는 그래프가 있지만, 종종 수천 개 또는 수백만 개의 노드가 있는 경우가 많으므로 더 효율적인 시스템이 필요할 수 있습니다. NetworkX를 사용하면 딕셔너리를 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 여러 노드에 속성을 포함한 노드를 추가할 수 있습니다\nG.add_nodes_from([\n  (1, {\"feature\": 1, \"label\": 1}),\n  (2, {\"feature\": 2, \"label\": 2})\n]) \n\n# 노드를 순회할 수 있습니다\n# 속성을 반환하려면 data=True 인수를 사용합니다\nfor node in G.nodes(data=True):\n  print(node)\n\n# 노드 수를 얻을 수 있습니다\nn_nodes = G.number_of_nodes()\nprint(\"G에는 {}개의 노드가 있습니다\".format(n_nodes))\n```\n\n![Graph](/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_5.png)\n\n앞서 말했듯이, 관계에는 다양한 특성이 있을 수 있습니다. 가장 흔한 경우는 서로 다른 연결에 값을 (또는 가중치) 연결하는 것입니다. 예를 들어, 교통 네트워크에서 노드는 장소를 나타내고 연결은 도로를 나타낼 수 있으며, 가중치는 거리나 이동 시간을 나타낼 수 있습니다. 이는 노드 A와 B 사이의 최단 경로를 찾고 싶은 경우에 중요한 정보입니다 (나중에 이를 계산하는 알고리즘이 있다는 것을 볼 것입니다).\n\n```js\n# 가중치가 0.5인 하나의 엣지를 추가합니다\nG.add_edge(0, 1, weight=0.5)\n\n# 엣지 (0, 1)의 속성을 가져옵니다\nedge_0_1_attr = G.edges[(0, 1)]\nprint(\"(0, 1) 엣지는 다음과 같은 속성을 가지고 있습니다: {}\".format(edge_0_1_attr))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당연히 노드 단위로 작업할 필요는 없어요:\n\n```js\n# 엣지 가중치를 가진 여러 엣지 추가\nG.add_edges_from([\n  (1, 2, {\"weight\": 0.3}),\n  (2, 0, {\"weight\": 0.1})\n])\n\n# 모든 엣지들에 루프 적용\n# 여기서 data=True가 없으므로 엣지만 반환됩니다\nfor edge in G.edges():\n  print(edge)\n\n# 엣지의 수 구하기\nnum_edges = G.number_of_edges()\nprint(\"G에는 {}개의 엣지가 있습니다\".format(num_edges))\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_7.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요, 이제 멋진 그래프가 있어요! 그래프를 시각화해 보는 건 어떨까요?\n\n```js\n# 그래프 그리기\nnx.draw(G, with_labels=True)\n```\n\n![Graph](/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_8.png)\n\n노드가 몇 개의 이웃을 가지고 있는지 알아내는 것은 종종 중요한 정보입니다. 예를 들어, 우리는 그래프를 플로팅하지 않고도 노드가 연결된 다른 노드 수를 알고 싶어합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnode_id = 1\n\n# 노드 1의 차수\nprint(\"노드 {}의 차수는 {}\".format(node_id, G.degree[node_id]))\n\n# 노드 1의 이웃 가져오기\nfor neighbor in G.neighbors(node_id):\n  print(\"노드 {}의 이웃은 {}\".format(node_id, neighbor))\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_9.png\" /\u003e\n\n# 서로 다른 그래프 유형\n\n이전 튜토리얼에서 우리는 그래프 유형이 다양하다는 것을 알 수 있었고 이러한 정보의 많은 부분이 인접 행렬에 요약되어 있다는 것을 알았습니다. 이제 이러한 그래프를 표현하고 시각화할 수 있는 모든 요소를 갖췄습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 가장 간단한 경우인 무방향 그래프로 시작해 보겠습니다:\n\n```js\nG = nx.Graph()\nG.add_nodes_from([\n  (1, {\"feature\": 1, \"label\": 1}),\n  (2, {\"feature\": 2, \"label\": 2}),\n  (3, {\"feature\": 2, \"label\": 3}),\n  (4, {\"feature\": 1, \"label\": 4})\n]) \nG.add_edges_from([(2, 1), (1, 4), (4, 2), (4,3)])\n# 그래프 그리기\nnx.draw(G, with_labels = True)\nA = nx.adjacency_matrix(G)\nprint(A.todense())\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_10.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_11.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다이렉트 그래프는 다양한 응용 분야에서 사용됩니다. 소셜 네트워크(예: A가 B에게 돈을 빌려줌), 전기 회로, 프로젝트 일정, 운송 등등.\n\n화살표는 일반적으로 관계의 방향을 나타내는 데 사용됩니다. 보시다시피 행렬도 다릅니다. 기술적으로 들어오는 간선과 나가는 간선을 나타내기 위해 두 개의 다른 행렬을 가져야합니다. 일반적으로, 우리는 나가는 간선을 나타내는 것을 사용합니다. 예를 들어, 여기서 간선을 시작하는 노드 1이 있고 이를 노드 4에 연결하는 간선이 있다면, 행렬에서 이 연결을 1로 나타냈습니다(위치는 1행 4열).\n\n```python\nG = nx.DiGraph()\nG.add_nodes_from([\n  (1, {\"feature\": 1, \"label\": 1}),\n  (2, {\"feature\": 2, \"label\": 2}),\n  (3, {\"feature\": 2, \"label\": 3}),\n  (4, {\"feature\": 1, \"label\": 4})\n]) \nG.add_edges_from([(2, 1), (1, 4), (4, 2), (4,3)])\n# 그래프 그리기\nA = nx.adjacency_matrix(G)\nprint(A.todense())\nnx.draw(G, with_labels = True)\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_12.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![그래프](/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_13.png)\n\n앞서 언급했듯이 가중 그래프를 사용하는 경우가 있습니다. 예를 들어, 2D 매트릭스 게임, 그래프에 제약 조건을 적용해야 하는 경우 (제품 설계, 회로 설계). 또한 가중 그래프는 우선 순위 흐름을 지정하는 의존성 그래프와 같이 가중할 수도 있습니다.\n\n```js\nG = nx.Graph()\nG.add_nodes_from([\n  (1, {\"feature\": 1, \"label\": 1}),\n  (2, {\"feature\": 2, \"label\": 2}),\n  (3, {\"feature\": 2, \"label\": 3}),\n  (4, {\"feature\": 1, \"label\": 4})\n]) \nG.add_edges_from([(2, 1, {\"weight\": 0.5}),\n                  (1, 4, {\"weight\": 4}), \n                  (4, 2, {\"weight\": 0.5}), \n                  (4,3,  {\"weight\": 1})])\n# 그래프 그리기\n# 노드\npos = nx.spring_layout(G, seed=7) \nA = nx.adjacency_matrix(G)\nprint(A.todense())\nnx.draw_networkx_nodes(G, pos, node_size=50)\nwidth = []\nfor node1, node2, data in G.edges(data=True):\n    width.append(data['weight'])\nnx.draw_networkx_edges(G, pos,  width =width)\n```\n\n![그래프](/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_14.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_15.png)\n\n지금까지 우리는 자체 루프(노드가 자기 자신과 연결될 때)가 없다고 결론 지었습니다. 그러나 화학, 유전학, 게임, 대기 이론 등에서 유용한 경우도 있습니다. 이전에 대각선에 1이 없었는데 이제 있습니다(노드가 실제로 자기 자신과 연결되어 있음을 볼 수 있습니다).\n\n```js\nG = nx.Graph()\nG.add_nodes_from([\n  (1, {\"feature\": 1, \"label\": 1}),\n  (2, {\"feature\": 2, \"label\": 2}),\n  (3, {\"feature\": 2, \"label\": 3}),\n  (4, {\"feature\": 1, \"label\": 4})\n]) \nG.add_edges_from([(2, 1), (1, 4), (4, 2), (4, 3), (4, 4), (2, 2)])\n# 그래프를 그립니다.\nA = nx.adjacency_matrix(G)\nprint(A.todense())\nnx.draw(G, with_labels=True)\n```\n\n![image](/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_16.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_17.png\" /\u003e\n\n지금까지 각 노드 쌍 간에 하나의 연결만 있을 수 있다고 생각했지만, 이론적으로는 두 노드 사이에 더 많은 링크를 나타내야 할 수도 있습니다. 이 경우, Multigraph가 필요합니다.\n\n```js\nG = nx.MultiGraph()\nG.add_nodes_from([\n  (1, {\"feature\": 1, \"label\": 1}),\n  (2, {\"feature\": 2, \"label\": 2}),\n  (3, {\"feature\": 2, \"label\": 3}),\n  (4, {\"feature\": 1, \"label\": 4})\n]) \nG.add_edges_from([(2, 1), (2, 1), (1, 4), (4, 2), (4,3), (4,3), (4,3)])\nA = nx.adjacency_matrix(G)\nprint(A.todense())\n# Draw the graph\npos = nx.random_layout(G)\nnx.draw_networkx_nodes(G, pos, node_color = 'r', node_size = 100, alpha = 1)\nax = plt.gca()\nfor e in G.edges:\n    ax.annotate(\"\",\n                xy=pos[e[0]], xycoords='data',\n                xytext=pos[e[1]], textcoords='data',\n                arrowprops=dict(arrowstyle=\"-\u003e\", color=\"0.5\",\n                                shrinkA=5, shrinkB=5,\n                                patchA=None, patchB=None,\n                                connectionstyle=\"arc3,rad=rrr\".replace('rrr',str(0.3*e[2])\n                                ),\n                                ),\n                )\nplt.axis('off')\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_18.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_19.png)\n\n양 부분 그래프(또는 이분 그래프)는 그래프 이론에 따르면 그래프의 꼭짓점을 두 가지 서로 다른 및 독립적인 집합으로 나눌 수 있는 그래프이며 각 간선이 꼭짓점을 서로 연결합니다. 양 부분 그래프는 암 검출, 전자 상거래 및 매칭 문제 등에서 사용됩니다.\n\n```js\nB = nx.Graph()\n# 노드 속성 \"bipartite\"를 가진 노드 추가\nB.add_nodes_from([1, 2, 3, 4], bipartite=0)\nB.add_nodes_from([\"a\", \"b\", \"c\"], bipartite=1)\n# 서로 다른 노드 집합 간에만 엣지 추가\nB.add_edges_from([(1, \"a\"), (1, \"b\"), (2, \"b\"), (2, \"c\"), (3, \"c\"), (4, \"a\")])\n# 그룹별로 분리\nl, r = nx.bipartite.sets(B)\npos = {}\n\n# 각 그룹에서 노드를 위한 위치 업데이트\npos.update((node, (1, index)) for index, node in enumerate(l))\npos.update((node, (2, index)) for index, node in enumerate(r))\n\nnx.draw(B, pos=pos)\nplt.show()\n```\n\n![이미지](/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_20.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 글은 여기에서 찾을 수 있어요. 이 튜토리얼에서 사용된 모든 코드는 여기에서 찾을 수 있어요. 모든 튜토리얼 링크와 코드도 여기에 모아져 있을 거예요.\n\n# 결론\n\n이 튜토리얼에서는 NetworkX를 사용하여 그래프를 생성하고 노드와 엣지를 추가하고 피처를 할당하는 방법을 알아봤어요.\n다양한 종류의 그래프가 있고 NetworkX를 통해 파이썬에서 이를 정의하고 시각화할 수 있다는 것을 보았어요.\n다음 튜토리얼에서는 더 복잡한 경우와 추가적인 기능을 살펴볼 거예요. 또한, 노드를 분류하고, 노드 간 새로운 연결을 예측하거나, 노드를 커뮤니티로 그룹화하는 방법, 그래프 신경망 등을 적용하는 방법에 대해 논의할 거예요. 계속해서 주시길 바래요!\n\n# 이 내용이 흥미로웠다면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 기사를 찾아보거나 LinkedIn에서 저와 연락할 수도 있어요. 매주 업데이트되는 기계 학습 및 인공 지능 뉴스가 포함된 이 저장소를 확인해보세요. 협업과 프로젝트에 열려 있고 LinkedIn을 통해 저에게 연락할 수 있습니다. 새 이야기를 게시할 때 알림을 받고 싶다면 무료로 구독할 수도 있어요.\n\n여기 GitHub 저장소 링크입니다. 기계 학습, 인공 지능 및 기타 관련 자원을 수집하고 있어요.\n\n또는 제 최근 기사 중 하나에 관심이 있을지도 모릅니다:","ogImage":{"url":"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_0.png"},"coverImage":"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e| GRAPH| GRAPH ML| NETWORKX| PYTHON|\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_0.png\" alt=\"NetworkX\"\u003e\u003c/p\u003e\n\u003cp\u003eNetworkX는 Python에서 그래프를 분석, 시각화 및 표현하는 주요 라이브러리입니다. NetworkX에는 많은 함수 모음이 포함되어 있으며, 본 튜토리얼에서는 Python에서 그래프를 시작하고 조작하는 기본 기능을 소개하겠습니다. 다음 튜토리얼에서는 더 복잡한 기능 및 그래프를 더 잘 시각화하는 방법을 살펴볼 예정이지만, 일단은 기초부터 단계별로 시작하는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003e이 글에서는 다음을 논의할 것입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eNetworkX를 사용하여 그래프를 다루는 방법\u003c/li\u003e\n\u003cli\u003e다양한 유형의 그래프 생성 방법\u003c/li\u003e\n\u003cli\u003e그래프를 그리는 방법\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 자습서의 코드는 Google Colab에서 작성되었으며 테스트되었으며 컴퓨터에 별도로 설치할 필요없이 어떤 Colab 노트북에서도 실행할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eNetworkX 소개\u003c/h1\u003e\n\u003cp\u003eNetworkX에서 그래프는 일반적으로 객체(클래스)이며 이러한 객체에 적용할 수 있는 다양한 메서드와 함수가 있습니다. 또한 NetworkX는 그래프 데이터 세트를 읽고 객체를 저장하며 다양한 형식으로 저장하는 기능을 제공합니다. 라이브러리는 일부 고전적인 데이터 세트도 제공하여 사용하여 놀 수 있습니다(예: 카라테 클럽 데이터 세트).\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e또한 NetworkX를 설치하고 사용하는 것이 실제로 쉽다는 것을 알 수 있을 것입니다 (Python의 기본 지식이 필요합니다). NetworkX는 확장성과 이식성으로 유명하며 이러한 이유로 Python에서 그래프를 처리하는 데 가장 많이 사용되는 라이브러리입니다. 이는 NetworkX와 호환되는 다른 데이터 과학자가 작성한 확장 프로그램의 생생한 생태계를 만들어냈습니다 (또는 NetworkX 그래프의 기반으로 사용됩니다).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_1.png\" alt=\"그림\"\u003e\u003c/p\u003e\n\u003cp\u003e어떻게 시작할까요?\u003c/p\u003e\n\u003cp\u003e첫 번째 단계는 라이브러리를 가져오는 것입니다 (이미 설치했다고 가정하거나 Colab을 사용 중이면 이미 설치되어 있을 것입니다).\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e networkx \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e nx\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 이제는 어떻게 해야 할까요? 이전 튜토리얼에서 말했듯이 그래프는 단순히 객체(노드 또는 정점)들이 엣지를 통해 연결된 모음일 뿐입니다. 그래프는 이러한 노드들 사이의 관계를 나타내며, 이를 어떻게 표현할지 결정해야 합니다. 우리는 그래프가 직접적인 연결을 가지고 있는지, 또는 링크의 방향을 신경 쓰지 않는지를 결정해야 합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 한 그룹 내에서 다른 사람들 간의 우정 관계를 표현하고 싶다고 가정해 봅시다. 이 경우 A가 B의 친구라면 B가 A의 친구라고 가정할 수 있으며 따라서 관계를 표시할 필요가 없습니다. 만약 A에서 B로 소포가 이동하는 운송 그래프를 표현하고 있다면, 방향성 있는 그래프를 사용하는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003eNetworkx에서 방향성 있는 그래프나 무방향 그래프를 구축하는 것은 매우 쉽습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e무방향 그래프 G 생성\u003c/h1\u003e\n\u003cp\u003eG = nx.Graph()\nprint(\"그래프 G는 방향이 지정되어 있습니다: {}\".format(G.is_directed()))\u003c/p\u003e\n\u003ch1\u003e유방향 그래프 H 생성\u003c/h1\u003e\n\u003cp\u003eH = nx.DiGraph()\nprint(\"그래프 H는 방향이 지정되어 있습니다: {}\".format(H.is_directed()))\u003c/p\u003e\n\u003ch1\u003e엣지와 노드 수 얻기\u003c/h1\u003e\n\u003cp\u003eG.number_of_nodes(), G.number_of_edges()\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e그래프를 구축한 후 추가 데이터를 수집하여 그래프를 업데이트해야 할 수 있습니다. NetworkX를 사용하면 노드를 추가하거나 다른 그래프를 직접 추가하기 쉽습니다.\u003c/p\u003e\n\u003ch1\u003e노드 추가\u003c/h1\u003e\n\u003cp\u003eG.add_node(1)\nG.add_nodes_from([2, 3])\u003c/p\u003e\n\u003ch1\u003e다른 그래프에서 추가할 수도 있습니다\u003c/h1\u003e\n\u003cp\u003eH = nx.path_graph(3)\nG.add_nodes_from(H)\u003c/p\u003e\n\u003ch1\u003e또는 그래프를 직접 추가할 수도 있습니다\u003c/h1\u003e\n\u003cp\u003eG.add_node(H)\nG.number_of_nodes(), G.number_of_edges()\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_3.png\" alt=\"Graph\"\u003e\u003c/p\u003e\n\u003cp\u003e당연히 A가 B와 친구이고 나중에 C와도 친구가 될 수 있으므로, 또 다른 링크를 추가하려고 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#엣지 추가하기\nG.\u003cspan class=\"hljs-title function_\"\u003eadd_edge\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\ne = (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\nG.\u003cspan class=\"hljs-title function_\"\u003eadd_edge\u003c/span\u003e(e)\nG.\u003cspan class=\"hljs-title function_\"\u003eadd_edges_from\u003c/span\u003e([(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)])\nG.\u003cspan class=\"hljs-title function_\"\u003eadd_edges_from\u003c/span\u003e(H.\u003cspan class=\"hljs-title function_\"\u003eedges\u003c/span\u003e())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e지금까지 그래프를 요소와 관계의 집합으로 삼았습니다. 노드는 모두 같았고, 관계도 단순한 연결이었습니다. 실제로 이는 축소된 것이며, 노드와 연결은 레이블 또는 기능과 연관될 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예를 들어, 소셜 네트워크를 만들 때 각 노드에 이름(label, 예: \"Bob\")을 부여하거나 클래스(\"스팸\" 또는 \"스팸 아님\")를 지정할 수 있지만 특성(키, 나이, 관심사)도 부여할 수 있습니다. 앞으로 볼 것처럼 노드의 특성은 다양한 알고리즘에서 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 무향 그래프 G를 생성합니다\nG = nx.\u003cspan class=\"hljs-title class_\"\u003eGraph\u003c/span\u003e() # 비어 있습니다\n# 첫 번째 노드에 노드 레벨 속성 추가\nG.\u003cspan class=\"hljs-title function_\"\u003eadd_node\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, feature=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, label=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\n# 노드 \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e의 속성을 가져옵니다\nattr = G.\u003cspan class=\"hljs-property\"\u003enodes\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"노드 0은 다음과 같은 속성을 가지고 있습니다: {}\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(attr))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_4.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이 경우 몇 개의 노드가 있는 그래프가 있지만, 종종 수천 개 또는 수백만 개의 노드가 있는 경우가 많으므로 더 효율적인 시스템이 필요할 수 있습니다. NetworkX를 사용하면 딕셔너리를 사용할 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 여러 노드에 속성을 포함한 노드를 추가할 수 있습니다\nG.\u003cspan class=\"hljs-title function_\"\u003eadd_nodes_from\u003c/span\u003e([\n  (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e})\n]) \n\n# 노드를 순회할 수 있습니다\n# 속성을 반환하려면 data=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e 인수를 사용합니다\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e node \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e G.\u003cspan class=\"hljs-title function_\"\u003enodes\u003c/span\u003e(data=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e):\n  \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(node)\n\n# 노드 수를 얻을 수 있습니다\nn_nodes = G.\u003cspan class=\"hljs-title function_\"\u003enumber_of_nodes\u003c/span\u003e()\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"G에는 {}개의 노드가 있습니다\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(n_nodes))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_5.png\" alt=\"Graph\"\u003e\u003c/p\u003e\n\u003cp\u003e앞서 말했듯이, 관계에는 다양한 특성이 있을 수 있습니다. 가장 흔한 경우는 서로 다른 연결에 값을 (또는 가중치) 연결하는 것입니다. 예를 들어, 교통 네트워크에서 노드는 장소를 나타내고 연결은 도로를 나타낼 수 있으며, 가중치는 거리나 이동 시간을 나타낼 수 있습니다. 이는 노드 A와 B 사이의 최단 경로를 찾고 싶은 경우에 중요한 정보입니다 (나중에 이를 계산하는 알고리즘이 있다는 것을 볼 것입니다).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 가중치가 \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e인 하나의 엣지를 추가합니다\nG.\u003cspan class=\"hljs-title function_\"\u003eadd_edge\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, weight=\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e)\n\n# 엣지 (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)의 속성을 가져옵니다\nedge_0_1_attr = G.\u003cspan class=\"hljs-property\"\u003eedges\u003c/span\u003e[(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)]\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"(0, 1) 엣지는 다음과 같은 속성을 가지고 있습니다: {}\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(edge_0_1_attr))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e당연히 노드 단위로 작업할 필요는 없어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 엣지 가중치를 가진 여러 엣지 추가\nG.\u003cspan class=\"hljs-title function_\"\u003eadd_edges_from\u003c/span\u003e([\n  (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"weight\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.3\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"weight\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.1\u003c/span\u003e})\n])\n\n# 모든 엣지들에 루프 적용\n# 여기서 data=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e가 없으므로 엣지만 반환됩니다\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e edge \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e G.\u003cspan class=\"hljs-title function_\"\u003eedges\u003c/span\u003e():\n  \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(edge)\n\n# 엣지의 수 구하기\nnum_edges = G.\u003cspan class=\"hljs-title function_\"\u003enumber_of_edges\u003c/span\u003e()\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"G에는 {}개의 엣지가 있습니다\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(num_edges))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_7.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e좋아요, 이제 멋진 그래프가 있어요! 그래프를 시각화해 보는 건 어떨까요?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 그래프 그리기\nnx.\u003cspan class=\"hljs-title function_\"\u003edraw\u003c/span\u003e(G, with_labels=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_8.png\" alt=\"Graph\"\u003e\u003c/p\u003e\n\u003cp\u003e노드가 몇 개의 이웃을 가지고 있는지 알아내는 것은 종종 중요한 정보입니다. 예를 들어, 우리는 그래프를 플로팅하지 않고도 노드가 연결된 다른 노드 수를 알고 싶어합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enode_id = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\n# 노드 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e의 차수\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"노드 {}의 차수는 {}\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(node_id, G.\u003cspan class=\"hljs-property\"\u003edegree\u003c/span\u003e[node_id]))\n\n# 노드 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e의 이웃 가져오기\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e neighbor \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e G.\u003cspan class=\"hljs-title function_\"\u003eneighbors\u003c/span\u003e(node_id):\n  \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"노드 {}의 이웃은 {}\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(node_id, neighbor))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_9.png\"\u003e\n\u003ch1\u003e서로 다른 그래프 유형\u003c/h1\u003e\n\u003cp\u003e이전 튜토리얼에서 우리는 그래프 유형이 다양하다는 것을 알 수 있었고 이러한 정보의 많은 부분이 인접 행렬에 요약되어 있다는 것을 알았습니다. 이제 이러한 그래프를 표현하고 시각화할 수 있는 모든 요소를 갖췄습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예를 들어, 가장 간단한 경우인 무방향 그래프로 시작해 보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eG = nx.\u003cspan class=\"hljs-title class_\"\u003eGraph\u003c/span\u003e()\nG.\u003cspan class=\"hljs-title function_\"\u003eadd_nodes_from\u003c/span\u003e([\n  (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e})\n]) \nG.\u003cspan class=\"hljs-title function_\"\u003eadd_edges_from\u003c/span\u003e([(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)])\n# 그래프 그리기\nnx.\u003cspan class=\"hljs-title function_\"\u003edraw\u003c/span\u003e(G, with_labels = \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\nA = nx.\u003cspan class=\"hljs-title function_\"\u003eadjacency_matrix\u003c/span\u003e(G)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(A.\u003cspan class=\"hljs-title function_\"\u003etodense\u003c/span\u003e())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_10.png\"\u003e\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_11.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다이렉트 그래프는 다양한 응용 분야에서 사용됩니다. 소셜 네트워크(예: A가 B에게 돈을 빌려줌), 전기 회로, 프로젝트 일정, 운송 등등.\u003c/p\u003e\n\u003cp\u003e화살표는 일반적으로 관계의 방향을 나타내는 데 사용됩니다. 보시다시피 행렬도 다릅니다. 기술적으로 들어오는 간선과 나가는 간선을 나타내기 위해 두 개의 다른 행렬을 가져야합니다. 일반적으로, 우리는 나가는 간선을 나타내는 것을 사용합니다. 예를 들어, 여기서 간선을 시작하는 노드 1이 있고 이를 노드 4에 연결하는 간선이 있다면, 행렬에서 이 연결을 1로 나타냈습니다(위치는 1행 4열).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eG = nx.DiGraph()\nG.add_nodes_from([\n  (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e})\n]) \nG.add_edges_from([(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)])\n\u003cspan class=\"hljs-comment\"\u003e# 그래프 그리기\u003c/span\u003e\nA = nx.adjacency_matrix(G)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(A.todense())\nnx.draw(G, with_labels = \u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_12.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_13.png\" alt=\"그래프\"\u003e\u003c/p\u003e\n\u003cp\u003e앞서 언급했듯이 가중 그래프를 사용하는 경우가 있습니다. 예를 들어, 2D 매트릭스 게임, 그래프에 제약 조건을 적용해야 하는 경우 (제품 설계, 회로 설계). 또한 가중 그래프는 우선 순위 흐름을 지정하는 의존성 그래프와 같이 가중할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eG = nx.\u003cspan class=\"hljs-title class_\"\u003eGraph\u003c/span\u003e()\nG.\u003cspan class=\"hljs-title function_\"\u003eadd_nodes_from\u003c/span\u003e([\n  (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e})\n]) \nG.\u003cspan class=\"hljs-title function_\"\u003eadd_edges_from\u003c/span\u003e([(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"weight\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e}),\n                  (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"weight\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e}), \n                  (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"weight\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e}), \n                  (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,  {\u003cspan class=\"hljs-string\"\u003e\"weight\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e})])\n# 그래프 그리기\n# 노드\npos = nx.\u003cspan class=\"hljs-title function_\"\u003espring_layout\u003c/span\u003e(G, seed=\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e) \nA = nx.\u003cspan class=\"hljs-title function_\"\u003eadjacency_matrix\u003c/span\u003e(G)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(A.\u003cspan class=\"hljs-title function_\"\u003etodense\u003c/span\u003e())\nnx.\u003cspan class=\"hljs-title function_\"\u003edraw_networkx_nodes\u003c/span\u003e(G, pos, node_size=\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e)\nwidth = []\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e node1, node2, data \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e G.\u003cspan class=\"hljs-title function_\"\u003eedges\u003c/span\u003e(data=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e):\n    width.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(data[\u003cspan class=\"hljs-string\"\u003e'weight'\u003c/span\u003e])\nnx.\u003cspan class=\"hljs-title function_\"\u003edraw_networkx_edges\u003c/span\u003e(G, pos,  width =width)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_14.png\" alt=\"그래프\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_15.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e지금까지 우리는 자체 루프(노드가 자기 자신과 연결될 때)가 없다고 결론 지었습니다. 그러나 화학, 유전학, 게임, 대기 이론 등에서 유용한 경우도 있습니다. 이전에 대각선에 1이 없었는데 이제 있습니다(노드가 실제로 자기 자신과 연결되어 있음을 볼 수 있습니다).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eG = nx.\u003cspan class=\"hljs-title class_\"\u003eGraph\u003c/span\u003e()\nG.\u003cspan class=\"hljs-title function_\"\u003eadd_nodes_from\u003c/span\u003e([\n  (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e})\n]) \nG.\u003cspan class=\"hljs-title function_\"\u003eadd_edges_from\u003c/span\u003e([(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)])\n# 그래프를 그립니다.\nA = nx.\u003cspan class=\"hljs-title function_\"\u003eadjacency_matrix\u003c/span\u003e(G)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(A.\u003cspan class=\"hljs-title function_\"\u003etodense\u003c/span\u003e())\nnx.\u003cspan class=\"hljs-title function_\"\u003edraw\u003c/span\u003e(G, with_labels=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_16.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_17.png\"\u003e\n\u003cp\u003e지금까지 각 노드 쌍 간에 하나의 연결만 있을 수 있다고 생각했지만, 이론적으로는 두 노드 사이에 더 많은 링크를 나타내야 할 수도 있습니다. 이 경우, Multigraph가 필요합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eG = nx.\u003cspan class=\"hljs-title class_\"\u003eMultiGraph\u003c/span\u003e()\nG.\u003cspan class=\"hljs-title function_\"\u003eadd_nodes_from\u003c/span\u003e([\n  (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e}),\n  (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, {\u003cspan class=\"hljs-string\"\u003e\"feature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e})\n]) \nG.\u003cspan class=\"hljs-title function_\"\u003eadd_edges_from\u003c/span\u003e([(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)])\nA = nx.\u003cspan class=\"hljs-title function_\"\u003eadjacency_matrix\u003c/span\u003e(G)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(A.\u003cspan class=\"hljs-title function_\"\u003etodense\u003c/span\u003e())\n# \u003cspan class=\"hljs-title class_\"\u003eDraw\u003c/span\u003e the graph\npos = nx.\u003cspan class=\"hljs-title function_\"\u003erandom_layout\u003c/span\u003e(G)\nnx.\u003cspan class=\"hljs-title function_\"\u003edraw_networkx_nodes\u003c/span\u003e(G, pos, node_color = \u003cspan class=\"hljs-string\"\u003e'r'\u003c/span\u003e, node_size = \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, alpha = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\nax = plt.\u003cspan class=\"hljs-title function_\"\u003egca\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e G.\u003cspan class=\"hljs-property\"\u003eedges\u003c/span\u003e:\n    ax.\u003cspan class=\"hljs-title function_\"\u003eannotate\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n                xy=pos[e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]], xycoords=\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e,\n                xytext=pos[e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]], textcoords=\u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e,\n                arrowprops=\u003cspan class=\"hljs-title function_\"\u003edict\u003c/span\u003e(arrowstyle=\u003cspan class=\"hljs-string\"\u003e\"-\u003e\"\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e\"0.5\"\u003c/span\u003e,\n                                shrinkA=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, shrinkB=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\n                                patchA=\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e, patchB=\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e,\n                                connectionstyle=\u003cspan class=\"hljs-string\"\u003e\"arc3,rad=rrr\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'rrr'\u003c/span\u003e,\u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.3\u003c/span\u003e*e[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])\n                                ),\n                                ),\n                )\nplt.\u003cspan class=\"hljs-title function_\"\u003eaxis\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'off'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_18.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_19.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e양 부분 그래프(또는 이분 그래프)는 그래프 이론에 따르면 그래프의 꼭짓점을 두 가지 서로 다른 및 독립적인 집합으로 나눌 수 있는 그래프이며 각 간선이 꼭짓점을 서로 연결합니다. 양 부분 그래프는 암 검출, 전자 상거래 및 매칭 문제 등에서 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eB = nx.\u003cspan class=\"hljs-title class_\"\u003eGraph\u003c/span\u003e()\n# 노드 속성 \u003cspan class=\"hljs-string\"\u003e\"bipartite\"\u003c/span\u003e를 가진 노드 추가\nB.\u003cspan class=\"hljs-title function_\"\u003eadd_nodes_from\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e], bipartite=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\nB.\u003cspan class=\"hljs-title function_\"\u003eadd_nodes_from\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"b\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"c\"\u003c/span\u003e], bipartite=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n# 서로 다른 노드 집합 간에만 엣지 추가\nB.\u003cspan class=\"hljs-title function_\"\u003eadd_edges_from\u003c/span\u003e([(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"b\"\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"b\"\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"c\"\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"c\"\u003c/span\u003e), (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e)])\n# 그룹별로 분리\nl, r = nx.\u003cspan class=\"hljs-property\"\u003ebipartite\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esets\u003c/span\u003e(B)\npos = {}\n\n# 각 그룹에서 노드를 위한 위치 업데이트\npos.\u003cspan class=\"hljs-title function_\"\u003eupdate\u003c/span\u003e((node, (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, index)) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e index, node \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(l))\npos.\u003cspan class=\"hljs-title function_\"\u003eupdate\u003c/span\u003e((node, (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, index)) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e index, node \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(r))\n\nnx.\u003cspan class=\"hljs-title function_\"\u003edraw\u003c/span\u003e(B, pos=pos)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-GraphMLintroductiontoNetworkX_20.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이전 글은 여기에서 찾을 수 있어요. 이 튜토리얼에서 사용된 모든 코드는 여기에서 찾을 수 있어요. 모든 튜토리얼 링크와 코드도 여기에 모아져 있을 거예요.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 튜토리얼에서는 NetworkX를 사용하여 그래프를 생성하고 노드와 엣지를 추가하고 피처를 할당하는 방법을 알아봤어요.\n다양한 종류의 그래프가 있고 NetworkX를 통해 파이썬에서 이를 정의하고 시각화할 수 있다는 것을 보았어요.\n다음 튜토리얼에서는 더 복잡한 경우와 추가적인 기능을 살펴볼 거예요. 또한, 노드를 분류하고, 노드 간 새로운 연결을 예측하거나, 노드를 커뮤니티로 그룹화하는 방법, 그래프 신경망 등을 적용하는 방법에 대해 논의할 거예요. 계속해서 주시길 바래요!\u003c/p\u003e\n\u003ch1\u003e이 내용이 흥미로웠다면:\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다른 기사를 찾아보거나 LinkedIn에서 저와 연락할 수도 있어요. 매주 업데이트되는 기계 학습 및 인공 지능 뉴스가 포함된 이 저장소를 확인해보세요. 협업과 프로젝트에 열려 있고 LinkedIn을 통해 저에게 연락할 수 있습니다. 새 이야기를 게시할 때 알림을 받고 싶다면 무료로 구독할 수도 있어요.\u003c/p\u003e\n\u003cp\u003e여기 GitHub 저장소 링크입니다. 기계 학습, 인공 지능 및 기타 관련 자원을 수집하고 있어요.\u003c/p\u003e\n\u003cp\u003e또는 제 최근 기사 중 하나에 관심이 있을지도 모릅니다:\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-GraphMLintroductiontoNetworkX"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>