<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>React 19 다가오는 변화에 대비하세요 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-React19GetReadyForWhatsComing" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="React 19 다가오는 변화에 대비하세요 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="React 19 다가오는 변화에 대비하세요 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-React19GetReadyForWhatsComing" data-gatsby-head="true"/><meta name="twitter:title" content="React 19 다가오는 변화에 대비하세요 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 21:09" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_buildManifest.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">React 19 다가오는 변화에 대비하세요</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="React 19 다가오는 변화에 대비하세요" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-React19GetReadyForWhatsComing&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png" alt="React 19"/></p>
<p>리액트 19, 어떤 경우에도 공개될 수 있고, 모든 리액트 개발자들이 사용하고 싶어할 것입니다. 왜냐하면 최신 버전이 훨씬 더 나아졌기 때문이죠. 다가올 변화 중 일부를 살펴보겠습니다.</p>
<h2>리액트 컴파일러: 리액트 핵심 최적화</h2>
<p>오랫동안, 리액트 개발자들은 useMemo, useCallback, memo 훅을 활용하여 애플리케이션을 최적화하고 불필요한 다시 렌더링을 방지했습니다. 이로 인해 종종 어색한 코드가 만들어지곤 했는데, 이를 더 우아한 해결책을 찾게끔 할 것이라는 리액트 개발팀이 약속했습니다.</p>
<p>그래서 정확히 그것이 React 19에서 제공되는 것입니다: 새로운 React 컴파일러. 이 컴파일러는 코드를 분석하여 상태 변경이 발생할 때 UI의 어떤 부분을 다시 렌더링해야 하는지 결정함으로써 React의 렌더링 프로세스를 자동으로 최적화하는 데 설계되었습니다.</p>
<p>React 컴파일러가 간단한 컴포넌트를 어떻게 최적화하는지 예시를 살펴봅시다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>React 컴파일러 없이 count 상태를 업데이트하면 <code>button</code> 요소를 포함한 전체 컴포넌트가 다시 렌더링됩니다. 그러나 해당 내용과 동작이 변경되지 않는 한 개선 없이 렌더링됩니다. 반면에 React 컴파일러를 사용하면 count를 보여주는 <code>p</code> 요소만 다시 렌더링되어 성능이 향상되고 오버헤드가 감소합니다.</p>
<h2>작업: 데이터 처리 간소화</h2>
<p>리액트 컴파일러에 추가로, 리액트 19에서는 Actions라는 강력한 새로운 기능이 소개되었습니다.</p>
<p>Actions를 사용하면 <code>form</code>과 같은 DOM 요소에 함수를 전달하여 폼 제출, 데이터 변이 및 기타 데이터 관련 작업을 손쉽게 처리할 수 있습니다. 아래는 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">SearchForm</span>(<span class="hljs-params">{ action }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">{action}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;query&quot;</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>검색<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">search</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">data</span>) =&gt; {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/search?q=<span class="hljs-subst">${data.query}</span>`</span>);
    <span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
    <span class="hljs-comment">// 검색 결과로 UI 업데이트</span>
  };

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SearchForm</span> <span class="hljs-attr">action</span>=<span class="hljs-string">{search}</span> /&gt;</span></span>;
}
</code></pre>
<p>이 예시에서 SearchForm 컴포넌트는 액션 prop을 받습니다. 이 prop은 폼이 제출될 때 실행될 함수입니다. App 컴포넌트는 검색 함수를 정의합니다. 이 함수는 서버로 fetch 요청을 보내고 응답을 처리합니다.</p>
<p>액션은 클라이언트 측에서 표준 JavaScript를 사용하여 또는 <code>use server</code> 지시문을 사용하여 서버에서 정의할 수 있습니다. React는 데이터 제출의 라이프사이클을 관리하며, useFormStatus 및 useActionState와 같은 훅을 제공하여 폼 액션의 현재 상태와 응답에 액세스할 수 있습니다.</p>
<p>기본적으로, 액션은 전환 내에서 제출되어 현재 페이지를 상호작용적으로 유지합니다. React 19에서는 전환 내에서 async/await를 사용하여 비동기 요청이 진행 중일 때 대기 중 UI를 보여줄 수 있는 기능도 소개되었습니다.</p>
<p>액션을 보완하는 것은 useOptimistic 훅입니다. 이 훅을 사용하면 개발자가 낙관적인 상태 업데이트를 관리할 수 있습니다. 이 훅을 사용하면 임시 업데이트가 적용되고 최종 상태가 확정되면 자동으로 되돌립니다. 이 기능을 사용하면 낙관적 UI 업데이트를 할 수 있으며, 제출이 성공하면 서버에서 제공된 데이터로 자연스럽게 되돌아갈 수 있습니다.</p>
<h2>React 서버 구성 요소: 서버 측 렌더링을 더욱 진보시키다.</h2>
<p>React 19에서 가장 기대되는 기능 중 하나는 React Server Components (RSC)의 도입입니다.</p>
<p>RSC를 사용하면 개발자는 <code>use server</code> 지시어를 사용하여 특정 구성 요소를 &quot;서버&quot; 구성 요소로 표시할 수 있습니다. 이러한 구성 요소는 서버에서 렌더링되어 정적 HTML로 클라이언트로 스트리밍되어 초기 JavaScript 페이로드를 줄이고 성능을 향상시킵니다.</p>
<p>다음은 RSC를 사용하는 예시입니다:</p>
<pre><code class="hljs language-jsx"><span class="hljs-comment">// PostContent.server.jsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> fetchPost <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./fetchPost&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">PostContent</span>(<span class="hljs-params">{ id }</span>) {
  <span class="hljs-keyword">const</span> [post, setPost] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchPostData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; {
      <span class="hljs-keyword">const</span> postData = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchPost</span>(id);
      <span class="hljs-title function_">setPost</span>(postData);
    };
    <span class="hljs-title function_">fetchPostData</span>();
  }, [id]);

  <span class="hljs-keyword">if</span> (!post) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{post.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{post.content}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>이 예제에서 PostContent 컴포넌트는 .server.jsx 파일 확장자를 사용하여 서버 컴포넌트로 표시됩니다. 서버에서 렌더링될 때 fetchPost 함수가 실행되고 결과로 나온 게시물 데이터가 정적 HTML로 렌더링되어 클라이언트로 스트리밍됩니다.</p>
<p>RSC와 액션을 결합하면 클라이언트 및 서버 환경에서 일관된 프로그래밍 모델로 풀 스택 앱을 만들 수 있습니다.</p>
<h2>리액트 개발의 미래를 받아들이기</h2>
<p>React 19 컴파일러는 렌더링 프로세스를 대폭 가속화하고 불필요한 다시 렌더링을 줄일 것입니다. Meta Devs가 릴리스하는 내용을 항상 주시하시고 큰 날을 위해 준비하세요.</p>
<p>출처: React Labs: 우리가 작업 중인 내용 — 2024년 2월 — React</p>
<h1>평문으로 간단히 🚀</h1>
<p>In Plain English 커뮤니티의 일부로 함께해 주셔서 감사합니다! 떠나시기 전에:</p>
<ul>
<li>작가에게 박수를 보내고 팔로우를 눌러주세요! 👏</li>
<li>팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터</li>
<li>다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed</li>
<li>알고리즘 컨텐츠를 다루도록 강요하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요!</li>
<li>더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요.</li>
</ul></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React 19 다가오는 변화에 대비하세요","description":"","date":"2024-05-12 21:09","slug":"2024-05-12-React19GetReadyForWhatsComing","content":"\n\n![React 19](/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png)\n\n리액트 19, 어떤 경우에도 공개될 수 있고, 모든 리액트 개발자들이 사용하고 싶어할 것입니다. 왜냐하면 최신 버전이 훨씬 더 나아졌기 때문이죠. 다가올 변화 중 일부를 살펴보겠습니다.\n\n## 리액트 컴파일러: 리액트 핵심 최적화\n\n오랫동안, 리액트 개발자들은 useMemo, useCallback, memo 훅을 활용하여 애플리케이션을 최적화하고 불필요한 다시 렌더링을 방지했습니다. 이로 인해 종종 어색한 코드가 만들어지곤 했는데, 이를 더 우아한 해결책을 찾게끔 할 것이라는 리액트 개발팀이 약속했습니다.\n\n\n\n그래서 정확히 그것이 React 19에서 제공되는 것입니다: 새로운 React 컴파일러. 이 컴파일러는 코드를 분석하여 상태 변경이 발생할 때 UI의 어떤 부분을 다시 렌더링해야 하는지 결정함으로써 React의 렌더링 프로세스를 자동으로 최적화하는 데 설계되었습니다.\n\nReact 컴파일러가 간단한 컴포넌트를 어떻게 최적화하는지 예시를 살펴봅시다:\n\n```js\nimport React, { useState } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () =\u003e {\n    setCount(count + 1);\n  };\n\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eCount: {count}\u003c/p\u003e\n      \u003cbutton onClick={handleClick}\u003eIncrement\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\nReact 컴파일러 없이 count 상태를 업데이트하면 `button` 요소를 포함한 전체 컴포넌트가 다시 렌더링됩니다. 그러나 해당 내용과 동작이 변경되지 않는 한 개선 없이 렌더링됩니다. 반면에 React 컴파일러를 사용하면 count를 보여주는 `p` 요소만 다시 렌더링되어 성능이 향상되고 오버헤드가 감소합니다.\n\n\n\n## 작업: 데이터 처리 간소화\n\n리액트 컴파일러에 추가로, 리액트 19에서는 Actions라는 강력한 새로운 기능이 소개되었습니다.\n\nActions를 사용하면 `form`과 같은 DOM 요소에 함수를 전달하여 폼 제출, 데이터 변이 및 기타 데이터 관련 작업을 손쉽게 처리할 수 있습니다. 아래는 예시입니다:\n\n```js\nimport React from 'react';\n\nfunction SearchForm({ action }) {\n  return (\n    \u003cform action={action}\u003e\n      \u003cinput name=\"query\" /\u003e\n      \u003cbutton type=\"submit\"\u003e검색\u003c/button\u003e\n    \u003c/form\u003e\n  );\n}\n\nfunction App() {\n  const search = async (data) =\u003e {\n    const response = await fetch(`/api/search?q=${data.query}`);\n    const results = await response.json();\n    // 검색 결과로 UI 업데이트\n  };\n\n  return \u003cSearchForm action={search} /\u003e;\n}\n```\n\n\n\n이 예시에서 SearchForm 컴포넌트는 액션 prop을 받습니다. 이 prop은 폼이 제출될 때 실행될 함수입니다. App 컴포넌트는 검색 함수를 정의합니다. 이 함수는 서버로 fetch 요청을 보내고 응답을 처리합니다.\n\n액션은 클라이언트 측에서 표준 JavaScript를 사용하여 또는 `use server` 지시문을 사용하여 서버에서 정의할 수 있습니다. React는 데이터 제출의 라이프사이클을 관리하며, useFormStatus 및 useActionState와 같은 훅을 제공하여 폼 액션의 현재 상태와 응답에 액세스할 수 있습니다.\n\n기본적으로, 액션은 전환 내에서 제출되어 현재 페이지를 상호작용적으로 유지합니다. React 19에서는 전환 내에서 async/await를 사용하여 비동기 요청이 진행 중일 때 대기 중 UI를 보여줄 수 있는 기능도 소개되었습니다.\n\n액션을 보완하는 것은 useOptimistic 훅입니다. 이 훅을 사용하면 개발자가 낙관적인 상태 업데이트를 관리할 수 있습니다. 이 훅을 사용하면 임시 업데이트가 적용되고 최종 상태가 확정되면 자동으로 되돌립니다. 이 기능을 사용하면 낙관적 UI 업데이트를 할 수 있으며, 제출이 성공하면 서버에서 제공된 데이터로 자연스럽게 되돌아갈 수 있습니다.\n\n\n\n## React 서버 구성 요소: 서버 측 렌더링을 더욱 진보시키다.\n\nReact 19에서 가장 기대되는 기능 중 하나는 React Server Components (RSC)의 도입입니다.\n\nRSC를 사용하면 개발자는 `use server` 지시어를 사용하여 특정 구성 요소를 \"서버\" 구성 요소로 표시할 수 있습니다. 이러한 구성 요소는 서버에서 렌더링되어 정적 HTML로 클라이언트로 스트리밍되어 초기 JavaScript 페이로드를 줄이고 성능을 향상시킵니다.\n\n다음은 RSC를 사용하는 예시입니다:\n\n\n\n```jsx\n// PostContent.server.jsx\nimport React, { useState, useEffect } from 'react';\nimport fetchPost from './fetchPost';\n\nexport default async function PostContent({ id }) {\n  const [post, setPost] = useState(null);\n\n  useEffect(() =\u003e {\n    const fetchPostData = async () =\u003e {\n      const postData = await fetchPost(id);\n      setPost(postData);\n    };\n    fetchPostData();\n  }, [id]);\n\n  if (!post) {\n    return \u003cdiv\u003eLoading...\u003c/div\u003e;\n  }\n\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e{post.title}\u003c/h1\u003e\n      \u003cp\u003e{post.content}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n이 예제에서 PostContent 컴포넌트는 .server.jsx 파일 확장자를 사용하여 서버 컴포넌트로 표시됩니다. 서버에서 렌더링될 때 fetchPost 함수가 실행되고 결과로 나온 게시물 데이터가 정적 HTML로 렌더링되어 클라이언트로 스트리밍됩니다.\n\nRSC와 액션을 결합하면 클라이언트 및 서버 환경에서 일관된 프로그래밍 모델로 풀 스택 앱을 만들 수 있습니다.\n\n## 리액트 개발의 미래를 받아들이기\n\n\n\nReact 19 컴파일러는 렌더링 프로세스를 대폭 가속화하고 불필요한 다시 렌더링을 줄일 것입니다. Meta Devs가 릴리스하는 내용을 항상 주시하시고 큰 날을 위해 준비하세요.\n\n출처: React Labs: 우리가 작업 중인 내용 — 2024년 2월 — React\n\n# 평문으로 간단히 🚀\n\nIn Plain English 커뮤니티의 일부로 함께해 주셔서 감사합니다! 떠나시기 전에:\n\n\n\n- 작가에게 박수를 보내고 팔로우를 눌러주세요! 👏\r\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\r\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\r\n- 알고리즘 컨텐츠를 다루도록 강요하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요!\r\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요.","ogImage":{"url":"/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png"},"coverImage":"/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    h1: \"h1\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-React19GetReadyForWhatsComing_0.png\",\n        alt: \"React 19\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리액트 19, 어떤 경우에도 공개될 수 있고, 모든 리액트 개발자들이 사용하고 싶어할 것입니다. 왜냐하면 최신 버전이 훨씬 더 나아졌기 때문이죠. 다가올 변화 중 일부를 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"리액트 컴파일러: 리액트 핵심 최적화\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오랫동안, 리액트 개발자들은 useMemo, useCallback, memo 훅을 활용하여 애플리케이션을 최적화하고 불필요한 다시 렌더링을 방지했습니다. 이로 인해 종종 어색한 코드가 만들어지곤 했는데, 이를 더 우아한 해결책을 찾게끔 할 것이라는 리액트 개발팀이 약속했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서 정확히 그것이 React 19에서 제공되는 것입니다: 새로운 React 컴파일러. 이 컴파일러는 코드를 분석하여 상태 변경이 발생할 때 UI의 어떤 부분을 다시 렌더링해야 하는지 결정함으로써 React의 렌더링 프로세스를 자동으로 최적화하는 데 설계되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React 컴파일러가 간단한 컴포넌트를 어떻게 최적화하는지 예시를 살펴봅시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \", { useState } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react'\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MyComponent\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [count, setCount] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"handleClick\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") =\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setCount\"\n        }), \"(count + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \");\\n  };\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"Count: {count}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onClick\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{handleClick}\"\n            }), \"\u003e\"]\n          }), \"Increment\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"React 컴파일러 없이 count 상태를 업데이트하면 \", _jsx(_components.code, {\n        children: \"button\"\n      }), \" 요소를 포함한 전체 컴포넌트가 다시 렌더링됩니다. 그러나 해당 내용과 동작이 변경되지 않는 한 개선 없이 렌더링됩니다. 반면에 React 컴파일러를 사용하면 count를 보여주는 \", _jsx(_components.code, {\n        children: \"p\"\n      }), \" 요소만 다시 렌더링되어 성능이 향상되고 오버헤드가 감소합니다.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"작업: 데이터 처리 간소화\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리액트 컴파일러에 추가로, 리액트 19에서는 Actions라는 강력한 새로운 기능이 소개되었습니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Actions를 사용하면 \", _jsx(_components.code, {\n        children: \"form\"\n      }), \"과 같은 DOM 요소에 함수를 전달하여 폼 제출, 데이터 변이 및 기타 데이터 관련 작업을 손쉽게 처리할 수 있습니다. 아래는 예시입니다:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react'\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"SearchForm\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{ action }\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"form\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"action\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{action}\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"input\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"name\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"query\\\"\"\n            }), \" /\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"type\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"submit\\\"\"\n            }), \"\u003e\"]\n          }), \"검색\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"form\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n  );\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"App\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"search\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"data\"\n        }), \") =\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" response = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`/api/search?q=\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${data.query}\"\n          }), \"`\"]\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" results = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" response.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"json\"\n        }), \"();\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 검색 결과로 UI 업데이트\"\n        }), \"\\n  };\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"SearchForm\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"action\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{search}\"\n            }), \" /\u003e\"]\n          })\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예시에서 SearchForm 컴포넌트는 액션 prop을 받습니다. 이 prop은 폼이 제출될 때 실행될 함수입니다. App 컴포넌트는 검색 함수를 정의합니다. 이 함수는 서버로 fetch 요청을 보내고 응답을 처리합니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"액션은 클라이언트 측에서 표준 JavaScript를 사용하여 또는 \", _jsx(_components.code, {\n        children: \"use server\"\n      }), \" 지시문을 사용하여 서버에서 정의할 수 있습니다. React는 데이터 제출의 라이프사이클을 관리하며, useFormStatus 및 useActionState와 같은 훅을 제공하여 폼 액션의 현재 상태와 응답에 액세스할 수 있습니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본적으로, 액션은 전환 내에서 제출되어 현재 페이지를 상호작용적으로 유지합니다. React 19에서는 전환 내에서 async/await를 사용하여 비동기 요청이 진행 중일 때 대기 중 UI를 보여줄 수 있는 기능도 소개되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"액션을 보완하는 것은 useOptimistic 훅입니다. 이 훅을 사용하면 개발자가 낙관적인 상태 업데이트를 관리할 수 있습니다. 이 훅을 사용하면 임시 업데이트가 적용되고 최종 상태가 확정되면 자동으로 되돌립니다. 이 기능을 사용하면 낙관적 UI 업데이트를 할 수 있으며, 제출이 성공하면 서버에서 제공된 데이터로 자연스럽게 되돌아갈 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"React 서버 구성 요소: 서버 측 렌더링을 더욱 진보시키다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React 19에서 가장 기대되는 기능 중 하나는 React Server Components (RSC)의 도입입니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"RSC를 사용하면 개발자는 \", _jsx(_components.code, {\n        children: \"use server\"\n      }), \" 지시어를 사용하여 특정 구성 요소를 \\\"서버\\\" 구성 요소로 표시할 수 있습니다. 이러한 구성 요소는 서버에서 렌더링되어 정적 HTML로 클라이언트로 스트리밍되어 초기 JavaScript 페이로드를 줄이고 성능을 향상시킵니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 RSC를 사용하는 예시입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-jsx\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// PostContent.server.jsx\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \", { useState, useEffect } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" fetchPost \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./fetchPost'\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"PostContent\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{ id }\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [post, setPost] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useEffect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetchPostData\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") =\u003e {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" postData = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetchPost\"\n        }), \"(id);\\n      \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setPost\"\n        }), \"(postData);\\n    };\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetchPostData\"\n        }), \"();\\n  }, [id]);\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!post) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"Loading...\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \";\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \"\u003e\"]\n          }), \"{post.title}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"h1\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"{post.content}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예제에서 PostContent 컴포넌트는 .server.jsx 파일 확장자를 사용하여 서버 컴포넌트로 표시됩니다. 서버에서 렌더링될 때 fetchPost 함수가 실행되고 결과로 나온 게시물 데이터가 정적 HTML로 렌더링되어 클라이언트로 스트리밍됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RSC와 액션을 결합하면 클라이언트 및 서버 환경에서 일관된 프로그래밍 모델로 풀 스택 앱을 만들 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"리액트 개발의 미래를 받아들이기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React 19 컴파일러는 렌더링 프로세스를 대폭 가속화하고 불필요한 다시 렌더링을 줄일 것입니다. Meta Devs가 릴리스하는 내용을 항상 주시하시고 큰 날을 위해 준비하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"출처: React Labs: 우리가 작업 중인 내용 — 2024년 2월 — React\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"평문으로 간단히 🚀\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In Plain English 커뮤니티의 일부로 함께해 주셔서 감사합니다! 떠나시기 전에:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"작가에게 박수를 보내고 팔로우를 눌러주세요! 👏\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"알고리즘 컨텐츠를 다루도록 강요하는 블로그 플랫폼에 지쳤나요? Differ를 시도해보세요!\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요.\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-React19GetReadyForWhatsComing"},"buildId":"837W-BjvPVBgft6aM4api","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>