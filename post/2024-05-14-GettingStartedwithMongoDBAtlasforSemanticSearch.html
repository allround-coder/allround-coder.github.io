<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>시맨틱 검색을 위한 MongoDB Atlas 시작하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="시맨틱 검색을 위한 MongoDB Atlas 시작하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="시맨틱 검색을 위한 MongoDB Atlas 시작하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch" data-gatsby-head="true"/><meta name="twitter:title" content="시맨틱 검색을 위한 MongoDB Atlas 시작하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 15:33" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">시맨틱 검색을 위한 MongoDB Atlas 시작하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="시맨틱 검색을 위한 MongoDB Atlas 시작하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>최신 MongoDB Atlas Vector Search 기능을 소개합니다</h2>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png" alt="이미지"></p>
<p>6월 22일, MongoDB가 Atlas Vector Search를 미리 보기 모드로 출시했습니다.</p>
<p>이 새로운 기능을 사용해봤어요!</p>
<p>테이블 태그를 마크다운 형식으로 바꾸세요.</p>
<p>이 검색 방법은 텍스트, 오디오, 비디오 및 이미지와 같이 구조화되지 않은 데이터를 효과적으로 검색하기 위해 기계 학습 모델을 활용합니다. 이를 통해 검색 항목과 유사하거나 관련된 항목을 찾을 수 있습니다. 추천 시스템, 챗봇 또는 검색 엔진과 같은 여러 사용 사례에 활용됩니다.</p>
<p>텍스트 데이터를 다룰 때 벡터 검색을 통해 정확한 검색어가 검색된 문장에 없더라도 비슷한 의미의 단어나 구를 찾을 수 있습니다.</p>
<p>벡터 검색은 임베딩 개념을 기반으로 합니다.</p>
<h2>Embeddings</h2>
<p>벡터 검색은 고급 머신 러닝 모델(encoders)을 사용하여 구조화되지 않은 입력 데이터의 수치적 표현을 제공하는 벡터 임베딩을 생성합니다.</p>
<p>벡터 임베딩은 컴퓨터에게 일반적으로 이해하기 어려운 구조화되지 않은 데이터를 숫자 형식으로 변환합니다.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_1.png" alt="이미지"></p>
<p>임베딩은 주로 수치 값 배열인 고차원 벡터입니다. 이러한 벡터는 데이터의 맥락적 및 의미적 정보를 포함하고 있어 유의미한 비교와 계산을 수행할 수 있도록 합니다.</p>
<p>예를 들어, 텍스트 임베딩 모델(인코더)은 구절 내 단어들 사이의 관계를 학습하여 문장의 의미와 맥락 정보를 포착하는 임베딩을 생성할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_2.png" alt="image"></p>
<p>위 이미지에서 "bovine buddies say" 구절은 부동 소수점 숫자 배열([-0.005, 0.012, -0.008, ..., -0.010])로 인코딩되었습니다.</p>
<p>벡터의 차원은 임베딩 모델에 따라 다르며 높을 수 있습니다(수천 개까지).</p>
<p>Markdown으로 테이블 태그를 변경하세요.</p>
<h2>Atlas Vector Search</h2>
<p>Atlas Vector Search은 MongoDB Atlas의 새로운 기능으로, MongoDB의 검색 기능을 더욱 발전시킵니다.</p>
<p>MongoDB Atlas Vector Search는 다음을 제공합니다:</p>
<ul>
<li>원하는 외부 ML 모델(OpenAI, Hugging Face 등)에서 생성된 임베딩 벡터를 보존하는 벡터 저장소;</li>
<li>저장된 임베딩 벡터를 색인화하는 벡터 저장소 인덱스;</li>
<li>저장된 벡터에서 의미 검색을 수행하기 위한 근사 최근 이웃(ANN) 알고리즘을 구현하는 검색 작업.</li>
</ul>
<p>몽고디비 Atlas Search를 사용하면 사용자는 기본 키워드 매칭 이상의 정보 검색 기능을 확장할 수 있습니다. 이 혁신적인 도구는 컨텍스트 인식 시맨틱 검색을 가능하게하여 사용자의 검색어에서 의미를 유추할 수 있도록 합니다.</p>
<h1>액션에서의 Atlas Vector Search</h1>
<p>이제 몽고디비 Atlas Vector Search의 새로운 기능을 시도해 보겠습니다.</p>
<p>이 튜토리얼을 완료하기 위해 다음 단계를 실행해 보겠습니다:</p>
<ul>
<li>무료 MongoDB ATLAS 클러스터를 생성하세요.</li>
<li>속담과 쿼리를 위한 MongoDB 컬렉션을 생성하세요.</li>
<li>Hugging Face API 토큰을 생성하세요.</li>
<li>생성된 Hugging Face API 토큰을 Atlas에 임포트하세요.</li>
<li>Atlas Database Triggers 및 HF API 실행을 위한 함수를 만드세요.</li>
<li>벡터 검색 인덱스를 생성하세요.</li>
<li>속담 데이터셋을 MongoDB에 삽입하세요.</li>
<li>의미론적 쿼리를 실행하세요.</li>
</ul>
<p>이번 튜토리얼에서는 Atlas UI만 사용하여 작업할 예정입니다.</p>
<h2>1. 무료 MongoDB ATLAS 클러스터 생성</h2>
<p>첫 번째 단계는 MongoDB Atlas 무료 클러스터(M0 클러스터)를 배포하는 것입니다.</p>
<p>이 튜토리얼에서는 새로운 것을 만들기보다 기존의 Atlas 클러스터를 자유롭게 사용해도 괜찮습니다.</p>
<h2>2. 속담 및 질의를 위한 MongoDB 컬렉션 생성</h2>
<p>이 튜토리얼에서는 같은 데이터베이스에 속한 두 개의 컬렉션을 사용할 것입니다:</p>
<ul>
<li>속담과 그에 대한 내장 값을 저장하는 <code>vector_search.proverbs</code></li>
<li>질의와 답변을 저장하는 <code>vector_search.queries</code></li>
</ul>
<p>데이터베이스와 컬렉션은 Atlas UI에서 생성됩니다.</p>
<p>데이터베이스 배포에서 'Collections 찾아보기' 버튼을 클릭하십시오:</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_4.png" alt="Collections 찾아보기"></p>
<p>그런 다음 Collections 탭에서 + 데이터베이스 생성을 클릭하고 데이터베이스 이름 (vector_search), 첫 번째 컬렉션 이름 (proverbs)을 입력한 후 생성 버튼을 클릭하십시오.</p>
<p>Markdown 형식으로 테이블 태그를 바꿔 주세요:</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_5.png" alt="이미지 1"></p>
<p>두 번째 컬렉션을 만들기 위해 데이터베이스 vector_search를 선택하거나 호버한 후, 플러스(+) 아이콘을 클릭하세요.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_6.png" alt="이미지 2"></p>
<p>다음으로 vector_search 데이터베이스 내에 queries 컬렉션을 생성하세요:</p>
<img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_7.png">
<p>이제 여러분의 컬렉션이 준비되었어요.</p>
<img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_8.png">
<h2>3. Hugging Face API 토큰 생성</h2>
<p>프로버브에 대한 벡터 임베딩을 얻기 위해 무료 공개 Hugging Face 추론 API를 사용할 것입니다.</p>
<p>텍스트 임베딩 API를 호출하기 전에 Hugging Face 사이트에서 읽기 액세스 토큰을 생성해야 합니다.</p>
<p>Hugging Face 웹사이트로 이동하여 로그인하거나 회원 가입하세요.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_9.png" alt="이미지"></p>
<p>로그인한 후 오른쪽 상단으로 이동하여 프로필 아이콘을 클릭하고 설정을 선택하세요. 그런 다음 프로필 설정 페이지 왼쪽에 있는 Access Tokens를 클릭하고 New Token 버튼을 누르세요.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_10.png" alt="Access Tokens"></p>
<p>토큰에 이름을 지정하고 read 역할을 선택한 후 Generate a token을 클릭하세요.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_11.png" alt="Generate a Token"></p>
<p>위의 생성된 토큰을 안전한 위치에 복사하여 저장해주세요.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_12.png" alt="image"></p>
<h2>4. 아틀라스로 허깅 페이스 API 토큰 가져오기</h2>
<p>HF API를 호출하기 전에 먼저 아틀라스에 이전에 생성된 허깅 페이스 토큰을 가져와야 합니다.</p>
<p>Atlas UI의 App Services 페이지로 이동해주세요:</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_13.png" alt="이미지"></p>
<p>Triggers 애플리케이션(가장 왼쪽 상자)을 클릭한 후, 왼쪽 메뉴에서 Values를 선택하고, Create New Value 버튼을 클릭해주세요.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_14.png" alt="이미지"></p>
<p>가장 먼저 할 일은 비밀을 만드는 것입니다. 값을 HF_secret로 지정하고 유형을 Secret으로 선택하여 허깅페이스 토큰을 Add Content 필드에 붙여넣은 다음 저장을 클릭하세요.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_15.png" alt="이미지"></p>
<p>그런 다음, 함수에서 사용할 새 환경 변수를 생성해야 합니다. 이를 위해 오른쪽 상단 버튼의 Create New Value를 다시 클릭하세요.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_16.png" alt="이미지"></p>
<p>HF_value라는 이름의 Value 타입의 값을 생성하고 Secret HF_secret에 링크를 걸고 저장을 누르세요. 아래에서 정확히 수행한 것을 따라해주세요.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_17.png" alt="이미지"></p>
<h2>5. Atlas 데이터베이스 트리거 및 함수 생성하여 HF API 호출하기</h2>
<p>Atlas UI에서 우리는 격언 및 쿼리 컬렉션에 데이터베이스 트리거를 정의할 수 있습니다. 이를 통해 이 컬렉션에 새 문서가 삽입될 때마다 Hugging Face API를 호출할 수 있습니다.</p>
<p>데이터베이스 트리거를 생성하려면 데이터베이스 배포로 이동한 다음 왼쪽 탐색 메뉴에서 트리거를 클릭하십시오.</p>
<p>"트리거 추가" 버튼을 클릭하여 새 트리거를 구성할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_18.png" alt="이미지"></p>
<p>HF_Create_Embeddings 트리거</p>
<p>vector_search.proverbs 컬렉션에 대한 첫 번째 트리거인 HF_Create_Embeddings을 생성했습니다. 아래와 같이 트리거를 구성하세요:</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_19.png" alt="trigger configuration"></p>
<p>함수 섹션에서 Function을 이벤트 유형으로 선택하고, 다음의 자바스크립트 함수 코드를 아래 코드 블록에 붙여넣으세요.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_20.png" alt="javascript function code"></p>
<p>위 양식에 붙여넣을 코드는 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">exports</span> = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">changeEvent</span>) {
    <span class="hljs-comment">// 변경 이벤트에서 전체 문서를 가져옵니다.</span>
    <span class="hljs-keyword">const</span> doc = changeEvent.<span class="hljs-property">fullDocument</span>;

    <span class="hljs-comment">// Hugging Face API의 URL과 키를 정의합니다.</span>
    <span class="hljs-keyword">const</span> url = <span class="hljs-string">'https://api-inference.huggingface.co/pipeline/feature-extraction/sentence-transformers/all-MiniLM-L6-v2'</span>;
    <span class="hljs-comment">// App Services 내부의 "Values" 유틸리티에서 API 키의 값을 지정한 이름을 사용합니다.</span>
    <span class="hljs-keyword">const</span> hf_read_token = context.<span class="hljs-property">values</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"HF_value"</span>);

    <span class="hljs-keyword">try</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`ID가 <span class="hljs-subst">${doc._id}</span>인 문서 처리 중`</span>);

        <span class="hljs-comment">// Hugging Face API를 호출하여 임베딩을 가져옵니다.</span>
        <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> context.<span class="hljs-property">http</span>.<span class="hljs-title function_">post</span>({
            <span class="hljs-attr">url</span>: url,
            <span class="hljs-attr">headers</span>: {
                <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${hf_read_token}</span>`</span>,
                <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
            },
            <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
                <span class="hljs-comment">// 문서 내 데이터를 임베딩할 필드를 지정합니다. 여기서는 샘플 속담 데이터의 "proverb" 필드를 사용합니다.</span>
                <span class="hljs-attr">inputs</span>: [doc.<span class="hljs-property">proverb</span>]
            })
        });

        <span class="hljs-comment">// JSON 응답을 파싱합니다.</span>
        <span class="hljs-keyword">let</span> responseData = <span class="hljs-variable constant_">EJSON</span>.<span class="hljs-title function_">parse</span>(response.<span class="hljs-property">body</span>.<span class="hljs-title function_">text</span>());

        <span class="hljs-comment">// 응답 상태를 확인합니다.</span>
        <span class="hljs-keyword">if</span>(response.<span class="hljs-property">statusCode</span> === <span class="hljs-number">200</span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"임베딩을 성공적으로 받았습니다."</span>);

            <span class="hljs-keyword">const</span> embedding = responseData[<span class="hljs-number">0</span>];

            <span class="hljs-comment">// MongoDB Atlas에서 클러스터를 가져옵니다.</span>
            <span class="hljs-keyword">const</span> mongodb = context.<span class="hljs-property">services</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'Cluster0'</span>);
            <span class="hljs-keyword">const</span> db = mongodb.<span class="hljs-title function_">db</span>(<span class="hljs-string">'vector_search'</span>); <span class="hljs-comment">// 데이터베이스명으로 변경하세요.</span>
            <span class="hljs-keyword">const</span> collection = db.<span class="hljs-title function_">collection</span>(<span class="hljs-string">'proverbs'</span>); <span class="hljs-comment">// 컬렉션명으로 변경하세요.</span>

            <span class="hljs-comment">// MongoDB에서 문서를 업데이트합니다.</span>
            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> collection.<span class="hljs-title function_">updateOne</span>(
                { <span class="hljs-attr">_id</span>: doc.<span class="hljs-property">_id</span> },
                <span class="hljs-comment">// 새로운 필드에 임베딩을 저장할 이름을 지정합니다.</span>
                { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">proverb_embedding</span>: embedding }
            );

            <span class="hljs-keyword">if</span>(result.<span class="hljs-property">modifiedCount</span> === <span class="hljs-number">1</span>) {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"문서를 성공적으로 업데이트했습니다."</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"문서를 업데이트하는 데 실패했습니다."</span>);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`임베딩을 받는 데 실패했습니다. 상태 코드: <span class="hljs-subst">${response.statusCode}</span>`</span>);
        }

    } <span class="hljs-keyword">catch</span>(err) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
    }
};
</code></pre>
<p>트리거 HF_Create_Embeddings는 속담 콜렉션에 삽입된 각 속담에 대한 벡터 임베딩을 얻기 위해 Hugging Face all-MiniLM-L6-v2 모델 API를 호출합니다.</p>
<p>Semantic_Query 트리거</p>
<p>두 번째 트리거는 쿼리 컬렉션에 생성될 것입니다. 트리거 함수에서는 Hugging Face 임베딩 모델을 호출하여 사용자 쿼리의 임베딩을 가져와 MongoDB 집계 명령을 통해 벡터 검색을 실행할 것입니다.</p>
<p>벡터 검색 결과는 쿼리 컬렉션에 저장될 것입니다.</p>
<p>두 번째 트리거를 만들려면, 첫 번째 트리거와 동일한 프로세스를 따르되, 다음에 설명된 매개변수를 조정해야 합니다 (다른 모든 매개변수 값은 이전과 동일합니다):</p>
<p>이름 Semantic_Query</p>
<p>컬렉션 이름 쿼리</p>
<p>함수 코드에 다음 블록을 붙여 넣으세요:</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">exports</span> = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">changeEvent</span>) {
    <span class="hljs-comment">// 변경 이벤트에서 전체 문서 가져오기</span>
    <span class="hljs-keyword">const</span> doc = changeEvent.<span class="hljs-property">fullDocument</span>;

    <span class="hljs-comment">// Hugging Face API URL 및 키 정의</span>
    <span class="hljs-keyword">const</span> url = <span class="hljs-string">'https://api-inference.huggingface.co/pipeline/feature-extraction/sentence-transformers/all-MiniLM-L6-v2'</span>;
    <span class="hljs-comment">// App Services 내의 "Values" 유틸리티에서 API 키의 값을 설정한 이름을 사용</span>
    <span class="hljs-keyword">const</span> hf_read_token = context.<span class="hljs-property">values</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"HF_value"</span>);

    <span class="hljs-keyword">try</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`아이디가 <span class="hljs-subst">${doc._id}</span>인 문서 처리 중`</span>);

        <span class="hljs-comment">// 쿼리의 임베딩을 가져오기 위해 Hugging Face API 호출</span>
        <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> context.<span class="hljs-property">http</span>.<span class="hljs-title function_">post</span>({
            <span class="hljs-attr">url</span>: url,
            <span class="hljs-attr">headers</span>: {
                <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${hf_read_token}</span>`</span>,
                <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>
            },
            <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
                <span class="hljs-comment">// 데이터를 임베딩할 문서 내 필드. 여기선 "queries" 컬렉션의 "query" 필드입니다.</span>
                <span class="hljs-attr">inputs</span>: [doc.<span class="hljs-property">query</span>]
            })
        });

        <span class="hljs-comment">// JSON 응답 파싱</span>
        <span class="hljs-keyword">let</span> responseData = <span class="hljs-variable constant_">EJSON</span>.<span class="hljs-title function_">parse</span>(response.<span class="hljs-property">body</span>.<span class="hljs-title function_">text</span>());

        <span class="hljs-comment">// 응답 상태 확인</span>
        <span class="hljs-keyword">if</span> (response.<span class="hljs-property">statusCode</span> === <span class="hljs-number">200</span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"임베딩 성공적으로 수신"</span>);

            <span class="hljs-keyword">const</span> embedding = responseData[<span class="hljs-number">0</span>];

            <span class="hljs-comment">// MongoDB Atlas에서 클러스터 가져오기</span>
            <span class="hljs-keyword">const</span> mongodb = context.<span class="hljs-property">services</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'Cluster0'</span>);
            <span class="hljs-keyword">const</span> db = mongodb.<span class="hljs-title function_">db</span>(<span class="hljs-string">'vector_search'</span>); <span class="hljs-comment">// 데이터베이스 이름으로 대체</span>
            <span class="hljs-keyword">const</span> proverbs_collection = db.<span class="hljs-title function_">collection</span>(<span class="hljs-string">'proverbs'</span>); <span class="hljs-comment">// 컬렉션 이름으로 대체</span>
            <span class="hljs-keyword">const</span> queries_collection = db.<span class="hljs-title function_">collection</span>(<span class="hljs-string">'queries'</span>); <span class="hljs-comment">// 컬렉션 이름으로 대체</span>

            <span class="hljs-comment">// 유사 문서 쿼리</span>
            <span class="hljs-keyword">const</span> documents = <span class="hljs-keyword">await</span> proverbs_collection.<span class="hljs-title function_">aggregate</span>([
                {
                    <span class="hljs-string">"$search"</span>: {
                        <span class="hljs-string">"index"</span>: <span class="hljs-string">"vector_search_index"</span>,
                        <span class="hljs-string">"knnBeta"</span>: {
                            <span class="hljs-string">"vector"</span>: embedding,
                            <span class="hljs-string">"path"</span>: <span class="hljs-string">"proverb_embedding"</span>,
                            <span class="hljs-string">"k"</span>: <span class="hljs-number">2</span>
                        }
                    }
                },
                {
                    <span class="hljs-string">"$project"</span>: {
                        <span class="hljs-string">"_id"</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-string">"proverb"</span>: <span class="hljs-number">1</span>
                    }
                }
            ]).<span class="hljs-title function_">toArray</span>();
            
            <span class="hljs-comment">// MongoDB에서 문서 업데이트</span>
            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> queries_collection.<span class="hljs-title function_">updateOne</span>(
                { <span class="hljs-attr">_id</span>: doc.<span class="hljs-property">_id</span> },
                <span class="hljs-comment">// "answer" 필드에 쿼리 결과가 포함됩니다.</span>
                { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">query_embedding</span>: embedding, <span class="hljs-attr">answer</span>: documents }
            });

        } <span class="hljs-keyword">else</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`임베딩 수신 실패. 상태 코드: <span class="hljs-subst">${response.statusCode}</span>`</span>);
        }

    } <span class="hljs-keyword">catch</span>(err) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
    }
};
</code></pre>
<h2>6. 벡터 탐색 인덱스 생성</h2>
<p>우리는 직역 검색을 가능하게 하기 위해 속담 모음에 벡터 검색 인덱스를 생성해야 합니다. 속담 모음은 우리의 쿼리에 응답하기 위해 검색될 속담 문장의 임베딩(proverb_embedding 필드)을 포함할 것입니다.</p>
<p>인덱스를 생성하려면 다음을 수행하세요. Atlas Search로 이동: 데이터베이스 배포 페이지에서 왼쪽 메뉴에서 검색을 클릭한 후, 데이터 원본 선택 드롭다운 메뉴에서 클러스터를 선택하고 Go to Atlas Search 버튼을 누릅니다.</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_21.png" alt="이미지"></p>
<p>새로운 검색 인덱스를 구성하려면 Create Search Index 버튼을 클릭하세요:</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_22.png" alt="이미지"></p>
<p>다음 페이지에서 JSON Editor 상자를 선택하고 Next 버튼을 누르세요:</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_23.png" alt="이미지"></p>
<p>데이터베이스 및 컬렉션 영역에서 vector_search 데이터베이스와 proverbs 컬렉션을 선택하고, Index Name 필드에 vector_search_index라는 인덱스 이름을 지정하세요.</p>
<img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_24.png">
<p>다음 JSON 문서를 텍스트 영역에 붙여넣고 '다음' 버튼을 클릭해주세요.</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">"mappings"</span>: {
    <span class="hljs-string">"dynamic"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">"fields"</span>: {
      <span class="hljs-string">"proverb_embedding"</span>: {
        <span class="hljs-string">"dimensions"</span>: <span class="hljs-number">384</span>,
        <span class="hljs-string">"similarity"</span>: <span class="hljs-string">"dotProduct"</span>,
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"knnVector"</span>
      }
    }
  }
}
</code></pre>
<p>'검색 인덱스 생성'을 클릭하면 인덱스 생성이 시작됩니다.</p>
<img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_25.png">
<p>곧 새로운 인덱스가 활성 상태로 사용 가능할 것입니다.</p>
<img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_26.png">
<h2>7. 경구 데이터 세트를 MongoDB에 삽입하기</h2>
<p>우리는 임베딩 스토어를 채우기 위해 영어 속담을 속담 컬렉션에 삽입할 것입니다. Atlas UI에서 하나의 속담을 추가할 것입니다.</p>
<p>우리가 삽입하는 첫 번째 속담은 다음과 같습니다:</p>
<p>속담을 삽입하려면:</p>
<ul>
<li>데이터베이스 배포 페이지에서 Browse Collections로 이동하세요.</li>
<li>vector_search 데이터베이스 아래에 있는 proverbs 컬렉션을 선택하세요.</li>
<li>"proverb"를 필드 이름으로 하고 속담 문장을 값으로 하는 단일 필드 문서를 추가하세요.</li>
<li>그런 다음 삽입을 눌러주세요.</li>
</ul>
<p>마법처럼 새로운 필드인 'proverb_embedding'이 문서에 추가됩니다:</p>
<p>'proverb_embedding' 필드에는 HF_Create_Embeddings 트리거에서 호출된 Hugging Face 텍스트 임베딩 모델 API에 의해 생성된 임베딩 벡터(384개의 부동 소수점 요소가 있는 배열)가 포함되어 있습니다.</p>
<p>자세한 것은 나중에 업데이트됩니다.</p>
<p>늦게라도 하는 것이 낫죠.</p>
<p>호기심은 고양이를 죽인다고 해요.</p>
<p>불에 노는 바보는 불에 탄다고 하잖아요.</p>
<p>정의를 미루면 결국 물거품이 돼버립니다.</p>
<p>밤은 충고를 안겨줍니다.</p>
<p>로마는 하루 만에 지어지지 않았어요.</p>
<p>울타리 너머에 있는 잔디가 더 푸릅니다.</p>
<p>우리 속담 컬렉션에는 10개의 문서가 있어요.</p>
<img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_29.png">
<h2>8. Semantic queries 실행하기</h2>
<p>검색을 실행하기 위해 쿼리 컬렉션에 단일 필드 문서를 삽입할 것입니다. 필드 이름은 "query"이고 값은 다음과 같이 우리 검색어의 텍스트입니다:</p>
<p>' "query": "Things that look good outwardly may not be as valuable or good."'</p>
<p>새로운 문서가 쿼리 컬렉션에 삽입되면 <code>Semantic_Query</code> 트리거가 실행됩니다:</p>
<ul>
<li>속담 문장을 전달하여 쿼리의 임베딩을 얻기 위해 Hugging Face API를 호출합니다.</li>
<li>받은 임베딩 벡터를 문서 자체에 저장합니다 (query_embedding 필드).</li>
<li>MongoDB 집계 명령어를 통해 vector_search_index에서 벡터 검색을 실행합니다.</li>
<li>검색 결과를 문서 자체에 저장합니다 (answer 필드).</li>
</ul>
<p>쿼리를 테스트하려면 "Collections" 탭으로 이동하여 쿼리 컬렉션에 쿼리를 삽입하세요:</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSematicSearch_30.png" alt="2024-05-14-GettingStartedwithMongoDBAtlasforSematicSearch_30.png"></p>
<p>여기 답변이 있어요:</p>
<p><img src="/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_31.png" alt="image"></p>
<p>우리 질문과 가장 유사한 의미를 가진 속담 두 개는 다음과 같습니다:</p>
<p>"반짝이는 것이 모두 금은 아니다." 그리고 "만능 재주꾼은 아무것도 제대로 할 수 없다."</p>
<p>정답이 잘 보입니다! 데이터셋과 쿼리를 실험해 볼 수 있습니다. 또한 OpenAI 텍스트 임베딩 API와 같은 다양한 임베딩 모델을 테스트하여 응답의 정확성을 평가할 수도 있습니다.</p>
<h1>참고 자료</h1>
<ul>
<li>MongoDB Atlas 매뉴얼</li>
<li>MongoDB Atlas 벡터 검색</li>
<li>MongoDB Atlas 검색 튜토리얼</li>
<li>일반적인 영어 속담</li>
<li>Hugging Face 텍스트 임베딩 모델</li>
</ul>
<p>MongoDB에 대한 지식을 확장하고 싶다면 How MongoDB Works에 대한 제 논문을 살펴보세요.</p>
<p>제가 쓰는 이야기를 좋아해주시고 지원하고 싶으시다면, Medium 회원이 되어서 지원해주실 수 있어요. 매달 $5를 내면 Medium의 모든 이야기에 무제한 액세스할 수 있어요. 저의 추천 링크를 사용해서 가입하면, 작은 커미션을 받을 수 있어요. 고려해 주셔서 감사합니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"시맨틱 검색을 위한 MongoDB Atlas 시작하기","description":"","date":"2024-05-14 15:33","slug":"2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch","content":"\n\n## 최신 MongoDB Atlas Vector Search 기능을 소개합니다\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png)\n\n6월 22일, MongoDB가 Atlas Vector Search를 미리 보기 모드로 출시했습니다.\n\n이 새로운 기능을 사용해봤어요!\n\n\n\n테이블 태그를 마크다운 형식으로 바꾸세요.\n\n\n\n이 검색 방법은 텍스트, 오디오, 비디오 및 이미지와 같이 구조화되지 않은 데이터를 효과적으로 검색하기 위해 기계 학습 모델을 활용합니다. 이를 통해 검색 항목과 유사하거나 관련된 항목을 찾을 수 있습니다. 추천 시스템, 챗봇 또는 검색 엔진과 같은 여러 사용 사례에 활용됩니다.\n\n텍스트 데이터를 다룰 때 벡터 검색을 통해 정확한 검색어가 검색된 문장에 없더라도 비슷한 의미의 단어나 구를 찾을 수 있습니다.\n\n벡터 검색은 임베딩 개념을 기반으로 합니다.\n\n## Embeddings\n\n\n\n벡터 검색은 고급 머신 러닝 모델(encoders)을 사용하여 구조화되지 않은 입력 데이터의 수치적 표현을 제공하는 벡터 임베딩을 생성합니다.\n\n벡터 임베딩은 컴퓨터에게 일반적으로 이해하기 어려운 구조화되지 않은 데이터를 숫자 형식으로 변환합니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_1.png)\n\n임베딩은 주로 수치 값 배열인 고차원 벡터입니다. 이러한 벡터는 데이터의 맥락적 및 의미적 정보를 포함하고 있어 유의미한 비교와 계산을 수행할 수 있도록 합니다.\n\n\n\n예를 들어, 텍스트 임베딩 모델(인코더)은 구절 내 단어들 사이의 관계를 학습하여 문장의 의미와 맥락 정보를 포착하는 임베딩을 생성할 수 있습니다.\n\n![image](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_2.png)\n\n위 이미지에서 \"bovine buddies say\" 구절은 부동 소수점 숫자 배열([-0.005, 0.012, -0.008, ..., -0.010])로 인코딩되었습니다.\n\n벡터의 차원은 임베딩 모델에 따라 다르며 높을 수 있습니다(수천 개까지).\n\n\n\nMarkdown으로 테이블 태그를 변경하세요.\n\n\n\n## Atlas Vector Search\n\nAtlas Vector Search은 MongoDB Atlas의 새로운 기능으로, MongoDB의 검색 기능을 더욱 발전시킵니다.\n\nMongoDB Atlas Vector Search는 다음을 제공합니다:\n\n- 원하는 외부 ML 모델(OpenAI, Hugging Face 등)에서 생성된 임베딩 벡터를 보존하는 벡터 저장소;\n- 저장된 임베딩 벡터를 색인화하는 벡터 저장소 인덱스;\n- 저장된 벡터에서 의미 검색을 수행하기 위한 근사 최근 이웃(ANN) 알고리즘을 구현하는 검색 작업.\n\n\n\n몽고디비 Atlas Search를 사용하면 사용자는 기본 키워드 매칭 이상의 정보 검색 기능을 확장할 수 있습니다. 이 혁신적인 도구는 컨텍스트 인식 시맨틱 검색을 가능하게하여 사용자의 검색어에서 의미를 유추할 수 있도록 합니다.\n\n# 액션에서의 Atlas Vector Search\n\n이제 몽고디비 Atlas Vector Search의 새로운 기능을 시도해 보겠습니다.\n\n이 튜토리얼을 완료하기 위해 다음 단계를 실행해 보겠습니다:\n\n\n\n- 무료 MongoDB ATLAS 클러스터를 생성하세요.\n- 속담과 쿼리를 위한 MongoDB 컬렉션을 생성하세요.\n- Hugging Face API 토큰을 생성하세요.\n- 생성된 Hugging Face API 토큰을 Atlas에 임포트하세요.\n- Atlas Database Triggers 및 HF API 실행을 위한 함수를 만드세요.\n- 벡터 검색 인덱스를 생성하세요.\n- 속담 데이터셋을 MongoDB에 삽입하세요.\n- 의미론적 쿼리를 실행하세요.\n\n이번 튜토리얼에서는 Atlas UI만 사용하여 작업할 예정입니다.\n\n## 1. 무료 MongoDB ATLAS 클러스터 생성\n\n첫 번째 단계는 MongoDB Atlas 무료 클러스터(M0 클러스터)를 배포하는 것입니다.\n\n\n\n이 튜토리얼에서는 새로운 것을 만들기보다 기존의 Atlas 클러스터를 자유롭게 사용해도 괜찮습니다.\n\n## 2. 속담 및 질의를 위한 MongoDB 컬렉션 생성\n\n이 튜토리얼에서는 같은 데이터베이스에 속한 두 개의 컬렉션을 사용할 것입니다:\n\n- 속담과 그에 대한 내장 값을 저장하는 `vector_search.proverbs`\n- 질의와 답변을 저장하는 `vector_search.queries`\n\n\n\n데이터베이스와 컬렉션은 Atlas UI에서 생성됩니다.\n\n데이터베이스 배포에서 'Collections 찾아보기' 버튼을 클릭하십시오:\n\n![Collections 찾아보기](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_4.png)\n\n그런 다음 Collections 탭에서 + 데이터베이스 생성을 클릭하고 데이터베이스 이름 (vector_search), 첫 번째 컬렉션 이름 (proverbs)을 입력한 후 생성 버튼을 클릭하십시오.\n\n\n\nMarkdown 형식으로 테이블 태그를 바꿔 주세요:\n\n\n![이미지 1](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_5.png)\n\n두 번째 컬렉션을 만들기 위해 데이터베이스 vector_search를 선택하거나 호버한 후, 플러스(+) 아이콘을 클릭하세요.\n\n![이미지 2](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_6.png)\n\n다음으로 vector_search 데이터베이스 내에 queries 컬렉션을 생성하세요:\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_7.png\" /\u003e\n\n이제 여러분의 컬렉션이 준비되었어요.\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_8.png\" /\u003e\n\n## 3. Hugging Face API 토큰 생성\n\n\n\n프로버브에 대한 벡터 임베딩을 얻기 위해 무료 공개 Hugging Face 추론 API를 사용할 것입니다.\n\n텍스트 임베딩 API를 호출하기 전에 Hugging Face 사이트에서 읽기 액세스 토큰을 생성해야 합니다.\n\nHugging Face 웹사이트로 이동하여 로그인하거나 회원 가입하세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_9.png)\n\n\n\n로그인한 후 오른쪽 상단으로 이동하여 프로필 아이콘을 클릭하고 설정을 선택하세요. 그런 다음 프로필 설정 페이지 왼쪽에 있는 Access Tokens를 클릭하고 New Token 버튼을 누르세요.\n\n![Access Tokens](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_10.png)\n\n토큰에 이름을 지정하고 read 역할을 선택한 후 Generate a token을 클릭하세요.\n\n![Generate a Token](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_11.png)\n\n\n\n위의 생성된 토큰을 안전한 위치에 복사하여 저장해주세요.\n\n![image](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_12.png)\n\n## 4. 아틀라스로 허깅 페이스 API 토큰 가져오기\n\nHF API를 호출하기 전에 먼저 아틀라스에 이전에 생성된 허깅 페이스 토큰을 가져와야 합니다.\n\n\n\nAtlas UI의 App Services 페이지로 이동해주세요:\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_13.png)\n\nTriggers 애플리케이션(가장 왼쪽 상자)을 클릭한 후, 왼쪽 메뉴에서 Values를 선택하고, Create New Value 버튼을 클릭해주세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_14.png)\n\n\n\n가장 먼저 할 일은 비밀을 만드는 것입니다. 값을 HF_secret로 지정하고 유형을 Secret으로 선택하여 허깅페이스 토큰을 Add Content 필드에 붙여넣은 다음 저장을 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_15.png)\n\n그런 다음, 함수에서 사용할 새 환경 변수를 생성해야 합니다. 이를 위해 오른쪽 상단 버튼의 Create New Value를 다시 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_16.png)\n\n\n\nHF_value라는 이름의 Value 타입의 값을 생성하고 Secret HF_secret에 링크를 걸고 저장을 누르세요. 아래에서 정확히 수행한 것을 따라해주세요.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_17.png)\n\n## 5. Atlas 데이터베이스 트리거 및 함수 생성하여 HF API 호출하기\n\nAtlas UI에서 우리는 격언 및 쿼리 컬렉션에 데이터베이스 트리거를 정의할 수 있습니다. 이를 통해 이 컬렉션에 새 문서가 삽입될 때마다 Hugging Face API를 호출할 수 있습니다.\n\n\n\n데이터베이스 트리거를 생성하려면 데이터베이스 배포로 이동한 다음 왼쪽 탐색 메뉴에서 트리거를 클릭하십시오.\n\n\"트리거 추가\" 버튼을 클릭하여 새 트리거를 구성할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_18.png)\n\nHF_Create_Embeddings 트리거\n\n\n\nvector_search.proverbs 컬렉션에 대한 첫 번째 트리거인 HF_Create_Embeddings을 생성했습니다. 아래와 같이 트리거를 구성하세요:\n\n![trigger configuration](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_19.png)\n\n함수 섹션에서 Function을 이벤트 유형으로 선택하고, 다음의 자바스크립트 함수 코드를 아래 코드 블록에 붙여넣으세요.\n\n![javascript function code](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_20.png)\n\n\n\n위 양식에 붙여넣을 코드는 다음과 같습니다:\n\n```js\nexports = async function(changeEvent) {\n    // 변경 이벤트에서 전체 문서를 가져옵니다.\n    const doc = changeEvent.fullDocument;\n\n    // Hugging Face API의 URL과 키를 정의합니다.\n    const url = 'https://api-inference.huggingface.co/pipeline/feature-extraction/sentence-transformers/all-MiniLM-L6-v2';\n    // App Services 내부의 \"Values\" 유틸리티에서 API 키의 값을 지정한 이름을 사용합니다.\n    const hf_read_token = context.values.get(\"HF_value\");\n\n    try {\n        console.log(`ID가 ${doc._id}인 문서 처리 중`);\n\n        // Hugging Face API를 호출하여 임베딩을 가져옵니다.\n        let response = await context.http.post({\n            url: url,\n            headers: {\n                'Authorization': `Bearer ${hf_read_token}`,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                // 문서 내 데이터를 임베딩할 필드를 지정합니다. 여기서는 샘플 속담 데이터의 \"proverb\" 필드를 사용합니다.\n                inputs: [doc.proverb]\n            })\n        });\n\n        // JSON 응답을 파싱합니다.\n        let responseData = EJSON.parse(response.body.text());\n\n        // 응답 상태를 확인합니다.\n        if(response.statusCode === 200) {\n            console.log(\"임베딩을 성공적으로 받았습니다.\");\n\n            const embedding = responseData[0];\n\n            // MongoDB Atlas에서 클러스터를 가져옵니다.\n            const mongodb = context.services.get('Cluster0');\n            const db = mongodb.db('vector_search'); // 데이터베이스명으로 변경하세요.\n            const collection = db.collection('proverbs'); // 컬렉션명으로 변경하세요.\n\n            // MongoDB에서 문서를 업데이트합니다.\n            const result = await collection.updateOne(\n                { _id: doc._id },\n                // 새로운 필드에 임베딩을 저장할 이름을 지정합니다.\n                { $set: { proverb_embedding: embedding }\n            );\n\n            if(result.modifiedCount === 1) {\n                console.log(\"문서를 성공적으로 업데이트했습니다.\");\n            } else {\n                console.log(\"문서를 업데이트하는 데 실패했습니다.\");\n            }\n        } else {\n            console.log(`임베딩을 받는 데 실패했습니다. 상태 코드: ${response.statusCode}`);\n        }\n\n    } catch(err) {\n        console.error(err);\n    }\n};\n```\n\n트리거 HF_Create_Embeddings는 속담 콜렉션에 삽입된 각 속담에 대한 벡터 임베딩을 얻기 위해 Hugging Face all-MiniLM-L6-v2 모델 API를 호출합니다.\n\nSemantic_Query 트리거\n\n\n\n두 번째 트리거는 쿼리 컬렉션에 생성될 것입니다. 트리거 함수에서는 Hugging Face 임베딩 모델을 호출하여 사용자 쿼리의 임베딩을 가져와 MongoDB 집계 명령을 통해 벡터 검색을 실행할 것입니다.\n\n벡터 검색 결과는 쿼리 컬렉션에 저장될 것입니다.\n\n두 번째 트리거를 만들려면, 첫 번째 트리거와 동일한 프로세스를 따르되, 다음에 설명된 매개변수를 조정해야 합니다 (다른 모든 매개변수 값은 이전과 동일합니다):\n\n이름 Semantic_Query\n\n\n\n컬렉션 이름 쿼리\n\n함수 코드에 다음 블록을 붙여 넣으세요:\n\n```js\nexports = async function(changeEvent) {\n    // 변경 이벤트에서 전체 문서 가져오기\n    const doc = changeEvent.fullDocument;\n\n    // Hugging Face API URL 및 키 정의\n    const url = 'https://api-inference.huggingface.co/pipeline/feature-extraction/sentence-transformers/all-MiniLM-L6-v2';\n    // App Services 내의 \"Values\" 유틸리티에서 API 키의 값을 설정한 이름을 사용\n    const hf_read_token = context.values.get(\"HF_value\");\n\n    try {\n        console.log(`아이디가 ${doc._id}인 문서 처리 중`);\n\n        // 쿼리의 임베딩을 가져오기 위해 Hugging Face API 호출\n        let response = await context.http.post({\n            url: url,\n            headers: {\n                'Authorization': `Bearer ${hf_read_token}`,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                // 데이터를 임베딩할 문서 내 필드. 여기선 \"queries\" 컬렉션의 \"query\" 필드입니다.\n                inputs: [doc.query]\n            })\n        });\n\n        // JSON 응답 파싱\n        let responseData = EJSON.parse(response.body.text());\n\n        // 응답 상태 확인\n        if (response.statusCode === 200) {\n            console.log(\"임베딩 성공적으로 수신\");\n\n            const embedding = responseData[0];\n\n            // MongoDB Atlas에서 클러스터 가져오기\n            const mongodb = context.services.get('Cluster0');\n            const db = mongodb.db('vector_search'); // 데이터베이스 이름으로 대체\n            const proverbs_collection = db.collection('proverbs'); // 컬렉션 이름으로 대체\n            const queries_collection = db.collection('queries'); // 컬렉션 이름으로 대체\n\n            // 유사 문서 쿼리\n            const documents = await proverbs_collection.aggregate([\n                {\n                    \"$search\": {\n                        \"index\": \"vector_search_index\",\n                        \"knnBeta\": {\n                            \"vector\": embedding,\n                            \"path\": \"proverb_embedding\",\n                            \"k\": 2\n                        }\n                    }\n                },\n                {\n                    \"$project\": {\n                        \"_id\": 0,\n                        \"proverb\": 1\n                    }\n                }\n            ]).toArray();\n            \n            // MongoDB에서 문서 업데이트\n            const result = await queries_collection.updateOne(\n                { _id: doc._id },\n                // \"answer\" 필드에 쿼리 결과가 포함됩니다.\n                { $set: { query_embedding: embedding, answer: documents }\n            });\n\n        } else {\n            console.log(`임베딩 수신 실패. 상태 코드: ${response.statusCode}`);\n        }\n\n    } catch(err) {\n        console.error(err);\n    }\n};\n```\n\n## 6. 벡터 탐색 인덱스 생성\n\n\n\n우리는 직역 검색을 가능하게 하기 위해 속담 모음에 벡터 검색 인덱스를 생성해야 합니다. 속담 모음은 우리의 쿼리에 응답하기 위해 검색될 속담 문장의 임베딩(proverb_embedding 필드)을 포함할 것입니다.\n\n인덱스를 생성하려면 다음을 수행하세요. Atlas Search로 이동: 데이터베이스 배포 페이지에서 왼쪽 메뉴에서 검색을 클릭한 후, 데이터 원본 선택 드롭다운 메뉴에서 클러스터를 선택하고 Go to Atlas Search 버튼을 누릅니다.\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_21.png)\n\n새로운 검색 인덱스를 구성하려면 Create Search Index 버튼을 클릭하세요:\n\n\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_22.png)\n\n다음 페이지에서 JSON Editor 상자를 선택하고 Next 버튼을 누르세요:\n\n![이미지](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_23.png)\n\n데이터베이스 및 컬렉션 영역에서 vector_search 데이터베이스와 proverbs 컬렉션을 선택하고, Index Name 필드에 vector_search_index라는 인덱스 이름을 지정하세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_24.png\" /\u003e\n\n다음 JSON 문서를 텍스트 영역에 붙여넣고 '다음' 버튼을 클릭해주세요.\n\n```js\n{\n  \"mappings\": {\n    \"dynamic\": true,\n    \"fields\": {\n      \"proverb_embedding\": {\n        \"dimensions\": 384,\n        \"similarity\": \"dotProduct\",\n        \"type\": \"knnVector\"\n      }\n    }\n  }\n}\n```\n\n'검색 인덱스 생성'을 클릭하면 인덱스 생성이 시작됩니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_25.png\" /\u003e\n\n곧 새로운 인덱스가 활성 상태로 사용 가능할 것입니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_26.png\" /\u003e\n\n## 7. 경구 데이터 세트를 MongoDB에 삽입하기\n\n\n\n우리는 임베딩 스토어를 채우기 위해 영어 속담을 속담 컬렉션에 삽입할 것입니다. Atlas UI에서 하나의 속담을 추가할 것입니다.\n\n우리가 삽입하는 첫 번째 속담은 다음과 같습니다:\n\n속담을 삽입하려면:\n\n- 데이터베이스 배포 페이지에서 Browse Collections로 이동하세요.\n- vector_search 데이터베이스 아래에 있는 proverbs 컬렉션을 선택하세요.\n- \"proverb\"를 필드 이름으로 하고 속담 문장을 값으로 하는 단일 필드 문서를 추가하세요.\n- 그런 다음 삽입을 눌러주세요.\n\n\n\n마법처럼 새로운 필드인 'proverb_embedding'이 문서에 추가됩니다:\n\n'proverb_embedding' 필드에는 HF_Create_Embeddings 트리거에서 호출된 Hugging Face 텍스트 임베딩 모델 API에 의해 생성된 임베딩 벡터(384개의 부동 소수점 요소가 있는 배열)가 포함되어 있습니다.\n\n\n\n자세한 것은 나중에 업데이트됩니다.\n\n\n\n늦게라도 하는 것이 낫죠.\n\n호기심은 고양이를 죽인다고 해요.\n\n불에 노는 바보는 불에 탄다고 하잖아요.\n\n정의를 미루면 결국 물거품이 돼버립니다.\n\n\n\n밤은 충고를 안겨줍니다.\n\n로마는 하루 만에 지어지지 않았어요.\n\n울타리 너머에 있는 잔디가 더 푸릅니다.\n\n우리 속담 컬렉션에는 10개의 문서가 있어요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_29.png\" /\u003e\n\n## 8. Semantic queries 실행하기\n\n검색을 실행하기 위해 쿼리 컬렉션에 단일 필드 문서를 삽입할 것입니다. 필드 이름은 \"query\"이고 값은 다음과 같이 우리 검색어의 텍스트입니다:\n\n' \"query\": \"Things that look good outwardly may not be as valuable or good.\"'\n\n\n\n새로운 문서가 쿼리 컬렉션에 삽입되면 `Semantic_Query` 트리거가 실행됩니다:\n\n- 속담 문장을 전달하여 쿼리의 임베딩을 얻기 위해 Hugging Face API를 호출합니다.\n- 받은 임베딩 벡터를 문서 자체에 저장합니다 (query_embedding 필드).\n- MongoDB 집계 명령어를 통해 vector_search_index에서 벡터 검색을 실행합니다.\n- 검색 결과를 문서 자체에 저장합니다 (answer 필드).\n\n쿼리를 테스트하려면 \"Collections\" 탭으로 이동하여 쿼리 컬렉션에 쿼리를 삽입하세요:\n\n![2024-05-14-GettingStartedwithMongoDBAtlasforSematicSearch_30.png](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSematicSearch_30.png)\n\n\n\n여기 답변이 있어요:\n\n![image](/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_31.png)\n\n우리 질문과 가장 유사한 의미를 가진 속담 두 개는 다음과 같습니다:\n\n\"반짝이는 것이 모두 금은 아니다.\" 그리고 \"만능 재주꾼은 아무것도 제대로 할 수 없다.\"\n\n\n\n정답이 잘 보입니다! 데이터셋과 쿼리를 실험해 볼 수 있습니다. 또한 OpenAI 텍스트 임베딩 API와 같은 다양한 임베딩 모델을 테스트하여 응답의 정확성을 평가할 수도 있습니다.\n\n# 참고 자료\n\n- MongoDB Atlas 매뉴얼\n- MongoDB Atlas 벡터 검색\n- MongoDB Atlas 검색 튜토리얼\n- 일반적인 영어 속담\n- Hugging Face 텍스트 임베딩 모델\n\nMongoDB에 대한 지식을 확장하고 싶다면 How MongoDB Works에 대한 제 논문을 살펴보세요.\n\n\n\n제가 쓰는 이야기를 좋아해주시고 지원하고 싶으시다면, Medium 회원이 되어서 지원해주실 수 있어요. 매달 $5를 내면 Medium의 모든 이야기에 무제한 액세스할 수 있어요. 저의 추천 링크를 사용해서 가입하면, 작은 커미션을 받을 수 있어요. 고려해 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png"},"coverImage":"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e최신 MongoDB Atlas Vector Search 기능을 소개합니다\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e6월 22일, MongoDB가 Atlas Vector Search를 미리 보기 모드로 출시했습니다.\u003c/p\u003e\n\u003cp\u003e이 새로운 기능을 사용해봤어요!\u003c/p\u003e\n\u003cp\u003e테이블 태그를 마크다운 형식으로 바꾸세요.\u003c/p\u003e\n\u003cp\u003e이 검색 방법은 텍스트, 오디오, 비디오 및 이미지와 같이 구조화되지 않은 데이터를 효과적으로 검색하기 위해 기계 학습 모델을 활용합니다. 이를 통해 검색 항목과 유사하거나 관련된 항목을 찾을 수 있습니다. 추천 시스템, 챗봇 또는 검색 엔진과 같은 여러 사용 사례에 활용됩니다.\u003c/p\u003e\n\u003cp\u003e텍스트 데이터를 다룰 때 벡터 검색을 통해 정확한 검색어가 검색된 문장에 없더라도 비슷한 의미의 단어나 구를 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e벡터 검색은 임베딩 개념을 기반으로 합니다.\u003c/p\u003e\n\u003ch2\u003eEmbeddings\u003c/h2\u003e\n\u003cp\u003e벡터 검색은 고급 머신 러닝 모델(encoders)을 사용하여 구조화되지 않은 입력 데이터의 수치적 표현을 제공하는 벡터 임베딩을 생성합니다.\u003c/p\u003e\n\u003cp\u003e벡터 임베딩은 컴퓨터에게 일반적으로 이해하기 어려운 구조화되지 않은 데이터를 숫자 형식으로 변환합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e임베딩은 주로 수치 값 배열인 고차원 벡터입니다. 이러한 벡터는 데이터의 맥락적 및 의미적 정보를 포함하고 있어 유의미한 비교와 계산을 수행할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 텍스트 임베딩 모델(인코더)은 구절 내 단어들 사이의 관계를 학습하여 문장의 의미와 맥락 정보를 포착하는 임베딩을 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e위 이미지에서 \"bovine buddies say\" 구절은 부동 소수점 숫자 배열([-0.005, 0.012, -0.008, ..., -0.010])로 인코딩되었습니다.\u003c/p\u003e\n\u003cp\u003e벡터의 차원은 임베딩 모델에 따라 다르며 높을 수 있습니다(수천 개까지).\u003c/p\u003e\n\u003cp\u003eMarkdown으로 테이블 태그를 변경하세요.\u003c/p\u003e\n\u003ch2\u003eAtlas Vector Search\u003c/h2\u003e\n\u003cp\u003eAtlas Vector Search은 MongoDB Atlas의 새로운 기능으로, MongoDB의 검색 기능을 더욱 발전시킵니다.\u003c/p\u003e\n\u003cp\u003eMongoDB Atlas Vector Search는 다음을 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e원하는 외부 ML 모델(OpenAI, Hugging Face 등)에서 생성된 임베딩 벡터를 보존하는 벡터 저장소;\u003c/li\u003e\n\u003cli\u003e저장된 임베딩 벡터를 색인화하는 벡터 저장소 인덱스;\u003c/li\u003e\n\u003cli\u003e저장된 벡터에서 의미 검색을 수행하기 위한 근사 최근 이웃(ANN) 알고리즘을 구현하는 검색 작업.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e몽고디비 Atlas Search를 사용하면 사용자는 기본 키워드 매칭 이상의 정보 검색 기능을 확장할 수 있습니다. 이 혁신적인 도구는 컨텍스트 인식 시맨틱 검색을 가능하게하여 사용자의 검색어에서 의미를 유추할 수 있도록 합니다.\u003c/p\u003e\n\u003ch1\u003e액션에서의 Atlas Vector Search\u003c/h1\u003e\n\u003cp\u003e이제 몽고디비 Atlas Vector Search의 새로운 기능을 시도해 보겠습니다.\u003c/p\u003e\n\u003cp\u003e이 튜토리얼을 완료하기 위해 다음 단계를 실행해 보겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e무료 MongoDB ATLAS 클러스터를 생성하세요.\u003c/li\u003e\n\u003cli\u003e속담과 쿼리를 위한 MongoDB 컬렉션을 생성하세요.\u003c/li\u003e\n\u003cli\u003eHugging Face API 토큰을 생성하세요.\u003c/li\u003e\n\u003cli\u003e생성된 Hugging Face API 토큰을 Atlas에 임포트하세요.\u003c/li\u003e\n\u003cli\u003eAtlas Database Triggers 및 HF API 실행을 위한 함수를 만드세요.\u003c/li\u003e\n\u003cli\u003e벡터 검색 인덱스를 생성하세요.\u003c/li\u003e\n\u003cli\u003e속담 데이터셋을 MongoDB에 삽입하세요.\u003c/li\u003e\n\u003cli\u003e의미론적 쿼리를 실행하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이번 튜토리얼에서는 Atlas UI만 사용하여 작업할 예정입니다.\u003c/p\u003e\n\u003ch2\u003e1. 무료 MongoDB ATLAS 클러스터 생성\u003c/h2\u003e\n\u003cp\u003e첫 번째 단계는 MongoDB Atlas 무료 클러스터(M0 클러스터)를 배포하는 것입니다.\u003c/p\u003e\n\u003cp\u003e이 튜토리얼에서는 새로운 것을 만들기보다 기존의 Atlas 클러스터를 자유롭게 사용해도 괜찮습니다.\u003c/p\u003e\n\u003ch2\u003e2. 속담 및 질의를 위한 MongoDB 컬렉션 생성\u003c/h2\u003e\n\u003cp\u003e이 튜토리얼에서는 같은 데이터베이스에 속한 두 개의 컬렉션을 사용할 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e속담과 그에 대한 내장 값을 저장하는 \u003ccode\u003evector_search.proverbs\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e질의와 답변을 저장하는 \u003ccode\u003evector_search.queries\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e데이터베이스와 컬렉션은 Atlas UI에서 생성됩니다.\u003c/p\u003e\n\u003cp\u003e데이터베이스 배포에서 'Collections 찾아보기' 버튼을 클릭하십시오:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_4.png\" alt=\"Collections 찾아보기\"\u003e\u003c/p\u003e\n\u003cp\u003e그런 다음 Collections 탭에서 + 데이터베이스 생성을 클릭하고 데이터베이스 이름 (vector_search), 첫 번째 컬렉션 이름 (proverbs)을 입력한 후 생성 버튼을 클릭하십시오.\u003c/p\u003e\n\u003cp\u003eMarkdown 형식으로 테이블 태그를 바꿔 주세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_5.png\" alt=\"이미지 1\"\u003e\u003c/p\u003e\n\u003cp\u003e두 번째 컬렉션을 만들기 위해 데이터베이스 vector_search를 선택하거나 호버한 후, 플러스(+) 아이콘을 클릭하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_6.png\" alt=\"이미지 2\"\u003e\u003c/p\u003e\n\u003cp\u003e다음으로 vector_search 데이터베이스 내에 queries 컬렉션을 생성하세요:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_7.png\"\u003e\n\u003cp\u003e이제 여러분의 컬렉션이 준비되었어요.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_8.png\"\u003e\n\u003ch2\u003e3. Hugging Face API 토큰 생성\u003c/h2\u003e\n\u003cp\u003e프로버브에 대한 벡터 임베딩을 얻기 위해 무료 공개 Hugging Face 추론 API를 사용할 것입니다.\u003c/p\u003e\n\u003cp\u003e텍스트 임베딩 API를 호출하기 전에 Hugging Face 사이트에서 읽기 액세스 토큰을 생성해야 합니다.\u003c/p\u003e\n\u003cp\u003eHugging Face 웹사이트로 이동하여 로그인하거나 회원 가입하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_9.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e로그인한 후 오른쪽 상단으로 이동하여 프로필 아이콘을 클릭하고 설정을 선택하세요. 그런 다음 프로필 설정 페이지 왼쪽에 있는 Access Tokens를 클릭하고 New Token 버튼을 누르세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_10.png\" alt=\"Access Tokens\"\u003e\u003c/p\u003e\n\u003cp\u003e토큰에 이름을 지정하고 read 역할을 선택한 후 Generate a token을 클릭하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_11.png\" alt=\"Generate a Token\"\u003e\u003c/p\u003e\n\u003cp\u003e위의 생성된 토큰을 안전한 위치에 복사하여 저장해주세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_12.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003e4. 아틀라스로 허깅 페이스 API 토큰 가져오기\u003c/h2\u003e\n\u003cp\u003eHF API를 호출하기 전에 먼저 아틀라스에 이전에 생성된 허깅 페이스 토큰을 가져와야 합니다.\u003c/p\u003e\n\u003cp\u003eAtlas UI의 App Services 페이지로 이동해주세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_13.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eTriggers 애플리케이션(가장 왼쪽 상자)을 클릭한 후, 왼쪽 메뉴에서 Values를 선택하고, Create New Value 버튼을 클릭해주세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_14.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e가장 먼저 할 일은 비밀을 만드는 것입니다. 값을 HF_secret로 지정하고 유형을 Secret으로 선택하여 허깅페이스 토큰을 Add Content 필드에 붙여넣은 다음 저장을 클릭하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_15.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e그런 다음, 함수에서 사용할 새 환경 변수를 생성해야 합니다. 이를 위해 오른쪽 상단 버튼의 Create New Value를 다시 클릭하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_16.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eHF_value라는 이름의 Value 타입의 값을 생성하고 Secret HF_secret에 링크를 걸고 저장을 누르세요. 아래에서 정확히 수행한 것을 따라해주세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_17.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e5. Atlas 데이터베이스 트리거 및 함수 생성하여 HF API 호출하기\u003c/h2\u003e\n\u003cp\u003eAtlas UI에서 우리는 격언 및 쿼리 컬렉션에 데이터베이스 트리거를 정의할 수 있습니다. 이를 통해 이 컬렉션에 새 문서가 삽입될 때마다 Hugging Face API를 호출할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e데이터베이스 트리거를 생성하려면 데이터베이스 배포로 이동한 다음 왼쪽 탐색 메뉴에서 트리거를 클릭하십시오.\u003c/p\u003e\n\u003cp\u003e\"트리거 추가\" 버튼을 클릭하여 새 트리거를 구성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_18.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eHF_Create_Embeddings 트리거\u003c/p\u003e\n\u003cp\u003evector_search.proverbs 컬렉션에 대한 첫 번째 트리거인 HF_Create_Embeddings을 생성했습니다. 아래와 같이 트리거를 구성하세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_19.png\" alt=\"trigger configuration\"\u003e\u003c/p\u003e\n\u003cp\u003e함수 섹션에서 Function을 이벤트 유형으로 선택하고, 다음의 자바스크립트 함수 코드를 아래 코드 블록에 붙여넣으세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_20.png\" alt=\"javascript function code\"\u003e\u003c/p\u003e\n\u003cp\u003e위 양식에 붙여넣을 코드는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003echangeEvent\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 변경 이벤트에서 전체 문서를 가져옵니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e doc = changeEvent.\u003cspan class=\"hljs-property\"\u003efullDocument\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// Hugging Face API의 URL과 키를 정의합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e url = \u003cspan class=\"hljs-string\"\u003e'https://api-inference.huggingface.co/pipeline/feature-extraction/sentence-transformers/all-MiniLM-L6-v2'\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// App Services 내부의 \"Values\" 유틸리티에서 API 키의 값을 지정한 이름을 사용합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hf_read_token = context.\u003cspan class=\"hljs-property\"\u003evalues\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"HF_value\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`ID가 \u003cspan class=\"hljs-subst\"\u003e${doc._id}\u003c/span\u003e인 문서 처리 중`\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-comment\"\u003e// Hugging Face API를 호출하여 임베딩을 가져옵니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e context.\u003cspan class=\"hljs-property\"\u003ehttp\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e({\n            \u003cspan class=\"hljs-attr\"\u003eurl\u003c/span\u003e: url,\n            \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: {\n                \u003cspan class=\"hljs-string\"\u003e'Authorization'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`Bearer \u003cspan class=\"hljs-subst\"\u003e${hf_read_token}\u003c/span\u003e`\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e'Content-Type'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e\n            },\n            \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e({\n                \u003cspan class=\"hljs-comment\"\u003e// 문서 내 데이터를 임베딩할 필드를 지정합니다. 여기서는 샘플 속담 데이터의 \"proverb\" 필드를 사용합니다.\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003einputs\u003c/span\u003e: [doc.\u003cspan class=\"hljs-property\"\u003eproverb\u003c/span\u003e]\n            })\n        });\n\n        \u003cspan class=\"hljs-comment\"\u003e// JSON 응답을 파싱합니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e responseData = \u003cspan class=\"hljs-variable constant_\"\u003eEJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(response.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etext\u003c/span\u003e());\n\n        \u003cspan class=\"hljs-comment\"\u003e// 응답 상태를 확인합니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(response.\u003cspan class=\"hljs-property\"\u003estatusCode\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e) {\n            \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"임베딩을 성공적으로 받았습니다.\"\u003c/span\u003e);\n\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e embedding = responseData[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n\n            \u003cspan class=\"hljs-comment\"\u003e// MongoDB Atlas에서 클러스터를 가져옵니다.\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mongodb = context.\u003cspan class=\"hljs-property\"\u003eservices\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Cluster0'\u003c/span\u003e);\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e db = mongodb.\u003cspan class=\"hljs-title function_\"\u003edb\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'vector_search'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 데이터베이스명으로 변경하세요.\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e collection = db.\u003cspan class=\"hljs-title function_\"\u003ecollection\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'proverbs'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 컬렉션명으로 변경하세요.\u003c/span\u003e\n\n            \u003cspan class=\"hljs-comment\"\u003e// MongoDB에서 문서를 업데이트합니다.\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e collection.\u003cspan class=\"hljs-title function_\"\u003eupdateOne\u003c/span\u003e(\n                { \u003cspan class=\"hljs-attr\"\u003e_id\u003c/span\u003e: doc.\u003cspan class=\"hljs-property\"\u003e_id\u003c/span\u003e },\n                \u003cspan class=\"hljs-comment\"\u003e// 새로운 필드에 임베딩을 저장할 이름을 지정합니다.\u003c/span\u003e\n                { \u003cspan class=\"hljs-attr\"\u003e$set\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003eproverb_embedding\u003c/span\u003e: embedding }\n            );\n\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(result.\u003cspan class=\"hljs-property\"\u003emodifiedCount\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n                \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"문서를 성공적으로 업데이트했습니다.\"\u003c/span\u003e);\n            } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"문서를 업데이트하는 데 실패했습니다.\"\u003c/span\u003e);\n            }\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`임베딩을 받는 데 실패했습니다. 상태 코드: \u003cspan class=\"hljs-subst\"\u003e${response.statusCode}\u003c/span\u003e`\u003c/span\u003e);\n        }\n\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(err) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(err);\n    }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e트리거 HF_Create_Embeddings는 속담 콜렉션에 삽입된 각 속담에 대한 벡터 임베딩을 얻기 위해 Hugging Face all-MiniLM-L6-v2 모델 API를 호출합니다.\u003c/p\u003e\n\u003cp\u003eSemantic_Query 트리거\u003c/p\u003e\n\u003cp\u003e두 번째 트리거는 쿼리 컬렉션에 생성될 것입니다. 트리거 함수에서는 Hugging Face 임베딩 모델을 호출하여 사용자 쿼리의 임베딩을 가져와 MongoDB 집계 명령을 통해 벡터 검색을 실행할 것입니다.\u003c/p\u003e\n\u003cp\u003e벡터 검색 결과는 쿼리 컬렉션에 저장될 것입니다.\u003c/p\u003e\n\u003cp\u003e두 번째 트리거를 만들려면, 첫 번째 트리거와 동일한 프로세스를 따르되, 다음에 설명된 매개변수를 조정해야 합니다 (다른 모든 매개변수 값은 이전과 동일합니다):\u003c/p\u003e\n\u003cp\u003e이름 Semantic_Query\u003c/p\u003e\n\u003cp\u003e컬렉션 이름 쿼리\u003c/p\u003e\n\u003cp\u003e함수 코드에 다음 블록을 붙여 넣으세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003echangeEvent\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 변경 이벤트에서 전체 문서 가져오기\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e doc = changeEvent.\u003cspan class=\"hljs-property\"\u003efullDocument\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// Hugging Face API URL 및 키 정의\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e url = \u003cspan class=\"hljs-string\"\u003e'https://api-inference.huggingface.co/pipeline/feature-extraction/sentence-transformers/all-MiniLM-L6-v2'\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// App Services 내의 \"Values\" 유틸리티에서 API 키의 값을 설정한 이름을 사용\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hf_read_token = context.\u003cspan class=\"hljs-property\"\u003evalues\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"HF_value\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`아이디가 \u003cspan class=\"hljs-subst\"\u003e${doc._id}\u003c/span\u003e인 문서 처리 중`\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-comment\"\u003e// 쿼리의 임베딩을 가져오기 위해 Hugging Face API 호출\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e context.\u003cspan class=\"hljs-property\"\u003ehttp\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e({\n            \u003cspan class=\"hljs-attr\"\u003eurl\u003c/span\u003e: url,\n            \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: {\n                \u003cspan class=\"hljs-string\"\u003e'Authorization'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`Bearer \u003cspan class=\"hljs-subst\"\u003e${hf_read_token}\u003c/span\u003e`\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e'Content-Type'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e\n            },\n            \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e({\n                \u003cspan class=\"hljs-comment\"\u003e// 데이터를 임베딩할 문서 내 필드. 여기선 \"queries\" 컬렉션의 \"query\" 필드입니다.\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003einputs\u003c/span\u003e: [doc.\u003cspan class=\"hljs-property\"\u003equery\u003c/span\u003e]\n            })\n        });\n\n        \u003cspan class=\"hljs-comment\"\u003e// JSON 응답 파싱\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e responseData = \u003cspan class=\"hljs-variable constant_\"\u003eEJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(response.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etext\u003c/span\u003e());\n\n        \u003cspan class=\"hljs-comment\"\u003e// 응답 상태 확인\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (response.\u003cspan class=\"hljs-property\"\u003estatusCode\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e) {\n            \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"임베딩 성공적으로 수신\"\u003c/span\u003e);\n\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e embedding = responseData[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n\n            \u003cspan class=\"hljs-comment\"\u003e// MongoDB Atlas에서 클러스터 가져오기\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mongodb = context.\u003cspan class=\"hljs-property\"\u003eservices\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Cluster0'\u003c/span\u003e);\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e db = mongodb.\u003cspan class=\"hljs-title function_\"\u003edb\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'vector_search'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 데이터베이스 이름으로 대체\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e proverbs_collection = db.\u003cspan class=\"hljs-title function_\"\u003ecollection\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'proverbs'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 컬렉션 이름으로 대체\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e queries_collection = db.\u003cspan class=\"hljs-title function_\"\u003ecollection\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'queries'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 컬렉션 이름으로 대체\u003c/span\u003e\n\n            \u003cspan class=\"hljs-comment\"\u003e// 유사 문서 쿼리\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e documents = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e proverbs_collection.\u003cspan class=\"hljs-title function_\"\u003eaggregate\u003c/span\u003e([\n                {\n                    \u003cspan class=\"hljs-string\"\u003e\"$search\"\u003c/span\u003e: {\n                        \u003cspan class=\"hljs-string\"\u003e\"index\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"vector_search_index\"\u003c/span\u003e,\n                        \u003cspan class=\"hljs-string\"\u003e\"knnBeta\"\u003c/span\u003e: {\n                            \u003cspan class=\"hljs-string\"\u003e\"vector\"\u003c/span\u003e: embedding,\n                            \u003cspan class=\"hljs-string\"\u003e\"path\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"proverb_embedding\"\u003c/span\u003e,\n                            \u003cspan class=\"hljs-string\"\u003e\"k\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n                        }\n                    }\n                },\n                {\n                    \u003cspan class=\"hljs-string\"\u003e\"$project\"\u003c/span\u003e: {\n                        \u003cspan class=\"hljs-string\"\u003e\"_id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n                        \u003cspan class=\"hljs-string\"\u003e\"proverb\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n                    }\n                }\n            ]).\u003cspan class=\"hljs-title function_\"\u003etoArray\u003c/span\u003e();\n            \n            \u003cspan class=\"hljs-comment\"\u003e// MongoDB에서 문서 업데이트\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e queries_collection.\u003cspan class=\"hljs-title function_\"\u003eupdateOne\u003c/span\u003e(\n                { \u003cspan class=\"hljs-attr\"\u003e_id\u003c/span\u003e: doc.\u003cspan class=\"hljs-property\"\u003e_id\u003c/span\u003e },\n                \u003cspan class=\"hljs-comment\"\u003e// \"answer\" 필드에 쿼리 결과가 포함됩니다.\u003c/span\u003e\n                { \u003cspan class=\"hljs-attr\"\u003e$set\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003equery_embedding\u003c/span\u003e: embedding, \u003cspan class=\"hljs-attr\"\u003eanswer\u003c/span\u003e: documents }\n            });\n\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`임베딩 수신 실패. 상태 코드: \u003cspan class=\"hljs-subst\"\u003e${response.statusCode}\u003c/span\u003e`\u003c/span\u003e);\n        }\n\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(err) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(err);\n    }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e6. 벡터 탐색 인덱스 생성\u003c/h2\u003e\n\u003cp\u003e우리는 직역 검색을 가능하게 하기 위해 속담 모음에 벡터 검색 인덱스를 생성해야 합니다. 속담 모음은 우리의 쿼리에 응답하기 위해 검색될 속담 문장의 임베딩(proverb_embedding 필드)을 포함할 것입니다.\u003c/p\u003e\n\u003cp\u003e인덱스를 생성하려면 다음을 수행하세요. Atlas Search로 이동: 데이터베이스 배포 페이지에서 왼쪽 메뉴에서 검색을 클릭한 후, 데이터 원본 선택 드롭다운 메뉴에서 클러스터를 선택하고 Go to Atlas Search 버튼을 누릅니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_21.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e새로운 검색 인덱스를 구성하려면 Create Search Index 버튼을 클릭하세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_22.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e다음 페이지에서 JSON Editor 상자를 선택하고 Next 버튼을 누르세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_23.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e데이터베이스 및 컬렉션 영역에서 vector_search 데이터베이스와 proverbs 컬렉션을 선택하고, Index Name 필드에 vector_search_index라는 인덱스 이름을 지정하세요.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_24.png\"\u003e\n\u003cp\u003e다음 JSON 문서를 텍스트 영역에 붙여넣고 '다음' 버튼을 클릭해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\"mappings\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"dynamic\"\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"fields\"\u003c/span\u003e: {\n      \u003cspan class=\"hljs-string\"\u003e\"proverb_embedding\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"dimensions\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e384\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"similarity\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"dotProduct\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"knnVector\"\u003c/span\u003e\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e'검색 인덱스 생성'을 클릭하면 인덱스 생성이 시작됩니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_25.png\"\u003e\n\u003cp\u003e곧 새로운 인덱스가 활성 상태로 사용 가능할 것입니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_26.png\"\u003e\n\u003ch2\u003e7. 경구 데이터 세트를 MongoDB에 삽입하기\u003c/h2\u003e\n\u003cp\u003e우리는 임베딩 스토어를 채우기 위해 영어 속담을 속담 컬렉션에 삽입할 것입니다. Atlas UI에서 하나의 속담을 추가할 것입니다.\u003c/p\u003e\n\u003cp\u003e우리가 삽입하는 첫 번째 속담은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e속담을 삽입하려면:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e데이터베이스 배포 페이지에서 Browse Collections로 이동하세요.\u003c/li\u003e\n\u003cli\u003evector_search 데이터베이스 아래에 있는 proverbs 컬렉션을 선택하세요.\u003c/li\u003e\n\u003cli\u003e\"proverb\"를 필드 이름으로 하고 속담 문장을 값으로 하는 단일 필드 문서를 추가하세요.\u003c/li\u003e\n\u003cli\u003e그런 다음 삽입을 눌러주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e마법처럼 새로운 필드인 'proverb_embedding'이 문서에 추가됩니다:\u003c/p\u003e\n\u003cp\u003e'proverb_embedding' 필드에는 HF_Create_Embeddings 트리거에서 호출된 Hugging Face 텍스트 임베딩 모델 API에 의해 생성된 임베딩 벡터(384개의 부동 소수점 요소가 있는 배열)가 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e자세한 것은 나중에 업데이트됩니다.\u003c/p\u003e\n\u003cp\u003e늦게라도 하는 것이 낫죠.\u003c/p\u003e\n\u003cp\u003e호기심은 고양이를 죽인다고 해요.\u003c/p\u003e\n\u003cp\u003e불에 노는 바보는 불에 탄다고 하잖아요.\u003c/p\u003e\n\u003cp\u003e정의를 미루면 결국 물거품이 돼버립니다.\u003c/p\u003e\n\u003cp\u003e밤은 충고를 안겨줍니다.\u003c/p\u003e\n\u003cp\u003e로마는 하루 만에 지어지지 않았어요.\u003c/p\u003e\n\u003cp\u003e울타리 너머에 있는 잔디가 더 푸릅니다.\u003c/p\u003e\n\u003cp\u003e우리 속담 컬렉션에는 10개의 문서가 있어요.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_29.png\"\u003e\n\u003ch2\u003e8. Semantic queries 실행하기\u003c/h2\u003e\n\u003cp\u003e검색을 실행하기 위해 쿼리 컬렉션에 단일 필드 문서를 삽입할 것입니다. 필드 이름은 \"query\"이고 값은 다음과 같이 우리 검색어의 텍스트입니다:\u003c/p\u003e\n\u003cp\u003e' \"query\": \"Things that look good outwardly may not be as valuable or good.\"'\u003c/p\u003e\n\u003cp\u003e새로운 문서가 쿼리 컬렉션에 삽입되면 \u003ccode\u003eSemantic_Query\u003c/code\u003e 트리거가 실행됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e속담 문장을 전달하여 쿼리의 임베딩을 얻기 위해 Hugging Face API를 호출합니다.\u003c/li\u003e\n\u003cli\u003e받은 임베딩 벡터를 문서 자체에 저장합니다 (query_embedding 필드).\u003c/li\u003e\n\u003cli\u003eMongoDB 집계 명령어를 통해 vector_search_index에서 벡터 검색을 실행합니다.\u003c/li\u003e\n\u003cli\u003e검색 결과를 문서 자체에 저장합니다 (answer 필드).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e쿼리를 테스트하려면 \"Collections\" 탭으로 이동하여 쿼리 컬렉션에 쿼리를 삽입하세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSematicSearch_30.png\" alt=\"2024-05-14-GettingStartedwithMongoDBAtlasforSematicSearch_30.png\"\u003e\u003c/p\u003e\n\u003cp\u003e여기 답변이 있어요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch_31.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e우리 질문과 가장 유사한 의미를 가진 속담 두 개는 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\"반짝이는 것이 모두 금은 아니다.\" 그리고 \"만능 재주꾼은 아무것도 제대로 할 수 없다.\"\u003c/p\u003e\n\u003cp\u003e정답이 잘 보입니다! 데이터셋과 쿼리를 실험해 볼 수 있습니다. 또한 OpenAI 텍스트 임베딩 API와 같은 다양한 임베딩 모델을 테스트하여 응답의 정확성을 평가할 수도 있습니다.\u003c/p\u003e\n\u003ch1\u003e참고 자료\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eMongoDB Atlas 매뉴얼\u003c/li\u003e\n\u003cli\u003eMongoDB Atlas 벡터 검색\u003c/li\u003e\n\u003cli\u003eMongoDB Atlas 검색 튜토리얼\u003c/li\u003e\n\u003cli\u003e일반적인 영어 속담\u003c/li\u003e\n\u003cli\u003eHugging Face 텍스트 임베딩 모델\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMongoDB에 대한 지식을 확장하고 싶다면 How MongoDB Works에 대한 제 논문을 살펴보세요.\u003c/p\u003e\n\u003cp\u003e제가 쓰는 이야기를 좋아해주시고 지원하고 싶으시다면, Medium 회원이 되어서 지원해주실 수 있어요. 매달 $5를 내면 Medium의 모든 이야기에 무제한 액세스할 수 있어요. 저의 추천 링크를 사용해서 가입하면, 작은 커미션을 받을 수 있어요. 고려해 주셔서 감사합니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-GettingStartedwithMongoDBAtlasforSemanticSearch"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>