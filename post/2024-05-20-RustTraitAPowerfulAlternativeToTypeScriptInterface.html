<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>러스트 트레이트 TypeScript 인터페이스의 강력한 대안 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="러스트 트레이트 TypeScript 인터페이스의 강력한 대안 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="러스트 트레이트 TypeScript 인터페이스의 강력한 대안 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface" data-gatsby-head="true"/><meta name="twitter:title" content="러스트 트레이트 TypeScript 인터페이스의 강력한 대안 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 21:42" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">러스트 트레이트 TypeScript 인터페이스의 강력한 대안</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="러스트 트레이트 TypeScript 인터페이스의 강력한 대안" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png" alt="RustTraitAPowerfulAlternativeToTypeScriptInterface"/></p>
<p>Rust은 인터페이스 개념을 갖고 있지만, 다른 프로그래밍 언어들과는 다르게 클래스와 함수의 동작을 지정하기 위해 인터페이스 키워드를 사용하지 않습니다. 대신, Rust의 가장 가까운 추상화 패턴은 트레이트입니다. 이러한 개념들은 많은 차이가 있지만, 둘 다 다중 가능한 구현을 다루는 문제를 해결합니다.</p>
<p>이 블로그 포스트에서는 TypeScript 코드 조각과 잠재적인 Rust 동등 코드를 비교하여 간단하고 유연하며 조립 가능한 코드를 어떻게 구현하는지를 보여줄 것입니다.</p>
<h1>선언</h1>
<div class="content-ad"></div>
<p>이는 데이터베이스에 문서 및 이미지를 저장하고 나열하는 프로젝트를 상상해 봅시다. 두 유형의 파일이 동일한 저장소에 저장되고 공통 특성을 공유하기 때문에 공통 정보를 공유하기 위해 인터페이스를 사용할 수 있습니다.</p>
<p>인터페이스를 사용하면 공통 속성 및 메소드를 정의하여 어느 유형의 파일과도 작업할 수 있는 코드를 쉽게 작성할 수 있습니다.</p>
<p>TypeScript에서는 이러한 인터페이스를 다음과 같이 정의할 수 있습니다:</p>
<pre><code class="hljs language-js">interface <span class="hljs-title class_">Entity</span> {
    <span class="hljs-attr">id</span>: string;
    <span class="hljs-attr">timestamp</span>: number;
}

interface <span class="hljs-title class_">Document</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Entity</span> {
    <span class="hljs-attr">revised</span>: boolean;
}

interface <span class="hljs-title class_">Image</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Entity</span> {
    <span class="hljs-attr">type</span>: string;
}
</code></pre>
<div class="content-ad"></div>
<p>Rust에서는 상속이 없기 때문에 가장 간단한 대응 구현은 타입을 복제해야 한다.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">Document</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">timestamp</span>: u64,
    <span class="hljs-attr">revised</span>: bool,
}

struct <span class="hljs-title class_">Image</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">timestamp</span>: u64,
    <span class="hljs-attr">mime_type</span>: <span class="hljs-title class_">String</span>,
}
</code></pre>
<h1>상속 및 제네릭</h1>
<p>이제 특정 문서 또는 이미지를 찾고 싶은 시나리오를 고려해보겠습니다. TypeScript에서는 다음과 같은 코드로 이를 수행할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> getDocument = (
 <span class="hljs-attr">id</span>: string,
 <span class="hljs-attr">documents</span>: <span class="hljs-title class_">Document</span>[]
): <span class="hljs-title class_">Document</span> | <span class="hljs-function"><span class="hljs-params">undefined</span> =&gt;</span>
 documents.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">{ id: docId }</span>) =&gt;</span> docId === id);

<span class="hljs-keyword">const</span> getImages = (
 <span class="hljs-attr">id</span>: string,
 <span class="hljs-attr">images</span>: <span class="hljs-title class_">Image</span>[]
): <span class="hljs-title class_">Image</span> | <span class="hljs-function"><span class="hljs-params">undefined</span> =&gt;</span>
 images.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">{ id: imageId }</span>) =&gt;</span> imageId === id);
</code></pre>
<p>하지만 두 함수가 동일한 인터페이스를 구현하기 때문에 중복을 피할 수 있습니다. 제네릭 함수를 추출하여 코드 중복을 피는 것이 좋습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> get = &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Entity</span>&gt;(
 <span class="hljs-attr">id</span>: string,
 <span class="hljs-attr">elements</span>: T[]
): T | <span class="hljs-function"><span class="hljs-params">undefined</span> =&gt;</span>
 elements.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">{ id: elementId }</span>) =&gt;</span> elementId === id);

<span class="hljs-keyword">const</span> getDocument = (
 <span class="hljs-attr">id</span>: string,
 <span class="hljs-attr">documents</span>: <span class="hljs-title class_">Document</span>[]
): <span class="hljs-title class_">Document</span> | <span class="hljs-function"><span class="hljs-params">undefined</span> =&gt;</span> get&lt;<span class="hljs-title class_">Document</span>&gt;(id, documents);

<span class="hljs-keyword">const</span> getImages = (
 <span class="hljs-attr">id</span>: string,
 <span class="hljs-attr">images</span>: <span class="hljs-title class_">Image</span>[]
): <span class="hljs-title class_">Image</span> | <span class="hljs-function"><span class="hljs-params">undefined</span> =&gt;</span> get&lt;<span class="hljs-title class_">Image</span>&gt;(id, images);
</code></pre>
<p>Rust에서 동일한 기능을 구현하는 경우 초기에는 코드를 중복해야 합니다:```</p>
<div class="content-ad"></div>
<pre><code class="hljs language-rs"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_document</span>(id: <span class="hljs-type">String</span>, documents: <span class="hljs-type">Vec</span>&lt;Document&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Document&gt; {
    documents.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">find</span>(|document| document.id == id)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_image</span>(id: <span class="hljs-type">String</span>, images: <span class="hljs-type">Vec</span>&lt;Image&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;Image&gt; {
    images.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">find</span>(|image| image.id == id)
}
</code></pre>
<p>위에서 보듯이 Rust 코드는 TypeScript 구현과 매우 유사합니다. 그러나 Rust에는 상속이나 인터페이스 키워드가 없기 때문에 중복을 피하기 위해 위의 패턴을 정확히 복제할 수 없습니다. 여기서 트레잇이 나옵니다.</p>
<p>이 특정 예에서 문서 및 이미지 두 객체 모두 공유하는 공통 특성은 ID를 사용하여 비교할 수 있다는 것입니다. 이것이 우리가 이러한 특성을 트레잇으로 선언하고 각 구조체에 대한 해당 구현을 제공할 수 있는 이유입니다.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Compare</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">compare</span>(&amp;<span class="hljs-keyword">self</span>, id: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>;
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Compare</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Document</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">compare</span>(&amp;<span class="hljs-keyword">self</span>, id: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> {
        <span class="hljs-keyword">self</span>.id == id
    }
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Compare</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Image</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">compare</span>(&amp;<span class="hljs-keyword">self</span>, id: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> {
        <span class="hljs-keyword">self</span>.id == id
    }
}
</code></pre>
<div class="content-ad"></div>
<p>마침내 러스트에서 공통 코드를 일반 함수로 추출할 수 있게 되었습니다. 이전에 TypeScript에서 했던 것처럼요.</p>
<pre><code class="hljs language-js">fn get&lt;<span class="hljs-attr">T</span>: <span class="hljs-title class_">Compare</span>&gt;(<span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Vec</span>&lt;T&gt;) -&gt; <span class="hljs-title class_">Option</span>&lt;T&gt; {
    elements.<span class="hljs-title function_">into_iter</span>().<span class="hljs-title function_">find</span>(|element| element.<span class="hljs-title function_">compare</span>(&amp;id))
}

fn <span class="hljs-title function_">get_document</span>(<span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">documents</span>: <span class="hljs-title class_">Vec</span>&lt;<span class="hljs-title class_">Document</span>&gt;) -&gt; <span class="hljs-title class_">Option</span>&lt;<span class="hljs-title class_">Document</span>&gt; {
    <span class="hljs-title function_">get</span>(id, documents)
}

fn <span class="hljs-title function_">get_image</span>(<span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">images</span>: <span class="hljs-title class_">Vec</span>&lt;<span class="hljs-title class_">Image</span>&gt;) -&gt; <span class="hljs-title class_">Option</span>&lt;<span class="hljs-title class_">Image</span>&gt; {
    <span class="hljs-title function_">get</span>(id, images)
}
</code></pre>
<p>또한 러스트에서는 트레이트를 “+” 기호로 결합하여 여러 공통 특성을 정의할 수 있습니다. 예를 들어:</p>
<pre><code class="hljs language-js">fn get&lt;<span class="hljs-attr">T</span>: <span class="hljs-title class_">Compare</span> + <span class="hljs-title class_">OtherTrait</span>&gt;(<span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Vec</span>&lt;T&gt;) -&gt; <span class="hljs-title class_">Option</span>&lt;T&gt; {
    elements
        .<span class="hljs-title function_">into_iter</span>()
        .<span class="hljs-title function_">find</span>(|element| element.<span class="hljs-title function_">compare</span>(&amp;id) &amp;&amp; element.<span class="hljs-title function_">other_trait</span>(&amp;id))
}
</code></pre>
<div class="content-ad"></div>
<p>이러한 패턴은 두 개의 매개변수가 동일한 구조체와 관련될 수 있기 때문에 객체를 비교하는 구현도 흥미로울 수 있습니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Compare</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sort</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> Ordering;
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Compare</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Document</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sort</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-&gt;</span> Ordering {
        <span class="hljs-keyword">self</span>.timestamp.<span class="hljs-title function_ invoke__">cmp</span>(&amp;other.timestamp)
    }
}
</code></pre>
<h1>결론</h1>
<p>우리는 트레이트가 제공할 수 있는 강력함의 일부만 살펴봤지만, 저와 같이 러스트를 탐색하고 있는 자바스크립트 개발자들에게 이 간단한 튜토리얼이 유용할 것이라고 희망합니다.</p>
<div class="content-ad"></div>
<p>무한한 여정이 시작됩니다
데이비드</p>
<p>더 많은 모험을 원하시면 트위터에서 제 계정을 팔로우해주세요.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"러스트 트레이트 TypeScript 인터페이스의 강력한 대안","description":"","date":"2024-05-20 21:42","slug":"2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface","content":"\n\n\n![RustTraitAPowerfulAlternativeToTypeScriptInterface](/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png)\n\nRust은 인터페이스 개념을 갖고 있지만, 다른 프로그래밍 언어들과는 다르게 클래스와 함수의 동작을 지정하기 위해 인터페이스 키워드를 사용하지 않습니다. 대신, Rust의 가장 가까운 추상화 패턴은 트레이트입니다. 이러한 개념들은 많은 차이가 있지만, 둘 다 다중 가능한 구현을 다루는 문제를 해결합니다.\n\n이 블로그 포스트에서는 TypeScript 코드 조각과 잠재적인 Rust 동등 코드를 비교하여 간단하고 유연하며 조립 가능한 코드를 어떻게 구현하는지를 보여줄 것입니다.\n\n# 선언\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 데이터베이스에 문서 및 이미지를 저장하고 나열하는 프로젝트를 상상해 봅시다. 두 유형의 파일이 동일한 저장소에 저장되고 공통 특성을 공유하기 때문에 공통 정보를 공유하기 위해 인터페이스를 사용할 수 있습니다.\n\n인터페이스를 사용하면 공통 속성 및 메소드를 정의하여 어느 유형의 파일과도 작업할 수 있는 코드를 쉽게 작성할 수 있습니다.\n\nTypeScript에서는 이러한 인터페이스를 다음과 같이 정의할 수 있습니다:\n\n```js\ninterface Entity {\n    id: string;\n    timestamp: number;\n}\n\ninterface Document extends Entity {\n    revised: boolean;\n}\n\ninterface Image extends Entity {\n    type: string;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRust에서는 상속이 없기 때문에 가장 간단한 대응 구현은 타입을 복제해야 한다.\n\n```js\nstruct Document {\n    id: String,\n    timestamp: u64,\n    revised: bool,\n}\n\nstruct Image {\n    id: String,\n    timestamp: u64,\n    mime_type: String,\n}\n```\n\n# 상속 및 제네릭\n\n이제 특정 문서 또는 이미지를 찾고 싶은 시나리오를 고려해보겠습니다. TypeScript에서는 다음과 같은 코드로 이를 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst getDocument = (\n id: string,\n documents: Document[]\n): Document | undefined =\u003e\n documents.find(({ id: docId }) =\u003e docId === id);\n\nconst getImages = (\n id: string,\n images: Image[]\n): Image | undefined =\u003e\n images.find(({ id: imageId }) =\u003e imageId === id);\n```\n\n하지만 두 함수가 동일한 인터페이스를 구현하기 때문에 중복을 피할 수 있습니다. 제네릭 함수를 추출하여 코드 중복을 피는 것이 좋습니다:\n\n```js\nconst get = \u003cT extends Entity\u003e(\n id: string,\n elements: T[]\n): T | undefined =\u003e\n elements.find(({ id: elementId }) =\u003e elementId === id);\n\nconst getDocument = (\n id: string,\n documents: Document[]\n): Document | undefined =\u003e get\u003cDocument\u003e(id, documents);\n\nconst getImages = (\n id: string,\n images: Image[]\n): Image | undefined =\u003e get\u003cImage\u003e(id, images);\n```\n\nRust에서 동일한 기능을 구현하는 경우 초기에는 코드를 중복해야 합니다:```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rs\nfn get_document(id: String, documents: Vec\u003cDocument\u003e) -\u003e Option\u003cDocument\u003e {\n    documents.into_iter().find(|document| document.id == id)\n}\n\nfn get_image(id: String, images: Vec\u003cImage\u003e) -\u003e Option\u003cImage\u003e {\n    images.into_iter().find(|image| image.id == id)\n}\n```\n\n위에서 보듯이 Rust 코드는 TypeScript 구현과 매우 유사합니다. 그러나 Rust에는 상속이나 인터페이스 키워드가 없기 때문에 중복을 피하기 위해 위의 패턴을 정확히 복제할 수 없습니다. 여기서 트레잇이 나옵니다.\n\n이 특정 예에서 문서 및 이미지 두 객체 모두 공유하는 공통 특성은 ID를 사용하여 비교할 수 있다는 것입니다. 이것이 우리가 이러한 특성을 트레잇으로 선언하고 각 구조체에 대한 해당 구현을 제공할 수 있는 이유입니다.\n\n```rs\ntrait Compare {\n    fn compare(\u0026self, id: \u0026str) -\u003e bool;\n}\n\nimpl Compare for Document {\n    fn compare(\u0026self, id: \u0026str) -\u003e bool {\n        self.id == id\n    }\n}\n\nimpl Compare for Image {\n    fn compare(\u0026self, id: \u0026str) -\u003e bool {\n        self.id == id\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내 러스트에서 공통 코드를 일반 함수로 추출할 수 있게 되었습니다. 이전에 TypeScript에서 했던 것처럼요.\n\n```js\nfn get\u003cT: Compare\u003e(id: String, elements: Vec\u003cT\u003e) -\u003e Option\u003cT\u003e {\n    elements.into_iter().find(|element| element.compare(\u0026id))\n}\n\nfn get_document(id: String, documents: Vec\u003cDocument\u003e) -\u003e Option\u003cDocument\u003e {\n    get(id, documents)\n}\n\nfn get_image(id: String, images: Vec\u003cImage\u003e) -\u003e Option\u003cImage\u003e {\n    get(id, images)\n}\n```\n\n또한 러스트에서는 트레이트를 “+” 기호로 결합하여 여러 공통 특성을 정의할 수 있습니다. 예를 들어:\n\n```js\nfn get\u003cT: Compare + OtherTrait\u003e(id: String, elements: Vec\u003cT\u003e) -\u003e Option\u003cT\u003e {\n    elements\n        .into_iter()\n        .find(|element| element.compare(\u0026id) \u0026\u0026 element.other_trait(\u0026id))\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 패턴은 두 개의 매개변수가 동일한 구조체와 관련될 수 있기 때문에 객체를 비교하는 구현도 흥미로울 수 있습니다.\n\n```rust\ntrait Compare {\n    fn sort(\u0026self, other: \u0026Self) -\u003e Ordering;\n}\n\nimpl Compare for Document {\n    fn sort(\u0026self, other: \u0026Self) -\u003e Ordering {\n        self.timestamp.cmp(\u0026other.timestamp)\n    }\n}\n```\n\n# 결론\n\n우리는 트레이트가 제공할 수 있는 강력함의 일부만 살펴봤지만, 저와 같이 러스트를 탐색하고 있는 자바스크립트 개발자들에게 이 간단한 튜토리얼이 유용할 것이라고 희망합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n무한한 여정이 시작됩니다\n데이비드\n\n더 많은 모험을 원하시면 트위터에서 제 계정을 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png"},"coverImage":"/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png\",\n        alt: \"RustTraitAPowerfulAlternativeToTypeScriptInterface\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rust은 인터페이스 개념을 갖고 있지만, 다른 프로그래밍 언어들과는 다르게 클래스와 함수의 동작을 지정하기 위해 인터페이스 키워드를 사용하지 않습니다. 대신, Rust의 가장 가까운 추상화 패턴은 트레이트입니다. 이러한 개념들은 많은 차이가 있지만, 둘 다 다중 가능한 구현을 다루는 문제를 해결합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 블로그 포스트에서는 TypeScript 코드 조각과 잠재적인 Rust 동등 코드를 비교하여 간단하고 유연하며 조립 가능한 코드를 어떻게 구현하는지를 보여줄 것입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"선언\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이는 데이터베이스에 문서 및 이미지를 저장하고 나열하는 프로젝트를 상상해 봅시다. 두 유형의 파일이 동일한 저장소에 저장되고 공통 특성을 공유하기 때문에 공통 정보를 공유하기 위해 인터페이스를 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"인터페이스를 사용하면 공통 속성 및 메소드를 정의하여 어느 유형의 파일과도 작업할 수 있는 코드를 쉽게 작성할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TypeScript에서는 이러한 인터페이스를 다음과 같이 정의할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"interface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Entity\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": string;\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"timestamp\"\n        }), \": number;\\n}\\n\\ninterface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Document\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Entity\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"revised\"\n        }), \": boolean;\\n}\\n\\ninterface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Image\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Entity\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type\"\n        }), \": string;\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rust에서는 상속이 없기 때문에 가장 간단한 대응 구현은 타입을 복제해야 한다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"struct \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Document\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"timestamp\"\n        }), \": u64,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"revised\"\n        }), \": bool,\\n}\\n\\nstruct \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Image\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"timestamp\"\n        }), \": u64,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"mime_type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \",\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"상속 및 제네릭\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 특정 문서 또는 이미지를 찾고 싶은 시나리오를 고려해보겠습니다. TypeScript에서는 다음과 같은 코드로 이를 수행할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" getDocument = (\\n \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": string,\\n \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"documents\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Document\"\n        }), \"[]\\n): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Document\"\n        }), \" | \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"undefined\"\n          }), \" =\u003e\"]\n        }), \"\\n documents.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"find\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"{ id: docId }\"\n          }), \") =\u003e\"]\n        }), \" docId === id);\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" getImages = (\\n \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": string,\\n \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"images\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Image\"\n        }), \"[]\\n): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Image\"\n        }), \" | \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"undefined\"\n          }), \" =\u003e\"]\n        }), \"\\n images.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"find\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"{ id: imageId }\"\n          }), \") =\u003e\"]\n        }), \" imageId === id);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 두 함수가 동일한 인터페이스를 구현하기 때문에 중복을 피할 수 있습니다. 제네릭 함수를 추출하여 코드 중복을 피는 것이 좋습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" get = \u003cT \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Entity\"\n        }), \"\u003e(\\n \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": string,\\n \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"elements\"\n        }), \": T[]\\n): T | \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"undefined\"\n          }), \" =\u003e\"]\n        }), \"\\n elements.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"find\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"{ id: elementId }\"\n          }), \") =\u003e\"]\n        }), \" elementId === id);\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" getDocument = (\\n \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": string,\\n \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"documents\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Document\"\n        }), \"[]\\n): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Document\"\n        }), \" | \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"undefined\"\n          }), \" =\u003e\"]\n        }), \" get\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Document\"\n        }), \"\u003e(id, documents);\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" getImages = (\\n \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": string,\\n \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"images\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Image\"\n        }), \"[]\\n): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Image\"\n        }), \" | \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"undefined\"\n          }), \" =\u003e\"]\n        }), \" get\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Image\"\n        }), \"\u003e(id, images);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rust에서 동일한 기능을 구현하는 경우 초기에는 코드를 중복해야 합니다:```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rs\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get_document\"\n        }), \"(id: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"String\"\n        }), \", documents: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Vec\"\n        }), \"\u003cDocument\u003e) \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Option\"\n        }), \"\u003cDocument\u003e {\\n    documents.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"into_iter\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"find\"\n        }), \"(|document| document.id == id)\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get_image\"\n        }), \"(id: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"String\"\n        }), \", images: \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Vec\"\n        }), \"\u003cImage\u003e) \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Option\"\n        }), \"\u003cImage\u003e {\\n    images.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"into_iter\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"find\"\n        }), \"(|image| image.id == id)\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위에서 보듯이 Rust 코드는 TypeScript 구현과 매우 유사합니다. 그러나 Rust에는 상속이나 인터페이스 키워드가 없기 때문에 중복을 피하기 위해 위의 패턴을 정확히 복제할 수 없습니다. 여기서 트레잇이 나옵니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 특정 예에서 문서 및 이미지 두 객체 모두 공유하는 공통 특성은 ID를 사용하여 비교할 수 있다는 것입니다. 이것이 우리가 이러한 특성을 트레잇으로 선언하고 각 구조체에 대한 해당 구현을 제공할 수 있는 이유입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rs\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"trait\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Compare\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"compare\"\n        }), \"(\u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", id: \u0026\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"str\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"bool\"\n        }), \";\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Compare\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Document\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"compare\"\n        }), \"(\u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", id: \u0026\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"str\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"bool\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".id == id\\n    }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Compare\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Image\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"compare\"\n        }), \"(\u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", id: \u0026\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"str\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"bool\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".id == id\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마침내 러스트에서 공통 코드를 일반 함수로 추출할 수 있게 되었습니다. 이전에 TypeScript에서 했던 것처럼요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn get\u003c\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"T\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Compare\"\n        }), \"\u003e(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"elements\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vec\"\n        }), \"\u003cT\u003e) -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Option\"\n        }), \"\u003cT\u003e {\\n    elements.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"into_iter\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"find\"\n        }), \"(|element| element.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"compare\"\n        }), \"(\u0026id))\\n}\\n\\nfn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get_document\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"documents\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vec\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Document\"\n        }), \"\u003e) -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Option\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Document\"\n        }), \"\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(id, documents)\\n}\\n\\nfn \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get_image\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"images\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vec\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Image\"\n        }), \"\u003e) -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Option\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Image\"\n        }), \"\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(id, images)\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한 러스트에서는 트레이트를 “+” 기호로 결합하여 여러 공통 특성을 정의할 수 있습니다. 예를 들어:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fn get\u003c\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"T\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Compare\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"OtherTrait\"\n        }), \"\u003e(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"elements\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Vec\"\n        }), \"\u003cT\u003e) -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Option\"\n        }), \"\u003cT\u003e {\\n    elements\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"into_iter\"\n        }), \"()\\n        .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"find\"\n        }), \"(|element| element.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"compare\"\n        }), \"(\u0026id) \u0026\u0026 element.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"other_trait\"\n        }), \"(\u0026id))\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 패턴은 두 개의 매개변수가 동일한 구조체와 관련될 수 있기 때문에 객체를 비교하는 구현도 흥미로울 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"trait\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Compare\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sort\"\n        }), \"(\u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", other: \u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"Self\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" Ordering;\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"impl\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Compare\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Document\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sort\"\n        }), \"(\u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \", other: \u0026\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"Self\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" Ordering {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"self\"\n        }), \".timestamp.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"cmp\"\n        }), \"(\u0026other.timestamp)\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 트레이트가 제공할 수 있는 강력함의 일부만 살펴봤지만, 저와 같이 러스트를 탐색하고 있는 자바스크립트 개발자들에게 이 간단한 튜토리얼이 유용할 것이라고 희망합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"무한한 여정이 시작됩니다\\n데이비드\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"더 많은 모험을 원하시면 트위터에서 제 계정을 팔로우해주세요.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>