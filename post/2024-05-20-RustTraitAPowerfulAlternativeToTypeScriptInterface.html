<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>러스트 트레이트 TypeScript 인터페이스의 강력한 대안 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="러스트 트레이트 TypeScript 인터페이스의 강력한 대안 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="러스트 트레이트 TypeScript 인터페이스의 강력한 대안 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface" data-gatsby-head="true"/><meta name="twitter:title" content="러스트 트레이트 TypeScript 인터페이스의 강력한 대안 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 21:42" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">러스트 트레이트 TypeScript 인터페이스의 강력한 대안</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="러스트 트레이트 TypeScript 인터페이스의 강력한 대안" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png" alt="RustTraitAPowerfulAlternativeToTypeScriptInterface"></p>
<p>Rust은 인터페이스 개념을 갖고 있지만, 다른 프로그래밍 언어들과는 다르게 클래스와 함수의 동작을 지정하기 위해 인터페이스 키워드를 사용하지 않습니다. 대신, Rust의 가장 가까운 추상화 패턴은 트레이트입니다. 이러한 개념들은 많은 차이가 있지만, 둘 다 다중 가능한 구현을 다루는 문제를 해결합니다.</p>
<p>이 블로그 포스트에서는 TypeScript 코드 조각과 잠재적인 Rust 동등 코드를 비교하여 간단하고 유연하며 조립 가능한 코드를 어떻게 구현하는지를 보여줄 것입니다.</p>
<h1>선언</h1>
<div class="content-ad"></div>
<p>이는 데이터베이스에 문서 및 이미지를 저장하고 나열하는 프로젝트를 상상해 봅시다. 두 유형의 파일이 동일한 저장소에 저장되고 공통 특성을 공유하기 때문에 공통 정보를 공유하기 위해 인터페이스를 사용할 수 있습니다.</p>
<p>인터페이스를 사용하면 공통 속성 및 메소드를 정의하여 어느 유형의 파일과도 작업할 수 있는 코드를 쉽게 작성할 수 있습니다.</p>
<p>TypeScript에서는 이러한 인터페이스를 다음과 같이 정의할 수 있습니다:</p>
<pre><code class="hljs language-js">interface <span class="hljs-title class_">Entity</span> {
    <span class="hljs-attr">id</span>: string;
    <span class="hljs-attr">timestamp</span>: number;
}

interface <span class="hljs-title class_">Document</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Entity</span> {
    <span class="hljs-attr">revised</span>: boolean;
}

interface <span class="hljs-title class_">Image</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Entity</span> {
    <span class="hljs-attr">type</span>: string;
}
</code></pre>
<div class="content-ad"></div>
<p>Rust에서는 상속이 없기 때문에 가장 간단한 대응 구현은 타입을 복제해야 한다.</p>
<pre><code class="hljs language-js">struct <span class="hljs-title class_">Document</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">timestamp</span>: u64,
    <span class="hljs-attr">revised</span>: bool,
}

struct <span class="hljs-title class_">Image</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">timestamp</span>: u64,
    <span class="hljs-attr">mime_type</span>: <span class="hljs-title class_">String</span>,
}
</code></pre>
<h1>상속 및 제네릭</h1>
<p>이제 특정 문서 또는 이미지를 찾고 싶은 시나리오를 고려해보겠습니다. TypeScript에서는 다음과 같은 코드로 이를 수행할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> getDocument = (
 <span class="hljs-attr">id</span>: string,
 <span class="hljs-attr">documents</span>: <span class="hljs-title class_">Document</span>[]
): <span class="hljs-title class_">Document</span> | <span class="hljs-function"><span class="hljs-params">undefined</span> =></span>
 documents.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">{ id: docId }</span>) =></span> docId === id);

<span class="hljs-keyword">const</span> getImages = (
 <span class="hljs-attr">id</span>: string,
 <span class="hljs-attr">images</span>: <span class="hljs-title class_">Image</span>[]
): <span class="hljs-title class_">Image</span> | <span class="hljs-function"><span class="hljs-params">undefined</span> =></span>
 images.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">{ id: imageId }</span>) =></span> imageId === id);
</code></pre>
<p>하지만 두 함수가 동일한 인터페이스를 구현하기 때문에 중복을 피할 수 있습니다. 제네릭 함수를 추출하여 코드 중복을 피는 것이 좋습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> get = &#x3C;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Entity</span>>(
 <span class="hljs-attr">id</span>: string,
 <span class="hljs-attr">elements</span>: T[]
): T | <span class="hljs-function"><span class="hljs-params">undefined</span> =></span>
 elements.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">{ id: elementId }</span>) =></span> elementId === id);

<span class="hljs-keyword">const</span> getDocument = (
 <span class="hljs-attr">id</span>: string,
 <span class="hljs-attr">documents</span>: <span class="hljs-title class_">Document</span>[]
): <span class="hljs-title class_">Document</span> | <span class="hljs-function"><span class="hljs-params">undefined</span> =></span> get&#x3C;<span class="hljs-title class_">Document</span>>(id, documents);

<span class="hljs-keyword">const</span> getImages = (
 <span class="hljs-attr">id</span>: string,
 <span class="hljs-attr">images</span>: <span class="hljs-title class_">Image</span>[]
): <span class="hljs-title class_">Image</span> | <span class="hljs-function"><span class="hljs-params">undefined</span> =></span> get&#x3C;<span class="hljs-title class_">Image</span>>(id, images);
</code></pre>
<p>Rust에서 동일한 기능을 구현하는 경우 초기에는 코드를 중복해야 합니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-rs"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_document</span>(id: <span class="hljs-type">String</span>, documents: <span class="hljs-type">Vec</span>&#x3C;Document>) <span class="hljs-punctuation">-></span> <span class="hljs-type">Option</span>&#x3C;Document> {
    documents.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">find</span>(|document| document.id == id)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_image</span>(id: <span class="hljs-type">String</span>, images: <span class="hljs-type">Vec</span>&#x3C;Image>) <span class="hljs-punctuation">-></span> <span class="hljs-type">Option</span>&#x3C;Image> {
    images.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">find</span>(|image| image.id == id)
}
</code></pre>
<p>위에서 보듯이 Rust 코드는 TypeScript 구현과 매우 유사합니다. 그러나 Rust에는 상속이나 인터페이스 키워드가 없기 때문에 중복을 피하기 위해 위의 패턴을 정확히 복제할 수 없습니다. 여기서 트레잇이 나옵니다.</p>
<p>이 특정 예에서 문서 및 이미지 두 객체 모두 공유하는 공통 특성은 ID를 사용하여 비교할 수 있다는 것입니다. 이것이 우리가 이러한 특성을 트레잇으로 선언하고 각 구조체에 대한 해당 구현을 제공할 수 있는 이유입니다.</p>
<pre><code class="hljs language-rs"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Compare</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">compare</span>(&#x26;<span class="hljs-keyword">self</span>, id: &#x26;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">bool</span>;
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Compare</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Document</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">compare</span>(&#x26;<span class="hljs-keyword">self</span>, id: &#x26;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">bool</span> {
        <span class="hljs-keyword">self</span>.id == id
    }
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Compare</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Image</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">compare</span>(&#x26;<span class="hljs-keyword">self</span>, id: &#x26;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-></span> <span class="hljs-type">bool</span> {
        <span class="hljs-keyword">self</span>.id == id
    }
}
</code></pre>
<div class="content-ad"></div>
<p>마침내 러스트에서 공통 코드를 일반 함수로 추출할 수 있게 되었습니다. 이전에 TypeScript에서 했던 것처럼요.</p>
<pre><code class="hljs language-js">fn get&#x3C;<span class="hljs-attr">T</span>: <span class="hljs-title class_">Compare</span>>(<span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Vec</span>&#x3C;T>) -> <span class="hljs-title class_">Option</span>&#x3C;T> {
    elements.<span class="hljs-title function_">into_iter</span>().<span class="hljs-title function_">find</span>(|element| element.<span class="hljs-title function_">compare</span>(&#x26;id))
}

fn <span class="hljs-title function_">get_document</span>(<span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">documents</span>: <span class="hljs-title class_">Vec</span>&#x3C;<span class="hljs-title class_">Document</span>>) -> <span class="hljs-title class_">Option</span>&#x3C;<span class="hljs-title class_">Document</span>> {
    <span class="hljs-title function_">get</span>(id, documents)
}

fn <span class="hljs-title function_">get_image</span>(<span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">images</span>: <span class="hljs-title class_">Vec</span>&#x3C;<span class="hljs-title class_">Image</span>>) -> <span class="hljs-title class_">Option</span>&#x3C;<span class="hljs-title class_">Image</span>> {
    <span class="hljs-title function_">get</span>(id, images)
}
</code></pre>
<p>또한 러스트에서는 트레이트를 “+” 기호로 결합하여 여러 공통 특성을 정의할 수 있습니다. 예를 들어:</p>
<pre><code class="hljs language-js">fn get&#x3C;<span class="hljs-attr">T</span>: <span class="hljs-title class_">Compare</span> + <span class="hljs-title class_">OtherTrait</span>>(<span class="hljs-attr">id</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">elements</span>: <span class="hljs-title class_">Vec</span>&#x3C;T>) -> <span class="hljs-title class_">Option</span>&#x3C;T> {
    elements
        .<span class="hljs-title function_">into_iter</span>()
        .<span class="hljs-title function_">find</span>(|element| element.<span class="hljs-title function_">compare</span>(&#x26;id) &#x26;&#x26; element.<span class="hljs-title function_">other_trait</span>(&#x26;id))
}
</code></pre>
<div class="content-ad"></div>
<p>이러한 패턴은 두 개의 매개변수가 동일한 구조체와 관련될 수 있기 때문에 객체를 비교하는 구현도 흥미로울 수 있습니다.</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Compare</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sort</span>(&#x26;<span class="hljs-keyword">self</span>, other: &#x26;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-></span> Ordering;
}

<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Compare</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Document</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sort</span>(&#x26;<span class="hljs-keyword">self</span>, other: &#x26;<span class="hljs-keyword">Self</span>) <span class="hljs-punctuation">-></span> Ordering {
        <span class="hljs-keyword">self</span>.timestamp.<span class="hljs-title function_ invoke__">cmp</span>(&#x26;other.timestamp)
    }
}
</code></pre>
<h1>결론</h1>
<p>우리는 트레이트가 제공할 수 있는 강력함의 일부만 살펴봤지만, 저와 같이 러스트를 탐색하고 있는 자바스크립트 개발자들에게 이 간단한 튜토리얼이 유용할 것이라고 희망합니다.</p>
<div class="content-ad"></div>
<p>무한한 여정이 시작됩니다
데이비드</p>
<p>더 많은 모험을 원하시면 트위터에서 제 계정을 팔로우해주세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"러스트 트레이트 TypeScript 인터페이스의 강력한 대안","description":"","date":"2024-05-20 21:42","slug":"2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface","content":"\n\n\n![RustTraitAPowerfulAlternativeToTypeScriptInterface](/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png)\n\nRust은 인터페이스 개념을 갖고 있지만, 다른 프로그래밍 언어들과는 다르게 클래스와 함수의 동작을 지정하기 위해 인터페이스 키워드를 사용하지 않습니다. 대신, Rust의 가장 가까운 추상화 패턴은 트레이트입니다. 이러한 개념들은 많은 차이가 있지만, 둘 다 다중 가능한 구현을 다루는 문제를 해결합니다.\n\n이 블로그 포스트에서는 TypeScript 코드 조각과 잠재적인 Rust 동등 코드를 비교하여 간단하고 유연하며 조립 가능한 코드를 어떻게 구현하는지를 보여줄 것입니다.\n\n# 선언\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 데이터베이스에 문서 및 이미지를 저장하고 나열하는 프로젝트를 상상해 봅시다. 두 유형의 파일이 동일한 저장소에 저장되고 공통 특성을 공유하기 때문에 공통 정보를 공유하기 위해 인터페이스를 사용할 수 있습니다.\n\n인터페이스를 사용하면 공통 속성 및 메소드를 정의하여 어느 유형의 파일과도 작업할 수 있는 코드를 쉽게 작성할 수 있습니다.\n\nTypeScript에서는 이러한 인터페이스를 다음과 같이 정의할 수 있습니다:\n\n```js\ninterface Entity {\n    id: string;\n    timestamp: number;\n}\n\ninterface Document extends Entity {\n    revised: boolean;\n}\n\ninterface Image extends Entity {\n    type: string;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRust에서는 상속이 없기 때문에 가장 간단한 대응 구현은 타입을 복제해야 한다.\n\n```js\nstruct Document {\n    id: String,\n    timestamp: u64,\n    revised: bool,\n}\n\nstruct Image {\n    id: String,\n    timestamp: u64,\n    mime_type: String,\n}\n```\n\n# 상속 및 제네릭\n\n이제 특정 문서 또는 이미지를 찾고 싶은 시나리오를 고려해보겠습니다. TypeScript에서는 다음과 같은 코드로 이를 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst getDocument = (\n id: string,\n documents: Document[]\n): Document | undefined =\u003e\n documents.find(({ id: docId }) =\u003e docId === id);\n\nconst getImages = (\n id: string,\n images: Image[]\n): Image | undefined =\u003e\n images.find(({ id: imageId }) =\u003e imageId === id);\n```\n\n하지만 두 함수가 동일한 인터페이스를 구현하기 때문에 중복을 피할 수 있습니다. 제네릭 함수를 추출하여 코드 중복을 피는 것이 좋습니다:\n\n```js\nconst get = \u003cT extends Entity\u003e(\n id: string,\n elements: T[]\n): T | undefined =\u003e\n elements.find(({ id: elementId }) =\u003e elementId === id);\n\nconst getDocument = (\n id: string,\n documents: Document[]\n): Document | undefined =\u003e get\u003cDocument\u003e(id, documents);\n\nconst getImages = (\n id: string,\n images: Image[]\n): Image | undefined =\u003e get\u003cImage\u003e(id, images);\n```\n\nRust에서 동일한 기능을 구현하는 경우 초기에는 코드를 중복해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rs\nfn get_document(id: String, documents: Vec\u003cDocument\u003e) -\u003e Option\u003cDocument\u003e {\n    documents.into_iter().find(|document| document.id == id)\n}\n\nfn get_image(id: String, images: Vec\u003cImage\u003e) -\u003e Option\u003cImage\u003e {\n    images.into_iter().find(|image| image.id == id)\n}\n```\n\n위에서 보듯이 Rust 코드는 TypeScript 구현과 매우 유사합니다. 그러나 Rust에는 상속이나 인터페이스 키워드가 없기 때문에 중복을 피하기 위해 위의 패턴을 정확히 복제할 수 없습니다. 여기서 트레잇이 나옵니다.\n\n이 특정 예에서 문서 및 이미지 두 객체 모두 공유하는 공통 특성은 ID를 사용하여 비교할 수 있다는 것입니다. 이것이 우리가 이러한 특성을 트레잇으로 선언하고 각 구조체에 대한 해당 구현을 제공할 수 있는 이유입니다.\n\n```rs\ntrait Compare {\n    fn compare(\u0026self, id: \u0026str) -\u003e bool;\n}\n\nimpl Compare for Document {\n    fn compare(\u0026self, id: \u0026str) -\u003e bool {\n        self.id == id\n    }\n}\n\nimpl Compare for Image {\n    fn compare(\u0026self, id: \u0026str) -\u003e bool {\n        self.id == id\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내 러스트에서 공통 코드를 일반 함수로 추출할 수 있게 되었습니다. 이전에 TypeScript에서 했던 것처럼요.\n\n```js\nfn get\u003cT: Compare\u003e(id: String, elements: Vec\u003cT\u003e) -\u003e Option\u003cT\u003e {\n    elements.into_iter().find(|element| element.compare(\u0026id))\n}\n\nfn get_document(id: String, documents: Vec\u003cDocument\u003e) -\u003e Option\u003cDocument\u003e {\n    get(id, documents)\n}\n\nfn get_image(id: String, images: Vec\u003cImage\u003e) -\u003e Option\u003cImage\u003e {\n    get(id, images)\n}\n```\n\n또한 러스트에서는 트레이트를 “+” 기호로 결합하여 여러 공통 특성을 정의할 수 있습니다. 예를 들어:\n\n```js\nfn get\u003cT: Compare + OtherTrait\u003e(id: String, elements: Vec\u003cT\u003e) -\u003e Option\u003cT\u003e {\n    elements\n        .into_iter()\n        .find(|element| element.compare(\u0026id) \u0026\u0026 element.other_trait(\u0026id))\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 패턴은 두 개의 매개변수가 동일한 구조체와 관련될 수 있기 때문에 객체를 비교하는 구현도 흥미로울 수 있습니다.\n\n```rust\ntrait Compare {\n    fn sort(\u0026self, other: \u0026Self) -\u003e Ordering;\n}\n\nimpl Compare for Document {\n    fn sort(\u0026self, other: \u0026Self) -\u003e Ordering {\n        self.timestamp.cmp(\u0026other.timestamp)\n    }\n}\n```\n\n# 결론\n\n우리는 트레이트가 제공할 수 있는 강력함의 일부만 살펴봤지만, 저와 같이 러스트를 탐색하고 있는 자바스크립트 개발자들에게 이 간단한 튜토리얼이 유용할 것이라고 희망합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n무한한 여정이 시작됩니다\n데이비드\n\n더 많은 모험을 원하시면 트위터에서 제 계정을 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png"},"coverImage":"/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface_0.png\" alt=\"RustTraitAPowerfulAlternativeToTypeScriptInterface\"\u003e\u003c/p\u003e\n\u003cp\u003eRust은 인터페이스 개념을 갖고 있지만, 다른 프로그래밍 언어들과는 다르게 클래스와 함수의 동작을 지정하기 위해 인터페이스 키워드를 사용하지 않습니다. 대신, Rust의 가장 가까운 추상화 패턴은 트레이트입니다. 이러한 개념들은 많은 차이가 있지만, 둘 다 다중 가능한 구현을 다루는 문제를 해결합니다.\u003c/p\u003e\n\u003cp\u003e이 블로그 포스트에서는 TypeScript 코드 조각과 잠재적인 Rust 동등 코드를 비교하여 간단하고 유연하며 조립 가능한 코드를 어떻게 구현하는지를 보여줄 것입니다.\u003c/p\u003e\n\u003ch1\u003e선언\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이는 데이터베이스에 문서 및 이미지를 저장하고 나열하는 프로젝트를 상상해 봅시다. 두 유형의 파일이 동일한 저장소에 저장되고 공통 특성을 공유하기 때문에 공통 정보를 공유하기 위해 인터페이스를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e인터페이스를 사용하면 공통 속성 및 메소드를 정의하여 어느 유형의 파일과도 작업할 수 있는 코드를 쉽게 작성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eTypeScript에서는 이러한 인터페이스를 다음과 같이 정의할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einterface \u003cspan class=\"hljs-title class_\"\u003eEntity\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: string;\n    \u003cspan class=\"hljs-attr\"\u003etimestamp\u003c/span\u003e: number;\n}\n\ninterface \u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEntity\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003erevised\u003c/span\u003e: boolean;\n}\n\ninterface \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEntity\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: string;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eRust에서는 상속이 없기 때문에 가장 간단한 대응 구현은 타입을 복제해야 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003estruct \u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003etimestamp\u003c/span\u003e: u64,\n    \u003cspan class=\"hljs-attr\"\u003erevised\u003c/span\u003e: bool,\n}\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003etimestamp\u003c/span\u003e: u64,\n    \u003cspan class=\"hljs-attr\"\u003emime_type\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e상속 및 제네릭\u003c/h1\u003e\n\u003cp\u003e이제 특정 문서 또는 이미지를 찾고 싶은 시나리오를 고려해보겠습니다. TypeScript에서는 다음과 같은 코드로 이를 수행할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getDocument = (\n \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: string,\n \u003cspan class=\"hljs-attr\"\u003edocuments\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e[]\n): \u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e | \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eundefined\u003c/span\u003e =\u003e\u003c/span\u003e\n documents.\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ id: docId }\u003c/span\u003e) =\u003e\u003c/span\u003e docId === id);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getImages = (\n \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: string,\n \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e[]\n): \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e | \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eundefined\u003c/span\u003e =\u003e\u003c/span\u003e\n images.\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ id: imageId }\u003c/span\u003e) =\u003e\u003c/span\u003e imageId === id);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 두 함수가 동일한 인터페이스를 구현하기 때문에 중복을 피할 수 있습니다. 제네릭 함수를 추출하여 코드 중복을 피는 것이 좋습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e get = \u0026#x3C;T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEntity\u003c/span\u003e\u003e(\n \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: string,\n \u003cspan class=\"hljs-attr\"\u003eelements\u003c/span\u003e: T[]\n): T | \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eundefined\u003c/span\u003e =\u003e\u003c/span\u003e\n elements.\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ id: elementId }\u003c/span\u003e) =\u003e\u003c/span\u003e elementId === id);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getDocument = (\n \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: string,\n \u003cspan class=\"hljs-attr\"\u003edocuments\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e[]\n): \u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e | \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eundefined\u003c/span\u003e =\u003e\u003c/span\u003e get\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e\u003e(id, documents);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getImages = (\n \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: string,\n \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e[]\n): \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e | \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eundefined\u003c/span\u003e =\u003e\u003c/span\u003e get\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e\u003e(id, images);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRust에서 동일한 기능을 구현하는 경우 초기에는 코드를 중복해야 합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rs\"\u003e\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_document\u003c/span\u003e(id: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e, documents: \u003cspan class=\"hljs-type\"\u003eVec\u003c/span\u003e\u0026#x3C;Document\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eOption\u003c/span\u003e\u0026#x3C;Document\u003e {\n    documents.\u003cspan class=\"hljs-title function_ invoke__\"\u003einto_iter\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003efind\u003c/span\u003e(|document| document.id == id)\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_image\u003c/span\u003e(id: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e, images: \u003cspan class=\"hljs-type\"\u003eVec\u003c/span\u003e\u0026#x3C;Image\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eOption\u003c/span\u003e\u0026#x3C;Image\u003e {\n    images.\u003cspan class=\"hljs-title function_ invoke__\"\u003einto_iter\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003efind\u003c/span\u003e(|image| image.id == id)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위에서 보듯이 Rust 코드는 TypeScript 구현과 매우 유사합니다. 그러나 Rust에는 상속이나 인터페이스 키워드가 없기 때문에 중복을 피하기 위해 위의 패턴을 정확히 복제할 수 없습니다. 여기서 트레잇이 나옵니다.\u003c/p\u003e\n\u003cp\u003e이 특정 예에서 문서 및 이미지 두 객체 모두 공유하는 공통 특성은 ID를 사용하여 비교할 수 있다는 것입니다. 이것이 우리가 이러한 특성을 트레잇으로 선언하고 각 구조체에 대한 해당 구현을 제공할 수 있는 이유입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rs\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCompare\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecompare\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, id: \u0026#x26;\u003cspan class=\"hljs-type\"\u003estr\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCompare\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecompare\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, id: \u0026#x26;\u003cspan class=\"hljs-type\"\u003estr\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.id == id\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCompare\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecompare\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, id: \u0026#x26;\u003cspan class=\"hljs-type\"\u003estr\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ebool\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.id == id\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e마침내 러스트에서 공통 코드를 일반 함수로 추출할 수 있게 되었습니다. 이전에 TypeScript에서 했던 것처럼요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efn get\u0026#x3C;\u003cspan class=\"hljs-attr\"\u003eT\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCompare\u003c/span\u003e\u003e(\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eelements\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eVec\u003c/span\u003e\u0026#x3C;T\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eOption\u003c/span\u003e\u0026#x3C;T\u003e {\n    elements.\u003cspan class=\"hljs-title function_\"\u003einto_iter\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(|element| element.\u003cspan class=\"hljs-title function_\"\u003ecompare\u003c/span\u003e(\u0026#x26;id))\n}\n\nfn \u003cspan class=\"hljs-title function_\"\u003eget_document\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edocuments\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eVec\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eOption\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(id, documents)\n}\n\nfn \u003cspan class=\"hljs-title function_\"\u003eget_image\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eimages\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eVec\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eOption\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(id, images)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한 러스트에서는 트레이트를 “+” 기호로 결합하여 여러 공통 특성을 정의할 수 있습니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efn get\u0026#x3C;\u003cspan class=\"hljs-attr\"\u003eT\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCompare\u003c/span\u003e + \u003cspan class=\"hljs-title class_\"\u003eOtherTrait\u003c/span\u003e\u003e(\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eelements\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eVec\u003c/span\u003e\u0026#x3C;T\u003e) -\u003e \u003cspan class=\"hljs-title class_\"\u003eOption\u003c/span\u003e\u0026#x3C;T\u003e {\n    elements\n        .\u003cspan class=\"hljs-title function_\"\u003einto_iter\u003c/span\u003e()\n        .\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(|element| element.\u003cspan class=\"hljs-title function_\"\u003ecompare\u003c/span\u003e(\u0026#x26;id) \u0026#x26;\u0026#x26; element.\u003cspan class=\"hljs-title function_\"\u003eother_trait\u003c/span\u003e(\u0026#x26;id))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이러한 패턴은 두 개의 매개변수가 동일한 구조체와 관련될 수 있기 때문에 객체를 비교하는 구현도 흥미로울 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCompare\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, other: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Ordering;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eimpl\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCompare\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDocument\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, other: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003eSelf\u003c/span\u003e) \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e Ordering {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.timestamp.\u003cspan class=\"hljs-title function_ invoke__\"\u003ecmp\u003c/span\u003e(\u0026#x26;other.timestamp)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e우리는 트레이트가 제공할 수 있는 강력함의 일부만 살펴봤지만, 저와 같이 러스트를 탐색하고 있는 자바스크립트 개발자들에게 이 간단한 튜토리얼이 유용할 것이라고 희망합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e무한한 여정이 시작됩니다\n데이비드\u003c/p\u003e\n\u003cp\u003e더 많은 모험을 원하시면 트위터에서 제 계정을 팔로우해주세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-RustTraitAPowerfulAlternativeToTypeScriptInterface"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>