<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity" data-gatsby-head="true"/><meta name="twitter:title" content="더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 14:16" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_buildManifest.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png" alt="Chrome DevTools JavaScript Debugging Features for Better Productivity"/></p>
<p>소프트웨어 버그는 소프트웨어 프로그램에서 예상치 못한 또는 잘못된 동작을 가리킵니다. 다른 소프트웨어 유형과 마찬가지로 웹 앱에도 버그가 포함될 수 있습니다. 웹 앱의 버그는 해당 웹 앱의 품질을 버그 심각도에 따라 저하시킬 수 있습니다. 몇 가지 심각한 소프트웨어 버그는 전체 웹 앱을 영향을 미치며 사용자 인터랙션 흐름을 망가뜨릴 수 있습니다. 한편 일부 미세한 소프트웨어 버그는 사용자 흐름의 일부를 영향을 미치며 대안 흐름으로 교체 가능할 수 있습니다. 잘 알려진 디버깅 프로세스는 웹 개발자가 웹 앱에서 버그를 제거하여 품질을 회복하는 데 도움을 줍니다.</p>
<p>현대 웹 브라우저는 기능이 풍부한 웹 개발 환경으로서, JavaScript 소스 코드에서 버그를 감지하기 위한 디버깅 기능을 제공합니다. 예를 들어, Google Chrome은 제품적인 JavaScript 디버깅을 위해 DevTools 패널을 제공합니다. DevTools은 표준 중단점을 기반으로 한 동적 코드 분석 및 변수 감시, 스택 프레임 분석기, 리스너 검사자 등과 같은 고급 디버깅 기능을 제공합니다. DevTools는 브라우저에서 로드된 베니라 JavaScript를 디버그할 수 있을 뿐만 아니라 Chrome DevTools 프로토콜을 통해 TypeScript, Node.js, Deno 및 React Native 앱을 디버그할 수 있도록 지원합니다. 게다가 대부분의 프론트엔드 프레임워크/라이브러리는 디버깅 경험을 향상하기 위한 DevTools 확장을 제공합니다(예: React Developer Tools).</p>
<p>생산성 중심의 Chrome DevTools 기능을 파악하면 JavaScript 소스 코드를 빠르게 디버그할 수 있고 버그 수정을 생산적으로 진행할 수 있습니다. 이 글에서는 JavaScript 디버깅 생산성을 높일 수 있는 DevTools 기능에 대해 설명하겠습니다. 이러한 DevTools 기능을 연습하고 디버깅 방법을 찾는 대신 디버깅에만 집중하세요!</p>
<h1>변수와 표현식 감시하기</h1>
<p>디버거 브레이크포인트가 코드 실행을 중단할 때마다, 마우스를 가져다 대면 JavaScript 변수를 살펴볼 수 있습니다. 이 기술을 사용하여 디버깅 중에 원자값과 객체를 살펴볼 수 있지만, 한꺼번에 여러 변수를 감시해야 한다면 시간이 많이 소요될 수 있습니다. 디버깅 중 감시해야 하는 변수와 표현식을 평가해야 한다면 더 어려워질 수 있습니다. 이런 경우에는 디버거 코드 뷰와 콘솔을 자주 왔다갔다해야 합니다.</p>
<p>DevTools에서는 브레이크포인트를 기반으로 변수와 표현식을 감시하거나 브레이크포인트에서 멈추지 않고 수동으로 업데이트할 수 있습니다. 다음 코드 조각을 살펴보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> m = <span class="hljs-number">0</span>;
<span class="hljs-keyword">let</span> s = <span class="hljs-number">0</span>;

<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
  s++;
  <span class="hljs-keyword">if</span>(s === <span class="hljs-number">60</span>) {
    m++;
    s = <span class="hljs-number">0</span>;
  }
}, <span class="hljs-number">1000</span>);
</code></pre>
<p>위 코드는 두 변수를 사용해 간단한 초-분 타이머를 구현한 것입니다. 다음과 같이 새로운 감시자를 추가하고 중단점을 설정하여 m 및 s 변수를 확인할 수 있습니다:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*T23NrZm73SydEAZjai8NVQ.gif" alt="이미지"/></p>
<p>매 초마다 실행을 멈추는 중단점이 있기 때문에 중단점을 제거하고 대신 새로고침 버튼을 누를 수 있습니다. 또한 감시자 레코드로 표현식을 평가할 수도 있습니다. 예를 들어 다음 샘플 표현식이 선행 0이 있는 타이머 값을 출력하는 방법을 확인해보세요:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*4f9JCOR17w3M4-Tp82Q92w.gif" alt="이미지"/></p>
<h1>콘솔에서 디버거 컨텍스트 사용하기</h1>
<p>우리는 객체 속성을 검사하기 위해 마우스를 호버하고 관찰자를 설정하는 방식으로 사용할 수 있습니다. 그러나 어떤 상황에서는 콘솔에서 자동 완성을 지원하는 상태에서 객체 메서드를 트리거하고 객체 속성을 검사해야 할 때가 있습니다. 개발 도구는 이 요구 사항을 해결하기 위해 콘솔의 범위를 현재 중단점으로 변경합니다. d 객체의 getMilliseconds() 메서드의 반환 값을 확인해야 한다고 가정해 봅시다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getMagicDate</span>(<span class="hljs-params">d</span>) {
  <span class="hljs-keyword">if</span>(d.<span class="hljs-title function_">getDate</span>() % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) {
    d.<span class="hljs-title function_">setDate</span>(d.<span class="hljs-title function_">getDate</span>() + <span class="hljs-number">2</span>);
  }
  <span class="hljs-keyword">else</span> {
    d.<span class="hljs-title function_">setMonth</span>(d.<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>);
  }
  <span class="hljs-keyword">return</span> d;
}

<span class="hljs-title function_">getMagicDate</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());
</code></pre>
<p>먼저 중단점을 설정하고 코드 실행 프로세스를 중단해야 합니다. 그런 다음, 콘솔 서랍을 열기 위해 escape 키를 누르고 실행할 메서드를 입력하세요:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*yErxg7PWPkt1nBHar2Z3Mw.gif" alt="Live Expressions"/></p>
<h1>중단점 없이 실시간 표현식 만들기</h1>
<p>첫 번째 예제에서는 위쳐(watchers)를 사용하여 샘플 프로그램의 몇 가지 변수를 조사했습니다. 표현식의 업데이트된 결과를 보려면 중단점에 멈춰야했거나 새로 고침 버튼을 눌러야 했습니다. DevTools를 사용하면 콘솔에서 실시간 표현식을 만들 수 있으므로 중단점을 사용하지 않고도 원하는 표현식의 업데이트된 결과를 볼 수 있습니다.</p>
<p>이 시나리오에 대해 이전에 사용한 코드를 사용하겠습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> m = <span class="hljs-number">0</span>;
<span class="hljs-keyword">let</span> s = <span class="hljs-number">0</span>;

<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
  s++;
  <span class="hljs-keyword">if</span> (s === <span class="hljs-number">60</span>) {
    m++;
    s = <span class="hljs-number">0</span>;
  }

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${m.toString().padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;0&#x27;</span>)}</span>:<span class="hljs-subst">${s.toString().padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;0&#x27;</span>)}</span>`</span>);
}, <span class="hljs-number">1000</span>);
</code></pre>
<h1>마지막 콘솔 결과 및 선택된 요소에 액세스하는 방법</h1>
<p>자동화를 위해 Bash 스크립팅을 사용하는 경우, 마지막 완료된 프로세스의 종료 코드를 가져오는 방법을 알고 있을 것입니다. $? 특수 Bash 매개변수가 도움이 됩니다. DevTools도 자동화 스크립팅에 존재하는 유사한 기능을 제공하여 디버깅 생산성을 향상시키려고 노력합니다. 콘솔에서 여러 식을 평가할 때, 사전 정의된 $_ 유틸리티 변수를 사용하여 마지막 표현식의 결과를 얻을 수 있습니다. 이는 디버깅 중에 테스트 데이터를 작성할 때 매우 유용합니다. 다음 예제를 살펴보세요:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*emqAYbt1vrKkcYS8aWP0Yw.gif" alt="예제"/></p>
<p>위 예에서는 $_ 유틸리티 변수를 사용하여 이전에 생성된 JavaScript 객체에 액세스합니다.</p>
<p>우리는 모두 포커스가 있는 요소를 반환하는 document.activeElement 속성에 대해 알고 있습니다. 그렇다면 DevTools Inspector에서 선택한 DOM 요소에 대한 참조를 얻어야 한다면 어떻게 할까요? $0 유틸리티 변수가 도와줍니다:</p>
<img src="https://miro.medium.com/v2/resize:fit:1400/1*rGXZoHl7e_qNtS9dCIG8Nw.gif"/>
<p>공식 Chrome 콘솔 유틸리티 참조를 읽고 JavaScript 디버깅 중에 콘솔에서 사용할 수 있는 더 많은 단축 변수와 함수에 대해 알아보세요.</p>
<p>다음 이야기는 여러분에게 JavaScript의 최신 단축 구문에 대해 가르쳐줍니다:</p>
<h1>이벤트 리스너 브레이크포인트 설정하기</h1>
<p>풀리피처가 갖춰진 개발 환경인 웹 브라우저는 다양한 이벤트를 제공하여 개발자들이 고품질이고 사용자 친화적인 웹 앱을 개발할 수 있도록 도와줍니다. 각 브라우저 API는 일반적으로 개발자들을 위한 이벤트 기반 상호작용 모델을 제공하며, 그에 따라 개발자들은 JavaScript 코드베이스에서 이벤트 리스너 콜백을 붙이곤 합니다. 디버깅을 위해 이벤트 리스너에 대한 브레이크포인트를 설정하려면 알려진 쉽고 간단한 방법이 있습니다.</p>
<p>다음 코드를 살펴보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);
<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;

btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  btn.<span class="hljs-property">innerText</span> = <span class="hljs-string">`Clicked <span class="hljs-subst">${++count}</span> times`</span>;
});
</code></pre>
<p>우리는 쉽게 이벤트 리스너를 중단점으로 설정할 수 있습니다. 왜냐하면 어디에 작성되어 있는지 알기 때문이죠. 그런데 만약 많은 이벤트 리스너가 있는 낯선한 코드베이스를 디버깅해야 한다면 어떨까요? DevTools는 이벤트 이름을 기반으로 중단점을 설정할 수 있는 방법을 제공합니다. 다음 예시를 살펴보세요:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*jWE3Q8yaZtfjoU-OsZK3EQ.gif" alt="이미지"/></p>
<p>위의 클릭 리스너 중단점은 코드 실행을 중지하고 자동으로 리스너 콜백으로 이동합니다. 비슷하게, XHR, worker, clipboard, keyboard 등의 이벤트에 대한 중단점을 설정하고 이벤트 리스너 등록을 찾을 수 있습니다.</p>
<p>다음 이야기에서는 모든 현대 웹 개발자가 알아야 할 새로운 브라우저 이벤트 및 API에 대해 설명합니다:</p>
<h1>네트워크 요청 중단점 사용하기</h1>
<p>XHR 이벤트 중단점을 사용하여 네트워크 요청을 감지할 수 있습니다. 이를 통해 네트워크 관련 JavaScript 코드에 수동으로 중단점을 설정할 필요 없이 코드 실행이 모든 XHR 이벤트에서 중단되는 것이 아니라 특정 네트워크 요청에만 관심이 있는 경우에도 이를 감지할 수 있습니다. 개발자 도구는 URL 필터를 기반으로 네트워크 요청을 감지하는 소스 탭에 다른 섹션을 제공합니다. 예를 들어, 앱이 https://api.example.com URL에 대한 요청을 보내는 소스 코드 라인을 찾아야 한다고 가정해봅시다. 다음과 같이 XHR/fetch 중단점을 설정할 수 있습니다:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*vg4xUAWXbRv7vJrAYQWq1w.gif" alt="네트워크 요청 중단점"/></p>
<p>이 접근법을 사용하면 특정 네트워크 요청이 어디서 트리거되었는지, 코드를 검사하거나 네트워크 탭에서 시간을 소비하지 않고 파악할 수 있습니다. 위 미리보기에서처럼, 개발자 도구는 네트워크 요청을 전송한 코드 세그먼트를 자동으로 표시하므로 필요한 경우 새로운 중단점을 설정하고 결과를 추가 검사할 수 있습니다.</p>
<h1>호출 스택 검사</h1>
<p>개발자들은 종종 전체 소스 코드를 여러 JavaScript 함수로 분해하여 코드의 가독성과 품질을 향상시킵니다. 또한 이러한 함수들을 여러 모듈로 정리하여 관리 가능성을 더욱 향상시킵니다. 따라서 특정 웹 앱에서 사용자가 작업을 호출할 때마다 JavaScript 엔진의 호출 스택에서 여러 JavaScript 함수가 실행됩니다. 이러한 스택 프레임은 입력 매개변수와 비공개 변수를 포함하는 함수 스코프를 보유합니다. 재귀 알고리즘 디버깅 및 함수 호출 스택 분석을 위해 스택 프레임을 검사하는 것이 중요합니다.</p>
<p>스택 프레임 분석기를 사용하는 것은 매우 쉬운데 - debugger 키워드를 사용하고 호출 스택 세그먼트를 열고 각 스택 프레임의 스코프를 검사할 수 있습니다. 아래 미리보기에서 보여지는 것과 같습니다:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*8OX_qVhdz4UtapF2jUzV8A.gif" alt="image"/></p>
<p>호출 스택은 이론적인 스택 데이터 구조를 사용합니다. 모든 일반적인 데이터 구조를 알면 프로그래밍 기술이 향상되며, 다음 이야기에서 설명했습니다:</p>
<p>읽어주셔서 감사합니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"더 나은 생산성을 위한 Chrome DevTools 자바스크립트 디버깅 기능들","description":"","date":"2024-05-14 14:16","slug":"2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity","content":"\n\n![Chrome DevTools JavaScript Debugging Features for Better Productivity](/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png)\n\n소프트웨어 버그는 소프트웨어 프로그램에서 예상치 못한 또는 잘못된 동작을 가리킵니다. 다른 소프트웨어 유형과 마찬가지로 웹 앱에도 버그가 포함될 수 있습니다. 웹 앱의 버그는 해당 웹 앱의 품질을 버그 심각도에 따라 저하시킬 수 있습니다. 몇 가지 심각한 소프트웨어 버그는 전체 웹 앱을 영향을 미치며 사용자 인터랙션 흐름을 망가뜨릴 수 있습니다. 한편 일부 미세한 소프트웨어 버그는 사용자 흐름의 일부를 영향을 미치며 대안 흐름으로 교체 가능할 수 있습니다. 잘 알려진 디버깅 프로세스는 웹 개발자가 웹 앱에서 버그를 제거하여 품질을 회복하는 데 도움을 줍니다.\n\n현대 웹 브라우저는 기능이 풍부한 웹 개발 환경으로서, JavaScript 소스 코드에서 버그를 감지하기 위한 디버깅 기능을 제공합니다. 예를 들어, Google Chrome은 제품적인 JavaScript 디버깅을 위해 DevTools 패널을 제공합니다. DevTools은 표준 중단점을 기반으로 한 동적 코드 분석 및 변수 감시, 스택 프레임 분석기, 리스너 검사자 등과 같은 고급 디버깅 기능을 제공합니다. DevTools는 브라우저에서 로드된 베니라 JavaScript를 디버그할 수 있을 뿐만 아니라 Chrome DevTools 프로토콜을 통해 TypeScript, Node.js, Deno 및 React Native 앱을 디버그할 수 있도록 지원합니다. 게다가 대부분의 프론트엔드 프레임워크/라이브러리는 디버깅 경험을 향상하기 위한 DevTools 확장을 제공합니다(예: React Developer Tools).\n\n생산성 중심의 Chrome DevTools 기능을 파악하면 JavaScript 소스 코드를 빠르게 디버그할 수 있고 버그 수정을 생산적으로 진행할 수 있습니다. 이 글에서는 JavaScript 디버깅 생산성을 높일 수 있는 DevTools 기능에 대해 설명하겠습니다. 이러한 DevTools 기능을 연습하고 디버깅 방법을 찾는 대신 디버깅에만 집중하세요!\n\n\n\n# 변수와 표현식 감시하기\n\n디버거 브레이크포인트가 코드 실행을 중단할 때마다, 마우스를 가져다 대면 JavaScript 변수를 살펴볼 수 있습니다. 이 기술을 사용하여 디버깅 중에 원자값과 객체를 살펴볼 수 있지만, 한꺼번에 여러 변수를 감시해야 한다면 시간이 많이 소요될 수 있습니다. 디버깅 중 감시해야 하는 변수와 표현식을 평가해야 한다면 더 어려워질 수 있습니다. 이런 경우에는 디버거 코드 뷰와 콘솔을 자주 왔다갔다해야 합니다.\n\nDevTools에서는 브레이크포인트를 기반으로 변수와 표현식을 감시하거나 브레이크포인트에서 멈추지 않고 수동으로 업데이트할 수 있습니다. 다음 코드 조각을 살펴보세요:\n\n```js\nlet m = 0;\nlet s = 0;\n\nsetInterval(() =\u003e {\n  s++;\n  if(s === 60) {\n    m++;\n    s = 0;\n  }\n}, 1000);\n```\n\n\n\n위 코드는 두 변수를 사용해 간단한 초-분 타이머를 구현한 것입니다. 다음과 같이 새로운 감시자를 추가하고 중단점을 설정하여 m 및 s 변수를 확인할 수 있습니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*T23NrZm73SydEAZjai8NVQ.gif)\n\n매 초마다 실행을 멈추는 중단점이 있기 때문에 중단점을 제거하고 대신 새로고침 버튼을 누를 수 있습니다. 또한 감시자 레코드로 표현식을 평가할 수도 있습니다. 예를 들어 다음 샘플 표현식이 선행 0이 있는 타이머 값을 출력하는 방법을 확인해보세요:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*4f9JCOR17w3M4-Tp82Q92w.gif)\n\n\n\n# 콘솔에서 디버거 컨텍스트 사용하기\n\n우리는 객체 속성을 검사하기 위해 마우스를 호버하고 관찰자를 설정하는 방식으로 사용할 수 있습니다. 그러나 어떤 상황에서는 콘솔에서 자동 완성을 지원하는 상태에서 객체 메서드를 트리거하고 객체 속성을 검사해야 할 때가 있습니다. 개발 도구는 이 요구 사항을 해결하기 위해 콘솔의 범위를 현재 중단점으로 변경합니다. d 객체의 getMilliseconds() 메서드의 반환 값을 확인해야 한다고 가정해 봅시다:\n\n```js\nfunction getMagicDate(d) {\n  if(d.getDate() % 2 === 0) {\n    d.setDate(d.getDate() + 2);\n  }\n  else {\n    d.setMonth(d.getMonth() + 1);\n  }\n  return d;\n}\n\ngetMagicDate(new Date());\n```\n\n먼저 중단점을 설정하고 코드 실행 프로세스를 중단해야 합니다. 그런 다음, 콘솔 서랍을 열기 위해 escape 키를 누르고 실행할 메서드를 입력하세요:\n\n\n\n![Live Expressions](https://miro.medium.com/v2/resize:fit:1400/1*yErxg7PWPkt1nBHar2Z3Mw.gif)\n\n# 중단점 없이 실시간 표현식 만들기\n\n첫 번째 예제에서는 위쳐(watchers)를 사용하여 샘플 프로그램의 몇 가지 변수를 조사했습니다. 표현식의 업데이트된 결과를 보려면 중단점에 멈춰야했거나 새로 고침 버튼을 눌러야 했습니다. DevTools를 사용하면 콘솔에서 실시간 표현식을 만들 수 있으므로 중단점을 사용하지 않고도 원하는 표현식의 업데이트된 결과를 볼 수 있습니다.\n\n이 시나리오에 대해 이전에 사용한 코드를 사용하겠습니다:\n\n\n\n```js\nlet m = 0;\nlet s = 0;\n\nsetInterval(() =\u003e {\n  s++;\n  if (s === 60) {\n    m++;\n    s = 0;\n  }\n\n  console.log(`${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`);\n}, 1000);\n```\n\n\n\n# 마지막 콘솔 결과 및 선택된 요소에 액세스하는 방법\n\n자동화를 위해 Bash 스크립팅을 사용하는 경우, 마지막 완료된 프로세스의 종료 코드를 가져오는 방법을 알고 있을 것입니다. $? 특수 Bash 매개변수가 도움이 됩니다. DevTools도 자동화 스크립팅에 존재하는 유사한 기능을 제공하여 디버깅 생산성을 향상시키려고 노력합니다. 콘솔에서 여러 식을 평가할 때, 사전 정의된 $_ 유틸리티 변수를 사용하여 마지막 표현식의 결과를 얻을 수 있습니다. 이는 디버깅 중에 테스트 데이터를 작성할 때 매우 유용합니다. 다음 예제를 살펴보세요:\n\n![예제](https://miro.medium.com/v2/resize:fit:1400/1*emqAYbt1vrKkcYS8aWP0Yw.gif)\n\n위 예에서는 $_ 유틸리티 변수를 사용하여 이전에 생성된 JavaScript 객체에 액세스합니다.\n\n\n\n우리는 모두 포커스가 있는 요소를 반환하는 document.activeElement 속성에 대해 알고 있습니다. 그렇다면 DevTools Inspector에서 선택한 DOM 요소에 대한 참조를 얻어야 한다면 어떻게 할까요? $0 유틸리티 변수가 도와줍니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*rGXZoHl7e_qNtS9dCIG8Nw.gif\" /\u003e\n\n공식 Chrome 콘솔 유틸리티 참조를 읽고 JavaScript 디버깅 중에 콘솔에서 사용할 수 있는 더 많은 단축 변수와 함수에 대해 알아보세요.\n\n다음 이야기는 여러분에게 JavaScript의 최신 단축 구문에 대해 가르쳐줍니다:\n\n\n\n# 이벤트 리스너 브레이크포인트 설정하기\n\n풀리피처가 갖춰진 개발 환경인 웹 브라우저는 다양한 이벤트를 제공하여 개발자들이 고품질이고 사용자 친화적인 웹 앱을 개발할 수 있도록 도와줍니다. 각 브라우저 API는 일반적으로 개발자들을 위한 이벤트 기반 상호작용 모델을 제공하며, 그에 따라 개발자들은 JavaScript 코드베이스에서 이벤트 리스너 콜백을 붙이곤 합니다. 디버깅을 위해 이벤트 리스너에 대한 브레이크포인트를 설정하려면 알려진 쉽고 간단한 방법이 있습니다.\n\n다음 코드를 살펴보세요:\n\n```js\nlet btn = document.getElementById('btn');\nlet count = 0;\n\nbtn.addEventListener('click', (e) =\u003e {\n  btn.innerText = `Clicked ${++count} times`;\n});\n```\n\n\n\n우리는 쉽게 이벤트 리스너를 중단점으로 설정할 수 있습니다. 왜냐하면 어디에 작성되어 있는지 알기 때문이죠. 그런데 만약 많은 이벤트 리스너가 있는 낯선한 코드베이스를 디버깅해야 한다면 어떨까요? DevTools는 이벤트 이름을 기반으로 중단점을 설정할 수 있는 방법을 제공합니다. 다음 예시를 살펴보세요:\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*jWE3Q8yaZtfjoU-OsZK3EQ.gif)\n\n위의 클릭 리스너 중단점은 코드 실행을 중지하고 자동으로 리스너 콜백으로 이동합니다. 비슷하게, XHR, worker, clipboard, keyboard 등의 이벤트에 대한 중단점을 설정하고 이벤트 리스너 등록을 찾을 수 있습니다.\n\n다음 이야기에서는 모든 현대 웹 개발자가 알아야 할 새로운 브라우저 이벤트 및 API에 대해 설명합니다:\n\n\n\n# 네트워크 요청 중단점 사용하기\n\nXHR 이벤트 중단점을 사용하여 네트워크 요청을 감지할 수 있습니다. 이를 통해 네트워크 관련 JavaScript 코드에 수동으로 중단점을 설정할 필요 없이 코드 실행이 모든 XHR 이벤트에서 중단되는 것이 아니라 특정 네트워크 요청에만 관심이 있는 경우에도 이를 감지할 수 있습니다. 개발자 도구는 URL 필터를 기반으로 네트워크 요청을 감지하는 소스 탭에 다른 섹션을 제공합니다. 예를 들어, 앱이 https://api.example.com URL에 대한 요청을 보내는 소스 코드 라인을 찾아야 한다고 가정해봅시다. 다음과 같이 XHR/fetch 중단점을 설정할 수 있습니다:\n\n![네트워크 요청 중단점](https://miro.medium.com/v2/resize:fit:1400/1*vg4xUAWXbRv7vJrAYQWq1w.gif)\n\n이 접근법을 사용하면 특정 네트워크 요청이 어디서 트리거되었는지, 코드를 검사하거나 네트워크 탭에서 시간을 소비하지 않고 파악할 수 있습니다. 위 미리보기에서처럼, 개발자 도구는 네트워크 요청을 전송한 코드 세그먼트를 자동으로 표시하므로 필요한 경우 새로운 중단점을 설정하고 결과를 추가 검사할 수 있습니다.\n\n\n\n# 호출 스택 검사\n\n개발자들은 종종 전체 소스 코드를 여러 JavaScript 함수로 분해하여 코드의 가독성과 품질을 향상시킵니다. 또한 이러한 함수들을 여러 모듈로 정리하여 관리 가능성을 더욱 향상시킵니다. 따라서 특정 웹 앱에서 사용자가 작업을 호출할 때마다 JavaScript 엔진의 호출 스택에서 여러 JavaScript 함수가 실행됩니다. 이러한 스택 프레임은 입력 매개변수와 비공개 변수를 포함하는 함수 스코프를 보유합니다. 재귀 알고리즘 디버깅 및 함수 호출 스택 분석을 위해 스택 프레임을 검사하는 것이 중요합니다.\n\n스택 프레임 분석기를 사용하는 것은 매우 쉬운데 - debugger 키워드를 사용하고 호출 스택 세그먼트를 열고 각 스택 프레임의 스코프를 검사할 수 있습니다. 아래 미리보기에서 보여지는 것과 같습니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*8OX_qVhdz4UtapF2jUzV8A.gif)\n\n\n\n호출 스택은 이론적인 스택 데이터 구조를 사용합니다. 모든 일반적인 데이터 구조를 알면 프로그래밍 기술이 향상되며, 다음 이야기에서 설명했습니다:\n\n읽어주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png"},"coverImage":"/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png","tag":["Tech"],"readingTime":6},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity_0.png\",\n        alt: \"Chrome DevTools JavaScript Debugging Features for Better Productivity\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"소프트웨어 버그는 소프트웨어 프로그램에서 예상치 못한 또는 잘못된 동작을 가리킵니다. 다른 소프트웨어 유형과 마찬가지로 웹 앱에도 버그가 포함될 수 있습니다. 웹 앱의 버그는 해당 웹 앱의 품질을 버그 심각도에 따라 저하시킬 수 있습니다. 몇 가지 심각한 소프트웨어 버그는 전체 웹 앱을 영향을 미치며 사용자 인터랙션 흐름을 망가뜨릴 수 있습니다. 한편 일부 미세한 소프트웨어 버그는 사용자 흐름의 일부를 영향을 미치며 대안 흐름으로 교체 가능할 수 있습니다. 잘 알려진 디버깅 프로세스는 웹 개발자가 웹 앱에서 버그를 제거하여 품질을 회복하는 데 도움을 줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"현대 웹 브라우저는 기능이 풍부한 웹 개발 환경으로서, JavaScript 소스 코드에서 버그를 감지하기 위한 디버깅 기능을 제공합니다. 예를 들어, Google Chrome은 제품적인 JavaScript 디버깅을 위해 DevTools 패널을 제공합니다. DevTools은 표준 중단점을 기반으로 한 동적 코드 분석 및 변수 감시, 스택 프레임 분석기, 리스너 검사자 등과 같은 고급 디버깅 기능을 제공합니다. DevTools는 브라우저에서 로드된 베니라 JavaScript를 디버그할 수 있을 뿐만 아니라 Chrome DevTools 프로토콜을 통해 TypeScript, Node.js, Deno 및 React Native 앱을 디버그할 수 있도록 지원합니다. 게다가 대부분의 프론트엔드 프레임워크/라이브러리는 디버깅 경험을 향상하기 위한 DevTools 확장을 제공합니다(예: React Developer Tools).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"생산성 중심의 Chrome DevTools 기능을 파악하면 JavaScript 소스 코드를 빠르게 디버그할 수 있고 버그 수정을 생산적으로 진행할 수 있습니다. 이 글에서는 JavaScript 디버깅 생산성을 높일 수 있는 DevTools 기능에 대해 설명하겠습니다. 이러한 DevTools 기능을 연습하고 디버깅 방법을 찾는 대신 디버깅에만 집중하세요!\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"변수와 표현식 감시하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"디버거 브레이크포인트가 코드 실행을 중단할 때마다, 마우스를 가져다 대면 JavaScript 변수를 살펴볼 수 있습니다. 이 기술을 사용하여 디버깅 중에 원자값과 객체를 살펴볼 수 있지만, 한꺼번에 여러 변수를 감시해야 한다면 시간이 많이 소요될 수 있습니다. 디버깅 중 감시해야 하는 변수와 표현식을 평가해야 한다면 더 어려워질 수 있습니다. 이런 경우에는 디버거 코드 뷰와 콘솔을 자주 왔다갔다해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DevTools에서는 브레이크포인트를 기반으로 변수와 표현식을 감시하거나 브레이크포인트에서 멈추지 않고 수동으로 업데이트할 수 있습니다. 다음 코드 조각을 살펴보세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" m = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" s = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"setInterval\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  s++;\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \"(s === \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"60\"\n        }), \") {\\n    m++;\\n    s = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n  }\\n}, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 코드는 두 변수를 사용해 간단한 초-분 타이머를 구현한 것입니다. 다음과 같이 새로운 감시자를 추가하고 중단점을 설정하여 m 및 s 변수를 확인할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*T23NrZm73SydEAZjai8NVQ.gif\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"매 초마다 실행을 멈추는 중단점이 있기 때문에 중단점을 제거하고 대신 새로고침 버튼을 누를 수 있습니다. 또한 감시자 레코드로 표현식을 평가할 수도 있습니다. 예를 들어 다음 샘플 표현식이 선행 0이 있는 타이머 값을 출력하는 방법을 확인해보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*4f9JCOR17w3M4-Tp82Q92w.gif\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"콘솔에서 디버거 컨텍스트 사용하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 객체 속성을 검사하기 위해 마우스를 호버하고 관찰자를 설정하는 방식으로 사용할 수 있습니다. 그러나 어떤 상황에서는 콘솔에서 자동 완성을 지원하는 상태에서 객체 메서드를 트리거하고 객체 속성을 검사해야 할 때가 있습니다. 개발 도구는 이 요구 사항을 해결하기 위해 콘솔의 범위를 현재 중단점으로 변경합니다. d 객체의 getMilliseconds() 메서드의 반환 값을 확인해야 한다고 가정해 봅시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getMagicDate\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"d\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \"(d.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getDate\"\n        }), \"() % \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" === \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \") {\\n    d.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setDate\"\n        }), \"(d.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getDate\"\n        }), \"() + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \");\\n  }\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n    d.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setMonth\"\n        }), \"(d.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getMonth\"\n        }), \"() + \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \");\\n  }\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" d;\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getMagicDate\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \"());\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저 중단점을 설정하고 코드 실행 프로세스를 중단해야 합니다. 그런 다음, 콘솔 서랍을 열기 위해 escape 키를 누르고 실행할 메서드를 입력하세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*yErxg7PWPkt1nBHar2Z3Mw.gif\",\n        alt: \"Live Expressions\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"중단점 없이 실시간 표현식 만들기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"첫 번째 예제에서는 위쳐(watchers)를 사용하여 샘플 프로그램의 몇 가지 변수를 조사했습니다. 표현식의 업데이트된 결과를 보려면 중단점에 멈춰야했거나 새로 고침 버튼을 눌러야 했습니다. DevTools를 사용하면 콘솔에서 실시간 표현식을 만들 수 있으므로 중단점을 사용하지 않고도 원하는 표현식의 업데이트된 결과를 볼 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 시나리오에 대해 이전에 사용한 코드를 사용하겠습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" m = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" s = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"setInterval\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  s++;\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (s === \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"60\"\n        }), \") {\\n    m++;\\n    s = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`\", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"${m.toString().padStart(\", _jsx(_components.span, {\n              className: \"hljs-number\",\n              children: \"2\"\n            }), \", \", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"'0'\"\n            }), \")}\"]\n          }), \":\", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"${s.toString().padStart(\", _jsx(_components.span, {\n              className: \"hljs-number\",\n              children: \"2\"\n            }), \", \", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"'0'\"\n            }), \")}\"]\n          }), \"`\"]\n        }), \");\\n}, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"마지막 콘솔 결과 및 선택된 요소에 액세스하는 방법\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자동화를 위해 Bash 스크립팅을 사용하는 경우, 마지막 완료된 프로세스의 종료 코드를 가져오는 방법을 알고 있을 것입니다. $? 특수 Bash 매개변수가 도움이 됩니다. DevTools도 자동화 스크립팅에 존재하는 유사한 기능을 제공하여 디버깅 생산성을 향상시키려고 노력합니다. 콘솔에서 여러 식을 평가할 때, 사전 정의된 $_ 유틸리티 변수를 사용하여 마지막 표현식의 결과를 얻을 수 있습니다. 이는 디버깅 중에 테스트 데이터를 작성할 때 매우 유용합니다. 다음 예제를 살펴보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*emqAYbt1vrKkcYS8aWP0Yw.gif\",\n        alt: \"예제\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 예에서는 $_ 유틸리티 변수를 사용하여 이전에 생성된 JavaScript 객체에 액세스합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 모두 포커스가 있는 요소를 반환하는 document.activeElement 속성에 대해 알고 있습니다. 그렇다면 DevTools Inspector에서 선택한 DOM 요소에 대한 참조를 얻어야 한다면 어떻게 할까요? $0 유틸리티 변수가 도와줍니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"https://miro.medium.com/v2/resize:fit:1400/1*rGXZoHl7e_qNtS9dCIG8Nw.gif\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"공식 Chrome 콘솔 유틸리티 참조를 읽고 JavaScript 디버깅 중에 콘솔에서 사용할 수 있는 더 많은 단축 변수와 함수에 대해 알아보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 이야기는 여러분에게 JavaScript의 최신 단축 구문에 대해 가르쳐줍니다:\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"이벤트 리스너 브레이크포인트 설정하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"풀리피처가 갖춰진 개발 환경인 웹 브라우저는 다양한 이벤트를 제공하여 개발자들이 고품질이고 사용자 친화적인 웹 앱을 개발할 수 있도록 도와줍니다. 각 브라우저 API는 일반적으로 개발자들을 위한 이벤트 기반 상호작용 모델을 제공하며, 그에 따라 개발자들은 JavaScript 코드베이스에서 이벤트 리스너 콜백을 붙이곤 합니다. 디버깅을 위해 이벤트 리스너에 대한 브레이크포인트를 설정하려면 알려진 쉽고 간단한 방법이 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 코드를 살펴보세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" btn = \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"document\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getElementById\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'btn'\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" count = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \";\\n\\nbtn.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"addEventListener\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'click'\"\n        }), \", \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"e\"\n          }), \") =\u003e\"]\n        }), \" {\\n  btn.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"innerText\"\n        }), \" = \", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`Clicked \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${++count}\"\n          }), \" times`\"]\n        }), \";\\n});\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 쉽게 이벤트 리스너를 중단점으로 설정할 수 있습니다. 왜냐하면 어디에 작성되어 있는지 알기 때문이죠. 그런데 만약 많은 이벤트 리스너가 있는 낯선한 코드베이스를 디버깅해야 한다면 어떨까요? DevTools는 이벤트 이름을 기반으로 중단점을 설정할 수 있는 방법을 제공합니다. 다음 예시를 살펴보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*jWE3Q8yaZtfjoU-OsZK3EQ.gif\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 클릭 리스너 중단점은 코드 실행을 중지하고 자동으로 리스너 콜백으로 이동합니다. 비슷하게, XHR, worker, clipboard, keyboard 등의 이벤트에 대한 중단점을 설정하고 이벤트 리스너 등록을 찾을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 이야기에서는 모든 현대 웹 개발자가 알아야 할 새로운 브라우저 이벤트 및 API에 대해 설명합니다:\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"네트워크 요청 중단점 사용하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"XHR 이벤트 중단점을 사용하여 네트워크 요청을 감지할 수 있습니다. 이를 통해 네트워크 관련 JavaScript 코드에 수동으로 중단점을 설정할 필요 없이 코드 실행이 모든 XHR 이벤트에서 중단되는 것이 아니라 특정 네트워크 요청에만 관심이 있는 경우에도 이를 감지할 수 있습니다. 개발자 도구는 URL 필터를 기반으로 네트워크 요청을 감지하는 소스 탭에 다른 섹션을 제공합니다. 예를 들어, 앱이 https://api.example.com URL에 대한 요청을 보내는 소스 코드 라인을 찾아야 한다고 가정해봅시다. 다음과 같이 XHR/fetch 중단점을 설정할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*vg4xUAWXbRv7vJrAYQWq1w.gif\",\n        alt: \"네트워크 요청 중단점\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 접근법을 사용하면 특정 네트워크 요청이 어디서 트리거되었는지, 코드를 검사하거나 네트워크 탭에서 시간을 소비하지 않고 파악할 수 있습니다. 위 미리보기에서처럼, 개발자 도구는 네트워크 요청을 전송한 코드 세그먼트를 자동으로 표시하므로 필요한 경우 새로운 중단점을 설정하고 결과를 추가 검사할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"호출 스택 검사\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"개발자들은 종종 전체 소스 코드를 여러 JavaScript 함수로 분해하여 코드의 가독성과 품질을 향상시킵니다. 또한 이러한 함수들을 여러 모듈로 정리하여 관리 가능성을 더욱 향상시킵니다. 따라서 특정 웹 앱에서 사용자가 작업을 호출할 때마다 JavaScript 엔진의 호출 스택에서 여러 JavaScript 함수가 실행됩니다. 이러한 스택 프레임은 입력 매개변수와 비공개 변수를 포함하는 함수 스코프를 보유합니다. 재귀 알고리즘 디버깅 및 함수 호출 스택 분석을 위해 스택 프레임을 검사하는 것이 중요합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"스택 프레임 분석기를 사용하는 것은 매우 쉬운데 - debugger 키워드를 사용하고 호출 스택 세그먼트를 열고 각 스택 프레임의 스코프를 검사할 수 있습니다. 아래 미리보기에서 보여지는 것과 같습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*8OX_qVhdz4UtapF2jUzV8A.gif\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"호출 스택은 이론적인 스택 데이터 구조를 사용합니다. 모든 일반적인 데이터 구조를 알면 프로그래밍 기술이 향상되며, 다음 이야기에서 설명했습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"읽어주셔서 감사합니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-ChromeDevToolsJavaScriptDebuggingFeaturesForBetterProductivity"},"buildId":"837W-BjvPVBgft6aM4api","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>