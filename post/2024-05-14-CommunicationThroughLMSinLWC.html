<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>LWC에서 LMS를 통한 커뮤니케이션 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-CommunicationThroughLMSinLWC" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="LWC에서 LMS를 통한 커뮤니케이션 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="LWC에서 LMS를 통한 커뮤니케이션 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-CommunicationThroughLMSinLWC" data-gatsby-head="true"/><meta name="twitter:title" content="LWC에서 LMS를 통한 커뮤니케이션 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 13:20" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">LWC에서 LMS를 통한 커뮤니케이션</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="LWC에서 LMS를 통한 커뮤니케이션" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-CommunicationThroughLMSinLWC&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png" alt="이미지"></p>
<p>Salesforce의 Lightning Message Service (LMS)는 돔 계층 구조 전체에서 Lightning Web Components (LWC) 간의 통신을 가능하게 하는 강력한 기능입니다. 이것은 요소가 직계 부모-자식 관계를 필요로하지 않고 서로 통신할 수 있도록 해주므로 복잡한 애플리케이션을 구축하는 유연한 도구입니다. 이 블로그에서는 LWC 간 통신을 위해 LMS를 사용하는 방법과 구현 예시를 살펴볼 것입니다.</p>
<h1>Lightning Message Service란?</h1>
<p>Lightning Message Service (LMS)는 Salesforce가 제공하는 통신 프레임워크로, Lightning 페이지의 다른 구성 요소와 Lightning Web Components (LWC) 간에 효과적인 통신을 가능하게 합니다.</p>
<p>그것은 계층적 관계에 관계없이 컴포넌트 간에 통신할 수 있도록 해줘서 모듈식이고 연결된 애플리케이션을 쉽게 구축할 수 있습니다.</p>
<p>LMS는 컴포넌트가 데이터를 포함하는 메시지를 게시하고, 다른 컴포넌트가 이러한 메시지를 구독하고 반응할 수 있는 방법을 제공합니다. 이러한 분리된 통신 접근 방식은 Lightning 애플리케이션의 유연성과 유지 보수성을 향상시킵니다.</p>
<p>아래는 Lightning Message Service Flow 다이어그램입니다. Lightning Message Channels의 도움으로 다양한 컴포넌트 간의 통신을 보여줍니다.</p>
<h1>라이트닝 메시지 서비스(LMS) 이해하기:</h1>
<p>LMS는 컴포넌트가 메시지(이벤트)를 발행하고 구독하여 해당 메시지를 수신할 수 있는 pub-sub (publish-subscribe) 메시징 패턴을 제공합니다. 이 분리된 통신 메커니즘은 컴포넌트 간의 느슨한 결합을 촉진하여 재사용성과 유지 보수성을 향상시킵니다.</p>
<p>라이트닝 메시지 서비스에는 두 가지 주요 개념이 있습니다: 발행자(Publishers)와 구독자(Subscribers).</p>
<h2>1. 발행자(Publisher):</h2>
<ul>
<li>Publisher 구성 요소는 특정 메시지 채널로 메시지를 보내는 역할을 합니다.</li>
<li>이러한 메시지는 데이터를 전달하거나 비어 있을 수 있으며, 구독자는 이에 따라 반응할 수 있습니다.</li>
<li>Publisher 구성 요소를 생성할 때는 <code>@salesforce/messageChannel</code> 모듈에서 <code>publish()</code> 함수를 import해야 합니다.</li>
<li>이 함수를 사용하면 Lightning Message Channel을 통해 메시지를 보낼 수 있습니다.</li>
</ul>
<h2>2. Subscriber:</h2>
<ul>
<li>Subscriber 구성 요소는 특정 메시지 채널을 주시적으로 듣습니다.</li>
<li>이 채널에서 메시지가 발행될 때마다 해당 메시지에 응답할 수 있는 모든 구독된 구성 요소가 반응할 수 있습니다.</li>
<li>중요한 점은 Subscriber가 Publisher에 대한 구체적인 세부 정보를 알 필요가 없어서 유연하고 느슨하게 결합된 시스템을 유지하는 데 도움이 된다는 것입니다.</li>
</ul>
<p><img src="/assets/img/2024-05-14-CommunicationThroughLMSinLWC_2.png" alt="이미지"></p>
<h2>주의 !</h2>
<h1>LWC에서 라이트닝 메시지 서비스(LMS)를 통해 컴포넌트가 어떻게 통신하는지</h1>
<h2>메시지 채널 메타데이터 정의:</h2>
<p>컴포넌트 간에 통신 채널을 설정하려면 먼저 Salesforce 조직에서 메시지 채널 메타데이터를 정의해야합니다. 아래 단계를 따르세요:</p>
<ul>
<li>Salesforce 프로젝트 구조의 <code>force-app/main/default</code> 하위에 "messageChannels"라는 폴더를 생성해주세요.</li>
</ul>
<ol start="2">
<li>
<p>이 폴더 안에 "messageChannelName.messageChannel-meta.xml" 형식의 XML 파일을 만들어주세요. 여기서 "messageChannelName"을 원하는 채널 이름으로 바꿔주세요.</p>
</li>
<li>
<p>아래 코드를 참고하여 .xml 파일에 <code>lightning message field</code>를 정의해주세요:</p>
</li>
</ol>
<p>sampleMessageChannel.messageChannel-meta.xml</p>
<p>md</p>
<pre><code class="hljs language-js">&#x3C;!--?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?-->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">lightningmessagechannel</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://soap.sforce.com/2006/04/metadata"</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">masterlabel</span>></span>SampleMessageChannel<span class="hljs-tag">&#x3C;/<span class="hljs-name">masterlabel</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">isexposed</span>></span>true<span class="hljs-tag">&#x3C;/<span class="hljs-name">isexposed</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">description</span>></span>This is a sample Lightning Message Channel.<span class="hljs-tag">&#x3C;/<span class="hljs-name">description</span>></span>
     
    <span class="hljs-comment">&#x3C;!-- Define message payload fields --></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">lightningmessagefields</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">fieldname</span>></span>recordId<span class="hljs-tag">&#x3C;/<span class="hljs-name">fieldname</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">description</span>></span>This is the record Id that changed<span class="hljs-tag">&#x3C;/<span class="hljs-name">description</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">lightningmessagefields</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">lightningmessagefields</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">fieldname</span>></span>recordData<span class="hljs-tag">&#x3C;/<span class="hljs-name">fieldname</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">description</span>></span>The current data representing the record that changed<span class="hljs-tag">&#x3C;/<span class="hljs-name">description</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">lightningmessagefields</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">lightningmessagechannel</span>></span></span>
</code></pre>
<h2>설명:</h2>
<ul>
<li><code>isExposed</code> 태그는 컴포넌트를 사용할 수 있게 만드는 데 사용됩니다.</li>
<li><code>lightningMessageFields</code> 태그를 사용하여 필드를 정의하는데 특정 정보를 전달할 수 있습니다. 예를 들어 <code>recordId</code>를 정의할 수 있습니다.</li>
<li><code>description</code> 태그를 사용하여 Lightning 메시지 채널에 대한 설명을 추가하면 이 메시지 채널을 만드는 목표에 대해 설명할 수 있습니다.</li>
<li><code>.messageChannel-meta.xml</code> 파일이 작성되면 Salesforce org에 배포하세요.</li>
</ul>
<h2>메시지 서비스 기능 가져오기:</h2>
<p>번역 :</p>
<p>당신의 Lightning 웹 컴포넌트에서 필요한 메시지 서비스 기능을 다음과 같이 가져오세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { publish, subscribe, unsubscribe, <span class="hljs-variable constant_">APPLICATION_SCOPE</span>, <span class="hljs-title class_">MessageContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'lightning/messageService'</span>;
<span class="hljs-keyword">import</span> msgService <span class="hljs-keyword">from</span> <span class="hljs-string">'@salesforce/messageChannel/messageChannelName__c'</span>;
</code></pre>
<h2>메시지 서비스 범위 정의:</h2>
<p><code>@wire 어댑터</code>를 사용하여 메시지 서비스의 범위를 정의할 수 있습니다.
라이트닝 웹 컴포넌트에서는 <code>@wire 어댑터</code>로만 스코핑이 가능합니다.</p>
<p>예시:</p>
<pre><code class="hljs language-js">@<span class="hljs-title function_">wire</span>(<span class="hljs-title class_">MessageContext</span>)
messageContext;
</code></pre>
<h1>메시지 채널 발행:</h1>
<p>메시지 채널에 메시지를 발행하려면 라이트닝 메시지 서비스의 <code>publish()</code> 메서드를 사용하십시오. 이 메서드는 메시지 컨텍스트, 메시지 채널, 메시지 페이로드를 매개변수로 받습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> messagePayload = {
    <span class="hljs-attr">recordId</span>: <span class="hljs-string">'0012y00000L5R6jAAF'</span>,
    <span class="hljs-attr">recordData</span>: { <span class="hljs-comment">/* 레코드를 나타내는 데이터 */</span> }
};
<span class="hljs-title function_">publish</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">messageContext</span>, msgService, messagePayload);
</code></pre>
<p><code>publish()</code> 메소드는 3개의 파라미터를 받습니다 :</p>
<ul>
<li>메시지 컨텍스트 (객체 타입)</li>
<li>메시지 채널 (객체 타입)</li>
<li>메시지 페이로드 (메시지 페이로드는 JSON 객체입니다)</li>
</ul>
<p>messageContext : <code>MessageContext</code> 객체는 Lightning 메시지 서비스를 사용하는 Lightning 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 <code>MessageContext</code> 와이어 어댑터나 <code>createMessageContext()</code>를 통해 가져올 수 있습니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title function_">wire</span>(<span class="hljs-title class_">MessageContext</span>)
messageContext
</code></pre>
<p>messageChannel: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 <code>@salesforce/messageChannel</code>과 같은 scoped 모듈을 사용하세요. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하세요.</p>
<p>message: 가입자에게 발행된 메시지를 포함하는 직렬화 가능한 JSON 객체입니다. 메시지에는 함수나 심볼을 포함할 수 없습니다.</p>
<h1>메시지 채널 구독:</h1>
<p>특정 메시지 채널의 메시지를 구독하려면 <code>subscribe()</code> 메서드를 사용하세요. 받은 메시지를 처리하기 위한 리스너 함수를 제공해주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">subscription</span> = <span class="hljs-title function_">subscribe</span>(
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageContext</span>,
    msgService,
    <span class="hljs-function">(<span class="hljs-params">message</span>) =></span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleMessage</span>(message)
);
</code></pre>
<p><code>subscribe()</code> 메서드는 4개의 매개변수를 받습니다:</p>
<ul>
<li>메시지 컨텍스트 (객체 형식)</li>
<li>메시지 채널 (객체 형식)</li>
<li>리스너 (함수 형식)</li>
<li>구독자 옵션 (객체 형식)</li>
</ul>
<p>메시지 컨텍스트: <code>MessageContext</code> 객체는 라이트닝 메시지 서비스를 사용하는 라이트닝 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 <code>MessageContext</code> 와이어 어댑터를 통해 가져오거나 <code>createMessageContext()</code>를 통해 가져올 수 있습니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title function_">wire</span>(<span class="hljs-title class_">MessageContext</span>)
messageContext
</code></pre>
<p>메시지 채널: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 scoped 모듈인 <code>@salesforce/messageChannel</code>을 사용하십시오. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하십시오.</p>
<p>리스너: 발행된 메시지를 처리하는 함수입니다.</p>
<p>subscriberOptions: (선택 사항) 이 객체는 <code>'scope: APPLICATION_SCOPE'</code>로 설정되었을 때, 애플리케이션 전반에서 메시지 채널에서 메시지를 수신할 수 있는 능력을 지정합니다. <code>lightning/messageService</code>에서 <code>APPLICATION_SCOPE</code>를 가져와야 합니다.</p>
<h1>메시지 채널 구독 취소:</h1>
<p>메시지 채널 구독을 취소하려면 <code>unsubscribe()</code> 메서드를 사용하고, <code>subscribe()</code> 함수에 의해 반환된 구독 객체를 제공하면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">unsubscribe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">subscription</span>);
</code></pre>
<h1>Salesforce Lightning Message Service를 언제 사용해야 할까요?</h1>
<p>라이트닝 메시지 서비스는 Visualforce 페이지, Aura 및 LWC 간에 정보를 교환하거나 전달하는 방법입니다. LMS는 특히 구성 요소가 구성 요소 계층구조에서 직접적으로 관련되어 있지 않지만 서로 상호 작용해야 하는 시나리오에서 유용합니다. 다음은 LMS를 사용할 수 있는 몇 가지 상황입니다:</p>
<ul>
<li>부모-자식 구성 요소 간 통신: 부모 구성 요소와 여러 자식 구성 요소가 있고, 이들 간에 데이터를 전달하거나 작업을 트리거하려는 경우입니다.</li>
<li>동료 구성 요소 간 통신: 페이지에 동료 구성 요소가 있고, 이들의 상태를 동기화하거나 데이터를 공유해야 하는 경우입니다.</li>
<li>크로스 도메인 통신: 관리되는 패키지와 사용자 지정 구성 요소와 같이 서로 다른 네임스페이스에 거주하는 구성 요소 간에 통신해야 하는 경우입니다.</li>
<li>동적 구성 요소 간 통신: 구성 요소가 런타임에서 동적으로 생성되거나 파괴되고, 이들 사이에 통신 채널을 설정할 유연한 방법이 필요한 경우입니다.</li>
</ul>
<p>다음은 Lightning Message Service의 사용 예시 시나리오입니다:</p>
<p>당신이 Lightning 페이지에서 두 개의 컴포넌트를 가지고 있는 상황을 상상해봅시다: 계정 목록을 표시하는 부모 컴포넌트와 선택된 계정의 세부 정보를 보여주는 자식 컴포넌트가 있습니다. 사용자가 부모 컴포넌트에서 계정을 선택할 때, 자식 컴포넌트가 동적으로 업데이트되어 선택된 계정의 세부 정보를 표시하고 싶습니다.</p>
<h1>Salesforce Lightning Message Service의 제한 사항</h1>
<ul>
<li>LMS는 Salesforce 모바일 앱, AppExchange, Lightning Out 및 Lightning Communities와 통합할 수 있는 능력이 없습니다.</li>
<li>LMS는 iframe에서 작동하지 않습니다.</li>
<li>LMS는 Salesforce 클래식에서 작동하지 않습니다.</li>
<li>Salesforce UI에서 직접 라이트닝 메시지 채널을 생성하는 것을 지원하지 않습니다.</li>
</ul>
<h1>결론:</h1>
<p>라이트닝 메시지 서비스(Lightning Message Service)는 Salesforce의 라이트닝 웹 컴포넌트(Lightning Web Components) 간 효율적인 통신을 가능케 하는 강력한 도구입니다. pub-sub 패턴을 구현함으로써 컴포넌트들은 분리된 방식으로 통신할 수 있으며, 이는 라이트닝 애플리케이션의 유연성과 확장성을 향상시킵니다. 올바른 사용법과 이해를 통해 LMS는 Salesforce에서 복잡하고 동적인 사용자 인터페이스를 원활하게 구축할 수 있도록 도와줍니다.</p>
<p>"더 많은 흥미로운 LWC 주제를 기대해주시고 Salesforce 개발 전문가가 되기 위해 라이트닝 웹 컴포넌트의 세계를 계속 탐험해보세요."</p>
<p>즐거운 LWC 코딩하세요!</p>
<p>더 자세한 내용은 아래 링크를 방문해주세요:</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"LWC에서 LMS를 통한 커뮤니케이션","description":"","date":"2024-05-14 13:20","slug":"2024-05-14-CommunicationThroughLMSinLWC","content":"\n\n\n![이미지](/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png)\n\nSalesforce의 Lightning Message Service (LMS)는 돔 계층 구조 전체에서 Lightning Web Components (LWC) 간의 통신을 가능하게 하는 강력한 기능입니다. 이것은 요소가 직계 부모-자식 관계를 필요로하지 않고 서로 통신할 수 있도록 해주므로 복잡한 애플리케이션을 구축하는 유연한 도구입니다. 이 블로그에서는 LWC 간 통신을 위해 LMS를 사용하는 방법과 구현 예시를 살펴볼 것입니다.\n\n# Lightning Message Service란?\n\nLightning Message Service (LMS)는 Salesforce가 제공하는 통신 프레임워크로, Lightning 페이지의 다른 구성 요소와 Lightning Web Components (LWC) 간에 효과적인 통신을 가능하게 합니다.\n\n\n\n\n그것은 계층적 관계에 관계없이 컴포넌트 간에 통신할 수 있도록 해줘서 모듈식이고 연결된 애플리케이션을 쉽게 구축할 수 있습니다.\n\nLMS는 컴포넌트가 데이터를 포함하는 메시지를 게시하고, 다른 컴포넌트가 이러한 메시지를 구독하고 반응할 수 있는 방법을 제공합니다. 이러한 분리된 통신 접근 방식은 Lightning 애플리케이션의 유연성과 유지 보수성을 향상시킵니다.\n\n아래는 Lightning Message Service Flow 다이어그램입니다. Lightning Message Channels의 도움으로 다양한 컴포넌트 간의 통신을 보여줍니다.\n\n\n\n# 라이트닝 메시지 서비스(LMS) 이해하기:\n\nLMS는 컴포넌트가 메시지(이벤트)를 발행하고 구독하여 해당 메시지를 수신할 수 있는 pub-sub (publish-subscribe) 메시징 패턴을 제공합니다. 이 분리된 통신 메커니즘은 컴포넌트 간의 느슨한 결합을 촉진하여 재사용성과 유지 보수성을 향상시킵니다.\n\n라이트닝 메시지 서비스에는 두 가지 주요 개념이 있습니다: 발행자(Publishers)와 구독자(Subscribers).\n\n## 1. 발행자(Publisher):\n\n\n\n- Publisher 구성 요소는 특정 메시지 채널로 메시지를 보내는 역할을 합니다.\n- 이러한 메시지는 데이터를 전달하거나 비어 있을 수 있으며, 구독자는 이에 따라 반응할 수 있습니다.\n- Publisher 구성 요소를 생성할 때는 `@salesforce/messageChannel` 모듈에서 `publish()` 함수를 import해야 합니다.\n- 이 함수를 사용하면 Lightning Message Channel을 통해 메시지를 보낼 수 있습니다.\n\n## 2. Subscriber:\n\n- Subscriber 구성 요소는 특정 메시지 채널을 주시적으로 듣습니다.\n- 이 채널에서 메시지가 발행될 때마다 해당 메시지에 응답할 수 있는 모든 구독된 구성 요소가 반응할 수 있습니다.\n- 중요한 점은 Subscriber가 Publisher에 대한 구체적인 세부 정보를 알 필요가 없어서 유연하고 느슨하게 결합된 시스템을 유지하는 데 도움이 된다는 것입니다.\n\n![이미지](/assets/img/2024-05-14-CommunicationThroughLMSinLWC_2.png)\n\n\n\n## 주의 !\n\n# LWC에서 라이트닝 메시지 서비스(LMS)를 통해 컴포넌트가 어떻게 통신하는지\n\n## 메시지 채널 메타데이터 정의:\n\n컴포넌트 간에 통신 채널을 설정하려면 먼저 Salesforce 조직에서 메시지 채널 메타데이터를 정의해야합니다. 아래 단계를 따르세요:\n\n\n\n- Salesforce 프로젝트 구조의 `force-app/main/default` 하위에 \"messageChannels\"라는 폴더를 생성해주세요.\n\n2. 이 폴더 안에 \"messageChannelName.messageChannel-meta.xml\" 형식의 XML 파일을 만들어주세요. 여기서 \"messageChannelName\"을 원하는 채널 이름으로 바꿔주세요.\n\n3. 아래 코드를 참고하여 .xml 파일에 `lightning message field`를 정의해주세요:\n\n\nsampleMessageChannel.messageChannel-meta.xml\n\n\n\n\nmd\n```js\n\u003c!--?xml version=\"1.0\" encoding=\"UTF-8\"?--\u003e\n\u003clightningmessagechannel xmlns=\"http://soap.sforce.com/2006/04/metadata\"\u003e\n    \u003cmasterlabel\u003eSampleMessageChannel\u003c/masterlabel\u003e\n    \u003cisexposed\u003etrue\u003c/isexposed\u003e\n    \u003cdescription\u003eThis is a sample Lightning Message Channel.\u003c/description\u003e\n     \n    \u003c!-- Define message payload fields --\u003e\n    \u003clightningmessagefields\u003e\n        \u003cfieldname\u003erecordId\u003c/fieldname\u003e\n        \u003cdescription\u003eThis is the record Id that changed\u003c/description\u003e\n    \u003c/lightningmessagefields\u003e\n    \u003clightningmessagefields\u003e\n        \u003cfieldname\u003erecordData\u003c/fieldname\u003e\n        \u003cdescription\u003eThe current data representing the record that changed\u003c/description\u003e\n    \u003c/lightningmessagefields\u003e\n\u003c/lightningmessagechannel\u003e\n```\n\n## 설명:\n\n- `isExposed` 태그는 컴포넌트를 사용할 수 있게 만드는 데 사용됩니다.\n- `lightningMessageFields` 태그를 사용하여 필드를 정의하는데 특정 정보를 전달할 수 있습니다. 예를 들어 `recordId`를 정의할 수 있습니다.\n- `description` 태그를 사용하여 Lightning 메시지 채널에 대한 설명을 추가하면 이 메시지 채널을 만드는 목표에 대해 설명할 수 있습니다.\n- `.messageChannel-meta.xml` 파일이 작성되면 Salesforce org에 배포하세요.\n\n## 메시지 서비스 기능 가져오기:\n\n\n\n\n번역 : \n\n당신의 Lightning 웹 컴포넌트에서 필요한 메시지 서비스 기능을 다음과 같이 가져오세요:\n\n```js\nimport { publish, subscribe, unsubscribe, APPLICATION_SCOPE, MessageContext } from 'lightning/messageService';\nimport msgService from '@salesforce/messageChannel/messageChannelName__c';\n```\n\n## 메시지 서비스 범위 정의:\n\n`@wire 어댑터`를 사용하여 메시지 서비스의 범위를 정의할 수 있습니다.\n라이트닝 웹 컴포넌트에서는 `@wire 어댑터`로만 스코핑이 가능합니다.\n\n\n\n예시:\n\n```js\n@wire(MessageContext)\nmessageContext;\n```\n\n# 메시지 채널 발행:\n\n메시지 채널에 메시지를 발행하려면 라이트닝 메시지 서비스의 `publish()` 메서드를 사용하십시오. 이 메서드는 메시지 컨텍스트, 메시지 채널, 메시지 페이로드를 매개변수로 받습니다.\n\n\n\n```js\nconst messagePayload = {\n    recordId: '0012y00000L5R6jAAF',\n    recordData: { /* 레코드를 나타내는 데이터 */ }\n};\npublish(this.messageContext, msgService, messagePayload);\n```\n\n`publish()` 메소드는 3개의 파라미터를 받습니다 :\n\n- 메시지 컨텍스트 (객체 타입)\n- 메시지 채널 (객체 타입)\n- 메시지 페이로드 (메시지 페이로드는 JSON 객체입니다)\n\nmessageContext : `MessageContext` 객체는 Lightning 메시지 서비스를 사용하는 Lightning 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 `MessageContext` 와이어 어댑터나 `createMessageContext()`를 통해 가져올 수 있습니다.\n\n\n\n```js\n@wire(MessageContext)\nmessageContext\n```\n\nmessageChannel: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 `@salesforce/messageChannel`과 같은 scoped 모듈을 사용하세요. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하세요.\n\nmessage: 가입자에게 발행된 메시지를 포함하는 직렬화 가능한 JSON 객체입니다. 메시지에는 함수나 심볼을 포함할 수 없습니다.\n\n# 메시지 채널 구독:\n\n\n\n특정 메시지 채널의 메시지를 구독하려면 `subscribe()` 메서드를 사용하세요. 받은 메시지를 처리하기 위한 리스너 함수를 제공해주세요.\n\n```js\nthis.subscription = subscribe(\n    this.messageContext,\n    msgService,\n    (message) =\u003e this.handleMessage(message)\n);\n```\n\n`subscribe()` 메서드는 4개의 매개변수를 받습니다:\n\n- 메시지 컨텍스트 (객체 형식)\n- 메시지 채널 (객체 형식)\n- 리스너 (함수 형식)\n- 구독자 옵션 (객체 형식)\n\n\n\n메시지 컨텍스트: `MessageContext` 객체는 라이트닝 메시지 서비스를 사용하는 라이트닝 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 `MessageContext` 와이어 어댑터를 통해 가져오거나 `createMessageContext()`를 통해 가져올 수 있습니다.\n\n```js\n@wire(MessageContext)\nmessageContext\n```\n\n메시지 채널: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 scoped 모듈인 `@salesforce/messageChannel`을 사용하십시오. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하십시오.\n\n리스너: 발행된 메시지를 처리하는 함수입니다.\n\n\n\nsubscriberOptions: (선택 사항) 이 객체는 `'scope: APPLICATION_SCOPE'`로 설정되었을 때, 애플리케이션 전반에서 메시지 채널에서 메시지를 수신할 수 있는 능력을 지정합니다. `lightning/messageService`에서 `APPLICATION_SCOPE`를 가져와야 합니다.\n\n# 메시지 채널 구독 취소:\n\n메시지 채널 구독을 취소하려면 `unsubscribe()` 메서드를 사용하고, `subscribe()` 함수에 의해 반환된 구독 객체를 제공하면 됩니다.\n\n```js\nunsubscribe(this.subscription);\n```\n\n\n\n# Salesforce Lightning Message Service를 언제 사용해야 할까요?\n\n라이트닝 메시지 서비스는 Visualforce 페이지, Aura 및 LWC 간에 정보를 교환하거나 전달하는 방법입니다. LMS는 특히 구성 요소가 구성 요소 계층구조에서 직접적으로 관련되어 있지 않지만 서로 상호 작용해야 하는 시나리오에서 유용합니다. 다음은 LMS를 사용할 수 있는 몇 가지 상황입니다:\n\n- 부모-자식 구성 요소 간 통신: 부모 구성 요소와 여러 자식 구성 요소가 있고, 이들 간에 데이터를 전달하거나 작업을 트리거하려는 경우입니다.\n- 동료 구성 요소 간 통신: 페이지에 동료 구성 요소가 있고, 이들의 상태를 동기화하거나 데이터를 공유해야 하는 경우입니다.\n- 크로스 도메인 통신: 관리되는 패키지와 사용자 지정 구성 요소와 같이 서로 다른 네임스페이스에 거주하는 구성 요소 간에 통신해야 하는 경우입니다.\n- 동적 구성 요소 간 통신: 구성 요소가 런타임에서 동적으로 생성되거나 파괴되고, 이들 사이에 통신 채널을 설정할 유연한 방법이 필요한 경우입니다.\n\n다음은 Lightning Message Service의 사용 예시 시나리오입니다:\n\n\n\n당신이 Lightning 페이지에서 두 개의 컴포넌트를 가지고 있는 상황을 상상해봅시다: 계정 목록을 표시하는 부모 컴포넌트와 선택된 계정의 세부 정보를 보여주는 자식 컴포넌트가 있습니다. 사용자가 부모 컴포넌트에서 계정을 선택할 때, 자식 컴포넌트가 동적으로 업데이트되어 선택된 계정의 세부 정보를 표시하고 싶습니다.\n\n# Salesforce Lightning Message Service의 제한 사항\n\n- LMS는 Salesforce 모바일 앱, AppExchange, Lightning Out 및 Lightning Communities와 통합할 수 있는 능력이 없습니다.\n- LMS는 iframe에서 작동하지 않습니다.\n- LMS는 Salesforce 클래식에서 작동하지 않습니다.\n- Salesforce UI에서 직접 라이트닝 메시지 채널을 생성하는 것을 지원하지 않습니다.\n\n# 결론:\n\n\n\n라이트닝 메시지 서비스(Lightning Message Service)는 Salesforce의 라이트닝 웹 컴포넌트(Lightning Web Components) 간 효율적인 통신을 가능케 하는 강력한 도구입니다. pub-sub 패턴을 구현함으로써 컴포넌트들은 분리된 방식으로 통신할 수 있으며, 이는 라이트닝 애플리케이션의 유연성과 확장성을 향상시킵니다. 올바른 사용법과 이해를 통해 LMS는 Salesforce에서 복잡하고 동적인 사용자 인터페이스를 원활하게 구축할 수 있도록 도와줍니다.\n\n\"더 많은 흥미로운 LWC 주제를 기대해주시고 Salesforce 개발 전문가가 되기 위해 라이트닝 웹 컴포넌트의 세계를 계속 탐험해보세요.\"\n\n즐거운 LWC 코딩하세요!\n\n더 자세한 내용은 아래 링크를 방문해주세요:","ogImage":{"url":"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png"},"coverImage":"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eSalesforce의 Lightning Message Service (LMS)는 돔 계층 구조 전체에서 Lightning Web Components (LWC) 간의 통신을 가능하게 하는 강력한 기능입니다. 이것은 요소가 직계 부모-자식 관계를 필요로하지 않고 서로 통신할 수 있도록 해주므로 복잡한 애플리케이션을 구축하는 유연한 도구입니다. 이 블로그에서는 LWC 간 통신을 위해 LMS를 사용하는 방법과 구현 예시를 살펴볼 것입니다.\u003c/p\u003e\n\u003ch1\u003eLightning Message Service란?\u003c/h1\u003e\n\u003cp\u003eLightning Message Service (LMS)는 Salesforce가 제공하는 통신 프레임워크로, Lightning 페이지의 다른 구성 요소와 Lightning Web Components (LWC) 간에 효과적인 통신을 가능하게 합니다.\u003c/p\u003e\n\u003cp\u003e그것은 계층적 관계에 관계없이 컴포넌트 간에 통신할 수 있도록 해줘서 모듈식이고 연결된 애플리케이션을 쉽게 구축할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eLMS는 컴포넌트가 데이터를 포함하는 메시지를 게시하고, 다른 컴포넌트가 이러한 메시지를 구독하고 반응할 수 있는 방법을 제공합니다. 이러한 분리된 통신 접근 방식은 Lightning 애플리케이션의 유연성과 유지 보수성을 향상시킵니다.\u003c/p\u003e\n\u003cp\u003e아래는 Lightning Message Service Flow 다이어그램입니다. Lightning Message Channels의 도움으로 다양한 컴포넌트 간의 통신을 보여줍니다.\u003c/p\u003e\n\u003ch1\u003e라이트닝 메시지 서비스(LMS) 이해하기:\u003c/h1\u003e\n\u003cp\u003eLMS는 컴포넌트가 메시지(이벤트)를 발행하고 구독하여 해당 메시지를 수신할 수 있는 pub-sub (publish-subscribe) 메시징 패턴을 제공합니다. 이 분리된 통신 메커니즘은 컴포넌트 간의 느슨한 결합을 촉진하여 재사용성과 유지 보수성을 향상시킵니다.\u003c/p\u003e\n\u003cp\u003e라이트닝 메시지 서비스에는 두 가지 주요 개념이 있습니다: 발행자(Publishers)와 구독자(Subscribers).\u003c/p\u003e\n\u003ch2\u003e1. 발행자(Publisher):\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003ePublisher 구성 요소는 특정 메시지 채널로 메시지를 보내는 역할을 합니다.\u003c/li\u003e\n\u003cli\u003e이러한 메시지는 데이터를 전달하거나 비어 있을 수 있으며, 구독자는 이에 따라 반응할 수 있습니다.\u003c/li\u003e\n\u003cli\u003ePublisher 구성 요소를 생성할 때는 \u003ccode\u003e@salesforce/messageChannel\u003c/code\u003e 모듈에서 \u003ccode\u003epublish()\u003c/code\u003e 함수를 import해야 합니다.\u003c/li\u003e\n\u003cli\u003e이 함수를 사용하면 Lightning Message Channel을 통해 메시지를 보낼 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e2. Subscriber:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSubscriber 구성 요소는 특정 메시지 채널을 주시적으로 듣습니다.\u003c/li\u003e\n\u003cli\u003e이 채널에서 메시지가 발행될 때마다 해당 메시지에 응답할 수 있는 모든 구독된 구성 요소가 반응할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e중요한 점은 Subscriber가 Publisher에 대한 구체적인 세부 정보를 알 필요가 없어서 유연하고 느슨하게 결합된 시스템을 유지하는 데 도움이 된다는 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e주의 !\u003c/h2\u003e\n\u003ch1\u003eLWC에서 라이트닝 메시지 서비스(LMS)를 통해 컴포넌트가 어떻게 통신하는지\u003c/h1\u003e\n\u003ch2\u003e메시지 채널 메타데이터 정의:\u003c/h2\u003e\n\u003cp\u003e컴포넌트 간에 통신 채널을 설정하려면 먼저 Salesforce 조직에서 메시지 채널 메타데이터를 정의해야합니다. 아래 단계를 따르세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSalesforce 프로젝트 구조의 \u003ccode\u003eforce-app/main/default\u003c/code\u003e 하위에 \"messageChannels\"라는 폴더를 생성해주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\n\u003cp\u003e이 폴더 안에 \"messageChannelName.messageChannel-meta.xml\" 형식의 XML 파일을 만들어주세요. 여기서 \"messageChannelName\"을 원하는 채널 이름으로 바꿔주세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e아래 코드를 참고하여 .xml 파일에 \u003ccode\u003elightning message field\u003c/code\u003e를 정의해주세요:\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003esampleMessageChannel.messageChannel-meta.xml\u003c/p\u003e\n\u003cp\u003emd\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;!--?xml version=\u003cspan class=\"hljs-string\"\u003e\"1.0\"\u003c/span\u003e encoding=\u003cspan class=\"hljs-string\"\u003e\"UTF-8\"\u003c/span\u003e?--\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003elightningmessagechannel\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003exmlns\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"http://soap.sforce.com/2006/04/metadata\"\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003emasterlabel\u003c/span\u003e\u003e\u003c/span\u003eSampleMessageChannel\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003emasterlabel\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eisexposed\u003c/span\u003e\u003e\u003c/span\u003etrue\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eisexposed\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003edescription\u003c/span\u003e\u003e\u003c/span\u003eThis is a sample Lightning Message Channel.\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003edescription\u003c/span\u003e\u003e\u003c/span\u003e\n     \n    \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- Define message payload fields --\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003elightningmessagefields\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003efieldname\u003c/span\u003e\u003e\u003c/span\u003erecordId\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003efieldname\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003edescription\u003c/span\u003e\u003e\u003c/span\u003eThis is the record Id that changed\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003edescription\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003elightningmessagefields\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003elightningmessagefields\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003efieldname\u003c/span\u003e\u003e\u003c/span\u003erecordData\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003efieldname\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003edescription\u003c/span\u003e\u003e\u003c/span\u003eThe current data representing the record that changed\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003edescription\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003elightningmessagefields\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003elightningmessagechannel\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e설명:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eisExposed\u003c/code\u003e 태그는 컴포넌트를 사용할 수 있게 만드는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elightningMessageFields\u003c/code\u003e 태그를 사용하여 필드를 정의하는데 특정 정보를 전달할 수 있습니다. 예를 들어 \u003ccode\u003erecordId\u003c/code\u003e를 정의할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edescription\u003c/code\u003e 태그를 사용하여 Lightning 메시지 채널에 대한 설명을 추가하면 이 메시지 채널을 만드는 목표에 대해 설명할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.messageChannel-meta.xml\u003c/code\u003e 파일이 작성되면 Salesforce org에 배포하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e메시지 서비스 기능 가져오기:\u003c/h2\u003e\n\u003cp\u003e번역 :\u003c/p\u003e\n\u003cp\u003e당신의 Lightning 웹 컴포넌트에서 필요한 메시지 서비스 기능을 다음과 같이 가져오세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { publish, subscribe, unsubscribe, \u003cspan class=\"hljs-variable constant_\"\u003eAPPLICATION_SCOPE\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eMessageContext\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'lightning/messageService'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e msgService \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@salesforce/messageChannel/messageChannelName__c'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e메시지 서비스 범위 정의:\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e@wire 어댑터\u003c/code\u003e를 사용하여 메시지 서비스의 범위를 정의할 수 있습니다.\n라이트닝 웹 컴포넌트에서는 \u003ccode\u003e@wire 어댑터\u003c/code\u003e로만 스코핑이 가능합니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title function_\"\u003ewire\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMessageContext\u003c/span\u003e)\nmessageContext;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e메시지 채널 발행:\u003c/h1\u003e\n\u003cp\u003e메시지 채널에 메시지를 발행하려면 라이트닝 메시지 서비스의 \u003ccode\u003epublish()\u003c/code\u003e 메서드를 사용하십시오. 이 메서드는 메시지 컨텍스트, 메시지 채널, 메시지 페이로드를 매개변수로 받습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e messagePayload = {\n    \u003cspan class=\"hljs-attr\"\u003erecordId\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'0012y00000L5R6jAAF'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003erecordData\u003c/span\u003e: { \u003cspan class=\"hljs-comment\"\u003e/* 레코드를 나타내는 데이터 */\u003c/span\u003e }\n};\n\u003cspan class=\"hljs-title function_\"\u003epublish\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessageContext\u003c/span\u003e, msgService, messagePayload);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epublish()\u003c/code\u003e 메소드는 3개의 파라미터를 받습니다 :\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e메시지 컨텍스트 (객체 타입)\u003c/li\u003e\n\u003cli\u003e메시지 채널 (객체 타입)\u003c/li\u003e\n\u003cli\u003e메시지 페이로드 (메시지 페이로드는 JSON 객체입니다)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003emessageContext : \u003ccode\u003eMessageContext\u003c/code\u003e 객체는 Lightning 메시지 서비스를 사용하는 Lightning 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 \u003ccode\u003eMessageContext\u003c/code\u003e 와이어 어댑터나 \u003ccode\u003ecreateMessageContext()\u003c/code\u003e를 통해 가져올 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title function_\"\u003ewire\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMessageContext\u003c/span\u003e)\nmessageContext\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emessageChannel: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 \u003ccode\u003e@salesforce/messageChannel\u003c/code\u003e과 같은 scoped 모듈을 사용하세요. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하세요.\u003c/p\u003e\n\u003cp\u003emessage: 가입자에게 발행된 메시지를 포함하는 직렬화 가능한 JSON 객체입니다. 메시지에는 함수나 심볼을 포함할 수 없습니다.\u003c/p\u003e\n\u003ch1\u003e메시지 채널 구독:\u003c/h1\u003e\n\u003cp\u003e특정 메시지 채널의 메시지를 구독하려면 \u003ccode\u003esubscribe()\u003c/code\u003e 메서드를 사용하세요. 받은 메시지를 처리하기 위한 리스너 함수를 제공해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esubscription\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessageContext\u003c/span\u003e,\n    msgService,\n    \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emessage\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehandleMessage\u003c/span\u003e(message)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003esubscribe()\u003c/code\u003e 메서드는 4개의 매개변수를 받습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e메시지 컨텍스트 (객체 형식)\u003c/li\u003e\n\u003cli\u003e메시지 채널 (객체 형식)\u003c/li\u003e\n\u003cli\u003e리스너 (함수 형식)\u003c/li\u003e\n\u003cli\u003e구독자 옵션 (객체 형식)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e메시지 컨텍스트: \u003ccode\u003eMessageContext\u003c/code\u003e 객체는 라이트닝 메시지 서비스를 사용하는 라이트닝 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 \u003ccode\u003eMessageContext\u003c/code\u003e 와이어 어댑터를 통해 가져오거나 \u003ccode\u003ecreateMessageContext()\u003c/code\u003e를 통해 가져올 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title function_\"\u003ewire\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMessageContext\u003c/span\u003e)\nmessageContext\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e메시지 채널: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 scoped 모듈인 \u003ccode\u003e@salesforce/messageChannel\u003c/code\u003e을 사용하십시오. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하십시오.\u003c/p\u003e\n\u003cp\u003e리스너: 발행된 메시지를 처리하는 함수입니다.\u003c/p\u003e\n\u003cp\u003esubscriberOptions: (선택 사항) 이 객체는 \u003ccode\u003e'scope: APPLICATION_SCOPE'\u003c/code\u003e로 설정되었을 때, 애플리케이션 전반에서 메시지 채널에서 메시지를 수신할 수 있는 능력을 지정합니다. \u003ccode\u003elightning/messageService\u003c/code\u003e에서 \u003ccode\u003eAPPLICATION_SCOPE\u003c/code\u003e를 가져와야 합니다.\u003c/p\u003e\n\u003ch1\u003e메시지 채널 구독 취소:\u003c/h1\u003e\n\u003cp\u003e메시지 채널 구독을 취소하려면 \u003ccode\u003eunsubscribe()\u003c/code\u003e 메서드를 사용하고, \u003ccode\u003esubscribe()\u003c/code\u003e 함수에 의해 반환된 구독 객체를 제공하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eunsubscribe\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esubscription\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eSalesforce Lightning Message Service를 언제 사용해야 할까요?\u003c/h1\u003e\n\u003cp\u003e라이트닝 메시지 서비스는 Visualforce 페이지, Aura 및 LWC 간에 정보를 교환하거나 전달하는 방법입니다. LMS는 특히 구성 요소가 구성 요소 계층구조에서 직접적으로 관련되어 있지 않지만 서로 상호 작용해야 하는 시나리오에서 유용합니다. 다음은 LMS를 사용할 수 있는 몇 가지 상황입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e부모-자식 구성 요소 간 통신: 부모 구성 요소와 여러 자식 구성 요소가 있고, 이들 간에 데이터를 전달하거나 작업을 트리거하려는 경우입니다.\u003c/li\u003e\n\u003cli\u003e동료 구성 요소 간 통신: 페이지에 동료 구성 요소가 있고, 이들의 상태를 동기화하거나 데이터를 공유해야 하는 경우입니다.\u003c/li\u003e\n\u003cli\u003e크로스 도메인 통신: 관리되는 패키지와 사용자 지정 구성 요소와 같이 서로 다른 네임스페이스에 거주하는 구성 요소 간에 통신해야 하는 경우입니다.\u003c/li\u003e\n\u003cli\u003e동적 구성 요소 간 통신: 구성 요소가 런타임에서 동적으로 생성되거나 파괴되고, 이들 사이에 통신 채널을 설정할 유연한 방법이 필요한 경우입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음은 Lightning Message Service의 사용 예시 시나리오입니다:\u003c/p\u003e\n\u003cp\u003e당신이 Lightning 페이지에서 두 개의 컴포넌트를 가지고 있는 상황을 상상해봅시다: 계정 목록을 표시하는 부모 컴포넌트와 선택된 계정의 세부 정보를 보여주는 자식 컴포넌트가 있습니다. 사용자가 부모 컴포넌트에서 계정을 선택할 때, 자식 컴포넌트가 동적으로 업데이트되어 선택된 계정의 세부 정보를 표시하고 싶습니다.\u003c/p\u003e\n\u003ch1\u003eSalesforce Lightning Message Service의 제한 사항\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eLMS는 Salesforce 모바일 앱, AppExchange, Lightning Out 및 Lightning Communities와 통합할 수 있는 능력이 없습니다.\u003c/li\u003e\n\u003cli\u003eLMS는 iframe에서 작동하지 않습니다.\u003c/li\u003e\n\u003cli\u003eLMS는 Salesforce 클래식에서 작동하지 않습니다.\u003c/li\u003e\n\u003cli\u003eSalesforce UI에서 직접 라이트닝 메시지 채널을 생성하는 것을 지원하지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e결론:\u003c/h1\u003e\n\u003cp\u003e라이트닝 메시지 서비스(Lightning Message Service)는 Salesforce의 라이트닝 웹 컴포넌트(Lightning Web Components) 간 효율적인 통신을 가능케 하는 강력한 도구입니다. pub-sub 패턴을 구현함으로써 컴포넌트들은 분리된 방식으로 통신할 수 있으며, 이는 라이트닝 애플리케이션의 유연성과 확장성을 향상시킵니다. 올바른 사용법과 이해를 통해 LMS는 Salesforce에서 복잡하고 동적인 사용자 인터페이스를 원활하게 구축할 수 있도록 도와줍니다.\u003c/p\u003e\n\u003cp\u003e\"더 많은 흥미로운 LWC 주제를 기대해주시고 Salesforce 개발 전문가가 되기 위해 라이트닝 웹 컴포넌트의 세계를 계속 탐험해보세요.\"\u003c/p\u003e\n\u003cp\u003e즐거운 LWC 코딩하세요!\u003c/p\u003e\n\u003cp\u003e더 자세한 내용은 아래 링크를 방문해주세요:\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-CommunicationThroughLMSinLWC"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>