<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>LWC에서 LMS를 통한 커뮤니케이션 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-CommunicationThroughLMSinLWC" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="LWC에서 LMS를 통한 커뮤니케이션 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="LWC에서 LMS를 통한 커뮤니케이션 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-CommunicationThroughLMSinLWC" data-gatsby-head="true"/><meta name="twitter:title" content="LWC에서 LMS를 통한 커뮤니케이션 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 13:20" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_buildManifest.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">LWC에서 LMS를 통한 커뮤니케이션</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="LWC에서 LMS를 통한 커뮤니케이션" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-CommunicationThroughLMSinLWC&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png" alt="이미지"/></p>
<p>Salesforce의 Lightning Message Service (LMS)는 돔 계층 구조 전체에서 Lightning Web Components (LWC) 간의 통신을 가능하게 하는 강력한 기능입니다. 이것은 요소가 직계 부모-자식 관계를 필요로하지 않고 서로 통신할 수 있도록 해주므로 복잡한 애플리케이션을 구축하는 유연한 도구입니다. 이 블로그에서는 LWC 간 통신을 위해 LMS를 사용하는 방법과 구현 예시를 살펴볼 것입니다.</p>
<h1>Lightning Message Service란?</h1>
<p>Lightning Message Service (LMS)는 Salesforce가 제공하는 통신 프레임워크로, Lightning 페이지의 다른 구성 요소와 Lightning Web Components (LWC) 간에 효과적인 통신을 가능하게 합니다.</p>
<p>그것은 계층적 관계에 관계없이 컴포넌트 간에 통신할 수 있도록 해줘서 모듈식이고 연결된 애플리케이션을 쉽게 구축할 수 있습니다.</p>
<p>LMS는 컴포넌트가 데이터를 포함하는 메시지를 게시하고, 다른 컴포넌트가 이러한 메시지를 구독하고 반응할 수 있는 방법을 제공합니다. 이러한 분리된 통신 접근 방식은 Lightning 애플리케이션의 유연성과 유지 보수성을 향상시킵니다.</p>
<p>아래는 Lightning Message Service Flow 다이어그램입니다. Lightning Message Channels의 도움으로 다양한 컴포넌트 간의 통신을 보여줍니다.</p>
<h1>라이트닝 메시지 서비스(LMS) 이해하기:</h1>
<p>LMS는 컴포넌트가 메시지(이벤트)를 발행하고 구독하여 해당 메시지를 수신할 수 있는 pub-sub (publish-subscribe) 메시징 패턴을 제공합니다. 이 분리된 통신 메커니즘은 컴포넌트 간의 느슨한 결합을 촉진하여 재사용성과 유지 보수성을 향상시킵니다.</p>
<p>라이트닝 메시지 서비스에는 두 가지 주요 개념이 있습니다: 발행자(Publishers)와 구독자(Subscribers).</p>
<h2>1. 발행자(Publisher):</h2>
<ul>
<li>Publisher 구성 요소는 특정 메시지 채널로 메시지를 보내는 역할을 합니다.</li>
<li>이러한 메시지는 데이터를 전달하거나 비어 있을 수 있으며, 구독자는 이에 따라 반응할 수 있습니다.</li>
<li>Publisher 구성 요소를 생성할 때는 <code>@salesforce/messageChannel</code> 모듈에서 <code>publish()</code> 함수를 import해야 합니다.</li>
<li>이 함수를 사용하면 Lightning Message Channel을 통해 메시지를 보낼 수 있습니다.</li>
</ul>
<h2>2. Subscriber:</h2>
<ul>
<li>Subscriber 구성 요소는 특정 메시지 채널을 주시적으로 듣습니다.</li>
<li>이 채널에서 메시지가 발행될 때마다 해당 메시지에 응답할 수 있는 모든 구독된 구성 요소가 반응할 수 있습니다.</li>
<li>중요한 점은 Subscriber가 Publisher에 대한 구체적인 세부 정보를 알 필요가 없어서 유연하고 느슨하게 결합된 시스템을 유지하는 데 도움이 된다는 것입니다.</li>
</ul>
<p><img src="/assets/img/2024-05-14-CommunicationThroughLMSinLWC_2.png" alt="이미지"/></p>
<h2>주의 !</h2>
<h1>LWC에서 라이트닝 메시지 서비스(LMS)를 통해 컴포넌트가 어떻게 통신하는지</h1>
<h2>메시지 채널 메타데이터 정의:</h2>
<p>컴포넌트 간에 통신 채널을 설정하려면 먼저 Salesforce 조직에서 메시지 채널 메타데이터를 정의해야합니다. 아래 단계를 따르세요:</p>
<ul>
<li>Salesforce 프로젝트 구조의 <code>force-app/main/default</code> 하위에 &quot;messageChannels&quot;라는 폴더를 생성해주세요.</li>
</ul>
<ol start="2">
<li>
<p>이 폴더 안에 &quot;messageChannelName.messageChannel-meta.xml&quot; 형식의 XML 파일을 만들어주세요. 여기서 &quot;messageChannelName&quot;을 원하는 채널 이름으로 바꿔주세요.</p>
</li>
<li>
<p>아래 코드를 참고하여 .xml 파일에 <code>lightning message field</code>를 정의해주세요:</p>
</li>
</ol>
<p>sampleMessageChannel.messageChannel-meta.xml</p>
<p>md</p>
<pre><code class="hljs language-js">&lt;!--?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?--&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">lightningmessagechannel</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://soap.sforce.com/2006/04/metadata&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">masterlabel</span>&gt;</span>SampleMessageChannel<span class="hljs-tag">&lt;/<span class="hljs-name">masterlabel</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">isexposed</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">isexposed</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>This is a sample Lightning Message Channel.<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>
     
    <span class="hljs-comment">&lt;!-- Define message payload fields --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">lightningmessagefields</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">fieldname</span>&gt;</span>recordId<span class="hljs-tag">&lt;/<span class="hljs-name">fieldname</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>This is the record Id that changed<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">lightningmessagefields</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">lightningmessagefields</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">fieldname</span>&gt;</span>recordData<span class="hljs-tag">&lt;/<span class="hljs-name">fieldname</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>The current data representing the record that changed<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">lightningmessagefields</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">lightningmessagechannel</span>&gt;</span></span>
</code></pre>
<h2>설명:</h2>
<ul>
<li><code>isExposed</code> 태그는 컴포넌트를 사용할 수 있게 만드는 데 사용됩니다.</li>
<li><code>lightningMessageFields</code> 태그를 사용하여 필드를 정의하는데 특정 정보를 전달할 수 있습니다. 예를 들어 <code>recordId</code>를 정의할 수 있습니다.</li>
<li><code>description</code> 태그를 사용하여 Lightning 메시지 채널에 대한 설명을 추가하면 이 메시지 채널을 만드는 목표에 대해 설명할 수 있습니다.</li>
<li><code>.messageChannel-meta.xml</code> 파일이 작성되면 Salesforce org에 배포하세요.</li>
</ul>
<h2>메시지 서비스 기능 가져오기:</h2>
<p>번역 :</p>
<p>당신의 Lightning 웹 컴포넌트에서 필요한 메시지 서비스 기능을 다음과 같이 가져오세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { publish, subscribe, unsubscribe, <span class="hljs-variable constant_">APPLICATION_SCOPE</span>, <span class="hljs-title class_">MessageContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lightning/messageService&#x27;</span>;
<span class="hljs-keyword">import</span> msgService <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@salesforce/messageChannel/messageChannelName__c&#x27;</span>;
</code></pre>
<h2>메시지 서비스 범위 정의:</h2>
<p><code>@wire 어댑터</code>를 사용하여 메시지 서비스의 범위를 정의할 수 있습니다.
라이트닝 웹 컴포넌트에서는 <code>@wire 어댑터</code>로만 스코핑이 가능합니다.</p>
<p>예시:</p>
<pre><code class="hljs language-js">@<span class="hljs-title function_">wire</span>(<span class="hljs-title class_">MessageContext</span>)
messageContext;
</code></pre>
<h1>메시지 채널 발행:</h1>
<p>메시지 채널에 메시지를 발행하려면 라이트닝 메시지 서비스의 <code>publish()</code> 메서드를 사용하십시오. 이 메서드는 메시지 컨텍스트, 메시지 채널, 메시지 페이로드를 매개변수로 받습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> messagePayload = {
    <span class="hljs-attr">recordId</span>: <span class="hljs-string">&#x27;0012y00000L5R6jAAF&#x27;</span>,
    <span class="hljs-attr">recordData</span>: { <span class="hljs-comment">/* 레코드를 나타내는 데이터 */</span> }
};
<span class="hljs-title function_">publish</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">messageContext</span>, msgService, messagePayload);
</code></pre>
<p><code>publish()</code> 메소드는 3개의 파라미터를 받습니다 :</p>
<ul>
<li>메시지 컨텍스트 (객체 타입)</li>
<li>메시지 채널 (객체 타입)</li>
<li>메시지 페이로드 (메시지 페이로드는 JSON 객체입니다)</li>
</ul>
<p>messageContext : <code>MessageContext</code> 객체는 Lightning 메시지 서비스를 사용하는 Lightning 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 <code>MessageContext</code> 와이어 어댑터나 <code>createMessageContext()</code>를 통해 가져올 수 있습니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title function_">wire</span>(<span class="hljs-title class_">MessageContext</span>)
messageContext
</code></pre>
<p>messageChannel: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 <code>@salesforce/messageChannel</code>과 같은 scoped 모듈을 사용하세요. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하세요.</p>
<p>message: 가입자에게 발행된 메시지를 포함하는 직렬화 가능한 JSON 객체입니다. 메시지에는 함수나 심볼을 포함할 수 없습니다.</p>
<h1>메시지 채널 구독:</h1>
<p>특정 메시지 채널의 메시지를 구독하려면 <code>subscribe()</code> 메서드를 사용하세요. 받은 메시지를 처리하기 위한 리스너 함수를 제공해주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">subscription</span> = <span class="hljs-title function_">subscribe</span>(
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">messageContext</span>,
    msgService,
    <span class="hljs-function">(<span class="hljs-params">message</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleMessage</span>(message)
);
</code></pre>
<p><code>subscribe()</code> 메서드는 4개의 매개변수를 받습니다:</p>
<ul>
<li>메시지 컨텍스트 (객체 형식)</li>
<li>메시지 채널 (객체 형식)</li>
<li>리스너 (함수 형식)</li>
<li>구독자 옵션 (객체 형식)</li>
</ul>
<p>메시지 컨텍스트: <code>MessageContext</code> 객체는 라이트닝 메시지 서비스를 사용하는 라이트닝 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 <code>MessageContext</code> 와이어 어댑터를 통해 가져오거나 <code>createMessageContext()</code>를 통해 가져올 수 있습니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title function_">wire</span>(<span class="hljs-title class_">MessageContext</span>)
messageContext
</code></pre>
<p>메시지 채널: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 scoped 모듈인 <code>@salesforce/messageChannel</code>을 사용하십시오. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하십시오.</p>
<p>리스너: 발행된 메시지를 처리하는 함수입니다.</p>
<p>subscriberOptions: (선택 사항) 이 객체는 <code>&#x27;scope: APPLICATION_SCOPE&#x27;</code>로 설정되었을 때, 애플리케이션 전반에서 메시지 채널에서 메시지를 수신할 수 있는 능력을 지정합니다. <code>lightning/messageService</code>에서 <code>APPLICATION_SCOPE</code>를 가져와야 합니다.</p>
<h1>메시지 채널 구독 취소:</h1>
<p>메시지 채널 구독을 취소하려면 <code>unsubscribe()</code> 메서드를 사용하고, <code>subscribe()</code> 함수에 의해 반환된 구독 객체를 제공하면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">unsubscribe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">subscription</span>);
</code></pre>
<h1>Salesforce Lightning Message Service를 언제 사용해야 할까요?</h1>
<p>라이트닝 메시지 서비스는 Visualforce 페이지, Aura 및 LWC 간에 정보를 교환하거나 전달하는 방법입니다. LMS는 특히 구성 요소가 구성 요소 계층구조에서 직접적으로 관련되어 있지 않지만 서로 상호 작용해야 하는 시나리오에서 유용합니다. 다음은 LMS를 사용할 수 있는 몇 가지 상황입니다:</p>
<ul>
<li>부모-자식 구성 요소 간 통신: 부모 구성 요소와 여러 자식 구성 요소가 있고, 이들 간에 데이터를 전달하거나 작업을 트리거하려는 경우입니다.</li>
<li>동료 구성 요소 간 통신: 페이지에 동료 구성 요소가 있고, 이들의 상태를 동기화하거나 데이터를 공유해야 하는 경우입니다.</li>
<li>크로스 도메인 통신: 관리되는 패키지와 사용자 지정 구성 요소와 같이 서로 다른 네임스페이스에 거주하는 구성 요소 간에 통신해야 하는 경우입니다.</li>
<li>동적 구성 요소 간 통신: 구성 요소가 런타임에서 동적으로 생성되거나 파괴되고, 이들 사이에 통신 채널을 설정할 유연한 방법이 필요한 경우입니다.</li>
</ul>
<p>다음은 Lightning Message Service의 사용 예시 시나리오입니다:</p>
<p>당신이 Lightning 페이지에서 두 개의 컴포넌트를 가지고 있는 상황을 상상해봅시다: 계정 목록을 표시하는 부모 컴포넌트와 선택된 계정의 세부 정보를 보여주는 자식 컴포넌트가 있습니다. 사용자가 부모 컴포넌트에서 계정을 선택할 때, 자식 컴포넌트가 동적으로 업데이트되어 선택된 계정의 세부 정보를 표시하고 싶습니다.</p>
<h1>Salesforce Lightning Message Service의 제한 사항</h1>
<ul>
<li>LMS는 Salesforce 모바일 앱, AppExchange, Lightning Out 및 Lightning Communities와 통합할 수 있는 능력이 없습니다.</li>
<li>LMS는 iframe에서 작동하지 않습니다.</li>
<li>LMS는 Salesforce 클래식에서 작동하지 않습니다.</li>
<li>Salesforce UI에서 직접 라이트닝 메시지 채널을 생성하는 것을 지원하지 않습니다.</li>
</ul>
<h1>결론:</h1>
<p>라이트닝 메시지 서비스(Lightning Message Service)는 Salesforce의 라이트닝 웹 컴포넌트(Lightning Web Components) 간 효율적인 통신을 가능케 하는 강력한 도구입니다. pub-sub 패턴을 구현함으로써 컴포넌트들은 분리된 방식으로 통신할 수 있으며, 이는 라이트닝 애플리케이션의 유연성과 확장성을 향상시킵니다. 올바른 사용법과 이해를 통해 LMS는 Salesforce에서 복잡하고 동적인 사용자 인터페이스를 원활하게 구축할 수 있도록 도와줍니다.</p>
<p>&quot;더 많은 흥미로운 LWC 주제를 기대해주시고 Salesforce 개발 전문가가 되기 위해 라이트닝 웹 컴포넌트의 세계를 계속 탐험해보세요.&quot;</p>
<p>즐거운 LWC 코딩하세요!</p>
<p>더 자세한 내용은 아래 링크를 방문해주세요:</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"LWC에서 LMS를 통한 커뮤니케이션","description":"","date":"2024-05-14 13:20","slug":"2024-05-14-CommunicationThroughLMSinLWC","content":"\n\n\n![이미지](/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png)\n\nSalesforce의 Lightning Message Service (LMS)는 돔 계층 구조 전체에서 Lightning Web Components (LWC) 간의 통신을 가능하게 하는 강력한 기능입니다. 이것은 요소가 직계 부모-자식 관계를 필요로하지 않고 서로 통신할 수 있도록 해주므로 복잡한 애플리케이션을 구축하는 유연한 도구입니다. 이 블로그에서는 LWC 간 통신을 위해 LMS를 사용하는 방법과 구현 예시를 살펴볼 것입니다.\n\n# Lightning Message Service란?\n\nLightning Message Service (LMS)는 Salesforce가 제공하는 통신 프레임워크로, Lightning 페이지의 다른 구성 요소와 Lightning Web Components (LWC) 간에 효과적인 통신을 가능하게 합니다.\n\n\n\n\n그것은 계층적 관계에 관계없이 컴포넌트 간에 통신할 수 있도록 해줘서 모듈식이고 연결된 애플리케이션을 쉽게 구축할 수 있습니다.\n\nLMS는 컴포넌트가 데이터를 포함하는 메시지를 게시하고, 다른 컴포넌트가 이러한 메시지를 구독하고 반응할 수 있는 방법을 제공합니다. 이러한 분리된 통신 접근 방식은 Lightning 애플리케이션의 유연성과 유지 보수성을 향상시킵니다.\n\n아래는 Lightning Message Service Flow 다이어그램입니다. Lightning Message Channels의 도움으로 다양한 컴포넌트 간의 통신을 보여줍니다.\n\n\n\n# 라이트닝 메시지 서비스(LMS) 이해하기:\n\nLMS는 컴포넌트가 메시지(이벤트)를 발행하고 구독하여 해당 메시지를 수신할 수 있는 pub-sub (publish-subscribe) 메시징 패턴을 제공합니다. 이 분리된 통신 메커니즘은 컴포넌트 간의 느슨한 결합을 촉진하여 재사용성과 유지 보수성을 향상시킵니다.\n\n라이트닝 메시지 서비스에는 두 가지 주요 개념이 있습니다: 발행자(Publishers)와 구독자(Subscribers).\n\n## 1. 발행자(Publisher):\n\n\n\n- Publisher 구성 요소는 특정 메시지 채널로 메시지를 보내는 역할을 합니다.\n- 이러한 메시지는 데이터를 전달하거나 비어 있을 수 있으며, 구독자는 이에 따라 반응할 수 있습니다.\n- Publisher 구성 요소를 생성할 때는 `@salesforce/messageChannel` 모듈에서 `publish()` 함수를 import해야 합니다.\n- 이 함수를 사용하면 Lightning Message Channel을 통해 메시지를 보낼 수 있습니다.\n\n## 2. Subscriber:\n\n- Subscriber 구성 요소는 특정 메시지 채널을 주시적으로 듣습니다.\n- 이 채널에서 메시지가 발행될 때마다 해당 메시지에 응답할 수 있는 모든 구독된 구성 요소가 반응할 수 있습니다.\n- 중요한 점은 Subscriber가 Publisher에 대한 구체적인 세부 정보를 알 필요가 없어서 유연하고 느슨하게 결합된 시스템을 유지하는 데 도움이 된다는 것입니다.\n\n![이미지](/assets/img/2024-05-14-CommunicationThroughLMSinLWC_2.png)\n\n\n\n## 주의 !\n\n# LWC에서 라이트닝 메시지 서비스(LMS)를 통해 컴포넌트가 어떻게 통신하는지\n\n## 메시지 채널 메타데이터 정의:\n\n컴포넌트 간에 통신 채널을 설정하려면 먼저 Salesforce 조직에서 메시지 채널 메타데이터를 정의해야합니다. 아래 단계를 따르세요:\n\n\n\n- Salesforce 프로젝트 구조의 `force-app/main/default` 하위에 \"messageChannels\"라는 폴더를 생성해주세요.\n\n2. 이 폴더 안에 \"messageChannelName.messageChannel-meta.xml\" 형식의 XML 파일을 만들어주세요. 여기서 \"messageChannelName\"을 원하는 채널 이름으로 바꿔주세요.\n\n3. 아래 코드를 참고하여 .xml 파일에 `lightning message field`를 정의해주세요:\n\n\nsampleMessageChannel.messageChannel-meta.xml\n\n\n\n\nmd\n```js\n\u003c!--?xml version=\"1.0\" encoding=\"UTF-8\"?--\u003e\n\u003clightningmessagechannel xmlns=\"http://soap.sforce.com/2006/04/metadata\"\u003e\n    \u003cmasterlabel\u003eSampleMessageChannel\u003c/masterlabel\u003e\n    \u003cisexposed\u003etrue\u003c/isexposed\u003e\n    \u003cdescription\u003eThis is a sample Lightning Message Channel.\u003c/description\u003e\n     \n    \u003c!-- Define message payload fields --\u003e\n    \u003clightningmessagefields\u003e\n        \u003cfieldname\u003erecordId\u003c/fieldname\u003e\n        \u003cdescription\u003eThis is the record Id that changed\u003c/description\u003e\n    \u003c/lightningmessagefields\u003e\n    \u003clightningmessagefields\u003e\n        \u003cfieldname\u003erecordData\u003c/fieldname\u003e\n        \u003cdescription\u003eThe current data representing the record that changed\u003c/description\u003e\n    \u003c/lightningmessagefields\u003e\n\u003c/lightningmessagechannel\u003e\n```\n\n## 설명:\n\n- `isExposed` 태그는 컴포넌트를 사용할 수 있게 만드는 데 사용됩니다.\n- `lightningMessageFields` 태그를 사용하여 필드를 정의하는데 특정 정보를 전달할 수 있습니다. 예를 들어 `recordId`를 정의할 수 있습니다.\n- `description` 태그를 사용하여 Lightning 메시지 채널에 대한 설명을 추가하면 이 메시지 채널을 만드는 목표에 대해 설명할 수 있습니다.\n- `.messageChannel-meta.xml` 파일이 작성되면 Salesforce org에 배포하세요.\n\n## 메시지 서비스 기능 가져오기:\n\n\n\n\n번역 : \n\n당신의 Lightning 웹 컴포넌트에서 필요한 메시지 서비스 기능을 다음과 같이 가져오세요:\n\n```js\nimport { publish, subscribe, unsubscribe, APPLICATION_SCOPE, MessageContext } from 'lightning/messageService';\nimport msgService from '@salesforce/messageChannel/messageChannelName__c';\n```\n\n## 메시지 서비스 범위 정의:\n\n`@wire 어댑터`를 사용하여 메시지 서비스의 범위를 정의할 수 있습니다.\n라이트닝 웹 컴포넌트에서는 `@wire 어댑터`로만 스코핑이 가능합니다.\n\n\n\n예시:\n\n```js\n@wire(MessageContext)\nmessageContext;\n```\n\n# 메시지 채널 발행:\n\n메시지 채널에 메시지를 발행하려면 라이트닝 메시지 서비스의 `publish()` 메서드를 사용하십시오. 이 메서드는 메시지 컨텍스트, 메시지 채널, 메시지 페이로드를 매개변수로 받습니다.\n\n\n\n```js\nconst messagePayload = {\n    recordId: '0012y00000L5R6jAAF',\n    recordData: { /* 레코드를 나타내는 데이터 */ }\n};\npublish(this.messageContext, msgService, messagePayload);\n```\n\n`publish()` 메소드는 3개의 파라미터를 받습니다 :\n\n- 메시지 컨텍스트 (객체 타입)\n- 메시지 채널 (객체 타입)\n- 메시지 페이로드 (메시지 페이로드는 JSON 객체입니다)\n\nmessageContext : `MessageContext` 객체는 Lightning 메시지 서비스를 사용하는 Lightning 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 `MessageContext` 와이어 어댑터나 `createMessageContext()`를 통해 가져올 수 있습니다.\n\n\n\n```js\n@wire(MessageContext)\nmessageContext\n```\n\nmessageChannel: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 `@salesforce/messageChannel`과 같은 scoped 모듈을 사용하세요. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하세요.\n\nmessage: 가입자에게 발행된 메시지를 포함하는 직렬화 가능한 JSON 객체입니다. 메시지에는 함수나 심볼을 포함할 수 없습니다.\n\n# 메시지 채널 구독:\n\n\n\n특정 메시지 채널의 메시지를 구독하려면 `subscribe()` 메서드를 사용하세요. 받은 메시지를 처리하기 위한 리스너 함수를 제공해주세요.\n\n```js\nthis.subscription = subscribe(\n    this.messageContext,\n    msgService,\n    (message) =\u003e this.handleMessage(message)\n);\n```\n\n`subscribe()` 메서드는 4개의 매개변수를 받습니다:\n\n- 메시지 컨텍스트 (객체 형식)\n- 메시지 채널 (객체 형식)\n- 리스너 (함수 형식)\n- 구독자 옵션 (객체 형식)\n\n\n\n메시지 컨텍스트: `MessageContext` 객체는 라이트닝 메시지 서비스를 사용하는 라이트닝 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 `MessageContext` 와이어 어댑터를 통해 가져오거나 `createMessageContext()`를 통해 가져올 수 있습니다.\n\n```js\n@wire(MessageContext)\nmessageContext\n```\n\n메시지 채널: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 scoped 모듈인 `@salesforce/messageChannel`을 사용하십시오. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하십시오.\n\n리스너: 발행된 메시지를 처리하는 함수입니다.\n\n\n\nsubscriberOptions: (선택 사항) 이 객체는 `'scope: APPLICATION_SCOPE'`로 설정되었을 때, 애플리케이션 전반에서 메시지 채널에서 메시지를 수신할 수 있는 능력을 지정합니다. `lightning/messageService`에서 `APPLICATION_SCOPE`를 가져와야 합니다.\n\n# 메시지 채널 구독 취소:\n\n메시지 채널 구독을 취소하려면 `unsubscribe()` 메서드를 사용하고, `subscribe()` 함수에 의해 반환된 구독 객체를 제공하면 됩니다.\n\n```js\nunsubscribe(this.subscription);\n```\n\n\n\n# Salesforce Lightning Message Service를 언제 사용해야 할까요?\n\n라이트닝 메시지 서비스는 Visualforce 페이지, Aura 및 LWC 간에 정보를 교환하거나 전달하는 방법입니다. LMS는 특히 구성 요소가 구성 요소 계층구조에서 직접적으로 관련되어 있지 않지만 서로 상호 작용해야 하는 시나리오에서 유용합니다. 다음은 LMS를 사용할 수 있는 몇 가지 상황입니다:\n\n- 부모-자식 구성 요소 간 통신: 부모 구성 요소와 여러 자식 구성 요소가 있고, 이들 간에 데이터를 전달하거나 작업을 트리거하려는 경우입니다.\n- 동료 구성 요소 간 통신: 페이지에 동료 구성 요소가 있고, 이들의 상태를 동기화하거나 데이터를 공유해야 하는 경우입니다.\n- 크로스 도메인 통신: 관리되는 패키지와 사용자 지정 구성 요소와 같이 서로 다른 네임스페이스에 거주하는 구성 요소 간에 통신해야 하는 경우입니다.\n- 동적 구성 요소 간 통신: 구성 요소가 런타임에서 동적으로 생성되거나 파괴되고, 이들 사이에 통신 채널을 설정할 유연한 방법이 필요한 경우입니다.\n\n다음은 Lightning Message Service의 사용 예시 시나리오입니다:\n\n\n\n당신이 Lightning 페이지에서 두 개의 컴포넌트를 가지고 있는 상황을 상상해봅시다: 계정 목록을 표시하는 부모 컴포넌트와 선택된 계정의 세부 정보를 보여주는 자식 컴포넌트가 있습니다. 사용자가 부모 컴포넌트에서 계정을 선택할 때, 자식 컴포넌트가 동적으로 업데이트되어 선택된 계정의 세부 정보를 표시하고 싶습니다.\n\n# Salesforce Lightning Message Service의 제한 사항\n\n- LMS는 Salesforce 모바일 앱, AppExchange, Lightning Out 및 Lightning Communities와 통합할 수 있는 능력이 없습니다.\n- LMS는 iframe에서 작동하지 않습니다.\n- LMS는 Salesforce 클래식에서 작동하지 않습니다.\n- Salesforce UI에서 직접 라이트닝 메시지 채널을 생성하는 것을 지원하지 않습니다.\n\n# 결론:\n\n\n\n라이트닝 메시지 서비스(Lightning Message Service)는 Salesforce의 라이트닝 웹 컴포넌트(Lightning Web Components) 간 효율적인 통신을 가능케 하는 강력한 도구입니다. pub-sub 패턴을 구현함으로써 컴포넌트들은 분리된 방식으로 통신할 수 있으며, 이는 라이트닝 애플리케이션의 유연성과 확장성을 향상시킵니다. 올바른 사용법과 이해를 통해 LMS는 Salesforce에서 복잡하고 동적인 사용자 인터페이스를 원활하게 구축할 수 있도록 도와줍니다.\n\n\"더 많은 흥미로운 LWC 주제를 기대해주시고 Salesforce 개발 전문가가 되기 위해 라이트닝 웹 컴포넌트의 세계를 계속 탐험해보세요.\"\n\n즐거운 LWC 코딩하세요!\n\n더 자세한 내용은 아래 링크를 방문해주세요:","ogImage":{"url":"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png"},"coverImage":"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png","tag":["Tech"],"readingTime":7},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    code: \"code\",\n    ol: \"ol\",\n    pre: \"pre\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Salesforce의 Lightning Message Service (LMS)는 돔 계층 구조 전체에서 Lightning Web Components (LWC) 간의 통신을 가능하게 하는 강력한 기능입니다. 이것은 요소가 직계 부모-자식 관계를 필요로하지 않고 서로 통신할 수 있도록 해주므로 복잡한 애플리케이션을 구축하는 유연한 도구입니다. 이 블로그에서는 LWC 간 통신을 위해 LMS를 사용하는 방법과 구현 예시를 살펴볼 것입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Lightning Message Service란?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Lightning Message Service (LMS)는 Salesforce가 제공하는 통신 프레임워크로, Lightning 페이지의 다른 구성 요소와 Lightning Web Components (LWC) 간에 효과적인 통신을 가능하게 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그것은 계층적 관계에 관계없이 컴포넌트 간에 통신할 수 있도록 해줘서 모듈식이고 연결된 애플리케이션을 쉽게 구축할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"LMS는 컴포넌트가 데이터를 포함하는 메시지를 게시하고, 다른 컴포넌트가 이러한 메시지를 구독하고 반응할 수 있는 방법을 제공합니다. 이러한 분리된 통신 접근 방식은 Lightning 애플리케이션의 유연성과 유지 보수성을 향상시킵니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 Lightning Message Service Flow 다이어그램입니다. Lightning Message Channels의 도움으로 다양한 컴포넌트 간의 통신을 보여줍니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"라이트닝 메시지 서비스(LMS) 이해하기:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"LMS는 컴포넌트가 메시지(이벤트)를 발행하고 구독하여 해당 메시지를 수신할 수 있는 pub-sub (publish-subscribe) 메시징 패턴을 제공합니다. 이 분리된 통신 메커니즘은 컴포넌트 간의 느슨한 결합을 촉진하여 재사용성과 유지 보수성을 향상시킵니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"라이트닝 메시지 서비스에는 두 가지 주요 개념이 있습니다: 발행자(Publishers)와 구독자(Subscribers).\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. 발행자(Publisher):\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Publisher 구성 요소는 특정 메시지 채널로 메시지를 보내는 역할을 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이러한 메시지는 데이터를 전달하거나 비어 있을 수 있으며, 구독자는 이에 따라 반응할 수 있습니다.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"Publisher 구성 요소를 생성할 때는 \", _jsx(_components.code, {\n          children: \"@salesforce/messageChannel\"\n        }), \" 모듈에서 \", _jsx(_components.code, {\n          children: \"publish()\"\n        }), \" 함수를 import해야 합니다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이 함수를 사용하면 Lightning Message Channel을 통해 메시지를 보낼 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. Subscriber:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Subscriber 구성 요소는 특정 메시지 채널을 주시적으로 듣습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이 채널에서 메시지가 발행될 때마다 해당 메시지에 응답할 수 있는 모든 구독된 구성 요소가 반응할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"중요한 점은 Subscriber가 Publisher에 대한 구체적인 세부 정보를 알 필요가 없어서 유연하고 느슨하게 결합된 시스템을 유지하는 데 도움이 된다는 것입니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-CommunicationThroughLMSinLWC_2.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"주의 !\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"LWC에서 라이트닝 메시지 서비스(LMS)를 통해 컴포넌트가 어떻게 통신하는지\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"메시지 채널 메타데이터 정의:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"컴포넌트 간에 통신 채널을 설정하려면 먼저 Salesforce 조직에서 메시지 채널 메타데이터를 정의해야합니다. 아래 단계를 따르세요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"Salesforce 프로젝트 구조의 \", _jsx(_components.code, {\n          children: \"force-app/main/default\"\n        }), \" 하위에 \\\"messageChannels\\\"라는 폴더를 생성해주세요.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"이 폴더 안에 \\\"messageChannelName.messageChannel-meta.xml\\\" 형식의 XML 파일을 만들어주세요. 여기서 \\\"messageChannelName\\\"을 원하는 채널 이름으로 바꿔주세요.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"아래 코드를 참고하여 .xml 파일에 \", _jsx(_components.code, {\n            children: \"lightning message field\"\n          }), \"를 정의해주세요:\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"sampleMessageChannel.messageChannel-meta.xml\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"md\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003c!--?xml version=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1.0\\\"\"\n        }), \" encoding=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"UTF-8\\\"\"\n        }), \"?--\u003e\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"lightningmessagechannel\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"xmlns\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"http://soap.sforce.com/2006/04/metadata\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"masterlabel\"\n            }), \"\u003e\"]\n          }), \"SampleMessageChannel\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"masterlabel\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"isexposed\"\n            }), \"\u003e\"]\n          }), \"true\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"isexposed\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"description\"\n            }), \"\u003e\"]\n          }), \"This is a sample Lightning Message Channel.\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"description\"\n            }), \"\u003e\"]\n          }), \"\\n     \\n    \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"\u003c!-- Define message payload fields --\u003e\"\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"lightningmessagefields\"\n            }), \"\u003e\"]\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"fieldname\"\n            }), \"\u003e\"]\n          }), \"recordId\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"fieldname\"\n            }), \"\u003e\"]\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"description\"\n            }), \"\u003e\"]\n          }), \"This is the record Id that changed\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"description\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"lightningmessagefields\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"lightningmessagefields\"\n            }), \"\u003e\"]\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"fieldname\"\n            }), \"\u003e\"]\n          }), \"recordData\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"fieldname\"\n            }), \"\u003e\"]\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"description\"\n            }), \"\u003e\"]\n          }), \"The current data representing the record that changed\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"description\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"lightningmessagefields\"\n            }), \"\u003e\"]\n          }), \"\\n\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"lightningmessagechannel\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"설명:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"isExposed\"\n        }), \" 태그는 컴포넌트를 사용할 수 있게 만드는 데 사용됩니다.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"lightningMessageFields\"\n        }), \" 태그를 사용하여 필드를 정의하는데 특정 정보를 전달할 수 있습니다. 예를 들어 \", _jsx(_components.code, {\n          children: \"recordId\"\n        }), \"를 정의할 수 있습니다.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"description\"\n        }), \" 태그를 사용하여 Lightning 메시지 채널에 대한 설명을 추가하면 이 메시지 채널을 만드는 목표에 대해 설명할 수 있습니다.\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \".messageChannel-meta.xml\"\n        }), \" 파일이 작성되면 Salesforce org에 배포하세요.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"메시지 서비스 기능 가져오기:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"번역 :\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"당신의 Lightning 웹 컴포넌트에서 필요한 메시지 서비스 기능을 다음과 같이 가져오세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { publish, subscribe, unsubscribe, \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"APPLICATION_SCOPE\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MessageContext\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'lightning/messageService'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" msgService \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@salesforce/messageChannel/messageChannelName__c'\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"메시지 서비스 범위 정의:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"@wire 어댑터\"\n      }), \"를 사용하여 메시지 서비스의 범위를 정의할 수 있습니다.\\n라이트닝 웹 컴포넌트에서는 \", _jsx(_components.code, {\n        children: \"@wire 어댑터\"\n      }), \"로만 스코핑이 가능합니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"@\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"wire\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MessageContext\"\n        }), \")\\nmessageContext;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"메시지 채널 발행:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"메시지 채널에 메시지를 발행하려면 라이트닝 메시지 서비스의 \", _jsx(_components.code, {\n        children: \"publish()\"\n      }), \" 메서드를 사용하십시오. 이 메서드는 메시지 컨텍스트, 메시지 채널, 메시지 페이로드를 매개변수로 받습니다.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" messagePayload = {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"recordId\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'0012y00000L5R6jAAF'\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"recordData\"\n        }), \": { \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/* 레코드를 나타내는 데이터 */\"\n        }), \" }\\n};\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"publish\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"messageContext\"\n        }), \", msgService, messagePayload);\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"publish()\"\n      }), \" 메소드는 3개의 파라미터를 받습니다 :\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"메시지 컨텍스트 (객체 타입)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"메시지 채널 (객체 타입)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"메시지 페이로드 (메시지 페이로드는 JSON 객체입니다)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"messageContext : \", _jsx(_components.code, {\n        children: \"MessageContext\"\n      }), \" 객체는 Lightning 메시지 서비스를 사용하는 Lightning 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 \", _jsx(_components.code, {\n        children: \"MessageContext\"\n      }), \" 와이어 어댑터나 \", _jsx(_components.code, {\n        children: \"createMessageContext()\"\n      }), \"를 통해 가져올 수 있습니다.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"@\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"wire\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MessageContext\"\n        }), \")\\nmessageContext\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"messageChannel: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 \", _jsx(_components.code, {\n        children: \"@salesforce/messageChannel\"\n      }), \"과 같은 scoped 모듈을 사용하세요. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하세요.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"message: 가입자에게 발행된 메시지를 포함하는 직렬화 가능한 JSON 객체입니다. 메시지에는 함수나 심볼을 포함할 수 없습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"메시지 채널 구독:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"특정 메시지 채널의 메시지를 구독하려면 \", _jsx(_components.code, {\n        children: \"subscribe()\"\n      }), \" 메서드를 사용하세요. 받은 메시지를 처리하기 위한 리스너 함수를 제공해주세요.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"subscription\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"subscribe\"\n        }), \"(\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"messageContext\"\n        }), \",\\n    msgService,\\n    \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"message\"\n          }), \") =\u003e\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"handleMessage\"\n        }), \"(message)\\n);\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"subscribe()\"\n      }), \" 메서드는 4개의 매개변수를 받습니다:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"메시지 컨텍스트 (객체 형식)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"메시지 채널 (객체 형식)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"리스너 (함수 형식)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"구독자 옵션 (객체 형식)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"메시지 컨텍스트: \", _jsx(_components.code, {\n        children: \"MessageContext\"\n      }), \" 객체는 라이트닝 메시지 서비스를 사용하는 라이트닝 웹 컴포넌트에 대한 정보를 제공합니다. 이 객체는 \", _jsx(_components.code, {\n        children: \"MessageContext\"\n      }), \" 와이어 어댑터를 통해 가져오거나 \", _jsx(_components.code, {\n        children: \"createMessageContext()\"\n      }), \"를 통해 가져올 수 있습니다.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"@\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"wire\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"MessageContext\"\n        }), \")\\nmessageContext\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"메시지 채널: 메시지 채널 객체입니다. 메시지 채널을 가져오려면 scoped 모듈인 \", _jsx(_components.code, {\n        children: \"@salesforce/messageChannel\"\n      }), \"을 사용하십시오. 조직에서 메시지 채널을 만들려면 LightningMessageChannel 메타데이터 유형을 사용하십시오.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리스너: 발행된 메시지를 처리하는 함수입니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"subscriberOptions: (선택 사항) 이 객체는 \", _jsx(_components.code, {\n        children: \"'scope: APPLICATION_SCOPE'\"\n      }), \"로 설정되었을 때, 애플리케이션 전반에서 메시지 채널에서 메시지를 수신할 수 있는 능력을 지정합니다. \", _jsx(_components.code, {\n        children: \"lightning/messageService\"\n      }), \"에서 \", _jsx(_components.code, {\n        children: \"APPLICATION_SCOPE\"\n      }), \"를 가져와야 합니다.\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"메시지 채널 구독 취소:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"메시지 채널 구독을 취소하려면 \", _jsx(_components.code, {\n        children: \"unsubscribe()\"\n      }), \" 메서드를 사용하고, \", _jsx(_components.code, {\n        children: \"subscribe()\"\n      }), \" 함수에 의해 반환된 구독 객체를 제공하면 됩니다.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"unsubscribe\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"subscription\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Salesforce Lightning Message Service를 언제 사용해야 할까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"라이트닝 메시지 서비스는 Visualforce 페이지, Aura 및 LWC 간에 정보를 교환하거나 전달하는 방법입니다. LMS는 특히 구성 요소가 구성 요소 계층구조에서 직접적으로 관련되어 있지 않지만 서로 상호 작용해야 하는 시나리오에서 유용합니다. 다음은 LMS를 사용할 수 있는 몇 가지 상황입니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"부모-자식 구성 요소 간 통신: 부모 구성 요소와 여러 자식 구성 요소가 있고, 이들 간에 데이터를 전달하거나 작업을 트리거하려는 경우입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"동료 구성 요소 간 통신: 페이지에 동료 구성 요소가 있고, 이들의 상태를 동기화하거나 데이터를 공유해야 하는 경우입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"크로스 도메인 통신: 관리되는 패키지와 사용자 지정 구성 요소와 같이 서로 다른 네임스페이스에 거주하는 구성 요소 간에 통신해야 하는 경우입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"동적 구성 요소 간 통신: 구성 요소가 런타임에서 동적으로 생성되거나 파괴되고, 이들 사이에 통신 채널을 설정할 유연한 방법이 필요한 경우입니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 Lightning Message Service의 사용 예시 시나리오입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"당신이 Lightning 페이지에서 두 개의 컴포넌트를 가지고 있는 상황을 상상해봅시다: 계정 목록을 표시하는 부모 컴포넌트와 선택된 계정의 세부 정보를 보여주는 자식 컴포넌트가 있습니다. 사용자가 부모 컴포넌트에서 계정을 선택할 때, 자식 컴포넌트가 동적으로 업데이트되어 선택된 계정의 세부 정보를 표시하고 싶습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Salesforce Lightning Message Service의 제한 사항\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"LMS는 Salesforce 모바일 앱, AppExchange, Lightning Out 및 Lightning Communities와 통합할 수 있는 능력이 없습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"LMS는 iframe에서 작동하지 않습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"LMS는 Salesforce 클래식에서 작동하지 않습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Salesforce UI에서 직접 라이트닝 메시지 채널을 생성하는 것을 지원하지 않습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"라이트닝 메시지 서비스(Lightning Message Service)는 Salesforce의 라이트닝 웹 컴포넌트(Lightning Web Components) 간 효율적인 통신을 가능케 하는 강력한 도구입니다. pub-sub 패턴을 구현함으로써 컴포넌트들은 분리된 방식으로 통신할 수 있으며, 이는 라이트닝 애플리케이션의 유연성과 확장성을 향상시킵니다. 올바른 사용법과 이해를 통해 LMS는 Salesforce에서 복잡하고 동적인 사용자 인터페이스를 원활하게 구축할 수 있도록 도와줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\"더 많은 흥미로운 LWC 주제를 기대해주시고 Salesforce 개발 전문가가 되기 위해 라이트닝 웹 컴포넌트의 세계를 계속 탐험해보세요.\\\"\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"즐거운 LWC 코딩하세요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"더 자세한 내용은 아래 링크를 방문해주세요:\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-CommunicationThroughLMSinLWC"},"buildId":"uXJWf9GNc_Ux38RlnQJQc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>