<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates" data-gatsby-head="true"/><meta name="twitter:title" content="ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 14:08" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png" alt="Angular 17 Release"></p>
<p>Angular의 17 버전 릴리스는 템플릿 시스템을 개선하는 등 매우 흥미로운 새로운 기능이 포함되어 있습니다. 가장 중요한 추가 기능 중 하나는 제어 흐름을 위한 새로운 내장 구문입니다.</p>
<p>이 선언적 접근 방식은 *ngIf, *ngFor, ngSwitch와 같은 디렉티브가 필요하지 않도록하여 템플릿 로직을 프레임워크 자체 내에서 간소화합니다. 또한 Angular V17에서는 컴포넌트, 디렉티브 및 파이프를 게으르게 로드하여 성능을 향상시킬 수 있는 지연 로딩(deferrable views)을 도입했습니다. 이러한 발전은 Angular 템플릿에 상당한 영향을 미치며, 이에 따라 기존 응용 프로그램을 새로운 템플릿 시스템으로 이관하는 데 도움이 되는 새로운 ngcommand가 추가되었습니다.</p>
<p>다음은 템플릿에서 이 새로운 제어 흐름의 예시입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">@<span class="hljs-keyword">if</span> (user.<span class="hljs-property">isHuman</span>) {
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">human-profile</span> [<span class="hljs-attr">data</span>]=<span class="hljs-string">"user"</span> /></span></span>
   @<span class="hljs-keyword">for</span> (skill <span class="hljs-keyword">of</span> user.<span class="hljs-property">skills</span>; track $index) {
     <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">human-skills</span>  [<span class="hljs-attr">name</span>]=<span class="hljs-string">"skill.name"</span> [<span class="hljs-attr">level</span>]=<span class="hljs-string">"skill.level"</span> /></span></span>
   } @empty {
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">span</span>></span>기술이 추가되지 않았습니다.<span class="hljs-tag">&#x3C;/<span class="hljs-name">span</span>></span></span>
   }
} @<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (user.<span class="hljs-property">isRobot</span>) {
  &#x3C;!-- 로봇 사용자는 드물기 때문에 프로필을 나중에 불러옵니다. -->
  @defer {
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">robot-profile</span> [<span class="hljs-attr">data</span>]=<span class="hljs-string">"user"</span> /></span></span>
  }
} @<span class="hljs-keyword">else</span> {
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>프로필을 알 수 없습니다!<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>
}
</code></pre>
<h2>@if 블록 조건</h2>
<p>@if 블록은 조건이 참일 때 콘텐츠를 표시합니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-keyword">if</span> (loggedIn) {
  환영합니다 {username}
}
</code></pre>
<div class="content-ad"></div>
<p>table 태그를 Markdown 형식으로 변경할 수도 있습니다.</p>
<div class="content-ad"></div>
<p>@for (skill of user.skills; track $index) {
&#x3C;human-skills  [name]="skill.name" [level]="skill.level" />
}</p>
<p>트랙: Angular는 변경되는 컬렉션과 작업할 때 성능을 최적화하기 위해 개별 항목을 식별하는 트랙 표현식을 사용합니다. 이 기능은 각 항목을 해당 DOM 뷰와 연결하는 데 사용되는 키를 지정합니다. 이러한 키를 비교함으로써 Angular는 추가, 제거 또는 이동된 항목을 효율적으로 파악하여 불필요한 DOM 조작을 최소화할 수 있습니다. 효율적으로 트랙을 사용하면 Angular 애플리케이션의 성능을 크게 향상시킬 수 있습니다.</p>
<p>콘텍스트 변수: @for 내용 안에는 다음과 같은 많은 변수를 사용할 수 있습니다:</p>
<p><img src="/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_1.png" alt="contextual variables"></p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">@<span class="hljs-keyword">for</span> (skill <span class="hljs-keyword">of</span> user.<span class="hljs-property">skills</span>; track $index) {
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">human-skills</span>  [<span class="hljs-attr">name</span>]=<span class="hljs-string">"skill.name"</span> [<span class="hljs-attr">level</span>]=<span class="hljs-string">"skill.level"</span> /></span></span>
} @empty {
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">span</span>></span> 기술이 추가되지 않았습니다.<span class="hljs-tag">&#x3C;/<span class="hljs-name">span</span>></span></span>
}
</code></pre>
<h2>@switch 블록 — 선택</h2>
<p>다른 모든 프로그래밍 언어의 switch 문을 영감받아, 값은 === 연산자로 케이스 표현식과 비교됩니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">@<span class="hljs-keyword">switch</span> (condition) {
@<span class="hljs-keyword">case</span> (caseA) {
<span class="hljs-title class_">Case</span> A.
}
@<span class="hljs-keyword">case</span> (caseB) {
<span class="hljs-title class_">Case</span> B.
}
@<span class="hljs-keyword">default</span> {
<span class="hljs-title class_">Default</span> <span class="hljs-keyword">case</span>.
}
}
</code></pre>
<p>Angular의 @switch 블록은 fallthrough가 없으므로 return 또는 break 문을 사용할 필요가 없습니다.</p>
<h2>Angular에서 @를 선택한 이유는?</h2>
<p>Angular의 제어 흐름 및 지연 가능한 뷰 제안서는 긍정적인 피드백을 받았지만 템플릿에 대한 #-구문은 논란을 빚었습니다. 초기 RFC에서는 HTML과 유사한 태그를 제안했지만 커뮤니티 피드백은 새로운 "@-구문"을 선호했습니다. Angular 팀은 이 대안을 인기 때문에 평가하고 최종 결정을 내리기 전에 더 많은 데이터를 수집할 것입니다.</p>
<div class="content-ad"></div>
<p>Angular은 제어 흐름 구문 옵션인 #과 @에 대한 개발자 경험을 조사했습니다. 내부 팀, Google 개발자 전문가(GDE), 개발자 설문 및 사용자 연구를 통해 피드백을 수집했습니다. 결과는 분명하게 나타났습니다: 약 2 대 1의 비율로 개발자들이 원래의 "#-syntax" 대신 커뮤니티가 제안한 "@-syntax"를 선호했습니다.</p>
<p>이 차트는 Angular 팀 연례 설문에 응답한 수천 명의 개발자들의 선호도를 보여줍니다:</p>
<p><img src="/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_2.png" alt="Angular Team Survey"></p>
<p>Angular 팀이 커뮤니티가 제안한 @-syntax를 고려하는 것은 그들의 의지를 향한 증명입니다.</p>
<div class="content-ad"></div>
<h2>어떤 제어 흐름이 대체될 것인가</h2>
<ul>
<li>@switch 지시어는 여러 이점을 갖는 ngSwitch를 대체합니다. 먼저, 조건을 보관할 컨테이너 요소가 필요하지 않습니다. 둘째로, 템플릿 유형 확인을 지원합니다.</li>
<li>@for 블록은 *ngFor 지시어를 대체합니다. 또한, @empty 블록 지원이 도입되며 추적에 대한 최적화를 제공합니다. 요소 컬렉션의 변경에 대한 응답으로 필요한 최소 DOM 작업 횟수를 계산하는 새로운 최적화 알고리즘을 활용합니다.</li>
</ul>
<h2>구조 지시어에서 마이그레이션</h2>
<p>이 문서에서 언급된 대로, Angular 팀은 Angular 17부터 구조 지시어에서 단순화된 제어 흐름 구문으로의 마이그레이션을 고려해 왔습니다. 이 마이그레이션은 CommonModule이 필요하지 않도록 만듭니다. Angular CLI에는 이 프로세스를 자동화하는 새로운 스키매틱이 포함되어 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">$ ng generate @angular/<span class="hljs-attr">core</span>:control-flow
</code></pre>
<p>이 글의 끝까지 읽어 주셔서 감사합니다! 다음을 꼭 확인해 보세요:</p>
<ul>
<li><strong>박수</strong>를 치고 작가를 팔로우 해 주세요 👏</li>
<li>저를 팔로우 해 주세요: X | LinkedIn | YouTube</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"ngIf, ngFor, ngSwitch 사라졌나요 앵귤러의 새로운 템플릿 제어 방법","description":"","date":"2024-06-23 14:08","slug":"2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates","content":"\n\n\n![Angular 17 Release](/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png)\n\nAngular의 17 버전 릴리스는 템플릿 시스템을 개선하는 등 매우 흥미로운 새로운 기능이 포함되어 있습니다. 가장 중요한 추가 기능 중 하나는 제어 흐름을 위한 새로운 내장 구문입니다.\n\n이 선언적 접근 방식은 *ngIf, *ngFor, ngSwitch와 같은 디렉티브가 필요하지 않도록하여 템플릿 로직을 프레임워크 자체 내에서 간소화합니다. 또한 Angular V17에서는 컴포넌트, 디렉티브 및 파이프를 게으르게 로드하여 성능을 향상시킬 수 있는 지연 로딩(deferrable views)을 도입했습니다. 이러한 발전은 Angular 템플릿에 상당한 영향을 미치며, 이에 따라 기존 응용 프로그램을 새로운 템플릿 시스템으로 이관하는 데 도움이 되는 새로운 ngcommand가 추가되었습니다.\n\n다음은 템플릿에서 이 새로운 제어 흐름의 예시입니다:\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@if (user.isHuman) {\n  \u003chuman-profile [data]=\"user\" /\u003e\n   @for (skill of user.skills; track $index) {\n     \u003chuman-skills  [name]=\"skill.name\" [level]=\"skill.level\" /\u003e\n   } @empty {\n    \u003cspan\u003e기술이 추가되지 않았습니다.\u003c/span\u003e\n   }\n} @else if (user.isRobot) {\n  \u003c!-- 로봇 사용자는 드물기 때문에 프로필을 나중에 불러옵니다. --\u003e\n  @defer {\n    \u003crobot-profile [data]=\"user\" /\u003e\n  }\n} @else {\n  \u003cp\u003e프로필을 알 수 없습니다!\u003c/p\u003e\n}\n```\n\n## @if 블록 조건\n\n@if 블록은 조건이 참일 때 콘텐츠를 표시합니다.\n\n```js\n@if (loggedIn) {\n  환영합니다 {username}\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ntable 태그를 Markdown 형식으로 변경할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n@for (skill of user.skills; track $index) {\n  \u003chuman-skills  [name]=\"skill.name\" [level]=\"skill.level\" /\u003e\n}\n\n\n트랙: Angular는 변경되는 컬렉션과 작업할 때 성능을 최적화하기 위해 개별 항목을 식별하는 트랙 표현식을 사용합니다. 이 기능은 각 항목을 해당 DOM 뷰와 연결하는 데 사용되는 키를 지정합니다. 이러한 키를 비교함으로써 Angular는 추가, 제거 또는 이동된 항목을 효율적으로 파악하여 불필요한 DOM 조작을 최소화할 수 있습니다. 효율적으로 트랙을 사용하면 Angular 애플리케이션의 성능을 크게 향상시킬 수 있습니다.\n\n콘텍스트 변수: @for 내용 안에는 다음과 같은 많은 변수를 사용할 수 있습니다:\n\n![contextual variables](/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@for (skill of user.skills; track $index) {\n  \u003chuman-skills  [name]=\"skill.name\" [level]=\"skill.level\" /\u003e\n} @empty {\n  \u003cspan\u003e 기술이 추가되지 않았습니다.\u003c/span\u003e\n}\n```\n\n## @switch 블록 — 선택\n\n다른 모든 프로그래밍 언어의 switch 문을 영감받아, 값은 === 연산자로 케이스 표현식과 비교됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@switch (condition) {\n@case (caseA) {\nCase A.\n}\n@case (caseB) {\nCase B.\n}\n@default {\nDefault case.\n}\n}\n```\n\nAngular의 @switch 블록은 fallthrough가 없으므로 return 또는 break 문을 사용할 필요가 없습니다.\n\n## Angular에서 @를 선택한 이유는?\n\nAngular의 제어 흐름 및 지연 가능한 뷰 제안서는 긍정적인 피드백을 받았지만 템플릿에 대한 #-구문은 논란을 빚었습니다. 초기 RFC에서는 HTML과 유사한 태그를 제안했지만 커뮤니티 피드백은 새로운 \"@-구문\"을 선호했습니다. Angular 팀은 이 대안을 인기 때문에 평가하고 최종 결정을 내리기 전에 더 많은 데이터를 수집할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular은 제어 흐름 구문 옵션인 #과 @에 대한 개발자 경험을 조사했습니다. 내부 팀, Google 개발자 전문가(GDE), 개발자 설문 및 사용자 연구를 통해 피드백을 수집했습니다. 결과는 분명하게 나타났습니다: 약 2 대 1의 비율로 개발자들이 원래의 \"#-syntax\" 대신 커뮤니티가 제안한 \"@-syntax\"를 선호했습니다.\n\n이 차트는 Angular 팀 연례 설문에 응답한 수천 명의 개발자들의 선호도를 보여줍니다:\n\n![Angular Team Survey](/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_2.png)\n\nAngular 팀이 커뮤니티가 제안한 @-syntax를 고려하는 것은 그들의 의지를 향한 증명입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 어떤 제어 흐름이 대체될 것인가\n\n- @switch 지시어는 여러 이점을 갖는 ngSwitch를 대체합니다. 먼저, 조건을 보관할 컨테이너 요소가 필요하지 않습니다. 둘째로, 템플릿 유형 확인을 지원합니다.\n- @for 블록은 *ngFor 지시어를 대체합니다. 또한, @empty 블록 지원이 도입되며 추적에 대한 최적화를 제공합니다. 요소 컬렉션의 변경에 대한 응답으로 필요한 최소 DOM 작업 횟수를 계산하는 새로운 최적화 알고리즘을 활용합니다.\n\n## 구조 지시어에서 마이그레이션\n\n이 문서에서 언급된 대로, Angular 팀은 Angular 17부터 구조 지시어에서 단순화된 제어 흐름 구문으로의 마이그레이션을 고려해 왔습니다. 이 마이그레이션은 CommonModule이 필요하지 않도록 만듭니다. Angular CLI에는 이 프로세스를 자동화하는 새로운 스키매틱이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ ng generate @angular/core:control-flow\n```\n\n이 글의 끝까지 읽어 주셔서 감사합니다! 다음을 꼭 확인해 보세요:\n\n- **박수**를 치고 작가를 팔로우 해 주세요 👏\n- 저를 팔로우 해 주세요: X | LinkedIn | YouTube","ogImage":{"url":"/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png"},"coverImage":"/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_0.png\" alt=\"Angular 17 Release\"\u003e\u003c/p\u003e\n\u003cp\u003eAngular의 17 버전 릴리스는 템플릿 시스템을 개선하는 등 매우 흥미로운 새로운 기능이 포함되어 있습니다. 가장 중요한 추가 기능 중 하나는 제어 흐름을 위한 새로운 내장 구문입니다.\u003c/p\u003e\n\u003cp\u003e이 선언적 접근 방식은 *ngIf, *ngFor, ngSwitch와 같은 디렉티브가 필요하지 않도록하여 템플릿 로직을 프레임워크 자체 내에서 간소화합니다. 또한 Angular V17에서는 컴포넌트, 디렉티브 및 파이프를 게으르게 로드하여 성능을 향상시킬 수 있는 지연 로딩(deferrable views)을 도입했습니다. 이러한 발전은 Angular 템플릿에 상당한 영향을 미치며, 이에 따라 기존 응용 프로그램을 새로운 템플릿 시스템으로 이관하는 데 도움이 되는 새로운 ngcommand가 추가되었습니다.\u003c/p\u003e\n\u003cp\u003e다음은 템플릿에서 이 새로운 제어 흐름의 예시입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (user.\u003cspan class=\"hljs-property\"\u003eisHuman\u003c/span\u003e) {\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehuman-profile\u003c/span\u003e [\u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e]=\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n   @\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (skill \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e user.\u003cspan class=\"hljs-property\"\u003eskills\u003c/span\u003e; track $index) {\n     \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehuman-skills\u003c/span\u003e  [\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e]=\u003cspan class=\"hljs-string\"\u003e\"skill.name\"\u003c/span\u003e [\u003cspan class=\"hljs-attr\"\u003elevel\u003c/span\u003e]=\u003cspan class=\"hljs-string\"\u003e\"skill.level\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n   } @empty {\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u003e\u003c/span\u003e기술이 추가되지 않았습니다.\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n   }\n} @\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (user.\u003cspan class=\"hljs-property\"\u003eisRobot\u003c/span\u003e) {\n  \u0026#x3C;!-- 로봇 사용자는 드물기 때문에 프로필을 나중에 불러옵니다. --\u003e\n  @defer {\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003erobot-profile\u003c/span\u003e [\u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e]=\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n  }\n} @\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e프로필을 알 수 없습니다!\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e@if 블록 조건\u003c/h2\u003e\n\u003cp\u003e@if 블록은 조건이 참일 때 콘텐츠를 표시합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (loggedIn) {\n  환영합니다 {username}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003etable 태그를 Markdown 형식으로 변경할 수도 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e@for (skill of user.skills; track $index) {\n\u0026#x3C;human-skills  [name]=\"skill.name\" [level]=\"skill.level\" /\u003e\n}\u003c/p\u003e\n\u003cp\u003e트랙: Angular는 변경되는 컬렉션과 작업할 때 성능을 최적화하기 위해 개별 항목을 식별하는 트랙 표현식을 사용합니다. 이 기능은 각 항목을 해당 DOM 뷰와 연결하는 데 사용되는 키를 지정합니다. 이러한 키를 비교함으로써 Angular는 추가, 제거 또는 이동된 항목을 효율적으로 파악하여 불필요한 DOM 조작을 최소화할 수 있습니다. 효율적으로 트랙을 사용하면 Angular 애플리케이션의 성능을 크게 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e콘텍스트 변수: @for 내용 안에는 다음과 같은 많은 변수를 사용할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_1.png\" alt=\"contextual variables\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (skill \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e user.\u003cspan class=\"hljs-property\"\u003eskills\u003c/span\u003e; track $index) {\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehuman-skills\u003c/span\u003e  [\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e]=\u003cspan class=\"hljs-string\"\u003e\"skill.name\"\u003c/span\u003e [\u003cspan class=\"hljs-attr\"\u003elevel\u003c/span\u003e]=\u003cspan class=\"hljs-string\"\u003e\"skill.level\"\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n} @empty {\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u003e\u003c/span\u003e 기술이 추가되지 않았습니다.\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e@switch 블록 — 선택\u003c/h2\u003e\n\u003cp\u003e다른 모든 프로그래밍 언어의 switch 문을 영감받아, 값은 === 연산자로 케이스 표현식과 비교됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (condition) {\n@\u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e (caseA) {\n\u003cspan class=\"hljs-title class_\"\u003eCase\u003c/span\u003e A.\n}\n@\u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e (caseB) {\n\u003cspan class=\"hljs-title class_\"\u003eCase\u003c/span\u003e B.\n}\n@\u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e {\n\u003cspan class=\"hljs-title class_\"\u003eDefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e.\n}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAngular의 @switch 블록은 fallthrough가 없으므로 return 또는 break 문을 사용할 필요가 없습니다.\u003c/p\u003e\n\u003ch2\u003eAngular에서 @를 선택한 이유는?\u003c/h2\u003e\n\u003cp\u003eAngular의 제어 흐름 및 지연 가능한 뷰 제안서는 긍정적인 피드백을 받았지만 템플릿에 대한 #-구문은 논란을 빚었습니다. 초기 RFC에서는 HTML과 유사한 태그를 제안했지만 커뮤니티 피드백은 새로운 \"@-구문\"을 선호했습니다. Angular 팀은 이 대안을 인기 때문에 평가하고 최종 결정을 내리기 전에 더 많은 데이터를 수집할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eAngular은 제어 흐름 구문 옵션인 #과 @에 대한 개발자 경험을 조사했습니다. 내부 팀, Google 개발자 전문가(GDE), 개발자 설문 및 사용자 연구를 통해 피드백을 수집했습니다. 결과는 분명하게 나타났습니다: 약 2 대 1의 비율로 개발자들이 원래의 \"#-syntax\" 대신 커뮤니티가 제안한 \"@-syntax\"를 선호했습니다.\u003c/p\u003e\n\u003cp\u003e이 차트는 Angular 팀 연례 설문에 응답한 수천 명의 개발자들의 선호도를 보여줍니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates_2.png\" alt=\"Angular Team Survey\"\u003e\u003c/p\u003e\n\u003cp\u003eAngular 팀이 커뮤니티가 제안한 @-syntax를 고려하는 것은 그들의 의지를 향한 증명입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e어떤 제어 흐름이 대체될 것인가\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e@switch 지시어는 여러 이점을 갖는 ngSwitch를 대체합니다. 먼저, 조건을 보관할 컨테이너 요소가 필요하지 않습니다. 둘째로, 템플릿 유형 확인을 지원합니다.\u003c/li\u003e\n\u003cli\u003e@for 블록은 *ngFor 지시어를 대체합니다. 또한, @empty 블록 지원이 도입되며 추적에 대한 최적화를 제공합니다. 요소 컬렉션의 변경에 대한 응답으로 필요한 최소 DOM 작업 횟수를 계산하는 새로운 최적화 알고리즘을 활용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e구조 지시어에서 마이그레이션\u003c/h2\u003e\n\u003cp\u003e이 문서에서 언급된 대로, Angular 팀은 Angular 17부터 구조 지시어에서 단순화된 제어 흐름 구문으로의 마이그레이션을 고려해 왔습니다. 이 마이그레이션은 CommonModule이 필요하지 않도록 만듭니다. Angular CLI에는 이 프로세스를 자동화하는 새로운 스키매틱이 포함되어 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ ng generate @angular/\u003cspan class=\"hljs-attr\"\u003ecore\u003c/span\u003e:control-flow\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 글의 끝까지 읽어 주셔서 감사합니다! 다음을 꼭 확인해 보세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e박수\u003c/strong\u003e를 치고 작가를 팔로우 해 주세요 👏\u003c/li\u003e\n\u003cli\u003e저를 팔로우 해 주세요: X | LinkedIn | YouTube\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-IsngIfngForandngSwitchDeadAngularsNewWaytoControlYourTemplates"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>