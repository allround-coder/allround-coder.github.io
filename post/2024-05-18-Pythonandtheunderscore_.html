<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>파이썬과 언더스코어 (_) | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-18-Pythonandtheunderscore_" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="파이썬과 언더스코어 (_) | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="파이썬과 언더스코어 (_) | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-Pythonandtheunderscore__0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-18-Pythonandtheunderscore_" data-gatsby-head="true"/><meta name="twitter:title" content="파이썬과 언더스코어 (_) | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-Pythonandtheunderscore__0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 21:38" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">파이썬과 언더스코어 (_)</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="파이썬과 언더스코어 (_)" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-Pythonandtheunderscore_&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>파이썬 프로그래밍</h2>
<p><img src="/assets/img/2024-05-18-Pythonandtheunderscore__0.png" alt="Python Programming"></p>
<p>밑줄 문자인 _는 파이썬 프로그래밍에서 중요한 역할을 하는 경우가 많습니다. 모든 파이썬 개발자는 이 다재다능한 특성을 이해하고 코딩에서 어떻게 효과적으로 밑줄을 활용할지 알아야 합니다. 가독성을 향상시키고 비공개 속성을 관리하는데부터 데이터 처리와 국제화에서 특정 기능을 활용하는 데까지, 밑줄은 단순한 문자가 아니라 파이썬 구문에서 가장 중요한 문자 중 하나로, 파이썬 언어에서 근본적인 도구입니다.</p>
<p>이 기사에서는 파이썬에서 밑줄의 다양한 역할을 분석하며, _이 파이썬 언어에서 필수적인 문자가 되도록 하는 일반적이고 특수한 사용 사례를 살펴보겠습니다. 초보자든 숙련된 프로그래머든 밑줄의 용도를 이해하면 코딩 기술을 획기적으로 향상시킬 수 있습니다.</p>
<div class="content-ad"></div>
<h1>밑줄 사용 사례</h1>
<h2>명명</h2>
<p>밑줄의 가장 일반적이고 중요한 사용 사례는 아마도 명명일 것입니다. PEP 8에 따르면,</p>
<p>따라서 밑줄은 함수와 변수 이름에서 단어를 구분하는 데 사용됩니다. 동일한 관례는 메서드 이름과 클래스 인스턴스 변수에도 사용됩니다.</p>
<div class="content-ad"></div>
<p>파이썬의 관용적인 네이밍 규칙이야. 다양한 프로그래밍 언어에서 사용되는 가장 중요한 네이밍 규칙은 다음과 같아:</p>
<ul>
<li>카멜 케이스 (myVariableName): 첫 번째 단어는 소문자로, 다음 단어의 첫 글자는 대문자로 쓰는 방식. 사용되는 언어: JavaScript, Java, C#, Swift.</li>
<li>파스칼 케이스 (MyVariableName): 각 단어의 첫 글자를 대문자로 쓰는 방식. 사용되는 언어: Python(클래스 이름으로), C#, Pascal, Java, C++.</li>
<li>스네이크 케이스 (my_variable_name): 단어는 소문자로 쓰고 밑줄로 구분하는 방식. 사용되는 언어: Python(변수와 함수 이름으로), Ruby.</li>
<li>대문자 스네이크 케이스 (MY_VARIABLE_NAME): 단어들을 밑줄로 구분하고 모든 글자를 대문자로 쓰는 방식. 사용되는 언어: Python(상수로), C, C++, Java.</li>
<li>케밥 케이스 (my-variable-name): 단어는 소문자로 쓰고 하이픈으로 구분하는 방식. 사용되는 곳: URL 및 CSS 클래스 이름.</li>
<li>헝가리안 표기법 (iCount, strName): 변수 이름에 타입이나 범위를 나타내는 접두사를 사용하는 방식. 사용되는 곳: 오래된 C 및 C++ 코드.</li>
</ul>
<p>밑줄을 사용하는 파이썬 변수명의 예시는 다음과 같아:</p>
<pre><code class="hljs language-python">write_to_database()
read_data()

df_history
df_actual
</code></pre>
<div class="content-ad"></div>
<p>파이썬에서 밑줄은 또다른 역할을 해요. PEP 8에 따르면, 예약된 이름과 충돌하는 이름(예: 인수 이름)을 만들어야 한다면, 이름 끝에 밑줄을 추가할 수 있어요.</p>
<p>흔한 사용 예로는 class_와 type_이 있어요.</p>
<p>밑줄은 상수의 이름에도 사용돼요. 다시 한 번 PEP 8에 따르면:</p>
<p>아래는 상수 이름의 예시 세 가지예요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">NO_OF_DAYS</span>
<span class="hljs-variable constant_">SIGNIF_LEVEL</span>
<span class="hljs-variable constant_">RUN_DEBUGGER</span>
</code></pre>
<p>알다시피 밑줄은 Python에서 사용되는 다양한 역할을 합니다. 몇 가지는 다른 것보다 더 중요하지만 — 중요한 점은 Python에서 사용되는 몇 가지 명명 규칙이 밑줄에 매우 의존한다는 것입니다.</p>
<p>그러나 Python 클래스는 일반적으로 밑줄을 사용하지 않습니다. 따라서 book_publisher처럼 클래스를 이름 짓지 않을 것입니다. BookPublisher로 짓겠죠. list나 dict와 같이 잘 알려진 예외가 있긴 하지만, 여러분이 직접 이러한 예외를 만들어서는 안 된다는 뜻입니다.</p>
<h2>Dunder (double underscore, or magic) methods</h2>
<div class="content-ad"></div>
<p>이 역할은 명명과 관련이 있지만, 여기서는 파이썬 언어의 내부 이름에 대해 이야기합니다. 말하는 것은 이른바 매직 메서드의 이름에 많은 언더스코어가 있는 것을 볼 수 있습니다. 이들은 더블 언더스코어(__)로 시작하고 끝나는 특수 메서드들입니다. 더블 언더스코어를 사용하기 때문에 이러한 메서드들은 때로 "던더" 메서드라고도 불립니다 — 던더란 더블 언더스코어의 줄임말입니다.</p>
<p>던더 메서드들은 다양한 파이썬 언어 기능과 구문에서 사용됩니다. 이들의 이름에 있는 더블 언더스코어는 이 메서드들이 특별하다는 것을 나타내는 것이 중요합니다. 이 명명 규칙은 사용자 정의 메서드가 내장 (매직) 메서드를 덮어쓰는 것을 방지합니다.</p>
<p>다음은 파이썬에서 던더 메서드의 몇 가지 예시입니다:</p>
<ul>
<li><strong>init</strong>: 클래스 인스턴스를 생성하는 역할을 합니다.</li>
<li><strong>str</strong>: 객체에 사용되는 str() 및 print() 함수의 동작을 정의합니다; 더 자세한 내용은 이 기사를 참조하세요.</li>
<li><strong>len</strong>: 컨테이너의 길이를 반환합니다.</li>
<li><strong>getitem</strong>: 인덱싱을 허용하고 정의합니다.</li>
<li><strong>add</strong>, <strong>mul</strong> 등: 객체가 산술 연산을 지원하도록 합니다.</li>
</ul>
<div class="content-ad"></div>
<p>주의해야 할 점은 던더 메소드를 직접 사용해서는 안 되며, 대신 파이썬 인터프리터가 다양한 작업을 실행하는 중에 호출됩니다. 예를 들어, len(x)를 호출하면 파이썬 내부적으로 x.<strong>len</strong>()을 호출합니다. 후자를 사용해서는 안 되지만, 정상적으로 작동합니다:</p>
<pre><code class="hljs language-js">>>> x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
>>> <span class="hljs-title function_">len</span>(x)
<span class="hljs-number">3</span>
>>> x.<span class="hljs-title function_">__len__</span>()
<span class="hljs-number">3</span>
</code></pre>
<p>새로운 사용자 정의 던더 메서드를 정의하지 않는 것이 좋은 습관입니다. 기존 마법 메서드를 덮어쓰거나 사용자 정의 클래스에서 정의하는 것은 괜찮습니다.</p>
<h2>특수 속성</h2>
<div class="content-ad"></div>
<p>더블 언더스코어로 시작하고 끝나는 메서드를 매직 또는 던더라고 부르지만, 이 네이밍 규칙을 따르는 속성은 일반적으로 특별 속성이라고 불립니다. 파이썬에 의해 자동으로 생성되고 관리되는 이러한 속성들은 객체에 관한 정보를 제공합니다. 몇 가지 예시를 확인해봅시다:</p>
<ul>
<li><strong>name</strong>: 모듈, 클래스, 클래스 메서드 및 함수에서 사용됩니다. (재미있게도, functools.partial을 사용하여 작성된 부분 함수는 이 속성이 없습니다) 객체의 이름을 유지하는 데 사용됩니다.</li>
<li><strong>doc</strong>: 모듈, 클래스, 메서드 또는 함수의 독스트링을 보존합니다.</li>
<li><strong>file</strong>: 모듈이 로드된 파일의 경로를 저장하는 데 사용됩니다.</li>
</ul>
<h2>더미 변수</h2>
<p>밑줄은 더미 변수로 사용되는 빈번한 용도로 사용됩니다. 이것은 현재 코드에서 사용되지 않는 변수를 나타내는 이름으로 밑줄을 사용한다는 것을 의미합니다.</p>
<div class="content-ad"></div>
<p>이런 것은 종종 루프에서 사용되는데, 루핑 변수를 사용하지 않을 때입니다. 다음 상황을 비교해보세요:</p>
<p>루핑 변수를 사용하는 경우:</p>
<pre><code class="hljs language-js">>>> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):
...     <span class="hljs-title function_">print</span>(f<span class="hljs-string">"number {i}"</span>)
<span class="hljs-number">1</span>
<span class="hljs-number">2</span>
<span class="hljs-number">3</span>
</code></pre>
<p>루핑 변수를 사용하지 않는 경우:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">>>> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">3</span>):
...     <span class="hljs-title function_">print</span>(<span class="hljs-string">"주마 주마"</span>)
주마 주마
주마 주마
주마 주마
</code></pre>
<p>또한, 객체를 반환하는 함수나 메서드에서 해당 객체를 사용하지 않을 때 밑줄을 사용하는 것이 좋은 습관입니다. 예를 들어 여기서처럼:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">save</span>(<span class="hljs-attr">obj</span>: <span class="hljs-title class_">Any</span>, <span class="hljs-attr">path</span>: pathlib.<span class="hljs-property">Path</span>) -> <span class="hljs-attr">bool</span>:
    # 객체가 성공 여부에 관계없이 저장됩니다.
    <span class="hljs-keyword">if</span> not <span class="hljs-attr">success</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">True</span>

_ = <span class="hljs-title function_">save</span>(obj, pathlib.<span class="hljs-title class_">Path</span>(<span class="hljs-string">"file.csv"</span>)
</code></pre>
<p>여기서는 save()의 출력을 _에 할당했는데, 이는 코드에서 이 출력을 사용할 필요가 없기 때문입니다. 만약 사용해야 한다면, 다음과 같이 하게 됩니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">저장된 = <span class="hljs-title function_">save</span>(obj, pathlib.<span class="hljs-title class_">Path</span>(<span class="hljs-string">"file.csv"</span>)
</code></pre>
<p>자주 볼 수 있는 대안은 – 내 생각에는 나쁜 – 사용법이 있습니다. 여기서는 출력이 무시됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">save</span>(obj, pathlib.<span class="hljs-title class_">Path</span>(<span class="hljs-string">"file.csv"</span>)
</code></pre>
<p>이 접근 방식이 마음에 들지 않는 이유는 save() 함수가 아무것도 반환하지 않는 것처럼 보이기 때문입니다. 함수의 출력을 무시하는 경우는 항상 None을 반환할 때뿐이라고 생각합니다.</p>
<div class="content-ad"></div>
<h2>프라이빗 메소드 및 속성 표시</h2>
<p>Python에는 OOP에서 진정한 은행 메소드나 속성이 없습니다. 이에 대해 여기에서 읽을 수 있습니다:</p>
<p>그럼에도 불구하고 사용자에게 클래스 메소드나 속성 중 어떤 것을 프라이빗으로 유지하길 원하는지를 알리는 데 언더바(<em>)를 단일(</em>) 또는 이중(__)으로 이름 앞에 두고 표시할 수 있습니다. 차이점을 배우려면 위의 기사를 읽어보세요. 이렇게 하면 사용자에게 클래스 외부에서 이러한 메소드나 속성을 사용하지 말아야 한다고 알리는 것과 같습니다. 사용자는 어쨌든 할 수 있지만, 그들에게는 이를 하지 말아야 한다고 알려졌습니다.</p>
<p>다음과 같은 클래스를 고려해보세요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Me</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, smile=<span class="hljs-string">":-D"</span></span>):
        self.name = name
        self.smile = smile
        self._thoughts = []

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self, what</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(what)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_think</span>(<span class="hljs-params">self, what</span>):
        self._thoughts += what
</code></pre>
<p>우리에게는 나를 나타내는 Me 클래스가 있어요. 다음과 같이 나 자신을 만들 수 있어요:</p>
<ul>
<li>.name, public 속성 → 당신의 이름은 분명히 공개적이에요</li>
<li>.smile, public 속성 → 당신의 미소는 외부에서 보여지기 때문에 분명히 공개적이에요</li>
<li>._thoughts, private 속성 → 당신의 생각은 확실하게 비공개적이죠?</li>
</ul>
<p>두 개의 public 속성은 언더스코어 없이 이름이 지어지고, 유일한 private 속성은 이름이 언더스코어로 시작해요.</p>
<div class="content-ad"></div>
<p>이제 메서드들을 살펴보겠습니다:</p>
<ul>
<li>.say(), 공개 메서드 → 무언가를 말할 때, 사람들이 듣을 수 있습니다.</li>
<li>._think(), 비공개 메서드 → 무언가를 생각할 때, 그것은 개인적인 생각입니다. 만약 크게 말하고 싶다면 공개 .say() 메서드를 사용해야 하지만, 생각을 자신에게 간직하고 싶다면 비공개 _think() 메서드를 사용해야 합니다.</li>
</ul>
<p>비밀 생각을 대대로 말할 수 있는 공개 메서드를 만들 수 있습니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">say_thought</span>(self, which):
    <span class="hljs-keyword">return</span> self.<span class="hljs-property">_thoughts</span>[which]
</code></pre>
<div class="content-ad"></div>
<h2>대화형 세션에서의 마지막 작업</h2>
<p>Python 3에서 밑줄은 대화형 세션에서의 마지막 작업 결과를 저장하는데 사용됩니다. 이것은 이전 계산이 이름에 할당되지 않았을 때 새로운 작업에서 이전 작업의 결과를 빠르게 사용하는 데 유용할 수 있습니다. 예를 들어:</p>
<pre><code class="hljs language-js">>>> <span class="hljs-number">1</span> + <span class="hljs-number">2</span>
<span class="hljs-number">3</span>
>>> _ * <span class="hljs-number">3</span>
<span class="hljs-number">9</span>
>>> y = <span class="hljs-number">10</span>
>>> _
<span class="hljs-number">9</span>
>>> <span class="hljs-number">100</span>
>>> _
<span class="hljs-number">100</span>
</code></pre>
<p>보시다시피 밑줄은 이름에 할당되지 않은 마지막 작업의 결과만 유지하며, 그것이 계산이 아닌 객체일 경우에도(위 코드 블록의 100처럼) 저장됩니다.</p>
<div class="content-ad"></div>
<h2>숫자 값 형식 지정</h2>
<p>Python 3.6에서는 밑줄을 사용하여 대형 숫자 값을 더 쉽게 읽을 수 있게 하는 기능이 추가되었습니다. 이 기능은 대형 정수에 특히 유용하지만 부동 소수점 수에도 적용할 수 있습니다. 예를 들어:</p>
<pre><code class="hljs language-js">>>> x = <span class="hljs-number">1_000_000</span>
>>> x
<span class="hljs-number">1000000</span>
>>> <span class="hljs-number">1.009_232_112</span>
<span class="hljs-number">1.009232112</span>
>>> <span class="hljs-number">1_021_232.198_231_111</span>  
<span class="hljs-number">1021232.198231111</span>
</code></pre>
<p>보통 대형 정수에 많이 사용되지만 밑줄은 소수값의 가독성을 향상시키는 데도 도움이 됩니다. 이러한 방식은 덜 사용되지만 가능합니다.</p>
<div class="content-ad"></div>
<h2>functools.singledispatch 사용 사례</h2>
<p>functools.singledispatch에서 밑줄(_)은 특정 타입을 처리하기 위한 익명 구현을 나타내기 위해 함수 이름으로 흔히 사용됩니다. 이 스타일 선택은 함수의 이름이 중요하지 않으며, 오히려 함수가 처리하는 타입이 중요하다는 것을 시사합니다. 이 사용법은 네임스페이스를 깨끗하게 유지하는 데 도움이 되며, 로직이 직접 호출을 위한 것이 아니라 singledispatch 메커니즘에 직접 연결되어 있음을 강조합니다. 다음은 PEP 443에서의 예시입니다:</p>
<pre><code class="hljs language-js">>>> <span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> singledispatch
>>> @singledispatch
... def <span class="hljs-title function_">fun</span>(arg, verbose=<span class="hljs-title class_">False</span>):
...     <span class="hljs-keyword">if</span> <span class="hljs-attr">verbose</span>:
...         <span class="hljs-title function_">print</span>(<span class="hljs-string">"Let me just say,"</span>, end=<span class="hljs-string">" "</span>)
...     <span class="hljs-title function_">print</span>(arg)
>>> @fun.<span class="hljs-title function_">register</span>(int)
... def <span class="hljs-title function_">_</span>(arg, verbose=<span class="hljs-title class_">False</span>):
...     <span class="hljs-keyword">if</span> <span class="hljs-attr">verbose</span>:
...         <span class="hljs-title function_">print</span>(<span class="hljs-string">"Strength in numbers, eh?"</span>, end=<span class="hljs-string">" "</span>)
...     <span class="hljs-title function_">print</span>(arg)
...
>>> @fun.<span class="hljs-title function_">register</span>(list)
... def <span class="hljs-title function_">_</span>(arg, verbose=<span class="hljs-title class_">False</span>):
...     <span class="hljs-keyword">if</span> <span class="hljs-attr">verbose</span>:
...         <span class="hljs-title function_">print</span>(<span class="hljs-string">"Enumerate this:"</span>)
...     <span class="hljs-keyword">for</span> i, elem <span class="hljs-keyword">in</span> <span class="hljs-title function_">enumerate</span>(arg):
...         <span class="hljs-title function_">print</span>(i, elem)
</code></pre>
<p>이 설정에서 _는 해당 타입에 대한 동작을 구현하여 사용되지 않는 함수 이름으로 네임스페이스를 혼란스럽게 만들지 않습니다.</p>
<div class="content-ad"></div>
<p>위의 코드에 MyPy와 같은 정적 체커를 사용하려면, _를 여러 번 정의하고 있다는 오류가 발생할 수 있다는 점을 알아두세요. 이 문제의 가장 간단한 해결책은 _가 정의된 줄 끝에 # type: ignore 주석을 추가하는 것입니다. 또 다른 방법으로는 현재 _로 호출되는 이러한 함수들을 _로 명명하는 것이 있습니다. 이는 functools.singledispatch에 대한 일반적이지 않은 접근법일 수 있습니다.</p>
<h2>국제화와 지역화</h2>
<p>국제화(일반적으로 i18n으로 약어)와 지역화(약어로 l10n)는 응용프로그램을 다른 언어와 지역에 적응 가능하게 만들어줍니다. 국제화를 통해 응용프로그램은 코드를 수정하지 않고도 다양한 언어와 지역에 적응할 수 있습니다. 반면에 지역화는 국제화된 소프트웨어를 특정 지역이나 언어에 맞게 적응시키는 데 도움을 줍니다. 이는 로케일별 구성 요소 추가 및 텍스트 번역을 통해 이루어집니다.</p>
<p>Python에서는 gettext 모듈을 사용하여 이러한 두 가지 프로세스를 수행할 수 있습니다. 이를 통해 응용프로그램이 여러 언어를 지원할 수 있게 됩니다.</p>
<div class="content-ad"></div>
<p>gettext에서는 번역할 문자열을 표시하는 gettext 함수에 대한 별명으로 밑줄(_)을 사용하는 것이 일반적입니다:</p>
<pre><code class="hljs language-js">>>> <span class="hljs-keyword">import</span> gettext
>>> <span class="hljs-keyword">import</span> locale

로캘을 폴란드어로 설정:
>>> locale.<span class="hljs-title function_">setlocale</span>(locale.<span class="hljs-property">LC_ALL</span>, <span class="hljs-string">"pl_PL"</span>)

.<span class="hljs-property">mo</span> 번역 파일의 경로를 설정하고 텍스트 도메인을 선택:
>>> gettext.<span class="hljs-title function_">bindtextdomain</span>(
...     <span class="hljs-string">"myapp"</span>,
...     <span class="hljs-string">"/path/to/my/locale/directory"</span>
... )
>>> gettext.<span class="hljs-title function_">textdomain</span>(<span class="hljs-string">"myapp"</span>)

밑줄은 일반적으로 gettext.<span class="hljs-property">gettext</span>의 별명으로 사용됩니다:
>>> _ = gettext.<span class="hljs-property">gettext</span>

>>> <span class="hljs-title function_">_</span>(<span class="hljs-string">"Hello, World!"</span>)
<span class="hljs-title class_">Witaj</span>, świecie!
</code></pre>
<p>여기서 _()은 번역할 텍스트를 감싸 줍니다. 번역이 있는 로캘에서 실행되면 gettext.gettext() 및 따라서 _()가 번역된 문자열을 가져옵니다. 밑줄을 사용하는 것은 단순히 더 간단합니다; 비교해 보세요:</p>
<pre><code class="hljs language-js">>>> gettext.<span class="hljs-title function_">gettext</span>(<span class="hljs-string">"Hello, World!"</span>)
<span class="hljs-title class_">Witaj</span>, świecie!
>>> <span class="hljs-title function_">_</span>(<span class="hljs-string">"Hello, World!"</span>)
<span class="hljs-title class_">Witaj</span>, świecie!
</code></pre>
<div class="content-ad"></div>
<p>특히 앱이 gettext.gettext 또는 _을 광범위하게 사용하는 경우에 유용합니다.</p>
<h2>언패킹 시 값을 무시하는 방법</h2>
<p>파이썬에서는 시퀀스를 언패킹할 때 불필요한 값을 무시하기 위해 언더스코어(_)를 사용할 수 있습니다. 이렇게 하면 코드가 더 깔끔하고 가독성이 높아지며, 코드에서 전혀 사용되지 않는 변수를 정의하지 않아도 됩니다.</p>
<p>따라서 이해할 필요가 없는 값들을 언더스코어(_)에 할당하여 일회용 변수로 사용할 수 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">>>> a, _, b = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
>>> a
<span class="hljs-number">1</span>
>>> b
<span class="hljs-number">3</span>
</code></pre>
<p>여기서는 _ 가 중간 값을 무시하는 데 사용되었습니다 (2).</p>
<p>여러 값이 무시해야 하는 경우, 특히 더 긴 시퀀스의 경우에는 *_ 를 사용할 수 있습니다:</p>
<pre><code class="hljs language-js">>>> a, *_, b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
>>> a
<span class="hljs-number">1</span>
>>> b
<span class="hljs-number">5</span>
</code></pre>
<div class="content-ad"></div>
<p>리스트의 첫 번째 값과 마지막 값은 각각 a와 b에 할당되었습니다. 다른 값들 — 2, 3, 4 — 은 * _에 할당되어 무시되었음을 의미하며 더 이상 사용되지 않을 것입니다.</p>
<p>이렇게 밑줄을 사용하면 코드의 가독성이 향상되어 특정 값들이 사용되지 않고 더 이상 필요하지 않음을 명확히 합니다. 이는 코드와 관련 데이터에 초점을 유지하는 데 도움이 됩니다. 게다가, 이 세 값을 변수에 할당하는데 사용하지 않는다면, 왜 할당해야 할까요? 이는 좋은 코딩 스타일에 어긋날 것입니다.</p>
<h1>결론</h1>
<p>하나의 작은 문자, 간단한 한 줄, 밑줄은 파이썬 프로그래밍에서 굉장히 유용한 문자입니다. 이것은 파이썬 프로그래머에게 꼭 필요한 도구로 사용되는 다양한 용도를 가지고 있습니다. 또한 이것은 파이썬 자체의 중요한 요소이며, 가끔 _이 무엇을 의미하는지 모른다면 문제를 유발할 수 있으며, 최소한 파이썬 코드를 오해하게 할 수 있습니다.</p>
<div class="content-ad"></div>
<p>언더스코어의 가장 중요한 사용 사례를 다루었어요. 그러나 덜 중요한 경우 중 일부를 빠뜨렸을 수도 있어요. 그럴 경우에는 댓글로 알려주세요. 어쨌든, 이러한 다양한 사용 사례들로 인해 언더스코어는 파이썬 프로그래밍에서 없어서는 안 될 문자로 자리를 잡았어요. 이 언더스코어는 아마도 이 언어에서 가장 유용한 문자이며, 모든 파이썬 프로그래머는 그 다양한 사용 사례에 익숙해져야 해요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"파이썬과 언더스코어 (_)","description":"","date":"2024-05-18 21:38","slug":"2024-05-18-Pythonandtheunderscore_","content":"\n\n## 파이썬 프로그래밍\n\n![Python Programming](/assets/img/2024-05-18-Pythonandtheunderscore__0.png)\n\n밑줄 문자인 _는 파이썬 프로그래밍에서 중요한 역할을 하는 경우가 많습니다. 모든 파이썬 개발자는 이 다재다능한 특성을 이해하고 코딩에서 어떻게 효과적으로 밑줄을 활용할지 알아야 합니다. 가독성을 향상시키고 비공개 속성을 관리하는데부터 데이터 처리와 국제화에서 특정 기능을 활용하는 데까지, 밑줄은 단순한 문자가 아니라 파이썬 구문에서 가장 중요한 문자 중 하나로, 파이썬 언어에서 근본적인 도구입니다.\n\n이 기사에서는 파이썬에서 밑줄의 다양한 역할을 분석하며, _이 파이썬 언어에서 필수적인 문자가 되도록 하는 일반적이고 특수한 사용 사례를 살펴보겠습니다. 초보자든 숙련된 프로그래머든 밑줄의 용도를 이해하면 코딩 기술을 획기적으로 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 밑줄 사용 사례\n\n## 명명\n\n밑줄의 가장 일반적이고 중요한 사용 사례는 아마도 명명일 것입니다. PEP 8에 따르면,\n\n따라서 밑줄은 함수와 변수 이름에서 단어를 구분하는 데 사용됩니다. 동일한 관례는 메서드 이름과 클래스 인스턴스 변수에도 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬의 관용적인 네이밍 규칙이야. 다양한 프로그래밍 언어에서 사용되는 가장 중요한 네이밍 규칙은 다음과 같아:\n\n- 카멜 케이스 (myVariableName): 첫 번째 단어는 소문자로, 다음 단어의 첫 글자는 대문자로 쓰는 방식. 사용되는 언어: JavaScript, Java, C#, Swift.\n- 파스칼 케이스 (MyVariableName): 각 단어의 첫 글자를 대문자로 쓰는 방식. 사용되는 언어: Python(클래스 이름으로), C#, Pascal, Java, C++.\n- 스네이크 케이스 (my_variable_name): 단어는 소문자로 쓰고 밑줄로 구분하는 방식. 사용되는 언어: Python(변수와 함수 이름으로), Ruby.\n- 대문자 스네이크 케이스 (MY_VARIABLE_NAME): 단어들을 밑줄로 구분하고 모든 글자를 대문자로 쓰는 방식. 사용되는 언어: Python(상수로), C, C++, Java.\n- 케밥 케이스 (my-variable-name): 단어는 소문자로 쓰고 하이픈으로 구분하는 방식. 사용되는 곳: URL 및 CSS 클래스 이름.\n- 헝가리안 표기법 (iCount, strName): 변수 이름에 타입이나 범위를 나타내는 접두사를 사용하는 방식. 사용되는 곳: 오래된 C 및 C++ 코드.\n\n밑줄을 사용하는 파이썬 변수명의 예시는 다음과 같아:\n\n```python\nwrite_to_database()\nread_data()\n\ndf_history\ndf_actual\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬에서 밑줄은 또다른 역할을 해요. PEP 8에 따르면, 예약된 이름과 충돌하는 이름(예: 인수 이름)을 만들어야 한다면, 이름 끝에 밑줄을 추가할 수 있어요.\n\n흔한 사용 예로는 class_와 type_이 있어요.\n\n밑줄은 상수의 이름에도 사용돼요. 다시 한 번 PEP 8에 따르면:\n\n아래는 상수 이름의 예시 세 가지예요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nNO_OF_DAYS\nSIGNIF_LEVEL\nRUN_DEBUGGER\n```\n\n알다시피 밑줄은 Python에서 사용되는 다양한 역할을 합니다. 몇 가지는 다른 것보다 더 중요하지만 — 중요한 점은 Python에서 사용되는 몇 가지 명명 규칙이 밑줄에 매우 의존한다는 것입니다.\n\n그러나 Python 클래스는 일반적으로 밑줄을 사용하지 않습니다. 따라서 book_publisher처럼 클래스를 이름 짓지 않을 것입니다. BookPublisher로 짓겠죠. list나 dict와 같이 잘 알려진 예외가 있긴 하지만, 여러분이 직접 이러한 예외를 만들어서는 안 된다는 뜻입니다.\n\n## Dunder (double underscore, or magic) methods\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 역할은 명명과 관련이 있지만, 여기서는 파이썬 언어의 내부 이름에 대해 이야기합니다. 말하는 것은 이른바 매직 메서드의 이름에 많은 언더스코어가 있는 것을 볼 수 있습니다. 이들은 더블 언더스코어(__)로 시작하고 끝나는 특수 메서드들입니다. 더블 언더스코어를 사용하기 때문에 이러한 메서드들은 때로 \"던더\" 메서드라고도 불립니다 — 던더란 더블 언더스코어의 줄임말입니다.\n\n던더 메서드들은 다양한 파이썬 언어 기능과 구문에서 사용됩니다. 이들의 이름에 있는 더블 언더스코어는 이 메서드들이 특별하다는 것을 나타내는 것이 중요합니다. 이 명명 규칙은 사용자 정의 메서드가 내장 (매직) 메서드를 덮어쓰는 것을 방지합니다.\n\n다음은 파이썬에서 던더 메서드의 몇 가지 예시입니다:\n\n- __init__: 클래스 인스턴스를 생성하는 역할을 합니다.\n- __str__: 객체에 사용되는 str() 및 print() 함수의 동작을 정의합니다; 더 자세한 내용은 이 기사를 참조하세요.\n- __len__: 컨테이너의 길이를 반환합니다.\n- __getitem__: 인덱싱을 허용하고 정의합니다.\n- __add__, __mul__ 등: 객체가 산술 연산을 지원하도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주의해야 할 점은 던더 메소드를 직접 사용해서는 안 되며, 대신 파이썬 인터프리터가 다양한 작업을 실행하는 중에 호출됩니다. 예를 들어, len(x)를 호출하면 파이썬 내부적으로 x.__len__()을 호출합니다. 후자를 사용해서는 안 되지만, 정상적으로 작동합니다:\n\n```js\n\u003e\u003e\u003e x = [1, 2, 3]\n\u003e\u003e\u003e len(x)\n3\n\u003e\u003e\u003e x.__len__()\n3\n```\n\n새로운 사용자 정의 던더 메서드를 정의하지 않는 것이 좋은 습관입니다. 기존 마법 메서드를 덮어쓰거나 사용자 정의 클래스에서 정의하는 것은 괜찮습니다.\n\n## 특수 속성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더블 언더스코어로 시작하고 끝나는 메서드를 매직 또는 던더라고 부르지만, 이 네이밍 규칙을 따르는 속성은 일반적으로 특별 속성이라고 불립니다. 파이썬에 의해 자동으로 생성되고 관리되는 이러한 속성들은 객체에 관한 정보를 제공합니다. 몇 가지 예시를 확인해봅시다:\n\n- __name__: 모듈, 클래스, 클래스 메서드 및 함수에서 사용됩니다. (재미있게도, functools.partial을 사용하여 작성된 부분 함수는 이 속성이 없습니다) 객체의 이름을 유지하는 데 사용됩니다.\n- __doc__: 모듈, 클래스, 메서드 또는 함수의 독스트링을 보존합니다.\n- __file__: 모듈이 로드된 파일의 경로를 저장하는 데 사용됩니다.\n\n## 더미 변수\n\n밑줄은 더미 변수로 사용되는 빈번한 용도로 사용됩니다. 이것은 현재 코드에서 사용되지 않는 변수를 나타내는 이름으로 밑줄을 사용한다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이런 것은 종종 루프에서 사용되는데, 루핑 변수를 사용하지 않을 때입니다. 다음 상황을 비교해보세요:\n\n루핑 변수를 사용하는 경우:\n\n```js\n\u003e\u003e\u003e for i in range(1, 4):\n...     print(f\"number {i}\")\n1\n2\n3\n```\n\n루핑 변수를 사용하지 않는 경우:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e\u003e\u003e for _ in range(3):\n...     print(\"주마 주마\")\n주마 주마\n주마 주마\n주마 주마\n```\n\n또한, 객체를 반환하는 함수나 메서드에서 해당 객체를 사용하지 않을 때 밑줄을 사용하는 것이 좋은 습관입니다. 예를 들어 여기서처럼:\n\n```js\ndef save(obj: Any, path: pathlib.Path) -\u003e bool:\n    # 객체가 성공 여부에 관계없이 저장됩니다.\n    if not success:\n        return False\n    return True\n\n_ = save(obj, pathlib.Path(\"file.csv\")\n```\n\n여기서는 save()의 출력을 _에 할당했는데, 이는 코드에서 이 출력을 사용할 필요가 없기 때문입니다. 만약 사용해야 한다면, 다음과 같이 하게 됩니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n저장된 = save(obj, pathlib.Path(\"file.csv\")\n```\n\n자주 볼 수 있는 대안은 – 내 생각에는 나쁜 – 사용법이 있습니다. 여기서는 출력이 무시됩니다:\n\n```js\nsave(obj, pathlib.Path(\"file.csv\")\n```\n\n이 접근 방식이 마음에 들지 않는 이유는 save() 함수가 아무것도 반환하지 않는 것처럼 보이기 때문입니다. 함수의 출력을 무시하는 경우는 항상 None을 반환할 때뿐이라고 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 프라이빗 메소드 및 속성 표시\n\nPython에는 OOP에서 진정한 은행 메소드나 속성이 없습니다. 이에 대해 여기에서 읽을 수 있습니다:\n\n그럼에도 불구하고 사용자에게 클래스 메소드나 속성 중 어떤 것을 프라이빗으로 유지하길 원하는지를 알리는 데 언더바(_)를 단일(_) 또는 이중(__)으로 이름 앞에 두고 표시할 수 있습니다. 차이점을 배우려면 위의 기사를 읽어보세요. 이렇게 하면 사용자에게 클래스 외부에서 이러한 메소드나 속성을 사용하지 말아야 한다고 알리는 것과 같습니다. 사용자는 어쨌든 할 수 있지만, 그들에게는 이를 하지 말아야 한다고 알려졌습니다.\n\n다음과 같은 클래스를 고려해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nclass Me:\n    def __init__(self, name, smile=\":-D\"):\n        self.name = name\n        self.smile = smile\n        self._thoughts = []\n\n    def say(self, what):\n        return str(what)\n\n    def _think(self, what):\n        self._thoughts += what\n```\n\n우리에게는 나를 나타내는 Me 클래스가 있어요. 다음과 같이 나 자신을 만들 수 있어요:\n\n- .name, public 속성 → 당신의 이름은 분명히 공개적이에요\n- .smile, public 속성 → 당신의 미소는 외부에서 보여지기 때문에 분명히 공개적이에요\n- ._thoughts, private 속성 → 당신의 생각은 확실하게 비공개적이죠?\n\n두 개의 public 속성은 언더스코어 없이 이름이 지어지고, 유일한 private 속성은 이름이 언더스코어로 시작해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 메서드들을 살펴보겠습니다:\n\n- .say(), 공개 메서드 → 무언가를 말할 때, 사람들이 듣을 수 있습니다.\n- ._think(), 비공개 메서드 → 무언가를 생각할 때, 그것은 개인적인 생각입니다. 만약 크게 말하고 싶다면 공개 .say() 메서드를 사용해야 하지만, 생각을 자신에게 간직하고 싶다면 비공개 _think() 메서드를 사용해야 합니다.\n\n비밀 생각을 대대로 말할 수 있는 공개 메서드를 만들 수 있습니다:\n\n```js\ndef say_thought(self, which):\n    return self._thoughts[which]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 대화형 세션에서의 마지막 작업\n\nPython 3에서 밑줄은 대화형 세션에서의 마지막 작업 결과를 저장하는데 사용됩니다. 이것은 이전 계산이 이름에 할당되지 않았을 때 새로운 작업에서 이전 작업의 결과를 빠르게 사용하는 데 유용할 수 있습니다. 예를 들어:\n\n```js\n\u003e\u003e\u003e 1 + 2\n3\n\u003e\u003e\u003e _ * 3\n9\n\u003e\u003e\u003e y = 10\n\u003e\u003e\u003e _\n9\n\u003e\u003e\u003e 100\n\u003e\u003e\u003e _\n100\n```\n\n보시다시피 밑줄은 이름에 할당되지 않은 마지막 작업의 결과만 유지하며, 그것이 계산이 아닌 객체일 경우에도(위 코드 블록의 100처럼) 저장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 숫자 값 형식 지정\n\nPython 3.6에서는 밑줄을 사용하여 대형 숫자 값을 더 쉽게 읽을 수 있게 하는 기능이 추가되었습니다. 이 기능은 대형 정수에 특히 유용하지만 부동 소수점 수에도 적용할 수 있습니다. 예를 들어:\n\n```js\n\u003e\u003e\u003e x = 1_000_000\n\u003e\u003e\u003e x\n1000000\n\u003e\u003e\u003e 1.009_232_112\n1.009232112\n\u003e\u003e\u003e 1_021_232.198_231_111  \n1021232.198231111\n```\n\n보통 대형 정수에 많이 사용되지만 밑줄은 소수값의 가독성을 향상시키는 데도 도움이 됩니다. 이러한 방식은 덜 사용되지만 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## functools.singledispatch 사용 사례\n\nfunctools.singledispatch에서 밑줄(_)은 특정 타입을 처리하기 위한 익명 구현을 나타내기 위해 함수 이름으로 흔히 사용됩니다. 이 스타일 선택은 함수의 이름이 중요하지 않으며, 오히려 함수가 처리하는 타입이 중요하다는 것을 시사합니다. 이 사용법은 네임스페이스를 깨끗하게 유지하는 데 도움이 되며, 로직이 직접 호출을 위한 것이 아니라 singledispatch 메커니즘에 직접 연결되어 있음을 강조합니다. 다음은 PEP 443에서의 예시입니다:\n\n```js\n\u003e\u003e\u003e from functools import singledispatch\n\u003e\u003e\u003e @singledispatch\n... def fun(arg, verbose=False):\n...     if verbose:\n...         print(\"Let me just say,\", end=\" \")\n...     print(arg)\n\u003e\u003e\u003e @fun.register(int)\n... def _(arg, verbose=False):\n...     if verbose:\n...         print(\"Strength in numbers, eh?\", end=\" \")\n...     print(arg)\n...\n\u003e\u003e\u003e @fun.register(list)\n... def _(arg, verbose=False):\n...     if verbose:\n...         print(\"Enumerate this:\")\n...     for i, elem in enumerate(arg):\n...         print(i, elem)\n```\n\n이 설정에서 _는 해당 타입에 대한 동작을 구현하여 사용되지 않는 함수 이름으로 네임스페이스를 혼란스럽게 만들지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에 MyPy와 같은 정적 체커를 사용하려면, _를 여러 번 정의하고 있다는 오류가 발생할 수 있다는 점을 알아두세요. 이 문제의 가장 간단한 해결책은 _가 정의된 줄 끝에 # type: ignore 주석을 추가하는 것입니다. 또 다른 방법으로는 현재 _로 호출되는 이러한 함수들을 _로 명명하는 것이 있습니다. 이는 functools.singledispatch에 대한 일반적이지 않은 접근법일 수 있습니다.\n\n## 국제화와 지역화\n\n국제화(일반적으로 i18n으로 약어)와 지역화(약어로 l10n)는 응용프로그램을 다른 언어와 지역에 적응 가능하게 만들어줍니다. 국제화를 통해 응용프로그램은 코드를 수정하지 않고도 다양한 언어와 지역에 적응할 수 있습니다. 반면에 지역화는 국제화된 소프트웨어를 특정 지역이나 언어에 맞게 적응시키는 데 도움을 줍니다. 이는 로케일별 구성 요소 추가 및 텍스트 번역을 통해 이루어집니다.\n\nPython에서는 gettext 모듈을 사용하여 이러한 두 가지 프로세스를 수행할 수 있습니다. 이를 통해 응용프로그램이 여러 언어를 지원할 수 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ngettext에서는 번역할 문자열을 표시하는 gettext 함수에 대한 별명으로 밑줄(_)을 사용하는 것이 일반적입니다:\n\n```js\n\u003e\u003e\u003e import gettext\n\u003e\u003e\u003e import locale\n\n로캘을 폴란드어로 설정:\n\u003e\u003e\u003e locale.setlocale(locale.LC_ALL, \"pl_PL\")\n\n.mo 번역 파일의 경로를 설정하고 텍스트 도메인을 선택:\n\u003e\u003e\u003e gettext.bindtextdomain(\n...     \"myapp\",\n...     \"/path/to/my/locale/directory\"\n... )\n\u003e\u003e\u003e gettext.textdomain(\"myapp\")\n\n밑줄은 일반적으로 gettext.gettext의 별명으로 사용됩니다:\n\u003e\u003e\u003e _ = gettext.gettext\n\n\u003e\u003e\u003e _(\"Hello, World!\")\nWitaj, świecie!\n```\n\n여기서 _()은 번역할 텍스트를 감싸 줍니다. 번역이 있는 로캘에서 실행되면 gettext.gettext() 및 따라서 _()가 번역된 문자열을 가져옵니다. 밑줄을 사용하는 것은 단순히 더 간단합니다; 비교해 보세요:\n\n```js\n\u003e\u003e\u003e gettext.gettext(\"Hello, World!\")\nWitaj, świecie!\n\u003e\u003e\u003e _(\"Hello, World!\")\nWitaj, świecie!\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특히 앱이 gettext.gettext 또는 _을 광범위하게 사용하는 경우에 유용합니다.\n\n## 언패킹 시 값을 무시하는 방법\n\n파이썬에서는 시퀀스를 언패킹할 때 불필요한 값을 무시하기 위해 언더스코어(_)를 사용할 수 있습니다. 이렇게 하면 코드가 더 깔끔하고 가독성이 높아지며, 코드에서 전혀 사용되지 않는 변수를 정의하지 않아도 됩니다.\n\n따라서 이해할 필요가 없는 값들을 언더스코어(_)에 할당하여 일회용 변수로 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e\u003e\u003e a, _, b = (1, 2, 3)\n\u003e\u003e\u003e a\n1\n\u003e\u003e\u003e b\n3\n```\n\n여기서는 _ 가 중간 값을 무시하는 데 사용되었습니다 (2).\n\n여러 값이 무시해야 하는 경우, 특히 더 긴 시퀀스의 경우에는 *_ 를 사용할 수 있습니다:\n\n```js\n\u003e\u003e\u003e a, *_, b = [1, 2, 3, 4, 5]\n\u003e\u003e\u003e a\n1\n\u003e\u003e\u003e b\n5\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리스트의 첫 번째 값과 마지막 값은 각각 a와 b에 할당되었습니다. 다른 값들 — 2, 3, 4 — 은 * _에 할당되어 무시되었음을 의미하며 더 이상 사용되지 않을 것입니다.\n\n이렇게 밑줄을 사용하면 코드의 가독성이 향상되어 특정 값들이 사용되지 않고 더 이상 필요하지 않음을 명확히 합니다. 이는 코드와 관련 데이터에 초점을 유지하는 데 도움이 됩니다. 게다가, 이 세 값을 변수에 할당하는데 사용하지 않는다면, 왜 할당해야 할까요? 이는 좋은 코딩 스타일에 어긋날 것입니다.\n\n# 결론\n\n하나의 작은 문자, 간단한 한 줄, 밑줄은 파이썬 프로그래밍에서 굉장히 유용한 문자입니다. 이것은 파이썬 프로그래머에게 꼭 필요한 도구로 사용되는 다양한 용도를 가지고 있습니다. 또한 이것은 파이썬 자체의 중요한 요소이며, 가끔 _이 무엇을 의미하는지 모른다면 문제를 유발할 수 있으며, 최소한 파이썬 코드를 오해하게 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n언더스코어의 가장 중요한 사용 사례를 다루었어요. 그러나 덜 중요한 경우 중 일부를 빠뜨렸을 수도 있어요. 그럴 경우에는 댓글로 알려주세요. 어쨌든, 이러한 다양한 사용 사례들로 인해 언더스코어는 파이썬 프로그래밍에서 없어서는 안 될 문자로 자리를 잡았어요. 이 언더스코어는 아마도 이 언어에서 가장 유용한 문자이며, 모든 파이썬 프로그래머는 그 다양한 사용 사례에 익숙해져야 해요.","ogImage":{"url":"/assets/img/2024-05-18-Pythonandtheunderscore__0.png"},"coverImage":"/assets/img/2024-05-18-Pythonandtheunderscore__0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e파이썬 프로그래밍\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-Pythonandtheunderscore__0.png\" alt=\"Python Programming\"\u003e\u003c/p\u003e\n\u003cp\u003e밑줄 문자인 _는 파이썬 프로그래밍에서 중요한 역할을 하는 경우가 많습니다. 모든 파이썬 개발자는 이 다재다능한 특성을 이해하고 코딩에서 어떻게 효과적으로 밑줄을 활용할지 알아야 합니다. 가독성을 향상시키고 비공개 속성을 관리하는데부터 데이터 처리와 국제화에서 특정 기능을 활용하는 데까지, 밑줄은 단순한 문자가 아니라 파이썬 구문에서 가장 중요한 문자 중 하나로, 파이썬 언어에서 근본적인 도구입니다.\u003c/p\u003e\n\u003cp\u003e이 기사에서는 파이썬에서 밑줄의 다양한 역할을 분석하며, _이 파이썬 언어에서 필수적인 문자가 되도록 하는 일반적이고 특수한 사용 사례를 살펴보겠습니다. 초보자든 숙련된 프로그래머든 밑줄의 용도를 이해하면 코딩 기술을 획기적으로 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e밑줄 사용 사례\u003c/h1\u003e\n\u003ch2\u003e명명\u003c/h2\u003e\n\u003cp\u003e밑줄의 가장 일반적이고 중요한 사용 사례는 아마도 명명일 것입니다. PEP 8에 따르면,\u003c/p\u003e\n\u003cp\u003e따라서 밑줄은 함수와 변수 이름에서 단어를 구분하는 데 사용됩니다. 동일한 관례는 메서드 이름과 클래스 인스턴스 변수에도 사용됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e파이썬의 관용적인 네이밍 규칙이야. 다양한 프로그래밍 언어에서 사용되는 가장 중요한 네이밍 규칙은 다음과 같아:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e카멜 케이스 (myVariableName): 첫 번째 단어는 소문자로, 다음 단어의 첫 글자는 대문자로 쓰는 방식. 사용되는 언어: JavaScript, Java, C#, Swift.\u003c/li\u003e\n\u003cli\u003e파스칼 케이스 (MyVariableName): 각 단어의 첫 글자를 대문자로 쓰는 방식. 사용되는 언어: Python(클래스 이름으로), C#, Pascal, Java, C++.\u003c/li\u003e\n\u003cli\u003e스네이크 케이스 (my_variable_name): 단어는 소문자로 쓰고 밑줄로 구분하는 방식. 사용되는 언어: Python(변수와 함수 이름으로), Ruby.\u003c/li\u003e\n\u003cli\u003e대문자 스네이크 케이스 (MY_VARIABLE_NAME): 단어들을 밑줄로 구분하고 모든 글자를 대문자로 쓰는 방식. 사용되는 언어: Python(상수로), C, C++, Java.\u003c/li\u003e\n\u003cli\u003e케밥 케이스 (my-variable-name): 단어는 소문자로 쓰고 하이픈으로 구분하는 방식. 사용되는 곳: URL 및 CSS 클래스 이름.\u003c/li\u003e\n\u003cli\u003e헝가리안 표기법 (iCount, strName): 변수 이름에 타입이나 범위를 나타내는 접두사를 사용하는 방식. 사용되는 곳: 오래된 C 및 C++ 코드.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e밑줄을 사용하는 파이썬 변수명의 예시는 다음과 같아:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003ewrite_to_database()\nread_data()\n\ndf_history\ndf_actual\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e파이썬에서 밑줄은 또다른 역할을 해요. PEP 8에 따르면, 예약된 이름과 충돌하는 이름(예: 인수 이름)을 만들어야 한다면, 이름 끝에 밑줄을 추가할 수 있어요.\u003c/p\u003e\n\u003cp\u003e흔한 사용 예로는 class_와 type_이 있어요.\u003c/p\u003e\n\u003cp\u003e밑줄은 상수의 이름에도 사용돼요. 다시 한 번 PEP 8에 따르면:\u003c/p\u003e\n\u003cp\u003e아래는 상수 이름의 예시 세 가지예요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eNO_OF_DAYS\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eSIGNIF_LEVEL\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN_DEBUGGER\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e알다시피 밑줄은 Python에서 사용되는 다양한 역할을 합니다. 몇 가지는 다른 것보다 더 중요하지만 — 중요한 점은 Python에서 사용되는 몇 가지 명명 규칙이 밑줄에 매우 의존한다는 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 Python 클래스는 일반적으로 밑줄을 사용하지 않습니다. 따라서 book_publisher처럼 클래스를 이름 짓지 않을 것입니다. BookPublisher로 짓겠죠. list나 dict와 같이 잘 알려진 예외가 있긴 하지만, 여러분이 직접 이러한 예외를 만들어서는 안 된다는 뜻입니다.\u003c/p\u003e\n\u003ch2\u003eDunder (double underscore, or magic) methods\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 역할은 명명과 관련이 있지만, 여기서는 파이썬 언어의 내부 이름에 대해 이야기합니다. 말하는 것은 이른바 매직 메서드의 이름에 많은 언더스코어가 있는 것을 볼 수 있습니다. 이들은 더블 언더스코어(__)로 시작하고 끝나는 특수 메서드들입니다. 더블 언더스코어를 사용하기 때문에 이러한 메서드들은 때로 \"던더\" 메서드라고도 불립니다 — 던더란 더블 언더스코어의 줄임말입니다.\u003c/p\u003e\n\u003cp\u003e던더 메서드들은 다양한 파이썬 언어 기능과 구문에서 사용됩니다. 이들의 이름에 있는 더블 언더스코어는 이 메서드들이 특별하다는 것을 나타내는 것이 중요합니다. 이 명명 규칙은 사용자 정의 메서드가 내장 (매직) 메서드를 덮어쓰는 것을 방지합니다.\u003c/p\u003e\n\u003cp\u003e다음은 파이썬에서 던더 메서드의 몇 가지 예시입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003einit\u003c/strong\u003e: 클래스 인스턴스를 생성하는 역할을 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003estr\u003c/strong\u003e: 객체에 사용되는 str() 및 print() 함수의 동작을 정의합니다; 더 자세한 내용은 이 기사를 참조하세요.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003elen\u003c/strong\u003e: 컨테이너의 길이를 반환합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003egetitem\u003c/strong\u003e: 인덱싱을 허용하고 정의합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eadd\u003c/strong\u003e, \u003cstrong\u003emul\u003c/strong\u003e 등: 객체가 산술 연산을 지원하도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e주의해야 할 점은 던더 메소드를 직접 사용해서는 안 되며, 대신 파이썬 인터프리터가 다양한 작업을 실행하는 중에 호출됩니다. 예를 들어, len(x)를 호출하면 파이썬 내부적으로 x.\u003cstrong\u003elen\u003c/strong\u003e()을 호출합니다. 후자를 사용해서는 안 되지만, 정상적으로 작동합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e\u003e\u003e x = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]\n\u003e\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(x)\n\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n\u003e\u003e\u003e x.\u003cspan class=\"hljs-title function_\"\u003e__len__\u003c/span\u003e()\n\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로운 사용자 정의 던더 메서드를 정의하지 않는 것이 좋은 습관입니다. 기존 마법 메서드를 덮어쓰거나 사용자 정의 클래스에서 정의하는 것은 괜찮습니다.\u003c/p\u003e\n\u003ch2\u003e특수 속성\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e더블 언더스코어로 시작하고 끝나는 메서드를 매직 또는 던더라고 부르지만, 이 네이밍 규칙을 따르는 속성은 일반적으로 특별 속성이라고 불립니다. 파이썬에 의해 자동으로 생성되고 관리되는 이러한 속성들은 객체에 관한 정보를 제공합니다. 몇 가지 예시를 확인해봅시다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ename\u003c/strong\u003e: 모듈, 클래스, 클래스 메서드 및 함수에서 사용됩니다. (재미있게도, functools.partial을 사용하여 작성된 부분 함수는 이 속성이 없습니다) 객체의 이름을 유지하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edoc\u003c/strong\u003e: 모듈, 클래스, 메서드 또는 함수의 독스트링을 보존합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003efile\u003c/strong\u003e: 모듈이 로드된 파일의 경로를 저장하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e더미 변수\u003c/h2\u003e\n\u003cp\u003e밑줄은 더미 변수로 사용되는 빈번한 용도로 사용됩니다. 이것은 현재 코드에서 사용되지 않는 변수를 나타내는 이름으로 밑줄을 사용한다는 것을 의미합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이런 것은 종종 루프에서 사용되는데, 루핑 변수를 사용하지 않을 때입니다. 다음 상황을 비교해보세요:\u003c/p\u003e\n\u003cp\u003e루핑 변수를 사용하는 경우:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e\u003e\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e):\n...     \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"number {i}\"\u003c/span\u003e)\n\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e루핑 변수를 사용하지 않는 경우:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e\u003e\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e _ \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e):\n...     \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"주마 주마\"\u003c/span\u003e)\n주마 주마\n주마 주마\n주마 주마\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한, 객체를 반환하는 함수나 메서드에서 해당 객체를 사용하지 않을 때 밑줄을 사용하는 것이 좋은 습관입니다. 예를 들어 여기서처럼:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003esave\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eobj\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAny\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: pathlib.\u003cspan class=\"hljs-property\"\u003ePath\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-attr\"\u003ebool\u003c/span\u003e:\n    # 객체가 성공 여부에 관계없이 저장됩니다.\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not \u003cspan class=\"hljs-attr\"\u003esuccess\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n\n_ = \u003cspan class=\"hljs-title function_\"\u003esave\u003c/span\u003e(obj, pathlib.\u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"file.csv\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서는 save()의 출력을 _에 할당했는데, 이는 코드에서 이 출력을 사용할 필요가 없기 때문입니다. 만약 사용해야 한다면, 다음과 같이 하게 됩니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e저장된 = \u003cspan class=\"hljs-title function_\"\u003esave\u003c/span\u003e(obj, pathlib.\u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"file.csv\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e자주 볼 수 있는 대안은 – 내 생각에는 나쁜 – 사용법이 있습니다. 여기서는 출력이 무시됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003esave\u003c/span\u003e(obj, pathlib.\u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"file.csv\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 접근 방식이 마음에 들지 않는 이유는 save() 함수가 아무것도 반환하지 않는 것처럼 보이기 때문입니다. 함수의 출력을 무시하는 경우는 항상 None을 반환할 때뿐이라고 생각합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e프라이빗 메소드 및 속성 표시\u003c/h2\u003e\n\u003cp\u003ePython에는 OOP에서 진정한 은행 메소드나 속성이 없습니다. 이에 대해 여기에서 읽을 수 있습니다:\u003c/p\u003e\n\u003cp\u003e그럼에도 불구하고 사용자에게 클래스 메소드나 속성 중 어떤 것을 프라이빗으로 유지하길 원하는지를 알리는 데 언더바(\u003cem\u003e)를 단일(\u003c/em\u003e) 또는 이중(__)으로 이름 앞에 두고 표시할 수 있습니다. 차이점을 배우려면 위의 기사를 읽어보세요. 이렇게 하면 사용자에게 클래스 외부에서 이러한 메소드나 속성을 사용하지 말아야 한다고 알리는 것과 같습니다. 사용자는 어쨌든 할 수 있지만, 그들에게는 이를 하지 말아야 한다고 알려졌습니다.\u003c/p\u003e\n\u003cp\u003e다음과 같은 클래스를 고려해보세요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMe\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, name, smile=\u003cspan class=\"hljs-string\"\u003e\":-D\"\u003c/span\u003e\u003c/span\u003e):\n        self.name = name\n        self.smile = smile\n        self._thoughts = []\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esay\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, what\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e(what)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e_think\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, what\u003c/span\u003e):\n        self._thoughts += what\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리에게는 나를 나타내는 Me 클래스가 있어요. 다음과 같이 나 자신을 만들 수 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e.name, public 속성 → 당신의 이름은 분명히 공개적이에요\u003c/li\u003e\n\u003cli\u003e.smile, public 속성 → 당신의 미소는 외부에서 보여지기 때문에 분명히 공개적이에요\u003c/li\u003e\n\u003cli\u003e._thoughts, private 속성 → 당신의 생각은 확실하게 비공개적이죠?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e두 개의 public 속성은 언더스코어 없이 이름이 지어지고, 유일한 private 속성은 이름이 언더스코어로 시작해요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 메서드들을 살펴보겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e.say(), 공개 메서드 → 무언가를 말할 때, 사람들이 듣을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e._think(), 비공개 메서드 → 무언가를 생각할 때, 그것은 개인적인 생각입니다. 만약 크게 말하고 싶다면 공개 .say() 메서드를 사용해야 하지만, 생각을 자신에게 간직하고 싶다면 비공개 _think() 메서드를 사용해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e비밀 생각을 대대로 말할 수 있는 공개 메서드를 만들 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003esay_thought\u003c/span\u003e(self, which):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003e_thoughts\u003c/span\u003e[which]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e대화형 세션에서의 마지막 작업\u003c/h2\u003e\n\u003cp\u003ePython 3에서 밑줄은 대화형 세션에서의 마지막 작업 결과를 저장하는데 사용됩니다. 이것은 이전 계산이 이름에 할당되지 않았을 때 새로운 작업에서 이전 작업의 결과를 빠르게 사용하는 데 유용할 수 있습니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e\u003e\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n\u003e\u003e\u003e _ * \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e\n\u003e\u003e\u003e y = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\n\u003e\u003e\u003e _\n\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e\n\u003e\u003e\u003e \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e\n\u003e\u003e\u003e _\n\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e보시다시피 밑줄은 이름에 할당되지 않은 마지막 작업의 결과만 유지하며, 그것이 계산이 아닌 객체일 경우에도(위 코드 블록의 100처럼) 저장됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e숫자 값 형식 지정\u003c/h2\u003e\n\u003cp\u003ePython 3.6에서는 밑줄을 사용하여 대형 숫자 값을 더 쉽게 읽을 수 있게 하는 기능이 추가되었습니다. 이 기능은 대형 정수에 특히 유용하지만 부동 소수점 수에도 적용할 수 있습니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e\u003e\u003e x = \u003cspan class=\"hljs-number\"\u003e1_000_000\u003c/span\u003e\n\u003e\u003e\u003e x\n\u003cspan class=\"hljs-number\"\u003e1000000\u003c/span\u003e\n\u003e\u003e\u003e \u003cspan class=\"hljs-number\"\u003e1.009_232_112\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e1.009232112\u003c/span\u003e\n\u003e\u003e\u003e \u003cspan class=\"hljs-number\"\u003e1_021_232.198_231_111\u003c/span\u003e  \n\u003cspan class=\"hljs-number\"\u003e1021232.198231111\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e보통 대형 정수에 많이 사용되지만 밑줄은 소수값의 가독성을 향상시키는 데도 도움이 됩니다. 이러한 방식은 덜 사용되지만 가능합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003efunctools.singledispatch 사용 사례\u003c/h2\u003e\n\u003cp\u003efunctools.singledispatch에서 밑줄(_)은 특정 타입을 처리하기 위한 익명 구현을 나타내기 위해 함수 이름으로 흔히 사용됩니다. 이 스타일 선택은 함수의 이름이 중요하지 않으며, 오히려 함수가 처리하는 타입이 중요하다는 것을 시사합니다. 이 사용법은 네임스페이스를 깨끗하게 유지하는 데 도움이 되며, 로직이 직접 호출을 위한 것이 아니라 singledispatch 메커니즘에 직접 연결되어 있음을 강조합니다. 다음은 PEP 443에서의 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e\u003e\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e functools \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e singledispatch\n\u003e\u003e\u003e @singledispatch\n... def \u003cspan class=\"hljs-title function_\"\u003efun\u003c/span\u003e(arg, verbose=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e):\n...     \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003everbose\u003c/span\u003e:\n...         \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Let me just say,\"\u003c/span\u003e, end=\u003cspan class=\"hljs-string\"\u003e\" \"\u003c/span\u003e)\n...     \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(arg)\n\u003e\u003e\u003e @fun.\u003cspan class=\"hljs-title function_\"\u003eregister\u003c/span\u003e(int)\n... def \u003cspan class=\"hljs-title function_\"\u003e_\u003c/span\u003e(arg, verbose=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e):\n...     \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003everbose\u003c/span\u003e:\n...         \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Strength in numbers, eh?\"\u003c/span\u003e, end=\u003cspan class=\"hljs-string\"\u003e\" \"\u003c/span\u003e)\n...     \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(arg)\n...\n\u003e\u003e\u003e @fun.\u003cspan class=\"hljs-title function_\"\u003eregister\u003c/span\u003e(list)\n... def \u003cspan class=\"hljs-title function_\"\u003e_\u003c/span\u003e(arg, verbose=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e):\n...     \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003everbose\u003c/span\u003e:\n...         \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Enumerate this:\"\u003c/span\u003e)\n...     \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i, elem \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(arg):\n...         \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(i, elem)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 설정에서 _는 해당 타입에 대한 동작을 구현하여 사용되지 않는 함수 이름으로 네임스페이스를 혼란스럽게 만들지 않습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 코드에 MyPy와 같은 정적 체커를 사용하려면, _를 여러 번 정의하고 있다는 오류가 발생할 수 있다는 점을 알아두세요. 이 문제의 가장 간단한 해결책은 _가 정의된 줄 끝에 # type: ignore 주석을 추가하는 것입니다. 또 다른 방법으로는 현재 _로 호출되는 이러한 함수들을 _로 명명하는 것이 있습니다. 이는 functools.singledispatch에 대한 일반적이지 않은 접근법일 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e국제화와 지역화\u003c/h2\u003e\n\u003cp\u003e국제화(일반적으로 i18n으로 약어)와 지역화(약어로 l10n)는 응용프로그램을 다른 언어와 지역에 적응 가능하게 만들어줍니다. 국제화를 통해 응용프로그램은 코드를 수정하지 않고도 다양한 언어와 지역에 적응할 수 있습니다. 반면에 지역화는 국제화된 소프트웨어를 특정 지역이나 언어에 맞게 적응시키는 데 도움을 줍니다. 이는 로케일별 구성 요소 추가 및 텍스트 번역을 통해 이루어집니다.\u003c/p\u003e\n\u003cp\u003ePython에서는 gettext 모듈을 사용하여 이러한 두 가지 프로세스를 수행할 수 있습니다. 이를 통해 응용프로그램이 여러 언어를 지원할 수 있게 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003egettext에서는 번역할 문자열을 표시하는 gettext 함수에 대한 별명으로 밑줄(_)을 사용하는 것이 일반적입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e\u003e\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e gettext\n\u003e\u003e\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e locale\n\n로캘을 폴란드어로 설정:\n\u003e\u003e\u003e locale.\u003cspan class=\"hljs-title function_\"\u003esetlocale\u003c/span\u003e(locale.\u003cspan class=\"hljs-property\"\u003eLC_ALL\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"pl_PL\"\u003c/span\u003e)\n\n.\u003cspan class=\"hljs-property\"\u003emo\u003c/span\u003e 번역 파일의 경로를 설정하고 텍스트 도메인을 선택:\n\u003e\u003e\u003e gettext.\u003cspan class=\"hljs-title function_\"\u003ebindtextdomain\u003c/span\u003e(\n...     \u003cspan class=\"hljs-string\"\u003e\"myapp\"\u003c/span\u003e,\n...     \u003cspan class=\"hljs-string\"\u003e\"/path/to/my/locale/directory\"\u003c/span\u003e\n... )\n\u003e\u003e\u003e gettext.\u003cspan class=\"hljs-title function_\"\u003etextdomain\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"myapp\"\u003c/span\u003e)\n\n밑줄은 일반적으로 gettext.\u003cspan class=\"hljs-property\"\u003egettext\u003c/span\u003e의 별명으로 사용됩니다:\n\u003e\u003e\u003e _ = gettext.\u003cspan class=\"hljs-property\"\u003egettext\u003c/span\u003e\n\n\u003e\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003e_\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Hello, World!\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title class_\"\u003eWitaj\u003c/span\u003e, świecie!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 _()은 번역할 텍스트를 감싸 줍니다. 번역이 있는 로캘에서 실행되면 gettext.gettext() 및 따라서 _()가 번역된 문자열을 가져옵니다. 밑줄을 사용하는 것은 단순히 더 간단합니다; 비교해 보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e\u003e\u003e gettext.\u003cspan class=\"hljs-title function_\"\u003egettext\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Hello, World!\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title class_\"\u003eWitaj\u003c/span\u003e, świecie!\n\u003e\u003e\u003e \u003cspan class=\"hljs-title function_\"\u003e_\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Hello, World!\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title class_\"\u003eWitaj\u003c/span\u003e, świecie!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e특히 앱이 gettext.gettext 또는 _을 광범위하게 사용하는 경우에 유용합니다.\u003c/p\u003e\n\u003ch2\u003e언패킹 시 값을 무시하는 방법\u003c/h2\u003e\n\u003cp\u003e파이썬에서는 시퀀스를 언패킹할 때 불필요한 값을 무시하기 위해 언더스코어(_)를 사용할 수 있습니다. 이렇게 하면 코드가 더 깔끔하고 가독성이 높아지며, 코드에서 전혀 사용되지 않는 변수를 정의하지 않아도 됩니다.\u003c/p\u003e\n\u003cp\u003e따라서 이해할 필요가 없는 값들을 언더스코어(_)에 할당하여 일회용 변수로 사용할 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e\u003e\u003e a, _, b = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\n\u003e\u003e\u003e a\n\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003e\u003e\u003e b\n\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서는 _ 가 중간 값을 무시하는 데 사용되었습니다 (2).\u003c/p\u003e\n\u003cp\u003e여러 값이 무시해야 하는 경우, 특히 더 긴 시퀀스의 경우에는 *_ 를 사용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e\u003e\u003e a, *_, b = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\n\u003e\u003e\u003e a\n\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003e\u003e\u003e b\n\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e리스트의 첫 번째 값과 마지막 값은 각각 a와 b에 할당되었습니다. 다른 값들 — 2, 3, 4 — 은 * _에 할당되어 무시되었음을 의미하며 더 이상 사용되지 않을 것입니다.\u003c/p\u003e\n\u003cp\u003e이렇게 밑줄을 사용하면 코드의 가독성이 향상되어 특정 값들이 사용되지 않고 더 이상 필요하지 않음을 명확히 합니다. 이는 코드와 관련 데이터에 초점을 유지하는 데 도움이 됩니다. 게다가, 이 세 값을 변수에 할당하는데 사용하지 않는다면, 왜 할당해야 할까요? 이는 좋은 코딩 스타일에 어긋날 것입니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e하나의 작은 문자, 간단한 한 줄, 밑줄은 파이썬 프로그래밍에서 굉장히 유용한 문자입니다. 이것은 파이썬 프로그래머에게 꼭 필요한 도구로 사용되는 다양한 용도를 가지고 있습니다. 또한 이것은 파이썬 자체의 중요한 요소이며, 가끔 _이 무엇을 의미하는지 모른다면 문제를 유발할 수 있으며, 최소한 파이썬 코드를 오해하게 할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e언더스코어의 가장 중요한 사용 사례를 다루었어요. 그러나 덜 중요한 경우 중 일부를 빠뜨렸을 수도 있어요. 그럴 경우에는 댓글로 알려주세요. 어쨌든, 이러한 다양한 사용 사례들로 인해 언더스코어는 파이썬 프로그래밍에서 없어서는 안 될 문자로 자리를 잡았어요. 이 언더스코어는 아마도 이 언어에서 가장 유용한 문자이며, 모든 파이썬 프로그래머는 그 다양한 사용 사례에 익숙해져야 해요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-Pythonandtheunderscore_"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>