<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>앵귤러 Observable의 포괄적 가이드 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-AComprehensiveGuidetoAngularObservables" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="앵귤러 Observable의 포괄적 가이드 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="앵귤러 Observable의 포괄적 가이드 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-AComprehensiveGuidetoAngularObservables" data-gatsby-head="true"/><meta name="twitter:title" content="앵귤러 Observable의 포괄적 가이드 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 00:41" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">앵귤러 Observable의 포괄적 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="앵귤러 Observable의 포괄적 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-AComprehensiveGuidetoAngularObservables&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png">
<h1>소개</h1>
<p>Angular에서 Observables는 반응형 프로그래밍의 필수 요소로, 데이터 스트림을 통한 변경 전파에 중점을 둔 프로그래밍 패러다임입니다. Observables는 개발자가 콜백 또는 프로미스와 같은 전통적인 기술보다 비동기 데이터와 이벤트를 보다 간단하고 효율적으로 처리할 수 있게 합니다.</p>
<p>Observables는 실시간 데이터 업데이트, 이벤트 처리 및 더 많은 기능을 필요로 하는 복잡한 애플리케이션을 구축하는 강력한 도구입니다. 이 글에서는 Angular에서 Observables의 기본 개념, 작동 방식 및 가장 일반적인 사용 사례에 대해 알아보겠습니다. 이 글을 마치면 Observables가 어떻게 더 나은 Angular 애플리케이션을 구축하는 데 도움을 줄 수 있는지에 대해 확고한 이해를 갖게 될 것입니다.</p>
<div class="content-ad"></div>
<h1>옵저버블이란 무엇인가요?</h1>
<p>옵저버블은 Angular에서 반응형 프로그래밍의 핵심 기능입니다. 옵저버블은 시간에 따라 관찰할 수 있는 데이터 스트림입니다. 옵저버블은 배열이나 다른 데이터 구조와 유사하지만 몇 가지 주요 차이점이 있습니다:</p>
<ul>
<li>옵저버블은 시간에 따라 여러 값을 반환할 수 있지만 배열은 정적이며 고정된 값 집합을 포함합니다.</li>
<li>옵저버블은 사용자 입력, 네트워크 요청 및 타이머와 같은 비동기 데이터 소스를 다룰 수 있지만 배열과 같은 동기 데이터 구조는 그렇지 않습니다.</li>
<li>옵저버블은 다양한 방식으로 결합, 변환 및 조합되어 더 복잡한 데이터 스트림을 생성할 수 있습니다.</li>
</ul>
<p>옵저버블은 Angular 프레임워크의 중심 요소이며 이벤트 처리, 데이터 바인딩 및 비동기 프로그래밍에 널리 사용됩니다. 다음 섹션에서 Angular에서 옵저버블을 어떻게 생성하는지 살펴보겠습니다.</p>
<div class="content-ad"></div>
<h1>Observable Creation</h1>
<p>앵귤러에서 Observable을 생성하는 여러 가지 방법이 있습니다. 사용 사례와 작업 중인 데이터 소스에 따라 다릅니다. 여기 몇 가지 일반적인 기술이 있습니다:</p>
<ul>
<li>처음부터 Observable 생성: Observable 생성자를 사용하여 처음부터 Observable을 만들 수 있습니다. 이를 사용하면 사용자 지정 데이터 스트림을 정의하고 next() 메서드를 사용하여 수동으로 값을 전달할 수 있습니다. 다음은 예시입니다:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myObservable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observable</span>(<span class="hljs-function"><span class="hljs-params">observer</span> =></span> {
  observer.<span class="hljs-title function_">next</span>(<span class="hljs-number">1</span>);
  observer.<span class="hljs-title function_">next</span>(<span class="hljs-number">2</span>);
  observer.<span class="hljs-title function_">next</span>(<span class="hljs-number">3</span>);
});
</code></pre>
<div class="content-ad"></div>
<ul>
<li>RxJS 연산자 사용하기: RxJS는 Angular에서 Observables와 함께 작업하는 데 널리 사용되는 라이브러리로, Observables을 생성, 변환 및 결합하는 다양한 연산자를 제공합니다. 예를 들어, of() 연산자를 사용하여 다음과 같이 일정한 값 집합을 방출하는 Observable을 생성할 수 있습니다:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">of</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-keyword">const</span> myObservable = <span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
</code></pre>
<ul>
<li>이벤트에서 Observables 생성하기: DOM 이벤트나 다른 이벤트 소스로부터 Observable을 만들 수 있습니다. 이를 위해 fromEvent() 연산자를 사용할 수 있습니다. 이를 사용하면 사용자 입력이나 다른 이벤트를 반응적이고 효율적으로 처리할 수 있습니다. 다음은 예제입니다:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { fromEvent } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'myButton'</span>);
<span class="hljs-keyword">const</span> clickObservable = <span class="hljs-title function_">fromEvent</span>(button, <span class="hljs-string">'click'</span>);
</code></pre>
<div class="content-ad"></div>
<p>Angular에서 Observable을 만드는 많은 다른 기술들 중에는 promises, timers, 그리고 HTTP 요청과 함께 작업하는 방법이 포함됩니다. 다음 섹션에서는 operators를 사용하여 Observables를 다루는 방법을 살펴볼 것입니다.</p>
<h1>Observables와 Operators</h1>
<p>Operators는 Angular에서 Observables를 다루는 핵심 기능입니다. Operators는 Observables를 다양한 방법으로 변환하거나 조작할 수 있게 해주는 함수들입니다. Angular에서 가장 일반적으로 사용되는 operators 중 일부는 다음과 같습니다:</p>
<ul>
<li>map(): map() operator는 Observable이 방출하는 각 값에 함수를 적용하여 변환합니다. 예를 들어, map()을 사용하여 숫자 스트림을 이들의 제곱 스트림으로 변환할 수 있습니다.</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">of</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { map } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;

<span class="hljs-keyword">const</span> numbers = <span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-keyword">const</span> squared = numbers.<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =></span> x * x));

squared.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">x</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)); <span class="hljs-comment">// 출력: 1, 4, 9</span>
</code></pre>
<ul>
<li>filter(): filter() 연산자는 Observable이 지정된 조건을 충족하지 않는 값을 방출하지 않도록 필터링합니다. 예를 들어, filter()를 사용하여 스트림에서 짝수만 방출할 수 있습니다. 아래와 같이:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">of</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { filter } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;

<span class="hljs-keyword">const</span> numbers = <span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);
<span class="hljs-keyword">const</span> evenNumbers = numbers.<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =></span> x % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>));

evenNumbers.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">x</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)); <span class="hljs-comment">// 출력: 2, 4</span>
</code></pre>
<ul>
<li>merge(): merge() 연산자는 여러 Observable을 하나의 값 스트림으로 결합합니다. 예를 들어, 두 개의 숫자 스트림을 단일 스트림으로 결합할 때 merge()를 사용할 수 있습니다.</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">of</span>, merge } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-keyword">const</span> numbers1 = <span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-keyword">const</span> numbers2 = <span class="hljs-title function_">of</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);
<span class="hljs-keyword">const</span> merged = <span class="hljs-title function_">merge</span>(numbers1, numbers2);

merged.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">x</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x)); <span class="hljs-comment">// Output: 1, 2, 3, 4, 5, 6</span>
</code></pre>
<p>Angular에는 tap(), switchMap(), 그리고 catchError()와 같은 다양한 연산자가 있습니다. 이러한 연산자들은 Angular 애플리케이션에서 더 강력하고 효율적인 데이터 스트림을 생성하는 데 도움이 될 수 있습니다.</p>
<h1>Observables 구독하기</h1>
<p>Observable이 방출하는 데이터를 사용하려면 해당 Observable을 구독해야 합니다. Observable을 구독하는 것은 이벤트 리스너를 등록하는 것과 유사하며, Observable이 방출하는 값을 받아 처리할 수 있게 해줍니다. 다음은 Observable을 구독하는 예제입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">of</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-keyword">const</span> numbers = <span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
numbers.<span class="hljs-title function_">subscribe</span>(
  <span class="hljs-function"><span class="hljs-params">value</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value),
  <span class="hljs-function"><span class="hljs-params">error</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error),
  <span class="hljs-function">() =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Completed'</span>)
);
</code></pre>
<p>이 예제에서는 of() 연산자를 사용하여 Observable을 만들어 정해진 값 집합을 방출합니다. 그런 다음 Observable을 구독하고 세 가지 콜백 함수를 인수로 제공합니다:</p>
<ul>
<li>첫 번째 함수는 Observable에서 방출된 각 값에 대해 처리하고 콘솔에 기록합니다.</li>
<li>두 번째 함수는 Observable 스트림 중 발생한 오류를 처리하고 콘솔에 기록합니다.</li>
<li>세 번째 함수는 Observable이 완료될 때 호출되어 콘솔에 메시지를 기록합니다.</li>
</ul>
<p>이 코드를 실행하면 콘솔에 1, 2, 3 값이 기록된 후 "Completed" 메시지가 표시됩니다.</p>
<div class="content-ad"></div>
<p>Observables는 게으르다는 것이 중요합니다. 이는 구독하지 않는 한 값을 방출하지 않는다는 뜻입니다. Angular 애플리케이션에서 데이터를 검색하고 처리하는 방법과 시기를 제어할 수 있게 해줍니다. 그러나 Observables를 사용한 작업이 끝난 후에는 구독을 해제하여 메모리 누수와 다른 문제를 방지하는 것도 중요합니다.</p>
<h1>Angular 서비스에서 Observables 사용하기</h1>
<p>Angular에서 Observables를 사용하는 가장 일반적인 사례 중 하나는 서비스에서 사용됩니다. 여기서 Observables를 사용하여 API, 데이터베이스 또는 기타 소스에서 데이터를 가져오고 조작할 수 있습니다. 다음은 가짜 API에서 데이터를 가져오기 위해 Observables를 사용하는 간단한 서비스 예제입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">HttpClient</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

@<span class="hljs-title class_">Injectable</span>({
  <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataService</span> {
  private apiUrl = <span class="hljs-string">'&#x3C;https://jsonplaceholder.typicode.com/posts>'</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private http: HttpClient</span>) {}
  <span class="hljs-title function_">getPosts</span>(): <span class="hljs-title class_">Observable</span>&#x3C;any[]> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">http</span>.<span class="hljs-property">get</span>&#x3C;any[]>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">apiUrl</span>);
  }
}
</code></pre>
<div class="content-ad"></div>
<p>이 예제에서는 Angular의 내장 HttpClient를 사용하여 URL이 <a href="https://jsonplaceholder.typicode.com/posts%EC%9D%B8" rel="nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts인</a> 가짜 API에 GET 요청을 하는 DataService라는 서비스를 만듭니다. 우리는 any[] 유형의 Observable을 반환하는 getPosts() 메서드를 정의합니다.</p>
<p>컴포넌트에서 이 서비스를 사용하려면 생성자에 주입하고 getPosts() 메서드를 호출하면 됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">DataService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./data.service'</span>;

@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &#x3C;h1>Posts&#x3C;/h1>
    &#x3C;ul>
      &#x3C;li *ngFor="let post of posts">{{ post.title }}&#x3C;/li>
    &#x3C;/ul>
  `</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppComponent</span> {
  <span class="hljs-attr">posts</span>: any[];
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private dataService: DataService</span>) {}
  <span class="hljs-title function_">ngOnInit</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataService</span>.<span class="hljs-title function_">getPosts</span>().<span class="hljs-title function_">subscribe</span>(
      <span class="hljs-function"><span class="hljs-params">data</span> =></span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">posts</span> = data,
      <span class="hljs-function"><span class="hljs-params">error</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error),
      <span class="hljs-function">() =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Posts loaded'</span>)
    );
  }
}
</code></pre>
<p>이 예제에서는 AppComponent라는 컴포넌트를 만들어 DataService를 사용하여 가짜 API에서 게시물 목록을 가져옵니다. ngOnInit() 메서드를 정의하여 getPosts() Observable을 구독하고 전달된 값들을 처리합니다. Observable이 완료되면 컴포넌트의 posts 속성을 검색된 데이터로 설정합니다.</p>
<div class="content-ad"></div>
<p>이 방법으로 Obserbables와 서비스를 사용하면 Angular 애플리케이션에서 강력하고 유연한 데이터 파이프라인을 만들 수 있어요.</p>
<h1>Observables 조합하기</h1>
<p>Observables의 가장 강력한 기능 중 하나는 다양한 방법으로 조합하고 조작할 수 있는 기능입니다. 이를 통해 다양한 유즈 케이스를 처리하는 복잡한 데이터 파이프라인을 만들 수 있어요. Angular에서 Observables를 조합하는 방법의 예시 몇 가지는 다음과 같아요:</p>
<ul>
<li>Merge: merge() 연산자를 사용하면 여러 Observables을 단일 스트림으로 결합할 수 있어요. 여기에 예시가 있어요:</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { interval, merge } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-keyword">const</span> source1 = <span class="hljs-title function_">interval</span>(<span class="hljs-number">1000</span>);
<span class="hljs-keyword">const</span> source2 = <span class="hljs-title function_">interval</span>(<span class="hljs-number">2000</span>);
<span class="hljs-keyword">const</span> merged = <span class="hljs-title function_">merge</span>(source1, source2);
merged.<span class="hljs-title function_">subscribe</span>(
  <span class="hljs-function"><span class="hljs-params">value</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)
);
</code></pre>
<p>이 예시에서는 interval() 연산자를 사용하여 1초마다 값과 2초마다 값이 발행되는 두 개의 Observable을 생성합니다. 그런 다음 merge() 연산자를 사용하여 이 두 개의 Observable을 하나의 스트림으로 병합합니다. 마지막으로 병합된 Observable을 구독하고 각 발행된 값마다 콘솔에 기록합니다.</p>
<ul>
<li>CombineLatest: combineLatest() 연산자를 사용하면 여러 Observable이 발행한 최신 값들을 하나의 스트림으로 결합할 수 있습니다. 다음은 예시입니다:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { interval, combineLatest } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-keyword">const</span> source1 = <span class="hljs-title function_">interval</span>(<span class="hljs-number">1000</span>);
<span class="hljs-keyword">const</span> source2 = <span class="hljs-title function_">interval</span>(<span class="hljs-number">2000</span>);
<span class="hljs-keyword">const</span> combined = <span class="hljs-title function_">combineLatest</span>(source1, source2);
combined.<span class="hljs-title function_">subscribe</span>(
  <span class="hljs-function"><span class="hljs-params">value</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)
);
</code></pre>
<div class="content-ad"></div>
<p>이 예제에서는 interval() 연산자를 사용하여 각각 1초마다 값과 2초마다 값이 방출되는 두 Observables을 만듭니다. 그런 다음 combineLatest() 연산자를 사용하여 두 Observables에서 최신 값들을 결합하여 단일 스트림으로 만듭니다. 마지막으로 결합된 Observable에 구독하여 각 방출된 값을 콘솔에 기록합니다.</p>
<ul>
<li>Zip: zip() 연산자를 사용하면 여러 Observables에서 방출된 값들을 배열로 결합할 수 있습니다. 다음은 예시입니다:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">of</span>, zip } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-keyword">const</span> source1 = <span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-keyword">const</span> source2 = <span class="hljs-title function_">of</span>(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>);
<span class="hljs-keyword">const</span> zipped = <span class="hljs-title function_">zip</span>(source1, source2);
zipped.<span class="hljs-title function_">subscribe</span>(
  <span class="hljs-function"><span class="hljs-params">value</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)
);
</code></pre>
<p>이 예제에서는 of() 연산자를 사용하여 일정한 값 집합을 방출하는 두 Observables을 만듭니다. 그런 다음 zip() 연산자를 사용하여 두 Observables에서 방출한 값을 배열로 결합합니다. 마지막으로 zipped Observable을 구독하여 각 방출된 값을 콘솔에 기록합니다.</p>
<div class="content-ad"></div>
<p>이 방식으로 옵저버블을 결합하고 조작함으로써, Angular 애플리케이션에서 다양한 유즈 케이스를 처리할 수 있는 복잡한 데이터 파이프라인을 만들 수 있습니다.</p>
<h1>데이터를 변형하고 필터링하기 위해 오퍼레이터 사용하기</h1>
<p>오퍼레이터는 옵저버블이 방출한 데이터를 변형하거나 필터링하거나 기타 방식으로 조작할 수 있는 함수들입니다. Angular 옵저버블과 함께 사용할 수 있는 많은 오퍼레이터가 RxJS 라이브러리에 제공되며, 여기에 몇 가지 예시가 있습니다:</p>
<ul>
<li>Map: map() 오퍼레이터를 사용하면 옵저버블에서 방출된 각 값을 새 값으로 변환할 수 있습니다. 다음은 예시입니다:</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">of</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { map } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;

<span class="hljs-keyword">const</span> source = <span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-keyword">const</span> mapped = source.<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">value</span> =></span> value * <span class="hljs-number">2</span>));
mapped.<span class="hljs-title function_">subscribe</span>(
  <span class="hljs-function"><span class="hljs-params">value</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)
);
</code></pre>
<p>이 예제에서는 of() 연산자를 사용하여 값을 고정된 세트로 방출하는 Observable을 생성합니다. 그런 다음 map() 연산자를 사용하여 각 방출된 값에 2를 곱해 변환합니다. 마지막으로 매핑된 Observable에 구독하고 각 방출된 값을 콘솔에 로깅합니다.</p>
<ul>
<li>Filter: filter() 연산자를 사용하면 주어진 조건에 따라 Observable에서 방출된 값을 필터링할 수 있습니다. 다음은 예시입니다:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">of</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { filter } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;

<span class="hljs-keyword">const</span> source = <span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-keyword">const</span> filtered = source.<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">value</span> =></span> value % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>));
filtered.<span class="hljs-title function_">subscribe</span>(
  <span class="hljs-function"><span class="hljs-params">value</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)
);
</code></pre>
<div class="content-ad"></div>
<p>이 예시에서는 of() 연산자를 사용하여 Observable을 만듭니다. 이 연산자는 고정된 값 집합을 방출합니다. 그런 다음 filter() 연산자를 사용하여 짝수인 값만 방출하도록합니다. 마지막으로 필터링된 Observable을 구독하고 콘솔에 각 방출된 값을 기록합니다.</p>
<ul>
<li>Reduce: reduce() 연산자를 사용하면 Observable이 방출하는 값들을 누적하고 단일 값으로 반환할 수 있습니다. 다음은 예제입니다:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">of</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { reduce } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;

<span class="hljs-keyword">const</span> source = <span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-keyword">const</span> reduced = source.<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, value</span>) =></span> acc + value));
reduced.<span class="hljs-title function_">subscribe</span>(
  <span class="hljs-function"><span class="hljs-params">value</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)
);
</code></pre>
<p>이 예시에서는 of() 연산자를 사용하여 고정된 값 집합을 방출하는 Observable을 만듭니다. 그런 다음 reduce() 연산자를 사용하여 Observable이 방출하는 값들을 누적하고 그 합계를 반환합니다. 마지막으로 누적된 Observable을 구독하고 콘솔에 최종 누적 값의 로그를 남깁니다.</p>
<div class="content-ad"></div>
<p>연산자인 map(), filter(), reduce()와 같은 것을 사용하여 Observable이 방출하는 데이터를 변환, 필터링하고 조작하여 Angular 애플리케이션에서 특정한 사용 사례에 맞게 맞출 수 있습니다.</p>
<h1>Subjects를 사용하여 값을 방출하기</h1>
<p>Observable 외에도 RxJS 라이브러리는 여러 구독자에게 값을 방출할 수 있는 Subject 클래스를 제공합니다. Subject는 Observable과 Observer 둘 다이므로 값을 방출하고 다른 Observables에 구독할 수 있습니다.</p>
<p>다음은 Angular에서 Subject를 생성하는 예제입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Subject</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> {
  mySubject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>&#x3C;string>();
  <span class="hljs-title function_">emitValue</span>(<span class="hljs-params">value: string</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mySubject</span>.<span class="hljs-title function_">next</span>(value);
  }
}
</code></pre>
<p>이 예시에서는 문자열 유형의 Subject를 생성하고 MyComponent 클래스의 속성으로 저장합니다. 그런 다음 emitValue() 메서드를 정의하고 해당 값을 mySubject 객체의 next() 메서드를 호출하여 구독자에게 해당 값을 방출합니다.</p>
<p>Subject를 다른 Observable처럼 구독할 수 있습니다:</p>
<pre><code class="hljs language-js">myComponent.<span class="hljs-property">mySubject</span>.<span class="hljs-title function_">subscribe</span>(
  <span class="hljs-function"><span class="hljs-params">value</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)
)
</code></pre>
<div class="content-ad"></div>
<p>이 예시에서는 myComponent 객체의 mySubject Subject에 구독(subscribe)하여 발생한 모든 값들을 콘솔에 기록합니다.</p>
<p>한 가지 주의할 점은 Subject를 구독할 때 Subject가 생성된 이후에 발생한 모든 값들을 받게 되는 것입니다. 구독 이후에 발생한 값들만 받고 싶다면 BehaviorSubject를 사용할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BehaviorSubject</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> {
  mySubject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BehaviorSubject</span>&#x3C;string>(<span class="hljs-string">'initial value'</span>);
  <span class="hljs-title function_">emitValue</span>(<span class="hljs-params">value: string</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mySubject</span>.<span class="hljs-title function_">next</span>(value);
  }
}
</code></pre>
<p>이 예시에서는 string 타입의 BehaviorSubject를 생성하고 초기값을 <code>initial value</code>로 설정합니다. BehaviorSubject를 구독하면 초기값을 먼저 받은 뒤에 구독 이후에 발생한 모든 값들을 받게 됩니다.</p>
<div class="content-ad"></div>
<p>Subject 및 BehaviorSubject을 사용하면 Angular 애플리케이션에서 값들을 발행하고 구독하는 강력한 방법이 될 수 있습니다. 이를 통해 컴포넌트와 서비스 간에 데이터를 쉽게 공유할 수 있으며 복잡한 데이터 흐름 시나리오를 간단화할 수 있습니다.</p>
<h1>결론</h1>
<p>Angular Observables은 Angular 애플리케이션의 비동기 데이터 흐름을 관리하는 강력한 도구입니다. RxJS 라이브러리의 도움으로 사용자 입력부터 HTTP 요청까지 모두 처리할 수 있는 Observables을 만들고 조작할 수 있습니다.</p>
<p>이 글에서는 Observables의 기본을 다룰 때, 생성하고 구독하는 방법 및 연산자를 사용하여 발행된 값들을 변환하고 필터링하는 방법을 다뤘습니다. 또한 Subject을 사용하여 여러 구독자에게 값을 발행하는 고급 주제도 살펴보았습니다.</p>
<div class="content-ad"></div>
<p>앵귤러 옵저버블을 효과적으로 활용하는 방법을 이해하면, 더 반응형이고 빠른 응용 프로그램을 만들어 사용자 경험을 향상시킬 수 있습니다. 간단한 양식 데이터든 복잡한 데이터 스트림이든 옵저버블을 사용하면 쉽게 관리할 수 있습니다.</p>
<p>다음에 앵귤러 응용 프로그램을 작성할 때는 데이터 흐름 요구 사항을 처리하기 위해 옵저버블을 사용해보세요. 강력한 기능과 다양한 기능 세트로, 보다 견고하고 유연하며 확장 가능한 응용 프로그램을 만들 수 있을 것입니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"앵귤러 Observable의 포괄적 가이드","description":"","date":"2024-06-20 00:41","slug":"2024-06-20-AComprehensiveGuidetoAngularObservables","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png\" /\u003e\n\n# 소개\n\nAngular에서 Observables는 반응형 프로그래밍의 필수 요소로, 데이터 스트림을 통한 변경 전파에 중점을 둔 프로그래밍 패러다임입니다. Observables는 개발자가 콜백 또는 프로미스와 같은 전통적인 기술보다 비동기 데이터와 이벤트를 보다 간단하고 효율적으로 처리할 수 있게 합니다.\n\nObservables는 실시간 데이터 업데이트, 이벤트 처리 및 더 많은 기능을 필요로 하는 복잡한 애플리케이션을 구축하는 강력한 도구입니다. 이 글에서는 Angular에서 Observables의 기본 개념, 작동 방식 및 가장 일반적인 사용 사례에 대해 알아보겠습니다. 이 글을 마치면 Observables가 어떻게 더 나은 Angular 애플리케이션을 구축하는 데 도움을 줄 수 있는지에 대해 확고한 이해를 갖게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 옵저버블이란 무엇인가요?\n\n옵저버블은 Angular에서 반응형 프로그래밍의 핵심 기능입니다. 옵저버블은 시간에 따라 관찰할 수 있는 데이터 스트림입니다. 옵저버블은 배열이나 다른 데이터 구조와 유사하지만 몇 가지 주요 차이점이 있습니다:\n\n- 옵저버블은 시간에 따라 여러 값을 반환할 수 있지만 배열은 정적이며 고정된 값 집합을 포함합니다.\n- 옵저버블은 사용자 입력, 네트워크 요청 및 타이머와 같은 비동기 데이터 소스를 다룰 수 있지만 배열과 같은 동기 데이터 구조는 그렇지 않습니다.\n- 옵저버블은 다양한 방식으로 결합, 변환 및 조합되어 더 복잡한 데이터 스트림을 생성할 수 있습니다.\n\n옵저버블은 Angular 프레임워크의 중심 요소이며 이벤트 처리, 데이터 바인딩 및 비동기 프로그래밍에 널리 사용됩니다. 다음 섹션에서 Angular에서 옵저버블을 어떻게 생성하는지 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Observable Creation\n\n앵귤러에서 Observable을 생성하는 여러 가지 방법이 있습니다. 사용 사례와 작업 중인 데이터 소스에 따라 다릅니다. 여기 몇 가지 일반적인 기술이 있습니다:\n\n- 처음부터 Observable 생성: Observable 생성자를 사용하여 처음부터 Observable을 만들 수 있습니다. 이를 사용하면 사용자 지정 데이터 스트림을 정의하고 next() 메서드를 사용하여 수동으로 값을 전달할 수 있습니다. 다음은 예시입니다:\n\n```js\nconst myObservable = new Observable(observer =\u003e {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- RxJS 연산자 사용하기: RxJS는 Angular에서 Observables와 함께 작업하는 데 널리 사용되는 라이브러리로, Observables을 생성, 변환 및 결합하는 다양한 연산자를 제공합니다. 예를 들어, of() 연산자를 사용하여 다음과 같이 일정한 값 집합을 방출하는 Observable을 생성할 수 있습니다:\n\n```js\nimport { of } from 'rxjs';\n\nconst myObservable = of(1, 2, 3);\n```\n\n- 이벤트에서 Observables 생성하기: DOM 이벤트나 다른 이벤트 소스로부터 Observable을 만들 수 있습니다. 이를 위해 fromEvent() 연산자를 사용할 수 있습니다. 이를 사용하면 사용자 입력이나 다른 이벤트를 반응적이고 효율적으로 처리할 수 있습니다. 다음은 예제입니다:\n\n```js\nimport { fromEvent } from 'rxjs';\n\nconst button = document.getElementById('myButton');\nconst clickObservable = fromEvent(button, 'click');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular에서 Observable을 만드는 많은 다른 기술들 중에는 promises, timers, 그리고 HTTP 요청과 함께 작업하는 방법이 포함됩니다. 다음 섹션에서는 operators를 사용하여 Observables를 다루는 방법을 살펴볼 것입니다.\n\n# Observables와 Operators\n\nOperators는 Angular에서 Observables를 다루는 핵심 기능입니다. Operators는 Observables를 다양한 방법으로 변환하거나 조작할 수 있게 해주는 함수들입니다. Angular에서 가장 일반적으로 사용되는 operators 중 일부는 다음과 같습니다:\n\n- map(): map() operator는 Observable이 방출하는 각 값에 함수를 적용하여 변환합니다. 예를 들어, map()을 사용하여 숫자 스트림을 이들의 제곱 스트림으로 변환할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst numbers = of(1, 2, 3);\nconst squared = numbers.pipe(map(x =\u003e x * x));\n\nsquared.subscribe(x =\u003e console.log(x)); // 출력: 1, 4, 9\n```\n\n- filter(): filter() 연산자는 Observable이 지정된 조건을 충족하지 않는 값을 방출하지 않도록 필터링합니다. 예를 들어, filter()를 사용하여 스트림에서 짝수만 방출할 수 있습니다. 아래와 같이:\n\n```js\nimport { of } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nconst numbers = of(1, 2, 3, 4, 5);\nconst evenNumbers = numbers.pipe(filter(x =\u003e x % 2 === 0));\n\nevenNumbers.subscribe(x =\u003e console.log(x)); // 출력: 2, 4\n```\n\n- merge(): merge() 연산자는 여러 Observable을 하나의 값 스트림으로 결합합니다. 예를 들어, 두 개의 숫자 스트림을 단일 스트림으로 결합할 때 merge()를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { of, merge } from 'rxjs';\n\nconst numbers1 = of(1, 2, 3);\nconst numbers2 = of(4, 5, 6);\nconst merged = merge(numbers1, numbers2);\n\nmerged.subscribe(x =\u003e console.log(x)); // Output: 1, 2, 3, 4, 5, 6\n```\n\nAngular에는 tap(), switchMap(), 그리고 catchError()와 같은 다양한 연산자가 있습니다. 이러한 연산자들은 Angular 애플리케이션에서 더 강력하고 효율적인 데이터 스트림을 생성하는 데 도움이 될 수 있습니다.\n\n# Observables 구독하기\n\nObservable이 방출하는 데이터를 사용하려면 해당 Observable을 구독해야 합니다. Observable을 구독하는 것은 이벤트 리스너를 등록하는 것과 유사하며, Observable이 방출하는 값을 받아 처리할 수 있게 해줍니다. 다음은 Observable을 구독하는 예제입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { of } from 'rxjs';\n\nconst numbers = of(1, 2, 3);\nnumbers.subscribe(\n  value =\u003e console.log(value),\n  error =\u003e console.error(error),\n  () =\u003e console.log('Completed')\n);\n```\n\n이 예제에서는 of() 연산자를 사용하여 Observable을 만들어 정해진 값 집합을 방출합니다. 그런 다음 Observable을 구독하고 세 가지 콜백 함수를 인수로 제공합니다:\n\n- 첫 번째 함수는 Observable에서 방출된 각 값에 대해 처리하고 콘솔에 기록합니다.\n- 두 번째 함수는 Observable 스트림 중 발생한 오류를 처리하고 콘솔에 기록합니다.\n- 세 번째 함수는 Observable이 완료될 때 호출되어 콘솔에 메시지를 기록합니다.\n\n이 코드를 실행하면 콘솔에 1, 2, 3 값이 기록된 후 \"Completed\" 메시지가 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nObservables는 게으르다는 것이 중요합니다. 이는 구독하지 않는 한 값을 방출하지 않는다는 뜻입니다. Angular 애플리케이션에서 데이터를 검색하고 처리하는 방법과 시기를 제어할 수 있게 해줍니다. 그러나 Observables를 사용한 작업이 끝난 후에는 구독을 해제하여 메모리 누수와 다른 문제를 방지하는 것도 중요합니다.\n\n# Angular 서비스에서 Observables 사용하기\n\nAngular에서 Observables를 사용하는 가장 일반적인 사례 중 하나는 서비스에서 사용됩니다. 여기서 Observables를 사용하여 API, 데이터베이스 또는 기타 소스에서 데이터를 가져오고 조작할 수 있습니다. 다음은 가짜 API에서 데이터를 가져오기 위해 Observables를 사용하는 간단한 서비스 예제입니다:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n  private apiUrl = '\u003chttps://jsonplaceholder.typicode.com/posts\u003e';\n  constructor(private http: HttpClient) {}\n  getPosts(): Observable\u003cany[]\u003e {\n    return this.http.get\u003cany[]\u003e(this.apiUrl);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 Angular의 내장 HttpClient를 사용하여 URL이 https://jsonplaceholder.typicode.com/posts인 가짜 API에 GET 요청을 하는 DataService라는 서비스를 만듭니다. 우리는 any[] 유형의 Observable을 반환하는 getPosts() 메서드를 정의합니다. \n\n컴포넌트에서 이 서비스를 사용하려면 생성자에 주입하고 getPosts() 메서드를 호출하면 됩니다:\n\n```js\nimport { Component } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-root',\n  template: `\n    \u003ch1\u003ePosts\u003c/h1\u003e\n    \u003cul\u003e\n      \u003cli *ngFor=\"let post of posts\"\u003e{{ post.title }}\u003c/li\u003e\n    \u003c/ul\u003e\n  `\n})\nexport class AppComponent {\n  posts: any[];\n  constructor(private dataService: DataService) {}\n  ngOnInit() {\n    this.dataService.getPosts().subscribe(\n      data =\u003e this.posts = data,\n      error =\u003e console.error(error),\n      () =\u003e console.log('Posts loaded')\n    );\n  }\n}\n```\n\n이 예제에서는 AppComponent라는 컴포넌트를 만들어 DataService를 사용하여 가짜 API에서 게시물 목록을 가져옵니다. ngOnInit() 메서드를 정의하여 getPosts() Observable을 구독하고 전달된 값들을 처리합니다. Observable이 완료되면 컴포넌트의 posts 속성을 검색된 데이터로 설정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법으로 Obserbables와 서비스를 사용하면 Angular 애플리케이션에서 강력하고 유연한 데이터 파이프라인을 만들 수 있어요.\n\n# Observables 조합하기\n\nObservables의 가장 강력한 기능 중 하나는 다양한 방법으로 조합하고 조작할 수 있는 기능입니다. 이를 통해 다양한 유즈 케이스를 처리하는 복잡한 데이터 파이프라인을 만들 수 있어요. Angular에서 Observables를 조합하는 방법의 예시 몇 가지는 다음과 같아요:\n\n- Merge: merge() 연산자를 사용하면 여러 Observables을 단일 스트림으로 결합할 수 있어요. 여기에 예시가 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nimport { interval, merge } from 'rxjs';\r\n\r\nconst source1 = interval(1000);\r\nconst source2 = interval(2000);\r\nconst merged = merge(source1, source2);\r\nmerged.subscribe(\r\n  value =\u003e console.log(value)\r\n);\r\n```\r\n\r\n이 예시에서는 interval() 연산자를 사용하여 1초마다 값과 2초마다 값이 발행되는 두 개의 Observable을 생성합니다. 그런 다음 merge() 연산자를 사용하여 이 두 개의 Observable을 하나의 스트림으로 병합합니다. 마지막으로 병합된 Observable을 구독하고 각 발행된 값마다 콘솔에 기록합니다.\r\n\r\n- CombineLatest: combineLatest() 연산자를 사용하면 여러 Observable이 발행한 최신 값들을 하나의 스트림으로 결합할 수 있습니다. 다음은 예시입니다:\r\n\r\n```js\r\nimport { interval, combineLatest } from 'rxjs';\r\n\r\nconst source1 = interval(1000);\r\nconst source2 = interval(2000);\r\nconst combined = combineLatest(source1, source2);\r\ncombined.subscribe(\r\n  value =\u003e console.log(value)\r\n);\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 interval() 연산자를 사용하여 각각 1초마다 값과 2초마다 값이 방출되는 두 Observables을 만듭니다. 그런 다음 combineLatest() 연산자를 사용하여 두 Observables에서 최신 값들을 결합하여 단일 스트림으로 만듭니다. 마지막으로 결합된 Observable에 구독하여 각 방출된 값을 콘솔에 기록합니다.\n\n- Zip: zip() 연산자를 사용하면 여러 Observables에서 방출된 값들을 배열로 결합할 수 있습니다. 다음은 예시입니다:\n\n```js\nimport { of, zip } from 'rxjs';\n\nconst source1 = of(1, 2, 3);\nconst source2 = of('a', 'b', 'c');\nconst zipped = zip(source1, source2);\nzipped.subscribe(\n  value =\u003e console.log(value)\n);\n```\n\n이 예제에서는 of() 연산자를 사용하여 일정한 값 집합을 방출하는 두 Observables을 만듭니다. 그런 다음 zip() 연산자를 사용하여 두 Observables에서 방출한 값을 배열로 결합합니다. 마지막으로 zipped Observable을 구독하여 각 방출된 값을 콘솔에 기록합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방식으로 옵저버블을 결합하고 조작함으로써, Angular 애플리케이션에서 다양한 유즈 케이스를 처리할 수 있는 복잡한 데이터 파이프라인을 만들 수 있습니다.\n\n# 데이터를 변형하고 필터링하기 위해 오퍼레이터 사용하기\n\n오퍼레이터는 옵저버블이 방출한 데이터를 변형하거나 필터링하거나 기타 방식으로 조작할 수 있는 함수들입니다. Angular 옵저버블과 함께 사용할 수 있는 많은 오퍼레이터가 RxJS 라이브러리에 제공되며, 여기에 몇 가지 예시가 있습니다:\n\n- Map: map() 오퍼레이터를 사용하면 옵저버블에서 방출된 각 값을 새 값으로 변환할 수 있습니다. 다음은 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\nconst mapped = source.pipe(map(value =\u003e value * 2));\nmapped.subscribe(\n  value =\u003e console.log(value)\n);\n```\n\n이 예제에서는 of() 연산자를 사용하여 값을 고정된 세트로 방출하는 Observable을 생성합니다. 그런 다음 map() 연산자를 사용하여 각 방출된 값에 2를 곱해 변환합니다. 마지막으로 매핑된 Observable에 구독하고 각 방출된 값을 콘솔에 로깅합니다.\n\n- Filter: filter() 연산자를 사용하면 주어진 조건에 따라 Observable에서 방출된 값을 필터링할 수 있습니다. 다음은 예시입니다:\n\n```js\nimport { of } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\nconst filtered = source.pipe(filter(value =\u003e value % 2 === 0));\nfiltered.subscribe(\n  value =\u003e console.log(value)\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 of() 연산자를 사용하여 Observable을 만듭니다. 이 연산자는 고정된 값 집합을 방출합니다. 그런 다음 filter() 연산자를 사용하여 짝수인 값만 방출하도록합니다. 마지막으로 필터링된 Observable을 구독하고 콘솔에 각 방출된 값을 기록합니다.\n\n- Reduce: reduce() 연산자를 사용하면 Observable이 방출하는 값들을 누적하고 단일 값으로 반환할 수 있습니다. 다음은 예제입니다:\n\n```js\nimport { of } from 'rxjs';\nimport { reduce } from 'rxjs/operators';\n\nconst source = of(1, 2, 3);\nconst reduced = source.pipe(reduce((acc, value) =\u003e acc + value));\nreduced.subscribe(\n  value =\u003e console.log(value)\n);\n```\n\n이 예시에서는 of() 연산자를 사용하여 고정된 값 집합을 방출하는 Observable을 만듭니다. 그런 다음 reduce() 연산자를 사용하여 Observable이 방출하는 값들을 누적하고 그 합계를 반환합니다. 마지막으로 누적된 Observable을 구독하고 콘솔에 최종 누적 값의 로그를 남깁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n연산자인 map(), filter(), reduce()와 같은 것을 사용하여 Observable이 방출하는 데이터를 변환, 필터링하고 조작하여 Angular 애플리케이션에서 특정한 사용 사례에 맞게 맞출 수 있습니다.\n\n# Subjects를 사용하여 값을 방출하기\n\nObservable 외에도 RxJS 라이브러리는 여러 구독자에게 값을 방출할 수 있는 Subject 클래스를 제공합니다. Subject는 Observable과 Observer 둘 다이므로 값을 방출하고 다른 Observables에 구독할 수 있습니다.\n\n다음은 Angular에서 Subject를 생성하는 예제입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { Subject } from 'rxjs';\n\nexport class MyComponent {\n  mySubject = new Subject\u003cstring\u003e();\n  emitValue(value: string) {\n    this.mySubject.next(value);\n  }\n}\n```\n\n이 예시에서는 문자열 유형의 Subject를 생성하고 MyComponent 클래스의 속성으로 저장합니다. 그런 다음 emitValue() 메서드를 정의하고 해당 값을 mySubject 객체의 next() 메서드를 호출하여 구독자에게 해당 값을 방출합니다.\n\nSubject를 다른 Observable처럼 구독할 수 있습니다:\n\n```js\nmyComponent.mySubject.subscribe(\n  value =\u003e console.log(value)\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 myComponent 객체의 mySubject Subject에 구독(subscribe)하여 발생한 모든 값들을 콘솔에 기록합니다.\n\n한 가지 주의할 점은 Subject를 구독할 때 Subject가 생성된 이후에 발생한 모든 값들을 받게 되는 것입니다. 구독 이후에 발생한 값들만 받고 싶다면 BehaviorSubject를 사용할 수 있습니다:\n\n```js\nimport { BehaviorSubject } from 'rxjs';\n\nexport class MyComponent {\n  mySubject = new BehaviorSubject\u003cstring\u003e('initial value');\n  emitValue(value: string) {\n    this.mySubject.next(value);\n  }\n}\n```\n\n이 예시에서는 string 타입의 BehaviorSubject를 생성하고 초기값을 `initial value`로 설정합니다. BehaviorSubject를 구독하면 초기값을 먼저 받은 뒤에 구독 이후에 발생한 모든 값들을 받게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSubject 및 BehaviorSubject을 사용하면 Angular 애플리케이션에서 값들을 발행하고 구독하는 강력한 방법이 될 수 있습니다. 이를 통해 컴포넌트와 서비스 간에 데이터를 쉽게 공유할 수 있으며 복잡한 데이터 흐름 시나리오를 간단화할 수 있습니다.\n\n# 결론\n\nAngular Observables은 Angular 애플리케이션의 비동기 데이터 흐름을 관리하는 강력한 도구입니다. RxJS 라이브러리의 도움으로 사용자 입력부터 HTTP 요청까지 모두 처리할 수 있는 Observables을 만들고 조작할 수 있습니다.\n\n이 글에서는 Observables의 기본을 다룰 때, 생성하고 구독하는 방법 및 연산자를 사용하여 발행된 값들을 변환하고 필터링하는 방법을 다뤘습니다. 또한 Subject을 사용하여 여러 구독자에게 값을 발행하는 고급 주제도 살펴보았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앵귤러 옵저버블을 효과적으로 활용하는 방법을 이해하면, 더 반응형이고 빠른 응용 프로그램을 만들어 사용자 경험을 향상시킬 수 있습니다. 간단한 양식 데이터든 복잡한 데이터 스트림이든 옵저버블을 사용하면 쉽게 관리할 수 있습니다.\n\n다음에 앵귤러 응용 프로그램을 작성할 때는 데이터 흐름 요구 사항을 처리하기 위해 옵저버블을 사용해보세요. 강력한 기능과 다양한 기능 세트로, 보다 견고하고 유연하며 확장 가능한 응용 프로그램을 만들 수 있을 것입니다.","ogImage":{"url":"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png"},"coverImage":"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-20-AComprehensiveGuidetoAngularObservables_0.png\"\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003eAngular에서 Observables는 반응형 프로그래밍의 필수 요소로, 데이터 스트림을 통한 변경 전파에 중점을 둔 프로그래밍 패러다임입니다. Observables는 개발자가 콜백 또는 프로미스와 같은 전통적인 기술보다 비동기 데이터와 이벤트를 보다 간단하고 효율적으로 처리할 수 있게 합니다.\u003c/p\u003e\n\u003cp\u003eObservables는 실시간 데이터 업데이트, 이벤트 처리 및 더 많은 기능을 필요로 하는 복잡한 애플리케이션을 구축하는 강력한 도구입니다. 이 글에서는 Angular에서 Observables의 기본 개념, 작동 방식 및 가장 일반적인 사용 사례에 대해 알아보겠습니다. 이 글을 마치면 Observables가 어떻게 더 나은 Angular 애플리케이션을 구축하는 데 도움을 줄 수 있는지에 대해 확고한 이해를 갖게 될 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e옵저버블이란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e옵저버블은 Angular에서 반응형 프로그래밍의 핵심 기능입니다. 옵저버블은 시간에 따라 관찰할 수 있는 데이터 스트림입니다. 옵저버블은 배열이나 다른 데이터 구조와 유사하지만 몇 가지 주요 차이점이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e옵저버블은 시간에 따라 여러 값을 반환할 수 있지만 배열은 정적이며 고정된 값 집합을 포함합니다.\u003c/li\u003e\n\u003cli\u003e옵저버블은 사용자 입력, 네트워크 요청 및 타이머와 같은 비동기 데이터 소스를 다룰 수 있지만 배열과 같은 동기 데이터 구조는 그렇지 않습니다.\u003c/li\u003e\n\u003cli\u003e옵저버블은 다양한 방식으로 결합, 변환 및 조합되어 더 복잡한 데이터 스트림을 생성할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e옵저버블은 Angular 프레임워크의 중심 요소이며 이벤트 처리, 데이터 바인딩 및 비동기 프로그래밍에 널리 사용됩니다. 다음 섹션에서 Angular에서 옵저버블을 어떻게 생성하는지 살펴보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eObservable Creation\u003c/h1\u003e\n\u003cp\u003e앵귤러에서 Observable을 생성하는 여러 가지 방법이 있습니다. 사용 사례와 작업 중인 데이터 소스에 따라 다릅니다. 여기 몇 가지 일반적인 기술이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e처음부터 Observable 생성: Observable 생성자를 사용하여 처음부터 Observable을 만들 수 있습니다. 이를 사용하면 사용자 지정 데이터 스트림을 정의하고 next() 메서드를 사용하여 수동으로 값을 전달할 수 있습니다. 다음은 예시입니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myObservable = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eobserver\u003c/span\u003e =\u003e\u003c/span\u003e {\n  observer.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  observer.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n  observer.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eRxJS 연산자 사용하기: RxJS는 Angular에서 Observables와 함께 작업하는 데 널리 사용되는 라이브러리로, Observables을 생성, 변환 및 결합하는 다양한 연산자를 제공합니다. 예를 들어, of() 연산자를 사용하여 다음과 같이 일정한 값 집합을 방출하는 Observable을 생성할 수 있습니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myObservable = \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e이벤트에서 Observables 생성하기: DOM 이벤트나 다른 이벤트 소스로부터 Observable을 만들 수 있습니다. 이를 위해 fromEvent() 연산자를 사용할 수 있습니다. 이를 사용하면 사용자 입력이나 다른 이벤트를 반응적이고 효율적으로 처리할 수 있습니다. 다음은 예제입니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { fromEvent } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e button = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'myButton'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e clickObservable = \u003cspan class=\"hljs-title function_\"\u003efromEvent\u003c/span\u003e(button, \u003cspan class=\"hljs-string\"\u003e'click'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eAngular에서 Observable을 만드는 많은 다른 기술들 중에는 promises, timers, 그리고 HTTP 요청과 함께 작업하는 방법이 포함됩니다. 다음 섹션에서는 operators를 사용하여 Observables를 다루는 방법을 살펴볼 것입니다.\u003c/p\u003e\n\u003ch1\u003eObservables와 Operators\u003c/h1\u003e\n\u003cp\u003eOperators는 Angular에서 Observables를 다루는 핵심 기능입니다. Operators는 Observables를 다양한 방법으로 변환하거나 조작할 수 있게 해주는 함수들입니다. Angular에서 가장 일반적으로 사용되는 operators 중 일부는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emap(): map() operator는 Observable이 방출하는 각 값에 함수를 적용하여 변환합니다. 예를 들어, map()을 사용하여 숫자 스트림을 이들의 제곱 스트림으로 변환할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { map } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs/operators'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e numbers = \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e squared = numbers.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u003e\u003c/span\u003e x * x));\n\nsquared.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x)); \u003cspan class=\"hljs-comment\"\u003e// 출력: 1, 4, 9\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003efilter(): filter() 연산자는 Observable이 지정된 조건을 충족하지 않는 값을 방출하지 않도록 필터링합니다. 예를 들어, filter()를 사용하여 스트림에서 짝수만 방출할 수 있습니다. 아래와 같이:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { filter } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs/operators'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e numbers = \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e evenNumbers = numbers.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u003e\u003c/span\u003e x % \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e));\n\nevenNumbers.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x)); \u003cspan class=\"hljs-comment\"\u003e// 출력: 2, 4\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003emerge(): merge() 연산자는 여러 Observable을 하나의 값 스트림으로 결합합니다. 예를 들어, 두 개의 숫자 스트림을 단일 스트림으로 결합할 때 merge()를 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e, merge } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e numbers1 = \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e numbers2 = \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e merged = \u003cspan class=\"hljs-title function_\"\u003emerge\u003c/span\u003e(numbers1, numbers2);\n\nmerged.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x)); \u003cspan class=\"hljs-comment\"\u003e// Output: 1, 2, 3, 4, 5, 6\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAngular에는 tap(), switchMap(), 그리고 catchError()와 같은 다양한 연산자가 있습니다. 이러한 연산자들은 Angular 애플리케이션에서 더 강력하고 효율적인 데이터 스트림을 생성하는 데 도움이 될 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eObservables 구독하기\u003c/h1\u003e\n\u003cp\u003eObservable이 방출하는 데이터를 사용하려면 해당 Observable을 구독해야 합니다. Observable을 구독하는 것은 이벤트 리스너를 등록하는 것과 유사하며, Observable이 방출하는 값을 받아 처리할 수 있게 해줍니다. 다음은 Observable을 구독하는 예제입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e numbers = \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\nnumbers.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value),\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(error),\n  \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Completed'\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 of() 연산자를 사용하여 Observable을 만들어 정해진 값 집합을 방출합니다. 그런 다음 Observable을 구독하고 세 가지 콜백 함수를 인수로 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e첫 번째 함수는 Observable에서 방출된 각 값에 대해 처리하고 콘솔에 기록합니다.\u003c/li\u003e\n\u003cli\u003e두 번째 함수는 Observable 스트림 중 발생한 오류를 처리하고 콘솔에 기록합니다.\u003c/li\u003e\n\u003cli\u003e세 번째 함수는 Observable이 완료될 때 호출되어 콘솔에 메시지를 기록합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 코드를 실행하면 콘솔에 1, 2, 3 값이 기록된 후 \"Completed\" 메시지가 표시됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eObservables는 게으르다는 것이 중요합니다. 이는 구독하지 않는 한 값을 방출하지 않는다는 뜻입니다. Angular 애플리케이션에서 데이터를 검색하고 처리하는 방법과 시기를 제어할 수 있게 해줍니다. 그러나 Observables를 사용한 작업이 끝난 후에는 구독을 해제하여 메모리 누수와 다른 문제를 방지하는 것도 중요합니다.\u003c/p\u003e\n\u003ch1\u003eAngular 서비스에서 Observables 사용하기\u003c/h1\u003e\n\u003cp\u003eAngular에서 Observables를 사용하는 가장 일반적인 사례 중 하나는 서비스에서 사용됩니다. 여기서 Observables를 사용하여 API, 데이터베이스 또는 기타 소스에서 데이터를 가져오고 조작할 수 있습니다. 다음은 가짜 API에서 데이터를 가져오기 위해 Observables를 사용하는 간단한 서비스 예제입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eHttpClient\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/common/http'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eprovidedIn\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDataService\u003c/span\u003e {\n  private apiUrl = \u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;https://jsonplaceholder.typicode.com/posts\u003e'\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate http: HttpClient\u003c/span\u003e) {}\n  \u003cspan class=\"hljs-title function_\"\u003egetPosts\u003c/span\u003e(): \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e\u0026#x3C;any[]\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ehttp\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eget\u003c/span\u003e\u0026#x3C;any[]\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eapiUrl\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 예제에서는 Angular의 내장 HttpClient를 사용하여 URL이 \u003ca href=\"https://jsonplaceholder.typicode.com/posts%EC%9D%B8\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://jsonplaceholder.typicode.com/posts인\u003c/a\u003e 가짜 API에 GET 요청을 하는 DataService라는 서비스를 만듭니다. 우리는 any[] 유형의 Observable을 반환하는 getPosts() 메서드를 정의합니다.\u003c/p\u003e\n\u003cp\u003e컴포넌트에서 이 서비스를 사용하려면 생성자에 주입하고 getPosts() 메서드를 호출하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eDataService\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./data.service'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-root'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\n    \u0026#x3C;h1\u003ePosts\u0026#x3C;/h1\u003e\n    \u0026#x3C;ul\u003e\n      \u0026#x3C;li *ngFor=\"let post of posts\"\u003e{{ post.title }}\u0026#x3C;/li\u003e\n    \u0026#x3C;/ul\u003e\n  `\u003c/span\u003e\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eposts\u003c/span\u003e: any[];\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate dataService: DataService\u003c/span\u003e) {}\n  \u003cspan class=\"hljs-title function_\"\u003engOnInit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edataService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetPosts\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n      \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eposts\u003c/span\u003e = data,\n      \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(error),\n      \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Posts loaded'\u003c/span\u003e)\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 AppComponent라는 컴포넌트를 만들어 DataService를 사용하여 가짜 API에서 게시물 목록을 가져옵니다. ngOnInit() 메서드를 정의하여 getPosts() Observable을 구독하고 전달된 값들을 처리합니다. Observable이 완료되면 컴포넌트의 posts 속성을 검색된 데이터로 설정합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 방법으로 Obserbables와 서비스를 사용하면 Angular 애플리케이션에서 강력하고 유연한 데이터 파이프라인을 만들 수 있어요.\u003c/p\u003e\n\u003ch1\u003eObservables 조합하기\u003c/h1\u003e\n\u003cp\u003eObservables의 가장 강력한 기능 중 하나는 다양한 방법으로 조합하고 조작할 수 있는 기능입니다. 이를 통해 다양한 유즈 케이스를 처리하는 복잡한 데이터 파이프라인을 만들 수 있어요. Angular에서 Observables를 조합하는 방법의 예시 몇 가지는 다음과 같아요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMerge: merge() 연산자를 사용하면 여러 Observables을 단일 스트림으로 결합할 수 있어요. 여기에 예시가 있어요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { interval, merge } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\r\n\r\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source1 = \u003cspan class=\"hljs-title function_\"\u003einterval\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\r\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source2 = \u003cspan class=\"hljs-title function_\"\u003einterval\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\r\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e merged = \u003cspan class=\"hljs-title function_\"\u003emerge\u003c/span\u003e(source1, source2);\r\nmerged.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\r\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value)\r\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서는 interval() 연산자를 사용하여 1초마다 값과 2초마다 값이 발행되는 두 개의 Observable을 생성합니다. 그런 다음 merge() 연산자를 사용하여 이 두 개의 Observable을 하나의 스트림으로 병합합니다. 마지막으로 병합된 Observable을 구독하고 각 발행된 값마다 콘솔에 기록합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCombineLatest: combineLatest() 연산자를 사용하면 여러 Observable이 발행한 최신 값들을 하나의 스트림으로 결합할 수 있습니다. 다음은 예시입니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { interval, combineLatest } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\r\n\r\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source1 = \u003cspan class=\"hljs-title function_\"\u003einterval\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\r\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source2 = \u003cspan class=\"hljs-title function_\"\u003einterval\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\r\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e combined = \u003cspan class=\"hljs-title function_\"\u003ecombineLatest\u003c/span\u003e(source1, source2);\r\ncombined.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\r\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value)\r\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 예제에서는 interval() 연산자를 사용하여 각각 1초마다 값과 2초마다 값이 방출되는 두 Observables을 만듭니다. 그런 다음 combineLatest() 연산자를 사용하여 두 Observables에서 최신 값들을 결합하여 단일 스트림으로 만듭니다. 마지막으로 결합된 Observable에 구독하여 각 방출된 값을 콘솔에 기록합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eZip: zip() 연산자를 사용하면 여러 Observables에서 방출된 값들을 배열로 결합할 수 있습니다. 다음은 예시입니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e, zip } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source1 = \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source2 = \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'c'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e zipped = \u003cspan class=\"hljs-title function_\"\u003ezip\u003c/span\u003e(source1, source2);\nzipped.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 of() 연산자를 사용하여 일정한 값 집합을 방출하는 두 Observables을 만듭니다. 그런 다음 zip() 연산자를 사용하여 두 Observables에서 방출한 값을 배열로 결합합니다. 마지막으로 zipped Observable을 구독하여 각 방출된 값을 콘솔에 기록합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 방식으로 옵저버블을 결합하고 조작함으로써, Angular 애플리케이션에서 다양한 유즈 케이스를 처리할 수 있는 복잡한 데이터 파이프라인을 만들 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e데이터를 변형하고 필터링하기 위해 오퍼레이터 사용하기\u003c/h1\u003e\n\u003cp\u003e오퍼레이터는 옵저버블이 방출한 데이터를 변형하거나 필터링하거나 기타 방식으로 조작할 수 있는 함수들입니다. Angular 옵저버블과 함께 사용할 수 있는 많은 오퍼레이터가 RxJS 라이브러리에 제공되며, 여기에 몇 가지 예시가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMap: map() 오퍼레이터를 사용하면 옵저버블에서 방출된 각 값을 새 값으로 변환할 수 있습니다. 다음은 예시입니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { map } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs/operators'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source = \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mapped = source.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e value * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e));\nmapped.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 of() 연산자를 사용하여 값을 고정된 세트로 방출하는 Observable을 생성합니다. 그런 다음 map() 연산자를 사용하여 각 방출된 값에 2를 곱해 변환합니다. 마지막으로 매핑된 Observable에 구독하고 각 방출된 값을 콘솔에 로깅합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFilter: filter() 연산자를 사용하면 주어진 조건에 따라 Observable에서 방출된 값을 필터링할 수 있습니다. 다음은 예시입니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { filter } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs/operators'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source = \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e filtered = source.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e value % \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e));\nfiltered.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 예시에서는 of() 연산자를 사용하여 Observable을 만듭니다. 이 연산자는 고정된 값 집합을 방출합니다. 그런 다음 filter() 연산자를 사용하여 짝수인 값만 방출하도록합니다. 마지막으로 필터링된 Observable을 구독하고 콘솔에 각 방출된 값을 기록합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eReduce: reduce() 연산자를 사용하면 Observable이 방출하는 값들을 누적하고 단일 값으로 반환할 수 있습니다. 다음은 예제입니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { reduce } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs/operators'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source = \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e reduced = source.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ereduce\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eacc, value\u003c/span\u003e) =\u003e\u003c/span\u003e acc + value));\nreduced.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서는 of() 연산자를 사용하여 고정된 값 집합을 방출하는 Observable을 만듭니다. 그런 다음 reduce() 연산자를 사용하여 Observable이 방출하는 값들을 누적하고 그 합계를 반환합니다. 마지막으로 누적된 Observable을 구독하고 콘솔에 최종 누적 값의 로그를 남깁니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e연산자인 map(), filter(), reduce()와 같은 것을 사용하여 Observable이 방출하는 데이터를 변환, 필터링하고 조작하여 Angular 애플리케이션에서 특정한 사용 사례에 맞게 맞출 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eSubjects를 사용하여 값을 방출하기\u003c/h1\u003e\n\u003cp\u003eObservable 외에도 RxJS 라이브러리는 여러 구독자에게 값을 방출할 수 있는 Subject 클래스를 제공합니다. Subject는 Observable과 Observer 둘 다이므로 값을 방출하고 다른 Observables에 구독할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 Angular에서 Subject를 생성하는 예제입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eSubject\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyComponent\u003c/span\u003e {\n  mySubject = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSubject\u003c/span\u003e\u0026#x3C;string\u003e();\n  \u003cspan class=\"hljs-title function_\"\u003eemitValue\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue: string\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emySubject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(value);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서는 문자열 유형의 Subject를 생성하고 MyComponent 클래스의 속성으로 저장합니다. 그런 다음 emitValue() 메서드를 정의하고 해당 값을 mySubject 객체의 next() 메서드를 호출하여 구독자에게 해당 값을 방출합니다.\u003c/p\u003e\n\u003cp\u003eSubject를 다른 Observable처럼 구독할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emyComponent.\u003cspan class=\"hljs-property\"\u003emySubject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 예시에서는 myComponent 객체의 mySubject Subject에 구독(subscribe)하여 발생한 모든 값들을 콘솔에 기록합니다.\u003c/p\u003e\n\u003cp\u003e한 가지 주의할 점은 Subject를 구독할 때 Subject가 생성된 이후에 발생한 모든 값들을 받게 되는 것입니다. 구독 이후에 발생한 값들만 받고 싶다면 BehaviorSubject를 사용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eBehaviorSubject\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyComponent\u003c/span\u003e {\n  mySubject = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBehaviorSubject\u003c/span\u003e\u0026#x3C;string\u003e(\u003cspan class=\"hljs-string\"\u003e'initial value'\u003c/span\u003e);\n  \u003cspan class=\"hljs-title function_\"\u003eemitValue\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue: string\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emySubject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(value);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서는 string 타입의 BehaviorSubject를 생성하고 초기값을 \u003ccode\u003einitial value\u003c/code\u003e로 설정합니다. BehaviorSubject를 구독하면 초기값을 먼저 받은 뒤에 구독 이후에 발생한 모든 값들을 받게 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eSubject 및 BehaviorSubject을 사용하면 Angular 애플리케이션에서 값들을 발행하고 구독하는 강력한 방법이 될 수 있습니다. 이를 통해 컴포넌트와 서비스 간에 데이터를 쉽게 공유할 수 있으며 복잡한 데이터 흐름 시나리오를 간단화할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eAngular Observables은 Angular 애플리케이션의 비동기 데이터 흐름을 관리하는 강력한 도구입니다. RxJS 라이브러리의 도움으로 사용자 입력부터 HTTP 요청까지 모두 처리할 수 있는 Observables을 만들고 조작할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 글에서는 Observables의 기본을 다룰 때, 생성하고 구독하는 방법 및 연산자를 사용하여 발행된 값들을 변환하고 필터링하는 방법을 다뤘습니다. 또한 Subject을 사용하여 여러 구독자에게 값을 발행하는 고급 주제도 살펴보았습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e앵귤러 옵저버블을 효과적으로 활용하는 방법을 이해하면, 더 반응형이고 빠른 응용 프로그램을 만들어 사용자 경험을 향상시킬 수 있습니다. 간단한 양식 데이터든 복잡한 데이터 스트림이든 옵저버블을 사용하면 쉽게 관리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음에 앵귤러 응용 프로그램을 작성할 때는 데이터 흐름 요구 사항을 처리하기 위해 옵저버블을 사용해보세요. 강력한 기능과 다양한 기능 세트로, 보다 견고하고 유연하며 확장 가능한 응용 프로그램을 만들 수 있을 것입니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-AComprehensiveGuidetoAngularObservables"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>