<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>마이크로 프론트엔드 재사용하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-HowtoReuseMicroFrontends" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="마이크로 프론트엔드 재사용하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="마이크로 프론트엔드 재사용하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-HowtoReuseMicroFrontends" data-gatsby-head="true"/><meta name="twitter:title" content="마이크로 프론트엔드 재사용하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 15:22" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">마이크로 프론트엔드 재사용하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="마이크로 프론트엔드 재사용하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-HowtoReuseMicroFrontends&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><h2>마이크로 프론트엔드는 재사용하기 어렵습니다. 그러나 적절한 도구 세트를 활용하면 서로 다른 프로젝트에 걸쳐 마이크로 프론트엔드를 재사용할 수 있습니다.</h2>
<p><img src="/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png" alt="Micro Frontends"/></p>
<p>이론상으로 마이크로 프론트엔드는 멋지지만, 여러 팀이 동시에 병렬로 생성하고 개별적으로 섞어 다양한 응용 프로그램을 만들어내고 그들의 로직을 재작성할 필요 없이 서로 조합할 수 있습니다.</p>
<p>그들은 마치 마법 같아요!</p>
<p>하지만 실제로 이러한 마이크로 프론트엔드를 공유하고 재사용하는 과정은 쉽지 않습니다.</p>
<p>그래서 이 글에서 여러 프로젝트에서 무난하게 재사용하는 방법을 보여드릴 거에요.</p>
<p>시작해봅시다!</p>
<h1>우리가 사용할 도구</h1>
<p>마이크로 프론트엔드 자체로는 재사용이나 여러 팀 또는 개발 커뮤니티와 공유할 방법을 제공하지 않습니다.</p>
<p>따라서 우리는 어떤 종류의 도구가 필요하며, 오늘은 비트(Bit)에 대해 알려 드리겠습니다.</p>
<p>비트(Bit) 및 비트 클라우드(Bit Cloud)(클라우드 기반 마켓플레이스)는 구성 가능한 소프트웨어 제품을 개발하는 혁신적인 팀을 위한 완벽한 솔루션을 제공합니다. 업계를 선도하는 구성 요소 기반 개발 플랫폼으로, 수천 개의 팀 및 포춘 500 개사에게 대규모 앱 개발을 위한 구성 가능 앱 개발을 지원합니다.</p>
<p>아래는 CDD 플랫폼에서 필요한 주요 기능 중 일부이며 비트(Bit)에서 제공하는 기능입니다.</p>
<ul>
<li>컴포넌트 중심 개발 툴셋</li>
<li>컴포넌트 소스 코드 관리 및 버전 관리</li>
<li>의존성 관리: 자동화, 스마트하고 일관성 있음</li>
<li>패키징 및 배포</li>
<li>공유하고 협업하는 중앙 플랫폼</li>
<li>찾아보기 및 검색</li>
<li>사용, 설치 및 통합 (빌드 시간 및 런타임)</li>
</ul>
<p>여기서 &quot;composable app development&quot;와 &quot;component-driven&quot;에 대해 얘기하고 있는 이유가 뭘까요? 왜냐하면 그것이 우리 문제를 해결하는 열쇠가 될 것이기 때문이에요.</p>
<p>알다시피, Bit에는 코드뿐만 아니라 테스트와 논리적 컴포넌트의 문서까지 포함하는 &quot;컴포넌트&quot; 개념이 있어요. 이 &quot;컴포넌트&quot; 개념을 우리의 마이크로 프론트엔드에 매핑할 수 있게 되면 위에서 언급한 혜택을 누릴 수 있게 됩니다.</p>
<p>우리의 마이크로 프론트엔드는 갑자기 다음과 같습니다:</p>
<ul>
<li>조립 가능합니다.</li>
<li>모든 종속성을 쉽게 관리할 수 있습니다.</li>
<li>개별 패키지로 쉽게 배포할 수 있습니다.</li>
<li>Bit.cloud를 통해 쉽게 발견할 수 있습니다.</li>
<li>그리고 Bit를 통해 이러한 패키지를 설치하는 것은 단 한 가지 명령을 실행하는 것만큼 단순합니다.</li>
</ul>
<p>다른 프로젝트 내에서 일부 마이크로 프론트엔드를 재사용하는 실용적인 예제를 살펴봅시다.</p>
<p>읽은 내용이 마음에 드셨나요? IT 산업에서 20년치의 지식을 모두와 공유하는 내 무료 뉴스레터에 가입해 보시는 건 어떨까요? &quot;늙은 개발자의 혼잣말&quot;에 참여해 보세요!</p>
<h1>기존의 마이크로 프론트엔드 재사용</h1>
<p>만약 Bit를 사용하여 독자적인 마이크로 프론트엔드를 어떻게 만들 수 있는지 궁금하다면, 아래 기사를 읽어보세요. 그곳에서 모든 과정을 단계별로 보여줄 테니까요:</p>
<p>그러나 단순히 재사용만 하려면, 조금 더 간단한 프로세스가 적용됩니다.</p>
<p>먼저 해야 할 일은 아래와 같은 명령어로 Bit를 설치하는 것입니다:</p>
<pre><code class="hljs language-js">npx @teambit/bvm install
</code></pre>
<p>설치가 완료되면 Bit은 프로젝트에 패키지를 추가할 준비가 되어 있지만, 이를 수행할 수 있는 여러 가지 방법을 이해해야 합니다.</p>
<p>우선 Bit.cloud를 통해 원하는 마이크로 프론트엔드를 찾아 설치해야 합니다. 예를 들어, 얼마 전에 만든 블로그 마이크로 프론트엔드를 한 번 살펴보겠습니다. 그것은 기사를 나열하는 간단한 마이크로 프론트엔드입니다.</p>
<p>페이지의 오른쪽 상단에는 &quot;사용&quot; 버튼이 있습니다. 클릭하면 다음 메뉴가 표시됩니다:</p>
<img src="/assets/img/2024-05-14-HowtoReuseMicroFrontends_1.png"/>
<p>알겠지만, &#x27;Bit&#x27;를 사용하는 것 외에도 &quot;npm&quot;, &quot;yarn&quot;, &quot;pnpm&quot;을 사용할 수 있습니다. 이 모든 프로세스는 간단합니다. 웹사이트에서 제공된 라인을 사용하기만 하면 됩니다. 사실, 이 방법은 Bit가 시스템에 설치되어 있을 필요가 전혀 없습니다. 그러나 이 명령을 사용하여 사용자 정의 Bit 레지스트리를 구성해야 합니다.</p>
<pre><code class="hljs language-js">npm config set <span class="hljs-string">&#x27;@deleteman:registry&#x27;</span> <span class="hljs-attr">https</span>:<span class="hljs-comment">//node.bit.cloud</span>
</code></pre>
<p>그러나 아마도 이미 알고 계실 것처럼, 이 도구들은 모든 종속성을 직접 node_modules 폴더 내에 설치합니다. 이는 유용하지만 패키지의 코드에 쉽게 액세스하지 못하게 하고 심지어 변경할 수 없게 합니다. 보통 다른 사람의 패키지를 변경하고 싶지 않지만, 여기서는 여러분이 자신의 마이크로 프론트엔드를 재사용하고자 할 수도 있기 때문에 여기저기 변경하는 게 유용할 수 있습니다.</p>
<p>그런 경우에는 비트(Bit)의 옵션에 대해 알아두는 게 좋아요:</p>
<ul>
<li>설치: 이 옵션은 npm을 사용하는 것과 거의 비슷합니다. 프로젝트에 구성 요소를 설치하면 예상대로 node_modules 폴더 안에 저장됩니다.</li>
<li>가져오기: 이전 옵션처럼 종속성을 저장하는 대신, 이 명령은 패키지를 워크스페이스 루트에 새 폴더에 다운로드합니다. 그러면 node_modules 블랙홀에 빠질 필요 없이 코드에 쉽게 액세스할 수 있어요. 더불어 Bit는 가져온 각 구성 요소에 대해 node_modules 안에 심볼릭 링크를 만들고 새로 다운로드한 파일을 가리킵니다. 이렇게 하면 코드에서 가져온 구성 요소를 여전히 일반 외부 구성 요소처럼 가져올 수 있습니다. 가져온 마이크로 프론트엔드를 변경하면 업데이트를 새 버전으로 푸시할 수 있어요. 다른 사람들과 협업하여 마이크로 프론트엔드를 개발하고 확장하려는 경우에 이 옵션이 완벽해요.</li>
<li>포크: 그러나 마이크로 프론트엔드의 사본을 만들고 변경하고 싶다면, Forking이 적절한 옵션이에요. &quot;가져오기&quot; 명령과 동일하게 작동하지만 버전 기록을 다운로드하지 않아서 사실상 당신의 변경을 기다리는 새로운 구성 요소가 됩니다.</li>
</ul>
<p>이런 내용을 감안하고, 내가 만든 마이크로 프론트엔드를 사용해 새로운 프로젝트를 처음부터 만드는 실용적인 예시를 살펴보겠어요.</p>
<h2>마이크로 프론트엔드로 웹사이트 구축하기</h2>
<p>위 예시를 통해, 홈 화면에 2개의 링크가 있는 웹사이트를 만들어보겠습니다:</p>
<ul>
<li>블로그: 블로그 마이크로 프론트엔드를 사용하여 블로그를 표시할 예정입니다.</li>
<li>문서: 문서 마이크로 프론트엔드를 사용하여 내부 네비게이션 및 사용자 정의 페이지를 표시할 예정입니다.</li>
</ul>
<p>이들은 모두 예시 마이크로 프론트엔드입니다만, 귀하의 사용 사례에 유용한 예시로 확장할 수 있습니다.</p>
<p>우리는 Bit를 사용하여 React 앱을 만들고, 그 후에 마이크로 프론트엔드를 설치할 것입니다.</p>
<p>코딩을 시작하기 전에 먼저 Bit 워크스페이스를 생성하여 애플리케이션 코드를 넣을 수 있도록 하겠어요. 이렇게 하면 나중에 공유할 수 있게 될 거에요 (이에 대해서는 잠시 후에 더 자세히 알려드릴게요).</p>
<pre><code class="hljs language-js">your-project-folder&gt; bit <span class="hljs-keyword">new</span> react workspace --env teambit.<span class="hljs-property">react</span>/react-env --<span class="hljs-keyword">default</span>-scope deleteman.<span class="hljs-property">test</span>-website
</code></pre>
<p>이제 워크스페이스 폴더 안에서 작업할 거에요.</p>
<p>이제 새로운 React 애플리케이션을 만들어봅시다.</p>
<p>이를 위해서, 아래 명령어를 사용할 거에요:</p>
<pre><code class="hljs language-js">bit create react-app apps/website --aspect teambit.<span class="hljs-property">react</span>/react-env
</code></pre>
<p>이것은 기본 scope 내 (우리의 경우에는 test-website)에 apps/website 폴더를 생성합니다.</p>
<p>이제 앱을 다음과 같이 설정하세요:</p>
<pre><code class="hljs language-js">bit use apps/website
</code></pre>
<p>그리고 <code>bit run website</code>으로 마침내 테스트할 수 있습니다. 이것은 포트 3000에서 서버를 시작하며 다음과 같이 매우 기본적인 내용이 표시됩니다:
<img src="/assets/img/2024-05-14-HowtoReuseMicroFrontends_2.png" alt="이미지"/></p>
<p>이제 <code>apps/website/website.tsx</code> 파일의 코드를 다음과 같이 변경하겠습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Website</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App-header&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
         웹사이트에 오신 것을 환영합니다!
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
          저희 제품에 대해 더 알고 싶다면, 저희의 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/docs&quot;</span>&gt;</span>문서<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>를 방문해 주세요.
          혹은 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/blog&quot;</span>&gt;</span>기술 블로그<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>도 확인해 보세요.
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        
      <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>우리는 더 간단히 단축할 수 있지만, 너무 복잡하게 하지 않기 위해 새 홈페이지가 어떻게 보이는지 알려드릴게요:</p>
<p><img src="/assets/img/2024-05-14-HowtoReuseMicroFrontends_3.png" alt="2024-05-14-HowtoReuseMicroFrontends_3.png"/></p>
<p>이제 두 섹션에 대한 라우트를 추가해 봅시다. 블로그 섹션이 가장 쉽기 때문에, 그것부터 시작해봅시다.```</p>
<p>가장 먼저 해야 할 일은 Bit를 사용하여 블로그 마이크로 프론트엔드를 가져오는 것입니다:</p>
<pre><code class="hljs language-js">your-project-folder&gt; bit <span class="hljs-keyword">import</span> deleteman.<span class="hljs-property">microfrontends</span>/blog
</code></pre>
<p>지금은 프로젝트의 루트에 microfrontends라는 폴더가 생겼을 것이며, website.tsx 파일을 다음과 같이 편집할 수 있을 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Blog</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@deleteman/microfrontends.blog&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Website</span>(<span class="hljs-params"></span>) {

  <span class="hljs-keyword">const</span> [page, setPage] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">&quot;home&quot;</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">navTo</span>(<span class="hljs-params">event, target</span>) {
    event.<span class="hljs-title function_">preventDefault</span>();
    <span class="hljs-title function_">setPage</span>(target);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">if</span>(page === <span class="hljs-string">&quot;home&quot;</span>) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App-header&quot;</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
            웹사이트에 오신 것을 환영합니다!
          <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
            제품에 대해 더 알아보려면 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;inline&#x27;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{(evt)</span> =&gt;</span> navTo(evt,&#x27;docs&#x27;)}&gt;문서<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>를 방문해주세요.
            또는 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;inline&#x27;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{(evt)</span> =&gt;</span> navTo(evt, &#x27;blog&#x27;)}&gt;기술 블로그<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>를 확인해도 좋아요.
          <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }

  <span class="hljs-keyword">if</span>(page === <span class="hljs-string">&quot;blog&quot;</span>) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Blog</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
          홈으로 돌아가려면 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;inline&#x27;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{(evnt)</span> =&gt;</span> navTo(evnt, &#x27;home&#x27;)}&gt;홈<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>을 클릭하세요.
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/&gt;</span></span>
    );
  }
}
</code></pre>
<p>주목하세요! 여기서는 첫 번째 마이크로 프론트엔드인 Blog 컴포넌트를 가져온다는 것을 알 수 있습니다. 파일이 다른 위치에 있더라도 node_modules 폴더 안에 복사된 것처럼 다룰 수 있어요.</p>
<p>게다가 추가적인 라우팅을 추가하지 않았으므로 간단한 페이지 상태 변수로 내비게이션을 시뮬레이션하고 있어요.</p>
<p>이제 Docs 마이크로 프론트엔드에서는 동일한 동작이 되도록, 올바른 컴포넌트를 렌더링하기 위해 새로운 if 문을 추가할 거예요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> {<span class="hljs-title class_">Docs</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@deleteman/microfrontends.docs&quot;</span>

 <span class="hljs-keyword">if</span>(page == <span class="hljs-string">&quot;docs&quot;</span>) {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Docs</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
          Go back <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;inline&#x27;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{(evnt)</span> =&gt;</span> navTo(evnt, &#x27;home&#x27;)}&gt;Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/&gt;</span></span>
    )
  }
</code></pre>
<p>다시 한 번 알고 계시든 아니면 그렇지 않든, Docs 컴포넌트를 마치 node_modules 내에 설치된 것처럼 가져오고 있어요.</p>
<p>그리고 여기가 최종 (그리고 못생긴) 결과입니다:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*DAkwXJnhXjDGwVvmrh_M0Q.gif" alt="image"/></p>
<p>단순히 프로젝트에 2개의 마이크로 프론트엔드를 추가함으로써, 블로그와 문서 섹션을 위한 완전히 작동하는 내비게이션과 새로운 내부 링크 및 페이지를 쉽게 추가할 수 있었어요.</p>
<p>강력한 내용이네요!</p>
<h2>Bit에 최종 제품 푸시하기</h2>
<p>네, Bit를 사용하면 컴포넌트를 공유할 뿐만 아니라 완전한 애플리케이션도 공유할 수 있어요.</p>
<p>이유가 뭔가요? 그것은 이들이 실제로 플랫폼에서 CI를 구성할 수 있는 능력을 제공하기 때문이에요.</p>
<p>하지만 중요한 점은 최최 어플리케이션이 완성되면 버전을 지정하여 컴포넌트로 공유할 수 있다는 것이다. 다른 개발자들이 이를 설치하고 작업할 수 있으며, 동시에 완벽하게 작동하는 CI/CD 파이프라인을 갖게 될 것이다.</p>
<p>가장 먼저 해야 할 일은 Bit.cloud에 가서 새 scope를 생성하는 것이다. 나는 &quot;test-website&quot;라고 이름 지었어 (네, 너무 원래 있어 보여!):</p>
<p><img src="/assets/img/2024-05-14-HowtoReuseMicroFrontends_4.png" alt="이미지"/></p>
<p>지금쯤이면 이미 어플리케이션을 설정하고 생성했을 것이다 (이 강의 전체를 통해 그렇게 했으니까), 따라서 남은 것은 버전을 지정하고 내보내는 것이다.</p>
<p>다음 명령어를 실행해주세요:</p>
<pre><code class="hljs language-js">bit tag
bit <span class="hljs-keyword">export</span>
</code></pre>
<p>첫 번째 명령은 테스트를 실행하고 코드를 린트하며 모든 것이 예상대로 작동하는지 확인할 것입니다. 그리고 그렇게 되면 버전을 0.0.1로 만들 것입니다.</p>
<p>마지막 명령은 두 파일을 클라우드에 업로드할 것입니다. 제 경우에는 여기에서 최종 결과를 볼 수 있습니다.</p>
<p>&quot;그리고 만일 &#x27;Dependencies&#x27; 탭을 클릭하면, 앱을 만들 때 사용한 2개의 마이크로 프론트엔드를 보실 수 있습니다:</p>
<p><img src="/assets/img/2024-05-14-HowtoReuseMicroFrontends_5.png" alt="Dependencies"/></p>
<p>이제 우리의 프로젝트는 팀원들과 함께 협업할 준비가 된 상태입니다.</p>
<p>성공!&quot;</p>
<p>마이크로 프론트엔드는 환상적인 재사용성 솔루션을 제시합니다. 이미 존재하는 것을 재사용하여 복잡한 웹사이트와 애플리케이션을 만들 수 있습니다.</p>
<p>팀은 개별적으로 이러한 구성 요소를 만들 수 있으며, 다른 사용자들은 이를 섞어서 매치할 수 있습니다. 생각해보면 레고 블록과 놀이하는 것과 매우 흡사합니다.</p>
<p>물론, &quot;블록&quot;을 공유하고 사용하는 것은 간단하지 않습니다. 이를 발견하고 새 프로젝트에 설치하기 위한 도구가 필요합니다. 다행히도 Bit를 사용하면 컴포넌트 중심의 접근 방식으로 마이크로 프론트엔드를 쉽게 만들고 공유하고 재사용할 수 있습니다.</p>
<p>그뿐만 아니라, 이미 존재하는 구성 요소를 확장할 수 있는 도구를 개발자들에게 제공합니다.</p>
<h1>또한, 기존 애플리케이션에 마이크로 프론트엔드를 생성하고 추가하는 방법에 대해 알아보세요:</h1>
<h1>추가로 읽을 거리:</h1></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"마이크로 프론트엔드 재사용하는 방법","description":"","date":"2024-05-14 15:22","slug":"2024-05-14-HowtoReuseMicroFrontends","content":"\n\n## 마이크로 프론트엔드는 재사용하기 어렵습니다. 그러나 적절한 도구 세트를 활용하면 서로 다른 프로젝트에 걸쳐 마이크로 프론트엔드를 재사용할 수 있습니다.\n\n![Micro Frontends](/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png)\n\n이론상으로 마이크로 프론트엔드는 멋지지만, 여러 팀이 동시에 병렬로 생성하고 개별적으로 섞어 다양한 응용 프로그램을 만들어내고 그들의 로직을 재작성할 필요 없이 서로 조합할 수 있습니다.\n\n그들은 마치 마법 같아요!\n\n\n\n하지만 실제로 이러한 마이크로 프론트엔드를 공유하고 재사용하는 과정은 쉽지 않습니다.\n\n그래서 이 글에서 여러 프로젝트에서 무난하게 재사용하는 방법을 보여드릴 거에요.\n\n시작해봅시다!\n\n# 우리가 사용할 도구\n\n\n\n마이크로 프론트엔드 자체로는 재사용이나 여러 팀 또는 개발 커뮤니티와 공유할 방법을 제공하지 않습니다.\n\n따라서 우리는 어떤 종류의 도구가 필요하며, 오늘은 비트(Bit)에 대해 알려 드리겠습니다.\n\n비트(Bit) 및 비트 클라우드(Bit Cloud)(클라우드 기반 마켓플레이스)는 구성 가능한 소프트웨어 제품을 개발하는 혁신적인 팀을 위한 완벽한 솔루션을 제공합니다. 업계를 선도하는 구성 요소 기반 개발 플랫폼으로, 수천 개의 팀 및 포춘 500 개사에게 대규모 앱 개발을 위한 구성 가능 앱 개발을 지원합니다.\n\n아래는 CDD 플랫폼에서 필요한 주요 기능 중 일부이며 비트(Bit)에서 제공하는 기능입니다.\n\n\n\n- 컴포넌트 중심 개발 툴셋\n- 컴포넌트 소스 코드 관리 및 버전 관리\n- 의존성 관리: 자동화, 스마트하고 일관성 있음\n- 패키징 및 배포\n- 공유하고 협업하는 중앙 플랫폼\n- 찾아보기 및 검색\n- 사용, 설치 및 통합 (빌드 시간 및 런타임)\n\n여기서 \"composable app development\"와 \"component-driven\"에 대해 얘기하고 있는 이유가 뭘까요? 왜냐하면 그것이 우리 문제를 해결하는 열쇠가 될 것이기 때문이에요.\n\n알다시피, Bit에는 코드뿐만 아니라 테스트와 논리적 컴포넌트의 문서까지 포함하는 \"컴포넌트\" 개념이 있어요. 이 \"컴포넌트\" 개념을 우리의 마이크로 프론트엔드에 매핑할 수 있게 되면 위에서 언급한 혜택을 누릴 수 있게 됩니다.\n\n\n\n우리의 마이크로 프론트엔드는 갑자기 다음과 같습니다:\n\n- 조립 가능합니다.\n- 모든 종속성을 쉽게 관리할 수 있습니다.\n- 개별 패키지로 쉽게 배포할 수 있습니다.\n- Bit.cloud를 통해 쉽게 발견할 수 있습니다.\n- 그리고 Bit를 통해 이러한 패키지를 설치하는 것은 단 한 가지 명령을 실행하는 것만큼 단순합니다.\n\n다른 프로젝트 내에서 일부 마이크로 프론트엔드를 재사용하는 실용적인 예제를 살펴봅시다.\n\n읽은 내용이 마음에 드셨나요? IT 산업에서 20년치의 지식을 모두와 공유하는 내 무료 뉴스레터에 가입해 보시는 건 어떨까요? \"늙은 개발자의 혼잣말\"에 참여해 보세요!\n\n\n\n# 기존의 마이크로 프론트엔드 재사용\n\n만약 Bit를 사용하여 독자적인 마이크로 프론트엔드를 어떻게 만들 수 있는지 궁금하다면, 아래 기사를 읽어보세요. 그곳에서 모든 과정을 단계별로 보여줄 테니까요:\n\n그러나 단순히 재사용만 하려면, 조금 더 간단한 프로세스가 적용됩니다.\n\n먼저 해야 할 일은 아래와 같은 명령어로 Bit를 설치하는 것입니다:\n\n\n\n```js\nnpx @teambit/bvm install\n```\n\n설치가 완료되면 Bit은 프로젝트에 패키지를 추가할 준비가 되어 있지만, 이를 수행할 수 있는 여러 가지 방법을 이해해야 합니다.\n\n우선 Bit.cloud를 통해 원하는 마이크로 프론트엔드를 찾아 설치해야 합니다. 예를 들어, 얼마 전에 만든 블로그 마이크로 프론트엔드를 한 번 살펴보겠습니다. 그것은 기사를 나열하는 간단한 마이크로 프론트엔드입니다.\n\n페이지의 오른쪽 상단에는 \"사용\" 버튼이 있습니다. 클릭하면 다음 메뉴가 표시됩니다:\n\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-HowtoReuseMicroFrontends_1.png\" /\u003e\n\n알겠지만, 'Bit'를 사용하는 것 외에도 \"npm\", \"yarn\", \"pnpm\"을 사용할 수 있습니다. 이 모든 프로세스는 간단합니다. 웹사이트에서 제공된 라인을 사용하기만 하면 됩니다. 사실, 이 방법은 Bit가 시스템에 설치되어 있을 필요가 전혀 없습니다. 그러나 이 명령을 사용하여 사용자 정의 Bit 레지스트리를 구성해야 합니다.\n\n```js\nnpm config set '@deleteman:registry' https://node.bit.cloud\n```\n\n그러나 아마도 이미 알고 계실 것처럼, 이 도구들은 모든 종속성을 직접 node_modules 폴더 내에 설치합니다. 이는 유용하지만 패키지의 코드에 쉽게 액세스하지 못하게 하고 심지어 변경할 수 없게 합니다. 보통 다른 사람의 패키지를 변경하고 싶지 않지만, 여기서는 여러분이 자신의 마이크로 프론트엔드를 재사용하고자 할 수도 있기 때문에 여기저기 변경하는 게 유용할 수 있습니다.\n\n\n\n그런 경우에는 비트(Bit)의 옵션에 대해 알아두는 게 좋아요:\n\n- 설치: 이 옵션은 npm을 사용하는 것과 거의 비슷합니다. 프로젝트에 구성 요소를 설치하면 예상대로 node_modules 폴더 안에 저장됩니다.\n- 가져오기: 이전 옵션처럼 종속성을 저장하는 대신, 이 명령은 패키지를 워크스페이스 루트에 새 폴더에 다운로드합니다. 그러면 node_modules 블랙홀에 빠질 필요 없이 코드에 쉽게 액세스할 수 있어요. 더불어 Bit는 가져온 각 구성 요소에 대해 node_modules 안에 심볼릭 링크를 만들고 새로 다운로드한 파일을 가리킵니다. 이렇게 하면 코드에서 가져온 구성 요소를 여전히 일반 외부 구성 요소처럼 가져올 수 있습니다. 가져온 마이크로 프론트엔드를 변경하면 업데이트를 새 버전으로 푸시할 수 있어요. 다른 사람들과 협업하여 마이크로 프론트엔드를 개발하고 확장하려는 경우에 이 옵션이 완벽해요.\n- 포크: 그러나 마이크로 프론트엔드의 사본을 만들고 변경하고 싶다면, Forking이 적절한 옵션이에요. \"가져오기\" 명령과 동일하게 작동하지만 버전 기록을 다운로드하지 않아서 사실상 당신의 변경을 기다리는 새로운 구성 요소가 됩니다.\n\n이런 내용을 감안하고, 내가 만든 마이크로 프론트엔드를 사용해 새로운 프로젝트를 처음부터 만드는 실용적인 예시를 살펴보겠어요.\n\n## 마이크로 프론트엔드로 웹사이트 구축하기\n\n\n\n위 예시를 통해, 홈 화면에 2개의 링크가 있는 웹사이트를 만들어보겠습니다:\n\n- 블로그: 블로그 마이크로 프론트엔드를 사용하여 블로그를 표시할 예정입니다.\n- 문서: 문서 마이크로 프론트엔드를 사용하여 내부 네비게이션 및 사용자 정의 페이지를 표시할 예정입니다.\n\n이들은 모두 예시 마이크로 프론트엔드입니다만, 귀하의 사용 사례에 유용한 예시로 확장할 수 있습니다.\n\n우리는 Bit를 사용하여 React 앱을 만들고, 그 후에 마이크로 프론트엔드를 설치할 것입니다.\n\n\n\n코딩을 시작하기 전에 먼저 Bit 워크스페이스를 생성하여 애플리케이션 코드를 넣을 수 있도록 하겠어요. 이렇게 하면 나중에 공유할 수 있게 될 거에요 (이에 대해서는 잠시 후에 더 자세히 알려드릴게요).\n\n```js\nyour-project-folder\u003e bit new react workspace --env teambit.react/react-env --default-scope deleteman.test-website\n```\n\n이제 워크스페이스 폴더 안에서 작업할 거에요.\n\n이제 새로운 React 애플리케이션을 만들어봅시다.\n\n\n\n이를 위해서, 아래 명령어를 사용할 거에요:\n\n```js\nbit create react-app apps/website --aspect teambit.react/react-env\n```\n\n이것은 기본 scope 내 (우리의 경우에는 test-website)에 apps/website 폴더를 생성합니다.\n\n이제 앱을 다음과 같이 설정하세요:\n\n\n\n```js\nbit use apps/website\n```\n\n그리고 `bit run website`으로 마침내 테스트할 수 있습니다. 이것은 포트 3000에서 서버를 시작하며 다음과 같이 매우 기본적인 내용이 표시됩니다:\n![이미지](/assets/img/2024-05-14-HowtoReuseMicroFrontends_2.png)\n\n이제 `apps/website/website.tsx` 파일의 코드를 다음과 같이 변경하겠습니다:\n\n\n\n\n```js\nimport './App.css';\n\nexport function Website() {\n  return (\n    \u003cdiv className=\"App\"\u003e\n      \u003cheader className=\"App-header\"\u003e\n        \u003cp\u003e\n         웹사이트에 오신 것을 환영합니다!\n        \u003c/p\u003e\n        \u003cp\u003e\n          저희 제품에 대해 더 알고 싶다면, 저희의 \u003ca href=\"/docs\"\u003e문서\u003c/a\u003e를 방문해 주세요.\n          혹은 \u003ca href=\"/blog\"\u003e기술 블로그\u003c/a\u003e도 확인해 보세요.\n        \u003c/p\u003e\n        \n      \u003c/header\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n우리는 더 간단히 단축할 수 있지만, 너무 복잡하게 하지 않기 위해 새 홈페이지가 어떻게 보이는지 알려드릴게요:\n\n![2024-05-14-HowtoReuseMicroFrontends_3.png](/assets/img/2024-05-14-HowtoReuseMicroFrontends_3.png)\n\n이제 두 섹션에 대한 라우트를 추가해 봅시다. 블로그 섹션이 가장 쉽기 때문에, 그것부터 시작해봅시다.```\n\n\n\n가장 먼저 해야 할 일은 Bit를 사용하여 블로그 마이크로 프론트엔드를 가져오는 것입니다:\n\n```js\nyour-project-folder\u003e bit import deleteman.microfrontends/blog\n```\n\n지금은 프로젝트의 루트에 microfrontends라는 폴더가 생겼을 것이며, website.tsx 파일을 다음과 같이 편집할 수 있을 것입니다:\n\n```js\nimport { useState } from 'react';\nimport { Blog } from \"@deleteman/microfrontends.blog\";\nimport './App.css';\n\nexport function Website() {\n\n  const [page, setPage] = useState(\"home\");\n\n  function navTo(event, target) {\n    event.preventDefault();\n    setPage(target);\n    return false;\n  }\n\n  if(page === \"home\") {\n    return (\n      \u003cdiv className=\"App\"\u003e\n        \u003cheader className=\"App-header\"\u003e\n          \u003cp\u003e\n            웹사이트에 오신 것을 환영합니다!\n          \u003c/p\u003e\n          \u003cp\u003e\n            제품에 대해 더 알아보려면 \u003ca href=\"#\" className='inline' onClick={(evt) =\u003e navTo(evt,'docs')}\u003e문서\u003c/a\u003e를 방문해주세요.\n            또는 \u003ca href=\"#\" className='inline' onClick={(evt) =\u003e navTo(evt, 'blog')}\u003e기술 블로그\u003c/a\u003e를 확인해도 좋아요.\n          \u003c/p\u003e\n        \u003c/header\u003e\n      \u003c/div\u003e\n    );\n  }\n\n  if(page === \"blog\") {\n    return (\n      \u003c\u003e\n        \u003cBlog /\u003e\n        \u003cp\u003e\n          홈으로 돌아가려면 \u003ca href=\"#\" className='inline' onClick={(evnt) =\u003e navTo(evnt, 'home')}\u003e홈\u003c/a\u003e을 클릭하세요.\n        \u003c/p\u003e\n      \u003c/\u003e\n    );\n  }\n}\n```\n\n\n\n주목하세요! 여기서는 첫 번째 마이크로 프론트엔드인 Blog 컴포넌트를 가져온다는 것을 알 수 있습니다. 파일이 다른 위치에 있더라도 node_modules 폴더 안에 복사된 것처럼 다룰 수 있어요.\n\n게다가 추가적인 라우팅을 추가하지 않았으므로 간단한 페이지 상태 변수로 내비게이션을 시뮬레이션하고 있어요.\n\n이제 Docs 마이크로 프론트엔드에서는 동일한 동작이 되도록, 올바른 컴포넌트를 렌더링하기 위해 새로운 if 문을 추가할 거예요:\n\n```js\nimport {Docs} from \"@deleteman/microfrontends.docs\"\n\n if(page == \"docs\") {\n    return (\n      \u003c\u003e\n      \u003cDocs /\u003e\n        \u003cp\u003e\n          Go back \u003ca href=\"#\" className='inline' onClick={(evnt) =\u003e navTo(evnt, 'home')}\u003eHome\u003c/a\u003e\n        \u003c/p\u003e\n      \u003c/\u003e\n    )\n  }\n```\n\n\n\n다시 한 번 알고 계시든 아니면 그렇지 않든, Docs 컴포넌트를 마치 node_modules 내에 설치된 것처럼 가져오고 있어요.\n\n그리고 여기가 최종 (그리고 못생긴) 결과입니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*DAkwXJnhXjDGwVvmrh_M0Q.gif)\n\n단순히 프로젝트에 2개의 마이크로 프론트엔드를 추가함으로써, 블로그와 문서 섹션을 위한 완전히 작동하는 내비게이션과 새로운 내부 링크 및 페이지를 쉽게 추가할 수 있었어요.\n\n\n\n강력한 내용이네요!\n\n## Bit에 최종 제품 푸시하기\n\n네, Bit를 사용하면 컴포넌트를 공유할 뿐만 아니라 완전한 애플리케이션도 공유할 수 있어요.\n\n이유가 뭔가요? 그것은 이들이 실제로 플랫폼에서 CI를 구성할 수 있는 능력을 제공하기 때문이에요.\n\n\n\n하지만 중요한 점은 최최 어플리케이션이 완성되면 버전을 지정하여 컴포넌트로 공유할 수 있다는 것이다. 다른 개발자들이 이를 설치하고 작업할 수 있으며, 동시에 완벽하게 작동하는 CI/CD 파이프라인을 갖게 될 것이다.\n\n가장 먼저 해야 할 일은 Bit.cloud에 가서 새 scope를 생성하는 것이다. 나는 \"test-website\"라고 이름 지었어 (네, 너무 원래 있어 보여!):\n\n![이미지](/assets/img/2024-05-14-HowtoReuseMicroFrontends_4.png)\n\n지금쯤이면 이미 어플리케이션을 설정하고 생성했을 것이다 (이 강의 전체를 통해 그렇게 했으니까), 따라서 남은 것은 버전을 지정하고 내보내는 것이다.\n\n\n\n다음 명령어를 실행해주세요:\n\n```js\nbit tag\nbit export\n```\n\n첫 번째 명령은 테스트를 실행하고 코드를 린트하며 모든 것이 예상대로 작동하는지 확인할 것입니다. 그리고 그렇게 되면 버전을 0.0.1로 만들 것입니다.\n\n마지막 명령은 두 파일을 클라우드에 업로드할 것입니다. 제 경우에는 여기에서 최종 결과를 볼 수 있습니다.\n\n\n\n\"그리고 만일 'Dependencies' 탭을 클릭하면, 앱을 만들 때 사용한 2개의 마이크로 프론트엔드를 보실 수 있습니다:\n\n![Dependencies](/assets/img/2024-05-14-HowtoReuseMicroFrontends_5.png)\n\n이제 우리의 프로젝트는 팀원들과 함께 협업할 준비가 된 상태입니다.\n\n성공!\"\n\n\n\n마이크로 프론트엔드는 환상적인 재사용성 솔루션을 제시합니다. 이미 존재하는 것을 재사용하여 복잡한 웹사이트와 애플리케이션을 만들 수 있습니다.\n\n팀은 개별적으로 이러한 구성 요소를 만들 수 있으며, 다른 사용자들은 이를 섞어서 매치할 수 있습니다. 생각해보면 레고 블록과 놀이하는 것과 매우 흡사합니다.\n\n물론, \"블록\"을 공유하고 사용하는 것은 간단하지 않습니다. 이를 발견하고 새 프로젝트에 설치하기 위한 도구가 필요합니다. 다행히도 Bit를 사용하면 컴포넌트 중심의 접근 방식으로 마이크로 프론트엔드를 쉽게 만들고 공유하고 재사용할 수 있습니다.\n\n그뿐만 아니라, 이미 존재하는 구성 요소를 확장할 수 있는 도구를 개발자들에게 제공합니다.\n\n\n\n# 또한, 기존 애플리케이션에 마이크로 프론트엔드를 생성하고 추가하는 방법에 대해 알아보세요:\n\n# 추가로 읽을 거리:","ogImage":{"url":"/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png"},"coverImage":"/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png","tag":["Tech"],"readingTime":9},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"마이크로 프론트엔드는 재사용하기 어렵습니다. 그러나 적절한 도구 세트를 활용하면 서로 다른 프로젝트에 걸쳐 마이크로 프론트엔드를 재사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-HowtoReuseMicroFrontends_0.png\",\n        alt: \"Micro Frontends\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이론상으로 마이크로 프론트엔드는 멋지지만, 여러 팀이 동시에 병렬로 생성하고 개별적으로 섞어 다양한 응용 프로그램을 만들어내고 그들의 로직을 재작성할 필요 없이 서로 조합할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그들은 마치 마법 같아요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 실제로 이러한 마이크로 프론트엔드를 공유하고 재사용하는 과정은 쉽지 않습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서 이 글에서 여러 프로젝트에서 무난하게 재사용하는 방법을 보여드릴 거에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"시작해봅시다!\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"우리가 사용할 도구\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마이크로 프론트엔드 자체로는 재사용이나 여러 팀 또는 개발 커뮤니티와 공유할 방법을 제공하지 않습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"따라서 우리는 어떤 종류의 도구가 필요하며, 오늘은 비트(Bit)에 대해 알려 드리겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"비트(Bit) 및 비트 클라우드(Bit Cloud)(클라우드 기반 마켓플레이스)는 구성 가능한 소프트웨어 제품을 개발하는 혁신적인 팀을 위한 완벽한 솔루션을 제공합니다. 업계를 선도하는 구성 요소 기반 개발 플랫폼으로, 수천 개의 팀 및 포춘 500 개사에게 대규모 앱 개발을 위한 구성 가능 앱 개발을 지원합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 CDD 플랫폼에서 필요한 주요 기능 중 일부이며 비트(Bit)에서 제공하는 기능입니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"컴포넌트 중심 개발 툴셋\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"컴포넌트 소스 코드 관리 및 버전 관리\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"의존성 관리: 자동화, 스마트하고 일관성 있음\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"패키징 및 배포\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"공유하고 협업하는 중앙 플랫폼\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"찾아보기 및 검색\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"사용, 설치 및 통합 (빌드 시간 및 런타임)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 \\\"composable app development\\\"와 \\\"component-driven\\\"에 대해 얘기하고 있는 이유가 뭘까요? 왜냐하면 그것이 우리 문제를 해결하는 열쇠가 될 것이기 때문이에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"알다시피, Bit에는 코드뿐만 아니라 테스트와 논리적 컴포넌트의 문서까지 포함하는 \\\"컴포넌트\\\" 개념이 있어요. 이 \\\"컴포넌트\\\" 개념을 우리의 마이크로 프론트엔드에 매핑할 수 있게 되면 위에서 언급한 혜택을 누릴 수 있게 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리의 마이크로 프론트엔드는 갑자기 다음과 같습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"조립 가능합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"모든 종속성을 쉽게 관리할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"개별 패키지로 쉽게 배포할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Bit.cloud를 통해 쉽게 발견할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"그리고 Bit를 통해 이러한 패키지를 설치하는 것은 단 한 가지 명령을 실행하는 것만큼 단순합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다른 프로젝트 내에서 일부 마이크로 프론트엔드를 재사용하는 실용적인 예제를 살펴봅시다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"읽은 내용이 마음에 드셨나요? IT 산업에서 20년치의 지식을 모두와 공유하는 내 무료 뉴스레터에 가입해 보시는 건 어떨까요? \\\"늙은 개발자의 혼잣말\\\"에 참여해 보세요!\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"기존의 마이크로 프론트엔드 재사용\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 Bit를 사용하여 독자적인 마이크로 프론트엔드를 어떻게 만들 수 있는지 궁금하다면, 아래 기사를 읽어보세요. 그곳에서 모든 과정을 단계별로 보여줄 테니까요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 단순히 재사용만 하려면, 조금 더 간단한 프로세스가 적용됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저 해야 할 일은 아래와 같은 명령어로 Bit를 설치하는 것입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"npx @teambit/bvm install\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"설치가 완료되면 Bit은 프로젝트에 패키지를 추가할 준비가 되어 있지만, 이를 수행할 수 있는 여러 가지 방법을 이해해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우선 Bit.cloud를 통해 원하는 마이크로 프론트엔드를 찾아 설치해야 합니다. 예를 들어, 얼마 전에 만든 블로그 마이크로 프론트엔드를 한 번 살펴보겠습니다. 그것은 기사를 나열하는 간단한 마이크로 프론트엔드입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"페이지의 오른쪽 상단에는 \\\"사용\\\" 버튼이 있습니다. 클릭하면 다음 메뉴가 표시됩니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-14-HowtoReuseMicroFrontends_1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"알겠지만, 'Bit'를 사용하는 것 외에도 \\\"npm\\\", \\\"yarn\\\", \\\"pnpm\\\"을 사용할 수 있습니다. 이 모든 프로세스는 간단합니다. 웹사이트에서 제공된 라인을 사용하기만 하면 됩니다. 사실, 이 방법은 Bit가 시스템에 설치되어 있을 필요가 전혀 없습니다. 그러나 이 명령을 사용하여 사용자 정의 Bit 레지스트리를 구성해야 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"npm config set \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@deleteman:registry'\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//node.bit.cloud\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 아마도 이미 알고 계실 것처럼, 이 도구들은 모든 종속성을 직접 node_modules 폴더 내에 설치합니다. 이는 유용하지만 패키지의 코드에 쉽게 액세스하지 못하게 하고 심지어 변경할 수 없게 합니다. 보통 다른 사람의 패키지를 변경하고 싶지 않지만, 여기서는 여러분이 자신의 마이크로 프론트엔드를 재사용하고자 할 수도 있기 때문에 여기저기 변경하는 게 유용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 경우에는 비트(Bit)의 옵션에 대해 알아두는 게 좋아요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"설치: 이 옵션은 npm을 사용하는 것과 거의 비슷합니다. 프로젝트에 구성 요소를 설치하면 예상대로 node_modules 폴더 안에 저장됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"가져오기: 이전 옵션처럼 종속성을 저장하는 대신, 이 명령은 패키지를 워크스페이스 루트에 새 폴더에 다운로드합니다. 그러면 node_modules 블랙홀에 빠질 필요 없이 코드에 쉽게 액세스할 수 있어요. 더불어 Bit는 가져온 각 구성 요소에 대해 node_modules 안에 심볼릭 링크를 만들고 새로 다운로드한 파일을 가리킵니다. 이렇게 하면 코드에서 가져온 구성 요소를 여전히 일반 외부 구성 요소처럼 가져올 수 있습니다. 가져온 마이크로 프론트엔드를 변경하면 업데이트를 새 버전으로 푸시할 수 있어요. 다른 사람들과 협업하여 마이크로 프론트엔드를 개발하고 확장하려는 경우에 이 옵션이 완벽해요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"포크: 그러나 마이크로 프론트엔드의 사본을 만들고 변경하고 싶다면, Forking이 적절한 옵션이에요. \\\"가져오기\\\" 명령과 동일하게 작동하지만 버전 기록을 다운로드하지 않아서 사실상 당신의 변경을 기다리는 새로운 구성 요소가 됩니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이런 내용을 감안하고, 내가 만든 마이크로 프론트엔드를 사용해 새로운 프로젝트를 처음부터 만드는 실용적인 예시를 살펴보겠어요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"마이크로 프론트엔드로 웹사이트 구축하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 예시를 통해, 홈 화면에 2개의 링크가 있는 웹사이트를 만들어보겠습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"블로그: 블로그 마이크로 프론트엔드를 사용하여 블로그를 표시할 예정입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"문서: 문서 마이크로 프론트엔드를 사용하여 내부 네비게이션 및 사용자 정의 페이지를 표시할 예정입니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이들은 모두 예시 마이크로 프론트엔드입니다만, 귀하의 사용 사례에 유용한 예시로 확장할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 Bit를 사용하여 React 앱을 만들고, 그 후에 마이크로 프론트엔드를 설치할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코딩을 시작하기 전에 먼저 Bit 워크스페이스를 생성하여 애플리케이션 코드를 넣을 수 있도록 하겠어요. 이렇게 하면 나중에 공유할 수 있게 될 거에요 (이에 대해서는 잠시 후에 더 자세히 알려드릴게요).\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"your-project-folder\u003e bit \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" react workspace --env teambit.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"react\"\n        }), \"/react-env --\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \"-scope deleteman.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"test\"\n        }), \"-website\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 워크스페이스 폴더 안에서 작업할 거에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 새로운 React 애플리케이션을 만들어봅시다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이를 위해서, 아래 명령어를 사용할 거에요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"bit create react-app apps/website --aspect teambit.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"react\"\n        }), \"/react-env\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 기본 scope 내 (우리의 경우에는 test-website)에 apps/website 폴더를 생성합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 앱을 다음과 같이 설정하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"bit use apps/website\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"그리고 \", _jsx(_components.code, {\n        children: \"bit run website\"\n      }), \"으로 마침내 테스트할 수 있습니다. 이것은 포트 3000에서 서버를 시작하며 다음과 같이 매우 기본적인 내용이 표시됩니다:\\n\", _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-HowtoReuseMicroFrontends_2.png\",\n        alt: \"이미지\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이제 \", _jsx(_components.code, {\n        children: \"apps/website/website.tsx\"\n      }), \" 파일의 코드를 다음과 같이 변경하겠습니다:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./App.css'\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"Website\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"className\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"App\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"header\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"className\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"App-header\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n         웹사이트에 오신 것을 환영합니다!\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n          저희 제품에 대해 더 알고 싶다면, 저희의 \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"href\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"/docs\\\"\"\n            }), \"\u003e\"]\n          }), \"문서\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \"\u003e\"]\n          }), \"를 방문해 주세요.\\n          혹은 \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"href\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"/blog\\\"\"\n            }), \"\u003e\"]\n          }), \"기술 블로그\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \"\u003e\"]\n          }), \"도 확인해 보세요.\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n        \\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"header\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 더 간단히 단축할 수 있지만, 너무 복잡하게 하지 않기 위해 새 홈페이지가 어떻게 보이는지 알려드릴게요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-HowtoReuseMicroFrontends_3.png\",\n        alt: \"2024-05-14-HowtoReuseMicroFrontends_3.png\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 두 섹션에 대한 라우트를 추가해 봅시다. 블로그 섹션이 가장 쉽기 때문에, 그것부터 시작해봅시다.```\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가장 먼저 해야 할 일은 Bit를 사용하여 블로그 마이크로 프론트엔드를 가져오는 것입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"your-project-folder\u003e bit \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" deleteman.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"microfrontends\"\n        }), \"/blog\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금은 프로젝트의 루트에 microfrontends라는 폴더가 생겼을 것이며, website.tsx 파일을 다음과 같이 편집할 수 있을 것입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { useState } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Blog\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@deleteman/microfrontends.blog\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./App.css'\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"Website\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [page, setPage] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"home\\\"\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"navTo\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"event, target\"\n        }), \") {\\n    event.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"preventDefault\"\n        }), \"();\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setPage\"\n        }), \"(target);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \";\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \"(page === \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"home\\\"\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n      \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"className\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"App\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"header\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"className\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"App-header\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n          \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n            웹사이트에 오신 것을 환영합니다!\\n          \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n          \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n            제품에 대해 더 알아보려면 \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"href\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"#\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"className\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"'inline'\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onClick\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{(evt)\"\n            }), \" =\u003e\"]\n          }), \" navTo(evt,'docs')}\u003e문서\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \"\u003e\"]\n          }), \"를 방문해주세요.\\n            또는 \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"href\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"#\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"className\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"'inline'\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onClick\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{(evt)\"\n            }), \" =\u003e\"]\n          }), \" navTo(evt, 'blog')}\u003e기술 블로그\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \"\u003e\"]\n          }), \"를 확인해도 좋아요.\\n          \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"header\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n    );\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \"(page === \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"blog\\\"\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n      \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-tag\",\n            children: \"\u003c\u003e\"\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Blog\"\n            }), \" /\u003e\"]\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n          홈으로 돌아가려면 \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"href\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"#\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"className\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"'inline'\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onClick\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{(evnt)\"\n            }), \" =\u003e\"]\n          }), \" navTo(evnt, 'home')}\u003e홈\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \"\u003e\"]\n          }), \"을 클릭하세요.\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsx(_components.span, {\n            className: \"hljs-tag\",\n            children: \"\u003c/\u003e\"\n          })]\n        }), \"\\n    );\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"주목하세요! 여기서는 첫 번째 마이크로 프론트엔드인 Blog 컴포넌트를 가져온다는 것을 알 수 있습니다. 파일이 다른 위치에 있더라도 node_modules 폴더 안에 복사된 것처럼 다룰 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"게다가 추가적인 라우팅을 추가하지 않았으므로 간단한 페이지 상태 변수로 내비게이션을 시뮬레이션하고 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 Docs 마이크로 프론트엔드에서는 동일한 동작이 되도록, 올바른 컴포넌트를 렌더링하기 위해 새로운 if 문을 추가할 거예요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" {\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Docs\"\n        }), \"} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@deleteman/microfrontends.docs\\\"\"\n        }), \"\\n\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \"(page == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"docs\\\"\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n      \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-tag\",\n            children: \"\u003c\u003e\"\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Docs\"\n            }), \" /\u003e\"]\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n          Go back \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"href\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"#\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"className\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"'inline'\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onClick\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{(evnt)\"\n            }), \" =\u003e\"]\n          }), \" navTo(evnt, 'home')}\u003eHome\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"a\"\n            }), \"\u003e\"]\n          }), \"\\n        \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"p\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsx(_components.span, {\n            className: \"hljs-tag\",\n            children: \"\u003c/\u003e\"\n          })]\n        }), \"\\n    )\\n  }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다시 한 번 알고 계시든 아니면 그렇지 않든, Docs 컴포넌트를 마치 node_modules 내에 설치된 것처럼 가져오고 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 여기가 최종 (그리고 못생긴) 결과입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*DAkwXJnhXjDGwVvmrh_M0Q.gif\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단순히 프로젝트에 2개의 마이크로 프론트엔드를 추가함으로써, 블로그와 문서 섹션을 위한 완전히 작동하는 내비게이션과 새로운 내부 링크 및 페이지를 쉽게 추가할 수 있었어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"강력한 내용이네요!\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Bit에 최종 제품 푸시하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"네, Bit를 사용하면 컴포넌트를 공유할 뿐만 아니라 완전한 애플리케이션도 공유할 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이유가 뭔가요? 그것은 이들이 실제로 플랫폼에서 CI를 구성할 수 있는 능력을 제공하기 때문이에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 중요한 점은 최최 어플리케이션이 완성되면 버전을 지정하여 컴포넌트로 공유할 수 있다는 것이다. 다른 개발자들이 이를 설치하고 작업할 수 있으며, 동시에 완벽하게 작동하는 CI/CD 파이프라인을 갖게 될 것이다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가장 먼저 해야 할 일은 Bit.cloud에 가서 새 scope를 생성하는 것이다. 나는 \\\"test-website\\\"라고 이름 지었어 (네, 너무 원래 있어 보여!):\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-HowtoReuseMicroFrontends_4.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금쯤이면 이미 어플리케이션을 설정하고 생성했을 것이다 (이 강의 전체를 통해 그렇게 했으니까), 따라서 남은 것은 버전을 지정하고 내보내는 것이다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 명령어를 실행해주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"bit tag\\nbit \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"첫 번째 명령은 테스트를 실행하고 코드를 린트하며 모든 것이 예상대로 작동하는지 확인할 것입니다. 그리고 그렇게 되면 버전을 0.0.1로 만들 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막 명령은 두 파일을 클라우드에 업로드할 것입니다. 제 경우에는 여기에서 최종 결과를 볼 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\"그리고 만일 'Dependencies' 탭을 클릭하면, 앱을 만들 때 사용한 2개의 마이크로 프론트엔드를 보실 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-HowtoReuseMicroFrontends_5.png\",\n        alt: \"Dependencies\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 우리의 프로젝트는 팀원들과 함께 협업할 준비가 된 상태입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"성공!\\\"\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마이크로 프론트엔드는 환상적인 재사용성 솔루션을 제시합니다. 이미 존재하는 것을 재사용하여 복잡한 웹사이트와 애플리케이션을 만들 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"팀은 개별적으로 이러한 구성 요소를 만들 수 있으며, 다른 사용자들은 이를 섞어서 매치할 수 있습니다. 생각해보면 레고 블록과 놀이하는 것과 매우 흡사합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"물론, \\\"블록\\\"을 공유하고 사용하는 것은 간단하지 않습니다. 이를 발견하고 새 프로젝트에 설치하기 위한 도구가 필요합니다. 다행히도 Bit를 사용하면 컴포넌트 중심의 접근 방식으로 마이크로 프론트엔드를 쉽게 만들고 공유하고 재사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그뿐만 아니라, 이미 존재하는 구성 요소를 확장할 수 있는 도구를 개발자들에게 제공합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"또한, 기존 애플리케이션에 마이크로 프론트엔드를 생성하고 추가하는 방법에 대해 알아보세요:\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"추가로 읽을 거리:\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-HowtoReuseMicroFrontends"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>