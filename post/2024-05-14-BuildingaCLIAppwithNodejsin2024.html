<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>2024년에 Nodejs로 CLI 애플리케이션 만들기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-BuildingaCLIAppwithNodejsin2024" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="2024년에 Nodejs로 CLI 애플리케이션 만들기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="2024년에 Nodejs로 CLI 애플리케이션 만들기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-BuildingaCLIAppwithNodejsin2024" data-gatsby-head="true"/><meta name="twitter:title" content="2024년에 Nodejs로 CLI 애플리케이션 만들기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 14:25" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-742e6c91a18eb160.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">2024년에 Nodejs로 CLI 애플리케이션 만들기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="2024년에 Nodejs로 CLI 애플리케이션 만들기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-BuildingaCLIAppwithNodejsin2024&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>Node.js로 CLI 앱을 만드는 과정을 자세히 안내하는 스텝바이스텝 가이드입니다. 명령 처리와 사용자 프롬프트부터 사용자 경험 향상, 프로젝트 구조 정리 및 문서화에 이르기까지 모든 것을 다루고 있습니다.</h2>
<p><img src="/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_0.png" alt="CLI App with Node.js"></p>
<h2>왜 Node.js를 사용해야 하는가?</h2>
<p>이벤트 기반 아키텍처와 이를 위해 특별히 설계된 많은 패키지를 제공하는 npm 생태계로 인해 효율적이고 확장 가능한 CLI 도구를 개발하는 데 가장 적합한 선택지가 됩니다.</p>
<h2>CLI 앱을 만드는 이유는?</h2>
<ul>
<li>작업 자동화</li>
<li>개발자를 위한 도구 만들기</li>
<li>시스템과 흐름 관리와 상호작용</li>
</ul>
<h2>실제 예시</h2>
<p>Nielsen에서는 많은 가치를 제공하는 여러 CLI를 만들었습니다.</p>
<ul>
<li>CI/CD 플로우에서 동적 파이프라인을 관리하는 CLI — 더 이상 수동 구성이나 프로세스 간 대기가 필요하지 않아요.</li>
<li>로컬 도커 환경을 설정하고 관리하는 CLI.</li>
<li>마이그레이션을 위한 미리 정의된 단계를 실행하는 CLI.</li>
</ul>
<p>이제 한 개 만드는 것이 얼마나 쉬운지 알게 될 거예요.
바로 코드로 빠져들기를 원하시는 분들을 위해, 파일은 여기서 찾을 수 있어요.</p>
<h1>목차</h1>
<ul>
<li>설정하기
∘ 프로젝트 부트스트랩
∘ Commander.js 가져오기
∘ CLI 만들기</li>
<li>유저 경험
∘ 색상 추가하기
∘ 쉬운 프롬프팅
∘ 멋진 로더
∘ ASCII 아트 추가하기</li>
<li>프로젝트 구조</li>
<li>문서화
∘ 자동 문서 생성</li>
<li>최선의 실천법</li>
</ul>
<h1>설정하기</h1>
<p>먼저 컴퓨터에 Node.js가 설치되어 있는지 확인해주세요.</p>
<h2>단계 1: 프로젝트 시작하기</h2>
<p>프로젝트를 위한 새 폴더를 만들고 그 안으로 들어가세요:</p>
<pre><code class="hljs language-js">mkdir my-node-cli
cd my-node-cli
</code></pre>
<p>새 Node.js 프로젝트를 시작해보세요:</p>
<pre><code class="hljs language-js">npm init
</code></pre>
<h2>단계 2: Commander.js 가져오기</h2>
<p>Commander.js은 Node.js에서 CLI를 구축하는 데 사용하는 핵심 도구입니다. 입력 구문 분석, 도움말 텍스트 및 오류 관리를 위한 스위스 아미 나이프가 있는 것과 같습니다.</p>
<pre><code class="hljs language-js">npm install commander
</code></pre>
<h2>단계 3: CLI 만들기</h2>
<p>프로젝트 폴더에 index.js라는 파일을 만듭니다. 이것이 우리의 CLI가 시작하는 곳이 될 것입니다. 이 CLI를 실행하기 위해 맨 위에 shebang을 추가하십시오.</p>
<pre><code class="hljs language-md"><span class="hljs-section">#!/usr/bin/env node</span>

import { program } from "commander";

program
  .version("1.0.0")
  .description("내 노드 CLI")
  .option("-n, --name <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">type</span>></span></span>", "당신의 이름을 추가하세요")
  .action((options) => {
<span class="hljs-code">    console.log(`안녕, ${options.name}!`);
  });
</span>
program.parse(process.argv);
</code></pre>
<p>패키지.json에 bin을 추가하여 CLI 명령을 인식하도록하고 CommonJS 대신 ES 모듈과 함께 작동하도록 유형을 추가하십시오:</p>
<pre><code class="hljs language-js"><span class="hljs-string">"bin"</span>: {
    <span class="hljs-string">"my-node-cli"</span>: <span class="hljs-string">"./index.js"</span>
},
<span class="hljs-string">"type"</span>: <span class="hljs-string">"module"</span>
</code></pre>
<p>프로젝트를 전역적으로 연결하려면:</p>
<pre><code class="hljs language-bash">npm <span class="hljs-built_in">link</span>
</code></pre>
<pre><code class="hljs language-js">npm link 
</code></pre>
<p>그러면, 내 my-node-cli가 당신의 터미널에서 실행될 준비가 끝납니다!</p>
<pre><code class="hljs language-js">my-node-cli --name <span class="hljs-title class_">YourName</span>
</code></pre>
<p><img src="/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_1.png" alt="이미지"></p>
<p>참고: Node.js 18.3부터는 내장된 커맨드 라인 인수 구문 분석기가 있습니다. 이것에 대해 읽어보고 commander.js 대신 사용할지 결정할 수 있습니다.</p>
<h1>사용자 경험</h1>
<h2>색상 추가하기</h2>
<p>Chalk는 CLI 출력을 다채롭게 만드는 데 완벽합니다. 다음 명령을 사용하여 가져올 수 있습니다:</p>
<pre><code class="hljs language-js">npm install chalk
</code></pre>
<p>이제 우리의 인사말을 개선해 보겠습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-meta">#!/usr/bin/env node</span>

<span class="hljs-keyword">import</span> { program } <span class="hljs-keyword">from</span> <span class="hljs-string">"commander"</span>;
<span class="hljs-keyword">import</span> chalk <span class="hljs-keyword">from</span> <span class="hljs-string">"chalk"</span>;

program
  .<span class="hljs-title function_">version</span>(<span class="hljs-string">"1.0.0"</span>)
  .<span class="hljs-title function_">description</span>(<span class="hljs-string">"내 Node CLI"</span>)
  .<span class="hljs-title function_">option</span>(<span class="hljs-string">"-n, --name &#x3C;type>"</span>, <span class="hljs-string">"당신의 이름을 추가하세요"</span>)
  .<span class="hljs-title function_">action</span>(<span class="hljs-function">(<span class="hljs-params">options</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chalk.<span class="hljs-title function_">blue</span>(<span class="hljs-string">`안녕, <span class="hljs-subst">${options.name}</span>!`</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chalk.<span class="hljs-title function_">green</span>(<span class="hljs-string">`안녕, <span class="hljs-subst">${options.name}</span>!`</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chalk.<span class="hljs-title function_">red</span>(<span class="hljs-string">`안녕, <span class="hljs-subst">${options.name}</span>!`</span>));
  });

program.<span class="hljs-title function_">parse</span>(process.<span class="hljs-property">argv</span>);
</code></pre>
<p><img src="/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_2.png" alt="이미지"></p>
<h2>손쉬운 프롬프팅</h2>
<p>더욱 상호작용적인 느낌을 원하신다면 Inquirer.js가 좋은 선택입니다.</p>
<pre><code class="hljs language-js">npm install inquirer
</code></pre>
<p>데이터를 수집하기 위해 명령줄 옵션을 사용하는 대신, 사용자에게 질문하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-meta">#!/usr/bin/env node</span>

<span class="hljs-keyword">import</span> { program } <span class="hljs-keyword">from</span> <span class="hljs-string">"commander"</span>;
<span class="hljs-keyword">import</span> chalk <span class="hljs-keyword">from</span> <span class="hljs-string">"chalk"</span>;
<span class="hljs-keyword">import</span> inquirer <span class="hljs-keyword">from</span> <span class="hljs-string">"inquirer"</span>;

program.<span class="hljs-title function_">version</span>(<span class="hljs-string">"1.0.0"</span>).<span class="hljs-title function_">description</span>(<span class="hljs-string">"나의 Node CLI"</span>);

program.<span class="hljs-title function_">action</span>(<span class="hljs-function">() =></span> {
  inquirer
    .<span class="hljs-title function_">prompt</span>([
      {
        <span class="hljs-attr">type</span>: <span class="hljs-string">"input"</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">"name"</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">"당신의 이름은 무엇인가요?"</span>,
      },
    ])
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">answers</span>) =></span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chalk.<span class="hljs-title function_">green</span>(<span class="hljs-string">`안녕하세요, <span class="hljs-subst">${answers.name}</span>님!`</span>));
    });
});

program.<span class="hljs-title function_">parse</span>(process.<span class="hljs-property">argv</span>);
</code></pre>
<p><img src="/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_3.png" alt="Building a CLI App with Node.js"></p>
<p>사용 가능한 Confirm 프롬프트 유형이 있습니다. 사용자에게 예/아니오 질문을 합니다.</p>
<p><img src="/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_4.png" alt="Building a CLI App with Node.js"></p>
<p>프롬프트 유형 — 사용자가 옵션 목록에서 선택할 수 있도록 합니다.</p>
<p><img src="/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_5.png" alt="이미지"></p>
<p>또한 체크박스, 비밀번호, 목록 및 확장 기능도 있습니다. <a href="https://github.com/SBoudrias/Inquirer.js%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">https://github.com/SBoudrias/Inquirer.js에서</a> 더 많이 알아보세요.</p>
<h2>멋진 로더들</h2>
<p>로딩 시간을 어떻게 보내시나요? ora를 사용하면 재미있게 만들 수 있어요. 스피너 애니메이션을 추가하는 데 좋아요:</p>
<pre><code class="hljs language-js">npm install ora
</code></pre>
<p>시간이 걸리는 프로세스에 로더를 뿌려보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-meta">#!/usr/bin/env node</span>

<span class="hljs-keyword">import</span> { program } <span class="hljs-keyword">from</span> <span class="hljs-string">"commander"</span>;
<span class="hljs-keyword">import</span> chalk <span class="hljs-keyword">from</span> <span class="hljs-string">"chalk"</span>;
<span class="hljs-keyword">import</span> inquirer <span class="hljs-keyword">from</span> <span class="hljs-string">"inquirer"</span>;
<span class="hljs-keyword">import</span> ora <span class="hljs-keyword">from</span> <span class="hljs-string">"ora"</span>;

program.<span class="hljs-title function_">version</span>(<span class="hljs-string">"1.0.0"</span>).<span class="hljs-title function_">description</span>(<span class="hljs-string">"My Node CLI"</span>);

program.<span class="hljs-title function_">action</span>(<span class="hljs-function">() =></span> {
  inquirer
    .<span class="hljs-title function_">prompt</span>([
      {
        <span class="hljs-attr">type</span>: <span class="hljs-string">"list"</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">"choice"</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">"옵션을 선택하세요:"</span>,
        <span class="hljs-attr">choices</span>: [<span class="hljs-string">"옵션 1"</span>, <span class="hljs-string">"옵션 2"</span>, <span class="hljs-string">"옵션 3"</span>],
      },
    ])
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =></span> {
      <span class="hljs-keyword">const</span> spinner = <span class="hljs-title function_">ora</span>(<span class="hljs-string">`<span class="hljs-subst">${result.choice}</span> 작업 중...`</span>).<span class="hljs-title function_">start</span>(); <span class="hljs-comment">// 스피너 시작</span>

      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
        spinner.<span class="hljs-title function_">succeed</span>(chalk.<span class="hljs-title function_">green</span>(<span class="hljs-string">"완료!"</span>));
      }, <span class="hljs-number">3000</span>);
    });
});

program.<span class="hljs-title function_">parse</span>(process.<span class="hljs-property">argv</span>);
</code></pre>
<h2>ASCII Art 추가</h2>
<p>figlet.js로 마지막 손질을 해봅시다:</p>
<pre><code class="hljs language-js">npm install figlet
</code></pre>
<p>index.js에 다음을 추가해주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> figlet <span class="hljs-keyword">from</span> <span class="hljs-string">"figlet"</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
  chalk.<span class="hljs-title function_">yellow</span>(figlet.<span class="hljs-title function_">textSync</span>(<span class="hljs-string">"My Node CLI"</span>, { <span class="hljs-attr">horizontalLayout</span>: <span class="hljs-string">"full"</span> }))
);
</code></pre>
<p>CLI의 aesthetic에 맞게 ASCII 아트를 맞춤화할 수 있는 다양한 글꼴 및 사용자 정의 옵션이 있습니다.</p>
<h1>프로젝트 구조</h1>
<p>프로젝트를 깔끔하게 유지하면 나중에 시간을 아낄 수 있어요, 특히 프로젝트가 커지면 더욱 그렇습니다. 다음은 시작하기에 좋은 간단하면서도 효과적인 구조입니다:</p>
<pre><code class="hljs language-js">my-node-cli/
├─ bin/
│ └─ index.<span class="hljs-property">js</span>
├─ src/
│ ├─ commands/
│ ├─ utils/
│ └─ lib/
├─ package.<span class="hljs-property">json</span>
└─ <span class="hljs-variable constant_">README</span>.<span class="hljs-property">md</span>
</code></pre>
<ul>
<li>bin — 여러분의 CLI가 있는 곳입니다. 누군가가 CLI를 실행할 때 호출되는 곳입니다.</li>
<li>src/commands — 개별 명령어 파일이 있는 위치입니다. 새로운 명령어를 추가하거나 기존 명령어를 편집할 때 더 깔끔하게 작업할 수 있습니다.</li>
<li>src/utils — 여러 명령어에서 필요한 유틸리티 함수를 담고 있습니다. 데이터 형식 설정과 같은 기능이 포함될 수 있습니다.</li>
<li>src/lib — 여러분의 CLI가 API와 상호 작용하거나 복잡한 로직을 실행하는 경우 주요 기능이 위치할 수 있습니다.</li>
</ul>
<h1>문서화</h1>
<p>명확한 문서화가 중요합니다. 사용자를 명령줄 도구를 통해 직접 놀라운 작업을 수행할 수 있도록 설치, 사용법 및 명령 옵션을 README.md에 개요로 기록하십시오.</p>
<pre><code class="hljs language-js"># 내 노드 <span class="hljs-variable constant_">CLI</span>
내 노드 <span class="hljs-variable constant_">CLI</span>는 터미널에서 직접 멋진 작업을 수행할 수 있는 도구입니다.

## 설치

<span class="hljs-string">``</span><span class="hljs-string">`bash
npm install -g my-node-cli
</span></code></pre>
<h2>사용법</h2>
<p>내 노드 CLI를 사용하려면 다음을 실행하십시오:</p>
<pre><code class="hljs language-bash">my-node-cli - <span class="hljs-built_in">help</span>
</code></pre>
<h3>명령어</h3>
<ul>
<li><code>my-node-cli - name YourName</code>: 당신의 이름으로 인사합니다.</li>
<li><code>my-node-cli option1</code>: 옵션 1을 실행합니다.</li>
</ul>
<p>더 자세한 명령어 정보는 <code>my-node-cli --help</code>를 실행해 주세요.</p>
<h2>기여하기</h2>
<p>기여는 환영합니다...</p>
<h2>라이선스</h2>
<p>이 프로젝트는 라이선스가 부여되었습니다...</p>
<h2>문서 자동 생성하기</h2>
<p>테이블 태그를 마크다운 형식으로 변경하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
 * 이 함수는 사용자의 이름으로 인사합니다.
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} name 사용자의 이름
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">greet</span> = (<span class="hljs-params">name</span>) => {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`안녕, <span class="hljs-subst">${name}</span>!`</span>);
};
</code></pre>
<h1>Best Practices</h1>
<p>실제 CLI 논리 작업을 시작하기 전에 Liran Tal의 이 리포를 확인하는 것을 강력히 권장합니다. 이 리포는 3천 개 이상의 스타를 받았으며 제가 생각한 모든 최상의 실천 방법과 그 이상을 다룹니다.</p>
<p>예를 들어, 사용자가 호출할 때 동일한 정보를 반복해서 제공하는 것을 요구하지 않고, 상태를 유지하면서 사용자 경험을 제공할 수 있습니다. conf를 사용하여 사용자 이름, 이메일 또는 API 토큰과 같은 데이터를 저장할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_7.png" alt="이미지"></p>
<p>이 모든 것이 실제로 작동하는 것을 보고 싶나요? 모든 예시 파일과 함께 완성된 프로젝트를 제 GitHub 페이지에서 확인해보세요. 들어가서 둘러보고, 자유롭게 실험해보세요. 만약 도움이 된다면 리포지토리를 fork하거나 스타를 눌러주세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"2024년에 Nodejs로 CLI 애플리케이션 만들기","description":"","date":"2024-05-14 14:25","slug":"2024-05-14-BuildingaCLIAppwithNodejsin2024","content":"\n\n## Node.js로 CLI 앱을 만드는 과정을 자세히 안내하는 스텝바이스텝 가이드입니다. 명령 처리와 사용자 프롬프트부터 사용자 경험 향상, 프로젝트 구조 정리 및 문서화에 이르기까지 모든 것을 다루고 있습니다.\n\n![CLI App with Node.js](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_0.png)\n\n## 왜 Node.js를 사용해야 하는가?\n\n이벤트 기반 아키텍처와 이를 위해 특별히 설계된 많은 패키지를 제공하는 npm 생태계로 인해 효율적이고 확장 가능한 CLI 도구를 개발하는 데 가장 적합한 선택지가 됩니다.\n\n\n\n## CLI 앱을 만드는 이유는?\n\n- 작업 자동화\n- 개발자를 위한 도구 만들기\n- 시스템과 흐름 관리와 상호작용\n\n## 실제 예시\n\nNielsen에서는 많은 가치를 제공하는 여러 CLI를 만들었습니다.\n\n\n\n- CI/CD 플로우에서 동적 파이프라인을 관리하는 CLI — 더 이상 수동 구성이나 프로세스 간 대기가 필요하지 않아요.\n- 로컬 도커 환경을 설정하고 관리하는 CLI.\n- 마이그레이션을 위한 미리 정의된 단계를 실행하는 CLI.\n\n이제 한 개 만드는 것이 얼마나 쉬운지 알게 될 거예요.\n바로 코드로 빠져들기를 원하시는 분들을 위해, 파일은 여기서 찾을 수 있어요.\n\n# 목차\n\n- 설정하기\n∘ 프로젝트 부트스트랩\n∘ Commander.js 가져오기\n∘ CLI 만들기\n- 유저 경험\n∘ 색상 추가하기\n∘ 쉬운 프롬프팅\n∘ 멋진 로더\n∘ ASCII 아트 추가하기\n- 프로젝트 구조\n- 문서화\n∘ 자동 문서 생성\n- 최선의 실천법\n\n\n\n# 설정하기\n\n먼저 컴퓨터에 Node.js가 설치되어 있는지 확인해주세요.\n\n## 단계 1: 프로젝트 시작하기\n\n프로젝트를 위한 새 폴더를 만들고 그 안으로 들어가세요:\n\n\n\n```js\nmkdir my-node-cli\ncd my-node-cli\n```\n\n새 Node.js 프로젝트를 시작해보세요:\n\n```js\nnpm init\n```\n\n## 단계 2: Commander.js 가져오기\n\n\n\nCommander.js은 Node.js에서 CLI를 구축하는 데 사용하는 핵심 도구입니다. 입력 구문 분석, 도움말 텍스트 및 오류 관리를 위한 스위스 아미 나이프가 있는 것과 같습니다.\n\n```js\nnpm install commander\n```\n\n## 단계 3: CLI 만들기\n\n프로젝트 폴더에 index.js라는 파일을 만듭니다. 이것이 우리의 CLI가 시작하는 곳이 될 것입니다. 이 CLI를 실행하기 위해 맨 위에 shebang을 추가하십시오.\n\n\n\n```md\n#!/usr/bin/env node\n\nimport { program } from \"commander\";\n\nprogram\n  .version(\"1.0.0\")\n  .description(\"내 노드 CLI\")\n  .option(\"-n, --name \u003ctype\u003e\", \"당신의 이름을 추가하세요\")\n  .action((options) =\u003e {\n    console.log(`안녕, ${options.name}!`);\n  });\n\nprogram.parse(process.argv);\n```\n\n패키지.json에 bin을 추가하여 CLI 명령을 인식하도록하고 CommonJS 대신 ES 모듈과 함께 작동하도록 유형을 추가하십시오:\n\n```js\n\"bin\": {\n    \"my-node-cli\": \"./index.js\"\n},\n\"type\": \"module\"\n```\n\n프로젝트를 전역적으로 연결하려면:\n```bash\nnpm link\n```\n\n\n\n```js\nnpm link \n```\n\n그러면, 내 my-node-cli가 당신의 터미널에서 실행될 준비가 끝납니다!\n\n```js\nmy-node-cli --name YourName\n```\n\n![이미지](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_1.png)\n\n\n\n참고: Node.js 18.3부터는 내장된 커맨드 라인 인수 구문 분석기가 있습니다. 이것에 대해 읽어보고 commander.js 대신 사용할지 결정할 수 있습니다.\n\n# 사용자 경험\n\n## 색상 추가하기\n\nChalk는 CLI 출력을 다채롭게 만드는 데 완벽합니다. 다음 명령을 사용하여 가져올 수 있습니다:\n\n\n\n```js\nnpm install chalk\n```\n\n이제 우리의 인사말을 개선해 보겠습니다:\n\n```js\n#!/usr/bin/env node\n\nimport { program } from \"commander\";\nimport chalk from \"chalk\";\n\nprogram\n  .version(\"1.0.0\")\n  .description(\"내 Node CLI\")\n  .option(\"-n, --name \u003ctype\u003e\", \"당신의 이름을 추가하세요\")\n  .action((options) =\u003e {\n    console.log(chalk.blue(`안녕, ${options.name}!`));\n    console.log(chalk.green(`안녕, ${options.name}!`));\n    console.log(chalk.red(`안녕, ${options.name}!`));\n  });\n\nprogram.parse(process.argv);\n```\n\n![이미지](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_2.png)\n\n\n\n## 손쉬운 프롬프팅\n\n더욱 상호작용적인 느낌을 원하신다면 Inquirer.js가 좋은 선택입니다.\n\n```js\nnpm install inquirer\n```\n\n데이터를 수집하기 위해 명령줄 옵션을 사용하는 대신, 사용자에게 질문하세요.\n\n\n\n```js\n#!/usr/bin/env node\n\nimport { program } from \"commander\";\nimport chalk from \"chalk\";\nimport inquirer from \"inquirer\";\n\nprogram.version(\"1.0.0\").description(\"나의 Node CLI\");\n\nprogram.action(() =\u003e {\n  inquirer\n    .prompt([\n      {\n        type: \"input\",\n        name: \"name\",\n        message: \"당신의 이름은 무엇인가요?\",\n      },\n    ])\n    .then((answers) =\u003e {\n      console.log(chalk.green(`안녕하세요, ${answers.name}님!`));\n    });\n});\n\nprogram.parse(process.argv);\n```\n\n![Building a CLI App with Node.js](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_3.png)\n\n사용 가능한 Confirm 프롬프트 유형이 있습니다. 사용자에게 예/아니오 질문을 합니다.\n\n![Building a CLI App with Node.js](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_4.png)\n\n\n\n\n프롬프트 유형 — 사용자가 옵션 목록에서 선택할 수 있도록 합니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_5.png)\n\n또한 체크박스, 비밀번호, 목록 및 확장 기능도 있습니다. https://github.com/SBoudrias/Inquirer.js에서 더 많이 알아보세요.\n\n## 멋진 로더들\n\n\n\n로딩 시간을 어떻게 보내시나요? ora를 사용하면 재미있게 만들 수 있어요. 스피너 애니메이션을 추가하는 데 좋아요:\n\n```js\nnpm install ora\n```\n\n시간이 걸리는 프로세스에 로더를 뿌려보세요:\n\n```js\n#!/usr/bin/env node\n\nimport { program } from \"commander\";\nimport chalk from \"chalk\";\nimport inquirer from \"inquirer\";\nimport ora from \"ora\";\n\nprogram.version(\"1.0.0\").description(\"My Node CLI\");\n\nprogram.action(() =\u003e {\n  inquirer\n    .prompt([\n      {\n        type: \"list\",\n        name: \"choice\",\n        message: \"옵션을 선택하세요:\",\n        choices: [\"옵션 1\", \"옵션 2\", \"옵션 3\"],\n      },\n    ])\n    .then((result) =\u003e {\n      const spinner = ora(`${result.choice} 작업 중...`).start(); // 스피너 시작\n\n      setTimeout(() =\u003e {\n        spinner.succeed(chalk.green(\"완료!\"));\n      }, 3000);\n    });\n});\n\nprogram.parse(process.argv);\n```\n\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*wFmspYHAW5572fRutff1MQ.gif\" /\u003e\n\n## ASCII Art 추가\n\nfiglet.js로 마지막 손질을 해봅시다:\n\n```js\nnpm install figlet\n```\n\n\n\nindex.js에 다음을 추가해주세요.\n\n```js\nimport figlet from \"figlet\";\n\nconsole.log(\n  chalk.yellow(figlet.textSync(\"My Node CLI\", { horizontalLayout: \"full\" }))\n);\n```\n\n\u003cimg src=\"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_6.png\" /\u003e\n\nCLI의 aesthetic에 맞게 ASCII 아트를 맞춤화할 수 있는 다양한 글꼴 및 사용자 정의 옵션이 있습니다.\n\n\n\n# 프로젝트 구조\n\n프로젝트를 깔끔하게 유지하면 나중에 시간을 아낄 수 있어요, 특히 프로젝트가 커지면 더욱 그렇습니다. 다음은 시작하기에 좋은 간단하면서도 효과적인 구조입니다:\n\n```js\nmy-node-cli/\n├─ bin/\n│ └─ index.js\n├─ src/\n│ ├─ commands/\n│ ├─ utils/\n│ └─ lib/\n├─ package.json\n└─ README.md\n```\n\n- bin — 여러분의 CLI가 있는 곳입니다. 누군가가 CLI를 실행할 때 호출되는 곳입니다.\n- src/commands — 개별 명령어 파일이 있는 위치입니다. 새로운 명령어를 추가하거나 기존 명령어를 편집할 때 더 깔끔하게 작업할 수 있습니다.\n- src/utils — 여러 명령어에서 필요한 유틸리티 함수를 담고 있습니다. 데이터 형식 설정과 같은 기능이 포함될 수 있습니다.\n- src/lib — 여러분의 CLI가 API와 상호 작용하거나 복잡한 로직을 실행하는 경우 주요 기능이 위치할 수 있습니다.\n\n\n\n# 문서화\n\n명확한 문서화가 중요합니다. 사용자를 명령줄 도구를 통해 직접 놀라운 작업을 수행할 수 있도록 설치, 사용법 및 명령 옵션을 README.md에 개요로 기록하십시오.\n\n```js\n# 내 노드 CLI\n내 노드 CLI는 터미널에서 직접 멋진 작업을 수행할 수 있는 도구입니다.\n\n## 설치\n\n```bash\nnpm install -g my-node-cli\n```\n\n## 사용법\n내 노드 CLI를 사용하려면 다음을 실행하십시오:\n\n```bash\nmy-node-cli - help\n```\n\n### 명령어\n- `my-node-cli - name YourName`: 당신의 이름으로 인사합니다.\n- `my-node-cli option1`: 옵션 1을 실행합니다.\n\n더 자세한 명령어 정보는 `my-node-cli --help`를 실행해 주세요.\n\n## 기여하기\n기여는 환영합니다...\n\n## 라이선스\n이 프로젝트는 라이선스가 부여되었습니다...\n \n\n## 문서 자동 생성하기\n\n\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n```js\n/**\n * 이 함수는 사용자의 이름으로 인사합니다.\n * @param {string} name 사용자의 이름\n */\nconst greet = (name) =\u003e {\n  console.log(`안녕, ${name}!`);\n};\n```\n\n# Best Practices\n\n실제 CLI 논리 작업을 시작하기 전에 Liran Tal의 이 리포를 확인하는 것을 강력히 권장합니다. 이 리포는 3천 개 이상의 스타를 받았으며 제가 생각한 모든 최상의 실천 방법과 그 이상을 다룹니다.\n\n\n\n예를 들어, 사용자가 호출할 때 동일한 정보를 반복해서 제공하는 것을 요구하지 않고, 상태를 유지하면서 사용자 경험을 제공할 수 있습니다. conf를 사용하여 사용자 이름, 이메일 또는 API 토큰과 같은 데이터를 저장할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_7.png)\n\n이 모든 것이 실제로 작동하는 것을 보고 싶나요? 모든 예시 파일과 함께 완성된 프로젝트를 제 GitHub 페이지에서 확인해보세요. 들어가서 둘러보고, 자유롭게 실험해보세요. 만약 도움이 된다면 리포지토리를 fork하거나 스타를 눌러주세요!","ogImage":{"url":"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_0.png"},"coverImage":"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003eNode.js로 CLI 앱을 만드는 과정을 자세히 안내하는 스텝바이스텝 가이드입니다. 명령 처리와 사용자 프롬프트부터 사용자 경험 향상, 프로젝트 구조 정리 및 문서화에 이르기까지 모든 것을 다루고 있습니다.\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_0.png\" alt=\"CLI App with Node.js\"\u003e\u003c/p\u003e\n\u003ch2\u003e왜 Node.js를 사용해야 하는가?\u003c/h2\u003e\n\u003cp\u003e이벤트 기반 아키텍처와 이를 위해 특별히 설계된 많은 패키지를 제공하는 npm 생태계로 인해 효율적이고 확장 가능한 CLI 도구를 개발하는 데 가장 적합한 선택지가 됩니다.\u003c/p\u003e\n\u003ch2\u003eCLI 앱을 만드는 이유는?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e작업 자동화\u003c/li\u003e\n\u003cli\u003e개발자를 위한 도구 만들기\u003c/li\u003e\n\u003cli\u003e시스템과 흐름 관리와 상호작용\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e실제 예시\u003c/h2\u003e\n\u003cp\u003eNielsen에서는 많은 가치를 제공하는 여러 CLI를 만들었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCI/CD 플로우에서 동적 파이프라인을 관리하는 CLI — 더 이상 수동 구성이나 프로세스 간 대기가 필요하지 않아요.\u003c/li\u003e\n\u003cli\u003e로컬 도커 환경을 설정하고 관리하는 CLI.\u003c/li\u003e\n\u003cli\u003e마이그레이션을 위한 미리 정의된 단계를 실행하는 CLI.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 한 개 만드는 것이 얼마나 쉬운지 알게 될 거예요.\n바로 코드로 빠져들기를 원하시는 분들을 위해, 파일은 여기서 찾을 수 있어요.\u003c/p\u003e\n\u003ch1\u003e목차\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e설정하기\n∘ 프로젝트 부트스트랩\n∘ Commander.js 가져오기\n∘ CLI 만들기\u003c/li\u003e\n\u003cli\u003e유저 경험\n∘ 색상 추가하기\n∘ 쉬운 프롬프팅\n∘ 멋진 로더\n∘ ASCII 아트 추가하기\u003c/li\u003e\n\u003cli\u003e프로젝트 구조\u003c/li\u003e\n\u003cli\u003e문서화\n∘ 자동 문서 생성\u003c/li\u003e\n\u003cli\u003e최선의 실천법\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e설정하기\u003c/h1\u003e\n\u003cp\u003e먼저 컴퓨터에 Node.js가 설치되어 있는지 확인해주세요.\u003c/p\u003e\n\u003ch2\u003e단계 1: 프로젝트 시작하기\u003c/h2\u003e\n\u003cp\u003e프로젝트를 위한 새 폴더를 만들고 그 안으로 들어가세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emkdir my-node-cli\ncd my-node-cli\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새 Node.js 프로젝트를 시작해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm init\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e단계 2: Commander.js 가져오기\u003c/h2\u003e\n\u003cp\u003eCommander.js은 Node.js에서 CLI를 구축하는 데 사용하는 핵심 도구입니다. 입력 구문 분석, 도움말 텍스트 및 오류 관리를 위한 스위스 아미 나이프가 있는 것과 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install commander\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e단계 3: CLI 만들기\u003c/h2\u003e\n\u003cp\u003e프로젝트 폴더에 index.js라는 파일을 만듭니다. 이것이 우리의 CLI가 시작하는 곳이 될 것입니다. 이 CLI를 실행하기 위해 맨 위에 shebang을 추가하십시오.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-md\"\u003e\u003cspan class=\"hljs-section\"\u003e#!/usr/bin/env node\u003c/span\u003e\n\nimport { program } from \"commander\";\n\nprogram\n  .version(\"1.0.0\")\n  .description(\"내 노드 CLI\")\n  .option(\"-n, --name \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003etype\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\", \"당신의 이름을 추가하세요\")\n  .action((options) =\u003e {\n\u003cspan class=\"hljs-code\"\u003e    console.log(`안녕, ${options.name}!`);\n  });\n\u003c/span\u003e\nprogram.parse(process.argv);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e패키지.json에 bin을 추가하여 CLI 명령을 인식하도록하고 CommonJS 대신 ES 모듈과 함께 작동하도록 유형을 추가하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"bin\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"my-node-cli\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"./index.js\"\u003c/span\u003e\n},\n\u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"module\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e프로젝트를 전역적으로 연결하려면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003enpm \u003cspan class=\"hljs-built_in\"\u003elink\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm link \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러면, 내 my-node-cli가 당신의 터미널에서 실행될 준비가 끝납니다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emy-node-cli --name \u003cspan class=\"hljs-title class_\"\u003eYourName\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e참고: Node.js 18.3부터는 내장된 커맨드 라인 인수 구문 분석기가 있습니다. 이것에 대해 읽어보고 commander.js 대신 사용할지 결정할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e사용자 경험\u003c/h1\u003e\n\u003ch2\u003e색상 추가하기\u003c/h2\u003e\n\u003cp\u003eChalk는 CLI 출력을 다채롭게 만드는 데 완벽합니다. 다음 명령을 사용하여 가져올 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install chalk\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 우리의 인사말을 개선해 보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-meta\"\u003e#!/usr/bin/env node\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { program } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"commander\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e chalk \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"chalk\"\u003c/span\u003e;\n\nprogram\n  .\u003cspan class=\"hljs-title function_\"\u003eversion\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"1.0.0\"\u003c/span\u003e)\n  .\u003cspan class=\"hljs-title function_\"\u003edescription\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"내 Node CLI\"\u003c/span\u003e)\n  .\u003cspan class=\"hljs-title function_\"\u003eoption\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"-n, --name \u0026#x3C;type\u003e\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"당신의 이름을 추가하세요\"\u003c/span\u003e)\n  .\u003cspan class=\"hljs-title function_\"\u003eaction\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eoptions\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(chalk.\u003cspan class=\"hljs-title function_\"\u003eblue\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`안녕, \u003cspan class=\"hljs-subst\"\u003e${options.name}\u003c/span\u003e!`\u003c/span\u003e));\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(chalk.\u003cspan class=\"hljs-title function_\"\u003egreen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`안녕, \u003cspan class=\"hljs-subst\"\u003e${options.name}\u003c/span\u003e!`\u003c/span\u003e));\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(chalk.\u003cspan class=\"hljs-title function_\"\u003ered\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`안녕, \u003cspan class=\"hljs-subst\"\u003e${options.name}\u003c/span\u003e!`\u003c/span\u003e));\n  });\n\nprogram.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(process.\u003cspan class=\"hljs-property\"\u003eargv\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e손쉬운 프롬프팅\u003c/h2\u003e\n\u003cp\u003e더욱 상호작용적인 느낌을 원하신다면 Inquirer.js가 좋은 선택입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install inquirer\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e데이터를 수집하기 위해 명령줄 옵션을 사용하는 대신, 사용자에게 질문하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-meta\"\u003e#!/usr/bin/env node\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { program } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"commander\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e chalk \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"chalk\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e inquirer \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"inquirer\"\u003c/span\u003e;\n\nprogram.\u003cspan class=\"hljs-title function_\"\u003eversion\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"1.0.0\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003edescription\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"나의 Node CLI\"\u003c/span\u003e);\n\nprogram.\u003cspan class=\"hljs-title function_\"\u003eaction\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  inquirer\n    .\u003cspan class=\"hljs-title function_\"\u003eprompt\u003c/span\u003e([\n      {\n        \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"input\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"당신의 이름은 무엇인가요?\"\u003c/span\u003e,\n      },\n    ])\n    .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eanswers\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(chalk.\u003cspan class=\"hljs-title function_\"\u003egreen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`안녕하세요, \u003cspan class=\"hljs-subst\"\u003e${answers.name}\u003c/span\u003e님!`\u003c/span\u003e));\n    });\n});\n\nprogram.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(process.\u003cspan class=\"hljs-property\"\u003eargv\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_3.png\" alt=\"Building a CLI App with Node.js\"\u003e\u003c/p\u003e\n\u003cp\u003e사용 가능한 Confirm 프롬프트 유형이 있습니다. 사용자에게 예/아니오 질문을 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_4.png\" alt=\"Building a CLI App with Node.js\"\u003e\u003c/p\u003e\n\u003cp\u003e프롬프트 유형 — 사용자가 옵션 목록에서 선택할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e또한 체크박스, 비밀번호, 목록 및 확장 기능도 있습니다. \u003ca href=\"https://github.com/SBoudrias/Inquirer.js%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/SBoudrias/Inquirer.js에서\u003c/a\u003e 더 많이 알아보세요.\u003c/p\u003e\n\u003ch2\u003e멋진 로더들\u003c/h2\u003e\n\u003cp\u003e로딩 시간을 어떻게 보내시나요? ora를 사용하면 재미있게 만들 수 있어요. 스피너 애니메이션을 추가하는 데 좋아요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install ora\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e시간이 걸리는 프로세스에 로더를 뿌려보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-meta\"\u003e#!/usr/bin/env node\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { program } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"commander\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e chalk \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"chalk\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e inquirer \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"inquirer\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ora \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ora\"\u003c/span\u003e;\n\nprogram.\u003cspan class=\"hljs-title function_\"\u003eversion\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"1.0.0\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003edescription\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"My Node CLI\"\u003c/span\u003e);\n\nprogram.\u003cspan class=\"hljs-title function_\"\u003eaction\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  inquirer\n    .\u003cspan class=\"hljs-title function_\"\u003eprompt\u003c/span\u003e([\n      {\n        \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"list\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"choice\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"옵션을 선택하세요:\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003echoices\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"옵션 1\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"옵션 2\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"옵션 3\"\u003c/span\u003e],\n      },\n    ])\n    .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresult\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e spinner = \u003cspan class=\"hljs-title function_\"\u003eora\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${result.choice}\u003c/span\u003e 작업 중...`\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 스피너 시작\u003c/span\u003e\n\n      \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n        spinner.\u003cspan class=\"hljs-title function_\"\u003esucceed\u003c/span\u003e(chalk.\u003cspan class=\"hljs-title function_\"\u003egreen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"완료!\"\u003c/span\u003e));\n      }, \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e);\n    });\n});\n\nprogram.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(process.\u003cspan class=\"hljs-property\"\u003eargv\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eASCII Art 추가\u003c/h2\u003e\n\u003cp\u003efiglet.js로 마지막 손질을 해봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install figlet\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eindex.js에 다음을 추가해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e figlet \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"figlet\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\n  chalk.\u003cspan class=\"hljs-title function_\"\u003eyellow\u003c/span\u003e(figlet.\u003cspan class=\"hljs-title function_\"\u003etextSync\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"My Node CLI\"\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003ehorizontalLayout\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"full\"\u003c/span\u003e }))\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCLI의 aesthetic에 맞게 ASCII 아트를 맞춤화할 수 있는 다양한 글꼴 및 사용자 정의 옵션이 있습니다.\u003c/p\u003e\n\u003ch1\u003e프로젝트 구조\u003c/h1\u003e\n\u003cp\u003e프로젝트를 깔끔하게 유지하면 나중에 시간을 아낄 수 있어요, 특히 프로젝트가 커지면 더욱 그렇습니다. 다음은 시작하기에 좋은 간단하면서도 효과적인 구조입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emy-node-cli/\n├─ bin/\n│ └─ index.\u003cspan class=\"hljs-property\"\u003ejs\u003c/span\u003e\n├─ src/\n│ ├─ commands/\n│ ├─ utils/\n│ └─ lib/\n├─ package.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e\n└─ \u003cspan class=\"hljs-variable constant_\"\u003eREADME\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emd\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003ebin — 여러분의 CLI가 있는 곳입니다. 누군가가 CLI를 실행할 때 호출되는 곳입니다.\u003c/li\u003e\n\u003cli\u003esrc/commands — 개별 명령어 파일이 있는 위치입니다. 새로운 명령어를 추가하거나 기존 명령어를 편집할 때 더 깔끔하게 작업할 수 있습니다.\u003c/li\u003e\n\u003cli\u003esrc/utils — 여러 명령어에서 필요한 유틸리티 함수를 담고 있습니다. 데이터 형식 설정과 같은 기능이 포함될 수 있습니다.\u003c/li\u003e\n\u003cli\u003esrc/lib — 여러분의 CLI가 API와 상호 작용하거나 복잡한 로직을 실행하는 경우 주요 기능이 위치할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e문서화\u003c/h1\u003e\n\u003cp\u003e명확한 문서화가 중요합니다. 사용자를 명령줄 도구를 통해 직접 놀라운 작업을 수행할 수 있도록 설치, 사용법 및 명령 옵션을 README.md에 개요로 기록하십시오.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 내 노드 \u003cspan class=\"hljs-variable constant_\"\u003eCLI\u003c/span\u003e\n내 노드 \u003cspan class=\"hljs-variable constant_\"\u003eCLI\u003c/span\u003e는 터미널에서 직접 멋진 작업을 수행할 수 있는 도구입니다.\n\n## 설치\n\n\u003cspan class=\"hljs-string\"\u003e``\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e`bash\nnpm install -g my-node-cli\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e사용법\u003c/h2\u003e\n\u003cp\u003e내 노드 CLI를 사용하려면 다음을 실행하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003emy-node-cli - \u003cspan class=\"hljs-built_in\"\u003ehelp\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e명령어\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emy-node-cli - name YourName\u003c/code\u003e: 당신의 이름으로 인사합니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emy-node-cli option1\u003c/code\u003e: 옵션 1을 실행합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e더 자세한 명령어 정보는 \u003ccode\u003emy-node-cli --help\u003c/code\u003e를 실행해 주세요.\u003c/p\u003e\n\u003ch2\u003e기여하기\u003c/h2\u003e\n\u003cp\u003e기여는 환영합니다...\u003c/p\u003e\n\u003ch2\u003e라이선스\u003c/h2\u003e\n\u003cp\u003e이 프로젝트는 라이선스가 부여되었습니다...\u003c/p\u003e\n\u003ch2\u003e문서 자동 생성하기\u003c/h2\u003e\n\u003cp\u003e테이블 태그를 마크다운 형식으로 변경하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/**\n * 이 함수는 사용자의 이름으로 인사합니다.\n * \u003cspan class=\"hljs-doctag\"\u003e@param\u003c/span\u003e {\u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e} name 사용자의 이름\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003ename\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`안녕, \u003cspan class=\"hljs-subst\"\u003e${name}\u003c/span\u003e!`\u003c/span\u003e);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eBest Practices\u003c/h1\u003e\n\u003cp\u003e실제 CLI 논리 작업을 시작하기 전에 Liran Tal의 이 리포를 확인하는 것을 강력히 권장합니다. 이 리포는 3천 개 이상의 스타를 받았으며 제가 생각한 모든 최상의 실천 방법과 그 이상을 다룹니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 사용자가 호출할 때 동일한 정보를 반복해서 제공하는 것을 요구하지 않고, 상태를 유지하면서 사용자 경험을 제공할 수 있습니다. conf를 사용하여 사용자 이름, 이메일 또는 API 토큰과 같은 데이터를 저장할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-BuildingaCLIAppwithNodejsin2024_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 모든 것이 실제로 작동하는 것을 보고 싶나요? 모든 예시 파일과 함께 완성된 프로젝트를 제 GitHub 페이지에서 확인해보세요. 들어가서 둘러보고, 자유롭게 실험해보세요. 만약 도움이 된다면 리포지토리를 fork하거나 스타를 눌러주세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-BuildingaCLIAppwithNodejsin2024"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>