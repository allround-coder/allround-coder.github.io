<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>React TypeScript로 npm 패키지 생성하고 배포하는 방법 데모 및 자동 빌드 포함 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="React TypeScript로 npm 패키지 생성하고 배포하는 방법 데모 및 자동 빌드 포함 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="React TypeScript로 npm 패키지 생성하고 배포하는 방법 데모 및 자동 빌드 포함 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild" data-gatsby-head="true"/><meta name="twitter:title" content="React TypeScript로 npm 패키지 생성하고 배포하는 방법 데모 및 자동 빌드 포함 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 22:36" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_buildManifest.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">React TypeScript로 npm 패키지 생성하고 배포하는 방법 데모 및 자동 빌드 포함</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="React TypeScript로 npm 패키지 생성하고 배포하는 방법 데모 및 자동 빌드 포함" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">17<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><h2>제로부터 놀라운 프로젝트를 만드는 법을 배워보세요</h2>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_0.png" alt="이미지"/></p>
<h1>소개</h1>
<p>npm 패키지를 발행하는 데 대해 더 많은 기사를 쓰기로 결정한 이유는 무엇일까요? 제가 스스로 이러한 패키지를 만들어야 할 때, 인터넷의 대부분의 지침이 오래되었거나 제품 제작에 거의 도움이 되지 않는 매우 짧았기 때문입니다.</p>
<p>모든 단계를 가능한 명확하게 설명하고자 노력하겠습니다. 그래서 여러분도 처음부터 직접 프로젝트를 만들어보실 수 있을 거에요. 시작해 봐요!</p>
<p>간단한 React 애플리케이션을 만드는 것을 제안합니다. 두 개의 버튼으로 이루어진 카운터 값을 증가시키거나 감소시키는 애플리케이션입니다.</p>
<p>우리 애플리케이션은 이렇게 생겼을 거에요:</p>
<p>데모: <a href="https://gapon2401.github.io/my-react-typescript-package/">링크</a>
저장소: <a href="https://github.com/gapon2401/my-react-typescript-package">링크</a></p>
<p>우리는 모든 것을 다루는 14단계가 있어요:</p>
<ul>
<li>프로젝트 준비하기</li>
<li>React 애플리케이션 만들기</li>
<li>Git 구성하기</li>
<li>ESLint 구성하기</li>
<li>Prettier 구성하기</li>
<li>Jest로 테스트 추가하기</li>
<li>package.json 구성하고 발행 준비하기</li>
<li>코드를 커밋하고 푸시하기</li>
<li>NPM에 발행하기</li>
<li>예제 폴더 생성하기</li>
<li>자동 빌드 설정하기</li>
<li>데모 페이지</li>
<li>README.md 파일과 shields.io</li>
<li>릴리스 만들기</li>
</ul>
<h1>단계 1. 프로젝트 준비</h1>
<ul>
<li>프로젝트의 명령줄에서 다음을 실행하세요:</li>
</ul>
<pre><code class="hljs language-js">npm init -y
</code></pre>
<p>이 명령어를 실행하면 기본 값으로 package.json 파일이 생성되고, 나중에 필요에 따라 수정할 수 있습니다.</p>
<ul>
<li>src 폴더를 생성하세요.</li>
</ul>
<p>이 폴더에 모든 프로젝트 파일을 보관할 예정입니다.</p>
<p>프로젝트에 React와 TypeScript를 추가해 보겠어요 (만약 상관 없다면 yarn을 사용할 거에요)</p>
<pre><code class="hljs language-js">yarn add -D react react-dom typescript @types/react
</code></pre>
<p>이제 node_modules 폴더와 yarn.lock 파일이 생성되었어요 — 꽤 좋죠!</p>
<ul>
<li>TypeScript를 컴파일하기 위해 프로젝트 루트에 다음 내용을 가진 tsconfig.json 파일을 생성하세요:</li>
</ul>
<p>위의 내용을 참조하시면 가능한 모든 속성을 확인할 수 있어요: https://www.typescriptlang.org/tsconfig</p>
<p>주요 내용:</p>
<ul>
<li>
<p>rootDir — 소스 파일 내에서의 루트 폴더</p>
</li>
<li>
<p>include— TypeScript 프로젝트에 포함될 파일을 지정</p>
</li>
<li>
<p>exclude — TypeScript 프로젝트에서 제외할 파일을 지정합니다. dist 폴더와 모든 node_modules를 포함하고 싶지 않습니다.</p>
</li>
<li>
<p>outDir — 이것은 컴파일된 출력물의 위치입니다.</p>
</li>
<li>
<p>빈 README.md 및 LICENSE 파일을 생성합니다.</p>
</li>
</ul>
<p>어떤 라이센스를 사용할지는 당신에게 달려있습니다. 저는 MIT를 사용할 것입니다. 해당 파일의 내용을 확인할 수 있습니다.</p>
<p>위에 있는 내용을 마크다운 형식으로 바꿔보세요:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_1.png" alt="structure"/></p>
<h2>단계 2. React 애플리케이션 만들기</h2>
<p>src 폴더 안에 components 폴더를 만들어주세요. 여기에 프로젝트의 모든 컴포넌트를 보관할 수 있습니다. 이 글에서는 여기에 App.tsx라는 파일 하나만 만들어보겠습니다. 파일에는 아래 내용을 넣어주세요:</p>
<p>저희의 React 애플리케이션이에요.</p>
<p>이제 src 폴더 안에 index.ts 파일을 만들어주세요. 모듈을 내보내세요.</p>
<p>프로젝트를 컴파일할 시간이에요!</p>
<p>package.json을 열어서 scripts 섹션을 변경해봐요:</p>
<p>터미널에서 다음 명령을 실행하세요:</p>
<pre><code class="hljs language-js">yarn build
</code></pre>
<p>모든 컴파일된 코드와 함께 dist 폴더가 나타날 것입니다.</p>
<p>축하합니다! 컴파일된 애플리케이션을 생성했습니다. 조금 더 나가야 할 과정이 남았습니다! (아마도.)</p>
<p>위에서 언급한 단계 2 이후의 프로젝트 구조를 비교해보세요:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_2.png" alt="프로젝트 구조"/></p>
<h2>단계 3. git 설정하기</h2>
<p>프로젝트를 빠르게 만들었으니 이제 git을 설정할 시간입니다.</p>
<p>프로젝트 루트에서 다음 명령어로 git을 초기화하세요:</p>
<pre><code class="hljs language-js">git init
</code></pre>
<p>프로젝트 루트에 다음 내용을 가진 .gitignore 파일을 생성하세요:</p>
<pre><code class="hljs language-js">node_modules
.<span class="hljs-property">idea</span>
dist
yarn-error.<span class="hljs-property">log</span>
</code></pre>
<p>Jetbrains IDE를 사용하여 개발을 도와주기 때문에 .idea를 추가했어요.</p>
<p>.gitignore 파일에는 리포지토리에 포함하고 싶지 않은 파일과 디렉터리를 나열합니다.</p>
<p>GitHub에서 git repo를 만드세요. 나중에 초기 커밋을 만들고 원격 git을 로컬 git에 연결할 거에요.</p>
<h1>단계 4. ESLint 구성</h1>
<p>ESLint은 코드를 정적으로 분석하여 빠르게 문제를 찾아줍니다. 우리는 개발 시에만 필요합니다.</p>
<p>다음 코드로 eslint와 모든 필요한 구성 요소를 추가해주세요:</p>
<pre><code class="hljs language-js">yarn add -D eslint eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser
</code></pre>
<p>원하는 대로 구성할 수 있으며, 자세한 사용자 가이드는 여기에 있어요: https://eslint.org/docs/user-guide/configuring/</p>
<p>프로젝트의 루트에 .eslintrc 파일을 만드는 것을 제안합니다:</p>
<p>.eslintignore 파일을 추가하세요:</p>
<pre><code class="hljs language-js">node_modules
dist
</code></pre>
<p>우리는 컴파일된 파일이 위치한 dist 폴더와 node_modules를 체크하지 않도록 무시할 것입니다.</p>
<p>테이블 태그를 마크다운 형식으로 변경해 주세요.</p>
<pre><code class="hljs language-js">yarn lint
</code></pre>
<p>에러가 없어야 해요.</p>
<p>스텝 4 이후 프로젝트 구조를 비교해보세요:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_3.png" alt="프로젝트 구조 비교"/></p>
<h1>단계 5. Prettier 구성</h1>
<p>Prettier는 코드 포매터입니다. 팀으로 작업할 때 사용하면 모두의 코드가 동일한 표준을 준수하게 됩니다.</p>
<p>터미널에서 다음 명령을 실행해주세요:</p>
<pre><code class="hljs language-js">yarn add -D eslint-config-prettier eslint-plugin-prettier prettier
</code></pre>
<p>프로젝트 루트에서 .prettierrc.json 파일을 만들어주세요:</p>
<p>모든 옵션에 대해 더 알아보려면 여기를 확인해주세요: https://prettier.io/docs/en/options.html.</p>
<p>.eslintrc에 prettier 플러그인을 추가해주세요:</p>
<p>prettier 설정이 완료되었습니다! 이제 yarn lint를 실행하여 포맷 에러를 확인해보세요. 에러가 없다면, 인간인지 확인해보세요 😆.</p>
<img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_4.png"/>
<p>이제 그것들을 수정해 봅시다! package.json에 다음을 추가하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;prettier&quot;</span>: <span class="hljs-string">&quot;prettier --write \&quot;{src,tests,example/src}/**/*.{js,ts,jsx,tsx}\&quot;&quot;</span>
</code></pre>
<p>좋아요, yarn prettier를 실행하면 다음과 유사한 결과를 얻을 수 있습니다:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_5.png" alt="이미지"/></p>
<p>이제 yarn lint를 실행한 후에는 오류가 없어야 합니다. src/components/App.tsx 및 src/index.ts 파일을 확인해보세요. 변경되었습니다.</p>
<p>package.json의 scripts 섹션:</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;scripts&quot;</span>: {
  <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;tsc&quot;</span>,
  <span class="hljs-string">&quot;lint&quot;</span>: <span class="hljs-string">&quot;eslint \&quot;{**/*,*}.{js,ts,jsx,tsx}\&quot;&quot;</span>,
  <span class="hljs-string">&quot;prettier&quot;</span>: <span class="hljs-string">&quot;prettier --write \&quot;{src,tests,example/src}/**/*.{js,ts,jsx,tsx}\&quot;&quot;</span>
}
</code></pre>
<p>Step 5 이후 프로젝트 구조를 비교해보세요:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_6.png" alt="프로젝트 구조"/></p>
<h2>단계 6. Jest를 사용한 테스트 추가</h2>
<p>테스트를 만들기 위해 저는 Jest 라이브러리를 사용하고 있어요. Jest는 꽤 유용하고 강력한 테스트 프레임워크에요. 얼마나 어려운 테스트를 작성할지는 당신에게 달렸어요.</p>
<p>프로젝트에 jest를 추가해주세요:</p>
<pre><code class="hljs language-js">yarn add -D jest jest-canvas-mock jest-environment-jsdom ts-jest @types/jest @testing-library/react
</code></pre>
<p>프로젝트 루트 파일 jestconfig.json을 생성해주세요.</p>
<p>폴더 tests를 만들어주세요.</p>
<p>첫 번째 테스트를 작성하는 시간입니다. 우리는 매우 간단한 테스트를 작성할 것인데, 렌더링이 성공적으로 이루어졌는지 확인할 것입니다.</p>
<p>tests 폴더 안에 common.test.tsx 파일을 만들어주세요.</p>
<p>package.json 파일의 scripts 섹션을 변경해주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;jest --config jestconfig.json&quot;</span>
</code></pre>
<p>yarn test 명령을 실행해보세요. 테스트가 통과해야 합니다:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_7.png" alt="프로젝트 구조 비교 후 이미지"/></p>
<p>스텝 6 이후의 프로젝트 구조를 비교해보세요:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_8.png" alt="스텝 6 이후 프로젝트 구조 이미지"/></p>
<h1>단계 7. package.json 구성 및 발행 준비</h1>
<p>저는 빌드를 분리하는 것을 제안합니다. 우리는 패키지를 가능한 한 접근하기 쉽게 만들기 위해 ECMAScript 모듈뿐만 아니라 CommonJs 모듈도 컴파일할 것입니다.</p>
<p>package.json 파일에서 다음을 대체하세요:</p>
<pre><code class="hljs language-json"><span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tsc&quot;</span><span class="hljs-punctuation">,</span>
</code></pre>
<p>다음 코드를 사용하여</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;yarn build:esm &amp;&amp; yarn build:cjs&quot;</span>,
<span class="hljs-string">&quot;build:esm&quot;</span>: <span class="hljs-string">&quot;tsc&quot;</span>,
<span class="hljs-string">&quot;build:cjs&quot;</span>: <span class="hljs-string">&quot;tsc --module commonjs --outDir dist/cjs&quot;</span>,
</code></pre>
<p>build<div></div>과 build<div></div>를 추가하고 이를 하나의 명령어로 결합했습니다.</p>
<p>yarn build를 실행하면, 이제 dist/ 폴더에 cjs 폴더가 생성된 것을 확인할 수 있습니다.</p>
<p>더 나아가보세요.</p>
<p>package.json 파일에서는 패키지가 게시될 때 자동으로 호출되는 매직 스크립트를 사용할 수 있습니다. 이러한 스크립트를 사용하면 패키지를 모든 종류의 오류로부터 확인하고 실수로 업데이트를 업로드하여 패키지가 사용되는 수백 만 프로젝트를 충돌시키지 않도록 도와줍니다!</p>
<ul>
<li>prepare — 패키지가 패킹되고 게시되기 전에 실행됩니다. 인수 없이 로컬 npm install에서 실행됩니다.</li>
<li>prepublishOnly — 패키지가 준비되고 패킹되기 전에 실행됩니다. npm publish에서만 실행됩니다. 여기에는 테스트가 들어갑니다.</li>
</ul>
<p>다음을 스크립트 섹션에 추가하세요:</p>
<pre><code class="hljs language-json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;prepare&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm run build&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;prepublishOnly&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;npm test &amp;&amp; npm run prettier &amp;&amp; npm run lint&quot;</span>
<span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
<span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dist/index.js&quot;</span><span class="hljs-punctuation">,</span>
<span class="hljs-attr">&quot;types&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;dist/index.d.ts&quot;</span>
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;index.js&quot;</span>,
</code></pre>
<p>다음과 같이 변경해주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;./dist/cjs/index.js&quot;</span>,
<span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;./dist/esm/index.js&quot;</span>,
<span class="hljs-string">&quot;types&quot;</span>: <span class="hljs-string">&quot;./dist/esm/index.d.ts&quot;</span>,
</code></pre>
<p>원격 Git 저장소에 대한 정보를 추가해주세요 (단계 3에서 제공한 Git URL을 명시해주세요):</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;repository&quot;</span>: {
  <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;git&quot;</span>,
  <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;git+https://github.com/gapon2401/my-react-typescript-package.git&quot;</span>
},
</code></pre>
<p>우리 패키지를 사용할 프로젝트는 적어도 <code>=16</code> 버전 이상의 리액트 버전을 가져야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;peerDependencies&quot;</span>: {
  <span class="hljs-string">&quot;react&quot;</span>: <span class="hljs-string">&quot;&gt;=16&quot;</span>
},
</code></pre>
<p>패키지가 불필요한 파일이 없도록하려면, 허용된 파일 및 폴더만 사용하여 패키지에 추가하십시오:</p>
<pre><code>


```js
&quot;files&quot;: [
  &quot;dist&quot;,
  &quot;LICENSE&quot;,
  &quot;README.md&quot;
],
</code></pre>
<p>프로젝트를 찾을 수 있도록 키워드를 추가해주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;keywords&quot;</span>: [
  <span class="hljs-string">&quot;react&quot;</span>,
  <span class="hljs-string">&quot;typescript&quot;</span>,
  <span class="hljs-string">&quot;awesome-project&quot;</span>
],
</code></pre>
<p>라이선스를 명시해주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;license&quot;</span>: <span class="hljs-string">&quot;MIT&quot;</span>,
</code></pre>
<p>저자 이름 변경하는거 잊지 마세요:</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;author&quot;</span>: <span class="hljs-string">&quot;Igor Gaponov (gapon2401)&quot;</span>,
</code></pre>
<p>그게 충분한 것 같아요.</p>
<p>README.md 파일에 설명을 추가해주세요.</p>
<p>현재 README 파일에는 한 줄만 있습니다. 이것이 h1 입니다:</p>
<pre><code class="hljs language-js"># my-react-typescript-package
</code></pre>
<p>package.json 파일의 최종 버전을 확인해보세요.</p>
<h1>단계 8. 코드를 커밋하고 푸시하세요</h1>
<p>우선, 원격 및 로컬 저장소를 연결하고 프로젝트를 푸시해 봅시다.</p>
<p>다음 코드를 실행해 주세요:</p>
<pre><code class="hljs language-js">git add .
git commit -m <span class="hljs-string">&quot;Initial commit&quot;</span>
git remote add origin &lt;저장소 <span class="hljs-variable constant_">URL</span>&gt;
git push -u origin master
</code></pre>
<p>본인의 <code>Repository Url</code>을 변경하는 것을 잊지 마세요. 이는 https URL이거나 ssh 일 수 있습니다. 이 URL은 레포지토리에서 얻을 수 있습니다.</p>
<p>다음과 같은 예시를 살펴보세요.</p>
<ul>
<li>HTTPS 레포지토리 URL (인증이 필요합니다)</li>
</ul>
<pre><code class="hljs language-js">git remote add origin <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/gapon2401/my-react-typescript-package.git</span>
</code></pre>
<ul>
<li>SSH 저장소 URL (SSH 연결 구성 필요)</li>
</ul>
<pre><code class="hljs language-js">git remote add origin git@github.<span class="hljs-property">com</span>:gapon2401/my-react-typescript-package.<span class="hljs-property">git</span>
</code></pre>
<p>저는 두 번째 해결책을 사용했어요.</p>
<h1>단계 9. NPM에 발행</h1>
<ul>
<li>패키지 이름 선택하기</li>
</ul>
<p>우리 패키지의 이름을 사용할 수 있는지 확인해야 합니다. https://www.npmjs.com/ 웹사이트로 이동하여 검색 도구를 사용해보세요.</p>
<p>package.json 파일에서 프로젝트의 기본 이름을 찾아 변경할 수 있습니다:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_9.png" alt="이미지"/></p>
<p>나의 경우에는 my-react-typescript-package 이 있습니다. 아직 그런 패키지는 없네요.</p>
<p>다음과 같이 링크에 이름을 직접 삽입하여 확인하는 것이 더 좋다고 생각해요:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">https</span>:<span class="hljs-comment">//www.npmjs.com/package/&lt;당신의 패키지 이름&gt;</span>
</code></pre>
<p><code>당신의 패키지 이름</code> 자리에 프로젝트의 이름을 넣어주세요.</p>
<p>다음 URL을 받았어요:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">https</span>:<span class="hljs-comment">//www.npmjs.com/package/my-react-typescript-package</span>
</code></pre>
<p>만약 이름이 무료하면 404 페이지가 표시됩니다:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_10.png" alt="이미지"/></p>
<ul>
<li>NPM에 등록/로그인하기</li>
</ul>
<p>프로젝트를 게시하려면 https://www.npmjs.com/에서 인증해야 합니다.</p>
<p>아직 계정이 없다면 https://www.npmjs.com/signup에서 등록하거나 명령줄을 사용해 주세요:</p>
<pre><code class="hljs language-js">npm adduser
</code></pre>
<p>사용자 이름, 비밀번호 및 이메일을 입력하라는 메시지가 표시됩니다.</p>
<p>이미 계정이 있는 경우에는 다음을 실행하세요:</p>
<pre><code class="hljs language-js">npm login
</code></pre>
<p>그리고 인증을 완료하세요.</p>
<ul>
<li>배포하기</li>
</ul>
<p>배포하기 전에 필요한 파일만 패키지에 포함되었는지, 오류가 없는지, 그리고 모든 것이 올바르게 포맷되어 있는지 확인하는 것을 추천합니다. 이를 위해 아래 명령어를 실행할 수 있습니다:</p>
<pre><code class="hljs language-js">npm publish --dry-run
</code></pre>
<p>패키지가 실제로 게시되지는 않을 거에요, 걱정 마세요.</p>
<p>&quot;매직 스크립트인 prepublishOnly가 호출되어 테스트 및 코드 형식 지정이 실행됨을 확인하게 될 거에요.</p>
<p>그런 다음 프로젝트에 포함된 모든 파일 목록을 볼 수 있게 되며:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_11.png" alt="이미지"/></p>
<p>Tarball 콘텐츠에는 package.json에서 지정된 파일 및 폴더가 포함되어 있습니다:&quot;</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;files&quot;</span>: [
   <span class="hljs-string">&quot;dist&quot;</span>,
   <span class="hljs-string">&quot;LICENSE&quot;</span>,
   <span class="hljs-string">&quot;README.md&quot;</span>
 ],
</code></pre>
<p>모든 준비가 끝났어요! 이제 패키지를 게시하면 돼요!</p>
<p>다음 명령어를 실행해 주세요:</p>
<pre><code class="hljs language-js">npm publish
</code></pre>
<p>이 명령을 실행할 때마다 항상 걱정이 돼요.</p>
<p>명령 호출의 전체 결과를 첨부합니다:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_12.png" alt="Command Result"/></p>
<p>이제 축하해요! 패키지가 발행되었어요. 공개되었고, 누구든 사용할 수 있어요! 생각보다 어렵지 않았죠.</p>
<p>NPM에서 해당 패키지를 확인해보세요.</p>
<p>이전에 열었던 링크를 열어보세요.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">https</span>:<span class="hljs-comment">//www.npmjs.com/package/&lt;당신의 패키지 이름&gt;</span>
</code></pre>
<img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_13.png"/>
<p>잘 보이네요!</p>
<h1>단계 10. 예제 폴더 만들기</h1>
<p>우리 패키지를 계속 발전시키는 재미를 느껴봐요. 이번 단계에서는 패키지를 어떻게 활용할 수 있는지 보여줄 예제 폴더를 만들 것입니다. 이 폴더에서는 서버를 빠르게 시작하고 코드를 테스트할 수 있어요.
애플리케이션을 빠르게 실행하려면 https://parceljs.org/를 사용할 거에요.</p>
<p><code>example</code>라는 폴더를 생성하세요.</p>
<p>해당 폴더 안에 비어 있는 src 폴더와 파일을 만들어주세요:</p>
<ul>
<li>.gitignore:</li>
</ul>
<pre><code class="hljs language-js">node_modules
yarn.<span class="hljs-property">lock</span>
.<span class="hljs-property">parcel</span>-cache
dist
yarn-error.<span class="hljs-property">log</span>
</code></pre>
<ul>
<li>
<p>package.json:</p>
</li>
<li>
<p>README.md:</p>
</li>
</ul>
<p>자, 지금 주의를 기울여봐! 프로젝트의 루트 디렉토리에서 명령줄을 열고 예제 폴더로 이동해봐:</p>
<pre><code class="hljs language-js">cd example
</code></pre>
<p>그리고 실행해봐:</p>
<pre><code class="hljs language-js">yarn add -D parcel my-react-typescript-package react react-dom @types/react-dom @types/react
</code></pre>
<p>src 폴더 안에 index.html 파일을 만듭니다.</p>
<p>이제, 우리 패키지를 가져와서 사용하는 예제를 작성해야 합니다.</p>
<p>src 폴더 안에 index.tsx 파일을 만듭니다.</p>
<p>서버를 실행할 시간입니다! 아래 명령어를 사용해주세요:</p>
<pre><code class="hljs language-js">yarn start
</code></pre>
<p>서버가 성공적으로 실행되면 다음 메시지가 표시됩니다:</p>
<img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_14.png"/>
<p>아래의 예시를 확인하려면 http://localhost:1234 링크를 열어보세요:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_15.png" alt="예시 이미지"/></p>
<p>모든 설치와 서버 실행 후의 예시 폴더 구조를 비교해보세요. 아래와 같은 모양이어야 합니다:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_16.png" alt="예시 이미지"/></p>
<h1>단계 11. 자동 빌드 설정하기</h1>
<p>자동 빌드에 대해 이야기해보겠습니다. 변경 사항을 git에 푸시하고 각 릴리스마다 npm에 푸시해야 하는 것은 꽤 불편합니다. 이 프로세스를 GitHub Actions로 자동화할 것입니다.</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_17.png" alt="이미지"/></p>
<p>프로젝트 구조의 루트에 .github라는 폴더를 생성해주세요.</p>
<p>안녕하세요! 친절한 안내드립니다.</p>
<p>Markdown 형식으로 테이블 태그를 변경하고,</p>
<p>폴더 workflows를 만드세요.</p>
<p>그 안에 파일 publish.yml을 만드세요:</p>
<p>파일 안에는 중요한 포인트들이 주석처리되어 있습니다.</p>
<p>GitHub에 릴리스할 때 우리의 패키지가 자동으로 빌드되어 NPM에 푸시됩니다.</p>
<p>다음 라인을 확인해 주세요:</p>
<pre><code class="hljs language-js"># 우리 <span class="hljs-variable constant_">NPM</span> 계정에 필요합니다
<span class="hljs-attr">NODE_AUTH_TOKEN</span>: ${ secrets.<span class="hljs-property">NPM_TOKEN</span> }
</code></pre>
<p>이 방법으로 GitHub를 NPM과 연결할 예정입니다.</p>
<p>브라우저에서 https://www.npmjs.com/ 에서 계정을 열고 토큰이 있는 페이지로 이동해 주세요:</p>
<p>아래는 Markdown 형식으로 변경된 내용입니다.</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_18.png" alt="이미지1"/></p>
<p>새 토큰을 생성하십시오:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_19.png" alt="이미지2"/></p>
<p>이름을 입력하고 유형을 선택하라는 메시지가 표시됩니다. Automation은 github-actions에 적합합니다.</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_20.png" alt="이미지"/></p>
<p>토큰을 복사하고 Github 레포지토리를 엽니다.</p>
<p>탭 설정으로 이동하여 Secrets — Actions를 엽니다. 새 저장소 시크릿 변수를 만듭니다. NPM_TOKEN이라는 이름을 주고 NPM에서 받은 토큰 값을 붙여넣습니다:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_21.png" alt="이미지"/></p>
<p>잘 했어요! 이제 프로젝트의 새 버전을 만들고 GitHub에 푸시하기만 남았어요.</p>
<p>어떤 변경 사항을 커밋하기 전에 다음 명령어를 실행하는 것을 잊지 마세요:</p>
<pre><code class="hljs language-js">yarn prepublishOnly
</code></pre>
<p>코드가 깔끔하게 유지될 수 있도록 확인하는 것이 좋아요.</p>
<p>프로젝트를 푸시한 후에 Actions 탭으로 이동하면 GitHub이 워크플로 액션을 감지했음을 알 수 있습니다. 그러나 아직 아무것도 시작되지 않았습니다. 왜냐하면 우리가 아직 릴리스를 만들지 않았기 때문입니다.)</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_22.png" alt="image"/></p>
<h1>단계 12. 데모 페이지</h1>
<p>이미 패키지를 사용하는 예제가 있는 폴더가 있지만, 전체 프로젝트를 클론하지 않고도 사용자가 빠르게 패키지 작업을 볼 수 있도록 서로 다른 페이지를 만들고 싶습니다. 이 페이지를 만들어 봅시다!</p>
<p>우리는 깃허브 페이지를 사용하여 데모를 만들 거에요.</p>
<p>새 깃 브랜치를 만들어보세요:</p>
<pre><code class="hljs language-js">git checkout -b gh-pages
</code></pre>
<p>이제 프로젝트에서 모든 파일을 지우세요!</p>
<p>이전 파일들은 모두 안전하게 다른 master 브랜치에 보관될 거니까 걱정하지 마세요. gh-pages 브랜치는 데모용으로만 사용될 거에요. 그래서 모든 파일을 삭제해야 해요. 자, 모두 삭제해주세요!</p>
<p>그런 다음 명령 줄에서 다음을 실행하세요:</p>
<pre><code class="hljs language-js">npm init -y
</code></pre>
<p>이 명령은 package.json 파일을 생성할 거에요. 이번에는 자세히 설정하지 않을 거에요.</p>
<p>데모 페이지에는 우리가 익숙한 Parcel을 사용하는 것을 제안합니다 (단계 10)</p>
<p>다음을 실행해보세요:</p>
<pre><code class="hljs language-js">yarn add -D parcel my-react-typescript-package react react-dom @types/react-dom @types/react typescript
</code></pre>
<p><code>.gitignore</code> 파일을 생성하세요:</p>
<pre><code class="hljs language-js">node_modules
yarn.<span class="hljs-property">lock</span>
.<span class="hljs-property">parcel</span>-cache
dist
yarn-error.<span class="hljs-property">log</span>
</code></pre>
<p>다음 내용을 포함한 파일 tsconfig.json을 생성하세요.</p>
<p>Eslint를 설정하는 단계 4를 따르세요.</p>
<p>빈 폴더 src를 생성하세요. 그 안에 다음 내용을 가진 파일 index.html을 생성하세요.</p>
<p>새로운 index.tsx 파일을 생성해주세요.</p>
<p>package.json 파일의 scripts 섹션에 아래 코드를 추가해주세요:</p>
<pre><code class="hljs language-json"><span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;parcel src/index.html&quot;</span><span class="hljs-punctuation">,</span>
<span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;parcel build src/index.html --dist-dir docs --public-url .&quot;</span>
</code></pre>
<p>제 package.json 파일을 확인해주세요.</p>
<p>서버를 실행하여 모든 것이 잘 작동하는지 확인하세요:</p>
<pre><code class="hljs language-js">yarn start 
</code></pre>
<p>이제 다음 명령어를 사용하여 오류를 확인하는 코드를 실행하세요:</p>
<pre><code class="hljs language-js">yarn lint
</code></pre>
<p>수정 사항 없습니다! 멋져요! 이제 페이지를 만들 차례에요.</p>
<pre><code class="hljs language-js">yarn build
</code></pre>
<p>데모 프로젝트의 모든 파일이 포함된 docs 폴더가 표시될 거예요.</p>
<p>다음은 브랜치 gh-pages의 구조입니다:</p>
<img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_23.png"/>
<p>이제 변경 사항을 모두 git에 푸시합시다. 다음을 실행하세요:</p>
<pre><code class="hljs language-js">git add .
git commit -m <span class="hljs-string">&quot;초기 페이지 커밋&quot;</span>
git push -u origin gh-pages
</code></pre>
<p>GitHub 저장소를 열어서 설정으로 이동하고 페이지로 이동합니다. 소스에서 /docs를 선택한 후 Save를 누릅니다:</p>
<img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_24.png"/>
<p>약 3-5분 정도 기다리시면 지정된 URL에 사이트가 이용 가능해집니다. 페이지에 표시된 URL을 확인해보세요.</p>
<img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_25.png"/>
<p>데모 페이지 작업이 끝났습니다. 보시다시피 사용자의 취향에 맞게 원하는 대로 커스터마이즈하고 어떠한 복잡도의 페이지나 웹사이트를 만들 수 있습니다.</p>
<p>여기 결과가 있어요: <a href="https://gapon2401.github.io/my-react-typescript-package/">https://gapon2401.github.io/my-react-typescript-package/</a></p>
<h1>단계 13. README.md 파일 및 shields.io</h1>
<p>이제 코드 작업이 끝났으니, 이제 패키지의 설명 파일로 전환해 볼게요.</p>
<p>git에서 master 브랜치로 전환하고 README.md 파일을 열어주세요.</p>
<p>테이블 태그를 마크다운 형식으로 변경해주세요:</p>
<p>For the description file, we are using markdown.</p>
<p>In README.md, I have added a short description of the package, link to demo-page, and a usage section.</p>
<p>At the beginning of the readme file, I have small cute icons. This is <a href="https://shields.io/">shields.io</a>. It is very convenient to have them. I’ve added just a couple as an example, you can use as many as you want.</p>
<p>GitHub 앱lications에 shields.io를 추가해보세요.</p>
<p>파일 끝을 살펴보세요; 이미지와 링크가 있는 변수를 만들었습니다. Markdown을 사용하면 이러한 변수를 만들 수 있기 때문에 설명 파일이 더 정확해집니다. 저장소 경로와 패키지 이름을 변경하는 것을 잊지 마세요.</p>
<p>package.json에서 버전을 변경하고, 커밋하고 파일을 레포지토리에 푸시하세요. 모든 작업은 스스로 진행해주세요. 이전 단계에 이미 수행했던 것과 같은 절차입니다.</p>
<h1>단계 14. 릴리스 만들기</h1>
<p>이것이 마지막 단계입니다. 짧을 거에요.</p>
<p>우리가 계획했던 모든 것을 완료했어요! 이제 공식 릴리스를 GitHub에 작성하고 자동 빌드가 어떻게 작동하는지 확인할 수 있어요.</p>
<p>저장소의 메인 페이지로 이동해서 &#x27;새 릴리스 생성&#x27;을 클릭하세요:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_26.png" alt="Create a new release"/></p>
<p>현재 버전을 지정하는 태그를 추가하세요. 릴리스 시 자동으로 생성됩니다. 릴리스 제목과 설명을 인쇄하고 릴리스를 발행하려면 클릭하십시오.</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_27.png" alt="이미지"/></p>
<p>이제 탭 &quot;Actions&quot;를 열고 빌드가 성공적으로 완료되었는지 확인하세요.</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_28.png" alt="이미지"/></p>
<p>패키지를 NPM에서 업데이트했는지 확인해 봐요.</p>
<p>패키지 링크를 열어 볼게요:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">https</span>:<span class="hljs-comment">//www.npmjs.com/package/&lt;패키지 이름&gt;</span>
</code></pre>
<p>제것을 열어 볼게요:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">https</span>:<span class="hljs-comment">//www.npmjs.com/package/my-react-typescript-package</span>
</code></pre>
<p>새 버전과 새 설명이 나와 있어요:</p>
<p><img src="/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_29.png" alt="이미지"/></p>
<p>긴 여정이었지만, 매우 유용하길 바랍니다. 처음 패키지를 게시할 때 어려웠던 모든 것을 설명하기 위해 노력했고, 이 정보들을 조각 조각 모았어요.</p>
<p>읽어 주셔서 감사합니다! ❤</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React TypeScript로 npm 패키지 생성하고 배포하는 방법 데모 및 자동 빌드 포함","description":"","date":"2024-05-12 22:36","slug":"2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild","content":"\n\n## 제로부터 놀라운 프로젝트를 만드는 법을 배워보세요\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_0.png)\n\n# 소개\n\nnpm 패키지를 발행하는 데 대해 더 많은 기사를 쓰기로 결정한 이유는 무엇일까요? 제가 스스로 이러한 패키지를 만들어야 할 때, 인터넷의 대부분의 지침이 오래되었거나 제품 제작에 거의 도움이 되지 않는 매우 짧았기 때문입니다.\n\n\n\n모든 단계를 가능한 명확하게 설명하고자 노력하겠습니다. 그래서 여러분도 처음부터 직접 프로젝트를 만들어보실 수 있을 거에요. 시작해 봐요!\n\n간단한 React 애플리케이션을 만드는 것을 제안합니다. 두 개의 버튼으로 이루어진 카운터 값을 증가시키거나 감소시키는 애플리케이션입니다.\n\n우리 애플리케이션은 이렇게 생겼을 거에요:\n\n데모: [링크](https://gapon2401.github.io/my-react-typescript-package/)\n저장소: [링크](https://github.com/gapon2401/my-react-typescript-package)\n\n\n\n우리는 모든 것을 다루는 14단계가 있어요:\n\n- 프로젝트 준비하기\n- React 애플리케이션 만들기\n- Git 구성하기\n- ESLint 구성하기\n- Prettier 구성하기\n- Jest로 테스트 추가하기\n- package.json 구성하고 발행 준비하기\n- 코드를 커밋하고 푸시하기\n- NPM에 발행하기\n- 예제 폴더 생성하기\n- 자동 빌드 설정하기\n- 데모 페이지\n- README.md 파일과 shields.io\n- 릴리스 만들기\n\n# 단계 1. 프로젝트 준비\n\n- 프로젝트의 명령줄에서 다음을 실행하세요:\n\n\n\n```js\nnpm init -y\n```\n\n이 명령어를 실행하면 기본 값으로 package.json 파일이 생성되고, 나중에 필요에 따라 수정할 수 있습니다.\n\n- src 폴더를 생성하세요.\n\n이 폴더에 모든 프로젝트 파일을 보관할 예정입니다.\n\n\n\n프로젝트에 React와 TypeScript를 추가해 보겠어요 (만약 상관 없다면 yarn을 사용할 거에요)\n\n```js\nyarn add -D react react-dom typescript @types/react\n```\n\n이제 node_modules 폴더와 yarn.lock 파일이 생성되었어요 — 꽤 좋죠!\n\n- TypeScript를 컴파일하기 위해 프로젝트 루트에 다음 내용을 가진 tsconfig.json 파일을 생성하세요:\n\n\n\n위의 내용을 참조하시면 가능한 모든 속성을 확인할 수 있어요: https://www.typescriptlang.org/tsconfig\n\n주요 내용:\n\n- rootDir — 소스 파일 내에서의 루트 폴더\n\n- include— TypeScript 프로젝트에 포함될 파일을 지정\n\n\n\n- exclude — TypeScript 프로젝트에서 제외할 파일을 지정합니다. dist 폴더와 모든 node_modules를 포함하고 싶지 않습니다.\n\n- outDir — 이것은 컴파일된 출력물의 위치입니다.\n\n- 빈 README.md 및 LICENSE 파일을 생성합니다.\n\n어떤 라이센스를 사용할지는 당신에게 달려있습니다. 저는 MIT를 사용할 것입니다. 해당 파일의 내용을 확인할 수 있습니다.\n\n\n\n위에 있는 내용을 마크다운 형식으로 바꿔보세요:\n\n![structure](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_1.png)\n\n## 단계 2. React 애플리케이션 만들기\n\nsrc 폴더 안에 components 폴더를 만들어주세요. 여기에 프로젝트의 모든 컴포넌트를 보관할 수 있습니다. 이 글에서는 여기에 App.tsx라는 파일 하나만 만들어보겠습니다. 파일에는 아래 내용을 넣어주세요:\n\n\n\n저희의 React 애플리케이션이에요.\n\n이제 src 폴더 안에 index.ts 파일을 만들어주세요. 모듈을 내보내세요.\n\n프로젝트를 컴파일할 시간이에요!\n\npackage.json을 열어서 scripts 섹션을 변경해봐요:\n\n\n\n터미널에서 다음 명령을 실행하세요:\n\n```js\nyarn build\n```\n\n모든 컴파일된 코드와 함께 dist 폴더가 나타날 것입니다.\n\n축하합니다! 컴파일된 애플리케이션을 생성했습니다. 조금 더 나가야 할 과정이 남았습니다! (아마도.)\n\n\n\n위에서 언급한 단계 2 이후의 프로젝트 구조를 비교해보세요:\n\n![프로젝트 구조](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_2.png)\n\n## 단계 3. git 설정하기\n\n프로젝트를 빠르게 만들었으니 이제 git을 설정할 시간입니다.\n\n\n\n프로젝트 루트에서 다음 명령어로 git을 초기화하세요:\n\n```js\ngit init\n```\n\n프로젝트 루트에 다음 내용을 가진 .gitignore 파일을 생성하세요:\n\n```js\nnode_modules\n.idea\ndist\nyarn-error.log\n```\n\n\n\nJetbrains IDE를 사용하여 개발을 도와주기 때문에 .idea를 추가했어요.\n\n.gitignore 파일에는 리포지토리에 포함하고 싶지 않은 파일과 디렉터리를 나열합니다.\n\nGitHub에서 git repo를 만드세요. 나중에 초기 커밋을 만들고 원격 git을 로컬 git에 연결할 거에요.\n\n# 단계 4. ESLint 구성\n\n\n\nESLint은 코드를 정적으로 분석하여 빠르게 문제를 찾아줍니다. 우리는 개발 시에만 필요합니다.\n\n다음 코드로 eslint와 모든 필요한 구성 요소를 추가해주세요:\n\n```js\nyarn add -D eslint eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser\n```\n\n원하는 대로 구성할 수 있으며, 자세한 사용자 가이드는 여기에 있어요: https://eslint.org/docs/user-guide/configuring/\n\n\n\n프로젝트의 루트에 .eslintrc 파일을 만드는 것을 제안합니다:\n\n.eslintignore 파일을 추가하세요:\n\n```js\nnode_modules\ndist\n```\n\n우리는 컴파일된 파일이 위치한 dist 폴더와 node_modules를 체크하지 않도록 무시할 것입니다.\n\n\n\n테이블 태그를 마크다운 형식으로 변경해 주세요.\n\n\n\n```js\nyarn lint\n```\n\n에러가 없어야 해요. \n\n스텝 4 이후 프로젝트 구조를 비교해보세요:\n\n![프로젝트 구조 비교](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_3.png)\n\n\n\n# 단계 5. Prettier 구성\n\nPrettier는 코드 포매터입니다. 팀으로 작업할 때 사용하면 모두의 코드가 동일한 표준을 준수하게 됩니다.\n\n터미널에서 다음 명령을 실행해주세요:\n\n```js\nyarn add -D eslint-config-prettier eslint-plugin-prettier prettier\n```\n\n\n\n프로젝트 루트에서 .prettierrc.json 파일을 만들어주세요:\n\n모든 옵션에 대해 더 알아보려면 여기를 확인해주세요: https://prettier.io/docs/en/options.html.\n\n.eslintrc에 prettier 플러그인을 추가해주세요:\n\nprettier 설정이 완료되었습니다! 이제 yarn lint를 실행하여 포맷 에러를 확인해보세요. 에러가 없다면, 인간인지 확인해보세요 😆.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_4.png\" /\u003e\n\n이제 그것들을 수정해 봅시다! package.json에 다음을 추가하세요:\n\n```js\n\"prettier\": \"prettier --write \\\"{src,tests,example/src}/**/*.{js,ts,jsx,tsx}\\\"\"\n```\n\n좋아요, yarn prettier를 실행하면 다음과 유사한 결과를 얻을 수 있습니다:\n\n\n\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_5.png)\n\n이제 yarn lint를 실행한 후에는 오류가 없어야 합니다. src/components/App.tsx 및 src/index.ts 파일을 확인해보세요. 변경되었습니다.\n\npackage.json의 scripts 섹션:\n\n```js\n\"scripts\": {\n  \"build\": \"tsc\",\n  \"lint\": \"eslint \\\"{**/*,*}.{js,ts,jsx,tsx}\\\"\",\n  \"prettier\": \"prettier --write \\\"{src,tests,example/src}/**/*.{js,ts,jsx,tsx}\\\"\"\n}\n``` \n\n\n\nStep 5 이후 프로젝트 구조를 비교해보세요:\n\n![프로젝트 구조](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_6.png)\n\n## 단계 6. Jest를 사용한 테스트 추가\n\n테스트를 만들기 위해 저는 Jest 라이브러리를 사용하고 있어요. Jest는 꽤 유용하고 강력한 테스트 프레임워크에요. 얼마나 어려운 테스트를 작성할지는 당신에게 달렸어요.\n\n\n\n프로젝트에 jest를 추가해주세요:\n\n```js\nyarn add -D jest jest-canvas-mock jest-environment-jsdom ts-jest @types/jest @testing-library/react\n```\n\n프로젝트 루트 파일 jestconfig.json을 생성해주세요.\n\n폴더 tests를 만들어주세요.\n\n\n\n첫 번째 테스트를 작성하는 시간입니다. 우리는 매우 간단한 테스트를 작성할 것인데, 렌더링이 성공적으로 이루어졌는지 확인할 것입니다.\n\ntests 폴더 안에 common.test.tsx 파일을 만들어주세요.\n\npackage.json 파일의 scripts 섹션을 변경해주세요:\n\n```js\n\"test\": \"jest --config jestconfig.json\"\n```\n\n\n\nyarn test 명령을 실행해보세요. 테스트가 통과해야 합니다:\n\n![프로젝트 구조 비교 후 이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_7.png)\n\n스텝 6 이후의 프로젝트 구조를 비교해보세요:\n\n![스텝 6 이후 프로젝트 구조 이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_8.png)\n\n\n\n# 단계 7. package.json 구성 및 발행 준비\n\n저는 빌드를 분리하는 것을 제안합니다. 우리는 패키지를 가능한 한 접근하기 쉽게 만들기 위해 ECMAScript 모듈뿐만 아니라 CommonJs 모듈도 컴파일할 것입니다.\n\npackage.json 파일에서 다음을 대체하세요:\n\n```json\n\"build\": \"tsc\",\n```\n\n\n\n다음 코드를 사용하여\n\n```js\n\"build\": \"yarn build:esm \u0026\u0026 yarn build:cjs\",\n\"build:esm\": \"tsc\",\n\"build:cjs\": \"tsc --module commonjs --outDir dist/cjs\",\n```\n\nbuild:esm과 build:cjs를 추가하고 이를 하나의 명령어로 결합했습니다.\n\nyarn build를 실행하면, 이제 dist/ 폴더에 cjs 폴더가 생성된 것을 확인할 수 있습니다.\n\n\n\n더 나아가보세요.\n\npackage.json 파일에서는 패키지가 게시될 때 자동으로 호출되는 매직 스크립트를 사용할 수 있습니다. 이러한 스크립트를 사용하면 패키지를 모든 종류의 오류로부터 확인하고 실수로 업데이트를 업로드하여 패키지가 사용되는 수백 만 프로젝트를 충돌시키지 않도록 도와줍니다!\n\n- prepare — 패키지가 패킹되고 게시되기 전에 실행됩니다. 인수 없이 로컬 npm install에서 실행됩니다.\n- prepublishOnly — 패키지가 준비되고 패킹되기 전에 실행됩니다. npm publish에서만 실행됩니다. 여기에는 테스트가 들어갑니다.\n\n다음을 스크립트 섹션에 추가하세요:\n\n\n\n```json\n\"scripts\": {\n  \"prepare\": \"npm run build\",\n  \"prepublishOnly\": \"npm test \u0026\u0026 npm run prettier \u0026\u0026 npm run lint\"\n},\n\"main\": \"dist/index.js\",\n\"types\": \"dist/index.d.ts\"\n```\n\n\n\n```js\n\"main\": \"index.js\",\n```\n\n다음과 같이 변경해주세요:\n\n```js\n\"main\": \"./dist/cjs/index.js\",\n\"module\": \"./dist/esm/index.js\",\n\"types\": \"./dist/esm/index.d.ts\",\n```\n\n원격 Git 저장소에 대한 정보를 추가해주세요 (단계 3에서 제공한 Git URL을 명시해주세요):\n\n\n\n```js\n\"repository\": {\n  \"type\": \"git\",\n  \"url\": \"git+https://github.com/gapon2401/my-react-typescript-package.git\"\n},\n```\n\n우리 패키지를 사용할 프로젝트는 적어도 `=16` 버전 이상의 리액트 버전을 가져야 합니다:\n\n```js\n\"peerDependencies\": {\n  \"react\": \"\u003e=16\"\n},\n```\n\n패키지가 불필요한 파일이 없도록하려면, 허용된 파일 및 폴더만 사용하여 패키지에 추가하십시오:\n```\n\n\n\n```js\n\"files\": [\n  \"dist\",\n  \"LICENSE\",\n  \"README.md\"\n],\n```\n\n프로젝트를 찾을 수 있도록 키워드를 추가해주세요:\n\n```js\n\"keywords\": [\n  \"react\",\n  \"typescript\",\n  \"awesome-project\"\n],\n```\n\n라이선스를 명시해주세요:\n\n\n\n```js\n\"license\": \"MIT\",\n```\n\n저자 이름 변경하는거 잊지 마세요:\n\n```js\n\"author\": \"Igor Gaponov (gapon2401)\",\n```\n\n그게 충분한 것 같아요.\n\n\n\nREADME.md 파일에 설명을 추가해주세요.\n\n현재 README 파일에는 한 줄만 있습니다. 이것이 h1 입니다:\n\n```js\n# my-react-typescript-package\n```\n\npackage.json 파일의 최종 버전을 확인해보세요.\n\n\n\n# 단계 8. 코드를 커밋하고 푸시하세요\n\n우선, 원격 및 로컬 저장소를 연결하고 프로젝트를 푸시해 봅시다.\n\n다음 코드를 실행해 주세요:\n\n```js\ngit add .\ngit commit -m \"Initial commit\"\ngit remote add origin \u003c저장소 URL\u003e\ngit push -u origin master\n```\n\n\n\n본인의 `Repository Url`을 변경하는 것을 잊지 마세요. 이는 https URL이거나 ssh 일 수 있습니다. 이 URL은 레포지토리에서 얻을 수 있습니다.\n\n다음과 같은 예시를 살펴보세요.\n\n- HTTPS 레포지토리 URL (인증이 필요합니다)\n\n```js\ngit remote add origin https://github.com/gapon2401/my-react-typescript-package.git\n```\n\n\n\n- SSH 저장소 URL (SSH 연결 구성 필요)\n\n```js\ngit remote add origin git@github.com:gapon2401/my-react-typescript-package.git\n```\n\n저는 두 번째 해결책을 사용했어요.\n\n# 단계 9. NPM에 발행\n\n\n\n- 패키지 이름 선택하기\n\n우리 패키지의 이름을 사용할 수 있는지 확인해야 합니다. https://www.npmjs.com/ 웹사이트로 이동하여 검색 도구를 사용해보세요.\n\npackage.json 파일에서 프로젝트의 기본 이름을 찾아 변경할 수 있습니다:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_9.png)\n\n\n\n나의 경우에는 my-react-typescript-package 이 있습니다. 아직 그런 패키지는 없네요.\n\n다음과 같이 링크에 이름을 직접 삽입하여 확인하는 것이 더 좋다고 생각해요:\n\n```js\nhttps://www.npmjs.com/package/\u003c당신의 패키지 이름\u003e\n```\n\n`당신의 패키지 이름` 자리에 프로젝트의 이름을 넣어주세요.\n\n\n\n다음 URL을 받았어요:\n\n```js\nhttps://www.npmjs.com/package/my-react-typescript-package\n```\n\n만약 이름이 무료하면 404 페이지가 표시됩니다:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_10.png)\n\n\n\n- NPM에 등록/로그인하기\n\n프로젝트를 게시하려면 https://www.npmjs.com/에서 인증해야 합니다.\n\n아직 계정이 없다면 https://www.npmjs.com/signup에서 등록하거나 명령줄을 사용해 주세요:\n\n```js\nnpm adduser\n```\n\n\n\n사용자 이름, 비밀번호 및 이메일을 입력하라는 메시지가 표시됩니다.\n\n이미 계정이 있는 경우에는 다음을 실행하세요:\n\n```js\nnpm login\n```\n\n그리고 인증을 완료하세요.\n\n\n\n- 배포하기\n\n배포하기 전에 필요한 파일만 패키지에 포함되었는지, 오류가 없는지, 그리고 모든 것이 올바르게 포맷되어 있는지 확인하는 것을 추천합니다. 이를 위해 아래 명령어를 실행할 수 있습니다:\n\n```js\nnpm publish --dry-run\n```\n\n패키지가 실제로 게시되지는 않을 거에요, 걱정 마세요.\n\n\n\n\"매직 스크립트인 prepublishOnly가 호출되어 테스트 및 코드 형식 지정이 실행됨을 확인하게 될 거에요.\n\n그런 다음 프로젝트에 포함된 모든 파일 목록을 볼 수 있게 되며:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_11.png)\n\nTarball 콘텐츠에는 package.json에서 지정된 파일 및 폴더가 포함되어 있습니다:\"\n\n\n\n```js\n\"files\": [\n   \"dist\",\n   \"LICENSE\",\n   \"README.md\"\n ],\n```\n\n모든 준비가 끝났어요! 이제 패키지를 게시하면 돼요!\n\n다음 명령어를 실행해 주세요:\n\n```js\nnpm publish\n```\n\n\n\n이 명령을 실행할 때마다 항상 걱정이 돼요.\n\n명령 호출의 전체 결과를 첨부합니다:\n\n![Command Result](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_12.png)\n\n이제 축하해요! 패키지가 발행되었어요. 공개되었고, 누구든 사용할 수 있어요! 생각보다 어렵지 않았죠.\n\n\n\nNPM에서 해당 패키지를 확인해보세요.\n\n이전에 열었던 링크를 열어보세요.\n\n```js\nhttps://www.npmjs.com/package/\u003c당신의 패키지 이름\u003e\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_13.png\" /\u003e\n\n\n\n잘 보이네요!\n\n# 단계 10. 예제 폴더 만들기\n\n우리 패키지를 계속 발전시키는 재미를 느껴봐요. 이번 단계에서는 패키지를 어떻게 활용할 수 있는지 보여줄 예제 폴더를 만들 것입니다. 이 폴더에서는 서버를 빠르게 시작하고 코드를 테스트할 수 있어요. \n애플리케이션을 빠르게 실행하려면 https://parceljs.org/를 사용할 거에요.\n\n`example`라는 폴더를 생성하세요.\n\n\n\n해당 폴더 안에 비어 있는 src 폴더와 파일을 만들어주세요:\n\n- .gitignore:\n\n```js\nnode_modules\nyarn.lock\n.parcel-cache\ndist\nyarn-error.log\n```\n\n- package.json:\n\n\n\n- README.md:\n\n자, 지금 주의를 기울여봐! 프로젝트의 루트 디렉토리에서 명령줄을 열고 예제 폴더로 이동해봐:\n\n```js\ncd example\n```\n\n그리고 실행해봐:\n\n\n\n```js\nyarn add -D parcel my-react-typescript-package react react-dom @types/react-dom @types/react\n```\n\nsrc 폴더 안에 index.html 파일을 만듭니다.\n\n이제, 우리 패키지를 가져와서 사용하는 예제를 작성해야 합니다.\n\nsrc 폴더 안에 index.tsx 파일을 만듭니다.\n\n\n\n서버를 실행할 시간입니다! 아래 명령어를 사용해주세요:\n\n```js\nyarn start\n```\n\n서버가 성공적으로 실행되면 다음 메시지가 표시됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_14.png\" /\u003e\n\n\n\n아래의 예시를 확인하려면 http://localhost:1234 링크를 열어보세요:\n\n![예시 이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_15.png)\n\n모든 설치와 서버 실행 후의 예시 폴더 구조를 비교해보세요. 아래와 같은 모양이어야 합니다:\n\n![예시 이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_16.png)\n\n\n\n# 단계 11. 자동 빌드 설정하기\n\n자동 빌드에 대해 이야기해보겠습니다. 변경 사항을 git에 푸시하고 각 릴리스마다 npm에 푸시해야 하는 것은 꽤 불편합니다. 이 프로세스를 GitHub Actions로 자동화할 것입니다.\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_17.png)\n\n프로젝트 구조의 루트에 .github라는 폴더를 생성해주세요.\n\n\n\n안녕하세요! 친절한 안내드립니다.\n\nMarkdown 형식으로 테이블 태그를 변경하고,\n\n폴더 workflows를 만드세요.\n\n그 안에 파일 publish.yml을 만드세요:\n\n파일 안에는 중요한 포인트들이 주석처리되어 있습니다.\n\nGitHub에 릴리스할 때 우리의 패키지가 자동으로 빌드되어 NPM에 푸시됩니다.\n\n\n\n다음 라인을 확인해 주세요:\n\n```js\n# 우리 NPM 계정에 필요합니다\nNODE_AUTH_TOKEN: ${ secrets.NPM_TOKEN }\n```\n\n이 방법으로 GitHub를 NPM과 연결할 예정입니다.\n\n브라우저에서 https://www.npmjs.com/ 에서 계정을 열고 토큰이 있는 페이지로 이동해 주세요:\n\n\n\n아래는 Markdown 형식으로 변경된 내용입니다.\n\n\n![이미지1](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_18.png)\n\n새 토큰을 생성하십시오:\n\n![이미지2](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_19.png)\n\n이름을 입력하고 유형을 선택하라는 메시지가 표시됩니다. Automation은 github-actions에 적합합니다.\n\n\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_20.png)\n\n토큰을 복사하고 Github 레포지토리를 엽니다.\n\n탭 설정으로 이동하여 Secrets — Actions를 엽니다. 새 저장소 시크릿 변수를 만듭니다. NPM_TOKEN이라는 이름을 주고 NPM에서 받은 토큰 값을 붙여넣습니다:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_21.png)\n\n\n\n잘 했어요! 이제 프로젝트의 새 버전을 만들고 GitHub에 푸시하기만 남았어요.\n\n어떤 변경 사항을 커밋하기 전에 다음 명령어를 실행하는 것을 잊지 마세요:\n\n```js\nyarn prepublishOnly\n```\n\n코드가 깔끔하게 유지될 수 있도록 확인하는 것이 좋아요.\n\n\n\n프로젝트를 푸시한 후에 Actions 탭으로 이동하면 GitHub이 워크플로 액션을 감지했음을 알 수 있습니다. 그러나 아직 아무것도 시작되지 않았습니다. 왜냐하면 우리가 아직 릴리스를 만들지 않았기 때문입니다.)\n\n![image](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_22.png)\n\n# 단계 12. 데모 페이지\n\n이미 패키지를 사용하는 예제가 있는 폴더가 있지만, 전체 프로젝트를 클론하지 않고도 사용자가 빠르게 패키지 작업을 볼 수 있도록 서로 다른 페이지를 만들고 싶습니다. 이 페이지를 만들어 봅시다!\n\n\n\n우리는 깃허브 페이지를 사용하여 데모를 만들 거에요.\n\n새 깃 브랜치를 만들어보세요:\n\n```js\ngit checkout -b gh-pages\n```\n\n이제 프로젝트에서 모든 파일을 지우세요!\n\n\n\n이전 파일들은 모두 안전하게 다른 master 브랜치에 보관될 거니까 걱정하지 마세요. gh-pages 브랜치는 데모용으로만 사용될 거에요. 그래서 모든 파일을 삭제해야 해요. 자, 모두 삭제해주세요!\n\n그런 다음 명령 줄에서 다음을 실행하세요:\n\n```js\nnpm init -y\n```\n\n이 명령은 package.json 파일을 생성할 거에요. 이번에는 자세히 설정하지 않을 거에요.\n\n\n\n데모 페이지에는 우리가 익숙한 Parcel을 사용하는 것을 제안합니다 (단계 10)\n\n다음을 실행해보세요:\n\n```js\nyarn add -D parcel my-react-typescript-package react react-dom @types/react-dom @types/react typescript\n```\n\n`.gitignore` 파일을 생성하세요:\n\n\n\n```js\nnode_modules\nyarn.lock\n.parcel-cache\ndist\nyarn-error.log\n```\n\n다음 내용을 포함한 파일 tsconfig.json을 생성하세요.\n\nEslint를 설정하는 단계 4를 따르세요.\n\n빈 폴더 src를 생성하세요. 그 안에 다음 내용을 가진 파일 index.html을 생성하세요.\n\n\n\n새로운 index.tsx 파일을 생성해주세요.\n\npackage.json 파일의 scripts 섹션에 아래 코드를 추가해주세요:\n\n```json\n\"start\": \"parcel src/index.html\",\n\"build\": \"parcel build src/index.html --dist-dir docs --public-url .\"\n```\n\n제 package.json 파일을 확인해주세요.\n\n\n\n서버를 실행하여 모든 것이 잘 작동하는지 확인하세요:\n\n```js\nyarn start \n```\n\n이제 다음 명령어를 사용하여 오류를 확인하는 코드를 실행하세요:\n\n```js\nyarn lint\n```\n\n\n\n수정 사항 없습니다! 멋져요! 이제 페이지를 만들 차례에요.\n\n```js\nyarn build\n```\n\n데모 프로젝트의 모든 파일이 포함된 docs 폴더가 표시될 거예요.\n\n다음은 브랜치 gh-pages의 구조입니다:\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_23.png\" /\u003e\n\n이제 변경 사항을 모두 git에 푸시합시다. 다음을 실행하세요:\n\n```js\ngit add .\ngit commit -m \"초기 페이지 커밋\"\ngit push -u origin gh-pages\n```\n\nGitHub 저장소를 열어서 설정으로 이동하고 페이지로 이동합니다. 소스에서 /docs를 선택한 후 Save를 누릅니다:\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_24.png\" /\u003e\n\n약 3-5분 정도 기다리시면 지정된 URL에 사이트가 이용 가능해집니다. 페이지에 표시된 URL을 확인해보세요.\n\n\u003cimg src=\"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_25.png\" /\u003e\n\n데모 페이지 작업이 끝났습니다. 보시다시피 사용자의 취향에 맞게 원하는 대로 커스터마이즈하고 어떠한 복잡도의 페이지나 웹사이트를 만들 수 있습니다.\n\n\n\n여기 결과가 있어요: [https://gapon2401.github.io/my-react-typescript-package/](https://gapon2401.github.io/my-react-typescript-package/)\n\n# 단계 13. README.md 파일 및 shields.io\n\n이제 코드 작업이 끝났으니, 이제 패키지의 설명 파일로 전환해 볼게요.\n\ngit에서 master 브랜치로 전환하고 README.md 파일을 열어주세요.\n\n\n\n테이블 태그를 마크다운 형식으로 변경해주세요:\n\n\nFor the description file, we are using markdown.\n\nIn README.md, I have added a short description of the package, link to demo-page, and a usage section.\n\nAt the beginning of the readme file, I have small cute icons. This is [shields.io](https://shields.io/). It is very convenient to have them. I’ve added just a couple as an example, you can use as many as you want.\n\n\n\nGitHub 앱lications에 shields.io를 추가해보세요.\n\n파일 끝을 살펴보세요; 이미지와 링크가 있는 변수를 만들었습니다. Markdown을 사용하면 이러한 변수를 만들 수 있기 때문에 설명 파일이 더 정확해집니다. 저장소 경로와 패키지 이름을 변경하는 것을 잊지 마세요.\n\npackage.json에서 버전을 변경하고, 커밋하고 파일을 레포지토리에 푸시하세요. 모든 작업은 스스로 진행해주세요. 이전 단계에 이미 수행했던 것과 같은 절차입니다.\n\n# 단계 14. 릴리스 만들기\n\n\n\n이것이 마지막 단계입니다. 짧을 거에요.\n\n우리가 계획했던 모든 것을 완료했어요! 이제 공식 릴리스를 GitHub에 작성하고 자동 빌드가 어떻게 작동하는지 확인할 수 있어요.\n\n저장소의 메인 페이지로 이동해서 '새 릴리스 생성'을 클릭하세요:\n\n![Create a new release](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_26.png)\n\n\n\n현재 버전을 지정하는 태그를 추가하세요. 릴리스 시 자동으로 생성됩니다. 릴리스 제목과 설명을 인쇄하고 릴리스를 발행하려면 클릭하십시오.\n\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_27.png)\n\n이제 탭 \"Actions\"를 열고 빌드가 성공적으로 완료되었는지 확인하세요.\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_28.png)\n\n\n\n패키지를 NPM에서 업데이트했는지 확인해 봐요.\n\n패키지 링크를 열어 볼게요:\n\n```js\nhttps://www.npmjs.com/package/\u003c패키지 이름\u003e\n```\n\n제것을 열어 볼게요:\n\n\n\n```js\nhttps://www.npmjs.com/package/my-react-typescript-package\n```\n\n새 버전과 새 설명이 나와 있어요:\n\n![이미지](/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_29.png)\n\n긴 여정이었지만, 매우 유용하길 바랍니다. 처음 패키지를 게시할 때 어려웠던 모든 것을 설명하기 위해 노력했고, 이 정보들을 조각 조각 모았어요.\n\n\n\n읽어 주셔서 감사합니다! ❤","ogImage":{"url":"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_0.png"},"coverImage":"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_0.png","tag":["Tech"],"readingTime":17},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    a: \"a\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    div: \"div\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"제로부터 놀라운 프로젝트를 만드는 법을 배워보세요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"소개\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"npm 패키지를 발행하는 데 대해 더 많은 기사를 쓰기로 결정한 이유는 무엇일까요? 제가 스스로 이러한 패키지를 만들어야 할 때, 인터넷의 대부분의 지침이 오래되었거나 제품 제작에 거의 도움이 되지 않는 매우 짧았기 때문입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모든 단계를 가능한 명확하게 설명하고자 노력하겠습니다. 그래서 여러분도 처음부터 직접 프로젝트를 만들어보실 수 있을 거에요. 시작해 봐요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"간단한 React 애플리케이션을 만드는 것을 제안합니다. 두 개의 버튼으로 이루어진 카운터 값을 증가시키거나 감소시키는 애플리케이션입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리 애플리케이션은 이렇게 생겼을 거에요:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"데모: \", _jsx(_components.a, {\n        href: \"https://gapon2401.github.io/my-react-typescript-package/\",\n        children: \"링크\"\n      }), \"\\n저장소: \", _jsx(_components.a, {\n        href: \"https://github.com/gapon2401/my-react-typescript-package\",\n        children: \"링크\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 모든 것을 다루는 14단계가 있어요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"프로젝트 준비하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"React 애플리케이션 만들기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Git 구성하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"ESLint 구성하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Prettier 구성하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Jest로 테스트 추가하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"package.json 구성하고 발행 준비하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"코드를 커밋하고 푸시하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"NPM에 발행하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"예제 폴더 생성하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"자동 빌드 설정하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"데모 페이지\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"README.md 파일과 shields.io\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"릴리스 만들기\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 1. 프로젝트 준비\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"프로젝트의 명령줄에서 다음을 실행하세요:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"npm init -y\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 명령어를 실행하면 기본 값으로 package.json 파일이 생성되고, 나중에 필요에 따라 수정할 수 있습니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"src 폴더를 생성하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 폴더에 모든 프로젝트 파일을 보관할 예정입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트에 React와 TypeScript를 추가해 보겠어요 (만약 상관 없다면 yarn을 사용할 거에요)\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"yarn add -D react react-dom typescript @types/react\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 node_modules 폴더와 yarn.lock 파일이 생성되었어요 — 꽤 좋죠!\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"TypeScript를 컴파일하기 위해 프로젝트 루트에 다음 내용을 가진 tsconfig.json 파일을 생성하세요:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 내용을 참조하시면 가능한 모든 속성을 확인할 수 있어요: https://www.typescriptlang.org/tsconfig\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"주요 내용:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"rootDir — 소스 파일 내에서의 루트 폴더\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"include— TypeScript 프로젝트에 포함될 파일을 지정\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"exclude — TypeScript 프로젝트에서 제외할 파일을 지정합니다. dist 폴더와 모든 node_modules를 포함하고 싶지 않습니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"outDir — 이것은 컴파일된 출력물의 위치입니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"빈 README.md 및 LICENSE 파일을 생성합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"어떤 라이센스를 사용할지는 당신에게 달려있습니다. 저는 MIT를 사용할 것입니다. 해당 파일의 내용을 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위에 있는 내용을 마크다운 형식으로 바꿔보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_1.png\",\n        alt: \"structure\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단계 2. React 애플리케이션 만들기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"src 폴더 안에 components 폴더를 만들어주세요. 여기에 프로젝트의 모든 컴포넌트를 보관할 수 있습니다. 이 글에서는 여기에 App.tsx라는 파일 하나만 만들어보겠습니다. 파일에는 아래 내용을 넣어주세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저희의 React 애플리케이션이에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 src 폴더 안에 index.ts 파일을 만들어주세요. 모듈을 내보내세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트를 컴파일할 시간이에요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"package.json을 열어서 scripts 섹션을 변경해봐요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"터미널에서 다음 명령을 실행하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"yarn build\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모든 컴파일된 코드와 함께 dist 폴더가 나타날 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"축하합니다! 컴파일된 애플리케이션을 생성했습니다. 조금 더 나가야 할 과정이 남았습니다! (아마도.)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위에서 언급한 단계 2 이후의 프로젝트 구조를 비교해보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_2.png\",\n        alt: \"프로젝트 구조\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단계 3. git 설정하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트를 빠르게 만들었으니 이제 git을 설정할 시간입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트 루트에서 다음 명령어로 git을 초기화하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"git init\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트 루트에 다음 내용을 가진 .gitignore 파일을 생성하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"node_modules\\n.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"idea\"\n        }), \"\\ndist\\nyarn-error.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"log\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Jetbrains IDE를 사용하여 개발을 도와주기 때문에 .idea를 추가했어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \".gitignore 파일에는 리포지토리에 포함하고 싶지 않은 파일과 디렉터리를 나열합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GitHub에서 git repo를 만드세요. 나중에 초기 커밋을 만들고 원격 git을 로컬 git에 연결할 거에요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 4. ESLint 구성\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ESLint은 코드를 정적으로 분석하여 빠르게 문제를 찾아줍니다. 우리는 개발 시에만 필요합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 코드로 eslint와 모든 필요한 구성 요소를 추가해주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"yarn add -D eslint eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"원하는 대로 구성할 수 있으며, 자세한 사용자 가이드는 여기에 있어요: https://eslint.org/docs/user-guide/configuring/\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트의 루트에 .eslintrc 파일을 만드는 것을 제안합니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \".eslintignore 파일을 추가하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"node_modules\\ndist\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 컴파일된 파일이 위치한 dist 폴더와 node_modules를 체크하지 않도록 무시할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블 태그를 마크다운 형식으로 변경해 주세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"yarn lint\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"에러가 없어야 해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"스텝 4 이후 프로젝트 구조를 비교해보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_3.png\",\n        alt: \"프로젝트 구조 비교\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 5. Prettier 구성\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Prettier는 코드 포매터입니다. 팀으로 작업할 때 사용하면 모두의 코드가 동일한 표준을 준수하게 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"터미널에서 다음 명령을 실행해주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"yarn add -D eslint-config-prettier eslint-plugin-prettier prettier\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트 루트에서 .prettierrc.json 파일을 만들어주세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모든 옵션에 대해 더 알아보려면 여기를 확인해주세요: https://prettier.io/docs/en/options.html.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \".eslintrc에 prettier 플러그인을 추가해주세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"prettier 설정이 완료되었습니다! 이제 yarn lint를 실행하여 포맷 에러를 확인해보세요. 에러가 없다면, 인간인지 확인해보세요 😆.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_4.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 그것들을 수정해 봅시다! package.json에 다음을 추가하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"prettier\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"prettier --write \\\\\\\"{src,tests,example/src}/**/*.{js,ts,jsx,tsx}\\\\\\\"\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"좋아요, yarn prettier를 실행하면 다음과 유사한 결과를 얻을 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_5.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 yarn lint를 실행한 후에는 오류가 없어야 합니다. src/components/App.tsx 및 src/index.ts 파일을 확인해보세요. 변경되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"package.json의 scripts 섹션:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"scripts\\\"\"\n        }), \": {\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"build\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"tsc\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"lint\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"eslint \\\\\\\"{**/*,*}.{js,ts,jsx,tsx}\\\\\\\"\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"prettier\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"prettier --write \\\\\\\"{src,tests,example/src}/**/*.{js,ts,jsx,tsx}\\\\\\\"\\\"\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Step 5 이후 프로젝트 구조를 비교해보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_6.png\",\n        alt: \"프로젝트 구조\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"단계 6. Jest를 사용한 테스트 추가\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테스트를 만들기 위해 저는 Jest 라이브러리를 사용하고 있어요. Jest는 꽤 유용하고 강력한 테스트 프레임워크에요. 얼마나 어려운 테스트를 작성할지는 당신에게 달렸어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트에 jest를 추가해주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"yarn add -D jest jest-canvas-mock jest-environment-jsdom ts-jest @types/jest @testing-library/react\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트 루트 파일 jestconfig.json을 생성해주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"폴더 tests를 만들어주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"첫 번째 테스트를 작성하는 시간입니다. 우리는 매우 간단한 테스트를 작성할 것인데, 렌더링이 성공적으로 이루어졌는지 확인할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"tests 폴더 안에 common.test.tsx 파일을 만들어주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"package.json 파일의 scripts 섹션을 변경해주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"test\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"jest --config jestconfig.json\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"yarn test 명령을 실행해보세요. 테스트가 통과해야 합니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_7.png\",\n        alt: \"프로젝트 구조 비교 후 이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"스텝 6 이후의 프로젝트 구조를 비교해보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_8.png\",\n        alt: \"스텝 6 이후 프로젝트 구조 이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 7. package.json 구성 및 발행 준비\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저는 빌드를 분리하는 것을 제안합니다. 우리는 패키지를 가능한 한 접근하기 쉽게 만들기 위해 ECMAScript 모듈뿐만 아니라 CommonJs 모듈도 컴파일할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"package.json 파일에서 다음을 대체하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-json\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"build\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"tsc\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 코드를 사용하여\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"build\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"yarn build:esm \u0026\u0026 yarn build:cjs\\\"\"\n        }), \",\\n\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"build:esm\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"tsc\\\"\"\n        }), \",\\n\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"build:cjs\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"tsc --module commonjs --outDir dist/cjs\\\"\"\n        }), \",\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"build\", _jsx(_components.div, {}), \"과 build\", _jsx(_components.div, {}), \"를 추가하고 이를 하나의 명령어로 결합했습니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"yarn build를 실행하면, 이제 dist/ 폴더에 cjs 폴더가 생성된 것을 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"더 나아가보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"package.json 파일에서는 패키지가 게시될 때 자동으로 호출되는 매직 스크립트를 사용할 수 있습니다. 이러한 스크립트를 사용하면 패키지를 모든 종류의 오류로부터 확인하고 실수로 업데이트를 업로드하여 패키지가 사용되는 수백 만 프로젝트를 충돌시키지 않도록 도와줍니다!\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"prepare — 패키지가 패킹되고 게시되기 전에 실행됩니다. 인수 없이 로컬 npm install에서 실행됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"prepublishOnly — 패키지가 준비되고 패킹되기 전에 실행됩니다. npm publish에서만 실행됩니다. 여기에는 테스트가 들어갑니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음을 스크립트 섹션에 추가하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-json\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"scripts\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"{\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"prepare\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"npm run build\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"prepublishOnly\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"npm test \u0026\u0026 npm run prettier \u0026\u0026 npm run lint\\\"\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"}\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"main\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dist/index.js\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"types\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dist/index.d.ts\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"main\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"index.js\\\"\"\n        }), \",\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음과 같이 변경해주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"main\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"./dist/cjs/index.js\\\"\"\n        }), \",\\n\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"module\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"./dist/esm/index.js\\\"\"\n        }), \",\\n\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"types\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"./dist/esm/index.d.ts\\\"\"\n        }), \",\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"원격 Git 저장소에 대한 정보를 추가해주세요 (단계 3에서 제공한 Git URL을 명시해주세요):\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"repository\\\"\"\n        }), \": {\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"type\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"git\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"url\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"git+https://github.com/gapon2401/my-react-typescript-package.git\\\"\"\n        }), \"\\n},\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"우리 패키지를 사용할 프로젝트는 적어도 \", _jsx(_components.code, {\n        children: \"=16\"\n      }), \" 버전 이상의 리액트 버전을 가져야 합니다:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"peerDependencies\\\"\"\n        }), \": {\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"react\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\u003e=16\\\"\"\n        }), \"\\n},\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"패키지가 불필요한 파일이 없도록하려면, 허용된 파일 및 폴더만 사용하여 패키지에 추가하십시오:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"\\n\\n\\n```js\\n\\\"files\\\": [\\n  \\\"dist\\\",\\n  \\\"LICENSE\\\",\\n  \\\"README.md\\\"\\n],\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트를 찾을 수 있도록 키워드를 추가해주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"keywords\\\"\"\n        }), \": [\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"react\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"typescript\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"awesome-project\\\"\"\n        }), \"\\n],\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"라이선스를 명시해주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"license\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"MIT\\\"\"\n        }), \",\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저자 이름 변경하는거 잊지 마세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"author\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Igor Gaponov (gapon2401)\\\"\"\n        }), \",\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그게 충분한 것 같아요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"README.md 파일에 설명을 추가해주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"현재 README 파일에는 한 줄만 있습니다. 이것이 h1 입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"# my-react-typescript-package\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"package.json 파일의 최종 버전을 확인해보세요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 8. 코드를 커밋하고 푸시하세요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우선, 원격 및 로컬 저장소를 연결하고 프로젝트를 푸시해 봅시다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 코드를 실행해 주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"git add .\\ngit commit -m \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Initial commit\\\"\"\n        }), \"\\ngit remote add origin \u003c저장소 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"URL\"\n        }), \"\u003e\\ngit push -u origin master\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"본인의 \", _jsx(_components.code, {\n        children: \"Repository Url\"\n      }), \"을 변경하는 것을 잊지 마세요. 이는 https URL이거나 ssh 일 수 있습니다. 이 URL은 레포지토리에서 얻을 수 있습니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음과 같은 예시를 살펴보세요.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"HTTPS 레포지토리 URL (인증이 필요합니다)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"git remote add origin \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//github.com/gapon2401/my-react-typescript-package.git\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"SSH 저장소 URL (SSH 연결 구성 필요)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"git remote add origin git@github.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"com\"\n        }), \":gapon2401/my-react-typescript-package.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"git\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저는 두 번째 해결책을 사용했어요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 9. NPM에 발행\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"패키지 이름 선택하기\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리 패키지의 이름을 사용할 수 있는지 확인해야 합니다. https://www.npmjs.com/ 웹사이트로 이동하여 검색 도구를 사용해보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"package.json 파일에서 프로젝트의 기본 이름을 찾아 변경할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_9.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"나의 경우에는 my-react-typescript-package 이 있습니다. 아직 그런 패키지는 없네요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음과 같이 링크에 이름을 직접 삽입하여 확인하는 것이 더 좋다고 생각해요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//www.npmjs.com/package/\u003c당신의 패키지 이름\u003e\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"당신의 패키지 이름\"\n      }), \" 자리에 프로젝트의 이름을 넣어주세요.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 URL을 받았어요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//www.npmjs.com/package/my-react-typescript-package\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 이름이 무료하면 404 페이지가 표시됩니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_10.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"NPM에 등록/로그인하기\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트를 게시하려면 https://www.npmjs.com/에서 인증해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아직 계정이 없다면 https://www.npmjs.com/signup에서 등록하거나 명령줄을 사용해 주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"npm adduser\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자 이름, 비밀번호 및 이메일을 입력하라는 메시지가 표시됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이미 계정이 있는 경우에는 다음을 실행하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"npm login\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 인증을 완료하세요.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"배포하기\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"배포하기 전에 필요한 파일만 패키지에 포함되었는지, 오류가 없는지, 그리고 모든 것이 올바르게 포맷되어 있는지 확인하는 것을 추천합니다. 이를 위해 아래 명령어를 실행할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"npm publish --dry-run\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"패키지가 실제로 게시되지는 않을 거에요, 걱정 마세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\"매직 스크립트인 prepublishOnly가 호출되어 테스트 및 코드 형식 지정이 실행됨을 확인하게 될 거에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 프로젝트에 포함된 모든 파일 목록을 볼 수 있게 되며:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_11.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Tarball 콘텐츠에는 package.json에서 지정된 파일 및 폴더가 포함되어 있습니다:\\\"\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"files\\\"\"\n        }), \": [\\n   \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dist\\\"\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"LICENSE\\\"\"\n        }), \",\\n   \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"README.md\\\"\"\n        }), \"\\n ],\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모든 준비가 끝났어요! 이제 패키지를 게시하면 돼요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 명령어를 실행해 주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"npm publish\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 명령을 실행할 때마다 항상 걱정이 돼요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"명령 호출의 전체 결과를 첨부합니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_12.png\",\n        alt: \"Command Result\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 축하해요! 패키지가 발행되었어요. 공개되었고, 누구든 사용할 수 있어요! 생각보다 어렵지 않았죠.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"NPM에서 해당 패키지를 확인해보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이전에 열었던 링크를 열어보세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//www.npmjs.com/package/\u003c당신의 패키지 이름\u003e\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_13.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"잘 보이네요!\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 10. 예제 폴더 만들기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리 패키지를 계속 발전시키는 재미를 느껴봐요. 이번 단계에서는 패키지를 어떻게 활용할 수 있는지 보여줄 예제 폴더를 만들 것입니다. 이 폴더에서는 서버를 빠르게 시작하고 코드를 테스트할 수 있어요.\\n애플리케이션을 빠르게 실행하려면 https://parceljs.org/를 사용할 거에요.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"example\"\n      }), \"라는 폴더를 생성하세요.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"해당 폴더 안에 비어 있는 src 폴더와 파일을 만들어주세요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \".gitignore:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"node_modules\\nyarn.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"lock\"\n        }), \"\\n.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"parcel\"\n        }), \"-cache\\ndist\\nyarn-error.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"log\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"package.json:\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"README.md:\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자, 지금 주의를 기울여봐! 프로젝트의 루트 디렉토리에서 명령줄을 열고 예제 폴더로 이동해봐:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"cd example\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 실행해봐:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"yarn add -D parcel my-react-typescript-package react react-dom @types/react-dom @types/react\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"src 폴더 안에 index.html 파일을 만듭니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제, 우리 패키지를 가져와서 사용하는 예제를 작성해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"src 폴더 안에 index.tsx 파일을 만듭니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서버를 실행할 시간입니다! 아래 명령어를 사용해주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"yarn start\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서버가 성공적으로 실행되면 다음 메시지가 표시됩니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_14.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래의 예시를 확인하려면 http://localhost:1234 링크를 열어보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_15.png\",\n        alt: \"예시 이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모든 설치와 서버 실행 후의 예시 폴더 구조를 비교해보세요. 아래와 같은 모양이어야 합니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_16.png\",\n        alt: \"예시 이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 11. 자동 빌드 설정하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자동 빌드에 대해 이야기해보겠습니다. 변경 사항을 git에 푸시하고 각 릴리스마다 npm에 푸시해야 하는 것은 꽤 불편합니다. 이 프로세스를 GitHub Actions로 자동화할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_17.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트 구조의 루트에 .github라는 폴더를 생성해주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"안녕하세요! 친절한 안내드립니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Markdown 형식으로 테이블 태그를 변경하고,\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"폴더 workflows를 만드세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그 안에 파일 publish.yml을 만드세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"파일 안에는 중요한 포인트들이 주석처리되어 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GitHub에 릴리스할 때 우리의 패키지가 자동으로 빌드되어 NPM에 푸시됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 라인을 확인해 주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 우리 \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"NPM\"\n        }), \" 계정에 필요합니다\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"NODE_AUTH_TOKEN\"\n        }), \": ${ secrets.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"NPM_TOKEN\"\n        }), \" }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법으로 GitHub를 NPM과 연결할 예정입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"브라우저에서 https://www.npmjs.com/ 에서 계정을 열고 토큰이 있는 페이지로 이동해 주세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 Markdown 형식으로 변경된 내용입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_18.png\",\n        alt: \"이미지1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"새 토큰을 생성하십시오:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_19.png\",\n        alt: \"이미지2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이름을 입력하고 유형을 선택하라는 메시지가 표시됩니다. Automation은 github-actions에 적합합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_20.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"토큰을 복사하고 Github 레포지토리를 엽니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"탭 설정으로 이동하여 Secrets — Actions를 엽니다. 새 저장소 시크릿 변수를 만듭니다. NPM_TOKEN이라는 이름을 주고 NPM에서 받은 토큰 값을 붙여넣습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_21.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"잘 했어요! 이제 프로젝트의 새 버전을 만들고 GitHub에 푸시하기만 남았어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"어떤 변경 사항을 커밋하기 전에 다음 명령어를 실행하는 것을 잊지 마세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"yarn prepublishOnly\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코드가 깔끔하게 유지될 수 있도록 확인하는 것이 좋아요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트를 푸시한 후에 Actions 탭으로 이동하면 GitHub이 워크플로 액션을 감지했음을 알 수 있습니다. 그러나 아직 아무것도 시작되지 않았습니다. 왜냐하면 우리가 아직 릴리스를 만들지 않았기 때문입니다.)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_22.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 12. 데모 페이지\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이미 패키지를 사용하는 예제가 있는 폴더가 있지만, 전체 프로젝트를 클론하지 않고도 사용자가 빠르게 패키지 작업을 볼 수 있도록 서로 다른 페이지를 만들고 싶습니다. 이 페이지를 만들어 봅시다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 깃허브 페이지를 사용하여 데모를 만들 거에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"새 깃 브랜치를 만들어보세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"git checkout -b gh-pages\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 프로젝트에서 모든 파일을 지우세요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이전 파일들은 모두 안전하게 다른 master 브랜치에 보관될 거니까 걱정하지 마세요. gh-pages 브랜치는 데모용으로만 사용될 거에요. 그래서 모든 파일을 삭제해야 해요. 자, 모두 삭제해주세요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 명령 줄에서 다음을 실행하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"npm init -y\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 명령은 package.json 파일을 생성할 거에요. 이번에는 자세히 설정하지 않을 거에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데모 페이지에는 우리가 익숙한 Parcel을 사용하는 것을 제안합니다 (단계 10)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음을 실행해보세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"yarn add -D parcel my-react-typescript-package react react-dom @types/react-dom @types/react typescript\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \".gitignore\"\n      }), \" 파일을 생성하세요:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"node_modules\\nyarn.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"lock\"\n        }), \"\\n.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"parcel\"\n        }), \"-cache\\ndist\\nyarn-error.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"log\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 내용을 포함한 파일 tsconfig.json을 생성하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Eslint를 설정하는 단계 4를 따르세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"빈 폴더 src를 생성하세요. 그 안에 다음 내용을 가진 파일 index.html을 생성하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"새로운 index.tsx 파일을 생성해주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"package.json 파일의 scripts 섹션에 아래 코드를 추가해주세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-json\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"start\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"parcel src/index.html\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \",\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"\\\"build\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \":\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"parcel build src/index.html --dist-dir docs --public-url .\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 package.json 파일을 확인해주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서버를 실행하여 모든 것이 잘 작동하는지 확인하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"yarn start \\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 다음 명령어를 사용하여 오류를 확인하는 코드를 실행하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"yarn lint\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"수정 사항 없습니다! 멋져요! 이제 페이지를 만들 차례에요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"yarn build\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데모 프로젝트의 모든 파일이 포함된 docs 폴더가 표시될 거예요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 브랜치 gh-pages의 구조입니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_23.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 변경 사항을 모두 git에 푸시합시다. 다음을 실행하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"git add .\\ngit commit -m \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"초기 페이지 커밋\\\"\"\n        }), \"\\ngit push -u origin gh-pages\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GitHub 저장소를 열어서 설정으로 이동하고 페이지로 이동합니다. 소스에서 /docs를 선택한 후 Save를 누릅니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_24.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"약 3-5분 정도 기다리시면 지정된 URL에 사이트가 이용 가능해집니다. 페이지에 표시된 URL을 확인해보세요.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_25.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데모 페이지 작업이 끝났습니다. 보시다시피 사용자의 취향에 맞게 원하는 대로 커스터마이즈하고 어떠한 복잡도의 페이지나 웹사이트를 만들 수 있습니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"여기 결과가 있어요: \", _jsx(_components.a, {\n        href: \"https://gapon2401.github.io/my-react-typescript-package/\",\n        children: \"https://gapon2401.github.io/my-react-typescript-package/\"\n      })]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 13. README.md 파일 및 shields.io\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 코드 작업이 끝났으니, 이제 패키지의 설명 파일로 전환해 볼게요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"git에서 master 브랜치로 전환하고 README.md 파일을 열어주세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블 태그를 마크다운 형식으로 변경해주세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"For the description file, we are using markdown.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In README.md, I have added a short description of the package, link to demo-page, and a usage section.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"At the beginning of the readme file, I have small cute icons. This is \", _jsx(_components.a, {\n        href: \"https://shields.io/\",\n        children: \"shields.io\"\n      }), \". It is very convenient to have them. I’ve added just a couple as an example, you can use as many as you want.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GitHub 앱lications에 shields.io를 추가해보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"파일 끝을 살펴보세요; 이미지와 링크가 있는 변수를 만들었습니다. Markdown을 사용하면 이러한 변수를 만들 수 있기 때문에 설명 파일이 더 정확해집니다. 저장소 경로와 패키지 이름을 변경하는 것을 잊지 마세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"package.json에서 버전을 변경하고, 커밋하고 파일을 레포지토리에 푸시하세요. 모든 작업은 스스로 진행해주세요. 이전 단계에 이미 수행했던 것과 같은 절차입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 14. 릴리스 만들기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것이 마지막 단계입니다. 짧을 거에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리가 계획했던 모든 것을 완료했어요! 이제 공식 릴리스를 GitHub에 작성하고 자동 빌드가 어떻게 작동하는지 확인할 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저장소의 메인 페이지로 이동해서 '새 릴리스 생성'을 클릭하세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_26.png\",\n        alt: \"Create a new release\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"현재 버전을 지정하는 태그를 추가하세요. 릴리스 시 자동으로 생성됩니다. 릴리스 제목과 설명을 인쇄하고 릴리스를 발행하려면 클릭하십시오.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_27.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 탭 \\\"Actions\\\"를 열고 빌드가 성공적으로 완료되었는지 확인하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_28.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"패키지를 NPM에서 업데이트했는지 확인해 봐요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"패키지 링크를 열어 볼게요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//www.npmjs.com/package/\u003c패키지 이름\u003e\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제것을 열어 볼게요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//www.npmjs.com/package/my-react-typescript-package\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"새 버전과 새 설명이 나와 있어요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild_29.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"긴 여정이었지만, 매우 유용하길 바랍니다. 처음 패키지를 게시할 때 어려웠던 모든 것을 설명하기 위해 노력했고, 이 정보들을 조각 조각 모았어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"읽어 주셔서 감사합니다! ❤\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-HowtoCreateandPublishReactTypeScriptnpmPackageWithDemoandAutomatedBuild"},"buildId":"uXJWf9GNc_Ux38RlnQJQc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>