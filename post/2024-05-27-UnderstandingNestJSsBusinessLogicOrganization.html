<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>NestJS의 비즈니스 로직 조직 이해하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="NestJS의 비즈니스 로직 조직 이해하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="NestJS의 비즈니스 로직 조직 이해하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization" data-gatsby-head="true"/><meta name="twitter:title" content="NestJS의 비즈니스 로직 조직 이해하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 18:47" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-742e6c91a18eb160.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">NestJS의 비즈니스 로직 조직 이해하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="NestJS의 비즈니스 로직 조직 이해하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">3<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png" alt="Understanding NestJS&#x27;s Business Logic Organization"></p>
<p>전통적인 MVC 아키텍처에서 왔다면 NestJS는 낯설게 느껴질 수 있습니다. 물론, view(사용자 인터페이스) 계층, model(데이터베이스) 계층, 및 controller(비즈니스 로직) 간의 관심사 분리 아이디어는 존재합니다. 그러나 NestJS에서는 파일과 비즈니스 로직을 구조화하기 위한 새로운 흐름을 소개합니다. 라우팅 요청에 대한 컨트롤러, 비즈니스 로직 처리를 위한 서비스, 데이터베이스 조작을 위한 리포지토리의 패턴을 사용합니다. NestJS에서 비즈니스 로직을 어떻게 구성할지 살펴보겠습니다.</p>
<h2>요청 처리 새로운 방식</h2>
<p>NestJS는 구성 기반의 백엔드 프레임워크입니다. JavaScript로 작성되었지만 TypeScript를 사용할 때 가장 빛을 발합니다. 기본 NodeJS와 Express의 Wild West 접근 방식과 Ruby on Rails의 엄격한 규칙 기반 접근 방식과는 다릅니다. NestJS는 애플리케이션 개발을 위한 최상의 관행을 형성하면서도 유연한 디자인을 가능하게 하는 패턴 또는 레시피를 제공합니다.</p>
<p>NestJS 프로젝트의 설정은 모듈의 조율에 중점을 두고 있습니다. 모든 로직은 기능을 제공하거나 사용하는 모듈에 래핑되어 있습니다. 다른 소프트웨어와 마찬가지로 진입점이 있으며 서로 의존하는 웹이 있습니다:</p>
<p><img src="/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_1.png" alt="이미지"></p>
<p>NestJS는 사용자 요청을 처리하기 위해 서비스와 리포지토리를 모듈 간에 공유하면서 복잡해질 수 있습니다. 단순하게 시작하여 컨트롤러, 서비스 및 리포지토리를 포함하는 격리된 모듈부터 시작하는 것이 좋습니다. 데이터베이스 변경 요청이 NestJS 프로젝트를 통해 어떻게 라우팅되는지 살펴보겠습니다.</p>
<h2>NestJS에서 컨트롤러는 무엇을 하는가?</h2>
<p>모든 것은 컨트롤러에서 시작됩니다. 클래식 MVC 프로젝트에서는 컨트롤러가 프로젝트의 많은 부분을 책임집니다. 뷰는 서버에서 반환된 데이터를 반영합니다. 모델은 데이터 구조를 제공하고 레코드와 관련된 비즈니스 로직을 저장하며, 컨트롤러는 이들 간의 모든 것을 조율합니다.</p>
<p>NestJS에서도 컨트롤러는 일부 비슷한 기능을 가지지만 책임은 훨씬 적습니다. 컨트롤러는 간단히 트래픽 디렉터로 기능하여 어디로 어떻게 전달해야 하는지 확인합니다. 요청 유효성 검사를 위한 파이프나 들어오는 데이터를 형성하고 유효성 검사하기 위한 DTO(데이터 전송 객체)와 같이 더 많은 기능을 추가할 수 있지만, 컨트롤러는 비즈니스 로직을 처리하지 않습니다.</p>
<p>NestJS에서는 컨트롤러의 역할이 요청을 수락하고 일부 유효성 검사를 수행하여 요청과 데이터를 올바른 서비스로 라우트하는 것입니다. 이는 여전히 많은 책임을 요구하지만 다른 프레임워크보다는 적습니다.</p>
<p><img src="/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_2.png" alt="이미지"></p>
<h2>NestJS에서 서비스는 무엇을 하는가요?</h2>
<p>요청 및 선택적 데이터가 어디로 가는지 알게 되면 비즈니스 로직에 맞게 형태를 변형합니다. 이것이 우리의 서비스 파일이 필요한 이유입니다. NestJS의 서비스는 컨트롤러로부터의 요청에 기반하여 데이터를 생성, 형태를 변형 또는 업데이트하는 로직을 말합니다. 신발을 구매한 사람을 위한 새로운 주문을 생성하거나 사용자의 구식 지불 수단을 제거하는 등의 작업이 일어날 수 있습니다.</p>
<p>무엇을 하든, 서비스에서는 애플리케이션 데이터에 대한 작업을 수행하여 새 상태를 지속할 수 있게 됩니다. 서비스가 데이터를 형태로 만드는 동안, 이 새 상태를 지속하기 위해 데이터베이스와 대화하는 책임은 없습니다. 데이터를 지속시키기 위해서는 저장소가 필요합니다.</p>
<h2>NestJS에서 리포지토리는 무엇을 하는가요?</h2>
<p>저장소는 데이터베이스로의 요청을 처리합니다. 사용자의 요청이 올바른 비즈니스 로직(컨트롤러에 의해)으로 라우팅되고 데이터에 필요한 작업(서비스에 의해)이 수행되면 업데이트된 응용 프로그램 상태를 영속화할 준비가 됩니다.</p>
<p>저장소는 CRU(D) 작업으로 구성되어 있으며 API 클라이언트와 유사한 도구로 볼 수 있습니다. 저장소의 메서드는 데이터베이스에 특정 데이터 레코드를 읽거나 쓰기를 예상합니다. 그게 전부입니다. 이는 다른 접근 방식인 ORM과는 달라요, 여기서 데이터베이스 호출이 서비스에 직접 엮이지 않습니다. 추가 파일이 늘어나는 것은 더 많은 작업이 필요해 보일 수 있지만, 별도의 저장소 파일을 갖는 것은 서비스 또는 앱 사이에서 데이터베이스 작업을 공유하고, 코드를 확장하기 위해 코드를 모듈화하는 데 도움이 됩니다.</p>
<h2>NestJS에 대한 마지막 생각</h2>
<p>NestJS는 강력한 백엔드 프레임워크로 API를 빌드하는 프로세스를 가속화합니다. Ruby on Rails 또는 Java 배경에서 오는 것을 배워야 할 내용이 많을 수 있습니다. 다행히 문서는 방대하고 이해하기 쉽습니다. 깨끗하고 일관된 코드를 작성하기 위해 문서를 여러 번 검토하는 것을 강력히 권장합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"NestJS의 비즈니스 로직 조직 이해하기","description":"","date":"2024-05-27 18:47","slug":"2024-05-27-UnderstandingNestJSsBusinessLogicOrganization","content":"\n\n\n![Understanding NestJS's Business Logic Organization](/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png)\n\n전통적인 MVC 아키텍처에서 왔다면 NestJS는 낯설게 느껴질 수 있습니다. 물론, view(사용자 인터페이스) 계층, model(데이터베이스) 계층, 및 controller(비즈니스 로직) 간의 관심사 분리 아이디어는 존재합니다. 그러나 NestJS에서는 파일과 비즈니스 로직을 구조화하기 위한 새로운 흐름을 소개합니다. 라우팅 요청에 대한 컨트롤러, 비즈니스 로직 처리를 위한 서비스, 데이터베이스 조작을 위한 리포지토리의 패턴을 사용합니다. NestJS에서 비즈니스 로직을 어떻게 구성할지 살펴보겠습니다.\n\n## 요청 처리 새로운 방식\n\nNestJS는 구성 기반의 백엔드 프레임워크입니다. JavaScript로 작성되었지만 TypeScript를 사용할 때 가장 빛을 발합니다. 기본 NodeJS와 Express의 Wild West 접근 방식과 Ruby on Rails의 엄격한 규칙 기반 접근 방식과는 다릅니다. NestJS는 애플리케이션 개발을 위한 최상의 관행을 형성하면서도 유연한 디자인을 가능하게 하는 패턴 또는 레시피를 제공합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNestJS 프로젝트의 설정은 모듈의 조율에 중점을 두고 있습니다. 모든 로직은 기능을 제공하거나 사용하는 모듈에 래핑되어 있습니다. 다른 소프트웨어와 마찬가지로 진입점이 있으며 서로 의존하는 웹이 있습니다:\n\n![이미지](/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_1.png)\n\nNestJS는 사용자 요청을 처리하기 위해 서비스와 리포지토리를 모듈 간에 공유하면서 복잡해질 수 있습니다. 단순하게 시작하여 컨트롤러, 서비스 및 리포지토리를 포함하는 격리된 모듈부터 시작하는 것이 좋습니다. 데이터베이스 변경 요청이 NestJS 프로젝트를 통해 어떻게 라우팅되는지 살펴보겠습니다.\n\n## NestJS에서 컨트롤러는 무엇을 하는가?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 것은 컨트롤러에서 시작됩니다. 클래식 MVC 프로젝트에서는 컨트롤러가 프로젝트의 많은 부분을 책임집니다. 뷰는 서버에서 반환된 데이터를 반영합니다. 모델은 데이터 구조를 제공하고 레코드와 관련된 비즈니스 로직을 저장하며, 컨트롤러는 이들 간의 모든 것을 조율합니다.\n\nNestJS에서도 컨트롤러는 일부 비슷한 기능을 가지지만 책임은 훨씬 적습니다. 컨트롤러는 간단히 트래픽 디렉터로 기능하여 어디로 어떻게 전달해야 하는지 확인합니다. 요청 유효성 검사를 위한 파이프나 들어오는 데이터를 형성하고 유효성 검사하기 위한 DTO(데이터 전송 객체)와 같이 더 많은 기능을 추가할 수 있지만, 컨트롤러는 비즈니스 로직을 처리하지 않습니다.\n\nNestJS에서는 컨트롤러의 역할이 요청을 수락하고 일부 유효성 검사를 수행하여 요청과 데이터를 올바른 서비스로 라우트하는 것입니다. 이는 여전히 많은 책임을 요구하지만 다른 프레임워크보다는 적습니다.\n\n![이미지](/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## NestJS에서 서비스는 무엇을 하는가요?\n\n요청 및 선택적 데이터가 어디로 가는지 알게 되면 비즈니스 로직에 맞게 형태를 변형합니다. 이것이 우리의 서비스 파일이 필요한 이유입니다. NestJS의 서비스는 컨트롤러로부터의 요청에 기반하여 데이터를 생성, 형태를 변형 또는 업데이트하는 로직을 말합니다. 신발을 구매한 사람을 위한 새로운 주문을 생성하거나 사용자의 구식 지불 수단을 제거하는 등의 작업이 일어날 수 있습니다.\n\n무엇을 하든, 서비스에서는 애플리케이션 데이터에 대한 작업을 수행하여 새 상태를 지속할 수 있게 됩니다. 서비스가 데이터를 형태로 만드는 동안, 이 새 상태를 지속하기 위해 데이터베이스와 대화하는 책임은 없습니다. 데이터를 지속시키기 위해서는 저장소가 필요합니다.\n\n## NestJS에서 리포지토리는 무엇을 하는가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저장소는 데이터베이스로의 요청을 처리합니다. 사용자의 요청이 올바른 비즈니스 로직(컨트롤러에 의해)으로 라우팅되고 데이터에 필요한 작업(서비스에 의해)이 수행되면 업데이트된 응용 프로그램 상태를 영속화할 준비가 됩니다.\n\n저장소는 CRU(D) 작업으로 구성되어 있으며 API 클라이언트와 유사한 도구로 볼 수 있습니다. 저장소의 메서드는 데이터베이스에 특정 데이터 레코드를 읽거나 쓰기를 예상합니다. 그게 전부입니다. 이는 다른 접근 방식인 ORM과는 달라요, 여기서 데이터베이스 호출이 서비스에 직접 엮이지 않습니다. 추가 파일이 늘어나는 것은 더 많은 작업이 필요해 보일 수 있지만, 별도의 저장소 파일을 갖는 것은 서비스 또는 앱 사이에서 데이터베이스 작업을 공유하고, 코드를 확장하기 위해 코드를 모듈화하는 데 도움이 됩니다.\n\n## NestJS에 대한 마지막 생각\n\nNestJS는 강력한 백엔드 프레임워크로 API를 빌드하는 프로세스를 가속화합니다. Ruby on Rails 또는 Java 배경에서 오는 것을 배워야 할 내용이 많을 수 있습니다. 다행히 문서는 방대하고 이해하기 쉽습니다. 깨끗하고 일관된 코드를 작성하기 위해 문서를 여러 번 검토하는 것을 강력히 권장합니다.","ogImage":{"url":"/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png"},"coverImage":"/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png","tag":["Tech"],"readingTime":3},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_0.png\" alt=\"Understanding NestJS\u0026#x27;s Business Logic Organization\"\u003e\u003c/p\u003e\n\u003cp\u003e전통적인 MVC 아키텍처에서 왔다면 NestJS는 낯설게 느껴질 수 있습니다. 물론, view(사용자 인터페이스) 계층, model(데이터베이스) 계층, 및 controller(비즈니스 로직) 간의 관심사 분리 아이디어는 존재합니다. 그러나 NestJS에서는 파일과 비즈니스 로직을 구조화하기 위한 새로운 흐름을 소개합니다. 라우팅 요청에 대한 컨트롤러, 비즈니스 로직 처리를 위한 서비스, 데이터베이스 조작을 위한 리포지토리의 패턴을 사용합니다. NestJS에서 비즈니스 로직을 어떻게 구성할지 살펴보겠습니다.\u003c/p\u003e\n\u003ch2\u003e요청 처리 새로운 방식\u003c/h2\u003e\n\u003cp\u003eNestJS는 구성 기반의 백엔드 프레임워크입니다. JavaScript로 작성되었지만 TypeScript를 사용할 때 가장 빛을 발합니다. 기본 NodeJS와 Express의 Wild West 접근 방식과 Ruby on Rails의 엄격한 규칙 기반 접근 방식과는 다릅니다. NestJS는 애플리케이션 개발을 위한 최상의 관행을 형성하면서도 유연한 디자인을 가능하게 하는 패턴 또는 레시피를 제공합니다.\u003c/p\u003e\n\u003cp\u003eNestJS 프로젝트의 설정은 모듈의 조율에 중점을 두고 있습니다. 모든 로직은 기능을 제공하거나 사용하는 모듈에 래핑되어 있습니다. 다른 소프트웨어와 마찬가지로 진입점이 있으며 서로 의존하는 웹이 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eNestJS는 사용자 요청을 처리하기 위해 서비스와 리포지토리를 모듈 간에 공유하면서 복잡해질 수 있습니다. 단순하게 시작하여 컨트롤러, 서비스 및 리포지토리를 포함하는 격리된 모듈부터 시작하는 것이 좋습니다. 데이터베이스 변경 요청이 NestJS 프로젝트를 통해 어떻게 라우팅되는지 살펴보겠습니다.\u003c/p\u003e\n\u003ch2\u003eNestJS에서 컨트롤러는 무엇을 하는가?\u003c/h2\u003e\n\u003cp\u003e모든 것은 컨트롤러에서 시작됩니다. 클래식 MVC 프로젝트에서는 컨트롤러가 프로젝트의 많은 부분을 책임집니다. 뷰는 서버에서 반환된 데이터를 반영합니다. 모델은 데이터 구조를 제공하고 레코드와 관련된 비즈니스 로직을 저장하며, 컨트롤러는 이들 간의 모든 것을 조율합니다.\u003c/p\u003e\n\u003cp\u003eNestJS에서도 컨트롤러는 일부 비슷한 기능을 가지지만 책임은 훨씬 적습니다. 컨트롤러는 간단히 트래픽 디렉터로 기능하여 어디로 어떻게 전달해야 하는지 확인합니다. 요청 유효성 검사를 위한 파이프나 들어오는 데이터를 형성하고 유효성 검사하기 위한 DTO(데이터 전송 객체)와 같이 더 많은 기능을 추가할 수 있지만, 컨트롤러는 비즈니스 로직을 처리하지 않습니다.\u003c/p\u003e\n\u003cp\u003eNestJS에서는 컨트롤러의 역할이 요청을 수락하고 일부 유효성 검사를 수행하여 요청과 데이터를 올바른 서비스로 라우트하는 것입니다. 이는 여전히 많은 책임을 요구하지만 다른 프레임워크보다는 적습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-UnderstandingNestJSsBusinessLogicOrganization_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003eNestJS에서 서비스는 무엇을 하는가요?\u003c/h2\u003e\n\u003cp\u003e요청 및 선택적 데이터가 어디로 가는지 알게 되면 비즈니스 로직에 맞게 형태를 변형합니다. 이것이 우리의 서비스 파일이 필요한 이유입니다. NestJS의 서비스는 컨트롤러로부터의 요청에 기반하여 데이터를 생성, 형태를 변형 또는 업데이트하는 로직을 말합니다. 신발을 구매한 사람을 위한 새로운 주문을 생성하거나 사용자의 구식 지불 수단을 제거하는 등의 작업이 일어날 수 있습니다.\u003c/p\u003e\n\u003cp\u003e무엇을 하든, 서비스에서는 애플리케이션 데이터에 대한 작업을 수행하여 새 상태를 지속할 수 있게 됩니다. 서비스가 데이터를 형태로 만드는 동안, 이 새 상태를 지속하기 위해 데이터베이스와 대화하는 책임은 없습니다. 데이터를 지속시키기 위해서는 저장소가 필요합니다.\u003c/p\u003e\n\u003ch2\u003eNestJS에서 리포지토리는 무엇을 하는가요?\u003c/h2\u003e\n\u003cp\u003e저장소는 데이터베이스로의 요청을 처리합니다. 사용자의 요청이 올바른 비즈니스 로직(컨트롤러에 의해)으로 라우팅되고 데이터에 필요한 작업(서비스에 의해)이 수행되면 업데이트된 응용 프로그램 상태를 영속화할 준비가 됩니다.\u003c/p\u003e\n\u003cp\u003e저장소는 CRU(D) 작업으로 구성되어 있으며 API 클라이언트와 유사한 도구로 볼 수 있습니다. 저장소의 메서드는 데이터베이스에 특정 데이터 레코드를 읽거나 쓰기를 예상합니다. 그게 전부입니다. 이는 다른 접근 방식인 ORM과는 달라요, 여기서 데이터베이스 호출이 서비스에 직접 엮이지 않습니다. 추가 파일이 늘어나는 것은 더 많은 작업이 필요해 보일 수 있지만, 별도의 저장소 파일을 갖는 것은 서비스 또는 앱 사이에서 데이터베이스 작업을 공유하고, 코드를 확장하기 위해 코드를 모듈화하는 데 도움이 됩니다.\u003c/p\u003e\n\u003ch2\u003eNestJS에 대한 마지막 생각\u003c/h2\u003e\n\u003cp\u003eNestJS는 강력한 백엔드 프레임워크로 API를 빌드하는 프로세스를 가속화합니다. Ruby on Rails 또는 Java 배경에서 오는 것을 배워야 할 내용이 많을 수 있습니다. 다행히 문서는 방대하고 이해하기 쉽습니다. 깨끗하고 일관된 코드를 작성하기 위해 문서를 여러 번 검토하는 것을 강력히 권장합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-UnderstandingNestJSsBusinessLogicOrganization"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>