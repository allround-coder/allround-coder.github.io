<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>React 컴파일러 발견 최적화된 React 마법 탐험하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="React 컴파일러 발견 최적화된 React 마법 탐험하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="React 컴파일러 발견 최적화된 React 마법 탐험하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic" data-gatsby-head="true"/><meta name="twitter:title" content="React 컴파일러 발견 최적화된 React 마법 탐험하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 03:09" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">React 컴파일러 발견 최적화된 React 마법 탐험하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="React 컴파일러 발견 최적화된 React 마법 탐험하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>안녕하세요, React 열정가 여러분! 오늘은 새로운 React 컴파일러에 관한 흥미로운 소식을 공유하려고 해요. React 팀에서 나온 이 편리한 도구는 React 앱을 자동으로 최적화해줍니다. 함께 React 컴파일러가 무엇인지, 시작하는 방법, 그리고 한번 시도해볼 가치가 있는 이유에 대해 알아보려고 해요.</p>
<h1>공사 중 🚧</h1>
<p>우선, React 컴파일러에 대한 문서 작업은 아직 진행 중입니다. 자세한 내용은 React 컴파일러 작업 그룹 레포를 확인해주세요. 하지만 지금은 전반적인 내용을 살펴볼까요?</p>
<h1>React 컴파일러란?</h1>
<div class="content-ad"></div>
<p>React Compiler은 빌드 시간에 React 앱을 최적화하기 위해 설계된 실험적인 도구입니다. 커뮤니티로부터 피드백을 모으기 위해 오픈 소스로 제공되며 일반 JavaScript와 완벽하게 작동합니다. 최고의 점은 기존 코드를 다시 작성할 필요가 없다는 것입니다.</p>
<p>그러나 React Compiler를 사용하려면 React 19 RC가 필요합니다. 이전 버전에 머물러 있으면 해결책이 있지만 업그레이드하는 것이 가장 좋습니다.</p>
<h1>컴파일러는 무엇을 하는가?</h1>
<p>간단히 말해, React Compiler는 코드를 자동으로 메모이즈합니다. useMemo, useCallback 또는 React.memo를 사용해 본 적이 있다면 메모이제이션의 강력함을 알고 있을 것입니다. 컴파일러는 이를 자동으로 수행하여 효율적인 업데이트를 보장하며 별다른 노력없이 처리합니다.</p>
<div class="content-ad"></div>
<h1>Vite를 이용한 React 컴파일러 설정:</h1>
<p>React 컴파일러를 Vite와 통합하는 것은 프로젝트의 성능을 크게 향상시킬 수 있는 간단한 과정입니다. 이 설정에서는 React 컴파일러를 쉽게 통합할 수 있는 방법을 보여주기 위해 샘플 프로젝트를 만들 것입니다. 이 설정은 Vite로 구동되는 React 앱에 React 컴파일러가 가져다주는 효율성과 속도 향상의 잠재적인 개선 사항을 보여줄 것입니다.</p>
<h1>필수 조건</h1>
<p>이전 버전과 호환되지 않으니 React 19 RC 이상을 사용하는지 확인해주세요.</p>
<div class="content-ad"></div>
<h1>설치 및 설정</h1>
<ul>
<li>새로운 Vite 프로젝트를 만들기:</li>
</ul>
<p>가장 먼저, 새로운 Vite 프로젝트를 만들어 봅시다. 터미널을 열고 다음 명령을 실행해 주세요:</p>
<pre><code class="hljs language-js">npm create vite@latest react-beta-test
</code></pre>
<div class="content-ad"></div>
<ol start="2">
<li>React 19 Beta 설치하기:</li>
</ol>
<p>이제 방금 만든 디렉토리로 이동해서 React 19 Beta를 설치해봅시다.</p>
<pre><code class="hljs language-js">cd react-beta-test
npm install react@beta react-dom@beta
</code></pre>
<div class="content-ad"></div>
<p>TypeScript 팬 여러분, 여기 한 가지 팁이 있습니다. 모든 것이 조화롭게 맞물리도록 package.json 파일을 조금 조정해야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-string">"dependencies"</span>: {
  <span class="hljs-string">"@types/react"</span>: <span class="hljs-string">"npm:types-react@alpha"</span>,
  <span class="hljs-string">"@types/react-dom"</span>: <span class="hljs-string">"npm:types-react-dom@alpha"</span>,
  <span class="hljs-string">"react"</span>: <span class="hljs-string">"^19.0.0-beta-94eed63c49-20240425"</span>,
  <span class="hljs-string">"react-dom"</span>: <span class="hljs-string">"^19.0.0-beta-94eed63c49-20240425"</span>
},
<span class="hljs-string">"overrides"</span>: {
  <span class="hljs-string">"@types/react"</span>: <span class="hljs-string">"npm:types-react@alpha"</span>,
  <span class="hljs-string">"@types/react-dom"</span>: <span class="hljs-string">"npm:types-react-dom@alpha"</span>
}
</code></pre>
<ul>
<li>Babel Plugin 설치:</li>
<li>다음으로, React 컴파일러를 활성화할 Babel 플러그인을 설치해야 합니다. 다음 명령어를 실행해주세요:</li>
</ul>
<pre><code class="hljs language-js">npm install babel-plugin-react-compiler
</code></pre>
<div class="content-ad"></div>
<ol start="2">
<li>Vite 구성에 React 컴파일러 플러그인을 추가해보세요:</li>
</ol>
<p>마지막으로, Vite가 React 컴파일러 플러그인을 사용하도록 구성해 봅시다. vite.config.js 파일을 열고 다음 구성을 추가하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-title class_">ReactCompilerConfig</span> = {};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">plugins</span>: [
      <span class="hljs-title function_">react</span>({
        <span class="hljs-attr">babel</span>: {
          <span class="hljs-attr">plugins</span>: [
            [<span class="hljs-string">"babel-plugin-react-compiler"</span>, <span class="hljs-title class_">ReactCompilerConfig</span>],
          ],
        },
      }),
    ],
  };
});
</code></pre>
<h1>파트 1: 컴파일러 및 useMemo 없이</h1>
<div class="content-ad"></div>
<p>간단한 앱을 두 가지 상태로 가정해 봅시다: 숫자(n)와 카운터. 1부터 n까지 숫자의 합을 계산할 겁니다. useMemo 없이 이 계산은 컴포넌트가 다시 렌더링될 때마다 발생하게 됩니다. 카운터만 변경된 경우에도 그렇죠. 무엇이 발생하는지 확인해 볼까요? 함께 알아봐요!</p>
<h1>컴포넌트 설정하기</h1>
<p>우선, 두 개의 상태와 합을 계산하는 함수로 컴포넌트를 설정해 보겠습니다. App.jsx 파일의 코드를 바꿔서 결과를 확인해 보세요. ("use no memo"를 사용해서 컴파일러가 자동으로 메모이제이션하지 않게 합니다)</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use no memo"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> [number, setNumber] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> [counter, setCounter] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">calculateSum</span> = (<span class="hljs-params">n</span>) => {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'합을 계산 중...'</span>);
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &#x3C;= n; i++) {
      sum += i;
    }
    <span class="hljs-keyword">return</span> sum;
  };
  <span class="hljs-keyword">const</span> sum = <span class="hljs-title function_">calculateSum</span>(number);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>1부터 {number}까지의 합: {sum}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> setNumber(number + 1)}>숫자 증가<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> setCounter(counter + 1)}>카운터 증가<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>카운터: {counter}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<div class="content-ad"></div>
<h1>불필요한 재렌더링 관찰</h1>
<p>이 설정에서는 "Increment Counter" 버튼을 클릭할 때마다 숫자가 변경되지 않았음에도 불구하고 calculateSum 함수가 실행됩니다. 콘솔을 확인해보세요 - 매번 "Calculating sum..."이 기록되는 것을 볼 수 있을 겁니다. 이것은 비효율적입니다! 숫자가 변경되지 않았다면 sum을 다시 계산하고 싶지 않습니다.</p>
<h1>파트 2: 컴파일러 없이 useMemo 사용하기</h1>
<p>여기서 마법이 벌어집니다. 숫자를 종속성으로 전달하여 calculateSum 호출을 useMemo로 감싸겠습니다.</p>
<div class="content-ad"></div>
<h1>useMemo 추가하기</h1>
<p>컴포넌트를 최적화해보죠. number가 변경될 때에만 계산이 발생하도록 useMemo를 사용해보세요.</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use no memo"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> [number, setNumber] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> [counter, setCounter] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">calculateSum</span> = (<span class="hljs-params">n</span>) => {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'계산 중...'</span>);
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &#x3C;= n; i++) {
      sum += i;
    }
    <span class="hljs-keyword">return</span> sum;
  };
  <span class="hljs-keyword">const</span> sum = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">calculateSum</span>(number), [number]);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>1부터 {number}까지의 합: {sum}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> setNumber(number + 1)}>숫자 증가<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> setCounter(counter + 1)}>카운터 증가<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>카운터: {counter}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<h1>최적화 즐기기</h1>
<div class="content-ad"></div>
<p>이제 useMemo가 적용되어 있어서 calculateSum 함수는 숫자가 변경될 때만 실행됩니다. 한 번 시도해보세요! "Increment Counter" 버튼을 클릭하고 콘솔을 확인해보세요. 불필요한 "Calculating sum..." 메시지가 사라졌죠. 높은 다섯! 🖐</p>
<h1>파트 3: 컴파일러와 함께</h1>
<p>상상해보세요: 프로젝트를 작업 중인데 useMemo를 추가하는 것을 깜빡했습니다. 걱정하지 마세요! 우리 마법같은 React 컴파일러가 자동으로 추가해 줍니다. 어떻게 작동하는지 보겠습니다. (우리는 "use no memo"를 사용하지 않기 때문에 컴파일러가 자체적으로 동작합니다)</p>
<h1>마법 같은 컴파일러 동작 방식</h1>
<div class="content-ad"></div>
<p>리액트 컴파일러를 사용하면, useMemo 없이 코드를 작성해도 컴포넌트가 자동으로 최적화됩니다. 다시 원본 코드를 확인해보겠습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">SumComponent</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> [number, setNumber] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);
  <span class="hljs-keyword">const</span> [counter, setCounter] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">calculateSum</span> = (<span class="hljs-params">n</span>) => {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Calculating sum...'</span>);
    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &#x3C;= n; i++) {
      sum += i;
    }
    <span class="hljs-keyword">return</span> sum;
  };
  <span class="hljs-keyword">const</span> sum = <span class="hljs-title function_">calculateSum</span>(number);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>Sum from 1 to {number}: {sum}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> setNumber(number + 1)}>Increment Number<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> setCounter(counter + 1)}>Increment Counter<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Counter: {counter}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">SumComponent</span>;
</code></pre>
<h1>최고 수준의 자동 최적화</h1>
<p><img src="/assets/img/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic_0.png" alt="image"></p>
<div class="content-ad"></div>
<p>컴파일러의 마법 덕분에 이 코드는 자동으로 변경되어 useMemo을 포함하여 효율적인 다시 렌더링을 보장해줍니다. 우리는 손가락 한 번 까딱하지 않아도 됩니다! 컴파일러는 필요한 곳에 useMemo를 추가하여 컴포넌트를 최적화합니다. 콘솔을 다시 확인해보세요 – "Calculating sum..." 메시지가 필요없어졌죠. 마치 성능 요정이 어깨에 앉아 있는 느낌이에요! 🧚‍♂️</p>
<h1>해볼 가치가 있을까요?</h1>
<p>React 컴파일러는 아직 실험 단계이며 베타 버전으로, 완전히 제품으로 출시되지는 않았습니다. Meta에서 이미 사용 중이지만, 여러분의 앱에 적합한지 여부는 코드가 React의 규칙을 얼마나 잘 준수하는지에 달려 있습니다.</p>
<p>컴파일러를 더 작은 프로젝트나 앱의 일부분에서 실험하는 것이 전체 앱에서 시도하는 것보다 좋은 아이디어입니다.</p>
<div class="content-ad"></div>
<h1>마무리하며</h1>
<p>React 컴파일러는 React 앱의 성능을 최적화해줄 것으로 기대되는 흥미로운 새로운 도구입니다. 아직 개발 중이고 베타 버전이지만, 앱 성능을 향상시키려는 열정을 가지고 있다면 탐색할 가치가 있습니다. 한번 시도해보고 생각을 공유해보세요!</p>
<p>이 개요가 React 컴파일러에 대해 흥미를 느끼게 해주기를 바랍니다. 궁금한 점이나 의견이 있으시면 언제든 댓글로 남겨주세요. 즐거운 코딩 되세요! 🎉</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React 컴파일러 발견 최적화된 React 마법 탐험하기","description":"","date":"2024-06-22 03:09","slug":"2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic","content":"\n\n안녕하세요, React 열정가 여러분! 오늘은 새로운 React 컴파일러에 관한 흥미로운 소식을 공유하려고 해요. React 팀에서 나온 이 편리한 도구는 React 앱을 자동으로 최적화해줍니다. 함께 React 컴파일러가 무엇인지, 시작하는 방법, 그리고 한번 시도해볼 가치가 있는 이유에 대해 알아보려고 해요.\n\n# 공사 중 🚧\n\n우선, React 컴파일러에 대한 문서 작업은 아직 진행 중입니다. 자세한 내용은 React 컴파일러 작업 그룹 레포를 확인해주세요. 하지만 지금은 전반적인 내용을 살펴볼까요?\n\n# React 컴파일러란?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact Compiler은 빌드 시간에 React 앱을 최적화하기 위해 설계된 실험적인 도구입니다. 커뮤니티로부터 피드백을 모으기 위해 오픈 소스로 제공되며 일반 JavaScript와 완벽하게 작동합니다. 최고의 점은 기존 코드를 다시 작성할 필요가 없다는 것입니다.\n\n그러나 React Compiler를 사용하려면 React 19 RC가 필요합니다. 이전 버전에 머물러 있으면 해결책이 있지만 업그레이드하는 것이 가장 좋습니다.\n\n# 컴파일러는 무엇을 하는가?\n\n간단히 말해, React Compiler는 코드를 자동으로 메모이즈합니다. useMemo, useCallback 또는 React.memo를 사용해 본 적이 있다면 메모이제이션의 강력함을 알고 있을 것입니다. 컴파일러는 이를 자동으로 수행하여 효율적인 업데이트를 보장하며 별다른 노력없이 처리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Vite를 이용한 React 컴파일러 설정:\n\nReact 컴파일러를 Vite와 통합하는 것은 프로젝트의 성능을 크게 향상시킬 수 있는 간단한 과정입니다. 이 설정에서는 React 컴파일러를 쉽게 통합할 수 있는 방법을 보여주기 위해 샘플 프로젝트를 만들 것입니다. 이 설정은 Vite로 구동되는 React 앱에 React 컴파일러가 가져다주는 효율성과 속도 향상의 잠재적인 개선 사항을 보여줄 것입니다.\n\n# 필수 조건\n\n이전 버전과 호환되지 않으니 React 19 RC 이상을 사용하는지 확인해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 설치 및 설정\n\n- 새로운 Vite 프로젝트를 만들기:\n\n가장 먼저, 새로운 Vite 프로젝트를 만들어 봅시다. 터미널을 열고 다음 명령을 실행해 주세요:\n\n```js\nnpm create vite@latest react-beta-test\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. React 19 Beta 설치하기:\n\n이제 방금 만든 디렉토리로 이동해서 React 19 Beta를 설치해봅시다.\n\n```js\ncd react-beta-test\nnpm install react@beta react-dom@beta\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTypeScript 팬 여러분, 여기 한 가지 팁이 있습니다. 모든 것이 조화롭게 맞물리도록 package.json 파일을 조금 조정해야 합니다.\n\n```js\n\"dependencies\": {\n  \"@types/react\": \"npm:types-react@alpha\",\n  \"@types/react-dom\": \"npm:types-react-dom@alpha\",\n  \"react\": \"^19.0.0-beta-94eed63c49-20240425\",\n  \"react-dom\": \"^19.0.0-beta-94eed63c49-20240425\"\n},\n\"overrides\": {\n  \"@types/react\": \"npm:types-react@alpha\",\n  \"@types/react-dom\": \"npm:types-react-dom@alpha\"\n}\n```\n\n- Babel Plugin 설치:\n- 다음으로, React 컴파일러를 활성화할 Babel 플러그인을 설치해야 합니다. 다음 명령어를 실행해주세요:\n\n```js\nnpm install babel-plugin-react-compiler\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. Vite 구성에 React 컴파일러 플러그인을 추가해보세요:\n\n마지막으로, Vite가 React 컴파일러 플러그인을 사용하도록 구성해 봅시다. vite.config.js 파일을 열고 다음 구성을 추가하세요:\n\n```js\n// vite.config.js\nReactCompilerConfig = {};\n\nexport default defineConfig(() =\u003e {\n  return {\n    plugins: [\n      react({\n        babel: {\n          plugins: [\n            [\"babel-plugin-react-compiler\", ReactCompilerConfig],\n          ],\n        },\n      }),\n    ],\n  };\n});\n```\n\n# 파트 1: 컴파일러 및 useMemo 없이\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 앱을 두 가지 상태로 가정해 봅시다: 숫자(n)와 카운터. 1부터 n까지 숫자의 합을 계산할 겁니다. useMemo 없이 이 계산은 컴포넌트가 다시 렌더링될 때마다 발생하게 됩니다. 카운터만 변경된 경우에도 그렇죠. 무엇이 발생하는지 확인해 볼까요? 함께 알아봐요!\n\n# 컴포넌트 설정하기\n\n우선, 두 개의 상태와 합을 계산하는 함수로 컴포넌트를 설정해 보겠습니다. App.jsx 파일의 코드를 바꿔서 결과를 확인해 보세요. (\"use no memo\"를 사용해서 컴파일러가 자동으로 메모이제이션하지 않게 합니다)\n\n```js\n\"use no memo\";\nimport React, { useState } from 'react';\nconst App = () =\u003e {\n  const [number, setNumber] = useState(1);\n  const [counter, setCounter] = useState(0);\n  const calculateSum = (n) =\u003e {\n    console.log('합을 계산 중...');\n    let sum = 0;\n    for (let i = 1; i \u003c= n; i++) {\n      sum += i;\n    }\n    return sum;\n  };\n  const sum = calculateSum(number);\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e1부터 {number}까지의 합: {sum}\u003c/h1\u003e\n      \u003cbutton onClick={() =\u003e setNumber(number + 1)}\u003e숫자 증가\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e setCounter(counter + 1)}\u003e카운터 증가\u003c/button\u003e\n      \u003cp\u003e카운터: {counter}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\nexport default App;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 불필요한 재렌더링 관찰\n\n이 설정에서는 \"Increment Counter\" 버튼을 클릭할 때마다 숫자가 변경되지 않았음에도 불구하고 calculateSum 함수가 실행됩니다. 콘솔을 확인해보세요 - 매번 \"Calculating sum...\"이 기록되는 것을 볼 수 있을 겁니다. 이것은 비효율적입니다! 숫자가 변경되지 않았다면 sum을 다시 계산하고 싶지 않습니다.\n\n# 파트 2: 컴파일러 없이 useMemo 사용하기\n\n여기서 마법이 벌어집니다. 숫자를 종속성으로 전달하여 calculateSum 호출을 useMemo로 감싸겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# useMemo 추가하기\n\n컴포넌트를 최적화해보죠. number가 변경될 때에만 계산이 발생하도록 useMemo를 사용해보세요.\n\n```js\n\"use no memo\";\nimport React, { useState, useMemo } from 'react';\nconst App = () =\u003e {\n  const [number, setNumber] = useState(1);\n  const [counter, setCounter] = useState(0);\n  const calculateSum = (n) =\u003e {\n    console.log('계산 중...');\n    let sum = 0;\n    for (let i = 1; i \u003c= n; i++) {\n      sum += i;\n    }\n    return sum;\n  };\n  const sum = useMemo(() =\u003e calculateSum(number), [number]);\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003e1부터 {number}까지의 합: {sum}\u003c/h1\u003e\n      \u003cbutton onClick={() =\u003e setNumber(number + 1)}\u003e숫자 증가\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e setCounter(counter + 1)}\u003e카운터 증가\u003c/button\u003e\n      \u003cp\u003e카운터: {counter}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\nexport default App;\n```\n\n# 최적화 즐기기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 useMemo가 적용되어 있어서 calculateSum 함수는 숫자가 변경될 때만 실행됩니다. 한 번 시도해보세요! \"Increment Counter\" 버튼을 클릭하고 콘솔을 확인해보세요. 불필요한 \"Calculating sum...\" 메시지가 사라졌죠. 높은 다섯! 🖐\n\n# 파트 3: 컴파일러와 함께\n\n상상해보세요: 프로젝트를 작업 중인데 useMemo를 추가하는 것을 깜빡했습니다. 걱정하지 마세요! 우리 마법같은 React 컴파일러가 자동으로 추가해 줍니다. 어떻게 작동하는지 보겠습니다. (우리는 \"use no memo\"를 사용하지 않기 때문에 컴파일러가 자체적으로 동작합니다)\n\n# 마법 같은 컴파일러 동작 방식\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리액트 컴파일러를 사용하면, useMemo 없이 코드를 작성해도 컴포넌트가 자동으로 최적화됩니다. 다시 원본 코드를 확인해보겠습니다:\n\n```js\nimport React, { useState } from 'react';\nconst SumComponent = () =\u003e {\n  const [number, setNumber] = useState(1);\n  const [counter, setCounter] = useState(0);\n  const calculateSum = (n) =\u003e {\n    console.log('Calculating sum...');\n    let sum = 0;\n    for (let i = 1; i \u003c= n; i++) {\n      sum += i;\n    }\n    return sum;\n  };\n  const sum = calculateSum(number);\n  return (\n    \u003cdiv\u003e\n      \u003ch1\u003eSum from 1 to {number}: {sum}\u003c/h1\u003e\n      \u003cbutton onClick={() =\u003e setNumber(number + 1)}\u003eIncrement Number\u003c/button\u003e\n      \u003cbutton onClick={() =\u003e setCounter(counter + 1)}\u003eIncrement Counter\u003c/button\u003e\n      \u003cp\u003eCounter: {counter}\u003c/p\u003e\n    \u003c/div\u003e\n  );\n};\nexport default SumComponent;\n```\n\n# 최고 수준의 자동 최적화\n\n![image](/assets/img/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴파일러의 마법 덕분에 이 코드는 자동으로 변경되어 useMemo을 포함하여 효율적인 다시 렌더링을 보장해줍니다. 우리는 손가락 한 번 까딱하지 않아도 됩니다! 컴파일러는 필요한 곳에 useMemo를 추가하여 컴포넌트를 최적화합니다. 콘솔을 다시 확인해보세요 – \"Calculating sum...\" 메시지가 필요없어졌죠. 마치 성능 요정이 어깨에 앉아 있는 느낌이에요! 🧚‍♂️\n\n# 해볼 가치가 있을까요?\n\nReact 컴파일러는 아직 실험 단계이며 베타 버전으로, 완전히 제품으로 출시되지는 않았습니다. Meta에서 이미 사용 중이지만, 여러분의 앱에 적합한지 여부는 코드가 React의 규칙을 얼마나 잘 준수하는지에 달려 있습니다.\n\n컴파일러를 더 작은 프로젝트나 앱의 일부분에서 실험하는 것이 전체 앱에서 시도하는 것보다 좋은 아이디어입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마무리하며\n\nReact 컴파일러는 React 앱의 성능을 최적화해줄 것으로 기대되는 흥미로운 새로운 도구입니다. 아직 개발 중이고 베타 버전이지만, 앱 성능을 향상시키려는 열정을 가지고 있다면 탐색할 가치가 있습니다. 한번 시도해보고 생각을 공유해보세요!\n\n이 개요가 React 컴파일러에 대해 흥미를 느끼게 해주기를 바랍니다. 궁금한 점이나 의견이 있으시면 언제든 댓글로 남겨주세요. 즐거운 코딩 되세요! 🎉","ogImage":{"url":"/assets/img/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic_0.png"},"coverImage":"/assets/img/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e안녕하세요, React 열정가 여러분! 오늘은 새로운 React 컴파일러에 관한 흥미로운 소식을 공유하려고 해요. React 팀에서 나온 이 편리한 도구는 React 앱을 자동으로 최적화해줍니다. 함께 React 컴파일러가 무엇인지, 시작하는 방법, 그리고 한번 시도해볼 가치가 있는 이유에 대해 알아보려고 해요.\u003c/p\u003e\n\u003ch1\u003e공사 중 🚧\u003c/h1\u003e\n\u003cp\u003e우선, React 컴파일러에 대한 문서 작업은 아직 진행 중입니다. 자세한 내용은 React 컴파일러 작업 그룹 레포를 확인해주세요. 하지만 지금은 전반적인 내용을 살펴볼까요?\u003c/p\u003e\n\u003ch1\u003eReact 컴파일러란?\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eReact Compiler은 빌드 시간에 React 앱을 최적화하기 위해 설계된 실험적인 도구입니다. 커뮤니티로부터 피드백을 모으기 위해 오픈 소스로 제공되며 일반 JavaScript와 완벽하게 작동합니다. 최고의 점은 기존 코드를 다시 작성할 필요가 없다는 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 React Compiler를 사용하려면 React 19 RC가 필요합니다. 이전 버전에 머물러 있으면 해결책이 있지만 업그레이드하는 것이 가장 좋습니다.\u003c/p\u003e\n\u003ch1\u003e컴파일러는 무엇을 하는가?\u003c/h1\u003e\n\u003cp\u003e간단히 말해, React Compiler는 코드를 자동으로 메모이즈합니다. useMemo, useCallback 또는 React.memo를 사용해 본 적이 있다면 메모이제이션의 강력함을 알고 있을 것입니다. 컴파일러는 이를 자동으로 수행하여 효율적인 업데이트를 보장하며 별다른 노력없이 처리합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eVite를 이용한 React 컴파일러 설정:\u003c/h1\u003e\n\u003cp\u003eReact 컴파일러를 Vite와 통합하는 것은 프로젝트의 성능을 크게 향상시킬 수 있는 간단한 과정입니다. 이 설정에서는 React 컴파일러를 쉽게 통합할 수 있는 방법을 보여주기 위해 샘플 프로젝트를 만들 것입니다. 이 설정은 Vite로 구동되는 React 앱에 React 컴파일러가 가져다주는 효율성과 속도 향상의 잠재적인 개선 사항을 보여줄 것입니다.\u003c/p\u003e\n\u003ch1\u003e필수 조건\u003c/h1\u003e\n\u003cp\u003e이전 버전과 호환되지 않으니 React 19 RC 이상을 사용하는지 확인해주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e설치 및 설정\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e새로운 Vite 프로젝트를 만들기:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e가장 먼저, 새로운 Vite 프로젝트를 만들어 봅시다. 터미널을 열고 다음 명령을 실행해 주세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm create vite@latest react-beta-test\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eReact 19 Beta 설치하기:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이제 방금 만든 디렉토리로 이동해서 React 19 Beta를 설치해봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd react-beta-test\nnpm install react@beta react-dom@beta\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eTypeScript 팬 여러분, 여기 한 가지 팁이 있습니다. 모든 것이 조화롭게 맞물리도록 package.json 파일을 조금 조정해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"dependencies\"\u003c/span\u003e: {\n  \u003cspan class=\"hljs-string\"\u003e\"@types/react\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"npm:types-react@alpha\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"@types/react-dom\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"npm:types-react-dom@alpha\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^19.0.0-beta-94eed63c49-20240425\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"react-dom\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^19.0.0-beta-94eed63c49-20240425\"\u003c/span\u003e\n},\n\u003cspan class=\"hljs-string\"\u003e\"overrides\"\u003c/span\u003e: {\n  \u003cspan class=\"hljs-string\"\u003e\"@types/react\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"npm:types-react@alpha\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"@types/react-dom\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"npm:types-react-dom@alpha\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eBabel Plugin 설치:\u003c/li\u003e\n\u003cli\u003e다음으로, React 컴파일러를 활성화할 Babel 플러그인을 설치해야 합니다. 다음 명령어를 실행해주세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install babel-plugin-react-compiler\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eVite 구성에 React 컴파일러 플러그인을 추가해보세요:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e마지막으로, Vite가 React 컴파일러 플러그인을 사용하도록 구성해 봅시다. vite.config.js 파일을 열고 다음 구성을 추가하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// vite.config.js\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eReactCompilerConfig\u003c/span\u003e = {};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefineConfig\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n      \u003cspan class=\"hljs-title function_\"\u003ereact\u003c/span\u003e({\n        \u003cspan class=\"hljs-attr\"\u003ebabel\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n            [\u003cspan class=\"hljs-string\"\u003e\"babel-plugin-react-compiler\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eReactCompilerConfig\u003c/span\u003e],\n          ],\n        },\n      }),\n    ],\n  };\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e파트 1: 컴파일러 및 useMemo 없이\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e간단한 앱을 두 가지 상태로 가정해 봅시다: 숫자(n)와 카운터. 1부터 n까지 숫자의 합을 계산할 겁니다. useMemo 없이 이 계산은 컴포넌트가 다시 렌더링될 때마다 발생하게 됩니다. 카운터만 변경된 경우에도 그렇죠. 무엇이 발생하는지 확인해 볼까요? 함께 알아봐요!\u003c/p\u003e\n\u003ch1\u003e컴포넌트 설정하기\u003c/h1\u003e\n\u003cp\u003e우선, 두 개의 상태와 합을 계산하는 함수로 컴포넌트를 설정해 보겠습니다. App.jsx 파일의 코드를 바꿔서 결과를 확인해 보세요. (\"use no memo\"를 사용해서 컴파일러가 자동으로 메모이제이션하지 않게 합니다)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use no memo\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [number, setNumber] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [counter, setCounter] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateSum\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003en\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'합을 계산 중...'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e sum = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; i \u0026#x3C;= n; i++) {\n      sum += i;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e sum;\n  };\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sum = \u003cspan class=\"hljs-title function_\"\u003ecalculateSum\u003c/span\u003e(number);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e1부터 {number}까지의 합: {sum}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e setNumber(number + 1)}\u003e숫자 증가\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e setCounter(counter + 1)}\u003e카운터 증가\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e카운터: {counter}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e불필요한 재렌더링 관찰\u003c/h1\u003e\n\u003cp\u003e이 설정에서는 \"Increment Counter\" 버튼을 클릭할 때마다 숫자가 변경되지 않았음에도 불구하고 calculateSum 함수가 실행됩니다. 콘솔을 확인해보세요 - 매번 \"Calculating sum...\"이 기록되는 것을 볼 수 있을 겁니다. 이것은 비효율적입니다! 숫자가 변경되지 않았다면 sum을 다시 계산하고 싶지 않습니다.\u003c/p\u003e\n\u003ch1\u003e파트 2: 컴파일러 없이 useMemo 사용하기\u003c/h1\u003e\n\u003cp\u003e여기서 마법이 벌어집니다. 숫자를 종속성으로 전달하여 calculateSum 호출을 useMemo로 감싸겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003euseMemo 추가하기\u003c/h1\u003e\n\u003cp\u003e컴포넌트를 최적화해보죠. number가 변경될 때에만 계산이 발생하도록 useMemo를 사용해보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use no memo\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState, useMemo } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [number, setNumber] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [counter, setCounter] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateSum\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003en\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'계산 중...'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e sum = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; i \u0026#x3C;= n; i++) {\n      sum += i;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e sum;\n  };\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sum = \u003cspan class=\"hljs-title function_\"\u003euseMemo\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateSum\u003c/span\u003e(number), [number]);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e1부터 {number}까지의 합: {sum}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e setNumber(number + 1)}\u003e숫자 증가\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e setCounter(counter + 1)}\u003e카운터 증가\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e카운터: {counter}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e최적화 즐기기\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 useMemo가 적용되어 있어서 calculateSum 함수는 숫자가 변경될 때만 실행됩니다. 한 번 시도해보세요! \"Increment Counter\" 버튼을 클릭하고 콘솔을 확인해보세요. 불필요한 \"Calculating sum...\" 메시지가 사라졌죠. 높은 다섯! 🖐\u003c/p\u003e\n\u003ch1\u003e파트 3: 컴파일러와 함께\u003c/h1\u003e\n\u003cp\u003e상상해보세요: 프로젝트를 작업 중인데 useMemo를 추가하는 것을 깜빡했습니다. 걱정하지 마세요! 우리 마법같은 React 컴파일러가 자동으로 추가해 줍니다. 어떻게 작동하는지 보겠습니다. (우리는 \"use no memo\"를 사용하지 않기 때문에 컴파일러가 자체적으로 동작합니다)\u003c/p\u003e\n\u003ch1\u003e마법 같은 컴파일러 동작 방식\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e리액트 컴파일러를 사용하면, useMemo 없이 코드를 작성해도 컴포넌트가 자동으로 최적화됩니다. 다시 원본 코드를 확인해보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eSumComponent\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [number, setNumber] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [counter, setCounter] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateSum\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003en\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Calculating sum...'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e sum = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; i \u0026#x3C;= n; i++) {\n      sum += i;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e sum;\n  };\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sum = \u003cspan class=\"hljs-title function_\"\u003ecalculateSum\u003c/span\u003e(number);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003eSum from 1 to {number}: {sum}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e setNumber(number + 1)}\u003eIncrement Number\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e setCounter(counter + 1)}\u003eIncrement Counter\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003eCounter: {counter}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSumComponent\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e최고 수준의 자동 최적화\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e컴파일러의 마법 덕분에 이 코드는 자동으로 변경되어 useMemo을 포함하여 효율적인 다시 렌더링을 보장해줍니다. 우리는 손가락 한 번 까딱하지 않아도 됩니다! 컴파일러는 필요한 곳에 useMemo를 추가하여 컴포넌트를 최적화합니다. 콘솔을 다시 확인해보세요 – \"Calculating sum...\" 메시지가 필요없어졌죠. 마치 성능 요정이 어깨에 앉아 있는 느낌이에요! 🧚‍♂️\u003c/p\u003e\n\u003ch1\u003e해볼 가치가 있을까요?\u003c/h1\u003e\n\u003cp\u003eReact 컴파일러는 아직 실험 단계이며 베타 버전으로, 완전히 제품으로 출시되지는 않았습니다. Meta에서 이미 사용 중이지만, 여러분의 앱에 적합한지 여부는 코드가 React의 규칙을 얼마나 잘 준수하는지에 달려 있습니다.\u003c/p\u003e\n\u003cp\u003e컴파일러를 더 작은 프로젝트나 앱의 일부분에서 실험하는 것이 전체 앱에서 시도하는 것보다 좋은 아이디어입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e마무리하며\u003c/h1\u003e\n\u003cp\u003eReact 컴파일러는 React 앱의 성능을 최적화해줄 것으로 기대되는 흥미로운 새로운 도구입니다. 아직 개발 중이고 베타 버전이지만, 앱 성능을 향상시키려는 열정을 가지고 있다면 탐색할 가치가 있습니다. 한번 시도해보고 생각을 공유해보세요!\u003c/p\u003e\n\u003cp\u003e이 개요가 React 컴파일러에 대해 흥미를 느끼게 해주기를 바랍니다. 궁금한 점이나 의견이 있으시면 언제든 댓글로 남겨주세요. 즐거운 코딩 되세요! 🎉\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-DiscoveringtheReactCompilerAFunJourneyintoOptimizedReactMagic"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>