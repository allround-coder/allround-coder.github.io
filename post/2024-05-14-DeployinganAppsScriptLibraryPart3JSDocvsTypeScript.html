<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>앱 스크립트 라이브러리 배포하기 Part 3 JSDoc 대 TypeScript | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="앱 스크립트 라이브러리 배포하기 Part 3 JSDoc 대 TypeScript | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="앱 스크립트 라이브러리 배포하기 Part 3 JSDoc 대 TypeScript | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript" data-gatsby-head="true"/><meta name="twitter:title" content="앱 스크립트 라이브러리 배포하기 Part 3 JSDoc 대 TypeScript | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 13:45" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-742e6c91a18eb160.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">앱 스크립트 라이브러리 배포하기 Part 3 JSDoc 대 TypeScript</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="앱 스크립트 라이브러리 배포하기 Part 3 JSDoc 대 TypeScript" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>아주 간단히 요약하면;</h1>
<p>약 1년 전, SvelteKit이 TypeScript에서 JSDoc으로의 전환 결정을 내렸을 때 개발자 커뮤니티에 주목할 만한 변화가 있었습니다. TypeScript는 라이브러리 개발에 이상적인 선택이 아니라고 명시하며 이 전환이 일어났는데, 이로 인해 개발자들 사이에서 논란이 일었습니다. 처음에는 이것이 발전이 아닌 퇴보로 보여 의심스러웠습니다. TypeScript는 심지어 이전 블로그 포스트 중 하나에서 추천하는 도구로 소개되기도 했습니다. 그러나 이 결정은 시간이 흐름에 따라 점차 나에게 와닿게 되었고, 구글 앱스 스크립트에서 유사한 접근 방식을 채택하게 되었습니다. 이 전환의 이유는 여러 가지가 있으며, 일부는 보편적으로 적용되는 이유이며, 다른 일부는 앱스 스크립트의 특이성과 관련된 이유입니다.</p>
<p>여기에 다시 레포 및 NPM 페이지 링크가 있습니다.</p>
<p>자 TypeScript를 처음 선택했던 이유와 그것보다 JSDoc를 선호하는 이유에 대해 알아봅시다.</p>
<h1>TypeScript를 처음 선택한 이유</h1>
<p>TypeScript는 스크립팅 및 앱 개발 분야에서 게임 체인저였습니다. 이는 주로 견고한 타입 안전 기능 때문입니다. TypeScript를 사용하면 명시적으로 선언하거나 지능적으로 추론할 수 있는 정적 타입을 사용할 수 있어 안전하고 견고한 코드를 작성하는 능력을 향상시킵니다. Google Apps Script 개발자에게 TypeScript는 추가적인 이점을 제공합니다; npm i -D @types/google-apps-script 명령어를 사용하여 GAS 타입을 쉽게 설치할 수 있습니다. 이를 통해 이러한 유형을 정의하는 데 필요한 초기 투자 시간에도 불구하고 개발 프로세스 초기에 버그를 조기에 발견하는 데 큰 도움이 됩니다.</p>
<p>또한 TypeScript는 타입에 대한 자동 완성을 제공하여 코드 품질과 유지 보수성을 향상시키고 코딩 프로세스를 가속화하며 오류를 줄입니다. 또한, 네임스페이스와 모듈을 사용할 수 있어 보다 조직적이고 모듈식 코드 구조를 구현할 수 있습니다. 이러한 기능들이 모두 Google Apps Script로 복잡하고 확장 가능한 애플리케이션을 개발하려는 개발자들에게 TypeScript를 매력적인 선택으로 만듭니다.</p>
<h1>TypeScript의 단점</h1>
<p>TypeScript은 많은 이점을 제공하지만 몇 가지 개발자들에게는 특히 번거로울 수 있는 단점도 있습니다. 먼저, 컴파일 단계가 필요하다는 점은 주요한 문제일 수 있습니다. 이 과정은 빌드 시스템의 설정 및 유지에 추가적인 복잡성을 추가하므로 일부 팀이 추구하는 간소화된 프로세스와 일치하지 않을 수 있습니다.</p>
<p>또한, TypeScript은 종종 추가적인 종속성을 필요로 합니다. 예를 들어 프로젝트에 단위 테스트를 통합할 때 추가 패키지를 다루어야 한다는 점과 Cucumber와 같은 프레임워크와 특히 호환성 문제가 발생할 수 있어 통합이 거의 불가능해질 수 있습니다. 이는 특정 테스트 프레임워크에 의존하는 팀들에게 문제가 될 수 있습니다.</p>
<p>다른 중요한 단점은 많은 양을 요구한다는 점입니다. TypeScript는 타입을 명시적으로 선언해야하므로 코드가 비대해질 수 있습니다. 이로 인해 코드가 덜 우아해지며 타입 정의를 작성하고 관리하는 데 더 많은 시간이 소비되어 개발 속도가 느려질 수 있습니다.</p>
<p>마지막으로, 이러한 유형을 최신 상태로 유지하는 것은 상당한 부담이 될 수 있습니다. 프로젝트가 규모가 확장되고 발전함에 따라 정확한 유형 정의를 유지하는 것은 지속적인 관심이 필요하며 유용한 자원을 다른 개발 활동으로 전환할 수 있습니다. 이 과부하는 TypeScript를 사용하는 이점을 초월할 정도로 중요할 수 있으며, 이로 인해 일부 팀은 선택을 재검토하기도 합니다.</p>
<h1>Apps Script 특정 단점</h1>
<p>TypeScript를 사용하는 데 관한 주목할만한 Apps Script 특정 단점 중 하나는 clasp 사용에 관련이 있습니다. clasp는 TypeScript를 JavaScript로 컴파일하는 도구 중 하나로, Apps Script 런타임과 호환되는 방식으로 작동합니다. 그러나 아쉽게도 clasp는 더 이상 업데이트되지 않는 상태이며, 이는 상당한 위험을 야기할 수 있습니다. clasp가 의존하는 TypeScript 버전이 점점 구식화되고 있으며, 호환성 문제나 완전한 실패가 발생하기 전에 오랜 시간이 걸리지 않을 것입니다. 이 구식화로 인해 더 최신의 TypeScript 기능이나 업데이트에 의존하는 스크립트들이 실행 안 될 가능성이 있습니다.</p>
<p>clasp의 기본 컴파일을 우회하려는 사람들을 위해서 자체 컴파일 구성을 설정하는 것은 대안이 될 수 있습니다. 그러나 이 방법은 자체적인 어려움을 포함하고 있습니다. 개발자들은 최종적인 JavaScript 출력이 Apps Script와 호환되도록 보장해야 합니다. 최소한, module.exports를 폴리필하는 노력이 필요하며, TypeScript 없이 이러한 조정을 관리하는 것이 간단하고 더 직관적일 수 있습니다.</p>
<p>또한 Google Apps Script와 호환되는 JavaScript 번들링 과정은 이 시리즈에서 나중에 다룰 예정입니다. 이 과정은 Apps Script 환경에서 스크립트가 원활하게 실행되도록 보장하므로 ECMAScript 표준 및 기타 호환성 장벽과 관련된 문제를 피할 수 있습니다. 이러한 요소들은 Apps Script 컨텍스트에서 TypeScript 대안을 고려하는 강력한 이유가 됩니다. 이에 대해 더 자세히 알아볼 것입니다.</p>
<h1>JSDoc의 구원</h1>
<p>JSDoc로 전환하면 Apps Script 환경에서 TypeScript의 복잡성과 오버헤드에 좌절한 사람들에게 매력적인 대안이 제공됩니다. JSDoc의 가장 중요한 장점 중 하나는 컴파일 단계가 필요하지 않다는 것입니다. 이는 개발 프로세스를 간소화하고 설정 시간을 줄이며 빌드 중에 발생하는 오류 가능성을 줄입니다. 또한 clasp의 기능을 망가뜨릴 염려없이 컴파일이 실패할 걱정을 할 필요가 없습니다.</p>
<p>게다가 JSDoc는 추가적인 종속성 없이 작동합니다. 이 간소화된 접근 방식은 많은 종속성을 유지하는 환경에서 부담이 될 수 있는 곳에서 특히 유용하며, 충돌 및 관리 문제로 이어질 수 있는 가능성을 줄일 수 있습니다.</p>
<p>복잡한 유형이 필요한 경우에도 JSDoc은 여전히 유연성을 제공합니다. 개발자들은 .d.ts 파일을 활용하여 복잡한 유형을 정의할 수 있으며, TypeScript의 엄격한 요구 사항을 완전히 따르지 않고 고급 유형 안전성이 필요한 중간 지점을 제공합니다.</p>
<p>중요한 점은 JSDoc이 다수의 개발자가 필요로 하는 기본적인 기능을 지원하면서도 타입 체크와 자동 완성을 제공한다는 것입니다. 이러한 기능을 통해 개발자들은 추가적인 도구의 부담 없이 정확하고 효율적인 코드를 작성할 수 있습니다.</p>
<p>마지막으로, JSDoc을 사용하는 주목할만한 장점 중 하나는 코드베이스에서 기술 문서를 직접 생성하는 능력입니다. 간단한 명령행 명령을 통해 JSDoc은 소스 코드의 주석을 서식이 있는 HTML 문서로 변환하여 문서 작성 및 업데이트를 일관되게 수행하기 쉽게 만듭니다. 이 기능은 사용자 채택 및 개발자 온보딩에 중요한 문서를 최신 상태로 유지해야 하는 프로젝트에서 특히 가치가 있습니다.</p>
<h1>결론</h1>
<p>종류들은 멋지지만 JSDoc이 TypeScript보다 우세합니다.</p>
<h1>시리즈의 다른 글들</h1>
<ul>
<li>파트 1: 나는 Google Apps Script에서 console.table()이 필요했고, 여기에 대해 한 일입니다.</li>
<li>파트 2: 소스 코드와 프로젝트 구조</li>
<li>파트 3: JSDoc 대 TypeScript (바로 이 글)</li>
<li>파트 4: 곧 배포 예정</li>
<li>파트 5: 곧 배포 예정</li>
<li>파트 6: 곧 배포 예정</li>
<li>파트 7: 곧 배포 예정</li>
</ul>
<h1>나에 대해</h1>
<p>저는 전업 Google Workspace 및 Google Cloud Platform 개발자이자 Workspace Google Developer Expert (GDE)입니다. 또한 Wurkspaces.dev의 창립자이기도 합니다. 프로젝트에 신뢰할 수 있는 개발자를 찾고 계시다면 저를 고용해보세요.</p>
<h1>쉽게 이해할 수 있는 영어로 🚀</h1>
<p>이 쉽게 이해할 수 있는 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:</p>
<ul>
<li>작가를 클랩하고 팔로우하는 것을 잊지 마세요 ️👏️️</li>
<li>팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter</li>
<li>다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed</li>
<li>알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지친 적이 있나요? Differ를 시도해보세요</li>
<li>PlainEnglish.io에서 더 많은 콘텐츠를 확인해보세요</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"앱 스크립트 라이브러리 배포하기 Part 3 JSDoc 대 TypeScript","description":"","date":"2024-05-14 13:45","slug":"2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript","content":"\n\n\u003cimg src=\"/assets/img/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript_0.png\" /\u003e\n\n# 아주 간단히 요약하면;\n\n약 1년 전, SvelteKit이 TypeScript에서 JSDoc으로의 전환 결정을 내렸을 때 개발자 커뮤니티에 주목할 만한 변화가 있었습니다. TypeScript는 라이브러리 개발에 이상적인 선택이 아니라고 명시하며 이 전환이 일어났는데, 이로 인해 개발자들 사이에서 논란이 일었습니다. 처음에는 이것이 발전이 아닌 퇴보로 보여 의심스러웠습니다. TypeScript는 심지어 이전 블로그 포스트 중 하나에서 추천하는 도구로 소개되기도 했습니다. 그러나 이 결정은 시간이 흐름에 따라 점차 나에게 와닿게 되었고, 구글 앱스 스크립트에서 유사한 접근 방식을 채택하게 되었습니다. 이 전환의 이유는 여러 가지가 있으며, 일부는 보편적으로 적용되는 이유이며, 다른 일부는 앱스 스크립트의 특이성과 관련된 이유입니다.\n\n여기에 다시 레포 및 NPM 페이지 링크가 있습니다.\n\n\n\n자 TypeScript를 처음 선택했던 이유와 그것보다 JSDoc를 선호하는 이유에 대해 알아봅시다.\n\n# TypeScript를 처음 선택한 이유\n\nTypeScript는 스크립팅 및 앱 개발 분야에서 게임 체인저였습니다. 이는 주로 견고한 타입 안전 기능 때문입니다. TypeScript를 사용하면 명시적으로 선언하거나 지능적으로 추론할 수 있는 정적 타입을 사용할 수 있어 안전하고 견고한 코드를 작성하는 능력을 향상시킵니다. Google Apps Script 개발자에게 TypeScript는 추가적인 이점을 제공합니다; npm i -D @types/google-apps-script 명령어를 사용하여 GAS 타입을 쉽게 설치할 수 있습니다. 이를 통해 이러한 유형을 정의하는 데 필요한 초기 투자 시간에도 불구하고 개발 프로세스 초기에 버그를 조기에 발견하는 데 큰 도움이 됩니다.\n\n또한 TypeScript는 타입에 대한 자동 완성을 제공하여 코드 품질과 유지 보수성을 향상시키고 코딩 프로세스를 가속화하며 오류를 줄입니다. 또한, 네임스페이스와 모듈을 사용할 수 있어 보다 조직적이고 모듈식 코드 구조를 구현할 수 있습니다. 이러한 기능들이 모두 Google Apps Script로 복잡하고 확장 가능한 애플리케이션을 개발하려는 개발자들에게 TypeScript를 매력적인 선택으로 만듭니다.\n\n\n\n# TypeScript의 단점\n\nTypeScript은 많은 이점을 제공하지만 몇 가지 개발자들에게는 특히 번거로울 수 있는 단점도 있습니다. 먼저, 컴파일 단계가 필요하다는 점은 주요한 문제일 수 있습니다. 이 과정은 빌드 시스템의 설정 및 유지에 추가적인 복잡성을 추가하므로 일부 팀이 추구하는 간소화된 프로세스와 일치하지 않을 수 있습니다.\n\n또한, TypeScript은 종종 추가적인 종속성을 필요로 합니다. 예를 들어 프로젝트에 단위 테스트를 통합할 때 추가 패키지를 다루어야 한다는 점과 Cucumber와 같은 프레임워크와 특히 호환성 문제가 발생할 수 있어 통합이 거의 불가능해질 수 있습니다. 이는 특정 테스트 프레임워크에 의존하는 팀들에게 문제가 될 수 있습니다.\n\n다른 중요한 단점은 많은 양을 요구한다는 점입니다. TypeScript는 타입을 명시적으로 선언해야하므로 코드가 비대해질 수 있습니다. 이로 인해 코드가 덜 우아해지며 타입 정의를 작성하고 관리하는 데 더 많은 시간이 소비되어 개발 속도가 느려질 수 있습니다.\n\n\n\n마지막으로, 이러한 유형을 최신 상태로 유지하는 것은 상당한 부담이 될 수 있습니다. 프로젝트가 규모가 확장되고 발전함에 따라 정확한 유형 정의를 유지하는 것은 지속적인 관심이 필요하며 유용한 자원을 다른 개발 활동으로 전환할 수 있습니다. 이 과부하는 TypeScript를 사용하는 이점을 초월할 정도로 중요할 수 있으며, 이로 인해 일부 팀은 선택을 재검토하기도 합니다.\n\n# Apps Script 특정 단점\n\nTypeScript를 사용하는 데 관한 주목할만한 Apps Script 특정 단점 중 하나는 clasp 사용에 관련이 있습니다. clasp는 TypeScript를 JavaScript로 컴파일하는 도구 중 하나로, Apps Script 런타임과 호환되는 방식으로 작동합니다. 그러나 아쉽게도 clasp는 더 이상 업데이트되지 않는 상태이며, 이는 상당한 위험을 야기할 수 있습니다. clasp가 의존하는 TypeScript 버전이 점점 구식화되고 있으며, 호환성 문제나 완전한 실패가 발생하기 전에 오랜 시간이 걸리지 않을 것입니다. 이 구식화로 인해 더 최신의 TypeScript 기능이나 업데이트에 의존하는 스크립트들이 실행 안 될 가능성이 있습니다.\n\nclasp의 기본 컴파일을 우회하려는 사람들을 위해서 자체 컴파일 구성을 설정하는 것은 대안이 될 수 있습니다. 그러나 이 방법은 자체적인 어려움을 포함하고 있습니다. 개발자들은 최종적인 JavaScript 출력이 Apps Script와 호환되도록 보장해야 합니다. 최소한, module.exports를 폴리필하는 노력이 필요하며, TypeScript 없이 이러한 조정을 관리하는 것이 간단하고 더 직관적일 수 있습니다.\n\n\n\n또한 Google Apps Script와 호환되는 JavaScript 번들링 과정은 이 시리즈에서 나중에 다룰 예정입니다. 이 과정은 Apps Script 환경에서 스크립트가 원활하게 실행되도록 보장하므로 ECMAScript 표준 및 기타 호환성 장벽과 관련된 문제를 피할 수 있습니다. 이러한 요소들은 Apps Script 컨텍스트에서 TypeScript 대안을 고려하는 강력한 이유가 됩니다. 이에 대해 더 자세히 알아볼 것입니다.\n\n# JSDoc의 구원\n\nJSDoc로 전환하면 Apps Script 환경에서 TypeScript의 복잡성과 오버헤드에 좌절한 사람들에게 매력적인 대안이 제공됩니다. JSDoc의 가장 중요한 장점 중 하나는 컴파일 단계가 필요하지 않다는 것입니다. 이는 개발 프로세스를 간소화하고 설정 시간을 줄이며 빌드 중에 발생하는 오류 가능성을 줄입니다. 또한 clasp의 기능을 망가뜨릴 염려없이 컴파일이 실패할 걱정을 할 필요가 없습니다.\n\n게다가 JSDoc는 추가적인 종속성 없이 작동합니다. 이 간소화된 접근 방식은 많은 종속성을 유지하는 환경에서 부담이 될 수 있는 곳에서 특히 유용하며, 충돌 및 관리 문제로 이어질 수 있는 가능성을 줄일 수 있습니다.\n\n\n\n복잡한 유형이 필요한 경우에도 JSDoc은 여전히 유연성을 제공합니다. 개발자들은 .d.ts 파일을 활용하여 복잡한 유형을 정의할 수 있으며, TypeScript의 엄격한 요구 사항을 완전히 따르지 않고 고급 유형 안전성이 필요한 중간 지점을 제공합니다.\n\n중요한 점은 JSDoc이 다수의 개발자가 필요로 하는 기본적인 기능을 지원하면서도 타입 체크와 자동 완성을 제공한다는 것입니다. 이러한 기능을 통해 개발자들은 추가적인 도구의 부담 없이 정확하고 효율적인 코드를 작성할 수 있습니다.\n\n마지막으로, JSDoc을 사용하는 주목할만한 장점 중 하나는 코드베이스에서 기술 문서를 직접 생성하는 능력입니다. 간단한 명령행 명령을 통해 JSDoc은 소스 코드의 주석을 서식이 있는 HTML 문서로 변환하여 문서 작성 및 업데이트를 일관되게 수행하기 쉽게 만듭니다. 이 기능은 사용자 채택 및 개발자 온보딩에 중요한 문서를 최신 상태로 유지해야 하는 프로젝트에서 특히 가치가 있습니다.\n\n# 결론\n\n\n\n종류들은 멋지지만 JSDoc이 TypeScript보다 우세합니다.\n\n# 시리즈의 다른 글들\n\n- 파트 1: 나는 Google Apps Script에서 console.table()이 필요했고, 여기에 대해 한 일입니다.\n- 파트 2: 소스 코드와 프로젝트 구조\n- 파트 3: JSDoc 대 TypeScript (바로 이 글)\n- 파트 4: 곧 배포 예정\n- 파트 5: 곧 배포 예정\n- 파트 6: 곧 배포 예정\n- 파트 7: 곧 배포 예정\n\n# 나에 대해\n\n\n\n저는 전업 Google Workspace 및 Google Cloud Platform 개발자이자 Workspace Google Developer Expert (GDE)입니다. 또한 Wurkspaces.dev의 창립자이기도 합니다. 프로젝트에 신뢰할 수 있는 개발자를 찾고 계시다면 저를 고용해보세요.\n\n# 쉽게 이해할 수 있는 영어로 🚀\n\n이 쉽게 이해할 수 있는 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클랩하고 팔로우하는 것을 잊지 마세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지친 적이 있나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 확인해보세요","ogImage":{"url":"/assets/img/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e아주 간단히 요약하면;\u003c/h1\u003e\n\u003cp\u003e약 1년 전, SvelteKit이 TypeScript에서 JSDoc으로의 전환 결정을 내렸을 때 개발자 커뮤니티에 주목할 만한 변화가 있었습니다. TypeScript는 라이브러리 개발에 이상적인 선택이 아니라고 명시하며 이 전환이 일어났는데, 이로 인해 개발자들 사이에서 논란이 일었습니다. 처음에는 이것이 발전이 아닌 퇴보로 보여 의심스러웠습니다. TypeScript는 심지어 이전 블로그 포스트 중 하나에서 추천하는 도구로 소개되기도 했습니다. 그러나 이 결정은 시간이 흐름에 따라 점차 나에게 와닿게 되었고, 구글 앱스 스크립트에서 유사한 접근 방식을 채택하게 되었습니다. 이 전환의 이유는 여러 가지가 있으며, 일부는 보편적으로 적용되는 이유이며, 다른 일부는 앱스 스크립트의 특이성과 관련된 이유입니다.\u003c/p\u003e\n\u003cp\u003e여기에 다시 레포 및 NPM 페이지 링크가 있습니다.\u003c/p\u003e\n\u003cp\u003e자 TypeScript를 처음 선택했던 이유와 그것보다 JSDoc를 선호하는 이유에 대해 알아봅시다.\u003c/p\u003e\n\u003ch1\u003eTypeScript를 처음 선택한 이유\u003c/h1\u003e\n\u003cp\u003eTypeScript는 스크립팅 및 앱 개발 분야에서 게임 체인저였습니다. 이는 주로 견고한 타입 안전 기능 때문입니다. TypeScript를 사용하면 명시적으로 선언하거나 지능적으로 추론할 수 있는 정적 타입을 사용할 수 있어 안전하고 견고한 코드를 작성하는 능력을 향상시킵니다. Google Apps Script 개발자에게 TypeScript는 추가적인 이점을 제공합니다; npm i -D @types/google-apps-script 명령어를 사용하여 GAS 타입을 쉽게 설치할 수 있습니다. 이를 통해 이러한 유형을 정의하는 데 필요한 초기 투자 시간에도 불구하고 개발 프로세스 초기에 버그를 조기에 발견하는 데 큰 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e또한 TypeScript는 타입에 대한 자동 완성을 제공하여 코드 품질과 유지 보수성을 향상시키고 코딩 프로세스를 가속화하며 오류를 줄입니다. 또한, 네임스페이스와 모듈을 사용할 수 있어 보다 조직적이고 모듈식 코드 구조를 구현할 수 있습니다. 이러한 기능들이 모두 Google Apps Script로 복잡하고 확장 가능한 애플리케이션을 개발하려는 개발자들에게 TypeScript를 매력적인 선택으로 만듭니다.\u003c/p\u003e\n\u003ch1\u003eTypeScript의 단점\u003c/h1\u003e\n\u003cp\u003eTypeScript은 많은 이점을 제공하지만 몇 가지 개발자들에게는 특히 번거로울 수 있는 단점도 있습니다. 먼저, 컴파일 단계가 필요하다는 점은 주요한 문제일 수 있습니다. 이 과정은 빌드 시스템의 설정 및 유지에 추가적인 복잡성을 추가하므로 일부 팀이 추구하는 간소화된 프로세스와 일치하지 않을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또한, TypeScript은 종종 추가적인 종속성을 필요로 합니다. 예를 들어 프로젝트에 단위 테스트를 통합할 때 추가 패키지를 다루어야 한다는 점과 Cucumber와 같은 프레임워크와 특히 호환성 문제가 발생할 수 있어 통합이 거의 불가능해질 수 있습니다. 이는 특정 테스트 프레임워크에 의존하는 팀들에게 문제가 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다른 중요한 단점은 많은 양을 요구한다는 점입니다. TypeScript는 타입을 명시적으로 선언해야하므로 코드가 비대해질 수 있습니다. 이로 인해 코드가 덜 우아해지며 타입 정의를 작성하고 관리하는 데 더 많은 시간이 소비되어 개발 속도가 느려질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, 이러한 유형을 최신 상태로 유지하는 것은 상당한 부담이 될 수 있습니다. 프로젝트가 규모가 확장되고 발전함에 따라 정확한 유형 정의를 유지하는 것은 지속적인 관심이 필요하며 유용한 자원을 다른 개발 활동으로 전환할 수 있습니다. 이 과부하는 TypeScript를 사용하는 이점을 초월할 정도로 중요할 수 있으며, 이로 인해 일부 팀은 선택을 재검토하기도 합니다.\u003c/p\u003e\n\u003ch1\u003eApps Script 특정 단점\u003c/h1\u003e\n\u003cp\u003eTypeScript를 사용하는 데 관한 주목할만한 Apps Script 특정 단점 중 하나는 clasp 사용에 관련이 있습니다. clasp는 TypeScript를 JavaScript로 컴파일하는 도구 중 하나로, Apps Script 런타임과 호환되는 방식으로 작동합니다. 그러나 아쉽게도 clasp는 더 이상 업데이트되지 않는 상태이며, 이는 상당한 위험을 야기할 수 있습니다. clasp가 의존하는 TypeScript 버전이 점점 구식화되고 있으며, 호환성 문제나 완전한 실패가 발생하기 전에 오랜 시간이 걸리지 않을 것입니다. 이 구식화로 인해 더 최신의 TypeScript 기능이나 업데이트에 의존하는 스크립트들이 실행 안 될 가능성이 있습니다.\u003c/p\u003e\n\u003cp\u003eclasp의 기본 컴파일을 우회하려는 사람들을 위해서 자체 컴파일 구성을 설정하는 것은 대안이 될 수 있습니다. 그러나 이 방법은 자체적인 어려움을 포함하고 있습니다. 개발자들은 최종적인 JavaScript 출력이 Apps Script와 호환되도록 보장해야 합니다. 최소한, module.exports를 폴리필하는 노력이 필요하며, TypeScript 없이 이러한 조정을 관리하는 것이 간단하고 더 직관적일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또한 Google Apps Script와 호환되는 JavaScript 번들링 과정은 이 시리즈에서 나중에 다룰 예정입니다. 이 과정은 Apps Script 환경에서 스크립트가 원활하게 실행되도록 보장하므로 ECMAScript 표준 및 기타 호환성 장벽과 관련된 문제를 피할 수 있습니다. 이러한 요소들은 Apps Script 컨텍스트에서 TypeScript 대안을 고려하는 강력한 이유가 됩니다. 이에 대해 더 자세히 알아볼 것입니다.\u003c/p\u003e\n\u003ch1\u003eJSDoc의 구원\u003c/h1\u003e\n\u003cp\u003eJSDoc로 전환하면 Apps Script 환경에서 TypeScript의 복잡성과 오버헤드에 좌절한 사람들에게 매력적인 대안이 제공됩니다. JSDoc의 가장 중요한 장점 중 하나는 컴파일 단계가 필요하지 않다는 것입니다. 이는 개발 프로세스를 간소화하고 설정 시간을 줄이며 빌드 중에 발생하는 오류 가능성을 줄입니다. 또한 clasp의 기능을 망가뜨릴 염려없이 컴파일이 실패할 걱정을 할 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003e게다가 JSDoc는 추가적인 종속성 없이 작동합니다. 이 간소화된 접근 방식은 많은 종속성을 유지하는 환경에서 부담이 될 수 있는 곳에서 특히 유용하며, 충돌 및 관리 문제로 이어질 수 있는 가능성을 줄일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e복잡한 유형이 필요한 경우에도 JSDoc은 여전히 유연성을 제공합니다. 개발자들은 .d.ts 파일을 활용하여 복잡한 유형을 정의할 수 있으며, TypeScript의 엄격한 요구 사항을 완전히 따르지 않고 고급 유형 안전성이 필요한 중간 지점을 제공합니다.\u003c/p\u003e\n\u003cp\u003e중요한 점은 JSDoc이 다수의 개발자가 필요로 하는 기본적인 기능을 지원하면서도 타입 체크와 자동 완성을 제공한다는 것입니다. 이러한 기능을 통해 개발자들은 추가적인 도구의 부담 없이 정확하고 효율적인 코드를 작성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, JSDoc을 사용하는 주목할만한 장점 중 하나는 코드베이스에서 기술 문서를 직접 생성하는 능력입니다. 간단한 명령행 명령을 통해 JSDoc은 소스 코드의 주석을 서식이 있는 HTML 문서로 변환하여 문서 작성 및 업데이트를 일관되게 수행하기 쉽게 만듭니다. 이 기능은 사용자 채택 및 개발자 온보딩에 중요한 문서를 최신 상태로 유지해야 하는 프로젝트에서 특히 가치가 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e종류들은 멋지지만 JSDoc이 TypeScript보다 우세합니다.\u003c/p\u003e\n\u003ch1\u003e시리즈의 다른 글들\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e파트 1: 나는 Google Apps Script에서 console.table()이 필요했고, 여기에 대해 한 일입니다.\u003c/li\u003e\n\u003cli\u003e파트 2: 소스 코드와 프로젝트 구조\u003c/li\u003e\n\u003cli\u003e파트 3: JSDoc 대 TypeScript (바로 이 글)\u003c/li\u003e\n\u003cli\u003e파트 4: 곧 배포 예정\u003c/li\u003e\n\u003cli\u003e파트 5: 곧 배포 예정\u003c/li\u003e\n\u003cli\u003e파트 6: 곧 배포 예정\u003c/li\u003e\n\u003cli\u003e파트 7: 곧 배포 예정\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e나에 대해\u003c/h1\u003e\n\u003cp\u003e저는 전업 Google Workspace 및 Google Cloud Platform 개발자이자 Workspace Google Developer Expert (GDE)입니다. 또한 Wurkspaces.dev의 창립자이기도 합니다. 프로젝트에 신뢰할 수 있는 개발자를 찾고 계시다면 저를 고용해보세요.\u003c/p\u003e\n\u003ch1\u003e쉽게 이해할 수 있는 영어로 🚀\u003c/h1\u003e\n\u003cp\u003e이 쉽게 이해할 수 있는 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작가를 클랩하고 팔로우하는 것을 잊지 마세요 ️👏️️\u003c/li\u003e\n\u003cli\u003e팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\u003c/li\u003e\n\u003cli\u003e다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\u003c/li\u003e\n\u003cli\u003e알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지친 적이 있나요? Differ를 시도해보세요\u003c/li\u003e\n\u003cli\u003ePlainEnglish.io에서 더 많은 콘텐츠를 확인해보세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-DeployinganAppsScriptLibraryPart3JSDocvsTypeScript"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>