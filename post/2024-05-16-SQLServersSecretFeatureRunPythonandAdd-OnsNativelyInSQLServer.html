<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SQL Server의 비밀 기능 - SQL Server에서 Python 및 애드온을 네이티브로 실행하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SQL Server의 비밀 기능 - SQL Server에서 Python 및 애드온을 네이티브로 실행하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="SQL Server의 비밀 기능 - SQL Server에서 Python 및 애드온을 네이티브로 실행하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer" data-gatsby-head="true"/><meta name="twitter:title" content="SQL Server의 비밀 기능 - SQL Server에서 Python 및 애드온을 네이티브로 실행하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-16 17:19" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SQL Server의 비밀 기능 - SQL Server에서 Python 및 애드온을 네이티브로 실행하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SQL Server의 비밀 기능 - SQL Server에서 Python 및 애드온을 네이티브로 실행하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 16, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>파이썬 라이브러리를 가져와서 SQL 테이블을 조작하고 출력하며, SQL 서버를 떠나지 않고 작업하세요.</h2>
<h2>문제</h2>
<p>이 프로젝트에서는 두 가지 서로 다른 출처에서 가져온 37,000개의 회사 이름을 관리하는 어려움에 직면합니다. 이 복잡성은 이러한 소스 간에 동일한 회사가 어떻게 나열되는지에 대한 잠재적인 불일치에 있습니다.</p>
<h2>목표</h2>
<div class="content-ad"></div>
<p>이 문서의 목표는 Microsoft SQL Server 내에서 Python을 네이티브로 실행하는 방법을 가르치는 것입니다. 또한 SQL을 사용하여 결과 테이블에 대해 추가 처리를 수행하고, 애드온 및 외부 라이브러리를 사용할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_0.png" alt="이미지"></p>
<h1>초기 알고리즘 빌드</h1>
<p>다음은 알고리즘을 구축할 때 따를 전략입니다:</p>
<div class="content-ad"></div>
<ul>
<li>블로킹 — 공통 속성을 기반으로 데이터 집합을 더 작은 블록이나 그룹으로 나누어 레코드 비교의 계산 복잡성을 줄이는 것입니다. 이는 검색 공간을 좁히고 유사도 검색 작업의 효율성을 향상시킵니다.</li>
<li>전처리 — 생 데이터를 정리하고 표준화하여 대문자를 소문자로 변환하거나 구두점을 제거, 불용어를 제거하는 등의 작업을 통해 분석에 준비시킵니다. 이 단계는 데이터 품질을 향상시키고 잡음을 줄입니다.</li>
<li>유사도 검색 모델 적용 — 모델을 적용하여 레코드 간의 유사도나 거리를 토큰화된 표현을 기반으로 계산하는 것입니다. 이는 코사인 유사도나 편집 거리와 같은 메트릭을 사용하여 레코드 링킹이나 중복 제거와 같은 작업을 위해 유사한 쌍을 식별하는 데 도움이 됩니다.</li>
</ul>
<h2>블로킹</h2>
<p>내 데이터 집합은 매우 불균형합니다 — 첫 번째 테이블에는 1,361,373개의 엔티티가 있고 두 번째 테이블에는 37,171개의 회사 이름이 있습니다. 전처리하지 않은 테이블에서 일치를 시도하면 알고리즘은 매우 오랜 시간이 걸릴 것입니다.</p>
<p>테이블을 블로킹하려면 2개의 데이터 집합 간에 어떤 공통된 특성이 있는지 확인해야 합니다. 내 경우, 회사들은 모두 내부 프로젝트와 관련이 있습니다. 그러므로 다음과 같이 작업할 것입니다:</p>
<div class="content-ad"></div>
<ul>
<li>작은 테이블에서 고유한 회사 이름과 프로젝트 코드를 추출합니다.</li>
<li>프로젝트 코드를 순회하면서 큰 테이블에서 해당 코드를 찾습니다.</li>
<li>해당 프로젝트의 모든 자금을 매핑하고 큰 테이블에서 제외합니다.</li>
<li>다음 프로젝트에 대해 반복합니다!</li>
</ul>
<p>이렇게 하면 매 반복마다 큰 데이터 세트를 줄이게 되며, 프로젝트 수준에서의 필터링된 데이터 세트로 인해 매핑이 빠릅니다.</p>
<p>이제 두 테이블을 프로젝트 코드로 필터링할 것입니다.</p>
<p>이 방식으로 접근하면, 작은 테이블에는 프로젝트 'ABC'에 대해 매핑할 406개의 행만 있고, 큰 테이블에는 매핑 대상인 15,973개의 행이 있습니다. 이는 최초 테이블에서 상당한 감소입니다.</p>
<div class="content-ad"></div>
<h2>프로그램 구조</h2>
<p>이 프로젝트는 SQL 서버에서 Python 및 SQL 함수를 모두 포함할 것입니다. 아래는 프로그램이 어떻게 작동하는지 더 명확히 이해하기 위해 간략히 스케치된 내용입니다:</p>
<p><img src="/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_1.png" alt="프로그램 실행"></p>
<p>프로그램 실행:</p>
<div class="content-ad"></div>
<ul>
<li>프로젝트 코드를 루프로 출력하는 것은이 기능의 가장 간단한 버전입니다.</li>
</ul>
<p>SQL 커서는 너무 많은 리소스를 사용한다는 것이 빨리 드러납니다. 간단히 말해서, 이는 커서가 행 수준에서 작동하고 모든 행을 통과하여 작업을 수행하기 때문입니다.</p>
<p>성능을 향상시키기 위해 임시 테이블을 사용하고 커서를 제거할 것입니다. 여기에 결과 함수가 있습니다:</p>
<p>이제 이 함수는 대형 매핑 테이블에서 해당 프로젝트로 필터링된 프로젝트 코드와 데이터를 선택하는 데 약 3초가 소요됩니다.</p>
<div class="content-ad"></div>
<p>데모 목적으로는 2개의 프로젝트에만 집중할 것이나, 프로덕션 환경에서 작업할 때는 모든 프로젝트에서 함수를 실행할 것입니다.</p>
<p>다음에 사용할 최종 함수는 다음과 같습니다:</p>
<h2>매핑 테이블 준비</h2>
<p>다음 단계는 Python 전처리 및 매핑 함수용 데이터를 준비하는 것입니다. 이를 위해 2개의 데이터셋이 필요합니다:</p>
<div class="content-ad"></div>
<ul>
<li>대형 매핑 테이블에서 프로젝트 코드로 필터링된 데이터</li>
<li>소기업 테이블에서 프로젝트 코드로 필터링된 데이터</li>
</ul>
<p>여기에 2개의 테이블에서 선택된 데이터가 포함된 업데이트된 함수가 있습니다:</p>
<p>이 함수를 통해 각 프로젝트에 대한 프로젝트, 회사 이름 및 소스를 얻을 수 있습니다.</p>
<p>이제 파이썬에 대비되었습니다!</p>
<div class="content-ad"></div>
<h1>SQL에서의 Python 실행</h1>
<p>SQL Server에서 Python은 sp_execute_external_script을 통해 SQL Server 내에서 Python 코드를 직접 실행할 수 있게 해줍니다.</p>
<p>SQL과 Python 간의 데이터 교환을 통해 Python의 기능을 SQL 워크플로에 통합할 수 있습니다. 제공된 예시에서는 Python 스크립트가 실행되어 입력 데이터에서 pandas DataFrame을 생성합니다.</p>
<p>결과는 단일 출력으로 반환됩니다.</p>
<div class="content-ad"></div>
<p>대박이네요!</p>
<p>SQL에서 Python을 실행하는 중요한 몇 가지 사항이 있습니다:</p>
<ul>
<li>문자열은 작은 따옴표(')가 아닌 큰 따옴표(")로 정의됩니다. 특히 정규표현식을 사용할 때 이를 확인해야 하며, 오류 추적에 시간을 낭비하지 않도록 주의해주세요.</li>
<li>하나의 출력만 허용됩니다. 따라서 Python 코드는 출력에서 하나의 테이블을 생성하게 됩니다.</li>
<li>디버깅을 위해 print 문을 사용하고 결과를 SQL 서버의 '메시지' 탭에 인쇄된 결과를 확인할 수 있습니다. 아래와 같이:</li>
</ul>
<p><img src="/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_2.png" alt="image"></p>
<div class="content-ad"></div>
<h2>SQL에서 파이썬 라이브러리</h2>
<p>SQL Server에서는 여러 라이브러리가 미리 설치되어 있고 쉽게 접근할 수 있습니다. 이러한 라이브러리들의 완전한 목록을 보려면 다음 명령을 실행할 수 있습니다:</p>
<p>다음은 결과의 예시입니다:</p>
<p><img src="/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_3.png" alt="이미지"></p>
<div class="content-ad"></div>
<h1>파이썬으로 텍스트 매칭하기</h1>
<p>우리가 생성한 테이블에 돌아와서, 이제 파이썬을 사용하여 여러 소스에서 가져온 회사 이름을 매칭할 수 있습니다. 우리의 파이썬 절차는 긴 테이블을 입력받아 매핑된 엔티티들이 있는 테이블을 출력할 것입니다. 이는 작은 회사 테이블의 각 레코드 옆에 있는 대형 매핑 테이블에서 가장 가능성이 높은 매치를 보여주어야 합니다.</p>
<p><img src="/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_4.png" alt="이미지"></p>
<p>이를 위해 먼저 SQL 절차에 파이썬 함수를 추가해 보겠습니다. 첫 번째 단계는 데이터 집합을 단순히 Python에 넣는 것입니다. 이를 샘플 데이터셋으로 하고, 그런 다음 실제 데이터로 하겠습니다. 여기에 코드가 있습니다:</p>
<div class="content-ad"></div>
<p>이 시스템을 통해 두 테이블을 모두 파이썬 함수의 입력으로 전달할 수 있습니다. 그러면 두 테이블을 출력으로 출력합니다.</p>
<h2>파이썬에서의 전처리</h2>
<p>문자열을 효과적으로 일치시키기 위해 Python에서 몇 가지 전처리를 수행해야 합니다. 이는 다음을 포함합니다:</p>
<ul>
<li>강세 음절 및 다른 언어별 특수 문자 제거</li>
<li>공백 제거</li>
<li>구두점 제거</li>
</ul>
<div class="content-ad"></div>
<p>SQL 작업 중 정렬을 사용하여 첫 번째 단계를 진행하고, 나머지 두 단계는 Python 함수의 전처리 단계에서 처리될 것입니다.</p>
<p>다음은 전처리가 포함된 함수의 모습입니다:</p>
<p>결과는 3개의 열로 나타납니다. 하나는 회사 이름을 소문자로 작성하고, 두 번째 열은 프로젝트 열이며, 세 번째 열은 출처입니다.</p>
<h2>Python에서 문자열 매칭하기</h2>
<div class="content-ad"></div>
<p>여기서는 사용할 수 있는 라이브러리의 수가 제한되어 있기 때문에 창의적이어야 합니다. 따라서 먼저 결과물이 어떻게 보여야 하는지 결정해봅시다.</p>
<p>소스 2에서 가져온 데이터를 소스 1의 데이터와 일치시키려고 합니다. 따라서 소스 2의 각 값에 대해 일치하는 값의 그룹이 있어야 하며, 일치 정도를 나타내는 점수도 있어야 합니다.</p>
<p><img src="/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_5.png" alt="image"></p>
<p>작업을 단순화하기 위해 라이브러리를 가져오지 않고 내장된 python 라이브러리를 먼저 사용할 것입니다.</p>
<div class="content-ad"></div>
<p>로직:</p>
<ul>
<li>각 프로젝트를 반복</li>
<li>소스에 따라 자금을 포함한 테이블을 만듭니다. 여기서 소스 1은 매핑 데이터가 있는 큰 테이블이고, 2는 초기 회사 데이터 세트입니다.</li>
<li>작은 데이터 세트에서 데이터를 배열로 선택합니다.</li>
<li>결과 배열의 각 요소를 대형 매핑 데이터 프레임의 각 요소와 비교합니다.</li>
<li>각 엔터티의 점수를 반환합니다.</li>
</ul>
<p>코드:</p>
<p>그리고 여기가 최종 결과입니다:</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_6.png" alt="table"></p>
<p>이 테이블에서는 각 회사 이름, 해당 프로젝트, 그리고 소스(대형 매핑 테이블에서인지 소규모 회사 테이블에서인지)가 나열되어 있습니다. 오른쪽의 점수는 소스 2와 소스 1 사이의 회사 이름 유사성 메트릭을 나타냅니다. 소스 2에서 비롯된 company4는 항상 점수가 1인 100% 일치임을 유의하는 것이 중요합니다.</p>
<p>SQL Server 내에서 Machine Learning Services를 통해 Python 스크립트를 실행하는 것은 인-데이터베이스 분석 및 기계 학습 작업을 가능하게 하는 강력한 기능입니다. 이 통합은 데이터 이동이 필요 없이 직접적인 데이터 접근을 가능하게 하여 데이터 집중적 작업의 성능과 보안을 크게 최적화합니다.</p>
<p>그러나 주의해야 할 제한 사항이 있습니다. 이 환경은 하나의 입력을 지원하므로 SQL 컨텍스트 내에서 직접 수행될 수 있는 작업의 복잡성을 제한할 수 있습니다. 또한 기본 라이브러리에서 지원되지 않는 일부 유형의 데이터 분석이나 기계 학습 작업에 대한 대안 솔루션이 필요할 수 있습니다. 게다가 사용자들은 복잡한 Python 코드가 포함된 T-SQL 쿼리에서의 복잡한 간격과 같은 SQL Server 환경의 복잡성을 해결해야 하며, 이러한 것들은 오류와 혼란의 원인이 될 수 있습니다.</p>
<div class="content-ad"></div>
<p>이러한 도전에도 불구하고, SQL Server에서 Python을 실행하는 것이 유리한 여러 응용 프로그램이 있습니다:</p>
<ol>
<li>
<p>데이터 정제 및 변환 — Python을 SQL Server에서 직접 사용하여 복잡한 데이터 전처리 작업을 수행할 수 있습니다. 예를 들어, 누락된 데이터를 처리하거나 값을 정규화하여 후속 분석이나 보고 전에.</p>
</li>
<li>
<p>예측 분석 — SQL Server 내에서 Python 기계 학습 모델을 직접 배포하면 실시간 예측이 가능해집니다. 고객 이탈 또는 판매 예측과 같은 실시간 데이터베이스 데이터를 사용하는 예측이 가능합니다.</p>
</li>
<li>
<p>고급 분석 — Python의 능력을 활용하여 데이터베이스에서 직접 고급 통계 분석과 데이터 마이닝을 수행할 수 있습니다. 이를 통해 데이터 전송 지연 없이 의사 결정 프로세스를 도와줍니다.</p>
</li>
</ol>
<div class="content-ad"></div>
<ol start="4">
<li>
<p>자동 보고 및 시각화 — Python 스크립트는 SQL Server 데이터에서 직접 데이터 시각화와 보고서를 생성할 수 있어 자동 업데이트와 대시보드를 가능하게 합니다.</p>
</li>
<li>
<p>머신 러닝 모델 운영화 — SQL Server에 Python을 통합함으로써, 모델을 데이터베이스 환경 내에서 직접 업데이트하고 관리할 수 있어 운영적 워크플로우를 간소화시킵니다.</p>
</li>
</ol>
<p>마지막으로, Python이 SQL Server에서 실행되는 것은 일부 도전을 동반하지만, 데이터 처리, 분석 및 예측 모델링을 데이터베이스 환경 내에서 직접 향상시키고 간소화시키는 다양한 가능성을 열어줍니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SQL Server의 비밀 기능 - SQL Server에서 Python 및 애드온을 네이티브로 실행하기","description":"","date":"2024-05-16 17:19","slug":"2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer","content":"\n\n## 파이썬 라이브러리를 가져와서 SQL 테이블을 조작하고 출력하며, SQL 서버를 떠나지 않고 작업하세요.\n\n## 문제\n\n이 프로젝트에서는 두 가지 서로 다른 출처에서 가져온 37,000개의 회사 이름을 관리하는 어려움에 직면합니다. 이 복잡성은 이러한 소스 간에 동일한 회사가 어떻게 나열되는지에 대한 잠재적인 불일치에 있습니다.\n\n## 목표\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문서의 목표는 Microsoft SQL Server 내에서 Python을 네이티브로 실행하는 방법을 가르치는 것입니다. 또한 SQL을 사용하여 결과 테이블에 대해 추가 처리를 수행하고, 애드온 및 외부 라이브러리를 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_0.png)\n\n# 초기 알고리즘 빌드\n\n다음은 알고리즘을 구축할 때 따를 전략입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 블로킹 — 공통 속성을 기반으로 데이터 집합을 더 작은 블록이나 그룹으로 나누어 레코드 비교의 계산 복잡성을 줄이는 것입니다. 이는 검색 공간을 좁히고 유사도 검색 작업의 효율성을 향상시킵니다.\n- 전처리 — 생 데이터를 정리하고 표준화하여 대문자를 소문자로 변환하거나 구두점을 제거, 불용어를 제거하는 등의 작업을 통해 분석에 준비시킵니다. 이 단계는 데이터 품질을 향상시키고 잡음을 줄입니다.\n- 유사도 검색 모델 적용 — 모델을 적용하여 레코드 간의 유사도나 거리를 토큰화된 표현을 기반으로 계산하는 것입니다. 이는 코사인 유사도나 편집 거리와 같은 메트릭을 사용하여 레코드 링킹이나 중복 제거와 같은 작업을 위해 유사한 쌍을 식별하는 데 도움이 됩니다.\n\n## 블로킹\n\n내 데이터 집합은 매우 불균형합니다 — 첫 번째 테이블에는 1,361,373개의 엔티티가 있고 두 번째 테이블에는 37,171개의 회사 이름이 있습니다. 전처리하지 않은 테이블에서 일치를 시도하면 알고리즘은 매우 오랜 시간이 걸릴 것입니다.\n\n테이블을 블로킹하려면 2개의 데이터 집합 간에 어떤 공통된 특성이 있는지 확인해야 합니다. 내 경우, 회사들은 모두 내부 프로젝트와 관련이 있습니다. 그러므로 다음과 같이 작업할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작은 테이블에서 고유한 회사 이름과 프로젝트 코드를 추출합니다.\n- 프로젝트 코드를 순회하면서 큰 테이블에서 해당 코드를 찾습니다.\n- 해당 프로젝트의 모든 자금을 매핑하고 큰 테이블에서 제외합니다.\n- 다음 프로젝트에 대해 반복합니다!\n\n이렇게 하면 매 반복마다 큰 데이터 세트를 줄이게 되며, 프로젝트 수준에서의 필터링된 데이터 세트로 인해 매핑이 빠릅니다.\n\n이제 두 테이블을 프로젝트 코드로 필터링할 것입니다.\n\n이 방식으로 접근하면, 작은 테이블에는 프로젝트 'ABC'에 대해 매핑할 406개의 행만 있고, 큰 테이블에는 매핑 대상인 15,973개의 행이 있습니다. 이는 최초 테이블에서 상당한 감소입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 프로그램 구조\n\n이 프로젝트는 SQL 서버에서 Python 및 SQL 함수를 모두 포함할 것입니다. 아래는 프로그램이 어떻게 작동하는지 더 명확히 이해하기 위해 간략히 스케치된 내용입니다:\n\n![프로그램 실행](/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_1.png)\n\n프로그램 실행:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 프로젝트 코드를 루프로 출력하는 것은이 기능의 가장 간단한 버전입니다.\n\nSQL 커서는 너무 많은 리소스를 사용한다는 것이 빨리 드러납니다. 간단히 말해서, 이는 커서가 행 수준에서 작동하고 모든 행을 통과하여 작업을 수행하기 때문입니다.\n\n성능을 향상시키기 위해 임시 테이블을 사용하고 커서를 제거할 것입니다. 여기에 결과 함수가 있습니다:\n\n이제 이 함수는 대형 매핑 테이블에서 해당 프로젝트로 필터링된 프로젝트 코드와 데이터를 선택하는 데 약 3초가 소요됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데모 목적으로는 2개의 프로젝트에만 집중할 것이나, 프로덕션 환경에서 작업할 때는 모든 프로젝트에서 함수를 실행할 것입니다.\n\n다음에 사용할 최종 함수는 다음과 같습니다:\n\n## 매핑 테이블 준비\n\n다음 단계는 Python 전처리 및 매핑 함수용 데이터를 준비하는 것입니다. 이를 위해 2개의 데이터셋이 필요합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 대형 매핑 테이블에서 프로젝트 코드로 필터링된 데이터\n- 소기업 테이블에서 프로젝트 코드로 필터링된 데이터\n\n여기에 2개의 테이블에서 선택된 데이터가 포함된 업데이트된 함수가 있습니다:\n\n이 함수를 통해 각 프로젝트에 대한 프로젝트, 회사 이름 및 소스를 얻을 수 있습니다.\n\n이제 파이썬에 대비되었습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# SQL에서의 Python 실행\n\nSQL Server에서 Python은 sp_execute_external_script을 통해 SQL Server 내에서 Python 코드를 직접 실행할 수 있게 해줍니다.\n\nSQL과 Python 간의 데이터 교환을 통해 Python의 기능을 SQL 워크플로에 통합할 수 있습니다. 제공된 예시에서는 Python 스크립트가 실행되어 입력 데이터에서 pandas DataFrame을 생성합니다.\n\n결과는 단일 출력으로 반환됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대박이네요!\n\nSQL에서 Python을 실행하는 중요한 몇 가지 사항이 있습니다:\n\n- 문자열은 작은 따옴표(')가 아닌 큰 따옴표(\")로 정의됩니다. 특히 정규표현식을 사용할 때 이를 확인해야 하며, 오류 추적에 시간을 낭비하지 않도록 주의해주세요.\n- 하나의 출력만 허용됩니다. 따라서 Python 코드는 출력에서 하나의 테이블을 생성하게 됩니다.\n- 디버깅을 위해 print 문을 사용하고 결과를 SQL 서버의 '메시지' 탭에 인쇄된 결과를 확인할 수 있습니다. 아래와 같이:\n\n![image](/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## SQL에서 파이썬 라이브러리\n\nSQL Server에서는 여러 라이브러리가 미리 설치되어 있고 쉽게 접근할 수 있습니다. 이러한 라이브러리들의 완전한 목록을 보려면 다음 명령을 실행할 수 있습니다:\n\n다음은 결과의 예시입니다:\n\n![이미지](/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 파이썬으로 텍스트 매칭하기\n\n우리가 생성한 테이블에 돌아와서, 이제 파이썬을 사용하여 여러 소스에서 가져온 회사 이름을 매칭할 수 있습니다. 우리의 파이썬 절차는 긴 테이블을 입력받아 매핑된 엔티티들이 있는 테이블을 출력할 것입니다. 이는 작은 회사 테이블의 각 레코드 옆에 있는 대형 매핑 테이블에서 가장 가능성이 높은 매치를 보여주어야 합니다.\n\n![이미지](/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_4.png)\n\n이를 위해 먼저 SQL 절차에 파이썬 함수를 추가해 보겠습니다. 첫 번째 단계는 데이터 집합을 단순히 Python에 넣는 것입니다. 이를 샘플 데이터셋으로 하고, 그런 다음 실제 데이터로 하겠습니다. 여기에 코드가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 시스템을 통해 두 테이블을 모두 파이썬 함수의 입력으로 전달할 수 있습니다. 그러면 두 테이블을 출력으로 출력합니다.\n\n## 파이썬에서의 전처리\n\n문자열을 효과적으로 일치시키기 위해 Python에서 몇 가지 전처리를 수행해야 합니다. 이는 다음을 포함합니다:\n\n- 강세 음절 및 다른 언어별 특수 문자 제거\n- 공백 제거\n- 구두점 제거\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQL 작업 중 정렬을 사용하여 첫 번째 단계를 진행하고, 나머지 두 단계는 Python 함수의 전처리 단계에서 처리될 것입니다.\n\n다음은 전처리가 포함된 함수의 모습입니다:\n\n결과는 3개의 열로 나타납니다. 하나는 회사 이름을 소문자로 작성하고, 두 번째 열은 프로젝트 열이며, 세 번째 열은 출처입니다.\n\n## Python에서 문자열 매칭하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서는 사용할 수 있는 라이브러리의 수가 제한되어 있기 때문에 창의적이어야 합니다. 따라서 먼저 결과물이 어떻게 보여야 하는지 결정해봅시다.\n\n소스 2에서 가져온 데이터를 소스 1의 데이터와 일치시키려고 합니다. 따라서 소스 2의 각 값에 대해 일치하는 값의 그룹이 있어야 하며, 일치 정도를 나타내는 점수도 있어야 합니다.\n\n![image](/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_5.png)\n\n작업을 단순화하기 위해 라이브러리를 가져오지 않고 내장된 python 라이브러리를 먼저 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로직:\n\n- 각 프로젝트를 반복\n- 소스에 따라 자금을 포함한 테이블을 만듭니다. 여기서 소스 1은 매핑 데이터가 있는 큰 테이블이고, 2는 초기 회사 데이터 세트입니다.\n- 작은 데이터 세트에서 데이터를 배열로 선택합니다.\n- 결과 배열의 각 요소를 대형 매핑 데이터 프레임의 각 요소와 비교합니다.\n- 각 엔터티의 점수를 반환합니다.\n\n코드:\n\n그리고 여기가 최종 결과입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![table](/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_6.png)\n\n이 테이블에서는 각 회사 이름, 해당 프로젝트, 그리고 소스(대형 매핑 테이블에서인지 소규모 회사 테이블에서인지)가 나열되어 있습니다. 오른쪽의 점수는 소스 2와 소스 1 사이의 회사 이름 유사성 메트릭을 나타냅니다. 소스 2에서 비롯된 company4는 항상 점수가 1인 100% 일치임을 유의하는 것이 중요합니다.\n\nSQL Server 내에서 Machine Learning Services를 통해 Python 스크립트를 실행하는 것은 인-데이터베이스 분석 및 기계 학습 작업을 가능하게 하는 강력한 기능입니다. 이 통합은 데이터 이동이 필요 없이 직접적인 데이터 접근을 가능하게 하여 데이터 집중적 작업의 성능과 보안을 크게 최적화합니다.\n\n그러나 주의해야 할 제한 사항이 있습니다. 이 환경은 하나의 입력을 지원하므로 SQL 컨텍스트 내에서 직접 수행될 수 있는 작업의 복잡성을 제한할 수 있습니다. 또한 기본 라이브러리에서 지원되지 않는 일부 유형의 데이터 분석이나 기계 학습 작업에 대한 대안 솔루션이 필요할 수 있습니다. 게다가 사용자들은 복잡한 Python 코드가 포함된 T-SQL 쿼리에서의 복잡한 간격과 같은 SQL Server 환경의 복잡성을 해결해야 하며, 이러한 것들은 오류와 혼란의 원인이 될 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 도전에도 불구하고, SQL Server에서 Python을 실행하는 것이 유리한 여러 응용 프로그램이 있습니다:\n\n1. 데이터 정제 및 변환 — Python을 SQL Server에서 직접 사용하여 복잡한 데이터 전처리 작업을 수행할 수 있습니다. 예를 들어, 누락된 데이터를 처리하거나 값을 정규화하여 후속 분석이나 보고 전에.\n\n2. 예측 분석 — SQL Server 내에서 Python 기계 학습 모델을 직접 배포하면 실시간 예측이 가능해집니다. 고객 이탈 또는 판매 예측과 같은 실시간 데이터베이스 데이터를 사용하는 예측이 가능합니다.\n\n3. 고급 분석 — Python의 능력을 활용하여 데이터베이스에서 직접 고급 통계 분석과 데이터 마이닝을 수행할 수 있습니다. 이를 통해 데이터 전송 지연 없이 의사 결정 프로세스를 도와줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 자동 보고 및 시각화 — Python 스크립트는 SQL Server 데이터에서 직접 데이터 시각화와 보고서를 생성할 수 있어 자동 업데이트와 대시보드를 가능하게 합니다.\n\n5. 머신 러닝 모델 운영화 — SQL Server에 Python을 통합함으로써, 모델을 데이터베이스 환경 내에서 직접 업데이트하고 관리할 수 있어 운영적 워크플로우를 간소화시킵니다.\n\n마지막으로, Python이 SQL Server에서 실행되는 것은 일부 도전을 동반하지만, 데이터 처리, 분석 및 예측 모델링을 데이터베이스 환경 내에서 직접 향상시키고 간소화시키는 다양한 가능성을 열어줍니다.","ogImage":{"url":"/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_0.png"},"coverImage":"/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e파이썬 라이브러리를 가져와서 SQL 테이블을 조작하고 출력하며, SQL 서버를 떠나지 않고 작업하세요.\u003c/h2\u003e\n\u003ch2\u003e문제\u003c/h2\u003e\n\u003cp\u003e이 프로젝트에서는 두 가지 서로 다른 출처에서 가져온 37,000개의 회사 이름을 관리하는 어려움에 직면합니다. 이 복잡성은 이러한 소스 간에 동일한 회사가 어떻게 나열되는지에 대한 잠재적인 불일치에 있습니다.\u003c/p\u003e\n\u003ch2\u003e목표\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 문서의 목표는 Microsoft SQL Server 내에서 Python을 네이티브로 실행하는 방법을 가르치는 것입니다. 또한 SQL을 사용하여 결과 테이블에 대해 추가 처리를 수행하고, 애드온 및 외부 라이브러리를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e초기 알고리즘 빌드\u003c/h1\u003e\n\u003cp\u003e다음은 알고리즘을 구축할 때 따를 전략입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e블로킹 — 공통 속성을 기반으로 데이터 집합을 더 작은 블록이나 그룹으로 나누어 레코드 비교의 계산 복잡성을 줄이는 것입니다. 이는 검색 공간을 좁히고 유사도 검색 작업의 효율성을 향상시킵니다.\u003c/li\u003e\n\u003cli\u003e전처리 — 생 데이터를 정리하고 표준화하여 대문자를 소문자로 변환하거나 구두점을 제거, 불용어를 제거하는 등의 작업을 통해 분석에 준비시킵니다. 이 단계는 데이터 품질을 향상시키고 잡음을 줄입니다.\u003c/li\u003e\n\u003cli\u003e유사도 검색 모델 적용 — 모델을 적용하여 레코드 간의 유사도나 거리를 토큰화된 표현을 기반으로 계산하는 것입니다. 이는 코사인 유사도나 편집 거리와 같은 메트릭을 사용하여 레코드 링킹이나 중복 제거와 같은 작업을 위해 유사한 쌍을 식별하는 데 도움이 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e블로킹\u003c/h2\u003e\n\u003cp\u003e내 데이터 집합은 매우 불균형합니다 — 첫 번째 테이블에는 1,361,373개의 엔티티가 있고 두 번째 테이블에는 37,171개의 회사 이름이 있습니다. 전처리하지 않은 테이블에서 일치를 시도하면 알고리즘은 매우 오랜 시간이 걸릴 것입니다.\u003c/p\u003e\n\u003cp\u003e테이블을 블로킹하려면 2개의 데이터 집합 간에 어떤 공통된 특성이 있는지 확인해야 합니다. 내 경우, 회사들은 모두 내부 프로젝트와 관련이 있습니다. 그러므로 다음과 같이 작업할 것입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e작은 테이블에서 고유한 회사 이름과 프로젝트 코드를 추출합니다.\u003c/li\u003e\n\u003cli\u003e프로젝트 코드를 순회하면서 큰 테이블에서 해당 코드를 찾습니다.\u003c/li\u003e\n\u003cli\u003e해당 프로젝트의 모든 자금을 매핑하고 큰 테이블에서 제외합니다.\u003c/li\u003e\n\u003cli\u003e다음 프로젝트에 대해 반복합니다!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이렇게 하면 매 반복마다 큰 데이터 세트를 줄이게 되며, 프로젝트 수준에서의 필터링된 데이터 세트로 인해 매핑이 빠릅니다.\u003c/p\u003e\n\u003cp\u003e이제 두 테이블을 프로젝트 코드로 필터링할 것입니다.\u003c/p\u003e\n\u003cp\u003e이 방식으로 접근하면, 작은 테이블에는 프로젝트 'ABC'에 대해 매핑할 406개의 행만 있고, 큰 테이블에는 매핑 대상인 15,973개의 행이 있습니다. 이는 최초 테이블에서 상당한 감소입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e프로그램 구조\u003c/h2\u003e\n\u003cp\u003e이 프로젝트는 SQL 서버에서 Python 및 SQL 함수를 모두 포함할 것입니다. 아래는 프로그램이 어떻게 작동하는지 더 명확히 이해하기 위해 간략히 스케치된 내용입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_1.png\" alt=\"프로그램 실행\"\u003e\u003c/p\u003e\n\u003cp\u003e프로그램 실행:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e프로젝트 코드를 루프로 출력하는 것은이 기능의 가장 간단한 버전입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSQL 커서는 너무 많은 리소스를 사용한다는 것이 빨리 드러납니다. 간단히 말해서, 이는 커서가 행 수준에서 작동하고 모든 행을 통과하여 작업을 수행하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e성능을 향상시키기 위해 임시 테이블을 사용하고 커서를 제거할 것입니다. 여기에 결과 함수가 있습니다:\u003c/p\u003e\n\u003cp\u003e이제 이 함수는 대형 매핑 테이블에서 해당 프로젝트로 필터링된 프로젝트 코드와 데이터를 선택하는 데 약 3초가 소요됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e데모 목적으로는 2개의 프로젝트에만 집중할 것이나, 프로덕션 환경에서 작업할 때는 모든 프로젝트에서 함수를 실행할 것입니다.\u003c/p\u003e\n\u003cp\u003e다음에 사용할 최종 함수는 다음과 같습니다:\u003c/p\u003e\n\u003ch2\u003e매핑 테이블 준비\u003c/h2\u003e\n\u003cp\u003e다음 단계는 Python 전처리 및 매핑 함수용 데이터를 준비하는 것입니다. 이를 위해 2개의 데이터셋이 필요합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e대형 매핑 테이블에서 프로젝트 코드로 필터링된 데이터\u003c/li\u003e\n\u003cli\u003e소기업 테이블에서 프로젝트 코드로 필터링된 데이터\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e여기에 2개의 테이블에서 선택된 데이터가 포함된 업데이트된 함수가 있습니다:\u003c/p\u003e\n\u003cp\u003e이 함수를 통해 각 프로젝트에 대한 프로젝트, 회사 이름 및 소스를 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 파이썬에 대비되었습니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eSQL에서의 Python 실행\u003c/h1\u003e\n\u003cp\u003eSQL Server에서 Python은 sp_execute_external_script을 통해 SQL Server 내에서 Python 코드를 직접 실행할 수 있게 해줍니다.\u003c/p\u003e\n\u003cp\u003eSQL과 Python 간의 데이터 교환을 통해 Python의 기능을 SQL 워크플로에 통합할 수 있습니다. 제공된 예시에서는 Python 스크립트가 실행되어 입력 데이터에서 pandas DataFrame을 생성합니다.\u003c/p\u003e\n\u003cp\u003e결과는 단일 출력으로 반환됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e대박이네요!\u003c/p\u003e\n\u003cp\u003eSQL에서 Python을 실행하는 중요한 몇 가지 사항이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e문자열은 작은 따옴표(')가 아닌 큰 따옴표(\")로 정의됩니다. 특히 정규표현식을 사용할 때 이를 확인해야 하며, 오류 추적에 시간을 낭비하지 않도록 주의해주세요.\u003c/li\u003e\n\u003cli\u003e하나의 출력만 허용됩니다. 따라서 Python 코드는 출력에서 하나의 테이블을 생성하게 됩니다.\u003c/li\u003e\n\u003cli\u003e디버깅을 위해 print 문을 사용하고 결과를 SQL 서버의 '메시지' 탭에 인쇄된 결과를 확인할 수 있습니다. 아래와 같이:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003eSQL에서 파이썬 라이브러리\u003c/h2\u003e\n\u003cp\u003eSQL Server에서는 여러 라이브러리가 미리 설치되어 있고 쉽게 접근할 수 있습니다. 이러한 라이브러리들의 완전한 목록을 보려면 다음 명령을 실행할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e다음은 결과의 예시입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e파이썬으로 텍스트 매칭하기\u003c/h1\u003e\n\u003cp\u003e우리가 생성한 테이블에 돌아와서, 이제 파이썬을 사용하여 여러 소스에서 가져온 회사 이름을 매칭할 수 있습니다. 우리의 파이썬 절차는 긴 테이블을 입력받아 매핑된 엔티티들이 있는 테이블을 출력할 것입니다. 이는 작은 회사 테이블의 각 레코드 옆에 있는 대형 매핑 테이블에서 가장 가능성이 높은 매치를 보여주어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이를 위해 먼저 SQL 절차에 파이썬 함수를 추가해 보겠습니다. 첫 번째 단계는 데이터 집합을 단순히 Python에 넣는 것입니다. 이를 샘플 데이터셋으로 하고, 그런 다음 실제 데이터로 하겠습니다. 여기에 코드가 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 시스템을 통해 두 테이블을 모두 파이썬 함수의 입력으로 전달할 수 있습니다. 그러면 두 테이블을 출력으로 출력합니다.\u003c/p\u003e\n\u003ch2\u003e파이썬에서의 전처리\u003c/h2\u003e\n\u003cp\u003e문자열을 효과적으로 일치시키기 위해 Python에서 몇 가지 전처리를 수행해야 합니다. 이는 다음을 포함합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e강세 음절 및 다른 언어별 특수 문자 제거\u003c/li\u003e\n\u003cli\u003e공백 제거\u003c/li\u003e\n\u003cli\u003e구두점 제거\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eSQL 작업 중 정렬을 사용하여 첫 번째 단계를 진행하고, 나머지 두 단계는 Python 함수의 전처리 단계에서 처리될 것입니다.\u003c/p\u003e\n\u003cp\u003e다음은 전처리가 포함된 함수의 모습입니다:\u003c/p\u003e\n\u003cp\u003e결과는 3개의 열로 나타납니다. 하나는 회사 이름을 소문자로 작성하고, 두 번째 열은 프로젝트 열이며, 세 번째 열은 출처입니다.\u003c/p\u003e\n\u003ch2\u003ePython에서 문자열 매칭하기\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기서는 사용할 수 있는 라이브러리의 수가 제한되어 있기 때문에 창의적이어야 합니다. 따라서 먼저 결과물이 어떻게 보여야 하는지 결정해봅시다.\u003c/p\u003e\n\u003cp\u003e소스 2에서 가져온 데이터를 소스 1의 데이터와 일치시키려고 합니다. 따라서 소스 2의 각 값에 대해 일치하는 값의 그룹이 있어야 하며, 일치 정도를 나타내는 점수도 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_5.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e작업을 단순화하기 위해 라이브러리를 가져오지 않고 내장된 python 라이브러리를 먼저 사용할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e로직:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e각 프로젝트를 반복\u003c/li\u003e\n\u003cli\u003e소스에 따라 자금을 포함한 테이블을 만듭니다. 여기서 소스 1은 매핑 데이터가 있는 큰 테이블이고, 2는 초기 회사 데이터 세트입니다.\u003c/li\u003e\n\u003cli\u003e작은 데이터 세트에서 데이터를 배열로 선택합니다.\u003c/li\u003e\n\u003cli\u003e결과 배열의 각 요소를 대형 매핑 데이터 프레임의 각 요소와 비교합니다.\u003c/li\u003e\n\u003cli\u003e각 엔터티의 점수를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e코드:\u003c/p\u003e\n\u003cp\u003e그리고 여기가 최종 결과입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer_6.png\" alt=\"table\"\u003e\u003c/p\u003e\n\u003cp\u003e이 테이블에서는 각 회사 이름, 해당 프로젝트, 그리고 소스(대형 매핑 테이블에서인지 소규모 회사 테이블에서인지)가 나열되어 있습니다. 오른쪽의 점수는 소스 2와 소스 1 사이의 회사 이름 유사성 메트릭을 나타냅니다. 소스 2에서 비롯된 company4는 항상 점수가 1인 100% 일치임을 유의하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003eSQL Server 내에서 Machine Learning Services를 통해 Python 스크립트를 실행하는 것은 인-데이터베이스 분석 및 기계 학습 작업을 가능하게 하는 강력한 기능입니다. 이 통합은 데이터 이동이 필요 없이 직접적인 데이터 접근을 가능하게 하여 데이터 집중적 작업의 성능과 보안을 크게 최적화합니다.\u003c/p\u003e\n\u003cp\u003e그러나 주의해야 할 제한 사항이 있습니다. 이 환경은 하나의 입력을 지원하므로 SQL 컨텍스트 내에서 직접 수행될 수 있는 작업의 복잡성을 제한할 수 있습니다. 또한 기본 라이브러리에서 지원되지 않는 일부 유형의 데이터 분석이나 기계 학습 작업에 대한 대안 솔루션이 필요할 수 있습니다. 게다가 사용자들은 복잡한 Python 코드가 포함된 T-SQL 쿼리에서의 복잡한 간격과 같은 SQL Server 환경의 복잡성을 해결해야 하며, 이러한 것들은 오류와 혼란의 원인이 될 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이러한 도전에도 불구하고, SQL Server에서 Python을 실행하는 것이 유리한 여러 응용 프로그램이 있습니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e데이터 정제 및 변환 — Python을 SQL Server에서 직접 사용하여 복잡한 데이터 전처리 작업을 수행할 수 있습니다. 예를 들어, 누락된 데이터를 처리하거나 값을 정규화하여 후속 분석이나 보고 전에.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e예측 분석 — SQL Server 내에서 Python 기계 학습 모델을 직접 배포하면 실시간 예측이 가능해집니다. 고객 이탈 또는 판매 예측과 같은 실시간 데이터베이스 데이터를 사용하는 예측이 가능합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e고급 분석 — Python의 능력을 활용하여 데이터베이스에서 직접 고급 통계 분석과 데이터 마이닝을 수행할 수 있습니다. 이를 통해 데이터 전송 지연 없이 의사 결정 프로세스를 도와줍니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e\n\u003cp\u003e자동 보고 및 시각화 — Python 스크립트는 SQL Server 데이터에서 직접 데이터 시각화와 보고서를 생성할 수 있어 자동 업데이트와 대시보드를 가능하게 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e머신 러닝 모델 운영화 — SQL Server에 Python을 통합함으로써, 모델을 데이터베이스 환경 내에서 직접 업데이트하고 관리할 수 있어 운영적 워크플로우를 간소화시킵니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e마지막으로, Python이 SQL Server에서 실행되는 것은 일부 도전을 동반하지만, 데이터 처리, 분석 및 예측 모델링을 데이터베이스 환경 내에서 직접 향상시키고 간소화시키는 다양한 가능성을 열어줍니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-16-SQLServersSecretFeatureRunPythonandAdd-OnsNativelyInSQLServer"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>