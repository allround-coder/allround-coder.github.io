<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs" data-gatsby-head="true"/><meta name="twitter:title" content="Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-13 00:34" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_buildManifest.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 13, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png" alt="Node.js Logo"/></p>
<p>Node.js의 핵심에 오신 것을 환영합니다. 여기는 이벤트가 다스리고 비동기가 왕이 되는 곳입니다. 이 시리즈에서는 Node.js의 이벤트 주도 아키텍처를 해독하고 비동기 능력에 대해 자세히 살펴볼 것입니다. 초보자이든 경험이 풍부한 개발자이든 Node.js의 비밀을 해제할 준비를 해주세요. 여정을 시작해봅시다!</p>
<ol>
<li>이벤트 주도 아키텍처:</li>
</ol>
<p>Node.js는 이벤트 주도 아키텍처에서 작동하며 작업은 이벤트 루프를 통해 비동기적으로 관리됩니다. 이 루프는 바쁜 교차로에서 교통 규제자와 유사하게 여러 작업을 효율적으로 동시에 처리합니다. 들어오는 요청이나 파일 작업과 같은 이벤트는 논블로킹 방식으로 대기열에 추가되고 처리되어 각 작업이 완료될 때까지 기다릴 필요 없이 원활하게 실행됩니다. 이 아키텍처를 통해 Node.js는 다양한 동시 작업을 효율적으로 처리하여 반응성이 뛰어나고 확장 가능한 애플리케이션을 만들기에 이상적입니다.</p>
<ol start="2">
<li>Node.js에서 이벤트 처리하기:</li>
</ol>
<p>Node.js에서는 EventEmitter 클래스를 통해 이벤트 처리를 원활하게 할 수 있습니다. 이 클래스를 사용하면 개발자가 사용자 정의 이벤트를 생성하고 해당 이벤트에 대한 리스너를 붙일 수 있어 응용 프로그램 내에서 비동기 통신을 쉽게 할 수 있습니다.</p>
<p>다음은 Node.js에서 이벤트 처리를 시작하는 방법입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// EventEmitter 클래스를 가져오기</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">EventEmitter</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;events&#x27;</span>);

<span class="hljs-comment">// EventEmitter 클래스의 인스턴스 생성</span>
<span class="hljs-keyword">const</span> myEmitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();

<span class="hljs-comment">// 사용자 정의 이벤트 생성 및 리스너 붙이기</span>
myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;sayHi&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hi!&#x27;</span>);
});

myEmitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;sayGoodbye&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Goodbye!&#x27;</span>);
});

<span class="hljs-comment">// 이벤트 발생</span>
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;sayHi&#x27;</span>); <span class="hljs-comment">// 출력: Hi!</span>
myEmitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;sayGoodbye&#x27;</span>); <span class="hljs-comment">// 출력: Goodbye!</span>
</code></pre>
<ol start="3">
<li>비동기 프로그래밍:</li>
</ol>
<p>비동기 프로그래밍은 Node.js에서의 기본 개념으로, 작업을 주 프로그램 흐름과 독립적으로 실행할 수 있게 합니다. 이 접근 방식은 I/O 작업, 네트워크 요청 또는 데이터베이스 쿼리와 같이 완료까지 시간이 걸릴 수 있는 작업을 처리할 때 주 프로그램 흐름을 차단하지 않고 다른 작업을 실행하는 데 중요합니다.</p>
<p>Node.js에서 비동기 프로그래밍은 고성능이면서 블로킹되지 않는 애플리케이션을 개발하는 데 필수적입니다. 다음은 Node.js에서 비동기 프로그래밍에 사용되는 주요 메커니즘을 살펴보겠습니다:</p>
<ul>
<li>콜백 함수: 콜백 함수는 다른 함수의 인수로 전달되어 작업이 완료되면 실행됩니다. Node.js에서 비동기 프로그래밍의 기본 구성 요소입니다. 그러나 여러 중첩된 콜백을 관리하는 것은 코드를 읽거나 유지하기 어렵게 만들 수 있는 콜백 지옥에 빠질 수 있습니다.</li>
<li>프로미스: 프로미스는 비동기 작업을 처리하고 콜백 지옥을 줄이는 더 구조화된 방법을 제공합니다. 프로미스는 비동기 작업의 최종 완료(또는 실패)를 나타내며 .then() 및 .catch() 메서드를 사용하여 작업을 연결할 수 있습니다. 프로미스는 코드 가독성과 유지 관리성을 향상시킵니다.</li>
<li>Async/Await: Async/Await은 ES2017 (ES8)에서 소개된 구문 설탕으로, 비동기 코드를 더욱 간단하게 작성할 수 있습니다. 이를 사용하면 동기적으로 보이는 비동기 코드를 작성할 수 있어 이해하기 쉽고 유지하기 쉽습니다. Async 함수는 암묵적으로 프로미스를 반환하며, await 키워드는 async 함수 내에서 비동기 작업의 완료를 기다리기 위해 사용됩니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 콜백 함수를 사용한 예시</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;파일을 읽는 중 오류 발생:&#x27;</span>, err);
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;파일 내용:&#x27;</span>, data);
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;파일 읽는 중...&#x27;</span>);

<span class="hljs-comment">// 프로미스를 사용한 예시</span>
<span class="hljs-keyword">const</span> readFilePromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
  fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-title function_">reject</span>(err);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-title function_">resolve</span>(data);
  });
});

readFilePromise
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;파일 내용:&#x27;</span>, data);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;파일을 읽는 중 오류 발생:&#x27;</span>, err);
  });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;파일 읽는 중...&#x27;</span>);

<span class="hljs-comment">// Async/Await를 사용한 예시</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">readFileAsync</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fs.<span class="hljs-property">promises</span>.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;example.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;파일 내용:&#x27;</span>, data);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;파일을 읽는 중 오류 발생:&#x27;</span>, err);
  }
}

<span class="hljs-title function_">readFileAsync</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;파일 읽는 중...&#x27;</span>);
</code></pre>
<ol start="4">
<li>이벤트 루프의 동작:</li>
</ol>
<p>이벤트 루프는 Node.js의 핵심으로, 비동기 작업을 효율적으로 실행하는 역할을 합니다. 이벤트 루프의 내부 동작 방식을 간단히 살펴보고, Node.js에서 비동기 작업을 처리하는 방법에 대해 알아봅시다.</p>
<ol>
<li>이벤트 큐:</li>
</ol>
<ul>
<li>Node.js에서 I/O 작업이나 타이머와 같은 비동기 작업을 만나면, 이러한 작업은 즉시 실행되지 않습니다.</li>
<li>대신에, 이러한 작업은 이벤트 큐에 들어가서 처리될 차례를 기다립니다.</li>
</ul>
<ol start="2">
<li>이벤트 루프 반복:</li>
</ol>
<ul>
<li>이벤트 루프는 계속해서 반복하면서, 실행 준비가 된 이벤트 큐의 작업을 확인합니다.</li>
<li>이벤트 큐가 비어있다면, 이벤트 루프는 작업이 추가될 때까지 기다립니다.</li>
</ul>
<ol start="3">
<li>실행 단계:</li>
</ol>
<ul>
<li>이벤트 큐에서 작업이 검색되면 실행 단계로 들어갑니다.</li>
<li>작업이 처리되고 동기 작업인 경우 즉시 실행됩니다.</li>
</ul>
<ol start="4">
<li>Non-Blocking I/O:</li>
</ol>
<ul>
<li>비동기 작업인 I/O 작업과 같은 작업의 경우, 이벤트 루프는 작업을 기저 시스템에 위임하여 Node.js가 그 동안 다른 작업을 계속 실행할 수 있도록 합니다.</li>
<li>비동기 작업이 완료되면 해당 작업과 연결된 콜백이 콜백 큐에 배치됩니다.</li>
</ul>
<ol start="5">
<li>콜백 큐:</li>
</ol>
<ul>
<li>비동기 콜백은 연관된 작업들이 완료된 후에 콜백 큐에 저장됩니다.</li>
<li>이벤트 루프는 각 반복마다 콜백 큐를 확인하여 실행 대기 중인 콜백이 있는지 확인합니다.</li>
</ul>
<ol start="6">
<li>콜백 실행:</li>
</ol>
<ul>
<li>이벤트 루프가 콜백 큐에서 콜백을 만나면 하나씩 검색하고 실행합니다.</li>
<li>이 과정을 통해 비동기 작업이 완료된 순서대로 실행되어 프로그램 로직의 무결성을 유지합니다.</li>
</ul>
<p><img src="/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_1.png" alt="이미지"/></p>
<ul>
<li>
<p>이벤트 기반 아키텍처:</p>
</li>
<li>
<p>Node.js는 이벤트 기반 아키텍처에서 작동하며, 작업들이 이벤트 루프를 통해 비동기적으로 관리됩니다.</p>
</li>
<li>
<p>이벤트 루프는 이벤트를 대기열에 넣고 처리함으로써 여러 작업을 효율적으로 동시에 처리합니다.</p>
</li>
</ul>
<ol start="2">
<li>Node.js에서 이벤트 처리:</li>
</ol>
<ul>
<li>Node.js는 EventEmitter 클래스를 제공하여 사용자 정의 이벤트를 생성하고 해당 이벤트에 청취자(listener)를 연결할 수 있습니다.</li>
<li>이벤트와 청취자는 Node.js 애플리케이션 내에서 비동기 통신을 용이하게 만듭니다.</li>
</ul>
<ol start="3">
<li>비동기 프로그래밍:</li>
</ol>
<ul>
<li>비동기 프로그래밍은 주 프로그램 흐름과 독립적으로 작업을 실행할 수 있어 애플리케이션의 응답성을 향상시킵니다.</li>
<li>콜백, 프로미스, 그리고 async/await는 Node.js에서 비동기 작업을 처리하는 데 사용되는 메커니즘입니다.</li>
<li>콜백은 기본적이지만 콜백 지옥에 빠질 수 있습니다. 프로미스와 async/await는 보다 구조화되고 가독성이 좋은 대안을 제공합니다.</li>
</ul>
<ol start="4">
<li>이벤트 루프 동작:</li>
</ol>
<ul>
<li>Node.js의 이벤트 루프는 지속적으로 반복하여 이벤트 큐에서 작업을 확인하고 처리합니다.</li>
<li>I/O 작업과 같은 비동기 작업은 하부 시스템에 위임되어 Node.js가 여러 동시 작업을 효율적으로 처리할 수 있게 합니다.</li>
</ul></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nodejs에서 이벤트 기반 및 비동기 프로그래밍 탐험하기","description":"","date":"2024-05-13 00:34","slug":"2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs","content":"\n\n![Node.js Logo](/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png)\n\nNode.js의 핵심에 오신 것을 환영합니다. 여기는 이벤트가 다스리고 비동기가 왕이 되는 곳입니다. 이 시리즈에서는 Node.js의 이벤트 주도 아키텍처를 해독하고 비동기 능력에 대해 자세히 살펴볼 것입니다. 초보자이든 경험이 풍부한 개발자이든 Node.js의 비밀을 해제할 준비를 해주세요. 여정을 시작해봅시다!\n\n1. 이벤트 주도 아키텍처:\n\nNode.js는 이벤트 주도 아키텍처에서 작동하며 작업은 이벤트 루프를 통해 비동기적으로 관리됩니다. 이 루프는 바쁜 교차로에서 교통 규제자와 유사하게 여러 작업을 효율적으로 동시에 처리합니다. 들어오는 요청이나 파일 작업과 같은 이벤트는 논블로킹 방식으로 대기열에 추가되고 처리되어 각 작업이 완료될 때까지 기다릴 필요 없이 원활하게 실행됩니다. 이 아키텍처를 통해 Node.js는 다양한 동시 작업을 효율적으로 처리하여 반응성이 뛰어나고 확장 가능한 애플리케이션을 만들기에 이상적입니다.\n\n\n\n2. Node.js에서 이벤트 처리하기:\n\nNode.js에서는 EventEmitter 클래스를 통해 이벤트 처리를 원활하게 할 수 있습니다. 이 클래스를 사용하면 개발자가 사용자 정의 이벤트를 생성하고 해당 이벤트에 대한 리스너를 붙일 수 있어 응용 프로그램 내에서 비동기 통신을 쉽게 할 수 있습니다.\n\n다음은 Node.js에서 이벤트 처리를 시작하는 방법입니다:\n\n```js\n// EventEmitter 클래스를 가져오기\nconst EventEmitter = require('events');\n\n// EventEmitter 클래스의 인스턴스 생성\nconst myEmitter = new EventEmitter();\n\n// 사용자 정의 이벤트 생성 및 리스너 붙이기\nmyEmitter.on('sayHi', () =\u003e {\n  console.log('Hi!');\n});\n\nmyEmitter.on('sayGoodbye', () =\u003e {\n  console.log('Goodbye!');\n});\n\n// 이벤트 발생\nmyEmitter.emit('sayHi'); // 출력: Hi!\nmyEmitter.emit('sayGoodbye'); // 출력: Goodbye!\n```\n\n\n\n3. 비동기 프로그래밍:\n\n비동기 프로그래밍은 Node.js에서의 기본 개념으로, 작업을 주 프로그램 흐름과 독립적으로 실행할 수 있게 합니다. 이 접근 방식은 I/O 작업, 네트워크 요청 또는 데이터베이스 쿼리와 같이 완료까지 시간이 걸릴 수 있는 작업을 처리할 때 주 프로그램 흐름을 차단하지 않고 다른 작업을 실행하는 데 중요합니다.\n\nNode.js에서 비동기 프로그래밍은 고성능이면서 블로킹되지 않는 애플리케이션을 개발하는 데 필수적입니다. 다음은 Node.js에서 비동기 프로그래밍에 사용되는 주요 메커니즘을 살펴보겠습니다:\n\n- 콜백 함수: 콜백 함수는 다른 함수의 인수로 전달되어 작업이 완료되면 실행됩니다. Node.js에서 비동기 프로그래밍의 기본 구성 요소입니다. 그러나 여러 중첩된 콜백을 관리하는 것은 코드를 읽거나 유지하기 어렵게 만들 수 있는 콜백 지옥에 빠질 수 있습니다.\n- 프로미스: 프로미스는 비동기 작업을 처리하고 콜백 지옥을 줄이는 더 구조화된 방법을 제공합니다. 프로미스는 비동기 작업의 최종 완료(또는 실패)를 나타내며 .then() 및 .catch() 메서드를 사용하여 작업을 연결할 수 있습니다. 프로미스는 코드 가독성과 유지 관리성을 향상시킵니다.\n- Async/Await: Async/Await은 ES2017 (ES8)에서 소개된 구문 설탕으로, 비동기 코드를 더욱 간단하게 작성할 수 있습니다. 이를 사용하면 동기적으로 보이는 비동기 코드를 작성할 수 있어 이해하기 쉽고 유지하기 쉽습니다. Async 함수는 암묵적으로 프로미스를 반환하며, await 키워드는 async 함수 내에서 비동기 작업의 완료를 기다리기 위해 사용됩니다.\n\n\n\n```js\n// 콜백 함수를 사용한 예시\nconst fs = require('fs');\n\nfs.readFile('example.txt', 'utf8', (err, data) =\u003e {\n  if (err) {\n    console.error('파일을 읽는 중 오류 발생:', err);\n    return;\n  }\n  console.log('파일 내용:', data);\n});\n\nconsole.log('파일 읽는 중...');\n\n// 프로미스를 사용한 예시\nconst readFilePromise = new Promise((resolve, reject) =\u003e {\n  fs.readFile('example.txt', 'utf8', (err, data) =\u003e {\n    if (err) {\n      reject(err);\n      return;\n    }\n    resolve(data);\n  });\n});\n\nreadFilePromise\n  .then(data =\u003e {\n    console.log('파일 내용:', data);\n  })\n  .catch(err =\u003e {\n    console.error('파일을 읽는 중 오류 발생:', err);\n  });\n\nconsole.log('파일 읽는 중...');\n\n// Async/Await를 사용한 예시\nasync function readFileAsync() {\n  try {\n    const data = await fs.promises.readFile('example.txt', 'utf8');\n    console.log('파일 내용:', data);\n  } catch (err) {\n    console.error('파일을 읽는 중 오류 발생:', err);\n  }\n}\n\nreadFileAsync();\nconsole.log('파일 읽는 중...');\n```\n\n4. 이벤트 루프의 동작:\n\n이벤트 루프는 Node.js의 핵심으로, 비동기 작업을 효율적으로 실행하는 역할을 합니다. 이벤트 루프의 내부 동작 방식을 간단히 살펴보고, Node.js에서 비동기 작업을 처리하는 방법에 대해 알아봅시다.\n\n1. 이벤트 큐:\n\n\n\n- Node.js에서 I/O 작업이나 타이머와 같은 비동기 작업을 만나면, 이러한 작업은 즉시 실행되지 않습니다.\n- 대신에, 이러한 작업은 이벤트 큐에 들어가서 처리될 차례를 기다립니다.\n\n2. 이벤트 루프 반복:\n\n- 이벤트 루프는 계속해서 반복하면서, 실행 준비가 된 이벤트 큐의 작업을 확인합니다.\n- 이벤트 큐가 비어있다면, 이벤트 루프는 작업이 추가될 때까지 기다립니다.\n\n3. 실행 단계:\n\n\n\n- 이벤트 큐에서 작업이 검색되면 실행 단계로 들어갑니다.\n- 작업이 처리되고 동기 작업인 경우 즉시 실행됩니다.\n\n4. Non-Blocking I/O:\n\n- 비동기 작업인 I/O 작업과 같은 작업의 경우, 이벤트 루프는 작업을 기저 시스템에 위임하여 Node.js가 그 동안 다른 작업을 계속 실행할 수 있도록 합니다.\n- 비동기 작업이 완료되면 해당 작업과 연결된 콜백이 콜백 큐에 배치됩니다.\n\n5. 콜백 큐:\n\n\n\n- 비동기 콜백은 연관된 작업들이 완료된 후에 콜백 큐에 저장됩니다.\n- 이벤트 루프는 각 반복마다 콜백 큐를 확인하여 실행 대기 중인 콜백이 있는지 확인합니다.\n\n6. 콜백 실행:\n\n- 이벤트 루프가 콜백 큐에서 콜백을 만나면 하나씩 검색하고 실행합니다.\n- 이 과정을 통해 비동기 작업이 완료된 순서대로 실행되어 프로그램 로직의 무결성을 유지합니다.\n\n![이미지](/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_1.png)\n\n\n\n- 이벤트 기반 아키텍처:\n\n- Node.js는 이벤트 기반 아키텍처에서 작동하며, 작업들이 이벤트 루프를 통해 비동기적으로 관리됩니다.\n- 이벤트 루프는 이벤트를 대기열에 넣고 처리함으로써 여러 작업을 효율적으로 동시에 처리합니다.\n\n2. Node.js에서 이벤트 처리:\n\n- Node.js는 EventEmitter 클래스를 제공하여 사용자 정의 이벤트를 생성하고 해당 이벤트에 청취자(listener)를 연결할 수 있습니다.\n- 이벤트와 청취자는 Node.js 애플리케이션 내에서 비동기 통신을 용이하게 만듭니다.\n\n\n\n3. 비동기 프로그래밍:\n\n- 비동기 프로그래밍은 주 프로그램 흐름과 독립적으로 작업을 실행할 수 있어 애플리케이션의 응답성을 향상시킵니다.\n- 콜백, 프로미스, 그리고 async/await는 Node.js에서 비동기 작업을 처리하는 데 사용되는 메커니즘입니다.\n- 콜백은 기본적이지만 콜백 지옥에 빠질 수 있습니다. 프로미스와 async/await는 보다 구조화되고 가독성이 좋은 대안을 제공합니다.\n\n4. 이벤트 루프 동작:\n\n- Node.js의 이벤트 루프는 지속적으로 반복하여 이벤트 큐에서 작업을 확인하고 처리합니다.\n- I/O 작업과 같은 비동기 작업은 하부 시스템에 위임되어 Node.js가 여러 동시 작업을 효율적으로 처리할 수 있게 합니다.","ogImage":{"url":"/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png"},"coverImage":"/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png","tag":["Tech"],"readingTime":5},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    ol: \"ol\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ul: \"ul\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_0.png\",\n        alt: \"Node.js Logo\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Node.js의 핵심에 오신 것을 환영합니다. 여기는 이벤트가 다스리고 비동기가 왕이 되는 곳입니다. 이 시리즈에서는 Node.js의 이벤트 주도 아키텍처를 해독하고 비동기 능력에 대해 자세히 살펴볼 것입니다. 초보자이든 경험이 풍부한 개발자이든 Node.js의 비밀을 해제할 준비를 해주세요. 여정을 시작해봅시다!\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이벤트 주도 아키텍처:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Node.js는 이벤트 주도 아키텍처에서 작동하며 작업은 이벤트 루프를 통해 비동기적으로 관리됩니다. 이 루프는 바쁜 교차로에서 교통 규제자와 유사하게 여러 작업을 효율적으로 동시에 처리합니다. 들어오는 요청이나 파일 작업과 같은 이벤트는 논블로킹 방식으로 대기열에 추가되고 처리되어 각 작업이 완료될 때까지 기다릴 필요 없이 원활하게 실행됩니다. 이 아키텍처를 통해 Node.js는 다양한 동시 작업을 효율적으로 처리하여 반응성이 뛰어나고 확장 가능한 애플리케이션을 만들기에 이상적입니다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Node.js에서 이벤트 처리하기:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Node.js에서는 EventEmitter 클래스를 통해 이벤트 처리를 원활하게 할 수 있습니다. 이 클래스를 사용하면 개발자가 사용자 정의 이벤트를 생성하고 해당 이벤트에 대한 리스너를 붙일 수 있어 응용 프로그램 내에서 비동기 통신을 쉽게 할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 Node.js에서 이벤트 처리를 시작하는 방법입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// EventEmitter 클래스를 가져오기\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"EventEmitter\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"require\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'events'\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// EventEmitter 클래스의 인스턴스 생성\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" myEmitter = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"EventEmitter\"\n        }), \"();\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 사용자 정의 이벤트 생성 및 리스너 붙이기\"\n        }), \"\\nmyEmitter.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"on\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sayHi'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Hi!'\"\n        }), \");\\n});\\n\\nmyEmitter.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"on\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sayGoodbye'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Goodbye!'\"\n        }), \");\\n});\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 이벤트 발생\"\n        }), \"\\nmyEmitter.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"emit\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sayHi'\"\n        }), \"); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 출력: Hi!\"\n        }), \"\\nmyEmitter.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"emit\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sayGoodbye'\"\n        }), \"); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 출력: Goodbye!\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"비동기 프로그래밍:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"비동기 프로그래밍은 Node.js에서의 기본 개념으로, 작업을 주 프로그램 흐름과 독립적으로 실행할 수 있게 합니다. 이 접근 방식은 I/O 작업, 네트워크 요청 또는 데이터베이스 쿼리와 같이 완료까지 시간이 걸릴 수 있는 작업을 처리할 때 주 프로그램 흐름을 차단하지 않고 다른 작업을 실행하는 데 중요합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Node.js에서 비동기 프로그래밍은 고성능이면서 블로킹되지 않는 애플리케이션을 개발하는 데 필수적입니다. 다음은 Node.js에서 비동기 프로그래밍에 사용되는 주요 메커니즘을 살펴보겠습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"콜백 함수: 콜백 함수는 다른 함수의 인수로 전달되어 작업이 완료되면 실행됩니다. Node.js에서 비동기 프로그래밍의 기본 구성 요소입니다. 그러나 여러 중첩된 콜백을 관리하는 것은 코드를 읽거나 유지하기 어렵게 만들 수 있는 콜백 지옥에 빠질 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"프로미스: 프로미스는 비동기 작업을 처리하고 콜백 지옥을 줄이는 더 구조화된 방법을 제공합니다. 프로미스는 비동기 작업의 최종 완료(또는 실패)를 나타내며 .then() 및 .catch() 메서드를 사용하여 작업을 연결할 수 있습니다. 프로미스는 코드 가독성과 유지 관리성을 향상시킵니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Async/Await: Async/Await은 ES2017 (ES8)에서 소개된 구문 설탕으로, 비동기 코드를 더욱 간단하게 작성할 수 있습니다. 이를 사용하면 동기적으로 보이는 비동기 코드를 작성할 수 있어 이해하기 쉽고 유지하기 쉽습니다. Async 함수는 암묵적으로 프로미스를 반환하며, await 키워드는 async 함수 내에서 비동기 작업의 완료를 기다리기 위해 사용됩니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 콜백 함수를 사용한 예시\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" fs = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"require\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'fs'\"\n        }), \");\\n\\nfs.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"readFile\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'example.txt'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'utf8'\"\n        }), \", \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"err, data\"\n          }), \") =\u003e\"]\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (err) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"error\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'파일을 읽는 중 오류 발생:'\"\n        }), \", err);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \";\\n  }\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'파일 내용:'\"\n        }), \", data);\\n});\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'파일 읽는 중...'\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 프로미스를 사용한 예시\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" readFilePromise = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Promise\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"resolve, reject\"\n          }), \") =\u003e\"]\n        }), \" {\\n  fs.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"readFile\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'example.txt'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'utf8'\"\n        }), \", \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"err, data\"\n          }), \") =\u003e\"]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (err) {\\n      \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"reject\"\n        }), \"(err);\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \";\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"resolve\"\n        }), \"(data);\\n  });\\n});\\n\\nreadFilePromise\\n  .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"then\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"data\"\n          }), \" =\u003e\"]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'파일 내용:'\"\n        }), \", data);\\n  })\\n  .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"catch\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"err\"\n          }), \" =\u003e\"]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"error\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'파일을 읽는 중 오류 발생:'\"\n        }), \", err);\\n  });\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'파일 읽는 중...'\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Async/Await를 사용한 예시\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"readFileAsync\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" data = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" fs.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"promises\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"readFile\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'example.txt'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'utf8'\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'파일 내용:'\"\n        }), \", data);\\n  } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"catch\"\n        }), \" (err) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"error\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'파일을 읽는 중 오류 발생:'\"\n        }), \", err);\\n  }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"readFileAsync\"\n        }), \"();\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'파일 읽는 중...'\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"4\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이벤트 루프의 동작:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이벤트 루프는 Node.js의 핵심으로, 비동기 작업을 효율적으로 실행하는 역할을 합니다. 이벤트 루프의 내부 동작 방식을 간단히 살펴보고, Node.js에서 비동기 작업을 처리하는 방법에 대해 알아봅시다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이벤트 큐:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Node.js에서 I/O 작업이나 타이머와 같은 비동기 작업을 만나면, 이러한 작업은 즉시 실행되지 않습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"대신에, 이러한 작업은 이벤트 큐에 들어가서 처리될 차례를 기다립니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이벤트 루프 반복:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이벤트 루프는 계속해서 반복하면서, 실행 준비가 된 이벤트 큐의 작업을 확인합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이벤트 큐가 비어있다면, 이벤트 루프는 작업이 추가될 때까지 기다립니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"실행 단계:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이벤트 큐에서 작업이 검색되면 실행 단계로 들어갑니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"작업이 처리되고 동기 작업인 경우 즉시 실행됩니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"4\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Non-Blocking I/O:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"비동기 작업인 I/O 작업과 같은 작업의 경우, 이벤트 루프는 작업을 기저 시스템에 위임하여 Node.js가 그 동안 다른 작업을 계속 실행할 수 있도록 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"비동기 작업이 완료되면 해당 작업과 연결된 콜백이 콜백 큐에 배치됩니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"5\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"콜백 큐:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"비동기 콜백은 연관된 작업들이 완료된 후에 콜백 큐에 저장됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이벤트 루프는 각 반복마다 콜백 큐를 확인하여 실행 대기 중인 콜백이 있는지 확인합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"6\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"콜백 실행:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이벤트 루프가 콜백 큐에서 콜백을 만나면 하나씩 검색하고 실행합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이 과정을 통해 비동기 작업이 완료된 순서대로 실행되어 프로그램 로직의 무결성을 유지합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs_1.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"이벤트 기반 아키텍처:\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Node.js는 이벤트 기반 아키텍처에서 작동하며, 작업들이 이벤트 루프를 통해 비동기적으로 관리됩니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"이벤트 루프는 이벤트를 대기열에 넣고 처리함으로써 여러 작업을 효율적으로 동시에 처리합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Node.js에서 이벤트 처리:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Node.js는 EventEmitter 클래스를 제공하여 사용자 정의 이벤트를 생성하고 해당 이벤트에 청취자(listener)를 연결할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이벤트와 청취자는 Node.js 애플리케이션 내에서 비동기 통신을 용이하게 만듭니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"비동기 프로그래밍:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"비동기 프로그래밍은 주 프로그램 흐름과 독립적으로 작업을 실행할 수 있어 애플리케이션의 응답성을 향상시킵니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"콜백, 프로미스, 그리고 async/await는 Node.js에서 비동기 작업을 처리하는 데 사용되는 메커니즘입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"콜백은 기본적이지만 콜백 지옥에 빠질 수 있습니다. 프로미스와 async/await는 보다 구조화되고 가독성이 좋은 대안을 제공합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"4\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이벤트 루프 동작:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Node.js의 이벤트 루프는 지속적으로 반복하여 이벤트 큐에서 작업을 확인하고 처리합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"I/O 작업과 같은 비동기 작업은 하부 시스템에 위임되어 Node.js가 여러 동시 작업을 효율적으로 처리할 수 있게 합니다.\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-13-ExploringEvent-DrivenandAsynchronousProgramminginNodejs"},"buildId":"uXJWf9GNc_Ux38RlnQJQc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>