<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>React Native 리스트의 성능을 개선하는 방법 FlatList 최적화 가이드 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="React Native 리스트의 성능을 개선하는 방법 FlatList 최적화 가이드 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="React Native 리스트의 성능을 개선하는 방법 FlatList 최적화 가이드 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide" data-gatsby-head="true"/><meta name="twitter:title" content="React Native 리스트의 성능을 개선하는 방법 FlatList 최적화 가이드 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 18:48" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">React Native 리스트의 성능을 개선하는 방법 FlatList 최적화 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="React Native 리스트의 성능을 개선하는 방법 FlatList 최적화 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">26<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>소개</p>
<p><img src="/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_0.png" alt="이미지"></p>
<p>FlatList란 무엇인가요?</p>
<ul>
<li>성능 최적화: FlatList는 대규모 목록을 효율적으로 렌더링하기 위해 설계된 React Native 컴포넌트입니다. "게으른 로딩"이라는 기술을 통해 이를 수행합니다. 이는 화면에 현재 표시된 항목만 렌더링하고 사용자가 스크롤할 때 컴포넌트를 재활용함으로써 작동합니다.</li>
<li>이를 통해 많은 양의 데이터를 다룰 때에도 앱이 부드럽고 반응성 있게 유지됩니다.</li>
<li>필수적인 목록 기능: FlatList는 사용자 친화적인 목록을 구축하는 데 필수적인 다양한 기능을 제공합니다.</li>
<li>매우 맞춤화 가능: 속성, 스타일링, 사용자 정의 컴포넌트를 사용하여 목록의 모양과 느낌을 쉽게 조정할 수 있습니다.</li>
</ul>
<p>FlatList를 사용하는 주요 장점들</p>
<ul>
<li>성능, 성능, 성능: FlatList는 긴 목록을 처리할 때 빛을 발합니다. 게으르게 로딩하고 최적화 기술을 사용하여 데이터가 많아져도 앱이 느려지지 않도록 합니다.</li>
<li>내장 기능: 바퀴를 재창조할 필요 없어요. FlatList에는 현대적인 목록에서 기대할 수 있는 기능이 탑재되어 있습니다: 당겨서 새로고침, 헤더, 푸터, 항목 구분선, 특정 위치로 스크롤 등.</li>
<li>크로스 플랫폼: 하나의 코드 베이스로 iOS와 Android 기기에서 목록이 매끄럽게 작동합니다.</li>
</ul>
<h2>핵심 기능들:</h2>
<ul>
<li>FlatList는 상자에서 바로 제공되는 주요 기능들로, 매우 유용하게 만들어집니다:</li>
<li>크로스 플랫폼: iOS와 Android에서 일관되게 작동합니다.</li>
<li>수평 모드: 표준 수직 및 수평 목록 간 전환 가능.</li>
<li>가시성 콜백: 보이는 항목을 추적하여, 사용자가 끝에 가까워질 때 추가 데이터를 로드할 수 있도록 합니다.</li>
<li>헤더 및 푸터: 헤더와 푸터를 목록에 쉽게 통합합니다.</li>
<li>구분선: 목록 항목 사이의 구분선 외관을 사용자 정의할 수 있습니다.</li>
<li>당겨서 새로고침: 사용자가 목록 내용을 새로 고칠 수 있는 일반적인 인터페이스.</li>
<li>스크롤 로딩 (무한 스크롤): 사용자가 스크롤할 때 자연스럽게 더 많은 데이터를 로드합니다.</li>
<li>ScrollToIndex: 목록에서 특정 항목으로 빠르게 이동합니다.</li>
<li>여러 열: 그리드 형식으로 목록을 렌더링합니다.</li>
</ul>
<p>FlatList을 언제 사용해볼까요?</p>
<ul>
<li>연락처 목록 표시</li>
<li>이미지 갤러리 만들기</li>
<li>뉴스 피드 또는 타임라인 구축</li>
<li>전자상거래 앱에서 제품 목록 렌더링</li>
<li>스크롤 가능한 항목 목록을 표시해야 하는 모든 시나리오</li>
</ul>
<p>간단한 예제로 설명해 보겠습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FlatList</span>, <span class="hljs-title class_">Text</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;

<span class="hljs-keyword">const</span> myData = [ <span class="hljs-comment">/* 데이터 객체 배열 */</span> ];

<span class="hljs-keyword">const</span> <span class="hljs-title function_">renderItem</span> = (<span class="hljs-params">{ item }</span>) => (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span>></span>{item.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span></span> 
);

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">FlatList</span>
  <span class="hljs-attr">data</span>=<span class="hljs-string">{myData}</span>
  <span class="hljs-attr">renderItem</span>=<span class="hljs-string">{renderItem}</span> 
  <span class="hljs-attr">keyExtractor</span>=<span class="hljs-string">{item</span> =></span> item.id} 
/></span>
</code></pre>
<p>중요한 속성 설명해 드릴게요</p>
<ul>
<li>data: 리스트에 표시하려는 데이터 배열입니다.</li>
<li>renderItem: 데이터 배열에서 개별 항목을 가져와서 시각적으로 표현하는 JSX 구조를 반환하는 함수입니다.</li>
<li>keyExtractor: 각 목록 항목에 대한 고유한 키를 생성하는 함수입니다 (React의 렌더링 최적화에 중요합니다).</li>
</ul>
<h2>FlatList가 동적으로 업데이트되도록 만드는 방법</h2>
<p>이 핵심은 FlatList가 응용 프로그램 데이터 변경에 따라 디스플레이를 어떻게 업데이트할지 제어하는 데 있습니다.</p>
<ul>
<li>
<p>선택 가능한 항목: FlatList에서 항목을 선택할 때 시각적으로 변경되도록 하는 것이 목표입니다 (예: 선택된 항목 강조 표시). 이를 위해 다음이 필요합니다:</p>
</li>
<li>
<p>상태(State): 현재 선택된 항목의 ID를 추적하기 위해 selectedId와 같은 상태 변수가 필요합니다.</p>
</li>
<li>
<p>시각적 스타일링: renderItem 함수 내부에서 항목의 ID가 선택된 ID와 일치하는지 여부에 따라 다른 스타일을 적용해야 합니다.</p>
</li>
</ul>
<p>extraData - 업데이트의 핵심:</p>
<ul>
<li>FlatList는 PureComponent이므로 생성자에서 직접 변경된 경우에만 다시 렌더링됩니다.</li>
<li>항목을 선택하는 경우 대부분 FlatList 자체의 속성 외부에서 상태를 변경하므로, extraData='selectedId'를 사용하여 selectedId 상태 변수가 변경될 때마다 FlatList가 다시 렌더링되어야 함을 알립니다.</li>
</ul>
<p>keyExtractor - 고유 키 보장하기:</p>
<ul>
<li>keyExtractor는 React에서 리스트를 업데이트할 때 효율적으로 사용됩니다. 데이터의 각 항목에서 고유 키(일반적으로 ID)를 추출하는 방법을 제공합니다.</li>
</ul>
<p>예시</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FlatList</span>, <span class="hljs-title class_">View</span>, <span class="hljs-title class_">StyleSheet</span>, <span class="hljs-title class_">TouchableOpacity</span>, <span class="hljs-title class_">Text</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;

<span class="hljs-keyword">const</span> recipes = [
  { <span class="hljs-attr">id</span>: <span class="hljs-string">'recipe1'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'맛있는 팬케이크'</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-string">'recipe2'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'초콜릿 케이크'</span> },
  <span class="hljs-comment">// ... 더 많은 레시피</span>
];

<span class="hljs-keyword">const</span> <span class="hljs-title function_">RecipeCard</span> = (<span class="hljs-params">{ recipe, onFavoriteToggle }</span>) => { <span class="hljs-keyword">return</span> ( <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">TouchableOpacity</span> <span class="hljs-attr">onPress</span>=<span class="hljs-string">{()</span> =></span> onFavoriteToggle(recipe.id)}> <span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.card}</span>></span> <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.title}</span>></span>{recipe.title}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span> {/* 가상: 여기에 이미지가 있을 것 */} <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{recipe.isFavorite</span> ? <span class="hljs-attr">styles.favorite</span> <span class="hljs-attr">:</span> <span class="hljs-attr">styles.notFavorite</span>}></span> {recipe.isFavorite ? '♥ 즐겨찾기한 레시피' : '☆ 즐겨찾기하기' } <span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span> <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span> <span class="hljs-tag">&#x3C;/<span class="hljs-name">TouchableOpacity</span>></span></span> ); };

<span class="hljs-keyword">const</span> <span class="hljs-title function_">RecipeApp</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> [recipesData, setRecipesData] = <span class="hljs-title function_">useState</span>(recipes); <span class="hljs-comment">// 즐겨찾기 관리</span>
  <span class="hljs-keyword">const</span> [selectedId, setSelectedId] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// extraData에 여전히 사용됨</span>

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleFavoriteToggle</span> = (<span class="hljs-params">recipeId</span>) => {
    <span class="hljs-title function_">setRecipesData</span>(<span class="hljs-function"><span class="hljs-params">prevRecipes</span> =></span> prevRecipes.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">recipe</span> =></span>
      recipe.<span class="hljs-property">id</span> === recipeId ? { ...recipe, <span class="hljs-attr">isFavorite</span>: !recipe.<span class="hljs-property">isFavorite</span> } : recipe
    ));
    <span class="hljs-title function_">setSelectedId</span>(recipeId); 
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">FlatList</span>
      <span class="hljs-attr">data</span>=<span class="hljs-string">{recipesData}</span> // <span class="hljs-attr">업데이트된</span> <span class="hljs-attr">데이터</span> <span class="hljs-attr">전달</span>
      <span class="hljs-attr">renderItem</span>=<span class="hljs-string">{({</span> <span class="hljs-attr">item</span> }) =></span> (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">RecipeCard</span> 
         <span class="hljs-attr">recipe</span>=<span class="hljs-string">{item}</span> 
         <span class="hljs-attr">isFavorite</span>=<span class="hljs-string">{item.isFavorite}</span> // <span class="hljs-attr">속성으로</span> <span class="hljs-attr">전달</span>
         <span class="hljs-attr">onFavoriteToggle</span>=<span class="hljs-string">{handleFavoriteToggle}</span> 
        /></span> 
      )} 
      keyExtractor={(item) => item.id} 
      numColumns={2} 
      extraData={selectedId} 
    /></span>
  );
};
</code></pre>
<p>데이터:</p>
<ul>
<li>recipes: 초기 레시피 데이터를 보유한 간단한 배열입니다. 각 레시피에는 id 및 title 속성이 포함되어 있습니다.</li>
</ul>
<p>구성 요소:</p>
<ul>
<li>RecipeCard: 단일 레시피 카드를 표시하는 컴포넌트입니다. 제목, 이미지를 위한 자리 표시자 및 즐겨찾기 버튼이 포함되어 있습니다. 이 버튼은 레시피의 isFavorite 상태에 따라 동적으로 변경됩니다.</li>
<li>RecipeApp: 앱의 주요 컴포넌트입니다. 다음을 관리합니다:</li>
<li>상태:</li>
<li>recipesData: 레시피의 현재 상태를 유지하는 배열로, isFavorite 상태를 포함합니다. 이는 recipes 배열을 사용하여 초기화됩니다.</li>
<li>selectedId: 레시피를 즐겨찾기 추가하거나 취소할 때 FlatList를 다시 렌더링하기 위해 사용됩니다.</li>
<li>handleFavoriteToggle: 레시피를 즐겨찾기 추가/취소하는 논리를 처리하는 함수입니다. 이 함수는 다음을 수행합니다:</li>
<li>recipesData 배열에서 올바른 레시피를 찾습니다.</li>
<li>레시피의 isFavorite 속성을 토글합니다.</li>
<li>다시 렌더링을 트리거하기 위해 setRecipesData를 사용하여 recipesData 상태를 업데이트합니다.</li>
<li>렌더링을 강제로 수행하기 위해 setSelectedId를 통해 selectedId를 업데이트하여 하트/별표가 즉시 업데이트되도록 합니다.</li>
</ul>
<p>아래는 Markdown 형식으로 변환된 텍스트입니다:</p>
<ul>
<li><strong>FlatList</strong>: 레시피 목록을 효율적으로 렌더링하는 데 사용됩니다. 주요 속성은 다음과 같습니다:
<ul>
<li><strong>data</strong>: 현재 즐겨찾기 상태를 반영하도록 recipesData 배열을 사용합니다.</li>
<li><strong>renderItem</strong>: 데이터 내 각 레시피에 대해 RecipeCard 컴포넌트를 렌더링하며, 레시피 데이터와 handleFavoriteToggle 함수를 전달합니다.</li>
<li><strong>keyExtractor</strong>: 각 레시피 객체에서 고유 id 속성을 추출하여 효율적인 추적을 가능하도록 합니다.</li>
<li><strong>numColumns</strong>: 두 개의 열을 갖는 그리드를 생성합니다.</li>
<li><strong>extraData</strong>: 선택된 ID가 변경될 때 (즐겨찾기를 추가하거나 삭제할 때) FlatList가 업데이트된 즐겨찾기 상태를 반영하도록 합니다.</li>
</ul>
</li>
</ul>
<h2>VirtualizedList을 위한 Wrapper로서 FlatList</h2>
<ul>
<li><strong>성능 중점</strong>: FlatList는 효율성을 위해 VirtualizedList 기반으로 구축되었습니다. 화면에 현재 보이는 레시피 카드만 렌더링합니다. 많은 레시피가 있는 경우 부드러운 스크롤링을 위해 중요합니다.</li>
<li><strong>상태 제한</strong>: 레시피 카드가 화면에서 스크롤되어 나가면 (예: 확장된 세부 정보 섹션이 있는 경우) 내부 상태가 기본적으로 유지되지 않습니다. 보통 Redux와 같은 중앙 집중형 저장소에 그러한 데이터를 저장합니다.</li>
</ul>
<p>PureComponent 동작</p>
<ul>
<li>변경 감지: PureComponent인 FlatList는 속성이나 기본 데이터가 실제로 변경될 때만 다시 렌더링되도록 최적화되어 있습니다. 여기서 extraData가 중요한 역할을 하며 레시피를 즐겨찾기로 지정하면 새로 고침이 트리거되어야 함을 알려줍니다.</li>
<li>속성 동등성: 레시피 배열 내의 변경 사항이 감지됩니다. renderItem이 의존하는 모든 요소가 레시피 데이터에 포함되어 있거나 별도의 속성으로 전달되는지 확인하는 것이 중요합니다.</li>
</ul>
<p>메모리 관리 및 부드러운 스크롤링</p>
<ul>
<li>비동기 렌더링: FlatList는 스크롤이 부드럽게 느껴지도록 실제로 보이는 것보다 약간 앞의 내용을 렌더링합니다. 하지만 너무 빠르게 스크롤할 경우, 콘텐츠가로드될 때까지 잠깐 빈 공간이 보일 수 있습니다.</li>
</ul>
<p>keyExtractor</p>
<ul>
<li>중요도: React에서 어떤 레시피 카드가 무엇인지 효율적으로 추적하는 것은 매우 중요합니다. 고유한 ID를 사용하는 것이 이상적인 방법입니다.</li>
</ul>
<h2>ItemSeparatorComponent</h2>
<p>React Native의 FlatList와 관련된 ItemSeparatorComponent의 설명은 다음과 같습니다:</p>
<p>목적:</p>
<ul>
<li>ItemSeparatorComponent 속성을 사용하면 FlatList에 사용자 정의 구성 요소나 요소를 각 항목 사이에 삽입하여 시각적 구분선이나 간격을 만들 수 있습니다.</li>
</ul>
<p>작동 방식:</p>
<ul>
<li>기본값 없음: FlatList에 기본 구분자가 없습니다. ItemSeparatorComponent를 사용하면 간단히 추가할 수 있습니다.</li>
<li>배치: 구분자 구성 요소는 각 항목 사이에 렌더링되며 목록의 맨 위와 맨 아래를 제외합니다.</li>
<li>renderItem 통합: FlatList의 renderItem 함수는 그 내부의 info 매개변수에 속성을 제공합니다:
<ul>
<li>highlighted: 현재 항목이 강조 표시되는지 표시합니다 (예: 눌림).</li>
<li>separators.highlight: 구분자를 강조 표시하는 함수입니다.</li>
<li>separators.unhighlight: 구분자의 강조 표시를 제거하는 함수입니다.</li>
<li>separators.updateProps: 구분자의 다른 사용자 지정 속성을 업데이트하는 함수입니다.</li>
</ul>
</li>
</ul>
<p>유연성:</p>
<ul>
<li>컴포넌트: 사용자 정의 React 컴포넌트를 생성하여 구분자 역할을 할 수 있습니다. 이렇게 하면 외관과 동작에 대한 완전한 제어권을 갖게 됩니다.</li>
<li>엘리먼트: 간단한 구분자의 경우 <code>View</code>와 같은 React 엘리먼트를 직접 전달하고 선 또는 간격을 위한 스타일링을 적용할 수 있습니다.</li>
</ul>
<p>예시:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">ItemSeparator</span> = (<span class="hljs-params"></span>) => <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{</span> <span class="hljs-attr">height:</span> <span class="hljs-attr">1</span>, <span class="hljs-attr">backgroundColor:</span> '<span class="hljs-attr">lightgray</span>' } /></span></span>;

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">FlatList</span>
  <span class="hljs-attr">data</span>=<span class="hljs-string">{myData}</span>
  <span class="hljs-attr">renderItem</span>=<span class="hljs-string">{({</span> <span class="hljs-attr">item</span> }) =></span> <span class="hljs-tag">&#x3C;<span class="hljs-name">MyItemComponent</span> <span class="hljs-attr">item</span>=<span class="hljs-string">{item}</span> /></span>}
  ItemSeparatorComponent={ItemSeparator} 
/></span>
</code></pre>
<p>종류:</p>
<ul>
<li>component: 리액트 컴포넌트 클래스 또는 함수형 컴포넌트.</li>
<li>function: 리액트 엘리먼트를 반환하는 함수.</li>
<li>element: 직접적인 리액트 엘리먼트 (시각적 구분선을 위한 간단한 뷰일 때가 많음)</li>
</ul>
<h2>스타일링 속성</h2>
<p>다음은 리액트 네이티브의 FlatList 컴포넌트 내에서 다양한 스타일링 속성 및 다른 중요한 목록 관련 속성에 대한 설명입니다:</p>
<h1>ListEmptyComponent</h1>
<p>리액트 네이티브의 FlatList에서 ListEmptyComponent가 어떻게 작동하는지 살펴보겠습니다:</p>
<p>목적:</p>
<ul>
<li>ListEmptyComponent 속성은 FlatList가 렌더링할 데이터가 없을 때(즉, 데이터 배열이 비어있을 때) 표시할 내용을 결정합니다.</li>
<li>완전히 비어있는 화면이 아닌 사용자에게 친숙한 메시지나 시각적 표시 방법을 제공합니다.</li>
</ul>
<p>작동 방식:</p>
<ul>
<li>
<p>조건부 렌더링: FlatList는 자동으로 데이터 배열이 비어 있는지 확인합니다. 데이터 배열이 비어있으면 보통의 목록 항목 대신 ListEmptyComponent를 렌더링합니다.</p>
</li>
<li>
<p>유연성: 렌더링할 대상에 대해 두 가지 주요 옵션이 있습니다:</p>
<ul>
<li>
<p>React 컴포넌트: 사용자 정의 React 컴포넌트(예: EmptyListComponent)를 만들어 메시지, 이미지, "새로 고침" 버튼과 같은 작업을 제공합니다. 외관과 기능에 완전한 제어권을 제공합니다.</p>
</li>
</ul>
<ol start="2">
<li>React 엘리먼트: 종종 "단순한" 것처럼 React 엘리먼트를 직접 제공합니다:</li>
</ol>
</li>
</ul>
<pre><code class="hljs language-js">&#x3C;<span class="hljs-title class_">Text</span> style={<span class="hljs-attr">textAlign</span>: <span class="hljs-string">'center'</span>}>레시피를 찾을 수 없어요!&#x3C;/<span class="hljs-title class_">Text</span>>
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">EmptyListComponent</span> = (<span class="hljs-params"></span>) => (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.emptyContainer}</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.emptyText}</span>></span>아직 레시피가 없어요!<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span></span> 
);

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">FlatList</span>
    <span class="hljs-attr">data</span>=<span class="hljs-string">{recipes}</span>
    <span class="hljs-attr">renderItem</span>=<span class="hljs-string">{({</span> <span class="hljs-attr">item</span> }) =></span> <span class="hljs-tag">&#x3C;<span class="hljs-name">RecipeCard</span> <span class="hljs-attr">recipe</span>=<span class="hljs-string">{item}</span> /></span>} 
    ListEmptyComponent={EmptyListComponent} 
/></span>
</code></pre>
<p>유형</p>
<ul>
<li>component: React 컴포넌트 클래스 또는 함수형 컴포넌트.</li>
<li>element: React 요소 직접 사용.</li>
</ul>
<p>주요 포인트:</p>
<ul>
<li>스타일링: 앱 디자인에 맞게 빈 컴포넌트의 스타일을 적절히 지정하세요.</li>
<li>사용자 경험: 잘 디자인된 ListEmptyComponent는 맨 텅 빈 목록보다 훨씬 나은 경험을 제공할 수 있습니다.</li>
</ul>
<h1>ListFooterComponent</h1>
<p>React Native의 FlatList 안에서 ListFooterComponent를 살펴봅시다.</p>
<p>목적:</p>
<ul>
<li>ListFooterComponent 속성을 사용하면 FlatList의 가장 아래에 일반 리스트 항목들 다음에 렌더링되는 구성 요소나 요소를 추가할 수 있습니다.</li>
<li>일반적인 사용 사례:
<ul>
<li>추가 데이터를 가져오기 위한 "더 보기" 버튼 표시</li>
<li>데이터를 가져오는 동안 로딩 스피너 표시</li>
<li>나열된 항목을 기반으로 요약 정보나 총계 제공</li>
<li>광고를 위한 자리 표시</li>
</ul>
</li>
</ul>
<p>작동 방식:</p>
<ul>
<li>배치: ListFooterComponent는 리스트의 절대적 끝에 일관되게 렌더링되며, 리스트가 화면 전체를 채우지 않더라도 렌더링됩니다.</li>
<li>렌더링: 리스트에 데이터가 있는지 여부와 상관없이 렌더링됩니다.</li>
<li>유연성: 다른 유사한 속성과 마찬가지로, 사용할 수 있는 옵션:
<ul>
<li>React 구성 요소: 복잡한 레이아웃이나 상호작용을 위한 사용자 지정 구성 요소</li>
<li>React 요소: 기본 디스플레이를 위한 <code>View</code>와 같은 간단한 요소</li>
</ul>
</li>
</ul>
<p>예시</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">FooterLoader</span> = (<span class="hljs-params"></span>) => (
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.footer}</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">ActivityIndicator</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"small"</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"gray"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.footerText}</span>></span>더 로딩 중...<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span></span>
);

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">FlatList</span>
  <span class="hljs-attr">data</span>=<span class="hljs-string">{recipes}</span>
  <span class="hljs-attr">renderItem</span>=<span class="hljs-string">{({</span> <span class="hljs-attr">item</span> }) =></span> <span class="hljs-tag">&#x3C;<span class="hljs-name">RecipeCard</span> <span class="hljs-attr">recipe</span>=<span class="hljs-string">{item}</span> /></span>}
  ListFooterComponent={FooterLoader} 
/></span>
</code></pre>
<p>유형</p>
<ul>
<li>component: React 컴포넌트 클래스 또는 함수형 컴포넌트.</li>
<li>element: React 요소 직접.</li>
</ul>
<p>중요한 사항:</p>
<ul>
<li>스크롤: ListFooterComponent를 보려면 사용자가 목록의 맨 아래로 스크롤해야 할 수도 있습니다.</li>
<li>ListHeaderComponent: ListHeaderComponent라는 상대적인 요소가 있으며 비슷한 기능을 하지만 목록의 맨 위에 컴포넌트를 렌더링합니다.</li>
</ul>
<h1>ListFooterComponentStyle</h1>
<p>React Native의 FlatList에서 ListFooterComponentStyle에 대해 이야기해봅시다.</p>
<p>목적:</p>
<ul>
<li>ListFooterComponentStyle prop을 사용하면 ListFooterComponent를 포함하는 내부 뷰에 사용자 정의 스타일을 적용할 수 있습니다. 이를 통해 목록 내의 footer 영역의 모양과 레이아웃을 제어할 수 있습니다.</li>
</ul>
<p>사용 방법:</p>
<ul>
<li>StyleSheet를 Import하세요:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">StyleSheet</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
</code></pre>
<ol start="2">
<li>스타일 생성:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> styles = <span class="hljs-title class_">StyleSheet</span>.<span class="hljs-title function_">create</span>({
    <span class="hljs-attr">footerContainer</span>: {
        <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'lightblue'</span>,
        <span class="hljs-attr">padding</span>: <span class="hljs-number">20</span>,
        <span class="hljs-attr">alignItems</span>: <span class="hljs-string">'center'</span> 
    }
});
</code></pre>
<ol start="3">
<li>FlatList에 적용하기:</li>
</ol>
<pre><code class="hljs language-js">&#x3C;<span class="hljs-title class_">FlatList</span>
    <span class="hljs-comment">// ... 다른 FlatList 속성들</span>
    <span class="hljs-title class_">ListFooterComponent</span>={footerComponent}
    <span class="hljs-title class_">ListFooterComponentStyle</span>={styles.<span class="hljs-property">footerContainer</span>}
/>
</code></pre>
<p>스타일링 제어:</p>
<ul>
<li>ListFooterComponentStyle 속성은 유효한 View 스타일 속성을 받습니다. 다음과 같이 사용자 정의할 수 있습니다:</li>
<li>레이아웃: flex, flexDirection, justifyContent, alignItems 등</li>
<li>배경: backgroundColor</li>
<li>크기: height, width, padding, margin</li>
<li>테두리: borderWidth, borderColor, borderRadius</li>
<li>... 그 외 등등!</li>
</ul>
<p>중요한 고려 사항:</p>
<ul>
<li>내부 뷰: ListFooterComponent를 보유하는 컨테이너를 스타일링하고 있습니다. 컴포넌트 자체를 스타일링하고 있지 않습니다.</li>
<li>컴포넌트 스타일링: 필요하다면 ListFooterComponent를 따로 스타일링하세요.</li>
</ul>
<p>예시:</p>
<p>화면 하단에 고정된 푸터를 원한다면:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">ListFooterComponentStyle</span>={ 
    <span class="hljs-attr">position</span>: <span class="hljs-string">'absolute'</span>,
    <span class="hljs-attr">bottom</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">right</span>: <span class="hljs-number">0</span>
}
</code></pre>
<p>팁</p>
<ul>
<li>지금까지 보여준 대로 스타일 시트를 사용하여 구성된 스타일링을 하세요.</li>
<li>원하는 푸터 레이아웃과 외관을 얻기 위해 실험해보세요!</li>
<li>ListFooterComponentStyle: ListFooterComponent를 보유하는 컨테이너에 스타일을 적용합니다.</li>
<li>ListHeaderComponentStyle: ListHeaderComponent를 보유하는 컨테이너에 스타일을 적용합니다.</li>
<li>columnWrapperStyle: numColumns를 사용하는 경우 다중 항목 행의 스타일을 사용자 정의합니다.</li>
</ul>
<p>스타일링에 대한 중요한 참고 사항</p>
<ul>
<li>이러한 props은 레이아웃, 테두리, 배경 등을 사용자 정의하기 위한 유효한 ViewStyle 속성을 수용합니다.</li>
<li>일반적으로 헤더, 푸터 및 항목 구성 요소를 내부 콘텐츠에 대해 별도로 스타일링할 것입니다.</li>
</ul>
<p>기타 중요한 속성들</p>
<p>좀 더 복잡하거나 자주 사용되는 몇 가지 속성들을 알아보겠습니다:</p>
<ul>
<li><strong>extraData:</strong>
<ul>
<li>주요 데이터 속성 외부의 데이터가 변경될 때 FlatList(순수 컴포넌트)에게 다시 렌더링하도록 지시합니다.</li>
<li>항목 자체가 아닌 다른 요소에 기반한 동적 업데이트에 유용합니다(예: 컴포넌트 내 선택된 상태 등).</li>
</ul>
</li>
<li><strong>getItemLayout:</strong>
<ul>
<li>최적화: 성능 향상을 위해 항목의 높이와 오프셋을 미리 계산하여 크기가 고정된 항목의 목록에 사용됩니다.</li>
</ul>
</li>
<li><strong>horizontal:</strong>
<ul>
<li>목록의 레이아웃을 가로 스크롤링으로 전환합니다.</li>
</ul>
</li>
<li><strong>initialNumToRender:</strong>
<ul>
<li>초기 경험을 더 부드럽게 하기 위해 처음에 렌더링할 항목 수를 지정합니다.</li>
</ul>
</li>
<li><strong>inverted:</strong>
<ul>
<li>목록의 방향을 반대로 바꿉니다.</li>
</ul>
</li>
<li><strong>keyExtractor:</strong>
<ul>
<li>항목에 대한 고유한 키를 제공하여 React의 렌더링 효율성을 유지합니다.</li>
</ul>
</li>
<li><strong>numColumns:</strong>
<ul>
<li>다중 열 그리드 레이아웃을 만듭니다.</li>
</ul>
</li>
<li><strong>onRefresh &#x26; refreshing:</strong>
<ul>
<li>"당겨서 새로고침" 기능을 구현합니다.</li>
</ul>
</li>
<li><strong>onViewableItemsChanged:</strong>
<ul>
<li>항목 가시성이 변경될 때 트리거되는 콜백 함수(게으른 로딩과 같은 작업에 유용)입니다.</li>
</ul>
</li>
<li><strong>viewabilityConfig:</strong>
<ul>
<li>onViewableItemsChanged 콜백이 트리거되는 조건을 세밀하게 조정합니다(가시성 임계값 등).</li>
</ul>
</li>
</ul>
<p>큰 목록을 최적화하기</p>
<h3>onViewableItemsChanged</h3>
<p><strong>도전 과제:</strong> FlatList를 사용하여 오래된 버전이나 성능이 떨어지는 장치에서 특히 많은 데이터 목록을 표시할 때 성능 문제를 겪을 수 있습니다. 한꺼번에 많은 항목을 렌더링하면 장치에 과부하가 걸려 스크롤이 느려지거나 프레임이 떨어질 수 있습니다.</p>
<p><strong>해결책:</strong> React Native의 FlatList 컴포넌트는 이러한 성능 문제를 해결하기 위해 설계된 onViewableItemsChanged라는 강력한 속성을 제공합니다. 이는 목록 내 항목의 가시성이 변경될 때마다 호출되는 콜백 함수를 제공합니다. 이를 통해 다음과 같은 최적화를 전략적으로 구현할 수 있습니다:</p>
<ul>
<li><strong>지연 로딩:</strong> 사용자가 목록 끝에 접근할 때만 추가 데이터를 가져와 렌더링합니다.</li>
<li><strong>미디어 제어:</strong> 비디오가 뷰포트를 벗어나거나 들어올 때 비디오를 일시 정지하거나 재생하여 자원을 절약합니다.</li>
<li><strong>선택적 업데이트:</strong> 현재 가시 상태인 항목에 따라 FlatList 바깥쪽의 UI 일부를 업데이트합니다.</li>
</ul>
<p><code>onViewableItemsChanged</code> Prop에 대해 설명드리겠습니다.</p>
<p>함수 서명:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">onViewableItemsChanged</span>: <span class="hljs-function">(<span class="hljs-params">{ changed, viewableItems }</span>) =></span> <span class="hljs-keyword">void</span>
</code></pre>
<ul>
<li>changed: ViewToken 객체의 배열입니다. 각 객체는 특정 항목의 가시성 변경을 설명합니다.</li>
<li>viewableItems: 현재 뷰포트 내에서 실제로 보이는 항목을 나타내는 ViewToken 객체의 배열입니다.</li>
</ul>
<p>ViewToken 구조:</p>
<ul>
<li>index: 데이터 배열 내 항목의 인덱스입니다.</li>
<li>isViewable: 해당 항목이 보이는 영역 내에 있는 경우 true이고, 그렇지 않으면 false인 부울 값입니다.</li>
<li>key: 항목에 제공한 고유한 키입니다.</li>
<li>(기타 속성 가능): ViewToken은 viewabilityConfig에 기반한 추가 속성을 가질 수 있습니다.</li>
</ul>
<p>키 구성 옵션 (viewabilityConfig)</p>
<ul>
<li>viewAreaCoveragePercentThreshold: 콜백을 트리거하기 위해 항목의 영역 중 얼마나 비춰져 있어야 하는지 결정하는 숫자 (예: 50).</li>
<li>itemVisiblePercentThreshold: 화면에 표시되어야 하는 항목의 얼마나 많은 부분을 제어하는 숫자 (항목의 높이가 다른 목록에 유용).</li>
<li>minimumViewTime: 항목이 "보이는" 것으로 간주되기 전에 보이는 지속 시간을 설정하는 밀리초 단위의 값입니다.</li>
<li>waitForInteraction: true인 경우 사용자가 목록과 상호 작용한 후까지 가시성 업데이트를 지연시켜 빠른 스크롤 중에 성능을 향상시킵니다.</li>
</ul>
<p>실용적인 예시: 무한 스크롤링</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleViewableItemsChanged</span> = (<span class="hljs-params">{ viewableItems }</span>) => {
  <span class="hljs-keyword">const</span> isLastItemVisible = viewableItems[viewableItems.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>].<span class="hljs-property">isViewable</span>;
  <span class="hljs-keyword">if</span> (isLastItemVisible &#x26;&#x26; !isLoading) {  
    <span class="hljs-title function_">loadMoreData</span>(); 
  }
};

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">FlatList</span>
    <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span>
    <span class="hljs-attr">onViewableItemsChanged</span>=<span class="hljs-string">{handleViewableItemsChanged}</span>
    <span class="hljs-attr">viewabilityConfig</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">viewAreaCoveragePercentThreshold:</span> <span class="hljs-attr">50</span> }} 
    // <span class="hljs-attr">...</span> <span class="hljs-attr">다른</span> <span class="hljs-attr">FlatList</span> <span class="hljs-attr">속성들</span>
/></span></span>
</code></pre>
<p>주의사항</p>
<ul>
<li>트레이드오프(Trade-offs): onViewableItemsChanged 내부에 과도하게 복잡한 계산을 포함하는 것은 성능에 영향을 줄 수 있습니다. 콜백을 트리거하는 방법을 세밀하게 조정하기 위해 viewabilityConfig을 사용하세요.</li>
<li>실제 최적화 예시: 매우 복잡한 시나리오에서는 onViewableItemsChanged를 getItemLayout과 결합하여 아이템 크기를 사전 계산하여 더 부드러운 스크롤링을 구현할 수 있습니다.</li>
</ul>
<h2>스크롤 및 제어를 위한 주요 FlatList 메서드</h2>
<p>메서드 설명</p>
<ul>
<li>flashScrollIndicators()</li>
<li>목적: 스크롤 표시기(스크롤바)를 잠시 표시하여 사용자에게 시각적 피드백을 제공합니다.</li>
<li>사용 사례: 목록 끝에 새 데이터를로드 한 후나 프로그래밍 방식으로 위치로 스크롤하는 경우에 사용합니다.</li>
<li>예시:</li>
</ul>
<pre><code class="hljs language-js">myListRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">flashScrollIndicators</span>();
</code></pre>
<ul>
<li>getNativeScrollRef()
<ul>
<li>목적: 기본 네이티브 스크롤 컴포넌트(예: ScrollView 또는 VirtualizedList)에 대한 참조를 제공합니다.</li>
<li>사용 사례: 절대적으로 필요한 경우에만 스크롤 컴포넌트의 하위 수준 사용자 정의를 위해 이에 액세스합니다. (대부분의 경우, 이는 필요하지 않을 것입니다).</li>
</ul>
</li>
<li>getScrollResponder()
<ul>
<li>목적: 스크롤 상호작용을 관리하는 스크롤 응답자 객체에 대한 참조를 반환합니다.</li>
<li>사용 사례: 스크롤 동작을 세밀하게 조정하거나 특정 스크롤 이벤트에 응답해야 하는 고급 시나리오에서 사용합니다.</li>
</ul>
</li>
<li>getScrollableNode()
<ul>
<li>목적: 스크롤 가능한 컴포넌트 자체에 대한 참조를 제공합니다.</li>
<li>사용 사례: 거의 필요하지 않습니다. 주로 스크롤 가능한 노드에서 직접 메서드를 호출해야 할 경우에 유용합니다.</li>
</ul>
</li>
<li>scrollToEnd(params?: ' animated?: boolean ')
<ul>
<li>목적: 콘텐츠의 맨 끝(또는 목록이 수평인 경우 하단)으로 스크롤합니다.</li>
<li>옵션:
<ul>
<li>animated (boolean, 기본: true): 스크롤을 애니메이션으로 제어할지 여부를 결정합니다.</li>
</ul>
</li>
<li>예시:</li>
</ul>
</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollToEnd</span> = (<span class="hljs-params"></span>) => {
    flatListRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">scrollToEnd</span>({ <span class="hljs-attr">animated</span>: <span class="hljs-literal">true</span> }); 
};
</code></pre>
<ul>
<li><strong>중요:</strong> 큰 목록의 경우, 부드럽고 효율적인 스크롤링을 위해 <code>getItemLayout</code> 속성을 사용하는지 확인하십시오.</li>
</ul>
<p>scrollToIndex(params: ' animated?: boolean; index: number; viewOffset?: number; viewPosition?: number; ')</p>
<ul>
<li>목적: 데이터 배열 내에서 특정 항목의 인덱스(위치)로 스크롤합니다.</li>
<li>옵션:
<ul>
<li>animated (boolean, 기본값: true): 애니메이션을 컨트롤합니다.</li>
<li>index (number): 스크롤할 항목의 인덱스입니다.</li>
<li>viewOffset (number): 픽셀 단위의 추가 오프셋입니다.</li>
<li>viewPosition (number): 뷰포트 내 항목의 위치를 제어합니다 (0: 맨 위, 1: 맨 아래, 0.5: 중앙).</li>
</ul>
</li>
<li>예시:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">scrollToRecipe</span> = (<span class="hljs-params">index</span>) => {
  flatListRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">scrollToIndex</span>({ index, <span class="hljs-attr">viewPosition</span>: <span class="hljs-number">0</span> }); <span class="hljs-comment">// 화면 맨 위에 있는 항목의 맨 위로 스크롤</span>
};
</code></pre>
<ul>
<li><strong>강조:</strong> 성능 개선을 위해 특정 항목으로 스크롤하는 우선적인 방법입니다.</li>
</ul>
<p>scrollToItem(params: ' animated?: boolean; item: Item; viewPosition?: number; ')</p>
<ul>
<li>목적: 데이터에서 아이템 객체를 제공하여 해당 항목으로 스크롤합니다.</li>
<li>단점: 특히 대규모 목록의 경우 scrollToIndex보다 효율성이 떨어질 수 있으며 데이터 배열을 검색해야 할 수도 있습니다.</li>
<li>참고: 가능하면 최상의 성능을 위해 scrollToIndex를 선택하십시오.</li>
</ul>
<h2>이론을 실제로 구현하기: React Native의 FlatList를 활용한 인터랙티브 레시피 앱 제작</h2>
<p>FlatListDemonstration.jsx</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">SafeAreaView</span>,
  <span class="hljs-title class_">FlatList</span>,
  <span class="hljs-title class_">Text</span>,
  <span class="hljs-title class_">TouchableOpacity</span>,
  <span class="hljs-title class_">ActivityIndicator</span>,
  <span class="hljs-title class_">RefreshControl</span>,
  <span class="hljs-title class_">StyleSheet</span>,
  <span class="hljs-title class_">TextInput</span>,
  <span class="hljs-title class_">View</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
<span class="hljs-keyword">import</span> recipesData <span class="hljs-keyword">from</span> <span class="hljs-string">'../data/recipeData'</span>; <span class="hljs-comment">// 데이터가 올바르게 형식화되었는지 확인</span>
<span class="hljs-keyword">import</span> { useNavigation } <span class="hljs-keyword">from</span> <span class="hljs-string">'@react-navigation/native'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">FlatListDemonstration</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> navigation = <span class="hljs-title function_">useNavigation</span>();
  <span class="hljs-keyword">const</span> [recipes, setRecipes] = <span class="hljs-title function_">useState</span>(recipesData);
  <span class="hljs-keyword">const</span> [isFetching, setIsFetching] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [refreshing, setRefreshing] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [searchQuery, setSearchQuery] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleFavorite</span> = (<span class="hljs-params">id</span>) => {
    <span class="hljs-keyword">const</span> newRecipes = recipes.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">recipe</span> =></span>
      recipe.<span class="hljs-property">id</span> === id ? { ...recipe, <span class="hljs-attr">isFavorite</span>: !recipe.<span class="hljs-property">isFavorite</span> } : recipe,
    );
    <span class="hljs-title function_">setRecipes</span>(newRecipes);
    navigation.<span class="hljs-title function_">navigate</span>(<span class="hljs-string">'Favorites'</span>, {
      <span class="hljs-attr">recipes</span>: newRecipes.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">r</span> =></span> r.<span class="hljs-property">isFavorite</span>),
    });
  };

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSearch</span> = (<span class="hljs-params">text</span>) => {
    <span class="hljs-title function_">setSearchQuery</span>(text);
    <span class="hljs-keyword">const</span> filteredData = text
      ? recipes.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">recipe</span> =></span>
          recipe.<span class="hljs-property">name</span>.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">includes</span>(text.<span class="hljs-title function_">toLowerCase</span>()),
        )
      : recipesData;
    <span class="hljs-title function_">setRecipes</span>(filteredData);
  };

  <span class="hljs-keyword">const</span> onRefresh = <span class="hljs-title function_">useCallback</span>(<span class="hljs-keyword">async</span> () => {
    <span class="hljs-title function_">setRefreshing</span>(<span class="hljs-literal">true</span>);
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =></span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1500</span>));
    <span class="hljs-title function_">setRefreshing</span>(<span class="hljs-literal">false</span>);
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">SafeAreaView</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.container}</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">TextInput</span>
        <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.searchBar}</span>
        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"레시피 검색..."</span>
        <span class="hljs-attr">value</span>=<span class="hljs-string">{searchQuery}</span>
        <span class="hljs-attr">onChangeText</span>=<span class="hljs-string">{handleSearch}</span>
      /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">FlatList</span>
        <span class="hljs-attr">data</span>=<span class="hljs-string">{recipes}</span>
        <span class="hljs-attr">renderItem</span>=<span class="hljs-string">{({</span> <span class="hljs-attr">item</span> }) =></span> (
          <span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.item}</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.title}</span>></span>{item.name}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.actionArea}</span>></span>
              <span class="hljs-tag">&#x3C;<span class="hljs-name">TouchableOpacity</span> <span class="hljs-attr">onPress</span>=<span class="hljs-string">{()</span> =></span> toggleFavorite(item.id)}>
                <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.favorite}</span>></span>
                  {item.isFavorite ? '♥' : '☆'}
                <span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
              <span class="hljs-tag">&#x3C;/<span class="hljs-name">TouchableOpacity</span>></span>
              <span class="hljs-tag">&#x3C;<span class="hljs-name">TouchableOpacity</span>
                <span class="hljs-attr">onPress</span>=<span class="hljs-string">{()</span> =></span>
                  navigation.navigate('RecipeDetails', { recipe: item })
                }>
                <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.detailsButton}</span>></span>세부 정보<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
              <span class="hljs-tag">&#x3C;/<span class="hljs-name">TouchableOpacity</span>></span>
            <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span>
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span>
        )}
        keyExtractor={item => item.id.toString()}
        refreshControl={
          <span class="hljs-tag">&#x3C;<span class="hljs-name">RefreshControl</span> <span class="hljs-attr">refreshing</span>=<span class="hljs-string">{refreshing}</span> <span class="hljs-attr">onRefresh</span>=<span class="hljs-string">{onRefresh}</span> /></span>
        }
      />
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">SafeAreaView</span>></span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">FlatListDemonstration</span>;
</code></pre>
<img src="/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_1.png">
<p>RecipeDetailsScreen.jsx</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">View</span>, <span class="hljs-title class_">Text</span>, <span class="hljs-title class_">StyleSheet</span>, <span class="hljs-title class_">ScrollView</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">RecipeDetailsScreen</span> = (<span class="hljs-params">{route}</span>) => {
  <span class="hljs-keyword">const</span> {recipe} = route.<span class="hljs-property">params</span>;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ScrollView</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.container}</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.title}</span>></span>{recipe.name}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.description}</span>></span>{recipe.description}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.section}</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.header}</span>></span>재료<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
        {recipe.ingredients.map((ingredient, index) => (
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.text}</span>></span>
            {ingredient.name}: {ingredient.quantity}
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
        ))}
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.section}</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.header}</span>></span>조리 방법<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
        {recipe.instructions.map((step, index) => (
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.text}</span>></span>
            {index + 1}. {step}
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
        ))}
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ScrollView</span>></span></span>
  );
};
</code></pre>
<img src="/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_2.png">
<p>FavouriteList.jsx</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, {useState} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">View</span>, <span class="hljs-title class_">Text</span>, <span class="hljs-title class_">TouchableOpacity</span>, <span class="hljs-title class_">Image</span>, <span class="hljs-title class_">StyleSheet</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">DraggableFlatList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native-draggable-flatlist'</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">GestureHandlerRootView</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native-gesture-handler'</span>;
<span class="hljs-keyword">import</span> {useNavigation} <span class="hljs-keyword">from</span> <span class="hljs-string">'@react-navigation/native'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">FavoriteList</span> = (<span class="hljs-params">{route}</span>) => {
    <span class="hljs-keyword">const</span> navigation = <span class="hljs-title function_">useNavigation</span>();
    <span class="hljs-keyword">const</span> {recipes} = route.<span class="hljs-property">params</span>;
    <span class="hljs-keyword">const</span> [favorites, setFavorites] = <span class="hljs-title function_">useState</span>(recipes);

    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">GestureHandlerRootView</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.rootView}</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.container}</span>></span>
                <span class="hljs-tag">&#x3C;<span class="hljs-name">DraggableFlatList</span>
                    <span class="hljs-attr">data</span>=<span class="hljs-string">{favorites}</span>
                    <span class="hljs-attr">renderItem</span>=<span class="hljs-string">{({item,</span> <span class="hljs-attr">drag</span>, <span class="hljs-attr">isActive</span>}) =></span> (
                        <span class="hljs-tag">&#x3C;<span class="hljs-name">TouchableOpacity</span>
                            <span class="hljs-attr">onLongPress</span>=<span class="hljs-string">{drag}</span>
                            <span class="hljs-attr">style</span>=<span class="hljs-string">{[styles.card,</span> <span class="hljs-attr">isActive</span> &#x26;&#x26; <span class="hljs-attr">styles.activeCard</span>]}
                        ></span>
                            <span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span>
                                <span class="hljs-attr">source</span>=<span class="hljs-string">{item.image}</span>
                                <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.recipeImage}</span>
                                <span class="hljs-attr">accessibilityLabel</span>=<span class="hljs-string">{</span>`<span class="hljs-attr">Image</span> <span class="hljs-attr">of</span> ${<span class="hljs-attr">item.name</span>}`}
                            /></span>
                            <span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.textContainer}</span>></span>
                                <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.recipeTitle}</span>></span>{item.name}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
                                <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.recipeDescription}</span>></span>{item.description}<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
                                <span class="hljs-tag">&#x3C;<span class="hljs-name">TouchableOpacity</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.detailsButton}</span>  <span class="hljs-attr">onPress</span>=<span class="hljs-string">{()</span> =></span>
                                    navigation.navigate('RecipeDetails', {recipe: item})}
                                >
                                    <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.detailsButtonText}</span>></span>View Details<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
                                <span class="hljs-tag">&#x3C;/<span class="hljs-name">TouchableOpacity</span>></span>
                            <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span>
                        <span class="hljs-tag">&#x3C;/<span class="hljs-name">TouchableOpacity</span>></span>
                    )}
                    keyExtractor={item => item.id.toString()}
                    onDragEnd={({data}) => setFavorites(data)}
                />
            <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">GestureHandlerRootView</span>></span></span>
    );
};
</code></pre>
<p><img src="/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_3.png" alt="Image 1"></p>
<p><img src="/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_4.png" alt="Image 2"></p>
<p>App.jsx</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">NavigationContainer</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@react-navigation/native'</span>;
<span class="hljs-keyword">import</span> { createNativeStackNavigator } <span class="hljs-keyword">from</span> <span class="hljs-string">'@react-navigation/native-stack'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">FlatListDemonstration</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./src/components/flatlist'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">RecipeDetailsScreen</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./src/screens/RecipeDetailsScreen'</span>;

<span class="hljs-keyword">import</span> <span class="hljs-title class_">FavoriteList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./src/components/FavoriteList'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Stack</span> = <span class="hljs-title function_">createNativeStackNavigator</span>();

<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">NavigationContainer</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Stack.Navigator</span> <span class="hljs-attr">initialRouteName</span>=<span class="hljs-string">"Home"</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Stack.Screen</span>
            <span class="hljs-attr">name</span>=<span class="hljs-string">"Home"</span>
            <span class="hljs-attr">component</span>=<span class="hljs-string">{FlatListDemonstration}</span> // <span class="hljs-attr">홈</span> <span class="hljs-attr">화면에</span> <span class="hljs-attr">FlatListDemonstration</span> <span class="hljs-attr">사용</span>
            <span class="hljs-attr">options</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">title:</span> '<span class="hljs-attr">Recipe</span> <span class="hljs-attr">List</span>' }}
          /></span>

          <span class="hljs-tag">&#x3C;<span class="hljs-name">Stack.Screen</span>
            <span class="hljs-attr">name</span>=<span class="hljs-string">"RecipeDetails"</span>
            <span class="hljs-attr">component</span>=<span class="hljs-string">{RecipeDetailsScreen}</span>
            <span class="hljs-attr">options</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">title:</span> '<span class="hljs-attr">Recipe</span> <span class="hljs-attr">Details</span>' }}
          /></span>
          
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Stack.Screen</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Favorites"</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{FavoriteList}</span> <span class="hljs-attr">options</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">title:</span> '<span class="hljs-attr">Favorite</span> <span class="hljs-attr">Recipes</span>' }} /></span>
      
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">Stack.Navigator</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">NavigationContainer</span>></span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>컴포넌트와 역할:</p>
<ul>
<li>FlatListDemonstration: 레시피 목록을 렌더링하는 주요 컴포넌트입니다. 레시피 데이터, 사용자 상호작용(검색, 즐겨찾기), 다른 화면으로의 이동을 관리합니다.</li>
<li>FavoriteList: DraggableFlatList 라이브러리를 사용하여 즐겨찾은 레시피 목록을 표시하는 컴포넌트로, 사용자가 순서를 변경할 수 있습니다.</li>
<li>RecipeDetailsScreen: FlatList에서 항목을 탭하면 특정 레시피의 세부 정보를 표시하는 컴포넌트입니다.</li>
</ul>
<p>FlatList와 관련된 주요 기능:</p>
<ul>
<li>상태 관리 (useState):
<ul>
<li>컴포넌트는 여러 상태 변수를 유지합니다:
<ul>
<li>recipes: 레시피 데이터 배열을 보유합니다.</li>
<li>isFetching: 데이터를 가져오는지 추적합니다 (풀 투 리프레시를 위한 가능성 있음).</li>
<li>refreshing: 데이터 가져오는 동안 시각적 리프레시 인디케이터를 제어합니다.</li>
<li>searchQuery: 사용자가 입력한 현재 검색어를 저장합니다.</li>
</ul>
</li>
<li>toggleFavorite 함수는 사용자가 레시피 항목의 즐겨찾기 버튼을 탭할 때 트리거됩니다. 이 함수는 특정 레시피를 찾아 isFavorite 속성을 토글하고, 필요에 따라 즐겨찾기 화면으로 이동을 트리거합니다.</li>
<li>handleSearch 함수는 검색 바에서 사용자 입력에 따라 searchQuery 상태를 업데이트합니다. 그런 다음 검색어와 일치하는 레시피 데이터만 표시하기 위해 recipes 데이터를 필터링합니다.</li>
</ul>
</li>
<li>검색 기능:
<ul>
<li>검색 바를 사용하여 레시피 목록을 동적으로 필터링할 수 있습니다.</li>
<li>사용자가 검색 바에 입력할 때 handleSearch 함수가 호출되어 searchQuery 상태를 업데이트합니다.</li>
<li>handleSearch 함수는 filter 메서드를 사용하여 recipes 데이터를 필터링합니다. 검색어의 소문자 버전을 포함하는 레시피 이름을 가진 레시피만 유지합니다.</li>
<li>필터링된 데이터는 새로운 recipes 상태로 설정되어 FlatList가 업데이트된 목록으로 다시 렌더링됩니다.</li>
</ul>
</li>
<li>내비게이션 (@react-navigation/native):
<ul>
<li>이 예제는 화면 간 부드러운 내비게이션을 위해 @react-navigation/native를 사용합니다.</li>
<li>레시피 항목을 누르면 toggleFavorite 함수가 호출되며, 레시피가 즐겨찾기 상태인 경우 즐겨찾기 화면으로 이동할 수 있습니다.</li>
<li>"자세히 보기" 버튼을 누르면 navigation.navigate(<code>RecipeDetails</code>, 'recipe: item')이 호출되어 선택한 레시피 데이터를 매개변수로 전달하여 RecipeDetailsScreen을 내비게이션 스택에 푸시합니다.</li>
</ul>
</li>
<li>풀 투 리프레시 (RefreshControl):
<ul>
<li>풀 투 리프레시 기능을 구현하기 위해 RefreshControl 컴포넌트를 사용합니다.</li>
<li>사용자가 목록 상단에서 아래로 스와이프하면 onRefresh 함수가 호출됩니다.</li>
<li>이 예제에서 onRefresh는 데이터 가져오기를 모방하기 위해 1.5초 지연을 시뮬레이션하고, 그 후 refreshing 상태를 업데이트하여 리프레시 인디케이터를 끕니다.</li>
<li>실제 앱에서는 onRefresh가 아마도 API에서 새 데이터를 가져오고 recipes 상태를 그에 맞게 업데이트할 것입니다.</li>
</ul>
</li>
</ul>
<p>더 많은 정보를 보려면 공식 문서를 방문해주세요: <a href="https://reactnative.dev/docs/flatlist" rel="nofollow" target="_blank">https://reactnative.dev/docs/flatlist</a></p>
<p>이 글을 읽어주셔서 정말 감사합니다! 여러분의 지원과 관심이 저에게는 큰 힘이 됩니다. 유용하게 여기셨다면, 이를 즐길 수 있는 다른 사람들과 공유해보시기를 권장드립니다. 더 많은 통찰과 팁을 기대해주세요. 📚💖 우리 커뮤니티의 멋진 일원이 되어 주셔서 다시 한번 감사드립니다! 🌟</p>
<h1>스택데믹 🎓</h1>
<p>끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:</p>
<ul>
<li>작가를 응원하고 팔로우해 주세요! 👏</li>
<li>저희를 팔로우하세요 X | LinkedIn | YouTube | Discord</li>
<li>다른 플랫폼들도 방문해 주세요: In Plain English | CoFeed | Venture | Cubed</li>
<li>스택데믹닷컴에서 더 많은 콘텐츠를 만나보세요</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React Native 리스트의 성능을 개선하는 방법 FlatList 최적화 가이드","description":"","date":"2024-05-12 18:48","slug":"2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide","content":"\n\n소개\n\n![이미지](/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_0.png)\n\nFlatList란 무엇인가요?\n\n- 성능 최적화: FlatList는 대규모 목록을 효율적으로 렌더링하기 위해 설계된 React Native 컴포넌트입니다. \"게으른 로딩\"이라는 기술을 통해 이를 수행합니다. 이는 화면에 현재 표시된 항목만 렌더링하고 사용자가 스크롤할 때 컴포넌트를 재활용함으로써 작동합니다.\n- 이를 통해 많은 양의 데이터를 다룰 때에도 앱이 부드럽고 반응성 있게 유지됩니다.\n- 필수적인 목록 기능: FlatList는 사용자 친화적인 목록을 구축하는 데 필수적인 다양한 기능을 제공합니다.\n- 매우 맞춤화 가능: 속성, 스타일링, 사용자 정의 컴포넌트를 사용하여 목록의 모양과 느낌을 쉽게 조정할 수 있습니다.\n\n\n\nFlatList를 사용하는 주요 장점들\n\n- 성능, 성능, 성능: FlatList는 긴 목록을 처리할 때 빛을 발합니다. 게으르게 로딩하고 최적화 기술을 사용하여 데이터가 많아져도 앱이 느려지지 않도록 합니다.\n- 내장 기능: 바퀴를 재창조할 필요 없어요. FlatList에는 현대적인 목록에서 기대할 수 있는 기능이 탑재되어 있습니다: 당겨서 새로고침, 헤더, 푸터, 항목 구분선, 특정 위치로 스크롤 등.\n- 크로스 플랫폼: 하나의 코드 베이스로 iOS와 Android 기기에서 목록이 매끄럽게 작동합니다.\n\n## 핵심 기능들:\n\n- FlatList는 상자에서 바로 제공되는 주요 기능들로, 매우 유용하게 만들어집니다:\n- 크로스 플랫폼: iOS와 Android에서 일관되게 작동합니다.\n- 수평 모드: 표준 수직 및 수평 목록 간 전환 가능.\n- 가시성 콜백: 보이는 항목을 추적하여, 사용자가 끝에 가까워질 때 추가 데이터를 로드할 수 있도록 합니다.\n- 헤더 및 푸터: 헤더와 푸터를 목록에 쉽게 통합합니다.\n- 구분선: 목록 항목 사이의 구분선 외관을 사용자 정의할 수 있습니다.\n- 당겨서 새로고침: 사용자가 목록 내용을 새로 고칠 수 있는 일반적인 인터페이스.\n- 스크롤 로딩 (무한 스크롤): 사용자가 스크롤할 때 자연스럽게 더 많은 데이터를 로드합니다.\n- ScrollToIndex: 목록에서 특정 항목으로 빠르게 이동합니다.\n- 여러 열: 그리드 형식으로 목록을 렌더링합니다.\n\n\n\nFlatList을 언제 사용해볼까요?\n\n- 연락처 목록 표시\n- 이미지 갤러리 만들기\n- 뉴스 피드 또는 타임라인 구축\n- 전자상거래 앱에서 제품 목록 렌더링\n- 스크롤 가능한 항목 목록을 표시해야 하는 모든 시나리오\n\n간단한 예제로 설명해 보겠습니다:\n\n```js\nimport { FlatList, Text } from 'react-native';\n\nconst myData = [ /* 데이터 객체 배열 */ ];\n\nconst renderItem = ({ item }) =\u003e (\n    \u003cText\u003e{item.title}\u003c/Text\u003e \n);\n\n\u003cFlatList\n  data={myData}\n  renderItem={renderItem} \n  keyExtractor={item =\u003e item.id} \n/\u003e\r\n```\n\n\n\n중요한 속성 설명해 드릴게요\n\n- data: 리스트에 표시하려는 데이터 배열입니다.\n- renderItem: 데이터 배열에서 개별 항목을 가져와서 시각적으로 표현하는 JSX 구조를 반환하는 함수입니다.\n- keyExtractor: 각 목록 항목에 대한 고유한 키를 생성하는 함수입니다 (React의 렌더링 최적화에 중요합니다).\n\n## FlatList가 동적으로 업데이트되도록 만드는 방법\n\n이 핵심은 FlatList가 응용 프로그램 데이터 변경에 따라 디스플레이를 어떻게 업데이트할지 제어하는 데 있습니다.\n\n\n\n- 선택 가능한 항목: FlatList에서 항목을 선택할 때 시각적으로 변경되도록 하는 것이 목표입니다 (예: 선택된 항목 강조 표시). 이를 위해 다음이 필요합니다:\n\n- 상태(State): 현재 선택된 항목의 ID를 추적하기 위해 selectedId와 같은 상태 변수가 필요합니다.\n- 시각적 스타일링: renderItem 함수 내부에서 항목의 ID가 선택된 ID와 일치하는지 여부에 따라 다른 스타일을 적용해야 합니다.\n\nextraData - 업데이트의 핵심:\n\n- FlatList는 PureComponent이므로 생성자에서 직접 변경된 경우에만 다시 렌더링됩니다.\n- 항목을 선택하는 경우 대부분 FlatList 자체의 속성 외부에서 상태를 변경하므로, extraData='selectedId'를 사용하여 selectedId 상태 변수가 변경될 때마다 FlatList가 다시 렌더링되어야 함을 알립니다.\n\n\n\nkeyExtractor - 고유 키 보장하기:\n\n- keyExtractor는 React에서 리스트를 업데이트할 때 효율적으로 사용됩니다. 데이터의 각 항목에서 고유 키(일반적으로 ID)를 추출하는 방법을 제공합니다.\n\n예시\n\n```js\nimport { FlatList, View, StyleSheet, TouchableOpacity, Text } from 'react-native';\n\nconst recipes = [\n  { id: 'recipe1', title: '맛있는 팬케이크' },\n  { id: 'recipe2', title: '초콜릿 케이크' },\n  // ... 더 많은 레시피\n];\n\nconst RecipeCard = ({ recipe, onFavoriteToggle }) =\u003e { return ( \u003cTouchableOpacity onPress={() =\u003e onFavoriteToggle(recipe.id)}\u003e \u003cView style={styles.card}\u003e \u003cText style={styles.title}\u003e{recipe.title}\u003c/Text\u003e {/* 가상: 여기에 이미지가 있을 것 */} \u003cText style={recipe.isFavorite ? styles.favorite : styles.notFavorite}\u003e {recipe.isFavorite ? '♥ 즐겨찾기한 레시피' : '☆ 즐겨찾기하기' } \u003c/Text\u003e \u003c/View\u003e \u003c/TouchableOpacity\u003e ); };\n\nconst RecipeApp = () =\u003e {\n  const [recipesData, setRecipesData] = useState(recipes); // 즐겨찾기 관리\n  const [selectedId, setSelectedId] = useState(null); // extraData에 여전히 사용됨\n\n  const handleFavoriteToggle = (recipeId) =\u003e {\n    setRecipesData(prevRecipes =\u003e prevRecipes.map(recipe =\u003e\n      recipe.id === recipeId ? { ...recipe, isFavorite: !recipe.isFavorite } : recipe\n    ));\n    setSelectedId(recipeId); \n  };\n\n  return (\n    \u003cFlatList\n      data={recipesData} // 업데이트된 데이터 전달\n      renderItem={({ item }) =\u003e (\n        \u003cRecipeCard \n         recipe={item} \n         isFavorite={item.isFavorite} // 속성으로 전달\n         onFavoriteToggle={handleFavoriteToggle} \n        /\u003e \n      )} \n      keyExtractor={(item) =\u003e item.id} \n      numColumns={2} \n      extraData={selectedId} \n    /\u003e\n  );\n};\n```\n\n\n\n데이터:\n\n- recipes: 초기 레시피 데이터를 보유한 간단한 배열입니다. 각 레시피에는 id 및 title 속성이 포함되어 있습니다.\n\n구성 요소:\n\n- RecipeCard: 단일 레시피 카드를 표시하는 컴포넌트입니다. 제목, 이미지를 위한 자리 표시자 및 즐겨찾기 버튼이 포함되어 있습니다. 이 버튼은 레시피의 isFavorite 상태에 따라 동적으로 변경됩니다.\n- RecipeApp: 앱의 주요 컴포넌트입니다. 다음을 관리합니다:\n- 상태:\n- recipesData: 레시피의 현재 상태를 유지하는 배열로, isFavorite 상태를 포함합니다. 이는 recipes 배열을 사용하여 초기화됩니다.\n- selectedId: 레시피를 즐겨찾기 추가하거나 취소할 때 FlatList를 다시 렌더링하기 위해 사용됩니다.\n- handleFavoriteToggle: 레시피를 즐겨찾기 추가/취소하는 논리를 처리하는 함수입니다. 이 함수는 다음을 수행합니다:\n- recipesData 배열에서 올바른 레시피를 찾습니다.\n- 레시피의 isFavorite 속성을 토글합니다.\n- 다시 렌더링을 트리거하기 위해 setRecipesData를 사용하여 recipesData 상태를 업데이트합니다.\n- 렌더링을 강제로 수행하기 위해 setSelectedId를 통해 selectedId를 업데이트하여 하트/별표가 즉시 업데이트되도록 합니다.\n\n\n\n아래는 Markdown 형식으로 변환된 텍스트입니다:\n\n- **FlatList**: 레시피 목록을 효율적으로 렌더링하는 데 사용됩니다. 주요 속성은 다음과 같습니다:\n  - **data**: 현재 즐겨찾기 상태를 반영하도록 recipesData 배열을 사용합니다.\n  - **renderItem**: 데이터 내 각 레시피에 대해 RecipeCard 컴포넌트를 렌더링하며, 레시피 데이터와 handleFavoriteToggle 함수를 전달합니다.\n  - **keyExtractor**: 각 레시피 객체에서 고유 id 속성을 추출하여 효율적인 추적을 가능하도록 합니다.\n  - **numColumns**: 두 개의 열을 갖는 그리드를 생성합니다.\n  - **extraData**: 선택된 ID가 변경될 때 (즐겨찾기를 추가하거나 삭제할 때) FlatList가 업데이트된 즐겨찾기 상태를 반영하도록 합니다.\n\n## VirtualizedList을 위한 Wrapper로서 FlatList\n\n- **성능 중점**: FlatList는 효율성을 위해 VirtualizedList 기반으로 구축되었습니다. 화면에 현재 보이는 레시피 카드만 렌더링합니다. 많은 레시피가 있는 경우 부드러운 스크롤링을 위해 중요합니다.\n- **상태 제한**: 레시피 카드가 화면에서 스크롤되어 나가면 (예: 확장된 세부 정보 섹션이 있는 경우) 내부 상태가 기본적으로 유지되지 않습니다. 보통 Redux와 같은 중앙 집중형 저장소에 그러한 데이터를 저장합니다.\n\n\n\nPureComponent 동작\n\n- 변경 감지: PureComponent인 FlatList는 속성이나 기본 데이터가 실제로 변경될 때만 다시 렌더링되도록 최적화되어 있습니다. 여기서 extraData가 중요한 역할을 하며 레시피를 즐겨찾기로 지정하면 새로 고침이 트리거되어야 함을 알려줍니다.\n- 속성 동등성: 레시피 배열 내의 변경 사항이 감지됩니다. renderItem이 의존하는 모든 요소가 레시피 데이터에 포함되어 있거나 별도의 속성으로 전달되는지 확인하는 것이 중요합니다.\n\n메모리 관리 및 부드러운 스크롤링\n\n- 비동기 렌더링: FlatList는 스크롤이 부드럽게 느껴지도록 실제로 보이는 것보다 약간 앞의 내용을 렌더링합니다. 하지만 너무 빠르게 스크롤할 경우, 콘텐츠가로드될 때까지 잠깐 빈 공간이 보일 수 있습니다.\n\n\n\nkeyExtractor\n\n- 중요도: React에서 어떤 레시피 카드가 무엇인지 효율적으로 추적하는 것은 매우 중요합니다. 고유한 ID를 사용하는 것이 이상적인 방법입니다.\n\n## ItemSeparatorComponent\n\nReact Native의 FlatList와 관련된 ItemSeparatorComponent의 설명은 다음과 같습니다:\n\n\n\n목적:\n\n- ItemSeparatorComponent 속성을 사용하면 FlatList에 사용자 정의 구성 요소나 요소를 각 항목 사이에 삽입하여 시각적 구분선이나 간격을 만들 수 있습니다.\n\n작동 방식:\n\n- 기본값 없음: FlatList에 기본 구분자가 없습니다. ItemSeparatorComponent를 사용하면 간단히 추가할 수 있습니다.\n- 배치: 구분자 구성 요소는 각 항목 사이에 렌더링되며 목록의 맨 위와 맨 아래를 제외합니다.\n- renderItem 통합: FlatList의 renderItem 함수는 그 내부의 info 매개변수에 속성을 제공합니다:\n  - highlighted: 현재 항목이 강조 표시되는지 표시합니다 (예: 눌림).\n  - separators.highlight: 구분자를 강조 표시하는 함수입니다.\n  - separators.unhighlight: 구분자의 강조 표시를 제거하는 함수입니다.\n  - separators.updateProps: 구분자의 다른 사용자 지정 속성을 업데이트하는 함수입니다.\n\n\n\n유연성:\n\n- 컴포넌트: 사용자 정의 React 컴포넌트를 생성하여 구분자 역할을 할 수 있습니다. 이렇게 하면 외관과 동작에 대한 완전한 제어권을 갖게 됩니다.\n- 엘리먼트: 간단한 구분자의 경우 `View`와 같은 React 엘리먼트를 직접 전달하고 선 또는 간격을 위한 스타일링을 적용할 수 있습니다.\n\n예시:\n\n```js\nconst ItemSeparator = () =\u003e \u003cView style={ height: 1, backgroundColor: 'lightgray' } /\u003e;\n\n\u003cFlatList\n  data={myData}\n  renderItem={({ item }) =\u003e \u003cMyItemComponent item={item} /\u003e}\n  ItemSeparatorComponent={ItemSeparator} \n/\u003e\n```\n\n\n\n종류:\n\n- component: 리액트 컴포넌트 클래스 또는 함수형 컴포넌트.\n- function: 리액트 엘리먼트를 반환하는 함수.\n- element: 직접적인 리액트 엘리먼트 (시각적 구분선을 위한 간단한 뷰일 때가 많음)\n\n## 스타일링 속성\n\n다음은 리액트 네이티브의 FlatList 컴포넌트 내에서 다양한 스타일링 속성 및 다른 중요한 목록 관련 속성에 대한 설명입니다:\n\n\n\n# ListEmptyComponent\n\n리액트 네이티브의 FlatList에서 ListEmptyComponent가 어떻게 작동하는지 살펴보겠습니다:\n\n목적:\n\n- ListEmptyComponent 속성은 FlatList가 렌더링할 데이터가 없을 때(즉, 데이터 배열이 비어있을 때) 표시할 내용을 결정합니다.\n- 완전히 비어있는 화면이 아닌 사용자에게 친숙한 메시지나 시각적 표시 방법을 제공합니다.\n\n\n\n작동 방식:\n\n- 조건부 렌더링: FlatList는 자동으로 데이터 배열이 비어 있는지 확인합니다. 데이터 배열이 비어있으면 보통의 목록 항목 대신 ListEmptyComponent를 렌더링합니다.\n- 유연성: 렌더링할 대상에 대해 두 가지 주요 옵션이 있습니다:\n\n    - React 컴포넌트: 사용자 정의 React 컴포넌트(예: EmptyListComponent)를 만들어 메시지, 이미지, \"새로 고침\" 버튼과 같은 작업을 제공합니다. 외관과 기능에 완전한 제어권을 제공합니다.\n\n  2. React 엘리먼트: 종종 \"단순한\" 것처럼 React 엘리먼트를 직접 제공합니다:\n\n\n\n```js\n\u003cText style={textAlign: 'center'}\u003e레시피를 찾을 수 없어요!\u003c/Text\u003e\n```\n\n```js\nconst EmptyListComponent = () =\u003e (\n    \u003cView style={styles.emptyContainer}\u003e\n        \u003cText style={styles.emptyText}\u003e아직 레시피가 없어요!\u003c/Text\u003e\n    \u003c/View\u003e \n);\n\n\u003cFlatList\n    data={recipes}\n    renderItem={({ item }) =\u003e \u003cRecipeCard recipe={item} /\u003e} \n    ListEmptyComponent={EmptyListComponent} \n/\u003e\r\n```\n\n유형\n\n- component: React 컴포넌트 클래스 또는 함수형 컴포넌트.\n- element: React 요소 직접 사용.\n\n\n\n주요 포인트:\n\n- 스타일링: 앱 디자인에 맞게 빈 컴포넌트의 스타일을 적절히 지정하세요.\n- 사용자 경험: 잘 디자인된 ListEmptyComponent는 맨 텅 빈 목록보다 훨씬 나은 경험을 제공할 수 있습니다.\n\n# ListFooterComponent\n\nReact Native의 FlatList 안에서 ListFooterComponent를 살펴봅시다.\n\n\n\n목적:\n\n- ListFooterComponent 속성을 사용하면 FlatList의 가장 아래에 일반 리스트 항목들 다음에 렌더링되는 구성 요소나 요소를 추가할 수 있습니다.\n- 일반적인 사용 사례:\n   - 추가 데이터를 가져오기 위한 \"더 보기\" 버튼 표시\n   - 데이터를 가져오는 동안 로딩 스피너 표시\n   - 나열된 항목을 기반으로 요약 정보나 총계 제공\n   - 광고를 위한 자리 표시\n\n작동 방식:\n\n- 배치: ListFooterComponent는 리스트의 절대적 끝에 일관되게 렌더링되며, 리스트가 화면 전체를 채우지 않더라도 렌더링됩니다.\n- 렌더링: 리스트에 데이터가 있는지 여부와 상관없이 렌더링됩니다.\n- 유연성: 다른 유사한 속성과 마찬가지로, 사용할 수 있는 옵션:\n   - React 구성 요소: 복잡한 레이아웃이나 상호작용을 위한 사용자 지정 구성 요소\n   - React 요소: 기본 디스플레이를 위한 `View`와 같은 간단한 요소\n\n\n\n예시\n\n```js\nconst FooterLoader = () =\u003e (\n  \u003cView style={styles.footer}\u003e\n    \u003cActivityIndicator size=\"small\" color=\"gray\" /\u003e\n    \u003cText style={styles.footerText}\u003e더 로딩 중...\u003c/Text\u003e\n  \u003c/View\u003e\n);\n\n\u003cFlatList\n  data={recipes}\n  renderItem={({ item }) =\u003e \u003cRecipeCard recipe={item} /\u003e}\n  ListFooterComponent={FooterLoader} \n/\u003e\r\n```\n\n유형\n\n- component: React 컴포넌트 클래스 또는 함수형 컴포넌트.\n- element: React 요소 직접.\n\n\n\n중요한 사항:\n\n- 스크롤: ListFooterComponent를 보려면 사용자가 목록의 맨 아래로 스크롤해야 할 수도 있습니다.\n- ListHeaderComponent: ListHeaderComponent라는 상대적인 요소가 있으며 비슷한 기능을 하지만 목록의 맨 위에 컴포넌트를 렌더링합니다.\n\n# ListFooterComponentStyle\n\nReact Native의 FlatList에서 ListFooterComponentStyle에 대해 이야기해봅시다.\n\n\n\n목적:\n\n- ListFooterComponentStyle prop을 사용하면 ListFooterComponent를 포함하는 내부 뷰에 사용자 정의 스타일을 적용할 수 있습니다. 이를 통해 목록 내의 footer 영역의 모양과 레이아웃을 제어할 수 있습니다.\n\n사용 방법:\n\n- StyleSheet를 Import하세요:\n\n\n\n```js\nimport { StyleSheet } from 'react-native';\n```\n\n2. 스타일 생성:\n\n```js\nconst styles = StyleSheet.create({\n    footerContainer: {\n        backgroundColor: 'lightblue',\n        padding: 20,\n        alignItems: 'center' \n    }\n});\n```\n\n3. FlatList에 적용하기:\n\n\n\n```js\n\u003cFlatList\n    // ... 다른 FlatList 속성들\n    ListFooterComponent={footerComponent}\n    ListFooterComponentStyle={styles.footerContainer}\n/\u003e\n```\n\n스타일링 제어:\n\n- ListFooterComponentStyle 속성은 유효한 View 스타일 속성을 받습니다. 다음과 같이 사용자 정의할 수 있습니다:\n- 레이아웃: flex, flexDirection, justifyContent, alignItems 등\n- 배경: backgroundColor\n- 크기: height, width, padding, margin\n- 테두리: borderWidth, borderColor, borderRadius\n- ... 그 외 등등!\n\n중요한 고려 사항:\n\n\n\n- 내부 뷰: ListFooterComponent를 보유하는 컨테이너를 스타일링하고 있습니다. 컴포넌트 자체를 스타일링하고 있지 않습니다.\n- 컴포넌트 스타일링: 필요하다면 ListFooterComponent를 따로 스타일링하세요.\n\n예시:\n\n화면 하단에 고정된 푸터를 원한다면:\n\n```js\nListFooterComponentStyle={ \n    position: 'absolute',\n    bottom: 0,\n    left: 0,\n    right: 0\n}\n```\n\n\n\n팁\n\n- 지금까지 보여준 대로 스타일 시트를 사용하여 구성된 스타일링을 하세요.\n- 원하는 푸터 레이아웃과 외관을 얻기 위해 실험해보세요!\n- ListFooterComponentStyle: ListFooterComponent를 보유하는 컨테이너에 스타일을 적용합니다.\n- ListHeaderComponentStyle: ListHeaderComponent를 보유하는 컨테이너에 스타일을 적용합니다.\n- columnWrapperStyle: numColumns를 사용하는 경우 다중 항목 행의 스타일을 사용자 정의합니다.\n\n스타일링에 대한 중요한 참고 사항\n\n- 이러한 props은 레이아웃, 테두리, 배경 등을 사용자 정의하기 위한 유효한 ViewStyle 속성을 수용합니다.\n- 일반적으로 헤더, 푸터 및 항목 구성 요소를 내부 콘텐츠에 대해 별도로 스타일링할 것입니다.\n\n\n\n기타 중요한 속성들\n\n좀 더 복잡하거나 자주 사용되는 몇 가지 속성들을 알아보겠습니다:\n\n- **extraData:**\n  - 주요 데이터 속성 외부의 데이터가 변경될 때 FlatList(순수 컴포넌트)에게 다시 렌더링하도록 지시합니다.\n  - 항목 자체가 아닌 다른 요소에 기반한 동적 업데이트에 유용합니다(예: 컴포넌트 내 선택된 상태 등).\n- **getItemLayout:**\n  - 최적화: 성능 향상을 위해 항목의 높이와 오프셋을 미리 계산하여 크기가 고정된 항목의 목록에 사용됩니다.\n- **horizontal:**\n  - 목록의 레이아웃을 가로 스크롤링으로 전환합니다.\n- **initialNumToRender:**\n  - 초기 경험을 더 부드럽게 하기 위해 처음에 렌더링할 항목 수를 지정합니다.\n- **inverted:**\n  - 목록의 방향을 반대로 바꿉니다.\n- **keyExtractor:**\n  - 항목에 대한 고유한 키를 제공하여 React의 렌더링 효율성을 유지합니다.\n- **numColumns:**\n  - 다중 열 그리드 레이아웃을 만듭니다.\n- **onRefresh \u0026 refreshing:**\n  - \"당겨서 새로고침\" 기능을 구현합니다.\n- **onViewableItemsChanged:**\n  - 항목 가시성이 변경될 때 트리거되는 콜백 함수(게으른 로딩과 같은 작업에 유용)입니다.\n- **viewabilityConfig:**\n  - onViewableItemsChanged 콜백이 트리거되는 조건을 세밀하게 조정합니다(가시성 임계값 등).\n\n큰 목록을 최적화하기\n\n\n\n### onViewableItemsChanged\n\n**도전 과제:** FlatList를 사용하여 오래된 버전이나 성능이 떨어지는 장치에서 특히 많은 데이터 목록을 표시할 때 성능 문제를 겪을 수 있습니다. 한꺼번에 많은 항목을 렌더링하면 장치에 과부하가 걸려 스크롤이 느려지거나 프레임이 떨어질 수 있습니다.\n\n**해결책:** React Native의 FlatList 컴포넌트는 이러한 성능 문제를 해결하기 위해 설계된 onViewableItemsChanged라는 강력한 속성을 제공합니다. 이는 목록 내 항목의 가시성이 변경될 때마다 호출되는 콜백 함수를 제공합니다. 이를 통해 다음과 같은 최적화를 전략적으로 구현할 수 있습니다:\n\n- **지연 로딩:** 사용자가 목록 끝에 접근할 때만 추가 데이터를 가져와 렌더링합니다.\n- **미디어 제어:** 비디오가 뷰포트를 벗어나거나 들어올 때 비디오를 일시 정지하거나 재생하여 자원을 절약합니다.\n- **선택적 업데이트:** 현재 가시 상태인 항목에 따라 FlatList 바깥쪽의 UI 일부를 업데이트합니다.\n\n\n\n`onViewableItemsChanged` Prop에 대해 설명드리겠습니다.\n\n함수 서명:\n\n```js\nonViewableItemsChanged: ({ changed, viewableItems }) =\u003e void\n```\n\n- changed: ViewToken 객체의 배열입니다. 각 객체는 특정 항목의 가시성 변경을 설명합니다.\n- viewableItems: 현재 뷰포트 내에서 실제로 보이는 항목을 나타내는 ViewToken 객체의 배열입니다.\n\n\n\nViewToken 구조:\n\n- index: 데이터 배열 내 항목의 인덱스입니다.\n- isViewable: 해당 항목이 보이는 영역 내에 있는 경우 true이고, 그렇지 않으면 false인 부울 값입니다.\n- key: 항목에 제공한 고유한 키입니다.\n- (기타 속성 가능): ViewToken은 viewabilityConfig에 기반한 추가 속성을 가질 수 있습니다.\n\n키 구성 옵션 (viewabilityConfig)\n\n- viewAreaCoveragePercentThreshold: 콜백을 트리거하기 위해 항목의 영역 중 얼마나 비춰져 있어야 하는지 결정하는 숫자 (예: 50).\n- itemVisiblePercentThreshold: 화면에 표시되어야 하는 항목의 얼마나 많은 부분을 제어하는 숫자 (항목의 높이가 다른 목록에 유용).\n- minimumViewTime: 항목이 \"보이는\" 것으로 간주되기 전에 보이는 지속 시간을 설정하는 밀리초 단위의 값입니다.\n- waitForInteraction: true인 경우 사용자가 목록과 상호 작용한 후까지 가시성 업데이트를 지연시켜 빠른 스크롤 중에 성능을 향상시킵니다.\n\n\n\n실용적인 예시: 무한 스크롤링\n\n```js\nconst handleViewableItemsChanged = ({ viewableItems }) =\u003e {\n  const isLastItemVisible = viewableItems[viewableItems.length - 1].isViewable;\n  if (isLastItemVisible \u0026\u0026 !isLoading) {  \n    loadMoreData(); \n  }\n};\n\n\u003cFlatList\n    data={data}\n    onViewableItemsChanged={handleViewableItemsChanged}\n    viewabilityConfig={{ viewAreaCoveragePercentThreshold: 50 }} \n    // ... 다른 FlatList 속성들\n/\u003e\n```\n\n주의사항\n\n- 트레이드오프(Trade-offs): onViewableItemsChanged 내부에 과도하게 복잡한 계산을 포함하는 것은 성능에 영향을 줄 수 있습니다. 콜백을 트리거하는 방법을 세밀하게 조정하기 위해 viewabilityConfig을 사용하세요.\n- 실제 최적화 예시: 매우 복잡한 시나리오에서는 onViewableItemsChanged를 getItemLayout과 결합하여 아이템 크기를 사전 계산하여 더 부드러운 스크롤링을 구현할 수 있습니다.\n\n\n\n## 스크롤 및 제어를 위한 주요 FlatList 메서드\n\n메서드 설명\n\n- flashScrollIndicators()\n- 목적: 스크롤 표시기(스크롤바)를 잠시 표시하여 사용자에게 시각적 피드백을 제공합니다.\n- 사용 사례: 목록 끝에 새 데이터를로드 한 후나 프로그래밍 방식으로 위치로 스크롤하는 경우에 사용합니다.\n- 예시:\n\n```js\nmyListRef.current.flashScrollIndicators();\n```\n\n\n\n- getNativeScrollRef()\n  - 목적: 기본 네이티브 스크롤 컴포넌트(예: ScrollView 또는 VirtualizedList)에 대한 참조를 제공합니다.\n  - 사용 사례: 절대적으로 필요한 경우에만 스크롤 컴포넌트의 하위 수준 사용자 정의를 위해 이에 액세스합니다. (대부분의 경우, 이는 필요하지 않을 것입니다).\n- getScrollResponder()\n  - 목적: 스크롤 상호작용을 관리하는 스크롤 응답자 객체에 대한 참조를 반환합니다.\n  - 사용 사례: 스크롤 동작을 세밀하게 조정하거나 특정 스크롤 이벤트에 응답해야 하는 고급 시나리오에서 사용합니다.\n- getScrollableNode()\n  - 목적: 스크롤 가능한 컴포넌트 자체에 대한 참조를 제공합니다.\n  - 사용 사례: 거의 필요하지 않습니다. 주로 스크롤 가능한 노드에서 직접 메서드를 호출해야 할 경우에 유용합니다.\n- scrollToEnd(params?: ' animated?: boolean ')\n  - 목적: 콘텐츠의 맨 끝(또는 목록이 수평인 경우 하단)으로 스크롤합니다.\n  - 옵션:\n    - animated (boolean, 기본: true): 스크롤을 애니메이션으로 제어할지 여부를 결정합니다.\n  - 예시:\n\n```js\nconst scrollToEnd = () =\u003e {\n    flatListRef.current.scrollToEnd({ animated: true }); \n};\n```\n\n* **중요:** 큰 목록의 경우, 부드럽고 효율적인 스크롤링을 위해 `getItemLayout` 속성을 사용하는지 확인하십시오.\n\nscrollToIndex(params: ' animated?: boolean; index: number; viewOffset?: number; viewPosition?: number; ')\n\n\n\n\n- 목적: 데이터 배열 내에서 특정 항목의 인덱스(위치)로 스크롤합니다.\n- 옵션:\n  - animated (boolean, 기본값: true): 애니메이션을 컨트롤합니다.\n  - index (number): 스크롤할 항목의 인덱스입니다.\n  - viewOffset (number): 픽셀 단위의 추가 오프셋입니다.\n  - viewPosition (number): 뷰포트 내 항목의 위치를 제어합니다 (0: 맨 위, 1: 맨 아래, 0.5: 중앙).\n- 예시:\n\n```js\nconst scrollToRecipe = (index) =\u003e {\n  flatListRef.current.scrollToIndex({ index, viewPosition: 0 }); // 화면 맨 위에 있는 항목의 맨 위로 스크롤\n};\n```\n\n- **강조:** 성능 개선을 위해 특정 항목으로 스크롤하는 우선적인 방법입니다.\n\nscrollToItem(params: ' animated?: boolean; item: Item; viewPosition?: number; ')\n\n\n\n- 목적: 데이터에서 아이템 객체를 제공하여 해당 항목으로 스크롤합니다.\n- 단점: 특히 대규모 목록의 경우 scrollToIndex보다 효율성이 떨어질 수 있으며 데이터 배열을 검색해야 할 수도 있습니다.\n- 참고: 가능하면 최상의 성능을 위해 scrollToIndex를 선택하십시오.\n\n## 이론을 실제로 구현하기: React Native의 FlatList를 활용한 인터랙티브 레시피 앱 제작\n\nFlatListDemonstration.jsx\n\n```js\nimport React, { useState, useCallback } from 'react';\nimport {\n  SafeAreaView,\n  FlatList,\n  Text,\n  TouchableOpacity,\n  ActivityIndicator,\n  RefreshControl,\n  StyleSheet,\n  TextInput,\n  View,\n} from 'react-native';\nimport recipesData from '../data/recipeData'; // 데이터가 올바르게 형식화되었는지 확인\nimport { useNavigation } from '@react-navigation/native';\n\nconst FlatListDemonstration = () =\u003e {\n  const navigation = useNavigation();\n  const [recipes, setRecipes] = useState(recipesData);\n  const [isFetching, setIsFetching] = useState(false);\n  const [refreshing, setRefreshing] = useState(false);\n  const [searchQuery, setSearchQuery] = useState('');\n\n  const toggleFavorite = (id) =\u003e {\n    const newRecipes = recipes.map(recipe =\u003e\n      recipe.id === id ? { ...recipe, isFavorite: !recipe.isFavorite } : recipe,\n    );\n    setRecipes(newRecipes);\n    navigation.navigate('Favorites', {\n      recipes: newRecipes.filter(r =\u003e r.isFavorite),\n    });\n  };\n\n  const handleSearch = (text) =\u003e {\n    setSearchQuery(text);\n    const filteredData = text\n      ? recipes.filter(recipe =\u003e\n          recipe.name.toLowerCase().includes(text.toLowerCase()),\n        )\n      : recipesData;\n    setRecipes(filteredData);\n  };\n\n  const onRefresh = useCallback(async () =\u003e {\n    setRefreshing(true);\n    await new Promise(resolve =\u003e setTimeout(resolve, 1500));\n    setRefreshing(false);\n  }, []);\n\n  return (\n    \u003cSafeAreaView style={styles.container}\u003e\n      \u003cTextInput\n        style={styles.searchBar}\n        placeholder=\"레시피 검색...\"\n        value={searchQuery}\n        onChangeText={handleSearch}\n      /\u003e\n      \u003cFlatList\n        data={recipes}\n        renderItem={({ item }) =\u003e (\n          \u003cView style={styles.item}\u003e\n            \u003cText style={styles.title}\u003e{item.name}\u003c/Text\u003e\n            \u003cView style={styles.actionArea}\u003e\n              \u003cTouchableOpacity onPress={() =\u003e toggleFavorite(item.id)}\u003e\n                \u003cText style={styles.favorite}\u003e\n                  {item.isFavorite ? '♥' : '☆'}\n                \u003c/Text\u003e\n              \u003c/TouchableOpacity\u003e\n              \u003cTouchableOpacity\n                onPress={() =\u003e\n                  navigation.navigate('RecipeDetails', { recipe: item })\n                }\u003e\n                \u003cText style={styles.detailsButton}\u003e세부 정보\u003c/Text\u003e\n              \u003c/TouchableOpacity\u003e\n            \u003c/View\u003e\n          \u003c/View\u003e\n        )}\n        keyExtractor={item =\u003e item.id.toString()}\n        refreshControl={\n          \u003cRefreshControl refreshing={refreshing} onRefresh={onRefresh} /\u003e\n        }\n      /\u003e\n    \u003c/SafeAreaView\u003e\n  );\n};\n\nexport default FlatListDemonstration;\n```\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_1.png\" /\u003e\n\nRecipeDetailsScreen.jsx\n\n```js\nimport React from 'react';\nimport {View, Text, StyleSheet, ScrollView} from 'react-native';\n\nconst RecipeDetailsScreen = ({route}) =\u003e {\n  const {recipe} = route.params;\n\n  return (\n    \u003cScrollView style={styles.container}\u003e\n      \u003cText style={styles.title}\u003e{recipe.name}\u003c/Text\u003e\n      \u003cText style={styles.description}\u003e{recipe.description}\u003c/Text\u003e\n      \u003cView style={styles.section}\u003e\n        \u003cText style={styles.header}\u003e재료\u003c/Text\u003e\n        {recipe.ingredients.map((ingredient, index) =\u003e (\n          \u003cText key={index} style={styles.text}\u003e\n            {ingredient.name}: {ingredient.quantity}\n          \u003c/Text\u003e\n        ))}\n      \u003c/View\u003e\n      \u003cView style={styles.section}\u003e\n        \u003cText style={styles.header}\u003e조리 방법\u003c/Text\u003e\n        {recipe.instructions.map((step, index) =\u003e (\n          \u003cText key={index} style={styles.text}\u003e\n            {index + 1}. {step}\n          \u003c/Text\u003e\n        ))}\n      \u003c/View\u003e\n    \u003c/ScrollView\u003e\n  );\n};\r\n```\n\n\u003cimg src=\"/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_2.png\" /\u003e\n\n\n\nFavouriteList.jsx\n\n```js\nimport React, {useState} from 'react';\nimport {View, Text, TouchableOpacity, Image, StyleSheet} from 'react-native';\nimport DraggableFlatList from 'react-native-draggable-flatlist';\nimport {GestureHandlerRootView} from 'react-native-gesture-handler';\nimport {useNavigation} from '@react-navigation/native';\nconst FavoriteList = ({route}) =\u003e {\n    const navigation = useNavigation();\n    const {recipes} = route.params;\n    const [favorites, setFavorites] = useState(recipes);\n\n    return (\n        \u003cGestureHandlerRootView style={styles.rootView}\u003e\n            \u003cView style={styles.container}\u003e\n                \u003cDraggableFlatList\n                    data={favorites}\n                    renderItem={({item, drag, isActive}) =\u003e (\n                        \u003cTouchableOpacity\n                            onLongPress={drag}\n                            style={[styles.card, isActive \u0026\u0026 styles.activeCard]}\n                        \u003e\n                            \u003cImage\n                                source={item.image}\n                                style={styles.recipeImage}\n                                accessibilityLabel={`Image of ${item.name}`}\n                            /\u003e\n                            \u003cView style={styles.textContainer}\u003e\n                                \u003cText style={styles.recipeTitle}\u003e{item.name}\u003c/Text\u003e\n                                \u003cText style={styles.recipeDescription}\u003e{item.description}\u003c/Text\u003e\n                                \u003cTouchableOpacity  style={styles.detailsButton}  onPress={() =\u003e\n                                    navigation.navigate('RecipeDetails', {recipe: item})}\n                                \u003e\n                                    \u003cText style={styles.detailsButtonText}\u003eView Details\u003c/Text\u003e\n                                \u003c/TouchableOpacity\u003e\n                            \u003c/View\u003e\n                        \u003c/TouchableOpacity\u003e\n                    )}\n                    keyExtractor={item =\u003e item.id.toString()}\n                    onDragEnd={({data}) =\u003e setFavorites(data)}\n                /\u003e\n            \u003c/View\u003e\n        \u003c/GestureHandlerRootView\u003e\n    );\n};\n```\n\n![Image 1](/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_3.png)\n\n![Image 2](/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_4.png)\n\n\n\n\nApp.jsx\n\n```js\nimport React from 'react';\nimport { NavigationContainer } from '@react-navigation/native';\nimport { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport FlatListDemonstration from './src/components/flatlist';\nimport RecipeDetailsScreen from './src/screens/RecipeDetailsScreen';\n\nimport FavoriteList from './src/components/FavoriteList';\n\nconst Stack = createNativeStackNavigator();\n\nconst App = () =\u003e {\n  return (\n      \u003cNavigationContainer\u003e\n        \u003cStack.Navigator initialRouteName=\"Home\"\u003e\n          \u003cStack.Screen\n            name=\"Home\"\n            component={FlatListDemonstration} // 홈 화면에 FlatListDemonstration 사용\n            options={{ title: 'Recipe List' }}\n          /\u003e\n\n          \u003cStack.Screen\n            name=\"RecipeDetails\"\n            component={RecipeDetailsScreen}\n            options={{ title: 'Recipe Details' }}\n          /\u003e\n          \n          \u003cStack.Screen name=\"Favorites\" component={FavoriteList} options={{ title: 'Favorite Recipes' }} /\u003e\n      \n        \u003c/Stack.Navigator\u003e\n      \u003c/NavigationContainer\u003e\n  );\n};\n\nexport default App;\n```\n\n컴포넌트와 역할:\n\n- FlatListDemonstration: 레시피 목록을 렌더링하는 주요 컴포넌트입니다. 레시피 데이터, 사용자 상호작용(검색, 즐겨찾기), 다른 화면으로의 이동을 관리합니다.\n- FavoriteList: DraggableFlatList 라이브러리를 사용하여 즐겨찾은 레시피 목록을 표시하는 컴포넌트로, 사용자가 순서를 변경할 수 있습니다.\n- RecipeDetailsScreen: FlatList에서 항목을 탭하면 특정 레시피의 세부 정보를 표시하는 컴포넌트입니다.\n\n\n\nFlatList와 관련된 주요 기능:\n\n- 상태 관리 (useState):\n  - 컴포넌트는 여러 상태 변수를 유지합니다:\n    - recipes: 레시피 데이터 배열을 보유합니다.\n    - isFetching: 데이터를 가져오는지 추적합니다 (풀 투 리프레시를 위한 가능성 있음).\n    - refreshing: 데이터 가져오는 동안 시각적 리프레시 인디케이터를 제어합니다.\n    - searchQuery: 사용자가 입력한 현재 검색어를 저장합니다.\n  - toggleFavorite 함수는 사용자가 레시피 항목의 즐겨찾기 버튼을 탭할 때 트리거됩니다. 이 함수는 특정 레시피를 찾아 isFavorite 속성을 토글하고, 필요에 따라 즐겨찾기 화면으로 이동을 트리거합니다.\n  - handleSearch 함수는 검색 바에서 사용자 입력에 따라 searchQuery 상태를 업데이트합니다. 그런 다음 검색어와 일치하는 레시피 데이터만 표시하기 위해 recipes 데이터를 필터링합니다.\n- 검색 기능:\n  - 검색 바를 사용하여 레시피 목록을 동적으로 필터링할 수 있습니다.\n  - 사용자가 검색 바에 입력할 때 handleSearch 함수가 호출되어 searchQuery 상태를 업데이트합니다.\n  - handleSearch 함수는 filter 메서드를 사용하여 recipes 데이터를 필터링합니다. 검색어의 소문자 버전을 포함하는 레시피 이름을 가진 레시피만 유지합니다.\n  - 필터링된 데이터는 새로운 recipes 상태로 설정되어 FlatList가 업데이트된 목록으로 다시 렌더링됩니다.\n- 내비게이션 (@react-navigation/native):\n  - 이 예제는 화면 간 부드러운 내비게이션을 위해 @react-navigation/native를 사용합니다.\n  - 레시피 항목을 누르면 toggleFavorite 함수가 호출되며, 레시피가 즐겨찾기 상태인 경우 즐겨찾기 화면으로 이동할 수 있습니다.\n  - \"자세히 보기\" 버튼을 누르면 navigation.navigate(`RecipeDetails`, 'recipe: item')이 호출되어 선택한 레시피 데이터를 매개변수로 전달하여 RecipeDetailsScreen을 내비게이션 스택에 푸시합니다.\n- 풀 투 리프레시 (RefreshControl):\n  - 풀 투 리프레시 기능을 구현하기 위해 RefreshControl 컴포넌트를 사용합니다.\n  - 사용자가 목록 상단에서 아래로 스와이프하면 onRefresh 함수가 호출됩니다.\n  - 이 예제에서 onRefresh는 데이터 가져오기를 모방하기 위해 1.5초 지연을 시뮬레이션하고, 그 후 refreshing 상태를 업데이트하여 리프레시 인디케이터를 끕니다.\n  - 실제 앱에서는 onRefresh가 아마도 API에서 새 데이터를 가져오고 recipes 상태를 그에 맞게 업데이트할 것입니다.\n\n더 많은 정보를 보려면 공식 문서를 방문해주세요: https://reactnative.dev/docs/flatlist\n\n이 글을 읽어주셔서 정말 감사합니다! 여러분의 지원과 관심이 저에게는 큰 힘이 됩니다. 유용하게 여기셨다면, 이를 즐길 수 있는 다른 사람들과 공유해보시기를 권장드립니다. 더 많은 통찰과 팁을 기대해주세요. 📚💖 우리 커뮤니티의 멋진 일원이 되어 주셔서 다시 한번 감사드립니다! 🌟\n\n\n\n# 스택데믹 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 응원하고 팔로우해 주세요! 👏\n- 저희를 팔로우하세요 X | LinkedIn | YouTube | Discord\n- 다른 플랫폼들도 방문해 주세요: In Plain English | CoFeed | Venture | Cubed\n- 스택데믹닷컴에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_0.png"},"coverImage":"/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_0.png","tag":["Tech"],"readingTime":26},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e소개\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eFlatList란 무엇인가요?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e성능 최적화: FlatList는 대규모 목록을 효율적으로 렌더링하기 위해 설계된 React Native 컴포넌트입니다. \"게으른 로딩\"이라는 기술을 통해 이를 수행합니다. 이는 화면에 현재 표시된 항목만 렌더링하고 사용자가 스크롤할 때 컴포넌트를 재활용함으로써 작동합니다.\u003c/li\u003e\n\u003cli\u003e이를 통해 많은 양의 데이터를 다룰 때에도 앱이 부드럽고 반응성 있게 유지됩니다.\u003c/li\u003e\n\u003cli\u003e필수적인 목록 기능: FlatList는 사용자 친화적인 목록을 구축하는 데 필수적인 다양한 기능을 제공합니다.\u003c/li\u003e\n\u003cli\u003e매우 맞춤화 가능: 속성, 스타일링, 사용자 정의 컴포넌트를 사용하여 목록의 모양과 느낌을 쉽게 조정할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFlatList를 사용하는 주요 장점들\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e성능, 성능, 성능: FlatList는 긴 목록을 처리할 때 빛을 발합니다. 게으르게 로딩하고 최적화 기술을 사용하여 데이터가 많아져도 앱이 느려지지 않도록 합니다.\u003c/li\u003e\n\u003cli\u003e내장 기능: 바퀴를 재창조할 필요 없어요. FlatList에는 현대적인 목록에서 기대할 수 있는 기능이 탑재되어 있습니다: 당겨서 새로고침, 헤더, 푸터, 항목 구분선, 특정 위치로 스크롤 등.\u003c/li\u003e\n\u003cli\u003e크로스 플랫폼: 하나의 코드 베이스로 iOS와 Android 기기에서 목록이 매끄럽게 작동합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e핵심 기능들:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eFlatList는 상자에서 바로 제공되는 주요 기능들로, 매우 유용하게 만들어집니다:\u003c/li\u003e\n\u003cli\u003e크로스 플랫폼: iOS와 Android에서 일관되게 작동합니다.\u003c/li\u003e\n\u003cli\u003e수평 모드: 표준 수직 및 수평 목록 간 전환 가능.\u003c/li\u003e\n\u003cli\u003e가시성 콜백: 보이는 항목을 추적하여, 사용자가 끝에 가까워질 때 추가 데이터를 로드할 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003e헤더 및 푸터: 헤더와 푸터를 목록에 쉽게 통합합니다.\u003c/li\u003e\n\u003cli\u003e구분선: 목록 항목 사이의 구분선 외관을 사용자 정의할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e당겨서 새로고침: 사용자가 목록 내용을 새로 고칠 수 있는 일반적인 인터페이스.\u003c/li\u003e\n\u003cli\u003e스크롤 로딩 (무한 스크롤): 사용자가 스크롤할 때 자연스럽게 더 많은 데이터를 로드합니다.\u003c/li\u003e\n\u003cli\u003eScrollToIndex: 목록에서 특정 항목으로 빠르게 이동합니다.\u003c/li\u003e\n\u003cli\u003e여러 열: 그리드 형식으로 목록을 렌더링합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFlatList을 언제 사용해볼까요?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e연락처 목록 표시\u003c/li\u003e\n\u003cli\u003e이미지 갤러리 만들기\u003c/li\u003e\n\u003cli\u003e뉴스 피드 또는 타임라인 구축\u003c/li\u003e\n\u003cli\u003e전자상거래 앱에서 제품 목록 렌더링\u003c/li\u003e\n\u003cli\u003e스크롤 가능한 항목 목록을 표시해야 하는 모든 시나리오\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e간단한 예제로 설명해 보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eFlatList\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myData = [ \u003cspan class=\"hljs-comment\"\u003e/* 데이터 객체 배열 */\u003c/span\u003e ];\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erenderItem\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ item }\u003c/span\u003e) =\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e{item.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e \n);\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eFlatList\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{myData}\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003erenderItem\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{renderItem}\u003c/span\u003e \n  \u003cspan class=\"hljs-attr\"\u003ekeyExtractor\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item\u003c/span\u003e =\u003e\u003c/span\u003e item.id} \n/\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e중요한 속성 설명해 드릴게요\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003edata: 리스트에 표시하려는 데이터 배열입니다.\u003c/li\u003e\n\u003cli\u003erenderItem: 데이터 배열에서 개별 항목을 가져와서 시각적으로 표현하는 JSX 구조를 반환하는 함수입니다.\u003c/li\u003e\n\u003cli\u003ekeyExtractor: 각 목록 항목에 대한 고유한 키를 생성하는 함수입니다 (React의 렌더링 최적화에 중요합니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eFlatList가 동적으로 업데이트되도록 만드는 방법\u003c/h2\u003e\n\u003cp\u003e이 핵심은 FlatList가 응용 프로그램 데이터 변경에 따라 디스플레이를 어떻게 업데이트할지 제어하는 데 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e선택 가능한 항목: FlatList에서 항목을 선택할 때 시각적으로 변경되도록 하는 것이 목표입니다 (예: 선택된 항목 강조 표시). 이를 위해 다음이 필요합니다:\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e상태(State): 현재 선택된 항목의 ID를 추적하기 위해 selectedId와 같은 상태 변수가 필요합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e시각적 스타일링: renderItem 함수 내부에서 항목의 ID가 선택된 ID와 일치하는지 여부에 따라 다른 스타일을 적용해야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eextraData - 업데이트의 핵심:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFlatList는 PureComponent이므로 생성자에서 직접 변경된 경우에만 다시 렌더링됩니다.\u003c/li\u003e\n\u003cli\u003e항목을 선택하는 경우 대부분 FlatList 자체의 속성 외부에서 상태를 변경하므로, extraData='selectedId'를 사용하여 selectedId 상태 변수가 변경될 때마다 FlatList가 다시 렌더링되어야 함을 알립니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ekeyExtractor - 고유 키 보장하기:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ekeyExtractor는 React에서 리스트를 업데이트할 때 효율적으로 사용됩니다. 데이터의 각 항목에서 고유 키(일반적으로 ID)를 추출하는 방법을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eFlatList\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eStyleSheet\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eTouchableOpacity\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e recipes = [\n  { \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'recipe1'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'맛있는 팬케이크'\u003c/span\u003e },\n  { \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'recipe2'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'초콜릿 케이크'\u003c/span\u003e },\n  \u003cspan class=\"hljs-comment\"\u003e// ... 더 많은 레시피\u003c/span\u003e\n];\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eRecipeCard\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ recipe, onFavoriteToggle }\u003c/span\u003e) =\u003e { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e ( \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eTouchableOpacity\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonPress\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e onFavoriteToggle(recipe.id)}\u003e \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.card}\u003c/span\u003e\u003e\u003c/span\u003e \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.title}\u003c/span\u003e\u003e\u003c/span\u003e{recipe.title}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e {/* 가상: 여기에 이미지가 있을 것 */} \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{recipe.isFavorite\u003c/span\u003e ? \u003cspan class=\"hljs-attr\"\u003estyles.favorite\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyles.notFavorite\u003c/span\u003e}\u003e\u003c/span\u003e {recipe.isFavorite ? '♥ 즐겨찾기한 레시피' : '☆ 즐겨찾기하기' } \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eTouchableOpacity\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e ); };\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eRecipeApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [recipesData, setRecipesData] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(recipes); \u003cspan class=\"hljs-comment\"\u003e// 즐겨찾기 관리\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [selectedId, setSelectedId] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// extraData에 여전히 사용됨\u003c/span\u003e\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleFavoriteToggle\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003erecipeId\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetRecipesData\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eprevRecipes\u003c/span\u003e =\u003e\u003c/span\u003e prevRecipes.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003erecipe\u003c/span\u003e =\u003e\u003c/span\u003e\n      recipe.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e === recipeId ? { ...recipe, \u003cspan class=\"hljs-attr\"\u003eisFavorite\u003c/span\u003e: !recipe.\u003cspan class=\"hljs-property\"\u003eisFavorite\u003c/span\u003e } : recipe\n    ));\n    \u003cspan class=\"hljs-title function_\"\u003esetSelectedId\u003c/span\u003e(recipeId); \n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eFlatList\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{recipesData}\u003c/span\u003e // \u003cspan class=\"hljs-attr\"\u003e업데이트된\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e데이터\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e전달\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003erenderItem\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{({\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eitem\u003c/span\u003e }) =\u003e\u003c/span\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eRecipeCard\u003c/span\u003e \n         \u003cspan class=\"hljs-attr\"\u003erecipe\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item}\u003c/span\u003e \n         \u003cspan class=\"hljs-attr\"\u003eisFavorite\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item.isFavorite}\u003c/span\u003e // \u003cspan class=\"hljs-attr\"\u003e속성으로\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e전달\u003c/span\u003e\n         \u003cspan class=\"hljs-attr\"\u003eonFavoriteToggle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleFavoriteToggle}\u003c/span\u003e \n        /\u003e\u003c/span\u003e \n      )} \n      keyExtractor={(item) =\u003e item.id} \n      numColumns={2} \n      extraData={selectedId} \n    /\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e데이터:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003erecipes: 초기 레시피 데이터를 보유한 간단한 배열입니다. 각 레시피에는 id 및 title 속성이 포함되어 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e구성 요소:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRecipeCard: 단일 레시피 카드를 표시하는 컴포넌트입니다. 제목, 이미지를 위한 자리 표시자 및 즐겨찾기 버튼이 포함되어 있습니다. 이 버튼은 레시피의 isFavorite 상태에 따라 동적으로 변경됩니다.\u003c/li\u003e\n\u003cli\u003eRecipeApp: 앱의 주요 컴포넌트입니다. 다음을 관리합니다:\u003c/li\u003e\n\u003cli\u003e상태:\u003c/li\u003e\n\u003cli\u003erecipesData: 레시피의 현재 상태를 유지하는 배열로, isFavorite 상태를 포함합니다. 이는 recipes 배열을 사용하여 초기화됩니다.\u003c/li\u003e\n\u003cli\u003eselectedId: 레시피를 즐겨찾기 추가하거나 취소할 때 FlatList를 다시 렌더링하기 위해 사용됩니다.\u003c/li\u003e\n\u003cli\u003ehandleFavoriteToggle: 레시피를 즐겨찾기 추가/취소하는 논리를 처리하는 함수입니다. 이 함수는 다음을 수행합니다:\u003c/li\u003e\n\u003cli\u003erecipesData 배열에서 올바른 레시피를 찾습니다.\u003c/li\u003e\n\u003cli\u003e레시피의 isFavorite 속성을 토글합니다.\u003c/li\u003e\n\u003cli\u003e다시 렌더링을 트리거하기 위해 setRecipesData를 사용하여 recipesData 상태를 업데이트합니다.\u003c/li\u003e\n\u003cli\u003e렌더링을 강제로 수행하기 위해 setSelectedId를 통해 selectedId를 업데이트하여 하트/별표가 즉시 업데이트되도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래는 Markdown 형식으로 변환된 텍스트입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eFlatList\u003c/strong\u003e: 레시피 목록을 효율적으로 렌더링하는 데 사용됩니다. 주요 속성은 다음과 같습니다:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003edata\u003c/strong\u003e: 현재 즐겨찾기 상태를 반영하도록 recipesData 배열을 사용합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003erenderItem\u003c/strong\u003e: 데이터 내 각 레시피에 대해 RecipeCard 컴포넌트를 렌더링하며, 레시피 데이터와 handleFavoriteToggle 함수를 전달합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ekeyExtractor\u003c/strong\u003e: 각 레시피 객체에서 고유 id 속성을 추출하여 효율적인 추적을 가능하도록 합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003enumColumns\u003c/strong\u003e: 두 개의 열을 갖는 그리드를 생성합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eextraData\u003c/strong\u003e: 선택된 ID가 변경될 때 (즐겨찾기를 추가하거나 삭제할 때) FlatList가 업데이트된 즐겨찾기 상태를 반영하도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eVirtualizedList을 위한 Wrapper로서 FlatList\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e성능 중점\u003c/strong\u003e: FlatList는 효율성을 위해 VirtualizedList 기반으로 구축되었습니다. 화면에 현재 보이는 레시피 카드만 렌더링합니다. 많은 레시피가 있는 경우 부드러운 스크롤링을 위해 중요합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e상태 제한\u003c/strong\u003e: 레시피 카드가 화면에서 스크롤되어 나가면 (예: 확장된 세부 정보 섹션이 있는 경우) 내부 상태가 기본적으로 유지되지 않습니다. 보통 Redux와 같은 중앙 집중형 저장소에 그러한 데이터를 저장합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePureComponent 동작\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e변경 감지: PureComponent인 FlatList는 속성이나 기본 데이터가 실제로 변경될 때만 다시 렌더링되도록 최적화되어 있습니다. 여기서 extraData가 중요한 역할을 하며 레시피를 즐겨찾기로 지정하면 새로 고침이 트리거되어야 함을 알려줍니다.\u003c/li\u003e\n\u003cli\u003e속성 동등성: 레시피 배열 내의 변경 사항이 감지됩니다. renderItem이 의존하는 모든 요소가 레시피 데이터에 포함되어 있거나 별도의 속성으로 전달되는지 확인하는 것이 중요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e메모리 관리 및 부드러운 스크롤링\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e비동기 렌더링: FlatList는 스크롤이 부드럽게 느껴지도록 실제로 보이는 것보다 약간 앞의 내용을 렌더링합니다. 하지만 너무 빠르게 스크롤할 경우, 콘텐츠가로드될 때까지 잠깐 빈 공간이 보일 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ekeyExtractor\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e중요도: React에서 어떤 레시피 카드가 무엇인지 효율적으로 추적하는 것은 매우 중요합니다. 고유한 ID를 사용하는 것이 이상적인 방법입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eItemSeparatorComponent\u003c/h2\u003e\n\u003cp\u003eReact Native의 FlatList와 관련된 ItemSeparatorComponent의 설명은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e목적:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eItemSeparatorComponent 속성을 사용하면 FlatList에 사용자 정의 구성 요소나 요소를 각 항목 사이에 삽입하여 시각적 구분선이나 간격을 만들 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e작동 방식:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기본값 없음: FlatList에 기본 구분자가 없습니다. ItemSeparatorComponent를 사용하면 간단히 추가할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e배치: 구분자 구성 요소는 각 항목 사이에 렌더링되며 목록의 맨 위와 맨 아래를 제외합니다.\u003c/li\u003e\n\u003cli\u003erenderItem 통합: FlatList의 renderItem 함수는 그 내부의 info 매개변수에 속성을 제공합니다:\n\u003cul\u003e\n\u003cli\u003ehighlighted: 현재 항목이 강조 표시되는지 표시합니다 (예: 눌림).\u003c/li\u003e\n\u003cli\u003eseparators.highlight: 구분자를 강조 표시하는 함수입니다.\u003c/li\u003e\n\u003cli\u003eseparators.unhighlight: 구분자의 강조 표시를 제거하는 함수입니다.\u003c/li\u003e\n\u003cli\u003eseparators.updateProps: 구분자의 다른 사용자 지정 속성을 업데이트하는 함수입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e유연성:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e컴포넌트: 사용자 정의 React 컴포넌트를 생성하여 구분자 역할을 할 수 있습니다. 이렇게 하면 외관과 동작에 대한 완전한 제어권을 갖게 됩니다.\u003c/li\u003e\n\u003cli\u003e엘리먼트: 간단한 구분자의 경우 \u003ccode\u003eView\u003c/code\u003e와 같은 React 엘리먼트를 직접 전달하고 선 또는 간격을 위한 스타일링을 적용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eItemSeparator\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eheight:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebackgroundColor:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003elightgray\u003c/span\u003e' } /\u003e\u003c/span\u003e\u003c/span\u003e;\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eFlatList\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{myData}\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003erenderItem\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{({\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eitem\u003c/span\u003e }) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMyItemComponent\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eitem\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item}\u003c/span\u003e /\u003e\u003c/span\u003e}\n  ItemSeparatorComponent={ItemSeparator} \n/\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e종류:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecomponent: 리액트 컴포넌트 클래스 또는 함수형 컴포넌트.\u003c/li\u003e\n\u003cli\u003efunction: 리액트 엘리먼트를 반환하는 함수.\u003c/li\u003e\n\u003cli\u003eelement: 직접적인 리액트 엘리먼트 (시각적 구분선을 위한 간단한 뷰일 때가 많음)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e스타일링 속성\u003c/h2\u003e\n\u003cp\u003e다음은 리액트 네이티브의 FlatList 컴포넌트 내에서 다양한 스타일링 속성 및 다른 중요한 목록 관련 속성에 대한 설명입니다:\u003c/p\u003e\n\u003ch1\u003eListEmptyComponent\u003c/h1\u003e\n\u003cp\u003e리액트 네이티브의 FlatList에서 ListEmptyComponent가 어떻게 작동하는지 살펴보겠습니다:\u003c/p\u003e\n\u003cp\u003e목적:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eListEmptyComponent 속성은 FlatList가 렌더링할 데이터가 없을 때(즉, 데이터 배열이 비어있을 때) 표시할 내용을 결정합니다.\u003c/li\u003e\n\u003cli\u003e완전히 비어있는 화면이 아닌 사용자에게 친숙한 메시지나 시각적 표시 방법을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e작동 방식:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e조건부 렌더링: FlatList는 자동으로 데이터 배열이 비어 있는지 확인합니다. 데이터 배열이 비어있으면 보통의 목록 항목 대신 ListEmptyComponent를 렌더링합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e유연성: 렌더링할 대상에 대해 두 가지 주요 옵션이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eReact 컴포넌트: 사용자 정의 React 컴포넌트(예: EmptyListComponent)를 만들어 메시지, 이미지, \"새로 고침\" 버튼과 같은 작업을 제공합니다. 외관과 기능에 완전한 제어권을 제공합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eReact 엘리먼트: 종종 \"단순한\" 것처럼 React 엘리먼트를 직접 제공합니다:\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e style={\u003cspan class=\"hljs-attr\"\u003etextAlign\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'center'\u003c/span\u003e}\u003e레시피를 찾을 수 없어요!\u0026#x3C;/\u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eEmptyListComponent\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.emptyContainer}\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.emptyText}\u003c/span\u003e\u003e\u003c/span\u003e아직 레시피가 없어요!\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e \n);\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eFlatList\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{recipes}\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003erenderItem\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{({\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eitem\u003c/span\u003e }) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eRecipeCard\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erecipe\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item}\u003c/span\u003e /\u003e\u003c/span\u003e} \n    ListEmptyComponent={EmptyListComponent} \n/\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e유형\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecomponent: React 컴포넌트 클래스 또는 함수형 컴포넌트.\u003c/li\u003e\n\u003cli\u003eelement: React 요소 직접 사용.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e주요 포인트:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e스타일링: 앱 디자인에 맞게 빈 컴포넌트의 스타일을 적절히 지정하세요.\u003c/li\u003e\n\u003cli\u003e사용자 경험: 잘 디자인된 ListEmptyComponent는 맨 텅 빈 목록보다 훨씬 나은 경험을 제공할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eListFooterComponent\u003c/h1\u003e\n\u003cp\u003eReact Native의 FlatList 안에서 ListFooterComponent를 살펴봅시다.\u003c/p\u003e\n\u003cp\u003e목적:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eListFooterComponent 속성을 사용하면 FlatList의 가장 아래에 일반 리스트 항목들 다음에 렌더링되는 구성 요소나 요소를 추가할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e일반적인 사용 사례:\n\u003cul\u003e\n\u003cli\u003e추가 데이터를 가져오기 위한 \"더 보기\" 버튼 표시\u003c/li\u003e\n\u003cli\u003e데이터를 가져오는 동안 로딩 스피너 표시\u003c/li\u003e\n\u003cli\u003e나열된 항목을 기반으로 요약 정보나 총계 제공\u003c/li\u003e\n\u003cli\u003e광고를 위한 자리 표시\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e작동 방식:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e배치: ListFooterComponent는 리스트의 절대적 끝에 일관되게 렌더링되며, 리스트가 화면 전체를 채우지 않더라도 렌더링됩니다.\u003c/li\u003e\n\u003cli\u003e렌더링: 리스트에 데이터가 있는지 여부와 상관없이 렌더링됩니다.\u003c/li\u003e\n\u003cli\u003e유연성: 다른 유사한 속성과 마찬가지로, 사용할 수 있는 옵션:\n\u003cul\u003e\n\u003cli\u003eReact 구성 요소: 복잡한 레이아웃이나 상호작용을 위한 사용자 지정 구성 요소\u003c/li\u003e\n\u003cli\u003eReact 요소: 기본 디스플레이를 위한 \u003ccode\u003eView\u003c/code\u003e와 같은 간단한 요소\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eFooterLoader\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e (\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.footer}\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eActivityIndicator\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esize\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"small\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"gray\"\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.footerText}\u003c/span\u003e\u003e\u003c/span\u003e더 로딩 중...\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n);\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eFlatList\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{recipes}\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003erenderItem\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{({\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eitem\u003c/span\u003e }) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eRecipeCard\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erecipe\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item}\u003c/span\u003e /\u003e\u003c/span\u003e}\n  ListFooterComponent={FooterLoader} \n/\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e유형\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecomponent: React 컴포넌트 클래스 또는 함수형 컴포넌트.\u003c/li\u003e\n\u003cli\u003eelement: React 요소 직접.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e중요한 사항:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e스크롤: ListFooterComponent를 보려면 사용자가 목록의 맨 아래로 스크롤해야 할 수도 있습니다.\u003c/li\u003e\n\u003cli\u003eListHeaderComponent: ListHeaderComponent라는 상대적인 요소가 있으며 비슷한 기능을 하지만 목록의 맨 위에 컴포넌트를 렌더링합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eListFooterComponentStyle\u003c/h1\u003e\n\u003cp\u003eReact Native의 FlatList에서 ListFooterComponentStyle에 대해 이야기해봅시다.\u003c/p\u003e\n\u003cp\u003e목적:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eListFooterComponentStyle prop을 사용하면 ListFooterComponent를 포함하는 내부 뷰에 사용자 정의 스타일을 적용할 수 있습니다. 이를 통해 목록 내의 footer 영역의 모양과 레이아웃을 제어할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e사용 방법:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStyleSheet를 Import하세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eStyleSheet\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e스타일 생성:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e styles = \u003cspan class=\"hljs-title class_\"\u003eStyleSheet\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003efooterContainer\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003ebackgroundColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'lightblue'\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003epadding\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ealignItems\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'center'\u003c/span\u003e \n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eFlatList에 적용하기:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eFlatList\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// ... 다른 FlatList 속성들\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eListFooterComponent\u003c/span\u003e={footerComponent}\n    \u003cspan class=\"hljs-title class_\"\u003eListFooterComponentStyle\u003c/span\u003e={styles.\u003cspan class=\"hljs-property\"\u003efooterContainer\u003c/span\u003e}\n/\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e스타일링 제어:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eListFooterComponentStyle 속성은 유효한 View 스타일 속성을 받습니다. 다음과 같이 사용자 정의할 수 있습니다:\u003c/li\u003e\n\u003cli\u003e레이아웃: flex, flexDirection, justifyContent, alignItems 등\u003c/li\u003e\n\u003cli\u003e배경: backgroundColor\u003c/li\u003e\n\u003cli\u003e크기: height, width, padding, margin\u003c/li\u003e\n\u003cli\u003e테두리: borderWidth, borderColor, borderRadius\u003c/li\u003e\n\u003cli\u003e... 그 외 등등!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e중요한 고려 사항:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e내부 뷰: ListFooterComponent를 보유하는 컨테이너를 스타일링하고 있습니다. 컴포넌트 자체를 스타일링하고 있지 않습니다.\u003c/li\u003e\n\u003cli\u003e컴포넌트 스타일링: 필요하다면 ListFooterComponent를 따로 스타일링하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cp\u003e화면 하단에 고정된 푸터를 원한다면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eListFooterComponentStyle\u003c/span\u003e={ \n    \u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'absolute'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ebottom\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eleft\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eright\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e팁\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e지금까지 보여준 대로 스타일 시트를 사용하여 구성된 스타일링을 하세요.\u003c/li\u003e\n\u003cli\u003e원하는 푸터 레이아웃과 외관을 얻기 위해 실험해보세요!\u003c/li\u003e\n\u003cli\u003eListFooterComponentStyle: ListFooterComponent를 보유하는 컨테이너에 스타일을 적용합니다.\u003c/li\u003e\n\u003cli\u003eListHeaderComponentStyle: ListHeaderComponent를 보유하는 컨테이너에 스타일을 적용합니다.\u003c/li\u003e\n\u003cli\u003ecolumnWrapperStyle: numColumns를 사용하는 경우 다중 항목 행의 스타일을 사용자 정의합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e스타일링에 대한 중요한 참고 사항\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이러한 props은 레이아웃, 테두리, 배경 등을 사용자 정의하기 위한 유효한 ViewStyle 속성을 수용합니다.\u003c/li\u003e\n\u003cli\u003e일반적으로 헤더, 푸터 및 항목 구성 요소를 내부 콘텐츠에 대해 별도로 스타일링할 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e기타 중요한 속성들\u003c/p\u003e\n\u003cp\u003e좀 더 복잡하거나 자주 사용되는 몇 가지 속성들을 알아보겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eextraData:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e주요 데이터 속성 외부의 데이터가 변경될 때 FlatList(순수 컴포넌트)에게 다시 렌더링하도록 지시합니다.\u003c/li\u003e\n\u003cli\u003e항목 자체가 아닌 다른 요소에 기반한 동적 업데이트에 유용합니다(예: 컴포넌트 내 선택된 상태 등).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003egetItemLayout:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e최적화: 성능 향상을 위해 항목의 높이와 오프셋을 미리 계산하여 크기가 고정된 항목의 목록에 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ehorizontal:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e목록의 레이아웃을 가로 스크롤링으로 전환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003einitialNumToRender:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e초기 경험을 더 부드럽게 하기 위해 처음에 렌더링할 항목 수를 지정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003einverted:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e목록의 방향을 반대로 바꿉니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ekeyExtractor:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e항목에 대한 고유한 키를 제공하여 React의 렌더링 효율성을 유지합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003enumColumns:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e다중 열 그리드 레이아웃을 만듭니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eonRefresh \u0026#x26; refreshing:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\"당겨서 새로고침\" 기능을 구현합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eonViewableItemsChanged:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e항목 가시성이 변경될 때 트리거되는 콜백 함수(게으른 로딩과 같은 작업에 유용)입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eviewabilityConfig:\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eonViewableItemsChanged 콜백이 트리거되는 조건을 세밀하게 조정합니다(가시성 임계값 등).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e큰 목록을 최적화하기\u003c/p\u003e\n\u003ch3\u003eonViewableItemsChanged\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e도전 과제:\u003c/strong\u003e FlatList를 사용하여 오래된 버전이나 성능이 떨어지는 장치에서 특히 많은 데이터 목록을 표시할 때 성능 문제를 겪을 수 있습니다. 한꺼번에 많은 항목을 렌더링하면 장치에 과부하가 걸려 스크롤이 느려지거나 프레임이 떨어질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e해결책:\u003c/strong\u003e React Native의 FlatList 컴포넌트는 이러한 성능 문제를 해결하기 위해 설계된 onViewableItemsChanged라는 강력한 속성을 제공합니다. 이는 목록 내 항목의 가시성이 변경될 때마다 호출되는 콜백 함수를 제공합니다. 이를 통해 다음과 같은 최적화를 전략적으로 구현할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e지연 로딩:\u003c/strong\u003e 사용자가 목록 끝에 접근할 때만 추가 데이터를 가져와 렌더링합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e미디어 제어:\u003c/strong\u003e 비디오가 뷰포트를 벗어나거나 들어올 때 비디오를 일시 정지하거나 재생하여 자원을 절약합니다.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e선택적 업데이트:\u003c/strong\u003e 현재 가시 상태인 항목에 따라 FlatList 바깥쪽의 UI 일부를 업데이트합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eonViewableItemsChanged\u003c/code\u003e Prop에 대해 설명드리겠습니다.\u003c/p\u003e\n\u003cp\u003e함수 서명:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003eonViewableItemsChanged\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ changed, viewableItems }\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003echanged: ViewToken 객체의 배열입니다. 각 객체는 특정 항목의 가시성 변경을 설명합니다.\u003c/li\u003e\n\u003cli\u003eviewableItems: 현재 뷰포트 내에서 실제로 보이는 항목을 나타내는 ViewToken 객체의 배열입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eViewToken 구조:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eindex: 데이터 배열 내 항목의 인덱스입니다.\u003c/li\u003e\n\u003cli\u003eisViewable: 해당 항목이 보이는 영역 내에 있는 경우 true이고, 그렇지 않으면 false인 부울 값입니다.\u003c/li\u003e\n\u003cli\u003ekey: 항목에 제공한 고유한 키입니다.\u003c/li\u003e\n\u003cli\u003e(기타 속성 가능): ViewToken은 viewabilityConfig에 기반한 추가 속성을 가질 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e키 구성 옵션 (viewabilityConfig)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eviewAreaCoveragePercentThreshold: 콜백을 트리거하기 위해 항목의 영역 중 얼마나 비춰져 있어야 하는지 결정하는 숫자 (예: 50).\u003c/li\u003e\n\u003cli\u003eitemVisiblePercentThreshold: 화면에 표시되어야 하는 항목의 얼마나 많은 부분을 제어하는 숫자 (항목의 높이가 다른 목록에 유용).\u003c/li\u003e\n\u003cli\u003eminimumViewTime: 항목이 \"보이는\" 것으로 간주되기 전에 보이는 지속 시간을 설정하는 밀리초 단위의 값입니다.\u003c/li\u003e\n\u003cli\u003ewaitForInteraction: true인 경우 사용자가 목록과 상호 작용한 후까지 가시성 업데이트를 지연시켜 빠른 스크롤 중에 성능을 향상시킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e실용적인 예시: 무한 스크롤링\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleViewableItemsChanged\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{ viewableItems }\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isLastItemVisible = viewableItems[viewableItems.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003eisViewable\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isLastItemVisible \u0026#x26;\u0026#x26; !isLoading) {  \n    \u003cspan class=\"hljs-title function_\"\u003eloadMoreData\u003c/span\u003e(); \n  }\n};\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eFlatList\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{data}\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eonViewableItemsChanged\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleViewableItemsChanged}\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eviewabilityConfig\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eviewAreaCoveragePercentThreshold:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e50\u003c/span\u003e }} \n    // \u003cspan class=\"hljs-attr\"\u003e...\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e다른\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eFlatList\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e속성들\u003c/span\u003e\n/\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e주의사항\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e트레이드오프(Trade-offs): onViewableItemsChanged 내부에 과도하게 복잡한 계산을 포함하는 것은 성능에 영향을 줄 수 있습니다. 콜백을 트리거하는 방법을 세밀하게 조정하기 위해 viewabilityConfig을 사용하세요.\u003c/li\u003e\n\u003cli\u003e실제 최적화 예시: 매우 복잡한 시나리오에서는 onViewableItemsChanged를 getItemLayout과 결합하여 아이템 크기를 사전 계산하여 더 부드러운 스크롤링을 구현할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e스크롤 및 제어를 위한 주요 FlatList 메서드\u003c/h2\u003e\n\u003cp\u003e메서드 설명\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eflashScrollIndicators()\u003c/li\u003e\n\u003cli\u003e목적: 스크롤 표시기(스크롤바)를 잠시 표시하여 사용자에게 시각적 피드백을 제공합니다.\u003c/li\u003e\n\u003cli\u003e사용 사례: 목록 끝에 새 데이터를로드 한 후나 프로그래밍 방식으로 위치로 스크롤하는 경우에 사용합니다.\u003c/li\u003e\n\u003cli\u003e예시:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emyListRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eflashScrollIndicators\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003egetNativeScrollRef()\n\u003cul\u003e\n\u003cli\u003e목적: 기본 네이티브 스크롤 컴포넌트(예: ScrollView 또는 VirtualizedList)에 대한 참조를 제공합니다.\u003c/li\u003e\n\u003cli\u003e사용 사례: 절대적으로 필요한 경우에만 스크롤 컴포넌트의 하위 수준 사용자 정의를 위해 이에 액세스합니다. (대부분의 경우, 이는 필요하지 않을 것입니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003egetScrollResponder()\n\u003cul\u003e\n\u003cli\u003e목적: 스크롤 상호작용을 관리하는 스크롤 응답자 객체에 대한 참조를 반환합니다.\u003c/li\u003e\n\u003cli\u003e사용 사례: 스크롤 동작을 세밀하게 조정하거나 특정 스크롤 이벤트에 응답해야 하는 고급 시나리오에서 사용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003egetScrollableNode()\n\u003cul\u003e\n\u003cli\u003e목적: 스크롤 가능한 컴포넌트 자체에 대한 참조를 제공합니다.\u003c/li\u003e\n\u003cli\u003e사용 사례: 거의 필요하지 않습니다. 주로 스크롤 가능한 노드에서 직접 메서드를 호출해야 할 경우에 유용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003escrollToEnd(params?: ' animated?: boolean ')\n\u003cul\u003e\n\u003cli\u003e목적: 콘텐츠의 맨 끝(또는 목록이 수평인 경우 하단)으로 스크롤합니다.\u003c/li\u003e\n\u003cli\u003e옵션:\n\u003cul\u003e\n\u003cli\u003eanimated (boolean, 기본: true): 스크롤을 애니메이션으로 제어할지 여부를 결정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e예시:\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003escrollToEnd\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    flatListRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003escrollToEnd\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003eanimated\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e }); \n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e중요:\u003c/strong\u003e 큰 목록의 경우, 부드럽고 효율적인 스크롤링을 위해 \u003ccode\u003egetItemLayout\u003c/code\u003e 속성을 사용하는지 확인하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003escrollToIndex(params: ' animated?: boolean; index: number; viewOffset?: number; viewPosition?: number; ')\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e목적: 데이터 배열 내에서 특정 항목의 인덱스(위치)로 스크롤합니다.\u003c/li\u003e\n\u003cli\u003e옵션:\n\u003cul\u003e\n\u003cli\u003eanimated (boolean, 기본값: true): 애니메이션을 컨트롤합니다.\u003c/li\u003e\n\u003cli\u003eindex (number): 스크롤할 항목의 인덱스입니다.\u003c/li\u003e\n\u003cli\u003eviewOffset (number): 픽셀 단위의 추가 오프셋입니다.\u003c/li\u003e\n\u003cli\u003eviewPosition (number): 뷰포트 내 항목의 위치를 제어합니다 (0: 맨 위, 1: 맨 아래, 0.5: 중앙).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e예시:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003escrollToRecipe\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eindex\u003c/span\u003e) =\u003e {\n  flatListRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003escrollToIndex\u003c/span\u003e({ index, \u003cspan class=\"hljs-attr\"\u003eviewPosition\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e }); \u003cspan class=\"hljs-comment\"\u003e// 화면 맨 위에 있는 항목의 맨 위로 스크롤\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e강조:\u003c/strong\u003e 성능 개선을 위해 특정 항목으로 스크롤하는 우선적인 방법입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003escrollToItem(params: ' animated?: boolean; item: Item; viewPosition?: number; ')\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e목적: 데이터에서 아이템 객체를 제공하여 해당 항목으로 스크롤합니다.\u003c/li\u003e\n\u003cli\u003e단점: 특히 대규모 목록의 경우 scrollToIndex보다 효율성이 떨어질 수 있으며 데이터 배열을 검색해야 할 수도 있습니다.\u003c/li\u003e\n\u003cli\u003e참고: 가능하면 최상의 성능을 위해 scrollToIndex를 선택하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e이론을 실제로 구현하기: React Native의 FlatList를 활용한 인터랙티브 레시피 앱 제작\u003c/h2\u003e\n\u003cp\u003eFlatListDemonstration.jsx\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState, useCallback } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eSafeAreaView\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eFlatList\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eTouchableOpacity\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eActivityIndicator\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eRefreshControl\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eStyleSheet\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eTextInput\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e,\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e recipesData \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'../data/recipeData'\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 데이터가 올바르게 형식화되었는지 확인\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useNavigation } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@react-navigation/native'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eFlatListDemonstration\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e navigation = \u003cspan class=\"hljs-title function_\"\u003euseNavigation\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [recipes, setRecipes] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(recipesData);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [isFetching, setIsFetching] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [refreshing, setRefreshing] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [searchQuery, setSearchQuery] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etoggleFavorite\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eid\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newRecipes = recipes.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003erecipe\u003c/span\u003e =\u003e\u003c/span\u003e\n      recipe.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e === id ? { ...recipe, \u003cspan class=\"hljs-attr\"\u003eisFavorite\u003c/span\u003e: !recipe.\u003cspan class=\"hljs-property\"\u003eisFavorite\u003c/span\u003e } : recipe,\n    );\n    \u003cspan class=\"hljs-title function_\"\u003esetRecipes\u003c/span\u003e(newRecipes);\n    navigation.\u003cspan class=\"hljs-title function_\"\u003enavigate\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Favorites'\u003c/span\u003e, {\n      \u003cspan class=\"hljs-attr\"\u003erecipes\u003c/span\u003e: newRecipes.\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003er\u003c/span\u003e =\u003e\u003c/span\u003e r.\u003cspan class=\"hljs-property\"\u003eisFavorite\u003c/span\u003e),\n    });\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleSearch\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003etext\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetSearchQuery\u003c/span\u003e(text);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e filteredData = text\n      ? recipes.\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003erecipe\u003c/span\u003e =\u003e\u003c/span\u003e\n          recipe.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoLowerCase\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eincludes\u003c/span\u003e(text.\u003cspan class=\"hljs-title function_\"\u003etoLowerCase\u003c/span\u003e()),\n        )\n      : recipesData;\n    \u003cspan class=\"hljs-title function_\"\u003esetRecipes\u003c/span\u003e(filteredData);\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e onRefresh = \u003cspan class=\"hljs-title function_\"\u003euseCallback\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetRefreshing\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(resolve, \u003cspan class=\"hljs-number\"\u003e1500\u003c/span\u003e));\n    \u003cspan class=\"hljs-title function_\"\u003esetRefreshing\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n  }, []);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eSafeAreaView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.container}\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eTextInput\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.searchBar}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eplaceholder\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"레시피 검색...\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{searchQuery}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eonChangeText\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleSearch}\u003c/span\u003e\n      /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eFlatList\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{recipes}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erenderItem\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{({\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eitem\u003c/span\u003e }) =\u003e\u003c/span\u003e (\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.item}\u003c/span\u003e\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.title}\u003c/span\u003e\u003e\u003c/span\u003e{item.name}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.actionArea}\u003c/span\u003e\u003e\u003c/span\u003e\n              \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eTouchableOpacity\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonPress\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e toggleFavorite(item.id)}\u003e\n                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.favorite}\u003c/span\u003e\u003e\u003c/span\u003e\n                  {item.isFavorite ? '♥' : '☆'}\n                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n              \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eTouchableOpacity\u003c/span\u003e\u003e\u003c/span\u003e\n              \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eTouchableOpacity\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003eonPress\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e\n                  navigation.navigate('RecipeDetails', { recipe: item })\n                }\u003e\n                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.detailsButton}\u003c/span\u003e\u003e\u003c/span\u003e세부 정보\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n              \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eTouchableOpacity\u003c/span\u003e\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\n        )}\n        keyExtractor={item =\u003e item.id.toString()}\n        refreshControl={\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eRefreshControl\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erefreshing\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{refreshing}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonRefresh\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{onRefresh}\u003c/span\u003e /\u003e\u003c/span\u003e\n        }\n      /\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eSafeAreaView\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFlatListDemonstration\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_1.png\"\u003e\n\u003cp\u003eRecipeDetailsScreen.jsx\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eStyleSheet\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eScrollView\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eRecipeDetailsScreen\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{route}\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {recipe} = route.\u003cspan class=\"hljs-property\"\u003eparams\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eScrollView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.container}\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.title}\u003c/span\u003e\u003e\u003c/span\u003e{recipe.name}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.description}\u003c/span\u003e\u003e\u003c/span\u003e{recipe.description}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.section}\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.header}\u003c/span\u003e\u003e\u003c/span\u003e재료\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n        {recipe.ingredients.map((ingredient, index) =\u003e (\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{index}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.text}\u003c/span\u003e\u003e\u003c/span\u003e\n            {ingredient.name}: {ingredient.quantity}\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n        ))}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.section}\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.header}\u003c/span\u003e\u003e\u003c/span\u003e조리 방법\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n        {recipe.instructions.map((step, index) =\u003e (\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{index}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.text}\u003c/span\u003e\u003e\u003c/span\u003e\n            {index + 1}. {step}\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n        ))}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eScrollView\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_2.png\"\u003e\n\u003cp\u003eFavouriteList.jsx\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, {useState} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eTouchableOpacity\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eStyleSheet\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDraggableFlatList\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native-draggable-flatlist'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\u003cspan class=\"hljs-title class_\"\u003eGestureHandlerRootView\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native-gesture-handler'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {useNavigation} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@react-navigation/native'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eFavoriteList\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{route}\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e navigation = \u003cspan class=\"hljs-title function_\"\u003euseNavigation\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {recipes} = route.\u003cspan class=\"hljs-property\"\u003eparams\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [favorites, setFavorites] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(recipes);\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n        \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eGestureHandlerRootView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.rootView}\u003c/span\u003e\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.container}\u003c/span\u003e\u003e\u003c/span\u003e\n                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eDraggableFlatList\u003c/span\u003e\n                    \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{favorites}\u003c/span\u003e\n                    \u003cspan class=\"hljs-attr\"\u003erenderItem\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{({item,\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edrag\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eisActive\u003c/span\u003e}) =\u003e\u003c/span\u003e (\n                        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eTouchableOpacity\u003c/span\u003e\n                            \u003cspan class=\"hljs-attr\"\u003eonLongPress\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{drag}\u003c/span\u003e\n                            \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{[styles.card,\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eisActive\u003c/span\u003e \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-attr\"\u003estyles.activeCard\u003c/span\u003e]}\n                        \u003e\u003c/span\u003e\n                            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e\n                                \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item.image}\u003c/span\u003e\n                                \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.recipeImage}\u003c/span\u003e\n                                \u003cspan class=\"hljs-attr\"\u003eaccessibilityLabel\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e`\u003cspan class=\"hljs-attr\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eof\u003c/span\u003e ${\u003cspan class=\"hljs-attr\"\u003eitem.name\u003c/span\u003e}`}\n                            /\u003e\u003c/span\u003e\n                            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.textContainer}\u003c/span\u003e\u003e\u003c/span\u003e\n                                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.recipeTitle}\u003c/span\u003e\u003e\u003c/span\u003e{item.name}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n                                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.recipeDescription}\u003c/span\u003e\u003e\u003c/span\u003e{item.description}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n                                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eTouchableOpacity\u003c/span\u003e  \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.detailsButton}\u003c/span\u003e  \u003cspan class=\"hljs-attr\"\u003eonPress\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e\n                                    navigation.navigate('RecipeDetails', {recipe: item})}\n                                \u003e\n                                    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.detailsButtonText}\u003c/span\u003e\u003e\u003c/span\u003eView Details\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n                                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eTouchableOpacity\u003c/span\u003e\u003e\u003c/span\u003e\n                            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\n                        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eTouchableOpacity\u003c/span\u003e\u003e\u003c/span\u003e\n                    )}\n                    keyExtractor={item =\u003e item.id.toString()}\n                    onDragEnd={({data}) =\u003e setFavorites(data)}\n                /\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eGestureHandlerRootView\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n    );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_3.png\" alt=\"Image 1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide_4.png\" alt=\"Image 2\"\u003e\u003c/p\u003e\n\u003cp\u003eApp.jsx\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eNavigationContainer\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@react-navigation/native'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { createNativeStackNavigator } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@react-navigation/native-stack'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFlatListDemonstration\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./src/components/flatlist'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRecipeDetailsScreen\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./src/screens/RecipeDetailsScreen'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFavoriteList\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./src/components/FavoriteList'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStack\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ecreateNativeStackNavigator\u003c/span\u003e();\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n      \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eNavigationContainer\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eStack.Navigator\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003einitialRouteName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Home\"\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eStack.Screen\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Home\"\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{FlatListDemonstration}\u003c/span\u003e // \u003cspan class=\"hljs-attr\"\u003e홈\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e화면에\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eFlatListDemonstration\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e사용\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etitle:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003eRecipe\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eList\u003c/span\u003e' }}\n          /\u003e\u003c/span\u003e\n\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eStack.Screen\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"RecipeDetails\"\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{RecipeDetailsScreen}\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etitle:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003eRecipe\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eDetails\u003c/span\u003e' }}\n          /\u003e\u003c/span\u003e\n          \n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eStack.Screen\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Favorites\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{FavoriteList}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etitle:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003eFavorite\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eRecipes\u003c/span\u003e' }} /\u003e\u003c/span\u003e\n      \n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eStack.Navigator\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eNavigationContainer\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e컴포넌트와 역할:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFlatListDemonstration: 레시피 목록을 렌더링하는 주요 컴포넌트입니다. 레시피 데이터, 사용자 상호작용(검색, 즐겨찾기), 다른 화면으로의 이동을 관리합니다.\u003c/li\u003e\n\u003cli\u003eFavoriteList: DraggableFlatList 라이브러리를 사용하여 즐겨찾은 레시피 목록을 표시하는 컴포넌트로, 사용자가 순서를 변경할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eRecipeDetailsScreen: FlatList에서 항목을 탭하면 특정 레시피의 세부 정보를 표시하는 컴포넌트입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFlatList와 관련된 주요 기능:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e상태 관리 (useState):\n\u003cul\u003e\n\u003cli\u003e컴포넌트는 여러 상태 변수를 유지합니다:\n\u003cul\u003e\n\u003cli\u003erecipes: 레시피 데이터 배열을 보유합니다.\u003c/li\u003e\n\u003cli\u003eisFetching: 데이터를 가져오는지 추적합니다 (풀 투 리프레시를 위한 가능성 있음).\u003c/li\u003e\n\u003cli\u003erefreshing: 데이터 가져오는 동안 시각적 리프레시 인디케이터를 제어합니다.\u003c/li\u003e\n\u003cli\u003esearchQuery: 사용자가 입력한 현재 검색어를 저장합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003etoggleFavorite 함수는 사용자가 레시피 항목의 즐겨찾기 버튼을 탭할 때 트리거됩니다. 이 함수는 특정 레시피를 찾아 isFavorite 속성을 토글하고, 필요에 따라 즐겨찾기 화면으로 이동을 트리거합니다.\u003c/li\u003e\n\u003cli\u003ehandleSearch 함수는 검색 바에서 사용자 입력에 따라 searchQuery 상태를 업데이트합니다. 그런 다음 검색어와 일치하는 레시피 데이터만 표시하기 위해 recipes 데이터를 필터링합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e검색 기능:\n\u003cul\u003e\n\u003cli\u003e검색 바를 사용하여 레시피 목록을 동적으로 필터링할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e사용자가 검색 바에 입력할 때 handleSearch 함수가 호출되어 searchQuery 상태를 업데이트합니다.\u003c/li\u003e\n\u003cli\u003ehandleSearch 함수는 filter 메서드를 사용하여 recipes 데이터를 필터링합니다. 검색어의 소문자 버전을 포함하는 레시피 이름을 가진 레시피만 유지합니다.\u003c/li\u003e\n\u003cli\u003e필터링된 데이터는 새로운 recipes 상태로 설정되어 FlatList가 업데이트된 목록으로 다시 렌더링됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e내비게이션 (@react-navigation/native):\n\u003cul\u003e\n\u003cli\u003e이 예제는 화면 간 부드러운 내비게이션을 위해 @react-navigation/native를 사용합니다.\u003c/li\u003e\n\u003cli\u003e레시피 항목을 누르면 toggleFavorite 함수가 호출되며, 레시피가 즐겨찾기 상태인 경우 즐겨찾기 화면으로 이동할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e\"자세히 보기\" 버튼을 누르면 navigation.navigate(\u003ccode\u003eRecipeDetails\u003c/code\u003e, 'recipe: item')이 호출되어 선택한 레시피 데이터를 매개변수로 전달하여 RecipeDetailsScreen을 내비게이션 스택에 푸시합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e풀 투 리프레시 (RefreshControl):\n\u003cul\u003e\n\u003cli\u003e풀 투 리프레시 기능을 구현하기 위해 RefreshControl 컴포넌트를 사용합니다.\u003c/li\u003e\n\u003cli\u003e사용자가 목록 상단에서 아래로 스와이프하면 onRefresh 함수가 호출됩니다.\u003c/li\u003e\n\u003cli\u003e이 예제에서 onRefresh는 데이터 가져오기를 모방하기 위해 1.5초 지연을 시뮬레이션하고, 그 후 refreshing 상태를 업데이트하여 리프레시 인디케이터를 끕니다.\u003c/li\u003e\n\u003cli\u003e실제 앱에서는 onRefresh가 아마도 API에서 새 데이터를 가져오고 recipes 상태를 그에 맞게 업데이트할 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e더 많은 정보를 보려면 공식 문서를 방문해주세요: \u003ca href=\"https://reactnative.dev/docs/flatlist\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://reactnative.dev/docs/flatlist\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e이 글을 읽어주셔서 정말 감사합니다! 여러분의 지원과 관심이 저에게는 큰 힘이 됩니다. 유용하게 여기셨다면, 이를 즐길 수 있는 다른 사람들과 공유해보시기를 권장드립니다. 더 많은 통찰과 팁을 기대해주세요. 📚💖 우리 커뮤니티의 멋진 일원이 되어 주셔서 다시 한번 감사드립니다! 🌟\u003c/p\u003e\n\u003ch1\u003e스택데믹 🎓\u003c/h1\u003e\n\u003cp\u003e끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작가를 응원하고 팔로우해 주세요! 👏\u003c/li\u003e\n\u003cli\u003e저희를 팔로우하세요 X | LinkedIn | YouTube | Discord\u003c/li\u003e\n\u003cli\u003e다른 플랫폼들도 방문해 주세요: In Plain English | CoFeed | Venture | Cubed\u003c/li\u003e\n\u003cli\u003e스택데믹닷컴에서 더 많은 콘텐츠를 만나보세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-OptimizeYourReactNativeListswithFlatListAPerformanceGuide"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>