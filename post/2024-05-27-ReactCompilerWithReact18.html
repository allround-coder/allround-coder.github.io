<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트 컴파일러와 리액트 18에 대해서 알아보기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-27-ReactCompilerWithReact18" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트 컴파일러와 리액트 18에 대해서 알아보기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트 컴파일러와 리액트 18에 대해서 알아보기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-ReactCompilerWithReact18_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-27-ReactCompilerWithReact18" data-gatsby-head="true"/><meta name="twitter:title" content="리액트 컴파일러와 리액트 18에 대해서 알아보기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-ReactCompilerWithReact18_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 18:43" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트 컴파일러와 리액트 18에 대해서 알아보기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트 컴파일러와 리액트 18에 대해서 알아보기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-ReactCompilerWithReact18&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>우선, 아니요. React 컴파일러는 React 19의 일부가 아닙니다. React 19는 단순히 React 라이브러리일 뿐입니다. 빌드 변경사항은 없습니다. 따라서 React 컴파일러를 통합하려면 스스로 작업해야 합니다. 또한 React 컴파일러가 선택 사항이라는 것을 의미합니다. 이것이 좋은 점입니다.</p>
<p>React 19에 대한 포인트를 더 증명하기 위해 React 18 프로젝트에서 React 컴파일러를 사용하는 방법을 보여드릴게요.</p>
<p><img src="/assets/img/2024-05-27-ReactCompilerWithReact18_0.png" alt="ReactCompilerWithReact18_0"></p>
<h1>프로젝트 설정</h1>
<div class="content-ad"></div>
<p>이 예시에서는 다른 프레임워크와 달리 리액트 19가 아닌 리액트 18.2.0으로 설정되어 있어서 Vite를 사용할 것입니다.</p>
<pre><code class="hljs language-js">pnpm create vite r18-<span class="hljs-keyword">with</span>-compiler --template react
</code></pre>
<p>또한 TypeScript를 사용하지 않기로 했어요. 어떤 타이핑 문제를 피하기 위해서 우리가 생성한 c 훅을 반환하는 배열로 타이핑할 수 있어요.</p>
<h1>예제 만들기</h1>
<div class="content-ad"></div>
<p>컴파일러가 작동하는 방식을 보여주기 위해 최적화되지 않은 버전을 먼저 보여준 다음, 컴파일러를 설치하고 최적화된 버전을 확인해보겠습니다.</p>
<p>다음과 같이 App 컴포넌트를 이 구현으로 대체할 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Header"</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>());
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">header</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>React Counter<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">header</span>></span></span>
  );
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Header</span> /></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{count}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> setCount(count + 1)}>Increment<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;/></span></span>
  );
}
</code></pre>
<p>여기에는 간단한 헤더를 표시하는 새로운 Header 컴포넌트와 Header를 사용하고 자체적인 카운터 구현을 갖는 App 컴포넌트가 있습니다.</p>
<div class="content-ad"></div>
<p>최적화되지 않은 React 컴포넌트에서 Header는 매번 App이 버튼을 클릭하여 카운터를 업데이트할 때 다시 렌더링됩니다.</p>
<p>이를 직접 확인하기 위해 응용 프로그램을 시작하고 버튼을 클릭하세요. 클릭할 때마다 Header 컴포넌트에서 console.log를 볼 수 있어야 합니다.</p>
<h1>React 컴파일러를 사용한 최적화</h1>
<p>React 컴파일러는 우리의 App 컴포넌트(사실 Header도)를 최적화하는 방식으로 작동합니다. App에서 Header를 렌더링할 때 Header가 의존하는지 확인합니다. 좋은 소식은, Header가 어느 것에도 의존하지 않습니다. 그래서 Header를 렌더링한 것이 처음이면 마지막이 되어야 합니다. 컴파일러를 사용하는 것이 최적화된 결과입니다.</p>
<div class="content-ad"></div>
<p>잘 작업했다면 버튼을 클릭할 때 Header의 console.log에서 메시지가 표시되지 않을 것을 기대할 수 있습니다. 이는 Header 함수가 호출되지 않기 때문입니다.</p>
<p>먼저 React 컴파일러를 설치해야 합니다:</p>
<pre><code class="hljs language-js">pnpm add babel-plugin-react-compiler
</code></pre>
<p>그런 다음 Vite 구성에서 babel 플러그인을 구성해야 합니다. 제 경우에는 다음과 같이 보입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;
<span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-react"</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">"path"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">ReactCompilerConfig</span> = {
  <span class="hljs-attr">runtimeModule</span>: <span class="hljs-string">"@/mycache"</span>,
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">alias</span>: {
      <span class="hljs-string">"@"</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"./src"</span>),
    },
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">react</span>({
      <span class="hljs-attr">babel</span>: {
        <span class="hljs-attr">plugins</span>: [[<span class="hljs-string">"babel-plugin-react-compiler"</span>, <span class="hljs-title class_">ReactCompilerConfig</span>]],
      },
    }),
  ],
});
</code></pre>
<p>여기에는 두 가지 작업이 진행 중입니다. 무엇보다 defineConfig의 plugins 섹션을 사용하여 React Compiler babel 플러그인을 설치하고 구성하고 있습니다. 그리고 ReactCompilerConfig 객체로 컴파일러를 구성하고 있습니다.</p>
<p>컴파일러 구성에서는 컴파일러가 보통 react-compiler-runtime에서 가져오는 캐시 메모이제이션 훅을 @/mycache에서 가져오도록 지정하고 있습니다.</p>
<p>또한 @ 별칭을 설정하고 소스로 가리키도록해야 합니다. 이렇게 하면 컴포넌트가 위치한 곳과 관계없이 항상 우리의 훅을 찾을 수 있습니다.</p>
<div class="content-ad"></div>
<h1>무엇을 다시 하고 있나요?</h1>
<p>간단히 다시 돌아가서 무슨 일이 일어나고 있는지 이야기해 봅시다. 여기서 일어나고 있는 것은 React 컴파일러가 memoization을 사용하여 컴포넌트를 최적화한다는 것입니다. 그러나 이를 위해 전통적인 React.memo나 useMemo 또는 useCallback을 사용하는 것이 아닙니다. 대신 새로운 훅을 사용합니다. 해당 훅은 이전에는 useMemoCache로 불리다가 지금은 c로 불립니다. 그리고 react-compiler-runtime 라이브러리에 해당 훅이 내장되어 있습니다.</p>
<p>저는 react-compiler-runtime 라이브러리가 React 19에 의존한다고 확신합니다. 따라서 React 18과 함께 사용하려면 해당 라이브러리에서 c 함수의 직접적인 구현이 필요합니다. 실제로 그 함수는 매우 간단해서 문제가 되지 않습니다. 사실 너무 쉬워서 여기에 구현해 두었습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params">size</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =></span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size))[<span class="hljs-number">0</span>];
}
</code></pre>
<div class="content-ad"></div>
<p>잠깐만요. 말 그대로 하는 게 없어요. 먼저 사전 할당된 배열의 필요한 크기를 매개변수로 사용하고, 그 크기의 배열이 있는 컴포넌트와 관련된 몇 가지 상태를 반환합니다. 그래서 useState를 사용하여 해당 배열을 만들고 배열만 반환합니다.</p>
<p>실제로 이게 어떻게 작동하는지에 대해 조금 후에 알아보겠습니다. 지금은 src/mycache.js 파일(또는 원하는 곳)에 해당 C 구현을 저장해야 합니다. 그런 다음 어플리케이션을 실행하면, 바로! 버튼을 누르면 Header가 다시 렌더링되지 않습니다. 성공!</p>
<h1>약간 다른 구현</h1>
<p>다른 옵션은 사실상 패키지 관리자를 속여 ./src/mycache가 실제로 react-compiler-runtime 라이브러리라고 생각하게 하는 것입니다. 그래서 package.json 의 종속성에 이 부분을 추가할 수 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-string">"dependencies"</span>: { ..., <span class="hljs-string">"react-compiler-runtime"</span>: <span class="hljs-string">"file:./src/mycache"</span> }
</code></pre>
<p>그러고 나면 Vite 구성에서 ReactCompilerConfig 블록에서 runtimeModule 키를 제거할 수 있습니다.</p>
<p>이것은 공식 폴리필이며 가장 최신 버전은 이 기스트에 있습니다.</p>
<h1>그래서 왜 이 C 구현이 작동합니까?</h1>
<div class="content-ad"></div>
<p>이제 모든 것이 원활히 진행되었으니 이 C 구현을 한 번 더 살펴보고 왜 동작하는지 알아보려고 해봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params">size</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =></span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(size))[<span class="hljs-number">0</span>];
}
</code></pre>
<p>여기서 상태를 생성하고 그 상태를 반환하고 있습니다. 상태 설정 함수를 반환하지 않고 상태만 반환하고 있으니, 뭔가 이상하죠?</p>
<p>이 컴포넌트를 컴파일해보죠:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"foo"</span>></span>안녕하세요<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}
</code></pre>
<p>위의 코드가 아래와 같이 변합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> {c <span class="hljs-keyword">as</span> _c} <span class="hljs-keyword">from</span> <span class="hljs-string">"/src/mycache.js"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> $ = <span class="hljs-title function_">_c</span>(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">if</span> ($[<span class="hljs-number">0</span>] !== <span class="hljs-string">"a49bfc30998b8cb2..."</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> $i = <span class="hljs-number">0</span>; $i &#x3C; <span class="hljs-number">2</span>; $i += <span class="hljs-number">1</span>) {
            $[$i] = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">"react.memo_cache_sentinel"</span>);
        }
        $[<span class="hljs-number">0</span>] = <span class="hljs-string">"a49bfc30998b8cb2..."</span>;
    }
    <span class="hljs-keyword">let</span> t0;
    <span class="hljs-keyword">if</span> ($[<span class="hljs-number">1</span>] === <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">"react.memo_cache_sentinel"</span>)) {
        t0 = <span class="hljs-title function_">jsxDEV</span>(<span class="hljs-string">"div"</span>, {
            <span class="hljs-attr">className</span>: <span class="hljs-string">"foo"</span>,
            <span class="hljs-attr">children</span>: <span class="hljs-string">"안녕하세요"</span>
        }, <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, {
        }, <span class="hljs-variable language_">this</span>);
        $[<span class="hljs-number">1</span>] = t0;
    } <span class="hljs-keyword">else</span> {
        t0 = $[<span class="hljs-number">1</span>];
    }
    <span class="hljs-keyword">return</span> t0;
}
</code></pre>
<p>컴파일된 코드의 상단에서 c 훅을 불러오고 최적화된 컴포넌트에서 사용한다는 것을 확인할 수 있습니다. 컴파일러는 초기화된 플래그를 저장하는 데 첫 번째 슬롯, 두 번째 슬롯에는 DOM 트리가 포함된 JSX의 메모이즈된 버전을 저장할 때 두 개의 슬롯만 필요하다는 사실을 알고 있습니다.</p>
<div class="content-ad"></div>
<p>지금 c 훅이 어떻게 사용되는지 알았으니, 왜 우리의 구현이 작동하는지에 대해 조금 더 이해할 수 있게 되었습니다.</p>
<p>첫째, 우리는 메모이징을 하고 있고, 메모이징을 통해 컴포넌트를 다시 렌더링하게 만들 필요가 없습니다. 그래서 우리는 상태 설정 함수를 호출하지 않는 것입니다. 왜냐하면 그렇게 하면 다시 렌더링이 강제되기 때문입니다.</p>
<p>둘째, 우리는 useState로부터 배열에 대한 참조를 받기 때문에 (그리고 즉, 우리는 배열 내의 데이터를 단순히 배열 요소를 설정함으로써 변경할 수 있습니다) 데이터를 변경할 수 있고, 그 변경 사항은 유지될 것입니다. 왜냐하면 useState는 배열의 내용이 아니라 배열에 대한 참조를 유지하기 때문입니다.</p>
<p>그 두 번째 부분이 여러분을 헷갈리게 한다면, JavaScript 메모리 관리와 참조가 배열 및 객체와 관련하여 작동하는 방식에 대한 이 비디오를 추천합니다.</p>
<div class="content-ad"></div>
<h1>공식 Polyfill</h1>
<p>만약 이를 실제로 적용하고 싶다면 c 함수의 원본 소스를 확인해보세요. 그리고 작업 그룹 기사도 살펴보세요. 이 지침 외에도 공식 Polyfill을 따를 수 있습니다.</p>
<h1>더 깊게 들어가보기</h1>
<p>만약 React 컴파일러와 메모이제이션 작업 방식에 대해 더 자세히 알고 싶다면 제 React 컴파일러 영상을 꼭 시청해보세요.</p>
<div class="content-ad"></div>
<p>이 비디오는 메모이제이션의 메커니즘을 심도 있게 다루어서 React 컴포넌트 코드가 어떻게 변환되고 메모이징되며, 그 메모이제이션의 정밀도를 정말로 이해할 수 있도록 도와줍니다.</p>
<h2>가능하지만 권장되지 않는 방법</h2>
<p>무언가를 할 수 있다고 해서 반드시 해야 한다는 것은 아닙니다. 이 경우에도 그렇게 적용됩니다. React 컴파일러는 실제로 React 19 생태계 내에서 작동하도록 설계되었습니다. 그러므로 오늘 18 버전에서 사용할 수 있다고 해도, 내일 그것이 작동한다는 보장은 없습니다. 간단히 말해서, 사용 시 주의가 필요합니다. 레드 옥토버를 찾아서에서 말하는 대로 "가능하지만 권장되지 않습니다."</p>
<h2>더욱 심화된 주제</h2>
<div class="content-ad"></div>
<p>만약 당신이 이러한 고급 React 주제에 관심이 있다면, 특히 NextJS에 대해, 제 ProNextJS 뉴스레터에 가입해보세요. 그것을 통해 NextJS 상태 관리와 폼 관리에 대한 두 가지 무료 자습서에 액세스 할 수 있습니다. 그리고 ProNextJS 전체 코스가 출시될 때 알림을 받을 수도 있어요! 곧 공개될 예정이에요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트 컴파일러와 리액트 18에 대해서 알아보기","description":"","date":"2024-05-27 18:43","slug":"2024-05-27-ReactCompilerWithReact18","content":"\n\n우선, 아니요. React 컴파일러는 React 19의 일부가 아닙니다. React 19는 단순히 React 라이브러리일 뿐입니다. 빌드 변경사항은 없습니다. 따라서 React 컴파일러를 통합하려면 스스로 작업해야 합니다. 또한 React 컴파일러가 선택 사항이라는 것을 의미합니다. 이것이 좋은 점입니다.\n\nReact 19에 대한 포인트를 더 증명하기 위해 React 18 프로젝트에서 React 컴파일러를 사용하는 방법을 보여드릴게요.\n\n![ReactCompilerWithReact18_0](/assets/img/2024-05-27-ReactCompilerWithReact18_0.png)\n\n# 프로젝트 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는 다른 프레임워크와 달리 리액트 19가 아닌 리액트 18.2.0으로 설정되어 있어서 Vite를 사용할 것입니다.\n\n```js\npnpm create vite r18-with-compiler --template react\n```\n\n또한 TypeScript를 사용하지 않기로 했어요. 어떤 타이핑 문제를 피하기 위해서 우리가 생성한 c 훅을 반환하는 배열로 타이핑할 수 있어요.\n\n# 예제 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴파일러가 작동하는 방식을 보여주기 위해 최적화되지 않은 버전을 먼저 보여준 다음, 컴파일러를 설치하고 최적화된 버전을 확인해보겠습니다.\n\n다음과 같이 App 컴포넌트를 이 구현으로 대체할 것입니다:\n\n```js\nimport { useState } from \"react\";\n\nfunction Header() {\n  console.log(\"Header\", Math.random());\n  return (\n    \u003cheader\u003e\n      \u003ch1\u003eReact Counter\u003c/h1\u003e\n    \u003c/header\u003e\n  );\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  return (\n    \u003c\u003e\n      \u003cHeader /\u003e\n      \u003cdiv\u003e\n        \u003cp\u003e{count}\u003c/p\u003e\n        \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003eIncrement\u003c/button\u003e\n      \u003c/div\u003e\n    \u003c/\u003e\n  );\n}\n```\n\n여기에는 간단한 헤더를 표시하는 새로운 Header 컴포넌트와 Header를 사용하고 자체적인 카운터 구현을 갖는 App 컴포넌트가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최적화되지 않은 React 컴포넌트에서 Header는 매번 App이 버튼을 클릭하여 카운터를 업데이트할 때 다시 렌더링됩니다.\n\n이를 직접 확인하기 위해 응용 프로그램을 시작하고 버튼을 클릭하세요. 클릭할 때마다 Header 컴포넌트에서 console.log를 볼 수 있어야 합니다.\n\n# React 컴파일러를 사용한 최적화\n\nReact 컴파일러는 우리의 App 컴포넌트(사실 Header도)를 최적화하는 방식으로 작동합니다. App에서 Header를 렌더링할 때 Header가 의존하는지 확인합니다. 좋은 소식은, Header가 어느 것에도 의존하지 않습니다. 그래서 Header를 렌더링한 것이 처음이면 마지막이 되어야 합니다. 컴파일러를 사용하는 것이 최적화된 결과입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘 작업했다면 버튼을 클릭할 때 Header의 console.log에서 메시지가 표시되지 않을 것을 기대할 수 있습니다. 이는 Header 함수가 호출되지 않기 때문입니다.\n\n먼저 React 컴파일러를 설치해야 합니다:\n\n```js\npnpm add babel-plugin-react-compiler\n```\n\n그런 다음 Vite 구성에서 babel 플러그인을 구성해야 합니다. 제 경우에는 다음과 같이 보입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport path from \"path\";\n\nconst ReactCompilerConfig = {\n  runtimeModule: \"@/mycache\",\n};\n\nexport default defineConfig({\n  resolve: {\n    alias: {\n      \"@\": path.resolve(__dirname, \"./src\"),\n    },\n  },\n  plugins: [\n    react({\n      babel: {\n        plugins: [[\"babel-plugin-react-compiler\", ReactCompilerConfig]],\n      },\n    }),\n  ],\n});\n```\n\n여기에는 두 가지 작업이 진행 중입니다. 무엇보다 defineConfig의 plugins 섹션을 사용하여 React Compiler babel 플러그인을 설치하고 구성하고 있습니다. 그리고 ReactCompilerConfig 객체로 컴파일러를 구성하고 있습니다.\n\n컴파일러 구성에서는 컴파일러가 보통 react-compiler-runtime에서 가져오는 캐시 메모이제이션 훅을 @/mycache에서 가져오도록 지정하고 있습니다.\n\n또한 @ 별칭을 설정하고 소스로 가리키도록해야 합니다. 이렇게 하면 컴포넌트가 위치한 곳과 관계없이 항상 우리의 훅을 찾을 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 무엇을 다시 하고 있나요?\n\n간단히 다시 돌아가서 무슨 일이 일어나고 있는지 이야기해 봅시다. 여기서 일어나고 있는 것은 React 컴파일러가 memoization을 사용하여 컴포넌트를 최적화한다는 것입니다. 그러나 이를 위해 전통적인 React.memo나 useMemo 또는 useCallback을 사용하는 것이 아닙니다. 대신 새로운 훅을 사용합니다. 해당 훅은 이전에는 useMemoCache로 불리다가 지금은 c로 불립니다. 그리고 react-compiler-runtime 라이브러리에 해당 훅이 내장되어 있습니다.\n\n저는 react-compiler-runtime 라이브러리가 React 19에 의존한다고 확신합니다. 따라서 React 18과 함께 사용하려면 해당 라이브러리에서 c 함수의 직접적인 구현이 필요합니다. 실제로 그 함수는 매우 간단해서 문제가 되지 않습니다. 사실 너무 쉬워서 여기에 구현해 두었습니다:\n\n```js\nimport { useState } from \"react\";\n\nexport function c(size) {\n  return useState(() =\u003e new Array(size))[0];\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잠깐만요. 말 그대로 하는 게 없어요. 먼저 사전 할당된 배열의 필요한 크기를 매개변수로 사용하고, 그 크기의 배열이 있는 컴포넌트와 관련된 몇 가지 상태를 반환합니다. 그래서 useState를 사용하여 해당 배열을 만들고 배열만 반환합니다.\n\n실제로 이게 어떻게 작동하는지에 대해 조금 후에 알아보겠습니다. 지금은 src/mycache.js 파일(또는 원하는 곳)에 해당 C 구현을 저장해야 합니다. 그런 다음 어플리케이션을 실행하면, 바로! 버튼을 누르면 Header가 다시 렌더링되지 않습니다. 성공!\n\n# 약간 다른 구현\n\n다른 옵션은 사실상 패키지 관리자를 속여 ./src/mycache가 실제로 react-compiler-runtime 라이브러리라고 생각하게 하는 것입니다. 그래서 package.json 의 종속성에 이 부분을 추가할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\"dependencies\": { ..., \"react-compiler-runtime\": \"file:./src/mycache\" }\n```\n\n그러고 나면 Vite 구성에서 ReactCompilerConfig 블록에서 runtimeModule 키를 제거할 수 있습니다.\n\n이것은 공식 폴리필이며 가장 최신 버전은 이 기스트에 있습니다.\n\n# 그래서 왜 이 C 구현이 작동합니까?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 모든 것이 원활히 진행되었으니 이 C 구현을 한 번 더 살펴보고 왜 동작하는지 알아보려고 해봅시다.\n\n```js\nimport { useState } from \"react\";\n\nexport function c(size) {\n  return useState(() =\u003e new Array(size))[0];\n}\n```\n\n여기서 상태를 생성하고 그 상태를 반환하고 있습니다. 상태 설정 함수를 반환하지 않고 상태만 반환하고 있으니, 뭔가 이상하죠?\n\n이 컴포넌트를 컴파일해보죠:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport default function Hello() {\n  return \u003cdiv className=\"foo\"\u003e안녕하세요\u003c/div\u003e;\n}\n```\n\n위의 코드가 아래와 같이 변합니다:\n\n```js\nimport {c as _c} from \"/src/mycache.js\";\nexport default function Hello() {\n    const $ = _c(2);\n    if ($[0] !== \"a49bfc30998b8cb2...\") {\n        for (let $i = 0; $i \u003c 2; $i += 1) {\n            $[$i] = Symbol.for(\"react.memo_cache_sentinel\");\n        }\n        $[0] = \"a49bfc30998b8cb2...\";\n    }\n    let t0;\n    if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n        t0 = jsxDEV(\"div\", {\n            className: \"foo\",\n            children: \"안녕하세요\"\n        }, void 0, false, {\n        }, this);\n        $[1] = t0;\n    } else {\n        t0 = $[1];\n    }\n    return t0;\n}\n```\n\n컴파일된 코드의 상단에서 c 훅을 불러오고 최적화된 컴포넌트에서 사용한다는 것을 확인할 수 있습니다. 컴파일러는 초기화된 플래그를 저장하는 데 첫 번째 슬롯, 두 번째 슬롯에는 DOM 트리가 포함된 JSX의 메모이즈된 버전을 저장할 때 두 개의 슬롯만 필요하다는 사실을 알고 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 c 훅이 어떻게 사용되는지 알았으니, 왜 우리의 구현이 작동하는지에 대해 조금 더 이해할 수 있게 되었습니다.\n\n첫째, 우리는 메모이징을 하고 있고, 메모이징을 통해 컴포넌트를 다시 렌더링하게 만들 필요가 없습니다. 그래서 우리는 상태 설정 함수를 호출하지 않는 것입니다. 왜냐하면 그렇게 하면 다시 렌더링이 강제되기 때문입니다.\n\n둘째, 우리는 useState로부터 배열에 대한 참조를 받기 때문에 (그리고 즉, 우리는 배열 내의 데이터를 단순히 배열 요소를 설정함으로써 변경할 수 있습니다) 데이터를 변경할 수 있고, 그 변경 사항은 유지될 것입니다. 왜냐하면 useState는 배열의 내용이 아니라 배열에 대한 참조를 유지하기 때문입니다.\n\n그 두 번째 부분이 여러분을 헷갈리게 한다면, JavaScript 메모리 관리와 참조가 배열 및 객체와 관련하여 작동하는 방식에 대한 이 비디오를 추천합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 공식 Polyfill\n\n만약 이를 실제로 적용하고 싶다면 c 함수의 원본 소스를 확인해보세요. 그리고 작업 그룹 기사도 살펴보세요. 이 지침 외에도 공식 Polyfill을 따를 수 있습니다.\n\n# 더 깊게 들어가보기\n\n만약 React 컴파일러와 메모이제이션 작업 방식에 대해 더 자세히 알고 싶다면 제 React 컴파일러 영상을 꼭 시청해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 비디오는 메모이제이션의 메커니즘을 심도 있게 다루어서 React 컴포넌트 코드가 어떻게 변환되고 메모이징되며, 그 메모이제이션의 정밀도를 정말로 이해할 수 있도록 도와줍니다.\n\n## 가능하지만 권장되지 않는 방법\n\n무언가를 할 수 있다고 해서 반드시 해야 한다는 것은 아닙니다. 이 경우에도 그렇게 적용됩니다. React 컴파일러는 실제로 React 19 생태계 내에서 작동하도록 설계되었습니다. 그러므로 오늘 18 버전에서 사용할 수 있다고 해도, 내일 그것이 작동한다는 보장은 없습니다. 간단히 말해서, 사용 시 주의가 필요합니다. 레드 옥토버를 찾아서에서 말하는 대로 \"가능하지만 권장되지 않습니다.\"\n\n## 더욱 심화된 주제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 당신이 이러한 고급 React 주제에 관심이 있다면, 특히 NextJS에 대해, 제 ProNextJS 뉴스레터에 가입해보세요. 그것을 통해 NextJS 상태 관리와 폼 관리에 대한 두 가지 무료 자습서에 액세스 할 수 있습니다. 그리고 ProNextJS 전체 코스가 출시될 때 알림을 받을 수도 있어요! 곧 공개될 예정이에요!","ogImage":{"url":"/assets/img/2024-05-27-ReactCompilerWithReact18_0.png"},"coverImage":"/assets/img/2024-05-27-ReactCompilerWithReact18_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e우선, 아니요. React 컴파일러는 React 19의 일부가 아닙니다. React 19는 단순히 React 라이브러리일 뿐입니다. 빌드 변경사항은 없습니다. 따라서 React 컴파일러를 통합하려면 스스로 작업해야 합니다. 또한 React 컴파일러가 선택 사항이라는 것을 의미합니다. 이것이 좋은 점입니다.\u003c/p\u003e\n\u003cp\u003eReact 19에 대한 포인트를 더 증명하기 위해 React 18 프로젝트에서 React 컴파일러를 사용하는 방법을 보여드릴게요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-ReactCompilerWithReact18_0.png\" alt=\"ReactCompilerWithReact18_0\"\u003e\u003c/p\u003e\n\u003ch1\u003e프로젝트 설정\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 예시에서는 다른 프레임워크와 달리 리액트 19가 아닌 리액트 18.2.0으로 설정되어 있어서 Vite를 사용할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epnpm create vite r18-\u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e-compiler --template react\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한 TypeScript를 사용하지 않기로 했어요. 어떤 타이핑 문제를 피하기 위해서 우리가 생성한 c 훅을 반환하는 배열로 타이핑할 수 있어요.\u003c/p\u003e\n\u003ch1\u003e예제 만들기\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e컴파일러가 작동하는 방식을 보여주기 위해 최적화되지 않은 버전을 먼저 보여준 다음, 컴파일러를 설치하고 최적화된 버전을 확인해보겠습니다.\u003c/p\u003e\n\u003cp\u003e다음과 같이 App 컴포넌트를 이 구현으로 대체할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHeader\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Header\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e());\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eheader\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003eReact Counter\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eheader\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [count, setCount] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eHeader\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{count}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e setCount(count + 1)}\u003eIncrement\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에는 간단한 헤더를 표시하는 새로운 Header 컴포넌트와 Header를 사용하고 자체적인 카운터 구현을 갖는 App 컴포넌트가 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e최적화되지 않은 React 컴포넌트에서 Header는 매번 App이 버튼을 클릭하여 카운터를 업데이트할 때 다시 렌더링됩니다.\u003c/p\u003e\n\u003cp\u003e이를 직접 확인하기 위해 응용 프로그램을 시작하고 버튼을 클릭하세요. 클릭할 때마다 Header 컴포넌트에서 console.log를 볼 수 있어야 합니다.\u003c/p\u003e\n\u003ch1\u003eReact 컴파일러를 사용한 최적화\u003c/h1\u003e\n\u003cp\u003eReact 컴파일러는 우리의 App 컴포넌트(사실 Header도)를 최적화하는 방식으로 작동합니다. App에서 Header를 렌더링할 때 Header가 의존하는지 확인합니다. 좋은 소식은, Header가 어느 것에도 의존하지 않습니다. 그래서 Header를 렌더링한 것이 처음이면 마지막이 되어야 합니다. 컴파일러를 사용하는 것이 최적화된 결과입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e잘 작업했다면 버튼을 클릭할 때 Header의 console.log에서 메시지가 표시되지 않을 것을 기대할 수 있습니다. 이는 Header 함수가 호출되지 않기 때문입니다.\u003c/p\u003e\n\u003cp\u003e먼저 React 컴파일러를 설치해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epnpm add babel-plugin-react-compiler\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 Vite 구성에서 babel 플러그인을 구성해야 합니다. 제 경우에는 다음과 같이 보입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { defineConfig } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"vite\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e react \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@vitejs/plugin-react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e path \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"path\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactCompilerConfig\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eruntimeModule\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"@/mycache\"\u003c/span\u003e,\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefineConfig\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eresolve\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003ealias\u003c/span\u003e: {\n      \u003cspan class=\"hljs-string\"\u003e\"@\"\u003c/span\u003e: path.\u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(__dirname, \u003cspan class=\"hljs-string\"\u003e\"./src\"\u003c/span\u003e),\n    },\n  },\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n    \u003cspan class=\"hljs-title function_\"\u003ereact\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003ebabel\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [[\u003cspan class=\"hljs-string\"\u003e\"babel-plugin-react-compiler\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eReactCompilerConfig\u003c/span\u003e]],\n      },\n    }),\n  ],\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에는 두 가지 작업이 진행 중입니다. 무엇보다 defineConfig의 plugins 섹션을 사용하여 React Compiler babel 플러그인을 설치하고 구성하고 있습니다. 그리고 ReactCompilerConfig 객체로 컴파일러를 구성하고 있습니다.\u003c/p\u003e\n\u003cp\u003e컴파일러 구성에서는 컴파일러가 보통 react-compiler-runtime에서 가져오는 캐시 메모이제이션 훅을 @/mycache에서 가져오도록 지정하고 있습니다.\u003c/p\u003e\n\u003cp\u003e또한 @ 별칭을 설정하고 소스로 가리키도록해야 합니다. 이렇게 하면 컴포넌트가 위치한 곳과 관계없이 항상 우리의 훅을 찾을 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e무엇을 다시 하고 있나요?\u003c/h1\u003e\n\u003cp\u003e간단히 다시 돌아가서 무슨 일이 일어나고 있는지 이야기해 봅시다. 여기서 일어나고 있는 것은 React 컴파일러가 memoization을 사용하여 컴포넌트를 최적화한다는 것입니다. 그러나 이를 위해 전통적인 React.memo나 useMemo 또는 useCallback을 사용하는 것이 아닙니다. 대신 새로운 훅을 사용합니다. 해당 훅은 이전에는 useMemoCache로 불리다가 지금은 c로 불립니다. 그리고 react-compiler-runtime 라이브러리에 해당 훅이 내장되어 있습니다.\u003c/p\u003e\n\u003cp\u003e저는 react-compiler-runtime 라이브러리가 React 19에 의존한다고 확신합니다. 따라서 React 18과 함께 사용하려면 해당 라이브러리에서 c 함수의 직접적인 구현이 필요합니다. 실제로 그 함수는 매우 간단해서 문제가 되지 않습니다. 사실 너무 쉬워서 여기에 구현해 두었습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ec\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esize\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e(size))[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e잠깐만요. 말 그대로 하는 게 없어요. 먼저 사전 할당된 배열의 필요한 크기를 매개변수로 사용하고, 그 크기의 배열이 있는 컴포넌트와 관련된 몇 가지 상태를 반환합니다. 그래서 useState를 사용하여 해당 배열을 만들고 배열만 반환합니다.\u003c/p\u003e\n\u003cp\u003e실제로 이게 어떻게 작동하는지에 대해 조금 후에 알아보겠습니다. 지금은 src/mycache.js 파일(또는 원하는 곳)에 해당 C 구현을 저장해야 합니다. 그런 다음 어플리케이션을 실행하면, 바로! 버튼을 누르면 Header가 다시 렌더링되지 않습니다. 성공!\u003c/p\u003e\n\u003ch1\u003e약간 다른 구현\u003c/h1\u003e\n\u003cp\u003e다른 옵션은 사실상 패키지 관리자를 속여 ./src/mycache가 실제로 react-compiler-runtime 라이브러리라고 생각하게 하는 것입니다. 그래서 package.json 의 종속성에 이 부분을 추가할 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"dependencies\"\u003c/span\u003e: { ..., \u003cspan class=\"hljs-string\"\u003e\"react-compiler-runtime\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"file:./src/mycache\"\u003c/span\u003e }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러고 나면 Vite 구성에서 ReactCompilerConfig 블록에서 runtimeModule 키를 제거할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이것은 공식 폴리필이며 가장 최신 버전은 이 기스트에 있습니다.\u003c/p\u003e\n\u003ch1\u003e그래서 왜 이 C 구현이 작동합니까?\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 모든 것이 원활히 진행되었으니 이 C 구현을 한 번 더 살펴보고 왜 동작하는지 알아보려고 해봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ec\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esize\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e(size))[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 상태를 생성하고 그 상태를 반환하고 있습니다. 상태 설정 함수를 반환하지 않고 상태만 반환하고 있으니, 뭔가 이상하죠?\u003c/p\u003e\n\u003cp\u003e이 컴포넌트를 컴파일해보죠:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHello\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e\u003e\u003c/span\u003e안녕하세요\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 코드가 아래와 같이 변합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {c \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _c} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"/src/mycache.js\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHello\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e $ = \u003cspan class=\"hljs-title function_\"\u003e_c\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ($[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] !== \u003cspan class=\"hljs-string\"\u003e\"a49bfc30998b8cb2...\"\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e $i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; $i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e; $i += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n            $[$i] = \u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"react.memo_cache_sentinel\"\u003c/span\u003e);\n        }\n        $[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-string\"\u003e\"a49bfc30998b8cb2...\"\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e t0;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ($[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] === \u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"react.memo_cache_sentinel\"\u003c/span\u003e)) {\n        t0 = \u003cspan class=\"hljs-title function_\"\u003ejsxDEV\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, {\n            \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"안녕하세요\"\u003c/span\u003e\n        }, \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, {\n        }, \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e);\n        $[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = t0;\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        t0 = $[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e t0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e컴파일된 코드의 상단에서 c 훅을 불러오고 최적화된 컴포넌트에서 사용한다는 것을 확인할 수 있습니다. 컴파일러는 초기화된 플래그를 저장하는 데 첫 번째 슬롯, 두 번째 슬롯에는 DOM 트리가 포함된 JSX의 메모이즈된 버전을 저장할 때 두 개의 슬롯만 필요하다는 사실을 알고 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e지금 c 훅이 어떻게 사용되는지 알았으니, 왜 우리의 구현이 작동하는지에 대해 조금 더 이해할 수 있게 되었습니다.\u003c/p\u003e\n\u003cp\u003e첫째, 우리는 메모이징을 하고 있고, 메모이징을 통해 컴포넌트를 다시 렌더링하게 만들 필요가 없습니다. 그래서 우리는 상태 설정 함수를 호출하지 않는 것입니다. 왜냐하면 그렇게 하면 다시 렌더링이 강제되기 때문입니다.\u003c/p\u003e\n\u003cp\u003e둘째, 우리는 useState로부터 배열에 대한 참조를 받기 때문에 (그리고 즉, 우리는 배열 내의 데이터를 단순히 배열 요소를 설정함으로써 변경할 수 있습니다) 데이터를 변경할 수 있고, 그 변경 사항은 유지될 것입니다. 왜냐하면 useState는 배열의 내용이 아니라 배열에 대한 참조를 유지하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e그 두 번째 부분이 여러분을 헷갈리게 한다면, JavaScript 메모리 관리와 참조가 배열 및 객체와 관련하여 작동하는 방식에 대한 이 비디오를 추천합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e공식 Polyfill\u003c/h1\u003e\n\u003cp\u003e만약 이를 실제로 적용하고 싶다면 c 함수의 원본 소스를 확인해보세요. 그리고 작업 그룹 기사도 살펴보세요. 이 지침 외에도 공식 Polyfill을 따를 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e더 깊게 들어가보기\u003c/h1\u003e\n\u003cp\u003e만약 React 컴파일러와 메모이제이션 작업 방식에 대해 더 자세히 알고 싶다면 제 React 컴파일러 영상을 꼭 시청해보세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 비디오는 메모이제이션의 메커니즘을 심도 있게 다루어서 React 컴포넌트 코드가 어떻게 변환되고 메모이징되며, 그 메모이제이션의 정밀도를 정말로 이해할 수 있도록 도와줍니다.\u003c/p\u003e\n\u003ch2\u003e가능하지만 권장되지 않는 방법\u003c/h2\u003e\n\u003cp\u003e무언가를 할 수 있다고 해서 반드시 해야 한다는 것은 아닙니다. 이 경우에도 그렇게 적용됩니다. React 컴파일러는 실제로 React 19 생태계 내에서 작동하도록 설계되었습니다. 그러므로 오늘 18 버전에서 사용할 수 있다고 해도, 내일 그것이 작동한다는 보장은 없습니다. 간단히 말해서, 사용 시 주의가 필요합니다. 레드 옥토버를 찾아서에서 말하는 대로 \"가능하지만 권장되지 않습니다.\"\u003c/p\u003e\n\u003ch2\u003e더욱 심화된 주제\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 당신이 이러한 고급 React 주제에 관심이 있다면, 특히 NextJS에 대해, 제 ProNextJS 뉴스레터에 가입해보세요. 그것을 통해 NextJS 상태 관리와 폼 관리에 대한 두 가지 무료 자습서에 액세스 할 수 있습니다. 그리고 ProNextJS 전체 코스가 출시될 때 알림을 받을 수도 있어요! 곧 공개될 예정이에요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-ReactCompilerWithReact18"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>