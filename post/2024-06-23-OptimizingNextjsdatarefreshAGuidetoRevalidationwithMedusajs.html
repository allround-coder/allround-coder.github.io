<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs" data-gatsby-head="true"/><meta name="twitter:title" content="Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 13:45" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png" alt="OptimizingNext.jsdatarefreshAGuidetoRevalidationwithMedusajs_0"></p>
<p>안녕하세요! 내부 서버를 사용하여 Next.js 애플리케이션에서 다시 유효성을 설정하는 가이드에 오신 것을 환영합니다. 이 자습서에서는 다양한 다시 유효성 유형을 탐색하고 그들의 보안을 향상하는 방법을 살펴볼 것입니다.</p>
<h1>왜 다시 유효성 검사가 중요한가요?</h1>
<p>다시 유효성 검사는 매 요청마다 소스에서 데이터를 가져오는 것을 피하고 웹 응용 프로그램의 성능을 향상시키기 위해 중요합니다. 기본적으로 Next.js는 fetch를 사용하여 요청을 캐시하며, POST 요청도 포함됩니다. 다시 유효성 검사를 하지 않거나 데이터 캐시를 선택적으로 사용하지 않는 경우, 애플리케이션이 사실상 정적으로 변할 것입니다.</p>
<div class="content-ad"></div>
<h3>재확인의 두 가지 유형:</h3>
<ul>
<li>시간 기반 재확인</li>
<li>요청에 따른 재확인</li>
</ul>
<h3>1. 시간 기반 재확인</h3>
<p>시간 기반 재확인은 Next.js 애플리케이션의 데이터에 대한 캐시 유효 기간을 설정하는 간단한 방법입니다. 밀리초(millisecond)로 간격을 지정함으로써 데이터가 캐시에서 유효한 기간을 정의할 수 있습니다. 다음은 이를 구현하는 방법입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://example.pl/api/products'</span>, { <span class="hljs-attr">next</span>: { <span class="hljs-attr">revalidate</span>: <span class="hljs-number">3600</span> } })
</code></pre>
<p>이 예제에서 revalidate 옵션이 3600초(1시간)로 설정되어 있습니다. 이는 지정된 API 엔드포인트에서 가져온 데이터가 최대 1시간 동안 신선하다고 간주됨을 의미합니다. 이 기간이 지나면 데이터를 새로 고칠 요청이 이루어집니다.</p>
<p>대안으로 페이지나 구성 요소 파일 자체에서 revalidate 속성을 사용할 수도 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// app/products/page.tsx</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> revalidate = <span class="hljs-number">3600</span> <span class="hljs-comment">// 최대 1시간마다 재검증</span>
</code></pre>
<div class="content-ad"></div>
<p>이 접근 방식은 캐시를 주기적으로 업데이트하고 애플리케이션이 지속적인 요청으로 서버를 과부하시키지 않고 최신 데이터를 제공하는 데 특히 유용합니다.</p>
<h2>2. 요청에 의한 재유효화</h2>
<p>요청에 의한 재유효화는 필요할 때만 데이터를 새로 고쳐야 하는 유연성을 제공하며, 이를 캐시 태그나 서버 액션 또는 라우트 핸들러 내에서 특정 경로를 사용하여 달성할 수 있습니다. 아래는 설정 방법입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(
    <span class="hljs-string">'https://example.pl/api/products'</span>, 
    { <span class="hljs-attr">next</span>: { <span class="hljs-attr">tags</span>: [<span class="hljs-string">'products'</span>] } } <span class="hljs-comment">// 이 부분이 마법이 일어나는 곳입니다</span>
  ) 
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>()

  <span class="hljs-keyword">return</span> (
  ...
}
</code></pre>
<div class="content-ad"></div>
<p>위의 코드를 한국어로 번역하면 다음과 같습니다.</p>
<p>Next.js에서 라우트 핸들러를 만들어보겠습니다</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// app/api/revalidate/[tag]/route.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params">
  request: NextRequest,
  { params }: { params: { tag: string } }
</span>) {
  <span class="hljs-keyword">const</span> tag = params.<span class="hljs-property">tag</span>

  <span class="hljs-title function_">revalidateTag</span>(tag);

  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">revalidated</span>: tag });
}
</code></pre>
<p>이 라우트에 접근할 때 URL <a href="http://localhost:3000/api/revalidate/products%EB%A5%BC" rel="nofollow" target="_blank">http://localhost:3000/api/revalidate/products를</a> 사용하면 캐시를 삭제하고 최신 데이터로 다시 가져옵니다.</p>
<p>내부 서버에서 다시 유효성을 검증하는 방법</p>
<div class="content-ad"></div>
<p>우리의 라우트 핸들러를 개선하여 쿼리 매개변수에 비밀 키를 포함시키는 것이 좋겠어요. 이렇게 하면 권한이 있는 사용자만 재확인 프로세스를 수동으로 트리거할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// app/api/revalidate/[tag]/route.ts</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">POST</span>(<span class="hljs-params">
  request: NextRequest,
  { params }: { params: { tag: string } }
</span>) {
  <span class="hljs-keyword">const</span> tag = params.<span class="hljs-property">tag</span>
  <span class="hljs-comment">// 검색 매개변수에서 비밀 키 가져오기</span>
  <span class="hljs-keyword">const</span> secret = request.<span class="hljs-property">nextUrl</span>.<span class="hljs-property">searchParams</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'secret'</span>);

  <span class="hljs-comment">// 비밀 키 확인</span>
  <span class="hljs-keyword">if</span> (secret !== process.<span class="hljs-property">env</span>.<span class="hljs-property">REVALIDATE_SECRET</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">error</span>: <span class="hljs-string">'Unauthorized'</span> }, { <span class="hljs-attr">status</span>: <span class="hljs-number">401</span> })
  }

  <span class="hljs-title function_">revalidateTag</span>(tag);

  <span class="hljs-keyword">return</span> <span class="hljs-title class_">NextResponse</span>.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">revalidated</span>: tag });
}
</code></pre>
<p>환경 변수에 REVALIDATE_SECRET도 추가해주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// .env</span>
<span class="hljs-variable constant_">REVALIDATE_SECRET</span>=supersecret_revalidate_key
</code></pre>
<div class="content-ad"></div>
<p>이제 Medusa.js를 사용하고 있다고 가정하고 서버로 이동하여 각 제품 업데이트마다 구독자를 구현해 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/subscribers/product.ts</span>
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductSubscriber</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">{ eventBusService }</span>) {
    eventBusService.<span class="hljs-title function_">subscribe</span>(
      <span class="hljs-string">"product.created"</span>,
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">revalidateOnDemand</span>
    );
    eventBusService.<span class="hljs-title function_">subscribe</span>(
      <span class="hljs-string">"product.updated"</span>,
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">revalidateOnDemand</span>
    );
    eventBusService.<span class="hljs-title function_">subscribe</span>(
      <span class="hljs-string">"product.deleted"</span>,
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">revalidateOnDemand</span>
    );
  }

  revalidateOnDemand = <span class="hljs-keyword">async</span> () => {
    <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">post</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">FRONTEND_REVALIDATE_URL</span>/products, {
      <span class="hljs-attr">params</span>: {
        <span class="hljs-attr">secret</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">FRONTEND_REVALIDATE_SECRET</span>
      },
    });
  };
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ProductSubscriber</span>;
</code></pre>
<p><code>.env</code> 파일에 다음 변수들을 포함시키세요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// .env</span>
<span class="hljs-variable constant_">REVALIDATE_SECRET</span>=supersecret_revalidate_key
<span class="hljs-variable constant_">FRONTEND_REVALIDATE_URL</span>=<span class="hljs-attr">http</span>:<span class="hljs-comment">//localhost.3000/api/revalidate</span>
</code></pre>
<div class="content-ad"></div>
<h1>마무리</h1>
<p>이러한 전략을 활용하여 성능 최적화와 데이터 신선도 사이의 균형을 유지할 수 있습니다. URL 매개변수에 비밀 키를 추가하여 권한이 있는 사용자만 수동 재확인을 트리거할 수 있도록하는 것은 귀하의 애플리케이션의 보안을 강화합니다.</p>
<p>본 문서가 도움이 되었기를 바랍니다.</p>
<p>읽어 주셔서 감사합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nextjs 데이터 새로 고침 최적화 Medusajs로 리밸리데이션하는 방법 안내","description":"","date":"2024-06-23 13:45","slug":"2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs","content":"\n\n![OptimizingNext.jsdatarefreshAGuidetoRevalidationwithMedusajs_0](/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png)\n\n안녕하세요! 내부 서버를 사용하여 Next.js 애플리케이션에서 다시 유효성을 설정하는 가이드에 오신 것을 환영합니다. 이 자습서에서는 다양한 다시 유효성 유형을 탐색하고 그들의 보안을 향상하는 방법을 살펴볼 것입니다.\n\n# 왜 다시 유효성 검사가 중요한가요?\n\n다시 유효성 검사는 매 요청마다 소스에서 데이터를 가져오는 것을 피하고 웹 응용 프로그램의 성능을 향상시키기 위해 중요합니다. 기본적으로 Next.js는 fetch를 사용하여 요청을 캐시하며, POST 요청도 포함됩니다. 다시 유효성 검사를 하지 않거나 데이터 캐시를 선택적으로 사용하지 않는 경우, 애플리케이션이 사실상 정적으로 변할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 재확인의 두 가지 유형:\n\n- 시간 기반 재확인\n- 요청에 따른 재확인\n\n### 1. 시간 기반 재확인\n\n시간 기반 재확인은 Next.js 애플리케이션의 데이터에 대한 캐시 유효 기간을 설정하는 간단한 방법입니다. 밀리초(millisecond)로 간격을 지정함으로써 데이터가 캐시에서 유효한 기간을 정의할 수 있습니다. 다음은 이를 구현하는 방법입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfetch('https://example.pl/api/products', { next: { revalidate: 3600 } })\n```\n\n이 예제에서 revalidate 옵션이 3600초(1시간)로 설정되어 있습니다. 이는 지정된 API 엔드포인트에서 가져온 데이터가 최대 1시간 동안 신선하다고 간주됨을 의미합니다. 이 기간이 지나면 데이터를 새로 고칠 요청이 이루어집니다.\n\n대안으로 페이지나 구성 요소 파일 자체에서 revalidate 속성을 사용할 수도 있습니다:\n\n```js\n// app/products/page.tsx\n\nexport const revalidate = 3600 // 최대 1시간마다 재검증\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 접근 방식은 캐시를 주기적으로 업데이트하고 애플리케이션이 지속적인 요청으로 서버를 과부하시키지 않고 최신 데이터를 제공하는 데 특히 유용합니다.\n\n## 2. 요청에 의한 재유효화\n\n요청에 의한 재유효화는 필요할 때만 데이터를 새로 고쳐야 하는 유연성을 제공하며, 이를 캐시 태그나 서버 액션 또는 라우트 핸들러 내에서 특정 경로를 사용하여 달성할 수 있습니다. 아래는 설정 방법입니다:\n\n```js\nexport default async function Page() {\n  const res = await fetch(\n    'https://example.pl/api/products', \n    { next: { tags: ['products'] } } // 이 부분이 마법이 일어나는 곳입니다\n  ) \n  const data = await res.json()\n\n  return (\n  ...\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드를 한국어로 번역하면 다음과 같습니다.\n\nNext.js에서 라우트 핸들러를 만들어보겠습니다\n\n```js\n// app/api/revalidate/[tag]/route.ts\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: { tag: string } }\n) {\n  const tag = params.tag\n\n  revalidateTag(tag);\n\n  return NextResponse.json({ revalidated: tag });\n}\n```\n\n이 라우트에 접근할 때 URL http://localhost:3000/api/revalidate/products를 사용하면 캐시를 삭제하고 최신 데이터로 다시 가져옵니다.\n\n내부 서버에서 다시 유효성을 검증하는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 라우트 핸들러를 개선하여 쿼리 매개변수에 비밀 키를 포함시키는 것이 좋겠어요. 이렇게 하면 권한이 있는 사용자만 재확인 프로세스를 수동으로 트리거할 수 있습니다.\n\n```js\n// app/api/revalidate/[tag]/route.ts\n\nexport async function POST(\n  request: NextRequest,\n  { params }: { params: { tag: string } }\n) {\n  const tag = params.tag\n  // 검색 매개변수에서 비밀 키 가져오기\n  const secret = request.nextUrl.searchParams.get('secret');\n\n  // 비밀 키 확인\n  if (secret !== process.env.REVALIDATE_SECRET) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n  }\n\n  revalidateTag(tag);\n\n  return NextResponse.json({ revalidated: tag });\n}\n```\n\n환경 변수에 REVALIDATE_SECRET도 추가해주세요:\n\n```js\n// .env\nREVALIDATE_SECRET=supersecret_revalidate_key\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Medusa.js를 사용하고 있다고 가정하고 서버로 이동하여 각 제품 업데이트마다 구독자를 구현해 봅시다.\n\n```js\n// src/subscribers/product.ts\nimport axios from \"axios\";\n\nclass ProductSubscriber {\n  constructor({ eventBusService }) {\n    eventBusService.subscribe(\n      \"product.created\",\n      this.revalidateOnDemand\n    );\n    eventBusService.subscribe(\n      \"product.updated\",\n      this.revalidateOnDemand\n    );\n    eventBusService.subscribe(\n      \"product.deleted\",\n      this.revalidateOnDemand\n    );\n  }\n\n  revalidateOnDemand = async () =\u003e {\n    await axios.post(process.env.FRONTEND_REVALIDATE_URL/products, {\n      params: {\n        secret: process.env.FRONTEND_REVALIDATE_SECRET\n      },\n    });\n  };\n}\n\nexport default ProductSubscriber;\n```\n\n`.env` 파일에 다음 변수들을 포함시키세요.\n\n```js\n// .env\nREVALIDATE_SECRET=supersecret_revalidate_key\nFRONTEND_REVALIDATE_URL=http://localhost.3000/api/revalidate\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마무리\n\n이러한 전략을 활용하여 성능 최적화와 데이터 신선도 사이의 균형을 유지할 수 있습니다. URL 매개변수에 비밀 키를 추가하여 권한이 있는 사용자만 수동 재확인을 트리거할 수 있도록하는 것은 귀하의 애플리케이션의 보안을 강화합니다.\n\n본 문서가 도움이 되었기를 바랍니다.\n\n읽어 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png"},"coverImage":"/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs_0.png\" alt=\"OptimizingNext.jsdatarefreshAGuidetoRevalidationwithMedusajs_0\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요! 내부 서버를 사용하여 Next.js 애플리케이션에서 다시 유효성을 설정하는 가이드에 오신 것을 환영합니다. 이 자습서에서는 다양한 다시 유효성 유형을 탐색하고 그들의 보안을 향상하는 방법을 살펴볼 것입니다.\u003c/p\u003e\n\u003ch1\u003e왜 다시 유효성 검사가 중요한가요?\u003c/h1\u003e\n\u003cp\u003e다시 유효성 검사는 매 요청마다 소스에서 데이터를 가져오는 것을 피하고 웹 응용 프로그램의 성능을 향상시키기 위해 중요합니다. 기본적으로 Next.js는 fetch를 사용하여 요청을 캐시하며, POST 요청도 포함됩니다. 다시 유효성 검사를 하지 않거나 데이터 캐시를 선택적으로 사용하지 않는 경우, 애플리케이션이 사실상 정적으로 변할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch3\u003e재확인의 두 가지 유형:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e시간 기반 재확인\u003c/li\u003e\n\u003cli\u003e요청에 따른 재확인\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e1. 시간 기반 재확인\u003c/h3\u003e\n\u003cp\u003e시간 기반 재확인은 Next.js 애플리케이션의 데이터에 대한 캐시 유효 기간을 설정하는 간단한 방법입니다. 밀리초(millisecond)로 간격을 지정함으로써 데이터가 캐시에서 유효한 기간을 정의할 수 있습니다. 다음은 이를 구현하는 방법입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://example.pl/api/products'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003erevalidate\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3600\u003c/span\u003e } })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서 revalidate 옵션이 3600초(1시간)로 설정되어 있습니다. 이는 지정된 API 엔드포인트에서 가져온 데이터가 최대 1시간 동안 신선하다고 간주됨을 의미합니다. 이 기간이 지나면 데이터를 새로 고칠 요청이 이루어집니다.\u003c/p\u003e\n\u003cp\u003e대안으로 페이지나 구성 요소 파일 자체에서 revalidate 속성을 사용할 수도 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// app/products/page.tsx\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e revalidate = \u003cspan class=\"hljs-number\"\u003e3600\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 최대 1시간마다 재검증\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 접근 방식은 캐시를 주기적으로 업데이트하고 애플리케이션이 지속적인 요청으로 서버를 과부하시키지 않고 최신 데이터를 제공하는 데 특히 유용합니다.\u003c/p\u003e\n\u003ch2\u003e2. 요청에 의한 재유효화\u003c/h2\u003e\n\u003cp\u003e요청에 의한 재유효화는 필요할 때만 데이터를 새로 고쳐야 하는 유연성을 제공하며, 이를 캐시 태그나 서버 액션 또는 라우트 핸들러 내에서 특정 경로를 사용하여 달성할 수 있습니다. 아래는 설정 방법입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePage\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\n    \u003cspan class=\"hljs-string\"\u003e'https://example.pl/api/products'\u003c/span\u003e, \n    { \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003etags\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'products'\u003c/span\u003e] } } \u003cspan class=\"hljs-comment\"\u003e// 이 부분이 마법이 일어나는 곳입니다\u003c/span\u003e\n  ) \n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e()\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 코드를 한국어로 번역하면 다음과 같습니다.\u003c/p\u003e\n\u003cp\u003eNext.js에서 라우트 핸들러를 만들어보겠습니다\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// app/api/revalidate/[tag]/route.ts\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePOST\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  request: NextRequest,\n  { params }: { params: { tag: string } }\n\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tag = params.\u003cspan class=\"hljs-property\"\u003etag\u003c/span\u003e\n\n  \u003cspan class=\"hljs-title function_\"\u003erevalidateTag\u003c/span\u003e(tag);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003erevalidated\u003c/span\u003e: tag });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 라우트에 접근할 때 URL \u003ca href=\"http://localhost:3000/api/revalidate/products%EB%A5%BC\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:3000/api/revalidate/products를\u003c/a\u003e 사용하면 캐시를 삭제하고 최신 데이터로 다시 가져옵니다.\u003c/p\u003e\n\u003cp\u003e내부 서버에서 다시 유효성을 검증하는 방법\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리의 라우트 핸들러를 개선하여 쿼리 매개변수에 비밀 키를 포함시키는 것이 좋겠어요. 이렇게 하면 권한이 있는 사용자만 재확인 프로세스를 수동으로 트리거할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// app/api/revalidate/[tag]/route.ts\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePOST\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  request: NextRequest,\n  { params }: { params: { tag: string } }\n\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tag = params.\u003cspan class=\"hljs-property\"\u003etag\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 검색 매개변수에서 비밀 키 가져오기\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e secret = request.\u003cspan class=\"hljs-property\"\u003enextUrl\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esearchParams\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'secret'\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 비밀 키 확인\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (secret !== process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eREVALIDATE_SECRET\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Unauthorized'\u003c/span\u003e }, { \u003cspan class=\"hljs-attr\"\u003estatus\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e401\u003c/span\u003e })\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003erevalidateTag\u003c/span\u003e(tag);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNextResponse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003erevalidated\u003c/span\u003e: tag });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e환경 변수에 REVALIDATE_SECRET도 추가해주세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// .env\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eREVALIDATE_SECRET\u003c/span\u003e=supersecret_revalidate_key\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 Medusa.js를 사용하고 있다고 가정하고 서버로 이동하여 각 제품 업데이트마다 구독자를 구현해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/subscribers/product.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e axios \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"axios\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProductSubscriber\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ eventBusService }\u003c/span\u003e) {\n    eventBusService.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n      \u003cspan class=\"hljs-string\"\u003e\"product.created\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erevalidateOnDemand\u003c/span\u003e\n    );\n    eventBusService.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n      \u003cspan class=\"hljs-string\"\u003e\"product.updated\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erevalidateOnDemand\u003c/span\u003e\n    );\n    eventBusService.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n      \u003cspan class=\"hljs-string\"\u003e\"product.deleted\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erevalidateOnDemand\u003c/span\u003e\n    );\n  }\n\n  revalidateOnDemand = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e axios.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFRONTEND_REVALIDATE_URL\u003c/span\u003e/products, {\n      \u003cspan class=\"hljs-attr\"\u003eparams\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003esecret\u003c/span\u003e: process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFRONTEND_REVALIDATE_SECRET\u003c/span\u003e\n      },\n    });\n  };\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProductSubscriber\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e.env\u003c/code\u003e 파일에 다음 변수들을 포함시키세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// .env\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eREVALIDATE_SECRET\u003c/span\u003e=supersecret_revalidate_key\n\u003cspan class=\"hljs-variable constant_\"\u003eFRONTEND_REVALIDATE_URL\u003c/span\u003e=\u003cspan class=\"hljs-attr\"\u003ehttp\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//localhost.3000/api/revalidate\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e마무리\u003c/h1\u003e\n\u003cp\u003e이러한 전략을 활용하여 성능 최적화와 데이터 신선도 사이의 균형을 유지할 수 있습니다. URL 매개변수에 비밀 키를 추가하여 권한이 있는 사용자만 수동 재확인을 트리거할 수 있도록하는 것은 귀하의 애플리케이션의 보안을 강화합니다.\u003c/p\u003e\n\u003cp\u003e본 문서가 도움이 되었기를 바랍니다.\u003c/p\u003e\n\u003cp\u003e읽어 주셔서 감사합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-OptimizingNextjsdatarefreshAGuidetoRevalidationwithMedusajs"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>