<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트 GraphQL 대 REST API 포괄적 가이드 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트 GraphQL 대 REST API 포괄적 가이드 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트 GraphQL 대 REST API 포괄적 가이드 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide" data-gatsby-head="true"/><meta name="twitter:title" content="리액트 GraphQL 대 REST API 포괄적 가이드 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 12:50" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_buildManifest.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트 GraphQL 대 REST API 포괄적 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트 GraphQL 대 REST API 포괄적 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png" alt="그래픽"/></p>
<p>GraphQL 또는 REST API를 React 기반 애플리케이션에 사용할지 결정하는 것은 매우 중요합니다. 이 결정은 앱의 성능, 확장 가능성, 데이터 처리 효율성 및 개발 수명주기에 도입되는 복잡성 수준에 심각한 영향을 미칩니다. 이 포괄적인 가이드는 두 가지의 차이점을 명확히하고 정보를 얻을 수 있는 선택을 도와줄 것으로 기대됩니다!</p>
<h1>REST API란 무엇인가요?</h1>
<p>REST (Representational State Transfer)는 웹 개발에 사용되는 아키텍처 스타일로, 클라이언트-서버 접근 방식을 사용합니다. 서버는 클라이언트가 요청한 리소스의 표현을 제공합니다. 리소스는 URL로 식별되며 이러한 리소스는 POST, GET, PUT, DELETE와 같은 HTTP 방식으로 표시되는 CRUD 작업을 사용하여 조작할 수 있습니다. 최근 몇 년간 REST API의 활용이 많이 증가했습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// REST API를 사용하여 데이터 가져오기</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.example.com/items&quot;</span>) 
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));
</code></pre>
<p>위 예시에서는 REST API 엔드포인트 /items에 대한 호출이 해당 항목들을 JSON 형식으로 반환합니다.</p>
<h1>GraphQL이란?</h1>
<p>2015년 Facebook에서 개발된 GraphQL은 REST API에 대안으로 효율적이고 선언적이며 유연한 데이터 쿼리 언어입니다. 이를 통해 클라이언트는 서버에서 어떤 데이터가 필요한지 정확히 지정하고 원하는 방식으로 가져올 수 있어, REST API와 관련된 오버-패칭 또는 언더-패칭 문제를 제거합니다.```</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// GraphQL을 사용하여 데이터를 가져옵니다</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/graphql&#x27;</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>
  },
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
    <span class="hljs-attr">query</span>: <span class="hljs-string">`{ 
      items { 
        id, 
        name 
      } 
    }`</span>
  })
})
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">data</span>));
</code></pre>
<p>위의 예제에서 요청의 query 속성은 GraphQL 서버에서 각 항목의 id와 이름을 가져옵니다.</p>
<h1>GraphQL과 REST API의 차이</h1>
<h2>1. 데이터 가져오기</h2>
<p>REST API</p>
<p>REST 기반 아키텍처에서는 귀하의 앱이 관련 데이터를 가져 오기 위해 다양한 엔드포인트로 여러 요청을 해야합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.example.com/users/1&quot;</span>) <span class="hljs-comment">// ID가 1인 사용자 가져 오기</span>
.<span class="hljs-title function_">then</span>(<span class="hljs-comment">/* */</span>)

<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;https://api.example.com/users/1/posts&quot;</span>) <span class="hljs-comment">// ID가 1인 사용자의 게시물 가져 오기</span>
.<span class="hljs-title function_">then</span>(<span class="hljs-comment">/* */</span>)
</code></pre>
<p>위의 예시처럼 특정 사용자가 만든 데이터(게시물)를 가져 오는 것은 REST API에서 여러 네트워크 요청이 필요합니다.</p>
<p>GraphQL</p>
<p>GraphQL을 사용하면 관련 데이터를 하나의 요청으로 모아 가져올 수 있으며, 정확히 필요한 데이터만 가져와서 과다 또는 미비한 데이터 문제를 줄일 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/graphql&#x27;</span>, {
  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>
  },
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
    <span class="hljs-attr">query</span>: <span class="hljs-string">`{
      user(id: 1) {
        name,
        posts {
          title,
          body
        }
      }
    }`</span>
  })
})
.<span class="hljs-title function_">then</span>(<span class="hljs-comment">/* */</span>)
</code></pre>
<p>위 코드는 한 요청으로 사용자와 해당 사용자의 게시물을 가져오는 거에요.</p>
<h2>2. Over-fetching and Under-fetching</h2>
<p>REST API</p>
<p>RESTful 서비스에서 응답의 모양과 크기는 서버에 의해 결정됩니다. 종종 endpoint가 충분한 정보를 제공하지 않아 추가 요청이 필요한 under-fetching이 발생하거나, 필요 이상의 정보가 전송되어 over-fetching이 발생할 수 있습니다.</p>
<p>GraphQL</p>
<p>GraphQL의 주요 이점 중 하나는 클라이언트가 필요한 데이터를 정확히 지정하여 over-fetching 또는 under-fetching을 피할 수 있다는 것입니다. 서버는 요청의 형태를 따르는 응답을 반환합니다.</p>
<h2>3. 버전 관리</h2>
<p>REST API</p>
<p>버전 관리는 REST 기반 서비스에서 일반적입니다. 이는 API를 발전시키는 것이 어려워 새로운 API 버전이 처리할 필요가 있는 파괴적인 변경을 피하기 위함입니다.</p>
<p>GraphQL</p>
<p>GraphQL을 사용하면 서버는 자신의 기능을 공개하고 클라이언트는 필요한 요청을 구성하며, 이로 인해 버전 관리가 필요 없어집니다.</p>
<h2>REST API와 GraphQL을 언제 사용해야 할까요?</h2>
<p>REST API를 사용해야 하는 경우:</p>
<ul>
<li>당신의 앱이 간단하거나 데이터 요구 사항이 복잡하지 않다면 REST API 설계에 더 익숙한 팀이 있다면 REST를 사용하세요.</li>
<li>데이터가 자주 변경되지 않고 중첩된 엔티티를 포함하지 않는다면 REST를 사용하세요.</li>
</ul>
<p>GraphQL을 사용해야 하는 경우:</p>
<ul>
<li>애플리케이션이 중첩된 엔티티를 포함하거나 그들 사이에 복잡한 관계가 있는 경우.</li>
<li>네트워크를 통해 로드되는 데이터를 줄이고 싶은 경우.</li>
<li>앱이 애플리케이션 부하 및 코드베이스 크기 측면에서 확장될 것으로 예상되는 경우.</li>
</ul>
<p>마지막으로, GraphQL과 REST 중 어느 것을 선택할지는 프로젝트 요구 사항, 팀의 기술 수준, 데이터의 성격 등 여러 가지 요인에 달려 있습니다. 두 가지 방식에는 각각의 장점이 있으며 상황에 따라 어느 쪽이든 완벽하게 어울릴 수 있습니다. 이러한 주요 차이를 이해하면 프로젝트 성공에 중요한 결정을 내릴 수 있게 될 것입니다.</p>
<h1>만약 즐거우셨다면 박수와 구독을 잊지 마세요! 👏</h1>
<p>열정적인 건축가들의 디스코드 커뮤니티에 가입해보세요: <a href="https://discord.gg/QyXEsb4C">https://discord.gg/QyXEsb4C</a></p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트 GraphQL 대 REST API 포괄적 가이드","description":"","date":"2024-05-14 12:50","slug":"2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide","content":"\n\n\n![그래픽](/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png)\n\nGraphQL 또는 REST API를 React 기반 애플리케이션에 사용할지 결정하는 것은 매우 중요합니다. 이 결정은 앱의 성능, 확장 가능성, 데이터 처리 효율성 및 개발 수명주기에 도입되는 복잡성 수준에 심각한 영향을 미칩니다. 이 포괄적인 가이드는 두 가지의 차이점을 명확히하고 정보를 얻을 수 있는 선택을 도와줄 것으로 기대됩니다!\n\n# REST API란 무엇인가요?\n\nREST (Representational State Transfer)는 웹 개발에 사용되는 아키텍처 스타일로, 클라이언트-서버 접근 방식을 사용합니다. 서버는 클라이언트가 요청한 리소스의 표현을 제공합니다. 리소스는 URL로 식별되며 이러한 리소스는 POST, GET, PUT, DELETE와 같은 HTTP 방식으로 표시되는 CRUD 작업을 사용하여 조작할 수 있습니다. 최근 몇 년간 REST API의 활용이 많이 증가했습니다.\n\n\n\n\n```js\n// REST API를 사용하여 데이터 가져오기\nfetch(\"https://api.example.com/items\") \n  .then(res =\u003e res.json())\n  .then(data =\u003e console.log(data));\n```\n\n위 예시에서는 REST API 엔드포인트 /items에 대한 호출이 해당 항목들을 JSON 형식으로 반환합니다.\n\n# GraphQL이란?\n\n2015년 Facebook에서 개발된 GraphQL은 REST API에 대안으로 효율적이고 선언적이며 유연한 데이터 쿼리 언어입니다. 이를 통해 클라이언트는 서버에서 어떤 데이터가 필요한지 정확히 지정하고 원하는 방식으로 가져올 수 있어, REST API와 관련된 오버-패칭 또는 언더-패칭 문제를 제거합니다.```\n\n\n\n```js\n// GraphQL을 사용하여 데이터를 가져옵니다\nfetch('/graphql', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    query: `{ \n      items { \n        id, \n        name \n      } \n    }`\n  })\n})\n.then(res =\u003e res.json())\n.then(data =\u003e console.log(data.data));\n```\n\n위의 예제에서 요청의 query 속성은 GraphQL 서버에서 각 항목의 id와 이름을 가져옵니다.\n\n# GraphQL과 REST API의 차이\n\n## 1. 데이터 가져오기\n\n\n\nREST API\n\nREST 기반 아키텍처에서는 귀하의 앱이 관련 데이터를 가져 오기 위해 다양한 엔드포인트로 여러 요청을 해야합니다.\n\n```js\nfetch(\"https://api.example.com/users/1\") // ID가 1인 사용자 가져 오기\n.then(/* */)\n\nfetch(\"https://api.example.com/users/1/posts\") // ID가 1인 사용자의 게시물 가져 오기\n.then(/* */)\n```\n\n위의 예시처럼 특정 사용자가 만든 데이터(게시물)를 가져 오는 것은 REST API에서 여러 네트워크 요청이 필요합니다.\n\n\n\nGraphQL\n\nGraphQL을 사용하면 관련 데이터를 하나의 요청으로 모아 가져올 수 있으며, 정확히 필요한 데이터만 가져와서 과다 또는 미비한 데이터 문제를 줄일 수 있어요.\n\n```js\nfetch('/graphql', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    query: `{\n      user(id: 1) {\n        name,\n        posts {\n          title,\n          body\n        }\n      }\n    }`\n  })\n})\n.then(/* */)\n```\n\n위 코드는 한 요청으로 사용자와 해당 사용자의 게시물을 가져오는 거에요.\n\n\n\n## 2. Over-fetching and Under-fetching\n\nREST API\n\nRESTful 서비스에서 응답의 모양과 크기는 서버에 의해 결정됩니다. 종종 endpoint가 충분한 정보를 제공하지 않아 추가 요청이 필요한 under-fetching이 발생하거나, 필요 이상의 정보가 전송되어 over-fetching이 발생할 수 있습니다.\n\nGraphQL\n\n\n\nGraphQL의 주요 이점 중 하나는 클라이언트가 필요한 데이터를 정확히 지정하여 over-fetching 또는 under-fetching을 피할 수 있다는 것입니다. 서버는 요청의 형태를 따르는 응답을 반환합니다.\n\n## 3. 버전 관리\n\nREST API\n\n버전 관리는 REST 기반 서비스에서 일반적입니다. 이는 API를 발전시키는 것이 어려워 새로운 API 버전이 처리할 필요가 있는 파괴적인 변경을 피하기 위함입니다.\n\n\n\nGraphQL\n\nGraphQL을 사용하면 서버는 자신의 기능을 공개하고 클라이언트는 필요한 요청을 구성하며, 이로 인해 버전 관리가 필요 없어집니다.\n\n## REST API와 GraphQL을 언제 사용해야 할까요?\n\nREST API를 사용해야 하는 경우:\n\n\n\n- 당신의 앱이 간단하거나 데이터 요구 사항이 복잡하지 않다면 REST API 설계에 더 익숙한 팀이 있다면 REST를 사용하세요.\n- 데이터가 자주 변경되지 않고 중첩된 엔티티를 포함하지 않는다면 REST를 사용하세요.\n\nGraphQL을 사용해야 하는 경우:\n\n- 애플리케이션이 중첩된 엔티티를 포함하거나 그들 사이에 복잡한 관계가 있는 경우.\n- 네트워크를 통해 로드되는 데이터를 줄이고 싶은 경우.\n- 앱이 애플리케이션 부하 및 코드베이스 크기 측면에서 확장될 것으로 예상되는 경우.\n\n마지막으로, GraphQL과 REST 중 어느 것을 선택할지는 프로젝트 요구 사항, 팀의 기술 수준, 데이터의 성격 등 여러 가지 요인에 달려 있습니다. 두 가지 방식에는 각각의 장점이 있으며 상황에 따라 어느 쪽이든 완벽하게 어울릴 수 있습니다. 이러한 주요 차이를 이해하면 프로젝트 성공에 중요한 결정을 내릴 수 있게 될 것입니다.\n\n\n\n# 만약 즐거우셨다면 박수와 구독을 잊지 마세요! 👏\n\n열정적인 건축가들의 디스코드 커뮤니티에 가입해보세요: [https://discord.gg/QyXEsb4C](https://discord.gg/QyXEsb4C)","ogImage":{"url":"/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide_0.png\",\n        alt: \"그래픽\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GraphQL 또는 REST API를 React 기반 애플리케이션에 사용할지 결정하는 것은 매우 중요합니다. 이 결정은 앱의 성능, 확장 가능성, 데이터 처리 효율성 및 개발 수명주기에 도입되는 복잡성 수준에 심각한 영향을 미칩니다. 이 포괄적인 가이드는 두 가지의 차이점을 명확히하고 정보를 얻을 수 있는 선택을 도와줄 것으로 기대됩니다!\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"REST API란 무엇인가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"REST (Representational State Transfer)는 웹 개발에 사용되는 아키텍처 스타일로, 클라이언트-서버 접근 방식을 사용합니다. 서버는 클라이언트가 요청한 리소스의 표현을 제공합니다. 리소스는 URL로 식별되며 이러한 리소스는 POST, GET, PUT, DELETE와 같은 HTTP 방식으로 표시되는 CRUD 작업을 사용하여 조작할 수 있습니다. 최근 몇 년간 REST API의 활용이 많이 증가했습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// REST API를 사용하여 데이터 가져오기\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://api.example.com/items\\\"\"\n        }), \") \\n  .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"then\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"res\"\n          }), \" =\u003e\"]\n        }), \" res.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"json\"\n        }), \"())\\n  .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"then\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"data\"\n          }), \" =\u003e\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(data));\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 예시에서는 REST API 엔드포인트 /items에 대한 호출이 해당 항목들을 JSON 형식으로 반환합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"GraphQL이란?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"2015년 Facebook에서 개발된 GraphQL은 REST API에 대안으로 효율적이고 선언적이며 유연한 데이터 쿼리 언어입니다. 이를 통해 클라이언트는 서버에서 어떤 데이터가 필요한지 정확히 지정하고 원하는 방식으로 가져올 수 있어, REST API와 관련된 오버-패칭 또는 언더-패칭 문제를 제거합니다.```\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// GraphQL을 사용하여 데이터를 가져옵니다\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/graphql'\"\n        }), \", {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"method\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'POST'\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"headers\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Content-Type'\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'application/json'\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"body\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"JSON\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stringify\"\n        }), \"({\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"query\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"`{ \\n      items { \\n        id, \\n        name \\n      } \\n    }`\"\n        }), \"\\n  })\\n})\\n.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"then\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"res\"\n          }), \" =\u003e\"]\n        }), \" res.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"json\"\n        }), \"())\\n.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"then\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"data\"\n          }), \" =\u003e\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(data.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"data\"\n        }), \"));\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 예제에서 요청의 query 속성은 GraphQL 서버에서 각 항목의 id와 이름을 가져옵니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"GraphQL과 REST API의 차이\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. 데이터 가져오기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"REST API\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"REST 기반 아키텍처에서는 귀하의 앱이 관련 데이터를 가져 오기 위해 다양한 엔드포인트로 여러 요청을 해야합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://api.example.com/users/1\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ID가 1인 사용자 가져 오기\"\n        }), \"\\n.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"then\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/* */\"\n        }), \")\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://api.example.com/users/1/posts\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ID가 1인 사용자의 게시물 가져 오기\"\n        }), \"\\n.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"then\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/* */\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 예시처럼 특정 사용자가 만든 데이터(게시물)를 가져 오는 것은 REST API에서 여러 네트워크 요청이 필요합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GraphQL\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GraphQL을 사용하면 관련 데이터를 하나의 요청으로 모아 가져올 수 있으며, 정확히 필요한 데이터만 가져와서 과다 또는 미비한 데이터 문제를 줄일 수 있어요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/graphql'\"\n        }), \", {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"method\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'POST'\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"headers\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Content-Type'\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'application/json'\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"body\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"JSON\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stringify\"\n        }), \"({\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"query\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"`{\\n      user(id: 1) {\\n        name,\\n        posts {\\n          title,\\n          body\\n        }\\n      }\\n    }`\"\n        }), \"\\n  })\\n})\\n.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"then\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/* */\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 코드는 한 요청으로 사용자와 해당 사용자의 게시물을 가져오는 거에요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. Over-fetching and Under-fetching\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"REST API\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RESTful 서비스에서 응답의 모양과 크기는 서버에 의해 결정됩니다. 종종 endpoint가 충분한 정보를 제공하지 않아 추가 요청이 필요한 under-fetching이 발생하거나, 필요 이상의 정보가 전송되어 over-fetching이 발생할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GraphQL\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GraphQL의 주요 이점 중 하나는 클라이언트가 필요한 데이터를 정확히 지정하여 over-fetching 또는 under-fetching을 피할 수 있다는 것입니다. 서버는 요청의 형태를 따르는 응답을 반환합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. 버전 관리\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"REST API\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"버전 관리는 REST 기반 서비스에서 일반적입니다. 이는 API를 발전시키는 것이 어려워 새로운 API 버전이 처리할 필요가 있는 파괴적인 변경을 피하기 위함입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GraphQL\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GraphQL을 사용하면 서버는 자신의 기능을 공개하고 클라이언트는 필요한 요청을 구성하며, 이로 인해 버전 관리가 필요 없어집니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"REST API와 GraphQL을 언제 사용해야 할까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"REST API를 사용해야 하는 경우:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"당신의 앱이 간단하거나 데이터 요구 사항이 복잡하지 않다면 REST API 설계에 더 익숙한 팀이 있다면 REST를 사용하세요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"데이터가 자주 변경되지 않고 중첩된 엔티티를 포함하지 않는다면 REST를 사용하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GraphQL을 사용해야 하는 경우:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"애플리케이션이 중첩된 엔티티를 포함하거나 그들 사이에 복잡한 관계가 있는 경우.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"네트워크를 통해 로드되는 데이터를 줄이고 싶은 경우.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"앱이 애플리케이션 부하 및 코드베이스 크기 측면에서 확장될 것으로 예상되는 경우.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, GraphQL과 REST 중 어느 것을 선택할지는 프로젝트 요구 사항, 팀의 기술 수준, 데이터의 성격 등 여러 가지 요인에 달려 있습니다. 두 가지 방식에는 각각의 장점이 있으며 상황에 따라 어느 쪽이든 완벽하게 어울릴 수 있습니다. 이러한 주요 차이를 이해하면 프로젝트 성공에 중요한 결정을 내릴 수 있게 될 것입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"만약 즐거우셨다면 박수와 구독을 잊지 마세요! 👏\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"열정적인 건축가들의 디스코드 커뮤니티에 가입해보세요: \", _jsx(_components.a, {\n        href: \"https://discord.gg/QyXEsb4C\",\n        children: \"https://discord.gg/QyXEsb4C\"\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-ReactGraphQLvsRESTAPIComprehensiveGuide"},"buildId":"z1a6VTi5qHH9JJH7jaxL3","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>