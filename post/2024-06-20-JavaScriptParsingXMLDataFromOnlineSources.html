<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources" data-gatsby-head="true"/><meta name="twitter:title" content="자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 01:25" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png" alt="이미지"></p>
<p>웹에서 XML 데이터를 가져오고 추출하는 능력은 웹 개발자에게 중요한 기술입니다. XML은 구조화된 데이터를 교환하는 데 널리 사용되는 형식이며, 많은 온라인 서비스와 API가 이 형식으로 데이터를 제공합니다.</p>
<p>JavaScript로 XML 데이터를 가져오는 현대적인 방법 중 하나는 fetch() API를 사용하는 것입니다. fetch() 함수를 사용하면 이전의 XMLHttpRequest 객체보다 더 간결하고 promise 기반으로 HTTP 요청을 보내고 XML 내용을 검색할 수 있습니다.</p>
<p>fetch()를 사용하여 XML 데이터를 가져오면 JavaScript에서 DOMParser 객체와 같은 도구를 제공하여 XML을 DOM 구조로 구문 분석할 수 있으며, 이를 통해 필요한 정보를 추출할 수 있습니다.</p>
<h1>[1] JavaScript 프로젝트 생성하기</h1>
<p>Replit 플랫폼에서 만들어보세요</p>
<p><img src="/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_1.png" alt=""></p>
<h1>[2] HTML과 JavaScript 코드 편집하기</h1>
<p>파일 index.html:</p>
<pre><code class="hljs language-js">&#x3C;!<span class="hljs-variable constant_">DOCTYPE</span> html>
&#x3C;html>

&#x3C;head>
  &#x3C;meta charset="utf-8">
  &#x3C;meta name="viewport" content="width=device-width">
  &#x3C;title>replit&#x3C;/title>
  &#x3C;link href="style.css" rel="stylesheet" type="text/css" />
&#x3C;/head>

&#x3C;body>
  &#x3C;div id="divOutput">&#x3C;/div>
  &#x3C;script src="script.js">&#x3C;/script>
&#x3C;/body>

&#x3C;/html>
</code></pre>
<p>위 HTML 코드는 웹 페이지의 기본 구조를 설정합니다. 이는 문자 인코딩, 뷰포트, 제목을 지정하는 <code>head</code> 섹션과 "style.css"라는 외부 CSS 파일에 대한 링크를 포함하고 있습니다. 또한, 동적 콘텐츠를 담을 컨테이너로 사용될 ID가 "divOutput"인 <code>div</code> 요소와 페이지 로드 시 실행될 "script.js"라는 외부 JavaScript 파일을 포함하는 <code>script</code> 요소를 포함한 <code>body</code> 섹션을 포함합니다. <code>!DOCTYPE html</code> 선언은 웹 브라우저에게 이 문서가 HTML5 문서임을 알려주며, 전체 코드는 클라이언트 측 스크립팅 및 JavaScript 파일을 사용한 동적 콘텐츠 조작을 포함한 웹 페이지의 기초를 설정합니다.</p>
<p>파일 script.js:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> myUrl = <span class="hljs-string">'https://catalog.ldc.upenn.edu/desc/addenda/LDC2010T05.xml'</span>;
<span class="hljs-comment">// CORS 문제를 처리하기 위해 cors-anywhere 서비스를 사용함</span>
<span class="hljs-keyword">var</span> proxy = <span class="hljs-string">'https://cors-anywhere.herokuapp.com/'</span>;

<span class="hljs-comment">// 요청 실행</span>
<span class="hljs-title function_">fetch</span>(proxy + myUrl)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =></span> response.<span class="hljs-title function_">text</span>())
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">xmlString</span> =></span> <span class="hljs-title function_">parseXML</span>(xmlString))
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));

<span class="hljs-comment">// XML 데이터 파싱</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">parseXML</span>(<span class="hljs-params">xmlString</span>) {
  <span class="hljs-keyword">const</span> parser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DOMParser</span>();
  <span class="hljs-keyword">const</span> doc = parser.<span class="hljs-title function_">parseFromString</span>(xmlString, <span class="hljs-string">'application/xml'</span>);

  <span class="hljs-comment">// 요소에 액세스</span>
  <span class="hljs-keyword">const</span> posts = doc.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">'Post'</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; posts.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> post = posts[i];
    <span class="hljs-keyword">const</span> postClass = post.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'class'</span>);
    <span class="hljs-keyword">const</span> postUser = post.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'user'</span>);
    <span class="hljs-keyword">const</span> postText = post.<span class="hljs-property">textContent</span>.<span class="hljs-title function_">trim</span>();

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'게시물 클래스:'</span>, postClass);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'게시물 사용자:'</span>, postUser);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'게시물 텍스트:'</span>, postText);

    <span class="hljs-keyword">const</span> terminals = post.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">'t'</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &#x3C; terminals.<span class="hljs-property">length</span>; j++) {
      <span class="hljs-keyword">const</span> terminal = terminals[j];
      <span class="hljs-keyword">const</span> pos = terminal.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'pos'</span>);
      <span class="hljs-keyword">const</span> word = terminal.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'word'</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`POS: <span class="hljs-subst">${pos}</span>, 단어: <span class="hljs-subst">${word}</span>`</span>);
      <span class="hljs-keyword">const</span> divOutput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'divOutput'</span>);
      <span class="hljs-keyword">if</span> (divOutput) {
        divOutput.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">`POS: <span class="hljs-subst">${pos}</span>, 단어: <span class="hljs-subst">${word}</span>&#x3C;br>`</span>;
      }
    }
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>();
  }
}
</code></pre>
<p>제공된 코드는 "<a href="https://catalog.ldc.upenn.edu/desc/addenda/LDC2010T05.xml%22%EC%97%90" rel="nofollow" target="_blank">https://catalog.ldc.upenn.edu/desc/addenda/LDC2010T05.xml"에</a> 위치한 XML 문서를 가져와 내용을 파싱하는 JavaScript 솔루션을 보여줍니다. 이 데이터는 NPS Internet Chatroom Corpus의 일부입니다.</p>
<p>위의 JavaScript 코드는 fetch() API를 사용하여 HTTP 요청을 수행하고, 잠재적인 Cross-Origin Resource Sharing (CORS) 문제를 처리하기 위해 "<a href="https://cors-anywhere.herokuapp.com/%22%EC%9D%98" rel="nofollow" target="_blank">https://cors-anywhere.herokuapp.com/"의</a> 프록시 URL을 활용합니다. fetch 요청에서의 응답은 텍스트 형식으로 변환되며, XML 문자열이 가정적인 parseXML() 함수에 전달되어 추가 처리됩니다. 코드에는 또한 fetch나 파싱 작업 중 발생할 수 있는 문제를 기록하기 위한 오류 처리도 포함되어 있습니다.</p>
<p>parseXML() 함수는 이전 코드 스니펫에서 가져온 XML 데이터를 파싱하는 역할을 합니다. 먼저 DOMParser 객체의 새 인스턴스를 생성하고, parseFromString() 메서드를 사용하여 XML 문자열을 Document 객체로 파싱합니다. 함수는 이후 파싱된 문서에서 모든 'Post' 요소를 검색하고, 각각의 'class', 'user' 및 텍스트 내용을 추출하여 콘솔에 기록합니다. 다음으로, 함수는 각 'Post' 요소 내부의 모든 't' (터미널) 요소를 가져와, 'pos' (품사) 및 'word' 속성을 추출하고, 이 정보를 콘솔에 기록하고 동시에 'divOutput' ID를 가진 HTML 요소에 추가합니다. 이 과정을 통해 함수는 XML 데이터를 파싱하고 관련 정보를 추출하여 이를 콘솔과 웹 페이지에 표시할 수 있게 됩니다.</p>
<p>결과:</p>
<h1>[3] Replit Code:</h1>
<p>코드를 사용하지 않는 방법을 선호하는 경우:</p>
<ul>
<li><a href="https://jsonformatter.org/xml-parser" rel="nofollow" target="_blank">https://jsonformatter.org/xml-parser</a></li>
<li><a href="https://codebeautify.org/xml-parser-online" rel="nofollow" target="_blank">https://codebeautify.org/xml-parser-online</a></li>
</ul>
<h1>🤓</h1>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"자바스크립트 - 온라인 소스로부터 XML 데이터 구문 분석하기","description":"","date":"2024-06-20 01:25","slug":"2024-06-20-JavaScriptParsingXMLDataFromOnlineSources","content":"\n\n\n![이미지](/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png)\n\n웹에서 XML 데이터를 가져오고 추출하는 능력은 웹 개발자에게 중요한 기술입니다. XML은 구조화된 데이터를 교환하는 데 널리 사용되는 형식이며, 많은 온라인 서비스와 API가 이 형식으로 데이터를 제공합니다.\n\nJavaScript로 XML 데이터를 가져오는 현대적인 방법 중 하나는 fetch() API를 사용하는 것입니다. fetch() 함수를 사용하면 이전의 XMLHttpRequest 객체보다 더 간결하고 promise 기반으로 HTTP 요청을 보내고 XML 내용을 검색할 수 있습니다.\n\nfetch()를 사용하여 XML 데이터를 가져오면 JavaScript에서 DOMParser 객체와 같은 도구를 제공하여 XML을 DOM 구조로 구문 분석할 수 있으며, 이를 통해 필요한 정보를 추출할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# [1] JavaScript 프로젝트 생성하기\n\nReplit 플랫폼에서 만들어보세요\n\n![](/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_1.png)\n\n# [2] HTML과 JavaScript 코드 편집하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파일 index.html:\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\n\u003chead\u003e\n  \u003cmeta charset=\"utf-8\"\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width\"\u003e\n  \u003ctitle\u003ereplit\u003c/title\u003e\n  \u003clink href=\"style.css\" rel=\"stylesheet\" type=\"text/css\" /\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n  \u003cdiv id=\"divOutput\"\u003e\u003c/div\u003e\n  \u003cscript src=\"script.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n위 HTML 코드는 웹 페이지의 기본 구조를 설정합니다. 이는 문자 인코딩, 뷰포트, 제목을 지정하는 `head` 섹션과 \"style.css\"라는 외부 CSS 파일에 대한 링크를 포함하고 있습니다. 또한, 동적 콘텐츠를 담을 컨테이너로 사용될 ID가 \"divOutput\"인 `div` 요소와 페이지 로드 시 실행될 \"script.js\"라는 외부 JavaScript 파일을 포함하는 `script` 요소를 포함한 `body` 섹션을 포함합니다. `!DOCTYPE html` 선언은 웹 브라우저에게 이 문서가 HTML5 문서임을 알려주며, 전체 코드는 클라이언트 측 스크립팅 및 JavaScript 파일을 사용한 동적 콘텐츠 조작을 포함한 웹 페이지의 기초를 설정합니다.\n\n파일 script.js:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar myUrl = 'https://catalog.ldc.upenn.edu/desc/addenda/LDC2010T05.xml';\n// CORS 문제를 처리하기 위해 cors-anywhere 서비스를 사용함\nvar proxy = 'https://cors-anywhere.herokuapp.com/';\n\n// 요청 실행\nfetch(proxy + myUrl)\n  .then(response =\u003e response.text())\n  .then(xmlString =\u003e parseXML(xmlString))\n  .catch(error =\u003e console.error(error));\n\n// XML 데이터 파싱\nfunction parseXML(xmlString) {\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(xmlString, 'application/xml');\n\n  // 요소에 액세스\n  const posts = doc.getElementsByTagName('Post');\n  for (let i = 0; i \u003c posts.length; i++) {\n    const post = posts[i];\n    const postClass = post.getAttribute('class');\n    const postUser = post.getAttribute('user');\n    const postText = post.textContent.trim();\n\n    console.log('게시물 클래스:', postClass);\n    console.log('게시물 사용자:', postUser);\n    console.log('게시물 텍스트:', postText);\n\n    const terminals = post.getElementsByTagName('t');\n    for (let j = 0; j \u003c terminals.length; j++) {\n      const terminal = terminals[j];\n      const pos = terminal.getAttribute('pos');\n      const word = terminal.getAttribute('word');\n      console.log(`POS: ${pos}, 단어: ${word}`);\n      const divOutput = document.getElementById('divOutput');\n      if (divOutput) {\n        divOutput.innerHTML += `POS: ${pos}, 단어: ${word}\u003cbr\u003e`;\n      }\n    }\n    console.log();\n  }\n}\n```\n\n제공된 코드는 \"https://catalog.ldc.upenn.edu/desc/addenda/LDC2010T05.xml\"에 위치한 XML 문서를 가져와 내용을 파싱하는 JavaScript 솔루션을 보여줍니다. 이 데이터는 NPS Internet Chatroom Corpus의 일부입니다.\n\n위의 JavaScript 코드는 fetch() API를 사용하여 HTTP 요청을 수행하고, 잠재적인 Cross-Origin Resource Sharing (CORS) 문제를 처리하기 위해 \"https://cors-anywhere.herokuapp.com/\"의 프록시 URL을 활용합니다. fetch 요청에서의 응답은 텍스트 형식으로 변환되며, XML 문자열이 가정적인 parseXML() 함수에 전달되어 추가 처리됩니다. 코드에는 또한 fetch나 파싱 작업 중 발생할 수 있는 문제를 기록하기 위한 오류 처리도 포함되어 있습니다.\n\nparseXML() 함수는 이전 코드 스니펫에서 가져온 XML 데이터를 파싱하는 역할을 합니다. 먼저 DOMParser 객체의 새 인스턴스를 생성하고, parseFromString() 메서드를 사용하여 XML 문자열을 Document 객체로 파싱합니다. 함수는 이후 파싱된 문서에서 모든 'Post' 요소를 검색하고, 각각의 'class', 'user' 및 텍스트 내용을 추출하여 콘솔에 기록합니다. 다음으로, 함수는 각 'Post' 요소 내부의 모든 't' (터미널) 요소를 가져와, 'pos' (품사) 및 'word' 속성을 추출하고, 이 정보를 콘솔에 기록하고 동시에 'divOutput' ID를 가진 HTML 요소에 추가합니다. 이 과정을 통해 함수는 XML 데이터를 파싱하고 관련 정보를 추출하여 이를 콘솔과 웹 페이지에 표시할 수 있게 됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과:\n\n\u003cimg src=\"/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_2.png\" /\u003e\n\n# [3] Replit Code:\n\n코드를 사용하지 않는 방법을 선호하는 경우:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- https://jsonformatter.org/xml-parser\n- https://codebeautify.org/xml-parser-online\n\n# 🤓","ogImage":{"url":"/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png"},"coverImage":"/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e웹에서 XML 데이터를 가져오고 추출하는 능력은 웹 개발자에게 중요한 기술입니다. XML은 구조화된 데이터를 교환하는 데 널리 사용되는 형식이며, 많은 온라인 서비스와 API가 이 형식으로 데이터를 제공합니다.\u003c/p\u003e\n\u003cp\u003eJavaScript로 XML 데이터를 가져오는 현대적인 방법 중 하나는 fetch() API를 사용하는 것입니다. fetch() 함수를 사용하면 이전의 XMLHttpRequest 객체보다 더 간결하고 promise 기반으로 HTTP 요청을 보내고 XML 내용을 검색할 수 있습니다.\u003c/p\u003e\n\u003cp\u003efetch()를 사용하여 XML 데이터를 가져오면 JavaScript에서 DOMParser 객체와 같은 도구를 제공하여 XML을 DOM 구조로 구문 분석할 수 있으며, 이를 통해 필요한 정보를 추출할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e[1] JavaScript 프로젝트 생성하기\u003c/h1\u003e\n\u003cp\u003eReplit 플랫폼에서 만들어보세요\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavaScriptParsingXMLDataFromOnlineSources_1.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch1\u003e[2] HTML과 JavaScript 코드 편집하기\u003c/h1\u003e\n\u003cp\u003e파일 index.html:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;!\u003cspan class=\"hljs-variable constant_\"\u003eDOCTYPE\u003c/span\u003e html\u003e\n\u0026#x3C;html\u003e\n\n\u0026#x3C;head\u003e\n  \u0026#x3C;meta charset=\"utf-8\"\u003e\n  \u0026#x3C;meta name=\"viewport\" content=\"width=device-width\"\u003e\n  \u0026#x3C;title\u003ereplit\u0026#x3C;/title\u003e\n  \u0026#x3C;link href=\"style.css\" rel=\"stylesheet\" type=\"text/css\" /\u003e\n\u0026#x3C;/head\u003e\n\n\u0026#x3C;body\u003e\n  \u0026#x3C;div id=\"divOutput\"\u003e\u0026#x3C;/div\u003e\n  \u0026#x3C;script src=\"script.js\"\u003e\u0026#x3C;/script\u003e\n\u0026#x3C;/body\u003e\n\n\u0026#x3C;/html\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 HTML 코드는 웹 페이지의 기본 구조를 설정합니다. 이는 문자 인코딩, 뷰포트, 제목을 지정하는 \u003ccode\u003ehead\u003c/code\u003e 섹션과 \"style.css\"라는 외부 CSS 파일에 대한 링크를 포함하고 있습니다. 또한, 동적 콘텐츠를 담을 컨테이너로 사용될 ID가 \"divOutput\"인 \u003ccode\u003ediv\u003c/code\u003e 요소와 페이지 로드 시 실행될 \"script.js\"라는 외부 JavaScript 파일을 포함하는 \u003ccode\u003escript\u003c/code\u003e 요소를 포함한 \u003ccode\u003ebody\u003c/code\u003e 섹션을 포함합니다. \u003ccode\u003e!DOCTYPE html\u003c/code\u003e 선언은 웹 브라우저에게 이 문서가 HTML5 문서임을 알려주며, 전체 코드는 클라이언트 측 스크립팅 및 JavaScript 파일을 사용한 동적 콘텐츠 조작을 포함한 웹 페이지의 기초를 설정합니다.\u003c/p\u003e\n\u003cp\u003e파일 script.js:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e myUrl = \u003cspan class=\"hljs-string\"\u003e'https://catalog.ldc.upenn.edu/desc/addenda/LDC2010T05.xml'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// CORS 문제를 처리하기 위해 cors-anywhere 서비스를 사용함\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e proxy = \u003cspan class=\"hljs-string\"\u003e'https://cors-anywhere.herokuapp.com/'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 요청 실행\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(proxy + myUrl)\n  .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u003e\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003etext\u003c/span\u003e())\n  .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003exmlString\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eparseXML\u003c/span\u003e(xmlString))\n  .\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(error));\n\n\u003cspan class=\"hljs-comment\"\u003e// XML 데이터 파싱\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eparseXML\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003exmlString\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e parser = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDOMParser\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e doc = parser.\u003cspan class=\"hljs-title function_\"\u003eparseFromString\u003c/span\u003e(xmlString, \u003cspan class=\"hljs-string\"\u003e'application/xml'\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 요소에 액세스\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e posts = doc.\u003cspan class=\"hljs-title function_\"\u003egetElementsByTagName\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Post'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; posts.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e; i++) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e post = posts[i];\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e postClass = post.\u003cspan class=\"hljs-title function_\"\u003egetAttribute\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'class'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e postUser = post.\u003cspan class=\"hljs-title function_\"\u003egetAttribute\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'user'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e postText = post.\u003cspan class=\"hljs-property\"\u003etextContent\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etrim\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'게시물 클래스:'\u003c/span\u003e, postClass);\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'게시물 사용자:'\u003c/span\u003e, postUser);\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'게시물 텍스트:'\u003c/span\u003e, postText);\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e terminals = post.\u003cspan class=\"hljs-title function_\"\u003egetElementsByTagName\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e't'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e j = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; j \u0026#x3C; terminals.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e; j++) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e terminal = terminals[j];\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pos = terminal.\u003cspan class=\"hljs-title function_\"\u003egetAttribute\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'pos'\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e word = terminal.\u003cspan class=\"hljs-title function_\"\u003egetAttribute\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'word'\u003c/span\u003e);\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`POS: \u003cspan class=\"hljs-subst\"\u003e${pos}\u003c/span\u003e, 단어: \u003cspan class=\"hljs-subst\"\u003e${word}\u003c/span\u003e`\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e divOutput = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'divOutput'\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (divOutput) {\n        divOutput.\u003cspan class=\"hljs-property\"\u003einnerHTML\u003c/span\u003e += \u003cspan class=\"hljs-string\"\u003e`POS: \u003cspan class=\"hljs-subst\"\u003e${pos}\u003c/span\u003e, 단어: \u003cspan class=\"hljs-subst\"\u003e${word}\u003c/span\u003e\u0026#x3C;br\u003e`\u003c/span\u003e;\n      }\n    }\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제공된 코드는 \"\u003ca href=\"https://catalog.ldc.upenn.edu/desc/addenda/LDC2010T05.xml%22%EC%97%90\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://catalog.ldc.upenn.edu/desc/addenda/LDC2010T05.xml\"에\u003c/a\u003e 위치한 XML 문서를 가져와 내용을 파싱하는 JavaScript 솔루션을 보여줍니다. 이 데이터는 NPS Internet Chatroom Corpus의 일부입니다.\u003c/p\u003e\n\u003cp\u003e위의 JavaScript 코드는 fetch() API를 사용하여 HTTP 요청을 수행하고, 잠재적인 Cross-Origin Resource Sharing (CORS) 문제를 처리하기 위해 \"\u003ca href=\"https://cors-anywhere.herokuapp.com/%22%EC%9D%98\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://cors-anywhere.herokuapp.com/\"의\u003c/a\u003e 프록시 URL을 활용합니다. fetch 요청에서의 응답은 텍스트 형식으로 변환되며, XML 문자열이 가정적인 parseXML() 함수에 전달되어 추가 처리됩니다. 코드에는 또한 fetch나 파싱 작업 중 발생할 수 있는 문제를 기록하기 위한 오류 처리도 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003eparseXML() 함수는 이전 코드 스니펫에서 가져온 XML 데이터를 파싱하는 역할을 합니다. 먼저 DOMParser 객체의 새 인스턴스를 생성하고, parseFromString() 메서드를 사용하여 XML 문자열을 Document 객체로 파싱합니다. 함수는 이후 파싱된 문서에서 모든 'Post' 요소를 검색하고, 각각의 'class', 'user' 및 텍스트 내용을 추출하여 콘솔에 기록합니다. 다음으로, 함수는 각 'Post' 요소 내부의 모든 't' (터미널) 요소를 가져와, 'pos' (품사) 및 'word' 속성을 추출하고, 이 정보를 콘솔에 기록하고 동시에 'divOutput' ID를 가진 HTML 요소에 추가합니다. 이 과정을 통해 함수는 XML 데이터를 파싱하고 관련 정보를 추출하여 이를 콘솔과 웹 페이지에 표시할 수 있게 됩니다.\u003c/p\u003e\n\u003cp\u003e결과:\u003c/p\u003e\n\u003ch1\u003e[3] Replit Code:\u003c/h1\u003e\n\u003cp\u003e코드를 사용하지 않는 방법을 선호하는 경우:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://jsonformatter.org/xml-parser\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://jsonformatter.org/xml-parser\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://codebeautify.org/xml-parser-online\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://codebeautify.org/xml-parser-online\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e🤓\u003c/h1\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-JavaScriptParsingXMLDataFromOnlineSources"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>