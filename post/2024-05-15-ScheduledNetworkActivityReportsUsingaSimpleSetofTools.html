<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>간단한 도구를 사용한 예약된 네트워크 활동 보고서 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="간단한 도구를 사용한 예약된 네트워크 활동 보고서 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="간단한 도구를 사용한 예약된 네트워크 활동 보고서 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools" data-gatsby-head="true"/><meta name="twitter:title" content="간단한 도구를 사용한 예약된 네트워크 활동 보고서 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-15 11:30" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_buildManifest.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">간단한 도구를 사용한 예약된 네트워크 활동 보고서</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="간단한 도구를 사용한 예약된 네트워크 활동 보고서" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 15, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><h1>소개</h1>
<p>평범한 Raspberry Pi 팬 중 수면 패턴이 안 좋은 사람은 아침에 먼저 핸드폰을 꺼내어 사랑하는 기기가 잘 작동하고 있는지 궁금해합니다. 혹은 더 넓은 의미로, 자는 동안 내 네트워크에서 무슨 일이 벌어지고 있는지 궁금해합니다.</p>
<p><img src="/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_0.png" alt="Scheduled Network Activity Reports Using a Simple Set of Tools"/></p>
<p>이 블로그 포스트에서 나는 최근 완료한 작은 프로젝트에 대해 설명할 것입니다. 여기서 나는 몇 가지 도구를 연결하여 Raspberry Pi와 관련된 특정 활동에 대한 아침에 첫 번째 활동 보고서를 보내기 위해 사용했습니다. 아래의 구체적인 사용 사례 자체는 특별히 유용하지는 않지만, 여러분이 유용하다고 생각하는 어떤 방향으로든 확장할 수 있는 장난감 예시입니다.</p>
<h1>야간 보고서</h1>
<p>많은 기업들이 이제 일반 업무 시간 이외에 대부분의 사이버 공격이 발생한다는 사실을 깨달았습니다. 그에 따라 단순히 백신 소프트웨어와 내부 IT 팀만으로는 부족하다는 것을 깨달았습니다. 대신 내부 팀을 24시간 365일 외부 사고 대응팀과 함께 보강하는 Sophos MDR(관리되는 탐지 및 대응) 서비스와 같은 것이 필요합니다. 네트워크를 모니터링하고 시간별 보고서를 제공하는 다양한 상업용 도구도 있습니다. 하지만 저는 이미 갖고 있는 간단한 도구들을 활용하여 어떻게 하는 지를 보기 위해 자체적인 이른바 DIY 솔루션을 만들기로 했습니다.</p>
<h1>사용된 도구</h1>
<p>본 프로젝트에서는 집 네트워크에 라즈베리 파이 5를 사용했고, 몇 가지 내부 장치(Pinging에 사용되는)와 함께 사용했습니다. 소프트웨어로는 tcpdump(명령줄 기반의 데이터 패킷 분석 도구), tcpdump와 유사한 Wireshark의 명령줄 대체인 tshark, 데이터 분석을 위해 Python(Pandas 및 Matplotlib 포함), 이메일 발송을 위한 sendmail, 그리고 Gmail 계정을 사용했습니다. 이러한 도구들은 몇 가지 bash 스크립트로 연결되었고 cron을 통해 실행 스케줄이 잡혔습니다.</p>
<p>기본 아이디어는 다음과 같이 3단계로 구성되었어요.</p>
<ul>
<li>나의 라즈베리 파이에 대한 핑을 로깅하기 시작하고 종료할 시간을 선택하여 (예: 밤새) tcpdump 스케줄링</li>
<li>이 데이터를 분석하여 간단한 그래프로 변환하는 파이썬 스크립트를 스케줄링</li>
<li>라즈베리 파이에게 이 그래프를 내가 선택한 시간에 이메일로 보내도록 하는 스케줄링</li>
</ul>
<p>각 단계를 함께 살펴보겠습니다.</p>
<h1>파트 1 — tcpdump</h1>
<p>tcpdump을 사용하는 것은 매우 간단하며, 온라인에는 무수히 많은 훌륭한 가이드가 있습니다. 예를 들어 아래 라인은 wlan0 인터페이스에서 ICMP(Internet Control Message Protocol) 패킷을 수신하도록 tcpdump에 지시합니다.</p>
<pre><code class="hljs language-js">tcpdump -i wlan0 icmp
</code></pre>
<p>이 코드는 화면에 패킷을 표시합니다. 파일에 기록하려면(&#x27;pings.pcap&#x27;에 로그를 기록하는 경우), 다음 명령을 사용해야 합니다.</p>
<pre><code class="hljs language-js">tcpdump -i wlan0 icmp -w pings.<span class="hljs-property">pcap</span>
</code></pre>
<p>다수의 pcap 파일 가이드가 있습니다 [3].</p>
<p>패킷 캡처의 시작과 종료를 예약하는 것은 적절한 명령어를 두 개의 별도 셸 스크립트에 넣고 cron을 사용하여 예약하는 것만으로도 간단합니다. 이러한 스크립트에 대해 도움이 되는 GitHub 저장소 [4]를 찾아내어 이를 편집했습니다.</p>
<p>실행 중에는 Windows 머신과 WebSSH 앱을 실행중인 휴대전화(모바일 폰)를 사용하여 Raspberry Pi에 핑을 전송했습니다 [5].</p>
<p>이 단계의 마지막 단계는 pcap 파일을 Python이 이해할 수 있는 형식으로 변환하는 것입니다. 이를 위해 tshark를 사용했습니다. &#x27;pings.pcap&#x27; 파일을 &#x27;pings.csv&#x27;로 변환하는 명령어는 유용한 블로그 포스트에서 찾은 내용을 이용하여 아래와 같이 실행했습니다 [6].</p>
<pre><code class="hljs language-js">tshark -N n -r ./pings.<span class="hljs-property">pcap</span> -T fields -e frame.<span class="hljs-property">number</span> -e _ws.<span class="hljs-property">col</span>.<span class="hljs-property">Time</span> -e _ws.<span class="hljs-property">col</span>.<span class="hljs-property">Source</span> -e _ws.<span class="hljs-property">col</span>.<span class="hljs-property">Destination</span> -e _ws.<span class="hljs-property">col</span>.<span class="hljs-property">Protocol</span> -e _ws.<span class="hljs-property">col</span>.<span class="hljs-property">Length</span> -e _ws.<span class="hljs-property">col</span>.<span class="hljs-property">Info</span> -e tcp.<span class="hljs-property">seq</span> -e ip.<span class="hljs-property">ttl</span> -E header=y -E separator=, &gt; pings.<span class="hljs-property">csv</span>
</code></pre>
<p>이 명령어는 그 후 &#x27;stop&#x27; 스크립트의 끝에 포함되었습니다.</p>
<h1>파트 2— 파이썬</h1>
<p>관심 있는 데이터를 수집하고 CSV 파일로 변환한 후에는 Python으로 할 수 있는 일이 무궁무진합니다. 사용한 스크립트는 매우 간단합니다. 각 IP 주소에서 ping의 수를 계산하고, 데이터의 막대 플롯을 생성한 다음 jpg로 저장합니다.```</p>
<pre><code class="hljs language-js">#라이브러리 가져오기
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt

#데이터 불러오기
pings = pd.<span class="hljs-title function_">read_csv</span>(<span class="hljs-string">&#x27;pings.csv&#x27;</span>)

#관심 있는 열로 제한하기
pings = pings.<span class="hljs-property">iloc</span>[:,<span class="hljs-number">0</span>]

#다시 데이터프레임으로 변환하기
pings = pings.<span class="hljs-title function_">to_frame</span>()

#열 이름 변경하기
pings.<span class="hljs-property">columns</span> = [<span class="hljs-string">&#x27;Source_IP&#x27;</span>]

#<span class="hljs-title class_">Raspberry</span> <span class="hljs-title class_">Pi</span> 자체에서의 핑 제거하기
pings = pings[pings[<span class="hljs-string">&#x27;Source_IP&#x27;</span>] != <span class="hljs-string">&#x27;192.168.68.127&#x27;</span>]

#<span class="hljs-variable constant_">IP</span> 주소로 그룹화하고, 수를 세어 정렬하기
pings_gb = pings.<span class="hljs-title function_">groupby</span>([<span class="hljs-string">&#x27;Source_IP&#x27;</span>]).<span class="hljs-title function_">size</span>().<span class="hljs-title function_">sort_values</span>()

#그룹화된 데이터를 사용하여 막대 그래프 만들기
fig = pings_gb.<span class="hljs-title function_">plot</span>(kind = <span class="hljs-string">&#x27;bar&#x27;</span>, rot=<span class="hljs-number">0</span>, figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>), fontsize=<span class="hljs-number">13</span>)
fig.<span class="hljs-title function_">set_ylabel</span>(<span class="hljs-string">&quot;Source Count&quot;</span>)
fig.<span class="hljs-property">figure</span>.<span class="hljs-title function_">savefig</span>(<span class="hljs-string">&#x27;pings.jpg&#x27;</span>)
</code></pre>
<h1>파트 3— Gmail</h1>
<p>이 부분은 가장 많은 노력을 필요로 했으며, Gmail 쪽에서의 설정(보안 수준이 낮은 앱 액세스 허용 및 앱 비밀번호 생성)과 Raspberry Pi 쪽에서의 설정(sendmail 설치 및 구성)이 포함되었습니다. 이러한 단계에 대한 두 가지 훌륭한 가이드는 [7, 8]에서 확인할 수 있습니다. 이 가이드를 따르면 var/logs/maillog의 로그 파일에 &quot;My unqualified host name (raspberrypi) unknown; sleeping for retry&quot;라는 오류가 계속 표시된다는 것에 유의하십시오. 이 오류를 해결하는 방법은 [9]에서 확인하십시오. 또한, 접근 보안 수준이 낮기 때문에 별도의 Gmail 계정을 만드는 것이 좋을 수 있습니다.</p>
<p>설정을 완료하면 Python에서 생성된 이미지를 첨부한 이메일을 보낼 수 있습니다.</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Enjoy! from Raspberry Pi&quot;</span> | mail -s <span class="hljs-string">&quot;Your Overnight Ping Analysis!&quot;</span> [내 주 이메일 주소] -A pings.jpg
</code></pre>
<h1>모두 함께 사용하기</h1>
<p>마지막으로, 위의 단계들을 연결하여 크론을 사용할 수 있습니다. (좋은 크론 도우미를 보려면 여기를 참조하세요 [10]). 이를 위해 크론탭을 수정하여 아래와 유사한 내용으로 편집하세요.</p>
<pre><code class="hljs language-bash">0 22 * * * bash /robh/start_tcpdump.sh <span class="hljs-comment"># 10시에 수집 시작</span>
0 6 * * * bash /robh/stop_and_convert.sh <span class="hljs-comment"># 6시에 수집 중지 및 csv로 변환</span>
5 6 * * * python ping_script.py <span class="hljs-comment"># 6:05에 파이썬 스크립트 실행</span>
30 6 * * * bash /robh/email.sh <span class="hljs-comment"># 6:30에 이미지를 이메일로 보내기</span>
</code></pre>
<p>작업 표정 변경이 완료되었습니다.</p>
<p>이메일 안에는 Python 스크립트가 생성한 이미지 파일이 포함되어 있었습니다.</p>
<p><img src="/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_2.png" alt="image"/></p>
<h1>결론</h1>
<p>위의 이미지는 매우 간단하지만, 크론을 사용하여 다음 이벤트 체인을 예약하는 원칙을 보여주기를 희망합니다,</p>
<p>데이터 수집 → CSV로 변환 → Python으로 분석 → 결과 이메일로 전송</p>
<p>수집하는 데이터와 분석 방법은 물론 무한히 맞춤화할 수 있어요. 이 게시물이 여러분의 일간 보고 요구 사항에 유용한 시작점이 되었으면 좋겠어요!</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"간단한 도구를 사용한 예약된 네트워크 활동 보고서","description":"","date":"2024-05-15 11:30","slug":"2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools","content":"\n\n# 소개\n\n평범한 Raspberry Pi 팬 중 수면 패턴이 안 좋은 사람은 아침에 먼저 핸드폰을 꺼내어 사랑하는 기기가 잘 작동하고 있는지 궁금해합니다. 혹은 더 넓은 의미로, 자는 동안 내 네트워크에서 무슨 일이 벌어지고 있는지 궁금해합니다.\n\n![Scheduled Network Activity Reports Using a Simple Set of Tools](/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_0.png)\n\n이 블로그 포스트에서 나는 최근 완료한 작은 프로젝트에 대해 설명할 것입니다. 여기서 나는 몇 가지 도구를 연결하여 Raspberry Pi와 관련된 특정 활동에 대한 아침에 첫 번째 활동 보고서를 보내기 위해 사용했습니다. 아래의 구체적인 사용 사례 자체는 특별히 유용하지는 않지만, 여러분이 유용하다고 생각하는 어떤 방향으로든 확장할 수 있는 장난감 예시입니다.\n\n\n\n# 야간 보고서\n\n많은 기업들이 이제 일반 업무 시간 이외에 대부분의 사이버 공격이 발생한다는 사실을 깨달았습니다. 그에 따라 단순히 백신 소프트웨어와 내부 IT 팀만으로는 부족하다는 것을 깨달았습니다. 대신 내부 팀을 24시간 365일 외부 사고 대응팀과 함께 보강하는 Sophos MDR(관리되는 탐지 및 대응) 서비스와 같은 것이 필요합니다. 네트워크를 모니터링하고 시간별 보고서를 제공하는 다양한 상업용 도구도 있습니다. 하지만 저는 이미 갖고 있는 간단한 도구들을 활용하여 어떻게 하는 지를 보기 위해 자체적인 이른바 DIY 솔루션을 만들기로 했습니다.\n\n# 사용된 도구\n\n본 프로젝트에서는 집 네트워크에 라즈베리 파이 5를 사용했고, 몇 가지 내부 장치(Pinging에 사용되는)와 함께 사용했습니다. 소프트웨어로는 tcpdump(명령줄 기반의 데이터 패킷 분석 도구), tcpdump와 유사한 Wireshark의 명령줄 대체인 tshark, 데이터 분석을 위해 Python(Pandas 및 Matplotlib 포함), 이메일 발송을 위한 sendmail, 그리고 Gmail 계정을 사용했습니다. 이러한 도구들은 몇 가지 bash 스크립트로 연결되었고 cron을 통해 실행 스케줄이 잡혔습니다.\n\n\n\n기본 아이디어는 다음과 같이 3단계로 구성되었어요.\n\n- 나의 라즈베리 파이에 대한 핑을 로깅하기 시작하고 종료할 시간을 선택하여 (예: 밤새) tcpdump 스케줄링\n- 이 데이터를 분석하여 간단한 그래프로 변환하는 파이썬 스크립트를 스케줄링\n- 라즈베리 파이에게 이 그래프를 내가 선택한 시간에 이메일로 보내도록 하는 스케줄링\n\n각 단계를 함께 살펴보겠습니다.\n\n# 파트 1 — tcpdump\n\n\n\ntcpdump을 사용하는 것은 매우 간단하며, 온라인에는 무수히 많은 훌륭한 가이드가 있습니다. 예를 들어 아래 라인은 wlan0 인터페이스에서 ICMP(Internet Control Message Protocol) 패킷을 수신하도록 tcpdump에 지시합니다.\n\n```js\ntcpdump -i wlan0 icmp\n```\n\n이 코드는 화면에 패킷을 표시합니다. 파일에 기록하려면('pings.pcap'에 로그를 기록하는 경우), 다음 명령을 사용해야 합니다.\n\n```js\ntcpdump -i wlan0 icmp -w pings.pcap\n```\n\n\n\n다수의 pcap 파일 가이드가 있습니다 [3].\n\n패킷 캡처의 시작과 종료를 예약하는 것은 적절한 명령어를 두 개의 별도 셸 스크립트에 넣고 cron을 사용하여 예약하는 것만으로도 간단합니다. 이러한 스크립트에 대해 도움이 되는 GitHub 저장소 [4]를 찾아내어 이를 편집했습니다.\n\n실행 중에는 Windows 머신과 WebSSH 앱을 실행중인 휴대전화(모바일 폰)를 사용하여 Raspberry Pi에 핑을 전송했습니다 [5].\n\n이 단계의 마지막 단계는 pcap 파일을 Python이 이해할 수 있는 형식으로 변환하는 것입니다. 이를 위해 tshark를 사용했습니다. 'pings.pcap' 파일을 'pings.csv'로 변환하는 명령어는 유용한 블로그 포스트에서 찾은 내용을 이용하여 아래와 같이 실행했습니다 [6].\n\n\n\n```js\ntshark -N n -r ./pings.pcap -T fields -e frame.number -e _ws.col.Time -e _ws.col.Source -e _ws.col.Destination -e _ws.col.Protocol -e _ws.col.Length -e _ws.col.Info -e tcp.seq -e ip.ttl -E header=y -E separator=, \u003e pings.csv\n```\n\n이 명령어는 그 후 'stop' 스크립트의 끝에 포함되었습니다.\n\n# 파트 2— 파이썬\n\n관심 있는 데이터를 수집하고 CSV 파일로 변환한 후에는 Python으로 할 수 있는 일이 무궁무진합니다. 사용한 스크립트는 매우 간단합니다. 각 IP 주소에서 ping의 수를 계산하고, 데이터의 막대 플롯을 생성한 다음 jpg로 저장합니다.```\n\n\n\n```js\n#라이브러리 가져오기\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n#데이터 불러오기\npings = pd.read_csv('pings.csv')\n\n#관심 있는 열로 제한하기\npings = pings.iloc[:,0]\n\n#다시 데이터프레임으로 변환하기\npings = pings.to_frame()\n\n#열 이름 변경하기\npings.columns = ['Source_IP']\n\n#Raspberry Pi 자체에서의 핑 제거하기\npings = pings[pings['Source_IP'] != '192.168.68.127']\n\n#IP 주소로 그룹화하고, 수를 세어 정렬하기\npings_gb = pings.groupby(['Source_IP']).size().sort_values()\n\n#그룹화된 데이터를 사용하여 막대 그래프 만들기\nfig = pings_gb.plot(kind = 'bar', rot=0, figsize=(10, 8), fontsize=13)\nfig.set_ylabel(\"Source Count\")\nfig.figure.savefig('pings.jpg')\n```\n\n# 파트 3— Gmail\n\n이 부분은 가장 많은 노력을 필요로 했으며, Gmail 쪽에서의 설정(보안 수준이 낮은 앱 액세스 허용 및 앱 비밀번호 생성)과 Raspberry Pi 쪽에서의 설정(sendmail 설치 및 구성)이 포함되었습니다. 이러한 단계에 대한 두 가지 훌륭한 가이드는 [7, 8]에서 확인할 수 있습니다. 이 가이드를 따르면 var/logs/maillog의 로그 파일에 \"My unqualified host name (raspberrypi) unknown; sleeping for retry\"라는 오류가 계속 표시된다는 것에 유의하십시오. 이 오류를 해결하는 방법은 [9]에서 확인하십시오. 또한, 접근 보안 수준이 낮기 때문에 별도의 Gmail 계정을 만드는 것이 좋을 수 있습니다.\n\n설정을 완료하면 Python에서 생성된 이미지를 첨부한 이메일을 보낼 수 있습니다.\n\n\n\n\n```bash\necho \"Enjoy! from Raspberry Pi\" | mail -s \"Your Overnight Ping Analysis!\" [내 주 이메일 주소] -A pings.jpg\n```\n\n# 모두 함께 사용하기\n\n마지막으로, 위의 단계들을 연결하여 크론을 사용할 수 있습니다. (좋은 크론 도우미를 보려면 여기를 참조하세요 [10]). 이를 위해 크론탭을 수정하여 아래와 유사한 내용으로 편집하세요.\n\n```bash\n0 22 * * * bash /robh/start_tcpdump.sh # 10시에 수집 시작\n0 6 * * * bash /robh/stop_and_convert.sh # 6시에 수집 중지 및 csv로 변환\n5 6 * * * python ping_script.py # 6:05에 파이썬 스크립트 실행\n30 6 * * * bash /robh/email.sh # 6:30에 이미지를 이메일로 보내기\n```\n\n\n\n작업 표정 변경이 완료되었습니다.\n\n\n\n이메일 안에는 Python 스크립트가 생성한 이미지 파일이 포함되어 있었습니다.\n\n![image](/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_2.png)\n\n# 결론\n\n위의 이미지는 매우 간단하지만, 크론을 사용하여 다음 이벤트 체인을 예약하는 원칙을 보여주기를 희망합니다,\n\n\n\n데이터 수집 → CSV로 변환 → Python으로 분석 → 결과 이메일로 전송\n\n수집하는 데이터와 분석 방법은 물론 무한히 맞춤화할 수 있어요. 이 게시물이 여러분의 일간 보고 요구 사항에 유용한 시작점이 되었으면 좋겠어요!","ogImage":{"url":"/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_0.png"},"coverImage":"/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_0.png","tag":["Tech"],"readingTime":5},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"소개\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"평범한 Raspberry Pi 팬 중 수면 패턴이 안 좋은 사람은 아침에 먼저 핸드폰을 꺼내어 사랑하는 기기가 잘 작동하고 있는지 궁금해합니다. 혹은 더 넓은 의미로, 자는 동안 내 네트워크에서 무슨 일이 벌어지고 있는지 궁금해합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_0.png\",\n        alt: \"Scheduled Network Activity Reports Using a Simple Set of Tools\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 블로그 포스트에서 나는 최근 완료한 작은 프로젝트에 대해 설명할 것입니다. 여기서 나는 몇 가지 도구를 연결하여 Raspberry Pi와 관련된 특정 활동에 대한 아침에 첫 번째 활동 보고서를 보내기 위해 사용했습니다. 아래의 구체적인 사용 사례 자체는 특별히 유용하지는 않지만, 여러분이 유용하다고 생각하는 어떤 방향으로든 확장할 수 있는 장난감 예시입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"야간 보고서\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"많은 기업들이 이제 일반 업무 시간 이외에 대부분의 사이버 공격이 발생한다는 사실을 깨달았습니다. 그에 따라 단순히 백신 소프트웨어와 내부 IT 팀만으로는 부족하다는 것을 깨달았습니다. 대신 내부 팀을 24시간 365일 외부 사고 대응팀과 함께 보강하는 Sophos MDR(관리되는 탐지 및 대응) 서비스와 같은 것이 필요합니다. 네트워크를 모니터링하고 시간별 보고서를 제공하는 다양한 상업용 도구도 있습니다. 하지만 저는 이미 갖고 있는 간단한 도구들을 활용하여 어떻게 하는 지를 보기 위해 자체적인 이른바 DIY 솔루션을 만들기로 했습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"사용된 도구\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"본 프로젝트에서는 집 네트워크에 라즈베리 파이 5를 사용했고, 몇 가지 내부 장치(Pinging에 사용되는)와 함께 사용했습니다. 소프트웨어로는 tcpdump(명령줄 기반의 데이터 패킷 분석 도구), tcpdump와 유사한 Wireshark의 명령줄 대체인 tshark, 데이터 분석을 위해 Python(Pandas 및 Matplotlib 포함), 이메일 발송을 위한 sendmail, 그리고 Gmail 계정을 사용했습니다. 이러한 도구들은 몇 가지 bash 스크립트로 연결되었고 cron을 통해 실행 스케줄이 잡혔습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본 아이디어는 다음과 같이 3단계로 구성되었어요.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"나의 라즈베리 파이에 대한 핑을 로깅하기 시작하고 종료할 시간을 선택하여 (예: 밤새) tcpdump 스케줄링\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이 데이터를 분석하여 간단한 그래프로 변환하는 파이썬 스크립트를 스케줄링\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"라즈베리 파이에게 이 그래프를 내가 선택한 시간에 이메일로 보내도록 하는 스케줄링\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 단계를 함께 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"파트 1 — tcpdump\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"tcpdump을 사용하는 것은 매우 간단하며, 온라인에는 무수히 많은 훌륭한 가이드가 있습니다. 예를 들어 아래 라인은 wlan0 인터페이스에서 ICMP(Internet Control Message Protocol) 패킷을 수신하도록 tcpdump에 지시합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"tcpdump -i wlan0 icmp\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 코드는 화면에 패킷을 표시합니다. 파일에 기록하려면('pings.pcap'에 로그를 기록하는 경우), 다음 명령을 사용해야 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"tcpdump -i wlan0 icmp -w pings.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"pcap\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다수의 pcap 파일 가이드가 있습니다 [3].\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"패킷 캡처의 시작과 종료를 예약하는 것은 적절한 명령어를 두 개의 별도 셸 스크립트에 넣고 cron을 사용하여 예약하는 것만으로도 간단합니다. 이러한 스크립트에 대해 도움이 되는 GitHub 저장소 [4]를 찾아내어 이를 편집했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실행 중에는 Windows 머신과 WebSSH 앱을 실행중인 휴대전화(모바일 폰)를 사용하여 Raspberry Pi에 핑을 전송했습니다 [5].\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 단계의 마지막 단계는 pcap 파일을 Python이 이해할 수 있는 형식으로 변환하는 것입니다. 이를 위해 tshark를 사용했습니다. 'pings.pcap' 파일을 'pings.csv'로 변환하는 명령어는 유용한 블로그 포스트에서 찾은 내용을 이용하여 아래와 같이 실행했습니다 [6].\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"tshark -N n -r ./pings.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"pcap\"\n        }), \" -T fields -e frame.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"number\"\n        }), \" -e _ws.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"col\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Time\"\n        }), \" -e _ws.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"col\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Source\"\n        }), \" -e _ws.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"col\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Destination\"\n        }), \" -e _ws.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"col\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Protocol\"\n        }), \" -e _ws.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"col\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Length\"\n        }), \" -e _ws.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"col\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Info\"\n        }), \" -e tcp.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"seq\"\n        }), \" -e ip.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ttl\"\n        }), \" -E header=y -E separator=, \u003e pings.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"csv\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 명령어는 그 후 'stop' 스크립트의 끝에 포함되었습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"파트 2— 파이썬\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"관심 있는 데이터를 수집하고 CSV 파일로 변환한 후에는 Python으로 할 수 있는 일이 무궁무진합니다. 사용한 스크립트는 매우 간단합니다. 각 IP 주소에서 ping의 수를 계산하고, 데이터의 막대 플롯을 생성한 다음 jpg로 저장합니다.```\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"#라이브러리 가져오기\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" pandas \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" pd\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" matplotlib.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"pyplot\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" plt\\n\\n#데이터 불러오기\\npings = pd.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"read_csv\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'pings.csv'\"\n        }), \")\\n\\n#관심 있는 열로 제한하기\\npings = pings.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"iloc\"\n        }), \"[:,\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"]\\n\\n#다시 데이터프레임으로 변환하기\\npings = pings.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to_frame\"\n        }), \"()\\n\\n#열 이름 변경하기\\npings.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"columns\"\n        }), \" = [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Source_IP'\"\n        }), \"]\\n\\n#\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Raspberry\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Pi\"\n        }), \" 자체에서의 핑 제거하기\\npings = pings[pings[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Source_IP'\"\n        }), \"] != \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'192.168.68.127'\"\n        }), \"]\\n\\n#\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"IP\"\n        }), \" 주소로 그룹화하고, 수를 세어 정렬하기\\npings_gb = pings.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"groupby\"\n        }), \"([\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Source_IP'\"\n        }), \"]).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"size\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sort_values\"\n        }), \"()\\n\\n#그룹화된 데이터를 사용하여 막대 그래프 만들기\\nfig = pings_gb.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"plot\"\n        }), \"(kind = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'bar'\"\n        }), \", rot=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", figsize=(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8\"\n        }), \"), fontsize=\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"13\"\n        }), \")\\nfig.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"set_ylabel\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Source Count\\\"\"\n        }), \")\\nfig.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"figure\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"savefig\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'pings.jpg'\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"파트 3— Gmail\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 부분은 가장 많은 노력을 필요로 했으며, Gmail 쪽에서의 설정(보안 수준이 낮은 앱 액세스 허용 및 앱 비밀번호 생성)과 Raspberry Pi 쪽에서의 설정(sendmail 설치 및 구성)이 포함되었습니다. 이러한 단계에 대한 두 가지 훌륭한 가이드는 [7, 8]에서 확인할 수 있습니다. 이 가이드를 따르면 var/logs/maillog의 로그 파일에 \\\"My unqualified host name (raspberrypi) unknown; sleeping for retry\\\"라는 오류가 계속 표시된다는 것에 유의하십시오. 이 오류를 해결하는 방법은 [9]에서 확인하십시오. 또한, 접근 보안 수준이 낮기 때문에 별도의 Gmail 계정을 만드는 것이 좋을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"설정을 완료하면 Python에서 생성된 이미지를 첨부한 이메일을 보낼 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-bash\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"echo\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Enjoy! from Raspberry Pi\\\"\"\n        }), \" | mail -s \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Your Overnight Ping Analysis!\\\"\"\n        }), \" [내 주 이메일 주소] -A pings.jpg\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"모두 함께 사용하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, 위의 단계들을 연결하여 크론을 사용할 수 있습니다. (좋은 크론 도우미를 보려면 여기를 참조하세요 [10]). 이를 위해 크론탭을 수정하여 아래와 유사한 내용으로 편집하세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-bash\",\n        children: [\"0 22 * * * bash /robh/start_tcpdump.sh \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 10시에 수집 시작\"\n        }), \"\\n0 6 * * * bash /robh/stop_and_convert.sh \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 6시에 수집 중지 및 csv로 변환\"\n        }), \"\\n5 6 * * * python ping_script.py \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 6:05에 파이썬 스크립트 실행\"\n        }), \"\\n30 6 * * * bash /robh/email.sh \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 6:30에 이미지를 이메일로 보내기\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"작업 표정 변경이 완료되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이메일 안에는 Python 스크립트가 생성한 이미지 파일이 포함되어 있었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools_2.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 이미지는 매우 간단하지만, 크론을 사용하여 다음 이벤트 체인을 예약하는 원칙을 보여주기를 희망합니다,\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데이터 수집 → CSV로 변환 → Python으로 분석 → 결과 이메일로 전송\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"수집하는 데이터와 분석 방법은 물론 무한히 맞춤화할 수 있어요. 이 게시물이 여러분의 일간 보고 요구 사항에 유용한 시작점이 되었으면 좋겠어요!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-15-ScheduledNetworkActivityReportsUsingaSimpleSetofTools"},"buildId":"R94iUTCf1NWeBC_VXjTJG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>