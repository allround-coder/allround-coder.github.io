<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated" data-gatsby-head="true"/><meta name="twitter:title" content="리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 21:21" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_buildManifest.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">18<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><h2>간단한 애니메이션이 앱의 사용자 경험을 얼마나 높일 수 있는지 궁금했던 적이 있나요?</h2>
<p>잘 디자인된 애니메이션은 평범한 사용자 상호 작용을 진정으로 기억에 남는 경험으로 변화시킬 수 있습니다.</p>
<p>이 포스트에서는 React Native와 Reanimated 라이브러리를 사용하여 모바일 앱에 맞춘 흥미로운 사용자 정의 &#x27;당겨서 새로고침&#x27; 애니메이션을 만드는 방법을 배우게 됩니다.</p>
<h2>그냥 React Native의 RefreshControl을 사용하는 것이 좋지 않을까요?</h2>
<p>리액트 네이티브로 모바일 애플리케이션을 개발할 때, Pull-to-refresh 기능을 구현하는 데 RefreshControl 컴포넌트를 주로 사용합니다.</p>
<p>간단하고 직관적이지만, 꽤 기본적이며 제한된 사용자 정의 기능을 제공합니다. 이로 인해 여러분의 앱이 그저 다른 어떤 앱처럼 보이는 경우가 있을 수 있습니다.</p>
<p>사용자 정의 애니메이션을 생성하면 앱의 모양과 느낌을 자유롭게 조절하여 브랜딩 및 디자인 언어와 완벽하게 일치시킬 수 있습니다. 이로써 앱이 더 독특하고 기억에 남는 사용자 경험을 제공하게 되어 앱이 더욱 독특하고 기억에 남게 만듭니다.</p>
<h2>왜 Animated가 아닌 Reanimated 라이브러리를 사용해야 하는가?</h2>
<p>React Native에서 애니메이션에 관한 이야기가 나온다면, 두 가지 주요 라이브러리가 떠오르게 됩니다: 내장된 Animated 라이브러리와 더 고급화된 Reanimated 라이브러리가 있습니다.</p>
<p>Reanimated가 선호되는 이유는 몇 가지가 있습니다:</p>
<ul>
<li>성능:
Reanimated는 특히 복잡한 애니메이션에 대해 우수한 성능을 제공합니다. 네이티브 스레드를 활용하여 JavaScript 스레드 대신 작동함으로써 더 효율적으로 작동합니다. 이는 훨씬 부드러운 애니메이션을 가능하게 하며, 이는 원활한 사용자 경험을 위한 중요한 요소입니다.</li>
<li>제스처 기반 애니메이션:
Reanimated는 더 복잡한 애니메이션 처리를 위한 더 나은 API를 제공하며, 제스처와 애니메이션의 더 섬세한 제어와 더 부드러운 통합을 가능케 합니다.</li>
<li>선언적 접근: Animated와 달리, Reanimated는 애니메이션에 더 선언적인 접근 방식을 채용합니다. 이는 애니메이션이 더 복잡해지면서 이해하고 관리하기 쉬워집니다.</li>
</ul>
<h1>시작하기</h1>
<p>이 튜토리얼에서는 간단한 앱을 향상시키고자 합니다. 이 앱은 FlatList에서 카드 형태로 표시되는 Dribbble 샷 목록을 보여줍니다. 우리의 목표는 사용자가 목록을 위로 당겼을 때 나타나는 사용자 정의 새로 고침 애니메이션을 추가하는 것입니다.</p>
<h2>프로젝트 복제 및 설정</h2>
<p>로컬 컴퓨터에서 저장소를 클론하고 프로젝트를 설정하기 위해 다음 단계를 따라주세요:</p>
<p>저장소 복제:
터미널을 열고 다음 명령어로 저장소를 클론하세요:</p>
<pre><code class="hljs language-js">git clone <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/teefouad/custom-rn-refresh-animation-start.git</span>
</code></pre>
<p>VSCode에서 프로젝트 열기:
이 강좌의 모든 코드는 app/index.tsx에 들어가기 때문에 해당 파일을 열어 다른 파일과 디렉터리를 무시할 수 있습니다.
다음과 같은 내용이 표시됩니다:</p>
<img src="/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png"/>
<p>의존성 설치:
필요한 종속 항목을 설치하려면 npm install 또는 yarn을 실행하세요.```</p>
<p>프로젝트 실행하기:
npm start 또는 yarn start를 실행하여 프로젝트를 시작하세요. 이렇게 하면 Metro 번들러가 초기화되고 앱이 개발 모드로 실행됩니다.</p>
<p>프로젝트가 설정되었으므로, 이제 우리는 흥미로운 부분으로 빠져들 준비가 되었습니다: 우리의 사용자 정의 새로고침 애니메이션 만들기!</p>
<h1>애니메이션 만들기: 상단 스크롤 감지</h1>
<p>사용자 정의 애니메이션을 만드는 첫 번째 단계는 FlatList가 맨 위로 스크롤되었을 때 감지하는 것입니다.</p>
<p>이를 위해 Reanimated에서 useAnimatedScrollHandler를 사용할 것입니다. 이 훅은 최적화되고 성능이 좋은 방식으로 스크롤 이벤트를 처리할 수 있는 함수를 제공할 것입니다.</p>
<ol>
<li>먼저, Reanimated에서 훅을 import 해야 합니다:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
 * Dependency imports
 */</span>

 <span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
 <span class="hljs-keyword">import</span> { <span class="hljs-title class_">FlatList</span>, <span class="hljs-title class_">StyleSheet</span>, <span class="hljs-title class_">View</span>, <span class="hljs-title class_">ViewProps</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;
 <span class="hljs-keyword">import</span> <span class="hljs-title class_">Animated</span>, { useAnimatedScrollHandler } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native-reanimated&#x27;</span>;
</code></pre>
<ol start="2">
<li>useAnimatedScrollHandler를 사용하여 스크롤 핸들러를 생성하세요:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">DribbbleShots</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">DribbbleShotsProps</span> &amp; <span class="hljs-title class_">ViewProps</span>&gt; = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> scrollHandler = <span class="hljs-title function_">useAnimatedScrollHandler</span>({
    <span class="hljs-attr">onScroll</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">contentOffset</span>.<span class="hljs-property">y</span>);
    },
  });

  <span class="hljs-keyword">return</span> (
    ...
</code></pre>
<p>지금은 리스트 스크롤 위치를 기록하는 것으로 할게요.</p>
<ol start="3">
<li>리스트에 스크롤 핸들러를 연결해보세요. useAnimatedScrollHandler를 사용하여 만든 스크롤 이벤트 핸들러는 React Native의 FlatList와 호환되지 않을 것이므로 Reanimated에서 제공하는 FlatList로 대체해야 합니다.</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.root}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Animated.FlatList</span>
        <span class="hljs-attr">...</span>
        <span class="hljs-attr">onScroll</span>=<span class="hljs-string">{scrollHandler}</span>
        <span class="hljs-attr">scrollEventThrottle</span>=<span class="hljs-string">{16}</span> // <span class="hljs-attr">부드러운</span> <span class="hljs-attr">성능을</span> <span class="hljs-attr">위한</span> <span class="hljs-attr">좋은</span> <span class="hljs-attr">방법</span>
      /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>
);
</code></pre>
<p>scrollEventThrottle 속성은 스크롤 이벤트가 발생하는 빈도를 제어합니다. 여기서 값이 16이면 스크롤 이벤트를 대략 16밀리초마다 캡처합니다. 이렇게 하면 애니메이션이 부드럽고 반응이 빠릅니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1280/1*6cGVuwIPgf4QnLIC79xN7g.gif" alt="이미지"/></p>
<p>이제 콘솔에 스크롤 위치를 단순히 기록하는 대신, 이를 공유 값에 저장합시다.</p>
<p>다음과 같이 코드를 업데이트하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Animated</span>, {
  useAnimatedScrollHandler,
  useSharedValue,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native-reanimated&#x27;</span>;

...

<span class="hljs-keyword">const</span> <span class="hljs-title class_">DribbbleShots</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">DribbbleShotsProps</span> &amp; <span class="hljs-title class_">ViewProps</span>&gt; = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> scrollPosition = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">const</span> scrollHandler = <span class="hljs-title function_">useAnimatedScrollHandler</span>({
    <span class="hljs-attr">onScroll</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      scrollPosition.<span class="hljs-property">value</span> = event.<span class="hljs-property">contentOffset</span>.<span class="hljs-property">y</span>;
    },
  });
  ...
</code></pre>
<h1>단계 2: 팬 제스처 캡처하기</h1>
<p>이제 목록이 화면 상단까지 스크롤된 것을 감지할 수 있게 되었으므로, 다음 단계는 사용자가 목록을 더 아래로 끌 때 팬 제스처를 캡처하는 것입니다. 이를 달성하기 위해 FlatList의 부모 View에 PanResponder를 사용할 것입니다.</p>
<p>팬 응답자(pan responder)를 생성하기 위해 React Native에서 PanResponder를 가져오세요:```</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">PanResponder</span>,
  <span class="hljs-title class_">StyleSheet</span>,
  <span class="hljs-title class_">View</span>,
  <span class="hljs-title class_">ViewProps</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;
</code></pre>
<p>그런 다음 PanResponder의 인스턴스를 저장하고 FlatList의 부모 View에 연결하기 위해 ref를 사용하십시오:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">DribbbleShots</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">DribbbleShotsProps</span> &amp; <span class="hljs-title class_">ViewProps</span>&gt; = <span class="hljs-function">() =&gt;</span> {
  ...

  <span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
    <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
      <span class="hljs-attr">onMoveShouldSetPanResponder</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-literal">true</span>,
      <span class="hljs-attr">onPanResponderMove</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gestureState.<span class="hljs-property">dy</span>);
      },
    })
  );

  <span class="hljs-keyword">return</span> (
    &lt;View
      style={styles.root}
      {...panResponderRef.current.panHandlers}
    &gt;
      &lt;Animated.FlatList
        ...
</code></pre>
<p>이 코드를 자세히 살펴보고 각 부분이 하는 일을 이해해보겠습니다:</p>
<p>PanResponder.create()
이 함수 호출은 PanResponder 인스턴스를 만들며 터치 동작에 대한 앱의 응답 방법을 설명하는 객체를 받습니다. 그리고 PanResponder는 React Ref에 저장됩니다.</p>
<p>onMoveShouldSetPanResponder: () =` true,
터치 동작 중 움직임이 있을 때 호출되는 함수입니다. 여기서 true를 반환하면 사용자가 손가락을 움직일 때 Pan Responder가 계속해서 동작을 처리합니다.</p>
<p>onPanResponderMove: (event, gestureState) =` &#x27; ... &#x27;
응답해야 할 제스처가 있으면, 이 함수는 제스처 동작 중 움직임이 발생할 때 실행됩니다.</p>
<p>gestureState는 현재 제스처에 대한 다양한 데이터를 포함하는 객체로, 터치의 위치, 전체 움직임 등을 나타냅니다. 우리는 gestureState.dy에만 관심이 있으며, 이 값은 제스처 시작부터 Y방향으로 얼마나 움직였는지를 나타냅니다. 사용자가 얼마나 아래로 당겼는지를 추적하는 데 사용할 것입니다.</p>
<p>현재 목록을 스크롤하려고 하면 응답하지 않는 것 같아요. 이것은 우리의 PanResponder가 계속해서 모든 팬 제스처를 캡처하기 때문에 발생합니다. 결과적으로 목록은 팬 제스처가 발생했음을 처리할 수 없죠. 일단 괜찮아요, 나중에 이 문제를 해결할 거예요.</p>
<img src="https://miro.medium.com/v2/resize:fit:1280/1*JeG4IxcnUQdpcaBdWBzMnA.gif"/>
<p>이제 이동 값을 갖게 됐으니, 이 값을 활용해봅시다. 새로운 공유 값(shared value)을 생성하고 이동 값을 저장하는데 사용해요. 이 공유 값은 목록을 애니메이션화하는 데 활용할 수 있어요.</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> pullDownPosition = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-number">0</span>);

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    <span class="hljs-attr">onMoveShouldSetPanResponder</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-literal">true</span>,
    <span class="hljs-attr">onPanResponderMove</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =&gt;</span> {
      pullDownPosition.<span class="hljs-property">value</span> = gestureState.<span class="hljs-property">dy</span>;
    },
  })
);

...
</code></pre>
<p>다음 단계는 Reanimated의 useAnimatedStyle 훅을 사용하여 일부 스타일을 생성하고 적용하는 것입니다. 이 훅은 Reanimated에서 제공되며 공유 값이나 다른 반응형 변수에 기반한 동적 스타일을 생성할 수 있게 해줍니다.</p>
<p>참고: 스타일을 목록 자체가 아닌 목록 부모 View에 적용해야 합니다. 또한 React Native의 View가 아닌 Animated.View를 사용해야 합니다.</p>
<pre><code class="hljs language-js">...
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Animated</span>, {
  useSharedValue,
  useAnimatedScrollHandler,
  useAnimatedStyle,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native-reanimated&#x27;</span>;

...

<span class="hljs-keyword">const</span> pullDownStyles = <span class="hljs-title function_">useAnimatedStyle</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">transform</span>: [
      {
        <span class="hljs-attr">translateY</span>: pullDownPosition.<span class="hljs-property">value</span>,
      },
    ],
  };
});

<span class="hljs-keyword">return</span> (
  &lt;Animated.View
    style={[styles.root, pullDownStyles]}
    {...panResponderRef.current.panHandlers}
  &gt;
    &lt;Animated.FlatList
      data={data}
      ...
</code></pre>
<p>저희 코드를 약간 수정하여 사용자가 목록을 아래로 당길 수는 있지만 상단 경계를 넘어서 올릴 수 없도록 해보겠습니다:</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    ...

    <span class="hljs-attr">onPanResponderMove</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =&gt;</span> {
      pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(gestureState.<span class="hljs-property">dy</span>, <span class="hljs-number">0</span>);
    },
  })
);
...
</code></pre>
<img src="https://miro.medium.com/v2/resize:fit:1400/1*FTJzKVw9pWxBXYxL4Nrf1g.gif"/>
<p>풀다운 애니메이션을 완성하기 위해, 팬 제스처가 해제될 때 pullDownPosition 공유 값을 제로로 재설정해보겠습니다. Reanimated는 공유 값을 애니메이션화할 수 있는 일련의 애니메이션 유틸리티 함수를 제공합니다. 이 경우에는 pullDownPosition 값을 매끄럽게 제로로 애니메이션화하기 위해 withTiming 함수를 사용하겠습니다.</p>
<pre><code class="hljs language-js">...
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Animated</span>, {
  useAnimatedScrollHandler,
  useAnimatedStyle,
  useSharedValue,
  withTiming,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native-reanimated&#x27;</span>;

...

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    ...
    <span class="hljs-attr">onPanResponderRelease</span>: <span class="hljs-function">() =&gt;</span> {
      pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title function_">withTiming</span>(<span class="hljs-number">0</span>, { <span class="hljs-attr">duration</span>: <span class="hljs-number">180</span> });
    },
  })
);
</code></pre>
<p>팬 제스처는 다른 제스처나 작업에 의해 조기에 종료되거나 중단될 수 있습니다. 다양한 상호 작용 시나리오에서 일관된 신뢰할 수 있는 사용자 경험을 보장하기 위해 onPanResponderRelease와 함께 onPanResponderTerminate도 사용합시다:</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> <span class="hljs-title function_">onPanRelease</span> = (<span class="hljs-params"></span>) =&gt; {
  pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title function_">withTiming</span>(<span class="hljs-number">0</span>, { <span class="hljs-attr">duration</span>: <span class="hljs-number">180</span> });
};

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    ...
    <span class="hljs-attr">onPanResponderRelease</span>: onPanRelease,
    <span class="hljs-attr">onPanResponderTerminate</span>: onPanRelease,
  })
);

...
</code></pre>
<img src="https://miro.medium.com/v2/resize:fit:1280/1*9K8kEfhq4VnhQPZoe60Pfw.gif"/>
<h1>단계 3: 목록의 스크롤 동작 복원하기</h1>
<p>간단한 작동하는 풀다운 애니메이션이 있지만, 목록의 정상적인 스크롤 동작이 보존되고 올바르게 작동하는지 확인해야 합니다.</p>
<p>onMoveShouldSetPanResponder로 돌아가서 항상 true를 반환하는 대신 의미있는 것을 반환하도록 하겠습니다. 목록이 맨 위로 스크롤되고 사용자가 목록을 더 아래로 밀어내는 경우에만 풀다운 제스처를 허용할 것입니다. 이는 아래와 같이 해석됩니다:</p>
<pre><code class="hljs language-js">...
<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    <span class="hljs-attr">onMoveShouldSetPanResponder</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =&gt;</span>
      scrollPosition.<span class="hljs-property">value</span> &lt;= <span class="hljs-number">0</span> &amp;&amp; gestureState.<span class="hljs-property">dy</span> &gt;= <span class="hljs-number">0</span>,
    <span class="hljs-attr">onPanResponderMove</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =&gt;</span> {
      pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(gestureState.<span class="hljs-property">dy</span>, <span class="hljs-number">0</span>);
    },
...
</code></pre>
<img src="https://miro.medium.com/v2/resize:fit:1280/1*URAgW2RXvWsWs1YxrTLL6g.gif"/>
<p>잘 했어요! 목록이 이제 제대로 작동하고 풀다운 애니메이션이 의도대로 트리거되어 멋진 일을 해냈어요!</p>
<p>이제 잠시 쉬는 시간이에요. 커피 한 잔을 즐기세요 ☕, 몇 분 휴식을 취한 후에 마지막 단계로 넘어갈게요.</p>
<h1>마지막 단계: 새로고침 트리거하기</h1>
<p>이제 튜토리얼의 가장 중요한 부분에 도달했어요. 여기서는 실제로 새로 고침 동작을 트리거할 수 있도록 로직을 설정하는 방법을 알아볼 거에요. 현재 사용자들은 목록을 아래로 내릴 수 있지만, 제약을 추가하고 언제 새로 고침을 활성화해야 하는지 정의하고 싶어요.</p>
<h2>최대 아래로 당기기 거리 설정</h2>
<p>지금 사용자들은 화면 아래쪽까지 목록을 아래로 끌어 내릴 수 있어요. 이것은 자연스럽지 않고 직관적이지 않게 느껴지죠. 그래서 우리는 아래로 당기는 거리를 최대 150픽셀로 제한할 거에요.</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    ...
    <span class="hljs-attr">onPanResponderMove</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> maxDistance = <span class="hljs-number">150</span>;
      pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(maxDistance, gestureState.<span class="hljs-property">dy</span>), <span class="hljs-number">0</span>);
    },
...
</code></pre>
<h2>새로고침 트리거 지점 결정하기</h2>
<p>사용자가 이 150픽셀 범위의 절반 이상으로 당겼을 때, 새로고침 액션이 트리거될 준비가 된 것으로 간주합니다. 이 지점을 넘어서 제스처를 놓으면 새로고침 액션이 시작됩니다.</p>
<pre><code class="hljs language-js">...
<span class="hljs-keyword">const</span> pullDownPosition = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> isReadyToRefresh = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-literal">false</span>);

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    ...
    <span class="hljs-attr">onPanResponderMove</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> maxDistance = <span class="hljs-number">150</span>;
      pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(maxDistance, gestureState.<span class="hljs-property">dy</span>), <span class="hljs-number">0</span>);

      <span class="hljs-keyword">if</span> (
        pullDownPosition.<span class="hljs-property">value</span> &gt;= maxDistance / <span class="hljs-number">2</span> &amp;&amp;
        isReadyToRefresh.<span class="hljs-property">value</span> === <span class="hljs-literal">false</span>
      ) {
        isReadyToRefresh.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;새로고침할 준비 완료&#x27;</span>);
      }

      <span class="hljs-keyword">if</span> (
        pullDownPosition.<span class="hljs-property">value</span> &lt; maxDistance / <span class="hljs-number">2</span> &amp;&amp;
        isReadyToRefresh.<span class="hljs-property">value</span> === <span class="hljs-literal">true</span>
      ) {
        isReadyToRefresh.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;릴리스 시 새로고침하지 않음&#x27;</span>);
      }
    },
...
</code></pre>
<p>공유 값 isReadyToRefresh는 목록을 충분히 당겼는지 여부를 나타냅니다. 이제는 제스처 릴리스 처리 논리를 업데이트해봅시다:</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> <span class="hljs-title function_">onPanRelease</span> = (<span class="hljs-params"></span>) =&gt; {
  pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title function_">withTiming</span>(isReadyToRefresh.<span class="hljs-property">value</span> ? <span class="hljs-number">75</span> : <span class="hljs-number">0</span>, {
    <span class="hljs-attr">duration</span>: <span class="hljs-number">180</span>,
  });

  <span class="hljs-keyword">if</span> (isReadyToRefresh.<span class="hljs-property">value</span>) {
    isReadyToRefresh.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// 새로고침 실행</span>
  }
};

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    ...
    <span class="hljs-attr">onPanResponderRelease</span>: onPanRelease,
    <span class="hljs-attr">onPanResponderTerminate</span>: onPanRelease,
  })
);
...
</code></pre>
<p>새로고침 작업을 트리거하는 메커니즘이 마련되었으니, 제스처(팬 릴리스)의 끝을 처리해봅시다.</p>
<h2>새로고침 작업 트리거</h2>
<p>사용자의 제스처가 끝나고 새로고침 작업 준비가 완료되면, onRefresh 함수를 호출할 것입니다. 이 함수는 하나의 매개변수를 받습니다. 해당 매개변수는 새로고침 작업이 완료된 후 애니메이션을 재설정할 done 함수입니다.```</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> pullDownPosition = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> isReadyToRefresh = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-literal">false</span>);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">onRefresh</span> = (<span class="hljs-params">done: () =&gt; <span class="hljs-keyword">void</span></span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;새로 고침 중...&#x27;</span>);

  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;새로 고침 완료!&#x27;</span>);
    <span class="hljs-title function_">done</span>();
  }, <span class="hljs-number">7500</span>);
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">onPanRelease</span> = (<span class="hljs-params"></span>) =&gt; {
  pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title function_">withTiming</span>(isReadyToRefresh.<span class="hljs-property">value</span> ? <span class="hljs-number">75</span> : <span class="hljs-number">0</span>, {
    <span class="hljs-attr">duration</span>: <span class="hljs-number">180</span>,
  });

  <span class="hljs-keyword">if</span> (isReadyToRefresh.<span class="hljs-property">value</span>) {
    isReadyToRefresh.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// 애니메이션을 재설정하는 함수</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onRefreshComplete</span> = (<span class="hljs-params"></span>) =&gt; {
      pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title function_">withTiming</span>(<span class="hljs-number">0</span>, { <span class="hljs-attr">duration</span>: <span class="hljs-number">180</span> });
    };

    <span class="hljs-comment">// 새로 고침 작업 실행</span>
    <span class="hljs-title function_">onRefresh</span>(onRefreshComplete);
  }
};

...
</code></pre>
<p><code>onRefresh</code> 함수는 setTimeout을 사용하여 새로 고침 프로세스를 시뮬레이션합니다(실제 데이터 가져오기 프로세스의 가상 대체물로). 데이터가 새로 고쳐지면 애니메이션을 재설정하기 위해 <code>done</code> 콜백이 호출됩니다.</p>
<img src="https://miro.medium.com/v2/resize:fit:1280/1*qtBcIAWfx4fISFDhdmreFw.gif"/>
<h1>애니메이션 구축하기</h1>
<p>이제 useAnimatedStyle 훅을 사용하여 새로 고침 애니메이션을 활성화할 준비가 되었습니다. 몇 가지 애니메이션 컴포넌트로 UI를 개선하면서 시작해 봅시다.</p>
<h2>배경 설정</h2>
<p>먼저, 애니메이션을 위한 배경을 만들겠습니다. 주요 UI를 View로 감싸고 기본 스타일을 적용하세요:</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>
    <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
      <span class="hljs-attr">flex:</span> <span class="hljs-attr">1</span>,
      <span class="hljs-attr">backgroundColor:</span> &#x27;#<span class="hljs-attr">333</span>&#x27;,
    }}
  &gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Animated.View</span>
      <span class="hljs-attr">style</span>=<span class="hljs-string">{[styles.root,</span> <span class="hljs-attr">pullDownStyles</span>]}
      {<span class="hljs-attr">...panResponderRef.current.panHandlers</span>}
    &gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Animated.FlatList</span>
        <span class="hljs-attr">...</span>
      /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Animated.View</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>
);

...
</code></pre>
<p>뷰는 애니메이션을 강조하는 어두운 배경을 제공하는 컨테이너 역할을 합니다.</p>
<h2>새로 고침 아이콘 통합</h2>
<p>다음으로, 회전하는 새로 고침 아이콘을 추가해 봅시다. 이 아이콘을 풀 다운 위치에 따라 확대 및 회전되도록 애니메이션화할 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">DribbbleShots</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">DribbbleShotsProps</span> &amp; <span class="hljs-title class_">ViewProps</span>&gt; = <span class="hljs-function">() =&gt;</span> {
  ...

  <span class="hljs-keyword">const</span> refreshContainerStyles = <span class="hljs-title function_">useAnimatedStyle</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">height</span>: pullDownPosition.<span class="hljs-property">value</span>,
    };
  });

  <span class="hljs-keyword">const</span> refreshIconStyles = <span class="hljs-title function_">useAnimatedStyle</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> scale = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, pullDownPosition.<span class="hljs-property">value</span> / <span class="hljs-number">75</span>));

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">opacity</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, pullDownPosition.<span class="hljs-property">value</span> - <span class="hljs-number">25</span>) / <span class="hljs-number">50</span>,
      <span class="hljs-attr">transform</span>: [
        {
          <span class="hljs-attr">scale</span>: scale,
        },
        {
          <span class="hljs-attr">rotate</span>: <span class="hljs-string">`<span class="hljs-subst">${pullDownPosition.value * <span class="hljs-number">3</span>}</span>deg`</span>,
        },
      ],
    };
  });

  <span class="hljs-keyword">return</span> (
    [styles.<span class="hljs-property">refreshContainer</span>, refreshContainerStyles]}&gt;
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Animated.Image</span>
          <span class="hljs-attr">source</span>=<span class="hljs-string">{refreshIcon}</span>
          <span class="hljs-attr">style</span>=<span class="hljs-string">{[styles.refreshIcon,</span> <span class="hljs-attr">refreshIconStyles</span>]}
        /&gt;</span></span>
      &lt;/<span class="hljs-title class_">Animated</span>.<span class="hljs-property">View</span>&gt;

      ...
    &lt;/<span class="hljs-title class_">View</span>&gt;
  );
};
</code></pre>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*OVJMKGr9f4IJG3Ou7KTUjA.gif" alt="Loading animation"/></p>
<p>이제 &#x27;새로 고침 중...&#x27;이라는 단어를 단순히 기록하는 대신 상태 값을 사용하여 UI를 업데이트하고 새로 고침이 진행 중임을 나타내겠습니다:</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> <span class="hljs-title class_">DribbbleShots</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">DribbbleShotsProps</span> &amp; <span class="hljs-title class_">ViewProps</span>&gt; = <span class="hljs-function">() =&gt;</span> {
  ...

  <span class="hljs-keyword">const</span> pullDownPosition = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> isReadyToRefresh = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [refreshing, setRefreshing] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onRefresh</span> = (<span class="hljs-params">done: () =&gt; <span class="hljs-keyword">void</span></span>) =&gt; {
    <span class="hljs-title function_">setRefreshing</span>(<span class="hljs-literal">true</span>);

    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setRefreshing</span>(<span class="hljs-literal">false</span>);
      <span class="hljs-title function_">done</span>();
    }, <span class="hljs-number">7500</span>);
  };

  ...

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>
      <span class="hljs-attr">pointerEvents</span>=<span class="hljs-string">{refreshing</span> ? &#x27;<span class="hljs-attr">none</span>&#x27; <span class="hljs-attr">:</span> &#x27;<span class="hljs-attr">auto</span>&#x27;}
      <span class="hljs-attr">style</span>=<span class="hljs-string">{</span>
        <span class="hljs-attr">flex:</span> <span class="hljs-attr">1</span>,
        <span class="hljs-attr">backgroundColor:</span> &#x27;#<span class="hljs-attr">333</span>&#x27;,
      }
    &gt;</span>

    ...
</span></code></pre>
<p>데이터가 아직로드 중인 동안 원치 않는 pull-down 제스처를 제어하고 방지하려면 pointerEvents 속성을 추가했습니다.</p>
<pre><code>


## 로고 애니메이션 구현하기

조금 더 재미있게 만들기 위해 애니메이션 로고를 추가해봅시다. 사용한 애니메이션 로고는 원래 Tony Pinkevych가 Dribbble에서 만들었고, 저는 이 데모에 맞게 약간 수정했습니다.

```js
/**
 * 의존성 가져오기
 */

import React from &#x27;react&#x27;;
import { Image } from &#x27;expo-image&#x27;;

...

const DribbbleShots: React.FC&lt;DribbbleShotsProps &amp; ViewProps&gt; = () =&gt; {
  ...

  return (
    &lt;View
      pointerEvents={refreshing ? &#x27;none&#x27; : &#x27;auto&#x27;}
      style={
        flex: 1,
        backgroundColor: &#x27;#333&#x27;,
      }
    &gt;
      &lt;Animated.View style={[styles.refreshContainer, refreshContainerStyles]}&gt;
        {refreshing &amp;&amp; (
          &lt;Image
            source={animatedLogo}
            style={ width: 280, height: &#x27;100%&#x27;, objectFit: &#x27;cover&#x27; }
          /&gt;
        )}

        &lt;Animated.Image
          source={refreshIcon}
          style={[styles.refreshIcon, refreshIconStyles]}
        /&gt;
      &lt;/Animated.View&gt;

    ...
</code></pre>
<p>마지막으로, refreshIconStyles를 업데이트하여 새로 고침 아이콘을 애니메이션 로고로 부드럽게 전환해보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> refreshIconStyles = <span class="hljs-title function_">useAnimatedStyle</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> scale = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, pullDownPosition.<span class="hljs-property">value</span> / <span class="hljs-number">75</span>));

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">opacity</span>: refreshing
      ? <span class="hljs-title function_">withDelay</span>(<span class="hljs-number">100</span>, <span class="hljs-title function_">withTiming</span>(<span class="hljs-number">0</span>, { <span class="hljs-attr">duration</span>: <span class="hljs-number">20</span> }))
      : <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, pullDownPosition.<span class="hljs-property">value</span> - <span class="hljs-number">25</span>) / <span class="hljs-number">50</span>,
    <span class="hljs-attr">transform</span>: [
      {
        <span class="hljs-attr">scaleX</span>: refreshing ? <span class="hljs-title function_">withTiming</span>(<span class="hljs-number">0.15</span>, { <span class="hljs-attr">duration</span>: <span class="hljs-number">120</span> }) : scale,
      },
      {
        <span class="hljs-attr">scaleY</span>: scale,
      },
      {
        <span class="hljs-attr">rotate</span>: <span class="hljs-string">`<span class="hljs-subst">${pullDownPosition.value * <span class="hljs-number">3</span>}</span>deg`</span>,
      },
    ],
    <span class="hljs-attr">backgroundColor</span>: refreshing ? <span class="hljs-string">&#x27;#fff&#x27;</span> : <span class="hljs-string">&#x27;transparent&#x27;</span>,
  };
}, [refreshing]);
</code></pre>
<p>마지막으로, 데이터를 로드하는 동안 스켈레톤 카드를 보여줄 것입니다:</p>
<pre><code class="hljs language-js">...

&lt;<span class="hljs-title class_">Animated</span>.<span class="hljs-property">FlatList</span>
  ...
  renderItem={<span class="hljs-function">(<span class="hljs-params">{ item, index }</span>) =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Card</span>
      <span class="hljs-attr">loading</span>=<span class="hljs-string">{refreshing}</span>
      <span class="hljs-attr">index</span>=<span class="hljs-string">{index}</span>
      <span class="hljs-attr">image</span>=<span class="hljs-string">{item.image}</span>
      <span class="hljs-attr">title</span>=<span class="hljs-string">{item.title}</span>
      <span class="hljs-attr">likes</span>=<span class="hljs-string">{item.likes}</span>
    /&gt;</span></span>
  )}
  onScroll={scrollHandler}
  scrollEventThrottle={<span class="hljs-number">16</span>}
/&gt;
&lt;/<span class="hljs-title class_">Animated</span>.<span class="hljs-property">View</span>&gt;

...
</code></pre>
<p>이러한 마지막 손짓으로, 새로 고침 애니메이션이 기능적이면서 시각적으로 매력적으로 완성되었습니다.```</p>
<h1>활기찬 인상 깊은 애니메이션</h1>
<p>이제 창조의 시간입니다. 여기 창의성을 자극하고 다음 앱을 위한 몇 가지 아이디어를 제공할 인상적인 애니메이션의 선별된 목록이 준비되어 있습니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*KB2KSwJq06LLyzA2_t-h1w.gif" alt="Animation 1"/></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*6L8rnyxjfPF-leE0x3Kigg.gif" alt="Animation 2"/></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*Fb1kzeeAhQVNEf5TTAZlrg.gif" alt="Animated GIF"/></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*YU3TndEWRtBaNcjXf-JZVg.gif" alt="Animated GIF"/></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*sMa1sfIYa6Zsl8Co0bCsEQ.gif" alt="Animated GIF"/></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*N5X0Kbuz7jHxclWzBv-glw.gif" alt="Animated GIF"/></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*pZ8ddY3rFUoVBuTWAhRPTg.gif" alt="image1"/></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*bSPbDYoIz9zz3r2mCftWKw.gif" alt="image2"/></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*utIKDBZ3o_V_-ctf22CBSA.gif" alt="image3"/></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*Ti1YIVYL67ZQHWDXNX8ZzA.gif" alt="image4"/></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*948wumPUB-5spDMTYs0Odg.gif" alt="이미지1"/></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*V4UtSyfCN9DDpl70IxXSHA.gif" alt="이미지2"/></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*GA_UPaFN6krQMhRb3lGiqw.gif" alt="이미지3"/></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*m4aMIvlIMY5WGmyFL8q2gA.gif" alt="이미지4"/></p>
<h1>결론</h1>
<p>우리의 사용자 정의 새로 고침 애니메이션 자습서가 마무리되었습니다! 아마도 이것이 여러분의 프로젝트에 몇 가지 아이디어를 불러일으켰으면 좋겠네요. 다양한 애니메이션을 실험해보고 해당 앱의 사용자 경험을 어떻게 향상시킬 수 있는지 확인해 보는 것을 권장합니다.</p>
<p>기억하세요, 배우는 가장 좋은 방법은 직접 해보는 것이기 때문에 고유한 새로 고침 애니메이션을 만들어보는 것에 도전해 보세요. 즐거운 코딩 되세요!</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기","description":"","date":"2024-05-12 21:21","slug":"2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated","content":"\n\n## 간단한 애니메이션이 앱의 사용자 경험을 얼마나 높일 수 있는지 궁금했던 적이 있나요?\n\n잘 디자인된 애니메이션은 평범한 사용자 상호 작용을 진정으로 기억에 남는 경험으로 변화시킬 수 있습니다.\n\n이 포스트에서는 React Native와 Reanimated 라이브러리를 사용하여 모바일 앱에 맞춘 흥미로운 사용자 정의 '당겨서 새로고침' 애니메이션을 만드는 방법을 배우게 됩니다.\n\n## 그냥 React Native의 RefreshControl을 사용하는 것이 좋지 않을까요?\n\n\n\n리액트 네이티브로 모바일 애플리케이션을 개발할 때, Pull-to-refresh 기능을 구현하는 데 RefreshControl 컴포넌트를 주로 사용합니다.\n\n간단하고 직관적이지만, 꽤 기본적이며 제한된 사용자 정의 기능을 제공합니다. 이로 인해 여러분의 앱이 그저 다른 어떤 앱처럼 보이는 경우가 있을 수 있습니다.\n\n사용자 정의 애니메이션을 생성하면 앱의 모양과 느낌을 자유롭게 조절하여 브랜딩 및 디자인 언어와 완벽하게 일치시킬 수 있습니다. 이로써 앱이 더 독특하고 기억에 남는 사용자 경험을 제공하게 되어 앱이 더욱 독특하고 기억에 남게 만듭니다.\n\n## 왜 Animated가 아닌 Reanimated 라이브러리를 사용해야 하는가?\n\n\n\nReact Native에서 애니메이션에 관한 이야기가 나온다면, 두 가지 주요 라이브러리가 떠오르게 됩니다: 내장된 Animated 라이브러리와 더 고급화된 Reanimated 라이브러리가 있습니다.\n\nReanimated가 선호되는 이유는 몇 가지가 있습니다:\n\n- 성능:\nReanimated는 특히 복잡한 애니메이션에 대해 우수한 성능을 제공합니다. 네이티브 스레드를 활용하여 JavaScript 스레드 대신 작동함으로써 더 효율적으로 작동합니다. 이는 훨씬 부드러운 애니메이션을 가능하게 하며, 이는 원활한 사용자 경험을 위한 중요한 요소입니다.\n- 제스처 기반 애니메이션:\nReanimated는 더 복잡한 애니메이션 처리를 위한 더 나은 API를 제공하며, 제스처와 애니메이션의 더 섬세한 제어와 더 부드러운 통합을 가능케 합니다.\n- 선언적 접근: Animated와 달리, Reanimated는 애니메이션에 더 선언적인 접근 방식을 채용합니다. 이는 애니메이션이 더 복잡해지면서 이해하고 관리하기 쉬워집니다.\n\n# 시작하기\n\n\n\n이 튜토리얼에서는 간단한 앱을 향상시키고자 합니다. 이 앱은 FlatList에서 카드 형태로 표시되는 Dribbble 샷 목록을 보여줍니다. 우리의 목표는 사용자가 목록을 위로 당겼을 때 나타나는 사용자 정의 새로 고침 애니메이션을 추가하는 것입니다.\n\n## 프로젝트 복제 및 설정\n\n로컬 컴퓨터에서 저장소를 클론하고 프로젝트를 설정하기 위해 다음 단계를 따라주세요:\n\n저장소 복제:\n터미널을 열고 다음 명령어로 저장소를 클론하세요:\n\n\n\n```js\ngit clone https://github.com/teefouad/custom-rn-refresh-animation-start.git\n```\n\nVSCode에서 프로젝트 열기:\n이 강좌의 모든 코드는 app/index.tsx에 들어가기 때문에 해당 파일을 열어 다른 파일과 디렉터리를 무시할 수 있습니다.\n다음과 같은 내용이 표시됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png\" /\u003e\n\n의존성 설치:\n필요한 종속 항목을 설치하려면 npm install 또는 yarn을 실행하세요.```\n\n\n\n프로젝트 실행하기:\nnpm start 또는 yarn start를 실행하여 프로젝트를 시작하세요. 이렇게 하면 Metro 번들러가 초기화되고 앱이 개발 모드로 실행됩니다.\n\n프로젝트가 설정되었으므로, 이제 우리는 흥미로운 부분으로 빠져들 준비가 되었습니다: 우리의 사용자 정의 새로고침 애니메이션 만들기!\n\n# 애니메이션 만들기: 상단 스크롤 감지\n\n사용자 정의 애니메이션을 만드는 첫 번째 단계는 FlatList가 맨 위로 스크롤되었을 때 감지하는 것입니다.\n\n\n\n이를 위해 Reanimated에서 useAnimatedScrollHandler를 사용할 것입니다. 이 훅은 최적화되고 성능이 좋은 방식으로 스크롤 이벤트를 처리할 수 있는 함수를 제공할 것입니다.\n\n1. 먼저, Reanimated에서 훅을 import 해야 합니다:\n\n```js\n/**\n * Dependency imports\n */\n\n import React from 'react';\n import { FlatList, StyleSheet, View, ViewProps } from 'react-native';\n import Animated, { useAnimatedScrollHandler } from 'react-native-reanimated';\n```\n\n2. useAnimatedScrollHandler를 사용하여 스크롤 핸들러를 생성하세요:\n\n\n\n```js\nconst DribbbleShots: React.FC\u003cDribbbleShotsProps \u0026 ViewProps\u003e = () =\u003e {\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) =\u003e {\n      console.log(event.contentOffset.y);\n    },\n  });\n\n  return (\n    ...\n```\n\n지금은 리스트 스크롤 위치를 기록하는 것으로 할게요.\n\n3. 리스트에 스크롤 핸들러를 연결해보세요. useAnimatedScrollHandler를 사용하여 만든 스크롤 이벤트 핸들러는 React Native의 FlatList와 호환되지 않을 것이므로 Reanimated에서 제공하는 FlatList로 대체해야 합니다.\n\n```js\nreturn (\n    \u003cView style={styles.root}\u003e\n      \u003cAnimated.FlatList\n        ...\n        onScroll={scrollHandler}\n        scrollEventThrottle={16} // 부드러운 성능을 위한 좋은 방법\n      /\u003e\n    \u003c/View\u003e\n);\n```\n\n\n\nscrollEventThrottle 속성은 스크롤 이벤트가 발생하는 빈도를 제어합니다. 여기서 값이 16이면 스크롤 이벤트를 대략 16밀리초마다 캡처합니다. 이렇게 하면 애니메이션이 부드럽고 반응이 빠릅니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1280/1*6cGVuwIPgf4QnLIC79xN7g.gif)\n\n이제 콘솔에 스크롤 위치를 단순히 기록하는 대신, 이를 공유 값에 저장합시다.\n\n다음과 같이 코드를 업데이트하세요:\n\n\n\n```js\nimport Animated, {\n  useAnimatedScrollHandler,\n  useSharedValue,\n} from 'react-native-reanimated';\n\n...\n\nconst DribbbleShots: React.FC\u003cDribbbleShotsProps \u0026 ViewProps\u003e = () =\u003e {\n  const scrollPosition = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) =\u003e {\n      scrollPosition.value = event.contentOffset.y;\n    },\n  });\n  ...\n```\n\n# 단계 2: 팬 제스처 캡처하기\n\n이제 목록이 화면 상단까지 스크롤된 것을 감지할 수 있게 되었으므로, 다음 단계는 사용자가 목록을 더 아래로 끌 때 팬 제스처를 캡처하는 것입니다. 이를 달성하기 위해 FlatList의 부모 View에 PanResponder를 사용할 것입니다.\n\n팬 응답자(pan responder)를 생성하기 위해 React Native에서 PanResponder를 가져오세요:```\n\n\n\n```js\nimport {\n  PanResponder,\n  StyleSheet,\n  View,\n  ViewProps,\n} from 'react-native';\n```\n\n그런 다음 PanResponder의 인스턴스를 저장하고 FlatList의 부모 View에 연결하기 위해 ref를 사용하십시오:\n\n```js\nconst DribbbleShots: React.FC\u003cDribbbleShotsProps \u0026 ViewProps\u003e = () =\u003e {\n  ...\n\n  const panResponderRef = React.useRef(\n    PanResponder.create({\n      onMoveShouldSetPanResponder: () =\u003e true,\n      onPanResponderMove: (event, gestureState) =\u003e {\n        console.log(gestureState.dy);\n      },\n    })\n  );\n\n  return (\n    \u003cView\n      style={styles.root}\n      {...panResponderRef.current.panHandlers}\n    \u003e\n      \u003cAnimated.FlatList\n        ...\n```\n\n이 코드를 자세히 살펴보고 각 부분이 하는 일을 이해해보겠습니다:\n\n\n\nPanResponder.create()\n이 함수 호출은 PanResponder 인스턴스를 만들며 터치 동작에 대한 앱의 응답 방법을 설명하는 객체를 받습니다. 그리고 PanResponder는 React Ref에 저장됩니다.\n\nonMoveShouldSetPanResponder: () =` true,\n터치 동작 중 움직임이 있을 때 호출되는 함수입니다. 여기서 true를 반환하면 사용자가 손가락을 움직일 때 Pan Responder가 계속해서 동작을 처리합니다.\n\nonPanResponderMove: (event, gestureState) =` ' ... '\n응답해야 할 제스처가 있으면, 이 함수는 제스처 동작 중 움직임이 발생할 때 실행됩니다.\n\ngestureState는 현재 제스처에 대한 다양한 데이터를 포함하는 객체로, 터치의 위치, 전체 움직임 등을 나타냅니다. 우리는 gestureState.dy에만 관심이 있으며, 이 값은 제스처 시작부터 Y방향으로 얼마나 움직였는지를 나타냅니다. 사용자가 얼마나 아래로 당겼는지를 추적하는 데 사용할 것입니다.\n\n\n\n현재 목록을 스크롤하려고 하면 응답하지 않는 것 같아요. 이것은 우리의 PanResponder가 계속해서 모든 팬 제스처를 캡처하기 때문에 발생합니다. 결과적으로 목록은 팬 제스처가 발생했음을 처리할 수 없죠. 일단 괜찮아요, 나중에 이 문제를 해결할 거예요.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*JeG4IxcnUQdpcaBdWBzMnA.gif\" /\u003e\n\n이제 이동 값을 갖게 됐으니, 이 값을 활용해봅시다. 새로운 공유 값(shared value)을 생성하고 이동 값을 저장하는데 사용해요. 이 공유 값은 목록을 애니메이션화하는 데 활용할 수 있어요.\n\n```js\n...\n\nconst pullDownPosition = useSharedValue(0);\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    onMoveShouldSetPanResponder: () =\u003e true,\n    onPanResponderMove: (event, gestureState) =\u003e {\n      pullDownPosition.value = gestureState.dy;\n    },\n  })\n);\n\n...\n```\n\n\n\n다음 단계는 Reanimated의 useAnimatedStyle 훅을 사용하여 일부 스타일을 생성하고 적용하는 것입니다. 이 훅은 Reanimated에서 제공되며 공유 값이나 다른 반응형 변수에 기반한 동적 스타일을 생성할 수 있게 해줍니다.\n\n참고: 스타일을 목록 자체가 아닌 목록 부모 View에 적용해야 합니다. 또한 React Native의 View가 아닌 Animated.View를 사용해야 합니다.\n\n```js\n...\nimport Animated, {\n  useSharedValue,\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n} from 'react-native-reanimated';\n\n...\n\nconst pullDownStyles = useAnimatedStyle(() =\u003e {\n  return {\n    transform: [\n      {\n        translateY: pullDownPosition.value,\n      },\n    ],\n  };\n});\n\nreturn (\n  \u003cAnimated.View\n    style={[styles.root, pullDownStyles]}\n    {...panResponderRef.current.panHandlers}\n  \u003e\n    \u003cAnimated.FlatList\n      data={data}\n      ...\n```\n\n\n\n저희 코드를 약간 수정하여 사용자가 목록을 아래로 당길 수는 있지만 상단 경계를 넘어서 올릴 수 없도록 해보겠습니다:\n\n```js\n...\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n\n    onPanResponderMove: (event, gestureState) =\u003e {\n      pullDownPosition.value = Math.max(gestureState.dy, 0);\n    },\n  })\n);\n...\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*FTJzKVw9pWxBXYxL4Nrf1g.gif\" /\u003e\n\n풀다운 애니메이션을 완성하기 위해, 팬 제스처가 해제될 때 pullDownPosition 공유 값을 제로로 재설정해보겠습니다. Reanimated는 공유 값을 애니메이션화할 수 있는 일련의 애니메이션 유틸리티 함수를 제공합니다. 이 경우에는 pullDownPosition 값을 매끄럽게 제로로 애니메이션화하기 위해 withTiming 함수를 사용하겠습니다.\n\n\n\n```js\n...\nimport Animated, {\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n  useSharedValue,\n  withTiming,\n} from 'react-native-reanimated';\n\n...\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderRelease: () =\u003e {\n      pullDownPosition.value = withTiming(0, { duration: 180 });\n    },\n  })\n);\n```\n\n팬 제스처는 다른 제스처나 작업에 의해 조기에 종료되거나 중단될 수 있습니다. 다양한 상호 작용 시나리오에서 일관된 신뢰할 수 있는 사용자 경험을 보장하기 위해 onPanResponderRelease와 함께 onPanResponderTerminate도 사용합시다:\n\n```js\n...\n\nconst onPanRelease = () =\u003e {\n  pullDownPosition.value = withTiming(0, { duration: 180 });\n};\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderRelease: onPanRelease,\n    onPanResponderTerminate: onPanRelease,\n  })\n);\n\n...\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*9K8kEfhq4VnhQPZoe60Pfw.gif\" /\u003e\n\n\n\n# 단계 3: 목록의 스크롤 동작 복원하기\n\n간단한 작동하는 풀다운 애니메이션이 있지만, 목록의 정상적인 스크롤 동작이 보존되고 올바르게 작동하는지 확인해야 합니다.\n\nonMoveShouldSetPanResponder로 돌아가서 항상 true를 반환하는 대신 의미있는 것을 반환하도록 하겠습니다. 목록이 맨 위로 스크롤되고 사용자가 목록을 더 아래로 밀어내는 경우에만 풀다운 제스처를 허용할 것입니다. 이는 아래와 같이 해석됩니다:\n\n```js\n...\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    onMoveShouldSetPanResponder: (event, gestureState) =\u003e\n      scrollPosition.value \u003c= 0 \u0026\u0026 gestureState.dy \u003e= 0,\n    onPanResponderMove: (event, gestureState) =\u003e {\n      pullDownPosition.value = Math.max(gestureState.dy, 0);\n    },\n...\n``` \n\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*URAgW2RXvWsWs1YxrTLL6g.gif\" /\u003e\n\n잘 했어요! 목록이 이제 제대로 작동하고 풀다운 애니메이션이 의도대로 트리거되어 멋진 일을 해냈어요!\n\n이제 잠시 쉬는 시간이에요. 커피 한 잔을 즐기세요 ☕, 몇 분 휴식을 취한 후에 마지막 단계로 넘어갈게요.\n\n# 마지막 단계: 새로고침 트리거하기\n\n\n\n이제 튜토리얼의 가장 중요한 부분에 도달했어요. 여기서는 실제로 새로 고침 동작을 트리거할 수 있도록 로직을 설정하는 방법을 알아볼 거에요. 현재 사용자들은 목록을 아래로 내릴 수 있지만, 제약을 추가하고 언제 새로 고침을 활성화해야 하는지 정의하고 싶어요.\n\n## 최대 아래로 당기기 거리 설정\n\n지금 사용자들은 화면 아래쪽까지 목록을 아래로 끌어 내릴 수 있어요. 이것은 자연스럽지 않고 직관적이지 않게 느껴지죠. 그래서 우리는 아래로 당기는 거리를 최대 150픽셀로 제한할 거에요.\n\n```js\n...\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderMove: (event, gestureState) =\u003e {\n      const maxDistance = 150;\n      pullDownPosition.value = Math.max(Math.min(maxDistance, gestureState.dy), 0);\n    },\n...\n```\n\n\n\n## 새로고침 트리거 지점 결정하기\n\n사용자가 이 150픽셀 범위의 절반 이상으로 당겼을 때, 새로고침 액션이 트리거될 준비가 된 것으로 간주합니다. 이 지점을 넘어서 제스처를 놓으면 새로고침 액션이 시작됩니다.\n\n```js\n...\nconst pullDownPosition = useSharedValue(0);\nconst isReadyToRefresh = useSharedValue(false);\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderMove: (event, gestureState) =\u003e {\n      const maxDistance = 150;\n      pullDownPosition.value = Math.max(Math.min(maxDistance, gestureState.dy), 0);\n\n      if (\n        pullDownPosition.value \u003e= maxDistance / 2 \u0026\u0026\n        isReadyToRefresh.value === false\n      ) {\n        isReadyToRefresh.value = true;\n        console.log('새로고침할 준비 완료');\n      }\n\n      if (\n        pullDownPosition.value \u003c maxDistance / 2 \u0026\u0026\n        isReadyToRefresh.value === true\n      ) {\n        isReadyToRefresh.value = false;\n        console.log('릴리스 시 새로고침하지 않음');\n      }\n    },\n...\n```\n\n공유 값 isReadyToRefresh는 목록을 충분히 당겼는지 여부를 나타냅니다. 이제는 제스처 릴리스 처리 논리를 업데이트해봅시다:\n\n\n\n```js\n...\n\nconst onPanRelease = () =\u003e {\n  pullDownPosition.value = withTiming(isReadyToRefresh.value ? 75 : 0, {\n    duration: 180,\n  });\n\n  if (isReadyToRefresh.value) {\n    isReadyToRefresh.value = false;\n\n    // 새로고침 실행\n  }\n};\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderRelease: onPanRelease,\n    onPanResponderTerminate: onPanRelease,\n  })\n);\n...\n```\n\n새로고침 작업을 트리거하는 메커니즘이 마련되었으니, 제스처(팬 릴리스)의 끝을 처리해봅시다.\n\n## 새로고침 작업 트리거\n\n사용자의 제스처가 끝나고 새로고침 작업 준비가 완료되면, onRefresh 함수를 호출할 것입니다. 이 함수는 하나의 매개변수를 받습니다. 해당 매개변수는 새로고침 작업이 완료된 후 애니메이션을 재설정할 done 함수입니다.```\n\n\n\n```js\n...\n\nconst pullDownPosition = useSharedValue(0);\nconst isReadyToRefresh = useSharedValue(false);\n\nconst onRefresh = (done: () =\u003e void) =\u003e {\n  console.log('새로 고침 중...');\n\n  setTimeout(() =\u003e {\n    console.log('새로 고침 완료!');\n    done();\n  }, 7500);\n};\n\nconst onPanRelease = () =\u003e {\n  pullDownPosition.value = withTiming(isReadyToRefresh.value ? 75 : 0, {\n    duration: 180,\n  });\n\n  if (isReadyToRefresh.value) {\n    isReadyToRefresh.value = false;\n\n    // 애니메이션을 재설정하는 함수\n    const onRefreshComplete = () =\u003e {\n      pullDownPosition.value = withTiming(0, { duration: 180 });\n    };\n\n    // 새로 고침 작업 실행\n    onRefresh(onRefreshComplete);\n  }\n};\n\n...\n```\n\n`onRefresh` 함수는 setTimeout을 사용하여 새로 고침 프로세스를 시뮬레이션합니다(실제 데이터 가져오기 프로세스의 가상 대체물로). 데이터가 새로 고쳐지면 애니메이션을 재설정하기 위해 `done` 콜백이 호출됩니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*qtBcIAWfx4fISFDhdmreFw.gif\" /\u003e\n\n# 애니메이션 구축하기\n\n\n\n이제 useAnimatedStyle 훅을 사용하여 새로 고침 애니메이션을 활성화할 준비가 되었습니다. 몇 가지 애니메이션 컴포넌트로 UI를 개선하면서 시작해 봅시다.\n\n## 배경 설정\n\n먼저, 애니메이션을 위한 배경을 만들겠습니다. 주요 UI를 View로 감싸고 기본 스타일을 적용하세요:\n\n```js\n...\n\nreturn (\n  \u003cView\n    style={{\n      flex: 1,\n      backgroundColor: '#333',\n    }}\n  \u003e\n    \u003cAnimated.View\n      style={[styles.root, pullDownStyles]}\n      {...panResponderRef.current.panHandlers}\n    \u003e\n      \u003cAnimated.FlatList\n        ...\n      /\u003e\n    \u003c/Animated.View\u003e\n  \u003c/View\u003e\n);\n\n...\n```\n\n\n\n뷰는 애니메이션을 강조하는 어두운 배경을 제공하는 컨테이너 역할을 합니다.\n\n## 새로 고침 아이콘 통합\n\n다음으로, 회전하는 새로 고침 아이콘을 추가해 봅시다. 이 아이콘을 풀 다운 위치에 따라 확대 및 회전되도록 애니메이션화할 것입니다:\n\n```js\nconst DribbbleShots: React.FC\u003cDribbbleShotsProps \u0026 ViewProps\u003e = () =\u003e {\n  ...\n\n  const refreshContainerStyles = useAnimatedStyle(() =\u003e {\n    return {\n      height: pullDownPosition.value,\n    };\n  });\n\n  const refreshIconStyles = useAnimatedStyle(() =\u003e {\n    const scale = Math.min(1, Math.max(0, pullDownPosition.value / 75));\n\n    return {\n      opacity: Math.max(0, pullDownPosition.value - 25) / 50,\n      transform: [\n        {\n          scale: scale,\n        },\n        {\n          rotate: `${pullDownPosition.value * 3}deg`,\n        },\n      ],\n    };\n  });\n\n  return (\n    [styles.refreshContainer, refreshContainerStyles]}\u003e\n        \u003cAnimated.Image\n          source={refreshIcon}\n          style={[styles.refreshIcon, refreshIconStyles]}\n        /\u003e\n      \u003c/Animated.View\u003e\n\n      ...\n    \u003c/View\u003e\n  );\n};\n```\n\n\n\n\n![Loading animation](https://miro.medium.com/v2/resize:fit:1400/1*OVJMKGr9f4IJG3Ou7KTUjA.gif)\n\n이제 '새로 고침 중...'이라는 단어를 단순히 기록하는 대신 상태 값을 사용하여 UI를 업데이트하고 새로 고침이 진행 중임을 나타내겠습니다:\n\n```js\n...\n\nconst DribbbleShots: React.FC\u003cDribbbleShotsProps \u0026 ViewProps\u003e = () =\u003e {\n  ...\n\n  const pullDownPosition = useSharedValue(0);\n  const isReadyToRefresh = useSharedValue(false);\n  const [refreshing, setRefreshing] = React.useState(false);\n\n  const onRefresh = (done: () =\u003e void) =\u003e {\n    setRefreshing(true);\n\n    setTimeout(() =\u003e {\n      setRefreshing(false);\n      done();\n    }, 7500);\n  };\n\n  ...\n\n  return (\n    \u003cView\n      pointerEvents={refreshing ? 'none' : 'auto'}\n      style={\n        flex: 1,\n        backgroundColor: '#333',\n      }\n    \u003e\n\n    ...\n```\n\n데이터가 아직로드 중인 동안 원치 않는 pull-down 제스처를 제어하고 방지하려면 pointerEvents 속성을 추가했습니다.\n```  \n\n\n\n## 로고 애니메이션 구현하기\n\n조금 더 재미있게 만들기 위해 애니메이션 로고를 추가해봅시다. 사용한 애니메이션 로고는 원래 Tony Pinkevych가 Dribbble에서 만들었고, 저는 이 데모에 맞게 약간 수정했습니다.\n\n```js\n/**\n * 의존성 가져오기\n */\n\nimport React from 'react';\nimport { Image } from 'expo-image';\n\n...\n\nconst DribbbleShots: React.FC\u003cDribbbleShotsProps \u0026 ViewProps\u003e = () =\u003e {\n  ...\n\n  return (\n    \u003cView\n      pointerEvents={refreshing ? 'none' : 'auto'}\n      style={\n        flex: 1,\n        backgroundColor: '#333',\n      }\n    \u003e\n      \u003cAnimated.View style={[styles.refreshContainer, refreshContainerStyles]}\u003e\n        {refreshing \u0026\u0026 (\n          \u003cImage\n            source={animatedLogo}\n            style={ width: 280, height: '100%', objectFit: 'cover' }\n          /\u003e\n        )}\n\n        \u003cAnimated.Image\n          source={refreshIcon}\n          style={[styles.refreshIcon, refreshIconStyles]}\n        /\u003e\n      \u003c/Animated.View\u003e\n\n    ...\n```\n\n마지막으로, refreshIconStyles를 업데이트하여 새로 고침 아이콘을 애니메이션 로고로 부드럽게 전환해보겠습니다.\n\n\n\n```js\nconst refreshIconStyles = useAnimatedStyle(() =\u003e {\n  const scale = Math.min(1, Math.max(0, pullDownPosition.value / 75));\n\n  return {\n    opacity: refreshing\n      ? withDelay(100, withTiming(0, { duration: 20 }))\n      : Math.max(0, pullDownPosition.value - 25) / 50,\n    transform: [\n      {\n        scaleX: refreshing ? withTiming(0.15, { duration: 120 }) : scale,\n      },\n      {\n        scaleY: scale,\n      },\n      {\n        rotate: `${pullDownPosition.value * 3}deg`,\n      },\n    ],\n    backgroundColor: refreshing ? '#fff' : 'transparent',\n  };\n}, [refreshing]);\n```\n\n마지막으로, 데이터를 로드하는 동안 스켈레톤 카드를 보여줄 것입니다:\n\n```js\n...\n\n\u003cAnimated.FlatList\n  ...\n  renderItem={({ item, index }) =\u003e (\n    \u003cCard\n      loading={refreshing}\n      index={index}\n      image={item.image}\n      title={item.title}\n      likes={item.likes}\n    /\u003e\n  )}\n  onScroll={scrollHandler}\n  scrollEventThrottle={16}\n/\u003e\n\u003c/Animated.View\u003e\n\n...\n```\n\n이러한 마지막 손짓으로, 새로 고침 애니메이션이 기능적이면서 시각적으로 매력적으로 완성되었습니다.```\n\n\n\n# 활기찬 인상 깊은 애니메이션\n\n이제 창조의 시간입니다. 여기 창의성을 자극하고 다음 앱을 위한 몇 가지 아이디어를 제공할 인상적인 애니메이션의 선별된 목록이 준비되어 있습니다.\n\n![Animation 1](https://miro.medium.com/v2/resize:fit:1400/1*KB2KSwJq06LLyzA2_t-h1w.gif)\n\n![Animation 2](https://miro.medium.com/v2/resize:fit:1400/1*6L8rnyxjfPF-leE0x3Kigg.gif)\n\n\n\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*Fb1kzeeAhQVNEf5TTAZlrg.gif)\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*YU3TndEWRtBaNcjXf-JZVg.gif)\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*sMa1sfIYa6Zsl8Co0bCsEQ.gif)\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*N5X0Kbuz7jHxclWzBv-glw.gif)\n\n\n\n![image1](https://miro.medium.com/v2/resize:fit:1400/1*pZ8ddY3rFUoVBuTWAhRPTg.gif)\n\n![image2](https://miro.medium.com/v2/resize:fit:1400/1*bSPbDYoIz9zz3r2mCftWKw.gif)\n\n![image3](https://miro.medium.com/v2/resize:fit:1400/1*utIKDBZ3o_V_-ctf22CBSA.gif)\n\n![image4](https://miro.medium.com/v2/resize:fit:1400/1*Ti1YIVYL67ZQHWDXNX8ZzA.gif)\n\n\n\n![이미지1](https://miro.medium.com/v2/resize:fit:1400/1*948wumPUB-5spDMTYs0Odg.gif)\n\n![이미지2](https://miro.medium.com/v2/resize:fit:1400/1*V4UtSyfCN9DDpl70IxXSHA.gif)\n\n![이미지3](https://miro.medium.com/v2/resize:fit:1400/1*GA_UPaFN6krQMhRb3lGiqw.gif)\n\n![이미지4](https://miro.medium.com/v2/resize:fit:1400/1*m4aMIvlIMY5WGmyFL8q2gA.gif)\n\n\n\n# 결론\n\n우리의 사용자 정의 새로 고침 애니메이션 자습서가 마무리되었습니다! 아마도 이것이 여러분의 프로젝트에 몇 가지 아이디어를 불러일으켰으면 좋겠네요. 다양한 애니메이션을 실험해보고 해당 앱의 사용자 경험을 어떻게 향상시킬 수 있는지 확인해 보는 것을 권장합니다.\n\n기억하세요, 배우는 가장 좋은 방법은 직접 해보는 것이기 때문에 고유한 새로 고침 애니메이션을 만들어보는 것에 도전해 보세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png","tag":["Tech"],"readingTime":18},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ol: \"ol\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"간단한 애니메이션이 앱의 사용자 경험을 얼마나 높일 수 있는지 궁금했던 적이 있나요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"잘 디자인된 애니메이션은 평범한 사용자 상호 작용을 진정으로 기억에 남는 경험으로 변화시킬 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 포스트에서는 React Native와 Reanimated 라이브러리를 사용하여 모바일 앱에 맞춘 흥미로운 사용자 정의 '당겨서 새로고침' 애니메이션을 만드는 방법을 배우게 됩니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"그냥 React Native의 RefreshControl을 사용하는 것이 좋지 않을까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"리액트 네이티브로 모바일 애플리케이션을 개발할 때, Pull-to-refresh 기능을 구현하는 데 RefreshControl 컴포넌트를 주로 사용합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"간단하고 직관적이지만, 꽤 기본적이며 제한된 사용자 정의 기능을 제공합니다. 이로 인해 여러분의 앱이 그저 다른 어떤 앱처럼 보이는 경우가 있을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자 정의 애니메이션을 생성하면 앱의 모양과 느낌을 자유롭게 조절하여 브랜딩 및 디자인 언어와 완벽하게 일치시킬 수 있습니다. 이로써 앱이 더 독특하고 기억에 남는 사용자 경험을 제공하게 되어 앱이 더욱 독특하고 기억에 남게 만듭니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"왜 Animated가 아닌 Reanimated 라이브러리를 사용해야 하는가?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React Native에서 애니메이션에 관한 이야기가 나온다면, 두 가지 주요 라이브러리가 떠오르게 됩니다: 내장된 Animated 라이브러리와 더 고급화된 Reanimated 라이브러리가 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Reanimated가 선호되는 이유는 몇 가지가 있습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"성능:\\nReanimated는 특히 복잡한 애니메이션에 대해 우수한 성능을 제공합니다. 네이티브 스레드를 활용하여 JavaScript 스레드 대신 작동함으로써 더 효율적으로 작동합니다. 이는 훨씬 부드러운 애니메이션을 가능하게 하며, 이는 원활한 사용자 경험을 위한 중요한 요소입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"제스처 기반 애니메이션:\\nReanimated는 더 복잡한 애니메이션 처리를 위한 더 나은 API를 제공하며, 제스처와 애니메이션의 더 섬세한 제어와 더 부드러운 통합을 가능케 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"선언적 접근: Animated와 달리, Reanimated는 애니메이션에 더 선언적인 접근 방식을 채용합니다. 이는 애니메이션이 더 복잡해지면서 이해하고 관리하기 쉬워집니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"시작하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 튜토리얼에서는 간단한 앱을 향상시키고자 합니다. 이 앱은 FlatList에서 카드 형태로 표시되는 Dribbble 샷 목록을 보여줍니다. 우리의 목표는 사용자가 목록을 위로 당겼을 때 나타나는 사용자 정의 새로 고침 애니메이션을 추가하는 것입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"프로젝트 복제 및 설정\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"로컬 컴퓨터에서 저장소를 클론하고 프로젝트를 설정하기 위해 다음 단계를 따라주세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저장소 복제:\\n터미널을 열고 다음 명령어로 저장소를 클론하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"git clone \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"https\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//github.com/teefouad/custom-rn-refresh-animation-start.git\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"VSCode에서 프로젝트 열기:\\n이 강좌의 모든 코드는 app/index.tsx에 들어가기 때문에 해당 파일을 열어 다른 파일과 디렉터리를 무시할 수 있습니다.\\n다음과 같은 내용이 표시됩니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"의존성 설치:\\n필요한 종속 항목을 설치하려면 npm install 또는 yarn을 실행하세요.```\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트 실행하기:\\nnpm start 또는 yarn start를 실행하여 프로젝트를 시작하세요. 이렇게 하면 Metro 번들러가 초기화되고 앱이 개발 모드로 실행됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트가 설정되었으므로, 이제 우리는 흥미로운 부분으로 빠져들 준비가 되었습니다: 우리의 사용자 정의 새로고침 애니메이션 만들기!\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"애니메이션 만들기: 상단 스크롤 감지\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자 정의 애니메이션을 만드는 첫 번째 단계는 FlatList가 맨 위로 스크롤되었을 때 감지하는 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이를 위해 Reanimated에서 useAnimatedScrollHandler를 사용할 것입니다. 이 훅은 최적화되고 성능이 좋은 방식으로 스크롤 이벤트를 처리할 수 있는 함수를 제공할 것입니다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"먼저, Reanimated에서 훅을 import 해야 합니다:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/**\\n * Dependency imports\\n */\"\n        }), \"\\n\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react'\"\n        }), \";\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"FlatList\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"StyleSheet\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"View\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ViewProps\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react-native'\"\n        }), \";\\n \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animated\"\n        }), \", { useAnimatedScrollHandler } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react-native-reanimated'\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"useAnimatedScrollHandler를 사용하여 스크롤 핸들러를 생성하세요:\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DribbbleShots\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"FC\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DribbbleShotsProps\"\n        }), \" \u0026 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ViewProps\"\n        }), \"\u003e = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" scrollHandler = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useAnimatedScrollHandler\"\n        }), \"({\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onScroll\"\n        }), \": \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"event\"\n          }), \") =\u003e\"]\n        }), \" {\\n      \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(event.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"contentOffset\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"y\"\n        }), \");\\n    },\\n  });\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    ...\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금은 리스트 스크롤 위치를 기록하는 것으로 할게요.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"리스트에 스크롤 핸들러를 연결해보세요. useAnimatedScrollHandler를 사용하여 만든 스크롤 이벤트 핸들러는 React Native의 FlatList와 호환되지 않을 것이므로 Reanimated에서 제공하는 FlatList로 대체해야 합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"View\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"style\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{styles.root}\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Animated.FlatList\"\n            }), \"\\n        \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"...\"\n            }), \"\\n        \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onScroll\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{scrollHandler}\"\n            }), \"\\n        \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"scrollEventThrottle\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{16}\"\n            }), \" // \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"부드러운\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"성능을\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"위한\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"좋은\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"방법\"\n            }), \"\\n      /\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"View\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"scrollEventThrottle 속성은 스크롤 이벤트가 발생하는 빈도를 제어합니다. 여기서 값이 16이면 스크롤 이벤트를 대략 16밀리초마다 캡처합니다. 이렇게 하면 애니메이션이 부드럽고 반응이 빠릅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1280/1*6cGVuwIPgf4QnLIC79xN7g.gif\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 콘솔에 스크롤 위치를 단순히 기록하는 대신, 이를 공유 값에 저장합시다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음과 같이 코드를 업데이트하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animated\"\n        }), \", {\\n  useAnimatedScrollHandler,\\n  useSharedValue,\\n} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react-native-reanimated'\"\n        }), \";\\n\\n...\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DribbbleShots\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"FC\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DribbbleShotsProps\"\n        }), \" \u0026 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ViewProps\"\n        }), \"\u003e = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" scrollPosition = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useSharedValue\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" scrollHandler = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useAnimatedScrollHandler\"\n        }), \"({\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onScroll\"\n        }), \": \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"event\"\n          }), \") =\u003e\"]\n        }), \" {\\n      scrollPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = event.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"contentOffset\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"y\"\n        }), \";\\n    },\\n  });\\n  ...\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 2: 팬 제스처 캡처하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 목록이 화면 상단까지 스크롤된 것을 감지할 수 있게 되었으므로, 다음 단계는 사용자가 목록을 더 아래로 끌 때 팬 제스처를 캡처하는 것입니다. 이를 달성하기 위해 FlatList의 부모 View에 PanResponder를 사용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"팬 응답자(pan responder)를 생성하기 위해 React Native에서 PanResponder를 가져오세요:```\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PanResponder\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"StyleSheet\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"View\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ViewProps\"\n        }), \",\\n} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react-native'\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 PanResponder의 인스턴스를 저장하고 FlatList의 부모 View에 연결하기 위해 ref를 사용하십시오:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DribbbleShots\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"FC\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DribbbleShotsProps\"\n        }), \" \u0026 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ViewProps\"\n        }), \"\u003e = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  ...\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" panResponderRef = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useRef\"\n        }), \"(\\n    \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PanResponder\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create\"\n        }), \"({\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onMoveShouldSetPanResponder\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \",\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onPanResponderMove\"\n        }), \": \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"event, gestureState\"\n          }), \") =\u003e\"]\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(gestureState.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"dy\"\n        }), \");\\n      },\\n    })\\n  );\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \u003cView\\n      style={styles.root}\\n      {...panResponderRef.current.panHandlers}\\n    \u003e\\n      \u003cAnimated.FlatList\\n        ...\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 코드를 자세히 살펴보고 각 부분이 하는 일을 이해해보겠습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"PanResponder.create()\\n이 함수 호출은 PanResponder 인스턴스를 만들며 터치 동작에 대한 앱의 응답 방법을 설명하는 객체를 받습니다. 그리고 PanResponder는 React Ref에 저장됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"onMoveShouldSetPanResponder: () =` true,\\n터치 동작 중 움직임이 있을 때 호출되는 함수입니다. 여기서 true를 반환하면 사용자가 손가락을 움직일 때 Pan Responder가 계속해서 동작을 처리합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"onPanResponderMove: (event, gestureState) =` ' ... '\\n응답해야 할 제스처가 있으면, 이 함수는 제스처 동작 중 움직임이 발생할 때 실행됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"gestureState는 현재 제스처에 대한 다양한 데이터를 포함하는 객체로, 터치의 위치, 전체 움직임 등을 나타냅니다. 우리는 gestureState.dy에만 관심이 있으며, 이 값은 제스처 시작부터 Y방향으로 얼마나 움직였는지를 나타냅니다. 사용자가 얼마나 아래로 당겼는지를 추적하는 데 사용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"현재 목록을 스크롤하려고 하면 응답하지 않는 것 같아요. 이것은 우리의 PanResponder가 계속해서 모든 팬 제스처를 캡처하기 때문에 발생합니다. 결과적으로 목록은 팬 제스처가 발생했음을 처리할 수 없죠. 일단 괜찮아요, 나중에 이 문제를 해결할 거예요.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"https://miro.medium.com/v2/resize:fit:1280/1*JeG4IxcnUQdpcaBdWBzMnA.gif\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 이동 값을 갖게 됐으니, 이 값을 활용해봅시다. 새로운 공유 값(shared value)을 생성하고 이동 값을 저장하는데 사용해요. 이 공유 값은 목록을 애니메이션화하는 데 활용할 수 있어요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"...\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" pullDownPosition = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useSharedValue\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" panResponderRef = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useRef\"\n        }), \"(\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PanResponder\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create\"\n        }), \"({\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onMoveShouldSetPanResponder\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onPanResponderMove\"\n        }), \": \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"event, gestureState\"\n          }), \") =\u003e\"]\n        }), \" {\\n      pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = gestureState.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"dy\"\n        }), \";\\n    },\\n  })\\n);\\n\\n...\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 단계는 Reanimated의 useAnimatedStyle 훅을 사용하여 일부 스타일을 생성하고 적용하는 것입니다. 이 훅은 Reanimated에서 제공되며 공유 값이나 다른 반응형 변수에 기반한 동적 스타일을 생성할 수 있게 해줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"참고: 스타일을 목록 자체가 아닌 목록 부모 View에 적용해야 합니다. 또한 React Native의 View가 아닌 Animated.View를 사용해야 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"...\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animated\"\n        }), \", {\\n  useSharedValue,\\n  useAnimatedScrollHandler,\\n  useAnimatedStyle,\\n} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react-native-reanimated'\"\n        }), \";\\n\\n...\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" pullDownStyles = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useAnimatedStyle\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"transform\"\n        }), \": [\\n      {\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"translateY\"\n        }), \": pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \",\\n      },\\n    ],\\n  };\\n});\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n  \u003cAnimated.View\\n    style={[styles.root, pullDownStyles]}\\n    {...panResponderRef.current.panHandlers}\\n  \u003e\\n    \u003cAnimated.FlatList\\n      data={data}\\n      ...\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저희 코드를 약간 수정하여 사용자가 목록을 아래로 당길 수는 있지만 상단 경계를 넘어서 올릴 수 없도록 해보겠습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"...\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" panResponderRef = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useRef\"\n        }), \"(\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PanResponder\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create\"\n        }), \"({\\n    ...\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onPanResponderMove\"\n        }), \": \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"event, gestureState\"\n          }), \") =\u003e\"]\n        }), \" {\\n      pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"max\"\n        }), \"(gestureState.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"dy\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n    },\\n  })\\n);\\n...\\n\"]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"https://miro.medium.com/v2/resize:fit:1400/1*FTJzKVw9pWxBXYxL4Nrf1g.gif\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"풀다운 애니메이션을 완성하기 위해, 팬 제스처가 해제될 때 pullDownPosition 공유 값을 제로로 재설정해보겠습니다. Reanimated는 공유 값을 애니메이션화할 수 있는 일련의 애니메이션 유틸리티 함수를 제공합니다. 이 경우에는 pullDownPosition 값을 매끄럽게 제로로 애니메이션화하기 위해 withTiming 함수를 사용하겠습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"...\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animated\"\n        }), \", {\\n  useAnimatedScrollHandler,\\n  useAnimatedStyle,\\n  useSharedValue,\\n  withTiming,\\n} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react-native-reanimated'\"\n        }), \";\\n\\n...\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" panResponderRef = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useRef\"\n        }), \"(\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PanResponder\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create\"\n        }), \"({\\n    ...\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onPanResponderRelease\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n      pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"withTiming\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"duration\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"180\"\n        }), \" });\\n    },\\n  })\\n);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"팬 제스처는 다른 제스처나 작업에 의해 조기에 종료되거나 중단될 수 있습니다. 다양한 상호 작용 시나리오에서 일관된 신뢰할 수 있는 사용자 경험을 보장하기 위해 onPanResponderRelease와 함께 onPanResponderTerminate도 사용합시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"...\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"onPanRelease\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") =\u003e {\\n  pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"withTiming\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"duration\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"180\"\n        }), \" });\\n};\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" panResponderRef = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useRef\"\n        }), \"(\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PanResponder\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create\"\n        }), \"({\\n    ...\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onPanResponderRelease\"\n        }), \": onPanRelease,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onPanResponderTerminate\"\n        }), \": onPanRelease,\\n  })\\n);\\n\\n...\\n\"]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"https://miro.medium.com/v2/resize:fit:1280/1*9K8kEfhq4VnhQPZoe60Pfw.gif\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 3: 목록의 스크롤 동작 복원하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"간단한 작동하는 풀다운 애니메이션이 있지만, 목록의 정상적인 스크롤 동작이 보존되고 올바르게 작동하는지 확인해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"onMoveShouldSetPanResponder로 돌아가서 항상 true를 반환하는 대신 의미있는 것을 반환하도록 하겠습니다. 목록이 맨 위로 스크롤되고 사용자가 목록을 더 아래로 밀어내는 경우에만 풀다운 제스처를 허용할 것입니다. 이는 아래와 같이 해석됩니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"...\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" panResponderRef = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useRef\"\n        }), \"(\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PanResponder\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create\"\n        }), \"({\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onMoveShouldSetPanResponder\"\n        }), \": \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"event, gestureState\"\n          }), \") =\u003e\"]\n        }), \"\\n      scrollPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" \u003c= \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" \u0026\u0026 gestureState.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"dy\"\n        }), \" \u003e= \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onPanResponderMove\"\n        }), \": \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"event, gestureState\"\n          }), \") =\u003e\"]\n        }), \" {\\n      pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"max\"\n        }), \"(gestureState.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"dy\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n    },\\n...\\n\"]\n      })\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"https://miro.medium.com/v2/resize:fit:1280/1*URAgW2RXvWsWs1YxrTLL6g.gif\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"잘 했어요! 목록이 이제 제대로 작동하고 풀다운 애니메이션이 의도대로 트리거되어 멋진 일을 해냈어요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 잠시 쉬는 시간이에요. 커피 한 잔을 즐기세요 ☕, 몇 분 휴식을 취한 후에 마지막 단계로 넘어갈게요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"마지막 단계: 새로고침 트리거하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 튜토리얼의 가장 중요한 부분에 도달했어요. 여기서는 실제로 새로 고침 동작을 트리거할 수 있도록 로직을 설정하는 방법을 알아볼 거에요. 현재 사용자들은 목록을 아래로 내릴 수 있지만, 제약을 추가하고 언제 새로 고침을 활성화해야 하는지 정의하고 싶어요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"최대 아래로 당기기 거리 설정\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금 사용자들은 화면 아래쪽까지 목록을 아래로 끌어 내릴 수 있어요. 이것은 자연스럽지 않고 직관적이지 않게 느껴지죠. 그래서 우리는 아래로 당기는 거리를 최대 150픽셀로 제한할 거에요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"...\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" panResponderRef = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useRef\"\n        }), \"(\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PanResponder\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create\"\n        }), \"({\\n    ...\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onPanResponderMove\"\n        }), \": \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"event, gestureState\"\n          }), \") =\u003e\"]\n        }), \" {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" maxDistance = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"150\"\n        }), \";\\n      pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"max\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"min\"\n        }), \"(maxDistance, gestureState.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"dy\"\n        }), \"), \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n    },\\n...\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"새로고침 트리거 지점 결정하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자가 이 150픽셀 범위의 절반 이상으로 당겼을 때, 새로고침 액션이 트리거될 준비가 된 것으로 간주합니다. 이 지점을 넘어서 제스처를 놓으면 새로고침 액션이 시작됩니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"...\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" pullDownPosition = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useSharedValue\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" isReadyToRefresh = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useSharedValue\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" panResponderRef = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useRef\"\n        }), \"(\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PanResponder\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create\"\n        }), \"({\\n    ...\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onPanResponderMove\"\n        }), \": \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"event, gestureState\"\n          }), \") =\u003e\"]\n        }), \" {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" maxDistance = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"150\"\n        }), \";\\n      pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"max\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"min\"\n        }), \"(maxDistance, gestureState.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"dy\"\n        }), \"), \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (\\n        pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" \u003e= maxDistance / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" \u0026\u0026\\n        isReadyToRefresh.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" === \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \"\\n      ) {\\n        isReadyToRefresh.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \";\\n        \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'새로고침할 준비 완료'\"\n        }), \");\\n      }\\n\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (\\n        pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" \u003c maxDistance / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" \u0026\u0026\\n        isReadyToRefresh.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" === \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n      ) {\\n        isReadyToRefresh.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \";\\n        \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'릴리스 시 새로고침하지 않음'\"\n        }), \");\\n      }\\n    },\\n...\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"공유 값 isReadyToRefresh는 목록을 충분히 당겼는지 여부를 나타냅니다. 이제는 제스처 릴리스 처리 논리를 업데이트해봅시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"...\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"onPanRelease\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") =\u003e {\\n  pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"withTiming\"\n        }), \"(isReadyToRefresh.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" ? \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"75\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"duration\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"180\"\n        }), \",\\n  });\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (isReadyToRefresh.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \") {\\n    isReadyToRefresh.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \";\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 새로고침 실행\"\n        }), \"\\n  }\\n};\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" panResponderRef = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useRef\"\n        }), \"(\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"PanResponder\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create\"\n        }), \"({\\n    ...\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onPanResponderRelease\"\n        }), \": onPanRelease,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"onPanResponderTerminate\"\n        }), \": onPanRelease,\\n  })\\n);\\n...\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"새로고침 작업을 트리거하는 메커니즘이 마련되었으니, 제스처(팬 릴리스)의 끝을 처리해봅시다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"새로고침 작업 트리거\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자의 제스처가 끝나고 새로고침 작업 준비가 완료되면, onRefresh 함수를 호출할 것입니다. 이 함수는 하나의 매개변수를 받습니다. 해당 매개변수는 새로고침 작업이 완료된 후 애니메이션을 재설정할 done 함수입니다.```\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"...\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" pullDownPosition = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useSharedValue\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" isReadyToRefresh = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useSharedValue\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \");\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"onRefresh\"\n        }), \" = (\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"done: () =\u003e \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          })]\n        }), \") =\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'새로 고침 중...'\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"setTimeout\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'새로 고침 완료!'\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"done\"\n        }), \"();\\n  }, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7500\"\n        }), \");\\n};\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"onPanRelease\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") =\u003e {\\n  pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"withTiming\"\n        }), \"(isReadyToRefresh.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" ? \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"75\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"duration\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"180\"\n        }), \",\\n  });\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (isReadyToRefresh.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \") {\\n    isReadyToRefresh.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \";\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 애니메이션을 재설정하는 함수\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"onRefreshComplete\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") =\u003e {\\n      pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"withTiming\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"duration\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"180\"\n        }), \" });\\n    };\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 새로 고침 작업 실행\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"onRefresh\"\n        }), \"(onRefreshComplete);\\n  }\\n};\\n\\n...\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"onRefresh\"\n      }), \" 함수는 setTimeout을 사용하여 새로 고침 프로세스를 시뮬레이션합니다(실제 데이터 가져오기 프로세스의 가상 대체물로). 데이터가 새로 고쳐지면 애니메이션을 재설정하기 위해 \", _jsx(_components.code, {\n        children: \"done\"\n      }), \" 콜백이 호출됩니다.\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"https://miro.medium.com/v2/resize:fit:1280/1*qtBcIAWfx4fISFDhdmreFw.gif\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"애니메이션 구축하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 useAnimatedStyle 훅을 사용하여 새로 고침 애니메이션을 활성화할 준비가 되었습니다. 몇 가지 애니메이션 컴포넌트로 UI를 개선하면서 시작해 봅시다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"배경 설정\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, 애니메이션을 위한 배경을 만들겠습니다. 주요 UI를 View로 감싸고 기본 스타일을 적용하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"...\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n  \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"View\"\n            }), \"\\n    \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"style\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{{\"\n            }), \"\\n      \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"flex:\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"1\"\n            }), \",\\n      \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"backgroundColor:\"\n            }), \" '#\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"333\"\n            }), \"',\\n    }}\\n  \u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Animated.View\"\n            }), \"\\n      \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"style\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{[styles.root,\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"pullDownStyles\"\n            }), \"]}\\n      {\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"...panResponderRef.current.panHandlers\"\n            }), \"}\\n    \u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Animated.FlatList\"\n            }), \"\\n        \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"...\"\n            }), \"\\n      /\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Animated.View\"\n            }), \"\u003e\"]\n          }), \"\\n  \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"View\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n);\\n\\n...\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"뷰는 애니메이션을 강조하는 어두운 배경을 제공하는 컨테이너 역할을 합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"새로 고침 아이콘 통합\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음으로, 회전하는 새로 고침 아이콘을 추가해 봅시다. 이 아이콘을 풀 다운 위치에 따라 확대 및 회전되도록 애니메이션화할 것입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DribbbleShots\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"FC\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DribbbleShotsProps\"\n        }), \" \u0026 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ViewProps\"\n        }), \"\u003e = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  ...\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" refreshContainerStyles = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useAnimatedStyle\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" {\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"height\"\n        }), \": pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \",\\n    };\\n  });\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" refreshIconStyles = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useAnimatedStyle\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" scale = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"min\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"max\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"75\"\n        }), \"));\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" {\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"opacity\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"max\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"25\"\n        }), \") / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"50\"\n        }), \",\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"transform\"\n        }), \": [\\n        {\\n          \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"scale\"\n        }), \": scale,\\n        },\\n        {\\n          \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"rotate\"\n        }), \": \", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`\", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"${pullDownPosition.value * \", _jsx(_components.span, {\n              className: \"hljs-number\",\n              children: \"3\"\n            }), \"}\"]\n          }), \"deg`\"]\n        }), \",\\n        },\\n      ],\\n    };\\n  });\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    [styles.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"refreshContainer\"\n        }), \", refreshContainerStyles]}\u003e\\n        \", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Animated.Image\"\n            }), \"\\n          \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"source\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{refreshIcon}\"\n            }), \"\\n          \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"style\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{[styles.refreshIcon,\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"refreshIconStyles\"\n            }), \"]}\\n        /\u003e\"]\n          })\n        }), \"\\n      \u003c/\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animated\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"View\"\n        }), \"\u003e\\n\\n      ...\\n    \u003c/\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"View\"\n        }), \"\u003e\\n  );\\n};\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*OVJMKGr9f4IJG3Ou7KTUjA.gif\",\n        alt: \"Loading animation\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 '새로 고침 중...'이라는 단어를 단순히 기록하는 대신 상태 값을 사용하여 UI를 업데이트하고 새로 고침이 진행 중임을 나타내겠습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"...\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DribbbleShots\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"FC\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DribbbleShotsProps\"\n        }), \" \u0026 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ViewProps\"\n        }), \"\u003e = \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  ...\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" pullDownPosition = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useSharedValue\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" isReadyToRefresh = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useSharedValue\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [refreshing, setRefreshing] = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"onRefresh\"\n        }), \" = (\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"done: () =\u003e \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          })]\n        }), \") =\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setRefreshing\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \");\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"setTimeout\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n      \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setRefreshing\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \");\\n      \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"done\"\n        }), \"();\\n    }, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7500\"\n        }), \");\\n  };\\n\\n  ...\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"View\"\n            }), \"\\n      \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"pointerEvents\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{refreshing\"\n            }), \" ? '\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"none\"\n            }), \"' \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \":\"\n            }), \" '\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"auto\"\n            }), \"'}\\n      \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"style\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{\"\n            }), \"\\n        \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"flex:\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"1\"\n            }), \",\\n        \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"backgroundColor:\"\n            }), \" '#\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"333\"\n            }), \"',\\n      }\\n    \u003e\"]\n          }), \"\\n\\n    ...\\n\"]\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데이터가 아직로드 중인 동안 원치 않는 pull-down 제스처를 제어하고 방지하려면 pointerEvents 속성을 추가했습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"\\n\\n\\n## 로고 애니메이션 구현하기\\n\\n조금 더 재미있게 만들기 위해 애니메이션 로고를 추가해봅시다. 사용한 애니메이션 로고는 원래 Tony Pinkevych가 Dribbble에서 만들었고, 저는 이 데모에 맞게 약간 수정했습니다.\\n\\n```js\\n/**\\n * 의존성 가져오기\\n */\\n\\nimport React from 'react';\\nimport { Image } from 'expo-image';\\n\\n...\\n\\nconst DribbbleShots: React.FC\u003cDribbbleShotsProps \u0026 ViewProps\u003e = () =\u003e {\\n  ...\\n\\n  return (\\n    \u003cView\\n      pointerEvents={refreshing ? 'none' : 'auto'}\\n      style={\\n        flex: 1,\\n        backgroundColor: '#333',\\n      }\\n    \u003e\\n      \u003cAnimated.View style={[styles.refreshContainer, refreshContainerStyles]}\u003e\\n        {refreshing \u0026\u0026 (\\n          \u003cImage\\n            source={animatedLogo}\\n            style={ width: 280, height: '100%', objectFit: 'cover' }\\n          /\u003e\\n        )}\\n\\n        \u003cAnimated.Image\\n          source={refreshIcon}\\n          style={[styles.refreshIcon, refreshIconStyles]}\\n        /\u003e\\n      \u003c/Animated.View\u003e\\n\\n    ...\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, refreshIconStyles를 업데이트하여 새로 고침 아이콘을 애니메이션 로고로 부드럽게 전환해보겠습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" refreshIconStyles = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useAnimatedStyle\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" scale = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"min\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"max\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"75\"\n        }), \"));\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"opacity\"\n        }), \": refreshing\\n      ? \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"withDelay\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"100\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"withTiming\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"duration\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"20\"\n        }), \" }))\\n      : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Math\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"max\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", pullDownPosition.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"value\"\n        }), \" - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"25\"\n        }), \") / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"50\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"transform\"\n        }), \": [\\n      {\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"scaleX\"\n        }), \": refreshing ? \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"withTiming\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.15\"\n        }), \", { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"duration\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"120\"\n        }), \" }) : scale,\\n      },\\n      {\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"scaleY\"\n        }), \": scale,\\n      },\\n      {\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"rotate\"\n        }), \": \", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`\", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"${pullDownPosition.value * \", _jsx(_components.span, {\n              className: \"hljs-number\",\n              children: \"3\"\n            }), \"}\"]\n          }), \"deg`\"]\n        }), \",\\n      },\\n    ],\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"backgroundColor\"\n        }), \": refreshing ? \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'#fff'\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'transparent'\"\n        }), \",\\n  };\\n}, [refreshing]);\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막으로, 데이터를 로드하는 동안 스켈레톤 카드를 보여줄 것입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"...\\n\\n\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animated\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"FlatList\"\n        }), \"\\n  ...\\n  renderItem={\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"{ item, index }\"\n          }), \") =\u003e\"]\n        }), \" (\\n    \", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Card\"\n            }), \"\\n      \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"loading\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{refreshing}\"\n            }), \"\\n      \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"index\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{index}\"\n            }), \"\\n      \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"image\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{item.image}\"\n            }), \"\\n      \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"title\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{item.title}\"\n            }), \"\\n      \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"likes\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{item.likes}\"\n            }), \"\\n    /\u003e\"]\n          })\n        }), \"\\n  )}\\n  onScroll={scrollHandler}\\n  scrollEventThrottle={\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"16\"\n        }), \"}\\n/\u003e\\n\u003c/\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animated\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"View\"\n        }), \"\u003e\\n\\n...\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 마지막 손짓으로, 새로 고침 애니메이션이 기능적이면서 시각적으로 매력적으로 완성되었습니다.```\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"활기찬 인상 깊은 애니메이션\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 창조의 시간입니다. 여기 창의성을 자극하고 다음 앱을 위한 몇 가지 아이디어를 제공할 인상적인 애니메이션의 선별된 목록이 준비되어 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*KB2KSwJq06LLyzA2_t-h1w.gif\",\n        alt: \"Animation 1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*6L8rnyxjfPF-leE0x3Kigg.gif\",\n        alt: \"Animation 2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*Fb1kzeeAhQVNEf5TTAZlrg.gif\",\n        alt: \"Animated GIF\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*YU3TndEWRtBaNcjXf-JZVg.gif\",\n        alt: \"Animated GIF\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*sMa1sfIYa6Zsl8Co0bCsEQ.gif\",\n        alt: \"Animated GIF\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*N5X0Kbuz7jHxclWzBv-glw.gif\",\n        alt: \"Animated GIF\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*pZ8ddY3rFUoVBuTWAhRPTg.gif\",\n        alt: \"image1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*bSPbDYoIz9zz3r2mCftWKw.gif\",\n        alt: \"image2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*utIKDBZ3o_V_-ctf22CBSA.gif\",\n        alt: \"image3\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*Ti1YIVYL67ZQHWDXNX8ZzA.gif\",\n        alt: \"image4\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*948wumPUB-5spDMTYs0Odg.gif\",\n        alt: \"이미지1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*V4UtSyfCN9DDpl70IxXSHA.gif\",\n        alt: \"이미지2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*GA_UPaFN6krQMhRb3lGiqw.gif\",\n        alt: \"이미지3\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1400/1*m4aMIvlIMY5WGmyFL8q2gA.gif\",\n        alt: \"이미지4\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리의 사용자 정의 새로 고침 애니메이션 자습서가 마무리되었습니다! 아마도 이것이 여러분의 프로젝트에 몇 가지 아이디어를 불러일으켰으면 좋겠네요. 다양한 애니메이션을 실험해보고 해당 앱의 사용자 경험을 어떻게 향상시킬 수 있는지 확인해 보는 것을 권장합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기억하세요, 배우는 가장 좋은 방법은 직접 해보는 것이기 때문에 고유한 새로 고침 애니메이션을 만들어보는 것에 도전해 보세요. 즐거운 코딩 되세요!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated"},"buildId":"uXJWf9GNc_Ux38RlnQJQc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>