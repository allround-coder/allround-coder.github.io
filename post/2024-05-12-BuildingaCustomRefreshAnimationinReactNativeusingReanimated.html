<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated" data-gatsby-head="true"/><meta name="twitter:title" content="리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 21:21" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">18<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>간단한 애니메이션이 앱의 사용자 경험을 얼마나 높일 수 있는지 궁금했던 적이 있나요?</h2>
<p>잘 디자인된 애니메이션은 평범한 사용자 상호 작용을 진정으로 기억에 남는 경험으로 변화시킬 수 있습니다.</p>
<p>이 포스트에서는 React Native와 Reanimated 라이브러리를 사용하여 모바일 앱에 맞춘 흥미로운 사용자 정의 '당겨서 새로고침' 애니메이션을 만드는 방법을 배우게 됩니다.</p>
<h2>그냥 React Native의 RefreshControl을 사용하는 것이 좋지 않을까요?</h2>
<p>리액트 네이티브로 모바일 애플리케이션을 개발할 때, Pull-to-refresh 기능을 구현하는 데 RefreshControl 컴포넌트를 주로 사용합니다.</p>
<p>간단하고 직관적이지만, 꽤 기본적이며 제한된 사용자 정의 기능을 제공합니다. 이로 인해 여러분의 앱이 그저 다른 어떤 앱처럼 보이는 경우가 있을 수 있습니다.</p>
<p>사용자 정의 애니메이션을 생성하면 앱의 모양과 느낌을 자유롭게 조절하여 브랜딩 및 디자인 언어와 완벽하게 일치시킬 수 있습니다. 이로써 앱이 더 독특하고 기억에 남는 사용자 경험을 제공하게 되어 앱이 더욱 독특하고 기억에 남게 만듭니다.</p>
<h2>왜 Animated가 아닌 Reanimated 라이브러리를 사용해야 하는가?</h2>
<p>React Native에서 애니메이션에 관한 이야기가 나온다면, 두 가지 주요 라이브러리가 떠오르게 됩니다: 내장된 Animated 라이브러리와 더 고급화된 Reanimated 라이브러리가 있습니다.</p>
<p>Reanimated가 선호되는 이유는 몇 가지가 있습니다:</p>
<ul>
<li>성능:
Reanimated는 특히 복잡한 애니메이션에 대해 우수한 성능을 제공합니다. 네이티브 스레드를 활용하여 JavaScript 스레드 대신 작동함으로써 더 효율적으로 작동합니다. 이는 훨씬 부드러운 애니메이션을 가능하게 하며, 이는 원활한 사용자 경험을 위한 중요한 요소입니다.</li>
<li>제스처 기반 애니메이션:
Reanimated는 더 복잡한 애니메이션 처리를 위한 더 나은 API를 제공하며, 제스처와 애니메이션의 더 섬세한 제어와 더 부드러운 통합을 가능케 합니다.</li>
<li>선언적 접근: Animated와 달리, Reanimated는 애니메이션에 더 선언적인 접근 방식을 채용합니다. 이는 애니메이션이 더 복잡해지면서 이해하고 관리하기 쉬워집니다.</li>
</ul>
<h1>시작하기</h1>
<p>이 튜토리얼에서는 간단한 앱을 향상시키고자 합니다. 이 앱은 FlatList에서 카드 형태로 표시되는 Dribbble 샷 목록을 보여줍니다. 우리의 목표는 사용자가 목록을 위로 당겼을 때 나타나는 사용자 정의 새로 고침 애니메이션을 추가하는 것입니다.</p>
<h2>프로젝트 복제 및 설정</h2>
<p>로컬 컴퓨터에서 저장소를 클론하고 프로젝트를 설정하기 위해 다음 단계를 따라주세요:</p>
<p>저장소 복제:
터미널을 열고 다음 명령어로 저장소를 클론하세요:</p>
<pre><code class="hljs language-js">git clone <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/teefouad/custom-rn-refresh-animation-start.git</span>
</code></pre>
<p>VSCode에서 프로젝트 열기:
이 강좌의 모든 코드는 app/index.tsx에 들어가기 때문에 해당 파일을 열어 다른 파일과 디렉터리를 무시할 수 있습니다.
다음과 같은 내용이 표시됩니다:</p>
<img src="/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png">
<p>의존성 설치:
필요한 종속 항목을 설치하려면 npm install 또는 yarn을 실행하세요.</p>
<p>프로젝트 실행하기:
npm start 또는 yarn start를 실행하여 프로젝트를 시작하세요. 이렇게 하면 Metro 번들러가 초기화되고 앱이 개발 모드로 실행됩니다.</p>
<p>프로젝트가 설정되었으므로, 이제 우리는 흥미로운 부분으로 빠져들 준비가 되었습니다: 우리의 사용자 정의 새로고침 애니메이션 만들기!</p>
<h1>애니메이션 만들기: 상단 스크롤 감지</h1>
<p>사용자 정의 애니메이션을 만드는 첫 번째 단계는 FlatList가 맨 위로 스크롤되었을 때 감지하는 것입니다.</p>
<p>이를 위해 Reanimated에서 useAnimatedScrollHandler를 사용할 것입니다. 이 훅은 최적화되고 성능이 좋은 방식으로 스크롤 이벤트를 처리할 수 있는 함수를 제공할 것입니다.</p>
<ol>
<li>먼저, Reanimated에서 훅을 import 해야 합니다:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
 * Dependency imports
 */</span>

 <span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
 <span class="hljs-keyword">import</span> { <span class="hljs-title class_">FlatList</span>, <span class="hljs-title class_">StyleSheet</span>, <span class="hljs-title class_">View</span>, <span class="hljs-title class_">ViewProps</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
 <span class="hljs-keyword">import</span> <span class="hljs-title class_">Animated</span>, { useAnimatedScrollHandler } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native-reanimated'</span>;
</code></pre>
<ol start="2">
<li>useAnimatedScrollHandler를 사용하여 스크롤 핸들러를 생성하세요:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">DribbbleShots</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;<span class="hljs-title class_">DribbbleShotsProps</span> &#x26; <span class="hljs-title class_">ViewProps</span>> = <span class="hljs-function">() =></span> {
  <span class="hljs-keyword">const</span> scrollHandler = <span class="hljs-title function_">useAnimatedScrollHandler</span>({
    <span class="hljs-attr">onScroll</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">contentOffset</span>.<span class="hljs-property">y</span>);
    },
  });

  <span class="hljs-keyword">return</span> (
    ...
</code></pre>
<p>지금은 리스트 스크롤 위치를 기록하는 것으로 할게요.</p>
<ol start="3">
<li>리스트에 스크롤 핸들러를 연결해보세요. useAnimatedScrollHandler를 사용하여 만든 스크롤 이벤트 핸들러는 React Native의 FlatList와 호환되지 않을 것이므로 Reanimated에서 제공하는 FlatList로 대체해야 합니다.</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.root}</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Animated.FlatList</span>
        <span class="hljs-attr">...</span>
        <span class="hljs-attr">onScroll</span>=<span class="hljs-string">{scrollHandler}</span>
        <span class="hljs-attr">scrollEventThrottle</span>=<span class="hljs-string">{16}</span> // <span class="hljs-attr">부드러운</span> <span class="hljs-attr">성능을</span> <span class="hljs-attr">위한</span> <span class="hljs-attr">좋은</span> <span class="hljs-attr">방법</span>
      /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span></span>
);
</code></pre>
<p>scrollEventThrottle 속성은 스크롤 이벤트가 발생하는 빈도를 제어합니다. 여기서 값이 16이면 스크롤 이벤트를 대략 16밀리초마다 캡처합니다. 이렇게 하면 애니메이션이 부드럽고 반응이 빠릅니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1280/1*6cGVuwIPgf4QnLIC79xN7g.gif" alt="이미지"></p>
<p>이제 콘솔에 스크롤 위치를 단순히 기록하는 대신, 이를 공유 값에 저장합시다.</p>
<p>다음과 같이 코드를 업데이트하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Animated</span>, {
  useAnimatedScrollHandler,
  useSharedValue,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native-reanimated'</span>;

...

<span class="hljs-keyword">const</span> <span class="hljs-title class_">DribbbleShots</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;<span class="hljs-title class_">DribbbleShotsProps</span> &#x26; <span class="hljs-title class_">ViewProps</span>> = <span class="hljs-function">() =></span> {
  <span class="hljs-keyword">const</span> scrollPosition = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">const</span> scrollHandler = <span class="hljs-title function_">useAnimatedScrollHandler</span>({
    <span class="hljs-attr">onScroll</span>: <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> {
      scrollPosition.<span class="hljs-property">value</span> = event.<span class="hljs-property">contentOffset</span>.<span class="hljs-property">y</span>;
    },
  });
  ...
</code></pre>
<h1>단계 2: 팬 제스처 캡처하기</h1>
<p>이제 목록이 화면 상단까지 스크롤된 것을 감지할 수 있게 되었으므로, 다음 단계는 사용자가 목록을 더 아래로 끌 때 팬 제스처를 캡처하는 것입니다. 이를 달성하기 위해 FlatList의 부모 View에 PanResponder를 사용할 것입니다.</p>
<p>팬 응답자(pan responder)를 생성하기 위해 React Native에서 PanResponder를 가져오세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">PanResponder</span>,
  <span class="hljs-title class_">StyleSheet</span>,
  <span class="hljs-title class_">View</span>,
  <span class="hljs-title class_">ViewProps</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
</code></pre>
<p>그런 다음 PanResponder의 인스턴스를 저장하고 FlatList의 부모 View에 연결하기 위해 ref를 사용하십시오:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">DribbbleShots</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;<span class="hljs-title class_">DribbbleShotsProps</span> &#x26; <span class="hljs-title class_">ViewProps</span>> = <span class="hljs-function">() =></span> {
  ...

  <span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
    <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
      <span class="hljs-attr">onMoveShouldSetPanResponder</span>: <span class="hljs-function">() =></span> <span class="hljs-literal">true</span>,
      <span class="hljs-attr">onPanResponderMove</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =></span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(gestureState.<span class="hljs-property">dy</span>);
      },
    })
  );

  <span class="hljs-keyword">return</span> (
    &#x3C;View
      style={styles.root}
      {...panResponderRef.current.panHandlers}
    >
      &#x3C;Animated.FlatList
        ...
</code></pre>
<p>이 코드를 자세히 살펴보고 각 부분이 하는 일을 이해해보겠습니다:</p>
<p>PanResponder.create()
이 함수 호출은 PanResponder 인스턴스를 만들며 터치 동작에 대한 앱의 응답 방법을 설명하는 객체를 받습니다. 그리고 PanResponder는 React Ref에 저장됩니다.</p>
<p>onMoveShouldSetPanResponder: () =` true,
터치 동작 중 움직임이 있을 때 호출되는 함수입니다. 여기서 true를 반환하면 사용자가 손가락을 움직일 때 Pan Responder가 계속해서 동작을 처리합니다.</p>
<p>onPanResponderMove: (event, gestureState) =` ' ... '
응답해야 할 제스처가 있으면, 이 함수는 제스처 동작 중 움직임이 발생할 때 실행됩니다.</p>
<p>gestureState는 현재 제스처에 대한 다양한 데이터를 포함하는 객체로, 터치의 위치, 전체 움직임 등을 나타냅니다. 우리는 gestureState.dy에만 관심이 있으며, 이 값은 제스처 시작부터 Y방향으로 얼마나 움직였는지를 나타냅니다. 사용자가 얼마나 아래로 당겼는지를 추적하는 데 사용할 것입니다.</p>
<p>현재 목록을 스크롤하려고 하면 응답하지 않는 것 같아요. 이것은 우리의 PanResponder가 계속해서 모든 팬 제스처를 캡처하기 때문에 발생합니다. 결과적으로 목록은 팬 제스처가 발생했음을 처리할 수 없죠. 일단 괜찮아요, 나중에 이 문제를 해결할 거예요.</p>
<img src="https://miro.medium.com/v2/resize:fit:1280/1*JeG4IxcnUQdpcaBdWBzMnA.gif">
<p>이제 이동 값을 갖게 됐으니, 이 값을 활용해봅시다. 새로운 공유 값(shared value)을 생성하고 이동 값을 저장하는데 사용해요. 이 공유 값은 목록을 애니메이션화하는 데 활용할 수 있어요.</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> pullDownPosition = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-number">0</span>);

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    <span class="hljs-attr">onMoveShouldSetPanResponder</span>: <span class="hljs-function">() =></span> <span class="hljs-literal">true</span>,
    <span class="hljs-attr">onPanResponderMove</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =></span> {
      pullDownPosition.<span class="hljs-property">value</span> = gestureState.<span class="hljs-property">dy</span>;
    },
  })
);

...
</code></pre>
<p>다음 단계는 Reanimated의 useAnimatedStyle 훅을 사용하여 일부 스타일을 생성하고 적용하는 것입니다. 이 훅은 Reanimated에서 제공되며 공유 값이나 다른 반응형 변수에 기반한 동적 스타일을 생성할 수 있게 해줍니다.</p>
<p>참고: 스타일을 목록 자체가 아닌 목록 부모 View에 적용해야 합니다. 또한 React Native의 View가 아닌 Animated.View를 사용해야 합니다.</p>
<pre><code class="hljs language-js">...
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Animated</span>, {
  useSharedValue,
  useAnimatedScrollHandler,
  useAnimatedStyle,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native-reanimated'</span>;

...

<span class="hljs-keyword">const</span> pullDownStyles = <span class="hljs-title function_">useAnimatedStyle</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">transform</span>: [
      {
        <span class="hljs-attr">translateY</span>: pullDownPosition.<span class="hljs-property">value</span>,
      },
    ],
  };
});

<span class="hljs-keyword">return</span> (
  &#x3C;Animated.View
    style={[styles.root, pullDownStyles]}
    {...panResponderRef.current.panHandlers}
  >
    &#x3C;Animated.FlatList
      data={data}
      ...
</code></pre>
<p>저희 코드를 약간 수정하여 사용자가 목록을 아래로 당길 수는 있지만 상단 경계를 넘어서 올릴 수 없도록 해보겠습니다:</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    ...

    <span class="hljs-attr">onPanResponderMove</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =></span> {
      pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(gestureState.<span class="hljs-property">dy</span>, <span class="hljs-number">0</span>);
    },
  })
);
...
</code></pre>
<img src="https://miro.medium.com/v2/resize:fit:1400/1*FTJzKVw9pWxBXYxL4Nrf1g.gif">
<p>풀다운 애니메이션을 완성하기 위해, 팬 제스처가 해제될 때 pullDownPosition 공유 값을 제로로 재설정해보겠습니다. Reanimated는 공유 값을 애니메이션화할 수 있는 일련의 애니메이션 유틸리티 함수를 제공합니다. 이 경우에는 pullDownPosition 값을 매끄럽게 제로로 애니메이션화하기 위해 withTiming 함수를 사용하겠습니다.</p>
<pre><code class="hljs language-js">...
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Animated</span>, {
  useAnimatedScrollHandler,
  useAnimatedStyle,
  useSharedValue,
  withTiming,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native-reanimated'</span>;

...

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    ...
    <span class="hljs-attr">onPanResponderRelease</span>: <span class="hljs-function">() =></span> {
      pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title function_">withTiming</span>(<span class="hljs-number">0</span>, { <span class="hljs-attr">duration</span>: <span class="hljs-number">180</span> });
    },
  })
);
</code></pre>
<p>팬 제스처는 다른 제스처나 작업에 의해 조기에 종료되거나 중단될 수 있습니다. 다양한 상호 작용 시나리오에서 일관된 신뢰할 수 있는 사용자 경험을 보장하기 위해 onPanResponderRelease와 함께 onPanResponderTerminate도 사용합시다:</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> <span class="hljs-title function_">onPanRelease</span> = (<span class="hljs-params"></span>) => {
  pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title function_">withTiming</span>(<span class="hljs-number">0</span>, { <span class="hljs-attr">duration</span>: <span class="hljs-number">180</span> });
};

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    ...
    <span class="hljs-attr">onPanResponderRelease</span>: onPanRelease,
    <span class="hljs-attr">onPanResponderTerminate</span>: onPanRelease,
  })
);

...
</code></pre>
<img src="https://miro.medium.com/v2/resize:fit:1280/1*9K8kEfhq4VnhQPZoe60Pfw.gif">
<h1>단계 3: 목록의 스크롤 동작 복원하기</h1>
<p>간단한 작동하는 풀다운 애니메이션이 있지만, 목록의 정상적인 스크롤 동작이 보존되고 올바르게 작동하는지 확인해야 합니다.</p>
<p>onMoveShouldSetPanResponder로 돌아가서 항상 true를 반환하는 대신 의미있는 것을 반환하도록 하겠습니다. 목록이 맨 위로 스크롤되고 사용자가 목록을 더 아래로 밀어내는 경우에만 풀다운 제스처를 허용할 것입니다. 이는 아래와 같이 해석됩니다:</p>
<pre><code class="hljs language-js">...
<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    <span class="hljs-attr">onMoveShouldSetPanResponder</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =></span>
      scrollPosition.<span class="hljs-property">value</span> &#x3C;= <span class="hljs-number">0</span> &#x26;&#x26; gestureState.<span class="hljs-property">dy</span> >= <span class="hljs-number">0</span>,
    <span class="hljs-attr">onPanResponderMove</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =></span> {
      pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(gestureState.<span class="hljs-property">dy</span>, <span class="hljs-number">0</span>);
    },
...
</code></pre>
<img src="https://miro.medium.com/v2/resize:fit:1280/1*URAgW2RXvWsWs1YxrTLL6g.gif">
<p>잘 했어요! 목록이 이제 제대로 작동하고 풀다운 애니메이션이 의도대로 트리거되어 멋진 일을 해냈어요!</p>
<p>이제 잠시 쉬는 시간이에요. 커피 한 잔을 즐기세요 ☕, 몇 분 휴식을 취한 후에 마지막 단계로 넘어갈게요.</p>
<h1>마지막 단계: 새로고침 트리거하기</h1>
<p>이제 튜토리얼의 가장 중요한 부분에 도달했어요. 여기서는 실제로 새로 고침 동작을 트리거할 수 있도록 로직을 설정하는 방법을 알아볼 거에요. 현재 사용자들은 목록을 아래로 내릴 수 있지만, 제약을 추가하고 언제 새로 고침을 활성화해야 하는지 정의하고 싶어요.</p>
<h2>최대 아래로 당기기 거리 설정</h2>
<p>지금 사용자들은 화면 아래쪽까지 목록을 아래로 끌어 내릴 수 있어요. 이것은 자연스럽지 않고 직관적이지 않게 느껴지죠. 그래서 우리는 아래로 당기는 거리를 최대 150픽셀로 제한할 거에요.</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    ...
    <span class="hljs-attr">onPanResponderMove</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =></span> {
      <span class="hljs-keyword">const</span> maxDistance = <span class="hljs-number">150</span>;
      pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(maxDistance, gestureState.<span class="hljs-property">dy</span>), <span class="hljs-number">0</span>);
    },
...
</code></pre>
<h2>새로고침 트리거 지점 결정하기</h2>
<p>사용자가 이 150픽셀 범위의 절반 이상으로 당겼을 때, 새로고침 액션이 트리거될 준비가 된 것으로 간주합니다. 이 지점을 넘어서 제스처를 놓으면 새로고침 액션이 시작됩니다.</p>
<pre><code class="hljs language-js">...
<span class="hljs-keyword">const</span> pullDownPosition = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> isReadyToRefresh = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-literal">false</span>);

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    ...
    <span class="hljs-attr">onPanResponderMove</span>: <span class="hljs-function">(<span class="hljs-params">event, gestureState</span>) =></span> {
      <span class="hljs-keyword">const</span> maxDistance = <span class="hljs-number">150</span>;
      pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(maxDistance, gestureState.<span class="hljs-property">dy</span>), <span class="hljs-number">0</span>);

      <span class="hljs-keyword">if</span> (
        pullDownPosition.<span class="hljs-property">value</span> >= maxDistance / <span class="hljs-number">2</span> &#x26;&#x26;
        isReadyToRefresh.<span class="hljs-property">value</span> === <span class="hljs-literal">false</span>
      ) {
        isReadyToRefresh.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'새로고침할 준비 완료'</span>);
      }

      <span class="hljs-keyword">if</span> (
        pullDownPosition.<span class="hljs-property">value</span> &#x3C; maxDistance / <span class="hljs-number">2</span> &#x26;&#x26;
        isReadyToRefresh.<span class="hljs-property">value</span> === <span class="hljs-literal">true</span>
      ) {
        isReadyToRefresh.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'릴리스 시 새로고침하지 않음'</span>);
      }
    },
...
</code></pre>
<p>공유 값 isReadyToRefresh는 목록을 충분히 당겼는지 여부를 나타냅니다. 이제는 제스처 릴리스 처리 논리를 업데이트해봅시다:</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> <span class="hljs-title function_">onPanRelease</span> = (<span class="hljs-params"></span>) => {
  pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title function_">withTiming</span>(isReadyToRefresh.<span class="hljs-property">value</span> ? <span class="hljs-number">75</span> : <span class="hljs-number">0</span>, {
    <span class="hljs-attr">duration</span>: <span class="hljs-number">180</span>,
  });

  <span class="hljs-keyword">if</span> (isReadyToRefresh.<span class="hljs-property">value</span>) {
    isReadyToRefresh.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// 새로고침 실행</span>
  }
};

<span class="hljs-keyword">const</span> panResponderRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(
  <span class="hljs-title class_">PanResponder</span>.<span class="hljs-title function_">create</span>({
    ...
    <span class="hljs-attr">onPanResponderRelease</span>: onPanRelease,
    <span class="hljs-attr">onPanResponderTerminate</span>: onPanRelease,
  })
);
...
</code></pre>
<p>새로고침 작업을 트리거하는 메커니즘이 마련되었으니, 제스처(팬 릴리스)의 끝을 처리해봅시다.</p>
<h2>새로고침 작업 트리거</h2>
<p>사용자의 제스처가 끝나고 새로고침 작업 준비가 완료되면, onRefresh 함수를 호출할 것입니다. 이 함수는 하나의 매개변수를 받습니다. 해당 매개변수는 새로고침 작업이 완료된 후 애니메이션을 재설정할 done 함수입니다.</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> pullDownPosition = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> isReadyToRefresh = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-literal">false</span>);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">onRefresh</span> = (<span class="hljs-params">done: () => <span class="hljs-keyword">void</span></span>) => {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'새로 고침 중...'</span>);

  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'새로 고침 완료!'</span>);
    <span class="hljs-title function_">done</span>();
  }, <span class="hljs-number">7500</span>);
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">onPanRelease</span> = (<span class="hljs-params"></span>) => {
  pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title function_">withTiming</span>(isReadyToRefresh.<span class="hljs-property">value</span> ? <span class="hljs-number">75</span> : <span class="hljs-number">0</span>, {
    <span class="hljs-attr">duration</span>: <span class="hljs-number">180</span>,
  });

  <span class="hljs-keyword">if</span> (isReadyToRefresh.<span class="hljs-property">value</span>) {
    isReadyToRefresh.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>;

    <span class="hljs-comment">// 애니메이션을 재설정하는 함수</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">onRefreshComplete</span> = (<span class="hljs-params"></span>) => {
      pullDownPosition.<span class="hljs-property">value</span> = <span class="hljs-title function_">withTiming</span>(<span class="hljs-number">0</span>, { <span class="hljs-attr">duration</span>: <span class="hljs-number">180</span> });
    };

    <span class="hljs-comment">// 새로 고침 작업 실행</span>
    <span class="hljs-title function_">onRefresh</span>(onRefreshComplete);
  }
};

...
</code></pre>
<p><code>onRefresh</code> 함수는 setTimeout을 사용하여 새로 고침 프로세스를 시뮬레이션합니다(실제 데이터 가져오기 프로세스의 가상 대체물로). 데이터가 새로 고쳐지면 애니메이션을 재설정하기 위해 <code>done</code> 콜백이 호출됩니다.</p>
<img src="https://miro.medium.com/v2/resize:fit:1280/1*qtBcIAWfx4fISFDhdmreFw.gif">
<h1>애니메이션 구축하기</h1>
<p>이제 useAnimatedStyle 훅을 사용하여 새로 고침 애니메이션을 활성화할 준비가 되었습니다. 몇 가지 애니메이션 컴포넌트로 UI를 개선하면서 시작해 봅시다.</p>
<h2>배경 설정</h2>
<p>먼저, 애니메이션을 위한 배경을 만들겠습니다. 주요 UI를 View로 감싸고 기본 스타일을 적용하세요:</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">return</span> (
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">View</span>
    <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span>
      <span class="hljs-attr">flex:</span> <span class="hljs-attr">1</span>,
      <span class="hljs-attr">backgroundColor:</span> '#<span class="hljs-attr">333</span>',
    }}
  ></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">Animated.View</span>
      <span class="hljs-attr">style</span>=<span class="hljs-string">{[styles.root,</span> <span class="hljs-attr">pullDownStyles</span>]}
      {<span class="hljs-attr">...panResponderRef.current.panHandlers</span>}
    ></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Animated.FlatList</span>
        <span class="hljs-attr">...</span>
      /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">Animated.View</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span></span>
);

...
</code></pre>
<p>뷰는 애니메이션을 강조하는 어두운 배경을 제공하는 컨테이너 역할을 합니다.</p>
<h2>새로 고침 아이콘 통합</h2>
<p>다음으로, 회전하는 새로 고침 아이콘을 추가해 봅시다. 이 아이콘을 풀 다운 위치에 따라 확대 및 회전되도록 애니메이션화할 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">DribbbleShots</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;<span class="hljs-title class_">DribbbleShotsProps</span> &#x26; <span class="hljs-title class_">ViewProps</span>> = <span class="hljs-function">() =></span> {
  ...

  <span class="hljs-keyword">const</span> refreshContainerStyles = <span class="hljs-title function_">useAnimatedStyle</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">height</span>: pullDownPosition.<span class="hljs-property">value</span>,
    };
  });

  <span class="hljs-keyword">const</span> refreshIconStyles = <span class="hljs-title function_">useAnimatedStyle</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> scale = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, pullDownPosition.<span class="hljs-property">value</span> / <span class="hljs-number">75</span>));

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">opacity</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, pullDownPosition.<span class="hljs-property">value</span> - <span class="hljs-number">25</span>) / <span class="hljs-number">50</span>,
      <span class="hljs-attr">transform</span>: [
        {
          <span class="hljs-attr">scale</span>: scale,
        },
        {
          <span class="hljs-attr">rotate</span>: <span class="hljs-string">`<span class="hljs-subst">${pullDownPosition.value * <span class="hljs-number">3</span>}</span>deg`</span>,
        },
      ],
    };
  });

  <span class="hljs-keyword">return</span> (
    [styles.<span class="hljs-property">refreshContainer</span>, refreshContainerStyles]}>
        <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Animated.Image</span>
          <span class="hljs-attr">source</span>=<span class="hljs-string">{refreshIcon}</span>
          <span class="hljs-attr">style</span>=<span class="hljs-string">{[styles.refreshIcon,</span> <span class="hljs-attr">refreshIconStyles</span>]}
        /></span></span>
      &#x3C;/<span class="hljs-title class_">Animated</span>.<span class="hljs-property">View</span>>

      ...
    &#x3C;/<span class="hljs-title class_">View</span>>
  );
};
</code></pre>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*OVJMKGr9f4IJG3Ou7KTUjA.gif" alt="Loading animation"></p>
<p>이제 '새로 고침 중...'이라는 단어를 단순히 기록하는 대신 상태 값을 사용하여 UI를 업데이트하고 새로 고침이 진행 중임을 나타내겠습니다:</p>
<pre><code class="hljs language-js">...

<span class="hljs-keyword">const</span> <span class="hljs-title class_">DribbbleShots</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;<span class="hljs-title class_">DribbbleShotsProps</span> &#x26; <span class="hljs-title class_">ViewProps</span>> = <span class="hljs-function">() =></span> {
  ...

  <span class="hljs-keyword">const</span> pullDownPosition = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> isReadyToRefresh = <span class="hljs-title function_">useSharedValue</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [refreshing, setRefreshing] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onRefresh</span> = (<span class="hljs-params">done: () => <span class="hljs-keyword">void</span></span>) => {
    <span class="hljs-title function_">setRefreshing</span>(<span class="hljs-literal">true</span>);

    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-title function_">setRefreshing</span>(<span class="hljs-literal">false</span>);
      <span class="hljs-title function_">done</span>();
    }, <span class="hljs-number">7500</span>);
  };

  ...

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">View</span>
      <span class="hljs-attr">pointerEvents</span>=<span class="hljs-string">{refreshing</span> ? '<span class="hljs-attr">none</span>' <span class="hljs-attr">:</span> '<span class="hljs-attr">auto</span>'}
      <span class="hljs-attr">style</span>=<span class="hljs-string">{</span>
        <span class="hljs-attr">flex:</span> <span class="hljs-attr">1</span>,
        <span class="hljs-attr">backgroundColor:</span> '#<span class="hljs-attr">333</span>',
      }
    ></span>

    ...
</span></code></pre>
<p>데이터가 아직로드 중인 동안 원치 않는 pull-down 제스처를 제어하고 방지하려면 pointerEvents 속성을 추가했습니다.</p>
<h2>로고 애니메이션 구현하기</h2>
<p>조금 더 재미있게 만들기 위해 애니메이션 로고를 추가해봅시다. 사용한 애니메이션 로고는 원래 Tony Pinkevych가 Dribbble에서 만들었고, 저는 이 데모에 맞게 약간 수정했습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/**
 * 의존성 가져오기
 */</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Image</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'expo-image'</span>;

...

<span class="hljs-keyword">const</span> <span class="hljs-title class_">DribbbleShots</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&#x3C;<span class="hljs-title class_">DribbbleShotsProps</span> &#x26; <span class="hljs-title class_">ViewProps</span>> = <span class="hljs-function">() =></span> {
  ...

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">View</span>
      <span class="hljs-attr">pointerEvents</span>=<span class="hljs-string">{refreshing</span> ? '<span class="hljs-attr">none</span>' <span class="hljs-attr">:</span> '<span class="hljs-attr">auto</span>'}
      <span class="hljs-attr">style</span>=<span class="hljs-string">{</span>
        <span class="hljs-attr">flex:</span> <span class="hljs-attr">1</span>,
        <span class="hljs-attr">backgroundColor:</span> '#<span class="hljs-attr">333</span>',
      }
    ></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Animated.View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{[styles.refreshContainer,</span> <span class="hljs-attr">refreshContainerStyles</span>]}></span>
        {refreshing &#x26;&#x26; (
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Image</span>
            <span class="hljs-attr">source</span>=<span class="hljs-string">{animatedLogo}</span>
            <span class="hljs-attr">style</span>=<span class="hljs-string">{</span> <span class="hljs-attr">width:</span> <span class="hljs-attr">280</span>, <span class="hljs-attr">height:</span> '<span class="hljs-attr">100</span>%', <span class="hljs-attr">objectFit:</span> '<span class="hljs-attr">cover</span>' }
          /></span>
        )}

        <span class="hljs-tag">&#x3C;<span class="hljs-name">Animated.Image</span>
          <span class="hljs-attr">source</span>=<span class="hljs-string">{refreshIcon}</span>
          <span class="hljs-attr">style</span>=<span class="hljs-string">{[styles.refreshIcon,</span> <span class="hljs-attr">refreshIconStyles</span>]}
        /></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">Animated.View</span>></span>

    ...
</span></code></pre>
<p>마지막으로, refreshIconStyles를 업데이트하여 새로 고침 아이콘을 애니메이션 로고로 부드럽게 전환해보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> refreshIconStyles = <span class="hljs-title function_">useAnimatedStyle</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-keyword">const</span> scale = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, pullDownPosition.<span class="hljs-property">value</span> / <span class="hljs-number">75</span>));

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">opacity</span>: refreshing
      ? <span class="hljs-title function_">withDelay</span>(<span class="hljs-number">100</span>, <span class="hljs-title function_">withTiming</span>(<span class="hljs-number">0</span>, { <span class="hljs-attr">duration</span>: <span class="hljs-number">20</span> }))
      : <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, pullDownPosition.<span class="hljs-property">value</span> - <span class="hljs-number">25</span>) / <span class="hljs-number">50</span>,
    <span class="hljs-attr">transform</span>: [
      {
        <span class="hljs-attr">scaleX</span>: refreshing ? <span class="hljs-title function_">withTiming</span>(<span class="hljs-number">0.15</span>, { <span class="hljs-attr">duration</span>: <span class="hljs-number">120</span> }) : scale,
      },
      {
        <span class="hljs-attr">scaleY</span>: scale,
      },
      {
        <span class="hljs-attr">rotate</span>: <span class="hljs-string">`<span class="hljs-subst">${pullDownPosition.value * <span class="hljs-number">3</span>}</span>deg`</span>,
      },
    ],
    <span class="hljs-attr">backgroundColor</span>: refreshing ? <span class="hljs-string">'#fff'</span> : <span class="hljs-string">'transparent'</span>,
  };
}, [refreshing]);
</code></pre>
<p>마지막으로, 데이터를 로드하는 동안 스켈레톤 카드를 보여줄 것입니다:</p>
<pre><code class="hljs language-js">...

&#x3C;<span class="hljs-title class_">Animated</span>.<span class="hljs-property">FlatList</span>
  ...
  renderItem={<span class="hljs-function">(<span class="hljs-params">{ item, index }</span>) =></span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Card</span>
      <span class="hljs-attr">loading</span>=<span class="hljs-string">{refreshing}</span>
      <span class="hljs-attr">index</span>=<span class="hljs-string">{index}</span>
      <span class="hljs-attr">image</span>=<span class="hljs-string">{item.image}</span>
      <span class="hljs-attr">title</span>=<span class="hljs-string">{item.title}</span>
      <span class="hljs-attr">likes</span>=<span class="hljs-string">{item.likes}</span>
    /></span></span>
  )}
  onScroll={scrollHandler}
  scrollEventThrottle={<span class="hljs-number">16</span>}
/>
&#x3C;/<span class="hljs-title class_">Animated</span>.<span class="hljs-property">View</span>>

...
</code></pre>
<p>이러한 마지막 손짓으로, 새로 고침 애니메이션이 기능적이면서 시각적으로 매력적으로 완성되었습니다.</p>
<h1>활기찬 인상 깊은 애니메이션</h1>
<p>이제 창조의 시간입니다. 여기 창의성을 자극하고 다음 앱을 위한 몇 가지 아이디어를 제공할 인상적인 애니메이션의 선별된 목록이 준비되어 있습니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*KB2KSwJq06LLyzA2_t-h1w.gif" alt="Animation 1"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*6L8rnyxjfPF-leE0x3Kigg.gif" alt="Animation 2"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*Fb1kzeeAhQVNEf5TTAZlrg.gif" alt="Animated GIF"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*YU3TndEWRtBaNcjXf-JZVg.gif" alt="Animated GIF"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*sMa1sfIYa6Zsl8Co0bCsEQ.gif" alt="Animated GIF"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*N5X0Kbuz7jHxclWzBv-glw.gif" alt="Animated GIF"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*pZ8ddY3rFUoVBuTWAhRPTg.gif" alt="image1"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*bSPbDYoIz9zz3r2mCftWKw.gif" alt="image2"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*utIKDBZ3o_V_-ctf22CBSA.gif" alt="image3"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*Ti1YIVYL67ZQHWDXNX8ZzA.gif" alt="image4"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*948wumPUB-5spDMTYs0Odg.gif" alt="이미지1"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*V4UtSyfCN9DDpl70IxXSHA.gif" alt="이미지2"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*GA_UPaFN6krQMhRb3lGiqw.gif" alt="이미지3"></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*m4aMIvlIMY5WGmyFL8q2gA.gif" alt="이미지4"></p>
<h1>결론</h1>
<p>우리의 사용자 정의 새로 고침 애니메이션 자습서가 마무리되었습니다! 아마도 이것이 여러분의 프로젝트에 몇 가지 아이디어를 불러일으켰으면 좋겠네요. 다양한 애니메이션을 실험해보고 해당 앱의 사용자 경험을 어떻게 향상시킬 수 있는지 확인해 보는 것을 권장합니다.</p>
<p>기억하세요, 배우는 가장 좋은 방법은 직접 해보는 것이기 때문에 고유한 새로 고침 애니메이션을 만들어보는 것에 도전해 보세요. 즐거운 코딩 되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트 네이티브에서 Reanimated를 사용해 사용자 정의 새로고침 애니메이션 만들기","description":"","date":"2024-05-12 21:21","slug":"2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated","content":"\n\n## 간단한 애니메이션이 앱의 사용자 경험을 얼마나 높일 수 있는지 궁금했던 적이 있나요?\n\n잘 디자인된 애니메이션은 평범한 사용자 상호 작용을 진정으로 기억에 남는 경험으로 변화시킬 수 있습니다.\n\n이 포스트에서는 React Native와 Reanimated 라이브러리를 사용하여 모바일 앱에 맞춘 흥미로운 사용자 정의 '당겨서 새로고침' 애니메이션을 만드는 방법을 배우게 됩니다.\n\n## 그냥 React Native의 RefreshControl을 사용하는 것이 좋지 않을까요?\n\n\n\n리액트 네이티브로 모바일 애플리케이션을 개발할 때, Pull-to-refresh 기능을 구현하는 데 RefreshControl 컴포넌트를 주로 사용합니다.\n\n간단하고 직관적이지만, 꽤 기본적이며 제한된 사용자 정의 기능을 제공합니다. 이로 인해 여러분의 앱이 그저 다른 어떤 앱처럼 보이는 경우가 있을 수 있습니다.\n\n사용자 정의 애니메이션을 생성하면 앱의 모양과 느낌을 자유롭게 조절하여 브랜딩 및 디자인 언어와 완벽하게 일치시킬 수 있습니다. 이로써 앱이 더 독특하고 기억에 남는 사용자 경험을 제공하게 되어 앱이 더욱 독특하고 기억에 남게 만듭니다.\n\n## 왜 Animated가 아닌 Reanimated 라이브러리를 사용해야 하는가?\n\n\n\nReact Native에서 애니메이션에 관한 이야기가 나온다면, 두 가지 주요 라이브러리가 떠오르게 됩니다: 내장된 Animated 라이브러리와 더 고급화된 Reanimated 라이브러리가 있습니다.\n\nReanimated가 선호되는 이유는 몇 가지가 있습니다:\n\n- 성능:\nReanimated는 특히 복잡한 애니메이션에 대해 우수한 성능을 제공합니다. 네이티브 스레드를 활용하여 JavaScript 스레드 대신 작동함으로써 더 효율적으로 작동합니다. 이는 훨씬 부드러운 애니메이션을 가능하게 하며, 이는 원활한 사용자 경험을 위한 중요한 요소입니다.\n- 제스처 기반 애니메이션:\nReanimated는 더 복잡한 애니메이션 처리를 위한 더 나은 API를 제공하며, 제스처와 애니메이션의 더 섬세한 제어와 더 부드러운 통합을 가능케 합니다.\n- 선언적 접근: Animated와 달리, Reanimated는 애니메이션에 더 선언적인 접근 방식을 채용합니다. 이는 애니메이션이 더 복잡해지면서 이해하고 관리하기 쉬워집니다.\n\n# 시작하기\n\n\n\n이 튜토리얼에서는 간단한 앱을 향상시키고자 합니다. 이 앱은 FlatList에서 카드 형태로 표시되는 Dribbble 샷 목록을 보여줍니다. 우리의 목표는 사용자가 목록을 위로 당겼을 때 나타나는 사용자 정의 새로 고침 애니메이션을 추가하는 것입니다.\n\n## 프로젝트 복제 및 설정\n\n로컬 컴퓨터에서 저장소를 클론하고 프로젝트를 설정하기 위해 다음 단계를 따라주세요:\n\n저장소 복제:\n터미널을 열고 다음 명령어로 저장소를 클론하세요:\n\n\n\n```js\ngit clone https://github.com/teefouad/custom-rn-refresh-animation-start.git\n```\n\nVSCode에서 프로젝트 열기:\n이 강좌의 모든 코드는 app/index.tsx에 들어가기 때문에 해당 파일을 열어 다른 파일과 디렉터리를 무시할 수 있습니다.\n다음과 같은 내용이 표시됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png\" /\u003e\n\n의존성 설치:\n필요한 종속 항목을 설치하려면 npm install 또는 yarn을 실행하세요.\n\n\n\n프로젝트 실행하기:\nnpm start 또는 yarn start를 실행하여 프로젝트를 시작하세요. 이렇게 하면 Metro 번들러가 초기화되고 앱이 개발 모드로 실행됩니다.\n\n프로젝트가 설정되었으므로, 이제 우리는 흥미로운 부분으로 빠져들 준비가 되었습니다: 우리의 사용자 정의 새로고침 애니메이션 만들기!\n\n# 애니메이션 만들기: 상단 스크롤 감지\n\n사용자 정의 애니메이션을 만드는 첫 번째 단계는 FlatList가 맨 위로 스크롤되었을 때 감지하는 것입니다.\n\n\n\n이를 위해 Reanimated에서 useAnimatedScrollHandler를 사용할 것입니다. 이 훅은 최적화되고 성능이 좋은 방식으로 스크롤 이벤트를 처리할 수 있는 함수를 제공할 것입니다.\n\n1. 먼저, Reanimated에서 훅을 import 해야 합니다:\n\n```js\n/**\n * Dependency imports\n */\n\n import React from 'react';\n import { FlatList, StyleSheet, View, ViewProps } from 'react-native';\n import Animated, { useAnimatedScrollHandler } from 'react-native-reanimated';\n```\n\n2. useAnimatedScrollHandler를 사용하여 스크롤 핸들러를 생성하세요:\n\n\n\n```js\nconst DribbbleShots: React.FC\u003cDribbbleShotsProps \u0026 ViewProps\u003e = () =\u003e {\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) =\u003e {\n      console.log(event.contentOffset.y);\n    },\n  });\n\n  return (\n    ...\n```\n\n지금은 리스트 스크롤 위치를 기록하는 것으로 할게요.\n\n3. 리스트에 스크롤 핸들러를 연결해보세요. useAnimatedScrollHandler를 사용하여 만든 스크롤 이벤트 핸들러는 React Native의 FlatList와 호환되지 않을 것이므로 Reanimated에서 제공하는 FlatList로 대체해야 합니다.\n\n```js\nreturn (\n    \u003cView style={styles.root}\u003e\n      \u003cAnimated.FlatList\n        ...\n        onScroll={scrollHandler}\n        scrollEventThrottle={16} // 부드러운 성능을 위한 좋은 방법\n      /\u003e\n    \u003c/View\u003e\n);\n```\n\n\n\nscrollEventThrottle 속성은 스크롤 이벤트가 발생하는 빈도를 제어합니다. 여기서 값이 16이면 스크롤 이벤트를 대략 16밀리초마다 캡처합니다. 이렇게 하면 애니메이션이 부드럽고 반응이 빠릅니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1280/1*6cGVuwIPgf4QnLIC79xN7g.gif)\n\n이제 콘솔에 스크롤 위치를 단순히 기록하는 대신, 이를 공유 값에 저장합시다.\n\n다음과 같이 코드를 업데이트하세요:\n\n\n\n```js\nimport Animated, {\n  useAnimatedScrollHandler,\n  useSharedValue,\n} from 'react-native-reanimated';\n\n...\n\nconst DribbbleShots: React.FC\u003cDribbbleShotsProps \u0026 ViewProps\u003e = () =\u003e {\n  const scrollPosition = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) =\u003e {\n      scrollPosition.value = event.contentOffset.y;\n    },\n  });\n  ...\n```\n\n# 단계 2: 팬 제스처 캡처하기\n\n이제 목록이 화면 상단까지 스크롤된 것을 감지할 수 있게 되었으므로, 다음 단계는 사용자가 목록을 더 아래로 끌 때 팬 제스처를 캡처하는 것입니다. 이를 달성하기 위해 FlatList의 부모 View에 PanResponder를 사용할 것입니다.\n\n팬 응답자(pan responder)를 생성하기 위해 React Native에서 PanResponder를 가져오세요:\n\n\n\n```js\nimport {\n  PanResponder,\n  StyleSheet,\n  View,\n  ViewProps,\n} from 'react-native';\n```\n\n그런 다음 PanResponder의 인스턴스를 저장하고 FlatList의 부모 View에 연결하기 위해 ref를 사용하십시오:\n\n```js\nconst DribbbleShots: React.FC\u003cDribbbleShotsProps \u0026 ViewProps\u003e = () =\u003e {\n  ...\n\n  const panResponderRef = React.useRef(\n    PanResponder.create({\n      onMoveShouldSetPanResponder: () =\u003e true,\n      onPanResponderMove: (event, gestureState) =\u003e {\n        console.log(gestureState.dy);\n      },\n    })\n  );\n\n  return (\n    \u003cView\n      style={styles.root}\n      {...panResponderRef.current.panHandlers}\n    \u003e\n      \u003cAnimated.FlatList\n        ...\n```\n\n이 코드를 자세히 살펴보고 각 부분이 하는 일을 이해해보겠습니다:\n\n\n\nPanResponder.create()\n이 함수 호출은 PanResponder 인스턴스를 만들며 터치 동작에 대한 앱의 응답 방법을 설명하는 객체를 받습니다. 그리고 PanResponder는 React Ref에 저장됩니다.\n\nonMoveShouldSetPanResponder: () =` true,\n터치 동작 중 움직임이 있을 때 호출되는 함수입니다. 여기서 true를 반환하면 사용자가 손가락을 움직일 때 Pan Responder가 계속해서 동작을 처리합니다.\n\nonPanResponderMove: (event, gestureState) =` ' ... '\n응답해야 할 제스처가 있으면, 이 함수는 제스처 동작 중 움직임이 발생할 때 실행됩니다.\n\ngestureState는 현재 제스처에 대한 다양한 데이터를 포함하는 객체로, 터치의 위치, 전체 움직임 등을 나타냅니다. 우리는 gestureState.dy에만 관심이 있으며, 이 값은 제스처 시작부터 Y방향으로 얼마나 움직였는지를 나타냅니다. 사용자가 얼마나 아래로 당겼는지를 추적하는 데 사용할 것입니다.\n\n\n\n현재 목록을 스크롤하려고 하면 응답하지 않는 것 같아요. 이것은 우리의 PanResponder가 계속해서 모든 팬 제스처를 캡처하기 때문에 발생합니다. 결과적으로 목록은 팬 제스처가 발생했음을 처리할 수 없죠. 일단 괜찮아요, 나중에 이 문제를 해결할 거예요.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*JeG4IxcnUQdpcaBdWBzMnA.gif\" /\u003e\n\n이제 이동 값을 갖게 됐으니, 이 값을 활용해봅시다. 새로운 공유 값(shared value)을 생성하고 이동 값을 저장하는데 사용해요. 이 공유 값은 목록을 애니메이션화하는 데 활용할 수 있어요.\n\n```js\n...\n\nconst pullDownPosition = useSharedValue(0);\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    onMoveShouldSetPanResponder: () =\u003e true,\n    onPanResponderMove: (event, gestureState) =\u003e {\n      pullDownPosition.value = gestureState.dy;\n    },\n  })\n);\n\n...\n```\n\n\n\n다음 단계는 Reanimated의 useAnimatedStyle 훅을 사용하여 일부 스타일을 생성하고 적용하는 것입니다. 이 훅은 Reanimated에서 제공되며 공유 값이나 다른 반응형 변수에 기반한 동적 스타일을 생성할 수 있게 해줍니다.\n\n참고: 스타일을 목록 자체가 아닌 목록 부모 View에 적용해야 합니다. 또한 React Native의 View가 아닌 Animated.View를 사용해야 합니다.\n\n```js\n...\nimport Animated, {\n  useSharedValue,\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n} from 'react-native-reanimated';\n\n...\n\nconst pullDownStyles = useAnimatedStyle(() =\u003e {\n  return {\n    transform: [\n      {\n        translateY: pullDownPosition.value,\n      },\n    ],\n  };\n});\n\nreturn (\n  \u003cAnimated.View\n    style={[styles.root, pullDownStyles]}\n    {...panResponderRef.current.panHandlers}\n  \u003e\n    \u003cAnimated.FlatList\n      data={data}\n      ...\n```\n\n\n\n저희 코드를 약간 수정하여 사용자가 목록을 아래로 당길 수는 있지만 상단 경계를 넘어서 올릴 수 없도록 해보겠습니다:\n\n```js\n...\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n\n    onPanResponderMove: (event, gestureState) =\u003e {\n      pullDownPosition.value = Math.max(gestureState.dy, 0);\n    },\n  })\n);\n...\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*FTJzKVw9pWxBXYxL4Nrf1g.gif\" /\u003e\n\n풀다운 애니메이션을 완성하기 위해, 팬 제스처가 해제될 때 pullDownPosition 공유 값을 제로로 재설정해보겠습니다. Reanimated는 공유 값을 애니메이션화할 수 있는 일련의 애니메이션 유틸리티 함수를 제공합니다. 이 경우에는 pullDownPosition 값을 매끄럽게 제로로 애니메이션화하기 위해 withTiming 함수를 사용하겠습니다.\n\n\n\n```js\n...\nimport Animated, {\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n  useSharedValue,\n  withTiming,\n} from 'react-native-reanimated';\n\n...\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderRelease: () =\u003e {\n      pullDownPosition.value = withTiming(0, { duration: 180 });\n    },\n  })\n);\n```\n\n팬 제스처는 다른 제스처나 작업에 의해 조기에 종료되거나 중단될 수 있습니다. 다양한 상호 작용 시나리오에서 일관된 신뢰할 수 있는 사용자 경험을 보장하기 위해 onPanResponderRelease와 함께 onPanResponderTerminate도 사용합시다:\n\n```js\n...\n\nconst onPanRelease = () =\u003e {\n  pullDownPosition.value = withTiming(0, { duration: 180 });\n};\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderRelease: onPanRelease,\n    onPanResponderTerminate: onPanRelease,\n  })\n);\n\n...\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*9K8kEfhq4VnhQPZoe60Pfw.gif\" /\u003e\n\n\n\n# 단계 3: 목록의 스크롤 동작 복원하기\n\n간단한 작동하는 풀다운 애니메이션이 있지만, 목록의 정상적인 스크롤 동작이 보존되고 올바르게 작동하는지 확인해야 합니다.\n\nonMoveShouldSetPanResponder로 돌아가서 항상 true를 반환하는 대신 의미있는 것을 반환하도록 하겠습니다. 목록이 맨 위로 스크롤되고 사용자가 목록을 더 아래로 밀어내는 경우에만 풀다운 제스처를 허용할 것입니다. 이는 아래와 같이 해석됩니다:\n\n```js\n...\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    onMoveShouldSetPanResponder: (event, gestureState) =\u003e\n      scrollPosition.value \u003c= 0 \u0026\u0026 gestureState.dy \u003e= 0,\n    onPanResponderMove: (event, gestureState) =\u003e {\n      pullDownPosition.value = Math.max(gestureState.dy, 0);\n    },\n...\n``` \n\n\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*URAgW2RXvWsWs1YxrTLL6g.gif\" /\u003e\n\n잘 했어요! 목록이 이제 제대로 작동하고 풀다운 애니메이션이 의도대로 트리거되어 멋진 일을 해냈어요!\n\n이제 잠시 쉬는 시간이에요. 커피 한 잔을 즐기세요 ☕, 몇 분 휴식을 취한 후에 마지막 단계로 넘어갈게요.\n\n# 마지막 단계: 새로고침 트리거하기\n\n\n\n이제 튜토리얼의 가장 중요한 부분에 도달했어요. 여기서는 실제로 새로 고침 동작을 트리거할 수 있도록 로직을 설정하는 방법을 알아볼 거에요. 현재 사용자들은 목록을 아래로 내릴 수 있지만, 제약을 추가하고 언제 새로 고침을 활성화해야 하는지 정의하고 싶어요.\n\n## 최대 아래로 당기기 거리 설정\n\n지금 사용자들은 화면 아래쪽까지 목록을 아래로 끌어 내릴 수 있어요. 이것은 자연스럽지 않고 직관적이지 않게 느껴지죠. 그래서 우리는 아래로 당기는 거리를 최대 150픽셀로 제한할 거에요.\n\n```js\n...\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderMove: (event, gestureState) =\u003e {\n      const maxDistance = 150;\n      pullDownPosition.value = Math.max(Math.min(maxDistance, gestureState.dy), 0);\n    },\n...\n```\n\n\n\n## 새로고침 트리거 지점 결정하기\n\n사용자가 이 150픽셀 범위의 절반 이상으로 당겼을 때, 새로고침 액션이 트리거될 준비가 된 것으로 간주합니다. 이 지점을 넘어서 제스처를 놓으면 새로고침 액션이 시작됩니다.\n\n```js\n...\nconst pullDownPosition = useSharedValue(0);\nconst isReadyToRefresh = useSharedValue(false);\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderMove: (event, gestureState) =\u003e {\n      const maxDistance = 150;\n      pullDownPosition.value = Math.max(Math.min(maxDistance, gestureState.dy), 0);\n\n      if (\n        pullDownPosition.value \u003e= maxDistance / 2 \u0026\u0026\n        isReadyToRefresh.value === false\n      ) {\n        isReadyToRefresh.value = true;\n        console.log('새로고침할 준비 완료');\n      }\n\n      if (\n        pullDownPosition.value \u003c maxDistance / 2 \u0026\u0026\n        isReadyToRefresh.value === true\n      ) {\n        isReadyToRefresh.value = false;\n        console.log('릴리스 시 새로고침하지 않음');\n      }\n    },\n...\n```\n\n공유 값 isReadyToRefresh는 목록을 충분히 당겼는지 여부를 나타냅니다. 이제는 제스처 릴리스 처리 논리를 업데이트해봅시다:\n\n\n\n```js\n...\n\nconst onPanRelease = () =\u003e {\n  pullDownPosition.value = withTiming(isReadyToRefresh.value ? 75 : 0, {\n    duration: 180,\n  });\n\n  if (isReadyToRefresh.value) {\n    isReadyToRefresh.value = false;\n\n    // 새로고침 실행\n  }\n};\n\nconst panResponderRef = React.useRef(\n  PanResponder.create({\n    ...\n    onPanResponderRelease: onPanRelease,\n    onPanResponderTerminate: onPanRelease,\n  })\n);\n...\n```\n\n새로고침 작업을 트리거하는 메커니즘이 마련되었으니, 제스처(팬 릴리스)의 끝을 처리해봅시다.\n\n## 새로고침 작업 트리거\n\n사용자의 제스처가 끝나고 새로고침 작업 준비가 완료되면, onRefresh 함수를 호출할 것입니다. 이 함수는 하나의 매개변수를 받습니다. 해당 매개변수는 새로고침 작업이 완료된 후 애니메이션을 재설정할 done 함수입니다.\n\n\n\n```js\n...\n\nconst pullDownPosition = useSharedValue(0);\nconst isReadyToRefresh = useSharedValue(false);\n\nconst onRefresh = (done: () =\u003e void) =\u003e {\n  console.log('새로 고침 중...');\n\n  setTimeout(() =\u003e {\n    console.log('새로 고침 완료!');\n    done();\n  }, 7500);\n};\n\nconst onPanRelease = () =\u003e {\n  pullDownPosition.value = withTiming(isReadyToRefresh.value ? 75 : 0, {\n    duration: 180,\n  });\n\n  if (isReadyToRefresh.value) {\n    isReadyToRefresh.value = false;\n\n    // 애니메이션을 재설정하는 함수\n    const onRefreshComplete = () =\u003e {\n      pullDownPosition.value = withTiming(0, { duration: 180 });\n    };\n\n    // 새로 고침 작업 실행\n    onRefresh(onRefreshComplete);\n  }\n};\n\n...\n```\n\n`onRefresh` 함수는 setTimeout을 사용하여 새로 고침 프로세스를 시뮬레이션합니다(실제 데이터 가져오기 프로세스의 가상 대체물로). 데이터가 새로 고쳐지면 애니메이션을 재설정하기 위해 `done` 콜백이 호출됩니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*qtBcIAWfx4fISFDhdmreFw.gif\" /\u003e\n\n# 애니메이션 구축하기\n\n\n\n이제 useAnimatedStyle 훅을 사용하여 새로 고침 애니메이션을 활성화할 준비가 되었습니다. 몇 가지 애니메이션 컴포넌트로 UI를 개선하면서 시작해 봅시다.\n\n## 배경 설정\n\n먼저, 애니메이션을 위한 배경을 만들겠습니다. 주요 UI를 View로 감싸고 기본 스타일을 적용하세요:\n\n```js\n...\n\nreturn (\n  \u003cView\n    style={{\n      flex: 1,\n      backgroundColor: '#333',\n    }}\n  \u003e\n    \u003cAnimated.View\n      style={[styles.root, pullDownStyles]}\n      {...panResponderRef.current.panHandlers}\n    \u003e\n      \u003cAnimated.FlatList\n        ...\n      /\u003e\n    \u003c/Animated.View\u003e\n  \u003c/View\u003e\n);\n\n...\n```\n\n\n\n뷰는 애니메이션을 강조하는 어두운 배경을 제공하는 컨테이너 역할을 합니다.\n\n## 새로 고침 아이콘 통합\n\n다음으로, 회전하는 새로 고침 아이콘을 추가해 봅시다. 이 아이콘을 풀 다운 위치에 따라 확대 및 회전되도록 애니메이션화할 것입니다:\n\n```js\nconst DribbbleShots: React.FC\u003cDribbbleShotsProps \u0026 ViewProps\u003e = () =\u003e {\n  ...\n\n  const refreshContainerStyles = useAnimatedStyle(() =\u003e {\n    return {\n      height: pullDownPosition.value,\n    };\n  });\n\n  const refreshIconStyles = useAnimatedStyle(() =\u003e {\n    const scale = Math.min(1, Math.max(0, pullDownPosition.value / 75));\n\n    return {\n      opacity: Math.max(0, pullDownPosition.value - 25) / 50,\n      transform: [\n        {\n          scale: scale,\n        },\n        {\n          rotate: `${pullDownPosition.value * 3}deg`,\n        },\n      ],\n    };\n  });\n\n  return (\n    [styles.refreshContainer, refreshContainerStyles]}\u003e\n        \u003cAnimated.Image\n          source={refreshIcon}\n          style={[styles.refreshIcon, refreshIconStyles]}\n        /\u003e\n      \u003c/Animated.View\u003e\n\n      ...\n    \u003c/View\u003e\n  );\n};\n```\n\n\n\n\n![Loading animation](https://miro.medium.com/v2/resize:fit:1400/1*OVJMKGr9f4IJG3Ou7KTUjA.gif)\n\n이제 '새로 고침 중...'이라는 단어를 단순히 기록하는 대신 상태 값을 사용하여 UI를 업데이트하고 새로 고침이 진행 중임을 나타내겠습니다:\n\n```js\n...\n\nconst DribbbleShots: React.FC\u003cDribbbleShotsProps \u0026 ViewProps\u003e = () =\u003e {\n  ...\n\n  const pullDownPosition = useSharedValue(0);\n  const isReadyToRefresh = useSharedValue(false);\n  const [refreshing, setRefreshing] = React.useState(false);\n\n  const onRefresh = (done: () =\u003e void) =\u003e {\n    setRefreshing(true);\n\n    setTimeout(() =\u003e {\n      setRefreshing(false);\n      done();\n    }, 7500);\n  };\n\n  ...\n\n  return (\n    \u003cView\n      pointerEvents={refreshing ? 'none' : 'auto'}\n      style={\n        flex: 1,\n        backgroundColor: '#333',\n      }\n    \u003e\n\n    ...\n```\n\n데이터가 아직로드 중인 동안 원치 않는 pull-down 제스처를 제어하고 방지하려면 pointerEvents 속성을 추가했습니다.\n\n\n\n\n## 로고 애니메이션 구현하기\n\n조금 더 재미있게 만들기 위해 애니메이션 로고를 추가해봅시다. 사용한 애니메이션 로고는 원래 Tony Pinkevych가 Dribbble에서 만들었고, 저는 이 데모에 맞게 약간 수정했습니다.\n\n```js\n/**\n * 의존성 가져오기\n */\n\nimport React from 'react';\nimport { Image } from 'expo-image';\n\n...\n\nconst DribbbleShots: React.FC\u003cDribbbleShotsProps \u0026 ViewProps\u003e = () =\u003e {\n  ...\n\n  return (\n    \u003cView\n      pointerEvents={refreshing ? 'none' : 'auto'}\n      style={\n        flex: 1,\n        backgroundColor: '#333',\n      }\n    \u003e\n      \u003cAnimated.View style={[styles.refreshContainer, refreshContainerStyles]}\u003e\n        {refreshing \u0026\u0026 (\n          \u003cImage\n            source={animatedLogo}\n            style={ width: 280, height: '100%', objectFit: 'cover' }\n          /\u003e\n        )}\n\n        \u003cAnimated.Image\n          source={refreshIcon}\n          style={[styles.refreshIcon, refreshIconStyles]}\n        /\u003e\n      \u003c/Animated.View\u003e\n\n    ...\n```\n\n마지막으로, refreshIconStyles를 업데이트하여 새로 고침 아이콘을 애니메이션 로고로 부드럽게 전환해보겠습니다.\n\n\n\n```js\nconst refreshIconStyles = useAnimatedStyle(() =\u003e {\n  const scale = Math.min(1, Math.max(0, pullDownPosition.value / 75));\n\n  return {\n    opacity: refreshing\n      ? withDelay(100, withTiming(0, { duration: 20 }))\n      : Math.max(0, pullDownPosition.value - 25) / 50,\n    transform: [\n      {\n        scaleX: refreshing ? withTiming(0.15, { duration: 120 }) : scale,\n      },\n      {\n        scaleY: scale,\n      },\n      {\n        rotate: `${pullDownPosition.value * 3}deg`,\n      },\n    ],\n    backgroundColor: refreshing ? '#fff' : 'transparent',\n  };\n}, [refreshing]);\n```\n\n마지막으로, 데이터를 로드하는 동안 스켈레톤 카드를 보여줄 것입니다:\n\n```js\n...\n\n\u003cAnimated.FlatList\n  ...\n  renderItem={({ item, index }) =\u003e (\n    \u003cCard\n      loading={refreshing}\n      index={index}\n      image={item.image}\n      title={item.title}\n      likes={item.likes}\n    /\u003e\n  )}\n  onScroll={scrollHandler}\n  scrollEventThrottle={16}\n/\u003e\n\u003c/Animated.View\u003e\n\n...\n```\n\n이러한 마지막 손짓으로, 새로 고침 애니메이션이 기능적이면서 시각적으로 매력적으로 완성되었습니다.\n\n\n\n# 활기찬 인상 깊은 애니메이션\n\n이제 창조의 시간입니다. 여기 창의성을 자극하고 다음 앱을 위한 몇 가지 아이디어를 제공할 인상적인 애니메이션의 선별된 목록이 준비되어 있습니다.\n\n![Animation 1](https://miro.medium.com/v2/resize:fit:1400/1*KB2KSwJq06LLyzA2_t-h1w.gif)\n\n![Animation 2](https://miro.medium.com/v2/resize:fit:1400/1*6L8rnyxjfPF-leE0x3Kigg.gif)\n\n\n\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*Fb1kzeeAhQVNEf5TTAZlrg.gif)\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*YU3TndEWRtBaNcjXf-JZVg.gif)\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*sMa1sfIYa6Zsl8Co0bCsEQ.gif)\n\n![Animated GIF](https://miro.medium.com/v2/resize:fit:1400/1*N5X0Kbuz7jHxclWzBv-glw.gif)\n\n\n\n![image1](https://miro.medium.com/v2/resize:fit:1400/1*pZ8ddY3rFUoVBuTWAhRPTg.gif)\n\n![image2](https://miro.medium.com/v2/resize:fit:1400/1*bSPbDYoIz9zz3r2mCftWKw.gif)\n\n![image3](https://miro.medium.com/v2/resize:fit:1400/1*utIKDBZ3o_V_-ctf22CBSA.gif)\n\n![image4](https://miro.medium.com/v2/resize:fit:1400/1*Ti1YIVYL67ZQHWDXNX8ZzA.gif)\n\n\n\n![이미지1](https://miro.medium.com/v2/resize:fit:1400/1*948wumPUB-5spDMTYs0Odg.gif)\n\n![이미지2](https://miro.medium.com/v2/resize:fit:1400/1*V4UtSyfCN9DDpl70IxXSHA.gif)\n\n![이미지3](https://miro.medium.com/v2/resize:fit:1400/1*GA_UPaFN6krQMhRb3lGiqw.gif)\n\n![이미지4](https://miro.medium.com/v2/resize:fit:1400/1*m4aMIvlIMY5WGmyFL8q2gA.gif)\n\n\n\n# 결론\n\n우리의 사용자 정의 새로 고침 애니메이션 자습서가 마무리되었습니다! 아마도 이것이 여러분의 프로젝트에 몇 가지 아이디어를 불러일으켰으면 좋겠네요. 다양한 애니메이션을 실험해보고 해당 앱의 사용자 경험을 어떻게 향상시킬 수 있는지 확인해 보는 것을 권장합니다.\n\n기억하세요, 배우는 가장 좋은 방법은 직접 해보는 것이기 때문에 고유한 새로 고침 애니메이션을 만들어보는 것에 도전해 보세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png","tag":["Tech"],"readingTime":18},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e간단한 애니메이션이 앱의 사용자 경험을 얼마나 높일 수 있는지 궁금했던 적이 있나요?\u003c/h2\u003e\n\u003cp\u003e잘 디자인된 애니메이션은 평범한 사용자 상호 작용을 진정으로 기억에 남는 경험으로 변화시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 포스트에서는 React Native와 Reanimated 라이브러리를 사용하여 모바일 앱에 맞춘 흥미로운 사용자 정의 '당겨서 새로고침' 애니메이션을 만드는 방법을 배우게 됩니다.\u003c/p\u003e\n\u003ch2\u003e그냥 React Native의 RefreshControl을 사용하는 것이 좋지 않을까요?\u003c/h2\u003e\n\u003cp\u003e리액트 네이티브로 모바일 애플리케이션을 개발할 때, Pull-to-refresh 기능을 구현하는 데 RefreshControl 컴포넌트를 주로 사용합니다.\u003c/p\u003e\n\u003cp\u003e간단하고 직관적이지만, 꽤 기본적이며 제한된 사용자 정의 기능을 제공합니다. 이로 인해 여러분의 앱이 그저 다른 어떤 앱처럼 보이는 경우가 있을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e사용자 정의 애니메이션을 생성하면 앱의 모양과 느낌을 자유롭게 조절하여 브랜딩 및 디자인 언어와 완벽하게 일치시킬 수 있습니다. 이로써 앱이 더 독특하고 기억에 남는 사용자 경험을 제공하게 되어 앱이 더욱 독특하고 기억에 남게 만듭니다.\u003c/p\u003e\n\u003ch2\u003e왜 Animated가 아닌 Reanimated 라이브러리를 사용해야 하는가?\u003c/h2\u003e\n\u003cp\u003eReact Native에서 애니메이션에 관한 이야기가 나온다면, 두 가지 주요 라이브러리가 떠오르게 됩니다: 내장된 Animated 라이브러리와 더 고급화된 Reanimated 라이브러리가 있습니다.\u003c/p\u003e\n\u003cp\u003eReanimated가 선호되는 이유는 몇 가지가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e성능:\nReanimated는 특히 복잡한 애니메이션에 대해 우수한 성능을 제공합니다. 네이티브 스레드를 활용하여 JavaScript 스레드 대신 작동함으로써 더 효율적으로 작동합니다. 이는 훨씬 부드러운 애니메이션을 가능하게 하며, 이는 원활한 사용자 경험을 위한 중요한 요소입니다.\u003c/li\u003e\n\u003cli\u003e제스처 기반 애니메이션:\nReanimated는 더 복잡한 애니메이션 처리를 위한 더 나은 API를 제공하며, 제스처와 애니메이션의 더 섬세한 제어와 더 부드러운 통합을 가능케 합니다.\u003c/li\u003e\n\u003cli\u003e선언적 접근: Animated와 달리, Reanimated는 애니메이션에 더 선언적인 접근 방식을 채용합니다. 이는 애니메이션이 더 복잡해지면서 이해하고 관리하기 쉬워집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e시작하기\u003c/h1\u003e\n\u003cp\u003e이 튜토리얼에서는 간단한 앱을 향상시키고자 합니다. 이 앱은 FlatList에서 카드 형태로 표시되는 Dribbble 샷 목록을 보여줍니다. 우리의 목표는 사용자가 목록을 위로 당겼을 때 나타나는 사용자 정의 새로 고침 애니메이션을 추가하는 것입니다.\u003c/p\u003e\n\u003ch2\u003e프로젝트 복제 및 설정\u003c/h2\u003e\n\u003cp\u003e로컬 컴퓨터에서 저장소를 클론하고 프로젝트를 설정하기 위해 다음 단계를 따라주세요:\u003c/p\u003e\n\u003cp\u003e저장소 복제:\n터미널을 열고 다음 명령어로 저장소를 클론하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003egit clone \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//github.com/teefouad/custom-rn-refresh-animation-start.git\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVSCode에서 프로젝트 열기:\n이 강좌의 모든 코드는 app/index.tsx에 들어가기 때문에 해당 파일을 열어 다른 파일과 디렉터리를 무시할 수 있습니다.\n다음과 같은 내용이 표시됩니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated_0.png\"\u003e\n\u003cp\u003e의존성 설치:\n필요한 종속 항목을 설치하려면 npm install 또는 yarn을 실행하세요.\u003c/p\u003e\n\u003cp\u003e프로젝트 실행하기:\nnpm start 또는 yarn start를 실행하여 프로젝트를 시작하세요. 이렇게 하면 Metro 번들러가 초기화되고 앱이 개발 모드로 실행됩니다.\u003c/p\u003e\n\u003cp\u003e프로젝트가 설정되었으므로, 이제 우리는 흥미로운 부분으로 빠져들 준비가 되었습니다: 우리의 사용자 정의 새로고침 애니메이션 만들기!\u003c/p\u003e\n\u003ch1\u003e애니메이션 만들기: 상단 스크롤 감지\u003c/h1\u003e\n\u003cp\u003e사용자 정의 애니메이션을 만드는 첫 번째 단계는 FlatList가 맨 위로 스크롤되었을 때 감지하는 것입니다.\u003c/p\u003e\n\u003cp\u003e이를 위해 Reanimated에서 useAnimatedScrollHandler를 사용할 것입니다. 이 훅은 최적화되고 성능이 좋은 방식으로 스크롤 이벤트를 처리할 수 있는 함수를 제공할 것입니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e먼저, Reanimated에서 훅을 import 해야 합니다:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/**\n * Dependency imports\n */\u003c/span\u003e\n\n \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eFlatList\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eStyleSheet\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eViewProps\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native'\u003c/span\u003e;\n \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimated\u003c/span\u003e, { useAnimatedScrollHandler } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native-reanimated'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003euseAnimatedScrollHandler를 사용하여 스크롤 핸들러를 생성하세요:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDribbbleShots\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDribbbleShotsProps\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eViewProps\u003c/span\u003e\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scrollHandler = \u003cspan class=\"hljs-title function_\"\u003euseAnimatedScrollHandler\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eonScroll\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(event.\u003cspan class=\"hljs-property\"\u003econtentOffset\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e);\n    },\n  });\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e지금은 리스트 스크롤 위치를 기록하는 것으로 할게요.\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e리스트에 스크롤 핸들러를 연결해보세요. useAnimatedScrollHandler를 사용하여 만든 스크롤 이벤트 핸들러는 React Native의 FlatList와 호환되지 않을 것이므로 Reanimated에서 제공하는 FlatList로 대체해야 합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.root}\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eAnimated.FlatList\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003e...\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eonScroll\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{scrollHandler}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003escrollEventThrottle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{16}\u003c/span\u003e // \u003cspan class=\"hljs-attr\"\u003e부드러운\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e성능을\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e위한\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e좋은\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e방법\u003c/span\u003e\n      /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003escrollEventThrottle 속성은 스크롤 이벤트가 발생하는 빈도를 제어합니다. 여기서 값이 16이면 스크롤 이벤트를 대략 16밀리초마다 캡처합니다. 이렇게 하면 애니메이션이 부드럽고 반응이 빠릅니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*6cGVuwIPgf4QnLIC79xN7g.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 콘솔에 스크롤 위치를 단순히 기록하는 대신, 이를 공유 값에 저장합시다.\u003c/p\u003e\n\u003cp\u003e다음과 같이 코드를 업데이트하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimated\u003c/span\u003e, {\n  useAnimatedScrollHandler,\n  useSharedValue,\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native-reanimated'\u003c/span\u003e;\n\n...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDribbbleShots\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDribbbleShotsProps\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eViewProps\u003c/span\u003e\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scrollPosition = \u003cspan class=\"hljs-title function_\"\u003euseSharedValue\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scrollHandler = \u003cspan class=\"hljs-title function_\"\u003euseAnimatedScrollHandler\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eonScroll\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      scrollPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = event.\u003cspan class=\"hljs-property\"\u003econtentOffset\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e;\n    },\n  });\n  ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 2: 팬 제스처 캡처하기\u003c/h1\u003e\n\u003cp\u003e이제 목록이 화면 상단까지 스크롤된 것을 감지할 수 있게 되었으므로, 다음 단계는 사용자가 목록을 더 아래로 끌 때 팬 제스처를 캡처하는 것입니다. 이를 달성하기 위해 FlatList의 부모 View에 PanResponder를 사용할 것입니다.\u003c/p\u003e\n\u003cp\u003e팬 응답자(pan responder)를 생성하기 위해 React Native에서 PanResponder를 가져오세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003ePanResponder\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eStyleSheet\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eViewProps\u003c/span\u003e,\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 PanResponder의 인스턴스를 저장하고 FlatList의 부모 View에 연결하기 위해 ref를 사용하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDribbbleShots\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDribbbleShotsProps\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eViewProps\u003c/span\u003e\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  ...\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e panResponderRef = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseRef\u003c/span\u003e(\n    \u003cspan class=\"hljs-title class_\"\u003ePanResponder\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003eonMoveShouldSetPanResponder\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eonPanResponderMove\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent, gestureState\u003c/span\u003e) =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(gestureState.\u003cspan class=\"hljs-property\"\u003edy\u003c/span\u003e);\n      },\n    })\n  );\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u0026#x3C;View\n      style={styles.root}\n      {...panResponderRef.current.panHandlers}\n    \u003e\n      \u0026#x3C;Animated.FlatList\n        ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드를 자세히 살펴보고 각 부분이 하는 일을 이해해보겠습니다:\u003c/p\u003e\n\u003cp\u003ePanResponder.create()\n이 함수 호출은 PanResponder 인스턴스를 만들며 터치 동작에 대한 앱의 응답 방법을 설명하는 객체를 받습니다. 그리고 PanResponder는 React Ref에 저장됩니다.\u003c/p\u003e\n\u003cp\u003eonMoveShouldSetPanResponder: () =` true,\n터치 동작 중 움직임이 있을 때 호출되는 함수입니다. 여기서 true를 반환하면 사용자가 손가락을 움직일 때 Pan Responder가 계속해서 동작을 처리합니다.\u003c/p\u003e\n\u003cp\u003eonPanResponderMove: (event, gestureState) =` ' ... '\n응답해야 할 제스처가 있으면, 이 함수는 제스처 동작 중 움직임이 발생할 때 실행됩니다.\u003c/p\u003e\n\u003cp\u003egestureState는 현재 제스처에 대한 다양한 데이터를 포함하는 객체로, 터치의 위치, 전체 움직임 등을 나타냅니다. 우리는 gestureState.dy에만 관심이 있으며, 이 값은 제스처 시작부터 Y방향으로 얼마나 움직였는지를 나타냅니다. 사용자가 얼마나 아래로 당겼는지를 추적하는 데 사용할 것입니다.\u003c/p\u003e\n\u003cp\u003e현재 목록을 스크롤하려고 하면 응답하지 않는 것 같아요. 이것은 우리의 PanResponder가 계속해서 모든 팬 제스처를 캡처하기 때문에 발생합니다. 결과적으로 목록은 팬 제스처가 발생했음을 처리할 수 없죠. 일단 괜찮아요, 나중에 이 문제를 해결할 거예요.\u003c/p\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*JeG4IxcnUQdpcaBdWBzMnA.gif\"\u003e\n\u003cp\u003e이제 이동 값을 갖게 됐으니, 이 값을 활용해봅시다. 새로운 공유 값(shared value)을 생성하고 이동 값을 저장하는데 사용해요. 이 공유 값은 목록을 애니메이션화하는 데 활용할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pullDownPosition = \u003cspan class=\"hljs-title function_\"\u003euseSharedValue\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e panResponderRef = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseRef\u003c/span\u003e(\n  \u003cspan class=\"hljs-title class_\"\u003ePanResponder\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eonMoveShouldSetPanResponder\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eonPanResponderMove\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent, gestureState\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = gestureState.\u003cspan class=\"hljs-property\"\u003edy\u003c/span\u003e;\n    },\n  })\n);\n\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 단계는 Reanimated의 useAnimatedStyle 훅을 사용하여 일부 스타일을 생성하고 적용하는 것입니다. 이 훅은 Reanimated에서 제공되며 공유 값이나 다른 반응형 변수에 기반한 동적 스타일을 생성할 수 있게 해줍니다.\u003c/p\u003e\n\u003cp\u003e참고: 스타일을 목록 자체가 아닌 목록 부모 View에 적용해야 합니다. 또한 React Native의 View가 아닌 Animated.View를 사용해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimated\u003c/span\u003e, {\n  useSharedValue,\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native-reanimated'\u003c/span\u003e;\n\n...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pullDownStyles = \u003cspan class=\"hljs-title function_\"\u003euseAnimatedStyle\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003etransform\u003c/span\u003e: [\n      {\n        \u003cspan class=\"hljs-attr\"\u003etranslateY\u003c/span\u003e: pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e,\n      },\n    ],\n  };\n});\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n  \u0026#x3C;Animated.View\n    style={[styles.root, pullDownStyles]}\n    {...panResponderRef.current.panHandlers}\n  \u003e\n    \u0026#x3C;Animated.FlatList\n      data={data}\n      ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e저희 코드를 약간 수정하여 사용자가 목록을 아래로 당길 수는 있지만 상단 경계를 넘어서 올릴 수 없도록 해보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e panResponderRef = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseRef\u003c/span\u003e(\n  \u003cspan class=\"hljs-title class_\"\u003ePanResponder\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({\n    ...\n\n    \u003cspan class=\"hljs-attr\"\u003eonPanResponderMove\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent, gestureState\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(gestureState.\u003cspan class=\"hljs-property\"\u003edy\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n    },\n  })\n);\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*FTJzKVw9pWxBXYxL4Nrf1g.gif\"\u003e\n\u003cp\u003e풀다운 애니메이션을 완성하기 위해, 팬 제스처가 해제될 때 pullDownPosition 공유 값을 제로로 재설정해보겠습니다. Reanimated는 공유 값을 애니메이션화할 수 있는 일련의 애니메이션 유틸리티 함수를 제공합니다. 이 경우에는 pullDownPosition 값을 매끄럽게 제로로 애니메이션화하기 위해 withTiming 함수를 사용하겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimated\u003c/span\u003e, {\n  useAnimatedScrollHandler,\n  useAnimatedStyle,\n  useSharedValue,\n  withTiming,\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-native-reanimated'\u003c/span\u003e;\n\n...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e panResponderRef = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseRef\u003c/span\u003e(\n  \u003cspan class=\"hljs-title class_\"\u003ePanResponder\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({\n    ...\n    \u003cspan class=\"hljs-attr\"\u003eonPanResponderRelease\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n      pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ewithTiming\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003eduration\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e180\u003c/span\u003e });\n    },\n  })\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e팬 제스처는 다른 제스처나 작업에 의해 조기에 종료되거나 중단될 수 있습니다. 다양한 상호 작용 시나리오에서 일관된 신뢰할 수 있는 사용자 경험을 보장하기 위해 onPanResponderRelease와 함께 onPanResponderTerminate도 사용합시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonPanRelease\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ewithTiming\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003eduration\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e180\u003c/span\u003e });\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e panResponderRef = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseRef\u003c/span\u003e(\n  \u003cspan class=\"hljs-title class_\"\u003ePanResponder\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({\n    ...\n    \u003cspan class=\"hljs-attr\"\u003eonPanResponderRelease\u003c/span\u003e: onPanRelease,\n    \u003cspan class=\"hljs-attr\"\u003eonPanResponderTerminate\u003c/span\u003e: onPanRelease,\n  })\n);\n\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*9K8kEfhq4VnhQPZoe60Pfw.gif\"\u003e\n\u003ch1\u003e단계 3: 목록의 스크롤 동작 복원하기\u003c/h1\u003e\n\u003cp\u003e간단한 작동하는 풀다운 애니메이션이 있지만, 목록의 정상적인 스크롤 동작이 보존되고 올바르게 작동하는지 확인해야 합니다.\u003c/p\u003e\n\u003cp\u003eonMoveShouldSetPanResponder로 돌아가서 항상 true를 반환하는 대신 의미있는 것을 반환하도록 하겠습니다. 목록이 맨 위로 스크롤되고 사용자가 목록을 더 아래로 밀어내는 경우에만 풀다운 제스처를 허용할 것입니다. 이는 아래와 같이 해석됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e panResponderRef = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseRef\u003c/span\u003e(\n  \u003cspan class=\"hljs-title class_\"\u003ePanResponder\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eonMoveShouldSetPanResponder\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent, gestureState\u003c/span\u003e) =\u003e\u003c/span\u003e\n      scrollPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e \u0026#x3C;= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026#x26;\u0026#x26; gestureState.\u003cspan class=\"hljs-property\"\u003edy\u003c/span\u003e \u003e= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eonPanResponderMove\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent, gestureState\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(gestureState.\u003cspan class=\"hljs-property\"\u003edy\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n    },\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*URAgW2RXvWsWs1YxrTLL6g.gif\"\u003e\n\u003cp\u003e잘 했어요! 목록이 이제 제대로 작동하고 풀다운 애니메이션이 의도대로 트리거되어 멋진 일을 해냈어요!\u003c/p\u003e\n\u003cp\u003e이제 잠시 쉬는 시간이에요. 커피 한 잔을 즐기세요 ☕, 몇 분 휴식을 취한 후에 마지막 단계로 넘어갈게요.\u003c/p\u003e\n\u003ch1\u003e마지막 단계: 새로고침 트리거하기\u003c/h1\u003e\n\u003cp\u003e이제 튜토리얼의 가장 중요한 부분에 도달했어요. 여기서는 실제로 새로 고침 동작을 트리거할 수 있도록 로직을 설정하는 방법을 알아볼 거에요. 현재 사용자들은 목록을 아래로 내릴 수 있지만, 제약을 추가하고 언제 새로 고침을 활성화해야 하는지 정의하고 싶어요.\u003c/p\u003e\n\u003ch2\u003e최대 아래로 당기기 거리 설정\u003c/h2\u003e\n\u003cp\u003e지금 사용자들은 화면 아래쪽까지 목록을 아래로 끌어 내릴 수 있어요. 이것은 자연스럽지 않고 직관적이지 않게 느껴지죠. 그래서 우리는 아래로 당기는 거리를 최대 150픽셀로 제한할 거에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e panResponderRef = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseRef\u003c/span\u003e(\n  \u003cspan class=\"hljs-title class_\"\u003ePanResponder\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({\n    ...\n    \u003cspan class=\"hljs-attr\"\u003eonPanResponderMove\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent, gestureState\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e maxDistance = \u003cspan class=\"hljs-number\"\u003e150\u003c/span\u003e;\n      pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(maxDistance, gestureState.\u003cspan class=\"hljs-property\"\u003edy\u003c/span\u003e), \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n    },\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e새로고침 트리거 지점 결정하기\u003c/h2\u003e\n\u003cp\u003e사용자가 이 150픽셀 범위의 절반 이상으로 당겼을 때, 새로고침 액션이 트리거될 준비가 된 것으로 간주합니다. 이 지점을 넘어서 제스처를 놓으면 새로고침 액션이 시작됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pullDownPosition = \u003cspan class=\"hljs-title function_\"\u003euseSharedValue\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isReadyToRefresh = \u003cspan class=\"hljs-title function_\"\u003euseSharedValue\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e panResponderRef = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseRef\u003c/span\u003e(\n  \u003cspan class=\"hljs-title class_\"\u003ePanResponder\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({\n    ...\n    \u003cspan class=\"hljs-attr\"\u003eonPanResponderMove\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent, gestureState\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e maxDistance = \u003cspan class=\"hljs-number\"\u003e150\u003c/span\u003e;\n      pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(maxDistance, gestureState.\u003cspan class=\"hljs-property\"\u003edy\u003c/span\u003e), \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n        pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e \u003e= maxDistance / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u0026#x26;\u0026#x26;\n        isReadyToRefresh.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e === \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n      ) {\n        isReadyToRefresh.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'새로고침할 준비 완료'\u003c/span\u003e);\n      }\n\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\n        pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e \u0026#x3C; maxDistance / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u0026#x26;\u0026#x26;\n        isReadyToRefresh.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e === \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n      ) {\n        isReadyToRefresh.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'릴리스 시 새로고침하지 않음'\u003c/span\u003e);\n      }\n    },\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e공유 값 isReadyToRefresh는 목록을 충분히 당겼는지 여부를 나타냅니다. 이제는 제스처 릴리스 처리 논리를 업데이트해봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonPanRelease\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ewithTiming\u003c/span\u003e(isReadyToRefresh.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e ? \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e : \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003eduration\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e180\u003c/span\u003e,\n  });\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isReadyToRefresh.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e) {\n    isReadyToRefresh.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 새로고침 실행\u003c/span\u003e\n  }\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e panResponderRef = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseRef\u003c/span\u003e(\n  \u003cspan class=\"hljs-title class_\"\u003ePanResponder\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({\n    ...\n    \u003cspan class=\"hljs-attr\"\u003eonPanResponderRelease\u003c/span\u003e: onPanRelease,\n    \u003cspan class=\"hljs-attr\"\u003eonPanResponderTerminate\u003c/span\u003e: onPanRelease,\n  })\n);\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로고침 작업을 트리거하는 메커니즘이 마련되었으니, 제스처(팬 릴리스)의 끝을 처리해봅시다.\u003c/p\u003e\n\u003ch2\u003e새로고침 작업 트리거\u003c/h2\u003e\n\u003cp\u003e사용자의 제스처가 끝나고 새로고침 작업 준비가 완료되면, onRefresh 함수를 호출할 것입니다. 이 함수는 하나의 매개변수를 받습니다. 해당 매개변수는 새로고침 작업이 완료된 후 애니메이션을 재설정할 done 함수입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pullDownPosition = \u003cspan class=\"hljs-title function_\"\u003euseSharedValue\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isReadyToRefresh = \u003cspan class=\"hljs-title function_\"\u003euseSharedValue\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonRefresh\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003edone: () =\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'새로 고침 중...'\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'새로 고침 완료!'\u003c/span\u003e);\n    \u003cspan class=\"hljs-title function_\"\u003edone\u003c/span\u003e();\n  }, \u003cspan class=\"hljs-number\"\u003e7500\u003c/span\u003e);\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonPanRelease\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ewithTiming\u003c/span\u003e(isReadyToRefresh.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e ? \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e : \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003eduration\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e180\u003c/span\u003e,\n  });\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (isReadyToRefresh.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e) {\n    isReadyToRefresh.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 애니메이션을 재설정하는 함수\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonRefreshComplete\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n      pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ewithTiming\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003eduration\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e180\u003c/span\u003e });\n    };\n\n    \u003cspan class=\"hljs-comment\"\u003e// 새로 고침 작업 실행\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003eonRefresh\u003c/span\u003e(onRefreshComplete);\n  }\n};\n\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eonRefresh\u003c/code\u003e 함수는 setTimeout을 사용하여 새로 고침 프로세스를 시뮬레이션합니다(실제 데이터 가져오기 프로세스의 가상 대체물로). 데이터가 새로 고쳐지면 애니메이션을 재설정하기 위해 \u003ccode\u003edone\u003c/code\u003e 콜백이 호출됩니다.\u003c/p\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1280/1*qtBcIAWfx4fISFDhdmreFw.gif\"\u003e\n\u003ch1\u003e애니메이션 구축하기\u003c/h1\u003e\n\u003cp\u003e이제 useAnimatedStyle 훅을 사용하여 새로 고침 애니메이션을 활성화할 준비가 되었습니다. 몇 가지 애니메이션 컴포넌트로 UI를 개선하면서 시작해 봅시다.\u003c/p\u003e\n\u003ch2\u003e배경 설정\u003c/h2\u003e\n\u003cp\u003e먼저, 애니메이션을 위한 배경을 만들겠습니다. 주요 UI를 View로 감싸고 기본 스타일을 적용하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eflex:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e1\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003ebackgroundColor:\u003c/span\u003e '#\u003cspan class=\"hljs-attr\"\u003e333\u003c/span\u003e',\n    }}\n  \u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eAnimated.View\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{[styles.root,\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epullDownStyles\u003c/span\u003e]}\n      {\u003cspan class=\"hljs-attr\"\u003e...panResponderRef.current.panHandlers\u003c/span\u003e}\n    \u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eAnimated.FlatList\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003e...\u003c/span\u003e\n      /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eAnimated.View\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n);\n\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e뷰는 애니메이션을 강조하는 어두운 배경을 제공하는 컨테이너 역할을 합니다.\u003c/p\u003e\n\u003ch2\u003e새로 고침 아이콘 통합\u003c/h2\u003e\n\u003cp\u003e다음으로, 회전하는 새로 고침 아이콘을 추가해 봅시다. 이 아이콘을 풀 다운 위치에 따라 확대 및 회전되도록 애니메이션화할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDribbbleShots\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDribbbleShotsProps\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eViewProps\u003c/span\u003e\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  ...\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e refreshContainerStyles = \u003cspan class=\"hljs-title function_\"\u003euseAnimatedStyle\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e,\n    };\n  });\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e refreshIconStyles = \u003cspan class=\"hljs-title function_\"\u003euseAnimatedStyle\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scale = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e / \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e));\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n      \u003cspan class=\"hljs-attr\"\u003eopacity\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e) / \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003etransform\u003c/span\u003e: [\n        {\n          \u003cspan class=\"hljs-attr\"\u003escale\u003c/span\u003e: scale,\n        },\n        {\n          \u003cspan class=\"hljs-attr\"\u003erotate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${pullDownPosition.value * \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e}\u003c/span\u003edeg`\u003c/span\u003e,\n        },\n      ],\n    };\n  });\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    [styles.\u003cspan class=\"hljs-property\"\u003erefreshContainer\u003c/span\u003e, refreshContainerStyles]}\u003e\n        \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eAnimated.Image\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{refreshIcon}\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{[styles.refreshIcon,\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erefreshIconStyles\u003c/span\u003e]}\n        /\u003e\u003c/span\u003e\u003c/span\u003e\n      \u0026#x3C;/\u003cspan class=\"hljs-title class_\"\u003eAnimated\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eView\u003c/span\u003e\u003e\n\n      ...\n    \u0026#x3C;/\u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*OVJMKGr9f4IJG3Ou7KTUjA.gif\" alt=\"Loading animation\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 '새로 고침 중...'이라는 단어를 단순히 기록하는 대신 상태 값을 사용하여 UI를 업데이트하고 새로 고침이 진행 중임을 나타내겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDribbbleShots\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDribbbleShotsProps\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eViewProps\u003c/span\u003e\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  ...\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pullDownPosition = \u003cspan class=\"hljs-title function_\"\u003euseSharedValue\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isReadyToRefresh = \u003cspan class=\"hljs-title function_\"\u003euseSharedValue\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [refreshing, setRefreshing] = \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonRefresh\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003edone: () =\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetRefreshing\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-title function_\"\u003esetRefreshing\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n      \u003cspan class=\"hljs-title function_\"\u003edone\u003c/span\u003e();\n    }, \u003cspan class=\"hljs-number\"\u003e7500\u003c/span\u003e);\n  };\n\n  ...\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003epointerEvents\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{refreshing\u003c/span\u003e ? '\u003cspan class=\"hljs-attr\"\u003enone\u003c/span\u003e' \u003cspan class=\"hljs-attr\"\u003e:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003eauto\u003c/span\u003e'}\n      \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eflex:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e1\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ebackgroundColor:\u003c/span\u003e '#\u003cspan class=\"hljs-attr\"\u003e333\u003c/span\u003e',\n      }\n    \u003e\u003c/span\u003e\n\n    ...\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e데이터가 아직로드 중인 동안 원치 않는 pull-down 제스처를 제어하고 방지하려면 pointerEvents 속성을 추가했습니다.\u003c/p\u003e\n\u003ch2\u003e로고 애니메이션 구현하기\u003c/h2\u003e\n\u003cp\u003e조금 더 재미있게 만들기 위해 애니메이션 로고를 추가해봅시다. 사용한 애니메이션 로고는 원래 Tony Pinkevych가 Dribbble에서 만들었고, 저는 이 데모에 맞게 약간 수정했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/**\n * 의존성 가져오기\n */\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'expo-image'\u003c/span\u003e;\n\n...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDribbbleShots\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFC\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eDribbbleShotsProps\u003c/span\u003e \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eViewProps\u003c/span\u003e\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  ...\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003epointerEvents\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{refreshing\u003c/span\u003e ? '\u003cspan class=\"hljs-attr\"\u003enone\u003c/span\u003e' \u003cspan class=\"hljs-attr\"\u003e:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003eauto\u003c/span\u003e'}\n      \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eflex:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e1\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ebackgroundColor:\u003c/span\u003e '#\u003cspan class=\"hljs-attr\"\u003e333\u003c/span\u003e',\n      }\n    \u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eAnimated.View\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{[styles.refreshContainer,\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erefreshContainerStyles\u003c/span\u003e]}\u003e\u003c/span\u003e\n        {refreshing \u0026#x26;\u0026#x26; (\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eImage\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{animatedLogo}\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e280\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eheight:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003e100\u003c/span\u003e%', \u003cspan class=\"hljs-attr\"\u003eobjectFit:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003ecover\u003c/span\u003e' }\n          /\u003e\u003c/span\u003e\n        )}\n\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eAnimated.Image\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003esource\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{refreshIcon}\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{[styles.refreshIcon,\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erefreshIconStyles\u003c/span\u003e]}\n        /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eAnimated.View\u003c/span\u003e\u003e\u003c/span\u003e\n\n    ...\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, refreshIconStyles를 업데이트하여 새로 고침 아이콘을 애니메이션 로고로 부드럽게 전환해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e refreshIconStyles = \u003cspan class=\"hljs-title function_\"\u003euseAnimatedStyle\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scale = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e / \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e));\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eopacity\u003c/span\u003e: refreshing\n      ? \u003cspan class=\"hljs-title function_\"\u003ewithDelay\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003ewithTiming\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003eduration\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e }))\n      : \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, pullDownPosition.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e) / \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003etransform\u003c/span\u003e: [\n      {\n        \u003cspan class=\"hljs-attr\"\u003escaleX\u003c/span\u003e: refreshing ? \u003cspan class=\"hljs-title function_\"\u003ewithTiming\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.15\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003eduration\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e }) : scale,\n      },\n      {\n        \u003cspan class=\"hljs-attr\"\u003escaleY\u003c/span\u003e: scale,\n      },\n      {\n        \u003cspan class=\"hljs-attr\"\u003erotate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${pullDownPosition.value * \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e}\u003c/span\u003edeg`\u003c/span\u003e,\n      },\n    ],\n    \u003cspan class=\"hljs-attr\"\u003ebackgroundColor\u003c/span\u003e: refreshing ? \u003cspan class=\"hljs-string\"\u003e'#fff'\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e'transparent'\u003c/span\u003e,\n  };\n}, [refreshing]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, 데이터를 로드하는 동안 스켈레톤 카드를 보여줄 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\n\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eAnimated\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFlatList\u003c/span\u003e\n  ...\n  renderItem={\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ item, index }\u003c/span\u003e) =\u003e\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eCard\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eloading\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{refreshing}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eindex\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{index}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item.image}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item.title}\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003elikes\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{item.likes}\u003c/span\u003e\n    /\u003e\u003c/span\u003e\u003c/span\u003e\n  )}\n  onScroll={scrollHandler}\n  scrollEventThrottle={\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e}\n/\u003e\n\u0026#x3C;/\u003cspan class=\"hljs-title class_\"\u003eAnimated\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eView\u003c/span\u003e\u003e\n\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 마지막 손짓으로, 새로 고침 애니메이션이 기능적이면서 시각적으로 매력적으로 완성되었습니다.\u003c/p\u003e\n\u003ch1\u003e활기찬 인상 깊은 애니메이션\u003c/h1\u003e\n\u003cp\u003e이제 창조의 시간입니다. 여기 창의성을 자극하고 다음 앱을 위한 몇 가지 아이디어를 제공할 인상적인 애니메이션의 선별된 목록이 준비되어 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*KB2KSwJq06LLyzA2_t-h1w.gif\" alt=\"Animation 1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*6L8rnyxjfPF-leE0x3Kigg.gif\" alt=\"Animation 2\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*Fb1kzeeAhQVNEf5TTAZlrg.gif\" alt=\"Animated GIF\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*YU3TndEWRtBaNcjXf-JZVg.gif\" alt=\"Animated GIF\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*sMa1sfIYa6Zsl8Co0bCsEQ.gif\" alt=\"Animated GIF\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*N5X0Kbuz7jHxclWzBv-glw.gif\" alt=\"Animated GIF\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*pZ8ddY3rFUoVBuTWAhRPTg.gif\" alt=\"image1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*bSPbDYoIz9zz3r2mCftWKw.gif\" alt=\"image2\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*utIKDBZ3o_V_-ctf22CBSA.gif\" alt=\"image3\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*Ti1YIVYL67ZQHWDXNX8ZzA.gif\" alt=\"image4\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*948wumPUB-5spDMTYs0Odg.gif\" alt=\"이미지1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*V4UtSyfCN9DDpl70IxXSHA.gif\" alt=\"이미지2\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*GA_UPaFN6krQMhRb3lGiqw.gif\" alt=\"이미지3\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*m4aMIvlIMY5WGmyFL8q2gA.gif\" alt=\"이미지4\"\u003e\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e우리의 사용자 정의 새로 고침 애니메이션 자습서가 마무리되었습니다! 아마도 이것이 여러분의 프로젝트에 몇 가지 아이디어를 불러일으켰으면 좋겠네요. 다양한 애니메이션을 실험해보고 해당 앱의 사용자 경험을 어떻게 향상시킬 수 있는지 확인해 보는 것을 권장합니다.\u003c/p\u003e\n\u003cp\u003e기억하세요, 배우는 가장 좋은 방법은 직접 해보는 것이기 때문에 고유한 새로 고침 애니메이션을 만들어보는 것에 도전해 보세요. 즐거운 코딩 되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-BuildingaCustomRefreshAnimationinReactNativeusingReanimated"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>