<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트  Props들어오는 값와 State내부값의 명명 규칙 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-ReactNamingConventionforPropsinoutandState" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트  Props들어오는 값와 State내부값의 명명 규칙 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트  Props들어오는 값와 State내부값의 명명 규칙 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-ReactNamingConventionforPropsinoutandState" data-gatsby-head="true"/><meta name="twitter:title" content="리액트  Props들어오는 값와 State내부값의 명명 규칙 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 20:24" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트  Props들어오는 값와 State내부값의 명명 규칙</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트  Props들어오는 값와 State내부값의 명명 규칙" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-ReactNamingConventionforPropsinoutandState&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>프로그래밍에서 가장 어려운 일 중 하나가 이름 짓기라고 자주 들어봤을 거예요.</p>
<p>대부분의 경우, 우리는 컴포넌트의 프로퍼티와 상태 변수를 어떻게 명명할지에 대해 많은 생각을 하게 됩니다.</p>
<p>이 자료에서는 React를 사용할 때 내가 사용하는 명명 규칙을 공유하고, 여러분이 프로퍼티와 상태를 어떻게 명명할지 쉽게 결정할 수 있도록 도와드릴 거예요.</p>
<h1>☯️ 프로퍼티용 명명 규칙</h1>
<p>리액트 프롭(prop)을 보는 방식은 입력과 출력 두 가지로 구성되어 있다고 생각해요.</p>
<p>그리고 이 두 가지는 서로 다른 네이밍 규약을 갖고 있어요.</p>
<p>입력 프롭은 부모 컴포넌트에서 자식 컴포넌트로 전달되어 자식 컴포넌트의 동작을 커스터마이즈하는 데 사용돼요.</p>
<p><img src="/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png" alt="React Naming Convention for Props"></p>
<p>출력 props는 입력 props와 거의 동일하지만 그 주요 목적은 이벤트 핸들러로 알려진 것과 같이 자식 컴포넌트가 부모와 통신할 수 있도록 하는 것입니다.</p>
<p><img src="/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_1.png" alt="React-Naming-Convention-for-Props"></p>
<p>이제 입력 및 출력 props 간의 차이를 이해했으므로 네이밍 규칙으로 넘어가 봅시다.</p>
<h2>입력 props의 네이밍 규칙</h2>
<p>입력 프롭스에 대해 다음과 같은 네이밍 규칙을 사용합니다:</p>
<ul>
<li>
<p>프롭스가 부울형인 경우 접두사로 is 또는 has를 사용하고 그 뒤에 프롭스의 이름을 붙입니다. 예를 들어: isDisabled, hasError, isActive, isOpen.</p>
</li>
<li>
<p>프롭스가 컴포넌트의 "도메인 값" 또는 "도메인 데이터"인 경우 그것을 값으로 명명합니다. 문자열, 숫자, 배열 또는 객체인지에 상관없이 모두 value로 명명합니다. 네이티브 HTML 요소 속성과 유사합니다. 예를 들어: value, defaultValue, initialValue.</p>
</li>
<li>
<p>컴포넌트 내의 자식 컴포넌트의 스타일인 경우, 자식 컴포넌트의 이름 뒤에 Props를 붙입니다. 예를 들어: textProps, buttonProps, inputProps, switchProps.</p>
</li>
<li>
<p>만약 prop이 ref prop이라면, 접미사 Ref 뒤에 ref의 이름을 사용합니다. 예를 들어, inputRef, buttonRef, textRef와 같이 사용합니다.</p>
</li>
</ul>
<h2>출력 Props에 대한 네이밍 규칙</h2>
<p>출력 Props의 경우, 다음과 같은 네이밍 규칙을 사용합니다:</p>
<ul>
<li>
<p>만약 prop이 렌더 prop이라면, 접두사 render를 사용하고 prop의 이름을 뒤에 붙입니다. 예를 들어, renderItem, renderHeader, renderFooter와 같이 사용합니다.</p>
</li>
<li>
<p>만약 prop이 이벤트 핸들러인 경우에는 해당 이벤트의 이름 뒤에 on을 붙입니다. 예를 들어, onClick, onSubmit, onClose, onOpen입니다.</p>
</li>
</ul>
<p>일부 출력 props가 이벤트 핸들러일 때에는 해당 이벤트의 이름 앞에 handleOn을 붙입니다. 예를 들어, handleOnClick, handleOnSubmit, handleOnClose, handleOnOpen입니다.</p>
<p>만약 이벤트가 변경(change) 이벤트인 경우에는 이름 뒤에 Change를 추가합니다. 예를 들어, handleOnChange, handleOnInputChange입니다.</p>
<p><img src="/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_2.png" alt="React props naming convention"></p>
<h1>⚙️ 상태에 대한 네이밍 규칙</h1>
<p>상태 속성은 변수의 네이밍 규칙과 거의 동일합니다.</p>
<p>만약 변수에 대해 이미 네이밍 규칙을 가지고 있고 익숙하다면, 동일한 네이밍 규칙을 상태 변수에 적용할 수 있습니다.</p>
<p>하지만 변수에 대해 네이밍 규칙이 없다면, 다음 네이밍 규칙을 사용할 수 있습니다:</p>
<ul>
<li>
<p>만약 상태가 부울(Boolean) 값인 경우, 상태의 이름에 "is" 또는 "has" 접두사를 사용합니다. 예를 들면: [isDisabled, setIsDisabled], [hasError, setHasError], [isActive, setIsActive], [isOpen, setIsOpen].</p>
</li>
<li>
<p>만약 상태가 컴포넌트의 "도메인 값" 또는 "도메인 데이터"인 경우, 값을 value로 지정합니다. 이 값이 문자열, 숫자, 배열 또는 객체든 상관없이 모두 같은 value로 표기합니다. 네이티브 HTML 입력 요소와 유사합니다. 예를 들면: [value, setValue], [defaultValue, setDefaultValue], [initialValue, setInitialValue].</p>
</li>
</ul>
<p>위의 명명 규칙 중 어떤 것이 props와 충돌한다면, 구조분해 할 때 별칭으로 설정하세요.</p>
<ul>
<li>만약 상태가 메모이제이션(memoized)된 값인 경우, 상태/컴포넌트의 이름 뒤에 memoized/Memoized 접두사를 사용합니다.</li>
</ul>
<p>메모이즈된 값이 컴포넌트가 아닌 경우, 접두사는 소문자로 지정됩니다. 예를 들어: memoizedValue, memoizedSum, memoizedResult.</p>
<p><img src="/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_3.png" alt="이미지1"></p>
<p>메모이즈된 값이 컴포넌트인 경우, 접두사는 대문자로 지정됩니다. 예를 들어: MemoizedButton, MemoizedText, MemoizedHeader.</p>
<p><img src="/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_4.png" alt="이미지2"></p>
<h1>🚀 결론</h1>
<p>이름 짓기는 어렵지만 결정을 돕는 가이드가 있다면 더 쉬울 수 있어요.</p>
<p>React 작업 시 사용하는 이 명명 규칙은 HTML 요소 속성에서 영감을 받았습니다. 비슷한 점을 찾아야 해서 일부 명명 규칙을 재사용하는 것을 좋아해요.</p>
<p>만약 이 중 어떤 것도 도움이 되지 않는다면, 언제든지 여러분, 여러분의 사용 사례 및 팀에 가장 적합한 명명 규칙을 만들 수 있다는 것을 염두에 두세요.</p>
<p>하루 마무리할 때 중요한 것은 일관되게 따를 수 있는 네이밍 규칙을 가지고 있다는 것입니다.</p>
<p>언제든지 궁금한 점이 있거나 제안할 내용이 있다면 아래에 댓글을 남겨주세요. 당신의 의견을 듣는 것을 기쁘게 생각할 거에요.</p>
<p>읽어주셔서 감사합니다. 여러분의 여정에 도움이 되기를 바랍니다! ❤️</p>
<h1>간단히 표현한 것 🚀</h1>
<p>In Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:</p>
<ul>
<li>작가를 클립하고 팔로우해 주세요 👏</li>
<li>팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter</li>
<li>다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed</li>
<li>PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트  Props들어오는 값와 State내부값의 명명 규칙","description":"","date":"2024-05-12 20:24","slug":"2024-05-12-ReactNamingConventionforPropsinoutandState","content":"\n\n프로그래밍에서 가장 어려운 일 중 하나가 이름 짓기라고 자주 들어봤을 거예요.\n\n대부분의 경우, 우리는 컴포넌트의 프로퍼티와 상태 변수를 어떻게 명명할지에 대해 많은 생각을 하게 됩니다.\n\n이 자료에서는 React를 사용할 때 내가 사용하는 명명 규칙을 공유하고, 여러분이 프로퍼티와 상태를 어떻게 명명할지 쉽게 결정할 수 있도록 도와드릴 거예요.\n\n# ☯️ 프로퍼티용 명명 규칙\n\n\n\n리액트 프롭(prop)을 보는 방식은 입력과 출력 두 가지로 구성되어 있다고 생각해요.\n\n그리고 이 두 가지는 서로 다른 네이밍 규약을 갖고 있어요.\n\n입력 프롭은 부모 컴포넌트에서 자식 컴포넌트로 전달되어 자식 컴포넌트의 동작을 커스터마이즈하는 데 사용돼요.\n\n![React Naming Convention for Props](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png)\n\n\n\n출력 props는 입력 props와 거의 동일하지만 그 주요 목적은 이벤트 핸들러로 알려진 것과 같이 자식 컴포넌트가 부모와 통신할 수 있도록 하는 것입니다.\n\n![React-Naming-Convention-for-Props](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_1.png)\n\n이제 입력 및 출력 props 간의 차이를 이해했으므로 네이밍 규칙으로 넘어가 봅시다.\n\n## 입력 props의 네이밍 규칙\n\n\n\n입력 프롭스에 대해 다음과 같은 네이밍 규칙을 사용합니다:\n\n- 프롭스가 부울형인 경우 접두사로 is 또는 has를 사용하고 그 뒤에 프롭스의 이름을 붙입니다. 예를 들어: isDisabled, hasError, isActive, isOpen.\n\n- 프롭스가 컴포넌트의 \"도메인 값\" 또는 \"도메인 데이터\"인 경우 그것을 값으로 명명합니다. 문자열, 숫자, 배열 또는 객체인지에 상관없이 모두 value로 명명합니다. 네이티브 HTML 요소 속성과 유사합니다. 예를 들어: value, defaultValue, initialValue.\n\n- 컴포넌트 내의 자식 컴포넌트의 스타일인 경우, 자식 컴포넌트의 이름 뒤에 Props를 붙입니다. 예를 들어: textProps, buttonProps, inputProps, switchProps.\n\n\n\n- 만약 prop이 ref prop이라면, 접미사 Ref 뒤에 ref의 이름을 사용합니다. 예를 들어, inputRef, buttonRef, textRef와 같이 사용합니다.\n\n## 출력 Props에 대한 네이밍 규칙\n\n출력 Props의 경우, 다음과 같은 네이밍 규칙을 사용합니다:\n\n- 만약 prop이 렌더 prop이라면, 접두사 render를 사용하고 prop의 이름을 뒤에 붙입니다. 예를 들어, renderItem, renderHeader, renderFooter와 같이 사용합니다.\n\n\n\n- 만약 prop이 이벤트 핸들러인 경우에는 해당 이벤트의 이름 뒤에 on을 붙입니다. 예를 들어, onClick, onSubmit, onClose, onOpen입니다.\n\n일부 출력 props가 이벤트 핸들러일 때에는 해당 이벤트의 이름 앞에 handleOn을 붙입니다. 예를 들어, handleOnClick, handleOnSubmit, handleOnClose, handleOnOpen입니다.\n\n만약 이벤트가 변경(change) 이벤트인 경우에는 이름 뒤에 Change를 추가합니다. 예를 들어, handleOnChange, handleOnInputChange입니다.\n\n![React props naming convention](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_2.png)\n\n\n\n# ⚙️ 상태에 대한 네이밍 규칙\n\n상태 속성은 변수의 네이밍 규칙과 거의 동일합니다.\n\n만약 변수에 대해 이미 네이밍 규칙을 가지고 있고 익숙하다면, 동일한 네이밍 규칙을 상태 변수에 적용할 수 있습니다.\n\n하지만 변수에 대해 네이밍 규칙이 없다면, 다음 네이밍 규칙을 사용할 수 있습니다:\n\n\n\n- 만약 상태가 부울(Boolean) 값인 경우, 상태의 이름에 \"is\" 또는 \"has\" 접두사를 사용합니다. 예를 들면: [isDisabled, setIsDisabled], [hasError, setHasError], [isActive, setIsActive], [isOpen, setIsOpen].\n\n- 만약 상태가 컴포넌트의 \"도메인 값\" 또는 \"도메인 데이터\"인 경우, 값을 value로 지정합니다. 이 값이 문자열, 숫자, 배열 또는 객체든 상관없이 모두 같은 value로 표기합니다. 네이티브 HTML 입력 요소와 유사합니다. 예를 들면: [value, setValue], [defaultValue, setDefaultValue], [initialValue, setInitialValue].\n\n위의 명명 규칙 중 어떤 것이 props와 충돌한다면, 구조분해 할 때 별칭으로 설정하세요.\n\n- 만약 상태가 메모이제이션(memoized)된 값인 경우, 상태/컴포넌트의 이름 뒤에 memoized/Memoized 접두사를 사용합니다.\n\n\n\n메모이즈된 값이 컴포넌트가 아닌 경우, 접두사는 소문자로 지정됩니다. 예를 들어: memoizedValue, memoizedSum, memoizedResult.\n\n![이미지1](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_3.png)\n\n메모이즈된 값이 컴포넌트인 경우, 접두사는 대문자로 지정됩니다. 예를 들어: MemoizedButton, MemoizedText, MemoizedHeader.\n\n![이미지2](/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_4.png)\n\n\n\n# 🚀 결론\n\n이름 짓기는 어렵지만 결정을 돕는 가이드가 있다면 더 쉬울 수 있어요.\n\nReact 작업 시 사용하는 이 명명 규칙은 HTML 요소 속성에서 영감을 받았습니다. 비슷한 점을 찾아야 해서 일부 명명 규칙을 재사용하는 것을 좋아해요.\n\n만약 이 중 어떤 것도 도움이 되지 않는다면, 언제든지 여러분, 여러분의 사용 사례 및 팀에 가장 적합한 명명 규칙을 만들 수 있다는 것을 염두에 두세요.\n\n\n\n하루 마무리할 때 중요한 것은 일관되게 따를 수 있는 네이밍 규칙을 가지고 있다는 것입니다.\n\n언제든지 궁금한 점이 있거나 제안할 내용이 있다면 아래에 댓글을 남겨주세요. 당신의 의견을 듣는 것을 기쁘게 생각할 거에요.\n\n읽어주셔서 감사합니다. 여러분의 여정에 도움이 되기를 바랍니다! ❤️\n\n# 간단히 표현한 것 🚀\n\n\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 클립하고 팔로우해 주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png"},"coverImage":"/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e프로그래밍에서 가장 어려운 일 중 하나가 이름 짓기라고 자주 들어봤을 거예요.\u003c/p\u003e\n\u003cp\u003e대부분의 경우, 우리는 컴포넌트의 프로퍼티와 상태 변수를 어떻게 명명할지에 대해 많은 생각을 하게 됩니다.\u003c/p\u003e\n\u003cp\u003e이 자료에서는 React를 사용할 때 내가 사용하는 명명 규칙을 공유하고, 여러분이 프로퍼티와 상태를 어떻게 명명할지 쉽게 결정할 수 있도록 도와드릴 거예요.\u003c/p\u003e\n\u003ch1\u003e☯️ 프로퍼티용 명명 규칙\u003c/h1\u003e\n\u003cp\u003e리액트 프롭(prop)을 보는 방식은 입력과 출력 두 가지로 구성되어 있다고 생각해요.\u003c/p\u003e\n\u003cp\u003e그리고 이 두 가지는 서로 다른 네이밍 규약을 갖고 있어요.\u003c/p\u003e\n\u003cp\u003e입력 프롭은 부모 컴포넌트에서 자식 컴포넌트로 전달되어 자식 컴포넌트의 동작을 커스터마이즈하는 데 사용돼요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_0.png\" alt=\"React Naming Convention for Props\"\u003e\u003c/p\u003e\n\u003cp\u003e출력 props는 입력 props와 거의 동일하지만 그 주요 목적은 이벤트 핸들러로 알려진 것과 같이 자식 컴포넌트가 부모와 통신할 수 있도록 하는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_1.png\" alt=\"React-Naming-Convention-for-Props\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 입력 및 출력 props 간의 차이를 이해했으므로 네이밍 규칙으로 넘어가 봅시다.\u003c/p\u003e\n\u003ch2\u003e입력 props의 네이밍 규칙\u003c/h2\u003e\n\u003cp\u003e입력 프롭스에 대해 다음과 같은 네이밍 규칙을 사용합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e프롭스가 부울형인 경우 접두사로 is 또는 has를 사용하고 그 뒤에 프롭스의 이름을 붙입니다. 예를 들어: isDisabled, hasError, isActive, isOpen.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e프롭스가 컴포넌트의 \"도메인 값\" 또는 \"도메인 데이터\"인 경우 그것을 값으로 명명합니다. 문자열, 숫자, 배열 또는 객체인지에 상관없이 모두 value로 명명합니다. 네이티브 HTML 요소 속성과 유사합니다. 예를 들어: value, defaultValue, initialValue.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e컴포넌트 내의 자식 컴포넌트의 스타일인 경우, 자식 컴포넌트의 이름 뒤에 Props를 붙입니다. 예를 들어: textProps, buttonProps, inputProps, switchProps.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e만약 prop이 ref prop이라면, 접미사 Ref 뒤에 ref의 이름을 사용합니다. 예를 들어, inputRef, buttonRef, textRef와 같이 사용합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e출력 Props에 대한 네이밍 규칙\u003c/h2\u003e\n\u003cp\u003e출력 Props의 경우, 다음과 같은 네이밍 규칙을 사용합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e만약 prop이 렌더 prop이라면, 접두사 render를 사용하고 prop의 이름을 뒤에 붙입니다. 예를 들어, renderItem, renderHeader, renderFooter와 같이 사용합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e만약 prop이 이벤트 핸들러인 경우에는 해당 이벤트의 이름 뒤에 on을 붙입니다. 예를 들어, onClick, onSubmit, onClose, onOpen입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e일부 출력 props가 이벤트 핸들러일 때에는 해당 이벤트의 이름 앞에 handleOn을 붙입니다. 예를 들어, handleOnClick, handleOnSubmit, handleOnClose, handleOnOpen입니다.\u003c/p\u003e\n\u003cp\u003e만약 이벤트가 변경(change) 이벤트인 경우에는 이름 뒤에 Change를 추가합니다. 예를 들어, handleOnChange, handleOnInputChange입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_2.png\" alt=\"React props naming convention\"\u003e\u003c/p\u003e\n\u003ch1\u003e⚙️ 상태에 대한 네이밍 규칙\u003c/h1\u003e\n\u003cp\u003e상태 속성은 변수의 네이밍 규칙과 거의 동일합니다.\u003c/p\u003e\n\u003cp\u003e만약 변수에 대해 이미 네이밍 규칙을 가지고 있고 익숙하다면, 동일한 네이밍 규칙을 상태 변수에 적용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e하지만 변수에 대해 네이밍 규칙이 없다면, 다음 네이밍 규칙을 사용할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e만약 상태가 부울(Boolean) 값인 경우, 상태의 이름에 \"is\" 또는 \"has\" 접두사를 사용합니다. 예를 들면: [isDisabled, setIsDisabled], [hasError, setHasError], [isActive, setIsActive], [isOpen, setIsOpen].\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e만약 상태가 컴포넌트의 \"도메인 값\" 또는 \"도메인 데이터\"인 경우, 값을 value로 지정합니다. 이 값이 문자열, 숫자, 배열 또는 객체든 상관없이 모두 같은 value로 표기합니다. 네이티브 HTML 입력 요소와 유사합니다. 예를 들면: [value, setValue], [defaultValue, setDefaultValue], [initialValue, setInitialValue].\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위의 명명 규칙 중 어떤 것이 props와 충돌한다면, 구조분해 할 때 별칭으로 설정하세요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e만약 상태가 메모이제이션(memoized)된 값인 경우, 상태/컴포넌트의 이름 뒤에 memoized/Memoized 접두사를 사용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e메모이즈된 값이 컴포넌트가 아닌 경우, 접두사는 소문자로 지정됩니다. 예를 들어: memoizedValue, memoizedSum, memoizedResult.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_3.png\" alt=\"이미지1\"\u003e\u003c/p\u003e\n\u003cp\u003e메모이즈된 값이 컴포넌트인 경우, 접두사는 대문자로 지정됩니다. 예를 들어: MemoizedButton, MemoizedText, MemoizedHeader.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-ReactNamingConventionforPropsinoutandState_4.png\" alt=\"이미지2\"\u003e\u003c/p\u003e\n\u003ch1\u003e🚀 결론\u003c/h1\u003e\n\u003cp\u003e이름 짓기는 어렵지만 결정을 돕는 가이드가 있다면 더 쉬울 수 있어요.\u003c/p\u003e\n\u003cp\u003eReact 작업 시 사용하는 이 명명 규칙은 HTML 요소 속성에서 영감을 받았습니다. 비슷한 점을 찾아야 해서 일부 명명 규칙을 재사용하는 것을 좋아해요.\u003c/p\u003e\n\u003cp\u003e만약 이 중 어떤 것도 도움이 되지 않는다면, 언제든지 여러분, 여러분의 사용 사례 및 팀에 가장 적합한 명명 규칙을 만들 수 있다는 것을 염두에 두세요.\u003c/p\u003e\n\u003cp\u003e하루 마무리할 때 중요한 것은 일관되게 따를 수 있는 네이밍 규칙을 가지고 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003e언제든지 궁금한 점이 있거나 제안할 내용이 있다면 아래에 댓글을 남겨주세요. 당신의 의견을 듣는 것을 기쁘게 생각할 거에요.\u003c/p\u003e\n\u003cp\u003e읽어주셔서 감사합니다. 여러분의 여정에 도움이 되기를 바랍니다! ❤️\u003c/p\u003e\n\u003ch1\u003e간단히 표현한 것 🚀\u003c/h1\u003e\n\u003cp\u003eIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작가를 클립하고 팔로우해 주세요 👏\u003c/li\u003e\n\u003cli\u003e팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\u003c/li\u003e\n\u003cli\u003e다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\u003c/li\u003e\n\u003cli\u003ePlainEnglish.io에서 더 많은 콘텐츠를 만나보세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-ReactNamingConventionforPropsinoutandState"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>