<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>웹 개발자가 알아야하는 필수 HTML 속성들 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="웹 개발자가 알아야하는 필수 HTML 속성들 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="웹 개발자가 알아야하는 필수 HTML 속성들 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow" data-gatsby-head="true"/><meta name="twitter:title" content="웹 개발자가 알아야하는 필수 HTML 속성들 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-01 22:58" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_buildManifest.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">웹 개발자가 알아야하는 필수 HTML 속성들</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="웹 개발자가 알아야하는 필수 HTML 속성들" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 1, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><img src="/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_0.png"/>
<p>HTML 언어는 웹 페이지에서 그래픽 요소를 그리기 위한 다양한 의미 있는 태그를 제공합니다. 보통 XML에서 속성을 사용하는 것처럼, HTML도 XML 기반의 마크업 언어로서 전역 및 태그별 속성을 지원합니다. 초기에 HTML은 웹 페이지를 디자인하기 위한 HTML 태그에 대한 기본 속성들을 제공했습니다. 모든 개발자가 알고 있는 id, class, style 등과 같은 어떤 HTML 요소와도 작동하는 전역 속성뿐만 아니라, src, href와 유사한 태그별 속성에 대해 알고 있습니다. 현대 웹 기술 및 UI/UX 요소의 성장과 함께, HTML 표준은 사용자 친화적인 웹 프론트엔드를 디자인하는 데 새로운 속성을 도입했습니다.</p>
<p>W3C 및 협력사들은 의심할 여지없이 HTML 기능을 확장하여, 무겁고, 제3자 외부 라이브러리에 의존하지 않고 접근 가능하고, 현대적이며, 기능이 풍부한 웹 프론트엔드를 개발할 수 있도록 노력하고 있습니다. 이러한 새로운 기능 중 일부는 새로운 HTML 태그로 나왔습니다. 한편, 일부는 새로운 속성으로 나왔습니다. 예를 들어, HTML은 액세스 가능하고, 네이티브하며, 자바스크립트 무료 팝오버 요소를 구현하기 위해 popover 속성을 도입했습니다.</p>
<p>이 이야기에서, 현대 웹 개발자로서 알아야 할 HTML 속성을 설명하고, 무거운, 제3자 라이브러리를 사용하지 않고 미래지향적인 프론트엔드를 디자인하세요. 이러한 네이티브 HTML 기능을 활용하여 최소한의 리소스로 높은 성능을 가진 웹 페이지를 제작해보세요!</p>
<div class="content-ad"></div>
<h1>웹 애플리케이션에서 원래 팝업 요소로 사용되던 네이티브 브라우저 창을 대안으로 사용하여 상위 레이어 콘텐츠를 표시했습니다 (예를 들어, 전자상거래 웹 사이트에서 사용자가 링크를 클릭할 때 T-셔츠 사이즈 차트를 표시합니다). 그러나 여러분들이 사용한 네이티브 창은 사용자 친화적이지 않았고 수정 가능하지 않았습니다. 나중에 개발자들은 UI/UX에 친화적으로 콘텐츠를 표시하기 위해 CSS 스타일이 적용된 인페이지 팝오버를 외부 라이브러리로 구축했습니다.</h1>
<p>이제 여러분은 HTML만으로 자바스크립트 코드 한 줄을 작성하지 않고 팝오버를 생성할 수 있습니다. 현대 웹 표준은 Popover API를 통해 내장 팝오버 지원을 포함하고 있습니다.</p>
<p>다음 소스 코드를 살펴보세요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[popover]</span><span class="hljs-selector-pseudo">::backdrop</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>);
}

<span class="hljs-selector-tag">div</span><span class="hljs-selector-attr">[popover]</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">12px</span>;
  <span class="hljs-attribute">border</span>: none;
}
</code></pre>
<p><code>pop</code> 요소에 <code>popover</code> 속성을 사용하여 간단한 팝오버 엘리먼트를 구현한 위의 HTML 코드 조각입니다. JavaScript를 사용하지 않고 <code>popovertarget</code> 속성을 사용하여 팝오버 엘리먼트를 표시합니다. 또한, 팝오버 뒷배경을 <code>::backdrop</code> 가상 요소를 사용하여 스타일링했습니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1148/1*KbjdZQW2A-7pzrBMGSDNXA.gif" alt="팝오버 예시 이미지"/></p>
<p>MDN 설명에 따라 네이티브 팝오버에 애니메이션을 추가할 수 있습니다. 또한, 팝오버 API의 JavaScript 메소드를 사용하여 CSS 스타일링된 툴팁을 만들 수 있습니다. 팝오버 웹 API는 아직 새로운 브라우저 기능이므로 제품에서 사용하기 전에 시간이 필요할 수 있습니다.</p>
<div class="content-ad"></div>
<h1>대화 상자 및 페이지에서 autofocus 속성 사용하기</h1>
<p>컴퓨터는 일반적으로 주요 입력 요소로 키보드와 마우스를 갖추고 있지만 특정 상황에서는 사용자가 특정 활동 중에 키보드만 사용하는 경우가 있습니다. 예를 들어 대량 생산 기업의 직원은 양손을 모두 사용하여 효율적으로 컴퓨터를 사용할 수 없는 바쁜 작업 중 데이터 입력 활동에 키보드만 사용할 수 있습니다. 결과적으로 브라우저는 탭 탐색, 팝오버 및 대화 상자에 대한 자동 키 할당, 단축키 등을 내장된 접근성 기능으로 키보드 지원을 구현합니다.</p>
<p>HTML 표준은 페이지 로드 및 대화 상자/팝오버 표시 상태에서 자동으로 양식 요소에 초점을 맞추기 위한 autofocus 속성을 제공합니다. 이 속성을 사용하면 사용자의 생산성을 향상시킬 수 있습니다.</p>
<p>다음 샘플 모달을 살펴보세요. 첫 번째 입력이 미리 채워져 있기 때문에 두 번째 텍스트 입력에 자동 초점이 맞춰집니다:</p>
<div class="content-ad"></div>
<img src="https://miro.medium.com/v2/resize:fit:1148/1*PvC6Czz14_44TLa_sTbhGA.gif"/>
<p>위 미리보기에서 보듯이 사용자는 Alt + Tab 단축키를 눌러 미리 채워진 텍스트 입력에 초점을 맞출 수 있습니다. 위 결과를 얻기 위한 소스 코드는 다음과 같습니다:</p>
<pre><code class="hljs language-js">&lt;dialog id=<span class="hljs-string">&quot;dlg&quot;</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;이름&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;존&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 8px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;성&quot;</span> <span class="hljs-attr">autofocus</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 8px&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>저장<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>
&lt;/dialog&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;document.getElementById(&#x27;dlg&#x27;).showModal()&quot;</span> <span class="hljs-attr">autofocus</span>&gt;</span>모달 표시<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
</code></pre>
<p>위 HTML 조각은 두 군데에서 포커스 속성을 사용합니다.</p>
<div class="content-ad"></div>
<ul>
<li>페이지 로드 이벤트 후에 쇼 모달 버튼 요소에 포커스를 맞추세요.</li>
<li>첫 번째 텍스트 입력란이 미리 채워져 있기 때문에 두 번째 텍스트 입력란을 자동으로 포커스하세요.</li>
</ul>
<p>여기서 우리는 JavaScript 코드를 사용하지 않고 다이얼로그를 닫기 위해 method=&quot;dialog&quot; 속성을 설정했습니다.</p>
<h1>pattern 속성을 사용하여 텍스트 입력 유효성 검사하기</h1>
<p>요즘 거의 모든 현대적인 웹 앱은 폼에서 클라이언트 측 유효성 검사를 사용합니다. 개발자들은 종종 유저 친화성을 향상시키기 위해 클라이언트 측에서 실시간 유효성 검사를 구현합니다. 이제 HTML의 input 요소에 pattern 속성이 있기 때문에 Regex 기반의 실시간 입력 유효성 검사를 구현하기 위해 JavaScript를 사용할 필요가 없어졌습니다.</p>
<div class="content-ad"></div>
<p>제품 식별자를 확인해야 한다고 가정해요. 이 식별자는 두 개의 영어 글자와 하이픈으로 연결된 여섯 자리 숫자로 구성돼요. 예를 들어 GR-100200 같은 거죠.</p>
<p>다음 HTML 코드 조각은 이 요구사항을 충족하는 유효성 검사가 가능한 텍스트 입력을 구현하고 있어요.</p>
<pre><code class="hljs language-js">&lt;form&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
    <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> 
    <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;예: GR-100200&quot;</span> 
    <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[A-Z]{2}-[0-9]{6}&quot;</span> 
    <span class="hljs-attr">required</span> 
   /&gt;</span></span>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>/&gt;</span></span>
&lt;/form&gt;
</code></pre>
<p>여기서 pattern 속성은 유효하지 않은 입력에 대한 브라우저별 유효성 메시지를 표시하여 제출을 방지해요. 그렇다면 실시간 유효성 검사를 어떻게 구현할 수 있을까요?</p>
<div class="content-ad"></div>
<p>패턴에 대한 실시간 유효성 검사는 다음 HTML 코드 조각에 표시된 대로 <div></div> 및 <div></div> CSS 가상 클래스를 사용하여 가능합니다:</p>
<pre><code class="hljs language-js">&lt;style&gt;
  input[type=text] {
    <span class="hljs-attr">border</span>: #<span class="hljs-number">000</span> 1px solid;
    border-<span class="hljs-attr">radius</span>: 4px;
    <span class="hljs-attr">outline</span>: none;
    <span class="hljs-attr">padding</span>: 6px;
  }

  input[type=text]:invalid {
    <span class="hljs-attr">border</span>: red 1px solid;
     + <span class="hljs-attr">span</span>::before {
      <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;✖&#x27;</span>;
      <span class="hljs-attr">display</span>: inline;
      <span class="hljs-attr">color</span>: red;
    }
  }
  
  input[type=text]:valid {
    <span class="hljs-attr">border</span>: green 1px solid;
    + <span class="hljs-attr">span</span>::before {
      <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;✓&#x27;</span>;
      <span class="hljs-attr">display</span>: inline;
      <span class="hljs-attr">color</span>: green;
    }
  }

&lt;/style&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> 
  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;예: GR-100200&quot;</span> 
  <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[A-Z]{2}-[0-9]{6}&quot;</span> <span class="hljs-attr">required</span>
/&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span>
</code></pre>
<p>위의 HTML 코드 조각은 유효성 상태에 따라 스타일을 설정하기 위해 CSS 코드를 사용합니다. 아래 미리보기에서와 같이, 유효하지 않은 입력값은 입력 상자 테두리를 빨간색으로 변하고 빨간색 교차 표시를 표시합니다. 한편, 유효한 입력값은 녹색 테두리와 녹색 확인 표시가 렌더링됩니다:</p>
<img src="https://miro.medium.com/v2/resize:fit:954/1*yCIHUIN8Sn6IMxuFbv0YVg.gif"/>
<pre><code>
&lt;div class=&quot;content-ad&quot;&gt;&lt;/div&gt;

아래 이야기에서 :valid 및 :invalid와 같은 CSS 가상 요소에 대해 더 알아보세요:

JavaScript에서 패턴을 사용하는 입력의 validity를 확인하기 위해 다음과 같이 JavaScript에서 입력의 validityState 인터페이스에 액세스할 수 있습니다:

```js
if(productInput.validity.valid) {
  // 할 일...
}
</code></pre>
<h1>inputmode 속성을 사용하여 모바일 가상 키보드 모드 다루기</h1>
<div class="content-ad"></div>
<p>현대 모바일 기기는 일반적으로 물리 키보드가 없습니다. 그 대신 터치 스크린에 렌더링되는 가상 키보드가 제공됩니다. 이 가상 키보드에는 여러 모드가 있습니다. 예를 들어 숫자 입력 요소에는 숫자 키만 표시되고 일반 문자열 입력에 대해서는 전체 키보드 인터페이스가 표시될 수 있습니다. 모바일 브라우저는 입력 유형에 따라 가상 키보드 모드를 자동으로 변경하지만 개발자는 input 요소의 inputmode 속성을 사용하여 사용자 정의할 수도 있습니다.</p>
<p>사용자로부터 OTP PIN을 입력받기 위해 특정 패턴을 사용하는 텍스트 입력을 사용한다고 가정해보겠습니다:</p>
<pre><code class="hljs language-js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span> placeholder=<span class="hljs-string">&quot;Enter OTP&quot;</span> pattern=<span class="hljs-string">&quot;[0-9]{4}&quot;</span> required /&gt;
</code></pre>
<p>이는 범용 문자열 유형 입력이므로 모바일은 전체 키보드 레이아웃을 표시합니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-md">![<span class="hljs-string">이미지</span>](<span class="hljs-link">/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_1.png</span>)

입력 요소와 함께 inputmode 속성을 다음과 같이 사용해봅시다:

<span class="hljs-code">```js
inputmode=&quot;numeric&quot;
</span></code></pre>
<p>이제 모바일에서 숫자 키보드 레이아웃을 확인할 수 있습니다. 아래 미리보기를 참고하세요:</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_2.png" alt="이미지"/></p>
<h1>loading 속성을 이용한 브라우저 레벨 이미지 지연 로딩</h1>
<p>웹 개발자들은 페이지 로딩 시간을 개선하여 SEO (검색 엔진 최적화) 점수를 높이고 사용자 상호 작용을 향상시키려고 노력합니다. 이미지의 지연 로딩은 특정 이미지를 렌더링할 때 해당 이미지를로드하여 초기 페이지 로딩 시간을 줄이는 잘 알려진 전략입니다. 이미지의 지연 로딩은 Intersection Observer API 또는 전통적인 스크롤 이벤트를 사용하여 자체 구현하거나 서드파티 라이브러리를 사용하여 가능합니다.</p>
<p>img 태그의 loading 속성을 사용하면 JavaScript 코드없이 또는 서드파티 라이브러리를 사용하지 않고 브라우저 레벨의 이미지 지연 로딩을 활성화할 수 있습니다.</p>
<div class="content-ad"></div>
<p>다음 소스 코드를 살펴보세요:</p>
<pre><code class="hljs language-js">&lt;div style=<span class="hljs-string">&quot;height: 2000px&quot;</span>&gt;&lt;/div&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://source.unsplash.com/vpOeXr5wmR4&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;240&quot;</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">&quot;lazy&quot;</span> /&gt;</span></span>
</code></pre>
<p>여기에는 사용자가 해당 이미지로 스크롤할 때에만 위 무료 이미지가 로드되며 초기 페이지 로드 시간에 영향을 주지 않게 되어 있습니다. 아래 미리 보기에서 확인할 수 있습니다:</p>
<img src="https://miro.medium.com/v2/resize:fit:1400/1*uy6OnakZEP-X8_0mbRHVPw.gif"/>
<div class="content-ad"></div>
<p>현재 HTML 명세에서는 lazy loading을 사용자화할 수 없지만, 브라우저는 브라우저 수준의 lazy-loading을 사용하는 개발자가 더 많아진다면 커스터마이즈 옵션을 제공할 수 있습니다.</p>
<h2>사용자 지정 data-* 속성 사용</h2>
<p>브라우저는 일반적으로 HTML 속성 이름에 엄격한 유효성 검사 규칙을 적용하지 않으므로 개발자는 원하는 사용자 정의 속성 이름을 사용할 수 있습니다. 그러나 사용자 정의 속성에 대한 다양한 명명 규칙을 사용하는 것은 좋지 않은 실천 방법입니다. 왜냐하면 그것은 HTML 문서 명세를 무효화하기 때문입니다. HTML 표준은 사용자 정의 속성에 대해 data- 접두사 사용을 권장하며 DOM API에서도 명시적인 기능을 제공하여 개발자를 독려합니다.</p>
<p>다음은 일부 사용자 정의 data 속성을 사용하는 샘플 HTML 요소입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">&lt;div 
  id=<span class="hljs-string">&quot;elm&quot;</span> 
  data-player-name=<span class="hljs-string">&quot;John&quot;</span>
  data-player-score=<span class="hljs-string">&quot;20&quot;</span>
  data-player-city=<span class="hljs-string">&quot;LA&quot;</span>&gt;
&lt;/div&gt;
</code></pre>
<p>자바스크립트를 통해 디스트럭처링으로 카멜 표기법 키를 사용하여 이러한 사용자 지정 속성 값을 쉽게 액세스할 수 있습니다. 다음 코드 스니펫에서 보여지듯이:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> { playerName, playerScore, playerCity } = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;elm&#x27;</span>).<span class="hljs-property">dataset</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(playerName, playerScore, playerCity); <span class="hljs-comment">// John 20 LA</span>
</code></pre>
<p>또한 CSS 문서 내에서 이러한 데이터 속성에 액세스할 수도 있습니다.```</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">#<span class="hljs-attr">elm</span>::before {
  <span class="hljs-attr">content</span>: <span class="hljs-title function_">attr</span>(data-player-name) <span class="hljs-string">&quot; - &quot;</span> <span class="hljs-title function_">attr</span>(data-player-score)
}

#elm {
  <span class="hljs-attr">display</span>: inline-block;
  <span class="hljs-attr">padding</span>: 12px;
  background-<span class="hljs-attr">color</span>: #ddd;
}
</code></pre>
<p>위의 CSS 코드 조각은 data-player-name과 data-score 값을 HTML 요소 위에 다음과 같이 렌더링합니다:</p>
<img src="/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_3.png"/>
<p>제3자 라이브러리를 사용하지 않고도 최신 네이티브 HTML 태그를 사용하여 간결하고 사용자 친화적이며 성능이 우수하며 접근성이 좋은 웹 프론트엔드를 개발할 수 있습니다. 아래 이야기로 더 자세히 알아보세요:```</p>
<div class="content-ad"></div>
<p>읽어 주셔서 감사합니다!</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"웹 개발자가 알아야하는 필수 HTML 속성들","description":"","date":"2024-05-01 22:58","slug":"2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_0.png\" /\u003e\n\nHTML 언어는 웹 페이지에서 그래픽 요소를 그리기 위한 다양한 의미 있는 태그를 제공합니다. 보통 XML에서 속성을 사용하는 것처럼, HTML도 XML 기반의 마크업 언어로서 전역 및 태그별 속성을 지원합니다. 초기에 HTML은 웹 페이지를 디자인하기 위한 HTML 태그에 대한 기본 속성들을 제공했습니다. 모든 개발자가 알고 있는 id, class, style 등과 같은 어떤 HTML 요소와도 작동하는 전역 속성뿐만 아니라, src, href와 유사한 태그별 속성에 대해 알고 있습니다. 현대 웹 기술 및 UI/UX 요소의 성장과 함께, HTML 표준은 사용자 친화적인 웹 프론트엔드를 디자인하는 데 새로운 속성을 도입했습니다.\n\nW3C 및 협력사들은 의심할 여지없이 HTML 기능을 확장하여, 무겁고, 제3자 외부 라이브러리에 의존하지 않고 접근 가능하고, 현대적이며, 기능이 풍부한 웹 프론트엔드를 개발할 수 있도록 노력하고 있습니다. 이러한 새로운 기능 중 일부는 새로운 HTML 태그로 나왔습니다. 한편, 일부는 새로운 속성으로 나왔습니다. 예를 들어, HTML은 액세스 가능하고, 네이티브하며, 자바스크립트 무료 팝오버 요소를 구현하기 위해 popover 속성을 도입했습니다.\n\n이 이야기에서, 현대 웹 개발자로서 알아야 할 HTML 속성을 설명하고, 무거운, 제3자 라이브러리를 사용하지 않고 미래지향적인 프론트엔드를 디자인하세요. 이러한 네이티브 HTML 기능을 활용하여 최소한의 리소스로 높은 성능을 가진 웹 페이지를 제작해보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 웹 애플리케이션에서 원래 팝업 요소로 사용되던 네이티브 브라우저 창을 대안으로 사용하여 상위 레이어 콘텐츠를 표시했습니다 (예를 들어, 전자상거래 웹 사이트에서 사용자가 링크를 클릭할 때 T-셔츠 사이즈 차트를 표시합니다). 그러나 여러분들이 사용한 네이티브 창은 사용자 친화적이지 않았고 수정 가능하지 않았습니다. 나중에 개발자들은 UI/UX에 친화적으로 콘텐츠를 표시하기 위해 CSS 스타일이 적용된 인페이지 팝오버를 외부 라이브러리로 구축했습니다.\n\n이제 여러분은 HTML만으로 자바스크립트 코드 한 줄을 작성하지 않고 팝오버를 생성할 수 있습니다. 현대 웹 표준은 Popover API를 통해 내장 팝오버 지원을 포함하고 있습니다.\n\n다음 소스 코드를 살펴보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```css\ndiv[popover]::backdrop {\n  background-color: rgba(0, 0, 0, 0.4);\n}\n\ndiv[popover] {\n  padding: 12px;\n  border: none;\n}\n```\n\n`pop` 요소에 `popover` 속성을 사용하여 간단한 팝오버 엘리먼트를 구현한 위의 HTML 코드 조각입니다. JavaScript를 사용하지 않고 `popovertarget` 속성을 사용하여 팝오버 엘리먼트를 표시합니다. 또한, 팝오버 뒷배경을 `::backdrop` 가상 요소를 사용하여 스타일링했습니다.\n\n![팝오버 예시 이미지](https://miro.medium.com/v2/resize:fit:1148/1*KbjdZQW2A-7pzrBMGSDNXA.gif)\n\nMDN 설명에 따라 네이티브 팝오버에 애니메이션을 추가할 수 있습니다. 또한, 팝오버 API의 JavaScript 메소드를 사용하여 CSS 스타일링된 툴팁을 만들 수 있습니다. 팝오버 웹 API는 아직 새로운 브라우저 기능이므로 제품에서 사용하기 전에 시간이 필요할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 대화 상자 및 페이지에서 autofocus 속성 사용하기\n\n컴퓨터는 일반적으로 주요 입력 요소로 키보드와 마우스를 갖추고 있지만 특정 상황에서는 사용자가 특정 활동 중에 키보드만 사용하는 경우가 있습니다. 예를 들어 대량 생산 기업의 직원은 양손을 모두 사용하여 효율적으로 컴퓨터를 사용할 수 없는 바쁜 작업 중 데이터 입력 활동에 키보드만 사용할 수 있습니다. 결과적으로 브라우저는 탭 탐색, 팝오버 및 대화 상자에 대한 자동 키 할당, 단축키 등을 내장된 접근성 기능으로 키보드 지원을 구현합니다.\n\nHTML 표준은 페이지 로드 및 대화 상자/팝오버 표시 상태에서 자동으로 양식 요소에 초점을 맞추기 위한 autofocus 속성을 제공합니다. 이 속성을 사용하면 사용자의 생산성을 향상시킬 수 있습니다.\n\n다음 샘플 모달을 살펴보세요. 첫 번째 입력이 미리 채워져 있기 때문에 두 번째 텍스트 입력에 자동 초점이 맞춰집니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1148/1*PvC6Czz14_44TLa_sTbhGA.gif\" /\u003e\n\n위 미리보기에서 보듯이 사용자는 Alt + Tab 단축키를 눌러 미리 채워진 텍스트 입력에 초점을 맞출 수 있습니다. 위 결과를 얻기 위한 소스 코드는 다음과 같습니다:\n\n```js\n\u003cdialog id=\"dlg\"\u003e\n  \u003cform method=\"dialog\"\u003e\n    \u003cinput type=\"text\" placeholder=\"이름\" value=\"존\" /\u003e\n    \u003cdiv style=\"height: 8px\"\u003e\u003c/div\u003e\n    \u003cinput type=\"text\" placeholder=\"성\" autofocus/\u003e\n    \u003cdiv style=\"height: 8px\"\u003e\u003c/div\u003e\n    \u003cbutton\u003e저장\u003c/button\u003e\n  \u003c/form\u003e\n\u003c/dialog\u003e\n\u003cbutton onclick=\"document.getElementById('dlg').showModal()\" autofocus\u003e모달 표시\u003c/button\u003e\n```\n\n위 HTML 조각은 두 군데에서 포커스 속성을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 페이지 로드 이벤트 후에 쇼 모달 버튼 요소에 포커스를 맞추세요.\n- 첫 번째 텍스트 입력란이 미리 채워져 있기 때문에 두 번째 텍스트 입력란을 자동으로 포커스하세요.\n\n여기서 우리는 JavaScript 코드를 사용하지 않고 다이얼로그를 닫기 위해 method=\"dialog\" 속성을 설정했습니다.\n\n# pattern 속성을 사용하여 텍스트 입력 유효성 검사하기\n\n요즘 거의 모든 현대적인 웹 앱은 폼에서 클라이언트 측 유효성 검사를 사용합니다. 개발자들은 종종 유저 친화성을 향상시키기 위해 클라이언트 측에서 실시간 유효성 검사를 구현합니다. 이제 HTML의 input 요소에 pattern 속성이 있기 때문에 Regex 기반의 실시간 입력 유효성 검사를 구현하기 위해 JavaScript를 사용할 필요가 없어졌습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제품 식별자를 확인해야 한다고 가정해요. 이 식별자는 두 개의 영어 글자와 하이픈으로 연결된 여섯 자리 숫자로 구성돼요. 예를 들어 GR-100200 같은 거죠.\n\n다음 HTML 코드 조각은 이 요구사항을 충족하는 유효성 검사가 가능한 텍스트 입력을 구현하고 있어요.\n\n```js\n\u003cform\u003e\n  \u003cinput \n    type=\"text\" \n    placeholder=\"예: GR-100200\" \n    pattern=\"[A-Z]{2}-[0-9]{6}\" \n    required \n   /\u003e\n  \u003cinput type=\"submit\"/\u003e\n\u003c/form\u003e\n```\n\n여기서 pattern 속성은 유효하지 않은 입력에 대한 브라우저별 유효성 메시지를 표시하여 제출을 방지해요. 그렇다면 실시간 유효성 검사를 어떻게 구현할 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패턴에 대한 실시간 유효성 검사는 다음 HTML 코드 조각에 표시된 대로 :valid 및 :invalid CSS 가상 클래스를 사용하여 가능합니다:\n\n```js\n\u003cstyle\u003e\n  input[type=text] {\n    border: #000 1px solid;\n    border-radius: 4px;\n    outline: none;\n    padding: 6px;\n  }\n\n  input[type=text]:invalid {\n    border: red 1px solid;\n     + span::before {\n      content: '✖';\n      display: inline;\n      color: red;\n    }\n  }\n  \n  input[type=text]:valid {\n    border: green 1px solid;\n    + span::before {\n      content: '✓';\n      display: inline;\n      color: green;\n    }\n  }\n\n\u003c/style\u003e\n\n\u003cinput \n  type=\"text\" \n  placeholder=\"예: GR-100200\" \n  pattern=\"[A-Z]{2}-[0-9]{6}\" required\n/\u003e\n\u003cspan\u003e\u003c/span\u003e\n```\n\n위의 HTML 코드 조각은 유효성 상태에 따라 스타일을 설정하기 위해 CSS 코드를 사용합니다. 아래 미리보기에서와 같이, 유효하지 않은 입력값은 입력 상자 테두리를 빨간색으로 변하고 빨간색 교차 표시를 표시합니다. 한편, 유효한 입력값은 녹색 테두리와 녹색 확인 표시가 렌더링됩니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:954/1*yCIHUIN8Sn6IMxuFbv0YVg.gif\" /\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 이야기에서 :valid 및 :invalid와 같은 CSS 가상 요소에 대해 더 알아보세요:\n\nJavaScript에서 패턴을 사용하는 입력의 validity를 확인하기 위해 다음과 같이 JavaScript에서 입력의 validityState 인터페이스에 액세스할 수 있습니다:\n\n```js\nif(productInput.validity.valid) {\n  // 할 일...\n}\n```\n\n# inputmode 속성을 사용하여 모바일 가상 키보드 모드 다루기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현대 모바일 기기는 일반적으로 물리 키보드가 없습니다. 그 대신 터치 스크린에 렌더링되는 가상 키보드가 제공됩니다. 이 가상 키보드에는 여러 모드가 있습니다. 예를 들어 숫자 입력 요소에는 숫자 키만 표시되고 일반 문자열 입력에 대해서는 전체 키보드 인터페이스가 표시될 수 있습니다. 모바일 브라우저는 입력 유형에 따라 가상 키보드 모드를 자동으로 변경하지만 개발자는 input 요소의 inputmode 속성을 사용하여 사용자 정의할 수도 있습니다.\n\n사용자로부터 OTP PIN을 입력받기 위해 특정 패턴을 사용하는 텍스트 입력을 사용한다고 가정해보겠습니다:\n\n```js\n\u003cinput type=\"text\" placeholder=\"Enter OTP\" pattern=\"[0-9]{4}\" required /\u003e\n```\n\n이는 범용 문자열 유형 입력이므로 모바일은 전체 키보드 레이아웃을 표시합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```md\n![이미지](/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_1.png)\n\n입력 요소와 함께 inputmode 속성을 다음과 같이 사용해봅시다:\n\n```js\ninputmode=\"numeric\"\n```\n\n이제 모바일에서 숫자 키보드 레이아웃을 확인할 수 있습니다. 아래 미리보기를 참고하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_2.png)\n\n# loading 속성을 이용한 브라우저 레벨 이미지 지연 로딩\n\n웹 개발자들은 페이지 로딩 시간을 개선하여 SEO (검색 엔진 최적화) 점수를 높이고 사용자 상호 작용을 향상시키려고 노력합니다. 이미지의 지연 로딩은 특정 이미지를 렌더링할 때 해당 이미지를로드하여 초기 페이지 로딩 시간을 줄이는 잘 알려진 전략입니다. 이미지의 지연 로딩은 Intersection Observer API 또는 전통적인 스크롤 이벤트를 사용하여 자체 구현하거나 서드파티 라이브러리를 사용하여 가능합니다.\n\nimg 태그의 loading 속성을 사용하면 JavaScript 코드없이 또는 서드파티 라이브러리를 사용하지 않고 브라우저 레벨의 이미지 지연 로딩을 활성화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 소스 코드를 살펴보세요:\n\n```js\n\u003cdiv style=\"height: 2000px\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"https://source.unsplash.com/vpOeXr5wmR4\" width=\"400\" height=\"240\" loading=\"lazy\" /\u003e\n```\n\n여기에는 사용자가 해당 이미지로 스크롤할 때에만 위 무료 이미지가 로드되며 초기 페이지 로드 시간에 영향을 주지 않게 되어 있습니다. 아래 미리 보기에서 확인할 수 있습니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*uy6OnakZEP-X8_0mbRHVPw.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 HTML 명세에서는 lazy loading을 사용자화할 수 없지만, 브라우저는 브라우저 수준의 lazy-loading을 사용하는 개발자가 더 많아진다면 커스터마이즈 옵션을 제공할 수 있습니다.\n\n## 사용자 지정 data-* 속성 사용\n\n브라우저는 일반적으로 HTML 속성 이름에 엄격한 유효성 검사 규칙을 적용하지 않으므로 개발자는 원하는 사용자 정의 속성 이름을 사용할 수 있습니다. 그러나 사용자 정의 속성에 대한 다양한 명명 규칙을 사용하는 것은 좋지 않은 실천 방법입니다. 왜냐하면 그것은 HTML 문서 명세를 무효화하기 때문입니다. HTML 표준은 사용자 정의 속성에 대해 data- 접두사 사용을 권장하며 DOM API에서도 명시적인 기능을 제공하여 개발자를 독려합니다.\n\n다음은 일부 사용자 정의 data 속성을 사용하는 샘플 HTML 요소입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cdiv \n  id=\"elm\" \n  data-player-name=\"John\"\n  data-player-score=\"20\"\n  data-player-city=\"LA\"\u003e\n\u003c/div\u003e\n```\n\n자바스크립트를 통해 디스트럭처링으로 카멜 표기법 키를 사용하여 이러한 사용자 지정 속성 값을 쉽게 액세스할 수 있습니다. 다음 코드 스니펫에서 보여지듯이:\n\n```js\nlet { playerName, playerScore, playerCity } = document.getElementById('elm').dataset;\n\nconsole.log(playerName, playerScore, playerCity); // John 20 LA\n```\n\n또한 CSS 문서 내에서 이러한 데이터 속성에 액세스할 수도 있습니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n#elm::before {\n  content: attr(data-player-name) \" - \" attr(data-player-score)\n}\n\n#elm {\n  display: inline-block;\n  padding: 12px;\n  background-color: #ddd;\n}\n```\n\n위의 CSS 코드 조각은 data-player-name과 data-score 값을 HTML 요소 위에 다음과 같이 렌더링합니다:\n\n\u003cimg src=\"/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_3.png\" /\u003e\n\n제3자 라이브러리를 사용하지 않고도 최신 네이티브 HTML 태그를 사용하여 간결하고 사용자 친화적이며 성능이 우수하며 접근성이 좋은 웹 프론트엔드를 개발할 수 있습니다. 아래 이야기로 더 자세히 알아보세요:```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":9},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\",\n    div: \"div\",\n    h2: \"h2\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_0.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"HTML 언어는 웹 페이지에서 그래픽 요소를 그리기 위한 다양한 의미 있는 태그를 제공합니다. 보통 XML에서 속성을 사용하는 것처럼, HTML도 XML 기반의 마크업 언어로서 전역 및 태그별 속성을 지원합니다. 초기에 HTML은 웹 페이지를 디자인하기 위한 HTML 태그에 대한 기본 속성들을 제공했습니다. 모든 개발자가 알고 있는 id, class, style 등과 같은 어떤 HTML 요소와도 작동하는 전역 속성뿐만 아니라, src, href와 유사한 태그별 속성에 대해 알고 있습니다. 현대 웹 기술 및 UI/UX 요소의 성장과 함께, HTML 표준은 사용자 친화적인 웹 프론트엔드를 디자인하는 데 새로운 속성을 도입했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"W3C 및 협력사들은 의심할 여지없이 HTML 기능을 확장하여, 무겁고, 제3자 외부 라이브러리에 의존하지 않고 접근 가능하고, 현대적이며, 기능이 풍부한 웹 프론트엔드를 개발할 수 있도록 노력하고 있습니다. 이러한 새로운 기능 중 일부는 새로운 HTML 태그로 나왔습니다. 한편, 일부는 새로운 속성으로 나왔습니다. 예를 들어, HTML은 액세스 가능하고, 네이티브하며, 자바스크립트 무료 팝오버 요소를 구현하기 위해 popover 속성을 도입했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 이야기에서, 현대 웹 개발자로서 알아야 할 HTML 속성을 설명하고, 무거운, 제3자 라이브러리를 사용하지 않고 미래지향적인 프론트엔드를 디자인하세요. 이러한 네이티브 HTML 기능을 활용하여 최소한의 리소스로 높은 성능을 가진 웹 페이지를 제작해보세요!\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"웹 애플리케이션에서 원래 팝업 요소로 사용되던 네이티브 브라우저 창을 대안으로 사용하여 상위 레이어 콘텐츠를 표시했습니다 (예를 들어, 전자상거래 웹 사이트에서 사용자가 링크를 클릭할 때 T-셔츠 사이즈 차트를 표시합니다). 그러나 여러분들이 사용한 네이티브 창은 사용자 친화적이지 않았고 수정 가능하지 않았습니다. 나중에 개발자들은 UI/UX에 친화적으로 콘텐츠를 표시하기 위해 CSS 스타일이 적용된 인페이지 팝오버를 외부 라이브러리로 구축했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 여러분은 HTML만으로 자바스크립트 코드 한 줄을 작성하지 않고 팝오버를 생성할 수 있습니다. 현대 웹 표준은 Popover API를 통해 내장 팝오버 지원을 포함하고 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 소스 코드를 살펴보세요:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-css\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-selector-tag\",\n          children: \"div\"\n        }), _jsx(_components.span, {\n          className: \"hljs-selector-attr\",\n          children: \"[popover]\"\n        }), _jsx(_components.span, {\n          className: \"hljs-selector-pseudo\",\n          children: \"::backdrop\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attribute\",\n          children: \"background-color\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"rgba\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.4\"\n        }), \");\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-selector-tag\",\n          children: \"div\"\n        }), _jsx(_components.span, {\n          className: \"hljs-selector-attr\",\n          children: \"[popover]\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attribute\",\n          children: \"padding\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12px\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-attribute\",\n          children: \"border\"\n        }), \": none;\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"pop\"\n      }), \" 요소에 \", _jsx(_components.code, {\n        children: \"popover\"\n      }), \" 속성을 사용하여 간단한 팝오버 엘리먼트를 구현한 위의 HTML 코드 조각입니다. JavaScript를 사용하지 않고 \", _jsx(_components.code, {\n        children: \"popovertarget\"\n      }), \" 속성을 사용하여 팝오버 엘리먼트를 표시합니다. 또한, 팝오버 뒷배경을 \", _jsx(_components.code, {\n        children: \"::backdrop\"\n      }), \" 가상 요소를 사용하여 스타일링했습니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://miro.medium.com/v2/resize:fit:1148/1*KbjdZQW2A-7pzrBMGSDNXA.gif\",\n        alt: \"팝오버 예시 이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"MDN 설명에 따라 네이티브 팝오버에 애니메이션을 추가할 수 있습니다. 또한, 팝오버 API의 JavaScript 메소드를 사용하여 CSS 스타일링된 툴팁을 만들 수 있습니다. 팝오버 웹 API는 아직 새로운 브라우저 기능이므로 제품에서 사용하기 전에 시간이 필요할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"대화 상자 및 페이지에서 autofocus 속성 사용하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"컴퓨터는 일반적으로 주요 입력 요소로 키보드와 마우스를 갖추고 있지만 특정 상황에서는 사용자가 특정 활동 중에 키보드만 사용하는 경우가 있습니다. 예를 들어 대량 생산 기업의 직원은 양손을 모두 사용하여 효율적으로 컴퓨터를 사용할 수 없는 바쁜 작업 중 데이터 입력 활동에 키보드만 사용할 수 있습니다. 결과적으로 브라우저는 탭 탐색, 팝오버 및 대화 상자에 대한 자동 키 할당, 단축키 등을 내장된 접근성 기능으로 키보드 지원을 구현합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"HTML 표준은 페이지 로드 및 대화 상자/팝오버 표시 상태에서 자동으로 양식 요소에 초점을 맞추기 위한 autofocus 속성을 제공합니다. 이 속성을 사용하면 사용자의 생산성을 향상시킬 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 샘플 모달을 살펴보세요. 첫 번째 입력이 미리 채워져 있기 때문에 두 번째 텍스트 입력에 자동 초점이 맞춰집니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"https://miro.medium.com/v2/resize:fit:1148/1*PvC6Czz14_44TLa_sTbhGA.gif\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 미리보기에서 보듯이 사용자는 Alt + Tab 단축키를 눌러 미리 채워진 텍스트 입력에 초점을 맞출 수 있습니다. 위 결과를 얻기 위한 소스 코드는 다음과 같습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003cdialog id=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dlg\\\"\"\n        }), \"\u003e\\n  \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"form\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"method\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"dialog\\\"\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"input\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"type\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"text\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"placeholder\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"이름\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"value\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"존\\\"\"\n            }), \" /\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"style\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"height: 8px\\\"\"\n            }), \"\u003e\"]\n          }), _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"input\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"type\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"text\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"placeholder\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"성\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"autofocus\"\n            }), \"/\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"style\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"height: 8px\\\"\"\n            }), \"\u003e\"]\n          }), _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \"\u003e\"]\n          }), \"저장\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \"\u003e\"]\n          }), \"\\n  \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"form\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\u003c/dialog\u003e\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onclick\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"document.getElementById('dlg').showModal()\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"autofocus\"\n            }), \"\u003e\"]\n          }), \"모달 표시\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 HTML 조각은 두 군데에서 포커스 속성을 사용합니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"페이지 로드 이벤트 후에 쇼 모달 버튼 요소에 포커스를 맞추세요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"첫 번째 텍스트 입력란이 미리 채워져 있기 때문에 두 번째 텍스트 입력란을 자동으로 포커스하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 우리는 JavaScript 코드를 사용하지 않고 다이얼로그를 닫기 위해 method=\\\"dialog\\\" 속성을 설정했습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"pattern 속성을 사용하여 텍스트 입력 유효성 검사하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"요즘 거의 모든 현대적인 웹 앱은 폼에서 클라이언트 측 유효성 검사를 사용합니다. 개발자들은 종종 유저 친화성을 향상시키기 위해 클라이언트 측에서 실시간 유효성 검사를 구현합니다. 이제 HTML의 input 요소에 pattern 속성이 있기 때문에 Regex 기반의 실시간 입력 유효성 검사를 구현하기 위해 JavaScript를 사용할 필요가 없어졌습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제품 식별자를 확인해야 한다고 가정해요. 이 식별자는 두 개의 영어 글자와 하이픈으로 연결된 여섯 자리 숫자로 구성돼요. 예를 들어 GR-100200 같은 거죠.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 HTML 코드 조각은 이 요구사항을 충족하는 유효성 검사가 가능한 텍스트 입력을 구현하고 있어요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003cform\u003e\\n  \", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"input\"\n            }), \" \\n    \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"type\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"text\\\"\"\n            }), \" \\n    \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"placeholder\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"예: GR-100200\\\"\"\n            }), \" \\n    \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"pattern\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"[A-Z]{2}-[0-9]{6}\\\"\"\n            }), \" \\n    \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"required\"\n            }), \" \\n   /\u003e\"]\n          })\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"input\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"type\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"submit\\\"\"\n            }), \"/\u003e\"]\n          })\n        }), \"\\n\u003c/form\u003e\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 pattern 속성은 유효하지 않은 입력에 대한 브라우저별 유효성 메시지를 표시하여 제출을 방지해요. 그렇다면 실시간 유효성 검사를 어떻게 구현할 수 있을까요?\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"패턴에 대한 실시간 유효성 검사는 다음 HTML 코드 조각에 표시된 대로 \", _jsx(_components.div, {}), \" 및 \", _jsx(_components.div, {}), \" CSS 가상 클래스를 사용하여 가능합니다:\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003cstyle\u003e\\n  input[type=text] {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"border\"\n        }), \": #\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"000\"\n        }), \" 1px solid;\\n    border-\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"radius\"\n        }), \": 4px;\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"outline\"\n        }), \": none;\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"padding\"\n        }), \": 6px;\\n  }\\n\\n  input[type=text]:invalid {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"border\"\n        }), \": red 1px solid;\\n     + \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"span\"\n        }), \"::before {\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"content\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'✖'\"\n        }), \";\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"display\"\n        }), \": inline;\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"color\"\n        }), \": red;\\n    }\\n  }\\n  \\n  input[type=text]:valid {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"border\"\n        }), \": green 1px solid;\\n    + \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"span\"\n        }), \"::before {\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"content\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'✓'\"\n        }), \";\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"display\"\n        }), \": inline;\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"color\"\n        }), \": green;\\n    }\\n  }\\n\\n\u003c/style\u003e\\n\\n\", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"input\"\n            }), \" \\n  \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"type\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"text\\\"\"\n            }), \" \\n  \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"placeholder\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"예: GR-100200\\\"\"\n            }), \" \\n  \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"pattern\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"[A-Z]{2}-[0-9]{6}\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"required\"\n            }), \"\\n/\u003e\"]\n          })\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"span\"\n            }), \"\u003e\"]\n          }), _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"span\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 HTML 코드 조각은 유효성 상태에 따라 스타일을 설정하기 위해 CSS 코드를 사용합니다. 아래 미리보기에서와 같이, 유효하지 않은 입력값은 입력 상자 테두리를 빨간색으로 변하고 빨간색 교차 표시를 표시합니다. 한편, 유효한 입력값은 녹색 테두리와 녹색 확인 표시가 렌더링됩니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"https://miro.medium.com/v2/resize:fit:954/1*yCIHUIN8Sn6IMxuFbv0YVg.gif\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"\\n\u003cdiv class=\\\"content-ad\\\"\u003e\u003c/div\u003e\\n\\n아래 이야기에서 :valid 및 :invalid와 같은 CSS 가상 요소에 대해 더 알아보세요:\\n\\nJavaScript에서 패턴을 사용하는 입력의 validity를 확인하기 위해 다음과 같이 JavaScript에서 입력의 validityState 인터페이스에 액세스할 수 있습니다:\\n\\n```js\\nif(productInput.validity.valid) {\\n  // 할 일...\\n}\\n\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"inputmode 속성을 사용하여 모바일 가상 키보드 모드 다루기\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"현대 모바일 기기는 일반적으로 물리 키보드가 없습니다. 그 대신 터치 스크린에 렌더링되는 가상 키보드가 제공됩니다. 이 가상 키보드에는 여러 모드가 있습니다. 예를 들어 숫자 입력 요소에는 숫자 키만 표시되고 일반 문자열 입력에 대해서는 전체 키보드 인터페이스가 표시될 수 있습니다. 모바일 브라우저는 입력 유형에 따라 가상 키보드 모드를 자동으로 변경하지만 개발자는 input 요소의 inputmode 속성을 사용하여 사용자 정의할 수도 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용자로부터 OTP PIN을 입력받기 위해 특정 패턴을 사용하는 텍스트 입력을 사용한다고 가정해보겠습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003cinput type=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"text\\\"\"\n        }), \" placeholder=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Enter OTP\\\"\"\n        }), \" pattern=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"[0-9]{4}\\\"\"\n        }), \" required /\u003e\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이는 범용 문자열 유형 입력이므로 모바일은 전체 키보드 레이아웃을 표시합니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-md\",\n        children: [\"![\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"이미지\"\n        }), \"](\", _jsx(_components.span, {\n          className: \"hljs-link\",\n          children: \"/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_1.png\"\n        }), \")\\n\\n입력 요소와 함께 inputmode 속성을 다음과 같이 사용해봅시다:\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-code\",\n          children: \"```js\\ninputmode=\\\"numeric\\\"\\n\"\n        })]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 모바일에서 숫자 키보드 레이아웃을 확인할 수 있습니다. 아래 미리보기를 참고하세요:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_2.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"loading 속성을 이용한 브라우저 레벨 이미지 지연 로딩\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"웹 개발자들은 페이지 로딩 시간을 개선하여 SEO (검색 엔진 최적화) 점수를 높이고 사용자 상호 작용을 향상시키려고 노력합니다. 이미지의 지연 로딩은 특정 이미지를 렌더링할 때 해당 이미지를로드하여 초기 페이지 로딩 시간을 줄이는 잘 알려진 전략입니다. 이미지의 지연 로딩은 Intersection Observer API 또는 전통적인 스크롤 이벤트를 사용하여 자체 구현하거나 서드파티 라이브러리를 사용하여 가능합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"img 태그의 loading 속성을 사용하면 JavaScript 코드없이 또는 서드파티 라이브러리를 사용하지 않고 브라우저 레벨의 이미지 지연 로딩을 활성화할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 소스 코드를 살펴보세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003cdiv style=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"height: 2000px\\\"\"\n        }), \"\u003e\u003c/div\u003e\\n\\n\", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"img\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"src\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"https://source.unsplash.com/vpOeXr5wmR4\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"width\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"400\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"height\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"240\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"loading\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"lazy\\\"\"\n            }), \" /\u003e\"]\n          })\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기에는 사용자가 해당 이미지로 스크롤할 때에만 위 무료 이미지가 로드되며 초기 페이지 로드 시간에 영향을 주지 않게 되어 있습니다. 아래 미리 보기에서 확인할 수 있습니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"https://miro.medium.com/v2/resize:fit:1400/1*uy6OnakZEP-X8_0mbRHVPw.gif\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"현재 HTML 명세에서는 lazy loading을 사용자화할 수 없지만, 브라우저는 브라우저 수준의 lazy-loading을 사용하는 개발자가 더 많아진다면 커스터마이즈 옵션을 제공할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"사용자 지정 data-* 속성 사용\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"브라우저는 일반적으로 HTML 속성 이름에 엄격한 유효성 검사 규칙을 적용하지 않으므로 개발자는 원하는 사용자 정의 속성 이름을 사용할 수 있습니다. 그러나 사용자 정의 속성에 대한 다양한 명명 규칙을 사용하는 것은 좋지 않은 실천 방법입니다. 왜냐하면 그것은 HTML 문서 명세를 무효화하기 때문입니다. HTML 표준은 사용자 정의 속성에 대해 data- 접두사 사용을 권장하며 DOM API에서도 명시적인 기능을 제공하여 개발자를 독려합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 일부 사용자 정의 data 속성을 사용하는 샘플 HTML 요소입니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"\u003cdiv \\n  id=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"elm\\\"\"\n        }), \" \\n  data-player-name=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"John\\\"\"\n        }), \"\\n  data-player-score=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"20\\\"\"\n        }), \"\\n  data-player-city=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"LA\\\"\"\n        }), \"\u003e\\n\u003c/div\u003e\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자바스크립트를 통해 디스트럭처링으로 카멜 표기법 키를 사용하여 이러한 사용자 지정 속성 값을 쉽게 액세스할 수 있습니다. 다음 코드 스니펫에서 보여지듯이:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" { playerName, playerScore, playerCity } = \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"document\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getElementById\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'elm'\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"dataset\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(playerName, playerScore, playerCity); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// John 20 LA\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한 CSS 문서 내에서 이러한 데이터 속성에 액세스할 수도 있습니다.```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"#\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"elm\"\n        }), \"::before {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"content\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"attr\"\n        }), \"(data-player-name) \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\" - \\\"\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"attr\"\n        }), \"(data-player-score)\\n}\\n\\n#elm {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"display\"\n        }), \": inline-block;\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"padding\"\n        }), \": 12px;\\n  background-\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"color\"\n        }), \": #ddd;\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 CSS 코드 조각은 data-player-name과 data-score 값을 HTML 요소 위에 다음과 같이 렌더링합니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow_3.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제3자 라이브러리를 사용하지 않고도 최신 네이티브 HTML 태그를 사용하여 간결하고 사용자 친화적이며 성능이 우수하며 접근성이 좋은 웹 프론트엔드를 개발할 수 있습니다. 아래 이야기로 더 자세히 알아보세요:```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"읽어 주셔서 감사합니다!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-01-HTMLAttributesThatEveryWebDeveloperShouldKnow"},"buildId":"z1a6VTi5qHH9JJH7jaxL3","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>