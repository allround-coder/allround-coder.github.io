<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>윈도우 IIS 서버에 NextJs 애플리케이션을 배포하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-20-DeployingNextJsApplicationonWindowsIISServer" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="윈도우 IIS 서버에 NextJs 애플리케이션을 배포하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="윈도우 IIS 서버에 NextJs 애플리케이션을 배포하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-DeployingNextJsApplicationonWindowsIISServer_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-20-DeployingNextJsApplicationonWindowsIISServer" data-gatsby-head="true"/><meta name="twitter:title" content="윈도우 IIS 서버에 NextJs 애플리케이션을 배포하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-DeployingNextJsApplicationonWindowsIISServer_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 22:10" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">윈도우 IIS 서버에 NextJs 애플리케이션을 배포하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="윈도우 IIS 서버에 NextJs 애플리케이션을 배포하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-DeployingNextJsApplicationonWindowsIISServer&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-20-DeployingNextJsApplicationonWindowsIISServer_0.png" alt="Deploying Next.js Application on Windows IIS Server"></p>
<p>NextJS는 단일 페이지 애플리케이션을 만들기 위한 서버 측 렌더링된 React 기반 프레임워크입니다. 서버 측 렌더링 기능으로 인해 매우 인기가 높습니다. NextJS를 사용하여 다음 애플리케이션을 작성하는 것은 매우 간단합니다. NextJS를 사용하기 위해 명시적으로 구성할 필요가 없습니다. npm run dev를 실행하고 애플리케이션을 구축하기 시작하면 됩니다.</p>
<h1>서버 측 렌더링이란?</h1>
<p>서버 측 렌더링(SSR)은 프런트엔드 프레임워크가 웹페이지를 준비하기 위해 사용자별 데이터를 서버 측에서 가져와 사용자 화면으로 보내는 능력입니다. 사용자에게 표시하기 위해 클라이언트 측에서 웹페이지를 준비하는 대신에 서버 측에서 웹페이지를 준비합니다.</p>
<div class="content-ad"></div>
<p>NextJS에서는 서버에서 페이지를 렌더링하거나 일반적인 create-react-app SPA처럼 클라이언트 측에서 렌더링할 수 있는 옵션이 있습니다.</p>
<p>서버 측 렌더링의 장점은 분명히 있습니다. 그래서 NextJS 프레임워크가 인기를 얻은 이유이기도 합니다. SSR 덕분에 초기 페이지 로딩이 빨라져 최종 사용자에게 더 나은 상호작용을 제공합니다. 또한 검색 엔진이 사이트를 크롤링하여 더 나은 검색 엔진 최적화를 제공하는데 도움이 됩니다.</p>
<h1>만약 NextJS가 프론트엔드 프레임워크라면, 이 프레임워크는 어떻게 서버에서 웹 페이지를 준비하는 것일까요?</h1>
<p>NextJS 프레임워크는 NodeJS 기반으로 만들어졌습니다. 아시다시피, NodeJS는 서버 측에서 페이지를 준비하기 위해 사용되는 NextJS 애플리케이션에 강력함을 제공하는 백엔드 JavaScript 런타임 환경입니다.</p>
<div class="content-ad"></div>
<h1>NextJS 애플리케이션 배포하기</h1>
<p>Windows IIS에서 Next.js 애플리케이션을 호스팅하는 방법을 여러 곳에서 찾아보았어요. 괜찮은 튜토리얼을 몇 개 찾았지만 제 문제를 해결해 주지는 못했어요. Vercel과 Netlify, Heroku 등과 같은 유사한 플랫폼에 호스팅하는 것이 이상적일 것 같아요. 하지만 제 애플리케이션을 로컬에서 호스팅하고 싶어요. 왜냐하면 내 애플리케이션에 대중이 접근하는 것을 원하지 않기 때문이에요. 그건 제 개인적인 용도로 사용할 거거든요. 그래서 여러분이 구글에서 시간을 낭비하지 않고 필요한 정보를 찾을 수 있도록, 간단한 가이드를 제공해 드리겠어요.</p>
<p>하지만 그 전에, 사용하려는 것에 대해 간단히 설명해볼게요.</p>
<p>저희는 iisnode을 사용하려고 해요. iisnode은 C++로 작성된 오픈 소스 네이티브 IIS 모듈로, Node.js를 Windows IIS 내에서 실행할 수 있게 해줘요. 저희는 IIS 서버 배포 방식으로 Node.js를 사용할 거에요. 그러려면 Server.js와 web.config 두 파일이 필요하답니다.</p>
<div class="content-ad"></div>
<p>지금 application의 진입점인 server.js를 만들어보겠습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { createServer } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"http"</span>);
<span class="hljs-keyword">const</span> { parse } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"url"</span>);
<span class="hljs-keyword">const</span> next = <span class="hljs-built_in">require</span>(<span class="hljs-string">"next"</span>);

<span class="hljs-keyword">const</span> dev = process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">"production"</span>;

<span class="hljs-keyword">const</span> port = process.<span class="hljs-property">env</span>.<span class="hljs-property">PORT</span> || <span class="hljs-number">3000</span>; <span class="hljs-comment">// 포트를 IIS가 실행 중인 포트로 변경하세요. 기본값은 80이고 개발 중이면 3000입니다.</span>
<span class="hljs-keyword">const</span> hostname = <span class="hljs-string">"localhost"</span>;
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">next</span>({ dev, hostname, port });
<span class="hljs-keyword">const</span> handle = app.<span class="hljs-title function_">getRequestHandler</span>();

app.<span class="hljs-title function_">prepare</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">async</span> (req, res) => {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> parsedUrl = <span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>, <span class="hljs-literal">true</span>);
      <span class="hljs-keyword">const</span> { pathname, query } = parsedUrl;

      <span class="hljs-keyword">if</span> (pathname === <span class="hljs-string">"/a"</span>) {
        <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">render</span>(req, res, <span class="hljs-string">"/a"</span>, query);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pathname === <span class="hljs-string">"/b"</span>) {
        <span class="hljs-keyword">await</span> app.<span class="hljs-title function_">render</span>(req, res, <span class="hljs-string">"/b"</span>, query);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">await</span> <span class="hljs-title function_">handle</span>(req, res, parsedUrl);
      }
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"Error occurred handling"</span>, req.<span class="hljs-property">url</span>, err);
      res.<span class="hljs-property">statusCode</span> = <span class="hljs-number">500</span>;
      res.<span class="hljs-title function_">end</span>(<span class="hljs-string">"internal server error"</span>);
    }
  })
    .<span class="hljs-title function_">once</span>(<span class="hljs-string">"error"</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =></span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err);
      process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>);
    })
    .<span class="hljs-title function_">listen</span>(port, <span class="hljs-keyword">async</span> () => {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`> Ready on http://localhost:<span class="hljs-subst">${port}</span>`</span>);
    });
});
</code></pre>
<p>웹 구성 파일인 web.config은 IIS 및 ASP.NET Core Module이 응용 프로그램을 구성하는 데 사용하는 파일입니다. 그래서 여기에 우리의 web.config 파일이 있습니다:</p>
<pre><code class="hljs language-js">&#x3C;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?>
&#x3C;!--
     이 구성 파일은 iisnode를 사용하여 <span class="hljs-variable constant_">IIS</span> 또는 <span class="hljs-variable constant_">IIS</span> <span class="hljs-title class_">Express</span>에서 노드 프로세스를 실행하는 경우 필요합니다.
     자세한 내용은 다음을 참조하십시오:

     <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/tjanczuk/iisnode/blob/master/src/samples/configuration/web.config</span>
-->

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">configuration</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">system.webServer</span>></span>
    <span class="hljs-comment">&#x3C;!-- WebSocket 지원에 대한 자세한 정보는 http://blogs.msdn.com/b/windowsazure/archive/2013/11/14/introduction-to-websockets-on-windows-azure-web-sites.aspx에서 확인할 수 있습니다 --></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">webSocket</span> <span class="hljs-attr">enabled</span>=<span class="hljs-string">"false"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">handlers</span>></span>
      <span class="hljs-comment">&#x3C;!-- server.js 파일이 iisnode 모듈에 의해 처리되는 node.js 사이트임을 나타냄 --></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"iisnode"</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"server.js"</span> <span class="hljs-attr">verb</span>=<span class="hljs-string">"*"</span> <span class="hljs-attr">modules</span>=<span class="hljs-string">"iisnode"</span>/></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">handlers</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">rewrite</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">rules</span>></span>
        <span class="hljs-comment">&#x3C;!-- node-inspector 디버깅을 위한 요청 방해하지 않음 --></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">rule</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"NodeInspector"</span> <span class="hljs-attr">patternSyntax</span>=<span class="hljs-string">"ECMAScript"</span> <span class="hljs-attr">stopProcessing</span>=<span class="hljs-string">"true"</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">match</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"^server.js\/debug[\/]?"</span> /></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">rule</span>></span>

        <span class="hljs-comment">&#x3C;!-- 먼저 /public 폴더의 물리적 파일과 일치하는 들어오는 URL을 고려 --></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">rule</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"StaticContent"</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">action</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Rewrite"</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"public{REQUEST_URI}"</span>/></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">rule</span>></span>

        <span class="hljs-comment">&#x3C;!-- 모든 다른 URL은 node.js 사이트 진입점으로 매핑됨 --></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">rule</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"DynamicContent"</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">conditions</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">add</span> <span class="hljs-attr">input</span>=<span class="hljs-string">"{REQUEST_FILENAME}"</span> <span class="hljs-attr">matchType</span>=<span class="hljs-string">"IsFile"</span> <span class="hljs-attr">negate</span>=<span class="hljs-string">"True"</span>/></span>
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">conditions</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">action</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"Rewrite"</span> <span class="hljs-attr">url</span>=<span class="hljs-string">"server.js"</span>/></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">rule</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">rules</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">rewrite</span>></span>
    
    <span class="hljs-comment">&#x3C;!-- 'bin' 디렉토리는 node.js에서 특별한 의미가 없으며, 앱을 그 안에 배치할 수 있음 --></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">security</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">requestFiltering</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">hiddenSegments</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">add</span> <span class="hljs-attr">segment</span>=<span class="hljs-string">"node_modules"</span>/></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">hiddenSegments</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">requestFiltering</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">security</span>></span>

    <span class="hljs-comment">&#x3C;!-- 오류 응답을 변경하지 않도록 함 --></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">httpErrors</span> <span class="hljs-attr">existingResponse</span>=<span class="hljs-string">"PassThrough"</span> /></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">iisnode</span> <span class="hljs-attr">node_env</span>=<span class="hljs-string">"production"</span>/></span>

    <span class="hljs-comment">&#x3C;!--
      다음 옵션을 사용하여 IIS 내에서 Node를 호스트하는 방법을 제어할 수 있습니다:
        * watchedFiles: 변경 사항을 감지하여 서버를 다시 시작할 파일 목록
        * node_env: NODE_ENV 환경 변수로 전달될 값
        * debuggingEnabled - 기본 디버거가 활성화되는지 여부

      모든 옵션 목록은 https://github.com/tjanczuk/iisnode/blob/master/src/samples/configuration/web.config에서 확인 가능합니다
    --></span>
    <span class="hljs-comment">&#x3C;!--&#x3C;iisnode watchedFiles="web.config;*.js"/>--></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">system.webServer</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">configuration</span>></span></span>
</code></pre>
<div class="content-ad"></div>
<p>웹 구성 파일을 추가한 후에는 package.json을 약간 변경해야 합니다. npm run start가 서버를 시작하도록 설정되어야 하며 next start를 사용하지 않아야 합니다. 다음은 package.json 스크립트가 보이는 방식입니다:</p>
<pre><code class="hljs language-js">  <span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"dev"</span>: <span class="hljs-string">"node server.js"</span>,
    <span class="hljs-string">"build"</span>: <span class="hljs-string">"next build"</span>,
    <span class="hljs-string">"start"</span>: <span class="hljs-string">"node server.js"</span>,
    <span class="hljs-string">"lint"</span>: <span class="hljs-string">"next lint"</span>
  },
</code></pre>
<p>server.js를 추가하고 web.config를 추가한 후 npm run build를 실행하면 애플리케이션의 루트 폴더가 다음과 같이 보입니다.</p>
<p><img src="/assets/img/2024-05-20-DeployingNextJsApplicationonWindowsIISServer_1.png" alt="애플리케이션 루트 폴더"></p>
<div class="content-ad"></div>
<h1>IIS에서 NextJS 애플리케이션을 배포하는 방법</h1>
<p>배포를 설정하기 전에 IISNode와 URLRewrite를 설치해야 합니다. 그 후, IIS에 새 웹 사이트를 생성하고 물리적 경로를 .next, node_modules, server.js 및 web.config가 포함된 폴더로 지정하세요. 권한 문제나 다른 가능한 문제를 피하려면 해당 폴더를 Windows Server의 루트 사용자 폴더 안에 배치하세요.</p>
<p>IIS에서 웹 서버를 시작하면 자동으로 iisnode이라는 새 폴더가 생성됩니다.</p>
<p>만약 배포 폴더가 C:/ 드라이브의 wwwroot에 있다면 전체 폴더에 대해 IIS_Users에게 읽기/쓰기 권한을 명시적으로 부여해야 할 수 있습니다. 다른 예상치 못한 오류가 발생하는 경우, 댓글을 남기거나 내 Discord @pallepadehat을 추가해주세요. 도와드릴게요!</p>
<div class="content-ad"></div>
<p>이 Github Repo에서 소스 코드를 확인할 수 있어요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"윈도우 IIS 서버에 NextJs 애플리케이션을 배포하는 방법","description":"","date":"2024-05-20 22:10","slug":"2024-05-20-DeployingNextJsApplicationonWindowsIISServer","content":"\n\n\n![Deploying Next.js Application on Windows IIS Server](/assets/img/2024-05-20-DeployingNextJsApplicationonWindowsIISServer_0.png)\n\nNextJS는 단일 페이지 애플리케이션을 만들기 위한 서버 측 렌더링된 React 기반 프레임워크입니다. 서버 측 렌더링 기능으로 인해 매우 인기가 높습니다. NextJS를 사용하여 다음 애플리케이션을 작성하는 것은 매우 간단합니다. NextJS를 사용하기 위해 명시적으로 구성할 필요가 없습니다. npm run dev를 실행하고 애플리케이션을 구축하기 시작하면 됩니다.\n\n# 서버 측 렌더링이란?\n\n서버 측 렌더링(SSR)은 프런트엔드 프레임워크가 웹페이지를 준비하기 위해 사용자별 데이터를 서버 측에서 가져와 사용자 화면으로 보내는 능력입니다. 사용자에게 표시하기 위해 클라이언트 측에서 웹페이지를 준비하는 대신에 서버 측에서 웹페이지를 준비합니다.\n \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNextJS에서는 서버에서 페이지를 렌더링하거나 일반적인 create-react-app SPA처럼 클라이언트 측에서 렌더링할 수 있는 옵션이 있습니다.\n\n서버 측 렌더링의 장점은 분명히 있습니다. 그래서 NextJS 프레임워크가 인기를 얻은 이유이기도 합니다. SSR 덕분에 초기 페이지 로딩이 빨라져 최종 사용자에게 더 나은 상호작용을 제공합니다. 또한 검색 엔진이 사이트를 크롤링하여 더 나은 검색 엔진 최적화를 제공하는데 도움이 됩니다.\n\n# 만약 NextJS가 프론트엔드 프레임워크라면, 이 프레임워크는 어떻게 서버에서 웹 페이지를 준비하는 것일까요?\n\nNextJS 프레임워크는 NodeJS 기반으로 만들어졌습니다. 아시다시피, NodeJS는 서버 측에서 페이지를 준비하기 위해 사용되는 NextJS 애플리케이션에 강력함을 제공하는 백엔드 JavaScript 런타임 환경입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# NextJS 애플리케이션 배포하기\n\nWindows IIS에서 Next.js 애플리케이션을 호스팅하는 방법을 여러 곳에서 찾아보았어요. 괜찮은 튜토리얼을 몇 개 찾았지만 제 문제를 해결해 주지는 못했어요. Vercel과 Netlify, Heroku 등과 같은 유사한 플랫폼에 호스팅하는 것이 이상적일 것 같아요. 하지만 제 애플리케이션을 로컬에서 호스팅하고 싶어요. 왜냐하면 내 애플리케이션에 대중이 접근하는 것을 원하지 않기 때문이에요. 그건 제 개인적인 용도로 사용할 거거든요. 그래서 여러분이 구글에서 시간을 낭비하지 않고 필요한 정보를 찾을 수 있도록, 간단한 가이드를 제공해 드리겠어요.\n\n하지만 그 전에, 사용하려는 것에 대해 간단히 설명해볼게요.\n\n저희는 iisnode을 사용하려고 해요. iisnode은 C++로 작성된 오픈 소스 네이티브 IIS 모듈로, Node.js를 Windows IIS 내에서 실행할 수 있게 해줘요. 저희는 IIS 서버 배포 방식으로 Node.js를 사용할 거에요. 그러려면 Server.js와 web.config 두 파일이 필요하답니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 application의 진입점인 server.js를 만들어보겠습니다:\n\n```js\nconst { createServer } = require(\"http\");\nconst { parse } = require(\"url\");\nconst next = require(\"next\");\n\nconst dev = process.env.NODE_ENV !== \"production\";\n\nconst port = process.env.PORT || 3000; // 포트를 IIS가 실행 중인 포트로 변경하세요. 기본값은 80이고 개발 중이면 3000입니다.\nconst hostname = \"localhost\";\nconst app = next({ dev, hostname, port });\nconst handle = app.getRequestHandler();\n\napp.prepare().then(() =\u003e {\n  createServer(async (req, res) =\u003e {\n    try {\n      const parsedUrl = parse(req.url, true);\n      const { pathname, query } = parsedUrl;\n\n      if (pathname === \"/a\") {\n        await app.render(req, res, \"/a\", query);\n      } else if (pathname === \"/b\") {\n        await app.render(req, res, \"/b\", query);\n      } else {\n        await handle(req, res, parsedUrl);\n      }\n    } catch (err) {\n      console.error(\"Error occurred handling\", req.url, err);\n      res.statusCode = 500;\n      res.end(\"internal server error\");\n    }\n  })\n    .once(\"error\", (err) =\u003e {\n      console.error(err);\n      process.exit(1);\n    })\n    .listen(port, async () =\u003e {\n      console.log(`\u003e Ready on http://localhost:${port}`);\n    });\n});\n```\n\n웹 구성 파일인 web.config은 IIS 및 ASP.NET Core Module이 응용 프로그램을 구성하는 데 사용하는 파일입니다. 그래서 여기에 우리의 web.config 파일이 있습니다:\n\n```js\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003c!--\n     이 구성 파일은 iisnode를 사용하여 IIS 또는 IIS Express에서 노드 프로세스를 실행하는 경우 필요합니다.\n     자세한 내용은 다음을 참조하십시오:\n\n     https://github.com/tjanczuk/iisnode/blob/master/src/samples/configuration/web.config\n--\u003e\n\n\u003cconfiguration\u003e\n  \u003csystem.webServer\u003e\n    \u003c!-- WebSocket 지원에 대한 자세한 정보는 http://blogs.msdn.com/b/windowsazure/archive/2013/11/14/introduction-to-websockets-on-windows-azure-web-sites.aspx에서 확인할 수 있습니다 --\u003e\n    \u003cwebSocket enabled=\"false\" /\u003e\n    \u003chandlers\u003e\n      \u003c!-- server.js 파일이 iisnode 모듈에 의해 처리되는 node.js 사이트임을 나타냄 --\u003e\n      \u003cadd name=\"iisnode\" path=\"server.js\" verb=\"*\" modules=\"iisnode\"/\u003e\n    \u003c/handlers\u003e\n    \u003crewrite\u003e\n      \u003crules\u003e\n        \u003c!-- node-inspector 디버깅을 위한 요청 방해하지 않음 --\u003e\n        \u003crule name=\"NodeInspector\" patternSyntax=\"ECMAScript\" stopProcessing=\"true\"\u003e\n          \u003cmatch url=\"^server.js\\/debug[\\/]?\" /\u003e\n        \u003c/rule\u003e\n\n        \u003c!-- 먼저 /public 폴더의 물리적 파일과 일치하는 들어오는 URL을 고려 --\u003e\n        \u003crule name=\"StaticContent\"\u003e\n          \u003caction type=\"Rewrite\" url=\"public{REQUEST_URI}\"/\u003e\n        \u003c/rule\u003e\n\n        \u003c!-- 모든 다른 URL은 node.js 사이트 진입점으로 매핑됨 --\u003e\n        \u003crule name=\"DynamicContent\"\u003e\n          \u003cconditions\u003e\n            \u003cadd input=\"{REQUEST_FILENAME}\" matchType=\"IsFile\" negate=\"True\"/\u003e\n          \u003c/conditions\u003e\n          \u003caction type=\"Rewrite\" url=\"server.js\"/\u003e\n        \u003c/rule\u003e\n      \u003c/rules\u003e\n    \u003c/rewrite\u003e\n    \n    \u003c!-- 'bin' 디렉토리는 node.js에서 특별한 의미가 없으며, 앱을 그 안에 배치할 수 있음 --\u003e\n    \u003csecurity\u003e\n      \u003crequestFiltering\u003e\n        \u003chiddenSegments\u003e\n          \u003cadd segment=\"node_modules\"/\u003e\n        \u003c/hiddenSegments\u003e\n      \u003c/requestFiltering\u003e\n    \u003c/security\u003e\n\n    \u003c!-- 오류 응답을 변경하지 않도록 함 --\u003e\n    \u003chttpErrors existingResponse=\"PassThrough\" /\u003e\n    \u003ciisnode node_env=\"production\"/\u003e\n\n    \u003c!--\n      다음 옵션을 사용하여 IIS 내에서 Node를 호스트하는 방법을 제어할 수 있습니다:\n        * watchedFiles: 변경 사항을 감지하여 서버를 다시 시작할 파일 목록\n        * node_env: NODE_ENV 환경 변수로 전달될 값\n        * debuggingEnabled - 기본 디버거가 활성화되는지 여부\n\n      모든 옵션 목록은 https://github.com/tjanczuk/iisnode/blob/master/src/samples/configuration/web.config에서 확인 가능합니다\n    --\u003e\n    \u003c!--\u003ciisnode watchedFiles=\"web.config;*.js\"/\u003e--\u003e\n  \u003c/system.webServer\u003e\n\u003c/configuration\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 구성 파일을 추가한 후에는 package.json을 약간 변경해야 합니다. npm run start가 서버를 시작하도록 설정되어야 하며 next start를 사용하지 않아야 합니다. 다음은 package.json 스크립트가 보이는 방식입니다:\n\n```js\n  \"scripts\": {\n    \"dev\": \"node server.js\",\n    \"build\": \"next build\",\n    \"start\": \"node server.js\",\n    \"lint\": \"next lint\"\n  },\n```\n\nserver.js를 추가하고 web.config를 추가한 후 npm run build를 실행하면 애플리케이션의 루트 폴더가 다음과 같이 보입니다.\n\n![애플리케이션 루트 폴더](/assets/img/2024-05-20-DeployingNextJsApplicationonWindowsIISServer_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# IIS에서 NextJS 애플리케이션을 배포하는 방법\n\n배포를 설정하기 전에 IISNode와 URLRewrite를 설치해야 합니다. 그 후, IIS에 새 웹 사이트를 생성하고 물리적 경로를 .next, node_modules, server.js 및 web.config가 포함된 폴더로 지정하세요. 권한 문제나 다른 가능한 문제를 피하려면 해당 폴더를 Windows Server의 루트 사용자 폴더 안에 배치하세요.\n\nIIS에서 웹 서버를 시작하면 자동으로 iisnode이라는 새 폴더가 생성됩니다.\n\n만약 배포 폴더가 C:/ 드라이브의 wwwroot에 있다면 전체 폴더에 대해 IIS_Users에게 읽기/쓰기 권한을 명시적으로 부여해야 할 수 있습니다. 다른 예상치 못한 오류가 발생하는 경우, 댓글을 남기거나 내 Discord @pallepadehat을 추가해주세요. 도와드릴게요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 Github Repo에서 소스 코드를 확인할 수 있어요.","ogImage":{"url":"/assets/img/2024-05-20-DeployingNextJsApplicationonWindowsIISServer_0.png"},"coverImage":"/assets/img/2024-05-20-DeployingNextJsApplicationonWindowsIISServer_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-DeployingNextJsApplicationonWindowsIISServer_0.png\" alt=\"Deploying Next.js Application on Windows IIS Server\"\u003e\u003c/p\u003e\n\u003cp\u003eNextJS는 단일 페이지 애플리케이션을 만들기 위한 서버 측 렌더링된 React 기반 프레임워크입니다. 서버 측 렌더링 기능으로 인해 매우 인기가 높습니다. NextJS를 사용하여 다음 애플리케이션을 작성하는 것은 매우 간단합니다. NextJS를 사용하기 위해 명시적으로 구성할 필요가 없습니다. npm run dev를 실행하고 애플리케이션을 구축하기 시작하면 됩니다.\u003c/p\u003e\n\u003ch1\u003e서버 측 렌더링이란?\u003c/h1\u003e\n\u003cp\u003e서버 측 렌더링(SSR)은 프런트엔드 프레임워크가 웹페이지를 준비하기 위해 사용자별 데이터를 서버 측에서 가져와 사용자 화면으로 보내는 능력입니다. 사용자에게 표시하기 위해 클라이언트 측에서 웹페이지를 준비하는 대신에 서버 측에서 웹페이지를 준비합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eNextJS에서는 서버에서 페이지를 렌더링하거나 일반적인 create-react-app SPA처럼 클라이언트 측에서 렌더링할 수 있는 옵션이 있습니다.\u003c/p\u003e\n\u003cp\u003e서버 측 렌더링의 장점은 분명히 있습니다. 그래서 NextJS 프레임워크가 인기를 얻은 이유이기도 합니다. SSR 덕분에 초기 페이지 로딩이 빨라져 최종 사용자에게 더 나은 상호작용을 제공합니다. 또한 검색 엔진이 사이트를 크롤링하여 더 나은 검색 엔진 최적화를 제공하는데 도움이 됩니다.\u003c/p\u003e\n\u003ch1\u003e만약 NextJS가 프론트엔드 프레임워크라면, 이 프레임워크는 어떻게 서버에서 웹 페이지를 준비하는 것일까요?\u003c/h1\u003e\n\u003cp\u003eNextJS 프레임워크는 NodeJS 기반으로 만들어졌습니다. 아시다시피, NodeJS는 서버 측에서 페이지를 준비하기 위해 사용되는 NextJS 애플리케이션에 강력함을 제공하는 백엔드 JavaScript 런타임 환경입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eNextJS 애플리케이션 배포하기\u003c/h1\u003e\n\u003cp\u003eWindows IIS에서 Next.js 애플리케이션을 호스팅하는 방법을 여러 곳에서 찾아보았어요. 괜찮은 튜토리얼을 몇 개 찾았지만 제 문제를 해결해 주지는 못했어요. Vercel과 Netlify, Heroku 등과 같은 유사한 플랫폼에 호스팅하는 것이 이상적일 것 같아요. 하지만 제 애플리케이션을 로컬에서 호스팅하고 싶어요. 왜냐하면 내 애플리케이션에 대중이 접근하는 것을 원하지 않기 때문이에요. 그건 제 개인적인 용도로 사용할 거거든요. 그래서 여러분이 구글에서 시간을 낭비하지 않고 필요한 정보를 찾을 수 있도록, 간단한 가이드를 제공해 드리겠어요.\u003c/p\u003e\n\u003cp\u003e하지만 그 전에, 사용하려는 것에 대해 간단히 설명해볼게요.\u003c/p\u003e\n\u003cp\u003e저희는 iisnode을 사용하려고 해요. iisnode은 C++로 작성된 오픈 소스 네이티브 IIS 모듈로, Node.js를 Windows IIS 내에서 실행할 수 있게 해줘요. 저희는 IIS 서버 배포 방식으로 Node.js를 사용할 거에요. 그러려면 Server.js와 web.config 두 파일이 필요하답니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e지금 application의 진입점인 server.js를 만들어보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { createServer } = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"http\"\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { parse } = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"url\"\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e next = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"next\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dev = process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNODE_ENV\u003c/span\u003e !== \u003cspan class=\"hljs-string\"\u003e\"production\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e port = process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePORT\u003c/span\u003e || \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 포트를 IIS가 실행 중인 포트로 변경하세요. 기본값은 80이고 개발 중이면 3000입니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hostname = \u003cspan class=\"hljs-string\"\u003e\"localhost\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e({ dev, hostname, port });\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e handle = app.\u003cspan class=\"hljs-title function_\"\u003egetRequestHandler\u003c/span\u003e();\n\napp.\u003cspan class=\"hljs-title function_\"\u003eprepare\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003ecreateServer\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (req, res) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e parsedUrl = \u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(req.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { pathname, query } = parsedUrl;\n\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (pathname === \u003cspan class=\"hljs-string\"\u003e\"/a\"\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e app.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(req, res, \u003cspan class=\"hljs-string\"\u003e\"/a\"\u003c/span\u003e, query);\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (pathname === \u003cspan class=\"hljs-string\"\u003e\"/b\"\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e app.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(req, res, \u003cspan class=\"hljs-string\"\u003e\"/b\"\u003c/span\u003e, query);\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandle\u003c/span\u003e(req, res, parsedUrl);\n      }\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Error occurred handling\"\u003c/span\u003e, req.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e, err);\n      res.\u003cspan class=\"hljs-property\"\u003estatusCode\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e;\n      res.\u003cspan class=\"hljs-title function_\"\u003eend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"internal server error\"\u003c/span\u003e);\n    }\n  })\n    .\u003cspan class=\"hljs-title function_\"\u003eonce\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"error\"\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(err);\n      process.\u003cspan class=\"hljs-title function_\"\u003eexit\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n    })\n    .\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(port, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003e Ready on http://localhost:\u003cspan class=\"hljs-subst\"\u003e${port}\u003c/span\u003e`\u003c/span\u003e);\n    });\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e웹 구성 파일인 web.config은 IIS 및 ASP.NET Core Module이 응용 프로그램을 구성하는 데 사용하는 파일입니다. 그래서 여기에 우리의 web.config 파일이 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;?xml version=\u003cspan class=\"hljs-string\"\u003e\"1.0\"\u003c/span\u003e encoding=\u003cspan class=\"hljs-string\"\u003e\"utf-8\"\u003c/span\u003e?\u003e\n\u0026#x3C;!--\n     이 구성 파일은 iisnode를 사용하여 \u003cspan class=\"hljs-variable constant_\"\u003eIIS\u003c/span\u003e 또는 \u003cspan class=\"hljs-variable constant_\"\u003eIIS\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExpress\u003c/span\u003e에서 노드 프로세스를 실행하는 경우 필요합니다.\n     자세한 내용은 다음을 참조하십시오:\n\n     \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//github.com/tjanczuk/iisnode/blob/master/src/samples/configuration/web.config\u003c/span\u003e\n--\u003e\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003econfiguration\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003esystem.webServer\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- WebSocket 지원에 대한 자세한 정보는 http://blogs.msdn.com/b/windowsazure/archive/2013/11/14/introduction-to-websockets-on-windows-azure-web-sites.aspx에서 확인할 수 있습니다 --\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ewebSocket\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eenabled\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"false\"\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehandlers\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- server.js 파일이 iisnode 모듈에 의해 처리되는 node.js 사이트임을 나타냄 --\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eadd\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"iisnode\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"server.js\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003everb\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"*\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emodules\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"iisnode\"\u003c/span\u003e/\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehandlers\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003erewrite\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003erules\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- node-inspector 디버깅을 위한 요청 방해하지 않음 --\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003erule\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"NodeInspector\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epatternSyntax\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ECMAScript\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estopProcessing\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"true\"\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ematch\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eurl\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"^server.js\\/debug[\\/]?\"\u003c/span\u003e /\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003erule\u003c/span\u003e\u003e\u003c/span\u003e\n\n        \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- 먼저 /public 폴더의 물리적 파일과 일치하는 들어오는 URL을 고려 --\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003erule\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"StaticContent\"\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eaction\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Rewrite\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eurl\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"public{REQUEST_URI}\"\u003c/span\u003e/\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003erule\u003c/span\u003e\u003e\u003c/span\u003e\n\n        \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- 모든 다른 URL은 node.js 사이트 진입점으로 매핑됨 --\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003erule\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"DynamicContent\"\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003econditions\u003c/span\u003e\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eadd\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003einput\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"{REQUEST_FILENAME}\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ematchType\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"IsFile\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enegate\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"True\"\u003c/span\u003e/\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003econditions\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eaction\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Rewrite\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eurl\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"server.js\"\u003c/span\u003e/\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003erule\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003erules\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003erewrite\u003c/span\u003e\u003e\u003c/span\u003e\n    \n    \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- 'bin' 디렉토리는 node.js에서 특별한 의미가 없으며, 앱을 그 안에 배치할 수 있음 --\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003esecurity\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003erequestFiltering\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehiddenSegments\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eadd\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esegment\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"node_modules\"\u003c/span\u003e/\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehiddenSegments\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003erequestFiltering\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003esecurity\u003c/span\u003e\u003e\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- 오류 응답을 변경하지 않도록 함 --\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehttpErrors\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eexistingResponse\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"PassThrough\"\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eiisnode\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enode_env\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"production\"\u003c/span\u003e/\u003e\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!--\n      다음 옵션을 사용하여 IIS 내에서 Node를 호스트하는 방법을 제어할 수 있습니다:\n        * watchedFiles: 변경 사항을 감지하여 서버를 다시 시작할 파일 목록\n        * node_env: NODE_ENV 환경 변수로 전달될 값\n        * debuggingEnabled - 기본 디버거가 활성화되는지 여부\n\n      모든 옵션 목록은 https://github.com/tjanczuk/iisnode/blob/master/src/samples/configuration/web.config에서 확인 가능합니다\n    --\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!--\u0026#x3C;iisnode watchedFiles=\"web.config;*.js\"/\u003e--\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003esystem.webServer\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003econfiguration\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e웹 구성 파일을 추가한 후에는 package.json을 약간 변경해야 합니다. npm run start가 서버를 시작하도록 설정되어야 하며 next start를 사용하지 않아야 합니다. 다음은 package.json 스크립트가 보이는 방식입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  \u003cspan class=\"hljs-string\"\u003e\"scripts\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"dev\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"node server.js\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"build\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"next build\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"start\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"node server.js\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"lint\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"next lint\"\u003c/span\u003e\n  },\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eserver.js를 추가하고 web.config를 추가한 후 npm run build를 실행하면 애플리케이션의 루트 폴더가 다음과 같이 보입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-DeployingNextJsApplicationonWindowsIISServer_1.png\" alt=\"애플리케이션 루트 폴더\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eIIS에서 NextJS 애플리케이션을 배포하는 방법\u003c/h1\u003e\n\u003cp\u003e배포를 설정하기 전에 IISNode와 URLRewrite를 설치해야 합니다. 그 후, IIS에 새 웹 사이트를 생성하고 물리적 경로를 .next, node_modules, server.js 및 web.config가 포함된 폴더로 지정하세요. 권한 문제나 다른 가능한 문제를 피하려면 해당 폴더를 Windows Server의 루트 사용자 폴더 안에 배치하세요.\u003c/p\u003e\n\u003cp\u003eIIS에서 웹 서버를 시작하면 자동으로 iisnode이라는 새 폴더가 생성됩니다.\u003c/p\u003e\n\u003cp\u003e만약 배포 폴더가 C:/ 드라이브의 wwwroot에 있다면 전체 폴더에 대해 IIS_Users에게 읽기/쓰기 권한을 명시적으로 부여해야 할 수 있습니다. 다른 예상치 못한 오류가 발생하는 경우, 댓글을 남기거나 내 Discord @pallepadehat을 추가해주세요. 도와드릴게요!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 Github Repo에서 소스 코드를 확인할 수 있어요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-DeployingNextJsApplicationonWindowsIISServer"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>