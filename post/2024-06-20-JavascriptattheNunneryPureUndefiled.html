<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>자바스크립트 공부 순수하고 불량한 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-JavascriptattheNunneryPureUndefiled" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="자바스크립트 공부 순수하고 불량한 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="자바스크립트 공부 순수하고 불량한 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-JavascriptattheNunneryPureUndefiled" data-gatsby-head="true"/><meta name="twitter:title" content="자바스크립트 공부 순수하고 불량한 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 02:44" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">자바스크립트 공부 순수하고 불량한</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="자바스크립트 공부 순수하고 불량한" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-JavascriptattheNunneryPureUndefiled&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>가장 좋은 자바스크립트는 간단하고 깔끔하며 클래스, this, 상속 및 데코레이터와 같은 추종할만한 기능으로 오염되지 않았어야 한다.</p>
<p><img src="/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png" alt="이미지"></p>
<h2>TLDR;</h2>
<p>자바스크립트는 다양한 언어 기능을 갖춘 매우 강력한 프로그래밍 언어입니다. 그러나 대부분은 완전한 쓰레기입니다. 지난 10년 동안 엔지니어들이 품질 좋은 코드를 작성하는 능력을 저해하는 데 그 기능들은 소용이 없었습니다. 저는 객체와 함수만 사용하는 것이 훨씬 좋습니다.</p>
<div class="content-ad"></div>
<h1>JavaScript의 문제</h1>
<p>JavaScript는 놀라운 언어입니다. JavaScript의 가장 놀라운 점은 그 창시 이후 얼마나 멀리 왔는지입니다. 대부분의 언어는 창조, 구식화, 소멸이라는 자연스러운 과정을 따릅니다. 하지만 약한 프로그래밍 언어는 필요한 것을 갖추지 못하면 새로운 언어에 밀려나며 결국 소멸합니다.</p>
<p>JavaScript는 그 규칙의 예외입니다.</p>
<p>JavaScript가 약했더라도 웹을 구동하는 기술로서 죽어서는 안되었습니다. 대신 새로운 기능들이 외부로 테이핑, 접착, 그리고 끈과 와이어로 결합되어 추가되었습니다.</p>
<div class="content-ad"></div>
<p>우리가 오늘 알고 있는, 싫어하는, 그리고 사랑하는 JavaScript는 처음부터 의심스러운 핵심 엔진에 계층 지어 쌓인 기능들의 집합이에요.</p>
<h1>커뮤니티의 문제</h1>
<p>진짜 문제는 JavaScript가 아니라, 엔지니어들이 JavaScript에 대해 어떻게 생각하는지에요. 모든 언어 기능이 특별하고 유용하며 적절한 시간과 장소가 있어서 가능한 경우 모든 기능을 배워서 사용해야 한다고 배우게 되죠.</p>
<p>거짓말이에요.</p>
<div class="content-ad"></div>
<p>프로토타입 상속을 예로 들어보죠. 좀 이상하고, 좀 추잡하며, 현대 프로그래밍 언어에는 어울리지 않는 개념이죠. 언어에 그 개념이 존재한다고 해서 우리가 받아들여야 하는 것은 아니라고 생각해요.</p>
<h1>해결책</h1>
<p>저는 모든 저 추잡한 특징들을 거부해요. 간단히 거절합니다. 특히 클래스, this 키워드, 데코레이터 및 상속 형태의 어떤 형태에도 의존하지 않아요. 제 JavaScript 코드는 모두 객체와 함수로 이루어져 있어요.</p>
<h2>클래스를 사용하지 않아요</h2>
<div class="content-ad"></div>
<p>클래스는 상태가 초기화된 객체일 뿐입니다. 정말, 그게 전부에요!</p>
<p>다음 두 코드 조각은 정신적으로 동일합니다. 유일한 차이점은 클래스 파서는 new 키워드를 요구하는데 반해 const 파서는 그렇지 않습니다.</p>
<p><img src="/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_1.png" alt="image"></p>
<p>그렇다면 왜 클래스를 사용해야 할까요? 상속에 대해 생각 중이라면 다음 코드 조각을 고려해보세요.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_2.png" alt="이미지"></p>
<p>클래스로 할 수 있는 것은 모두 객체와 함수로도 할 수 있어요. 그리 어렵지 않아요.</p>
<h2>데코레이터는 사용하지 않아요</h2>
<p>사실 데코레이터 아이디어를 좋아해요. 안타깝게도 자바스크립트 위원회가 금기 주류에 취해 있었던 그 날 밤, 형식을 결정해버렸어요.</p>
<div class="content-ad"></div>
<p>이를 수행하기 위해 자바스크립트가 만든 형식을 배워야 합니다. 저는 파이썬 접근 방식을 선호합니다. 파이썬에서 데코레이터는 함수를 인수로 받아들이고 함수를 반환하는 함수입니다.</p>
<p>이것이 어떻게 동작하는지 자바스크립트에서 보여 드리겠습니다:</p>
<p><img src="/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_3.png" alt="이미지"></p>
<p>이 예제에서는 <code>speak</code> 함수를 우리의 <code>uppercase</code> 및 <code>emphasize</code> 데코레이터로 장식하여 <code>scream</code> 함수를 만들었습니다. 실제로 우리는 데코레이팅하는 것이 아니라 조합하고 있습니다. 그것은 버그가 아니라 기능입니다. 어쨌든, 우리는 동일한 꾸미기 목표를 달성하고 있습니다.</p>
<div class="content-ad"></div>
<h1>그런데 왜요?</h1>
<p>내 코드를 객체와 함수에만 제한하는 이유가 몇 가지 있습니다. 일반적으로 이야기하자면, 이렇게 하면 코드를 간단하고 읽기 쉽고 빠르며, 전반적으로 더 나아지게 할 수 있습니다. 나는 더 좋아합니다.</p>
<h2>클래스는 상태를 쌓는 경향이 있습니다</h2>
<p>이것은 절대적인 규칙은 아니지만, 제 경력 동안 본 경향입니다. 개인적으로, 결정론적인 코드와 가능한 한 순수한 함수를 강력히 선호합니다. 당신이 단호하다면 클래스로도 이러한 것들을 달성할 수 있습니다. 그러나 항상 그대로인 것 같지는 않습니다. 제가 단호해도, 다음 10 명의 엔지니어들은 같은 생각을 공유할 가능성이 낮습니다.</p>
<div class="content-ad"></div>
<p>시간이 지남에 따라 클래스는 더 많은 속성을 저장하고 해당 속성에 의존하는 더 많은 함수를 추가하는 경향이 있습니다. 클래스가 정말 통제를 벗어날 때, 어느 시점에 적절한 속성 값은 메소드의 올바른 기능에 중요해집니다. 즉, 상태의 악몽입니다.</p>
<p><img src="/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_4.png" alt="이미지"></p>
<p>객체를 사용하면 모듈 스코프에서 결정적인 함수를 작성하고 필요한 것만 전달해서 객체 인스턴스에서 호출할 수 있습니다. 이를 통해 함수에 수동으로 상태를 전달하게 되는데, 이를 통해 엔지니어들이 무엇을 추가하는지 두 번 생각하도록 유도합니다.</p>
<p>이를 클래스로 수행할 수 있지만, 30년 이상의 전통이 있어 이 방식으로 작업하지 않는 것이 좋습니다. 다른 사람들이 당신의 코드를 분석하고 클래스를 찾게 되면, 그들은 깊게 생각하지 않고 상태를 더 늘리게 될 것입니다.</p>
<div class="content-ad"></div>
<h2>클래스 테스트하기 어렵습니다</h2>
<p>이 포인트는 이전 내용과 밀접하게 관련되어 있습니다. 클래스가 가지고 있는 상태(state)가 많을수록 그것을 테스트하기가 어려워집니다. 클래스에서 상태를 제거하여 불변 객체(immutable object)로 만들고, 복잡한 함수를 모듈 스코프에 배치하여 독립적으로 테스트할 수 있도록 한다면, 테스트의 복잡성을 크게 줄일 수 있습니다.</p>
<p>저는 유닛 테스트에 코드 커버리지를 중요하게 생각합니다. 아픈 경험을 토대로 말씀드리지만 상태를 가지는 클래스의 코드 커버리지는 아무런 의미가 없다고 말할 수 있습니다. 반면, 만일 클래스가 불변 객체 인스턴스이고 모듈 스코프에 결정적 함수(deterministic functions)가 있으며, 결정적 함수들이 100%의 유닛 테스트로 커버된 경우에는, 실제로 로직이 커버된 것에 자신감을 가질 수 있습니다.</p>
<img src="/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_5.png">
<div class="content-ad"></div>
<p>우리의 오토바이 수업은 약간 특이해요 — 빨간 오토바이가 가장 빠르다는 건 누구나 알고 있죠 — 하지만 이것은 국가가 결과를 파생해내는 실제 시나리오를 보여줘요.</p>
<p>테스트를 작성할 때, 물건의 색상과 같이 보이게는 상관없는 것이 속도에 영향을 미칠 수 있다는 것이 명백하지 않을 수 있어요.</p>
<p>함수 및 객체 버전에서, getSpeed 함수를 위한 테스트를 작성하면 개발자에게 색상 — 필수 인수 — 가 결과에 영향을 미친다는 것을 알려줄 거에요.</p>
<div class="content-ad"></div>
<h2>객체는 인지 부담을 줄입니다</h2>
<p>사람으로서 클래스 메서드를 이해하기 위해서는 모든 상태를 내 머리로 불러와야 하고 그 후 이에 의존하는 상태를 고려하여 런타임 동작을 고려해야 합니다. 개발자로서 우리는 주로 이 의존 상태를 식별하기 위해 클래스 메서드를 검사하여 this나 self와 같은 키워드를 찾게 됩니다.</p>
<p>결정론적 함수는 인자를 통해 의존성을 정의합니다. 이러한 경향은 이해하기 쉽고 추론하기 쉽게 만듭니다.</p>
<h2>데코레이터는 영원히 함수에 데코레이터를 바인딩합니다</h2>
<div class="content-ad"></div>
<p>JavaScript에서 @decorator 기능을 사용할 때는 데코레이터 함수를 영원히 데코레이트된 함수에 바인딩하는 것입니다. 이것은 함수를 격리해서 테스트하는 능력을 완전히 파괴합니다.</p>
<p>speak/scream 데코레이터 예제의 버전을 살펴봅시다. 이 예제는 @decorator 기능을 사용하도록 변환되었습니다.</p>
<p><img src="/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_7.png" alt="이미지"></p>
<p>나는 데코레이터를 실행하지 않고는 speak 메서드를 테스트할 수 없습니다. 품질 높은 단위 테스트를 중요시하는 사람으로서, 이는 시작조차 할 수 없는 상황입니다.</p>
<div class="content-ad"></div>
<h2>장식자는 난해한 형식에 대한 지식이 필요합니다</h2>
<p>다음 코드 스니펫을 살펴보고, 저희 강조 장식자에 관해 알려주세요: 타겟이 무엇인가요? 이름은 무엇인가요? 그리고 디스크립터는 무엇인가요?</p>
<img src="/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_8.png">
<p>장식자의 정의는 간단하고 아름다운데...함수를 취하고 함수를 반환하는 함수입니다. 자바스크립트는 복잡한 형식으로 실로 우아한 패턴을 와해시켰습니다.</p>
<div class="content-ad"></div>
<h2>데코레이터들은 이를 필요로 합니다</h2>
<p>우리 두 데코레이터에서 보듯이, apply와 this를 사용하여 데코레이트된 메소드의 컨텍스트를 올바르게 설정해야 합니다.</p>
<p>저랑 함께 마음을 열고 잠시 얘기해볼까요?... 20년 전 실수였고 오늘날에도 그래요. 하느님아, 자바스크립트에 이것을 중심으로 언어 기능을 만들지 말아 주시고 엔지니어분들아, 코딩에서 이를 중심으로 코드를 작성하지 말아 주세요.</p>
<p>그리고 다른 얘기인데, 만약 면접을 볼 때 this 키워드에 대해 물어보면, 올바른 대답은 "잘 모르겠어요, 이 구식 쓰레기를 사용하지 않아요. 이것은 코드를 불필요하게 복잡하게 만들 뿐이에요" 입니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"자바스크립트 공부 순수하고 불량한","description":"","date":"2024-06-20 02:44","slug":"2024-06-20-JavascriptattheNunneryPureUndefiled","content":"\n\n가장 좋은 자바스크립트는 간단하고 깔끔하며 클래스, this, 상속 및 데코레이터와 같은 추종할만한 기능으로 오염되지 않았어야 한다.\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png)\n\n## TLDR;\n\n자바스크립트는 다양한 언어 기능을 갖춘 매우 강력한 프로그래밍 언어입니다. 그러나 대부분은 완전한 쓰레기입니다. 지난 10년 동안 엔지니어들이 품질 좋은 코드를 작성하는 능력을 저해하는 데 그 기능들은 소용이 없었습니다. 저는 객체와 함수만 사용하는 것이 훨씬 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# JavaScript의 문제\n\nJavaScript는 놀라운 언어입니다. JavaScript의 가장 놀라운 점은 그 창시 이후 얼마나 멀리 왔는지입니다. 대부분의 언어는 창조, 구식화, 소멸이라는 자연스러운 과정을 따릅니다. 하지만 약한 프로그래밍 언어는 필요한 것을 갖추지 못하면 새로운 언어에 밀려나며 결국 소멸합니다.\n\nJavaScript는 그 규칙의 예외입니다.\n\nJavaScript가 약했더라도 웹을 구동하는 기술로서 죽어서는 안되었습니다. 대신 새로운 기능들이 외부로 테이핑, 접착, 그리고 끈과 와이어로 결합되어 추가되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 오늘 알고 있는, 싫어하는, 그리고 사랑하는 JavaScript는 처음부터 의심스러운 핵심 엔진에 계층 지어 쌓인 기능들의 집합이에요.\n\n# 커뮤니티의 문제\n\n진짜 문제는 JavaScript가 아니라, 엔지니어들이 JavaScript에 대해 어떻게 생각하는지에요. 모든 언어 기능이 특별하고 유용하며 적절한 시간과 장소가 있어서 가능한 경우 모든 기능을 배워서 사용해야 한다고 배우게 되죠.\n\n거짓말이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로토타입 상속을 예로 들어보죠. 좀 이상하고, 좀 추잡하며, 현대 프로그래밍 언어에는 어울리지 않는 개념이죠. 언어에 그 개념이 존재한다고 해서 우리가 받아들여야 하는 것은 아니라고 생각해요.\n\n# 해결책\n\n저는 모든 저 추잡한 특징들을 거부해요. 간단히 거절합니다. 특히 클래스, this 키워드, 데코레이터 및 상속 형태의 어떤 형태에도 의존하지 않아요. 제 JavaScript 코드는 모두 객체와 함수로 이루어져 있어요.\n\n## 클래스를 사용하지 않아요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클래스는 상태가 초기화된 객체일 뿐입니다. 정말, 그게 전부에요!\n\n다음 두 코드 조각은 정신적으로 동일합니다. 유일한 차이점은 클래스 파서는 new 키워드를 요구하는데 반해 const 파서는 그렇지 않습니다.\n\n![image](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_1.png)\n\n그렇다면 왜 클래스를 사용해야 할까요? 상속에 대해 생각 중이라면 다음 코드 조각을 고려해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_2.png)\n\n클래스로 할 수 있는 것은 모두 객체와 함수로도 할 수 있어요. 그리 어렵지 않아요.\n\n## 데코레이터는 사용하지 않아요\n\n사실 데코레이터 아이디어를 좋아해요. 안타깝게도 자바스크립트 위원회가 금기 주류에 취해 있었던 그 날 밤, 형식을 결정해버렸어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이를 수행하기 위해 자바스크립트가 만든 형식을 배워야 합니다. 저는 파이썬 접근 방식을 선호합니다. 파이썬에서 데코레이터는 함수를 인수로 받아들이고 함수를 반환하는 함수입니다.\n\n이것이 어떻게 동작하는지 자바스크립트에서 보여 드리겠습니다:\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_3.png)\n\n이 예제에서는 `speak` 함수를 우리의 `uppercase` 및 `emphasize` 데코레이터로 장식하여 `scream` 함수를 만들었습니다. 실제로 우리는 데코레이팅하는 것이 아니라 조합하고 있습니다. 그것은 버그가 아니라 기능입니다. 어쨌든, 우리는 동일한 꾸미기 목표를 달성하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 그런데 왜요?\n\n내 코드를 객체와 함수에만 제한하는 이유가 몇 가지 있습니다. 일반적으로 이야기하자면, 이렇게 하면 코드를 간단하고 읽기 쉽고 빠르며, 전반적으로 더 나아지게 할 수 있습니다. 나는 더 좋아합니다.\n\n## 클래스는 상태를 쌓는 경향이 있습니다\n\n이것은 절대적인 규칙은 아니지만, 제 경력 동안 본 경향입니다. 개인적으로, 결정론적인 코드와 가능한 한 순수한 함수를 강력히 선호합니다. 당신이 단호하다면 클래스로도 이러한 것들을 달성할 수 있습니다. 그러나 항상 그대로인 것 같지는 않습니다. 제가 단호해도, 다음 10 명의 엔지니어들은 같은 생각을 공유할 가능성이 낮습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시간이 지남에 따라 클래스는 더 많은 속성을 저장하고 해당 속성에 의존하는 더 많은 함수를 추가하는 경향이 있습니다. 클래스가 정말 통제를 벗어날 때, 어느 시점에 적절한 속성 값은 메소드의 올바른 기능에 중요해집니다. 즉, 상태의 악몽입니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_4.png)\n\n객체를 사용하면 모듈 스코프에서 결정적인 함수를 작성하고 필요한 것만 전달해서 객체 인스턴스에서 호출할 수 있습니다. 이를 통해 함수에 수동으로 상태를 전달하게 되는데, 이를 통해 엔지니어들이 무엇을 추가하는지 두 번 생각하도록 유도합니다.\n\n이를 클래스로 수행할 수 있지만, 30년 이상의 전통이 있어 이 방식으로 작업하지 않는 것이 좋습니다. 다른 사람들이 당신의 코드를 분석하고 클래스를 찾게 되면, 그들은 깊게 생각하지 않고 상태를 더 늘리게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 클래스 테스트하기 어렵습니다\n\n이 포인트는 이전 내용과 밀접하게 관련되어 있습니다. 클래스가 가지고 있는 상태(state)가 많을수록 그것을 테스트하기가 어려워집니다. 클래스에서 상태를 제거하여 불변 객체(immutable object)로 만들고, 복잡한 함수를 모듈 스코프에 배치하여 독립적으로 테스트할 수 있도록 한다면, 테스트의 복잡성을 크게 줄일 수 있습니다.\n\n저는 유닛 테스트에 코드 커버리지를 중요하게 생각합니다. 아픈 경험을 토대로 말씀드리지만 상태를 가지는 클래스의 코드 커버리지는 아무런 의미가 없다고 말할 수 있습니다. 반면, 만일 클래스가 불변 객체 인스턴스이고 모듈 스코프에 결정적 함수(deterministic functions)가 있으며, 결정적 함수들이 100%의 유닛 테스트로 커버된 경우에는, 실제로 로직이 커버된 것에 자신감을 가질 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_5.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 오토바이 수업은 약간 특이해요 — 빨간 오토바이가 가장 빠르다는 건 누구나 알고 있죠 — 하지만 이것은 국가가 결과를 파생해내는 실제 시나리오를 보여줘요.\n\n테스트를 작성할 때, 물건의 색상과 같이 보이게는 상관없는 것이 속도에 영향을 미칠 수 있다는 것이 명백하지 않을 수 있어요.\n\n함수 및 객체 버전에서, getSpeed 함수를 위한 테스트를 작성하면 개발자에게 색상 — 필수 인수 — 가 결과에 영향을 미친다는 것을 알려줄 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 객체는 인지 부담을 줄입니다\n\n사람으로서 클래스 메서드를 이해하기 위해서는 모든 상태를 내 머리로 불러와야 하고 그 후 이에 의존하는 상태를 고려하여 런타임 동작을 고려해야 합니다. 개발자로서 우리는 주로 이 의존 상태를 식별하기 위해 클래스 메서드를 검사하여 this나 self와 같은 키워드를 찾게 됩니다.\n\n결정론적 함수는 인자를 통해 의존성을 정의합니다. 이러한 경향은 이해하기 쉽고 추론하기 쉽게 만듭니다.\n\n## 데코레이터는 영원히 함수에 데코레이터를 바인딩합니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript에서 @decorator 기능을 사용할 때는 데코레이터 함수를 영원히 데코레이트된 함수에 바인딩하는 것입니다. 이것은 함수를 격리해서 테스트하는 능력을 완전히 파괴합니다.\n\nspeak/scream 데코레이터 예제의 버전을 살펴봅시다. 이 예제는 @decorator 기능을 사용하도록 변환되었습니다.\n\n![이미지](/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_7.png)\n\n나는 데코레이터를 실행하지 않고는 speak 메서드를 테스트할 수 없습니다. 품질 높은 단위 테스트를 중요시하는 사람으로서, 이는 시작조차 할 수 없는 상황입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 장식자는 난해한 형식에 대한 지식이 필요합니다\n\n다음 코드 스니펫을 살펴보고, 저희 강조 장식자에 관해 알려주세요: 타겟이 무엇인가요? 이름은 무엇인가요? 그리고 디스크립터는 무엇인가요?\n\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_8.png\" /\u003e\n\n장식자의 정의는 간단하고 아름다운데...함수를 취하고 함수를 반환하는 함수입니다. 자바스크립트는 복잡한 형식으로 실로 우아한 패턴을 와해시켰습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 데코레이터들은 이를 필요로 합니다\n\n우리 두 데코레이터에서 보듯이, apply와 this를 사용하여 데코레이트된 메소드의 컨텍스트를 올바르게 설정해야 합니다.\n\n저랑 함께 마음을 열고 잠시 얘기해볼까요?... 20년 전 실수였고 오늘날에도 그래요. 하느님아, 자바스크립트에 이것을 중심으로 언어 기능을 만들지 말아 주시고 엔지니어분들아, 코딩에서 이를 중심으로 코드를 작성하지 말아 주세요.\n\n그리고 다른 얘기인데, 만약 면접을 볼 때 this 키워드에 대해 물어보면, 올바른 대답은 \"잘 모르겠어요, 이 구식 쓰레기를 사용하지 않아요. 이것은 코드를 불필요하게 복잡하게 만들 뿐이에요\" 입니다.","ogImage":{"url":"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png"},"coverImage":"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e가장 좋은 자바스크립트는 간단하고 깔끔하며 클래스, this, 상속 및 데코레이터와 같은 추종할만한 기능으로 오염되지 않았어야 한다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003eTLDR;\u003c/h2\u003e\n\u003cp\u003e자바스크립트는 다양한 언어 기능을 갖춘 매우 강력한 프로그래밍 언어입니다. 그러나 대부분은 완전한 쓰레기입니다. 지난 10년 동안 엔지니어들이 품질 좋은 코드를 작성하는 능력을 저해하는 데 그 기능들은 소용이 없었습니다. 저는 객체와 함수만 사용하는 것이 훨씬 좋습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eJavaScript의 문제\u003c/h1\u003e\n\u003cp\u003eJavaScript는 놀라운 언어입니다. JavaScript의 가장 놀라운 점은 그 창시 이후 얼마나 멀리 왔는지입니다. 대부분의 언어는 창조, 구식화, 소멸이라는 자연스러운 과정을 따릅니다. 하지만 약한 프로그래밍 언어는 필요한 것을 갖추지 못하면 새로운 언어에 밀려나며 결국 소멸합니다.\u003c/p\u003e\n\u003cp\u003eJavaScript는 그 규칙의 예외입니다.\u003c/p\u003e\n\u003cp\u003eJavaScript가 약했더라도 웹을 구동하는 기술로서 죽어서는 안되었습니다. 대신 새로운 기능들이 외부로 테이핑, 접착, 그리고 끈과 와이어로 결합되어 추가되었습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리가 오늘 알고 있는, 싫어하는, 그리고 사랑하는 JavaScript는 처음부터 의심스러운 핵심 엔진에 계층 지어 쌓인 기능들의 집합이에요.\u003c/p\u003e\n\u003ch1\u003e커뮤니티의 문제\u003c/h1\u003e\n\u003cp\u003e진짜 문제는 JavaScript가 아니라, 엔지니어들이 JavaScript에 대해 어떻게 생각하는지에요. 모든 언어 기능이 특별하고 유용하며 적절한 시간과 장소가 있어서 가능한 경우 모든 기능을 배워서 사용해야 한다고 배우게 되죠.\u003c/p\u003e\n\u003cp\u003e거짓말이에요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e프로토타입 상속을 예로 들어보죠. 좀 이상하고, 좀 추잡하며, 현대 프로그래밍 언어에는 어울리지 않는 개념이죠. 언어에 그 개념이 존재한다고 해서 우리가 받아들여야 하는 것은 아니라고 생각해요.\u003c/p\u003e\n\u003ch1\u003e해결책\u003c/h1\u003e\n\u003cp\u003e저는 모든 저 추잡한 특징들을 거부해요. 간단히 거절합니다. 특히 클래스, this 키워드, 데코레이터 및 상속 형태의 어떤 형태에도 의존하지 않아요. 제 JavaScript 코드는 모두 객체와 함수로 이루어져 있어요.\u003c/p\u003e\n\u003ch2\u003e클래스를 사용하지 않아요\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e클래스는 상태가 초기화된 객체일 뿐입니다. 정말, 그게 전부에요!\u003c/p\u003e\n\u003cp\u003e다음 두 코드 조각은 정신적으로 동일합니다. 유일한 차이점은 클래스 파서는 new 키워드를 요구하는데 반해 const 파서는 그렇지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e그렇다면 왜 클래스를 사용해야 할까요? 상속에 대해 생각 중이라면 다음 코드 조각을 고려해보세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e클래스로 할 수 있는 것은 모두 객체와 함수로도 할 수 있어요. 그리 어렵지 않아요.\u003c/p\u003e\n\u003ch2\u003e데코레이터는 사용하지 않아요\u003c/h2\u003e\n\u003cp\u003e사실 데코레이터 아이디어를 좋아해요. 안타깝게도 자바스크립트 위원회가 금기 주류에 취해 있었던 그 날 밤, 형식을 결정해버렸어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이를 수행하기 위해 자바스크립트가 만든 형식을 배워야 합니다. 저는 파이썬 접근 방식을 선호합니다. 파이썬에서 데코레이터는 함수를 인수로 받아들이고 함수를 반환하는 함수입니다.\u003c/p\u003e\n\u003cp\u003e이것이 어떻게 동작하는지 자바스크립트에서 보여 드리겠습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 예제에서는 \u003ccode\u003espeak\u003c/code\u003e 함수를 우리의 \u003ccode\u003euppercase\u003c/code\u003e 및 \u003ccode\u003eemphasize\u003c/code\u003e 데코레이터로 장식하여 \u003ccode\u003escream\u003c/code\u003e 함수를 만들었습니다. 실제로 우리는 데코레이팅하는 것이 아니라 조합하고 있습니다. 그것은 버그가 아니라 기능입니다. 어쨌든, 우리는 동일한 꾸미기 목표를 달성하고 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e그런데 왜요?\u003c/h1\u003e\n\u003cp\u003e내 코드를 객체와 함수에만 제한하는 이유가 몇 가지 있습니다. 일반적으로 이야기하자면, 이렇게 하면 코드를 간단하고 읽기 쉽고 빠르며, 전반적으로 더 나아지게 할 수 있습니다. 나는 더 좋아합니다.\u003c/p\u003e\n\u003ch2\u003e클래스는 상태를 쌓는 경향이 있습니다\u003c/h2\u003e\n\u003cp\u003e이것은 절대적인 규칙은 아니지만, 제 경력 동안 본 경향입니다. 개인적으로, 결정론적인 코드와 가능한 한 순수한 함수를 강력히 선호합니다. 당신이 단호하다면 클래스로도 이러한 것들을 달성할 수 있습니다. 그러나 항상 그대로인 것 같지는 않습니다. 제가 단호해도, 다음 10 명의 엔지니어들은 같은 생각을 공유할 가능성이 낮습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e시간이 지남에 따라 클래스는 더 많은 속성을 저장하고 해당 속성에 의존하는 더 많은 함수를 추가하는 경향이 있습니다. 클래스가 정말 통제를 벗어날 때, 어느 시점에 적절한 속성 값은 메소드의 올바른 기능에 중요해집니다. 즉, 상태의 악몽입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e객체를 사용하면 모듈 스코프에서 결정적인 함수를 작성하고 필요한 것만 전달해서 객체 인스턴스에서 호출할 수 있습니다. 이를 통해 함수에 수동으로 상태를 전달하게 되는데, 이를 통해 엔지니어들이 무엇을 추가하는지 두 번 생각하도록 유도합니다.\u003c/p\u003e\n\u003cp\u003e이를 클래스로 수행할 수 있지만, 30년 이상의 전통이 있어 이 방식으로 작업하지 않는 것이 좋습니다. 다른 사람들이 당신의 코드를 분석하고 클래스를 찾게 되면, 그들은 깊게 생각하지 않고 상태를 더 늘리게 될 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e클래스 테스트하기 어렵습니다\u003c/h2\u003e\n\u003cp\u003e이 포인트는 이전 내용과 밀접하게 관련되어 있습니다. 클래스가 가지고 있는 상태(state)가 많을수록 그것을 테스트하기가 어려워집니다. 클래스에서 상태를 제거하여 불변 객체(immutable object)로 만들고, 복잡한 함수를 모듈 스코프에 배치하여 독립적으로 테스트할 수 있도록 한다면, 테스트의 복잡성을 크게 줄일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e저는 유닛 테스트에 코드 커버리지를 중요하게 생각합니다. 아픈 경험을 토대로 말씀드리지만 상태를 가지는 클래스의 코드 커버리지는 아무런 의미가 없다고 말할 수 있습니다. 반면, 만일 클래스가 불변 객체 인스턴스이고 모듈 스코프에 결정적 함수(deterministic functions)가 있으며, 결정적 함수들이 100%의 유닛 테스트로 커버된 경우에는, 실제로 로직이 커버된 것에 자신감을 가질 수 있습니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_5.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리의 오토바이 수업은 약간 특이해요 — 빨간 오토바이가 가장 빠르다는 건 누구나 알고 있죠 — 하지만 이것은 국가가 결과를 파생해내는 실제 시나리오를 보여줘요.\u003c/p\u003e\n\u003cp\u003e테스트를 작성할 때, 물건의 색상과 같이 보이게는 상관없는 것이 속도에 영향을 미칠 수 있다는 것이 명백하지 않을 수 있어요.\u003c/p\u003e\n\u003cp\u003e함수 및 객체 버전에서, getSpeed 함수를 위한 테스트를 작성하면 개발자에게 색상 — 필수 인수 — 가 결과에 영향을 미친다는 것을 알려줄 거에요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e객체는 인지 부담을 줄입니다\u003c/h2\u003e\n\u003cp\u003e사람으로서 클래스 메서드를 이해하기 위해서는 모든 상태를 내 머리로 불러와야 하고 그 후 이에 의존하는 상태를 고려하여 런타임 동작을 고려해야 합니다. 개발자로서 우리는 주로 이 의존 상태를 식별하기 위해 클래스 메서드를 검사하여 this나 self와 같은 키워드를 찾게 됩니다.\u003c/p\u003e\n\u003cp\u003e결정론적 함수는 인자를 통해 의존성을 정의합니다. 이러한 경향은 이해하기 쉽고 추론하기 쉽게 만듭니다.\u003c/p\u003e\n\u003ch2\u003e데코레이터는 영원히 함수에 데코레이터를 바인딩합니다\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eJavaScript에서 @decorator 기능을 사용할 때는 데코레이터 함수를 영원히 데코레이트된 함수에 바인딩하는 것입니다. 이것은 함수를 격리해서 테스트하는 능력을 완전히 파괴합니다.\u003c/p\u003e\n\u003cp\u003espeak/scream 데코레이터 예제의 버전을 살펴봅시다. 이 예제는 @decorator 기능을 사용하도록 변환되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e나는 데코레이터를 실행하지 않고는 speak 메서드를 테스트할 수 없습니다. 품질 높은 단위 테스트를 중요시하는 사람으로서, 이는 시작조차 할 수 없는 상황입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e장식자는 난해한 형식에 대한 지식이 필요합니다\u003c/h2\u003e\n\u003cp\u003e다음 코드 스니펫을 살펴보고, 저희 강조 장식자에 관해 알려주세요: 타겟이 무엇인가요? 이름은 무엇인가요? 그리고 디스크립터는 무엇인가요?\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-20-JavascriptattheNunneryPureUndefiled_8.png\"\u003e\n\u003cp\u003e장식자의 정의는 간단하고 아름다운데...함수를 취하고 함수를 반환하는 함수입니다. 자바스크립트는 복잡한 형식으로 실로 우아한 패턴을 와해시켰습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e데코레이터들은 이를 필요로 합니다\u003c/h2\u003e\n\u003cp\u003e우리 두 데코레이터에서 보듯이, apply와 this를 사용하여 데코레이트된 메소드의 컨텍스트를 올바르게 설정해야 합니다.\u003c/p\u003e\n\u003cp\u003e저랑 함께 마음을 열고 잠시 얘기해볼까요?... 20년 전 실수였고 오늘날에도 그래요. 하느님아, 자바스크립트에 이것을 중심으로 언어 기능을 만들지 말아 주시고 엔지니어분들아, 코딩에서 이를 중심으로 코드를 작성하지 말아 주세요.\u003c/p\u003e\n\u003cp\u003e그리고 다른 얘기인데, 만약 면접을 볼 때 this 키워드에 대해 물어보면, 올바른 대답은 \"잘 모르겠어요, 이 구식 쓰레기를 사용하지 않아요. 이것은 코드를 불필요하게 복잡하게 만들 뿐이에요\" 입니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-JavascriptattheNunneryPureUndefiled"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>