<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트 네이티브에서 Redux를 이용한 테마 설정 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-ThemingWithReduxinReactNative" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트 네이티브에서 Redux를 이용한 테마 설정 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트 네이티브에서 Redux를 이용한 테마 설정 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-ThemingWithReduxinReactNative" data-gatsby-head="true"/><meta name="twitter:title" content="리액트 네이티브에서 Redux를 이용한 테마 설정 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 00:06" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트 네이티브에서 Redux를 이용한 테마 설정</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트 네이티브에서 Redux를 이용한 테마 설정" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">14<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-ThemingWithReduxinReactNative&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png" alt="image"></p>
<p>왜 Theming을 할까요?</p>
<p>Theming은 현대 앱의 주요 부분이 되어, 사용자 맞춤화 기능을 더욱 향상시킬 수 있게 해줍니다. 테마는 다양한 속성을 포함한 스타일을 설정하여, 다양한 사용자에게 다양한 방식으로 읽히게 합니다. 특히 편의성 측면에서 다르게 작용합니다. 요즘 유행하는 테마 모드는 주로 밝은 모드 또는 어두운 모드(어두운 모드가 가장 좋아요 :-))가 사용되고 있습니다. 일반적으로 사용자의 전화 시스템이 결정하도록 하는 세 번째 옵션이 존재하기도 합니다.</p>
<p>Redux로 Theming을 하는 이유는 무엇인가요?</p>
<div class="content-ad"></div>
<p>리덕스는 사용자가 상태를 중앙에서 조직적으로 관리할 수 있도록 도와주는 상태 관리 라이브러리입니다. 리덕스는 애플리케이션 상태를 저장하는 저장소 역할을 하며, 사용자는 이 저장소로 읽기, 업데이트 또는 액션을 전달할 수 있습니다. 리액트 컨텍스트, 리액트 쿼리 등 다른 더 쉬운 옵션이 있지만, 사용자를 위해 상태 관리를 간단하게 만드는 목적으로 이 글을 리덕스로 작성했습니다.</p>
<ul>
<li>리덕스는 현재 여러 프로젝트에서 사용 중인 매우 큰 커뮤니티 기반을 가지고 있습니다. 누군가에게 도움이 될 수 있습니다.</li>
<li>개인적으로는 상태 관리 과정에서 어떤 일이 벌어지는지 더 잘 이해할 수 있다고 믿습니다.</li>
<li>누군가가 그것이 스트레스라고 말했으므로, 왜냐하면 나는 그렇게 결정했기 때문에요. :-))</li>
</ul>
<p>우리가 이루고자 하는 목표</p>
<p>이 프로젝트를 작성하는 시점을 기준으로, React Native 버전인 0.72.7, TypeScript 버전인 4.8.4, Node 버전인 16.17.1, 그리고 NPM 버전인 8.15.0을 사용할 것입니다. 사용할 리덕스 패키지 버전은 다음과 같습니다.</p>
<div class="content-ad"></div>
<ul>
<li>"redux": "5.0.1",</li>
<li>"redux-logger": "3.0.6",</li>
<li>"redux-persist": "6.0.0",</li>
<li>"@react-native-async-storage/async-storage": "1.21.0"</li>
</ul>
<p>이 프로젝트를 진행하면서 몇 가지 목표를 이루고자 합니다.</p>
<ul>
<li>작업 환경을 설치하고 설정하기.</li>
<li>서로 다른 테마에 대한 다양한 색상을 만들고 사용할 테마 색상 객체를 선택하는 함수를 작성하기.</li>
<li>액션과 리듀서 만들기.</li>
<li>Redux 스토어 만들기, Redux 로거, 퍼시스트, 그리고 Async Storage 설정하기. 이 패키지들이 어떤 역할을 하는지 앱에서 사용하면서 설명해 드리겠습니다.</li>
<li>리하이드레이션에 대해 설명하고 여기서 왜 필요한지 이야기하기.</li>
<li>이 컴포넌트 내에서 저장된 상태 사용하기.</li>
<li>마지막으로, 사용자가 시스템의 기본 테마를 사용할 수 있도록 하는 세 번째 옵션을 고려하기.</li>
</ul>
<p>전제 조건</p>
<div class="content-ad"></div>
<ul>
<li>Javascript, Typescript, React Native 및 Redux에 대한 지식이 있습니다.</li>
<li>위의 패키지가 설치되었습니다.</li>
</ul>
<p>시작하기</p>
<p>패키지 설치</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// npm을 사용하여</span>
npm i redux redux-logger redux-persist @react-native-<span class="hljs-keyword">async</span>-storage/<span class="hljs-keyword">async</span>-storage
<span class="hljs-comment">// yarn을 사용하여</span>
yarn add redux redux-logger redux-persist @react-native-<span class="hljs-keyword">async</span>-storage/<span class="hljs-keyword">async</span>-storage
</code></pre>
<div class="content-ad"></div>
<p>색구성 만들기</p>
<p>누가 색상을 선택하는 데 머리 아픈 적이 없나요? src 폴더에 colors.tsx 파일을 생성하세요. 여기에는 light 및 dark 모드에 구조를 제공하는 유형을 만들었고, 이를 light 및 dark 키로 지정된 객체에 할당했습니다. 또한 테마에 따라 색구성을 반환하는 함수를 만들었습니다. 나중에 이 부분으로 돌아오겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> interface <span class="hljs-title class_">ColorProps</span> {
  <span class="hljs-attr">screenColor</span>: string;
  <span class="hljs-attr">primary</span>: string;
  <span class="hljs-attr">primaryTextColor</span>: string;
  <span class="hljs-attr">lighterBlack</span>: string;
  <span class="hljs-attr">secondaryTextColor</span>: string;
  <span class="hljs-attr">inActiveUnderlineTextInputColor</span>: string;
  <span class="hljs-attr">tertiaryTextColor</span>: string;
  <span class="hljs-attr">whiteColor</span>: string;
  <span class="hljs-attr">lightPrimaryColor</span>: string;
  <span class="hljs-attr">favouriteButtonColor</span>: string;
  <span class="hljs-attr">addPhotoButtonColor</span>: string;
  <span class="hljs-attr">ratingIconColor</span>: string;
  <span class="hljs-attr">disabledButtonColor</span>: string;
  <span class="hljs-attr">onboardingInactiveIconColor</span>: string;
  <span class="hljs-attr">tabBarTextColor</span>: string;
  <span class="hljs-attr">tabColor</span>: string;
  <span class="hljs-attr">gradientColor</span>: string;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Colors</span>: <span class="hljs-title class_">ColorProps</span> = {
  <span class="hljs-attr">screenColor</span>: <span class="hljs-string">'#E5E5E5'</span>,
  <span class="hljs-attr">primaryTextColor</span>: <span class="hljs-string">'#000000'</span>,
  <span class="hljs-attr">lighterBlack</span>: <span class="hljs-string">'#FFFFFF'</span>,
  <span class="hljs-attr">secondaryTextColor</span>: <span class="hljs-string">'#FFFFFF'</span>,
  <span class="hljs-attr">tertiaryTextColor</span>: <span class="hljs-string">'#FFFFFF'</span>,
  <span class="hljs-attr">gradientColor</span>: <span class="hljs-string">'#61D2C4'</span>,
  <span class="hljs-attr">tabColor</span>: <span class="hljs-string">'#FFFFFF'</span>,
  <span class="hljs-attr">ratingIconColor</span>: <span class="hljs-string">'#FFCD00'</span>,
  <span class="hljs-attr">primary</span>: <span class="hljs-string">'#2DDA93'</span>,
  <span class="hljs-attr">disabledButtonColor</span>: <span class="hljs-string">'#AAAAAA'</span>,
  <span class="hljs-attr">onboardingInactiveIconColor</span>: <span class="hljs-string">'#DBDBDB'</span>,
  <span class="hljs-attr">inActiveUnderlineTextInputColor</span>: <span class="hljs-string">'#A7A7A7'</span>,
  <span class="hljs-attr">lightPrimaryColor</span>: <span class="hljs-string">'#61D2C4'</span>,
  <span class="hljs-attr">tabBarTextColor</span>: <span class="hljs-string">'#D2D2D2'</span>,
  <span class="hljs-attr">whiteColor</span>: <span class="hljs-string">'#FFFFFF'</span>,
  <span class="hljs-attr">favouriteButtonColor</span>: <span class="hljs-string">'#FF6262'</span>,
  <span class="hljs-attr">addPhotoButtonColor</span>: <span class="hljs-string">'#48A2F5'</span>,
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">DarkColors</span>: <span class="hljs-title class_">ColorProps</span> = {
  <span class="hljs-attr">primaryTextColor</span>: <span class="hljs-string">'#FFFFFF'</span>,
  <span class="hljs-attr">tertiaryTextColor</span>: <span class="hljs-string">'#1E1E1E'</span>,
  <span class="hljs-attr">secondaryTextColor</span>: <span class="hljs-string">'#F5F5F5'</span>,
  <span class="hljs-attr">screenColor</span>: <span class="hljs-string">'#1B1C1E'</span>,
  <span class="hljs-attr">lighterBlack</span>: <span class="hljs-string">'#777777'</span>,
  <span class="hljs-attr">tabColor</span>: <span class="hljs-string">'#FFFFFF'</span>,
  <span class="hljs-attr">ratingIconColor</span>: <span class="hljs-string">'#FFCD00'</span>,
  <span class="hljs-attr">primary</span>: <span class="hljs-string">'#2DDA93'</span>,
  <span class="hljs-attr">disabledButtonColor</span>: <span class="hljs-string">'#AAAAAA'</span>,
  <span class="hljs-attr">lightPrimaryColor</span>: <span class="hljs-string">'#61D2C4'</span>,
  <span class="hljs-attr">gradientColor</span>: <span class="hljs-string">'#1B1C1E'</span>,
  <span class="hljs-attr">onboardingInactiveIconColor</span>: <span class="hljs-string">'#DBDBDB'</span>,
  <span class="hljs-attr">inActiveUnderlineTextInputColor</span>: <span class="hljs-string">'#A7A7A7'</span>,
  <span class="hljs-attr">tabBarTextColor</span>: <span class="hljs-string">'#D2D2D2'</span>,
  <span class="hljs-attr">whiteColor</span>: <span class="hljs-string">'#FFFFFF'</span>,
  <span class="hljs-attr">favouriteButtonColor</span>: <span class="hljs-string">'#FF6262'</span>,
  <span class="hljs-attr">addPhotoButtonColor</span>: <span class="hljs-string">'#48A2F5'</span>,
};
<span class="hljs-keyword">const</span> themes = {
  <span class="hljs-attr">light</span>: {...<span class="hljs-title class_">Colors</span>},
  <span class="hljs-attr">dark</span>: {...<span class="hljs-title class_">DarkColors</span>},
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getThemeColor</span> = (<span class="hljs-params">
  theme: <span class="hljs-string">'light'</span> | <span class="hljs-string">'dark'</span> = <span class="hljs-string">'light'</span>,
  useSystemTheme?: <span class="hljs-string">'light'</span> | <span class="hljs-string">'dark'</span>,
</span>) => {
  <span class="hljs-keyword">const</span> themeMode = themes[theme];
  <span class="hljs-keyword">return</span> themeMode;
};
</code></pre>
<p>더 진행하기 전에, store, action 및 reducer는 무엇인가요? 간단히 살펴보겠습니다.</p>
<div class="content-ad"></div>
<p>어딘가에서 배운 상인의 비유를 사용해 보자. 좋은 걸로 알고 있어.</p>
<ul>
<li>가게를 운영하는 상인인 당신이라고 상상해보세요. 당신은 주문을 방문해야 팔 수 있는 국가를 파는 상점을 소유하고 있어요 (이곳에서는 이것이 유행이죠). 당신의 고객들은 직접 물건을 가져갈 수 없어요, 당신이 주어야죠 (리덕스 스토어).</li>
<li>이익을 내려면 고객이 있어야 해요 - 우리는 비즈니스를 운영하고 있거든요!! - 이 고객들은 상점에 있는 제품에 대해 요청하거나 주문을 넣어요 (하나의 액션). 이러한 주문/요청은 '타입'으로 분류되며, 기타 정보와 함께 액션 객체에 유지되어요.</li>
<li>이제 재고를 업데이트해야 해요 - 몇 개의 물건을 주고 나서 재고가 부족해요 - 그러나 당신이 따르는 특정 논리가 있어요. 여기에서 리듀서라는 개념이 등장해요. 리듀서는 현재 상태와 액션을 받아 들이는 순수한 액션 함수로, 액션 타입과 데이터에 기반하여 새로운 상태를 반환해요.</li>
</ul>
<p>우리의 리덕스 폴더 구조</p>
<p><img src="/assets/img/2024-06-20-ThemingWithReduxinReactNative_1.png" alt="image"></p>
<div class="content-ad"></div>
<p>미리 정의된 유형과 초기 테마 상태를 정의해 봅시다 (이 기능은 더 큰 앱의 일부이므로 혼란스러워하지 않도록 이렇게 하고 있어요). 상태 매개변수에 초기 상태를 기본값으로 전달하는 것이 중요합니다. 이렇게 함으로써 상태가 정의되지 않은 경우 첫 번째로 리듀서를 호출할 때 처리할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">TOGGLE_STATUS</span>: <span class="hljs-string">'Toggle'</span>,
};
<span class="hljs-keyword">export</span> type <span class="hljs-title class_">ThemeData</span> = {
  <span class="hljs-attr">theme</span>: <span class="hljs-string">'light'</span> | <span class="hljs-string">'dark'</span> | <span class="hljs-string">'system'</span>;
};
<span class="hljs-keyword">const</span> <span class="hljs-attr">initialState</span>: <span class="hljs-title class_">ThemeData</span> = {
  <span class="hljs-attr">theme</span>: <span class="hljs-string">'light'</span>,
};
</code></pre>
<p>이제 액션(고객)을 만들어 봅시다.
먼저 액션 생성자부터 시작할게요 - 액션을 반환하는 함수(유형, 페이로드)를 반환하고, 페이로드를 새로운 테마로 설정하여 나중에 컴포넌트에서 디스패치할 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleTheme</span> = (<span class="hljs-params">newTheme: string</span>) => {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">type</span>: types.<span class="hljs-property">TOGGLE_STATUS</span>, <span class="hljs-comment">// 모든 액션은 유형을 가져야 합니다</span>
    <span class="hljs-attr">payload</span>: newTheme,
  };
};
</code></pre>
<div class="content-ad"></div>
<p>저희 상태를 업데이트하기 위한 reducer를 생성 중입니다 (상점 주인님)</p>
<p>여기서 이전 상태를 가져오고 이를 이전 상태가 없는 경우 초기 상태로 설정하는데 사용합니다. 그런 다음 액션에서 전달된 테마 값을 새 상태로 반환합니다. 여기서 액션은 'type, payload'로 구조화되어 있습니다. 타입이 없는 경우에는 이전 상태를 기본 블록에 전달합니다. 이 동작은 새로운 테마 모드로 상태를 업데이트합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleThemeReducer</span> = (<span class="hljs-params">
  state: ThemeData = initialState,
  {type, payload}: {type: string; payload: any},
</span>) => {
  <span class="hljs-keyword">switch</span> (type) {
    <span class="hljs-keyword">case</span> types.<span class="hljs-property">TOGGLE_STATUS</span>:
      <span class="hljs-keyword">return</span> {...state, <span class="hljs-attr">theme</span>: payload};
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
};
</code></pre>
<p>리덕스 스토어 설정 중입니다</p>
<div class="content-ad"></div>
<p>와, 그것은 쉬운 부분이었네요. 이제 더 쉬운 부분으로 넘어가겠습니다. (다만 좀 더 신경 써야 할 수도 있어요 :-)).</p>
<p>우리는 예상되는 입력 상태에 타입을 지정하는 것부터 시작할 거에요. 이렇게 미리 정의된 타입을 TypeScript가 타입 추론을 도와줄 때 삶이 조금 더 쉬워지게 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> type <span class="hljs-title class_">ThemeState</span> = <span class="hljs-title class_">ReturnType</span>&#x3C;<span class="hljs-keyword">typeof</span> toggleThemeReducer>;
</code></pre>
<p>그런 다음에는 우리의 toggleThemeReducer 주위에 래퍼 역할을 하는 루트 리듀서를 가지고 있어요. 그 루트 리듀서는 redux-persist를 사용할 때 지속 상태를 처리하는 데 도움을 줍니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">rootReducer</span> = (<span class="hljs-params">state: ThemeState | <span class="hljs-literal">undefined</span>, action: any</span>) => {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">rehydratedState</span>: <span class="hljs-title class_">ThemeState</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-title function_">toggleThemeReducer</span>(state, action);
  <span class="hljs-keyword">return</span> rehydratedState;
};
</code></pre>
<p>이제 상태를 보존해야 합니다. 이렇게 하면 사용자가 애플리케이션을 다시 시작하거나 새로 고침하면 이전에 한 변경 사항을 볼 수 있습니다. 테마 상태를 앱 다시 시작이나 새로 고침을 통해 다시 살리기 위해 상태를 보존하고 살립니다. 먼저 리듀서를 보존할 설정 객체(코드 상단에 좋습니다)를 만들고, 이 값을 persistReducer에 전달해야 합니다. 지속성 구성 객체는 redux-persist가 저장 솔루션으로 AsyncStorage를 사용하도록 구성하고 '테마' 상태만을 지속해야 한다고 지정합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> persistConfig = {
  <span class="hljs-attr">key</span>: <span class="hljs-string">'root'</span>,
  <span class="hljs-attr">storage</span>: <span class="hljs-title class_">AsyncStorage</span>,
  <span class="hljs-attr">whitelist</span>: [<span class="hljs-string">'theme'</span>],
};

<span class="hljs-keyword">const</span> persistedReducer = <span class="hljs-title function_">persistReducer</span>(persistConfig, rootReducer);
</code></pre>
<p>이제 저장소를 설정하고 이 저장소를 지속해야 합니다. 지속된 리듀서를 사용하여 저장소를 생성하면 테마 상태를 지속하고 다시 살립니다. 지속된 저장소(persistor)는 persistStore와 Redux 저장소를 사용하여 만듭니다. 이 persistor는 필요할 때 상태를 수동으로 보존하고 다시 살릴 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">상태 = <span class="hljs-title function_">createStore</span>(
= 지속<span class="hljs-title class_">Reducer</span>,
= <span class="hljs-title function_">applyMiddleware</span>(...middlewares),
);
= 지속 = <span class="hljs-title function_">persistStore</span>(모임);
</code></pre>
<p>Redux-logger</p>
<p>이것은 Redux 스토어를 사용할 때 우리를 돕는 미들웨어입니다. 우리는 reduxlogger를 사용하는 middleware라는 배열을 만듭니다.</p>
<pre><code class="hljs language-js">reduxlogger = <span class="hljs-title function_">createLogger</span>({});
middleware = [reduxlogger];

상태 = <span class="hljs-title function_">createStore</span>(
= 지속<span class="hljs-title class_">Reducer</span>,
= <span class="hljs-title function_">applyMiddleware</span>(...middleware),
);
</code></pre>
<div class="content-ad"></div>
<ul>
<li>Redux Logger: 이것은 모든 Redux 액션과 상태 변경을 콘솔에 로그로 남기는 개발 도구입니다. 이는 디버깅 목적으로 매우 유용한데, 액션의 흐름을 추적하고 그에 따라 상태가 어떻게 업데이트되는지 확인할 수 있기 때문입니다.</li>
</ul>
<p>재수행(Rehydration)</p>
<p>이제, 우리는 리듀서를 수정하여 우리가 재수행할 때의 시나리오에 유의해야 합니다. 하지만 먼저, 재수행이 무엇인지 살펴보겠습니다. 우리 로거에서 가져온 앱의 로그를 살펴보면, 재시작했다는 것을 알 수 있습니다.</p>
<pre><code class="hljs language-js">{<span class="hljs-string">"theme"</span>: {<span class="hljs-string">"theme"</span>: <span class="hljs-string">"light"</span>}
<span class="hljs-variable constant_">GROUP</span>  action persist/<span class="hljs-variable constant_">PERSIST</span> @ <span class="hljs-number">16</span>:<span class="hljs-number">15</span>:<span class="hljs-number">46.681</span>
<span class="hljs-variable constant_">LOG</span>    prev state {<span class="hljs-string">"theme"</span>: {<span class="hljs-string">"theme"</span>: <span class="hljs-string">"light"</span>}
<span class="hljs-variable constant_">LOG</span>    action     {<span class="hljs-string">"register"</span>: [<span class="hljs-title class_">Function</span> register], <span class="hljs-string">"rehydrate"</span>: [<span class="hljs-title class_">Function</span> rehydrate], <span class="hljs-string">"type"</span>: <span class="hljs-string">"persist/PERSIST"</span>}
<span class="hljs-variable constant_">LOG</span>    next state {<span class="hljs-string">"_persist"</span>: {<span class="hljs-string">"rehydrated"</span>: <span class="hljs-literal">false</span>, <span class="hljs-string">"version"</span>: -<span class="hljs-number">1</span>}, <span class="hljs-string">"theme"</span>: {<span class="hljs-string">"theme"</span>: <span class="hljs-string">"light"</span>}
<span class="hljs-variable constant_">LOG</span>    {<span class="hljs-string">"theme"</span>: {<span class="hljs-string">"theme"</span>: <span class="hljs-string">"light"</span>} 재수행상태 
<span class="hljs-variable constant_">LOG</span>    {<span class="hljs-string">"_persist"</span>: {<span class="hljs-string">"rehydrated"</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">"version"</span>: -<span class="hljs-number">1</span>}, <span class="hljs-string">"theme"</span>: {<span class="hljs-string">"theme"</span>: <span class="hljs-string">"dark"</span>} 페이로드 {<span class="hljs-string">"theme"</span>: <span class="hljs-string">"light"</span>} 상태
<span class="hljs-variable constant_">GROUP</span>  action persist/<span class="hljs-variable constant_">REHYDRATE</span> @ <span class="hljs-number">16</span>:<span class="hljs-number">15</span>:<span class="hljs-number">46.923</span>
<span class="hljs-variable constant_">LOG</span>    prev state {<span class="hljs-string">"_persist"</span>: {<span class="hljs-string">"rehydrated"</span>: <span class="hljs-literal">false</span>, <span class="hljs-string">"version"</span>: -<span class="hljs-number">1</span>}, <span class="hljs-string">"theme"</span>: {<span class="hljs-string">"theme"</span>: <span class="hljs-string">"light"</span>}
<span class="hljs-variable constant_">LOG</span>    action     {<span class="hljs-string">"err"</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-string">"key"</span>: <span class="hljs-string">"root"</span>, <span class="hljs-string">"payload"</span>: {<span class="hljs-string">"_persist"</span>: {<span class="hljs-string">"rehydrated"</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">"version"</span>: -<span class="hljs-number">1</span>}, <span class="hljs-string">"theme"</span>: {<span class="hljs-string">"theme"</span>: <span class="hljs-string">"dark"</span>}, <span class="hljs-string">"type"</span>: <span class="hljs-string">"persist/REHYDRATE"</span>}
<span class="hljs-variable constant_">LOG</span>    next state {<span class="hljs-string">"_persist"</span>: {<span class="hljs-string">"rehydrated"</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">"version"</span>: -<span class="hljs-number">1</span>}, <span class="hljs-string">"theme"</span>: {<span class="hljs-string">"theme"</span>: <span class="hljs-string">"dark"</span>}
</code></pre>
<div class="content-ad"></div>
<p>여기에서 무슨 일이 일어나고 있는 거죠?</p>
<p>앱이 다시 시작될 때, redux-persist가 먼저 현재 상태인 <code>light</code>를 AsyncStorage에 <code>persist/PERSIST</code> 액션을 사용하여 영속화합니다. 그런 다음, 이전에 <code>dark</code>로 설정되었던 영속 상태를 AsyncStorage에서 가져와 Redux 스토어에 <code>persist/REHYDRATE</code> 액션을 사용하여 재수확합니다.</p>
<p>이것이 스토어에 대한 완전한 코드입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> persistConfig = {
  <span class="hljs-attr">key</span>: <span class="hljs-string">'root'</span>,
  <span class="hljs-attr">storage</span>: <span class="hljs-title class_">AsyncStorage</span>,
  <span class="hljs-attr">whitelist</span>: [<span class="hljs-string">'theme'</span>],
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">rootReducer</span> = (<span class="hljs-params">state: ThemeState | <span class="hljs-literal">undefined</span>, action: any</span>) => {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">rehydratedState</span>: <span class="hljs-title class_">ThemeState</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-title function_">toggleThemeReducer</span>(state, action);
  <span class="hljs-keyword">return</span> rehydratedState;
};

<span class="hljs-keyword">const</span> persistedReducer = <span class="hljs-title function_">persistReducer</span>(persistConfig, rootReducer);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(
  persistedReducer,
  <span class="hljs-title function_">applyMiddleware</span>(...middlewares),
);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> persistor = <span class="hljs-title function_">persistStore</span>(store);

<span class="hljs-keyword">export</span> type <span class="hljs-title class_">RootState</span> = <span class="hljs-title class_">ReturnType</span>&#x3C;<span class="hljs-keyword">typeof</span> rootReducer>; <span class="hljs-comment">// 사전 정의된 이 유형 추론을 돕기 위한 것.</span>
</code></pre>
<div class="content-ad"></div>
<p>우리 컴포넌트와 함께 이들 저장된 상태를 사용합니다.</p>
<p>이 시연에서는 앱 내에서 테마 모드를 전환하는 데 도움이 되는 테마 버튼이 포함된 드롭다운을 가지고 있을 것입니다.</p>
<pre><code class="hljs language-js">인터페이스 <span class="hljs-title class_">DropDownData</span> {
  라벨: 문자열;
  값: 문자열;
}
인터페이스 <span class="hljs-title class_">DropDownProps</span> {
  색상?: 문자열;
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">DropDown</span> = (<span class="hljs-params">props?: DropDownProps</span>) => {
  <span class="hljs-keyword">const</span> navigation = useNavigation&#x3C;<span class="hljs-title class_">RootStackNavigationProp</span>>();
  <span class="hljs-keyword">const</span> [selectedOption, setSelectedOption] = useState&#x3C;string>(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>: <span class="hljs-title class_">DropDownData</span>[] = [
    {<span class="hljs-attr">label</span>: <span class="hljs-string">'테마'</span>, 값: <span class="hljs-string">'theme'</span>},
  ];

  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();

  <span class="hljs-keyword">const</span> userTheme = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state: RootState</span>) =></span> state.<span class="hljs-property">theme</span>);
  <span class="hljs-keyword">const</span> {theme} = userTheme;
  <span class="hljs-keyword">const</span> <span class="hljs-title class_">Colors</span> = <span class="hljs-title function_">getThemeColor</span>(theme);

  <span class="hljs-keyword">const</span> styles = <span class="hljs-title class_">StyleSheet</span>.<span class="hljs-title function_">create</span>({
    <span class="hljs-attr">dropDownItem</span>: {
      <span class="hljs-attr">paddingHorizontal</span>: screenWidth * <span class="hljs-number">0.04</span>,
    },
    <span class="hljs-attr">dropdown</span>: {
      <span class="hljs-attr">backgroundColor</span>: <span class="hljs-title class_">Colors</span>.<span class="hljs-property">screenColor</span>,
      <span class="hljs-attr">position</span>: <span class="hljs-string">'absolute'</span>,
      <span class="hljs-attr">left</span>: screenWidth * <span class="hljs-number">0.55</span>,
      <span class="hljs-attr">borderRadius</span>: <span class="hljs-number">20</span>,
      <span class="hljs-attr">paddingVertical</span>: <span class="hljs-number">8</span>,
      <span class="hljs-attr">width</span>: screenWidth * <span class="hljs-number">0.4</span>,
    },
  });

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleOptionSelect</span> = (<span class="hljs-params">value: string</span>) => {
    <span class="hljs-title function_">setSelectedOption</span>(value);

    <span class="hljs-keyword">if</span> (value === <span class="hljs-string">'customTheme'</span>) {
      <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">toggleTheme</span>(theme === <span class="hljs-string">'light'</span> ? <span class="hljs-string">'dark'</span> : <span class="hljs-string">'light'</span>));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value === <span class="hljs-string">'system'</span>) {
      <span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">toggleTheme</span>(<span class="hljs-string">'system'</span>));
    }
  };
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">View</span>
      <span class="hljs-attr">style</span>=<span class="hljs-string">{</span>
        <span class="hljs-attr">position:</span> '<span class="hljs-attr">absolute</span>',
        <span class="hljs-attr">top:</span> <span class="hljs-attr">screenHeight</span> * <span class="hljs-attr">0.07</span>,
        <span class="hljs-attr">right:</span> <span class="hljs-attr">screenWidth</span> * <span class="hljs-attr">0.03</span>,
      }></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">SelectDropdown</span>
        <span class="hljs-attr">data</span>=<span class="hljs-string">{data}</span>
        <span class="hljs-attr">statusBarTranslucent</span>
        <span class="hljs-attr">renderItem</span>=<span class="hljs-string">{(</span>
          <span class="hljs-attr">selectedItem:</span> <span class="hljs-attr">DropDownData</span>,
          <span class="hljs-attr">index:</span> <span class="hljs-attr">number</span>,
          <span class="hljs-attr">isSelected:</span> <span class="hljs-attr">boolean</span>,
        ) =></span> {
          return (
            <span class="hljs-tag">&#x3C;<span class="hljs-name">View</span>
              <span class="hljs-attr">style</span>=<span class="hljs-string">{</span>
                <span class="hljs-attr">...styles.dropDownItem</span>,
                <span class="hljs-attr">borderBottomWidth:</span> <span class="hljs-attr">1</span>,
                <span class="hljs-attr">borderBottomColor:</span> <span class="hljs-attr">Colors.primary</span>,
              }></span>
              <span class="hljs-tag">&#x3C;<span class="hljs-name">WText</span>
                <span class="hljs-attr">style</span>=<span class="hljs-string">{</span>
                  <span class="hljs-attr">paddingVertical:</span> <span class="hljs-attr">13</span>,
                  <span class="hljs-attr">paddingLeft:</span> <span class="hljs-attr">5</span>,
                  <span class="hljs-attr">fontSize:</span> <span class="hljs-attr">18</span>,
                }></span>
                {selectedItem.label}
              <span class="hljs-tag">&#x3C;/<span class="hljs-name">WText</span>></span>
            <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span>
          );
        }
        dropdownOverlayColor="transparent"
        renderButton={() => {
          return (
            <span class="hljs-tag">&#x3C;<span class="hljs-name">View</span>
              <span class="hljs-attr">style</span>=<span class="hljs-string">{</span>
                <span class="hljs-attr">alignItems:</span> '<span class="hljs-attr">flex-end</span>',
                <span class="hljs-attr">backgroundColor:</span> <span class="hljs-attr">Colors.lighterBlack</span>,
                <span class="hljs-attr">borderRadius:</span> <span class="hljs-attr">100</span>,
                <span class="hljs-attr">padding:</span> <span class="hljs-attr">5</span>,
              }></span>
              <span class="hljs-tag">&#x3C;<span class="hljs-name">Ionicons</span>
                <span class="hljs-attr">name</span>=<span class="hljs-string">"ellipsis-vertical"</span>
                <span class="hljs-attr">color</span>=<span class="hljs-string">{Colors.primary}</span>
                <span class="hljs-attr">size</span>=<span class="hljs-string">{30}</span>
              /></span>
            <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span>
          );
        }
        onSelect={(selectedItem: DropDownData, index: number) => {
          handleOptionSelect(selectedItem.value);
        }
        dropdownStyle={styles.dropdown}
      />
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DropDown</span>;
</code></pre>
<p>위에 무슨 일이 발생했나요? "CustomTheme"을 선택했을 때, 현재 테마의 값을 확인한 후, 테마를 번갈아가며 변경합니다. 그러나 "system" 옵션을 선택하면 폰의 기본 테마를 사용합니다.</p>
<div class="content-ad"></div>
<p>시스템 기본 테마 사용하기</p>
<p>마지막으로 시스템 테마를 사용하려면 useColorScheme 훅을 활용할 수 있습니다. 이 훅은 기기에서 현재 사용 중인 색상테마에 대한 업데이트를 제공합니다. colors.tsx 파일에서 getThemeColor 함수를 수정해봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getThemeColor</span> = (<span class="hljs-params">theme: <span class="hljs-string">'light'</span> | <span class="hljs-string">'dark'</span> = <span class="hljs-string">'light'</span></span>) => {
  <span class="hljs-keyword">const</span> systemTheme = <span class="hljs-title function_">useColorScheme</span>() || <span class="hljs-string">'light'</span>;
  <span class="hljs-keyword">const</span> userTheme = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state: RootState</span>) =></span> state.<span class="hljs-property">theme</span>);
  <span class="hljs-keyword">const</span> {<span class="hljs-attr">theme</span>: storedTheme} = userTheme;
  <span class="hljs-keyword">let</span> themeMode;

  <span class="hljs-keyword">if</span> (storedTheme === <span class="hljs-string">'system'</span>) {
    <span class="hljs-keyword">const</span> themeMode = themes[systemTheme];
    <span class="hljs-keyword">return</span> themeMode;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">const</span> themeMode = themes[theme];
    <span class="hljs-keyword">return</span> themeMode;
  }
};
</code></pre>
<p>아래의 코드를 사용하여 저장소에서 현재 테마 색상을 제공받아 원하는 동작을 구현하는데 사용할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> userTheme = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function">(<span class="hljs-params">state: RootState</span>) =></span> state.<span class="hljs-property">theme</span>);
<span class="hljs-keyword">const</span> {theme} = userTheme;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Colors</span> = <span class="hljs-title function_">getThemeColor</span>(theme);
</code></pre>
<p>아래는 우리의 결과입니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1152/1*2zA_7xp0whnKUe5a5ts_aA.gif" alt="image"></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트 네이티브에서 Redux를 이용한 테마 설정","description":"","date":"2024-06-20 00:06","slug":"2024-06-20-ThemingWithReduxinReactNative","content":"\n\n![image](/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png)\n\n왜 Theming을 할까요?\n\nTheming은 현대 앱의 주요 부분이 되어, 사용자 맞춤화 기능을 더욱 향상시킬 수 있게 해줍니다. 테마는 다양한 속성을 포함한 스타일을 설정하여, 다양한 사용자에게 다양한 방식으로 읽히게 합니다. 특히 편의성 측면에서 다르게 작용합니다. 요즘 유행하는 테마 모드는 주로 밝은 모드 또는 어두운 모드(어두운 모드가 가장 좋아요 :-))가 사용되고 있습니다. 일반적으로 사용자의 전화 시스템이 결정하도록 하는 세 번째 옵션이 존재하기도 합니다.\n\nRedux로 Theming을 하는 이유는 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리덕스는 사용자가 상태를 중앙에서 조직적으로 관리할 수 있도록 도와주는 상태 관리 라이브러리입니다. 리덕스는 애플리케이션 상태를 저장하는 저장소 역할을 하며, 사용자는 이 저장소로 읽기, 업데이트 또는 액션을 전달할 수 있습니다. 리액트 컨텍스트, 리액트 쿼리 등 다른 더 쉬운 옵션이 있지만, 사용자를 위해 상태 관리를 간단하게 만드는 목적으로 이 글을 리덕스로 작성했습니다.\n\n- 리덕스는 현재 여러 프로젝트에서 사용 중인 매우 큰 커뮤니티 기반을 가지고 있습니다. 누군가에게 도움이 될 수 있습니다.\n- 개인적으로는 상태 관리 과정에서 어떤 일이 벌어지는지 더 잘 이해할 수 있다고 믿습니다.\n- 누군가가 그것이 스트레스라고 말했으므로, 왜냐하면 나는 그렇게 결정했기 때문에요. :-))\n\n우리가 이루고자 하는 목표\n\n이 프로젝트를 작성하는 시점을 기준으로, React Native 버전인 0.72.7, TypeScript 버전인 4.8.4, Node 버전인 16.17.1, 그리고 NPM 버전인 8.15.0을 사용할 것입니다. 사용할 리덕스 패키지 버전은 다음과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- \"redux\": \"5.0.1\",\n- \"redux-logger\": \"3.0.6\",\n- \"redux-persist\": \"6.0.0\",\n- \"@react-native-async-storage/async-storage\": \"1.21.0\"\n\n이 프로젝트를 진행하면서 몇 가지 목표를 이루고자 합니다.\n\n- 작업 환경을 설치하고 설정하기.\n- 서로 다른 테마에 대한 다양한 색상을 만들고 사용할 테마 색상 객체를 선택하는 함수를 작성하기.\n- 액션과 리듀서 만들기.\n- Redux 스토어 만들기, Redux 로거, 퍼시스트, 그리고 Async Storage 설정하기. 이 패키지들이 어떤 역할을 하는지 앱에서 사용하면서 설명해 드리겠습니다.\n- 리하이드레이션에 대해 설명하고 여기서 왜 필요한지 이야기하기.\n- 이 컴포넌트 내에서 저장된 상태 사용하기.\n- 마지막으로, 사용자가 시스템의 기본 테마를 사용할 수 있도록 하는 세 번째 옵션을 고려하기.\n\n전제 조건\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Javascript, Typescript, React Native 및 Redux에 대한 지식이 있습니다.\n- 위의 패키지가 설치되었습니다.\n\n시작하기\n\n패키지 설치\n\n```js\n// npm을 사용하여\nnpm i redux redux-logger redux-persist @react-native-async-storage/async-storage\n// yarn을 사용하여\nyarn add redux redux-logger redux-persist @react-native-async-storage/async-storage\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n색구성 만들기\n\n누가 색상을 선택하는 데 머리 아픈 적이 없나요? src 폴더에 colors.tsx 파일을 생성하세요. 여기에는 light 및 dark 모드에 구조를 제공하는 유형을 만들었고, 이를 light 및 dark 키로 지정된 객체에 할당했습니다. 또한 테마에 따라 색구성을 반환하는 함수를 만들었습니다. 나중에 이 부분으로 돌아오겠습니다.\n\n```js\nexport interface ColorProps {\n  screenColor: string;\n  primary: string;\n  primaryTextColor: string;\n  lighterBlack: string;\n  secondaryTextColor: string;\n  inActiveUnderlineTextInputColor: string;\n  tertiaryTextColor: string;\n  whiteColor: string;\n  lightPrimaryColor: string;\n  favouriteButtonColor: string;\n  addPhotoButtonColor: string;\n  ratingIconColor: string;\n  disabledButtonColor: string;\n  onboardingInactiveIconColor: string;\n  tabBarTextColor: string;\n  tabColor: string;\n  gradientColor: string;\n}\nexport const Colors: ColorProps = {\n  screenColor: '#E5E5E5',\n  primaryTextColor: '#000000',\n  lighterBlack: '#FFFFFF',\n  secondaryTextColor: '#FFFFFF',\n  tertiaryTextColor: '#FFFFFF',\n  gradientColor: '#61D2C4',\n  tabColor: '#FFFFFF',\n  ratingIconColor: '#FFCD00',\n  primary: '#2DDA93',\n  disabledButtonColor: '#AAAAAA',\n  onboardingInactiveIconColor: '#DBDBDB',\n  inActiveUnderlineTextInputColor: '#A7A7A7',\n  lightPrimaryColor: '#61D2C4',\n  tabBarTextColor: '#D2D2D2',\n  whiteColor: '#FFFFFF',\n  favouriteButtonColor: '#FF6262',\n  addPhotoButtonColor: '#48A2F5',\n};\n\nexport const DarkColors: ColorProps = {\n  primaryTextColor: '#FFFFFF',\n  tertiaryTextColor: '#1E1E1E',\n  secondaryTextColor: '#F5F5F5',\n  screenColor: '#1B1C1E',\n  lighterBlack: '#777777',\n  tabColor: '#FFFFFF',\n  ratingIconColor: '#FFCD00',\n  primary: '#2DDA93',\n  disabledButtonColor: '#AAAAAA',\n  lightPrimaryColor: '#61D2C4',\n  gradientColor: '#1B1C1E',\n  onboardingInactiveIconColor: '#DBDBDB',\n  inActiveUnderlineTextInputColor: '#A7A7A7',\n  tabBarTextColor: '#D2D2D2',\n  whiteColor: '#FFFFFF',\n  favouriteButtonColor: '#FF6262',\n  addPhotoButtonColor: '#48A2F5',\n};\nconst themes = {\n  light: {...Colors},\n  dark: {...DarkColors},\n};\n\nexport const getThemeColor = (\n  theme: 'light' | 'dark' = 'light',\n  useSystemTheme?: 'light' | 'dark',\n) =\u003e {\n  const themeMode = themes[theme];\n  return themeMode;\n};\n```\n\n더 진행하기 전에, store, action 및 reducer는 무엇인가요? 간단히 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어딘가에서 배운 상인의 비유를 사용해 보자. 좋은 걸로 알고 있어.\n\n- 가게를 운영하는 상인인 당신이라고 상상해보세요. 당신은 주문을 방문해야 팔 수 있는 국가를 파는 상점을 소유하고 있어요 (이곳에서는 이것이 유행이죠). 당신의 고객들은 직접 물건을 가져갈 수 없어요, 당신이 주어야죠 (리덕스 스토어).\n- 이익을 내려면 고객이 있어야 해요 - 우리는 비즈니스를 운영하고 있거든요!! - 이 고객들은 상점에 있는 제품에 대해 요청하거나 주문을 넣어요 (하나의 액션). 이러한 주문/요청은 '타입'으로 분류되며, 기타 정보와 함께 액션 객체에 유지되어요.\n- 이제 재고를 업데이트해야 해요 - 몇 개의 물건을 주고 나서 재고가 부족해요 - 그러나 당신이 따르는 특정 논리가 있어요. 여기에서 리듀서라는 개념이 등장해요. 리듀서는 현재 상태와 액션을 받아 들이는 순수한 액션 함수로, 액션 타입과 데이터에 기반하여 새로운 상태를 반환해요.\n\n우리의 리덕스 폴더 구조\n\n![image](/assets/img/2024-06-20-ThemingWithReduxinReactNative_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미리 정의된 유형과 초기 테마 상태를 정의해 봅시다 (이 기능은 더 큰 앱의 일부이므로 혼란스러워하지 않도록 이렇게 하고 있어요). 상태 매개변수에 초기 상태를 기본값으로 전달하는 것이 중요합니다. 이렇게 함으로써 상태가 정의되지 않은 경우 첫 번째로 리듀서를 호출할 때 처리할 수 있습니다.\n\n```js\nexport default {\n  TOGGLE_STATUS: 'Toggle',\n};\nexport type ThemeData = {\n  theme: 'light' | 'dark' | 'system';\n};\nconst initialState: ThemeData = {\n  theme: 'light',\n};\n```\n\n이제 액션(고객)을 만들어 봅시다.\n먼저 액션 생성자부터 시작할게요 - 액션을 반환하는 함수(유형, 페이로드)를 반환하고, 페이로드를 새로운 테마로 설정하여 나중에 컴포넌트에서 디스패치할 것입니다. \n\n```js\nexport const toggleTheme = (newTheme: string) =\u003e {\n  return {\n    type: types.TOGGLE_STATUS, // 모든 액션은 유형을 가져야 합니다\n    payload: newTheme,\n  };\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 상태를 업데이트하기 위한 reducer를 생성 중입니다 (상점 주인님)\n\n여기서 이전 상태를 가져오고 이를 이전 상태가 없는 경우 초기 상태로 설정하는데 사용합니다. 그런 다음 액션에서 전달된 테마 값을 새 상태로 반환합니다. 여기서 액션은 'type, payload'로 구조화되어 있습니다. 타입이 없는 경우에는 이전 상태를 기본 블록에 전달합니다. 이 동작은 새로운 테마 모드로 상태를 업데이트합니다.\n\n```js\nconst toggleThemeReducer = (\n  state: ThemeData = initialState,\n  {type, payload}: {type: string; payload: any},\n) =\u003e {\n  switch (type) {\n    case types.TOGGLE_STATUS:\n      return {...state, theme: payload};\n    default:\n      return state;\n  }\n};\n```\n\n리덕스 스토어 설정 중입니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n와, 그것은 쉬운 부분이었네요. 이제 더 쉬운 부분으로 넘어가겠습니다. (다만 좀 더 신경 써야 할 수도 있어요 :-)).\n\n우리는 예상되는 입력 상태에 타입을 지정하는 것부터 시작할 거에요. 이렇게 미리 정의된 타입을 TypeScript가 타입 추론을 도와줄 때 삶이 조금 더 쉬워지게 됩니다.\n\n```js\nexport type ThemeState = ReturnType\u003ctypeof toggleThemeReducer\u003e;\n```\n\n그런 다음에는 우리의 toggleThemeReducer 주위에 래퍼 역할을 하는 루트 리듀서를 가지고 있어요. 그 루트 리듀서는 redux-persist를 사용할 때 지속 상태를 처리하는 데 도움을 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst rootReducer = (state: ThemeState | undefined, action: any) =\u003e {\n  const rehydratedState: ThemeState | undefined = toggleThemeReducer(state, action);\n  return rehydratedState;\n};\n```\n\n이제 상태를 보존해야 합니다. 이렇게 하면 사용자가 애플리케이션을 다시 시작하거나 새로 고침하면 이전에 한 변경 사항을 볼 수 있습니다. 테마 상태를 앱 다시 시작이나 새로 고침을 통해 다시 살리기 위해 상태를 보존하고 살립니다. 먼저 리듀서를 보존할 설정 객체(코드 상단에 좋습니다)를 만들고, 이 값을 persistReducer에 전달해야 합니다. 지속성 구성 객체는 redux-persist가 저장 솔루션으로 AsyncStorage를 사용하도록 구성하고 '테마' 상태만을 지속해야 한다고 지정합니다.\n\n```js\nconst persistConfig = {\n  key: 'root',\n  storage: AsyncStorage,\n  whitelist: ['theme'],\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n```\n\n이제 저장소를 설정하고 이 저장소를 지속해야 합니다. 지속된 리듀서를 사용하여 저장소를 생성하면 테마 상태를 지속하고 다시 살립니다. 지속된 저장소(persistor)는 persistStore와 Redux 저장소를 사용하여 만듭니다. 이 persistor는 필요할 때 상태를 수동으로 보존하고 다시 살릴 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n상태 = createStore(\n= 지속Reducer,\n= applyMiddleware(...middlewares),\n);\n= 지속 = persistStore(모임);\n```\n\nRedux-logger\n\n이것은 Redux 스토어를 사용할 때 우리를 돕는 미들웨어입니다. 우리는 reduxlogger를 사용하는 middleware라는 배열을 만듭니다.\n\n```js\nreduxlogger = createLogger({});\nmiddleware = [reduxlogger];\n\n상태 = createStore(\n= 지속Reducer,\n= applyMiddleware(...middleware),\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Redux Logger: 이것은 모든 Redux 액션과 상태 변경을 콘솔에 로그로 남기는 개발 도구입니다. 이는 디버깅 목적으로 매우 유용한데, 액션의 흐름을 추적하고 그에 따라 상태가 어떻게 업데이트되는지 확인할 수 있기 때문입니다.\n\n재수행(Rehydration)\n\n이제, 우리는 리듀서를 수정하여 우리가 재수행할 때의 시나리오에 유의해야 합니다. 하지만 먼저, 재수행이 무엇인지 살펴보겠습니다. 우리 로거에서 가져온 앱의 로그를 살펴보면, 재시작했다는 것을 알 수 있습니다.\n\n```js\n{\"theme\": {\"theme\": \"light\"}\nGROUP  action persist/PERSIST @ 16:15:46.681\nLOG    prev state {\"theme\": {\"theme\": \"light\"}\nLOG    action     {\"register\": [Function register], \"rehydrate\": [Function rehydrate], \"type\": \"persist/PERSIST\"}\nLOG    next state {\"_persist\": {\"rehydrated\": false, \"version\": -1}, \"theme\": {\"theme\": \"light\"}\nLOG    {\"theme\": {\"theme\": \"light\"} 재수행상태 \nLOG    {\"_persist\": {\"rehydrated\": true, \"version\": -1}, \"theme\": {\"theme\": \"dark\"} 페이로드 {\"theme\": \"light\"} 상태\nGROUP  action persist/REHYDRATE @ 16:15:46.923\nLOG    prev state {\"_persist\": {\"rehydrated\": false, \"version\": -1}, \"theme\": {\"theme\": \"light\"}\nLOG    action     {\"err\": undefined, \"key\": \"root\", \"payload\": {\"_persist\": {\"rehydrated\": true, \"version\": -1}, \"theme\": {\"theme\": \"dark\"}, \"type\": \"persist/REHYDRATE\"}\nLOG    next state {\"_persist\": {\"rehydrated\": true, \"version\": -1}, \"theme\": {\"theme\": \"dark\"}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에서 무슨 일이 일어나고 있는 거죠?\n\n앱이 다시 시작될 때, redux-persist가 먼저 현재 상태인 `light`를 AsyncStorage에 `persist/PERSIST` 액션을 사용하여 영속화합니다. 그런 다음, 이전에 `dark`로 설정되었던 영속 상태를 AsyncStorage에서 가져와 Redux 스토어에 `persist/REHYDRATE` 액션을 사용하여 재수확합니다.\n\n이것이 스토어에 대한 완전한 코드입니다.\n\n```js\nconst persistConfig = {\n  key: 'root',\n  storage: AsyncStorage,\n  whitelist: ['theme'],\n};\n\nconst rootReducer = (state: ThemeState | undefined, action: any) =\u003e {\n  const rehydratedState: ThemeState | undefined = toggleThemeReducer(state, action);\n  return rehydratedState;\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\nexport const store = createStore(\n  persistedReducer,\n  applyMiddleware(...middlewares),\n);\nexport const persistor = persistStore(store);\n\nexport type RootState = ReturnType\u003ctypeof rootReducer\u003e; // 사전 정의된 이 유형 추론을 돕기 위한 것.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 컴포넌트와 함께 이들 저장된 상태를 사용합니다.\n\n이 시연에서는 앱 내에서 테마 모드를 전환하는 데 도움이 되는 테마 버튼이 포함된 드롭다운을 가지고 있을 것입니다.\n\n```js\n인터페이스 DropDownData {\n  라벨: 문자열;\n  값: 문자열;\n}\n인터페이스 DropDownProps {\n  색상?: 문자열;\n}\nconst DropDown = (props?: DropDownProps) =\u003e {\n  const navigation = useNavigation\u003cRootStackNavigationProp\u003e();\n  const [selectedOption, setSelectedOption] = useState\u003cstring\u003e('');\n\n  const data: DropDownData[] = [\n    {label: '테마', 값: 'theme'},\n  ];\n\n  const dispatch = useDispatch();\n\n  const userTheme = useSelector((state: RootState) =\u003e state.theme);\n  const {theme} = userTheme;\n  const Colors = getThemeColor(theme);\n\n  const styles = StyleSheet.create({\n    dropDownItem: {\n      paddingHorizontal: screenWidth * 0.04,\n    },\n    dropdown: {\n      backgroundColor: Colors.screenColor,\n      position: 'absolute',\n      left: screenWidth * 0.55,\n      borderRadius: 20,\n      paddingVertical: 8,\n      width: screenWidth * 0.4,\n    },\n  });\n\n  const handleOptionSelect = (value: string) =\u003e {\n    setSelectedOption(value);\n\n    if (value === 'customTheme') {\n      dispatch(toggleTheme(theme === 'light' ? 'dark' : 'light'));\n    } else if (value === 'system') {\n      dispatch(toggleTheme('system'));\n    }\n  };\n  return (\n    \u003cView\n      style={\n        position: 'absolute',\n        top: screenHeight * 0.07,\n        right: screenWidth * 0.03,\n      }\u003e\n      \u003cSelectDropdown\n        data={data}\n        statusBarTranslucent\n        renderItem={(\n          selectedItem: DropDownData,\n          index: number,\n          isSelected: boolean,\n        ) =\u003e {\n          return (\n            \u003cView\n              style={\n                ...styles.dropDownItem,\n                borderBottomWidth: 1,\n                borderBottomColor: Colors.primary,\n              }\u003e\n              \u003cWText\n                style={\n                  paddingVertical: 13,\n                  paddingLeft: 5,\n                  fontSize: 18,\n                }\u003e\n                {selectedItem.label}\n              \u003c/WText\u003e\n            \u003c/View\u003e\n          );\n        }\n        dropdownOverlayColor=\"transparent\"\n        renderButton={() =\u003e {\n          return (\n            \u003cView\n              style={\n                alignItems: 'flex-end',\n                backgroundColor: Colors.lighterBlack,\n                borderRadius: 100,\n                padding: 5,\n              }\u003e\n              \u003cIonicons\n                name=\"ellipsis-vertical\"\n                color={Colors.primary}\n                size={30}\n              /\u003e\n            \u003c/View\u003e\n          );\n        }\n        onSelect={(selectedItem: DropDownData, index: number) =\u003e {\n          handleOptionSelect(selectedItem.value);\n        }\n        dropdownStyle={styles.dropdown}\n      /\u003e\n    \u003c/View\u003e\n  );\n};\n\nexport default DropDown;\n```\n\n위에 무슨 일이 발생했나요? \"CustomTheme\"을 선택했을 때, 현재 테마의 값을 확인한 후, 테마를 번갈아가며 변경합니다. 그러나 \"system\" 옵션을 선택하면 폰의 기본 테마를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시스템 기본 테마 사용하기\n\n마지막으로 시스템 테마를 사용하려면 useColorScheme 훅을 활용할 수 있습니다. 이 훅은 기기에서 현재 사용 중인 색상테마에 대한 업데이트를 제공합니다. colors.tsx 파일에서 getThemeColor 함수를 수정해봅시다.\n\n```js\nexport const getThemeColor = (theme: 'light' | 'dark' = 'light') =\u003e {\n  const systemTheme = useColorScheme() || 'light';\n  const userTheme = useSelector((state: RootState) =\u003e state.theme);\n  const {theme: storedTheme} = userTheme;\n  let themeMode;\n\n  if (storedTheme === 'system') {\n    const themeMode = themes[systemTheme];\n    return themeMode;\n  } else {\n    const themeMode = themes[theme];\n    return themeMode;\n  }\n};\n```\n\n아래의 코드를 사용하여 저장소에서 현재 테마 색상을 제공받아 원하는 동작을 구현하는데 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst userTheme = useSelector((state: RootState) =\u003e state.theme);\nconst {theme} = userTheme;\nconst Colors = getThemeColor(theme);\n```\n\n아래는 우리의 결과입니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1152/1*2zA_7xp0whnKUe5a5ts_aA.gif)","ogImage":{"url":"/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png"},"coverImage":"/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png","tag":["Tech"],"readingTime":14},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-ThemingWithReduxinReactNative_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e왜 Theming을 할까요?\u003c/p\u003e\n\u003cp\u003eTheming은 현대 앱의 주요 부분이 되어, 사용자 맞춤화 기능을 더욱 향상시킬 수 있게 해줍니다. 테마는 다양한 속성을 포함한 스타일을 설정하여, 다양한 사용자에게 다양한 방식으로 읽히게 합니다. 특히 편의성 측면에서 다르게 작용합니다. 요즘 유행하는 테마 모드는 주로 밝은 모드 또는 어두운 모드(어두운 모드가 가장 좋아요 :-))가 사용되고 있습니다. 일반적으로 사용자의 전화 시스템이 결정하도록 하는 세 번째 옵션이 존재하기도 합니다.\u003c/p\u003e\n\u003cp\u003eRedux로 Theming을 하는 이유는 무엇인가요?\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e리덕스는 사용자가 상태를 중앙에서 조직적으로 관리할 수 있도록 도와주는 상태 관리 라이브러리입니다. 리덕스는 애플리케이션 상태를 저장하는 저장소 역할을 하며, 사용자는 이 저장소로 읽기, 업데이트 또는 액션을 전달할 수 있습니다. 리액트 컨텍스트, 리액트 쿼리 등 다른 더 쉬운 옵션이 있지만, 사용자를 위해 상태 관리를 간단하게 만드는 목적으로 이 글을 리덕스로 작성했습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e리덕스는 현재 여러 프로젝트에서 사용 중인 매우 큰 커뮤니티 기반을 가지고 있습니다. 누군가에게 도움이 될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e개인적으로는 상태 관리 과정에서 어떤 일이 벌어지는지 더 잘 이해할 수 있다고 믿습니다.\u003c/li\u003e\n\u003cli\u003e누군가가 그것이 스트레스라고 말했으므로, 왜냐하면 나는 그렇게 결정했기 때문에요. :-))\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e우리가 이루고자 하는 목표\u003c/p\u003e\n\u003cp\u003e이 프로젝트를 작성하는 시점을 기준으로, React Native 버전인 0.72.7, TypeScript 버전인 4.8.4, Node 버전인 16.17.1, 그리고 NPM 버전인 8.15.0을 사용할 것입니다. 사용할 리덕스 패키지 버전은 다음과 같습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\"redux\": \"5.0.1\",\u003c/li\u003e\n\u003cli\u003e\"redux-logger\": \"3.0.6\",\u003c/li\u003e\n\u003cli\u003e\"redux-persist\": \"6.0.0\",\u003c/li\u003e\n\u003cli\u003e\"@react-native-async-storage/async-storage\": \"1.21.0\"\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 프로젝트를 진행하면서 몇 가지 목표를 이루고자 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작업 환경을 설치하고 설정하기.\u003c/li\u003e\n\u003cli\u003e서로 다른 테마에 대한 다양한 색상을 만들고 사용할 테마 색상 객체를 선택하는 함수를 작성하기.\u003c/li\u003e\n\u003cli\u003e액션과 리듀서 만들기.\u003c/li\u003e\n\u003cli\u003eRedux 스토어 만들기, Redux 로거, 퍼시스트, 그리고 Async Storage 설정하기. 이 패키지들이 어떤 역할을 하는지 앱에서 사용하면서 설명해 드리겠습니다.\u003c/li\u003e\n\u003cli\u003e리하이드레이션에 대해 설명하고 여기서 왜 필요한지 이야기하기.\u003c/li\u003e\n\u003cli\u003e이 컴포넌트 내에서 저장된 상태 사용하기.\u003c/li\u003e\n\u003cli\u003e마지막으로, 사용자가 시스템의 기본 테마를 사용할 수 있도록 하는 세 번째 옵션을 고려하기.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e전제 조건\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eJavascript, Typescript, React Native 및 Redux에 대한 지식이 있습니다.\u003c/li\u003e\n\u003cli\u003e위의 패키지가 설치되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e시작하기\u003c/p\u003e\n\u003cp\u003e패키지 설치\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// npm을 사용하여\u003c/span\u003e\nnpm i redux redux-logger redux-persist @react-native-\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e-storage/\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e-storage\n\u003cspan class=\"hljs-comment\"\u003e// yarn을 사용하여\u003c/span\u003e\nyarn add redux redux-logger redux-persist @react-native-\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e-storage/\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e-storage\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e색구성 만들기\u003c/p\u003e\n\u003cp\u003e누가 색상을 선택하는 데 머리 아픈 적이 없나요? src 폴더에 colors.tsx 파일을 생성하세요. 여기에는 light 및 dark 모드에 구조를 제공하는 유형을 만들었고, 이를 light 및 dark 키로 지정된 객체에 할당했습니다. 또한 테마에 따라 색구성을 반환하는 함수를 만들었습니다. 나중에 이 부분으로 돌아오겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e interface \u003cspan class=\"hljs-title class_\"\u003eColorProps\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003escreenColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003eprimary\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003eprimaryTextColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003elighterBlack\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003esecondaryTextColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003einActiveUnderlineTextInputColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003etertiaryTextColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003ewhiteColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003elightPrimaryColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003efavouriteButtonColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003eaddPhotoButtonColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003eratingIconColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003edisabledButtonColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003eonboardingInactiveIconColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003etabBarTextColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003etabColor\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003egradientColor\u003c/span\u003e: string;\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColorProps\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003escreenColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#E5E5E5'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eprimaryTextColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#000000'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003elighterBlack\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#FFFFFF'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003esecondaryTextColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#FFFFFF'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etertiaryTextColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#FFFFFF'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003egradientColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#61D2C4'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etabColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#FFFFFF'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eratingIconColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#FFCD00'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eprimary\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#2DDA93'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003edisabledButtonColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#AAAAAA'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eonboardingInactiveIconColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#DBDBDB'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003einActiveUnderlineTextInputColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#A7A7A7'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003elightPrimaryColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#61D2C4'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etabBarTextColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#D2D2D2'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ewhiteColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#FFFFFF'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003efavouriteButtonColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#FF6262'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eaddPhotoButtonColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#48A2F5'\u003c/span\u003e,\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDarkColors\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColorProps\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eprimaryTextColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#FFFFFF'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etertiaryTextColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#1E1E1E'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003esecondaryTextColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#F5F5F5'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003escreenColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#1B1C1E'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003elighterBlack\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#777777'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etabColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#FFFFFF'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eratingIconColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#FFCD00'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eprimary\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#2DDA93'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003edisabledButtonColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#AAAAAA'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003elightPrimaryColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#61D2C4'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003egradientColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#1B1C1E'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eonboardingInactiveIconColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#DBDBDB'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003einActiveUnderlineTextInputColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#A7A7A7'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etabBarTextColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#D2D2D2'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ewhiteColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#FFFFFF'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003efavouriteButtonColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#FF6262'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eaddPhotoButtonColor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#48A2F5'\u003c/span\u003e,\n};\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e themes = {\n  \u003cspan class=\"hljs-attr\"\u003elight\u003c/span\u003e: {...\u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e},\n  \u003cspan class=\"hljs-attr\"\u003edark\u003c/span\u003e: {...\u003cspan class=\"hljs-title class_\"\u003eDarkColors\u003c/span\u003e},\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetThemeColor\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\n  theme: \u003cspan class=\"hljs-string\"\u003e'light'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'dark'\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'light'\u003c/span\u003e,\n  useSystemTheme?: \u003cspan class=\"hljs-string\"\u003e'light'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'dark'\u003c/span\u003e,\n\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e themeMode = themes[theme];\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e themeMode;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e더 진행하기 전에, store, action 및 reducer는 무엇인가요? 간단히 살펴보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e어딘가에서 배운 상인의 비유를 사용해 보자. 좋은 걸로 알고 있어.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e가게를 운영하는 상인인 당신이라고 상상해보세요. 당신은 주문을 방문해야 팔 수 있는 국가를 파는 상점을 소유하고 있어요 (이곳에서는 이것이 유행이죠). 당신의 고객들은 직접 물건을 가져갈 수 없어요, 당신이 주어야죠 (리덕스 스토어).\u003c/li\u003e\n\u003cli\u003e이익을 내려면 고객이 있어야 해요 - 우리는 비즈니스를 운영하고 있거든요!! - 이 고객들은 상점에 있는 제품에 대해 요청하거나 주문을 넣어요 (하나의 액션). 이러한 주문/요청은 '타입'으로 분류되며, 기타 정보와 함께 액션 객체에 유지되어요.\u003c/li\u003e\n\u003cli\u003e이제 재고를 업데이트해야 해요 - 몇 개의 물건을 주고 나서 재고가 부족해요 - 그러나 당신이 따르는 특정 논리가 있어요. 여기에서 리듀서라는 개념이 등장해요. 리듀서는 현재 상태와 액션을 받아 들이는 순수한 액션 함수로, 액션 타입과 데이터에 기반하여 새로운 상태를 반환해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e우리의 리덕스 폴더 구조\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-ThemingWithReduxinReactNative_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e미리 정의된 유형과 초기 테마 상태를 정의해 봅시다 (이 기능은 더 큰 앱의 일부이므로 혼란스러워하지 않도록 이렇게 하고 있어요). 상태 매개변수에 초기 상태를 기본값으로 전달하는 것이 중요합니다. 이렇게 함으로써 상태가 정의되지 않은 경우 첫 번째로 리듀서를 호출할 때 처리할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eTOGGLE_STATUS\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Toggle'\u003c/span\u003e,\n};\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e type \u003cspan class=\"hljs-title class_\"\u003eThemeData\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003etheme\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'light'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'dark'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'system'\u003c/span\u003e;\n};\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003einitialState\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eThemeData\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003etheme\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'light'\u003c/span\u003e,\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 액션(고객)을 만들어 봅시다.\n먼저 액션 생성자부터 시작할게요 - 액션을 반환하는 함수(유형, 페이로드)를 반환하고, 페이로드를 새로운 테마로 설정하여 나중에 컴포넌트에서 디스패치할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etoggleTheme\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003enewTheme: string\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: types.\u003cspan class=\"hljs-property\"\u003eTOGGLE_STATUS\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 모든 액션은 유형을 가져야 합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003epayload\u003c/span\u003e: newTheme,\n  };\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저희 상태를 업데이트하기 위한 reducer를 생성 중입니다 (상점 주인님)\u003c/p\u003e\n\u003cp\u003e여기서 이전 상태를 가져오고 이를 이전 상태가 없는 경우 초기 상태로 설정하는데 사용합니다. 그런 다음 액션에서 전달된 테마 값을 새 상태로 반환합니다. 여기서 액션은 'type, payload'로 구조화되어 있습니다. 타입이 없는 경우에는 이전 상태를 기본 블록에 전달합니다. 이 동작은 새로운 테마 모드로 상태를 업데이트합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etoggleThemeReducer\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\n  state: ThemeData = initialState,\n  {type, payload}: {type: string; payload: any},\n\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (type) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e types.\u003cspan class=\"hljs-property\"\u003eTOGGLE_STATUS\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {...state, \u003cspan class=\"hljs-attr\"\u003etheme\u003c/span\u003e: payload};\n    \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e state;\n  }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e리덕스 스토어 설정 중입니다\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e와, 그것은 쉬운 부분이었네요. 이제 더 쉬운 부분으로 넘어가겠습니다. (다만 좀 더 신경 써야 할 수도 있어요 :-)).\u003c/p\u003e\n\u003cp\u003e우리는 예상되는 입력 상태에 타입을 지정하는 것부터 시작할 거에요. 이렇게 미리 정의된 타입을 TypeScript가 타입 추론을 도와줄 때 삶이 조금 더 쉬워지게 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e type \u003cspan class=\"hljs-title class_\"\u003eThemeState\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eReturnType\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e toggleThemeReducer\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음에는 우리의 toggleThemeReducer 주위에 래퍼 역할을 하는 루트 리듀서를 가지고 있어요. 그 루트 리듀서는 redux-persist를 사용할 때 지속 상태를 처리하는 데 도움을 줍니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erootReducer\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003estate: ThemeState | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e, action: any\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erehydratedState\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eThemeState\u003c/span\u003e | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003etoggleThemeReducer\u003c/span\u003e(state, action);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e rehydratedState;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 상태를 보존해야 합니다. 이렇게 하면 사용자가 애플리케이션을 다시 시작하거나 새로 고침하면 이전에 한 변경 사항을 볼 수 있습니다. 테마 상태를 앱 다시 시작이나 새로 고침을 통해 다시 살리기 위해 상태를 보존하고 살립니다. 먼저 리듀서를 보존할 설정 객체(코드 상단에 좋습니다)를 만들고, 이 값을 persistReducer에 전달해야 합니다. 지속성 구성 객체는 redux-persist가 저장 솔루션으로 AsyncStorage를 사용하도록 구성하고 '테마' 상태만을 지속해야 한다고 지정합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e persistConfig = {\n  \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003estorage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAsyncStorage\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ewhitelist\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'theme'\u003c/span\u003e],\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e persistedReducer = \u003cspan class=\"hljs-title function_\"\u003epersistReducer\u003c/span\u003e(persistConfig, rootReducer);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 저장소를 설정하고 이 저장소를 지속해야 합니다. 지속된 리듀서를 사용하여 저장소를 생성하면 테마 상태를 지속하고 다시 살립니다. 지속된 저장소(persistor)는 persistStore와 Redux 저장소를 사용하여 만듭니다. 이 persistor는 필요할 때 상태를 수동으로 보존하고 다시 살릴 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e상태 = \u003cspan class=\"hljs-title function_\"\u003ecreateStore\u003c/span\u003e(\n= 지속\u003cspan class=\"hljs-title class_\"\u003eReducer\u003c/span\u003e,\n= \u003cspan class=\"hljs-title function_\"\u003eapplyMiddleware\u003c/span\u003e(...middlewares),\n);\n= 지속 = \u003cspan class=\"hljs-title function_\"\u003epersistStore\u003c/span\u003e(모임);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRedux-logger\u003c/p\u003e\n\u003cp\u003e이것은 Redux 스토어를 사용할 때 우리를 돕는 미들웨어입니다. 우리는 reduxlogger를 사용하는 middleware라는 배열을 만듭니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ereduxlogger = \u003cspan class=\"hljs-title function_\"\u003ecreateLogger\u003c/span\u003e({});\nmiddleware = [reduxlogger];\n\n상태 = \u003cspan class=\"hljs-title function_\"\u003ecreateStore\u003c/span\u003e(\n= 지속\u003cspan class=\"hljs-title class_\"\u003eReducer\u003c/span\u003e,\n= \u003cspan class=\"hljs-title function_\"\u003eapplyMiddleware\u003c/span\u003e(...middleware),\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eRedux Logger: 이것은 모든 Redux 액션과 상태 변경을 콘솔에 로그로 남기는 개발 도구입니다. 이는 디버깅 목적으로 매우 유용한데, 액션의 흐름을 추적하고 그에 따라 상태가 어떻게 업데이트되는지 확인할 수 있기 때문입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e재수행(Rehydration)\u003c/p\u003e\n\u003cp\u003e이제, 우리는 리듀서를 수정하여 우리가 재수행할 때의 시나리오에 유의해야 합니다. 하지만 먼저, 재수행이 무엇인지 살펴보겠습니다. 우리 로거에서 가져온 앱의 로그를 살펴보면, 재시작했다는 것을 알 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"light\"\u003c/span\u003e}\n\u003cspan class=\"hljs-variable constant_\"\u003eGROUP\u003c/span\u003e  action persist/\u003cspan class=\"hljs-variable constant_\"\u003ePERSIST\u003c/span\u003e @ \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e46.681\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eLOG\u003c/span\u003e    prev state {\u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"light\"\u003c/span\u003e}\n\u003cspan class=\"hljs-variable constant_\"\u003eLOG\u003c/span\u003e    action     {\u003cspan class=\"hljs-string\"\u003e\"register\"\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eFunction\u003c/span\u003e register], \u003cspan class=\"hljs-string\"\u003e\"rehydrate\"\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eFunction\u003c/span\u003e rehydrate], \u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"persist/PERSIST\"\u003c/span\u003e}\n\u003cspan class=\"hljs-variable constant_\"\u003eLOG\u003c/span\u003e    next state {\u003cspan class=\"hljs-string\"\u003e\"_persist\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"rehydrated\"\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"version\"\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}, \u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"light\"\u003c/span\u003e}\n\u003cspan class=\"hljs-variable constant_\"\u003eLOG\u003c/span\u003e    {\u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"light\"\u003c/span\u003e} 재수행상태 \n\u003cspan class=\"hljs-variable constant_\"\u003eLOG\u003c/span\u003e    {\u003cspan class=\"hljs-string\"\u003e\"_persist\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"rehydrated\"\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"version\"\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}, \u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"dark\"\u003c/span\u003e} 페이로드 {\u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"light\"\u003c/span\u003e} 상태\n\u003cspan class=\"hljs-variable constant_\"\u003eGROUP\u003c/span\u003e  action persist/\u003cspan class=\"hljs-variable constant_\"\u003eREHYDRATE\u003c/span\u003e @ \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e46.923\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eLOG\u003c/span\u003e    prev state {\u003cspan class=\"hljs-string\"\u003e\"_persist\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"rehydrated\"\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"version\"\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}, \u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"light\"\u003c/span\u003e}\n\u003cspan class=\"hljs-variable constant_\"\u003eLOG\u003c/span\u003e    action     {\u003cspan class=\"hljs-string\"\u003e\"err\"\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"key\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"root\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"payload\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"_persist\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"rehydrated\"\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"version\"\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}, \u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"dark\"\u003c/span\u003e}, \u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"persist/REHYDRATE\"\u003c/span\u003e}\n\u003cspan class=\"hljs-variable constant_\"\u003eLOG\u003c/span\u003e    next state {\u003cspan class=\"hljs-string\"\u003e\"_persist\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"rehydrated\"\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"version\"\u003c/span\u003e: -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}, \u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"theme\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"dark\"\u003c/span\u003e}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기에서 무슨 일이 일어나고 있는 거죠?\u003c/p\u003e\n\u003cp\u003e앱이 다시 시작될 때, redux-persist가 먼저 현재 상태인 \u003ccode\u003elight\u003c/code\u003e를 AsyncStorage에 \u003ccode\u003epersist/PERSIST\u003c/code\u003e 액션을 사용하여 영속화합니다. 그런 다음, 이전에 \u003ccode\u003edark\u003c/code\u003e로 설정되었던 영속 상태를 AsyncStorage에서 가져와 Redux 스토어에 \u003ccode\u003epersist/REHYDRATE\u003c/code\u003e 액션을 사용하여 재수확합니다.\u003c/p\u003e\n\u003cp\u003e이것이 스토어에 대한 완전한 코드입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e persistConfig = {\n  \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003estorage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAsyncStorage\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ewhitelist\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'theme'\u003c/span\u003e],\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erootReducer\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003estate: ThemeState | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e, action: any\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erehydratedState\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eThemeState\u003c/span\u003e | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003etoggleThemeReducer\u003c/span\u003e(state, action);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e rehydratedState;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e persistedReducer = \u003cspan class=\"hljs-title function_\"\u003epersistReducer\u003c/span\u003e(persistConfig, rootReducer);\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e store = \u003cspan class=\"hljs-title function_\"\u003ecreateStore\u003c/span\u003e(\n  persistedReducer,\n  \u003cspan class=\"hljs-title function_\"\u003eapplyMiddleware\u003c/span\u003e(...middlewares),\n);\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e persistor = \u003cspan class=\"hljs-title function_\"\u003epersistStore\u003c/span\u003e(store);\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e type \u003cspan class=\"hljs-title class_\"\u003eRootState\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eReturnType\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e rootReducer\u003e; \u003cspan class=\"hljs-comment\"\u003e// 사전 정의된 이 유형 추론을 돕기 위한 것.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리 컴포넌트와 함께 이들 저장된 상태를 사용합니다.\u003c/p\u003e\n\u003cp\u003e이 시연에서는 앱 내에서 테마 모드를 전환하는 데 도움이 되는 테마 버튼이 포함된 드롭다운을 가지고 있을 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e인터페이스 \u003cspan class=\"hljs-title class_\"\u003eDropDownData\u003c/span\u003e {\n  라벨: 문자열;\n  값: 문자열;\n}\n인터페이스 \u003cspan class=\"hljs-title class_\"\u003eDropDownProps\u003c/span\u003e {\n  색상?: 문자열;\n}\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eDropDown\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eprops?: DropDownProps\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e navigation = useNavigation\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eRootStackNavigationProp\u003c/span\u003e\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [selectedOption, setSelectedOption] = useState\u0026#x3C;string\u003e(\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDropDownData\u003c/span\u003e[] = [\n    {\u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'테마'\u003c/span\u003e, 값: \u003cspan class=\"hljs-string\"\u003e'theme'\u003c/span\u003e},\n  ];\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dispatch = \u003cspan class=\"hljs-title function_\"\u003euseDispatch\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userTheme = \u003cspan class=\"hljs-title function_\"\u003euseSelector\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003estate: RootState\u003c/span\u003e) =\u003e\u003c/span\u003e state.\u003cspan class=\"hljs-property\"\u003etheme\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {theme} = userTheme;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003egetThemeColor\u003c/span\u003e(theme);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e styles = \u003cspan class=\"hljs-title class_\"\u003eStyleSheet\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003edropDownItem\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003epaddingHorizontal\u003c/span\u003e: screenWidth * \u003cspan class=\"hljs-number\"\u003e0.04\u003c/span\u003e,\n    },\n    \u003cspan class=\"hljs-attr\"\u003edropdown\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003ebackgroundColor\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003escreenColor\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eposition\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'absolute'\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eleft\u003c/span\u003e: screenWidth * \u003cspan class=\"hljs-number\"\u003e0.55\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eborderRadius\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003epaddingVertical\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e: screenWidth * \u003cspan class=\"hljs-number\"\u003e0.4\u003c/span\u003e,\n    },\n  });\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleOptionSelect\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003evalue: string\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetSelectedOption\u003c/span\u003e(value);\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (value === \u003cspan class=\"hljs-string\"\u003e'customTheme'\u003c/span\u003e) {\n      \u003cspan class=\"hljs-title function_\"\u003edispatch\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003etoggleTheme\u003c/span\u003e(theme === \u003cspan class=\"hljs-string\"\u003e'light'\u003c/span\u003e ? \u003cspan class=\"hljs-string\"\u003e'dark'\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e'light'\u003c/span\u003e));\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (value === \u003cspan class=\"hljs-string\"\u003e'system'\u003c/span\u003e) {\n      \u003cspan class=\"hljs-title function_\"\u003edispatch\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003etoggleTheme\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'system'\u003c/span\u003e));\n    }\n  };\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eposition:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003eabsolute\u003c/span\u003e',\n        \u003cspan class=\"hljs-attr\"\u003etop:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003escreenHeight\u003c/span\u003e * \u003cspan class=\"hljs-attr\"\u003e0.07\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eright:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003escreenWidth\u003c/span\u003e * \u003cspan class=\"hljs-attr\"\u003e0.03\u003c/span\u003e,\n      }\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eSelectDropdown\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{data}\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003estatusBarTranslucent\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erenderItem\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{(\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eselectedItem:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eDropDownData\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003eindex:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enumber\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003eisSelected:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eboolean\u003c/span\u003e,\n        ) =\u003e\u003c/span\u003e {\n          return (\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003e...styles.dropDownItem\u003c/span\u003e,\n                \u003cspan class=\"hljs-attr\"\u003eborderBottomWidth:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e1\u003c/span\u003e,\n                \u003cspan class=\"hljs-attr\"\u003eborderBottomColor:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eColors.primary\u003c/span\u003e,\n              }\u003e\u003c/span\u003e\n              \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eWText\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n                  \u003cspan class=\"hljs-attr\"\u003epaddingVertical:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e13\u003c/span\u003e,\n                  \u003cspan class=\"hljs-attr\"\u003epaddingLeft:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e5\u003c/span\u003e,\n                  \u003cspan class=\"hljs-attr\"\u003efontSize:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e18\u003c/span\u003e,\n                }\u003e\u003c/span\u003e\n                {selectedItem.label}\n              \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eWText\u003c/span\u003e\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\n          );\n        }\n        dropdownOverlayColor=\"transparent\"\n        renderButton={() =\u003e {\n          return (\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003ealignItems:\u003c/span\u003e '\u003cspan class=\"hljs-attr\"\u003eflex-end\u003c/span\u003e',\n                \u003cspan class=\"hljs-attr\"\u003ebackgroundColor:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eColors.lighterBlack\u003c/span\u003e,\n                \u003cspan class=\"hljs-attr\"\u003eborderRadius:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e100\u003c/span\u003e,\n                \u003cspan class=\"hljs-attr\"\u003epadding:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e5\u003c/span\u003e,\n              }\u003e\u003c/span\u003e\n              \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eIonicons\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"ellipsis-vertical\"\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{Colors.primary}\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003esize\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{30}\u003c/span\u003e\n              /\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\n          );\n        }\n        onSelect={(selectedItem: DropDownData, index: number) =\u003e {\n          handleOptionSelect(selectedItem.value);\n        }\n        dropdownStyle={styles.dropdown}\n      /\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDropDown\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위에 무슨 일이 발생했나요? \"CustomTheme\"을 선택했을 때, 현재 테마의 값을 확인한 후, 테마를 번갈아가며 변경합니다. 그러나 \"system\" 옵션을 선택하면 폰의 기본 테마를 사용합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e시스템 기본 테마 사용하기\u003c/p\u003e\n\u003cp\u003e마지막으로 시스템 테마를 사용하려면 useColorScheme 훅을 활용할 수 있습니다. 이 훅은 기기에서 현재 사용 중인 색상테마에 대한 업데이트를 제공합니다. colors.tsx 파일에서 getThemeColor 함수를 수정해봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetThemeColor\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003etheme: \u003cspan class=\"hljs-string\"\u003e'light'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'dark'\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'light'\u003c/span\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e systemTheme = \u003cspan class=\"hljs-title function_\"\u003euseColorScheme\u003c/span\u003e() || \u003cspan class=\"hljs-string\"\u003e'light'\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userTheme = \u003cspan class=\"hljs-title function_\"\u003euseSelector\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003estate: RootState\u003c/span\u003e) =\u003e\u003c/span\u003e state.\u003cspan class=\"hljs-property\"\u003etheme\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {\u003cspan class=\"hljs-attr\"\u003etheme\u003c/span\u003e: storedTheme} = userTheme;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e themeMode;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (storedTheme === \u003cspan class=\"hljs-string\"\u003e'system'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e themeMode = themes[systemTheme];\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e themeMode;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e themeMode = themes[theme];\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e themeMode;\n  }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래의 코드를 사용하여 저장소에서 현재 테마 색상을 제공받아 원하는 동작을 구현하는데 사용할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userTheme = \u003cspan class=\"hljs-title function_\"\u003euseSelector\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003estate: RootState\u003c/span\u003e) =\u003e\u003c/span\u003e state.\u003cspan class=\"hljs-property\"\u003etheme\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e {theme} = userTheme;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eColors\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003egetThemeColor\u003c/span\u003e(theme);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래는 우리의 결과입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1152/1*2zA_7xp0whnKUe5a5ts_aA.gif\" alt=\"image\"\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-ThemingWithReduxinReactNative"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>