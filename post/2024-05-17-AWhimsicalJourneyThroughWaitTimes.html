<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>대기 시간을 통해의 신비로운 여행 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-17-AWhimsicalJourneyThroughWaitTimes" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="대기 시간을 통해의 신비로운 여행 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="대기 시간을 통해의 신비로운 여행 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-17-AWhimsicalJourneyThroughWaitTimes" data-gatsby-head="true"/><meta name="twitter:title" content="대기 시간을 통해의 신비로운 여행 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 20:39" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">대기 시간을 통해의 신비로운 여행</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="대기 시간을 통해의 신비로운 여행" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">20<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-AWhimsicalJourneyThroughWaitTimes&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>파이썬을 사용하여 전자레인지 카운트다운부터 끝나지 않는 전화 대기 시간까지</h2>
<p><img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_0.png" alt="image"></p>
<p>전자레인지 오븐의 카운트다운이 빠르게 0으로 수렴하는 것을 본 적이 있나요? 반면 전화 대기시간은 영원처럼 늘어날까요?</p>
<p>한가지 생각해 보세요. 포플콘을 전자레인지에 넣어 가열한 지 겨우 1분 지난 때에는 그릇을 준비하고 서빙할 준비를 합니다. 하지만 전화 대기 중에 1분이 지난다면? 다시 사람과 대화를 나눌 수 있을지 의문이 들 정도입니다. 10분 후, 포플콘을 즐기는 중이겠죠. 하지만 전화는? 대기 음악이 끝도 없는 연옥의 배경음악이 되고 있습니다.</p>
<div class="content-ad"></div>
<p>그리고 팝콘을 기다리는 사이와 전화 대기를 이어가는 서사 속을 맴도는 … 주간 복권. 승리를 기다립니다. 매주 새로운 티켓은 이전 주의 실망과는 거리가 먼 신선한 약속을 간직하고 있습니다.</p>
<p>요약하자면, 세 가지 다른 종류의 대기가 나타납니다:</p>
<ul>
<li>“대기 전화”형 — 기다린 시간이 오래 될수록 더 오랫동안 기다릴 것으로 기대합니다.</li>
<li>“팝콘”형 — 기다린 시간이 길어질수록 더 짧게 기다릴 것으로 기대합니다.</li>
<li>“복권 당첨”형 — 지금까지 기다린 것과 관계없이 예상 대기 시간은 변하지 않습니다.</li>
</ul>
<p>이 대기 시간의 차이는 실제로 존재하는 것일까요, 아니면 마음의 장난일까요? 이 질문에 대한 대답은 두 부분으로 나누어 알아보겠습니다.</p>
<div class="content-ad"></div>
<ul>
<li>부분 1 — 데이터 분석</li>
<li>부분 2 — 데이터 모델링</li>
</ul>
<p>각 부분에서 대기 시간 유형을 각각 살펴보겠습니다. 자세한 Python 코드와 설명이 번갈아 나옵니다. Python에 관심이 있다면 코드 부분을 읽어보세요. 대기 시간에 대해 배우고 싶다면 코드를 건너뛰어도 됩니다.</p>
<h1>"대기 중" 유형 대기 시간 — 기다린 시간이 길수록 더 오래 기다리게 됩니다.</h1>
<p>데이터로 시작하고 싶지만 "대기 중" 시간에 대한 데이터가 없습니다. 대신 컴퓨터 파일의 편집 사이의 시간에 대해서 어떠세요? 그런 편집 시간을 보는 곳 한 곳이 바로 위키피디아입니다.</p>
<div class="content-ad"></div>
<p>위키피디아 페이지에서 마지막 편집 이후의 시간을 보고 다음 편집까지 얼마나 남았는지 예측할 수 있을까요?</p>
<p>위키피디아 페이지 편집에 대한 다음 편집까지의 시간을 어떻게 예측할 수 있을까요? 다음 편집이 언제 발생할지 정확히 예측해 보세요: "저는 이 페이지가 정확히 5일 3시간 20분 후에 편집될 것으로 예측합니다." 하지만 그렇게 구체적으로 예측하는 것은 너무 정확성이 떨어질 것입니다.</p>
<p>시간 범위를 예측할 수도 있습니다: "저는 이 페이지가 다음 100년 이내에 언제든지 편집될 것으로 예측합니다." 이렇게 하면 거의 항상 맞을 수 있겠지만, 너무 모호하고 흥미롭지 않습니다.</p>
<p>더 실용적인 예측은 "중위 다음 편집 시간"의 형태입니다. 이렇게 말할 수 있습니다: "저는 이 페이지가 다음 5일 3시간 20분 이내에 50% 확률로 편집될 것으로 예측합니다." 저, 당신의 적,는 "이전" 또는 "이후"를 선택할 것입니다. 만약 실제 중위 다음 편집 시간이 3일이라고 가정하면, "이전"을 선택할 것입니다. 그럼 우리는 최대 5일 3시간 20분까지 기다립니다. 그 동안 누군가(다시 말해서, 우리 둘을 제외한 누군가) 페이지를 편집하면 상대방이 점수를 획들하고, 그렇지 않으면 당신이 점수를 획득합니다. 이러한 점수 체계를 통해, 만약 제가 당신보다 더 좋은 예측자라면 더 많은 점수를 획득해야 할 것입니다.</p>
<div class="content-ad"></div>
<p>파이썬에 대해 알아보고 이러한 예측을 어떻게 할 수 있는지 살펴봅시다:</p>
<h2>“대기 중” 유형의 대기 시간 — Python</h2>
<p>아티스트 Marie Cochran에 관한 위키피디아 문서를 살펴보겠습니다. 문서의 개정 내역을 살펴볼 수 있습니다:</p>
<p><img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_1.png" alt="image"></p>
<div class="content-ad"></div>
<p>다양한 위키피디아 문서에서 데이터를 수집하기 위해 작은 파이썬 스크립트를 작성했어요. 다음과 같은 작업을 합니다:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Special:Random%EC%9D%84" rel="nofollow" target="_blank">https://en.wikipedia.org/wiki/Special:Random을</a> 통해 랜덤한 영어 위키백과 페이지를 선택합니다.</li>
<li>해당 페이지의 편집 이력으로 이동합니다. 예를 들어, <a href="https://en.wikipedia.org/w/index.php?title=Marie_Cochran&#x26;action=history" rel="nofollow" target="_blank">https://en.wikipedia.org/w/index.php?title=Marie_Cochran&#x26;action=history</a>.</li>
<li>(최대) 최근 50회 편집의 날짜와 시간을 추출합니다. 시간은 분 단위로 표시됩니다.</li>
<li>문서 제목, 수정 시간, 스크립트 실행 시간으로 구성된 줄을 생성합니다. 모든 시간은 UTC 시간대를 사용합니다. 탭으로 열을 구분합니다.</li>
<li>줄을 파일에 추가합니다.</li>
</ul>
<p>편집 시간 데이터 일부를 보여드리겠습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Marie</span>_Cochran <span class="hljs-number">01</span>:<span class="hljs-number">20</span>, <span class="hljs-number">8</span> <span class="hljs-title class_">January</span> <span class="hljs-number">2024</span> <span class="hljs-number">01</span>:<span class="hljs-number">16</span>, <span class="hljs-number">08</span> <span class="hljs-title class_">February</span> <span class="hljs-number">2024</span>
<span class="hljs-title class_">Marie</span>_Cochran <span class="hljs-number">01</span>:<span class="hljs-number">10</span>, <span class="hljs-number">27</span> <span class="hljs-title class_">September</span> <span class="hljs-number">2023</span> <span class="hljs-number">01</span>:<span class="hljs-number">16</span>, <span class="hljs-number">08</span> <span class="hljs-title class_">February</span> <span class="hljs-number">2024</span>
<span class="hljs-title class_">Marie</span>_Cochran <span class="hljs-number">00</span>:<span class="hljs-number">59</span>, <span class="hljs-number">12</span> <span class="hljs-title class_">September</span> <span class="hljs-number">2023</span> <span class="hljs-number">01</span>:<span class="hljs-number">16</span>, <span class="hljs-number">08</span> <span class="hljs-title class_">February</span> <span class="hljs-number">2024</span>
<span class="hljs-title class_">Marie</span>_Cochran <span class="hljs-number">11</span>:<span class="hljs-number">43</span>, <span class="hljs-number">2</span> <span class="hljs-title class_">November</span> <span class="hljs-number">2022</span> <span class="hljs-number">01</span>:<span class="hljs-number">16</span>, <span class="hljs-number">08</span> <span class="hljs-title class_">February</span> <span class="hljs-number">2024</span>
...
<span class="hljs-title class_">Marie</span>_Cochran <span class="hljs-number">19</span>:<span class="hljs-number">20</span>, <span class="hljs-number">10</span> <span class="hljs-title class_">March</span> <span class="hljs-number">2018</span> <span class="hljs-number">01</span>:<span class="hljs-number">16</span>, <span class="hljs-number">08</span> <span class="hljs-title class_">February</span> <span class="hljs-number">2024</span>
<span class="hljs-title class_">Peter</span>_Tennant <span class="hljs-number">15</span>:<span class="hljs-number">03</span>, <span class="hljs-number">29</span> <span class="hljs-title class_">July</span> <span class="hljs-number">2023</span> <span class="hljs-number">01</span>:<span class="hljs-number">16</span>, <span class="hljs-number">08</span> <span class="hljs-title class_">February</span> <span class="hljs-number">2024</span>
<span class="hljs-title class_">Peter</span>_Tennant <span class="hljs-number">21</span>:<span class="hljs-number">39</span>, <span class="hljs-number">15</span> <span class="hljs-title class_">April</span> <span class="hljs-number">2022</span> <span class="hljs-number">01</span>:<span class="hljs-number">16</span>, <span class="hljs-number">08</span> <span class="hljs-title class_">February</span> <span class="hljs-number">2024</span>
...
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

<span class="hljs-comment"># 데이터 읽기</span>
wiki_df = pd.read_csv(<span class="hljs-string">"edit_history.txt"</span>, sep=<span class="hljs-string">'\t'</span>, header=<span class="hljs-literal">None</span>, names=[<span class="hljs-string">"Title"</span>, <span class="hljs-string">"Edit DateTime"</span>, <span class="hljs-string">"Probe DateTime"</span>], usecols=[<span class="hljs-string">"Title"</span>, <span class="hljs-string">"Edit DateTime"</span>])
wiki_df[<span class="hljs-string">'Edit DateTime'</span>] = pd.to_datetime(wiki_df[<span class="hljs-string">'Edit DateTime'</span>]) <span class="hljs-comment"># 텍스트를 날짜 및 시간으로 변환</span>

<span class="hljs-comment"># 'Title' 및 'Edit DateTime'을 기준으로 DataFrame 정렬하여 시간 간격이 올바르게 계산되도록 함</span>
wiki_df.sort_values(by=[<span class="hljs-string">'Title'</span>, <span class="hljs-string">'Edit DateTime'</span>], inplace=<span class="hljs-literal">True</span>)

<span class="hljs-comment"># 동일한 제목 내에서 연속해서 편집한 경우의 시간 간격 계산</span>
wiki_df[<span class="hljs-string">'Time Delta'</span>] = wiki_df.groupby(<span class="hljs-string">'Title'</span>)[<span class="hljs-string">'Edit DateTime'</span>].diff()
wiki_df.head()
</code></pre>
<p>결과로 나온 Pandas 데이터프레임은 샘플된 기사 중 알파벳상으로 가장 빠른 기사(제목 기준)로 시작합니다. 이 기사는 몽골 출신인 매우 키가 큰 사람 인 Öndör Gongor에 대해 독자들에게 알려줍니다:</p>
<p><img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_2.png" alt="image"></p>
<div class="content-ad"></div>
<p>해당 기사의 마지막 50개의 편집 중 첫 번째 편집은 2008년 1월 27일 오후 3시 13분 (UTC)에 이루어졌습니다. 다음 편집은 16분 후에 이루어졌습니다. 그 다음 편집은 데이터의 해상도 한계로 인해 1분 내로 발생하여 0일 00:00:00으로 표시됩니다.</p>
<p>계속 처리하면, 각 기사 맨 처음에 나타나는 NaT (not-a-time) 행을 제거해 보겠습니다. 또한 대기 시간에 따라 정렬하고 판다의 인덱스를 재설정할 것입니다:</p>
<pre><code class="hljs language-js"># <span class="hljs-string">'Time Delta'</span> 열에서 <span class="hljs-title class_">NaT</span>(시간이 아님) 값이 포함된 행 제거
wiki_df.<span class="hljs-title function_">dropna</span>(subset=[<span class="hljs-string">'Time Delta'</span>], inplace=<span class="hljs-title class_">True</span>)
# 시간 간격으로 정렬 및 인덱스 재설정
wiki_df.<span class="hljs-title function_">sort_values</span>(by=<span class="hljs-string">'Time Delta'</span>, inplace=<span class="hljs-title class_">True</span>)
wiki_df.<span class="hljs-title function_">reset_index</span>(drop=<span class="hljs-title class_">True</span>, inplace=<span class="hljs-title class_">True</span>)
<span class="hljs-title function_">display</span>(wiki_df)
wiki_df[<span class="hljs-string">'Time Delta'</span>].<span class="hljs-title function_">describe</span>()
</code></pre>
<p>이를 통해 다음과 같이 시작하고 끝나는 데이터프레임이 생성됩니다:</p>
<div class="content-ad"></div>
<p>아래는 통계 요약입니다.</p>
<pre><code class="hljs language-js">count                          <span class="hljs-number">36320</span>
mean      <span class="hljs-number">92</span> days <span class="hljs-number">13</span>:<span class="hljs-number">46</span>:<span class="hljs-number">11.116189427</span>
std      <span class="hljs-number">195</span> days <span class="hljs-number">11</span>:<span class="hljs-number">36</span>:<span class="hljs-number">52.016155110</span>
min                  <span class="hljs-number">0</span> days <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>
<span class="hljs-number">25</span>%                  <span class="hljs-number">0</span> days <span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">00</span>
<span class="hljs-number">50</span>%                 <span class="hljs-number">15</span> days <span class="hljs-number">05</span>:<span class="hljs-number">41</span>:<span class="hljs-number">00</span>
<span class="hljs-number">75</span>%                <span class="hljs-number">100</span> days <span class="hljs-number">21</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45</span>
max               <span class="hljs-number">4810</span> days <span class="hljs-number">17</span>:<span class="hljs-number">39</span>:<span class="hljs-number">00</span>
</code></pre>
<p>조사 결과, 샘플링된 대기 시간은 0일 00:00:00(즉, 1분 미만)부터 13년 이상까지 다양합니다. (13년 편집 대기는 버지니아 대학교의 건물에 관한 기사였습니다.) 편집의 1/4은 이전 편집 후 27분 이내에 발생합니다. 편집 간 중위값은 약 15일을 조금 넘습니다.</p>
<div class="content-ad"></div>
<p>조금 더 발전하기 전에, 웨이팅 시간을 향상시키고 싶은데요. 다음과 같이 작은 함수를 사용해서 웨이팅 시간을 표시할 수 있습니다:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">seconds_to_text</span>(seconds):
    seconds = <span class="hljs-title function_">round</span>(seconds)
    result = []
    <span class="hljs-keyword">for</span> unit_name, unit_seconds <span class="hljs-keyword">in</span> [(<span class="hljs-string">'y'</span>, <span class="hljs-number">86400</span> * <span class="hljs-number">365.25</span>),(<span class="hljs-string">'d'</span>, <span class="hljs-number">86400</span>),(<span class="hljs-string">'h'</span>, <span class="hljs-number">3600</span>),(<span class="hljs-string">'m'</span>, <span class="hljs-number">60</span>),(<span class="hljs-string">'s'</span>, <span class="hljs-number">1</span>)]:
        <span class="hljs-keyword">if</span> seconds >= <span class="hljs-attr">unit_seconds</span>:
            unit_value, seconds = <span class="hljs-title function_">divmod</span>(seconds, unit_seconds)
            result.<span class="hljs-title function_">append</span>(f<span class="hljs-string">"{int(unit_value)}{unit_name}"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>.<span class="hljs-title function_">join</span>(result) <span class="hljs-keyword">if</span> result <span class="hljs-keyword">else</span> <span class="hljs-string">"&#x3C;1s"</span>

<span class="hljs-title function_">seconds_to_text</span>(<span class="hljs-number">100</span>)
</code></pre>
<p>위의 <code>seconds_to_text</code> 함수는 100초를 <code>1m 40s</code>로 표시합니다.</p>
<p>이제 위키피디아 데이터를 위한 "웨이팅 테이블"을 만들 수 있습니다. 기존에 기사의 다음 편집을 기다린 시간을 주면, 이 테이블은 중간 추가로 기다려야 할 시간을 알려줍니다. ("중간값"은 이 시간보다 덜 기다릴 확률이 50%이고, 시간이 더 걸리는 확률이 50%라는 것을 의미합니다.)</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

def <span class="hljs-title function_">wait_wait_table</span>(df, wait_ticks):
    sorted_time_deltas_seconds = df[<span class="hljs-string">'Time Delta'</span>].<span class="hljs-property">dt</span>.<span class="hljs-title function_">total_seconds</span>()
    results = []
    <span class="hljs-keyword">for</span> wait_tick <span class="hljs-keyword">in</span> <span class="hljs-attr">wait_ticks</span>:
        greater_or_equal_values = sorted_time_deltas_seconds[sorted_time_deltas_seconds >= wait_tick]
        median_wait = np.<span class="hljs-title function_">median</span>(greater_or_equal_values)
        additional_wait = median_wait - wait_tick
        results.<span class="hljs-title function_">append</span>({<span class="hljs-string">"Wait So Far"</span>: <span class="hljs-title function_">seconds_to_text</span>(wait_tick), <span class="hljs-string">"Median Additional Wait"</span>: <span class="hljs-title function_">seconds_to_text</span>(additional_wait)})
    <span class="hljs-keyword">return</span> pd.<span class="hljs-title class_">DataFrame</span>(results)

wiki_wait_ticks = [<span class="hljs-number">0</span>, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>*<span class="hljs-number">5</span>, <span class="hljs-number">60</span>*<span class="hljs-number">15</span>, <span class="hljs-number">3600</span>, <span class="hljs-number">3600</span>*<span class="hljs-number">4</span>, <span class="hljs-number">86400</span>, <span class="hljs-number">86400</span> * <span class="hljs-number">7</span>,<span class="hljs-number">86400</span> * <span class="hljs-number">30</span>, <span class="hljs-number">86400</span> * <span class="hljs-number">100</span>, <span class="hljs-number">86400</span> * <span class="hljs-number">365.25</span>, <span class="hljs-number">86400</span> * <span class="hljs-number">365.25</span> * <span class="hljs-number">5</span>, <span class="hljs-number">86400</span> * <span class="hljs-number">365.25</span> * <span class="hljs-number">10</span>]
wiki_wait_tick_labels = [<span class="hljs-title function_">seconds_to_text</span>(wait_tick) <span class="hljs-keyword">for</span> wait_tick <span class="hljs-keyword">in</span> wiki_wait_ticks]
<span class="hljs-title function_">wait_wait_table</span>(wiki_df, wiki_wait_ticks).<span class="hljs-property">style</span>.<span class="hljs-title function_">hide</span>(axis=<span class="hljs-string">"index"</span>)
</code></pre>
<p>이제 이 표의 출력에 대해 알아보겠습니다.</p>
<h2>"대기 중" 유형의 대기 - 토론</h2>
<p>앞의 파이썬 코드는 이 표를 생성합니다. 이것을 "대기-대기" 표라고 부르죠.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_4.png" alt="image"></p>
<p>만약 아무도 기다리지 않았다면(다시 말해, 누군가가 페이지를 편집했다) 다음 편집은 15일이 넘게 기다릴 것으로 예상됩니다. 그러나 1분 후에도 누군가 기사를 편집하지 않았다면, 19일을 기다려야 할 것으로 예상됩니다. 따라서 1분 기다리면 예상 추가 대기 시간이 거의 4일 더 늘어납니다. 한 시간 후에도 누구도 기사를 편집하지 않았다면, 예상 추가 대기 시간은 47일로 두 배 넘게 늘어납니다.</p>
<p>이 현상을 생각하는 한 가지 방법은 다음 편집을 기다리기 시작할 때 우리가 어떤 종류의 페이지에 있는지 모르는 것입니다. 이것이 테일러 스위프트와 같은 핫 팝컬쳐 주제의 기사인가요? 아니면 5000명 대학의 건물인 '로턴다(The Rotunda)'와 같은 니치하고 느린 주제인가요? 수정이 일어나지 않는 매 분이 지날수록, 확률은 이것이 테일러 스위프트와 같은 기사에서 '로턴다(The Rotunda)'와 같은 기사로 이동합니다.</p>
<p>마찬가지로, 고객 서비스에 전화하고 대기시간이 발생할 때 - 처음에는 어떤 종류의 고객 서비스를 기다리고 있는지 모릅니다. 그러나 매 분이 지날 때마다, 우리는 서서히 나쁜, 느린 고객 서비스를 기다리고 있다는 것을 알게 됩니다. 따라서 예상 추가 대기 시간은 늘어납니다.</p>
<div class="content-ad"></div>
<p>지금까지는 데이터를 직접 사용했습니다. 데이터를 확률 분포로 모델링해 볼 수도 있습니다. 그러나 모델링으로 넘어가기 전에 다른 두 예제인 마이크로파 팝콘 요리와 복권 당첨을 살펴보겠습니다.</p>
<h1>"팝콘"형 기다림 - 기다릴수록 덜 기다리는 것을 기대합니다.</h1>
<p>위키피디아 편집을 기다리는 기법을 마이크로파 팝콘 조리를 기다리는 것에 적용해 봅시다. (매력적일지도 모르는) 실제 데이터를 수집하는 대신 모의 데이터를 시뮬레이션하는 것으로 만족합니다. 난수 생성기를 사용할 것입니다. 요리 시간은 센서를 기반으로 하는 것이라 가정하며, 5분에서 15초 차이가 날 수 있다고 가정합니다.</p>
<h2>"팝콘"형 기다림 - 파이썬</h2>
<div class="content-ad"></div>
<p>파이썬에서 특히:</p>
<pre><code class="hljs language-python">seed = <span class="hljs-number">0</span>
rng = np.random.default_rng(seed)
sorted_popcorn_time_deltas = np.sort(rng.normal(<span class="hljs-number">5</span>*<span class="hljs-number">60</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30_000</span>))
popcorn_df = pd.DataFrame(pd.to_timedelta(sorted_popcorn_time_deltas, unit=<span class="hljs-string">"s"</span>), columns=[<span class="hljs-string">"Time Delta"</span>])
<span class="hljs-built_in">print</span>(popcorn_df.describe())
</code></pre>
<p>이 코드는 다음과 같은 통계 요약이 포함된 판다 데이터프레임을 생성합니다:</p>
<pre><code>                  Time Delta
</code></pre>
<p>count                      30000
mean   0 days 00:05:00.060355606
std    0 days 00:00:14.956424467
min    0 days 00:03:52.588244397
25%    0 days 00:04:50.011437922
50%    0 days 00:04:59.971380399
75%    0 days 00:05:10.239357827
max    0 days 00:05:59.183245298</p>
<div class="content-ad"></div>
<p>예상대로, 이 정규 분포에서 데이터를 생성할 때 평균은 5분이고 표준 편차는 약 15초입니다. 우리가 시뮬레이션한 대기 시간은 3분 52초에서 6분까지 범위에 있습니다.</p>
<p>이제 "대기-대기" 테이블을 생성할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">wait_wait_table</span>(popcorn_df, [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span>, <span class="hljs-number">2</span>*<span class="hljs-number">60</span>, <span class="hljs-number">3</span>*<span class="hljs-number">60</span>, <span class="hljs-number">4</span>*<span class="hljs-number">60</span>, <span class="hljs-number">5</span>*<span class="hljs-number">60</span>]).<span class="hljs-property">style</span>.<span class="hljs-title function_">hide</span>(axis=<span class="hljs-string">"index"</span>)
</code></pre>
<h2>"팝콘" 형태의 대기 시간 — 토론</h2>
<div class="content-ad"></div>
<p>우리의 "기다려-기다려" 소프트웨어는 팝콘 테이블을 아래와 같이 보여줍니다:</p>
<p><img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_5.png" alt="팝콘 대기 시간"></p>
<p>우리의 테이블에 따르면, 처음에는 5분 기다림을 예상합니다. 그리고 10초를 기다린 후에는 추가로 기대되는 대기 시간이 정확히 10초 줄어듭니다 (4분 50초로). 1분을 기다린 후에는 추가 대기 시간이 4분으로 줄어들고, 그러한 식으로 이어집니다. 5분에 이르러서도 추가 대기 시간은 계속해서 줄어들지만 0으로는 안 줄어듭니다.</p>
<p>나중에 데이터 모델링 하는 방법을 보게 될 것입니다. 지금은 복권 당첨을 기다리는 것에 대해 다음으로 살펴봅시다.</p>
<div class="content-ad"></div>
<h1>“로또 당첨” 스타일 대기 시간 — 지금까지 기다린 시간과는 무관하게, 예상 대기 시간은 동일합니다.</h1>
<p>로또 데이터에 대해서는 다시 시뮬레이션된 데이터를 생성하는 것이 편합니다. 워싱턴 주의 로또는 당첨 확률을 1 대 27.1로 제공합니다. (가장 흔한 당첨은 $1 베팅에 $3를 지불합니다.) 100만 주 (약 1만 9천 년) 동안 로또를 플레이하고 당첨 사이의 대기 시간에 대한 데이터를 수집해 봅시다.</p>
<h2>“로또 당첨” 스타일 대기 시간 — 파이썬</h2>
<p>우리는 100만 주 동안의 로또 플레이를 시뮬레이션합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">시드 = <span class="hljs-number">0</span>
rng = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">default_rng</span>(시드)
지난주_당첨 = <span class="hljs-title class_">None</span>
로또_대기 = []
<span class="hljs-keyword">for</span> 주차 <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1_000_000</span>):
    <span class="hljs-keyword">if</span> rng.<span class="hljs-title function_">uniform</span>(high=<span class="hljs-number">27.1</span>) &#x3C; <span class="hljs-number">1.0</span>:
        <span class="hljs-keyword">if</span> 지난주_당첨 is not <span class="hljs-title class_">None</span>:
            로또_대기.<span class="hljs-title function_">append</span>(주차 - 지난주_당첨)
        지난주_당첨 = 주차
정렬된_로또_시간_간격 = np.<span class="hljs-title function_">sort</span>(np.<span class="hljs-title function_">array</span>(로또_대기) * <span class="hljs-number">7</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>)
lotto_df = pd.<span class="hljs-title class_">DataFrame</span>(pd.<span class="hljs-title function_">to_timedelta</span>(정렬된_로또_시간_간격, unit=<span class="hljs-string">"s"</span>), columns=[<span class="hljs-string">"시간 간격"</span>])
<span class="hljs-title function_">print</span>(lotto_df.<span class="hljs-title function_">describe</span>())
</code></pre>
<pre><code class="hljs language-js">                        시간 간격
count                        <span class="hljs-number">36773</span>
mean   <span class="hljs-number">190</span> days <span class="hljs-number">08</span>:<span class="hljs-number">21</span>:<span class="hljs-number">00</span><span class="hljs-number">.141951976</span>
std    <span class="hljs-number">185</span> days <span class="hljs-number">22</span>:<span class="hljs-number">42</span>:<span class="hljs-number">41.462765808</span>
min                <span class="hljs-number">7</span> days <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>
<span class="hljs-number">25</span>%               <span class="hljs-number">56</span> days <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>
<span class="hljs-number">50</span>%              <span class="hljs-number">133</span> days <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>
<span class="hljs-number">75</span>%              <span class="hljs-number">259</span> days <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>
max             <span class="hljs-number">2429</span> days <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>
</code></pre>
<p>우리의 최단 가능한 당첨 간격은 7일입니다. 가장 긴 시뮬레이션된 건조 기간은 6년 이상입니다. 중앙값 대기 시간은 133일입니다.</p>
<p>우리는 "대기-대기" 테이블을 생성합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">lotto_days = [<span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7.00001</span>,  <span class="hljs-number">2</span>*<span class="hljs-number">7</span>, <span class="hljs-number">4</span>*<span class="hljs-number">7</span>, <span class="hljs-number">183</span>, <span class="hljs-number">365.25</span>, <span class="hljs-number">2</span>*<span class="hljs-number">365.25</span>, <span class="hljs-number">5</span>*<span class="hljs-number">365.25</span>]
lotto_waits = [day * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> <span class="hljs-keyword">for</span> day <span class="hljs-keyword">in</span> lotto_days]
<span class="hljs-title function_">wait_wait_table</span>(lotto_df, lotto_waits).<span class="hljs-property">style</span>.<span class="hljs-title function_">hide</span>(axis=<span class="hljs-string">"index"</span>)
</code></pre>
<h2>"로또 당첨" 스타일 대기 시간 — 토론</h2>
<p>여기 "대기-대기" 테이블이 있습니다:</p>
<img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_6.png">
<div class="content-ad"></div>
<p>다음은 Markdown 형식으로 작성된 텍스트입니다.</p>
<p>테이블에 따르면 복권은 우리가 이기기까지 얼마나 기다렸는지에 신경을 쓰지 않습니다. 우리가 방금 이겼던지 (지금까지 기다린 시간 ` 1초) 아니면 1년 동안 이기지 못했던지, 우리가 다음 승리까지 기다려야 하는 예상 추가 기다림은 대부분 항상 126일부터 133일 사이입니다.</p>
<p>표의 세 항목은 이상할 수 있습니다. 7일과 7일 1초에서 무슨 일이 일어나는지 생각해보세요. 추가 기다림이 126일에서 거의 즉시 133일 정도로 급격히 증가하는 이유는 무엇일까요? 답은 매주 추첨하는 시점에서 승리까지의 최소 기다림이 0일에서 7일로 변경되기 때문입니다. 그리고 5년은 어떻게 되는 걸까요? 5년을 기다린다면 보통 133일이 걸리는 대신 단지 50일만에 승리를 기대할 수 있는 것일까요? 안타깝게도 아닙니다. 오히려 이는 우리 데이터의 한계를 보여줍니다. 데이터에서는 5년을 기다리는 경우를 세 번만 볼 수 있습니다:</p>
<pre><code class="hljs language-js">lotto_df[lotto_df[<span class="hljs-string">"Time Delta"</span>] > pd.<span class="hljs-title function_">to_timedelta</span>(<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span> * <span class="hljs-number">365.25</span> * <span class="hljs-number">5</span>, unit=<span class="hljs-string">"s"</span>)]
</code></pre>
<img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_7.png">
<div class="content-ad"></div>
<p>삼 가지 값은 중위수의 노이즈 추정치로 이어집니다.</p>
<p>지금까지 실제 및 모의 데이터에서 본 것을 요약해보면:</p>
<ul>
<li>위키피디아 편집 — 기다릴수록 기대하는 대기 시간이 길어집니다.</li>
<li>팝콘 — 기다릴수록 기대하는 대기 시간이 줄어듭니다.</li>
<li>복권 당첨 — 지금까지의 대기 시간과 관계없이 기대 대기 시간은 동일합니다.</li>
</ul>
<p>다음 섹션에서는 모델링의 방법과 그 이유에 대해 살펴보겠습니다. 미국 로또 데이터부터 시작하겠습니다.</p>
<div class="content-ad"></div>
<p>이 부분에서는 대기 시간 예측을 위한 간단한 표현을 찾아보겠습니다. 예측에는 이러한 간소화가 필요하지 않습니다. 우리가 지금까지 만든 것은 경험적 분포라고 불리며 잘 작동합니다. 그러나 더 간단한 표현은 더 편리할 수 있습니다. 또한 다른 종류의 대기를 이해하기 쉽게 비교할 수 있게 해줄 수도 있습니다.</p>
<p>우리는 세 가지 예제를 살펴보면서 진행할 것입니다. 가장 간단한 것부터 시작하여 (복권 당첨) 가장 복잡한 것(Wikipedia 편집)으로 넘어갈 것입니다. 이전과 마찬가지로 Python 코드(건너뛸 수 있는)와 토론 사이를 오가겠습니다.</p>
<p>먼저 대기 시간 데이터프레임에 누적 분포 열을 추가하는 것부터 시작하겠습니다. 이전에 데이터프레임을 시간 딜타로 정렬했음을 기억해주세요.</p>
<pre><code class="hljs language-python">wiki_df[<span class="hljs-string">'CDF'</span>] = wiki_df[<span class="hljs-string">'Time Delta'</span>].rank(pct=<span class="hljs-literal">True</span>)
popcorn_df[<span class="hljs-string">'CDF'</span>] = popcorn_df[<span class="hljs-string">'Time Delta'</span>].rank(pct=<span class="hljs-literal">True</span>)
lotto_df[<span class="hljs-string">'CDF'</span>] = lotto_df[<span class="hljs-string">'Time Delta'</span>].rank(pct=<span class="hljs-literal">True</span>)
wiki_df
</code></pre>
<div class="content-ad"></div>
<p>CDF 컬럼은 누적 분포 함수(Cumulative Distribution Function)를 나타내며, 가장 짧은 대기 시간에는 0.0에 가까운 값이 있고, 가장 긴 대기 시간에는 1.0이 있습니다. 다시 말해, 각 행의 순위가 분수로 나타난 것입니다. 위키피디아 데이터프레임은 이제 다음과 같습니다:</p>

































<table><thead><tr><th>Time Delta</th><th>CDF</th></tr></thead><tbody><tr><td>0 days 00:00:10</td><td>0.1</td></tr><tr><td>0 days 00:00:30</td><td>0.3</td></tr><tr><td>0 days 00:01:00</td><td>0.5</td></tr><tr><td>0 days 00:02:00</td><td>0.7</td></tr><tr><td>0 days 00:05:00</td><td>0.9</td></tr><tr><td>0 days 00:10:00</td><td>1.0</td></tr></tbody></table>
<p>이제 CDF(누적 분포 함수)를 대기 시간 Time Delta(x-축)에 대해 그릴 수 있습니다. 파이썬에서 다음과 같은 플로팅 코드를 사용할 수 있습니다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt

<span class="hljs-keyword">def</span> <span class="hljs-title function_">wait_cdf</span>(<span class="hljs-params">title, sorted_df, wait_ticks, dist=<span class="hljs-literal">None</span>, dist_label=<span class="hljs-literal">None</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span>, xscale=<span class="hljs-string">'linear'</span></span>):
    wait_seconds = sorted_df[<span class="hljs-string">'Time Delta'</span>].dt.total_seconds() <span class="hljs-comment"># x values</span>
    cdf = sorted_df[<span class="hljs-string">'CDF'</span>] <span class="hljs-comment"># y values</span>

    left = left <span class="hljs-keyword">or</span> wait_seconds.<span class="hljs-built_in">min</span>()
    right = right <span class="hljs-keyword">or</span> wait_seconds.<span class="hljs-built_in">max</span>()

    plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
    plt.title(title + <span class="hljs-string">' 누적 분포 함수(CDF)'</span>)
    plt.plot(wait_seconds, cdf, marker=<span class="hljs-string">'.'</span>, linestyle=<span class="hljs-string">" "</span>, label=<span class="hljs-string">'경험적인 CDF'</span>)

    <span class="hljs-keyword">if</span> dist <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
        dist_x = np.logspace(np.log10(left), np.log10(right), <span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> xscale == <span class="hljs-string">'log'</span> <span class="hljs-keyword">else</span> np.linspace(left, right, <span class="hljs-number">100</span>)
        dist_y = dist.cdf(dist_x)
        plt.plot(dist_x, dist_y, label = dist_label)

    plt.xlabel(<span class="hljs-string">'대기 시간'</span>)
    plt.ylabel(<span class="hljs-string">'CDF'</span>)
    plt.xscale(xscale)
    plt.xticks(wait_ticks, [seconds_to_text(wait_tick) <span class="hljs-keyword">for</span> wait_tick <span class="hljs-keyword">in</span> wait_ticks], rotation=<span class="hljs-number">45</span>)
    plt.xlim(left=left, right=right)
    plt.grid(<span class="hljs-literal">True</span>, which=<span class="hljs-string">"both"</span>, ls=<span class="hljs-string">"--"</span>)
    plt.legend(loc=<span class="hljs-string">'upper left'</span>)
    plt.show()

wait_cdf(<span class="hljs-string">"로또 당첨"</span>, lotto_df, wiki_wait_ticks, xscale=<span class="hljs-string">'log'</span>)
</code></pre>
<div class="content-ad"></div>
<p>로또 당첨과 대기 시간의 CDF 플롯을 로그 스케일로 표시하였습니다:</p>
<p><img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_9.png" alt="Lottery Wins CDF Plot"></p>
<p>곡선이 간단해 보이니 이에 간단한 곡선을 적합해보려고 합니다. 가장 적합한 곡선은 지수 분포입니다. 이는 대기 시간과 관련된 가장 간단한 일반 함수입니다.</p>
<p>Python의 scipy.stats 패키지를 사용하면 데이터에 지수 곡선을 맞추고 해당 결과 곡선을 Python 객체로 표현하는 것이 쉽습니다. 여기서는 lotto_expon_dist라는 이름으로 이를 표현했습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> expon

_, lotto_e_scale = expon.fit(lotto_df[<span class="hljs-string">'Time Delta'</span>].dt.total_seconds(), floc=<span class="hljs-number">0</span>)
lotto_expon_dist = expon(scale=lotto_e_scale)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"복권 당첨 지수 중앙값은 <span class="hljs-subst">{seconds_to_text(lotto_expon_dist.median())}</span> 입니다. 스케일 매개변수는 <span class="hljs-subst">{seconds_to_text(lotto_e_scale)}</span> 입니다."</span>)
</code></pre>
<p>이 코드는 출력합니다:</p>
<p>복권 당첨 지수 중앙값은 131일 22시간 32분 20초 입니다. 스케일 매개변수는 190일 8시간 21분 입니다.</p>
<p>적합된 곡선의 중앙값은 약 132일로, 경험적인 중앙값인 133일과 근접합니다. 지수곡선을 관행적으로 스케일이라는 단일 숫자로 매개변수화하는데, 이것은 분포의 평균에 해당하지만 평균에서 중앙값을 쉽게 계산하거나 그 반대로 할 수 있습니다.</p>
<div class="content-ad"></div>
<p>로또 당첨금에 대한 경험적 누적 분포(EMCDF) 및 적합 누적 분포(FCDF) 플롯입니다:</p>
<pre><code class="hljs language-js">lotto_expon_label = f<span class="hljs-string">'ExponentialDistribution(scale={seconds_to_text(lotto_e_scale)})'</span>
<span class="hljs-title function_">wait_cdf</span>(<span class="hljs-string">"당첨금"</span>, lotto_df, wiki_wait_ticks, dist=lotto_expon_dist, dist_label=lotto_expon_label, xscale=<span class="hljs-string">'log'</span>)
</code></pre>
<img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_10.png">
<p>둘이 꽤 근접합니다. 왼쪽의 약간의 불일치는 복권 추첨시 모멘트의 즉시 7일 점프에 의해 발생합니다. 이 글에서는 이 작은 불일치를 무시하겠습니다.</p>
<div class="content-ad"></div>
<p>우리 (모의) 복권 당첨 데이터에 지수 함수가 잘 작동합니다. Popcorn과 Wikipedia 데이터에도 어떻게 작동하는지 살펴봅시다. 다음은 이러한 데이터프레임에 지수 분포를 맞추는 코드입니다.</p>
<pre><code class="hljs language-js">_, popcorn_e_scale = expon.<span class="hljs-title function_">fit</span>(popcorn_df[<span class="hljs-string">'Time Delta'</span>].<span class="hljs-property">dt</span>.<span class="hljs-title function_">total_seconds</span>(), floc=<span class="hljs-number">0</span>)
popcorn_expon_dist = <span class="hljs-title function_">expon</span>(scale=popcorn_e_scale)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"Popcorn exponential median is {seconds_to_text(popcorn_expon_dist.median())}"</span>)
popcorn_expon_label = f<span class="hljs-string">'ExponentialDistribution(scale={seconds_to_text(popcorn_e_scale)})'</span>
<span class="hljs-title function_">wait_cdf</span>(<span class="hljs-string">"Popcorn"</span>, popcorn_df, popcorn_ticks, dist=popcorn_expon_dist, dist_label=popcorn_expon_label, left=<span class="hljs-number">10</span>, right=<span class="hljs-number">6</span>*<span class="hljs-number">60</span>, xscale=<span class="hljs-string">'linear'</span> )

_, wiki_e_scale = expon.<span class="hljs-title function_">fit</span>(wiki_df[<span class="hljs-string">'Time Delta'</span>].<span class="hljs-property">dt</span>.<span class="hljs-title function_">total_seconds</span>(), floc=<span class="hljs-number">0</span>)
wiki_expon_dist = <span class="hljs-title function_">expon</span>(scale=wiki_e_scale)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"Wiki exponential median is {seconds_to_text(wiki_expon_dist.median())}"</span>)
wiki_expon_label = f<span class="hljs-string">'ExponentialDistribution(scale={seconds_to_text(wiki_e_scale)})'</span>
<span class="hljs-title function_">wait_cdf</span>(<span class="hljs-string">"Wiki Edits"</span>, wiki_df, wiki_wait_ticks, dist=wiki_expon_dist, dist_label=wiki_expon_label, xscale=<span class="hljs-string">'log'</span>, left=<span class="hljs-number">60</span>)
</code></pre>
<p>그리고 여기가 그림들입니다:</p>
<img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_11.png">
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_12.png" alt="이미지"></p>
<p>이런, 이 곡선 맞추기 결과는 정말 최악이네요! 문제는 지수 분포가 "복권 당첨"과 유사한 데이터만 모델링한다는 것입니다. 구체적으로 말하면, 대기 시간이 이전 대기 시간에 관계없이 기대 대기 시간이 동일한 경우에 해당합니다. 이전 대기 시간을 무시하는 대기 시간에 대해 좌우되는 경우, 이것이 메모리리스(exponential)이라고 불립니다. 또한 연속 분포 중에서 지수 분포는 유일한 메모리리스 분포입니다.</p>
<p>그렇다면 분포에 메모리가 필요하다면 어떨까요? 다음으로 시도할 수 있는 가장 간단한 분포는 와이블(Weibull) 분포입니다.</p>
<p>와이블 분포는 형태(shape)와 척도(scale) 두 매개변수로 매개화됩니다. 복권 데이터로 시작해 보죠:</p>
<div class="content-ad"></div>
<p>from scipy.stats import weibull_min</p>
<p>lotto_shape, _, lotto_w_scale = weibull_min.fit(lotto_df['Time Delta'].dt.total_seconds(), floc=0)
lotto_weibull_dist = weibull_min(c=lotto_shape,scale=lotto_w_scale)</p>
<p>print(f"복권 당첨 위블 중앙값은 {seconds_to_text(lotto_weibull_dist.median())}")
lotto_weibull_label = f'WeibullDistribution(shape={lotto_shape:.3},scale={seconds_to_text(lotto_w_scale)})'
wait_cdf("복권 당첨", lotto_df, wiki_wait_ticks, dist=lotto_weibull_dist, dist_label=lotto_weibull_label, xscale='log')</p>
<p>이는 지수함수와 유사한 장착 곡선을 생성합니다. 실제로 형태가 1일때 위블 분포는 지수 분포입니다. 여기서 형태는 1.06입니다.</p>
<img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_13.png">
<p>팝콘 데이터에 위블을 적합하려고 하면 무엇이 발생하나요?</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python">popcorn_shape, _, popcorn_w_scale = weibull_min.fit(popcorn_df[<span class="hljs-string">'Time Delta'</span>].dt.total_seconds(), floc=<span class="hljs-number">0</span>)
popcorn_weibull_dist = weibull_min(c=popcorn_shape, scale=popcorn_w_scale)
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Popcorn Weibull median is <span class="hljs-subst">{seconds_to_text(popcorn_weibull_dist.median())}</span>"</span>)
popcorn_df_weibull_label = <span class="hljs-string">f'Weibull(shape=<span class="hljs-subst">{popcorn_shape:<span class="hljs-number">.3</span>}</span>, scale=<span class="hljs-subst">{seconds_to_text(popcorn_w_scale)}</span>)'</span>
wait_cdf(<span class="hljs-string">"Popcorn"</span>, popcorn_df, popcorn_ticks, dist=popcorn_weibull_dist, dist_label=popcorn_df_weibull_label, left=<span class="hljs-number">3</span>*<span class="hljs-number">60</span>, right=<span class="hljs-number">7</span>*<span class="hljs-number">60</span>, xscale=<span class="hljs-string">'linear'</span>)
</code></pre>
<p><img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_14.png" alt="Image"></p>
<p>안전하진 않지만, 이 적합은 지수 함수의 적합보다 훨씬 낫습니다. 모양 모수의 값이 20임을 주목하세요. Weibull의 모양 모수가 1보다 큰 경우 "대기 시간이 길수록 대기 시간을 기대하는 것이 줄어든다"를 나타냅니다.</p>
<p>마지막으로, 위키피디아 데이터에 Weibull을 시도해보겠습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">wiki_shape, _, wiki_w_scale = weibull_min.<span class="hljs-title function_">fit</span>(wiki_df[<span class="hljs-string">'Time Delta'</span>].<span class="hljs-property">dt</span>.<span class="hljs-title function_">total_seconds</span>(), floc=<span class="hljs-number">0</span>)
wiki_weibull_dist = <span class="hljs-title function_">weibull_min</span>(c=wiki_shape, scale=wiki_w_scale)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"위키 위불 중앙값은 {seconds_to_text(wiki_weibull_dist.median())}"</span>)
wiki_df_weibull_label = f<span class="hljs-string">'위불(모양={wiki_shape:.3},스케일={seconds_to_text(wiki_w_scale)})'</span>
<span class="hljs-title function_">wait_cdf</span>(<span class="hljs-string">"위키 편집"</span>, wiki_df, wiki_wait_ticks, dist=wiki_weibull_dist, dist_label=wiki_df_weibull_label, xscale=<span class="hljs-string">'log'</span>, left=<span class="hljs-number">60</span>)
</code></pre>
<img src="/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_15.png">
<p>이 곡선 맞춤은 완벽하지 않지만, 지수함수의 맞춤보다 훨씬 좋습니다. 모양 모수값인 0.292에 주목해보세요. 위불의 모양 모수가 1보다 작을 때는 "기다린 시간이 길수록 더 기다려야 한다"는 것을 나타냅니다. 그러나 위불만이 이 특성을 갖고 있는 것은 아닙니다. 이 특성을 갖는 무수히 많은 분포들도 있습니다. 실제로 위키피디아 분포는 이 특성을 갖지만 위불 분포가 아닙니다.</p>
<h1>결론</h1>
<div class="content-ad"></div>
<p>결론적으로, 당신과 나는 미친 것이 아닙니다(필요에 따라).</p>
<p>우리는 정말 기다린 시간이 길수록 더 기다려야 할 상황이 있는 것을 보았습니다. 위키피디아 편집 사이의 시간 간격에서 경험적으로 확인할 수 있습니다. 또한 Weibull 분포에서 형태 매개변수가 1보다 작은 경우에도 확인할 수 있습니다.</p>
<p>똑같이, 다른 몇 가지 대기 시간에는 "기다린 시간이 길수록 더 적게 기다리게 된다"는 규칙이 적용됩니다. 팝콘에서 이 현상을 확인할 수도 있습니다. 또한 Weibull 분포에서 형태 매개변수가 1보다 큰 경우에도 이를 확인할 수 있습니다.</p>
<p>마지막으로, 세 번째 종류의 대기 시간인 "메모리리스"도 존재합니다. 이 경우, 지금까지 기다린 시간에 상관없이 기대 대기 시간은 동일합니다. 복권 당첨 간의 시간에서 이를 확인했습니다. 이는 형태 매개변수가 1인 Weibull 분포(지수 분포와 동일)와 관련이 있습니다.</p>
<div class="content-ad"></div>
<p>데이터를 분석할 때 기다릴 데이터가 있는 경우, Weibull 분포를 시도하는 것을 권장합니다. Python을 사용하면 이러한 곡선을 fitting하는 것이 쉽습니다. 그러나 데이터가 Weibull 분포와 잘 맞지 않는 경우에는 Weibull을 사용하지 않는 것이 좋습니다. 대신, 자료 분포를 직접 사용하여 데이터가 스스로 말하도록하십시오.</p>
<p>기다림 시간에 대한 이 여정에 참여해 주셔서 감사합니다. 이제 기다림 시간과 그 분석에 대해 더 잘 이해하게 되었으면 좋겠습니다.</p>
<p>칼을 Medium에서 팔로우해 주세요. 저는 Rust 및 Python에서의 과학적 프로그래밍, 머신러닝 및 통계에 대해 씁니다. 월 한 번 정도 기사를 씁니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"대기 시간을 통해의 신비로운 여행","description":"","date":"2024-05-17 20:39","slug":"2024-05-17-AWhimsicalJourneyThroughWaitTimes","content":"\n\n## 파이썬을 사용하여 전자레인지 카운트다운부터 끝나지 않는 전화 대기 시간까지\n\n![image](/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_0.png)\n\n전자레인지 오븐의 카운트다운이 빠르게 0으로 수렴하는 것을 본 적이 있나요? 반면 전화 대기시간은 영원처럼 늘어날까요?\n\n한가지 생각해 보세요. 포플콘을 전자레인지에 넣어 가열한 지 겨우 1분 지난 때에는 그릇을 준비하고 서빙할 준비를 합니다. 하지만 전화 대기 중에 1분이 지난다면? 다시 사람과 대화를 나눌 수 있을지 의문이 들 정도입니다. 10분 후, 포플콘을 즐기는 중이겠죠. 하지만 전화는? 대기 음악이 끝도 없는 연옥의 배경음악이 되고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 팝콘을 기다리는 사이와 전화 대기를 이어가는 서사 속을 맴도는 … 주간 복권. 승리를 기다립니다. 매주 새로운 티켓은 이전 주의 실망과는 거리가 먼 신선한 약속을 간직하고 있습니다.\n\n요약하자면, 세 가지 다른 종류의 대기가 나타납니다:\n\n- “대기 전화”형 — 기다린 시간이 오래 될수록 더 오랫동안 기다릴 것으로 기대합니다.\n- “팝콘”형 — 기다린 시간이 길어질수록 더 짧게 기다릴 것으로 기대합니다.\n- “복권 당첨”형 — 지금까지 기다린 것과 관계없이 예상 대기 시간은 변하지 않습니다.\n\n이 대기 시간의 차이는 실제로 존재하는 것일까요, 아니면 마음의 장난일까요? 이 질문에 대한 대답은 두 부분으로 나누어 알아보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 부분 1 — 데이터 분석\n- 부분 2 — 데이터 모델링\n\n각 부분에서 대기 시간 유형을 각각 살펴보겠습니다. 자세한 Python 코드와 설명이 번갈아 나옵니다. Python에 관심이 있다면 코드 부분을 읽어보세요. 대기 시간에 대해 배우고 싶다면 코드를 건너뛰어도 됩니다.\n\n# \"대기 중\" 유형 대기 시간 — 기다린 시간이 길수록 더 오래 기다리게 됩니다.\n\n데이터로 시작하고 싶지만 \"대기 중\" 시간에 대한 데이터가 없습니다. 대신 컴퓨터 파일의 편집 사이의 시간에 대해서 어떠세요? 그런 편집 시간을 보는 곳 한 곳이 바로 위키피디아입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위키피디아 페이지에서 마지막 편집 이후의 시간을 보고 다음 편집까지 얼마나 남았는지 예측할 수 있을까요?\n\n위키피디아 페이지 편집에 대한 다음 편집까지의 시간을 어떻게 예측할 수 있을까요? 다음 편집이 언제 발생할지 정확히 예측해 보세요: \"저는 이 페이지가 정확히 5일 3시간 20분 후에 편집될 것으로 예측합니다.\" 하지만 그렇게 구체적으로 예측하는 것은 너무 정확성이 떨어질 것입니다.\n\n시간 범위를 예측할 수도 있습니다: \"저는 이 페이지가 다음 100년 이내에 언제든지 편집될 것으로 예측합니다.\" 이렇게 하면 거의 항상 맞을 수 있겠지만, 너무 모호하고 흥미롭지 않습니다.\n\n더 실용적인 예측은 \"중위 다음 편집 시간\"의 형태입니다. 이렇게 말할 수 있습니다: \"저는 이 페이지가 다음 5일 3시간 20분 이내에 50% 확률로 편집될 것으로 예측합니다.\" 저, 당신의 적,는 \"이전\" 또는 \"이후\"를 선택할 것입니다. 만약 실제 중위 다음 편집 시간이 3일이라고 가정하면, \"이전\"을 선택할 것입니다. 그럼 우리는 최대 5일 3시간 20분까지 기다립니다. 그 동안 누군가(다시 말해서, 우리 둘을 제외한 누군가) 페이지를 편집하면 상대방이 점수를 획들하고, 그렇지 않으면 당신이 점수를 획득합니다. 이러한 점수 체계를 통해, 만약 제가 당신보다 더 좋은 예측자라면 더 많은 점수를 획득해야 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬에 대해 알아보고 이러한 예측을 어떻게 할 수 있는지 살펴봅시다:\n\n## “대기 중” 유형의 대기 시간 — Python\n\n아티스트 Marie Cochran에 관한 위키피디아 문서를 살펴보겠습니다. 문서의 개정 내역을 살펴볼 수 있습니다:\n\n![image](/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다양한 위키피디아 문서에서 데이터를 수집하기 위해 작은 파이썬 스크립트를 작성했어요. 다음과 같은 작업을 합니다:\n\n- https://en.wikipedia.org/wiki/Special:Random을 통해 랜덤한 영어 위키백과 페이지를 선택합니다.\n- 해당 페이지의 편집 이력으로 이동합니다. 예를 들어, https://en.wikipedia.org/w/index.php?title=Marie_Cochran\u0026action=history.\n- (최대) 최근 50회 편집의 날짜와 시간을 추출합니다. 시간은 분 단위로 표시됩니다.\n- 문서 제목, 수정 시간, 스크립트 실행 시간으로 구성된 줄을 생성합니다. 모든 시간은 UTC 시간대를 사용합니다. 탭으로 열을 구분합니다.\n- 줄을 파일에 추가합니다.\n\n편집 시간 데이터 일부를 보여드리겠습니다:\n\n```js\nMarie_Cochran 01:20, 8 January 2024 01:16, 08 February 2024\nMarie_Cochran 01:10, 27 September 2023 01:16, 08 February 2024\nMarie_Cochran 00:59, 12 September 2023 01:16, 08 February 2024\nMarie_Cochran 11:43, 2 November 2022 01:16, 08 February 2024\n...\nMarie_Cochran 19:20, 10 March 2018 01:16, 08 February 2024\nPeter_Tennant 15:03, 29 July 2023 01:16, 08 February 2024\nPeter_Tennant 21:39, 15 April 2022 01:16, 08 February 2024\n...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nimport pandas as pd\n\n# 데이터 읽기\nwiki_df = pd.read_csv(\"edit_history.txt\", sep='\\t', header=None, names=[\"Title\", \"Edit DateTime\", \"Probe DateTime\"], usecols=[\"Title\", \"Edit DateTime\"])\nwiki_df['Edit DateTime'] = pd.to_datetime(wiki_df['Edit DateTime']) # 텍스트를 날짜 및 시간으로 변환\n\n# 'Title' 및 'Edit DateTime'을 기준으로 DataFrame 정렬하여 시간 간격이 올바르게 계산되도록 함\nwiki_df.sort_values(by=['Title', 'Edit DateTime'], inplace=True)\n\n# 동일한 제목 내에서 연속해서 편집한 경우의 시간 간격 계산\nwiki_df['Time Delta'] = wiki_df.groupby('Title')['Edit DateTime'].diff()\nwiki_df.head()\n```\n\n결과로 나온 Pandas 데이터프레임은 샘플된 기사 중 알파벳상으로 가장 빠른 기사(제목 기준)로 시작합니다. 이 기사는 몽골 출신인 매우 키가 큰 사람 인 Öndör Gongor에 대해 독자들에게 알려줍니다:\n\n![image](/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 기사의 마지막 50개의 편집 중 첫 번째 편집은 2008년 1월 27일 오후 3시 13분 (UTC)에 이루어졌습니다. 다음 편집은 16분 후에 이루어졌습니다. 그 다음 편집은 데이터의 해상도 한계로 인해 1분 내로 발생하여 0일 00:00:00으로 표시됩니다.\n\n계속 처리하면, 각 기사 맨 처음에 나타나는 NaT (not-a-time) 행을 제거해 보겠습니다. 또한 대기 시간에 따라 정렬하고 판다의 인덱스를 재설정할 것입니다:\n\n```js\n# 'Time Delta' 열에서 NaT(시간이 아님) 값이 포함된 행 제거\nwiki_df.dropna(subset=['Time Delta'], inplace=True)\n# 시간 간격으로 정렬 및 인덱스 재설정\nwiki_df.sort_values(by='Time Delta', inplace=True)\nwiki_df.reset_index(drop=True, inplace=True)\ndisplay(wiki_df)\nwiki_df['Time Delta'].describe()\n```\n\n이를 통해 다음과 같이 시작하고 끝나는 데이터프레임이 생성됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 통계 요약입니다.\n\n```js\ncount                          36320\nmean      92 days 13:46:11.116189427\nstd      195 days 11:36:52.016155110\nmin                  0 days 00:00:00\n25%                  0 days 00:27:00\n50%                 15 days 05:41:00\n75%                100 days 21:45:45\nmax               4810 days 17:39:00\n```\n\n조사 결과, 샘플링된 대기 시간은 0일 00:00:00(즉, 1분 미만)부터 13년 이상까지 다양합니다. (13년 편집 대기는 버지니아 대학교의 건물에 관한 기사였습니다.) 편집의 1/4은 이전 편집 후 27분 이내에 발생합니다. 편집 간 중위값은 약 15일을 조금 넘습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n조금 더 발전하기 전에, 웨이팅 시간을 향상시키고 싶은데요. 다음과 같이 작은 함수를 사용해서 웨이팅 시간을 표시할 수 있습니다:\n\n```js\ndef seconds_to_text(seconds):\n    seconds = round(seconds)\n    result = []\n    for unit_name, unit_seconds in [('y', 86400 * 365.25),('d', 86400),('h', 3600),('m', 60),('s', 1)]:\n        if seconds \u003e= unit_seconds:\n            unit_value, seconds = divmod(seconds, unit_seconds)\n            result.append(f\"{int(unit_value)}{unit_name}\")\n    return ' '.join(result) if result else \"\u003c1s\"\n\nseconds_to_text(100)\n```\n\n위의 `seconds_to_text` 함수는 100초를 `1m 40s`로 표시합니다.\n\n이제 위키피디아 데이터를 위한 \"웨이팅 테이블\"을 만들 수 있습니다. 기존에 기사의 다음 편집을 기다린 시간을 주면, 이 테이블은 중간 추가로 기다려야 할 시간을 알려줍니다. (\"중간값\"은 이 시간보다 덜 기다릴 확률이 50%이고, 시간이 더 걸리는 확률이 50%라는 것을 의미합니다.)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport numpy as np\n\ndef wait_wait_table(df, wait_ticks):\n    sorted_time_deltas_seconds = df['Time Delta'].dt.total_seconds()\n    results = []\n    for wait_tick in wait_ticks:\n        greater_or_equal_values = sorted_time_deltas_seconds[sorted_time_deltas_seconds \u003e= wait_tick]\n        median_wait = np.median(greater_or_equal_values)\n        additional_wait = median_wait - wait_tick\n        results.append({\"Wait So Far\": seconds_to_text(wait_tick), \"Median Additional Wait\": seconds_to_text(additional_wait)})\n    return pd.DataFrame(results)\n\nwiki_wait_ticks = [0, 60, 60*5, 60*15, 3600, 3600*4, 86400, 86400 * 7,86400 * 30, 86400 * 100, 86400 * 365.25, 86400 * 365.25 * 5, 86400 * 365.25 * 10]\nwiki_wait_tick_labels = [seconds_to_text(wait_tick) for wait_tick in wiki_wait_ticks]\nwait_wait_table(wiki_df, wiki_wait_ticks).style.hide(axis=\"index\")\n```\n\n이제 이 표의 출력에 대해 알아보겠습니다.\n\n## \"대기 중\" 유형의 대기 - 토론\n\n앞의 파이썬 코드는 이 표를 생성합니다. 이것을 \"대기-대기\" 표라고 부르죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_4.png)\n\n만약 아무도 기다리지 않았다면(다시 말해, 누군가가 페이지를 편집했다) 다음 편집은 15일이 넘게 기다릴 것으로 예상됩니다. 그러나 1분 후에도 누군가 기사를 편집하지 않았다면, 19일을 기다려야 할 것으로 예상됩니다. 따라서 1분 기다리면 예상 추가 대기 시간이 거의 4일 더 늘어납니다. 한 시간 후에도 누구도 기사를 편집하지 않았다면, 예상 추가 대기 시간은 47일로 두 배 넘게 늘어납니다.\n\n이 현상을 생각하는 한 가지 방법은 다음 편집을 기다리기 시작할 때 우리가 어떤 종류의 페이지에 있는지 모르는 것입니다. 이것이 테일러 스위프트와 같은 핫 팝컬쳐 주제의 기사인가요? 아니면 5000명 대학의 건물인 '로턴다(The Rotunda)'와 같은 니치하고 느린 주제인가요? 수정이 일어나지 않는 매 분이 지날수록, 확률은 이것이 테일러 스위프트와 같은 기사에서 '로턴다(The Rotunda)'와 같은 기사로 이동합니다.\n\n마찬가지로, 고객 서비스에 전화하고 대기시간이 발생할 때 - 처음에는 어떤 종류의 고객 서비스를 기다리고 있는지 모릅니다. 그러나 매 분이 지날 때마다, 우리는 서서히 나쁜, 느린 고객 서비스를 기다리고 있다는 것을 알게 됩니다. 따라서 예상 추가 대기 시간은 늘어납니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금까지는 데이터를 직접 사용했습니다. 데이터를 확률 분포로 모델링해 볼 수도 있습니다. 그러나 모델링으로 넘어가기 전에 다른 두 예제인 마이크로파 팝콘 요리와 복권 당첨을 살펴보겠습니다.\n\n# \"팝콘\"형 기다림 - 기다릴수록 덜 기다리는 것을 기대합니다.\n\n위키피디아 편집을 기다리는 기법을 마이크로파 팝콘 조리를 기다리는 것에 적용해 봅시다. (매력적일지도 모르는) 실제 데이터를 수집하는 대신 모의 데이터를 시뮬레이션하는 것으로 만족합니다. 난수 생성기를 사용할 것입니다. 요리 시간은 센서를 기반으로 하는 것이라 가정하며, 5분에서 15초 차이가 날 수 있다고 가정합니다.\n\n## \"팝콘\"형 기다림 - 파이썬\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬에서 특히:\n\n```python\nseed = 0\nrng = np.random.default_rng(seed)\nsorted_popcorn_time_deltas = np.sort(rng.normal(5*60, 15, 30_000))\npopcorn_df = pd.DataFrame(pd.to_timedelta(sorted_popcorn_time_deltas, unit=\"s\"), columns=[\"Time Delta\"])\nprint(popcorn_df.describe())\n```\n\n이 코드는 다음과 같은 통계 요약이 포함된 판다 데이터프레임을 생성합니다:\n\n\n                      Time Delta\ncount                      30000\nmean   0 days 00:05:00.060355606\nstd    0 days 00:00:14.956424467\nmin    0 days 00:03:52.588244397\n25%    0 days 00:04:50.011437922\n50%    0 days 00:04:59.971380399\n75%    0 days 00:05:10.239357827\nmax    0 days 00:05:59.183245298\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예상대로, 이 정규 분포에서 데이터를 생성할 때 평균은 5분이고 표준 편차는 약 15초입니다. 우리가 시뮬레이션한 대기 시간은 3분 52초에서 6분까지 범위에 있습니다.\n\n이제 \"대기-대기\" 테이블을 생성할 수 있습니다:\n\n```js\nwait_wait_table(popcorn_df, [0, 10, 30, 60, 2*60, 3*60, 4*60, 5*60]).style.hide(axis=\"index\")\n```\n\n## \"팝콘\" 형태의 대기 시간 — 토론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 \"기다려-기다려\" 소프트웨어는 팝콘 테이블을 아래와 같이 보여줍니다:\n\n![팝콘 대기 시간](/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_5.png)\n\n우리의 테이블에 따르면, 처음에는 5분 기다림을 예상합니다. 그리고 10초를 기다린 후에는 추가로 기대되는 대기 시간이 정확히 10초 줄어듭니다 (4분 50초로). 1분을 기다린 후에는 추가 대기 시간이 4분으로 줄어들고, 그러한 식으로 이어집니다. 5분에 이르러서도 추가 대기 시간은 계속해서 줄어들지만 0으로는 안 줄어듭니다.\n\n나중에 데이터 모델링 하는 방법을 보게 될 것입니다. 지금은 복권 당첨을 기다리는 것에 대해 다음으로 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# “로또 당첨” 스타일 대기 시간 — 지금까지 기다린 시간과는 무관하게, 예상 대기 시간은 동일합니다.\n\n로또 데이터에 대해서는 다시 시뮬레이션된 데이터를 생성하는 것이 편합니다. 워싱턴 주의 로또는 당첨 확률을 1 대 27.1로 제공합니다. (가장 흔한 당첨은 $1 베팅에 $3를 지불합니다.) 100만 주 (약 1만 9천 년) 동안 로또를 플레이하고 당첨 사이의 대기 시간에 대한 데이터를 수집해 봅시다.\n\n## “로또 당첨” 스타일 대기 시간 — 파이썬\n\n우리는 100만 주 동안의 로또 플레이를 시뮬레이션합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n시드 = 0\nrng = np.random.default_rng(시드)\n지난주_당첨 = None\n로또_대기 = []\nfor 주차 in range(1_000_000):\n    if rng.uniform(high=27.1) \u003c 1.0:\n        if 지난주_당첨 is not None:\n            로또_대기.append(주차 - 지난주_당첨)\n        지난주_당첨 = 주차\n정렬된_로또_시간_간격 = np.sort(np.array(로또_대기) * 7 * 24 * 60 * 60)\nlotto_df = pd.DataFrame(pd.to_timedelta(정렬된_로또_시간_간격, unit=\"s\"), columns=[\"시간 간격\"])\nprint(lotto_df.describe())\n```\n\n```js\n                        시간 간격\ncount                        36773\nmean   190 days 08:21:00.141951976\nstd    185 days 22:42:41.462765808\nmin                7 days 00:00:00\n25%               56 days 00:00:00\n50%              133 days 00:00:00\n75%              259 days 00:00:00\nmax             2429 days 00:00:00\n```\n\n우리의 최단 가능한 당첨 간격은 7일입니다. 가장 긴 시뮬레이션된 건조 기간은 6년 이상입니다. 중앙값 대기 시간은 133일입니다.\n\n우리는 \"대기-대기\" 테이블을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlotto_days = [0, 7, 7.00001,  2*7, 4*7, 183, 365.25, 2*365.25, 5*365.25]\nlotto_waits = [day * 24 * 60 * 60 for day in lotto_days]\nwait_wait_table(lotto_df, lotto_waits).style.hide(axis=\"index\")\n```\n\n## \"로또 당첨\" 스타일 대기 시간 — 토론\n\n여기 \"대기-대기\" 테이블이 있습니다:\n\n\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_6.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 Markdown 형식으로 작성된 텍스트입니다.\n\n테이블에 따르면 복권은 우리가 이기기까지 얼마나 기다렸는지에 신경을 쓰지 않습니다. 우리가 방금 이겼던지 (지금까지 기다린 시간 ` 1초) 아니면 1년 동안 이기지 못했던지, 우리가 다음 승리까지 기다려야 하는 예상 추가 기다림은 대부분 항상 126일부터 133일 사이입니다.\n\n표의 세 항목은 이상할 수 있습니다. 7일과 7일 1초에서 무슨 일이 일어나는지 생각해보세요. 추가 기다림이 126일에서 거의 즉시 133일 정도로 급격히 증가하는 이유는 무엇일까요? 답은 매주 추첨하는 시점에서 승리까지의 최소 기다림이 0일에서 7일로 변경되기 때문입니다. 그리고 5년은 어떻게 되는 걸까요? 5년을 기다린다면 보통 133일이 걸리는 대신 단지 50일만에 승리를 기대할 수 있는 것일까요? 안타깝게도 아닙니다. 오히려 이는 우리 데이터의 한계를 보여줍니다. 데이터에서는 5년을 기다리는 경우를 세 번만 볼 수 있습니다:\n\n```js\nlotto_df[lotto_df[\"Time Delta\"] \u003e pd.to_timedelta(24*60*60 * 365.25 * 5, unit=\"s\")]\n```\n\n\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_7.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n삼 가지 값은 중위수의 노이즈 추정치로 이어집니다.\n\n지금까지 실제 및 모의 데이터에서 본 것을 요약해보면:\n\n- 위키피디아 편집 — 기다릴수록 기대하는 대기 시간이 길어집니다.\n- 팝콘 — 기다릴수록 기대하는 대기 시간이 줄어듭니다.\n- 복권 당첨 — 지금까지의 대기 시간과 관계없이 기대 대기 시간은 동일합니다.\n\n다음 섹션에서는 모델링의 방법과 그 이유에 대해 살펴보겠습니다. 미국 로또 데이터부터 시작하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 부분에서는 대기 시간 예측을 위한 간단한 표현을 찾아보겠습니다. 예측에는 이러한 간소화가 필요하지 않습니다. 우리가 지금까지 만든 것은 경험적 분포라고 불리며 잘 작동합니다. 그러나 더 간단한 표현은 더 편리할 수 있습니다. 또한 다른 종류의 대기를 이해하기 쉽게 비교할 수 있게 해줄 수도 있습니다.\n\n우리는 세 가지 예제를 살펴보면서 진행할 것입니다. 가장 간단한 것부터 시작하여 (복권 당첨) 가장 복잡한 것(Wikipedia 편집)으로 넘어갈 것입니다. 이전과 마찬가지로 Python 코드(건너뛸 수 있는)와 토론 사이를 오가겠습니다.\n\n먼저 대기 시간 데이터프레임에 누적 분포 열을 추가하는 것부터 시작하겠습니다. 이전에 데이터프레임을 시간 딜타로 정렬했음을 기억해주세요.\n\n```python\nwiki_df['CDF'] = wiki_df['Time Delta'].rank(pct=True)\npopcorn_df['CDF'] = popcorn_df['Time Delta'].rank(pct=True)\nlotto_df['CDF'] = lotto_df['Time Delta'].rank(pct=True)\nwiki_df\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCDF 컬럼은 누적 분포 함수(Cumulative Distribution Function)를 나타내며, 가장 짧은 대기 시간에는 0.0에 가까운 값이 있고, 가장 긴 대기 시간에는 1.0이 있습니다. 다시 말해, 각 행의 순위가 분수로 나타난 것입니다. 위키피디아 데이터프레임은 이제 다음과 같습니다:\n\n\n| Time Delta  |  CDF  |\n|-------------|-------|\n| 0 days 00:00:10 | 0.1 |\n| 0 days 00:00:30 | 0.3 |\n| 0 days 00:01:00 | 0.5 |\n| 0 days 00:02:00 | 0.7 |\n| 0 days 00:05:00 | 0.9 |\n| 0 days 00:10:00 | 1.0 |\n\n\n이제 CDF(누적 분포 함수)를 대기 시간 Time Delta(x-축)에 대해 그릴 수 있습니다. 파이썬에서 다음과 같은 플로팅 코드를 사용할 수 있습니다:\n\n```python\nimport matplotlib.pyplot as plt\n\ndef wait_cdf(title, sorted_df, wait_ticks, dist=None, dist_label=None, left=None, right=None, xscale='linear'):\n    wait_seconds = sorted_df['Time Delta'].dt.total_seconds() # x values\n    cdf = sorted_df['CDF'] # y values\n\n    left = left or wait_seconds.min()\n    right = right or wait_seconds.max()\n\n    plt.figure(figsize=(10, 6))\n    plt.title(title + ' 누적 분포 함수(CDF)')\n    plt.plot(wait_seconds, cdf, marker='.', linestyle=\" \", label='경험적인 CDF')\n\n    if dist is not None:\n        dist_x = np.logspace(np.log10(left), np.log10(right), 100) if xscale == 'log' else np.linspace(left, right, 100)\n        dist_y = dist.cdf(dist_x)\n        plt.plot(dist_x, dist_y, label = dist_label)\n\n    plt.xlabel('대기 시간')\n    plt.ylabel('CDF')\n    plt.xscale(xscale)\n    plt.xticks(wait_ticks, [seconds_to_text(wait_tick) for wait_tick in wait_ticks], rotation=45)\n    plt.xlim(left=left, right=right)\n    plt.grid(True, which=\"both\", ls=\"--\")\n    plt.legend(loc='upper left')\n    plt.show()\n\nwait_cdf(\"로또 당첨\", lotto_df, wiki_wait_ticks, xscale='log')\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로또 당첨과 대기 시간의 CDF 플롯을 로그 스케일로 표시하였습니다:\n\n![Lottery Wins CDF Plot](/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_9.png)\n\n곡선이 간단해 보이니 이에 간단한 곡선을 적합해보려고 합니다. 가장 적합한 곡선은 지수 분포입니다. 이는 대기 시간과 관련된 가장 간단한 일반 함수입니다.\n\nPython의 scipy.stats 패키지를 사용하면 데이터에 지수 곡선을 맞추고 해당 결과 곡선을 Python 객체로 표현하는 것이 쉽습니다. 여기서는 lotto_expon_dist라는 이름으로 이를 표현했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom scipy.stats import expon\n\n_, lotto_e_scale = expon.fit(lotto_df['Time Delta'].dt.total_seconds(), floc=0)\nlotto_expon_dist = expon(scale=lotto_e_scale)\nprint(f\"복권 당첨 지수 중앙값은 {seconds_to_text(lotto_expon_dist.median())} 입니다. 스케일 매개변수는 {seconds_to_text(lotto_e_scale)} 입니다.\")\n```\n\n이 코드는 출력합니다:\n\n복권 당첨 지수 중앙값은 131일 22시간 32분 20초 입니다. 스케일 매개변수는 190일 8시간 21분 입니다.\n\n적합된 곡선의 중앙값은 약 132일로, 경험적인 중앙값인 133일과 근접합니다. 지수곡선을 관행적으로 스케일이라는 단일 숫자로 매개변수화하는데, 이것은 분포의 평균에 해당하지만 평균에서 중앙값을 쉽게 계산하거나 그 반대로 할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로또 당첨금에 대한 경험적 누적 분포(EMCDF) 및 적합 누적 분포(FCDF) 플롯입니다:\n\n```js\nlotto_expon_label = f'ExponentialDistribution(scale={seconds_to_text(lotto_e_scale)})'\nwait_cdf(\"당첨금\", lotto_df, wiki_wait_ticks, dist=lotto_expon_dist, dist_label=lotto_expon_label, xscale='log')\n```\n\n\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_10.png\" /\u003e\n\n둘이 꽤 근접합니다. 왼쪽의 약간의 불일치는 복권 추첨시 모멘트의 즉시 7일 점프에 의해 발생합니다. 이 글에서는 이 작은 불일치를 무시하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 (모의) 복권 당첨 데이터에 지수 함수가 잘 작동합니다. Popcorn과 Wikipedia 데이터에도 어떻게 작동하는지 살펴봅시다. 다음은 이러한 데이터프레임에 지수 분포를 맞추는 코드입니다.\n\n```js\n_, popcorn_e_scale = expon.fit(popcorn_df['Time Delta'].dt.total_seconds(), floc=0)\npopcorn_expon_dist = expon(scale=popcorn_e_scale)\nprint(f\"Popcorn exponential median is {seconds_to_text(popcorn_expon_dist.median())}\")\npopcorn_expon_label = f'ExponentialDistribution(scale={seconds_to_text(popcorn_e_scale)})'\nwait_cdf(\"Popcorn\", popcorn_df, popcorn_ticks, dist=popcorn_expon_dist, dist_label=popcorn_expon_label, left=10, right=6*60, xscale='linear' )\n\n_, wiki_e_scale = expon.fit(wiki_df['Time Delta'].dt.total_seconds(), floc=0)\nwiki_expon_dist = expon(scale=wiki_e_scale)\nprint(f\"Wiki exponential median is {seconds_to_text(wiki_expon_dist.median())}\")\nwiki_expon_label = f'ExponentialDistribution(scale={seconds_to_text(wiki_e_scale)})'\nwait_cdf(\"Wiki Edits\", wiki_df, wiki_wait_ticks, dist=wiki_expon_dist, dist_label=wiki_expon_label, xscale='log', left=60)\n```\n\n그리고 여기가 그림들입니다:\n\n\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_11.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_12.png)\n\n이런, 이 곡선 맞추기 결과는 정말 최악이네요! 문제는 지수 분포가 \"복권 당첨\"과 유사한 데이터만 모델링한다는 것입니다. 구체적으로 말하면, 대기 시간이 이전 대기 시간에 관계없이 기대 대기 시간이 동일한 경우에 해당합니다. 이전 대기 시간을 무시하는 대기 시간에 대해 좌우되는 경우, 이것이 메모리리스(exponential)이라고 불립니다. 또한 연속 분포 중에서 지수 분포는 유일한 메모리리스 분포입니다.\n\n그렇다면 분포에 메모리가 필요하다면 어떨까요? 다음으로 시도할 수 있는 가장 간단한 분포는 와이블(Weibull) 분포입니다.\n\n와이블 분포는 형태(shape)와 척도(scale) 두 매개변수로 매개화됩니다. 복권 데이터로 시작해 보죠:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nfrom scipy.stats import weibull_min\n\nlotto_shape, _, lotto_w_scale = weibull_min.fit(lotto_df['Time Delta'].dt.total_seconds(), floc=0)\nlotto_weibull_dist = weibull_min(c=lotto_shape,scale=lotto_w_scale)\n\nprint(f\"복권 당첨 위블 중앙값은 {seconds_to_text(lotto_weibull_dist.median())}\")\nlotto_weibull_label = f'WeibullDistribution(shape={lotto_shape:.3},scale={seconds_to_text(lotto_w_scale)})'\nwait_cdf(\"복권 당첨\", lotto_df, wiki_wait_ticks, dist=lotto_weibull_dist, dist_label=lotto_weibull_label, xscale='log')\n\n\n이는 지수함수와 유사한 장착 곡선을 생성합니다. 실제로 형태가 1일때 위블 분포는 지수 분포입니다. 여기서 형태는 1.06입니다.\n\n\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_13.png\" /\u003e\n\n팝콘 데이터에 위블을 적합하려고 하면 무엇이 발생하나요?\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\npopcorn_shape, _, popcorn_w_scale = weibull_min.fit(popcorn_df['Time Delta'].dt.total_seconds(), floc=0)\npopcorn_weibull_dist = weibull_min(c=popcorn_shape, scale=popcorn_w_scale)\nprint(f\"Popcorn Weibull median is {seconds_to_text(popcorn_weibull_dist.median())}\")\npopcorn_df_weibull_label = f'Weibull(shape={popcorn_shape:.3}, scale={seconds_to_text(popcorn_w_scale)})'\nwait_cdf(\"Popcorn\", popcorn_df, popcorn_ticks, dist=popcorn_weibull_dist, dist_label=popcorn_df_weibull_label, left=3*60, right=7*60, xscale='linear')\n```\n\n![Image](/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_14.png)\n\n안전하진 않지만, 이 적합은 지수 함수의 적합보다 훨씬 낫습니다. 모양 모수의 값이 20임을 주목하세요. Weibull의 모양 모수가 1보다 큰 경우 \"대기 시간이 길수록 대기 시간을 기대하는 것이 줄어든다\"를 나타냅니다.\n\n마지막으로, 위키피디아 데이터에 Weibull을 시도해보겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nwiki_shape, _, wiki_w_scale = weibull_min.fit(wiki_df['Time Delta'].dt.total_seconds(), floc=0)\nwiki_weibull_dist = weibull_min(c=wiki_shape, scale=wiki_w_scale)\nprint(f\"위키 위불 중앙값은 {seconds_to_text(wiki_weibull_dist.median())}\")\nwiki_df_weibull_label = f'위불(모양={wiki_shape:.3},스케일={seconds_to_text(wiki_w_scale)})'\nwait_cdf(\"위키 편집\", wiki_df, wiki_wait_ticks, dist=wiki_weibull_dist, dist_label=wiki_df_weibull_label, xscale='log', left=60)\n```\n\n\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_15.png\" /\u003e\n\n이 곡선 맞춤은 완벽하지 않지만, 지수함수의 맞춤보다 훨씬 좋습니다. 모양 모수값인 0.292에 주목해보세요. 위불의 모양 모수가 1보다 작을 때는 \"기다린 시간이 길수록 더 기다려야 한다\"는 것을 나타냅니다. 그러나 위불만이 이 특성을 갖고 있는 것은 아닙니다. 이 특성을 갖는 무수히 많은 분포들도 있습니다. 실제로 위키피디아 분포는 이 특성을 갖지만 위불 분포가 아닙니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결론적으로, 당신과 나는 미친 것이 아닙니다(필요에 따라).\n\n우리는 정말 기다린 시간이 길수록 더 기다려야 할 상황이 있는 것을 보았습니다. 위키피디아 편집 사이의 시간 간격에서 경험적으로 확인할 수 있습니다. 또한 Weibull 분포에서 형태 매개변수가 1보다 작은 경우에도 확인할 수 있습니다.\n\n똑같이, 다른 몇 가지 대기 시간에는 \"기다린 시간이 길수록 더 적게 기다리게 된다\"는 규칙이 적용됩니다. 팝콘에서 이 현상을 확인할 수도 있습니다. 또한 Weibull 분포에서 형태 매개변수가 1보다 큰 경우에도 이를 확인할 수 있습니다.\n\n마지막으로, 세 번째 종류의 대기 시간인 \"메모리리스\"도 존재합니다. 이 경우, 지금까지 기다린 시간에 상관없이 기대 대기 시간은 동일합니다. 복권 당첨 간의 시간에서 이를 확인했습니다. 이는 형태 매개변수가 1인 Weibull 분포(지수 분포와 동일)와 관련이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터를 분석할 때 기다릴 데이터가 있는 경우, Weibull 분포를 시도하는 것을 권장합니다. Python을 사용하면 이러한 곡선을 fitting하는 것이 쉽습니다. 그러나 데이터가 Weibull 분포와 잘 맞지 않는 경우에는 Weibull을 사용하지 않는 것이 좋습니다. 대신, 자료 분포를 직접 사용하여 데이터가 스스로 말하도록하십시오.\n\n기다림 시간에 대한 이 여정에 참여해 주셔서 감사합니다. 이제 기다림 시간과 그 분석에 대해 더 잘 이해하게 되었으면 좋겠습니다.\n\n칼을 Medium에서 팔로우해 주세요. 저는 Rust 및 Python에서의 과학적 프로그래밍, 머신러닝 및 통계에 대해 씁니다. 월 한 번 정도 기사를 씁니다.","ogImage":{"url":"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_0.png"},"coverImage":"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_0.png","tag":["Tech"],"readingTime":20},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e파이썬을 사용하여 전자레인지 카운트다운부터 끝나지 않는 전화 대기 시간까지\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e전자레인지 오븐의 카운트다운이 빠르게 0으로 수렴하는 것을 본 적이 있나요? 반면 전화 대기시간은 영원처럼 늘어날까요?\u003c/p\u003e\n\u003cp\u003e한가지 생각해 보세요. 포플콘을 전자레인지에 넣어 가열한 지 겨우 1분 지난 때에는 그릇을 준비하고 서빙할 준비를 합니다. 하지만 전화 대기 중에 1분이 지난다면? 다시 사람과 대화를 나눌 수 있을지 의문이 들 정도입니다. 10분 후, 포플콘을 즐기는 중이겠죠. 하지만 전화는? 대기 음악이 끝도 없는 연옥의 배경음악이 되고 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그리고 팝콘을 기다리는 사이와 전화 대기를 이어가는 서사 속을 맴도는 … 주간 복권. 승리를 기다립니다. 매주 새로운 티켓은 이전 주의 실망과는 거리가 먼 신선한 약속을 간직하고 있습니다.\u003c/p\u003e\n\u003cp\u003e요약하자면, 세 가지 다른 종류의 대기가 나타납니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e“대기 전화”형 — 기다린 시간이 오래 될수록 더 오랫동안 기다릴 것으로 기대합니다.\u003c/li\u003e\n\u003cli\u003e“팝콘”형 — 기다린 시간이 길어질수록 더 짧게 기다릴 것으로 기대합니다.\u003c/li\u003e\n\u003cli\u003e“복권 당첨”형 — 지금까지 기다린 것과 관계없이 예상 대기 시간은 변하지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 대기 시간의 차이는 실제로 존재하는 것일까요, 아니면 마음의 장난일까요? 이 질문에 대한 대답은 두 부분으로 나누어 알아보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e부분 1 — 데이터 분석\u003c/li\u003e\n\u003cli\u003e부분 2 — 데이터 모델링\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e각 부분에서 대기 시간 유형을 각각 살펴보겠습니다. 자세한 Python 코드와 설명이 번갈아 나옵니다. Python에 관심이 있다면 코드 부분을 읽어보세요. 대기 시간에 대해 배우고 싶다면 코드를 건너뛰어도 됩니다.\u003c/p\u003e\n\u003ch1\u003e\"대기 중\" 유형 대기 시간 — 기다린 시간이 길수록 더 오래 기다리게 됩니다.\u003c/h1\u003e\n\u003cp\u003e데이터로 시작하고 싶지만 \"대기 중\" 시간에 대한 데이터가 없습니다. 대신 컴퓨터 파일의 편집 사이의 시간에 대해서 어떠세요? 그런 편집 시간을 보는 곳 한 곳이 바로 위키피디아입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위키피디아 페이지에서 마지막 편집 이후의 시간을 보고 다음 편집까지 얼마나 남았는지 예측할 수 있을까요?\u003c/p\u003e\n\u003cp\u003e위키피디아 페이지 편집에 대한 다음 편집까지의 시간을 어떻게 예측할 수 있을까요? 다음 편집이 언제 발생할지 정확히 예측해 보세요: \"저는 이 페이지가 정확히 5일 3시간 20분 후에 편집될 것으로 예측합니다.\" 하지만 그렇게 구체적으로 예측하는 것은 너무 정확성이 떨어질 것입니다.\u003c/p\u003e\n\u003cp\u003e시간 범위를 예측할 수도 있습니다: \"저는 이 페이지가 다음 100년 이내에 언제든지 편집될 것으로 예측합니다.\" 이렇게 하면 거의 항상 맞을 수 있겠지만, 너무 모호하고 흥미롭지 않습니다.\u003c/p\u003e\n\u003cp\u003e더 실용적인 예측은 \"중위 다음 편집 시간\"의 형태입니다. 이렇게 말할 수 있습니다: \"저는 이 페이지가 다음 5일 3시간 20분 이내에 50% 확률로 편집될 것으로 예측합니다.\" 저, 당신의 적,는 \"이전\" 또는 \"이후\"를 선택할 것입니다. 만약 실제 중위 다음 편집 시간이 3일이라고 가정하면, \"이전\"을 선택할 것입니다. 그럼 우리는 최대 5일 3시간 20분까지 기다립니다. 그 동안 누군가(다시 말해서, 우리 둘을 제외한 누군가) 페이지를 편집하면 상대방이 점수를 획들하고, 그렇지 않으면 당신이 점수를 획득합니다. 이러한 점수 체계를 통해, 만약 제가 당신보다 더 좋은 예측자라면 더 많은 점수를 획득해야 할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e파이썬에 대해 알아보고 이러한 예측을 어떻게 할 수 있는지 살펴봅시다:\u003c/p\u003e\n\u003ch2\u003e“대기 중” 유형의 대기 시간 — Python\u003c/h2\u003e\n\u003cp\u003e아티스트 Marie Cochran에 관한 위키피디아 문서를 살펴보겠습니다. 문서의 개정 내역을 살펴볼 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다양한 위키피디아 문서에서 데이터를 수집하기 위해 작은 파이썬 스크립트를 작성했어요. 다음과 같은 작업을 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Special:Random%EC%9D%84\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://en.wikipedia.org/wiki/Special:Random을\u003c/a\u003e 통해 랜덤한 영어 위키백과 페이지를 선택합니다.\u003c/li\u003e\n\u003cli\u003e해당 페이지의 편집 이력으로 이동합니다. 예를 들어, \u003ca href=\"https://en.wikipedia.org/w/index.php?title=Marie_Cochran\u0026#x26;action=history\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://en.wikipedia.org/w/index.php?title=Marie_Cochran\u0026#x26;action=history\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e(최대) 최근 50회 편집의 날짜와 시간을 추출합니다. 시간은 분 단위로 표시됩니다.\u003c/li\u003e\n\u003cli\u003e문서 제목, 수정 시간, 스크립트 실행 시간으로 구성된 줄을 생성합니다. 모든 시간은 UTC 시간대를 사용합니다. 탭으로 열을 구분합니다.\u003c/li\u003e\n\u003cli\u003e줄을 파일에 추가합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e편집 시간 데이터 일부를 보여드리겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eMarie\u003c/span\u003e_Cochran \u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eJanuary\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e08\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFebruary\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eMarie\u003c/span\u003e_Cochran \u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e27\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSeptember\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2023\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e08\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFebruary\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eMarie\u003c/span\u003e_Cochran \u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e59\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSeptember\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2023\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e08\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFebruary\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eMarie\u003c/span\u003e_Cochran \u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e43\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNovember\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2022\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e08\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFebruary\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e\n...\n\u003cspan class=\"hljs-title class_\"\u003eMarie\u003c/span\u003e_Cochran \u003cspan class=\"hljs-number\"\u003e19\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMarch\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2018\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e08\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFebruary\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003ePeter\u003c/span\u003e_Tennant \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e03\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e29\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eJuly\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2023\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e08\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFebruary\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003ePeter\u003c/span\u003e_Tennant \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e39\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApril\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2022\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e08\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFebruary\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\n\u003cspan class=\"hljs-comment\"\u003e# 데이터 읽기\u003c/span\u003e\nwiki_df = pd.read_csv(\u003cspan class=\"hljs-string\"\u003e\"edit_history.txt\"\u003c/span\u003e, sep=\u003cspan class=\"hljs-string\"\u003e'\\t'\u003c/span\u003e, header=\u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e, names=[\u003cspan class=\"hljs-string\"\u003e\"Title\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Edit DateTime\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Probe DateTime\"\u003c/span\u003e], usecols=[\u003cspan class=\"hljs-string\"\u003e\"Title\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Edit DateTime\"\u003c/span\u003e])\nwiki_df[\u003cspan class=\"hljs-string\"\u003e'Edit DateTime'\u003c/span\u003e] = pd.to_datetime(wiki_df[\u003cspan class=\"hljs-string\"\u003e'Edit DateTime'\u003c/span\u003e]) \u003cspan class=\"hljs-comment\"\u003e# 텍스트를 날짜 및 시간으로 변환\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 'Title' 및 'Edit DateTime'을 기준으로 DataFrame 정렬하여 시간 간격이 올바르게 계산되도록 함\u003c/span\u003e\nwiki_df.sort_values(by=[\u003cspan class=\"hljs-string\"\u003e'Title'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Edit DateTime'\u003c/span\u003e], inplace=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e# 동일한 제목 내에서 연속해서 편집한 경우의 시간 간격 계산\u003c/span\u003e\nwiki_df[\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e] = wiki_df.groupby(\u003cspan class=\"hljs-string\"\u003e'Title'\u003c/span\u003e)[\u003cspan class=\"hljs-string\"\u003e'Edit DateTime'\u003c/span\u003e].diff()\nwiki_df.head()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과로 나온 Pandas 데이터프레임은 샘플된 기사 중 알파벳상으로 가장 빠른 기사(제목 기준)로 시작합니다. 이 기사는 몽골 출신인 매우 키가 큰 사람 인 Öndör Gongor에 대해 독자들에게 알려줍니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e해당 기사의 마지막 50개의 편집 중 첫 번째 편집은 2008년 1월 27일 오후 3시 13분 (UTC)에 이루어졌습니다. 다음 편집은 16분 후에 이루어졌습니다. 그 다음 편집은 데이터의 해상도 한계로 인해 1분 내로 발생하여 0일 00:00:00으로 표시됩니다.\u003c/p\u003e\n\u003cp\u003e계속 처리하면, 각 기사 맨 처음에 나타나는 NaT (not-a-time) 행을 제거해 보겠습니다. 또한 대기 시간에 따라 정렬하고 판다의 인덱스를 재설정할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e 열에서 \u003cspan class=\"hljs-title class_\"\u003eNaT\u003c/span\u003e(시간이 아님) 값이 포함된 행 제거\nwiki_df.\u003cspan class=\"hljs-title function_\"\u003edropna\u003c/span\u003e(subset=[\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e], inplace=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n# 시간 간격으로 정렬 및 인덱스 재설정\nwiki_df.\u003cspan class=\"hljs-title function_\"\u003esort_values\u003c/span\u003e(by=\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e, inplace=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\nwiki_df.\u003cspan class=\"hljs-title function_\"\u003ereset_index\u003c/span\u003e(drop=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, inplace=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003edisplay\u003c/span\u003e(wiki_df)\nwiki_df[\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003edescribe\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이를 통해 다음과 같이 시작하고 끝나는 데이터프레임이 생성됩니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 통계 요약입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecount                          \u003cspan class=\"hljs-number\"\u003e36320\u003c/span\u003e\nmean      \u003cspan class=\"hljs-number\"\u003e92\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e46\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e11.116189427\u003c/span\u003e\nstd      \u003cspan class=\"hljs-number\"\u003e195\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e36\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e52.016155110\u003c/span\u003e\nmin                  \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e%                  \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e27\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%                 \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e05\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e%                \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e45\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e45\u003c/span\u003e\nmax               \u003cspan class=\"hljs-number\"\u003e4810\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e17\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e39\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e조사 결과, 샘플링된 대기 시간은 0일 00:00:00(즉, 1분 미만)부터 13년 이상까지 다양합니다. (13년 편집 대기는 버지니아 대학교의 건물에 관한 기사였습니다.) 편집의 1/4은 이전 편집 후 27분 이내에 발생합니다. 편집 간 중위값은 약 15일을 조금 넘습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e조금 더 발전하기 전에, 웨이팅 시간을 향상시키고 싶은데요. 다음과 같이 작은 함수를 사용해서 웨이팅 시간을 표시할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eseconds_to_text\u003c/span\u003e(seconds):\n    seconds = \u003cspan class=\"hljs-title function_\"\u003eround\u003c/span\u003e(seconds)\n    result = []\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e unit_name, unit_seconds \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e [(\u003cspan class=\"hljs-string\"\u003e'y'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e86400\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e365.25\u003c/span\u003e),(\u003cspan class=\"hljs-string\"\u003e'd'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e86400\u003c/span\u003e),(\u003cspan class=\"hljs-string\"\u003e'h'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3600\u003c/span\u003e),(\u003cspan class=\"hljs-string\"\u003e'm'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e),(\u003cspan class=\"hljs-string\"\u003e's'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)]:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e seconds \u003e= \u003cspan class=\"hljs-attr\"\u003eunit_seconds\u003c/span\u003e:\n            unit_value, seconds = \u003cspan class=\"hljs-title function_\"\u003edivmod\u003c/span\u003e(seconds, unit_seconds)\n            result.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{int(unit_value)}{unit_name}\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e' '\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(result) \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e result \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;1s\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003eseconds_to_text\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 \u003ccode\u003eseconds_to_text\u003c/code\u003e 함수는 100초를 \u003ccode\u003e1m 40s\u003c/code\u003e로 표시합니다.\u003c/p\u003e\n\u003cp\u003e이제 위키피디아 데이터를 위한 \"웨이팅 테이블\"을 만들 수 있습니다. 기존에 기사의 다음 편집을 기다린 시간을 주면, 이 테이블은 중간 추가로 기다려야 할 시간을 알려줍니다. (\"중간값\"은 이 시간보다 덜 기다릴 확률이 50%이고, 시간이 더 걸리는 확률이 50%라는 것을 의미합니다.)\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\ndef \u003cspan class=\"hljs-title function_\"\u003ewait_wait_table\u003c/span\u003e(df, wait_ticks):\n    sorted_time_deltas_seconds = df[\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003edt\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etotal_seconds\u003c/span\u003e()\n    results = []\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e wait_tick \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewait_ticks\u003c/span\u003e:\n        greater_or_equal_values = sorted_time_deltas_seconds[sorted_time_deltas_seconds \u003e= wait_tick]\n        median_wait = np.\u003cspan class=\"hljs-title function_\"\u003emedian\u003c/span\u003e(greater_or_equal_values)\n        additional_wait = median_wait - wait_tick\n        results.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"Wait So Far\"\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003eseconds_to_text\u003c/span\u003e(wait_tick), \u003cspan class=\"hljs-string\"\u003e\"Median Additional Wait\"\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003eseconds_to_text\u003c/span\u003e(additional_wait)})\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(results)\n\nwiki_wait_ticks = [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3600\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3600\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e86400\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e86400\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e86400\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e86400\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e86400\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e365.25\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e86400\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e365.25\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e86400\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e365.25\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e]\nwiki_wait_tick_labels = [\u003cspan class=\"hljs-title function_\"\u003eseconds_to_text\u003c/span\u003e(wait_tick) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e wait_tick \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e wiki_wait_ticks]\n\u003cspan class=\"hljs-title function_\"\u003ewait_wait_table\u003c/span\u003e(wiki_df, wiki_wait_ticks).\u003cspan class=\"hljs-property\"\u003estyle\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehide\u003c/span\u003e(axis=\u003cspan class=\"hljs-string\"\u003e\"index\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 이 표의 출력에 대해 알아보겠습니다.\u003c/p\u003e\n\u003ch2\u003e\"대기 중\" 유형의 대기 - 토론\u003c/h2\u003e\n\u003cp\u003e앞의 파이썬 코드는 이 표를 생성합니다. 이것을 \"대기-대기\" 표라고 부르죠.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_4.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e만약 아무도 기다리지 않았다면(다시 말해, 누군가가 페이지를 편집했다) 다음 편집은 15일이 넘게 기다릴 것으로 예상됩니다. 그러나 1분 후에도 누군가 기사를 편집하지 않았다면, 19일을 기다려야 할 것으로 예상됩니다. 따라서 1분 기다리면 예상 추가 대기 시간이 거의 4일 더 늘어납니다. 한 시간 후에도 누구도 기사를 편집하지 않았다면, 예상 추가 대기 시간은 47일로 두 배 넘게 늘어납니다.\u003c/p\u003e\n\u003cp\u003e이 현상을 생각하는 한 가지 방법은 다음 편집을 기다리기 시작할 때 우리가 어떤 종류의 페이지에 있는지 모르는 것입니다. 이것이 테일러 스위프트와 같은 핫 팝컬쳐 주제의 기사인가요? 아니면 5000명 대학의 건물인 '로턴다(The Rotunda)'와 같은 니치하고 느린 주제인가요? 수정이 일어나지 않는 매 분이 지날수록, 확률은 이것이 테일러 스위프트와 같은 기사에서 '로턴다(The Rotunda)'와 같은 기사로 이동합니다.\u003c/p\u003e\n\u003cp\u003e마찬가지로, 고객 서비스에 전화하고 대기시간이 발생할 때 - 처음에는 어떤 종류의 고객 서비스를 기다리고 있는지 모릅니다. 그러나 매 분이 지날 때마다, 우리는 서서히 나쁜, 느린 고객 서비스를 기다리고 있다는 것을 알게 됩니다. 따라서 예상 추가 대기 시간은 늘어납니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e지금까지는 데이터를 직접 사용했습니다. 데이터를 확률 분포로 모델링해 볼 수도 있습니다. 그러나 모델링으로 넘어가기 전에 다른 두 예제인 마이크로파 팝콘 요리와 복권 당첨을 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003e\"팝콘\"형 기다림 - 기다릴수록 덜 기다리는 것을 기대합니다.\u003c/h1\u003e\n\u003cp\u003e위키피디아 편집을 기다리는 기법을 마이크로파 팝콘 조리를 기다리는 것에 적용해 봅시다. (매력적일지도 모르는) 실제 데이터를 수집하는 대신 모의 데이터를 시뮬레이션하는 것으로 만족합니다. 난수 생성기를 사용할 것입니다. 요리 시간은 센서를 기반으로 하는 것이라 가정하며, 5분에서 15초 차이가 날 수 있다고 가정합니다.\u003c/p\u003e\n\u003ch2\u003e\"팝콘\"형 기다림 - 파이썬\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e파이썬에서 특히:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eseed = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\nrng = np.random.default_rng(seed)\nsorted_popcorn_time_deltas = np.sort(rng.normal(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e30_000\u003c/span\u003e))\npopcorn_df = pd.DataFrame(pd.to_timedelta(sorted_popcorn_time_deltas, unit=\u003cspan class=\"hljs-string\"\u003e\"s\"\u003c/span\u003e), columns=[\u003cspan class=\"hljs-string\"\u003e\"Time Delta\"\u003c/span\u003e])\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(popcorn_df.describe())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 다음과 같은 통계 요약이 포함된 판다 데이터프레임을 생성합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e                  Time Delta\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecount                      30000\nmean   0 days 00:05:00.060355606\nstd    0 days 00:00:14.956424467\nmin    0 days 00:03:52.588244397\n25%    0 days 00:04:50.011437922\n50%    0 days 00:04:59.971380399\n75%    0 days 00:05:10.239357827\nmax    0 days 00:05:59.183245298\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예상대로, 이 정규 분포에서 데이터를 생성할 때 평균은 5분이고 표준 편차는 약 15초입니다. 우리가 시뮬레이션한 대기 시간은 3분 52초에서 6분까지 범위에 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 \"대기-대기\" 테이블을 생성할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003ewait_wait_table\u003c/span\u003e(popcorn_df, [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e]).\u003cspan class=\"hljs-property\"\u003estyle\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehide\u003c/span\u003e(axis=\u003cspan class=\"hljs-string\"\u003e\"index\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e\"팝콘\" 형태의 대기 시간 — 토론\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리의 \"기다려-기다려\" 소프트웨어는 팝콘 테이블을 아래와 같이 보여줍니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_5.png\" alt=\"팝콘 대기 시간\"\u003e\u003c/p\u003e\n\u003cp\u003e우리의 테이블에 따르면, 처음에는 5분 기다림을 예상합니다. 그리고 10초를 기다린 후에는 추가로 기대되는 대기 시간이 정확히 10초 줄어듭니다 (4분 50초로). 1분을 기다린 후에는 추가 대기 시간이 4분으로 줄어들고, 그러한 식으로 이어집니다. 5분에 이르러서도 추가 대기 시간은 계속해서 줄어들지만 0으로는 안 줄어듭니다.\u003c/p\u003e\n\u003cp\u003e나중에 데이터 모델링 하는 방법을 보게 될 것입니다. 지금은 복권 당첨을 기다리는 것에 대해 다음으로 살펴봅시다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e“로또 당첨” 스타일 대기 시간 — 지금까지 기다린 시간과는 무관하게, 예상 대기 시간은 동일합니다.\u003c/h1\u003e\n\u003cp\u003e로또 데이터에 대해서는 다시 시뮬레이션된 데이터를 생성하는 것이 편합니다. 워싱턴 주의 로또는 당첨 확률을 1 대 27.1로 제공합니다. (가장 흔한 당첨은 $1 베팅에 $3를 지불합니다.) 100만 주 (약 1만 9천 년) 동안 로또를 플레이하고 당첨 사이의 대기 시간에 대한 데이터를 수집해 봅시다.\u003c/p\u003e\n\u003ch2\u003e“로또 당첨” 스타일 대기 시간 — 파이썬\u003c/h2\u003e\n\u003cp\u003e우리는 100만 주 동안의 로또 플레이를 시뮬레이션합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e시드 = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\nrng = np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edefault_rng\u003c/span\u003e(시드)\n지난주_당첨 = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n로또_대기 = []\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e 주차 \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1_000_000\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e rng.\u003cspan class=\"hljs-title function_\"\u003euniform\u003c/span\u003e(high=\u003cspan class=\"hljs-number\"\u003e27.1\u003c/span\u003e) \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e 지난주_당첨 is not \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n            로또_대기.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(주차 - 지난주_당첨)\n        지난주_당첨 = 주차\n정렬된_로또_시간_간격 = np.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(로또_대기) * \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e)\nlotto_df = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(pd.\u003cspan class=\"hljs-title function_\"\u003eto_timedelta\u003c/span\u003e(정렬된_로또_시간_간격, unit=\u003cspan class=\"hljs-string\"\u003e\"s\"\u003c/span\u003e), columns=[\u003cspan class=\"hljs-string\"\u003e\"시간 간격\"\u003c/span\u003e])\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(lotto_df.\u003cspan class=\"hljs-title function_\"\u003edescribe\u003c/span\u003e())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e                        시간 간격\ncount                        \u003cspan class=\"hljs-number\"\u003e36773\u003c/span\u003e\nmean   \u003cspan class=\"hljs-number\"\u003e190\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e08\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.141951976\u003c/span\u003e\nstd    \u003cspan class=\"hljs-number\"\u003e185\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e41.462765808\u003c/span\u003e\nmin                \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e%               \u003cspan class=\"hljs-number\"\u003e56\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e%              \u003cspan class=\"hljs-number\"\u003e133\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e%              \u003cspan class=\"hljs-number\"\u003e259\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e\nmax             \u003cspan class=\"hljs-number\"\u003e2429\u003c/span\u003e days \u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리의 최단 가능한 당첨 간격은 7일입니다. 가장 긴 시뮬레이션된 건조 기간은 6년 이상입니다. 중앙값 대기 시간은 133일입니다.\u003c/p\u003e\n\u003cp\u003e우리는 \"대기-대기\" 테이블을 생성합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003elotto_days = [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7.00001\u003c/span\u003e,  \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e183\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e365.25\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e365.25\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e365.25\u003c/span\u003e]\nlotto_waits = [day * \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e day \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e lotto_days]\n\u003cspan class=\"hljs-title function_\"\u003ewait_wait_table\u003c/span\u003e(lotto_df, lotto_waits).\u003cspan class=\"hljs-property\"\u003estyle\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehide\u003c/span\u003e(axis=\u003cspan class=\"hljs-string\"\u003e\"index\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e\"로또 당첨\" 스타일 대기 시간 — 토론\u003c/h2\u003e\n\u003cp\u003e여기 \"대기-대기\" 테이블이 있습니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_6.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음은 Markdown 형식으로 작성된 텍스트입니다.\u003c/p\u003e\n\u003cp\u003e테이블에 따르면 복권은 우리가 이기기까지 얼마나 기다렸는지에 신경을 쓰지 않습니다. 우리가 방금 이겼던지 (지금까지 기다린 시간 ` 1초) 아니면 1년 동안 이기지 못했던지, 우리가 다음 승리까지 기다려야 하는 예상 추가 기다림은 대부분 항상 126일부터 133일 사이입니다.\u003c/p\u003e\n\u003cp\u003e표의 세 항목은 이상할 수 있습니다. 7일과 7일 1초에서 무슨 일이 일어나는지 생각해보세요. 추가 기다림이 126일에서 거의 즉시 133일 정도로 급격히 증가하는 이유는 무엇일까요? 답은 매주 추첨하는 시점에서 승리까지의 최소 기다림이 0일에서 7일로 변경되기 때문입니다. 그리고 5년은 어떻게 되는 걸까요? 5년을 기다린다면 보통 133일이 걸리는 대신 단지 50일만에 승리를 기대할 수 있는 것일까요? 안타깝게도 아닙니다. 오히려 이는 우리 데이터의 한계를 보여줍니다. 데이터에서는 5년을 기다리는 경우를 세 번만 볼 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003elotto_df[lotto_df[\u003cspan class=\"hljs-string\"\u003e\"Time Delta\"\u003c/span\u003e] \u003e pd.\u003cspan class=\"hljs-title function_\"\u003eto_timedelta\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e365.25\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, unit=\u003cspan class=\"hljs-string\"\u003e\"s\"\u003c/span\u003e)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_7.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e삼 가지 값은 중위수의 노이즈 추정치로 이어집니다.\u003c/p\u003e\n\u003cp\u003e지금까지 실제 및 모의 데이터에서 본 것을 요약해보면:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e위키피디아 편집 — 기다릴수록 기대하는 대기 시간이 길어집니다.\u003c/li\u003e\n\u003cli\u003e팝콘 — 기다릴수록 기대하는 대기 시간이 줄어듭니다.\u003c/li\u003e\n\u003cli\u003e복권 당첨 — 지금까지의 대기 시간과 관계없이 기대 대기 시간은 동일합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 섹션에서는 모델링의 방법과 그 이유에 대해 살펴보겠습니다. 미국 로또 데이터부터 시작하겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 부분에서는 대기 시간 예측을 위한 간단한 표현을 찾아보겠습니다. 예측에는 이러한 간소화가 필요하지 않습니다. 우리가 지금까지 만든 것은 경험적 분포라고 불리며 잘 작동합니다. 그러나 더 간단한 표현은 더 편리할 수 있습니다. 또한 다른 종류의 대기를 이해하기 쉽게 비교할 수 있게 해줄 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e우리는 세 가지 예제를 살펴보면서 진행할 것입니다. 가장 간단한 것부터 시작하여 (복권 당첨) 가장 복잡한 것(Wikipedia 편집)으로 넘어갈 것입니다. 이전과 마찬가지로 Python 코드(건너뛸 수 있는)와 토론 사이를 오가겠습니다.\u003c/p\u003e\n\u003cp\u003e먼저 대기 시간 데이터프레임에 누적 분포 열을 추가하는 것부터 시작하겠습니다. 이전에 데이터프레임을 시간 딜타로 정렬했음을 기억해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003ewiki_df[\u003cspan class=\"hljs-string\"\u003e'CDF'\u003c/span\u003e] = wiki_df[\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e].rank(pct=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\npopcorn_df[\u003cspan class=\"hljs-string\"\u003e'CDF'\u003c/span\u003e] = popcorn_df[\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e].rank(pct=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\nlotto_df[\u003cspan class=\"hljs-string\"\u003e'CDF'\u003c/span\u003e] = lotto_df[\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e].rank(pct=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\nwiki_df\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eCDF 컬럼은 누적 분포 함수(Cumulative Distribution Function)를 나타내며, 가장 짧은 대기 시간에는 0.0에 가까운 값이 있고, 가장 긴 대기 시간에는 1.0이 있습니다. 다시 말해, 각 행의 순위가 분수로 나타난 것입니다. 위키피디아 데이터프레임은 이제 다음과 같습니다:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eTime Delta\u003c/th\u003e\u003cth\u003eCDF\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e0 days 00:00:10\u003c/td\u003e\u003ctd\u003e0.1\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e0 days 00:00:30\u003c/td\u003e\u003ctd\u003e0.3\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e0 days 00:01:00\u003c/td\u003e\u003ctd\u003e0.5\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e0 days 00:02:00\u003c/td\u003e\u003ctd\u003e0.7\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e0 days 00:05:00\u003c/td\u003e\u003ctd\u003e0.9\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e0 days 00:10:00\u003c/td\u003e\u003ctd\u003e1.0\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e이제 CDF(누적 분포 함수)를 대기 시간 Time Delta(x-축)에 대해 그릴 수 있습니다. 파이썬에서 다음과 같은 플로팅 코드를 사용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.pyplot \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ewait_cdf\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etitle, sorted_df, wait_ticks, dist=\u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e, dist_label=\u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e, left=\u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e, right=\u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e, xscale=\u003cspan class=\"hljs-string\"\u003e'linear'\u003c/span\u003e\u003c/span\u003e):\n    wait_seconds = sorted_df[\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e].dt.total_seconds() \u003cspan class=\"hljs-comment\"\u003e# x values\u003c/span\u003e\n    cdf = sorted_df[\u003cspan class=\"hljs-string\"\u003e'CDF'\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e# y values\u003c/span\u003e\n\n    left = left \u003cspan class=\"hljs-keyword\"\u003eor\u003c/span\u003e wait_seconds.\u003cspan class=\"hljs-built_in\"\u003emin\u003c/span\u003e()\n    right = right \u003cspan class=\"hljs-keyword\"\u003eor\u003c/span\u003e wait_seconds.\u003cspan class=\"hljs-built_in\"\u003emax\u003c/span\u003e()\n\n    plt.figure(figsize=(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e))\n    plt.title(title + \u003cspan class=\"hljs-string\"\u003e' 누적 분포 함수(CDF)'\u003c/span\u003e)\n    plt.plot(wait_seconds, cdf, marker=\u003cspan class=\"hljs-string\"\u003e'.'\u003c/span\u003e, linestyle=\u003cspan class=\"hljs-string\"\u003e\" \"\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e'경험적인 CDF'\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e dist \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enot\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        dist_x = np.logspace(np.log10(left), np.log10(right), \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e xscale == \u003cspan class=\"hljs-string\"\u003e'log'\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e np.linspace(left, right, \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e)\n        dist_y = dist.cdf(dist_x)\n        plt.plot(dist_x, dist_y, label = dist_label)\n\n    plt.xlabel(\u003cspan class=\"hljs-string\"\u003e'대기 시간'\u003c/span\u003e)\n    plt.ylabel(\u003cspan class=\"hljs-string\"\u003e'CDF'\u003c/span\u003e)\n    plt.xscale(xscale)\n    plt.xticks(wait_ticks, [seconds_to_text(wait_tick) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e wait_tick \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e wait_ticks], rotation=\u003cspan class=\"hljs-number\"\u003e45\u003c/span\u003e)\n    plt.xlim(left=left, right=right)\n    plt.grid(\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e, which=\u003cspan class=\"hljs-string\"\u003e\"both\"\u003c/span\u003e, ls=\u003cspan class=\"hljs-string\"\u003e\"--\"\u003c/span\u003e)\n    plt.legend(loc=\u003cspan class=\"hljs-string\"\u003e'upper left'\u003c/span\u003e)\n    plt.show()\n\nwait_cdf(\u003cspan class=\"hljs-string\"\u003e\"로또 당첨\"\u003c/span\u003e, lotto_df, wiki_wait_ticks, xscale=\u003cspan class=\"hljs-string\"\u003e'log'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e로또 당첨과 대기 시간의 CDF 플롯을 로그 스케일로 표시하였습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_9.png\" alt=\"Lottery Wins CDF Plot\"\u003e\u003c/p\u003e\n\u003cp\u003e곡선이 간단해 보이니 이에 간단한 곡선을 적합해보려고 합니다. 가장 적합한 곡선은 지수 분포입니다. 이는 대기 시간과 관련된 가장 간단한 일반 함수입니다.\u003c/p\u003e\n\u003cp\u003ePython의 scipy.stats 패키지를 사용하면 데이터에 지수 곡선을 맞추고 해당 결과 곡선을 Python 객체로 표현하는 것이 쉽습니다. 여기서는 lotto_expon_dist라는 이름으로 이를 표현했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e scipy.stats \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e expon\n\n_, lotto_e_scale = expon.fit(lotto_df[\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e].dt.total_seconds(), floc=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\nlotto_expon_dist = expon(scale=lotto_e_scale)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"복권 당첨 지수 중앙값은 \u003cspan class=\"hljs-subst\"\u003e{seconds_to_text(lotto_expon_dist.median())}\u003c/span\u003e 입니다. 스케일 매개변수는 \u003cspan class=\"hljs-subst\"\u003e{seconds_to_text(lotto_e_scale)}\u003c/span\u003e 입니다.\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 출력합니다:\u003c/p\u003e\n\u003cp\u003e복권 당첨 지수 중앙값은 131일 22시간 32분 20초 입니다. 스케일 매개변수는 190일 8시간 21분 입니다.\u003c/p\u003e\n\u003cp\u003e적합된 곡선의 중앙값은 약 132일로, 경험적인 중앙값인 133일과 근접합니다. 지수곡선을 관행적으로 스케일이라는 단일 숫자로 매개변수화하는데, 이것은 분포의 평균에 해당하지만 평균에서 중앙값을 쉽게 계산하거나 그 반대로 할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e로또 당첨금에 대한 경험적 누적 분포(EMCDF) 및 적합 누적 분포(FCDF) 플롯입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003elotto_expon_label = f\u003cspan class=\"hljs-string\"\u003e'ExponentialDistribution(scale={seconds_to_text(lotto_e_scale)})'\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003ewait_cdf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"당첨금\"\u003c/span\u003e, lotto_df, wiki_wait_ticks, dist=lotto_expon_dist, dist_label=lotto_expon_label, xscale=\u003cspan class=\"hljs-string\"\u003e'log'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_10.png\"\u003e\n\u003cp\u003e둘이 꽤 근접합니다. 왼쪽의 약간의 불일치는 복권 추첨시 모멘트의 즉시 7일 점프에 의해 발생합니다. 이 글에서는 이 작은 불일치를 무시하겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리 (모의) 복권 당첨 데이터에 지수 함수가 잘 작동합니다. Popcorn과 Wikipedia 데이터에도 어떻게 작동하는지 살펴봅시다. 다음은 이러한 데이터프레임에 지수 분포를 맞추는 코드입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e_, popcorn_e_scale = expon.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(popcorn_df[\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003edt\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etotal_seconds\u003c/span\u003e(), floc=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\npopcorn_expon_dist = \u003cspan class=\"hljs-title function_\"\u003eexpon\u003c/span\u003e(scale=popcorn_e_scale)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"Popcorn exponential median is {seconds_to_text(popcorn_expon_dist.median())}\"\u003c/span\u003e)\npopcorn_expon_label = f\u003cspan class=\"hljs-string\"\u003e'ExponentialDistribution(scale={seconds_to_text(popcorn_e_scale)})'\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003ewait_cdf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Popcorn\"\u003c/span\u003e, popcorn_df, popcorn_ticks, dist=popcorn_expon_dist, dist_label=popcorn_expon_label, left=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, right=\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e, xscale=\u003cspan class=\"hljs-string\"\u003e'linear'\u003c/span\u003e )\n\n_, wiki_e_scale = expon.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(wiki_df[\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003edt\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etotal_seconds\u003c/span\u003e(), floc=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\nwiki_expon_dist = \u003cspan class=\"hljs-title function_\"\u003eexpon\u003c/span\u003e(scale=wiki_e_scale)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"Wiki exponential median is {seconds_to_text(wiki_expon_dist.median())}\"\u003c/span\u003e)\nwiki_expon_label = f\u003cspan class=\"hljs-string\"\u003e'ExponentialDistribution(scale={seconds_to_text(wiki_e_scale)})'\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003ewait_cdf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Wiki Edits\"\u003c/span\u003e, wiki_df, wiki_wait_ticks, dist=wiki_expon_dist, dist_label=wiki_expon_label, xscale=\u003cspan class=\"hljs-string\"\u003e'log'\u003c/span\u003e, left=\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 여기가 그림들입니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_11.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_12.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이런, 이 곡선 맞추기 결과는 정말 최악이네요! 문제는 지수 분포가 \"복권 당첨\"과 유사한 데이터만 모델링한다는 것입니다. 구체적으로 말하면, 대기 시간이 이전 대기 시간에 관계없이 기대 대기 시간이 동일한 경우에 해당합니다. 이전 대기 시간을 무시하는 대기 시간에 대해 좌우되는 경우, 이것이 메모리리스(exponential)이라고 불립니다. 또한 연속 분포 중에서 지수 분포는 유일한 메모리리스 분포입니다.\u003c/p\u003e\n\u003cp\u003e그렇다면 분포에 메모리가 필요하다면 어떨까요? 다음으로 시도할 수 있는 가장 간단한 분포는 와이블(Weibull) 분포입니다.\u003c/p\u003e\n\u003cp\u003e와이블 분포는 형태(shape)와 척도(scale) 두 매개변수로 매개화됩니다. 복권 데이터로 시작해 보죠:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003efrom scipy.stats import weibull_min\u003c/p\u003e\n\u003cp\u003elotto_shape, _, lotto_w_scale = weibull_min.fit(lotto_df['Time Delta'].dt.total_seconds(), floc=0)\nlotto_weibull_dist = weibull_min(c=lotto_shape,scale=lotto_w_scale)\u003c/p\u003e\n\u003cp\u003eprint(f\"복권 당첨 위블 중앙값은 {seconds_to_text(lotto_weibull_dist.median())}\")\nlotto_weibull_label = f'WeibullDistribution(shape={lotto_shape:.3},scale={seconds_to_text(lotto_w_scale)})'\nwait_cdf(\"복권 당첨\", lotto_df, wiki_wait_ticks, dist=lotto_weibull_dist, dist_label=lotto_weibull_label, xscale='log')\u003c/p\u003e\n\u003cp\u003e이는 지수함수와 유사한 장착 곡선을 생성합니다. 실제로 형태가 1일때 위블 분포는 지수 분포입니다. 여기서 형태는 1.06입니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_13.png\"\u003e\n\u003cp\u003e팝콘 데이터에 위블을 적합하려고 하면 무엇이 발생하나요?\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003epopcorn_shape, _, popcorn_w_scale = weibull_min.fit(popcorn_df[\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e].dt.total_seconds(), floc=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\npopcorn_weibull_dist = weibull_min(c=popcorn_shape, scale=popcorn_w_scale)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"Popcorn Weibull median is \u003cspan class=\"hljs-subst\"\u003e{seconds_to_text(popcorn_weibull_dist.median())}\u003c/span\u003e\"\u003c/span\u003e)\npopcorn_df_weibull_label = \u003cspan class=\"hljs-string\"\u003ef'Weibull(shape=\u003cspan class=\"hljs-subst\"\u003e{popcorn_shape:\u003cspan class=\"hljs-number\"\u003e.3\u003c/span\u003e}\u003c/span\u003e, scale=\u003cspan class=\"hljs-subst\"\u003e{seconds_to_text(popcorn_w_scale)}\u003c/span\u003e)'\u003c/span\u003e\nwait_cdf(\u003cspan class=\"hljs-string\"\u003e\"Popcorn\"\u003c/span\u003e, popcorn_df, popcorn_ticks, dist=popcorn_weibull_dist, dist_label=popcorn_df_weibull_label, left=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e, right=\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e, xscale=\u003cspan class=\"hljs-string\"\u003e'linear'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_14.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e안전하진 않지만, 이 적합은 지수 함수의 적합보다 훨씬 낫습니다. 모양 모수의 값이 20임을 주목하세요. Weibull의 모양 모수가 1보다 큰 경우 \"대기 시간이 길수록 대기 시간을 기대하는 것이 줄어든다\"를 나타냅니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, 위키피디아 데이터에 Weibull을 시도해보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ewiki_shape, _, wiki_w_scale = weibull_min.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(wiki_df[\u003cspan class=\"hljs-string\"\u003e'Time Delta'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003edt\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etotal_seconds\u003c/span\u003e(), floc=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\nwiki_weibull_dist = \u003cspan class=\"hljs-title function_\"\u003eweibull_min\u003c/span\u003e(c=wiki_shape, scale=wiki_w_scale)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"위키 위불 중앙값은 {seconds_to_text(wiki_weibull_dist.median())}\"\u003c/span\u003e)\nwiki_df_weibull_label = f\u003cspan class=\"hljs-string\"\u003e'위불(모양={wiki_shape:.3},스케일={seconds_to_text(wiki_w_scale)})'\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003ewait_cdf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"위키 편집\"\u003c/span\u003e, wiki_df, wiki_wait_ticks, dist=wiki_weibull_dist, dist_label=wiki_df_weibull_label, xscale=\u003cspan class=\"hljs-string\"\u003e'log'\u003c/span\u003e, left=\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-05-17-AWhimsicalJourneyThroughWaitTimes_15.png\"\u003e\n\u003cp\u003e이 곡선 맞춤은 완벽하지 않지만, 지수함수의 맞춤보다 훨씬 좋습니다. 모양 모수값인 0.292에 주목해보세요. 위불의 모양 모수가 1보다 작을 때는 \"기다린 시간이 길수록 더 기다려야 한다\"는 것을 나타냅니다. 그러나 위불만이 이 특성을 갖고 있는 것은 아닙니다. 이 특성을 갖는 무수히 많은 분포들도 있습니다. 실제로 위키피디아 분포는 이 특성을 갖지만 위불 분포가 아닙니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e결론적으로, 당신과 나는 미친 것이 아닙니다(필요에 따라).\u003c/p\u003e\n\u003cp\u003e우리는 정말 기다린 시간이 길수록 더 기다려야 할 상황이 있는 것을 보았습니다. 위키피디아 편집 사이의 시간 간격에서 경험적으로 확인할 수 있습니다. 또한 Weibull 분포에서 형태 매개변수가 1보다 작은 경우에도 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e똑같이, 다른 몇 가지 대기 시간에는 \"기다린 시간이 길수록 더 적게 기다리게 된다\"는 규칙이 적용됩니다. 팝콘에서 이 현상을 확인할 수도 있습니다. 또한 Weibull 분포에서 형태 매개변수가 1보다 큰 경우에도 이를 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, 세 번째 종류의 대기 시간인 \"메모리리스\"도 존재합니다. 이 경우, 지금까지 기다린 시간에 상관없이 기대 대기 시간은 동일합니다. 복권 당첨 간의 시간에서 이를 확인했습니다. 이는 형태 매개변수가 1인 Weibull 분포(지수 분포와 동일)와 관련이 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e데이터를 분석할 때 기다릴 데이터가 있는 경우, Weibull 분포를 시도하는 것을 권장합니다. Python을 사용하면 이러한 곡선을 fitting하는 것이 쉽습니다. 그러나 데이터가 Weibull 분포와 잘 맞지 않는 경우에는 Weibull을 사용하지 않는 것이 좋습니다. 대신, 자료 분포를 직접 사용하여 데이터가 스스로 말하도록하십시오.\u003c/p\u003e\n\u003cp\u003e기다림 시간에 대한 이 여정에 참여해 주셔서 감사합니다. 이제 기다림 시간과 그 분석에 대해 더 잘 이해하게 되었으면 좋겠습니다.\u003c/p\u003e\n\u003cp\u003e칼을 Medium에서 팔로우해 주세요. 저는 Rust 및 Python에서의 과학적 프로그래밍, 머신러닝 및 통계에 대해 씁니다. 월 한 번 정도 기사를 씁니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-AWhimsicalJourneyThroughWaitTimes"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>