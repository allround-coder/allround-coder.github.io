<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Angular 폼의 새로운 통합된 컨트롤 상태 변경 이벤트 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Angular 폼의 새로운 통합된 컨트롤 상태 변경 이벤트 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Angular 폼의 새로운 통합된 컨트롤 상태 변경 이벤트 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents" data-gatsby-head="true"/><meta name="twitter:title" content="Angular 폼의 새로운 통합된 컨트롤 상태 변경 이벤트 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 00:32" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Angular 폼의 새로운 통합된 컨트롤 상태 변경 이벤트</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Angular 폼의 새로운 통합된 컨트롤 상태 변경 이벤트" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>Angular v18의 릴리스는 프레임워크에 흥미로운 새로운 기능과 개선 사항을 도입했습니다.</p>
<p>그 중 하나의 기능은 특히 유망하며, Angular Forms 라이브러리 내에서 새로운 기능을 소개하여 AbstractControl 클래스를 통해 통합된 컨트롤 상태 변경 이벤트를 향상시킵니다.</p>
<p>내 글에서는 주제에 집중하기 전에 기본 사항을 먼저 검토하는 것이 관습입니다. 이는 다가오는 내용을 더 잘 이해하도록 도와줄 것입니다.</p>
<h1>Angular 반응형 Forms: 기본 사항</h1>
<p>앵귤러 반응형 폼은 양식 입력을 처리하는 모델 중심 접근 방식을 제공하며, 데이터 모델에 대한 동기식 액세스, 입력 유효성 검사 및 변경 추적을 위한 강력한 도구를 Observables를 통해 제공합니다.</p>
<p>반응형 폼 데이터 모델은 다음 클래스를 사용하여 구성됩니다:</p>
<ul>
<li>FormControl: 단일 입력 양식을 나타냅니다. 값은 기본 유형입니다.</li>
<li>FormGroup: FormControl 그룹을 나타냅니다. 값은 객체입니다.</li>
<li>FormArray: FormControl 목록을 나타냅니다. 값은 배열입니다.</li>
</ul>
<p>FormGroup으로 나타낼 수 있는 폼의 일반적인 예시는 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FormGroup</span>, <span class="hljs-title class_">FormControl</span>, <span class="hljs-title class_">FormArray</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>;

<span class="hljs-keyword">const</span> articleForm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormGroup</span>({
  <span class="hljs-attr">title</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormControl</span>(<span class="hljs-string">''</span>),
  <span class="hljs-attr">content</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormControl</span>(<span class="hljs-string">''</span>),
  <span class="hljs-attr">tags</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormArray</span>([])
});
</code></pre>
<p>이 모든 클래스들은 여기서는 컨트롤이라고만 부르겠습니다. 이 컨트롤들은 AbstractControl 클래스에서 파생되었기 때문에 공통 속성과 메소드를 공유합니다.</p>
<h2>템플릿 바인딩</h2>
<p>Angular Reactive Forms 모델 기반 접근 방식은 라이브러리 자체에서 제공하는 다양한 디렉티브에 의해 지원되며, 이는 폼 컨트롤을 HTML 요소와 쉽게 통합할 수 있도록 합니다.</p>
<p>다음의 FormGroup을 예시로 삼아보겠습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">articleForm</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormGroup</span>({
  <span class="hljs-attr">author</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormGroup</span>({
    <span class="hljs-attr">name</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormControl</span>(<span class="hljs-string">''</span>),
  }),
  <span class="hljs-attr">tags</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormArray</span>([ <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormControl</span>(<span class="hljs-string">'Angular'</span>) ]),
});
</code></pre>
<p>제공된 지시문을 사용하여 템플릿에 쉽게 바인딩할 수 있습니다:</p>
<pre><code class="hljs language-js">&#x3C;form [formGroup]=<span class="hljs-string">"articleForm"</span>>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">formGroupName</span>=<span class="hljs-string">"author"</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"name"</span> /></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>

  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">formArrayName</span>=<span class="hljs-string">"tags"</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let tag of tags.controls; index as i"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">input</span> [<span class="hljs-attr">formControlName</span>]=<span class="hljs-string">"i"</span> /></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
&#x3C;/form>
</code></pre>
<p>잊지 말아야 할 중요한 점은, 지나치게 깊게 파고들지 않으면서도 필요한 내용은, FormGroupDirective를 사용하여 쉽게 폼을 재설정하는 버튼과 해당 값을 제출하는 버튼을 만들 수 있다는 것입니다:</p>
<pre><code class="hljs language-js">&#x3C;form [formGroup]=<span class="hljs-string">"articleForm"</span>>
  &#x3C;!-- 폼 템플릿 -->

  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"reset"</span>></span>지우기<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>></span>저장<span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
&#x3C;/form>
</code></pre>
<p>FormGroupDirective는 이러한 버튼에서 발생하는 클릭 이벤트를 가로채어 컨트롤의 reset() 함수를 트리거하고, 컨트롤을 초기 값으로 재설정하며 directive의 ngSubmit 출력 이벤트를 트리거합니다.</p>
<h2>값 변경 감시</h2>
<p>특정 작업을 수행하기 위해 값을 변경하는 것을 듣기 위해, 추적하려는 컨트롤의 valueChanges observable에 구독할 수 있습니다:</p>
<pre><code class="hljs language-js">myControl.<span class="hljs-property">valueChanges</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">value</span> =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'새 값:'</span>, value)
});
</code></pre>
<h2>비활성화된 컨트롤</h2>
<p>각 컨트롤은 비활성화로 설정되어 사용자가 값을 편집하는 것을 방지할 수 있습니다. 이는 HTML 비활성화 속성(Disabled attribute)의 동작을 모방합니다.</p>
<p>이를 수행하기 위해서는 컨트롤을 비활성화하는 방법으로 사용할 수도 있고, disable()와 enable() 함수를 사용하여 이 상태를 전환할 수도 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FormControl</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>;

<span class="hljs-keyword">const</span> myControl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormControl</span>({ <span class="hljs-attr">value</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">disabled</span>: <span class="hljs-literal">true</span> });
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myControl.<span class="hljs-property">disabled</span>, myControl.<span class="hljs-property">enabled</span>) <span class="hljs-comment">// true, false</span>

myControl.<span class="hljs-title function_">enable</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myControl.<span class="hljs-property">disabled</span>, myControl.<span class="hljs-property">enabled</span>) <span class="hljs-comment">// false, true</span>

myControl.<span class="hljs-title function_">disable</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myControl.<span class="hljs-property">disabled</span>, myControl.<span class="hljs-property">enabled</span>) <span class="hljs-comment">// true, false</span>
</code></pre>
<p>위 예제에서 보듯이 AbstractControl 클래스는 이 상태를 설명하기 위해 disabled와 enabled라는 두 가지 전용 속성을 제공합니다.</p>
<h2>Validators</h2>
<p>특정 규칙을 강제하고 컨트롤이 특정 기준을 충족하는지 확인하려면 일부 유효성 검사 규칙 또는 유효성 검증기를 지정할 수도 있습니다.</p>
<p>유효성 검증기는 동기식일 수도 있고(@required 또는 @minLength와 같은), 외부 리소스에 의존하는 유효성 검사를 처리하는 비동기식일 수도 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">FormControl</span>, <span class="hljs-title class_">Validators</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MyCustomAsyncValidators</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./my-custom-async-validators.ts'</span>;

<span class="hljs-keyword">const</span> myFormControl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormControl</span>(<span class="hljs-string">''</span>, {
  <span class="hljs-attr">validators</span>: [ <span class="hljs-title class_">Validators</span>.<span class="hljs-property">required</span>, <span class="hljs-title class_">Validators</span>.<span class="hljs-title function_">minLength</span>(<span class="hljs-number">3</span>) ],
  <span class="hljs-attr">asyncValidators</span>: [ <span class="hljs-title class_">MyCustomAsyncValidators</span>.<span class="hljs-property">validate</span> ]
});
</code></pre>
<p>이러한 규칙을 기반으로 AbstractControl 클래스는 유효성 상태를 설명하는 몇 가지 속성도 제공합니다.</p>
<ul>
<li>valid: 제어 값이 모든 유효성 검사 테스트를 통과했는지 여부를 나타내는 부울 값입니다;</li>
<li>invalid: 제어 값이 모든 유효성 검사 테스트를 통과하지 못했는지 여부를 나타내는 부울 값입니다; valid 속성의 반대입니다;</li>
<li>pending: 제어 값이 유효성 검사를 수행 중인지 여부를 나타내는 부울 값입니다.</li>
</ul>
<h2>FormControlStatus</h2>
<p>비활성 상태와 유효성 상태는 서로 연결되어 있습니다.
사실, 이들은 다음과 같이 유형이 지정된 상태 속성으로 파생됩니다:</p>
<pre><code class="hljs language-js">type <span class="hljs-title class_">FormControlStatus</span> = <span class="hljs-string">'VALID'</span> | <span class="hljs-string">'INVALID'</span> | <span class="hljs-string">'PENDING'</span> | <span class="hljs-string">'DISABLED'</span>;
</code></pre>
<h2>원형과 접촉됨</h2>
<p>AbstractControl 클래스는 사용자가 양식과 상호 작용한 방식을 설명하는 여러 속성도 제공합니다:</p>
<ul>
<li>pristine: 컨트롤이 원형 상태인지 여부를 나타내는 부울 값으로, 즉 아직 수정되지 않은 상태임을 의미합니다;</li>
<li>dirty: 컨트롤이 수정되었는지 여부를 나타내는 부울 값입니다;</li>
<li>untouched: 컨트롤이 아직 터치되지 않았는지 여부를 나타내는 부울 값으로, 즉 아직 상호 작용되지 않았음을 의미합니다;</li>
<li>touched: 컨트롤이 터치되었는지 여부를 나타내는 부울 값입니다.</li>
</ul>
<p>Angular 반응형 폼의 기본 사항 중 일부를 다시 살펴보았으니, 이제 이 글의 주제를 소개할 때입니다.</p>
<p><img src="/assets/img/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents_0.png" alt="이미지"></p>
<h1>새로운 통합 제어 상태 변경 이벤트</h1>
<p>Angular v18부터 AbstractControl 클래스는 이제 모든 제어 상태 변경 이벤트를 추적하기 위한 새로운 이벤트 observable을 노출합니다.</p>
<p>이를 통해 이제 PristineEvent, ValueChangeEvent, StatusEvent 및 TouchedEvent 이벤트를 통해 FormControl, FormGroup 및 FormArray 클래스를 모니터링할 수 있습니다.</p>
<pre><code class="hljs language-js">myControl.<span class="hljs-property">events</span>
  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =></span> event <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">PristineChangeEvent</span>))
  .<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Pristine:'</span>, event.<span class="hljs-property">pristine</span>));

myControl.<span class="hljs-property">events</span>
  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =></span> event <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ValueChangeEvent</span>))
  .<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Value:'</span>, event.<span class="hljs-property">value</span>));

myControl.<span class="hljs-property">events</span>
  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =></span> event <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">StatusChangeEvent</span>))
  .<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Status:'</span>, event.<span class="hljs-property">status</span>));

myControl.<span class="hljs-property">events</span>
  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =></span> event <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">TouchedChangeEvent</span>))
  .<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Touched:'</span>, event.<span class="hljs-property">touched</span>));
</code></pre>
<p>이러한 기능들은 매우 강력합니다. 특히 valueChange를 제외하고는 이전에 상태 변경을 제대로 추적하기가 어려웠습니다.</p>
<p>게다가 FormGroup 클래스는 events observable을 통해 FormSubmittedEvent와 FormResetEvent 두 가지 추가 이벤트를 발생시킬 수도 있습니다.</p>
<pre><code class="hljs language-js">myControl.<span class="hljs-property">events</span>
  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =></span> event <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">FormSubmittedEvent</span>))
  .<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Submit:'</span>, event));

myControl.<span class="hljs-property">events</span>
  .<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =></span> event <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">FormResetEvent</span>))
  .<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">event</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Reset:'</span>, event));
</code></pre>
<p>FormSubmittedEvent와 FormResetEvent는 모두 FormGroupDirective에서 상속되며 실제로 지시자 자체에서만 발생됩니다.</p>
<h2>추가 정보</h2>
<p>이 새로운 추가로, 다음 AbstractControl 메소드들은 emitEvent 매개변수를 지원하도록 업데이트되었습니다:</p>
<ul>
<li>markAsPristine(): 컨트롤을 pristine으로 표시;</li>
<li>markAsDirty(): 컨트롤을 dirty로 표시;</li>
<li>markAsTouched(): 컨트롤을 touched로 표시;</li>
<li>markAsUntouched(): 컨트롤을 untouched로 표시;</li>
<li>markAllAsTouched(): 컨트롤과 하위 요소를 모두 touched 상태로 표시합니다.</li>
</ul>
<h1>지금까지 읽어 주셔서 감사합니다 🙏</h1>
<p>피드백을 받고 싶어요. 댓글을 남겨주시거나 클랩을 눌러주세요. 👏</p>
<p>그리고 만약에 정말 좋았다면, 당신의 커뮤니티, 기술 브라더들, 누구든지 공유해주세요. 그리고 리링크드인 팔로우도 잊지 말아주세요. 👋😁</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Angular 폼의 새로운 통합된 컨트롤 상태 변경 이벤트","description":"","date":"2024-06-20 00:32","slug":"2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents","content":"\n\nAngular v18의 릴리스는 프레임워크에 흥미로운 새로운 기능과 개선 사항을 도입했습니다.\n\n그 중 하나의 기능은 특히 유망하며, Angular Forms 라이브러리 내에서 새로운 기능을 소개하여 AbstractControl 클래스를 통해 통합된 컨트롤 상태 변경 이벤트를 향상시킵니다.\n\n내 글에서는 주제에 집중하기 전에 기본 사항을 먼저 검토하는 것이 관습입니다. 이는 다가오는 내용을 더 잘 이해하도록 도와줄 것입니다.\n\n# Angular 반응형 Forms: 기본 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앵귤러 반응형 폼은 양식 입력을 처리하는 모델 중심 접근 방식을 제공하며, 데이터 모델에 대한 동기식 액세스, 입력 유효성 검사 및 변경 추적을 위한 강력한 도구를 Observables를 통해 제공합니다.\n\n반응형 폼 데이터 모델은 다음 클래스를 사용하여 구성됩니다:\n\n- FormControl: 단일 입력 양식을 나타냅니다. 값은 기본 유형입니다.\n- FormGroup: FormControl 그룹을 나타냅니다. 값은 객체입니다.\n- FormArray: FormControl 목록을 나타냅니다. 값은 배열입니다.\n\nFormGroup으로 나타낼 수 있는 폼의 일반적인 예시는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { FormGroup, FormControl, FormArray } from '@angular/forms';\n\nconst articleForm = new FormGroup({\n  title: new FormControl(''),\n  content: new FormControl(''),\n  tags: new FormArray([])\n});\n```\n\n이 모든 클래스들은 여기서는 컨트롤이라고만 부르겠습니다. 이 컨트롤들은 AbstractControl 클래스에서 파생되었기 때문에 공통 속성과 메소드를 공유합니다.\n\n## 템플릿 바인딩\n\nAngular Reactive Forms 모델 기반 접근 방식은 라이브러리 자체에서 제공하는 다양한 디렉티브에 의해 지원되며, 이는 폼 컨트롤을 HTML 요소와 쉽게 통합할 수 있도록 합니다. \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음의 FormGroup을 예시로 삼아보겠습니다:\n\n```js\nthis.articleForm = new FormGroup({\n  author: new FormGroup({\n    name: new FormControl(''),\n  }),\n  tags: new FormArray([ new FormControl('Angular') ]),\n});\n```\n\n제공된 지시문을 사용하여 템플릿에 쉽게 바인딩할 수 있습니다:\n\n```js\n\u003cform [formGroup]=\"articleForm\"\u003e\n  \u003cdiv formGroupName=\"author\"\u003e\n    \u003cinput formControlName=\"name\" /\u003e\n  \u003c/div\u003e\n\n  \u003cdiv formArrayName=\"tags\"\u003e\n    \u003cdiv *ngFor=\"let tag of tags.controls; index as i\"\u003e\n      \u003cinput [formControlName]=\"i\" /\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/form\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잊지 말아야 할 중요한 점은, 지나치게 깊게 파고들지 않으면서도 필요한 내용은, FormGroupDirective를 사용하여 쉽게 폼을 재설정하는 버튼과 해당 값을 제출하는 버튼을 만들 수 있다는 것입니다:\n\n```js\n\u003cform [formGroup]=\"articleForm\"\u003e\n  \u003c!-- 폼 템플릿 --\u003e\n\n  \u003cbutton type=\"reset\"\u003e지우기\u003c/button\u003e\n  \u003cbutton type=\"submit\"\u003e저장\u003c/button\u003e\n\u003c/form\u003e\n```\n\nFormGroupDirective는 이러한 버튼에서 발생하는 클릭 이벤트를 가로채어 컨트롤의 reset() 함수를 트리거하고, 컨트롤을 초기 값으로 재설정하며 directive의 ngSubmit 출력 이벤트를 트리거합니다.\n\n## 값 변경 감시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 작업을 수행하기 위해 값을 변경하는 것을 듣기 위해, 추적하려는 컨트롤의 valueChanges observable에 구독할 수 있습니다:\n\n```js\nmyControl.valueChanges.subscribe(value =\u003e {\n  console.log('새 값:', value)\n});\n```\n\n## 비활성화된 컨트롤\n\n각 컨트롤은 비활성화로 설정되어 사용자가 값을 편집하는 것을 방지할 수 있습니다. 이는 HTML 비활성화 속성(Disabled attribute)의 동작을 모방합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이를 수행하기 위해서는 컨트롤을 비활성화하는 방법으로 사용할 수도 있고, disable()와 enable() 함수를 사용하여 이 상태를 전환할 수도 있습니다:\n\n```js\nimport { FormControl } from '@angular/forms';\n\nconst myControl = new FormControl({ value: '', disabled: true });\nconsole.log(myControl.disabled, myControl.enabled) // true, false\n\nmyControl.enable();\nconsole.log(myControl.disabled, myControl.enabled) // false, true\n\nmyControl.disable();\nconsole.log(myControl.disabled, myControl.enabled) // true, false\n```\n\n위 예제에서 보듯이 AbstractControl 클래스는 이 상태를 설명하기 위해 disabled와 enabled라는 두 가지 전용 속성을 제공합니다.\n\n## Validators\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 규칙을 강제하고 컨트롤이 특정 기준을 충족하는지 확인하려면 일부 유효성 검사 규칙 또는 유효성 검증기를 지정할 수도 있습니다.\n\n유효성 검증기는 동기식일 수도 있고(@required 또는 @minLength와 같은), 외부 리소스에 의존하는 유효성 검사를 처리하는 비동기식일 수도 있습니다.\n\n```js\nimport { FormControl, Validators } from '@angular/forms';\nimport { MyCustomAsyncValidators } from './my-custom-async-validators.ts';\n\nconst myFormControl = new FormControl('', {\n  validators: [ Validators.required, Validators.minLength(3) ],\n  asyncValidators: [ MyCustomAsyncValidators.validate ]\n});\n```\n\n이러한 규칙을 기반으로 AbstractControl 클래스는 유효성 상태를 설명하는 몇 가지 속성도 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- valid: 제어 값이 모든 유효성 검사 테스트를 통과했는지 여부를 나타내는 부울 값입니다;\n- invalid: 제어 값이 모든 유효성 검사 테스트를 통과하지 못했는지 여부를 나타내는 부울 값입니다; valid 속성의 반대입니다;\n- pending: 제어 값이 유효성 검사를 수행 중인지 여부를 나타내는 부울 값입니다.\n\n## FormControlStatus\n\n비활성 상태와 유효성 상태는 서로 연결되어 있습니다.\n사실, 이들은 다음과 같이 유형이 지정된 상태 속성으로 파생됩니다:\n\n```js\ntype FormControlStatus = 'VALID' | 'INVALID' | 'PENDING' | 'DISABLED';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 원형과 접촉됨\n\nAbstractControl 클래스는 사용자가 양식과 상호 작용한 방식을 설명하는 여러 속성도 제공합니다:\n\n- pristine: 컨트롤이 원형 상태인지 여부를 나타내는 부울 값으로, 즉 아직 수정되지 않은 상태임을 의미합니다;\n- dirty: 컨트롤이 수정되었는지 여부를 나타내는 부울 값입니다;\n- untouched: 컨트롤이 아직 터치되지 않았는지 여부를 나타내는 부울 값으로, 즉 아직 상호 작용되지 않았음을 의미합니다;\n- touched: 컨트롤이 터치되었는지 여부를 나타내는 부울 값입니다.\n\nAngular 반응형 폼의 기본 사항 중 일부를 다시 살펴보았으니, 이제 이 글의 주제를 소개할 때입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents_0.png)\n\n# 새로운 통합 제어 상태 변경 이벤트\n\nAngular v18부터 AbstractControl 클래스는 이제 모든 제어 상태 변경 이벤트를 추적하기 위한 새로운 이벤트 observable을 노출합니다.\n\n이를 통해 이제 PristineEvent, ValueChangeEvent, StatusEvent 및 TouchedEvent 이벤트를 통해 FormControl, FormGroup 및 FormArray 클래스를 모니터링할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmyControl.events\n  .pipe(filter((event) =\u003e event instanceof PristineChangeEvent))\n  .subscribe((event) =\u003e console.log('Pristine:', event.pristine));\n\nmyControl.events\n  .pipe(filter((event) =\u003e event instanceof ValueChangeEvent))\n  .subscribe((event) =\u003e console.log('Value:', event.value));\n\nmyControl.events\n  .pipe(filter((event) =\u003e event instanceof StatusChangeEvent))\n  .subscribe((event) =\u003e console.log('Status:', event.status));\n\nmyControl.events\n  .pipe(filter((event) =\u003e event instanceof TouchedChangeEvent))\n  .subscribe((event) =\u003e console.log('Touched:', event.touched));\n```\n\n이러한 기능들은 매우 강력합니다. 특히 valueChange를 제외하고는 이전에 상태 변경을 제대로 추적하기가 어려웠습니다.\n\n게다가 FormGroup 클래스는 events observable을 통해 FormSubmittedEvent와 FormResetEvent 두 가지 추가 이벤트를 발생시킬 수도 있습니다.\n\n```js\nmyControl.events\n  .pipe(filter((event) =\u003e event instanceof FormSubmittedEvent))\n  .subscribe((event) =\u003e console.log('Submit:', event));\n\nmyControl.events\n  .pipe(filter((event) =\u003e event instanceof FormResetEvent))\n  .subscribe((event) =\u003e console.log('Reset:', event));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFormSubmittedEvent와 FormResetEvent는 모두 FormGroupDirective에서 상속되며 실제로 지시자 자체에서만 발생됩니다.\n\n## 추가 정보\n\n이 새로운 추가로, 다음 AbstractControl 메소드들은 emitEvent 매개변수를 지원하도록 업데이트되었습니다:\n\n- markAsPristine(): 컨트롤을 pristine으로 표시;\n- markAsDirty(): 컨트롤을 dirty로 표시;\n- markAsTouched(): 컨트롤을 touched로 표시;\n- markAsUntouched(): 컨트롤을 untouched로 표시;\n- markAllAsTouched(): 컨트롤과 하위 요소를 모두 touched 상태로 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 지금까지 읽어 주셔서 감사합니다 🙏\n\n피드백을 받고 싶어요. 댓글을 남겨주시거나 클랩을 눌러주세요. 👏 \n\n그리고 만약에 정말 좋았다면, 당신의 커뮤니티, 기술 브라더들, 누구든지 공유해주세요. 그리고 리링크드인 팔로우도 잊지 말아주세요. 👋😁","ogImage":{"url":"/assets/img/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents_0.png"},"coverImage":"/assets/img/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003eAngular v18의 릴리스는 프레임워크에 흥미로운 새로운 기능과 개선 사항을 도입했습니다.\u003c/p\u003e\n\u003cp\u003e그 중 하나의 기능은 특히 유망하며, Angular Forms 라이브러리 내에서 새로운 기능을 소개하여 AbstractControl 클래스를 통해 통합된 컨트롤 상태 변경 이벤트를 향상시킵니다.\u003c/p\u003e\n\u003cp\u003e내 글에서는 주제에 집중하기 전에 기본 사항을 먼저 검토하는 것이 관습입니다. 이는 다가오는 내용을 더 잘 이해하도록 도와줄 것입니다.\u003c/p\u003e\n\u003ch1\u003eAngular 반응형 Forms: 기본 사항\u003c/h1\u003e\n\u003cp\u003e앵귤러 반응형 폼은 양식 입력을 처리하는 모델 중심 접근 방식을 제공하며, 데이터 모델에 대한 동기식 액세스, 입력 유효성 검사 및 변경 추적을 위한 강력한 도구를 Observables를 통해 제공합니다.\u003c/p\u003e\n\u003cp\u003e반응형 폼 데이터 모델은 다음 클래스를 사용하여 구성됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFormControl: 단일 입력 양식을 나타냅니다. 값은 기본 유형입니다.\u003c/li\u003e\n\u003cli\u003eFormGroup: FormControl 그룹을 나타냅니다. 값은 객체입니다.\u003c/li\u003e\n\u003cli\u003eFormArray: FormControl 목록을 나타냅니다. 값은 배열입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFormGroup으로 나타낼 수 있는 폼의 일반적인 예시는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eFormGroup\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eFormControl\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eFormArray\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/forms'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e articleForm = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormGroup\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormControl\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e),\n  \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormControl\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e),\n  \u003cspan class=\"hljs-attr\"\u003etags\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormArray\u003c/span\u003e([])\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 모든 클래스들은 여기서는 컨트롤이라고만 부르겠습니다. 이 컨트롤들은 AbstractControl 클래스에서 파생되었기 때문에 공통 속성과 메소드를 공유합니다.\u003c/p\u003e\n\u003ch2\u003e템플릿 바인딩\u003c/h2\u003e\n\u003cp\u003eAngular Reactive Forms 모델 기반 접근 방식은 라이브러리 자체에서 제공하는 다양한 디렉티브에 의해 지원되며, 이는 폼 컨트롤을 HTML 요소와 쉽게 통합할 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003e다음의 FormGroup을 예시로 삼아보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003earticleForm\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormGroup\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eauthor\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormGroup\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormControl\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e),\n  }),\n  \u003cspan class=\"hljs-attr\"\u003etags\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormArray\u003c/span\u003e([ \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormControl\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Angular'\u003c/span\u003e) ]),\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제공된 지시문을 사용하여 템플릿에 쉽게 바인딩할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;form [formGroup]=\u003cspan class=\"hljs-string\"\u003e\"articleForm\"\u003c/span\u003e\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eformGroupName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"author\"\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eformControlName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e /\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eformArrayName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"tags\"\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e *\u003cspan class=\"hljs-attr\"\u003engFor\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"let tag of tags.controls; index as i\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e [\u003cspan class=\"hljs-attr\"\u003eformControlName\u003c/span\u003e]=\u003cspan class=\"hljs-string\"\u003e\"i\"\u003c/span\u003e /\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/form\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e잊지 말아야 할 중요한 점은, 지나치게 깊게 파고들지 않으면서도 필요한 내용은, FormGroupDirective를 사용하여 쉽게 폼을 재설정하는 버튼과 해당 값을 제출하는 버튼을 만들 수 있다는 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;form [formGroup]=\u003cspan class=\"hljs-string\"\u003e\"articleForm\"\u003c/span\u003e\u003e\n  \u0026#x3C;!-- 폼 템플릿 --\u003e\n\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"reset\"\u003c/span\u003e\u003e\u003c/span\u003e지우기\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"submit\"\u003c/span\u003e\u003e\u003c/span\u003e저장\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/form\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFormGroupDirective는 이러한 버튼에서 발생하는 클릭 이벤트를 가로채어 컨트롤의 reset() 함수를 트리거하고, 컨트롤을 초기 값으로 재설정하며 directive의 ngSubmit 출력 이벤트를 트리거합니다.\u003c/p\u003e\n\u003ch2\u003e값 변경 감시\u003c/h2\u003e\n\u003cp\u003e특정 작업을 수행하기 위해 값을 변경하는 것을 듣기 위해, 추적하려는 컨트롤의 valueChanges observable에 구독할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emyControl.\u003cspan class=\"hljs-property\"\u003evalueChanges\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'새 값:'\u003c/span\u003e, value)\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e비활성화된 컨트롤\u003c/h2\u003e\n\u003cp\u003e각 컨트롤은 비활성화로 설정되어 사용자가 값을 편집하는 것을 방지할 수 있습니다. 이는 HTML 비활성화 속성(Disabled attribute)의 동작을 모방합니다.\u003c/p\u003e\n\u003cp\u003e이를 수행하기 위해서는 컨트롤을 비활성화하는 방법으로 사용할 수도 있고, disable()와 enable() 함수를 사용하여 이 상태를 전환할 수도 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eFormControl\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/forms'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myControl = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormControl\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edisabled\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e });\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(myControl.\u003cspan class=\"hljs-property\"\u003edisabled\u003c/span\u003e, myControl.\u003cspan class=\"hljs-property\"\u003eenabled\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// true, false\u003c/span\u003e\n\nmyControl.\u003cspan class=\"hljs-title function_\"\u003eenable\u003c/span\u003e();\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(myControl.\u003cspan class=\"hljs-property\"\u003edisabled\u003c/span\u003e, myControl.\u003cspan class=\"hljs-property\"\u003eenabled\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// false, true\u003c/span\u003e\n\nmyControl.\u003cspan class=\"hljs-title function_\"\u003edisable\u003c/span\u003e();\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(myControl.\u003cspan class=\"hljs-property\"\u003edisabled\u003c/span\u003e, myControl.\u003cspan class=\"hljs-property\"\u003eenabled\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// true, false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예제에서 보듯이 AbstractControl 클래스는 이 상태를 설명하기 위해 disabled와 enabled라는 두 가지 전용 속성을 제공합니다.\u003c/p\u003e\n\u003ch2\u003eValidators\u003c/h2\u003e\n\u003cp\u003e특정 규칙을 강제하고 컨트롤이 특정 기준을 충족하는지 확인하려면 일부 유효성 검사 규칙 또는 유효성 검증기를 지정할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e유효성 검증기는 동기식일 수도 있고(@required 또는 @minLength와 같은), 외부 리소스에 의존하는 유효성 검사를 처리하는 비동기식일 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eFormControl\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eValidators\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/forms'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eMyCustomAsyncValidators\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./my-custom-async-validators.ts'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myFormControl = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormControl\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003evalidators\u003c/span\u003e: [ \u003cspan class=\"hljs-title class_\"\u003eValidators\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erequired\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eValidators\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eminLength\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e) ],\n  \u003cspan class=\"hljs-attr\"\u003easyncValidators\u003c/span\u003e: [ \u003cspan class=\"hljs-title class_\"\u003eMyCustomAsyncValidators\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalidate\u003c/span\u003e ]\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 규칙을 기반으로 AbstractControl 클래스는 유효성 상태를 설명하는 몇 가지 속성도 제공합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003evalid: 제어 값이 모든 유효성 검사 테스트를 통과했는지 여부를 나타내는 부울 값입니다;\u003c/li\u003e\n\u003cli\u003einvalid: 제어 값이 모든 유효성 검사 테스트를 통과하지 못했는지 여부를 나타내는 부울 값입니다; valid 속성의 반대입니다;\u003c/li\u003e\n\u003cli\u003epending: 제어 값이 유효성 검사를 수행 중인지 여부를 나타내는 부울 값입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eFormControlStatus\u003c/h2\u003e\n\u003cp\u003e비활성 상태와 유효성 상태는 서로 연결되어 있습니다.\n사실, 이들은 다음과 같이 유형이 지정된 상태 속성으로 파생됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype \u003cspan class=\"hljs-title class_\"\u003eFormControlStatus\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'VALID'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'INVALID'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'PENDING'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'DISABLED'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e원형과 접촉됨\u003c/h2\u003e\n\u003cp\u003eAbstractControl 클래스는 사용자가 양식과 상호 작용한 방식을 설명하는 여러 속성도 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epristine: 컨트롤이 원형 상태인지 여부를 나타내는 부울 값으로, 즉 아직 수정되지 않은 상태임을 의미합니다;\u003c/li\u003e\n\u003cli\u003edirty: 컨트롤이 수정되었는지 여부를 나타내는 부울 값입니다;\u003c/li\u003e\n\u003cli\u003euntouched: 컨트롤이 아직 터치되지 않았는지 여부를 나타내는 부울 값으로, 즉 아직 상호 작용되지 않았음을 의미합니다;\u003c/li\u003e\n\u003cli\u003etouched: 컨트롤이 터치되었는지 여부를 나타내는 부울 값입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAngular 반응형 폼의 기본 사항 중 일부를 다시 살펴보았으니, 이제 이 글의 주제를 소개할 때입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e새로운 통합 제어 상태 변경 이벤트\u003c/h1\u003e\n\u003cp\u003eAngular v18부터 AbstractControl 클래스는 이제 모든 제어 상태 변경 이벤트를 추적하기 위한 새로운 이벤트 observable을 노출합니다.\u003c/p\u003e\n\u003cp\u003e이를 통해 이제 PristineEvent, ValueChangeEvent, StatusEvent 및 TouchedEvent 이벤트를 통해 FormControl, FormGroup 및 FormArray 클래스를 모니터링할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emyControl.\u003cspan class=\"hljs-property\"\u003eevents\u003c/span\u003e\n  .\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e event \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePristineChangeEvent\u003c/span\u003e))\n  .\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Pristine:'\u003c/span\u003e, event.\u003cspan class=\"hljs-property\"\u003epristine\u003c/span\u003e));\n\nmyControl.\u003cspan class=\"hljs-property\"\u003eevents\u003c/span\u003e\n  .\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e event \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eValueChangeEvent\u003c/span\u003e))\n  .\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Value:'\u003c/span\u003e, event.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e));\n\nmyControl.\u003cspan class=\"hljs-property\"\u003eevents\u003c/span\u003e\n  .\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e event \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStatusChangeEvent\u003c/span\u003e))\n  .\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Status:'\u003c/span\u003e, event.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e));\n\nmyControl.\u003cspan class=\"hljs-property\"\u003eevents\u003c/span\u003e\n  .\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e event \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTouchedChangeEvent\u003c/span\u003e))\n  .\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Touched:'\u003c/span\u003e, event.\u003cspan class=\"hljs-property\"\u003etouched\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 기능들은 매우 강력합니다. 특히 valueChange를 제외하고는 이전에 상태 변경을 제대로 추적하기가 어려웠습니다.\u003c/p\u003e\n\u003cp\u003e게다가 FormGroup 클래스는 events observable을 통해 FormSubmittedEvent와 FormResetEvent 두 가지 추가 이벤트를 발생시킬 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emyControl.\u003cspan class=\"hljs-property\"\u003eevents\u003c/span\u003e\n  .\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e event \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormSubmittedEvent\u003c/span\u003e))\n  .\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Submit:'\u003c/span\u003e, event));\n\nmyControl.\u003cspan class=\"hljs-property\"\u003eevents\u003c/span\u003e\n  .\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e event \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFormResetEvent\u003c/span\u003e))\n  .\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Reset:'\u003c/span\u003e, event));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFormSubmittedEvent와 FormResetEvent는 모두 FormGroupDirective에서 상속되며 실제로 지시자 자체에서만 발생됩니다.\u003c/p\u003e\n\u003ch2\u003e추가 정보\u003c/h2\u003e\n\u003cp\u003e이 새로운 추가로, 다음 AbstractControl 메소드들은 emitEvent 매개변수를 지원하도록 업데이트되었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emarkAsPristine(): 컨트롤을 pristine으로 표시;\u003c/li\u003e\n\u003cli\u003emarkAsDirty(): 컨트롤을 dirty로 표시;\u003c/li\u003e\n\u003cli\u003emarkAsTouched(): 컨트롤을 touched로 표시;\u003c/li\u003e\n\u003cli\u003emarkAsUntouched(): 컨트롤을 untouched로 표시;\u003c/li\u003e\n\u003cli\u003emarkAllAsTouched(): 컨트롤과 하위 요소를 모두 touched 상태로 표시합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e지금까지 읽어 주셔서 감사합니다 🙏\u003c/h1\u003e\n\u003cp\u003e피드백을 받고 싶어요. 댓글을 남겨주시거나 클랩을 눌러주세요. 👏\u003c/p\u003e\n\u003cp\u003e그리고 만약에 정말 좋았다면, 당신의 커뮤니티, 기술 브라더들, 누구든지 공유해주세요. 그리고 리링크드인 팔로우도 잊지 말아주세요. 👋😁\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-AngularFormsnewunifiedcontrolstatechangeevents"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>