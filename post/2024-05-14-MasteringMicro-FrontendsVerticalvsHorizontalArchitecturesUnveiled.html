<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>마이크로 프론트엔드 마스터하기 수직 대 수평 아키텍쳐 공개 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="마이크로 프론트엔드 마스터하기 수직 대 수평 아키텍쳐 공개 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="마이크로 프론트엔드 마스터하기 수직 대 수평 아키텍쳐 공개 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled" data-gatsby-head="true"/><meta name="twitter:title" content="마이크로 프론트엔드 마스터하기 수직 대 수평 아키텍쳐 공개 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 14:27" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_buildManifest.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">마이크로 프론트엔드 마스터하기 수직 대 수평 아키텍쳐 공개</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="마이크로 프론트엔드 마스터하기 수직 대 수평 아키텍쳐 공개" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_0.png" alt="이미지"/></p>
<p>마이크로 프론트엔드는 현대 웹 개발에서 강력한 아키텍처 패턴으로 등장했습니다. 이는 팀이 거대한 프론트엔드 응용 프로그램을 더 작고 관리하기 쉬운 조각으로 나눌 수 있도록 합니다. 마이크로 프론트엔드 아키텍처에서 중요한 결정 중 하나는 수직 또는 수평 구성에 관한 선택입니다. 이러한 구성은 개별 프론트엔드 모듈이 구조화되고 전체 응용 프로그램에 통합되는 방식을 결정합니다. 이 기사에서는 수직 및 수평 마이크로 프론트엔드 아키텍처 간의 차이를 탐구하고 클라이언트 측, 엣지 및 서버 측과 같은 여러 구성 전술 및 각각의 장단점 및 실제 응용 프로그램을 살펴봅니다.</p>
<h1>수직형 마이크로 프론트엔드 아키텍처:</h1>
<p><img src="/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_1.png" alt="이미지"/></p>
<p>수직 마이크로프런트엔드 아키텍처에서 각 모듈은 특정 수직 단위의 기능을 담당하며, 특정 기능이나 사용자 이동을 제공하기 위해 필요한 프론트엔드와 백엔드 구성 요소를 모두 포괄합니다. 수직 마이크로프런트엔드와 관련된 구성에 대해 자세히 살펴봅시다:</p>
<p>클라이언트 측 구성에서 모듈은 독립적으로 개발 및 배포되며, 최종 구성은 사용자의 브라우저 내에서 발생합니다. JavaScript 오케스트레이터인 single-spa 또는 Webpack Module Federation과 같은 도구를 사용하여 런타임에서 모듈을 동적으로 로드하고 통합하는 것이 일반적입니다.</p>
<p>장점:</p>
<ul>
<li>격리성: 각 모듈은 독립적으로 작동하여 한 모듈의 실패가 다른 모듈에 영향을 미치는 위험을 최소화합니다.</li>
<li>유연성: 팀이 독립적으로 모듈을 개발하고 배포할 수 있어 빠른 이터레이션 및 릴리스 주기를 용이하게 합니다.</li>
<li>확장성: 동일 모듈의 인스턴스를 추가함으로써 수평적으로 손쉽게 확장할 수 있습니다.</li>
</ul>
<p>단점:</p>
<ul>
<li>성능 오버헤드: 동적 모듈 로딩으로 인한 초기 로드 시간 증가 및 런타임 오버헤드 가능성.</li>
<li>복잡성: 모듈 로딩, 라우팅 및 통신 처리를 위한 견고한 조율 메커니즘 필요.</li>
</ul>
<p>실제 사례 시나리오: 각 모듈이 구체적인 쇼핑 기능을 나타내는 전자 상거래 플랫폼(예: 제품 목록, 장바구니 관리, 결제 과정).</p>
<p>Edge 구성은 중앙 게이트웨이 또는 Edge 서버를 통해 요청을 경유하며, 요청된 URL에 기반하여 프론트엔드 모듈을 동적으로 조합합니다. Edge 서버는 서버리스 함수나 리버스 프록시를 사용하여 구성된 애플리케이션을 사용자에게 제공할 수 있습니다.</p>
<p>장점:</p>
<ul>
<li>효율성: 구성이 네트워크 가장자리에서 발생하기 때문에 클라이언트 측 부하가 줄어듭니다.</li>
<li>보안: 요청의 중앙화된 처리로 통합 보안 정책과 접근 제어가 가능합니다.</li>
<li>성능: 가장자리에서 개선된 캐싱 및 콘텐츠 전달 최적화가 이루어집니다.</li>
</ul>
<p>단점:</p>
<ul>
<li>복잡한 배포: 글로벌 배포를 위해 가장자리 인프라를 설정하고 관리하는 것은 어려울 수 있습니다.</li>
<li>한정된 동적성: 구성 논리 변경시 가장자리 서버 구성 업데이트가 필요할 수 있습니다.</li>
</ul>
<p>실제 사례 시나리오: 다양한 모듈이 콘텐츠 유형(예: 기사, 동영상, 이미지)을 나타내며 사용자 요청에 따라 조합되는 콘텐츠 관리 시스템입니다.</p>
<h1>수평 마이크로프론트엔드 아키텍처:</h1>
<p><img src="/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_2.png" alt="Horizontal Micro-Frontend Architecture"/></p>
<p>수평 마이크로프론트엔드 아키텍처에서는 모듈이 공유된 기능 또는 구성 요소 주변에 정리되며 각 모듈이 전체 응용 프로그램에 특정 기능을 기여합니다. 수평 마이크로프론트엔드와 관련된 조합 전술을 살펴보겠습니다.</p>
<p>수직 아키텍처와 유사하게, 수평 미크로 프론트엔드에서의 클라이언트 측 구성은 사용자의 브라우저 내에서 모듈을 동적으로 로드하고 통합하는 것을 의미합니다. 그러나 수평 아키텍처의 경우, 모듈은 주로 재사용 가능한 UI 구성 요소나 서비스를 제공하는 데 중점을 두며 완전한 기능을 제공하기보다는 집중적으로 활용됩니다.</p>
<p>장점:</p>
<ul>
<li>재사용성: 공유 UI 구성 요소와 서비스는 일관성을 유지하고 모듈 간의 중복을 줄이는 데 도움이 됩니다.</li>
<li>협업: 응용 프로그램의 다른 부분에 작업하는 팀 간의 협력을 촉진합니다.</li>
<li>점진적 적용: 개별 구성 요소를 대체함으로써 단일체에서 미크로프론트엔드 아키텍처로 점진적인 이전이 가능합니다.</li>
</ul>
<p>단점:</p>
<ul>
<li>종속성 관리: 공유 종속성과 통신 프로토콜은 신중한 버전 및 호환성 관리가 필요합니다.</li>
<li>조정 오버헤드: 모듈 간 일관된 UI/UX를 보장하는 것은 추가 조정 노력이 필요할 수 있습니다.</li>
</ul>
<p>실제 사례 시나리오: 대시보드 애플리케이션에서 모듈이 다른 데이터 시각화 구성 요소(예: 차트, 표, 지도)를 나타내며 여러 페이지나 뷰에서 공유됩니다.</p>
<p>서버 측 구성에서는 백엔드 서버가 클라이언트로 전송하기 전에 모듈의 출력을 결합한 최종 HTML 마크업을 집계하고 렌더링하는 역할을 합니다. 이 접근 방식은 종종 Next.js나 Nuxt.js와 같은 서버 측 렌더링(SSR) 프레임워크와 함께 사용됩니다.</p>
<p>장점:</p>
<p><strong>장점:</strong></p>
<ul>
<li>성능: 초기 페이지 로드 시간을 서버에서 조합된 HTML을 렌더링하여 최적화할 수 있습니다.</li>
<li>SEO: 서버 렌더링된 콘텐츠는 검색 엔진에 더 쉽게 색인되어 발견성을 향상시킵니다.</li>
<li>점진적인 향상: 제한된 JavaScript 기능을 갖는 클라이언트에 대해 우아한 저하를 가능하게 합니다.</li>
</ul>
<p><strong>단점:</strong></p>
<ul>
<li>서버 부하: 복잡한 조합을 위한 서버 측 처리와 렌더링 부하가 증가합니다.</li>
<li>강한 결합: 백엔드 서버가 조합 로직과 데이터 집계를 위한 단일 장애 지점이 됩니다.</li>
</ul>
<p><strong>실제 사례 시나리오:</strong></p>
<ul>
<li>모놀리식 전자 상거래 앱이 마이크로 프론트엔드로 변형되어 각 마이크로 애플리케이션이 독립적인 개발, 저장소, 배포를 필요로 하며 최소한의 의존성이나 제로 의존성이 필요한 것입니다. (예: 헤더, 푸터, 필터, 제품 목록 등)</li>
</ul>
<h1>결론:</h1>
<p>수직 및 수평 미크로프론트엔드 아키텍처 사이를 선택하거나 적절한 구성 전술을 선택하는 것은 프로젝트 요구 사항, 팀 구조, 확장 가능성 요구 사항 및 성능 고려 사항과 같은 여러 요소에 의존합니다. 각 접근 방식의 장단점 및 실제 응용 프로그램을 이해함으로써, 개발 팀은 특정 사용 사례 및 목표와 일치하는 정보에 기반한 결정을 내릴 수 있으며, 웹 개발의 계속 변화하는 환경에서 확장 가능하고 모듈식이며 유지 보수 가능한 프론트엔드 응용 프로그램을 위한 길을 열 수 있습니다.</p>
<h1>Stackademic 🎓</h1>
<p>끝까지 읽어 주셔서 감사합니다. 떠나기 전에:</p>
<ul>
<li>작가를 응원하고 팔로우해 주세요! 👏</li>
<li>팔로우하기: X | LinkedIn | YouTube | Discord</li>
<li>다른 플랫폼 방문: In Plain English | CoFeed | Venture | Cubed</li>
<li>알고리즘 콘텐츠를 다루게 만드는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요</li>
<li>더 많은 콘텐츠는 Stackademic.com에서 확인하세요</li>
</ul></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"마이크로 프론트엔드 마스터하기 수직 대 수평 아키텍쳐 공개","description":"","date":"2024-05-14 14:27","slug":"2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled","content":"\n\n\n![이미지](/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_0.png)\n\n마이크로 프론트엔드는 현대 웹 개발에서 강력한 아키텍처 패턴으로 등장했습니다. 이는 팀이 거대한 프론트엔드 응용 프로그램을 더 작고 관리하기 쉬운 조각으로 나눌 수 있도록 합니다. 마이크로 프론트엔드 아키텍처에서 중요한 결정 중 하나는 수직 또는 수평 구성에 관한 선택입니다. 이러한 구성은 개별 프론트엔드 모듈이 구조화되고 전체 응용 프로그램에 통합되는 방식을 결정합니다. 이 기사에서는 수직 및 수평 마이크로 프론트엔드 아키텍처 간의 차이를 탐구하고 클라이언트 측, 엣지 및 서버 측과 같은 여러 구성 전술 및 각각의 장단점 및 실제 응용 프로그램을 살펴봅니다.\n\n# 수직형 마이크로 프론트엔드 아키텍처:\n\n![이미지](/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_1.png)\n\n\n\n\n수직 마이크로프런트엔드 아키텍처에서 각 모듈은 특정 수직 단위의 기능을 담당하며, 특정 기능이나 사용자 이동을 제공하기 위해 필요한 프론트엔드와 백엔드 구성 요소를 모두 포괄합니다. 수직 마이크로프런트엔드와 관련된 구성에 대해 자세히 살펴봅시다:\n\n클라이언트 측 구성에서 모듈은 독립적으로 개발 및 배포되며, 최종 구성은 사용자의 브라우저 내에서 발생합니다. JavaScript 오케스트레이터인 single-spa 또는 Webpack Module Federation과 같은 도구를 사용하여 런타임에서 모듈을 동적으로 로드하고 통합하는 것이 일반적입니다.\n\n장점:\n\n- 격리성: 각 모듈은 독립적으로 작동하여 한 모듈의 실패가 다른 모듈에 영향을 미치는 위험을 최소화합니다.\n- 유연성: 팀이 독립적으로 모듈을 개발하고 배포할 수 있어 빠른 이터레이션 및 릴리스 주기를 용이하게 합니다.\n- 확장성: 동일 모듈의 인스턴스를 추가함으로써 수평적으로 손쉽게 확장할 수 있습니다.\n\n\n\n단점:\n\n- 성능 오버헤드: 동적 모듈 로딩으로 인한 초기 로드 시간 증가 및 런타임 오버헤드 가능성.\n- 복잡성: 모듈 로딩, 라우팅 및 통신 처리를 위한 견고한 조율 메커니즘 필요.\n\n실제 사례 시나리오: 각 모듈이 구체적인 쇼핑 기능을 나타내는 전자 상거래 플랫폼(예: 제품 목록, 장바구니 관리, 결제 과정).\n\nEdge 구성은 중앙 게이트웨이 또는 Edge 서버를 통해 요청을 경유하며, 요청된 URL에 기반하여 프론트엔드 모듈을 동적으로 조합합니다. Edge 서버는 서버리스 함수나 리버스 프록시를 사용하여 구성된 애플리케이션을 사용자에게 제공할 수 있습니다.\n\n\n\n장점:\n\n- 효율성: 구성이 네트워크 가장자리에서 발생하기 때문에 클라이언트 측 부하가 줄어듭니다.\n- 보안: 요청의 중앙화된 처리로 통합 보안 정책과 접근 제어가 가능합니다.\n- 성능: 가장자리에서 개선된 캐싱 및 콘텐츠 전달 최적화가 이루어집니다.\n\n단점:\n\n- 복잡한 배포: 글로벌 배포를 위해 가장자리 인프라를 설정하고 관리하는 것은 어려울 수 있습니다.\n- 한정된 동적성: 구성 논리 변경시 가장자리 서버 구성 업데이트가 필요할 수 있습니다.\n\n\n\n실제 사례 시나리오: 다양한 모듈이 콘텐츠 유형(예: 기사, 동영상, 이미지)을 나타내며 사용자 요청에 따라 조합되는 콘텐츠 관리 시스템입니다.\n\n# 수평 마이크로프론트엔드 아키텍처:\n\n![Horizontal Micro-Frontend Architecture](/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_2.png)\n\n수평 마이크로프론트엔드 아키텍처에서는 모듈이 공유된 기능 또는 구성 요소 주변에 정리되며 각 모듈이 전체 응용 프로그램에 특정 기능을 기여합니다. 수평 마이크로프론트엔드와 관련된 조합 전술을 살펴보겠습니다.\n\n\n\n수직 아키텍처와 유사하게, 수평 미크로 프론트엔드에서의 클라이언트 측 구성은 사용자의 브라우저 내에서 모듈을 동적으로 로드하고 통합하는 것을 의미합니다. 그러나 수평 아키텍처의 경우, 모듈은 주로 재사용 가능한 UI 구성 요소나 서비스를 제공하는 데 중점을 두며 완전한 기능을 제공하기보다는 집중적으로 활용됩니다.\n\n장점:\n\n- 재사용성: 공유 UI 구성 요소와 서비스는 일관성을 유지하고 모듈 간의 중복을 줄이는 데 도움이 됩니다.\n- 협업: 응용 프로그램의 다른 부분에 작업하는 팀 간의 협력을 촉진합니다.\n- 점진적 적용: 개별 구성 요소를 대체함으로써 단일체에서 미크로프론트엔드 아키텍처로 점진적인 이전이 가능합니다.\n\n단점:\n\n\n\n- 종속성 관리: 공유 종속성과 통신 프로토콜은 신중한 버전 및 호환성 관리가 필요합니다.\n- 조정 오버헤드: 모듈 간 일관된 UI/UX를 보장하는 것은 추가 조정 노력이 필요할 수 있습니다.\n\n실제 사례 시나리오: 대시보드 애플리케이션에서 모듈이 다른 데이터 시각화 구성 요소(예: 차트, 표, 지도)를 나타내며 여러 페이지나 뷰에서 공유됩니다.\n\n서버 측 구성에서는 백엔드 서버가 클라이언트로 전송하기 전에 모듈의 출력을 결합한 최종 HTML 마크업을 집계하고 렌더링하는 역할을 합니다. 이 접근 방식은 종종 Next.js나 Nuxt.js와 같은 서버 측 렌더링(SSR) 프레임워크와 함께 사용됩니다.\n\n장점:\n\n\n\n**장점:**\n\n- 성능: 초기 페이지 로드 시간을 서버에서 조합된 HTML을 렌더링하여 최적화할 수 있습니다.\n- SEO: 서버 렌더링된 콘텐츠는 검색 엔진에 더 쉽게 색인되어 발견성을 향상시킵니다.\n- 점진적인 향상: 제한된 JavaScript 기능을 갖는 클라이언트에 대해 우아한 저하를 가능하게 합니다.\n\n**단점:**\n\n- 서버 부하: 복잡한 조합을 위한 서버 측 처리와 렌더링 부하가 증가합니다.\n- 강한 결합: 백엔드 서버가 조합 로직과 데이터 집계를 위한 단일 장애 지점이 됩니다.\n\n**실제 사례 시나리오:**\n\n- 모놀리식 전자 상거래 앱이 마이크로 프론트엔드로 변형되어 각 마이크로 애플리케이션이 독립적인 개발, 저장소, 배포를 필요로 하며 최소한의 의존성이나 제로 의존성이 필요한 것입니다. (예: 헤더, 푸터, 필터, 제품 목록 등)\n\n\n\n# 결론:\n\n수직 및 수평 미크로프론트엔드 아키텍처 사이를 선택하거나 적절한 구성 전술을 선택하는 것은 프로젝트 요구 사항, 팀 구조, 확장 가능성 요구 사항 및 성능 고려 사항과 같은 여러 요소에 의존합니다. 각 접근 방식의 장단점 및 실제 응용 프로그램을 이해함으로써, 개발 팀은 특정 사용 사례 및 목표와 일치하는 정보에 기반한 결정을 내릴 수 있으며, 웹 개발의 계속 변화하는 환경에서 확장 가능하고 모듈식이며 유지 보수 가능한 프론트엔드 응용 프로그램을 위한 길을 열 수 있습니다.\n\n# Stackademic 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나기 전에:\n\n\n\n- 작가를 응원하고 팔로우해 주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루게 만드는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 더 많은 콘텐츠는 Stackademic.com에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_0.png"},"coverImage":"/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마이크로 프론트엔드는 현대 웹 개발에서 강력한 아키텍처 패턴으로 등장했습니다. 이는 팀이 거대한 프론트엔드 응용 프로그램을 더 작고 관리하기 쉬운 조각으로 나눌 수 있도록 합니다. 마이크로 프론트엔드 아키텍처에서 중요한 결정 중 하나는 수직 또는 수평 구성에 관한 선택입니다. 이러한 구성은 개별 프론트엔드 모듈이 구조화되고 전체 응용 프로그램에 통합되는 방식을 결정합니다. 이 기사에서는 수직 및 수평 마이크로 프론트엔드 아키텍처 간의 차이를 탐구하고 클라이언트 측, 엣지 및 서버 측과 같은 여러 구성 전술 및 각각의 장단점 및 실제 응용 프로그램을 살펴봅니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"수직형 마이크로 프론트엔드 아키텍처:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_1.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"수직 마이크로프런트엔드 아키텍처에서 각 모듈은 특정 수직 단위의 기능을 담당하며, 특정 기능이나 사용자 이동을 제공하기 위해 필요한 프론트엔드와 백엔드 구성 요소를 모두 포괄합니다. 수직 마이크로프런트엔드와 관련된 구성에 대해 자세히 살펴봅시다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"클라이언트 측 구성에서 모듈은 독립적으로 개발 및 배포되며, 최종 구성은 사용자의 브라우저 내에서 발생합니다. JavaScript 오케스트레이터인 single-spa 또는 Webpack Module Federation과 같은 도구를 사용하여 런타임에서 모듈을 동적으로 로드하고 통합하는 것이 일반적입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"장점:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"격리성: 각 모듈은 독립적으로 작동하여 한 모듈의 실패가 다른 모듈에 영향을 미치는 위험을 최소화합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"유연성: 팀이 독립적으로 모듈을 개발하고 배포할 수 있어 빠른 이터레이션 및 릴리스 주기를 용이하게 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"확장성: 동일 모듈의 인스턴스를 추가함으로써 수평적으로 손쉽게 확장할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단점:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"성능 오버헤드: 동적 모듈 로딩으로 인한 초기 로드 시간 증가 및 런타임 오버헤드 가능성.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"복잡성: 모듈 로딩, 라우팅 및 통신 처리를 위한 견고한 조율 메커니즘 필요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실제 사례 시나리오: 각 모듈이 구체적인 쇼핑 기능을 나타내는 전자 상거래 플랫폼(예: 제품 목록, 장바구니 관리, 결제 과정).\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Edge 구성은 중앙 게이트웨이 또는 Edge 서버를 통해 요청을 경유하며, 요청된 URL에 기반하여 프론트엔드 모듈을 동적으로 조합합니다. Edge 서버는 서버리스 함수나 리버스 프록시를 사용하여 구성된 애플리케이션을 사용자에게 제공할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"장점:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"효율성: 구성이 네트워크 가장자리에서 발생하기 때문에 클라이언트 측 부하가 줄어듭니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"보안: 요청의 중앙화된 처리로 통합 보안 정책과 접근 제어가 가능합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"성능: 가장자리에서 개선된 캐싱 및 콘텐츠 전달 최적화가 이루어집니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단점:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"복잡한 배포: 글로벌 배포를 위해 가장자리 인프라를 설정하고 관리하는 것은 어려울 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"한정된 동적성: 구성 논리 변경시 가장자리 서버 구성 업데이트가 필요할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실제 사례 시나리오: 다양한 모듈이 콘텐츠 유형(예: 기사, 동영상, 이미지)을 나타내며 사용자 요청에 따라 조합되는 콘텐츠 관리 시스템입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"수평 마이크로프론트엔드 아키텍처:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled_2.png\",\n        alt: \"Horizontal Micro-Frontend Architecture\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"수평 마이크로프론트엔드 아키텍처에서는 모듈이 공유된 기능 또는 구성 요소 주변에 정리되며 각 모듈이 전체 응용 프로그램에 특정 기능을 기여합니다. 수평 마이크로프론트엔드와 관련된 조합 전술을 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"수직 아키텍처와 유사하게, 수평 미크로 프론트엔드에서의 클라이언트 측 구성은 사용자의 브라우저 내에서 모듈을 동적으로 로드하고 통합하는 것을 의미합니다. 그러나 수평 아키텍처의 경우, 모듈은 주로 재사용 가능한 UI 구성 요소나 서비스를 제공하는 데 중점을 두며 완전한 기능을 제공하기보다는 집중적으로 활용됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"장점:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"재사용성: 공유 UI 구성 요소와 서비스는 일관성을 유지하고 모듈 간의 중복을 줄이는 데 도움이 됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"협업: 응용 프로그램의 다른 부분에 작업하는 팀 간의 협력을 촉진합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"점진적 적용: 개별 구성 요소를 대체함으로써 단일체에서 미크로프론트엔드 아키텍처로 점진적인 이전이 가능합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단점:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"종속성 관리: 공유 종속성과 통신 프로토콜은 신중한 버전 및 호환성 관리가 필요합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"조정 오버헤드: 모듈 간 일관된 UI/UX를 보장하는 것은 추가 조정 노력이 필요할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실제 사례 시나리오: 대시보드 애플리케이션에서 모듈이 다른 데이터 시각화 구성 요소(예: 차트, 표, 지도)를 나타내며 여러 페이지나 뷰에서 공유됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서버 측 구성에서는 백엔드 서버가 클라이언트로 전송하기 전에 모듈의 출력을 결합한 최종 HTML 마크업을 집계하고 렌더링하는 역할을 합니다. 이 접근 방식은 종종 Next.js나 Nuxt.js와 같은 서버 측 렌더링(SSR) 프레임워크와 함께 사용됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"장점:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"장점:\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"성능: 초기 페이지 로드 시간을 서버에서 조합된 HTML을 렌더링하여 최적화할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"SEO: 서버 렌더링된 콘텐츠는 검색 엔진에 더 쉽게 색인되어 발견성을 향상시킵니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"점진적인 향상: 제한된 JavaScript 기능을 갖는 클라이언트에 대해 우아한 저하를 가능하게 합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"단점:\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"서버 부하: 복잡한 조합을 위한 서버 측 처리와 렌더링 부하가 증가합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"강한 결합: 백엔드 서버가 조합 로직과 데이터 집계를 위한 단일 장애 지점이 됩니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"실제 사례 시나리오:\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"모놀리식 전자 상거래 앱이 마이크로 프론트엔드로 변형되어 각 마이크로 애플리케이션이 독립적인 개발, 저장소, 배포를 필요로 하며 최소한의 의존성이나 제로 의존성이 필요한 것입니다. (예: 헤더, 푸터, 필터, 제품 목록 등)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"수직 및 수평 미크로프론트엔드 아키텍처 사이를 선택하거나 적절한 구성 전술을 선택하는 것은 프로젝트 요구 사항, 팀 구조, 확장 가능성 요구 사항 및 성능 고려 사항과 같은 여러 요소에 의존합니다. 각 접근 방식의 장단점 및 실제 응용 프로그램을 이해함으로써, 개발 팀은 특정 사용 사례 및 목표와 일치하는 정보에 기반한 결정을 내릴 수 있으며, 웹 개발의 계속 변화하는 환경에서 확장 가능하고 모듈식이며 유지 보수 가능한 프론트엔드 응용 프로그램을 위한 길을 열 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Stackademic 🎓\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"끝까지 읽어 주셔서 감사합니다. 떠나기 전에:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"작가를 응원하고 팔로우해 주세요! 👏\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"팔로우하기: X | LinkedIn | YouTube | Discord\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"다른 플랫폼 방문: In Plain English | CoFeed | Venture | Cubed\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"알고리즘 콘텐츠를 다루게 만드는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"더 많은 콘텐츠는 Stackademic.com에서 확인하세요\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-MasteringMicro-FrontendsVerticalvsHorizontalArchitecturesUnveiled"},"buildId":"z1a6VTi5qHH9JJH7jaxL3","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>