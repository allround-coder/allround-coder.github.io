<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker" data-gatsby-head="true"/><meta name="twitter:title" content="단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 23:21" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>모노 레포는 여러 프로젝트를 보관하는 버전 관리 코드 저장소입니다. 이러한 프로젝트들은 서로 관련이 있을 수 있지만 종종 논리적으로 독립적이며 다른 팀에 의해 운영됩니다. 일부 회사는 모든 코드를 모든 사람 사이에서 공유되는 단일 저장소에 호스팅합니다. 모노 레포는 거대한 크기에 도달할 수 있습니다.</p>
<p>저는 이러한 소프트웨어 개발 전략을 매우 매력적으로 생각했습니다. 팀 간의 장벽과 칸막이를 제거하여 함께 잘 작동하는 일련의 마이크로서비스를 설계하고 유지하는 것이 더 쉬워집니다.</p>
<p><img src="/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png" alt="이미지"></p>
<p>시작하기 전에 여기서 다룰 내용에 대한 기본적인 이해를 갖겠습니다.</p>
<ul>
<li>표준 프로젝트에서는 프로젝트 전체에서 사용되는 외부 종속성에 의존합니다.</li>
<li>이러한 종속성은 여러 프로젝트가 이를 필요로 할 경우 여러 복사본이 생길 수 있습니다.</li>
<li>여러 패키지가 서로 보완하는 경우 추상화가 최선의 접근 방식이 아닐 수 있습니다.</li>
<li>한 번에 여러 앱을 실행하는 것은 이해관계자들에게 보여주는 즐거움입니다.</li>
</ul>
<p>이 문서에서는 pnpm 워크스페이스, 프론트엔드에서 React, 백엔드에서 ExpressJS를 사용하여 풀 스택 애플리케이션을 구축할 것입니다:</p>
<ul>
<li>pnpm 워크스페이스: 이 프로젝트를 주관하고 클라이언트와 서버에서 필요한 일반적인 도구를 공유합니다.</li>
<li>클라이언트: React 애플리케이션을 실행하는 모든 프론트엔드 코드를 포함합니다.</li>
<li>서버: API 엔드포인트를 노출하는 ExpressJS 서버가 있습니다.</li>
</ul>
<p>전제 조건:</p>
<ul>
<li>NodeJS: Node.js 설치 방법</li>
<li>pnpm: pnpm 설치 방법</li>
</ul>
<h2>pnpm 워크스페이스</h2>
<ul>
<li>루트 폴더에 pnpm 워크스페이스 생성하기</li>
</ul>
<pre><code class="hljs language-js">pnpm init
</code></pre>
<ul>
<li>패키지라는 폴더를 만드세요. 여기에는 클라이언트와 서버가 들어갈 거에요.</li>
</ul>
<pre><code class="hljs language-js">mkdir packages
</code></pre>
<ul>
<li>pnpm-workspace.yaml 파일을 생성하세요. 이를 통해 pnpm이 제 패키지 폴더를 확인할 수 있어요.</li>
</ul>
<pre><code class="hljs language-js">touch pnpm-workspace.<span class="hljs-property">yaml</span>
</code></pre>
<ul>
<li>우리는 pnpm에게 내 패키지가 직장의 일부임을 알려줄 거에요.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">//pnpm-workspace.yaml</span>
<span class="hljs-attr">packages</span>:
  - <span class="hljs-string">'packages/*'</span>
</code></pre>
<ul>
<li>루트 디렉토리에 docker-compose.yml 파일을 만들어주세요. 나중에 이에 대해 이야기할 거에요</li>
</ul>
<pre><code class="hljs language-js">touch docker-compose.<span class="hljs-property">yml</span>
</code></pre>
<h2>클라이언트</h2>
<ul>
<li>우리는 Vite를 사용하여 리액트 프로젝트를 설정할 것입니다. 프로젝트 이름은 client로 지정하세요. 이 이름은 pnpm이 이 패키지를 감지하는 방법이기 때문에 중요합니다.</li>
</ul>
<pre><code class="hljs language-js"> pnpm create vite
</code></pre>
<ul>
<li>클라이언트를 위한 모든 종속성을 설치합니다. pnpm이 루트에 node_modules 폴더를 가지고 있다는 것에 주목하세요. 멋지죠!</li>
</ul>
<pre><code class="hljs language-js">cd client
pnpm install
pnpm run dev
</code></pre>
<ul>
<li>클라이언트용 도커 파일</li>
</ul>
<pre><code class="hljs language-js">touch <span class="hljs-title class_">Dockerfile</span>
</code></pre>
<h2>서버</h2>
<ul>
<li>여기에 익스프레스 애플리케이션을 설정할 거에요. 그를 위해 패키지 폴더로 이동하여 서버 폴더를 만들어야 해요.</li>
</ul>
<pre><code class="hljs language-js">mkdir server
cd server
</code></pre>
<ul>
<li>서버 폴더 안에 새로운 npm 패키지를 생성할 거에요.</li>
</ul>
<pre><code class="hljs language-js">npm init
</code></pre>
<ul>
<li>그리고 Express 프레임워크를 설치하세요.</li>
</ul>
<pre><code class="hljs language-js">npm install express
</code></pre>
<ul>
<li>서버용 도커 파일도 만들어주세요.</li>
</ul>
<pre><code class="hljs language-js">touch <span class="hljs-title class_">Dockerfile</span>
</code></pre>
<ul>
<li>멋져요, 우리 절반 이상을 이미 지났어요! 그리고 이미 풀 스택 앱을 만들었다니 축하해요(조금 더 연결이 필요하지만, 클라이언트에서 서버로) :)</li>
</ul>
<p>연결이 얼마나 잘 되었는지 확인해봐요!</p>
<h2>서버 + 클라이언트</h2>
<ul>
<li>서버에 index.js 파일을 만들어, 잘 진행 중이라고 말하고 <a href="http://localhost:3000%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">http://localhost:3000에서</a> 제공할 목록이 있어요</li>
</ul>
<pre><code class="hljs language-js">touch index.<span class="hljs-property">js</span>
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// server/index.js</span>
<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">"express"</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PORT</span> = <span class="hljs-number">3000</span>;

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/"</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {
  res.<span class="hljs-title function_">json</span>([
    { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">"Jane"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">"Bob"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">35</span> },
  ]);
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-variable constant_">PORT</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I am doing great and serving at <span class="hljs-subst">${PORT}</span>`</span>);
});
</code></pre>
<ul>
<li>패키지.json에서 서버를 시작하는 스크립트를 추가하세요.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"dev"</span>: <span class="hljs-string">"node index.js"</span>,
    <span class="hljs-string">"test"</span>: <span class="hljs-string">"echo \"Error: no test specified\" &#x26;&#x26; exit 1"</span>
},
</code></pre>
<ul>
<li>그리고 물론 실행해 주세요</li>
</ul>
<pre><code class="hljs language-js">pnpm run dev
</code></pre>
<ul>
<li>이제 클라이언트에서 이 목록을 받습니다. Vite는 이를 사용하여 프론트엔드에서 <a href="http://localhost:3000%EC%9D%84" rel="nofollow" target="_blank">http://localhost:3000을</a> 자체 URL처럼 사용할 수 있습니다. 귀찮은 CORS 오류도 없어요 :) 이 코드를 vite.config.ts에 추가해 보세요.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">"vite"</span>;
<span class="hljs-keyword">import</span> react <span class="hljs-keyword">from</span> <span class="hljs-string">"@vitejs/plugin-react"</span>;

<span class="hljs-comment">// https://vitejs.dev/config/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>,
    <span class="hljs-attr">strictPort</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">host</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">origin</span>: <span class="hljs-string">"http://0.0.0.0:8080"</span>,
    <span class="hljs-attr">proxy</span>: {
      <span class="hljs-string">"/api"</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">"http://localhost:3000"</span>,
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path: string</span>) =></span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">""</span>),
      },
    },
  },
});
</code></pre>
<ul>
<li>vite.config.ts 파일에서는 특별한 것이 없어요. localhost와 네트워크의 8080 포트에서 프론트엔드 코드를 실행합니다. 그리고 백엔드 API인 <a href="http://localhost:3000%EC%9D%84" rel="nofollow" target="_blank">http://localhost:3000을</a> /api를 호출하여 프록시합니다.</li>
<li>이제 App.ts 파일에서는 /api를 호출하여 <a href="http://localhost:3000%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">http://localhost:3000에서</a> 데이터를 가져옵니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">import</span> <span class="hljs-string">"./App.css"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [data, setData] = useState&#x3C;any>(<span class="hljs-literal">null</span>);
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) => {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"/api"</span>);
      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
      <span class="hljs-title function_">setData</span>(data);
    };
    <span class="hljs-title function_">fetchData</span>();
  }, []);

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;></span>{data &#x26;&#x26; <span class="hljs-tag">&#x3C;<span class="hljs-name">pre</span>></span>{JSON.stringify(data, null, 2)}<span class="hljs-tag">&#x3C;/<span class="hljs-name">pre</span>></span>}<span class="hljs-tag">&#x3C;/></span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<ul>
<li>목록을 보려면 프론트앱을 시작해주세요.</li>
</ul>
<pre><code class="hljs language-js">pnpm run dev
</code></pre>
<p>이제 이 앱은 풀 스택 앱입니다! 그러나 pnpm에서 개발 경험을 향상시키고 이전에 만들었던 Docker 파일을 사용해 봅시다.</p>
<p>개선 사항</p>
<ul>
<li>이제 백엔드와 프론트엔드를 별도로 시작해야 하므로, 워크스페이스 루트에 이를 추가하여 단일 명령으로 실행할 수 있게 합시다. package.json에 다음을 추가하여 pnpm run app을 통해 모두 시작할 수 있도록 하겠습니다!</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"client"</span>: <span class="hljs-string">"pnpm --filter \"client\" run dev"</span>,
    <span class="hljs-string">"server"</span>: <span class="hljs-string">"pnpm --filter \"server\" run dev"</span>,
    <span class="hljs-string">"app"</span>: <span class="hljs-string">"pnpm run client &#x26; pnpm run server"</span>
},
</code></pre>
<ul>
<li>클라이언트용 Dockerfile</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">node</span>:latest

# 컨테이너 내의 작업 디렉토리 설정
<span class="hljs-variable constant_">WORKDIR</span> /app/client

# 클라이언트 package.<span class="hljs-property">json</span> 복사
<span class="hljs-variable constant_">COPY</span> package.<span class="hljs-property">json</span> .

# 의존성 설치 
<span class="hljs-variable constant_">RUN</span> npm install

# 코드를 도커 이미지로 모두 복사
<span class="hljs-variable constant_">COPY</span> .

<span class="hljs-variable constant_">EXPOSE</span> <span class="hljs-number">8080</span>

<span class="hljs-variable constant_">CMD</span> [<span class="hljs-string">"npm"</span>,<span class="hljs-string">"run"</span>, <span class="hljs-string">"dev"</span>]
</code></pre>
<ul>
<li>서버용 Dockerfile</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">node</span>:latest

# 컨테이너 내의 작업 디렉토리 설정
<span class="hljs-variable constant_">WORKDIR</span> /app/server

# 서버 package.<span class="hljs-property">json</span> 복사
<span class="hljs-variable constant_">COPY</span> package.<span class="hljs-property">json</span> .

# 의존성 설치
<span class="hljs-variable constant_">RUN</span> npm install

# 코드를 도커 이미지로 모두 복사
<span class="hljs-variable constant_">COPY</span> .

<span class="hljs-variable constant_">EXPOSE</span> <span class="hljs-number">3000</span>

<span class="hljs-variable constant_">CMD</span> [<span class="hljs-string">"npm"</span>,<span class="hljs-string">"run"</span>, <span class="hljs-string">"dev"</span>]
</code></pre>
<ul>
<li>도커 컴포즈 파일로 이동하기 전에, 클라이언트 폴더의 vite.config.ts 파일에서 약간의 조정을 해보겠어요. 이 조정 내용은 이미지를 만들 때 'server_c'라는 이름의 서버 컨테이너를 사용하므로 기본적으로 로컬호스트가 아닌 http://server_c:3000을 타겟하도록 프론트엔드에 알려주는 것이에요.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">react</span>()],
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>,
    <span class="hljs-attr">strictPort</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">host</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">origin</span>: <span class="hljs-string">"http://0.0.0.0:8080"</span>,
    <span class="hljs-attr">proxy</span>: {
      <span class="hljs-string">"/api"</span>: {
        <span class="hljs-attr">target</span>:
          process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">"docker"</span>
            ? <span class="hljs-string">"http://server_c:3000"</span>
            : <span class="hljs-string">"http://localhost:3000"</span>,
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path: string</span>) =></span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">""</span>),
      },
    },
  },
});
</code></pre>
<ul>
<li>루트 디렉토리에 위치한 도커 컴포즈 파일을 사용하여 두 이미지를 만들어봅시다. vite.config.ts 파일에서 제공하는 NODE_ENV=docker 환경을 주의해주세요.</li>
</ul>
<pre><code class="hljs language-yaml"><span class="hljs-attr">services:</span>
  <span class="hljs-attr">client:</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">./packages/client</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">client_c</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"8080:8080"</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">NODE_ENV=docker</span>

  <span class="hljs-attr">server:</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">./packages/server</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">server_c</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"3000:3000"</span>
</code></pre>
<p>여기서 재밌는 마크다운 표 형식을 사용한 코드가 있어요. 도커 이미지를 빌드하고 도커 환경에서 앱을 시작하려면 docker-compose 파일을 실행해보세요!</p>
<pre><code class="hljs language-js">docker-compose up
</code></pre>
<p>더 많은 코드들은 여기에서 확인할 수 있어요. 계속 배우고 있어요.</p>
<h1>Stackademic 🎓</h1>
<p>끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:</p>
<ul>
<li>글을 추천하고 작가를 팔로우해 주시는 것을 고려해주세요! 👏</li>
<li>우리를 팔로우해주세요: X | LinkedIn | YouTube | Discord</li>
<li>다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed</li>
<li>알고리즘 콘텐츠와 싸우는 블로깅 플랫폼에 지치셨나요? Differ를 시도해보세요</li>
<li>Stackademic.com에서 더 많은 콘텐츠를 만나보세요</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"단순한 풀 스택 애플리케이션을 만들어보자 pnpm, React, Express 및 Docker를 사용한 모노 레포","description":"","date":"2024-05-12 23:21","slug":"2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker","content":"\n\n모노 레포는 여러 프로젝트를 보관하는 버전 관리 코드 저장소입니다. 이러한 프로젝트들은 서로 관련이 있을 수 있지만 종종 논리적으로 독립적이며 다른 팀에 의해 운영됩니다. 일부 회사는 모든 코드를 모든 사람 사이에서 공유되는 단일 저장소에 호스팅합니다. 모노 레포는 거대한 크기에 도달할 수 있습니다.\n\n저는 이러한 소프트웨어 개발 전략을 매우 매력적으로 생각했습니다. 팀 간의 장벽과 칸막이를 제거하여 함께 잘 작동하는 일련의 마이크로서비스를 설계하고 유지하는 것이 더 쉬워집니다.\n\n![이미지](/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png)\n\n시작하기 전에 여기서 다룰 내용에 대한 기본적인 이해를 갖겠습니다.\n\n\n\n- 표준 프로젝트에서는 프로젝트 전체에서 사용되는 외부 종속성에 의존합니다.\n- 이러한 종속성은 여러 프로젝트가 이를 필요로 할 경우 여러 복사본이 생길 수 있습니다.\n- 여러 패키지가 서로 보완하는 경우 추상화가 최선의 접근 방식이 아닐 수 있습니다.\n- 한 번에 여러 앱을 실행하는 것은 이해관계자들에게 보여주는 즐거움입니다.\n\n이 문서에서는 pnpm 워크스페이스, 프론트엔드에서 React, 백엔드에서 ExpressJS를 사용하여 풀 스택 애플리케이션을 구축할 것입니다:\n\n- pnpm 워크스페이스: 이 프로젝트를 주관하고 클라이언트와 서버에서 필요한 일반적인 도구를 공유합니다.\n- 클라이언트: React 애플리케이션을 실행하는 모든 프론트엔드 코드를 포함합니다.\n- 서버: API 엔드포인트를 노출하는 ExpressJS 서버가 있습니다.\n\n전제 조건:\n\n\n\n- NodeJS: Node.js 설치 방법\n- pnpm: pnpm 설치 방법\n\n## pnpm 워크스페이스\n\n- 루트 폴더에 pnpm 워크스페이스 생성하기\n\n```js\npnpm init\n```\n\n\n\n- 패키지라는 폴더를 만드세요. 여기에는 클라이언트와 서버가 들어갈 거에요.\n\n```js\nmkdir packages\n```\n\n- pnpm-workspace.yaml 파일을 생성하세요. 이를 통해 pnpm이 제 패키지 폴더를 확인할 수 있어요.\n\n```js\ntouch pnpm-workspace.yaml\n```\n\n\n\n- 우리는 pnpm에게 내 패키지가 직장의 일부임을 알려줄 거에요.\n\n```js\n//pnpm-workspace.yaml\npackages:\n  - 'packages/*'\n```\n\n- 루트 디렉토리에 docker-compose.yml 파일을 만들어주세요. 나중에 이에 대해 이야기할 거에요\n\n```js\ntouch docker-compose.yml\n```\n\n\n\n## 클라이언트\n\n- 우리는 Vite를 사용하여 리액트 프로젝트를 설정할 것입니다. 프로젝트 이름은 client로 지정하세요. 이 이름은 pnpm이 이 패키지를 감지하는 방법이기 때문에 중요합니다.\n\n```js\n pnpm create vite\n```\n\n- 클라이언트를 위한 모든 종속성을 설치합니다. pnpm이 루트에 node_modules 폴더를 가지고 있다는 것에 주목하세요. 멋지죠!\n\n\n\n```js\ncd client\npnpm install\npnpm run dev\n```\n\n- 클라이언트용 도커 파일\n\n```js\ntouch Dockerfile\n```\n\n## 서버\n\n\n\n\n- 여기에 익스프레스 애플리케이션을 설정할 거에요. 그를 위해 패키지 폴더로 이동하여 서버 폴더를 만들어야 해요.\n\n```js\nmkdir server\ncd server\n```\n\n- 서버 폴더 안에 새로운 npm 패키지를 생성할 거에요.\n\n```js\nnpm init\n```\n\n\n\n- 그리고 Express 프레임워크를 설치하세요.\n\n```js\nnpm install express\n```\n\n- 서버용 도커 파일도 만들어주세요.\n\n```js\ntouch Dockerfile\n```\n\n\n\n- 멋져요, 우리 절반 이상을 이미 지났어요! 그리고 이미 풀 스택 앱을 만들었다니 축하해요(조금 더 연결이 필요하지만, 클라이언트에서 서버로) :)\n\n연결이 얼마나 잘 되었는지 확인해봐요!\n\n## 서버 + 클라이언트\n\n- 서버에 index.js 파일을 만들어, 잘 진행 중이라고 말하고 http://localhost:3000에서 제공할 목록이 있어요\n\n\n\n```js\ntouch index.js\n```\n\n```js\n// server/index.js\nconst express = require(\"express\");\nconst app = express();\nconst PORT = 3000;\n\napp.get(\"/\", (req, res) =\u003e {\n  res.json([\n    { name: \"John\", age: 25 },\n    { name: \"Jane\", age: 30 },\n    { name: \"Bob\", age: 35 },\n  ]);\n});\n\napp.listen(PORT, () =\u003e {\n  console.log(`I am doing great and serving at ${PORT}`);\n});\n```\n\n- 패키지.json에서 서버를 시작하는 스크립트를 추가하세요.\n\n```js\n\"scripts\": {\n    \"dev\": \"node index.js\",\n    \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\"\n},\n```\n\n\n\n- 그리고 물론 실행해 주세요\n\n```js\npnpm run dev\n```\n\n- 이제 클라이언트에서 이 목록을 받습니다. Vite는 이를 사용하여 프론트엔드에서 http://localhost:3000을 자체 URL처럼 사용할 수 있습니다. 귀찮은 CORS 오류도 없어요 :) 이 코드를 vite.config.ts에 추가해 보세요.\n\n```js\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    port: 8080,\n    strictPort: true,\n    host: true,\n    origin: \"http://0.0.0.0:8080\",\n    proxy: {\n      \"/api\": {\n        target: \"http://localhost:3000\",\n        changeOrigin: true,\n        rewrite: (path: string) =\u003e path.replace(/^\\/api/, \"\"),\n      },\n    },\n  },\n});\n```\n\n\n\n- vite.config.ts 파일에서는 특별한 것이 없어요. localhost와 네트워크의 8080 포트에서 프론트엔드 코드를 실행합니다. 그리고 백엔드 API인 http://localhost:3000을 /api를 호출하여 프록시합니다.\n- 이제 App.ts 파일에서는 /api를 호출하여 http://localhost:3000에서 데이터를 가져옵니다.\n\n```js\nimport { useEffect, useState } from \"react\";\n\nimport \"./App.css\";\n\nfunction App() {\n  const [data, setData] = useState\u003cany\u003e(null);\n  useEffect(() =\u003e {\n    const fetchData = async () =\u003e {\n      const response = await fetch(\"/api\");\n      const data = await response.json();\n      console.log(data);\n      setData(data);\n    };\n    fetchData();\n  }, []);\n\n  return \u003c\u003e{data \u0026\u0026 \u003cpre\u003e{JSON.stringify(data, null, 2)}\u003c/pre\u003e}\u003c/\u003e;\n}\n\nexport default App;\n```\n\n- 목록을 보려면 프론트앱을 시작해주세요.\n\n```js\npnpm run dev\n```\n\n\n\n이제 이 앱은 풀 스택 앱입니다! 그러나 pnpm에서 개발 경험을 향상시키고 이전에 만들었던 Docker 파일을 사용해 봅시다.\n\n개선 사항\n\n- 이제 백엔드와 프론트엔드를 별도로 시작해야 하므로, 워크스페이스 루트에 이를 추가하여 단일 명령으로 실행할 수 있게 합시다. package.json에 다음을 추가하여 pnpm run app을 통해 모두 시작할 수 있도록 하겠습니다!\n\n```js\n\"scripts\": {\n    \"client\": \"pnpm --filter \\\"client\\\" run dev\",\n    \"server\": \"pnpm --filter \\\"server\\\" run dev\",\n    \"app\": \"pnpm run client \u0026 pnpm run server\"\n},\n```\n\n\n\n- 클라이언트용 Dockerfile\n\n```js\nFROM node:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\nWORKDIR /app/client\n\n# 클라이언트 package.json 복사\nCOPY package.json .\n\n# 의존성 설치 \nRUN npm install\n\n# 코드를 도커 이미지로 모두 복사\nCOPY .\n\nEXPOSE 8080\n\nCMD [\"npm\",\"run\", \"dev\"]\n```\n\n- 서버용 Dockerfile\n\n```js\nFROM node:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\nWORKDIR /app/server\n\n# 서버 package.json 복사\nCOPY package.json .\n\n# 의존성 설치\nRUN npm install\n\n# 코드를 도커 이미지로 모두 복사\nCOPY .\n\nEXPOSE 3000\n\nCMD [\"npm\",\"run\", \"dev\"]\n```\n\n\n\n- 도커 컴포즈 파일로 이동하기 전에, 클라이언트 폴더의 vite.config.ts 파일에서 약간의 조정을 해보겠어요. 이 조정 내용은 이미지를 만들 때 'server_c'라는 이름의 서버 컨테이너를 사용하므로 기본적으로 로컬호스트가 아닌 http://server_c:3000을 타겟하도록 프론트엔드에 알려주는 것이에요.\n\n```js\nexport default defineConfig({\n  plugins: [react()],\n  server: {\n    port: 8080,\n    strictPort: true,\n    host: true,\n    origin: \"http://0.0.0.0:8080\",\n    proxy: {\n      \"/api\": {\n        target:\n          process.env.NODE_ENV === \"docker\"\n            ? \"http://server_c:3000\"\n            : \"http://localhost:3000\",\n        changeOrigin: true,\n        rewrite: (path: string) =\u003e path.replace(/^\\/api/, \"\"),\n      },\n    },\n  },\n});\n```\n\n- 루트 디렉토리에 위치한 도커 컴포즈 파일을 사용하여 두 이미지를 만들어봅시다. vite.config.ts 파일에서 제공하는 NODE_ENV=docker 환경을 주의해주세요.\n\n```yaml\nservices:\n  client:\n    build: ./packages/client\n    container_name: client_c\n    ports:\n      - \"8080:8080\"\n    environment:\n      - NODE_ENV=docker\n\n  server:\n    build: ./packages/server\n    container_name: server_c\n    ports:\n      - \"3000:3000\"\n```\n\n\n\n여기서 재밌는 마크다운 표 형식을 사용한 코드가 있어요. 도커 이미지를 빌드하고 도커 환경에서 앱을 시작하려면 docker-compose 파일을 실행해보세요!\n\n```js\ndocker-compose up\n```\n\n더 많은 코드들은 여기에서 확인할 수 있어요. 계속 배우고 있어요.\n\n# Stackademic 🎓\n\n\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 글을 추천하고 작가를 팔로우해 주시는 것을 고려해주세요! 👏\n- 우리를 팔로우해주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠와 싸우는 블로깅 플랫폼에 지치셨나요? Differ를 시도해보세요\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png"},"coverImage":"/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e모노 레포는 여러 프로젝트를 보관하는 버전 관리 코드 저장소입니다. 이러한 프로젝트들은 서로 관련이 있을 수 있지만 종종 논리적으로 독립적이며 다른 팀에 의해 운영됩니다. 일부 회사는 모든 코드를 모든 사람 사이에서 공유되는 단일 저장소에 호스팅합니다. 모노 레포는 거대한 크기에 도달할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e저는 이러한 소프트웨어 개발 전략을 매우 매력적으로 생각했습니다. 팀 간의 장벽과 칸막이를 제거하여 함께 잘 작동하는 일련의 마이크로서비스를 설계하고 유지하는 것이 더 쉬워집니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e시작하기 전에 여기서 다룰 내용에 대한 기본적인 이해를 갖겠습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e표준 프로젝트에서는 프로젝트 전체에서 사용되는 외부 종속성에 의존합니다.\u003c/li\u003e\n\u003cli\u003e이러한 종속성은 여러 프로젝트가 이를 필요로 할 경우 여러 복사본이 생길 수 있습니다.\u003c/li\u003e\n\u003cli\u003e여러 패키지가 서로 보완하는 경우 추상화가 최선의 접근 방식이 아닐 수 있습니다.\u003c/li\u003e\n\u003cli\u003e한 번에 여러 앱을 실행하는 것은 이해관계자들에게 보여주는 즐거움입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 문서에서는 pnpm 워크스페이스, 프론트엔드에서 React, 백엔드에서 ExpressJS를 사용하여 풀 스택 애플리케이션을 구축할 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epnpm 워크스페이스: 이 프로젝트를 주관하고 클라이언트와 서버에서 필요한 일반적인 도구를 공유합니다.\u003c/li\u003e\n\u003cli\u003e클라이언트: React 애플리케이션을 실행하는 모든 프론트엔드 코드를 포함합니다.\u003c/li\u003e\n\u003cli\u003e서버: API 엔드포인트를 노출하는 ExpressJS 서버가 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e전제 조건:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNodeJS: Node.js 설치 방법\u003c/li\u003e\n\u003cli\u003epnpm: pnpm 설치 방법\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003epnpm 워크스페이스\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e루트 폴더에 pnpm 워크스페이스 생성하기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epnpm init\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e패키지라는 폴더를 만드세요. 여기에는 클라이언트와 서버가 들어갈 거에요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emkdir packages\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003epnpm-workspace.yaml 파일을 생성하세요. 이를 통해 pnpm이 제 패키지 폴더를 확인할 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etouch pnpm-workspace.\u003cspan class=\"hljs-property\"\u003eyaml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e우리는 pnpm에게 내 패키지가 직장의 일부임을 알려줄 거에요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//pnpm-workspace.yaml\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003epackages\u003c/span\u003e:\n  - \u003cspan class=\"hljs-string\"\u003e'packages/*'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e루트 디렉토리에 docker-compose.yml 파일을 만들어주세요. 나중에 이에 대해 이야기할 거에요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etouch docker-compose.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e클라이언트\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e우리는 Vite를 사용하여 리액트 프로젝트를 설정할 것입니다. 프로젝트 이름은 client로 지정하세요. 이 이름은 pnpm이 이 패키지를 감지하는 방법이기 때문에 중요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e pnpm create vite\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e클라이언트를 위한 모든 종속성을 설치합니다. pnpm이 루트에 node_modules 폴더를 가지고 있다는 것에 주목하세요. 멋지죠!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd client\npnpm install\npnpm run dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e클라이언트용 도커 파일\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etouch \u003cspan class=\"hljs-title class_\"\u003eDockerfile\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e서버\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e여기에 익스프레스 애플리케이션을 설정할 거에요. 그를 위해 패키지 폴더로 이동하여 서버 폴더를 만들어야 해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emkdir server\ncd server\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e서버 폴더 안에 새로운 npm 패키지를 생성할 거에요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm init\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e그리고 Express 프레임워크를 설치하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install express\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e서버용 도커 파일도 만들어주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etouch \u003cspan class=\"hljs-title class_\"\u003eDockerfile\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e멋져요, 우리 절반 이상을 이미 지났어요! 그리고 이미 풀 스택 앱을 만들었다니 축하해요(조금 더 연결이 필요하지만, 클라이언트에서 서버로) :)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e연결이 얼마나 잘 되었는지 확인해봐요!\u003c/p\u003e\n\u003ch2\u003e서버 + 클라이언트\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e서버에 index.js 파일을 만들어, 잘 진행 중이라고 말하고 \u003ca href=\"http://localhost:3000%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:3000에서\u003c/a\u003e 제공할 목록이 있어요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etouch index.\u003cspan class=\"hljs-property\"\u003ejs\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// server/index.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e express = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"express\"\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePORT\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e;\n\napp.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/\"\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e([\n    { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"John\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e },\n    { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Jane\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e },\n    { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Bob\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e35\u003c/span\u003e },\n  ]);\n});\n\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003ePORT\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`I am doing great and serving at \u003cspan class=\"hljs-subst\"\u003e${PORT}\u003c/span\u003e`\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e패키지.json에서 서버를 시작하는 스크립트를 추가하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"scripts\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"dev\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"node index.js\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"test\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"echo \\\"Error: no test specified\\\" \u0026#x26;\u0026#x26; exit 1\"\u003c/span\u003e\n},\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e그리고 물론 실행해 주세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epnpm run dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e이제 클라이언트에서 이 목록을 받습니다. Vite는 이를 사용하여 프론트엔드에서 \u003ca href=\"http://localhost:3000%EC%9D%84\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:3000을\u003c/a\u003e 자체 URL처럼 사용할 수 있습니다. 귀찮은 CORS 오류도 없어요 :) 이 코드를 vite.config.ts에 추가해 보세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { defineConfig } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"vite\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e react \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@vitejs/plugin-react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// https://vitejs.dev/config/\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefineConfig\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\u003cspan class=\"hljs-title function_\"\u003ereact\u003c/span\u003e()],\n  \u003cspan class=\"hljs-attr\"\u003eserver\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003estrictPort\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ehost\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eorigin\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"http://0.0.0.0:8080\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eproxy\u003c/span\u003e: {\n      \u003cspan class=\"hljs-string\"\u003e\"/api\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003etarget\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"http://localhost:3000\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003echangeOrigin\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003erewrite\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003epath: string\u003c/span\u003e) =\u003e\u003c/span\u003e path.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/^\\/api/\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e),\n      },\n    },\n  },\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003evite.config.ts 파일에서는 특별한 것이 없어요. localhost와 네트워크의 8080 포트에서 프론트엔드 코드를 실행합니다. 그리고 백엔드 API인 \u003ca href=\"http://localhost:3000%EC%9D%84\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:3000을\u003c/a\u003e /api를 호출하여 프록시합니다.\u003c/li\u003e\n\u003cli\u003e이제 App.ts 파일에서는 /api를 호출하여 \u003ca href=\"http://localhost:3000%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:3000에서\u003c/a\u003e 데이터를 가져옵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useEffect, useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./App.css\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [data, setData] = useState\u0026#x3C;any\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/api\"\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data);\n      \u003cspan class=\"hljs-title function_\"\u003esetData\u003c/span\u003e(data);\n    };\n    \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e();\n  }, []);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e{data \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003epre\u003c/span\u003e\u003e\u003c/span\u003e{JSON.stringify(data, null, 2)}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003epre\u003c/span\u003e\u003e\u003c/span\u003e}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e목록을 보려면 프론트앱을 시작해주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epnpm run dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 이 앱은 풀 스택 앱입니다! 그러나 pnpm에서 개발 경험을 향상시키고 이전에 만들었던 Docker 파일을 사용해 봅시다.\u003c/p\u003e\n\u003cp\u003e개선 사항\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이제 백엔드와 프론트엔드를 별도로 시작해야 하므로, 워크스페이스 루트에 이를 추가하여 단일 명령으로 실행할 수 있게 합시다. package.json에 다음을 추가하여 pnpm run app을 통해 모두 시작할 수 있도록 하겠습니다!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"scripts\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"client\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"pnpm --filter \\\"client\\\" run dev\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"server\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"pnpm --filter \\\"server\\\" run dev\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"app\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"pnpm run client \u0026#x26; pnpm run server\"\u003c/span\u003e\n},\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e클라이언트용 Dockerfile\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enode\u003c/span\u003e:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\n\u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /app/client\n\n# 클라이언트 package.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e 복사\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e package.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e .\n\n# 의존성 설치 \n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e npm install\n\n# 코드를 도커 이미지로 모두 복사\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e .\n\n\u003cspan class=\"hljs-variable constant_\"\u003eEXPOSE\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable constant_\"\u003eCMD\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"npm\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"run\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"dev\"\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e서버용 Dockerfile\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enode\u003c/span\u003e:latest\n\n# 컨테이너 내의 작업 디렉토리 설정\n\u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /app/server\n\n# 서버 package.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e 복사\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e package.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e .\n\n# 의존성 설치\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e npm install\n\n# 코드를 도커 이미지로 모두 복사\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e .\n\n\u003cspan class=\"hljs-variable constant_\"\u003eEXPOSE\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable constant_\"\u003eCMD\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"npm\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"run\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"dev\"\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e도커 컴포즈 파일로 이동하기 전에, 클라이언트 폴더의 vite.config.ts 파일에서 약간의 조정을 해보겠어요. 이 조정 내용은 이미지를 만들 때 'server_c'라는 이름의 서버 컨테이너를 사용하므로 기본적으로 로컬호스트가 아닌 http://server_c:3000을 타겟하도록 프론트엔드에 알려주는 것이에요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefineConfig\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\u003cspan class=\"hljs-title function_\"\u003ereact\u003c/span\u003e()],\n  \u003cspan class=\"hljs-attr\"\u003eserver\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e8080\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003estrictPort\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ehost\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eorigin\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"http://0.0.0.0:8080\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eproxy\u003c/span\u003e: {\n      \u003cspan class=\"hljs-string\"\u003e\"/api\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003etarget\u003c/span\u003e:\n          process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNODE_ENV\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\"docker\"\u003c/span\u003e\n            ? \u003cspan class=\"hljs-string\"\u003e\"http://server_c:3000\"\u003c/span\u003e\n            : \u003cspan class=\"hljs-string\"\u003e\"http://localhost:3000\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003echangeOrigin\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003erewrite\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003epath: string\u003c/span\u003e) =\u003e\u003c/span\u003e path.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/^\\/api/\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e),\n      },\n    },\n  },\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e루트 디렉토리에 위치한 도커 컴포즈 파일을 사용하여 두 이미지를 만들어봅시다. vite.config.ts 파일에서 제공하는 NODE_ENV=docker 환경을 주의해주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eservices:\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eclient:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ebuild:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e./packages/client\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003econtainer_name:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eclient_c\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eports:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"8080:8080\"\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eenvironment:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eNODE_ENV=docker\u003c/span\u003e\n\n  \u003cspan class=\"hljs-attr\"\u003eserver:\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003ebuild:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e./packages/server\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003econtainer_name:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eserver_c\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eports:\u003c/span\u003e\n      \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"3000:3000\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 재밌는 마크다운 표 형식을 사용한 코드가 있어요. 도커 이미지를 빌드하고 도커 환경에서 앱을 시작하려면 docker-compose 파일을 실행해보세요!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker-compose up\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e더 많은 코드들은 여기에서 확인할 수 있어요. 계속 배우고 있어요.\u003c/p\u003e\n\u003ch1\u003eStackademic 🎓\u003c/h1\u003e\n\u003cp\u003e끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e글을 추천하고 작가를 팔로우해 주시는 것을 고려해주세요! 👏\u003c/li\u003e\n\u003cli\u003e우리를 팔로우해주세요: X | LinkedIn | YouTube | Discord\u003c/li\u003e\n\u003cli\u003e다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\u003c/li\u003e\n\u003cli\u003e알고리즘 콘텐츠와 싸우는 블로깅 플랫폼에 지치셨나요? Differ를 시도해보세요\u003c/li\u003e\n\u003cli\u003eStackademic.com에서 더 많은 콘텐츠를 만나보세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-Creatingasimplefull-stackapplicationwithmonorepousingpnpmReactExpressandDocker"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>