<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>시스템 객체 확장으로 자바스크립트 DOM 빌더를 개선하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-01-BuildingABetterJavaScriptDOMBuilderPart2ExtendingSystemObjects" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="시스템 객체 확장으로 자바스크립트 DOM 빌더를 개선하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="시스템 객체 확장으로 자바스크립트 DOM 빌더를 개선하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-01-BuildingABetterJavaScriptDOMBuilderPart2ExtendingSystemObjects_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-01-BuildingABetterJavaScriptDOMBuilderPart2ExtendingSystemObjects" data-gatsby-head="true"/><meta name="twitter:title" content="시스템 객체 확장으로 자바스크립트 DOM 빌더를 개선하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-01-BuildingABetterJavaScriptDOMBuilderPart2ExtendingSystemObjects_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-01 23:02" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">시스템 객체 확장으로 자바스크립트 DOM 빌더를 개선하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="시스템 객체 확장으로 자바스크립트 DOM 빌더를 개선하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 1, 2024</span><span class="posts_reading_time__f7YPP">19<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-01-BuildingABetterJavaScriptDOMBuilderPart2ExtendingSystemObjects&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>첫 번째 부분에서는 DOM-JON 개념을 소개했습니다. HTML을 JSON 스타일의 네임스페이스로 재구성하고, 이를 DOM에 직접 번역하는 과정을 간단하게 소개하며, InnerHTML을 통해 작업하는 대신에 바로 DOM으로 이동하는 이유를 다뤘습니다.</p>
<p>간단한 사이드 노트, 이 기사의 목적은 여러분에게 이것을 사용하는 방법을 가르치는 것이 아니라, 제가 이를 구축하는 과정에서의 사고 과정을 공유하는 것입니다. 실시간으로 말이에요. 피드백을 받기 위해 내 머릿속에 정리하기 위해 글로 써내리기도! 문서화 및 전체 웹사이트는 나중에 제작될 예정입니다.</p>
<p>이번에는 기존 엘리먼트에 여러 노드를 쉽게 적용할 수 있도록하고, 이전 "make" 루틴의 "attach" 부분에 대한 액세스를 독립적으로 제공하고, 속성 처리를 더 견고하게 만들고자 합니다.</p>
<p>'원인은 몇 가지 부족한 것이 있기 때문이죠. Element.style 나 Element.dataset과 같은 속성은 Object.assign을 통해 요소에 적용할 수 없습니다. 속성에 직접 적용해야 합니다. 또한 DOM-JON 구조의 "속성 객체"를 사용하여 요소를 "배치"하는 방법과 같은 다른 정보를 전달할 수 있다면 좋겠어요.</p>
<p>이 부분을 간단히 하는 가장 좋은 방법은 무엇일까요?</p>
<h1>시스템 객체 확장</h1>
<p>기본적으로, 저는 기존 Document, Object, Node 및 Element 객체에 내 방법을 추가할 것입니다. 부모 클래스에 대한 정적 값 및 프로토타입에 대해서도 추가할 겁니다.</p>
<p>이제 이 일에 대해 너무 많은 공포가 있어요. 마치 JavaScript의 강력하고 다용도 객체 모델을 수정하면 안 된다는 것처럼 말이죠. "결코 하지 말아야 한다!" 라고 하는 분들은 충분한 이유 없이 말하는 경우가 많아요. 하지만 합당한 우려가 세 가지 있습니다.</p>
<ul>
<li>IE 7 / 이전 버전은 기존 객체에 프로토 타입 변경을 상속하지 않습니다.</li>
<li>우리 자신의 함수와 언어의 미래 변경 사이에 이름 충돌의 문을 열어둡니다.</li>
<li>변경할 수 있는 객체를 실수로 덮어쓰고, 이들을 열거할 수 있을 경우에 덮어쓸 수 있습니다.</li>
</ul>
<p>그 첫 번째 우려는 어질어질해요! 이제는 2024년이에요. 우리는 전혀 구식이 아닌 JavaScript를 쓰고 있어요. nullish coalescing, for..of, IE 어떤 버전에서도 작동하지 않는 spread / rest 연산자 등을 사용하고 있어요. 심지어 "화살표 함수"가 있으면 익스플로러의 JSCRIPT 엔진이 즉시 다운될 정도에요.</p>
<p>두 번째로, 이 문제는 네이밍 규칙을 사용하여 쉽게 해결할 수 있어요. 이런 경우에는 lodash의 방식을 가져와서 모든 사용자 지정 메서드와 속성의 시작에 이중 밑줄을 사용할 거에요. 누군가가 비슷한 기교를 사용하지 않는 한 문제없을 거예요.</p>
<p>저 세 번째 코드는 대부분 사람들이 바보같은 일을 하는 경우에 발생한 것이에요:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Element</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__make</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">tagName, ...attach</span>) {}
</code></pre>
<p>해야 할 것은 다음과 같아요:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(
  <span class="hljs-title class_">Element</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,
  <span class="hljs-string">"__make"</span>,
  { value : <span class="hljs-keyword">function</span>(<span class="hljs-params">tagName, ...attach</span>) {} }
);
</code></pre>
<p>Object.definePropert[ies | y]는 우리의 친구입니다... 그리고 JavaScript의 가장 안타깝게도 under-used한 부분 중 하나입니다. 전체 새 클래스를 만들지 않고 기존 Object에 추가하는 능력은 엄청 유용합니다. 시스템 객체가 이미 존재하기 때문에 전역 네임스페이스에 추가하는 것처럼 보이지 않습니다. 기본적으로 이러한 메서드에 의해 추가된 객체 속성 - 네, 속성, "속성"이 아니라. 그렇습니다, 심지어 DOM에 있는 경우도! - 객체에 대해 열거할 수 없게 만듭니다. 시스템 메서드만큼 "숨겨진" 것입니다. 현대 클래스에서 #을 접두사로 붙일 때와 같습니다. 필요할 경우에는 열거 가능하게 만들기 위해 인수 객체에 enumerable:true를 추가할 수도 있습니다.</p>
<h1>Object.definepropert[ies|y] 개선하기</h1>
<p>이 함수들을 좋아하지만, 문법에는 약간 번잡한 부분이 있어 불필요하게 장황하게 느끼게 할 수 있습니다. 이전 기사에서처럼 "타입"을 가로채서 요소의 "타입"을 확인하여 일반 객체를 전달하면 defineProperty과 같이 동작하지만, 다른 값 유형은 자동으로 가장 일반적으로 사용하는 기술인 객체 <code>{</code> value <code>}</code>에 래핑하게 할 수 있습니다.</p>
<p>이를 돕기 위해 - 특히 일반 Object를 후손으로부터 격리하기 위해 - 나만의 Object.__type 루틴을 추가합니다. JavaScript에서 가장 큰 고통 중 하나는 범용 "데이터 유형" 객체를 다른 객체와 구분하는 간편한 메커니즘이 없다는 것입니다. 일부 후손은 typeof == "Object"를 반환하고 이는 원하는 바가 아닐 수 있습니다... 그리고 배열 같은 것들이 instanceof와 같은 것을 사용해야 할 수 있습니다.</p>
<p>목적을 달성하기 위해 Object.prototype에 이것을 적용하고 있어요.</p>
<pre><code class="hljs language-js">    __type : { get : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {

      <span class="hljs-keyword">let</span> value = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
        .<span class="hljs-property">toString</span>
        .<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>)
        .<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>, <span class="hljs-number">2</span>)
        [<span class="hljs-number">1</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);

      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">__define</span>(<span class="hljs-string">"__type"</span>, value);
      <span class="hljs-keyword">return</span> value;
    } } <span class="hljs-comment">// Object.prototype.__type</span>
</code></pre>
<p>toString 메서드에는 실제 Object 클래스 이름이 포함되어 있어서 대부분 Array에는 Array라고, Node에는 Node라고, 일반 객체에는 Object라고 등등 표시될 거에요. 문자열 처리면에서 해당 값을 가져오는 것이 약간 무겁지만, Object.__type을 두 번 이상 요청하면 루틴이 두 번 호출되는 대신 define이 반환되도록 타입을 재정의할 수 있어요.</p>
<p>그러나 "boolean"과 같은 소수의 Object에 대해 이것은 작동하지 않습니다. 이것은 명백히 Object인데도 Object.prototype에서 상속받지 않기 때문이에요. (프로토타입이 있는) Element 등 특정 하위 클래스를 알 필요가없는 다른 객체들이 있을 수 있어요. Element 인지 여부를 알고 싶은데 HTMLTableElement인지를 알아야 할 필요는 없는 것이죠.</p>
<p>따라서 미리 값의 값을 먼저 선언해야 합니다:</p>
<pre><code class="hljs language-js"> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> value <span class="hljs-keyword">of</span> [
   <span class="hljs-string">"Array"</span>, <span class="hljs-string">"Boolean"</span>, <span class="hljs-string">"Date"</span>, <span class="hljs-string">"Element"</span>,
   <span class="hljs-string">"Error"</span>, <span class="hljs-string">"Function"</span>, <span class="hljs-string">"Map"</span>, <span class="hljs-string">"Node"</span>,
   <span class="hljs-string">"Number"</span>, <span class="hljs-string">"RegExp"</span>, <span class="hljs-string">"Set"</span>, <span class="hljs-string">"String"</span>,
   <span class="hljs-string">"Symbol"</span>, <span class="hljs-string">"Text"</span>
 ]) <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(
   <span class="hljs-variable language_">window</span>[value].<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">"__type"</span>, { value }
 );
</code></pre>
<p>다행히도 모든 것이 window의 하위 요소이므로 window[value]를 사용하여 모든 이름을 배열에서 대상으로 할 수 있습니다. 매번 일일이 선언할 필요 없이 또는 [name, Object]와 같이 어리석고 무의미한 객체를 만들 필요가 없습니다.</p>
<p>자바스크립트를 잘 몰라도 되는 분들을 위해,  value는 <code>{</code> "value": value <code>}</code>와 기능적으로 동일합니다. 객체 선언에서 변수를 그냥 넣으면 변수의 이름이 속성의 이름이 됩니다.</p>
<p>지금은 우리가 __define 루틴을 만들 수 있게 했습니다.</p>
<pre><code class="hljs language-js">    __define : { value : <span class="hljs-keyword">function</span>(<span class="hljs-params">name, value</span>) {
      <span class="hljs-comment">/*
        Object.defineProperty를 통해 속성을 할당합니다.
        일반적인 Object가 전달되면 변경하지 않을 것이지만,
        타입 지정된 Object나 다른 값이 전달되면 새 속성의 값을
        할당할 Object로 이스케이프됩니다.
        
        전달된 객체대신 "this"를 반환하며, 내 의견으로는
        훨씬 더 유용한 값입니다.
      */</span>
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">this</span>, name,
        <span class="hljs-string">"Object"</span> == value.<span class="hljs-property">__type</span> ? value : { value }
      );
    } }, <span class="hljs-comment">// Object.prototype.__define</span>
</code></pre>
<p>그리고 여러 속성을 설정하기 위한 __defineProps도 있습니다.</p>
<pre><code class="hljs language-js">    __defineProps : { value : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> props <span class="hljs-keyword">of</span> <span class="hljs-variable language_">arguments</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [name, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(props)) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">__define</span>(name, value);
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
    } }, <span class="hljs-comment">// Object.prototype.__defineProps</span>
</code></pre>
<p>저는 이것이 단지 구문 설탕을 구현하는 것이라는 것을 알지만, 괜찮습니다.</p>
<p>그들이 "this"를 반환한다는 것에 주목하세요. 이는 정의나 속성을 쉽게 연결할 수 있게 해줍니다. 수정된 객체 대신 적용된 객체를 반환하는 것은 많은 내장 JS 함수의 어리석은 부분 중 하나이며, 사용자 정의 메서드로 "감싸는" 또 다른 좋은 이유입니다.</p>
<p>구문 설탕에 관해서 말씀드리면... 몇몇 흔히 사용되는 Object 메서드에 대한 별칭을 제공하고 있습니다. 많은 방법이 Object에 정적인 메서드인 것은, 조작된 객체를 전달해야 하는 번거로움을 초래합니다. JS의 대부분이 Object의 형식을 갖춘 객체임을 감안하면, 이것은 약간 어리석은 것처럼 보일 수 있습니다. "Object.entries(myObject)" 대신에 그냥 "myObject.entries"로 간단히 작성할 수 있어야 하는 부분에 대해 지금 까지 많이 타이핑하는 것이 싫어졌습니다.</p>
<pre><code class="hljs language-js">  <span class="hljs-comment">/*
    다음 속성들은 Object 클래스에서 혼란스럽게 정적입니다.
    이는 타입 캐스팅을 강제로 이용하는 데 편리하지만,
    이미 객체인 것을 알고 있을 때는 복잡하다고 생각할 수 있습니다!

    그래서 우리는 몇 가지 별칭을 만들어 보겠습니다.
  */</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">makeAliasWrapper</span> = (<span class="hljs-params">method, name</span>) => {
    <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">__define</span>(
      <span class="hljs-string">`__<span class="hljs-subst">${name}</span>`</span>,
      { [method] : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>[name](<span class="hljs-variable language_">this</span>, ...<span class="hljs-variable language_">arguments</span>)
      } }
    );
  }; <span class="hljs-comment">// makeAliasWrapper</span>
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [ method, names ] <span class="hljs-keyword">of</span> [
    [ <span class="hljs-string">"get"</span>,
      [ <span class="hljs-string">"entries"</span>, <span class="hljs-string">"isFrozen"</span>, <span class="hljs-string">"isSealed"</span>, <span class="hljs-string">"isExtensible"</span>, <span class="hljs-string">"keys"</span>, <span class="hljs-string">"values"</span> ]
    ],
    [ <span class="hljs-string">"value"</span>,
      [ <span class="hljs-string">"assign"</span>, <span class="hljs-string">"freeze"</span>, <span class="hljs-string">"hasOwn"</span>, <span class="hljs-string">"is"</span>, <span class="hljs-string">"seal"</span>, <span class="hljs-string">"preventExtensions"</span> ]
    ]
  ]) <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">of</span> names) <span class="hljs-title function_">makeAliasWrapper</span>(method, name);
</code></pre>
<p>저는 객체에 열거 가능한 키가 있는지 확인하는 "__empty" 게터도 만듭니다. 대부분의 경우, 이렇게 하는 이유는 제 기억력이 좋지 않아서 그런데요, "__empty"가 "Object.keys(target).length == 0" 또는 "!target.__keys.length"보다 기억하기 쉽거든요. 저의 별칭을 사용해서요.</p>
<pre><code class="hljs language-js">    __empty : { get : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
      <span class="hljs-comment">/*
        객체에 열거 가능한 키가 있는지 편리하게
        보고합니다.
      */</span>
      <span class="hljs-keyword">return</span> !<span class="hljs-variable language_">this</span>.<span class="hljs-property">__keys</span>.<span class="hljs-property">length</span>;
    } }, <span class="hljs-comment">// Object.prototype.__empty</span>
</code></pre>
<p>그리고 이것으로 좋은 베이스라인 "헬퍼" 라이브러리가 완성됩니다.</p>
<p>그리고, 네, 전 "arrow" 대신 전체 함수를 사용하고 있습니다. 이유는 실제로 뒤집는 객체인 "this"에 액세스해야 하기 때문이에요. "this"를 창으로 설정하는 화살표 함수는 정말 많은 시나리오에서 아무 쓸모가 없거든요.</p>
<h1>"첨부"와 "setAttr"</h1>
<p>실제로 make 루틴을 구현하기 전에, 자식 요소들과 속성 객체의 "attach"를 별도의 함수로 분리하고 싶어요. 여러 하위 루틴들을 구현하고 있기 때문에, 우리의 지역 범위에 있는 "attachData" 객체 내부에 룩업 테이블/객체를 만들고 있어요.</p>
<p>우선은 "sterile / void / empty" 요소들에 대한 오류 감지를 해야해요. 이러한 요소에 속성을 첨부할 수 있지만 자식 노드는 첨부할 수 없어요. 나는 한 걸음 더 나아가서 특정 속성으로 String/Number 콘텐츠를 추가하는 것을 허용해요. 그러므로 우리는 다음을 할 수 있을 거에요:</p>
<pre><code class="hljs language-js">[ <span class="hljs-string">"img=images/test.png"</span>, <span class="hljs-string">"Test Image"</span> ]
</code></pre>
<p>아래의 코드조각을 Markdown포맷으로 표현하면 다음과 같습니다:</p>
<pre><code class="hljs language-js">&#x3C;img src=<span class="hljs-string">"images/test.png"</span> alt=<span class="hljs-string">"Test Image"</span>>
</code></pre>
<p>나는 어떤 함수나 배열을 통한 속성 처리도 허용한다.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">canAttach</span>: {
    <span class="hljs-comment">/*
        null          첨부할 수 없음 (빈 태그)
        Boolean true  첨부할 수 있음 (기본값으로 기재되지 않은 경우)
        Array         인수 키에 할당할 값
        Function      콜백 함수(element, value)을 처리함
        String        this.setAttribute로 첨부
    */</span>
    area     : <span class="hljs-string">"alt"</span>,
    img      : <span class="hljs-string">"alt"</span>,
    meta     : <span class="hljs-string">"content"</span>,
    path     : <span class="hljs-string">"content"</span>,
    track    : <span class="hljs-string">"label"</span>,
    input    : <span class="hljs-string">"value"</span>,
    base     : <span class="hljs-literal">null</span>,
    br       : <span class="hljs-literal">null</span>,
    col      : <span class="hljs-literal">null</span>,
    embed    : <span class="hljs-literal">null</span>,
    hr       : <span class="hljs-literal">null</span>,
    link     : <span class="hljs-literal">null</span>,
    param    : <span class="hljs-literal">null</span>,
    source   : <span class="hljs-literal">null</span>,
    wbr      : <span class="hljs-literal">null</span>,
    <span class="hljs-comment">// 재밌는 목적으로 일부 SVG를 포함</span>
    polygon  : <span class="hljs-string">"points"</span>,
    polyline : <span class="hljs-string">"points"</span>,
    circle   : [ <span class="hljs-string">"cx"</span>, <span class="hljs-string">"cy"</span>, <span class="hljs-string">"r"</span> ],
    ellipse  : [ <span class="hljs-string">"cx"</span>, <span class="hljs-string">"cy"</span>, <span class="hljs-string">"rx"</span>, <span class="hljs-string">"ry"</span> ],
    line     : [ <span class="hljs-string">"x1"</span>, <span class="hljs-string">"y1"</span>, <span class="hljs-string">"x2"</span>, <span class="hljs-string">"y2"</span> ],
    path     : [ <span class="hljs-string">"x1"</span>, <span class="hljs-string">"y1"</span>, <span class="hljs-string">"x2"</span>, <span class="hljs-string">"y2"</span> ],
    rect     : [ <span class="hljs-string">"x"</span>, <span class="hljs-string">"y"</span>, <span class="hljs-string">"width"</span>, <span class="hljs-string">"height"</span> ]
}, <span class="hljs-comment">// attachData.canAttach</span>
</code></pre>
<p>그것은 우리에게 입력 값 설정하는 두 가지 방법을 제공한다는 걸 확인할 수 있어요. 다시 한번 말하지만, 저는 괜찮아요. 옵션은 좋은거죠.</p>
<p>canAttach의 유형은 각각 다른 루틴을 사용해요. 제가 선택한 방법은 switch/case보다는 Object 룩업을 사용하는 것이에요. 옵션 체이닝 덕분에 attach 루틴 자체를 크게 간소화할 거에요.</p>
<pre><code class="hljs language-js">    canType : {

      <span class="hljs-string">"Array"</span> : <span class="hljs-function">(<span class="hljs-params">target, arg, canAttach</span>) =></span> {
        
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"Array"</span> !== arg.<span class="hljs-property">__type</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
          <span class="hljs-string">`&#x3C;<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.tagName}</span>>.__attach는 배열을 비-속성 인수로만 첨부할 수 있어요. "<span class="hljs-subst">${arg.__type}</span> 대신에 입력했네요.`</span>
        );
        
        <span class="hljs-keyword">if</span> (arg.<span class="hljs-property">length</span> !== canAttach.<span class="hljs-property">length</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
          <span class="hljs-string">`&#x3C;<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.tagName}</span>>.__attach는 어떤 배열 인수에도 <span class="hljs-subst">${canAttach.length}</span>개의 값이 필요해요. "<span class="hljs-subst">${arg.length}</span> 대신 입력했네요.`</span>
        );
        
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">__fromKeyValuePairs</span>(canAttach, args));
        
      }, <span class="hljs-comment">// attachData.canType.Array</span>

      <span class="hljs-string">"String"</span> : <span class="hljs-function">(<span class="hljs-params">target, arg, canAttach</span>) =></span> {
        
          <span class="hljs-keyword">switch</span> (arg.<span class="hljs-property">__type</span>) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">"Number"</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">"String"</span>:
              target.<span class="hljs-title function_">setAttribute</span>(canAttach, arg);
              <span class="hljs-keyword">return</span>;
          }
          
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
            <span class="hljs-string">`&#x3C;<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.tagName}</span>>.__attach는 문자열 또는 숫자 비-속성 인수만 첨부할 수 있어요. "<span class="hljs-subst">${arg.__type}</span> 대신 입력했네요.`</span>
          );
          
      } <span class="hljs-comment">// attachData.canType.String</span>

    }, <span class="hljs-comment">// // attachData.canType</span>
</code></pre>
<p>여기에 "throw"를 많이 사용한 것을 주목하세요. 심각한 오류가 발생했을 때는 스크립팅이 멈춰야 한다고 확신을 갖고 있어요. 그 자리에서 멈춰야 해요. HTML과 JavaScript는 이를 처리하기 위한 완벽한 메커니즘을 제공하지만 여전히 너무 관대하다고 생각해요.</p>
<p>"argument"의 종류에 따라 특별한 처리 사례가 있을 수 있습니다.</p>
<pre><code class="hljs language-js">    argType : {

      <span class="hljs-string">"Array"</span> : <span class="hljs-function">(<span class="hljs-params">target, arg, canAttach</span>) =></span> target.<span class="hljs-title function_">__make</span>(...arg),

      <span class="hljs-string">"Function"</span> : <span class="hljs-function">(<span class="hljs-params">target, arg, canAttach</span>) =></span> target.<span class="hljs-title function_">append</span>(<span class="hljs-title function_">arg</span>(target))

    }, <span class="hljs-comment">// // attachData.argType</span>
</code></pre>
<p>그리고 위의 어떤 경우도 일치하지 않을 때의 대체 방안입니다.</p>
<pre><code class="hljs language-js">    append : <span class="hljs-function">(<span class="hljs-params">target, arg, canAttach</span>) =></span> target.<span class="hljs-title function_">append</span>(arg)
</code></pre>
<p>위 모든 것이 갖춰진 상태에서 Element.__defineProps를 Element.prototype.__attach 메서드에 적용할 수 있습니다.</p>
<pre><code class="hljs language-js"> <span class="hljs-title class_">Element</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">__defineProps</span>( {

    __attach : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {

      <span class="hljs-keyword">const</span> canAttach = attachData.<span class="hljs-property">canAttach</span>[
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tagName</span>.<span class="hljs-title function_">toLowerCase</span>()
      ] || <span class="hljs-literal">true</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> arg <span class="hljs-keyword">of</span> <span class="hljs-variable language_">arguments</span>) {

        <span class="hljs-keyword">if</span> (<span class="hljs-string">"Object"</span> === arg.<span class="hljs-property">__type</span>) <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">__setAttr</span>(arg);

        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (canAttach) (
          attachData.<span class="hljs-property">canType</span>[canAttach.<span class="hljs-property">__type</span>] ??
          attachData.<span class="hljs-property">argType</span>[arg.<span class="hljs-property">__type</span>] ??
          attachData.<span class="hljs-property">append</span>
        )(<span class="hljs-variable language_">this</span>, arg, canAttach);

        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
          <span class="hljs-string">`&#x3C;<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.tagName}</span>>은(는) 빈 Element이므로 해당 Element.prototype.__attach로 자식요소를 추가할 수 없습니다.`</span>
        );

      }

      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;

    }, <span class="hljs-comment">// Element.prototype.__attach</span>
</code></pre>
<p>Element의 tagName을 룩업했을 때 찾을 수 없다면 대부분의 태그는 첨부 파일을 가질 수 있으므로 true로 기본값으로 설정됩니다.</p>
<p>만약 순수한 객체라면, 속성을 설정하기 위해 해당 객체를 사용합니다. 만약 loose-true라면 널 병합 연산자를 사용하여 올바른 첨부 서브루틴을 선택합니다. 만약 아무것도 작동하지 않으면 자식 요소/데이터를 첨부할 수 없는 요소에서 예외를 발생시킵니다.</p>
<p>그리고 함수에 전달된 모든 인수를 처리하기 때문에 속성 및 자식 뿐만 아니라 make도 선언할 수 있습니다. 따라서 DOM-JON 항목의 배열이 있다면 attach에서 분해할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> test = [
  [ <span class="hljs-string">"h2"</span>, <span class="hljs-string">"테스트 제목"</span> ],
  [ <span class="hljs-string">"p"</span>, <span class="hljs-string">"간단한 테스트 단락"</span> ]
];

<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"testDIV"</span>).<span class="hljs-title function_">__attach</span>(...test);
</code></pre>
<p>이렇게 하면 실제 JSON 객체를 만들고 쉽게 첨부할 수 있습니다. 이제 HTML을 서버측에서 빌드하지 않고 JSON을 보내는 가능성을 생각해보세요.</p>
<p>이제 이렇게 생긴 "setAttr" 메소드를 호출합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">__setAttr</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">attr</span>) {
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(attr)) {
    
    <span class="hljs-keyword">switch</span> (key) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"__makePlace"</span>:
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">__define</span>(key, value);
        <span class="hljs-keyword">continue</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">"dataset"</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">"style"</span>:
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"Object"</span> !== value.<span class="hljs-property">__type</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(
          <span class="hljs-string">`&#x3C;<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.tagName}</span>>.__setAttr requires a Object when setting "<span class="hljs-subst">${key}</span>", got "<span class="hljs-subst">${value.__type}</span>" instead.`</span>
        );
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(<span class="hljs-variable language_">this</span>[key], value);
        <span class="hljs-keyword">continue</span>;
    }
    
    <span class="hljs-keyword">switch</span> (value.<span class="hljs-property">__type</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">"Array"</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">"Function"</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">"Object"</span>:
        <span class="hljs-variable language_">this</span>[key] = value;
        <span class="hljs-keyword">continue</span>;
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setAttribute</span>(key, value);
    
  }
  
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  
} <span class="hljs-comment">// Element.prototype.__setAttr</span>
</code></pre>
<p>"쉬운" <code>Object.assign</code> 대신 손수 속성 객체를 반복해서 순회하는 방법을 사용합니다. 이렇게 하면 정의를 후킹하고, 데이터셋과 스타일을 올바르게 처리할 수 있습니다. 대부분의 속성에는 <code>setAttribute</code>를 사용하는 것이 좋지만, 그것은 값들을 문자열로만 설정할 수 있습니다. 배열, 함수 및 객체 기능을 트랩할 수 있어서 이벤트 등을 설정할 수 있게 합니다.</p>
<p>참고로, DOM-JON에서는 className 대신 <code>{</code> "class": "myClassName" <code>}</code>를 사용해야 합니다. 여러분! className을 수동으로 "class"로 이름을 변경하여 두 가지 방법으로 사용할 수 있도록 할지 고민 중입니다. DSS "dot" 구분 기호를 사용하여 클래스를 설정하는 것이 시간을 들이는 가치가 있는 것일까요?</p>
<p>Element에 이 모든 것을 설정한 후에는 새로운 개선된 <code>__make</code>을 사용할 수 있게 됩니다. 이것을 모듈의 일부로 내보내거나 전역 범위에 넣는 것보다는, 저는 문서 객체에 이것을 넣을 것입니다!</p>
<pre><code class="hljs language-js">  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">__defineProps</span>( {

    __make : <span class="hljs-function">(<span class="hljs-params">selector, ...attach</span>) =></span> {

      <span class="hljs-keyword">let</span>
        parts = { attr : {}, data : {}, define : {} },
        value;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [ delimiter, typeName, attrName ] <span class="hljs-keyword">of</span> makeData.<span class="hljs-property">delimiters</span>) {
        [selector, value] = selector.<span class="hljs-title function_">split</span>(delimiter, <span class="hljs-number">2</span>);
        <span class="hljs-keyword">if</span> (value) parts[typeName][attrName] = value;
      }
      
      <span class="hljs-keyword">const</span>
        tagName = (selector || <span class="hljs-string">"span"</span>).<span class="hljs-title function_">toLowerCase</span>(),
        namespace = (
          parts.<span class="hljs-property">data</span>.<span class="hljs-property">namespace</span> ? (
            parts.<span class="hljs-property">data</span>.<span class="hljs-property">namespace</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">"http://"</span>) === <span class="hljs-number">0</span> ?
            parts.<span class="hljs-property">data</span>.<span class="hljs-property">namespace</span> :
            (
              makeData.<span class="hljs-property">namespaces</span>[parts.<span class="hljs-property">data</span>.<span class="hljs-property">namsspace</span>.<span class="hljs-title function_">toUpperCase</span>()] ?? 
              makeData.<span class="hljs-property">namespaces</span>.<span class="hljs-property">HTML</span>
            )
          ) : makeData.<span class="hljs-property">namespaces</span>.<span class="hljs-property">HTML</span>
        ),
        e = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(
          <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElementNS</span>(namespace, tagName),
          parts.<span class="hljs-property">attr</span>
        );
      
      <span class="hljs-keyword">if</span> (!parts.<span class="hljs-property">define</span>.<span class="hljs-property">__empty</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> parts.<span class="hljs-property">define</span>.<span class="hljs-property">__entries</span>) {
          e.<span class="hljs-title function_">__define</span>(key, value);
        }
      }

      <span class="hljs-keyword">if</span> (parts.<span class="hljs-property">data</span>.<span class="hljs-property">value</span>) e.<span class="hljs-title function_">setAttribute</span>(
        makeData.<span class="hljs-property">values</span>[tagName] ?? <span class="hljs-string">"value"</span>,
        parts.<span class="hljs-property">data</span>.<span class="hljs-property">value</span>
      );

      <span class="hljs-keyword">if</span> (parts.<span class="hljs-property">data</span>.<span class="hljs-property">special</span>) {
        <span class="hljs-keyword">const</span> attrName = makeData.<span class="hljs-property">special</span>[tagName];
        <span class="hljs-keyword">if</span> (attrName) e.<span class="hljs-title function_">setAttribute</span>(attrName, parts.<span class="hljs-property">data</span>.<span class="hljs-property">special</span>);
        <span class="hljs-keyword">else</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(
          <span class="hljs-string">`Special underscore property not supported on &#x3C;<span class="hljs-subst">${tagName}</span>>, ignoring value "<span class="hljs-subst">${parts.data.special}</span>"`</span>
        );
      }

      <span class="hljs-keyword">if</span> (attach) e.<span class="hljs-title function_">__attach</span>(...attach);

      <span class="hljs-keyword">return</span> e;

    } <span class="hljs-comment">// document.__make</span>

  } ); <span class="hljs-comment">// document extensions</span>
</code></pre>
<p>큰 변경 중 하나는 이제 "define"을 구분 기준으로 사용한다는 것입니다. 이를 새로운 구분자 조회에서 확인할 수 있습니다:</p>
<pre><code class="hljs language-js">    <span class="hljs-comment">/*
      DSS 구분자는 여기 나열된 순서의 역순으로 사용해야 합니다.
      여기 나열된 나중에 있는 문자는 이전 섹션 값들의 값 안에서 사용할 수 없습니다.
      
      예를 들어 ID 내에서 "."을 사용할 수 없습니다.
    */</span>
    delimiters : [
      [ <span class="hljs-string">"="</span>, <span class="hljs-string">"data"</span>,   <span class="hljs-string">"value"</span> ],
      [ <span class="hljs-string">"?"</span>, <span class="hljs-string">"attr"</span>,   <span class="hljs-string">"name"</span> ],
      [ <span class="hljs-string">"."</span>, <span class="hljs-string">"attr"</span>,   <span class="hljs-string">"className"</span> ],
      [ <span class="hljs-string">"#"</span>, <span class="hljs-string">"attr"</span>,   <span class="hljs-string">"id"</span> ],
      [ <span class="hljs-string">"&#x26;"</span>, <span class="hljs-string">"define"</span>, <span class="hljs-string">"__stateName"</span> ],
      [ <span class="hljs-string">"@"</span>, <span class="hljs-string">"define"</span>, <span class="hljs-string">"__makePlace"</span> ],
      [ <span class="hljs-string">":"</span>, <span class="hljs-string">"data"</span>,   <span class="hljs-string">"namespace"</span> ],
      [ <span class="hljs-string">"_"</span>, <span class="hljs-string">"data"</span>,   <span class="hljs-string">"special"</span> ]
    ], <span class="hljs-comment">// makeData.delimiters</span>
</code></pre>
<p>이를 통해 DOM 요소에 변경 불가능하고 열거되지 않는 정의를 만들 수 있어요. 다음 부분에 이르러 성능이 좋아지는데 유용할 것입니다: Element.prototype.__make</p>
<pre><code class="hljs language-js">    __make : <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
      
      <span class="hljs-keyword">const</span> e = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(...<span class="hljs-variable language_">arguments</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">insertAdjacentElement</span>(e.<span class="hljs-property">__makePlace</span> ?? <span class="hljs-string">"beforeend"</span>, e);
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
      
    }, <span class="hljs-comment">// Element.prototype.__make</span>
</code></pre>
<p>이 버전의 make 함수는 새 Element를 부모 요소와 관련하여 자동으로 첨부합니다. 다음과 같은 코드가 있다고 가정해봅시다:</p>
<pre><code class="hljs language-js">&#x3C;div id=<span class="hljs-string">"test"</span>>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>원본 콘텐츠<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>
&#x3C;/div>
</code></pre>
<p>이 기능을 한 번 시도해보세요 — __attach가 Element.prototype.__make를 호출하므로 둘 다 테스트됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"test"</span>).<span class="hljs-title function_">__attach</span>(
  [ <span class="hljs-string">"h2@afterbegin"</span>, <span class="hljs-string">"처음에 &#x3C;h2> 추가됨"</span> ],
  [ <span class="hljs-string">"h1@beforebegin"</span>, <span class="hljs-string">"앞에 &#x3C;h1> 추가됨"</span> ],
  [ <span class="hljs-string">"footer"</span>, <span class="hljs-comment">// beforeend는 기본값</span>
    [ <span class="hljs-string">"p"</span>, <span class="hljs-string">"마지막에 &#x3C;footer> 추가됨"</span> ]
  ],
  [ <span class="hljs-string">"p@afterend"</span>, <span class="hljs-string">"&#x3C;p> 뒤에 추가됨"</span> ]
);
</code></pre>
<p>여기 동작 중인 것이 있는 펜입니다:</p>
<p>전체 DOM-JON 코드베이스를 외부 {}에 넣어 scope isolation을 만들었음을 볼 수 있습니다. 오랜 시간 동안 JS의 let/const가 쓸모 없다고 생각했는데, 그것들을 사용하면 이전에 IIFE에 낭비했던 것들을 대체할 수 있다는 것을 깨달았습니다. 자주 캐시를 비운 첫 로드에서 클라이언트 사이드 파일 수를 나누는 모듈을 사용하지 않아도 됩니다. 이 방법을 사용하면 별도의 스크립트를 연결하여 배포 시 파일 수를 줄일 수 있습니다.</p>
<h1>새로운 Object 메소드 요약</h1>
<p>그래서 이제 DOM-JON을 다루는 방법에 대해 다음과 같은 메서드가 있습니다:</p>
<p><strong>method Element.prototype.__attach(...attachments)</strong>
attachment 유형에 따라 노드 또는 속성을 문서에 첨부합니다. 일반적인 객체는 노드 속성 및/또는 특별히 정의된 상태로 적용되며, 배열은 this.__make(Element.prototype__make)에 전달됩니다. 그 외의 경우는 추가됩니다.</p>
<p><strong>method document.__make(selector, ...attachments)</strong>
DSS를 적용하여 셀렉터로부터 Element를 생성한 다음 첨부를 Element.prototype.__attach에 전달합니다.</p>
<p><strong>method Element.prototype.__make(selector, ...attachments)</strong>
Document.__make를 호출하여 Element를 생성한 다음, 새 Element의 __makePlace 값에 따라 "this"에 추가되거나, 선언되지 않은 경우 기본값으로 "beforeend"에 추가됩니다.</p>
<p>method Element.prototype.__setAttr(obj)<br>
요소에 속성:값 쌍의 일반 객체를 할당합니다. 일부 속성은 __define으로 생성되도록 가로챕니다. 스타일 및 데이터세트와 같은 객체 하위 속성은 정규화되어 작동합니다. 함수, 배열 및 기타 객체는 this[key] = value로 할당되고, 다른 모든 값 유형은 this.setAttribute(key, value)로 할당됩니다.</p>
<p>또한 시스템 객체에 대한 많은 유용한 추가 기능들이 있습니다.</p>
<p>method Object.prototype.__define(name, value)<br>
Object.defineProperty와 유사하지만 일반 객체를 <code>{</code> value <code>}</code>로 할당하며 "this"를 반환하고 전달된 값이 아닙니다.</p>
<p>method Object.prototype.__defineProps(...props)<br>
__define이 defineProperty와 유사하다면, __defineProps는 defineProperties와 유사합니다. 가장 큰 차이점은 여러 다른 이름/속성 쌍의 객체를 수락할 수 있으며 첫 번째 전달된 인수 대신 "this"를 반환한다는 것입니다.</p>
<p>정적 메서드 Object.__defineMulti(targets, ...props)
여러 대상에 속성을 할당합니다. 대상은 키 배열이어야하며, 그 다음 ...props의 각 객체와 일치해야합니다.</p>
<p>정적 메서드 Object.__fromKeyValueArrays(keys, values)
두 배열에서 객체를 생성합니다.</p>
<p>getter 및/또는 propertyObject.prototype.__type
단일 "유형"을 반환합니다. 마치 통일된 "typeof" 및 "instanceof"처럼 다루기가 훨씬 덜 복잡한 것처럼. 대부분의 객체에 대해 이것은 처음 호출시 getter이지만 절대 수정할 수없는 열거 불가 속성으로 재정의됩니다. 일부 일반 객체 유형도 해당 속성으로 시작됩니다.</p>
<p>이것이 "공개적으로 보이는" 속성과 메서드입니다. 전역 변수나 전역 함수가 필요하지 않습니다.</p>
<p>그게 이번에는 그게 다야. 13,000 줄의 코드가 있지만 gzip으로 압축하면 겨우 4,400 줄만 남아. 압축 후 최소화하면 3,000 줄도 안 될 것 같아.</p>
<p>이 알파 빌드를 여기서 다운로드할 수 있어:
<a href="https://cutcodedown.com/for_others/domjon/domjon.alpha4.js" rel="nofollow" target="_blank">https://cutcodedown.com/for_others/domjon/domjon.alpha4.js</a></p>
<p>다음에는 "__make"로 구축된 DOM 구조에 직접 연결할 수 있는 getter 및 setter를 생성하는 "State" 객체를 추가할 거야. 이는 "listeners"가 작동하는 방식과 유사하다.</p>
<h1>기사 목차</h1>
<h1>파트 1 : 기본 개념</h1>
<h1>파트 2 : 시스템 객체 확장 (현재 위치)</h1>
<h1>파트 3 : 상태</h1>
<h1>파트 4 : 템플릿 및 모듈 (곧 제공 예정)</h1>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"시스템 객체 확장으로 자바스크립트 DOM 빌더를 개선하는 방법","description":"","date":"2024-05-01 23:02","slug":"2024-05-01-BuildingABetterJavaScriptDOMBuilderPart2ExtendingSystemObjects","content":"\n\n\u003cimg src=\"/assets/img/2024-05-01-BuildingABetterJavaScriptDOMBuilderPart2ExtendingSystemObjects_0.png\" /\u003e\n\n첫 번째 부분에서는 DOM-JON 개념을 소개했습니다. HTML을 JSON 스타일의 네임스페이스로 재구성하고, 이를 DOM에 직접 번역하는 과정을 간단하게 소개하며, InnerHTML을 통해 작업하는 대신에 바로 DOM으로 이동하는 이유를 다뤘습니다.\n\n간단한 사이드 노트, 이 기사의 목적은 여러분에게 이것을 사용하는 방법을 가르치는 것이 아니라, 제가 이를 구축하는 과정에서의 사고 과정을 공유하는 것입니다. 실시간으로 말이에요. 피드백을 받기 위해 내 머릿속에 정리하기 위해 글로 써내리기도! 문서화 및 전체 웹사이트는 나중에 제작될 예정입니다.\n\n이번에는 기존 엘리먼트에 여러 노드를 쉽게 적용할 수 있도록하고, 이전 \"make\" 루틴의 \"attach\" 부분에 대한 액세스를 독립적으로 제공하고, 속성 처리를 더 견고하게 만들고자 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n'원인은 몇 가지 부족한 것이 있기 때문이죠. Element.style 나 Element.dataset과 같은 속성은 Object.assign을 통해 요소에 적용할 수 없습니다. 속성에 직접 적용해야 합니다. 또한 DOM-JON 구조의 \"속성 객체\"를 사용하여 요소를 \"배치\"하는 방법과 같은 다른 정보를 전달할 수 있다면 좋겠어요.\n\n이 부분을 간단히 하는 가장 좋은 방법은 무엇일까요?\n\n# 시스템 객체 확장\n\n기본적으로, 저는 기존 Document, Object, Node 및 Element 객체에 내 방법을 추가할 것입니다. 부모 클래스에 대한 정적 값 및 프로토타입에 대해서도 추가할 겁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이 일에 대해 너무 많은 공포가 있어요. 마치 JavaScript의 강력하고 다용도 객체 모델을 수정하면 안 된다는 것처럼 말이죠. \"결코 하지 말아야 한다!\" 라고 하는 분들은 충분한 이유 없이 말하는 경우가 많아요. 하지만 합당한 우려가 세 가지 있습니다.\n\n- IE 7 / 이전 버전은 기존 객체에 프로토 타입 변경을 상속하지 않습니다.\n- 우리 자신의 함수와 언어의 미래 변경 사이에 이름 충돌의 문을 열어둡니다.\n- 변경할 수 있는 객체를 실수로 덮어쓰고, 이들을 열거할 수 있을 경우에 덮어쓸 수 있습니다.\n\n그 첫 번째 우려는 어질어질해요! 이제는 2024년이에요. 우리는 전혀 구식이 아닌 JavaScript를 쓰고 있어요. nullish coalescing, for..of, IE 어떤 버전에서도 작동하지 않는 spread / rest 연산자 등을 사용하고 있어요. 심지어 \"화살표 함수\"가 있으면 익스플로러의 JSCRIPT 엔진이 즉시 다운될 정도에요.\n\n두 번째로, 이 문제는 네이밍 규칙을 사용하여 쉽게 해결할 수 있어요. 이런 경우에는 lodash의 방식을 가져와서 모든 사용자 지정 메서드와 속성의 시작에 이중 밑줄을 사용할 거에요. 누군가가 비슷한 기교를 사용하지 않는 한 문제없을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저 세 번째 코드는 대부분 사람들이 바보같은 일을 하는 경우에 발생한 것이에요:\n\n```js\nElement.prototype.__make = function(tagName, ...attach) {}\n```\n\n해야 할 것은 다음과 같아요:\n\n```js\nObject.defineProperty(\n  Element.prototype,\n  \"__make\",\n  { value : function(tagName, ...attach) {} }\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nObject.definePropert[ies | y]는 우리의 친구입니다... 그리고 JavaScript의 가장 안타깝게도 under-used한 부분 중 하나입니다. 전체 새 클래스를 만들지 않고 기존 Object에 추가하는 능력은 엄청 유용합니다. 시스템 객체가 이미 존재하기 때문에 전역 네임스페이스에 추가하는 것처럼 보이지 않습니다. 기본적으로 이러한 메서드에 의해 추가된 객체 속성 - 네, 속성, \"속성\"이 아니라. 그렇습니다, 심지어 DOM에 있는 경우도! - 객체에 대해 열거할 수 없게 만듭니다. 시스템 메서드만큼 \"숨겨진\" 것입니다. 현대 클래스에서 #을 접두사로 붙일 때와 같습니다. 필요할 경우에는 열거 가능하게 만들기 위해 인수 객체에 enumerable:true를 추가할 수도 있습니다.\n\n# Object.definepropert[ies|y] 개선하기\n\n이 함수들을 좋아하지만, 문법에는 약간 번잡한 부분이 있어 불필요하게 장황하게 느끼게 할 수 있습니다. 이전 기사에서처럼 \"타입\"을 가로채서 요소의 \"타입\"을 확인하여 일반 객체를 전달하면 defineProperty과 같이 동작하지만, 다른 값 유형은 자동으로 가장 일반적으로 사용하는 기술인 객체 `{` value `}`에 래핑하게 할 수 있습니다.\n\n이를 돕기 위해 - 특히 일반 Object를 후손으로부터 격리하기 위해 - 나만의 Object.__type 루틴을 추가합니다. JavaScript에서 가장 큰 고통 중 하나는 범용 \"데이터 유형\" 객체를 다른 객체와 구분하는 간편한 메커니즘이 없다는 것입니다. 일부 후손은 typeof == \"Object\"를 반환하고 이는 원하는 바가 아닐 수 있습니다... 그리고 배열 같은 것들이 instanceof와 같은 것을 사용해야 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n목적을 달성하기 위해 Object.prototype에 이것을 적용하고 있어요.\n\n```js\n    __type : { get : function() {\n\n      let value = Object.prototype\n        .toString\n        .call(this)\n        .split(\" \", 2)\n        [1].slice(0, -1);\n\n      this.__define(\"__type\", value);\n      return value;\n    } } // Object.prototype.__type\n```\n\ntoString 메서드에는 실제 Object 클래스 이름이 포함되어 있어서 대부분 Array에는 Array라고, Node에는 Node라고, 일반 객체에는 Object라고 등등 표시될 거에요. 문자열 처리면에서 해당 값을 가져오는 것이 약간 무겁지만, Object.__type을 두 번 이상 요청하면 루틴이 두 번 호출되는 대신 define이 반환되도록 타입을 재정의할 수 있어요.\n\n그러나 \"boolean\"과 같은 소수의 Object에 대해 이것은 작동하지 않습니다. 이것은 명백히 Object인데도 Object.prototype에서 상속받지 않기 때문이에요. (프로토타입이 있는) Element 등 특정 하위 클래스를 알 필요가없는 다른 객체들이 있을 수 있어요. Element 인지 여부를 알고 싶은데 HTMLTableElement인지를 알아야 할 필요는 없는 것이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n따라서 미리 값의 값을 먼저 선언해야 합니다:\n\n```js\n for (let value of [\n   \"Array\", \"Boolean\", \"Date\", \"Element\",\n   \"Error\", \"Function\", \"Map\", \"Node\",\n   \"Number\", \"RegExp\", \"Set\", \"String\",\n   \"Symbol\", \"Text\"\n ]) Object.defineProperty(\n   window[value].prototype, \"__type\", { value }\n );\n```\n\n다행히도 모든 것이 window의 하위 요소이므로 window[value]를 사용하여 모든 이름을 배열에서 대상으로 할 수 있습니다. 매번 일일이 선언할 필요 없이 또는 [name, Object]와 같이 어리석고 무의미한 객체를 만들 필요가 없습니다.\n\n자바스크립트를 잘 몰라도 되는 분들을 위해,  value는 `{` \"value\": value `}`와 기능적으로 동일합니다. 객체 선언에서 변수를 그냥 넣으면 변수의 이름이 속성의 이름이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 우리가 __define 루틴을 만들 수 있게 했습니다.\n\n```js\n    __define : { value : function(name, value) {\n      /*\n        Object.defineProperty를 통해 속성을 할당합니다.\n        일반적인 Object가 전달되면 변경하지 않을 것이지만,\n        타입 지정된 Object나 다른 값이 전달되면 새 속성의 값을\n        할당할 Object로 이스케이프됩니다.\n        \n        전달된 객체대신 \"this\"를 반환하며, 내 의견으로는\n        훨씬 더 유용한 값입니다.\n      */\n      return Object.defineProperty(this, name,\n        \"Object\" == value.__type ? value : { value }\n      );\n    } }, // Object.prototype.__define\n```\n\n그리고 여러 속성을 설정하기 위한 __defineProps도 있습니다.\n\n```js\n    __defineProps : { value : function() {\n      for (const props of arguments) {\n        for (const [name, value] of Object.entries(props)) {\n          this.__define(name, value);\n        }\n      }\n      return this;\n    } }, // Object.prototype.__defineProps\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 이것이 단지 구문 설탕을 구현하는 것이라는 것을 알지만, 괜찮습니다.\n\n그들이 \"this\"를 반환한다는 것에 주목하세요. 이는 정의나 속성을 쉽게 연결할 수 있게 해줍니다. 수정된 객체 대신 적용된 객체를 반환하는 것은 많은 내장 JS 함수의 어리석은 부분 중 하나이며, 사용자 정의 메서드로 \"감싸는\" 또 다른 좋은 이유입니다.\n\n구문 설탕에 관해서 말씀드리면... 몇몇 흔히 사용되는 Object 메서드에 대한 별칭을 제공하고 있습니다. 많은 방법이 Object에 정적인 메서드인 것은, 조작된 객체를 전달해야 하는 번거로움을 초래합니다. JS의 대부분이 Object의 형식을 갖춘 객체임을 감안하면, 이것은 약간 어리석은 것처럼 보일 수 있습니다. \"Object.entries(myObject)\" 대신에 그냥 \"myObject.entries\"로 간단히 작성할 수 있어야 하는 부분에 대해 지금 까지 많이 타이핑하는 것이 싫어졌습니다.\n\n```js\n  /*\n    다음 속성들은 Object 클래스에서 혼란스럽게 정적입니다.\n    이는 타입 캐스팅을 강제로 이용하는 데 편리하지만,\n    이미 객체인 것을 알고 있을 때는 복잡하다고 생각할 수 있습니다!\n\n    그래서 우리는 몇 가지 별칭을 만들어 보겠습니다.\n  */\n  const makeAliasWrapper = (method, name) =\u003e {\n    Object.prototype.__define(\n      `__${name}`,\n      { [method] : function() {\n        return Object[name](this, ...arguments)\n      } }\n    );\n  }; // makeAliasWrapper\n  \n  for (const [ method, names ] of [\n    [ \"get\",\n      [ \"entries\", \"isFrozen\", \"isSealed\", \"isExtensible\", \"keys\", \"values\" ]\n    ],\n    [ \"value\",\n      [ \"assign\", \"freeze\", \"hasOwn\", \"is\", \"seal\", \"preventExtensions\" ]\n    ]\n  ]) for (name of names) makeAliasWrapper(method, name);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 객체에 열거 가능한 키가 있는지 확인하는 \"__empty\" 게터도 만듭니다. 대부분의 경우, 이렇게 하는 이유는 제 기억력이 좋지 않아서 그런데요, \"__empty\"가 \"Object.keys(target).length == 0\" 또는 \"!target.__keys.length\"보다 기억하기 쉽거든요. 저의 별칭을 사용해서요.\n\n```js\n    __empty : { get : function() {\n      /*\n        객체에 열거 가능한 키가 있는지 편리하게\n        보고합니다.\n      */\n      return !this.__keys.length;\n    } }, // Object.prototype.__empty\n```\n\n그리고 이것으로 좋은 베이스라인 \"헬퍼\" 라이브러리가 완성됩니다.\n\n그리고, 네, 전 \"arrow\" 대신 전체 함수를 사용하고 있습니다. 이유는 실제로 뒤집는 객체인 \"this\"에 액세스해야 하기 때문이에요. \"this\"를 창으로 설정하는 화살표 함수는 정말 많은 시나리오에서 아무 쓸모가 없거든요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# \"첨부\"와 \"setAttr\"\n\n실제로 make 루틴을 구현하기 전에, 자식 요소들과 속성 객체의 \"attach\"를 별도의 함수로 분리하고 싶어요. 여러 하위 루틴들을 구현하고 있기 때문에, 우리의 지역 범위에 있는 \"attachData\" 객체 내부에 룩업 테이블/객체를 만들고 있어요.\n\n우선은 \"sterile / void / empty\" 요소들에 대한 오류 감지를 해야해요. 이러한 요소에 속성을 첨부할 수 있지만 자식 노드는 첨부할 수 없어요. 나는 한 걸음 더 나아가서 특정 속성으로 String/Number 콘텐츠를 추가하는 것을 허용해요. 그러므로 우리는 다음을 할 수 있을 거에요:\n\n```js\n[ \"img=images/test.png\", \"Test Image\" ]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 코드조각을 Markdown포맷으로 표현하면 다음과 같습니다:\n\n```js\n\u003cimg src=\"images/test.png\" alt=\"Test Image\"\u003e\n```\n\n나는 어떤 함수나 배열을 통한 속성 처리도 허용한다.\n\n```js\ncanAttach: {\n    /*\n        null          첨부할 수 없음 (빈 태그)\n        Boolean true  첨부할 수 있음 (기본값으로 기재되지 않은 경우)\n        Array         인수 키에 할당할 값\n        Function      콜백 함수(element, value)을 처리함\n        String        this.setAttribute로 첨부\n    */\n    area     : \"alt\",\n    img      : \"alt\",\n    meta     : \"content\",\n    path     : \"content\",\n    track    : \"label\",\n    input    : \"value\",\n    base     : null,\n    br       : null,\n    col      : null,\n    embed    : null,\n    hr       : null,\n    link     : null,\n    param    : null,\n    source   : null,\n    wbr      : null,\n    // 재밌는 목적으로 일부 SVG를 포함\n    polygon  : \"points\",\n    polyline : \"points\",\n    circle   : [ \"cx\", \"cy\", \"r\" ],\n    ellipse  : [ \"cx\", \"cy\", \"rx\", \"ry\" ],\n    line     : [ \"x1\", \"y1\", \"x2\", \"y2\" ],\n    path     : [ \"x1\", \"y1\", \"x2\", \"y2\" ],\n    rect     : [ \"x\", \"y\", \"width\", \"height\" ]\n}, // attachData.canAttach\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것은 우리에게 입력 값 설정하는 두 가지 방법을 제공한다는 걸 확인할 수 있어요. 다시 한번 말하지만, 저는 괜찮아요. 옵션은 좋은거죠.\n\ncanAttach의 유형은 각각 다른 루틴을 사용해요. 제가 선택한 방법은 switch/case보다는 Object 룩업을 사용하는 것이에요. 옵션 체이닝 덕분에 attach 루틴 자체를 크게 간소화할 거에요.\n\n```js\n    canType : {\n\n      \"Array\" : (target, arg, canAttach) =\u003e {\n        \n        if (\"Array\" !== arg.__type) throw new Error(\n          `\u003c${this.tagName}\u003e.__attach는 배열을 비-속성 인수로만 첨부할 수 있어요. \"${arg.__type} 대신에 입력했네요.`\n        );\n        \n        if (arg.length !== canAttach.length) throw new Error(\n          `\u003c${this.tagName}\u003e.__attach는 어떤 배열 인수에도 ${canAttach.length}개의 값이 필요해요. \"${arg.length} 대신 입력했네요.`\n        );\n        \n        Object.assign(this, Object.__fromKeyValuePairs(canAttach, args));\n        \n      }, // attachData.canType.Array\n\n      \"String\" : (target, arg, canAttach) =\u003e {\n        \n          switch (arg.__type) {\n            case \"Number\":\n            case \"String\":\n              target.setAttribute(canAttach, arg);\n              return;\n          }\n          \n          throw new Error(\n            `\u003c${this.tagName}\u003e.__attach는 문자열 또는 숫자 비-속성 인수만 첨부할 수 있어요. \"${arg.__type} 대신 입력했네요.`\n          );\n          \n      } // attachData.canType.String\n\n    }, // // attachData.canType\n```\n\n여기에 \"throw\"를 많이 사용한 것을 주목하세요. 심각한 오류가 발생했을 때는 스크립팅이 멈춰야 한다고 확신을 갖고 있어요. 그 자리에서 멈춰야 해요. HTML과 JavaScript는 이를 처리하기 위한 완벽한 메커니즘을 제공하지만 여전히 너무 관대하다고 생각해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"argument\"의 종류에 따라 특별한 처리 사례가 있을 수 있습니다.\n\n```js\n    argType : {\n\n      \"Array\" : (target, arg, canAttach) =\u003e target.__make(...arg),\n\n      \"Function\" : (target, arg, canAttach) =\u003e target.append(arg(target))\n\n    }, // // attachData.argType\n```\n\n그리고 위의 어떤 경우도 일치하지 않을 때의 대체 방안입니다.\n\n```js\n    append : (target, arg, canAttach) =\u003e target.append(arg)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 모든 것이 갖춰진 상태에서 Element.__defineProps를 Element.prototype.__attach 메서드에 적용할 수 있습니다.\n\n```js\n Element.prototype.__defineProps( {\n\n    __attach : function() {\n\n      const canAttach = attachData.canAttach[\n        this.tagName.toLowerCase()\n      ] || true;\n\n      for (const arg of arguments) {\n\n        if (\"Object\" === arg.__type) this.__setAttr(arg);\n\n        else if (canAttach) (\n          attachData.canType[canAttach.__type] ??\n          attachData.argType[arg.__type] ??\n          attachData.append\n        )(this, arg, canAttach);\n\n        else throw new Error(\n          `\u003c${this.tagName}\u003e은(는) 빈 Element이므로 해당 Element.prototype.__attach로 자식요소를 추가할 수 없습니다.`\n        );\n\n      }\n\n      return this;\n\n    }, // Element.prototype.__attach\n```\n\nElement의 tagName을 룩업했을 때 찾을 수 없다면 대부분의 태그는 첨부 파일을 가질 수 있으므로 true로 기본값으로 설정됩니다.\n\n만약 순수한 객체라면, 속성을 설정하기 위해 해당 객체를 사용합니다. 만약 loose-true라면 널 병합 연산자를 사용하여 올바른 첨부 서브루틴을 선택합니다. 만약 아무것도 작동하지 않으면 자식 요소/데이터를 첨부할 수 없는 요소에서 예외를 발생시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 함수에 전달된 모든 인수를 처리하기 때문에 속성 및 자식 뿐만 아니라 make도 선언할 수 있습니다. 따라서 DOM-JON 항목의 배열이 있다면 attach에서 분해할 수 있습니다.\n\n```js\nconst test = [\n  [ \"h2\", \"테스트 제목\" ],\n  [ \"p\", \"간단한 테스트 단락\" ]\n];\n\ndocument.getElementById(\"testDIV\").__attach(...test);\n```\n\n이렇게 하면 실제 JSON 객체를 만들고 쉽게 첨부할 수 있습니다. 이제 HTML을 서버측에서 빌드하지 않고 JSON을 보내는 가능성을 생각해보세요.\n\n이제 이렇게 생긴 \"setAttr\" 메소드를 호출합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n__setAttr: function (attr) {\n  \n  for (const [key, value] of Object.entries(attr)) {\n    \n    switch (key) {\n      case \"__makePlace\":\n        this.__define(key, value);\n        continue;\n      case \"dataset\":\n      case \"style\":\n        if (\"Object\" !== value.__type) throw new Error(\n          `\u003c${this.tagName}\u003e.__setAttr requires a Object when setting \"${key}\", got \"${value.__type}\" instead.`\n        );\n        Object.assign(this[key], value);\n        continue;\n    }\n    \n    switch (value.__type) {\n      case \"Array\":\n      case \"Function\":\n      case \"Object\":\n        this[key] = value;\n        continue;\n    }\n    \n    this.setAttribute(key, value);\n    \n  }\n  \n  return this;\n  \n} // Element.prototype.__setAttr\n```\n\n\"쉬운\" `Object.assign` 대신 손수 속성 객체를 반복해서 순회하는 방법을 사용합니다. 이렇게 하면 정의를 후킹하고, 데이터셋과 스타일을 올바르게 처리할 수 있습니다. 대부분의 속성에는 `setAttribute`를 사용하는 것이 좋지만, 그것은 값들을 문자열로만 설정할 수 있습니다. 배열, 함수 및 객체 기능을 트랩할 수 있어서 이벤트 등을 설정할 수 있게 합니다.\n\n참고로, DOM-JON에서는 className 대신 `{` \"class\": \"myClassName\" `}`를 사용해야 합니다. 여러분! className을 수동으로 \"class\"로 이름을 변경하여 두 가지 방법으로 사용할 수 있도록 할지 고민 중입니다. DSS \"dot\" 구분 기호를 사용하여 클래스를 설정하는 것이 시간을 들이는 가치가 있는 것일까요?\n\nElement에 이 모든 것을 설정한 후에는 새로운 개선된 `__make`을 사용할 수 있게 됩니다. 이것을 모듈의 일부로 내보내거나 전역 범위에 넣는 것보다는, 저는 문서 객체에 이것을 넣을 것입니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n  document.__defineProps( {\n\n    __make : (selector, ...attach) =\u003e {\n\n      let\n        parts = { attr : {}, data : {}, define : {} },\n        value;\n\n      for (const [ delimiter, typeName, attrName ] of makeData.delimiters) {\n        [selector, value] = selector.split(delimiter, 2);\n        if (value) parts[typeName][attrName] = value;\n      }\n      \n      const\n        tagName = (selector || \"span\").toLowerCase(),\n        namespace = (\n          parts.data.namespace ? (\n            parts.data.namespace.indexOf(\"http://\") === 0 ?\n            parts.data.namespace :\n            (\n              makeData.namespaces[parts.data.namsspace.toUpperCase()] ?? \n              makeData.namespaces.HTML\n            )\n          ) : makeData.namespaces.HTML\n        ),\n        e = Object.assign(\n          document.createElementNS(namespace, tagName),\n          parts.attr\n        );\n      \n      if (!parts.define.__empty) {\n        for (const [key, value] of parts.define.__entries) {\n          e.__define(key, value);\n        }\n      }\n\n      if (parts.data.value) e.setAttribute(\n        makeData.values[tagName] ?? \"value\",\n        parts.data.value\n      );\n\n      if (parts.data.special) {\n        const attrName = makeData.special[tagName];\n        if (attrName) e.setAttribute(attrName, parts.data.special);\n        else console.warn(\n          `Special underscore property not supported on \u003c${tagName}\u003e, ignoring value \"${parts.data.special}\"`\n        );\n      }\n\n      if (attach) e.__attach(...attach);\n\n      return e;\n\n    } // document.__make\n\n  } ); // document extensions\n```\n\n큰 변경 중 하나는 이제 \"define\"을 구분 기준으로 사용한다는 것입니다. 이를 새로운 구분자 조회에서 확인할 수 있습니다:\n\n```js\n    /*\n      DSS 구분자는 여기 나열된 순서의 역순으로 사용해야 합니다.\n      여기 나열된 나중에 있는 문자는 이전 섹션 값들의 값 안에서 사용할 수 없습니다.\n      \n      예를 들어 ID 내에서 \".\"을 사용할 수 없습니다.\n    */\n    delimiters : [\n      [ \"=\", \"data\",   \"value\" ],\n      [ \"?\", \"attr\",   \"name\" ],\n      [ \".\", \"attr\",   \"className\" ],\n      [ \"#\", \"attr\",   \"id\" ],\n      [ \"\u0026\", \"define\", \"__stateName\" ],\n      [ \"@\", \"define\", \"__makePlace\" ],\n      [ \":\", \"data\",   \"namespace\" ],\n      [ \"_\", \"data\",   \"special\" ]\n    ], // makeData.delimiters\n```\n\n이를 통해 DOM 요소에 변경 불가능하고 열거되지 않는 정의를 만들 수 있어요. 다음 부분에 이르러 성능이 좋아지는데 유용할 것입니다: Element.prototype.__make\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n    __make : function() {\n      \n      const e = document.createElement(...arguments);\n      this.insertAdjacentElement(e.__makePlace ?? \"beforeend\", e);\n      return this;\n      \n    }, // Element.prototype.__make\n```\n\n이 버전의 make 함수는 새 Element를 부모 요소와 관련하여 자동으로 첨부합니다. 다음과 같은 코드가 있다고 가정해봅시다:\n\n```js\n\u003cdiv id=\"test\"\u003e\n  \u003cp\u003e원본 콘텐츠\u003c/p\u003e\n\u003c/div\u003e\n```\n\n이 기능을 한 번 시도해보세요 — __attach가 Element.prototype.__make를 호출하므로 둘 다 테스트됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndocument.getElementById(\"test\").__attach(\n  [ \"h2@afterbegin\", \"처음에 \u003ch2\u003e 추가됨\" ],\n  [ \"h1@beforebegin\", \"앞에 \u003ch1\u003e 추가됨\" ],\n  [ \"footer\", // beforeend는 기본값\n    [ \"p\", \"마지막에 \u003cfooter\u003e 추가됨\" ]\n  ],\n  [ \"p@afterend\", \"\u003cp\u003e 뒤에 추가됨\" ]\n);\n```\n\n여기 동작 중인 것이 있는 펜입니다:\n\n전체 DOM-JON 코드베이스를 외부 {}에 넣어 scope isolation을 만들었음을 볼 수 있습니다. 오랜 시간 동안 JS의 let/const가 쓸모 없다고 생각했는데, 그것들을 사용하면 이전에 IIFE에 낭비했던 것들을 대체할 수 있다는 것을 깨달았습니다. 자주 캐시를 비운 첫 로드에서 클라이언트 사이드 파일 수를 나누는 모듈을 사용하지 않아도 됩니다. 이 방법을 사용하면 별도의 스크립트를 연결하여 배포 시 파일 수를 줄일 수 있습니다.\n\n# 새로운 Object 메소드 요약\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 이제 DOM-JON을 다루는 방법에 대해 다음과 같은 메서드가 있습니다:\n\n**method Element.prototype.__attach(...attachments)**\nattachment 유형에 따라 노드 또는 속성을 문서에 첨부합니다. 일반적인 객체는 노드 속성 및/또는 특별히 정의된 상태로 적용되며, 배열은 this.__make(Element.prototype__make)에 전달됩니다. 그 외의 경우는 추가됩니다.\n\n**method document.__make(selector, ...attachments)**\nDSS를 적용하여 셀렉터로부터 Element를 생성한 다음 첨부를 Element.prototype.__attach에 전달합니다.\n\n**method Element.prototype.__make(selector, ...attachments)**\nDocument.__make를 호출하여 Element를 생성한 다음, 새 Element의 __makePlace 값에 따라 \"this\"에 추가되거나, 선언되지 않은 경우 기본값으로 \"beforeend\"에 추가됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nmethod Element.prototype.__setAttr(obj)  \n요소에 속성:값 쌍의 일반 객체를 할당합니다. 일부 속성은 __define으로 생성되도록 가로챕니다. 스타일 및 데이터세트와 같은 객체 하위 속성은 정규화되어 작동합니다. 함수, 배열 및 기타 객체는 this[key] = value로 할당되고, 다른 모든 값 유형은 this.setAttribute(key, value)로 할당됩니다.\n\n또한 시스템 객체에 대한 많은 유용한 추가 기능들이 있습니다.\n\nmethod Object.prototype.__define(name, value)  \nObject.defineProperty와 유사하지만 일반 객체를 `{` value `}`로 할당하며 \"this\"를 반환하고 전달된 값이 아닙니다.\n\nmethod Object.prototype.__defineProps(...props)  \n__define이 defineProperty와 유사하다면, __defineProps는 defineProperties와 유사합니다. 가장 큰 차이점은 여러 다른 이름/속성 쌍의 객체를 수락할 수 있으며 첫 번째 전달된 인수 대신 \"this\"를 반환한다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n정적 메서드 Object.__defineMulti(targets, ...props)\n여러 대상에 속성을 할당합니다. 대상은 키 배열이어야하며, 그 다음 ...props의 각 객체와 일치해야합니다.\n\n정적 메서드 Object.__fromKeyValueArrays(keys, values)\n두 배열에서 객체를 생성합니다.\n\ngetter 및/또는 propertyObject.prototype.__type\n단일 \"유형\"을 반환합니다. 마치 통일된 \"typeof\" 및 \"instanceof\"처럼 다루기가 훨씬 덜 복잡한 것처럼. 대부분의 객체에 대해 이것은 처음 호출시 getter이지만 절대 수정할 수없는 열거 불가 속성으로 재정의됩니다. 일부 일반 객체 유형도 해당 속성으로 시작됩니다.\n\n이것이 \"공개적으로 보이는\" 속성과 메서드입니다. 전역 변수나 전역 함수가 필요하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그게 이번에는 그게 다야. 13,000 줄의 코드가 있지만 gzip으로 압축하면 겨우 4,400 줄만 남아. 압축 후 최소화하면 3,000 줄도 안 될 것 같아.\n\n이 알파 빌드를 여기서 다운로드할 수 있어:\nhttps://cutcodedown.com/for_others/domjon/domjon.alpha4.js\n\n다음에는 \"__make\"로 구축된 DOM 구조에 직접 연결할 수 있는 getter 및 setter를 생성하는 \"State\" 객체를 추가할 거야. 이는 \"listeners\"가 작동하는 방식과 유사하다.\n\n# 기사 목차\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 파트 1 : 기본 개념\n# 파트 2 : 시스템 객체 확장 (현재 위치)\n# 파트 3 : 상태\n# 파트 4 : 템플릿 및 모듈 (곧 제공 예정)","ogImage":{"url":"/assets/img/2024-05-01-BuildingABetterJavaScriptDOMBuilderPart2ExtendingSystemObjects_0.png"},"coverImage":"/assets/img/2024-05-01-BuildingABetterJavaScriptDOMBuilderPart2ExtendingSystemObjects_0.png","tag":["Tech"],"readingTime":19},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e첫 번째 부분에서는 DOM-JON 개념을 소개했습니다. HTML을 JSON 스타일의 네임스페이스로 재구성하고, 이를 DOM에 직접 번역하는 과정을 간단하게 소개하며, InnerHTML을 통해 작업하는 대신에 바로 DOM으로 이동하는 이유를 다뤘습니다.\u003c/p\u003e\n\u003cp\u003e간단한 사이드 노트, 이 기사의 목적은 여러분에게 이것을 사용하는 방법을 가르치는 것이 아니라, 제가 이를 구축하는 과정에서의 사고 과정을 공유하는 것입니다. 실시간으로 말이에요. 피드백을 받기 위해 내 머릿속에 정리하기 위해 글로 써내리기도! 문서화 및 전체 웹사이트는 나중에 제작될 예정입니다.\u003c/p\u003e\n\u003cp\u003e이번에는 기존 엘리먼트에 여러 노드를 쉽게 적용할 수 있도록하고, 이전 \"make\" 루틴의 \"attach\" 부분에 대한 액세스를 독립적으로 제공하고, 속성 처리를 더 견고하게 만들고자 합니다.\u003c/p\u003e\n\u003cp\u003e'원인은 몇 가지 부족한 것이 있기 때문이죠. Element.style 나 Element.dataset과 같은 속성은 Object.assign을 통해 요소에 적용할 수 없습니다. 속성에 직접 적용해야 합니다. 또한 DOM-JON 구조의 \"속성 객체\"를 사용하여 요소를 \"배치\"하는 방법과 같은 다른 정보를 전달할 수 있다면 좋겠어요.\u003c/p\u003e\n\u003cp\u003e이 부분을 간단히 하는 가장 좋은 방법은 무엇일까요?\u003c/p\u003e\n\u003ch1\u003e시스템 객체 확장\u003c/h1\u003e\n\u003cp\u003e기본적으로, 저는 기존 Document, Object, Node 및 Element 객체에 내 방법을 추가할 것입니다. 부모 클래스에 대한 정적 값 및 프로토타입에 대해서도 추가할 겁니다.\u003c/p\u003e\n\u003cp\u003e이제 이 일에 대해 너무 많은 공포가 있어요. 마치 JavaScript의 강력하고 다용도 객체 모델을 수정하면 안 된다는 것처럼 말이죠. \"결코 하지 말아야 한다!\" 라고 하는 분들은 충분한 이유 없이 말하는 경우가 많아요. 하지만 합당한 우려가 세 가지 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIE 7 / 이전 버전은 기존 객체에 프로토 타입 변경을 상속하지 않습니다.\u003c/li\u003e\n\u003cli\u003e우리 자신의 함수와 언어의 미래 변경 사이에 이름 충돌의 문을 열어둡니다.\u003c/li\u003e\n\u003cli\u003e변경할 수 있는 객체를 실수로 덮어쓰고, 이들을 열거할 수 있을 경우에 덮어쓸 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그 첫 번째 우려는 어질어질해요! 이제는 2024년이에요. 우리는 전혀 구식이 아닌 JavaScript를 쓰고 있어요. nullish coalescing, for..of, IE 어떤 버전에서도 작동하지 않는 spread / rest 연산자 등을 사용하고 있어요. 심지어 \"화살표 함수\"가 있으면 익스플로러의 JSCRIPT 엔진이 즉시 다운될 정도에요.\u003c/p\u003e\n\u003cp\u003e두 번째로, 이 문제는 네이밍 규칙을 사용하여 쉽게 해결할 수 있어요. 이런 경우에는 lodash의 방식을 가져와서 모든 사용자 지정 메서드와 속성의 시작에 이중 밑줄을 사용할 거에요. 누군가가 비슷한 기교를 사용하지 않는 한 문제없을 거예요.\u003c/p\u003e\n\u003cp\u003e저 세 번째 코드는 대부분 사람들이 바보같은 일을 하는 경우에 발생한 것이에요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eElement\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e__make\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etagName, ...attach\u003c/span\u003e) {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e해야 할 것은 다음과 같아요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edefineProperty\u003c/span\u003e(\n  \u003cspan class=\"hljs-title class_\"\u003eElement\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"__make\"\u003c/span\u003e,\n  { value : \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etagName, ...attach\u003c/span\u003e) {} }\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eObject.definePropert[ies | y]는 우리의 친구입니다... 그리고 JavaScript의 가장 안타깝게도 under-used한 부분 중 하나입니다. 전체 새 클래스를 만들지 않고 기존 Object에 추가하는 능력은 엄청 유용합니다. 시스템 객체가 이미 존재하기 때문에 전역 네임스페이스에 추가하는 것처럼 보이지 않습니다. 기본적으로 이러한 메서드에 의해 추가된 객체 속성 - 네, 속성, \"속성\"이 아니라. 그렇습니다, 심지어 DOM에 있는 경우도! - 객체에 대해 열거할 수 없게 만듭니다. 시스템 메서드만큼 \"숨겨진\" 것입니다. 현대 클래스에서 #을 접두사로 붙일 때와 같습니다. 필요할 경우에는 열거 가능하게 만들기 위해 인수 객체에 enumerable:true를 추가할 수도 있습니다.\u003c/p\u003e\n\u003ch1\u003eObject.definepropert[ies|y] 개선하기\u003c/h1\u003e\n\u003cp\u003e이 함수들을 좋아하지만, 문법에는 약간 번잡한 부분이 있어 불필요하게 장황하게 느끼게 할 수 있습니다. 이전 기사에서처럼 \"타입\"을 가로채서 요소의 \"타입\"을 확인하여 일반 객체를 전달하면 defineProperty과 같이 동작하지만, 다른 값 유형은 자동으로 가장 일반적으로 사용하는 기술인 객체 \u003ccode\u003e{\u003c/code\u003e value \u003ccode\u003e}\u003c/code\u003e에 래핑하게 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이를 돕기 위해 - 특히 일반 Object를 후손으로부터 격리하기 위해 - 나만의 Object.__type 루틴을 추가합니다. JavaScript에서 가장 큰 고통 중 하나는 범용 \"데이터 유형\" 객체를 다른 객체와 구분하는 간편한 메커니즘이 없다는 것입니다. 일부 후손은 typeof == \"Object\"를 반환하고 이는 원하는 바가 아닐 수 있습니다... 그리고 배열 같은 것들이 instanceof와 같은 것을 사용해야 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e목적을 달성하기 위해 Object.prototype에 이것을 적용하고 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    __type : { get : \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e value = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e\n        .\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e\n        .\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\" \"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n        [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eslice\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003e__define\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"__type\"\u003c/span\u003e, value);\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e value;\n    } } \u003cspan class=\"hljs-comment\"\u003e// Object.prototype.__type\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003etoString 메서드에는 실제 Object 클래스 이름이 포함되어 있어서 대부분 Array에는 Array라고, Node에는 Node라고, 일반 객체에는 Object라고 등등 표시될 거에요. 문자열 처리면에서 해당 값을 가져오는 것이 약간 무겁지만, Object.__type을 두 번 이상 요청하면 루틴이 두 번 호출되는 대신 define이 반환되도록 타입을 재정의할 수 있어요.\u003c/p\u003e\n\u003cp\u003e그러나 \"boolean\"과 같은 소수의 Object에 대해 이것은 작동하지 않습니다. 이것은 명백히 Object인데도 Object.prototype에서 상속받지 않기 때문이에요. (프로토타입이 있는) Element 등 특정 하위 클래스를 알 필요가없는 다른 객체들이 있을 수 있어요. Element 인지 여부를 알고 싶은데 HTMLTableElement인지를 알아야 할 필요는 없는 것이죠.\u003c/p\u003e\n\u003cp\u003e따라서 미리 값의 값을 먼저 선언해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e value \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e [\n   \u003cspan class=\"hljs-string\"\u003e\"Array\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Boolean\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Date\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Element\"\u003c/span\u003e,\n   \u003cspan class=\"hljs-string\"\u003e\"Error\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Function\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Map\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Node\"\u003c/span\u003e,\n   \u003cspan class=\"hljs-string\"\u003e\"Number\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"RegExp\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Set\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"String\"\u003c/span\u003e,\n   \u003cspan class=\"hljs-string\"\u003e\"Symbol\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Text\"\u003c/span\u003e\n ]) \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edefineProperty\u003c/span\u003e(\n   \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e[value].\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"__type\"\u003c/span\u003e, { value }\n );\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다행히도 모든 것이 window의 하위 요소이므로 window[value]를 사용하여 모든 이름을 배열에서 대상으로 할 수 있습니다. 매번 일일이 선언할 필요 없이 또는 [name, Object]와 같이 어리석고 무의미한 객체를 만들 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003e자바스크립트를 잘 몰라도 되는 분들을 위해,  value는 \u003ccode\u003e{\u003c/code\u003e \"value\": value \u003ccode\u003e}\u003c/code\u003e와 기능적으로 동일합니다. 객체 선언에서 변수를 그냥 넣으면 변수의 이름이 속성의 이름이 됩니다.\u003c/p\u003e\n\u003cp\u003e지금은 우리가 __define 루틴을 만들 수 있게 했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    __define : { value : \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename, value\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e/*\n        Object.defineProperty를 통해 속성을 할당합니다.\n        일반적인 Object가 전달되면 변경하지 않을 것이지만,\n        타입 지정된 Object나 다른 값이 전달되면 새 속성의 값을\n        할당할 Object로 이스케이프됩니다.\n        \n        전달된 객체대신 \"this\"를 반환하며, 내 의견으로는\n        훨씬 더 유용한 값입니다.\n      */\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edefineProperty\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, name,\n        \u003cspan class=\"hljs-string\"\u003e\"Object\"\u003c/span\u003e == value.\u003cspan class=\"hljs-property\"\u003e__type\u003c/span\u003e ? value : { value }\n      );\n    } }, \u003cspan class=\"hljs-comment\"\u003e// Object.prototype.__define\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 여러 속성을 설정하기 위한 __defineProps도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    __defineProps : { value : \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e props \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [name, value] \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eentries\u003c/span\u003e(props)) {\n          \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003e__define\u003c/span\u003e(name, value);\n        }\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e;\n    } }, \u003cspan class=\"hljs-comment\"\u003e// Object.prototype.__defineProps\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e저는 이것이 단지 구문 설탕을 구현하는 것이라는 것을 알지만, 괜찮습니다.\u003c/p\u003e\n\u003cp\u003e그들이 \"this\"를 반환한다는 것에 주목하세요. 이는 정의나 속성을 쉽게 연결할 수 있게 해줍니다. 수정된 객체 대신 적용된 객체를 반환하는 것은 많은 내장 JS 함수의 어리석은 부분 중 하나이며, 사용자 정의 메서드로 \"감싸는\" 또 다른 좋은 이유입니다.\u003c/p\u003e\n\u003cp\u003e구문 설탕에 관해서 말씀드리면... 몇몇 흔히 사용되는 Object 메서드에 대한 별칭을 제공하고 있습니다. 많은 방법이 Object에 정적인 메서드인 것은, 조작된 객체를 전달해야 하는 번거로움을 초래합니다. JS의 대부분이 Object의 형식을 갖춘 객체임을 감안하면, 이것은 약간 어리석은 것처럼 보일 수 있습니다. \"Object.entries(myObject)\" 대신에 그냥 \"myObject.entries\"로 간단히 작성할 수 있어야 하는 부분에 대해 지금 까지 많이 타이핑하는 것이 싫어졌습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  \u003cspan class=\"hljs-comment\"\u003e/*\n    다음 속성들은 Object 클래스에서 혼란스럽게 정적입니다.\n    이는 타입 캐스팅을 강제로 이용하는 데 편리하지만,\n    이미 객체인 것을 알고 있을 때는 복잡하다고 생각할 수 있습니다!\n\n    그래서 우리는 몇 가지 별칭을 만들어 보겠습니다.\n  */\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emakeAliasWrapper\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003emethod, name\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003e__define\u003c/span\u003e(\n      \u003cspan class=\"hljs-string\"\u003e`__\u003cspan class=\"hljs-subst\"\u003e${name}\u003c/span\u003e`\u003c/span\u003e,\n      { [method] : \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e[name](\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, ...\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e)\n      } }\n    );\n  }; \u003cspan class=\"hljs-comment\"\u003e// makeAliasWrapper\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [ method, names ] \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e [\n    [ \u003cspan class=\"hljs-string\"\u003e\"get\"\u003c/span\u003e,\n      [ \u003cspan class=\"hljs-string\"\u003e\"entries\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"isFrozen\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"isSealed\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"isExtensible\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"keys\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"values\"\u003c/span\u003e ]\n    ],\n    [ \u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e,\n      [ \u003cspan class=\"hljs-string\"\u003e\"assign\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"freeze\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"hasOwn\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"is\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"seal\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"preventExtensions\"\u003c/span\u003e ]\n    ]\n  ]) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (name \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e names) \u003cspan class=\"hljs-title function_\"\u003emakeAliasWrapper\u003c/span\u003e(method, name);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e저는 객체에 열거 가능한 키가 있는지 확인하는 \"__empty\" 게터도 만듭니다. 대부분의 경우, 이렇게 하는 이유는 제 기억력이 좋지 않아서 그런데요, \"__empty\"가 \"Object.keys(target).length == 0\" 또는 \"!target.__keys.length\"보다 기억하기 쉽거든요. 저의 별칭을 사용해서요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    __empty : { get : \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e/*\n        객체에 열거 가능한 키가 있는지 편리하게\n        보고합니다.\n      */\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e !\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e__keys\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e;\n    } }, \u003cspan class=\"hljs-comment\"\u003e// Object.prototype.__empty\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 이것으로 좋은 베이스라인 \"헬퍼\" 라이브러리가 완성됩니다.\u003c/p\u003e\n\u003cp\u003e그리고, 네, 전 \"arrow\" 대신 전체 함수를 사용하고 있습니다. 이유는 실제로 뒤집는 객체인 \"this\"에 액세스해야 하기 때문이에요. \"this\"를 창으로 설정하는 화살표 함수는 정말 많은 시나리오에서 아무 쓸모가 없거든요.\u003c/p\u003e\n\u003ch1\u003e\"첨부\"와 \"setAttr\"\u003c/h1\u003e\n\u003cp\u003e실제로 make 루틴을 구현하기 전에, 자식 요소들과 속성 객체의 \"attach\"를 별도의 함수로 분리하고 싶어요. 여러 하위 루틴들을 구현하고 있기 때문에, 우리의 지역 범위에 있는 \"attachData\" 객체 내부에 룩업 테이블/객체를 만들고 있어요.\u003c/p\u003e\n\u003cp\u003e우선은 \"sterile / void / empty\" 요소들에 대한 오류 감지를 해야해요. 이러한 요소에 속성을 첨부할 수 있지만 자식 노드는 첨부할 수 없어요. 나는 한 걸음 더 나아가서 특정 속성으로 String/Number 콘텐츠를 추가하는 것을 허용해요. 그러므로 우리는 다음을 할 수 있을 거에요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[ \u003cspan class=\"hljs-string\"\u003e\"img=images/test.png\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Test Image\"\u003c/span\u003e ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래의 코드조각을 Markdown포맷으로 표현하면 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;img src=\u003cspan class=\"hljs-string\"\u003e\"images/test.png\"\u003c/span\u003e alt=\u003cspan class=\"hljs-string\"\u003e\"Test Image\"\u003c/span\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e나는 어떤 함수나 배열을 통한 속성 처리도 허용한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003ecanAttach\u003c/span\u003e: {\n    \u003cspan class=\"hljs-comment\"\u003e/*\n        null          첨부할 수 없음 (빈 태그)\n        Boolean true  첨부할 수 있음 (기본값으로 기재되지 않은 경우)\n        Array         인수 키에 할당할 값\n        Function      콜백 함수(element, value)을 처리함\n        String        this.setAttribute로 첨부\n    */\u003c/span\u003e\n    area     : \u003cspan class=\"hljs-string\"\u003e\"alt\"\u003c/span\u003e,\n    img      : \u003cspan class=\"hljs-string\"\u003e\"alt\"\u003c/span\u003e,\n    meta     : \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e,\n    path     : \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e,\n    track    : \u003cspan class=\"hljs-string\"\u003e\"label\"\u003c/span\u003e,\n    input    : \u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e,\n    base     : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    br       : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    col      : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    embed    : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    hr       : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    link     : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    param    : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    source   : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    wbr      : \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    \u003cspan class=\"hljs-comment\"\u003e// 재밌는 목적으로 일부 SVG를 포함\u003c/span\u003e\n    polygon  : \u003cspan class=\"hljs-string\"\u003e\"points\"\u003c/span\u003e,\n    polyline : \u003cspan class=\"hljs-string\"\u003e\"points\"\u003c/span\u003e,\n    circle   : [ \u003cspan class=\"hljs-string\"\u003e\"cx\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"cy\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"r\"\u003c/span\u003e ],\n    ellipse  : [ \u003cspan class=\"hljs-string\"\u003e\"cx\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"cy\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"rx\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"ry\"\u003c/span\u003e ],\n    line     : [ \u003cspan class=\"hljs-string\"\u003e\"x1\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"y1\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"x2\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"y2\"\u003c/span\u003e ],\n    path     : [ \u003cspan class=\"hljs-string\"\u003e\"x1\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"y1\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"x2\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"y2\"\u003c/span\u003e ],\n    rect     : [ \u003cspan class=\"hljs-string\"\u003e\"x\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"y\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"width\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"height\"\u003c/span\u003e ]\n}, \u003cspan class=\"hljs-comment\"\u003e// attachData.canAttach\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그것은 우리에게 입력 값 설정하는 두 가지 방법을 제공한다는 걸 확인할 수 있어요. 다시 한번 말하지만, 저는 괜찮아요. 옵션은 좋은거죠.\u003c/p\u003e\n\u003cp\u003ecanAttach의 유형은 각각 다른 루틴을 사용해요. 제가 선택한 방법은 switch/case보다는 Object 룩업을 사용하는 것이에요. 옵션 체이닝 덕분에 attach 루틴 자체를 크게 간소화할 거에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    canType : {\n\n      \u003cspan class=\"hljs-string\"\u003e\"Array\"\u003c/span\u003e : \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003etarget, arg, canAttach\u003c/span\u003e) =\u003e\u003c/span\u003e {\n        \n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-string\"\u003e\"Array\"\u003c/span\u003e !== arg.\u003cspan class=\"hljs-property\"\u003e__type\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\n          \u003cspan class=\"hljs-string\"\u003e`\u0026#x3C;\u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.tagName}\u003c/span\u003e\u003e.__attach는 배열을 비-속성 인수로만 첨부할 수 있어요. \"\u003cspan class=\"hljs-subst\"\u003e${arg.__type}\u003c/span\u003e 대신에 입력했네요.`\u003c/span\u003e\n        );\n        \n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (arg.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e !== canAttach.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\n          \u003cspan class=\"hljs-string\"\u003e`\u0026#x3C;\u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.tagName}\u003c/span\u003e\u003e.__attach는 어떤 배열 인수에도 \u003cspan class=\"hljs-subst\"\u003e${canAttach.length}\u003c/span\u003e개의 값이 필요해요. \"\u003cspan class=\"hljs-subst\"\u003e${arg.length}\u003c/span\u003e 대신 입력했네요.`\u003c/span\u003e\n        );\n        \n        \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eassign\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003e__fromKeyValuePairs\u003c/span\u003e(canAttach, args));\n        \n      }, \u003cspan class=\"hljs-comment\"\u003e// attachData.canType.Array\u003c/span\u003e\n\n      \u003cspan class=\"hljs-string\"\u003e\"String\"\u003c/span\u003e : \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003etarget, arg, canAttach\u003c/span\u003e) =\u003e\u003c/span\u003e {\n        \n          \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (arg.\u003cspan class=\"hljs-property\"\u003e__type\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Number\"\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"String\"\u003c/span\u003e:\n              target.\u003cspan class=\"hljs-title function_\"\u003esetAttribute\u003c/span\u003e(canAttach, arg);\n              \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n          }\n          \n          \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\n            \u003cspan class=\"hljs-string\"\u003e`\u0026#x3C;\u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.tagName}\u003c/span\u003e\u003e.__attach는 문자열 또는 숫자 비-속성 인수만 첨부할 수 있어요. \"\u003cspan class=\"hljs-subst\"\u003e${arg.__type}\u003c/span\u003e 대신 입력했네요.`\u003c/span\u003e\n          );\n          \n      } \u003cspan class=\"hljs-comment\"\u003e// attachData.canType.String\u003c/span\u003e\n\n    }, \u003cspan class=\"hljs-comment\"\u003e// // attachData.canType\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에 \"throw\"를 많이 사용한 것을 주목하세요. 심각한 오류가 발생했을 때는 스크립팅이 멈춰야 한다고 확신을 갖고 있어요. 그 자리에서 멈춰야 해요. HTML과 JavaScript는 이를 처리하기 위한 완벽한 메커니즘을 제공하지만 여전히 너무 관대하다고 생각해요.\u003c/p\u003e\n\u003cp\u003e\"argument\"의 종류에 따라 특별한 처리 사례가 있을 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    argType : {\n\n      \u003cspan class=\"hljs-string\"\u003e\"Array\"\u003c/span\u003e : \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003etarget, arg, canAttach\u003c/span\u003e) =\u003e\u003c/span\u003e target.\u003cspan class=\"hljs-title function_\"\u003e__make\u003c/span\u003e(...arg),\n\n      \u003cspan class=\"hljs-string\"\u003e\"Function\"\u003c/span\u003e : \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003etarget, arg, canAttach\u003c/span\u003e) =\u003e\u003c/span\u003e target.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003earg\u003c/span\u003e(target))\n\n    }, \u003cspan class=\"hljs-comment\"\u003e// // attachData.argType\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 위의 어떤 경우도 일치하지 않을 때의 대체 방안입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    append : \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003etarget, arg, canAttach\u003c/span\u003e) =\u003e\u003c/span\u003e target.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(arg)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 모든 것이 갖춰진 상태에서 Element.__defineProps를 Element.prototype.__attach 메서드에 적용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e \u003cspan class=\"hljs-title class_\"\u003eElement\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003e__defineProps\u003c/span\u003e( {\n\n    __attach : \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e canAttach = attachData.\u003cspan class=\"hljs-property\"\u003ecanAttach\u003c/span\u003e[\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etagName\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoLowerCase\u003c/span\u003e()\n      ] || \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n\n      \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arg \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e) {\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-string\"\u003e\"Object\"\u003c/span\u003e === arg.\u003cspan class=\"hljs-property\"\u003e__type\u003c/span\u003e) \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003e__setAttr\u003c/span\u003e(arg);\n\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (canAttach) (\n          attachData.\u003cspan class=\"hljs-property\"\u003ecanType\u003c/span\u003e[canAttach.\u003cspan class=\"hljs-property\"\u003e__type\u003c/span\u003e] ??\n          attachData.\u003cspan class=\"hljs-property\"\u003eargType\u003c/span\u003e[arg.\u003cspan class=\"hljs-property\"\u003e__type\u003c/span\u003e] ??\n          attachData.\u003cspan class=\"hljs-property\"\u003eappend\u003c/span\u003e\n        )(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, arg, canAttach);\n\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\n          \u003cspan class=\"hljs-string\"\u003e`\u0026#x3C;\u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.tagName}\u003c/span\u003e\u003e은(는) 빈 Element이므로 해당 Element.prototype.__attach로 자식요소를 추가할 수 없습니다.`\u003c/span\u003e\n        );\n\n      }\n\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e;\n\n    }, \u003cspan class=\"hljs-comment\"\u003e// Element.prototype.__attach\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eElement의 tagName을 룩업했을 때 찾을 수 없다면 대부분의 태그는 첨부 파일을 가질 수 있으므로 true로 기본값으로 설정됩니다.\u003c/p\u003e\n\u003cp\u003e만약 순수한 객체라면, 속성을 설정하기 위해 해당 객체를 사용합니다. 만약 loose-true라면 널 병합 연산자를 사용하여 올바른 첨부 서브루틴을 선택합니다. 만약 아무것도 작동하지 않으면 자식 요소/데이터를 첨부할 수 없는 요소에서 예외를 발생시킵니다.\u003c/p\u003e\n\u003cp\u003e그리고 함수에 전달된 모든 인수를 처리하기 때문에 속성 및 자식 뿐만 아니라 make도 선언할 수 있습니다. 따라서 DOM-JON 항목의 배열이 있다면 attach에서 분해할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e test = [\n  [ \u003cspan class=\"hljs-string\"\u003e\"h2\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"테스트 제목\"\u003c/span\u003e ],\n  [ \u003cspan class=\"hljs-string\"\u003e\"p\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"간단한 테스트 단락\"\u003c/span\u003e ]\n];\n\n\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"testDIV\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003e__attach\u003c/span\u003e(...test);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 실제 JSON 객체를 만들고 쉽게 첨부할 수 있습니다. 이제 HTML을 서버측에서 빌드하지 않고 JSON을 보내는 가능성을 생각해보세요.\u003c/p\u003e\n\u003cp\u003e이제 이렇게 생긴 \"setAttr\" 메소드를 호출합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003e__setAttr\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eattr\u003c/span\u003e) {\n  \n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [key, value] \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eentries\u003c/span\u003e(attr)) {\n    \n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (key) {\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"__makePlace\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003e__define\u003c/span\u003e(key, value);\n        \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"dataset\"\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"style\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-string\"\u003e\"Object\"\u003c/span\u003e !== value.\u003cspan class=\"hljs-property\"\u003e__type\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\n          \u003cspan class=\"hljs-string\"\u003e`\u0026#x3C;\u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.tagName}\u003c/span\u003e\u003e.__setAttr requires a Object when setting \"\u003cspan class=\"hljs-subst\"\u003e${key}\u003c/span\u003e\", got \"\u003cspan class=\"hljs-subst\"\u003e${value.__type}\u003c/span\u003e\" instead.`\u003c/span\u003e\n        );\n        \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eassign\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e[key], value);\n        \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n    }\n    \n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (value.\u003cspan class=\"hljs-property\"\u003e__type\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Array\"\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Function\"\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Object\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e[key] = value;\n        \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n    }\n    \n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esetAttribute\u003c/span\u003e(key, value);\n    \n  }\n  \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e;\n  \n} \u003cspan class=\"hljs-comment\"\u003e// Element.prototype.__setAttr\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\"쉬운\" \u003ccode\u003eObject.assign\u003c/code\u003e 대신 손수 속성 객체를 반복해서 순회하는 방법을 사용합니다. 이렇게 하면 정의를 후킹하고, 데이터셋과 스타일을 올바르게 처리할 수 있습니다. 대부분의 속성에는 \u003ccode\u003esetAttribute\u003c/code\u003e를 사용하는 것이 좋지만, 그것은 값들을 문자열로만 설정할 수 있습니다. 배열, 함수 및 객체 기능을 트랩할 수 있어서 이벤트 등을 설정할 수 있게 합니다.\u003c/p\u003e\n\u003cp\u003e참고로, DOM-JON에서는 className 대신 \u003ccode\u003e{\u003c/code\u003e \"class\": \"myClassName\" \u003ccode\u003e}\u003c/code\u003e를 사용해야 합니다. 여러분! className을 수동으로 \"class\"로 이름을 변경하여 두 가지 방법으로 사용할 수 있도록 할지 고민 중입니다. DSS \"dot\" 구분 기호를 사용하여 클래스를 설정하는 것이 시간을 들이는 가치가 있는 것일까요?\u003c/p\u003e\n\u003cp\u003eElement에 이 모든 것을 설정한 후에는 새로운 개선된 \u003ccode\u003e__make\u003c/code\u003e을 사용할 수 있게 됩니다. 이것을 모듈의 일부로 내보내거나 전역 범위에 넣는 것보다는, 저는 문서 객체에 이것을 넣을 것입니다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003e__defineProps\u003c/span\u003e( {\n\n    __make : \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eselector, ...attach\u003c/span\u003e) =\u003e\u003c/span\u003e {\n\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e\n        parts = { attr : {}, data : {}, define : {} },\n        value;\n\n      \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [ delimiter, typeName, attrName ] \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e makeData.\u003cspan class=\"hljs-property\"\u003edelimiters\u003c/span\u003e) {\n        [selector, value] = selector.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(delimiter, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (value) parts[typeName][attrName] = value;\n      }\n      \n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e\n        tagName = (selector || \u003cspan class=\"hljs-string\"\u003e\"span\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003etoLowerCase\u003c/span\u003e(),\n        namespace = (\n          parts.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enamespace\u003c/span\u003e ? (\n            parts.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enamespace\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eindexOf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"http://\"\u003c/span\u003e) === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e ?\n            parts.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enamespace\u003c/span\u003e :\n            (\n              makeData.\u003cspan class=\"hljs-property\"\u003enamespaces\u003c/span\u003e[parts.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enamsspace\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoUpperCase\u003c/span\u003e()] ?? \n              makeData.\u003cspan class=\"hljs-property\"\u003enamespaces\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eHTML\u003c/span\u003e\n            )\n          ) : makeData.\u003cspan class=\"hljs-property\"\u003enamespaces\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eHTML\u003c/span\u003e\n        ),\n        e = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eassign\u003c/span\u003e(\n          \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElementNS\u003c/span\u003e(namespace, tagName),\n          parts.\u003cspan class=\"hljs-property\"\u003eattr\u003c/span\u003e\n        );\n      \n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!parts.\u003cspan class=\"hljs-property\"\u003edefine\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e__empty\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [key, value] \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e parts.\u003cspan class=\"hljs-property\"\u003edefine\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e__entries\u003c/span\u003e) {\n          e.\u003cspan class=\"hljs-title function_\"\u003e__define\u003c/span\u003e(key, value);\n        }\n      }\n\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (parts.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e) e.\u003cspan class=\"hljs-title function_\"\u003esetAttribute\u003c/span\u003e(\n        makeData.\u003cspan class=\"hljs-property\"\u003evalues\u003c/span\u003e[tagName] ?? \u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e,\n        parts.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e\n      );\n\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (parts.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003especial\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e attrName = makeData.\u003cspan class=\"hljs-property\"\u003especial\u003c/span\u003e[tagName];\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (attrName) e.\u003cspan class=\"hljs-title function_\"\u003esetAttribute\u003c/span\u003e(attrName, parts.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003especial\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewarn\u003c/span\u003e(\n          \u003cspan class=\"hljs-string\"\u003e`Special underscore property not supported on \u0026#x3C;\u003cspan class=\"hljs-subst\"\u003e${tagName}\u003c/span\u003e\u003e, ignoring value \"\u003cspan class=\"hljs-subst\"\u003e${parts.data.special}\u003c/span\u003e\"`\u003c/span\u003e\n        );\n      }\n\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (attach) e.\u003cspan class=\"hljs-title function_\"\u003e__attach\u003c/span\u003e(...attach);\n\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e e;\n\n    } \u003cspan class=\"hljs-comment\"\u003e// document.__make\u003c/span\u003e\n\n  } ); \u003cspan class=\"hljs-comment\"\u003e// document extensions\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e큰 변경 중 하나는 이제 \"define\"을 구분 기준으로 사용한다는 것입니다. 이를 새로운 구분자 조회에서 확인할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    \u003cspan class=\"hljs-comment\"\u003e/*\n      DSS 구분자는 여기 나열된 순서의 역순으로 사용해야 합니다.\n      여기 나열된 나중에 있는 문자는 이전 섹션 값들의 값 안에서 사용할 수 없습니다.\n      \n      예를 들어 ID 내에서 \".\"을 사용할 수 없습니다.\n    */\u003c/span\u003e\n    delimiters : [\n      [ \u003cspan class=\"hljs-string\"\u003e\"=\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"data\"\u003c/span\u003e,   \u003cspan class=\"hljs-string\"\u003e\"value\"\u003c/span\u003e ],\n      [ \u003cspan class=\"hljs-string\"\u003e\"?\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"attr\"\u003c/span\u003e,   \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e ],\n      [ \u003cspan class=\"hljs-string\"\u003e\".\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"attr\"\u003c/span\u003e,   \u003cspan class=\"hljs-string\"\u003e\"className\"\u003c/span\u003e ],\n      [ \u003cspan class=\"hljs-string\"\u003e\"#\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"attr\"\u003c/span\u003e,   \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e ],\n      [ \u003cspan class=\"hljs-string\"\u003e\"\u0026#x26;\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"define\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"__stateName\"\u003c/span\u003e ],\n      [ \u003cspan class=\"hljs-string\"\u003e\"@\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"define\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"__makePlace\"\u003c/span\u003e ],\n      [ \u003cspan class=\"hljs-string\"\u003e\":\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"data\"\u003c/span\u003e,   \u003cspan class=\"hljs-string\"\u003e\"namespace\"\u003c/span\u003e ],\n      [ \u003cspan class=\"hljs-string\"\u003e\"_\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"data\"\u003c/span\u003e,   \u003cspan class=\"hljs-string\"\u003e\"special\"\u003c/span\u003e ]\n    ], \u003cspan class=\"hljs-comment\"\u003e// makeData.delimiters\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이를 통해 DOM 요소에 변경 불가능하고 열거되지 않는 정의를 만들 수 있어요. 다음 부분에 이르러 성능이 좋아지는데 유용할 것입니다: Element.prototype.__make\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    __make : \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e e = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(...\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e);\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einsertAdjacentElement\u003c/span\u003e(e.\u003cspan class=\"hljs-property\"\u003e__makePlace\u003c/span\u003e ?? \u003cspan class=\"hljs-string\"\u003e\"beforeend\"\u003c/span\u003e, e);\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e;\n      \n    }, \u003cspan class=\"hljs-comment\"\u003e// Element.prototype.__make\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 버전의 make 함수는 새 Element를 부모 요소와 관련하여 자동으로 첨부합니다. 다음과 같은 코드가 있다고 가정해봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;div id=\u003cspan class=\"hljs-string\"\u003e\"test\"\u003c/span\u003e\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e원본 콘텐츠\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/div\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 기능을 한 번 시도해보세요 — __attach가 Element.prototype.__make를 호출하므로 둘 다 테스트됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"test\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003e__attach\u003c/span\u003e(\n  [ \u003cspan class=\"hljs-string\"\u003e\"h2@afterbegin\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"처음에 \u0026#x3C;h2\u003e 추가됨\"\u003c/span\u003e ],\n  [ \u003cspan class=\"hljs-string\"\u003e\"h1@beforebegin\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"앞에 \u0026#x3C;h1\u003e 추가됨\"\u003c/span\u003e ],\n  [ \u003cspan class=\"hljs-string\"\u003e\"footer\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// beforeend는 기본값\u003c/span\u003e\n    [ \u003cspan class=\"hljs-string\"\u003e\"p\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"마지막에 \u0026#x3C;footer\u003e 추가됨\"\u003c/span\u003e ]\n  ],\n  [ \u003cspan class=\"hljs-string\"\u003e\"p@afterend\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;p\u003e 뒤에 추가됨\"\u003c/span\u003e ]\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기 동작 중인 것이 있는 펜입니다:\u003c/p\u003e\n\u003cp\u003e전체 DOM-JON 코드베이스를 외부 {}에 넣어 scope isolation을 만들었음을 볼 수 있습니다. 오랜 시간 동안 JS의 let/const가 쓸모 없다고 생각했는데, 그것들을 사용하면 이전에 IIFE에 낭비했던 것들을 대체할 수 있다는 것을 깨달았습니다. 자주 캐시를 비운 첫 로드에서 클라이언트 사이드 파일 수를 나누는 모듈을 사용하지 않아도 됩니다. 이 방법을 사용하면 별도의 스크립트를 연결하여 배포 시 파일 수를 줄일 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e새로운 Object 메소드 요약\u003c/h1\u003e\n\u003cp\u003e그래서 이제 DOM-JON을 다루는 방법에 대해 다음과 같은 메서드가 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003emethod Element.prototype.__attach(...attachments)\u003c/strong\u003e\nattachment 유형에 따라 노드 또는 속성을 문서에 첨부합니다. 일반적인 객체는 노드 속성 및/또는 특별히 정의된 상태로 적용되며, 배열은 this.__make(Element.prototype__make)에 전달됩니다. 그 외의 경우는 추가됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003emethod document.__make(selector, ...attachments)\u003c/strong\u003e\nDSS를 적용하여 셀렉터로부터 Element를 생성한 다음 첨부를 Element.prototype.__attach에 전달합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003emethod Element.prototype.__make(selector, ...attachments)\u003c/strong\u003e\nDocument.__make를 호출하여 Element를 생성한 다음, 새 Element의 __makePlace 값에 따라 \"this\"에 추가되거나, 선언되지 않은 경우 기본값으로 \"beforeend\"에 추가됩니다.\u003c/p\u003e\n\u003cp\u003emethod Element.prototype.__setAttr(obj)\u003cbr\u003e\n요소에 속성:값 쌍의 일반 객체를 할당합니다. 일부 속성은 __define으로 생성되도록 가로챕니다. 스타일 및 데이터세트와 같은 객체 하위 속성은 정규화되어 작동합니다. 함수, 배열 및 기타 객체는 this[key] = value로 할당되고, 다른 모든 값 유형은 this.setAttribute(key, value)로 할당됩니다.\u003c/p\u003e\n\u003cp\u003e또한 시스템 객체에 대한 많은 유용한 추가 기능들이 있습니다.\u003c/p\u003e\n\u003cp\u003emethod Object.prototype.__define(name, value)\u003cbr\u003e\nObject.defineProperty와 유사하지만 일반 객체를 \u003ccode\u003e{\u003c/code\u003e value \u003ccode\u003e}\u003c/code\u003e로 할당하며 \"this\"를 반환하고 전달된 값이 아닙니다.\u003c/p\u003e\n\u003cp\u003emethod Object.prototype.__defineProps(...props)\u003cbr\u003e\n__define이 defineProperty와 유사하다면, __defineProps는 defineProperties와 유사합니다. 가장 큰 차이점은 여러 다른 이름/속성 쌍의 객체를 수락할 수 있으며 첫 번째 전달된 인수 대신 \"this\"를 반환한다는 것입니다.\u003c/p\u003e\n\u003cp\u003e정적 메서드 Object.__defineMulti(targets, ...props)\n여러 대상에 속성을 할당합니다. 대상은 키 배열이어야하며, 그 다음 ...props의 각 객체와 일치해야합니다.\u003c/p\u003e\n\u003cp\u003e정적 메서드 Object.__fromKeyValueArrays(keys, values)\n두 배열에서 객체를 생성합니다.\u003c/p\u003e\n\u003cp\u003egetter 및/또는 propertyObject.prototype.__type\n단일 \"유형\"을 반환합니다. 마치 통일된 \"typeof\" 및 \"instanceof\"처럼 다루기가 훨씬 덜 복잡한 것처럼. 대부분의 객체에 대해 이것은 처음 호출시 getter이지만 절대 수정할 수없는 열거 불가 속성으로 재정의됩니다. 일부 일반 객체 유형도 해당 속성으로 시작됩니다.\u003c/p\u003e\n\u003cp\u003e이것이 \"공개적으로 보이는\" 속성과 메서드입니다. 전역 변수나 전역 함수가 필요하지 않습니다.\u003c/p\u003e\n\u003cp\u003e그게 이번에는 그게 다야. 13,000 줄의 코드가 있지만 gzip으로 압축하면 겨우 4,400 줄만 남아. 압축 후 최소화하면 3,000 줄도 안 될 것 같아.\u003c/p\u003e\n\u003cp\u003e이 알파 빌드를 여기서 다운로드할 수 있어:\n\u003ca href=\"https://cutcodedown.com/for_others/domjon/domjon.alpha4.js\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://cutcodedown.com/for_others/domjon/domjon.alpha4.js\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e다음에는 \"__make\"로 구축된 DOM 구조에 직접 연결할 수 있는 getter 및 setter를 생성하는 \"State\" 객체를 추가할 거야. 이는 \"listeners\"가 작동하는 방식과 유사하다.\u003c/p\u003e\n\u003ch1\u003e기사 목차\u003c/h1\u003e\n\u003ch1\u003e파트 1 : 기본 개념\u003c/h1\u003e\n\u003ch1\u003e파트 2 : 시스템 객체 확장 (현재 위치)\u003c/h1\u003e\n\u003ch1\u003e파트 3 : 상태\u003c/h1\u003e\n\u003ch1\u003e파트 4 : 템플릿 및 모듈 (곧 제공 예정)\u003c/h1\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-01-BuildingABetterJavaScriptDOMBuilderPart2ExtendingSystemObjects"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>