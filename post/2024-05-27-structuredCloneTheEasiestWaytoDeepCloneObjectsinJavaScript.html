<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript" data-gatsby-head="true"/><meta name="twitter:title" content="structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 18:19" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png">
<h1>1. 서문</h1>
<p>왜 지금까지 JavaScript에 완전한 복제 함수가 만들어지지 않았을까요? 데이터 유형에 관계 없이 객체와 해당 모든 내용을 완전히 복제하는 것은?</p>
<p>이건 놀랍고, 때로는 객체를 깊은 복제해야 하는 경우가 많이 있어서 일에 많은 어려움을 야기하죠.</p>
<div class="content-ad"></div>
<h1>2. 객체를 깊은 복제하는 두 가지 방법</h1>
<p><img src="/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_1.png" alt="이미지"></p>
<p>내 친구야, 객체를 깊은 복제하는 방법을 아시나요? 위 표의 데이터 유형을 복제하는 것이 가장 좋을 겁니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> testData = {
  <span class="hljs-attr">number</span>: <span class="hljs-number">123</span>,
  <span class="hljs-attr">string</span>: <span class="hljs-string">"test"</span>,
  <span class="hljs-attr">undefined</span>: <span class="hljs-literal">undefined</span>,
  <span class="hljs-attr">null</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">boolean</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">object</span>: { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: { <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> } },
  <span class="hljs-attr">array</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, { <span class="hljs-attr">d</span>: <span class="hljs-number">3</span> }],
  <span class="hljs-attr">function</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>; },
  <span class="hljs-attr">map</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">"key1"</span>, <span class="hljs-string">"value1"</span>], [<span class="hljs-string">"key2"</span>, <span class="hljs-string">"value2"</span>]]),
  <span class="hljs-attr">set</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]),
  <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),
  <span class="hljs-attr">error</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"An error occurred"</span>),
  <span class="hljs-attr">regex</span>: <span class="hljs-regexp">/test/i</span>,
  <span class="hljs-attr">domNode</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>)
}
</code></pre>
<div class="content-ad"></div>
<p>우리는 testData를 테스트 데이터로 사용할 것입니다.</p>
<h1>2.1# JSON.parse와 JSON.stringify</h1>
<p>이 기능을 사용하면 객체를 깊이 복제할 수 있지만, 유감스럽게도 데이터 유형의 일부만 복사될 뿐이며, 순환 참조가 있는 객체는 복사할 수 없습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">const</span> jsonClone = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(testData))
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonClone)
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"JSON 메서드가 이 데이터를 처리할 수 없습니다"</span>)
}
<span class="hljs-comment">// 출력</span>
<span class="hljs-comment">/*
{
  number: 123,
  string: "test",
  null: null,
  boolean: true,
  object: { a: 1, b: { c: 2 } },
  array: [1, 2, { d: 3 }]
}
*/</span>
</code></pre>
<div class="content-ad"></div>
<p>이미지를 포함한 코드 블록:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">'fatfish'</span> }

obj.<span class="hljs-property">obj</span> = obj
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj))
</code></pre>
<p>Markdown 형식으로 변환 된 표:</p>
<h1>2.2# lodash.clone</h1>
<div class="content-ad"></div>
<p>대부분의 사람들이 이 선택을 하겠지만 추가적인 npm 패키지를 가져와야 할 수도 있지만 그 가치는 충분히 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash'</span>)
<span class="hljs-keyword">const</span> lodashClone = _.<span class="hljs-title function_">cloneDeep</span>(testData)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lodashClone)

<span class="hljs-comment">/*
{
  number: 123,
  string: "test",
  undefined: undefined,
  null: null,
  boolean: true,
  object: { a: 1, b: { c: 2 } },
  array: [1, 2, { d: 3 }],
  function: [Function: function], // 함수 참조는 복사됩니다.
  map: Map { 'key1' => 'value1', 'key2' => 'value2' },
  set: Set { 1, 2, 3 },
  date: 2023-05-23T09:00:00.000Z,
  error: Error: An error occurred,
  regex: /test/i,
  domNode: HTMLDivElement {}
}
*/</span>
</code></pre>
<p><img src="/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_4.png" alt="이미지"></p>
<h1>3.1# 새로운 API: structuredClone?</h1>
<div class="content-ad"></div>
<img src="/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_5.png">
<p>mdn에서 가져왔어요!</p>
<p>2022년부터 크롬, 파이어폭스 등 다양한 주요 브라우저에서 지원되고 있어요. 우리에게 행운이네요!</p>
<p>아직 이 데이터를 사용 중이지만, 먼저 함수와 DOM 유형을 숨기고, 그 이유를 나중에 설명할게요.</p>
<div class="content-ad"></div>
<p>const testData = {
number: 123,
string: "test",
undefined: undefined,
null: null,
boolean: true,
object: { a: 1, b: { c: 2 } },
array: [1, 2, { d: 3 }],
// function: function() { return "hello"; },
map: new Map([["key1", "value1"], ["key2", "value2"]]),
set: new Set([1, 2, 3]),
date: new Date(),
error: new Error("An error occurred"),
regex: /test/i,
// domNode: document.createElement("div")
}</p>
<p>const structuredCloneResult = structuredClone(testData)
console.log(structuredCloneResult)
/*
{
number: 123,
string: "test",
undefined: undefined,
null: null,
boolean: true,
object: { a: 1, b: { c: 2 } },
array: [1, 2, { d: 3 }],
function: undefined, // Functions are not cloned
map: Map { 'key1' => 'value1', 'key2' => 'value2' },
set: Set { 1, 2, 3 },
date: 2023-05-23T09:00:00.000Z,
error: Error: An error occurred,
regex: /test/i,
domNode: undefined // DOM nodes are not cloned
}
*/</p>
<img src="/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_6.png">
<p>우리가 손에 들고 있는 잔을 들어 올려봐요. 이 결과는 축하해야 할 만하네요.</p>
<h1>3.2# structuredClone의 장점</h1>
<div class="content-ad"></div>
<p>친구야, structuredClone 함수를 좋아하시나요? 충분히 간단한가요? 네, 그것이 가장 큰 장점이죠.</p>
<p>하지만 또 다른 큰 장점이 있습니다. 그것은 심지어 원형 참조가 있는 객체도 복사할 수 있다는 것이죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">'fatfish'</span> }

obj.<span class="hljs-property">obj</span> = obj
<span class="hljs-title function_">structuredClone</span>(obj)
</code></pre>
<img src="/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_7.png">
<div class="content-ad"></div>
<h1>3.3 구조화된 복제의 일부 제한 사항</h1>
<p>친구들아, 함께 축배를 건넜지만, 구조화된 복제에는 여전히 몇 가지 제한 사항이 있음을 인정해야 합니다.</p>
<p>함수나 Dom을 복사할 수 없습니다. 이를 하려고 시도하면 예외가 발생합니다. 이것이 저가 함수와 Dom을 숨긴 이유입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">fn</span>: <span class="hljs-function">() =></span> {} }

<span class="hljs-title function_">structuredClone</span>(obj)
</code></pre>
<div class="content-ad"></div>
<img src="/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_8.png">
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">domNode</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>) }

<span class="hljs-title function_">structuredClone</span>(obj)
</code></pre>
<img src="/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_9.png">
<p>이 함수를 호출할 때 오류가 발생하지 않도록 하고, 메소드를 가진 객체를 깊게 복제하지만 메소드는 복제하지 않기를 원합니다.</p>
<div class="content-ad"></div>
<h1>친절한 한국어 번역 🚀</h1>
<p>In Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:</p>
<ul>
<li>작가를 박수 보내고 팔로우하세요 ️👏️️</li>
<li>팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter</li>
<li>다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed</li>
<li>알고리즘 콘텐츠에 강제로 노출되는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.</li>
<li>PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"structuredClone(), JavaScript에서 객체를 깊은 복제하는 가장 쉬운 방법","description":"","date":"2024-05-27 18:19","slug":"2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png\" /\u003e\n\n# 1. 서문\n\n왜 지금까지 JavaScript에 완전한 복제 함수가 만들어지지 않았을까요? 데이터 유형에 관계 없이 객체와 해당 모든 내용을 완전히 복제하는 것은?\n\n이건 놀랍고, 때로는 객체를 깊은 복제해야 하는 경우가 많이 있어서 일에 많은 어려움을 야기하죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 객체를 깊은 복제하는 두 가지 방법\n\n![이미지](/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_1.png)\n\n내 친구야, 객체를 깊은 복제하는 방법을 아시나요? 위 표의 데이터 유형을 복제하는 것이 가장 좋을 겁니다.\n\n```js\nconst testData = {\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: function() { return \"hello\"; },\n  map: new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]),\n  set: new Set([1, 2, 3]),\n  date: new Date(),\n  error: new Error(\"An error occurred\"),\n  regex: /test/i,\n  domNode: document.createElement(\"div\")\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 testData를 테스트 데이터로 사용할 것입니다.\n\n# 2.1# JSON.parse와 JSON.stringify\n\n이 기능을 사용하면 객체를 깊이 복제할 수 있지만, 유감스럽게도 데이터 유형의 일부만 복사될 뿐이며, 순환 참조가 있는 객체는 복사할 수 없습니다.\n\n```js\ntry {\n  const jsonClone = JSON.parse(JSON.stringify(testData))\n  console.log(jsonClone)\n} catch (error) {\n  console.log(\"JSON 메서드가 이 데이터를 처리할 수 없습니다\")\n}\n// 출력\n/*\n{\n  number: 123,\n  string: \"test\",\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }]\n}\n*/\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지를 포함한 코드 블록:\n\n```js\nconst obj = { name: 'fatfish' }\n\nobj.obj = obj\nJSON.parse(JSON.stringify(obj))\n```\n\nMarkdown 형식으로 변환 된 표:\n\n# 2.2# lodash.clone\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 사람들이 이 선택을 하겠지만 추가적인 npm 패키지를 가져와야 할 수도 있지만 그 가치는 충분히 합니다.\n\n```js\nconst _ = require('lodash')\nconst lodashClone = _.cloneDeep(testData)\nconsole.log(lodashClone)\n\n/*\n{\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: [Function: function], // 함수 참조는 복사됩니다.\n  map: Map { 'key1' =\u003e 'value1', 'key2' =\u003e 'value2' },\n  set: Set { 1, 2, 3 },\n  date: 2023-05-23T09:00:00.000Z,\n  error: Error: An error occurred,\n  regex: /test/i,\n  domNode: HTMLDivElement {}\n}\n*/\n```\n\n![이미지](/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_4.png)\n\n# 3.1# 새로운 API: structuredClone?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_5.png\" /\u003e\n\nmdn에서 가져왔어요!\n\n2022년부터 크롬, 파이어폭스 등 다양한 주요 브라우저에서 지원되고 있어요. 우리에게 행운이네요!\n\n아직 이 데이터를 사용 중이지만, 먼저 함수와 DOM 유형을 숨기고, 그 이유를 나중에 설명할게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nconst testData = {\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  // function: function() { return \"hello\"; },\n  map: new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]),\n  set: new Set([1, 2, 3]),\n  date: new Date(),\n  error: new Error(\"An error occurred\"),\n  regex: /test/i,\n  // domNode: document.createElement(\"div\")\n}\n\nconst structuredCloneResult = structuredClone(testData)\nconsole.log(structuredCloneResult)\n/*\n{\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: undefined, // Functions are not cloned\n  map: Map { 'key1' =\u003e 'value1', 'key2' =\u003e 'value2' },\n  set: Set { 1, 2, 3 },\n  date: 2023-05-23T09:00:00.000Z,\n  error: Error: An error occurred,\n  regex: /test/i,\n  domNode: undefined // DOM nodes are not cloned\n}\n*/\n\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_6.png\" /\u003e\n\n우리가 손에 들고 있는 잔을 들어 올려봐요. 이 결과는 축하해야 할 만하네요.\n\n# 3.2# structuredClone의 장점\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n친구야, structuredClone 함수를 좋아하시나요? 충분히 간단한가요? 네, 그것이 가장 큰 장점이죠.\n\n하지만 또 다른 큰 장점이 있습니다. 그것은 심지어 원형 참조가 있는 객체도 복사할 수 있다는 것이죠.\n\n```js\nconst obj = { name: 'fatfish' }\n\nobj.obj = obj\nstructuredClone(obj)\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_7.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3.3 구조화된 복제의 일부 제한 사항\n\n친구들아, 함께 축배를 건넜지만, 구조화된 복제에는 여전히 몇 가지 제한 사항이 있음을 인정해야 합니다.\n\n함수나 Dom을 복사할 수 없습니다. 이를 하려고 시도하면 예외가 발생합니다. 이것이 저가 함수와 Dom을 숨긴 이유입니다.\n\n```js\nconst obj = { fn: () =\u003e {} }\n\nstructuredClone(obj)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_8.png\" /\u003e\n\n```js\nconst obj = { domNode: document.createElement('div') }\n\nstructuredClone(obj)\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_9.png\" /\u003e\n\n이 함수를 호출할 때 오류가 발생하지 않도록 하고, 메소드를 가진 객체를 깊게 복제하지만 메소드는 복제하지 않기를 원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 친절한 한국어 번역 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수 보내고 팔로우하세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠에 강제로 노출되는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_0.png\"\u003e\n\u003ch1\u003e1. 서문\u003c/h1\u003e\n\u003cp\u003e왜 지금까지 JavaScript에 완전한 복제 함수가 만들어지지 않았을까요? 데이터 유형에 관계 없이 객체와 해당 모든 내용을 완전히 복제하는 것은?\u003c/p\u003e\n\u003cp\u003e이건 놀랍고, 때로는 객체를 깊은 복제해야 하는 경우가 많이 있어서 일에 많은 어려움을 야기하죠.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e2. 객체를 깊은 복제하는 두 가지 방법\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e내 친구야, 객체를 깊은 복제하는 방법을 아시나요? 위 표의 데이터 유형을 복제하는 것이 가장 좋을 겁니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e testData = {\n  \u003cspan class=\"hljs-attr\"\u003enumber\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003estring\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"test\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eundefined\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003enull\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eboolean\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eobject\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003ec\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e } },\n  \u003cspan class=\"hljs-attr\"\u003earray\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003ed\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e }],\n  \u003cspan class=\"hljs-attr\"\u003efunction\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"hello\"\u003c/span\u003e; },\n  \u003cspan class=\"hljs-attr\"\u003emap\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e([[\u003cspan class=\"hljs-string\"\u003e\"key1\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"value1\"\u003c/span\u003e], [\u003cspan class=\"hljs-string\"\u003e\"key2\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"value2\"\u003c/span\u003e]]),\n  \u003cspan class=\"hljs-attr\"\u003eset\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]),\n  \u003cspan class=\"hljs-attr\"\u003edate\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e(),\n  \u003cspan class=\"hljs-attr\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"An error occurred\"\u003c/span\u003e),\n  \u003cspan class=\"hljs-attr\"\u003eregex\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/test/i\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003edomNode\u003c/span\u003e: \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리는 testData를 테스트 데이터로 사용할 것입니다.\u003c/p\u003e\n\u003ch1\u003e2.1# JSON.parse와 JSON.stringify\u003c/h1\u003e\n\u003cp\u003e이 기능을 사용하면 객체를 깊이 복제할 수 있지만, 유감스럽게도 데이터 유형의 일부만 복사될 뿐이며, 순환 참조가 있는 객체는 복사할 수 없습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e jsonClone = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(testData))\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(jsonClone)\n} \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"JSON 메서드가 이 데이터를 처리할 수 없습니다\"\u003c/span\u003e)\n}\n\u003cspan class=\"hljs-comment\"\u003e// 출력\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e/*\n{\n  number: 123,\n  string: \"test\",\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }]\n}\n*/\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이미지를 포함한 코드 블록:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'fatfish'\u003c/span\u003e }\n\nobj.\u003cspan class=\"hljs-property\"\u003eobj\u003c/span\u003e = obj\n\u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(obj))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMarkdown 형식으로 변환 된 표:\u003c/p\u003e\n\u003ch1\u003e2.2# lodash.clone\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e대부분의 사람들이 이 선택을 하겠지만 추가적인 npm 패키지를 가져와야 할 수도 있지만 그 가치는 충분히 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e _ = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'lodash'\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e lodashClone = _.\u003cspan class=\"hljs-title function_\"\u003ecloneDeep\u003c/span\u003e(testData)\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(lodashClone)\n\n\u003cspan class=\"hljs-comment\"\u003e/*\n{\n  number: 123,\n  string: \"test\",\n  undefined: undefined,\n  null: null,\n  boolean: true,\n  object: { a: 1, b: { c: 2 } },\n  array: [1, 2, { d: 3 }],\n  function: [Function: function], // 함수 참조는 복사됩니다.\n  map: Map { 'key1' =\u003e 'value1', 'key2' =\u003e 'value2' },\n  set: Set { 1, 2, 3 },\n  date: 2023-05-23T09:00:00.000Z,\n  error: Error: An error occurred,\n  regex: /test/i,\n  domNode: HTMLDivElement {}\n}\n*/\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e3.1# 새로운 API: structuredClone?\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_5.png\"\u003e\n\u003cp\u003emdn에서 가져왔어요!\u003c/p\u003e\n\u003cp\u003e2022년부터 크롬, 파이어폭스 등 다양한 주요 브라우저에서 지원되고 있어요. 우리에게 행운이네요!\u003c/p\u003e\n\u003cp\u003e아직 이 데이터를 사용 중이지만, 먼저 함수와 DOM 유형을 숨기고, 그 이유를 나중에 설명할게요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003econst testData = {\nnumber: 123,\nstring: \"test\",\nundefined: undefined,\nnull: null,\nboolean: true,\nobject: { a: 1, b: { c: 2 } },\narray: [1, 2, { d: 3 }],\n// function: function() { return \"hello\"; },\nmap: new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]),\nset: new Set([1, 2, 3]),\ndate: new Date(),\nerror: new Error(\"An error occurred\"),\nregex: /test/i,\n// domNode: document.createElement(\"div\")\n}\u003c/p\u003e\n\u003cp\u003econst structuredCloneResult = structuredClone(testData)\nconsole.log(structuredCloneResult)\n/*\n{\nnumber: 123,\nstring: \"test\",\nundefined: undefined,\nnull: null,\nboolean: true,\nobject: { a: 1, b: { c: 2 } },\narray: [1, 2, { d: 3 }],\nfunction: undefined, // Functions are not cloned\nmap: Map { 'key1' =\u003e 'value1', 'key2' =\u003e 'value2' },\nset: Set { 1, 2, 3 },\ndate: 2023-05-23T09:00:00.000Z,\nerror: Error: An error occurred,\nregex: /test/i,\ndomNode: undefined // DOM nodes are not cloned\n}\n*/\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_6.png\"\u003e\n\u003cp\u003e우리가 손에 들고 있는 잔을 들어 올려봐요. 이 결과는 축하해야 할 만하네요.\u003c/p\u003e\n\u003ch1\u003e3.2# structuredClone의 장점\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e친구야, structuredClone 함수를 좋아하시나요? 충분히 간단한가요? 네, 그것이 가장 큰 장점이죠.\u003c/p\u003e\n\u003cp\u003e하지만 또 다른 큰 장점이 있습니다. 그것은 심지어 원형 참조가 있는 객체도 복사할 수 있다는 것이죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'fatfish'\u003c/span\u003e }\n\nobj.\u003cspan class=\"hljs-property\"\u003eobj\u003c/span\u003e = obj\n\u003cspan class=\"hljs-title function_\"\u003estructuredClone\u003c/span\u003e(obj)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_7.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e3.3 구조화된 복제의 일부 제한 사항\u003c/h1\u003e\n\u003cp\u003e친구들아, 함께 축배를 건넜지만, 구조화된 복제에는 여전히 몇 가지 제한 사항이 있음을 인정해야 합니다.\u003c/p\u003e\n\u003cp\u003e함수나 Dom을 복사할 수 없습니다. 이를 하려고 시도하면 예외가 발생합니다. 이것이 저가 함수와 Dom을 숨긴 이유입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = { \u003cspan class=\"hljs-attr\"\u003efn\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {} }\n\n\u003cspan class=\"hljs-title function_\"\u003estructuredClone\u003c/span\u003e(obj)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_8.png\"\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = { \u003cspan class=\"hljs-attr\"\u003edomNode\u003c/span\u003e: \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'div'\u003c/span\u003e) }\n\n\u003cspan class=\"hljs-title function_\"\u003estructuredClone\u003c/span\u003e(obj)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript_9.png\"\u003e\n\u003cp\u003e이 함수를 호출할 때 오류가 발생하지 않도록 하고, 메소드를 가진 객체를 깊게 복제하지만 메소드는 복제하지 않기를 원합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e친절한 한국어 번역 🚀\u003c/h1\u003e\n\u003cp\u003eIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작가를 박수 보내고 팔로우하세요 ️👏️️\u003c/li\u003e\n\u003cli\u003e팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\u003c/li\u003e\n\u003cli\u003e다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\u003c/li\u003e\n\u003cli\u003e알고리즘 콘텐츠에 강제로 노출되는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\u003c/li\u003e\n\u003cli\u003ePlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-structuredCloneTheEasiestWaytoDeepCloneObjectsinJavaScript"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>