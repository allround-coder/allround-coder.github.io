<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nextjs에서 Web Worker 활용하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nextjs에서 Web Worker 활용하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Nextjs에서 Web Worker 활용하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs" data-gatsby-head="true"/><meta name="twitter:title" content="Nextjs에서 Web Worker 활용하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 14:28" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nextjs에서 Web Worker 활용하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nextjs에서 Web Worker 활용하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png" alt="2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png"></p>
<p>웹 애플리케이션의 응답성을 유지하는 데 실시간 데이터를 효율적으로 제공하는 것이 중요합니다. 이 게시물은 금융에 관한 것은 아니지만, 암호화폐 가격과 같은 데이터는 급속하게 변동할 수 있기 때문에 Web Worker에 적합한 사용 사례입니다. 이 데이터를 처리하는 기존 방법은 메인 스레드를 지연시킬 수 있어 웹 앱의 반응이 둔해질 수 있습니다. 그러나 Web Worker의 능력을 활용하면 이 데이터 처리를 별도 스레드로 옮겨 UI를 빠르고 반응적으로 유지할 수 있습니다. 이 게시물에서는 Next.js 애플리케이션에서 Web Worker를 사용하여 실시간 암호화폐 데이터를 관리한 방법을 안내합니다. 아래는 UI의 스크린샷입니다.</p>
<p><img src="/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_1.png" alt="2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_1.png"></p>
<h1>웹 워커란 무엇인가</h1>
<div class="content-ad"></div>
<p>간단히 말해서, 웹 워커는 백그라운드 스레드에서 스크립트를 실행할 수 있는 방법을 제공합니다. 워커 스레드는 사용자 인터페이스를 방해하지 않고 작업을 수행할 수 있습니다. 게다가, 주요 JavaScript 스레드로 메시지를 보낼 수 있어서 애플리케이션이 반응성을 유지할 수 있습니다.</p>
<h1>준비 과정: Next.js와 웹 워커</h1>
<p>Next.js는 개발자가 서버 측 렌더링 및 정적 웹 애플리케이션을 만들 수 있도록 하는 React 프레임워크입니다. 저는 Next.js를 업무에서 사용하고 있고 매우 인기가 있기 때문에 Web Workers를 Next.js와 함께 사용하는 방법을 알고 싶었습니다. 특히 극복하고자 했던 어려움은 다음과 같습니다.</p>
<ul>
<li>TypeScript 사용</li>
<li>웹 워커 파일 경로를 모든 컴포넌트에서 사용 가능하게 하기</li>
<li>현재 tsconfig.json 파일을 오염시키지 않거나 모든 파일을 public 디렉토리에 넣지 않기</li>
</ul>
<div class="content-ad"></div>
<h1>빌드 단계</h1>
<p>실제 웹 워커 작업에 들어가기 전에 지루한 작업을 먼저 해보겠습니다. 웹 워커를 런타임에서 사용할 수 있도록 하려면 /public 디렉토리에 저장해야 합니다. public 디렉토리에 대해 간단히 설명하자면 이미지, 폰트, 스크립트, HTML 파일 같은 정적 파일을 브라우저를 통해 직접 액세스해야 하는 경우에 사용됩니다. 이 디렉토리에 위치한 모든 것은 Next.js에서 정적 리소스로 제공됩니다. 이 설정은 몇 가지 보안 고려 사항을 동반합니다. 민감한 사용자 데이터를 피하고 적절한 보안 헤더를 사용하며 이 파일에 API 키를 저장하지 마십시오.</p>
<h1>새로운 tsconfig.json 파일 만들기</h1>
<p>tsconfig.worker.json이라는 새 파일을 생성하여 특정 웹 워커 파일을 /public 디렉토리로 컴파일하기 위해 기존 tsconfig.json을 확장합니다. 동일한 JSON을 기본 구성에 넣으면 컴파일러 옵션 -` outDir가 모든 것을 /public 디렉토리에 넣을 것으로 생각됩니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"extends"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"./tsconfig.json"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"outDir"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">". /public/workers"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ES6"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"noEmit"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"include"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"workers/**/*.ts"</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>이제는 /workers 폴더 안의 모든 파일을 JavaScript로 컴파일하여 /public/workers 디렉토리에 넣어줍니다. 이렇게하면 컴포넌트에서 어디에서든 액세스할 수 있습니다.</p>
<h1>Package.json 업데이트</h1>
<p>package.json 파일에서 스크립트를 업데이트해야합니다. 이렇게하면 worker 파일이 저장될 때마다 빌드됩니다. 제가 일단 빌드를 실행할 수있는 스크립트 명령어를 추가했습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-string">"build:workers"</span>: <span class="hljs-string">"tsc -p tsconfig.worker.json"</span>, 
</code></pre>
<p>이후에는 변경 사항이 발생할 때마다 worker 폴더를 감시하고 저장한 후 빌드하는 명령을 추가했습니다. 이 명령을 개발 명령과 병렬로 실행했습니다. 그러나 모든 작업을 한 번에 수행하도록 개발 명령을 업데이트할 수도 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-string">"watch:workers"</span>: <span class="hljs-string">"tsc -p tsconfig.worker.json --watch"</span>,
<span class="hljs-string">"dev"</span>: <span class="hljs-string">"next dev -H 127.0.0.1 -p 3111"</span>,
</code></pre>
<h1>웹 워커</h1>
<div class="content-ad"></div>
<p>웹 워커는 굉장히 복잡하지 않아요. 사실, 마지막에는 메소드 4개와 속성 2개만 가지고 있어요. 이 메소드들은 워커 내부로 메시지를 보내거나 받기 위해 사용하고, 속성들은 이벤트를 듣기 위해 사용돼요.</p>
<h2>메소드</h2>
<ul>
<li>postMessage(): 워커의 내부 스코프로 메시지를 보냅니다. 어떤 값 또는 자바스크립트 객체든 보낼 수 있지만 함수나 오류 객체는 보낼 수 없어요.</li>
</ul>
<pre><code class="hljs language-js">worker.<span class="hljs-title function_">postMessage</span>(data);
</code></pre>
<div class="content-ad"></div>
<ul>
<li>terminate():
워커를 즉시 종료합니다. 이렇게하면 워커 범위 내의 모든 작업이 중지되며, 모든 네트워크 연결이 해제되며, 모든 리소스가 해제됩니다. <code>terminate()</code>을 호출한 후에는 워커를 다시 시작할 수 없습니다.</li>
</ul>
<pre><code class="hljs language-js">worker.<span class="hljs-title function_">terminate</span>();
</code></pre>
<ul>
<li>addEventListener():
<code>message</code> 및 <code>error</code>와 같은 이벤트를 처리하기 위해 워커에 직접 속성을 설정하는 대신 사용할 수 있는 대체 방법입니다.</li>
</ul>
<pre><code class="hljs language-js">worker.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'message'</span>, handlerFunction);
</code></pre>
<div class="content-ad"></div>
<ul>
<li>removeEventListener():
addEventListener()로 이전에 등록된 이벤트 리스너를 제거합니다.</li>
</ul>
<pre><code class="hljs language-js">worker.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'message'</span>, handlerFunction);
</code></pre>
<h2>속성</h2>
<ul>
<li>onmessage: worker가 <code>postMessage()</code>를 사용하여 메인 스레드로부터 메시지를 수신할 때 호출되는 이벤트 핸들러입니다.</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-js">worker.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) { 
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(event.<span class="hljs-property">data</span>); 
};
</code></pre>
<ul>
<li><strong>onerror</strong>: 설명: 워커에서 오류가 발생했을 때 호출되는 이벤트 핸들러입니다. 이 이벤트 핸들러는 오류에 관한 정보를 포함하는 <code>ErrorEvent</code> 객체를 받을 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js">worker.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(event.<span class="hljs-property">message</span>); };
</code></pre>
<p><code>postMessage</code> 메서드를 사용할 때 직접 'init' 또는 'data'와 같은 메시지 유형을 만들면 구성 및 유연성이 증가할 수 있습니다. 예를 들어 이 프로젝트에서는 페이로드를 웹 워커의 특정 알고리즘으로 연결하기 위한 메시지 유형을 나타내는 TypeScript 유형을 사용했습니다. 'type'이라는 단어를 많이 사용했는데, 예시를 보여드릴까요?</p>
<div class="content-ad"></div>
<p>types.ts</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> type <span class="hljs-title class_">WorkerMessageT</span>&#x3C;T> = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">'init'</span> | <span class="hljs-string">'data'</span> | <span class="hljs-string">'error'</span> | <span class="hljs-string">'stop'</span>
  payload?: {
    id?: string
    <span class="hljs-attr">data</span>: T
  }
}

<span class="hljs-keyword">export</span> type <span class="hljs-title class_">CryptoWorkConfigT</span> = {
  <span class="hljs-attr">assets</span>: string <span class="hljs-comment">// 비트코인, 이더리움, 모네로, 라이트코인</span>
}
</code></pre>
<p>다른 방법으로는 addEventListener()를 활용할 수도 있습니다.</p>
<p>crypto.ts</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">WorkerMessageT</span>, <span class="hljs-title class_">CryptoWorkConfigT</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../types'</span>

<span class="hljs-comment">// 워커의 최상위 범위에서 pricesWs를 정의합니다</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">pricesWs</span>: <span class="hljs-title class_">WebSocket</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>

self.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =></span> {
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BASE_URL</span> = <span class="hljs-string">'wss://ws.coincap.io/prices'</span>
  <span class="hljs-keyword">switch</span> (e.<span class="hljs-property">data</span>.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'init'</span>:
      <span class="hljs-keyword">const</span> <span class="hljs-attr">message</span>: <span class="hljs-title class_">WorkerMessageT</span>&#x3C;<span class="hljs-title class_">CryptoWorkConfigT</span>> = e.<span class="hljs-property">data</span>

      <span class="hljs-comment">// 웹 소켓 연결을 초기화합니다</span>
      pricesWs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(
        <span class="hljs-string">`<span class="hljs-subst">${BASE_URL}</span>?assets=<span class="hljs-subst">${message.payload?.data.assets}</span>`</span>,
      )

      <span class="hljs-keyword">const</span> <span class="hljs-title function_">initSubscription</span> = (<span class="hljs-params"></span>) => {
        pricesWs?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
          self.<span class="hljs-title function_">postMessage</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>))
        })
      }

      <span class="hljs-title function_">initSubscription</span>()

      <span class="hljs-keyword">break</span>

    <span class="hljs-keyword">case</span> <span class="hljs-string">'stop'</span>:
      <span class="hljs-comment">// 열려 있는 웹 소켓을 안전하게 닫습니다</span>
      <span class="hljs-keyword">if</span> (pricesWs) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'WebSocket 연결을 종료합니다...'</span>, pricesWs)
        pricesWs.<span class="hljs-title function_">close</span>()
        pricesWs = <span class="hljs-literal">null</span> <span class="hljs-comment">// 닫은 후에 참조를 지웁니다</span>
      }
      <span class="hljs-keyword">break</span>

    <span class="hljs-keyword">case</span> <span class="hljs-string">'error'</span>:
      <span class="hljs-comment">// 오류 발생 시, 웹 소켓을 닫습니다</span>
      <span class="hljs-keyword">if</span> (pricesWs) {
        pricesWs.<span class="hljs-title function_">close</span>()
        pricesWs = <span class="hljs-literal">null</span> <span class="hljs-comment">// 오류 발생 시 정리합니다</span>
      }
      <span class="hljs-comment">// 여기에 추가적인 오류 처리 로직을 구현할 수 있습니다</span>
      <span class="hljs-keyword">break</span>

    <span class="hljs-attr">default</span>:
      <span class="hljs-comment">// 명시적으로 언급되지 않은 모든 케이스 처리</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'처리되지 않은 메시지 유형:'</span>, e.<span class="hljs-property">data</span>.<span class="hljs-property">type</span>)
  }
}
</code></pre>
<p>먼저 몇 가지 타입을 가져오고, Coincap API와 통신하기 위해 사용할 웹 소켓 변수를 초기화합니다. 그런 다음 첫 번째 웹 워커 메서드 self.onmessage가 나타납니다. 메시지 유형이 즉시 유용하며 적절한 알고리즘으로 이벤트를 분기합니다. 'init' 케이스에서는 수신된 메시지 데이터를 수집하고 Coincap 웹 소켓에 구독합니다. 웹 소켓 이벤트 핸들러에서 postMessage() 메서드를 사용하여 데이터를 전파합니다. 여기까지입니다! 이제 웹 워커와 통신하는 UI로 이동해봅시다.</p>
<p>page.ts</p>
<pre><code class="hljs language-js"><span class="hljs-string">'use client'</span>

<span class="hljs-keyword">import</span> { useEffect, useRef, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Button</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@mozilla/lilypad-ui'</span>
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./page.module.scss'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CryptoWorkConfigT</span>, <span class="hljs-title class_">WorkerMessageT</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'workers/types'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Card</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@Shared/Card/Card'</span>

type <span class="hljs-title class_">CryptoDataT</span> = {
  <span class="hljs-attr">bitcoin</span>: string
  <span class="hljs-attr">ethereum</span>: string
  <span class="hljs-attr">monero</span>: string
  <span class="hljs-attr">litecoin</span>: string
}

<span class="hljs-keyword">const</span> <span class="hljs-title function_">page</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> workerRef = useRef&#x3C;<span class="hljs-title class_">Worker</span>>()
  <span class="hljs-keyword">const</span> initPrice = <span class="hljs-string">'데이터를 기다리는 중...'</span>
  <span class="hljs-keyword">const</span> [status, setStatus] = useState&#x3C;string>(<span class="hljs-string">'중지됨'</span>)
  <span class="hljs-keyword">const</span> [prices, setPrices] = useState&#x3C;<span class="hljs-title class_">CryptoDataT</span>>({
    <span class="hljs-attr">bitcoin</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">ethereum</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">monero</span>: <span class="hljs-string">''</span>,
    <span class="hljs-attr">litecoin</span>: <span class="hljs-string">''</span>,
  })

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    workerRef.<span class="hljs-property">current</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">'/workers/crypto/crypto.js'</span>, {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'module'</span>,
    })
    workerRef.<span class="hljs-property">current</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> {
      <span class="hljs-title function_">setPrices</span>(<span class="hljs-function">(<span class="hljs-params">prev</span>) =></span> {
        <span class="hljs-keyword">const</span> newState = { ...prev, ...event.<span class="hljs-property">data</span> }
        <span class="hljs-keyword">return</span> newState
      })
    }
    workerRef.<span class="hljs-property">current</span>.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'워커 오류:'</span>, error)
    }
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> {
      <span class="hljs-keyword">if</span> (workerRef.<span class="hljs-property">current</span>) {
        workerRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">terminate</span>()
      }
    }
  }, [])

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">startWorker</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-title function_">setStatus</span>(<span class="hljs-string">'실행 중'</span>)

    <span class="hljs-keyword">const</span> <span class="hljs-attr">workerMessage</span>: <span class="hljs-title class_">WorkerMessageT</span>&#x3C;<span class="hljs-title class_">CryptoWorkConfigT</span>> = {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'init'</span>,
      <span class="hljs-attr">payload</span>: {
        <span class="hljs-attr">data</span>: {
          <span class="hljs-attr">assets</span>: <span class="hljs-string">'bitcoin,ethereum,monero,litecoin'</span>,
        },
      },
    }
    <span class="hljs-keyword">if</span> (workerRef.<span class="hljs-property">current</span>) {
      workerRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">postMessage</span>(workerMessage)
    }
  }

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">stopWorker</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-title function_">setStatus</span>(<span class="hljs-string">'중지됨'</span>)
    <span class="hljs-keyword">const</span> <span class="hljs-attr">workerMessage</span>: <span class="hljs-title class_">WorkerMessageT</span>&#x3C;<span class="hljs-title class_">CryptoWorkConfigT</span>> = {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'stop'</span>,
    }
    <span class="hljs-keyword">if</span> (workerRef.<span class="hljs-property">current</span>) {
      workerRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">postMessage</span>(workerMessage)
    }
  }

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">terminateWorker</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-title function_">setStatus</span>(<span class="hljs-string">'종료됨'</span>)
    <span class="hljs-keyword">const</span> <span class="hljs-attr">workerMessage</span>: <span class="hljs-title class_">WorkerMessageT</span>&#x3C;<span class="hljs-title class_">CryptoWorkConfigT</span>> = {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'stop'</span>,
    }
    <span class="hljs-keyword">if</span> (workerRef.<span class="hljs-property">current</span>) {
      workerRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">postMessage</span>(workerMessage)
      workerRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">terminate</span>()
    }
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">section</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.page}</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Card</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"large"</span> <span class="hljs-attr">classProp</span>=<span class="hljs-string">{styles.card}</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"mb-40 gap-12"</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{startWorker}</span> <span class="hljs-attr">text</span>=<span class="hljs-string">"스트림 시작"</span> /></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Button</span>
            <span class="hljs-attr">onClick</span>=<span class="hljs-string">{stopWorker}</span>
            <span class="hljs-attr">text</span>=<span class="hljs-string">"스트림 중지"</span>
            <span class="hljs-attr">category</span>=<span class="hljs-string">"primary_outline"</span>
          /></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Button</span>
            <span class="hljs-attr">icon</span>=<span class="hljs-string">"trash"</span>
            <span class="hljs-attr">onClick</span>=<span class="hljs-string">{terminateWorker}</span>
            <span class="hljs-attr">text</span>=<span class="hljs-string">"워커 종료"</span>
            <span class="hljs-attr">category</span>=<span class="hljs-string">"primary_clear"</span>
          /></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">h2</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"heading-md mb-12"</span>></span>데이터 스트림: {status}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h2</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"mb-40 body-sm"</span>></span>
            이 페이지는 CoinCap.io에서 암호화폐 가격을 스트리밍하는 웹 워커를 사용합니다. "스트림 시작" 버튼을 클릭하면 워커가 시작되고 "스트림 중지" 버튼을 클릭하면 워커가 중지됩니다.
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"gap-12 flex-column"</span>></span>
            {Object.keys(prices).map((key) => {
              const price = prices[key as keyof CryptoDataT]
              return (
                <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{key}</span>></span>
                  <span class="hljs-tag">&#x3C;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"mr-12 capitalize"</span>></span>{key}:<span class="hljs-tag">&#x3C;/<span class="hljs-name">span</span>></span>
                  <span class="hljs-tag">&#x3C;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>`${!<span class="hljs-attr">price</span> &#x26;&#x26; '<span class="hljs-attr">opacity-20</span>'}`}></span>
                    {price ? '$' + price : initPrice}
                  <span class="hljs-tag">&#x3C;/<span class="hljs-name">span</span>></span>
                <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
              )
            })}
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">Card</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">section</span>></span></span>
  )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> page
</code></pre>
<div class="content-ad"></div>
<p>우선, useEffect에서 웹 워커를 생성하고 해당 이벤트를 구독했습니다(JSON 파일 경로는 /public 디렉토리에 컴파일될 파일로 지정해야 합니다). onmessage 이벤트에서 컴포넌트 상태를 업데이트하여 가장 최신의 암호화폐 가격을 반영하도록 했습니다. JSX에서는 웹 워커를 켜는 버튼을 만들었지만, useEffect에서 페이지 로드 시 프로세스를 시작하는 방법도 있습니다.</p>
<p>클릭 핸들러 "startWorker", "stopWorker", "terminateWorker"에 추가 기능이 있습니다. 이 핸들러는 필수 사항은 아니지만 기능을 조직하는 좋은 방법이라고 생각했습니다. 이들의 이름은 수행하는 작업이 명확하지만, 메시지의 "유형"을 잘 고려하면 웹 워커 통신을 더 예측 가능하게 만들 수 있다는 것을 다시 한 번 살펴보시면 더 나은 이해가 될 것입니다.</p>
<h1>결론</h1>
<p>이 예제 이외에도 더 흥미로운 용도로 웹 워커를 사용할 수 있지만, 이 소개가 개념을 파악하는 데 도움이 되었으면 좋겠습니다. 혹시 저와 같이 Next.js에서 웹 워커를 사용하는 데 어려움을 겪었다면, 이것이 적어도 올바른 방향으로 가도록 도움이 될 것입니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nextjs에서 Web Worker 활용하는 방법","description":"","date":"2024-06-22 14:28","slug":"2024-06-22-HarnessingthePowerofWebWorkerswithNextjs","content":"\n\n![2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png](/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png)\n\n웹 애플리케이션의 응답성을 유지하는 데 실시간 데이터를 효율적으로 제공하는 것이 중요합니다. 이 게시물은 금융에 관한 것은 아니지만, 암호화폐 가격과 같은 데이터는 급속하게 변동할 수 있기 때문에 Web Worker에 적합한 사용 사례입니다. 이 데이터를 처리하는 기존 방법은 메인 스레드를 지연시킬 수 있어 웹 앱의 반응이 둔해질 수 있습니다. 그러나 Web Worker의 능력을 활용하면 이 데이터 처리를 별도 스레드로 옮겨 UI를 빠르고 반응적으로 유지할 수 있습니다. 이 게시물에서는 Next.js 애플리케이션에서 Web Worker를 사용하여 실시간 암호화폐 데이터를 관리한 방법을 안내합니다. 아래는 UI의 스크린샷입니다.\n\n![2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_1.png](/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_1.png)\n\n# 웹 워커란 무엇인가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단히 말해서, 웹 워커는 백그라운드 스레드에서 스크립트를 실행할 수 있는 방법을 제공합니다. 워커 스레드는 사용자 인터페이스를 방해하지 않고 작업을 수행할 수 있습니다. 게다가, 주요 JavaScript 스레드로 메시지를 보낼 수 있어서 애플리케이션이 반응성을 유지할 수 있습니다.\n\n# 준비 과정: Next.js와 웹 워커\n\nNext.js는 개발자가 서버 측 렌더링 및 정적 웹 애플리케이션을 만들 수 있도록 하는 React 프레임워크입니다. 저는 Next.js를 업무에서 사용하고 있고 매우 인기가 있기 때문에 Web Workers를 Next.js와 함께 사용하는 방법을 알고 싶었습니다. 특히 극복하고자 했던 어려움은 다음과 같습니다.\n\n- TypeScript 사용\n- 웹 워커 파일 경로를 모든 컴포넌트에서 사용 가능하게 하기\n- 현재 tsconfig.json 파일을 오염시키지 않거나 모든 파일을 public 디렉토리에 넣지 않기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 빌드 단계\n\n실제 웹 워커 작업에 들어가기 전에 지루한 작업을 먼저 해보겠습니다. 웹 워커를 런타임에서 사용할 수 있도록 하려면 /public 디렉토리에 저장해야 합니다. public 디렉토리에 대해 간단히 설명하자면 이미지, 폰트, 스크립트, HTML 파일 같은 정적 파일을 브라우저를 통해 직접 액세스해야 하는 경우에 사용됩니다. 이 디렉토리에 위치한 모든 것은 Next.js에서 정적 리소스로 제공됩니다. 이 설정은 몇 가지 보안 고려 사항을 동반합니다. 민감한 사용자 데이터를 피하고 적절한 보안 헤더를 사용하며 이 파일에 API 키를 저장하지 마십시오.\n\n# 새로운 tsconfig.json 파일 만들기\n\ntsconfig.worker.json이라는 새 파일을 생성하여 특정 웹 워커 파일을 /public 디렉토리로 컴파일하기 위해 기존 tsconfig.json을 확장합니다. 동일한 JSON을 기본 구성에 넣으면 컴파일러 옵션 -` outDir가 모든 것을 /public 디렉토리에 넣을 것으로 생각됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \". /public/workers\",\n    \"module\": \"ES6\",\n    \"noEmit\": false\n  },\n  \"include\": [\"workers/**/*.ts\"]\n}\n```\n\n이제는 /workers 폴더 안의 모든 파일을 JavaScript로 컴파일하여 /public/workers 디렉토리에 넣어줍니다. 이렇게하면 컴포넌트에서 어디에서든 액세스할 수 있습니다.\n\n# Package.json 업데이트\n\npackage.json 파일에서 스크립트를 업데이트해야합니다. 이렇게하면 worker 파일이 저장될 때마다 빌드됩니다. 제가 일단 빌드를 실행할 수있는 스크립트 명령어를 추가했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\"build:workers\": \"tsc -p tsconfig.worker.json\", \n```\n\n이후에는 변경 사항이 발생할 때마다 worker 폴더를 감시하고 저장한 후 빌드하는 명령을 추가했습니다. 이 명령을 개발 명령과 병렬로 실행했습니다. 그러나 모든 작업을 한 번에 수행하도록 개발 명령을 업데이트할 수도 있습니다.\n\n```js\n\"watch:workers\": \"tsc -p tsconfig.worker.json --watch\",\n\"dev\": \"next dev -H 127.0.0.1 -p 3111\",\n```\n\n# 웹 워커\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 워커는 굉장히 복잡하지 않아요. 사실, 마지막에는 메소드 4개와 속성 2개만 가지고 있어요. 이 메소드들은 워커 내부로 메시지를 보내거나 받기 위해 사용하고, 속성들은 이벤트를 듣기 위해 사용돼요.\n\n## 메소드\n\n- postMessage(): 워커의 내부 스코프로 메시지를 보냅니다. 어떤 값 또는 자바스크립트 객체든 보낼 수 있지만 함수나 오류 객체는 보낼 수 없어요.\n\n```js\nworker.postMessage(data);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- terminate():\n    워커를 즉시 종료합니다. 이렇게하면 워커 범위 내의 모든 작업이 중지되며, 모든 네트워크 연결이 해제되며, 모든 리소스가 해제됩니다. `terminate()`을 호출한 후에는 워커를 다시 시작할 수 없습니다.\n\n```js\nworker.terminate();\n```\n\n- addEventListener():\n    `message` 및 `error`와 같은 이벤트를 처리하기 위해 워커에 직접 속성을 설정하는 대신 사용할 수 있는 대체 방법입니다.\n\n```js\nworker.addEventListener('message', handlerFunction);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- removeEventListener():\naddEventListener()로 이전에 등록된 이벤트 리스너를 제거합니다.\n\n```js\nworker.removeEventListener('message', handlerFunction);\n```\n\n## 속성\n\n- onmessage: worker가 `postMessage()`를 사용하여 메인 스레드로부터 메시지를 수신할 때 호출되는 이벤트 핸들러입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js \nworker.onmessage = function(event) { \n  console.log(event.data); \n};\n```\n\n- **onerror**: 설명: 워커에서 오류가 발생했을 때 호출되는 이벤트 핸들러입니다. 이 이벤트 핸들러는 오류에 관한 정보를 포함하는 `ErrorEvent` 객체를 받을 수 있습니다.\n\n```js\nworker.onerror = function(event) { console.error(event.message); };\n```\n\n`postMessage` 메서드를 사용할 때 직접 'init' 또는 'data'와 같은 메시지 유형을 만들면 구성 및 유연성이 증가할 수 있습니다. 예를 들어 이 프로젝트에서는 페이로드를 웹 워커의 특정 알고리즘으로 연결하기 위한 메시지 유형을 나타내는 TypeScript 유형을 사용했습니다. 'type'이라는 단어를 많이 사용했는데, 예시를 보여드릴까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ntypes.ts\n\n```js\nexport type WorkerMessageT\u003cT\u003e = {\n  type: 'init' | 'data' | 'error' | 'stop'\n  payload?: {\n    id?: string\n    data: T\n  }\n}\n\nexport type CryptoWorkConfigT = {\n  assets: string // 비트코인, 이더리움, 모네로, 라이트코인\n}\n```\n\n다른 방법으로는 addEventListener()를 활용할 수도 있습니다.\n\ncrypto.ts\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { WorkerMessageT, CryptoWorkConfigT } from '../types'\n\n// 워커의 최상위 범위에서 pricesWs를 정의합니다\nlet pricesWs: WebSocket | null = null\n\nself.onmessage = (e) =\u003e {\n  const BASE_URL = 'wss://ws.coincap.io/prices'\n  switch (e.data.type) {\n    case 'init':\n      const message: WorkerMessageT\u003cCryptoWorkConfigT\u003e = e.data\n\n      // 웹 소켓 연결을 초기화합니다\n      pricesWs = new WebSocket(\n        `${BASE_URL}?assets=${message.payload?.data.assets}`,\n      )\n\n      const initSubscription = () =\u003e {\n        pricesWs?.addEventListener('message', function (event) {\n          self.postMessage(JSON.parse(event.data))\n        })\n      }\n\n      initSubscription()\n\n      break\n\n    case 'stop':\n      // 열려 있는 웹 소켓을 안전하게 닫습니다\n      if (pricesWs) {\n        console.log('WebSocket 연결을 종료합니다...', pricesWs)\n        pricesWs.close()\n        pricesWs = null // 닫은 후에 참조를 지웁니다\n      }\n      break\n\n    case 'error':\n      // 오류 발생 시, 웹 소켓을 닫습니다\n      if (pricesWs) {\n        pricesWs.close()\n        pricesWs = null // 오류 발생 시 정리합니다\n      }\n      // 여기에 추가적인 오류 처리 로직을 구현할 수 있습니다\n      break\n\n    default:\n      // 명시적으로 언급되지 않은 모든 케이스 처리\n      console.error('처리되지 않은 메시지 유형:', e.data.type)\n  }\n}\n```\n\n먼저 몇 가지 타입을 가져오고, Coincap API와 통신하기 위해 사용할 웹 소켓 변수를 초기화합니다. 그런 다음 첫 번째 웹 워커 메서드 self.onmessage가 나타납니다. 메시지 유형이 즉시 유용하며 적절한 알고리즘으로 이벤트를 분기합니다. 'init' 케이스에서는 수신된 메시지 데이터를 수집하고 Coincap 웹 소켓에 구독합니다. 웹 소켓 이벤트 핸들러에서 postMessage() 메서드를 사용하여 데이터를 전파합니다. 여기까지입니다! 이제 웹 워커와 통신하는 UI로 이동해봅시다.\n\npage.ts\n\n```js\n'use client'\n\nimport { useEffect, useRef, useState } from 'react'\nimport { Button } from '@mozilla/lilypad-ui'\nimport styles from './page.module.scss'\nimport { CryptoWorkConfigT, WorkerMessageT } from 'workers/types'\nimport Card from '@Shared/Card/Card'\n\ntype CryptoDataT = {\n  bitcoin: string\n  ethereum: string\n  monero: string\n  litecoin: string\n}\n\nconst page = () =\u003e {\n  const workerRef = useRef\u003cWorker\u003e()\n  const initPrice = '데이터를 기다리는 중...'\n  const [status, setStatus] = useState\u003cstring\u003e('중지됨')\n  const [prices, setPrices] = useState\u003cCryptoDataT\u003e({\n    bitcoin: '',\n    ethereum: '',\n    monero: '',\n    litecoin: '',\n  })\n\n  useEffect(() =\u003e {\n    workerRef.current = new Worker('/workers/crypto/crypto.js', {\n      type: 'module',\n    })\n    workerRef.current.onmessage = (event) =\u003e {\n      setPrices((prev) =\u003e {\n        const newState = { ...prev, ...event.data }\n        return newState\n      })\n    }\n    workerRef.current.onerror = (error) =\u003e {\n      console.error('워커 오류:', error)\n    }\n    return () =\u003e {\n      if (workerRef.current) {\n        workerRef.current.terminate()\n      }\n    }\n  }, [])\n\n  const startWorker = () =\u003e {\n    setStatus('실행 중')\n\n    const workerMessage: WorkerMessageT\u003cCryptoWorkConfigT\u003e = {\n      type: 'init',\n      payload: {\n        data: {\n          assets: 'bitcoin,ethereum,monero,litecoin',\n        },\n      },\n    }\n    if (workerRef.current) {\n      workerRef.current.postMessage(workerMessage)\n    }\n  }\n\n  const stopWorker = () =\u003e {\n    setStatus('중지됨')\n    const workerMessage: WorkerMessageT\u003cCryptoWorkConfigT\u003e = {\n      type: 'stop',\n    }\n    if (workerRef.current) {\n      workerRef.current.postMessage(workerMessage)\n    }\n  }\n\n  const terminateWorker = () =\u003e {\n    setStatus('종료됨')\n    const workerMessage: WorkerMessageT\u003cCryptoWorkConfigT\u003e = {\n      type: 'stop',\n    }\n    if (workerRef.current) {\n      workerRef.current.postMessage(workerMessage)\n      workerRef.current.terminate()\n    }\n  }\n\n  return (\n    \u003csection className={styles.page}\u003e\n      \u003cCard size=\"large\" classProp={styles.card}\u003e\n        \u003cdiv className=\"mb-40 gap-12\"\u003e\n          \u003cButton onClick={startWorker} text=\"스트림 시작\" /\u003e\n          \u003cButton\n            onClick={stopWorker}\n            text=\"스트림 중지\"\n            category=\"primary_outline\"\n          /\u003e\n          \u003cButton\n            icon=\"trash\"\n            onClick={terminateWorker}\n            text=\"워커 종료\"\n            category=\"primary_clear\"\n          /\u003e\n        \u003c/div\u003e\n        \u003cdiv\u003e\n          \u003ch2 className=\"heading-md mb-12\"\u003e데이터 스트림: {status}\u003c/h2\u003e\n          \u003cp className=\"mb-40 body-sm\"\u003e\n            이 페이지는 CoinCap.io에서 암호화폐 가격을 스트리밍하는 웹 워커를 사용합니다. \"스트림 시작\" 버튼을 클릭하면 워커가 시작되고 \"스트림 중지\" 버튼을 클릭하면 워커가 중지됩니다.\n          \u003c/p\u003e\n          \u003cdiv className=\"gap-12 flex-column\"\u003e\n            {Object.keys(prices).map((key) =\u003e {\n              const price = prices[key as keyof CryptoDataT]\n              return (\n                \u003cdiv key={key}\u003e\n                  \u003cspan className=\"mr-12 capitalize\"\u003e{key}:\u003c/span\u003e\n                  \u003cspan className={`${!price \u0026\u0026 'opacity-20'}`}\u003e\n                    {price ? '$' + price : initPrice}\n                  \u003c/span\u003e\n                \u003c/div\u003e\n              )\n            })}\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/Card\u003e\n    \u003c/section\u003e\n  )\n}\n\nexport default page\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선, useEffect에서 웹 워커를 생성하고 해당 이벤트를 구독했습니다(JSON 파일 경로는 /public 디렉토리에 컴파일될 파일로 지정해야 합니다). onmessage 이벤트에서 컴포넌트 상태를 업데이트하여 가장 최신의 암호화폐 가격을 반영하도록 했습니다. JSX에서는 웹 워커를 켜는 버튼을 만들었지만, useEffect에서 페이지 로드 시 프로세스를 시작하는 방법도 있습니다.\n\n클릭 핸들러 \"startWorker\", \"stopWorker\", \"terminateWorker\"에 추가 기능이 있습니다. 이 핸들러는 필수 사항은 아니지만 기능을 조직하는 좋은 방법이라고 생각했습니다. 이들의 이름은 수행하는 작업이 명확하지만, 메시지의 \"유형\"을 잘 고려하면 웹 워커 통신을 더 예측 가능하게 만들 수 있다는 것을 다시 한 번 살펴보시면 더 나은 이해가 될 것입니다.\n\n# 결론\n\n이 예제 이외에도 더 흥미로운 용도로 웹 워커를 사용할 수 있지만, 이 소개가 개념을 파악하는 데 도움이 되었으면 좋겠습니다. 혹시 저와 같이 Next.js에서 웹 워커를 사용하는 데 어려움을 겪었다면, 이것이 적어도 올바른 방향으로 가도록 도움이 될 것입니다.","ogImage":{"url":"/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png"},"coverImage":"/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png\" alt=\"2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_0.png\"\u003e\u003c/p\u003e\n\u003cp\u003e웹 애플리케이션의 응답성을 유지하는 데 실시간 데이터를 효율적으로 제공하는 것이 중요합니다. 이 게시물은 금융에 관한 것은 아니지만, 암호화폐 가격과 같은 데이터는 급속하게 변동할 수 있기 때문에 Web Worker에 적합한 사용 사례입니다. 이 데이터를 처리하는 기존 방법은 메인 스레드를 지연시킬 수 있어 웹 앱의 반응이 둔해질 수 있습니다. 그러나 Web Worker의 능력을 활용하면 이 데이터 처리를 별도 스레드로 옮겨 UI를 빠르고 반응적으로 유지할 수 있습니다. 이 게시물에서는 Next.js 애플리케이션에서 Web Worker를 사용하여 실시간 암호화폐 데이터를 관리한 방법을 안내합니다. 아래는 UI의 스크린샷입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_1.png\" alt=\"2024-06-22-HarnessingthePowerofWebWorkerswithNextjs_1.png\"\u003e\u003c/p\u003e\n\u003ch1\u003e웹 워커란 무엇인가\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e간단히 말해서, 웹 워커는 백그라운드 스레드에서 스크립트를 실행할 수 있는 방법을 제공합니다. 워커 스레드는 사용자 인터페이스를 방해하지 않고 작업을 수행할 수 있습니다. 게다가, 주요 JavaScript 스레드로 메시지를 보낼 수 있어서 애플리케이션이 반응성을 유지할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e준비 과정: Next.js와 웹 워커\u003c/h1\u003e\n\u003cp\u003eNext.js는 개발자가 서버 측 렌더링 및 정적 웹 애플리케이션을 만들 수 있도록 하는 React 프레임워크입니다. 저는 Next.js를 업무에서 사용하고 있고 매우 인기가 있기 때문에 Web Workers를 Next.js와 함께 사용하는 방법을 알고 싶었습니다. 특히 극복하고자 했던 어려움은 다음과 같습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTypeScript 사용\u003c/li\u003e\n\u003cli\u003e웹 워커 파일 경로를 모든 컴포넌트에서 사용 가능하게 하기\u003c/li\u003e\n\u003cli\u003e현재 tsconfig.json 파일을 오염시키지 않거나 모든 파일을 public 디렉토리에 넣지 않기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e빌드 단계\u003c/h1\u003e\n\u003cp\u003e실제 웹 워커 작업에 들어가기 전에 지루한 작업을 먼저 해보겠습니다. 웹 워커를 런타임에서 사용할 수 있도록 하려면 /public 디렉토리에 저장해야 합니다. public 디렉토리에 대해 간단히 설명하자면 이미지, 폰트, 스크립트, HTML 파일 같은 정적 파일을 브라우저를 통해 직접 액세스해야 하는 경우에 사용됩니다. 이 디렉토리에 위치한 모든 것은 Next.js에서 정적 리소스로 제공됩니다. 이 설정은 몇 가지 보안 고려 사항을 동반합니다. 민감한 사용자 데이터를 피하고 적절한 보안 헤더를 사용하며 이 파일에 API 키를 저장하지 마십시오.\u003c/p\u003e\n\u003ch1\u003e새로운 tsconfig.json 파일 만들기\u003c/h1\u003e\n\u003cp\u003etsconfig.worker.json이라는 새 파일을 생성하여 특정 웹 워커 파일을 /public 디렉토리로 컴파일하기 위해 기존 tsconfig.json을 확장합니다. 동일한 JSON을 기본 구성에 넣으면 컴파일러 옵션 -` outDir가 모든 것을 /public 디렉토리에 넣을 것으로 생각됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e\u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"extends\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./tsconfig.json\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"compilerOptions\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"outDir\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\". /public/workers\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"module\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ES6\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"noEmit\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003efalse\u003c/span\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"include\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"workers/**/*.ts\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\n\u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제는 /workers 폴더 안의 모든 파일을 JavaScript로 컴파일하여 /public/workers 디렉토리에 넣어줍니다. 이렇게하면 컴포넌트에서 어디에서든 액세스할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003ePackage.json 업데이트\u003c/h1\u003e\n\u003cp\u003epackage.json 파일에서 스크립트를 업데이트해야합니다. 이렇게하면 worker 파일이 저장될 때마다 빌드됩니다. 제가 일단 빌드를 실행할 수있는 스크립트 명령어를 추가했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"build:workers\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"tsc -p tsconfig.worker.json\"\u003c/span\u003e, \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이후에는 변경 사항이 발생할 때마다 worker 폴더를 감시하고 저장한 후 빌드하는 명령을 추가했습니다. 이 명령을 개발 명령과 병렬로 실행했습니다. 그러나 모든 작업을 한 번에 수행하도록 개발 명령을 업데이트할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"watch:workers\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"tsc -p tsconfig.worker.json --watch\"\u003c/span\u003e,\n\u003cspan class=\"hljs-string\"\u003e\"dev\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"next dev -H 127.0.0.1 -p 3111\"\u003c/span\u003e,\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e웹 워커\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e웹 워커는 굉장히 복잡하지 않아요. 사실, 마지막에는 메소드 4개와 속성 2개만 가지고 있어요. 이 메소드들은 워커 내부로 메시지를 보내거나 받기 위해 사용하고, 속성들은 이벤트를 듣기 위해 사용돼요.\u003c/p\u003e\n\u003ch2\u003e메소드\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003epostMessage(): 워커의 내부 스코프로 메시지를 보냅니다. 어떤 값 또는 자바스크립트 객체든 보낼 수 있지만 함수나 오류 객체는 보낼 수 없어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eworker.\u003cspan class=\"hljs-title function_\"\u003epostMessage\u003c/span\u003e(data);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eterminate():\n워커를 즉시 종료합니다. 이렇게하면 워커 범위 내의 모든 작업이 중지되며, 모든 네트워크 연결이 해제되며, 모든 리소스가 해제됩니다. \u003ccode\u003eterminate()\u003c/code\u003e을 호출한 후에는 워커를 다시 시작할 수 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eworker.\u003cspan class=\"hljs-title function_\"\u003eterminate\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eaddEventListener():\n\u003ccode\u003emessage\u003c/code\u003e 및 \u003ccode\u003eerror\u003c/code\u003e와 같은 이벤트를 처리하기 위해 워커에 직접 속성을 설정하는 대신 사용할 수 있는 대체 방법입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eworker.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e, handlerFunction);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eremoveEventListener():\naddEventListener()로 이전에 등록된 이벤트 리스너를 제거합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eworker.\u003cspan class=\"hljs-title function_\"\u003eremoveEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e, handlerFunction);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e속성\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eonmessage: worker가 \u003ccode\u003epostMessage()\u003c/code\u003e를 사용하여 메인 스레드로부터 메시지를 수신할 때 호출되는 이벤트 핸들러입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eworker.\u003cspan class=\"hljs-property\"\u003eonmessage\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) { \n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(event.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e); \n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eonerror\u003c/strong\u003e: 설명: 워커에서 오류가 발생했을 때 호출되는 이벤트 핸들러입니다. 이 이벤트 핸들러는 오류에 관한 정보를 포함하는 \u003ccode\u003eErrorEvent\u003c/code\u003e 객체를 받을 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eworker.\u003cspan class=\"hljs-property\"\u003eonerror\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) { \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(event.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e); };\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epostMessage\u003c/code\u003e 메서드를 사용할 때 직접 'init' 또는 'data'와 같은 메시지 유형을 만들면 구성 및 유연성이 증가할 수 있습니다. 예를 들어 이 프로젝트에서는 페이로드를 웹 워커의 특정 알고리즘으로 연결하기 위한 메시지 유형을 나타내는 TypeScript 유형을 사용했습니다. 'type'이라는 단어를 많이 사용했는데, 예시를 보여드릴까요?\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003etypes.ts\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e type \u003cspan class=\"hljs-title class_\"\u003eWorkerMessageT\u003c/span\u003e\u0026#x3C;T\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'init'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'data'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'error'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'stop'\u003c/span\u003e\n  payload?: {\n    id?: string\n    \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: T\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e type \u003cspan class=\"hljs-title class_\"\u003eCryptoWorkConfigT\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eassets\u003c/span\u003e: string \u003cspan class=\"hljs-comment\"\u003e// 비트코인, 이더리움, 모네로, 라이트코인\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 방법으로는 addEventListener()를 활용할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003ecrypto.ts\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eWorkerMessageT\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eCryptoWorkConfigT\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'../types'\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 워커의 최상위 범위에서 pricesWs를 정의합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epricesWs\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eWebSocket\u003c/span\u003e | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\n\nself.\u003cspan class=\"hljs-property\"\u003eonmessage\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBASE_URL\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'wss://ws.coincap.io/prices'\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'init'\u003c/span\u003e:\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eWorkerMessageT\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eCryptoWorkConfigT\u003c/span\u003e\u003e = e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e\n\n      \u003cspan class=\"hljs-comment\"\u003e// 웹 소켓 연결을 초기화합니다\u003c/span\u003e\n      pricesWs = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWebSocket\u003c/span\u003e(\n        \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${BASE_URL}\u003c/span\u003e?assets=\u003cspan class=\"hljs-subst\"\u003e${message.payload?.data.assets}\u003c/span\u003e`\u003c/span\u003e,\n      )\n\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitSubscription\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n        pricesWs?.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) {\n          self.\u003cspan class=\"hljs-title function_\"\u003epostMessage\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(event.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e))\n        })\n      }\n\n      \u003cspan class=\"hljs-title function_\"\u003einitSubscription\u003c/span\u003e()\n\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'stop'\u003c/span\u003e:\n      \u003cspan class=\"hljs-comment\"\u003e// 열려 있는 웹 소켓을 안전하게 닫습니다\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (pricesWs) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'WebSocket 연결을 종료합니다...'\u003c/span\u003e, pricesWs)\n        pricesWs.\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e()\n        pricesWs = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 닫은 후에 참조를 지웁니다\u003c/span\u003e\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'error'\u003c/span\u003e:\n      \u003cspan class=\"hljs-comment\"\u003e// 오류 발생 시, 웹 소켓을 닫습니다\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (pricesWs) {\n        pricesWs.\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e()\n        pricesWs = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 오류 발생 시 정리합니다\u003c/span\u003e\n      }\n      \u003cspan class=\"hljs-comment\"\u003e// 여기에 추가적인 오류 처리 로직을 구현할 수 있습니다\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n\n    \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e:\n      \u003cspan class=\"hljs-comment\"\u003e// 명시적으로 언급되지 않은 모든 케이스 처리\u003c/span\u003e\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'처리되지 않은 메시지 유형:'\u003c/span\u003e, e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저 몇 가지 타입을 가져오고, Coincap API와 통신하기 위해 사용할 웹 소켓 변수를 초기화합니다. 그런 다음 첫 번째 웹 워커 메서드 self.onmessage가 나타납니다. 메시지 유형이 즉시 유용하며 적절한 알고리즘으로 이벤트를 분기합니다. 'init' 케이스에서는 수신된 메시지 데이터를 수집하고 Coincap 웹 소켓에 구독합니다. 웹 소켓 이벤트 핸들러에서 postMessage() 메서드를 사용하여 데이터를 전파합니다. 여기까지입니다! 이제 웹 워커와 통신하는 UI로 이동해봅시다.\u003c/p\u003e\n\u003cp\u003epage.ts\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e'use client'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useEffect, useRef, useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@mozilla/lilypad-ui'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e styles \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./page.module.scss'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eCryptoWorkConfigT\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eWorkerMessageT\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'workers/types'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCard\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@Shared/Card/Card'\u003c/span\u003e\n\ntype \u003cspan class=\"hljs-title class_\"\u003eCryptoDataT\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003ebitcoin\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003eethereum\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003emonero\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003elitecoin\u003c/span\u003e: string\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epage\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e workerRef = useRef\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e\u003e()\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e initPrice = \u003cspan class=\"hljs-string\"\u003e'데이터를 기다리는 중...'\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [status, setStatus] = useState\u0026#x3C;string\u003e(\u003cspan class=\"hljs-string\"\u003e'중지됨'\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [prices, setPrices] = useState\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eCryptoDataT\u003c/span\u003e\u003e({\n    \u003cspan class=\"hljs-attr\"\u003ebitcoin\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eethereum\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003emonero\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003elitecoin\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n  })\n\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    workerRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/workers/crypto/crypto.js'\u003c/span\u003e, {\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'module'\u003c/span\u003e,\n    })\n    workerRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eonmessage\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-title function_\"\u003esetPrices\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprev\u003c/span\u003e) =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newState = { ...prev, ...event.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e }\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e newState\n      })\n    }\n    workerRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eonerror\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'워커 오류:'\u003c/span\u003e, error)\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (workerRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e) {\n        workerRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eterminate\u003c/span\u003e()\n      }\n    }\n  }, [])\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003estartWorker\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetStatus\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'실행 중'\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eworkerMessage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eWorkerMessageT\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eCryptoWorkConfigT\u003c/span\u003e\u003e = {\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'init'\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003epayload\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003eassets\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'bitcoin,ethereum,monero,litecoin'\u003c/span\u003e,\n        },\n      },\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (workerRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e) {\n      workerRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epostMessage\u003c/span\u003e(workerMessage)\n    }\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003estopWorker\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetStatus\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'중지됨'\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eworkerMessage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eWorkerMessageT\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eCryptoWorkConfigT\u003c/span\u003e\u003e = {\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'stop'\u003c/span\u003e,\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (workerRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e) {\n      workerRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epostMessage\u003c/span\u003e(workerMessage)\n    }\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eterminateWorker\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetStatus\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'종료됨'\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eworkerMessage\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eWorkerMessageT\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eCryptoWorkConfigT\u003c/span\u003e\u003e = {\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'stop'\u003c/span\u003e,\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (workerRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e) {\n      workerRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epostMessage\u003c/span\u003e(workerMessage)\n      workerRef.\u003cspan class=\"hljs-property\"\u003ecurrent\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eterminate\u003c/span\u003e()\n    }\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003esection\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.page}\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eCard\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esize\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"large\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassProp\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.card}\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"mb-40 gap-12\"\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{startWorker}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"스트림 시작\"\u003c/span\u003e /\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{stopWorker}\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"스트림 중지\"\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003ecategory\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"primary_outline\"\u003c/span\u003e\n          /\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003eicon\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"trash\"\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{terminateWorker}\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"워커 종료\"\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003ecategory\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"primary_clear\"\u003c/span\u003e\n          /\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh2\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"heading-md mb-12\"\u003c/span\u003e\u003e\u003c/span\u003e데이터 스트림: {status}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh2\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"mb-40 body-sm\"\u003c/span\u003e\u003e\u003c/span\u003e\n            이 페이지는 CoinCap.io에서 암호화폐 가격을 스트리밍하는 웹 워커를 사용합니다. \"스트림 시작\" 버튼을 클릭하면 워커가 시작되고 \"스트림 중지\" 버튼을 클릭하면 워커가 중지됩니다.\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"gap-12 flex-column\"\u003c/span\u003e\u003e\u003c/span\u003e\n            {Object.keys(prices).map((key) =\u003e {\n              const price = prices[key as keyof CryptoDataT]\n              return (\n                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{key}\u003c/span\u003e\u003e\u003c/span\u003e\n                  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"mr-12 capitalize\"\u003c/span\u003e\u003e\u003c/span\u003e{key}:\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u003e\u003c/span\u003e\n                  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e`${!\u003cspan class=\"hljs-attr\"\u003eprice\u003c/span\u003e \u0026#x26;\u0026#x26; '\u003cspan class=\"hljs-attr\"\u003eopacity-20\u003c/span\u003e'}`}\u003e\u003c/span\u003e\n                    {price ? '$' + price : initPrice}\n                  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u003e\u003c/span\u003e\n                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n              )\n            })}\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eCard\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003esection\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  )\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e page\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우선, useEffect에서 웹 워커를 생성하고 해당 이벤트를 구독했습니다(JSON 파일 경로는 /public 디렉토리에 컴파일될 파일로 지정해야 합니다). onmessage 이벤트에서 컴포넌트 상태를 업데이트하여 가장 최신의 암호화폐 가격을 반영하도록 했습니다. JSX에서는 웹 워커를 켜는 버튼을 만들었지만, useEffect에서 페이지 로드 시 프로세스를 시작하는 방법도 있습니다.\u003c/p\u003e\n\u003cp\u003e클릭 핸들러 \"startWorker\", \"stopWorker\", \"terminateWorker\"에 추가 기능이 있습니다. 이 핸들러는 필수 사항은 아니지만 기능을 조직하는 좋은 방법이라고 생각했습니다. 이들의 이름은 수행하는 작업이 명확하지만, 메시지의 \"유형\"을 잘 고려하면 웹 워커 통신을 더 예측 가능하게 만들 수 있다는 것을 다시 한 번 살펴보시면 더 나은 이해가 될 것입니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 예제 이외에도 더 흥미로운 용도로 웹 워커를 사용할 수 있지만, 이 소개가 개념을 파악하는 데 도움이 되었으면 좋겠습니다. 혹시 저와 같이 Next.js에서 웹 워커를 사용하는 데 어려움을 겪었다면, 이것이 적어도 올바른 방향으로 가도록 도움이 될 것입니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-HarnessingthePowerofWebWorkerswithNextjs"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>