<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow" data-gatsby-head="true"/><meta name="twitter:title" content="모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 05:16" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">21<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png">
<p>자바스크립트는 현대 웹 개발에서 필수적인 다목적 강력한 언어입니다. 이 글에서는 여러분을 더 효율적이고 효과적인 자바스크립트 개발자로 만들어 줄 수 있는 슈퍼 해킹 기술들을 소개하고 각각에 대한 상세한 설명과 예제를 제공합니다.</p>
<h2>1. <code>var</code> 대신 <code>let</code> 및 <code>const</code> 사용하기</h2>
<p>문제: <code>var</code>은 함수 범위를 가지고 있어서 버그와 예상치 못한 동작을 유발할 수 있습니다.</p>
<div class="content-ad"></div>
<p>해결책: 블록 스코프를 갖는 <code>let</code>과 <code>const</code>를 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PI</span> = <span class="hljs-number">3.14</span>;
</code></pre>
<p><code>let</code>과 <code>const</code>를 사용하면 변수를 정의된 블록 내에서만 접근할 수 있도록 하여 스코프 관련 버그를 방지할 수 있습니다.</p>
<h2>2. 기본 매개변수</h2>
<div class="content-ad"></div>
<p>문제: 인수가 제공되지 않으면 함수가 실패할 수 있습니다.</p>
<p>해결책: 기본 매개변수를 사용하여 대안 값 설정.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name = <span class="hljs-string">'방문자'</span></span>) {
<span class="hljs-keyword">return</span> <span class="hljs-string">`안녕하세요, <span class="hljs-subst">${name}</span>님!`</span>;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">greet</span>()); <span class="hljs-comment">// "안녕하세요, 방문자님!"</span>
</code></pre>
<p>기본 매개변수를 사용하면 함수가 합리적인 기본값을 갖도록되어 오류를 방지하고 코드를 더 견고하게 만듭니다.</p>
<div class="content-ad"></div>
<h2>3. 템플릿 리터럴</h2>
<p>문제: 문자열 연결은 번거로우며 오류가 발생하기 쉽습니다.</p>
<p>해결책: 더 깔끔하고 가독성이 좋은 문자열 보간을 위해 템플릿 리터럴을 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">'John'</span>;
<span class="hljs-keyword">const</span> greeting = <span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>!`</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting); <span class="hljs-comment">// "Hello, John!"</span>
</code></pre>
<div class="content-ad"></div>
<p>템플릿 리터럴을 사용하면 포함된 표현식과 여러 줄의 문자열을 쉽게 만들 수 있어요.</p>
<h2>4. 비구조화 할당</h2>
<p>문제: 객체와 배열에서 값 추출하는 과정이 장황할 수 있어요.</p>
<p>해결책: 비구조화 할당을 사용해서 값을 더 간결하게 추출하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Jane'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };
<span class="hljs-keyword">const</span> { name, age } = user;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age); <span class="hljs-comment">// "Jane" 25</span>
</code></pre>
<p>구조 분해 할당을 사용하면 객체에서 속성을 추출하고 배열에서 요소를 쉽게 각각의 변수로 추출할 수 있습니다.</p>
<h2>5. 화살표 함수</h2>
<p>문제: 기존 함수 표현식은 장황할 수 있고 <code>this</code>를 렉시컬하게 바인딩하지 않습니다.</p>
<div class="content-ad"></div>
<p>솔루션: 더 짧은 구문을 위해 화살표 함수를 사용하고 렉시컬 <code>this</code>를 활용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">a, b</span>) => a + b;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 5</span>
</code></pre>
<p>화살표 함수는 함수 표현식에 대해 간결한 구문을 제공하며 <code>this</code>가 렉시컬하게 바인딩되어 있는지 보장합니다.</p>
<h2>6. 전개 연산자</h2>
<div class="content-ad"></div>
<p>문제: 배열이나 객체를 결합하는 것은 번거로울 수 있습니다.</p>
<p>해결책: 전개 연산자를 사용하여 배열과 객체를 쉽게 결합하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
<span class="hljs-keyword">const</span> combined = […arr1, …arr2];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(combined); <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span>
</code></pre>
<p>전개 연산자를 사용하면 배열이나 객체의 요소를 다른 배열이나 객체로 전개할 수 있습니다.</p>
<div class="content-ad"></div>
<h2>7. 나머지 매개변수</h2>
<p>문제: 함수에 변수 수의 인수를 처리하는 것은 까다로울 수 있습니다.</p>
<p>해결책: 모든 인수를 배열에 캡처하기 위해 나머지 매개변수를 사용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">…args</span>) {
<span class="hljs-keyword">return</span> args.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, num</span>) =></span> total + num, <span class="hljs-number">0</span>);
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 10</span>
</code></pre>
<div class="content-ad"></div>
<p>레스트 매개변수를 사용하면 매개변수의 개수에 상관없이 배열로 처리할 수 있어 함수를 보다 유연하게 만들 수 있어요.</p>
<h2>8. 단락 평가</h2>
<p>문제: 조건문을 작성하는 것은 매우 번거로울 수 있어요.</p>
<p>해결책: 간결한 조건을 작성하기 위해 단락 평가를 활용해보세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> isLoggedIn = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">const</span> user = isLoggedIn &#x26;&#x26; { <span class="hljs-attr">name</span>: <span class="hljs-string">'Jane'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user); <span class="hljs-comment">// { name: 'Jane', age: 25 }</span>
</code></pre>
<p>단축 평가는 논리적 <code>&#x26;&#x26;</code> 및 <code>||</code> 연산자를 사용하여 조건식을 간단하게 만듭니다.</p>
<h2>9. 선택적 체이닝</h2>
<p>문제: 깊게 중첩된 속성에 액세스하는 것은 체인의 일부가 <code>null</code> 또는 <code>undefined</code>인 경우 오류를 발생시킬 수 있습니다.</p>
<div class="content-ad"></div>
<p>해결책: 중첩된 속성에 안전하게 접근하기 위해 선택적 체이닝을 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">profile</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'Jane'</span> } };
<span class="hljs-keyword">const</span> userName = user?.<span class="hljs-property">profile</span>?.<span class="hljs-property">name</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userName); <span class="hljs-comment">// "Jane"</span>
</code></pre>
<p>선택적 체이닝을 사용하면 <code>null</code> 또는 <code>undefined</code>인지 명시적으로 확인하지 않고도 중첩된 속성에 안전하게 접근할 수 있습니다.</p>
<h2>10. 널리쉬 콜리싱</h2>
<div class="content-ad"></div>
<p>문제: <code>||</code>를 사용하여 기본 값을 제공하는 경우, 값이 <code>0</code> 또는 <code>""</code>이면 예상치 못한 결과가 발생할 수 있습니다.</p>
<p>해결책: <code>nullish coalescing</code> (<code>??</code>)을 사용하여 <code>null</code> 또는 <code>undefined</code>일 때만 기본 값을 제공합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">0</span> };
<span class="hljs-keyword">const</span> userName = user.<span class="hljs-property">name</span> ?? <span class="hljs-string">'익명'</span>;
<span class="hljs-keyword">const</span> userAge = user.<span class="hljs-property">age</span> ?? <span class="hljs-number">18</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userName); <span class="hljs-comment">// ""</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userAge); <span class="hljs-comment">// 0</span>
</code></pre>
<p><code>Nullish coalescing</code>은 왼쪽 피연산자가 <code>null</code> 또는 <code>undefined</code>일 때에만 기본 값을 제공할 수 있습니다.</p>
<div class="content-ad"></div>
<h2>11. 객체 속성 축약</h2>
<p>문제: 객체 속성에 변수를 할당하는 작업이 반복적 일 수 있습니다.</p>
<p>해결책: 속성 축약을 사용하여 객체 생성을 간단하게 만듭니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> name = <span class="hljs-string">'Jane'</span>;
<span class="hljs-keyword">const</span> age = <span class="hljs-number">25</span>;
<span class="hljs-keyword">const</span> user = { name, age };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user); <span class="hljs-comment">// { name: 'Jane', age: 25 }</span>
</code></pre>
<div class="content-ad"></div>
<p>프로퍼티 축약형을 사용하면 변수 이름과 일치할 때 프로퍼티 이름을 생략할 수 있어서 코드가 더 깔끔해집니다.</p>
<h2>12. 동적 프로퍼티 이름</h2>
<p>문제: 동적 프로퍼티 이름으로 객체를 생성하는 것은 다소 장황할 수 있습니다.</p>
<p>해결책: 계산된 프로퍼티 이름을 사용하여 동적으로 객체 프로퍼티를 생성하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> propName = <span class="hljs-string">'나이'</span>;
<span class="hljs-keyword">const</span> user = { 이름: <span class="hljs-string">'제인'</span>, [propName]: <span class="hljs-number">25</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user); <span class="hljs-comment">// { 이름: '제인', 나이: 25 }</span>
</code></pre>
<p>계산된 속성 이름을 사용하면 식의 값으로 속성 이름을 동적으로 만들 수 있습니다.</p>
<h2>13. 배열 <code>map()</code>, <code>filter()</code>, 및 <code>reduce()</code></h2>
<p>문제: 배열을 변환, 필터링 또는 값 누적하기 위해 배열을 반복하는 작업은 반복적일 수 있습니다.</p>
<div class="content-ad"></div>
<p>솔루션: 일반적인 배열 작업에 <code>map()</code>, <code>filter()</code>, 및 <code>reduce()</code>를 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> doubled = numbers.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">num</span> =></span> num * <span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubled); <span class="hljs-comment">// [2, 4, 6, 8, 10]</span>
<span class="hljs-keyword">const</span> evens = numbers.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">num</span> =></span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evens); <span class="hljs-comment">// [2, 4]</span>
<span class="hljs-keyword">const</span> sum = numbers.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, num</span>) =></span> total + num, <span class="hljs-number">0</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum); <span class="hljs-comment">// 15</span>
</code></pre>
<p>이러한 배열 메서드들은 배열을 변환하고 필터링하며 줄이는 함수적인 방식을 제공하여, 코드를 더 표현적이고 간결하게 만듭니다.</p>
<h2>14. 문자열 <code>includes()</code>, <code>startsWith()</code>, 및 <code>endsWith()</code></h2>
<div class="content-ad"></div>
<p>문제: 문자열에 특정 부분 문자열이 포함되어 있는지, 시작하는지 또는 끝나는지를 확인하는 작업은 장황할 수 있습니다.</p>
<p>해결책: 더 간단한 문자열 확인을 위해 <code>includes()</code>, <code>startsWith()</code>, <code>endsWith()</code>를 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'Hello, world!'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'world'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'Hello'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">'!'</span>)); <span class="hljs-comment">// true</span>
</code></pre>
<p>이러한 문자열 메소드들은 부분 문자열의 존재, 시작 또는 끝을 확인하는 간단하고 가독성 있는 방법을 제공합니다.</p>
<div class="content-ad"></div>
<h2>15. 함수 매개변수에서 배열 및 객체 비구조화</h2>
<p>문제: 함수 매개변수로 전달된 배열 또는 객체에서 값을 추출하는 것은 장황할 수 있습니다.</p>
<p>해결책: 함수 매개변수에서 비구조화를 사용하여 값을 직접 추출하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Jane'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };
<span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">{ name, age }</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`안녕, <span class="hljs-subst">${name}</span>! 당신은 <span class="hljs-subst">${age}</span>살 입니다.`</span>;
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">greet</span>(user)); <span class="hljs-comment">// "안녕, Jane! 당신은 25살 입니다."</span>
</code></pre>
<div class="content-ad"></div>
<p>함수 매개변수의 구조 분해를 사용하면 함수에 전달된 객체나 배열에서 값을 직접 추출하여 코드를 더 간결하고 가독성 있게 만들 수 있어요.</p>
<h2>16. 구조 분해에서 기본값 활용</h2>
<p>문제: 객체의 구조 분해 시 누락된 속성을 다루는 것은 복잡할 수 있어요.</p>
<p>해결책: 구조 분해에서 기본값을 사용하여 대체 값을 제공해요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">'Jane'</span> };
<span class="hljs-keyword">const</span> { name, age = <span class="hljs-number">18</span> } = user;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name); <span class="hljs-comment">// "Jane"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age); <span class="hljs-comment">// 18</span>
</code></pre>
<p>구조 분해 안에 기본 값(default values)을 설정하면 누락될 수 있는 속성에 대한 대체 값을 제공할 수 있어 코드를 보다 견고하게 만들어줍니다.</p>
<h2>17. Object <code>assign()</code></h2>
<p>문제: 객체를 복제하거나 병합하는 것은 번거롭고 실수하기 쉽습니다.</p>
<div class="content-ad"></div>
<p>해결 방법: <code>Object.assign()</code>을 사용하여 객체를 복제하거나 병합할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> target = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };
<span class="hljs-keyword">const</span> source = { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">const</span> merged = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, source);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(merged); <span class="hljs-comment">// { a: 1, b: 2 }</span>
</code></pre>
<p><code>Object.assign()</code>을 사용하면 객체를 효율적으로 복제하거나 병합할 수 있어서 수동 복사가 필요한 경우를 줄일 수 있습니다.</p>
<h2>18. Array <code>find()</code> 및 <code>findIndex()</code></h2>
<div class="content-ad"></div>
<p>문제: 배열에서 요소나 인덱스를 찾는 것은 루프를 사용하면 번거로울 수 있습니다.</p>
<p>해결책: 더 가독성있는 코드를 위해 <code>find()</code>와 <code>findIndex()</code>를 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> users = [
{ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Jane'</span> },
{ <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span> },
];
<span class="hljs-keyword">const</span> user = users.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">u</span> =></span> u.<span class="hljs-property">id</span> === <span class="hljs-number">1</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user); <span class="hljs-comment">// { id: 1, name: 'Jane' }</span>
<span class="hljs-keyword">const</span> index = users.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">u</span> =></span> u.<span class="hljs-property">id</span> === <span class="hljs-number">1</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index); <span class="hljs-comment">// 0</span>
</code></pre>
<div class="content-ad"></div>
<p>이러한 배열 메소드는 조건에 따라 요소를 찾거나 인덱스를 찾는 간단한 방법을 제공하여 코드의 가독성을 향상시킵니다.</p>
<h2>19. 배열 <code>some()</code> 및 <code>every()</code></h2>
<p>문제: 배열 중 일부 또는 모든 요소가 특정 조건을 충족하는지 확인하는 것이 장황할 수 있습니다.</p>
<p>해결책: 더 깔끔한 코드를 위해 <code>some()</code> 및 <code>every()</code>를 사용하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> hasEven = numbers.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">num</span> =></span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hasEven); <span class="hljs-comment">// true</span>
<span class="hljs-keyword">const</span> allEven = numbers.<span class="hljs-title function_">every</span>(<span class="hljs-function"><span class="hljs-params">num</span> =></span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(allEven); <span class="hljs-comment">// false</span>
</code></pre>
<p>이러한 배열 메소드를 사용하면 배열 내 일부 또는 모든 요소가 특정 조건을 충족하는지 간결하게 확인할 수 있습니다.</p>
<h2>20. 배열 <code>flat()</code> 및 <code>flatMap()</code></h2>
<p>문제: 중첩된 배열을 평탄화하거나 배열을 매핑하고 평탄화하는 것은 번거로울 수 있습니다.</p>
<div class="content-ad"></div>
<p>해결 방법: 더 읽기 쉬운 코드를 위해 <code>flat()</code> 및 <code>flatMap()</code>을 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> nested = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>]]]];
<span class="hljs-keyword">const</span> flat = nested.<span class="hljs-title function_">flat</span>(<span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flat); <span class="hljs-comment">// [1, 2, 3, [4]]</span>
<span class="hljs-keyword">const</span> mapped = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =></span> [x, x * <span class="hljs-number">2</span>]);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mapped); <span class="hljs-comment">// [1, 2, 2, 4, 3, 6]</span>
</code></pre>
<p>이러한 배열 메서드를 사용하면 중첩된 배열을 쉽게 평탄화하고 한 번에 매핑 및 평탄화할 수 있는 간단한 방법을 제공합니다.</p>
<h2>21. Array <code>from()</code> and <code>of()</code></h2>
<div class="content-ad"></div>
<p>문제: 이터러블 객체나 인수에서 배열을 만드는 것은 장황할 수 있습니다.</p>
<p>해결책: 더 깔끔한 코드를 위해 <code>Array.from()</code> 및 <code>Array.of()</code>를 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-keyword">const</span> arrFromSet = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(set);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrFromSet); <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-keyword">const</span> arrOfNumbers = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrOfNumbers); <span class="hljs-comment">// [1, 2, 3]</span>
</code></pre>
<p><code>Array.from()</code>은 이터러블 객체에서 배열을 만들 수 있고, <code>Array.of()</code>은 인수 목록에서 배열을 만들 수 있습니다.</p>
<div class="content-ad"></div>
<h2>22. 콜백에서 파라미터 구조 분해</h2>
<p>문제점: 콜백에 전달된 객체의 속성에 접근하는 것은 장황할 수 있습니다.</p>
<p>해결책: 더 깔끔한 코드를 위해 콜백 파라미터에서 구조 분해를 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> users = [
{ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Jane'</span> },
{ <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span> },
];
users.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{ id, name }</span>) =></span> {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`User ID: <span class="hljs-subst">${id}</span>, User Name: <span class="hljs-subst">${name}</span>`</span>);
};
</code></pre>
<div class="content-ad"></div>
<p>콜백 매개변수의 구조 분해를 사용하면 콜백에 전달된 객체의 속성에 직접 액세스하여 코드를 더 간결하게 만들 수 있어요.</p>
<h2>23. 선택적 콜백 함수</h2>
<p>문제: 선택적 콜백 함수를 처리하는 것은 다소 까다로울 수 있어요.</p>
<p>해결책: 선택적 콜백을 호출하기 위해 단락 평가(short-circuit evaluation)를 사용해주세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">url, callback</span>) {
    <span class="hljs-title function_">fetch</span>(url)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =></span> response.<span class="hljs-title function_">json</span>())
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =></span> {
        callback &#x26;&#x26; <span class="hljs-title function_">callback</span>(data);
    });
}
</code></pre>
<p>단락평가는 제공된 경우에만 선택적 콜백 함수를 호출할 수 있게 해서 코드를 보다 견고하게 만들어줍니다.</p>
<h2>24. 콜백을 프로미스로 변환하기</h2>
<p>문제: 콜백을 기반으로 하는 함수를 프로미스로 변환하는 것은 어려울 수 있습니다.</p>
<div class="content-ad"></div>
<p>솔루션: 유틸리티 함수를 사용하여 콜백을 Promisify합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">promisify</span>(<span class="hljs-params">fn</span>) {
<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">…args</span>) {
<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
<span class="hljs-title function_">fn</span>(…args, <span class="hljs-function">(<span class="hljs-params">err, result</span>) =></span> {
<span class="hljs-keyword">if</span> (err) <span class="hljs-title function_">reject</span>(err);
<span class="hljs-keyword">else</span> <span class="hljs-title function_">resolve</span>(result);
});
});
};
}
<span class="hljs-keyword">const</span> readFile = <span class="hljs-title function_">promisify</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>).<span class="hljs-property">readFile</span>);
<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'path/to/file.txt'</span>, <span class="hljs-string">'utf8'</span>)
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data))
.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err));
</code></pre>
<p>프로미스화를 통해 콜백 기반 함수를 프로미스로 변환하여 비동기/대기 문법과 함께 사용할 수 있게 만들어줍니다.</p>
<h2>25. 동기적인 코드를 위한 Async/Await</h2>
<div class="content-ad"></div>
<p>문제점: Promise를 사용한 비동기 코드 작성은 길고 읽기 어렵습니다.</p>
<p>해결책: async/await를 사용하여 동기적인 스타일로 비동기 코드를 작성하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params">url</span>) {
<span class="hljs-keyword">try</span> {
<span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
} <span class="hljs-keyword">catch</span> (error) {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'데이터를 불러오는 중 오류가 발생했습니다:'</span>, error);
}
}
<span class="hljs-title function_">fetchData</span>(<span class="hljs-string">'https://api.example.com/data'</span>);
</code></pre>
<p>Async/await는 비동기 코드를 동기 코드처럼 작성하고 동작하도록 하는 방법을 제공하여 가독성과 유지보수성을 향상시킵니다.</p>
<div class="content-ad"></div>
<h2>26. Promises 연쇄하기</h2>
<p>문제 : 여러 비동기 작업을 순차적으로 처리하는 것은 번거로울 수 있습니다.</p>
<p>해결책 : Promises를 연쇄하여 여러 비동기 작업을 처리하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data'</span>)
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =></span> response.<span class="hljs-title function_">json</span>())
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'데이터:'</span>, data);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/more-data'</span>);
})
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =></span> response.<span class="hljs-title function_">json</span>())
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">moreData</span> =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'더 많은 데이터:'</span>, moreData);
})
.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'에러:'</span>, error);
});
</code></pre>
<div class="content-ad"></div>
<p><strong>Promise를 연결하는 것은 여러 비동기 작업을 순차적으로 처리할 수 있어 가독성과 유지 보수성을 향상시킬 수 있습니다.</strong></p>
<h2>27. 동시 실행을 위한 Promise.all</h2>
<p>문제: 여러 비동기 작업을 동시에 처리하는 것은 어려울 수 있습니다.</p>
<p>해결책: <code>Promise.all</code>을 사용하여 동시에 비동기 작업을 처리하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> fetchData1 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data1'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =></span> response.<span class="hljs-title function_">json</span>());
<span class="hljs-keyword">const</span> fetchData2 = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://api.example.com/data2'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =></span> response.<span class="hljs-title function_">json</span>());
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([fetchData1, fetchData2])
.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">[data1, data2]</span>) =></span> {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Data 1:'</span>, data1);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Data 2:'</span>, data2);
})
.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =></span> {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'Error:'</span>, error);
});
</code></pre>
<p><code>Promise.all</code>을 사용하면 여러 비동기 작업을 동시에 처리하고 모두 완료될 때 진행할 수 있습니다.</p>
<h2>28. 디바운스 함수</h2>
<p>문제: 창 크기 조절과 같은 빈번한 함수 호출은 성능을 저하시킬 수 있습니다.</p>
<div class="content-ad"></div>
<p>해결책: debounce 함수를 사용하여 함수가 실행되는 속도를 제한합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, wait</span>) {
  <span class="hljs-keyword">let</span> timeout;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
    <span class="hljs-built_in">clearTimeout</span>(timeout);
    timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args), wait);
  };
}
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'resize'</span>, <span class="hljs-title function_">debounce</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'창 크기 조정됨'</span>);
}, <span class="hljs-number">200</span>));
</code></pre>
<p>debounce 함수는 일정 시간 동안 활동이 없을 때에만 함수가 호출되도록 보장하여 성능을 개선합니다.</p>
<h2>29. 스로틀 함수</h2>
<div class="content-ad"></div>
<p>문제: 스크롤 또는 크기 조정과 같이 빈번하게 발생하는 이벤트의 함수 실행 속도 제한.</p>
<p>해결책: 함수 실행 속도 제한을 위해 스로틀(throttle) 함수를 사용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, limit</span>) {
  <span class="hljs-keyword">let</span> lastFunc;
  <span class="hljs-keyword">let</span> lastRan;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
    <span class="hljs-keyword">if</span> (!lastRan) {
      func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
      lastRan = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">clearTimeout</span>(lastFunc);
      lastFunc = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - lastRan >= limit) {
          func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
          lastRan = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
        }
      }, limit - (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() - lastRan));
    }
  };
}

<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'scroll'</span>, <span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'창 스크롤됨'</span>);
}, <span class="hljs-number">200</span>));
</code></pre>
<p>스로틀 함수를 사용하면 주어진 기간에 함수가 최대 한 번 호출되도록 보장하여 빈번히 발생하는 이벤트에 대한 성능을 향상시킬 수 있습니다.</p>
<div class="content-ad"></div>
<h2>30. 객체의 깊은 복제</h2>
<p>문제: 중첩된 객체를 복제하는 것은 까다롭고 오류가 발생하기 쉽습니다.</p>
<p>해결책: 구조화된 복제 또는 Lodash와 같은 라이브러리를 사용하여 객체를 깊게 복제하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: { <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> } };
<span class="hljs-keyword">const</span> deepClone = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(deepClone); <span class="hljs-comment">// { a: 1, b: { c: 2 } }</span>
</code></pre>
<div class="content-ad"></div>
<p>깊은 복제는 중첩된 객체가 참조가 아닌 값으로 복사되어 원본 객체가 의도하지 않은 수정을 방지합니다.</p>
<h2>31. 메모이제이션</h2>
<p>문제: 비싼 함수를 반복 호출하면 성능이 저하될 수 있습니다.</p>
<p>해결책: 메모이제이션을 사용하여 비싼 함수 호출의 결과를 캐시합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">memoize</span>(<span class="hljs-params">func</span>) {
<span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
<span class="hljs-keyword">const</span> key = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(args);
<span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(key)) {
<span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(key);
}
<span class="hljs-keyword">const</span> result = func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
cache.<span class="hljs-title function_">set</span>(key, result);
<span class="hljs-keyword">return</span> result;
};
}
<span class="hljs-keyword">const</span> expensiveFunction = <span class="hljs-title function_">memoize</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =></span> {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'계산 중…'</span>);
<span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span>;
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">expensiveFunction</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// "계산 중…" 4</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">expensiveFunction</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">// 4</span>
</code></pre>
<p>메모이제이션은 비용이 많이 드는 함수 호출의 결과를 캐싱하여 동일한 인수로의 후속 호출에 대해 캐시된 결과를 반환함으로써 성능을 향상시킵니다.</p>
<h2>32. 함수 커링</h2>
<p>문제: 여러 개의 매개변수를 가진 함수를 생성하는 것은 번거로울 수 있습니다.</p>
<div class="content-ad"></div>
<p>솔루션: 커링을 사용하여 부분적으로 적용된 매개변수를 가진 함수를 만드세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">func</span>) {
<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">curried</span>(<span class="hljs-params">…args</span>) {
<span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> >= func.<span class="hljs-property">length</span>) {
<span class="hljs-keyword">return</span> func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
}
<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">…nextArgs</span>) {
<span class="hljs-keyword">return</span> curried.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args.<span class="hljs-title function_">concat</span>(nextArgs));
};
};
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">a, b, c</span>) => a + b + c;
<span class="hljs-keyword">const</span> curriedSum = <span class="hljs-title function_">curry</span>(sum);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">curriedSum</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">curriedSum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span>
</code></pre>
<p>커링을 사용하면 더 적은 매개변수로 호출할 수 있는 함수를 생성하여 나머지 매개변수를 받는 새 함수를 반환할 수 있습니다.</p>
<h2>33. 부분 적용</h2>
<div class="content-ad"></div>
<p>문제: 반복적인 인자로 함수를 호출하는 것은 귀찮을 수 있습니다.</p>
<p>해결책: 일부 인자를 함수에 미리 적용하기 위해 부분 적용을 사용하십시오.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">partial</span>(<span class="hljs-params">func, ...presetArgs</span>) {
<span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...laterArgs</span>) {
<span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(...presetArgs, ...laterArgs);
};
}
<span class="hljs-keyword">const</span> <span class="hljs-title function_">multiply</span> = (<span class="hljs-params">a, b, c</span>) => a * b * c;
<span class="hljs-keyword">const</span> double = <span class="hljs-title function_">partial</span>(multiply, <span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">double</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 24</span>
</code></pre>
<p>부분 적용을 사용하면 일부 인자를 미리 적용하여 새로운 함수를 만들 수 있어 코드를 더 유연하고 재사용 가능하게 만들 수 있습니다.</p>
<div class="content-ad"></div>
<ol start="34">
<li>함수 합성</li>
</ol>
<p>문제: 여러 함수를 단일 작업으로 결합하는 것은 번거로울 수 있습니다.</p>
<p>해결책: 여러 함수를 결합하기 위해 함수 합성을 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">compose</span> = (<span class="hljs-params">…funcs</span>) => <span class="hljs-function">(<span class="hljs-params">arg</span>) =></span>
funcs.<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">prev, fn</span>) =></span> <span class="hljs-title function_">fn</span>(prev), arg);
<span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">x</span>) => x + <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">multiply</span> = (<span class="hljs-params">x</span>) => x * <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> addThenMultiply = <span class="hljs-title function_">compose</span>(multiply, add);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addThenMultiply</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 12</span>
</code></pre>
<div class="content-ad"></div>
<p>함수 합성을 사용하면 여러 함수를 결합하여 새로운 함수를 만들어 코드를 더 모듈식으로 만들고 재사용할 수 있습니다.</p>
<h2>35. 함수 파이프라이닝</h2>
<p>문제: 값에 일련의 함수를 적용하는 것이 장황할 수 있습니다.</p>
<p>해결책: 함수 파이프라이닝을 사용하여 일련의 함수를 순차적으로 적용하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">pipe</span> = (<span class="hljs-params">...funcs</span>) => <span class="hljs-function">(<span class="hljs-params">arg</span>) =></span>
funcs.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, fn</span>) =></span> <span class="hljs-title function_">fn</span>(prev), arg);
<span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">x</span>) => x + <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">multiply</span> = (<span class="hljs-params">x</span>) => x * <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> addThenMultiply = <span class="hljs-title function_">pipe</span>(add, multiply);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">addThenMultiply</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 12</span>
</code></pre>
<p>함수 파이프 라이닝을 사용하면 코드의 가독성과 유지 관리성을 높일 수 있습니다.</p>
<h2>36. 스스로 호출하는 함수</h2>
<p>문제: 정의할 때 즉시 함수를 실행하는 것은 번거로울 수 있습니다.</p>
<div class="content-ad"></div>
<p>솔루션: 즉시 실행 함수 표현식(IIFE)을 사용하세요.</p>
<pre><code class="hljs language-js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'즉시 실행됩니다!'</span>);
})();
</code></pre>
<p>IIFE를 사용하면 함수를 정의하는 즉시 실행할 수 있어서, 격리된 스코프를 만들고 전역 네임스페이스를 오염시키는 것을 피할 수 있습니다.</p>
<h2>37. 전역 변수 사용을 피하세요</h2>
<div class="content-ad"></div>
<p>문제: 전역 변수는 충돌과 의도치 않은 부작용을 일으킬 수 있습니다.</p>
<p>해결책: 전역 이름 공간을 오염시키지 않도록 지역 변수와 모듈을 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 지역 변수 사용</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> localVariable = <span class="hljs-string">'지역 변수입니다'</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(localVariable);
}
<span class="hljs-comment">// 모듈 사용</span>
<span class="hljs-keyword">const</span> myModule = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> privateVariable = <span class="hljs-string">'비공개 변수입니다'</span>;
    <span class="hljs-keyword">return</span> {
        <span class="hljs-title function_">publicMethod</span>(<span class="hljs-params"></span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(privateVariable);
        },
    };
})();
myModule.<span class="hljs-title function_">publicMethod</span>(); <span class="hljs-comment">// "비공개 변수입니다"</span>
</code></pre>
<p>전역 변수를 피함으로써 충돌과 의도하지 않은 부작용을 방지하고, 코드를 모듈화하고 유지보수하기 쉽도록 만들 수 있습니다.</p>
<div class="content-ad"></div>
<h2>38. 클로저를 사용한 캡슐화</h2>
<p>문제: 함수의 내부 세부 정보를 노출하면 남용될 수 있습니다.</p>
<p>해결책: 클로저를 사용하여 내부 세부 정보를 캡슐화합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) {
<span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
<span class="hljs-keyword">return</span> {
<span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {
count++;
<span class="hljs-keyword">return</span> count;
},
<span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) {
count--;
<span class="hljs-keyword">return</span> count;
},
};
}
<span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">increment</span>()); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">increment</span>()); <span class="hljs-comment">// 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-title function_">decrement</span>()); <span class="hljs-comment">// 1</span>
</code></pre>
<div class="content-ad"></div>
<p>클로저를 사용하면 내부 세부 정보를 캡슐화하고 필요한 기능만 노출하여 코드 보안 및 유지 보수성을 향상시킬 수 있어요.</p>
<h2>39. 모듈 패턴</h2>
<p>문제: 코드를 재사용 가능한 모듈로 구성하는 것은 challenging할 수 있어요.</p>
<p>해결책: 모듈 패턴을 사용하여 재사용 가능하고 캡슐화된 코드를 생성하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myModule = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
<span class="hljs-keyword">let</span> privateVariable = <span class="hljs-string">'This is private'</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">privateMethod</span>(<span class="hljs-params"></span>) {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(privateVariable);
}
<span class="hljs-keyword">return</span> {
<span class="hljs-title function_">publicMethod</span>(<span class="hljs-params"></span>) {
<span class="hljs-title function_">privateMethod</span>();
},
};
})();
myModule.<span class="hljs-title function_">publicMethod</span>(); <span class="hljs-comment">// "This is private"</span>
</code></pre>
<p>모듈 패턴을 사용하면 재사용 가능하고 캡슐화된 코드를 작성할 수 있어 코드 구성과 유지보수를 개선할 수 있어요.</p>
<h2>40. 싱글톤 패턴</h2>
<p>문제: 클래스의 인스턴스가 하나만 생성되도록 보장하는 것은 도전적일 수 있어요.</p>
<div class="content-ad"></div>
<p>해결책: 싱글톤 패턴을 사용하여 단일 인스턴스를 생성하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> singleton = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
<span class="hljs-keyword">let</span> instance;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createInstance</span>(<span class="hljs-params"></span>) {
<span class="hljs-keyword">return</span> {
<span class="hljs-attr">name</span>: <span class="hljs-string">'싱글톤 인스턴스'</span>,
};
}
<span class="hljs-keyword">return</span> {
<span class="hljs-title function_">getInstance</span>(<span class="hljs-params"></span>) {
<span class="hljs-keyword">if</span> (!instance) {
instance = <span class="hljs-title function_">createInstance</span>();
}
<span class="hljs-keyword">return</span> instance;
},
};
})();
<span class="hljs-keyword">const</span> instance1 = singleton.<span class="hljs-title function_">getInstance</span>();
<span class="hljs-keyword">const</span> instance2 = singleton.<span class="hljs-title function_">getInstance</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1 === instance2); <span class="hljs-comment">// true</span>
</code></pre>
<p>싱글톤 패턴은 클래스의 단일 인스턴스만 생성되도록 보장하며, 공유 리소스 또는 구성을 관리하는 데 유용합니다.</p>
<h2>41. 팩토리 패턴</h2>
<div class="content-ad"></div>
<p>문제: 복잡한 초기화가 필요한 객체를 생성하는 것은 귀찮을 수 있습니다.</p>
<p>해결책: 팩토리 패턴을 사용하여 객체를 생성하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createUser</span>(<span class="hljs-params">name, role</span>) {
<span class="hljs-keyword">return</span> {
name,
role,
<span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>) {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`안녕하세요, 제 이름은 <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>이고 <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.role}</span>입니다.`</span>);
},
};
}
<span class="hljs-keyword">const</span> admin = <span class="hljs-title function_">createUser</span>(<span class="hljs-string">'Alice'</span>, <span class="hljs-string">'admin'</span>);
<span class="hljs-keyword">const</span> user = <span class="hljs-title function_">createUser</span>(<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'user'</span>);
admin.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "안녕하세요, 제 이름은 Alice이고 admin입니다."</span>
user.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// "안녕하세요, 제 이름은 Bob이고 user입니다."</span>
</code></pre>
<p>팩토리 패턴을 사용하면 유연하고 재사용 가능한 방식으로 복잡한 초기화가 필요한 객체를 생성할 수 있습니다.</p>
<div class="content-ad"></div>
<h2>42. 관찰자 패턴</h2>
<p>문제: 상태 변경을 관리하고 여러 구성 요소에 알릴 때 어려울 수 있습니다.</p>
<p>해결책: 관찰자 패턴을 사용하여 상태 변경을 관리하고 관찰자에게 알립니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Subject</span>(<span class="hljs-params"></span>) {
<span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];
}
<span class="hljs-title class_">Subject</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = {
<span class="hljs-title function_">subscribe</span>(<span class="hljs-params">observer</span>) {
<span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer);
},
<span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">observer</span>) {
<span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">obs</span>) =></span> obs !== observer);
},
<span class="hljs-title function_">notify</span>(<span class="hljs-params">data</span>) {
<span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">observer</span>) =></span> observer.<span class="hljs-title function_">update</span>(data));
},
};
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Observer</span>(<span class="hljs-params">name</span>) {
<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}
<span class="hljs-title class_">Observer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">update</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span> received data: <span class="hljs-subst">${data}</span>`</span>);
};
<span class="hljs-keyword">const</span> subject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>();
<span class="hljs-keyword">const</span> observer1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(<span class="hljs-string">'Observer 1'</span>);
<span class="hljs-keyword">const</span> observer2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(<span class="hljs-string">'Observer 2'</span>);
subject.<span class="hljs-title function_">subscribe</span>(observer1);
subject.<span class="hljs-title function_">subscribe</span>(observer2);
subject.<span class="hljs-title function_">notify</span>(<span class="hljs-string">'새로운 데이터 이용 가능'</span>); <span class="hljs-comment">// "Observer 1 received data: 새로운 데이터 이용 가능" "Observer 2 received data: 새로운 데이터 이용 가능"</span>
</code></pre>
<div class="content-ad"></div>
<p>옵저버 패턴을 사용하면 상태 변경을 관리하고 여러 옵저버에게 알림을 보내어 코드 구성 및 유지 관리를 개선할 수 있어요.</p>
<h2>43. 이벤트 위임</h2>
<p>문제: 여러 요소에 이벤트 리스너를 추가하면 성능이 저하될 수 있어요.</p>
<p>해결책: 이벤트 위임을 사용하여 이벤트를 효율적으로 관리하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'parent'</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =></span> {
<span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span> &#x26;&#x26; event.<span class="hljs-property">target</span>.<span class="hljs-title function_">matches</span>(<span class="hljs-string">'button.className'</span>)) {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Button clicked:'</span>, event.<span class="hljs-property">target</span>.<span class="hljs-property">textContent</span>);
}
});
</code></pre>
<p>이벤트 위임을 사용하면 공통 상위 요소에 하나의 이벤트 리스너를 추가하여 여러 하위 요소의 이벤트를 효율적으로 처리할 수 있습니다.</p>
<h2>44. <code>eval()</code> 사용 피하기</h2>
<p>문제: <code>eval()</code> 사용은 보안 취약점과 성능 문제를 야기할 수 있습니다.</p>
<div class="content-ad"></div>
<p>해결 방법: <code>eval()</code>을 사용하지 말고 더 안전한 대안을 사용하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 피하십시오</span>
<span class="hljs-keyword">const</span> code = <span class="hljs-string">'console.log("Hello, world!")'</span>;
<span class="hljs-built_in">eval</span>(code); <span class="hljs-comment">// "Hello, world!"</span>
<span class="hljs-comment">// 더 안전한 대안 사용</span>
<span class="hljs-keyword">const</span> func = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">'console.log("Hello, world!")'</span>);
<span class="hljs-title function_">func</span>(); <span class="hljs-comment">// "Hello, world!"</span>
</code></pre>
<p><code>eval()</code>을 피함으로써 보안 취약성과 성능 문제를 방지하고 코드를 더 안전하고 효율적으로 만들 수 있습니다.</p>
<h2>45. <code>for…of</code>를 사용하여 반복하기</h2>
<div class="content-ad"></div>
<p>문제: 'for...in'을 사용하여 배열을 반복하는 것은 오류가 발생할 수 있습니다.</p>
<p>해결책: 배열 및 기타 반복 가능한 객체를 반복하는 데는 'for...of'를 사용하십시오.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> arr) {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);
}
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 2</span>
<span class="hljs-comment">// 3</span>
<span class="hljs-comment">// 4</span>
<span class="hljs-comment">// 5</span>
</code></pre>
<p><code>for...of</code>는 간단하고 안전한 방법을 제공합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"모든 개발자가 알아야 할 45가지 자바스크립트 슈퍼 해킹 기술","description":"","date":"2024-06-22 05:16","slug":"2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png\" /\u003e\n\n자바스크립트는 현대 웹 개발에서 필수적인 다목적 강력한 언어입니다. 이 글에서는 여러분을 더 효율적이고 효과적인 자바스크립트 개발자로 만들어 줄 수 있는 슈퍼 해킹 기술들을 소개하고 각각에 대한 상세한 설명과 예제를 제공합니다.\n\n## 1. `var` 대신 `let` 및 `const` 사용하기\n\n문제: `var`은 함수 범위를 가지고 있어서 버그와 예상치 못한 동작을 유발할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: 블록 스코프를 갖는 `let`과 `const`를 사용하세요.\n\n```js\nlet count = 0;\nconst PI = 3.14;\n```\n\n`let`과 `const`를 사용하면 변수를 정의된 블록 내에서만 접근할 수 있도록 하여 스코프 관련 버그를 방지할 수 있습니다.\n\n## 2. 기본 매개변수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 인수가 제공되지 않으면 함수가 실패할 수 있습니다.\n\n해결책: 기본 매개변수를 사용하여 대안 값 설정.\n\n```js\nfunction greet(name = '방문자') {\nreturn `안녕하세요, ${name}님!`;\n}\nconsole.log(greet()); // \"안녕하세요, 방문자님!\"\n```\n\n기본 매개변수를 사용하면 함수가 합리적인 기본값을 갖도록되어 오류를 방지하고 코드를 더 견고하게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3. 템플릿 리터럴\n\n문제: 문자열 연결은 번거로우며 오류가 발생하기 쉽습니다.\n\n해결책: 더 깔끔하고 가독성이 좋은 문자열 보간을 위해 템플릿 리터럴을 사용하세요.\n\n```js\nconst name = 'John';\nconst greeting = `Hello, ${name}!`;\nconsole.log(greeting); // \"Hello, John!\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n템플릿 리터럴을 사용하면 포함된 표현식과 여러 줄의 문자열을 쉽게 만들 수 있어요.\n\n## 4. 비구조화 할당\n\n문제: 객체와 배열에서 값 추출하는 과정이 장황할 수 있어요.\n\n해결책: 비구조화 할당을 사용해서 값을 더 간결하게 추출하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst user = { name: 'Jane', age: 25 };\nconst { name, age } = user;\nconsole.log(name, age); // \"Jane\" 25\n```\n\n구조 분해 할당을 사용하면 객체에서 속성을 추출하고 배열에서 요소를 쉽게 각각의 변수로 추출할 수 있습니다.\n\n## 5. 화살표 함수\n\n문제: 기존 함수 표현식은 장황할 수 있고 `this`를 렉시컬하게 바인딩하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 더 짧은 구문을 위해 화살표 함수를 사용하고 렉시컬 `this`를 활용하세요.\n\n```js\nconst add = (a, b) =\u003e a + b;\nconsole.log(add(2, 3)); // 5\n```\n\n화살표 함수는 함수 표현식에 대해 간결한 구문을 제공하며 `this`가 렉시컬하게 바인딩되어 있는지 보장합니다.\n\n## 6. 전개 연산자\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 배열이나 객체를 결합하는 것은 번거로울 수 있습니다.\n\n해결책: 전개 연산자를 사용하여 배열과 객체를 쉽게 결합하세요.\n\n```js\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = […arr1, …arr2];\nconsole.log(combined); // [1, 2, 3, 4, 5, 6]\n```\n\n전개 연산자를 사용하면 배열이나 객체의 요소를 다른 배열이나 객체로 전개할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 7. 나머지 매개변수\n\n문제: 함수에 변수 수의 인수를 처리하는 것은 까다로울 수 있습니다.\n\n해결책: 모든 인수를 배열에 캡처하기 위해 나머지 매개변수를 사용합니다.\n\n```js\nfunction sum(…args) {\nreturn args.reduce((total, num) =\u003e total + num, 0);\n}\nconsole.log(sum(1, 2, 3, 4)); // 10\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n레스트 매개변수를 사용하면 매개변수의 개수에 상관없이 배열로 처리할 수 있어 함수를 보다 유연하게 만들 수 있어요.\n\n## 8. 단락 평가\n\n문제: 조건문을 작성하는 것은 매우 번거로울 수 있어요.\n\n해결책: 간결한 조건을 작성하기 위해 단락 평가를 활용해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst isLoggedIn = true;\nconst user = isLoggedIn \u0026\u0026 { name: 'Jane', age: 25 };\nconsole.log(user); // { name: 'Jane', age: 25 }\n```\n\n단축 평가는 논리적 `\u0026\u0026` 및 `||` 연산자를 사용하여 조건식을 간단하게 만듭니다.\n\n## 9. 선택적 체이닝\n\n문제: 깊게 중첩된 속성에 액세스하는 것은 체인의 일부가 `null` 또는 `undefined`인 경우 오류를 발생시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: 중첩된 속성에 안전하게 접근하기 위해 선택적 체이닝을 사용하세요.\n\n```js\nconst user = { profile: { name: 'Jane' } };\nconst userName = user?.profile?.name;\nconsole.log(userName); // \"Jane\"\n```\n\n선택적 체이닝을 사용하면 `null` 또는 `undefined`인지 명시적으로 확인하지 않고도 중첩된 속성에 안전하게 접근할 수 있습니다.\n\n## 10. 널리쉬 콜리싱\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: `||`를 사용하여 기본 값을 제공하는 경우, 값이 `0` 또는 `\"\"`이면 예상치 못한 결과가 발생할 수 있습니다.\n\n해결책: `nullish coalescing` (`??`)을 사용하여 `null` 또는 `undefined`일 때만 기본 값을 제공합니다.\n\n```js\nconst user = { name: '', age: 0 };\nconst userName = user.name ?? '익명';\nconst userAge = user.age ?? 18;\nconsole.log(userName); // \"\"\nconsole.log(userAge); // 0\n```\n\n`Nullish coalescing`은 왼쪽 피연산자가 `null` 또는 `undefined`일 때에만 기본 값을 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 11. 객체 속성 축약\n\n문제: 객체 속성에 변수를 할당하는 작업이 반복적 일 수 있습니다.\n\n해결책: 속성 축약을 사용하여 객체 생성을 간단하게 만듭니다.\n\n```js\nconst name = 'Jane';\nconst age = 25;\nconst user = { name, age };\nconsole.log(user); // { name: 'Jane', age: 25 }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로퍼티 축약형을 사용하면 변수 이름과 일치할 때 프로퍼티 이름을 생략할 수 있어서 코드가 더 깔끔해집니다.\n\n## 12. 동적 프로퍼티 이름\n\n문제: 동적 프로퍼티 이름으로 객체를 생성하는 것은 다소 장황할 수 있습니다.\n\n해결책: 계산된 프로퍼티 이름을 사용하여 동적으로 객체 프로퍼티를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst propName = '나이';\nconst user = { 이름: '제인', [propName]: 25 };\nconsole.log(user); // { 이름: '제인', 나이: 25 }\n```\n\n계산된 속성 이름을 사용하면 식의 값으로 속성 이름을 동적으로 만들 수 있습니다.\n\n## 13. 배열 `map()`, `filter()`, 및 `reduce()`\n\n문제: 배열을 변환, 필터링 또는 값 누적하기 위해 배열을 반복하는 작업은 반복적일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 일반적인 배열 작업에 `map()`, `filter()`, 및 `reduce()`를 사용하세요.\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst doubled = numbers.map(num =\u003e num * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]\nconst evens = numbers.filter(num =\u003e num % 2 === 0);\nconsole.log(evens); // [2, 4]\nconst sum = numbers.reduce((total, num) =\u003e total + num, 0);\nconsole.log(sum); // 15\n```\n\n이러한 배열 메서드들은 배열을 변환하고 필터링하며 줄이는 함수적인 방식을 제공하여, 코드를 더 표현적이고 간결하게 만듭니다.\n\n## 14. 문자열 `includes()`, `startsWith()`, 및 `endsWith()`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 문자열에 특정 부분 문자열이 포함되어 있는지, 시작하는지 또는 끝나는지를 확인하는 작업은 장황할 수 있습니다.\n\n해결책: 더 간단한 문자열 확인을 위해 `includes()`, `startsWith()`, `endsWith()`를 사용하세요.\n\n```js\nconst str = 'Hello, world!';\nconsole.log(str.includes('world')); // true\nconsole.log(str.startsWith('Hello')); // true\nconsole.log(str.endsWith('!')); // true\n```\n\n이러한 문자열 메소드들은 부분 문자열의 존재, 시작 또는 끝을 확인하는 간단하고 가독성 있는 방법을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 15. 함수 매개변수에서 배열 및 객체 비구조화\n\n문제: 함수 매개변수로 전달된 배열 또는 객체에서 값을 추출하는 것은 장황할 수 있습니다.\n\n해결책: 함수 매개변수에서 비구조화를 사용하여 값을 직접 추출하세요.\n\n```js\nconst user = { name: 'Jane', age: 25 };\nfunction greet({ name, age }) {\n    return `안녕, ${name}! 당신은 ${age}살 입니다.`;\n}\nconsole.log(greet(user)); // \"안녕, Jane! 당신은 25살 입니다.\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수 매개변수의 구조 분해를 사용하면 함수에 전달된 객체나 배열에서 값을 직접 추출하여 코드를 더 간결하고 가독성 있게 만들 수 있어요.\n\n## 16. 구조 분해에서 기본값 활용\n\n문제: 객체의 구조 분해 시 누락된 속성을 다루는 것은 복잡할 수 있어요.\n\n해결책: 구조 분해에서 기본값을 사용하여 대체 값을 제공해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst user = { name: 'Jane' };\nconst { name, age = 18 } = user;\nconsole.log(name); // \"Jane\"\nconsole.log(age); // 18\n```\n\n구조 분해 안에 기본 값(default values)을 설정하면 누락될 수 있는 속성에 대한 대체 값을 제공할 수 있어 코드를 보다 견고하게 만들어줍니다.\n\n## 17. Object `assign()`\n\n문제: 객체를 복제하거나 병합하는 것은 번거롭고 실수하기 쉽습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결 방법: `Object.assign()`을 사용하여 객체를 복제하거나 병합할 수 있습니다.\n\n```js\nconst target = { a: 1 };\nconst source = { b: 2 };\nconst merged = Object.assign(target, source);\nconsole.log(merged); // { a: 1, b: 2 }\n```\n\n`Object.assign()`을 사용하면 객체를 효율적으로 복제하거나 병합할 수 있어서 수동 복사가 필요한 경우를 줄일 수 있습니다.\n\n## 18. Array `find()` 및 `findIndex()`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 배열에서 요소나 인덱스를 찾는 것은 루프를 사용하면 번거로울 수 있습니다.\n\n해결책: 더 가독성있는 코드를 위해 `find()`와 `findIndex()`를 사용하세요.\n\n```js\nconst users = [\n{ id: 1, name: 'Jane' },\n{ id: 2, name: 'John' },\n];\nconst user = users.find(u =\u003e u.id === 1);\nconsole.log(user); // { id: 1, name: 'Jane' }\nconst index = users.findIndex(u =\u003e u.id === 1);\nconsole.log(index); // 0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 배열 메소드는 조건에 따라 요소를 찾거나 인덱스를 찾는 간단한 방법을 제공하여 코드의 가독성을 향상시킵니다.\n\n## 19. 배열 `some()` 및 `every()`\n\n문제: 배열 중 일부 또는 모든 요소가 특정 조건을 충족하는지 확인하는 것이 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 `some()` 및 `every()`를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nconst hasEven = numbers.some(num =\u003e num % 2 === 0);\nconsole.log(hasEven); // true\nconst allEven = numbers.every(num =\u003e num % 2 === 0);\nconsole.log(allEven); // false\n```\n\n이러한 배열 메소드를 사용하면 배열 내 일부 또는 모든 요소가 특정 조건을 충족하는지 간결하게 확인할 수 있습니다.\n\n## 20. 배열 `flat()` 및 `flatMap()`\n\n문제: 중첩된 배열을 평탄화하거나 배열을 매핑하고 평탄화하는 것은 번거로울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결 방법: 더 읽기 쉬운 코드를 위해 `flat()` 및 `flatMap()`을 사용하세요.\n\n```js\nconst nested = [1, [2, [3, [4]]]];\nconst flat = nested.flat(2);\nconsole.log(flat); // [1, 2, 3, [4]]\nconst mapped = [1, 2, 3].flatMap(x =\u003e [x, x * 2]);\nconsole.log(mapped); // [1, 2, 2, 4, 3, 6]\n```\n\n이러한 배열 메서드를 사용하면 중첩된 배열을 쉽게 평탄화하고 한 번에 매핑 및 평탄화할 수 있는 간단한 방법을 제공합니다.\n\n## 21. Array `from()` and `of()`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 이터러블 객체나 인수에서 배열을 만드는 것은 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 `Array.from()` 및 `Array.of()`를 사용하세요.\n\n```js\nconst set = new Set([1, 2, 3]);\nconst arrFromSet = Array.from(set);\nconsole.log(arrFromSet); // [1, 2, 3]\nconst arrOfNumbers = Array.of(1, 2, 3);\nconsole.log(arrOfNumbers); // [1, 2, 3]\n```\n\n`Array.from()`은 이터러블 객체에서 배열을 만들 수 있고, `Array.of()`은 인수 목록에서 배열을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 22. 콜백에서 파라미터 구조 분해\n\n문제점: 콜백에 전달된 객체의 속성에 접근하는 것은 장황할 수 있습니다.\n\n해결책: 더 깔끔한 코드를 위해 콜백 파라미터에서 구조 분해를 사용하세요.\n\n```js\nconst users = [\n{ id: 1, name: 'Jane' },\n{ id: 2, name: 'John' },\n];\nusers.forEach(({ id, name }) =\u003e {\nconsole.log(`User ID: ${id}, User Name: ${name}`);\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n콜백 매개변수의 구조 분해를 사용하면 콜백에 전달된 객체의 속성에 직접 액세스하여 코드를 더 간결하게 만들 수 있어요.\n\n## 23. 선택적 콜백 함수\n\n문제: 선택적 콜백 함수를 처리하는 것은 다소 까다로울 수 있어요.\n\n해결책: 선택적 콜백을 호출하기 위해 단락 평가(short-circuit evaluation)를 사용해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction fetchData(url, callback) {\n    fetch(url)\n    .then(response =\u003e response.json())\n    .then(data =\u003e {\n        callback \u0026\u0026 callback(data);\n    });\n}\n```\n\n단락평가는 제공된 경우에만 선택적 콜백 함수를 호출할 수 있게 해서 코드를 보다 견고하게 만들어줍니다.\n\n## 24. 콜백을 프로미스로 변환하기\n\n문제: 콜백을 기반으로 하는 함수를 프로미스로 변환하는 것은 어려울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 유틸리티 함수를 사용하여 콜백을 Promisify합니다.\n\n```js\nfunction promisify(fn) {\nreturn function (…args) {\nreturn new Promise((resolve, reject) =\u003e {\nfn(…args, (err, result) =\u003e {\nif (err) reject(err);\nelse resolve(result);\n});\n});\n};\n}\nconst readFile = promisify(require('fs').readFile);\nreadFile('path/to/file.txt', 'utf8')\n.then(data =\u003e console.log(data))\n.catch(err =\u003e console.error(err));\n```\n\n프로미스화를 통해 콜백 기반 함수를 프로미스로 변환하여 비동기/대기 문법과 함께 사용할 수 있게 만들어줍니다.\n\n## 25. 동기적인 코드를 위한 Async/Await\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제점: Promise를 사용한 비동기 코드 작성은 길고 읽기 어렵습니다.\n\n해결책: async/await를 사용하여 동기적인 스타일로 비동기 코드를 작성하세요.\n\n```js\nasync function fetchData(url) {\ntry {\nconst response = await fetch(url);\nconst data = await response.json();\nconsole.log(data);\n} catch (error) {\nconsole.error('데이터를 불러오는 중 오류가 발생했습니다:', error);\n}\n}\nfetchData('https://api.example.com/data');\n```\n\nAsync/await는 비동기 코드를 동기 코드처럼 작성하고 동작하도록 하는 방법을 제공하여 가독성과 유지보수성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 26. Promises 연쇄하기\n\n문제 : 여러 비동기 작업을 순차적으로 처리하는 것은 번거로울 수 있습니다.\n\n해결책 : Promises를 연쇄하여 여러 비동기 작업을 처리하세요.\n\n```js\nfetch('https://api.example.com/data')\n.then(response =\u003e response.json())\n.then(data =\u003e {\n    console.log('데이터:', data);\n    return fetch('https://api.example.com/more-data');\n})\n.then(response =\u003e response.json())\n.then(moreData =\u003e {\n    console.log('더 많은 데이터:', moreData);\n})\n.catch(error =\u003e {\n    console.error('에러:', error);\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**Promise를 연결하는 것은 여러 비동기 작업을 순차적으로 처리할 수 있어 가독성과 유지 보수성을 향상시킬 수 있습니다.**\n\n## 27. 동시 실행을 위한 Promise.all\n\n문제: 여러 비동기 작업을 동시에 처리하는 것은 어려울 수 있습니다.\n\n해결책: `Promise.all`을 사용하여 동시에 비동기 작업을 처리하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst fetchData1 = fetch('https://api.example.com/data1').then(response =\u003e response.json());\nconst fetchData2 = fetch('https://api.example.com/data2').then(response =\u003e response.json());\nPromise.all([fetchData1, fetchData2])\n.then(([data1, data2]) =\u003e {\nconsole.log('Data 1:', data1);\nconsole.log('Data 2:', data2);\n})\n.catch(error =\u003e {\nconsole.error('Error:', error);\n});\n```\n\n`Promise.all`을 사용하면 여러 비동기 작업을 동시에 처리하고 모두 완료될 때 진행할 수 있습니다.\n\n## 28. 디바운스 함수\n\n문제: 창 크기 조절과 같은 빈번한 함수 호출은 성능을 저하시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: debounce 함수를 사용하여 함수가 실행되는 속도를 제한합니다.\n\n```js\nfunction debounce(func, wait) {\n  let timeout;\n  return function (...args) {\n    clearTimeout(timeout);\n    timeout = setTimeout(() =\u003e func.apply(this, args), wait);\n  };\n}\nwindow.addEventListener('resize', debounce(() =\u003e {\n  console.log('창 크기 조정됨');\n}, 200));\n```\n\ndebounce 함수는 일정 시간 동안 활동이 없을 때에만 함수가 호출되도록 보장하여 성능을 개선합니다.\n\n## 29. 스로틀 함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 스크롤 또는 크기 조정과 같이 빈번하게 발생하는 이벤트의 함수 실행 속도 제한.\n\n해결책: 함수 실행 속도 제한을 위해 스로틀(throttle) 함수를 사용합니다.\n\n```js\nfunction throttle(func, limit) {\n  let lastFunc;\n  let lastRan;\n  return function (...args) {\n    if (!lastRan) {\n      func.apply(this, args);\n      lastRan = Date.now();\n    } else {\n      clearTimeout(lastFunc);\n      lastFunc = setTimeout(() =\u003e {\n        if (Date.now() - lastRan \u003e= limit) {\n          func.apply(this, args);\n          lastRan = Date.now();\n        }\n      }, limit - (Date.now() - lastRan));\n    }\n  };\n}\n\nwindow.addEventListener('scroll', throttle(() =\u003e {\n  console.log('창 스크롤됨');\n}, 200));\n```\n\n스로틀 함수를 사용하면 주어진 기간에 함수가 최대 한 번 호출되도록 보장하여 빈번히 발생하는 이벤트에 대한 성능을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 30. 객체의 깊은 복제\n\n문제: 중첩된 객체를 복제하는 것은 까다롭고 오류가 발생하기 쉽습니다.\n\n해결책: 구조화된 복제 또는 Lodash와 같은 라이브러리를 사용하여 객체를 깊게 복제하세요.\n\n```js\nconst obj = { a: 1, b: { c: 2 } };\nconst deepClone = JSON.parse(JSON.stringify(obj));\nconsole.log(deepClone); // { a: 1, b: { c: 2 } }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n깊은 복제는 중첩된 객체가 참조가 아닌 값으로 복사되어 원본 객체가 의도하지 않은 수정을 방지합니다.\n\n## 31. 메모이제이션\n\n문제: 비싼 함수를 반복 호출하면 성능이 저하될 수 있습니다.\n\n해결책: 메모이제이션을 사용하여 비싼 함수 호출의 결과를 캐시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction memoize(func) {\nconst cache = new Map();\nreturn function (...args) {\nconst key = JSON.stringify(args);\nif (cache.has(key)) {\nreturn cache.get(key);\n}\nconst result = func.apply(this, args);\ncache.set(key, result);\nreturn result;\n};\n}\nconst expensiveFunction = memoize((num) =\u003e {\nconsole.log('계산 중…');\nreturn num * 2;\n});\nconsole.log(expensiveFunction(2)); // \"계산 중…\" 4\nconsole.log(expensiveFunction(2)); // 4\n```\n\n메모이제이션은 비용이 많이 드는 함수 호출의 결과를 캐싱하여 동일한 인수로의 후속 호출에 대해 캐시된 결과를 반환함으로써 성능을 향상시킵니다.\n\n## 32. 함수 커링\n\n문제: 여러 개의 매개변수를 가진 함수를 생성하는 것은 번거로울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 커링을 사용하여 부분적으로 적용된 매개변수를 가진 함수를 만드세요.\n\n```js\nfunction curry(func) {\nreturn function curried(…args) {\nif (args.length \u003e= func.length) {\nreturn func.apply(this, args);\n}\nreturn function (…nextArgs) {\nreturn curried.apply(this, args.concat(nextArgs));\n};\n};\n}\nconst sum = (a, b, c) =\u003e a + b + c;\nconst curriedSum = curry(sum);\nconsole.log(curriedSum(1)(2)(3)); // 6\nconsole.log(curriedSum(1, 2)(3)); // 6\n```\n\n커링을 사용하면 더 적은 매개변수로 호출할 수 있는 함수를 생성하여 나머지 매개변수를 받는 새 함수를 반환할 수 있습니다.\n\n## 33. 부분 적용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 반복적인 인자로 함수를 호출하는 것은 귀찮을 수 있습니다.\n\n해결책: 일부 인자를 함수에 미리 적용하기 위해 부분 적용을 사용하십시오.\n\n```js\nfunction partial(func, ...presetArgs) {\nreturn function (...laterArgs) {\nreturn func(...presetArgs, ...laterArgs);\n};\n}\nconst multiply = (a, b, c) =\u003e a * b * c;\nconst double = partial(multiply, 2);\nconsole.log(double(3, 4)); // 24\n```\n\n부분 적용을 사용하면 일부 인자를 미리 적용하여 새로운 함수를 만들 수 있어 코드를 더 유연하고 재사용 가능하게 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n34. 함수 합성\n\n문제: 여러 함수를 단일 작업으로 결합하는 것은 번거로울 수 있습니다.\n\n해결책: 여러 함수를 결합하기 위해 함수 합성을 사용하세요.\n\n```js\nconst compose = (…funcs) =\u003e (arg) =\u003e\nfuncs.reduceRight((prev, fn) =\u003e fn(prev), arg);\nconst add = (x) =\u003e x + 1;\nconst multiply = (x) =\u003e x * 2;\nconst addThenMultiply = compose(multiply, add);\nconsole.log(addThenMultiply(5)); // 12\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수 합성을 사용하면 여러 함수를 결합하여 새로운 함수를 만들어 코드를 더 모듈식으로 만들고 재사용할 수 있습니다.\n\n## 35. 함수 파이프라이닝\n\n문제: 값에 일련의 함수를 적용하는 것이 장황할 수 있습니다.\n\n해결책: 함수 파이프라이닝을 사용하여 일련의 함수를 순차적으로 적용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst pipe = (...funcs) =\u003e (arg) =\u003e\nfuncs.reduce((prev, fn) =\u003e fn(prev), arg);\nconst add = (x) =\u003e x + 1;\nconst multiply = (x) =\u003e x * 2;\nconst addThenMultiply = pipe(add, multiply);\nconsole.log(addThenMultiply(5)); // 12\n```\n\n함수 파이프 라이닝을 사용하면 코드의 가독성과 유지 관리성을 높일 수 있습니다.\n\n## 36. 스스로 호출하는 함수\n\n문제: 정의할 때 즉시 함수를 실행하는 것은 번거로울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션: 즉시 실행 함수 표현식(IIFE)을 사용하세요.\n\n```js\n(function () {\nconsole.log('즉시 실행됩니다!');\n})();\n```\nIIFE를 사용하면 함수를 정의하는 즉시 실행할 수 있어서, 격리된 스코프를 만들고 전역 네임스페이스를 오염시키는 것을 피할 수 있습니다.\n\n## 37. 전역 변수 사용을 피하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 전역 변수는 충돌과 의도치 않은 부작용을 일으킬 수 있습니다.\n\n해결책: 전역 이름 공간을 오염시키지 않도록 지역 변수와 모듈을 사용하세요.\n\n```js\n// 지역 변수 사용\nfunction doSomething() {\n    let localVariable = '지역 변수입니다';\n    console.log(localVariable);\n}\n// 모듈 사용\nconst myModule = (function () {\n    let privateVariable = '비공개 변수입니다';\n    return {\n        publicMethod() {\n            console.log(privateVariable);\n        },\n    };\n})();\nmyModule.publicMethod(); // \"비공개 변수입니다\"\n```\n\n전역 변수를 피함으로써 충돌과 의도하지 않은 부작용을 방지하고, 코드를 모듈화하고 유지보수하기 쉽도록 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 38. 클로저를 사용한 캡슐화\n\n문제: 함수의 내부 세부 정보를 노출하면 남용될 수 있습니다.\n\n해결책: 클로저를 사용하여 내부 세부 정보를 캡슐화합니다.\n\n```js\nfunction createCounter() {\nlet count = 0;\nreturn {\nincrement() {\ncount++;\nreturn count;\n},\ndecrement() {\ncount--;\nreturn count;\n},\n};\n}\nconst counter = createCounter();\nconsole.log(counter.increment()); // 1\nconsole.log(counter.increment()); // 2\nconsole.log(counter.decrement()); // 1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클로저를 사용하면 내부 세부 정보를 캡슐화하고 필요한 기능만 노출하여 코드 보안 및 유지 보수성을 향상시킬 수 있어요.\n\n## 39. 모듈 패턴\n\n문제: 코드를 재사용 가능한 모듈로 구성하는 것은 challenging할 수 있어요.\n\n해결책: 모듈 패턴을 사용하여 재사용 가능하고 캡슐화된 코드를 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst myModule = (function () {\nlet privateVariable = 'This is private';\nfunction privateMethod() {\nconsole.log(privateVariable);\n}\nreturn {\npublicMethod() {\nprivateMethod();\n},\n};\n})();\nmyModule.publicMethod(); // \"This is private\"\n```\n\n모듈 패턴을 사용하면 재사용 가능하고 캡슐화된 코드를 작성할 수 있어 코드 구성과 유지보수를 개선할 수 있어요.\n\n## 40. 싱글톤 패턴\n\n문제: 클래스의 인스턴스가 하나만 생성되도록 보장하는 것은 도전적일 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결책: 싱글톤 패턴을 사용하여 단일 인스턴스를 생성하세요.\n\n```js\nconst singleton = (function () {\nlet instance;\nfunction createInstance() {\nreturn {\nname: '싱글톤 인스턴스',\n};\n}\nreturn {\ngetInstance() {\nif (!instance) {\ninstance = createInstance();\n}\nreturn instance;\n},\n};\n})();\nconst instance1 = singleton.getInstance();\nconst instance2 = singleton.getInstance();\nconsole.log(instance1 === instance2); // true\n```\n\n싱글톤 패턴은 클래스의 단일 인스턴스만 생성되도록 보장하며, 공유 리소스 또는 구성을 관리하는 데 유용합니다.\n\n## 41. 팩토리 패턴\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 복잡한 초기화가 필요한 객체를 생성하는 것은 귀찮을 수 있습니다.\n\n해결책: 팩토리 패턴을 사용하여 객체를 생성하세요.\n\n```js\nfunction createUser(name, role) {\nreturn {\nname,\nrole,\nsayHello() {\nconsole.log(`안녕하세요, 제 이름은 ${this.name}이고 ${this.role}입니다.`);\n},\n};\n}\nconst admin = createUser('Alice', 'admin');\nconst user = createUser('Bob', 'user');\nadmin.sayHello(); // \"안녕하세요, 제 이름은 Alice이고 admin입니다.\"\nuser.sayHello(); // \"안녕하세요, 제 이름은 Bob이고 user입니다.\"\n```\n\n팩토리 패턴을 사용하면 유연하고 재사용 가능한 방식으로 복잡한 초기화가 필요한 객체를 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 42. 관찰자 패턴\n\n문제: 상태 변경을 관리하고 여러 구성 요소에 알릴 때 어려울 수 있습니다.\n\n해결책: 관찰자 패턴을 사용하여 상태 변경을 관리하고 관찰자에게 알립니다.\n\n```js\nfunction Subject() {\nthis.observers = [];\n}\nSubject.prototype = {\nsubscribe(observer) {\nthis.observers.push(observer);\n},\nunsubscribe(observer) {\nthis.observers = this.observers.filter((obs) =\u003e obs !== observer);\n},\nnotify(data) {\nthis.observers.forEach((observer) =\u003e observer.update(data));\n},\n};\nfunction Observer(name) {\nthis.name = name;\n}\nObserver.prototype.update = function (data) {\nconsole.log(`${this.name} received data: ${data}`);\n};\nconst subject = new Subject();\nconst observer1 = new Observer('Observer 1');\nconst observer2 = new Observer('Observer 2');\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\nsubject.notify('새로운 데이터 이용 가능'); // \"Observer 1 received data: 새로운 데이터 이용 가능\" \"Observer 2 received data: 새로운 데이터 이용 가능\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n옵저버 패턴을 사용하면 상태 변경을 관리하고 여러 옵저버에게 알림을 보내어 코드 구성 및 유지 관리를 개선할 수 있어요.\n\n## 43. 이벤트 위임\n\n문제: 여러 요소에 이벤트 리스너를 추가하면 성능이 저하될 수 있어요.\n\n해결책: 이벤트 위임을 사용하여 이벤트를 효율적으로 관리하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndocument.getElementById('parent').addEventListener('click', (event) =\u003e {\nif (event.target \u0026\u0026 event.target.matches('button.className')) {\nconsole.log('Button clicked:', event.target.textContent);\n}\n});\n```\n\n이벤트 위임을 사용하면 공통 상위 요소에 하나의 이벤트 리스너를 추가하여 여러 하위 요소의 이벤트를 효율적으로 처리할 수 있습니다.\n\n## 44. `eval()` 사용 피하기\n\n문제: `eval()` 사용은 보안 취약점과 성능 문제를 야기할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해결 방법: `eval()`을 사용하지 말고 더 안전한 대안을 사용하세요.\n\n```js\n// 피하십시오\nconst code = 'console.log(\"Hello, world!\")';\neval(code); // \"Hello, world!\"\n// 더 안전한 대안 사용\nconst func = new Function('console.log(\"Hello, world!\")');\nfunc(); // \"Hello, world!\"\n```\n\n`eval()`을 피함으로써 보안 취약성과 성능 문제를 방지하고 코드를 더 안전하고 효율적으로 만들 수 있습니다.\n\n## 45. `for…of`를 사용하여 반복하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제: 'for...in'을 사용하여 배열을 반복하는 것은 오류가 발생할 수 있습니다.\n\n해결책: 배열 및 기타 반복 가능한 객체를 반복하는 데는 'for...of'를 사용하십시오.\n\n```js\nconst arr = [1, 2, 3, 4, 5];\nfor (const value of arr) {\nconsole.log(value);\n}\n// 1\n// 2\n// 3\n// 4\n// 5\n```\n\n`for...of`는 간단하고 안전한 방법을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png"},"coverImage":"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png","tag":["Tech"],"readingTime":21},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow_0.png\"\u003e\n\u003cp\u003e자바스크립트는 현대 웹 개발에서 필수적인 다목적 강력한 언어입니다. 이 글에서는 여러분을 더 효율적이고 효과적인 자바스크립트 개발자로 만들어 줄 수 있는 슈퍼 해킹 기술들을 소개하고 각각에 대한 상세한 설명과 예제를 제공합니다.\u003c/p\u003e\n\u003ch2\u003e1. \u003ccode\u003evar\u003c/code\u003e 대신 \u003ccode\u003elet\u003c/code\u003e 및 \u003ccode\u003econst\u003c/code\u003e 사용하기\u003c/h2\u003e\n\u003cp\u003e문제: \u003ccode\u003evar\u003c/code\u003e은 함수 범위를 가지고 있어서 버그와 예상치 못한 동작을 유발할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e해결책: 블록 스코프를 갖는 \u003ccode\u003elet\u003c/code\u003e과 \u003ccode\u003econst\u003c/code\u003e를 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e count = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePI\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e3.14\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003elet\u003c/code\u003e과 \u003ccode\u003econst\u003c/code\u003e를 사용하면 변수를 정의된 블록 내에서만 접근할 수 있도록 하여 스코프 관련 버그를 방지할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e2. 기본 매개변수\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제: 인수가 제공되지 않으면 함수가 실패할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 기본 매개변수를 사용하여 대안 값 설정.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename = \u003cspan class=\"hljs-string\"\u003e'방문자'\u003c/span\u003e\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`안녕하세요, \u003cspan class=\"hljs-subst\"\u003e${name}\u003c/span\u003e님!`\u003c/span\u003e;\n}\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// \"안녕하세요, 방문자님!\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기본 매개변수를 사용하면 함수가 합리적인 기본값을 갖도록되어 오류를 방지하고 코드를 더 견고하게 만듭니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e3. 템플릿 리터럴\u003c/h2\u003e\n\u003cp\u003e문제: 문자열 연결은 번거로우며 오류가 발생하기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 더 깔끔하고 가독성이 좋은 문자열 보간을 위해 템플릿 리터럴을 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e'John'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e greeting = \u003cspan class=\"hljs-string\"\u003e`Hello, \u003cspan class=\"hljs-subst\"\u003e${name}\u003c/span\u003e!`\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(greeting); \u003cspan class=\"hljs-comment\"\u003e// \"Hello, John!\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e템플릿 리터럴을 사용하면 포함된 표현식과 여러 줄의 문자열을 쉽게 만들 수 있어요.\u003c/p\u003e\n\u003ch2\u003e4. 비구조화 할당\u003c/h2\u003e\n\u003cp\u003e문제: 객체와 배열에서 값 추출하는 과정이 장황할 수 있어요.\u003c/p\u003e\n\u003cp\u003e해결책: 비구조화 할당을 사용해서 값을 더 간결하게 추출하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Jane'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { name, age } = user;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(name, age); \u003cspan class=\"hljs-comment\"\u003e// \"Jane\" 25\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e구조 분해 할당을 사용하면 객체에서 속성을 추출하고 배열에서 요소를 쉽게 각각의 변수로 추출할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e5. 화살표 함수\u003c/h2\u003e\n\u003cp\u003e문제: 기존 함수 표현식은 장황할 수 있고 \u003ccode\u003ethis\u003c/code\u003e를 렉시컬하게 바인딩하지 않습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e솔루션: 더 짧은 구문을 위해 화살표 함수를 사용하고 렉시컬 \u003ccode\u003ethis\u003c/code\u003e를 활용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003ea, b\u003c/span\u003e) =\u003e a + b;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 5\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e화살표 함수는 함수 표현식에 대해 간결한 구문을 제공하며 \u003ccode\u003ethis\u003c/code\u003e가 렉시컬하게 바인딩되어 있는지 보장합니다.\u003c/p\u003e\n\u003ch2\u003e6. 전개 연산자\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제: 배열이나 객체를 결합하는 것은 번거로울 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 전개 연산자를 사용하여 배열과 객체를 쉽게 결합하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr1 = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr2 = [\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e combined = […arr1, …arr2];\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(combined); \u003cspan class=\"hljs-comment\"\u003e// [1, 2, 3, 4, 5, 6]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e전개 연산자를 사용하면 배열이나 객체의 요소를 다른 배열이나 객체로 전개할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e7. 나머지 매개변수\u003c/h2\u003e\n\u003cp\u003e문제: 함수에 변수 수의 인수를 처리하는 것은 까다로울 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 모든 인수를 배열에 캡처하기 위해 나머지 매개변수를 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esum\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e…args\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e args.\u003cspan class=\"hljs-title function_\"\u003ereduce\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003etotal, num\u003c/span\u003e) =\u003e\u003c/span\u003e total + num, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n}\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003esum\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 10\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e레스트 매개변수를 사용하면 매개변수의 개수에 상관없이 배열로 처리할 수 있어 함수를 보다 유연하게 만들 수 있어요.\u003c/p\u003e\n\u003ch2\u003e8. 단락 평가\u003c/h2\u003e\n\u003cp\u003e문제: 조건문을 작성하는 것은 매우 번거로울 수 있어요.\u003c/p\u003e\n\u003cp\u003e해결책: 간결한 조건을 작성하기 위해 단락 평가를 활용해보세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isLoggedIn = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = isLoggedIn \u0026#x26;\u0026#x26; { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Jane'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e };\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(user); \u003cspan class=\"hljs-comment\"\u003e// { name: 'Jane', age: 25 }\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e단축 평가는 논리적 \u003ccode\u003e\u0026#x26;\u0026#x26;\u003c/code\u003e 및 \u003ccode\u003e||\u003c/code\u003e 연산자를 사용하여 조건식을 간단하게 만듭니다.\u003c/p\u003e\n\u003ch2\u003e9. 선택적 체이닝\u003c/h2\u003e\n\u003cp\u003e문제: 깊게 중첩된 속성에 액세스하는 것은 체인의 일부가 \u003ccode\u003enull\u003c/code\u003e 또는 \u003ccode\u003eundefined\u003c/code\u003e인 경우 오류를 발생시킬 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e해결책: 중첩된 속성에 안전하게 접근하기 위해 선택적 체이닝을 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = { \u003cspan class=\"hljs-attr\"\u003eprofile\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Jane'\u003c/span\u003e } };\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userName = user?.\u003cspan class=\"hljs-property\"\u003eprofile\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(userName); \u003cspan class=\"hljs-comment\"\u003e// \"Jane\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e선택적 체이닝을 사용하면 \u003ccode\u003enull\u003c/code\u003e 또는 \u003ccode\u003eundefined\u003c/code\u003e인지 명시적으로 확인하지 않고도 중첩된 속성에 안전하게 접근할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e10. 널리쉬 콜리싱\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제: \u003ccode\u003e||\u003c/code\u003e를 사용하여 기본 값을 제공하는 경우, 값이 \u003ccode\u003e0\u003c/code\u003e 또는 \u003ccode\u003e\"\"\u003c/code\u003e이면 예상치 못한 결과가 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: \u003ccode\u003enullish coalescing\u003c/code\u003e (\u003ccode\u003e??\u003c/code\u003e)을 사용하여 \u003ccode\u003enull\u003c/code\u003e 또는 \u003ccode\u003eundefined\u003c/code\u003e일 때만 기본 값을 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userName = user.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e ?? \u003cspan class=\"hljs-string\"\u003e'익명'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userAge = user.\u003cspan class=\"hljs-property\"\u003eage\u003c/span\u003e ?? \u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(userName); \u003cspan class=\"hljs-comment\"\u003e// \"\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(userAge); \u003cspan class=\"hljs-comment\"\u003e// 0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eNullish coalescing\u003c/code\u003e은 왼쪽 피연산자가 \u003ccode\u003enull\u003c/code\u003e 또는 \u003ccode\u003eundefined\u003c/code\u003e일 때에만 기본 값을 제공할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e11. 객체 속성 축약\u003c/h2\u003e\n\u003cp\u003e문제: 객체 속성에 변수를 할당하는 작업이 반복적 일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 속성 축약을 사용하여 객체 생성을 간단하게 만듭니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e'Jane'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e age = \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = { name, age };\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(user); \u003cspan class=\"hljs-comment\"\u003e// { name: 'Jane', age: 25 }\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e프로퍼티 축약형을 사용하면 변수 이름과 일치할 때 프로퍼티 이름을 생략할 수 있어서 코드가 더 깔끔해집니다.\u003c/p\u003e\n\u003ch2\u003e12. 동적 프로퍼티 이름\u003c/h2\u003e\n\u003cp\u003e문제: 동적 프로퍼티 이름으로 객체를 생성하는 것은 다소 장황할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 계산된 프로퍼티 이름을 사용하여 동적으로 객체 프로퍼티를 생성하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e propName = \u003cspan class=\"hljs-string\"\u003e'나이'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = { 이름: \u003cspan class=\"hljs-string\"\u003e'제인'\u003c/span\u003e, [propName]: \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e };\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(user); \u003cspan class=\"hljs-comment\"\u003e// { 이름: '제인', 나이: 25 }\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e계산된 속성 이름을 사용하면 식의 값으로 속성 이름을 동적으로 만들 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e13. 배열 \u003ccode\u003emap()\u003c/code\u003e, \u003ccode\u003efilter()\u003c/code\u003e, 및 \u003ccode\u003ereduce()\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e문제: 배열을 변환, 필터링 또는 값 누적하기 위해 배열을 반복하는 작업은 반복적일 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e솔루션: 일반적인 배열 작업에 \u003ccode\u003emap()\u003c/code\u003e, \u003ccode\u003efilter()\u003c/code\u003e, 및 \u003ccode\u003ereduce()\u003c/code\u003e를 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e numbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e doubled = numbers.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e =\u003e\u003c/span\u003e num * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(doubled); \u003cspan class=\"hljs-comment\"\u003e// [2, 4, 6, 8, 10]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e evens = numbers.\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e =\u003e\u003c/span\u003e num % \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(evens); \u003cspan class=\"hljs-comment\"\u003e// [2, 4]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sum = numbers.\u003cspan class=\"hljs-title function_\"\u003ereduce\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003etotal, num\u003c/span\u003e) =\u003e\u003c/span\u003e total + num, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(sum); \u003cspan class=\"hljs-comment\"\u003e// 15\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 배열 메서드들은 배열을 변환하고 필터링하며 줄이는 함수적인 방식을 제공하여, 코드를 더 표현적이고 간결하게 만듭니다.\u003c/p\u003e\n\u003ch2\u003e14. 문자열 \u003ccode\u003eincludes()\u003c/code\u003e, \u003ccode\u003estartsWith()\u003c/code\u003e, 및 \u003ccode\u003eendsWith()\u003c/code\u003e\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제: 문자열에 특정 부분 문자열이 포함되어 있는지, 시작하는지 또는 끝나는지를 확인하는 작업은 장황할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 더 간단한 문자열 확인을 위해 \u003ccode\u003eincludes()\u003c/code\u003e, \u003ccode\u003estartsWith()\u003c/code\u003e, \u003ccode\u003eendsWith()\u003c/code\u003e를 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e str = \u003cspan class=\"hljs-string\"\u003e'Hello, world!'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(str.\u003cspan class=\"hljs-title function_\"\u003eincludes\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'world'\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(str.\u003cspan class=\"hljs-title function_\"\u003estartsWith\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Hello'\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(str.\u003cspan class=\"hljs-title function_\"\u003eendsWith\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'!'\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 문자열 메소드들은 부분 문자열의 존재, 시작 또는 끝을 확인하는 간단하고 가독성 있는 방법을 제공합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e15. 함수 매개변수에서 배열 및 객체 비구조화\u003c/h2\u003e\n\u003cp\u003e문제: 함수 매개변수로 전달된 배열 또는 객체에서 값을 추출하는 것은 장황할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 함수 매개변수에서 비구조화를 사용하여 값을 직접 추출하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Jane'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ name, age }\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`안녕, \u003cspan class=\"hljs-subst\"\u003e${name}\u003c/span\u003e! 당신은 \u003cspan class=\"hljs-subst\"\u003e${age}\u003c/span\u003e살 입니다.`\u003c/span\u003e;\n}\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e(user)); \u003cspan class=\"hljs-comment\"\u003e// \"안녕, Jane! 당신은 25살 입니다.\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e함수 매개변수의 구조 분해를 사용하면 함수에 전달된 객체나 배열에서 값을 직접 추출하여 코드를 더 간결하고 가독성 있게 만들 수 있어요.\u003c/p\u003e\n\u003ch2\u003e16. 구조 분해에서 기본값 활용\u003c/h2\u003e\n\u003cp\u003e문제: 객체의 구조 분해 시 누락된 속성을 다루는 것은 복잡할 수 있어요.\u003c/p\u003e\n\u003cp\u003e해결책: 구조 분해에서 기본값을 사용하여 대체 값을 제공해요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Jane'\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { name, age = \u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e } = user;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(name); \u003cspan class=\"hljs-comment\"\u003e// \"Jane\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(age); \u003cspan class=\"hljs-comment\"\u003e// 18\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e구조 분해 안에 기본 값(default values)을 설정하면 누락될 수 있는 속성에 대한 대체 값을 제공할 수 있어 코드를 보다 견고하게 만들어줍니다.\u003c/p\u003e\n\u003ch2\u003e17. Object \u003ccode\u003eassign()\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e문제: 객체를 복제하거나 병합하는 것은 번거롭고 실수하기 쉽습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e해결 방법: \u003ccode\u003eObject.assign()\u003c/code\u003e을 사용하여 객체를 복제하거나 병합할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e target = { \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source = { \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e merged = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eassign\u003c/span\u003e(target, source);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(merged); \u003cspan class=\"hljs-comment\"\u003e// { a: 1, b: 2 }\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eObject.assign()\u003c/code\u003e을 사용하면 객체를 효율적으로 복제하거나 병합할 수 있어서 수동 복사가 필요한 경우를 줄일 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e18. Array \u003ccode\u003efind()\u003c/code\u003e 및 \u003ccode\u003efindIndex()\u003c/code\u003e\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제: 배열에서 요소나 인덱스를 찾는 것은 루프를 사용하면 번거로울 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 더 가독성있는 코드를 위해 \u003ccode\u003efind()\u003c/code\u003e와 \u003ccode\u003efindIndex()\u003c/code\u003e를 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = [\n{ \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Jane'\u003c/span\u003e },\n{ \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'John'\u003c/span\u003e },\n];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = users.\u003cspan class=\"hljs-title function_\"\u003efind\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eu\u003c/span\u003e =\u003e\u003c/span\u003e u.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(user); \u003cspan class=\"hljs-comment\"\u003e// { id: 1, name: 'Jane' }\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e index = users.\u003cspan class=\"hljs-title function_\"\u003efindIndex\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eu\u003c/span\u003e =\u003e\u003c/span\u003e u.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(index); \u003cspan class=\"hljs-comment\"\u003e// 0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이러한 배열 메소드는 조건에 따라 요소를 찾거나 인덱스를 찾는 간단한 방법을 제공하여 코드의 가독성을 향상시킵니다.\u003c/p\u003e\n\u003ch2\u003e19. 배열 \u003ccode\u003esome()\u003c/code\u003e 및 \u003ccode\u003eevery()\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e문제: 배열 중 일부 또는 모든 요소가 특정 조건을 충족하는지 확인하는 것이 장황할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 더 깔끔한 코드를 위해 \u003ccode\u003esome()\u003c/code\u003e 및 \u003ccode\u003eevery()\u003c/code\u003e를 사용하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e numbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hasEven = numbers.\u003cspan class=\"hljs-title function_\"\u003esome\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e =\u003e\u003c/span\u003e num % \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(hasEven); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e allEven = numbers.\u003cspan class=\"hljs-title function_\"\u003eevery\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e =\u003e\u003c/span\u003e num % \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(allEven); \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 배열 메소드를 사용하면 배열 내 일부 또는 모든 요소가 특정 조건을 충족하는지 간결하게 확인할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e20. 배열 \u003ccode\u003eflat()\u003c/code\u003e 및 \u003ccode\u003eflatMap()\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e문제: 중첩된 배열을 평탄화하거나 배열을 매핑하고 평탄화하는 것은 번거로울 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e해결 방법: 더 읽기 쉬운 코드를 위해 \u003ccode\u003eflat()\u003c/code\u003e 및 \u003ccode\u003eflatMap()\u003c/code\u003e을 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nested = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e]]]];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e flat = nested.\u003cspan class=\"hljs-title function_\"\u003eflat\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(flat); \u003cspan class=\"hljs-comment\"\u003e// [1, 2, 3, [4]]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mapped = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eflatMap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u003e\u003c/span\u003e [x, x * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(mapped); \u003cspan class=\"hljs-comment\"\u003e// [1, 2, 2, 4, 3, 6]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 배열 메서드를 사용하면 중첩된 배열을 쉽게 평탄화하고 한 번에 매핑 및 평탄화할 수 있는 간단한 방법을 제공합니다.\u003c/p\u003e\n\u003ch2\u003e21. Array \u003ccode\u003efrom()\u003c/code\u003e and \u003ccode\u003eof()\u003c/code\u003e\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제: 이터러블 객체나 인수에서 배열을 만드는 것은 장황할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 더 깔끔한 코드를 위해 \u003ccode\u003eArray.from()\u003c/code\u003e 및 \u003ccode\u003eArray.of()\u003c/code\u003e를 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e set = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arrFromSet = \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(set);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arrFromSet); \u003cspan class=\"hljs-comment\"\u003e// [1, 2, 3]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arrOfNumbers = \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arrOfNumbers); \u003cspan class=\"hljs-comment\"\u003e// [1, 2, 3]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eArray.from()\u003c/code\u003e은 이터러블 객체에서 배열을 만들 수 있고, \u003ccode\u003eArray.of()\u003c/code\u003e은 인수 목록에서 배열을 만들 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e22. 콜백에서 파라미터 구조 분해\u003c/h2\u003e\n\u003cp\u003e문제점: 콜백에 전달된 객체의 속성에 접근하는 것은 장황할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 더 깔끔한 코드를 위해 콜백 파라미터에서 구조 분해를 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = [\n{ \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Jane'\u003c/span\u003e },\n{ \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'John'\u003c/span\u003e },\n];\nusers.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ id, name }\u003c/span\u003e) =\u003e\u003c/span\u003e {\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`User ID: \u003cspan class=\"hljs-subst\"\u003e${id}\u003c/span\u003e, User Name: \u003cspan class=\"hljs-subst\"\u003e${name}\u003c/span\u003e`\u003c/span\u003e);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e콜백 매개변수의 구조 분해를 사용하면 콜백에 전달된 객체의 속성에 직접 액세스하여 코드를 더 간결하게 만들 수 있어요.\u003c/p\u003e\n\u003ch2\u003e23. 선택적 콜백 함수\u003c/h2\u003e\n\u003cp\u003e문제: 선택적 콜백 함수를 처리하는 것은 다소 까다로울 수 있어요.\u003c/p\u003e\n\u003cp\u003e해결책: 선택적 콜백을 호출하기 위해 단락 평가(short-circuit evaluation)를 사용해주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eurl, callback\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(url)\n    .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u003e\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n    .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u003e\u003c/span\u003e {\n        callback \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-title function_\"\u003ecallback\u003c/span\u003e(data);\n    });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e단락평가는 제공된 경우에만 선택적 콜백 함수를 호출할 수 있게 해서 코드를 보다 견고하게 만들어줍니다.\u003c/p\u003e\n\u003ch2\u003e24. 콜백을 프로미스로 변환하기\u003c/h2\u003e\n\u003cp\u003e문제: 콜백을 기반으로 하는 함수를 프로미스로 변환하는 것은 어려울 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e솔루션: 유틸리티 함수를 사용하여 콜백을 Promisify합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epromisify\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efn\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e…args\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve, reject\u003c/span\u003e) =\u003e\u003c/span\u003e {\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(…args, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerr, result\u003c/span\u003e) =\u003e\u003c/span\u003e {\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) \u003cspan class=\"hljs-title function_\"\u003ereject\u003c/span\u003e(err);\n\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(result);\n});\n});\n};\n}\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e readFile = \u003cspan class=\"hljs-title function_\"\u003epromisify\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'fs'\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003ereadFile\u003c/span\u003e);\n\u003cspan class=\"hljs-title function_\"\u003ereadFile\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'path/to/file.txt'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'utf8'\u003c/span\u003e)\n.\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data))\n.\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(err));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e프로미스화를 통해 콜백 기반 함수를 프로미스로 변환하여 비동기/대기 문법과 함께 사용할 수 있게 만들어줍니다.\u003c/p\u003e\n\u003ch2\u003e25. 동기적인 코드를 위한 Async/Await\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제점: Promise를 사용한 비동기 코드 작성은 길고 읽기 어렵습니다.\u003c/p\u003e\n\u003cp\u003e해결책: async/await를 사용하여 동기적인 스타일로 비동기 코드를 작성하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eurl\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(url);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data);\n} \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'데이터를 불러오는 중 오류가 발생했습니다:'\u003c/span\u003e, error);\n}\n}\n\u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/data'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAsync/await는 비동기 코드를 동기 코드처럼 작성하고 동작하도록 하는 방법을 제공하여 가독성과 유지보수성을 향상시킵니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e26. Promises 연쇄하기\u003c/h2\u003e\n\u003cp\u003e문제 : 여러 비동기 작업을 순차적으로 처리하는 것은 번거로울 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책 : Promises를 연쇄하여 여러 비동기 작업을 처리하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/data'\u003c/span\u003e)\n.\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u003e\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n.\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'데이터:'\u003c/span\u003e, data);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/more-data'\u003c/span\u003e);\n})\n.\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u003e\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n.\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003emoreData\u003c/span\u003e =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'더 많은 데이터:'\u003c/span\u003e, moreData);\n})\n.\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'에러:'\u003c/span\u003e, error);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cstrong\u003ePromise를 연결하는 것은 여러 비동기 작업을 순차적으로 처리할 수 있어 가독성과 유지 보수성을 향상시킬 수 있습니다.\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003e27. 동시 실행을 위한 Promise.all\u003c/h2\u003e\n\u003cp\u003e문제: 여러 비동기 작업을 동시에 처리하는 것은 어려울 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: \u003ccode\u003ePromise.all\u003c/code\u003e을 사용하여 동시에 비동기 작업을 처리하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fetchData1 = \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/data1'\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u003e\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e());\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fetchData2 = \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'https://api.example.com/data2'\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e =\u003e\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e());\n\u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e([fetchData1, fetchData2])\n.\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e[data1, data2]\u003c/span\u003e) =\u003e\u003c/span\u003e {\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Data 1:'\u003c/span\u003e, data1);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Data 2:'\u003c/span\u003e, data2);\n})\n.\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e =\u003e\u003c/span\u003e {\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Error:'\u003c/span\u003e, error);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ePromise.all\u003c/code\u003e을 사용하면 여러 비동기 작업을 동시에 처리하고 모두 완료될 때 진행할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e28. 디바운스 함수\u003c/h2\u003e\n\u003cp\u003e문제: 창 크기 조절과 같은 빈번한 함수 호출은 성능을 저하시킬 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e해결책: debounce 함수를 사용하여 함수가 실행되는 속도를 제한합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edebounce\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efunc, wait\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e timeout;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e...args\u003c/span\u003e) {\n    \u003cspan class=\"hljs-built_in\"\u003eclearTimeout\u003c/span\u003e(timeout);\n    timeout = \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e func.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, args), wait);\n  };\n}\n\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'resize'\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003edebounce\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'창 크기 조정됨'\u003c/span\u003e);\n}, \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edebounce 함수는 일정 시간 동안 활동이 없을 때에만 함수가 호출되도록 보장하여 성능을 개선합니다.\u003c/p\u003e\n\u003ch2\u003e29. 스로틀 함수\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제: 스크롤 또는 크기 조정과 같이 빈번하게 발생하는 이벤트의 함수 실행 속도 제한.\u003c/p\u003e\n\u003cp\u003e해결책: 함수 실행 속도 제한을 위해 스로틀(throttle) 함수를 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ethrottle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efunc, limit\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e lastFunc;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e lastRan;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e...args\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!lastRan) {\n      func.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, args);\n      lastRan = \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e();\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-built_in\"\u003eclearTimeout\u003c/span\u003e(lastFunc);\n      lastFunc = \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e() - lastRan \u003e= limit) {\n          func.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, args);\n          lastRan = \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e();\n        }\n      }, limit - (\u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e() - lastRan));\n    }\n  };\n}\n\n\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'scroll'\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003ethrottle\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'창 스크롤됨'\u003c/span\u003e);\n}, \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e스로틀 함수를 사용하면 주어진 기간에 함수가 최대 한 번 호출되도록 보장하여 빈번히 발생하는 이벤트에 대한 성능을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e30. 객체의 깊은 복제\u003c/h2\u003e\n\u003cp\u003e문제: 중첩된 객체를 복제하는 것은 까다롭고 오류가 발생하기 쉽습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 구조화된 복제 또는 Lodash와 같은 라이브러리를 사용하여 객체를 깊게 복제하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = { \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003ec\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e } };\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e deepClone = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(obj));\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(deepClone); \u003cspan class=\"hljs-comment\"\u003e// { a: 1, b: { c: 2 } }\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e깊은 복제는 중첩된 객체가 참조가 아닌 값으로 복사되어 원본 객체가 의도하지 않은 수정을 방지합니다.\u003c/p\u003e\n\u003ch2\u003e31. 메모이제이션\u003c/h2\u003e\n\u003cp\u003e문제: 비싼 함수를 반복 호출하면 성능이 저하될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 메모이제이션을 사용하여 비싼 함수 호출의 결과를 캐시합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ememoize\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efunc\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e cache = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e...args\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(args);\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (cache.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(key)) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e cache.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(key);\n}\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = func.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, args);\ncache.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(key, result);\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n};\n}\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e expensiveFunction = \u003cspan class=\"hljs-title function_\"\u003ememoize\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e) =\u003e\u003c/span\u003e {\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'계산 중…'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e num * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n});\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eexpensiveFunction\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// \"계산 중…\" 4\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eexpensiveFunction\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 4\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e메모이제이션은 비용이 많이 드는 함수 호출의 결과를 캐싱하여 동일한 인수로의 후속 호출에 대해 캐시된 결과를 반환함으로써 성능을 향상시킵니다.\u003c/p\u003e\n\u003ch2\u003e32. 함수 커링\u003c/h2\u003e\n\u003cp\u003e문제: 여러 개의 매개변수를 가진 함수를 생성하는 것은 번거로울 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e솔루션: 커링을 사용하여 부분적으로 적용된 매개변수를 가진 함수를 만드세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecurry\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efunc\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecurried\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e…args\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (args.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e \u003e= func.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e func.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, args);\n}\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e…nextArgs\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e curried.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, args.\u003cspan class=\"hljs-title function_\"\u003econcat\u003c/span\u003e(nextArgs));\n};\n};\n}\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esum\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003ea, b, c\u003c/span\u003e) =\u003e a + b + c;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e curriedSum = \u003cspan class=\"hljs-title function_\"\u003ecurry\u003c/span\u003e(sum);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ecurriedSum\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 6\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ecurriedSum\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 6\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e커링을 사용하면 더 적은 매개변수로 호출할 수 있는 함수를 생성하여 나머지 매개변수를 받는 새 함수를 반환할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e33. 부분 적용\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제: 반복적인 인자로 함수를 호출하는 것은 귀찮을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 일부 인자를 함수에 미리 적용하기 위해 부분 적용을 사용하십시오.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epartial\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efunc, ...presetArgs\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e...laterArgs\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e(...presetArgs, ...laterArgs);\n};\n}\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emultiply\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003ea, b, c\u003c/span\u003e) =\u003e a * b * c;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e double = \u003cspan class=\"hljs-title function_\"\u003epartial\u003c/span\u003e(multiply, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003edouble\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 24\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e부분 적용을 사용하면 일부 인자를 미리 적용하여 새로운 함수를 만들 수 있어 코드를 더 유연하고 재사용 가능하게 만들 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"34\"\u003e\n\u003cli\u003e함수 합성\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e문제: 여러 함수를 단일 작업으로 결합하는 것은 번거로울 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 여러 함수를 결합하기 위해 함수 합성을 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecompose\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e…funcs\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003earg\u003c/span\u003e) =\u003e\u003c/span\u003e\nfuncs.\u003cspan class=\"hljs-title function_\"\u003ereduceRight\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprev, fn\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(prev), arg);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e) =\u003e x + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emultiply\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e) =\u003e x * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e addThenMultiply = \u003cspan class=\"hljs-title function_\"\u003ecompose\u003c/span\u003e(multiply, add);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eaddThenMultiply\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 12\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e함수 합성을 사용하면 여러 함수를 결합하여 새로운 함수를 만들어 코드를 더 모듈식으로 만들고 재사용할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e35. 함수 파이프라이닝\u003c/h2\u003e\n\u003cp\u003e문제: 값에 일련의 함수를 적용하는 것이 장황할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 함수 파이프라이닝을 사용하여 일련의 함수를 순차적으로 적용하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e...funcs\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003earg\u003c/span\u003e) =\u003e\u003c/span\u003e\nfuncs.\u003cspan class=\"hljs-title function_\"\u003ereduce\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprev, fn\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(prev), arg);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e) =\u003e x + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emultiply\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e) =\u003e x * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e addThenMultiply = \u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(add, multiply);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eaddThenMultiply\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 12\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e함수 파이프 라이닝을 사용하면 코드의 가독성과 유지 관리성을 높일 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e36. 스스로 호출하는 함수\u003c/h2\u003e\n\u003cp\u003e문제: 정의할 때 즉시 함수를 실행하는 것은 번거로울 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e솔루션: 즉시 실행 함수 표현식(IIFE)을 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'즉시 실행됩니다!'\u003c/span\u003e);\n})();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIIFE를 사용하면 함수를 정의하는 즉시 실행할 수 있어서, 격리된 스코프를 만들고 전역 네임스페이스를 오염시키는 것을 피할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e37. 전역 변수 사용을 피하세요\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제: 전역 변수는 충돌과 의도치 않은 부작용을 일으킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 전역 이름 공간을 오염시키지 않도록 지역 변수와 모듈을 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 지역 변수 사용\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e localVariable = \u003cspan class=\"hljs-string\"\u003e'지역 변수입니다'\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(localVariable);\n}\n\u003cspan class=\"hljs-comment\"\u003e// 모듈 사용\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myModule = (\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e privateVariable = \u003cspan class=\"hljs-string\"\u003e'비공개 변수입니다'\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_\"\u003epublicMethod\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n            \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(privateVariable);\n        },\n    };\n})();\nmyModule.\u003cspan class=\"hljs-title function_\"\u003epublicMethod\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// \"비공개 변수입니다\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e전역 변수를 피함으로써 충돌과 의도하지 않은 부작용을 방지하고, 코드를 모듈화하고 유지보수하기 쉽도록 만들 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e38. 클로저를 사용한 캡슐화\u003c/h2\u003e\n\u003cp\u003e문제: 함수의 내부 세부 정보를 노출하면 남용될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 클로저를 사용하여 내부 세부 정보를 캡슐화합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateCounter\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e count = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n\u003cspan class=\"hljs-title function_\"\u003eincrement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\ncount++;\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e count;\n},\n\u003cspan class=\"hljs-title function_\"\u003edecrement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\ncount--;\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e count;\n},\n};\n}\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e counter = \u003cspan class=\"hljs-title function_\"\u003ecreateCounter\u003c/span\u003e();\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(counter.\u003cspan class=\"hljs-title function_\"\u003eincrement\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(counter.\u003cspan class=\"hljs-title function_\"\u003eincrement\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(counter.\u003cspan class=\"hljs-title function_\"\u003edecrement\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e클로저를 사용하면 내부 세부 정보를 캡슐화하고 필요한 기능만 노출하여 코드 보안 및 유지 보수성을 향상시킬 수 있어요.\u003c/p\u003e\n\u003ch2\u003e39. 모듈 패턴\u003c/h2\u003e\n\u003cp\u003e문제: 코드를 재사용 가능한 모듈로 구성하는 것은 challenging할 수 있어요.\u003c/p\u003e\n\u003cp\u003e해결책: 모듈 패턴을 사용하여 재사용 가능하고 캡슐화된 코드를 생성하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myModule = (\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e privateVariable = \u003cspan class=\"hljs-string\"\u003e'This is private'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprivateMethod\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(privateVariable);\n}\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n\u003cspan class=\"hljs-title function_\"\u003epublicMethod\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\u003cspan class=\"hljs-title function_\"\u003eprivateMethod\u003c/span\u003e();\n},\n};\n})();\nmyModule.\u003cspan class=\"hljs-title function_\"\u003epublicMethod\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// \"This is private\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모듈 패턴을 사용하면 재사용 가능하고 캡슐화된 코드를 작성할 수 있어 코드 구성과 유지보수를 개선할 수 있어요.\u003c/p\u003e\n\u003ch2\u003e40. 싱글톤 패턴\u003c/h2\u003e\n\u003cp\u003e문제: 클래스의 인스턴스가 하나만 생성되도록 보장하는 것은 도전적일 수 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e해결책: 싱글톤 패턴을 사용하여 단일 인스턴스를 생성하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e singleton = (\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e instance;\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateInstance\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'싱글톤 인스턴스'\u003c/span\u003e,\n};\n}\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n\u003cspan class=\"hljs-title function_\"\u003egetInstance\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!instance) {\ninstance = \u003cspan class=\"hljs-title function_\"\u003ecreateInstance\u003c/span\u003e();\n}\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instance;\n},\n};\n})();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance1 = singleton.\u003cspan class=\"hljs-title function_\"\u003egetInstance\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance2 = singleton.\u003cspan class=\"hljs-title function_\"\u003egetInstance\u003c/span\u003e();\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(instance1 === instance2); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e싱글톤 패턴은 클래스의 단일 인스턴스만 생성되도록 보장하며, 공유 리소스 또는 구성을 관리하는 데 유용합니다.\u003c/p\u003e\n\u003ch2\u003e41. 팩토리 패턴\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제: 복잡한 초기화가 필요한 객체를 생성하는 것은 귀찮을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 팩토리 패턴을 사용하여 객체를 생성하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename, role\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\nname,\nrole,\n\u003cspan class=\"hljs-title function_\"\u003esayHello\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`안녕하세요, 제 이름은 \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.name}\u003c/span\u003e이고 \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.role}\u003c/span\u003e입니다.`\u003c/span\u003e);\n},\n};\n}\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e admin = \u003cspan class=\"hljs-title function_\"\u003ecreateUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Alice'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'admin'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-title function_\"\u003ecreateUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Bob'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'user'\u003c/span\u003e);\nadmin.\u003cspan class=\"hljs-title function_\"\u003esayHello\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// \"안녕하세요, 제 이름은 Alice이고 admin입니다.\"\u003c/span\u003e\nuser.\u003cspan class=\"hljs-title function_\"\u003esayHello\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// \"안녕하세요, 제 이름은 Bob이고 user입니다.\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e팩토리 패턴을 사용하면 유연하고 재사용 가능한 방식으로 복잡한 초기화가 필요한 객체를 생성할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e42. 관찰자 패턴\u003c/h2\u003e\n\u003cp\u003e문제: 상태 변경을 관리하고 여러 구성 요소에 알릴 때 어려울 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 관찰자 패턴을 사용하여 상태 변경을 관리하고 관찰자에게 알립니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eSubject\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e = [];\n}\n\u003cspan class=\"hljs-title class_\"\u003eSubject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e = {\n\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eobserver\u003c/span\u003e) {\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(observer);\n},\n\u003cspan class=\"hljs-title function_\"\u003eunsubscribe\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eobserver\u003c/span\u003e) {\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eobs\u003c/span\u003e) =\u003e\u003c/span\u003e obs !== observer);\n},\n\u003cspan class=\"hljs-title function_\"\u003enotify\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) {\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eobserver\u003c/span\u003e) =\u003e\u003c/span\u003e observer.\u003cspan class=\"hljs-title function_\"\u003eupdate\u003c/span\u003e(data));\n},\n};\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eObserver\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename\u003c/span\u003e) {\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = name;\n}\n\u003cspan class=\"hljs-title class_\"\u003eObserver\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eupdate\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) {\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.name}\u003c/span\u003e received data: \u003cspan class=\"hljs-subst\"\u003e${data}\u003c/span\u003e`\u003c/span\u003e);\n};\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subject = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSubject\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e observer1 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObserver\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Observer 1'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e observer2 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObserver\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Observer 2'\u003c/span\u003e);\nsubject.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(observer1);\nsubject.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(observer2);\nsubject.\u003cspan class=\"hljs-title function_\"\u003enotify\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'새로운 데이터 이용 가능'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"Observer 1 received data: 새로운 데이터 이용 가능\" \"Observer 2 received data: 새로운 데이터 이용 가능\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e옵저버 패턴을 사용하면 상태 변경을 관리하고 여러 옵저버에게 알림을 보내어 코드 구성 및 유지 관리를 개선할 수 있어요.\u003c/p\u003e\n\u003ch2\u003e43. 이벤트 위임\u003c/h2\u003e\n\u003cp\u003e문제: 여러 요소에 이벤트 리스너를 추가하면 성능이 저하될 수 있어요.\u003c/p\u003e\n\u003cp\u003e해결책: 이벤트 위임을 사용하여 이벤트를 효율적으로 관리하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'parent'\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'click'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u003e\u003c/span\u003e {\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (event.\u003cspan class=\"hljs-property\"\u003etarget\u003c/span\u003e \u0026#x26;\u0026#x26; event.\u003cspan class=\"hljs-property\"\u003etarget\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ematches\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'button.className'\u003c/span\u003e)) {\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Button clicked:'\u003c/span\u003e, event.\u003cspan class=\"hljs-property\"\u003etarget\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etextContent\u003c/span\u003e);\n}\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이벤트 위임을 사용하면 공통 상위 요소에 하나의 이벤트 리스너를 추가하여 여러 하위 요소의 이벤트를 효율적으로 처리할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e44. \u003ccode\u003eeval()\u003c/code\u003e 사용 피하기\u003c/h2\u003e\n\u003cp\u003e문제: \u003ccode\u003eeval()\u003c/code\u003e 사용은 보안 취약점과 성능 문제를 야기할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e해결 방법: \u003ccode\u003eeval()\u003c/code\u003e을 사용하지 말고 더 안전한 대안을 사용하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 피하십시오\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e code = \u003cspan class=\"hljs-string\"\u003e'console.log(\"Hello, world!\")'\u003c/span\u003e;\n\u003cspan class=\"hljs-built_in\"\u003eeval\u003c/span\u003e(code); \u003cspan class=\"hljs-comment\"\u003e// \"Hello, world!\"\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 더 안전한 대안 사용\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e func = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFunction\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'console.log(\"Hello, world!\")'\u003c/span\u003e);\n\u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// \"Hello, world!\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eeval()\u003c/code\u003e을 피함으로써 보안 취약성과 성능 문제를 방지하고 코드를 더 안전하고 효율적으로 만들 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e45. \u003ccode\u003efor…of\u003c/code\u003e를 사용하여 반복하기\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제: 'for...in'을 사용하여 배열을 반복하는 것은 오류가 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e해결책: 배열 및 기타 반복 가능한 객체를 반복하는 데는 'for...of'를 사용하십시오.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e value \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e arr) {\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value);\n}\n\u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 3\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 4\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 5\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003efor...of\u003c/code\u003e는 간단하고 안전한 방법을 제공합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-45JavaScriptSuperHacksEveryDeveloperShouldKnow"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>