<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>JavaScript로 배열 흉내내기 Objectassign, arr 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-JavaScriptFakesArraysObjectassignarr" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="JavaScript로 배열 흉내내기 Objectassign, arr 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="JavaScript로 배열 흉내내기 Objectassign, arr 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-JavaScriptFakesArraysObjectassignarr" data-gatsby-head="true"/><meta name="twitter:title" content="JavaScript로 배열 흉내내기 Objectassign, arr 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 12:53" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">JavaScript로 배열 흉내내기 Objectassign, arr 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="JavaScript로 배열 흉내내기 Objectassign, arr 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-JavaScriptFakesArraysObjectassignarr&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>자바스크립트에서 배열은 사실 객체임을 비밀로 만들 필요가 없습니다. 그런데 이를 무시하는 대신, 배열에 객체 메소드를 적용해보면 어떨까요?..</h2>
<p><img src="/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png" alt="이미지"></p>
<h2>1. Object.assign()</h2>
<p>자바스크립트는 배열을 객체로 변환하는 데 전혀 문제가 없다고 인식합니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, arr);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj); <span class="hljs-comment">// 출력: {0: 1, 1: 2, 2: 3}</span>
</code></pre>
<p>하지만 재미있는 점은 인수를 바꾸고 일부 비어 있지 않은 객체를 사용하는 경우 발생합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(arr, {<span class="hljs-attr">a</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">5</span>});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj); <span class="hljs-comment">// 출력: (3) [1, 2, 3, a: 4, b: 5]</span>
</code></pre>
<p>이제 "무언가"를 찾을 수 없는 전형적인 이름을 가진: 반 배열 — 반 객체입니다. 이것이 어떻게 동작하는지는 심지어 더더욱 우스꽝스럽습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> newObj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(arr, {<span class="hljs-attr">a</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">5</span>});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj); <span class="hljs-comment">// Output: [1, 2, 3, a: 4, b: 5]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">a</span>); <span class="hljs-comment">// Output: 4</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>); <span class="hljs-comment">// Output: 3</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr)); <span class="hljs-comment">// Output: [1,2,3]</span>
</code></pre>
<p>자바스크립트는 괴상한 짓을 할 때 양심에 찔리는 듯한 척합니다. 한쪽에서는 배열에 문제가 없는 것처럼 꾸미지만, “이상한” 것들에 명시적으로 접근하면 추악한 진실을 드러내야 할 뿐입니다.</p>
<h2>2. Object.freeze()</h2>
<p>Object.freeze()는 객체에 새로운 속성이 추가되거나 기존 속성이 제거 또는 수정되지 못하도록 합니다. 배열과 함께 완벽하게 작동합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(arr);
arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>; <span class="hljs-comment">// 영향이 없음</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// 출력: [1, 2, 3]</span>
arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// TypeError: Cannot add property 3, object is not extensible</span>
</code></pre>
<p>여기서는 "object is not extensible"라고 속이지 않고 그냥 객체라고 합니다.</p>
<h2>3. Object.seal() 사용하기</h2>
<p>Object.seal()은 객체에 새로운 속성을 추가하지 못하게 하지만 기존 속성의 수정은 허용합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(arr);
arr[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>; <span class="hljs-comment">// 작동합니다</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// 출력: [10, 2, 3]</span>
arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// TypeError: 프로퍼티를 추가할 수 없습니다</span>
</code></pre>
<p>이 도구는 정의된 크기로 배열을 생성할 수 있게 해줄 수 있었지만, 제대로 작동했더라면 유용한 도구가 될 수도 있었습니다. 왜냐하면:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = []
arr.<span class="hljs-property">length</span> = <span class="hljs-number">10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// 출력: [empty × 10]</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(arr)
arr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span> <span class="hljs-comment">// 여기에 오류가 없습니다</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">// 안타깝게도, 다시 출력은: [empty × 10]</span>
</code></pre>
<h2>4. Object.getOwnPropertyDescriptors() 사용하기</h2>
<div class="content-ad"></div>
<p><code>Object.getOwnPropertyDescriptors()</code>은 객체의 모든 소유 속성 설명자를 반환합니다. 배열에서 사용할 때는 배열 색인에 대한 설명자도 포함됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> descriptors = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(arr);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptors);
<span class="hljs-comment">/* 결과:
{
  "0": { value: 1, writable: true, enumerable: true, configurable: true },
  "1": { value: 2, writable: true, enumerable: true, configurable: true },
  "2": { value: 3, writable: true, enumerable: true, configurable: true },
  "length": { value: 3, writable: true, enumerable: false, configurable: false }
}
*/</span>
</code></pre>
<p>JS 배열의 진정한 성격을 보여주는 쇼케이스입니다.</p>
<h2>5. <code>Object.getPrototypeOf()</code> 사용하기</h2>
<div class="content-ad"></div>
<p>Object.getPrototypeOf()은 지정된 객체의 프로토타입을 반환합니다. 배열에 사용하면 Array.prototype을 반환합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">const</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(arr);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proto === <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 출력: true</span>
</code></pre>
<p>그것은 배열을 식별하는 방법으로 정말 유용합니다. 왜냐하면:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = []
<span class="hljs-keyword">typeof</span> arr <span class="hljs-comment">// 출력 'object'</span>
</code></pre>
<div class="content-ad"></div>
<h2>6. Object.defineProperty() 사용하기</h2>
<p>Object.defineProperty()은 객체에 새로운 속성을 정의하거나 기존 속성을 수정하고 해당 객체를 반환합니다. 배열에 사용될 때, 새로운 속성을 정의하거나 기존 속성을 수정할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(arr, <span class="hljs-string">'0'</span>, {
  <span class="hljs-attr">value</span>: <span class="hljs-number">10</span>,
  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>
});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 결과: 10</span>
arr[<span class="hljs-number">0</span>] = <span class="hljs-number">20</span>; <span class="hljs-comment">// 쓰기가 불가능하기 때문에 영향을 주지 않음</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 결과: 10</span>
</code></pre>
<p>어째서 이렇게 할까요? 저는 상당히 작은 이유로 동료들을 놀리기 위해서 한다는 것 밖에 상상이 안됩니다. 또 다른 아이디어가 있나요?</p>
<div class="content-ad"></div>
<h2>7. Object.setPrototypeOf() 사용</h2>
<p>Object.setPrototypeOf()은 지정된 객체의 프로토타입을 설정합니다. 배열에 사용하면 프로토타입을 다른 객체로 변경할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(arr, <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// 출력: [1, 2, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">push</span>); <span class="hljs-comment">// 출력: undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">shift</span>); <span class="hljs-comment">// 출력: undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">pop</span>); <span class="hljs-comment">// 출력: undefined</span>
<span class="hljs-comment">// .map(), .filter(), .forEach() 등도 동일</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 출력: '[object Array]'</span>
arr[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// 출력: [1, 2, 3, 4]</span>
<span class="hljs-keyword">const</span> newArr = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...arr, ...newArr]) <span class="hljs-comment">// TypeError: arr은 반복 가능하지 않음</span>
</code></pre>
<p>반 배열에서 반 죽은 노파를 만드는 재미있는 방법이에요. "arr[3] = 4"와 같이 새 요소를 추가하거나 "delete arr[2]"를 호출하여 요소를 삭제할 수 있지만, 거의 모든 다른 것들이 동작하지 않아요.</p>
<div class="content-ad"></div>
<h2>8. delete 연산자 사용하기</h2>
<p>이전 포인트의 아이디어를 백 퍼센트 따르지는 않지만, 자바스크립트에서 값의 "존재하지 않음"을 나타내는 null, undefined와의 연결을 드러내어 매우 흥미로운 부분입니다.
다음 예제를 살펴보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">delete</span> arr[<span class="hljs-number">1</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// 출력: [1, empty, 3]</span>
</code></pre>
<p>특정 크기의 객체를 봉인하려고 시도할 때 "empty"가 표시되었습니다. 하지만 이것이 무엇인가요? "empty"라는 값 또는 유형은 없기 때문에 표시된 것은 실제 데이터가 아니며, 그저 "희소 배열"을 나타내는 방법일 뿐입니다. 누락된 인덱스가 있는 배열에 대한 일반적인 용어입니다. 하지만 이 값을 액세스하려고 해보죠:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">delete</span> arr[<span class="hljs-number">1</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">1</span>]); <span class="hljs-comment">// Output: undefined</span>
</code></pre>
<p>이것이 우리에게 알려주는 바는 Javascript가 존재하지 않는 것에 접근하려고 할 때 "undefined"로 대체한다는 것입니다. 이것은 실제로 공백으로 변환되기보다 "undefined"를 배열에 명시적으로 넣어두면 "empty"로 다시 변환되지 않는다는 트릭입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">delete</span> arr[<span class="hljs-number">1</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// Output: [1, empty, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">1</span>]); <span class="hljs-comment">// Output: undefined</span>
arr[<span class="hljs-number">1</span>] = <span class="hljs-literal">undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// Output: [1, undefined, 3]</span>
</code></pre>
<p>이게 다가 아닙니다. JS 데이터를 표현하는 또 다른 내장 방법인 JSON이 있습니다. JSON이 우리에게 어떤 것을 제공할 수 있는지 살펴봅시다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">delete</span> arr[<span class="hljs-number">1</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// 결과: [1, 빈 칸, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr)); <span class="hljs-comment">// 결과: [1, null, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr))); <span class="hljs-comment">// 결과: [1, null, 3]</span>
</code></pre>
<p>JSON.stringify()은 그냥 "undefined"를 "null"로 변환하기 때문에 JSON에는 undefined가 없다. 자바스크립트에도 "null"이 있기 때문에 다시 파싱할 때 "null"로 유지되는 것이 예상된다... 정말 이상한 일이다:
한 가지 방향은 empty -<code> undefined -</code> null이다.
돌아오는 방향은 null -<code> null -</code> null이다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">delete</span> arr[<span class="hljs-number">1</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// 결과: [1, 빈 칸, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 결과: undefined</span>
<span class="hljs-keyword">const</span> jsonArr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonArr); <span class="hljs-comment">// 결과: [1, null, 3]</span>
<span class="hljs-keyword">const</span> parsedArr = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonArr);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsedArr) <span class="hljs-comment">// 결과: [1, null, 3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parsedArr[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 결과: null</span>
</code></pre>
<h1>결론</h1>
<div class="content-ad"></div>
<p>자바스크립트에서 배열의 동작은 밑바닥 복잡성을 보여줍니다. 이는 종종 짜증을 유발할 수 있습니다. JavaScript 배열은 기술적으로 객체이지만, 고유한 특성과 표준 객체 메서드와의 상호작용으로 인해 예상치 못한 결과를 초래할 수 있습니다. 이러한 특이점을 이해하는 것은 개발자에게 잠재적인 문제를 피하는 데 중요할 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JavaScript로 배열 흉내내기 Objectassign, arr 방법","description":"","date":"2024-06-22 12:53","slug":"2024-06-22-JavaScriptFakesArraysObjectassignarr","content":"\n\n## 자바스크립트에서 배열은 사실 객체임을 비밀로 만들 필요가 없습니다. 그런데 이를 무시하는 대신, 배열에 객체 메소드를 적용해보면 어떨까요?..\n\n![이미지](/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png)\n\n## 1. Object.assign()\n\n자바스크립트는 배열을 객체로 변환하는 데 전혀 문제가 없다고 인식합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst arr = [1, 2, 3];\nconst newObj = Object.assign({}, arr);\nconsole.log(newObj); // 출력: {0: 1, 1: 2, 2: 3}\n```\n\n하지만 재미있는 점은 인수를 바꾸고 일부 비어 있지 않은 객체를 사용하는 경우 발생합니다:\n\n```js\nconst arr = [1, 2, 3];\nconst newObj = Object.assign(arr, {a: 4, b: 5});\nconsole.log(newObj); // 출력: (3) [1, 2, 3, a: 4, b: 5]\n```\n\n이제 \"무언가\"를 찾을 수 없는 전형적인 이름을 가진: 반 배열 — 반 객체입니다. 이것이 어떻게 동작하는지는 심지어 더더욱 우스꽝스럽습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst arr = [1, 2, 3];\nconst newObj = Object.assign(arr, {a: 4, b: 5});\nconsole.log(newObj); // Output: [1, 2, 3, a: 4, b: 5]\nconsole.log(arr.a); // Output: 4\nconsole.log(arr.length); // Output: 3\nconsole.log(JSON.stringify(arr)); // Output: [1,2,3]\n```\n\n자바스크립트는 괴상한 짓을 할 때 양심에 찔리는 듯한 척합니다. 한쪽에서는 배열에 문제가 없는 것처럼 꾸미지만, “이상한” 것들에 명시적으로 접근하면 추악한 진실을 드러내야 할 뿐입니다.\n\n## 2. Object.freeze()\n\nObject.freeze()는 객체에 새로운 속성이 추가되거나 기존 속성이 제거 또는 수정되지 못하도록 합니다. 배열과 함께 완벽하게 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst arr = [1, 2, 3];\nObject.freeze(arr);\narr[0] = 10; // 영향이 없음\nconsole.log(arr); // 출력: [1, 2, 3]\narr.push(4); // TypeError: Cannot add property 3, object is not extensible\n```\n\n여기서는 \"object is not extensible\"라고 속이지 않고 그냥 객체라고 합니다.\n\n## 3. Object.seal() 사용하기\n\nObject.seal()은 객체에 새로운 속성을 추가하지 못하게 하지만 기존 속성의 수정은 허용합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst arr = [1, 2, 3];\nObject.seal(arr);\narr[0] = 10; // 작동합니다\nconsole.log(arr); // 출력: [10, 2, 3]\narr.push(4); // TypeError: 프로퍼티를 추가할 수 없습니다\n```\n\n이 도구는 정의된 크기로 배열을 생성할 수 있게 해줄 수 있었지만, 제대로 작동했더라면 유용한 도구가 될 수도 있었습니다. 왜냐하면:\n\n```js\nconst arr = []\narr.length = 10\nconsole.log(arr) // 출력: [empty × 10]\nObject.seal(arr)\narr[0] = 1 // 여기에 오류가 없습니다\nconsole.log(arr) // 안타깝게도, 다시 출력은: [empty × 10]\n```\n\n## 4. Object.getOwnPropertyDescriptors() 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`Object.getOwnPropertyDescriptors()`은 객체의 모든 소유 속성 설명자를 반환합니다. 배열에서 사용할 때는 배열 색인에 대한 설명자도 포함됩니다.\n\n```js\nconst arr = [1, 2, 3];\nconst descriptors = Object.getOwnPropertyDescriptors(arr);\nconsole.log(descriptors);\n/* 결과:\n{\n  \"0\": { value: 1, writable: true, enumerable: true, configurable: true },\n  \"1\": { value: 2, writable: true, enumerable: true, configurable: true },\n  \"2\": { value: 3, writable: true, enumerable: true, configurable: true },\n  \"length\": { value: 3, writable: true, enumerable: false, configurable: false }\n}\n*/\n```\n\nJS 배열의 진정한 성격을 보여주는 쇼케이스입니다.\n\n## 5. `Object.getPrototypeOf()` 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nObject.getPrototypeOf()은 지정된 객체의 프로토타입을 반환합니다. 배열에 사용하면 Array.prototype을 반환합니다:\n\n```js\nconst arr = [1, 2, 3];\nconst proto = Object.getPrototypeOf(arr);\nconsole.log(proto === Array.prototype); // 출력: true\n```\n\n그것은 배열을 식별하는 방법으로 정말 유용합니다. 왜냐하면:\n\n```js\nconst arr = []\ntypeof arr // 출력 'object'\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 6. Object.defineProperty() 사용하기\n\nObject.defineProperty()은 객체에 새로운 속성을 정의하거나 기존 속성을 수정하고 해당 객체를 반환합니다. 배열에 사용될 때, 새로운 속성을 정의하거나 기존 속성을 수정할 수 있습니다.\n\n```js\nconst arr = [1, 2, 3];\nObject.defineProperty(arr, '0', {\n  value: 10,\n  writable: false,\n  enumerable: true,\n  configurable: false\n});\nconsole.log(arr[0]); // 결과: 10\narr[0] = 20; // 쓰기가 불가능하기 때문에 영향을 주지 않음\nconsole.log(arr[0]); // 결과: 10\n```\n\n어째서 이렇게 할까요? 저는 상당히 작은 이유로 동료들을 놀리기 위해서 한다는 것 밖에 상상이 안됩니다. 또 다른 아이디어가 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 7. Object.setPrototypeOf() 사용\n\nObject.setPrototypeOf()은 지정된 객체의 프로토타입을 설정합니다. 배열에 사용하면 프로토타입을 다른 객체로 변경할 수 있습니다.\n\n```js\nconst arr = [1, 2, 3];\nObject.setPrototypeOf(arr, Object.prototype);\nconsole.log(arr); // 출력: [1, 2, 3]\nconsole.log(arr.push); // 출력: undefined\nconsole.log(arr.shift); // 출력: undefined\nconsole.log(arr.pop); // 출력: undefined\n// .map(), .filter(), .forEach() 등도 동일\nconsole.log(arr.toString()); // 출력: '[object Array]'\narr[3] = 4\nconsole.log(arr); // 출력: [1, 2, 3, 4]\nconst newArr = [5,6]\nconsole.log([...arr, ...newArr]) // TypeError: arr은 반복 가능하지 않음\n```\n\n반 배열에서 반 죽은 노파를 만드는 재미있는 방법이에요. \"arr[3] = 4\"와 같이 새 요소를 추가하거나 \"delete arr[2]\"를 호출하여 요소를 삭제할 수 있지만, 거의 모든 다른 것들이 동작하지 않아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 8. delete 연산자 사용하기\n\n이전 포인트의 아이디어를 백 퍼센트 따르지는 않지만, 자바스크립트에서 값의 \"존재하지 않음\"을 나타내는 null, undefined와의 연결을 드러내어 매우 흥미로운 부분입니다.\n다음 예제를 살펴보세요:\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr); // 출력: [1, empty, 3]\n```\n\n특정 크기의 객체를 봉인하려고 시도할 때 \"empty\"가 표시되었습니다. 하지만 이것이 무엇인가요? \"empty\"라는 값 또는 유형은 없기 때문에 표시된 것은 실제 데이터가 아니며, 그저 \"희소 배열\"을 나타내는 방법일 뿐입니다. 누락된 인덱스가 있는 배열에 대한 일반적인 용어입니다. 하지만 이 값을 액세스하려고 해보죠:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr[1]); // Output: undefined\n```\n\n이것이 우리에게 알려주는 바는 Javascript가 존재하지 않는 것에 접근하려고 할 때 \"undefined\"로 대체한다는 것입니다. 이것은 실제로 공백으로 변환되기보다 \"undefined\"를 배열에 명시적으로 넣어두면 \"empty\"로 다시 변환되지 않는다는 트릭입니다:\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr); // Output: [1, empty, 3]\nconsole.log(arr[1]); // Output: undefined\narr[1] = undefined\nconsole.log(arr); // Output: [1, undefined, 3]\n```\n\n이게 다가 아닙니다. JS 데이터를 표현하는 또 다른 내장 방법인 JSON이 있습니다. JSON이 우리에게 어떤 것을 제공할 수 있는지 살펴봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr); // 결과: [1, 빈 칸, 3]\nconsole.log(JSON.stringify(arr)); // 결과: [1, null, 3]\nconsole.log(JSON.parse(JSON.stringify(arr))); // 결과: [1, null, 3]\n```\n\nJSON.stringify()은 그냥 \"undefined\"를 \"null\"로 변환하기 때문에 JSON에는 undefined가 없다. 자바스크립트에도 \"null\"이 있기 때문에 다시 파싱할 때 \"null\"로 유지되는 것이 예상된다... 정말 이상한 일이다:\n한 가지 방향은 empty -` undefined -` null이다.\n돌아오는 방향은 null -` null -` null이다.\n\n```js\nconst arr = [1, 2, 3];\ndelete arr[1];\nconsole.log(arr); // 결과: [1, 빈 칸, 3]\nconsole.log(arr[1]); // 결과: undefined\nconst jsonArr = JSON.stringify(arr);\nconsole.log(jsonArr); // 결과: [1, null, 3]\nconst parsedArr = JSON.parse(jsonArr);\nconsole.log(parsedArr) // 결과: [1, null, 3]\nconsole.log(parsedArr[1]) // 결과: null\n```\n\n# 결론\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바스크립트에서 배열의 동작은 밑바닥 복잡성을 보여줍니다. 이는 종종 짜증을 유발할 수 있습니다. JavaScript 배열은 기술적으로 객체이지만, 고유한 특성과 표준 객체 메서드와의 상호작용으로 인해 예상치 못한 결과를 초래할 수 있습니다. 이러한 특이점을 이해하는 것은 개발자에게 잠재적인 문제를 피하는 데 중요할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png"},"coverImage":"/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e자바스크립트에서 배열은 사실 객체임을 비밀로 만들 필요가 없습니다. 그런데 이를 무시하는 대신, 배열에 객체 메소드를 적용해보면 어떨까요?..\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-JavaScriptFakesArraysObjectassignarr_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e1. Object.assign()\u003c/h2\u003e\n\u003cp\u003e자바스크립트는 배열을 객체로 변환하는 데 전혀 문제가 없다고 인식합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newObj = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eassign\u003c/span\u003e({}, arr);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(newObj); \u003cspan class=\"hljs-comment\"\u003e// 출력: {0: 1, 1: 2, 2: 3}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 재미있는 점은 인수를 바꾸고 일부 비어 있지 않은 객체를 사용하는 경우 발생합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newObj = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eassign\u003c/span\u003e(arr, {\u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e});\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(newObj); \u003cspan class=\"hljs-comment\"\u003e// 출력: (3) [1, 2, 3, a: 4, b: 5]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 \"무언가\"를 찾을 수 없는 전형적인 이름을 가진: 반 배열 — 반 객체입니다. 이것이 어떻게 동작하는지는 심지어 더더욱 우스꽝스럽습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newObj = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eassign\u003c/span\u003e(arr, {\u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e});\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(newObj); \u003cspan class=\"hljs-comment\"\u003e// Output: [1, 2, 3, a: 4, b: 5]\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Output: 4\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Output: 3\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(arr)); \u003cspan class=\"hljs-comment\"\u003e// Output: [1,2,3]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e자바스크립트는 괴상한 짓을 할 때 양심에 찔리는 듯한 척합니다. 한쪽에서는 배열에 문제가 없는 것처럼 꾸미지만, “이상한” 것들에 명시적으로 접근하면 추악한 진실을 드러내야 할 뿐입니다.\u003c/p\u003e\n\u003ch2\u003e2. Object.freeze()\u003c/h2\u003e\n\u003cp\u003eObject.freeze()는 객체에 새로운 속성이 추가되거나 기존 속성이 제거 또는 수정되지 못하도록 합니다. 배열과 함께 완벽하게 작동합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efreeze\u003c/span\u003e(arr);\narr[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 영향이 없음\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr); \u003cspan class=\"hljs-comment\"\u003e// 출력: [1, 2, 3]\u003c/span\u003e\narr.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// TypeError: Cannot add property 3, object is not extensible\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서는 \"object is not extensible\"라고 속이지 않고 그냥 객체라고 합니다.\u003c/p\u003e\n\u003ch2\u003e3. Object.seal() 사용하기\u003c/h2\u003e\n\u003cp\u003eObject.seal()은 객체에 새로운 속성을 추가하지 못하게 하지만 기존 속성의 수정은 허용합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eseal\u003c/span\u003e(arr);\narr[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 작동합니다\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr); \u003cspan class=\"hljs-comment\"\u003e// 출력: [10, 2, 3]\u003c/span\u003e\narr.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// TypeError: 프로퍼티를 추가할 수 없습니다\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 도구는 정의된 크기로 배열을 생성할 수 있게 해줄 수 있었지만, 제대로 작동했더라면 유용한 도구가 될 수도 있었습니다. 왜냐하면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = []\narr.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr) \u003cspan class=\"hljs-comment\"\u003e// 출력: [empty × 10]\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eseal\u003c/span\u003e(arr)\narr[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 여기에 오류가 없습니다\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr) \u003cspan class=\"hljs-comment\"\u003e// 안타깝게도, 다시 출력은: [empty × 10]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e4. Object.getOwnPropertyDescriptors() 사용하기\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eObject.getOwnPropertyDescriptors()\u003c/code\u003e은 객체의 모든 소유 속성 설명자를 반환합니다. 배열에서 사용할 때는 배열 색인에 대한 설명자도 포함됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e descriptors = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetOwnPropertyDescriptors\u003c/span\u003e(arr);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(descriptors);\n\u003cspan class=\"hljs-comment\"\u003e/* 결과:\n{\n  \"0\": { value: 1, writable: true, enumerable: true, configurable: true },\n  \"1\": { value: 2, writable: true, enumerable: true, configurable: true },\n  \"2\": { value: 3, writable: true, enumerable: true, configurable: true },\n  \"length\": { value: 3, writable: true, enumerable: false, configurable: false }\n}\n*/\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJS 배열의 진정한 성격을 보여주는 쇼케이스입니다.\u003c/p\u003e\n\u003ch2\u003e5. \u003ccode\u003eObject.getPrototypeOf()\u003c/code\u003e 사용하기\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eObject.getPrototypeOf()은 지정된 객체의 프로토타입을 반환합니다. 배열에 사용하면 Array.prototype을 반환합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e proto = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetPrototypeOf\u003c/span\u003e(arr);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(proto === \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 출력: true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그것은 배열을 식별하는 방법으로 정말 유용합니다. 왜냐하면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = []\n\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e arr \u003cspan class=\"hljs-comment\"\u003e// 출력 'object'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e6. Object.defineProperty() 사용하기\u003c/h2\u003e\n\u003cp\u003eObject.defineProperty()은 객체에 새로운 속성을 정의하거나 기존 속성을 수정하고 해당 객체를 반환합니다. 배열에 사용될 때, 새로운 속성을 정의하거나 기존 속성을 수정할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edefineProperty\u003c/span\u003e(arr, \u003cspan class=\"hljs-string\"\u003e'0'\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ewritable\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eenumerable\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003econfigurable\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n});\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// 결과: 10\u003c/span\u003e\narr[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 쓰기가 불가능하기 때문에 영향을 주지 않음\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// 결과: 10\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e어째서 이렇게 할까요? 저는 상당히 작은 이유로 동료들을 놀리기 위해서 한다는 것 밖에 상상이 안됩니다. 또 다른 아이디어가 있나요?\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e7. Object.setPrototypeOf() 사용\u003c/h2\u003e\n\u003cp\u003eObject.setPrototypeOf()은 지정된 객체의 프로토타입을 설정합니다. 배열에 사용하면 프로토타입을 다른 객체로 변경할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esetPrototypeOf\u003c/span\u003e(arr, \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr); \u003cspan class=\"hljs-comment\"\u003e// 출력: [1, 2, 3]\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr.\u003cspan class=\"hljs-property\"\u003epush\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 출력: undefined\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr.\u003cspan class=\"hljs-property\"\u003eshift\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 출력: undefined\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr.\u003cspan class=\"hljs-property\"\u003epop\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 출력: undefined\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// .map(), .filter(), .forEach() 등도 동일\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// 출력: '[object Array]'\u003c/span\u003e\narr[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr); \u003cspan class=\"hljs-comment\"\u003e// 출력: [1, 2, 3, 4]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newArr = [\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e]\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e([...arr, ...newArr]) \u003cspan class=\"hljs-comment\"\u003e// TypeError: arr은 반복 가능하지 않음\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e반 배열에서 반 죽은 노파를 만드는 재미있는 방법이에요. \"arr[3] = 4\"와 같이 새 요소를 추가하거나 \"delete arr[2]\"를 호출하여 요소를 삭제할 수 있지만, 거의 모든 다른 것들이 동작하지 않아요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e8. delete 연산자 사용하기\u003c/h2\u003e\n\u003cp\u003e이전 포인트의 아이디어를 백 퍼센트 따르지는 않지만, 자바스크립트에서 값의 \"존재하지 않음\"을 나타내는 null, undefined와의 연결을 드러내어 매우 흥미로운 부분입니다.\n다음 예제를 살펴보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e arr[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr); \u003cspan class=\"hljs-comment\"\u003e// 출력: [1, empty, 3]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e특정 크기의 객체를 봉인하려고 시도할 때 \"empty\"가 표시되었습니다. 하지만 이것이 무엇인가요? \"empty\"라는 값 또는 유형은 없기 때문에 표시된 것은 실제 데이터가 아니며, 그저 \"희소 배열\"을 나타내는 방법일 뿐입니다. 누락된 인덱스가 있는 배열에 대한 일반적인 용어입니다. 하지만 이 값을 액세스하려고 해보죠:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e arr[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// Output: undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것이 우리에게 알려주는 바는 Javascript가 존재하지 않는 것에 접근하려고 할 때 \"undefined\"로 대체한다는 것입니다. 이것은 실제로 공백으로 변환되기보다 \"undefined\"를 배열에 명시적으로 넣어두면 \"empty\"로 다시 변환되지 않는다는 트릭입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e arr[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr); \u003cspan class=\"hljs-comment\"\u003e// Output: [1, empty, 3]\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// Output: undefined\u003c/span\u003e\narr[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr); \u003cspan class=\"hljs-comment\"\u003e// Output: [1, undefined, 3]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이게 다가 아닙니다. JS 데이터를 표현하는 또 다른 내장 방법인 JSON이 있습니다. JSON이 우리에게 어떤 것을 제공할 수 있는지 살펴봅시다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e arr[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr); \u003cspan class=\"hljs-comment\"\u003e// 결과: [1, 빈 칸, 3]\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(arr)); \u003cspan class=\"hljs-comment\"\u003e// 결과: [1, null, 3]\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(arr))); \u003cspan class=\"hljs-comment\"\u003e// 결과: [1, null, 3]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJSON.stringify()은 그냥 \"undefined\"를 \"null\"로 변환하기 때문에 JSON에는 undefined가 없다. 자바스크립트에도 \"null\"이 있기 때문에 다시 파싱할 때 \"null\"로 유지되는 것이 예상된다... 정말 이상한 일이다:\n한 가지 방향은 empty -\u003ccode\u003e undefined -\u003c/code\u003e null이다.\n돌아오는 방향은 null -\u003ccode\u003e null -\u003c/code\u003e null이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arr = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e arr[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr); \u003cspan class=\"hljs-comment\"\u003e// 결과: [1, 빈 칸, 3]\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(arr[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// 결과: undefined\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e jsonArr = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(arr);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(jsonArr); \u003cspan class=\"hljs-comment\"\u003e// 결과: [1, null, 3]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e parsedArr = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(jsonArr);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(parsedArr) \u003cspan class=\"hljs-comment\"\u003e// 결과: [1, null, 3]\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(parsedArr[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]) \u003cspan class=\"hljs-comment\"\u003e// 결과: null\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e자바스크립트에서 배열의 동작은 밑바닥 복잡성을 보여줍니다. 이는 종종 짜증을 유발할 수 있습니다. JavaScript 배열은 기술적으로 객체이지만, 고유한 특성과 표준 객체 메서드와의 상호작용으로 인해 예상치 못한 결과를 초래할 수 있습니다. 이러한 특이점을 이해하는 것은 개발자에게 잠재적인 문제를 피하는 데 중요할 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-JavaScriptFakesArraysObjectassignarr"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>