<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>상태 관리자인 Zustand와 JS 메모리 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-ZustandStateManagerAndJSMemory" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="상태 관리자인 Zustand와 JS 메모리 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="상태 관리자인 Zustand와 JS 메모리 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-ZustandStateManagerAndJSMemory" data-gatsby-head="true"/><meta name="twitter:title" content="상태 관리자인 Zustand와 JS 메모리 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 22:19" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">상태 관리자인 Zustand와 JS 메모리</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="상태 관리자인 Zustand와 JS 메모리" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">3<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-ZustandStateManagerAndJSMemory&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이 기사에서는 매우 간단하고 쉽게 관리할 수 있는 Zustand 상태 관리자를 검토할 것이며, 사용 시 고려해야 할 몇 가지 사항이 있습니다. 또한 기본적으로 JavaScript 메모리 관리가 어떻게 작동하는지 설명하겠습니다.</p>
<p><img src="/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png" alt="Zustand 상태 관리자 및 JS 메모리"></p>
<p>여기 Zustand 상태 관리자에서의 기본 이슈 설명이 있습니다. 매우 간단한 구조를 가진 store를 선언했는데, 이 store는 목록으로 간단한 데이터를 유지하도록 설계되었고 setStoreData라는 단일 메서드만 있습니다. store를 사용할 수 있겠죠? 내가 store를 가져왔다면 모든 컴포넌트에서 store 데이터를 사용할 수 있고, setStoreData 메서드를 가져오면 store 데이터를 편집할 수도 있을 것입니다. 하지만 setStoreData 메서드를 가져오지 않아도 store 데이터를 편집할 수 있다면 어떨까요? 네, 그렇게 되어서는 안 될 것 같지만 Zustand에서 그렇게 되고 있어서 React 프로젝트에서 Zustand 상태 관리자를 사용할 때 매우 조심해야 합니다. 어떻게 그런 일이 발생하는지 살펴보겠습니다...</p>
<p><img src="/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_1.png" alt="Zustand 상태 관리자 및 JS 메모리"></p>
<p>우리가 간단한 상점 예제를 보여드립니다. 꽤 기본적인 내용이죠. 하지만 이 상점을 사용하는 중에 작은 문제가 있습니다.</p>
<p><img src="/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_2.png" alt="image"></p>
<p>이 조건하에, <code>setStoreDATA</code> 함수를 전혀 사용하지 않는다는 점을 볼 수 있습니다. 그런데 이 함수가 메소드를 사용하지 않아도 상점 데이터를 설정할 수 있습니다. 어떻게 그런 일이 가능한 걸까요?</p>
<p>JavaScript에서 기본 데이터 유형(숫자, 문자열, 불리언, null, undefined, 심볼, BigInt)은 변수가 액세스하는 위치에 직접 저장됩니다. 그러나 객체, 배열 및 함수와 같은 비-기본 유형은 참조로 저장되기 때문에 우리가 참조로 호출하면 데이터 유형을 조작할 수 있습니다. 이것은 프로그램 전체에 직접 영향을 미치며 우리가 수정한 공간이 아닌 모든 곳에서 변경을 가져옵니다. 그래서 데이터를 참조로 저장하는 것은 무엇인가요?</p>
<p>참조에 의한 전달 및 값에 의한 전달</p>
<h2>값에 의한 전달</h2>
<p>값에 의한 전달을 사용할 때, 원래 데이터의 사본이 함수에 전달됩니다. 함수 내부에서 매개변수를 변경해도 원본 데이터에는 영향을 미치지 않습니다. 이는 함수에 전달된 값이 실제로 원래 값의 사본이기 때문입니다. 대부분의 기본 데이터 유형(정수, 부동 소수점 및 부울과 같은)은 보통 값에 의해 전달됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">modifyValue</span>(<span class="hljs-params">num</span>) {
    num = <span class="hljs-number">15</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"함수 내부 값:"</span>, num);
}

<span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
<span class="hljs-title function_">modifyValue</span>(x);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"함수 호출 후 x 값:"</span>, x);
</code></pre>
<p>이 예시의 결과</p>
<pre><code class="hljs language-js">함수 내부의 값: <span class="hljs-number">15</span>
함수 호출 후 x 값: <span class="hljs-number">5</span>
</code></pre>
<p>이 예시에서는 함수 내에서 x의 값이 변경되었지만 x의 값이 변하지 않았습니다. 이는 함수가 x의 사본만을 접근했기 때문입니다.</p>
<h1>참조로 전달</h1>
<p>자바스크립트에서 객체(배열 및 함수 포함)를 함수에 전달할 때, 기술적으로 "공유"로 전달됩니다 (간단히 말하면 참조에 의한 전달이라고도 합니다). 실제로 객체에 대한 참조를 전달하므로 함수 내에서 객체를 수정하면 원본 객체에 영향을 줍니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">modifyArray</span>(<span class="hljs-params">arr</span>) {
    arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"함수 내부의 배열:"</span>, arr);
}

<span class="hljs-keyword">let</span> myArray = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-title function_">modifyArray</span>(myArray);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"함수 호출 후 배열:"</span>, myArray);
</code></pre>
<p>이 예제의 출력</p>
<pre><code class="hljs language-js">함수 내부의 배열: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
함수 호출 후 배열: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]
</code></pre>
<p>요약하자면, 자바스크립트에서:</p>
<ul>
<li>값을 전달 (원시 값): 값만 전달되므로 함수 내부의 매개변수 변경은 원래 변수에 영향을 미치지 않습니다.</li>
<li>참조로 전달 (객체): 객체에 대한 참조가 전달되므로 매개변수 변경은 원래 객체에 영향을 미칩니다.</li>
</ul>
<p>그렇다면 Zustand는 무엇일까요?</p>
<p>Zustand에서는 사용자가 스토어를 변경할 때 setStoreData 메서드를 사용하도록 강제하는 보호 기능이 배열을 유지하는 경우에는 없습니다.</p>
<h1>결론</h1>
<p>만약 당신이 리스트 구조를 유지하는 상점을 가지고 있다면, 자바스크립트에서 배열인 리스트는 참조 호출로 편집될 것입니다. 즉, 당신이 상점 데이터를 호출하고 그 데이터를 함수에서 사용하고 다른 리스트나 값을 동일하게 만들었다고 가정해봅시다. 이러한 경우, 선언한 설정 방법을 사용하지 않아도 상점이 변경될 것입니다.</p>
<p>아마도 이것은 간단한 부족한 보호 또는 고의적으로 포기된 자유일 수 있습니다. 특히 상점이 리스트 구조를 포함하는 경우, Zustand 상점을 사용할 때 극도로 조심해야 합니다.</p>
<h1>Stackademic 🎓</h1>
<p>끝까지 읽어주셔서 감사합니다. 떠나시기 전에:</p>
<ul>
<li>작가를 박수로 응원하고 팔로우해주세요! 👏</li>
<li>X를 팔로우하고 LinkedIn, YouTube, Discord에서 우리를 만나보세요.</li>
<li>다른 플랫폼을 방문해보세요: In Plain English, CoFeed, Venture, Cubed</li>
<li>알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.</li>
<li>Stackademic.com에서 더 많은 콘텐츠를 만나보세요.</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"상태 관리자인 Zustand와 JS 메모리","description":"","date":"2024-05-12 22:19","slug":"2024-05-12-ZustandStateManagerAndJSMemory","content":"\n\n이 기사에서는 매우 간단하고 쉽게 관리할 수 있는 Zustand 상태 관리자를 검토할 것이며, 사용 시 고려해야 할 몇 가지 사항이 있습니다. 또한 기본적으로 JavaScript 메모리 관리가 어떻게 작동하는지 설명하겠습니다.\n\n![Zustand 상태 관리자 및 JS 메모리](/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png)\n\n여기 Zustand 상태 관리자에서의 기본 이슈 설명이 있습니다. 매우 간단한 구조를 가진 store를 선언했는데, 이 store는 목록으로 간단한 데이터를 유지하도록 설계되었고 setStoreData라는 단일 메서드만 있습니다. store를 사용할 수 있겠죠? 내가 store를 가져왔다면 모든 컴포넌트에서 store 데이터를 사용할 수 있고, setStoreData 메서드를 가져오면 store 데이터를 편집할 수도 있을 것입니다. 하지만 setStoreData 메서드를 가져오지 않아도 store 데이터를 편집할 수 있다면 어떨까요? 네, 그렇게 되어서는 안 될 것 같지만 Zustand에서 그렇게 되고 있어서 React 프로젝트에서 Zustand 상태 관리자를 사용할 때 매우 조심해야 합니다. 어떻게 그런 일이 발생하는지 살펴보겠습니다...\n\n![Zustand 상태 관리자 및 JS 메모리](/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_1.png)\n\n\n\n우리가 간단한 상점 예제를 보여드립니다. 꽤 기본적인 내용이죠. 하지만 이 상점을 사용하는 중에 작은 문제가 있습니다.\n\n![image](/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_2.png)\n\n이 조건하에, `setStoreDATA` 함수를 전혀 사용하지 않는다는 점을 볼 수 있습니다. 그런데 이 함수가 메소드를 사용하지 않아도 상점 데이터를 설정할 수 있습니다. 어떻게 그런 일이 가능한 걸까요?\n\nJavaScript에서 기본 데이터 유형(숫자, 문자열, 불리언, null, undefined, 심볼, BigInt)은 변수가 액세스하는 위치에 직접 저장됩니다. 그러나 객체, 배열 및 함수와 같은 비-기본 유형은 참조로 저장되기 때문에 우리가 참조로 호출하면 데이터 유형을 조작할 수 있습니다. 이것은 프로그램 전체에 직접 영향을 미치며 우리가 수정한 공간이 아닌 모든 곳에서 변경을 가져옵니다. 그래서 데이터를 참조로 저장하는 것은 무엇인가요?\n\n\n\n참조에 의한 전달 및 값에 의한 전달\n\n## 값에 의한 전달\n\n값에 의한 전달을 사용할 때, 원래 데이터의 사본이 함수에 전달됩니다. 함수 내부에서 매개변수를 변경해도 원본 데이터에는 영향을 미치지 않습니다. 이는 함수에 전달된 값이 실제로 원래 값의 사본이기 때문입니다. 대부분의 기본 데이터 유형(정수, 부동 소수점 및 부울과 같은)은 보통 값에 의해 전달됩니다.\n\n```js\nfunction modifyValue(num) {\n    num = 15;\n    console.log(\"함수 내부 값:\", num);\n}\n\nlet x = 5;\nmodifyValue(x);\nconsole.log(\"함수 호출 후 x 값:\", x);\n```\n\n\n\n이 예시의 결과\n\n```js\n함수 내부의 값: 15\n함수 호출 후 x 값: 5\n```\n\n이 예시에서는 함수 내에서 x의 값이 변경되었지만 x의 값이 변하지 않았습니다. 이는 함수가 x의 사본만을 접근했기 때문입니다.\n\n# 참조로 전달\n\n\n\n자바스크립트에서 객체(배열 및 함수 포함)를 함수에 전달할 때, 기술적으로 \"공유\"로 전달됩니다 (간단히 말하면 참조에 의한 전달이라고도 합니다). 실제로 객체에 대한 참조를 전달하므로 함수 내에서 객체를 수정하면 원본 객체에 영향을 줍니다.\n\n```js\nfunction modifyArray(arr) {\n    arr.push(4);\n    console.log(\"함수 내부의 배열:\", arr);\n}\n\nlet myArray = [1, 2, 3];\nmodifyArray(myArray);\nconsole.log(\"함수 호출 후 배열:\", myArray);\n```\n\n이 예제의 출력\n\n```js\n함수 내부의 배열: [1, 2, 3, 4]\n함수 호출 후 배열: [1, 2, 3, 4]\n```\n\n\n\n요약하자면, 자바스크립트에서:\n\n- 값을 전달 (원시 값): 값만 전달되므로 함수 내부의 매개변수 변경은 원래 변수에 영향을 미치지 않습니다.\n- 참조로 전달 (객체): 객체에 대한 참조가 전달되므로 매개변수 변경은 원래 객체에 영향을 미칩니다.\n\n그렇다면 Zustand는 무엇일까요?\n\nZustand에서는 사용자가 스토어를 변경할 때 setStoreData 메서드를 사용하도록 강제하는 보호 기능이 배열을 유지하는 경우에는 없습니다.\n\n\n\n# 결론\n\n만약 당신이 리스트 구조를 유지하는 상점을 가지고 있다면, 자바스크립트에서 배열인 리스트는 참조 호출로 편집될 것입니다. 즉, 당신이 상점 데이터를 호출하고 그 데이터를 함수에서 사용하고 다른 리스트나 값을 동일하게 만들었다고 가정해봅시다. 이러한 경우, 선언한 설정 방법을 사용하지 않아도 상점이 변경될 것입니다.\n\n아마도 이것은 간단한 부족한 보호 또는 고의적으로 포기된 자유일 수 있습니다. 특히 상점이 리스트 구조를 포함하는 경우, Zustand 상점을 사용할 때 극도로 조심해야 합니다.\n\n# Stackademic 🎓\n\n\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우해주세요! 👏\n- X를 팔로우하고 LinkedIn, YouTube, Discord에서 우리를 만나보세요.\n- 다른 플랫폼을 방문해보세요: In Plain English, CoFeed, Venture, Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png"},"coverImage":"/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png","tag":["Tech"],"readingTime":3},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이 기사에서는 매우 간단하고 쉽게 관리할 수 있는 Zustand 상태 관리자를 검토할 것이며, 사용 시 고려해야 할 몇 가지 사항이 있습니다. 또한 기본적으로 JavaScript 메모리 관리가 어떻게 작동하는지 설명하겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_0.png\" alt=\"Zustand 상태 관리자 및 JS 메모리\"\u003e\u003c/p\u003e\n\u003cp\u003e여기 Zustand 상태 관리자에서의 기본 이슈 설명이 있습니다. 매우 간단한 구조를 가진 store를 선언했는데, 이 store는 목록으로 간단한 데이터를 유지하도록 설계되었고 setStoreData라는 단일 메서드만 있습니다. store를 사용할 수 있겠죠? 내가 store를 가져왔다면 모든 컴포넌트에서 store 데이터를 사용할 수 있고, setStoreData 메서드를 가져오면 store 데이터를 편집할 수도 있을 것입니다. 하지만 setStoreData 메서드를 가져오지 않아도 store 데이터를 편집할 수 있다면 어떨까요? 네, 그렇게 되어서는 안 될 것 같지만 Zustand에서 그렇게 되고 있어서 React 프로젝트에서 Zustand 상태 관리자를 사용할 때 매우 조심해야 합니다. 어떻게 그런 일이 발생하는지 살펴보겠습니다...\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_1.png\" alt=\"Zustand 상태 관리자 및 JS 메모리\"\u003e\u003c/p\u003e\n\u003cp\u003e우리가 간단한 상점 예제를 보여드립니다. 꽤 기본적인 내용이죠. 하지만 이 상점을 사용하는 중에 작은 문제가 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-ZustandStateManagerAndJSMemory_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이 조건하에, \u003ccode\u003esetStoreDATA\u003c/code\u003e 함수를 전혀 사용하지 않는다는 점을 볼 수 있습니다. 그런데 이 함수가 메소드를 사용하지 않아도 상점 데이터를 설정할 수 있습니다. 어떻게 그런 일이 가능한 걸까요?\u003c/p\u003e\n\u003cp\u003eJavaScript에서 기본 데이터 유형(숫자, 문자열, 불리언, null, undefined, 심볼, BigInt)은 변수가 액세스하는 위치에 직접 저장됩니다. 그러나 객체, 배열 및 함수와 같은 비-기본 유형은 참조로 저장되기 때문에 우리가 참조로 호출하면 데이터 유형을 조작할 수 있습니다. 이것은 프로그램 전체에 직접 영향을 미치며 우리가 수정한 공간이 아닌 모든 곳에서 변경을 가져옵니다. 그래서 데이터를 참조로 저장하는 것은 무엇인가요?\u003c/p\u003e\n\u003cp\u003e참조에 의한 전달 및 값에 의한 전달\u003c/p\u003e\n\u003ch2\u003e값에 의한 전달\u003c/h2\u003e\n\u003cp\u003e값에 의한 전달을 사용할 때, 원래 데이터의 사본이 함수에 전달됩니다. 함수 내부에서 매개변수를 변경해도 원본 데이터에는 영향을 미치지 않습니다. 이는 함수에 전달된 값이 실제로 원래 값의 사본이기 때문입니다. 대부분의 기본 데이터 유형(정수, 부동 소수점 및 부울과 같은)은 보통 값에 의해 전달됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emodifyValue\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e) {\n    num = \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"함수 내부 값:\"\u003c/span\u003e, num);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e;\n\u003cspan class=\"hljs-title function_\"\u003emodifyValue\u003c/span\u003e(x);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"함수 호출 후 x 값:\"\u003c/span\u003e, x);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시의 결과\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e함수 내부의 값: \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e\n함수 호출 후 x 값: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서는 함수 내에서 x의 값이 변경되었지만 x의 값이 변하지 않았습니다. 이는 함수가 x의 사본만을 접근했기 때문입니다.\u003c/p\u003e\n\u003ch1\u003e참조로 전달\u003c/h1\u003e\n\u003cp\u003e자바스크립트에서 객체(배열 및 함수 포함)를 함수에 전달할 때, 기술적으로 \"공유\"로 전달됩니다 (간단히 말하면 참조에 의한 전달이라고도 합니다). 실제로 객체에 대한 참조를 전달하므로 함수 내에서 객체를 수정하면 원본 객체에 영향을 줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emodifyArray\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003earr\u003c/span\u003e) {\n    arr.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"함수 내부의 배열:\"\u003c/span\u003e, arr);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e myArray = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-title function_\"\u003emodifyArray\u003c/span\u003e(myArray);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"함수 호출 후 배열:\"\u003c/span\u003e, myArray);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제의 출력\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e함수 내부의 배열: [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e]\n함수 호출 후 배열: [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e요약하자면, 자바스크립트에서:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e값을 전달 (원시 값): 값만 전달되므로 함수 내부의 매개변수 변경은 원래 변수에 영향을 미치지 않습니다.\u003c/li\u003e\n\u003cli\u003e참조로 전달 (객체): 객체에 대한 참조가 전달되므로 매개변수 변경은 원래 객체에 영향을 미칩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그렇다면 Zustand는 무엇일까요?\u003c/p\u003e\n\u003cp\u003eZustand에서는 사용자가 스토어를 변경할 때 setStoreData 메서드를 사용하도록 강제하는 보호 기능이 배열을 유지하는 경우에는 없습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e만약 당신이 리스트 구조를 유지하는 상점을 가지고 있다면, 자바스크립트에서 배열인 리스트는 참조 호출로 편집될 것입니다. 즉, 당신이 상점 데이터를 호출하고 그 데이터를 함수에서 사용하고 다른 리스트나 값을 동일하게 만들었다고 가정해봅시다. 이러한 경우, 선언한 설정 방법을 사용하지 않아도 상점이 변경될 것입니다.\u003c/p\u003e\n\u003cp\u003e아마도 이것은 간단한 부족한 보호 또는 고의적으로 포기된 자유일 수 있습니다. 특히 상점이 리스트 구조를 포함하는 경우, Zustand 상점을 사용할 때 극도로 조심해야 합니다.\u003c/p\u003e\n\u003ch1\u003eStackademic 🎓\u003c/h1\u003e\n\u003cp\u003e끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작가를 박수로 응원하고 팔로우해주세요! 👏\u003c/li\u003e\n\u003cli\u003eX를 팔로우하고 LinkedIn, YouTube, Discord에서 우리를 만나보세요.\u003c/li\u003e\n\u003cli\u003e다른 플랫폼을 방문해보세요: In Plain English, CoFeed, Venture, Cubed\u003c/li\u003e\n\u003cli\u003e알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요.\u003c/li\u003e\n\u003cli\u003eStackademic.com에서 더 많은 콘텐츠를 만나보세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-ZustandStateManagerAndJSMemory"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>