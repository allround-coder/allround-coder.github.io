<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>아두이노와 iOS 간의 블루투스 연결 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-15-BluetoothconnectionbetweenArduinoandiOS" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="아두이노와 iOS 간의 블루투스 연결 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="아두이노와 iOS 간의 블루투스 연결 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-15-BluetoothconnectionbetweenArduinoandiOS" data-gatsby-head="true"/><meta name="twitter:title" content="아두이노와 iOS 간의 블루투스 연결 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-15 04:34" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">아두이노와 iOS 간의 블루투스 연결</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="아두이노와 iOS 간의 블루투스 연결" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 15, 2024</span><span class="posts_reading_time__f7YPP">14<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-15-BluetoothconnectionbetweenArduinoandiOS&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>소개</h1>
<p>안녕하세요!! 여기에 오신 것을 환영합니다. 아두이노 장치에서 iOS 장치로 블루투스를 사용하여 데이터를 송수신하는 방법을 찾고 계시다고 생각합니다, 맞나요? (빌드할 내용을 설명하는 비디오가 있는 GitHub 링크를 여기에 배치했습니다).</p>
<p>이를 위해 지식을 두 부분으로 나누기로 결정했습니다. 첫 번째 부분에서는 하드웨어 구체적인 내용, 블루투스 모듈의 조립 및 아두이노 코드를 통해 정보를 전송하는 방법에 대해 다룰 것입니다. 이 문서의 후반부에서는 iOS 개발에 대해 다룰 예정입니다.</p>
<h1>블루투스 모듈</h1>
<p>이 프로젝트에서는 에너지 소비가 적은 통신 형태인 블루투스를 아두이노와 IOS 장치 간에 사용하기로 결정했습니다. 이것은 배터리로 아두이노를 사용할 때 중요한 요소입니다.
이를 염두에 두고 프로젝트를 시작할 때의 첫 번째 질문은 아두이노에 이미 블루투스가 내장되어 있는지 여부입니다(이를 위해 문서에 접근할 수 있음). 저의 경우, 블루투스가 내장되어 있지 않은 ArduinoUno를 사용할 예정이므로 이 기술을 제공하는 모듈이 필요합니다.</p>
<p>어떤 모듈을 사용해야 할까요?
iOS 기기는 BLE(Bluetooth Low Energy)라는 기술을 사용하여 통신하며, 일반적인 블루투스와 차이가 있지만, 이는 다른 기사로 남기겠습니다. 따라서 BLE를 지원하는 모듈이 필요하며, 여러 옵션이 있습니다(구매하기 전에 주의하세요), 하지만 저는 HC-08 모듈을 사용할 예정입니다.</p>
<p><img src="/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png" alt="Image"></p>
<h1>Arduino에 HC-08 연결하기</h1>
<p>조립을 더 잘 설명하기 위해 어셈블리를 시연하기 위한 다이어그램을 만들었습니다.</p>
<p><img src="/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_1.png" alt="Bluetooth Connection Diagram"></p>
<p>프로젝트에서 핀 2와 3을 이미 사용 중이라면, TX 및 RX를 사용 가능한 핀에 연결할 수 있습니다(이 경우 SoftwareSerial을 사용합니다). 그러나 코드에 도달하면 사용 중인 핀을 변경해야 합니다.
이미지에 문제가 있을 경우, HC-08에서 아두이노로 연결되는 방법을 적어놓겠습니다:</p>
<ul>
<li>VCC → 5V</li>
<li>GND → GND</li>
<li>TXD(송신) → 2</li>
<li>RXD(수신) → 3</li>
</ul>
<h1>코딩 시간</h1>
<p>우리가 아두이노에 업로드할 코드는 블루투스 모듈(나의 iOS 기기에 연결될 것)로 정보를 보내고, 그 모듈은 나의 iOS 기기로 데이터를 전송할 것을 목적으로 합니다.</p>
<pre><code class="hljs language-js">#include <span class="hljs-string">"SoftwareSerial.h"</span>
<span class="hljs-title class_">SoftwareSerial</span> <span class="hljs-title function_">bluetooth</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//3 = RX ; 2 = TX</span>
</code></pre>
<p>기본적으로, 코드의 이 부분에서는 SoftwareSerial 라이브러리를 사용하고 있습니다. 이 라이브러리를 사용하면 아두이노 디지털 핀에 추가적인 시리얼 포트를 생성할 수 있습니다. 이 기능은 시리얼 통신이 필요하지만 이미 주 시리얼 포트를 코드를 디버깅하기 위한 시리얼 모니터로 사용하는 경우와 같이 주 시리얼 포트가 다른 목적으로 이미 사용 중인 경우 유용합니다.</p>
<p>소프트웨어 시리얼 인스턴스가 이름이 "bluetooth"인 것을 만들었습니다. 매개변수 (3, 2)는 아두이노의 핀 3을 RX(수신)로, 핀 2를 TX(송신)로 사용할 것을 나타냅니다 (기본적으로 첫 번째 숫자가 RX이며 두 번째 숫자가 TX입니다).</p>
<p>⚠️만약 다른 핀을 사용했다면, 숫자를 변경하세요.⚠️</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">begin</span>(<span class="hljs-number">9600</span>);
  bluetooth.<span class="hljs-title function_">begin</span>(<span class="hljs-number">9600</span>);
}
</code></pre>
<p>설정 함수에서(스크립트가 실행될 때에만 실행되는 함수), 아두이노와 컴퓨터 사이에 표준 시리얼 포트를 통해 초당 9600비트의 속도로 시리얼 통신을 시작합니다 (디버깅에 유용합니다).</p>
<p>이제 "블루투스"라고 불리는 객체의 직렬 통신을 9600 비트로 설정하여 시작합니다. 이는 아두이노와 핀 2와 3에 연결된 블루투스 모듈 간의 통신을 수립합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>) {
    bluetooth.<span class="hljs-title function_">print</span>(<span class="hljs-string">"성공!"</span>); 
    <span class="hljs-title function_">delay</span>(<span class="hljs-number">2000</span>);
    bluetooth.<span class="hljs-title function_">print</span>(<span class="hljs-string">"잘 했어요!"</span>);
    <span class="hljs-title function_">delay</span>(<span class="hljs-number">2000</span>);
}
</code></pre>
<p>이제 우리의 루프에서는 코드가 계속해서 실행되며, 기본적으로 블루투스 모듈과 통신하도록 한 책임자에게 문자열을 보내고 있습니다. 매 2초마다 다른 문자열을 보내고 있습니다.</p>
<p>이 코드 스니펫의 아이디어는 여러분의 프로젝트에 맞는 데이터를 가져와 생성된 통신으로 보내는 것입니다. 이 경우 문자열만 보내고 있지만 다양한 유형의 데이터를 보낼 수 있습니다.</p>
<h1>iOS 프로젝트</h1>
<p>지금까지 배운 것으로는, 코드와 아두이노가 준비가 되어 블루투스 장치와 연결하고 정보를 전송할 수 있게 되었어요. 이제는 SwiftUI iOS 프로젝트를 만들어야 할 때입니다.</p>
<h1>XCode 권한</h1>
<p>XCode에서 프로젝트를 생성한 후, "info.plist"에 블루투스 사용을 추가해야 합니다. 그러면 애플리케이션이 사용자에게 다른 블루투스 장치에 연결할 권한을 요청할 수 있어요.</p>
<p>프로젝트 파일에 액세스하고 "info" 탭에 들어가야 해요. 그 화면에 들어가면 기존 항목 위에 마우스 포인터를 두고 "＋"를 클릭해서 "Privacy — Bluetooth Peripheral Usage Description"을 추가해야 해요.</p>
<p>우리가 추가할 이 권한은 사용자에게 Bluetooth 장치에 연결할 권한을 요청하는 것이에요. "value"는 연결을 요청하는 메시지로 사용자에게 표시될 거에요.</p>
<p>그런데 다른 권한인 "Privacy — Bluetooth always usage Description"도 있어요. 이 권한은 앱이 종료되어도 계속 Bluetooth을 사용하도록 사용자에게 요청하는데, 우리가 여기서 제안한 프로젝트에는 필요 없는 권한이에요.</p>
<p>권한을 추가한 후에는 우리의 "info" 목록에 새로운 줄이 이렇게 보여야 해요:</p>
<h1>Swift 코딩</h1>
<p>이제 Arduino를 준비하고 Bluetooth를 사용하기 위한 필수 권한을 설정했으니, 코드 작성을 시작할 수 있습니다.</p>
<p>이 맥락에서, 이 기사에서 "BluetoothController"라고 부르는 부분만 설명하겠습니다. 이 컨트롤러에서 수집된 정보와 데이터를 표시하는 뷰는 GitHub에서 액세스할 수 있지만, 기본적으로 컨트롤러에서 수집된 정보와 데이터를 표시합니다.</p>
<p>이 매체 기사의 이 부분에서 설명하고자 하는 섹션을 넣은 다음, 더 작은 섹션으로 나누어 각각 설명하겠습니다. 세 개의 점을 통과할 때마다, 새로운 섹션을 설명하기 시작함을 나타냅니다.</p>
<p>이렇게 할 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Foundation</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">CoreBluetooth</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">BluetoothController</span>: <span class="hljs-title class_">NSObject</span>, <span class="hljs-title class_">ObservableObject</span>, <span class="hljs-title class_">CBPeripheralDelegate</span> {
    
    private <span class="hljs-keyword">var</span> <span class="hljs-attr">centralManager</span>: <span class="hljs-title class_">CBCentralManager</span>!
    
    @<span class="hljs-title class_">Published</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">connectedPeripheral</span>: <span class="hljs-title class_">CBPeripheral</span>?
    @<span class="hljs-title class_">Published</span> <span class="hljs-keyword">var</span> discoveredPeripherals = [<span class="hljs-title class_">CBPeripheral</span>]()
    @<span class="hljs-title class_">Published</span> <span class="hljs-keyword">var</span> isConnected = <span class="hljs-literal">false</span>
    @<span class="hljs-title class_">Published</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">bluetoothStatus</span>: <span class="hljs-title class_">BluetoothStatus</span> = .<span class="hljs-property">off</span>
    @<span class="hljs-title class_">Published</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">valueReceived</span>: <span class="hljs-title class_">String</span>?
   
    override <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">init</span>()
        centralManager = <span class="hljs-title class_">CBCentralManager</span>(<span class="hljs-attr">delegate</span>: self, <span class="hljs-attr">queue</span>: nil)
        <span class="hljs-title function_">centralManagerDidUpdateState</span>(centralManager)
    }
}
</code></pre>
<p>"BluetoothController"은 뷰에서 정보에 액세스할 것이므로 observable해야 하고, ObjectiveC stuff를 사용할 예정이므로 NSObject여야 하며, 연결될 블루투스 장치(페리페럴)로부터 이벤트를 처리할 수 있는 메서드를 정의하는 CoreBluetooth가 제공하는 프로토콜인 CBPeripheralDelegate를 준수해야 합니다.</p>
<pre><code class="hljs language-js">private <span class="hljs-keyword">var</span> <span class="hljs-attr">centralManager</span>: <span class="hljs-title class_">CBCentralManager</span>!
</code></pre>
<p>우리는 CBCentralManager 타입의 centralManager 변수를 생성했습니다. 이는 CoreBluetooth에서 제공하는 타입으로, BLE 통신에서 중심 역할을 하는 Bluetooth "페리페랄"과 통신 관리를 담당합니다.</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Published</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">connectedPeripheral</span>: <span class="hljs-title class_">CBPeripheral</span>?
@<span class="hljs-title class_">Published</span> <span class="hljs-keyword">var</span> discoveredPeripherals = [<span class="hljs-title class_">CBPeripheral</span>]()
@<span class="hljs-title class_">Published</span> <span class="hljs-keyword">var</span> isConnected = <span class="hljs-literal">false</span>
@<span class="hljs-title class_">Published</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">bluetoothStatus</span>: <span class="hljs-title class_">BluetoothStatus</span> = .<span class="hljs-property">off</span>
@<span class="hljs-title class_">Published</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">valueReceived</span>: <span class="hljs-title class_">String</span>?
</code></pre>
<p>생성된 이 변수들은 화면에 표시할 정보입니다.</p>
<pre><code class="hljs language-js">override <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">init</span>()
        centralManager = <span class="hljs-title class_">CBCentralManager</span>(<span class="hljs-attr">delegate</span>: self, <span class="hljs-attr">queue</span>: nil)
        <span class="hljs-title function_">centralManagerDidUpdateState</span>(centralManager)
}
</code></pre>
<p>마지막으로, init을 사용하여 우리의 슈퍼클래스인 NSObject을 초기화하는 init 메서드가 있습니다. 여기서 모든 BluetoothController의 추가 설정을 제공하기 전에 NSObject에서 제공하는 모든 것을 초기화합니다.</p>
<p>centralManager = CBCentralManager(delegate: self, queue: nil) - 이 줄은 Bluetooth 통신을 위한 "중앙 매니저"인 CBCentralManager의 인스턴스를 초기화합니다. 중앙 매니저의 "delegate"를 self로 설정하여 BluetoothController 인스턴스가 Bluetooth 이벤트에 관련된 반환을 받게 됩니다. 상태 변경, 페리페럴 발견 등과 관련된 반환에 대한 delegate로서 센트럴 매니저가 메인 디스패치 큐를 사용할 것을 나타내는 queue 매개변수는 nil로 설정되어 있습니다.</p>
<p>centralManagerDidUpdateState(centralManager) - 이 줄은 BluetoothController의 centralManagerDidUpdateState 메서드를 직접 호출합니다. 이 메서드는 CBCentralManagerDelegate 프로토콜의 일부이며 Bluetooth 상태가 변경될 때 호출됩니다. 센트럴 매니저를 초기화한 후 이 메서드를 직접 호출함으로써 BluetoothController 인스턴스가 초기화 직후 현재 Bluetooth 상태를 처리할 수 있도록 보장됩니다.</p>
<pre><code class="hljs language-js">extension <span class="hljs-title class_">BluetoothController</span>: <span class="hljs-title class_">CBCentralManagerDelegate</span> {
    
    func <span class="hljs-title function_">centralManagerDidUpdateState</span>(<span class="hljs-params">_ central: CBCentralManager</span>) {
        <span class="hljs-keyword">switch</span> central.<span class="hljs-property">state</span> {
        <span class="hljs-keyword">case</span> .<span class="hljs-property">poweredOn</span>:
            centralManager.<span class="hljs-title function_">scanForPeripherals</span>(<span class="hljs-attr">withServices</span>: nil, <span class="hljs-attr">options</span>: nil)
            bluetoothStatus = <span class="hljs-title class_">BluetoothStatus</span>.<span class="hljs-property">on</span>
            
        <span class="hljs-keyword">case</span> .<span class="hljs-property">poweredOff</span>:
            self.<span class="hljs-property">connectedPeripheral</span> = nil
            self.<span class="hljs-property">discoveredPeripherals</span> = []
            self.<span class="hljs-property">isConnected</span> = <span class="hljs-literal">false</span>
            self.<span class="hljs-property">valueReceived</span> = nil
            bluetoothStatus = <span class="hljs-title class_">BluetoothStatus</span>.<span class="hljs-property">off</span>
            
        <span class="hljs-keyword">case</span> .<span class="hljs-property">resetting</span>:
            <span class="hljs-comment">// Wait for next state update and consider logging interruption of Bluetooth service</span>
            bluetoothStatus = <span class="hljs-title class_">BluetoothStatus</span>.<span class="hljs-property">resetting</span>
            
        <span class="hljs-keyword">case</span> .<span class="hljs-property">unauthorized</span>:
            <span class="hljs-comment">// Alert user to enable Bluetooth permission in app Settings</span>
            bluetoothStatus = <span class="hljs-title class_">BluetoothStatus</span>.<span class="hljs-property">unathorized</span>
            
        <span class="hljs-keyword">case</span> .<span class="hljs-property">unsupported</span>:
            <span class="hljs-comment">// Alert user their device does not support Bluetooth and app will not work as expected</span>
            bluetoothStatus = <span class="hljs-title class_">BluetoothStatus</span>.<span class="hljs-property">unsupported</span>
            
        <span class="hljs-keyword">case</span> .<span class="hljs-property">unknown</span>:
            <span class="hljs-comment">// Wait for next state update</span>
            bluetoothStatus = <span class="hljs-title class_">BluetoothStatus</span>.<span class="hljs-property">unknown</span>
            
        @unknown <span class="hljs-attr">default</span>:
            <span class="hljs-title function_">print</span>(<span class="hljs-string">"---Default case---"</span>)
        }
    }
</code></pre>
<p>"centralManagerDidUpdateState" 메서드 내에서 중앙 매니저의 현재 상태에 따라 다양한 조치가 취해집니다:</p>
<ul>
<li>.poweredOn: Bluetooth가 켜져 있으면 중앙 매니저가 블루투스 장치를 스캔하기 시작합니다</li>
<li>.poweredOff: Bluetooth가 꺼져 있으면, 이미 발견되거나 연결된 장치에 대한 모든 참조를 지우고 Bluetooth를 다시 켤 때 모두 다시 발견해야 합니다.</li>
</ul>
<p>각 상태마다 적절한 처리를 해야 하며, 이 경우에는 블루투스 상태를 현재 상태로 설정하고 이러한 경우를 처리한 것이 아니라는 점을 유의하십시오. 그러나 각 상태가 의미하는 바는 문서에서 찾을 수 있습니다.</p>
<p>본 코드는 본질적으로 Bluetooth 상태 변화를 모니터하고 이에 적절하게 대응하여 애플리케이션이 이러한 변화에 적절하게 반응하도록 보장합니다."</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">centralManager</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">central</span>: <span class="hljs-type">CBCentralManager</span>, <span class="hljs-params">didDiscover</span> <span class="hljs-params">peripheral</span>: <span class="hljs-type">CBPeripheral</span>, <span class="hljs-params">advertisementData</span>: [<span class="hljs-params">String</span> : <span class="hljs-keyword">Any</span>], <span class="hljs-params">rssi</span> <span class="hljs-params">RSSI</span>: <span class="hljs-type">NSNumber</span>) {
    <span class="hljs-keyword">if</span> <span class="hljs-operator">!</span>peripheralAlreadyRegistered(peripheral: peripheral){
        discoveredPeripherals.append(peripheral)
    }
}

<span class="hljs-keyword">func</span> <span class="hljs-title function_">peripheralAlreadyRegistered</span>(<span class="hljs-params">peripheral</span>: <span class="hljs-type">CBPeripheral</span>) -> <span class="hljs-type">Bool</span>{
    <span class="hljs-keyword">return</span> discoveredPeripherals.contains(peripheral)
}
</code></pre>
<p>이제 CentralManager가 감지하는 이벤트에 따라 자동으로 호출되는 일련의 메소드를 입력할 것입니다. 예를 들어, 이전에 블루투스가 켜져 있음을 감지했을 때 "peripheral"를 스캔하기 시작했고, 발견하자마자 첫 번째 함수 "didDiscover"에 들어갔습니다. 여기에는 발견된 페리페럴과 함께 수행할 작업이 포함되어 있습니다.</p>
<p>이 경우에는 기본적으로 이미 발견되었는지 확인한 후, 아직 발견되지 않은 경우에만 발견된 페리페럴을 발견된 페리페럴 배열에 추가했습니다(뷰에 표시될 배열이며 사용자가 어떤 페리페럴에 연결할지 선택할 수 있도록 표시됩니다).</p>
<pre><code class="hljs language-js">func <span class="hljs-title function_">connect</span>(<span class="hljs-params">peripheral: CBPeripheral</span>) {
    centralManager.<span class="hljs-title function_">connect</span>(peripheral, <span class="hljs-attr">options</span>: nil)
}

func <span class="hljs-title function_">centralManager</span>(<span class="hljs-params">_ central: CBCentralManager, didConnect peripheral: CBPeripheral</span>) {
    self.<span class="hljs-property">connectedPeripheral</span> = peripheral
    self.<span class="hljs-property">isConnected</span> = <span class="hljs-literal">true</span>

    peripheral.<span class="hljs-property">delegate</span> = self
    peripheral.<span class="hljs-title function_">discoverServices</span>(nil)
}
</code></pre>
<p>여기에는 뷰에서 선택된 페리페럴에 연결하는 데 책임이 있는 두 가지 함수가 있습니다. 발견된 장치 목록에서 페리페럴을 클릭하면 "connect" 함수를 호출하여 중앙 관리자에게 매개변수로 전달된 페리페럴과의 연결을 요청합니다.</p>
<p>연결이 성공하면 Bluetooth 모듈의 LED가 깜박이는 것이 멈추고 켜져 있어야 합니다.</p>
<p>연결이 성공하면 자동으로 CentralManager 함수 "didConnect"로 들어가며, 이 경우에:</p>
<ul>
<li>연결된 장치에 대한 참조(connectedPeripheral)를 저장합니다.</li>
<li>연결된 주변 장치의 "대리자(delegate)"로서 객체 자체의 정의. 이를 통해 객체는 주변 장치에서 발생하는 이벤트에 대한 알림을 받을 수 있습니다.</li>
<li>연결된 주변 장치로부터 서비스(블루투스 장치가 제공하는 "기능"들에 대해 계속 논의됩니다)를 검색을 시작합니다.</li>
</ul>
<pre><code class="hljs language-js">func <span class="hljs-title function_">centralManager</span>(<span class="hljs-params">_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: <span class="hljs-built_in">Error</span>?</span>) {
    <span class="hljs-comment">// 오류 처리</span>
    <span class="hljs-title function_">print</span>(<span class="hljs-string">"주의: 연결 실패"</span>)
}
</code></pre>
<p>다른 함수가 이것을 호출할 수 있는데, 해당 주변 장치에 연결을 시도할 때 연결에 실패했을 때입니다. 이 경우 콘솔에 연결이 실패했다는 메시지를 출력했지만, 이 시나리오를 처리해야 합니다.</p>
<pre><code class="hljs language-js">func <span class="hljs-title function_">disconnect</span>(<span class="hljs-params"></span>) {
    guard <span class="hljs-keyword">let</span> peripheral = connectedPeripheral <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span>
    }
    centralManager.<span class="hljs-title function_">cancelPeripheralConnection</span>(peripheral)
}

func <span class="hljs-title function_">centralManager</span>(<span class="hljs-params">_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: <span class="hljs-built_in">Error</span>?</span>) {
    self.<span class="hljs-property">connectedPeripheral</span> = nil
    self.<span class="hljs-property">discoveredPeripherals</span> = []
    self.<span class="hljs-property">isConnected</span> = <span class="hljs-literal">false</span>
    self.<span class="hljs-property">valueReceived</span> = nil
        
    centralManager.<span class="hljs-title function_">scanForPeripherals</span>(<span class="hljs-attr">withServices</span>: nil, <span class="hljs-attr">options</span>: nil)
}
</code></pre>
<p>이제 영구적으로 주변 장치와 연결되어 있지 않도록 연결을 해제하는 기능이 있습니다. 이 기능은 우리가 무엇에 연결돼 있는지 확인한 후, CentralManager에 연결을 취소하도록 요청합니다.</p>
<p>이 연결을 취소하면, 이전에 연결돼 있던 것이 더 이상 연결되지 않았으므로 발견된 장치와 연결된 모든 참조를 지우기로 결정했습니다. 게다가, 주변 기기를 연결하고 30m를 걸어가서 이미 발견한 다른 기기를 잃는 경우도 있을 수 있으므로, 그들의 참조를 삭제하여 더 이상 존재하지 않는 것에 연결하려고 하지 않도록 합니다.</p>
<p>그 후, 다시 주변에 있는 주변 기기를 찾기 시작합니다.</p>
<h1>서비스</h1>
<p>기본적으로, 서비스는 주변 장치에서 제공되는 기능을 나타내는 특성의 모음입니다. 각 서비스는 하나 이상의 특성을 포함할 수 있으며, 이러한 특성은 주변 장치에서 제공되는 특정 정보를 나타냅니다.</p>
<p>예를 들어, Bluetooth 주변 장치는 "온도 센서" 서비스를 가질 수 있으며, 이 서비스에는 센서가 측정한 현재 온도를 제공하는 특성이 포함될 수 있습니다. 또한 "LED 제어" 서비스를 가질 수 있으며, 이 서비스에는 LED를 켜거나 끄고 색상을 설정하는 특성이 포함될 수 있습니다.</p>
<pre><code class="hljs language-js">func <span class="hljs-title function_">peripheral</span>(<span class="hljs-params">_ peripheral: CBPeripheral, didDiscoverServices error: <span class="hljs-built_in">Error</span>?</span>) {
        guard peripheral.<span class="hljs-property">services</span> != nil <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span>
        }
        <span class="hljs-title function_">discoverCharacteristics</span>(<span class="hljs-attr">peripheral</span>: peripheral)
}
</code></pre>
<p>장치와의 연결이 끊기거나 연결이 실패할 가능성을 다룬 후, 이전에 서비스를 찾는 함수를 호출한 지점으로 돌아가서, 발견된 서비스가 있을 때 이 함수에 들어가는데, 이것은 이제 CBPeriperalDelegate의 메서드이고 더 이상 CentralManager의 메서드가 아니기 때문에 제 주변 장치에서 발생하는 이벤트는 CBPeripeheralDelegate의 메서드를 통해 처리해야 합니다.</p>
<p>우리가 서비스 검색 시 호출되는 함수는 기본적으로 해당 장치에 서비스가 있는지 확인하고, 서비스가 있는 경우 해당 서비스의 특성을 찾도록 요청합니다.</p>
<pre><code class="hljs language-js">func <span class="hljs-title function_">discoverCharacteristics</span>(<span class="hljs-params">peripheral: CBPeripheral</span>) {
    guard <span class="hljs-keyword">let</span> services = peripheral.<span class="hljs-property">services</span> <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span>
    }
    
    <span class="hljs-keyword">for</span> service <span class="hljs-keyword">in</span> services {
        peripheral.<span class="hljs-title function_">discoverCharacteristics</span>(nil, <span class="hljs-attr">for</span>: service)
    }
}

func <span class="hljs-title function_">peripheral</span>(<span class="hljs-params">_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: <span class="hljs-built_in">Error</span>?</span>) {
    guard <span class="hljs-keyword">let</span> characteristics = service.<span class="hljs-property">characteristics</span> <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span>
    }
    
    <span class="hljs-keyword">for</span> characteristic <span class="hljs-keyword">in</span> characteristics {
        <span class="hljs-keyword">if</span> characteristic.<span class="hljs-property">uuid</span> == <span class="hljs-title function_">CBUUID</span>(<span class="hljs-params">string: <span class="hljs-string">"FFE1"</span></span>) {
            <span class="hljs-keyword">if</span> characteristic.<span class="hljs-property">properties</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-params">.notify</span>) {
                peripheral.<span class="hljs-title function_">setNotifyValue</span>(<span class="hljs-literal">true</span>, <span class="hljs-attr">for</span>: characteristic)
            }
            
            self.<span class="hljs-property">connectedPeripheral</span>?.<span class="hljs-title function_">readValue</span>(<span class="hljs-attr">for</span>: characteristic)
            <span class="hljs-keyword">break</span>
        }
    }
}
</code></pre>
<p>첫 번째 함수는 간단히 발견된 모든 서비스에 있는 특성을 검색하도록 요청합니다. 이러한 특성을 찾으면, CBPeripheralDelegate 대리자가 이 이벤트를 식별하고 "didDiscoverCharacteristics" 메서드를 호출합니다.</p>
<p>이 메서드에서는 특성 목록이 null이 아닌지 확인하고, 그 후에 찾은 모든 특성을 특성 식별자가 "FFE1"인 특성을 찾아냅니다. 이는 우리가 원하는 값을 제공하는 특성이며 값이 변경될 때 경고해주는 notify 속성을 가지고 있습니다.</p>
<p>그 후에 이 속성에 포함된 값이 무엇인지를 읽습니다.</p>
<h1>주의</h1>
<p>HC-08 모듈을 사용하는 이 프로젝트의 경우, 찾고 있는 ID는 "FFE1"입니다. 그러나 다른 모듈을 사용 중이라면 ID가 다를 수도 있습니다.</p>
<p>찾아야 할 기능이 무엇인지 알아보려면 모듈 또는 아두이노의 데이터 시트를 읽는 것을 추천합니다. 또한 "LightBlue"라는 앱을 사용하여 장치에 연결하고 장치가 제공하는 서비스에 대한 정보를 포함하여 장치에 대한 몇 가지 정보를 제공할 수 있습니다.</p>
<p>HC-08 모듈을 사용하는 분들을 위해 gitHub에 데이터 시트를 올려두었어요.</p>
<p><img src="/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_2.png" alt="Bluetooth connection between Arduino and iOS"></p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">peripheral</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">peripheral</span>: <span class="hljs-type">CBPeripheral</span>, <span class="hljs-params">didUpdateValueFor</span> <span class="hljs-params">characteristic</span>: <span class="hljs-type">CBCharacteristic</span>, <span class="hljs-params">error</span>: <span class="hljs-type">Error</span>?) {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> characteristic.value {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> stringValue <span class="hljs-operator">=</span> <span class="hljs-type">String</span>(data: value, encoding: .utf8) {
                valueReceived <span class="hljs-operator">=</span> stringValue
            }
        }
    }
</code></pre>
<p>마지막으로 값을 읽기 위해 요청한 후, 값이 변경되면 "didUpdateValueFor" 메서드에 들어가게 되는데, 이 메서드는 받은 값을 문자열로 변환하는 역할을 담당합니다 (이 프로젝트의 목적은 아두이노에서 보내는 두 문자열을 표시하는 것이기 때문이죠).</p>
<p>그러나 당신의 프로젝트에서는 받고 싶은 데이터 유형으로 변환할 수 있고, 심지어 데이터를 받기 전에 값이 업데이트되길 기다리지 않고도 이 변환을 수행할 수 있습니다. 하지만 이 경우에는 매 두 초마다 문자열을 변경하는 것이 목표였습니다.</p>
<h1>결론</h1>
<p>우리는 다음을 구축했습니다.</p>
<ul>
<li>블루투스 장치와 통신하고 데이터를 수신할 수 있는 클래스;</li>
<li>아두이노에서 블루투스 모듈을 사용하는 방법을 배웠습니다;</li>
<li>아두이노와 iOS가 블루투스를 통해 통신할 수 있도록 만들었습니다.</li>
</ul>
<p>저희의 다음 단계로, BluetoothController에서 제공하는 정보에 액세스하여 원하는 뷰에서 사용해야 합니다.</p>
<p>소스 코드는 제 GitHub에서 확인해주세요.
도움이 되었기를 바랍니다!🫡</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"아두이노와 iOS 간의 블루투스 연결","description":"","date":"2024-05-15 04:34","slug":"2024-05-15-BluetoothconnectionbetweenArduinoandiOS","content":"\n\n# 소개\n\n안녕하세요!! 여기에 오신 것을 환영합니다. 아두이노 장치에서 iOS 장치로 블루투스를 사용하여 데이터를 송수신하는 방법을 찾고 계시다고 생각합니다, 맞나요? (빌드할 내용을 설명하는 비디오가 있는 GitHub 링크를 여기에 배치했습니다).\n\n이를 위해 지식을 두 부분으로 나누기로 결정했습니다. 첫 번째 부분에서는 하드웨어 구체적인 내용, 블루투스 모듈의 조립 및 아두이노 코드를 통해 정보를 전송하는 방법에 대해 다룰 것입니다. 이 문서의 후반부에서는 iOS 개발에 대해 다룰 예정입니다.\n\n# 블루투스 모듈\n\n\n\n이 프로젝트에서는 에너지 소비가 적은 통신 형태인 블루투스를 아두이노와 IOS 장치 간에 사용하기로 결정했습니다. 이것은 배터리로 아두이노를 사용할 때 중요한 요소입니다.\n이를 염두에 두고 프로젝트를 시작할 때의 첫 번째 질문은 아두이노에 이미 블루투스가 내장되어 있는지 여부입니다(이를 위해 문서에 접근할 수 있음). 저의 경우, 블루투스가 내장되어 있지 않은 ArduinoUno를 사용할 예정이므로 이 기술을 제공하는 모듈이 필요합니다.\n\n어떤 모듈을 사용해야 할까요?\niOS 기기는 BLE(Bluetooth Low Energy)라는 기술을 사용하여 통신하며, 일반적인 블루투스와 차이가 있지만, 이는 다른 기사로 남기겠습니다. 따라서 BLE를 지원하는 모듈이 필요하며, 여러 옵션이 있습니다(구매하기 전에 주의하세요), 하지만 저는 HC-08 모듈을 사용할 예정입니다.\n\n![Image](/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png)\n\n# Arduino에 HC-08 연결하기\n\n\n\n조립을 더 잘 설명하기 위해 어셈블리를 시연하기 위한 다이어그램을 만들었습니다.\n\n![Bluetooth Connection Diagram](/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_1.png)\n\n프로젝트에서 핀 2와 3을 이미 사용 중이라면, TX 및 RX를 사용 가능한 핀에 연결할 수 있습니다(이 경우 SoftwareSerial을 사용합니다). 그러나 코드에 도달하면 사용 중인 핀을 변경해야 합니다.\n이미지에 문제가 있을 경우, HC-08에서 아두이노로 연결되는 방법을 적어놓겠습니다:\n\n- VCC → 5V\n- GND → GND\n- TXD(송신) → 2\n- RXD(수신) → 3\n\n\n\n# 코딩 시간\n\n우리가 아두이노에 업로드할 코드는 블루투스 모듈(나의 iOS 기기에 연결될 것)로 정보를 보내고, 그 모듈은 나의 iOS 기기로 데이터를 전송할 것을 목적으로 합니다.\n\n```js\n#include \"SoftwareSerial.h\"\nSoftwareSerial bluetooth(3, 2); //3 = RX ; 2 = TX\n```\n\n기본적으로, 코드의 이 부분에서는 SoftwareSerial 라이브러리를 사용하고 있습니다. 이 라이브러리를 사용하면 아두이노 디지털 핀에 추가적인 시리얼 포트를 생성할 수 있습니다. 이 기능은 시리얼 통신이 필요하지만 이미 주 시리얼 포트를 코드를 디버깅하기 위한 시리얼 모니터로 사용하는 경우와 같이 주 시리얼 포트가 다른 목적으로 이미 사용 중인 경우 유용합니다.\n\n\n\n소프트웨어 시리얼 인스턴스가 이름이 \"bluetooth\"인 것을 만들었습니다. 매개변수 (3, 2)는 아두이노의 핀 3을 RX(수신)로, 핀 2를 TX(송신)로 사용할 것을 나타냅니다 (기본적으로 첫 번째 숫자가 RX이며 두 번째 숫자가 TX입니다).\n\n⚠️만약 다른 핀을 사용했다면, 숫자를 변경하세요.⚠️\n\n```js\nvoid setup() {\n  Serial.begin(9600);\n  bluetooth.begin(9600);\n}\n```\n\n설정 함수에서(스크립트가 실행될 때에만 실행되는 함수), 아두이노와 컴퓨터 사이에 표준 시리얼 포트를 통해 초당 9600비트의 속도로 시리얼 통신을 시작합니다 (디버깅에 유용합니다).\n\n\n\n이제 \"블루투스\"라고 불리는 객체의 직렬 통신을 9600 비트로 설정하여 시작합니다. 이는 아두이노와 핀 2와 3에 연결된 블루투스 모듈 간의 통신을 수립합니다.\n\n```js\nvoid loop() {\n    bluetooth.print(\"성공!\"); \n    delay(2000);\n    bluetooth.print(\"잘 했어요!\");\n    delay(2000);\n}\n```\n\n이제 우리의 루프에서는 코드가 계속해서 실행되며, 기본적으로 블루투스 모듈과 통신하도록 한 책임자에게 문자열을 보내고 있습니다. 매 2초마다 다른 문자열을 보내고 있습니다.\n\n이 코드 스니펫의 아이디어는 여러분의 프로젝트에 맞는 데이터를 가져와 생성된 통신으로 보내는 것입니다. 이 경우 문자열만 보내고 있지만 다양한 유형의 데이터를 보낼 수 있습니다.\n\n\n\n# iOS 프로젝트\n\n지금까지 배운 것으로는, 코드와 아두이노가 준비가 되어 블루투스 장치와 연결하고 정보를 전송할 수 있게 되었어요. 이제는 SwiftUI iOS 프로젝트를 만들어야 할 때입니다.\n\n# XCode 권한\n\nXCode에서 프로젝트를 생성한 후, \"info.plist\"에 블루투스 사용을 추가해야 합니다. 그러면 애플리케이션이 사용자에게 다른 블루투스 장치에 연결할 권한을 요청할 수 있어요.\n\n\n\n프로젝트 파일에 액세스하고 \"info\" 탭에 들어가야 해요. 그 화면에 들어가면 기존 항목 위에 마우스 포인터를 두고 \"＋\"를 클릭해서 \"Privacy — Bluetooth Peripheral Usage Description\"을 추가해야 해요.\n\n우리가 추가할 이 권한은 사용자에게 Bluetooth 장치에 연결할 권한을 요청하는 것이에요. \"value\"는 연결을 요청하는 메시지로 사용자에게 표시될 거에요.\n\n그런데 다른 권한인 \"Privacy — Bluetooth always usage Description\"도 있어요. 이 권한은 앱이 종료되어도 계속 Bluetooth을 사용하도록 사용자에게 요청하는데, 우리가 여기서 제안한 프로젝트에는 필요 없는 권한이에요.\n\n권한을 추가한 후에는 우리의 \"info\" 목록에 새로운 줄이 이렇게 보여야 해요:\n\n\n\n# Swift 코딩\n\n이제 Arduino를 준비하고 Bluetooth를 사용하기 위한 필수 권한을 설정했으니, 코드 작성을 시작할 수 있습니다.\n\n이 맥락에서, 이 기사에서 \"BluetoothController\"라고 부르는 부분만 설명하겠습니다. 이 컨트롤러에서 수집된 정보와 데이터를 표시하는 뷰는 GitHub에서 액세스할 수 있지만, 기본적으로 컨트롤러에서 수집된 정보와 데이터를 표시합니다.\n\n이 매체 기사의 이 부분에서 설명하고자 하는 섹션을 넣은 다음, 더 작은 섹션으로 나누어 각각 설명하겠습니다. 세 개의 점을 통과할 때마다, 새로운 섹션을 설명하기 시작함을 나타냅니다.\n\n\n\n이렇게 할 것입니다:\n\n```js\nimport Foundation\nimport CoreBluetooth\nclass BluetoothController: NSObject, ObservableObject, CBPeripheralDelegate {\n    \n    private var centralManager: CBCentralManager!\n    \n    @Published var connectedPeripheral: CBPeripheral?\n    @Published var discoveredPeripherals = [CBPeripheral]()\n    @Published var isConnected = false\n    @Published var bluetoothStatus: BluetoothStatus = .off\n    @Published var valueReceived: String?\n   \n    override init() {\n        super.init()\n        centralManager = CBCentralManager(delegate: self, queue: nil)\n        centralManagerDidUpdateState(centralManager)\n    }\n}\n```\n\n\"BluetoothController\"은 뷰에서 정보에 액세스할 것이므로 observable해야 하고, ObjectiveC stuff를 사용할 예정이므로 NSObject여야 하며, 연결될 블루투스 장치(페리페럴)로부터 이벤트를 처리할 수 있는 메서드를 정의하는 CoreBluetooth가 제공하는 프로토콜인 CBPeripheralDelegate를 준수해야 합니다.\n\n```js\nprivate var centralManager: CBCentralManager!\n```\n\n\n\n우리는 CBCentralManager 타입의 centralManager 변수를 생성했습니다. 이는 CoreBluetooth에서 제공하는 타입으로, BLE 통신에서 중심 역할을 하는 Bluetooth \"페리페랄\"과 통신 관리를 담당합니다.\n\n```js\n@Published var connectedPeripheral: CBPeripheral?\n@Published var discoveredPeripherals = [CBPeripheral]()\n@Published var isConnected = false\n@Published var bluetoothStatus: BluetoothStatus = .off\n@Published var valueReceived: String?\n```\n\n생성된 이 변수들은 화면에 표시할 정보입니다.\n\n```js\noverride init() {\n        super.init()\n        centralManager = CBCentralManager(delegate: self, queue: nil)\n        centralManagerDidUpdateState(centralManager)\n}\n```\n\n\n\n마지막으로, init을 사용하여 우리의 슈퍼클래스인 NSObject을 초기화하는 init 메서드가 있습니다. 여기서 모든 BluetoothController의 추가 설정을 제공하기 전에 NSObject에서 제공하는 모든 것을 초기화합니다.\n\ncentralManager = CBCentralManager(delegate: self, queue: nil) - 이 줄은 Bluetooth 통신을 위한 \"중앙 매니저\"인 CBCentralManager의 인스턴스를 초기화합니다. 중앙 매니저의 \"delegate\"를 self로 설정하여 BluetoothController 인스턴스가 Bluetooth 이벤트에 관련된 반환을 받게 됩니다. 상태 변경, 페리페럴 발견 등과 관련된 반환에 대한 delegate로서 센트럴 매니저가 메인 디스패치 큐를 사용할 것을 나타내는 queue 매개변수는 nil로 설정되어 있습니다.\n\ncentralManagerDidUpdateState(centralManager) - 이 줄은 BluetoothController의 centralManagerDidUpdateState 메서드를 직접 호출합니다. 이 메서드는 CBCentralManagerDelegate 프로토콜의 일부이며 Bluetooth 상태가 변경될 때 호출됩니다. 센트럴 매니저를 초기화한 후 이 메서드를 직접 호출함으로써 BluetoothController 인스턴스가 초기화 직후 현재 Bluetooth 상태를 처리할 수 있도록 보장됩니다.\n\n```js\nextension BluetoothController: CBCentralManagerDelegate {\n    \n    func centralManagerDidUpdateState(_ central: CBCentralManager) {\n        switch central.state {\n        case .poweredOn:\n            centralManager.scanForPeripherals(withServices: nil, options: nil)\n            bluetoothStatus = BluetoothStatus.on\n            \n        case .poweredOff:\n            self.connectedPeripheral = nil\n            self.discoveredPeripherals = []\n            self.isConnected = false\n            self.valueReceived = nil\n            bluetoothStatus = BluetoothStatus.off\n            \n        case .resetting:\n            // Wait for next state update and consider logging interruption of Bluetooth service\n            bluetoothStatus = BluetoothStatus.resetting\n            \n        case .unauthorized:\n            // Alert user to enable Bluetooth permission in app Settings\n            bluetoothStatus = BluetoothStatus.unathorized\n            \n        case .unsupported:\n            // Alert user their device does not support Bluetooth and app will not work as expected\n            bluetoothStatus = BluetoothStatus.unsupported\n            \n        case .unknown:\n            // Wait for next state update\n            bluetoothStatus = BluetoothStatus.unknown\n            \n        @unknown default:\n            print(\"---Default case---\")\n        }\n    }\n```\n\n\n\n\"centralManagerDidUpdateState\" 메서드 내에서 중앙 매니저의 현재 상태에 따라 다양한 조치가 취해집니다:\n\n- .poweredOn: Bluetooth가 켜져 있으면 중앙 매니저가 블루투스 장치를 스캔하기 시작합니다\n- .poweredOff: Bluetooth가 꺼져 있으면, 이미 발견되거나 연결된 장치에 대한 모든 참조를 지우고 Bluetooth를 다시 켤 때 모두 다시 발견해야 합니다.\n\n각 상태마다 적절한 처리를 해야 하며, 이 경우에는 블루투스 상태를 현재 상태로 설정하고 이러한 경우를 처리한 것이 아니라는 점을 유의하십시오. 그러나 각 상태가 의미하는 바는 문서에서 찾을 수 있습니다.\n\n본 코드는 본질적으로 Bluetooth 상태 변화를 모니터하고 이에 적절하게 대응하여 애플리케이션이 이러한 변화에 적절하게 반응하도록 보장합니다.\"\n\n\n\n```swift\nfunc centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {\n    if !peripheralAlreadyRegistered(peripheral: peripheral){\n        discoveredPeripherals.append(peripheral)\n    }\n}\n\nfunc peripheralAlreadyRegistered(peripheral: CBPeripheral) -\u003e Bool{\n    return discoveredPeripherals.contains(peripheral)\n}\n```\n\n이제 CentralManager가 감지하는 이벤트에 따라 자동으로 호출되는 일련의 메소드를 입력할 것입니다. 예를 들어, 이전에 블루투스가 켜져 있음을 감지했을 때 \"peripheral\"를 스캔하기 시작했고, 발견하자마자 첫 번째 함수 \"didDiscover\"에 들어갔습니다. 여기에는 발견된 페리페럴과 함께 수행할 작업이 포함되어 있습니다.\n\n이 경우에는 기본적으로 이미 발견되었는지 확인한 후, 아직 발견되지 않은 경우에만 발견된 페리페럴을 발견된 페리페럴 배열에 추가했습니다(뷰에 표시될 배열이며 사용자가 어떤 페리페럴에 연결할지 선택할 수 있도록 표시됩니다).\n\n\n\n```js\nfunc connect(peripheral: CBPeripheral) {\n    centralManager.connect(peripheral, options: nil)\n}\n\nfunc centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {\n    self.connectedPeripheral = peripheral\n    self.isConnected = true\n\n    peripheral.delegate = self\n    peripheral.discoverServices(nil)\n}\n```\n\n여기에는 뷰에서 선택된 페리페럴에 연결하는 데 책임이 있는 두 가지 함수가 있습니다. 발견된 장치 목록에서 페리페럴을 클릭하면 \"connect\" 함수를 호출하여 중앙 관리자에게 매개변수로 전달된 페리페럴과의 연결을 요청합니다.\n\n연결이 성공하면 Bluetooth 모듈의 LED가 깜박이는 것이 멈추고 켜져 있어야 합니다.\n\n연결이 성공하면 자동으로 CentralManager 함수 \"didConnect\"로 들어가며, 이 경우에:\n\n\n\n\n- 연결된 장치에 대한 참조(connectedPeripheral)를 저장합니다.\n- 연결된 주변 장치의 \"대리자(delegate)\"로서 객체 자체의 정의. 이를 통해 객체는 주변 장치에서 발생하는 이벤트에 대한 알림을 받을 수 있습니다.\n- 연결된 주변 장치로부터 서비스(블루투스 장치가 제공하는 \"기능\"들에 대해 계속 논의됩니다)를 검색을 시작합니다.\n\n```js\nfunc centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) {\n    // 오류 처리\n    print(\"주의: 연결 실패\")\n}\n```\n\n다른 함수가 이것을 호출할 수 있는데, 해당 주변 장치에 연결을 시도할 때 연결에 실패했을 때입니다. 이 경우 콘솔에 연결이 실패했다는 메시지를 출력했지만, 이 시나리오를 처리해야 합니다.\n\n```js\nfunc disconnect() {\n    guard let peripheral = connectedPeripheral else {\n        return\n    }\n    centralManager.cancelPeripheralConnection(peripheral)\n}\n\nfunc centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {\n    self.connectedPeripheral = nil\n    self.discoveredPeripherals = []\n    self.isConnected = false\n    self.valueReceived = nil\n        \n    centralManager.scanForPeripherals(withServices: nil, options: nil)\n}\n```\n\n\n\n이제 영구적으로 주변 장치와 연결되어 있지 않도록 연결을 해제하는 기능이 있습니다. 이 기능은 우리가 무엇에 연결돼 있는지 확인한 후, CentralManager에 연결을 취소하도록 요청합니다.\n\n이 연결을 취소하면, 이전에 연결돼 있던 것이 더 이상 연결되지 않았으므로 발견된 장치와 연결된 모든 참조를 지우기로 결정했습니다. 게다가, 주변 기기를 연결하고 30m를 걸어가서 이미 발견한 다른 기기를 잃는 경우도 있을 수 있으므로, 그들의 참조를 삭제하여 더 이상 존재하지 않는 것에 연결하려고 하지 않도록 합니다.\n\n그 후, 다시 주변에 있는 주변 기기를 찾기 시작합니다.\n\n# 서비스\n\n\n\n기본적으로, 서비스는 주변 장치에서 제공되는 기능을 나타내는 특성의 모음입니다. 각 서비스는 하나 이상의 특성을 포함할 수 있으며, 이러한 특성은 주변 장치에서 제공되는 특정 정보를 나타냅니다.\n\n예를 들어, Bluetooth 주변 장치는 \"온도 센서\" 서비스를 가질 수 있으며, 이 서비스에는 센서가 측정한 현재 온도를 제공하는 특성이 포함될 수 있습니다. 또한 \"LED 제어\" 서비스를 가질 수 있으며, 이 서비스에는 LED를 켜거나 끄고 색상을 설정하는 특성이 포함될 수 있습니다.\n\n```js\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {\n        guard peripheral.services != nil else {\n            return\n        }\n        discoverCharacteristics(peripheral: peripheral)\n}\n```\n\n장치와의 연결이 끊기거나 연결이 실패할 가능성을 다룬 후, 이전에 서비스를 찾는 함수를 호출한 지점으로 돌아가서, 발견된 서비스가 있을 때 이 함수에 들어가는데, 이것은 이제 CBPeriperalDelegate의 메서드이고 더 이상 CentralManager의 메서드가 아니기 때문에 제 주변 장치에서 발생하는 이벤트는 CBPeripeheralDelegate의 메서드를 통해 처리해야 합니다.\n\n\n\n우리가 서비스 검색 시 호출되는 함수는 기본적으로 해당 장치에 서비스가 있는지 확인하고, 서비스가 있는 경우 해당 서비스의 특성을 찾도록 요청합니다.\n\n```js\nfunc discoverCharacteristics(peripheral: CBPeripheral) {\n    guard let services = peripheral.services else {\n        return\n    }\n    \n    for service in services {\n        peripheral.discoverCharacteristics(nil, for: service)\n    }\n}\n\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {\n    guard let characteristics = service.characteristics else {\n        return\n    }\n    \n    for characteristic in characteristics {\n        if characteristic.uuid == CBUUID(string: \"FFE1\") {\n            if characteristic.properties.contains(.notify) {\n                peripheral.setNotifyValue(true, for: characteristic)\n            }\n            \n            self.connectedPeripheral?.readValue(for: characteristic)\n            break\n        }\n    }\n}\n```\n\n첫 번째 함수는 간단히 발견된 모든 서비스에 있는 특성을 검색하도록 요청합니다. 이러한 특성을 찾으면, CBPeripheralDelegate 대리자가 이 이벤트를 식별하고 \"didDiscoverCharacteristics\" 메서드를 호출합니다.\n\n이 메서드에서는 특성 목록이 null이 아닌지 확인하고, 그 후에 찾은 모든 특성을 특성 식별자가 \"FFE1\"인 특성을 찾아냅니다. 이는 우리가 원하는 값을 제공하는 특성이며 값이 변경될 때 경고해주는 notify 속성을 가지고 있습니다.\n\n\n\n그 후에 이 속성에 포함된 값이 무엇인지를 읽습니다.\n\n# 주의\n\nHC-08 모듈을 사용하는 이 프로젝트의 경우, 찾고 있는 ID는 \"FFE1\"입니다. 그러나 다른 모듈을 사용 중이라면 ID가 다를 수도 있습니다.\n\n찾아야 할 기능이 무엇인지 알아보려면 모듈 또는 아두이노의 데이터 시트를 읽는 것을 추천합니다. 또한 \"LightBlue\"라는 앱을 사용하여 장치에 연결하고 장치가 제공하는 서비스에 대한 정보를 포함하여 장치에 대한 몇 가지 정보를 제공할 수 있습니다.\n\n\n\nHC-08 모듈을 사용하는 분들을 위해 gitHub에 데이터 시트를 올려두었어요.\n\n![Bluetooth connection between Arduino and iOS](/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_2.png)\n\n```swift\nfunc peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {\n        if let value = characteristic.value {\n            if let stringValue = String(data: value, encoding: .utf8) {\n                valueReceived = stringValue\n            }\n        }\n    }\n```\n\n마지막으로 값을 읽기 위해 요청한 후, 값이 변경되면 \"didUpdateValueFor\" 메서드에 들어가게 되는데, 이 메서드는 받은 값을 문자열로 변환하는 역할을 담당합니다 (이 프로젝트의 목적은 아두이노에서 보내는 두 문자열을 표시하는 것이기 때문이죠).\n\n\n\n그러나 당신의 프로젝트에서는 받고 싶은 데이터 유형으로 변환할 수 있고, 심지어 데이터를 받기 전에 값이 업데이트되길 기다리지 않고도 이 변환을 수행할 수 있습니다. 하지만 이 경우에는 매 두 초마다 문자열을 변경하는 것이 목표였습니다.\n\n# 결론\n\n우리는 다음을 구축했습니다.\n\n- 블루투스 장치와 통신하고 데이터를 수신할 수 있는 클래스;\n- 아두이노에서 블루투스 모듈을 사용하는 방법을 배웠습니다;\n- 아두이노와 iOS가 블루투스를 통해 통신할 수 있도록 만들었습니다.\n\n\n\n저희의 다음 단계로, BluetoothController에서 제공하는 정보에 액세스하여 원하는 뷰에서 사용해야 합니다.\n\n소스 코드는 제 GitHub에서 확인해주세요.\n도움이 되었기를 바랍니다!🫡","ogImage":{"url":"/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png"},"coverImage":"/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png","tag":["Tech"],"readingTime":14},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e안녕하세요!! 여기에 오신 것을 환영합니다. 아두이노 장치에서 iOS 장치로 블루투스를 사용하여 데이터를 송수신하는 방법을 찾고 계시다고 생각합니다, 맞나요? (빌드할 내용을 설명하는 비디오가 있는 GitHub 링크를 여기에 배치했습니다).\u003c/p\u003e\n\u003cp\u003e이를 위해 지식을 두 부분으로 나누기로 결정했습니다. 첫 번째 부분에서는 하드웨어 구체적인 내용, 블루투스 모듈의 조립 및 아두이노 코드를 통해 정보를 전송하는 방법에 대해 다룰 것입니다. 이 문서의 후반부에서는 iOS 개발에 대해 다룰 예정입니다.\u003c/p\u003e\n\u003ch1\u003e블루투스 모듈\u003c/h1\u003e\n\u003cp\u003e이 프로젝트에서는 에너지 소비가 적은 통신 형태인 블루투스를 아두이노와 IOS 장치 간에 사용하기로 결정했습니다. 이것은 배터리로 아두이노를 사용할 때 중요한 요소입니다.\n이를 염두에 두고 프로젝트를 시작할 때의 첫 번째 질문은 아두이노에 이미 블루투스가 내장되어 있는지 여부입니다(이를 위해 문서에 접근할 수 있음). 저의 경우, 블루투스가 내장되어 있지 않은 ArduinoUno를 사용할 예정이므로 이 기술을 제공하는 모듈이 필요합니다.\u003c/p\u003e\n\u003cp\u003e어떤 모듈을 사용해야 할까요?\niOS 기기는 BLE(Bluetooth Low Energy)라는 기술을 사용하여 통신하며, 일반적인 블루투스와 차이가 있지만, 이는 다른 기사로 남기겠습니다. 따라서 BLE를 지원하는 모듈이 필요하며, 여러 옵션이 있습니다(구매하기 전에 주의하세요), 하지만 저는 HC-08 모듈을 사용할 예정입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_0.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003ch1\u003eArduino에 HC-08 연결하기\u003c/h1\u003e\n\u003cp\u003e조립을 더 잘 설명하기 위해 어셈블리를 시연하기 위한 다이어그램을 만들었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_1.png\" alt=\"Bluetooth Connection Diagram\"\u003e\u003c/p\u003e\n\u003cp\u003e프로젝트에서 핀 2와 3을 이미 사용 중이라면, TX 및 RX를 사용 가능한 핀에 연결할 수 있습니다(이 경우 SoftwareSerial을 사용합니다). 그러나 코드에 도달하면 사용 중인 핀을 변경해야 합니다.\n이미지에 문제가 있을 경우, HC-08에서 아두이노로 연결되는 방법을 적어놓겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVCC → 5V\u003c/li\u003e\n\u003cli\u003eGND → GND\u003c/li\u003e\n\u003cli\u003eTXD(송신) → 2\u003c/li\u003e\n\u003cli\u003eRXD(수신) → 3\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e코딩 시간\u003c/h1\u003e\n\u003cp\u003e우리가 아두이노에 업로드할 코드는 블루투스 모듈(나의 iOS 기기에 연결될 것)로 정보를 보내고, 그 모듈은 나의 iOS 기기로 데이터를 전송할 것을 목적으로 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#include \u003cspan class=\"hljs-string\"\u003e\"SoftwareSerial.h\"\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eSoftwareSerial\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebluetooth\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e//3 = RX ; 2 = TX\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기본적으로, 코드의 이 부분에서는 SoftwareSerial 라이브러리를 사용하고 있습니다. 이 라이브러리를 사용하면 아두이노 디지털 핀에 추가적인 시리얼 포트를 생성할 수 있습니다. 이 기능은 시리얼 통신이 필요하지만 이미 주 시리얼 포트를 코드를 디버깅하기 위한 시리얼 모니터로 사용하는 경우와 같이 주 시리얼 포트가 다른 목적으로 이미 사용 중인 경우 유용합니다.\u003c/p\u003e\n\u003cp\u003e소프트웨어 시리얼 인스턴스가 이름이 \"bluetooth\"인 것을 만들었습니다. 매개변수 (3, 2)는 아두이노의 핀 3을 RX(수신)로, 핀 2를 TX(송신)로 사용할 것을 나타냅니다 (기본적으로 첫 번째 숫자가 RX이며 두 번째 숫자가 TX입니다).\u003c/p\u003e\n\u003cp\u003e⚠️만약 다른 핀을 사용했다면, 숫자를 변경하세요.⚠️\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetup\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebegin\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e9600\u003c/span\u003e);\n  bluetooth.\u003cspan class=\"hljs-title function_\"\u003ebegin\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e9600\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e설정 함수에서(스크립트가 실행될 때에만 실행되는 함수), 아두이노와 컴퓨터 사이에 표준 시리얼 포트를 통해 초당 9600비트의 속도로 시리얼 통신을 시작합니다 (디버깅에 유용합니다).\u003c/p\u003e\n\u003cp\u003e이제 \"블루투스\"라고 불리는 객체의 직렬 통신을 9600 비트로 설정하여 시작합니다. 이는 아두이노와 핀 2와 3에 연결된 블루투스 모듈 간의 통신을 수립합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloop\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    bluetooth.\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"성공!\"\u003c/span\u003e); \n    \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\n    bluetooth.\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"잘 했어요!\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 우리의 루프에서는 코드가 계속해서 실행되며, 기본적으로 블루투스 모듈과 통신하도록 한 책임자에게 문자열을 보내고 있습니다. 매 2초마다 다른 문자열을 보내고 있습니다.\u003c/p\u003e\n\u003cp\u003e이 코드 스니펫의 아이디어는 여러분의 프로젝트에 맞는 데이터를 가져와 생성된 통신으로 보내는 것입니다. 이 경우 문자열만 보내고 있지만 다양한 유형의 데이터를 보낼 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eiOS 프로젝트\u003c/h1\u003e\n\u003cp\u003e지금까지 배운 것으로는, 코드와 아두이노가 준비가 되어 블루투스 장치와 연결하고 정보를 전송할 수 있게 되었어요. 이제는 SwiftUI iOS 프로젝트를 만들어야 할 때입니다.\u003c/p\u003e\n\u003ch1\u003eXCode 권한\u003c/h1\u003e\n\u003cp\u003eXCode에서 프로젝트를 생성한 후, \"info.plist\"에 블루투스 사용을 추가해야 합니다. 그러면 애플리케이션이 사용자에게 다른 블루투스 장치에 연결할 권한을 요청할 수 있어요.\u003c/p\u003e\n\u003cp\u003e프로젝트 파일에 액세스하고 \"info\" 탭에 들어가야 해요. 그 화면에 들어가면 기존 항목 위에 마우스 포인터를 두고 \"＋\"를 클릭해서 \"Privacy — Bluetooth Peripheral Usage Description\"을 추가해야 해요.\u003c/p\u003e\n\u003cp\u003e우리가 추가할 이 권한은 사용자에게 Bluetooth 장치에 연결할 권한을 요청하는 것이에요. \"value\"는 연결을 요청하는 메시지로 사용자에게 표시될 거에요.\u003c/p\u003e\n\u003cp\u003e그런데 다른 권한인 \"Privacy — Bluetooth always usage Description\"도 있어요. 이 권한은 앱이 종료되어도 계속 Bluetooth을 사용하도록 사용자에게 요청하는데, 우리가 여기서 제안한 프로젝트에는 필요 없는 권한이에요.\u003c/p\u003e\n\u003cp\u003e권한을 추가한 후에는 우리의 \"info\" 목록에 새로운 줄이 이렇게 보여야 해요:\u003c/p\u003e\n\u003ch1\u003eSwift 코딩\u003c/h1\u003e\n\u003cp\u003e이제 Arduino를 준비하고 Bluetooth를 사용하기 위한 필수 권한을 설정했으니, 코드 작성을 시작할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 맥락에서, 이 기사에서 \"BluetoothController\"라고 부르는 부분만 설명하겠습니다. 이 컨트롤러에서 수집된 정보와 데이터를 표시하는 뷰는 GitHub에서 액세스할 수 있지만, 기본적으로 컨트롤러에서 수집된 정보와 데이터를 표시합니다.\u003c/p\u003e\n\u003cp\u003e이 매체 기사의 이 부분에서 설명하고자 하는 섹션을 넣은 다음, 더 작은 섹션으로 나누어 각각 설명하겠습니다. 세 개의 점을 통과할 때마다, 새로운 섹션을 설명하기 시작함을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e이렇게 할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFoundation\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCoreBluetooth\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBluetoothController\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eNSObject\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eObservableObject\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eCBPeripheralDelegate\u003c/span\u003e {\n    \n    private \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecentralManager\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCBCentralManager\u003c/span\u003e!\n    \n    @\u003cspan class=\"hljs-title class_\"\u003ePublished\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econnectedPeripheral\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCBPeripheral\u003c/span\u003e?\n    @\u003cspan class=\"hljs-title class_\"\u003ePublished\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e discoveredPeripherals = [\u003cspan class=\"hljs-title class_\"\u003eCBPeripheral\u003c/span\u003e]()\n    @\u003cspan class=\"hljs-title class_\"\u003ePublished\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e isConnected = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003ePublished\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebluetoothStatus\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBluetoothStatus\u003c/span\u003e = .\u003cspan class=\"hljs-property\"\u003eoff\u003c/span\u003e\n    @\u003cspan class=\"hljs-title class_\"\u003ePublished\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalueReceived\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e?\n   \n    override \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e()\n        centralManager = \u003cspan class=\"hljs-title class_\"\u003eCBCentralManager\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edelegate\u003c/span\u003e: self, \u003cspan class=\"hljs-attr\"\u003equeue\u003c/span\u003e: nil)\n        \u003cspan class=\"hljs-title function_\"\u003ecentralManagerDidUpdateState\u003c/span\u003e(centralManager)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\"BluetoothController\"은 뷰에서 정보에 액세스할 것이므로 observable해야 하고, ObjectiveC stuff를 사용할 예정이므로 NSObject여야 하며, 연결될 블루투스 장치(페리페럴)로부터 이벤트를 처리할 수 있는 메서드를 정의하는 CoreBluetooth가 제공하는 프로토콜인 CBPeripheralDelegate를 준수해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eprivate \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecentralManager\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCBCentralManager\u003c/span\u003e!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 CBCentralManager 타입의 centralManager 변수를 생성했습니다. 이는 CoreBluetooth에서 제공하는 타입으로, BLE 통신에서 중심 역할을 하는 Bluetooth \"페리페랄\"과 통신 관리를 담당합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003ePublished\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econnectedPeripheral\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCBPeripheral\u003c/span\u003e?\n@\u003cspan class=\"hljs-title class_\"\u003ePublished\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e discoveredPeripherals = [\u003cspan class=\"hljs-title class_\"\u003eCBPeripheral\u003c/span\u003e]()\n@\u003cspan class=\"hljs-title class_\"\u003ePublished\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e isConnected = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n@\u003cspan class=\"hljs-title class_\"\u003ePublished\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebluetoothStatus\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBluetoothStatus\u003c/span\u003e = .\u003cspan class=\"hljs-property\"\u003eoff\u003c/span\u003e\n@\u003cspan class=\"hljs-title class_\"\u003ePublished\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalueReceived\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e?\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e생성된 이 변수들은 화면에 표시할 정보입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eoverride \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e()\n        centralManager = \u003cspan class=\"hljs-title class_\"\u003eCBCentralManager\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edelegate\u003c/span\u003e: self, \u003cspan class=\"hljs-attr\"\u003equeue\u003c/span\u003e: nil)\n        \u003cspan class=\"hljs-title function_\"\u003ecentralManagerDidUpdateState\u003c/span\u003e(centralManager)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, init을 사용하여 우리의 슈퍼클래스인 NSObject을 초기화하는 init 메서드가 있습니다. 여기서 모든 BluetoothController의 추가 설정을 제공하기 전에 NSObject에서 제공하는 모든 것을 초기화합니다.\u003c/p\u003e\n\u003cp\u003ecentralManager = CBCentralManager(delegate: self, queue: nil) - 이 줄은 Bluetooth 통신을 위한 \"중앙 매니저\"인 CBCentralManager의 인스턴스를 초기화합니다. 중앙 매니저의 \"delegate\"를 self로 설정하여 BluetoothController 인스턴스가 Bluetooth 이벤트에 관련된 반환을 받게 됩니다. 상태 변경, 페리페럴 발견 등과 관련된 반환에 대한 delegate로서 센트럴 매니저가 메인 디스패치 큐를 사용할 것을 나타내는 queue 매개변수는 nil로 설정되어 있습니다.\u003c/p\u003e\n\u003cp\u003ecentralManagerDidUpdateState(centralManager) - 이 줄은 BluetoothController의 centralManagerDidUpdateState 메서드를 직접 호출합니다. 이 메서드는 CBCentralManagerDelegate 프로토콜의 일부이며 Bluetooth 상태가 변경될 때 호출됩니다. 센트럴 매니저를 초기화한 후 이 메서드를 직접 호출함으로써 BluetoothController 인스턴스가 초기화 직후 현재 Bluetooth 상태를 처리할 수 있도록 보장됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eextension \u003cspan class=\"hljs-title class_\"\u003eBluetoothController\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCBCentralManagerDelegate\u003c/span\u003e {\n    \n    func \u003cspan class=\"hljs-title function_\"\u003ecentralManagerDidUpdateState\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ central: CBCentralManager\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e central.\u003cspan class=\"hljs-property\"\u003estate\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003epoweredOn\u003c/span\u003e:\n            centralManager.\u003cspan class=\"hljs-title function_\"\u003escanForPeripherals\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ewithServices\u003c/span\u003e: nil, \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: nil)\n            bluetoothStatus = \u003cspan class=\"hljs-title class_\"\u003eBluetoothStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eon\u003c/span\u003e\n            \n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003epoweredOff\u003c/span\u003e:\n            self.\u003cspan class=\"hljs-property\"\u003econnectedPeripheral\u003c/span\u003e = nil\n            self.\u003cspan class=\"hljs-property\"\u003ediscoveredPeripherals\u003c/span\u003e = []\n            self.\u003cspan class=\"hljs-property\"\u003eisConnected\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n            self.\u003cspan class=\"hljs-property\"\u003evalueReceived\u003c/span\u003e = nil\n            bluetoothStatus = \u003cspan class=\"hljs-title class_\"\u003eBluetoothStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoff\u003c/span\u003e\n            \n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003eresetting\u003c/span\u003e:\n            \u003cspan class=\"hljs-comment\"\u003e// Wait for next state update and consider logging interruption of Bluetooth service\u003c/span\u003e\n            bluetoothStatus = \u003cspan class=\"hljs-title class_\"\u003eBluetoothStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eresetting\u003c/span\u003e\n            \n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003eunauthorized\u003c/span\u003e:\n            \u003cspan class=\"hljs-comment\"\u003e// Alert user to enable Bluetooth permission in app Settings\u003c/span\u003e\n            bluetoothStatus = \u003cspan class=\"hljs-title class_\"\u003eBluetoothStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eunathorized\u003c/span\u003e\n            \n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003eunsupported\u003c/span\u003e:\n            \u003cspan class=\"hljs-comment\"\u003e// Alert user their device does not support Bluetooth and app will not work as expected\u003c/span\u003e\n            bluetoothStatus = \u003cspan class=\"hljs-title class_\"\u003eBluetoothStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eunsupported\u003c/span\u003e\n            \n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003eunknown\u003c/span\u003e:\n            \u003cspan class=\"hljs-comment\"\u003e// Wait for next state update\u003c/span\u003e\n            bluetoothStatus = \u003cspan class=\"hljs-title class_\"\u003eBluetoothStatus\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eunknown\u003c/span\u003e\n            \n        @unknown \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e:\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"---Default case---\"\u003c/span\u003e)\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\"centralManagerDidUpdateState\" 메서드 내에서 중앙 매니저의 현재 상태에 따라 다양한 조치가 취해집니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e.poweredOn: Bluetooth가 켜져 있으면 중앙 매니저가 블루투스 장치를 스캔하기 시작합니다\u003c/li\u003e\n\u003cli\u003e.poweredOff: Bluetooth가 꺼져 있으면, 이미 발견되거나 연결된 장치에 대한 모든 참조를 지우고 Bluetooth를 다시 켤 때 모두 다시 발견해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e각 상태마다 적절한 처리를 해야 하며, 이 경우에는 블루투스 상태를 현재 상태로 설정하고 이러한 경우를 처리한 것이 아니라는 점을 유의하십시오. 그러나 각 상태가 의미하는 바는 문서에서 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e본 코드는 본질적으로 Bluetooth 상태 변화를 모니터하고 이에 적절하게 대응하여 애플리케이션이 이러한 변화에 적절하게 반응하도록 보장합니다.\"\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecentralManager\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003ecentral\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eCBCentralManager\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003edidDiscover\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eperipheral\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eCBPeripheral\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003eadvertisementData\u003c/span\u003e: [\u003cspan class=\"hljs-params\"\u003eString\u003c/span\u003e : \u003cspan class=\"hljs-keyword\"\u003eAny\u003c/span\u003e], \u003cspan class=\"hljs-params\"\u003erssi\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eRSSI\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eNSNumber\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e!\u003c/span\u003eperipheralAlreadyRegistered(peripheral: peripheral){\n        discoveredPeripherals.append(peripheral)\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eperipheralAlreadyRegistered\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eperipheral\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eCBPeripheral\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-type\"\u003eBool\u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e discoveredPeripherals.contains(peripheral)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 CentralManager가 감지하는 이벤트에 따라 자동으로 호출되는 일련의 메소드를 입력할 것입니다. 예를 들어, 이전에 블루투스가 켜져 있음을 감지했을 때 \"peripheral\"를 스캔하기 시작했고, 발견하자마자 첫 번째 함수 \"didDiscover\"에 들어갔습니다. 여기에는 발견된 페리페럴과 함께 수행할 작업이 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e이 경우에는 기본적으로 이미 발견되었는지 확인한 후, 아직 발견되지 않은 경우에만 발견된 페리페럴을 발견된 페리페럴 배열에 추가했습니다(뷰에 표시될 배열이며 사용자가 어떤 페리페럴에 연결할지 선택할 수 있도록 표시됩니다).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efunc \u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eperipheral: CBPeripheral\u003c/span\u003e) {\n    centralManager.\u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e(peripheral, \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: nil)\n}\n\nfunc \u003cspan class=\"hljs-title function_\"\u003ecentralManager\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ central: CBCentralManager, didConnect peripheral: CBPeripheral\u003c/span\u003e) {\n    self.\u003cspan class=\"hljs-property\"\u003econnectedPeripheral\u003c/span\u003e = peripheral\n    self.\u003cspan class=\"hljs-property\"\u003eisConnected\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n\n    peripheral.\u003cspan class=\"hljs-property\"\u003edelegate\u003c/span\u003e = self\n    peripheral.\u003cspan class=\"hljs-title function_\"\u003ediscoverServices\u003c/span\u003e(nil)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에는 뷰에서 선택된 페리페럴에 연결하는 데 책임이 있는 두 가지 함수가 있습니다. 발견된 장치 목록에서 페리페럴을 클릭하면 \"connect\" 함수를 호출하여 중앙 관리자에게 매개변수로 전달된 페리페럴과의 연결을 요청합니다.\u003c/p\u003e\n\u003cp\u003e연결이 성공하면 Bluetooth 모듈의 LED가 깜박이는 것이 멈추고 켜져 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e연결이 성공하면 자동으로 CentralManager 함수 \"didConnect\"로 들어가며, 이 경우에:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e연결된 장치에 대한 참조(connectedPeripheral)를 저장합니다.\u003c/li\u003e\n\u003cli\u003e연결된 주변 장치의 \"대리자(delegate)\"로서 객체 자체의 정의. 이를 통해 객체는 주변 장치에서 발생하는 이벤트에 대한 알림을 받을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e연결된 주변 장치로부터 서비스(블루투스 장치가 제공하는 \"기능\"들에 대해 계속 논의됩니다)를 검색을 시작합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efunc \u003cspan class=\"hljs-title function_\"\u003ecentralManager\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e?\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 오류 처리\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"주의: 연결 실패\"\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 함수가 이것을 호출할 수 있는데, 해당 주변 장치에 연결을 시도할 때 연결에 실패했을 때입니다. 이 경우 콘솔에 연결이 실패했다는 메시지를 출력했지만, 이 시나리오를 처리해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efunc \u003cspan class=\"hljs-title function_\"\u003edisconnect\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    guard \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e peripheral = connectedPeripheral \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n    }\n    centralManager.\u003cspan class=\"hljs-title function_\"\u003ecancelPeripheralConnection\u003c/span\u003e(peripheral)\n}\n\nfunc \u003cspan class=\"hljs-title function_\"\u003ecentralManager\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e?\u003c/span\u003e) {\n    self.\u003cspan class=\"hljs-property\"\u003econnectedPeripheral\u003c/span\u003e = nil\n    self.\u003cspan class=\"hljs-property\"\u003ediscoveredPeripherals\u003c/span\u003e = []\n    self.\u003cspan class=\"hljs-property\"\u003eisConnected\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n    self.\u003cspan class=\"hljs-property\"\u003evalueReceived\u003c/span\u003e = nil\n        \n    centralManager.\u003cspan class=\"hljs-title function_\"\u003escanForPeripherals\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ewithServices\u003c/span\u003e: nil, \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: nil)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 영구적으로 주변 장치와 연결되어 있지 않도록 연결을 해제하는 기능이 있습니다. 이 기능은 우리가 무엇에 연결돼 있는지 확인한 후, CentralManager에 연결을 취소하도록 요청합니다.\u003c/p\u003e\n\u003cp\u003e이 연결을 취소하면, 이전에 연결돼 있던 것이 더 이상 연결되지 않았으므로 발견된 장치와 연결된 모든 참조를 지우기로 결정했습니다. 게다가, 주변 기기를 연결하고 30m를 걸어가서 이미 발견한 다른 기기를 잃는 경우도 있을 수 있으므로, 그들의 참조를 삭제하여 더 이상 존재하지 않는 것에 연결하려고 하지 않도록 합니다.\u003c/p\u003e\n\u003cp\u003e그 후, 다시 주변에 있는 주변 기기를 찾기 시작합니다.\u003c/p\u003e\n\u003ch1\u003e서비스\u003c/h1\u003e\n\u003cp\u003e기본적으로, 서비스는 주변 장치에서 제공되는 기능을 나타내는 특성의 모음입니다. 각 서비스는 하나 이상의 특성을 포함할 수 있으며, 이러한 특성은 주변 장치에서 제공되는 특정 정보를 나타냅니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, Bluetooth 주변 장치는 \"온도 센서\" 서비스를 가질 수 있으며, 이 서비스에는 센서가 측정한 현재 온도를 제공하는 특성이 포함될 수 있습니다. 또한 \"LED 제어\" 서비스를 가질 수 있으며, 이 서비스에는 LED를 켜거나 끄고 색상을 설정하는 특성이 포함될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efunc \u003cspan class=\"hljs-title function_\"\u003eperipheral\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ peripheral: CBPeripheral, didDiscoverServices error: \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e?\u003c/span\u003e) {\n        guard peripheral.\u003cspan class=\"hljs-property\"\u003eservices\u003c/span\u003e != nil \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n        }\n        \u003cspan class=\"hljs-title function_\"\u003ediscoverCharacteristics\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eperipheral\u003c/span\u003e: peripheral)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e장치와의 연결이 끊기거나 연결이 실패할 가능성을 다룬 후, 이전에 서비스를 찾는 함수를 호출한 지점으로 돌아가서, 발견된 서비스가 있을 때 이 함수에 들어가는데, 이것은 이제 CBPeriperalDelegate의 메서드이고 더 이상 CentralManager의 메서드가 아니기 때문에 제 주변 장치에서 발생하는 이벤트는 CBPeripeheralDelegate의 메서드를 통해 처리해야 합니다.\u003c/p\u003e\n\u003cp\u003e우리가 서비스 검색 시 호출되는 함수는 기본적으로 해당 장치에 서비스가 있는지 확인하고, 서비스가 있는 경우 해당 서비스의 특성을 찾도록 요청합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efunc \u003cspan class=\"hljs-title function_\"\u003ediscoverCharacteristics\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eperipheral: CBPeripheral\u003c/span\u003e) {\n    guard \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e services = peripheral.\u003cspan class=\"hljs-property\"\u003eservices\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n    }\n    \n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e service \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e services {\n        peripheral.\u003cspan class=\"hljs-title function_\"\u003ediscoverCharacteristics\u003c/span\u003e(nil, \u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: service)\n    }\n}\n\nfunc \u003cspan class=\"hljs-title function_\"\u003eperipheral\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e?\u003c/span\u003e) {\n    guard \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e characteristics = service.\u003cspan class=\"hljs-property\"\u003echaracteristics\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n    }\n    \n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e characteristic \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e characteristics {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e characteristic.\u003cspan class=\"hljs-property\"\u003euuid\u003c/span\u003e == \u003cspan class=\"hljs-title function_\"\u003eCBUUID\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estring: \u003cspan class=\"hljs-string\"\u003e\"FFE1\"\u003c/span\u003e\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e characteristic.\u003cspan class=\"hljs-property\"\u003eproperties\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econtains\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e.notify\u003c/span\u003e) {\n                peripheral.\u003cspan class=\"hljs-title function_\"\u003esetNotifyValue\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: characteristic)\n            }\n            \n            self.\u003cspan class=\"hljs-property\"\u003econnectedPeripheral\u003c/span\u003e?.\u003cspan class=\"hljs-title function_\"\u003ereadValue\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: characteristic)\n            \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 번째 함수는 간단히 발견된 모든 서비스에 있는 특성을 검색하도록 요청합니다. 이러한 특성을 찾으면, CBPeripheralDelegate 대리자가 이 이벤트를 식별하고 \"didDiscoverCharacteristics\" 메서드를 호출합니다.\u003c/p\u003e\n\u003cp\u003e이 메서드에서는 특성 목록이 null이 아닌지 확인하고, 그 후에 찾은 모든 특성을 특성 식별자가 \"FFE1\"인 특성을 찾아냅니다. 이는 우리가 원하는 값을 제공하는 특성이며 값이 변경될 때 경고해주는 notify 속성을 가지고 있습니다.\u003c/p\u003e\n\u003cp\u003e그 후에 이 속성에 포함된 값이 무엇인지를 읽습니다.\u003c/p\u003e\n\u003ch1\u003e주의\u003c/h1\u003e\n\u003cp\u003eHC-08 모듈을 사용하는 이 프로젝트의 경우, 찾고 있는 ID는 \"FFE1\"입니다. 그러나 다른 모듈을 사용 중이라면 ID가 다를 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e찾아야 할 기능이 무엇인지 알아보려면 모듈 또는 아두이노의 데이터 시트를 읽는 것을 추천합니다. 또한 \"LightBlue\"라는 앱을 사용하여 장치에 연결하고 장치가 제공하는 서비스에 대한 정보를 포함하여 장치에 대한 몇 가지 정보를 제공할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eHC-08 모듈을 사용하는 분들을 위해 gitHub에 데이터 시트를 올려두었어요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-BluetoothconnectionbetweenArduinoandiOS_2.png\" alt=\"Bluetooth connection between Arduino and iOS\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eperipheral\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eperipheral\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eCBPeripheral\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003edidUpdateValueFor\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003echaracteristic\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eCBCharacteristic\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eError\u003c/span\u003e?) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e value \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e characteristic.value {\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e stringValue \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e(data: value, encoding: .utf8) {\n                valueReceived \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e stringValue\n            }\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로 값을 읽기 위해 요청한 후, 값이 변경되면 \"didUpdateValueFor\" 메서드에 들어가게 되는데, 이 메서드는 받은 값을 문자열로 변환하는 역할을 담당합니다 (이 프로젝트의 목적은 아두이노에서 보내는 두 문자열을 표시하는 것이기 때문이죠).\u003c/p\u003e\n\u003cp\u003e그러나 당신의 프로젝트에서는 받고 싶은 데이터 유형으로 변환할 수 있고, 심지어 데이터를 받기 전에 값이 업데이트되길 기다리지 않고도 이 변환을 수행할 수 있습니다. 하지만 이 경우에는 매 두 초마다 문자열을 변경하는 것이 목표였습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e우리는 다음을 구축했습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e블루투스 장치와 통신하고 데이터를 수신할 수 있는 클래스;\u003c/li\u003e\n\u003cli\u003e아두이노에서 블루투스 모듈을 사용하는 방법을 배웠습니다;\u003c/li\u003e\n\u003cli\u003e아두이노와 iOS가 블루투스를 통해 통신할 수 있도록 만들었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e저희의 다음 단계로, BluetoothController에서 제공하는 정보에 액세스하여 원하는 뷰에서 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003e소스 코드는 제 GitHub에서 확인해주세요.\n도움이 되었기를 바랍니다!🫡\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-15-BluetoothconnectionbetweenArduinoandiOS"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>