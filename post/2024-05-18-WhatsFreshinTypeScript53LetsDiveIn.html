<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TypeScript 53에 새로 추가된 내용 정리 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TypeScript 53에 새로 추가된 내용 정리 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="TypeScript 53에 새로 추가된 내용 정리 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn" data-gatsby-head="true"/><meta name="twitter:title" content="TypeScript 53에 새로 추가된 내용 정리 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 21:47" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-742e6c91a18eb160.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">TypeScript 53에 새로 추가된 내용 정리</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="TypeScript 53에 새로 추가된 내용 정리" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png" alt="2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0"></p>
<p>자바스크립트로 작업 중인 상황을 상상해보세요. 이 언어는 유연하지만 때로는 까다로운 면이 있습니다.</p>
<p>타입스크립트는 코드를 실행하기 전에 실수를 잡아주는 일종의 보조 역할을 하는데요.</p>
<p>변수와 함수와 같은 요소들의 타입을 명시하는 방법을 추가함으로써 이를 수행합니다.</p>
<p>그러니까, 흔한 오류를 미리 방지하는 데 넘어서 TypeScript는 테이블에 몇 가지 멋진 기능을 가져다 줍니다. 이것을 한 마디로 말하면, 오타를 만들 것 같을 때나 특정 사항을 확인을 잊었을 때 지적해주는 스마트한 친구가 있다고 생각해보세요. 하나 더, 코드를 작성하는 동안 당신을 도와주기도 합니다.</p>
<p>Visual Studio 또는 VS Code를 사용해 본 적이 있다면, 자동 완성, 코드 탐색, 코드를 더 깔끔하게 만드는 매력적인 부분이 TypeScript가 뒷담화로 작동하고 있다는 거죠.</p>
<p>호기심이 생겼고 TypeScript를 한 번 시도해 보고 싶다면, TypeScript를 사용하는 방법은 다음과 같습니다:</p>
<p>TypeScript를 시작해 보려면 NuGet을 사용하여 가져올 수 있고, npm 세계에 더 익숙하다면 다음 명령어를 입력해 보세요:</p>
<pre><code class="hljs language-js">npm install -D typescript
</code></pre>
<h1>Import 속성</h1>
<p>TypeScript 5.3에서 새로 추가된 멋진 기능 중 하나는 import 속성입니다. 이것들은 런타임에 가져온 항목들을 다루는 방법에 대한 특정 세부사항을 알려주는 작은 태그 같은 역할을 합니다.</p>
<p>예를 들어, JSON 파일을 가져올 때 이것이 JSON으로 처리되고 실행 가능한 JavaScript로 처리되지 않도록 하려면 다음과 같이 할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> obj <span class="hljs-keyword">from</span> <span class="hljs-string">"./something.json"</span> <span class="hljs-keyword">with</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">"json"</span> };
</code></pre>
<p>이러한 속성은 TypeScript 자체에서 확인되지 않습니다. 대신 브라우저나 런타임이 따를 주석과 같습니다. 따라서 자유롭게 사용할 수 있지만, 무의미한 유형을 사용하여 브라우저를 혼란스럽게 하지 않도록 주의하십시오:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">"./foo.js"</span> <span class="hljs-keyword">with</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">"fluffy bunny"</span> };
</code></pre>
<p>동적 임포트인 import()로 만든 임포트도 이러한 임포트 속성을 사용할 수 있습니다:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">"./something.json"</span>, {
    <span class="hljs-attr">with</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">"json"</span> }
});
</code></pre>
<p>재밌는 점은 TypeScript가 예전 기능인 "import assertions"에서 이 새로운 import 속성으로 이동하고 있다는 것입니다.</p>
<p>이제 더 이상 assert 키워드를 사용하는 대신 with를 사용합니다. 이전 코드에 assert가 있는 경우, 새로운 문법인 with를 사용하도록 업데이트하는 것이 권장됩니다.</p>
<h1>Import 타입에서 버그 수정된 해상도 모드 안정성 지원</h1>
<p>현재는 Markdown 형식을 사용하고 있는 것 같네요. 예를 들어, 코드에서 타입 가져오기를 기존 require처럼 처리하거나 현대적인 import처럼 처리할지 결정할 때 사용하는 설정과 비슷한 거죠.</p>
<p>코드에서 타입 가져오기를 예전 방식인 require()처럼 처리하고 싶다면 다음과 같이 할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> type { <span class="hljs-title class_">TypeFromRequire</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"pkg"</span> <span class="hljs-keyword">with</span> {
    <span class="hljs-string">"resolution-mode"</span>: <span class="hljs-string">"require"</span>
};
</code></pre>
<p>그리고 새로운 import 방식을 선호한다면, 이렇게 할 수도 있죠:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> type { <span class="hljs-title class_">TypeFromImport</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"pkg"</span> <span class="hljs-keyword">with</span> {
    <span class="hljs-string">"resolution-mode"</span>: <span class="hljs-string">"import"</span>
};
</code></pre>
<p>하지만 여기에 멋진 부분이 있어요. 이 기능은 처음에 import 어써션에 사용할 수 없었는데요, 이는 모듈이 어떻게 처리되어야 하는지에 대한 힌트 같은 것입니다.</p>
<p>지금은 TypeScript 5.3에서 이 "resolution-mode" 속성을 import 타입에도 확장했습니다. 따라서, 이제 일반적인 import뿐만 아니라 import()를 사용하여 동적으로 타입을 끌어올 때에도 사용할 수 있어요.</p>
<p>여기에 더 실용적인 예시가 있습니다:```</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> type <span class="hljs-title class_">TypeFromRequire</span> =
    <span class="hljs-keyword">import</span>(<span class="hljs-string">"pkg"</span>, { <span class="hljs-attr">with</span>: { <span class="hljs-string">"resolution-mode"</span>: <span class="hljs-string">"require"</span> } }).<span class="hljs-property">TypeFromRequire</span>;

<span class="hljs-keyword">export</span> type <span class="hljs-title class_">TypeFromImport</span> =
    <span class="hljs-keyword">import</span>(<span class="hljs-string">"pkg"</span>, { <span class="hljs-attr">with</span>: { <span class="hljs-string">"resolution-mode"</span>: <span class="hljs-string">"import"</span> } }).<span class="hljs-property">TypeFromImport</span>;

<span class="hljs-keyword">export</span> interface <span class="hljs-title class_">MergedType</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TypeFromRequire</span>, <span class="hljs-title class_">TypeFromImport</span> {}
</code></pre>
<h1>resolution-mode All Module Modes에서 지원됩니다.</h1>
<p>과거에는 node16 및 nodenext와 같은 특정 moduleResolution 옵션에서만 resolution-mode 마법을 사용할 수 있었습니다.</p>
<p>하지만 생각해보세요! TypeScript 5.3가 삶을 더 간단하게 만들어줍니다. 이제 bundler, node10 및 심지어 classic와 같은 모든 다른 moduleResolution 옵션과 함께 resolution-mode를 사용할 수 있습니다.</p>
<p>더는 당신이 타입을 다루는 방식을 조정하고 싶어서 발생하는 오류가 더 이상 나타나지 않는다.</p>
<p>TypeScript는 여러분이 원하는 모듈 모드에서 자유롭게 작업할 수 있도록 더 널널해졌어요. 멋지죠?</p>
<h1>switch (true) 좁히기</h1>
<p>이제 true로 설정된 switch 문을 다룰 때, TypeScript가 각 case의 조건에 따라 타입을 똑똑하게 좁힐 수 있어요. 자세히 설명해 드릴게요.</p>
<p>자, 이런 함수가 있다고 하자:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x: unknown</span>) {
    <span class="hljs-keyword">switch</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">"string"</span>:
            <span class="hljs-comment">// 'x'은 여기서 'string'입니다.</span>
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x.<span class="hljs-title function_">toUpperCase</span>());
            <span class="hljs-comment">// 계속 진행...</span>

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(x):
            <span class="hljs-comment">// 'x'는 여기서 'string | any[]' 입니다.</span>
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x.<span class="hljs-property">length</span>);
            <span class="hljs-comment">// 계속 진행...</span>

        <span class="hljs-attr">default</span>:
            <span class="hljs-comment">// 'x'는 여기서 'unknown'입니다.</span>
            <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<p>여기서 하는 일은, 각 case의 조건에 따라 TypeScript가 'x'의 유형을 더 수월하게 파악하는 것입니다.</p>
<p>예를 들어, 'x'가 문자열이면, 그것을 알고 있으며, toUpperCase()와 같은 문자열 관련 작업을 수행할 수 있습니다. 배열인 경우에도 이해합니다.</p>
<h1>불리언에 대한 비교 좁히기</h1>
<p>당신이 직접적으로 true 또는 false와 비교를 할 때를 말해요. 스타일적 이유이거나 JavaScript의 특징을 처리하기 위해서 명시적으로 무언가가 true인지 false인지 확인할 때 그렇습니다.</p>
<p>이전에 TypeScript는 이러한 비교를 인지하지 못했지만, 이제는 도와줄 준비가 되어 있어요. 한 예제로 보여드릴게요:</p>
<pre><code class="hljs language-js">interface A {
    <span class="hljs-attr">a</span>: string;
}

interface B {
    <span class="hljs-attr">b</span>: string;
}

type <span class="hljs-title class_">MyType</span> = A | B;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">isA</span>(<span class="hljs-params">x: MyType</span>): x is A {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"a"</span> <span class="hljs-keyword">in</span> x;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">someFn</span>(<span class="hljs-params">x: MyType</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isA</span>(x) === <span class="hljs-literal">true</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x.<span class="hljs-property">a</span>); <span class="hljs-comment">// TypeScript가 이해했어요!</span>
    }
}
</code></pre>
<p>그래, isA(x) === true를 보셨나요? TypeScript가 그것을 이해하고 if 블록 내에서 타입을 더 좁게 인식할 수 있게 되었습니다.</p>
<p>그래서 TypeScript가 불평하지 않고도 console.log(x.a)와 같은 작업을 자신 있게 수행할 수 있습니다.</p>
<h1>Symbol.hasInstance를 통한 좁히기</h1>
<p>instanceof를 사용할 때, [Symbol.hasInstance]로 정의된 메서드를 고려하여 더 똑똑해졌습니다. 이는 사용자 정의 타입 가드를 사용하여 타입을 더 정확하게 좁힐 수 있게 되었다는 것을 의미합니다.</p>
<p>예를 통해 설명해 드리겠습니다:</p>
<p>Point라는 클래스가 있다고 상상해 보세요. 이제 TypeScript를 사용하여 [Symbol.hasInstance]를 사용하여 해당 클래스에 특별한 메서드를 정의할 수 있습니다. 이 메서드에서는 Point와 유사한지를 확인하기 위한 사용자 지정 로직을 구현할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
    <span class="hljs-keyword">static</span> [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>](<span class="hljs-attr">val</span>: unknown): val is <span class="hljs-title class_">PointLike</span> {
        <span class="hljs-comment">// 여기에 사용자 정의 타입 가드 로직을 넣으세요</span>
    }
}
</code></pre>
<p>그런 다음 코드에서 instanceof를 사용할 때 TypeScript는 사용자 정의 타입 가드를 인식하고 활용할 수 있습니다. 예를 들면:</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">value: <span class="hljs-built_in">unknown</span></span>) {
    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Point</span>) {
        <span class="hljs-comment">// Now, you can access properties defined in PointLike,</span>
        <span class="hljs-comment">// but you won't have access to specific Point methods or properties.</span>
    }
}
</code></pre>
<p>그래서 이 기능은 기본적으로 TypeScript가 사용자 정의 유형 확인을 정말 이해하고 유형을 더 정확하게 좁힐 수 있도록 합니다.</p>
<h1>인스턴스 필드에서 수퍼 속성 액세스를 위한 검사</h1>
<p>클래스를 다룰 때 기반 클래스에서 메서드에 접근하기 위해 super 키워드를 사용할 수 있습니다. 이것은 "이 클래스에서 상속 받은 클래스로부터 메서드를 가져오게 해줘"라는 방식입니다.</p>
<p>예를 들어:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {
    <span class="hljs-title function_">someMethod</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"베이스 메서드 호출됨!"</span>);
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Base</span> {
    <span class="hljs-title function_">someMethod</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"파생 메서드 호출됨!"</span>);
        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">someMethod</span>();
    }
}

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Derived</span>().<span class="hljs-title function_">someMethod</span>();
<span class="hljs-comment">// 출력:</span>
<span class="hljs-comment">//   파생 메서드 호출됨!</span>
<span class="hljs-comment">//   베이스 메서드 호출됨!</span>
</code></pre>
<p>따라서 super.someMethod()은 베이스 클래스에서 메서드를 특별히 얻는 방법임을 알 수 있습니다.</p>
<p>이제 여기가 tricky한 부분입니다. 클래스 필드(전체의 속성)를 다룬다면, 동일한 방식으로 super를 사용하는 것이 예상대로 작동하지 않을 수 있습니다. TypeScript 5.3는 이를 잘 파악하여 경고를 제공합니다.</p>
<p>여기 예시가 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {
    someMethod = <span class="hljs-function">() =></span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"someMethod called!"</span>);
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Base</span> {
    <span class="hljs-title function_">someOtherMethod</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">someMethod</span>(); <span class="hljs-comment">// 이제 오류가 발생할 거예요!</span>
    }
}

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Derived</span>().<span class="hljs-title function_">someOtherMethod</span>();
<span class="hljs-comment">// 💥</span>
<span class="hljs-comment">// 'super.someMethod'이 'undefined'이기 때문에 작동하지 않아요.</span>
</code></pre>
<p>그래서 TypeScript 5.3은 super를 사용하여 무언가에 접근할 때 그것이 클래스 필드인지 확인해요. 그게 맞다면, super를 통해 접근하려고 하면 TypeScript가 런타임 오류에 부딪히기 전에 멈춰줄 거예요. 코드에 잠입하는 교묘한 버그를 막기 위해 친구가 코드를 한 번 더 확인해주는 것 같죠!</p>
<h1>자동 Imports 유형을 선호하는 설정</h1>
<p>자동으로 타입에 대한 import를 추가할 때, 이전에는 사용자 설정을 기반으로 했습니다. 예를 들어, Person이라는 타입이 있는 경우:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Person</span>;
</code></pre>
<p>TypeScript는 보통 다음과 같이 import를 추가했을 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Person</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Person</span>;
</code></pre>
<p>하지만 설정에 따라 다를 수 있습니다. 예를 들어, verbatimModuleSyntax와 같은 특정 설정이 있는 경우에는 type 수정자를 추가할 수도 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { type <span class="hljs-title class_">Person</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"./types"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">p</span>: <span class="hljs-title class_">Person</span>;
</code></pre>
<p>이제 TypeScript는 더 많은 제어권을 제공합니다. 특정한 선호도가 있거나 코드베이스에서 특정 옵션을 사용할 수 없는 경우, 가능한 경우에는 항상 명시적인 타입 가져오기를 설정할 수 있습니다. 이는 "안녕 TypeScript, 이렇게 해 달라고 말했어, 깜짝 놀라지 말고"라고 말하는 것과 같습니다. 그래서 TypeScript를 자신이 원하는 방식으로 작동하도록 만드는 것입니다.</p>
<h1>TypeScript 5.3에서 몇 가지 최적화가 소개되었습니다:</h1>
<p>우선, JSDoc 파싱을 스킵하고 있습니다. 이는 TypeScript가 JSDoc에 불필요한 시간과 메모리를 소비하지 않아 컴파일 속도를 높일 수 있음을 의미합니다.</p>
<p>특히 변경 사항이 빈번한 감시 모드에서 이 점이 특히 두드러집니다. 게다가, 이 개선은 TypeScript 자체뿐만 아니라 typescript-eslint와 Prettier와 같은 도구들도 이 속도 및 메모리 향상으로 이점을 얻을 수 있습니다.</p>
<p>또한, TypeScript가 교차(intersections)를 처리하는 방식에 최적화가 있습니다. 이는 TypeScript가 유니언과 교차에서 특히 타입을 비교하는 데 능숙해지고 있는 것과 같습니다.</p>
<p>원본 교차형식을 살펴보면, 이제 더 빠르게 확인할 수 있어 타입 평가가 더 효율적으로 이루어집니다.</p>
<p>마지막으로 TypeScript는 tsserverlibrary.js 및 typescript.js 라이브러리 파일을 합치면서 봄철처럼 청소를 하고 있어요.</p>
<p>중복을 줄이고 일관성을 높이기 위해 이들을 결합하고 있습니다.</p>
<p>이렇게 하면 API 사용이 보다 간소화되며 자원 사용량이 감소하는데 도움이 됩니다. 모든 것이 제 자리에 있고 원활하게 작동되도록 집을 정리하는 것과 같아요.</p>
<p>자세한 변경 사항에 대한 내용은 여기에서 확인할 수 있는 완전한 릴리스 로그를 참조해 주세요.</p>
<p>제 Medium 페이지와 연결해 보세요! ✍ : <a href="https://medium.com/@Evelyn.Taylor" rel="nofollow" target="_blank">https://medium.com/@Evelyn.Taylor</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"TypeScript 53에 새로 추가된 내용 정리","description":"","date":"2024-05-18 21:47","slug":"2024-05-18-WhatsFreshinTypeScript53LetsDiveIn","content":"\n\n\n![2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0](/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png)\n\n자바스크립트로 작업 중인 상황을 상상해보세요. 이 언어는 유연하지만 때로는 까다로운 면이 있습니다.\n\n타입스크립트는 코드를 실행하기 전에 실수를 잡아주는 일종의 보조 역할을 하는데요.\n\n변수와 함수와 같은 요소들의 타입을 명시하는 방법을 추가함으로써 이를 수행합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러니까, 흔한 오류를 미리 방지하는 데 넘어서 TypeScript는 테이블에 몇 가지 멋진 기능을 가져다 줍니다. 이것을 한 마디로 말하면, 오타를 만들 것 같을 때나 특정 사항을 확인을 잊었을 때 지적해주는 스마트한 친구가 있다고 생각해보세요. 하나 더, 코드를 작성하는 동안 당신을 도와주기도 합니다.\n\nVisual Studio 또는 VS Code를 사용해 본 적이 있다면, 자동 완성, 코드 탐색, 코드를 더 깔끔하게 만드는 매력적인 부분이 TypeScript가 뒷담화로 작동하고 있다는 거죠.\n\n호기심이 생겼고 TypeScript를 한 번 시도해 보고 싶다면, TypeScript를 사용하는 방법은 다음과 같습니다:\n\nTypeScript를 시작해 보려면 NuGet을 사용하여 가져올 수 있고, npm 세계에 더 익숙하다면 다음 명령어를 입력해 보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm install -D typescript\n```\n\n# Import 속성\n\nTypeScript 5.3에서 새로 추가된 멋진 기능 중 하나는 import 속성입니다. 이것들은 런타임에 가져온 항목들을 다루는 방법에 대한 특정 세부사항을 알려주는 작은 태그 같은 역할을 합니다.\n\n예를 들어, JSON 파일을 가져올 때 이것이 JSON으로 처리되고 실행 가능한 JavaScript로 처리되지 않도록 하려면 다음과 같이 할 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport obj from \"./something.json\" with { type: \"json\" };\n```\n\n이러한 속성은 TypeScript 자체에서 확인되지 않습니다. 대신 브라우저나 런타임이 따를 주석과 같습니다. 따라서 자유롭게 사용할 수 있지만, 무의미한 유형을 사용하여 브라우저를 혼란스럽게 하지 않도록 주의하십시오:\n\n```js\nimport * as foo from \"./foo.js\" with { type: \"fluffy bunny\" };\n```\n\n동적 임포트인 import()로 만든 임포트도 이러한 임포트 속성을 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\nconst obj = await import(\"./something.json\", {\n    with: { type: \"json\" }\n});\n```\n\n재밌는 점은 TypeScript가 예전 기능인 \"import assertions\"에서 이 새로운 import 속성으로 이동하고 있다는 것입니다.\n\n이제 더 이상 assert 키워드를 사용하는 대신 with를 사용합니다. 이전 코드에 assert가 있는 경우, 새로운 문법인 with를 사용하도록 업데이트하는 것이 권장됩니다.\n\n# Import 타입에서 버그 수정된 해상도 모드 안정성 지원\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재는 Markdown 형식을 사용하고 있는 것 같네요. 예를 들어, 코드에서 타입 가져오기를 기존 require처럼 처리하거나 현대적인 import처럼 처리할지 결정할 때 사용하는 설정과 비슷한 거죠.\n\n코드에서 타입 가져오기를 예전 방식인 require()처럼 처리하고 싶다면 다음과 같이 할 수 있어요:\n\n```js\nimport type { TypeFromRequire } from \"pkg\" with {\n    \"resolution-mode\": \"require\"\n};\n```\n\n그리고 새로운 import 방식을 선호한다면, 이렇게 할 수도 있죠:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport type { TypeFromImport } from \"pkg\" with {\n    \"resolution-mode\": \"import\"\n};\n```\n\n하지만 여기에 멋진 부분이 있어요. 이 기능은 처음에 import 어써션에 사용할 수 없었는데요, 이는 모듈이 어떻게 처리되어야 하는지에 대한 힌트 같은 것입니다.\n\n지금은 TypeScript 5.3에서 이 \"resolution-mode\" 속성을 import 타입에도 확장했습니다. 따라서, 이제 일반적인 import뿐만 아니라 import()를 사용하여 동적으로 타입을 끌어올 때에도 사용할 수 있어요.\n\n여기에 더 실용적인 예시가 있습니다:```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport type TypeFromRequire =\n    import(\"pkg\", { with: { \"resolution-mode\": \"require\" } }).TypeFromRequire;\n\nexport type TypeFromImport =\n    import(\"pkg\", { with: { \"resolution-mode\": \"import\" } }).TypeFromImport;\n\nexport interface MergedType extends TypeFromRequire, TypeFromImport {}\n```\n\n# resolution-mode All Module Modes에서 지원됩니다.\n\n과거에는 node16 및 nodenext와 같은 특정 moduleResolution 옵션에서만 resolution-mode 마법을 사용할 수 있었습니다.\n\n하지만 생각해보세요! TypeScript 5.3가 삶을 더 간단하게 만들어줍니다. 이제 bundler, node10 및 심지어 classic와 같은 모든 다른 moduleResolution 옵션과 함께 resolution-mode를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더는 당신이 타입을 다루는 방식을 조정하고 싶어서 발생하는 오류가 더 이상 나타나지 않는다.\n\n TypeScript는 여러분이 원하는 모듈 모드에서 자유롭게 작업할 수 있도록 더 널널해졌어요. 멋지죠?\n\n# switch (true) 좁히기\n\n이제 true로 설정된 switch 문을 다룰 때, TypeScript가 각 case의 조건에 따라 타입을 똑똑하게 좁힐 수 있어요. 자세히 설명해 드릴게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이런 함수가 있다고 하자:\n\n```js\nfunction f(x: unknown) {\n    switch (true) {\n        case typeof x === \"string\":\n            // 'x'은 여기서 'string'입니다.\n            console.log(x.toUpperCase());\n            // 계속 진행...\n\n        case Array.isArray(x):\n            // 'x'는 여기서 'string | any[]' 입니다.\n            console.log(x.length);\n            // 계속 진행...\n\n        default:\n            // 'x'는 여기서 'unknown'입니다.\n            // ...\n    }\n}\n```\n\n여기서 하는 일은, 각 case의 조건에 따라 TypeScript가 'x'의 유형을 더 수월하게 파악하는 것입니다.\n\n예를 들어, 'x'가 문자열이면, 그것을 알고 있으며, toUpperCase()와 같은 문자열 관련 작업을 수행할 수 있습니다. 배열인 경우에도 이해합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 불리언에 대한 비교 좁히기\n\n당신이 직접적으로 true 또는 false와 비교를 할 때를 말해요. 스타일적 이유이거나 JavaScript의 특징을 처리하기 위해서 명시적으로 무언가가 true인지 false인지 확인할 때 그렇습니다.\n\n이전에 TypeScript는 이러한 비교를 인지하지 못했지만, 이제는 도와줄 준비가 되어 있어요. 한 예제로 보여드릴게요:\n\n```js\ninterface A {\n    a: string;\n}\n\ninterface B {\n    b: string;\n}\n\ntype MyType = A | B;\n\nfunction isA(x: MyType): x is A {\n    return \"a\" in x;\n}\n\nfunction someFn(x: MyType) {\n    if (isA(x) === true) {\n        console.log(x.a); // TypeScript가 이해했어요!\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래, isA(x) === true를 보셨나요? TypeScript가 그것을 이해하고 if 블록 내에서 타입을 더 좁게 인식할 수 있게 되었습니다.\n\n그래서 TypeScript가 불평하지 않고도 console.log(x.a)와 같은 작업을 자신 있게 수행할 수 있습니다.\n\n# Symbol.hasInstance를 통한 좁히기\n\ninstanceof를 사용할 때, [Symbol.hasInstance]로 정의된 메서드를 고려하여 더 똑똑해졌습니다. 이는 사용자 정의 타입 가드를 사용하여 타입을 더 정확하게 좁힐 수 있게 되었다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 통해 설명해 드리겠습니다:\n\nPoint라는 클래스가 있다고 상상해 보세요. 이제 TypeScript를 사용하여 [Symbol.hasInstance]를 사용하여 해당 클래스에 특별한 메서드를 정의할 수 있습니다. 이 메서드에서는 Point와 유사한지를 확인하기 위한 사용자 지정 로직을 구현할 수 있습니다.\n\n```js\nclass Point {\n    static [Symbol.hasInstance](val: unknown): val is PointLike {\n        // 여기에 사용자 정의 타입 가드 로직을 넣으세요\n    }\n}\n```\n\n그런 다음 코드에서 instanceof를 사용할 때 TypeScript는 사용자 정의 타입 가드를 인식하고 활용할 수 있습니다. 예를 들면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```ts\nfunction f(value: unknown) {\n    if (value instanceof Point) {\n        // Now, you can access properties defined in PointLike,\n        // but you won't have access to specific Point methods or properties.\n    }\n}\n```\n\n그래서 이 기능은 기본적으로 TypeScript가 사용자 정의 유형 확인을 정말 이해하고 유형을 더 정확하게 좁힐 수 있도록 합니다.\n\n# 인스턴스 필드에서 수퍼 속성 액세스를 위한 검사\n\n클래스를 다룰 때 기반 클래스에서 메서드에 접근하기 위해 super 키워드를 사용할 수 있습니다. 이것은 \"이 클래스에서 상속 받은 클래스로부터 메서드를 가져오게 해줘\"라는 방식입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어:\n\n```js\nclass Base {\n    someMethod() {\n        console.log(\"베이스 메서드 호출됨!\");\n    }\n}\n\nclass Derived extends Base {\n    someMethod() {\n        console.log(\"파생 메서드 호출됨!\");\n        super.someMethod();\n    }\n}\n\nnew Derived().someMethod();\n// 출력:\n//   파생 메서드 호출됨!\n//   베이스 메서드 호출됨!\n```\n\n따라서 super.someMethod()은 베이스 클래스에서 메서드를 특별히 얻는 방법임을 알 수 있습니다.\n\n이제 여기가 tricky한 부분입니다. 클래스 필드(전체의 속성)를 다룬다면, 동일한 방식으로 super를 사용하는 것이 예상대로 작동하지 않을 수 있습니다. TypeScript 5.3는 이를 잘 파악하여 경고를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 예시가 있어요:\n\n```js\nclass Base {\n    someMethod = () =\u003e {\n        console.log(\"someMethod called!\");\n    }\n}\n\nclass Derived extends Base {\n    someOtherMethod() {\n        super.someMethod(); // 이제 오류가 발생할 거예요!\n    }\n}\n\nnew Derived().someOtherMethod();\n// 💥\n// 'super.someMethod'이 'undefined'이기 때문에 작동하지 않아요.\n```\n\n그래서 TypeScript 5.3은 super를 사용하여 무언가에 접근할 때 그것이 클래스 필드인지 확인해요. 그게 맞다면, super를 통해 접근하려고 하면 TypeScript가 런타임 오류에 부딪히기 전에 멈춰줄 거예요. 코드에 잠입하는 교묘한 버그를 막기 위해 친구가 코드를 한 번 더 확인해주는 것 같죠!\n\n# 자동 Imports 유형을 선호하는 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자동으로 타입에 대한 import를 추가할 때, 이전에는 사용자 설정을 기반으로 했습니다. 예를 들어, Person이라는 타입이 있는 경우:\n\n```js\nexport let p: Person;\n```\n\nTypeScript는 보통 다음과 같이 import를 추가했을 것입니다:\n\n```js\nimport { Person } from \"./types\";\n\nexport let p: Person;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 설정에 따라 다를 수 있습니다. 예를 들어, verbatimModuleSyntax와 같은 특정 설정이 있는 경우에는 type 수정자를 추가할 수도 있습니다:\n\n```js\nimport { type Person } from \"./types\";\n\nexport let p: Person;\n```\n\n이제 TypeScript는 더 많은 제어권을 제공합니다. 특정한 선호도가 있거나 코드베이스에서 특정 옵션을 사용할 수 없는 경우, 가능한 경우에는 항상 명시적인 타입 가져오기를 설정할 수 있습니다. 이는 \"안녕 TypeScript, 이렇게 해 달라고 말했어, 깜짝 놀라지 말고\"라고 말하는 것과 같습니다. 그래서 TypeScript를 자신이 원하는 방식으로 작동하도록 만드는 것입니다.\n\n# TypeScript 5.3에서 몇 가지 최적화가 소개되었습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선, JSDoc 파싱을 스킵하고 있습니다. 이는 TypeScript가 JSDoc에 불필요한 시간과 메모리를 소비하지 않아 컴파일 속도를 높일 수 있음을 의미합니다.\n\n특히 변경 사항이 빈번한 감시 모드에서 이 점이 특히 두드러집니다. 게다가, 이 개선은 TypeScript 자체뿐만 아니라 typescript-eslint와 Prettier와 같은 도구들도 이 속도 및 메모리 향상으로 이점을 얻을 수 있습니다.\n\n또한, TypeScript가 교차(intersections)를 처리하는 방식에 최적화가 있습니다. 이는 TypeScript가 유니언과 교차에서 특히 타입을 비교하는 데 능숙해지고 있는 것과 같습니다.\n\n원본 교차형식을 살펴보면, 이제 더 빠르게 확인할 수 있어 타입 평가가 더 효율적으로 이루어집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 TypeScript는 tsserverlibrary.js 및 typescript.js 라이브러리 파일을 합치면서 봄철처럼 청소를 하고 있어요.\n\n중복을 줄이고 일관성을 높이기 위해 이들을 결합하고 있습니다.\n\n이렇게 하면 API 사용이 보다 간소화되며 자원 사용량이 감소하는데 도움이 됩니다. 모든 것이 제 자리에 있고 원활하게 작동되도록 집을 정리하는 것과 같아요.\n\n자세한 변경 사항에 대한 내용은 여기에서 확인할 수 있는 완전한 릴리스 로그를 참조해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 Medium 페이지와 연결해 보세요! ✍ : https://medium.com/@Evelyn.Taylor","ogImage":{"url":"/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png"},"coverImage":"/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0.png\" alt=\"2024-05-18-WhatsFreshinTypeScript53LetsDiveIn_0\"\u003e\u003c/p\u003e\n\u003cp\u003e자바스크립트로 작업 중인 상황을 상상해보세요. 이 언어는 유연하지만 때로는 까다로운 면이 있습니다.\u003c/p\u003e\n\u003cp\u003e타입스크립트는 코드를 실행하기 전에 실수를 잡아주는 일종의 보조 역할을 하는데요.\u003c/p\u003e\n\u003cp\u003e변수와 함수와 같은 요소들의 타입을 명시하는 방법을 추가함으로써 이를 수행합니다.\u003c/p\u003e\n\u003cp\u003e그러니까, 흔한 오류를 미리 방지하는 데 넘어서 TypeScript는 테이블에 몇 가지 멋진 기능을 가져다 줍니다. 이것을 한 마디로 말하면, 오타를 만들 것 같을 때나 특정 사항을 확인을 잊었을 때 지적해주는 스마트한 친구가 있다고 생각해보세요. 하나 더, 코드를 작성하는 동안 당신을 도와주기도 합니다.\u003c/p\u003e\n\u003cp\u003eVisual Studio 또는 VS Code를 사용해 본 적이 있다면, 자동 완성, 코드 탐색, 코드를 더 깔끔하게 만드는 매력적인 부분이 TypeScript가 뒷담화로 작동하고 있다는 거죠.\u003c/p\u003e\n\u003cp\u003e호기심이 생겼고 TypeScript를 한 번 시도해 보고 싶다면, TypeScript를 사용하는 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003eTypeScript를 시작해 보려면 NuGet을 사용하여 가져올 수 있고, npm 세계에 더 익숙하다면 다음 명령어를 입력해 보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install -D typescript\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eImport 속성\u003c/h1\u003e\n\u003cp\u003eTypeScript 5.3에서 새로 추가된 멋진 기능 중 하나는 import 속성입니다. 이것들은 런타임에 가져온 항목들을 다루는 방법에 대한 특정 세부사항을 알려주는 작은 태그 같은 역할을 합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, JSON 파일을 가져올 때 이것이 JSON으로 처리되고 실행 가능한 JavaScript로 처리되지 않도록 하려면 다음과 같이 할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e obj \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./something.json\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"json\"\u003c/span\u003e };\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 속성은 TypeScript 자체에서 확인되지 않습니다. 대신 브라우저나 런타임이 따를 주석과 같습니다. 따라서 자유롭게 사용할 수 있지만, 무의미한 유형을 사용하여 브라우저를 혼란스럽게 하지 않도록 주의하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e foo \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./foo.js\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"fluffy bunny\"\u003c/span\u003e };\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e동적 임포트인 import()로 만든 임포트도 이러한 임포트 속성을 사용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"./something.json\"\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003ewith\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"json\"\u003c/span\u003e }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e재밌는 점은 TypeScript가 예전 기능인 \"import assertions\"에서 이 새로운 import 속성으로 이동하고 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003e이제 더 이상 assert 키워드를 사용하는 대신 with를 사용합니다. 이전 코드에 assert가 있는 경우, 새로운 문법인 with를 사용하도록 업데이트하는 것이 권장됩니다.\u003c/p\u003e\n\u003ch1\u003eImport 타입에서 버그 수정된 해상도 모드 안정성 지원\u003c/h1\u003e\n\u003cp\u003e현재는 Markdown 형식을 사용하고 있는 것 같네요. 예를 들어, 코드에서 타입 가져오기를 기존 require처럼 처리하거나 현대적인 import처럼 처리할지 결정할 때 사용하는 설정과 비슷한 거죠.\u003c/p\u003e\n\u003cp\u003e코드에서 타입 가져오기를 예전 방식인 require()처럼 처리하고 싶다면 다음과 같이 할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e type { \u003cspan class=\"hljs-title class_\"\u003eTypeFromRequire\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"pkg\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e {\n    \u003cspan class=\"hljs-string\"\u003e\"resolution-mode\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"require\"\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 새로운 import 방식을 선호한다면, 이렇게 할 수도 있죠:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e type { \u003cspan class=\"hljs-title class_\"\u003eTypeFromImport\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"pkg\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e {\n    \u003cspan class=\"hljs-string\"\u003e\"resolution-mode\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"import\"\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 여기에 멋진 부분이 있어요. 이 기능은 처음에 import 어써션에 사용할 수 없었는데요, 이는 모듈이 어떻게 처리되어야 하는지에 대한 힌트 같은 것입니다.\u003c/p\u003e\n\u003cp\u003e지금은 TypeScript 5.3에서 이 \"resolution-mode\" 속성을 import 타입에도 확장했습니다. 따라서, 이제 일반적인 import뿐만 아니라 import()를 사용하여 동적으로 타입을 끌어올 때에도 사용할 수 있어요.\u003c/p\u003e\n\u003cp\u003e여기에 더 실용적인 예시가 있습니다:```\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e type \u003cspan class=\"hljs-title class_\"\u003eTypeFromRequire\u003c/span\u003e =\n    \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"pkg\"\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003ewith\u003c/span\u003e: { \u003cspan class=\"hljs-string\"\u003e\"resolution-mode\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"require\"\u003c/span\u003e } }).\u003cspan class=\"hljs-property\"\u003eTypeFromRequire\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e type \u003cspan class=\"hljs-title class_\"\u003eTypeFromImport\u003c/span\u003e =\n    \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"pkg\"\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003ewith\u003c/span\u003e: { \u003cspan class=\"hljs-string\"\u003e\"resolution-mode\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"import\"\u003c/span\u003e } }).\u003cspan class=\"hljs-property\"\u003eTypeFromImport\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e interface \u003cspan class=\"hljs-title class_\"\u003eMergedType\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTypeFromRequire\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eTypeFromImport\u003c/span\u003e {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eresolution-mode All Module Modes에서 지원됩니다.\u003c/h1\u003e\n\u003cp\u003e과거에는 node16 및 nodenext와 같은 특정 moduleResolution 옵션에서만 resolution-mode 마법을 사용할 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e하지만 생각해보세요! TypeScript 5.3가 삶을 더 간단하게 만들어줍니다. 이제 bundler, node10 및 심지어 classic와 같은 모든 다른 moduleResolution 옵션과 함께 resolution-mode를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e더는 당신이 타입을 다루는 방식을 조정하고 싶어서 발생하는 오류가 더 이상 나타나지 않는다.\u003c/p\u003e\n\u003cp\u003eTypeScript는 여러분이 원하는 모듈 모드에서 자유롭게 작업할 수 있도록 더 널널해졌어요. 멋지죠?\u003c/p\u003e\n\u003ch1\u003eswitch (true) 좁히기\u003c/h1\u003e\n\u003cp\u003e이제 true로 설정된 switch 문을 다룰 때, TypeScript가 각 case의 조건에 따라 타입을 똑똑하게 좁힐 수 있어요. 자세히 설명해 드릴게요.\u003c/p\u003e\n\u003cp\u003e자, 이런 함수가 있다고 하자:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ef\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex: unknown\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e x === \u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e:\n            \u003cspan class=\"hljs-comment\"\u003e// 'x'은 여기서 'string'입니다.\u003c/span\u003e\n            \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x.\u003cspan class=\"hljs-title function_\"\u003etoUpperCase\u003c/span\u003e());\n            \u003cspan class=\"hljs-comment\"\u003e// 계속 진행...\u003c/span\u003e\n\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisArray\u003c/span\u003e(x):\n            \u003cspan class=\"hljs-comment\"\u003e// 'x'는 여기서 'string | any[]' 입니다.\u003c/span\u003e\n            \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e);\n            \u003cspan class=\"hljs-comment\"\u003e// 계속 진행...\u003c/span\u003e\n\n        \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e:\n            \u003cspan class=\"hljs-comment\"\u003e// 'x'는 여기서 'unknown'입니다.\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 하는 일은, 각 case의 조건에 따라 TypeScript가 'x'의 유형을 더 수월하게 파악하는 것입니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 'x'가 문자열이면, 그것을 알고 있으며, toUpperCase()와 같은 문자열 관련 작업을 수행할 수 있습니다. 배열인 경우에도 이해합니다.\u003c/p\u003e\n\u003ch1\u003e불리언에 대한 비교 좁히기\u003c/h1\u003e\n\u003cp\u003e당신이 직접적으로 true 또는 false와 비교를 할 때를 말해요. 스타일적 이유이거나 JavaScript의 특징을 처리하기 위해서 명시적으로 무언가가 true인지 false인지 확인할 때 그렇습니다.\u003c/p\u003e\n\u003cp\u003e이전에 TypeScript는 이러한 비교를 인지하지 못했지만, 이제는 도와줄 준비가 되어 있어요. 한 예제로 보여드릴게요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einterface A {\n    \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: string;\n}\n\ninterface B {\n    \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: string;\n}\n\ntype \u003cspan class=\"hljs-title class_\"\u003eMyType\u003c/span\u003e = A | B;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisA\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex: MyType\u003c/span\u003e): x is A {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e x;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esomeFn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex: MyType\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-title function_\"\u003eisA\u003c/span\u003e(x) === \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// TypeScript가 이해했어요!\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그래, isA(x) === true를 보셨나요? TypeScript가 그것을 이해하고 if 블록 내에서 타입을 더 좁게 인식할 수 있게 되었습니다.\u003c/p\u003e\n\u003cp\u003e그래서 TypeScript가 불평하지 않고도 console.log(x.a)와 같은 작업을 자신 있게 수행할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eSymbol.hasInstance를 통한 좁히기\u003c/h1\u003e\n\u003cp\u003einstanceof를 사용할 때, [Symbol.hasInstance]로 정의된 메서드를 고려하여 더 똑똑해졌습니다. 이는 사용자 정의 타입 가드를 사용하여 타입을 더 정확하게 좁힐 수 있게 되었다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e예를 통해 설명해 드리겠습니다:\u003c/p\u003e\n\u003cp\u003ePoint라는 클래스가 있다고 상상해 보세요. 이제 TypeScript를 사용하여 [Symbol.hasInstance]를 사용하여 해당 클래스에 특별한 메서드를 정의할 수 있습니다. 이 메서드에서는 Point와 유사한지를 확인하기 위한 사용자 지정 로직을 구현할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePoint\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e [\u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ehasInstance\u003c/span\u003e](\u003cspan class=\"hljs-attr\"\u003eval\u003c/span\u003e: unknown): val is \u003cspan class=\"hljs-title class_\"\u003ePointLike\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 여기에 사용자 정의 타입 가드 로직을 넣으세요\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 코드에서 instanceof를 사용할 때 TypeScript는 사용자 정의 타입 가드를 인식하고 활용할 수 있습니다. 예를 들면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-ts\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ef\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue: \u003cspan class=\"hljs-built_in\"\u003eunknown\u003c/span\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (value \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePoint\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// Now, you can access properties defined in PointLike,\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// but you won't have access to specific Point methods or properties.\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그래서 이 기능은 기본적으로 TypeScript가 사용자 정의 유형 확인을 정말 이해하고 유형을 더 정확하게 좁힐 수 있도록 합니다.\u003c/p\u003e\n\u003ch1\u003e인스턴스 필드에서 수퍼 속성 액세스를 위한 검사\u003c/h1\u003e\n\u003cp\u003e클래스를 다룰 때 기반 클래스에서 메서드에 접근하기 위해 super 키워드를 사용할 수 있습니다. 이것은 \"이 클래스에서 상속 받은 클래스로부터 메서드를 가져오게 해줘\"라는 방식입니다.\u003c/p\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esomeMethod\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"베이스 메서드 호출됨!\"\u003c/span\u003e);\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDerived\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eBase\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esomeMethod\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"파생 메서드 호출됨!\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esomeMethod\u003c/span\u003e();\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDerived\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003esomeMethod\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 출력:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//   파생 메서드 호출됨!\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//   베이스 메서드 호출됨!\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e따라서 super.someMethod()은 베이스 클래스에서 메서드를 특별히 얻는 방법임을 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 여기가 tricky한 부분입니다. 클래스 필드(전체의 속성)를 다룬다면, 동일한 방식으로 super를 사용하는 것이 예상대로 작동하지 않을 수 있습니다. TypeScript 5.3는 이를 잘 파악하여 경고를 제공합니다.\u003c/p\u003e\n\u003cp\u003e여기 예시가 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e {\n    someMethod = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"someMethod called!\"\u003c/span\u003e);\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDerived\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eBase\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esomeOtherMethod\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esomeMethod\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 이제 오류가 발생할 거예요!\u003c/span\u003e\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDerived\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003esomeOtherMethod\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 💥\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 'super.someMethod'이 'undefined'이기 때문에 작동하지 않아요.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그래서 TypeScript 5.3은 super를 사용하여 무언가에 접근할 때 그것이 클래스 필드인지 확인해요. 그게 맞다면, super를 통해 접근하려고 하면 TypeScript가 런타임 오류에 부딪히기 전에 멈춰줄 거예요. 코드에 잠입하는 교묘한 버그를 막기 위해 친구가 코드를 한 번 더 확인해주는 것 같죠!\u003c/p\u003e\n\u003ch1\u003e자동 Imports 유형을 선호하는 설정\u003c/h1\u003e\n\u003cp\u003e자동으로 타입에 대한 import를 추가할 때, 이전에는 사용자 설정을 기반으로 했습니다. 예를 들어, Person이라는 타입이 있는 경우:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ep\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePerson\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTypeScript는 보통 다음과 같이 import를 추가했을 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003ePerson\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./types\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ep\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePerson\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 설정에 따라 다를 수 있습니다. 예를 들어, verbatimModuleSyntax와 같은 특정 설정이 있는 경우에는 type 수정자를 추가할 수도 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { type \u003cspan class=\"hljs-title class_\"\u003ePerson\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./types\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ep\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePerson\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 TypeScript는 더 많은 제어권을 제공합니다. 특정한 선호도가 있거나 코드베이스에서 특정 옵션을 사용할 수 없는 경우, 가능한 경우에는 항상 명시적인 타입 가져오기를 설정할 수 있습니다. 이는 \"안녕 TypeScript, 이렇게 해 달라고 말했어, 깜짝 놀라지 말고\"라고 말하는 것과 같습니다. 그래서 TypeScript를 자신이 원하는 방식으로 작동하도록 만드는 것입니다.\u003c/p\u003e\n\u003ch1\u003eTypeScript 5.3에서 몇 가지 최적화가 소개되었습니다:\u003c/h1\u003e\n\u003cp\u003e우선, JSDoc 파싱을 스킵하고 있습니다. 이는 TypeScript가 JSDoc에 불필요한 시간과 메모리를 소비하지 않아 컴파일 속도를 높일 수 있음을 의미합니다.\u003c/p\u003e\n\u003cp\u003e특히 변경 사항이 빈번한 감시 모드에서 이 점이 특히 두드러집니다. 게다가, 이 개선은 TypeScript 자체뿐만 아니라 typescript-eslint와 Prettier와 같은 도구들도 이 속도 및 메모리 향상으로 이점을 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또한, TypeScript가 교차(intersections)를 처리하는 방식에 최적화가 있습니다. 이는 TypeScript가 유니언과 교차에서 특히 타입을 비교하는 데 능숙해지고 있는 것과 같습니다.\u003c/p\u003e\n\u003cp\u003e원본 교차형식을 살펴보면, 이제 더 빠르게 확인할 수 있어 타입 평가가 더 효율적으로 이루어집니다.\u003c/p\u003e\n\u003cp\u003e마지막으로 TypeScript는 tsserverlibrary.js 및 typescript.js 라이브러리 파일을 합치면서 봄철처럼 청소를 하고 있어요.\u003c/p\u003e\n\u003cp\u003e중복을 줄이고 일관성을 높이기 위해 이들을 결합하고 있습니다.\u003c/p\u003e\n\u003cp\u003e이렇게 하면 API 사용이 보다 간소화되며 자원 사용량이 감소하는데 도움이 됩니다. 모든 것이 제 자리에 있고 원활하게 작동되도록 집을 정리하는 것과 같아요.\u003c/p\u003e\n\u003cp\u003e자세한 변경 사항에 대한 내용은 여기에서 확인할 수 있는 완전한 릴리스 로그를 참조해 주세요.\u003c/p\u003e\n\u003cp\u003e제 Medium 페이지와 연결해 보세요! ✍ : \u003ca href=\"https://medium.com/@Evelyn.Taylor\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://medium.com/@Evelyn.Taylor\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-WhatsFreshinTypeScript53LetsDiveIn"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>