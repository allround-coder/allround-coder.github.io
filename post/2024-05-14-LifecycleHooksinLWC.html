<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>라이프사이클 후크Lifecycle Hooks에 대한 LWC | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-LifecycleHooksinLWC" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="라이프사이클 후크Lifecycle Hooks에 대한 LWC | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="라이프사이클 후크Lifecycle Hooks에 대한 LWC | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-LifecycleHooksinLWC_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-LifecycleHooksinLWC" data-gatsby-head="true"/><meta name="twitter:title" content="라이프사이클 후크Lifecycle Hooks에 대한 LWC | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-LifecycleHooksinLWC_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 12:48" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">라이프사이클 후크Lifecycle Hooks에 대한 LWC</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="라이프사이클 후크Lifecycle Hooks에 대한 LWC" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-LifecycleHooksinLWC&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-14-LifecycleHooksinLWC_0.png" alt="Lifecycle Hooks in LWC"></p>
<p>라이프사이클 훅은 라이트닝 웹 컴포넌트(LWC)를 개발하는 여정에서 굉장히 중요한 부분입니다. 이들은 컴포넌트의 라이프사이클의 다양한 단계를 제어하고 응답하는 능력을 제공하여 Salesforce 생태계에서 웹 컴포넌트를 구축하는데 더 효율적이고 세밀한 접근법을 가능하게 합니다.</p>
<p>이 블로그에서는 LWC 라이프사이클 훅의 세계에 대해 자세히 살펴보겠습니다. 이 훅이 무엇이고 왜 중요한지, 그리고 동적이고 반응성 있는 컴포넌트를 만들기 위해 효과적으로 활용하는 방법에 대해 탐구할 것입니다. LWC 여정을 시작한 지 얼마 안 된 분들이거나 기술을 향상하려는 분들, 이러한 훅을 이해하는 것이 강력하고 효율적인 라이트닝 웹 컴포넌트를 만드는 데 중요합니다.</p>
<p>이 블로그를 통해 LWC에서 사용 가능한 다양한 라이프사이클 훅을 자세히 살펴보고, 이들의 구체적인 사용 사례를 논의하며, 실용적인 예제를 제공하여 실제 응용 가능한 내용을 파악하는 데 도움을 드리겠습니다. 이 여정의 끝에는 컴포넌트 라이프사이클 관리의 기술을 숙달하여 LWC의 전체 잠재력을 활용할 수 있는 지식을 갖추게 될 것입니다.</p>
<p>Lifecycle Hooks in LWC: Managing the Journey of a Lightning Web Component</p>
<p>라이트닝 웹 컴포넌트(LWC)의 라이프사이클 훅</p>
<p>라이트닝 웹 컴포넌트(LWC)는 Salesforce 플랫폼 내에서 동적이고 인터랙티브한 사용자 인터페이스의 구성 요소입니다. 그들의 잠재력을 완벽하게 활용하려면, 개발자들은 이러한 구성 요소들이 라이프사이클 동안 거치는 복잡한 단계를 이해해야 합니다. 이것이 바로 "라이프사이클 훅(Lifecycle Hooks)"의 세계입니다.</p>
<h1>라이프사이클 훅이란?</h1>
<p>LWC의 라이프사이클 훅은 개발자들이 컴포넌트의 여정의 다른 단계에서 개입할 수 있는 미리 정의된 메소드들입니다. 이러한 훅들은 컴포넌트의 라이프사이클에서 발생하는 특정 이벤트와 전환에 대응하고 제어하고 최적화할 수 있는 능력을 제공합니다. 이러한 훅들을 이해하고 효과적으로 사용하는 것이 견고하고 반응적인 컴포넌트를 만드는 핵심입니다.</p>
<p>여기 몇 가지 중요한 라이프사이클 후크에 대한 간단한 개요입니다:</p>
<ul>
<li>constructor(): 컴포넌트가 초기화되는 곳입니다. 기본값을 설정하고 일회성 설정을 수행할 수 있습니다.</li>
<li>connectedCallback(): 컴포넌트가 DOM에 추가된 후에 실행되는 후크입니다. DOM 조작 및 데이터 검색에 좋은 장소입니다.</li>
<li>renderedCallback(): 렌더링 후에 트리거되는 후크입니다. 렌더링된 DOM에 대한 지식이 필요한 작업에 이상적입니다.</li>
<li>disconnectedCallback(): 컴포넌트가 DOM에서 제거될 때 호출되는 후크입니다. 정리 작업 및 리소스 해제에 사용하세요.</li>
<li>errorCallback(): 렌더링 중에 오류가 발생하면 호출되는 후크입니다. 오류를 우아하게 처리할 기회입니다.</li>
</ul>
<h1>라이프사이클 후크 흐름</h1>
<p>먼저 부모 constructor가 호출되고, 부모 connectedCallBack가 실행된 후, 자식 컴포넌트가 있으면 자식 constructor → connectedCallback → renderedCallback 순으로 진행되고 다시 부모 renderedCallback로 이동합니다.</p>
<p><img src="/assets/img/2024-05-14-LifecycleHooksinLWC_1.png" alt="이미지"></p>
<ol>
<li>생성:</li>
</ol>
<ul>
<li><code>constructor()</code>: 컴포넌트 인스턴스가 생성될 때 실행되는 첫 번째 후크입니다. 변수를 초기화하고 기본 값 설정하는 곳입니다.</li>
</ul>
<p>주의하세요!</p>
<p>생성자()</p>
<ul>
<li>컴포넌트의 인스턴스가 생성될 때 호출됩니다(init()와 비슷합니다).</li>
<li>부모 컴포넌트에서 먼저 발생하며 부모에서 자식으로 흘러갑니다.</li>
<li>부모 클래스 생성자인 LightningElement를 호출하려면 먼저 super()를 호출해야 합니다.</li>
<li>컴포넌트 템플릿에서 요소에 액세스하려면 this.template을 사용하세요.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">LightningElement</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'lwc'</span>;
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LifeCycleHookParent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LightningElement</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>(); <span class="hljs-comment">// LightningElement 클래스 생성자를 호출합니다. console.log('Parent Constructor Called');</span>
    <span class="hljs-keyword">let</span> con = <span class="hljs-variable language_">this</span>.<span class="hljs-property">template</span> <span class="hljs-comment">// 호스트 요소에 액세스합니다.</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(con);
  }
}
</code></pre>
<ol start="2">
<li>초기화:</li>
</ol>
<ul>
<li><code>connectedCallback()</code>: 컴포넌트가 초기화된 후에 이 훅이 호출됩니다. DOM 조작 및 데이터 검색에 이상적인 위치입니다.</li>
</ul>
<p>주의!</p>
<p>connectedCallback()</p>
<ul>
<li>컴포넌트가 DOM에 삽입될 때 호출됩니다.</li>
<li>부모에서 자식으로 흐릅니다.</li>
<li>데이터를 가져오고 캐시를 설정하며 이벤트를 수신하는 초기화 작업을 수행하는 데 사용됩니다.</li>
<li>컴포넌트가 DOM에 연결되어 있는지 확인하려면 isConnected 메서드를 사용하세요.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title function_">connectedCallback</span>(<span class="hljs-params"></span>){
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Parent Connected Call Back called'</span>);
  <span class="hljs-keyword">let</span> cb = <span class="hljs-variable language_">this</span>.<span class="hljs-property">template</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'is connected=> '</span> + cb.<span class="hljs-property">isConnected</span>);
}
</code></pre>
<ol start="3">
<li>렌더링:</li>
</ol>
<ul>
<li><code>renderedCallback()</code>: 이 훅은 컴포넌트의 초기 렌더링 후에 트리거됩니다. 요소와 상호 작용하는 것과 같은 렌더링된 DOM에 대한 지식이 필요한 작업에 적합합니다.</li>
</ul>
<p>주의하세요!</p>
<p>renderedCallback()</p>
<ul>
<li>컴포넌트가 렌더링 프레임워크를 완료한 후에 로직을 수행할 때 사용합니다. 이는 컴포넌트가 UI에 완전히 렌더링된 후에 호출됩니다.</li>
<li>자식 컴포넌트에서 부모 컴포넌트로 흐름이 됩니다.</li>
<li>컴포넌트는 여러 번 렌더링되어 렌더링 콜백을 추적하려면 isRendered 불리언 필드를 사용하세요.</li>
<li>렌더링된 콜백 내에서 무한 루프로 이어지는 속성을 조심하세요.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">LightningElement</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'lwc'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LifeCycleHookParent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LightningElement</span> {
  isRendered = <span class="hljs-literal">true</span> <span class="hljs-comment">// 컴포넌트가 렌더링되었는지 확인하기 위한 변수</span>
  <span class="hljs-title function_">renderedCallback</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRendered</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'부모 컴포넌트의 렌더링 콜백이 호출되었습니다'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isRendered</span> = <span class="hljs-literal">false</span>
    }
  ?
 }
</code></pre>
<ol start="4">
<li>Reactivity:</li>
</ol>
<ul>
<li>컴포넌트 내의 속성 또는 변수가 변경될 때마다 반응성 주기가 트리거될 수 있습니다. 이 주기 중에는 컴포넌트가 속성 변화를 확인하며, 변화가 감지되면 다시 렌더링되고 <code>renderedCallback</code>을 다시 호출합니다.</li>
</ul>
<ol start="5">
<li>소멸:</li>
</ol>
<ul>
<li><code>disconnectedCallback()</code>: 컴포넌트가 DOM에서 제거될 때 이 후크가 호출됩니다. 정리 작업이나 이벤트 리스너와 같은 리소스 해제에 뛰어난 장소입니다.</li>
</ul>
<p>주의하세요!</p>
<p>disconnectedCallback()</p>
<ul>
<li>문서에서 요소가 제거될 때 호출됩니다 (이벤트 리스너 제거, 시간 간격 제거 등).</li>
<li>Parent에서 Child로 이어집니다.</li>
<li>connectedCallback()에서 수행한 작업 정리에 disconnectedCallback()을 사용하십시오. 예를 들어, 이벤트 리스너 제거 등.</li>
<li>메시지 채널 구독 취소 등에도 이 후크를 사용할 수 있습니다.</li>
</ul>
<ol start="6">
<li>오류 처리:</li>
</ol>
<ul>
<li><code>errorCallback()</code>: 렌더링 중 오류가 발생하면 이 후크가 호출됩니다. 오류를 우아하게 처리하고 적절한 메시지를 표시할 수 있는 기회를 제공합니다.</li>
</ul>
<p>알아두세요!</p>
<p>errorCallback()</p>
<p>이것을 구현하여 하위 컴포넌트의 모든 오류를 캡처하는 오류 경계 컴포넌트를 만드세요.</p>
<p>하위 컴포넌트의 라이프사이클 훅 또는 HTML 템플릿에서 선언된 이벤트 핸들러 중 발생한 오류를 캡처합니다.</p>
<ul>
<li>자식(하위) 컴포넌트에서 오류가 발생했을 때 호출됩니다.</li>
<li>errorCallback(error, stack) 함수에 두 가지 아규먼트가 전달됩니다. error 아규먼트는 JavaScript 네이티브 오류 객체이며, stack 아규먼트는 문자열입니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">//Child Component</span>
<span class="hljs-title function_">connectedCallback</span>(<span class="hljs-params"></span>){
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Child Connected Call Back called'</span>);
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'problem in child component connectedCallback'</span>)
  }
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">//Parent component</span>
<span class="hljs-title function_">errorCallback</span>(<span class="hljs-params">error, stack</span>){
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error 메시지);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Stack: - '</span> + stack);
}
</code></pre>
<p>이 플로우를 이해하고 각 후크의 사용법을 파악하는 것은 Salesforce 생태계에서 반응형, 효율적이고 인터랙티브 웹 컴포넌트를 효과적으로 관리하고 최적화하는 데 중요합니다.</p>
<h1>라이프사이클 훅이 왜 중요한가요?</h1>
<p>라이프사이클 훅은 여러 이점을 제공합니다:</p>
<ul>
<li>최적화: 적절한 시간에 개입하여 컴포넌트 렌더링을 최적화함으로써 성능과 응답성을 향상시킬 수 있습니다.</li>
<li>상호작용: 적절한 라이프사이클 단계에서 사용자 작업에 응답함으로써 상호작용형 컴포넌트를 만들 수 있습니다.</li>
<li>자원 관리: 라이프사이클 훅을 사용하여 효율적인 자원 관리가 가능해지며, 컴포넌트가 더 이상 필요하지 않을 때 이벤트 리스너를 해제하고 타이머를 정리할 수 있습니다.</li>
</ul>
<p>예시: 실용적인 사용 사례</p>
<p>간단한 예제로 라이프사이클 훅의 중요성을 설명해보겠습니다. 카운트다운 타이머 컴포넌트를 구축 중이라고 상상해보세요. 라이프사이클 훅을 사용하는 방법은 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountdownTimer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LightningElement</span> {
    seconds = <span class="hljs-number">10</span>;

    <span class="hljs-title function_">connectedCallback</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">seconds</span> > <span class="hljs-number">0</span>) {
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">seconds</span>--;
            }
        }, <span class="hljs-number">1000</span>);
    }

    <span class="hljs-title function_">renderedCallback</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">seconds</span> === <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>);
        }
    }

    <span class="hljs-title function_">disconnectedCallback</span>(<span class="hljs-params"></span>) {
        <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>);
    }
}
</code></pre>
<p>이 예시에서 <code>connectedCallback</code>은 타이머를 설정하고, <code>renderedCallback</code>은 타이머가 0에 도달했을 때 UI를 업데이트하며, <code>disconnectedCallback</code>은 컴포넌트가 제거될 때 타이머가 중지되도록 보장합니다.</p>
<p>자세한 내용은 아래 링크를 참조해주세요:</p>
<p>읽어 주셔서 감사합니다 ☺️</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"라이프사이클 후크Lifecycle Hooks에 대한 LWC","description":"","date":"2024-05-14 12:48","slug":"2024-05-14-LifecycleHooksinLWC","content":"\n\n\n![Lifecycle Hooks in LWC](/assets/img/2024-05-14-LifecycleHooksinLWC_0.png)\n\n라이프사이클 훅은 라이트닝 웹 컴포넌트(LWC)를 개발하는 여정에서 굉장히 중요한 부분입니다. 이들은 컴포넌트의 라이프사이클의 다양한 단계를 제어하고 응답하는 능력을 제공하여 Salesforce 생태계에서 웹 컴포넌트를 구축하는데 더 효율적이고 세밀한 접근법을 가능하게 합니다.\n\n이 블로그에서는 LWC 라이프사이클 훅의 세계에 대해 자세히 살펴보겠습니다. 이 훅이 무엇이고 왜 중요한지, 그리고 동적이고 반응성 있는 컴포넌트를 만들기 위해 효과적으로 활용하는 방법에 대해 탐구할 것입니다. LWC 여정을 시작한 지 얼마 안 된 분들이거나 기술을 향상하려는 분들, 이러한 훅을 이해하는 것이 강력하고 효율적인 라이트닝 웹 컴포넌트를 만드는 데 중요합니다.\n\n이 블로그를 통해 LWC에서 사용 가능한 다양한 라이프사이클 훅을 자세히 살펴보고, 이들의 구체적인 사용 사례를 논의하며, 실용적인 예제를 제공하여 실제 응용 가능한 내용을 파악하는 데 도움을 드리겠습니다. 이 여정의 끝에는 컴포넌트 라이프사이클 관리의 기술을 숙달하여 LWC의 전체 잠재력을 활용할 수 있는 지식을 갖추게 될 것입니다.\n\n\n\nLifecycle Hooks in LWC: Managing the Journey of a Lightning Web Component\n\n라이트닝 웹 컴포넌트(LWC)의 라이프사이클 훅\n\n라이트닝 웹 컴포넌트(LWC)는 Salesforce 플랫폼 내에서 동적이고 인터랙티브한 사용자 인터페이스의 구성 요소입니다. 그들의 잠재력을 완벽하게 활용하려면, 개발자들은 이러한 구성 요소들이 라이프사이클 동안 거치는 복잡한 단계를 이해해야 합니다. 이것이 바로 \"라이프사이클 훅(Lifecycle Hooks)\"의 세계입니다.\n\n# 라이프사이클 훅이란?\n\nLWC의 라이프사이클 훅은 개발자들이 컴포넌트의 여정의 다른 단계에서 개입할 수 있는 미리 정의된 메소드들입니다. 이러한 훅들은 컴포넌트의 라이프사이클에서 발생하는 특정 이벤트와 전환에 대응하고 제어하고 최적화할 수 있는 능력을 제공합니다. 이러한 훅들을 이해하고 효과적으로 사용하는 것이 견고하고 반응적인 컴포넌트를 만드는 핵심입니다.\n\n\n\n여기 몇 가지 중요한 라이프사이클 후크에 대한 간단한 개요입니다:\n\n- constructor(): 컴포넌트가 초기화되는 곳입니다. 기본값을 설정하고 일회성 설정을 수행할 수 있습니다.\n- connectedCallback(): 컴포넌트가 DOM에 추가된 후에 실행되는 후크입니다. DOM 조작 및 데이터 검색에 좋은 장소입니다.\n- renderedCallback(): 렌더링 후에 트리거되는 후크입니다. 렌더링된 DOM에 대한 지식이 필요한 작업에 이상적입니다.\n- disconnectedCallback(): 컴포넌트가 DOM에서 제거될 때 호출되는 후크입니다. 정리 작업 및 리소스 해제에 사용하세요.\n- errorCallback(): 렌더링 중에 오류가 발생하면 호출되는 후크입니다. 오류를 우아하게 처리할 기회입니다.\n\n# 라이프사이클 후크 흐름\n\n먼저 부모 constructor가 호출되고, 부모 connectedCallBack가 실행된 후, 자식 컴포넌트가 있으면 자식 constructor → connectedCallback → renderedCallback 순으로 진행되고 다시 부모 renderedCallback로 이동합니다.\n\n\n\n![이미지](/assets/img/2024-05-14-LifecycleHooksinLWC_1.png)\n\n1. 생성:\n\n- `constructor()`: 컴포넌트 인스턴스가 생성될 때 실행되는 첫 번째 후크입니다. 변수를 초기화하고 기본 값 설정하는 곳입니다.\n\n주의하세요!\n\n\n\n생성자()\n\n- 컴포넌트의 인스턴스가 생성될 때 호출됩니다(init()와 비슷합니다).\n- 부모 컴포넌트에서 먼저 발생하며 부모에서 자식으로 흘러갑니다.\n- 부모 클래스 생성자인 LightningElement를 호출하려면 먼저 super()를 호출해야 합니다.\n- 컴포넌트 템플릿에서 요소에 액세스하려면 this.template을 사용하세요.\n\n```js\nimport { LightningElement } from 'lwc';\n \nexport default class LifeCycleHookParent extends LightningElement {\n  constructor() {\n    super(); // LightningElement 클래스 생성자를 호출합니다. console.log('Parent Constructor Called');\n    let con = this.template // 호스트 요소에 액세스합니다.\n    console.log(con);\n  }\n}\n```\n\n2. 초기화:\n\n\n\n- `connectedCallback()`: 컴포넌트가 초기화된 후에 이 훅이 호출됩니다. DOM 조작 및 데이터 검색에 이상적인 위치입니다.\n\n주의!\n\nconnectedCallback()\n\n- 컴포넌트가 DOM에 삽입될 때 호출됩니다.\n- 부모에서 자식으로 흐릅니다.\n- 데이터를 가져오고 캐시를 설정하며 이벤트를 수신하는 초기화 작업을 수행하는 데 사용됩니다.\n- 컴포넌트가 DOM에 연결되어 있는지 확인하려면 isConnected 메서드를 사용하세요.\n\n\n\n```js\nconnectedCallback(){\n  console.log('Parent Connected Call Back called');\n  let cb = this.template\n  console.log('is connected=\u003e ' + cb.isConnected);\n}\n```\n\n3. 렌더링:\n\n- `renderedCallback()`: 이 훅은 컴포넌트의 초기 렌더링 후에 트리거됩니다. 요소와 상호 작용하는 것과 같은 렌더링된 DOM에 대한 지식이 필요한 작업에 적합합니다.\n\n주의하세요!\n\n\n\n\nrenderedCallback()\n\n- 컴포넌트가 렌더링 프레임워크를 완료한 후에 로직을 수행할 때 사용합니다. 이는 컴포넌트가 UI에 완전히 렌더링된 후에 호출됩니다.\n- 자식 컴포넌트에서 부모 컴포넌트로 흐름이 됩니다.\n- 컴포넌트는 여러 번 렌더링되어 렌더링 콜백을 추적하려면 isRendered 불리언 필드를 사용하세요.\n- 렌더링된 콜백 내에서 무한 루프로 이어지는 속성을 조심하세요.\n\n```js\nimport { LightningElement } from 'lwc';\nexport default class LifeCycleHookParent extends LightningElement {\n  isRendered = true // 컴포넌트가 렌더링되었는지 확인하기 위한 변수\n  renderedCallback() {\n    if (this.isRendered) {\n      console.log('부모 컴포넌트의 렌더링 콜백이 호출되었습니다');\n      this.isRendered = false\n    }\n  ?\n }\n```\n\n4. Reactivity:\n\n\n\n- 컴포넌트 내의 속성 또는 변수가 변경될 때마다 반응성 주기가 트리거될 수 있습니다. 이 주기 중에는 컴포넌트가 속성 변화를 확인하며, 변화가 감지되면 다시 렌더링되고 `renderedCallback`을 다시 호출합니다.\n\n5. 소멸:\n\n- `disconnectedCallback()`: 컴포넌트가 DOM에서 제거될 때 이 후크가 호출됩니다. 정리 작업이나 이벤트 리스너와 같은 리소스 해제에 뛰어난 장소입니다.\n\n주의하세요!\n\n\n\n\ndisconnectedCallback()\n\n- 문서에서 요소가 제거될 때 호출됩니다 (이벤트 리스너 제거, 시간 간격 제거 등).\n- Parent에서 Child로 이어집니다.\n- connectedCallback()에서 수행한 작업 정리에 disconnectedCallback()을 사용하십시오. 예를 들어, 이벤트 리스너 제거 등.\n- 메시지 채널 구독 취소 등에도 이 후크를 사용할 수 있습니다.\n\n6. 오류 처리:\n\n- `errorCallback()`: 렌더링 중 오류가 발생하면 이 후크가 호출됩니다. 오류를 우아하게 처리하고 적절한 메시지를 표시할 수 있는 기회를 제공합니다.\n\n\n\n\n알아두세요!\n\nerrorCallback()\n\n이것을 구현하여 하위 컴포넌트의 모든 오류를 캡처하는 오류 경계 컴포넌트를 만드세요.\n\n하위 컴포넌트의 라이프사이클 훅 또는 HTML 템플릿에서 선언된 이벤트 핸들러 중 발생한 오류를 캡처합니다.\n\n\n\n- 자식(하위) 컴포넌트에서 오류가 발생했을 때 호출됩니다.\n- errorCallback(error, stack) 함수에 두 가지 아규먼트가 전달됩니다. error 아규먼트는 JavaScript 네이티브 오류 객체이며, stack 아규먼트는 문자열입니다.\n\n```js\n//Child Component\nconnectedCallback(){\n  console.log('Child Connected Call Back called');\n  throw new Error('problem in child component connectedCallback')\n  }\n```\n\n```js\n//Parent component\nerrorCallback(error, stack){\n  console.log(error 메시지);\n  console.log('Stack: - ' + stack);\n}\n```\n\n이 플로우를 이해하고 각 후크의 사용법을 파악하는 것은 Salesforce 생태계에서 반응형, 효율적이고 인터랙티브 웹 컴포넌트를 효과적으로 관리하고 최적화하는 데 중요합니다.\n\n\n\n# 라이프사이클 훅이 왜 중요한가요?\n\n라이프사이클 훅은 여러 이점을 제공합니다:\n\n- 최적화: 적절한 시간에 개입하여 컴포넌트 렌더링을 최적화함으로써 성능과 응답성을 향상시킬 수 있습니다.\n- 상호작용: 적절한 라이프사이클 단계에서 사용자 작업에 응답함으로써 상호작용형 컴포넌트를 만들 수 있습니다.\n- 자원 관리: 라이프사이클 훅을 사용하여 효율적인 자원 관리가 가능해지며, 컴포넌트가 더 이상 필요하지 않을 때 이벤트 리스너를 해제하고 타이머를 정리할 수 있습니다.\n\n예시: 실용적인 사용 사례\n\n\n\n간단한 예제로 라이프사이클 훅의 중요성을 설명해보겠습니다. 카운트다운 타이머 컴포넌트를 구축 중이라고 상상해보세요. 라이프사이클 훅을 사용하는 방법은 다음과 같습니다:\n\n```js\nexport default class CountdownTimer extends LightningElement {\n    seconds = 10;\n\n    connectedCallback() {\n        this.timer = setInterval(() =\u003e {\n            if (this.seconds \u003e 0) {\n                this.seconds--;\n            }\n        }, 1000);\n    }\n\n    renderedCallback() {\n        if (this.seconds === 0) {\n            clearInterval(this.timer);\n        }\n    }\n\n    disconnectedCallback() {\n        clearInterval(this.timer);\n    }\n}\n```\n\n이 예시에서 `connectedCallback`은 타이머를 설정하고, `renderedCallback`은 타이머가 0에 도달했을 때 UI를 업데이트하며, `disconnectedCallback`은 컴포넌트가 제거될 때 타이머가 중지되도록 보장합니다.\n\n자세한 내용은 아래 링크를 참조해주세요:\n\n\n\n읽어 주셔서 감사합니다 ☺️","ogImage":{"url":"/assets/img/2024-05-14-LifecycleHooksinLWC_0.png"},"coverImage":"/assets/img/2024-05-14-LifecycleHooksinLWC_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-LifecycleHooksinLWC_0.png\" alt=\"Lifecycle Hooks in LWC\"\u003e\u003c/p\u003e\n\u003cp\u003e라이프사이클 훅은 라이트닝 웹 컴포넌트(LWC)를 개발하는 여정에서 굉장히 중요한 부분입니다. 이들은 컴포넌트의 라이프사이클의 다양한 단계를 제어하고 응답하는 능력을 제공하여 Salesforce 생태계에서 웹 컴포넌트를 구축하는데 더 효율적이고 세밀한 접근법을 가능하게 합니다.\u003c/p\u003e\n\u003cp\u003e이 블로그에서는 LWC 라이프사이클 훅의 세계에 대해 자세히 살펴보겠습니다. 이 훅이 무엇이고 왜 중요한지, 그리고 동적이고 반응성 있는 컴포넌트를 만들기 위해 효과적으로 활용하는 방법에 대해 탐구할 것입니다. LWC 여정을 시작한 지 얼마 안 된 분들이거나 기술을 향상하려는 분들, 이러한 훅을 이해하는 것이 강력하고 효율적인 라이트닝 웹 컴포넌트를 만드는 데 중요합니다.\u003c/p\u003e\n\u003cp\u003e이 블로그를 통해 LWC에서 사용 가능한 다양한 라이프사이클 훅을 자세히 살펴보고, 이들의 구체적인 사용 사례를 논의하며, 실용적인 예제를 제공하여 실제 응용 가능한 내용을 파악하는 데 도움을 드리겠습니다. 이 여정의 끝에는 컴포넌트 라이프사이클 관리의 기술을 숙달하여 LWC의 전체 잠재력을 활용할 수 있는 지식을 갖추게 될 것입니다.\u003c/p\u003e\n\u003cp\u003eLifecycle Hooks in LWC: Managing the Journey of a Lightning Web Component\u003c/p\u003e\n\u003cp\u003e라이트닝 웹 컴포넌트(LWC)의 라이프사이클 훅\u003c/p\u003e\n\u003cp\u003e라이트닝 웹 컴포넌트(LWC)는 Salesforce 플랫폼 내에서 동적이고 인터랙티브한 사용자 인터페이스의 구성 요소입니다. 그들의 잠재력을 완벽하게 활용하려면, 개발자들은 이러한 구성 요소들이 라이프사이클 동안 거치는 복잡한 단계를 이해해야 합니다. 이것이 바로 \"라이프사이클 훅(Lifecycle Hooks)\"의 세계입니다.\u003c/p\u003e\n\u003ch1\u003e라이프사이클 훅이란?\u003c/h1\u003e\n\u003cp\u003eLWC의 라이프사이클 훅은 개발자들이 컴포넌트의 여정의 다른 단계에서 개입할 수 있는 미리 정의된 메소드들입니다. 이러한 훅들은 컴포넌트의 라이프사이클에서 발생하는 특정 이벤트와 전환에 대응하고 제어하고 최적화할 수 있는 능력을 제공합니다. 이러한 훅들을 이해하고 효과적으로 사용하는 것이 견고하고 반응적인 컴포넌트를 만드는 핵심입니다.\u003c/p\u003e\n\u003cp\u003e여기 몇 가지 중요한 라이프사이클 후크에 대한 간단한 개요입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003econstructor(): 컴포넌트가 초기화되는 곳입니다. 기본값을 설정하고 일회성 설정을 수행할 수 있습니다.\u003c/li\u003e\n\u003cli\u003econnectedCallback(): 컴포넌트가 DOM에 추가된 후에 실행되는 후크입니다. DOM 조작 및 데이터 검색에 좋은 장소입니다.\u003c/li\u003e\n\u003cli\u003erenderedCallback(): 렌더링 후에 트리거되는 후크입니다. 렌더링된 DOM에 대한 지식이 필요한 작업에 이상적입니다.\u003c/li\u003e\n\u003cli\u003edisconnectedCallback(): 컴포넌트가 DOM에서 제거될 때 호출되는 후크입니다. 정리 작업 및 리소스 해제에 사용하세요.\u003c/li\u003e\n\u003cli\u003eerrorCallback(): 렌더링 중에 오류가 발생하면 호출되는 후크입니다. 오류를 우아하게 처리할 기회입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e라이프사이클 후크 흐름\u003c/h1\u003e\n\u003cp\u003e먼저 부모 constructor가 호출되고, 부모 connectedCallBack가 실행된 후, 자식 컴포넌트가 있으면 자식 constructor → connectedCallback → renderedCallback 순으로 진행되고 다시 부모 renderedCallback로 이동합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-LifecycleHooksinLWC_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e생성:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econstructor()\u003c/code\u003e: 컴포넌트 인스턴스가 생성될 때 실행되는 첫 번째 후크입니다. 변수를 초기화하고 기본 값 설정하는 곳입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e주의하세요!\u003c/p\u003e\n\u003cp\u003e생성자()\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e컴포넌트의 인스턴스가 생성될 때 호출됩니다(init()와 비슷합니다).\u003c/li\u003e\n\u003cli\u003e부모 컴포넌트에서 먼저 발생하며 부모에서 자식으로 흘러갑니다.\u003c/li\u003e\n\u003cli\u003e부모 클래스 생성자인 LightningElement를 호출하려면 먼저 super()를 호출해야 합니다.\u003c/li\u003e\n\u003cli\u003e컴포넌트 템플릿에서 요소에 액세스하려면 this.template을 사용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eLightningElement\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'lwc'\u003c/span\u003e;\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLifeCycleHookParent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eLightningElement\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// LightningElement 클래스 생성자를 호출합니다. console.log('Parent Constructor Called');\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e con = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etemplate\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 호스트 요소에 액세스합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(con);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e초기화:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003econnectedCallback()\u003c/code\u003e: 컴포넌트가 초기화된 후에 이 훅이 호출됩니다. DOM 조작 및 데이터 검색에 이상적인 위치입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e주의!\u003c/p\u003e\n\u003cp\u003econnectedCallback()\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e컴포넌트가 DOM에 삽입될 때 호출됩니다.\u003c/li\u003e\n\u003cli\u003e부모에서 자식으로 흐릅니다.\u003c/li\u003e\n\u003cli\u003e데이터를 가져오고 캐시를 설정하며 이벤트를 수신하는 초기화 작업을 수행하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e컴포넌트가 DOM에 연결되어 있는지 확인하려면 isConnected 메서드를 사용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003econnectedCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e){\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Parent Connected Call Back called'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e cb = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etemplate\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'is connected=\u003e '\u003c/span\u003e + cb.\u003cspan class=\"hljs-property\"\u003eisConnected\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e렌더링:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erenderedCallback()\u003c/code\u003e: 이 훅은 컴포넌트의 초기 렌더링 후에 트리거됩니다. 요소와 상호 작용하는 것과 같은 렌더링된 DOM에 대한 지식이 필요한 작업에 적합합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e주의하세요!\u003c/p\u003e\n\u003cp\u003erenderedCallback()\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e컴포넌트가 렌더링 프레임워크를 완료한 후에 로직을 수행할 때 사용합니다. 이는 컴포넌트가 UI에 완전히 렌더링된 후에 호출됩니다.\u003c/li\u003e\n\u003cli\u003e자식 컴포넌트에서 부모 컴포넌트로 흐름이 됩니다.\u003c/li\u003e\n\u003cli\u003e컴포넌트는 여러 번 렌더링되어 렌더링 콜백을 추적하려면 isRendered 불리언 필드를 사용하세요.\u003c/li\u003e\n\u003cli\u003e렌더링된 콜백 내에서 무한 루프로 이어지는 속성을 조심하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eLightningElement\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'lwc'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLifeCycleHookParent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eLightningElement\u003c/span\u003e {\n  isRendered = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 컴포넌트가 렌더링되었는지 확인하기 위한 변수\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003erenderedCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eisRendered\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'부모 컴포넌트의 렌더링 콜백이 호출되었습니다'\u003c/span\u003e);\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eisRendered\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n    }\n  ?\n }\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eReactivity:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e컴포넌트 내의 속성 또는 변수가 변경될 때마다 반응성 주기가 트리거될 수 있습니다. 이 주기 중에는 컴포넌트가 속성 변화를 확인하며, 변화가 감지되면 다시 렌더링되고 \u003ccode\u003erenderedCallback\u003c/code\u003e을 다시 호출합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e소멸:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edisconnectedCallback()\u003c/code\u003e: 컴포넌트가 DOM에서 제거될 때 이 후크가 호출됩니다. 정리 작업이나 이벤트 리스너와 같은 리소스 해제에 뛰어난 장소입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e주의하세요!\u003c/p\u003e\n\u003cp\u003edisconnectedCallback()\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e문서에서 요소가 제거될 때 호출됩니다 (이벤트 리스너 제거, 시간 간격 제거 등).\u003c/li\u003e\n\u003cli\u003eParent에서 Child로 이어집니다.\u003c/li\u003e\n\u003cli\u003econnectedCallback()에서 수행한 작업 정리에 disconnectedCallback()을 사용하십시오. 예를 들어, 이벤트 리스너 제거 등.\u003c/li\u003e\n\u003cli\u003e메시지 채널 구독 취소 등에도 이 후크를 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003e오류 처리:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eerrorCallback()\u003c/code\u003e: 렌더링 중 오류가 발생하면 이 후크가 호출됩니다. 오류를 우아하게 처리하고 적절한 메시지를 표시할 수 있는 기회를 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e알아두세요!\u003c/p\u003e\n\u003cp\u003eerrorCallback()\u003c/p\u003e\n\u003cp\u003e이것을 구현하여 하위 컴포넌트의 모든 오류를 캡처하는 오류 경계 컴포넌트를 만드세요.\u003c/p\u003e\n\u003cp\u003e하위 컴포넌트의 라이프사이클 훅 또는 HTML 템플릿에서 선언된 이벤트 핸들러 중 발생한 오류를 캡처합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e자식(하위) 컴포넌트에서 오류가 발생했을 때 호출됩니다.\u003c/li\u003e\n\u003cli\u003eerrorCallback(error, stack) 함수에 두 가지 아규먼트가 전달됩니다. error 아규먼트는 JavaScript 네이티브 오류 객체이며, stack 아규먼트는 문자열입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//Child Component\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003econnectedCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e){\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Child Connected Call Back called'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'problem in child component connectedCallback'\u003c/span\u003e)\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//Parent component\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eerrorCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eerror, stack\u003c/span\u003e){\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(error 메시지);\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Stack: - '\u003c/span\u003e + stack);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 플로우를 이해하고 각 후크의 사용법을 파악하는 것은 Salesforce 생태계에서 반응형, 효율적이고 인터랙티브 웹 컴포넌트를 효과적으로 관리하고 최적화하는 데 중요합니다.\u003c/p\u003e\n\u003ch1\u003e라이프사이클 훅이 왜 중요한가요?\u003c/h1\u003e\n\u003cp\u003e라이프사이클 훅은 여러 이점을 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e최적화: 적절한 시간에 개입하여 컴포넌트 렌더링을 최적화함으로써 성능과 응답성을 향상시킬 수 있습니다.\u003c/li\u003e\n\u003cli\u003e상호작용: 적절한 라이프사이클 단계에서 사용자 작업에 응답함으로써 상호작용형 컴포넌트를 만들 수 있습니다.\u003c/li\u003e\n\u003cli\u003e자원 관리: 라이프사이클 훅을 사용하여 효율적인 자원 관리가 가능해지며, 컴포넌트가 더 이상 필요하지 않을 때 이벤트 리스너를 해제하고 타이머를 정리할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시: 실용적인 사용 사례\u003c/p\u003e\n\u003cp\u003e간단한 예제로 라이프사이클 훅의 중요성을 설명해보겠습니다. 카운트다운 타이머 컴포넌트를 구축 중이라고 상상해보세요. 라이프사이클 훅을 사용하는 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCountdownTimer\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eLightningElement\u003c/span\u003e {\n    seconds = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-title function_\"\u003econnectedCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etimer\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003esetInterval\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eseconds\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n                \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eseconds\u003c/span\u003e--;\n            }\n        }, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-title function_\"\u003erenderedCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eseconds\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n            \u003cspan class=\"hljs-built_in\"\u003eclearInterval\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etimer\u003c/span\u003e);\n        }\n    }\n\n    \u003cspan class=\"hljs-title function_\"\u003edisconnectedCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-built_in\"\u003eclearInterval\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etimer\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서 \u003ccode\u003econnectedCallback\u003c/code\u003e은 타이머를 설정하고, \u003ccode\u003erenderedCallback\u003c/code\u003e은 타이머가 0에 도달했을 때 UI를 업데이트하며, \u003ccode\u003edisconnectedCallback\u003c/code\u003e은 컴포넌트가 제거될 때 타이머가 중지되도록 보장합니다.\u003c/p\u003e\n\u003cp\u003e자세한 내용은 아래 링크를 참조해주세요:\u003c/p\u003e\n\u003cp\u003e읽어 주셔서 감사합니다 ☺️\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-LifecycleHooksinLWC"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>