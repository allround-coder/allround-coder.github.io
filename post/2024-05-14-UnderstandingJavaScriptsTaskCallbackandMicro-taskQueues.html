<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues" data-gatsby-head="true"/><meta name="twitter:title" content="자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 12:49" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">2<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png">
<p>JavaScript 코드 실행 방식에 대해 궁금했던 적이 있나요? 웹 브라우저 내에서 JavaScript 코드 실행은 단일 스레드로 이루어지며 비동기 작업들이 어떻게 조율되는지 흥미로운 여정을 안내합니다.</p>
<p>JavaScript는 단일 스레드 내에서 작동합니다. 이는 한 번에 한 가지 작업만 수행할 수 있다는 것을 의미합니다. 그러나 재미있는 점은, 이 제약에도 불구하고 JavaScript가 네트워크 요청이나 setTimeout() 함수 호출과 같은 비동기 작업을 원할하게 다룰 수 있고 사용자 인터페이스가 멈추지 않는다는 것입니다.</p>
<p>그렇다면, JavaScript는 이를 어떻게 성취할까요?</p>
<p>자바스크립트는 사용자 인터페이스가 반응성을 유지하는 동안 비동기 작업을 관리하기 위한 병렬처리 방식을 채용합니다. setTimeout()을 사용하여 네트워크 요청 또는 타임아웃과 같은 비동기 작업을 시작할 때, 자바스크립트는 이러한 작업이 완료될 때까지 기다리지 않습니다. 대신에 브라우저의 비동기 작업 처리를 담당하는 기본 메커니즘으로 위임합니다.</p>
<p>이제 깊게 들어가 봅시다.</p>
<p>자바스크립트 병렬처리 모델의 핵심은 이벤트 루프입니다. 이벤트 루프는 작업의 실행을 감독합니다. 이벤트 루프는 실행 스택과 작업 대기열(작업/콜백 및 마이크로 작업 대기열)을 지속적으로 모니터링하여 올바른 순서로 작업이 실행되고 주 스레드가 차단되지 않도록 합니다.</p>
<p>작업 대기열은 비동기 이벤트에 응답하여 실행되도록 예약된 작업을 보관하는 곳입니다. 예를 들어 사용자가 버튼을 클릭하거나 setTimeout()으로 설정된 타이머가 만료될 때, 자바스크립트는 관련 작업을 작업 대기열에 추가합니다. 자바스크립트 병렬처리 모델의 중심 요소인 이벤트 루프는 실행 스택과 작업 대기열을 지속적으로 모니터링합니다. 실행 스택이 비어 있고 작업 대기열에 작업이 있는 경우, 이벤트 루프는 다음 작업을 선택하여 실행하고 해당 콜백 함수를 호출합니다. 이 과정은 계속 반복되며, 작업이 콜백 대기열에 추가되어 큐에 정렬된 순서대로 실행됩니다.</p>
<p>자바스크립트는 작업 대기열 외에도 고우선 순위 작업을 처리하기 위한 마이크로태스크 대기열을 유지합니다. 마이크로태스크는 일반적으로 사용자 인터페이스를 업데이트하는 시간이 중요한 작업과 같은 작업에 사용됩니다. 마이크로태스크가 생성되면 마이크로태스크 대기열에 넣어집니다. 작업 대기열의 작업과 달리 마이크로태스크는 현재 실행 컨텍스트(예: 현재 함수)가 완료된 후 즉시 실행되며, 그 후에 제어가 이벤트 루프로 돌아갑니다. 이벤트 루프는 마이크로태스크를 작업 대기열의 작업보다 우선 처리하여 신속하게 처리합니다. 마이크로태스크 대기열의 모든 마이크로태스크가 실행된 후, 이벤트 루프는 나머지 작업을 처리하기 위해 작업 대기열로 돌아가며 동기적 및 비동기적 작업 사이의 균형을 유지합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"자바스크립트의 태스크콜백 및 마이크로태스크 큐 이해하기","description":"","date":"2024-05-14 12:49","slug":"2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues","content":"\n\n\n\u003cimg src=\"/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png\" /\u003e\n\nJavaScript 코드 실행 방식에 대해 궁금했던 적이 있나요? 웹 브라우저 내에서 JavaScript 코드 실행은 단일 스레드로 이루어지며 비동기 작업들이 어떻게 조율되는지 흥미로운 여정을 안내합니다.\n\nJavaScript는 단일 스레드 내에서 작동합니다. 이는 한 번에 한 가지 작업만 수행할 수 있다는 것을 의미합니다. 그러나 재미있는 점은, 이 제약에도 불구하고 JavaScript가 네트워크 요청이나 setTimeout() 함수 호출과 같은 비동기 작업을 원할하게 다룰 수 있고 사용자 인터페이스가 멈추지 않는다는 것입니다.\n\n그렇다면, JavaScript는 이를 어떻게 성취할까요?\n\n\n\n\n자바스크립트는 사용자 인터페이스가 반응성을 유지하는 동안 비동기 작업을 관리하기 위한 병렬처리 방식을 채용합니다. setTimeout()을 사용하여 네트워크 요청 또는 타임아웃과 같은 비동기 작업을 시작할 때, 자바스크립트는 이러한 작업이 완료될 때까지 기다리지 않습니다. 대신에 브라우저의 비동기 작업 처리를 담당하는 기본 메커니즘으로 위임합니다.\n\n이제 깊게 들어가 봅시다.\n\n자바스크립트 병렬처리 모델의 핵심은 이벤트 루프입니다. 이벤트 루프는 작업의 실행을 감독합니다. 이벤트 루프는 실행 스택과 작업 대기열(작업/콜백 및 마이크로 작업 대기열)을 지속적으로 모니터링하여 올바른 순서로 작업이 실행되고 주 스레드가 차단되지 않도록 합니다.\n\n작업 대기열은 비동기 이벤트에 응답하여 실행되도록 예약된 작업을 보관하는 곳입니다. 예를 들어 사용자가 버튼을 클릭하거나 setTimeout()으로 설정된 타이머가 만료될 때, 자바스크립트는 관련 작업을 작업 대기열에 추가합니다. 자바스크립트 병렬처리 모델의 중심 요소인 이벤트 루프는 실행 스택과 작업 대기열을 지속적으로 모니터링합니다. 실행 스택이 비어 있고 작업 대기열에 작업이 있는 경우, 이벤트 루프는 다음 작업을 선택하여 실행하고 해당 콜백 함수를 호출합니다. 이 과정은 계속 반복되며, 작업이 콜백 대기열에 추가되어 큐에 정렬된 순서대로 실행됩니다.\n\n\n\n자바스크립트는 작업 대기열 외에도 고우선 순위 작업을 처리하기 위한 마이크로태스크 대기열을 유지합니다. 마이크로태스크는 일반적으로 사용자 인터페이스를 업데이트하는 시간이 중요한 작업과 같은 작업에 사용됩니다. 마이크로태스크가 생성되면 마이크로태스크 대기열에 넣어집니다. 작업 대기열의 작업과 달리 마이크로태스크는 현재 실행 컨텍스트(예: 현재 함수)가 완료된 후 즉시 실행되며, 그 후에 제어가 이벤트 루프로 돌아갑니다. 이벤트 루프는 마이크로태스크를 작업 대기열의 작업보다 우선 처리하여 신속하게 처리합니다. 마이크로태스크 대기열의 모든 마이크로태스크가 실행된 후, 이벤트 루프는 나머지 작업을 처리하기 위해 작업 대기열로 돌아가며 동기적 및 비동기적 작업 사이의 균형을 유지합니다.","ogImage":{"url":"/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png"},"coverImage":"/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png","tag":["Tech"],"readingTime":2},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues_0.png\"\u003e\n\u003cp\u003eJavaScript 코드 실행 방식에 대해 궁금했던 적이 있나요? 웹 브라우저 내에서 JavaScript 코드 실행은 단일 스레드로 이루어지며 비동기 작업들이 어떻게 조율되는지 흥미로운 여정을 안내합니다.\u003c/p\u003e\n\u003cp\u003eJavaScript는 단일 스레드 내에서 작동합니다. 이는 한 번에 한 가지 작업만 수행할 수 있다는 것을 의미합니다. 그러나 재미있는 점은, 이 제약에도 불구하고 JavaScript가 네트워크 요청이나 setTimeout() 함수 호출과 같은 비동기 작업을 원할하게 다룰 수 있고 사용자 인터페이스가 멈추지 않는다는 것입니다.\u003c/p\u003e\n\u003cp\u003e그렇다면, JavaScript는 이를 어떻게 성취할까요?\u003c/p\u003e\n\u003cp\u003e자바스크립트는 사용자 인터페이스가 반응성을 유지하는 동안 비동기 작업을 관리하기 위한 병렬처리 방식을 채용합니다. setTimeout()을 사용하여 네트워크 요청 또는 타임아웃과 같은 비동기 작업을 시작할 때, 자바스크립트는 이러한 작업이 완료될 때까지 기다리지 않습니다. 대신에 브라우저의 비동기 작업 처리를 담당하는 기본 메커니즘으로 위임합니다.\u003c/p\u003e\n\u003cp\u003e이제 깊게 들어가 봅시다.\u003c/p\u003e\n\u003cp\u003e자바스크립트 병렬처리 모델의 핵심은 이벤트 루프입니다. 이벤트 루프는 작업의 실행을 감독합니다. 이벤트 루프는 실행 스택과 작업 대기열(작업/콜백 및 마이크로 작업 대기열)을 지속적으로 모니터링하여 올바른 순서로 작업이 실행되고 주 스레드가 차단되지 않도록 합니다.\u003c/p\u003e\n\u003cp\u003e작업 대기열은 비동기 이벤트에 응답하여 실행되도록 예약된 작업을 보관하는 곳입니다. 예를 들어 사용자가 버튼을 클릭하거나 setTimeout()으로 설정된 타이머가 만료될 때, 자바스크립트는 관련 작업을 작업 대기열에 추가합니다. 자바스크립트 병렬처리 모델의 중심 요소인 이벤트 루프는 실행 스택과 작업 대기열을 지속적으로 모니터링합니다. 실행 스택이 비어 있고 작업 대기열에 작업이 있는 경우, 이벤트 루프는 다음 작업을 선택하여 실행하고 해당 콜백 함수를 호출합니다. 이 과정은 계속 반복되며, 작업이 콜백 대기열에 추가되어 큐에 정렬된 순서대로 실행됩니다.\u003c/p\u003e\n\u003cp\u003e자바스크립트는 작업 대기열 외에도 고우선 순위 작업을 처리하기 위한 마이크로태스크 대기열을 유지합니다. 마이크로태스크는 일반적으로 사용자 인터페이스를 업데이트하는 시간이 중요한 작업과 같은 작업에 사용됩니다. 마이크로태스크가 생성되면 마이크로태스크 대기열에 넣어집니다. 작업 대기열의 작업과 달리 마이크로태스크는 현재 실행 컨텍스트(예: 현재 함수)가 완료된 후 즉시 실행되며, 그 후에 제어가 이벤트 루프로 돌아갑니다. 이벤트 루프는 마이크로태스크를 작업 대기열의 작업보다 우선 처리하여 신속하게 처리합니다. 마이크로태스크 대기열의 모든 마이크로태스크가 실행된 후, 이벤트 루프는 나머지 작업을 처리하기 위해 작업 대기열로 돌아가며 동기적 및 비동기적 작업 사이의 균형을 유지합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-UnderstandingJavaScriptsTaskCallbackandMicro-taskQueues"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>