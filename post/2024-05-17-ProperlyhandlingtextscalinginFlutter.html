<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>플러터에서 텍스트 스케일링을 적절히 다루는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-17-ProperlyhandlingtextscalinginFlutter" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="플러터에서 텍스트 스케일링을 적절히 다루는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="플러터에서 텍스트 스케일링을 적절히 다루는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-17-ProperlyhandlingtextscalinginFlutter" data-gatsby-head="true"/><meta name="twitter:title" content="플러터에서 텍스트 스케일링을 적절히 다루는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 03:37" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-742e6c91a18eb160.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">플러터에서 텍스트 스케일링을 적절히 다루는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="플러터에서 텍스트 스케일링을 적절히 다루는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-ProperlyhandlingtextscalinginFlutter&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이 튜토리얼은 가장 쉽고 영향력이 큰 해결책을 먼저 제시하도록 구성되어 있어요. 후속 섹션에는 구현이 어려우면서 전반적인 영향이 더 낮은 해결책들이 포함되어 있지만, 특정 경우에 대응하기 위해 유용해요.</p>
<p><img src="/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png" alt="이미지"></p>
<h2>텍스트 스케일링 가능 범위 제한</h2>
<p>MaterialApp에 최소 및 최대 스케일 팩터를 설정할 수 있어요. 이렇게 하면 모든 텍스트가 지정한 범위 내에서 스케일링된다는 것을 보장할 수 있어요. 더 빈번한 경계는 가독성과 미적 감각을 유지하는 데 덜 노력이 필요해요. 그러나 경계 선택은 대상 사용자에 따라 달라져야 해요. 예를 들어 노인 사용자를 대상으로 한 앱의 경우, 그들의 요구를 수용하기 위해 더 넓은 범위를 사용하는 것을 고려해야 해요.</p>
<pre><code class="hljs language-js">    <span class="hljs-title class_">MaterialApp</span>(
      ...
      <span class="hljs-attr">builder</span>: <span class="hljs-function">(<span class="hljs-params">_, child</span>) =></span> <span class="hljs-title class_">MediaQuery</span>(
        <span class="hljs-attr">data</span>: <span class="hljs-title class_">MediaQuery</span>.<span class="hljs-title function_">of</span>(context).<span class="hljs-title function_">copyWith</span>(
          <span class="hljs-attr">textScaler</span>: <span class="hljs-title class_">MediaQuery</span>.<span class="hljs-title function_">of</span>(context)
              .<span class="hljs-property">textScaler</span>
              .<span class="hljs-title function_">clamp</span>(<span class="hljs-attr">minScaleFactor</span>: <span class="hljs-number">0.8</span>, <span class="hljs-attr">maxScaleFactor</span>: <span class="hljs-number">1.6</span>),
        ),
        <span class="hljs-attr">child</span>: child!,
      ),
    );
</code></pre>
<h2>텍스트를 포함하는 요소에 고정 높이를 사용하지 마세요</h2>
<p>다음 코드를 살펴보세요:</p>
<pre><code class="hljs language-js">          <span class="hljs-comment">//DON'T</span>
          <span class="hljs-title class_">SizedBox</span>(
            <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>,
            <span class="hljs-attr">child</span>: <span class="hljs-title class_">Card</span>(
              <span class="hljs-attr">child</span>: <span class="hljs-title class_">Center</span>(
                <span class="hljs-attr">child</span>: <span class="hljs-title class_">Column</span>(
                  <span class="hljs-attr">mainAxisAlignment</span>: <span class="hljs-title class_">MainAxisAlignment</span>.<span class="hljs-property">center</span>,
                  <span class="hljs-attr">children</span>: [
                    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"Title"</span>, <span class="hljs-attr">style</span>: <span class="hljs-title class_">TextStyle</span>(<span class="hljs-attr">fontSize</span>: <span class="hljs-number">30</span>), <span class="hljs-attr">maxLines</span>: <span class="hljs-number">1</span>),
                    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"Subtitle"</span>, <span class="hljs-attr">maxLines</span>: <span class="hljs-number">1</span>),
                  ],
                ),
              ),
            ),
          ),
</code></pre>
<p>문제가 발생할 수 있습니다.</p>
<p>예상하신 대로, 텍스트 크기를 키우면 SizedBox의 내용이 너무 많은 공간을 차지할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_1.png" alt="image"></p>
<p>컨텐츠 높이 및 패딩에 기반한 아이템의 높이를 만드는 것이 더 좋습니다. 게다가 ConstrainedBox를 사용하여 최소 높이를 설정할 수도 있습니다.</p>
<pre><code class="hljs language-dart">ConstrainedBox(
  constraints: <span class="hljs-keyword">const</span> BoxConstraints(minHeight: <span class="hljs-number">100</span>),
  child: <span class="hljs-keyword">const</span> Card(
    child: Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(<span class="hljs-string">"Title"</span>, style: TextStyle(fontSize: <span class="hljs-number">30</span>), maxLines: <span class="hljs-number">1</span>),
          Text(<span class="hljs-string">"Subtitle"</span>, maxLines: <span class="hljs-number">1</span>),
        ],
      ),
    ),
  ),
),
</code></pre>
<p>결과적으로 100% 배율에서 동일한 레이아웃을 얻고, 160%에서도 유효한 레이아웃을 얻을 수 있습니다.</p>
<p>ListView에도 동일한 사항이 적용됩니다. itemExtent를 사용하는 경우, 폰트 스케일을 고려하여 계산하거나 prototypeItem을 제공하는 것이 좋습니다. 이에 대해 자세히 설명된 내용은 이 기사에서 확인할 수 있습니다.</p>
<p>계속 진행해 봅시다. 다음 레이아웃을 상상해보세요:</p>
<p><img src="/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_3.png" alt="Image1"></p>
<p>아이템 A는 이전 예시에서 나왔어요. 아이템 B는 약간의 간격을 가지고 있고 텍스트 확대에 대응할 수 있어야해요. 화면 하단에는 충분한 공간이 있어요. 그래서 어떤 문제가 발생할 수 있을까요?</p>
<p><img src="/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_4.png" alt="Image2"></p>
<p>화면이 작은 폰들도 고려해주세요. 또한, 언어를 바꿀 때 텍스트 길이가 달라질 수 있어요.</p>
<h2>컨텐츠를 스크롤할 수 있도록 만들기</h2>
<p>먼저, 모든 컨텐츠에 접근 가능하도록 오버플로우를 제거해야 해요. 간단한 SingleChildScrollView를 추가하면 이 문제를 해결할 수 있어요.</p>
<h2>마진과 패딩에 대해 적응적인 값을 사용하는 것을 고려해보세요</h2>
<p>이것은 논란이 될 수 있는 방법일 수 있지만, 자신이 더 큰 글꼴을 사용해야 하는 사용자로 상상해보세요. 사용되지 않는 공간을 많이 보고 싶으신가요 아니면 텍스트를 명확하게 읽고 싶으신가요?</p>
<p>텍스트를 표시하는 논리적 픽셀의 수에 따라 값들을 사용해봅시다. smallScreenThreshold를 응용 프로그램에 가장 적합한 값으로 조절할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dimens</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> smallScreenThreshold = <span class="hljs-number">300</span>;
  <span class="hljs-keyword">static</span> bool <span class="hljs-title function_">isSmallWidth</span>(<span class="hljs-params">BuildContext context</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">MediaQuery</span>.<span class="hljs-title function_">of</span>(context).<span class="hljs-property">size</span>.<span class="hljs-property">width</span> /
            <span class="hljs-title class_">MediaQuery</span>.<span class="hljs-title function_">textScalerOf</span>(context).<span class="hljs-title function_">scale</span>(<span class="hljs-number">1</span>) &#x3C;
        smallScreenThreshold;
  }

  <span class="hljs-keyword">static</span> double <span class="hljs-title function_">small</span>(<span class="hljs-title class_">BuildContext</span> context) => <span class="hljs-title function_">isSmallWidth</span>(context) ? <span class="hljs-number">4</span> : <span class="hljs-number">8</span>;
  <span class="hljs-keyword">static</span> double <span class="hljs-title function_">medium</span>(<span class="hljs-title class_">BuildContext</span> context) => <span class="hljs-title function_">isSmallWidth</span>(context) ? <span class="hljs-number">8</span> : <span class="hljs-number">16</span>;
  <span class="hljs-keyword">static</span> double <span class="hljs-title function_">large</span>(<span class="hljs-title class_">BuildContext</span> context) => <span class="hljs-title function_">isSmallWidth</span>(context) ? <span class="hljs-number">16</span> : <span class="hljs-number">32</span>;
}
</code></pre>
<p>만약 Human Interface Guidelines와 Material Design을 따르고 싶다면, 이 값들은 4로 나눌 수 있는 값이어야 합니다.</p>
<p>이러한 Dimens에 기반하여 간격에 대한 클래스를 만들 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Insets</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title class_">EdgeInsets</span> <span class="hljs-title function_">small</span>(<span class="hljs-title class_">BuildContext</span> context) =>
      <span class="hljs-title class_">EdgeInsets</span>.<span class="hljs-title function_">all</span>(<span class="hljs-title class_">Dimens</span>.<span class="hljs-title function_">small</span>(context));
      
  <span class="hljs-keyword">static</span> <span class="hljs-title class_">EdgeInsets</span> <span class="hljs-title function_">medium</span>(<span class="hljs-title class_">BuildContext</span> context) =>
      <span class="hljs-title class_">EdgeInsets</span>.<span class="hljs-title function_">all</span>(<span class="hljs-title class_">Dimens</span>.<span class="hljs-title function_">medium</span>(context));

  <span class="hljs-keyword">static</span> <span class="hljs-title class_">EdgeInsets</span> <span class="hljs-title function_">large</span>(<span class="hljs-title class_">BuildContext</span> context) =>
      <span class="hljs-title class_">EdgeInsets</span>.<span class="hljs-title function_">all</span>(<span class="hljs-title class_">Dimens</span>.<span class="hljs-title function_">large</span>(context));
}
</code></pre>
<p>그리고 코드에서 다음과 같이 대체합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//padding: const EdgeInsets.all(16),</span>
<span class="hljs-attr">padding</span>: <span class="hljs-title class_">Insets</span>.<span class="hljs-title function_">medium</span>(context),

<span class="hljs-comment">//SizedBox(height: 16),</span>
<span class="hljs-title class_">SizedBox</span>(<span class="hljs-attr">height</span>: <span class="hljs-title class_">Dimens</span>.<span class="hljs-title function_">medium</span>(context)),
</code></pre>
<p>결과적으로 화면에 텍스트를 그릴 수 있는 공간이 조금 더 확보되었습니다:</p>
<p><img src="/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_5.png" alt="이미지"></p>
<h2>제목의 텍스트 크기 확장을 제한하세요</h2>
<p>글꼴 크기를 크게 하는 주된 목적은 시력이 약해진 사람들에게 콘텐츠를 가독성 있게 만드는 것입니다. 그러나 제목과 같은 앱의 일부는 이미 글꼴이 크기 때문에 접근성이 좋을 수 있습니다. 이를 해결하기 위해 텍스트가 확대될 수 있는 범위를 제한할 수 있습니다. 이를 달성하는 한 가지 방법은 제목용 사용자 정의 위젯을 만드는 것입니다:</p>
<pre><code class="hljs language-dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TitleText</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> text;
  <span class="hljs-keyword">final</span> TextStyle style;

  <span class="hljs-keyword">const</span> TitleText(<span class="hljs-keyword">this</span>.text, {<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.style, <span class="hljs-keyword">super</span>.key});

  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span> maxRealFontSize = <span class="hljs-number">30</span>;

  <span class="hljs-meta">@override</span>
  Widget build(BuildContext context) {
    <span class="hljs-keyword">if</span> (MediaQuery.textScalerOf(context).scale(style.fontSize!) >
        maxRealFontSize) {
      <span class="hljs-keyword">return</span> Text(
        text,
        style: style.copyWith(
          fontSize: maxRealFontSize / MediaQuery.textScalerOf(context).scale(<span class="hljs-number">1</span>),
        ),
      );
    }
    <span class="hljs-keyword">return</span> Text(text, style: style);
  }
}
</code></pre>
<p>이렇게 하면 가독성을 유지하면서 공간을 더 확보할 수 있어요. 앱에 더 적합한 값으로 maxRealFontSize를 변경할 수 있어요.</p>
<h2>최대 줄 수 및 텍스트 오버플로우 지정하기</h2>
<p>큰 화면에서 일반적인 텍스트 스케일로 보기 좋을 수도 있지만, 다른 조건에서는 수직 공간을 더 많이 차지할 수 있음을 잊지 마세요. 그러나 제목(Subtitle)과 같은 곳은 항상 전체 내용을 표시할 필요가 없습니다. Text 위젯에 maxLines 값을 추가하여 원하는 줄 수로 설정할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_7.png" alt="Properly handling text scaling in Flutter"></p>
<p>1로 설정된 maxLines로 보기 좋네요. 주요 정보는 여전히 잘 보입니다.</p>
<h2>문자열의 대안 버전 사용하기</h2>
<p>하지만 항상 유용한 정보를 포함하는 방식으로 문자열을 줄이는 것이 가능한 것은 아닙니다. 게다가, 단어 순서는 다른 언어들에서 다르게 변할 수 있습니다. 영어에서의 첫 번째 단어가 다른 언어에서는 문장의 끝에 올 수도 있습니다. 이번에는 국제화(i18n) 문자열을 고려해보는 것이 중요합니다:</p>
<pre><code class="hljs language-js">        <span class="hljs-string">"tasksDone"</span>: {
            <span class="hljs-string">"one"</span>: <span class="hljs-string">"할 일 중 $completed 개 완료"</span>,
            <span class="hljs-string">"other"</span>: <span class="hljs-string">"할 일 중 $completed 개 완료"</span>
        },
        <span class="hljs-string">"tasksDoneShort"</span>: {
            <span class="hljs-string">"one"</span>: <span class="hljs-string">"$completed/$n 작업 완료"</span>,
            <span class="hljs-string">"other"</span>: <span class="hljs-string">"$completed/$n 작업 완료"</span>
        },
</code></pre>
<p>가장 의미 있는 부분은 숫자를 나타낸 부분입니다. 더 짧은 버전에서 숫자를 앞에 두고 전체 문자열을 더 짧게 만들었습니다. 코드에서는 다음과 같이 사용할 수 있습니다:</p>
<pre><code class="hljs language-js">        <span class="hljs-title class_">Text</span>(
          <span class="hljs-title class_">Dimens</span>.<span class="hljs-title function_">isSmallWidth</span>(context)
              ? t.<span class="hljs-title function_">tasksDoneShort</span>(<span class="hljs-attr">n</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">completed</span>: <span class="hljs-number">5</span>)
              : t.<span class="hljs-title function_">tasksDone</span>(<span class="hljs-attr">n</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">completed</span>: <span class="hljs-number">5</span>),
          <span class="hljs-attr">maxLines</span>: <span class="hljs-number">1</span>,
        )
</code></pre>
<p><img src="/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_8.png" alt="Screenshot"></p>
<p>스크린샷을 보시면, 단축된 버전을 사용하면 필요한 정보를 보여주는 데 도움이 됩니다.</p>
<p>이 기사가 유용하게 느껴졌으면 좋겠네요. 더 유용한 기술을 찾으면 업데이트할 예정입니다. 코드는 이 저장소에서 찾을 수 있습니다.</p>
<p><img src="/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_9.png" alt="Screenshot"></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"플러터에서 텍스트 스케일링을 적절히 다루는 방법","description":"","date":"2024-05-17 03:37","slug":"2024-05-17-ProperlyhandlingtextscalinginFlutter","content":"\n\n이 튜토리얼은 가장 쉽고 영향력이 큰 해결책을 먼저 제시하도록 구성되어 있어요. 후속 섹션에는 구현이 어려우면서 전반적인 영향이 더 낮은 해결책들이 포함되어 있지만, 특정 경우에 대응하기 위해 유용해요.\n\n![이미지](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png)\n\n## 텍스트 스케일링 가능 범위 제한\n\nMaterialApp에 최소 및 최대 스케일 팩터를 설정할 수 있어요. 이렇게 하면 모든 텍스트가 지정한 범위 내에서 스케일링된다는 것을 보장할 수 있어요. 더 빈번한 경계는 가독성과 미적 감각을 유지하는 데 덜 노력이 필요해요. 그러나 경계 선택은 대상 사용자에 따라 달라져야 해요. 예를 들어 노인 사용자를 대상으로 한 앱의 경우, 그들의 요구를 수용하기 위해 더 넓은 범위를 사용하는 것을 고려해야 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n    MaterialApp(\n      ...\n      builder: (_, child) =\u003e MediaQuery(\n        data: MediaQuery.of(context).copyWith(\n          textScaler: MediaQuery.of(context)\n              .textScaler\n              .clamp(minScaleFactor: 0.8, maxScaleFactor: 1.6),\n        ),\n        child: child!,\n      ),\n    );\n```\n\n## 텍스트를 포함하는 요소에 고정 높이를 사용하지 마세요\n\n다음 코드를 살펴보세요:\n\n```js\n          //DON'T\n          SizedBox(\n            height: 100,\n            child: Card(\n              child: Center(\n                child: Column(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: [\n                    Text(\"Title\", style: TextStyle(fontSize: 30), maxLines: 1),\n                    Text(\"Subtitle\", maxLines: 1),\n                  ],\n                ),\n              ),\n            ),\n          ),\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제가 발생할 수 있습니다.\n\n예상하신 대로, 텍스트 크기를 키우면 SizedBox의 내용이 너무 많은 공간을 차지할 수 있습니다.\n\n![image](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_1.png)\n\n컨텐츠 높이 및 패딩에 기반한 아이템의 높이를 만드는 것이 더 좋습니다. 게다가 ConstrainedBox를 사용하여 최소 높이를 설정할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nConstrainedBox(\n  constraints: const BoxConstraints(minHeight: 100),\n  child: const Card(\n    child: Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(\"Title\", style: TextStyle(fontSize: 30), maxLines: 1),\n          Text(\"Subtitle\", maxLines: 1),\n        ],\n      ),\n    ),\n  ),\n),\n```\n\n결과적으로 100% 배율에서 동일한 레이아웃을 얻고, 160%에서도 유효한 레이아웃을 얻을 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_2.png\" /\u003e\n\nListView에도 동일한 사항이 적용됩니다. itemExtent를 사용하는 경우, 폰트 스케일을 고려하여 계산하거나 prototypeItem을 제공하는 것이 좋습니다. 이에 대해 자세히 설명된 내용은 이 기사에서 확인할 수 있습니다.\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n계속 진행해 봅시다. 다음 레이아웃을 상상해보세요:\n\n![Image1](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_3.png)\n\n아이템 A는 이전 예시에서 나왔어요. 아이템 B는 약간의 간격을 가지고 있고 텍스트 확대에 대응할 수 있어야해요. 화면 하단에는 충분한 공간이 있어요. 그래서 어떤 문제가 발생할 수 있을까요?\n\n![Image2](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n화면이 작은 폰들도 고려해주세요. 또한, 언어를 바꿀 때 텍스트 길이가 달라질 수 있어요.\n\n## 컨텐츠를 스크롤할 수 있도록 만들기\n\n먼저, 모든 컨텐츠에 접근 가능하도록 오버플로우를 제거해야 해요. 간단한 SingleChildScrollView를 추가하면 이 문제를 해결할 수 있어요.\n\n## 마진과 패딩에 대해 적응적인 값을 사용하는 것을 고려해보세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 논란이 될 수 있는 방법일 수 있지만, 자신이 더 큰 글꼴을 사용해야 하는 사용자로 상상해보세요. 사용되지 않는 공간을 많이 보고 싶으신가요 아니면 텍스트를 명확하게 읽고 싶으신가요?\n\n텍스트를 표시하는 논리적 픽셀의 수에 따라 값들을 사용해봅시다. smallScreenThreshold를 응용 프로그램에 가장 적합한 값으로 조절할 수 있습니다.\n\n```js\nclass Dimens {\n  static const smallScreenThreshold = 300;\n  static bool isSmallWidth(BuildContext context) {\n    return MediaQuery.of(context).size.width /\n            MediaQuery.textScalerOf(context).scale(1) \u003c\n        smallScreenThreshold;\n  }\n\n  static double small(BuildContext context) =\u003e isSmallWidth(context) ? 4 : 8;\n  static double medium(BuildContext context) =\u003e isSmallWidth(context) ? 8 : 16;\n  static double large(BuildContext context) =\u003e isSmallWidth(context) ? 16 : 32;\n}\n```\n\n만약 Human Interface Guidelines와 Material Design을 따르고 싶다면, 이 값들은 4로 나눌 수 있는 값이어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 Dimens에 기반하여 간격에 대한 클래스를 만들 수 있습니다:\n\n```js\nclass Insets {\n  static EdgeInsets small(BuildContext context) =\u003e\n      EdgeInsets.all(Dimens.small(context));\n      \n  static EdgeInsets medium(BuildContext context) =\u003e\n      EdgeInsets.all(Dimens.medium(context));\n\n  static EdgeInsets large(BuildContext context) =\u003e\n      EdgeInsets.all(Dimens.large(context));\n}\n```\n\n그리고 코드에서 다음과 같이 대체합니다:\n\n```js\n//padding: const EdgeInsets.all(16),\npadding: Insets.medium(context),\n\n//SizedBox(height: 16),\nSizedBox(height: Dimens.medium(context)),\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과적으로 화면에 텍스트를 그릴 수 있는 공간이 조금 더 확보되었습니다:\n\n![이미지](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_5.png)\n\n## 제목의 텍스트 크기 확장을 제한하세요\n\n글꼴 크기를 크게 하는 주된 목적은 시력이 약해진 사람들에게 콘텐츠를 가독성 있게 만드는 것입니다. 그러나 제목과 같은 앱의 일부는 이미 글꼴이 크기 때문에 접근성이 좋을 수 있습니다. 이를 해결하기 위해 텍스트가 확대될 수 있는 범위를 제한할 수 있습니다. 이를 달성하는 한 가지 방법은 제목용 사용자 정의 위젯을 만드는 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass TitleText extends StatelessWidget {\n  final String text;\n  final TextStyle style;\n\n  const TitleText(this.text, {required this.style, super.key});\n\n  static const double maxRealFontSize = 30;\n\n  @override\n  Widget build(BuildContext context) {\n    if (MediaQuery.textScalerOf(context).scale(style.fontSize!) \u003e\n        maxRealFontSize) {\n      return Text(\n        text,\n        style: style.copyWith(\n          fontSize: maxRealFontSize / MediaQuery.textScalerOf(context).scale(1),\n        ),\n      );\n    }\n    return Text(text, style: style);\n  }\n}\n```\n\n이렇게 하면 가독성을 유지하면서 공간을 더 확보할 수 있어요. 앱에 더 적합한 값으로 maxRealFontSize를 변경할 수 있어요.\n\n\u003cimg src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_6.png\" /\u003e\n\n## 최대 줄 수 및 텍스트 오버플로우 지정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n큰 화면에서 일반적인 텍스트 스케일로 보기 좋을 수도 있지만, 다른 조건에서는 수직 공간을 더 많이 차지할 수 있음을 잊지 마세요. 그러나 제목(Subtitle)과 같은 곳은 항상 전체 내용을 표시할 필요가 없습니다. Text 위젯에 maxLines 값을 추가하여 원하는 줄 수로 설정할 수 있습니다.\n\n\n![Properly handling text scaling in Flutter](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_7.png) \n\n\n1로 설정된 maxLines로 보기 좋네요. 주요 정보는 여전히 잘 보입니다.\n\n## 문자열의 대안 버전 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 항상 유용한 정보를 포함하는 방식으로 문자열을 줄이는 것이 가능한 것은 아닙니다. 게다가, 단어 순서는 다른 언어들에서 다르게 변할 수 있습니다. 영어에서의 첫 번째 단어가 다른 언어에서는 문장의 끝에 올 수도 있습니다. 이번에는 국제화(i18n) 문자열을 고려해보는 것이 중요합니다:\n\n```js\n        \"tasksDone\": {\n            \"one\": \"할 일 중 $completed 개 완료\",\n            \"other\": \"할 일 중 $completed 개 완료\"\n        },\n        \"tasksDoneShort\": {\n            \"one\": \"$completed/$n 작업 완료\",\n            \"other\": \"$completed/$n 작업 완료\"\n        },\n```\n\n가장 의미 있는 부분은 숫자를 나타낸 부분입니다. 더 짧은 버전에서 숫자를 앞에 두고 전체 문자열을 더 짧게 만들었습니다. 코드에서는 다음과 같이 사용할 수 있습니다:\n\n```js\n        Text(\n          Dimens.isSmallWidth(context)\n              ? t.tasksDoneShort(n: 10, completed: 5)\n              : t.tasksDone(n: 10, completed: 5),\n          maxLines: 1,\n        )\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Screenshot](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_8.png)\n\n스크린샷을 보시면, 단축된 버전을 사용하면 필요한 정보를 보여주는 데 도움이 됩니다.\n\n이 기사가 유용하게 느껴졌으면 좋겠네요. 더 유용한 기술을 찾으면 업데이트할 예정입니다. 코드는 이 저장소에서 찾을 수 있습니다.\n\n![Screenshot](/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_9.png)","ogImage":{"url":"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png"},"coverImage":"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이 튜토리얼은 가장 쉽고 영향력이 큰 해결책을 먼저 제시하도록 구성되어 있어요. 후속 섹션에는 구현이 어려우면서 전반적인 영향이 더 낮은 해결책들이 포함되어 있지만, 특정 경우에 대응하기 위해 유용해요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e텍스트 스케일링 가능 범위 제한\u003c/h2\u003e\n\u003cp\u003eMaterialApp에 최소 및 최대 스케일 팩터를 설정할 수 있어요. 이렇게 하면 모든 텍스트가 지정한 범위 내에서 스케일링된다는 것을 보장할 수 있어요. 더 빈번한 경계는 가독성과 미적 감각을 유지하는 데 덜 노력이 필요해요. 그러나 경계 선택은 대상 사용자에 따라 달라져야 해요. 예를 들어 노인 사용자를 대상으로 한 앱의 경우, 그들의 요구를 수용하기 위해 더 넓은 범위를 사용하는 것을 고려해야 해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    \u003cspan class=\"hljs-title class_\"\u003eMaterialApp\u003c/span\u003e(\n      ...\n      \u003cspan class=\"hljs-attr\"\u003ebuilder\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e_, child\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMediaQuery\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMediaQuery\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(context).\u003cspan class=\"hljs-title function_\"\u003ecopyWith\u003c/span\u003e(\n          \u003cspan class=\"hljs-attr\"\u003etextScaler\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMediaQuery\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(context)\n              .\u003cspan class=\"hljs-property\"\u003etextScaler\u003c/span\u003e\n              .\u003cspan class=\"hljs-title function_\"\u003eclamp\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eminScaleFactor\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.8\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emaxScaleFactor\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1.6\u003c/span\u003e),\n        ),\n        \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: child!,\n      ),\n    );\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e텍스트를 포함하는 요소에 고정 높이를 사용하지 마세요\u003c/h2\u003e\n\u003cp\u003e다음 코드를 살펴보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e          \u003cspan class=\"hljs-comment\"\u003e//DON'T\u003c/span\u003e\n          \u003cspan class=\"hljs-title class_\"\u003eSizedBox\u003c/span\u003e(\n            \u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCard\u003c/span\u003e(\n              \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCenter\u003c/span\u003e(\n                \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(\n                  \u003cspan class=\"hljs-attr\"\u003emainAxisAlignment\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMainAxisAlignment\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecenter\u003c/span\u003e,\n                  \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [\n                    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Title\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eTextStyle\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efontSize\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e), \u003cspan class=\"hljs-attr\"\u003emaxLines\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),\n                    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Subtitle\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emaxLines\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),\n                  ],\n                ),\n              ),\n            ),\n          ),\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e문제가 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예상하신 대로, 텍스트 크기를 키우면 SizedBox의 내용이 너무 많은 공간을 차지할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e컨텐츠 높이 및 패딩에 기반한 아이템의 높이를 만드는 것이 더 좋습니다. 게다가 ConstrainedBox를 사용하여 최소 높이를 설정할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003eConstrainedBox(\n  constraints: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e BoxConstraints(minHeight: \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e),\n  child: \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e Card(\n    child: Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Text(\u003cspan class=\"hljs-string\"\u003e\"Title\"\u003c/span\u003e, style: TextStyle(fontSize: \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e), maxLines: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),\n          Text(\u003cspan class=\"hljs-string\"\u003e\"Subtitle\"\u003c/span\u003e, maxLines: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),\n        ],\n      ),\n    ),\n  ),\n),\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과적으로 100% 배율에서 동일한 레이아웃을 얻고, 160%에서도 유효한 레이아웃을 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003eListView에도 동일한 사항이 적용됩니다. itemExtent를 사용하는 경우, 폰트 스케일을 고려하여 계산하거나 prototypeItem을 제공하는 것이 좋습니다. 이에 대해 자세히 설명된 내용은 이 기사에서 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e계속 진행해 봅시다. 다음 레이아웃을 상상해보세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_3.png\" alt=\"Image1\"\u003e\u003c/p\u003e\n\u003cp\u003e아이템 A는 이전 예시에서 나왔어요. 아이템 B는 약간의 간격을 가지고 있고 텍스트 확대에 대응할 수 있어야해요. 화면 하단에는 충분한 공간이 있어요. 그래서 어떤 문제가 발생할 수 있을까요?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_4.png\" alt=\"Image2\"\u003e\u003c/p\u003e\n\u003cp\u003e화면이 작은 폰들도 고려해주세요. 또한, 언어를 바꿀 때 텍스트 길이가 달라질 수 있어요.\u003c/p\u003e\n\u003ch2\u003e컨텐츠를 스크롤할 수 있도록 만들기\u003c/h2\u003e\n\u003cp\u003e먼저, 모든 컨텐츠에 접근 가능하도록 오버플로우를 제거해야 해요. 간단한 SingleChildScrollView를 추가하면 이 문제를 해결할 수 있어요.\u003c/p\u003e\n\u003ch2\u003e마진과 패딩에 대해 적응적인 값을 사용하는 것을 고려해보세요\u003c/h2\u003e\n\u003cp\u003e이것은 논란이 될 수 있는 방법일 수 있지만, 자신이 더 큰 글꼴을 사용해야 하는 사용자로 상상해보세요. 사용되지 않는 공간을 많이 보고 싶으신가요 아니면 텍스트를 명확하게 읽고 싶으신가요?\u003c/p\u003e\n\u003cp\u003e텍스트를 표시하는 논리적 픽셀의 수에 따라 값들을 사용해봅시다. smallScreenThreshold를 응용 프로그램에 가장 적합한 값으로 조절할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDimens\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e smallScreenThreshold = \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e bool \u003cspan class=\"hljs-title function_\"\u003eisSmallWidth\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBuildContext context\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMediaQuery\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(context).\u003cspan class=\"hljs-property\"\u003esize\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e /\n            \u003cspan class=\"hljs-title class_\"\u003eMediaQuery\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etextScalerOf\u003c/span\u003e(context).\u003cspan class=\"hljs-title function_\"\u003escale\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u0026#x3C;\n        smallScreenThreshold;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e double \u003cspan class=\"hljs-title function_\"\u003esmall\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBuildContext\u003c/span\u003e context) =\u003e \u003cspan class=\"hljs-title function_\"\u003eisSmallWidth\u003c/span\u003e(context) ? \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e : \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e double \u003cspan class=\"hljs-title function_\"\u003emedium\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBuildContext\u003c/span\u003e context) =\u003e \u003cspan class=\"hljs-title function_\"\u003eisSmallWidth\u003c/span\u003e(context) ? \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e : \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e double \u003cspan class=\"hljs-title function_\"\u003elarge\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBuildContext\u003c/span\u003e context) =\u003e \u003cspan class=\"hljs-title function_\"\u003eisSmallWidth\u003c/span\u003e(context) ? \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e : \u003cspan class=\"hljs-number\"\u003e32\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 Human Interface Guidelines와 Material Design을 따르고 싶다면, 이 값들은 4로 나눌 수 있는 값이어야 합니다.\u003c/p\u003e\n\u003cp\u003e이러한 Dimens에 기반하여 간격에 대한 클래스를 만들 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInsets\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEdgeInsets\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esmall\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBuildContext\u003c/span\u003e context) =\u003e\n      \u003cspan class=\"hljs-title class_\"\u003eEdgeInsets\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDimens\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esmall\u003c/span\u003e(context));\n      \n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEdgeInsets\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emedium\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBuildContext\u003c/span\u003e context) =\u003e\n      \u003cspan class=\"hljs-title class_\"\u003eEdgeInsets\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDimens\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emedium\u003c/span\u003e(context));\n\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEdgeInsets\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elarge\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBuildContext\u003c/span\u003e context) =\u003e\n      \u003cspan class=\"hljs-title class_\"\u003eEdgeInsets\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDimens\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elarge\u003c/span\u003e(context));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 코드에서 다음과 같이 대체합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//padding: const EdgeInsets.all(16),\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003epadding\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInsets\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emedium\u003c/span\u003e(context),\n\n\u003cspan class=\"hljs-comment\"\u003e//SizedBox(height: 16),\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eSizedBox\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDimens\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emedium\u003c/span\u003e(context)),\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e결과적으로 화면에 텍스트를 그릴 수 있는 공간이 조금 더 확보되었습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e제목의 텍스트 크기 확장을 제한하세요\u003c/h2\u003e\n\u003cp\u003e글꼴 크기를 크게 하는 주된 목적은 시력이 약해진 사람들에게 콘텐츠를 가독성 있게 만드는 것입니다. 그러나 제목과 같은 앱의 일부는 이미 글꼴이 크기 때문에 접근성이 좋을 수 있습니다. 이를 해결하기 위해 텍스트가 확대될 수 있는 범위를 제한할 수 있습니다. 이를 달성하는 한 가지 방법은 제목용 사용자 정의 위젯을 만드는 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-dart\"\u003e\u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eTitleText\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eStatelessWidget\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e text;\n  \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e TextStyle style;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e TitleText(\u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.text, {\u003cspan class=\"hljs-keyword\"\u003erequired\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ethis\u003c/span\u003e.style, \u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.key});\n\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003edouble\u003c/span\u003e maxRealFontSize = \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-meta\"\u003e@override\u003c/span\u003e\n  Widget build(BuildContext context) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (MediaQuery.textScalerOf(context).scale(style.fontSize!) \u003e\n        maxRealFontSize) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Text(\n        text,\n        style: style.copyWith(\n          fontSize: maxRealFontSize / MediaQuery.textScalerOf(context).scale(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e),\n        ),\n      );\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Text(text, style: style);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 가독성을 유지하면서 공간을 더 확보할 수 있어요. 앱에 더 적합한 값으로 maxRealFontSize를 변경할 수 있어요.\u003c/p\u003e\n\u003ch2\u003e최대 줄 수 및 텍스트 오버플로우 지정하기\u003c/h2\u003e\n\u003cp\u003e큰 화면에서 일반적인 텍스트 스케일로 보기 좋을 수도 있지만, 다른 조건에서는 수직 공간을 더 많이 차지할 수 있음을 잊지 마세요. 그러나 제목(Subtitle)과 같은 곳은 항상 전체 내용을 표시할 필요가 없습니다. Text 위젯에 maxLines 값을 추가하여 원하는 줄 수로 설정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_7.png\" alt=\"Properly handling text scaling in Flutter\"\u003e\u003c/p\u003e\n\u003cp\u003e1로 설정된 maxLines로 보기 좋네요. 주요 정보는 여전히 잘 보입니다.\u003c/p\u003e\n\u003ch2\u003e문자열의 대안 버전 사용하기\u003c/h2\u003e\n\u003cp\u003e하지만 항상 유용한 정보를 포함하는 방식으로 문자열을 줄이는 것이 가능한 것은 아닙니다. 게다가, 단어 순서는 다른 언어들에서 다르게 변할 수 있습니다. 영어에서의 첫 번째 단어가 다른 언어에서는 문장의 끝에 올 수도 있습니다. 이번에는 국제화(i18n) 문자열을 고려해보는 것이 중요합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e        \u003cspan class=\"hljs-string\"\u003e\"tasksDone\"\u003c/span\u003e: {\n            \u003cspan class=\"hljs-string\"\u003e\"one\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"할 일 중 $completed 개 완료\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"other\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"할 일 중 $completed 개 완료\"\u003c/span\u003e\n        },\n        \u003cspan class=\"hljs-string\"\u003e\"tasksDoneShort\"\u003c/span\u003e: {\n            \u003cspan class=\"hljs-string\"\u003e\"one\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"$completed/$n 작업 완료\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"other\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"$completed/$n 작업 완료\"\u003c/span\u003e\n        },\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e가장 의미 있는 부분은 숫자를 나타낸 부분입니다. 더 짧은 버전에서 숫자를 앞에 두고 전체 문자열을 더 짧게 만들었습니다. 코드에서는 다음과 같이 사용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e        \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\n          \u003cspan class=\"hljs-title class_\"\u003eDimens\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisSmallWidth\u003c/span\u003e(context)\n              ? t.\u003cspan class=\"hljs-title function_\"\u003etasksDoneShort\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003en\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecompleted\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\n              : t.\u003cspan class=\"hljs-title function_\"\u003etasksDone\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003en\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecompleted\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e),\n          \u003cspan class=\"hljs-attr\"\u003emaxLines\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n        )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_8.png\" alt=\"Screenshot\"\u003e\u003c/p\u003e\n\u003cp\u003e스크린샷을 보시면, 단축된 버전을 사용하면 필요한 정보를 보여주는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e이 기사가 유용하게 느껴졌으면 좋겠네요. 더 유용한 기술을 찾으면 업데이트할 예정입니다. 코드는 이 저장소에서 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-ProperlyhandlingtextscalinginFlutter_9.png\" alt=\"Screenshot\"\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-ProperlyhandlingtextscalinginFlutter"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>