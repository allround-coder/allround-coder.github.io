<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>API 응답에 TypeScript 유형을 올바르게 사용하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="API 응답에 TypeScript 유형을 올바르게 사용하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="API 응답에 TypeScript 유형을 올바르게 사용하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse" data-gatsby-head="true"/><meta name="twitter:title" content="API 응답에 TypeScript 유형을 올바르게 사용하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 15:14" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">API 응답에 TypeScript 유형을 올바르게 사용하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="API 응답에 TypeScript 유형을 올바르게 사용하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><h2>JSON 응답을 받을 때 올바른 타입을 보장받을 수 없습니다. 물론 형 변환을 수행하고 모든 것이 괜찮다고 가정할 수 있지만, 이 상황에서 정말로 타입 안전한 방법을 알고 계신가요?</h2>
<p><img src="/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png" alt="How to correctly use TypeScript types for your API response"/></p>
<p>조금 더 일반적인 주제부터 시작해봅시다. 우리는 어떻게 타입을 확인할 수 있을까요? 두 가지 접근 방식이 있습니다. 정적으로 타입을 확인할 수 있습니다(컴파일 시간, 정적 분석기) 또는 런타임에서 확인할 수 있습니다.</p>
<p>정적 타입 확인은 우리가 미리 데이터를 알고 있다는 경우에는 충분히 강력합니다. 그러나 대부분의 상황에서는 해당되지 않습니다. 데이터는 대개 API, 파일 또는 사용자 입력과 같은 소스에서 가져옵니다. 이러한 소스의 인터페이스는 문자열을 반환하며, 우리의 책임은 그것을 우리 프로그램에서 기대하는 형태로 파싱하는 것입니다.</p>
<p>100% 유형 안전성을 위해 실행 시 데이터를 분석해야 합니다. 대부분의 유형 안전성 언어는 정적 유형 확인을 실행 시 확인과 결합합니다. 하지만 TypeScript의 경우는 어떨까요?</p>
<p>TypeScript는 컴파일 시에만 유형을 확인합니다. JavaScritp로 컴파일된 후에는 유형에 대한 정보가 남지 않으므로 우리가 동적 데이터(예: API 응답)가 가정한 형식을 실제로 갖고 있는지 확신할 수 없습니다.</p>
<h1>예시 시간</h1>
<p>이러한 동작을 설명하는 가장 좋은 방법은 예시를 통해 보여주는 것입니다. 다음 예시는 API에서 데이터를 가져오는 일반적인 상황을 보여줍니다.</p>
<p>우리가 처음에 마주한 문제는 코드 완성 기능의 부재였습니다. TypeScript를 사용하고 있기 때문에 쉽게 해결할 수 있어요. 우리가 기대하는 응답에 대한 타입을 정의해주면 되죠.</p>
<p>이제는 타입 캐스팅을 사용하여 코드 완성기능을 사용할 수 있게 되었어요.</p>
<p>이제 우리는 끝났다고 생각할 수 있지만, 여전히 코드를 개선할 수 있는 부분이 있습니다. fetchData 함수의 반환 타입 any는 최선의 방법이 아닙니다. 이를 Article로 변경할 수 있지만, 그렇게 하면 함수가 특정 반환 타입에 의존하게 되어버립니다. 이 경우에 이상적인 해결책은 제네릭을 사용하는 것이에요.</p>
<p>이 방법을 통해 typecast (as Article)를 삭제할 수도 있습니다.</p>
<p>지금 우리 코드가 멋지게 보이고 함수 fetchData를 다른 엔드포인트에도 사용할 수 있게 되었어요. 그런데 만약 API 응답이 우리 코드에 정의된 타입과 일치하지 않으면 어떻게 될까요? 우리의 타입 시스템이 그것에 대해 경고를 해줄까요? 답은 NO에요. 제가 소개에서 말했듯이, TypeScript에서 런타임에는 타입 체크가 없어요.</p>
<h1>런타임에서 타입을 확인하는 방법은?</h1>
<p>TS에서는 리플렉션을 지원하지 않기 때문에 수동으로 처리해야 해요. string이나 number와 같은 기본 타입을 위해서는 쉬워요. 간단한 if 문을 작성하고 끝이에요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> myVariable === <span class="hljs-string">&#x27;number&#x27;</span>) {
  <span class="hljs-comment">// 우리 작업을 해요</span>
}
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> myVariable === <span class="hljs-string">&#x27;string&#x27;</span>) {
  <span class="hljs-comment">// 우리 작업을 해요</span>
}
</code></pre>
<p>하지만 객체들은 훨씬 복잡합니다. 변수가 객체인지 확인하고, null을 체크하고, 각 속성에 대해 객체 내에서 존재하는지 확인하고 별도의 유형 체크를 해야 합니다.
우리의 Article에 대한 적절한 제어는 다음과 같이 보일 것입니다.</p>
<p>더 복잡하거나 심지어 중첩된 객체에 대해 이겨내야 한다고 상상할 수 있나요? 그걸 하기는 정말 괴로운 아이디어이고, 너무나도 오류가 발생하기 쉽습니다. 그렇다면 어떻게 하면서 다른 부분을 망치치 않을 수 있을까요?</p>
<h2>타입 가드</h2>
<p>한 가지 가능한 해결책은 타입 가드를 생성하는 것입니다. 타입 가드는 보통 함수들이지만 함수의 시그니처가 TS에게 함수의 매개변수가 특정 유형을 가지고 있음을 알려줍니다. 시그니처는 두 가지로 구성됩니다. 함수는 boolean을 반환해야 하며 반환 형식은 param is myType이어야 합니다.
다음 예제는 타입 가드가 어떻게 사용되는지를 보여줍니다.</p>
<p>이전 예제의 if 문과 마찬가지로 타입 가드의 구현을 볼 수 있습니다. 유용한 해결책은 이러한 타입 가드를 생성하는 것일 것입니다. 그러나 이것 또한 많은 단점을 가지고 있습니다. 내가 보기에, 이전 예제와 동일한 문제들 외에 가장 큰 문제는 타입 정의와의 동기화입니다.</p>
<h1>런타임 타입에서 TS 타입 추론하기</h1>
<p>수동 접근 방법은 널리 사용하기에는 충분히 실용적이지 않다는 것을 보았습니다. 진짜 열쇠는 typeof 연산자에 숨겨져 있습니다. 우리는 런타임 타입에서 TS 타입을 추론하는 데 이것을 사용할 수 있습니다.</p>
<p>타입을 추론하는 기술 중 하나는 타입 가드의 사용입니다. 실제로 위의 예제에서 이를 보았습니다.</p>
<p>두 번째로 비슷한 방법은 단언 함수를 사용하는 것입니다. 이러한 함수들은 부울 대신에 매개변수 유형이 잘못된 경우 오류를 throw합니다.</p>
<p>이 방법의 장점 중 하나는 예외와 관련된 메시지가 있어 문제가 발생한 위치를 알 수 있다는 것입니다. 또한 함수를 호출할 때 조건을 작성할 필요가 없습니다. 그러나 그러한 함수의 반환 유형은 void 여야 하며 나중에 보게 될 것처럼 다른 것을 반환하는 것이 유용할 수 있습니다.</p>
<h2>기능적 접근</h2>
<p>Either를 사용하여 유형 검사 함수를 사용할 수 있습니다.</p>
<p>이제는 이렇게 할 수도 있다는 것을 언급하고 싶어요. 이 개념에 익숙하지 않다면 걱정할 필요 없이 계속 읽어주세요.</p>
<h2>기본 타입에 대한 최소 구현</h2>
<p>비기능적인 방법은 예외를 사용하고 타입이 올바른 경우 입력 매개변수를 반환하는 것입니다. 기본 타입에 대한 최소 구현은 다음과 같이 보일 수 있습니다.</p>
<p>이러한 예는 간단하며 설명이 거의 필요하지 않습니다. TypeGuard<code>T</code> 타입은 이러한 함수의 타입이며 이후의 예제에서 더 널리 사용될 것입니다.</p>
<p>이 기능은 배열의 모든 항목이 내부 유형 가드로 강제되는지 확인합니다.</p>
<p>여기서 보여줄 가드 중에서 가장 복잡한 것입니다. 가드 객체를 인수로 사용하여 해당 객체의 모든 속성이 올바른 유형인지 확인하는 함수를 반환합니다.</p>
<h2>사용법</h2>
<p>위의 함수들은 매우 간단하게 사용할 수 있습니다.</p>
<p>일반적인 타입 정의 구문과 유사하지만 이제 우리는 런타임 세계에 저장된 타입을 가지게 되었어요. 그리고 앞서 언급했듯이 런타임에서 타입 세계로 정보를 쉽게 얻을 수 있어요. typeof 연산자를 사용하면 끝이에요.</p>
<pre><code class="hljs language-js">type <span class="hljs-title class_">Article</span> = <span class="hljs-title class_">ReturnType</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Article</span>&gt;
</code></pre>
<p>타입에 동일한 이름을 사용할 수도 있어요.</p>
<h1>데이터를 가져오는 안전한 방법</h1>
<p>우리가 보여준 기술을 사용해서 원래 예제를 리팩토링할 수 있어요.</p>
<p>그게 그냥 이렇게 간단해요.</p>
<h1>새로운 타입의 슈퍼파워</h1>
<p>타입 가드는 어떤 함수든 될 수 있어요. 이것은 당신이 원하는 대로 타입을 정의할 수 있다는 걸 의미해요. 항상 짝수인 타입을 가지고 싶다고 상상해보세요. 문제없어요. 당신의 가드만 정의하면 됩니다.</p>
<p>여기서의 한계는 단지 당신의 상상력뿐이지만, 몇 가지 엉뚱한 유형을 만들 때 조심하는 것이 좋습니다.</p>
<h1>결론</h1>
<p>외부 소스로부터 데이터를 다룰 때는 해당 데이터가 올바른 유형을 가지고 있는지 100% 확신할 수 없습니다. 우리는 TypeScript 유형을 정의하고, 변수를 유형으로 캐스팅하여 모든 것이 작동할 것을 기대할 수 있습니다. 하지만 그것은 단지 희망일 뿐입니다. 우리는 런타임에서 유형을 확인할 방법이 필요하지만 TS에는 이를 위한 세련된 내장 도구가 없습니다. 수동 유형 가드를 작성할 수 있지만 많은 단점이 있습니다. 유형 정의와 유형 가드를 동기화할 필요를 없애기 위해 먼저 유형 가드를 정의하고 typeof 연산자를 사용하여 런타임 정의에서 TS 유형을 추론할 수 있습니다.</p>
<h1>라이브러리</h1>
<p>이 글에서 소개된 것보다 더 견고한 해결책을 찾고 있다면 다음과 같은 기능을 제공하는 몇 가지 라이브러리가 있습니다.</p>
<ul>
<li>IO-ts - 함수형 라이브러리</li>
<li>Zod</li>
<li>Runtypes</li>
<li>여기서 더 많은 정보를 얻을 수 있습니다.</li>
</ul>
<p>오늘 제가 가진 것은 여기까지입니다. 도움이 되었기를 바랍니다. 읽어 주셔서 감사합니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"API 응답에 TypeScript 유형을 올바르게 사용하는 방법","description":"","date":"2024-05-14 15:14","slug":"2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse","content":"\n\n## JSON 응답을 받을 때 올바른 타입을 보장받을 수 없습니다. 물론 형 변환을 수행하고 모든 것이 괜찮다고 가정할 수 있지만, 이 상황에서 정말로 타입 안전한 방법을 알고 계신가요?\n\n![How to correctly use TypeScript types for your API response](/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png)\n\n조금 더 일반적인 주제부터 시작해봅시다. 우리는 어떻게 타입을 확인할 수 있을까요? 두 가지 접근 방식이 있습니다. 정적으로 타입을 확인할 수 있습니다(컴파일 시간, 정적 분석기) 또는 런타임에서 확인할 수 있습니다.\n\n정적 타입 확인은 우리가 미리 데이터를 알고 있다는 경우에는 충분히 강력합니다. 그러나 대부분의 상황에서는 해당되지 않습니다. 데이터는 대개 API, 파일 또는 사용자 입력과 같은 소스에서 가져옵니다. 이러한 소스의 인터페이스는 문자열을 반환하며, 우리의 책임은 그것을 우리 프로그램에서 기대하는 형태로 파싱하는 것입니다.\n\n\n\n100% 유형 안전성을 위해 실행 시 데이터를 분석해야 합니다. 대부분의 유형 안전성 언어는 정적 유형 확인을 실행 시 확인과 결합합니다. 하지만 TypeScript의 경우는 어떨까요?\n\nTypeScript는 컴파일 시에만 유형을 확인합니다. JavaScritp로 컴파일된 후에는 유형에 대한 정보가 남지 않으므로 우리가 동적 데이터(예: API 응답)가 가정한 형식을 실제로 갖고 있는지 확신할 수 없습니다.\n\n# 예시 시간\n\n이러한 동작을 설명하는 가장 좋은 방법은 예시를 통해 보여주는 것입니다. 다음 예시는 API에서 데이터를 가져오는 일반적인 상황을 보여줍니다.\n\n\n\n우리가 처음에 마주한 문제는 코드 완성 기능의 부재였습니다. TypeScript를 사용하고 있기 때문에 쉽게 해결할 수 있어요. 우리가 기대하는 응답에 대한 타입을 정의해주면 되죠.\n\n이제는 타입 캐스팅을 사용하여 코드 완성기능을 사용할 수 있게 되었어요.\n\n이제 우리는 끝났다고 생각할 수 있지만, 여전히 코드를 개선할 수 있는 부분이 있습니다. fetchData 함수의 반환 타입 any는 최선의 방법이 아닙니다. 이를 Article로 변경할 수 있지만, 그렇게 하면 함수가 특정 반환 타입에 의존하게 되어버립니다. 이 경우에 이상적인 해결책은 제네릭을 사용하는 것이에요.\n\n이 방법을 통해 typecast (as Article)를 삭제할 수도 있습니다.\n\n\n\n지금 우리 코드가 멋지게 보이고 함수 fetchData를 다른 엔드포인트에도 사용할 수 있게 되었어요. 그런데 만약 API 응답이 우리 코드에 정의된 타입과 일치하지 않으면 어떻게 될까요? 우리의 타입 시스템이 그것에 대해 경고를 해줄까요? 답은 NO에요. 제가 소개에서 말했듯이, TypeScript에서 런타임에는 타입 체크가 없어요.\n\n# 런타임에서 타입을 확인하는 방법은?\n\nTS에서는 리플렉션을 지원하지 않기 때문에 수동으로 처리해야 해요. string이나 number와 같은 기본 타입을 위해서는 쉬워요. 간단한 if 문을 작성하고 끝이에요.\n\n```js\nif (typeof myVariable === 'number') {\n  // 우리 작업을 해요\n}\nif (typeof myVariable === 'string') {\n  // 우리 작업을 해요\n}\n```\n\n\n\n하지만 객체들은 훨씬 복잡합니다. 변수가 객체인지 확인하고, null을 체크하고, 각 속성에 대해 객체 내에서 존재하는지 확인하고 별도의 유형 체크를 해야 합니다.\n우리의 Article에 대한 적절한 제어는 다음과 같이 보일 것입니다.\n\n더 복잡하거나 심지어 중첩된 객체에 대해 이겨내야 한다고 상상할 수 있나요? 그걸 하기는 정말 괴로운 아이디어이고, 너무나도 오류가 발생하기 쉽습니다. 그렇다면 어떻게 하면서 다른 부분을 망치치 않을 수 있을까요?\n\n## 타입 가드\n\n한 가지 가능한 해결책은 타입 가드를 생성하는 것입니다. 타입 가드는 보통 함수들이지만 함수의 시그니처가 TS에게 함수의 매개변수가 특정 유형을 가지고 있음을 알려줍니다. 시그니처는 두 가지로 구성됩니다. 함수는 boolean을 반환해야 하며 반환 형식은 param is myType이어야 합니다.\n다음 예제는 타입 가드가 어떻게 사용되는지를 보여줍니다.\n\n\n\n이전 예제의 if 문과 마찬가지로 타입 가드의 구현을 볼 수 있습니다. 유용한 해결책은 이러한 타입 가드를 생성하는 것일 것입니다. 그러나 이것 또한 많은 단점을 가지고 있습니다. 내가 보기에, 이전 예제와 동일한 문제들 외에 가장 큰 문제는 타입 정의와의 동기화입니다.\n\n# 런타임 타입에서 TS 타입 추론하기\n\n수동 접근 방법은 널리 사용하기에는 충분히 실용적이지 않다는 것을 보았습니다. 진짜 열쇠는 typeof 연산자에 숨겨져 있습니다. 우리는 런타임 타입에서 TS 타입을 추론하는 데 이것을 사용할 수 있습니다.\n\n타입을 추론하는 기술 중 하나는 타입 가드의 사용입니다. 실제로 위의 예제에서 이를 보았습니다.\n\n\n\n두 번째로 비슷한 방법은 단언 함수를 사용하는 것입니다. 이러한 함수들은 부울 대신에 매개변수 유형이 잘못된 경우 오류를 throw합니다.\n\n이 방법의 장점 중 하나는 예외와 관련된 메시지가 있어 문제가 발생한 위치를 알 수 있다는 것입니다. 또한 함수를 호출할 때 조건을 작성할 필요가 없습니다. 그러나 그러한 함수의 반환 유형은 void 여야 하며 나중에 보게 될 것처럼 다른 것을 반환하는 것이 유용할 수 있습니다.\n\n## 기능적 접근\n\nEither를 사용하여 유형 검사 함수를 사용할 수 있습니다.\n\n\n\n이제는 이렇게 할 수도 있다는 것을 언급하고 싶어요. 이 개념에 익숙하지 않다면 걱정할 필요 없이 계속 읽어주세요.\n\n## 기본 타입에 대한 최소 구현\n\n비기능적인 방법은 예외를 사용하고 타입이 올바른 경우 입력 매개변수를 반환하는 것입니다. 기본 타입에 대한 최소 구현은 다음과 같이 보일 수 있습니다.\n\n이러한 예는 간단하며 설명이 거의 필요하지 않습니다. TypeGuard`T` 타입은 이러한 함수의 타입이며 이후의 예제에서 더 널리 사용될 것입니다.\n\n\n\n이 기능은 배열의 모든 항목이 내부 유형 가드로 강제되는지 확인합니다.\n\n여기서 보여줄 가드 중에서 가장 복잡한 것입니다. 가드 객체를 인수로 사용하여 해당 객체의 모든 속성이 올바른 유형인지 확인하는 함수를 반환합니다.\n\n## 사용법\n\n위의 함수들은 매우 간단하게 사용할 수 있습니다.\n\n\n\n일반적인 타입 정의 구문과 유사하지만 이제 우리는 런타임 세계에 저장된 타입을 가지게 되었어요. 그리고 앞서 언급했듯이 런타임에서 타입 세계로 정보를 쉽게 얻을 수 있어요. typeof 연산자를 사용하면 끝이에요.\n\n```js\ntype Article = ReturnType\u003ctypeof Article\u003e\n```\n\n타입에 동일한 이름을 사용할 수도 있어요.\n\n# 데이터를 가져오는 안전한 방법\n\n\n\n우리가 보여준 기술을 사용해서 원래 예제를 리팩토링할 수 있어요.\n\n그게 그냥 이렇게 간단해요.\n\n# 새로운 타입의 슈퍼파워\n\n타입 가드는 어떤 함수든 될 수 있어요. 이것은 당신이 원하는 대로 타입을 정의할 수 있다는 걸 의미해요. 항상 짝수인 타입을 가지고 싶다고 상상해보세요. 문제없어요. 당신의 가드만 정의하면 됩니다.\n\n\n\n여기서의 한계는 단지 당신의 상상력뿐이지만, 몇 가지 엉뚱한 유형을 만들 때 조심하는 것이 좋습니다.\n\n# 결론\n\n외부 소스로부터 데이터를 다룰 때는 해당 데이터가 올바른 유형을 가지고 있는지 100% 확신할 수 없습니다. 우리는 TypeScript 유형을 정의하고, 변수를 유형으로 캐스팅하여 모든 것이 작동할 것을 기대할 수 있습니다. 하지만 그것은 단지 희망일 뿐입니다. 우리는 런타임에서 유형을 확인할 방법이 필요하지만 TS에는 이를 위한 세련된 내장 도구가 없습니다. 수동 유형 가드를 작성할 수 있지만 많은 단점이 있습니다. 유형 정의와 유형 가드를 동기화할 필요를 없애기 위해 먼저 유형 가드를 정의하고 typeof 연산자를 사용하여 런타임 정의에서 TS 유형을 추론할 수 있습니다.\n\n# 라이브러리\n\n\n\n이 글에서 소개된 것보다 더 견고한 해결책을 찾고 있다면 다음과 같은 기능을 제공하는 몇 가지 라이브러리가 있습니다.\n\n- IO-ts - 함수형 라이브러리\n- Zod\n- Runtypes\n- 여기서 더 많은 정보를 얻을 수 있습니다.\n\n오늘 제가 가진 것은 여기까지입니다. 도움이 되었기를 바랍니다. 읽어 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png"},"coverImage":"/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png","tag":["Tech"],"readingTime":5},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"JSON 응답을 받을 때 올바른 타입을 보장받을 수 없습니다. 물론 형 변환을 수행하고 모든 것이 괜찮다고 가정할 수 있지만, 이 상황에서 정말로 타입 안전한 방법을 알고 계신가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse_0.png\",\n        alt: \"How to correctly use TypeScript types for your API response\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"조금 더 일반적인 주제부터 시작해봅시다. 우리는 어떻게 타입을 확인할 수 있을까요? 두 가지 접근 방식이 있습니다. 정적으로 타입을 확인할 수 있습니다(컴파일 시간, 정적 분석기) 또는 런타임에서 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정적 타입 확인은 우리가 미리 데이터를 알고 있다는 경우에는 충분히 강력합니다. 그러나 대부분의 상황에서는 해당되지 않습니다. 데이터는 대개 API, 파일 또는 사용자 입력과 같은 소스에서 가져옵니다. 이러한 소스의 인터페이스는 문자열을 반환하며, 우리의 책임은 그것을 우리 프로그램에서 기대하는 형태로 파싱하는 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"100% 유형 안전성을 위해 실행 시 데이터를 분석해야 합니다. 대부분의 유형 안전성 언어는 정적 유형 확인을 실행 시 확인과 결합합니다. 하지만 TypeScript의 경우는 어떨까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TypeScript는 컴파일 시에만 유형을 확인합니다. JavaScritp로 컴파일된 후에는 유형에 대한 정보가 남지 않으므로 우리가 동적 데이터(예: API 응답)가 가정한 형식을 실제로 갖고 있는지 확신할 수 없습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"예시 시간\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 동작을 설명하는 가장 좋은 방법은 예시를 통해 보여주는 것입니다. 다음 예시는 API에서 데이터를 가져오는 일반적인 상황을 보여줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리가 처음에 마주한 문제는 코드 완성 기능의 부재였습니다. TypeScript를 사용하고 있기 때문에 쉽게 해결할 수 있어요. 우리가 기대하는 응답에 대한 타입을 정의해주면 되죠.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제는 타입 캐스팅을 사용하여 코드 완성기능을 사용할 수 있게 되었어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 우리는 끝났다고 생각할 수 있지만, 여전히 코드를 개선할 수 있는 부분이 있습니다. fetchData 함수의 반환 타입 any는 최선의 방법이 아닙니다. 이를 Article로 변경할 수 있지만, 그렇게 하면 함수가 특정 반환 타입에 의존하게 되어버립니다. 이 경우에 이상적인 해결책은 제네릭을 사용하는 것이에요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법을 통해 typecast (as Article)를 삭제할 수도 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금 우리 코드가 멋지게 보이고 함수 fetchData를 다른 엔드포인트에도 사용할 수 있게 되었어요. 그런데 만약 API 응답이 우리 코드에 정의된 타입과 일치하지 않으면 어떻게 될까요? 우리의 타입 시스템이 그것에 대해 경고를 해줄까요? 답은 NO에요. 제가 소개에서 말했듯이, TypeScript에서 런타임에는 타입 체크가 없어요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"런타임에서 타입을 확인하는 방법은?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TS에서는 리플렉션을 지원하지 않기 때문에 수동으로 처리해야 해요. string이나 number와 같은 기본 타입을 위해서는 쉬워요. 간단한 if 문을 작성하고 끝이에요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"typeof\"\n        }), \" myVariable === \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'number'\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 우리 작업을 해요\"\n        }), \"\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"typeof\"\n        }), \" myVariable === \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'string'\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 우리 작업을 해요\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 객체들은 훨씬 복잡합니다. 변수가 객체인지 확인하고, null을 체크하고, 각 속성에 대해 객체 내에서 존재하는지 확인하고 별도의 유형 체크를 해야 합니다.\\n우리의 Article에 대한 적절한 제어는 다음과 같이 보일 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"더 복잡하거나 심지어 중첩된 객체에 대해 이겨내야 한다고 상상할 수 있나요? 그걸 하기는 정말 괴로운 아이디어이고, 너무나도 오류가 발생하기 쉽습니다. 그렇다면 어떻게 하면서 다른 부분을 망치치 않을 수 있을까요?\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"타입 가드\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"한 가지 가능한 해결책은 타입 가드를 생성하는 것입니다. 타입 가드는 보통 함수들이지만 함수의 시그니처가 TS에게 함수의 매개변수가 특정 유형을 가지고 있음을 알려줍니다. 시그니처는 두 가지로 구성됩니다. 함수는 boolean을 반환해야 하며 반환 형식은 param is myType이어야 합니다.\\n다음 예제는 타입 가드가 어떻게 사용되는지를 보여줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이전 예제의 if 문과 마찬가지로 타입 가드의 구현을 볼 수 있습니다. 유용한 해결책은 이러한 타입 가드를 생성하는 것일 것입니다. 그러나 이것 또한 많은 단점을 가지고 있습니다. 내가 보기에, 이전 예제와 동일한 문제들 외에 가장 큰 문제는 타입 정의와의 동기화입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"런타임 타입에서 TS 타입 추론하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"수동 접근 방법은 널리 사용하기에는 충분히 실용적이지 않다는 것을 보았습니다. 진짜 열쇠는 typeof 연산자에 숨겨져 있습니다. 우리는 런타임 타입에서 TS 타입을 추론하는 데 이것을 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"타입을 추론하는 기술 중 하나는 타입 가드의 사용입니다. 실제로 위의 예제에서 이를 보았습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"두 번째로 비슷한 방법은 단언 함수를 사용하는 것입니다. 이러한 함수들은 부울 대신에 매개변수 유형이 잘못된 경우 오류를 throw합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법의 장점 중 하나는 예외와 관련된 메시지가 있어 문제가 발생한 위치를 알 수 있다는 것입니다. 또한 함수를 호출할 때 조건을 작성할 필요가 없습니다. 그러나 그러한 함수의 반환 유형은 void 여야 하며 나중에 보게 될 것처럼 다른 것을 반환하는 것이 유용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"기능적 접근\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Either를 사용하여 유형 검사 함수를 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제는 이렇게 할 수도 있다는 것을 언급하고 싶어요. 이 개념에 익숙하지 않다면 걱정할 필요 없이 계속 읽어주세요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"기본 타입에 대한 최소 구현\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"비기능적인 방법은 예외를 사용하고 타입이 올바른 경우 입력 매개변수를 반환하는 것입니다. 기본 타입에 대한 최소 구현은 다음과 같이 보일 수 있습니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"이러한 예는 간단하며 설명이 거의 필요하지 않습니다. TypeGuard\", _jsx(_components.code, {\n        children: \"T\"\n      }), \" 타입은 이러한 함수의 타입이며 이후의 예제에서 더 널리 사용될 것입니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기능은 배열의 모든 항목이 내부 유형 가드로 강제되는지 확인합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 보여줄 가드 중에서 가장 복잡한 것입니다. 가드 객체를 인수로 사용하여 해당 객체의 모든 속성이 올바른 유형인지 확인하는 함수를 반환합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"사용법\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 함수들은 매우 간단하게 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"일반적인 타입 정의 구문과 유사하지만 이제 우리는 런타임 세계에 저장된 타입을 가지게 되었어요. 그리고 앞서 언급했듯이 런타임에서 타입 세계로 정보를 쉽게 얻을 수 있어요. typeof 연산자를 사용하면 끝이에요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"type \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Article\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ReturnType\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"typeof\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Article\"\n        }), \"\u003e\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"타입에 동일한 이름을 사용할 수도 있어요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"데이터를 가져오는 안전한 방법\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리가 보여준 기술을 사용해서 원래 예제를 리팩토링할 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그게 그냥 이렇게 간단해요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"새로운 타입의 슈퍼파워\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"타입 가드는 어떤 함수든 될 수 있어요. 이것은 당신이 원하는 대로 타입을 정의할 수 있다는 걸 의미해요. 항상 짝수인 타입을 가지고 싶다고 상상해보세요. 문제없어요. 당신의 가드만 정의하면 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서의 한계는 단지 당신의 상상력뿐이지만, 몇 가지 엉뚱한 유형을 만들 때 조심하는 것이 좋습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"외부 소스로부터 데이터를 다룰 때는 해당 데이터가 올바른 유형을 가지고 있는지 100% 확신할 수 없습니다. 우리는 TypeScript 유형을 정의하고, 변수를 유형으로 캐스팅하여 모든 것이 작동할 것을 기대할 수 있습니다. 하지만 그것은 단지 희망일 뿐입니다. 우리는 런타임에서 유형을 확인할 방법이 필요하지만 TS에는 이를 위한 세련된 내장 도구가 없습니다. 수동 유형 가드를 작성할 수 있지만 많은 단점이 있습니다. 유형 정의와 유형 가드를 동기화할 필요를 없애기 위해 먼저 유형 가드를 정의하고 typeof 연산자를 사용하여 런타임 정의에서 TS 유형을 추론할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"라이브러리\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 글에서 소개된 것보다 더 견고한 해결책을 찾고 있다면 다음과 같은 기능을 제공하는 몇 가지 라이브러리가 있습니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"IO-ts - 함수형 라이브러리\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Zod\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Runtypes\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"여기서 더 많은 정보를 얻을 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오늘 제가 가진 것은 여기까지입니다. 도움이 되었기를 바랍니다. 읽어 주셔서 감사합니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-HowtocorrectlyuseTypeScripttypesforyourAPIresponse"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>