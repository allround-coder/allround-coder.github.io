<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트 라우터에서 경로 형성하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-FormingRoutesinReactRouter" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트 라우터에서 경로 형성하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트 라우터에서 경로 형성하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-FormingRoutesinReactRouter_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-FormingRoutesinReactRouter" data-gatsby-head="true"/><meta name="twitter:title" content="리액트 라우터에서 경로 형성하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-FormingRoutesinReactRouter_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 23:03" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트 라우터에서 경로 형성하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트 라우터에서 경로 형성하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-FormingRoutesinReactRouter&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-05-12-FormingRoutesinReactRouter_0.png">
<p>리액트는 웹 개발 세계를 뒤흔들 정도로 인기 있는 프런트엔드 자바스크립트 라이브러리입니다. 그 인기의 이유 중 하나는 컴포넌트 기반 접근 방식으로, 웹 페이지 UI가 여러 컴포넌트나 함수로 나뉘어 효율적이고 인터랙티브한 사용자 인터페이스를 만들어내기 때문입니다. 오픈 소스 라이브러리인 리액트는 개발자들에게 뛰어난 웹 응용프로그램을 만들 수 있는 무한한 가능성을 제공합니다. 이 글에서는 특정 패키지인 React Router 패키지에 초점을 맞추어 다룰 것인데, 이 패키지는 리액트 응용프로그램에서 URL 라우팅을 통해 여러 리액트 컴포넌트의 탐색을 처리할 수 있도록 합니다.</p>
<h1>시작하기 전에</h1>
<p>아래 내용은 Windows OS 환경에서 Visual Studio Code를 코드 편집기로 사용하여 React Router와 React를 사용하는 방법에 대한 상세한 가이드를 제공합니다. 예시는 React 버전 18.3과 React Router 버전 6.2를 기반으로 합니다. 그러나 세팅 과정에서 다른 점이 발견된다면, 설치된 패키지 버전을 확인하기 위해 package.json 파일을 확인하는 것이 좋습니다. 리액트와 리액트 라우터가 계속 발전함에 따라, 이 안내서의 코드는 오래되어질 수 있습니다. 리액트와 리액트 라우터는 자신들의 패키지의 최신 버전으로 업그레이드하기 위한 상세한 문서를 제공하고 있습니다.</p>
<h1>기본 설정</h1>
<p>시작하려면 기본적인 React 앱을 만들어야 합니다. 필요한 패키지를 수동으로 코딩하고 다운로드하는 방법도 있지만, React에서는 더 간단한 대안을 제공합니다. 먼저 터미널에서 앱을 저장할 디렉토리로 이동합니다. 그런 다음 해당 명령을 실행하세요.</p>
<pre><code class="hljs language-js">npx create-react-app your-app-name
</code></pre>
<p>이 명령은 항상 현재 React 버전이 설치되어 있는지 확인합니다. 그런 다음이 명령을 사용하여 앱으로 이동합니다:</p>
<pre><code class="hljs language-js">cd your-app-name
</code></pre>
<p>설정에 따라 오픈 명령이 다를 수 있습니다. 제가 사용하는 것은 Visual Studio Code에서 앱을 열기 위해 code . 입니다. 어떤 경우든 코드 편집 소프트웨어가 터미널에 연결되어 있는 것이 중요합니다. 기본적인 React 코딩 환경만 필요하다면 모두 준비된 상태입니다! 하지만 싱글 페이지 애플리케이션을 더욱 확장하고 싶다면 클라이언트 측 라우팅을 활용하여 효율적으로 만들 수 있습니다.</p>
<h1>클라이언트 측 라우팅이란?</h1>
<p>이 주제에 대해 자세히 설명하진 않겠지만, 기본 개념에 대해 간단히 설명해 드릴게요. 더 자세히 알고 싶다면 이와 같은 유용한 블로그 포스트와 같은 많은 자료들이 있습니다. 서버 측 라우팅에서는 웹페이지의 링크를 클릭할 때 라우팅이 발생하며 해당 링크 URL을 가집니다. 그러면 브라우저는 해당 특정 페이지에 대한 GET 요청을 서버에 생성하고 서버는 페이지를 그 URL 라우트로 채우기 위해 필요한 데이터로 응답합니다. 사용자가 경험하는 대부분의 버퍼링은 이 과정에서 생성된 GET 요청으로 인한 것입니다. 반면 클라이언트 측 라우팅은 이러한 방식과는 다릅니다. JavaScript를 통해 모든 라우팅을 처리하고 초기 로드 중에 모든 요청을 수행합니다. 이 기술에는 여러 장단점이 있지만, 대부분의 사용자가 빠른 속도를 경험하는 장점이 있습니다. 다음 단락에서는 React Router에 대해 살펴보며 이 라우팅 논리를 React 환경에서 사용하는 것이 훨씬 쉬워진 패키지에 대해 논의할 것입니다.</p>
<h1>React Router 설정하기</h1>
<p>React Router Dom의 도구를 사용하려면 먼저 React 애플리케이션에 설치해야 합니다. React 애플리케이션 내에서 아래 명령어를 실행해주세요:</p>
<pre><code class="hljs language-js">npm i react-router-dom
</code></pre>
<p>그런 다음 package.json 파일을 확인하고, 다음과 유사한 정보를 찾아보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//</span>
<span class="hljs-string">"dependencies"</span>: {
    <span class="hljs-string">"@testing-library/jest-dom"</span>: <span class="hljs-string">"^5.17.0"</span>,
    <span class="hljs-string">"@testing-library/react"</span>: <span class="hljs-string">"^13.4.0"</span>,
    <span class="hljs-string">"@testing-library/user-event"</span>: <span class="hljs-string">"^13.5.0"</span>,
    <span class="hljs-string">"react"</span>: <span class="hljs-string">"^18.3.1"</span>,
    <span class="hljs-string">"react-dom"</span>: <span class="hljs-string">"^18.3.1"</span>,
    <span class="hljs-string">"react-router-dom"</span>: <span class="hljs-string">"^6.23.0"</span>,
    <span class="hljs-string">"react-scripts"</span>: <span class="hljs-string">"5.0.1"</span>,
    <span class="hljs-string">"web-vitals"</span>: <span class="hljs-string">"^2.1.4"</span>
<span class="hljs-comment">//</span>
</code></pre>
<p>만약 React Router Dom 부분에서 버전이 v5 이상이면 모두 설정이 완료된 것입니다!</p>
<p>만약 앞에서 설명한대로 Create React App을 사용했다면, 아래 이미지는 코드 편집기에 따라 다를 수는 있지만 완전히 같아야 합니다.</p>
<img src="/assets/img/2024-05-12-FormingRoutesinReactRouter_1.png">
<p>지금은 React가 index.js 파일을 통해 App.js만 렌더링하고 있어요. 이 블로그를 만드는 목적을 완전히 무너뜨리고 있네요! 그래서 변경할게요. index.js 파일로 이동해서 필요한 변경사항을 해봐요.</p>
<p>원래 코드:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/client'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'./index.css'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;
<span class="hljs-keyword">import</span> reportWebVitals <span class="hljs-keyword">from</span> <span class="hljs-string">'./reportWebVitals'</span>;

<span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>));
root.<span class="hljs-title function_">render</span>(
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">React.StrictMode</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">React.StrictMode</span>></span></span>
);

<span class="hljs-comment">// If you want to start measuring performance in your app, pass a function</span>
<span class="hljs-comment">// to log results (for example: reportWebVitals(console.log))</span>
<span class="hljs-comment">// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals</span>
<span class="hljs-title function_">reportWebVitals</span>();
</code></pre>
<p>다음과 같이 변경해주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/client'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'./index.css'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;
<span class="hljs-keyword">import</span> reportWebVitals <span class="hljs-keyword">from</span> <span class="hljs-string">'./reportWebVitals'</span>;
<span class="hljs-keyword">import</span> { createBrowserRouter, <span class="hljs-title class_">RouterProvider</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;
<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createBrowserRouter</span>([
  {
    path : <span class="hljs-string">'/'</span>,
    element : <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>
  }
])
<span class="hljs-keyword">const</span> root = <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>));
root.<span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">RouterProvider</span> <span class="hljs-attr">router</span>=<span class="hljs-string">{router}/</span>></span></span>)

<span class="hljs-comment">// 알겠어요. React에서 특정 컴포넌트를 렌더링할 때는, root.render을 사용하여 특정 div의 ID가 있는 위치에 컴포넌트를 표시합니다. 그러나 만약 URL 경로에 기반하여 여러 컴포넌트를 렌더링하고 싶을 때는 어떻게 해야 할까요? 이때 React Router Dom 도구가 필요합니다. React Router Dom을 구현하려면 먼저 react-router-dom에서 createBrowserRouter와 RouterProvider를 가져와야 합니다. createBrowerRouter는 애플리케이션 내에서 탐색하는 데 필요한 라우터를 생성하고, RouterProvider는 라우터를 애플리케이션에 제공합니다. 그런 다음에는 URL 경로를 담을 수 있는 router라는 변수를 설정합니다. 이 변수에는 배열이 사용됩니다. router 배열을 사용하면 URL 경로를 해당하는 컴포넌트로 매핑할 수 있습니다. 모든 애플리케이션에는 지정된 "홈" 페이지가 필요하기 때문에, 사용자가 웹사이트로 이동할 때 초기로드할 컴포넌트로 App.js를 만들었습니다. 이는 router 배열 내에서 객체를 만들어 이루어졌습니다. 그런 다음 "path" 키를 사용하여 해당 URL 경로를 입력하여 그에 연결된 컴포넌트를 표시할 수 있습니다. "element" 키를 사용하여 해당 URL 경로의 사용자가 DOM을 표시하는 데 사용할 컴포넌트를 할당했습니다. 마지막으로 ReactProvider를 사용하여 일반적인 React 컴포넌트처럼 호출하고 변수 router를 속성(prop)으로 넘겨줍니다. 이를 통해 React 애플리케이션이 사용자가 입력한 URL 경로에 따라 동적으로 다른 컴포넌트를 렌더링할 수 있게 되었습니다.</span>

좋아요, 모든 것을 이해했어요. 그러나 사용자가 다른 <span class="hljs-variable constant_">URL</span>로 이동하는 방법은 어떻게 할까요? <span class="hljs-variable constant_">URL</span> 경로를 직접 입력하는 것은 좋지 않은 사용자 경험입니다. 이때 <span class="hljs-title class_">React</span> <span class="hljs-title class_">Router</span>가 제공하는 또 다른 도구인 <span class="hljs-title class_">Link</span>와 <span class="hljs-title class_">Navlink</span>를 활용합니다. 이 도구들을 사용하는 방법을 알아보겠습니다. src 내의 두 번째 <span class="hljs-variable constant_">URL</span>에 연결된 다른 <span class="hljs-title class_">React</span> 컴포넌트를 만들어보겠습니다. 이 블로그에서는 <span class="hljs-variable constant_">JSX</span>와 같은 <span class="hljs-title class_">React</span> 컴포넌트 구문에 대한 내용을 다루지 않지만, 더 자세히 알고 싶은 사람들을 위한 좋은 자료가 많이 있습니다. 물론 가장 좋은 자료는 <span class="hljs-title class_">React</span> 문서 자체입니다.

여기 우리의 기본 예제 컴포넌트가 있습니다



![<span class="hljs-number">2024</span>-<span class="hljs-number">05</span>-<span class="hljs-number">12</span>-<span class="hljs-title class_">FormingRoutesinReactRouter</span>_2.<span class="hljs-property">png</span>](<span class="hljs-regexp">/assets/img</span><span class="hljs-regexp">/2024-05-12-FormingRoutesinReactRouter_2.png)

이 시점에서 App 컴포넌트가 콘텐츠로 가득 찼다는 것을 눈치챘을 것입니다. 이 콘텐츠는 create react app 명령을 사용하여 애플리케이션을 생성할 때 채워졌습니다. 함수 자체와 내부의 wrapper div만 남기고 모두 안전하게 삭제할 수 있습니다. App 컴포넌트 내에 h1 요소에 코드를 추가하여 예제 컴포넌트와 동일하게 텍스트 내용을 "hello"로 만드세요.

![2024-05-12-FormingRoutesinReactRouter_3.png](/</span>assets/img/<span class="hljs-number">2024</span>-<span class="hljs-number">05</span>-<span class="hljs-number">12</span>-<span class="hljs-title class_">FormingRoutesinReactRouter</span>_3.<span class="hljs-property">png</span>)

package.<span class="hljs-property">json</span> 파일로 이동하여 스크립트 섹션을 살펴보면 다음과 같은 항목이 있는 것을 확인할 수 있습니다:



<span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"start"</span>: <span class="hljs-string">"react-scripts start"</span>,
    <span class="hljs-string">"build"</span>: <span class="hljs-string">"react-scripts build"</span>,
    <span class="hljs-string">"test"</span>: <span class="hljs-string">"react-scripts test"</span>,
    <span class="hljs-string">"eject"</span>: <span class="hljs-string">"react-scripts eject"</span>
  },

이 명령은 터미널에서 사용할 수 있는 스크립트입니다. 터미널에서 <span class="hljs-string">`npm start`</span>를 실행하여 시작 스크립트를 실행하면 모의 프론트엔드 서버가 실행되어 컴포넌트를 렌더링할 것입니다.

이 시점에는 모킹 페이지에 검은색 <span class="hljs-title class_">Hello</span>가 표시되어 있어야 합니다. 잘 했어요! 그런데 예시 컴포넌트는 어디로 갔을까요? 페이지를 렌더링하는 방법을 생각해보세요. 다시 index.<span class="hljs-property">js</span>로 돌아가서 예시 컴포넌트를 렌더링할 페이지로 추가해야 합니다. 그러면 이제 그렇게 해 봅시다!

![<span class="hljs-title class_">React</span> <span class="hljs-title class_">Router</span>를 사용한 라우트 구성](<span class="hljs-regexp">/assets/img</span><span class="hljs-regexp">/2024-05-12-FormingRoutesinReactRouter_4.png)



저희는 예제 컴포넌트를 index.js에 불러왔고, 그 후에 라우팅 오브젝트를 형성하여 예제에 라우팅 URL을 지정했습니다. 이제 URL "/</span>example<span class="hljs-string">"을 입력하면 "</span><span class="hljs-title class_">Hello</span> <span class="hljs-title class_">World</span>!<span class="hljs-string">"가 화면에 표시됩니다.

이전에 말한대로, 이는 서로 다른 URL 경로 간에 이동하는 끔찍한 방법입니다. 대신 Link와 Navlink를 사용해보죠. Link와 Navlink는 모두 to 속성이라는 특별한 속성을 갖고 있으며, 이를 통해 사용자를 제공된 URL로 이동시킵니다. 두 가지의 차이점은 NavLink에는 쉽게 CSS로 스타일을 지정할 수 있는 active 클래스가 있어 사용자에게 현재 활성화된 페이지를 보여줍니다. 우선 Link만 사용해보겠습니다. 다음과 같이 두 컴포넌트에 Link를 가져오세요:

import { Link } from "</span>react-router-dom<span class="hljs-string">"

App 및 예제 컴포넌트에서 둘 다 wrapper 엘리먼트인 nav를 사용하여 링크 엘리먼트를 형성한 다음, to 속성에 해당 링크가 이동할 라우팅 경로를 제공해주세요:



&#x3C;img src="</span>/assets/img/<span class="hljs-number">2024</span>-<span class="hljs-number">05</span>-<span class="hljs-number">12</span>-<span class="hljs-title class_">FormingRoutesinReactRouter</span>_5.<span class="hljs-property">png</span><span class="hljs-string">" />

&#x3C;img src="</span>/assets/img/<span class="hljs-number">2024</span>-<span class="hljs-number">05</span>-<span class="hljs-number">12</span>-<span class="hljs-title class_">FormingRoutesinReactRouter</span>_6.<span class="hljs-property">png</span><span class="hljs-string">" />

이제 목업 페이지로 돌아가서 링크를 클릭해보세요. URL 경로가 변경되는 것을 주목하셨나요? 이제 다른 리액트 컴포넌트로의 경로를 포함하는 싱글 페이지 애플리케이션을 성공적으로 생성했습니다!

# 결론



# React Router은 독특한 콘텐츠를 가진 상호 연결된 React 컴포넌트를 생성할 수 있는 무궁무진한 가능성을 제공하는 강력한 도구입니다. 동적 URL 라우팅, 상태 관리 및 useEffect 훅을 통해 혁신의 잠재력이 굉장히 높습니다. 기본 도면조차도 무한한 가능성을 탐험하고 창의성을 발휘할 수 있도록 영감을 줄 수 있습니다. 그러니 바로 React Router에 뛰어들어서, 상상력이 당신을 이끌어갈 곳을 확인해 보세요!

리소스

- [React 문서](https://reactjs.org/)
- [React Router 문서](https://reactrouter.com/)
</span></code></pre>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트 라우터에서 경로 형성하기","description":"","date":"2024-05-12 23:03","slug":"2024-05-12-FormingRoutesinReactRouter","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-FormingRoutesinReactRouter_0.png\" /\u003e\n\n리액트는 웹 개발 세계를 뒤흔들 정도로 인기 있는 프런트엔드 자바스크립트 라이브러리입니다. 그 인기의 이유 중 하나는 컴포넌트 기반 접근 방식으로, 웹 페이지 UI가 여러 컴포넌트나 함수로 나뉘어 효율적이고 인터랙티브한 사용자 인터페이스를 만들어내기 때문입니다. 오픈 소스 라이브러리인 리액트는 개발자들에게 뛰어난 웹 응용프로그램을 만들 수 있는 무한한 가능성을 제공합니다. 이 글에서는 특정 패키지인 React Router 패키지에 초점을 맞추어 다룰 것인데, 이 패키지는 리액트 응용프로그램에서 URL 라우팅을 통해 여러 리액트 컴포넌트의 탐색을 처리할 수 있도록 합니다.\n\n# 시작하기 전에\n\n아래 내용은 Windows OS 환경에서 Visual Studio Code를 코드 편집기로 사용하여 React Router와 React를 사용하는 방법에 대한 상세한 가이드를 제공합니다. 예시는 React 버전 18.3과 React Router 버전 6.2를 기반으로 합니다. 그러나 세팅 과정에서 다른 점이 발견된다면, 설치된 패키지 버전을 확인하기 위해 package.json 파일을 확인하는 것이 좋습니다. 리액트와 리액트 라우터가 계속 발전함에 따라, 이 안내서의 코드는 오래되어질 수 있습니다. 리액트와 리액트 라우터는 자신들의 패키지의 최신 버전으로 업그레이드하기 위한 상세한 문서를 제공하고 있습니다.\n\n\n\n# 기본 설정\n\n시작하려면 기본적인 React 앱을 만들어야 합니다. 필요한 패키지를 수동으로 코딩하고 다운로드하는 방법도 있지만, React에서는 더 간단한 대안을 제공합니다. 먼저 터미널에서 앱을 저장할 디렉토리로 이동합니다. 그런 다음 해당 명령을 실행하세요.\n\n```js\nnpx create-react-app your-app-name\n```\n\n이 명령은 항상 현재 React 버전이 설치되어 있는지 확인합니다. 그런 다음이 명령을 사용하여 앱으로 이동합니다:\n\n\n\n```js\ncd your-app-name\n```\n\n설정에 따라 오픈 명령이 다를 수 있습니다. 제가 사용하는 것은 Visual Studio Code에서 앱을 열기 위해 code . 입니다. 어떤 경우든 코드 편집 소프트웨어가 터미널에 연결되어 있는 것이 중요합니다. 기본적인 React 코딩 환경만 필요하다면 모두 준비된 상태입니다! 하지만 싱글 페이지 애플리케이션을 더욱 확장하고 싶다면 클라이언트 측 라우팅을 활용하여 효율적으로 만들 수 있습니다.\n\n# 클라이언트 측 라우팅이란?\n\n이 주제에 대해 자세히 설명하진 않겠지만, 기본 개념에 대해 간단히 설명해 드릴게요. 더 자세히 알고 싶다면 이와 같은 유용한 블로그 포스트와 같은 많은 자료들이 있습니다. 서버 측 라우팅에서는 웹페이지의 링크를 클릭할 때 라우팅이 발생하며 해당 링크 URL을 가집니다. 그러면 브라우저는 해당 특정 페이지에 대한 GET 요청을 서버에 생성하고 서버는 페이지를 그 URL 라우트로 채우기 위해 필요한 데이터로 응답합니다. 사용자가 경험하는 대부분의 버퍼링은 이 과정에서 생성된 GET 요청으로 인한 것입니다. 반면 클라이언트 측 라우팅은 이러한 방식과는 다릅니다. JavaScript를 통해 모든 라우팅을 처리하고 초기 로드 중에 모든 요청을 수행합니다. 이 기술에는 여러 장단점이 있지만, 대부분의 사용자가 빠른 속도를 경험하는 장점이 있습니다. 다음 단락에서는 React Router에 대해 살펴보며 이 라우팅 논리를 React 환경에서 사용하는 것이 훨씬 쉬워진 패키지에 대해 논의할 것입니다.\n\n\n\n# React Router 설정하기\n\nReact Router Dom의 도구를 사용하려면 먼저 React 애플리케이션에 설치해야 합니다. React 애플리케이션 내에서 아래 명령어를 실행해주세요:\n\n```js\nnpm i react-router-dom\n```\n\n그런 다음 package.json 파일을 확인하고, 다음과 유사한 정보를 찾아보세요:\n\n\n\n```js\r\n//\n\"dependencies\": {\n    \"@testing-library/jest-dom\": \"^5.17.0\",\n    \"@testing-library/react\": \"^13.4.0\",\n    \"@testing-library/user-event\": \"^13.5.0\",\n    \"react\": \"^18.3.1\",\n    \"react-dom\": \"^18.3.1\",\n    \"react-router-dom\": \"^6.23.0\",\n    \"react-scripts\": \"5.0.1\",\n    \"web-vitals\": \"^2.1.4\"\n//\r\n```\n\n만약 React Router Dom 부분에서 버전이 v5 이상이면 모두 설정이 완료된 것입니다!\n\n만약 앞에서 설명한대로 Create React App을 사용했다면, 아래 이미지는 코드 편집기에 따라 다를 수는 있지만 완전히 같아야 합니다.\n\n\u003cimg src=\"/assets/img/2024-05-12-FormingRoutesinReactRouter_1.png\" /\u003e\n\n\n\n지금은 React가 index.js 파일을 통해 App.js만 렌더링하고 있어요. 이 블로그를 만드는 목적을 완전히 무너뜨리고 있네요! 그래서 변경할게요. index.js 파일로 이동해서 필요한 변경사항을 해봐요.\n\n원래 코드:\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  \u003cReact.StrictMode\u003e\n    \u003cApp /\u003e\n  \u003c/React.StrictMode\u003e\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n```\n\n다음과 같이 변경해주세요:\n\n\n\n```js\r\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { createBrowserRouter, RouterProvider } from 'react-router-dom';\nconst router = createBrowserRouter([\n  {\n    path : '/',\n    element : \u003cApp /\u003e\n  }\n])\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\u003cRouterProvider router={router}/\u003e)\n\n// 알겠어요. React에서 특정 컴포넌트를 렌더링할 때는, root.render을 사용하여 특정 div의 ID가 있는 위치에 컴포넌트를 표시합니다. 그러나 만약 URL 경로에 기반하여 여러 컴포넌트를 렌더링하고 싶을 때는 어떻게 해야 할까요? 이때 React Router Dom 도구가 필요합니다. React Router Dom을 구현하려면 먼저 react-router-dom에서 createBrowserRouter와 RouterProvider를 가져와야 합니다. createBrowerRouter는 애플리케이션 내에서 탐색하는 데 필요한 라우터를 생성하고, RouterProvider는 라우터를 애플리케이션에 제공합니다. 그런 다음에는 URL 경로를 담을 수 있는 router라는 변수를 설정합니다. 이 변수에는 배열이 사용됩니다. router 배열을 사용하면 URL 경로를 해당하는 컴포넌트로 매핑할 수 있습니다. 모든 애플리케이션에는 지정된 \"홈\" 페이지가 필요하기 때문에, 사용자가 웹사이트로 이동할 때 초기로드할 컴포넌트로 App.js를 만들었습니다. 이는 router 배열 내에서 객체를 만들어 이루어졌습니다. 그런 다음 \"path\" 키를 사용하여 해당 URL 경로를 입력하여 그에 연결된 컴포넌트를 표시할 수 있습니다. \"element\" 키를 사용하여 해당 URL 경로의 사용자가 DOM을 표시하는 데 사용할 컴포넌트를 할당했습니다. 마지막으로 ReactProvider를 사용하여 일반적인 React 컴포넌트처럼 호출하고 변수 router를 속성(prop)으로 넘겨줍니다. 이를 통해 React 애플리케이션이 사용자가 입력한 URL 경로에 따라 동적으로 다른 컴포넌트를 렌더링할 수 있게 되었습니다.\n\n좋아요, 모든 것을 이해했어요. 그러나 사용자가 다른 URL로 이동하는 방법은 어떻게 할까요? URL 경로를 직접 입력하는 것은 좋지 않은 사용자 경험입니다. 이때 React Router가 제공하는 또 다른 도구인 Link와 Navlink를 활용합니다. 이 도구들을 사용하는 방법을 알아보겠습니다. src 내의 두 번째 URL에 연결된 다른 React 컴포넌트를 만들어보겠습니다. 이 블로그에서는 JSX와 같은 React 컴포넌트 구문에 대한 내용을 다루지 않지만, 더 자세히 알고 싶은 사람들을 위한 좋은 자료가 많이 있습니다. 물론 가장 좋은 자료는 React 문서 자체입니다.\n\n여기 우리의 기본 예제 컴포넌트가 있습니다\n\n\n\n![2024-05-12-FormingRoutesinReactRouter_2.png](/assets/img/2024-05-12-FormingRoutesinReactRouter_2.png)\n\n이 시점에서 App 컴포넌트가 콘텐츠로 가득 찼다는 것을 눈치챘을 것입니다. 이 콘텐츠는 create react app 명령을 사용하여 애플리케이션을 생성할 때 채워졌습니다. 함수 자체와 내부의 wrapper div만 남기고 모두 안전하게 삭제할 수 있습니다. App 컴포넌트 내에 h1 요소에 코드를 추가하여 예제 컴포넌트와 동일하게 텍스트 내용을 \"hello\"로 만드세요.\n\n![2024-05-12-FormingRoutesinReactRouter_3.png](/assets/img/2024-05-12-FormingRoutesinReactRouter_3.png)\n\npackage.json 파일로 이동하여 스크립트 섹션을 살펴보면 다음과 같은 항목이 있는 것을 확인할 수 있습니다:\n\n\n\n\"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  },\n\n이 명령은 터미널에서 사용할 수 있는 스크립트입니다. 터미널에서 `npm start`를 실행하여 시작 스크립트를 실행하면 모의 프론트엔드 서버가 실행되어 컴포넌트를 렌더링할 것입니다.\n\n이 시점에는 모킹 페이지에 검은색 Hello가 표시되어 있어야 합니다. 잘 했어요! 그런데 예시 컴포넌트는 어디로 갔을까요? 페이지를 렌더링하는 방법을 생각해보세요. 다시 index.js로 돌아가서 예시 컴포넌트를 렌더링할 페이지로 추가해야 합니다. 그러면 이제 그렇게 해 봅시다!\n\n![React Router를 사용한 라우트 구성](/assets/img/2024-05-12-FormingRoutesinReactRouter_4.png)\n\n\n\n저희는 예제 컴포넌트를 index.js에 불러왔고, 그 후에 라우팅 오브젝트를 형성하여 예제에 라우팅 URL을 지정했습니다. 이제 URL \"/example\"을 입력하면 \"Hello World!\"가 화면에 표시됩니다.\n\n이전에 말한대로, 이는 서로 다른 URL 경로 간에 이동하는 끔찍한 방법입니다. 대신 Link와 Navlink를 사용해보죠. Link와 Navlink는 모두 to 속성이라는 특별한 속성을 갖고 있으며, 이를 통해 사용자를 제공된 URL로 이동시킵니다. 두 가지의 차이점은 NavLink에는 쉽게 CSS로 스타일을 지정할 수 있는 active 클래스가 있어 사용자에게 현재 활성화된 페이지를 보여줍니다. 우선 Link만 사용해보겠습니다. 다음과 같이 두 컴포넌트에 Link를 가져오세요:\n\nimport { Link } from \"react-router-dom\"\n\nApp 및 예제 컴포넌트에서 둘 다 wrapper 엘리먼트인 nav를 사용하여 링크 엘리먼트를 형성한 다음, to 속성에 해당 링크가 이동할 라우팅 경로를 제공해주세요:\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-FormingRoutesinReactRouter_5.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-12-FormingRoutesinReactRouter_6.png\" /\u003e\n\n이제 목업 페이지로 돌아가서 링크를 클릭해보세요. URL 경로가 변경되는 것을 주목하셨나요? 이제 다른 리액트 컴포넌트로의 경로를 포함하는 싱글 페이지 애플리케이션을 성공적으로 생성했습니다!\n\n# 결론\n\n\n\n# React Router은 독특한 콘텐츠를 가진 상호 연결된 React 컴포넌트를 생성할 수 있는 무궁무진한 가능성을 제공하는 강력한 도구입니다. 동적 URL 라우팅, 상태 관리 및 useEffect 훅을 통해 혁신의 잠재력이 굉장히 높습니다. 기본 도면조차도 무한한 가능성을 탐험하고 창의성을 발휘할 수 있도록 영감을 줄 수 있습니다. 그러니 바로 React Router에 뛰어들어서, 상상력이 당신을 이끌어갈 곳을 확인해 보세요!\n\n리소스\n\n- [React 문서](https://reactjs.org/)\n- [React Router 문서](https://reactrouter.com/)","ogImage":{"url":"/assets/img/2024-05-12-FormingRoutesinReactRouter_0.png"},"coverImage":"/assets/img/2024-05-12-FormingRoutesinReactRouter_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-05-12-FormingRoutesinReactRouter_0.png\"\u003e\n\u003cp\u003e리액트는 웹 개발 세계를 뒤흔들 정도로 인기 있는 프런트엔드 자바스크립트 라이브러리입니다. 그 인기의 이유 중 하나는 컴포넌트 기반 접근 방식으로, 웹 페이지 UI가 여러 컴포넌트나 함수로 나뉘어 효율적이고 인터랙티브한 사용자 인터페이스를 만들어내기 때문입니다. 오픈 소스 라이브러리인 리액트는 개발자들에게 뛰어난 웹 응용프로그램을 만들 수 있는 무한한 가능성을 제공합니다. 이 글에서는 특정 패키지인 React Router 패키지에 초점을 맞추어 다룰 것인데, 이 패키지는 리액트 응용프로그램에서 URL 라우팅을 통해 여러 리액트 컴포넌트의 탐색을 처리할 수 있도록 합니다.\u003c/p\u003e\n\u003ch1\u003e시작하기 전에\u003c/h1\u003e\n\u003cp\u003e아래 내용은 Windows OS 환경에서 Visual Studio Code를 코드 편집기로 사용하여 React Router와 React를 사용하는 방법에 대한 상세한 가이드를 제공합니다. 예시는 React 버전 18.3과 React Router 버전 6.2를 기반으로 합니다. 그러나 세팅 과정에서 다른 점이 발견된다면, 설치된 패키지 버전을 확인하기 위해 package.json 파일을 확인하는 것이 좋습니다. 리액트와 리액트 라우터가 계속 발전함에 따라, 이 안내서의 코드는 오래되어질 수 있습니다. 리액트와 리액트 라우터는 자신들의 패키지의 최신 버전으로 업그레이드하기 위한 상세한 문서를 제공하고 있습니다.\u003c/p\u003e\n\u003ch1\u003e기본 설정\u003c/h1\u003e\n\u003cp\u003e시작하려면 기본적인 React 앱을 만들어야 합니다. 필요한 패키지를 수동으로 코딩하고 다운로드하는 방법도 있지만, React에서는 더 간단한 대안을 제공합니다. 먼저 터미널에서 앱을 저장할 디렉토리로 이동합니다. 그런 다음 해당 명령을 실행하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpx create-react-app your-app-name\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 명령은 항상 현재 React 버전이 설치되어 있는지 확인합니다. 그런 다음이 명령을 사용하여 앱으로 이동합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd your-app-name\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e설정에 따라 오픈 명령이 다를 수 있습니다. 제가 사용하는 것은 Visual Studio Code에서 앱을 열기 위해 code . 입니다. 어떤 경우든 코드 편집 소프트웨어가 터미널에 연결되어 있는 것이 중요합니다. 기본적인 React 코딩 환경만 필요하다면 모두 준비된 상태입니다! 하지만 싱글 페이지 애플리케이션을 더욱 확장하고 싶다면 클라이언트 측 라우팅을 활용하여 효율적으로 만들 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e클라이언트 측 라우팅이란?\u003c/h1\u003e\n\u003cp\u003e이 주제에 대해 자세히 설명하진 않겠지만, 기본 개념에 대해 간단히 설명해 드릴게요. 더 자세히 알고 싶다면 이와 같은 유용한 블로그 포스트와 같은 많은 자료들이 있습니다. 서버 측 라우팅에서는 웹페이지의 링크를 클릭할 때 라우팅이 발생하며 해당 링크 URL을 가집니다. 그러면 브라우저는 해당 특정 페이지에 대한 GET 요청을 서버에 생성하고 서버는 페이지를 그 URL 라우트로 채우기 위해 필요한 데이터로 응답합니다. 사용자가 경험하는 대부분의 버퍼링은 이 과정에서 생성된 GET 요청으로 인한 것입니다. 반면 클라이언트 측 라우팅은 이러한 방식과는 다릅니다. JavaScript를 통해 모든 라우팅을 처리하고 초기 로드 중에 모든 요청을 수행합니다. 이 기술에는 여러 장단점이 있지만, 대부분의 사용자가 빠른 속도를 경험하는 장점이 있습니다. 다음 단락에서는 React Router에 대해 살펴보며 이 라우팅 논리를 React 환경에서 사용하는 것이 훨씬 쉬워진 패키지에 대해 논의할 것입니다.\u003c/p\u003e\n\u003ch1\u003eReact Router 설정하기\u003c/h1\u003e\n\u003cp\u003eReact Router Dom의 도구를 사용하려면 먼저 React 애플리케이션에 설치해야 합니다. React 애플리케이션 내에서 아래 명령어를 실행해주세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm i react-router-dom\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 package.json 파일을 확인하고, 다음과 유사한 정보를 찾아보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"dependencies\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"@testing-library/jest-dom\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^5.17.0\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"@testing-library/react\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^13.4.0\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"@testing-library/user-event\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^13.5.0\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^18.3.1\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"react-dom\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^18.3.1\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"react-router-dom\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^6.23.0\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"react-scripts\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"5.0.1\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"web-vitals\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"^2.1.4\"\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 React Router Dom 부분에서 버전이 v5 이상이면 모두 설정이 완료된 것입니다!\u003c/p\u003e\n\u003cp\u003e만약 앞에서 설명한대로 Create React App을 사용했다면, 아래 이미지는 코드 편집기에 따라 다를 수는 있지만 완전히 같아야 합니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-12-FormingRoutesinReactRouter_1.png\"\u003e\n\u003cp\u003e지금은 React가 index.js 파일을 통해 App.js만 렌더링하고 있어요. 이 블로그를 만드는 목적을 완전히 무너뜨리고 있네요! 그래서 변경할게요. index.js 파일로 이동해서 필요한 변경사항을 해봐요.\u003c/p\u003e\n\u003cp\u003e원래 코드:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-dom/client'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./index.css'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./App'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e reportWebVitals \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./reportWebVitals'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e root = \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateRoot\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e));\nroot.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eReact.StrictMode\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eReact.StrictMode\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n);\n\n\u003cspan class=\"hljs-comment\"\u003e// If you want to start measuring performance in your app, pass a function\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// to log results (for example: reportWebVitals(console.log))\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003ereportWebVitals\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음과 같이 변경해주세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-dom/client'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./index.css'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./App'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e reportWebVitals \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./reportWebVitals'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { createBrowserRouter, \u003cspan class=\"hljs-title class_\"\u003eRouterProvider\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-router-dom'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e router = \u003cspan class=\"hljs-title function_\"\u003ecreateBrowserRouter\u003c/span\u003e([\n  {\n    path : \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e,\n    element : \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n  }\n])\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e root = \u003cspan class=\"hljs-title class_\"\u003eReactDOM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateRoot\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e));\nroot.\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eRouterProvider\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erouter\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{router}/\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e// 알겠어요. React에서 특정 컴포넌트를 렌더링할 때는, root.render을 사용하여 특정 div의 ID가 있는 위치에 컴포넌트를 표시합니다. 그러나 만약 URL 경로에 기반하여 여러 컴포넌트를 렌더링하고 싶을 때는 어떻게 해야 할까요? 이때 React Router Dom 도구가 필요합니다. React Router Dom을 구현하려면 먼저 react-router-dom에서 createBrowserRouter와 RouterProvider를 가져와야 합니다. createBrowerRouter는 애플리케이션 내에서 탐색하는 데 필요한 라우터를 생성하고, RouterProvider는 라우터를 애플리케이션에 제공합니다. 그런 다음에는 URL 경로를 담을 수 있는 router라는 변수를 설정합니다. 이 변수에는 배열이 사용됩니다. router 배열을 사용하면 URL 경로를 해당하는 컴포넌트로 매핑할 수 있습니다. 모든 애플리케이션에는 지정된 \"홈\" 페이지가 필요하기 때문에, 사용자가 웹사이트로 이동할 때 초기로드할 컴포넌트로 App.js를 만들었습니다. 이는 router 배열 내에서 객체를 만들어 이루어졌습니다. 그런 다음 \"path\" 키를 사용하여 해당 URL 경로를 입력하여 그에 연결된 컴포넌트를 표시할 수 있습니다. \"element\" 키를 사용하여 해당 URL 경로의 사용자가 DOM을 표시하는 데 사용할 컴포넌트를 할당했습니다. 마지막으로 ReactProvider를 사용하여 일반적인 React 컴포넌트처럼 호출하고 변수 router를 속성(prop)으로 넘겨줍니다. 이를 통해 React 애플리케이션이 사용자가 입력한 URL 경로에 따라 동적으로 다른 컴포넌트를 렌더링할 수 있게 되었습니다.\u003c/span\u003e\n\n좋아요, 모든 것을 이해했어요. 그러나 사용자가 다른 \u003cspan class=\"hljs-variable constant_\"\u003eURL\u003c/span\u003e로 이동하는 방법은 어떻게 할까요? \u003cspan class=\"hljs-variable constant_\"\u003eURL\u003c/span\u003e 경로를 직접 입력하는 것은 좋지 않은 사용자 경험입니다. 이때 \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRouter\u003c/span\u003e가 제공하는 또 다른 도구인 \u003cspan class=\"hljs-title class_\"\u003eLink\u003c/span\u003e와 \u003cspan class=\"hljs-title class_\"\u003eNavlink\u003c/span\u003e를 활용합니다. 이 도구들을 사용하는 방법을 알아보겠습니다. src 내의 두 번째 \u003cspan class=\"hljs-variable constant_\"\u003eURL\u003c/span\u003e에 연결된 다른 \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e 컴포넌트를 만들어보겠습니다. 이 블로그에서는 \u003cspan class=\"hljs-variable constant_\"\u003eJSX\u003c/span\u003e와 같은 \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e 컴포넌트 구문에 대한 내용을 다루지 않지만, 더 자세히 알고 싶은 사람들을 위한 좋은 자료가 많이 있습니다. 물론 가장 좋은 자료는 \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e 문서 자체입니다.\n\n여기 우리의 기본 예제 컴포넌트가 있습니다\n\n\n\n![\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e05\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eFormingRoutesinReactRouter\u003c/span\u003e_2.\u003cspan class=\"hljs-property\"\u003epng\u003c/span\u003e](\u003cspan class=\"hljs-regexp\"\u003e/assets/img\u003c/span\u003e\u003cspan class=\"hljs-regexp\"\u003e/2024-05-12-FormingRoutesinReactRouter_2.png)\n\n이 시점에서 App 컴포넌트가 콘텐츠로 가득 찼다는 것을 눈치챘을 것입니다. 이 콘텐츠는 create react app 명령을 사용하여 애플리케이션을 생성할 때 채워졌습니다. 함수 자체와 내부의 wrapper div만 남기고 모두 안전하게 삭제할 수 있습니다. App 컴포넌트 내에 h1 요소에 코드를 추가하여 예제 컴포넌트와 동일하게 텍스트 내용을 \"hello\"로 만드세요.\n\n![2024-05-12-FormingRoutesinReactRouter_3.png](/\u003c/span\u003eassets/img/\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e05\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eFormingRoutesinReactRouter\u003c/span\u003e_3.\u003cspan class=\"hljs-property\"\u003epng\u003c/span\u003e)\n\npackage.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e 파일로 이동하여 스크립트 섹션을 살펴보면 다음과 같은 항목이 있는 것을 확인할 수 있습니다:\n\n\n\n\u003cspan class=\"hljs-string\"\u003e\"scripts\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"start\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"react-scripts start\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"build\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"react-scripts build\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"test\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"react-scripts test\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"eject\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"react-scripts eject\"\u003c/span\u003e\n  },\n\n이 명령은 터미널에서 사용할 수 있는 스크립트입니다. 터미널에서 \u003cspan class=\"hljs-string\"\u003e`npm start`\u003c/span\u003e를 실행하여 시작 스크립트를 실행하면 모의 프론트엔드 서버가 실행되어 컴포넌트를 렌더링할 것입니다.\n\n이 시점에는 모킹 페이지에 검은색 \u003cspan class=\"hljs-title class_\"\u003eHello\u003c/span\u003e가 표시되어 있어야 합니다. 잘 했어요! 그런데 예시 컴포넌트는 어디로 갔을까요? 페이지를 렌더링하는 방법을 생각해보세요. 다시 index.\u003cspan class=\"hljs-property\"\u003ejs\u003c/span\u003e로 돌아가서 예시 컴포넌트를 렌더링할 페이지로 추가해야 합니다. 그러면 이제 그렇게 해 봅시다!\n\n![\u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRouter\u003c/span\u003e를 사용한 라우트 구성](\u003cspan class=\"hljs-regexp\"\u003e/assets/img\u003c/span\u003e\u003cspan class=\"hljs-regexp\"\u003e/2024-05-12-FormingRoutesinReactRouter_4.png)\n\n\n\n저희는 예제 컴포넌트를 index.js에 불러왔고, 그 후에 라우팅 오브젝트를 형성하여 예제에 라우팅 URL을 지정했습니다. 이제 URL \"/\u003c/span\u003eexample\u003cspan class=\"hljs-string\"\u003e\"을 입력하면 \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003eHello\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWorld\u003c/span\u003e!\u003cspan class=\"hljs-string\"\u003e\"가 화면에 표시됩니다.\n\n이전에 말한대로, 이는 서로 다른 URL 경로 간에 이동하는 끔찍한 방법입니다. 대신 Link와 Navlink를 사용해보죠. Link와 Navlink는 모두 to 속성이라는 특별한 속성을 갖고 있으며, 이를 통해 사용자를 제공된 URL로 이동시킵니다. 두 가지의 차이점은 NavLink에는 쉽게 CSS로 스타일을 지정할 수 있는 active 클래스가 있어 사용자에게 현재 활성화된 페이지를 보여줍니다. 우선 Link만 사용해보겠습니다. 다음과 같이 두 컴포넌트에 Link를 가져오세요:\n\nimport { Link } from \"\u003c/span\u003ereact-router-dom\u003cspan class=\"hljs-string\"\u003e\"\n\nApp 및 예제 컴포넌트에서 둘 다 wrapper 엘리먼트인 nav를 사용하여 링크 엘리먼트를 형성한 다음, to 속성에 해당 링크가 이동할 라우팅 경로를 제공해주세요:\n\n\n\n\u0026#x3C;img src=\"\u003c/span\u003e/assets/img/\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e05\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eFormingRoutesinReactRouter\u003c/span\u003e_5.\u003cspan class=\"hljs-property\"\u003epng\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\" /\u003e\n\n\u0026#x3C;img src=\"\u003c/span\u003e/assets/img/\u003cspan class=\"hljs-number\"\u003e2024\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e05\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eFormingRoutesinReactRouter\u003c/span\u003e_6.\u003cspan class=\"hljs-property\"\u003epng\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\" /\u003e\n\n이제 목업 페이지로 돌아가서 링크를 클릭해보세요. URL 경로가 변경되는 것을 주목하셨나요? 이제 다른 리액트 컴포넌트로의 경로를 포함하는 싱글 페이지 애플리케이션을 성공적으로 생성했습니다!\n\n# 결론\n\n\n\n# React Router은 독특한 콘텐츠를 가진 상호 연결된 React 컴포넌트를 생성할 수 있는 무궁무진한 가능성을 제공하는 강력한 도구입니다. 동적 URL 라우팅, 상태 관리 및 useEffect 훅을 통해 혁신의 잠재력이 굉장히 높습니다. 기본 도면조차도 무한한 가능성을 탐험하고 창의성을 발휘할 수 있도록 영감을 줄 수 있습니다. 그러니 바로 React Router에 뛰어들어서, 상상력이 당신을 이끌어갈 곳을 확인해 보세요!\n\n리소스\n\n- [React 문서](https://reactjs.org/)\n- [React Router 문서](https://reactrouter.com/)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-FormingRoutesinReactRouter"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>