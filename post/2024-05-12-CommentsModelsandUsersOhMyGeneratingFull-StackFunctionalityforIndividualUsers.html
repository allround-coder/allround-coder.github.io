<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>댓글, 모델, 그리고 사용자들- 어머나 개별 사용자를 위한 풀 스택 기능 생성하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="댓글, 모델, 그리고 사용자들- 어머나 개별 사용자를 위한 풀 스택 기능 생성하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="댓글, 모델, 그리고 사용자들- 어머나 개별 사용자를 위한 풀 스택 기능 생성하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers" data-gatsby-head="true"/><meta name="twitter:title" content="댓글, 모델, 그리고 사용자들- 어머나 개별 사용자를 위한 풀 스택 기능 생성하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 21:57" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">댓글, 모델, 그리고 사용자들- 어머나 개별 사용자를 위한 풀 스택 기능 생성하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="댓글, 모델, 그리고 사용자들- 어머나 개별 사용자를 위한 풀 스택 기능 생성하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>프론트엔드와 백엔드 프로그래밍에 대해 충분히 배웠다면, 풀스택 애플리케이션을 구축한 후에 할 일은 아마도 다른 사용자가 응용 프로그램에 로그인하고 로그인한 사용자에 맞게 사이트의 특정 세부 정보를 제공할 수 있도록 하는 것일 것입니다. 이제 데이터베이스와 모델에 대한 지식을 활용하여 그 모든 정보를 저장할 데이터베이스(또는 여러 개)를 만들 수 있습니다. 지금, 사용자의 로그인 유효성 검사 및 암호화에 필요한 모든 사항에 대해 다루지는 않겠습니다(그것은 다른 블로그 게시물이 되겠죠), 하지만 사용자가 댓글을 달거나 평가할 수 있도록 허용하는 백엔드 구조 및 해당 구조를 클라이언트 측에서 사용하여 현재 사용자에 대한 특정 정보를 렌더링하는 방법에 대해서 이야기해보려고 합니다.</p>
<h1>모델</h1>
<p>아래에는 우리의 User 클래스에 대한 상당히 기본적인 모델과 Flask/SQLAlchemy를 통해 생성될 데이터베이스 테이블이 있으며, 그 관계들이 포함되어 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> sqlalchemy_serializer를 <span class="hljs-title class_">SerializerMixin</span>에 <span class="hljs-keyword">import</span>합니다.
<span class="hljs-title class_">SQLAlchemy</span>.<span class="hljs-property">ext</span>.<span class="hljs-property">associationproxy</span>에서 association_proxy도 <span class="hljs-keyword">import</span>합니다.

config에서 db를 <span class="hljs-keyword">import</span>하고 <span class="hljs-title class_">User</span> 클래스를 만듭니다. <span class="hljs-title class_">User</span> 클래스는 db.<span class="hljs-property">Model</span>과 <span class="hljs-title class_">SerializerMixin</span>을 상속받습니다.
아래는 <span class="hljs-title class_">User</span> 클래스의 일부분입니다.

__tablename__ = <span class="hljs-string">'users'</span>
id = db.<span class="hljs-title class_">Column</span>(db.<span class="hljs-property">Integer</span>, primary_key=<span class="hljs-title class_">True</span>)
username = db.<span class="hljs-title class_">Column</span>(db.<span class="hljs-property">String</span>)
_password_hash = db.<span class="hljs-title class_">Column</span>(db.<span class="hljs-property">String</span>)

game_statistics = db.<span class="hljs-title function_">relationship</span>(<span class="hljs-string">'GameStatistics'</span>, back_populates=<span class="hljs-string">'user'</span>, cascade=<span class="hljs-string">'all, delete-orphan'</span>)
games = <span class="hljs-title function_">association_proxy</span>(<span class="hljs-string">'game_statistics'</span>, <span class="hljs-string">'game'</span>)

serialize_rules = (<span class="hljs-string">'-game_statistics'</span>,)

사용자의 사용자 이름과 비밀번호를 저장하고 다른 데이터베이스와의 관계를 만들어 추가 정보를 보유하려고 합니다. 게임 등급 애플리케이션을 개발하고 사용자가 게임을 <span class="hljs-string">"좋아요"</span>하거나 게임에 댓글/평가를 남기거나 게임을 위시리스트에 추가할 수 있도록 했으며, 각각의 기능은 특정 게임에 관한 것이어야 합니다. 이 애플리케이션에는 많은 게임이 있기 때문에 사용자와 게임 사이의 다대다 관계를 만들기 위해 사용자당 게임별로 좋아요, 위시리스트, 댓글 및 등급에 관한 모든 정보를 보유할 다른 데이터베이스가 필요합니다.

아래에는 다른 두 클래스 (그리고 이에 따른 <span class="hljs-title class_">Flask</span>와 <span class="hljs-title class_">SQLAlchemy</span>를 통한 테이블)의 간소화된 버전이 있습니다.

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Game</span>(db.<span class="hljs-property">Model</span>, <span class="hljs-title class_">SerializerMixin</span>):
    __tablename__ = <span class="hljs-string">'games'</span>

    위의 <span class="hljs-title class_">User</span> 클래스와 유사한 형태입니다. 이하 생략.

<span class="hljs-keyword">class</span> <span class="hljs-title class_">GameStatistics</span>(db.<span class="hljs-property">Model</span>, <span class="hljs-title class_">SerializerMixin</span>):
    __tablename__ = <span class="hljs-string">'gameStatistics'</span>

    위의 <span class="hljs-title class_">User</span> 클래스와 유사한 형태입니다. 이하 생략.
</code></pre>
<p>이제 사용자 정보를 모두 보유한 데이터베이스, 게임에 대한 모든 세부 정보를 보유한 데이터베이스, 이 둘 사이에서 중개 역할을 하는 세 번째 테이블이 있습니다. 외래 키를 사용하여 통계와 게임, 사용자 간의 연관을 볼 수 있습니다. 데이터베이스가 다른 테이블의 열에 연결되어 있는지 알 수 있게 됩니다. 사용자는 많은 게임과 연관을 갖을 수 있고, 게임은 해당 게임에 댓글을 남기거나 즐겨찾기에 추가한 많은 사용자들을 가질 수 있습니다. 이에 대한 데이터를 완전히 새로운 테이블에 보유해야 합니다. 사용자와 게임을 식별하는 새로운 테이블을 생성합니다. 마지막으로 API가 관련 클래스의 모든 세부 정보를 보여줄 수 있도록 SQLAlchemy의 association proxy를 사용하여 관계를 생성합니다.</p>
<h1>프론트 엔드</h1>
<p>이제 스스로 묻고 있을 수 있습니다. "왜 프론트 엔드로 건너뛰나요? 아직 백엔드 루트를 만들지 않았는데요!" 맞습니다! 그러나 프론트 엔드에서 필요한 기능이 무엇인지 알 때 백엔드 루트를 만드는 것이 더 쉬울 수 있습니다. 특정 게임에 대한 모든 댓글이 해당 게임 페이지에 나타나게 하려면? 사용자가 지금까지 한 모든 댓글이 프로필 페이지에 나타나야 하나요? 사용자가 즐겨찾기한 것을 어디에서 렌더링하고 있나요? 사용자가 게임을 즐겨찾기했는지 여부는 게임 페이지에 나타나길 원하시나요? 다른 곳? 위시리스트도 어떻게 하나요? 동적으로 렌더링하면서 즐겨찾기한 경우 데이터베이스를 변경하고 싶으실 텐데요?</p>
<p>휴우! 프론트 엔드의 모든 렌더링과 기능을 계획하는 일은 많은 노력이 필요할 수 있지만, API를 위한 백엔드 루트를 만드는 것은 훨씬 간단해집니다. 위에서 나열된 옵션 중 일부만 가져와서 백엔드에 필요한 루트에 대해 이야기해보겠습니다:</p>
<ul>
<li>게임 상세 페이지에 게임의 모든 코멘트를 나열합니다.</li>
<li>즐겨찾기한 게임을 즐겨찾기 페이지에서 나열합니다.</li>
<li>위시리스트 버튼을 동적으로 렌더링하고 데이터베이스를 변경합니다.</li>
</ul>
<h1>코멘트</h1>
<p>게임 상세 페이지에서 단일 게임의 코멘트만 렌더링하는 기본적인 방법을 살펴봅시다. 프론트엔드는 다음과 같이 보일 수 있습니다. 프론트 엔드 라우트에서 사용되는 게임 ID에 대해 모든 게임 통계를 얻기 위해 백엔드 URL로 fetch 요청을 수행하고, React State를 응답으로 설정한 다음 해당 상태를 사용하여 목록을 반복하고 각 반환된 게임 통계에 대해 코멘트, 평점, 사용자를 표시하는 Review Card를 만들어야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { useParams, <span class="hljs-title class_">Link</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-router-dom'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">GameReviewCard</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../components/GameReviewCard'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">GameDetail</span>(<span class="hljs-params">{ user }</span>) {
  <span class="hljs-comment">// URL 파라미터에서 게임 ID를 가져옵니다.</span>
  <span class="hljs-keyword">const</span> { id } = <span class="hljs-title function_">useParams</span>();
  <span class="hljs-comment">// 게임 통계를 저장할 상태</span>
  <span class="hljs-keyword">const</span> [gameStats, setGameStats] = <span class="hljs-title function_">useState</span>([]);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
       <span class="hljs-title function_">fetch</span>(back_end_url) <span class="hljs-comment">//아직 이 변수를 정의하지 않았음을 참고해 주세요. </span>
      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> res.<span class="hljs-title function_">json</span>())
      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> <span class="hljs-title function_">setGameStats</span>(data))
      .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Box</span> <span class="hljs-attr">sx</span>=<span class="hljs-string">{</span> <span class="hljs-attr">mt:</span> <span class="hljs-attr">2</span> }></span>
            {gameStats.length > 0 ? (
              gameStats.map((stat) => (
                <span class="hljs-tag">&#x3C;<span class="hljs-name">GameReviewCard</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{stat.game_stats_id}</span> <span class="hljs-attr">gameStats</span>=<span class="hljs-string">{stat}</span> /></span>
              ))
            ) : (
              <span class="hljs-tag">&#x3C;<span class="hljs-name">Typography</span>></span>리뷰가 없습니다.<span class="hljs-tag">&#x3C;/<span class="hljs-name">Typography</span>></span>
            )}
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">Box</span>></span></span>
  );
</code></pre>
<p>지금, 이 back-end route를 살펴보겠어요. 여러분이 fetch 문에서 <code>back_end_url</code>로 넣을 내용은 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GameStatsByGameID</span>(<span class="hljs-title class_">Resource</span>):
    # 이는 특정 게임에 대한 모든 댓글과 평가를 가져와 개별 게임 페이지에 표시합니다
    def <span class="hljs-title function_">get</span>(self, game_id): 
        gamestats = [gamestat.<span class="hljs-title function_">to_dict</span>() <span class="hljs-keyword">for</span> gamestat <span class="hljs-keyword">in</span> <span class="hljs-title class_">GameStatistics</span>.<span class="hljs-property">query</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">GameStatistics</span>.<span class="hljs-property">game_id</span> == game_id, <span class="hljs-title class_">GameStatistics</span>.<span class="hljs-property">comments</span> != <span class="hljs-title class_">None</span>).<span class="hljs-title function_">all</span>()]
        <span class="hljs-keyword">if</span> <span class="hljs-attr">gamestats</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">make_response</span>(gamestats)
        <span class="hljs-attr">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">make_response</span>({<span class="hljs-string">'error'</span>: [<span class="hljs-string">'아직 리뷰가 없습니다'</span>]})

api.<span class="hljs-title function_">add_resource</span>(<span class="hljs-title class_">GameStatsByGameID</span>, <span class="hljs-string">'/game-statistic/&#x3C;int:game_id>'</span>)
</code></pre>
<p>이 route의 가장 중요한 부분은 우리가 하는 데이터베이스 쿼리입니다. 게임 ID(우리는 front-end route로부터 가져온 것)를 전달하고, 그 ID를 사용하여 전체 게임 통계 데이터베이스를 훑어서 해당 특정 게임과 관련된 모든 인스턴스를 추출합니다. filter 내부의 쿼리의 두 번째 부분은 실제로 존재하는 댓글만 추출하도록 하는 것입니다(기억하세요, 우리는 게임 통계 테이블에 Favorite와 Wishlist와 같은 것들도 저장하지만 페이지의 댓글 섹션에 렌더링되지 않길 원합니다!). 이제 반환된 결과를 사용하여 댓글/리뷰 카드를 렌더링할 수 있습니다! 그리고 front-end에서는 useParams에서 game_id를 가져오기 위해 fetch 요청에서 <code>back_end_url</code>을 <code>/game-statistic/$'id'</code>로 설정할 수 있어요.</p>
<h1>즐겨찾기</h1>
<p>즐겨찾기 기능도 비슷한 방식으로 작동하지만, 사용자 ID와 특정 게임 ID가 아닌 사용자 ID와 관련된 게임 통계를 쿼리하는 새로운 백앤드 루트가 필요합니다. 또한 즐겨찾기한 게임 통계만 쿼리 결과로 포함하고 싶습니다. 그래서 우리의 프런트엔드는 다음과 같이 간단하게 보일 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect, useParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">FavoritesGameCard</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@/components/FavoritesGameCard.jsx'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Favorites</span>(<span class="hljs-params">{ user }</span>) {
  <span class="hljs-keyword">const</span> [games, setGames] = <span class="hljs-title function_">useState</span>([]);
  <span class="hljs-keyword">const</span> [deleteGame, setDeleteGame] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">if</span> (user &#x26;&#x26; user.<span class="hljs-property">id</span>) {
      <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`http://localhost:8080/favorites/<span class="hljs-subst">${user.id}</span>`</span>)
        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> {
          <span class="hljs-keyword">if</span> (res.<span class="hljs-property">ok</span>) {
            <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">json</span>();
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">"GET 요청 중에 문제가 발생했습니다"</span>);
          }
        })
        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">gameData</span>) =></span> {
          <span class="hljs-title function_">setGames</span>(gameData);
        });
    }
  }, [user, deleteGame]);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleUnfavorite</span> = (<span class="hljs-params">gameId</span>) => {
    <span class="hljs-title function_">setGames</span>(games.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">game</span>) =></span> game.<span class="hljs-property">id</span> !== gameId));
    <span class="hljs-title function_">setDeleteGame</span>(<span class="hljs-function">(<span class="hljs-params">prev</span>) =></span> !prev);
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      {!games ? (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"no-favorites-message"</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">h2</span>></span>아직 즐겨찾기한 게임이 없습니다<span class="hljs-tag">&#x3C;/<span class="hljs-name">h2</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      ) : (
        <span class="hljs-tag">&#x3C;></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"game-cards-container"</span>></span>
            {games.map((game) => (
              <span class="hljs-tag">&#x3C;<span class="hljs-name">FavoritesGameCard</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{game.id}</span> <span class="hljs-attr">game</span>=<span class="hljs-string">{game}</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> <span class="hljs-attr">handleUnfavorite</span>=<span class="hljs-string">{handleUnfavorite}</span> /></span>
            )}
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;/></span></span>
      )}
    &#x3C;/div>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Favorites</span>;
</code></pre>
<p>새로운 백앤드 루트와 ID를 백앤드로 보내는 새로운 방법을 알 수 있을 것입니다. 우리는 현재 로그인한 사용자를 React 상태에 유지하여 해당 사용자에 대한 정보가 필요한 컴포넌트에 전달할 수 있습니다 (이 경우에는 ID가 필요합니다). 백앤드 루트와 쿼리는 다음과 같이 구성되어 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FavoritesByUser</span>(<span class="hljs-title class_">Resource</span>):
    def <span class="hljs-title function_">get</span>(self, user_id):
        favorites = [gamestat.<span class="hljs-property">game</span>.<span class="hljs-title function_">to_dict</span>() <span class="hljs-keyword">for</span> gamestat <span class="hljs-keyword">in</span> <span class="hljs-title class_">GameStatistics</span>.<span class="hljs-property">query</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">GameStatistics</span>.<span class="hljs-property">user_id</span>==user_id, <span class="hljs-title class_">GameStatistics</span>.<span class="hljs-property">favorited</span>==<span class="hljs-title class_">True</span>).<span class="hljs-title function_">all</span>()]
        <span class="hljs-keyword">if</span> <span class="hljs-attr">favorites</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">make_response</span>(favorites)
        <span class="hljs-attr">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">make_response</span>({<span class="hljs-string">'error'</span>: [<span class="hljs-string">'아직 즐겨찾기한 게임이 없습니다'</span>]})
        
api.<span class="hljs-title function_">add_resource</span>(<span class="hljs-title class_">FavoritesByUser</span>, <span class="hljs-string">'/favorites/&#x3C;int:user_id>'</span>)
</code></pre>
<p>알았어요! 이제, 즐겨찾기 및 위시리스트 관련 기능에 대해 더 이야기해보겠어요.</p>
<h1>위시리스트 버튼</h1>
<p>게임을 즐겨찾기 하는 방법은 React State를 활용하는 위시리스트 버튼을 구현하는 것으로 결정했어요. 이 버튼은 부모 컴포넌트로부터 전달된 prop과 이 컴포넌트 자체의 네이티브 state를 활용하여 사용자와 게임에 관련된 게임 통계를 확인하고 이에 맞게 렌더링하는 기능을 제공해요. 부모 컴포넌트로부터 넘어온 gameStatId 상태를 사용하여 데이터베이스로 fetch 요청을 보내 현재 로그인한 사용자의 ID(기억해요, 사용자 정보는 이미 state에 저장되어 있어요)와 현재 보고 있는 게임 상세 페이지의 게임 ID에 해당하는 게임 통계의 인스턴스가 있는지 확인해요. 만약 해당 인스턴스가 있다면 gameStateId를 업데이트하고 해당 상태를 버튼으로 전달해요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@mui/material/Button'</span>; <span class="hljs-comment">// Material-UI에서 Button 가져오기</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">StarIcon</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@mui/icons-material/Star'</span>; <span class="hljs-comment">// Material-UI에서 즐겨찾기 아이콘 가져오기</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">StarBorderIcon</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@mui/icons-material/StarBorder'</span>; <span class="hljs-comment">// Material-UI에서 즐겨찾기 해제 아이콘 가져오기</span>

<span class="hljs-comment">// gameId와 userId를 prop으로 전달받는 함수형 컴포넌트 WishlistButton 정의</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">WishlistButton</span>(<span class="hljs-params">{ gameId, userId, gameStatId, updateGameStatId}</span>) {
  
  <span class="hljs-comment">// 게임을 위시리스트에 추가했는지 추적하는 상태</span>
  <span class="hljs-keyword">const</span> [isWishlisted, setIsWishlisted] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);

  <span class="hljs-comment">// 게임 통계를 가져오는 useEffect 훅, gameId 또는 userId가 변경될 때 실행</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-comment">// 현재 사용자와 게임에 대한 게임 통계 가져오기</span>
    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`http://localhost:8080/game-statistics/<span class="hljs-subst">${gameId}</span>/<span class="hljs-subst">${userId}</span>`</span>)
      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> res.<span class="hljs-title function_">json</span>())
      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
        <span class="hljs-comment">// 게임 통계가 있는 경우 상태 업데이트</span>
        <span class="hljs-keyword">if</span> (data.<span class="hljs-property">game_stats_id</span>) {
          <span class="hljs-title function_">setIsWishlisted</span>(data.<span class="hljs-property">wish_listed</span>);
          <span class="hljs-title function_">updateGameStatId</span>(data.<span class="hljs-property">game_stats_id</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// 게임 통계가 없는 경우 기본 상태로 설정</span>
          <span class="hljs-title function_">setIsWishlisted</span>(<span class="hljs-literal">false</span>);
          <span class="hljs-title function_">updateGameStatId</span>(<span class="hljs-literal">null</span>);
        }
      });
  }, [gameId, userId]); <span class="hljs-comment">// useEffect의 의존성 배열</span>

  <span class="hljs-comment">// 위시리스트 버튼 클릭 처리 함수</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleWishlist</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-comment">// 게임 통계 인스턴스가 있는 경우 위시리스트 상태 업데이트</span>
    <span class="hljs-keyword">if</span> (gameStatId) {
      <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`http://localhost:8080/game-statistics/<span class="hljs-subst">${gameId}</span>/<span class="hljs-subst">${userId}</span>`</span>, {
        <span class="hljs-attr">method</span>: <span class="hljs-string">'PATCH'</span>, <span class="hljs-comment">// 기존 데이터 업데이트용 PATCH 메소드 사용</span>
        <span class="hljs-attr">headers</span>: {
          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
        },
        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">wish_listed</span>: !isWishlisted }), <span class="hljs-comment">// 위시리스트 상태 토글</span>
      })
        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> res.<span class="hljs-title function_">json</span>())
        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> <span class="hljs-title function_">setIsWishlisted</span>(data.<span class="hljs-property">wish_listed</span>)); <span class="hljs-comment">// 새로운 위시리스트 상태로 상태 업데이트</span>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 게임 통계 인스턴스가 없는 경우 새로운 위시리스트 생성</span>
      <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`http://localhost:8080/game-statistics`</span>, {
        <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-comment">// 새 데이터 생성용 POST 메소드 사용</span>
        <span class="hljs-attr">headers</span>: {
          <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
        },
        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
          <span class="hljs-attr">user_id</span>: userId,
          <span class="hljs-attr">game_id</span>: gameId,
          <span class="hljs-attr">wish_listed</span>: <span class="hljs-literal">true</span>,
        }),
      })
        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =></span> res.<span class="hljs-title function_">json</span>())
        .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
          <span class="hljs-comment">// 새 게임 통계 데이터로 상태 업데이트</span>
          <span class="hljs-title function_">setIsWishlisted</span>(<span class="hljs-literal">true</span>);
          <span class="hljs-title function_">updateGameStatId</span>(data.<span class="hljs-property">game_stats_id</span>);
        });
    }
  };

  <span class="hljs-comment">// 위시리스트 버튼 동적 텍스트 및 아이콘을 기반으로 렌더링</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"wishlist-container"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Button</span>
        <span class="hljs-attr">variant</span>=<span class="hljs-string">"contained"</span>
        <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>
        <span class="hljs-attr">startIcon</span>=<span class="hljs-string">{isWishlisted</span> ? &#x3C;<span class="hljs-attr">StarIcon</span> /></span> : <span class="hljs-tag">&#x3C;<span class="hljs-name">StarBorderIcon</span> /></span>}
        onClick={handleWishlist}
      >
        {isWishlisted ? '위시리스트에서 제거' : '위시리스트에 추가'}
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">Button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">WishlistButton</span>; <span class="hljs-comment">// 다른 부분에서 사용할 수 있도록 WishlistButton 컴포넌트 내보내기</span>
</code></pre>
<p>만약 해당 인스턴스가 이미 존재한다면(예: 사용자가 이 게임에 댓글을 달았거나 위시리스트에 추가했을 경우), 위시리스트 버튼을 클릭하면 데이터베이스에서 해당 게임 통계를 업데이트하기 위해 서버로 PATCH 요청이 전송됩니다. 아직 인스턴스가 존재하지 않은 경우, POST 요청을 보내고 모든 다른 버튼들(위시리스트 및 댓글 등)의 상태를 업데이트하여 이후 PATCH 요청을 보냅니다. 그런 다음, 확실히 isWishlisted 상태를 사용하여 페이지에서 조건부 렌더링을 수행하여 버튼을 "위시리스트에서 제거" 또는 "위시리스트에 추가"로 표시하게 됩니다.</p>
<p>사용자와 상호 작용할 때 프론트엔드와 백엔드를 연결하는 몇 가지 방법 중 일부입니다. SerializerMixin 및 직렬화 규칙과 같은 것들을 사용하면 백엔드에서 반환되는 데이터를 더욱 구체적으로 얻을 수 있습니다. 매우 구체적인 라우팅을 만드는 것은 시간이 소모되고 때로는 중복된 느낌을 줄 수 있지만, 데이터베이스에 많은 양의 정보가 저장된 경우 메모리 및 로드 시간을 줄일 수도 있습니다.</p>
<p>좋은 코딩 되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"댓글, 모델, 그리고 사용자들- 어머나 개별 사용자를 위한 풀 스택 기능 생성하기","description":"","date":"2024-05-12 21:57","slug":"2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers_0.png\" /\u003e\n\n프론트엔드와 백엔드 프로그래밍에 대해 충분히 배웠다면, 풀스택 애플리케이션을 구축한 후에 할 일은 아마도 다른 사용자가 응용 프로그램에 로그인하고 로그인한 사용자에 맞게 사이트의 특정 세부 정보를 제공할 수 있도록 하는 것일 것입니다. 이제 데이터베이스와 모델에 대한 지식을 활용하여 그 모든 정보를 저장할 데이터베이스(또는 여러 개)를 만들 수 있습니다. 지금, 사용자의 로그인 유효성 검사 및 암호화에 필요한 모든 사항에 대해 다루지는 않겠습니다(그것은 다른 블로그 게시물이 되겠죠), 하지만 사용자가 댓글을 달거나 평가할 수 있도록 허용하는 백엔드 구조 및 해당 구조를 클라이언트 측에서 사용하여 현재 사용자에 대한 특정 정보를 렌더링하는 방법에 대해서 이야기해보려고 합니다.\n\n# 모델\n\n아래에는 우리의 User 클래스에 대한 상당히 기본적인 모델과 Flask/SQLAlchemy를 통해 생성될 데이터베이스 테이블이 있으며, 그 관계들이 포함되어 있습니다.\n\n\n\n```js\nfrom sqlalchemy_serializer를 SerializerMixin에 import합니다.\nSQLAlchemy.ext.associationproxy에서 association_proxy도 import합니다.\n\nconfig에서 db를 import하고 User 클래스를 만듭니다. User 클래스는 db.Model과 SerializerMixin을 상속받습니다.\n아래는 User 클래스의 일부분입니다.\n\n__tablename__ = 'users'\nid = db.Column(db.Integer, primary_key=True)\nusername = db.Column(db.String)\n_password_hash = db.Column(db.String)\n\ngame_statistics = db.relationship('GameStatistics', back_populates='user', cascade='all, delete-orphan')\ngames = association_proxy('game_statistics', 'game')\n\nserialize_rules = ('-game_statistics',)\n\n사용자의 사용자 이름과 비밀번호를 저장하고 다른 데이터베이스와의 관계를 만들어 추가 정보를 보유하려고 합니다. 게임 등급 애플리케이션을 개발하고 사용자가 게임을 \"좋아요\"하거나 게임에 댓글/평가를 남기거나 게임을 위시리스트에 추가할 수 있도록 했으며, 각각의 기능은 특정 게임에 관한 것이어야 합니다. 이 애플리케이션에는 많은 게임이 있기 때문에 사용자와 게임 사이의 다대다 관계를 만들기 위해 사용자당 게임별로 좋아요, 위시리스트, 댓글 및 등급에 관한 모든 정보를 보유할 다른 데이터베이스가 필요합니다.\n\n아래에는 다른 두 클래스 (그리고 이에 따른 Flask와 SQLAlchemy를 통한 테이블)의 간소화된 버전이 있습니다.\n\nclass Game(db.Model, SerializerMixin):\n    __tablename__ = 'games'\n\n    위의 User 클래스와 유사한 형태입니다. 이하 생략.\n\nclass GameStatistics(db.Model, SerializerMixin):\n    __tablename__ = 'gameStatistics'\n\n    위의 User 클래스와 유사한 형태입니다. 이하 생략.\n```\n\n\n\n이제 사용자 정보를 모두 보유한 데이터베이스, 게임에 대한 모든 세부 정보를 보유한 데이터베이스, 이 둘 사이에서 중개 역할을 하는 세 번째 테이블이 있습니다. 외래 키를 사용하여 통계와 게임, 사용자 간의 연관을 볼 수 있습니다. 데이터베이스가 다른 테이블의 열에 연결되어 있는지 알 수 있게 됩니다. 사용자는 많은 게임과 연관을 갖을 수 있고, 게임은 해당 게임에 댓글을 남기거나 즐겨찾기에 추가한 많은 사용자들을 가질 수 있습니다. 이에 대한 데이터를 완전히 새로운 테이블에 보유해야 합니다. 사용자와 게임을 식별하는 새로운 테이블을 생성합니다. 마지막으로 API가 관련 클래스의 모든 세부 정보를 보여줄 수 있도록 SQLAlchemy의 association proxy를 사용하여 관계를 생성합니다.\n\n# 프론트 엔드\n\n이제 스스로 묻고 있을 수 있습니다. \"왜 프론트 엔드로 건너뛰나요? 아직 백엔드 루트를 만들지 않았는데요!\" 맞습니다! 그러나 프론트 엔드에서 필요한 기능이 무엇인지 알 때 백엔드 루트를 만드는 것이 더 쉬울 수 있습니다. 특정 게임에 대한 모든 댓글이 해당 게임 페이지에 나타나게 하려면? 사용자가 지금까지 한 모든 댓글이 프로필 페이지에 나타나야 하나요? 사용자가 즐겨찾기한 것을 어디에서 렌더링하고 있나요? 사용자가 게임을 즐겨찾기했는지 여부는 게임 페이지에 나타나길 원하시나요? 다른 곳? 위시리스트도 어떻게 하나요? 동적으로 렌더링하면서 즐겨찾기한 경우 데이터베이스를 변경하고 싶으실 텐데요?\n\n휴우! 프론트 엔드의 모든 렌더링과 기능을 계획하는 일은 많은 노력이 필요할 수 있지만, API를 위한 백엔드 루트를 만드는 것은 훨씬 간단해집니다. 위에서 나열된 옵션 중 일부만 가져와서 백엔드에 필요한 루트에 대해 이야기해보겠습니다:\n\n\n\n- 게임 상세 페이지에 게임의 모든 코멘트를 나열합니다.\n- 즐겨찾기한 게임을 즐겨찾기 페이지에서 나열합니다.\n- 위시리스트 버튼을 동적으로 렌더링하고 데이터베이스를 변경합니다.\n\n# 코멘트\n\n게임 상세 페이지에서 단일 게임의 코멘트만 렌더링하는 기본적인 방법을 살펴봅시다. 프론트엔드는 다음과 같이 보일 수 있습니다. 프론트 엔드 라우트에서 사용되는 게임 ID에 대해 모든 게임 통계를 얻기 위해 백엔드 URL로 fetch 요청을 수행하고, React State를 응답으로 설정한 다음 해당 상태를 사용하여 목록을 반복하고 각 반환된 게임 통계에 대해 코멘트, 평점, 사용자를 표시하는 Review Card를 만들어야 합니다.\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport { useParams, Link } from 'react-router-dom';\nimport GameReviewCard from '../components/GameReviewCard';\n\nfunction GameDetail({ user }) {\n  // URL 파라미터에서 게임 ID를 가져옵니다.\n  const { id } = useParams();\n  // 게임 통계를 저장할 상태\n  const [gameStats, setGameStats] = useState([]);\n\n  useEffect(() =\u003e {\n       fetch(back_end_url) //아직 이 변수를 정의하지 않았음을 참고해 주세요. \n      .then((res) =\u003e res.json())\n      .then((data) =\u003e setGameStats(data))\n      .catch((error) =\u003e console.error(error));\n  return (\n    \u003cBox sx={ mt: 2 }\u003e\n            {gameStats.length \u003e 0 ? (\n              gameStats.map((stat) =\u003e (\n                \u003cGameReviewCard key={stat.game_stats_id} gameStats={stat} /\u003e\n              ))\n            ) : (\n              \u003cTypography\u003e리뷰가 없습니다.\u003c/Typography\u003e\n            )}\n          \u003c/Box\u003e\n  );\r\n```\n\n\n\n지금, 이 back-end route를 살펴보겠어요. 여러분이 fetch 문에서 `back_end_url`로 넣을 내용은 다음과 같습니다:\n\n```js\nclass GameStatsByGameID(Resource):\n    # 이는 특정 게임에 대한 모든 댓글과 평가를 가져와 개별 게임 페이지에 표시합니다\n    def get(self, game_id): \n        gamestats = [gamestat.to_dict() for gamestat in GameStatistics.query.filter(GameStatistics.game_id == game_id, GameStatistics.comments != None).all()]\n        if gamestats:\n            return make_response(gamestats)\n        else:\n            return make_response({'error': ['아직 리뷰가 없습니다']})\n\napi.add_resource(GameStatsByGameID, '/game-statistic/\u003cint:game_id\u003e')\n```\n\n이 route의 가장 중요한 부분은 우리가 하는 데이터베이스 쿼리입니다. 게임 ID(우리는 front-end route로부터 가져온 것)를 전달하고, 그 ID를 사용하여 전체 게임 통계 데이터베이스를 훑어서 해당 특정 게임과 관련된 모든 인스턴스를 추출합니다. filter 내부의 쿼리의 두 번째 부분은 실제로 존재하는 댓글만 추출하도록 하는 것입니다(기억하세요, 우리는 게임 통계 테이블에 Favorite와 Wishlist와 같은 것들도 저장하지만 페이지의 댓글 섹션에 렌더링되지 않길 원합니다!). 이제 반환된 결과를 사용하여 댓글/리뷰 카드를 렌더링할 수 있습니다! 그리고 front-end에서는 useParams에서 game_id를 가져오기 위해 fetch 요청에서 `back_end_url`을 `/game-statistic/$'id'`로 설정할 수 있어요.\n\n# 즐겨찾기\n\n\n\n즐겨찾기 기능도 비슷한 방식으로 작동하지만, 사용자 ID와 특정 게임 ID가 아닌 사용자 ID와 관련된 게임 통계를 쿼리하는 새로운 백앤드 루트가 필요합니다. 또한 즐겨찾기한 게임 통계만 쿼리 결과로 포함하고 싶습니다. 그래서 우리의 프런트엔드는 다음과 같이 간단하게 보일 수 있습니다:\n\n```js\nimport React, { useState, useEffect, useParams } from 'react';\nimport FavoritesGameCard from '@/components/FavoritesGameCard.jsx';\n\nfunction Favorites({ user }) {\n  const [games, setGames] = useState([]);\n  const [deleteGame, setDeleteGame] = useState(false);\n\n  useEffect(() =\u003e {\n    if (user \u0026\u0026 user.id) {\n      fetch(`http://localhost:8080/favorites/${user.id}`)\n        .then((res) =\u003e {\n          if (res.ok) {\n            return res.json();\n          } else {\n            return console.error(\"GET 요청 중에 문제가 발생했습니다\");\n          }\n        })\n        .then((gameData) =\u003e {\n          setGames(gameData);\n        });\n    }\n  }, [user, deleteGame]);\n\n  const handleUnfavorite = (gameId) =\u003e {\n    setGames(games.filter((game) =\u003e game.id !== gameId));\n    setDeleteGame((prev) =\u003e !prev);\n  };\n\n  return (\n    \u003cdiv\u003e\n      {!games ? (\n        \u003cdiv className=\"no-favorites-message\"\u003e\n          \u003ch2\u003e아직 즐겨찾기한 게임이 없습니다\u003c/h2\u003e\n        \u003c/div\u003e\n      ) : (\n        \u003c\u003e\n          \u003cdiv className=\"game-cards-container\"\u003e\n            {games.map((game) =\u003e (\n              \u003cFavoritesGameCard key={game.id} game={game} user={user} handleUnfavorite={handleUnfavorite} /\u003e\n            )}\n          \u003c/div\u003e\n        \u003c/\u003e\n      )}\n    \u003c/div\u003e\n  );\n}\n\nexport default Favorites;\n```\n\n새로운 백앤드 루트와 ID를 백앤드로 보내는 새로운 방법을 알 수 있을 것입니다. 우리는 현재 로그인한 사용자를 React 상태에 유지하여 해당 사용자에 대한 정보가 필요한 컴포넌트에 전달할 수 있습니다 (이 경우에는 ID가 필요합니다). 백앤드 루트와 쿼리는 다음과 같이 구성되어 있습니다:\n\n```js\nclass FavoritesByUser(Resource):\n    def get(self, user_id):\n        favorites = [gamestat.game.to_dict() for gamestat in GameStatistics.query.filter(GameStatistics.user_id==user_id, GameStatistics.favorited==True).all()]\n        if favorites:\n            return make_response(favorites)\n        else:\n            return make_response({'error': ['아직 즐겨찾기한 게임이 없습니다']})\n        \napi.add_resource(FavoritesByUser, '/favorites/\u003cint:user_id\u003e')\n```\n\n\n\n알았어요! 이제, 즐겨찾기 및 위시리스트 관련 기능에 대해 더 이야기해보겠어요.\n\n# 위시리스트 버튼\n\n게임을 즐겨찾기 하는 방법은 React State를 활용하는 위시리스트 버튼을 구현하는 것으로 결정했어요. 이 버튼은 부모 컴포넌트로부터 전달된 prop과 이 컴포넌트 자체의 네이티브 state를 활용하여 사용자와 게임에 관련된 게임 통계를 확인하고 이에 맞게 렌더링하는 기능을 제공해요. 부모 컴포넌트로부터 넘어온 gameStatId 상태를 사용하여 데이터베이스로 fetch 요청을 보내 현재 로그인한 사용자의 ID(기억해요, 사용자 정보는 이미 state에 저장되어 있어요)와 현재 보고 있는 게임 상세 페이지의 게임 ID에 해당하는 게임 통계의 인스턴스가 있는지 확인해요. 만약 해당 인스턴스가 있다면 gameStateId를 업데이트하고 해당 상태를 버튼으로 전달해요.\n\n```js\nimport React, { useState, useEffect } from 'react';\nimport Button from '@mui/material/Button'; // Material-UI에서 Button 가져오기\nimport StarIcon from '@mui/icons-material/Star'; // Material-UI에서 즐겨찾기 아이콘 가져오기\nimport StarBorderIcon from '@mui/icons-material/StarBorder'; // Material-UI에서 즐겨찾기 해제 아이콘 가져오기\n\n// gameId와 userId를 prop으로 전달받는 함수형 컴포넌트 WishlistButton 정의\nfunction WishlistButton({ gameId, userId, gameStatId, updateGameStatId}) {\n  \n  // 게임을 위시리스트에 추가했는지 추적하는 상태\n  const [isWishlisted, setIsWishlisted] = useState(false);\n\n  // 게임 통계를 가져오는 useEffect 훅, gameId 또는 userId가 변경될 때 실행\n  useEffect(() =\u003e {\n    // 현재 사용자와 게임에 대한 게임 통계 가져오기\n    fetch(`http://localhost:8080/game-statistics/${gameId}/${userId}`)\n      .then((res) =\u003e res.json())\n      .then((data) =\u003e {\n        // 게임 통계가 있는 경우 상태 업데이트\n        if (data.game_stats_id) {\n          setIsWishlisted(data.wish_listed);\n          updateGameStatId(data.game_stats_id);\n        } else {\n          // 게임 통계가 없는 경우 기본 상태로 설정\n          setIsWishlisted(false);\n          updateGameStatId(null);\n        }\n      });\n  }, [gameId, userId]); // useEffect의 의존성 배열\n\n  // 위시리스트 버튼 클릭 처리 함수\n  const handleWishlist = () =\u003e {\n    // 게임 통계 인스턴스가 있는 경우 위시리스트 상태 업데이트\n    if (gameStatId) {\n      fetch(`http://localhost:8080/game-statistics/${gameId}/${userId}`, {\n        method: 'PATCH', // 기존 데이터 업데이트용 PATCH 메소드 사용\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ wish_listed: !isWishlisted }), // 위시리스트 상태 토글\n      })\n        .then((res) =\u003e res.json())\n        .then((data) =\u003e setIsWishlisted(data.wish_listed)); // 새로운 위시리스트 상태로 상태 업데이트\n    } else {\n      // 게임 통계 인스턴스가 없는 경우 새로운 위시리스트 생성\n      fetch(`http://localhost:8080/game-statistics`, {\n        method: 'POST', // 새 데이터 생성용 POST 메소드 사용\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          user_id: userId,\n          game_id: gameId,\n          wish_listed: true,\n        }),\n      })\n        .then((res) =\u003e res.json())\n        .then((data) =\u003e {\n          // 새 게임 통계 데이터로 상태 업데이트\n          setIsWishlisted(true);\n          updateGameStatId(data.game_stats_id);\n        });\n    }\n  };\n\n  // 위시리스트 버튼 동적 텍스트 및 아이콘을 기반으로 렌더링\n  return (\n    \u003cdiv className=\"wishlist-container\"\u003e\n      \u003cButton\n        variant=\"contained\"\n        color=\"primary\"\n        startIcon={isWishlisted ? \u003cStarIcon /\u003e : \u003cStarBorderIcon /\u003e}\n        onClick={handleWishlist}\n      \u003e\n        {isWishlisted ? '위시리스트에서 제거' : '위시리스트에 추가'}\n      \u003c/Button\u003e\n    \u003c/div\u003e\n  );\n}\n\nexport default WishlistButton; // 다른 부분에서 사용할 수 있도록 WishlistButton 컴포넌트 내보내기\n```\n\n\n\n만약 해당 인스턴스가 이미 존재한다면(예: 사용자가 이 게임에 댓글을 달았거나 위시리스트에 추가했을 경우), 위시리스트 버튼을 클릭하면 데이터베이스에서 해당 게임 통계를 업데이트하기 위해 서버로 PATCH 요청이 전송됩니다. 아직 인스턴스가 존재하지 않은 경우, POST 요청을 보내고 모든 다른 버튼들(위시리스트 및 댓글 등)의 상태를 업데이트하여 이후 PATCH 요청을 보냅니다. 그런 다음, 확실히 isWishlisted 상태를 사용하여 페이지에서 조건부 렌더링을 수행하여 버튼을 \"위시리스트에서 제거\" 또는 \"위시리스트에 추가\"로 표시하게 됩니다.\n\n사용자와 상호 작용할 때 프론트엔드와 백엔드를 연결하는 몇 가지 방법 중 일부입니다. SerializerMixin 및 직렬화 규칙과 같은 것들을 사용하면 백엔드에서 반환되는 데이터를 더욱 구체적으로 얻을 수 있습니다. 매우 구체적인 라우팅을 만드는 것은 시간이 소모되고 때로는 중복된 느낌을 줄 수 있지만, 데이터베이스에 많은 양의 정보가 저장된 경우 메모리 및 로드 시간을 줄일 수도 있습니다.\n\n좋은 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers_0.png"},"coverImage":"/assets/img/2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e프론트엔드와 백엔드 프로그래밍에 대해 충분히 배웠다면, 풀스택 애플리케이션을 구축한 후에 할 일은 아마도 다른 사용자가 응용 프로그램에 로그인하고 로그인한 사용자에 맞게 사이트의 특정 세부 정보를 제공할 수 있도록 하는 것일 것입니다. 이제 데이터베이스와 모델에 대한 지식을 활용하여 그 모든 정보를 저장할 데이터베이스(또는 여러 개)를 만들 수 있습니다. 지금, 사용자의 로그인 유효성 검사 및 암호화에 필요한 모든 사항에 대해 다루지는 않겠습니다(그것은 다른 블로그 게시물이 되겠죠), 하지만 사용자가 댓글을 달거나 평가할 수 있도록 허용하는 백엔드 구조 및 해당 구조를 클라이언트 측에서 사용하여 현재 사용자에 대한 특정 정보를 렌더링하는 방법에 대해서 이야기해보려고 합니다.\u003c/p\u003e\n\u003ch1\u003e모델\u003c/h1\u003e\n\u003cp\u003e아래에는 우리의 User 클래스에 대한 상당히 기본적인 모델과 Flask/SQLAlchemy를 통해 생성될 데이터베이스 테이블이 있으며, 그 관계들이 포함되어 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sqlalchemy_serializer를 \u003cspan class=\"hljs-title class_\"\u003eSerializerMixin\u003c/span\u003e에 \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e합니다.\n\u003cspan class=\"hljs-title class_\"\u003eSQLAlchemy\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eext\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eassociationproxy\u003c/span\u003e에서 association_proxy도 \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e합니다.\n\nconfig에서 db를 \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e하고 \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e 클래스를 만듭니다. \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e 클래스는 db.\u003cspan class=\"hljs-property\"\u003eModel\u003c/span\u003e과 \u003cspan class=\"hljs-title class_\"\u003eSerializerMixin\u003c/span\u003e을 상속받습니다.\n아래는 \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e 클래스의 일부분입니다.\n\n__tablename__ = \u003cspan class=\"hljs-string\"\u003e'users'\u003c/span\u003e\nid = db.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(db.\u003cspan class=\"hljs-property\"\u003eInteger\u003c/span\u003e, primary_key=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\nusername = db.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(db.\u003cspan class=\"hljs-property\"\u003eString\u003c/span\u003e)\n_password_hash = db.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(db.\u003cspan class=\"hljs-property\"\u003eString\u003c/span\u003e)\n\ngame_statistics = db.\u003cspan class=\"hljs-title function_\"\u003erelationship\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'GameStatistics'\u003c/span\u003e, back_populates=\u003cspan class=\"hljs-string\"\u003e'user'\u003c/span\u003e, cascade=\u003cspan class=\"hljs-string\"\u003e'all, delete-orphan'\u003c/span\u003e)\ngames = \u003cspan class=\"hljs-title function_\"\u003eassociation_proxy\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'game_statistics'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'game'\u003c/span\u003e)\n\nserialize_rules = (\u003cspan class=\"hljs-string\"\u003e'-game_statistics'\u003c/span\u003e,)\n\n사용자의 사용자 이름과 비밀번호를 저장하고 다른 데이터베이스와의 관계를 만들어 추가 정보를 보유하려고 합니다. 게임 등급 애플리케이션을 개발하고 사용자가 게임을 \u003cspan class=\"hljs-string\"\u003e\"좋아요\"\u003c/span\u003e하거나 게임에 댓글/평가를 남기거나 게임을 위시리스트에 추가할 수 있도록 했으며, 각각의 기능은 특정 게임에 관한 것이어야 합니다. 이 애플리케이션에는 많은 게임이 있기 때문에 사용자와 게임 사이의 다대다 관계를 만들기 위해 사용자당 게임별로 좋아요, 위시리스트, 댓글 및 등급에 관한 모든 정보를 보유할 다른 데이터베이스가 필요합니다.\n\n아래에는 다른 두 클래스 (그리고 이에 따른 \u003cspan class=\"hljs-title class_\"\u003eFlask\u003c/span\u003e와 \u003cspan class=\"hljs-title class_\"\u003eSQLAlchemy\u003c/span\u003e를 통한 테이블)의 간소화된 버전이 있습니다.\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGame\u003c/span\u003e(db.\u003cspan class=\"hljs-property\"\u003eModel\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eSerializerMixin\u003c/span\u003e):\n    __tablename__ = \u003cspan class=\"hljs-string\"\u003e'games'\u003c/span\u003e\n\n    위의 \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e 클래스와 유사한 형태입니다. 이하 생략.\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGameStatistics\u003c/span\u003e(db.\u003cspan class=\"hljs-property\"\u003eModel\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eSerializerMixin\u003c/span\u003e):\n    __tablename__ = \u003cspan class=\"hljs-string\"\u003e'gameStatistics'\u003c/span\u003e\n\n    위의 \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e 클래스와 유사한 형태입니다. 이하 생략.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 사용자 정보를 모두 보유한 데이터베이스, 게임에 대한 모든 세부 정보를 보유한 데이터베이스, 이 둘 사이에서 중개 역할을 하는 세 번째 테이블이 있습니다. 외래 키를 사용하여 통계와 게임, 사용자 간의 연관을 볼 수 있습니다. 데이터베이스가 다른 테이블의 열에 연결되어 있는지 알 수 있게 됩니다. 사용자는 많은 게임과 연관을 갖을 수 있고, 게임은 해당 게임에 댓글을 남기거나 즐겨찾기에 추가한 많은 사용자들을 가질 수 있습니다. 이에 대한 데이터를 완전히 새로운 테이블에 보유해야 합니다. 사용자와 게임을 식별하는 새로운 테이블을 생성합니다. 마지막으로 API가 관련 클래스의 모든 세부 정보를 보여줄 수 있도록 SQLAlchemy의 association proxy를 사용하여 관계를 생성합니다.\u003c/p\u003e\n\u003ch1\u003e프론트 엔드\u003c/h1\u003e\n\u003cp\u003e이제 스스로 묻고 있을 수 있습니다. \"왜 프론트 엔드로 건너뛰나요? 아직 백엔드 루트를 만들지 않았는데요!\" 맞습니다! 그러나 프론트 엔드에서 필요한 기능이 무엇인지 알 때 백엔드 루트를 만드는 것이 더 쉬울 수 있습니다. 특정 게임에 대한 모든 댓글이 해당 게임 페이지에 나타나게 하려면? 사용자가 지금까지 한 모든 댓글이 프로필 페이지에 나타나야 하나요? 사용자가 즐겨찾기한 것을 어디에서 렌더링하고 있나요? 사용자가 게임을 즐겨찾기했는지 여부는 게임 페이지에 나타나길 원하시나요? 다른 곳? 위시리스트도 어떻게 하나요? 동적으로 렌더링하면서 즐겨찾기한 경우 데이터베이스를 변경하고 싶으실 텐데요?\u003c/p\u003e\n\u003cp\u003e휴우! 프론트 엔드의 모든 렌더링과 기능을 계획하는 일은 많은 노력이 필요할 수 있지만, API를 위한 백엔드 루트를 만드는 것은 훨씬 간단해집니다. 위에서 나열된 옵션 중 일부만 가져와서 백엔드에 필요한 루트에 대해 이야기해보겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e게임 상세 페이지에 게임의 모든 코멘트를 나열합니다.\u003c/li\u003e\n\u003cli\u003e즐겨찾기한 게임을 즐겨찾기 페이지에서 나열합니다.\u003c/li\u003e\n\u003cli\u003e위시리스트 버튼을 동적으로 렌더링하고 데이터베이스를 변경합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e코멘트\u003c/h1\u003e\n\u003cp\u003e게임 상세 페이지에서 단일 게임의 코멘트만 렌더링하는 기본적인 방법을 살펴봅시다. 프론트엔드는 다음과 같이 보일 수 있습니다. 프론트 엔드 라우트에서 사용되는 게임 ID에 대해 모든 게임 통계를 얻기 위해 백엔드 URL로 fetch 요청을 수행하고, React State를 응답으로 설정한 다음 해당 상태를 사용하여 목록을 반복하고 각 반환된 게임 통계에 대해 코멘트, 평점, 사용자를 표시하는 Review Card를 만들어야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState, useEffect } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useParams, \u003cspan class=\"hljs-title class_\"\u003eLink\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react-router-dom'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGameReviewCard\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'../components/GameReviewCard'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eGameDetail\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ user }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// URL 파라미터에서 게임 ID를 가져옵니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { id } = \u003cspan class=\"hljs-title function_\"\u003euseParams\u003c/span\u003e();\n  \u003cspan class=\"hljs-comment\"\u003e// 게임 통계를 저장할 상태\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [gameStats, setGameStats] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e([]);\n\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n       \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(back_end_url) \u003cspan class=\"hljs-comment\"\u003e//아직 이 변수를 정의하지 않았음을 참고해 주세요. \u003c/span\u003e\n      .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u003e\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n      .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetGameStats\u003c/span\u003e(data))\n      .\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(error));\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eBox\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esx\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emt:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e2\u003c/span\u003e }\u003e\u003c/span\u003e\n            {gameStats.length \u003e 0 ? (\n              gameStats.map((stat) =\u003e (\n                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eGameReviewCard\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{stat.game_stats_id}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003egameStats\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{stat}\u003c/span\u003e /\u003e\u003c/span\u003e\n              ))\n            ) : (\n              \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eTypography\u003c/span\u003e\u003e\u003c/span\u003e리뷰가 없습니다.\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eTypography\u003c/span\u003e\u003e\u003c/span\u003e\n            )}\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eBox\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e지금, 이 back-end route를 살펴보겠어요. 여러분이 fetch 문에서 \u003ccode\u003eback_end_url\u003c/code\u003e로 넣을 내용은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGameStatsByGameID\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eResource\u003c/span\u003e):\n    # 이는 특정 게임에 대한 모든 댓글과 평가를 가져와 개별 게임 페이지에 표시합니다\n    def \u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(self, game_id): \n        gamestats = [gamestat.\u003cspan class=\"hljs-title function_\"\u003eto_dict\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e gamestat \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGameStatistics\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003equery\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eGameStatistics\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egame_id\u003c/span\u003e == game_id, \u003cspan class=\"hljs-title class_\"\u003eGameStatistics\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecomments\u003c/span\u003e != \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e()]\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003egamestats\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emake_response\u003c/span\u003e(gamestats)\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emake_response\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e'error'\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'아직 리뷰가 없습니다'\u003c/span\u003e]})\n\napi.\u003cspan class=\"hljs-title function_\"\u003eadd_resource\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eGameStatsByGameID\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'/game-statistic/\u0026#x3C;int:game_id\u003e'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 route의 가장 중요한 부분은 우리가 하는 데이터베이스 쿼리입니다. 게임 ID(우리는 front-end route로부터 가져온 것)를 전달하고, 그 ID를 사용하여 전체 게임 통계 데이터베이스를 훑어서 해당 특정 게임과 관련된 모든 인스턴스를 추출합니다. filter 내부의 쿼리의 두 번째 부분은 실제로 존재하는 댓글만 추출하도록 하는 것입니다(기억하세요, 우리는 게임 통계 테이블에 Favorite와 Wishlist와 같은 것들도 저장하지만 페이지의 댓글 섹션에 렌더링되지 않길 원합니다!). 이제 반환된 결과를 사용하여 댓글/리뷰 카드를 렌더링할 수 있습니다! 그리고 front-end에서는 useParams에서 game_id를 가져오기 위해 fetch 요청에서 \u003ccode\u003eback_end_url\u003c/code\u003e을 \u003ccode\u003e/game-statistic/$'id'\u003c/code\u003e로 설정할 수 있어요.\u003c/p\u003e\n\u003ch1\u003e즐겨찾기\u003c/h1\u003e\n\u003cp\u003e즐겨찾기 기능도 비슷한 방식으로 작동하지만, 사용자 ID와 특정 게임 ID가 아닌 사용자 ID와 관련된 게임 통계를 쿼리하는 새로운 백앤드 루트가 필요합니다. 또한 즐겨찾기한 게임 통계만 쿼리 결과로 포함하고 싶습니다. 그래서 우리의 프런트엔드는 다음과 같이 간단하게 보일 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState, useEffect, useParams } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFavoritesGameCard\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@/components/FavoritesGameCard.jsx'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eFavorites\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ user }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [games, setGames] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e([]);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [deleteGame, setDeleteGame] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (user \u0026#x26;\u0026#x26; user.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e) {\n      \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`http://localhost:8080/favorites/\u003cspan class=\"hljs-subst\"\u003e${user.id}\u003c/span\u003e`\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u003e\u003c/span\u003e {\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (res.\u003cspan class=\"hljs-property\"\u003eok\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n          } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"GET 요청 중에 문제가 발생했습니다\"\u003c/span\u003e);\n          }\n        })\n        .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003egameData\u003c/span\u003e) =\u003e\u003c/span\u003e {\n          \u003cspan class=\"hljs-title function_\"\u003esetGames\u003c/span\u003e(gameData);\n        });\n    }\n  }, [user, deleteGame]);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleUnfavorite\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003egameId\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetGames\u003c/span\u003e(games.\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003egame\u003c/span\u003e) =\u003e\u003c/span\u003e game.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e !== gameId));\n    \u003cspan class=\"hljs-title function_\"\u003esetDeleteGame\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprev\u003c/span\u003e) =\u003e\u003c/span\u003e !prev);\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      {!games ? (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"no-favorites-message\"\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh2\u003c/span\u003e\u003e\u003c/span\u003e아직 즐겨찾기한 게임이 없습니다\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh2\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      ) : (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"game-cards-container\"\u003c/span\u003e\u003e\u003c/span\u003e\n            {games.map((game) =\u003e (\n              \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eFavoritesGameCard\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{game.id}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003egame\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{game}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euser\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{user}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehandleUnfavorite\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleUnfavorite}\u003c/span\u003e /\u003e\u003c/span\u003e\n            )}\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n      )}\n    \u0026#x3C;/div\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFavorites\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로운 백앤드 루트와 ID를 백앤드로 보내는 새로운 방법을 알 수 있을 것입니다. 우리는 현재 로그인한 사용자를 React 상태에 유지하여 해당 사용자에 대한 정보가 필요한 컴포넌트에 전달할 수 있습니다 (이 경우에는 ID가 필요합니다). 백앤드 루트와 쿼리는 다음과 같이 구성되어 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFavoritesByUser\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eResource\u003c/span\u003e):\n    def \u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(self, user_id):\n        favorites = [gamestat.\u003cspan class=\"hljs-property\"\u003egame\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eto_dict\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e gamestat \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGameStatistics\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003equery\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eGameStatistics\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003euser_id\u003c/span\u003e==user_id, \u003cspan class=\"hljs-title class_\"\u003eGameStatistics\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003efavorited\u003c/span\u003e==\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e()]\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efavorites\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emake_response\u003c/span\u003e(favorites)\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emake_response\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e'error'\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'아직 즐겨찾기한 게임이 없습니다'\u003c/span\u003e]})\n        \napi.\u003cspan class=\"hljs-title function_\"\u003eadd_resource\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eFavoritesByUser\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'/favorites/\u0026#x3C;int:user_id\u003e'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e알았어요! 이제, 즐겨찾기 및 위시리스트 관련 기능에 대해 더 이야기해보겠어요.\u003c/p\u003e\n\u003ch1\u003e위시리스트 버튼\u003c/h1\u003e\n\u003cp\u003e게임을 즐겨찾기 하는 방법은 React State를 활용하는 위시리스트 버튼을 구현하는 것으로 결정했어요. 이 버튼은 부모 컴포넌트로부터 전달된 prop과 이 컴포넌트 자체의 네이티브 state를 활용하여 사용자와 게임에 관련된 게임 통계를 확인하고 이에 맞게 렌더링하는 기능을 제공해요. 부모 컴포넌트로부터 넘어온 gameStatId 상태를 사용하여 데이터베이스로 fetch 요청을 보내 현재 로그인한 사용자의 ID(기억해요, 사용자 정보는 이미 state에 저장되어 있어요)와 현재 보고 있는 게임 상세 페이지의 게임 ID에 해당하는 게임 통계의 인스턴스가 있는지 확인해요. 만약 해당 인스턴스가 있다면 gameStateId를 업데이트하고 해당 상태를 버튼으로 전달해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { useState, useEffect } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'react'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@mui/material/Button'\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// Material-UI에서 Button 가져오기\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStarIcon\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@mui/icons-material/Star'\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// Material-UI에서 즐겨찾기 아이콘 가져오기\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStarBorderIcon\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@mui/icons-material/StarBorder'\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// Material-UI에서 즐겨찾기 해제 아이콘 가져오기\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// gameId와 userId를 prop으로 전달받는 함수형 컴포넌트 WishlistButton 정의\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eWishlistButton\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ gameId, userId, gameStatId, updateGameStatId}\u003c/span\u003e) {\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 게임을 위시리스트에 추가했는지 추적하는 상태\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [isWishlisted, setIsWishlisted] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 게임 통계를 가져오는 useEffect 훅, gameId 또는 userId가 변경될 때 실행\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 현재 사용자와 게임에 대한 게임 통계 가져오기\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`http://localhost:8080/game-statistics/\u003cspan class=\"hljs-subst\"\u003e${gameId}\u003c/span\u003e/\u003cspan class=\"hljs-subst\"\u003e${userId}\u003c/span\u003e`\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u003e\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n      .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 게임 통계가 있는 경우 상태 업데이트\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (data.\u003cspan class=\"hljs-property\"\u003egame_stats_id\u003c/span\u003e) {\n          \u003cspan class=\"hljs-title function_\"\u003esetIsWishlisted\u003c/span\u003e(data.\u003cspan class=\"hljs-property\"\u003ewish_listed\u003c/span\u003e);\n          \u003cspan class=\"hljs-title function_\"\u003eupdateGameStatId\u003c/span\u003e(data.\u003cspan class=\"hljs-property\"\u003egame_stats_id\u003c/span\u003e);\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n          \u003cspan class=\"hljs-comment\"\u003e// 게임 통계가 없는 경우 기본 상태로 설정\u003c/span\u003e\n          \u003cspan class=\"hljs-title function_\"\u003esetIsWishlisted\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n          \u003cspan class=\"hljs-title function_\"\u003eupdateGameStatId\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n        }\n      });\n  }, [gameId, userId]); \u003cspan class=\"hljs-comment\"\u003e// useEffect의 의존성 배열\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// 위시리스트 버튼 클릭 처리 함수\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleWishlist\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 게임 통계 인스턴스가 있는 경우 위시리스트 상태 업데이트\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (gameStatId) {\n      \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`http://localhost:8080/game-statistics/\u003cspan class=\"hljs-subst\"\u003e${gameId}\u003c/span\u003e/\u003cspan class=\"hljs-subst\"\u003e${userId}\u003c/span\u003e`\u003c/span\u003e, {\n        \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'PATCH'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 기존 데이터 업데이트용 PATCH 메소드 사용\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: {\n          \u003cspan class=\"hljs-string\"\u003e'Content-Type'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e,\n        },\n        \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ewish_listed\u003c/span\u003e: !isWishlisted }), \u003cspan class=\"hljs-comment\"\u003e// 위시리스트 상태 토글\u003c/span\u003e\n      })\n        .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u003e\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n        .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetIsWishlisted\u003c/span\u003e(data.\u003cspan class=\"hljs-property\"\u003ewish_listed\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 새로운 위시리스트 상태로 상태 업데이트\u003c/span\u003e\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 게임 통계 인스턴스가 없는 경우 새로운 위시리스트 생성\u003c/span\u003e\n      \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`http://localhost:8080/game-statistics`\u003c/span\u003e, {\n        \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 새 데이터 생성용 POST 메소드 사용\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: {\n          \u003cspan class=\"hljs-string\"\u003e'Content-Type'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e,\n        },\n        \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e({\n          \u003cspan class=\"hljs-attr\"\u003euser_id\u003c/span\u003e: userId,\n          \u003cspan class=\"hljs-attr\"\u003egame_id\u003c/span\u003e: gameId,\n          \u003cspan class=\"hljs-attr\"\u003ewish_listed\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n        }),\n      })\n        .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u003e\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n        .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u003e\u003c/span\u003e {\n          \u003cspan class=\"hljs-comment\"\u003e// 새 게임 통계 데이터로 상태 업데이트\u003c/span\u003e\n          \u003cspan class=\"hljs-title function_\"\u003esetIsWishlisted\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n          \u003cspan class=\"hljs-title function_\"\u003eupdateGameStatId\u003c/span\u003e(data.\u003cspan class=\"hljs-property\"\u003egame_stats_id\u003c/span\u003e);\n        });\n    }\n  };\n\n  \u003cspan class=\"hljs-comment\"\u003e// 위시리스트 버튼 동적 텍스트 및 아이콘을 기반으로 렌더링\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"wishlist-container\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003evariant\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"contained\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"primary\"\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003estartIcon\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{isWishlisted\u003c/span\u003e ? \u0026#x3C;\u003cspan class=\"hljs-attr\"\u003eStarIcon\u003c/span\u003e /\u003e\u003c/span\u003e : \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eStarBorderIcon\u003c/span\u003e /\u003e\u003c/span\u003e}\n        onClick={handleWishlist}\n      \u003e\n        {isWishlisted ? '위시리스트에서 제거' : '위시리스트에 추가'}\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWishlistButton\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 다른 부분에서 사용할 수 있도록 WishlistButton 컴포넌트 내보내기\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 해당 인스턴스가 이미 존재한다면(예: 사용자가 이 게임에 댓글을 달았거나 위시리스트에 추가했을 경우), 위시리스트 버튼을 클릭하면 데이터베이스에서 해당 게임 통계를 업데이트하기 위해 서버로 PATCH 요청이 전송됩니다. 아직 인스턴스가 존재하지 않은 경우, POST 요청을 보내고 모든 다른 버튼들(위시리스트 및 댓글 등)의 상태를 업데이트하여 이후 PATCH 요청을 보냅니다. 그런 다음, 확실히 isWishlisted 상태를 사용하여 페이지에서 조건부 렌더링을 수행하여 버튼을 \"위시리스트에서 제거\" 또는 \"위시리스트에 추가\"로 표시하게 됩니다.\u003c/p\u003e\n\u003cp\u003e사용자와 상호 작용할 때 프론트엔드와 백엔드를 연결하는 몇 가지 방법 중 일부입니다. SerializerMixin 및 직렬화 규칙과 같은 것들을 사용하면 백엔드에서 반환되는 데이터를 더욱 구체적으로 얻을 수 있습니다. 매우 구체적인 라우팅을 만드는 것은 시간이 소모되고 때로는 중복된 느낌을 줄 수 있지만, 데이터베이스에 많은 양의 정보가 저장된 경우 메모리 및 로드 시간을 줄일 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e좋은 코딩 되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-CommentsModelsandUsersOhMyGeneratingFull-StackFunctionalityforIndividualUsers"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>