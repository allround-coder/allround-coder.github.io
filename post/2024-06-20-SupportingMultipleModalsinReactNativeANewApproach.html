<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트 네이티브에서 다중 모달 지원하기 새로운 방식 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트 네이티브에서 다중 모달 지원하기 새로운 방식 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트 네이티브에서 다중 모달 지원하기 새로운 방식 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach" data-gatsby-head="true"/><meta name="twitter:title" content="리액트 네이티브에서 다중 모달 지원하기 새로운 방식 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 01:20" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트 네이티브에서 다중 모달 지원하기 새로운 방식</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트 네이티브에서 다중 모달 지원하기 새로운 방식" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>여러 모달을 관리하는 것은 React Native의 표준 모달 구현 및 인기있는 서드 파티 라이브러리에서 볼 수 있는 제한 사항입니다. 이 문제에 대한 우리만의 접근 방식 및 우리의 rn-modal-presenter 라이브러리 사용 방법을 알아보세요.</h2>
<p>바이 화이트 스펙트어 React Native 팀</p>
<p><img src="/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png" alt="이미지"></p>
<p>이 기사는 화이트 스펙트어 React Native 팀 구성원인 Lucas Diez de Medina와 Rui Lu가 공동 저술했습니다.</p>
<div class="content-ad"></div>
<p>어플 빌드를 위한 조사 중에, 현재 React Native 표준 모달 구현이 동시에 여러 모달을 관리하지 못한다는 사실을 발견했습니다. 인기 있는 서드 파티 라이브러리들도 비슷한 제한을 가지고 있어서 우리에겐 작동하지 않았습니다. 더욱 복잡한 React Native 앱일수록 더 많은 제약이 생길 것입니다. 더 나쁜 점은, 에러가 발생할 수 있지만 눈에 띄지 않을 수도 있습니다.</p>
<p>그래서 우리는 우리만의 간단한 방법을 만들기로 결정했고, rn-modal-presenter 라이브러리를 출시했습니다. 우리가 발견한 사항과 여러분의 React Native 프로젝트에 우리 라이브러리를 사용하는 방법을 알아보려면 계속 읽어주세요.</p>
<p>이 글에서 다루는 내용은 다음과 같습니다:</p>
<ul>
<li>서드 파티 모달 라이브러리의 제한 사항</li>
<li>테스트한 대안</li>
<li>우리의 해결책: rn-modal-presenter 라이브러리</li>
<li>rn-modal-presenter 라이브러리 구현 방법</li>
</ul>
<div class="content-ad"></div>
<p>rn-modal-presenter 라이브러리의 전체 문서를 npm 및 GitHub에서 읽어보세요.</p>
<h1>서드파티 Modal 라이브러리의 제한 사항</h1>
<p>이제 위에서 언급한 대로, React Native에서 모달이 얼마나 중요한지는 알 수 있지만, 표준 구현은 몇 가지 중요한 제한 사항을 갖고 있습니다. 이는 사용자에게 다른 상황에서 여러 모달을 표시하려고 시도했을 때 우리가 발견한 것입니다.</p>
<p>모달은 일반적으로 프롭을 기반으로 표시되거나 숨겨지는 컴포넌트이며, 이 프롭은 일반적으로 표시하는 컴포넌트의 상태에 의해 제어됩니다. 해당 컴포넌트는 컴포넌트 트리의 일부여야 하며 표시하고 싶은 모든 컴포넌트의 자식으로 나타나야 합니다. 이러한 이유로 하나의 컴포넌트로 표시되는 여러 모달을 표시하려는 경우나 모달이 표시되는 별도의 화면으로 이동해야 하는 경우에 기본적인 제한 사항과 복잡성이 발생합니다.</p>
<div class="content-ad"></div>
<p>위의 내용을 한국어로 번역하면 다음과 같습니다:</p>
<ul>
<li>모달을 제어하는 상태를 관리해야 합니다.</li>
<li>상태를 업데이트함으로써 모달의 표시 및 숨김을 동시에 처리해야 합니다 (표시하는 컴포넌트 내에서).</li>
<li>특정 컴포넌트에서 모달을 표시한 후에 뒤로 이동하려면, 표시하는 컴포넌트가 언마운트되므로 모달도 사라집니다.</li>
<li>iOS에서는 동시에 두 개 이상의 모달을 표시하거나 서로 겹치는 여러 모달을 스택으로 관리할 수 없습니다: <a href="https://github.com/react-native-modal/react-native-modal/issues/30" rel="nofollow" target="_blank">https://github.com/react-native-modal/react-native-modal/issues/30</a></li>
</ul>
<p>마지막으로, 이 제한 사항은 iOS 네이티브 측면에 있습니다. UIViewController가 다른 뷰 컨트롤러를 표시한 후, 표시 중인 뷰 컨트롤러 (이제 숨겨진 상태)가 해당 뷰 컨트롤러 위에 다른 두 번째 뷰 컨트롤러를 표시할 수 없습니다. 따라서 이전에 표시된 뷰 컨트롤러에서 두 번째 뷰를 표시해야 합니다.</p>
<h1>간단한 예시</h1>
<div class="content-ad"></div>
<p>간단한 예제로이 한계를 확인해 보겠습니다. 여기서는 전통적인 모달을 사용하여 앱 평가를 받으려고 시도하지만, 특정 상황에서만 만족한 사용자에게만 보여줍니다.</p>
<p>사용자가 앱에서 관련 작업을 수행한 후에는 다음을 보여줍니다:</p>
<ul>
<li>
<p>작업이 완료되었음을 알리는 모달</p>
</li>
<li>
<p>앱에 대해 얼마나 만족하는지 묻는 모달</p>
</li>
<li>
<p>긍정적인 답변일 경우 AppStore에서 앱 평가를 요청하는 모달을 보여줍니다.</p>
</li>
<li>
<p>부정적인 답변인 경우 피드백을 남겨 주시라는 모달을 제공합니다.</p>
</li>
</ul>
<div class="content-ad"></div>
<p>그럼, 모든 이 modal들이 같은 메인 화면에서 제시되며 이 코드 스니펫에서 볼 수 있듯이 네 가지 다른 modal에 대한 모든 상태를 가지고 있으며 그 상태에 따라 각 modal을 표시합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) => {
 <span class="hljs-keyword">const</span> [showRateAppModal, setShowRateAppModal] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
 <span class="hljs-keyword">const</span> [showAppRatedPositiveModal, setShowAppRatedPositiveModal] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
 <span class="hljs-keyword">const</span> [showAppRatedNegativeModal, setShowAppRatedNegativeModal] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
 <span class="hljs-keyword">const</span> [showActivateGadgetModal, setShowActivateGadgetModal] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
 
 <span class="hljs-keyword">return</span> (
   <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">SafeAreaView</span>></span>
     {showActivateGadgetModal &#x26;&#x26; (
       <span class="hljs-tag">&#x3C;<span class="hljs-name">ActivateGadgetModal</span>
         <span class="hljs-attr">onDismiss</span>=<span class="hljs-string">{()</span> =></span> {
           setShowActivateGadgetModal(false);
         }
       />
     )}
     {showRateAppModal &#x26;&#x26; (
       <span class="hljs-tag">&#x3C;<span class="hljs-name">RateAppModal</span>
         <span class="hljs-attr">positiveFeedback</span>=<span class="hljs-string">{()</span> =></span> {
           setShowRateAppModal(false);
           setShowAppRatedPositiveModal(true);
         }
         negativeFeedback={() => {
           setShowRateAppModal(false);
           setShowAppRatedNegativeModal(true);
         }
       />
     )}
     {showAppRatedPositiveModal &#x26;&#x26; (
       <span class="hljs-tag">&#x3C;<span class="hljs-name">PositiveFeedbackModal</span>
         <span class="hljs-attr">onDismiss</span>=<span class="hljs-string">{()</span> =></span> setShowAppRatedPositiveModal(false)}
       />
     )}
     {showAppRatedNegativeModal &#x26;&#x26; (
       <span class="hljs-tag">&#x3C;<span class="hljs-name">NegativeFeedbackModal</span>
         <span class="hljs-attr">onDismiss</span>=<span class="hljs-string">{()</span> =></span> setShowAppRatedNegativeModal(false)}
       />
     )}
     <span class="hljs-tag">&#x3C;<span class="hljs-name">Button</span>
       <span class="hljs-attr">title</span>=<span class="hljs-string">"Activate Gadget"</span>
       <span class="hljs-attr">onPress</span>=<span class="hljs-string">{()</span> =></span> {
         setShowActivateGadgetModal(true);
         setShowRateAppModal(true);
       }
     />
   <span class="hljs-tag">&#x3C;/<span class="hljs-name">SafeAreaView</span>></span></span>
 );
};
</code></pre>
<p>이 상호작용은 상태를 같은 컴포넌트에서 제어하기 때문에 매우 간단합니다. 또한 우리는 저장소(store)를 가지고 있지 않습니다. 이미 4개의 상태 변수를 가지고 있는 저장소를 관리하고 있는데, 이것은 계속해 추가할수록 더 복잡해집니다.</p>
<p>이제 실수로 두 개의 modal을 동시에 표시하려고하면 어떻게 작동하는지 살펴보겠습니다.</p>
<div class="content-ad"></div>
<p>이 경우에는 첫 번째 모달이 iOS에서만 표시될 것이며, 이 문제의 가장 나쁜 부분은 React Native 콘솔에서는 오류가 발생하지 않았다는 것입니다.</p>
<p>그러나 Xcode 콘솔을 확인하면 현재 다른 View Controller 위에 View Controller를 표시하려고 시도하고 있는 것이 iOS 시스템에서 올바르지 않은 동작임을 알 수 있습니다.</p>
<p>보게 될 오류는 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Warning</span>: <span class="hljs-title class_">Attempt</span> to present &#x3C;<span class="hljs-title class_">UIViewController</span>: <span class="hljs-number">0x147d2c6b0</span>> on &#x3C;<span class="hljs-title class_">UIViewController</span>: <span class="hljs-number">0x147d614c0</span>> which is already presenting (<span class="hljs-literal">null</span>)
</code></pre>
<div class="content-ad"></div>
<p>iOS에서 올바른 흐름은 첫 번째 모달을 표시한 후에, 첫 번째 모달이 해제되면(해당 상태 변수를 false로 설정함으로써) 다음 모달의 상태 변수를 true로 설정하여 표시하는 것입니다.</p>
<p>상상할 수 있듯이, 이것은 매우 복잡해질 수 있습니다. 대부분의 경우 개발자들은 여러 모달의 해제와 표시를 관리하기 위해 지연 또는 시간 초과를 사용합니다. 이로 인해 예기치 못한 오류가 발생하며 실제로 모달 애니메이션 지속 시간은 앱이 실행되는 기기에 따라 다를 수 있습니다.</p>
<p>요약하면, 여기서 직면한 문제는 표시 컴포넌트가 모든 로직 및 상태 관리를 처리해야 하고 표시하려는 각 모달마다 하나의 상태 변수가 필요하다는 것입니다.</p>
<p>우리에게 가장 큰 문제는 한 가지 실수를 하게 되면, 두 개의 모달을 동시에 표시하려고 한다면 두 번째 모달이 나타나지 않고 오류/경고 메시지도 표시되지 않는다는 것입니다.</p>
<div class="content-ad"></div>
<h1>시도한 대체품</h1>
<p>리액트 네이티브 프로젝트에서 여러 모달을 관리하는 데 직면할 수 있는 두 가지 일반적인 문제는 다음과 같습니다:</p>
<ul>
<li>동시에 하나 이상의 모달을 표시할 수 없음</li>
<li>모달이 더 많이 추가될수록 코드 복잡성이 기하급수적으로 증가함</li>
</ul>
<p>이러한 두 가지 문제로 인해 표준 네이티브 모달 컴포넌트를 사용하면서 이를 해결하기 위해 다양한 옵션을 시도해 보았습니다.</p>
<div class="content-ad"></div>
<p>아래에는 여기서 가장 일반적으로 사용되는 2개의 라이브러리가 있으며, 이들을 사용한 이유와 우리가 고유한 방식으로 진행하기로 결정한 이유를 설명했습니다.</p>
<h1>react-native-modal</h1>
<p>이는 표준 React Native Modal 컴포넌트의 확장입니다. 기존 기능에 추가적인 기능을 제공하여 들어오는/나가는 애니메이션 타이밍을 지정할 수 있거나 다른 콜백을 제공하여 API를 사용자 정의할 수 있습니다. 또한 기기 방향에 따라 스와이프할 수 있고 스크롤 가능하며 적응적인 콘텐츠를 제공합니다.</p>
<p>하지만 이러한 기능이 얼마나 좋든, 이 라이브러리는 결국 React Native에서 모달이 작동하는 방식을 변경하지 않기 때문에 여전히 동시에 여러 모달을 표시하거나 코드 복잡성을 줄이는 등 위에서 언급한 같은 제한 사항을 갖고 있습니다.</p>
<div class="content-ad"></div>
<h1>react-native-modalfy</h1>
<p>이 라이브러리는 이전 것보다 훨씬 인기가 적지만, 우리가 달성하고자 하는 방향과 일치합니다.</p>
<p>첫 번째 이점은 JavaScript로 구현되어 여러 모달을 지원한다는 것입니다. 코드의 어느 곳에서든 JavaScript 함수를 호출할 수 있으며, 컴포넌트 트리를 혼동시키지 않고 추가적인 상태를 관리할 필요가 없습니다.</p>
<p>다른 중요한 점은 명령형 API를 기반으로 하고 있으며, 각 모달의 외형에 대한 애니메이션과 전환을 완전히 사용자 정의할 수 있다는 것입니다.</p>
<div class="content-ad"></div>
<p>위 장점들에도 불구하고, 이 라이브러리는 설정하기 위해 일부 뼈대 코드가 필요했습니다. 이런 면에서 React Navigation과 매우 유사합니다. 여러분은 프로젝트 내에서 사용할 각 모달을 미리 정의하고 각각에 대한 구성을 제공해야 합니다.</p>
<p>또 다른 단점은 동일한 모달 유형의 여러 인스턴스를 표시하거나 숨기지 못한다는 것입니다. 같은 스타일을 공유하는 다양한 버튼과 복사본을 가진 다수의 모달이 있는 애플리케이션에서는, 다양한 모달 엔티티를 만드는 대신 서로 다른 복사본을 위한 특정 매개변수를 가진 하나의 모달만 가지는 것이 더 효율적입니다.</p>
<h1>우리의 해결책: rn-modal-presenter</h1>
<p>다양한 옵션을 분석한 후, 우리는 다음 기반으로 우리만의 라이브러리를 만들기로 결정했습니다.</p>
<div class="content-ad"></div>
<h1>유연한 구성요소와 명령형 API</h1>
<p>유연하다는 의미는 어떤 구성요소든 모달로 표현할 수 있고, 상태를 수정하지 않고 코드의 어디서든(표시된 모달 내에서도) 표시/감춤을 관리할 수 있다는 것입니다.</p>
<p>명령형 API를 사용하면 앱 전체 위에 모달이 표시되므로 어디서든 모달 표시를 트리거할 수 있습니다.</p>
<h1>콘텐츠는 부모 구성요소(보통 귀하의 구성요소) 위에 표시됩니다</h1>
<div class="content-ad"></div>
<p>이 부보 컴포넌트는 우리 라이브러리에서 노출되었고, 여러분은 해당 컴포넌트 트리 어딘가에 배치해야 합니다. 이것은 모달 창이 다른 일반 뷰와 화면에 비해 가장 높은 우선순위를 가지고 있기 때문에 멋집니다.</p>
<h1>다중 모달 지원</h1>
<p>100% 자바스크립트 라이브러리이기 때문에 여러 개의 모달을 쉽게 표시할 수 있습니다. 또한 동일한 모달 유형의 여러 인스턴스를 표시하는 것을 지원합니다.</p>
<p>그러나 이에는 조금 제한이 있습니다. 자바스크립트 솔루션이기 때문에 프로젝트에 다른 네이티브 모달이 있는 경우, 해당 나중 모달은 여전히 우리 모달 위에 있을 수 있습니다. 왜냐하면 네이티브 컴포넌트가 가장 높은 우선순위를 가지기 때문입니다.</p>
<div class="content-ad"></div>
<h1>라이브러리 통합 방법</h1>
<p>단계 1: 프로젝트에 라이브러리 추가하기:</p>
<ul>
<li>yarn add @whitespectre/rn-modal-presenter</li>
<li>npm install @whitespectre/rn-modal-presenter</li>
</ul>
<p>단계 2: 모달을 표시하고 싶은 컴포넌트 위에 래핑하기:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ModalPresenterParent</span>, showModal } <span class="hljs-keyword">from</span> <span class="hljs-string">'@whitespectre/rn-modal-presenter'</span>;
…
&#x3C;<span class="hljs-title class_">ModalPresenterParent</span>>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">App</span> /></span></span>
&#x3C;/<span class="hljs-title class_">ModalPresenterParent</span>>
</code></pre>
<p>제 3단계: showModal 메소드를 호출하세요. 이 메소드는 다음을 받습니다:</p>
<ul>
<li>보여질 컴포넌트</li>
<li>해당 컴포넌트로 전달될 속성</li>
<li>나중에 모달을 해제하는 데 사용할 ModalHandler를 반환합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> declare <span class="hljs-keyword">const</span> <span class="hljs-attr">showModal</span>: &#x3C;<span class="hljs-title class_">ContentProps</span>><span class="hljs-function">(<span class="hljs-params">
  Content: (props: ContentProps &#x26; ModalContentProps) => JSX.Element,
  contentProps: ContentProps,
</span>) =></span> <span class="hljs-title class_">ModalHandler</span>;
</code></pre>
<div class="content-ad"></div>
<p>그게 다야. 충분히 준비됐어요.</p>
<h2>더 복잡한 구현</h2>
<h3>컴포넌트에 속성 전달하기</h3>
<p>모달 위에 표시하려는 컴포넌트에 속성을 추가하려면 컴포넌트에 도우미 함수를 만들 수 있습니다.</p>
<div class="content-ad"></div>
<p>이 경우에는 showModal 함수를 호출하는 helper 함수를 만들 수 있습니다. 이 함수는 사용자에게 보여줄 텍스트와 사용자가 닫기 버튼을 눌렀을 때 실행할 완료 핸들러를 받는데, 이것은 custom text modal이 받는 속성을 받게 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">showCustomAlert</span> = (<span class="hljs-params">
  title: string,
  body: string,
  buttons: CustomAlertButton[] = [defaultButton],
</span>) => {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">showModal</span>(<span class="hljs-title class_">CustomAlert</span>, { title, body, buttons });
};
</code></pre>
<h2>컴포넌트 속성에 ModalContentProps 추가하기</h2>
<p>이 기능은 컴포넌트를 설치할 때 라이브러리에 의해 제공되며, dismiss 함수를 포함합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">CustomAlert</span> = (<span class="hljs-params">{
  dismiss,
  title,
  body,
  buttons
}: CustomAlertProps &#x26; ModalContentProps</span>) => {
  <span class="hljs-keyword">return</span> (
    …
</code></pre>
<p>여기에는 모달 컴포넌트 속성으로 반환된 dismiss 함수를 전달하고 해당 dismiss를 모달 내에서 모달을 지우는 데 사용합니다.</p>
<h2>새 라이브러리를 사용한 원본 예제</h2>
<p>rn-modal-presenter 라이브러리를 사용하면 상태를 관리할 필요가 없고 어디에서든 모달 표시를 강제로 트리거할 수 있기 때문에 원본 예제는 다음과 같이 다시 작성할 수 있습니다.</p>
<div class="content-ad"></div>
<p>메인 앱 컴포넌트는 Gadget Activation 모달을 표시할 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">ModalPresenterParent</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">SafeAreaView</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Button</span>
          <span class="hljs-attr">title</span>=<span class="hljs-string">"Gadget 활성화"</span>
          <span class="hljs-attr">onPress</span>=<span class="hljs-string">{()</span> =></span> {
            showModal(ActivateGadgetModal, {});
          }
        />
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">SafeAreaView</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">ModalPresenterParent</span>></span></span>
  );
};
</code></pre>
<p>그리고 각 모달은 자체적으로 dismiss하고, 흐름에서 다음 모달을 표시하는 책임이 있을 것입니다. 예를 들어, ActivateGadgetModal은 아래와 같이 보일 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">ActivateGadgetModal</span> = (<span class="hljs-params">{dismiss}: ModalContentProps</span>) => {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.modalOverlay}</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.modal}</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.contentContainer}</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Text</span>></span>당신의 Gadget이 활성화되었습니다<span class="hljs-tag">&#x3C;/<span class="hljs-name">Text</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{styles.buttonsContainer}</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">Button</span>
              <span class="hljs-attr">title</span>=<span class="hljs-string">"닫기"</span>
              <span class="hljs-attr">onPress</span>=<span class="hljs-string">{()</span> =></span> {
                dismiss();
                showModal(RateAppModal, {});
              }
            />
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">View</span>></span></span>
  );
};
</code></pre>
<div class="content-ad"></div>
<h1>미래 개선 사항</h1>
<p>rn-modal-presenter 라이브러리는 현재 진행 중인 프로젝트에 우리의 요구 사항에 맞게 만들어 졌지만, 사용하면서 다른 기능과 개선 사항들을 확인했습니다. 다른 사용 사례에 유용할 수 있는 것들입니다.</p>
<p>여기 우리 라이브러리에 도입하고 싶은 주요 기능 및 개선 사항입니다:</p>
<ul>
<li>하나씩 보이도록 모달의 대기열 만들기</li>
<li>현재 여러 개의 모달이 동시에 표시되려고 하면 서로 위에 겹쳐서 나타납니다.</li>
<li>대기열은 우선순위 매커니즘을 포함하여 강제로 다음 모달을 표시할 수 있어야 합니다.</li>
<li>뷰가 네이티브 뷰들 위에 나타날 수 있도록 만들기</li>
<li>더불어 네이티브 모듈을 구축하여 내용을 네이티브 뷰 위에 표시할 수 있도록 하기</li>
<li>각 효과에 대해 사용자 정의 가능한 애니메이션 및 지속 시간 허용하기</li>
</ul>
<div class="content-ad"></div>
<p>만약 이러한 기능 중 어떤 것을 구현하고 싶거나 우리 라이브러리에 기여하고 싶다면, 언제든지 다음 링크에서 PR을 열어주세요: <a href="https://github.com/whitespectre/rn-modal-presenter" rel="nofollow" target="_blank">https://github.com/whitespectre/rn-modal-presenter</a>.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트 네이티브에서 다중 모달 지원하기 새로운 방식","description":"","date":"2024-06-20 01:20","slug":"2024-06-20-SupportingMultipleModalsinReactNativeANewApproach","content":"\n\n## 여러 모달을 관리하는 것은 React Native의 표준 모달 구현 및 인기있는 서드 파티 라이브러리에서 볼 수 있는 제한 사항입니다. 이 문제에 대한 우리만의 접근 방식 및 우리의 rn-modal-presenter 라이브러리 사용 방법을 알아보세요.\n\n바이 화이트 스펙트어 React Native 팀\n\n![이미지](/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png)\n\n이 기사는 화이트 스펙트어 React Native 팀 구성원인 Lucas Diez de Medina와 Rui Lu가 공동 저술했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어플 빌드를 위한 조사 중에, 현재 React Native 표준 모달 구현이 동시에 여러 모달을 관리하지 못한다는 사실을 발견했습니다. 인기 있는 서드 파티 라이브러리들도 비슷한 제한을 가지고 있어서 우리에겐 작동하지 않았습니다. 더욱 복잡한 React Native 앱일수록 더 많은 제약이 생길 것입니다. 더 나쁜 점은, 에러가 발생할 수 있지만 눈에 띄지 않을 수도 있습니다.\n\n그래서 우리는 우리만의 간단한 방법을 만들기로 결정했고, rn-modal-presenter 라이브러리를 출시했습니다. 우리가 발견한 사항과 여러분의 React Native 프로젝트에 우리 라이브러리를 사용하는 방법을 알아보려면 계속 읽어주세요.\n\n이 글에서 다루는 내용은 다음과 같습니다:\n\n- 서드 파티 모달 라이브러리의 제한 사항\n- 테스트한 대안\n- 우리의 해결책: rn-modal-presenter 라이브러리\n- rn-modal-presenter 라이브러리 구현 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nrn-modal-presenter 라이브러리의 전체 문서를 npm 및 GitHub에서 읽어보세요.\n\n# 서드파티 Modal 라이브러리의 제한 사항\n\n이제 위에서 언급한 대로, React Native에서 모달이 얼마나 중요한지는 알 수 있지만, 표준 구현은 몇 가지 중요한 제한 사항을 갖고 있습니다. 이는 사용자에게 다른 상황에서 여러 모달을 표시하려고 시도했을 때 우리가 발견한 것입니다.\n\n모달은 일반적으로 프롭을 기반으로 표시되거나 숨겨지는 컴포넌트이며, 이 프롭은 일반적으로 표시하는 컴포넌트의 상태에 의해 제어됩니다. 해당 컴포넌트는 컴포넌트 트리의 일부여야 하며 표시하고 싶은 모든 컴포넌트의 자식으로 나타나야 합니다. 이러한 이유로 하나의 컴포넌트로 표시되는 여러 모달을 표시하려는 경우나 모달이 표시되는 별도의 화면으로 이동해야 하는 경우에 기본적인 제한 사항과 복잡성이 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 내용을 한국어로 번역하면 다음과 같습니다:\n\n- 모달을 제어하는 상태를 관리해야 합니다.\n- 상태를 업데이트함으로써 모달의 표시 및 숨김을 동시에 처리해야 합니다 (표시하는 컴포넌트 내에서).\n- 특정 컴포넌트에서 모달을 표시한 후에 뒤로 이동하려면, 표시하는 컴포넌트가 언마운트되므로 모달도 사라집니다.\n- iOS에서는 동시에 두 개 이상의 모달을 표시하거나 서로 겹치는 여러 모달을 스택으로 관리할 수 없습니다: https://github.com/react-native-modal/react-native-modal/issues/30\n\n마지막으로, 이 제한 사항은 iOS 네이티브 측면에 있습니다. UIViewController가 다른 뷰 컨트롤러를 표시한 후, 표시 중인 뷰 컨트롤러 (이제 숨겨진 상태)가 해당 뷰 컨트롤러 위에 다른 두 번째 뷰 컨트롤러를 표시할 수 없습니다. 따라서 이전에 표시된 뷰 컨트롤러에서 두 번째 뷰를 표시해야 합니다.\n\n# 간단한 예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 예제로이 한계를 확인해 보겠습니다. 여기서는 전통적인 모달을 사용하여 앱 평가를 받으려고 시도하지만, 특정 상황에서만 만족한 사용자에게만 보여줍니다.\n\n사용자가 앱에서 관련 작업을 수행한 후에는 다음을 보여줍니다:\n\n- 작업이 완료되었음을 알리는 모달\n- 앱에 대해 얼마나 만족하는지 묻는 모달\n\n- 긍정적인 답변일 경우 AppStore에서 앱 평가를 요청하는 모달을 보여줍니다.\n- 부정적인 답변인 경우 피드백을 남겨 주시라는 모달을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼, 모든 이 modal들이 같은 메인 화면에서 제시되며 이 코드 스니펫에서 볼 수 있듯이 네 가지 다른 modal에 대한 모든 상태를 가지고 있으며 그 상태에 따라 각 modal을 표시합니다.\n\n```js\nconst App = () =\u003e {\n const [showRateAppModal, setShowRateAppModal] = useState(false);\n const [showAppRatedPositiveModal, setShowAppRatedPositiveModal] = useState(false);\n const [showAppRatedNegativeModal, setShowAppRatedNegativeModal] = useState(false);\n const [showActivateGadgetModal, setShowActivateGadgetModal] = useState(false);\n \n return (\n   \u003cSafeAreaView\u003e\n     {showActivateGadgetModal \u0026\u0026 (\n       \u003cActivateGadgetModal\n         onDismiss={() =\u003e {\n           setShowActivateGadgetModal(false);\n         }\n       /\u003e\n     )}\n     {showRateAppModal \u0026\u0026 (\n       \u003cRateAppModal\n         positiveFeedback={() =\u003e {\n           setShowRateAppModal(false);\n           setShowAppRatedPositiveModal(true);\n         }\n         negativeFeedback={() =\u003e {\n           setShowRateAppModal(false);\n           setShowAppRatedNegativeModal(true);\n         }\n       /\u003e\n     )}\n     {showAppRatedPositiveModal \u0026\u0026 (\n       \u003cPositiveFeedbackModal\n         onDismiss={() =\u003e setShowAppRatedPositiveModal(false)}\n       /\u003e\n     )}\n     {showAppRatedNegativeModal \u0026\u0026 (\n       \u003cNegativeFeedbackModal\n         onDismiss={() =\u003e setShowAppRatedNegativeModal(false)}\n       /\u003e\n     )}\n     \u003cButton\n       title=\"Activate Gadget\"\n       onPress={() =\u003e {\n         setShowActivateGadgetModal(true);\n         setShowRateAppModal(true);\n       }\n     /\u003e\n   \u003c/SafeAreaView\u003e\n );\n};\n```\n\n이 상호작용은 상태를 같은 컴포넌트에서 제어하기 때문에 매우 간단합니다. 또한 우리는 저장소(store)를 가지고 있지 않습니다. 이미 4개의 상태 변수를 가지고 있는 저장소를 관리하고 있는데, 이것은 계속해 추가할수록 더 복잡해집니다.\n\n이제 실수로 두 개의 modal을 동시에 표시하려고하면 어떻게 작동하는지 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 경우에는 첫 번째 모달이 iOS에서만 표시될 것이며, 이 문제의 가장 나쁜 부분은 React Native 콘솔에서는 오류가 발생하지 않았다는 것입니다.\n\n그러나 Xcode 콘솔을 확인하면 현재 다른 View Controller 위에 View Controller를 표시하려고 시도하고 있는 것이 iOS 시스템에서 올바르지 않은 동작임을 알 수 있습니다.\n\n보게 될 오류는 다음과 같습니다:\n\n```js\nWarning: Attempt to present \u003cUIViewController: 0x147d2c6b0\u003e on \u003cUIViewController: 0x147d614c0\u003e which is already presenting (null)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niOS에서 올바른 흐름은 첫 번째 모달을 표시한 후에, 첫 번째 모달이 해제되면(해당 상태 변수를 false로 설정함으로써) 다음 모달의 상태 변수를 true로 설정하여 표시하는 것입니다.\n\n상상할 수 있듯이, 이것은 매우 복잡해질 수 있습니다. 대부분의 경우 개발자들은 여러 모달의 해제와 표시를 관리하기 위해 지연 또는 시간 초과를 사용합니다. 이로 인해 예기치 못한 오류가 발생하며 실제로 모달 애니메이션 지속 시간은 앱이 실행되는 기기에 따라 다를 수 있습니다.\n\n요약하면, 여기서 직면한 문제는 표시 컴포넌트가 모든 로직 및 상태 관리를 처리해야 하고 표시하려는 각 모달마다 하나의 상태 변수가 필요하다는 것입니다.\n\n우리에게 가장 큰 문제는 한 가지 실수를 하게 되면, 두 개의 모달을 동시에 표시하려고 한다면 두 번째 모달이 나타나지 않고 오류/경고 메시지도 표시되지 않는다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 시도한 대체품\n\n리액트 네이티브 프로젝트에서 여러 모달을 관리하는 데 직면할 수 있는 두 가지 일반적인 문제는 다음과 같습니다:\n\n- 동시에 하나 이상의 모달을 표시할 수 없음\n- 모달이 더 많이 추가될수록 코드 복잡성이 기하급수적으로 증가함\n\n이러한 두 가지 문제로 인해 표준 네이티브 모달 컴포넌트를 사용하면서 이를 해결하기 위해 다양한 옵션을 시도해 보았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에는 여기서 가장 일반적으로 사용되는 2개의 라이브러리가 있으며, 이들을 사용한 이유와 우리가 고유한 방식으로 진행하기로 결정한 이유를 설명했습니다.\n\n# react-native-modal\n\n이는 표준 React Native Modal 컴포넌트의 확장입니다. 기존 기능에 추가적인 기능을 제공하여 들어오는/나가는 애니메이션 타이밍을 지정할 수 있거나 다른 콜백을 제공하여 API를 사용자 정의할 수 있습니다. 또한 기기 방향에 따라 스와이프할 수 있고 스크롤 가능하며 적응적인 콘텐츠를 제공합니다.\n\n하지만 이러한 기능이 얼마나 좋든, 이 라이브러리는 결국 React Native에서 모달이 작동하는 방식을 변경하지 않기 때문에 여전히 동시에 여러 모달을 표시하거나 코드 복잡성을 줄이는 등 위에서 언급한 같은 제한 사항을 갖고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# react-native-modalfy\n\n이 라이브러리는 이전 것보다 훨씬 인기가 적지만, 우리가 달성하고자 하는 방향과 일치합니다.\n\n첫 번째 이점은 JavaScript로 구현되어 여러 모달을 지원한다는 것입니다. 코드의 어느 곳에서든 JavaScript 함수를 호출할 수 있으며, 컴포넌트 트리를 혼동시키지 않고 추가적인 상태를 관리할 필요가 없습니다.\n\n다른 중요한 점은 명령형 API를 기반으로 하고 있으며, 각 모달의 외형에 대한 애니메이션과 전환을 완전히 사용자 정의할 수 있다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 장점들에도 불구하고, 이 라이브러리는 설정하기 위해 일부 뼈대 코드가 필요했습니다. 이런 면에서 React Navigation과 매우 유사합니다. 여러분은 프로젝트 내에서 사용할 각 모달을 미리 정의하고 각각에 대한 구성을 제공해야 합니다.\n\n또 다른 단점은 동일한 모달 유형의 여러 인스턴스를 표시하거나 숨기지 못한다는 것입니다. 같은 스타일을 공유하는 다양한 버튼과 복사본을 가진 다수의 모달이 있는 애플리케이션에서는, 다양한 모달 엔티티를 만드는 대신 서로 다른 복사본을 위한 특정 매개변수를 가진 하나의 모달만 가지는 것이 더 효율적입니다.\n\n# 우리의 해결책: rn-modal-presenter\n\n다양한 옵션을 분석한 후, 우리는 다음 기반으로 우리만의 라이브러리를 만들기로 결정했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 유연한 구성요소와 명령형 API\n\n유연하다는 의미는 어떤 구성요소든 모달로 표현할 수 있고, 상태를 수정하지 않고 코드의 어디서든(표시된 모달 내에서도) 표시/감춤을 관리할 수 있다는 것입니다.\n\n명령형 API를 사용하면 앱 전체 위에 모달이 표시되므로 어디서든 모달 표시를 트리거할 수 있습니다.\n\n# 콘텐츠는 부모 구성요소(보통 귀하의 구성요소) 위에 표시됩니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 부보 컴포넌트는 우리 라이브러리에서 노출되었고, 여러분은 해당 컴포넌트 트리 어딘가에 배치해야 합니다. 이것은 모달 창이 다른 일반 뷰와 화면에 비해 가장 높은 우선순위를 가지고 있기 때문에 멋집니다.\n\n# 다중 모달 지원\n\n100% 자바스크립트 라이브러리이기 때문에 여러 개의 모달을 쉽게 표시할 수 있습니다. 또한 동일한 모달 유형의 여러 인스턴스를 표시하는 것을 지원합니다.\n\n그러나 이에는 조금 제한이 있습니다. 자바스크립트 솔루션이기 때문에 프로젝트에 다른 네이티브 모달이 있는 경우, 해당 나중 모달은 여전히 우리 모달 위에 있을 수 있습니다. 왜냐하면 네이티브 컴포넌트가 가장 높은 우선순위를 가지기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 라이브러리 통합 방법\n\n단계 1: 프로젝트에 라이브러리 추가하기:\n\n- yarn add @whitespectre/rn-modal-presenter\n- npm install @whitespectre/rn-modal-presenter\n\n단계 2: 모달을 표시하고 싶은 컴포넌트 위에 래핑하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { ModalPresenterParent, showModal } from '@whitespectre/rn-modal-presenter';\n…\n\u003cModalPresenterParent\u003e\n  \u003cApp /\u003e\n\u003c/ModalPresenterParent\u003e\n```\n\n제 3단계: showModal 메소드를 호출하세요. 이 메소드는 다음을 받습니다:\n\n- 보여질 컴포넌트\n- 해당 컴포넌트로 전달될 속성\n- 나중에 모달을 해제하는 데 사용할 ModalHandler를 반환합니다.\n\n```js\nexport declare const showModal: \u003cContentProps\u003e(\n  Content: (props: ContentProps \u0026 ModalContentProps) =\u003e JSX.Element,\n  contentProps: ContentProps,\n) =\u003e ModalHandler;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그게 다야. 충분히 준비됐어요.\n\n## 더 복잡한 구현\n\n### 컴포넌트에 속성 전달하기\n\n모달 위에 표시하려는 컴포넌트에 속성을 추가하려면 컴포넌트에 도우미 함수를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 경우에는 showModal 함수를 호출하는 helper 함수를 만들 수 있습니다. 이 함수는 사용자에게 보여줄 텍스트와 사용자가 닫기 버튼을 눌렀을 때 실행할 완료 핸들러를 받는데, 이것은 custom text modal이 받는 속성을 받게 됩니다.\n\n```js\nexport const showCustomAlert = (\n  title: string,\n  body: string,\n  buttons: CustomAlertButton[] = [defaultButton],\n) =\u003e {\n  return showModal(CustomAlert, { title, body, buttons });\n};\n```\n\n## 컴포넌트 속성에 ModalContentProps 추가하기\n\n이 기능은 컴포넌트를 설치할 때 라이브러리에 의해 제공되며, dismiss 함수를 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst CustomAlert = ({\n  dismiss,\n  title,\n  body,\n  buttons\n}: CustomAlertProps \u0026 ModalContentProps) =\u003e {\n  return (\n    …\n```\n\n여기에는 모달 컴포넌트 속성으로 반환된 dismiss 함수를 전달하고 해당 dismiss를 모달 내에서 모달을 지우는 데 사용합니다.\n\n## 새 라이브러리를 사용한 원본 예제\n\nrn-modal-presenter 라이브러리를 사용하면 상태를 관리할 필요가 없고 어디에서든 모달 표시를 강제로 트리거할 수 있기 때문에 원본 예제는 다음과 같이 다시 작성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메인 앱 컴포넌트는 Gadget Activation 모달을 표시할 것입니다:\n\n```js\nconst App = () =\u003e {\n  return (\n    \u003cModalPresenterParent\u003e\n      \u003cSafeAreaView\u003e\n        \u003cButton\n          title=\"Gadget 활성화\"\n          onPress={() =\u003e {\n            showModal(ActivateGadgetModal, {});\n          }\n        /\u003e\n      \u003c/SafeAreaView\u003e\n    \u003c/ModalPresenterParent\u003e\n  );\n};\n```\n\n그리고 각 모달은 자체적으로 dismiss하고, 흐름에서 다음 모달을 표시하는 책임이 있을 것입니다. 예를 들어, ActivateGadgetModal은 아래와 같이 보일 것입니다:\n\n```js\nconst ActivateGadgetModal = ({dismiss}: ModalContentProps) =\u003e {\n  return (\n    \u003cView style={styles.modalOverlay}\u003e\n      \u003cView style={styles.modal}\u003e\n        \u003cView style={styles.contentContainer}\u003e\n          \u003cText\u003e당신의 Gadget이 활성화되었습니다\u003c/Text\u003e\n          \u003cView style={styles.buttonsContainer}\u003e\n            \u003cButton\n              title=\"닫기\"\n              onPress={() =\u003e {\n                dismiss();\n                showModal(RateAppModal, {});\n              }\n            /\u003e\n          \u003c/View\u003e\n        \u003c/View\u003e\n      \u003c/View\u003e\n    \u003c/View\u003e\n  );\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 미래 개선 사항\n\nrn-modal-presenter 라이브러리는 현재 진행 중인 프로젝트에 우리의 요구 사항에 맞게 만들어 졌지만, 사용하면서 다른 기능과 개선 사항들을 확인했습니다. 다른 사용 사례에 유용할 수 있는 것들입니다.\n\n여기 우리 라이브러리에 도입하고 싶은 주요 기능 및 개선 사항입니다:\n\n- 하나씩 보이도록 모달의 대기열 만들기\n- 현재 여러 개의 모달이 동시에 표시되려고 하면 서로 위에 겹쳐서 나타납니다.\n- 대기열은 우선순위 매커니즘을 포함하여 강제로 다음 모달을 표시할 수 있어야 합니다.\n- 뷰가 네이티브 뷰들 위에 나타날 수 있도록 만들기\n- 더불어 네이티브 모듈을 구축하여 내용을 네이티브 뷰 위에 표시할 수 있도록 하기\n- 각 효과에 대해 사용자 정의 가능한 애니메이션 및 지속 시간 허용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이러한 기능 중 어떤 것을 구현하고 싶거나 우리 라이브러리에 기여하고 싶다면, 언제든지 다음 링크에서 PR을 열어주세요: [https://github.com/whitespectre/rn-modal-presenter](https://github.com/whitespectre/rn-modal-presenter).","ogImage":{"url":"/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png"},"coverImage":"/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e여러 모달을 관리하는 것은 React Native의 표준 모달 구현 및 인기있는 서드 파티 라이브러리에서 볼 수 있는 제한 사항입니다. 이 문제에 대한 우리만의 접근 방식 및 우리의 rn-modal-presenter 라이브러리 사용 방법을 알아보세요.\u003c/h2\u003e\n\u003cp\u003e바이 화이트 스펙트어 React Native 팀\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-SupportingMultipleModalsinReactNativeANewApproach_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 기사는 화이트 스펙트어 React Native 팀 구성원인 Lucas Diez de Medina와 Rui Lu가 공동 저술했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e어플 빌드를 위한 조사 중에, 현재 React Native 표준 모달 구현이 동시에 여러 모달을 관리하지 못한다는 사실을 발견했습니다. 인기 있는 서드 파티 라이브러리들도 비슷한 제한을 가지고 있어서 우리에겐 작동하지 않았습니다. 더욱 복잡한 React Native 앱일수록 더 많은 제약이 생길 것입니다. 더 나쁜 점은, 에러가 발생할 수 있지만 눈에 띄지 않을 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e그래서 우리는 우리만의 간단한 방법을 만들기로 결정했고, rn-modal-presenter 라이브러리를 출시했습니다. 우리가 발견한 사항과 여러분의 React Native 프로젝트에 우리 라이브러리를 사용하는 방법을 알아보려면 계속 읽어주세요.\u003c/p\u003e\n\u003cp\u003e이 글에서 다루는 내용은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e서드 파티 모달 라이브러리의 제한 사항\u003c/li\u003e\n\u003cli\u003e테스트한 대안\u003c/li\u003e\n\u003cli\u003e우리의 해결책: rn-modal-presenter 라이브러리\u003c/li\u003e\n\u003cli\u003ern-modal-presenter 라이브러리 구현 방법\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003ern-modal-presenter 라이브러리의 전체 문서를 npm 및 GitHub에서 읽어보세요.\u003c/p\u003e\n\u003ch1\u003e서드파티 Modal 라이브러리의 제한 사항\u003c/h1\u003e\n\u003cp\u003e이제 위에서 언급한 대로, React Native에서 모달이 얼마나 중요한지는 알 수 있지만, 표준 구현은 몇 가지 중요한 제한 사항을 갖고 있습니다. 이는 사용자에게 다른 상황에서 여러 모달을 표시하려고 시도했을 때 우리가 발견한 것입니다.\u003c/p\u003e\n\u003cp\u003e모달은 일반적으로 프롭을 기반으로 표시되거나 숨겨지는 컴포넌트이며, 이 프롭은 일반적으로 표시하는 컴포넌트의 상태에 의해 제어됩니다. 해당 컴포넌트는 컴포넌트 트리의 일부여야 하며 표시하고 싶은 모든 컴포넌트의 자식으로 나타나야 합니다. 이러한 이유로 하나의 컴포넌트로 표시되는 여러 모달을 표시하려는 경우나 모달이 표시되는 별도의 화면으로 이동해야 하는 경우에 기본적인 제한 사항과 복잡성이 발생합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 내용을 한국어로 번역하면 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모달을 제어하는 상태를 관리해야 합니다.\u003c/li\u003e\n\u003cli\u003e상태를 업데이트함으로써 모달의 표시 및 숨김을 동시에 처리해야 합니다 (표시하는 컴포넌트 내에서).\u003c/li\u003e\n\u003cli\u003e특정 컴포넌트에서 모달을 표시한 후에 뒤로 이동하려면, 표시하는 컴포넌트가 언마운트되므로 모달도 사라집니다.\u003c/li\u003e\n\u003cli\u003eiOS에서는 동시에 두 개 이상의 모달을 표시하거나 서로 겹치는 여러 모달을 스택으로 관리할 수 없습니다: \u003ca href=\"https://github.com/react-native-modal/react-native-modal/issues/30\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/react-native-modal/react-native-modal/issues/30\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e마지막으로, 이 제한 사항은 iOS 네이티브 측면에 있습니다. UIViewController가 다른 뷰 컨트롤러를 표시한 후, 표시 중인 뷰 컨트롤러 (이제 숨겨진 상태)가 해당 뷰 컨트롤러 위에 다른 두 번째 뷰 컨트롤러를 표시할 수 없습니다. 따라서 이전에 표시된 뷰 컨트롤러에서 두 번째 뷰를 표시해야 합니다.\u003c/p\u003e\n\u003ch1\u003e간단한 예시\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e간단한 예제로이 한계를 확인해 보겠습니다. 여기서는 전통적인 모달을 사용하여 앱 평가를 받으려고 시도하지만, 특정 상황에서만 만족한 사용자에게만 보여줍니다.\u003c/p\u003e\n\u003cp\u003e사용자가 앱에서 관련 작업을 수행한 후에는 다음을 보여줍니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e작업이 완료되었음을 알리는 모달\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e앱에 대해 얼마나 만족하는지 묻는 모달\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e긍정적인 답변일 경우 AppStore에서 앱 평가를 요청하는 모달을 보여줍니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e부정적인 답변인 경우 피드백을 남겨 주시라는 모달을 제공합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그럼, 모든 이 modal들이 같은 메인 화면에서 제시되며 이 코드 스니펫에서 볼 수 있듯이 네 가지 다른 modal에 대한 모든 상태를 가지고 있으며 그 상태에 따라 각 modal을 표시합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [showRateAppModal, setShowRateAppModal] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [showAppRatedPositiveModal, setShowAppRatedPositiveModal] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [showAppRatedNegativeModal, setShowAppRatedNegativeModal] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [showActivateGadgetModal, setShowActivateGadgetModal] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n \n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n   \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eSafeAreaView\u003c/span\u003e\u003e\u003c/span\u003e\n     {showActivateGadgetModal \u0026#x26;\u0026#x26; (\n       \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eActivateGadgetModal\u003c/span\u003e\n         \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e {\n           setShowActivateGadgetModal(false);\n         }\n       /\u003e\n     )}\n     {showRateAppModal \u0026#x26;\u0026#x26; (\n       \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eRateAppModal\u003c/span\u003e\n         \u003cspan class=\"hljs-attr\"\u003epositiveFeedback\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e {\n           setShowRateAppModal(false);\n           setShowAppRatedPositiveModal(true);\n         }\n         negativeFeedback={() =\u003e {\n           setShowRateAppModal(false);\n           setShowAppRatedNegativeModal(true);\n         }\n       /\u003e\n     )}\n     {showAppRatedPositiveModal \u0026#x26;\u0026#x26; (\n       \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ePositiveFeedbackModal\u003c/span\u003e\n         \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e setShowAppRatedPositiveModal(false)}\n       /\u003e\n     )}\n     {showAppRatedNegativeModal \u0026#x26;\u0026#x26; (\n       \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eNegativeFeedbackModal\u003c/span\u003e\n         \u003cspan class=\"hljs-attr\"\u003eonDismiss\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e setShowAppRatedNegativeModal(false)}\n       /\u003e\n     )}\n     \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\n       \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Activate Gadget\"\u003c/span\u003e\n       \u003cspan class=\"hljs-attr\"\u003eonPress\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e {\n         setShowActivateGadgetModal(true);\n         setShowRateAppModal(true);\n       }\n     /\u003e\n   \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eSafeAreaView\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 상호작용은 상태를 같은 컴포넌트에서 제어하기 때문에 매우 간단합니다. 또한 우리는 저장소(store)를 가지고 있지 않습니다. 이미 4개의 상태 변수를 가지고 있는 저장소를 관리하고 있는데, 이것은 계속해 추가할수록 더 복잡해집니다.\u003c/p\u003e\n\u003cp\u003e이제 실수로 두 개의 modal을 동시에 표시하려고하면 어떻게 작동하는지 살펴보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 경우에는 첫 번째 모달이 iOS에서만 표시될 것이며, 이 문제의 가장 나쁜 부분은 React Native 콘솔에서는 오류가 발생하지 않았다는 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 Xcode 콘솔을 확인하면 현재 다른 View Controller 위에 View Controller를 표시하려고 시도하고 있는 것이 iOS 시스템에서 올바르지 않은 동작임을 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e보게 될 오류는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eWarning\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAttempt\u003c/span\u003e to present \u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUIViewController\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0x147d2c6b0\u003c/span\u003e\u003e on \u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUIViewController\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0x147d614c0\u003c/span\u003e\u003e which is already presenting (\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eiOS에서 올바른 흐름은 첫 번째 모달을 표시한 후에, 첫 번째 모달이 해제되면(해당 상태 변수를 false로 설정함으로써) 다음 모달의 상태 변수를 true로 설정하여 표시하는 것입니다.\u003c/p\u003e\n\u003cp\u003e상상할 수 있듯이, 이것은 매우 복잡해질 수 있습니다. 대부분의 경우 개발자들은 여러 모달의 해제와 표시를 관리하기 위해 지연 또는 시간 초과를 사용합니다. 이로 인해 예기치 못한 오류가 발생하며 실제로 모달 애니메이션 지속 시간은 앱이 실행되는 기기에 따라 다를 수 있습니다.\u003c/p\u003e\n\u003cp\u003e요약하면, 여기서 직면한 문제는 표시 컴포넌트가 모든 로직 및 상태 관리를 처리해야 하고 표시하려는 각 모달마다 하나의 상태 변수가 필요하다는 것입니다.\u003c/p\u003e\n\u003cp\u003e우리에게 가장 큰 문제는 한 가지 실수를 하게 되면, 두 개의 모달을 동시에 표시하려고 한다면 두 번째 모달이 나타나지 않고 오류/경고 메시지도 표시되지 않는다는 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e시도한 대체품\u003c/h1\u003e\n\u003cp\u003e리액트 네이티브 프로젝트에서 여러 모달을 관리하는 데 직면할 수 있는 두 가지 일반적인 문제는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e동시에 하나 이상의 모달을 표시할 수 없음\u003c/li\u003e\n\u003cli\u003e모달이 더 많이 추가될수록 코드 복잡성이 기하급수적으로 증가함\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 두 가지 문제로 인해 표준 네이티브 모달 컴포넌트를 사용하면서 이를 해결하기 위해 다양한 옵션을 시도해 보았습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래에는 여기서 가장 일반적으로 사용되는 2개의 라이브러리가 있으며, 이들을 사용한 이유와 우리가 고유한 방식으로 진행하기로 결정한 이유를 설명했습니다.\u003c/p\u003e\n\u003ch1\u003ereact-native-modal\u003c/h1\u003e\n\u003cp\u003e이는 표준 React Native Modal 컴포넌트의 확장입니다. 기존 기능에 추가적인 기능을 제공하여 들어오는/나가는 애니메이션 타이밍을 지정할 수 있거나 다른 콜백을 제공하여 API를 사용자 정의할 수 있습니다. 또한 기기 방향에 따라 스와이프할 수 있고 스크롤 가능하며 적응적인 콘텐츠를 제공합니다.\u003c/p\u003e\n\u003cp\u003e하지만 이러한 기능이 얼마나 좋든, 이 라이브러리는 결국 React Native에서 모달이 작동하는 방식을 변경하지 않기 때문에 여전히 동시에 여러 모달을 표시하거나 코드 복잡성을 줄이는 등 위에서 언급한 같은 제한 사항을 갖고 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003ereact-native-modalfy\u003c/h1\u003e\n\u003cp\u003e이 라이브러리는 이전 것보다 훨씬 인기가 적지만, 우리가 달성하고자 하는 방향과 일치합니다.\u003c/p\u003e\n\u003cp\u003e첫 번째 이점은 JavaScript로 구현되어 여러 모달을 지원한다는 것입니다. 코드의 어느 곳에서든 JavaScript 함수를 호출할 수 있으며, 컴포넌트 트리를 혼동시키지 않고 추가적인 상태를 관리할 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003e다른 중요한 점은 명령형 API를 기반으로 하고 있으며, 각 모달의 외형에 대한 애니메이션과 전환을 완전히 사용자 정의할 수 있다는 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위 장점들에도 불구하고, 이 라이브러리는 설정하기 위해 일부 뼈대 코드가 필요했습니다. 이런 면에서 React Navigation과 매우 유사합니다. 여러분은 프로젝트 내에서 사용할 각 모달을 미리 정의하고 각각에 대한 구성을 제공해야 합니다.\u003c/p\u003e\n\u003cp\u003e또 다른 단점은 동일한 모달 유형의 여러 인스턴스를 표시하거나 숨기지 못한다는 것입니다. 같은 스타일을 공유하는 다양한 버튼과 복사본을 가진 다수의 모달이 있는 애플리케이션에서는, 다양한 모달 엔티티를 만드는 대신 서로 다른 복사본을 위한 특정 매개변수를 가진 하나의 모달만 가지는 것이 더 효율적입니다.\u003c/p\u003e\n\u003ch1\u003e우리의 해결책: rn-modal-presenter\u003c/h1\u003e\n\u003cp\u003e다양한 옵션을 분석한 후, 우리는 다음 기반으로 우리만의 라이브러리를 만들기로 결정했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e유연한 구성요소와 명령형 API\u003c/h1\u003e\n\u003cp\u003e유연하다는 의미는 어떤 구성요소든 모달로 표현할 수 있고, 상태를 수정하지 않고 코드의 어디서든(표시된 모달 내에서도) 표시/감춤을 관리할 수 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003e명령형 API를 사용하면 앱 전체 위에 모달이 표시되므로 어디서든 모달 표시를 트리거할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e콘텐츠는 부모 구성요소(보통 귀하의 구성요소) 위에 표시됩니다\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 부보 컴포넌트는 우리 라이브러리에서 노출되었고, 여러분은 해당 컴포넌트 트리 어딘가에 배치해야 합니다. 이것은 모달 창이 다른 일반 뷰와 화면에 비해 가장 높은 우선순위를 가지고 있기 때문에 멋집니다.\u003c/p\u003e\n\u003ch1\u003e다중 모달 지원\u003c/h1\u003e\n\u003cp\u003e100% 자바스크립트 라이브러리이기 때문에 여러 개의 모달을 쉽게 표시할 수 있습니다. 또한 동일한 모달 유형의 여러 인스턴스를 표시하는 것을 지원합니다.\u003c/p\u003e\n\u003cp\u003e그러나 이에는 조금 제한이 있습니다. 자바스크립트 솔루션이기 때문에 프로젝트에 다른 네이티브 모달이 있는 경우, 해당 나중 모달은 여전히 우리 모달 위에 있을 수 있습니다. 왜냐하면 네이티브 컴포넌트가 가장 높은 우선순위를 가지기 때문입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e라이브러리 통합 방법\u003c/h1\u003e\n\u003cp\u003e단계 1: 프로젝트에 라이브러리 추가하기:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eyarn add @whitespectre/rn-modal-presenter\u003c/li\u003e\n\u003cli\u003enpm install @whitespectre/rn-modal-presenter\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단계 2: 모달을 표시하고 싶은 컴포넌트 위에 래핑하기:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eModalPresenterParent\u003c/span\u003e, showModal } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@whitespectre/rn-modal-presenter'\u003c/span\u003e;\n…\n\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eModalPresenterParent\u003c/span\u003e\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eApp\u003c/span\u003e /\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/\u003cspan class=\"hljs-title class_\"\u003eModalPresenterParent\u003c/span\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제 3단계: showModal 메소드를 호출하세요. 이 메소드는 다음을 받습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e보여질 컴포넌트\u003c/li\u003e\n\u003cli\u003e해당 컴포넌트로 전달될 속성\u003c/li\u003e\n\u003cli\u003e나중에 모달을 해제하는 데 사용할 ModalHandler를 반환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e declare \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eshowModal\u003c/span\u003e: \u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eContentProps\u003c/span\u003e\u003e\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\n  Content: (props: ContentProps \u0026#x26; ModalContentProps) =\u003e JSX.Element,\n  contentProps: ContentProps,\n\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eModalHandler\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그게 다야. 충분히 준비됐어요.\u003c/p\u003e\n\u003ch2\u003e더 복잡한 구현\u003c/h2\u003e\n\u003ch3\u003e컴포넌트에 속성 전달하기\u003c/h3\u003e\n\u003cp\u003e모달 위에 표시하려는 컴포넌트에 속성을 추가하려면 컴포넌트에 도우미 함수를 만들 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 경우에는 showModal 함수를 호출하는 helper 함수를 만들 수 있습니다. 이 함수는 사용자에게 보여줄 텍스트와 사용자가 닫기 버튼을 눌렀을 때 실행할 완료 핸들러를 받는데, 이것은 custom text modal이 받는 속성을 받게 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eshowCustomAlert\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\n  title: string,\n  body: string,\n  buttons: CustomAlertButton[] = [defaultButton],\n\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eshowModal\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eCustomAlert\u003c/span\u003e, { title, body, buttons });\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e컴포넌트 속성에 ModalContentProps 추가하기\u003c/h2\u003e\n\u003cp\u003e이 기능은 컴포넌트를 설치할 때 라이브러리에 의해 제공되며, dismiss 함수를 포함합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eCustomAlert\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{\n  dismiss,\n  title,\n  body,\n  buttons\n}: CustomAlertProps \u0026#x26; ModalContentProps\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    …\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에는 모달 컴포넌트 속성으로 반환된 dismiss 함수를 전달하고 해당 dismiss를 모달 내에서 모달을 지우는 데 사용합니다.\u003c/p\u003e\n\u003ch2\u003e새 라이브러리를 사용한 원본 예제\u003c/h2\u003e\n\u003cp\u003ern-modal-presenter 라이브러리를 사용하면 상태를 관리할 필요가 없고 어디에서든 모달 표시를 강제로 트리거할 수 있기 때문에 원본 예제는 다음과 같이 다시 작성할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e메인 앱 컴포넌트는 Gadget Activation 모달을 표시할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eModalPresenterParent\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eSafeAreaView\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Gadget 활성화\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eonPress\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e {\n            showModal(ActivateGadgetModal, {});\n          }\n        /\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eSafeAreaView\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eModalPresenterParent\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 각 모달은 자체적으로 dismiss하고, 흐름에서 다음 모달을 표시하는 책임이 있을 것입니다. 예를 들어, ActivateGadgetModal은 아래와 같이 보일 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eActivateGadgetModal\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e{dismiss}: ModalContentProps\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.modalOverlay}\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.modal}\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.contentContainer}\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e당신의 Gadget이 활성화되었습니다\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eText\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{styles.buttonsContainer}\u003c/span\u003e\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"닫기\"\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003eonPress\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e {\n                dismiss();\n                showModal(RateAppModal, {});\n              }\n            /\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eView\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e미래 개선 사항\u003c/h1\u003e\n\u003cp\u003ern-modal-presenter 라이브러리는 현재 진행 중인 프로젝트에 우리의 요구 사항에 맞게 만들어 졌지만, 사용하면서 다른 기능과 개선 사항들을 확인했습니다. 다른 사용 사례에 유용할 수 있는 것들입니다.\u003c/p\u003e\n\u003cp\u003e여기 우리 라이브러리에 도입하고 싶은 주요 기능 및 개선 사항입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e하나씩 보이도록 모달의 대기열 만들기\u003c/li\u003e\n\u003cli\u003e현재 여러 개의 모달이 동시에 표시되려고 하면 서로 위에 겹쳐서 나타납니다.\u003c/li\u003e\n\u003cli\u003e대기열은 우선순위 매커니즘을 포함하여 강제로 다음 모달을 표시할 수 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e뷰가 네이티브 뷰들 위에 나타날 수 있도록 만들기\u003c/li\u003e\n\u003cli\u003e더불어 네이티브 모듈을 구축하여 내용을 네이티브 뷰 위에 표시할 수 있도록 하기\u003c/li\u003e\n\u003cli\u003e각 효과에 대해 사용자 정의 가능한 애니메이션 및 지속 시간 허용하기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 이러한 기능 중 어떤 것을 구현하고 싶거나 우리 라이브러리에 기여하고 싶다면, 언제든지 다음 링크에서 PR을 열어주세요: \u003ca href=\"https://github.com/whitespectre/rn-modal-presenter\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/whitespectre/rn-modal-presenter\u003c/a\u003e.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-SupportingMultipleModalsinReactNativeANewApproach"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>