<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>앵귤러에서의 HTTP Interceptors | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-HTTPInterceptorsinAngular" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="앵귤러에서의 HTTP Interceptors | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="앵귤러에서의 HTTP Interceptors | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-HTTPInterceptorsinAngular" data-gatsby-head="true"/><meta name="twitter:title" content="앵귤러에서의 HTTP Interceptors | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 23:44" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_buildManifest.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">앵귤러에서의 HTTP Interceptors</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="앵귤러에서의 HTTP Interceptors" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-HTTPInterceptorsinAngular&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><img src="/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png"/>
<p>안녕하세요! 이 글에서는 Angular에서 HTTP Interceptor의 기본 개념과 몇 가지 예제에 대해 알아보고자 합니다. Angular 15를 사용하여 함께 살펴보겠습니다.</p>
<h1>안내</h1>
<ul>
<li>Angular란 무엇인가요?</li>
</ul>
<p><strong>HTTP Interceptor란 무엇인가요?</strong></p>
<p><strong>Angular에서의 HTTP Interceptor</strong></p>
<p><strong>HTTP Interceptor의 장점</strong></p>
<p><strong>실용적인 구현</strong></p>
<h1>선행 요건</h1>
<ul>
<li>
<p>TypeScript와 Angular에 대한 기본적인 이해</p>
</li>
<li>
<p>Angular CLI</p>
</li>
<li>
<p>NodeJS</p>
</li>
<li>
<p>VS Code</p>
</li>
</ul>
<h2>Angular이란 무엇인가요?</h2>
<p>Angular은 웹 애플리케이션을 구축하기 위한 인기 있는 오픈 소스 JavaScript 프레임워크입니다. Google에서 개발되었으며 현재는 Google의 Angular 팀에서 유지 보수되고 있습니다. Angular를 사용하면 개발자들은 동적인, 싱글 페이지 애플리케이션 (SPA)을 만들 수 있으며 복잡한 웹 애플리케이션을 구축하기 위한 구조화된 접근법을 제공합니다.</p>
<h2>HTTP Interceptor란 무엇인가요?</h2>
<ul>
<li>
<p>HTTP Interceptors(인터셉터)는 웹 개발과 서버 측 프로그래밍에서  자주 사용되는 개념입니다. 이는 주로 웹 프레임워크와 라이브러리와 관련이 있습니다.</p>
</li>
<li>
<p>이러한 인터셉터를 통해 개발자는 응용 프로그램 전체에서 HTTP 요청과 응답을 가로채고 처리할 수 있습니다.</p>
</li>
</ul>
<h2>Angular의 HTTP 인터셉터</h2>
<ul>
<li>Angular의 HTTP 인터셉터는 HttpInterceptor 인터페이스를 구현하는 클래스입니다.</li>
</ul>
<img src="/assets/img/2024-05-12-HTTPInterceptorsinAngular_1.png"/>
<ul>
<li>
<p>HTTP 요청 및 응답과 관련된 다양한 작업을 수행하는 데 사용할 수 있습니다. 예를 들어 헤더 추가, 오류 처리, 요청 또는 응답 데이터 수정, 로깅, 인증 등이 있습니다.</p>
</li>
<li>
<p>HttpInterceptor는 HttpRequest 및 HttpHandler 두 매개변수를 사용하는 intercept라는 단일 메서드를 정의합니다.</p>
</li>
</ul>
<h1>HTTP 인터셉터의 장점</h1>
<p>아래는 Angular에서 HTTP Interceptor를 사용하는 주요 이점 중 일부입니다:</p>
<p>테스트 용이성 및 재사용성: Interceptor는 고립된 환경에서 쉽게 테스트할 수 있어 각 Interceptor가 올바르게 작동하는지 확인할 수 있습니다.</p>
<p>크로스 커팅 관심사를 위한 중앙화된 코드: HTTP Interceptor를 사용하면 인증, 로깅, 오류 처리 또는 헤더 추가와 같은 일반 작업에 대한 논리를 중앙 위치에 정의할 수 있습니다.</p>
<p>전역 응용 프로그램 수준의 수정: Interceptor는 전역적으로 작동하여 Angular 애플리케이션이 만드는 모든 HTTP 요청과 응답을 가로챕니다. 이는 각 개별 요청이나 응답을 수동으로 수정하지 않아도 여러 API 호출에 일관되게 변경 적용하거나 작업을 수행할 수 있음을 의미합니다.</p>
<p>오류 처리 및 로깅: 인터셉터를 활용하여 전역적으로 오류를 처리할 수 있으며, 애플리케이션 전반에 걸친 일관된 방식으로 오류 보고 및 처리를 제공할 수 있습니다.</p>
<p>캐싱 및 요청/응답 조작: HTTP 인터셉터를 활용하여 캐싱 메커니즘을 구현하면 중복 요청을 줄이고 애플리케이션 성능을 최적화할 수 있습니다.</p>
<p>역할 분리: HTTP 인터셉터를 사용하면 데이터 검색 및 통신 (HTTP)과 관련된 문제를 컴포넌트 및 서비스의 비즈니스 로직과 분리할 수 있습니다.</p>
<p>보안 및 인증: 인터셉터는 인증 헤더나 인증 토큰을 발신 요청에 추가하는 데 일반적으로 사용됩니다. 이를 통해 사용자의 인증 상태가 API 호출에 자동으로 포함되어 매번 헤더를 명시적으로 설정할 필요가 없습니다.</p>
<p>세 번째 두 번째 줄은 Markdown 표현식으로 바꿈:</p>
<p>| Easy integration with third-party libraries: Interceptors can be used to integrate with third-party libraries or APIs seamlessly. For example, you can apply a specific format to API responses that are expected by a charting library or a data visualization tool.</p>
<h2>실용적인 구현</h2>
<p>실용적인 구현부터 시작해보겠습니다; 이를 위해 다음 명령을 사용하여 새 Angular 어플리케이션을 생성해야 합니다.</p>
<p>이제 우리는 Angular를 사용하여 하나씩 다른 인터셉터를 만들어 보겠습니다.</p>
<ol>
<li>로깅 인터셉터</li>
</ol>
<p>Angular에서는 로깅 인터셉터를 감사 로그 목적으로 사용할 수 있습니다. 요청과 응답 개체로 다양한 들어오는 요청과 나가는 요청을 로깅하려면 로깅 인터셉터의 도움을 받을 수 있습니다.</p>
<p>단계 1</p>
<p>다음 명령어를 사용하여 새로운 로깅 인터셉터를 생성하세요.</p>
<p>이 명령은 기본 구현을 사용하여 로깅 인터페이스를 생성합니다. 그러므로 아래에 나와 있는 대로 수정해주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;
<span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">HttpEvent</span>,
  <span class="hljs-title class_">HttpInterceptor</span>,
  <span class="hljs-title class_">HttpHandler</span>,
  <span class="hljs-title class_">HttpRequest</span>,
  <span class="hljs-title class_">HttpResponse</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/common/http&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span>, tap } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingInterceptor</span> implements <span class="hljs-title class_">HttpInterceptor</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}

  <span class="hljs-title function_">intercept</span>(
    <span class="hljs-attr">request</span>: <span class="hljs-title class_">HttpRequest</span>&lt;any&gt;,
    <span class="hljs-attr">next</span>: <span class="hljs-title class_">HttpHandler</span>
  ): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-title class_">HttpEvent</span>&lt;any&gt;&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Outgoing HTTP request&#x27;</span>, request);
    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>(request).<span class="hljs-title function_">pipe</span>(
      <span class="hljs-title function_">tap</span>(<span class="hljs-function">(<span class="hljs-params">event: HttpEvent&lt;any&gt;</span>) =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Incoming HTTP response&#x27;</span>, event);
      })
    );
  }
}
</code></pre>
<ul>
<li>
<p>여기에서는 Angular의 HTTP 패키지에서 필요한 모듈과 클래스를 가져옵니다.</p>
</li>
<li>
<p>HttpInterceptor 인터페이스는 사용자 정의 인터셉터를 만들 수 있게 해주며, HttpRequest, HttpHandler 및 HttpEvent는 HTTP 요청과 응답을 처리하는 데 사용되는 클래스입니다.</p>
</li>
<li>
<p>우리는 비동기 작업을 처리하는 RxJS 라이브러리에서 Observable 및 Tap을 가져와 사용합니다.</p>
</li>
<li>
<p>next.handle(request)를 호출하여 요청을 체인의 다음 인터셉터 또는 백엔드 서버로 전달합니다.</p>
</li>
<li>
<p>그런 다음, tap 연산자와 함께 pipe 메서드를 사용하여 들어오는 응답을 가로챕니다.</p>
</li>
<li>
<p>tap 연산자를 사용하면 응답 자체를 수정하지 않고도 부작용(이 경우 응답을 로깅하는)을 실행할 수 있습니다.</p>
</li>
</ul>
<p>단계 2</p>
<p>앱 모듈에 인터셉터를 제공하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">LoggingInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./interceptors/logging.interceptor&#x27;</span>;

<span class="hljs-attr">providers</span>: [
    {
      <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">HTTP_INTERCEPTORS</span>, <span class="hljs-attr">useClass</span>: <span class="hljs-title class_">LoggingInterceptor</span>, <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>
    }
]
</code></pre>
<p>AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 LoggingInterceptor 클래스를 인터셉터로 제공합니다. multi: true 옵션은 인터셉터가 기존 인터셉터 배열에 추가되도록 하며 덮어쓰지 않도록 합니다.</p>
<p>HTTP 요청을 보낼 때, 다음과 같은 요청과 응답이 로그에 기록됩니다:</p>
<p><img src="/assets/img/2024-05-12-HTTPInterceptorsinAngular_2.png" alt="HTTPInterceptorsinAngular_2"/></p>
<p>실제 시나리오에서는 필요에 따라 이 응답을 서드파티 서비스에 기록할 수 있습니다.</p>
<ol start="2">
<li>요청에 헤더 추가</li>
</ol>
<p>앵귤러에서는 인터셉터를 활용하여 HTTP 요청을 수정하고 요청 헤더에 추가적인 값들을 넣을 수 있어요.</p>
<p>단계 1</p>
<p>다음 명령어를 사용하여 새 헤더 인터셉터를 만들어보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;
<span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">HttpRequest</span>,
  <span class="hljs-title class_">HttpHandler</span>,
  <span class="hljs-title class_">HttpEvent</span>,
  <span class="hljs-title class_">HttpInterceptor</span>
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/common/http&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeadersInterceptor</span> implements <span class="hljs-title class_">HttpInterceptor</span> {

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}

  <span class="hljs-title function_">intercept</span>(<span class="hljs-attr">request</span>: <span class="hljs-title class_">HttpRequest</span>&lt;unknown&gt;, <span class="hljs-attr">next</span>: <span class="hljs-title class_">HttpHandler</span>): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-title class_">HttpEvent</span>&lt;unknown&gt;&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request)
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">GUID</span> = <span class="hljs-string">&#x27;f4179b26-21ac-432c-bcd8-cb4bc6e50981&#x27;</span>
    <span class="hljs-keyword">const</span> modifiedRequest = request.<span class="hljs-title function_">clone</span>({
      <span class="hljs-attr">setHeaders</span>:{
        <span class="hljs-variable constant_">GUID</span>
      }
    })
    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>(modifiedRequest);
  }
}
</code></pre>
<p>먼저 헤더 안에 설정할 GUID를 하드코딩합니다. 그래서 먼저 HTTP 요청을 복제하고 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.</p>
<h3>단계 2</h3>
<p>앱 모듈에 인터셉터를 제공하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">HeadersInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./interceptors/headers.interceptor&#x27;</span>

<span class="hljs-attr">providers</span>: [
    {
      <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">HTTP_INTERCEPTORS</span>, <span class="hljs-attr">useClass</span>: <span class="hljs-title class_">HeadersInterceptor</span>, <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>
    }
  ]
</code></pre>
<p>AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 Interceptor가 기존 Interceptor 배열에 추가되도록 하는 것을 보장하며, 기존 Interceptor를 대체하지 않습니다.</p>
<p><img src="/assets/img/2024-05-12-HTTPInterceptorsinAngular_3.png" alt="HTTP Interceptors in Angular"/></p>
<p>실제 시나리오에서는 이러한 헤더 값들을 추가로 처리하는 데 활용할 수 있습니다. 예를 들어 요청을 유효성 검사하거나 다른 여러 경우에 사용할 수 있습니다.</p>
<ol start="3">
<li>에러 처리 Interceptor</li>
</ol>
<p>앵귤러에서, 에러 인터셉터는 HTTP 인터셉터로서 어플리케이션 전반에 걸쳐 HTTP 에러를 처리할 수 있게 해주는 기능입니다.</p>
<p>서버로 HTTP 요청을 보낼 때, 404나 500과 같은 에러 상태 코드로 응답을 받을 수 있는 상황이 발생할 수 있습니다.</p>
<p>각각의 HTTP 요청마다 이러한 에러들을 처리하는 것은 지루하고 반복적일 수 있습니다.</p>
<p>에러 인터셉터는 에러 처리 로직을 중앙화시켜 주며, 어플리케이션 전반에 걸쳐 일관된 방법으로 에러를 관리할 수 있도록 도와줍니다.</p>
<p><strong>단계 1</strong></p>
<p>다음 명령을 사용하여 새로운 오류 인터셉터를 생성하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;
<span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">HttpRequest</span>,
  <span class="hljs-title class_">HttpHandler</span>,
  <span class="hljs-title class_">HttpEvent</span>,
  <span class="hljs-title class_">HttpInterceptor</span>,
  <span class="hljs-title class_">HttpErrorResponse</span>
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/common/http&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span>, catchError, throwError } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorInterceptor</span> implements <span class="hljs-title class_">HttpInterceptor</span> {

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}

  <span class="hljs-title function_">intercept</span>(<span class="hljs-attr">request</span>: <span class="hljs-title class_">HttpRequest</span>&lt;any&gt;, <span class="hljs-attr">next</span>: <span class="hljs-title class_">HttpHandler</span>): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-title class_">HttpEvent</span>&lt;any&gt;&gt; {
    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>(request).<span class="hljs-title function_">pipe</span>(
      <span class="hljs-title function_">catchError</span>(<span class="hljs-function">(<span class="hljs-params">error: HttpErrorResponse</span>) =&gt;</span> {
        <span class="hljs-comment">// 여기서 오류를 처리합니다</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;오류 발생:&#x27;</span>, error);
        <span class="hljs-comment">// 요구에 따라 오류 throw</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">throwError</span>(error);
      })
    );
  }
}
</code></pre>
<ul>
<li><code>intercept()</code> 메서드 내에서 RxJS의 <code>catchError</code> 연산자를 사용하여 HTTP 요청이나 응답 처리 중 발생하는 오류를 잡을 수 있습니다.</li>
</ul>
<p><strong>단계 1</strong></p>
<p>· 오류를 가로채고 필요에 따라 처리하고, 오류를 선택적으로 다시 던져서 observable 체인을 계속 전파할 수 있게 합니다.</p>
<p><strong>단계 2</strong></p>
<p>· 앱 모듈에서 인터셉터를 제공하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ErrorInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./interceptors/error.interceptor&#x27;</span>;

<span class="hljs-attr">providers</span>: [
  {
    <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">HTTP_INTERCEPTORS</span>, <span class="hljs-attr">useClass</span>: <span class="hljs-title class_">ErrorInterceptor</span>, <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>
  }
]
</code></pre>
<p>· AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션을 사용하면 Interceptor가 기존 Interceptor 배열에 추가되며 대체되지 않습니다.</p>
<ol start="4">
<li>Authentication Interceptor</li>
</ol>
<p>Angular에서는 인증 Interceptor를 사용하여 모든 외부 HTTP 요청에 인증 토큰이나 헤더를 추가할 수 있습니다. API 요청이 모두 인증된 상태인지 확인해야 할 때 유용합니다.</p>
<p>단계 1</p>
<p>다음 명령어를 사용하여 새로운 인증 인터셉터를 만들어보세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>;
<span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">HttpEvent</span>,
  <span class="hljs-title class_">HttpInterceptor</span>,
  <span class="hljs-title class_">HttpHandler</span>,
  <span class="hljs-title class_">HttpRequest</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/common/http&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;
<span class="hljs-comment">//import { AuthService } from &#x27;./auth.service&#x27;;</span>

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthInterceptor</span> implements <span class="hljs-title class_">HttpInterceptor</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-comment">/*private authService: AuthService*/</span></span>) {}

  <span class="hljs-title function_">intercept</span>(
    <span class="hljs-attr">req</span>: <span class="hljs-title class_">HttpRequest</span>&lt;any&gt;,
    <span class="hljs-attr">next</span>: <span class="hljs-title class_">HttpHandler</span>
  ): <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-title class_">HttpEvent</span>&lt;any&gt;&gt; {
    <span class="hljs-keyword">const</span> authToken = <span class="hljs-string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpheWRlZXAgUGF0aWwiLCJpYXQiOjE1MTYyMzkwMjJ9.yt3EOXf60R62Mef2oFpbFh2ihkP5qZ4fM8bjVnF8YhA&quot;</span>;<span class="hljs-comment">//his.authService.getToken();</span>

    <span class="hljs-keyword">if</span> (authToken) {
      <span class="hljs-comment">// 요청을 복제하고 토큰을 첨부합니다</span>
      <span class="hljs-keyword">const</span> authReq = req.<span class="hljs-title function_">clone</span>({
        <span class="hljs-attr">setHeaders</span>: {
          <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${authToken}</span>`</span>
        }
      });

      <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>(authReq);
    }

    <span class="hljs-comment">// 토큰이 없는 경우 원본 요청을 전달합니다</span>
    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>(req);
  }
}
</code></pre>
<p>여기서 우리는 먼저 헤더에 설정할 하나의 토큰을 하드코딩합니다. 따라서 첫 번째로 HTTP 요청을 복제하고 요청 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.</p>
<p>Step 2</p>
<p>앱 모듈에서 인터셉터를 제공하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">AuthInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./interceptors/auth.interceptor&#x27;</span>;

<span class="hljs-attr">providers</span>: [
  {
    <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">HTTP_INTERCEPTORS</span>, <span class="hljs-attr">useClass</span>: <span class="hljs-title class_">AuthInterceptor</span>, <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>
  }
]  
</code></pre>
<p>AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 인터셉터로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 인터셉터가 기존의 인터셉터 배열에 추가되도록 하는 것을 보장합니다.</p>
<p>HTTP 요청을 보낼 때, 아래와 같이 헤더 내에 토큰을 설정할 것입니다.</p>
<img src="/assets/img/2024-05-12-HTTPInterceptorsinAngular_4.png"/>
<p>여기서 볼 수 있듯이, 필요에 따라 추가 처리에 사용할 수 있는 하나의 bearer 토큰을 설정했습니다.</p>
<h1>GitHub URL</h1>
<p>https://github.com/Jaydeep-007/angular-http-interceptor-demo</p>
<h1>결론</h1>
<p>이 글에서는 인터셉터의 기본, 이점 및 실시간 사용 사례를 Angular 15를 사용하여 단계별 구현을 통해 설명했습니다.</p>
<p>코딩하세요!</p>
<h1>간단히 말해서</h1>
<p>우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:</p>
<ul>
<li>작가를 박수로 칭찬하고 팔로우해 주세요! 👏</li>
<li>PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀</li>
<li>무료 주간 뉴스레터에 가입해주세요. 🗞️</li>
<li>트위터, 링크드인, 유튜브, 디스코드에서도 우리를 팔로우해주세요.</li>
</ul></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"앵귤러에서의 HTTP Interceptors","description":"","date":"2024-05-12 23:44","slug":"2024-05-12-HTTPInterceptorsinAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png\" /\u003e\n\n안녕하세요! 이 글에서는 Angular에서 HTTP Interceptor의 기본 개념과 몇 가지 예제에 대해 알아보고자 합니다. Angular 15를 사용하여 함께 살펴보겠습니다.\n\n# 안내\n\n- Angular란 무엇인가요?\n\n\n\n**HTTP Interceptor란 무엇인가요?**\n\n**Angular에서의 HTTP Interceptor**\n\n**HTTP Interceptor의 장점**\n\n**실용적인 구현**\n\n\n\n# 선행 요건\n\n- TypeScript와 Angular에 대한 기본적인 이해\n- Angular CLI\n- NodeJS\n\n\n\n- VS Code\n\n## Angular이란 무엇인가요?\n\nAngular은 웹 애플리케이션을 구축하기 위한 인기 있는 오픈 소스 JavaScript 프레임워크입니다. Google에서 개발되었으며 현재는 Google의 Angular 팀에서 유지 보수되고 있습니다. Angular를 사용하면 개발자들은 동적인, 싱글 페이지 애플리케이션 (SPA)을 만들 수 있으며 복잡한 웹 애플리케이션을 구축하기 위한 구조화된 접근법을 제공합니다.\n\n## HTTP Interceptor란 무엇인가요?\n\n\n\n- HTTP Interceptors(인터셉터)는 웹 개발과 서버 측 프로그래밍에서  자주 사용되는 개념입니다. 이는 주로 웹 프레임워크와 라이브러리와 관련이 있습니다.\n\n- 이러한 인터셉터를 통해 개발자는 응용 프로그램 전체에서 HTTP 요청과 응답을 가로채고 처리할 수 있습니다.\n\n## Angular의 HTTP 인터셉터\n\n- Angular의 HTTP 인터셉터는 HttpInterceptor 인터페이스를 구현하는 클래스입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_1.png\" /\u003e\n\n- HTTP 요청 및 응답과 관련된 다양한 작업을 수행하는 데 사용할 수 있습니다. 예를 들어 헤더 추가, 오류 처리, 요청 또는 응답 데이터 수정, 로깅, 인증 등이 있습니다.\n\n- HttpInterceptor는 HttpRequest 및 HttpHandler 두 매개변수를 사용하는 intercept라는 단일 메서드를 정의합니다.\n\n# HTTP 인터셉터의 장점\n\n\n\n아래는 Angular에서 HTTP Interceptor를 사용하는 주요 이점 중 일부입니다:\n\n테스트 용이성 및 재사용성: Interceptor는 고립된 환경에서 쉽게 테스트할 수 있어 각 Interceptor가 올바르게 작동하는지 확인할 수 있습니다.\n\n크로스 커팅 관심사를 위한 중앙화된 코드: HTTP Interceptor를 사용하면 인증, 로깅, 오류 처리 또는 헤더 추가와 같은 일반 작업에 대한 논리를 중앙 위치에 정의할 수 있습니다.\n\n전역 응용 프로그램 수준의 수정: Interceptor는 전역적으로 작동하여 Angular 애플리케이션이 만드는 모든 HTTP 요청과 응답을 가로챕니다. 이는 각 개별 요청이나 응답을 수동으로 수정하지 않아도 여러 API 호출에 일관되게 변경 적용하거나 작업을 수행할 수 있음을 의미합니다.\n\n\n\n오류 처리 및 로깅: 인터셉터를 활용하여 전역적으로 오류를 처리할 수 있으며, 애플리케이션 전반에 걸친 일관된 방식으로 오류 보고 및 처리를 제공할 수 있습니다.\n\n캐싱 및 요청/응답 조작: HTTP 인터셉터를 활용하여 캐싱 메커니즘을 구현하면 중복 요청을 줄이고 애플리케이션 성능을 최적화할 수 있습니다.\n\n역할 분리: HTTP 인터셉터를 사용하면 데이터 검색 및 통신 (HTTP)과 관련된 문제를 컴포넌트 및 서비스의 비즈니스 로직과 분리할 수 있습니다.\n\n보안 및 인증: 인터셉터는 인증 헤더나 인증 토큰을 발신 요청에 추가하는 데 일반적으로 사용됩니다. 이를 통해 사용자의 인증 상태가 API 호출에 자동으로 포함되어 매번 헤더를 명시적으로 설정할 필요가 없습니다.\n\n\n\n세 번째 두 번째 줄은 Markdown 표현식으로 바꿈:\n\n| Easy integration with third-party libraries: Interceptors can be used to integrate with third-party libraries or APIs seamlessly. For example, you can apply a specific format to API responses that are expected by a charting library or a data visualization tool. \n\n## 실용적인 구현\n\n실용적인 구현부터 시작해보겠습니다; 이를 위해 다음 명령을 사용하여 새 Angular 어플리케이션을 생성해야 합니다.\n\n이제 우리는 Angular를 사용하여 하나씩 다른 인터셉터를 만들어 보겠습니다.\n\n\n\n1. 로깅 인터셉터\n\nAngular에서는 로깅 인터셉터를 감사 로그 목적으로 사용할 수 있습니다. 요청과 응답 개체로 다양한 들어오는 요청과 나가는 요청을 로깅하려면 로깅 인터셉터의 도움을 받을 수 있습니다.\n\n단계 1\n\n다음 명령어를 사용하여 새로운 로깅 인터셉터를 생성하세요.\n\n\n\n이 명령은 기본 구현을 사용하여 로깅 인터페이스를 생성합니다. 그러므로 아래에 나와 있는 대로 수정해주세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n  HttpResponse,\n} from '@angular/common/http';\nimport { Observable, tap } from 'rxjs';\n\n@Injectable()\nexport class LoggingInterceptor implements HttpInterceptor {\n  constructor() {}\n\n  intercept(\n    request: HttpRequest\u003cany\u003e,\n    next: HttpHandler\n  ): Observable\u003cHttpEvent\u003cany\u003e\u003e {\n    console.log('Outgoing HTTP request', request);\n    return next.handle(request).pipe(\n      tap((event: HttpEvent\u003cany\u003e) =\u003e {\n        console.log('Incoming HTTP response', event);\n      })\n    );\n  }\n}\n```\n\n- 여기에서는 Angular의 HTTP 패키지에서 필요한 모듈과 클래스를 가져옵니다.\n\n- HttpInterceptor 인터페이스는 사용자 정의 인터셉터를 만들 수 있게 해주며, HttpRequest, HttpHandler 및 HttpEvent는 HTTP 요청과 응답을 처리하는 데 사용되는 클래스입니다.\n\n\n\n- 우리는 비동기 작업을 처리하는 RxJS 라이브러리에서 Observable 및 Tap을 가져와 사용합니다.\n\n- next.handle(request)를 호출하여 요청을 체인의 다음 인터셉터 또는 백엔드 서버로 전달합니다.\n\n- 그런 다음, tap 연산자와 함께 pipe 메서드를 사용하여 들어오는 응답을 가로챕니다.\n\n- tap 연산자를 사용하면 응답 자체를 수정하지 않고도 부작용(이 경우 응답을 로깅하는)을 실행할 수 있습니다.\n\n\n\n단계 2\n\n앱 모듈에 인터셉터를 제공하세요:\n\n```js\nimport { LoggingInterceptor } from './interceptors/logging.interceptor';\n\nproviders: [\n    {\n      provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true\n    }\n]\n```\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 LoggingInterceptor 클래스를 인터셉터로 제공합니다. multi: true 옵션은 인터셉터가 기존 인터셉터 배열에 추가되도록 하며 덮어쓰지 않도록 합니다.\n\n\n\nHTTP 요청을 보낼 때, 다음과 같은 요청과 응답이 로그에 기록됩니다:\n\n![HTTPInterceptorsinAngular_2](/assets/img/2024-05-12-HTTPInterceptorsinAngular_2.png)\n\n실제 시나리오에서는 필요에 따라 이 응답을 서드파티 서비스에 기록할 수 있습니다.\n\n2. 요청에 헤더 추가\n\n\n\n앵귤러에서는 인터셉터를 활용하여 HTTP 요청을 수정하고 요청 헤더에 추가적인 값들을 넣을 수 있어요.\n\n단계 1\n\n다음 명령어를 사용하여 새 헤더 인터셉터를 만들어보세요:\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HeadersInterceptor implements HttpInterceptor {\n\n  constructor() {}\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cunknown\u003e\u003e {\n    console.log(request)\n    const GUID = 'f4179b26-21ac-432c-bcd8-cb4bc6e50981'\n    const modifiedRequest = request.clone({\n      setHeaders:{\n        GUID\n      }\n    })\n    return next.handle(modifiedRequest);\n  }\n}\n```\n\n\n\n먼저 헤더 안에 설정할 GUID를 하드코딩합니다. 그래서 먼저 HTTP 요청을 복제하고 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.\n\n### 단계 2\n\n앱 모듈에 인터셉터를 제공하세요:\n\n```js\nimport { HeadersInterceptor } from './interceptors/headers.interceptor'\n\nproviders: [\n    {\n      provide: HTTP_INTERCEPTORS, useClass: HeadersInterceptor, multi: true\n    }\n  ]\n```\n\n\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 Interceptor가 기존 Interceptor 배열에 추가되도록 하는 것을 보장하며, 기존 Interceptor를 대체하지 않습니다.\n\n![HTTP Interceptors in Angular](/assets/img/2024-05-12-HTTPInterceptorsinAngular_3.png)\n\n실제 시나리오에서는 이러한 헤더 값들을 추가로 처리하는 데 활용할 수 있습니다. 예를 들어 요청을 유효성 검사하거나 다른 여러 경우에 사용할 수 있습니다.\n\n3. 에러 처리 Interceptor\n\n\n\n앵귤러에서, 에러 인터셉터는 HTTP 인터셉터로서 어플리케이션 전반에 걸쳐 HTTP 에러를 처리할 수 있게 해주는 기능입니다.\n\n서버로 HTTP 요청을 보낼 때, 404나 500과 같은 에러 상태 코드로 응답을 받을 수 있는 상황이 발생할 수 있습니다.\n\n각각의 HTTP 요청마다 이러한 에러들을 처리하는 것은 지루하고 반복적일 수 있습니다.\n\n에러 인터셉터는 에러 처리 로직을 중앙화시켜 주며, 어플리케이션 전반에 걸쳐 일관된 방법으로 에러를 관리할 수 있도록 도와줍니다.\n\n\n\n**단계 1**\n\n다음 명령을 사용하여 새로운 오류 인터셉터를 생성하세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor,\n  HttpErrorResponse\n} from '@angular/common/http';\nimport { Observable, catchError, throwError } from 'rxjs';\n\n@Injectable()\nexport class ErrorInterceptor implements HttpInterceptor {\n\n  constructor() {}\n\n  intercept(request: HttpRequest\u003cany\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cany\u003e\u003e {\n    return next.handle(request).pipe(\n      catchError((error: HttpErrorResponse) =\u003e {\n        // 여기서 오류를 처리합니다\n        console.error('오류 발생:', error);\n        // 요구에 따라 오류 throw\n        return throwError(error);\n      })\n    );\n  }\n}\n```\n\n- `intercept()` 메서드 내에서 RxJS의 `catchError` 연산자를 사용하여 HTTP 요청이나 응답 처리 중 발생하는 오류를 잡을 수 있습니다.\n\n\n\n**단계 1**\n\n· 오류를 가로채고 필요에 따라 처리하고, 오류를 선택적으로 다시 던져서 observable 체인을 계속 전파할 수 있게 합니다.\n\n**단계 2**\n\n· 앱 모듈에서 인터셉터를 제공하세요:\n\n```js\nimport { ErrorInterceptor } from './interceptors/error.interceptor';\n\nproviders: [\n  {\n    provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true\n  }\n]\n```\n\n\n\n· AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션을 사용하면 Interceptor가 기존 Interceptor 배열에 추가되며 대체되지 않습니다.\n\n4. Authentication Interceptor\n\nAngular에서는 인증 Interceptor를 사용하여 모든 외부 HTTP 요청에 인증 토큰이나 헤더를 추가할 수 있습니다. API 요청이 모두 인증된 상태인지 확인해야 할 때 유용합니다.\n\n단계 1\n\n\n\n다음 명령어를 사용하여 새로운 인증 인터셉터를 만들어보세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n//import { AuthService } from './auth.service';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  constructor(/*private authService: AuthService*/) {}\n\n  intercept(\n    req: HttpRequest\u003cany\u003e,\n    next: HttpHandler\n  ): Observable\u003cHttpEvent\u003cany\u003e\u003e {\n    const authToken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpheWRlZXAgUGF0aWwiLCJpYXQiOjE1MTYyMzkwMjJ9.yt3EOXf60R62Mef2oFpbFh2ihkP5qZ4fM8bjVnF8YhA\";//his.authService.getToken();\n\n    if (authToken) {\n      // 요청을 복제하고 토큰을 첨부합니다\n      const authReq = req.clone({\n        setHeaders: {\n          Authorization: `Bearer ${authToken}`\n        }\n      });\n\n      return next.handle(authReq);\n    }\n\n    // 토큰이 없는 경우 원본 요청을 전달합니다\n    return next.handle(req);\n  }\n}\n```\n\n여기서 우리는 먼저 헤더에 설정할 하나의 토큰을 하드코딩합니다. 따라서 첫 번째로 HTTP 요청을 복제하고 요청 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다. \n\nStep 2\n\n\n\n앱 모듈에서 인터셉터를 제공하세요:\n\n```js\nimport { AuthInterceptor } from './interceptors/auth.interceptor';\n\nproviders: [\n  {\n    provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true\n  }\n]  \n```\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 인터셉터로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 인터셉터가 기존의 인터셉터 배열에 추가되도록 하는 것을 보장합니다.\n\nHTTP 요청을 보낼 때, 아래와 같이 헤더 내에 토큰을 설정할 것입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_4.png\" /\u003e\n\n여기서 볼 수 있듯이, 필요에 따라 추가 처리에 사용할 수 있는 하나의 bearer 토큰을 설정했습니다.\n\n# GitHub URL\n\nhttps://github.com/Jaydeep-007/angular-http-interceptor-demo\n\n\n\n# 결론\n\n이 글에서는 인터셉터의 기본, 이점 및 실시간 사용 사례를 Angular 15를 사용하여 단계별 구현을 통해 설명했습니다.\n\n코딩하세요!\n\n# 간단히 말해서\n\n\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 칭찬하고 팔로우해 주세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀\n- 무료 주간 뉴스레터에 가입해주세요. 🗞️\n- 트위터, 링크드인, 유튜브, 디스코드에서도 우리를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png"},"coverImage":"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png","tag":["Tech"],"readingTime":10},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h1: \"h1\",\n    ul: \"ul\",\n    li: \"li\",\n    strong: \"strong\",\n    h2: \"h2\",\n    ol: \"ol\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    img: \"img\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"안녕하세요! 이 글에서는 Angular에서 HTTP Interceptor의 기본 개념과 몇 가지 예제에 대해 알아보고자 합니다. Angular 15를 사용하여 함께 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"안내\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Angular란 무엇인가요?\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"HTTP Interceptor란 무엇인가요?\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"Angular에서의 HTTP Interceptor\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"HTTP Interceptor의 장점\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"실용적인 구현\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"선행 요건\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"TypeScript와 Angular에 대한 기본적인 이해\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Angular CLI\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"NodeJS\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"VS Code\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Angular이란 무엇인가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Angular은 웹 애플리케이션을 구축하기 위한 인기 있는 오픈 소스 JavaScript 프레임워크입니다. Google에서 개발되었으며 현재는 Google의 Angular 팀에서 유지 보수되고 있습니다. Angular를 사용하면 개발자들은 동적인, 싱글 페이지 애플리케이션 (SPA)을 만들 수 있으며 복잡한 웹 애플리케이션을 구축하기 위한 구조화된 접근법을 제공합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"HTTP Interceptor란 무엇인가요?\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"HTTP Interceptors(인터셉터)는 웹 개발과 서버 측 프로그래밍에서  자주 사용되는 개념입니다. 이는 주로 웹 프레임워크와 라이브러리와 관련이 있습니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"이러한 인터셉터를 통해 개발자는 응용 프로그램 전체에서 HTTP 요청과 응답을 가로채고 처리할 수 있습니다.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Angular의 HTTP 인터셉터\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Angular의 HTTP 인터셉터는 HttpInterceptor 인터페이스를 구현하는 클래스입니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-HTTPInterceptorsinAngular_1.png\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"HTTP 요청 및 응답과 관련된 다양한 작업을 수행하는 데 사용할 수 있습니다. 예를 들어 헤더 추가, 오류 처리, 요청 또는 응답 데이터 수정, 로깅, 인증 등이 있습니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"HttpInterceptor는 HttpRequest 및 HttpHandler 두 매개변수를 사용하는 intercept라는 단일 메서드를 정의합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"HTTP 인터셉터의 장점\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 Angular에서 HTTP Interceptor를 사용하는 주요 이점 중 일부입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테스트 용이성 및 재사용성: Interceptor는 고립된 환경에서 쉽게 테스트할 수 있어 각 Interceptor가 올바르게 작동하는지 확인할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"크로스 커팅 관심사를 위한 중앙화된 코드: HTTP Interceptor를 사용하면 인증, 로깅, 오류 처리 또는 헤더 추가와 같은 일반 작업에 대한 논리를 중앙 위치에 정의할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"전역 응용 프로그램 수준의 수정: Interceptor는 전역적으로 작동하여 Angular 애플리케이션이 만드는 모든 HTTP 요청과 응답을 가로챕니다. 이는 각 개별 요청이나 응답을 수동으로 수정하지 않아도 여러 API 호출에 일관되게 변경 적용하거나 작업을 수행할 수 있음을 의미합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오류 처리 및 로깅: 인터셉터를 활용하여 전역적으로 오류를 처리할 수 있으며, 애플리케이션 전반에 걸친 일관된 방식으로 오류 보고 및 처리를 제공할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"캐싱 및 요청/응답 조작: HTTP 인터셉터를 활용하여 캐싱 메커니즘을 구현하면 중복 요청을 줄이고 애플리케이션 성능을 최적화할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"역할 분리: HTTP 인터셉터를 사용하면 데이터 검색 및 통신 (HTTP)과 관련된 문제를 컴포넌트 및 서비스의 비즈니스 로직과 분리할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"보안 및 인증: 인터셉터는 인증 헤더나 인증 토큰을 발신 요청에 추가하는 데 일반적으로 사용됩니다. 이를 통해 사용자의 인증 상태가 API 호출에 자동으로 포함되어 매번 헤더를 명시적으로 설정할 필요가 없습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"세 번째 두 번째 줄은 Markdown 표현식으로 바꿈:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"| Easy integration with third-party libraries: Interceptors can be used to integrate with third-party libraries or APIs seamlessly. For example, you can apply a specific format to API responses that are expected by a charting library or a data visualization tool.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"실용적인 구현\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실용적인 구현부터 시작해보겠습니다; 이를 위해 다음 명령을 사용하여 새 Angular 어플리케이션을 생성해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 우리는 Angular를 사용하여 하나씩 다른 인터셉터를 만들어 보겠습니다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"로깅 인터셉터\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Angular에서는 로깅 인터셉터를 감사 로그 목적으로 사용할 수 있습니다. 요청과 응답 개체로 다양한 들어오는 요청과 나가는 요청을 로깅하려면 로깅 인터셉터의 도움을 받을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단계 1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 명령어를 사용하여 새로운 로깅 인터셉터를 생성하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 명령은 기본 구현을 사용하여 로깅 인터페이스를 생성합니다. 그러므로 아래에 나와 있는 대로 수정해주세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Injectable\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/core'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpEvent\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpInterceptor\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpHandler\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpRequest\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpResponse\"\n        }), \",\\n} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/common/http'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Observable\"\n        }), \", tap } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'rxjs'\"\n        }), \";\\n\\n@\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Injectable\"\n        }), \"()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"LoggingInterceptor\"\n        }), \" implements \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpInterceptor\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"constructor\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {}\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"intercept\"\n        }), \"(\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"request\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpRequest\"\n        }), \"\u003cany\u003e,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"next\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpHandler\"\n        }), \"\\n  ): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Observable\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpEvent\"\n        }), \"\u003cany\u003e\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Outgoing HTTP request'\"\n        }), \", request);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" next.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"handle\"\n        }), \"(request).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"pipe\"\n        }), \"(\\n      \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"tap\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"event: HttpEvent\u003cany\u003e\"\n          }), \") =\u003e\"]\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Incoming HTTP response'\"\n        }), \", event);\\n      })\\n    );\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"여기에서는 Angular의 HTTP 패키지에서 필요한 모듈과 클래스를 가져옵니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"HttpInterceptor 인터페이스는 사용자 정의 인터셉터를 만들 수 있게 해주며, HttpRequest, HttpHandler 및 HttpEvent는 HTTP 요청과 응답을 처리하는 데 사용되는 클래스입니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"우리는 비동기 작업을 처리하는 RxJS 라이브러리에서 Observable 및 Tap을 가져와 사용합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"next.handle(request)를 호출하여 요청을 체인의 다음 인터셉터 또는 백엔드 서버로 전달합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"그런 다음, tap 연산자와 함께 pipe 메서드를 사용하여 들어오는 응답을 가로챕니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"tap 연산자를 사용하면 응답 자체를 수정하지 않고도 부작용(이 경우 응답을 로깅하는)을 실행할 수 있습니다.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단계 2\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"앱 모듈에 인터셉터를 제공하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"LoggingInterceptor\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./interceptors/logging.interceptor'\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"providers\"\n        }), \": [\\n    {\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"provide\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"HTTP_INTERCEPTORS\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"useClass\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"LoggingInterceptor\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"multi\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n    }\\n]\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 LoggingInterceptor 클래스를 인터셉터로 제공합니다. multi: true 옵션은 인터셉터가 기존 인터셉터 배열에 추가되도록 하며 덮어쓰지 않도록 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"HTTP 요청을 보낼 때, 다음과 같은 요청과 응답이 로그에 기록됩니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HTTPInterceptorsinAngular_2.png\",\n        alt: \"HTTPInterceptorsinAngular_2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실제 시나리오에서는 필요에 따라 이 응답을 서드파티 서비스에 기록할 수 있습니다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"요청에 헤더 추가\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"앵귤러에서는 인터셉터를 활용하여 HTTP 요청을 수정하고 요청 헤더에 추가적인 값들을 넣을 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단계 1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 명령어를 사용하여 새 헤더 인터셉터를 만들어보세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Injectable\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/core'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpRequest\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpHandler\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpEvent\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpInterceptor\"\n        }), \"\\n} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/common/http'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Observable\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'rxjs'\"\n        }), \";\\n\\n@\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Injectable\"\n        }), \"()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HeadersInterceptor\"\n        }), \" implements \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpInterceptor\"\n        }), \" {\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"constructor\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {}\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"intercept\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"request\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpRequest\"\n        }), \"\u003cunknown\u003e, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"next\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpHandler\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Observable\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpEvent\"\n        }), \"\u003cunknown\u003e\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(request)\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"GUID\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'f4179b26-21ac-432c-bcd8-cb4bc6e50981'\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" modifiedRequest = request.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"({\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"setHeaders\"\n        }), \":{\\n        \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"GUID\"\n        }), \"\\n      }\\n    })\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" next.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"handle\"\n        }), \"(modifiedRequest);\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저 헤더 안에 설정할 GUID를 하드코딩합니다. 그래서 먼저 HTTP 요청을 복제하고 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"단계 2\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"앱 모듈에 인터셉터를 제공하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HeadersInterceptor\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./interceptors/headers.interceptor'\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"providers\"\n        }), \": [\\n    {\\n      \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"provide\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"HTTP_INTERCEPTORS\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"useClass\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HeadersInterceptor\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"multi\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n    }\\n  ]\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 Interceptor가 기존 Interceptor 배열에 추가되도록 하는 것을 보장하며, 기존 Interceptor를 대체하지 않습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-HTTPInterceptorsinAngular_3.png\",\n        alt: \"HTTP Interceptors in Angular\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실제 시나리오에서는 이러한 헤더 값들을 추가로 처리하는 데 활용할 수 있습니다. 예를 들어 요청을 유효성 검사하거나 다른 여러 경우에 사용할 수 있습니다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"3\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"에러 처리 Interceptor\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"앵귤러에서, 에러 인터셉터는 HTTP 인터셉터로서 어플리케이션 전반에 걸쳐 HTTP 에러를 처리할 수 있게 해주는 기능입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서버로 HTTP 요청을 보낼 때, 404나 500과 같은 에러 상태 코드로 응답을 받을 수 있는 상황이 발생할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각각의 HTTP 요청마다 이러한 에러들을 처리하는 것은 지루하고 반복적일 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"에러 인터셉터는 에러 처리 로직을 중앙화시켜 주며, 어플리케이션 전반에 걸쳐 일관된 방법으로 에러를 관리할 수 있도록 도와줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"단계 1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 명령을 사용하여 새로운 오류 인터셉터를 생성하세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Injectable\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/core'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpRequest\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpHandler\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpEvent\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpInterceptor\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpErrorResponse\"\n        }), \"\\n} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/common/http'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Observable\"\n        }), \", catchError, throwError } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'rxjs'\"\n        }), \";\\n\\n@\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Injectable\"\n        }), \"()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ErrorInterceptor\"\n        }), \" implements \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpInterceptor\"\n        }), \" {\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"constructor\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {}\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"intercept\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"request\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpRequest\"\n        }), \"\u003cany\u003e, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"next\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpHandler\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Observable\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpEvent\"\n        }), \"\u003cany\u003e\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" next.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"handle\"\n        }), \"(request).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"pipe\"\n        }), \"(\\n      \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"catchError\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"error: HttpErrorResponse\"\n          }), \") =\u003e\"]\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 여기서 오류를 처리합니다\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"error\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'오류 발생:'\"\n        }), \", error);\\n        \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 요구에 따라 오류 throw\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"throwError\"\n        }), \"(error);\\n      })\\n    );\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"intercept()\"\n        }), \" 메서드 내에서 RxJS의 \", _jsx(_components.code, {\n          children: \"catchError\"\n        }), \" 연산자를 사용하여 HTTP 요청이나 응답 처리 중 발생하는 오류를 잡을 수 있습니다.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"단계 1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"· 오류를 가로채고 필요에 따라 처리하고, 오류를 선택적으로 다시 던져서 observable 체인을 계속 전파할 수 있게 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"단계 2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"· 앱 모듈에서 인터셉터를 제공하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ErrorInterceptor\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./interceptors/error.interceptor'\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"providers\"\n        }), \": [\\n  {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"provide\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"HTTP_INTERCEPTORS\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"useClass\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ErrorInterceptor\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"multi\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n  }\\n]\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"· AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션을 사용하면 Interceptor가 기존 Interceptor 배열에 추가되며 대체되지 않습니다.\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"4\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Authentication Interceptor\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Angular에서는 인증 Interceptor를 사용하여 모든 외부 HTTP 요청에 인증 토큰이나 헤더를 추가할 수 있습니다. API 요청이 모두 인증된 상태인지 확인해야 할 때 유용합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단계 1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 명령어를 사용하여 새로운 인증 인터셉터를 만들어보세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Injectable\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/core'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpEvent\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpInterceptor\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpHandler\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpRequest\"\n        }), \",\\n} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@angular/common/http'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Observable\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'rxjs'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//import { AuthService } from './auth.service';\"\n        }), \"\\n\\n@\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Injectable\"\n        }), \"()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"AuthInterceptor\"\n        }), \" implements \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpInterceptor\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"constructor\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"/*private authService: AuthService*/\"\n          })\n        }), \") {}\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"intercept\"\n        }), \"(\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"req\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpRequest\"\n        }), \"\u003cany\u003e,\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"next\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpHandler\"\n        }), \"\\n  ): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Observable\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HttpEvent\"\n        }), \"\u003cany\u003e\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" authToken = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpheWRlZXAgUGF0aWwiLCJpYXQiOjE1MTYyMzkwMjJ9.yt3EOXf60R62Mef2oFpbFh2ihkP5qZ4fM8bjVnF8YhA\\\"\"\n        }), \";\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"//his.authService.getToken();\"\n        }), \"\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (authToken) {\\n      \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 요청을 복제하고 토큰을 첨부합니다\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" authReq = req.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"({\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"setHeaders\"\n        }), \": {\\n          \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Authorization\"\n        }), \": \", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`Bearer \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${authToken}\"\n          }), \"`\"]\n        }), \"\\n        }\\n      });\\n\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" next.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"handle\"\n        }), \"(authReq);\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 토큰이 없는 경우 원본 요청을 전달합니다\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" next.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"handle\"\n        }), \"(req);\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 우리는 먼저 헤더에 설정할 하나의 토큰을 하드코딩합니다. 따라서 첫 번째로 HTTP 요청을 복제하고 요청 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Step 2\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"앱 모듈에서 인터셉터를 제공하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"AuthInterceptor\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./interceptors/auth.interceptor'\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"providers\"\n        }), \": [\\n  {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"provide\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"HTTP_INTERCEPTORS\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"useClass\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"AuthInterceptor\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"multi\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n  }\\n]  \\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 인터셉터로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 인터셉터가 기존의 인터셉터 배열에 추가되도록 하는 것을 보장합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"HTTP 요청을 보낼 때, 아래와 같이 헤더 내에 토큰을 설정할 것입니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-HTTPInterceptorsinAngular_4.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 볼 수 있듯이, 필요에 따라 추가 처리에 사용할 수 있는 하나의 bearer 토큰을 설정했습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"GitHub URL\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"https://github.com/Jaydeep-007/angular-http-interceptor-demo\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 글에서는 인터셉터의 기본, 이점 및 실시간 사용 사례를 Angular 15를 사용하여 단계별 구현을 통해 설명했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코딩하세요!\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"간단히 말해서\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"작가를 박수로 칭찬하고 팔로우해 주세요! 👏\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"무료 주간 뉴스레터에 가입해주세요. 🗞️\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"트위터, 링크드인, 유튜브, 디스코드에서도 우리를 팔로우해주세요.\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-HTTPInterceptorsinAngular"},"buildId":"K-h7XvEVBqnNx_uXMgZoe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>