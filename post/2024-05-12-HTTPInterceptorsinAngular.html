<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>앵귤러에서의 HTTP Interceptors | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-HTTPInterceptorsinAngular" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="앵귤러에서의 HTTP Interceptors | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="앵귤러에서의 HTTP Interceptors | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-HTTPInterceptorsinAngular" data-gatsby-head="true"/><meta name="twitter:title" content="앵귤러에서의 HTTP Interceptors | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 23:44" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">앵귤러에서의 HTTP Interceptors</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="앵귤러에서의 HTTP Interceptors" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-HTTPInterceptorsinAngular&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png">
<p>안녕하세요! 이 글에서는 Angular에서 HTTP Interceptor의 기본 개념과 몇 가지 예제에 대해 알아보고자 합니다. Angular 15를 사용하여 함께 살펴보겠습니다.</p>
<h1>안내</h1>
<ul>
<li>Angular란 무엇인가요?</li>
</ul>
<p><strong>HTTP Interceptor란 무엇인가요?</strong></p>
<p><strong>Angular에서의 HTTP Interceptor</strong></p>
<p><strong>HTTP Interceptor의 장점</strong></p>
<p><strong>실용적인 구현</strong></p>
<h1>선행 요건</h1>
<ul>
<li>
<p>TypeScript와 Angular에 대한 기본적인 이해</p>
</li>
<li>
<p>Angular CLI</p>
</li>
<li>
<p>NodeJS</p>
</li>
<li>
<p>VS Code</p>
</li>
</ul>
<h2>Angular이란 무엇인가요?</h2>
<p>Angular은 웹 애플리케이션을 구축하기 위한 인기 있는 오픈 소스 JavaScript 프레임워크입니다. Google에서 개발되었으며 현재는 Google의 Angular 팀에서 유지 보수되고 있습니다. Angular를 사용하면 개발자들은 동적인, 싱글 페이지 애플리케이션 (SPA)을 만들 수 있으며 복잡한 웹 애플리케이션을 구축하기 위한 구조화된 접근법을 제공합니다.</p>
<h2>HTTP Interceptor란 무엇인가요?</h2>
<ul>
<li>
<p>HTTP Interceptors(인터셉터)는 웹 개발과 서버 측 프로그래밍에서  자주 사용되는 개념입니다. 이는 주로 웹 프레임워크와 라이브러리와 관련이 있습니다.</p>
</li>
<li>
<p>이러한 인터셉터를 통해 개발자는 응용 프로그램 전체에서 HTTP 요청과 응답을 가로채고 처리할 수 있습니다.</p>
</li>
</ul>
<h2>Angular의 HTTP 인터셉터</h2>
<ul>
<li>Angular의 HTTP 인터셉터는 HttpInterceptor 인터페이스를 구현하는 클래스입니다.</li>
</ul>
<img src="/assets/img/2024-05-12-HTTPInterceptorsinAngular_1.png">
<ul>
<li>
<p>HTTP 요청 및 응답과 관련된 다양한 작업을 수행하는 데 사용할 수 있습니다. 예를 들어 헤더 추가, 오류 처리, 요청 또는 응답 데이터 수정, 로깅, 인증 등이 있습니다.</p>
</li>
<li>
<p>HttpInterceptor는 HttpRequest 및 HttpHandler 두 매개변수를 사용하는 intercept라는 단일 메서드를 정의합니다.</p>
</li>
</ul>
<h1>HTTP 인터셉터의 장점</h1>
<p>아래는 Angular에서 HTTP Interceptor를 사용하는 주요 이점 중 일부입니다:</p>
<p>테스트 용이성 및 재사용성: Interceptor는 고립된 환경에서 쉽게 테스트할 수 있어 각 Interceptor가 올바르게 작동하는지 확인할 수 있습니다.</p>
<p>크로스 커팅 관심사를 위한 중앙화된 코드: HTTP Interceptor를 사용하면 인증, 로깅, 오류 처리 또는 헤더 추가와 같은 일반 작업에 대한 논리를 중앙 위치에 정의할 수 있습니다.</p>
<p>전역 응용 프로그램 수준의 수정: Interceptor는 전역적으로 작동하여 Angular 애플리케이션이 만드는 모든 HTTP 요청과 응답을 가로챕니다. 이는 각 개별 요청이나 응답을 수동으로 수정하지 않아도 여러 API 호출에 일관되게 변경 적용하거나 작업을 수행할 수 있음을 의미합니다.</p>
<p>오류 처리 및 로깅: 인터셉터를 활용하여 전역적으로 오류를 처리할 수 있으며, 애플리케이션 전반에 걸친 일관된 방식으로 오류 보고 및 처리를 제공할 수 있습니다.</p>
<p>캐싱 및 요청/응답 조작: HTTP 인터셉터를 활용하여 캐싱 메커니즘을 구현하면 중복 요청을 줄이고 애플리케이션 성능을 최적화할 수 있습니다.</p>
<p>역할 분리: HTTP 인터셉터를 사용하면 데이터 검색 및 통신 (HTTP)과 관련된 문제를 컴포넌트 및 서비스의 비즈니스 로직과 분리할 수 있습니다.</p>
<p>보안 및 인증: 인터셉터는 인증 헤더나 인증 토큰을 발신 요청에 추가하는 데 일반적으로 사용됩니다. 이를 통해 사용자의 인증 상태가 API 호출에 자동으로 포함되어 매번 헤더를 명시적으로 설정할 필요가 없습니다.</p>
<p>세 번째 두 번째 줄은 Markdown 표현식으로 바꿈:</p>
<p>| Easy integration with third-party libraries: Interceptors can be used to integrate with third-party libraries or APIs seamlessly. For example, you can apply a specific format to API responses that are expected by a charting library or a data visualization tool.</p>
<h2>실용적인 구현</h2>
<p>실용적인 구현부터 시작해보겠습니다; 이를 위해 다음 명령을 사용하여 새 Angular 어플리케이션을 생성해야 합니다.</p>
<p>이제 우리는 Angular를 사용하여 하나씩 다른 인터셉터를 만들어 보겠습니다.</p>
<ol>
<li>로깅 인터셉터</li>
</ol>
<p>Angular에서는 로깅 인터셉터를 감사 로그 목적으로 사용할 수 있습니다. 요청과 응답 개체로 다양한 들어오는 요청과 나가는 요청을 로깅하려면 로깅 인터셉터의 도움을 받을 수 있습니다.</p>
<p>단계 1</p>
<p>다음 명령어를 사용하여 새로운 로깅 인터셉터를 생성하세요.</p>
<p>이 명령은 기본 구현을 사용하여 로깅 인터페이스를 생성합니다. 그러므로 아래에 나와 있는 대로 수정해주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">HttpEvent</span>,
  <span class="hljs-title class_">HttpInterceptor</span>,
  <span class="hljs-title class_">HttpHandler</span>,
  <span class="hljs-title class_">HttpRequest</span>,
  <span class="hljs-title class_">HttpResponse</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span>, tap } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingInterceptor</span> implements <span class="hljs-title class_">HttpInterceptor</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}

  <span class="hljs-title function_">intercept</span>(
    <span class="hljs-attr">request</span>: <span class="hljs-title class_">HttpRequest</span>&#x3C;any>,
    <span class="hljs-attr">next</span>: <span class="hljs-title class_">HttpHandler</span>
  ): <span class="hljs-title class_">Observable</span>&#x3C;<span class="hljs-title class_">HttpEvent</span>&#x3C;any>> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Outgoing HTTP request'</span>, request);
    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>(request).<span class="hljs-title function_">pipe</span>(
      <span class="hljs-title function_">tap</span>(<span class="hljs-function">(<span class="hljs-params">event: HttpEvent&#x3C;any></span>) =></span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Incoming HTTP response'</span>, event);
      })
    );
  }
}
</code></pre>
<ul>
<li>
<p>여기에서는 Angular의 HTTP 패키지에서 필요한 모듈과 클래스를 가져옵니다.</p>
</li>
<li>
<p>HttpInterceptor 인터페이스는 사용자 정의 인터셉터를 만들 수 있게 해주며, HttpRequest, HttpHandler 및 HttpEvent는 HTTP 요청과 응답을 처리하는 데 사용되는 클래스입니다.</p>
</li>
<li>
<p>우리는 비동기 작업을 처리하는 RxJS 라이브러리에서 Observable 및 Tap을 가져와 사용합니다.</p>
</li>
<li>
<p>next.handle(request)를 호출하여 요청을 체인의 다음 인터셉터 또는 백엔드 서버로 전달합니다.</p>
</li>
<li>
<p>그런 다음, tap 연산자와 함께 pipe 메서드를 사용하여 들어오는 응답을 가로챕니다.</p>
</li>
<li>
<p>tap 연산자를 사용하면 응답 자체를 수정하지 않고도 부작용(이 경우 응답을 로깅하는)을 실행할 수 있습니다.</p>
</li>
</ul>
<p>단계 2</p>
<p>앱 모듈에 인터셉터를 제공하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">LoggingInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./interceptors/logging.interceptor'</span>;

<span class="hljs-attr">providers</span>: [
    {
      <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">HTTP_INTERCEPTORS</span>, <span class="hljs-attr">useClass</span>: <span class="hljs-title class_">LoggingInterceptor</span>, <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>
    }
]
</code></pre>
<p>AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 LoggingInterceptor 클래스를 인터셉터로 제공합니다. multi: true 옵션은 인터셉터가 기존 인터셉터 배열에 추가되도록 하며 덮어쓰지 않도록 합니다.</p>
<p>HTTP 요청을 보낼 때, 다음과 같은 요청과 응답이 로그에 기록됩니다:</p>
<p><img src="/assets/img/2024-05-12-HTTPInterceptorsinAngular_2.png" alt="HTTPInterceptorsinAngular_2"></p>
<p>실제 시나리오에서는 필요에 따라 이 응답을 서드파티 서비스에 기록할 수 있습니다.</p>
<ol start="2">
<li>요청에 헤더 추가</li>
</ol>
<p>앵귤러에서는 인터셉터를 활용하여 HTTP 요청을 수정하고 요청 헤더에 추가적인 값들을 넣을 수 있어요.</p>
<p>단계 1</p>
<p>다음 명령어를 사용하여 새 헤더 인터셉터를 만들어보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">HttpRequest</span>,
  <span class="hljs-title class_">HttpHandler</span>,
  <span class="hljs-title class_">HttpEvent</span>,
  <span class="hljs-title class_">HttpInterceptor</span>
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeadersInterceptor</span> implements <span class="hljs-title class_">HttpInterceptor</span> {

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}

  <span class="hljs-title function_">intercept</span>(<span class="hljs-attr">request</span>: <span class="hljs-title class_">HttpRequest</span>&#x3C;unknown>, <span class="hljs-attr">next</span>: <span class="hljs-title class_">HttpHandler</span>): <span class="hljs-title class_">Observable</span>&#x3C;<span class="hljs-title class_">HttpEvent</span>&#x3C;unknown>> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(request)
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">GUID</span> = <span class="hljs-string">'f4179b26-21ac-432c-bcd8-cb4bc6e50981'</span>
    <span class="hljs-keyword">const</span> modifiedRequest = request.<span class="hljs-title function_">clone</span>({
      <span class="hljs-attr">setHeaders</span>:{
        <span class="hljs-variable constant_">GUID</span>
      }
    })
    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>(modifiedRequest);
  }
}
</code></pre>
<p>먼저 헤더 안에 설정할 GUID를 하드코딩합니다. 그래서 먼저 HTTP 요청을 복제하고 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.</p>
<h3>단계 2</h3>
<p>앱 모듈에 인터셉터를 제공하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">HeadersInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./interceptors/headers.interceptor'</span>

<span class="hljs-attr">providers</span>: [
    {
      <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">HTTP_INTERCEPTORS</span>, <span class="hljs-attr">useClass</span>: <span class="hljs-title class_">HeadersInterceptor</span>, <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>
    }
  ]
</code></pre>
<p>AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 Interceptor가 기존 Interceptor 배열에 추가되도록 하는 것을 보장하며, 기존 Interceptor를 대체하지 않습니다.</p>
<p><img src="/assets/img/2024-05-12-HTTPInterceptorsinAngular_3.png" alt="HTTP Interceptors in Angular"></p>
<p>실제 시나리오에서는 이러한 헤더 값들을 추가로 처리하는 데 활용할 수 있습니다. 예를 들어 요청을 유효성 검사하거나 다른 여러 경우에 사용할 수 있습니다.</p>
<ol start="3">
<li>에러 처리 Interceptor</li>
</ol>
<p>앵귤러에서, 에러 인터셉터는 HTTP 인터셉터로서 어플리케이션 전반에 걸쳐 HTTP 에러를 처리할 수 있게 해주는 기능입니다.</p>
<p>서버로 HTTP 요청을 보낼 때, 404나 500과 같은 에러 상태 코드로 응답을 받을 수 있는 상황이 발생할 수 있습니다.</p>
<p>각각의 HTTP 요청마다 이러한 에러들을 처리하는 것은 지루하고 반복적일 수 있습니다.</p>
<p>에러 인터셉터는 에러 처리 로직을 중앙화시켜 주며, 어플리케이션 전반에 걸쳐 일관된 방법으로 에러를 관리할 수 있도록 도와줍니다.</p>
<p><strong>단계 1</strong></p>
<p>다음 명령을 사용하여 새로운 오류 인터셉터를 생성하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">HttpRequest</span>,
  <span class="hljs-title class_">HttpHandler</span>,
  <span class="hljs-title class_">HttpEvent</span>,
  <span class="hljs-title class_">HttpInterceptor</span>,
  <span class="hljs-title class_">HttpErrorResponse</span>
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span>, catchError, throwError } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorInterceptor</span> implements <span class="hljs-title class_">HttpInterceptor</span> {

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}

  <span class="hljs-title function_">intercept</span>(<span class="hljs-attr">request</span>: <span class="hljs-title class_">HttpRequest</span>&#x3C;any>, <span class="hljs-attr">next</span>: <span class="hljs-title class_">HttpHandler</span>): <span class="hljs-title class_">Observable</span>&#x3C;<span class="hljs-title class_">HttpEvent</span>&#x3C;any>> {
    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>(request).<span class="hljs-title function_">pipe</span>(
      <span class="hljs-title function_">catchError</span>(<span class="hljs-function">(<span class="hljs-params">error: HttpErrorResponse</span>) =></span> {
        <span class="hljs-comment">// 여기서 오류를 처리합니다</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'오류 발생:'</span>, error);
        <span class="hljs-comment">// 요구에 따라 오류 throw</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">throwError</span>(error);
      })
    );
  }
}
</code></pre>
<ul>
<li><code>intercept()</code> 메서드 내에서 RxJS의 <code>catchError</code> 연산자를 사용하여 HTTP 요청이나 응답 처리 중 발생하는 오류를 잡을 수 있습니다.</li>
</ul>
<p><strong>단계 1</strong></p>
<p>· 오류를 가로채고 필요에 따라 처리하고, 오류를 선택적으로 다시 던져서 observable 체인을 계속 전파할 수 있게 합니다.</p>
<p><strong>단계 2</strong></p>
<p>· 앱 모듈에서 인터셉터를 제공하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ErrorInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./interceptors/error.interceptor'</span>;

<span class="hljs-attr">providers</span>: [
  {
    <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">HTTP_INTERCEPTORS</span>, <span class="hljs-attr">useClass</span>: <span class="hljs-title class_">ErrorInterceptor</span>, <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>
  }
]
</code></pre>
<p>· AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션을 사용하면 Interceptor가 기존 Interceptor 배열에 추가되며 대체되지 않습니다.</p>
<ol start="4">
<li>Authentication Interceptor</li>
</ol>
<p>Angular에서는 인증 Interceptor를 사용하여 모든 외부 HTTP 요청에 인증 토큰이나 헤더를 추가할 수 있습니다. API 요청이 모두 인증된 상태인지 확인해야 할 때 유용합니다.</p>
<p>단계 1</p>
<p>다음 명령어를 사용하여 새로운 인증 인터셉터를 만들어보세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> {
  <span class="hljs-title class_">HttpEvent</span>,
  <span class="hljs-title class_">HttpInterceptor</span>,
  <span class="hljs-title class_">HttpHandler</span>,
  <span class="hljs-title class_">HttpRequest</span>,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-comment">//import { AuthService } from './auth.service';</span>

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthInterceptor</span> implements <span class="hljs-title class_">HttpInterceptor</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-comment">/*private authService: AuthService*/</span></span>) {}

  <span class="hljs-title function_">intercept</span>(
    <span class="hljs-attr">req</span>: <span class="hljs-title class_">HttpRequest</span>&#x3C;any>,
    <span class="hljs-attr">next</span>: <span class="hljs-title class_">HttpHandler</span>
  ): <span class="hljs-title class_">Observable</span>&#x3C;<span class="hljs-title class_">HttpEvent</span>&#x3C;any>> {
    <span class="hljs-keyword">const</span> authToken = <span class="hljs-string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpheWRlZXAgUGF0aWwiLCJpYXQiOjE1MTYyMzkwMjJ9.yt3EOXf60R62Mef2oFpbFh2ihkP5qZ4fM8bjVnF8YhA"</span>;<span class="hljs-comment">//his.authService.getToken();</span>

    <span class="hljs-keyword">if</span> (authToken) {
      <span class="hljs-comment">// 요청을 복제하고 토큰을 첨부합니다</span>
      <span class="hljs-keyword">const</span> authReq = req.<span class="hljs-title function_">clone</span>({
        <span class="hljs-attr">setHeaders</span>: {
          <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${authToken}</span>`</span>
        }
      });

      <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>(authReq);
    }

    <span class="hljs-comment">// 토큰이 없는 경우 원본 요청을 전달합니다</span>
    <span class="hljs-keyword">return</span> next.<span class="hljs-title function_">handle</span>(req);
  }
}
</code></pre>
<p>여기서 우리는 먼저 헤더에 설정할 하나의 토큰을 하드코딩합니다. 따라서 첫 번째로 HTTP 요청을 복제하고 요청 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.</p>
<p>Step 2</p>
<p>앱 모듈에서 인터셉터를 제공하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">AuthInterceptor</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./interceptors/auth.interceptor'</span>;

<span class="hljs-attr">providers</span>: [
  {
    <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">HTTP_INTERCEPTORS</span>, <span class="hljs-attr">useClass</span>: <span class="hljs-title class_">AuthInterceptor</span>, <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>
  }
]  
</code></pre>
<p>AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 인터셉터로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 인터셉터가 기존의 인터셉터 배열에 추가되도록 하는 것을 보장합니다.</p>
<p>HTTP 요청을 보낼 때, 아래와 같이 헤더 내에 토큰을 설정할 것입니다.</p>
<img src="/assets/img/2024-05-12-HTTPInterceptorsinAngular_4.png">
<p>여기서 볼 수 있듯이, 필요에 따라 추가 처리에 사용할 수 있는 하나의 bearer 토큰을 설정했습니다.</p>
<h1>GitHub URL</h1>
<p><a href="https://github.com/Jaydeep-007/angular-http-interceptor-demo" rel="nofollow" target="_blank">https://github.com/Jaydeep-007/angular-http-interceptor-demo</a></p>
<h1>결론</h1>
<p>이 글에서는 인터셉터의 기본, 이점 및 실시간 사용 사례를 Angular 15를 사용하여 단계별 구현을 통해 설명했습니다.</p>
<p>코딩하세요!</p>
<h1>간단히 말해서</h1>
<p>우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:</p>
<ul>
<li>작가를 박수로 칭찬하고 팔로우해 주세요! 👏</li>
<li>PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀</li>
<li>무료 주간 뉴스레터에 가입해주세요. 🗞️</li>
<li>트위터, 링크드인, 유튜브, 디스코드에서도 우리를 팔로우해주세요.</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"앵귤러에서의 HTTP Interceptors","description":"","date":"2024-05-12 23:44","slug":"2024-05-12-HTTPInterceptorsinAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png\" /\u003e\n\n안녕하세요! 이 글에서는 Angular에서 HTTP Interceptor의 기본 개념과 몇 가지 예제에 대해 알아보고자 합니다. Angular 15를 사용하여 함께 살펴보겠습니다.\n\n# 안내\n\n- Angular란 무엇인가요?\n\n\n\n**HTTP Interceptor란 무엇인가요?**\n\n**Angular에서의 HTTP Interceptor**\n\n**HTTP Interceptor의 장점**\n\n**실용적인 구현**\n\n\n\n# 선행 요건\n\n- TypeScript와 Angular에 대한 기본적인 이해\n- Angular CLI\n- NodeJS\n\n\n\n- VS Code\n\n## Angular이란 무엇인가요?\n\nAngular은 웹 애플리케이션을 구축하기 위한 인기 있는 오픈 소스 JavaScript 프레임워크입니다. Google에서 개발되었으며 현재는 Google의 Angular 팀에서 유지 보수되고 있습니다. Angular를 사용하면 개발자들은 동적인, 싱글 페이지 애플리케이션 (SPA)을 만들 수 있으며 복잡한 웹 애플리케이션을 구축하기 위한 구조화된 접근법을 제공합니다.\n\n## HTTP Interceptor란 무엇인가요?\n\n\n\n- HTTP Interceptors(인터셉터)는 웹 개발과 서버 측 프로그래밍에서  자주 사용되는 개념입니다. 이는 주로 웹 프레임워크와 라이브러리와 관련이 있습니다.\n\n- 이러한 인터셉터를 통해 개발자는 응용 프로그램 전체에서 HTTP 요청과 응답을 가로채고 처리할 수 있습니다.\n\n## Angular의 HTTP 인터셉터\n\n- Angular의 HTTP 인터셉터는 HttpInterceptor 인터페이스를 구현하는 클래스입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_1.png\" /\u003e\n\n- HTTP 요청 및 응답과 관련된 다양한 작업을 수행하는 데 사용할 수 있습니다. 예를 들어 헤더 추가, 오류 처리, 요청 또는 응답 데이터 수정, 로깅, 인증 등이 있습니다.\n\n- HttpInterceptor는 HttpRequest 및 HttpHandler 두 매개변수를 사용하는 intercept라는 단일 메서드를 정의합니다.\n\n# HTTP 인터셉터의 장점\n\n\n\n아래는 Angular에서 HTTP Interceptor를 사용하는 주요 이점 중 일부입니다:\n\n테스트 용이성 및 재사용성: Interceptor는 고립된 환경에서 쉽게 테스트할 수 있어 각 Interceptor가 올바르게 작동하는지 확인할 수 있습니다.\n\n크로스 커팅 관심사를 위한 중앙화된 코드: HTTP Interceptor를 사용하면 인증, 로깅, 오류 처리 또는 헤더 추가와 같은 일반 작업에 대한 논리를 중앙 위치에 정의할 수 있습니다.\n\n전역 응용 프로그램 수준의 수정: Interceptor는 전역적으로 작동하여 Angular 애플리케이션이 만드는 모든 HTTP 요청과 응답을 가로챕니다. 이는 각 개별 요청이나 응답을 수동으로 수정하지 않아도 여러 API 호출에 일관되게 변경 적용하거나 작업을 수행할 수 있음을 의미합니다.\n\n\n\n오류 처리 및 로깅: 인터셉터를 활용하여 전역적으로 오류를 처리할 수 있으며, 애플리케이션 전반에 걸친 일관된 방식으로 오류 보고 및 처리를 제공할 수 있습니다.\n\n캐싱 및 요청/응답 조작: HTTP 인터셉터를 활용하여 캐싱 메커니즘을 구현하면 중복 요청을 줄이고 애플리케이션 성능을 최적화할 수 있습니다.\n\n역할 분리: HTTP 인터셉터를 사용하면 데이터 검색 및 통신 (HTTP)과 관련된 문제를 컴포넌트 및 서비스의 비즈니스 로직과 분리할 수 있습니다.\n\n보안 및 인증: 인터셉터는 인증 헤더나 인증 토큰을 발신 요청에 추가하는 데 일반적으로 사용됩니다. 이를 통해 사용자의 인증 상태가 API 호출에 자동으로 포함되어 매번 헤더를 명시적으로 설정할 필요가 없습니다.\n\n\n\n세 번째 두 번째 줄은 Markdown 표현식으로 바꿈:\n\n| Easy integration with third-party libraries: Interceptors can be used to integrate with third-party libraries or APIs seamlessly. For example, you can apply a specific format to API responses that are expected by a charting library or a data visualization tool. \n\n## 실용적인 구현\n\n실용적인 구현부터 시작해보겠습니다; 이를 위해 다음 명령을 사용하여 새 Angular 어플리케이션을 생성해야 합니다.\n\n이제 우리는 Angular를 사용하여 하나씩 다른 인터셉터를 만들어 보겠습니다.\n\n\n\n1. 로깅 인터셉터\n\nAngular에서는 로깅 인터셉터를 감사 로그 목적으로 사용할 수 있습니다. 요청과 응답 개체로 다양한 들어오는 요청과 나가는 요청을 로깅하려면 로깅 인터셉터의 도움을 받을 수 있습니다.\n\n단계 1\n\n다음 명령어를 사용하여 새로운 로깅 인터셉터를 생성하세요.\n\n\n\n이 명령은 기본 구현을 사용하여 로깅 인터페이스를 생성합니다. 그러므로 아래에 나와 있는 대로 수정해주세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n  HttpResponse,\n} from '@angular/common/http';\nimport { Observable, tap } from 'rxjs';\n\n@Injectable()\nexport class LoggingInterceptor implements HttpInterceptor {\n  constructor() {}\n\n  intercept(\n    request: HttpRequest\u003cany\u003e,\n    next: HttpHandler\n  ): Observable\u003cHttpEvent\u003cany\u003e\u003e {\n    console.log('Outgoing HTTP request', request);\n    return next.handle(request).pipe(\n      tap((event: HttpEvent\u003cany\u003e) =\u003e {\n        console.log('Incoming HTTP response', event);\n      })\n    );\n  }\n}\n```\n\n- 여기에서는 Angular의 HTTP 패키지에서 필요한 모듈과 클래스를 가져옵니다.\n\n- HttpInterceptor 인터페이스는 사용자 정의 인터셉터를 만들 수 있게 해주며, HttpRequest, HttpHandler 및 HttpEvent는 HTTP 요청과 응답을 처리하는 데 사용되는 클래스입니다.\n\n\n\n- 우리는 비동기 작업을 처리하는 RxJS 라이브러리에서 Observable 및 Tap을 가져와 사용합니다.\n\n- next.handle(request)를 호출하여 요청을 체인의 다음 인터셉터 또는 백엔드 서버로 전달합니다.\n\n- 그런 다음, tap 연산자와 함께 pipe 메서드를 사용하여 들어오는 응답을 가로챕니다.\n\n- tap 연산자를 사용하면 응답 자체를 수정하지 않고도 부작용(이 경우 응답을 로깅하는)을 실행할 수 있습니다.\n\n\n\n단계 2\n\n앱 모듈에 인터셉터를 제공하세요:\n\n```js\nimport { LoggingInterceptor } from './interceptors/logging.interceptor';\n\nproviders: [\n    {\n      provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true\n    }\n]\n```\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 LoggingInterceptor 클래스를 인터셉터로 제공합니다. multi: true 옵션은 인터셉터가 기존 인터셉터 배열에 추가되도록 하며 덮어쓰지 않도록 합니다.\n\n\n\nHTTP 요청을 보낼 때, 다음과 같은 요청과 응답이 로그에 기록됩니다:\n\n![HTTPInterceptorsinAngular_2](/assets/img/2024-05-12-HTTPInterceptorsinAngular_2.png)\n\n실제 시나리오에서는 필요에 따라 이 응답을 서드파티 서비스에 기록할 수 있습니다.\n\n2. 요청에 헤더 추가\n\n\n\n앵귤러에서는 인터셉터를 활용하여 HTTP 요청을 수정하고 요청 헤더에 추가적인 값들을 넣을 수 있어요.\n\n단계 1\n\n다음 명령어를 사용하여 새 헤더 인터셉터를 만들어보세요:\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable()\nexport class HeadersInterceptor implements HttpInterceptor {\n\n  constructor() {}\n\n  intercept(request: HttpRequest\u003cunknown\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cunknown\u003e\u003e {\n    console.log(request)\n    const GUID = 'f4179b26-21ac-432c-bcd8-cb4bc6e50981'\n    const modifiedRequest = request.clone({\n      setHeaders:{\n        GUID\n      }\n    })\n    return next.handle(modifiedRequest);\n  }\n}\n```\n\n\n\n먼저 헤더 안에 설정할 GUID를 하드코딩합니다. 그래서 먼저 HTTP 요청을 복제하고 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.\n\n### 단계 2\n\n앱 모듈에 인터셉터를 제공하세요:\n\n```js\nimport { HeadersInterceptor } from './interceptors/headers.interceptor'\n\nproviders: [\n    {\n      provide: HTTP_INTERCEPTORS, useClass: HeadersInterceptor, multi: true\n    }\n  ]\n```\n\n\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 Interceptor가 기존 Interceptor 배열에 추가되도록 하는 것을 보장하며, 기존 Interceptor를 대체하지 않습니다.\n\n![HTTP Interceptors in Angular](/assets/img/2024-05-12-HTTPInterceptorsinAngular_3.png)\n\n실제 시나리오에서는 이러한 헤더 값들을 추가로 처리하는 데 활용할 수 있습니다. 예를 들어 요청을 유효성 검사하거나 다른 여러 경우에 사용할 수 있습니다.\n\n3. 에러 처리 Interceptor\n\n\n\n앵귤러에서, 에러 인터셉터는 HTTP 인터셉터로서 어플리케이션 전반에 걸쳐 HTTP 에러를 처리할 수 있게 해주는 기능입니다.\n\n서버로 HTTP 요청을 보낼 때, 404나 500과 같은 에러 상태 코드로 응답을 받을 수 있는 상황이 발생할 수 있습니다.\n\n각각의 HTTP 요청마다 이러한 에러들을 처리하는 것은 지루하고 반복적일 수 있습니다.\n\n에러 인터셉터는 에러 처리 로직을 중앙화시켜 주며, 어플리케이션 전반에 걸쳐 일관된 방법으로 에러를 관리할 수 있도록 도와줍니다.\n\n\n\n**단계 1**\n\n다음 명령을 사용하여 새로운 오류 인터셉터를 생성하세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor,\n  HttpErrorResponse\n} from '@angular/common/http';\nimport { Observable, catchError, throwError } from 'rxjs';\n\n@Injectable()\nexport class ErrorInterceptor implements HttpInterceptor {\n\n  constructor() {}\n\n  intercept(request: HttpRequest\u003cany\u003e, next: HttpHandler): Observable\u003cHttpEvent\u003cany\u003e\u003e {\n    return next.handle(request).pipe(\n      catchError((error: HttpErrorResponse) =\u003e {\n        // 여기서 오류를 처리합니다\n        console.error('오류 발생:', error);\n        // 요구에 따라 오류 throw\n        return throwError(error);\n      })\n    );\n  }\n}\n```\n\n- `intercept()` 메서드 내에서 RxJS의 `catchError` 연산자를 사용하여 HTTP 요청이나 응답 처리 중 발생하는 오류를 잡을 수 있습니다.\n\n\n\n**단계 1**\n\n· 오류를 가로채고 필요에 따라 처리하고, 오류를 선택적으로 다시 던져서 observable 체인을 계속 전파할 수 있게 합니다.\n\n**단계 2**\n\n· 앱 모듈에서 인터셉터를 제공하세요:\n\n```js\nimport { ErrorInterceptor } from './interceptors/error.interceptor';\n\nproviders: [\n  {\n    provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true\n  }\n]\n```\n\n\n\n· AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션을 사용하면 Interceptor가 기존 Interceptor 배열에 추가되며 대체되지 않습니다.\n\n4. Authentication Interceptor\n\nAngular에서는 인증 Interceptor를 사용하여 모든 외부 HTTP 요청에 인증 토큰이나 헤더를 추가할 수 있습니다. API 요청이 모두 인증된 상태인지 확인해야 할 때 유용합니다.\n\n단계 1\n\n\n\n다음 명령어를 사용하여 새로운 인증 인터셉터를 만들어보세요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n} from '@angular/common/http';\nimport { Observable } from 'rxjs';\n//import { AuthService } from './auth.service';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  constructor(/*private authService: AuthService*/) {}\n\n  intercept(\n    req: HttpRequest\u003cany\u003e,\n    next: HttpHandler\n  ): Observable\u003cHttpEvent\u003cany\u003e\u003e {\n    const authToken = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpheWRlZXAgUGF0aWwiLCJpYXQiOjE1MTYyMzkwMjJ9.yt3EOXf60R62Mef2oFpbFh2ihkP5qZ4fM8bjVnF8YhA\";//his.authService.getToken();\n\n    if (authToken) {\n      // 요청을 복제하고 토큰을 첨부합니다\n      const authReq = req.clone({\n        setHeaders: {\n          Authorization: `Bearer ${authToken}`\n        }\n      });\n\n      return next.handle(authReq);\n    }\n\n    // 토큰이 없는 경우 원본 요청을 전달합니다\n    return next.handle(req);\n  }\n}\n```\n\n여기서 우리는 먼저 헤더에 설정할 하나의 토큰을 하드코딩합니다. 따라서 첫 번째로 HTTP 요청을 복제하고 요청 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다. \n\nStep 2\n\n\n\n앱 모듈에서 인터셉터를 제공하세요:\n\n```js\nimport { AuthInterceptor } from './interceptors/auth.interceptor';\n\nproviders: [\n  {\n    provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true\n  }\n]  \n```\n\nAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 인터셉터로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 인터셉터가 기존의 인터셉터 배열에 추가되도록 하는 것을 보장합니다.\n\nHTTP 요청을 보낼 때, 아래와 같이 헤더 내에 토큰을 설정할 것입니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_4.png\" /\u003e\n\n여기서 볼 수 있듯이, 필요에 따라 추가 처리에 사용할 수 있는 하나의 bearer 토큰을 설정했습니다.\n\n# GitHub URL\n\nhttps://github.com/Jaydeep-007/angular-http-interceptor-demo\n\n\n\n# 결론\n\n이 글에서는 인터셉터의 기본, 이점 및 실시간 사용 사례를 Angular 15를 사용하여 단계별 구현을 통해 설명했습니다.\n\n코딩하세요!\n\n# 간단히 말해서\n\n\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 칭찬하고 팔로우해 주세요! 👏\n- PlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀\n- 무료 주간 뉴스레터에 가입해주세요. 🗞️\n- 트위터, 링크드인, 유튜브, 디스코드에서도 우리를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png"},"coverImage":"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_0.png\"\u003e\n\u003cp\u003e안녕하세요! 이 글에서는 Angular에서 HTTP Interceptor의 기본 개념과 몇 가지 예제에 대해 알아보고자 합니다. Angular 15를 사용하여 함께 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003e안내\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eAngular란 무엇인가요?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eHTTP Interceptor란 무엇인가요?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAngular에서의 HTTP Interceptor\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHTTP Interceptor의 장점\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e실용적인 구현\u003c/strong\u003e\u003c/p\u003e\n\u003ch1\u003e선행 요건\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eTypeScript와 Angular에 대한 기본적인 이해\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAngular CLI\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNodeJS\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eVS Code\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eAngular이란 무엇인가요?\u003c/h2\u003e\n\u003cp\u003eAngular은 웹 애플리케이션을 구축하기 위한 인기 있는 오픈 소스 JavaScript 프레임워크입니다. Google에서 개발되었으며 현재는 Google의 Angular 팀에서 유지 보수되고 있습니다. Angular를 사용하면 개발자들은 동적인, 싱글 페이지 애플리케이션 (SPA)을 만들 수 있으며 복잡한 웹 애플리케이션을 구축하기 위한 구조화된 접근법을 제공합니다.\u003c/p\u003e\n\u003ch2\u003eHTTP Interceptor란 무엇인가요?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eHTTP Interceptors(인터셉터)는 웹 개발과 서버 측 프로그래밍에서  자주 사용되는 개념입니다. 이는 주로 웹 프레임워크와 라이브러리와 관련이 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e이러한 인터셉터를 통해 개발자는 응용 프로그램 전체에서 HTTP 요청과 응답을 가로채고 처리할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eAngular의 HTTP 인터셉터\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eAngular의 HTTP 인터셉터는 HttpInterceptor 인터페이스를 구현하는 클래스입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_1.png\"\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eHTTP 요청 및 응답과 관련된 다양한 작업을 수행하는 데 사용할 수 있습니다. 예를 들어 헤더 추가, 오류 처리, 요청 또는 응답 데이터 수정, 로깅, 인증 등이 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHttpInterceptor는 HttpRequest 및 HttpHandler 두 매개변수를 사용하는 intercept라는 단일 메서드를 정의합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eHTTP 인터셉터의 장점\u003c/h1\u003e\n\u003cp\u003e아래는 Angular에서 HTTP Interceptor를 사용하는 주요 이점 중 일부입니다:\u003c/p\u003e\n\u003cp\u003e테스트 용이성 및 재사용성: Interceptor는 고립된 환경에서 쉽게 테스트할 수 있어 각 Interceptor가 올바르게 작동하는지 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e크로스 커팅 관심사를 위한 중앙화된 코드: HTTP Interceptor를 사용하면 인증, 로깅, 오류 처리 또는 헤더 추가와 같은 일반 작업에 대한 논리를 중앙 위치에 정의할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e전역 응용 프로그램 수준의 수정: Interceptor는 전역적으로 작동하여 Angular 애플리케이션이 만드는 모든 HTTP 요청과 응답을 가로챕니다. 이는 각 개별 요청이나 응답을 수동으로 수정하지 않아도 여러 API 호출에 일관되게 변경 적용하거나 작업을 수행할 수 있음을 의미합니다.\u003c/p\u003e\n\u003cp\u003e오류 처리 및 로깅: 인터셉터를 활용하여 전역적으로 오류를 처리할 수 있으며, 애플리케이션 전반에 걸친 일관된 방식으로 오류 보고 및 처리를 제공할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e캐싱 및 요청/응답 조작: HTTP 인터셉터를 활용하여 캐싱 메커니즘을 구현하면 중복 요청을 줄이고 애플리케이션 성능을 최적화할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e역할 분리: HTTP 인터셉터를 사용하면 데이터 검색 및 통신 (HTTP)과 관련된 문제를 컴포넌트 및 서비스의 비즈니스 로직과 분리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e보안 및 인증: 인터셉터는 인증 헤더나 인증 토큰을 발신 요청에 추가하는 데 일반적으로 사용됩니다. 이를 통해 사용자의 인증 상태가 API 호출에 자동으로 포함되어 매번 헤더를 명시적으로 설정할 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003e세 번째 두 번째 줄은 Markdown 표현식으로 바꿈:\u003c/p\u003e\n\u003cp\u003e| Easy integration with third-party libraries: Interceptors can be used to integrate with third-party libraries or APIs seamlessly. For example, you can apply a specific format to API responses that are expected by a charting library or a data visualization tool.\u003c/p\u003e\n\u003ch2\u003e실용적인 구현\u003c/h2\u003e\n\u003cp\u003e실용적인 구현부터 시작해보겠습니다; 이를 위해 다음 명령을 사용하여 새 Angular 어플리케이션을 생성해야 합니다.\u003c/p\u003e\n\u003cp\u003e이제 우리는 Angular를 사용하여 하나씩 다른 인터셉터를 만들어 보겠습니다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e로깅 인터셉터\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAngular에서는 로깅 인터셉터를 감사 로그 목적으로 사용할 수 있습니다. 요청과 응답 개체로 다양한 들어오는 요청과 나가는 요청을 로깅하려면 로깅 인터셉터의 도움을 받을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e단계 1\u003c/p\u003e\n\u003cp\u003e다음 명령어를 사용하여 새로운 로깅 인터셉터를 생성하세요.\u003c/p\u003e\n\u003cp\u003e이 명령은 기본 구현을 사용하여 로깅 인터페이스를 생성합니다. 그러므로 아래에 나와 있는 대로 수정해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eHttpEvent\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpInterceptor\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpHandler\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpRequest\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpResponse\u003c/span\u003e,\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/common/http'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e, tap } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLoggingInterceptor\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eHttpInterceptor\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {}\n\n  \u003cspan class=\"hljs-title function_\"\u003eintercept\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003erequest\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHttpRequest\u003c/span\u003e\u0026#x3C;any\u003e,\n    \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHttpHandler\u003c/span\u003e\n  ): \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHttpEvent\u003c/span\u003e\u0026#x3C;any\u003e\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Outgoing HTTP request'\u003c/span\u003e, request);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e next.\u003cspan class=\"hljs-title function_\"\u003ehandle\u003c/span\u003e(request).\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\n      \u003cspan class=\"hljs-title function_\"\u003etap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent: HttpEvent\u0026#x3C;any\u003e\u003c/span\u003e) =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Incoming HTTP response'\u003c/span\u003e, event);\n      })\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e여기에서는 Angular의 HTTP 패키지에서 필요한 모듈과 클래스를 가져옵니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHttpInterceptor 인터페이스는 사용자 정의 인터셉터를 만들 수 있게 해주며, HttpRequest, HttpHandler 및 HttpEvent는 HTTP 요청과 응답을 처리하는 데 사용되는 클래스입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e우리는 비동기 작업을 처리하는 RxJS 라이브러리에서 Observable 및 Tap을 가져와 사용합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003enext.handle(request)를 호출하여 요청을 체인의 다음 인터셉터 또는 백엔드 서버로 전달합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e그런 다음, tap 연산자와 함께 pipe 메서드를 사용하여 들어오는 응답을 가로챕니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003etap 연산자를 사용하면 응답 자체를 수정하지 않고도 부작용(이 경우 응답을 로깅하는)을 실행할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단계 2\u003c/p\u003e\n\u003cp\u003e앱 모듈에 인터셉터를 제공하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eLoggingInterceptor\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./interceptors/logging.interceptor'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-attr\"\u003eproviders\u003c/span\u003e: [\n    {\n      \u003cspan class=\"hljs-attr\"\u003eprovide\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eHTTP_INTERCEPTORS\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003euseClass\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eLoggingInterceptor\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emulti\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n    }\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 LoggingInterceptor 클래스를 인터셉터로 제공합니다. multi: true 옵션은 인터셉터가 기존 인터셉터 배열에 추가되도록 하며 덮어쓰지 않도록 합니다.\u003c/p\u003e\n\u003cp\u003eHTTP 요청을 보낼 때, 다음과 같은 요청과 응답이 로그에 기록됩니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_2.png\" alt=\"HTTPInterceptorsinAngular_2\"\u003e\u003c/p\u003e\n\u003cp\u003e실제 시나리오에서는 필요에 따라 이 응답을 서드파티 서비스에 기록할 수 있습니다.\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e요청에 헤더 추가\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e앵귤러에서는 인터셉터를 활용하여 HTTP 요청을 수정하고 요청 헤더에 추가적인 값들을 넣을 수 있어요.\u003c/p\u003e\n\u003cp\u003e단계 1\u003c/p\u003e\n\u003cp\u003e다음 명령어를 사용하여 새 헤더 인터셉터를 만들어보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eHttpRequest\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpHandler\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpEvent\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpInterceptor\u003c/span\u003e\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/common/http'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHeadersInterceptor\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eHttpInterceptor\u003c/span\u003e {\n\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {}\n\n  \u003cspan class=\"hljs-title function_\"\u003eintercept\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003erequest\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHttpRequest\u003c/span\u003e\u0026#x3C;unknown\u003e, \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHttpHandler\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHttpEvent\u003c/span\u003e\u0026#x3C;unknown\u003e\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(request)\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGUID\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'f4179b26-21ac-432c-bcd8-cb4bc6e50981'\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e modifiedRequest = request.\u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003esetHeaders\u003c/span\u003e:{\n        \u003cspan class=\"hljs-variable constant_\"\u003eGUID\u003c/span\u003e\n      }\n    })\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e next.\u003cspan class=\"hljs-title function_\"\u003ehandle\u003c/span\u003e(modifiedRequest);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저 헤더 안에 설정할 GUID를 하드코딩합니다. 그래서 먼저 HTTP 요청을 복제하고 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.\u003c/p\u003e\n\u003ch3\u003e단계 2\u003c/h3\u003e\n\u003cp\u003e앱 모듈에 인터셉터를 제공하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eHeadersInterceptor\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./interceptors/headers.interceptor'\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003eproviders\u003c/span\u003e: [\n    {\n      \u003cspan class=\"hljs-attr\"\u003eprovide\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eHTTP_INTERCEPTORS\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003euseClass\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHeadersInterceptor\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emulti\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n    }\n  ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 Interceptor가 기존 Interceptor 배열에 추가되도록 하는 것을 보장하며, 기존 Interceptor를 대체하지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_3.png\" alt=\"HTTP Interceptors in Angular\"\u003e\u003c/p\u003e\n\u003cp\u003e실제 시나리오에서는 이러한 헤더 값들을 추가로 처리하는 데 활용할 수 있습니다. 예를 들어 요청을 유효성 검사하거나 다른 여러 경우에 사용할 수 있습니다.\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e에러 처리 Interceptor\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e앵귤러에서, 에러 인터셉터는 HTTP 인터셉터로서 어플리케이션 전반에 걸쳐 HTTP 에러를 처리할 수 있게 해주는 기능입니다.\u003c/p\u003e\n\u003cp\u003e서버로 HTTP 요청을 보낼 때, 404나 500과 같은 에러 상태 코드로 응답을 받을 수 있는 상황이 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e각각의 HTTP 요청마다 이러한 에러들을 처리하는 것은 지루하고 반복적일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e에러 인터셉터는 에러 처리 로직을 중앙화시켜 주며, 어플리케이션 전반에 걸쳐 일관된 방법으로 에러를 관리할 수 있도록 도와줍니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e단계 1\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e다음 명령을 사용하여 새로운 오류 인터셉터를 생성하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eHttpRequest\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpHandler\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpEvent\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpInterceptor\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpErrorResponse\u003c/span\u003e\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/common/http'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e, catchError, throwError } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eErrorInterceptor\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eHttpInterceptor\u003c/span\u003e {\n\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {}\n\n  \u003cspan class=\"hljs-title function_\"\u003eintercept\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003erequest\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHttpRequest\u003c/span\u003e\u0026#x3C;any\u003e, \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHttpHandler\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHttpEvent\u003c/span\u003e\u0026#x3C;any\u003e\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e next.\u003cspan class=\"hljs-title function_\"\u003ehandle\u003c/span\u003e(request).\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\n      \u003cspan class=\"hljs-title function_\"\u003ecatchError\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerror: HttpErrorResponse\u003c/span\u003e) =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 여기서 오류를 처리합니다\u003c/span\u003e\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'오류 발생:'\u003c/span\u003e, error);\n        \u003cspan class=\"hljs-comment\"\u003e// 요구에 따라 오류 throw\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ethrowError\u003c/span\u003e(error);\n      })\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eintercept()\u003c/code\u003e 메서드 내에서 RxJS의 \u003ccode\u003ecatchError\u003c/code\u003e 연산자를 사용하여 HTTP 요청이나 응답 처리 중 발생하는 오류를 잡을 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e단계 1\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e· 오류를 가로채고 필요에 따라 처리하고, 오류를 선택적으로 다시 던져서 observable 체인을 계속 전파할 수 있게 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e단계 2\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e· 앱 모듈에서 인터셉터를 제공하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eErrorInterceptor\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./interceptors/error.interceptor'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-attr\"\u003eproviders\u003c/span\u003e: [\n  {\n    \u003cspan class=\"hljs-attr\"\u003eprovide\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eHTTP_INTERCEPTORS\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003euseClass\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eErrorInterceptor\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emulti\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n  }\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e· AppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 Interceptor로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션을 사용하면 Interceptor가 기존 Interceptor 배열에 추가되며 대체되지 않습니다.\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eAuthentication Interceptor\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAngular에서는 인증 Interceptor를 사용하여 모든 외부 HTTP 요청에 인증 토큰이나 헤더를 추가할 수 있습니다. API 요청이 모두 인증된 상태인지 확인해야 할 때 유용합니다.\u003c/p\u003e\n\u003cp\u003e단계 1\u003c/p\u003e\n\u003cp\u003e다음 명령어를 사용하여 새로운 인증 인터셉터를 만들어보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eHttpEvent\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpInterceptor\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpHandler\u003c/span\u003e,\n  \u003cspan class=\"hljs-title class_\"\u003eHttpRequest\u003c/span\u003e,\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/common/http'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e//import { AuthService } from './auth.service';\u003c/span\u003e\n\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAuthInterceptor\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eHttpInterceptor\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-comment\"\u003e/*private authService: AuthService*/\u003c/span\u003e\u003c/span\u003e) {}\n\n  \u003cspan class=\"hljs-title function_\"\u003eintercept\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003ereq\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHttpRequest\u003c/span\u003e\u0026#x3C;any\u003e,\n    \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHttpHandler\u003c/span\u003e\n  ): \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eHttpEvent\u003c/span\u003e\u0026#x3C;any\u003e\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e authToken = \u003cspan class=\"hljs-string\"\u003e\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpheWRlZXAgUGF0aWwiLCJpYXQiOjE1MTYyMzkwMjJ9.yt3EOXf60R62Mef2oFpbFh2ihkP5qZ4fM8bjVnF8YhA\"\u003c/span\u003e;\u003cspan class=\"hljs-comment\"\u003e//his.authService.getToken();\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (authToken) {\n      \u003cspan class=\"hljs-comment\"\u003e// 요청을 복제하고 토큰을 첨부합니다\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e authReq = req.\u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e({\n        \u003cspan class=\"hljs-attr\"\u003esetHeaders\u003c/span\u003e: {\n          \u003cspan class=\"hljs-title class_\"\u003eAuthorization\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`Bearer \u003cspan class=\"hljs-subst\"\u003e${authToken}\u003c/span\u003e`\u003c/span\u003e\n        }\n      });\n\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e next.\u003cspan class=\"hljs-title function_\"\u003ehandle\u003c/span\u003e(authReq);\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 토큰이 없는 경우 원본 요청을 전달합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e next.\u003cspan class=\"hljs-title function_\"\u003ehandle\u003c/span\u003e(req);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 우리는 먼저 헤더에 설정할 하나의 토큰을 하드코딩합니다. 따라서 첫 번째로 HTTP 요청을 복제하고 요청 헤더에 값을 설정하기 위해 set headers 속성을 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003eStep 2\u003c/p\u003e\n\u003cp\u003e앱 모듈에서 인터셉터를 제공하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eAuthInterceptor\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./interceptors/auth.interceptor'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-attr\"\u003eproviders\u003c/span\u003e: [\n  {\n    \u003cspan class=\"hljs-attr\"\u003eprovide\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eHTTP_INTERCEPTORS\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003euseClass\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAuthInterceptor\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emulti\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n  }\n]  \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAppModule에서 HTTP_INTERCEPTORS 토큰을 사용하여 인터셉터로 HeadersInterceptor 클래스를 제공합니다. multi: true 옵션은 인터셉터가 기존의 인터셉터 배열에 추가되도록 하는 것을 보장합니다.\u003c/p\u003e\n\u003cp\u003eHTTP 요청을 보낼 때, 아래와 같이 헤더 내에 토큰을 설정할 것입니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-12-HTTPInterceptorsinAngular_4.png\"\u003e\n\u003cp\u003e여기서 볼 수 있듯이, 필요에 따라 추가 처리에 사용할 수 있는 하나의 bearer 토큰을 설정했습니다.\u003c/p\u003e\n\u003ch1\u003eGitHub URL\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/Jaydeep-007/angular-http-interceptor-demo\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/Jaydeep-007/angular-http-interceptor-demo\u003c/a\u003e\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 글에서는 인터셉터의 기본, 이점 및 실시간 사용 사례를 Angular 15를 사용하여 단계별 구현을 통해 설명했습니다.\u003c/p\u003e\n\u003cp\u003e코딩하세요!\u003c/p\u003e\n\u003ch1\u003e간단히 말해서\u003c/h1\u003e\n\u003cp\u003e우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작가를 박수로 칭찬하고 팔로우해 주세요! 👏\u003c/li\u003e\n\u003cli\u003ePlainEnglish.io에서 더 많은 콘텐츠를 찾아보세요! 🚀\u003c/li\u003e\n\u003cli\u003e무료 주간 뉴스레터에 가입해주세요. 🗞️\u003c/li\u003e\n\u003cli\u003e트위터, 링크드인, 유튜브, 디스코드에서도 우리를 팔로우해주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-HTTPInterceptorsinAngular"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>