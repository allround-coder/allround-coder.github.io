<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>React Native 웹 뷰와 React 앱 간의 통신 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="React Native 웹 뷰와 React 앱 간의 통신 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="React Native 웹 뷰와 React 앱 간의 통신 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp" data-gatsby-head="true"/><meta name="twitter:title" content="React Native 웹 뷰와 React 앱 간의 통신 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 11:40" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_buildManifest.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">React Native 웹 뷰와 React 앱 간의 통신</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="React Native 웹 뷰와 React 앱 간의 통신" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">3<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>이것은 React Native 웹 뷰와 React 응용 프로그램 간의 데이터 통신 방법 중 하나입니다.</p>
<p><img src="/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png" alt="CommunicationbetweenReactNativewebviewandReactapp"/></p>
<p>React Native 앱의 웹 뷰와 별도로 호스팅된 React 애플리케이션 간의 통신 방법은 여러 가지가 있을 수 있습니다. 저는 이러한 요구사항을 마주했고, 여기에 적용하기로 결정한 해결책을 공유하려 합니다.</p>
<p>먼저, React 응용 프로그램과 React Native 응용 프로그램의 기본 구현을 살펴보겠습니다.</p>
<p>간단한 React 어플리케이션:-</p>
<ul>
<li>App.js의 useEffect() 안에 원시 이벤트를 수신하는 이벤트 리스너를 추가합니다. 이는 HTML의 &quot;window&quot; 객체 내에 존재합니다. EventTarget 인터페이스의 addEventListener() 메소드는 특정 이벤트가 대상에 전달될 때마다 호출될 함수를 설정합니다. 참고: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener</li>
<li>첨부한 리스너 함수 안에서는 React 네이티브 또는 HTML 문서로 전송되는 외부 소스에서 찾을 수 있는 데이터가 포함된 nativeEvent 객체를 얻습니다.</li>
<li>React에서 React 네이티브로 메시지를 보내려면 window.ReactNativeWebView.postMessage() 메소드를 사용할 수 있습니다. 추가적인 임포트나 패키지가 필요하지 않습니다. 이는 HTML의 &quot;window&quot; 객체에 내장되어 있습니다. window.postMessage() 메소드는 Window 객체 간 안전하게 교차 출처 통신을 가능하게 합니다. 예를 들어 페이지와 생성된 팝업 간 또는 페이지와 내장된 iframe 간의 통신입니다. 참고: https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage</li>
</ul>
<img src="/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_1.png"/>
<p>간단한 React 네이티브 어플리케이션과 웹 뷰:-</p>
<ul>
<li>어떤 npm 패키지에서 간단한 웹뷰를 생성합니다.</li>
<li>웹사이트에서 메시지를 받으려면 웹뷰의 onMessage = &#x27;&#x27; 속성을 가리키는 메소드를 첨부합니다. 해당 함수에서 들어오는 메시지를 처리할 수 있습니다.</li>
<li>React로 메시지를 보내려면 useRef()를 사용하여 참조를 가져와야 합니다. ref = &#x27;webViewRef&#x27;와 함께 첨부합니다.</li>
<li>webViewRef.current.postMessage()를 사용하여 React 웹사이트로 메시지를 보낼 수 있습니다.</li>
<li>componentDidMount() 시점에 뭔가를 트리거하려면, webview의 onLoadEnd() 속성에 필요한 메소드를 추가하여 할 수 있습니다. 이것은 웹뷰가 웹사이트를 로드했을 때 콜백을 트리거합니다.</li>
<li>최신 버전의 userAgents를 언급했습니다. 또한 domStorageEnabled, cacheEnabled, javaScriptEnabled 등과 같은 프롭스를 활성화하여 React Native 스크린의 성능이 향상되도록 했습니다.</li>
<li>사이트가 로드될 때까지 사용자 정의 로더를 표시할 수도 있습니다.</li>
</ul>
<p><a href="/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_2.png">이미지 바로가기</a></p>
<p>저의 Github 저장소 공유합니다: <a href="https://github.com/svbala99/react-zoom">react-zoom</a> 및 <a href="https://github.com/svbala99/zoomsdk-sign-generator-express">zoomsdk-sign-generator-express</a></p>
<p>이 저장소들은 React Native에서 웹뷰를 설정할 수 있게 해주고, 해당 웹뷰에서 zoom 미팅을 호스팅할 수 있게 합니다. 두 번째 저장소는 안전한 서명을 생성하는 데 도움이 됩니다. 이는 공식 Zoom에서 지시한 대로 입니다.</p>
<p>누군가에게 도움이 되면 좋겣습니다. 읽어 주셔서 감사합니다. 또 다른 흥미로운 글로 돌아오겠습니다. 건강하세요, 챙기세요!!!</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React Native 웹 뷰와 React 앱 간의 통신","description":"","date":"2024-05-14 11:40","slug":"2024-05-14-CommunicationbetweenReactNativewebviewandReactapp","content":"\n\n이것은 React Native 웹 뷰와 React 응용 프로그램 간의 데이터 통신 방법 중 하나입니다.\n\n![CommunicationbetweenReactNativewebviewandReactapp](/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png)\n\nReact Native 앱의 웹 뷰와 별도로 호스팅된 React 애플리케이션 간의 통신 방법은 여러 가지가 있을 수 있습니다. 저는 이러한 요구사항을 마주했고, 여기에 적용하기로 결정한 해결책을 공유하려 합니다.\n\n먼저, React 응용 프로그램과 React Native 응용 프로그램의 기본 구현을 살펴보겠습니다.\n\n\n\n간단한 React 어플리케이션:-\n\n- App.js의 useEffect() 안에 원시 이벤트를 수신하는 이벤트 리스너를 추가합니다. 이는 HTML의 \"window\" 객체 내에 존재합니다. EventTarget 인터페이스의 addEventListener() 메소드는 특정 이벤트가 대상에 전달될 때마다 호출될 함수를 설정합니다. 참고: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\n- 첨부한 리스너 함수 안에서는 React 네이티브 또는 HTML 문서로 전송되는 외부 소스에서 찾을 수 있는 데이터가 포함된 nativeEvent 객체를 얻습니다.\n- React에서 React 네이티브로 메시지를 보내려면 window.ReactNativeWebView.postMessage() 메소드를 사용할 수 있습니다. 추가적인 임포트나 패키지가 필요하지 않습니다. 이는 HTML의 \"window\" 객체에 내장되어 있습니다. window.postMessage() 메소드는 Window 객체 간 안전하게 교차 출처 통신을 가능하게 합니다. 예를 들어 페이지와 생성된 팝업 간 또는 페이지와 내장된 iframe 간의 통신입니다. 참고: https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n\n\u003cimg src=\"/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_1.png\" /\u003e\n\n간단한 React 네이티브 어플리케이션과 웹 뷰:-\n\n\n\n- 어떤 npm 패키지에서 간단한 웹뷰를 생성합니다.\n- 웹사이트에서 메시지를 받으려면 웹뷰의 onMessage = '' 속성을 가리키는 메소드를 첨부합니다. 해당 함수에서 들어오는 메시지를 처리할 수 있습니다.\n- React로 메시지를 보내려면 useRef()를 사용하여 참조를 가져와야 합니다. ref = 'webViewRef'와 함께 첨부합니다.\n- webViewRef.current.postMessage()를 사용하여 React 웹사이트로 메시지를 보낼 수 있습니다.\n- componentDidMount() 시점에 뭔가를 트리거하려면, webview의 onLoadEnd() 속성에 필요한 메소드를 추가하여 할 수 있습니다. 이것은 웹뷰가 웹사이트를 로드했을 때 콜백을 트리거합니다.\n- 최신 버전의 userAgents를 언급했습니다. 또한 domStorageEnabled, cacheEnabled, javaScriptEnabled 등과 같은 프롭스를 활성화하여 React Native 스크린의 성능이 향상되도록 했습니다.\n- 사이트가 로드될 때까지 사용자 정의 로더를 표시할 수도 있습니다.\n\n[이미지 바로가기](/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_2.png)\n\n저의 Github 저장소 공유합니다: [react-zoom](https://github.com/svbala99/react-zoom) 및 [zoomsdk-sign-generator-express](https://github.com/svbala99/zoomsdk-sign-generator-express)\n\n이 저장소들은 React Native에서 웹뷰를 설정할 수 있게 해주고, 해당 웹뷰에서 zoom 미팅을 호스팅할 수 있게 합니다. 두 번째 저장소는 안전한 서명을 생성하는 데 도움이 됩니다. 이는 공식 Zoom에서 지시한 대로 입니다.\n\n\n\n누군가에게 도움이 되면 좋겣습니다. 읽어 주셔서 감사합니다. 또 다른 흥미로운 글로 돌아오겠습니다. 건강하세요, 챙기세요!!!","ogImage":{"url":"/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png"},"coverImage":"/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png","tag":["Tech"],"readingTime":3},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"이것은 React Native 웹 뷰와 React 응용 프로그램 간의 데이터 통신 방법 중 하나입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_0.png\",\n        alt: \"CommunicationbetweenReactNativewebviewandReactapp\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React Native 앱의 웹 뷰와 별도로 호스팅된 React 애플리케이션 간의 통신 방법은 여러 가지가 있을 수 있습니다. 저는 이러한 요구사항을 마주했고, 여기에 적용하기로 결정한 해결책을 공유하려 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"먼저, React 응용 프로그램과 React Native 응용 프로그램의 기본 구현을 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"간단한 React 어플리케이션:-\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"App.js의 useEffect() 안에 원시 이벤트를 수신하는 이벤트 리스너를 추가합니다. 이는 HTML의 \\\"window\\\" 객체 내에 존재합니다. EventTarget 인터페이스의 addEventListener() 메소드는 특정 이벤트가 대상에 전달될 때마다 호출될 함수를 설정합니다. 참고: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"첨부한 리스너 함수 안에서는 React 네이티브 또는 HTML 문서로 전송되는 외부 소스에서 찾을 수 있는 데이터가 포함된 nativeEvent 객체를 얻습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"React에서 React 네이티브로 메시지를 보내려면 window.ReactNativeWebView.postMessage() 메소드를 사용할 수 있습니다. 추가적인 임포트나 패키지가 필요하지 않습니다. 이는 HTML의 \\\"window\\\" 객체에 내장되어 있습니다. window.postMessage() 메소드는 Window 객체 간 안전하게 교차 출처 통신을 가능하게 합니다. 예를 들어 페이지와 생성된 팝업 간 또는 페이지와 내장된 iframe 간의 통신입니다. 참고: https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"간단한 React 네이티브 어플리케이션과 웹 뷰:-\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"어떤 npm 패키지에서 간단한 웹뷰를 생성합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"웹사이트에서 메시지를 받으려면 웹뷰의 onMessage = '' 속성을 가리키는 메소드를 첨부합니다. 해당 함수에서 들어오는 메시지를 처리할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"React로 메시지를 보내려면 useRef()를 사용하여 참조를 가져와야 합니다. ref = 'webViewRef'와 함께 첨부합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"webViewRef.current.postMessage()를 사용하여 React 웹사이트로 메시지를 보낼 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"componentDidMount() 시점에 뭔가를 트리거하려면, webview의 onLoadEnd() 속성에 필요한 메소드를 추가하여 할 수 있습니다. 이것은 웹뷰가 웹사이트를 로드했을 때 콜백을 트리거합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"최신 버전의 userAgents를 언급했습니다. 또한 domStorageEnabled, cacheEnabled, javaScriptEnabled 등과 같은 프롭스를 활성화하여 React Native 스크린의 성능이 향상되도록 했습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"사이트가 로드될 때까지 사용자 정의 로더를 표시할 수도 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.a, {\n        href: \"/assets/img/2024-05-14-CommunicationbetweenReactNativewebviewandReactapp_2.png\",\n        children: \"이미지 바로가기\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"저의 Github 저장소 공유합니다: \", _jsx(_components.a, {\n        href: \"https://github.com/svbala99/react-zoom\",\n        children: \"react-zoom\"\n      }), \" 및 \", _jsx(_components.a, {\n        href: \"https://github.com/svbala99/zoomsdk-sign-generator-express\",\n        children: \"zoomsdk-sign-generator-express\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 저장소들은 React Native에서 웹뷰를 설정할 수 있게 해주고, 해당 웹뷰에서 zoom 미팅을 호스팅할 수 있게 합니다. 두 번째 저장소는 안전한 서명을 생성하는 데 도움이 됩니다. 이는 공식 Zoom에서 지시한 대로 입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"누군가에게 도움이 되면 좋겣습니다. 읽어 주셔서 감사합니다. 또 다른 흥미로운 글로 돌아오겠습니다. 건강하세요, 챙기세요!!!\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-CommunicationbetweenReactNativewebviewandReactapp"},"buildId":"R94iUTCf1NWeBC_VXjTJG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>