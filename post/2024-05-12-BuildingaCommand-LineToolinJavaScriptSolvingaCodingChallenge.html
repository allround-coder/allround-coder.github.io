<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>JavaScript로 Command-Line Tool 만드는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="JavaScript로 Command-Line Tool 만드는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="JavaScript로 Command-Line Tool 만드는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge" data-gatsby-head="true"/><meta name="twitter:title" content="JavaScript로 Command-Line Tool 만드는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 23:52" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">JavaScript로 Command-Line Tool 만드는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="JavaScript로 Command-Line Tool 만드는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png">
<h1>소개:</h1>
<p>이 가이드에 오신 것을 환영합니다! JavaScript를 사용하여 명령줄 도구를 구축하는 코딩 챌린지에 도전하게 됩니다. 우리의 목표는 텍스트 파일을 분석하고 줄 수, 단어 수, 문자 수 등 다양한 메트릭을 제공할 수 있는 다재다능한 도구를 만드는 것입니다.</p>
<p>여기에서 다룰 도전 과제를 찾을 수 있습니다. 이 작업에는 JavaScript (JS)을 사용하겠습니다. 이제 구현 세부 정보로 바로 들어가 봅시다.</p>
<h1>환경 설정하기</h1>
<p>명령줄 도구를 만들 때 가장 먼저 해야 할 일 중 하나는 코드를 작성할 위치를 결정하는 것입니다. 통합 개발 환경(IDE)에서의 전통적인 개발과는 달리, 스크립팅은 약간 다른 절차를 따릅니다.</p>
<p>먼저, 컴퓨터에 Node.js가 설치되어 있는지 확인하세요. 그런 다음 다음 단계를 따르세요:</p>
<ul>
<li>프로젝트의 루트 디렉토리로 이동합니다.</li>
<li>mkdir bin 명령을 사용하여 'bin'이라는 새 폴더를 만듭니다.</li>
<li>'bin' 폴더 내부에 새 파일을 만듭니다. touch <code>파일이름</code>을 사용할 수 있습니다.</li>
<li>텍스트 편집기로 파일을 열기 위해 nano <code>파일이름</code>을 사용합니다.</li>
<li>파일의 맨 위에 다음 해시뱅( shebang) 라인을 추가합니다: #!/usr/local/bin/node. 이 라인은 컴파일러에게 코드를 Node.js를 사용해 해석하도록 지시합니다.</li>
<li>Ctrl + O를 눌러 변경 사항을 저장한 후 Enter를 누르고 Ctrl + X를 눌러 편집기를 종료합니다.</li>
<li>chmod +x <code>파일이름</code>을 사용하여 스크립트에 실행 권한을 부여합니다.</li>
<li>bin 폴더 내부에 export PATH="$HOME/bin:$PATH"를 입력합니다.</li>
<li>이제이 스크립트를 실행할 때마다 Node.js 스크립트로 해석됩니다.</li>
</ul>
<h1>챌린지 해결하기</h1>
<h2>단계 1: 파일의 바이트 수 세기</h2>
<p>우리의 첫 번째 작업은 파일의 바이트 수를 계산하고 터미널에서 제공된 인수가 ‘-c’인지 감지하는 함수를 만드는 것입니다. 다음은 이를 어떻게 달성할 수 있는지입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">"fs"</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title function_">readFileContent</span>(<span class="hljs-params">fileName</span>) {
  <span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(fileName)) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`파일을 찾을 수 없습니다: <span class="hljs-subst">${fileName}</span>`</span>);
    process.<span class="hljs-title function_">exit</span>(<span class="hljs-number">1</span>);
  }

  fs.<span class="hljs-title function_">readFile</span>(fileName, <span class="hljs-string">"utf8"</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =></span> {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
    <span class="hljs-keyword">const</span> fileSizeInBytes = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">byteLength</span>(data, <span class="hljs-string">"utf8"</span>);
    <span class="hljs-title function_">displayResult</span>(fileSizeInBytes);
  });
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">displayResult</span>(<span class="hljs-params">fileSizeInBytes</span>) {
  <span class="hljs-keyword">if</span> (commandLineOption === <span class="hljs-string">"-c"</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${fileSizeInBytes}</span> <span class="hljs-subst">${fileName}</span>`</span>);
  }
}
<span class="hljs-keyword">let</span> fileName = process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>];
<span class="hljs-keyword">const</span> commandLineOption = process.<span class="hljs-property">argv</span>[<span class="hljs-number">3</span>];
<span class="hljs-title function_">readFileContent</span>(fileName);
</code></pre>
<p>이 코드 스니펫에서는 fs.readFile 메서드를 사용하여 파일 내용을 읽고 Buffer.byteLength를 사용하여 파일 크기를 바이트 단위로 계산합니다. 그런 다음 명령줄 옵션이 ‘-c’와 일치하는 경우 결과를 표시합니다.</p>
<h2>단계 2: 줄, 단어 및 문자수 계산하기</h2>
<p>다음으로, 파일의 줄 수, 단어 수 및 문자 수를 계산하는 도구를 확장합니다. readFileContent 함수를 재사용하여 ‘-l’, ‘-w’ 및 ‘-m’과 같은 추가 옵션을 지원하도록 향상시킬 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">readFileContent</span>(<span class="hljs-params">fileName</span>) {
  <span class="hljs-comment">// 이전과 동일</span>
  fs.<span class="hljs-title function_">readFile</span>(fileName, <span class="hljs-string">"utf8"</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =></span> {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
    <span class="hljs-keyword">const</span> { charactersCount, wordsCount, numberOfLines } = <span class="hljs-title function_">parseFile</span>(data);
    <span class="hljs-title function_">displayResult</span>(charactersCount, wordsCount, numberOfLines);
  });
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">parseFile</span>(<span class="hljs-params">data</span>) {
  <span class="hljs-keyword">const</span> charactersCount = data.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> wordsCount = data.<span class="hljs-title function_">split</span>(<span class="hljs-string">" "</span>).<span class="hljs-property">length</span>;
  <span class="hljs-keyword">const</span> numberOfLines = data.<span class="hljs-title function_">split</span>(<span class="hljs-string">"\n"</span>).<span class="hljs-property">length</span>;
  <span class="hljs-keyword">return</span> { charactersCount, wordsCount, numberOfLines };
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">displayResult</span>(<span class="hljs-params">charactersCount, wordsCount, numberOfLines</span>) {
  <span class="hljs-comment">// 이전과 동일하며 '-l', '-w', '-m'에 대한 추가 조건이 있습니다.</span>
}
<span class="hljs-keyword">let</span> fileName = process.<span class="hljs-property">argv</span>[<span class="hljs-number">2</span>];
<span class="hljs-keyword">const</span> commandLineOption = process.<span class="hljs-property">argv</span>[<span class="hljs-number">3</span>];
<span class="hljs-title function_">readFileContent</span>(fileName);
</code></pre>
<p>이 수정된 코드에서는 파일 내용을 구문 분석하여 줄 수, 단어 수 및 문자 수를 계산합니다. 그런 다음 제공된 명령줄 옵션에 따라 해당 카운트를 표시합니다.</p>
<h2>단계 3: 표준 입력 처리</h2>
<p>파일 이름이 지정되지 않은 경우 표준 입력에서 읽기를 지원하기 위해 코드를 수정하여 다른 명령에서 입력이 파이프될 때 (예: cat test.txt | ccwc -l) 입력이 감지되는지 확인해야 합니다. 다음과 같이 이를 달성할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (!process.<span class="hljs-property">stdin</span>.<span class="hljs-property">isTTY</span>) {
  <span class="hljs-keyword">let</span> data = <span class="hljs-string">""</span>;
  process.<span class="hljs-property">stdin</span>.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">"utf8"</span>);
  process.<span class="hljs-property">stdin</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">"data"</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =></span> {
    data += chunk;
  });
  process.<span class="hljs-property">stdin</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">"end"</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> { charactersCount, wordsCount, numberOfLines } = <span class="hljs-title function_">parseFile</span>(data);
    <span class="hljs-title function_">displayResult</span>(charactersCount, wordsCount, numberOfLines);
  });
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// 이전과 동일하지만 약간 수정된 부분이 있음</span>
}
</code></pre>
<p>표준 입력이 제공되는지 확인함으로써 (!process.stdin.isTTY), 우리는 적절하게 파이프로 연결된 입력을 처리할 수 있습니다.</p>
<h2>결론</h2>
<p>이 안내서에서는 코딩 도전 과제를 해결하기 위해 JavaScript로 명령줄 도구를 만드는 과정을 안내했습니다. 환경 설정, 파일에서 바이트, 라인, 단어 및 문자 수를 세는 기능 구현, 그리고 표준 입력 처리까지 다루었습니다.</p>
<p>이 튜토리얼을 따라와 주셔서 CLI 도구 구축, Node.js 파일 처리, 그리고 동적으로 명령줄 인수를 처리하는 방법에 대한 통찰력을 얻었습니다.</p>
<p>GitHub에서 완전한 코드 솔루션과 테스트 파일을 살펴보세요.</p>
<p>이 안내서가 도움이 되었기를 바랍니다. 궁금한 사항이나 제안 사항이 있으면 아래에 댓글을 남겨주세요. 더 많은 튜토리얼을 기대해주세요!</p>
<p>다음 포스트에서 뵙겠습니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JavaScript로 Command-Line Tool 만드는 방법","description":"","date":"2024-05-12 23:52","slug":"2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge","content":"\n\u003cimg src=\"/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png\" /\u003e\n\n# 소개:\n\n이 가이드에 오신 것을 환영합니다! JavaScript를 사용하여 명령줄 도구를 구축하는 코딩 챌린지에 도전하게 됩니다. 우리의 목표는 텍스트 파일을 분석하고 줄 수, 단어 수, 문자 수 등 다양한 메트릭을 제공할 수 있는 다재다능한 도구를 만드는 것입니다.\n\n여기에서 다룰 도전 과제를 찾을 수 있습니다. 이 작업에는 JavaScript (JS)을 사용하겠습니다. 이제 구현 세부 정보로 바로 들어가 봅시다.\n\n# 환경 설정하기\n\n명령줄 도구를 만들 때 가장 먼저 해야 할 일 중 하나는 코드를 작성할 위치를 결정하는 것입니다. 통합 개발 환경(IDE)에서의 전통적인 개발과는 달리, 스크립팅은 약간 다른 절차를 따릅니다.\n\n먼저, 컴퓨터에 Node.js가 설치되어 있는지 확인하세요. 그런 다음 다음 단계를 따르세요:\n\n- 프로젝트의 루트 디렉토리로 이동합니다.\n- mkdir bin 명령을 사용하여 'bin'이라는 새 폴더를 만듭니다.\n- 'bin' 폴더 내부에 새 파일을 만듭니다. touch `파일이름`을 사용할 수 있습니다.\n- 텍스트 편집기로 파일을 열기 위해 nano `파일이름`을 사용합니다.\n- 파일의 맨 위에 다음 해시뱅( shebang) 라인을 추가합니다: #!/usr/local/bin/node. 이 라인은 컴파일러에게 코드를 Node.js를 사용해 해석하도록 지시합니다.\n- Ctrl + O를 눌러 변경 사항을 저장한 후 Enter를 누르고 Ctrl + X를 눌러 편집기를 종료합니다.\n- chmod +x `파일이름`을 사용하여 스크립트에 실행 권한을 부여합니다.\n- bin 폴더 내부에 export PATH=\"$HOME/bin:$PATH\"를 입력합니다.\n- 이제이 스크립트를 실행할 때마다 Node.js 스크립트로 해석됩니다.\n\n# 챌린지 해결하기\n\n## 단계 1: 파일의 바이트 수 세기\n\n우리의 첫 번째 작업은 파일의 바이트 수를 계산하고 터미널에서 제공된 인수가 ‘-c’인지 감지하는 함수를 만드는 것입니다. 다음은 이를 어떻게 달성할 수 있는지입니다:\n\n```js\nconst fs = require(\"fs\");\nfunction readFileContent(fileName) {\n  if (!fs.existsSync(fileName)) {\n    console.log(`파일을 찾을 수 없습니다: ${fileName}`);\n    process.exit(1);\n  }\n\n  fs.readFile(fileName, \"utf8\", (err, data) =\u003e {\n    if (err) throw err;\n    const fileSizeInBytes = Buffer.byteLength(data, \"utf8\");\n    displayResult(fileSizeInBytes);\n  });\n}\nfunction displayResult(fileSizeInBytes) {\n  if (commandLineOption === \"-c\") {\n    console.log(`${fileSizeInBytes} ${fileName}`);\n  }\n}\nlet fileName = process.argv[2];\nconst commandLineOption = process.argv[3];\nreadFileContent(fileName);\n```\n\n이 코드 스니펫에서는 fs.readFile 메서드를 사용하여 파일 내용을 읽고 Buffer.byteLength를 사용하여 파일 크기를 바이트 단위로 계산합니다. 그런 다음 명령줄 옵션이 ‘-c’와 일치하는 경우 결과를 표시합니다.\n\n## 단계 2: 줄, 단어 및 문자수 계산하기\n\n다음으로, 파일의 줄 수, 단어 수 및 문자 수를 계산하는 도구를 확장합니다. readFileContent 함수를 재사용하여 ‘-l’, ‘-w’ 및 ‘-m’과 같은 추가 옵션을 지원하도록 향상시킬 수 있습니다.\n\n```js\nfunction readFileContent(fileName) {\n  // 이전과 동일\n  fs.readFile(fileName, \"utf8\", (err, data) =\u003e {\n    if (err) throw err;\n    const { charactersCount, wordsCount, numberOfLines } = parseFile(data);\n    displayResult(charactersCount, wordsCount, numberOfLines);\n  });\n}\nfunction parseFile(data) {\n  const charactersCount = data.length;\n  const wordsCount = data.split(\" \").length;\n  const numberOfLines = data.split(\"\\n\").length;\n  return { charactersCount, wordsCount, numberOfLines };\n}\nfunction displayResult(charactersCount, wordsCount, numberOfLines) {\n  // 이전과 동일하며 '-l', '-w', '-m'에 대한 추가 조건이 있습니다.\n}\nlet fileName = process.argv[2];\nconst commandLineOption = process.argv[3];\nreadFileContent(fileName);\n```\n\n이 수정된 코드에서는 파일 내용을 구문 분석하여 줄 수, 단어 수 및 문자 수를 계산합니다. 그런 다음 제공된 명령줄 옵션에 따라 해당 카운트를 표시합니다.\n\n## 단계 3: 표준 입력 처리\n\n파일 이름이 지정되지 않은 경우 표준 입력에서 읽기를 지원하기 위해 코드를 수정하여 다른 명령에서 입력이 파이프될 때 (예: cat test.txt | ccwc -l) 입력이 감지되는지 확인해야 합니다. 다음과 같이 이를 달성할 수 있습니다:\n\n```js\nif (!process.stdin.isTTY) {\n  let data = \"\";\n  process.stdin.setEncoding(\"utf8\");\n  process.stdin.on(\"data\", (chunk) =\u003e {\n    data += chunk;\n  });\n  process.stdin.on(\"end\", () =\u003e {\n    const { charactersCount, wordsCount, numberOfLines } = parseFile(data);\n    displayResult(charactersCount, wordsCount, numberOfLines);\n  });\n} else {\n  // 이전과 동일하지만 약간 수정된 부분이 있음\n}\n```\n\n표준 입력이 제공되는지 확인함으로써 (!process.stdin.isTTY), 우리는 적절하게 파이프로 연결된 입력을 처리할 수 있습니다.\n\n## 결론\n\n이 안내서에서는 코딩 도전 과제를 해결하기 위해 JavaScript로 명령줄 도구를 만드는 과정을 안내했습니다. 환경 설정, 파일에서 바이트, 라인, 단어 및 문자 수를 세는 기능 구현, 그리고 표준 입력 처리까지 다루었습니다.\n\n이 튜토리얼을 따라와 주셔서 CLI 도구 구축, Node.js 파일 처리, 그리고 동적으로 명령줄 인수를 처리하는 방법에 대한 통찰력을 얻었습니다.\n\nGitHub에서 완전한 코드 솔루션과 테스트 파일을 살펴보세요.\n\n이 안내서가 도움이 되었기를 바랍니다. 궁금한 사항이나 제안 사항이 있으면 아래에 댓글을 남겨주세요. 더 많은 튜토리얼을 기대해주세요!\n\n다음 포스트에서 뵙겠습니다!\n","ogImage":{"url":"/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png"},"coverImage":"/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge_0.png\"\u003e\n\u003ch1\u003e소개:\u003c/h1\u003e\n\u003cp\u003e이 가이드에 오신 것을 환영합니다! JavaScript를 사용하여 명령줄 도구를 구축하는 코딩 챌린지에 도전하게 됩니다. 우리의 목표는 텍스트 파일을 분석하고 줄 수, 단어 수, 문자 수 등 다양한 메트릭을 제공할 수 있는 다재다능한 도구를 만드는 것입니다.\u003c/p\u003e\n\u003cp\u003e여기에서 다룰 도전 과제를 찾을 수 있습니다. 이 작업에는 JavaScript (JS)을 사용하겠습니다. 이제 구현 세부 정보로 바로 들어가 봅시다.\u003c/p\u003e\n\u003ch1\u003e환경 설정하기\u003c/h1\u003e\n\u003cp\u003e명령줄 도구를 만들 때 가장 먼저 해야 할 일 중 하나는 코드를 작성할 위치를 결정하는 것입니다. 통합 개발 환경(IDE)에서의 전통적인 개발과는 달리, 스크립팅은 약간 다른 절차를 따릅니다.\u003c/p\u003e\n\u003cp\u003e먼저, 컴퓨터에 Node.js가 설치되어 있는지 확인하세요. 그런 다음 다음 단계를 따르세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e프로젝트의 루트 디렉토리로 이동합니다.\u003c/li\u003e\n\u003cli\u003emkdir bin 명령을 사용하여 'bin'이라는 새 폴더를 만듭니다.\u003c/li\u003e\n\u003cli\u003e'bin' 폴더 내부에 새 파일을 만듭니다. touch \u003ccode\u003e파일이름\u003c/code\u003e을 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e텍스트 편집기로 파일을 열기 위해 nano \u003ccode\u003e파일이름\u003c/code\u003e을 사용합니다.\u003c/li\u003e\n\u003cli\u003e파일의 맨 위에 다음 해시뱅( shebang) 라인을 추가합니다: #!/usr/local/bin/node. 이 라인은 컴파일러에게 코드를 Node.js를 사용해 해석하도록 지시합니다.\u003c/li\u003e\n\u003cli\u003eCtrl + O를 눌러 변경 사항을 저장한 후 Enter를 누르고 Ctrl + X를 눌러 편집기를 종료합니다.\u003c/li\u003e\n\u003cli\u003echmod +x \u003ccode\u003e파일이름\u003c/code\u003e을 사용하여 스크립트에 실행 권한을 부여합니다.\u003c/li\u003e\n\u003cli\u003ebin 폴더 내부에 export PATH=\"$HOME/bin:$PATH\"를 입력합니다.\u003c/li\u003e\n\u003cli\u003e이제이 스크립트를 실행할 때마다 Node.js 스크립트로 해석됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e챌린지 해결하기\u003c/h1\u003e\n\u003ch2\u003e단계 1: 파일의 바이트 수 세기\u003c/h2\u003e\n\u003cp\u003e우리의 첫 번째 작업은 파일의 바이트 수를 계산하고 터미널에서 제공된 인수가 ‘-c’인지 감지하는 함수를 만드는 것입니다. 다음은 이를 어떻게 달성할 수 있는지입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fs = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"fs\"\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereadFileContent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efileName\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!fs.\u003cspan class=\"hljs-title function_\"\u003eexistsSync\u003c/span\u003e(fileName)) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`파일을 찾을 수 없습니다: \u003cspan class=\"hljs-subst\"\u003e${fileName}\u003c/span\u003e`\u003c/span\u003e);\n    process.\u003cspan class=\"hljs-title function_\"\u003eexit\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n\n  fs.\u003cspan class=\"hljs-title function_\"\u003ereadFile\u003c/span\u003e(fileName, \u003cspan class=\"hljs-string\"\u003e\"utf8\"\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerr, data\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e err;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fileSizeInBytes = \u003cspan class=\"hljs-title class_\"\u003eBuffer\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebyteLength\u003c/span\u003e(data, \u003cspan class=\"hljs-string\"\u003e\"utf8\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-title function_\"\u003edisplayResult\u003c/span\u003e(fileSizeInBytes);\n  });\n}\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edisplayResult\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efileSizeInBytes\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (commandLineOption === \u003cspan class=\"hljs-string\"\u003e\"-c\"\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${fileSizeInBytes}\u003c/span\u003e \u003cspan class=\"hljs-subst\"\u003e${fileName}\u003c/span\u003e`\u003c/span\u003e);\n  }\n}\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e fileName = process.\u003cspan class=\"hljs-property\"\u003eargv\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e commandLineOption = process.\u003cspan class=\"hljs-property\"\u003eargv\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-title function_\"\u003ereadFileContent\u003c/span\u003e(fileName);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드 스니펫에서는 fs.readFile 메서드를 사용하여 파일 내용을 읽고 Buffer.byteLength를 사용하여 파일 크기를 바이트 단위로 계산합니다. 그런 다음 명령줄 옵션이 ‘-c’와 일치하는 경우 결과를 표시합니다.\u003c/p\u003e\n\u003ch2\u003e단계 2: 줄, 단어 및 문자수 계산하기\u003c/h2\u003e\n\u003cp\u003e다음으로, 파일의 줄 수, 단어 수 및 문자 수를 계산하는 도구를 확장합니다. readFileContent 함수를 재사용하여 ‘-l’, ‘-w’ 및 ‘-m’과 같은 추가 옵션을 지원하도록 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereadFileContent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efileName\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 이전과 동일\u003c/span\u003e\n  fs.\u003cspan class=\"hljs-title function_\"\u003ereadFile\u003c/span\u003e(fileName, \u003cspan class=\"hljs-string\"\u003e\"utf8\"\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerr, data\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e err;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { charactersCount, wordsCount, numberOfLines } = \u003cspan class=\"hljs-title function_\"\u003eparseFile\u003c/span\u003e(data);\n    \u003cspan class=\"hljs-title function_\"\u003edisplayResult\u003c/span\u003e(charactersCount, wordsCount, numberOfLines);\n  });\n}\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eparseFile\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e charactersCount = data.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e wordsCount = data.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\" \"\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e numberOfLines = data.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e { charactersCount, wordsCount, numberOfLines };\n}\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edisplayResult\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003echaractersCount, wordsCount, numberOfLines\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 이전과 동일하며 '-l', '-w', '-m'에 대한 추가 조건이 있습니다.\u003c/span\u003e\n}\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e fileName = process.\u003cspan class=\"hljs-property\"\u003eargv\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e commandLineOption = process.\u003cspan class=\"hljs-property\"\u003eargv\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n\u003cspan class=\"hljs-title function_\"\u003ereadFileContent\u003c/span\u003e(fileName);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 수정된 코드에서는 파일 내용을 구문 분석하여 줄 수, 단어 수 및 문자 수를 계산합니다. 그런 다음 제공된 명령줄 옵션에 따라 해당 카운트를 표시합니다.\u003c/p\u003e\n\u003ch2\u003e단계 3: 표준 입력 처리\u003c/h2\u003e\n\u003cp\u003e파일 이름이 지정되지 않은 경우 표준 입력에서 읽기를 지원하기 위해 코드를 수정하여 다른 명령에서 입력이 파이프될 때 (예: cat test.txt | ccwc -l) 입력이 감지되는지 확인해야 합니다. 다음과 같이 이를 달성할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!process.\u003cspan class=\"hljs-property\"\u003estdin\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eisTTY\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e;\n  process.\u003cspan class=\"hljs-property\"\u003estdin\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esetEncoding\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"utf8\"\u003c/span\u003e);\n  process.\u003cspan class=\"hljs-property\"\u003estdin\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"data\"\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003echunk\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    data += chunk;\n  });\n  process.\u003cspan class=\"hljs-property\"\u003estdin\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"end\"\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { charactersCount, wordsCount, numberOfLines } = \u003cspan class=\"hljs-title function_\"\u003eparseFile\u003c/span\u003e(data);\n    \u003cspan class=\"hljs-title function_\"\u003edisplayResult\u003c/span\u003e(charactersCount, wordsCount, numberOfLines);\n  });\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 이전과 동일하지만 약간 수정된 부분이 있음\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e표준 입력이 제공되는지 확인함으로써 (!process.stdin.isTTY), 우리는 적절하게 파이프로 연결된 입력을 처리할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003e이 안내서에서는 코딩 도전 과제를 해결하기 위해 JavaScript로 명령줄 도구를 만드는 과정을 안내했습니다. 환경 설정, 파일에서 바이트, 라인, 단어 및 문자 수를 세는 기능 구현, 그리고 표준 입력 처리까지 다루었습니다.\u003c/p\u003e\n\u003cp\u003e이 튜토리얼을 따라와 주셔서 CLI 도구 구축, Node.js 파일 처리, 그리고 동적으로 명령줄 인수를 처리하는 방법에 대한 통찰력을 얻었습니다.\u003c/p\u003e\n\u003cp\u003eGitHub에서 완전한 코드 솔루션과 테스트 파일을 살펴보세요.\u003c/p\u003e\n\u003cp\u003e이 안내서가 도움이 되었기를 바랍니다. 궁금한 사항이나 제안 사항이 있으면 아래에 댓글을 남겨주세요. 더 많은 튜토리얼을 기대해주세요!\u003c/p\u003e\n\u003cp\u003e다음 포스트에서 뵙겠습니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-BuildingaCommand-LineToolinJavaScriptSolvingaCodingChallenge"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>