<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>우리가 알고 있는 프론트엔드 개발의 종말 2024년 최신 동향 분석 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="우리가 알고 있는 프론트엔드 개발의 종말 2024년 최신 동향 분석 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="우리가 알고 있는 프론트엔드 개발의 종말 2024년 최신 동향 분석 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying" data-gatsby-head="true"/><meta name="twitter:title" content="우리가 알고 있는 프론트엔드 개발의 종말 2024년 최신 동향 분석 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 05:20" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">우리가 알고 있는 프론트엔드 개발의 종말 2024년 최신 동향 분석</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="우리가 알고 있는 프론트엔드 개발의 종말 2024년 최신 동향 분석" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png" alt="image"></p>
<h1>소개</h1>
<p>SPA가 등장하기 전에 웹 애플리케이션은 일반적으로 다중 페이지로 이루어져 있었습니다. 사용자가 애플리케이션과 상호 작용할 때마다 서버가 새로운 전체 페이지를 보내고 브라우저가 다시로드하는 방식이었습니다. 사용자가 페이지 간을 이동할 때마다 완전한 페이지 재로드가 발생했고, 이로 인해 속도가 느려지고 부자연스러운 사용자 경험이 발생할 수 있었습니다. 비슷한 애플리케이션들은 주로 PHP, Ruby on Rails, ASP.NET 등과 같은 서버 측 기술을 사용하여 구축되었는데, 이들은 서버 측에서 HTML 코드를 생성하여 브라우저로 보냈습니다.</p>
<p><img src="/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_1.png" alt="image"></p>
<div class="content-ad"></div>
<p>웹 개발자들은 만능 전문가였어요. 그들은 프론트엔드와 백엔드 부분을 동시에 책임지고 있었어요. 웹 기술의 발전과 사용자의 요구에 따라, 문제없이 상호작용 인터페이스로 작업할 수 있는 새로운 솔루션이 필요했죠.</p>
<p>그래서 BackboneJs나 AngularJs를 사용한 SPA의 최초 솔루션이 나타났어요. 그것들은 서버 부하를 줄이고 상호작용을 제공함으로써 서버의 제한된 자원을 고려한 적이 없는 웹 페이지와 함께 새로운 페이지를 기다리지 않아도 됐답니다.</p>
<p>이렇게 프론트엔드와 백엔드 부분으로의 분리가 나타났어요. 순수한 프론트엔드 개발자의 역할은 더욱 필요하고 다양해졌어요. 그들은 사용자 인터페이스 생성, HTML, CSS, JavaScript와 상호작용하는 API 및 서버와 작업하는 기술을 전문화하기 시작했어요. 그 반대로 백엔드 개발자들은 데이터 처리, 응용 프로그램 비즈니스 로직, 데이터베이스와 서버 API 생성에 더 집중했어요.</p>
<p>그래서 React, Angular2, Vue 및 기타 웹 애플리케이션 개발 도구 시대로 진입했어요. 단순한 양식과 목록을 만드는 대신, js-routing, 상태 관리, 브라우저 API, 요청에 권한 토큰 바인딩, 데이터 매핑 등의 작업이 가능해졌어요.</p>
<div class="content-ad"></div>
<p>이 접근 방식의 결과로 문제점이 발생했습니다:</p>
<ul>
<li>커뮤니케이션과 조정에 대한 어려움. Api 계약 및 통신 방법 — HTTP 1.1, Websocket, GraphQL. JSON 파싱과 유효성 검사.</li>
<li>이해와 지식의 차이. 예를 들어, 여러 쿼리를 생성하는 프론트엔드 애플리케이션을 개발하고 일반적 및 최적화된 SPA로 간주할 수 있습니다. 그러나 백엔드에서는 데이터베이스 액세스가 많이 필요하고 이 데이터의 적절한 집계가 필요하므로 성능 및 유지 관리에 영향을 줄 수 있습니다.</li>
<li>작업의 중복. 대부분의 CRUD 작업은 프론트엔드에서 동일한 동작을 가졌습니다. 이제 단순히 서버에서 목록을 가져오는 것이 아니라 store()에 넣었습니다. 각 사용자 작업은 dispatch()를 통해 처리되고 요청이 실행되기를 기다리며, 그 후에 결과에 따라 reducer()를 통해 store를 업데이트합니다. — 데이터베이스에서 백엔드가 수행하는 모든 작업을 프론트엔드에서 반복합니다. (페이지 다시로드 및 서버에서 현재 상태로 SPA를 복원하는 것도 언급할 가치가 있습니다 — 현재 별도의 고통입니다)</li>
<li>디버깅 및 테스트의 어려움. 이제 가능한 통합 문제를 고려하고 응용 프로그램의 양쪽 컨텍스트에서 테스트해야 합니다. 네, 프론트엔드 애플리케이션에 대해 격리된 e2e-tests을 만들 수 있지만 제품 생산성을 보장할 수 없습니다. 네, ZoD가 서버 응답을 유효성 검사하기 위한 것이 있지만, 그 사용 비율은 얼마나 되는지요?</li>
<li>개발 시간 및 비용 증가. API 계약에 대한 변경 사항은 동시에 두 명의 사람이 필요합니다. 서버로 직접 템플릿을 변경할 수 없습니다. 변경을 원활히 수행하려면 럴리를 필요로하고, 개별 작업으로 분할되며, 비즈니스 분석 전문가 등등이 필요합니다.</li>
<li>SEO. 우리 앱은 JS를 통해 완전히 형성되므로 검색 엔진은 앱 콘텐츠와 적절히 인덱싱 및 내비게이션 할 수 없기 때문에 SSR 및 SSG 솔루션이 필요했습니다.</li>
<li>보안. 페이지에 입력된 모든 중요 데이터는 서버로 전달되기 전에 숨겨야 합니다. 또한 애플리케이션을 위해 서버로부터 많은 개인 정보를 요청해야하므로 액세스 토큰이 공개됩니다.</li>
</ul>
<h1>그래서, 왜 보통의 프론트엔드가 사라지고 있는 걸까요?</h1>
<p>어떤 리소스로 가든 공고가 얼마나 많이 열려 있는지 확인할 수 있습니다:</p>
<div class="content-ad"></div>
<ul>
<li>Python + Django</li>
<li>PHP + Laravel</li>
<li>NextJs + React</li>
<li>Nuxt + Vue</li>
</ul>
<p>이것들은 모두 서버 기반 웹 애플리케이션 개발을 위한 번들입니다. 수분화와 재개성 접근 방식 덕분에 서버는 페이지를 다시로드하지 않고 인터페이스의 수정된 부분만 렌더링할 수 있습니다.</p>
<p>그들이 제공하는 것들:</p>
<ul>
<li>이제 서버 애플리케이션은 복잡한 HTTP 또는 WS 계약이 필요하지 않으며 양쪽에서 지원해야 하는 것들을 사용하지 않아도 됩니다. gRPC와 같은 다른 서비스와의 정보 교환에 대해 더 나은 방법을 사용할 수 있게 됩니다.</li>
<li>변경 사항을 만드는 과정이 중간 승인 없이 빨라져 1명의 사람이 사용자가 바로 변화를 볼 수 있습니다.</li>
<li>테스트를 통해 애플리케이션을 종합적으로 확인할 수 있어 통합 테스트를 없애고 오류를 줄일 수 있습니다.</li>
<li>HTML 마크업만 교환하므로 모든 "요청-응답" 로직이 사용자에게 숨겨집니다.</li>
<li>SPA를 올바른 상태로 복원하기 위해 JSON으로 많은 데이터를 전달할 필요가 없습니다. 이미 준비된 템플릿을 전달할 수 있습니다.</li>
<li>페이지의 JS 코드가 최소화되므로 babel 및 기타 도구를 사용하여 브라우저 호환성에 대해 걱정할 필요가 없습니다.</li>
</ul>
<div class="content-ad"></div>
<p>노코드 솔루션의 등장, 인공지능을 활용한 템플릿 생성, 거대한 서버 자원, 그리고 SEO 요구사항으로 인해 현재는 프론트엔드 개발자 수와 도구들이 전체 애플리케이션을 개발하는 데 필요하지 않은 상황입니다.</p>
<p>사업주들은 타당한 질문을 하고 있습니다. "왜 단순한 애플리케이션을 개발하려면 순수한 프론트엔드 개발자와 백엔드 개발자를 고용해야 하죠?"</p>
<p>풀스택 개발자는 인력 비용을 절약하는 관리 쇼파로 여겨질 수 없습니다. 지금은 필수적인 존재입니다. 순수한 프론트엔드 개발자가 아니라, 데이터베이스에서 직접 간단한 작업을 수행하고 결과를 표시할 수 있는 개발자가 필요합니다.</p>
<p>그렇습니다, 복잡하거나 헤드리스 애플리케이션은 프론트엔드와 백엔드를 분리해서 사용해야 할 것입니다. 그러나 대부분의 애플리케이션은 SPA에서 멀어져가고 이미 존재했던 방식으로 나아가게 될 것입니다. 지금은 그러한 문제들에 대한 해결책이 있습니다. HTMX의 등장으로 어떤 백엔드 개발자도 기본 지식만 있으면 웹 애플리케이션을 만들 수 있습니다. 이제는 조금의 논리를 사용하여 싱글 페이지 앱을 만들 때 심지어 JS를 알 필요가 없습니다.</p>
<div class="content-ad"></div>
<p>앞단 개발자는 JS 로직 뿐만 아니라 CSS 및 적절한 선택자, HTML 및 그 의미론에도 책임이 있었는데, 이제 백엔드 개발자가 그것을 알아야 할까요? — 아니요, 이제는 인공지능 또는 "HTML 레이아웃 디자이너"가 Figma 레이아웃을 기반으로 템플릿 생성을 처리할 수 있습니다. HTML 템플릿의 로직과 상호작용은 이제 서버에서 정의됩니다.</p>
<h1>결론</h1>
<p>지금은 모든 이러한 정교한 프론트엔드 개발 도구가 실제로 필요한지, 순수한 프론트엔드 개발자로 남아야 할지를 고민할 때입니다.</p>
<p>현재의 프론트엔드 개발자들이 60% 프론트엔드, 40% 백엔드로 분할된 풀스택 자격으로 이동해야 하는 것이 바람직합니다. HTMX는 시작에 불과하며, NextJs 또는 Nuxt 도구를 향한 벡터가 성장할 것이며, Angular 유형의 프레임워크는 새로운 구현에 적응할 수 없다면 죽을 것입니다. 물론 Angular 생태계에는 이미 AnalogJs에서 프로토타입이 있습니다.</p>
<div class="content-ad"></div>
<h1>자원</h1>
<p>"프론트 엔드 개발자" 역할로 취업 정보 검색</p>
<p>"풀 스택 개발자" 역할로 취업 정보 검색</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"우리가 알고 있는 프론트엔드 개발의 종말 2024년 최신 동향 분석","description":"","date":"2024-06-22 05:20","slug":"2024-06-22-TheFront-EndDevelopmentwereusedtoisdying","content":"\n\n\n![image](/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png)\n\n# 소개\n\nSPA가 등장하기 전에 웹 애플리케이션은 일반적으로 다중 페이지로 이루어져 있었습니다. 사용자가 애플리케이션과 상호 작용할 때마다 서버가 새로운 전체 페이지를 보내고 브라우저가 다시로드하는 방식이었습니다. 사용자가 페이지 간을 이동할 때마다 완전한 페이지 재로드가 발생했고, 이로 인해 속도가 느려지고 부자연스러운 사용자 경험이 발생할 수 있었습니다. 비슷한 애플리케이션들은 주로 PHP, Ruby on Rails, ASP.NET 등과 같은 서버 측 기술을 사용하여 구축되었는데, 이들은 서버 측에서 HTML 코드를 생성하여 브라우저로 보냈습니다.\n\n![image](/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 개발자들은 만능 전문가였어요. 그들은 프론트엔드와 백엔드 부분을 동시에 책임지고 있었어요. 웹 기술의 발전과 사용자의 요구에 따라, 문제없이 상호작용 인터페이스로 작업할 수 있는 새로운 솔루션이 필요했죠.\n\n그래서 BackboneJs나 AngularJs를 사용한 SPA의 최초 솔루션이 나타났어요. 그것들은 서버 부하를 줄이고 상호작용을 제공함으로써 서버의 제한된 자원을 고려한 적이 없는 웹 페이지와 함께 새로운 페이지를 기다리지 않아도 됐답니다.\n\n이렇게 프론트엔드와 백엔드 부분으로의 분리가 나타났어요. 순수한 프론트엔드 개발자의 역할은 더욱 필요하고 다양해졌어요. 그들은 사용자 인터페이스 생성, HTML, CSS, JavaScript와 상호작용하는 API 및 서버와 작업하는 기술을 전문화하기 시작했어요. 그 반대로 백엔드 개발자들은 데이터 처리, 응용 프로그램 비즈니스 로직, 데이터베이스와 서버 API 생성에 더 집중했어요.\n\n그래서 React, Angular2, Vue 및 기타 웹 애플리케이션 개발 도구 시대로 진입했어요. 단순한 양식과 목록을 만드는 대신, js-routing, 상태 관리, 브라우저 API, 요청에 권한 토큰 바인딩, 데이터 매핑 등의 작업이 가능해졌어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 접근 방식의 결과로 문제점이 발생했습니다:\n\n- 커뮤니케이션과 조정에 대한 어려움. Api 계약 및 통신 방법 — HTTP 1.1, Websocket, GraphQL. JSON 파싱과 유효성 검사.\n- 이해와 지식의 차이. 예를 들어, 여러 쿼리를 생성하는 프론트엔드 애플리케이션을 개발하고 일반적 및 최적화된 SPA로 간주할 수 있습니다. 그러나 백엔드에서는 데이터베이스 액세스가 많이 필요하고 이 데이터의 적절한 집계가 필요하므로 성능 및 유지 관리에 영향을 줄 수 있습니다.\n- 작업의 중복. 대부분의 CRUD 작업은 프론트엔드에서 동일한 동작을 가졌습니다. 이제 단순히 서버에서 목록을 가져오는 것이 아니라 store()에 넣었습니다. 각 사용자 작업은 dispatch()를 통해 처리되고 요청이 실행되기를 기다리며, 그 후에 결과에 따라 reducer()를 통해 store를 업데이트합니다. — 데이터베이스에서 백엔드가 수행하는 모든 작업을 프론트엔드에서 반복합니다. (페이지 다시로드 및 서버에서 현재 상태로 SPA를 복원하는 것도 언급할 가치가 있습니다 — 현재 별도의 고통입니다)\n- 디버깅 및 테스트의 어려움. 이제 가능한 통합 문제를 고려하고 응용 프로그램의 양쪽 컨텍스트에서 테스트해야 합니다. 네, 프론트엔드 애플리케이션에 대해 격리된 e2e-tests을 만들 수 있지만 제품 생산성을 보장할 수 없습니다. 네, ZoD가 서버 응답을 유효성 검사하기 위한 것이 있지만, 그 사용 비율은 얼마나 되는지요?\n- 개발 시간 및 비용 증가. API 계약에 대한 변경 사항은 동시에 두 명의 사람이 필요합니다. 서버로 직접 템플릿을 변경할 수 없습니다. 변경을 원활히 수행하려면 럴리를 필요로하고, 개별 작업으로 분할되며, 비즈니스 분석 전문가 등등이 필요합니다.\n- SEO. 우리 앱은 JS를 통해 완전히 형성되므로 검색 엔진은 앱 콘텐츠와 적절히 인덱싱 및 내비게이션 할 수 없기 때문에 SSR 및 SSG 솔루션이 필요했습니다.\n- 보안. 페이지에 입력된 모든 중요 데이터는 서버로 전달되기 전에 숨겨야 합니다. 또한 애플리케이션을 위해 서버로부터 많은 개인 정보를 요청해야하므로 액세스 토큰이 공개됩니다.\n\n# 그래서, 왜 보통의 프론트엔드가 사라지고 있는 걸까요?\n\n어떤 리소스로 가든 공고가 얼마나 많이 열려 있는지 확인할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Python + Django\n- PHP + Laravel\n- NextJs + React\n- Nuxt + Vue\n\n이것들은 모두 서버 기반 웹 애플리케이션 개발을 위한 번들입니다. 수분화와 재개성 접근 방식 덕분에 서버는 페이지를 다시로드하지 않고 인터페이스의 수정된 부분만 렌더링할 수 있습니다.\n\n그들이 제공하는 것들:\n\n- 이제 서버 애플리케이션은 복잡한 HTTP 또는 WS 계약이 필요하지 않으며 양쪽에서 지원해야 하는 것들을 사용하지 않아도 됩니다. gRPC와 같은 다른 서비스와의 정보 교환에 대해 더 나은 방법을 사용할 수 있게 됩니다.\n- 변경 사항을 만드는 과정이 중간 승인 없이 빨라져 1명의 사람이 사용자가 바로 변화를 볼 수 있습니다.\n- 테스트를 통해 애플리케이션을 종합적으로 확인할 수 있어 통합 테스트를 없애고 오류를 줄일 수 있습니다.\n- HTML 마크업만 교환하므로 모든 \"요청-응답\" 로직이 사용자에게 숨겨집니다.\n- SPA를 올바른 상태로 복원하기 위해 JSON으로 많은 데이터를 전달할 필요가 없습니다. 이미 준비된 템플릿을 전달할 수 있습니다.\n- 페이지의 JS 코드가 최소화되므로 babel 및 기타 도구를 사용하여 브라우저 호환성에 대해 걱정할 필요가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노코드 솔루션의 등장, 인공지능을 활용한 템플릿 생성, 거대한 서버 자원, 그리고 SEO 요구사항으로 인해 현재는 프론트엔드 개발자 수와 도구들이 전체 애플리케이션을 개발하는 데 필요하지 않은 상황입니다.\n\n사업주들은 타당한 질문을 하고 있습니다. \"왜 단순한 애플리케이션을 개발하려면 순수한 프론트엔드 개발자와 백엔드 개발자를 고용해야 하죠?\"\n\n풀스택 개발자는 인력 비용을 절약하는 관리 쇼파로 여겨질 수 없습니다. 지금은 필수적인 존재입니다. 순수한 프론트엔드 개발자가 아니라, 데이터베이스에서 직접 간단한 작업을 수행하고 결과를 표시할 수 있는 개발자가 필요합니다.\n\n그렇습니다, 복잡하거나 헤드리스 애플리케이션은 프론트엔드와 백엔드를 분리해서 사용해야 할 것입니다. 그러나 대부분의 애플리케이션은 SPA에서 멀어져가고 이미 존재했던 방식으로 나아가게 될 것입니다. 지금은 그러한 문제들에 대한 해결책이 있습니다. HTMX의 등장으로 어떤 백엔드 개발자도 기본 지식만 있으면 웹 애플리케이션을 만들 수 있습니다. 이제는 조금의 논리를 사용하여 싱글 페이지 앱을 만들 때 심지어 JS를 알 필요가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앞단 개발자는 JS 로직 뿐만 아니라 CSS 및 적절한 선택자, HTML 및 그 의미론에도 책임이 있었는데, 이제 백엔드 개발자가 그것을 알아야 할까요? — 아니요, 이제는 인공지능 또는 \"HTML 레이아웃 디자이너\"가 Figma 레이아웃을 기반으로 템플릿 생성을 처리할 수 있습니다. HTML 템플릿의 로직과 상호작용은 이제 서버에서 정의됩니다.\n\n# 결론\n\n지금은 모든 이러한 정교한 프론트엔드 개발 도구가 실제로 필요한지, 순수한 프론트엔드 개발자로 남아야 할지를 고민할 때입니다.\n\n현재의 프론트엔드 개발자들이 60% 프론트엔드, 40% 백엔드로 분할된 풀스택 자격으로 이동해야 하는 것이 바람직합니다. HTMX는 시작에 불과하며, NextJs 또는 Nuxt 도구를 향한 벡터가 성장할 것이며, Angular 유형의 프레임워크는 새로운 구현에 적응할 수 없다면 죽을 것입니다. 물론 Angular 생태계에는 이미 AnalogJs에서 프로토타입이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자원\n\n\"프론트 엔드 개발자\" 역할로 취업 정보 검색\n\n\"풀 스택 개발자\" 역할로 취업 정보 검색","ogImage":{"url":"/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png"},"coverImage":"/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003eSPA가 등장하기 전에 웹 애플리케이션은 일반적으로 다중 페이지로 이루어져 있었습니다. 사용자가 애플리케이션과 상호 작용할 때마다 서버가 새로운 전체 페이지를 보내고 브라우저가 다시로드하는 방식이었습니다. 사용자가 페이지 간을 이동할 때마다 완전한 페이지 재로드가 발생했고, 이로 인해 속도가 느려지고 부자연스러운 사용자 경험이 발생할 수 있었습니다. 비슷한 애플리케이션들은 주로 PHP, Ruby on Rails, ASP.NET 등과 같은 서버 측 기술을 사용하여 구축되었는데, 이들은 서버 측에서 HTML 코드를 생성하여 브라우저로 보냈습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-TheFront-EndDevelopmentwereusedtoisdying_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e웹 개발자들은 만능 전문가였어요. 그들은 프론트엔드와 백엔드 부분을 동시에 책임지고 있었어요. 웹 기술의 발전과 사용자의 요구에 따라, 문제없이 상호작용 인터페이스로 작업할 수 있는 새로운 솔루션이 필요했죠.\u003c/p\u003e\n\u003cp\u003e그래서 BackboneJs나 AngularJs를 사용한 SPA의 최초 솔루션이 나타났어요. 그것들은 서버 부하를 줄이고 상호작용을 제공함으로써 서버의 제한된 자원을 고려한 적이 없는 웹 페이지와 함께 새로운 페이지를 기다리지 않아도 됐답니다.\u003c/p\u003e\n\u003cp\u003e이렇게 프론트엔드와 백엔드 부분으로의 분리가 나타났어요. 순수한 프론트엔드 개발자의 역할은 더욱 필요하고 다양해졌어요. 그들은 사용자 인터페이스 생성, HTML, CSS, JavaScript와 상호작용하는 API 및 서버와 작업하는 기술을 전문화하기 시작했어요. 그 반대로 백엔드 개발자들은 데이터 처리, 응용 프로그램 비즈니스 로직, 데이터베이스와 서버 API 생성에 더 집중했어요.\u003c/p\u003e\n\u003cp\u003e그래서 React, Angular2, Vue 및 기타 웹 애플리케이션 개발 도구 시대로 진입했어요. 단순한 양식과 목록을 만드는 대신, js-routing, 상태 관리, 브라우저 API, 요청에 권한 토큰 바인딩, 데이터 매핑 등의 작업이 가능해졌어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 접근 방식의 결과로 문제점이 발생했습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e커뮤니케이션과 조정에 대한 어려움. Api 계약 및 통신 방법 — HTTP 1.1, Websocket, GraphQL. JSON 파싱과 유효성 검사.\u003c/li\u003e\n\u003cli\u003e이해와 지식의 차이. 예를 들어, 여러 쿼리를 생성하는 프론트엔드 애플리케이션을 개발하고 일반적 및 최적화된 SPA로 간주할 수 있습니다. 그러나 백엔드에서는 데이터베이스 액세스가 많이 필요하고 이 데이터의 적절한 집계가 필요하므로 성능 및 유지 관리에 영향을 줄 수 있습니다.\u003c/li\u003e\n\u003cli\u003e작업의 중복. 대부분의 CRUD 작업은 프론트엔드에서 동일한 동작을 가졌습니다. 이제 단순히 서버에서 목록을 가져오는 것이 아니라 store()에 넣었습니다. 각 사용자 작업은 dispatch()를 통해 처리되고 요청이 실행되기를 기다리며, 그 후에 결과에 따라 reducer()를 통해 store를 업데이트합니다. — 데이터베이스에서 백엔드가 수행하는 모든 작업을 프론트엔드에서 반복합니다. (페이지 다시로드 및 서버에서 현재 상태로 SPA를 복원하는 것도 언급할 가치가 있습니다 — 현재 별도의 고통입니다)\u003c/li\u003e\n\u003cli\u003e디버깅 및 테스트의 어려움. 이제 가능한 통합 문제를 고려하고 응용 프로그램의 양쪽 컨텍스트에서 테스트해야 합니다. 네, 프론트엔드 애플리케이션에 대해 격리된 e2e-tests을 만들 수 있지만 제품 생산성을 보장할 수 없습니다. 네, ZoD가 서버 응답을 유효성 검사하기 위한 것이 있지만, 그 사용 비율은 얼마나 되는지요?\u003c/li\u003e\n\u003cli\u003e개발 시간 및 비용 증가. API 계약에 대한 변경 사항은 동시에 두 명의 사람이 필요합니다. 서버로 직접 템플릿을 변경할 수 없습니다. 변경을 원활히 수행하려면 럴리를 필요로하고, 개별 작업으로 분할되며, 비즈니스 분석 전문가 등등이 필요합니다.\u003c/li\u003e\n\u003cli\u003eSEO. 우리 앱은 JS를 통해 완전히 형성되므로 검색 엔진은 앱 콘텐츠와 적절히 인덱싱 및 내비게이션 할 수 없기 때문에 SSR 및 SSG 솔루션이 필요했습니다.\u003c/li\u003e\n\u003cli\u003e보안. 페이지에 입력된 모든 중요 데이터는 서버로 전달되기 전에 숨겨야 합니다. 또한 애플리케이션을 위해 서버로부터 많은 개인 정보를 요청해야하므로 액세스 토큰이 공개됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e그래서, 왜 보통의 프론트엔드가 사라지고 있는 걸까요?\u003c/h1\u003e\n\u003cp\u003e어떤 리소스로 가든 공고가 얼마나 많이 열려 있는지 확인할 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003ePython + Django\u003c/li\u003e\n\u003cli\u003ePHP + Laravel\u003c/li\u003e\n\u003cli\u003eNextJs + React\u003c/li\u003e\n\u003cli\u003eNuxt + Vue\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이것들은 모두 서버 기반 웹 애플리케이션 개발을 위한 번들입니다. 수분화와 재개성 접근 방식 덕분에 서버는 페이지를 다시로드하지 않고 인터페이스의 수정된 부분만 렌더링할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그들이 제공하는 것들:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이제 서버 애플리케이션은 복잡한 HTTP 또는 WS 계약이 필요하지 않으며 양쪽에서 지원해야 하는 것들을 사용하지 않아도 됩니다. gRPC와 같은 다른 서비스와의 정보 교환에 대해 더 나은 방법을 사용할 수 있게 됩니다.\u003c/li\u003e\n\u003cli\u003e변경 사항을 만드는 과정이 중간 승인 없이 빨라져 1명의 사람이 사용자가 바로 변화를 볼 수 있습니다.\u003c/li\u003e\n\u003cli\u003e테스트를 통해 애플리케이션을 종합적으로 확인할 수 있어 통합 테스트를 없애고 오류를 줄일 수 있습니다.\u003c/li\u003e\n\u003cli\u003eHTML 마크업만 교환하므로 모든 \"요청-응답\" 로직이 사용자에게 숨겨집니다.\u003c/li\u003e\n\u003cli\u003eSPA를 올바른 상태로 복원하기 위해 JSON으로 많은 데이터를 전달할 필요가 없습니다. 이미 준비된 템플릿을 전달할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e페이지의 JS 코드가 최소화되므로 babel 및 기타 도구를 사용하여 브라우저 호환성에 대해 걱정할 필요가 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e노코드 솔루션의 등장, 인공지능을 활용한 템플릿 생성, 거대한 서버 자원, 그리고 SEO 요구사항으로 인해 현재는 프론트엔드 개발자 수와 도구들이 전체 애플리케이션을 개발하는 데 필요하지 않은 상황입니다.\u003c/p\u003e\n\u003cp\u003e사업주들은 타당한 질문을 하고 있습니다. \"왜 단순한 애플리케이션을 개발하려면 순수한 프론트엔드 개발자와 백엔드 개발자를 고용해야 하죠?\"\u003c/p\u003e\n\u003cp\u003e풀스택 개발자는 인력 비용을 절약하는 관리 쇼파로 여겨질 수 없습니다. 지금은 필수적인 존재입니다. 순수한 프론트엔드 개발자가 아니라, 데이터베이스에서 직접 간단한 작업을 수행하고 결과를 표시할 수 있는 개발자가 필요합니다.\u003c/p\u003e\n\u003cp\u003e그렇습니다, 복잡하거나 헤드리스 애플리케이션은 프론트엔드와 백엔드를 분리해서 사용해야 할 것입니다. 그러나 대부분의 애플리케이션은 SPA에서 멀어져가고 이미 존재했던 방식으로 나아가게 될 것입니다. 지금은 그러한 문제들에 대한 해결책이 있습니다. HTMX의 등장으로 어떤 백엔드 개발자도 기본 지식만 있으면 웹 애플리케이션을 만들 수 있습니다. 이제는 조금의 논리를 사용하여 싱글 페이지 앱을 만들 때 심지어 JS를 알 필요가 없습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e앞단 개발자는 JS 로직 뿐만 아니라 CSS 및 적절한 선택자, HTML 및 그 의미론에도 책임이 있었는데, 이제 백엔드 개발자가 그것을 알아야 할까요? — 아니요, 이제는 인공지능 또는 \"HTML 레이아웃 디자이너\"가 Figma 레이아웃을 기반으로 템플릿 생성을 처리할 수 있습니다. HTML 템플릿의 로직과 상호작용은 이제 서버에서 정의됩니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e지금은 모든 이러한 정교한 프론트엔드 개발 도구가 실제로 필요한지, 순수한 프론트엔드 개발자로 남아야 할지를 고민할 때입니다.\u003c/p\u003e\n\u003cp\u003e현재의 프론트엔드 개발자들이 60% 프론트엔드, 40% 백엔드로 분할된 풀스택 자격으로 이동해야 하는 것이 바람직합니다. HTMX는 시작에 불과하며, NextJs 또는 Nuxt 도구를 향한 벡터가 성장할 것이며, Angular 유형의 프레임워크는 새로운 구현에 적응할 수 없다면 죽을 것입니다. 물론 Angular 생태계에는 이미 AnalogJs에서 프로토타입이 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e자원\u003c/h1\u003e\n\u003cp\u003e\"프론트 엔드 개발자\" 역할로 취업 정보 검색\u003c/p\u003e\n\u003cp\u003e\"풀 스택 개발자\" 역할로 취업 정보 검색\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-TheFront-EndDevelopmentwereusedtoisdying"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>