<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>PostgreSQL 쿼리를 최적화하는 방법  | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-HowtoOptimizePostgreSQLQueries" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="PostgreSQL 쿼리를 최적화하는 방법  | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="PostgreSQL 쿼리를 최적화하는 방법  | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-HowtoOptimizePostgreSQLQueries_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-HowtoOptimizePostgreSQLQueries" data-gatsby-head="true"/><meta name="twitter:title" content="PostgreSQL 쿼리를 최적화하는 방법  | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-HowtoOptimizePostgreSQLQueries_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 13:57" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">PostgreSQL 쿼리를 최적화하는 방법 </h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="PostgreSQL 쿼리를 최적화하는 방법 " loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-HowtoOptimizePostgreSQLQueries&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>PostgreSQL은 강력하고 높은 사용자 정의 가능성을 가진 오픈 소스 관계형 데이터베이스 관리 시스템입니다. PostgreSQL은 높은 효율성을 갖도록 설계되었지만, 쿼리 성능을 최적화하여 개선할 수 있습니다. PostgreSQL 쿼리를 최적화하는 몇 가지 팁은 다음과 같습니다:</p>
<h2>1. 인덱스 사용</h2>
<p>이메일로 사용자를 자주 검색하는 경우, “users”라는 테이블이 있고 “id”, “name”, “email” 열이 있다고 가정해보겠습니다. 이 경우 “email” 열에 인덱스를 생성할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">CREATE</span> <span class="hljs-variable constant_">INDEX</span> users_email_idx <span class="hljs-variable constant_">ON</span> users (email);
</code></pre>
<h2>2. Use EXPLAIN</h2>
<p>Suppose you have a query that joins two tables and returns the total number of rows:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">EXPLAIN</span> <span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">COUNT</span>(*) <span class="hljs-variable constant_">FROM</span> table1 <span class="hljs-variable constant_">JOIN</span> table2 <span class="hljs-variable constant_">ON</span> table1.<span class="hljs-property">id</span> = table2.<span class="hljs-property">table1_id</span>;
</code></pre>
<p>EXPLAIN 명령은 쿼리의 실행 계획을 출력하여 성능 문제를 식별하는 데 도움이 됩니다.</p>
<h2>3. 와일드카드 문자 사용을 피하세요</h2>
<p>예를 들어 email 주소가 "@example.com"으로 끝나는 모든 사용자를 검색하는 쿼리가 있다고 가정해봅시다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> users <span class="hljs-variable constant_">WHERE</span> email <span class="hljs-variable constant_">LIKE</span> <span class="hljs-string">'%@example.com'</span>;
</code></pre>
<p>이 쿼리는 "users" 테이블 전체를 순차적으로 스캔하여 실행되며, 테이블이 크다면 느릴 수 있습니다. 이 쿼리를 최적화하려면 다음과 같이 다시 작성할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> users <span class="hljs-variable constant_">WHERE</span> email <span class="hljs-variable constant_">LIKE</span> <span class="hljs-string">'@example.com%'</span>;
</code></pre>
<p>이 쿼리는 1단계에서 생성된 인덱스를 사용하고 훨씬 더 빠른 인덱스 스캔을 수행할 것입니다.</p>
<h2>4. 반환된 행의 수 제한:</h2>
<p>"users" 테이블에서 모든 사용자를 반환하는 쿼리가 있다고 가정해보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> users;
</code></pre>
<p>이 쿼리는 테이블이 큰 경우 느리고 자원을 많이 사용할 수 있습니다. 이 쿼리를 최적화하려면 LIMIT 절을 사용하여 반환되는 행 수를 제한할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> users <span class="hljs-variable constant_">LIMIT</span> <span class="hljs-number">100</span>;
</code></pre>
<p>이 쿼리는 성능을 향상시킬 수 있도록 처음 100개의 행만 반환합니다.</p>
<h2>5. 적절한 데이터 유형 사용:</h2>
<p>만일 "users" 테이블에 사용자의 나이를 정수로 저장하는 "age"라는 열이 있다고 가정해보겠습니다. 사용자의 평균 연령을 자주 계산한다면 "integer" 대신 "smallint"와 같은 더 작은 데이터 유형을 사용하여 성능을 최적화할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">ALTER</span> <span class="hljs-variable constant_">TABLE</span> users <span class="hljs-variable constant_">ALTER</span> <span class="hljs-variable constant_">COLUMN</span> age <span class="hljs-variable constant_">TYPE</span> smallint;
</code></pre>
<p>표 태그를 마크다운 형식으로 변경하면 메모리 사용량을 줄일 수 있어 성능을 향상시킬 수 있어요.</p>
<h2>6. 서브쿼리 최적화</h2>
<p>특정 도시에 거주하는 고객에 대한 모든 주문을 검색하는 쿼리가 있다고 가정해보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> orders <span class="hljs-variable constant_">WHERE</span> customer_id <span class="hljs-variable constant_">IN</span> (<span class="hljs-variable constant_">SELECT</span> id <span class="hljs-variable constant_">FROM</span> customers <span class="hljs-variable constant_">WHERE</span> city = <span class="hljs-string">'뉴욕'</span>);
</code></pre>
<p>이 쿼리는 뉴욕에 거주하는 고객들의 고객 ID를 검색하기 위해 서브쿼리를 사용합니다. 이 쿼리를 최적화하기 위해 JOIN으로 다시 작성할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> orders.* <span class="hljs-variable constant_">FROM</span> orders <span class="hljs-variable constant_">JOIN</span> customers <span class="hljs-variable constant_">ON</span> orders.<span class="hljs-property">customer_id</span> = customers.<span class="hljs-property">id</span> <span class="hljs-variable constant_">WHERE</span> customers.<span class="hljs-property">city</span> = <span class="hljs-string">'New York'</span>;
</code></pre>
<p>이 쿼리는 서브쿼리 대신 JOIN을 수행하며, "orders" 테이블에 많은 행이 있는 경우 더 빠를 수 있습니다.</p>
<h2>7. 준비된 문을 사용하세요</h2>
<p>특정 이름을 가진 모든 사용자를 검색하는 쿼리가 있다고 가정해봅시다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> users <span class="hljs-variable constant_">WHERE</span> name = <span class="hljs-string">'John'</span>;
</code></pre>
<p>여러 번 다른 이름으로 이 쿼리를 실행한다면, 준비된 문을 사용하여 성능을 개선할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">PREPARE</span> get_users_by_name (text) <span class="hljs-variable constant_">AS</span> <span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> users <span class="hljs-variable constant_">WHERE</span> name = $1;
<span class="hljs-variable constant_">EXECUTE</span> <span class="hljs-title function_">get_users_by_name</span>(<span class="hljs-string">'John'</span>);
<span class="hljs-variable constant_">EXECUTE</span> <span class="hljs-title function_">get_users_by_name</span>(<span class="hljs-string">'Jane'</span>);
</code></pre>
<p>이렇게 하면 각 후속 실행에 대해 쿼리를 준비하고 실행 계획을 재사용할 수 있어 성능을 향상시킬 수 있습니다.</p>
<p>제가 언급한 옵션을 사용하여 PostgreSQL 쿼리를 최적화하는 방법을 명확하게 설명하는 데 도움이 되기를 바랍니다!</p>
<h2>8. 연결 풀 사용</h2>
<p>연결 풀을 사용하면 데이터베이스 연결을 생성하고 해제하는 오버헤드를 줄여 성능을 향상시킬 수 있습니다.</p>
<p>커넥션 풀링은 각 데이터베이스 요청마다 새로운 연결을 생성하고 해제하는 대신 데이터베이스 연결 풀을 관리하는 기술입니다. 기존 연결을 재사용함으로써 커넥션 풀링은 새로운 연결을 맺는 데 필요한 오버헤드를 줄일 수 있어 PostgreSQL 쿼리의 성능을 향상시킬 수 있습니다.</p>
<p>다음은 PostgreSQL에서 커넥션 풀링을 사용하는 예시입니다:</p>
<ul>
<li>커넥션 풀링 라이브러리 설치: PostgreSQL용 여러 커넥션 풀링 라이브러리가 있습니다. pgBouncer, pgpool-II, 그리고 Pgpool 등이 있습니다. 요구 사항에 가장 적합한 라이브러리를 선택하고 서버에 설치합니다.</li>
<li>커넥션 풀 구성: 데이터베이스에 대한 최대 연결 수와 최대 휴대 중인 연결 수를 지정하도록 커넥션 풀을 구성합니다. 또한 일정 시간 후 휴대 중인 연결을 자동으로 닫도록 풀을 구성할 수도 있습니다.</li>
<li>응용 프로그램 코드 수정: 응용 프로그램 코드를 수정하여 각 데이터베이스 요청마다 새로운 연결을 생성하는 대신에 커넥션 풀을 사용하도록 수정합니다. 선택한 커넥션 풀 라이브러리에 따라 연결 문자열이나 데이터베이스 URL을 수정해야 할 수도 있습니다.</li>
</ul>
<p>다음은 pgBouncer를 사용한 커넥션 풀링 사용 예시입니다:</p>
<ul>
<li>pgBouncer 설치: 패키지 관리자를 사용하거나 소스에서 컴파일하여 서버에 pgBouncer를 설치합니다.</li>
<li>연결 풀 구성: pgBouncer 구성 파일을 편집하여 데이터베이스에 대한 연결 최대 수와 최대 휴식 연결 수를 지정합니다. 또한 일정 시간이 지난 후 자동으로 휴식 연결을 닫도록 pgBouncer를 구성할 수 있습니다.</li>
<li>응용 프로그램 코드 수정: 응용 프로그램 코드를 수정하여 기본 PostgreSQL 연결 문자열 대신 pgBouncer 연결 문자열을 사용하도록 합니다. 다음은 PostgreSQL 연결 문자열의 예시입니다:</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-attr">postgres</span>:<span class="hljs-comment">//username:password@hostname:port/database</span>
</code></pre>
<p>다음은 pgBouncer 연결 문자열의 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">postgres</span>:<span class="hljs-comment">//username:password@hostname:6432/database</span>
</code></pre>
<p>포트 번호가 다르고 호스트 이름이 PostgreSQL 서버가 아닌 pgBouncer 서버를 가리키는 것을 유의해 주세요.</p>
<p>pgBouncer와 같은 커넥션 풀을 사용하면 데이터베이스 연결을 생성하고 해제하는 오버헤드를 줄일 수 있어 PostgreSQL 쿼리의 성능을 향상시킬 수 있습니다.</p>
<h2>9. 테이블 분석 및 VACUUM</h2>
<p>분석과 VACUUM은 데이터베이스 통계를 업데이트하고 디스크 공간을 회수하여 PostgreSQL 쿼리의 성능을 향상시킬 수 있는 두 가지 중요한 유지 관리 작업입니다. 각 작업에 대한 간단한 설명은 다음과 같습니다:</p>
<ul>
<li>분석: 테이블에 인덱스를 생성하거나 데이터를 필터링하거나 정렬하는 쿼리를 실행할 때, PostgreSQL은 통계를 사용하여 조건과 일치하는 행 수를 추정합니다. 데이터베이스 통계에는 데이터의 분포에 대한 정보가 포함되어 있습니다. 즉, 고유한 값의 수 및 각 값의 빈도가 포함됩니다. 이러한 통계는 pg_statistic이라는 시스템 카탈로그에 저장됩니다. 통계가 오래되거나 부정확할 경우, 쿼리 플래너가 잘못된 결정을 내리고 효율적이지 않은 쿼리 계획을 생성할 수 있습니다.</li>
</ul>
<p>통계를 업데이트하려면 테이블이나 전체 데이터베이스에 ANALYZE 명령을 실행할 수 있습니다. ANALYZE는 테이블을 스캔하고 pg_statistic에서 통계를 업데이트합니다. 대규모 테이블의 경우, 이 작업은 상당한 시간이 소요될 수 있지만, 이는 일회성 비용이며 혜택이 상당할 수 있습니다.</p>
<ul>
<li>박강작업: 테이블에 행을 삽입, 업데이트 또는 삭제할 때, PostgreSQL은 이전 행이 사용한 디스크 공간을 즉시 해제하지 않습니다. 대신, 해당 공간을 재사용 가능하다고 표시하고 새 행이 그 공간을 채울 때까지 기다립니다. 이를 "불필요한" 공간이라고 하며 시간이 지남에 따라 축적되어 단편화와 성능 저하로 이어질 수 있습니다. 박강작업은 불필요한 공간을 회수하여 운영 체제가 다시 사용할 수 있도록 하는 과정입니다.</li>
</ul>
<p>PostgreSQL에서 테이블을 박강하는 여러 옵션이 있습니다. 가장 간단한 옵션은 VACUUM 명령을 실행하는 것으로, 전체 테이블을 스캔하고 불필요한 공간을 제거합니다. 다른 옵션은 VACUUM ANALYZE 명령을 실행하는 것으로, 분석과 박강 작업의 혜택을 결합한 명령입니다.</p>
<p>이제 PostgreSQL에서 테이블을 분석하고 VACUUM하는 방법을 알아볼게요:</p>
<pre><code class="hljs language-js">-- 테이블 분석하기
<span class="hljs-variable constant_">ANALYZE</span> mytable;

-- 테이블 <span class="hljs-variable constant_">VACUUM</span>하기
<span class="hljs-variable constant_">VACUUM</span> mytable;
</code></pre>
<p>정기적으로 테이블을 분석하고 VACUUM하면 데이터베이스 통계가 최신 상태를 유지하고 디스크 공간을 효율적으로 사용할 수 있어요. 이는 PostgreSQL 쿼리의 성능을 향상시키고 더 나은 쿼리 계획을 생성하며 데이터를 읽고 쓰기 위해 필요한 디스크 I/O 양을 줄이는 데 도움이 될 수 있어요.</p>
<p>이 글에 대한 궁금한 점이나 피드백이 있으면 언제든지 댓글을 남겨주세요.
읽어주셔서 감사합니다. 함께 NodeTeam에 참여해보세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"PostgreSQL 쿼리를 최적화하는 방법 ","description":"","date":"2024-06-22 13:57","slug":"2024-06-22-HowtoOptimizePostgreSQLQueries","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-HowtoOptimizePostgreSQLQueries_0.png\" /\u003e\n\nPostgreSQL은 강력하고 높은 사용자 정의 가능성을 가진 오픈 소스 관계형 데이터베이스 관리 시스템입니다. PostgreSQL은 높은 효율성을 갖도록 설계되었지만, 쿼리 성능을 최적화하여 개선할 수 있습니다. PostgreSQL 쿼리를 최적화하는 몇 가지 팁은 다음과 같습니다:\n\n## 1. 인덱스 사용\n\n이메일로 사용자를 자주 검색하는 경우, “users”라는 테이블이 있고 “id”, “name”, “email” 열이 있다고 가정해보겠습니다. 이 경우 “email” 열에 인덱스를 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nCREATE INDEX users_email_idx ON users (email);\n```\n\n## 2. Use EXPLAIN\n\nSuppose you have a query that joins two tables and returns the total number of rows:\n\n```js\nEXPLAIN SELECT COUNT(*) FROM table1 JOIN table2 ON table1.id = table2.table1_id;\n```  \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEXPLAIN 명령은 쿼리의 실행 계획을 출력하여 성능 문제를 식별하는 데 도움이 됩니다.\n\n## 3. 와일드카드 문자 사용을 피하세요\n\n예를 들어 email 주소가 \"@example.com\"으로 끝나는 모든 사용자를 검색하는 쿼리가 있다고 가정해봅시다:\n\n```js\nSELECT * FROM users WHERE email LIKE '%@example.com';\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 쿼리는 \"users\" 테이블 전체를 순차적으로 스캔하여 실행되며, 테이블이 크다면 느릴 수 있습니다. 이 쿼리를 최적화하려면 다음과 같이 다시 작성할 수 있습니다:\n\n```js\nSELECT * FROM users WHERE email LIKE '@example.com%';\n```\n\n이 쿼리는 1단계에서 생성된 인덱스를 사용하고 훨씬 더 빠른 인덱스 스캔을 수행할 것입니다.\n\n## 4. 반환된 행의 수 제한:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"users\" 테이블에서 모든 사용자를 반환하는 쿼리가 있다고 가정해보세요:\n\n```js\nSELECT * FROM users;\n```\n\n이 쿼리는 테이블이 큰 경우 느리고 자원을 많이 사용할 수 있습니다. 이 쿼리를 최적화하려면 LIMIT 절을 사용하여 반환되는 행 수를 제한할 수 있습니다:\n\n```js\nSELECT * FROM users LIMIT 100;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 쿼리는 성능을 향상시킬 수 있도록 처음 100개의 행만 반환합니다.\n\n## 5. 적절한 데이터 유형 사용:\n\n만일 \"users\" 테이블에 사용자의 나이를 정수로 저장하는 \"age\"라는 열이 있다고 가정해보겠습니다. 사용자의 평균 연령을 자주 계산한다면 \"integer\" 대신 \"smallint\"와 같은 더 작은 데이터 유형을 사용하여 성능을 최적화할 수 있습니다:\n\n```js\nALTER TABLE users ALTER COLUMN age TYPE smallint;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표 태그를 마크다운 형식으로 변경하면 메모리 사용량을 줄일 수 있어 성능을 향상시킬 수 있어요.\n\n## 6. 서브쿼리 최적화\n\n특정 도시에 거주하는 고객에 대한 모든 주문을 검색하는 쿼리가 있다고 가정해보세요:\n\n```js\nSELECT * FROM orders WHERE customer_id IN (SELECT id FROM customers WHERE city = '뉴욕');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 쿼리는 뉴욕에 거주하는 고객들의 고객 ID를 검색하기 위해 서브쿼리를 사용합니다. 이 쿼리를 최적화하기 위해 JOIN으로 다시 작성할 수 있습니다:\n\n```js\nSELECT orders.* FROM orders JOIN customers ON orders.customer_id = customers.id WHERE customers.city = 'New York';\n```\n\n이 쿼리는 서브쿼리 대신 JOIN을 수행하며, \"orders\" 테이블에 많은 행이 있는 경우 더 빠를 수 있습니다.\n\n## 7. 준비된 문을 사용하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 이름을 가진 모든 사용자를 검색하는 쿼리가 있다고 가정해봅시다:\n\n```js\nSELECT * FROM users WHERE name = 'John';\n```\n\n여러 번 다른 이름으로 이 쿼리를 실행한다면, 준비된 문을 사용하여 성능을 개선할 수 있습니다:\n\n```js\nPREPARE get_users_by_name (text) AS SELECT * FROM users WHERE name = $1;\nEXECUTE get_users_by_name('John');\nEXECUTE get_users_by_name('Jane');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 각 후속 실행에 대해 쿼리를 준비하고 실행 계획을 재사용할 수 있어 성능을 향상시킬 수 있습니다.\n\n제가 언급한 옵션을 사용하여 PostgreSQL 쿼리를 최적화하는 방법을 명확하게 설명하는 데 도움이 되기를 바랍니다!\n\n## 8. 연결 풀 사용\n\n연결 풀을 사용하면 데이터베이스 연결을 생성하고 해제하는 오버헤드를 줄여 성능을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n커넥션 풀링은 각 데이터베이스 요청마다 새로운 연결을 생성하고 해제하는 대신 데이터베이스 연결 풀을 관리하는 기술입니다. 기존 연결을 재사용함으로써 커넥션 풀링은 새로운 연결을 맺는 데 필요한 오버헤드를 줄일 수 있어 PostgreSQL 쿼리의 성능을 향상시킬 수 있습니다.\n\n다음은 PostgreSQL에서 커넥션 풀링을 사용하는 예시입니다:\n\n- 커넥션 풀링 라이브러리 설치: PostgreSQL용 여러 커넥션 풀링 라이브러리가 있습니다. pgBouncer, pgpool-II, 그리고 Pgpool 등이 있습니다. 요구 사항에 가장 적합한 라이브러리를 선택하고 서버에 설치합니다.\n- 커넥션 풀 구성: 데이터베이스에 대한 최대 연결 수와 최대 휴대 중인 연결 수를 지정하도록 커넥션 풀을 구성합니다. 또한 일정 시간 후 휴대 중인 연결을 자동으로 닫도록 풀을 구성할 수도 있습니다.\n- 응용 프로그램 코드 수정: 응용 프로그램 코드를 수정하여 각 데이터베이스 요청마다 새로운 연결을 생성하는 대신에 커넥션 풀을 사용하도록 수정합니다. 선택한 커넥션 풀 라이브러리에 따라 연결 문자열이나 데이터베이스 URL을 수정해야 할 수도 있습니다.\n\n다음은 pgBouncer를 사용한 커넥션 풀링 사용 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- pgBouncer 설치: 패키지 관리자를 사용하거나 소스에서 컴파일하여 서버에 pgBouncer를 설치합니다.\n- 연결 풀 구성: pgBouncer 구성 파일을 편집하여 데이터베이스에 대한 연결 최대 수와 최대 휴식 연결 수를 지정합니다. 또한 일정 시간이 지난 후 자동으로 휴식 연결을 닫도록 pgBouncer를 구성할 수 있습니다.\n- 응용 프로그램 코드 수정: 응용 프로그램 코드를 수정하여 기본 PostgreSQL 연결 문자열 대신 pgBouncer 연결 문자열을 사용하도록 합니다. 다음은 PostgreSQL 연결 문자열의 예시입니다:\n\n```js\npostgres://username:password@hostname:port/database\n```\n\n다음은 pgBouncer 연결 문자열의 예시입니다:\n\n```js\npostgres://username:password@hostname:6432/database\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포트 번호가 다르고 호스트 이름이 PostgreSQL 서버가 아닌 pgBouncer 서버를 가리키는 것을 유의해 주세요.\n\npgBouncer와 같은 커넥션 풀을 사용하면 데이터베이스 연결을 생성하고 해제하는 오버헤드를 줄일 수 있어 PostgreSQL 쿼리의 성능을 향상시킬 수 있습니다.\n\n## 9. 테이블 분석 및 VACUUM\n\n분석과 VACUUM은 데이터베이스 통계를 업데이트하고 디스크 공간을 회수하여 PostgreSQL 쿼리의 성능을 향상시킬 수 있는 두 가지 중요한 유지 관리 작업입니다. 각 작업에 대한 간단한 설명은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 분석: 테이블에 인덱스를 생성하거나 데이터를 필터링하거나 정렬하는 쿼리를 실행할 때, PostgreSQL은 통계를 사용하여 조건과 일치하는 행 수를 추정합니다. 데이터베이스 통계에는 데이터의 분포에 대한 정보가 포함되어 있습니다. 즉, 고유한 값의 수 및 각 값의 빈도가 포함됩니다. 이러한 통계는 pg_statistic이라는 시스템 카탈로그에 저장됩니다. 통계가 오래되거나 부정확할 경우, 쿼리 플래너가 잘못된 결정을 내리고 효율적이지 않은 쿼리 계획을 생성할 수 있습니다.\n\n통계를 업데이트하려면 테이블이나 전체 데이터베이스에 ANALYZE 명령을 실행할 수 있습니다. ANALYZE는 테이블을 스캔하고 pg_statistic에서 통계를 업데이트합니다. 대규모 테이블의 경우, 이 작업은 상당한 시간이 소요될 수 있지만, 이는 일회성 비용이며 혜택이 상당할 수 있습니다.\n\n- 박강작업: 테이블에 행을 삽입, 업데이트 또는 삭제할 때, PostgreSQL은 이전 행이 사용한 디스크 공간을 즉시 해제하지 않습니다. 대신, 해당 공간을 재사용 가능하다고 표시하고 새 행이 그 공간을 채울 때까지 기다립니다. 이를 \"불필요한\" 공간이라고 하며 시간이 지남에 따라 축적되어 단편화와 성능 저하로 이어질 수 있습니다. 박강작업은 불필요한 공간을 회수하여 운영 체제가 다시 사용할 수 있도록 하는 과정입니다.\n\nPostgreSQL에서 테이블을 박강하는 여러 옵션이 있습니다. 가장 간단한 옵션은 VACUUM 명령을 실행하는 것으로, 전체 테이블을 스캔하고 불필요한 공간을 제거합니다. 다른 옵션은 VACUUM ANALYZE 명령을 실행하는 것으로, 분석과 박강 작업의 혜택을 결합한 명령입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 PostgreSQL에서 테이블을 분석하고 VACUUM하는 방법을 알아볼게요:\n\n```js\n-- 테이블 분석하기\nANALYZE mytable;\n\n-- 테이블 VACUUM하기\nVACUUM mytable;\n```\n\n정기적으로 테이블을 분석하고 VACUUM하면 데이터베이스 통계가 최신 상태를 유지하고 디스크 공간을 효율적으로 사용할 수 있어요. 이는 PostgreSQL 쿼리의 성능을 향상시키고 더 나은 쿼리 계획을 생성하며 데이터를 읽고 쓰기 위해 필요한 디스크 I/O 양을 줄이는 데 도움이 될 수 있어요.\n\n이 글에 대한 궁금한 점이나 피드백이 있으면 언제든지 댓글을 남겨주세요.\n읽어주셔서 감사합니다. 함께 NodeTeam에 참여해보세요!","ogImage":{"url":"/assets/img/2024-06-22-HowtoOptimizePostgreSQLQueries_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoOptimizePostgreSQLQueries_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003ePostgreSQL은 강력하고 높은 사용자 정의 가능성을 가진 오픈 소스 관계형 데이터베이스 관리 시스템입니다. PostgreSQL은 높은 효율성을 갖도록 설계되었지만, 쿼리 성능을 최적화하여 개선할 수 있습니다. PostgreSQL 쿼리를 최적화하는 몇 가지 팁은 다음과 같습니다:\u003c/p\u003e\n\u003ch2\u003e1. 인덱스 사용\u003c/h2\u003e\n\u003cp\u003e이메일로 사용자를 자주 검색하는 경우, “users”라는 테이블이 있고 “id”, “name”, “email” 열이 있다고 가정해보겠습니다. 이 경우 “email” 열에 인덱스를 생성할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINDEX\u003c/span\u003e users_email_idx \u003cspan class=\"hljs-variable constant_\"\u003eON\u003c/span\u003e users (email);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e2. Use EXPLAIN\u003c/h2\u003e\n\u003cp\u003eSuppose you have a query that joins two tables and returns the total number of rows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eEXPLAIN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eCOUNT\u003c/span\u003e(*) \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e table1 \u003cspan class=\"hljs-variable constant_\"\u003eJOIN\u003c/span\u003e table2 \u003cspan class=\"hljs-variable constant_\"\u003eON\u003c/span\u003e table1.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e = table2.\u003cspan class=\"hljs-property\"\u003etable1_id\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEXPLAIN 명령은 쿼리의 실행 계획을 출력하여 성능 문제를 식별하는 데 도움이 됩니다.\u003c/p\u003e\n\u003ch2\u003e3. 와일드카드 문자 사용을 피하세요\u003c/h2\u003e\n\u003cp\u003e예를 들어 email 주소가 \"@example.com\"으로 끝나는 모든 사용자를 검색하는 쿼리가 있다고 가정해봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e * \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e users \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e email \u003cspan class=\"hljs-variable constant_\"\u003eLIKE\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'%@example.com'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 쿼리는 \"users\" 테이블 전체를 순차적으로 스캔하여 실행되며, 테이블이 크다면 느릴 수 있습니다. 이 쿼리를 최적화하려면 다음과 같이 다시 작성할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e * \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e users \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e email \u003cspan class=\"hljs-variable constant_\"\u003eLIKE\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@example.com%'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 쿼리는 1단계에서 생성된 인덱스를 사용하고 훨씬 더 빠른 인덱스 스캔을 수행할 것입니다.\u003c/p\u003e\n\u003ch2\u003e4. 반환된 행의 수 제한:\u003c/h2\u003e\n\u003cp\u003e\"users\" 테이블에서 모든 사용자를 반환하는 쿼리가 있다고 가정해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e * \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e users;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 쿼리는 테이블이 큰 경우 느리고 자원을 많이 사용할 수 있습니다. 이 쿼리를 최적화하려면 LIMIT 절을 사용하여 반환되는 행 수를 제한할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e * \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e users \u003cspan class=\"hljs-variable constant_\"\u003eLIMIT\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 쿼리는 성능을 향상시킬 수 있도록 처음 100개의 행만 반환합니다.\u003c/p\u003e\n\u003ch2\u003e5. 적절한 데이터 유형 사용:\u003c/h2\u003e\n\u003cp\u003e만일 \"users\" 테이블에 사용자의 나이를 정수로 저장하는 \"age\"라는 열이 있다고 가정해보겠습니다. 사용자의 평균 연령을 자주 계산한다면 \"integer\" 대신 \"smallint\"와 같은 더 작은 데이터 유형을 사용하여 성능을 최적화할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eALTER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTABLE\u003c/span\u003e users \u003cspan class=\"hljs-variable constant_\"\u003eALTER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCOLUMN\u003c/span\u003e age \u003cspan class=\"hljs-variable constant_\"\u003eTYPE\u003c/span\u003e smallint;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e표 태그를 마크다운 형식으로 변경하면 메모리 사용량을 줄일 수 있어 성능을 향상시킬 수 있어요.\u003c/p\u003e\n\u003ch2\u003e6. 서브쿼리 최적화\u003c/h2\u003e\n\u003cp\u003e특정 도시에 거주하는 고객에 대한 모든 주문을 검색하는 쿼리가 있다고 가정해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e * \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e orders \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e customer_id \u003cspan class=\"hljs-variable constant_\"\u003eIN\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e id \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e customers \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e city = \u003cspan class=\"hljs-string\"\u003e'뉴욕'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 쿼리는 뉴욕에 거주하는 고객들의 고객 ID를 검색하기 위해 서브쿼리를 사용합니다. 이 쿼리를 최적화하기 위해 JOIN으로 다시 작성할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e orders.* \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e orders \u003cspan class=\"hljs-variable constant_\"\u003eJOIN\u003c/span\u003e customers \u003cspan class=\"hljs-variable constant_\"\u003eON\u003c/span\u003e orders.\u003cspan class=\"hljs-property\"\u003ecustomer_id\u003c/span\u003e = customers.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e customers.\u003cspan class=\"hljs-property\"\u003ecity\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'New York'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 쿼리는 서브쿼리 대신 JOIN을 수행하며, \"orders\" 테이블에 많은 행이 있는 경우 더 빠를 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e7. 준비된 문을 사용하세요\u003c/h2\u003e\n\u003cp\u003e특정 이름을 가진 모든 사용자를 검색하는 쿼리가 있다고 가정해봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e * \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e users \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e'John'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여러 번 다른 이름으로 이 쿼리를 실행한다면, 준비된 문을 사용하여 성능을 개선할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003ePREPARE\u003c/span\u003e get_users_by_name (text) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e * \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e users \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e name = $1;\n\u003cspan class=\"hljs-variable constant_\"\u003eEXECUTE\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_users_by_name\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'John'\u003c/span\u003e);\n\u003cspan class=\"hljs-variable constant_\"\u003eEXECUTE\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_users_by_name\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Jane'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 각 후속 실행에 대해 쿼리를 준비하고 실행 계획을 재사용할 수 있어 성능을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e제가 언급한 옵션을 사용하여 PostgreSQL 쿼리를 최적화하는 방법을 명확하게 설명하는 데 도움이 되기를 바랍니다!\u003c/p\u003e\n\u003ch2\u003e8. 연결 풀 사용\u003c/h2\u003e\n\u003cp\u003e연결 풀을 사용하면 데이터베이스 연결을 생성하고 해제하는 오버헤드를 줄여 성능을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e커넥션 풀링은 각 데이터베이스 요청마다 새로운 연결을 생성하고 해제하는 대신 데이터베이스 연결 풀을 관리하는 기술입니다. 기존 연결을 재사용함으로써 커넥션 풀링은 새로운 연결을 맺는 데 필요한 오버헤드를 줄일 수 있어 PostgreSQL 쿼리의 성능을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 PostgreSQL에서 커넥션 풀링을 사용하는 예시입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e커넥션 풀링 라이브러리 설치: PostgreSQL용 여러 커넥션 풀링 라이브러리가 있습니다. pgBouncer, pgpool-II, 그리고 Pgpool 등이 있습니다. 요구 사항에 가장 적합한 라이브러리를 선택하고 서버에 설치합니다.\u003c/li\u003e\n\u003cli\u003e커넥션 풀 구성: 데이터베이스에 대한 최대 연결 수와 최대 휴대 중인 연결 수를 지정하도록 커넥션 풀을 구성합니다. 또한 일정 시간 후 휴대 중인 연결을 자동으로 닫도록 풀을 구성할 수도 있습니다.\u003c/li\u003e\n\u003cli\u003e응용 프로그램 코드 수정: 응용 프로그램 코드를 수정하여 각 데이터베이스 요청마다 새로운 연결을 생성하는 대신에 커넥션 풀을 사용하도록 수정합니다. 선택한 커넥션 풀 라이브러리에 따라 연결 문자열이나 데이터베이스 URL을 수정해야 할 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음은 pgBouncer를 사용한 커넥션 풀링 사용 예시입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epgBouncer 설치: 패키지 관리자를 사용하거나 소스에서 컴파일하여 서버에 pgBouncer를 설치합니다.\u003c/li\u003e\n\u003cli\u003e연결 풀 구성: pgBouncer 구성 파일을 편집하여 데이터베이스에 대한 연결 최대 수와 최대 휴식 연결 수를 지정합니다. 또한 일정 시간이 지난 후 자동으로 휴식 연결을 닫도록 pgBouncer를 구성할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e응용 프로그램 코드 수정: 응용 프로그램 코드를 수정하여 기본 PostgreSQL 연결 문자열 대신 pgBouncer 연결 문자열을 사용하도록 합니다. 다음은 PostgreSQL 연결 문자열의 예시입니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//username:password@hostname:port/database\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음은 pgBouncer 연결 문자열의 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//username:password@hostname:6432/database\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e포트 번호가 다르고 호스트 이름이 PostgreSQL 서버가 아닌 pgBouncer 서버를 가리키는 것을 유의해 주세요.\u003c/p\u003e\n\u003cp\u003epgBouncer와 같은 커넥션 풀을 사용하면 데이터베이스 연결을 생성하고 해제하는 오버헤드를 줄일 수 있어 PostgreSQL 쿼리의 성능을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e9. 테이블 분석 및 VACUUM\u003c/h2\u003e\n\u003cp\u003e분석과 VACUUM은 데이터베이스 통계를 업데이트하고 디스크 공간을 회수하여 PostgreSQL 쿼리의 성능을 향상시킬 수 있는 두 가지 중요한 유지 관리 작업입니다. 각 작업에 대한 간단한 설명은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e분석: 테이블에 인덱스를 생성하거나 데이터를 필터링하거나 정렬하는 쿼리를 실행할 때, PostgreSQL은 통계를 사용하여 조건과 일치하는 행 수를 추정합니다. 데이터베이스 통계에는 데이터의 분포에 대한 정보가 포함되어 있습니다. 즉, 고유한 값의 수 및 각 값의 빈도가 포함됩니다. 이러한 통계는 pg_statistic이라는 시스템 카탈로그에 저장됩니다. 통계가 오래되거나 부정확할 경우, 쿼리 플래너가 잘못된 결정을 내리고 효율적이지 않은 쿼리 계획을 생성할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e통계를 업데이트하려면 테이블이나 전체 데이터베이스에 ANALYZE 명령을 실행할 수 있습니다. ANALYZE는 테이블을 스캔하고 pg_statistic에서 통계를 업데이트합니다. 대규모 테이블의 경우, 이 작업은 상당한 시간이 소요될 수 있지만, 이는 일회성 비용이며 혜택이 상당할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e박강작업: 테이블에 행을 삽입, 업데이트 또는 삭제할 때, PostgreSQL은 이전 행이 사용한 디스크 공간을 즉시 해제하지 않습니다. 대신, 해당 공간을 재사용 가능하다고 표시하고 새 행이 그 공간을 채울 때까지 기다립니다. 이를 \"불필요한\" 공간이라고 하며 시간이 지남에 따라 축적되어 단편화와 성능 저하로 이어질 수 있습니다. 박강작업은 불필요한 공간을 회수하여 운영 체제가 다시 사용할 수 있도록 하는 과정입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePostgreSQL에서 테이블을 박강하는 여러 옵션이 있습니다. 가장 간단한 옵션은 VACUUM 명령을 실행하는 것으로, 전체 테이블을 스캔하고 불필요한 공간을 제거합니다. 다른 옵션은 VACUUM ANALYZE 명령을 실행하는 것으로, 분석과 박강 작업의 혜택을 결합한 명령입니다.\u003c/p\u003e\n\u003cp\u003e이제 PostgreSQL에서 테이블을 분석하고 VACUUM하는 방법을 알아볼게요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e-- 테이블 분석하기\n\u003cspan class=\"hljs-variable constant_\"\u003eANALYZE\u003c/span\u003e mytable;\n\n-- 테이블 \u003cspan class=\"hljs-variable constant_\"\u003eVACUUM\u003c/span\u003e하기\n\u003cspan class=\"hljs-variable constant_\"\u003eVACUUM\u003c/span\u003e mytable;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e정기적으로 테이블을 분석하고 VACUUM하면 데이터베이스 통계가 최신 상태를 유지하고 디스크 공간을 효율적으로 사용할 수 있어요. 이는 PostgreSQL 쿼리의 성능을 향상시키고 더 나은 쿼리 계획을 생성하며 데이터를 읽고 쓰기 위해 필요한 디스크 I/O 양을 줄이는 데 도움이 될 수 있어요.\u003c/p\u003e\n\u003cp\u003e이 글에 대한 궁금한 점이나 피드백이 있으면 언제든지 댓글을 남겨주세요.\n읽어주셔서 감사합니다. 함께 NodeTeam에 참여해보세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-HowtoOptimizePostgreSQLQueries"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>