<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Jetpack Compose에서 DataStorePreferences를 사용한 지속적 데이터 저장 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Jetpack Compose에서 DataStorePreferences를 사용한 지속적 데이터 저장 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Jetpack Compose에서 DataStorePreferences를 사용한 지속적 데이터 저장 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose" data-gatsby-head="true"/><meta name="twitter:title" content="Jetpack Compose에서 DataStorePreferences를 사용한 지속적 데이터 저장 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-01 16:51" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Jetpack Compose에서 DataStorePreferences를 사용한 지속적 데이터 저장 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Jetpack Compose에서 DataStorePreferences를 사용한 지속적 데이터 저장 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 1, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png" alt="image"></p>
<p>ℹ: 가끔 실수를 하거나 완전히 정확하지 않은 정보를 공유할 수도 있어요. 완벽하지 않으니 참고용으로만 사용해 주세요. 뭔가 이상하다고 느껴지면 공식 문서나 블로그를 확인하는 것이 좋아요.</p>
<h1>✨ 소개</h1>
<p>"설정" 메뉴를 응용 프로그램에 포함시키는 것이 표준적인 규칙이 되었습니다. 사용자의 선호에 맞춰 인터페이스를 사용자 정의할 수 있는 기능을 제공하여, 예를 들어 밝은 테마와 어두운 테마 간 전환 또는 알림을 켜거나 끄기 등이 가능합니다.</p>
<div class="content-ad"></div>
<p>“Settings” 정보는 사용자 기기에 지속적으로 저장되어 있어야 합니다 (앱이 삭제될 때까지). 그렇지 않으면 사용자가 앱을 닫을 때마다 저장된 사용자 설정이 손실되어 설정을 다시 처음부터 구성해야 합니다.</p>
<p>이를 염두에 두고 오늘은 앱 설정 정보를 지속적으로 저장하기 위해 주로 사용되는 DataStore (Preferences)의 기본 구현 방법을 소개하겠습니다!</p>
<h1>☛ 구현 전 고려사항</h1>
<p>DataStore (Preferences) API를 사용하면 데이터를 키-값 형식으로 저장하고 관리할 수 있습니다. 그 자체로는 과도하게 복잡하지 않지만 구현에는 다음과 같은 기본 지식을 이해해야 합니다:</p>
<div class="content-ad"></div>
<ul>
<li>ViewModel을 사용한 UI 상태 관리의 기본 사항</li>
<li>Kotlin에서 비동기 처리의 기본 사항 (Coroutine)</li>
<li>DI (의존성 주입)의 기본적인 이해</li>
</ul>
<p>만약 이러한 주제들을 이해하지 못하고 있다면, 제가 소개할 샘플 코드의 역할을 이해하기 어려울 수도 있습니다.</p>
<p>제가 작성한 글 속 코드에 대해 가능한 많은 설명을 제공하겠지만, 모든 세부 내용을 다 다루기는 이 글의 범위를 벗어나므로, 일정 수준의 이전 지식을 갖고 있다고 가정하겠습니다. 샘플 코드가 무엇을 하는지 완전히 이해할 수 없다면, Jetpack Compose와 Kotlin의 기본을 다시 공부하는 것이 좋을 수도 있습니다.</p>
<p>아래는 참고 링크입니다 (공식 Google 및 Kotlin 문서):</p>
<div class="content-ad"></div>
<ul>
<li>ViewModel: <a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/ViewModel" rel="nofollow" target="_blank">라이브러리 안드로이드 뷰모델 참조</a></li>
<li>Kotlin 코루틴: <a href="https://kotlinlang.org/docs/coroutines-overview.html" rel="nofollow" target="_blank">코루틴 개요 코틀린 문서</a></li>
<li>Kotlin Flow: <a href="https://kotlinlang.org/docs/flow.html" rel="nofollow" target="_blank">코틀린 Flow 문서</a></li>
<li>DI (의존성 주입): <a href="https://developer.android.com/training/dependency-injection" rel="nofollow" target="_blank">의존성 주입 안드로이드 교육</a></li>
</ul>
<p>하지만 저자로서 제 생각으로는 코드를 즉시 이해하지 못해도 전혀 괜찮습니다. 코드를 그대로 복사하여 붙여넣고 '세부 정보를 모르겠지만 작동했다!' 라고 생각하는 지점에 도달하는 것도 중요한 단계입니다.</p>
<p>기본을 이해하는 것은 필수적이지만, 코드의 의미가 처음에 분명하지 않더라도 진행하는 것은 괜찮습니다. 완전한 이해 없이 전진하는 것은 학습 과정의 중요한 부분일 수 있습니다.</p>
<h1>☛ 앱의 UI 확인</h1>
<div class="content-ad"></div>
<p>이번에는 사용자가 사용자 이름을 입력하고 SAVE 버튼을 탭하면 해당 사용자 이름이 기기에 영구적으로 저장되고 저장된 사용자 이름이 표시되는 앱을 만들고 싶어요.</p>
<p>완성된 앱은 아래 이미지처럼 보일 거예요.</p>
<p><img src="/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_1.png" alt="Image"></p>
<p>완료되면 "SAVE" 버튼을 탭한 후에도 앱을 닫아도 사용자 이름이 계속 저장되어 있어야 합니다. 그러나 "SAVE" 버튼을 탭했을 때 아무런 작업도 수행되지 않도록 해야 합니다.</p>
<div class="content-ad"></div>
<p>사용자 이름이 표시되는 부분은 "Hi, Name?"으로 일단 고정 값으로 설정해보겠습니다.</p>
<p>아래는 앱의 메인 화면(MainScreen.kt)에 대한 임시 코드입니다:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@Composable</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">MainScreen</span><span class="hljs-params">(
   modifier: <span class="hljs-type">Modifier</span> = Modifier
)</span></span> {

   <span class="hljs-keyword">var</span> userInput <span class="hljs-keyword">by</span> remember {
       mutableStateOf(<span class="hljs-string">""</span>)
   }

   Column(
       modifier = modifier.fillMaxSize(),
       verticalArrangement = Arrangement.Center,
       horizontalAlignment = Alignment.CenterHorizontally
   ) {
       Text(
           text = <span class="hljs-string">"Hi, Name?"</span>,
           style = MaterialTheme.typography.displaySmall,
           modifier = Modifier
               .padding(top = <span class="hljs-number">32.</span>dp)
       )
       TextField(
           value = userInput,
           onValueChange = { userInput = it },
           modifier = Modifier
               .padding(vertical = <span class="hljs-number">32.</span>dp)
       )
       Button(
           onClick = { <span class="hljs-comment">/*TODO*/</span> }
       ) {
           Text(text = <span class="hljs-string">"SAVE"</span>)
       }
   }
}
</code></pre>
<p>현재 SAVE 버튼을 누르면 아무 일도 일어나지 않으며, 앱을 닫으면 입력한 사용자 이름 정보가 손실됩니다.</p>
<div class="content-ad"></div>
<h1>☛ 1) Dependencies 설정하기</h1>
<p>이제 우리가 완성품의 명확한 비전을 갖고 있다면, DataStore (Preferences)의 소개를 진행해 봅시다.</p>
<p>먼저, 의존성을 설정해야 합니다. 다음 의존성을 모듈 레벨의 build.gradle.kts 파일에 추가해주세요. (참고: ViewModel도 필요하므로 DataStore와 함께 나열되어 있습니다.)</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* build.gradle.kts */</span>
<span class="hljs-comment">// ViewModel 추가</span>
<span class="hljs-title function_">implementation</span>(<span class="hljs-string">"androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0"</span>)

<span class="hljs-comment">// DataStore preferences 추가</span>
<span class="hljs-title function_">implementation</span>(<span class="hljs-string">"androidx.datastore:datastore-preferences:1.0.0"</span>)
</code></pre>
<div class="content-ad"></div>
<p>위의 코드에서는 이 글을 작성하는 시점에서 사용 가능한 최신 안정 버전을 지정했습니다. 그러나 구현할 때 사용 가능한 최신 안정 버전을 확인하고 지정하는 것이 좋습니다.</p>
<p>코드를 추가한 후 '지금 동기화'를 클릭하여 동기화하세요. 이 시점에서 특별히 어려운 점은 없어야 합니다.</p>
<h1>☛ 2) UserRepository.kt 추가</h1>
<p>이제 본격적으로 시작합니다. 이 부분에서는 DataStore(Preferences)를 사용하여 기기에 사용자 설정 정보(이 경우 사용자 이름)를 영구적으로 저장하는 논리를 작성할 겁니다.</p>
<div class="content-ad"></div>
<p>우선, 이 패키지와 파일이 UI가 아닌 데이터를 관리하는 것임을 명확히 하기 위해 "data"라는 이름의 패키지를 생성하세요.</p>
<p>com.example.projectname 패키지에서 마우스 오른쪽 버튼을 클릭하고 "새 패키지"를 선택한 후 "data"라고 입력하여 생성하세요.</p>
<p><img src="/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_2.png" alt="image"></p>
<p>data 패키지를 생성한 후에 이 패키지 내부에 UserRepository란 이름의 Kotlin 파일을 만드세요. 만들 때 Class를 선택해주세요.</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_3.png">
<p>특정 패키지에 파일을 추가하는 프로세스는 이후 단계에서도 동일합니다.</p>
<p>지금은 생성된 UserRepository.kt 파일의 UserRepository 클래스에서 DataStore(Preferences)를 사용하는 로직을 작성할 예정입니다.</p>
<p>먼저 DataStore를 사용할 때는 애플리케이션의 최상위 컨텍스트를 사용해야 하므로, 생성자로 dataStore라는 DataStore 타입을 지정해줍니다.</p>
<div class="content-ad"></div>
<p>/* UserRepository.kt */
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.Preferences</p>
<p>class UserRepository(private val dataStore: DataStore<preferences>) {</preferences></p>
<p>}</p>
<p>이렇게 하면 UserRepository 클래스 내에서 컨텍스트를 정의할 필요가 없고, UserRepository 클래스는 오직 DataStore에 대한 로직만을 처리할 수 있습니다.</p>
<p>DataStore(Preferences)에서 데이터는 키 및 값으로 관리되며, 여기서 다루는 값은 문자열인 사용자 이름입니다. 따라서 stringPreferencesKey()를 사용하여 다음과 같이 문자열 값이 포함된 키를 정의합니다:</p>
<p>/* UserRepository.kt */
import androidx.datastore.preferences.core.stringPreferencesKey</p>
<p>class UserRepository(private val dataStore: DataStore<preferences>) {
private companion object {
val USER_NAME = stringPreferencesKey("user_name")
}
}</preferences></p>
<div class="content-ad"></div>
<p>프라이빗 컴패니언 객체로 정의하면 각 Preferences 키를 클래스 내에서 한 번만 존재하는 정적 객체(싱글톤)로 관리할 수 있습니다. 사용자 이름만 관리하는 것은 쉽지만, 다른 설정을 토글하거나 관리해야 하는 경우처럼 여러 키를 관리해야 하는 경우에는 컴패니언 객체를 사용하는 것이 더욱 유리합니다.</p>
<p>다음으로, 장치에 저장된 문자열 타입 값에 대한 속성을 정의합니다. 이는 데이터 스토어를 생성자로 받은 데이터의 데이터를 map()으로 확장하고, 앞서 컴패니언 객체에서 정의한 키를 지정하여 달성할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* UserRepository.kt */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRepository</span>(private val <span class="hljs-attr">dataStore</span>: <span class="hljs-title class_">DataStore</span>&#x3C;<span class="hljs-title class_">Preferences</span>>) {
   private companion object {
       val <span class="hljs-variable constant_">USER_NAME</span> = <span class="hljs-title function_">stringPreferencesKey</span>(<span class="hljs-string">"user_name"</span>)
   }

   val <span class="hljs-attr">currentUserName</span>: <span class="hljs-title class_">Flow</span>&#x3C;<span class="hljs-title class_">String</span>> =
       dataStore.<span class="hljs-property">data</span>.<span class="hljs-property">map</span> { preferences ->
           preferences[<span class="hljs-variable constant_">USER_NAME</span>] ?: <span class="hljs-string">"Unknown"</span>
       }
}
</code></pre>
<p>⚠️참고: 실제로는 데이터를 읽는 작업이 실패할 경우를 대비하여 에러를 처리하고 해당 코드를 포함해야 합니다. 그러나 코드를 간단하게 유지하기 위해 여기에서는 생략하였습니다.</p>
<div class="content-ad"></div>
<p>이제 이 설정으로 데이터를 읽을 수만 있기 때문에, 데이터를 저장하거나 업데이트하는 메소드를 추가해 봅시다. edit()를 사용하여 전달된 문자열을 저장하는 메소드를 추가해 보세요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* UserRepository.kt */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRepository</span>(private val <span class="hljs-attr">dataStore</span>: <span class="hljs-title class_">DataStore</span>&#x3C;<span class="hljs-title class_">Preferences</span>>) {
   private companion object {
       val <span class="hljs-variable constant_">USER_NAME</span> = <span class="hljs-title function_">stringPreferencesKey</span>(<span class="hljs-string">"user_name"</span>)
   }

   val <span class="hljs-attr">currentUserName</span>: <span class="hljs-title class_">Flow</span>&#x3C;<span class="hljs-title class_">String</span>> =
       dataStore.<span class="hljs-property">data</span>.<span class="hljs-property">map</span> { preferences ->
           preferences[<span class="hljs-variable constant_">USER_NAME</span>] ?: <span class="hljs-string">"알 수 없음"</span>
       }

   suspend fun <span class="hljs-title function_">saveUserName</span>(<span class="hljs-params">userName: <span class="hljs-built_in">String</span></span>) {
       dataStore.<span class="hljs-property">edit</span> { preferences ->
           preferences[<span class="hljs-variable constant_">USER_NAME</span>] = userName
       }
   }
}
</code></pre>
<p>이로써 DataStore (Preferences)를 사용하기 위한 세 가지 필수 구성 요소가 완성되었습니다:</p>
<ul>
<li>문자열을 값으로 가지는 키를 설정하는 것</li>
<li>값을 읽을 수 있는 프로퍼티</li>
<li>값을 저장할 수 있는 메소드</li>
</ul>
<div class="content-ad"></div>
<p>UserRepository.kt 파일의 코드 작성이 완료되었습니다.</p>
<p>하지만 우리는 아직 데이터 저장소를 생성자로 받을 준비를 하지 않았기 때문에 아직 작동하지 않을 것입니다. 다음 단계에서는 애플리케이션 컨텍스트를 사용할 준비를 하겠습니다.</p>
<h1>☛ 3) MyApplication 클래스 추가 및 설정</h1>
<p>이 단계에서는 UserRepository에서 사용할 애플리케이션 컨텍스트를 구성할 것입니다.</p>
<div class="content-ad"></div>
<p>먼저, com.example.projectname 패키지 내에 MyApplication.kt라는 파일을 만들어주세요 (클래스로 지정).</p>
<p>그런 다음, MyApplication.kt 파일의 MyApplication 클래스 바깥에서 dataStore를 Context 확장 속성으로 정의하고 특정 DataStore 인스턴스에 위임해주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* MyApplication.kt */</span>
private val <span class="hljs-title class_">Context</span>.<span class="hljs-property">dataStore</span>: <span class="hljs-title class_">DataStore</span>&#x3C;<span class="hljs-title class_">Preferences</span>> by <span class="hljs-title function_">preferencesDataStore</span>(
   name = <span class="hljs-string">"setting"</span>
)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> {
}
</code></pre>
<p>이를 통해 어플리케이션의 모든 부분이 동일한 Context를 통해 DataStore에 액세스할 수 있게 되어 데이터 일관성을 보장하고 코드 재사용성을 향상시킬 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">/* MyApplication.kt */</span>
private val <span class="hljs-title class_">Context</span>.<span class="hljs-property">dataStore</span>: <span class="hljs-title class_">DataStore</span>&#x3C;<span class="hljs-title class_">Preferences</span>> by <span class="hljs-title function_">preferencesDataStore</span>(
  name = <span class="hljs-string">"setting"</span>
)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span>: <span class="hljs-title class_">Application</span>() {
  lateinit <span class="hljs-keyword">var</span> <span class="hljs-attr">userRepository</span>: <span class="hljs-title class_">UserRepository</span>
  override fun <span class="hljs-title function_">onCreate</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">onCreate</span>()
    userRepository = <span class="hljs-title class_">UserRepository</span>(dataStore)
  }
}
</code></pre>
<p>userRepository은 이전 단계에서 생성된 UserRepository 클래스를 상속받지만, 당연히 여기에서 초기화할 수 없습니다(데이터 스토어인 생성자를 지정할 수 없기 때문). 따라서 애플리케이션이 초기화될 때 이전에 정의한 Context.dataStore가 UserRepository 클래스로 전달되어야 합니다.</p>
<p>이 과정은 애플리케이션 전체에서 일관된 데이터 저장 메커니즘을 제공하여 UserRepository 클래스가 이 데이터 스토어를 사용하여 사용자 설정 및 정보를 관리할 수 있도록 합니다. 결과적으로 데이터 저장, 검색 및 업데이트가 애플리케이션 내의 어디에서든 쉽게 액세스할 수 있습니다.</p>
<div class="content-ad"></div>
<p>이 단계의 마지막에 AndroidManifest.xml 파일의 애플리케이션 태그에 android:name을 다음과 같이 추가하는 것을 잊지 마세요:</p>
<pre><code class="hljs language-js">&#x3C;!-- <span class="hljs-title class_">AndroidManifest</span>.<span class="hljs-property">xml</span> -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">application</span>
   <span class="hljs-attr">android:name</span>=<span class="hljs-string">".MyApplication"</span>></span>
</span></code></pre>
<p>이 사양을 따르면 MyApplication 클래스에 정의된 종속성이 MainActivity가 시작되기 전에 초기화됩니다.</p>
<p>MyApplication 클래스와 관련된 코딩 및 설정이 이제 완료되었지만, 코드의 역할과 의미가 간결함 때문에 이해하기 어려울 수 있다는 것을 이해합니다.</p>
<div class="content-ad"></div>
<p>이 단계에서는 "DataStore(Preferences)와 애플리케이션 컨텍스트(전체 앱을 통틀어 말하는 맥락)를 사용할 수 있게 해준다"는 넓은 이해를 바탕으로 시작하는 것이 좋아요.</p>
<h1>☛ 4) ViewModel 추가 및 구성하기</h1>
<p>이전 단계에서 DataStore(Preferences)를 사용할 준비가 되었지만, 현재 상태에서는 UI가 어떤 변경 사항도 반영하지 않을 것입니다. 이번 단계에서는 ViewModel을 사용하여 UI의 책임을 처리하여 앱을 완성에 더 가깝게 이끌 것입니다.</p>
<p>먼저, 샘플.com.프로젝트명 <code>ui</code> 패키지 내에 MyAppViewModel이라는 파일을 생성하세요.</p>
<div class="content-ad"></div>
<p>자연스럽게 MyAppViewModel 클래스는 응용 프로그램 컨텍스트에 따라 다르게 구성된 UserRepository 클래스의 속성 및 메서드를 활용할 것입니다. 따라서 MyAppViewModel 내에서 UserRepository를 직접 사용할 수 없습니다. 대신에 다음과 같이 생성자로 userRepository를 지정합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* MyAppViewModel.kt */</span>
<span class="hljs-keyword">import</span> androidx.<span class="hljs-property">lifecycle</span>.<span class="hljs-property">ViewModel</span>
<span class="hljs-keyword">import</span> com.<span class="hljs-property">example</span>.<span class="hljs-property">datastoresample</span>.<span class="hljs-property">data</span>.<span class="hljs-property">UserRepository</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAppViewModel</span>(
   private val <span class="hljs-attr">userRepository</span>: <span class="hljs-title class_">UserRepository</span>
): <span class="hljs-title class_">ViewModel</span>() {
  
}
</code></pre>
<p>이렇게 함으로써 UserRepository 클래스가 응용 프로그램 컨텍스트에 의존하고 있고, MyAppViewModel 클래스가 UserRepository 클래스에 의존하고 있는 관계를 설정했습니다. MyAppViewModel이 초기화될 때 UserRepository가 초기화되어야 하므로 ViewModel을 사용하기 어렵다고 걱정할 수도 있겠지만, 이 의존성 문제를 이번 단계의 끝에서 해결할 것입니다.</p>
<p>지금은 의존성 해결을 제외하고, 저장된 사용자 이름을 검색하는 속성을 정의하기 위해 시작하겠습니다. 그 전에, UI 상태를 관리하는 UiState라는 데이터 클래스를 MyAppViewModel 클래스 외부에 정의해보겠습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">/* MyAppViewModel.kt */</span>
data <span class="hljs-keyword">class</span> <span class="hljs-title class_">UiState</span> (
   val <span class="hljs-attr">userName</span>: <span class="hljs-title class_">String</span>
)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAppViewModel</span>(
   private val <span class="hljs-attr">userRepository</span>: <span class="hljs-title class_">UserRepository</span>
): <span class="hljs-title class_">ViewModel</span>() {
  
}
</code></pre>
<p>그리고 UiState 데이터 클래스를 사용하여 UserRepository 클래스에 정의된 currentUserName 속성에서 데이터를 비동기적으로 로드합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* MyAppViewModel.kt */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAppViewModel</span>(
   private val <span class="hljs-attr">userRepository</span>: <span class="hljs-title class_">UserRepository</span>
): <span class="hljs-title class_">ViewModel</span>() {
   val <span class="hljs-attr">uiState</span>: <span class="hljs-title class_">StateFlow</span>&#x3C;<span class="hljs-title class_">UiState</span>> =
       userRepository.<span class="hljs-property">currentUserName</span>.<span class="hljs-property">map</span> { userName ->
           <span class="hljs-title class_">UiState</span>(userName)
       }.<span class="hljs-title function_">stateIn</span>(
           scope = viewModelScope,
           started = <span class="hljs-title class_">SharingStarted</span>.<span class="hljs-title class_">WhileSubscribed</span>(<span class="hljs-number">5000</span>),
           initialValue = <span class="hljs-title class_">UiState</span>(<span class="hljs-string">"Unknown"</span>)
       )
}
</code></pre>
<p>ViewModel의 UI 상태(UiState)는 StateFlow 형식으로 관리되어야 하므로, Flow 형식에서 StateFlow 형식으로 변환하고, .stateIn()을 사용하여 구독을 설정하고 초기 값이 설정되도록 합니다.</p>
<div class="content-ad"></div>
<p>SharingStarted.WhileSubscribed(5000)은 구독이 종료된 후 5초 동안 여전히 값이 방출되며, 구독을 취소한 후에도 잠시 동안 UI 구성 요소가 데이터 업데이트를 받을 수 있습니다. 값 구독을 최적화하기 위한 이 조정은 복잡해 보일 수 있지만, 이를 "값 구독을 최적화하는 설정"으로 생각할 수 있습니다.</p>
<p>그렇게 하면, 저장된 사용자 이름(문자열) 정보를 UI 상태 관리를 위한 값으로 읽을 준비가 되었습니다. 그 다음으로, 값을 저장하거나 업데이트하는 메서드를 추가해 봅시다. 이는 UserRepository 클래스에서 정의된 것과 비슷한 방식으로 구현할 수 있습니다.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">/* MyAppViewModel.kt */</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">saveUserName</span><span class="hljs-params">(userName: <span class="hljs-type">String</span>)</span></span> {
    viewModelScope.launch {
        userRepository.saveUserName(userName)
    }
}
</code></pre>
<p>UserRepository 클래스에서 정의된 saveUserName() 메서드는 suspend fun으로 정의되어 있기 때문에 coroutine scope 내에서 호출되어야 합니다.</p>
<div class="content-ad"></div>
<p>이제 우리는 값을 읽고 저장(업데이트)할 수 있게 되었는데, 남은 문제는 MyViewModel이 UserRepository에 의존하고 UserRepository가 애플리케이션 컨텍스트에 의존하는 문제입니다. 이를 해결해 봅시다.</p>
<p>다음과 같이 MyViewModel 클래스에 companion object를 정의하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* MyAppViewModel.kt */</span>
companion object {
   val <span class="hljs-title class_">Factory</span>: <span class="hljs-title class_">ViewModelProvider</span>.<span class="hljs-property">Factory</span> = viewModelFactory {
       initializer {
           val application = (<span class="hljs-variable language_">this</span>[<span class="hljs-variable constant_">APPLICATION_KEY</span>] <span class="hljs-keyword">as</span> <span class="hljs-title class_">MyApplication</span>)
           <span class="hljs-title class_">MyAppViewModel</span>(application.<span class="hljs-property">userRepository</span>)
       }
   }
}
</code></pre>
<p>이전 코드와 비교했을 때, 처음에는 더욱 불분명해 보일 수 있습니다. 그러나 이 코드의 목적은 MyAppViewModel의 인스턴스를 생성할 때 애플리케이션 컨텍스트로부터 필요한 종속성(이 경우 userRepository)을 주입하는 것입니다. 이를 통해 ViewModel을 테스트하고 재사용하기 쉬워지며 종속성을 명시적으로 관리할 수 있도록 합니다.</p>
<div class="content-ad"></div>
<p>본질적으로, 이 사용자 정의는 ViewModel (MyAppViewModel)을 초기화할 때 발생하여 MyAppViewModel이 UserRepository에 의존하는 문제를 해결합니다.</p>
<p>마지막 단계는 초기에 제시된 MainScreen.kt를 수정하여 버튼을 탭할 때 데이터(사용자 이름)를 영구적으로 저장하고 저장된 데이터를 문자열로 표시하여 앱을 완성하는 것입니다.</p>
<h1>☛ 5) 뷰 업데이트</h1>
<p>지금까지의 단계에서 DataStore (Preferences)를 사용하여 지속적인 데이터 저장 및 검색을 준비했으며 ViewModel을 사용하여 UI를 관리했습니다. 이제 MainScreen.kt를 업데이트하여 ViewModel을 통해 저장된 데이터가 UI에 반영되도록 할 것입니다.</p>
<div class="content-ad"></div>
<p>먼저, 다음과 같이 MainScreen()에 MyAppViewModel을 매개변수로 지정하세요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* MainScreen.kt */</span>
@<span class="hljs-title class_">Composable</span>
fun <span class="hljs-title class_">MainScreen</span>(
   <span class="hljs-attr">modifier</span>: <span class="hljs-title class_">Modifier</span> = <span class="hljs-title class_">Modifier</span>,
   <span class="hljs-attr">myAppViewModel</span>: <span class="hljs-title class_">MyAppViewModel</span> = <span class="hljs-title function_">viewModel</span>(factory = <span class="hljs-title class_">MyAppViewModel</span>.<span class="hljs-property">Factory</span>)
) { … }
</code></pre>
<p>MyAppViewModel에서 정의된 Factory를 factory 매개변수에 전달함으로써, 이 MyAppViewModel의 초기화는 이전 챕터에서 설정한 사용자 지정 초기화 설정이 적용됩니다.</p>
<p>다음으로 UI 상태(이 경우 저장된 사용자 이름)를 정의하려면 MainScreen 함수 내에서 savedUserName을 다음과 같이 정의하세요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">/* MainScreen.kt */</span>
<span class="hljs-keyword">val</span> savedUserName <span class="hljs-keyword">by</span> myAppViewModel.uiState.collectAsState()

Text(
   text = <span class="hljs-string">"안녕하세요, <span class="hljs-subst">${savedUserName.userName}</span>님"</span>,
   style = MaterialTheme.typography.displaySmall,
   modifier = Modifier
       .padding(top = <span class="hljs-number">32.</span>dp)
)
</code></pre>
<p>마지막으로, TextField에 입력된 문자열이 버튼을 클릭했을 때 저장되도록 하려면, onclick 매개변수에 전달할 함수를 설정하면 됩니다. 이렇게 하면 끝이죠.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">/* MainScreen.kt */</span>
Button(
   onClick = { myAppViewModel.saveUserName(userInput) }
) {
   Text(text = <span class="hljs-string">"저장"</span>)
}
</code></pre>
<p>앱을 빌드하고 사용자 이름을 입력한 후 SAVE 버튼을 탭한 다음, 앱을 완전히 종료하고 다시 엽니다.</p>
<div class="content-ad"></div>
<p>아래 저장된 데이터가 앱을 종료한 후에도 지워지지 않고 유지되는 것을 확인할 수 있습니다.</p>
<p>잘 했어요! 이렇게 하면 DataStore (Preferences)의 기본 구현이 완료됩니다.</p>
<div class="content-ad"></div>
<h1>☛ 마무리로</h1>
<p>개발 초보자들이 필요한 코드를 외우기에 집중하는 경향이 있다는 것을 알았어요. 하지만, 중요한 것은 코드를 외우는 것이 아니에요. 시험이 아니기 때문에, 과거에 작성한 코드를 잊어버렸을 때는 열심히 다시 작성하기보다는 그냥 복사해서 붙여넣는 것이 괜찮아요.</p>
<p>실제로, 무언가를 구현할 때마다 코드를 처음부터 쓰는 대신, 한 번 작성한 코드를 템플릿으로 관리하는 것이 더 효율적하다고 생각해요. Git이나 클라우드 서비스를 사용해서 작성한 코드를 손쉽게 재사용할 수 있게 만들어두면 좋아요.</p>
<p>하지만, 코드를 복사하고 붙여넣을 때도 그 코드가 무엇을 의미하는지와 어떤 역할을 하는지 이해하는 것이 중요해요.</p>
<div class="content-ad"></div>
<p>"I'm happy to help you out! However, I might not fully understand the requested change. It's important to avoid blindly copying and pasting code; instead, try to understand its purpose to improve your coding skills. Here is the code snippet in Markdown format:</p>
<pre><code class="hljs language-js">&#x3C;aside>
 <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>
   Thank you for reading!<span class="hljs-tag">&#x3C;<span class="hljs-name">br</span>></span>
   If you enjoyed this post, <span class="hljs-tag">&#x3C;<span class="hljs-name">br</span>></span>
   I'd appreciate claps. 😄
 <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">aside</span>></span>
</span></code></pre>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Jetpack Compose에서 DataStorePreferences를 사용한 지속적 데이터 저장 방법","description":"","date":"2024-07-01 16:51","slug":"2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose","content":"\n\n![image](/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png)\n\nℹ: 가끔 실수를 하거나 완전히 정확하지 않은 정보를 공유할 수도 있어요. 완벽하지 않으니 참고용으로만 사용해 주세요. 뭔가 이상하다고 느껴지면 공식 문서나 블로그를 확인하는 것이 좋아요.\n\n# ✨ 소개\n\n\"설정\" 메뉴를 응용 프로그램에 포함시키는 것이 표준적인 규칙이 되었습니다. 사용자의 선호에 맞춰 인터페이스를 사용자 정의할 수 있는 기능을 제공하여, 예를 들어 밝은 테마와 어두운 테마 간 전환 또는 알림을 켜거나 끄기 등이 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n“Settings” 정보는 사용자 기기에 지속적으로 저장되어 있어야 합니다 (앱이 삭제될 때까지). 그렇지 않으면 사용자가 앱을 닫을 때마다 저장된 사용자 설정이 손실되어 설정을 다시 처음부터 구성해야 합니다.\n\n이를 염두에 두고 오늘은 앱 설정 정보를 지속적으로 저장하기 위해 주로 사용되는 DataStore (Preferences)의 기본 구현 방법을 소개하겠습니다!\n\n# ☛ 구현 전 고려사항\n\nDataStore (Preferences) API를 사용하면 데이터를 키-값 형식으로 저장하고 관리할 수 있습니다. 그 자체로는 과도하게 복잡하지 않지만 구현에는 다음과 같은 기본 지식을 이해해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- ViewModel을 사용한 UI 상태 관리의 기본 사항\n- Kotlin에서 비동기 처리의 기본 사항 (Coroutine)\n- DI (의존성 주입)의 기본적인 이해\n\n만약 이러한 주제들을 이해하지 못하고 있다면, 제가 소개할 샘플 코드의 역할을 이해하기 어려울 수도 있습니다.\n\n제가 작성한 글 속 코드에 대해 가능한 많은 설명을 제공하겠지만, 모든 세부 내용을 다 다루기는 이 글의 범위를 벗어나므로, 일정 수준의 이전 지식을 갖고 있다고 가정하겠습니다. 샘플 코드가 무엇을 하는지 완전히 이해할 수 없다면, Jetpack Compose와 Kotlin의 기본을 다시 공부하는 것이 좋을 수도 있습니다.\n\n아래는 참고 링크입니다 (공식 Google 및 Kotlin 문서):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- ViewModel: [라이브러리 안드로이드 뷰모델 참조](https://developer.android.com/reference/kotlin/androidx/lifecycle/ViewModel)\r\n- Kotlin 코루틴: [코루틴 개요 코틀린 문서](https://kotlinlang.org/docs/coroutines-overview.html)\r\n- Kotlin Flow: [코틀린 Flow 문서](https://kotlinlang.org/docs/flow.html)\r\n- DI (의존성 주입): [의존성 주입 안드로이드 교육](https://developer.android.com/training/dependency-injection)\n\n하지만 저자로서 제 생각으로는 코드를 즉시 이해하지 못해도 전혀 괜찮습니다. 코드를 그대로 복사하여 붙여넣고 '세부 정보를 모르겠지만 작동했다!' 라고 생각하는 지점에 도달하는 것도 중요한 단계입니다.\n\n기본을 이해하는 것은 필수적이지만, 코드의 의미가 처음에 분명하지 않더라도 진행하는 것은 괜찮습니다. 완전한 이해 없이 전진하는 것은 학습 과정의 중요한 부분일 수 있습니다.\n\n# ☛ 앱의 UI 확인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이번에는 사용자가 사용자 이름을 입력하고 SAVE 버튼을 탭하면 해당 사용자 이름이 기기에 영구적으로 저장되고 저장된 사용자 이름이 표시되는 앱을 만들고 싶어요.\n\n완성된 앱은 아래 이미지처럼 보일 거예요.\n\n![Image](/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_1.png)\n\n완료되면 \"SAVE\" 버튼을 탭한 후에도 앱을 닫아도 사용자 이름이 계속 저장되어 있어야 합니다. 그러나 \"SAVE\" 버튼을 탭했을 때 아무런 작업도 수행되지 않도록 해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 이름이 표시되는 부분은 \"Hi, Name?\"으로 일단 고정 값으로 설정해보겠습니다.\n\n아래는 앱의 메인 화면(MainScreen.kt)에 대한 임시 코드입니다:\n\n```kotlin\n@Composable\nfun MainScreen(\n   modifier: Modifier = Modifier\n) {\n\n   var userInput by remember {\n       mutableStateOf(\"\")\n   }\n\n   Column(\n       modifier = modifier.fillMaxSize(),\n       verticalArrangement = Arrangement.Center,\n       horizontalAlignment = Alignment.CenterHorizontally\n   ) {\n       Text(\n           text = \"Hi, Name?\",\n           style = MaterialTheme.typography.displaySmall,\n           modifier = Modifier\n               .padding(top = 32.dp)\n       )\n       TextField(\n           value = userInput,\n           onValueChange = { userInput = it },\n           modifier = Modifier\n               .padding(vertical = 32.dp)\n       )\n       Button(\n           onClick = { /*TODO*/ }\n       ) {\n           Text(text = \"SAVE\")\n       }\n   }\n}\n```\n\n현재 SAVE 버튼을 누르면 아무 일도 일어나지 않으며, 앱을 닫으면 입력한 사용자 이름 정보가 손실됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ☛ 1) Dependencies 설정하기\n\n이제 우리가 완성품의 명확한 비전을 갖고 있다면, DataStore (Preferences)의 소개를 진행해 봅시다.\n\n먼저, 의존성을 설정해야 합니다. 다음 의존성을 모듈 레벨의 build.gradle.kts 파일에 추가해주세요. (참고: ViewModel도 필요하므로 DataStore와 함께 나열되어 있습니다.)\n\n```js\n/* build.gradle.kts */\n// ViewModel 추가\nimplementation(\"androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0\")\n\n// DataStore preferences 추가\nimplementation(\"androidx.datastore:datastore-preferences:1.0.0\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에서는 이 글을 작성하는 시점에서 사용 가능한 최신 안정 버전을 지정했습니다. 그러나 구현할 때 사용 가능한 최신 안정 버전을 확인하고 지정하는 것이 좋습니다.\n\n코드를 추가한 후 '지금 동기화'를 클릭하여 동기화하세요. 이 시점에서 특별히 어려운 점은 없어야 합니다.\n\n# ☛ 2) UserRepository.kt 추가\n\n이제 본격적으로 시작합니다. 이 부분에서는 DataStore(Preferences)를 사용하여 기기에 사용자 설정 정보(이 경우 사용자 이름)를 영구적으로 저장하는 논리를 작성할 겁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선, 이 패키지와 파일이 UI가 아닌 데이터를 관리하는 것임을 명확히 하기 위해 \"data\"라는 이름의 패키지를 생성하세요.\n\ncom.example.projectname 패키지에서 마우스 오른쪽 버튼을 클릭하고 \"새 패키지\"를 선택한 후 \"data\"라고 입력하여 생성하세요.\n\n![image](/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_2.png)\n\ndata 패키지를 생성한 후에 이 패키지 내부에 UserRepository란 이름의 Kotlin 파일을 만드세요. 만들 때 Class를 선택해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_3.png\" /\u003e\n\n특정 패키지에 파일을 추가하는 프로세스는 이후 단계에서도 동일합니다.\n\n지금은 생성된 UserRepository.kt 파일의 UserRepository 클래스에서 DataStore(Preferences)를 사용하는 로직을 작성할 예정입니다.\n\n먼저 DataStore를 사용할 때는 애플리케이션의 최상위 컨텍스트를 사용해야 하므로, 생성자로 dataStore라는 DataStore 타입을 지정해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n/* UserRepository.kt */\nimport androidx.datastore.core.DataStore\nimport androidx.datastore.preferences.core.Preferences\n\nclass UserRepository(private val dataStore: DataStore\u003cPreferences\u003e) {\n  \n}\n\n\n이렇게 하면 UserRepository 클래스 내에서 컨텍스트를 정의할 필요가 없고, UserRepository 클래스는 오직 DataStore에 대한 로직만을 처리할 수 있습니다.\n\nDataStore(Preferences)에서 데이터는 키 및 값으로 관리되며, 여기서 다루는 값은 문자열인 사용자 이름입니다. 따라서 stringPreferencesKey()를 사용하여 다음과 같이 문자열 값이 포함된 키를 정의합니다:\n\n\n/* UserRepository.kt */\nimport androidx.datastore.preferences.core.stringPreferencesKey\n\nclass UserRepository(private val dataStore: DataStore\u003cPreferences\u003e) {\n    private companion object {\n        val USER_NAME = stringPreferencesKey(\"user_name\")\n    }\n}\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프라이빗 컴패니언 객체로 정의하면 각 Preferences 키를 클래스 내에서 한 번만 존재하는 정적 객체(싱글톤)로 관리할 수 있습니다. 사용자 이름만 관리하는 것은 쉽지만, 다른 설정을 토글하거나 관리해야 하는 경우처럼 여러 키를 관리해야 하는 경우에는 컴패니언 객체를 사용하는 것이 더욱 유리합니다.\n\n다음으로, 장치에 저장된 문자열 타입 값에 대한 속성을 정의합니다. 이는 데이터 스토어를 생성자로 받은 데이터의 데이터를 map()으로 확장하고, 앞서 컴패니언 객체에서 정의한 키를 지정하여 달성할 수 있습니다.\n\n```js\n/* UserRepository.kt */\nclass UserRepository(private val dataStore: DataStore\u003cPreferences\u003e) {\n   private companion object {\n       val USER_NAME = stringPreferencesKey(\"user_name\")\n   }\n\n   val currentUserName: Flow\u003cString\u003e =\n       dataStore.data.map { preferences -\u003e\n           preferences[USER_NAME] ?: \"Unknown\"\n       }\n}\n```\n\n⚠️참고: 실제로는 데이터를 읽는 작업이 실패할 경우를 대비하여 에러를 처리하고 해당 코드를 포함해야 합니다. 그러나 코드를 간단하게 유지하기 위해 여기에서는 생략하였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이 설정으로 데이터를 읽을 수만 있기 때문에, 데이터를 저장하거나 업데이트하는 메소드를 추가해 봅시다. edit()를 사용하여 전달된 문자열을 저장하는 메소드를 추가해 보세요.\n\n```js\n/* UserRepository.kt */\nclass UserRepository(private val dataStore: DataStore\u003cPreferences\u003e) {\n   private companion object {\n       val USER_NAME = stringPreferencesKey(\"user_name\")\n   }\n\n   val currentUserName: Flow\u003cString\u003e =\n       dataStore.data.map { preferences -\u003e\n           preferences[USER_NAME] ?: \"알 수 없음\"\n       }\n\n   suspend fun saveUserName(userName: String) {\n       dataStore.edit { preferences -\u003e\n           preferences[USER_NAME] = userName\n       }\n   }\n}\n```\n\n이로써 DataStore (Preferences)를 사용하기 위한 세 가지 필수 구성 요소가 완성되었습니다:\n\n- 문자열을 값으로 가지는 키를 설정하는 것\n- 값을 읽을 수 있는 프로퍼티\n- 값을 저장할 수 있는 메소드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUserRepository.kt 파일의 코드 작성이 완료되었습니다.\n\n하지만 우리는 아직 데이터 저장소를 생성자로 받을 준비를 하지 않았기 때문에 아직 작동하지 않을 것입니다. 다음 단계에서는 애플리케이션 컨텍스트를 사용할 준비를 하겠습니다.\n\n# ☛ 3) MyApplication 클래스 추가 및 설정\n\n이 단계에서는 UserRepository에서 사용할 애플리케이션 컨텍스트를 구성할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, com.example.projectname 패키지 내에 MyApplication.kt라는 파일을 만들어주세요 (클래스로 지정).\n\n그런 다음, MyApplication.kt 파일의 MyApplication 클래스 바깥에서 dataStore를 Context 확장 속성으로 정의하고 특정 DataStore 인스턴스에 위임해주세요.\n\n```js\n/* MyApplication.kt */\nprivate val Context.dataStore: DataStore\u003cPreferences\u003e by preferencesDataStore(\n   name = \"setting\"\n)\nclass MyApplication {\n}\n```\n\n이를 통해 어플리케이션의 모든 부분이 동일한 Context를 통해 DataStore에 액세스할 수 있게 되어 데이터 일관성을 보장하고 코드 재사용성을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/* MyApplication.kt */\nprivate val Context.dataStore: DataStore\u003cPreferences\u003e by preferencesDataStore(\n  name = \"setting\"\n)\nclass MyApplication: Application() {\n  lateinit var userRepository: UserRepository\n  override fun onCreate() {\n    super.onCreate()\n    userRepository = UserRepository(dataStore)\n  }\n}\n```\n\nuserRepository은 이전 단계에서 생성된 UserRepository 클래스를 상속받지만, 당연히 여기에서 초기화할 수 없습니다(데이터 스토어인 생성자를 지정할 수 없기 때문). 따라서 애플리케이션이 초기화될 때 이전에 정의한 Context.dataStore가 UserRepository 클래스로 전달되어야 합니다.\n\n이 과정은 애플리케이션 전체에서 일관된 데이터 저장 메커니즘을 제공하여 UserRepository 클래스가 이 데이터 스토어를 사용하여 사용자 설정 및 정보를 관리할 수 있도록 합니다. 결과적으로 데이터 저장, 검색 및 업데이트가 애플리케이션 내의 어디에서든 쉽게 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 단계의 마지막에 AndroidManifest.xml 파일의 애플리케이션 태그에 android:name을 다음과 같이 추가하는 것을 잊지 마세요:\n\n```js\n\u003c!-- AndroidManifest.xml --\u003e\n\u003capplication\n   android:name=\".MyApplication\"\u003e\n```\n\n이 사양을 따르면 MyApplication 클래스에 정의된 종속성이 MainActivity가 시작되기 전에 초기화됩니다.\n\nMyApplication 클래스와 관련된 코딩 및 설정이 이제 완료되었지만, 코드의 역할과 의미가 간결함 때문에 이해하기 어려울 수 있다는 것을 이해합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 단계에서는 \"DataStore(Preferences)와 애플리케이션 컨텍스트(전체 앱을 통틀어 말하는 맥락)를 사용할 수 있게 해준다\"는 넓은 이해를 바탕으로 시작하는 것이 좋아요.\n\n# ☛ 4) ViewModel 추가 및 구성하기\n\n이전 단계에서 DataStore(Preferences)를 사용할 준비가 되었지만, 현재 상태에서는 UI가 어떤 변경 사항도 반영하지 않을 것입니다. 이번 단계에서는 ViewModel을 사용하여 UI의 책임을 처리하여 앱을 완성에 더 가깝게 이끌 것입니다.\n\n먼저, 샘플.com.프로젝트명 `ui` 패키지 내에 MyAppViewModel이라는 파일을 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자연스럽게 MyAppViewModel 클래스는 응용 프로그램 컨텍스트에 따라 다르게 구성된 UserRepository 클래스의 속성 및 메서드를 활용할 것입니다. 따라서 MyAppViewModel 내에서 UserRepository를 직접 사용할 수 없습니다. 대신에 다음과 같이 생성자로 userRepository를 지정합니다:\n\n```js\n/* MyAppViewModel.kt */\nimport androidx.lifecycle.ViewModel\nimport com.example.datastoresample.data.UserRepository\n\nclass MyAppViewModel(\n   private val userRepository: UserRepository\n): ViewModel() {\n  \n}\n```\n\n이렇게 함으로써 UserRepository 클래스가 응용 프로그램 컨텍스트에 의존하고 있고, MyAppViewModel 클래스가 UserRepository 클래스에 의존하고 있는 관계를 설정했습니다. MyAppViewModel이 초기화될 때 UserRepository가 초기화되어야 하므로 ViewModel을 사용하기 어렵다고 걱정할 수도 있겠지만, 이 의존성 문제를 이번 단계의 끝에서 해결할 것입니다.\n\n지금은 의존성 해결을 제외하고, 저장된 사용자 이름을 검색하는 속성을 정의하기 위해 시작하겠습니다. 그 전에, UI 상태를 관리하는 UiState라는 데이터 클래스를 MyAppViewModel 클래스 외부에 정의해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/* MyAppViewModel.kt */\ndata class UiState (\n   val userName: String\n)\n\nclass MyAppViewModel(\n   private val userRepository: UserRepository\n): ViewModel() {\n  \n}\n```\n\n그리고 UiState 데이터 클래스를 사용하여 UserRepository 클래스에 정의된 currentUserName 속성에서 데이터를 비동기적으로 로드합니다.\n\n```js\n/* MyAppViewModel.kt */\nclass MyAppViewModel(\n   private val userRepository: UserRepository\n): ViewModel() {\n   val uiState: StateFlow\u003cUiState\u003e =\n       userRepository.currentUserName.map { userName -\u003e\n           UiState(userName)\n       }.stateIn(\n           scope = viewModelScope,\n           started = SharingStarted.WhileSubscribed(5000),\n           initialValue = UiState(\"Unknown\")\n       )\n}\n```\n\nViewModel의 UI 상태(UiState)는 StateFlow 형식으로 관리되어야 하므로, Flow 형식에서 StateFlow 형식으로 변환하고, .stateIn()을 사용하여 구독을 설정하고 초기 값이 설정되도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSharingStarted.WhileSubscribed(5000)은 구독이 종료된 후 5초 동안 여전히 값이 방출되며, 구독을 취소한 후에도 잠시 동안 UI 구성 요소가 데이터 업데이트를 받을 수 있습니다. 값 구독을 최적화하기 위한 이 조정은 복잡해 보일 수 있지만, 이를 \"값 구독을 최적화하는 설정\"으로 생각할 수 있습니다.\n\n그렇게 하면, 저장된 사용자 이름(문자열) 정보를 UI 상태 관리를 위한 값으로 읽을 준비가 되었습니다. 그 다음으로, 값을 저장하거나 업데이트하는 메서드를 추가해 봅시다. 이는 UserRepository 클래스에서 정의된 것과 비슷한 방식으로 구현할 수 있습니다.\n\n```kotlin\n/* MyAppViewModel.kt */\nfun saveUserName(userName: String) {\n    viewModelScope.launch {\n        userRepository.saveUserName(userName)\n    }\n}\n```\n\nUserRepository 클래스에서 정의된 saveUserName() 메서드는 suspend fun으로 정의되어 있기 때문에 coroutine scope 내에서 호출되어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리는 값을 읽고 저장(업데이트)할 수 있게 되었는데, 남은 문제는 MyViewModel이 UserRepository에 의존하고 UserRepository가 애플리케이션 컨텍스트에 의존하는 문제입니다. 이를 해결해 봅시다.\n\n다음과 같이 MyViewModel 클래스에 companion object를 정의하세요:\n\n```js\n/* MyAppViewModel.kt */\ncompanion object {\n   val Factory: ViewModelProvider.Factory = viewModelFactory {\n       initializer {\n           val application = (this[APPLICATION_KEY] as MyApplication)\n           MyAppViewModel(application.userRepository)\n       }\n   }\n}\n```\n\n이전 코드와 비교했을 때, 처음에는 더욱 불분명해 보일 수 있습니다. 그러나 이 코드의 목적은 MyAppViewModel의 인스턴스를 생성할 때 애플리케이션 컨텍스트로부터 필요한 종속성(이 경우 userRepository)을 주입하는 것입니다. 이를 통해 ViewModel을 테스트하고 재사용하기 쉬워지며 종속성을 명시적으로 관리할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n본질적으로, 이 사용자 정의는 ViewModel (MyAppViewModel)을 초기화할 때 발생하여 MyAppViewModel이 UserRepository에 의존하는 문제를 해결합니다.\n\n마지막 단계는 초기에 제시된 MainScreen.kt를 수정하여 버튼을 탭할 때 데이터(사용자 이름)를 영구적으로 저장하고 저장된 데이터를 문자열로 표시하여 앱을 완성하는 것입니다.\n\n# ☛ 5) 뷰 업데이트\n\n지금까지의 단계에서 DataStore (Preferences)를 사용하여 지속적인 데이터 저장 및 검색을 준비했으며 ViewModel을 사용하여 UI를 관리했습니다. 이제 MainScreen.kt를 업데이트하여 ViewModel을 통해 저장된 데이터가 UI에 반영되도록 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 다음과 같이 MainScreen()에 MyAppViewModel을 매개변수로 지정하세요.\n\n```js\n/* MainScreen.kt */\n@Composable\nfun MainScreen(\n   modifier: Modifier = Modifier,\n   myAppViewModel: MyAppViewModel = viewModel(factory = MyAppViewModel.Factory)\n) { … }\n```\n\nMyAppViewModel에서 정의된 Factory를 factory 매개변수에 전달함으로써, 이 MyAppViewModel의 초기화는 이전 챕터에서 설정한 사용자 지정 초기화 설정이 적용됩니다.\n\n다음으로 UI 상태(이 경우 저장된 사용자 이름)를 정의하려면 MainScreen 함수 내에서 savedUserName을 다음과 같이 정의하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n/* MainScreen.kt */\nval savedUserName by myAppViewModel.uiState.collectAsState()\n\nText(\n   text = \"안녕하세요, ${savedUserName.userName}님\",\n   style = MaterialTheme.typography.displaySmall,\n   modifier = Modifier\n       .padding(top = 32.dp)\n)\n```\n\n마지막으로, TextField에 입력된 문자열이 버튼을 클릭했을 때 저장되도록 하려면, onclick 매개변수에 전달할 함수를 설정하면 됩니다. 이렇게 하면 끝이죠.\n\n```kotlin\n/* MainScreen.kt */\nButton(\n   onClick = { myAppViewModel.saveUserName(userInput) }\n) {\n   Text(text = \"저장\")\n}\n```\n\n앱을 빌드하고 사용자 이름을 입력한 후 SAVE 버튼을 탭한 다음, 앱을 완전히 종료하고 다시 엽니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 저장된 데이터가 앱을 종료한 후에도 지워지지 않고 유지되는 것을 확인할 수 있습니다.\n\n잘 했어요! 이렇게 하면 DataStore (Preferences)의 기본 구현이 완료됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ☛ 마무리로\n\n개발 초보자들이 필요한 코드를 외우기에 집중하는 경향이 있다는 것을 알았어요. 하지만, 중요한 것은 코드를 외우는 것이 아니에요. 시험이 아니기 때문에, 과거에 작성한 코드를 잊어버렸을 때는 열심히 다시 작성하기보다는 그냥 복사해서 붙여넣는 것이 괜찮아요.\n\n실제로, 무언가를 구현할 때마다 코드를 처음부터 쓰는 대신, 한 번 작성한 코드를 템플릿으로 관리하는 것이 더 효율적하다고 생각해요. Git이나 클라우드 서비스를 사용해서 작성한 코드를 손쉽게 재사용할 수 있게 만들어두면 좋아요.\n\n하지만, 코드를 복사하고 붙여넣을 때도 그 코드가 무엇을 의미하는지와 어떤 역할을 하는지 이해하는 것이 중요해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"I'm happy to help you out! However, I might not fully understand the requested change. It's important to avoid blindly copying and pasting code; instead, try to understand its purpose to improve your coding skills. Here is the code snippet in Markdown format:\n\n\n```js\n\u003caside\u003e\n \u003cp\u003e\n   Thank you for reading!\u003cbr\u003e\n   If you enjoyed this post, \u003cbr\u003e\n   I'd appreciate claps. 😄\n \u003c/p\u003e\n\u003c/aside\u003e\n```","ogImage":{"url":"/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eℹ: 가끔 실수를 하거나 완전히 정확하지 않은 정보를 공유할 수도 있어요. 완벽하지 않으니 참고용으로만 사용해 주세요. 뭔가 이상하다고 느껴지면 공식 문서나 블로그를 확인하는 것이 좋아요.\u003c/p\u003e\n\u003ch1\u003e✨ 소개\u003c/h1\u003e\n\u003cp\u003e\"설정\" 메뉴를 응용 프로그램에 포함시키는 것이 표준적인 규칙이 되었습니다. 사용자의 선호에 맞춰 인터페이스를 사용자 정의할 수 있는 기능을 제공하여, 예를 들어 밝은 테마와 어두운 테마 간 전환 또는 알림을 켜거나 끄기 등이 가능합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e“Settings” 정보는 사용자 기기에 지속적으로 저장되어 있어야 합니다 (앱이 삭제될 때까지). 그렇지 않으면 사용자가 앱을 닫을 때마다 저장된 사용자 설정이 손실되어 설정을 다시 처음부터 구성해야 합니다.\u003c/p\u003e\n\u003cp\u003e이를 염두에 두고 오늘은 앱 설정 정보를 지속적으로 저장하기 위해 주로 사용되는 DataStore (Preferences)의 기본 구현 방법을 소개하겠습니다!\u003c/p\u003e\n\u003ch1\u003e☛ 구현 전 고려사항\u003c/h1\u003e\n\u003cp\u003eDataStore (Preferences) API를 사용하면 데이터를 키-값 형식으로 저장하고 관리할 수 있습니다. 그 자체로는 과도하게 복잡하지 않지만 구현에는 다음과 같은 기본 지식을 이해해야 합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eViewModel을 사용한 UI 상태 관리의 기본 사항\u003c/li\u003e\n\u003cli\u003eKotlin에서 비동기 처리의 기본 사항 (Coroutine)\u003c/li\u003e\n\u003cli\u003eDI (의존성 주입)의 기본적인 이해\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e만약 이러한 주제들을 이해하지 못하고 있다면, 제가 소개할 샘플 코드의 역할을 이해하기 어려울 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e제가 작성한 글 속 코드에 대해 가능한 많은 설명을 제공하겠지만, 모든 세부 내용을 다 다루기는 이 글의 범위를 벗어나므로, 일정 수준의 이전 지식을 갖고 있다고 가정하겠습니다. 샘플 코드가 무엇을 하는지 완전히 이해할 수 없다면, Jetpack Compose와 Kotlin의 기본을 다시 공부하는 것이 좋을 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e아래는 참고 링크입니다 (공식 Google 및 Kotlin 문서):\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eViewModel: \u003ca href=\"https://developer.android.com/reference/kotlin/androidx/lifecycle/ViewModel\" rel=\"nofollow\" target=\"_blank\"\u003e라이브러리 안드로이드 뷰모델 참조\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eKotlin 코루틴: \u003ca href=\"https://kotlinlang.org/docs/coroutines-overview.html\" rel=\"nofollow\" target=\"_blank\"\u003e코루틴 개요 코틀린 문서\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eKotlin Flow: \u003ca href=\"https://kotlinlang.org/docs/flow.html\" rel=\"nofollow\" target=\"_blank\"\u003e코틀린 Flow 문서\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eDI (의존성 주입): \u003ca href=\"https://developer.android.com/training/dependency-injection\" rel=\"nofollow\" target=\"_blank\"\u003e의존성 주입 안드로이드 교육\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e하지만 저자로서 제 생각으로는 코드를 즉시 이해하지 못해도 전혀 괜찮습니다. 코드를 그대로 복사하여 붙여넣고 '세부 정보를 모르겠지만 작동했다!' 라고 생각하는 지점에 도달하는 것도 중요한 단계입니다.\u003c/p\u003e\n\u003cp\u003e기본을 이해하는 것은 필수적이지만, 코드의 의미가 처음에 분명하지 않더라도 진행하는 것은 괜찮습니다. 완전한 이해 없이 전진하는 것은 학습 과정의 중요한 부분일 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e☛ 앱의 UI 확인\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이번에는 사용자가 사용자 이름을 입력하고 SAVE 버튼을 탭하면 해당 사용자 이름이 기기에 영구적으로 저장되고 저장된 사용자 이름이 표시되는 앱을 만들고 싶어요.\u003c/p\u003e\n\u003cp\u003e완성된 앱은 아래 이미지처럼 보일 거예요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_1.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e완료되면 \"SAVE\" 버튼을 탭한 후에도 앱을 닫아도 사용자 이름이 계속 저장되어 있어야 합니다. 그러나 \"SAVE\" 버튼을 탭했을 때 아무런 작업도 수행되지 않도록 해야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e사용자 이름이 표시되는 부분은 \"Hi, Name?\"으로 일단 고정 값으로 설정해보겠습니다.\u003c/p\u003e\n\u003cp\u003e아래는 앱의 메인 화면(MainScreen.kt)에 대한 임시 코드입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Composable\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eMainScreen\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\n   modifier: \u003cspan class=\"hljs-type\"\u003eModifier\u003c/span\u003e = Modifier\n)\u003c/span\u003e\u003c/span\u003e {\n\n   \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e userInput \u003cspan class=\"hljs-keyword\"\u003eby\u003c/span\u003e remember {\n       mutableStateOf(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n   }\n\n   Column(\n       modifier = modifier.fillMaxSize(),\n       verticalArrangement = Arrangement.Center,\n       horizontalAlignment = Alignment.CenterHorizontally\n   ) {\n       Text(\n           text = \u003cspan class=\"hljs-string\"\u003e\"Hi, Name?\"\u003c/span\u003e,\n           style = MaterialTheme.typography.displaySmall,\n           modifier = Modifier\n               .padding(top = \u003cspan class=\"hljs-number\"\u003e32.\u003c/span\u003edp)\n       )\n       TextField(\n           value = userInput,\n           onValueChange = { userInput = it },\n           modifier = Modifier\n               .padding(vertical = \u003cspan class=\"hljs-number\"\u003e32.\u003c/span\u003edp)\n       )\n       Button(\n           onClick = { \u003cspan class=\"hljs-comment\"\u003e/*TODO*/\u003c/span\u003e }\n       ) {\n           Text(text = \u003cspan class=\"hljs-string\"\u003e\"SAVE\"\u003c/span\u003e)\n       }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재 SAVE 버튼을 누르면 아무 일도 일어나지 않으며, 앱을 닫으면 입력한 사용자 이름 정보가 손실됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e☛ 1) Dependencies 설정하기\u003c/h1\u003e\n\u003cp\u003e이제 우리가 완성품의 명확한 비전을 갖고 있다면, DataStore (Preferences)의 소개를 진행해 봅시다.\u003c/p\u003e\n\u003cp\u003e먼저, 의존성을 설정해야 합니다. 다음 의존성을 모듈 레벨의 build.gradle.kts 파일에 추가해주세요. (참고: ViewModel도 필요하므로 DataStore와 함께 나열되어 있습니다.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* build.gradle.kts */\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ViewModel 추가\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eimplementation\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0\"\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e// DataStore preferences 추가\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eimplementation\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"androidx.datastore:datastore-preferences:1.0.0\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 코드에서는 이 글을 작성하는 시점에서 사용 가능한 최신 안정 버전을 지정했습니다. 그러나 구현할 때 사용 가능한 최신 안정 버전을 확인하고 지정하는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003e코드를 추가한 후 '지금 동기화'를 클릭하여 동기화하세요. 이 시점에서 특별히 어려운 점은 없어야 합니다.\u003c/p\u003e\n\u003ch1\u003e☛ 2) UserRepository.kt 추가\u003c/h1\u003e\n\u003cp\u003e이제 본격적으로 시작합니다. 이 부분에서는 DataStore(Preferences)를 사용하여 기기에 사용자 설정 정보(이 경우 사용자 이름)를 영구적으로 저장하는 논리를 작성할 겁니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우선, 이 패키지와 파일이 UI가 아닌 데이터를 관리하는 것임을 명확히 하기 위해 \"data\"라는 이름의 패키지를 생성하세요.\u003c/p\u003e\n\u003cp\u003ecom.example.projectname 패키지에서 마우스 오른쪽 버튼을 클릭하고 \"새 패키지\"를 선택한 후 \"data\"라고 입력하여 생성하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003edata 패키지를 생성한 후에 이 패키지 내부에 UserRepository란 이름의 Kotlin 파일을 만드세요. 만들 때 Class를 선택해주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose_3.png\"\u003e\n\u003cp\u003e특정 패키지에 파일을 추가하는 프로세스는 이후 단계에서도 동일합니다.\u003c/p\u003e\n\u003cp\u003e지금은 생성된 UserRepository.kt 파일의 UserRepository 클래스에서 DataStore(Preferences)를 사용하는 로직을 작성할 예정입니다.\u003c/p\u003e\n\u003cp\u003e먼저 DataStore를 사용할 때는 애플리케이션의 최상위 컨텍스트를 사용해야 하므로, 생성자로 dataStore라는 DataStore 타입을 지정해줍니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e/* UserRepository.kt */\nimport androidx.datastore.core.DataStore\nimport androidx.datastore.preferences.core.Preferences\u003c/p\u003e\n\u003cp\u003eclass UserRepository(private val dataStore: DataStore\u003cpreferences\u003e) {\u003c/preferences\u003e\u003c/p\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003cp\u003e이렇게 하면 UserRepository 클래스 내에서 컨텍스트를 정의할 필요가 없고, UserRepository 클래스는 오직 DataStore에 대한 로직만을 처리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eDataStore(Preferences)에서 데이터는 키 및 값으로 관리되며, 여기서 다루는 값은 문자열인 사용자 이름입니다. 따라서 stringPreferencesKey()를 사용하여 다음과 같이 문자열 값이 포함된 키를 정의합니다:\u003c/p\u003e\n\u003cp\u003e/* UserRepository.kt */\nimport androidx.datastore.preferences.core.stringPreferencesKey\u003c/p\u003e\n\u003cp\u003eclass UserRepository(private val dataStore: DataStore\u003cpreferences\u003e) {\nprivate companion object {\nval USER_NAME = stringPreferencesKey(\"user_name\")\n}\n}\u003c/preferences\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e프라이빗 컴패니언 객체로 정의하면 각 Preferences 키를 클래스 내에서 한 번만 존재하는 정적 객체(싱글톤)로 관리할 수 있습니다. 사용자 이름만 관리하는 것은 쉽지만, 다른 설정을 토글하거나 관리해야 하는 경우처럼 여러 키를 관리해야 하는 경우에는 컴패니언 객체를 사용하는 것이 더욱 유리합니다.\u003c/p\u003e\n\u003cp\u003e다음으로, 장치에 저장된 문자열 타입 값에 대한 속성을 정의합니다. 이는 데이터 스토어를 생성자로 받은 데이터의 데이터를 map()으로 확장하고, 앞서 컴패니언 객체에서 정의한 키를 지정하여 달성할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* UserRepository.kt */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserRepository\u003c/span\u003e(private val \u003cspan class=\"hljs-attr\"\u003edataStore\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDataStore\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003ePreferences\u003c/span\u003e\u003e) {\n   private companion object {\n       val \u003cspan class=\"hljs-variable constant_\"\u003eUSER_NAME\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003estringPreferencesKey\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"user_name\"\u003c/span\u003e)\n   }\n\n   val \u003cspan class=\"hljs-attr\"\u003ecurrentUserName\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFlow\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e =\n       dataStore.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emap\u003c/span\u003e { preferences -\u003e\n           preferences[\u003cspan class=\"hljs-variable constant_\"\u003eUSER_NAME\u003c/span\u003e] ?: \u003cspan class=\"hljs-string\"\u003e\"Unknown\"\u003c/span\u003e\n       }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e⚠️참고: 실제로는 데이터를 읽는 작업이 실패할 경우를 대비하여 에러를 처리하고 해당 코드를 포함해야 합니다. 그러나 코드를 간단하게 유지하기 위해 여기에서는 생략하였습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 이 설정으로 데이터를 읽을 수만 있기 때문에, 데이터를 저장하거나 업데이트하는 메소드를 추가해 봅시다. edit()를 사용하여 전달된 문자열을 저장하는 메소드를 추가해 보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* UserRepository.kt */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserRepository\u003c/span\u003e(private val \u003cspan class=\"hljs-attr\"\u003edataStore\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDataStore\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003ePreferences\u003c/span\u003e\u003e) {\n   private companion object {\n       val \u003cspan class=\"hljs-variable constant_\"\u003eUSER_NAME\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003estringPreferencesKey\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"user_name\"\u003c/span\u003e)\n   }\n\n   val \u003cspan class=\"hljs-attr\"\u003ecurrentUserName\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFlow\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\u003e =\n       dataStore.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emap\u003c/span\u003e { preferences -\u003e\n           preferences[\u003cspan class=\"hljs-variable constant_\"\u003eUSER_NAME\u003c/span\u003e] ?: \u003cspan class=\"hljs-string\"\u003e\"알 수 없음\"\u003c/span\u003e\n       }\n\n   suspend fun \u003cspan class=\"hljs-title function_\"\u003esaveUserName\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003euserName: \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e\u003c/span\u003e) {\n       dataStore.\u003cspan class=\"hljs-property\"\u003eedit\u003c/span\u003e { preferences -\u003e\n           preferences[\u003cspan class=\"hljs-variable constant_\"\u003eUSER_NAME\u003c/span\u003e] = userName\n       }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이로써 DataStore (Preferences)를 사용하기 위한 세 가지 필수 구성 요소가 완성되었습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e문자열을 값으로 가지는 키를 설정하는 것\u003c/li\u003e\n\u003cli\u003e값을 읽을 수 있는 프로퍼티\u003c/li\u003e\n\u003cli\u003e값을 저장할 수 있는 메소드\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eUserRepository.kt 파일의 코드 작성이 완료되었습니다.\u003c/p\u003e\n\u003cp\u003e하지만 우리는 아직 데이터 저장소를 생성자로 받을 준비를 하지 않았기 때문에 아직 작동하지 않을 것입니다. 다음 단계에서는 애플리케이션 컨텍스트를 사용할 준비를 하겠습니다.\u003c/p\u003e\n\u003ch1\u003e☛ 3) MyApplication 클래스 추가 및 설정\u003c/h1\u003e\n\u003cp\u003e이 단계에서는 UserRepository에서 사용할 애플리케이션 컨텍스트를 구성할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e먼저, com.example.projectname 패키지 내에 MyApplication.kt라는 파일을 만들어주세요 (클래스로 지정).\u003c/p\u003e\n\u003cp\u003e그런 다음, MyApplication.kt 파일의 MyApplication 클래스 바깥에서 dataStore를 Context 확장 속성으로 정의하고 특정 DataStore 인스턴스에 위임해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* MyApplication.kt */\u003c/span\u003e\nprivate val \u003cspan class=\"hljs-title class_\"\u003eContext\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edataStore\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDataStore\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003ePreferences\u003c/span\u003e\u003e by \u003cspan class=\"hljs-title function_\"\u003epreferencesDataStore\u003c/span\u003e(\n   name = \u003cspan class=\"hljs-string\"\u003e\"setting\"\u003c/span\u003e\n)\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApplication\u003c/span\u003e {\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이를 통해 어플리케이션의 모든 부분이 동일한 Context를 통해 DataStore에 액세스할 수 있게 되어 데이터 일관성을 보장하고 코드 재사용성을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* MyApplication.kt */\u003c/span\u003e\nprivate val \u003cspan class=\"hljs-title class_\"\u003eContext\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edataStore\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDataStore\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003ePreferences\u003c/span\u003e\u003e by \u003cspan class=\"hljs-title function_\"\u003epreferencesDataStore\u003c/span\u003e(\n  name = \u003cspan class=\"hljs-string\"\u003e\"setting\"\u003c/span\u003e\n)\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApplication\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eApplication\u003c/span\u003e() {\n  lateinit \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003euserRepository\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUserRepository\u003c/span\u003e\n  override fun \u003cspan class=\"hljs-title function_\"\u003eonCreate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eonCreate\u003c/span\u003e()\n    userRepository = \u003cspan class=\"hljs-title class_\"\u003eUserRepository\u003c/span\u003e(dataStore)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003euserRepository은 이전 단계에서 생성된 UserRepository 클래스를 상속받지만, 당연히 여기에서 초기화할 수 없습니다(데이터 스토어인 생성자를 지정할 수 없기 때문). 따라서 애플리케이션이 초기화될 때 이전에 정의한 Context.dataStore가 UserRepository 클래스로 전달되어야 합니다.\u003c/p\u003e\n\u003cp\u003e이 과정은 애플리케이션 전체에서 일관된 데이터 저장 메커니즘을 제공하여 UserRepository 클래스가 이 데이터 스토어를 사용하여 사용자 설정 및 정보를 관리할 수 있도록 합니다. 결과적으로 데이터 저장, 검색 및 업데이트가 애플리케이션 내의 어디에서든 쉽게 액세스할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 단계의 마지막에 AndroidManifest.xml 파일의 애플리케이션 태그에 android:name을 다음과 같이 추가하는 것을 잊지 마세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;!-- \u003cspan class=\"hljs-title class_\"\u003eAndroidManifest\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003exml\u003c/span\u003e --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eapplication\u003c/span\u003e\n   \u003cspan class=\"hljs-attr\"\u003eandroid:name\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\".MyApplication\"\u003c/span\u003e\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 사양을 따르면 MyApplication 클래스에 정의된 종속성이 MainActivity가 시작되기 전에 초기화됩니다.\u003c/p\u003e\n\u003cp\u003eMyApplication 클래스와 관련된 코딩 및 설정이 이제 완료되었지만, 코드의 역할과 의미가 간결함 때문에 이해하기 어려울 수 있다는 것을 이해합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 단계에서는 \"DataStore(Preferences)와 애플리케이션 컨텍스트(전체 앱을 통틀어 말하는 맥락)를 사용할 수 있게 해준다\"는 넓은 이해를 바탕으로 시작하는 것이 좋아요.\u003c/p\u003e\n\u003ch1\u003e☛ 4) ViewModel 추가 및 구성하기\u003c/h1\u003e\n\u003cp\u003e이전 단계에서 DataStore(Preferences)를 사용할 준비가 되었지만, 현재 상태에서는 UI가 어떤 변경 사항도 반영하지 않을 것입니다. 이번 단계에서는 ViewModel을 사용하여 UI의 책임을 처리하여 앱을 완성에 더 가깝게 이끌 것입니다.\u003c/p\u003e\n\u003cp\u003e먼저, 샘플.com.프로젝트명 \u003ccode\u003eui\u003c/code\u003e 패키지 내에 MyAppViewModel이라는 파일을 생성하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e자연스럽게 MyAppViewModel 클래스는 응용 프로그램 컨텍스트에 따라 다르게 구성된 UserRepository 클래스의 속성 및 메서드를 활용할 것입니다. 따라서 MyAppViewModel 내에서 UserRepository를 직접 사용할 수 없습니다. 대신에 다음과 같이 생성자로 userRepository를 지정합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* MyAppViewModel.kt */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e androidx.\u003cspan class=\"hljs-property\"\u003elifecycle\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eViewModel\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e com.\u003cspan class=\"hljs-property\"\u003eexample\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edatastoresample\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eUserRepository\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyAppViewModel\u003c/span\u003e(\n   private val \u003cspan class=\"hljs-attr\"\u003euserRepository\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUserRepository\u003c/span\u003e\n): \u003cspan class=\"hljs-title class_\"\u003eViewModel\u003c/span\u003e() {\n  \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 함으로써 UserRepository 클래스가 응용 프로그램 컨텍스트에 의존하고 있고, MyAppViewModel 클래스가 UserRepository 클래스에 의존하고 있는 관계를 설정했습니다. MyAppViewModel이 초기화될 때 UserRepository가 초기화되어야 하므로 ViewModel을 사용하기 어렵다고 걱정할 수도 있겠지만, 이 의존성 문제를 이번 단계의 끝에서 해결할 것입니다.\u003c/p\u003e\n\u003cp\u003e지금은 의존성 해결을 제외하고, 저장된 사용자 이름을 검색하는 속성을 정의하기 위해 시작하겠습니다. 그 전에, UI 상태를 관리하는 UiState라는 데이터 클래스를 MyAppViewModel 클래스 외부에 정의해보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* MyAppViewModel.kt */\u003c/span\u003e\ndata \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUiState\u003c/span\u003e (\n   val \u003cspan class=\"hljs-attr\"\u003euserName\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyAppViewModel\u003c/span\u003e(\n   private val \u003cspan class=\"hljs-attr\"\u003euserRepository\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUserRepository\u003c/span\u003e\n): \u003cspan class=\"hljs-title class_\"\u003eViewModel\u003c/span\u003e() {\n  \n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 UiState 데이터 클래스를 사용하여 UserRepository 클래스에 정의된 currentUserName 속성에서 데이터를 비동기적으로 로드합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* MyAppViewModel.kt */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyAppViewModel\u003c/span\u003e(\n   private val \u003cspan class=\"hljs-attr\"\u003euserRepository\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUserRepository\u003c/span\u003e\n): \u003cspan class=\"hljs-title class_\"\u003eViewModel\u003c/span\u003e() {\n   val \u003cspan class=\"hljs-attr\"\u003euiState\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eStateFlow\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eUiState\u003c/span\u003e\u003e =\n       userRepository.\u003cspan class=\"hljs-property\"\u003ecurrentUserName\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emap\u003c/span\u003e { userName -\u003e\n           \u003cspan class=\"hljs-title class_\"\u003eUiState\u003c/span\u003e(userName)\n       }.\u003cspan class=\"hljs-title function_\"\u003estateIn\u003c/span\u003e(\n           scope = viewModelScope,\n           started = \u003cspan class=\"hljs-title class_\"\u003eSharingStarted\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eWhileSubscribed\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e),\n           initialValue = \u003cspan class=\"hljs-title class_\"\u003eUiState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Unknown\"\u003c/span\u003e)\n       )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eViewModel의 UI 상태(UiState)는 StateFlow 형식으로 관리되어야 하므로, Flow 형식에서 StateFlow 형식으로 변환하고, .stateIn()을 사용하여 구독을 설정하고 초기 값이 설정되도록 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eSharingStarted.WhileSubscribed(5000)은 구독이 종료된 후 5초 동안 여전히 값이 방출되며, 구독을 취소한 후에도 잠시 동안 UI 구성 요소가 데이터 업데이트를 받을 수 있습니다. 값 구독을 최적화하기 위한 이 조정은 복잡해 보일 수 있지만, 이를 \"값 구독을 최적화하는 설정\"으로 생각할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그렇게 하면, 저장된 사용자 이름(문자열) 정보를 UI 상태 관리를 위한 값으로 읽을 준비가 되었습니다. 그 다음으로, 값을 저장하거나 업데이트하는 메서드를 추가해 봅시다. 이는 UserRepository 클래스에서 정의된 것과 비슷한 방식으로 구현할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* MyAppViewModel.kt */\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efun\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003esaveUserName\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(userName: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e {\n    viewModelScope.launch {\n        userRepository.saveUserName(userName)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUserRepository 클래스에서 정의된 saveUserName() 메서드는 suspend fun으로 정의되어 있기 때문에 coroutine scope 내에서 호출되어야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 우리는 값을 읽고 저장(업데이트)할 수 있게 되었는데, 남은 문제는 MyViewModel이 UserRepository에 의존하고 UserRepository가 애플리케이션 컨텍스트에 의존하는 문제입니다. 이를 해결해 봅시다.\u003c/p\u003e\n\u003cp\u003e다음과 같이 MyViewModel 클래스에 companion object를 정의하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* MyAppViewModel.kt */\u003c/span\u003e\ncompanion object {\n   val \u003cspan class=\"hljs-title class_\"\u003eFactory\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eViewModelProvider\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFactory\u003c/span\u003e = viewModelFactory {\n       initializer {\n           val application = (\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e[\u003cspan class=\"hljs-variable constant_\"\u003eAPPLICATION_KEY\u003c/span\u003e] \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyApplication\u003c/span\u003e)\n           \u003cspan class=\"hljs-title class_\"\u003eMyAppViewModel\u003c/span\u003e(application.\u003cspan class=\"hljs-property\"\u003euserRepository\u003c/span\u003e)\n       }\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이전 코드와 비교했을 때, 처음에는 더욱 불분명해 보일 수 있습니다. 그러나 이 코드의 목적은 MyAppViewModel의 인스턴스를 생성할 때 애플리케이션 컨텍스트로부터 필요한 종속성(이 경우 userRepository)을 주입하는 것입니다. 이를 통해 ViewModel을 테스트하고 재사용하기 쉬워지며 종속성을 명시적으로 관리할 수 있도록 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e본질적으로, 이 사용자 정의는 ViewModel (MyAppViewModel)을 초기화할 때 발생하여 MyAppViewModel이 UserRepository에 의존하는 문제를 해결합니다.\u003c/p\u003e\n\u003cp\u003e마지막 단계는 초기에 제시된 MainScreen.kt를 수정하여 버튼을 탭할 때 데이터(사용자 이름)를 영구적으로 저장하고 저장된 데이터를 문자열로 표시하여 앱을 완성하는 것입니다.\u003c/p\u003e\n\u003ch1\u003e☛ 5) 뷰 업데이트\u003c/h1\u003e\n\u003cp\u003e지금까지의 단계에서 DataStore (Preferences)를 사용하여 지속적인 데이터 저장 및 검색을 준비했으며 ViewModel을 사용하여 UI를 관리했습니다. 이제 MainScreen.kt를 업데이트하여 ViewModel을 통해 저장된 데이터가 UI에 반영되도록 할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e먼저, 다음과 같이 MainScreen()에 MyAppViewModel을 매개변수로 지정하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* MainScreen.kt */\u003c/span\u003e\n@\u003cspan class=\"hljs-title class_\"\u003eComposable\u003c/span\u003e\nfun \u003cspan class=\"hljs-title class_\"\u003eMainScreen\u003c/span\u003e(\n   \u003cspan class=\"hljs-attr\"\u003emodifier\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eModifier\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eModifier\u003c/span\u003e,\n   \u003cspan class=\"hljs-attr\"\u003emyAppViewModel\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMyAppViewModel\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003eviewModel\u003c/span\u003e(factory = \u003cspan class=\"hljs-title class_\"\u003eMyAppViewModel\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eFactory\u003c/span\u003e)\n) { … }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMyAppViewModel에서 정의된 Factory를 factory 매개변수에 전달함으로써, 이 MyAppViewModel의 초기화는 이전 챕터에서 설정한 사용자 지정 초기화 설정이 적용됩니다.\u003c/p\u003e\n\u003cp\u003e다음으로 UI 상태(이 경우 저장된 사용자 이름)를 정의하려면 MainScreen 함수 내에서 savedUserName을 다음과 같이 정의하세요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* MainScreen.kt */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eval\u003c/span\u003e savedUserName \u003cspan class=\"hljs-keyword\"\u003eby\u003c/span\u003e myAppViewModel.uiState.collectAsState()\n\nText(\n   text = \u003cspan class=\"hljs-string\"\u003e\"안녕하세요, \u003cspan class=\"hljs-subst\"\u003e${savedUserName.userName}\u003c/span\u003e님\"\u003c/span\u003e,\n   style = MaterialTheme.typography.displaySmall,\n   modifier = Modifier\n       .padding(top = \u003cspan class=\"hljs-number\"\u003e32.\u003c/span\u003edp)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, TextField에 입력된 문자열이 버튼을 클릭했을 때 저장되도록 하려면, onclick 매개변수에 전달할 함수를 설정하면 됩니다. 이렇게 하면 끝이죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-kotlin\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* MainScreen.kt */\u003c/span\u003e\nButton(\n   onClick = { myAppViewModel.saveUserName(userInput) }\n) {\n   Text(text = \u003cspan class=\"hljs-string\"\u003e\"저장\"\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e앱을 빌드하고 사용자 이름을 입력한 후 SAVE 버튼을 탭한 다음, 앱을 완전히 종료하고 다시 엽니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래 저장된 데이터가 앱을 종료한 후에도 지워지지 않고 유지되는 것을 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e잘 했어요! 이렇게 하면 DataStore (Preferences)의 기본 구현이 완료됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e☛ 마무리로\u003c/h1\u003e\n\u003cp\u003e개발 초보자들이 필요한 코드를 외우기에 집중하는 경향이 있다는 것을 알았어요. 하지만, 중요한 것은 코드를 외우는 것이 아니에요. 시험이 아니기 때문에, 과거에 작성한 코드를 잊어버렸을 때는 열심히 다시 작성하기보다는 그냥 복사해서 붙여넣는 것이 괜찮아요.\u003c/p\u003e\n\u003cp\u003e실제로, 무언가를 구현할 때마다 코드를 처음부터 쓰는 대신, 한 번 작성한 코드를 템플릿으로 관리하는 것이 더 효율적하다고 생각해요. Git이나 클라우드 서비스를 사용해서 작성한 코드를 손쉽게 재사용할 수 있게 만들어두면 좋아요.\u003c/p\u003e\n\u003cp\u003e하지만, 코드를 복사하고 붙여넣을 때도 그 코드가 무엇을 의미하는지와 어떤 역할을 하는지 이해하는 것이 중요해요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\"I'm happy to help you out! However, I might not fully understand the requested change. It's important to avoid blindly copying and pasting code; instead, try to understand its purpose to improve your coding skills. Here is the code snippet in Markdown format:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;aside\u003e\n \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n   Thank you for reading!\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e\u003e\u003c/span\u003e\n   If you enjoyed this post, \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebr\u003c/span\u003e\u003e\u003c/span\u003e\n   I'd appreciate claps. 😄\n \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003easide\u003c/span\u003e\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-01-PersistentDataStorageUsingDataStorePreferencesinJetpackCompose"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>