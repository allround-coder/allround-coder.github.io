<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>AI와 함께 하는 프로그래밍,  API 호출하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-27-ProgrammingwithAICallingAPIs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="AI와 함께 하는 프로그래밍,  API 호출하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="AI와 함께 하는 프로그래밍,  API 호출하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-ProgrammingwithAICallingAPIs_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-27-ProgrammingwithAICallingAPIs" data-gatsby-head="true"/><meta name="twitter:title" content="AI와 함께 하는 프로그래밍,  API 호출하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-ProgrammingwithAICallingAPIs_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 18:37" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">AI와 함께 하는 프로그래밍,  API 호출하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="AI와 함께 하는 프로그래밍,  API 호출하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">17<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-ProgrammingwithAICallingAPIs&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>몇 주 전에 AI 프로그래밍 수업을 가르쳐달라는 요청을 받았어요. 그래서 슬라이드와 코드를 열심히 준비했는데, 물질들이 커져갔어요. 그래서 이 모든 자료들을 하나로 모아 시리즈 형식의 글로 만들어보자는 생각이 들었죠. 수업 이후에 이를 참고할 수 있는 사람들이 많을 것이라 생각해요. 또한 이 글들은 세션 이후에도 수업에 도움이 될 수 있는 참고 자료가 될 거예요.</p>
<p>그래서 이 수업의 첫 번째 부분을 공유합니다. 이 부분은 REST API 및 라이브러리를 통해 AI 공급업체 API를 호출하는데 관한 내용입니다.</p>
<p>참고: 이것은 초보자를 위한 자료이므로 제가 생략한 내용이 많습니다. 이는 포괄적인 내용이 아니고 이해를 돕기 위한 것입니다.</p>
<p><img src="/assets/img/2024-05-27-ProgrammingwithAICallingAPIs_0.png" alt="Programming with AI Image"></p>
<div class="content-ad"></div>
<p>따뜻한 시작부터 시작해봅시다. 그것은 몇 가지 API를 호출하는 것을 의미합니다. AI를 활용하기 위해 API를 호출하는 것은 AI 능력에 가장 흔하고 쉬운 방법이에요. 많은 사람들이 이를 비웃고 "충분히 AI가 아니다" 라고 생각하지만, 그건 좀 어리석은 생각이죠 - 시스템의 가치는 사용자에게 기능을 제공하는 것이지 얼마나 많은 AI가 사용되었는지에 달려 있지 않습니다.</p>
<p>현재 OpenAI (GPT), Google (Gemini), Anthropic (Claude), Mistral (Mistral), Cohere (Command) 등 다양한 API 제공업체들이 있어요. 이외에도 Replicate, Anyscale, Modal, Banana 등 다양한 기능을 제공하는 플랫폼 제공자들도 있습니다.</p>
<p>이 글에서는 우리가 REST API를 호출하는 것으로 간단히 시작할 거에요.</p>
<h1>REST APIs</h1>
<div class="content-ad"></div>
<p>내가 아는 바에 의하면, 각 제공업체는 REST API를 갖고 있어요. 그들을 호출하는 것은 매우 간단해요. curl과 API URL 엔드포인트 그리고 JSON 페이로드를 전달하기만 하면 돼요.</p>
<p>여기 채팅 완성을 위해 OpenAI API를 호출하는 예시가 있어요.</p>
<pre><code class="hljs language-js">$ curl <span class="hljs-attr">https</span>:<span class="hljs-comment">//api.openai.com/v1/chat/completions \</span>
  -H <span class="hljs-string">"Content-Type: application/json"</span> \
  -H <span class="hljs-string">"Authorization: Bearer $OPENAI_API_KEY"</span> \
  -d <span class="hljs-string">'{
    "model": "gpt-4o",
    "messages": [
      {
        "role": "system",
        "content": "You are a helpful assistant."
      },
      {
        "role": "user",
        "content": "Why is the sky blue?"
      }
    ]
  }'</span>
</code></pre>
<p>각 제공업체로부터 유효한 API 키가 필요해요. 대부분의 경우 계정에 가입하고 API 키를 생성하기만 하면 돼요. API 키를 얻었다면 직접 전달하거나 환경 변수로 설정할 수 있어요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">$ <span class="hljs-keyword">export</span> <span class="hljs-variable constant_">OPENAI_API_KEY</span>=&#x3C;당신의 <span class="hljs-variable constant_">API</span> 키>
</code></pre>
<p>API를 호출하면 다음과 같은 결과가 반환되어야 합니다:</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">"id"</span>: <span class="hljs-string">"chatcmpl-9RWBzicE7v7A1ZRLWUMX3a6zwooWd"</span>,
  <span class="hljs-string">"object"</span>: <span class="hljs-string">"chat.completion"</span>,
  <span class="hljs-string">"created"</span>: <span class="hljs-number">1716345631</span>,
  <span class="hljs-string">"model"</span>: <span class="hljs-string">"gpt-4o-2024-05-13"</span>,
  <span class="hljs-string">"choices"</span>: [
    {
      <span class="hljs-string">"index"</span>: <span class="hljs-number">0</span>,
      <span class="hljs-string">"message"</span>: {
        <span class="hljs-string">"role"</span>: <span class="hljs-string">"assistant"</span>,
        <span class="hljs-string">"content"</span>: <span class="hljs-string">"Rayleigh 산란이라는 현상으로 인해 하늘은 푸르게 보입니다. 더 자세한 설명은 다음과 같습니다:\n\n1. **태양빛 구성**: 태양빛 또는 백색광은 서로 다른 파장을 가진 색 스펙트럼으로 구성되어 있습니다. 가시 스펙트럼은 짧은 파장(파랑과 보라색)에서 긴 파장(빨강과 주황색)까지 범위에 걸쳐 있습니다.\n\n2. **대기와의 상호작용**: 태양빛이 지구 대기에 들어오면 분자와 작은 입자와 상호작용합니다. 짧은 파장의 빛(파랑과 보라색)은 이러한 입자에 의해 더 효과적으로 산란되며, 긴 파장(빨강, 주황, 노랑)은 그보다 적게 산란됩니다. \n\n3. **인간의 지각**: 보라색 빛은 파랑 빛보다 더 많이 산란되지만, 우리 눈은 파랑 빛에 민감하며, 태양빛에는 처음부터 보라색 빛이 많이 없습니다. 게다가 일부 보라색 빛은 상층 대기에 흡수됩니다. 결과적으로 우리는 하늘을 파랗게 보게 됩니다.\n\n4. **결과적인 푸른 하늘**: 산란된 파랑 빛이 각 방향에서 우리 눈에 도달하여, 주로 지면에서 낮에 하늘을 보면 하늘이 파랗게 보입니다.\n\n이 산란 효과는 태양이 하늘에 낮게 있을 때 더 명확하게 나타납니다. 그래서 일출과 일몰 시 빨간색 계열을 보게 됩니다. 이러한 경우에는 빛이 더 많은 대기를 통과하면서 파랑과 녹색빛이 더 많이 산란되고, 빨강과 주황색이 하늘을 지배하게 됩니다."</span>
      },
      <span class="hljs-string">"logprobs"</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-string">"finish_reason"</span>: <span class="hljs-string">"stop"</span>
    }
  ],
  <span class="hljs-string">"usage"</span>: {
    <span class="hljs-string">"prompt_tokens"</span>: <span class="hljs-number">23</span>,
    <span class="hljs-string">"completion_tokens"</span>: <span class="hljs-number">286</span>,
    <span class="hljs-string">"total_tokens"</span>: <span class="hljs-number">309</span>
  },
  <span class="hljs-string">"system_fingerprint"</span>: <span class="hljs-string">"fp_729ea513f7"</span>
}
</code></pre>
<p>아마도 OpenAI가 이러한 API를 처음으로 개발한 것이거나, 더 인기가 많아서 다른 많은 공급자들이 그들의 REST API에서 비슷한 형식을 사용하는 것일 수도 있습니다. 예를 들어, Anthropic의 형식은 다음과 같습니다.</p>
<div class="content-ad"></div>
<p>$ curl <a href="https://api.anthropic.com/v1/messages" rel="nofollow" target="_blank">https://api.anthropic.com/v1/messages</a> <br>
-H "content-type: application/json" <br>
-H "x-api-key: $ANTHROPIC_API_KEY" <br>
-H "anthropic-version: 2023-06-01" <br>
-d '{
"model": "claude-3-opus-20240229",
"max_tokens": 1024,
"messages": [
{"role": "user", "content": "Why is the sky blue?"}
]
}'</p>
<p>위에서 보듯이, API 키는 다른 헤더를 통해 전달되지만 페이로드는 거의 동일하지만 모델 작동 방식에 따라 약간 차이가 있습니다. 예를 들어, Anthropic에서 메시지의 일부로 시스템 역할 콘텐츠를 전달할 수 없습니다.</p>
<p>또 다른 예시는 Mistral의 것입니다.</p>
<p>$ curl <a href="https://api.mistral.ai/v1/chat/completions" rel="nofollow" target="_blank">https://api.mistral.ai/v1/chat/completions</a> <br>
--header 'Content-Type: application/json' <br>
--header 'Accept: application/json' <br>
--header "Authorization: Bearer $MISTRAL_API_KEY" <br>
--data '{
"model": "mistral-large-latest",
"messages": [
{
"role": "user",
"content": "Why is the sky blue?"
}
]
}'</p>
<div class="content-ad"></div>
<p>그런데, Google은 실제로 API에 대해 약간 다른 방식을 사용하며 API 키를 URL 쿼리의 일부로 전달하고 모델을 URL의 일부로 포함시킵니다. 페이로드도 다르지만 아이디어는 거의 동일합니다.</p>
<pre><code class="hljs language-js">$ curl <span class="hljs-string">"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=$API_KEY"</span> \
  -H <span class="hljs-string">'Content-Type: application/json'</span> \
  -d <span class="hljs-string">'{ "contents":[
    { "parts":[{"text": "Why is the sky blue?"}]}
  ]
}'</span>
</code></pre>
<p>REST API는 정말 유용하고 거의 보편적입니다. 제공 업체에서 직접 지원하지 않는 언어로 프로그래밍하는 경우 HTTP 클라이언트 라이브러리를 사용하여 REST API를 직접 호출할 수 있습니다. 대부분의 합리적인 프로그래밍 언어에는 표준 라이브러리나 서드 파티 라이브러리에 HTTP 클라이언트 라이브러리가 있으므로 문제 없습니다.</p>
<p>그러나 대부분의 제공 업체는 대부분 Python을 지원하기도 합니다. 그 이유는 대부분의 AI 관련 작업이 Python으로 프로그래밍되기 때문입니다.</p>
<div class="content-ad"></div>
<h1>파이썬</h1>
<p>예를 들어, OpenAI를 호출하는 방법은 이렇습니다. Python 라이브러리를 사용합니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI
client = OpenAI()

completion = client.chat.completions.create(
  model=<span class="hljs-string">"gpt-4o"</span>,
  messages=[
    {<span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"You are a helpful assistant."</span>},
    {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"Why is the sky blue?"</span>}
  ]
)

<span class="hljs-built_in">print</span>(completion.choices[<span class="hljs-number">0</span>].message.content)
</code></pre>
<p>너무 간단하죠? 클라이언트를 만들 때 매개변수와 옵션을 설정할 수 있지만 그게 전부입니다. API 키를 더 이상 지정할 필요가 없다는 것을 알아채셨을 것입니다. 환경 변수로 API 키를 설정했다면 Python 라이브러리가 해당 환경 변수에서 가져올 거에요.</p>
<div class="content-ad"></div>
<p>안녕하세요! Anthropic과 Mistral도 마찬가지에요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> anthropic

message = anthropic.<span class="hljs-title class_">Anthropic</span>().<span class="hljs-property">messages</span>.<span class="hljs-title function_">create</span>(
    model=<span class="hljs-string">"claude-3-opus-20240229"</span>,
    max_tokens=<span class="hljs-number">1024</span>,
    messages=[
        {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"Why is the sky blue?"</span>}
    ]
)

<span class="hljs-title function_">print</span>(message.<span class="hljs-property">content</span>)
</code></pre>
<p>프랜들리하게말하자면,</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> mistralai.<span class="hljs-property">client</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">MistralClient</span>
<span class="hljs-keyword">from</span> mistralai.<span class="hljs-property">models</span>.<span class="hljs-property">chat_completion</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChatMessage</span>

client = <span class="hljs-title class_">MistralClient</span>()

chat_response = client.<span class="hljs-title function_">chat</span>(
    model=<span class="hljs-string">"mistral-large-latest"</span>,
    messages=[
        <span class="hljs-title class_">ChatMessage</span>(role=<span class="hljs-string">"user"</span>, content=<span class="hljs-string">"Why is the sky blue?"</span>)
    ],
)

<span class="hljs-title function_">print</span>(chat_response.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span>.<span class="hljs-property">content</span>)
</code></pre>
<div class="content-ad"></div>
<p>Google의 Python 라이브러리도 사용하기 매우 쉽지만, 다른 라이브러리들과 조금 다릅니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> google.generativeai <span class="hljs-keyword">as</span> genai

model = genai.GenerativeModel(<span class="hljs-string">'gemini-1.5-flash-latest'</span>)
chat = model.start_chat(history=[])
response = chat.send_message(<span class="hljs-string">"Why is the sky blue?"</span>)

<span class="hljs-built_in">print</span>(response.text)
</code></pre>
<p>파이썬은 매우 잘 지원되고 있는 것을 보실 수 있습니다. 다른 잘 지원되는 언어는 JavaScript입니다.</p>
<h1>Javascript</h1>
<div class="content-ad"></div>
<p>파이썬이 가장 잘 지원되는 언어라고 해도, 인기가 많기 때문에 자바스크립트/타입스크립트도 많이 사용됩니다. 자바스크립트와 node.js를 사용하여 OpenAI API에 액세스하는 방법을 살펴봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">OpenAI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"openai"</span>;

<span class="hljs-keyword">const</span> openai = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAI</span>();

<span class="hljs-keyword">const</span> completion = <span class="hljs-keyword">await</span> openai.<span class="hljs-property">chat</span>.<span class="hljs-property">completions</span>.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">model</span>: <span class="hljs-string">"gpt-4o"</span>,
  <span class="hljs-attr">messages</span>: [
      { <span class="hljs-attr">role</span>: <span class="hljs-string">"system"</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">"You are a helpful assistant."</span> },
      { <span class="hljs-attr">role</span>: <span class="hljs-string">"user"</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">"Why is the sky blue?"</span> }
  ],    
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(completion.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>]);
</code></pre>
<p>파이썬 라이브러리에서와 같이 API 키를 더 이상 입력할 필요가 없었습니다. 환경 변수로 API 키를 설정한 경우, 자바스크립트 라이브러리가 환경 변수에서 API 키를 자동으로 인식합니다.</p>
<p>이것이 JSON 결과 출력입니다 (completion.choices[0]만 표시).</p>
<div class="content-ad"></div>
<p>Markdown 형식으로 표를 변경하려면 다음과 같이 하면 됩니다.</p>
<pre><code class="hljs language-js">{
  <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">message</span>: {
    <span class="hljs-attr">role</span>: <span class="hljs-string">'assistant'</span>,
    <span class="hljs-attr">content</span>: <span class="hljs-string">"하늘이 파란 이유는 Rayleigh 산란이라는 현상 때문입니다. 이 산란은 태양광이 지구 대기로 들어와 공기 속 분자와 작은 입자들과 상호 작용할 때 발생합니다.\n"</span> +
      <span class="hljs-string">'\n'</span> +
      <span class="hljs-string">"하늘이 파란 색으로 보이는 이유를 단계별로 살펴보겠습니다:\n"</span> +
      <span class="hljs-string">'\n'</span> +
      <span class="hljs-string">'1. **태양광 조성**: 태양광 또는 백색광은 여러 색상으로 구성되어 있으며 각각 다른 파장을 가지고 있습니다. 색상은 보라색과 파랑 (파장이 짧은)에서 빨강과 주황 (파장이 긴)까지 이어집니다.\n'</span> +
      <span class="hljs-string">'\n'</span> +
      <span class="hljs-string">'2. **산란**: 태양광이 대기를 통과할 때 가스 분자와 작은 입자와 충돌합니다. 빛의 짧은 파장(파랑과 보라색)은 이러한 분자와 입자들에 의해 더 많이 길거나 (빨강과 주황과 같은)보다 더 넓은 범위로 산란됩니다.\n'</span> +
      <span class="hljs-string">'\n'</span> +
      <span class="hljs-string">'3. **인간의 지각**: 비록 보라색 빛이 파란 빛보다 더 많이 산란되지만, 우리 눈은 파란 빛에 민감하고 보라색 빛에 덜 민감합니다. 또한 일부의 보라색 빛은 상층 대기에 흡수됩니다. 따라서 우리에게는 하늘이 주로 파란색으로 보입니다.\n'</span> +
      <span class="hljs-string">'\n'</span> +
      <span class="hljs-string">'4. **시야각**: 하늘을 올려다볼 때, 우리는 하늘의 모든 부분에서 나오는 이 산란된 파란 빛을 보며 그 특징적인 색상을 부여합니다.\n'</span> +
      <span class="hljs-string">'\n'</span> +
      <span class="hljs-string">"요약하면, 하늘이 파란 이유는 태양광의 짧은 파장인 파란색이 지구 대기의 분자들에 의해 모든 방향으로 더 넓게 산란되고, 우리 눈이 파란색 빛을 보는 데 더 잘 적응되어있기 때문입니다."</span>
  },
  <span class="hljs-attr">logprobs</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">finish_reason</span>: <span class="hljs-string">'stop'</span>
}
</code></pre>
<p>마찬가지로, Javascript와 node.js를 사용하여 Anthropic API를 호출하는 방법은 아래와 같습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Anthropic</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@anthropic-ai/sdk'</span>;

<span class="hljs-keyword">const</span> anthropic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Anthropic</span>();

<span class="hljs-keyword">const</span> completion = <span class="hljs-keyword">await</span> anthropic.<span class="hljs-property">messages</span>.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">model</span>: <span class="hljs-string">"claude-3-haiku-20240307"</span>,
  <span class="hljs-attr">max_tokens</span>: <span class="hljs-number">1024</span>,
  <span class="hljs-attr">messages</span>: [
    {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"하늘이 파란 이유는 무엇인가요?"</span>}
  ]
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(completion);
</code></pre>
<p>다른 공급자들로는 진행하지 않겠지만, 아이디어를 얻으실 수 있습니다. 공식적으로 지원되는 라이브러리를 사용하시려면 Python 및 Javascript가 좋습니다. REST API 외에도 Python 및 Javascript를 포함한 대부분의 공급자는 다른 언어에 대한 공식 지원이 없지만 Google은 훨씬 더 다양한 언어를 지원합니다.</p>
<div class="content-ad"></div>
<p>그러나 다른 언어용 라이브러리가 없는 것은 아닙니다.</p>
<h1>서드 파티 라이브러리</h1>
<p>주변에는 다양한 서드 파티 라이브러리가 있습니다. OpenAI 문서를 살펴보면 대부분의 인기 있는 언어에 대한 서드 파티 라이브러리 지원이 있습니다. 예를 들어, go-openai 패키지를 사용하면 Go에서 OpenAI 라이브러리를 호출할 수 있습니다.</p>
<pre><code class="hljs language-js">package main

<span class="hljs-keyword">import</span> (
 <span class="hljs-string">"context"</span>
 <span class="hljs-string">"fmt"</span>
 <span class="hljs-string">"os"</span>

 openai <span class="hljs-string">"github.com/sashabaranov/go-openai"</span>
)

func <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
 client := openai.<span class="hljs-title class_">NewClient</span>(os.<span class="hljs-title class_">Getenv</span>(<span class="hljs-string">"OPENAI_API_KEY"</span>))
 resp, err := client.<span class="hljs-title class_">CreateChatCompletion</span>(
  context.<span class="hljs-title class_">Background</span>(),
  openai.<span class="hljs-property">ChatCompletionRequest</span>{
   <span class="hljs-title class_">Model</span>: openai.<span class="hljs-property">GPT4o</span>,
   <span class="hljs-title class_">Messages</span>: []openai.<span class="hljs-property">ChatCompletionMessage</span>{
    {
     <span class="hljs-title class_">Role</span>:    openai.<span class="hljs-property">ChatMessageRoleUser</span>,
     <span class="hljs-title class_">Content</span>: <span class="hljs-string">"Why is the sky blue?"</span>,
    },
   },
  },
 )

 <span class="hljs-keyword">if</span> err != nil {
  fmt.<span class="hljs-title class_">Printf</span>(<span class="hljs-string">"ChatCompletion error: %v\n"</span>, err)
  <span class="hljs-keyword">return</span>
 }

 fmt.<span class="hljs-title class_">Println</span>(resp.<span class="hljs-property">Choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">Message</span>.<span class="hljs-property">Content</span>)
}
</code></pre>
<div class="content-ad"></div>
<p>저기요! 여기 SwiftOpenAI라는 Swift용 써드파티 OpenAI 라이브러리가 있어요. XCode 프로젝트에서 패키지 종속성으로 추가해서 사용할 수 있어요. 이 함수는 OpenAI API를 호출하는 예시에요.</p>
<pre><code class="hljs language-js">    func <span class="hljs-title function_">sendMessage</span>() <span class="hljs-keyword">async</span> {
        <span class="hljs-keyword">let</span> input = userInput.<span class="hljs-title function_">trimmingCharacters</span>(<span class="hljs-attr">in</span>: .<span class="hljs-property">whitespacesAndNewlines</span>)
        guard !input.<span class="hljs-property">isEmpty</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
        
        <span class="hljs-keyword">let</span> message = <span class="hljs-title class_">Message</span>(<span class="hljs-attr">content</span>: input, <span class="hljs-attr">isUser</span>: <span class="hljs-literal">true</span>)
        messages.<span class="hljs-title function_">append</span>(message)
        userInput = <span class="hljs-string">""</span>
        
        <span class="hljs-keyword">let</span> openAI = <span class="hljs-title class_">SwiftOpenAI</span>(<span class="hljs-attr">apiKey</span>: <span class="hljs-title class_">Config</span>.<span class="hljs-property">openAIKey</span>)
        <span class="hljs-keyword">let</span> <span class="hljs-attr">msgs</span>: [<span class="hljs-title class_">MessageChatGPT</span>] = [
            <span class="hljs-title class_">MessageChatGPT</span>(<span class="hljs-attr">text</span>: <span class="hljs-string">"You are a helpful assistant."</span>, <span class="hljs-attr">role</span>: .<span class="hljs-property">system</span>),
            <span class="hljs-title class_">MessageChatGPT</span>(<span class="hljs-attr">text</span>: input, <span class="hljs-attr">role</span>: .<span class="hljs-property">user</span>)
        ]
        
        <span class="hljs-keyword">let</span> optionalParameters = <span class="hljs-title class_">ChatCompletionsOptionalParameters</span>(
            <span class="hljs-attr">temperature</span>: <span class="hljs-number">0.7</span>,
            <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">maxTokens</span>: <span class="hljs-number">1024</span>
        )
        
        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">let</span> stream = <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> openAI.<span class="hljs-title function_">createChatCompletionsStream</span>(
                <span class="hljs-attr">model</span>: .<span class="hljs-title function_">gpt4o</span>(.<span class="hljs-property">base</span>),
                <span class="hljs-attr">messages</span>: msgs,
                <span class="hljs-attr">optionalParameters</span>: optionalParameters
            )
            
            <span class="hljs-keyword">let</span> resp = <span class="hljs-title class_">Message</span>(<span class="hljs-attr">content</span>: <span class="hljs-string">""</span>, <span class="hljs-attr">isUser</span>: <span class="hljs-literal">false</span>)
            messages.<span class="hljs-title function_">append</span>(resp)
            
            <span class="hljs-keyword">for</span> <span class="hljs-keyword">try</span> <span class="hljs-keyword">await</span> response <span class="hljs-keyword">in</span> stream {
                <span class="hljs-keyword">let</span> content = response.<span class="hljs-property">choices</span>[<span class="hljs-number">0</span>].<span class="hljs-property">delta</span>?.<span class="hljs-property">content</span> ?? <span class="hljs-string">""</span>
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> lastMessage = messages.<span class="hljs-property">last</span>, !lastMessage.<span class="hljs-property">isUser</span> {
                    <span class="hljs-keyword">let</span> updatedContent = lastMessage.<span class="hljs-property">content</span> + content
                    messages[messages.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>] = <span class="hljs-title class_">Message</span>(<span class="hljs-attr">content</span>: updatedContent, <span class="hljs-attr">isUser</span>: <span class="hljs-literal">false</span>)
                }
            }
        } <span class="hljs-keyword">catch</span> {
            <span class="hljs-title function_">print</span>(<span class="hljs-string">"Error: \(error)"</span>)
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> lastMessage = messages.<span class="hljs-property">last</span>, !lastMessage.<span class="hljs-property">isUser</span> {
                messages[messages.<span class="hljs-property">count</span> - <span class="hljs-number">1</span>] = <span class="hljs-title class_">Message</span>(<span class="hljs-attr">content</span>: <span class="hljs-string">"Cannot get response from OpenAI: \(error)"</span>, <span class="hljs-attr">isUser</span>: <span class="hljs-literal">false</span>)
            }
        }
    }
</code></pre>
<p>이 모든 써드파티 라이브러리들은 좋지만 대부분이 한 제공업체만 지원해요. 여러 제공업체에 접근하려면 보통 동시에 몇 개의 라이브러리를 사용하거나 LLM 프레임워크를 시도해볼 수도 있어요.</p>
<h1>LLM 프레임워크</h1>
<div class="content-ad"></div>
<p>LLM 프레임워크는 LLM 기반 어플리케이션을 작성할 수 있게 해주는 어플리케이션 프레임워크의 일종입니다. 이러한 프레임워크는 지원과 구조를 제공하며, 일반적으로 LLM 기반 어플리케이션을 작성하는 방법을 표현합니다.</p>
<p>다양한 LLM 프레임워크가 있으며, 그 중에는 공식으로 지원되거나 제3자 라이브러리보다 인기가 있는 것도 있습니다. 이는 이러한 프레임워크가 개발자에게 다양한 능력을 제공하기 때문입니다. 이를 통해 여러 LLM 제공 업체에 동시에 연결하고, 여러 데이터 소스에 연결하며, 기본 LLM 위에 에이전트를 구현할 수 있습니다.</p>
<p>Langchain, LlamaIndex, Haystack 등 여러 프레임워크가 있지만, 이 글에서는 LLM 기반 어플리케이션을 만들기 위한 현재 가장 인기 있는 두 프레임워크인 Langchain과 LlamaIndex에 대해 이야기하겠습니다.</p>
<h2>Langchain 🦜️🔗</h2>
<div class="content-ad"></div>
<p>가장 인기 있는 프레임워크는 아마도 Langchain일 것입니다. Langchain은 2022년 10월에 처음 릴리스되었으며 그 이후로 급속하게 발전하여 LLM 세계의 거의 모든 것을 다루는데 이르렀습니다. 현재 시점에서 거의 400개의 릴리스에 이를 정도로 성장했습니다. 한 때 릴리스는 거의 매일 발생했으며 가끔은 하루에 두 번씩 이루어졌습니다!</p>
<p>지난 1년 동안 Langchain은 비교적 단순한 Python 라이브러리에서 핵심 라이브러리부터 배포 서버, 관측성 도구 세트까지의 기능 생태계로 성장했습니다.</p>
<p>이제 Langchain을 사용하여 OpenAI에 연결하고 그 채팅 API를 호출하는 방법에 대해 간단히 설명해드리겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChatOpenAI</span>
<span class="hljs-keyword">from</span> langchain_core.<span class="hljs-property">prompts</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChatPromptTemplate</span>
<span class="hljs-keyword">from</span> langchain_core.<span class="hljs-property">output_parsers</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">StrOutputParser</span>

llm = <span class="hljs-title class_">ChatOpenAI</span>(model_name=<span class="hljs-string">"gpt-4o"</span>)
prompt = <span class="hljs-title class_">ChatPromptTemplate</span>.<span class="hljs-title function_">from_messages</span>([
    (<span class="hljs-string">"system"</span>, <span class="hljs-string">"You are a helpful assistant."</span>),
    (<span class="hljs-string">"user"</span>, <span class="hljs-string">"{input}"</span>)
])
output_parser = <span class="hljs-title class_">StrOutputParser</span>()

chain = prompt | llm | output_parser
results = chain.<span class="hljs-title function_">invoke</span>({<span class="hljs-string">"input"</span>: <span class="hljs-string">"why is the sky blue?"</span>})

<span class="hljs-title function_">print</span>(results)
</code></pre>
<div class="content-ad"></div>
<p>코드를 한눈에 보면 그리 다른 것 같지는 않지만, 챗 프롬프트, LLM 및 출력 파서를 연결하여 결과를 생성했음을 알아차릴 수도 있을 것입니다. 이것은 Langchain의 더 강력한 기능 중 하나의 예시이며, Langchain에 이름을 부여한 것 중 하나인 연쇄입니다.</p>
<p>연쇄는 서로 연결된 호출의 일련이다. 연쇄는 Langchain 표현 언어(LCEL)를 사용하여 생성되며, 가장 기본적인 연쇄는 위에서 보여진 것과 같습니다:</p>
<pre><code class="hljs language-js">chain = prompt | llm | output_parser
</code></pre>
<p>연쇄를 실행하기 위해, 우리는 연쇄에 대해 몇 가지 메서드 중 하나를 호출하면 됩니다(위의 코드의 경우 invoke를 사용했습니다). 적절한 입력을 사용하여 호출하면 결과를 얻을 수 있습니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-27-ProgrammingwithAICallingAPIs_1.png" alt="Programming with AI: Calling APIs"></p>
<p>체인은 강력하고 구성 가능합니다. 컨텍스트와 함께 질문을 LLM에 전달하여 간단한 검색 증강 생성(RAG)을 수행하는 방법을 살펴보겠습니다.</p>
<p>이 경우 싱가포르의 통신 및 정보부 (MCI) 위원회 공급위원회에 대한 2024년 1월의 국회 회의록 텍스트 문서를 사용합니다. 해당 사이트에서 텍스트를 가져와 hansard.txt라는 텍스트 파일로 저장했습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> langchain_community.<span class="hljs-property">vectorstores</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">DocArrayInMemorySearch</span>
<span class="hljs-keyword">from</span> langchain_core.<span class="hljs-property">output_parsers</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">StrOutputParser</span>
<span class="hljs-keyword">from</span> langchain_core.<span class="hljs-property">prompts</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChatPromptTemplate</span>
<span class="hljs-keyword">from</span> langchain_core.<span class="hljs-property">runnables</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">RunnableParallel</span>, <span class="hljs-title class_">RunnablePassthrough</span>
<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> <span class="hljs-title class_">OpenAIEmbeddings</span>
<span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChatOpenAI</span>

def <span class="hljs-title function_">extract</span>(file_path):
    <span class="hljs-keyword">with</span> <span class="hljs-title function_">open</span>(file_path, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> <span class="hljs-attr">file</span>:
        <span class="hljs-keyword">return</span> [line.<span class="hljs-title function_">strip</span>() <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file <span class="hljs-keyword">if</span> line.<span class="hljs-title function_">strip</span>()]

model = <span class="hljs-title class_">ChatOpenAI</span>(model=<span class="hljs-string">"gpt-4o"</span>)
vectorstore = <span class="hljs-title class_">DocArrayInMemorySearch</span>.<span class="hljs-title function_">from_texts</span>(
    texts=<span class="hljs-title function_">extract</span>(<span class="hljs-string">'data/hansard.txt'</span>),
    embedding=<span class="hljs-title class_">OpenAIEmbeddings</span>(),
)
retriever = vectorstore.<span class="hljs-title function_">as_retriever</span>()
template = <span class="hljs-string">""</span><span class="hljs-string">"다음 컨텍스트를 기반으로 질문에 답하십시오:
{context}

질문: {question}
"</span><span class="hljs-string">""</span>
prompt = <span class="hljs-title class_">ChatPromptTemplate</span>.<span class="hljs-title function_">from_template</span>(template)
output_parser = <span class="hljs-title class_">StrOutputParser</span>()
setup_and_retrieval = <span class="hljs-title class_">RunnableParallel</span>(
    {<span class="hljs-string">"context"</span>: retriever, <span class="hljs-string">"question"</span>: <span class="hljs-title class_">RunnablePassthrough</span>()}
)
chain = setup_and_retrieval | prompt | model | output_parser

results = chain.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">"스마트 네이션은 어떻게 시민들의 삶을 개선했습니까?"</span>)
<span class="hljs-title function_">print</span>(results)
</code></pre>
<div class="content-ad"></div>
<p>위의 코드에서는 먼저 hansard.txt 문서의 각 줄에서 인메모리 벡터 저장소를 만들고 OpenAI의 임베딩을 사용합니다. 벡터 저장소로부터 리트리버를 생성하여 프롬프트에 입력으로 적합한 줄을 가져올 수 있습니다.</p>
<p>이제 사용자의 입력이 주어지면, 해당 입력을 리트리버에 전달하여 벡터 저장소에서 줄들을 가져올 수 있습니다. 사용자 입력은 또한 프롬프트로 전달됩니다. RunnableParallel을 통해 동시에 이 두 가지가 실행되고, 출력은 질문과 문맥으로 프롬프트로 전송됩니다.</p>
<img src="/assets/img/2024-05-27-ProgrammingwithAICallingAPIs_2.png">
<p>나머지 부분은 거의 동일하지만 여기에 출력이 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python">% python langchain_test_rag.py
싱가포르의 스마트 네이션 이니셔티브는 <span class="hljs-number">2014</span>년부터 <span class="hljs-number">2023</span>년까지 정부 서비스에 대한 만족도를 <span class="hljs-number">73</span>%에서 <span class="hljs-number">83</span>%로 높여 시민들의 삶을 개선했습니다. 뿐만 아니라, 싱가포르인의 <span class="hljs-number">84</span>%가 디지털 기술이 그들의 삶을 더 편하게 만들었다고 느끼고 있습니다. 이 이니셔티브는 일상적인 편의성과 삶의 질을 향상시키고, 사람들이 더 의미 있는 삶을 살도록 돕고, 누구도 뒤처지지 않도록 하는 것을 목표로 합니다.
</code></pre>
<p>여러분이 보실 수 있듯이, 체인은 강력한 메커니즘입니다. 이 체인 메커니즘은 Langchain에만 해당하는 것은 아닙니다. Haystack 프레임워크는 파이프라인이라고 부르며, LLMFlows와 같은 몇 개의 다른 프레임워크는 플로우라고 합니다.</p>
<h2>LlamaIndex</h2>
<p>다른 인기 있는 LLM 프레임워크인 LlamaIndex가 있습니다. LlamaIndex는 2022년 11월에 GPTIndex라는 이름의 프레임워크로 시작되었습니다. LlamaIndex의 기본 개념은 LLM을 데이터에 연결하는 것입니다. 실제로 LlamaIndex와 Langchain은 거의 동시에 시작되었다는 것에 주목할 수 있습니다. 사실, Langchain의 창시자인 해리슨 체이스와 LlamaIndex의 창시자인 제리 류는 인공 지능 보안 회사인 Robust Intelligence에서 동료였습니다.</p>
<div class="content-ad"></div>
<p>빠른 대화 완성을 위해 LlamaIndex 사용 방법을 간단히 살펴봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> llama_index.<span class="hljs-property">core</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Settings</span>
<span class="hljs-keyword">from</span> llama_index.<span class="hljs-property">core</span>.<span class="hljs-property">llms</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChatMessage</span>
<span class="hljs-keyword">from</span> llama_index.<span class="hljs-property">llms</span>.<span class="hljs-property">openai</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">OpenAI</span>

<span class="hljs-title class_">Settings</span>.<span class="hljs-property">llm</span> = <span class="hljs-title class_">OpenAI</span>(model=<span class="hljs-string">"gpt-4o"</span>)
messages = [
    <span class="hljs-title class_">ChatMessage</span>(
        role=<span class="hljs-string">"system"</span>, content=<span class="hljs-string">"You are a helpful assistant."</span>
    ),
    <span class="hljs-title class_">ChatMessage</span>(role=<span class="hljs-string">"user"</span>, content=<span class="hljs-string">"Why is the sky blue?"</span>),
]
resp = <span class="hljs-title class_">OpenAI</span>().<span class="hljs-title function_">chat</span>(messages)
<span class="hljs-title function_">print</span>(resp)
</code></pre>
<p>보시다시피, Langchain이나 기타 API와 크게 다르지 않지만 LlamaIndex의 장점은 데이터와의 연결에 중점을 둔다는 점입니다. 예상대로, 간단한 RAG를 수행하는 코드는 매우 간단합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> llama_index.<span class="hljs-property">core</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Settings</span>, <span class="hljs-title class_">VectorStoreIndex</span>, <span class="hljs-title class_">SimpleDirectoryReader</span>
<span class="hljs-keyword">from</span> llama_index.<span class="hljs-property">llms</span>.<span class="hljs-property">openai</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">OpenAI</span>

<span class="hljs-title class_">Settings</span>.<span class="hljs-property">llm</span> = <span class="hljs-title class_">OpenAI</span>(model=<span class="hljs-string">"gpt-4o"</span>)

documents = <span class="hljs-title class_">SimpleDirectoryReader</span>(<span class="hljs-string">"data"</span>).<span class="hljs-title function_">load_data</span>()
index = <span class="hljs-title class_">VectorStoreIndex</span>.<span class="hljs-title function_">from_documents</span>(documents)
query_engine = index.<span class="hljs-title function_">as_query_engine</span>()
response = query_engine.<span class="hljs-title function_">query</span>(<span class="hljs-string">"How has Smart Nation improved citizen's lives?"</span>)
<span class="hljs-title function_">print</span>(response)
</code></pre>
<div class="content-ad"></div>
<p>먼저, 데이터 디렉토리(즉, 우리의 hansard.txt 파일)에서 파일을 가져와서 벡터 저장소에 저장합니다. 그런 다음 해당 벡터 저장소를 쿼리 엔진으로 사용하여 쿼리를 보내면 문서에서 데이터를 사용하여 응답을 형성할 것입니다.</p>
<p>Langchain과 LlamaIndex는 진화의 급격한 속도 이후 강력한 프레임워크입니다. 각각의 강점이 있으며 현재 시점에서는 주로 개인적인 선호에 따라 사용하는 것이 대부분입니다.</p>
<h1>요약</h1>
<p>AI 프로그래밍에 대한 수업의 첫 번째 부분입니다. 다음 글에서는 지역 LLM에 대해 더 깊이 알아볼 것입니다. 즉, 자신의 기기에 배포할 수 있는 LLM에 대해 다뤄볼 것입니다. 예를 들어, 자신의 노트북에도 배포할 수 있는 LLM입니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"AI와 함께 하는 프로그래밍,  API 호출하기","description":"","date":"2024-05-27 18:37","slug":"2024-05-27-ProgrammingwithAICallingAPIs","content":"\n\n몇 주 전에 AI 프로그래밍 수업을 가르쳐달라는 요청을 받았어요. 그래서 슬라이드와 코드를 열심히 준비했는데, 물질들이 커져갔어요. 그래서 이 모든 자료들을 하나로 모아 시리즈 형식의 글로 만들어보자는 생각이 들었죠. 수업 이후에 이를 참고할 수 있는 사람들이 많을 것이라 생각해요. 또한 이 글들은 세션 이후에도 수업에 도움이 될 수 있는 참고 자료가 될 거예요.\n\n그래서 이 수업의 첫 번째 부분을 공유합니다. 이 부분은 REST API 및 라이브러리를 통해 AI 공급업체 API를 호출하는데 관한 내용입니다.\n\n참고: 이것은 초보자를 위한 자료이므로 제가 생략한 내용이 많습니다. 이는 포괄적인 내용이 아니고 이해를 돕기 위한 것입니다.\n\n![Programming with AI Image](/assets/img/2024-05-27-ProgrammingwithAICallingAPIs_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n따뜻한 시작부터 시작해봅시다. 그것은 몇 가지 API를 호출하는 것을 의미합니다. AI를 활용하기 위해 API를 호출하는 것은 AI 능력에 가장 흔하고 쉬운 방법이에요. 많은 사람들이 이를 비웃고 \"충분히 AI가 아니다\" 라고 생각하지만, 그건 좀 어리석은 생각이죠 - 시스템의 가치는 사용자에게 기능을 제공하는 것이지 얼마나 많은 AI가 사용되었는지에 달려 있지 않습니다.\n\n현재 OpenAI (GPT), Google (Gemini), Anthropic (Claude), Mistral (Mistral), Cohere (Command) 등 다양한 API 제공업체들이 있어요. 이외에도 Replicate, Anyscale, Modal, Banana 등 다양한 기능을 제공하는 플랫폼 제공자들도 있습니다.\n\n이 글에서는 우리가 REST API를 호출하는 것으로 간단히 시작할 거에요.\n\n# REST APIs\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내가 아는 바에 의하면, 각 제공업체는 REST API를 갖고 있어요. 그들을 호출하는 것은 매우 간단해요. curl과 API URL 엔드포인트 그리고 JSON 페이로드를 전달하기만 하면 돼요.\n\n여기 채팅 완성을 위해 OpenAI API를 호출하는 예시가 있어요.\n\n```js\n$ curl https://api.openai.com/v1/chat/completions \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n    \"model\": \"gpt-4o\",\n    \"messages\": [\n      {\n        \"role\": \"system\",\n        \"content\": \"You are a helpful assistant.\"\n      },\n      {\n        \"role\": \"user\",\n        \"content\": \"Why is the sky blue?\"\n      }\n    ]\n  }'\n```\n\n각 제공업체로부터 유효한 API 키가 필요해요. 대부분의 경우 계정에 가입하고 API 키를 생성하기만 하면 돼요. API 키를 얻었다면 직접 전달하거나 환경 변수로 설정할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ export OPENAI_API_KEY=\u003c당신의 API 키\u003e\n```\n\nAPI를 호출하면 다음과 같은 결과가 반환되어야 합니다:\n\n```js\n{\n  \"id\": \"chatcmpl-9RWBzicE7v7A1ZRLWUMX3a6zwooWd\",\n  \"object\": \"chat.completion\",\n  \"created\": 1716345631,\n  \"model\": \"gpt-4o-2024-05-13\",\n  \"choices\": [\n    {\n      \"index\": 0,\n      \"message\": {\n        \"role\": \"assistant\",\n        \"content\": \"Rayleigh 산란이라는 현상으로 인해 하늘은 푸르게 보입니다. 더 자세한 설명은 다음과 같습니다:\\n\\n1. **태양빛 구성**: 태양빛 또는 백색광은 서로 다른 파장을 가진 색 스펙트럼으로 구성되어 있습니다. 가시 스펙트럼은 짧은 파장(파랑과 보라색)에서 긴 파장(빨강과 주황색)까지 범위에 걸쳐 있습니다.\\n\\n2. **대기와의 상호작용**: 태양빛이 지구 대기에 들어오면 분자와 작은 입자와 상호작용합니다. 짧은 파장의 빛(파랑과 보라색)은 이러한 입자에 의해 더 효과적으로 산란되며, 긴 파장(빨강, 주황, 노랑)은 그보다 적게 산란됩니다. \\n\\n3. **인간의 지각**: 보라색 빛은 파랑 빛보다 더 많이 산란되지만, 우리 눈은 파랑 빛에 민감하며, 태양빛에는 처음부터 보라색 빛이 많이 없습니다. 게다가 일부 보라색 빛은 상층 대기에 흡수됩니다. 결과적으로 우리는 하늘을 파랗게 보게 됩니다.\\n\\n4. **결과적인 푸른 하늘**: 산란된 파랑 빛이 각 방향에서 우리 눈에 도달하여, 주로 지면에서 낮에 하늘을 보면 하늘이 파랗게 보입니다.\\n\\n이 산란 효과는 태양이 하늘에 낮게 있을 때 더 명확하게 나타납니다. 그래서 일출과 일몰 시 빨간색 계열을 보게 됩니다. 이러한 경우에는 빛이 더 많은 대기를 통과하면서 파랑과 녹색빛이 더 많이 산란되고, 빨강과 주황색이 하늘을 지배하게 됩니다.\"\n      },\n      \"logprobs\": null,\n      \"finish_reason\": \"stop\"\n    }\n  ],\n  \"usage\": {\n    \"prompt_tokens\": 23,\n    \"completion_tokens\": 286,\n    \"total_tokens\": 309\n  },\n  \"system_fingerprint\": \"fp_729ea513f7\"\n}\n```\n\n아마도 OpenAI가 이러한 API를 처음으로 개발한 것이거나, 더 인기가 많아서 다른 많은 공급자들이 그들의 REST API에서 비슷한 형식을 사용하는 것일 수도 있습니다. 예를 들어, Anthropic의 형식은 다음과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n$ curl https://api.anthropic.com/v1/messages \\\n  -H \"content-type: application/json\" \\\n  -H \"x-api-key: $ANTHROPIC_API_KEY\" \\\n  -H \"anthropic-version: 2023-06-01\" \\\n  -d '{\n    \"model\": \"claude-3-opus-20240229\",\n    \"max_tokens\": 1024,\n    \"messages\": [\n        {\"role\": \"user\", \"content\": \"Why is the sky blue?\"}\n    ]\n}'\n\n\n위에서 보듯이, API 키는 다른 헤더를 통해 전달되지만 페이로드는 거의 동일하지만 모델 작동 방식에 따라 약간 차이가 있습니다. 예를 들어, Anthropic에서 메시지의 일부로 시스템 역할 콘텐츠를 전달할 수 없습니다.\n\n또 다른 예시는 Mistral의 것입니다.\n\n\n$ curl https://api.mistral.ai/v1/chat/completions \\\n     --header 'Content-Type: application/json' \\\n     --header 'Accept: application/json' \\\n     --header \"Authorization: Bearer $MISTRAL_API_KEY\" \\\n     --data '{\n    \"model\": \"mistral-large-latest\",\n    \"messages\": [\n     {\n        \"role\": \"user\",\n        \"content\": \"Why is the sky blue?\"\n      }\n    ]\n  }'\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그런데, Google은 실제로 API에 대해 약간 다른 방식을 사용하며 API 키를 URL 쿼리의 일부로 전달하고 모델을 URL의 일부로 포함시킵니다. 페이로드도 다르지만 아이디어는 거의 동일합니다.\n\n```js\n$ curl \"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=$API_KEY\" \\\n  -H 'Content-Type: application/json' \\\n  -d '{ \"contents\":[\n    { \"parts\":[{\"text\": \"Why is the sky blue?\"}]}\n  ]\n}'\n```\n\nREST API는 정말 유용하고 거의 보편적입니다. 제공 업체에서 직접 지원하지 않는 언어로 프로그래밍하는 경우 HTTP 클라이언트 라이브러리를 사용하여 REST API를 직접 호출할 수 있습니다. 대부분의 합리적인 프로그래밍 언어에는 표준 라이브러리나 서드 파티 라이브러리에 HTTP 클라이언트 라이브러리가 있으므로 문제 없습니다.\n\n그러나 대부분의 제공 업체는 대부분 Python을 지원하기도 합니다. 그 이유는 대부분의 AI 관련 작업이 Python으로 프로그래밍되기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 파이썬\n\n예를 들어, OpenAI를 호출하는 방법은 이렇습니다. Python 라이브러리를 사용합니다.\n\n```python\nfrom openai import OpenAI\nclient = OpenAI()\n\ncompletion = client.chat.completions.create(\n  model=\"gpt-4o\",\n  messages=[\n    {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n    {\"role\": \"user\", \"content\": \"Why is the sky blue?\"}\n  ]\n)\n\nprint(completion.choices[0].message.content)\n```\n\n너무 간단하죠? 클라이언트를 만들 때 매개변수와 옵션을 설정할 수 있지만 그게 전부입니다. API 키를 더 이상 지정할 필요가 없다는 것을 알아채셨을 것입니다. 환경 변수로 API 키를 설정했다면 Python 라이브러리가 해당 환경 변수에서 가져올 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! Anthropic과 Mistral도 마찬가지에요.\n\n```js\nimport anthropic\n\nmessage = anthropic.Anthropic().messages.create(\n    model=\"claude-3-opus-20240229\",\n    max_tokens=1024,\n    messages=[\n        {\"role\": \"user\", \"content\": \"Why is the sky blue?\"}\n    ]\n)\n\nprint(message.content)\n```\n\n프랜들리하게말하자면,\n\n```js\nfrom mistralai.client import MistralClient\nfrom mistralai.models.chat_completion import ChatMessage\n\nclient = MistralClient()\n\nchat_response = client.chat(\n    model=\"mistral-large-latest\",\n    messages=[\n        ChatMessage(role=\"user\", content=\"Why is the sky blue?\")\n    ],\n)\n\nprint(chat_response.choices[0].message.content)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGoogle의 Python 라이브러리도 사용하기 매우 쉽지만, 다른 라이브러리들과 조금 다릅니다.\n\n```python\nimport google.generativeai as genai\n\nmodel = genai.GenerativeModel('gemini-1.5-flash-latest')\nchat = model.start_chat(history=[])\nresponse = chat.send_message(\"Why is the sky blue?\")\n\nprint(response.text)\n```\n\n파이썬은 매우 잘 지원되고 있는 것을 보실 수 있습니다. 다른 잘 지원되는 언어는 JavaScript입니다.\n\n# Javascript\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬이 가장 잘 지원되는 언어라고 해도, 인기가 많기 때문에 자바스크립트/타입스크립트도 많이 사용됩니다. 자바스크립트와 node.js를 사용하여 OpenAI API에 액세스하는 방법을 살펴봅시다.\n\n```js\nimport OpenAI from \"openai\";\n\nconst openai = new OpenAI();\n\nconst completion = await openai.chat.completions.create({\n  model: \"gpt-4o\",\n  messages: [\n      { role: \"system\", content: \"You are a helpful assistant.\" },\n      { role: \"user\", content: \"Why is the sky blue?\" }\n  ],    \n});\n\nconsole.log(completion.choices[0]);\n```\n\n파이썬 라이브러리에서와 같이 API 키를 더 이상 입력할 필요가 없었습니다. 환경 변수로 API 키를 설정한 경우, 자바스크립트 라이브러리가 환경 변수에서 API 키를 자동으로 인식합니다.\n\n이것이 JSON 결과 출력입니다 (completion.choices[0]만 표시).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMarkdown 형식으로 표를 변경하려면 다음과 같이 하면 됩니다.\n\n```js\n{\n  index: 0,\n  message: {\n    role: 'assistant',\n    content: \"하늘이 파란 이유는 Rayleigh 산란이라는 현상 때문입니다. 이 산란은 태양광이 지구 대기로 들어와 공기 속 분자와 작은 입자들과 상호 작용할 때 발생합니다.\\n\" +\n      '\\n' +\n      \"하늘이 파란 색으로 보이는 이유를 단계별로 살펴보겠습니다:\\n\" +\n      '\\n' +\n      '1. **태양광 조성**: 태양광 또는 백색광은 여러 색상으로 구성되어 있으며 각각 다른 파장을 가지고 있습니다. 색상은 보라색과 파랑 (파장이 짧은)에서 빨강과 주황 (파장이 긴)까지 이어집니다.\\n' +\n      '\\n' +\n      '2. **산란**: 태양광이 대기를 통과할 때 가스 분자와 작은 입자와 충돌합니다. 빛의 짧은 파장(파랑과 보라색)은 이러한 분자와 입자들에 의해 더 많이 길거나 (빨강과 주황과 같은)보다 더 넓은 범위로 산란됩니다.\\n' +\n      '\\n' +\n      '3. **인간의 지각**: 비록 보라색 빛이 파란 빛보다 더 많이 산란되지만, 우리 눈은 파란 빛에 민감하고 보라색 빛에 덜 민감합니다. 또한 일부의 보라색 빛은 상층 대기에 흡수됩니다. 따라서 우리에게는 하늘이 주로 파란색으로 보입니다.\\n' +\n      '\\n' +\n      '4. **시야각**: 하늘을 올려다볼 때, 우리는 하늘의 모든 부분에서 나오는 이 산란된 파란 빛을 보며 그 특징적인 색상을 부여합니다.\\n' +\n      '\\n' +\n      \"요약하면, 하늘이 파란 이유는 태양광의 짧은 파장인 파란색이 지구 대기의 분자들에 의해 모든 방향으로 더 넓게 산란되고, 우리 눈이 파란색 빛을 보는 데 더 잘 적응되어있기 때문입니다.\"\n  },\n  logprobs: null,\n  finish_reason: 'stop'\n}\n```\n\n마찬가지로, Javascript와 node.js를 사용하여 Anthropic API를 호출하는 방법은 아래와 같습니다.\n\n```js\nimport Anthropic from '@anthropic-ai/sdk';\n\nconst anthropic = new Anthropic();\n\nconst completion = await anthropic.messages.create({\n  model: \"claude-3-haiku-20240307\",\n  max_tokens: 1024,\n  messages: [\n    {\"role\": \"user\", \"content\": \"하늘이 파란 이유는 무엇인가요?\"}\n  ]\n});\n\nconsole.log(completion);\n```\n\n다른 공급자들로는 진행하지 않겠지만, 아이디어를 얻으실 수 있습니다. 공식적으로 지원되는 라이브러리를 사용하시려면 Python 및 Javascript가 좋습니다. REST API 외에도 Python 및 Javascript를 포함한 대부분의 공급자는 다른 언어에 대한 공식 지원이 없지만 Google은 훨씬 더 다양한 언어를 지원합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 다른 언어용 라이브러리가 없는 것은 아닙니다.\n\n# 서드 파티 라이브러리\n\n주변에는 다양한 서드 파티 라이브러리가 있습니다. OpenAI 문서를 살펴보면 대부분의 인기 있는 언어에 대한 서드 파티 라이브러리 지원이 있습니다. 예를 들어, go-openai 패키지를 사용하면 Go에서 OpenAI 라이브러리를 호출할 수 있습니다.\n\n```js\npackage main\n\nimport (\n \"context\"\n \"fmt\"\n \"os\"\n\n openai \"github.com/sashabaranov/go-openai\"\n)\n\nfunc main() {\n client := openai.NewClient(os.Getenv(\"OPENAI_API_KEY\"))\n resp, err := client.CreateChatCompletion(\n  context.Background(),\n  openai.ChatCompletionRequest{\n   Model: openai.GPT4o,\n   Messages: []openai.ChatCompletionMessage{\n    {\n     Role:    openai.ChatMessageRoleUser,\n     Content: \"Why is the sky blue?\",\n    },\n   },\n  },\n )\n\n if err != nil {\n  fmt.Printf(\"ChatCompletion error: %v\\n\", err)\n  return\n }\n\n fmt.Println(resp.Choices[0].Message.Content)\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저기요! 여기 SwiftOpenAI라는 Swift용 써드파티 OpenAI 라이브러리가 있어요. XCode 프로젝트에서 패키지 종속성으로 추가해서 사용할 수 있어요. 이 함수는 OpenAI API를 호출하는 예시에요.\n\n```js\n    func sendMessage() async {\n        let input = userInput.trimmingCharacters(in: .whitespacesAndNewlines)\n        guard !input.isEmpty else { return }\n        \n        let message = Message(content: input, isUser: true)\n        messages.append(message)\n        userInput = \"\"\n        \n        let openAI = SwiftOpenAI(apiKey: Config.openAIKey)\n        let msgs: [MessageChatGPT] = [\n            MessageChatGPT(text: \"You are a helpful assistant.\", role: .system),\n            MessageChatGPT(text: input, role: .user)\n        ]\n        \n        let optionalParameters = ChatCompletionsOptionalParameters(\n            temperature: 0.7,\n            stream: true,\n            maxTokens: 1024\n        )\n        \n        do {\n            let stream = try await openAI.createChatCompletionsStream(\n                model: .gpt4o(.base),\n                messages: msgs,\n                optionalParameters: optionalParameters\n            )\n            \n            let resp = Message(content: \"\", isUser: false)\n            messages.append(resp)\n            \n            for try await response in stream {\n                let content = response.choices[0].delta?.content ?? \"\"\n                if let lastMessage = messages.last, !lastMessage.isUser {\n                    let updatedContent = lastMessage.content + content\n                    messages[messages.count - 1] = Message(content: updatedContent, isUser: false)\n                }\n            }\n        } catch {\n            print(\"Error: \\(error)\")\n            if let lastMessage = messages.last, !lastMessage.isUser {\n                messages[messages.count - 1] = Message(content: \"Cannot get response from OpenAI: \\(error)\", isUser: false)\n            }\n        }\n    }\n```\n\n이 모든 써드파티 라이브러리들은 좋지만 대부분이 한 제공업체만 지원해요. 여러 제공업체에 접근하려면 보통 동시에 몇 개의 라이브러리를 사용하거나 LLM 프레임워크를 시도해볼 수도 있어요.\n\n# LLM 프레임워크\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLLM 프레임워크는 LLM 기반 어플리케이션을 작성할 수 있게 해주는 어플리케이션 프레임워크의 일종입니다. 이러한 프레임워크는 지원과 구조를 제공하며, 일반적으로 LLM 기반 어플리케이션을 작성하는 방법을 표현합니다.\n\n다양한 LLM 프레임워크가 있으며, 그 중에는 공식으로 지원되거나 제3자 라이브러리보다 인기가 있는 것도 있습니다. 이는 이러한 프레임워크가 개발자에게 다양한 능력을 제공하기 때문입니다. 이를 통해 여러 LLM 제공 업체에 동시에 연결하고, 여러 데이터 소스에 연결하며, 기본 LLM 위에 에이전트를 구현할 수 있습니다.\n\nLangchain, LlamaIndex, Haystack 등 여러 프레임워크가 있지만, 이 글에서는 LLM 기반 어플리케이션을 만들기 위한 현재 가장 인기 있는 두 프레임워크인 Langchain과 LlamaIndex에 대해 이야기하겠습니다.\n\n## Langchain 🦜️🔗\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 인기 있는 프레임워크는 아마도 Langchain일 것입니다. Langchain은 2022년 10월에 처음 릴리스되었으며 그 이후로 급속하게 발전하여 LLM 세계의 거의 모든 것을 다루는데 이르렀습니다. 현재 시점에서 거의 400개의 릴리스에 이를 정도로 성장했습니다. 한 때 릴리스는 거의 매일 발생했으며 가끔은 하루에 두 번씩 이루어졌습니다!\n\n지난 1년 동안 Langchain은 비교적 단순한 Python 라이브러리에서 핵심 라이브러리부터 배포 서버, 관측성 도구 세트까지의 기능 생태계로 성장했습니다.\n\n이제 Langchain을 사용하여 OpenAI에 연결하고 그 채팅 API를 호출하는 방법에 대해 간단히 설명해드리겠습니다.\n\n```js\nfrom langchain_openai import ChatOpenAI\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_core.output_parsers import StrOutputParser\n\nllm = ChatOpenAI(model_name=\"gpt-4o\")\nprompt = ChatPromptTemplate.from_messages([\n    (\"system\", \"You are a helpful assistant.\"),\n    (\"user\", \"{input}\")\n])\noutput_parser = StrOutputParser()\n\nchain = prompt | llm | output_parser\nresults = chain.invoke({\"input\": \"why is the sky blue?\"})\n\nprint(results)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드를 한눈에 보면 그리 다른 것 같지는 않지만, 챗 프롬프트, LLM 및 출력 파서를 연결하여 결과를 생성했음을 알아차릴 수도 있을 것입니다. 이것은 Langchain의 더 강력한 기능 중 하나의 예시이며, Langchain에 이름을 부여한 것 중 하나인 연쇄입니다.\n\n연쇄는 서로 연결된 호출의 일련이다. 연쇄는 Langchain 표현 언어(LCEL)를 사용하여 생성되며, 가장 기본적인 연쇄는 위에서 보여진 것과 같습니다:\n\n```js\nchain = prompt | llm | output_parser\n```\n\n연쇄를 실행하기 위해, 우리는 연쇄에 대해 몇 가지 메서드 중 하나를 호출하면 됩니다(위의 코드의 경우 invoke를 사용했습니다). 적절한 입력을 사용하여 호출하면 결과를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Programming with AI: Calling APIs](/assets/img/2024-05-27-ProgrammingwithAICallingAPIs_1.png)\n\n체인은 강력하고 구성 가능합니다. 컨텍스트와 함께 질문을 LLM에 전달하여 간단한 검색 증강 생성(RAG)을 수행하는 방법을 살펴보겠습니다.\n\n이 경우 싱가포르의 통신 및 정보부 (MCI) 위원회 공급위원회에 대한 2024년 1월의 국회 회의록 텍스트 문서를 사용합니다. 해당 사이트에서 텍스트를 가져와 hansard.txt라는 텍스트 파일로 저장했습니다.\n\n```js\nfrom langchain_community.vectorstores import DocArrayInMemorySearch\nfrom langchain_core.output_parsers import StrOutputParser\nfrom langchain_core.prompts import ChatPromptTemplate\nfrom langchain_core.runnables import RunnableParallel, RunnablePassthrough\nfrom langchain_openai import OpenAIEmbeddings\nfrom langchain_openai import ChatOpenAI\n\ndef extract(file_path):\n    with open(file_path, 'r') as file:\n        return [line.strip() for line in file if line.strip()]\n\nmodel = ChatOpenAI(model=\"gpt-4o\")\nvectorstore = DocArrayInMemorySearch.from_texts(\n    texts=extract('data/hansard.txt'),\n    embedding=OpenAIEmbeddings(),\n)\nretriever = vectorstore.as_retriever()\ntemplate = \"\"\"다음 컨텍스트를 기반으로 질문에 답하십시오:\n{context}\n\n질문: {question}\n\"\"\"\nprompt = ChatPromptTemplate.from_template(template)\noutput_parser = StrOutputParser()\nsetup_and_retrieval = RunnableParallel(\n    {\"context\": retriever, \"question\": RunnablePassthrough()}\n)\nchain = setup_and_retrieval | prompt | model | output_parser\n\nresults = chain.invoke(\"스마트 네이션은 어떻게 시민들의 삶을 개선했습니까?\")\nprint(results)\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에서는 먼저 hansard.txt 문서의 각 줄에서 인메모리 벡터 저장소를 만들고 OpenAI의 임베딩을 사용합니다. 벡터 저장소로부터 리트리버를 생성하여 프롬프트에 입력으로 적합한 줄을 가져올 수 있습니다.\n\n이제 사용자의 입력이 주어지면, 해당 입력을 리트리버에 전달하여 벡터 저장소에서 줄들을 가져올 수 있습니다. 사용자 입력은 또한 프롬프트로 전달됩니다. RunnableParallel을 통해 동시에 이 두 가지가 실행되고, 출력은 질문과 문맥으로 프롬프트로 전송됩니다.\n\n\u003cimg src=\"/assets/img/2024-05-27-ProgrammingwithAICallingAPIs_2.png\" /\u003e\n\n나머지 부분은 거의 동일하지만 여기에 출력이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\n% python langchain_test_rag.py\n싱가포르의 스마트 네이션 이니셔티브는 2014년부터 2023년까지 정부 서비스에 대한 만족도를 73%에서 83%로 높여 시민들의 삶을 개선했습니다. 뿐만 아니라, 싱가포르인의 84%가 디지털 기술이 그들의 삶을 더 편하게 만들었다고 느끼고 있습니다. 이 이니셔티브는 일상적인 편의성과 삶의 질을 향상시키고, 사람들이 더 의미 있는 삶을 살도록 돕고, 누구도 뒤처지지 않도록 하는 것을 목표로 합니다.\n```\n\n여러분이 보실 수 있듯이, 체인은 강력한 메커니즘입니다. 이 체인 메커니즘은 Langchain에만 해당하는 것은 아닙니다. Haystack 프레임워크는 파이프라인이라고 부르며, LLMFlows와 같은 몇 개의 다른 프레임워크는 플로우라고 합니다.\n\n## LlamaIndex\n\n다른 인기 있는 LLM 프레임워크인 LlamaIndex가 있습니다. LlamaIndex는 2022년 11월에 GPTIndex라는 이름의 프레임워크로 시작되었습니다. LlamaIndex의 기본 개념은 LLM을 데이터에 연결하는 것입니다. 실제로 LlamaIndex와 Langchain은 거의 동시에 시작되었다는 것에 주목할 수 있습니다. 사실, Langchain의 창시자인 해리슨 체이스와 LlamaIndex의 창시자인 제리 류는 인공 지능 보안 회사인 Robust Intelligence에서 동료였습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빠른 대화 완성을 위해 LlamaIndex 사용 방법을 간단히 살펴봅시다.\n\n```js\nfrom llama_index.core import Settings\nfrom llama_index.core.llms import ChatMessage\nfrom llama_index.llms.openai import OpenAI\n\nSettings.llm = OpenAI(model=\"gpt-4o\")\nmessages = [\n    ChatMessage(\n        role=\"system\", content=\"You are a helpful assistant.\"\n    ),\n    ChatMessage(role=\"user\", content=\"Why is the sky blue?\"),\n]\nresp = OpenAI().chat(messages)\nprint(resp)\n```\n\n보시다시피, Langchain이나 기타 API와 크게 다르지 않지만 LlamaIndex의 장점은 데이터와의 연결에 중점을 둔다는 점입니다. 예상대로, 간단한 RAG를 수행하는 코드는 매우 간단합니다.\n\n```js\nfrom llama_index.core import Settings, VectorStoreIndex, SimpleDirectoryReader\nfrom llama_index.llms.openai import OpenAI\n\nSettings.llm = OpenAI(model=\"gpt-4o\")\n\ndocuments = SimpleDirectoryReader(\"data\").load_data()\nindex = VectorStoreIndex.from_documents(documents)\nquery_engine = index.as_query_engine()\nresponse = query_engine.query(\"How has Smart Nation improved citizen's lives?\")\nprint(response)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 데이터 디렉토리(즉, 우리의 hansard.txt 파일)에서 파일을 가져와서 벡터 저장소에 저장합니다. 그런 다음 해당 벡터 저장소를 쿼리 엔진으로 사용하여 쿼리를 보내면 문서에서 데이터를 사용하여 응답을 형성할 것입니다.\n\nLangchain과 LlamaIndex는 진화의 급격한 속도 이후 강력한 프레임워크입니다. 각각의 강점이 있으며 현재 시점에서는 주로 개인적인 선호에 따라 사용하는 것이 대부분입니다.\n\n# 요약\n\nAI 프로그래밍에 대한 수업의 첫 번째 부분입니다. 다음 글에서는 지역 LLM에 대해 더 깊이 알아볼 것입니다. 즉, 자신의 기기에 배포할 수 있는 LLM에 대해 다뤄볼 것입니다. 예를 들어, 자신의 노트북에도 배포할 수 있는 LLM입니다.","ogImage":{"url":"/assets/img/2024-05-27-ProgrammingwithAICallingAPIs_0.png"},"coverImage":"/assets/img/2024-05-27-ProgrammingwithAICallingAPIs_0.png","tag":["Tech"],"readingTime":17},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e몇 주 전에 AI 프로그래밍 수업을 가르쳐달라는 요청을 받았어요. 그래서 슬라이드와 코드를 열심히 준비했는데, 물질들이 커져갔어요. 그래서 이 모든 자료들을 하나로 모아 시리즈 형식의 글로 만들어보자는 생각이 들었죠. 수업 이후에 이를 참고할 수 있는 사람들이 많을 것이라 생각해요. 또한 이 글들은 세션 이후에도 수업에 도움이 될 수 있는 참고 자료가 될 거예요.\u003c/p\u003e\n\u003cp\u003e그래서 이 수업의 첫 번째 부분을 공유합니다. 이 부분은 REST API 및 라이브러리를 통해 AI 공급업체 API를 호출하는데 관한 내용입니다.\u003c/p\u003e\n\u003cp\u003e참고: 이것은 초보자를 위한 자료이므로 제가 생략한 내용이 많습니다. 이는 포괄적인 내용이 아니고 이해를 돕기 위한 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-ProgrammingwithAICallingAPIs_0.png\" alt=\"Programming with AI Image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e따뜻한 시작부터 시작해봅시다. 그것은 몇 가지 API를 호출하는 것을 의미합니다. AI를 활용하기 위해 API를 호출하는 것은 AI 능력에 가장 흔하고 쉬운 방법이에요. 많은 사람들이 이를 비웃고 \"충분히 AI가 아니다\" 라고 생각하지만, 그건 좀 어리석은 생각이죠 - 시스템의 가치는 사용자에게 기능을 제공하는 것이지 얼마나 많은 AI가 사용되었는지에 달려 있지 않습니다.\u003c/p\u003e\n\u003cp\u003e현재 OpenAI (GPT), Google (Gemini), Anthropic (Claude), Mistral (Mistral), Cohere (Command) 등 다양한 API 제공업체들이 있어요. 이외에도 Replicate, Anyscale, Modal, Banana 등 다양한 기능을 제공하는 플랫폼 제공자들도 있습니다.\u003c/p\u003e\n\u003cp\u003e이 글에서는 우리가 REST API를 호출하는 것으로 간단히 시작할 거에요.\u003c/p\u003e\n\u003ch1\u003eREST APIs\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e내가 아는 바에 의하면, 각 제공업체는 REST API를 갖고 있어요. 그들을 호출하는 것은 매우 간단해요. curl과 API URL 엔드포인트 그리고 JSON 페이로드를 전달하기만 하면 돼요.\u003c/p\u003e\n\u003cp\u003e여기 채팅 완성을 위해 OpenAI API를 호출하는 예시가 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ curl \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//api.openai.com/v1/chat/completions \\\u003c/span\u003e\n  -H \u003cspan class=\"hljs-string\"\u003e\"Content-Type: application/json\"\u003c/span\u003e \\\n  -H \u003cspan class=\"hljs-string\"\u003e\"Authorization: Bearer $OPENAI_API_KEY\"\u003c/span\u003e \\\n  -d \u003cspan class=\"hljs-string\"\u003e'{\n    \"model\": \"gpt-4o\",\n    \"messages\": [\n      {\n        \"role\": \"system\",\n        \"content\": \"You are a helpful assistant.\"\n      },\n      {\n        \"role\": \"user\",\n        \"content\": \"Why is the sky blue?\"\n      }\n    ]\n  }'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e각 제공업체로부터 유효한 API 키가 필요해요. 대부분의 경우 계정에 가입하고 API 키를 생성하기만 하면 돼요. API 키를 얻었다면 직접 전달하거나 환경 변수로 설정할 수 있어요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ \u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eOPENAI_API_KEY\u003c/span\u003e=\u0026#x3C;당신의 \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e 키\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAPI를 호출하면 다음과 같은 결과가 반환되어야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"chatcmpl-9RWBzicE7v7A1ZRLWUMX3a6zwooWd\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"object\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"chat.completion\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"created\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1716345631\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"model\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"gpt-4o-2024-05-13\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"choices\"\u003c/span\u003e: [\n    {\n      \u003cspan class=\"hljs-string\"\u003e\"index\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n      \u003cspan class=\"hljs-string\"\u003e\"message\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"assistant\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Rayleigh 산란이라는 현상으로 인해 하늘은 푸르게 보입니다. 더 자세한 설명은 다음과 같습니다:\\n\\n1. **태양빛 구성**: 태양빛 또는 백색광은 서로 다른 파장을 가진 색 스펙트럼으로 구성되어 있습니다. 가시 스펙트럼은 짧은 파장(파랑과 보라색)에서 긴 파장(빨강과 주황색)까지 범위에 걸쳐 있습니다.\\n\\n2. **대기와의 상호작용**: 태양빛이 지구 대기에 들어오면 분자와 작은 입자와 상호작용합니다. 짧은 파장의 빛(파랑과 보라색)은 이러한 입자에 의해 더 효과적으로 산란되며, 긴 파장(빨강, 주황, 노랑)은 그보다 적게 산란됩니다. \\n\\n3. **인간의 지각**: 보라색 빛은 파랑 빛보다 더 많이 산란되지만, 우리 눈은 파랑 빛에 민감하며, 태양빛에는 처음부터 보라색 빛이 많이 없습니다. 게다가 일부 보라색 빛은 상층 대기에 흡수됩니다. 결과적으로 우리는 하늘을 파랗게 보게 됩니다.\\n\\n4. **결과적인 푸른 하늘**: 산란된 파랑 빛이 각 방향에서 우리 눈에 도달하여, 주로 지면에서 낮에 하늘을 보면 하늘이 파랗게 보입니다.\\n\\n이 산란 효과는 태양이 하늘에 낮게 있을 때 더 명확하게 나타납니다. 그래서 일출과 일몰 시 빨간색 계열을 보게 됩니다. 이러한 경우에는 빛이 더 많은 대기를 통과하면서 파랑과 녹색빛이 더 많이 산란되고, 빨강과 주황색이 하늘을 지배하게 됩니다.\"\u003c/span\u003e\n      },\n      \u003cspan class=\"hljs-string\"\u003e\"logprobs\"\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n      \u003cspan class=\"hljs-string\"\u003e\"finish_reason\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"stop\"\u003c/span\u003e\n    }\n  ],\n  \u003cspan class=\"hljs-string\"\u003e\"usage\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"prompt_tokens\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"completion_tokens\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e286\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"total_tokens\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e309\u003c/span\u003e\n  },\n  \u003cspan class=\"hljs-string\"\u003e\"system_fingerprint\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"fp_729ea513f7\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아마도 OpenAI가 이러한 API를 처음으로 개발한 것이거나, 더 인기가 많아서 다른 많은 공급자들이 그들의 REST API에서 비슷한 형식을 사용하는 것일 수도 있습니다. 예를 들어, Anthropic의 형식은 다음과 같습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e$ curl \u003ca href=\"https://api.anthropic.com/v1/messages\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://api.anthropic.com/v1/messages\u003c/a\u003e \u003cbr\u003e\n-H \"content-type: application/json\" \u003cbr\u003e\n-H \"x-api-key: $ANTHROPIC_API_KEY\" \u003cbr\u003e\n-H \"anthropic-version: 2023-06-01\" \u003cbr\u003e\n-d '{\n\"model\": \"claude-3-opus-20240229\",\n\"max_tokens\": 1024,\n\"messages\": [\n{\"role\": \"user\", \"content\": \"Why is the sky blue?\"}\n]\n}'\u003c/p\u003e\n\u003cp\u003e위에서 보듯이, API 키는 다른 헤더를 통해 전달되지만 페이로드는 거의 동일하지만 모델 작동 방식에 따라 약간 차이가 있습니다. 예를 들어, Anthropic에서 메시지의 일부로 시스템 역할 콘텐츠를 전달할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e또 다른 예시는 Mistral의 것입니다.\u003c/p\u003e\n\u003cp\u003e$ curl \u003ca href=\"https://api.mistral.ai/v1/chat/completions\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://api.mistral.ai/v1/chat/completions\u003c/a\u003e \u003cbr\u003e\n--header 'Content-Type: application/json' \u003cbr\u003e\n--header 'Accept: application/json' \u003cbr\u003e\n--header \"Authorization: Bearer $MISTRAL_API_KEY\" \u003cbr\u003e\n--data '{\n\"model\": \"mistral-large-latest\",\n\"messages\": [\n{\n\"role\": \"user\",\n\"content\": \"Why is the sky blue?\"\n}\n]\n}'\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그런데, Google은 실제로 API에 대해 약간 다른 방식을 사용하며 API 키를 URL 쿼리의 일부로 전달하고 모델을 URL의 일부로 포함시킵니다. 페이로드도 다르지만 아이디어는 거의 동일합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ curl \u003cspan class=\"hljs-string\"\u003e\"https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=$API_KEY\"\u003c/span\u003e \\\n  -H \u003cspan class=\"hljs-string\"\u003e'Content-Type: application/json'\u003c/span\u003e \\\n  -d \u003cspan class=\"hljs-string\"\u003e'{ \"contents\":[\n    { \"parts\":[{\"text\": \"Why is the sky blue?\"}]}\n  ]\n}'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eREST API는 정말 유용하고 거의 보편적입니다. 제공 업체에서 직접 지원하지 않는 언어로 프로그래밍하는 경우 HTTP 클라이언트 라이브러리를 사용하여 REST API를 직접 호출할 수 있습니다. 대부분의 합리적인 프로그래밍 언어에는 표준 라이브러리나 서드 파티 라이브러리에 HTTP 클라이언트 라이브러리가 있으므로 문제 없습니다.\u003c/p\u003e\n\u003cp\u003e그러나 대부분의 제공 업체는 대부분 Python을 지원하기도 합니다. 그 이유는 대부분의 AI 관련 작업이 Python으로 프로그래밍되기 때문입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e파이썬\u003c/h1\u003e\n\u003cp\u003e예를 들어, OpenAI를 호출하는 방법은 이렇습니다. Python 라이브러리를 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e openai \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e OpenAI\nclient = OpenAI()\n\ncompletion = client.chat.completions.create(\n  model=\u003cspan class=\"hljs-string\"\u003e\"gpt-4o\"\u003c/span\u003e,\n  messages=[\n    {\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"You are a helpful assistant.\"\u003c/span\u003e},\n    {\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Why is the sky blue?\"\u003c/span\u003e}\n  ]\n)\n\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(completion.choices[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].message.content)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e너무 간단하죠? 클라이언트를 만들 때 매개변수와 옵션을 설정할 수 있지만 그게 전부입니다. API 키를 더 이상 지정할 필요가 없다는 것을 알아채셨을 것입니다. 환경 변수로 API 키를 설정했다면 Python 라이브러리가 해당 환경 변수에서 가져올 거에요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e안녕하세요! Anthropic과 Mistral도 마찬가지에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e anthropic\n\nmessage = anthropic.\u003cspan class=\"hljs-title class_\"\u003eAnthropic\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003emessages\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\n    model=\u003cspan class=\"hljs-string\"\u003e\"claude-3-opus-20240229\"\u003c/span\u003e,\n    max_tokens=\u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e,\n    messages=[\n        {\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Why is the sky blue?\"\u003c/span\u003e}\n    ]\n)\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(message.\u003cspan class=\"hljs-property\"\u003econtent\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e프랜들리하게말하자면,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e mistralai.\u003cspan class=\"hljs-property\"\u003eclient\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMistralClient\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e mistralai.\u003cspan class=\"hljs-property\"\u003emodels\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003echat_completion\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatMessage\u003c/span\u003e\n\nclient = \u003cspan class=\"hljs-title class_\"\u003eMistralClient\u003c/span\u003e()\n\nchat_response = client.\u003cspan class=\"hljs-title function_\"\u003echat\u003c/span\u003e(\n    model=\u003cspan class=\"hljs-string\"\u003e\"mistral-large-latest\"\u003c/span\u003e,\n    messages=[\n        \u003cspan class=\"hljs-title class_\"\u003eChatMessage\u003c/span\u003e(role=\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, content=\u003cspan class=\"hljs-string\"\u003e\"Why is the sky blue?\"\u003c/span\u003e)\n    ],\n)\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(chat_response.\u003cspan class=\"hljs-property\"\u003echoices\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003econtent\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eGoogle의 Python 라이브러리도 사용하기 매우 쉽지만, 다른 라이브러리들과 조금 다릅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e google.generativeai \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e genai\n\nmodel = genai.GenerativeModel(\u003cspan class=\"hljs-string\"\u003e'gemini-1.5-flash-latest'\u003c/span\u003e)\nchat = model.start_chat(history=[])\nresponse = chat.send_message(\u003cspan class=\"hljs-string\"\u003e\"Why is the sky blue?\"\u003c/span\u003e)\n\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(response.text)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e파이썬은 매우 잘 지원되고 있는 것을 보실 수 있습니다. 다른 잘 지원되는 언어는 JavaScript입니다.\u003c/p\u003e\n\u003ch1\u003eJavascript\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e파이썬이 가장 잘 지원되는 언어라고 해도, 인기가 많기 때문에 자바스크립트/타입스크립트도 많이 사용됩니다. 자바스크립트와 node.js를 사용하여 OpenAI API에 액세스하는 방법을 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"openai\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e openai = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e();\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e completion = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e openai.\u003cspan class=\"hljs-property\"\u003echat\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecompletions\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003emodel\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"gpt-4o\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003emessages\u003c/span\u003e: [\n      { \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"You are a helpful assistant.\"\u003c/span\u003e },\n      { \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Why is the sky blue?\"\u003c/span\u003e }\n  ],    \n});\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(completion.\u003cspan class=\"hljs-property\"\u003echoices\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e파이썬 라이브러리에서와 같이 API 키를 더 이상 입력할 필요가 없었습니다. 환경 변수로 API 키를 설정한 경우, 자바스크립트 라이브러리가 환경 변수에서 API 키를 자동으로 인식합니다.\u003c/p\u003e\n\u003cp\u003e이것이 JSON 결과 출력입니다 (completion.choices[0]만 표시).\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eMarkdown 형식으로 표를 변경하려면 다음과 같이 하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n  \u003cspan class=\"hljs-attr\"\u003eindex\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'assistant'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"하늘이 파란 이유는 Rayleigh 산란이라는 현상 때문입니다. 이 산란은 태양광이 지구 대기로 들어와 공기 속 분자와 작은 입자들과 상호 작용할 때 발생합니다.\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e'\\n'\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"하늘이 파란 색으로 보이는 이유를 단계별로 살펴보겠습니다:\\n\"\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e'\\n'\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e'1. **태양광 조성**: 태양광 또는 백색광은 여러 색상으로 구성되어 있으며 각각 다른 파장을 가지고 있습니다. 색상은 보라색과 파랑 (파장이 짧은)에서 빨강과 주황 (파장이 긴)까지 이어집니다.\\n'\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e'\\n'\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e'2. **산란**: 태양광이 대기를 통과할 때 가스 분자와 작은 입자와 충돌합니다. 빛의 짧은 파장(파랑과 보라색)은 이러한 분자와 입자들에 의해 더 많이 길거나 (빨강과 주황과 같은)보다 더 넓은 범위로 산란됩니다.\\n'\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e'\\n'\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e'3. **인간의 지각**: 비록 보라색 빛이 파란 빛보다 더 많이 산란되지만, 우리 눈은 파란 빛에 민감하고 보라색 빛에 덜 민감합니다. 또한 일부의 보라색 빛은 상층 대기에 흡수됩니다. 따라서 우리에게는 하늘이 주로 파란색으로 보입니다.\\n'\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e'\\n'\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e'4. **시야각**: 하늘을 올려다볼 때, 우리는 하늘의 모든 부분에서 나오는 이 산란된 파란 빛을 보며 그 특징적인 색상을 부여합니다.\\n'\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e'\\n'\u003c/span\u003e +\n      \u003cspan class=\"hljs-string\"\u003e\"요약하면, 하늘이 파란 이유는 태양광의 짧은 파장인 파란색이 지구 대기의 분자들에 의해 모든 방향으로 더 넓게 산란되고, 우리 눈이 파란색 빛을 보는 데 더 잘 적응되어있기 때문입니다.\"\u003c/span\u003e\n  },\n  \u003cspan class=\"hljs-attr\"\u003elogprobs\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003efinish_reason\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'stop'\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마찬가지로, Javascript와 node.js를 사용하여 Anthropic API를 호출하는 방법은 아래와 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnthropic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@anthropic-ai/sdk'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e anthropic = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnthropic\u003c/span\u003e();\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e completion = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e anthropic.\u003cspan class=\"hljs-property\"\u003emessages\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003emodel\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"claude-3-haiku-20240307\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003emax_tokens\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003emessages\u003c/span\u003e: [\n    {\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"하늘이 파란 이유는 무엇인가요?\"\u003c/span\u003e}\n  ]\n});\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(completion);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 공급자들로는 진행하지 않겠지만, 아이디어를 얻으실 수 있습니다. 공식적으로 지원되는 라이브러리를 사용하시려면 Python 및 Javascript가 좋습니다. REST API 외에도 Python 및 Javascript를 포함한 대부분의 공급자는 다른 언어에 대한 공식 지원이 없지만 Google은 훨씬 더 다양한 언어를 지원합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그러나 다른 언어용 라이브러리가 없는 것은 아닙니다.\u003c/p\u003e\n\u003ch1\u003e서드 파티 라이브러리\u003c/h1\u003e\n\u003cp\u003e주변에는 다양한 서드 파티 라이브러리가 있습니다. OpenAI 문서를 살펴보면 대부분의 인기 있는 언어에 대한 서드 파티 라이브러리 지원이 있습니다. 예를 들어, go-openai 패키지를 사용하면 Go에서 OpenAI 라이브러리를 호출할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epackage main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n \u003cspan class=\"hljs-string\"\u003e\"context\"\u003c/span\u003e\n \u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n \u003cspan class=\"hljs-string\"\u003e\"os\"\u003c/span\u003e\n\n openai \u003cspan class=\"hljs-string\"\u003e\"github.com/sashabaranov/go-openai\"\u003c/span\u003e\n)\n\nfunc \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n client := openai.\u003cspan class=\"hljs-title class_\"\u003eNewClient\u003c/span\u003e(os.\u003cspan class=\"hljs-title class_\"\u003eGetenv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"OPENAI_API_KEY\"\u003c/span\u003e))\n resp, err := client.\u003cspan class=\"hljs-title class_\"\u003eCreateChatCompletion\u003c/span\u003e(\n  context.\u003cspan class=\"hljs-title class_\"\u003eBackground\u003c/span\u003e(),\n  openai.\u003cspan class=\"hljs-property\"\u003eChatCompletionRequest\u003c/span\u003e{\n   \u003cspan class=\"hljs-title class_\"\u003eModel\u003c/span\u003e: openai.\u003cspan class=\"hljs-property\"\u003eGPT4o\u003c/span\u003e,\n   \u003cspan class=\"hljs-title class_\"\u003eMessages\u003c/span\u003e: []openai.\u003cspan class=\"hljs-property\"\u003eChatCompletionMessage\u003c/span\u003e{\n    {\n     \u003cspan class=\"hljs-title class_\"\u003eRole\u003c/span\u003e:    openai.\u003cspan class=\"hljs-property\"\u003eChatMessageRoleUser\u003c/span\u003e,\n     \u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Why is the sky blue?\"\u003c/span\u003e,\n    },\n   },\n  },\n )\n\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e err != nil {\n  fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ChatCompletion error: %v\\n\"\u003c/span\u003e, err)\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n }\n\n fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintln\u003c/span\u003e(resp.\u003cspan class=\"hljs-property\"\u003eChoices\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003eMessage\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eContent\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저기요! 여기 SwiftOpenAI라는 Swift용 써드파티 OpenAI 라이브러리가 있어요. XCode 프로젝트에서 패키지 종속성으로 추가해서 사용할 수 있어요. 이 함수는 OpenAI API를 호출하는 예시에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    func \u003cspan class=\"hljs-title function_\"\u003esendMessage\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e input = userInput.\u003cspan class=\"hljs-title function_\"\u003etrimmingCharacters\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ein\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ewhitespacesAndNewlines\u003c/span\u003e)\n        guard !input.\u003cspan class=\"hljs-property\"\u003eisEmpty\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e }\n        \n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e message = \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: input, \u003cspan class=\"hljs-attr\"\u003eisUser\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n        messages.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(message)\n        userInput = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n        \n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e openAI = \u003cspan class=\"hljs-title class_\"\u003eSwiftOpenAI\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eapiKey\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eConfig\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eopenAIKey\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emsgs\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eMessageChatGPT\u003c/span\u003e] = [\n            \u003cspan class=\"hljs-title class_\"\u003eMessageChatGPT\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"You are a helpful assistant.\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003esystem\u003c/span\u003e),\n            \u003cspan class=\"hljs-title class_\"\u003eMessageChatGPT\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: input, \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e)\n        ]\n        \n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e optionalParameters = \u003cspan class=\"hljs-title class_\"\u003eChatCompletionsOptionalParameters\u003c/span\u003e(\n            \u003cspan class=\"hljs-attr\"\u003etemperature\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.7\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003estream\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003emaxTokens\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e\n        )\n        \n        \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e stream = \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e openAI.\u003cspan class=\"hljs-title function_\"\u003ecreateChatCompletionsStream\u003c/span\u003e(\n                \u003cspan class=\"hljs-attr\"\u003emodel\u003c/span\u003e: .\u003cspan class=\"hljs-title function_\"\u003egpt4o\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ebase\u003c/span\u003e),\n                \u003cspan class=\"hljs-attr\"\u003emessages\u003c/span\u003e: msgs,\n                \u003cspan class=\"hljs-attr\"\u003eoptionalParameters\u003c/span\u003e: optionalParameters\n            )\n            \n            \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e resp = \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eisUser\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e)\n            messages.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(resp)\n            \n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e stream {\n                \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e content = response.\u003cspan class=\"hljs-property\"\u003echoices\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003edelta\u003c/span\u003e?.\u003cspan class=\"hljs-property\"\u003econtent\u003c/span\u003e ?? \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e lastMessage = messages.\u003cspan class=\"hljs-property\"\u003elast\u003c/span\u003e, !lastMessage.\u003cspan class=\"hljs-property\"\u003eisUser\u003c/span\u003e {\n                    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e updatedContent = lastMessage.\u003cspan class=\"hljs-property\"\u003econtent\u003c/span\u003e + content\n                    messages[messages.\u003cspan class=\"hljs-property\"\u003ecount\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: updatedContent, \u003cspan class=\"hljs-attr\"\u003eisUser\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e)\n                }\n            }\n        } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e {\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Error: \\(error)\"\u003c/span\u003e)\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e lastMessage = messages.\u003cspan class=\"hljs-property\"\u003elast\u003c/span\u003e, !lastMessage.\u003cspan class=\"hljs-property\"\u003eisUser\u003c/span\u003e {\n                messages[messages.\u003cspan class=\"hljs-property\"\u003ecount\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Cannot get response from OpenAI: \\(error)\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eisUser\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e)\n            }\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 모든 써드파티 라이브러리들은 좋지만 대부분이 한 제공업체만 지원해요. 여러 제공업체에 접근하려면 보통 동시에 몇 개의 라이브러리를 사용하거나 LLM 프레임워크를 시도해볼 수도 있어요.\u003c/p\u003e\n\u003ch1\u003eLLM 프레임워크\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eLLM 프레임워크는 LLM 기반 어플리케이션을 작성할 수 있게 해주는 어플리케이션 프레임워크의 일종입니다. 이러한 프레임워크는 지원과 구조를 제공하며, 일반적으로 LLM 기반 어플리케이션을 작성하는 방법을 표현합니다.\u003c/p\u003e\n\u003cp\u003e다양한 LLM 프레임워크가 있으며, 그 중에는 공식으로 지원되거나 제3자 라이브러리보다 인기가 있는 것도 있습니다. 이는 이러한 프레임워크가 개발자에게 다양한 능력을 제공하기 때문입니다. 이를 통해 여러 LLM 제공 업체에 동시에 연결하고, 여러 데이터 소스에 연결하며, 기본 LLM 위에 에이전트를 구현할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eLangchain, LlamaIndex, Haystack 등 여러 프레임워크가 있지만, 이 글에서는 LLM 기반 어플리케이션을 만들기 위한 현재 가장 인기 있는 두 프레임워크인 Langchain과 LlamaIndex에 대해 이야기하겠습니다.\u003c/p\u003e\n\u003ch2\u003eLangchain 🦜️🔗\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e가장 인기 있는 프레임워크는 아마도 Langchain일 것입니다. Langchain은 2022년 10월에 처음 릴리스되었으며 그 이후로 급속하게 발전하여 LLM 세계의 거의 모든 것을 다루는데 이르렀습니다. 현재 시점에서 거의 400개의 릴리스에 이를 정도로 성장했습니다. 한 때 릴리스는 거의 매일 발생했으며 가끔은 하루에 두 번씩 이루어졌습니다!\u003c/p\u003e\n\u003cp\u003e지난 1년 동안 Langchain은 비교적 단순한 Python 라이브러리에서 핵심 라이브러리부터 배포 서버, 관측성 도구 세트까지의 기능 생태계로 성장했습니다.\u003c/p\u003e\n\u003cp\u003e이제 Langchain을 사용하여 OpenAI에 연결하고 그 채팅 API를 호출하는 방법에 대해 간단히 설명해드리겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_openai \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatOpenAI\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_core.\u003cspan class=\"hljs-property\"\u003eprompts\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatPromptTemplate\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_core.\u003cspan class=\"hljs-property\"\u003eoutput_parsers\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStrOutputParser\u003c/span\u003e\n\nllm = \u003cspan class=\"hljs-title class_\"\u003eChatOpenAI\u003c/span\u003e(model_name=\u003cspan class=\"hljs-string\"\u003e\"gpt-4o\"\u003c/span\u003e)\nprompt = \u003cspan class=\"hljs-title class_\"\u003eChatPromptTemplate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_messages\u003c/span\u003e([\n    (\u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"You are a helpful assistant.\"\u003c/span\u003e),\n    (\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"{input}\"\u003c/span\u003e)\n])\noutput_parser = \u003cspan class=\"hljs-title class_\"\u003eStrOutputParser\u003c/span\u003e()\n\nchain = prompt | llm | output_parser\nresults = chain.\u003cspan class=\"hljs-title function_\"\u003einvoke\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"input\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"why is the sky blue?\"\u003c/span\u003e})\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(results)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e코드를 한눈에 보면 그리 다른 것 같지는 않지만, 챗 프롬프트, LLM 및 출력 파서를 연결하여 결과를 생성했음을 알아차릴 수도 있을 것입니다. 이것은 Langchain의 더 강력한 기능 중 하나의 예시이며, Langchain에 이름을 부여한 것 중 하나인 연쇄입니다.\u003c/p\u003e\n\u003cp\u003e연쇄는 서로 연결된 호출의 일련이다. 연쇄는 Langchain 표현 언어(LCEL)를 사용하여 생성되며, 가장 기본적인 연쇄는 위에서 보여진 것과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003echain = prompt | llm | output_parser\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e연쇄를 실행하기 위해, 우리는 연쇄에 대해 몇 가지 메서드 중 하나를 호출하면 됩니다(위의 코드의 경우 invoke를 사용했습니다). 적절한 입력을 사용하여 호출하면 결과를 얻을 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-ProgrammingwithAICallingAPIs_1.png\" alt=\"Programming with AI: Calling APIs\"\u003e\u003c/p\u003e\n\u003cp\u003e체인은 강력하고 구성 가능합니다. 컨텍스트와 함께 질문을 LLM에 전달하여 간단한 검색 증강 생성(RAG)을 수행하는 방법을 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e이 경우 싱가포르의 통신 및 정보부 (MCI) 위원회 공급위원회에 대한 2024년 1월의 국회 회의록 텍스트 문서를 사용합니다. 해당 사이트에서 텍스트를 가져와 hansard.txt라는 텍스트 파일로 저장했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_community.\u003cspan class=\"hljs-property\"\u003evectorstores\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDocArrayInMemorySearch\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_core.\u003cspan class=\"hljs-property\"\u003eoutput_parsers\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStrOutputParser\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_core.\u003cspan class=\"hljs-property\"\u003eprompts\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatPromptTemplate\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_core.\u003cspan class=\"hljs-property\"\u003erunnables\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRunnableParallel\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eRunnablePassthrough\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_openai \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOpenAIEmbeddings\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_openai \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatOpenAI\u003c/span\u003e\n\ndef \u003cspan class=\"hljs-title function_\"\u003eextract\u003c/span\u003e(file_path):\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(file_path, \u003cspan class=\"hljs-string\"\u003e'r'\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efile\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [line.\u003cspan class=\"hljs-title function_\"\u003estrip\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e line \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e file \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e line.\u003cspan class=\"hljs-title function_\"\u003estrip\u003c/span\u003e()]\n\nmodel = \u003cspan class=\"hljs-title class_\"\u003eChatOpenAI\u003c/span\u003e(model=\u003cspan class=\"hljs-string\"\u003e\"gpt-4o\"\u003c/span\u003e)\nvectorstore = \u003cspan class=\"hljs-title class_\"\u003eDocArrayInMemorySearch\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_texts\u003c/span\u003e(\n    texts=\u003cspan class=\"hljs-title function_\"\u003eextract\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'data/hansard.txt'\u003c/span\u003e),\n    embedding=\u003cspan class=\"hljs-title class_\"\u003eOpenAIEmbeddings\u003c/span\u003e(),\n)\nretriever = vectorstore.\u003cspan class=\"hljs-title function_\"\u003eas_retriever\u003c/span\u003e()\ntemplate = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"다음 컨텍스트를 기반으로 질문에 답하십시오:\n{context}\n\n질문: {question}\n\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\nprompt = \u003cspan class=\"hljs-title class_\"\u003eChatPromptTemplate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_template\u003c/span\u003e(template)\noutput_parser = \u003cspan class=\"hljs-title class_\"\u003eStrOutputParser\u003c/span\u003e()\nsetup_and_retrieval = \u003cspan class=\"hljs-title class_\"\u003eRunnableParallel\u003c/span\u003e(\n    {\u003cspan class=\"hljs-string\"\u003e\"context\"\u003c/span\u003e: retriever, \u003cspan class=\"hljs-string\"\u003e\"question\"\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRunnablePassthrough\u003c/span\u003e()}\n)\nchain = setup_and_retrieval | prompt | model | output_parser\n\nresults = chain.\u003cspan class=\"hljs-title function_\"\u003einvoke\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"스마트 네이션은 어떻게 시민들의 삶을 개선했습니까?\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(results)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 코드에서는 먼저 hansard.txt 문서의 각 줄에서 인메모리 벡터 저장소를 만들고 OpenAI의 임베딩을 사용합니다. 벡터 저장소로부터 리트리버를 생성하여 프롬프트에 입력으로 적합한 줄을 가져올 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 사용자의 입력이 주어지면, 해당 입력을 리트리버에 전달하여 벡터 저장소에서 줄들을 가져올 수 있습니다. 사용자 입력은 또한 프롬프트로 전달됩니다. RunnableParallel을 통해 동시에 이 두 가지가 실행되고, 출력은 질문과 문맥으로 프롬프트로 전송됩니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-27-ProgrammingwithAICallingAPIs_2.png\"\u003e\n\u003cp\u003e나머지 부분은 거의 동일하지만 여기에 출력이 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e% python langchain_test_rag.py\n싱가포르의 스마트 네이션 이니셔티브는 \u003cspan class=\"hljs-number\"\u003e2014\u003c/span\u003e년부터 \u003cspan class=\"hljs-number\"\u003e2023\u003c/span\u003e년까지 정부 서비스에 대한 만족도를 \u003cspan class=\"hljs-number\"\u003e73\u003c/span\u003e%에서 \u003cspan class=\"hljs-number\"\u003e83\u003c/span\u003e%로 높여 시민들의 삶을 개선했습니다. 뿐만 아니라, 싱가포르인의 \u003cspan class=\"hljs-number\"\u003e84\u003c/span\u003e%가 디지털 기술이 그들의 삶을 더 편하게 만들었다고 느끼고 있습니다. 이 이니셔티브는 일상적인 편의성과 삶의 질을 향상시키고, 사람들이 더 의미 있는 삶을 살도록 돕고, 누구도 뒤처지지 않도록 하는 것을 목표로 합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여러분이 보실 수 있듯이, 체인은 강력한 메커니즘입니다. 이 체인 메커니즘은 Langchain에만 해당하는 것은 아닙니다. Haystack 프레임워크는 파이프라인이라고 부르며, LLMFlows와 같은 몇 개의 다른 프레임워크는 플로우라고 합니다.\u003c/p\u003e\n\u003ch2\u003eLlamaIndex\u003c/h2\u003e\n\u003cp\u003e다른 인기 있는 LLM 프레임워크인 LlamaIndex가 있습니다. LlamaIndex는 2022년 11월에 GPTIndex라는 이름의 프레임워크로 시작되었습니다. LlamaIndex의 기본 개념은 LLM을 데이터에 연결하는 것입니다. 실제로 LlamaIndex와 Langchain은 거의 동시에 시작되었다는 것에 주목할 수 있습니다. 사실, Langchain의 창시자인 해리슨 체이스와 LlamaIndex의 창시자인 제리 류는 인공 지능 보안 회사인 Robust Intelligence에서 동료였습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e빠른 대화 완성을 위해 LlamaIndex 사용 방법을 간단히 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e llama_index.\u003cspan class=\"hljs-property\"\u003ecore\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSettings\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e llama_index.\u003cspan class=\"hljs-property\"\u003ecore\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ellms\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatMessage\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e llama_index.\u003cspan class=\"hljs-property\"\u003ellms\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eopenai\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003eSettings\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ellm\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e(model=\u003cspan class=\"hljs-string\"\u003e\"gpt-4o\"\u003c/span\u003e)\nmessages = [\n    \u003cspan class=\"hljs-title class_\"\u003eChatMessage\u003c/span\u003e(\n        role=\u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, content=\u003cspan class=\"hljs-string\"\u003e\"You are a helpful assistant.\"\u003c/span\u003e\n    ),\n    \u003cspan class=\"hljs-title class_\"\u003eChatMessage\u003c/span\u003e(role=\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, content=\u003cspan class=\"hljs-string\"\u003e\"Why is the sky blue?\"\u003c/span\u003e),\n]\nresp = \u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003echat\u003c/span\u003e(messages)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(resp)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e보시다시피, Langchain이나 기타 API와 크게 다르지 않지만 LlamaIndex의 장점은 데이터와의 연결에 중점을 둔다는 점입니다. 예상대로, 간단한 RAG를 수행하는 코드는 매우 간단합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e llama_index.\u003cspan class=\"hljs-property\"\u003ecore\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSettings\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eVectorStoreIndex\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eSimpleDirectoryReader\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e llama_index.\u003cspan class=\"hljs-property\"\u003ellms\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eopenai\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003eSettings\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ellm\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e(model=\u003cspan class=\"hljs-string\"\u003e\"gpt-4o\"\u003c/span\u003e)\n\ndocuments = \u003cspan class=\"hljs-title class_\"\u003eSimpleDirectoryReader\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"data\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eload_data\u003c/span\u003e()\nindex = \u003cspan class=\"hljs-title class_\"\u003eVectorStoreIndex\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_documents\u003c/span\u003e(documents)\nquery_engine = index.\u003cspan class=\"hljs-title function_\"\u003eas_query_engine\u003c/span\u003e()\nresponse = query_engine.\u003cspan class=\"hljs-title function_\"\u003equery\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"How has Smart Nation improved citizen's lives?\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(response)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e먼저, 데이터 디렉토리(즉, 우리의 hansard.txt 파일)에서 파일을 가져와서 벡터 저장소에 저장합니다. 그런 다음 해당 벡터 저장소를 쿼리 엔진으로 사용하여 쿼리를 보내면 문서에서 데이터를 사용하여 응답을 형성할 것입니다.\u003c/p\u003e\n\u003cp\u003eLangchain과 LlamaIndex는 진화의 급격한 속도 이후 강력한 프레임워크입니다. 각각의 강점이 있으며 현재 시점에서는 주로 개인적인 선호에 따라 사용하는 것이 대부분입니다.\u003c/p\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003eAI 프로그래밍에 대한 수업의 첫 번째 부분입니다. 다음 글에서는 지역 LLM에 대해 더 깊이 알아볼 것입니다. 즉, 자신의 기기에 배포할 수 있는 LLM에 대해 다뤄볼 것입니다. 예를 들어, 자신의 노트북에도 배포할 수 있는 LLM입니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-ProgrammingwithAICallingAPIs"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>