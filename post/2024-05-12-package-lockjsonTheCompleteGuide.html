<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>패키지-락json 완전 가이드 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-package-lockjsonTheCompleteGuide" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="패키지-락json 완전 가이드 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="패키지-락json 완전 가이드 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-package-lockjsonTheCompleteGuide" data-gatsby-head="true"/><meta name="twitter:title" content="패키지-락json 완전 가이드 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 19:28" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_buildManifest.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">패키지-락json 완전 가이드</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="패키지-락json 완전 가이드" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-package-lockjsonTheCompleteGuide&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><h2>package-lock.json이란 무엇이고, 왜 신경 써야 하나요?</h2>
<h3>package.json이란?</h3>
<p>package.json은 주로 당신의 Node.js 프로젝트가 실행되기 위해 필요한 종속성(라이브러리) 목록을 포함하는 버전 파일입니다.</p>
<p>또한 스크립트, 저자 및 라이센스 정보, 설명, 프로젝트 속성 등과 같은 다른 메타 정보도 포함하고 있습니다.</p>
<img src="/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png"/>
<h1>고유한 문제</h1>
<p>위의 package.json에서 &quot;dependencies&quot; 객체가 package-name을 버전 범위로 매핑하는 것을 볼 수 있습니다.</p>
<img src="/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_1.png"/>
<p>이것은 npm install을 결정론적이지 않게 만듭니다. 그래서 오늘 npm install을 실행하고 3개월 후에 다시 실행하면 동일한 node_modules 트리를 얻을 수 없을 수 있습니다.</p>
<p>게다가, 만약 다른 개발자가 여러분의 프로젝트를 복제하고 그것에 몇 일 후에 npm install을 실행한다면, 그들은 다른 node_modules 의존성 트리를 가질 수 있습니다. 여러 명의 개발자가 같은 저장소에서 작업하는 경우(이는 대부분의 경우 조직 내에서 발생할 것으로 예상됩니다),이는 큰 문제를 일으킬 수 있으며 설치된 의존성에 일관성이 없거나 더 나빠른 변경으로 이어질 수 있습니다.</p>
<p>그래서 해결책은 무엇일까요? 먼저, 버전 범위가 무엇을 의미하는지 이해해 봅시다. 버전 범위는 하나 이상의 공백으로 구분된 숫자가 포함된 문자열입니다. 이 숫자들은 ^ ~ <code>||와 같은 일부 특수 기호도 포함합니다. 예: ^1.0.4, ~2.3, 4.4.x,</code>=2.3.4, `1.0.9 ||</p>
<p><img src="/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_2.png" alt="image"/></p>
<p>이 기호들은 npm에게 다른 정보를 전달해요:</p>
<p>예를 들어, &quot;foo&quot; 패키지를 설치하고 싶다고 해봅시다. npm i foo를 실행한 후에, 내 package.json 파일에는 대부분 다음과 같은 항목이 있을 거에요:</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">&quot;dependencies&quot;</span>: {
    <span class="hljs-string">&quot;foo&quot;</span>: <span class="hljs-string">&quot;^2.3.0&quot;</span>,
    ...
    ...
  }
}
</code></pre>
<p>여기서 foo는 2.3.0 [주 버전 부 버전 패치 버전] 버전으로 설치되었어요. 이 caret 기호는 또 다른 정보를 알려줘요:</p>
<p>^2.3.0 — Caret Symbol: npm에게 마이너 및 패치 버전을 업그레이드하도록 지시하지만 메이저 버전은 업그레이드하지 않습니다. 기본적으로 2.3.4, 2.3.9, 2.4.5, 2.8는 가능하지만 3.0.0부터는 불가능합니다. (마이너 및 패치는 업그레이드하지만 메이저는 제외)</p>
<p>~2.3.0 — Tilde Symbol: npm에게 패치 버전을 업그레이드하도록 지시하지만 마이너 및 메이저 버전은 업그레이드하지 않습니다. 따라서 2.3.4, 2.3.9는 가능하지만 2.4.0부터는 불가능합니다. (패치는 업그레이드하지만 마이너 및 메이저는 제외)</p>
<p>다른 npm 버전 업데이트 전략을 표시하는 여러 기호가 있습니다. 공식 npm 웹사이트가 좋은 참고자료가 될 것입니다.</p>
<p>따라서 &quot;foo&quot;: &quot;^2.3.0&quot;의 경우, 며칠 후에 npm install을 실행하면 자동으로 마이너/패치 버전이 업그레이드될 수 있습니다. 이는 바람직하지 않습니다...</p>
<h1>패키지 잠금파일(package-lock.json)이란?</h1>
<p><img src="/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_3.png" alt="이미지"/></p>
<p>패키지 잠금파일(package-lock.json)은 노드.js 프로젝트에 설치된 종속성/패키지들과 정확한 버전 번호에 대한 정보를 포함하는 잠금 파일(lockfile)입니다 (*중요).</p>
<ul>
<li>이 파일은 동일한 저장소에서 작업하는 다른 개발자들이 이전에 설치된 정확한 패키지 버전을 설치할 수 있도록 도와줍니다. 새 버전의 패키지가 출시되어도 다른 기기/환경에서 동일한 node_modules 트리를 유지할 수 있습니다.</li>
<li>패키지 잠금파일(package-lock.json)은 종속성을 특정 버전 번호로 잠그는 데 주로 사용됩니다.</li>
<li>이 파일은 node_modules 트리나 package.json 파일 중 하나라도 변경이 있을 때 자동으로 생성(또는 재생성)됩니다.</li>
<li>저장소를 복제하고 새 기기에서 npm i를 실행할 때, npm은 먼저 패키지 잠금파일(package-lock.json)이 있는지 확인합니다. 있을 경우 해당 파일에 있는 패키지를 설치합니다. 그렇지 않으면 package.json 파일을 확인하고 필요한 종속성 패키지를 설치합니다. (📦 이에 대한 주의사항은 뒤의 글에서 설명됩니다)</li>
</ul>
<img src="/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_4.png"/>
<h1>패키지 잠금 파일(package-lock.json)은 커밋해야 하나요?</h1>
<p>네, 이 파일은 소스 저장소에 커밋해야 합니다. 이렇게 하면 개발자가 귀하의 리포지토리를 클론할 때 귀하의 컴퓨터/환경에 설치된 의존성과 정확히 일치하는 의존성을 설치할 수 있습니다. 다른 컴퓨터에서 node.js 환경을 복제하는 데 도움이 됩니다.</p>
<h1>참고로</h1>
<p>저는 YouTube에서 아름다운 자바스크립트 체험을 보여주는 비디오를 만들고 있어요. (참고로 코딩 튜토리얼 채널은 아니에요...) 제 비디오를 확인해보세요:</p>
<h1>npm install이 package-lock.json을 다시 작성하는 이유 / 시기</h1>
<ul>
<li>📦 주의: npm install은 package.json의 버전 범위 내에 설치할 패키지가 있는 경우에만 package-lock.json을 고려합니다.</li>
<li>잠금 파일에 지정된 패키지 버전이 package.json 파일의 버전 범위 내에 없는 경우, 패키지가 업데이트되고 package-lock.json 파일이 덮어씌워집니다.</li>
<li>package-lock.json을 덮어쓰기 대신 설치를 실패하게 하려면 npm ci를 사용하세요.</li>
</ul>
<p>예를 들어,</p>
<p>패키지.json에서는 종속성을 다음과 같이 선언합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;foo&quot;</span>: <span class="hljs-string">&quot;^2.3.0&quot;</span>
</code></pre>
<p>그리고 npm install을 실행하면, 다음과 같은 package-lock.json이 생성됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;foo&quot;</span>: <span class="hljs-string">&quot;2.3.0&quot;</span>
</code></pre>
<p>몇 일 후에, &quot;foo&quot;의 새로운 부 버전인 &quot;2.4.0&quot;이 출시됩니다. 그리고 이렇게 됩니다:</p>
<p>npm install — package-lock 버전이 범위 내에 있으므로(예: ^2.3.0) 2.3.0이 설치됩니다.
npm ci — 이 명령은 어차피 package-lock.json만을 보기 때문에 2.3.0이 설치됩니다.</p>
<p>다음으로, package.json을 수동으로 업데이트합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-string">&quot;foo&quot;</span>: <span class="hljs-string">&quot;^2.4.0&quot;</span>
</code></pre>
<p>그럼 다시 실행해주세요:</p>
<p>npm install 명령어를 실행하면 package-lock 파일의 버전이 범위 내에 없기 때문에 (예: ^2.4.0), 2.4.0 버전으로 설치되며 package-lock.json 파일은 이제 다음과 같이 다시 작성됩니다:
&quot;foo&quot;: &quot;2.4.0&quot;</p>
<p>npm ci 명령어를 실행하면 package-lock.json 파일만 고려하지만 버전이 범위 내에 없기 때문에 오류가 발생합니다.</p>
<p>npm ci 명령어는 npm install과 유사하지만 테스트 플랫폼, 지속적인 통합, 배포 등과 같은 자동 환경에서 사용하기 위한 명령어입니다. 즉, 종속성을 깔끔하게 설치하고 싶은 경우에 유용합니다. (출처: npm 문서)</p>
<h1>간단히 말해요:</h1>
<ul>
<li>npm install은 결정론적이지 않아서, 수천 개의 종속성이 포함된 리포지토리(다수의 개발자들이 참여)에서 작업할 때 문제가 발생할 수 있어요.</li>
<li>package-lock.json 파일은 npm install이 실행될 때 항상 동일한 node_modules 트리가 생성되도록 보장해줘요.</li>
<li>최신 명령어인 npm ci는 항상 동일한 node_modules 트리를 생성하도록 보장하며, 그렇지 않으면 오류를 발생시켜요.</li>
</ul></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"패키지-락json 완전 가이드","description":"","date":"2024-05-12 19:28","slug":"2024-05-12-package-lockjsonTheCompleteGuide","content":"\n\n## package-lock.json이란 무엇이고, 왜 신경 써야 하나요?\n\n### package.json이란?\n\npackage.json은 주로 당신의 Node.js 프로젝트가 실행되기 위해 필요한 종속성(라이브러리) 목록을 포함하는 버전 파일입니다.\n\n또한 스크립트, 저자 및 라이센스 정보, 설명, 프로젝트 속성 등과 같은 다른 메타 정보도 포함하고 있습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png\" /\u003e\n\n# 고유한 문제\n\n위의 package.json에서 \"dependencies\" 객체가 package-name을 버전 범위로 매핑하는 것을 볼 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_1.png\" /\u003e\n\n\n\n이것은 npm install을 결정론적이지 않게 만듭니다. 그래서 오늘 npm install을 실행하고 3개월 후에 다시 실행하면 동일한 node_modules 트리를 얻을 수 없을 수 있습니다.\n\n게다가, 만약 다른 개발자가 여러분의 프로젝트를 복제하고 그것에 몇 일 후에 npm install을 실행한다면, 그들은 다른 node_modules 의존성 트리를 가질 수 있습니다. 여러 명의 개발자가 같은 저장소에서 작업하는 경우(이는 대부분의 경우 조직 내에서 발생할 것으로 예상됩니다),이는 큰 문제를 일으킬 수 있으며 설치된 의존성에 일관성이 없거나 더 나빠른 변경으로 이어질 수 있습니다.\n\n그래서 해결책은 무엇일까요? 먼저, 버전 범위가 무엇을 의미하는지 이해해 봅시다. 버전 범위는 하나 이상의 공백으로 구분된 숫자가 포함된 문자열입니다. 이 숫자들은 ^ ~ ` ||와 같은 일부 특수 기호도 포함합니다. 예: ^1.0.4, ~2.3, 4.4.x, `=2.3.4, `1.0.9 ||\n\n![image](/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_2.png)\n\n\n\n이 기호들은 npm에게 다른 정보를 전달해요:\n\n예를 들어, \"foo\" 패키지를 설치하고 싶다고 해봅시다. npm i foo를 실행한 후에, 내 package.json 파일에는 대부분 다음과 같은 항목이 있을 거에요:\n\n```js\n{\n  \"dependencies\": {\n    \"foo\": \"^2.3.0\",\n    ...\n    ...\n  }\n}\n```\n\n여기서 foo는 2.3.0 [주 버전 부 버전 패치 버전] 버전으로 설치되었어요. 이 caret 기호는 또 다른 정보를 알려줘요:\n\n\n\n^2.3.0 — Caret Symbol: npm에게 마이너 및 패치 버전을 업그레이드하도록 지시하지만 메이저 버전은 업그레이드하지 않습니다. 기본적으로 2.3.4, 2.3.9, 2.4.5, 2.8는 가능하지만 3.0.0부터는 불가능합니다. (마이너 및 패치는 업그레이드하지만 메이저는 제외)\n\n~2.3.0 — Tilde Symbol: npm에게 패치 버전을 업그레이드하도록 지시하지만 마이너 및 메이저 버전은 업그레이드하지 않습니다. 따라서 2.3.4, 2.3.9는 가능하지만 2.4.0부터는 불가능합니다. (패치는 업그레이드하지만 마이너 및 메이저는 제외)\n\n다른 npm 버전 업데이트 전략을 표시하는 여러 기호가 있습니다. 공식 npm 웹사이트가 좋은 참고자료가 될 것입니다.\n\n따라서 \"foo\": \"^2.3.0\"의 경우, 며칠 후에 npm install을 실행하면 자동으로 마이너/패치 버전이 업그레이드될 수 있습니다. 이는 바람직하지 않습니다...\n\n\n\n# 패키지 잠금파일(package-lock.json)이란?\n\n![이미지](/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_3.png)\n\n패키지 잠금파일(package-lock.json)은 노드.js 프로젝트에 설치된 종속성/패키지들과 정확한 버전 번호에 대한 정보를 포함하는 잠금 파일(lockfile)입니다 (*중요).\n\n- 이 파일은 동일한 저장소에서 작업하는 다른 개발자들이 이전에 설치된 정확한 패키지 버전을 설치할 수 있도록 도와줍니다. 새 버전의 패키지가 출시되어도 다른 기기/환경에서 동일한 node_modules 트리를 유지할 수 있습니다.\n- 패키지 잠금파일(package-lock.json)은 종속성을 특정 버전 번호로 잠그는 데 주로 사용됩니다.\n- 이 파일은 node_modules 트리나 package.json 파일 중 하나라도 변경이 있을 때 자동으로 생성(또는 재생성)됩니다.\n- 저장소를 복제하고 새 기기에서 npm i를 실행할 때, npm은 먼저 패키지 잠금파일(package-lock.json)이 있는지 확인합니다. 있을 경우 해당 파일에 있는 패키지를 설치합니다. 그렇지 않으면 package.json 파일을 확인하고 필요한 종속성 패키지를 설치합니다. (📦 이에 대한 주의사항은 뒤의 글에서 설명됩니다)\n\n\n\n\u003cimg src=\"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_4.png\" /\u003e\n\n# 패키지 잠금 파일(package-lock.json)은 커밋해야 하나요?\n\n네, 이 파일은 소스 저장소에 커밋해야 합니다. 이렇게 하면 개발자가 귀하의 리포지토리를 클론할 때 귀하의 컴퓨터/환경에 설치된 의존성과 정확히 일치하는 의존성을 설치할 수 있습니다. 다른 컴퓨터에서 node.js 환경을 복제하는 데 도움이 됩니다.\n\n# 참고로\n\n\n\n저는 YouTube에서 아름다운 자바스크립트 체험을 보여주는 비디오를 만들고 있어요. (참고로 코딩 튜토리얼 채널은 아니에요...) 제 비디오를 확인해보세요:\n\n# npm install이 package-lock.json을 다시 작성하는 이유 / 시기\n\n- 📦 주의: npm install은 package.json의 버전 범위 내에 설치할 패키지가 있는 경우에만 package-lock.json을 고려합니다.\n- 잠금 파일에 지정된 패키지 버전이 package.json 파일의 버전 범위 내에 없는 경우, 패키지가 업데이트되고 package-lock.json 파일이 덮어씌워집니다.\n- package-lock.json을 덮어쓰기 대신 설치를 실패하게 하려면 npm ci를 사용하세요.\n\n예를 들어,\n\n\n\n패키지.json에서는 종속성을 다음과 같이 선언합니다:\n\n```js\n\"foo\": \"^2.3.0\"\n```\n\n그리고 npm install을 실행하면, 다음과 같은 package-lock.json이 생성됩니다:\n\n```js\n\"foo\": \"2.3.0\"\n```\n\n\n\n몇 일 후에, \"foo\"의 새로운 부 버전인 \"2.4.0\"이 출시됩니다. 그리고 이렇게 됩니다:\n\nnpm install — package-lock 버전이 범위 내에 있으므로(예: ^2.3.0) 2.3.0이 설치됩니다.\nnpm ci — 이 명령은 어차피 package-lock.json만을 보기 때문에 2.3.0이 설치됩니다.\n\n다음으로, package.json을 수동으로 업데이트합니다:\n\n```js\n\"foo\": \"^2.4.0\"\n```\n\n\n\n그럼 다시 실행해주세요:\n\nnpm install 명령어를 실행하면 package-lock 파일의 버전이 범위 내에 없기 때문에 (예: ^2.4.0), 2.4.0 버전으로 설치되며 package-lock.json 파일은 이제 다음과 같이 다시 작성됩니다:\n\"foo\": \"2.4.0\"\n\nnpm ci 명령어를 실행하면 package-lock.json 파일만 고려하지만 버전이 범위 내에 없기 때문에 오류가 발생합니다.\n\nnpm ci 명령어는 npm install과 유사하지만 테스트 플랫폼, 지속적인 통합, 배포 등과 같은 자동 환경에서 사용하기 위한 명령어입니다. 즉, 종속성을 깔끔하게 설치하고 싶은 경우에 유용합니다. (출처: npm 문서)\n\n\n\n# 간단히 말해요:\n\n- npm install은 결정론적이지 않아서, 수천 개의 종속성이 포함된 리포지토리(다수의 개발자들이 참여)에서 작업할 때 문제가 발생할 수 있어요.\n- package-lock.json 파일은 npm install이 실행될 때 항상 동일한 node_modules 트리가 생성되도록 보장해줘요.\n- 최신 명령어인 npm ci는 항상 동일한 node_modules 트리를 생성하도록 보장하며, 그렇지 않으면 오류를 발생시켜요.","ogImage":{"url":"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png"},"coverImage":"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png","tag":["Tech"],"readingTime":5},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    h3: \"h3\",\n    p: \"p\",\n    h1: \"h1\",\n    code: \"code\",\n    img: \"img\",\n    pre: \"pre\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"package-lock.json이란 무엇이고, 왜 신경 써야 하나요?\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"package.json이란?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"package.json은 주로 당신의 Node.js 프로젝트가 실행되기 위해 필요한 종속성(라이브러리) 목록을 포함하는 버전 파일입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한 스크립트, 저자 및 라이센스 정보, 설명, 프로젝트 속성 등과 같은 다른 메타 정보도 포함하고 있습니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_0.png\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"고유한 문제\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 package.json에서 \\\"dependencies\\\" 객체가 package-name을 버전 범위로 매핑하는 것을 볼 수 있습니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 npm install을 결정론적이지 않게 만듭니다. 그래서 오늘 npm install을 실행하고 3개월 후에 다시 실행하면 동일한 node_modules 트리를 얻을 수 없을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"게다가, 만약 다른 개발자가 여러분의 프로젝트를 복제하고 그것에 몇 일 후에 npm install을 실행한다면, 그들은 다른 node_modules 의존성 트리를 가질 수 있습니다. 여러 명의 개발자가 같은 저장소에서 작업하는 경우(이는 대부분의 경우 조직 내에서 발생할 것으로 예상됩니다),이는 큰 문제를 일으킬 수 있으며 설치된 의존성에 일관성이 없거나 더 나빠른 변경으로 이어질 수 있습니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"그래서 해결책은 무엇일까요? 먼저, 버전 범위가 무엇을 의미하는지 이해해 봅시다. 버전 범위는 하나 이상의 공백으로 구분된 숫자가 포함된 문자열입니다. 이 숫자들은 ^ ~ \", _jsx(_components.code, {\n        children: \"||와 같은 일부 특수 기호도 포함합니다. 예: ^1.0.4, ~2.3, 4.4.x,\"\n      }), \"=2.3.4, `1.0.9 ||\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_2.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기호들은 npm에게 다른 정보를 전달해요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, \\\"foo\\\" 패키지를 설치하고 싶다고 해봅시다. npm i foo를 실행한 후에, 내 package.json 파일에는 대부분 다음과 같은 항목이 있을 거에요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dependencies\\\"\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"foo\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"^2.3.0\\\"\"\n        }), \",\\n    ...\\n    ...\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 foo는 2.3.0 [주 버전 부 버전 패치 버전] 버전으로 설치되었어요. 이 caret 기호는 또 다른 정보를 알려줘요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"^2.3.0 — Caret Symbol: npm에게 마이너 및 패치 버전을 업그레이드하도록 지시하지만 메이저 버전은 업그레이드하지 않습니다. 기본적으로 2.3.4, 2.3.9, 2.4.5, 2.8는 가능하지만 3.0.0부터는 불가능합니다. (마이너 및 패치는 업그레이드하지만 메이저는 제외)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"~2.3.0 — Tilde Symbol: npm에게 패치 버전을 업그레이드하도록 지시하지만 마이너 및 메이저 버전은 업그레이드하지 않습니다. 따라서 2.3.4, 2.3.9는 가능하지만 2.4.0부터는 불가능합니다. (패치는 업그레이드하지만 마이너 및 메이저는 제외)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다른 npm 버전 업데이트 전략을 표시하는 여러 기호가 있습니다. 공식 npm 웹사이트가 좋은 참고자료가 될 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"따라서 \\\"foo\\\": \\\"^2.3.0\\\"의 경우, 며칠 후에 npm install을 실행하면 자동으로 마이너/패치 버전이 업그레이드될 수 있습니다. 이는 바람직하지 않습니다...\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"패키지 잠금파일(package-lock.json)이란?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_3.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"패키지 잠금파일(package-lock.json)은 노드.js 프로젝트에 설치된 종속성/패키지들과 정확한 버전 번호에 대한 정보를 포함하는 잠금 파일(lockfile)입니다 (*중요).\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이 파일은 동일한 저장소에서 작업하는 다른 개발자들이 이전에 설치된 정확한 패키지 버전을 설치할 수 있도록 도와줍니다. 새 버전의 패키지가 출시되어도 다른 기기/환경에서 동일한 node_modules 트리를 유지할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"패키지 잠금파일(package-lock.json)은 종속성을 특정 버전 번호로 잠그는 데 주로 사용됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이 파일은 node_modules 트리나 package.json 파일 중 하나라도 변경이 있을 때 자동으로 생성(또는 재생성)됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"저장소를 복제하고 새 기기에서 npm i를 실행할 때, npm은 먼저 패키지 잠금파일(package-lock.json)이 있는지 확인합니다. 있을 경우 해당 파일에 있는 패키지를 설치합니다. 그렇지 않으면 package.json 파일을 확인하고 필요한 종속성 패키지를 설치합니다. (📦 이에 대한 주의사항은 뒤의 글에서 설명됩니다)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-package-lockjsonTheCompleteGuide_4.png\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"패키지 잠금 파일(package-lock.json)은 커밋해야 하나요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"네, 이 파일은 소스 저장소에 커밋해야 합니다. 이렇게 하면 개발자가 귀하의 리포지토리를 클론할 때 귀하의 컴퓨터/환경에 설치된 의존성과 정확히 일치하는 의존성을 설치할 수 있습니다. 다른 컴퓨터에서 node.js 환경을 복제하는 데 도움이 됩니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"참고로\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저는 YouTube에서 아름다운 자바스크립트 체험을 보여주는 비디오를 만들고 있어요. (참고로 코딩 튜토리얼 채널은 아니에요...) 제 비디오를 확인해보세요:\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"npm install이 package-lock.json을 다시 작성하는 이유 / 시기\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"📦 주의: npm install은 package.json의 버전 범위 내에 설치할 패키지가 있는 경우에만 package-lock.json을 고려합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"잠금 파일에 지정된 패키지 버전이 package.json 파일의 버전 범위 내에 없는 경우, 패키지가 업데이트되고 package-lock.json 파일이 덮어씌워집니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"package-lock.json을 덮어쓰기 대신 설치를 실패하게 하려면 npm ci를 사용하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어,\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"패키지.json에서는 종속성을 다음과 같이 선언합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"foo\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"^2.3.0\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 npm install을 실행하면, 다음과 같은 package-lock.json이 생성됩니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"foo\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"2.3.0\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"몇 일 후에, \\\"foo\\\"의 새로운 부 버전인 \\\"2.4.0\\\"이 출시됩니다. 그리고 이렇게 됩니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"npm install — package-lock 버전이 범위 내에 있으므로(예: ^2.3.0) 2.3.0이 설치됩니다.\\nnpm ci — 이 명령은 어차피 package-lock.json만을 보기 때문에 2.3.0이 설치됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음으로, package.json을 수동으로 업데이트합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"foo\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"^2.4.0\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그럼 다시 실행해주세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"npm install 명령어를 실행하면 package-lock 파일의 버전이 범위 내에 없기 때문에 (예: ^2.4.0), 2.4.0 버전으로 설치되며 package-lock.json 파일은 이제 다음과 같이 다시 작성됩니다:\\n\\\"foo\\\": \\\"2.4.0\\\"\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"npm ci 명령어를 실행하면 package-lock.json 파일만 고려하지만 버전이 범위 내에 없기 때문에 오류가 발생합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"npm ci 명령어는 npm install과 유사하지만 테스트 플랫폼, 지속적인 통합, 배포 등과 같은 자동 환경에서 사용하기 위한 명령어입니다. 즉, 종속성을 깔끔하게 설치하고 싶은 경우에 유용합니다. (출처: npm 문서)\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"간단히 말해요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"npm install은 결정론적이지 않아서, 수천 개의 종속성이 포함된 리포지토리(다수의 개발자들이 참여)에서 작업할 때 문제가 발생할 수 있어요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"package-lock.json 파일은 npm install이 실행될 때 항상 동일한 node_modules 트리가 생성되도록 보장해줘요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"최신 명령어인 npm ci는 항상 동일한 node_modules 트리를 생성하도록 보장하며, 그렇지 않으면 오류를 발생시켜요.\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-package-lockjsonTheCompleteGuide"},"buildId":"R94iUTCf1NWeBC_VXjTJG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>