<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB" data-gatsby-head="true"/><meta name="twitter:title" content="리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 22:45" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png" alt="이미지"></p>
<p>건설 산업을 위한 웹 응용 프로그램(또는 현장에서 사용할 웹 응용 프로그램)을 구축한다고 상상해보세요. 이 앱에서 현장 감독관들은 작업 사이트에서 양식을 통해 프로젝트 및 근로자 상태를 데이터베이스에 업데이트합니다. 이제 하루에 여러 사이트를 방문하고 iPad를 통해 웹 앱에 엑세스해야 하는 경우를 상상해보세요. 이러한 시나리오에서는 지속적인 인터넷 연결을 보장할 수 없습니다. 이 정보에 프로젝트 성공에 중요한 자원이 의존하는 경우는 어떨까요? 이 위험을 어떻게 완화할 수 있을까요? 이를 완화하는 한 가지 방법은 오프라인 우선 방법으로 앱을 구축하는 것입니다.</p>
<p>우리는 React와 네이티브 자바스크립트 라이브러리인 서비스 워커(Service Workers)와 IndexedDB를 결합하여 웹에서 오프라인 우선 양식을 만들 것입니다.</p>
<p>서비스 워커란 무엇인가요?</p>
<p>서비스 워커는 웹의 시크릿 에이전트처럼, 뒷면에서 작업하는 것 같아요. 이들은 원본과 경로에 대해 등록된 이벤트 기반 워커입니다. 웹 페이지/사이트를 제어할 수 있는 자바스크립트 파일이에요. 이들 스크립트는 메인 브라우저 스레드와 별도로 실행되며 논블로킹입니다. 그들은 네트워크 요청을 가로채거나 자원 요청을 캐시하거나 검색하며 푸시 메시지를 전달할 수 있어요. 또한 오프라인 상태일 때에도 작동합니다. 이것은 오프라인 우선 구성 SaSS 시나리오에 완벽합니다.</p>
<p>동기화 관리자와 IndexedDB: 완벽한 조합</p>
<p>Sync Manager API는 안정적인 연결이 확립될 때까지 작업을 연기하는 데 도움을 주는 네이티브 JS 기능입니다. IndexedDB는 로컬 스토리지보다 훨씬 강력한 클라이언트 측 저장소를 위한 저수준 API입니다. 함께 사용할 때 웹 응용프로그램은 사용자 세션 및 연결 상태 변경 사이에서 데이터를 저장하고 동기화할 수 있습니다.</p>
<p>사용 사례: 오프라인에서 양식 데이터 저장</p>
<p>건설 앱 시나리오에서 사용자는 양식을 입력하고 제출하려고 합니다. 일반적으로 연결이 끊어지면 해당 데이터가 손실될 수 있습니다. 그러나 저희 설정은 서비스 워커를 사용하여 폼 제출을 가로채고 데이터를 IndexedDB에 저장하며 Sync Manager와 동기화를 등록합니다. 연결이 다시 연결되면 데이터가 서버로 전송됩니다. 코드에서 어떻게 작동하는지 살펴봅시다.</p>
<h1>코드 예시</h1>
<h2>시작하기</h2>
<p>저희는 빠른 실행과 Vite를 빌드 도구로 사용하겠습니다.</p>
<p>번을 설치한 후 다음 명령어를 사용하여 Vite로 생성된 React 앱을 만들고 실행할 수 있어요:</p>
<pre><code class="hljs language-js">bun create my-app --template react
</code></pre>
<pre><code class="hljs language-js">cd my-app &#x26;&#x26; bun run dev
</code></pre>
<p>저희는 src 디렉토리 내의 App.tsx 파일에서 애플리케이션을 개발하기 시작할 거예요.</p>
<p><strong>참고</strong>: 이 예제의 React JSX나 백엔드는 확인하지 않습니다. 백엔드는 저장된 사람들을 위한 GET 및 POST 엔드포인트가 있는 기본 REST API입니다. 전체 코드는 GitHub 저장소를 참조하십시오.</p>
<h1>단계 1: 서비스 워커 등록</h1>
<p>애플리케이션이 로드될 때, 브라우저가 서비스 워커를 지원하는지 확인하고, 지원하는 경우 서비스 워커 스크립트를 등록합니다 (나중에 이 service-worker.js를 생성합니다). 이 등록은 애플리케이션이 시작되면 발생하며, 서비스 워커가 요청을 가로채고 캐싱 및 동기화 작업을 관리할 준비가 되도록 합니다.</p>
<pre><code class="hljs language-js">interface <span class="hljs-title class_">Person</span> {
  <span class="hljs-attr">firstName</span>: string,
  <span class="hljs-attr">lastName</span>: string,
  <span class="hljs-attr">age</span>: number
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [people, setPeople] = useState&#x3C;<span class="hljs-title class_">Person</span>[]>([]);
  <span class="hljs-keyword">const</span> { register, handleSubmit } = <span class="hljs-title function_">useForm</span>();

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">registerWorker</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'serviceWorker'</span> <span class="hljs-keyword">in</span> navigator) {
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'load'</span>, <span class="hljs-function">() =></span> {
        navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">'/service-worker.js'</span>, {<span class="hljs-attr">scope</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">'module'</span>})
          .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">registration</span> =></span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Service Worker registered: '</span>, registration);
          })
          .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">registrationError</span> =></span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Service Worker registration failed: '</span>, registrationError); 
          });
      });
    }
  }
</code></pre>
<h1>단계 2: 서비스 워커 파일 생성 및 설치 시 IndexedDB 설정</h1>
<p>우리가 App.tsx에서 등록하려고 하는 서비스 워커를 생성하기 위해, src 디렉토리와 동일한 디렉토리 수준에 service-worker.js라는 파일을 만들 것입니다. 이렇게 하는 이유는 서비스 워커를 더 넓은 범위로 설정하기 위해서입니다. 더 높은 또는 루트 디렉토리 수준에 서비스 워커를 배치하면 애플리케이션 전체에서 더 많은 리소스에 대한 요청을 가로챌 수 있습니다. 이 위치 설정은 서비스 워커가 캐싱 및 네트워크 요청을 효과적으로 관리할 수 있도록하는 데 중요합니다.</p>
<p>이 서비스 워커 파일에서 'install' 이벤트 동안 IndexedDB를 초기화합니다. 우리는 formDataStore라는 데이터베이스를 설정하고 오프라인 폼 데이터를 저장하기 위해 특별히 설계된 formData 개체 저장소를 구성합니다. 이 설정은 앱에서 견고한 오프라인 기능을 활성화하는 데 중요합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// service-worker.js </span>

self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'install'</span>, <span class="hljs-keyword">async</span> (event) => {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Service Worker installing...'</span>);
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">openDB</span>(<span class="hljs-string">'formDataStore'</span>, <span class="hljs-number">1</span>, {
        <span class="hljs-title function_">upgrade</span>(<span class="hljs-params">db</span>) {
          <span class="hljs-keyword">if</span> (!db.<span class="hljs-property">objectStoreNames</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">'formData'</span>)) {
            db.<span class="hljs-title function_">createObjectStore</span>(<span class="hljs-string">'formData'</span>, { <span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span> });
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Object store created!'</span>);
          }
        },
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Service Worker installed.'</span>);
});
</code></pre>
<h1>단계 3: 폼 제출 가로채기</h1>
<p>폼이 제출되면, 애플리케이션은 기기가 온라인인지 확인합니다. 온라인 상태인 경우, 데이터를 API를 통해 직접 서버로 보냅니다. 오프라인 상태인 경우, 데이터를 IndexedDB에 저장합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// App.tsx</span>

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onSubmit</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">data: FieldValues</span>) => {
    <span class="hljs-keyword">if</span> (navigator.<span class="hljs-property">onLine</span>) {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-variable constant_">API_URL</span> + <span class="hljs-string">'/people'</span>,
        { <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>, <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data) }
      )
      <span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)
        <span class="hljs-title function_">setPeople</span>(<span class="hljs-function">(<span class="hljs-params">prevPeople</span>) =></span> [{...data} <span class="hljs-keyword">as</span> <span class="hljs-title class_">Person</span>, ...prevPeople])
      }

    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">storeFormDataLocally</span>(data);
    }
  }
</code></pre>
<h1>단계 4: 로컬로 데이터 저장하기</h1>
<p>오프라인 상태에서는 폼 데이터가 IndexedDB에 저장됩니다. 이 storeFormDataLocally 함수는 formData 객체 저장소에서 트랜잭션을 열고 데이터를 작성한 다음, 이 데이터가 서버로 전송되어야 할 것임을 나타내는 sendFormData 태그와의 백그라운드 동기화 이벤트를 등록합니다. 이렇게 하면 나중에 연결이 복원될 때 이 데이터를 서버로 보낼 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">storeFormDataLocally</span>(<span class="hljs-params">formData : FieldValues</span>) {

    <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> <span class="hljs-title function_">openDB</span>(<span class="hljs-string">'formDataStore'</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">const</span> tx = db.<span class="hljs-title function_">transaction</span>(<span class="hljs-string">'formData'</span>, <span class="hljs-string">'readwrite'</span>);
    <span class="hljs-keyword">const</span> store = tx.<span class="hljs-title function_">objectStore</span>(<span class="hljs-string">'formData'</span>);
    store.<span class="hljs-title function_">put</span>(formData);
    <span class="hljs-keyword">await</span> tx.<span class="hljs-property">done</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'serviceWorker'</span> <span class="hljs-keyword">in</span> navigator &#x26;&#x26; <span class="hljs-string">'SyncManager'</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) {
      <span class="hljs-keyword">const</span> registration : any  = <span class="hljs-keyword">await</span> navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">ready</span>
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">await</span> registration.<span class="hljs-property">sync</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">'sendFormData'</span>);
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Sync event registered'</span>);
      } <span class="hljs-keyword">catch</span>(e) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Failed to register sync, will retry on next   visit'</span> + e);
      }
  }
    db.<span class="hljs-title function_">close</span>();
  }
</code></pre>
<p>서비스 워커는 'sync' 이벤트를 수신 대기합니다. 이벤트가 트리거될 때(온라인으로 변경될 때 자동적으로 발생), IndexedDB에서 모든 저장된 폼 데이터를 검색하여 서버로 보내려고 시도합니다. 성공적인 제출은 그 후에 저장소에서 삭제되어 중복 전송을 방지합니다.</p>
<pre><code class="hljs language-js">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'sync'</span>, <span class="hljs-function"><span class="hljs-params">event</span> =></span> {
    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">tag</span> === <span class="hljs-string">'sendFormData'</span>) {
        event.<span class="hljs-title function_">waitUntil</span>(<span class="hljs-title function_">sendFormDataToServer</span>());
    }
});
</code></pre>
<h1>단계 6: 데이터 서버로 전송하고 IndexedDB 초기화하기</h1>
<p>실제 데이터 전송 함수는 formData 스토어에서 모든 항목을 가져와 각 항목을 서버로 전송하며 성공적인 전송 후 스토어에서 해당 항목을 제거합니다. 이렇게 함으로써 로컬 스토어를 유지하고 최신 상태로 유지할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sendFormDataToServer</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> <span class="hljs-title function_">openDB</span>(<span class="hljs-string">'formDataStore'</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">const</span> tx = db.<span class="hljs-title function_">transaction</span>(<span class="hljs-string">'formData'</span>, <span class="hljs-string">'readonly'</span>);
    <span class="hljs-keyword">const</span> store = tx.<span class="hljs-title function_">objectStore</span>(<span class="hljs-string">'formData'</span>);
    <span class="hljs-keyword">const</span> allSavedData = <span class="hljs-keyword">await</span> store.<span class="hljs-title function_">getAll</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'저장된 폼 데이터'</span>, allSavedData);
    <span class="hljs-keyword">try</span> {
        allSavedData.<span class="hljs-title function_">forEach</span>( <span class="hljs-keyword">async</span> (form, index) =>  {
            <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'http://localhost:3000/people'</span>,  
            {
                <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
                <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
                <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(form)
            });
            <span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'서버와 동기화된 데이터:'</span>, form);
                <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">transaction</span>(<span class="hljs-string">'formData'</span>, <span class="hljs-string">'readwrite'</span>).<span class="hljs-title function_">objectStore</span>(<span class="hljs-string">'formData'</span>).<span class="hljs-title function_">delete</span>(index);
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`제거된 폼 데이터: <span class="hljs-subst">${form.firstName}</span> <span class="hljs-subst">${form.lastName}</span>`</span> )
            }
        });
    } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'폼 데이터 전송 실패:'</span>, error);
    }
}
</code></pre>
<h1>결론</h1>
<p>건설 SaSS 웹 앱 시나리오로 돌아가 봅시다. 건설 현장에서는 감독관이 여러 장소를 자주 이동하며 중요한 프로젝트 및 작업자 데이터에 원활하게 접근할 수 있어야 합니다. 때때로 인터넷 연결이 불안정한 상황에서도요.</p>
<p>React, 서비스 워커 및 IndexedDB를 사용하여 오프라인 우선 접근 방식을 채택함으로써 이러한 독특한 요구 사항을 충족시켰습니다. 이러한 기술을 활용하면 지속적인 워크플로우를 지원하고 신뢰할 수 없는 연결성으로 인한 위험을 완화하며 모든 이해관계자가 최신 정보에 접근할 수 있도록하여 적시에 결정을 내릴 수 있게 하며 꾸준한 프로젝트 진행을 보장할 수 있습니다.</p>
<p>코드의 전체 내용은 여기에서 Github 저장소를 참조하세요.</p>
<p>원문은 <a href="https://dennistowns.substack.com%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">https://dennistowns.substack.com에서</a> 원본 게시됨.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식","description":"","date":"2024-05-12 22:45","slug":"2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB","content":"\n\n![이미지](/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png)\n\n건설 산업을 위한 웹 응용 프로그램(또는 현장에서 사용할 웹 응용 프로그램)을 구축한다고 상상해보세요. 이 앱에서 현장 감독관들은 작업 사이트에서 양식을 통해 프로젝트 및 근로자 상태를 데이터베이스에 업데이트합니다. 이제 하루에 여러 사이트를 방문하고 iPad를 통해 웹 앱에 엑세스해야 하는 경우를 상상해보세요. 이러한 시나리오에서는 지속적인 인터넷 연결을 보장할 수 없습니다. 이 정보에 프로젝트 성공에 중요한 자원이 의존하는 경우는 어떨까요? 이 위험을 어떻게 완화할 수 있을까요? 이를 완화하는 한 가지 방법은 오프라인 우선 방법으로 앱을 구축하는 것입니다.\n\n우리는 React와 네이티브 자바스크립트 라이브러리인 서비스 워커(Service Workers)와 IndexedDB를 결합하여 웹에서 오프라인 우선 양식을 만들 것입니다.\n\n서비스 워커란 무엇인가요?\n\n\n\n서비스 워커는 웹의 시크릿 에이전트처럼, 뒷면에서 작업하는 것 같아요. 이들은 원본과 경로에 대해 등록된 이벤트 기반 워커입니다. 웹 페이지/사이트를 제어할 수 있는 자바스크립트 파일이에요. 이들 스크립트는 메인 브라우저 스레드와 별도로 실행되며 논블로킹입니다. 그들은 네트워크 요청을 가로채거나 자원 요청을 캐시하거나 검색하며 푸시 메시지를 전달할 수 있어요. 또한 오프라인 상태일 때에도 작동합니다. 이것은 오프라인 우선 구성 SaSS 시나리오에 완벽합니다.\n\n동기화 관리자와 IndexedDB: 완벽한 조합\n\nSync Manager API는 안정적인 연결이 확립될 때까지 작업을 연기하는 데 도움을 주는 네이티브 JS 기능입니다. IndexedDB는 로컬 스토리지보다 훨씬 강력한 클라이언트 측 저장소를 위한 저수준 API입니다. 함께 사용할 때 웹 응용프로그램은 사용자 세션 및 연결 상태 변경 사이에서 데이터를 저장하고 동기화할 수 있습니다.\n\n사용 사례: 오프라인에서 양식 데이터 저장\n\n\n\n건설 앱 시나리오에서 사용자는 양식을 입력하고 제출하려고 합니다. 일반적으로 연결이 끊어지면 해당 데이터가 손실될 수 있습니다. 그러나 저희 설정은 서비스 워커를 사용하여 폼 제출을 가로채고 데이터를 IndexedDB에 저장하며 Sync Manager와 동기화를 등록합니다. 연결이 다시 연결되면 데이터가 서버로 전송됩니다. 코드에서 어떻게 작동하는지 살펴봅시다.\n\n# 코드 예시\n\n## 시작하기\n\n저희는 빠른 실행과 Vite를 빌드 도구로 사용하겠습니다.\n\n\n\n번을 설치한 후 다음 명령어를 사용하여 Vite로 생성된 React 앱을 만들고 실행할 수 있어요:\n\n```js\nbun create my-app --template react\n```\n\n```js\ncd my-app \u0026\u0026 bun run dev\n```\n\n저희는 src 디렉토리 내의 App.tsx 파일에서 애플리케이션을 개발하기 시작할 거예요.\n\n\n\n**참고**: 이 예제의 React JSX나 백엔드는 확인하지 않습니다. 백엔드는 저장된 사람들을 위한 GET 및 POST 엔드포인트가 있는 기본 REST API입니다. 전체 코드는 GitHub 저장소를 참조하십시오.\n\n# 단계 1: 서비스 워커 등록\n\n애플리케이션이 로드될 때, 브라우저가 서비스 워커를 지원하는지 확인하고, 지원하는 경우 서비스 워커 스크립트를 등록합니다 (나중에 이 service-worker.js를 생성합니다). 이 등록은 애플리케이션이 시작되면 발생하며, 서비스 워커가 요청을 가로채고 캐싱 및 동기화 작업을 관리할 준비가 되도록 합니다.\n\n```js\ninterface Person {\n  firstName: string,\n  lastName: string,\n  age: number\n}\n\nfunction App() {\n  const [people, setPeople] = useState\u003cPerson[]\u003e([]);\n  const { register, handleSubmit } = useForm();\n\n  const registerWorker = () =\u003e {\n    if ('serviceWorker' in navigator) {\n      window.addEventListener('load', () =\u003e {\n        navigator.serviceWorker.register('/service-worker.js', {scope: '/', type: 'module'})\n          .then(registration =\u003e {\n            console.log('Service Worker registered: ', registration);\n          })\n          .catch(registrationError =\u003e {\n            console.log('Service Worker registration failed: ', registrationError); \n          });\n      });\n    }\n  }\n```\n\n\n\n# 단계 2: 서비스 워커 파일 생성 및 설치 시 IndexedDB 설정\n\n우리가 App.tsx에서 등록하려고 하는 서비스 워커를 생성하기 위해, src 디렉토리와 동일한 디렉토리 수준에 service-worker.js라는 파일을 만들 것입니다. 이렇게 하는 이유는 서비스 워커를 더 넓은 범위로 설정하기 위해서입니다. 더 높은 또는 루트 디렉토리 수준에 서비스 워커를 배치하면 애플리케이션 전체에서 더 많은 리소스에 대한 요청을 가로챌 수 있습니다. 이 위치 설정은 서비스 워커가 캐싱 및 네트워크 요청을 효과적으로 관리할 수 있도록하는 데 중요합니다.\n\n이 서비스 워커 파일에서 'install' 이벤트 동안 IndexedDB를 초기화합니다. 우리는 formDataStore라는 데이터베이스를 설정하고 오프라인 폼 데이터를 저장하기 위해 특별히 설계된 formData 개체 저장소를 구성합니다. 이 설정은 앱에서 견고한 오프라인 기능을 활성화하는 데 중요합니다:\n\n```js\n// service-worker.js \n\nself.addEventListener('install', async (event) =\u003e {\n    console.log('Service Worker installing...');\n    await openDB('formDataStore', 1, {\n        upgrade(db) {\n          if (!db.objectStoreNames.contains('formData')) {\n            db.createObjectStore('formData', { autoIncrement: true });\n            console.log('Object store created!');\n          }\n        },\n    });\n    console.log('Service Worker installed.');\n});\n```\n\n\n\n# 단계 3: 폼 제출 가로채기\n\n폼이 제출되면, 애플리케이션은 기기가 온라인인지 확인합니다. 온라인 상태인 경우, 데이터를 API를 통해 직접 서버로 보냅니다. 오프라인 상태인 경우, 데이터를 IndexedDB에 저장합니다.\n\n```js\n// App.tsx\n\n  const onSubmit = async (data: FieldValues) =\u003e {\n    if (navigator.onLine) {\n      const response = await fetch(API_URL + '/people',\n        { method: \"POST\", body: JSON.stringify(data) }\n      )\n      if (response.ok) {\n        console.log(response)\n        setPeople((prevPeople) =\u003e [{...data} as Person, ...prevPeople])\n      }\n\n    } else {\n      await storeFormDataLocally(data);\n    }\n  }\n```\n\n# 단계 4: 로컬로 데이터 저장하기\n\n\n\n오프라인 상태에서는 폼 데이터가 IndexedDB에 저장됩니다. 이 storeFormDataLocally 함수는 formData 객체 저장소에서 트랜잭션을 열고 데이터를 작성한 다음, 이 데이터가 서버로 전송되어야 할 것임을 나타내는 sendFormData 태그와의 백그라운드 동기화 이벤트를 등록합니다. 이렇게 하면 나중에 연결이 복원될 때 이 데이터를 서버로 보낼 수 있습니다.\n\n```js\nasync function storeFormDataLocally(formData : FieldValues) {\n\n    const db = await openDB('formDataStore', 1);\n    const tx = db.transaction('formData', 'readwrite');\n    const store = tx.objectStore('formData');\n    store.put(formData);\n    await tx.done;\n    if ('serviceWorker' in navigator \u0026\u0026 'SyncManager' in window) {\n      const registration : any  = await navigator.serviceWorker.ready\n      try {\n        await registration.sync.register('sendFormData');\n          console.log('Sync event registered');\n      } catch(e) {\n          console.log('Failed to register sync, will retry on next   visit' + e);\n      }\n  }\n    db.close();\n  }\n```\n\n서비스 워커는 'sync' 이벤트를 수신 대기합니다. 이벤트가 트리거될 때(온라인으로 변경될 때 자동적으로 발생), IndexedDB에서 모든 저장된 폼 데이터를 검색하여 서버로 보내려고 시도합니다. 성공적인 제출은 그 후에 저장소에서 삭제되어 중복 전송을 방지합니다.\n\n```js\nself.addEventListener('sync', event =\u003e {\n    if (event.tag === 'sendFormData') {\n        event.waitUntil(sendFormDataToServer());\n    }\n});\n```\n\n\n\n# 단계 6: 데이터 서버로 전송하고 IndexedDB 초기화하기\n\n실제 데이터 전송 함수는 formData 스토어에서 모든 항목을 가져와 각 항목을 서버로 전송하며 성공적인 전송 후 스토어에서 해당 항목을 제거합니다. 이렇게 함으로써 로컬 스토어를 유지하고 최신 상태로 유지할 수 있습니다.\n\n```js\nexport async function sendFormDataToServer() {\n    const db = await openDB('formDataStore', 1);\n    const tx = db.transaction('formData', 'readonly');\n    const store = tx.objectStore('formData');\n    const allSavedData = await store.getAll();\n    console.log('저장된 폼 데이터', allSavedData);\n    try {\n        allSavedData.forEach( async (form, index) =\u003e  {\n            const response = await fetch('http://localhost:3000/people',  \n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(form)\n            });\n            if (response.ok) {\n                console.log('서버와 동기화된 데이터:', form);\n                await db.transaction('formData', 'readwrite').objectStore('formData').delete(index);\n                console.log(`제거된 폼 데이터: ${form.firstName} ${form.lastName}` )\n            }\n        });\n    } catch (error) {\n        console.error('폼 데이터 전송 실패:', error);\n    }\n}\n```\n\n# 결론\n\n\n\n건설 SaSS 웹 앱 시나리오로 돌아가 봅시다. 건설 현장에서는 감독관이 여러 장소를 자주 이동하며 중요한 프로젝트 및 작업자 데이터에 원활하게 접근할 수 있어야 합니다. 때때로 인터넷 연결이 불안정한 상황에서도요.\n\nReact, 서비스 워커 및 IndexedDB를 사용하여 오프라인 우선 접근 방식을 채택함으로써 이러한 독특한 요구 사항을 충족시켰습니다. 이러한 기술을 활용하면 지속적인 워크플로우를 지원하고 신뢰할 수 없는 연결성으로 인한 위험을 완화하며 모든 이해관계자가 최신 정보에 접근할 수 있도록하여 적시에 결정을 내릴 수 있게 하며 꾸준한 프로젝트 진행을 보장할 수 있습니다.\n\n코드의 전체 내용은 여기에서 Github 저장소를 참조하세요.\n\n원문은 https://dennistowns.substack.com에서 원본 게시됨.","ogImage":{"url":"/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png"},"coverImage":"/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e건설 산업을 위한 웹 응용 프로그램(또는 현장에서 사용할 웹 응용 프로그램)을 구축한다고 상상해보세요. 이 앱에서 현장 감독관들은 작업 사이트에서 양식을 통해 프로젝트 및 근로자 상태를 데이터베이스에 업데이트합니다. 이제 하루에 여러 사이트를 방문하고 iPad를 통해 웹 앱에 엑세스해야 하는 경우를 상상해보세요. 이러한 시나리오에서는 지속적인 인터넷 연결을 보장할 수 없습니다. 이 정보에 프로젝트 성공에 중요한 자원이 의존하는 경우는 어떨까요? 이 위험을 어떻게 완화할 수 있을까요? 이를 완화하는 한 가지 방법은 오프라인 우선 방법으로 앱을 구축하는 것입니다.\u003c/p\u003e\n\u003cp\u003e우리는 React와 네이티브 자바스크립트 라이브러리인 서비스 워커(Service Workers)와 IndexedDB를 결합하여 웹에서 오프라인 우선 양식을 만들 것입니다.\u003c/p\u003e\n\u003cp\u003e서비스 워커란 무엇인가요?\u003c/p\u003e\n\u003cp\u003e서비스 워커는 웹의 시크릿 에이전트처럼, 뒷면에서 작업하는 것 같아요. 이들은 원본과 경로에 대해 등록된 이벤트 기반 워커입니다. 웹 페이지/사이트를 제어할 수 있는 자바스크립트 파일이에요. 이들 스크립트는 메인 브라우저 스레드와 별도로 실행되며 논블로킹입니다. 그들은 네트워크 요청을 가로채거나 자원 요청을 캐시하거나 검색하며 푸시 메시지를 전달할 수 있어요. 또한 오프라인 상태일 때에도 작동합니다. 이것은 오프라인 우선 구성 SaSS 시나리오에 완벽합니다.\u003c/p\u003e\n\u003cp\u003e동기화 관리자와 IndexedDB: 완벽한 조합\u003c/p\u003e\n\u003cp\u003eSync Manager API는 안정적인 연결이 확립될 때까지 작업을 연기하는 데 도움을 주는 네이티브 JS 기능입니다. IndexedDB는 로컬 스토리지보다 훨씬 강력한 클라이언트 측 저장소를 위한 저수준 API입니다. 함께 사용할 때 웹 응용프로그램은 사용자 세션 및 연결 상태 변경 사이에서 데이터를 저장하고 동기화할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e사용 사례: 오프라인에서 양식 데이터 저장\u003c/p\u003e\n\u003cp\u003e건설 앱 시나리오에서 사용자는 양식을 입력하고 제출하려고 합니다. 일반적으로 연결이 끊어지면 해당 데이터가 손실될 수 있습니다. 그러나 저희 설정은 서비스 워커를 사용하여 폼 제출을 가로채고 데이터를 IndexedDB에 저장하며 Sync Manager와 동기화를 등록합니다. 연결이 다시 연결되면 데이터가 서버로 전송됩니다. 코드에서 어떻게 작동하는지 살펴봅시다.\u003c/p\u003e\n\u003ch1\u003e코드 예시\u003c/h1\u003e\n\u003ch2\u003e시작하기\u003c/h2\u003e\n\u003cp\u003e저희는 빠른 실행과 Vite를 빌드 도구로 사용하겠습니다.\u003c/p\u003e\n\u003cp\u003e번을 설치한 후 다음 명령어를 사용하여 Vite로 생성된 React 앱을 만들고 실행할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ebun create my-app --template react\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd my-app \u0026#x26;\u0026#x26; bun run dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e저희는 src 디렉토리 내의 App.tsx 파일에서 애플리케이션을 개발하기 시작할 거예요.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e참고\u003c/strong\u003e: 이 예제의 React JSX나 백엔드는 확인하지 않습니다. 백엔드는 저장된 사람들을 위한 GET 및 POST 엔드포인트가 있는 기본 REST API입니다. 전체 코드는 GitHub 저장소를 참조하십시오.\u003c/p\u003e\n\u003ch1\u003e단계 1: 서비스 워커 등록\u003c/h1\u003e\n\u003cp\u003e애플리케이션이 로드될 때, 브라우저가 서비스 워커를 지원하는지 확인하고, 지원하는 경우 서비스 워커 스크립트를 등록합니다 (나중에 이 service-worker.js를 생성합니다). 이 등록은 애플리케이션이 시작되면 발생하며, 서비스 워커가 요청을 가로채고 캐싱 및 동기화 작업을 관리할 준비가 되도록 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einterface \u003cspan class=\"hljs-title class_\"\u003ePerson\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003efirstName\u003c/span\u003e: string,\n  \u003cspan class=\"hljs-attr\"\u003elastName\u003c/span\u003e: string,\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: number\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eApp\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [people, setPeople] = useState\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003ePerson\u003c/span\u003e[]\u003e([]);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { register, handleSubmit } = \u003cspan class=\"hljs-title function_\"\u003euseForm\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eregisterWorker\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-string\"\u003e'serviceWorker'\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e navigator) {\n      \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'load'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n        navigator.\u003cspan class=\"hljs-property\"\u003eserviceWorker\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eregister\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/service-worker.js'\u003c/span\u003e, {\u003cspan class=\"hljs-attr\"\u003escope\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'module'\u003c/span\u003e})\n          .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eregistration\u003c/span\u003e =\u003e\u003c/span\u003e {\n            \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Service Worker registered: '\u003c/span\u003e, registration);\n          })\n          .\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eregistrationError\u003c/span\u003e =\u003e\u003c/span\u003e {\n            \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Service Worker registration failed: '\u003c/span\u003e, registrationError); \n          });\n      });\n    }\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 2: 서비스 워커 파일 생성 및 설치 시 IndexedDB 설정\u003c/h1\u003e\n\u003cp\u003e우리가 App.tsx에서 등록하려고 하는 서비스 워커를 생성하기 위해, src 디렉토리와 동일한 디렉토리 수준에 service-worker.js라는 파일을 만들 것입니다. 이렇게 하는 이유는 서비스 워커를 더 넓은 범위로 설정하기 위해서입니다. 더 높은 또는 루트 디렉토리 수준에 서비스 워커를 배치하면 애플리케이션 전체에서 더 많은 리소스에 대한 요청을 가로챌 수 있습니다. 이 위치 설정은 서비스 워커가 캐싱 및 네트워크 요청을 효과적으로 관리할 수 있도록하는 데 중요합니다.\u003c/p\u003e\n\u003cp\u003e이 서비스 워커 파일에서 'install' 이벤트 동안 IndexedDB를 초기화합니다. 우리는 formDataStore라는 데이터베이스를 설정하고 오프라인 폼 데이터를 저장하기 위해 특별히 설계된 formData 개체 저장소를 구성합니다. 이 설정은 앱에서 견고한 오프라인 기능을 활성화하는 데 중요합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// service-worker.js \u003c/span\u003e\n\nself.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'install'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (event) =\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Service Worker installing...'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eopenDB\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'formDataStore'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, {\n        \u003cspan class=\"hljs-title function_\"\u003eupgrade\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edb\u003c/span\u003e) {\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!db.\u003cspan class=\"hljs-property\"\u003eobjectStoreNames\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econtains\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'formData'\u003c/span\u003e)) {\n            db.\u003cspan class=\"hljs-title function_\"\u003ecreateObjectStore\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'formData'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003eautoIncrement\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e });\n            \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Object store created!'\u003c/span\u003e);\n          }\n        },\n    });\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Service Worker installed.'\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 3: 폼 제출 가로채기\u003c/h1\u003e\n\u003cp\u003e폼이 제출되면, 애플리케이션은 기기가 온라인인지 확인합니다. 온라인 상태인 경우, 데이터를 API를 통해 직접 서버로 보냅니다. 오프라인 상태인 경우, 데이터를 IndexedDB에 저장합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// App.tsx\u003c/span\u003e\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonSubmit\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003edata: FieldValues\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (navigator.\u003cspan class=\"hljs-property\"\u003eonLine\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAPI_URL\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e'/people'\u003c/span\u003e,\n        { \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"POST\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(data) }\n      )\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (response.\u003cspan class=\"hljs-property\"\u003eok\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(response)\n        \u003cspan class=\"hljs-title function_\"\u003esetPeople\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprevPeople\u003c/span\u003e) =\u003e\u003c/span\u003e [{...data} \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePerson\u003c/span\u003e, ...prevPeople])\n      }\n\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003estoreFormDataLocally\u003c/span\u003e(data);\n    }\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 4: 로컬로 데이터 저장하기\u003c/h1\u003e\n\u003cp\u003e오프라인 상태에서는 폼 데이터가 IndexedDB에 저장됩니다. 이 storeFormDataLocally 함수는 formData 객체 저장소에서 트랜잭션을 열고 데이터를 작성한 다음, 이 데이터가 서버로 전송되어야 할 것임을 나타내는 sendFormData 태그와의 백그라운드 동기화 이벤트를 등록합니다. 이렇게 하면 나중에 연결이 복원될 때 이 데이터를 서버로 보낼 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003estoreFormDataLocally\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eformData : FieldValues\u003c/span\u003e) {\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e db = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eopenDB\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'formDataStore'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tx = db.\u003cspan class=\"hljs-title function_\"\u003etransaction\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'formData'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'readwrite'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e store = tx.\u003cspan class=\"hljs-title function_\"\u003eobjectStore\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'formData'\u003c/span\u003e);\n    store.\u003cspan class=\"hljs-title function_\"\u003eput\u003c/span\u003e(formData);\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e tx.\u003cspan class=\"hljs-property\"\u003edone\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-string\"\u003e'serviceWorker'\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e navigator \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-string\"\u003e'SyncManager'\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e registration : any  = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e navigator.\u003cspan class=\"hljs-property\"\u003eserviceWorker\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eready\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e registration.\u003cspan class=\"hljs-property\"\u003esync\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eregister\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'sendFormData'\u003c/span\u003e);\n          \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Sync event registered'\u003c/span\u003e);\n      } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(e) {\n          \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Failed to register sync, will retry on next   visit'\u003c/span\u003e + e);\n      }\n  }\n    db.\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e();\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서비스 워커는 'sync' 이벤트를 수신 대기합니다. 이벤트가 트리거될 때(온라인으로 변경될 때 자동적으로 발생), IndexedDB에서 모든 저장된 폼 데이터를 검색하여 서버로 보내려고 시도합니다. 성공적인 제출은 그 후에 저장소에서 삭제되어 중복 전송을 방지합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eself.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'sync'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (event.\u003cspan class=\"hljs-property\"\u003etag\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'sendFormData'\u003c/span\u003e) {\n        event.\u003cspan class=\"hljs-title function_\"\u003ewaitUntil\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003esendFormDataToServer\u003c/span\u003e());\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 6: 데이터 서버로 전송하고 IndexedDB 초기화하기\u003c/h1\u003e\n\u003cp\u003e실제 데이터 전송 함수는 formData 스토어에서 모든 항목을 가져와 각 항목을 서버로 전송하며 성공적인 전송 후 스토어에서 해당 항목을 제거합니다. 이렇게 함으로써 로컬 스토어를 유지하고 최신 상태로 유지할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esendFormDataToServer\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e db = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eopenDB\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'formDataStore'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tx = db.\u003cspan class=\"hljs-title function_\"\u003etransaction\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'formData'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'readonly'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e store = tx.\u003cspan class=\"hljs-title function_\"\u003eobjectStore\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'formData'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e allSavedData = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e store.\u003cspan class=\"hljs-title function_\"\u003egetAll\u003c/span\u003e();\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'저장된 폼 데이터'\u003c/span\u003e, allSavedData);\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n        allSavedData.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e( \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (form, index) =\u003e  {\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'http://localhost:3000/people'\u003c/span\u003e,  \n            {\n                \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'POST'\u003c/span\u003e,\n                \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: { \u003cspan class=\"hljs-string\"\u003e'Content-Type'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e },\n                \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(form)\n            });\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (response.\u003cspan class=\"hljs-property\"\u003eok\u003c/span\u003e) {\n                \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'서버와 동기화된 데이터:'\u003c/span\u003e, form);\n                \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e db.\u003cspan class=\"hljs-title function_\"\u003etransaction\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'formData'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'readwrite'\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eobjectStore\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'formData'\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(index);\n                \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`제거된 폼 데이터: \u003cspan class=\"hljs-subst\"\u003e${form.firstName}\u003c/span\u003e \u003cspan class=\"hljs-subst\"\u003e${form.lastName}\u003c/span\u003e`\u003c/span\u003e )\n            }\n        });\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'폼 데이터 전송 실패:'\u003c/span\u003e, error);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e건설 SaSS 웹 앱 시나리오로 돌아가 봅시다. 건설 현장에서는 감독관이 여러 장소를 자주 이동하며 중요한 프로젝트 및 작업자 데이터에 원활하게 접근할 수 있어야 합니다. 때때로 인터넷 연결이 불안정한 상황에서도요.\u003c/p\u003e\n\u003cp\u003eReact, 서비스 워커 및 IndexedDB를 사용하여 오프라인 우선 접근 방식을 채택함으로써 이러한 독특한 요구 사항을 충족시켰습니다. 이러한 기술을 활용하면 지속적인 워크플로우를 지원하고 신뢰할 수 없는 연결성으로 인한 위험을 완화하며 모든 이해관계자가 최신 정보에 접근할 수 있도록하여 적시에 결정을 내릴 수 있게 하며 꾸준한 프로젝트 진행을 보장할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e코드의 전체 내용은 여기에서 Github 저장소를 참조하세요.\u003c/p\u003e\n\u003cp\u003e원문은 \u003ca href=\"https://dennistowns.substack.com%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://dennistowns.substack.com에서\u003c/a\u003e 원본 게시됨.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>