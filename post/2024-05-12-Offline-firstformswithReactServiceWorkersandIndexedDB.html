<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB" data-gatsby-head="true"/><meta name="twitter:title" content="리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 22:45" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_buildManifest.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png" alt="이미지"/></p>
<p>건설 산업을 위한 웹 응용 프로그램(또는 현장에서 사용할 웹 응용 프로그램)을 구축한다고 상상해보세요. 이 앱에서 현장 감독관들은 작업 사이트에서 양식을 통해 프로젝트 및 근로자 상태를 데이터베이스에 업데이트합니다. 이제 하루에 여러 사이트를 방문하고 iPad를 통해 웹 앱에 엑세스해야 하는 경우를 상상해보세요. 이러한 시나리오에서는 지속적인 인터넷 연결을 보장할 수 없습니다. 이 정보에 프로젝트 성공에 중요한 자원이 의존하는 경우는 어떨까요? 이 위험을 어떻게 완화할 수 있을까요? 이를 완화하는 한 가지 방법은 오프라인 우선 방법으로 앱을 구축하는 것입니다.</p>
<p>우리는 React와 네이티브 자바스크립트 라이브러리인 서비스 워커(Service Workers)와 IndexedDB를 결합하여 웹에서 오프라인 우선 양식을 만들 것입니다.</p>
<p>서비스 워커란 무엇인가요?</p>
<p>서비스 워커는 웹의 시크릿 에이전트처럼, 뒷면에서 작업하는 것 같아요. 이들은 원본과 경로에 대해 등록된 이벤트 기반 워커입니다. 웹 페이지/사이트를 제어할 수 있는 자바스크립트 파일이에요. 이들 스크립트는 메인 브라우저 스레드와 별도로 실행되며 논블로킹입니다. 그들은 네트워크 요청을 가로채거나 자원 요청을 캐시하거나 검색하며 푸시 메시지를 전달할 수 있어요. 또한 오프라인 상태일 때에도 작동합니다. 이것은 오프라인 우선 구성 SaSS 시나리오에 완벽합니다.</p>
<p>동기화 관리자와 IndexedDB: 완벽한 조합</p>
<p>Sync Manager API는 안정적인 연결이 확립될 때까지 작업을 연기하는 데 도움을 주는 네이티브 JS 기능입니다. IndexedDB는 로컬 스토리지보다 훨씬 강력한 클라이언트 측 저장소를 위한 저수준 API입니다. 함께 사용할 때 웹 응용프로그램은 사용자 세션 및 연결 상태 변경 사이에서 데이터를 저장하고 동기화할 수 있습니다.</p>
<p>사용 사례: 오프라인에서 양식 데이터 저장</p>
<p>건설 앱 시나리오에서 사용자는 양식을 입력하고 제출하려고 합니다. 일반적으로 연결이 끊어지면 해당 데이터가 손실될 수 있습니다. 그러나 저희 설정은 서비스 워커를 사용하여 폼 제출을 가로채고 데이터를 IndexedDB에 저장하며 Sync Manager와 동기화를 등록합니다. 연결이 다시 연결되면 데이터가 서버로 전송됩니다. 코드에서 어떻게 작동하는지 살펴봅시다.</p>
<h1>코드 예시</h1>
<h2>시작하기</h2>
<p>저희는 빠른 실행과 Vite를 빌드 도구로 사용하겠습니다.</p>
<p>번을 설치한 후 다음 명령어를 사용하여 Vite로 생성된 React 앱을 만들고 실행할 수 있어요:</p>
<pre><code class="hljs language-js">bun create my-app --template react
</code></pre>
<pre><code class="hljs language-js">cd my-app &amp;&amp; bun run dev
</code></pre>
<p>저희는 src 디렉토리 내의 App.tsx 파일에서 애플리케이션을 개발하기 시작할 거예요.</p>
<p><strong>참고</strong>: 이 예제의 React JSX나 백엔드는 확인하지 않습니다. 백엔드는 저장된 사람들을 위한 GET 및 POST 엔드포인트가 있는 기본 REST API입니다. 전체 코드는 GitHub 저장소를 참조하십시오.</p>
<h1>단계 1: 서비스 워커 등록</h1>
<p>애플리케이션이 로드될 때, 브라우저가 서비스 워커를 지원하는지 확인하고, 지원하는 경우 서비스 워커 스크립트를 등록합니다 (나중에 이 service-worker.js를 생성합니다). 이 등록은 애플리케이션이 시작되면 발생하며, 서비스 워커가 요청을 가로채고 캐싱 및 동기화 작업을 관리할 준비가 되도록 합니다.</p>
<pre><code class="hljs language-js">interface <span class="hljs-title class_">Person</span> {
  <span class="hljs-attr">firstName</span>: string,
  <span class="hljs-attr">lastName</span>: string,
  <span class="hljs-attr">age</span>: number
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [people, setPeople] = useState&lt;<span class="hljs-title class_">Person</span>[]&gt;([]);
  <span class="hljs-keyword">const</span> { register, handleSubmit } = <span class="hljs-title function_">useForm</span>();

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">registerWorker</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator) {
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
        navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;/service-worker.js&#x27;</span>, {<span class="hljs-attr">scope</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;module&#x27;</span>})
          .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">registration</span> =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Service Worker registered: &#x27;</span>, registration);
          })
          .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">registrationError</span> =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Service Worker registration failed: &#x27;</span>, registrationError); 
          });
      });
    }
  }
</code></pre>
<h1>단계 2: 서비스 워커 파일 생성 및 설치 시 IndexedDB 설정</h1>
<p>우리가 App.tsx에서 등록하려고 하는 서비스 워커를 생성하기 위해, src 디렉토리와 동일한 디렉토리 수준에 service-worker.js라는 파일을 만들 것입니다. 이렇게 하는 이유는 서비스 워커를 더 넓은 범위로 설정하기 위해서입니다. 더 높은 또는 루트 디렉토리 수준에 서비스 워커를 배치하면 애플리케이션 전체에서 더 많은 리소스에 대한 요청을 가로챌 수 있습니다. 이 위치 설정은 서비스 워커가 캐싱 및 네트워크 요청을 효과적으로 관리할 수 있도록하는 데 중요합니다.</p>
<p>이 서비스 워커 파일에서 &#x27;install&#x27; 이벤트 동안 IndexedDB를 초기화합니다. 우리는 formDataStore라는 데이터베이스를 설정하고 오프라인 폼 데이터를 저장하기 위해 특별히 설계된 formData 개체 저장소를 구성합니다. 이 설정은 앱에서 견고한 오프라인 기능을 활성화하는 데 중요합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// service-worker.js </span>

self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-keyword">async</span> (event) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Service Worker installing...&#x27;</span>);
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">openDB</span>(<span class="hljs-string">&#x27;formDataStore&#x27;</span>, <span class="hljs-number">1</span>, {
        <span class="hljs-title function_">upgrade</span>(<span class="hljs-params">db</span>) {
          <span class="hljs-keyword">if</span> (!db.<span class="hljs-property">objectStoreNames</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&#x27;formData&#x27;</span>)) {
            db.<span class="hljs-title function_">createObjectStore</span>(<span class="hljs-string">&#x27;formData&#x27;</span>, { <span class="hljs-attr">autoIncrement</span>: <span class="hljs-literal">true</span> });
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Object store created!&#x27;</span>);
          }
        },
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Service Worker installed.&#x27;</span>);
});
</code></pre>
<h1>단계 3: 폼 제출 가로채기</h1>
<p>폼이 제출되면, 애플리케이션은 기기가 온라인인지 확인합니다. 온라인 상태인 경우, 데이터를 API를 통해 직접 서버로 보냅니다. 오프라인 상태인 경우, 데이터를 IndexedDB에 저장합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// App.tsx</span>

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onSubmit</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">data: FieldValues</span>) =&gt; {
    <span class="hljs-keyword">if</span> (navigator.<span class="hljs-property">onLine</span>) {
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-variable constant_">API_URL</span> + <span class="hljs-string">&#x27;/people&#x27;</span>,
        { <span class="hljs-attr">method</span>: <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data) }
      )
      <span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)
        <span class="hljs-title function_">setPeople</span>(<span class="hljs-function">(<span class="hljs-params">prevPeople</span>) =&gt;</span> [{...data} <span class="hljs-keyword">as</span> <span class="hljs-title class_">Person</span>, ...prevPeople])
      }

    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">storeFormDataLocally</span>(data);
    }
  }
</code></pre>
<h1>단계 4: 로컬로 데이터 저장하기</h1>
<p>오프라인 상태에서는 폼 데이터가 IndexedDB에 저장됩니다. 이 storeFormDataLocally 함수는 formData 객체 저장소에서 트랜잭션을 열고 데이터를 작성한 다음, 이 데이터가 서버로 전송되어야 할 것임을 나타내는 sendFormData 태그와의 백그라운드 동기화 이벤트를 등록합니다. 이렇게 하면 나중에 연결이 복원될 때 이 데이터를 서버로 보낼 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">storeFormDataLocally</span>(<span class="hljs-params">formData : FieldValues</span>) {

    <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> <span class="hljs-title function_">openDB</span>(<span class="hljs-string">&#x27;formDataStore&#x27;</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">const</span> tx = db.<span class="hljs-title function_">transaction</span>(<span class="hljs-string">&#x27;formData&#x27;</span>, <span class="hljs-string">&#x27;readwrite&#x27;</span>);
    <span class="hljs-keyword">const</span> store = tx.<span class="hljs-title function_">objectStore</span>(<span class="hljs-string">&#x27;formData&#x27;</span>);
    store.<span class="hljs-title function_">put</span>(formData);
    <span class="hljs-keyword">await</span> tx.<span class="hljs-property">done</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator &amp;&amp; <span class="hljs-string">&#x27;SyncManager&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) {
      <span class="hljs-keyword">const</span> registration : any  = <span class="hljs-keyword">await</span> navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">ready</span>
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">await</span> registration.<span class="hljs-property">sync</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;sendFormData&#x27;</span>);
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Sync event registered&#x27;</span>);
      } <span class="hljs-keyword">catch</span>(e) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Failed to register sync, will retry on next   visit&#x27;</span> + e);
      }
  }
    db.<span class="hljs-title function_">close</span>();
  }
</code></pre>
<p>서비스 워커는 &#x27;sync&#x27; 이벤트를 수신 대기합니다. 이벤트가 트리거될 때(온라인으로 변경될 때 자동적으로 발생), IndexedDB에서 모든 저장된 폼 데이터를 검색하여 서버로 보내려고 시도합니다. 성공적인 제출은 그 후에 저장소에서 삭제되어 중복 전송을 방지합니다.</p>
<pre><code class="hljs language-js">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;sync&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">tag</span> === <span class="hljs-string">&#x27;sendFormData&#x27;</span>) {
        event.<span class="hljs-title function_">waitUntil</span>(<span class="hljs-title function_">sendFormDataToServer</span>());
    }
});
</code></pre>
<h1>단계 6: 데이터 서버로 전송하고 IndexedDB 초기화하기</h1>
<p>실제 데이터 전송 함수는 formData 스토어에서 모든 항목을 가져와 각 항목을 서버로 전송하며 성공적인 전송 후 스토어에서 해당 항목을 제거합니다. 이렇게 함으로써 로컬 스토어를 유지하고 최신 상태로 유지할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sendFormDataToServer</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">await</span> <span class="hljs-title function_">openDB</span>(<span class="hljs-string">&#x27;formDataStore&#x27;</span>, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">const</span> tx = db.<span class="hljs-title function_">transaction</span>(<span class="hljs-string">&#x27;formData&#x27;</span>, <span class="hljs-string">&#x27;readonly&#x27;</span>);
    <span class="hljs-keyword">const</span> store = tx.<span class="hljs-title function_">objectStore</span>(<span class="hljs-string">&#x27;formData&#x27;</span>);
    <span class="hljs-keyword">const</span> allSavedData = <span class="hljs-keyword">await</span> store.<span class="hljs-title function_">getAll</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;저장된 폼 데이터&#x27;</span>, allSavedData);
    <span class="hljs-keyword">try</span> {
        allSavedData.<span class="hljs-title function_">forEach</span>( <span class="hljs-keyword">async</span> (form, index) =&gt;  {
            <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://localhost:3000/people&#x27;</span>,  
            {
                <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
                <span class="hljs-attr">headers</span>: { <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> },
                <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(form)
            });
            <span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;서버와 동기화된 데이터:&#x27;</span>, form);
                <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">transaction</span>(<span class="hljs-string">&#x27;formData&#x27;</span>, <span class="hljs-string">&#x27;readwrite&#x27;</span>).<span class="hljs-title function_">objectStore</span>(<span class="hljs-string">&#x27;formData&#x27;</span>).<span class="hljs-title function_">delete</span>(index);
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`제거된 폼 데이터: <span class="hljs-subst">${form.firstName}</span> <span class="hljs-subst">${form.lastName}</span>`</span> )
            }
        });
    } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;폼 데이터 전송 실패:&#x27;</span>, error);
    }
}
</code></pre>
<h1>결론</h1>
<p>건설 SaSS 웹 앱 시나리오로 돌아가 봅시다. 건설 현장에서는 감독관이 여러 장소를 자주 이동하며 중요한 프로젝트 및 작업자 데이터에 원활하게 접근할 수 있어야 합니다. 때때로 인터넷 연결이 불안정한 상황에서도요.</p>
<p>React, 서비스 워커 및 IndexedDB를 사용하여 오프라인 우선 접근 방식을 채택함으로써 이러한 독특한 요구 사항을 충족시켰습니다. 이러한 기술을 활용하면 지속적인 워크플로우를 지원하고 신뢰할 수 없는 연결성으로 인한 위험을 완화하며 모든 이해관계자가 최신 정보에 접근할 수 있도록하여 적시에 결정을 내릴 수 있게 하며 꾸준한 프로젝트 진행을 보장할 수 있습니다.</p>
<p>코드의 전체 내용은 여기에서 Github 저장소를 참조하세요.</p>
<p>원문은 https://dennistowns.substack.com에서 원본 게시됨.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트, 서비스 워커, IndexedDB를 이용한 오프라인 우선 양식","description":"","date":"2024-05-12 22:45","slug":"2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB","content":"\n\n![이미지](/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png)\n\n건설 산업을 위한 웹 응용 프로그램(또는 현장에서 사용할 웹 응용 프로그램)을 구축한다고 상상해보세요. 이 앱에서 현장 감독관들은 작업 사이트에서 양식을 통해 프로젝트 및 근로자 상태를 데이터베이스에 업데이트합니다. 이제 하루에 여러 사이트를 방문하고 iPad를 통해 웹 앱에 엑세스해야 하는 경우를 상상해보세요. 이러한 시나리오에서는 지속적인 인터넷 연결을 보장할 수 없습니다. 이 정보에 프로젝트 성공에 중요한 자원이 의존하는 경우는 어떨까요? 이 위험을 어떻게 완화할 수 있을까요? 이를 완화하는 한 가지 방법은 오프라인 우선 방법으로 앱을 구축하는 것입니다.\n\n우리는 React와 네이티브 자바스크립트 라이브러리인 서비스 워커(Service Workers)와 IndexedDB를 결합하여 웹에서 오프라인 우선 양식을 만들 것입니다.\n\n서비스 워커란 무엇인가요?\n\n\n\n서비스 워커는 웹의 시크릿 에이전트처럼, 뒷면에서 작업하는 것 같아요. 이들은 원본과 경로에 대해 등록된 이벤트 기반 워커입니다. 웹 페이지/사이트를 제어할 수 있는 자바스크립트 파일이에요. 이들 스크립트는 메인 브라우저 스레드와 별도로 실행되며 논블로킹입니다. 그들은 네트워크 요청을 가로채거나 자원 요청을 캐시하거나 검색하며 푸시 메시지를 전달할 수 있어요. 또한 오프라인 상태일 때에도 작동합니다. 이것은 오프라인 우선 구성 SaSS 시나리오에 완벽합니다.\n\n동기화 관리자와 IndexedDB: 완벽한 조합\n\nSync Manager API는 안정적인 연결이 확립될 때까지 작업을 연기하는 데 도움을 주는 네이티브 JS 기능입니다. IndexedDB는 로컬 스토리지보다 훨씬 강력한 클라이언트 측 저장소를 위한 저수준 API입니다. 함께 사용할 때 웹 응용프로그램은 사용자 세션 및 연결 상태 변경 사이에서 데이터를 저장하고 동기화할 수 있습니다.\n\n사용 사례: 오프라인에서 양식 데이터 저장\n\n\n\n건설 앱 시나리오에서 사용자는 양식을 입력하고 제출하려고 합니다. 일반적으로 연결이 끊어지면 해당 데이터가 손실될 수 있습니다. 그러나 저희 설정은 서비스 워커를 사용하여 폼 제출을 가로채고 데이터를 IndexedDB에 저장하며 Sync Manager와 동기화를 등록합니다. 연결이 다시 연결되면 데이터가 서버로 전송됩니다. 코드에서 어떻게 작동하는지 살펴봅시다.\n\n# 코드 예시\n\n## 시작하기\n\n저희는 빠른 실행과 Vite를 빌드 도구로 사용하겠습니다.\n\n\n\n번을 설치한 후 다음 명령어를 사용하여 Vite로 생성된 React 앱을 만들고 실행할 수 있어요:\n\n```js\nbun create my-app --template react\n```\n\n```js\ncd my-app \u0026\u0026 bun run dev\n```\n\n저희는 src 디렉토리 내의 App.tsx 파일에서 애플리케이션을 개발하기 시작할 거예요.\n\n\n\n**참고**: 이 예제의 React JSX나 백엔드는 확인하지 않습니다. 백엔드는 저장된 사람들을 위한 GET 및 POST 엔드포인트가 있는 기본 REST API입니다. 전체 코드는 GitHub 저장소를 참조하십시오.\n\n# 단계 1: 서비스 워커 등록\n\n애플리케이션이 로드될 때, 브라우저가 서비스 워커를 지원하는지 확인하고, 지원하는 경우 서비스 워커 스크립트를 등록합니다 (나중에 이 service-worker.js를 생성합니다). 이 등록은 애플리케이션이 시작되면 발생하며, 서비스 워커가 요청을 가로채고 캐싱 및 동기화 작업을 관리할 준비가 되도록 합니다.\n\n```js\ninterface Person {\n  firstName: string,\n  lastName: string,\n  age: number\n}\n\nfunction App() {\n  const [people, setPeople] = useState\u003cPerson[]\u003e([]);\n  const { register, handleSubmit } = useForm();\n\n  const registerWorker = () =\u003e {\n    if ('serviceWorker' in navigator) {\n      window.addEventListener('load', () =\u003e {\n        navigator.serviceWorker.register('/service-worker.js', {scope: '/', type: 'module'})\n          .then(registration =\u003e {\n            console.log('Service Worker registered: ', registration);\n          })\n          .catch(registrationError =\u003e {\n            console.log('Service Worker registration failed: ', registrationError); \n          });\n      });\n    }\n  }\n```\n\n\n\n# 단계 2: 서비스 워커 파일 생성 및 설치 시 IndexedDB 설정\n\n우리가 App.tsx에서 등록하려고 하는 서비스 워커를 생성하기 위해, src 디렉토리와 동일한 디렉토리 수준에 service-worker.js라는 파일을 만들 것입니다. 이렇게 하는 이유는 서비스 워커를 더 넓은 범위로 설정하기 위해서입니다. 더 높은 또는 루트 디렉토리 수준에 서비스 워커를 배치하면 애플리케이션 전체에서 더 많은 리소스에 대한 요청을 가로챌 수 있습니다. 이 위치 설정은 서비스 워커가 캐싱 및 네트워크 요청을 효과적으로 관리할 수 있도록하는 데 중요합니다.\n\n이 서비스 워커 파일에서 'install' 이벤트 동안 IndexedDB를 초기화합니다. 우리는 formDataStore라는 데이터베이스를 설정하고 오프라인 폼 데이터를 저장하기 위해 특별히 설계된 formData 개체 저장소를 구성합니다. 이 설정은 앱에서 견고한 오프라인 기능을 활성화하는 데 중요합니다:\n\n```js\n// service-worker.js \n\nself.addEventListener('install', async (event) =\u003e {\n    console.log('Service Worker installing...');\n    await openDB('formDataStore', 1, {\n        upgrade(db) {\n          if (!db.objectStoreNames.contains('formData')) {\n            db.createObjectStore('formData', { autoIncrement: true });\n            console.log('Object store created!');\n          }\n        },\n    });\n    console.log('Service Worker installed.');\n});\n```\n\n\n\n# 단계 3: 폼 제출 가로채기\n\n폼이 제출되면, 애플리케이션은 기기가 온라인인지 확인합니다. 온라인 상태인 경우, 데이터를 API를 통해 직접 서버로 보냅니다. 오프라인 상태인 경우, 데이터를 IndexedDB에 저장합니다.\n\n```js\n// App.tsx\n\n  const onSubmit = async (data: FieldValues) =\u003e {\n    if (navigator.onLine) {\n      const response = await fetch(API_URL + '/people',\n        { method: \"POST\", body: JSON.stringify(data) }\n      )\n      if (response.ok) {\n        console.log(response)\n        setPeople((prevPeople) =\u003e [{...data} as Person, ...prevPeople])\n      }\n\n    } else {\n      await storeFormDataLocally(data);\n    }\n  }\n```\n\n# 단계 4: 로컬로 데이터 저장하기\n\n\n\n오프라인 상태에서는 폼 데이터가 IndexedDB에 저장됩니다. 이 storeFormDataLocally 함수는 formData 객체 저장소에서 트랜잭션을 열고 데이터를 작성한 다음, 이 데이터가 서버로 전송되어야 할 것임을 나타내는 sendFormData 태그와의 백그라운드 동기화 이벤트를 등록합니다. 이렇게 하면 나중에 연결이 복원될 때 이 데이터를 서버로 보낼 수 있습니다.\n\n```js\nasync function storeFormDataLocally(formData : FieldValues) {\n\n    const db = await openDB('formDataStore', 1);\n    const tx = db.transaction('formData', 'readwrite');\n    const store = tx.objectStore('formData');\n    store.put(formData);\n    await tx.done;\n    if ('serviceWorker' in navigator \u0026\u0026 'SyncManager' in window) {\n      const registration : any  = await navigator.serviceWorker.ready\n      try {\n        await registration.sync.register('sendFormData');\n          console.log('Sync event registered');\n      } catch(e) {\n          console.log('Failed to register sync, will retry on next   visit' + e);\n      }\n  }\n    db.close();\n  }\n```\n\n서비스 워커는 'sync' 이벤트를 수신 대기합니다. 이벤트가 트리거될 때(온라인으로 변경될 때 자동적으로 발생), IndexedDB에서 모든 저장된 폼 데이터를 검색하여 서버로 보내려고 시도합니다. 성공적인 제출은 그 후에 저장소에서 삭제되어 중복 전송을 방지합니다.\n\n```js\nself.addEventListener('sync', event =\u003e {\n    if (event.tag === 'sendFormData') {\n        event.waitUntil(sendFormDataToServer());\n    }\n});\n```\n\n\n\n# 단계 6: 데이터 서버로 전송하고 IndexedDB 초기화하기\n\n실제 데이터 전송 함수는 formData 스토어에서 모든 항목을 가져와 각 항목을 서버로 전송하며 성공적인 전송 후 스토어에서 해당 항목을 제거합니다. 이렇게 함으로써 로컬 스토어를 유지하고 최신 상태로 유지할 수 있습니다.\n\n```js\nexport async function sendFormDataToServer() {\n    const db = await openDB('formDataStore', 1);\n    const tx = db.transaction('formData', 'readonly');\n    const store = tx.objectStore('formData');\n    const allSavedData = await store.getAll();\n    console.log('저장된 폼 데이터', allSavedData);\n    try {\n        allSavedData.forEach( async (form, index) =\u003e  {\n            const response = await fetch('http://localhost:3000/people',  \n            {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify(form)\n            });\n            if (response.ok) {\n                console.log('서버와 동기화된 데이터:', form);\n                await db.transaction('formData', 'readwrite').objectStore('formData').delete(index);\n                console.log(`제거된 폼 데이터: ${form.firstName} ${form.lastName}` )\n            }\n        });\n    } catch (error) {\n        console.error('폼 데이터 전송 실패:', error);\n    }\n}\n```\n\n# 결론\n\n\n\n건설 SaSS 웹 앱 시나리오로 돌아가 봅시다. 건설 현장에서는 감독관이 여러 장소를 자주 이동하며 중요한 프로젝트 및 작업자 데이터에 원활하게 접근할 수 있어야 합니다. 때때로 인터넷 연결이 불안정한 상황에서도요.\n\nReact, 서비스 워커 및 IndexedDB를 사용하여 오프라인 우선 접근 방식을 채택함으로써 이러한 독특한 요구 사항을 충족시켰습니다. 이러한 기술을 활용하면 지속적인 워크플로우를 지원하고 신뢰할 수 없는 연결성으로 인한 위험을 완화하며 모든 이해관계자가 최신 정보에 접근할 수 있도록하여 적시에 결정을 내릴 수 있게 하며 꾸준한 프로젝트 진행을 보장할 수 있습니다.\n\n코드의 전체 내용은 여기에서 Github 저장소를 참조하세요.\n\n원문은 https://dennistowns.substack.com에서 원본 게시됨.","ogImage":{"url":"/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png"},"coverImage":"/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png","tag":["Tech"],"readingTime":7},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    strong: \"strong\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"건설 산업을 위한 웹 응용 프로그램(또는 현장에서 사용할 웹 응용 프로그램)을 구축한다고 상상해보세요. 이 앱에서 현장 감독관들은 작업 사이트에서 양식을 통해 프로젝트 및 근로자 상태를 데이터베이스에 업데이트합니다. 이제 하루에 여러 사이트를 방문하고 iPad를 통해 웹 앱에 엑세스해야 하는 경우를 상상해보세요. 이러한 시나리오에서는 지속적인 인터넷 연결을 보장할 수 없습니다. 이 정보에 프로젝트 성공에 중요한 자원이 의존하는 경우는 어떨까요? 이 위험을 어떻게 완화할 수 있을까요? 이를 완화하는 한 가지 방법은 오프라인 우선 방법으로 앱을 구축하는 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 React와 네이티브 자바스크립트 라이브러리인 서비스 워커(Service Workers)와 IndexedDB를 결합하여 웹에서 오프라인 우선 양식을 만들 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서비스 워커란 무엇인가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서비스 워커는 웹의 시크릿 에이전트처럼, 뒷면에서 작업하는 것 같아요. 이들은 원본과 경로에 대해 등록된 이벤트 기반 워커입니다. 웹 페이지/사이트를 제어할 수 있는 자바스크립트 파일이에요. 이들 스크립트는 메인 브라우저 스레드와 별도로 실행되며 논블로킹입니다. 그들은 네트워크 요청을 가로채거나 자원 요청을 캐시하거나 검색하며 푸시 메시지를 전달할 수 있어요. 또한 오프라인 상태일 때에도 작동합니다. 이것은 오프라인 우선 구성 SaSS 시나리오에 완벽합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"동기화 관리자와 IndexedDB: 완벽한 조합\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Sync Manager API는 안정적인 연결이 확립될 때까지 작업을 연기하는 데 도움을 주는 네이티브 JS 기능입니다. IndexedDB는 로컬 스토리지보다 훨씬 강력한 클라이언트 측 저장소를 위한 저수준 API입니다. 함께 사용할 때 웹 응용프로그램은 사용자 세션 및 연결 상태 변경 사이에서 데이터를 저장하고 동기화할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용 사례: 오프라인에서 양식 데이터 저장\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"건설 앱 시나리오에서 사용자는 양식을 입력하고 제출하려고 합니다. 일반적으로 연결이 끊어지면 해당 데이터가 손실될 수 있습니다. 그러나 저희 설정은 서비스 워커를 사용하여 폼 제출을 가로채고 데이터를 IndexedDB에 저장하며 Sync Manager와 동기화를 등록합니다. 연결이 다시 연결되면 데이터가 서버로 전송됩니다. 코드에서 어떻게 작동하는지 살펴봅시다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"코드 예시\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"시작하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저희는 빠른 실행과 Vite를 빌드 도구로 사용하겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"번을 설치한 후 다음 명령어를 사용하여 Vite로 생성된 React 앱을 만들고 실행할 수 있어요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"bun create my-app --template react\\n\"\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"cd my-app \u0026\u0026 bun run dev\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저희는 src 디렉토리 내의 App.tsx 파일에서 애플리케이션을 개발하기 시작할 거예요.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"참고\"\n      }), \": 이 예제의 React JSX나 백엔드는 확인하지 않습니다. 백엔드는 저장된 사람들을 위한 GET 및 POST 엔드포인트가 있는 기본 REST API입니다. 전체 코드는 GitHub 저장소를 참조하십시오.\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 1: 서비스 워커 등록\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"애플리케이션이 로드될 때, 브라우저가 서비스 워커를 지원하는지 확인하고, 지원하는 경우 서비스 워커 스크립트를 등록합니다 (나중에 이 service-worker.js를 생성합니다). 이 등록은 애플리케이션이 시작되면 발생하며, 서비스 워커가 요청을 가로채고 캐싱 및 동기화 작업을 관리할 준비가 되도록 합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"interface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Person\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"firstName\"\n        }), \": string,\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"lastName\"\n        }), \": string,\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": number\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"App\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [people, setPeople] = useState\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Person\"\n        }), \"[]\u003e([]);\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" { register, handleSubmit } = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useForm\"\n        }), \"();\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"registerWorker\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") =\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'serviceWorker'\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" navigator) {\\n      \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"window\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"addEventListener\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'load'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n        navigator.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"serviceWorker\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"register\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/service-worker.js'\"\n        }), \", {\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"scope\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"type\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'module'\"\n        }), \"})\\n          .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"then\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"registration\"\n          }), \" =\u003e\"]\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Service Worker registered: '\"\n        }), \", registration);\\n          })\\n          .\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"catch\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"registrationError\"\n          }), \" =\u003e\"]\n        }), \" {\\n            \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Service Worker registration failed: '\"\n        }), \", registrationError); \\n          });\\n      });\\n    }\\n  }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 2: 서비스 워커 파일 생성 및 설치 시 IndexedDB 설정\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리가 App.tsx에서 등록하려고 하는 서비스 워커를 생성하기 위해, src 디렉토리와 동일한 디렉토리 수준에 service-worker.js라는 파일을 만들 것입니다. 이렇게 하는 이유는 서비스 워커를 더 넓은 범위로 설정하기 위해서입니다. 더 높은 또는 루트 디렉토리 수준에 서비스 워커를 배치하면 애플리케이션 전체에서 더 많은 리소스에 대한 요청을 가로챌 수 있습니다. 이 위치 설정은 서비스 워커가 캐싱 및 네트워크 요청을 효과적으로 관리할 수 있도록하는 데 중요합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 서비스 워커 파일에서 'install' 이벤트 동안 IndexedDB를 초기화합니다. 우리는 formDataStore라는 데이터베이스를 설정하고 오프라인 폼 데이터를 저장하기 위해 특별히 설계된 formData 개체 저장소를 구성합니다. 이 설정은 앱에서 견고한 오프라인 기능을 활성화하는 데 중요합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// service-worker.js \"\n        }), \"\\n\\nself.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"addEventListener\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'install'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (event) =\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Service Worker installing...'\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"openDB\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'formDataStore'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"upgrade\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"db\"\n        }), \") {\\n          \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!db.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"objectStoreNames\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"contains\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'formData'\"\n        }), \")) {\\n            db.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"createObjectStore\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'formData'\"\n        }), \", { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"autoIncrement\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \" });\\n            \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Object store created!'\"\n        }), \");\\n          }\\n        },\\n    });\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Service Worker installed.'\"\n        }), \");\\n});\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 3: 폼 제출 가로채기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"폼이 제출되면, 애플리케이션은 기기가 온라인인지 확인합니다. 온라인 상태인 경우, 데이터를 API를 통해 직접 서버로 보냅니다. 오프라인 상태인 경우, 데이터를 IndexedDB에 저장합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// App.tsx\"\n        }), \"\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"onSubmit\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"data: FieldValues\"\n        }), \") =\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (navigator.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"onLine\"\n        }), \") {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" response = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"API_URL\"\n        }), \" + \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/people'\"\n        }), \",\\n        { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"method\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"POST\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"body\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"JSON\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stringify\"\n        }), \"(data) }\\n      )\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (response.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ok\"\n        }), \") {\\n        \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(response)\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setPeople\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"prevPeople\"\n          }), \") =\u003e\"]\n        }), \" [{...data} \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Person\"\n        }), \", ...prevPeople])\\n      }\\n\\n    } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"storeFormDataLocally\"\n        }), \"(data);\\n    }\\n  }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 4: 로컬로 데이터 저장하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오프라인 상태에서는 폼 데이터가 IndexedDB에 저장됩니다. 이 storeFormDataLocally 함수는 formData 객체 저장소에서 트랜잭션을 열고 데이터를 작성한 다음, 이 데이터가 서버로 전송되어야 할 것임을 나타내는 sendFormData 태그와의 백그라운드 동기화 이벤트를 등록합니다. 이렇게 하면 나중에 연결이 복원될 때 이 데이터를 서버로 보낼 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"storeFormDataLocally\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"formData : FieldValues\"\n        }), \") {\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" db = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"openDB\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'formDataStore'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" tx = db.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"transaction\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'formData'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'readwrite'\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" store = tx.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"objectStore\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'formData'\"\n        }), \");\\n    store.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"put\"\n        }), \"(formData);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" tx.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"done\"\n        }), \";\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'serviceWorker'\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" navigator \u0026\u0026 \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'SyncManager'\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"window\"\n        }), \") {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" registration : any  = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" navigator.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"serviceWorker\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ready\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" registration.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"sync\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"register\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sendFormData'\"\n        }), \");\\n          \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Sync event registered'\"\n        }), \");\\n      } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"catch\"\n        }), \"(e) {\\n          \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Failed to register sync, will retry on next   visit'\"\n        }), \" + e);\\n      }\\n  }\\n    db.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"close\"\n        }), \"();\\n  }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"서비스 워커는 'sync' 이벤트를 수신 대기합니다. 이벤트가 트리거될 때(온라인으로 변경될 때 자동적으로 발생), IndexedDB에서 모든 저장된 폼 데이터를 검색하여 서버로 보내려고 시도합니다. 성공적인 제출은 그 후에 저장소에서 삭제되어 중복 전송을 방지합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"self.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"addEventListener\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sync'\"\n        }), \", \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"event\"\n          }), \" =\u003e\"]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (event.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"tag\"\n        }), \" === \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'sendFormData'\"\n        }), \") {\\n        event.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"waitUntil\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sendFormDataToServer\"\n        }), \"());\\n    }\\n});\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"단계 6: 데이터 서버로 전송하고 IndexedDB 초기화하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실제 데이터 전송 함수는 formData 스토어에서 모든 항목을 가져와 각 항목을 서버로 전송하며 성공적인 전송 후 스토어에서 해당 항목을 제거합니다. 이렇게 함으로써 로컬 스토어를 유지하고 최신 상태로 유지할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"sendFormDataToServer\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" db = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"openDB\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'formDataStore'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" tx = db.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"transaction\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'formData'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'readonly'\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" store = tx.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"objectStore\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'formData'\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" allSavedData = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" store.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getAll\"\n        }), \"();\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'저장된 폼 데이터'\"\n        }), \", allSavedData);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" {\\n        allSavedData.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"forEach\"\n        }), \"( \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (form, index) =\u003e  {\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" response = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetch\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'http://localhost:3000/people'\"\n        }), \",  \\n            {\\n                \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"method\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'POST'\"\n        }), \",\\n                \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"headers\"\n        }), \": { \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Content-Type'\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'application/json'\"\n        }), \" },\\n                \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"body\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"JSON\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stringify\"\n        }), \"(form)\\n            });\\n            \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (response.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ok\"\n        }), \") {\\n                \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'서버와 동기화된 데이터:'\"\n        }), \", form);\\n                \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" db.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"transaction\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'formData'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'readwrite'\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"objectStore\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'formData'\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"delete\"\n        }), \"(index);\\n                \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`제거된 폼 데이터: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${form.firstName}\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${form.lastName}\"\n          }), \"`\"]\n        }), \" )\\n            }\\n        });\\n    } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"catch\"\n        }), \" (error) {\\n        \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"error\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'폼 데이터 전송 실패:'\"\n        }), \", error);\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"건설 SaSS 웹 앱 시나리오로 돌아가 봅시다. 건설 현장에서는 감독관이 여러 장소를 자주 이동하며 중요한 프로젝트 및 작업자 데이터에 원활하게 접근할 수 있어야 합니다. 때때로 인터넷 연결이 불안정한 상황에서도요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React, 서비스 워커 및 IndexedDB를 사용하여 오프라인 우선 접근 방식을 채택함으로써 이러한 독특한 요구 사항을 충족시켰습니다. 이러한 기술을 활용하면 지속적인 워크플로우를 지원하고 신뢰할 수 없는 연결성으로 인한 위험을 완화하며 모든 이해관계자가 최신 정보에 접근할 수 있도록하여 적시에 결정을 내릴 수 있게 하며 꾸준한 프로젝트 진행을 보장할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코드의 전체 내용은 여기에서 Github 저장소를 참조하세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"원문은 https://dennistowns.substack.com에서 원본 게시됨.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-Offline-firstformswithReactServiceWorkersandIndexedDB"},"buildId":"R94iUTCf1NWeBC_VXjTJG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>