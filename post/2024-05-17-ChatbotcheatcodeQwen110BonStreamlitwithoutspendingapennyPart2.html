<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>챗봇 치트 코드 Qwen110B로 스트림릿에서 돈을 쓰지 않고 활용하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="챗봇 치트 코드 Qwen110B로 스트림릿에서 돈을 쓰지 않고 활용하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="챗봇 치트 코드 Qwen110B로 스트림릿에서 돈을 쓰지 않고 활용하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2" data-gatsby-head="true"/><meta name="twitter:title" content="챗봇 치트 코드 Qwen110B로 스트림릿에서 돈을 쓰지 않고 활용하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 03:23" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">챗봇 치트 코드 Qwen110B로 스트림릿에서 돈을 쓰지 않고 활용하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="챗봇 치트 코드 Qwen110B로 스트림릿에서 돈을 쓰지 않고 활용하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>제1부에서는 수십억 개의 매개변수를 가진 큰 언어 모델에 무료로 액세스하고 활용할 수 있다는 것을 발견했어요. 제처럼 여러분도 하드웨어 한정으로 고민 중이라면, 이 해킹 방법은 하이엔드 GPU나 유료 구독 없이도 Qwen-110B-chat과 같은 대규모 모델과 상호 작용할 수 있는 기쁨을 선사할 거예요.</p>
<p>제2부에서는 지금부터 체험을 더 향상시키기 위해 스트림릿 인터페이스로 동일한 개념을 적용하여 챗봇에 시각적으로 매력적인 스트리밍 효과를 추가할 거예요.</p>
<p>과정을 되짚어보자면, Python, Gradio_client 및 코딩 능력이 필요해요. AI 챗봇을 텍스트 인터페이스를 통해 만드는 데 초점을 맞추었어요:</p>
<ul>
<li>환경 설정: 먼저 가상 환경을 만들고 필요한 패키지(huggingface_hub, gradio-client 및 streamlit)를 설치하세요. PyTorch나 TensorFlow가 필요하지 않으며, 상호 작용은 API를 통해 이루어질 거예요.</li>
<li>Hugging Face API 토큰: 사용자는 Hugging Face에 등록하고 모델 추론 API에 액세스하기 위해 API 토큰을 생성해야 해요.</li>
<li>챗봇 코딩: Hugging Face Spaces에서 Gradio의 &quot;API를 통해 사용&quot; 기능을 활용하여 이러한 강력한 모델에 Python 코드로 연결하는 방법을 배웠어요. 특히 여러 언어로 상업적 이용을 위한 라이선스가 허용되는 Qwen 시리즈 모델에 초점을 맞췄어요.</li>
<li>스트리밍 효과: 코드 구조를 살펴보면, 모델과 상호 작용할 수 있는 함수를 만드는 방법을 설명했어요. predict() 및 submit() 메서드 중에서 선택하여 스트리밍 효과와 함께 또는 없이 응답을 생성하는 방법을 강조했어요.</li>
</ul>
<div class="content-ad"></div>
<p>조금 헤매고 있다면 part 1부터 시작하는 것을 제안해요:</p>
<h2>핵심 코드부터 Streamlit 인터페이스까지</h2>
<p>이걸 꼭 말해야 해요: 터미널에서 모든 앱이 정상 작동하지 않으면 그래픽 인터페이스를 시작하지 말아야 해요.</p>
<p>이건 필수 조건이에요! 그래서 Streamlit 인터페이스를 만드는 것이 아주 쉬울 거에요: 이미 이전 파트에서 라이브러리와 상호작용이 어떻게 작동하는지 확인했기 때문이죠.</p>
<div class="content-ad"></div>
<p>모든 것은 이 핵심을 중심으로 움직입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> gradio_client <span class="hljs-keyword">import</span> <span class="hljs-title class_">Client</span>

client = <span class="hljs-title class_">Client</span>(<span class="hljs-string">&quot;Qwen/Qwen1.5-110B-Chat-demo&quot;</span>)
result = client.<span class="hljs-title function_">submit</span>(
        query=<span class="hljs-string">&#x27;What is Science?&#x27;</span>,
        history=[],
        system=<span class="hljs-string">&quot;You are a helpful assistant.&quot;</span>,
        api_name=<span class="hljs-string">&quot;/model_chat&quot;</span>
)
<span class="hljs-title function_">print</span>(result)
</code></pre>
<p>그리고 submit() 메소드를 사용하여 스트리밍 객체/반복자를 얻을 수 있다는 것을 알고 있습니다. Streamlit을 사용하면 스트림을 다루기가 훨씬 쉬워집니다. 사실, 애플리케이션은 항상 페이지 위젯을 새로 고치기 때문에 텍스트 애플리케이션에서 사용되는 지루한 알고리즘을 무시할 수 있습니다. 기억하시나요?</p>
<pre><code class="hljs language-js">    final = <span class="hljs-string">&#x27;&#x27;</span>
    <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> <span class="hljs-attr">result</span>:
        <span class="hljs-keyword">if</span> final == <span class="hljs-string">&#x27;&#x27;</span>:
            final=chunk[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]
            <span class="hljs-title function_">print</span>(chunk[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], end=<span class="hljs-string">&quot;&quot;</span>, flush=<span class="hljs-title class_">True</span>)
        <span class="hljs-attr">else</span>:
            <span class="hljs-attr">try</span>:
                <span class="hljs-title function_">print</span>(chunk[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>].<span class="hljs-title function_">replace</span>(final,<span class="hljs-string">&#x27;&#x27;</span>), end=<span class="hljs-string">&quot;&quot;</span>, flush=<span class="hljs-title class_">True</span>)
                final = chunk[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]
            <span class="hljs-attr">except</span>:
                pass    
</code></pre>
<div class="content-ad"></div>
<p>string.replace()을 사용하여 이미 생성된 것에서 새로운 단어를 빼내는 작업을 했었는데, 더이상 필요하지 않아요.🥳</p>
<h1>Streamlit 앱</h1>
<p>습관적인 사람이라... 그래서 내 코드가 다른 프로젝트와 매우 비슷하다는 사실을 발견할 수 있을 거에요. 그런데 괜찮아요! 결국, 템플릿을 적용하고 수정하는 것이 매번 처음부터 시작하는 것보다 쉽고 빠를 수 있거든.</p>
<p>새 파일을 만들어보세요: 제 파일은 st-Qwen1.5–110B-Chat.py라고 해요. 주요 라이브러리를 가져와 세션 상태 전역 변수를 생성하는 것부터 시작해볼까요?</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> gradio_client <span class="hljs-keyword">import</span> Client
<span class="hljs-comment"># Internal usage</span>
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep


<span class="hljs-keyword">if</span> <span class="hljs-string">&quot;hf_model&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> st.session_state:
    st.session_state.hf_model = <span class="hljs-string">&quot;Qwen1.5-110B-Chat&quot;</span>
<span class="hljs-comment"># Initialize chat history</span>
<span class="hljs-keyword">if</span> <span class="hljs-string">&quot;messages&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> st.session_state:
    st.session_state.messages = []
</code></pre>
<p>프로그램에서 전역 변수는 공유되어 사용될 수 있습니다. 또한 session_state라고 불리는 이러한 객체들이 streamlit의 매 실행마다 변경되지 않는 것을 필요로합니다.</p>
<p>그리고 2가지 주요 함수를 정의합니다:</p>
<pre><code class="hljs language-python"><span class="hljs-meta">@st.cache_resource</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_client</span>():   
    yourHFtoken = <span class="hljs-string">&quot;hf_xxxxxxxxxxxxxxxxxxxxxxx&quot;</span> <span class="hljs-comment">#여기에 여러분의 HF 토큰을 넣으세요</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">{st.session_state.hf_model}</span>에 대한 API Gradio 클라이언트를 로딩 중입니다.&#x27;</span>)
    client = Client(<span class="hljs-string">&quot;Qwen/Qwen1.5-110B-Chat-demo&quot;</span>, hf_token=yourHFtoken)
    <span class="hljs-keyword">return</span> client

<span class="hljs-comment"># 모든 채팅 메시지를 chathistory.txt에 기록하는 함수</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">writehistory</span>(<span class="hljs-params">text</span>):
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;chathistorywen110b.txt&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:
        f.write(text)
        f.write(<span class="hljs-string">&#x27;\n&#x27;</span>)
    f.close()
</code></pre>
<div class="content-ad"></div>
<p>저희는 @st.cache_resource 데코레이터를 사용하고 있습니다. 이는 Qwen1.5-110에 대한 API gradio 클라이언트를 Streamlit이 매 실행마다 로딩하지 않기를 원하기 때문입니다 (이는 분당 1회 이상 발생할 수 있습니다): Gradio 클라이언트 연결이 실행 중에 변경되지 않을 것이기 때문에, 이 리소스를 특별한 메모리에 캐싱하고 있습니다 (@st.cache_resource). 자세한 내용은 여기에서 확인하실 수 있습니다.</p>
<h2>일부 그래픽 조정</h2>
<p>이제 기본 Streamlit 페이지 요소와 챗봇에 사용할 아이콘을 설정할 수 있습니다.</p>
<pre><code class="hljs language-js">#아바타
av_us = <span class="hljs-string">&#x27;🧑‍💻&#x27;</span>  # <span class="hljs-string">&#x27;./man.png&#x27;</span>  #<span class="hljs-string">&quot;🦖&quot;</span>  # <span class="hljs-string">&quot;🧑‍💻&quot;</span>, <span class="hljs-string">&quot;🤖&quot;</span>, <span class="hljs-string">&quot;🦖&quot;</span>과 같은 단일 이모지입니다. <span class="hljs-title class_">Shortcut</span>은 지원되지 않습니다.
av_ass = <span class="hljs-string">&quot;🤖&quot;</span>   #<span class="hljs-string">&#x27;./robot.png&#x27;</span>
# 기본 모델 설정

### <span class="hljs-variable constant_">STREAMLIT</span> <span class="hljs-variable constant_">UI</span> 시작
st.<span class="hljs-title function_">image</span>(<span class="hljs-string">&#x27;https://github.com/fabiomatricardi/ChatBOTMastery/raw/main/qwen100logo.png&#x27;</span>, )
st.<span class="hljs-title function_">markdown</span>(<span class="hljs-string">&quot;### *Streamlit &amp; Gradio_client로 구동됨*&quot;</span>, unsafe_allow_html=<span class="hljs-title class_">True</span> )
st.<span class="hljs-title function_">markdown</span>(<span class="hljs-string">&#x27;---&#x27;</span>)

client = <span class="hljs-title function_">create_client</span>()
</code></pre>
<div class="content-ad"></div>
<ul>
<li>채팅 인터페이스에 로컬 이미지를 사용할 수도 있어요 (코드의 주석을 참고하세요!)</li>
<li>마지막으로, create_client()로 클라이언트 연결을 인스턴스화해요.</li>
</ul>
<h1>본문 — 채팅 인터페이스</h1>
<p>Streamlit은 자신의 위젯에 변경이 발생할 때마다 또는 입력(버튼, 선택기, 라디오 요소 등)으로 사용자 조작이 호출될 때마다 코드를 맨 위부터 다시 실행해요.</p>
<p>그래서 저희는 대화 기록을 맨 위에 먼저 렌더링하기 시작했어요. 여기서는 뭐라도 새롭게 발명한 건 없어요: Streamlit 블로그의 공식 자습서에서 모두 배웠거든요.</p>
<div class="content-ad"></div>
<p>이것은 표준 렌더링입니다. OpenAI API와 호환되는 chat_completion 형식에 모두 적용 가능합니다.</p>
<p>코드로 돌아가서, 우리는 chat_template 메시지들을 표시하고, 메시지 목록을 반복하며 사용자 프롬프트(myprompt)가 제출되기를 기다립니다.</p>
<pre><code class="hljs language-js"># 앱 재실행 시 이전 대화 내용을 보여줍니다
<span class="hljs-keyword">for</span> message <span class="hljs-keyword">in</span> st.<span class="hljs-property">session_state</span>.<span class="hljs-property">messages</span>:
    <span class="hljs-keyword">if</span> message[<span class="hljs-string">&quot;role&quot;</span>] == <span class="hljs-string">&quot;user&quot;</span>:
        <span class="hljs-keyword">with</span> st.<span class="hljs-title function_">chat_message</span>(message[<span class="hljs-string">&quot;role&quot;</span>],avatar=av_us):
            st.<span class="hljs-title function_">markdown</span>(message[<span class="hljs-string">&quot;content&quot;</span>])
    <span class="hljs-attr">else</span>:
        <span class="hljs-keyword">with</span> st.<span class="hljs-title function_">chat_message</span>(message[<span class="hljs-string">&quot;role&quot;</span>],avatar=av_ass):
            st.<span class="hljs-title function_">markdown</span>(message[<span class="hljs-string">&quot;content&quot;</span>])
# 사용자 입력 받기
<span class="hljs-keyword">if</span> myprompt := st.<span class="hljs-title function_">chat_input</span>(<span class="hljs-string">&quot;인공지능 모델이란 무엇인가요?&quot;</span>):
    # 사용자 메시지를 대화 내역에 추가
    st.<span class="hljs-property">session_state</span>.<span class="hljs-property">messages</span>.<span class="hljs-title function_">append</span>({<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: myprompt})
    # 대화 메시지 컨테이너에 사용자 메시지 표시
    <span class="hljs-keyword">with</span> st.<span class="hljs-title function_">chat_message</span>(<span class="hljs-string">&quot;user&quot;</span>, avatar=av_us):
        st.<span class="hljs-title function_">markdown</span>(myprompt)
        usertext = f<span class="hljs-string">&quot;user: {myprompt}&quot;</span>
        <span class="hljs-title function_">writehistory</span>(usertext)
        # 차후 사용을 위해 대화 상대의 응답을 표시
</code></pre>
<p>여기에 이상한 writehistory(usertext) 지시문을 추가하고 있는 것을 볼 수 있습니다. 기억하시나요? 처음에 이 함수를 선언했던 거죠? 저는 모든 대화 내용을 로컬 텍스트 파일에 저장하는 버릇이 있어요. 이는 프롬프트를 분석하거나 미래 활용을 위해 자료를 조직화할 때 매우 편리합니다.🙂</p>
<div class="content-ad"></div>
<p>프롬프트에서 제출된 내용을 확인한 후, gradio 클라이언트 인스턴스(client.submit)를 호출하고 스트리밍을 시작합니다 (message_placeholder.markdown(r[1][0][1]+ &quot;▌&quot;))</p>
<pre><code class="hljs language-js">    # 채팅 메시지 컨테이너에 어시스턴트 응답 표시
    <span class="hljs-keyword">with</span> st.<span class="hljs-title function_">chat_message</span>(<span class="hljs-string">&quot;assistant&quot;</span>):
        message_placeholder = st.<span class="hljs-title function_">empty</span>()
        full_response = <span class="hljs-string">&quot;&quot;</span>
        res  =  client.<span class="hljs-title function_">submit</span>(
                query=myprompt,
                history=[],
                system=<span class="hljs-string">&quot;You are a helpful assistant.&quot;</span>,
                api_name=<span class="hljs-string">&quot;/model_chat&quot;</span>
                )        
        <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> <span class="hljs-attr">res</span>:
            full_response=r[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]
            message_placeholder.<span class="hljs-title function_">markdown</span>(r[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]+ <span class="hljs-string">&quot;▌&quot;</span>)

        message_placeholder.<span class="hljs-title function_">markdown</span>(full_response)
        asstext = f<span class="hljs-string">&quot;assistant: {full_response}&quot;</span>
        <span class="hljs-title function_">writehistory</span>(asstext)       
        st.<span class="hljs-property">session_state</span>.<span class="hljs-property">messages</span>.<span class="hljs-title function_">append</span>({<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;assistant&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: full_response})
</code></pre>
<p>이게 전부에요. full_response는 최종 텍스트가 들어 있는 변수이므로 대화 기록에도 추가하여 표시합니다.</p>
<p>해결했으면 댓글에 알려주세요 👍</p>
<div class="content-ad"></div>
<p>파이썬 파일을 저장한 후 터미널에서 가상 환경을 활성화한 상태에서 다음과 같이 실행하세요.</p>
<pre><code class="hljs language-js">streamlit run .\st-<span class="hljs-title class_">Qwen1</span><span class="hljs-number">.5</span>-110B-<span class="hljs-title class_">Chat</span>.<span class="hljs-property">py</span>
</code></pre>
<p>아래처럼 나와야 합니다... 그리고 기본 브라우저가 로컬 URL인 http://localhost:8501로 열리게 됩니다.</p>
<p><img src="/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png" alt="이미지"/></p>
<div class="content-ad"></div>
<p>Streamlit은 로컬 네트워크로의 편리한 라우팅을 제공합니다. 예를 들어, 핸드폰이 동일한 액세스 포인트에 연결되어 있으면 Network URL로 표시된 주소인 http://192.168.2.6:8501을 통해 핸드폰에서도 이 애플리케이션을 사용할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_1.png" alt="이미지"/></p>
<h1>다른 모델 실행에 대한 참고 사항</h1>
<p>GitHub 리포지토리에서도 Streamlit Python 파일을 실행하는 방법을 찾을 수 있습니다.</p>
<div class="content-ad"></div>
<ul>
<li>OpenELM 3B</li>
<li>Phi-3-mini-Instruct 128k</li>
<li>QwenMoE</li>
</ul>
<p>고객 구성이 변경될 예정입니다 (물론...) 그리고 스트리밍 지침도 변경될 것입니다. 이는 API 엔드포인트가 다른 데이터 유형을 반환하기 때문에 발생합니다. OpenELM 및 Phi-3의 경우 순수한 문자열이 반환되므로 어떠한 사전/튜플 위치에 있는 LLM 응답을 추출할 필요가 없습니다. 여기를 살펴보세요:</p>
<p>그리고 또한 PLEASE, 기억해주세요...</p>
<p><img src="/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_2.png" alt="이미지"/></p>
<div class="content-ad"></div>
<h1>결론</h1>
<p>이 모든 복잡성을 다루는 이유는 무엇일까요? 우리는 어떻게 일하는지 배우고, 나만의 AI 비서를 만드는 방법을 알고 싶기 때문입니다. 내가 상상할 수 있는 최고의 목적을 위해 콘텐츠 생성, 학습 자료, 프레젠테이션, 교육 지원 등.</p>
<p>어디에 사용할 건가요?</p>
<p>글이 마음에 드셨으면 좋겣습니다. 이 이야기가 가치를 제공했고 조금이라도 지원하고 싶다면 다음을 해볼 수 있습니다 :</p>
<div class="content-ad"></div>
<ul>
<li>이 이야기에 대해 많이 박수를 쳐 주세요</li>
<li>기억할 가치가 있는 부분을 강조하십시오 (나중에 찾기 쉽고, 더 나은 기사를 쓰는 데 도움이 될 것입니다)</li>
<li>Build Your Own AI를 시작하는 방법을 배우려면, 무료 eBook을 다운로드하세요</li>
<li>내 링크를 사용하여 Medium 멤버십 가입하기 - (무제한 Medium 이야기를 읽으려면 매달 $5)</li>
<li>Medium에서 나를 팔로우하기</li>
<li>내 최신 기사 읽기 https://medium.com/@fabio.matricardi</li>
</ul>
<p>여기 몇 가지 더 흥미로운 읽을거리:</p>
<p>추가 학습 자료</p>
<p><img src="/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_3.png" alt="이미지"/></p>
<div class="content-ad"></div>
<p>이 이야기는 Generative AI Publication에서 발행되었습니다.</p>
<p>최신 AI 이야기를 놓치지 않으려면 Substack, LinkedIn 및 Zeniteq에서 저희와 연락하여 AI의 미래를 함께 창조해보세요!</p>
<p><img src="/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_4.png" alt="이미지"/></p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"챗봇 치트 코드 Qwen110B로 스트림릿에서 돈을 쓰지 않고 활용하는 방법","description":"","date":"2024-05-17 03:23","slug":"2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2","content":"\n\n제1부에서는 수십억 개의 매개변수를 가진 큰 언어 모델에 무료로 액세스하고 활용할 수 있다는 것을 발견했어요. 제처럼 여러분도 하드웨어 한정으로 고민 중이라면, 이 해킹 방법은 하이엔드 GPU나 유료 구독 없이도 Qwen-110B-chat과 같은 대규모 모델과 상호 작용할 수 있는 기쁨을 선사할 거예요.\n\n제2부에서는 지금부터 체험을 더 향상시키기 위해 스트림릿 인터페이스로 동일한 개념을 적용하여 챗봇에 시각적으로 매력적인 스트리밍 효과를 추가할 거예요.\n\n과정을 되짚어보자면, Python, Gradio_client 및 코딩 능력이 필요해요. AI 챗봇을 텍스트 인터페이스를 통해 만드는 데 초점을 맞추었어요:\n\n- 환경 설정: 먼저 가상 환경을 만들고 필요한 패키지(huggingface_hub, gradio-client 및 streamlit)를 설치하세요. PyTorch나 TensorFlow가 필요하지 않으며, 상호 작용은 API를 통해 이루어질 거예요.\n- Hugging Face API 토큰: 사용자는 Hugging Face에 등록하고 모델 추론 API에 액세스하기 위해 API 토큰을 생성해야 해요.\n- 챗봇 코딩: Hugging Face Spaces에서 Gradio의 \"API를 통해 사용\" 기능을 활용하여 이러한 강력한 모델에 Python 코드로 연결하는 방법을 배웠어요. 특히 여러 언어로 상업적 이용을 위한 라이선스가 허용되는 Qwen 시리즈 모델에 초점을 맞췄어요.\n- 스트리밍 효과: 코드 구조를 살펴보면, 모델과 상호 작용할 수 있는 함수를 만드는 방법을 설명했어요. predict() 및 submit() 메서드 중에서 선택하여 스트리밍 효과와 함께 또는 없이 응답을 생성하는 방법을 강조했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n조금 헤매고 있다면 part 1부터 시작하는 것을 제안해요:\n\n## 핵심 코드부터 Streamlit 인터페이스까지\n\n이걸 꼭 말해야 해요: 터미널에서 모든 앱이 정상 작동하지 않으면 그래픽 인터페이스를 시작하지 말아야 해요.\n\n이건 필수 조건이에요! 그래서 Streamlit 인터페이스를 만드는 것이 아주 쉬울 거에요: 이미 이전 파트에서 라이브러리와 상호작용이 어떻게 작동하는지 확인했기 때문이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 것은 이 핵심을 중심으로 움직입니다:\n\n```js\nfrom gradio_client import Client\n\nclient = Client(\"Qwen/Qwen1.5-110B-Chat-demo\")\nresult = client.submit(\n        query='What is Science?',\n        history=[],\n        system=\"You are a helpful assistant.\",\n        api_name=\"/model_chat\"\n)\nprint(result)\n```\n\n그리고 submit() 메소드를 사용하여 스트리밍 객체/반복자를 얻을 수 있다는 것을 알고 있습니다. Streamlit을 사용하면 스트림을 다루기가 훨씬 쉬워집니다. 사실, 애플리케이션은 항상 페이지 위젯을 새로 고치기 때문에 텍스트 애플리케이션에서 사용되는 지루한 알고리즘을 무시할 수 있습니다. 기억하시나요?\n\n```js\n    final = ''\n    for chunk in result:\n        if final == '':\n            final=chunk[1][0][1]\n            print(chunk[1][0][1], end=\"\", flush=True)\n        else:\n            try:\n                print(chunk[1][0][1].replace(final,''), end=\"\", flush=True)\n                final = chunk[1][0][1]\n            except:\n                pass    \n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nstring.replace()을 사용하여 이미 생성된 것에서 새로운 단어를 빼내는 작업을 했었는데, 더이상 필요하지 않아요.🥳\n\n# Streamlit 앱\n\n습관적인 사람이라... 그래서 내 코드가 다른 프로젝트와 매우 비슷하다는 사실을 발견할 수 있을 거에요. 그런데 괜찮아요! 결국, 템플릿을 적용하고 수정하는 것이 매번 처음부터 시작하는 것보다 쉽고 빠를 수 있거든.\n\n새 파일을 만들어보세요: 제 파일은 st-Qwen1.5–110B-Chat.py라고 해요. 주요 라이브러리를 가져와 세션 상태 전역 변수를 생성하는 것부터 시작해볼까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nimport streamlit as st\nimport time\nimport sys\nfrom gradio_client import Client\n# Internal usage\nimport os\nfrom time import sleep\n\n\nif \"hf_model\" not in st.session_state:\n    st.session_state.hf_model = \"Qwen1.5-110B-Chat\"\n# Initialize chat history\nif \"messages\" not in st.session_state:\n    st.session_state.messages = []\n```\n\n프로그램에서 전역 변수는 공유되어 사용될 수 있습니다. 또한 session_state라고 불리는 이러한 객체들이 streamlit의 매 실행마다 변경되지 않는 것을 필요로합니다.\n\n그리고 2가지 주요 함수를 정의합니다:\n\n```python\n@st.cache_resource\ndef create_client():   \n    yourHFtoken = \"hf_xxxxxxxxxxxxxxxxxxxxxxx\" #여기에 여러분의 HF 토큰을 넣으세요\n    print(f'{st.session_state.hf_model}에 대한 API Gradio 클라이언트를 로딩 중입니다.')\n    client = Client(\"Qwen/Qwen1.5-110B-Chat-demo\", hf_token=yourHFtoken)\n    return client\n\n# 모든 채팅 메시지를 chathistory.txt에 기록하는 함수\ndef writehistory(text):\n    with open('chathistorywen110b.txt', 'a', encoding='utf-8') as f:\n        f.write(text)\n        f.write('\\n')\n    f.close()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 @st.cache_resource 데코레이터를 사용하고 있습니다. 이는 Qwen1.5-110에 대한 API gradio 클라이언트를 Streamlit이 매 실행마다 로딩하지 않기를 원하기 때문입니다 (이는 분당 1회 이상 발생할 수 있습니다): Gradio 클라이언트 연결이 실행 중에 변경되지 않을 것이기 때문에, 이 리소스를 특별한 메모리에 캐싱하고 있습니다 (@st.cache_resource). 자세한 내용은 여기에서 확인하실 수 있습니다.\n\n## 일부 그래픽 조정\n\n이제 기본 Streamlit 페이지 요소와 챗봇에 사용할 아이콘을 설정할 수 있습니다.\n\n```js\n#아바타\nav_us = '🧑‍💻'  # './man.png'  #\"🦖\"  # \"🧑‍💻\", \"🤖\", \"🦖\"과 같은 단일 이모지입니다. Shortcut은 지원되지 않습니다.\nav_ass = \"🤖\"   #'./robot.png'\n# 기본 모델 설정\n\n### STREAMLIT UI 시작\nst.image('https://github.com/fabiomatricardi/ChatBOTMastery/raw/main/qwen100logo.png', )\nst.markdown(\"### *Streamlit \u0026 Gradio_client로 구동됨*\", unsafe_allow_html=True )\nst.markdown('---')\n\nclient = create_client()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 채팅 인터페이스에 로컬 이미지를 사용할 수도 있어요 (코드의 주석을 참고하세요!)\n- 마지막으로, create_client()로 클라이언트 연결을 인스턴스화해요.\n\n# 본문 — 채팅 인터페이스\n\nStreamlit은 자신의 위젯에 변경이 발생할 때마다 또는 입력(버튼, 선택기, 라디오 요소 등)으로 사용자 조작이 호출될 때마다 코드를 맨 위부터 다시 실행해요.\n\n그래서 저희는 대화 기록을 맨 위에 먼저 렌더링하기 시작했어요. 여기서는 뭐라도 새롭게 발명한 건 없어요: Streamlit 블로그의 공식 자습서에서 모두 배웠거든요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 표준 렌더링입니다. OpenAI API와 호환되는 chat_completion 형식에 모두 적용 가능합니다.\n\n코드로 돌아가서, 우리는 chat_template 메시지들을 표시하고, 메시지 목록을 반복하며 사용자 프롬프트(myprompt)가 제출되기를 기다립니다.\n\n```js\n# 앱 재실행 시 이전 대화 내용을 보여줍니다\nfor message in st.session_state.messages:\n    if message[\"role\"] == \"user\":\n        with st.chat_message(message[\"role\"],avatar=av_us):\n            st.markdown(message[\"content\"])\n    else:\n        with st.chat_message(message[\"role\"],avatar=av_ass):\n            st.markdown(message[\"content\"])\n# 사용자 입력 받기\nif myprompt := st.chat_input(\"인공지능 모델이란 무엇인가요?\"):\n    # 사용자 메시지를 대화 내역에 추가\n    st.session_state.messages.append({\"role\": \"user\", \"content\": myprompt})\n    # 대화 메시지 컨테이너에 사용자 메시지 표시\n    with st.chat_message(\"user\", avatar=av_us):\n        st.markdown(myprompt)\n        usertext = f\"user: {myprompt}\"\n        writehistory(usertext)\n        # 차후 사용을 위해 대화 상대의 응답을 표시\n```\n\n여기에 이상한 writehistory(usertext) 지시문을 추가하고 있는 것을 볼 수 있습니다. 기억하시나요? 처음에 이 함수를 선언했던 거죠? 저는 모든 대화 내용을 로컬 텍스트 파일에 저장하는 버릇이 있어요. 이는 프롬프트를 분석하거나 미래 활용을 위해 자료를 조직화할 때 매우 편리합니다.🙂\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프롬프트에서 제출된 내용을 확인한 후, gradio 클라이언트 인스턴스(client.submit)를 호출하고 스트리밍을 시작합니다 (message_placeholder.markdown(r[1][0][1]+ \"▌\"))\n\n```js\n    # 채팅 메시지 컨테이너에 어시스턴트 응답 표시\n    with st.chat_message(\"assistant\"):\n        message_placeholder = st.empty()\n        full_response = \"\"\n        res  =  client.submit(\n                query=myprompt,\n                history=[],\n                system=\"You are a helpful assistant.\",\n                api_name=\"/model_chat\"\n                )        \n        for r in res:\n            full_response=r[1][0][1]\n            message_placeholder.markdown(r[1][0][1]+ \"▌\")\n\n        message_placeholder.markdown(full_response)\n        asstext = f\"assistant: {full_response}\"\n        writehistory(asstext)       \n        st.session_state.messages.append({\"role\": \"assistant\", \"content\": full_response})\n```\n\n이게 전부에요. full_response는 최종 텍스트가 들어 있는 변수이므로 대화 기록에도 추가하여 표시합니다.\n\n해결했으면 댓글에 알려주세요 👍\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬 파일을 저장한 후 터미널에서 가상 환경을 활성화한 상태에서 다음과 같이 실행하세요.\n\n```js\nstreamlit run .\\st-Qwen1.5-110B-Chat.py\n```\n\n아래처럼 나와야 합니다... 그리고 기본 브라우저가 로컬 URL인 http://localhost:8501로 열리게 됩니다.\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nStreamlit은 로컬 네트워크로의 편리한 라우팅을 제공합니다. 예를 들어, 핸드폰이 동일한 액세스 포인트에 연결되어 있으면 Network URL로 표시된 주소인 http://192.168.2.6:8501을 통해 핸드폰에서도 이 애플리케이션을 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_1.png)\n\n# 다른 모델 실행에 대한 참고 사항\n\nGitHub 리포지토리에서도 Streamlit Python 파일을 실행하는 방법을 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- OpenELM 3B\n- Phi-3-mini-Instruct 128k\n- QwenMoE\n\n고객 구성이 변경될 예정입니다 (물론...) 그리고 스트리밍 지침도 변경될 것입니다. 이는 API 엔드포인트가 다른 데이터 유형을 반환하기 때문에 발생합니다. OpenELM 및 Phi-3의 경우 순수한 문자열이 반환되므로 어떠한 사전/튜플 위치에 있는 LLM 응답을 추출할 필요가 없습니다. 여기를 살펴보세요:\n\n그리고 또한 PLEASE, 기억해주세요...\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 모든 복잡성을 다루는 이유는 무엇일까요? 우리는 어떻게 일하는지 배우고, 나만의 AI 비서를 만드는 방법을 알고 싶기 때문입니다. 내가 상상할 수 있는 최고의 목적을 위해 콘텐츠 생성, 학습 자료, 프레젠테이션, 교육 지원 등.\n\n어디에 사용할 건가요?\n\n글이 마음에 드셨으면 좋겣습니다. 이 이야기가 가치를 제공했고 조금이라도 지원하고 싶다면 다음을 해볼 수 있습니다 :\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이 이야기에 대해 많이 박수를 쳐 주세요\n- 기억할 가치가 있는 부분을 강조하십시오 (나중에 찾기 쉽고, 더 나은 기사를 쓰는 데 도움이 될 것입니다)\n- Build Your Own AI를 시작하는 방법을 배우려면, 무료 eBook을 다운로드하세요\n- 내 링크를 사용하여 Medium 멤버십 가입하기 - (무제한 Medium 이야기를 읽으려면 매달 $5)\n- Medium에서 나를 팔로우하기\n- 내 최신 기사 읽기 https://medium.com/@fabio.matricardi\n\n여기 몇 가지 더 흥미로운 읽을거리:\n\n추가 학습 자료\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 이야기는 Generative AI Publication에서 발행되었습니다.\n\n최신 AI 이야기를 놓치지 않으려면 Substack, LinkedIn 및 Zeniteq에서 저희와 연락하여 AI의 미래를 함께 창조해보세요!\n\n![이미지](/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_4.png)","ogImage":{"url":"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png"},"coverImage":"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png","tag":["Tech"],"readingTime":9},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    h1: \"h1\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"제1부에서는 수십억 개의 매개변수를 가진 큰 언어 모델에 무료로 액세스하고 활용할 수 있다는 것을 발견했어요. 제처럼 여러분도 하드웨어 한정으로 고민 중이라면, 이 해킹 방법은 하이엔드 GPU나 유료 구독 없이도 Qwen-110B-chat과 같은 대규모 모델과 상호 작용할 수 있는 기쁨을 선사할 거예요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제2부에서는 지금부터 체험을 더 향상시키기 위해 스트림릿 인터페이스로 동일한 개념을 적용하여 챗봇에 시각적으로 매력적인 스트리밍 효과를 추가할 거예요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"과정을 되짚어보자면, Python, Gradio_client 및 코딩 능력이 필요해요. AI 챗봇을 텍스트 인터페이스를 통해 만드는 데 초점을 맞추었어요:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"환경 설정: 먼저 가상 환경을 만들고 필요한 패키지(huggingface_hub, gradio-client 및 streamlit)를 설치하세요. PyTorch나 TensorFlow가 필요하지 않으며, 상호 작용은 API를 통해 이루어질 거예요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Hugging Face API 토큰: 사용자는 Hugging Face에 등록하고 모델 추론 API에 액세스하기 위해 API 토큰을 생성해야 해요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"챗봇 코딩: Hugging Face Spaces에서 Gradio의 \\\"API를 통해 사용\\\" 기능을 활용하여 이러한 강력한 모델에 Python 코드로 연결하는 방법을 배웠어요. 특히 여러 언어로 상업적 이용을 위한 라이선스가 허용되는 Qwen 시리즈 모델에 초점을 맞췄어요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"스트리밍 효과: 코드 구조를 살펴보면, 모델과 상호 작용할 수 있는 함수를 만드는 방법을 설명했어요. predict() 및 submit() 메서드 중에서 선택하여 스트리밍 효과와 함께 또는 없이 응답을 생성하는 방법을 강조했어요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"조금 헤매고 있다면 part 1부터 시작하는 것을 제안해요:\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"핵심 코드부터 Streamlit 인터페이스까지\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이걸 꼭 말해야 해요: 터미널에서 모든 앱이 정상 작동하지 않으면 그래픽 인터페이스를 시작하지 말아야 해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이건 필수 조건이에요! 그래서 Streamlit 인터페이스를 만드는 것이 아주 쉬울 거에요: 이미 이전 파트에서 라이브러리와 상호작용이 어떻게 작동하는지 확인했기 때문이죠.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모든 것은 이 핵심을 중심으로 움직입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" gradio_client \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Client\"\n        }), \"\\n\\nclient = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Client\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Qwen/Qwen1.5-110B-Chat-demo\\\"\"\n        }), \")\\nresult = client.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"submit\"\n        }), \"(\\n        query=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'What is Science?'\"\n        }), \",\\n        history=[],\\n        system=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"You are a helpful assistant.\\\"\"\n        }), \",\\n        api_name=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/model_chat\\\"\"\n        }), \"\\n)\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(result)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 submit() 메소드를 사용하여 스트리밍 객체/반복자를 얻을 수 있다는 것을 알고 있습니다. Streamlit을 사용하면 스트림을 다루기가 훨씬 쉬워집니다. 사실, 애플리케이션은 항상 페이지 위젯을 새로 고치기 때문에 텍스트 애플리케이션에서 사용되는 지루한 알고리즘을 무시할 수 있습니다. 기억하시나요?\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"    final = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" chunk \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"result\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" final == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \":\\n            final=chunk[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\n            \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(chunk[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"], end=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \", flush=\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \")\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"else\"\n        }), \":\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"try\"\n        }), \":\\n                \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"print\"\n        }), \"(chunk[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"].\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"replace\"\n        }), \"(final,\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"''\"\n        }), \"), end=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \", flush=\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \")\\n                final = chunk[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\n            \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"except\"\n        }), \":\\n                pass    \\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"string.replace()을 사용하여 이미 생성된 것에서 새로운 단어를 빼내는 작업을 했었는데, 더이상 필요하지 않아요.🥳\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Streamlit 앱\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"습관적인 사람이라... 그래서 내 코드가 다른 프로젝트와 매우 비슷하다는 사실을 발견할 수 있을 거에요. 그런데 괜찮아요! 결국, 템플릿을 적용하고 수정하는 것이 매번 처음부터 시작하는 것보다 쉽고 빠를 수 있거든.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"새 파일을 만들어보세요: 제 파일은 st-Qwen1.5–110B-Chat.py라고 해요. 주요 라이브러리를 가져와 세션 상태 전역 변수를 생성하는 것부터 시작해볼까요?\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" streamlit \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" st\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" time\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" sys\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" gradio_client \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" Client\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Internal usage\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" os\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" time \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" sleep\\n\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"hf_model\\\"\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"not\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" st.session_state:\\n    st.session_state.hf_model = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Qwen1.5-110B-Chat\\\"\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# Initialize chat history\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"messages\\\"\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"not\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" st.session_state:\\n    st.session_state.messages = []\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로그램에서 전역 변수는 공유되어 사용될 수 있습니다. 또한 session_state라고 불리는 이러한 객체들이 streamlit의 매 실행마다 변경되지 않는 것을 필요로합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 2가지 주요 함수를 정의합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-python\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"@st.cache_resource\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create_client\"\n        }), \"():   \\n    yourHFtoken = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"hf_xxxxxxxxxxxxxxxxxxxxxxx\\\"\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"#여기에 여러분의 HF 토큰을 넣으세요\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"print\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"f'\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"{st.session_state.hf_model}\"\n          }), \"에 대한 API Gradio 클라이언트를 로딩 중입니다.'\"]\n        }), \")\\n    client = Client(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Qwen/Qwen1.5-110B-Chat-demo\\\"\"\n        }), \", hf_token=yourHFtoken)\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" client\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"# 모든 채팅 메시지를 chathistory.txt에 기록하는 함수\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"writehistory\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"text\"\n        }), \"):\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"open\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'chathistorywen110b.txt'\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'a'\"\n        }), \", encoding=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'utf-8'\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" f:\\n        f.write(text)\\n        f.write(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'\\\\n'\"\n        }), \")\\n    f.close()\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저희는 @st.cache_resource 데코레이터를 사용하고 있습니다. 이는 Qwen1.5-110에 대한 API gradio 클라이언트를 Streamlit이 매 실행마다 로딩하지 않기를 원하기 때문입니다 (이는 분당 1회 이상 발생할 수 있습니다): Gradio 클라이언트 연결이 실행 중에 변경되지 않을 것이기 때문에, 이 리소스를 특별한 메모리에 캐싱하고 있습니다 (@st.cache_resource). 자세한 내용은 여기에서 확인하실 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"일부 그래픽 조정\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 기본 Streamlit 페이지 요소와 챗봇에 사용할 아이콘을 설정할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"#아바타\\nav_us = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'🧑‍💻'\"\n        }), \"  # \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./man.png'\"\n        }), \"  #\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🦖\\\"\"\n        }), \"  # \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🧑‍💻\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🤖\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🦖\\\"\"\n        }), \"과 같은 단일 이모지입니다. \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Shortcut\"\n        }), \"은 지원되지 않습니다.\\nav_ass = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"🤖\\\"\"\n        }), \"   #\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./robot.png'\"\n        }), \"\\n# 기본 모델 설정\\n\\n### \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"STREAMLIT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"UI\"\n        }), \" 시작\\nst.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"image\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'https://github.com/fabiomatricardi/ChatBOTMastery/raw/main/qwen100logo.png'\"\n        }), \", )\\nst.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"### *Streamlit \u0026 Gradio_client로 구동됨*\\\"\"\n        }), \", unsafe_allow_html=\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"True\"\n        }), \" )\\nst.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'---'\"\n        }), \")\\n\\nclient = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"create_client\"\n        }), \"()\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"채팅 인터페이스에 로컬 이미지를 사용할 수도 있어요 (코드의 주석을 참고하세요!)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"마지막으로, create_client()로 클라이언트 연결을 인스턴스화해요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"본문 — 채팅 인터페이스\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Streamlit은 자신의 위젯에 변경이 발생할 때마다 또는 입력(버튼, 선택기, 라디오 요소 등)으로 사용자 조작이 호출될 때마다 코드를 맨 위부터 다시 실행해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서 저희는 대화 기록을 맨 위에 먼저 렌더링하기 시작했어요. 여기서는 뭐라도 새롭게 발명한 건 없어요: Streamlit 블로그의 공식 자습서에서 모두 배웠거든요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 표준 렌더링입니다. OpenAI API와 호환되는 chat_completion 형식에 모두 적용 가능합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코드로 돌아가서, 우리는 chat_template 메시지들을 표시하고, 메시지 목록을 반복하며 사용자 프롬프트(myprompt)가 제출되기를 기다립니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"# 앱 재실행 시 이전 대화 내용을 보여줍니다\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" message \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" st.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"session_state\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"messages\"\n        }), \":\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" message[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"role\\\"\"\n        }), \"] == \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"user\\\"\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"chat_message\"\n        }), \"(message[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"role\\\"\"\n        }), \"],avatar=av_us):\\n            st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(message[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content\\\"\"\n        }), \"])\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"else\"\n        }), \":\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"chat_message\"\n        }), \"(message[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"role\\\"\"\n        }), \"],avatar=av_ass):\\n            st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(message[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content\\\"\"\n        }), \"])\\n# 사용자 입력 받기\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" myprompt := st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"chat_input\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"인공지능 모델이란 무엇인가요?\\\"\"\n        }), \"):\\n    # 사용자 메시지를 대화 내역에 추가\\n    st.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"session_state\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"messages\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"({\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"role\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"user\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content\\\"\"\n        }), \": myprompt})\\n    # 대화 메시지 컨테이너에 사용자 메시지 표시\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"chat_message\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"user\\\"\"\n        }), \", avatar=av_us):\\n        st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(myprompt)\\n        usertext = f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"user: {myprompt}\\\"\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"writehistory\"\n        }), \"(usertext)\\n        # 차후 사용을 위해 대화 상대의 응답을 표시\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기에 이상한 writehistory(usertext) 지시문을 추가하고 있는 것을 볼 수 있습니다. 기억하시나요? 처음에 이 함수를 선언했던 거죠? 저는 모든 대화 내용을 로컬 텍스트 파일에 저장하는 버릇이 있어요. 이는 프롬프트를 분석하거나 미래 활용을 위해 자료를 조직화할 때 매우 편리합니다.🙂\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프롬프트에서 제출된 내용을 확인한 후, gradio 클라이언트 인스턴스(client.submit)를 호출하고 스트리밍을 시작합니다 (message_placeholder.markdown(r[1][0][1]+ \\\"▌\\\"))\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"    # 채팅 메시지 컨테이너에 어시스턴트 응답 표시\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"with\"\n        }), \" st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"chat_message\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"assistant\\\"\"\n        }), \"):\\n        message_placeholder = st.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"empty\"\n        }), \"()\\n        full_response = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \"\\n        res  =  client.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"submit\"\n        }), \"(\\n                query=myprompt,\\n                history=[],\\n                system=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"You are a helpful assistant.\\\"\"\n        }), \",\\n                api_name=\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"/model_chat\\\"\"\n        }), \"\\n                )        \\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" r \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"res\"\n        }), \":\\n            full_response=r[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]\\n            message_placeholder.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(r[\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"][\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"]+ \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"▌\\\"\"\n        }), \")\\n\\n        message_placeholder.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"markdown\"\n        }), \"(full_response)\\n        asstext = f\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"assistant: {full_response}\\\"\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"writehistory\"\n        }), \"(asstext)       \\n        st.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"session_state\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"messages\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"append\"\n        }), \"({\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"role\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"assistant\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content\\\"\"\n        }), \": full_response})\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이게 전부에요. full_response는 최종 텍스트가 들어 있는 변수이므로 대화 기록에도 추가하여 표시합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"해결했으면 댓글에 알려주세요 👍\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"파이썬 파일을 저장한 후 터미널에서 가상 환경을 활성화한 상태에서 다음과 같이 실행하세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"streamlit run .\\\\st-\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Qwen1\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".5\"\n        }), \"-110B-\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Chat\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"py\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래처럼 나와야 합니다... 그리고 기본 브라우저가 로컬 URL인 http://localhost:8501로 열리게 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_0.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Streamlit은 로컬 네트워크로의 편리한 라우팅을 제공합니다. 예를 들어, 핸드폰이 동일한 액세스 포인트에 연결되어 있으면 Network URL로 표시된 주소인 http://192.168.2.6:8501을 통해 핸드폰에서도 이 애플리케이션을 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_1.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"다른 모델 실행에 대한 참고 사항\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GitHub 리포지토리에서도 Streamlit Python 파일을 실행하는 방법을 찾을 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"OpenELM 3B\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Phi-3-mini-Instruct 128k\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"QwenMoE\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"고객 구성이 변경될 예정입니다 (물론...) 그리고 스트리밍 지침도 변경될 것입니다. 이는 API 엔드포인트가 다른 데이터 유형을 반환하기 때문에 발생합니다. OpenELM 및 Phi-3의 경우 순수한 문자열이 반환되므로 어떠한 사전/튜플 위치에 있는 LLM 응답을 추출할 필요가 없습니다. 여기를 살펴보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 또한 PLEASE, 기억해주세요...\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_2.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 모든 복잡성을 다루는 이유는 무엇일까요? 우리는 어떻게 일하는지 배우고, 나만의 AI 비서를 만드는 방법을 알고 싶기 때문입니다. 내가 상상할 수 있는 최고의 목적을 위해 콘텐츠 생성, 학습 자료, 프레젠테이션, 교육 지원 등.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"어디에 사용할 건가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"글이 마음에 드셨으면 좋겣습니다. 이 이야기가 가치를 제공했고 조금이라도 지원하고 싶다면 다음을 해볼 수 있습니다 :\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이 이야기에 대해 많이 박수를 쳐 주세요\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"기억할 가치가 있는 부분을 강조하십시오 (나중에 찾기 쉽고, 더 나은 기사를 쓰는 데 도움이 될 것입니다)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Build Your Own AI를 시작하는 방법을 배우려면, 무료 eBook을 다운로드하세요\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"내 링크를 사용하여 Medium 멤버십 가입하기 - (무제한 Medium 이야기를 읽으려면 매달 $5)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Medium에서 나를 팔로우하기\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"내 최신 기사 읽기 https://medium.com/@fabio.matricardi\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기 몇 가지 더 흥미로운 읽을거리:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"추가 학습 자료\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_3.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 이야기는 Generative AI Publication에서 발행되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"최신 AI 이야기를 놓치지 않으려면 Substack, LinkedIn 및 Zeniteq에서 저희와 연락하여 AI의 미래를 함께 창조해보세요!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2_4.png\",\n        alt: \"이미지\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-ChatbotcheatcodeQwen110BonStreamlitwithoutspendingapennyPart2"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>