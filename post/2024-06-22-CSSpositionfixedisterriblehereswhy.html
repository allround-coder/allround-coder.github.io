<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>CSS position fixed가 문제인 3가지 이유 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-CSSpositionfixedisterriblehereswhy" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="CSS position fixed가 문제인 3가지 이유 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="CSS position fixed가 문제인 3가지 이유 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-CSSpositionfixedisterriblehereswhy_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-CSSpositionfixedisterriblehereswhy" data-gatsby-head="true"/><meta name="twitter:title" content="CSS position fixed가 문제인 3가지 이유 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-CSSpositionfixedisterriblehereswhy_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 03:40" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">CSS position fixed가 문제인 3가지 이유</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="CSS position fixed가 문제인 3가지 이유" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-CSSpositionfixedisterriblehereswhy&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>자바스크립트 UI - 개발 블로그 #4</h2>
<p><img src="/assets/img/2024-06-22-CSSpositionfixedisterriblehereswhy_0.png" alt="이미지"></p>
<h2>소개</h2>
<p>HTML과 CSS는 근본적인 문제를 해결하기보다 예외 사항을 도입하는 경향이 있습니다. 특히 position 속성과 특히 position: fixed는 그 증거입니다. 이런 언어들이 계속해서 개념, 규칙 및 규례를 만들어 내지만 더 많은 이상한 행동과 일관성이 내가 셀 수 있는 것보다 더 많이 있어서 이해하기 어렵습니다.</p>
<div class="content-ad"></div>
<p>그게 무슨 뜻이지?</p>
<h2>규칙</h2>
<p>당신이 뷰 트리의 가장 기본적인 규칙을 직관적으로 이해하려면 로켓 과학자가 되어있을 필요는 없어요:</p>
<ul>
<li>우리 코드의 트리는 뷰 트리와 똑같이 보여야 해요 (한숨)</li>
<li>각 뷰는 유일하며 트리에 한 번만 나타날 수 있어요</li>
<li>각 뷰는 정확히 하나의 부모를 가지고 있어요. 루트는 부모가 없어요</li>
<li>뷰는 0개 이상의 자식을 가질 수 있어요</li>
<li>나중에 정의된 뷰가 일찍 정의된 뷰 위에 나타나요</li>
</ul>
<div class="content-ad"></div>
<p>이것은 직관적이고 명확하며 간단합니다. 위치:고정을 입력하세요.</p>
<h2>위치: 고정의 엉망인 디자인</h2>
<p>HTML에는 우리의 계층 구조를 정의하는 방법에 대한 특정한 엄격함이 있으며 이는 올바른 레이아웃/사용자 인터페이스 개념을 근본적으로 훼손합니다. 이를 해결하기 위해 CSS가 개입해 HTML에 패치를 적용해야 했고, 결과적으로 레이아웃 구축과 관련하여 더 많은 문제가 발생했습니다. 이 예제를 살펴보세요. 이 스니펫은 화면에 어떻게 보일까요?</p>
<pre><code class="hljs language-js">&#x3C;body>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"fixed_1"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"position: fixed"</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"fixed_2"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"position: fixed"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"regular"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
&#x3C;/body>
</code></pre>
<div class="content-ad"></div>
<p>fixed_1은 일반적인 흐름에서 벗어나 뷰포트에 대해 상대적으로 배치되어 부모가 변경됩니다. fixed_2도 동일하지만 시각적으로 fixed_1의 자식이 아닌 형제가 되었습니다 (fixed_1은 fixed_1을 자르거나 스크롤할 수 없습니다). 더불어 (위치상의) 그들은 정해진 것보다 뒤에 정의되었다는 사실에도 불구하고 일반적인 것 위에 나타납니다. 그리고 웹 전문가들이 의미론적으로 생각하는 것입니다.</p>
<p>수백 페이지의 명세서를 쓰고, 끝없는 예외, 이상한 새로운 개념, 쌓임 맥락, 포함 블록을 도입하고 CSS가 가파른 학습 곡선을 가지고 있다고 말해도, 결과는 여전히 대참사일 것입니다. 심지어 하나의 요소에 position: fixed를 추가하면, 앞서 정의한 다섯 가지 규칙을 근본적으로 어길 것입니다 (오히려 이것은 내 규칙이 아니라 HTML과 CSS의 핵심입니다). 이 모든 것은 HTML이 뷰포트에 뷰를 직접 추가하는 것을 허용하지 않기 때문입니다.</p>
<h2>해결책</h2>
<p>HTML 가르침을 잠시 내려놓고 이 코드 조각을 살펴보시기 바랍니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">&#x3C;viewport>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">html</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">body</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"regular"</span>></span>웹 사이트의 본문<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">body</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">html</span>></span></span>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"fixed_1"</span>></span>고정입니다<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"fixed_2"</span>></span>여기도 고정입니다<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
&#x3C;/viewport>
</code></pre>
<p>이것은 명백히 유효하지 않은 HTML이지만 매우 가깝습니다. 이전에 정의한 다섯 가지 규칙을 모두 준수하며 고정 위치를 필요로하지 않습니다. 사실, 위치 속성조차 필요하지 않습니다. 뷰를 소유한 곳에 두어 뷰 계층 구조가 명확합니다. 무작정 특정 예외를 생성하는 대신 자체 규칙을 이해함으로써 더 적은 노력으로 더 많은 것을 달성할 수 있습니다.</p>
<p>안타깝게도 브라우저에서 뷰 트리의 루트는 이보다 훨씬 복잡합니다. 실제 viewport는 직접 접근할 수 없으며 <code>html</code>은 viewport도 아니고 viewport의 첫 번째 자식조차 아닙니다. 실제 트리는 다음과 같이 더 복잡합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">window</span> <span class="hljs-comment">//object</span>
  screen <span class="hljs-comment">//object, window의 상위</span>
  viewport <span class="hljs-comment">//object, 접근 불가, 루트 뷰여야 함</span>
    #<span class="hljs-variable language_">document</span> <span class="hljs-comment">//node, 실제 루트 뷰</span>
      #doctype <span class="hljs-comment">//node</span>
      &#x3C;html> <span class="hljs-comment">//"root" element</span>
        &#x3C;head> <span class="hljs-comment">//보이지 않는 요소 (메타데이터)</span>
        &#x3C;body>  <span class="hljs-comment">//"root" element</span>
          &#x3C;div> <span class="hljs-comment">//요소 (고정), viewport의 직접 자식이어야 함</span>
          &#x3C;div> <span class="hljs-comment">//요소 (일반)</span>
</code></pre>
<div class="content-ad"></div>
<p>절대 아름다워요.</p>
<h2>JavaScriptUI는 어떻게 작동하나요</h2>
<p>JavaScriptUI에서는 position: fixed를 사용할 필요가 없습니다. 사실 position 속성 전체가 불필요합니다. 대신에 적절한 뷰 계층 구조와 직관적인 컨테이너가 있습니다 (사실 display 속성도 제거되었지만, 이 부분은 다른 설치에서 다룰 예정입니다). 당신이 작성한 대로 결과가 나옵니다.</p>
<p>이것은 정확히 같은 예제이지만 엉망과 혼란이 없습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-title class_">App</span>(
  <span class="hljs-title class_">Stack</span>(
    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"웹 사이트의 본문입니다."</span>)
  ),
  <span class="hljs-title class_">Text</span>(<span class="hljs-string">"고정입니다."</span>),
  <span class="hljs-title class_">Text</span>(<span class="hljs-string">"또 다른 고정입니다."</span>)
);
</code></pre>
<p>다시 말씀드리지만, 이 코드는 유효한 JavaScript 코드입니다. 단일 라이브러리에 의존하고 있습니다. 여전히 레거시 혼란이 유효한지 생각하시나요?</p>
<h2>하지만, 그게 왜 중요한가요?</h2>
<p>알겠어요. 이건 단 하나의 속성일 뿐이고 누가 신경 쓸까요, 맞죠? 제가 전하는 포인트는 HTML과 CSS가 이러한 성가신 문제에 침통해 있으며, 프로젝트가 확장될수록 이러한 문제들이 얼마나 많은 압박을 가하는지 심지어 인지하지 못할 수 있을 것이라는 것입니다. 오버레이, 팝업, 문서 내 다른 레이어가 필요한 경우 이 문제를 마주치게 될 것이며, CSS 코드를 부풀려 HTML 계층 구조를 엉망으로 만들며 혼란을 증가시키고 접근성을 해치고 반응성을 부정적으로 영향을 미칠 것입니다.</p>
<div class="content-ad"></div>
<h2>마무리</h2>
<p>이번 포스트는 짧았지만 여전히 도움이 된다면 좋겠습니다. 다음 주에는 더 많은 CSS 속성 및 값에 대해 알아보고 사용하기 좋은 추상화를 구축할 것입니다.</p>
<p>만약 이 프로젝트가 마음에 든다면 박수 치거나 댓글을 남기고 다른 사람들과 이 블로그를 공유해주세요.</p>
<p>감사합니다, 즐거운 시간 보내세요!</p>
<div class="content-ad"></div>
<p>⬅️ DevBlog #3 — CSS를 대체하기 위한 새로운 스타일 시스템 설계</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"CSS position fixed가 문제인 3가지 이유","description":"","date":"2024-06-22 03:40","slug":"2024-06-22-CSSpositionfixedisterriblehereswhy","content":"\n\n## 자바스크립트 UI - 개발 블로그 #4\n\n![이미지](/assets/img/2024-06-22-CSSpositionfixedisterriblehereswhy_0.png)\n\n## 소개\n\nHTML과 CSS는 근본적인 문제를 해결하기보다 예외 사항을 도입하는 경향이 있습니다. 특히 position 속성과 특히 position: fixed는 그 증거입니다. 이런 언어들이 계속해서 개념, 규칙 및 규례를 만들어 내지만 더 많은 이상한 행동과 일관성이 내가 셀 수 있는 것보다 더 많이 있어서 이해하기 어렵습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그게 무슨 뜻이지?\n\n## 규칙\n\n당신이 뷰 트리의 가장 기본적인 규칙을 직관적으로 이해하려면 로켓 과학자가 되어있을 필요는 없어요:\n\n- 우리 코드의 트리는 뷰 트리와 똑같이 보여야 해요 (한숨)\n- 각 뷰는 유일하며 트리에 한 번만 나타날 수 있어요\n- 각 뷰는 정확히 하나의 부모를 가지고 있어요. 루트는 부모가 없어요\n- 뷰는 0개 이상의 자식을 가질 수 있어요\n- 나중에 정의된 뷰가 일찍 정의된 뷰 위에 나타나요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 직관적이고 명확하며 간단합니다. 위치:고정을 입력하세요.\n\n## 위치: 고정의 엉망인 디자인\n\nHTML에는 우리의 계층 구조를 정의하는 방법에 대한 특정한 엄격함이 있으며 이는 올바른 레이아웃/사용자 인터페이스 개념을 근본적으로 훼손합니다. 이를 해결하기 위해 CSS가 개입해 HTML에 패치를 적용해야 했고, 결과적으로 레이아웃 구축과 관련하여 더 많은 문제가 발생했습니다. 이 예제를 살펴보세요. 이 스니펫은 화면에 어떻게 보일까요?\n\n```js\n\u003cbody\u003e\n  \u003cdiv id=\"fixed_1\" style=\"position: fixed\"\u003e\n    \u003cdiv id=\"fixed_2\" style=\"position: fixed\"\u003e\u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv id=\"regular\"\u003e\u003c/div\u003e\n\u003c/body\u003e\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nfixed_1은 일반적인 흐름에서 벗어나 뷰포트에 대해 상대적으로 배치되어 부모가 변경됩니다. fixed_2도 동일하지만 시각적으로 fixed_1의 자식이 아닌 형제가 되었습니다 (fixed_1은 fixed_1을 자르거나 스크롤할 수 없습니다). 더불어 (위치상의) 그들은 정해진 것보다 뒤에 정의되었다는 사실에도 불구하고 일반적인 것 위에 나타납니다. 그리고 웹 전문가들이 의미론적으로 생각하는 것입니다.\n\n수백 페이지의 명세서를 쓰고, 끝없는 예외, 이상한 새로운 개념, 쌓임 맥락, 포함 블록을 도입하고 CSS가 가파른 학습 곡선을 가지고 있다고 말해도, 결과는 여전히 대참사일 것입니다. 심지어 하나의 요소에 position: fixed를 추가하면, 앞서 정의한 다섯 가지 규칙을 근본적으로 어길 것입니다 (오히려 이것은 내 규칙이 아니라 HTML과 CSS의 핵심입니다). 이 모든 것은 HTML이 뷰포트에 뷰를 직접 추가하는 것을 허용하지 않기 때문입니다.\n\n## 해결책\n\nHTML 가르침을 잠시 내려놓고 이 코드 조각을 살펴보시기 바랍니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003cviewport\u003e\n  \u003chtml\u003e\n    \u003cbody\u003e\n      \u003cdiv id=\"regular\"\u003e웹 사이트의 본문\u003c/div\u003e\n    \u003c/body\u003e\n  \u003c/html\u003e\n  \u003cdiv id=\"fixed_1\"\u003e고정입니다\u003c/div\u003e\n  \u003cdiv id=\"fixed_2\"\u003e여기도 고정입니다\u003c/div\u003e\n\u003c/viewport\u003e\n```\n\n이것은 명백히 유효하지 않은 HTML이지만 매우 가깝습니다. 이전에 정의한 다섯 가지 규칙을 모두 준수하며 고정 위치를 필요로하지 않습니다. 사실, 위치 속성조차 필요하지 않습니다. 뷰를 소유한 곳에 두어 뷰 계층 구조가 명확합니다. 무작정 특정 예외를 생성하는 대신 자체 규칙을 이해함으로써 더 적은 노력으로 더 많은 것을 달성할 수 있습니다.\n\n안타깝게도 브라우저에서 뷰 트리의 루트는 이보다 훨씬 복잡합니다. 실제 viewport는 직접 접근할 수 없으며 `html`은 viewport도 아니고 viewport의 첫 번째 자식조차 아닙니다. 실제 트리는 다음과 같이 더 복잡합니다:\n\n```js\nwindow //object\n  screen //object, window의 상위\n  viewport //object, 접근 불가, 루트 뷰여야 함\n    #document //node, 실제 루트 뷰\n      #doctype //node\n      \u003chtml\u003e //\"root\" element\n        \u003chead\u003e //보이지 않는 요소 (메타데이터)\n        \u003cbody\u003e  //\"root\" element\n          \u003cdiv\u003e //요소 (고정), viewport의 직접 자식이어야 함\n          \u003cdiv\u003e //요소 (일반)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n절대 아름다워요.\n\n## JavaScriptUI는 어떻게 작동하나요\n\nJavaScriptUI에서는 position: fixed를 사용할 필요가 없습니다. 사실 position 속성 전체가 불필요합니다. 대신에 적절한 뷰 계층 구조와 직관적인 컨테이너가 있습니다 (사실 display 속성도 제거되었지만, 이 부분은 다른 설치에서 다룰 예정입니다). 당신이 작성한 대로 결과가 나옵니다.\n\n이것은 정확히 같은 예제이지만 엉망과 혼란이 없습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nApp(\n  Stack(\n    Text(\"웹 사이트의 본문입니다.\")\n  ),\n  Text(\"고정입니다.\"),\n  Text(\"또 다른 고정입니다.\")\n);\n```\n\n다시 말씀드리지만, 이 코드는 유효한 JavaScript 코드입니다. 단일 라이브러리에 의존하고 있습니다. 여전히 레거시 혼란이 유효한지 생각하시나요?\n\n## 하지만, 그게 왜 중요한가요?\n\n알겠어요. 이건 단 하나의 속성일 뿐이고 누가 신경 쓸까요, 맞죠? 제가 전하는 포인트는 HTML과 CSS가 이러한 성가신 문제에 침통해 있으며, 프로젝트가 확장될수록 이러한 문제들이 얼마나 많은 압박을 가하는지 심지어 인지하지 못할 수 있을 것이라는 것입니다. 오버레이, 팝업, 문서 내 다른 레이어가 필요한 경우 이 문제를 마주치게 될 것이며, CSS 코드를 부풀려 HTML 계층 구조를 엉망으로 만들며 혼란을 증가시키고 접근성을 해치고 반응성을 부정적으로 영향을 미칠 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 마무리\n\n이번 포스트는 짧았지만 여전히 도움이 된다면 좋겠습니다. 다음 주에는 더 많은 CSS 속성 및 값에 대해 알아보고 사용하기 좋은 추상화를 구축할 것입니다.\n\n만약 이 프로젝트가 마음에 든다면 박수 치거나 댓글을 남기고 다른 사람들과 이 블로그를 공유해주세요.\n\n감사합니다, 즐거운 시간 보내세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n⬅️ DevBlog #3 — CSS를 대체하기 위한 새로운 스타일 시스템 설계","ogImage":{"url":"/assets/img/2024-06-22-CSSpositionfixedisterriblehereswhy_0.png"},"coverImage":"/assets/img/2024-06-22-CSSpositionfixedisterriblehereswhy_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e자바스크립트 UI - 개발 블로그 #4\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-CSSpositionfixedisterriblehereswhy_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e소개\u003c/h2\u003e\n\u003cp\u003eHTML과 CSS는 근본적인 문제를 해결하기보다 예외 사항을 도입하는 경향이 있습니다. 특히 position 속성과 특히 position: fixed는 그 증거입니다. 이런 언어들이 계속해서 개념, 규칙 및 규례를 만들어 내지만 더 많은 이상한 행동과 일관성이 내가 셀 수 있는 것보다 더 많이 있어서 이해하기 어렵습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그게 무슨 뜻이지?\u003c/p\u003e\n\u003ch2\u003e규칙\u003c/h2\u003e\n\u003cp\u003e당신이 뷰 트리의 가장 기본적인 규칙을 직관적으로 이해하려면 로켓 과학자가 되어있을 필요는 없어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e우리 코드의 트리는 뷰 트리와 똑같이 보여야 해요 (한숨)\u003c/li\u003e\n\u003cli\u003e각 뷰는 유일하며 트리에 한 번만 나타날 수 있어요\u003c/li\u003e\n\u003cli\u003e각 뷰는 정확히 하나의 부모를 가지고 있어요. 루트는 부모가 없어요\u003c/li\u003e\n\u003cli\u003e뷰는 0개 이상의 자식을 가질 수 있어요\u003c/li\u003e\n\u003cli\u003e나중에 정의된 뷰가 일찍 정의된 뷰 위에 나타나요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이것은 직관적이고 명확하며 간단합니다. 위치:고정을 입력하세요.\u003c/p\u003e\n\u003ch2\u003e위치: 고정의 엉망인 디자인\u003c/h2\u003e\n\u003cp\u003eHTML에는 우리의 계층 구조를 정의하는 방법에 대한 특정한 엄격함이 있으며 이는 올바른 레이아웃/사용자 인터페이스 개념을 근본적으로 훼손합니다. 이를 해결하기 위해 CSS가 개입해 HTML에 패치를 적용해야 했고, 결과적으로 레이아웃 구축과 관련하여 더 많은 문제가 발생했습니다. 이 예제를 살펴보세요. 이 스니펫은 화면에 어떻게 보일까요?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;body\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"fixed_1\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"position: fixed\"\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"fixed_2\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"position: fixed\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"regular\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/body\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003efixed_1은 일반적인 흐름에서 벗어나 뷰포트에 대해 상대적으로 배치되어 부모가 변경됩니다. fixed_2도 동일하지만 시각적으로 fixed_1의 자식이 아닌 형제가 되었습니다 (fixed_1은 fixed_1을 자르거나 스크롤할 수 없습니다). 더불어 (위치상의) 그들은 정해진 것보다 뒤에 정의되었다는 사실에도 불구하고 일반적인 것 위에 나타납니다. 그리고 웹 전문가들이 의미론적으로 생각하는 것입니다.\u003c/p\u003e\n\u003cp\u003e수백 페이지의 명세서를 쓰고, 끝없는 예외, 이상한 새로운 개념, 쌓임 맥락, 포함 블록을 도입하고 CSS가 가파른 학습 곡선을 가지고 있다고 말해도, 결과는 여전히 대참사일 것입니다. 심지어 하나의 요소에 position: fixed를 추가하면, 앞서 정의한 다섯 가지 규칙을 근본적으로 어길 것입니다 (오히려 이것은 내 규칙이 아니라 HTML과 CSS의 핵심입니다). 이 모든 것은 HTML이 뷰포트에 뷰를 직접 추가하는 것을 허용하지 않기 때문입니다.\u003c/p\u003e\n\u003ch2\u003e해결책\u003c/h2\u003e\n\u003cp\u003eHTML 가르침을 잠시 내려놓고 이 코드 조각을 살펴보시기 바랍니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;viewport\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"regular\"\u003c/span\u003e\u003e\u003c/span\u003e웹 사이트의 본문\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ehtml\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"fixed_1\"\u003c/span\u003e\u003e\u003c/span\u003e고정입니다\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"fixed_2\"\u003c/span\u003e\u003e\u003c/span\u003e여기도 고정입니다\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/viewport\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것은 명백히 유효하지 않은 HTML이지만 매우 가깝습니다. 이전에 정의한 다섯 가지 규칙을 모두 준수하며 고정 위치를 필요로하지 않습니다. 사실, 위치 속성조차 필요하지 않습니다. 뷰를 소유한 곳에 두어 뷰 계층 구조가 명확합니다. 무작정 특정 예외를 생성하는 대신 자체 규칙을 이해함으로써 더 적은 노력으로 더 많은 것을 달성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e안타깝게도 브라우저에서 뷰 트리의 루트는 이보다 훨씬 복잡합니다. 실제 viewport는 직접 접근할 수 없으며 \u003ccode\u003ehtml\u003c/code\u003e은 viewport도 아니고 viewport의 첫 번째 자식조차 아닙니다. 실제 트리는 다음과 같이 더 복잡합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e//object\u003c/span\u003e\n  screen \u003cspan class=\"hljs-comment\"\u003e//object, window의 상위\u003c/span\u003e\n  viewport \u003cspan class=\"hljs-comment\"\u003e//object, 접근 불가, 루트 뷰여야 함\u003c/span\u003e\n    #\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e//node, 실제 루트 뷰\u003c/span\u003e\n      #doctype \u003cspan class=\"hljs-comment\"\u003e//node\u003c/span\u003e\n      \u0026#x3C;html\u003e \u003cspan class=\"hljs-comment\"\u003e//\"root\" element\u003c/span\u003e\n        \u0026#x3C;head\u003e \u003cspan class=\"hljs-comment\"\u003e//보이지 않는 요소 (메타데이터)\u003c/span\u003e\n        \u0026#x3C;body\u003e  \u003cspan class=\"hljs-comment\"\u003e//\"root\" element\u003c/span\u003e\n          \u0026#x3C;div\u003e \u003cspan class=\"hljs-comment\"\u003e//요소 (고정), viewport의 직접 자식이어야 함\u003c/span\u003e\n          \u0026#x3C;div\u003e \u003cspan class=\"hljs-comment\"\u003e//요소 (일반)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e절대 아름다워요.\u003c/p\u003e\n\u003ch2\u003eJavaScriptUI는 어떻게 작동하나요\u003c/h2\u003e\n\u003cp\u003eJavaScriptUI에서는 position: fixed를 사용할 필요가 없습니다. 사실 position 속성 전체가 불필요합니다. 대신에 적절한 뷰 계층 구조와 직관적인 컨테이너가 있습니다 (사실 display 속성도 제거되었지만, 이 부분은 다른 설치에서 다룰 예정입니다). 당신이 작성한 대로 결과가 나옵니다.\u003c/p\u003e\n\u003cp\u003e이것은 정확히 같은 예제이지만 엉망과 혼란이 없습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e(\n  \u003cspan class=\"hljs-title class_\"\u003eStack\u003c/span\u003e(\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"웹 사이트의 본문입니다.\"\u003c/span\u003e)\n  ),\n  \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"고정입니다.\"\u003c/span\u003e),\n  \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"또 다른 고정입니다.\"\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다시 말씀드리지만, 이 코드는 유효한 JavaScript 코드입니다. 단일 라이브러리에 의존하고 있습니다. 여전히 레거시 혼란이 유효한지 생각하시나요?\u003c/p\u003e\n\u003ch2\u003e하지만, 그게 왜 중요한가요?\u003c/h2\u003e\n\u003cp\u003e알겠어요. 이건 단 하나의 속성일 뿐이고 누가 신경 쓸까요, 맞죠? 제가 전하는 포인트는 HTML과 CSS가 이러한 성가신 문제에 침통해 있으며, 프로젝트가 확장될수록 이러한 문제들이 얼마나 많은 압박을 가하는지 심지어 인지하지 못할 수 있을 것이라는 것입니다. 오버레이, 팝업, 문서 내 다른 레이어가 필요한 경우 이 문제를 마주치게 될 것이며, CSS 코드를 부풀려 HTML 계층 구조를 엉망으로 만들며 혼란을 증가시키고 접근성을 해치고 반응성을 부정적으로 영향을 미칠 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e마무리\u003c/h2\u003e\n\u003cp\u003e이번 포스트는 짧았지만 여전히 도움이 된다면 좋겠습니다. 다음 주에는 더 많은 CSS 속성 및 값에 대해 알아보고 사용하기 좋은 추상화를 구축할 것입니다.\u003c/p\u003e\n\u003cp\u003e만약 이 프로젝트가 마음에 든다면 박수 치거나 댓글을 남기고 다른 사람들과 이 블로그를 공유해주세요.\u003c/p\u003e\n\u003cp\u003e감사합니다, 즐거운 시간 보내세요!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e⬅️ DevBlog #3 — CSS를 대체하기 위한 새로운 스타일 시스템 설계\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-CSSpositionfixedisterriblehereswhy"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>