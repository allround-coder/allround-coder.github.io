<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Angular 18 Zoneless 2024년 핵심 기능 탐구 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-27-Angular18ZonelessExploringthePillars" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Angular 18 Zoneless 2024년 핵심 기능 탐구 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Angular 18 Zoneless 2024년 핵심 기능 탐구 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-27-Angular18ZonelessExploringthePillars" data-gatsby-head="true"/><meta name="twitter:title" content="Angular 18 Zoneless 2024년 핵심 기능 탐구 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-27 18:23" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Angular 18 Zoneless 2024년 핵심 기능 탐구</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Angular 18 Zoneless 2024년 핵심 기능 탐구" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 27, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-27-Angular18ZonelessExploringthePillars&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png" alt="Image"></p>
<p>"동의하지 않을 수도 있지만, 저는 Angular이 존리스(zoneless)가 되길 원했고 실현될 줄은 상상도 못 했습니다. 이제 실험 모드로 Angular 18에서 사용할 수 있습니다. 제발 프로덕션 환경에서 사용하지 마십시오."</p>
<h1>존리스(zoneless)란?</h1>
<p>네, 맞습니다. Angular의 존리스 설정에서 Angular 스케줄러는 컴포넌트 내에서 무언가 변경되었을 때 변경 감지를 자동으로 트리거하지 않습니다. 대신 Angular의 ChangeDetectorRef 서비스를 사용하여 변경 감지를 수동으로 트리거해야 합니다.</p>
<div class="content-ad"></div>
<p>여기 간단한 설명이 있어요:</p>
<p>Zone.js를 사용하는 기존 Angular 애플리케이션에서는 Angular이 모든 비동기 작업(HTTP 요청, setTimeout, 사용자 상호작용 등)이 완료될 때 자동으로 변경 감지를 트리거합니다. Zone.js는 이러한 비동기 작업들을 monkey-patch하여 Angular에게 변경 감지를 실행할 때 알리게 합니다.</p>
<p>우리가 무언가를 요리했다고 생각하실 지도 모르겠지만, 네 개의 기둥은 어디에 있을까요? 🧐</p>
<p>우선, Angular 18의 zoneless API를 확인하는 설정을 해야 합니다.</p>
<div class="content-ad"></div>
<ul>
<li>설치.</li>
</ul>
<pre><code class="hljs language-js">ng install @angular/cli@^<span class="hljs-number">18</span>
</code></pre>
<ol start="2">
<li>새 앱 만들기</li>
</ol>
<pre><code class="hljs language-js">ng <span class="hljs-keyword">new</span> zoneless-app
cd zoneless-app
</code></pre>
<div class="content-ad"></div>
<ol start="3">
<li>app.config.ts 파일이나 애플리케이션 부트스트랩 파일로 이동하세요.</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ApplicationConfig</span>, provideExperimentalZonelessChangeDetection, provideZoneChangeDetection } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { provideRouter } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;

<span class="hljs-keyword">import</span> { routes } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.routes'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">appConfig</span>: <span class="hljs-title class_">ApplicationConfig</span> = {
  <span class="hljs-attr">providers</span>: [<span class="hljs-title function_">provideExperimentalZonelessChangeDetection</span>(), <span class="hljs-title function_">provideRouter</span>(routes)]
};
</code></pre>
<ol start="4">
<li>angular.json의 폴리필에서 zone.js를 제거하세요.</li>
</ol>
<img src="/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_1.png">
<div class="content-ad"></div>
<p>이제 모든 설정이 완료되었으니 애플리케이션을 실행하면 됩니다.</p>
<p>이제 이 설정 이후에는 Angular가 자동으로 변경 감지를 트리거하지 않습니다.</p>
<h1>왜 zoneless를 사용해야 하는가? .</h1>
<p>불필요한 변경 감지를 피하기 위해서 간단하게 제안드립니다.</p>
<div class="content-ad"></div>
<p>모든 컴포넌트의 비동기 작업이 발생할 때 Angular는 루트부터 모든 하위 컴포넌트를 확인하는데, 이는 비효율적일 수 있습니다.</p>
<p>"changeDetection" 전략 "OnPush"를 사용하여 이 문제를 극복할 수 있는 옵션이 있습니다. 이는 컴포넌트와 해당 모든 하위 컴포넌트를 일반 변경 감지 주기에서 격리시킵니다.</p>
<h1>네 기둥이 무엇인가요?</h1>
<ul>
<li>이벤트 핸들러.</li>
<li>MarkForChanges 관리.</li>
<li>비동기 파이프.</li>
<li>시그널.</li>
</ul>
<div class="content-ad"></div>
<h2>이벤트 핸들러 :</h2>
<p>앵귤러의 이벤트 핸들러는 템플릿의 이벤트에 바인딩된 컴포넌트 클래스 내의 메서드입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">'&#x3C;button (click)="onClick()">{state}&#x3C;/button>'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppComponent</span> {
 state = <span class="hljs-string">"Click Me"</span>;
  <span class="hljs-title function_">onClick</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-string">"Clicked"</span>;
  }
}
</code></pre>
<h2>MarkForChanges 관리하기:</h2>
<div class="content-ad"></div>
<p>앵귤러에서, markForCheck은 앵귤러의 기본 변경 감지가 변경 사항을 감지하지 못하는 시나리오에서 사용됩니다. 이는 OnPush 변경 감지 전략 및 지금은 zoneless에서 일반적입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChangeDetectorRef</span>, <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
      {data}
      &#x3C;button (click)="update()">Update&#x3C;/button>
     `</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppComponent</span> {
  data = <span class="hljs-string">'초기 데이터'</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private cdr: ChangeDetectorRef</span>) { }

  <span class="hljs-title function_">update</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = <span class="hljs-string">'업데이트된 데이터'</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cdr</span>.<span class="hljs-title function_">markForCheck</span>();
  }
}
</code></pre>
<h2>Async 파이프 :</h2>
<p>앵귤러의 AsyncPipe는 Observable 또는 Promise에 자동으로 구독하고 최신 값을 반환합니다. 또한 컴포넌트가 파괴될 때 자동으로 구독을 해제합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">CommonModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ChangeDetectionStrategy</span>, <span class="hljs-title class_">ChangeDetectorRef</span>, <span class="hljs-title class_">Component</span>, inject } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { bootstrapApplication } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span>, <span class="hljs-keyword">of</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'zone.js'</span>;
@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
     Hello world
     {data$ | async }
  `</span>,
  <span class="hljs-attr">changeDetection</span>: <span class="hljs-title class_">ChangeDetectionStrategy</span>.<span class="hljs-property">OnPush</span>,
  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">CommonModule</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> {
  name = <span class="hljs-string">'Angular'</span>;
  <span class="hljs-attr">data$</span>: <span class="hljs-title class_">Observable</span>&#x3C;string> | <span class="hljs-literal">undefined</span>;
  cRef = <span class="hljs-title function_">inject</span>(<span class="hljs-title class_">ChangeDetectorRef</span>);

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">data$</span> = <span class="hljs-title function_">of</span>(<span class="hljs-string">'Hello, AsyncPipe!'</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">cRef</span>.<span class="hljs-title function_">markForCheck</span>();
    }, <span class="hljs-number">4000</span>);
  }
}

<span class="hljs-title function_">bootstrapApplication</span>(<span class="hljs-title class_">App</span>);
</code></pre>
<h2>Signals:</h2>
<p>Angular에 Signals가 포함되어 정말 기쁩니다. 이전에는 불필요한 다시 렌더링 오버헤드를 극복하기 위해 신호를 사용해야 했습니다. 또한 이제 더 선언적 프로그래밍 스타일로 코드를 작성할 수 있고, 대부분의 주요 API는 Signals과 호환됩니다. 이것은 반응성을 위해 더 이상 RxJS에 의존하지 않아도 된다는 것을 의미합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Signal</span>, createSignal } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core/signals'</span>;

@<span class="hljs-title class_">Component</span>({
  <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-counter'</span>,
  <span class="hljs-attr">standalone</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">template</span>: <span class="hljs-string">`
    &#x3C;div class="counter">
      &#x3C;h1>Counter: { count.value }&#x3C;/h1>
      &#x3C;button (click)="decrement()">-&#x3C;/button>
      &#x3C;button (click)="increment()">+&#x3C;/button>
    &#x3C;/div>
  `</span>,
  <span class="hljs-attr">styles</span>: [<span class="hljs-string">`
    .counter {
      text-align: center;
      margin-top: 50px;
    }
    button {
      margin: 0 5px;
      padding: 10px;
      font-size: 16px;
    }
  `</span>]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CounterComponent</span> {
  <span class="hljs-comment">// Count 상태를 관리하기 위한 Signal 생성</span>
  <span class="hljs-attr">count</span>: <span class="hljs-title class_">Signal</span>&#x3C;number> = <span class="hljs-title function_">createSignal</span>(<span class="hljs-number">0</span>);

  <span class="hljs-comment">// Count 증가 메소드</span>
  <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>.<span class="hljs-property">value</span> + <span class="hljs-number">1</span>);
  }

  <span class="hljs-comment">// Count 감소 메소드</span>
  <span class="hljs-title function_">decrement</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>.<span class="hljs-property">value</span> - <span class="hljs-number">1</span>);
  }
}
</code></pre>
<div class="content-ad"></div>
<p>"markForCheck" 또는 수동 변경 감지가 필요하지 않습니다.</p>
<p>신호 패턴 때문에 수동 변경 감지 확인이 필요하지 않습니다. 수동 코드 작성 부담이 줄어들고, Angular 팀은 Input/Output, ViewChild 및 기타 모든 API를 신호로 변환하고 있습니다.</p>
<h2>마지막 기둥:</h2>
<p>SSR은 Angular의 마지막 기둥입니다. 다음 포스트에서 계속합니다.</p>
<div class="content-ad"></div>
<h2>결론:</h2>
<p>Angular은 이제 시그널의 도입으로 올바른 방향으로 나아가고 있습니다. Angular를 지원하는 중요한 요소 가운데 시그널이 특히 두드러집니다. 시그널은 Angular 18에서 존리스 작업으로의 전환을 용이하게 하뿐만 아니라 불필요한 다시 렌더링과 수동 변경 감지 확인의 부담으로부터 자유로움을 제공합니다. 이 방식은 성능을 향상시키는 것뿐만 아니라 더 선언적인 코딩 스타일을 촉진합니다.</p>
<p>서버 측 렌더링(SSR)은 Angular의 중요한 측면으로 남아 있으며, 제가 이후에 다룰 것입니다. 이 네 가지 중요한 요소인 이벤트 핸들러, MarkForChanges 관리, 비동기 파이프, 그리고 시그널을 계속 탐험하면 코드를 더 읽기 쉽고 간단하게 만드는 데 기여하는 방법을 발견할 것입니다.</p>
<p>즐거운 코딩되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Angular 18 Zoneless 2024년 핵심 기능 탐구","description":"","date":"2024-06-27 18:23","slug":"2024-06-27-Angular18ZonelessExploringthePillars","content":"\n\n\n![Image](/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png)\n\n\"동의하지 않을 수도 있지만, 저는 Angular이 존리스(zoneless)가 되길 원했고 실현될 줄은 상상도 못 했습니다. 이제 실험 모드로 Angular 18에서 사용할 수 있습니다. 제발 프로덕션 환경에서 사용하지 마십시오.\"\n\n# 존리스(zoneless)란?\n\n네, 맞습니다. Angular의 존리스 설정에서 Angular 스케줄러는 컴포넌트 내에서 무언가 변경되었을 때 변경 감지를 자동으로 트리거하지 않습니다. 대신 Angular의 ChangeDetectorRef 서비스를 사용하여 변경 감지를 수동으로 트리거해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 간단한 설명이 있어요:\n\nZone.js를 사용하는 기존 Angular 애플리케이션에서는 Angular이 모든 비동기 작업(HTTP 요청, setTimeout, 사용자 상호작용 등)이 완료될 때 자동으로 변경 감지를 트리거합니다. Zone.js는 이러한 비동기 작업들을 monkey-patch하여 Angular에게 변경 감지를 실행할 때 알리게 합니다.\n\n우리가 무언가를 요리했다고 생각하실 지도 모르겠지만, 네 개의 기둥은 어디에 있을까요? 🧐\n\n우선, Angular 18의 zoneless API를 확인하는 설정을 해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 설치.\n\n```js\nng install @angular/cli@^18\n```\n\n2. 새 앱 만들기\n\n```js\nng new zoneless-app\ncd zoneless-app\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. app.config.ts 파일이나 애플리케이션 부트스트랩 파일로 이동하세요.\n\n```js\nimport { ApplicationConfig, provideExperimentalZonelessChangeDetection, provideZoneChangeDetection } from '@angular/core';\nimport { provideRouter } from '@angular/router';\n\nimport { routes } from './app.routes';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [provideExperimentalZonelessChangeDetection(), provideRouter(routes)]\n};\n```\n\n4. angular.json의 폴리필에서 zone.js를 제거하세요.\n\n\u003cimg src=\"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 모든 설정이 완료되었으니 애플리케이션을 실행하면 됩니다.\n\n이제 이 설정 이후에는 Angular가 자동으로 변경 감지를 트리거하지 않습니다.\n\n# 왜 zoneless를 사용해야 하는가? .\n\n불필요한 변경 감지를 피하기 위해서 간단하게 제안드립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 컴포넌트의 비동기 작업이 발생할 때 Angular는 루트부터 모든 하위 컴포넌트를 확인하는데, 이는 비효율적일 수 있습니다.\n\n\"changeDetection\" 전략 \"OnPush\"를 사용하여 이 문제를 극복할 수 있는 옵션이 있습니다. 이는 컴포넌트와 해당 모든 하위 컴포넌트를 일반 변경 감지 주기에서 격리시킵니다.\n\n# 네 기둥이 무엇인가요?\n\n- 이벤트 핸들러.\n- MarkForChanges 관리.\n- 비동기 파이프.\n- 시그널.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 이벤트 핸들러 :\n\n앵귤러의 이벤트 핸들러는 템플릿의 이벤트에 바인딩된 컴포넌트 클래스 내의 메서드입니다.\n\n```js\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  template: '\u003cbutton (click)=\"onClick()\"\u003e{state}\u003c/button\u003e'\n})\nexport class AppComponent {\n state = \"Click Me\";\n  onClick() {\n    this.state = \"Clicked\";\n  }\n}\n```\n\n## MarkForChanges 관리하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앵귤러에서, markForCheck은 앵귤러의 기본 변경 감지가 변경 사항을 감지하지 못하는 시나리오에서 사용됩니다. 이는 OnPush 변경 감지 전략 및 지금은 zoneless에서 일반적입니다.\n\n```js\nimport { ChangeDetectorRef, Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  template: `\n      {data}\n      \u003cbutton (click)=\"update()\"\u003eUpdate\u003c/button\u003e\n     `,\n})\nexport class AppComponent {\n  data = '초기 데이터';\n\n  constructor(private cdr: ChangeDetectorRef) { }\n\n  update() {\n    this.data = '업데이트된 데이터';\n    this.cdr.markForCheck();\n  }\n}\n```\n\n## Async 파이프 :\n\n앵귤러의 AsyncPipe는 Observable 또는 Promise에 자동으로 구독하고 최신 값을 반환합니다. 또한 컴포넌트가 파괴될 때 자동으로 구독을 해제합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component, inject } from '@angular/core';\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { Observable, of } from 'rxjs';\nimport 'zone.js';\n@Component({\n  selector: 'app-root',\n  standalone: true,\n  template: `\n     Hello world\n     {data$ | async }\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  imports: [CommonModule],\n})\nexport class App {\n  name = 'Angular';\n  data$: Observable\u003cstring\u003e | undefined;\n  cRef = inject(ChangeDetectorRef);\n\n  constructor() {\n    setTimeout(() =\u003e {\n      this.data$ = of('Hello, AsyncPipe!');\n      this.cRef.markForCheck();\n    }, 4000);\n  }\n}\n\nbootstrapApplication(App);\n```\n\n## Signals:\n\nAngular에 Signals가 포함되어 정말 기쁩니다. 이전에는 불필요한 다시 렌더링 오버헤드를 극복하기 위해 신호를 사용해야 했습니다. 또한 이제 더 선언적 프로그래밍 스타일로 코드를 작성할 수 있고, 대부분의 주요 API는 Signals과 호환됩니다. 이것은 반응성을 위해 더 이상 RxJS에 의존하지 않아도 된다는 것을 의미합니다.\n\n```js\nimport { Component } from '@angular/core';\nimport { Signal, createSignal } from '@angular/core/signals';\n\n@Component({\n  selector: 'app-counter',\n  standalone: true,\n  template: `\n    \u003cdiv class=\"counter\"\u003e\n      \u003ch1\u003eCounter: { count.value }\u003c/h1\u003e\n      \u003cbutton (click)=\"decrement()\"\u003e-\u003c/button\u003e\n      \u003cbutton (click)=\"increment()\"\u003e+\u003c/button\u003e\n    \u003c/div\u003e\n  `,\n  styles: [`\n    .counter {\n      text-align: center;\n      margin-top: 50px;\n    }\n    button {\n      margin: 0 5px;\n      padding: 10px;\n      font-size: 16px;\n    }\n  `]\n})\nexport class CounterComponent {\n  // Count 상태를 관리하기 위한 Signal 생성\n  count: Signal\u003cnumber\u003e = createSignal(0);\n\n  // Count 증가 메소드\n  increment() {\n    this.count.set(this.count.value + 1);\n  }\n\n  // Count 감소 메소드\n  decrement() {\n    this.count.set(this.count.value - 1);\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"markForCheck\" 또는 수동 변경 감지가 필요하지 않습니다.\n\n신호 패턴 때문에 수동 변경 감지 확인이 필요하지 않습니다. 수동 코드 작성 부담이 줄어들고, Angular 팀은 Input/Output, ViewChild 및 기타 모든 API를 신호로 변환하고 있습니다.\n\n## 마지막 기둥:\n\nSSR은 Angular의 마지막 기둥입니다. 다음 포스트에서 계속합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론:\n\nAngular은 이제 시그널의 도입으로 올바른 방향으로 나아가고 있습니다. Angular를 지원하는 중요한 요소 가운데 시그널이 특히 두드러집니다. 시그널은 Angular 18에서 존리스 작업으로의 전환을 용이하게 하뿐만 아니라 불필요한 다시 렌더링과 수동 변경 감지 확인의 부담으로부터 자유로움을 제공합니다. 이 방식은 성능을 향상시키는 것뿐만 아니라 더 선언적인 코딩 스타일을 촉진합니다.\n\n서버 측 렌더링(SSR)은 Angular의 중요한 측면으로 남아 있으며, 제가 이후에 다룰 것입니다. 이 네 가지 중요한 요소인 이벤트 핸들러, MarkForChanges 관리, 비동기 파이프, 그리고 시그널을 계속 탐험하면 코드를 더 읽기 쉽고 간단하게 만드는 데 기여하는 방법을 발견할 것입니다.\n\n즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png"},"coverImage":"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_0.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e\"동의하지 않을 수도 있지만, 저는 Angular이 존리스(zoneless)가 되길 원했고 실현될 줄은 상상도 못 했습니다. 이제 실험 모드로 Angular 18에서 사용할 수 있습니다. 제발 프로덕션 환경에서 사용하지 마십시오.\"\u003c/p\u003e\n\u003ch1\u003e존리스(zoneless)란?\u003c/h1\u003e\n\u003cp\u003e네, 맞습니다. Angular의 존리스 설정에서 Angular 스케줄러는 컴포넌트 내에서 무언가 변경되었을 때 변경 감지를 자동으로 트리거하지 않습니다. 대신 Angular의 ChangeDetectorRef 서비스를 사용하여 변경 감지를 수동으로 트리거해야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기 간단한 설명이 있어요:\u003c/p\u003e\n\u003cp\u003eZone.js를 사용하는 기존 Angular 애플리케이션에서는 Angular이 모든 비동기 작업(HTTP 요청, setTimeout, 사용자 상호작용 등)이 완료될 때 자동으로 변경 감지를 트리거합니다. Zone.js는 이러한 비동기 작업들을 monkey-patch하여 Angular에게 변경 감지를 실행할 때 알리게 합니다.\u003c/p\u003e\n\u003cp\u003e우리가 무언가를 요리했다고 생각하실 지도 모르겠지만, 네 개의 기둥은 어디에 있을까요? 🧐\u003c/p\u003e\n\u003cp\u003e우선, Angular 18의 zoneless API를 확인하는 설정을 해야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e설치.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eng install @angular/cli@^\u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e새 앱 만들기\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eng \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e zoneless-app\ncd zoneless-app\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eapp.config.ts 파일이나 애플리케이션 부트스트랩 파일로 이동하세요.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eApplicationConfig\u003c/span\u003e, provideExperimentalZonelessChangeDetection, provideZoneChangeDetection } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { provideRouter } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/router'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { routes } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./app.routes'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eappConfig\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eApplicationConfig\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eproviders\u003c/span\u003e: [\u003cspan class=\"hljs-title function_\"\u003eprovideExperimentalZonelessChangeDetection\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003eprovideRouter\u003c/span\u003e(routes)]\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eangular.json의 폴리필에서 zone.js를 제거하세요.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cimg src=\"/assets/img/2024-06-27-Angular18ZonelessExploringthePillars_1.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 모든 설정이 완료되었으니 애플리케이션을 실행하면 됩니다.\u003c/p\u003e\n\u003cp\u003e이제 이 설정 이후에는 Angular가 자동으로 변경 감지를 트리거하지 않습니다.\u003c/p\u003e\n\u003ch1\u003e왜 zoneless를 사용해야 하는가? .\u003c/h1\u003e\n\u003cp\u003e불필요한 변경 감지를 피하기 위해서 간단하게 제안드립니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e모든 컴포넌트의 비동기 작업이 발생할 때 Angular는 루트부터 모든 하위 컴포넌트를 확인하는데, 이는 비효율적일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\"changeDetection\" 전략 \"OnPush\"를 사용하여 이 문제를 극복할 수 있는 옵션이 있습니다. 이는 컴포넌트와 해당 모든 하위 컴포넌트를 일반 변경 감지 주기에서 격리시킵니다.\u003c/p\u003e\n\u003ch1\u003e네 기둥이 무엇인가요?\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e이벤트 핸들러.\u003c/li\u003e\n\u003cli\u003eMarkForChanges 관리.\u003c/li\u003e\n\u003cli\u003e비동기 파이프.\u003c/li\u003e\n\u003cli\u003e시그널.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e이벤트 핸들러 :\u003c/h2\u003e\n\u003cp\u003e앵귤러의 이벤트 핸들러는 템플릿의 이벤트에 바인딩된 컴포넌트 클래스 내의 메서드입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-root'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;button (click)=\"onClick()\"\u003e{state}\u0026#x3C;/button\u003e'\u003c/span\u003e\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e {\n state = \u003cspan class=\"hljs-string\"\u003e\"Click Me\"\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003eonClick\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estate\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Clicked\"\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eMarkForChanges 관리하기:\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e앵귤러에서, markForCheck은 앵귤러의 기본 변경 감지가 변경 사항을 감지하지 못하는 시나리오에서 사용됩니다. 이는 OnPush 변경 감지 전략 및 지금은 zoneless에서 일반적입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eChangeDetectorRef\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-root'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\n      {data}\n      \u0026#x3C;button (click)=\"update()\"\u003eUpdate\u0026#x3C;/button\u003e\n     `\u003c/span\u003e,\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e {\n  data = \u003cspan class=\"hljs-string\"\u003e'초기 데이터'\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate cdr: ChangeDetectorRef\u003c/span\u003e) { }\n\n  \u003cspan class=\"hljs-title function_\"\u003eupdate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'업데이트된 데이터'\u003c/span\u003e;\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecdr\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emarkForCheck\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eAsync 파이프 :\u003c/h2\u003e\n\u003cp\u003e앵귤러의 AsyncPipe는 Observable 또는 Promise에 자동으로 구독하고 최신 값을 반환합니다. 또한 컴포넌트가 파괴될 때 자동으로 구독을 해제합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eCommonModule\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/common'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eChangeDetectionStrategy\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eChangeDetectorRef\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e, inject } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { bootstrapApplication } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/platform-browser'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'zone.js'\u003c/span\u003e;\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-root'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003estandalone\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\n     Hello world\n     {data$ | async }\n  `\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003echangeDetection\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eChangeDetectionStrategy\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eOnPush\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eimports\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eCommonModule\u003c/span\u003e],\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e {\n  name = \u003cspan class=\"hljs-string\"\u003e'Angular'\u003c/span\u003e;\n  \u003cspan class=\"hljs-attr\"\u003edata$\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e\u0026#x3C;string\u003e | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n  cRef = \u003cspan class=\"hljs-title function_\"\u003einject\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eChangeDetectorRef\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edata$\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Hello, AsyncPipe!'\u003c/span\u003e);\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecRef\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emarkForCheck\u003c/span\u003e();\n    }, \u003cspan class=\"hljs-number\"\u003e4000\u003c/span\u003e);\n  }\n}\n\n\u003cspan class=\"hljs-title function_\"\u003ebootstrapApplication\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eSignals:\u003c/h2\u003e\n\u003cp\u003eAngular에 Signals가 포함되어 정말 기쁩니다. 이전에는 불필요한 다시 렌더링 오버헤드를 극복하기 위해 신호를 사용해야 했습니다. 또한 이제 더 선언적 프로그래밍 스타일로 코드를 작성할 수 있고, 대부분의 주요 API는 Signals과 호환됩니다. 이것은 반응성을 위해 더 이상 RxJS에 의존하지 않아도 된다는 것을 의미합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eSignal\u003c/span\u003e, createSignal } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core/signals'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-counter'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003estandalone\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\n    \u0026#x3C;div class=\"counter\"\u003e\n      \u0026#x3C;h1\u003eCounter: { count.value }\u0026#x3C;/h1\u003e\n      \u0026#x3C;button (click)=\"decrement()\"\u003e-\u0026#x3C;/button\u003e\n      \u0026#x3C;button (click)=\"increment()\"\u003e+\u0026#x3C;/button\u003e\n    \u0026#x3C;/div\u003e\n  `\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003estyles\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e`\n    .counter {\n      text-align: center;\n      margin-top: 50px;\n    }\n    button {\n      margin: 0 5px;\n      padding: 10px;\n      font-size: 16px;\n    }\n  `\u003c/span\u003e]\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCounterComponent\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// Count 상태를 관리하기 위한 Signal 생성\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ecount\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSignal\u003c/span\u003e\u0026#x3C;number\u003e = \u003cspan class=\"hljs-title function_\"\u003ecreateSignal\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// Count 증가 메소드\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003eincrement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecount\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecount\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// Count 감소 메소드\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003edecrement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecount\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecount\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\"markForCheck\" 또는 수동 변경 감지가 필요하지 않습니다.\u003c/p\u003e\n\u003cp\u003e신호 패턴 때문에 수동 변경 감지 확인이 필요하지 않습니다. 수동 코드 작성 부담이 줄어들고, Angular 팀은 Input/Output, ViewChild 및 기타 모든 API를 신호로 변환하고 있습니다.\u003c/p\u003e\n\u003ch2\u003e마지막 기둥:\u003c/h2\u003e\n\u003cp\u003eSSR은 Angular의 마지막 기둥입니다. 다음 포스트에서 계속합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e결론:\u003c/h2\u003e\n\u003cp\u003eAngular은 이제 시그널의 도입으로 올바른 방향으로 나아가고 있습니다. Angular를 지원하는 중요한 요소 가운데 시그널이 특히 두드러집니다. 시그널은 Angular 18에서 존리스 작업으로의 전환을 용이하게 하뿐만 아니라 불필요한 다시 렌더링과 수동 변경 감지 확인의 부담으로부터 자유로움을 제공합니다. 이 방식은 성능을 향상시키는 것뿐만 아니라 더 선언적인 코딩 스타일을 촉진합니다.\u003c/p\u003e\n\u003cp\u003e서버 측 렌더링(SSR)은 Angular의 중요한 측면으로 남아 있으며, 제가 이후에 다룰 것입니다. 이 네 가지 중요한 요소인 이벤트 핸들러, MarkForChanges 관리, 비동기 파이프, 그리고 시그널을 계속 탐험하면 코드를 더 읽기 쉽고 간단하게 만드는 데 기여하는 방법을 발견할 것입니다.\u003c/p\u003e\n\u003cp\u003e즐거운 코딩되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-27-Angular18ZonelessExploringthePillars"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>