<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>DOM 트리의 일부 선택 인터뷰 문제 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="DOM 트리의 일부 선택 인터뷰 문제 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="DOM 트리의 일부 선택 인터뷰 문제 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion" data-gatsby-head="true"/><meta name="twitter:title" content="DOM 트리의 일부 선택 인터뷰 문제 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 21:13" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">DOM 트리의 일부 선택 인터뷰 문제</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="DOM 트리의 일부 선택 인터뷰 문제" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png" alt="DOM 트리의 일부 선택에 관한 인터뷰 질문"></p>
<p>웹 페이지의 일부를 선택하는 문제는 상당히 실용적이며, 웹 레이아웃과 DOM 트리 간의 변환과 관련이 있어 시각적으로 흥미로운 문제입니다.</p>
<p>이 문제는 웹 페이지의 일부를 선택하고 선택한 요소들을 모두 파악하여 화면에 표시된 순서대로 하나씩 나열하라는 내용입니다.</p>
<p>이 유형의 문제를 해본 적이 없다면, 그 순간에는 압도적일 수 있습니다. 그러므로 이 글에서는 이에 대해 천천히 공부해보려 합니다.</p>
<h2>웹 페이지 부분 선택</h2>
<p>부분 선택하는 것이 좀 tricky 하죠. 정확히 어떤 것을 말하는 걸까요?</p>
<p>모두가 아시다시피 페이지는 요소(element)로 이루어져 있습니다. 하나의 요소는 시각적인 요소일 수도 있고, 다른 요소들을 그룹화하는 요소일 수도 있습니다. 이것이 바로 DOM 트리라고 합니다.</p>
<p><img src="/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_1.png" alt="DOM 트리의 부분 선택"></p>
<p>간단히 하기 위해 위의 예시에서는 이진 트리를 사용했습니다. 하지만 실제로는 각 부모 아래 노드가 비어 있거나 하나, 두 개 이상의 요소를 포함할 수 있습니다. 이 질문의 첫 번째 과제는 위 트리를 웹 콘텐츠에 대응시키는 것입니다. 우리는 그렇게하는 일이 드물기 때문에 나무 노드에서 어떤 것이 무엇인지 명확하지 않아집니다. 그래서 웹 용어에 따라 노드에 레이블을 붙여 보겠습니다:</p>
<p><img src="/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_2.png" alt="DOM tree image"></p>
<p>body 태그에서 시작합니다 (원한다면 html에서 시작할 수도 있어요 :). 그리고 페이지에는 헤더와 본문 두 섹션이 있습니다. 헤더를 예로 들면, 가로로 두 개의 div 태그가 있습니다. 그 중 하나에는 링크 태그로 래핑된 이미지 로고가 있습니다. 이것이 전형적인 헤더입니다. 비슷하게, 본문 섹션을 살펴보면, 하나의 article과 참고 자료 목록이 있습니다. article 안에는 컨텐츠 안에 있는 저자 이름이 들어 있는 중첩된 span이 있습니다. 그래서, 이제 이 웹 페이지의 올바른 정신적 이미지를 가졌으면 좋겠네요.</p>
<p>트리의 위상 구조는 페이지의 레이아웃으로 잘 번역되지 않을 수 있습니다. 이것은 레이아웃이 위에서 아래로 이동하거나 왼쪽에서 오른쪽으로 이동할 수도 있고, CSS가 순서를 뒤집을 수도 있기 때문입니다. 반면에, DOM 트리 노드 표현은 한 가지 패턴으로만 이동할 수 있습니다: 부모로 들어가면 여러 자식을 볼 수 있고, 자식 안에는 자식의 자식을 볼 수 있습니다. 이 두 가지 시스템을 머리 속에서 동시에 운영하는 데 시간이 조금 필요할 수 있습니다.</p>
<p>질문은 페이지의 일부를 선택하도록 우리에게 요청했습니다. 페이지의 로고에서 마우스를 드래그하여 기사의 작성자 이름에 놓는 것을 원한다고 가정해 봅시다. 먼저 요구 사항에서 생각해 봅시다. 우리가 실제로 무엇을 선택했나요?</p>
<p>우리는 헤더 섹션에서 시작해서 본문 섹션에서 끝났습니다. 그래서 헤더 섹션에서 일부를 선택하고 본문 섹션에서 일부를 선택했습니다. 모두 부분적인 선택이라는 이유는 어떤 것도 완전한 선택을 받지 못했기 때문입니다. 이제 질문은 DOM 표현에서 부분적인 선택이 무엇인지 묻습니다.</p>
<p>다음 강조부분에서 살펴보겠습니다:</p>
<p><img src="/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_3.png" alt="Partial selection of a DOM tree: An interview question"></p>
<p>아마도 일부 노드에는 시각적인 표현이 없을 것이라고 생각할 수 있습니다. 이 경우, 부모 노드(잎이 아닌)가 선택되지 않을 것이라고 가정한다면 main, article 및 마지막 div 노드를 숨길 수 있습니다. 기본적으로 오직 잎 노드만 표시될 수 있으므로 사용자가 볼 수 있는 것입니다.</p>
<p>어차피, 어떤 변화던 주제가 크게 달라지지 않아야 합니다. 따라서 이 기사에서는 여전히 부모가 먼저 강조된 기본 버전에 대해 이야기합니다. 우리의 변명은 부모 노드(또는 startProcess)에서 시각적 표시가 전달될 수 있기 때문입니다.</p>
<h2>DOM 노드의 트리 순회</h2>
<p>질문을 받기 전에 위의 그림을 보았다면, 아마도 어느 정도 여유를 가지고 질문에 대답할 수 있을 것입니다. 나머지는 주로 우리가 알고리즘 코더로서 훈련받은 방법입니다.</p>
<p>트리 순회에 대해 이야기할 때, 주로 두 가지 패턴이 있습니다: 깊이 우선과 너비 우선입니다. 웹 페이지 표시는 깊이 우선 탐색으로 이루어집니다. 왜냐하면 우리는 body로 들어가고, 그리고 header로 들어가기 때문에 header가 표시되기 전에 main을 표시할 필요가 없습니다.</p>
<p>이것은 한 조각의 내용을 가능한 한 자세히 공개하고 나서 다른 조각의 내용을 표시하려고 합니다. 레이아웃 관점에서 다음(또는 다른) 요소는 일반적으로 형제 노드입니다.</p>
<p>먼저 자식을 다음으로 형제를, 이것이 깊이 우선 탐색입니다. 이것은 재귀 알고리즘을 사용하여 수행할 수 있다는 것을 의미합니다. 이것은 프로그래밍을 다소 쉽게 만들어주며, 스택을 사용할 필요가 없으므로 중첩 함수 호출이면 충분합니다.</p>
<p>다음으로, 중위/전위/후위 순서는 혼동스러울 수 있습니다. 기본적으로 우리의 경우에는 각 요소에 도달한 후에 노드 이름을 표시하고, 그런 다음 자식 요소로 깊숙이 파고들 수 있도록 전위 순서인 경우가 될 수 있습니다: 먼저 이름을 수집하고 나서 자식 요소로 깊숙히 들어갑니다.</p>
<pre><code class="hljs language-js">body -> header -> div -> p -> em
-> div -> a -> <span class="hljs-title function_">img</span>(*) -> a
-> main -> article -> p -> div -> <span class="hljs-title function_">span</span>(*)
-> ul -> li -> li
</code></pre>
<p>위에 전위 순서로 인쇄된 트리 이동 목록이 있습니다. 이 목록에서 img와 span을 확인할 수 있고, 그것이 우리의 대답입니다. 이동할 때 기본적으로 img를 만나면 노드를 기록하기 시작하고 span을 감지할 때까지 마무리할 수 있습니다. 왜냐하면 img와 span 둘 다 질문의 입력이어야 하기 때문입니다. 여기서 마우스 동작(예: onDragStart)이 감지됩니다.</p>
<p>잎 노드에만 초점을 맞추려면 잎이 아닌 노드를 수집하지 않는 것을 건너뛸 수 있으며, 이렇게 할 경우 다음 목록을 얻을 수 있습니다:</p>
<pre><code class="hljs language-js">p -> em -> <span class="hljs-title function_">img</span>(*) -> a
-> p -> <span class="hljs-title function_">span</span>(*) -> li -> li
</code></pre>
<p>우리는 다양한 변형이 가능할 거라고 가정할 수 있어요. 예를 들어, 무엇인가의 이유로 형제로 이동하기 전에 부모를 다시 방문해야 하는 경우가 있다면, 기술적으로 부모에게 끝내기 작업을 의존해야 하는 경우일 수도 있어요 (예: endProcess). 심지어  postorder 순회도 할 수 있어요:</p>
<pre><code class="hljs language-js">p -> em -> div -> <span class="hljs-title function_">img</span>(*) -> a -> a -> div -> header
-> p -> <span class="hljs-title function_">span</span>(*) -> div -> article
-> li -> li -> ul -> main -> body
</code></pre>
<p>위 목록에서 부모(잎이 아닌 것)를 숨겨서 이전에 얻은 답변을 얻을 수도 있어요. 완성을 위해, 여기에 inorder 순회에 대한 인쇄결과가 있어요:</p>
<pre><code class="hljs language-js">p -> div -> em -> header
-> <span class="hljs-title function_">img</span>(*) -> a -> div -> a -> body
-> p -> article -> <span class="hljs-title function_">span</span>(*) -> div -> main
-> li -> ul -> li
</code></pre>
<p>어떤 문제에 inorder가 어떻게 도움이 될지 정확히는 모르겠지만, 어쨌든 특별한 용도가 있을지도 몰라요.</p>
<p>따라서 특정 시점에 노드를 처리해야 할 필요가 있다면, 트리를 다른 방식으로 순회할 수도 있어요. 하지만 결국 이는 깊이 우선 탐색이기 때문에 무엇이든지, 올바른 답변에 가까워질 것이에요.</p>
<p><img src="/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_4.png" alt="이미지"></p>
<h1>결론</h1>
<p>웹 페이지의 일부를 선택하는 것은 이해하기 어려울 수 있지만, 중요한 것은 어떤 노드가 어떤 내용 조각에 매핑되는지 위상적인 방식으로 알아내는 것입니다. 그 후에는 트리 순회 작업의 문제입니다.</p>
<h1>쉽게 이해하기 🚀</h1>
<p>In Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:</p>
<ul>
<li>작가를 박수로 응원하고 팔로우해주세요 ️👏️️</li>
<li>팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터</li>
<li>다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed</li>
<li>알고리즘 콘텐츠를 다루어야 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요</li>
<li>PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"DOM 트리의 일부 선택 인터뷰 문제","description":"","date":"2024-05-12 21:13","slug":"2024-05-12-PartialselectionofaDOMtreeAninterviewquestion","content":"\n\n\n![DOM 트리의 일부 선택에 관한 인터뷰 질문](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png)\n\n웹 페이지의 일부를 선택하는 문제는 상당히 실용적이며, 웹 레이아웃과 DOM 트리 간의 변환과 관련이 있어 시각적으로 흥미로운 문제입니다.\n\n이 문제는 웹 페이지의 일부를 선택하고 선택한 요소들을 모두 파악하여 화면에 표시된 순서대로 하나씩 나열하라는 내용입니다.\n\n이 유형의 문제를 해본 적이 없다면, 그 순간에는 압도적일 수 있습니다. 그러므로 이 글에서는 이에 대해 천천히 공부해보려 합니다.\n\n\n\n## 웹 페이지 부분 선택\n\n부분 선택하는 것이 좀 tricky 하죠. 정확히 어떤 것을 말하는 걸까요?\n\n모두가 아시다시피 페이지는 요소(element)로 이루어져 있습니다. 하나의 요소는 시각적인 요소일 수도 있고, 다른 요소들을 그룹화하는 요소일 수도 있습니다. 이것이 바로 DOM 트리라고 합니다.\n\n![DOM 트리의 부분 선택](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_1.png)\n\n\n\n간단히 하기 위해 위의 예시에서는 이진 트리를 사용했습니다. 하지만 실제로는 각 부모 아래 노드가 비어 있거나 하나, 두 개 이상의 요소를 포함할 수 있습니다. 이 질문의 첫 번째 과제는 위 트리를 웹 콘텐츠에 대응시키는 것입니다. 우리는 그렇게하는 일이 드물기 때문에 나무 노드에서 어떤 것이 무엇인지 명확하지 않아집니다. 그래서 웹 용어에 따라 노드에 레이블을 붙여 보겠습니다:\n\n![DOM tree image](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_2.png)\n\nbody 태그에서 시작합니다 (원한다면 html에서 시작할 수도 있어요 :). 그리고 페이지에는 헤더와 본문 두 섹션이 있습니다. 헤더를 예로 들면, 가로로 두 개의 div 태그가 있습니다. 그 중 하나에는 링크 태그로 래핑된 이미지 로고가 있습니다. 이것이 전형적인 헤더입니다. 비슷하게, 본문 섹션을 살펴보면, 하나의 article과 참고 자료 목록이 있습니다. article 안에는 컨텐츠 안에 있는 저자 이름이 들어 있는 중첩된 span이 있습니다. 그래서, 이제 이 웹 페이지의 올바른 정신적 이미지를 가졌으면 좋겠네요.\n\n트리의 위상 구조는 페이지의 레이아웃으로 잘 번역되지 않을 수 있습니다. 이것은 레이아웃이 위에서 아래로 이동하거나 왼쪽에서 오른쪽으로 이동할 수도 있고, CSS가 순서를 뒤집을 수도 있기 때문입니다. 반면에, DOM 트리 노드 표현은 한 가지 패턴으로만 이동할 수 있습니다: 부모로 들어가면 여러 자식을 볼 수 있고, 자식 안에는 자식의 자식을 볼 수 있습니다. 이 두 가지 시스템을 머리 속에서 동시에 운영하는 데 시간이 조금 필요할 수 있습니다.\n\n\n\n질문은 페이지의 일부를 선택하도록 우리에게 요청했습니다. 페이지의 로고에서 마우스를 드래그하여 기사의 작성자 이름에 놓는 것을 원한다고 가정해 봅시다. 먼저 요구 사항에서 생각해 봅시다. 우리가 실제로 무엇을 선택했나요?\n\n우리는 헤더 섹션에서 시작해서 본문 섹션에서 끝났습니다. 그래서 헤더 섹션에서 일부를 선택하고 본문 섹션에서 일부를 선택했습니다. 모두 부분적인 선택이라는 이유는 어떤 것도 완전한 선택을 받지 못했기 때문입니다. 이제 질문은 DOM 표현에서 부분적인 선택이 무엇인지 묻습니다.\n\n다음 강조부분에서 살펴보겠습니다:\n\n![Partial selection of a DOM tree: An interview question](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_3.png)\n\n\n\n아마도 일부 노드에는 시각적인 표현이 없을 것이라고 생각할 수 있습니다. 이 경우, 부모 노드(잎이 아닌)가 선택되지 않을 것이라고 가정한다면 main, article 및 마지막 div 노드를 숨길 수 있습니다. 기본적으로 오직 잎 노드만 표시될 수 있으므로 사용자가 볼 수 있는 것입니다.\n\n어차피, 어떤 변화던 주제가 크게 달라지지 않아야 합니다. 따라서 이 기사에서는 여전히 부모가 먼저 강조된 기본 버전에 대해 이야기합니다. 우리의 변명은 부모 노드(또는 startProcess)에서 시각적 표시가 전달될 수 있기 때문입니다.\n\n## DOM 노드의 트리 순회\n\n질문을 받기 전에 위의 그림을 보았다면, 아마도 어느 정도 여유를 가지고 질문에 대답할 수 있을 것입니다. 나머지는 주로 우리가 알고리즘 코더로서 훈련받은 방법입니다.\n\n\n\n트리 순회에 대해 이야기할 때, 주로 두 가지 패턴이 있습니다: 깊이 우선과 너비 우선입니다. 웹 페이지 표시는 깊이 우선 탐색으로 이루어집니다. 왜냐하면 우리는 body로 들어가고, 그리고 header로 들어가기 때문에 header가 표시되기 전에 main을 표시할 필요가 없습니다.\n\n이것은 한 조각의 내용을 가능한 한 자세히 공개하고 나서 다른 조각의 내용을 표시하려고 합니다. 레이아웃 관점에서 다음(또는 다른) 요소는 일반적으로 형제 노드입니다.\n\n먼저 자식을 다음으로 형제를, 이것이 깊이 우선 탐색입니다. 이것은 재귀 알고리즘을 사용하여 수행할 수 있다는 것을 의미합니다. 이것은 프로그래밍을 다소 쉽게 만들어주며, 스택을 사용할 필요가 없으므로 중첩 함수 호출이면 충분합니다.\n\n다음으로, 중위/전위/후위 순서는 혼동스러울 수 있습니다. 기본적으로 우리의 경우에는 각 요소에 도달한 후에 노드 이름을 표시하고, 그런 다음 자식 요소로 깊숙이 파고들 수 있도록 전위 순서인 경우가 될 수 있습니다: 먼저 이름을 수집하고 나서 자식 요소로 깊숙히 들어갑니다.\n\n\n\n```js\nbody -\u003e header -\u003e div -\u003e p -\u003e em\n-\u003e div -\u003e a -\u003e img(*) -\u003e a\n-\u003e main -\u003e article -\u003e p -\u003e div -\u003e span(*)\n-\u003e ul -\u003e li -\u003e li\n```\n\n위에 전위 순서로 인쇄된 트리 이동 목록이 있습니다. 이 목록에서 img와 span을 확인할 수 있고, 그것이 우리의 대답입니다. 이동할 때 기본적으로 img를 만나면 노드를 기록하기 시작하고 span을 감지할 때까지 마무리할 수 있습니다. 왜냐하면 img와 span 둘 다 질문의 입력이어야 하기 때문입니다. 여기서 마우스 동작(예: onDragStart)이 감지됩니다.\n\n잎 노드에만 초점을 맞추려면 잎이 아닌 노드를 수집하지 않는 것을 건너뛸 수 있으며, 이렇게 할 경우 다음 목록을 얻을 수 있습니다:\n\n```js\np -\u003e em -\u003e img(*) -\u003e a\n-\u003e p -\u003e span(*) -\u003e li -\u003e li\n```\n\n\n\n우리는 다양한 변형이 가능할 거라고 가정할 수 있어요. 예를 들어, 무엇인가의 이유로 형제로 이동하기 전에 부모를 다시 방문해야 하는 경우가 있다면, 기술적으로 부모에게 끝내기 작업을 의존해야 하는 경우일 수도 있어요 (예: endProcess). 심지어  postorder 순회도 할 수 있어요:\n\n```js\np -\u003e em -\u003e div -\u003e img(*) -\u003e a -\u003e a -\u003e div -\u003e header\n-\u003e p -\u003e span(*) -\u003e div -\u003e article\n-\u003e li -\u003e li -\u003e ul -\u003e main -\u003e body\n```\n\n위 목록에서 부모(잎이 아닌 것)를 숨겨서 이전에 얻은 답변을 얻을 수도 있어요. 완성을 위해, 여기에 inorder 순회에 대한 인쇄결과가 있어요:\n\n```js\np -\u003e div -\u003e em -\u003e header\n-\u003e img(*) -\u003e a -\u003e div -\u003e a -\u003e body\n-\u003e p -\u003e article -\u003e span(*) -\u003e div -\u003e main\n-\u003e li -\u003e ul -\u003e li\n```\n\n\n\n어떤 문제에 inorder가 어떻게 도움이 될지 정확히는 모르겠지만, 어쨌든 특별한 용도가 있을지도 몰라요.\n\n따라서 특정 시점에 노드를 처리해야 할 필요가 있다면, 트리를 다른 방식으로 순회할 수도 있어요. 하지만 결국 이는 깊이 우선 탐색이기 때문에 무엇이든지, 올바른 답변에 가까워질 것이에요.\n\n![이미지](/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_4.png)\n\n# 결론\n\n\n\n웹 페이지의 일부를 선택하는 것은 이해하기 어려울 수 있지만, 중요한 것은 어떤 노드가 어떤 내용 조각에 매핑되는지 위상적인 방식으로 알아내는 것입니다. 그 후에는 트리 순회 작업의 문제입니다.\n\n# 쉽게 이해하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우해주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루어야 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png"},"coverImage":"/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_0.png\" alt=\"DOM 트리의 일부 선택에 관한 인터뷰 질문\"\u003e\u003c/p\u003e\n\u003cp\u003e웹 페이지의 일부를 선택하는 문제는 상당히 실용적이며, 웹 레이아웃과 DOM 트리 간의 변환과 관련이 있어 시각적으로 흥미로운 문제입니다.\u003c/p\u003e\n\u003cp\u003e이 문제는 웹 페이지의 일부를 선택하고 선택한 요소들을 모두 파악하여 화면에 표시된 순서대로 하나씩 나열하라는 내용입니다.\u003c/p\u003e\n\u003cp\u003e이 유형의 문제를 해본 적이 없다면, 그 순간에는 압도적일 수 있습니다. 그러므로 이 글에서는 이에 대해 천천히 공부해보려 합니다.\u003c/p\u003e\n\u003ch2\u003e웹 페이지 부분 선택\u003c/h2\u003e\n\u003cp\u003e부분 선택하는 것이 좀 tricky 하죠. 정확히 어떤 것을 말하는 걸까요?\u003c/p\u003e\n\u003cp\u003e모두가 아시다시피 페이지는 요소(element)로 이루어져 있습니다. 하나의 요소는 시각적인 요소일 수도 있고, 다른 요소들을 그룹화하는 요소일 수도 있습니다. 이것이 바로 DOM 트리라고 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_1.png\" alt=\"DOM 트리의 부분 선택\"\u003e\u003c/p\u003e\n\u003cp\u003e간단히 하기 위해 위의 예시에서는 이진 트리를 사용했습니다. 하지만 실제로는 각 부모 아래 노드가 비어 있거나 하나, 두 개 이상의 요소를 포함할 수 있습니다. 이 질문의 첫 번째 과제는 위 트리를 웹 콘텐츠에 대응시키는 것입니다. 우리는 그렇게하는 일이 드물기 때문에 나무 노드에서 어떤 것이 무엇인지 명확하지 않아집니다. 그래서 웹 용어에 따라 노드에 레이블을 붙여 보겠습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_2.png\" alt=\"DOM tree image\"\u003e\u003c/p\u003e\n\u003cp\u003ebody 태그에서 시작합니다 (원한다면 html에서 시작할 수도 있어요 :). 그리고 페이지에는 헤더와 본문 두 섹션이 있습니다. 헤더를 예로 들면, 가로로 두 개의 div 태그가 있습니다. 그 중 하나에는 링크 태그로 래핑된 이미지 로고가 있습니다. 이것이 전형적인 헤더입니다. 비슷하게, 본문 섹션을 살펴보면, 하나의 article과 참고 자료 목록이 있습니다. article 안에는 컨텐츠 안에 있는 저자 이름이 들어 있는 중첩된 span이 있습니다. 그래서, 이제 이 웹 페이지의 올바른 정신적 이미지를 가졌으면 좋겠네요.\u003c/p\u003e\n\u003cp\u003e트리의 위상 구조는 페이지의 레이아웃으로 잘 번역되지 않을 수 있습니다. 이것은 레이아웃이 위에서 아래로 이동하거나 왼쪽에서 오른쪽으로 이동할 수도 있고, CSS가 순서를 뒤집을 수도 있기 때문입니다. 반면에, DOM 트리 노드 표현은 한 가지 패턴으로만 이동할 수 있습니다: 부모로 들어가면 여러 자식을 볼 수 있고, 자식 안에는 자식의 자식을 볼 수 있습니다. 이 두 가지 시스템을 머리 속에서 동시에 운영하는 데 시간이 조금 필요할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e질문은 페이지의 일부를 선택하도록 우리에게 요청했습니다. 페이지의 로고에서 마우스를 드래그하여 기사의 작성자 이름에 놓는 것을 원한다고 가정해 봅시다. 먼저 요구 사항에서 생각해 봅시다. 우리가 실제로 무엇을 선택했나요?\u003c/p\u003e\n\u003cp\u003e우리는 헤더 섹션에서 시작해서 본문 섹션에서 끝났습니다. 그래서 헤더 섹션에서 일부를 선택하고 본문 섹션에서 일부를 선택했습니다. 모두 부분적인 선택이라는 이유는 어떤 것도 완전한 선택을 받지 못했기 때문입니다. 이제 질문은 DOM 표현에서 부분적인 선택이 무엇인지 묻습니다.\u003c/p\u003e\n\u003cp\u003e다음 강조부분에서 살펴보겠습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_3.png\" alt=\"Partial selection of a DOM tree: An interview question\"\u003e\u003c/p\u003e\n\u003cp\u003e아마도 일부 노드에는 시각적인 표현이 없을 것이라고 생각할 수 있습니다. 이 경우, 부모 노드(잎이 아닌)가 선택되지 않을 것이라고 가정한다면 main, article 및 마지막 div 노드를 숨길 수 있습니다. 기본적으로 오직 잎 노드만 표시될 수 있으므로 사용자가 볼 수 있는 것입니다.\u003c/p\u003e\n\u003cp\u003e어차피, 어떤 변화던 주제가 크게 달라지지 않아야 합니다. 따라서 이 기사에서는 여전히 부모가 먼저 강조된 기본 버전에 대해 이야기합니다. 우리의 변명은 부모 노드(또는 startProcess)에서 시각적 표시가 전달될 수 있기 때문입니다.\u003c/p\u003e\n\u003ch2\u003eDOM 노드의 트리 순회\u003c/h2\u003e\n\u003cp\u003e질문을 받기 전에 위의 그림을 보았다면, 아마도 어느 정도 여유를 가지고 질문에 대답할 수 있을 것입니다. 나머지는 주로 우리가 알고리즘 코더로서 훈련받은 방법입니다.\u003c/p\u003e\n\u003cp\u003e트리 순회에 대해 이야기할 때, 주로 두 가지 패턴이 있습니다: 깊이 우선과 너비 우선입니다. 웹 페이지 표시는 깊이 우선 탐색으로 이루어집니다. 왜냐하면 우리는 body로 들어가고, 그리고 header로 들어가기 때문에 header가 표시되기 전에 main을 표시할 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003e이것은 한 조각의 내용을 가능한 한 자세히 공개하고 나서 다른 조각의 내용을 표시하려고 합니다. 레이아웃 관점에서 다음(또는 다른) 요소는 일반적으로 형제 노드입니다.\u003c/p\u003e\n\u003cp\u003e먼저 자식을 다음으로 형제를, 이것이 깊이 우선 탐색입니다. 이것은 재귀 알고리즘을 사용하여 수행할 수 있다는 것을 의미합니다. 이것은 프로그래밍을 다소 쉽게 만들어주며, 스택을 사용할 필요가 없으므로 중첩 함수 호출이면 충분합니다.\u003c/p\u003e\n\u003cp\u003e다음으로, 중위/전위/후위 순서는 혼동스러울 수 있습니다. 기본적으로 우리의 경우에는 각 요소에 도달한 후에 노드 이름을 표시하고, 그런 다음 자식 요소로 깊숙이 파고들 수 있도록 전위 순서인 경우가 될 수 있습니다: 먼저 이름을 수집하고 나서 자식 요소로 깊숙히 들어갑니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ebody -\u003e header -\u003e div -\u003e p -\u003e em\n-\u003e div -\u003e a -\u003e \u003cspan class=\"hljs-title function_\"\u003eimg\u003c/span\u003e(*) -\u003e a\n-\u003e main -\u003e article -\u003e p -\u003e div -\u003e \u003cspan class=\"hljs-title function_\"\u003espan\u003c/span\u003e(*)\n-\u003e ul -\u003e li -\u003e li\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위에 전위 순서로 인쇄된 트리 이동 목록이 있습니다. 이 목록에서 img와 span을 확인할 수 있고, 그것이 우리의 대답입니다. 이동할 때 기본적으로 img를 만나면 노드를 기록하기 시작하고 span을 감지할 때까지 마무리할 수 있습니다. 왜냐하면 img와 span 둘 다 질문의 입력이어야 하기 때문입니다. 여기서 마우스 동작(예: onDragStart)이 감지됩니다.\u003c/p\u003e\n\u003cp\u003e잎 노드에만 초점을 맞추려면 잎이 아닌 노드를 수집하지 않는 것을 건너뛸 수 있으며, 이렇게 할 경우 다음 목록을 얻을 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ep -\u003e em -\u003e \u003cspan class=\"hljs-title function_\"\u003eimg\u003c/span\u003e(*) -\u003e a\n-\u003e p -\u003e \u003cspan class=\"hljs-title function_\"\u003espan\u003c/span\u003e(*) -\u003e li -\u003e li\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 다양한 변형이 가능할 거라고 가정할 수 있어요. 예를 들어, 무엇인가의 이유로 형제로 이동하기 전에 부모를 다시 방문해야 하는 경우가 있다면, 기술적으로 부모에게 끝내기 작업을 의존해야 하는 경우일 수도 있어요 (예: endProcess). 심지어  postorder 순회도 할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ep -\u003e em -\u003e div -\u003e \u003cspan class=\"hljs-title function_\"\u003eimg\u003c/span\u003e(*) -\u003e a -\u003e a -\u003e div -\u003e header\n-\u003e p -\u003e \u003cspan class=\"hljs-title function_\"\u003espan\u003c/span\u003e(*) -\u003e div -\u003e article\n-\u003e li -\u003e li -\u003e ul -\u003e main -\u003e body\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 목록에서 부모(잎이 아닌 것)를 숨겨서 이전에 얻은 답변을 얻을 수도 있어요. 완성을 위해, 여기에 inorder 순회에 대한 인쇄결과가 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ep -\u003e div -\u003e em -\u003e header\n-\u003e \u003cspan class=\"hljs-title function_\"\u003eimg\u003c/span\u003e(*) -\u003e a -\u003e div -\u003e a -\u003e body\n-\u003e p -\u003e article -\u003e \u003cspan class=\"hljs-title function_\"\u003espan\u003c/span\u003e(*) -\u003e div -\u003e main\n-\u003e li -\u003e ul -\u003e li\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e어떤 문제에 inorder가 어떻게 도움이 될지 정확히는 모르겠지만, 어쨌든 특별한 용도가 있을지도 몰라요.\u003c/p\u003e\n\u003cp\u003e따라서 특정 시점에 노드를 처리해야 할 필요가 있다면, 트리를 다른 방식으로 순회할 수도 있어요. 하지만 결국 이는 깊이 우선 탐색이기 때문에 무엇이든지, 올바른 답변에 가까워질 것이에요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-PartialselectionofaDOMtreeAninterviewquestion_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e웹 페이지의 일부를 선택하는 것은 이해하기 어려울 수 있지만, 중요한 것은 어떤 노드가 어떤 내용 조각에 매핑되는지 위상적인 방식으로 알아내는 것입니다. 그 후에는 트리 순회 작업의 문제입니다.\u003c/p\u003e\n\u003ch1\u003e쉽게 이해하기 🚀\u003c/h1\u003e\n\u003cp\u003eIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작가를 박수로 응원하고 팔로우해주세요 ️👏️️\u003c/li\u003e\n\u003cli\u003e팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\u003c/li\u003e\n\u003cli\u003e다른 플랫폼 방문: Stackademic | CoFeed | Venture | Cubed\u003c/li\u003e\n\u003cli\u003e알고리즘 콘텐츠를 다루어야 하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\u003c/li\u003e\n\u003cli\u003ePlainEnglish.io에서 더 많은 콘텐츠를 만나보세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-PartialselectionofaDOMtreeAninterviewquestion"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>