<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>TypeScript 데코레이터란 무엇이며, 데코레이터를 사용하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="TypeScript 데코레이터란 무엇이며, 데코레이터를 사용하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="TypeScript 데코레이터란 무엇이며, 데코레이터를 사용하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators" data-gatsby-head="true"/><meta name="twitter:title" content="TypeScript 데코레이터란 무엇이며, 데코레이터를 사용하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 14:46" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">TypeScript 데코레이터란 무엇이며, 데코레이터를 사용하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="TypeScript 데코레이터란 무엇이며, 데코레이터를 사용하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">13<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><code>&#x3C;img src="/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png" /></code></p>
<p>데코레이터는 클래스 선언, 메소드, 접근자, 속성 또는 매개변수에 첨부할 수 있는 특별한 선언 유형입니다. 데코레이터는 @expression 형식으로 사용되며, expression은 데코레이트된 선언에 대한 정보를 런타임에 호출할 함수로 평가되어야 합니다.</p>
<p>Typescript 5.0부터 Stage 3 데코레이터 지원이 가능합니다.</p>
<h2>데코레이터 사용 방법:</h2>
<div class="content-ad"></div>
<p>데코레이터에 대한 실험적인 지원을 활성화하려면 명령줄에서 tsc --target ES5 --experimentalDecorators를 사용하거나 tsconfig.json에서 experimentalDecorators 컴파일러 옵션을 활성화해야 합니다:</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">"compilerOptions"</span>: {
    <span class="hljs-string">"target"</span>: <span class="hljs-string">"ES5"</span>,
    <span class="hljs-string">"experimentalDecorators"</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre>
<p>사용자 클래스에 greet 메서드가 있는 경우를 고려해보세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private name: string, private age: number</span>) {}

  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>.`</span>);
  }

  <span class="hljs-title function_">printAge</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.age}</span> years old`</span>);
  }
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Ron"</span>, <span class="hljs-number">25</span>);
user.<span class="hljs-title function_">greet</span>();
user.<span class="hljs-title function_">printAge</span>();

출력:
<span class="hljs-title class_">Hello</span>, my name is <span class="hljs-title class_">Ron</span>.
I am <span class="hljs-number">25</span> years old
</code></pre>
<div class="content-ad"></div>
<p>이제 각 함수 실행이 시작하고 끝나는 시점을 기록하고 싶어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private name: string, private age: number</span>) {}

  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'start: greet'</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>.`</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'end: greet'</span>)
  }

  <span class="hljs-title function_">printAge</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'start: printAge'</span>)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.age}</span> years old`</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'end: printAge'</span>)
  }
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Ron"</span>, <span class="hljs-number">25</span>);
user.<span class="hljs-title function_">greet</span>();
user.<span class="hljs-title function_">printAge</span>();



<span class="hljs-title class_">Output</span>: 
<span class="hljs-attr">start</span>: greet
<span class="hljs-title class_">Hello</span>, my name is <span class="hljs-title class_">Ron</span>.
<span class="hljs-attr">end</span>: greet
<span class="hljs-attr">start</span>: printAge
I am <span class="hljs-number">25</span> years old
<span class="hljs-attr">end</span>: printAge
</code></pre>
<p>데코레이터를 만드는 것은 정말 쉬워요: logger라는 함수를 만들기만 하면 돼요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">originalMethod: any, _context: any</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">replacementMethod</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: any, ...args: any[]</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"start:"</span>, originalMethod.<span class="hljs-property">name</span>);
    <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"end:"</span>, originalMethod.<span class="hljs-property">name</span>);
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-keyword">return</span> replacementMethod;
}
</code></pre>
<div class="content-ad"></div>
<p>이제 메소드를 꾸밈을 준비했어요. 위의 예시에서 데코레이터를 사용해봅시다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private name: string, private age: number</span>) {}

  @logger
  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>.`</span>);
  }

  @logger
  <span class="hljs-title function_">printAge</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.age}</span> years old`</span>);
  }
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Ron"</span>, <span class="hljs-number">25</span>);
user.<span class="hljs-title function_">greet</span>();
user.<span class="hljs-title function_">printAge</span>();



<span class="hljs-title class_">Output</span>: 
<span class="hljs-attr">start</span>: greet
<span class="hljs-title class_">Hello</span>, my name is <span class="hljs-title class_">Ron</span>.
<span class="hljs-attr">end</span>: greet
<span class="hljs-attr">start</span>: printAge
I am <span class="hljs-number">25</span> years old
<span class="hljs-attr">end</span>: printAge
</code></pre>
<p>쉽죠? TypeScript는 여러 데코레이터를 지원합니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">  @logger
  @xyz
  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>.`</span>);
  }
</code></pre>
<p>여러 개의 데코레이터가 적용될 때 실행 순서를 살펴봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private name: string, private age: number</span>) {}

  @logger2
  @logger1
  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>.`</span>);
  }
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Ron"</span>, <span class="hljs-number">25</span>);
user.<span class="hljs-title function_">greet</span>();


<span class="hljs-keyword">function</span> <span class="hljs-title function_">logger1</span>(<span class="hljs-params">originalMethod: any, _context: any</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">replacementMethod</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: any, ...args: any[]</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"log1"</span>);
    <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args);
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-keyword">return</span> replacementMethod;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">logger2</span>(<span class="hljs-params">originalMethod: any, _context: any</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">replacementMethod</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: any, ...args: any[]</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"log2"</span>);
    <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args);
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-keyword">return</span> replacementMethod;
}





<span class="hljs-title class_">Output</span>: 
log2
log1
<span class="hljs-title class_">Hello</span>, my name is <span class="hljs-title class_">Ron</span>.
</code></pre>
<p>하나의 선언에 여러 데코레이터가 적용되면, 그 평가는 수학의 함수 합성과 유사합니다. 이 모델에서 함수 f와 g를 합성할 때, 결과 컴포지트(f ∘ g)(x)는 f(g(x))와 동등합니다.</p>
<div class="content-ad"></div>
<p>올바른 형식의 데코레이터 예제:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> loggedMethod&#x3C;<span class="hljs-title class_">This</span>, <span class="hljs-title class_">Args</span> <span class="hljs-keyword">extends</span> any[], <span class="hljs-title class_">Return</span>>(
    <span class="hljs-attr">target</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">this</span>: This, ...args: Args</span>) =></span> <span class="hljs-title class_">Return</span>,
    <span class="hljs-attr">context</span>: <span class="hljs-title class_">ClassMethodDecoratorContext</span>&#x3C;<span class="hljs-title class_">This</span>, <span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">this</span>: This, ...args: Args</span>) =></span> <span class="hljs-title class_">Return</span>>
) {
    <span class="hljs-keyword">const</span> methodName = <span class="hljs-title class_">String</span>(context.<span class="hljs-property">name</span>);

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">replacementMethod</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: This, ...args: Args</span>): <span class="hljs-title class_">Return</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`LOG: Entering method '<span class="hljs-subst">${methodName}</span>'.`</span>)
        <span class="hljs-keyword">const</span> result = target.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`LOG: Exiting method '<span class="hljs-subst">${methodName}</span>'.`</span>)
        <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-keyword">return</span> replacementMethod;
}
</code></pre>
<h2>데코레이터 유형:</h2>
<h2>1. 클래스 데코레이터</h2>
<div class="content-ad"></div>
<p>클래스 데코레이터는 클래스 선언 바로 전에 선언됩니다. 클래스 데코레이터는 클래스의 생성자에 적용되며, 클래스 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다. 클래스 데코레이터는 선언 파일이나 다른 주변 컨텍스트(예: 선언 클래스에 대해)에서 사용할 수 없습니다.</p>
<p>클래스 데코레이터의 표현식은 실행 시에 생성된 클래스의 생성자를 유일한 인수로하여 함수로 호출됩니다.</p>
<p>클래스 데코레이터가 값을 반환하면 제공된 생성자 함수로 클래스 선언이 대체됩니다. "새로운 생성자 함수를 반환하려면 원본 프로토 타입을 유지해야 합니다. 런타임에서 데코레이터를 적용하는 로직이 자동으로 처리해주지 않습니다."</p>
<p>여기에는 클래스 데코레이터를 사용하여 created 속성을 설정하려는 예제가 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  [<span class="hljs-attr">x</span>: string]: any;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">public name: string</span>) {}
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'John'</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span>, user.<span class="hljs-property">created</span>)

<span class="hljs-comment">// 출력:</span>
<span class="hljs-title class_">John</span> <span class="hljs-literal">undefined</span>
</code></pre>
<p>클래스 데코레이터를 사용한 예시</p>
<pre><code class="hljs language-js">@<span class="hljs-title class_">BaseEntity</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  [<span class="hljs-attr">x</span>: string]: any;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">public name: string</span>) {}
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">BaseEntity</span>(<span class="hljs-params">ctr: <span class="hljs-built_in">Function</span></span>) {
  ctr.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">created</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">toISOString</span>();
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'John'</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span>, user.<span class="hljs-property">created</span>)
</code></pre>
<h2>2. 메소드 데코레이터</h2>
<div class="content-ad"></div>
<p>메소드 데코레이터는 메소드 선언 바로 전에 선언됩니다. 데코레이터는 해당 메소드의 속성 설명자에 적용되며, 메소드 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 메소드 데코레이터는 선언 파일에서, 오버로드에서, 또는 기타 환경에서 (예: 선언 클래스 내) 사용할 수 없습니다. 이미 메소드 데코레이터 예제를 보았으므로 추가적인 자세한 내용은 다루지 않겠습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private name: string, private age: number</span>) {}

  @logger
  <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>.`</span>);
  }

  @logger
  <span class="hljs-title function_">printAge</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`I am <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.age}</span> years old`</span>);
  }
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">"Ron"</span>, <span class="hljs-number">25</span>);
user.<span class="hljs-title function_">greet</span>();
user.<span class="hljs-title function_">printAge</span>();

여러분의 프로젝트 블랙핑크에 오신 것을 환영합니다!

출력:
<span class="hljs-attr">start</span>: greet
<span class="hljs-title class_">Hello</span>, my name is <span class="hljs-title class_">Ron</span>.
<span class="hljs-attr">end</span>: greet
<span class="hljs-attr">start</span>: printAge
I am <span class="hljs-number">25</span> years old
<span class="hljs-attr">end</span>: printAge
</code></pre>
<h2>3. 접근자 데코레이터</h2>
<p>접근자 데코레이터는 접근자 선언 바로 전에 선언됩니다. 접근자 데코레이터는 해당 접근자의 속성 설명자에 적용되며, 접근자의 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 접근자 데코레이터는 선언 파일이나 기타 환경 (예: 선언 클래스 내)에서 사용할 수 없습니다.</p>
<div class="content-ad"></div>
<p>액세서 데코레이터의 표현은 런타임에서 다음 세 가지 인수와 함께 함수로 호출될 것입니다:</p>
<ul>
<li>정적 멤버의 경우 클래스의 생성자 함수 또는 인스턴스 멤버의 경우 클래스의 프로토타입.</li>
<li>멤버의 이름.</li>
<li>멤버의 속성 설명자(Property Descriptor).</li>
</ul>
<p>액세서 데코레이터가 값을 반환하면 해당 값은 멤버의 속성 설명자로 사용됩니다.</p>
<p>다음은 Point 클래스의 멤버에 적용된 액세서 데코레이터 예시(@configurable)입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">_x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_x</span> = x;
  }

  <span class="hljs-meta">@configurable</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">x</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_x</span>;
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">configurable</span>(<span class="hljs-params">value: <span class="hljs-built_in">boolean</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target: <span class="hljs-built_in">any</span>, propertyKey: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) {
    descriptor.<span class="hljs-property">configurable</span> = value;
  };
}
</code></pre>
<h2>4. Property Decorators</h2>
<p>프로퍼티 데코레이터는 프로퍼티 선언 바로 전에 선언됩니다. 프로퍼티 데코레이터는 선언 파일이나 다른 환경(context)에서 사용할 수 없습니다(예: declare class 내에서).</p>
<p>프로퍼티 데코레이터의 표현식은 런타임 시 함수로 호출되며 아래 두 인수를 전달받습니다:</p>
<div class="content-ad"></div>
<ul>
<li>정적 멤버의 클래스 생성자 함수이거나 인스턴스 멤버의 클래스 프로토타입입니다.</li>
<li>멤버의 이름입니다.</li>
</ul>
<p>TypeScript에서 속성 데코레이터의 예시를 제공합니다. 이 데코레이터는 속성의 값이 유효한 이메일 주소인지를 확인합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이메일 유효성 검사를 위한 속성 데코레이터</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ValidateEmail</span>(<span class="hljs-params">target: any, propertyKey: string</span>) {
  <span class="hljs-keyword">const</span> privateFieldName = <span class="hljs-string">`_<span class="hljs-subst">${propertyKey}</span>`</span>;

  <span class="hljs-comment">// 원래의 setter 메서드를 저장합니다.</span>
  <span class="hljs-keyword">const</span> originalSetter = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(target, propertyKey)?.<span class="hljs-property">set</span>;

  <span class="hljs-comment">// 속성을 위한 새로운 setter를 정의합니다.</span>
  <span class="hljs-keyword">const</span> newSetter = <span class="hljs-keyword">function</span> (<span class="hljs-params">value: any</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isValidEmail</span>(value)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`"<span class="hljs-subst">${propertyKey}</span>" 속성에 대한 유효하지 않은 이메일 주소입니다.`</span>);
    }
    <span class="hljs-variable language_">this</span>[privateFieldName] = value;
  };

  <span class="hljs-comment">// 속성의 setter 메서드를 대체합니다.</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, propertyKey, {
    <span class="hljs-attr">set</span>: newSetter,
    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[privateFieldName];
    },
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
  });
}

<span class="hljs-comment">// 이메일 주소 유효성을 검사하는 도우미 함수</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">isValidEmail</span>(<span class="hljs-params">email: string</span>): boolean {
  <span class="hljs-comment">// 간단한 이메일 유효성을 위한 정규 표현식</span>
  <span class="hljs-keyword">const</span> emailPattern = <span class="hljs-regexp">/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/</span>;
  <span class="hljs-keyword">return</span> emailPattern.<span class="hljs-title function_">test</span>(email);
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  @<span class="hljs-title class_">ValidateEmail</span>
  <span class="hljs-attr">email</span>: string = <span class="hljs-string">'test@example.com'</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">email: string</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">email</span> = email;
  }
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">'john@example.com'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">email</span>); <span class="hljs-comment">// john@example.com</span>

<span class="hljs-keyword">try</span> {
  user.<span class="hljs-property">email</span> = <span class="hljs-string">'invalid-email'</span>; <span class="hljs-comment">// 오류가 발생합니다.</span>
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">message</span>); <span class="hljs-comment">// "email" 속성에 대한 유효하지 않은 이메일 주소입니다.</span>
}

<span class="hljs-comment">// 출력:</span>
john@example.<span class="hljs-property">com</span>
<span class="hljs-string">"email"</span> 속성에 대한 유효하지 않은 이메일 주소입니다.
</code></pre>
<ul>
<li>우리는 속성 데코레이터 ValidateEmail을 정의하여 할당된 값이 유효한 이메일 주소인지 확인합니다.</li>
<li>newSetter 함수는 제공된 값이 유효한 이메일 주소인지 확인합니다. 그렇지 않으면 오류를 발생합니다.</li>
<li>User 클래스의 email 속성에 @ValidateEmail 데코레이터를 적용합니다.</li>
<li>User의 인스턴스를 만들 때 email 속성을 유효한 이메일 주소로 설정하면 예상대로 작동합니다.</li>
<li>email 속성을 유효하지 않은 이메일 주소(예: <code>invalid-email</code>)로 설정하려고 하면 데코레이터가 유효하지 않은 이메일 주소임을 나타내는 오류를 throw합니다.</li>
</ul>
<div class="content-ad"></div>
<h2>5. 매개변수 데코레이터</h2>
<p>매개변수 데코레이터는 매개변수 선언 바로 전에 선언됩니다. 매개변수 데코레이터는 클래스 생성자나 메서드 선언에 적용됩니다. 매개변수 데코레이터는 선언 파일, 오버로드 또는 다른 ambient context(declare class 내에도)에서 사용할 수 없습니다.</p>
<p>매개변수 데코레이터의 표현식은 런타임에 함수로 호출되며 다음 세 가지 인수와 함께 호출됩니다:</p>
<ul>
<li>정적 멤버의 경우 클래스의 생성자 함수 또는 인스턴스 멤버의 경우 클래스의 프로토타입.</li>
<li>멤버의 이름.</li>
<li>함수의 매개변수 목록에서 매개변수의 순서 인덱스.</li>
</ul>
<div class="content-ad"></div>
<p>파라미터 데코레이터의 반환 값은 무시됩니다.</p>
<p>다음은 간단한 정규 표현식을 사용하여 메서드 파라미터가 유효한 이메일 주소인지를 확인하는 파라미터 데코레이터의 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이메일 유효성 검사를 위한 파라미터 데코레이터</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ValidateEmail</span>(<span class="hljs-params">target: any, methodName: string, parameterIndex: number</span>) {
  <span class="hljs-keyword">const</span> originalMethod = target[methodName];

  target[methodName] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args: any[]</span>) {
    <span class="hljs-keyword">const</span> paramValue = args[parameterIndex];

    <span class="hljs-comment">// 간단한 이메일 유효성을 위한 정규 표현식</span>
    <span class="hljs-keyword">const</span> emailPattern = <span class="hljs-regexp">/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/</span>;

    <span class="hljs-keyword">if</span> (!emailPattern.<span class="hljs-title function_">test</span>(paramValue)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`파라미터 인덱스 <span class="hljs-subst">${parameterIndex}</span>의 유효하지 않은 이메일 주소가 제공되었습니다`</span>);
    }

    <span class="hljs-keyword">return</span> originalMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
  };
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleClass</span> {
  <span class="hljs-comment">// 이메일 파라미터를 검증하기 위해 파라미터 데코레이터를 적용</span>
  <span class="hljs-title function_">sendEmail</span>(<span class="hljs-params">@ValidateEmail email: string</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${email}</span>로 이메일을 보냅니다`</span>);
  }
}

<span class="hljs-keyword">const</span> exampleInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExampleClass</span>();

<span class="hljs-comment">// 작동합니다</span>
exampleInstance.<span class="hljs-title function_">sendEmail</span>(<span class="hljs-string">"example@email.com"</span>);

<span class="hljs-comment">// 이메일 유효성 검사로 오류가 발생합니다</span>
<span class="hljs-keyword">try</span> {
  exampleInstance.<span class="hljs-title function_">sendEmail</span>(<span class="hljs-string">"invalid-email"</span>);
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">message</span>); <span class="hljs-comment">// 파라미터 인덱스 0에 유효하지 않은 이메일 주소가 제공되었습니다</span>
}
</code></pre>
<ul>
<li>ValidateEmail이라는 이름의 파라미터 데코레이터를 정의하고, 정규 표현식을 사용하여 제공된 파라미터가 유효한 이메일 주소인지 확인합니다.</li>
<li>sendEmail 메서드를 가진 ExampleClass 클래스를 만들고, email 파라미터를 검증하기 위해 @ValidateEmail 데코레이터를 적용합니다.</li>
<li>sendEmail 메서드를 호출할 때, 제공된 이메일 파라미터가 이메일 유효성 정규 표현식과 일치하는지 확인합니다. 일치하지 않으면 오류를 throw합니다.</li>
<li>유효한 이메일로 한 번, 그리고 유효하지 않은 이메일을 주면 이메일 유효성 오류가 발생하는 두 가지 sendEmail 메서드 호출을 보여줍니다.</li>
</ul>
<div class="content-ad"></div>
<p>이 예제는 메서드 매개변수의 간단한 이메일 유효성 검사를 수행하기 위해 매개변수 데코레이터를 사용하는 방법을 보여줍니다. 특정 요구 사항에 따라 정규 표현식을 조정하거나 필요에 따라 더 복잡한 이메일 유효성 검사 로직을 추가할 수 있습니다.</p>
<h2>TypeScript의 데코레이터는 코드의 여러 부분을 수정하거나 동작을 추가하는 강력한 메커니즘을 제공합니다. 데코레이터의 일반적인 사용 사례는 다음과 같습니다:</h2>
<ul>
<li>로깅 및 디버깅: 메서드 호출, 함수 매개변수 또는 속성 액세스를 기록하여 디버깅에 도움을 줄 수 있습니다.</li>
<li>유효성 검사: 데코레이터는 입력 유효성 검사에 사용될 수 있으며, 함수 매개변수나 속성 값이 특정 기준이나 제약 조건을 충족하는지 확인할 수 있습니다.</li>
<li>메모이제이션: 데코레이터를 사용하여 함수 결과를 캐시함으로써 입력 매개변수에 따라 함수를 캐싱하여 비용이 많이 드는 계산의 성능을 향상시킬 수 있습니다.</li>
<li>인증 및 권한 부여: 데코레이터를 사용하여 웹 애플리케이션의 특정 메서드나 라우트에 액세스할 수 있는 전에 사용자 인증 또는 권한을 확인할 수 있습니다.</li>
<li>의존성 주입: Angular과 같은 프레임워크에서 데코레이터를 사용하여 클래스나 컴포넌트에 주입할 서비스를 지정할 수 있습니다.</li>
<li>라우트 처리 (웹 애플리케이션): Express.js 또는 Nest.js와 같은 웹 프레임워크에서 데코레이터를 사용하여 HTTP 엔드포인트의 라우트와 요청 핸들러를 정의할 수 있습니다.</li>
<li>데이터 변환: 처리되기 전에 데이터를 변환하기 위해 데코레이터를 사용할 수 있습니다.</li>
<li>캐싱: 데코레이터를 사용하여 데이터 검색 메서드를 캐싱함으로써 외부 데이터 소스에 부하를 줄일 수 있습니다.</li>
<li>시간 측정 및 프로파일링: 함수의 실행 시간을 측정할 수 있습니다.</li>
<li>로깅 프레임워크: 사용 사례에서 데코레이터는 특정 이벤트나 작업을 로깅하기 위해 메서드에 적용될 수 있습니다.</li>
<li>유효성 검사 프레임워크: 데이터가 특정 규칙이나 제약 조건을 준수하는지 확인하기 위해 사용자 정의 유효성 검사 데코레이터를 생성할 수 있습니다.</li>
<li>데이터베이스 매핑: Object-Relational Mapping (ORM) 라이브러리에서 데코레이터는 클래스 프로퍼티와 데이터베이스 열을 매핑하는 데 사용됩니다.</li>
<li>속성 액세스 제어: 데코레이터를 사용하여 클래스 속성에 액세스 제어 정책을 강제할 수 있습니다.</li>
<li>싱글톤 패턴: 데코레이터를 사용하여 싱글톤 디자인 패턴을 구현할 수 있습니다.</li>
<li>사용자 지정 미들웨어: 웹 프레임워크에서 데코레이터는 메인 요청 핸들러 앞이나 뒤에서 실행될 사용자 정의 미들웨어 함수를 생성하는 데 사용될 수 있습니다.</li>
<li>국제화와 지역화: 텍스트 속성이나 메서드에 데코레이터를 적용하여 언어 번역 및 지역화를 처리할 수 있습니다.</li>
<li>오류 처리: 예외를 일관되게 처리하기 쉽게 하기 위해 중앙 집중식 오류 처리 논리를 데코레이터로 사용할 수 있습니다.</li>
<li>이벤트 처리: 특정 이벤트에 대한 이벤트 리스너와 핸들러를 등록하는 데 사용될 수 있습니다.</li>
<li>유형 확인 및 변환: 데이터가 예상된 유형과 형식에 맞는지 확인하기 위해 유형 확인 및 데이터 변환을 수행할 수 있습니다.</li>
<li>사용자 정의 어노테이션: 클래스, 메서드 또는 속성에 대한 추가 정보를 제공하기 위한 사용자 지정 어노테이션 또는 메타데이터를 만들 수 있습니다.</li>
</ul>
<p>이것들은 TypeScript에서 데코레이터의 많은 사용 사례 중 일부에 불과합니다. 데코레이터는 클래스, 메서드 및 속성의 기능을 향상시키는 유연하고 확장 가능한 방법을 제공하여 코드를 더 모듈화되고 유지보수 가능하게 만듭니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"TypeScript 데코레이터란 무엇이며, 데코레이터를 사용하는 방법","description":"","date":"2024-06-22 14:46","slug":"2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators","content":"\n\n`\u003cimg src=\"/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png\" /\u003e`\n\n데코레이터는 클래스 선언, 메소드, 접근자, 속성 또는 매개변수에 첨부할 수 있는 특별한 선언 유형입니다. 데코레이터는 @expression 형식으로 사용되며, expression은 데코레이트된 선언에 대한 정보를 런타임에 호출할 함수로 평가되어야 합니다.\n\nTypescript 5.0부터 Stage 3 데코레이터 지원이 가능합니다.\n\n## 데코레이터 사용 방법:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데코레이터에 대한 실험적인 지원을 활성화하려면 명령줄에서 tsc --target ES5 --experimentalDecorators를 사용하거나 tsconfig.json에서 experimentalDecorators 컴파일러 옵션을 활성화해야 합니다:\n\n```js\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n사용자 클래스에 greet 메서드가 있는 경우를 고려해보세요.\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n\n  printAge() {\n    console.log(`I am ${this.age} years old`);\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\nuser.printAge();\n\n출력:\nHello, my name is Ron.\nI am 25 years old\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 각 함수 실행이 시작하고 끝나는 시점을 기록하고 싶어요:\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  greet() {\n    console.log('start: greet')\n    console.log(`Hello, my name is ${this.name}.`);\n    console.log('end: greet')\n  }\n\n  printAge() {\n    console.log('start: printAge')\n    console.log(`I am ${this.age} years old`);\n    console.log('end: printAge')\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\nuser.printAge();\n\n\n\nOutput: \nstart: greet\nHello, my name is Ron.\nend: greet\nstart: printAge\nI am 25 years old\nend: printAge\n```\n\n데코레이터를 만드는 것은 정말 쉬워요: logger라는 함수를 만들기만 하면 돼요:\n\n```js\nfunction logger(originalMethod: any, _context: any) {\n  function replacementMethod(this: any, ...args: any[]) {\n    console.log(\"start:\", originalMethod.name);\n    const result = originalMethod.call(this, ...args);\n    console.log(\"end:\", originalMethod.name);\n    return result;\n  }\n\n  return replacementMethod;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 메소드를 꾸밈을 준비했어요. 위의 예시에서 데코레이터를 사용해봅시다:\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  @logger\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n\n  @logger\n  printAge() {\n    console.log(`I am ${this.age} years old`);\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\nuser.printAge();\n\n\n\nOutput: \nstart: greet\nHello, my name is Ron.\nend: greet\nstart: printAge\nI am 25 years old\nend: printAge\n```\n\n쉽죠? TypeScript는 여러 데코레이터를 지원합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n  @logger\n  @xyz\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n```\n\n여러 개의 데코레이터가 적용될 때 실행 순서를 살펴봅시다.\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  @logger2\n  @logger1\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\n\n\nfunction logger1(originalMethod: any, _context: any) {\n  function replacementMethod(this: any, ...args: any[]) {\n    console.log(\"log1\");\n    const result = originalMethod.call(this, ...args);\n    return result;\n  }\n\n  return replacementMethod;\n}\n\nfunction logger2(originalMethod: any, _context: any) {\n  function replacementMethod(this: any, ...args: any[]) {\n    console.log(\"log2\");\n    const result = originalMethod.call(this, ...args);\n    return result;\n  }\n\n  return replacementMethod;\n}\n\n\n\n\n\nOutput: \nlog2\nlog1\nHello, my name is Ron.\n```\n\n하나의 선언에 여러 데코레이터가 적용되면, 그 평가는 수학의 함수 합성과 유사합니다. 이 모델에서 함수 f와 g를 합성할 때, 결과 컴포지트(f ∘ g)(x)는 f(g(x))와 동등합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n올바른 형식의 데코레이터 예제:\n\n```js\nfunction loggedMethod\u003cThis, Args extends any[], Return\u003e(\n    target: (this: This, ...args: Args) =\u003e Return,\n    context: ClassMethodDecoratorContext\u003cThis, (this: This, ...args: Args) =\u003e Return\u003e\n) {\n    const methodName = String(context.name);\n\n    function replacementMethod(this: This, ...args: Args): Return {\n        console.log(`LOG: Entering method '${methodName}'.`)\n        const result = target.call(this, ...args);\n        console.log(`LOG: Exiting method '${methodName}'.`)\n        return result;\n    }\n\n    return replacementMethod;\n}\n```\n\n## 데코레이터 유형:\n\n## 1. 클래스 데코레이터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클래스 데코레이터는 클래스 선언 바로 전에 선언됩니다. 클래스 데코레이터는 클래스의 생성자에 적용되며, 클래스 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다. 클래스 데코레이터는 선언 파일이나 다른 주변 컨텍스트(예: 선언 클래스에 대해)에서 사용할 수 없습니다.\n\n클래스 데코레이터의 표현식은 실행 시에 생성된 클래스의 생성자를 유일한 인수로하여 함수로 호출됩니다.\n\n클래스 데코레이터가 값을 반환하면 제공된 생성자 함수로 클래스 선언이 대체됩니다. \"새로운 생성자 함수를 반환하려면 원본 프로토 타입을 유지해야 합니다. 런타임에서 데코레이터를 적용하는 로직이 자동으로 처리해주지 않습니다.\"\n\n여기에는 클래스 데코레이터를 사용하여 created 속성을 설정하려는 예제가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass User {\n  [x: string]: any;\n  constructor(public name: string) {}\n}\n\nconst user = new User('John')\nconsole.log(user.name, user.created)\n\n// 출력:\nJohn undefined\n```\n\n클래스 데코레이터를 사용한 예시\n\n```js\n@BaseEntity\nclass User {\n  [x: string]: any;\n  constructor(public name: string) {}\n}\n\nfunction BaseEntity(ctr: Function) {\n  ctr.prototype.created = new Date().toISOString();\n}\n\nconst user = new User('John')\nconsole.log(user.name, user.created)\n```\n\n## 2. 메소드 데코레이터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메소드 데코레이터는 메소드 선언 바로 전에 선언됩니다. 데코레이터는 해당 메소드의 속성 설명자에 적용되며, 메소드 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 메소드 데코레이터는 선언 파일에서, 오버로드에서, 또는 기타 환경에서 (예: 선언 클래스 내) 사용할 수 없습니다. 이미 메소드 데코레이터 예제를 보았으므로 추가적인 자세한 내용은 다루지 않겠습니다:\n\n```js\nclass User {\n  constructor(private name: string, private age: number) {}\n\n  @logger\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n\n  @logger\n  printAge() {\n    console.log(`I am ${this.age} years old`);\n  }\n}\n\nconst user = new User(\"Ron\", 25);\nuser.greet();\nuser.printAge();\n\n여러분의 프로젝트 블랙핑크에 오신 것을 환영합니다!\n\n출력:\nstart: greet\nHello, my name is Ron.\nend: greet\nstart: printAge\nI am 25 years old\nend: printAge\n```\n\n## 3. 접근자 데코레이터\n\n접근자 데코레이터는 접근자 선언 바로 전에 선언됩니다. 접근자 데코레이터는 해당 접근자의 속성 설명자에 적용되며, 접근자의 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 접근자 데코레이터는 선언 파일이나 기타 환경 (예: 선언 클래스 내)에서 사용할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n액세서 데코레이터의 표현은 런타임에서 다음 세 가지 인수와 함께 함수로 호출될 것입니다:\n\n- 정적 멤버의 경우 클래스의 생성자 함수 또는 인스턴스 멤버의 경우 클래스의 프로토타입.\n- 멤버의 이름.\n- 멤버의 속성 설명자(Property Descriptor).\n\n액세서 데코레이터가 값을 반환하면 해당 값은 멤버의 속성 설명자로 사용됩니다.\n\n다음은 Point 클래스의 멤버에 적용된 액세서 데코레이터 예시(@configurable)입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```typescript\nclass Point {\n  private _x: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n  }\n\n  @configurable(false)\n  get x() {\n    return this._x;\n  }\n}\n\nfunction configurable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.configurable = value;\n  };\n}\n```\n\n## 4. Property Decorators\n\n프로퍼티 데코레이터는 프로퍼티 선언 바로 전에 선언됩니다. 프로퍼티 데코레이터는 선언 파일이나 다른 환경(context)에서 사용할 수 없습니다(예: declare class 내에서).\n\n프로퍼티 데코레이터의 표현식은 런타임 시 함수로 호출되며 아래 두 인수를 전달받습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 정적 멤버의 클래스 생성자 함수이거나 인스턴스 멤버의 클래스 프로토타입입니다.\n- 멤버의 이름입니다.\n\nTypeScript에서 속성 데코레이터의 예시를 제공합니다. 이 데코레이터는 속성의 값이 유효한 이메일 주소인지를 확인합니다:\n\n```js\n// 이메일 유효성 검사를 위한 속성 데코레이터\nfunction ValidateEmail(target: any, propertyKey: string) {\n  const privateFieldName = `_${propertyKey}`;\n\n  // 원래의 setter 메서드를 저장합니다.\n  const originalSetter = Object.getOwnPropertyDescriptor(target, propertyKey)?.set;\n\n  // 속성을 위한 새로운 setter를 정의합니다.\n  const newSetter = function (value: any) {\n    if (!isValidEmail(value)) {\n      throw new Error(`\"${propertyKey}\" 속성에 대한 유효하지 않은 이메일 주소입니다.`);\n    }\n    this[privateFieldName] = value;\n  };\n\n  // 속성의 setter 메서드를 대체합니다.\n  Object.defineProperty(target, propertyKey, {\n    set: newSetter,\n    get() {\n      return this[privateFieldName];\n    },\n    enumerable: true,\n    configurable: true,\n  });\n}\n\n// 이메일 주소 유효성을 검사하는 도우미 함수\nfunction isValidEmail(email: string): boolean {\n  // 간단한 이메일 유효성을 위한 정규 표현식\n  const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  return emailPattern.test(email);\n}\n\nclass User {\n  @ValidateEmail\n  email: string = 'test@example.com';\n\n  constructor(email: string) {\n    this.email = email;\n  }\n}\n\nconst user = new User('john@example.com');\n\nconsole.log(user.email); // john@example.com\n\ntry {\n  user.email = 'invalid-email'; // 오류가 발생합니다.\n} catch (error) {\n  console.error(error.message); // \"email\" 속성에 대한 유효하지 않은 이메일 주소입니다.\n}\n\n// 출력:\njohn@example.com\n\"email\" 속성에 대한 유효하지 않은 이메일 주소입니다.\n```\n\n- 우리는 속성 데코레이터 ValidateEmail을 정의하여 할당된 값이 유효한 이메일 주소인지 확인합니다.\n- newSetter 함수는 제공된 값이 유효한 이메일 주소인지 확인합니다. 그렇지 않으면 오류를 발생합니다.\n- User 클래스의 email 속성에 @ValidateEmail 데코레이터를 적용합니다.\n- User의 인스턴스를 만들 때 email 속성을 유효한 이메일 주소로 설정하면 예상대로 작동합니다.\n- email 속성을 유효하지 않은 이메일 주소(예: `invalid-email`)로 설정하려고 하면 데코레이터가 유효하지 않은 이메일 주소임을 나타내는 오류를 throw합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 5. 매개변수 데코레이터\n\n매개변수 데코레이터는 매개변수 선언 바로 전에 선언됩니다. 매개변수 데코레이터는 클래스 생성자나 메서드 선언에 적용됩니다. 매개변수 데코레이터는 선언 파일, 오버로드 또는 다른 ambient context(declare class 내에도)에서 사용할 수 없습니다.\n\n매개변수 데코레이터의 표현식은 런타임에 함수로 호출되며 다음 세 가지 인수와 함께 호출됩니다:\n\n- 정적 멤버의 경우 클래스의 생성자 함수 또는 인스턴스 멤버의 경우 클래스의 프로토타입.\n- 멤버의 이름.\n- 함수의 매개변수 목록에서 매개변수의 순서 인덱스.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파라미터 데코레이터의 반환 값은 무시됩니다.\n\n다음은 간단한 정규 표현식을 사용하여 메서드 파라미터가 유효한 이메일 주소인지를 확인하는 파라미터 데코레이터의 예시입니다:\n\n```js\n// 이메일 유효성 검사를 위한 파라미터 데코레이터\nfunction ValidateEmail(target: any, methodName: string, parameterIndex: number) {\n  const originalMethod = target[methodName];\n\n  target[methodName] = function (...args: any[]) {\n    const paramValue = args[parameterIndex];\n\n    // 간단한 이메일 유효성을 위한 정규 표현식\n    const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n\n    if (!emailPattern.test(paramValue)) {\n      throw new Error(`파라미터 인덱스 ${parameterIndex}의 유효하지 않은 이메일 주소가 제공되었습니다`);\n    }\n\n    return originalMethod.apply(this, args);\n  };\n}\n\nclass ExampleClass {\n  // 이메일 파라미터를 검증하기 위해 파라미터 데코레이터를 적용\n  sendEmail(@ValidateEmail email: string) {\n    console.log(`${email}로 이메일을 보냅니다`);\n  }\n}\n\nconst exampleInstance = new ExampleClass();\n\n// 작동합니다\nexampleInstance.sendEmail(\"example@email.com\");\n\n// 이메일 유효성 검사로 오류가 발생합니다\ntry {\n  exampleInstance.sendEmail(\"invalid-email\");\n} catch (error) {\n  console.error(error.message); // 파라미터 인덱스 0에 유효하지 않은 이메일 주소가 제공되었습니다\n}\n```\n\n- ValidateEmail이라는 이름의 파라미터 데코레이터를 정의하고, 정규 표현식을 사용하여 제공된 파라미터가 유효한 이메일 주소인지 확인합니다.\n- sendEmail 메서드를 가진 ExampleClass 클래스를 만들고, email 파라미터를 검증하기 위해 @ValidateEmail 데코레이터를 적용합니다.\n- sendEmail 메서드를 호출할 때, 제공된 이메일 파라미터가 이메일 유효성 정규 표현식과 일치하는지 확인합니다. 일치하지 않으면 오류를 throw합니다.\n- 유효한 이메일로 한 번, 그리고 유효하지 않은 이메일을 주면 이메일 유효성 오류가 발생하는 두 가지 sendEmail 메서드 호출을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제는 메서드 매개변수의 간단한 이메일 유효성 검사를 수행하기 위해 매개변수 데코레이터를 사용하는 방법을 보여줍니다. 특정 요구 사항에 따라 정규 표현식을 조정하거나 필요에 따라 더 복잡한 이메일 유효성 검사 로직을 추가할 수 있습니다.\n\n## TypeScript의 데코레이터는 코드의 여러 부분을 수정하거나 동작을 추가하는 강력한 메커니즘을 제공합니다. 데코레이터의 일반적인 사용 사례는 다음과 같습니다:\n\n- 로깅 및 디버깅: 메서드 호출, 함수 매개변수 또는 속성 액세스를 기록하여 디버깅에 도움을 줄 수 있습니다.\n- 유효성 검사: 데코레이터는 입력 유효성 검사에 사용될 수 있으며, 함수 매개변수나 속성 값이 특정 기준이나 제약 조건을 충족하는지 확인할 수 있습니다.\n- 메모이제이션: 데코레이터를 사용하여 함수 결과를 캐시함으로써 입력 매개변수에 따라 함수를 캐싱하여 비용이 많이 드는 계산의 성능을 향상시킬 수 있습니다.\n- 인증 및 권한 부여: 데코레이터를 사용하여 웹 애플리케이션의 특정 메서드나 라우트에 액세스할 수 있는 전에 사용자 인증 또는 권한을 확인할 수 있습니다.\n- 의존성 주입: Angular과 같은 프레임워크에서 데코레이터를 사용하여 클래스나 컴포넌트에 주입할 서비스를 지정할 수 있습니다.\n- 라우트 처리 (웹 애플리케이션): Express.js 또는 Nest.js와 같은 웹 프레임워크에서 데코레이터를 사용하여 HTTP 엔드포인트의 라우트와 요청 핸들러를 정의할 수 있습니다.\n- 데이터 변환: 처리되기 전에 데이터를 변환하기 위해 데코레이터를 사용할 수 있습니다.\n- 캐싱: 데코레이터를 사용하여 데이터 검색 메서드를 캐싱함으로써 외부 데이터 소스에 부하를 줄일 수 있습니다.\n- 시간 측정 및 프로파일링: 함수의 실행 시간을 측정할 수 있습니다.\n- 로깅 프레임워크: 사용 사례에서 데코레이터는 특정 이벤트나 작업을 로깅하기 위해 메서드에 적용될 수 있습니다.\n- 유효성 검사 프레임워크: 데이터가 특정 규칙이나 제약 조건을 준수하는지 확인하기 위해 사용자 정의 유효성 검사 데코레이터를 생성할 수 있습니다.\n- 데이터베이스 매핑: Object-Relational Mapping (ORM) 라이브러리에서 데코레이터는 클래스 프로퍼티와 데이터베이스 열을 매핑하는 데 사용됩니다.\n- 속성 액세스 제어: 데코레이터를 사용하여 클래스 속성에 액세스 제어 정책을 강제할 수 있습니다.\n- 싱글톤 패턴: 데코레이터를 사용하여 싱글톤 디자인 패턴을 구현할 수 있습니다.\n- 사용자 지정 미들웨어: 웹 프레임워크에서 데코레이터는 메인 요청 핸들러 앞이나 뒤에서 실행될 사용자 정의 미들웨어 함수를 생성하는 데 사용될 수 있습니다.\n- 국제화와 지역화: 텍스트 속성이나 메서드에 데코레이터를 적용하여 언어 번역 및 지역화를 처리할 수 있습니다.\n- 오류 처리: 예외를 일관되게 처리하기 쉽게 하기 위해 중앙 집중식 오류 처리 논리를 데코레이터로 사용할 수 있습니다.\n- 이벤트 처리: 특정 이벤트에 대한 이벤트 리스너와 핸들러를 등록하는 데 사용될 수 있습니다.\n- 유형 확인 및 변환: 데이터가 예상된 유형과 형식에 맞는지 확인하기 위해 유형 확인 및 데이터 변환을 수행할 수 있습니다.\n- 사용자 정의 어노테이션: 클래스, 메서드 또는 속성에 대한 추가 정보를 제공하기 위한 사용자 지정 어노테이션 또는 메타데이터를 만들 수 있습니다.\n\n이것들은 TypeScript에서 데코레이터의 많은 사용 사례 중 일부에 불과합니다. 데코레이터는 클래스, 메서드 및 속성의 기능을 향상시키는 유연하고 확장 가능한 방법을 제공하여 코드를 더 모듈화되고 유지보수 가능하게 만듭니다.","ogImage":{"url":"/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png"},"coverImage":"/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png","tag":["Tech"],"readingTime":13},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003ccode\u003e\u0026#x3C;img src=\"/assets/img/2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators_0.png\" /\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e데코레이터는 클래스 선언, 메소드, 접근자, 속성 또는 매개변수에 첨부할 수 있는 특별한 선언 유형입니다. 데코레이터는 @expression 형식으로 사용되며, expression은 데코레이트된 선언에 대한 정보를 런타임에 호출할 함수로 평가되어야 합니다.\u003c/p\u003e\n\u003cp\u003eTypescript 5.0부터 Stage 3 데코레이터 지원이 가능합니다.\u003c/p\u003e\n\u003ch2\u003e데코레이터 사용 방법:\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e데코레이터에 대한 실험적인 지원을 활성화하려면 명령줄에서 tsc --target ES5 --experimentalDecorators를 사용하거나 tsconfig.json에서 experimentalDecorators 컴파일러 옵션을 활성화해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\"compilerOptions\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"target\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"ES5\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"experimentalDecorators\"\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사용자 클래스에 greet 메서드가 있는 경우를 고려해보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate name: string, private age: number\u003c/span\u003e) {}\n\n  \u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Hello, my name is \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.name}\u003c/span\u003e.`\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003eprintAge\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`I am \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.age}\u003c/span\u003e years old`\u003c/span\u003e);\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Ron\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e);\nuser.\u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e();\nuser.\u003cspan class=\"hljs-title function_\"\u003eprintAge\u003c/span\u003e();\n\n출력:\n\u003cspan class=\"hljs-title class_\"\u003eHello\u003c/span\u003e, my name is \u003cspan class=\"hljs-title class_\"\u003eRon\u003c/span\u003e.\nI am \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e years old\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 각 함수 실행이 시작하고 끝나는 시점을 기록하고 싶어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate name: string, private age: number\u003c/span\u003e) {}\n\n  \u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'start: greet'\u003c/span\u003e)\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Hello, my name is \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.name}\u003c/span\u003e.`\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'end: greet'\u003c/span\u003e)\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003eprintAge\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'start: printAge'\u003c/span\u003e)\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`I am \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.age}\u003c/span\u003e years old`\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'end: printAge'\u003c/span\u003e)\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Ron\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e);\nuser.\u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e();\nuser.\u003cspan class=\"hljs-title function_\"\u003eprintAge\u003c/span\u003e();\n\n\n\n\u003cspan class=\"hljs-title class_\"\u003eOutput\u003c/span\u003e: \n\u003cspan class=\"hljs-attr\"\u003estart\u003c/span\u003e: greet\n\u003cspan class=\"hljs-title class_\"\u003eHello\u003c/span\u003e, my name is \u003cspan class=\"hljs-title class_\"\u003eRon\u003c/span\u003e.\n\u003cspan class=\"hljs-attr\"\u003eend\u003c/span\u003e: greet\n\u003cspan class=\"hljs-attr\"\u003estart\u003c/span\u003e: printAge\nI am \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e years old\n\u003cspan class=\"hljs-attr\"\u003eend\u003c/span\u003e: printAge\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e데코레이터를 만드는 것은 정말 쉬워요: logger라는 함수를 만들기만 하면 돼요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elogger\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eoriginalMethod: any, _context: any\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereplacementMethod\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e: any, ...args: any[]\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"start:\"\u003c/span\u003e, originalMethod.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = originalMethod.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, ...args);\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"end:\"\u003c/span\u003e, originalMethod.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e replacementMethod;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 메소드를 꾸밈을 준비했어요. 위의 예시에서 데코레이터를 사용해봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate name: string, private age: number\u003c/span\u003e) {}\n\n  @logger\n  \u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Hello, my name is \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.name}\u003c/span\u003e.`\u003c/span\u003e);\n  }\n\n  @logger\n  \u003cspan class=\"hljs-title function_\"\u003eprintAge\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`I am \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.age}\u003c/span\u003e years old`\u003c/span\u003e);\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Ron\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e);\nuser.\u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e();\nuser.\u003cspan class=\"hljs-title function_\"\u003eprintAge\u003c/span\u003e();\n\n\n\n\u003cspan class=\"hljs-title class_\"\u003eOutput\u003c/span\u003e: \n\u003cspan class=\"hljs-attr\"\u003estart\u003c/span\u003e: greet\n\u003cspan class=\"hljs-title class_\"\u003eHello\u003c/span\u003e, my name is \u003cspan class=\"hljs-title class_\"\u003eRon\u003c/span\u003e.\n\u003cspan class=\"hljs-attr\"\u003eend\u003c/span\u003e: greet\n\u003cspan class=\"hljs-attr\"\u003estart\u003c/span\u003e: printAge\nI am \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e years old\n\u003cspan class=\"hljs-attr\"\u003eend\u003c/span\u003e: printAge\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e쉽죠? TypeScript는 여러 데코레이터를 지원합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  @logger\n  @xyz\n  \u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Hello, my name is \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.name}\u003c/span\u003e.`\u003c/span\u003e);\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여러 개의 데코레이터가 적용될 때 실행 순서를 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate name: string, private age: number\u003c/span\u003e) {}\n\n  @logger2\n  @logger1\n  \u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Hello, my name is \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.name}\u003c/span\u003e.`\u003c/span\u003e);\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Ron\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e);\nuser.\u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e();\n\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elogger1\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eoriginalMethod: any, _context: any\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereplacementMethod\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e: any, ...args: any[]\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"log1\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = originalMethod.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, ...args);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e replacementMethod;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elogger2\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eoriginalMethod: any, _context: any\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereplacementMethod\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e: any, ...args: any[]\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"log2\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = originalMethod.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, ...args);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e replacementMethod;\n}\n\n\n\n\n\n\u003cspan class=\"hljs-title class_\"\u003eOutput\u003c/span\u003e: \nlog2\nlog1\n\u003cspan class=\"hljs-title class_\"\u003eHello\u003c/span\u003e, my name is \u003cspan class=\"hljs-title class_\"\u003eRon\u003c/span\u003e.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하나의 선언에 여러 데코레이터가 적용되면, 그 평가는 수학의 함수 합성과 유사합니다. 이 모델에서 함수 f와 g를 합성할 때, 결과 컴포지트(f ∘ g)(x)는 f(g(x))와 동등합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e올바른 형식의 데코레이터 예제:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e loggedMethod\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eThis\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eArgs\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e any[], \u003cspan class=\"hljs-title class_\"\u003eReturn\u003c/span\u003e\u003e(\n    \u003cspan class=\"hljs-attr\"\u003etarget\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e: This, ...args: Args\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReturn\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003econtext\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eClassMethodDecoratorContext\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eThis\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e: This, ...args: Args\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReturn\u003c/span\u003e\u003e\n) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e methodName = \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(context.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereplacementMethod\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e: This, ...args: Args\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eReturn\u003c/span\u003e {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`LOG: Entering method '\u003cspan class=\"hljs-subst\"\u003e${methodName}\u003c/span\u003e'.`\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = target.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, ...args);\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`LOG: Exiting method '\u003cspan class=\"hljs-subst\"\u003e${methodName}\u003c/span\u003e'.`\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e replacementMethod;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e데코레이터 유형:\u003c/h2\u003e\n\u003ch2\u003e1. 클래스 데코레이터\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e클래스 데코레이터는 클래스 선언 바로 전에 선언됩니다. 클래스 데코레이터는 클래스의 생성자에 적용되며, 클래스 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다. 클래스 데코레이터는 선언 파일이나 다른 주변 컨텍스트(예: 선언 클래스에 대해)에서 사용할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e클래스 데코레이터의 표현식은 실행 시에 생성된 클래스의 생성자를 유일한 인수로하여 함수로 호출됩니다.\u003c/p\u003e\n\u003cp\u003e클래스 데코레이터가 값을 반환하면 제공된 생성자 함수로 클래스 선언이 대체됩니다. \"새로운 생성자 함수를 반환하려면 원본 프로토 타입을 유지해야 합니다. 런타임에서 데코레이터를 적용하는 로직이 자동으로 처리해주지 않습니다.\"\u003c/p\u003e\n\u003cp\u003e여기에는 클래스 데코레이터를 사용하여 created 속성을 설정하려는 예제가 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  [\u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: string]: any;\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epublic name: string\u003c/span\u003e) {}\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'John'\u003c/span\u003e)\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(user.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e, user.\u003cspan class=\"hljs-property\"\u003ecreated\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e// 출력:\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eJohn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e클래스 데코레이터를 사용한 예시\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eBaseEntity\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  [\u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: string]: any;\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003epublic name: string\u003c/span\u003e) {}\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eBaseEntity\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ectr: \u003cspan class=\"hljs-built_in\"\u003eFunction\u003c/span\u003e\u003c/span\u003e) {\n  ctr.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecreated\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003etoISOString\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'John'\u003c/span\u003e)\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(user.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e, user.\u003cspan class=\"hljs-property\"\u003ecreated\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e2. 메소드 데코레이터\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e메소드 데코레이터는 메소드 선언 바로 전에 선언됩니다. 데코레이터는 해당 메소드의 속성 설명자에 적용되며, 메소드 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 메소드 데코레이터는 선언 파일에서, 오버로드에서, 또는 기타 환경에서 (예: 선언 클래스 내) 사용할 수 없습니다. 이미 메소드 데코레이터 예제를 보았으므로 추가적인 자세한 내용은 다루지 않겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate name: string, private age: number\u003c/span\u003e) {}\n\n  @logger\n  \u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Hello, my name is \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.name}\u003c/span\u003e.`\u003c/span\u003e);\n  }\n\n  @logger\n  \u003cspan class=\"hljs-title function_\"\u003eprintAge\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`I am \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.age}\u003c/span\u003e years old`\u003c/span\u003e);\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Ron\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e);\nuser.\u003cspan class=\"hljs-title function_\"\u003egreet\u003c/span\u003e();\nuser.\u003cspan class=\"hljs-title function_\"\u003eprintAge\u003c/span\u003e();\n\n여러분의 프로젝트 블랙핑크에 오신 것을 환영합니다!\n\n출력:\n\u003cspan class=\"hljs-attr\"\u003estart\u003c/span\u003e: greet\n\u003cspan class=\"hljs-title class_\"\u003eHello\u003c/span\u003e, my name is \u003cspan class=\"hljs-title class_\"\u003eRon\u003c/span\u003e.\n\u003cspan class=\"hljs-attr\"\u003eend\u003c/span\u003e: greet\n\u003cspan class=\"hljs-attr\"\u003estart\u003c/span\u003e: printAge\nI am \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e years old\n\u003cspan class=\"hljs-attr\"\u003eend\u003c/span\u003e: printAge\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e3. 접근자 데코레이터\u003c/h2\u003e\n\u003cp\u003e접근자 데코레이터는 접근자 선언 바로 전에 선언됩니다. 접근자 데코레이터는 해당 접근자의 속성 설명자에 적용되며, 접근자의 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 접근자 데코레이터는 선언 파일이나 기타 환경 (예: 선언 클래스 내)에서 사용할 수 없습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e액세서 데코레이터의 표현은 런타임에서 다음 세 가지 인수와 함께 함수로 호출될 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e정적 멤버의 경우 클래스의 생성자 함수 또는 인스턴스 멤버의 경우 클래스의 프로토타입.\u003c/li\u003e\n\u003cli\u003e멤버의 이름.\u003c/li\u003e\n\u003cli\u003e멤버의 속성 설명자(Property Descriptor).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e액세서 데코레이터가 값을 반환하면 해당 값은 멤버의 속성 설명자로 사용됩니다.\u003c/p\u003e\n\u003cp\u003e다음은 Point 클래스의 멤버에 적용된 액세서 데코레이터 예시(@configurable)입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePoint\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e_x\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e, y: \u003cspan class=\"hljs-built_in\"\u003enumber\u003c/span\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_x\u003c/span\u003e = x;\n  }\n\n  \u003cspan class=\"hljs-meta\"\u003e@configurable\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e)\n  \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ex\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_x\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003econfigurable\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue: \u003cspan class=\"hljs-built_in\"\u003eboolean\u003c/span\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003etarget: \u003cspan class=\"hljs-built_in\"\u003eany\u003c/span\u003e, propertyKey: \u003cspan class=\"hljs-built_in\"\u003estring\u003c/span\u003e, descriptor: PropertyDescriptor\u003c/span\u003e) {\n    descriptor.\u003cspan class=\"hljs-property\"\u003econfigurable\u003c/span\u003e = value;\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e4. Property Decorators\u003c/h2\u003e\n\u003cp\u003e프로퍼티 데코레이터는 프로퍼티 선언 바로 전에 선언됩니다. 프로퍼티 데코레이터는 선언 파일이나 다른 환경(context)에서 사용할 수 없습니다(예: declare class 내에서).\u003c/p\u003e\n\u003cp\u003e프로퍼티 데코레이터의 표현식은 런타임 시 함수로 호출되며 아래 두 인수를 전달받습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e정적 멤버의 클래스 생성자 함수이거나 인스턴스 멤버의 클래스 프로토타입입니다.\u003c/li\u003e\n\u003cli\u003e멤버의 이름입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTypeScript에서 속성 데코레이터의 예시를 제공합니다. 이 데코레이터는 속성의 값이 유효한 이메일 주소인지를 확인합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이메일 유효성 검사를 위한 속성 데코레이터\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eValidateEmail\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etarget: any, propertyKey: string\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e privateFieldName = \u003cspan class=\"hljs-string\"\u003e`_\u003cspan class=\"hljs-subst\"\u003e${propertyKey}\u003c/span\u003e`\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// 원래의 setter 메서드를 저장합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e originalSetter = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetOwnPropertyDescriptor\u003c/span\u003e(target, propertyKey)?.\u003cspan class=\"hljs-property\"\u003eset\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// 속성을 위한 새로운 setter를 정의합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newSetter = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003evalue: any\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!\u003cspan class=\"hljs-title function_\"\u003eisValidEmail\u003c/span\u003e(value)) {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\"\u003cspan class=\"hljs-subst\"\u003e${propertyKey}\u003c/span\u003e\" 속성에 대한 유효하지 않은 이메일 주소입니다.`\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e[privateFieldName] = value;\n  };\n\n  \u003cspan class=\"hljs-comment\"\u003e// 속성의 setter 메서드를 대체합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edefineProperty\u003c/span\u003e(target, propertyKey, {\n    \u003cspan class=\"hljs-attr\"\u003eset\u003c/span\u003e: newSetter,\n    \u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e[privateFieldName];\n    },\n    \u003cspan class=\"hljs-attr\"\u003eenumerable\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003econfigurable\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  });\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 이메일 주소 유효성을 검사하는 도우미 함수\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisValidEmail\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eemail: string\u003c/span\u003e): boolean {\n  \u003cspan class=\"hljs-comment\"\u003e// 간단한 이메일 유효성을 위한 정규 표현식\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e emailPattern = \u003cspan class=\"hljs-regexp\"\u003e/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e emailPattern.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(email);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title class_\"\u003eValidateEmail\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: string = \u003cspan class=\"hljs-string\"\u003e'test@example.com'\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eemail: string\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e = email;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'john@example.com'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(user.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// john@example.com\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n  user.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'invalid-email'\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 오류가 발생합니다.\u003c/span\u003e\n} \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(error.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"email\" 속성에 대한 유효하지 않은 이메일 주소입니다.\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 출력:\u003c/span\u003e\njohn@example.\u003cspan class=\"hljs-property\"\u003ecom\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"email\"\u003c/span\u003e 속성에 대한 유효하지 않은 이메일 주소입니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e우리는 속성 데코레이터 ValidateEmail을 정의하여 할당된 값이 유효한 이메일 주소인지 확인합니다.\u003c/li\u003e\n\u003cli\u003enewSetter 함수는 제공된 값이 유효한 이메일 주소인지 확인합니다. 그렇지 않으면 오류를 발생합니다.\u003c/li\u003e\n\u003cli\u003eUser 클래스의 email 속성에 @ValidateEmail 데코레이터를 적용합니다.\u003c/li\u003e\n\u003cli\u003eUser의 인스턴스를 만들 때 email 속성을 유효한 이메일 주소로 설정하면 예상대로 작동합니다.\u003c/li\u003e\n\u003cli\u003eemail 속성을 유효하지 않은 이메일 주소(예: \u003ccode\u003einvalid-email\u003c/code\u003e)로 설정하려고 하면 데코레이터가 유효하지 않은 이메일 주소임을 나타내는 오류를 throw합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e5. 매개변수 데코레이터\u003c/h2\u003e\n\u003cp\u003e매개변수 데코레이터는 매개변수 선언 바로 전에 선언됩니다. 매개변수 데코레이터는 클래스 생성자나 메서드 선언에 적용됩니다. 매개변수 데코레이터는 선언 파일, 오버로드 또는 다른 ambient context(declare class 내에도)에서 사용할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e매개변수 데코레이터의 표현식은 런타임에 함수로 호출되며 다음 세 가지 인수와 함께 호출됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e정적 멤버의 경우 클래스의 생성자 함수 또는 인스턴스 멤버의 경우 클래스의 프로토타입.\u003c/li\u003e\n\u003cli\u003e멤버의 이름.\u003c/li\u003e\n\u003cli\u003e함수의 매개변수 목록에서 매개변수의 순서 인덱스.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e파라미터 데코레이터의 반환 값은 무시됩니다.\u003c/p\u003e\n\u003cp\u003e다음은 간단한 정규 표현식을 사용하여 메서드 파라미터가 유효한 이메일 주소인지를 확인하는 파라미터 데코레이터의 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이메일 유효성 검사를 위한 파라미터 데코레이터\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eValidateEmail\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etarget: any, methodName: string, parameterIndex: number\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e originalMethod = target[methodName];\n\n  target[methodName] = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e paramValue = args[parameterIndex];\n\n    \u003cspan class=\"hljs-comment\"\u003e// 간단한 이메일 유효성을 위한 정규 표현식\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e emailPattern = \u003cspan class=\"hljs-regexp\"\u003e/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!emailPattern.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(paramValue)) {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`파라미터 인덱스 \u003cspan class=\"hljs-subst\"\u003e${parameterIndex}\u003c/span\u003e의 유효하지 않은 이메일 주소가 제공되었습니다`\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e originalMethod.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, args);\n  };\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExampleClass\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 이메일 파라미터를 검증하기 위해 파라미터 데코레이터를 적용\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003esendEmail\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e@ValidateEmail email: string\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${email}\u003c/span\u003e로 이메일을 보냅니다`\u003c/span\u003e);\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e exampleInstance = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eExampleClass\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 작동합니다\u003c/span\u003e\nexampleInstance.\u003cspan class=\"hljs-title function_\"\u003esendEmail\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"example@email.com\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 이메일 유효성 검사로 오류가 발생합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n  exampleInstance.\u003cspan class=\"hljs-title function_\"\u003esendEmail\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"invalid-email\"\u003c/span\u003e);\n} \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(error.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 파라미터 인덱스 0에 유효하지 않은 이메일 주소가 제공되었습니다\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eValidateEmail이라는 이름의 파라미터 데코레이터를 정의하고, 정규 표현식을 사용하여 제공된 파라미터가 유효한 이메일 주소인지 확인합니다.\u003c/li\u003e\n\u003cli\u003esendEmail 메서드를 가진 ExampleClass 클래스를 만들고, email 파라미터를 검증하기 위해 @ValidateEmail 데코레이터를 적용합니다.\u003c/li\u003e\n\u003cli\u003esendEmail 메서드를 호출할 때, 제공된 이메일 파라미터가 이메일 유효성 정규 표현식과 일치하는지 확인합니다. 일치하지 않으면 오류를 throw합니다.\u003c/li\u003e\n\u003cli\u003e유효한 이메일로 한 번, 그리고 유효하지 않은 이메일을 주면 이메일 유효성 오류가 발생하는 두 가지 sendEmail 메서드 호출을 보여줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 예제는 메서드 매개변수의 간단한 이메일 유효성 검사를 수행하기 위해 매개변수 데코레이터를 사용하는 방법을 보여줍니다. 특정 요구 사항에 따라 정규 표현식을 조정하거나 필요에 따라 더 복잡한 이메일 유효성 검사 로직을 추가할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003eTypeScript의 데코레이터는 코드의 여러 부분을 수정하거나 동작을 추가하는 강력한 메커니즘을 제공합니다. 데코레이터의 일반적인 사용 사례는 다음과 같습니다:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e로깅 및 디버깅: 메서드 호출, 함수 매개변수 또는 속성 액세스를 기록하여 디버깅에 도움을 줄 수 있습니다.\u003c/li\u003e\n\u003cli\u003e유효성 검사: 데코레이터는 입력 유효성 검사에 사용될 수 있으며, 함수 매개변수나 속성 값이 특정 기준이나 제약 조건을 충족하는지 확인할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e메모이제이션: 데코레이터를 사용하여 함수 결과를 캐시함으로써 입력 매개변수에 따라 함수를 캐싱하여 비용이 많이 드는 계산의 성능을 향상시킬 수 있습니다.\u003c/li\u003e\n\u003cli\u003e인증 및 권한 부여: 데코레이터를 사용하여 웹 애플리케이션의 특정 메서드나 라우트에 액세스할 수 있는 전에 사용자 인증 또는 권한을 확인할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e의존성 주입: Angular과 같은 프레임워크에서 데코레이터를 사용하여 클래스나 컴포넌트에 주입할 서비스를 지정할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e라우트 처리 (웹 애플리케이션): Express.js 또는 Nest.js와 같은 웹 프레임워크에서 데코레이터를 사용하여 HTTP 엔드포인트의 라우트와 요청 핸들러를 정의할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e데이터 변환: 처리되기 전에 데이터를 변환하기 위해 데코레이터를 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e캐싱: 데코레이터를 사용하여 데이터 검색 메서드를 캐싱함으로써 외부 데이터 소스에 부하를 줄일 수 있습니다.\u003c/li\u003e\n\u003cli\u003e시간 측정 및 프로파일링: 함수의 실행 시간을 측정할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e로깅 프레임워크: 사용 사례에서 데코레이터는 특정 이벤트나 작업을 로깅하기 위해 메서드에 적용될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e유효성 검사 프레임워크: 데이터가 특정 규칙이나 제약 조건을 준수하는지 확인하기 위해 사용자 정의 유효성 검사 데코레이터를 생성할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e데이터베이스 매핑: Object-Relational Mapping (ORM) 라이브러리에서 데코레이터는 클래스 프로퍼티와 데이터베이스 열을 매핑하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e속성 액세스 제어: 데코레이터를 사용하여 클래스 속성에 액세스 제어 정책을 강제할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e싱글톤 패턴: 데코레이터를 사용하여 싱글톤 디자인 패턴을 구현할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e사용자 지정 미들웨어: 웹 프레임워크에서 데코레이터는 메인 요청 핸들러 앞이나 뒤에서 실행될 사용자 정의 미들웨어 함수를 생성하는 데 사용될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e국제화와 지역화: 텍스트 속성이나 메서드에 데코레이터를 적용하여 언어 번역 및 지역화를 처리할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e오류 처리: 예외를 일관되게 처리하기 쉽게 하기 위해 중앙 집중식 오류 처리 논리를 데코레이터로 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e이벤트 처리: 특정 이벤트에 대한 이벤트 리스너와 핸들러를 등록하는 데 사용될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e유형 확인 및 변환: 데이터가 예상된 유형과 형식에 맞는지 확인하기 위해 유형 확인 및 데이터 변환을 수행할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e사용자 정의 어노테이션: 클래스, 메서드 또는 속성에 대한 추가 정보를 제공하기 위한 사용자 지정 어노테이션 또는 메타데이터를 만들 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이것들은 TypeScript에서 데코레이터의 많은 사용 사례 중 일부에 불과합니다. 데코레이터는 클래스, 메서드 및 속성의 기능을 향상시키는 유연하고 확장 가능한 방법을 제공하여 코드를 더 모듈화되고 유지보수 가능하게 만듭니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-Whataredecoratorsintypescriptandhowtousedecorators"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>