<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>첫 번째 RCE를 발견한 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-15-HowIFoundMyFirstRCE" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="첫 번째 RCE를 발견한 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="첫 번째 RCE를 발견한 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-15-HowIFoundMyFirstRCE_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-15-HowIFoundMyFirstRCE" data-gatsby-head="true"/><meta name="twitter:title" content="첫 번째 RCE를 발견한 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-15-HowIFoundMyFirstRCE_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-15 11:46" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-742e6c91a18eb160.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">첫 번째 RCE를 발견한 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="첫 번째 RCE를 발견한 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 15, 2024</span><span class="posts_reading_time__f7YPP">2<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-15-HowIFoundMyFirstRCE&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>안녕하세요 여러분! 이 글에서는 제 첫 RCE 경험에 대해 이야기하려고 해요. 제가 Apache ActiveMQ에서 발생한 CVE-2023-46604로 발생한 사건이죠. 전문적인 버그 헌터를 위한 새로운 정보를 제공하는 것보다는 어떻게 발견했는지에 더 초점을 맞출 거에요.</p>
<p>저의 탐색 과정에서, 매주 서브도메인 목록을 업데이트하고 3일마다(하루에 한 번 하는 것이 더 좋겠지만) 열린 포트를 스캔했어요. 서브도메인 열람을 위해 Subfinder와 Amass 같은 도구를 사용했어요.</p>
<pre><code class="hljs language-js">subfinder -dL domains.<span class="hljs-property">txt</span> -o subdomains.<span class="hljs-property">txt</span>
#그리고 서브도메인의 서브도메인
subfinder -dL subdomains.<span class="hljs-property">txt</span> -o more-subdomains.<span class="hljs-property">txt</span>

#<span class="hljs-title class_">Amass</span> 사용
amass enum -passive -norecursive -noalts -df domains.<span class="hljs-property">txt</span> -o subs.<span class="hljs-property">txt</span>
#그리고 서브도메인의 서브도메인
amass enum -passive -norecursive -noalts -df subs.<span class="hljs-property">txt</span> -o more-subs.<span class="hljs-property">txt</span>
</code></pre>
<p>아래와 같이 하세요:</p>
<pre><code class="hljs language-bash"><span class="hljs-built_in">cat</span> more-subdomains.txt subdomains.txt subs.txt more-subs.txt | <span class="hljs-built_in">sort</span> -u > targets.txt
</code></pre>
<p>이후에는 몇 가지 경우에는 많은 수의 서브도메인이 생기기도 하는데, 때로는 5천개 이상이 될 때도 있습니다. DNSx를 사용하여 서브도메인을 확인하는 간단한 스크립트를 만들어 15개씩 그룹으로 나누었습니다. 그런 다음, 백그라운드에서 계속 실행하기 위해 nohup을 사용하여 Naabu를 실행했습니다.</p>
<p>사용한 스크립트</p>
<pre><code class="hljs language-sh"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -eq 0 ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"사용법: <span class="hljs-variable">$0</span> &#x3C;file>"</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>

<span class="hljs-built_in">cat</span> <span class="hljs-variable">$1</span> | dnsx -o <span class="hljs-variable">$1_ok</span>.txt

<span class="hljs-built_in">split</span> -l 15 <span class="hljs-variable">$1_ok</span>.txt 15_file_

<span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> 15_file_*; <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">nohup</span> naabu -list <span class="hljs-string">"<span class="hljs-variable">$file</span>"</span> -p - -o <span class="hljs-string">"<span class="hljs-variable">${file}</span>.out"</span>&#x26;
<span class="hljs-keyword">done</span>
</code></pre>
<p>그리고</p>
<pre><code class="hljs language-sh"><span class="hljs-built_in">cat</span> 15*out | <span class="hljs-built_in">sort</span> -u > ports.out 
</code></pre>
<p>많은 시간 동안 그 목록을 수동으로 확인했습니다. 저는 허니팟일 가능성이 있는 호스트를 필터링했고, 때로는 Naabu가 신뢰할 수 없는 결과를 제공했습니다.```</p>
<p>그리고 그 이후에, 3부터 10 사이의 열린 포트를 가진 호스트를 수동으로 확인했어요. 이상한 열린 포트를 발견했을 때, Nmap을 이용해서 어떤 서비스가 작동 중인지 확인했어요.</p>
<p>한 사례에서 bamboo.target.com이라는 호스트가 있었고, 포트 54663이 열려 있다는 것을 알았어요.</p>
<p>-sSCV 플래그와 함께 Nmap을 사용했을 때, Apache ActiveMQ가 실행 중이라는 것을 확인했고, 최신 버전의 CVE-2023-46604가 있었어요.</p>
<p>그런 다음 해당 취약점을 쉽게 적용했는데, 바로 작동했어요. 상세 보고서를 작성했고, 이는 현명한 선택이었어요. 트리저와 보안팀에 필요한 모든 정보를 제공하는 것은 자신의 노력에 대한 좋은 보상을 가져다주곤 해요.</p>
<p>아래는 제 결과에 대한 이미지입니다</p>
<p><img src="/assets/img/2024-05-15-HowIFoundMyFirstRCE_0.png" alt="이미지1"></p>
<p>그 결과에 대한 이미지도 있습니다</p>
<p><img src="/assets/img/2024-05-15-HowIFoundMyFirstRCE_1.png" alt="이미지2"></p>
<p>그게 다야! 시간 내어 주셔서 감사합니다. LinkedIn이나 Twitter도 부담 갖지 마시고 방문해주세요 — 거기서 친구를 찾고 있어요!</p>
<h1>찬양합니다. 주님, 우리에게 깨닫는 것은 주님의 가르침밖에 없습니다. 우리의 마지막 기도는 모든 찬양을 받으시는 세계의 주님 하나님께로부터 오는 것입니다.</h1>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"첫 번째 RCE를 발견한 방법","description":"","date":"2024-05-15 11:46","slug":"2024-05-15-HowIFoundMyFirstRCE","content":"\n\n안녕하세요 여러분! 이 글에서는 제 첫 RCE 경험에 대해 이야기하려고 해요. 제가 Apache ActiveMQ에서 발생한 CVE-2023-46604로 발생한 사건이죠. 전문적인 버그 헌터를 위한 새로운 정보를 제공하는 것보다는 어떻게 발견했는지에 더 초점을 맞출 거에요.\n\n저의 탐색 과정에서, 매주 서브도메인 목록을 업데이트하고 3일마다(하루에 한 번 하는 것이 더 좋겠지만) 열린 포트를 스캔했어요. 서브도메인 열람을 위해 Subfinder와 Amass 같은 도구를 사용했어요.\n\n```js\nsubfinder -dL domains.txt -o subdomains.txt\n#그리고 서브도메인의 서브도메인\nsubfinder -dL subdomains.txt -o more-subdomains.txt\n\n#Amass 사용\namass enum -passive -norecursive -noalts -df domains.txt -o subs.txt\n#그리고 서브도메인의 서브도메인\namass enum -passive -norecursive -noalts -df subs.txt -o more-subs.txt\n```\n\n\n\n아래와 같이 하세요:\n\n```bash\ncat more-subdomains.txt subdomains.txt subs.txt more-subs.txt | sort -u \u003e targets.txt\n```\n\n이후에는 몇 가지 경우에는 많은 수의 서브도메인이 생기기도 하는데, 때로는 5천개 이상이 될 때도 있습니다. DNSx를 사용하여 서브도메인을 확인하는 간단한 스크립트를 만들어 15개씩 그룹으로 나누었습니다. 그런 다음, 백그라운드에서 계속 실행하기 위해 nohup을 사용하여 Naabu를 실행했습니다.\n\n사용한 스크립트\n\n\n\n```sh\n#!/bin/bash\n\nif [ $# -eq 0 ]; then\n    echo \"사용법: $0 \u003cfile\u003e\"\n    exit 1\nfi\n\ncat $1 | dnsx -o $1_ok.txt\n\nsplit -l 15 $1_ok.txt 15_file_\n\nfor file in 15_file_*; do\n    nohup naabu -list \"$file\" -p - -o \"${file}.out\"\u0026\ndone\n```\n\n그리고\n\n```sh\ncat 15*out | sort -u \u003e ports.out \n```\n\n많은 시간 동안 그 목록을 수동으로 확인했습니다. 저는 허니팟일 가능성이 있는 호스트를 필터링했고, 때로는 Naabu가 신뢰할 수 없는 결과를 제공했습니다.```\n\n\n\n그리고 그 이후에, 3부터 10 사이의 열린 포트를 가진 호스트를 수동으로 확인했어요. 이상한 열린 포트를 발견했을 때, Nmap을 이용해서 어떤 서비스가 작동 중인지 확인했어요.\n\n한 사례에서 bamboo.target.com이라는 호스트가 있었고, 포트 54663이 열려 있다는 것을 알았어요.\n\n-sSCV 플래그와 함께 Nmap을 사용했을 때, Apache ActiveMQ가 실행 중이라는 것을 확인했고, 최신 버전의 CVE-2023-46604가 있었어요.\n\n그런 다음 해당 취약점을 쉽게 적용했는데, 바로 작동했어요. 상세 보고서를 작성했고, 이는 현명한 선택이었어요. 트리저와 보안팀에 필요한 모든 정보를 제공하는 것은 자신의 노력에 대한 좋은 보상을 가져다주곤 해요.\n\n\n\n아래는 제 결과에 대한 이미지입니다\n\n![이미지1](/assets/img/2024-05-15-HowIFoundMyFirstRCE_0.png)\n\n그 결과에 대한 이미지도 있습니다\n\n![이미지2](/assets/img/2024-05-15-HowIFoundMyFirstRCE_1.png)\n\n그게 다야! 시간 내어 주셔서 감사합니다. LinkedIn이나 Twitter도 부담 갖지 마시고 방문해주세요 — 거기서 친구를 찾고 있어요!\n\n\n\n# 찬양합니다. 주님, 우리에게 깨닫는 것은 주님의 가르침밖에 없습니다. 우리의 마지막 기도는 모든 찬양을 받으시는 세계의 주님 하나님께로부터 오는 것입니다.","ogImage":{"url":"/assets/img/2024-05-15-HowIFoundMyFirstRCE_0.png"},"coverImage":"/assets/img/2024-05-15-HowIFoundMyFirstRCE_0.png","tag":["Tech"],"readingTime":2},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e안녕하세요 여러분! 이 글에서는 제 첫 RCE 경험에 대해 이야기하려고 해요. 제가 Apache ActiveMQ에서 발생한 CVE-2023-46604로 발생한 사건이죠. 전문적인 버그 헌터를 위한 새로운 정보를 제공하는 것보다는 어떻게 발견했는지에 더 초점을 맞출 거에요.\u003c/p\u003e\n\u003cp\u003e저의 탐색 과정에서, 매주 서브도메인 목록을 업데이트하고 3일마다(하루에 한 번 하는 것이 더 좋겠지만) 열린 포트를 스캔했어요. 서브도메인 열람을 위해 Subfinder와 Amass 같은 도구를 사용했어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esubfinder -dL domains.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e -o subdomains.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n#그리고 서브도메인의 서브도메인\nsubfinder -dL subdomains.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e -o more-subdomains.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n\n#\u003cspan class=\"hljs-title class_\"\u003eAmass\u003c/span\u003e 사용\namass enum -passive -norecursive -noalts -df domains.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e -o subs.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n#그리고 서브도메인의 서브도메인\namass enum -passive -norecursive -noalts -df subs.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e -o more-subs.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래와 같이 하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecat\u003c/span\u003e more-subdomains.txt subdomains.txt subs.txt more-subs.txt | \u003cspan class=\"hljs-built_in\"\u003esort\u003c/span\u003e -u \u003e targets.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이후에는 몇 가지 경우에는 많은 수의 서브도메인이 생기기도 하는데, 때로는 5천개 이상이 될 때도 있습니다. DNSx를 사용하여 서브도메인을 확인하는 간단한 스크립트를 만들어 15개씩 그룹으로 나누었습니다. 그런 다음, 백그라운드에서 계속 실행하기 위해 nohup을 사용하여 Naabu를 실행했습니다.\u003c/p\u003e\n\u003cp\u003e사용한 스크립트\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sh\"\u003e\u003cspan class=\"hljs-meta\"\u003e#!/bin/bash\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e [ \u003cspan class=\"hljs-variable\"\u003e$#\u003c/span\u003e -eq 0 ]; \u003cspan class=\"hljs-keyword\"\u003ethen\u003c/span\u003e\n    \u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"사용법: \u003cspan class=\"hljs-variable\"\u003e$0\u003c/span\u003e \u0026#x3C;file\u003e\"\u003c/span\u003e\n    \u003cspan class=\"hljs-built_in\"\u003eexit\u003c/span\u003e 1\n\u003cspan class=\"hljs-keyword\"\u003efi\u003c/span\u003e\n\n\u003cspan class=\"hljs-built_in\"\u003ecat\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003e$1\u003c/span\u003e | dnsx -o \u003cspan class=\"hljs-variable\"\u003e$1_ok\u003c/span\u003e.txt\n\n\u003cspan class=\"hljs-built_in\"\u003esplit\u003c/span\u003e -l 15 \u003cspan class=\"hljs-variable\"\u003e$1_ok\u003c/span\u003e.txt 15_file_\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e file \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e 15_file_*; \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e\n    \u003cspan class=\"hljs-built_in\"\u003enohup\u003c/span\u003e naabu -list \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e$file\u003c/span\u003e\"\u003c/span\u003e -p - -o \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e${file}\u003c/span\u003e.out\"\u003c/span\u003e\u0026#x26;\n\u003cspan class=\"hljs-keyword\"\u003edone\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sh\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecat\u003c/span\u003e 15*out | \u003cspan class=\"hljs-built_in\"\u003esort\u003c/span\u003e -u \u003e ports.out \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e많은 시간 동안 그 목록을 수동으로 확인했습니다. 저는 허니팟일 가능성이 있는 호스트를 필터링했고, 때로는 Naabu가 신뢰할 수 없는 결과를 제공했습니다.```\u003c/p\u003e\n\u003cp\u003e그리고 그 이후에, 3부터 10 사이의 열린 포트를 가진 호스트를 수동으로 확인했어요. 이상한 열린 포트를 발견했을 때, Nmap을 이용해서 어떤 서비스가 작동 중인지 확인했어요.\u003c/p\u003e\n\u003cp\u003e한 사례에서 bamboo.target.com이라는 호스트가 있었고, 포트 54663이 열려 있다는 것을 알았어요.\u003c/p\u003e\n\u003cp\u003e-sSCV 플래그와 함께 Nmap을 사용했을 때, Apache ActiveMQ가 실행 중이라는 것을 확인했고, 최신 버전의 CVE-2023-46604가 있었어요.\u003c/p\u003e\n\u003cp\u003e그런 다음 해당 취약점을 쉽게 적용했는데, 바로 작동했어요. 상세 보고서를 작성했고, 이는 현명한 선택이었어요. 트리저와 보안팀에 필요한 모든 정보를 제공하는 것은 자신의 노력에 대한 좋은 보상을 가져다주곤 해요.\u003c/p\u003e\n\u003cp\u003e아래는 제 결과에 대한 이미지입니다\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-HowIFoundMyFirstRCE_0.png\" alt=\"이미지1\"\u003e\u003c/p\u003e\n\u003cp\u003e그 결과에 대한 이미지도 있습니다\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-HowIFoundMyFirstRCE_1.png\" alt=\"이미지2\"\u003e\u003c/p\u003e\n\u003cp\u003e그게 다야! 시간 내어 주셔서 감사합니다. LinkedIn이나 Twitter도 부담 갖지 마시고 방문해주세요 — 거기서 친구를 찾고 있어요!\u003c/p\u003e\n\u003ch1\u003e찬양합니다. 주님, 우리에게 깨닫는 것은 주님의 가르침밖에 없습니다. 우리의 마지막 기도는 모든 찬양을 받으시는 세계의 주님 하나님께로부터 오는 것입니다.\u003c/h1\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-15-HowIFoundMyFirstRCE"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>