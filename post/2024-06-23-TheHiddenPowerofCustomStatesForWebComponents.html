<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>웹 컴포넌트에서 커스텀 상태의 숨겨진 힘 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="웹 컴포넌트에서 커스텀 상태의 숨겨진 힘 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="웹 컴포넌트에서 커스텀 상태의 숨겨진 힘 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents" data-gatsby-head="true"/><meta name="twitter:title" content="웹 컴포넌트에서 커스텀 상태의 숨겨진 힘 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 13:03" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">웹 컴포넌트에서 커스텀 상태의 숨겨진 힘</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="웹 컴포넌트에서 커스텀 상태의 숨겨진 힘" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>사용자 정의 요소의 진화 과정에서 중요한 단계</p>
<p><img src="/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png" alt="image"></p>
<p>이전에 썼던 "웹 컴포넌트가 이제 네이티브 폼 요소가 될 수 있게 되었고"와 "웹 컴포넌트의 네이티브 폼 유효성 검사"라는 기사에서, ElementInternals 속성에 대해 설명했었어요. 이 속성을 통해 사용자 정의 요소가 양식과 관련되도록 할 수 있게 되었죠.</p>
<p>이 인터페이스는 또한 개발자들이 사용자 정의 상태와 사용자 정의 요소를 연관시킬 수 있도록 하며, 이 상태에 기반하여 스타일을 입힐 수 있게 해줍니다.</p>
<div class="content-ad"></div>
<p>ElementInternals의 states 속성은 사용자 지정 요소가 있는 상태를 나타내는 CustomStateSet을 반환합니다. 이 CustomStateSet은 집합에 추가 및 제거를 가능하게 합니다.</p>
<p>집합의 각 상태는 문자열로 표시되며 현재 그에는 두 가지 유형의 구문이 있습니다:</p>
<ul>
<li>이전 구문: --mystate (향후 지원 중단 예정)</li>
<li>새로운 구문: mystate</li>
</ul>
<p>이러한 상태는 내장된 상태와 마찬가지로 사용자 지정 상태 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.</p>
<div class="content-ad"></div>
<p>예를 들어, 선택된 체크박스는 내장된 :checked 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.</p>
<pre><code class="hljs language-js">input[type=”checkbox”]:checked {
 <span class="hljs-attr">outline</span>: solid green;
}
</code></pre>
<p>다른 예로, 비활성화된 버튼은 :disabled 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">button</span>:disabled {
 <span class="hljs-attr">cursor</span>: not-allowed;
}
</code></pre>
<div class="content-ad"></div>
<p>비슷하게, 사용자 정의 상태를 포함하는 요소는 다음과 같은 방식으로 CSS에서 액세스할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 이전 구문 */</span>
my-<span class="hljs-attr">element</span>:--mystate {
  <span class="hljs-attr">color</span>: red;
}

<span class="hljs-comment">/* 새 구문 */</span>
my-<span class="hljs-attr">element</span>:<span class="hljs-title function_">state</span>(<span class="hljs-params">mystate</span>) {
  <span class="hljs-attr">color</span>: red;
}
</code></pre>
<h1>사용자 정의 상태의 사용 사례</h1>
<p>사용자 정의 상태는 강력한 기능을 해제합니다.</p>
<div class="content-ad"></div>
<p>내부 상태에 기반을 둔 Web Components의 스타일링을 지원하기 때문에 이러한 상태를 반영하기 위해 컴포넌트에 속성이나 클래스를 추가할 필요가 없어요. 따라서 완전히 내부적으로 유지됩니다.</p>
<p>예를 들어, <code>video-player</code> 컴포넌트가 있고 이 컴포넌트는 비디오를 재생하는 데 사용되는 재생 버튼을 표시합니다.</p>
<p>재생 버튼을 클릭하면 비디오가 재생되고, 이 때 재생 버튼이 숨겨지고 일시 정지 버튼이 표시되기를 원합니다.</p>
<p>그런 후 일시 정지 버튼을 클릭하면 이 버튼이 숨겨지고 재생 버튼이 다시 표시되어야 합니다.</p>
<div class="content-ad"></div>
<p>이 작업을 간단히 수행하는 방법은 플레이 속성을 소개하고 해당 속성을 반영하고 :host 가상 클래스를 사용하여 버튼을 표시하거나 숨기는 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VideoPlayer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>();

    <span class="hljs-keyword">const</span> shadowRoot = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>({<span class="hljs-attr">mode</span>: <span class="hljs-string">'open'</span>});

    shadowRoot.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`
      &#x3C;style>
        :host {
          display: block;
          width: 300px;
          height: 300px;
          border: 2px solid red;
          display: flex;
          justify-content: center;
          align-items: center;
          background-color: transparent;
        }

        #pause {
          display: none;
        }

        :host([playing]) #play {
          display: none;
        }

        :host([playing]) #pause {
          display: block;
        }
      &#x3C;/style>

      &#x3C;button id="play" type="button">Play&#x3C;/button>
      &#x3C;button id="pause" type="button">Pause&#x3C;/button
    `</span>;
  }

  <span class="hljs-title function_">connectedCallback</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> playButton = <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadowRoot</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#play'</span>);
    <span class="hljs-keyword">const</span> pauseButton = <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadowRoot</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#pause'</span>);

    playButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =></span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">playing</span> = <span class="hljs-literal">true</span>;
    });

    pauseButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =></span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">playing</span> = <span class="hljs-literal">false</span>;
    });
  }

  <span class="hljs-keyword">get</span> <span class="hljs-title function_">playing</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">'playing'</span>);
  }

  <span class="hljs-keyword">set</span> <span class="hljs-title function_">playing</span>(<span class="hljs-params">isPlaying</span>) {
    <span class="hljs-keyword">if</span>(isPlaying) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">'playing'</span>, <span class="hljs-string">''</span>);
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeAttribute</span>(<span class="hljs-string">'playing'</span>);
    }
  }
}
</code></pre>
<p>기본적으로 재생 버튼이 표시됩니다. 플레이 속성을 위한 설정자가 정의되어 해당 속성을 설정하거나 제거하며 CSS 규칙은 :host 가상 클래스를 사용하여 버튼을 표시하거나 숨기는 역할을 합니다.</p>
<p>아래에 작동하는 예제가 있습니다:</p>
<div class="content-ad"></div>
<p>이 방법은 잘 작동하지만 이 구현에 잠재적인 문제가 있을 수 있어요.</p>
<p>이렇게 내부 속성을 속성으로 노출하는 것은 항상 바람직하지 않을 수 있고 캡슐화를 깨버릴 수 있어요.</p>
<p>이 경우 playing 속성을 노출하는 것은 나쁜 생각은 아닐 수 있지만, 이는 사용자가 그냥 속성을 추가함으로써 컴포넌트를 재생 상태로 수동 설정할 수 있지만, 실제로 비디오가 재생되는 것은 아니라는 점이에요.</p>
<p>이 속성을 노출함으로써 사용자가 playing 속성을 추가하기만 하면 비디오를 재생할 수 있다는 기대감조차 줄 수 있어요.</p>
<div class="content-ad"></div>
<p>사실 특정 상태의 웹 컴포넌트를 설정하기 위해 속성을 추가하는 것은 해당 상태를 설정하는 것이 아니기 때문에 playing 속성을 true로 설정하지 않습니다. playing 속성에 playing 속성을 추가하는 것만으로 playing 속성을 true로 설정하지는 않습니다.</p>
<p>이 경우 실제로 심각한 피해를 입히지는 않겠지만 내부 속성을 노출하는 것이 좋지 않은 경우가 항상 있을 수 있습니다.</p>
<p>이것은 사용자 정의 상태에 대한 완벽한 사용 사례입니다. 속성은 노출되지 않지만 이러한 상태에 기반한 CSS 스타일을 사용하여 컴포넌트를 여전히 스타일링할 수 있습니다.</p>
<h1>사용자 정의 상태 추가 및 제거</h1>
<div class="content-ad"></div>
<p>언급한 바와 같이 모든 사용자 지정 상태는 ElementInternals 인터페이스의 states 속성에 저장된 CustomStateSet 객체에 저장됩니다.</p>
<p>상태를 추가하고 제거하는 데 사용되는 add 및 delete 메서드와 요소가 특정 상태를 갖고 있는지 확인하는 has 메서드가 있습니다.</p>
<p>다른 주목할 만한 메서드로는 모든 상태를 지우는 clear 및 요소의 모든 상태를 반복하는 forEach가 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 내부 구현 부착</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachInternals</span>();

<span class="hljs-comment">// 상태 추가 예전 문법</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'--foo'</span>);

<span class="hljs-comment">// 상태 추가 새 문법</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'bar'</span>);

<span class="hljs-comment">// 상태 반복</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">state</span> =></span> {
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state); <span class="hljs-comment">// foo bar</span>
});

<span class="hljs-comment">// 상태 제거 예전 문법</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'--bar'</span>);

<span class="hljs-comment">// 상태 제거 새 문법</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'bar'</span>);

<span class="hljs-comment">// 상태 존재 여부 확인 예전 문법</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">'--foo'</span>); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">'--bar'</span>); <span class="hljs-comment">// false</span>

<span class="hljs-comment">// 상태 존재 여부 확인 새 문법</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">'foo'</span>); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">'bar'</span>); <span class="hljs-comment">// false</span>
</code></pre>
<div class="content-ad"></div>
<p>브라우저에서 오래된 구문만 지원하는 경우 --로 시작하지 않는 상태를 추가하려고 할 때 오류가 발생합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachInternals</span>();
<span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'foo'</span>); <span class="hljs-comment">// 오류, '--'로 시작하지 않음 (오래된 구문만 지원)</span>
</code></pre>
<p>이전 예제가 사용자 정의 상태와 함께 작동하도록 하려면 <code>playing</code> 속성의 게터 및 세터를 상태와 함께 작동하도록 변경해야 합니다. 이를 오래된 및 새로운 구문을 지원하는 브라우저에서 작동하도록 하려면 --없이 상태를 설정하는 것은 try/catch 블록으로 감싸야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">get</span> <span class="hljs-title function_">playing</span>() {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">'--playing'</span>) || <span class="hljs-variable language_">this</span>.#internals.<span class="hljs-property">states</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">'playing'</span>);
}

<span class="hljs-keyword">set</span> <span class="hljs-title function_">playing</span>(<span class="hljs-params">isPlaying</span>) {
  <span class="hljs-keyword">if</span>(isPlaying) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'playing'</span>);
    }
    <span class="hljs-keyword">catch</span>(e) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'--playing'</span>);
    }
  }
  <span class="hljs-keyword">else</span> {
   <span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'playing'</span>);
   <span class="hljs-variable language_">this</span>.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'--playing'</span>);
  }
}
</code></pre>
<div class="content-ad"></div>
<p>테이블 태그를 마크다운 형식으로 변경했습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 이전 구문 */</span>
<span class="hljs-title function_">host</span>(:--playing) #play {
  <span class="hljs-attr">display</span>: none;
}

<span class="hljs-comment">/* 이전 구문 */</span>
:<span class="hljs-title function_">host</span>(:--playing) #pause {
  <span class="hljs-attr">display</span>: block;
}

<span class="hljs-comment">/* 새로운 구문 */</span>
<span class="hljs-title function_">host</span>(:<span class="hljs-title function_">state</span>(playing)) #play {
  <span class="hljs-attr">display</span>: none;
}

<span class="hljs-comment">/* 새로운 구문 */</span>
:<span class="hljs-title function_">host</span>(:<span class="hljs-title function_">state</span>(playing)) #pause {
  <span class="hljs-attr">display</span>: block;
}
</code></pre>
<p>내부 속성이 속성으로 노출되지 않도록 하는 것은 좋지만, 여전히 소비자가 내부 속성을 통해 상태에 액세스하고 add 및 delete 메서드를 호출하여 상태를 추가하거나 제거할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> player = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'video-player'</span>);

<span class="hljs-comment">// 이전 구문</span>
player.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'--playing'</span>);

<span class="hljs-comment">// 새로운 구문</span>
player.<span class="hljs-property">internals</span>.<span class="hljs-property">states</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'playing'</span>);
</code></pre>
<div class="content-ad"></div>
<p>더 좋지 않은 점은 소비자가 내부 상태를 변경하기 위해 playing의 setter를 호출할 수 있다는 것입니다.</p>
<p>이를 수정하여 getter와 setter 및 내부 속성을 모두 #으로 접두사를 붙여 private로 만들 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// internals is now private</span>
<span class="hljs-variable language_">this</span>.#internals = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachInternals</span>();

<span class="hljs-keyword">get</span> <span class="hljs-title function_">playing</span>() {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#internals.<span class="hljs-property">states</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">'--playing'</span>) || <span class="hljs-variable language_">this</span>.#internals.<span class="hljs-property">states</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">'playing'</span>);
}

<span class="hljs-keyword">set</span> <span class="hljs-title function_">playing</span>(<span class="hljs-params">isPlaying</span>) {
  <span class="hljs-keyword">if</span>(isPlaying) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-variable language_">this</span>.#internals.<span class="hljs-property">states</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'playing'</span>);
    }
    <span class="hljs-keyword">catch</span>(e) {
      <span class="hljs-variable language_">this</span>.#internals.<span class="hljs-property">states</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'--playing'</span>);
    }
        
  }
  <span class="hljs-keyword">else</span> {
   <span class="hljs-variable language_">this</span>.#internals.<span class="hljs-property">states</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'playing'</span>);
   <span class="hljs-variable language_">this</span>.#internals.<span class="hljs-property">states</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'--playing'</span>);
  }
}
</code></pre>
<p>private 속성에 대한 getter와 setter 쌍을 작성하는 것이 직관적이지 않을 수 있지만, 이것이 실제로 작동한다는 것에 주목하세요.</p>
<div class="content-ad"></div>
<p>비록 playing에 getter와 setter가 정의되어 있지만, 여전히 private이며 클래스 내에서만 접근 가능합니다.</p>
<p>값을 할당하면 setter가 호출되고 값을 읽으면 getter가 호출됩니다.</p>
<p>아래에 전체 코드가 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">VideoPlayer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {
  #internals;  <span class="hljs-comment">// private property를 필요로 하는 클래스 필드</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>();

    <span class="hljs-keyword">const</span> shadowRoot = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>({<span class="hljs-attr">mode</span>: <span class="hljs-string">'open'</span>});

    <span class="hljs-variable language_">this</span>.#internals = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachInternals</span>();

    shadowRoot.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`
      &#x3C;style>
        :host {
          width: 300px;
          height: 300px;
          border: 2px solid red;
          display: flex;
          justify-content: center;
          align-items: center;
          background-color: transparent;
        }

        #pause {
          display: none;
        }

        /* 예전 문법 */
        :host(:--playing) #play {
          display: none;
        }

        :host(:--playing) #pause {
          display: block;
        }

        /* 새로운 문법 */
        :host(:state(playing)) #play {
          display: none;
        }

        :host(:state(playing)) #pause {
          display: block;
        }
      &#x3C;/style>

      &#x3C;button id="play" type="button">재생&#x3C;/button>
      &#x3C;button id="pause" type="button">일시정지&#x3C;/button>
    `</span>;
  }

  <span class="hljs-title function_">connectedCallback</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> playButton = <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadowRoot</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#play'</span>);
    <span class="hljs-keyword">const</span> pauseButton = <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadowRoot</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'#pause'</span>);

    playButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =></span> {
      <span class="hljs-variable language_">this</span>.#playing = <span class="hljs-literal">true</span>;
    });

    pauseButton.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-function">() =></span> {
      <span class="hljs-variable language_">this</span>.#playing = <span class="hljs-literal">false</span>;
    });
  }

  <span class="hljs-keyword">get</span> <span class="hljs-title function_">playing</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#internals.<span class="hljs-property">states</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">'--playing'</span>) || <span class="hljs-variable language_">this</span>.#internals.<span class="hljs-property">states</span>.<span class="hljs-title function_">has</span>(<span class="hljs-string">'playing'</span>);
  }

  <span class="hljs-keyword">set</span> <span class="hljs-title function_">playing</span>(<span class="hljs-params">isPlaying</span>) {
    <span class="hljs-keyword">if</span>(isPlaying) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-variable language_">this</span>.#internals.<span class="hljs-property">states</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'playing'</span>);
      }
      <span class="hljs-keyword">catch</span>(e) {
        <span class="hljs-variable language_">this</span>.#internals.<span class="hljs-property">states</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">'--playing'</span>);
      }
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">this</span>.#internals.<span class="hljs-property">states</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'playing'</span>);
      <span class="hljs-variable language_">this</span>.#internals.<span class="hljs-property">states</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-string">'--playing'</span>);
    }
  }
}
</code></pre>
<div class="content-ad"></div>
<p>그리고 여기에는 오래된 구문과 새 구문 둘 다 작동하는 작동 예제가 있습니다:</p>
<p>이 예제들은 커스텀 상태에 기반하여 커스텀 요소를 내부 컴포넌트 내에서 :host 가상 클래스를 사용하여 스타일링하는 방법을 보여줍니다.</p>
<p>커스텀 요소는 사용자 정의 상태에 기반하여 외부에서 스타일링될 수도 있습니다.</p>
<p>이 스타일링은 :checked나 :hover와 같은 내장 상태에 기반하여 구성 요소를 스타일링하는 것과 동일한 형태를 가지고 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 예전 구문 */</span>
video-<span class="hljs-attr">player</span>:--playing {
  <span class="hljs-attr">border</span>: 1px solid red;
}

<span class="hljs-comment">/* 새로운 구문 */</span>
video-<span class="hljs-attr">player</span>:<span class="hljs-title function_">state</span>(<span class="hljs-params">playing</span>) {
  <span class="hljs-attr">border</span>: 1px solid red;
}
</code></pre>
<p>같은 CSS 속성에 대한 사용자 지정 상태를 기반으로 스타일 지정이 내부와 외부에서 모두 정의된 경우, 외부에서 정의된 스타일이 우선합니다.</p>
<p>다음 예제에서 컴포넌트는 --playing/playing 사용자 지정 상태일 때 녹색 테두리가 추가됩니다.</p>
<p>--playing/playing 상태에 대해 컴포넌트 내부에서 정의된 파란색 테두리는 덮어씌워집니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">// 컴포넌트 외부에서 정의된 스타일</span>
<span class="hljs-comment">// 이렇게 하면 컴포넌트에 녹색 테두리가 우선적으로 적용됩니다.</span>
<span class="hljs-comment">// 이전 구문</span>
video-<span class="hljs-attr">player</span>:--playing {
  <span class="hljs-attr">border</span>: 2px solid green;
}

<span class="hljs-comment">// 새로운 구문</span>
video-<span class="hljs-attr">player</span>:<span class="hljs-title function_">state</span>(<span class="hljs-params">playing</span>) {
  <span class="hljs-attr">border</span>: 2px solid green;
}

<span class="hljs-comment">// 컴포넌트 내부에서 정의된 스타일</span>
<span class="hljs-comment">// 외부에서 정의된 스타일에 덮어씌워지게 됩니다.</span>
<span class="hljs-comment">// 이전 구문</span>
:<span class="hljs-title function_">host</span>(<span class="hljs-params">:--playing</span>) {
  <span class="hljs-attr">border</span>: 2px solid blue;
}

<span class="hljs-comment">// 새로운 구문</span>
:<span class="hljs-title function_">host</span>(<span class="hljs-params">:state(playing)</span>) {
  <span class="hljs-attr">border</span>: 2px solid blue;
}
</code></pre>
<h1>결론</h1>
<p>사용자 정의 상태(Custom States)는 웹 컴포넌트의 진화를 위한 중요한 단계입니다.</p>
<p>이를 통해 컴포넌트의 상태를 속성이나 클래스를 추가하지 않고도 스타일링할 수 있어 외부에서 상태를 조작할 수 없도록 유지할 수 있습니다.</p>
<div class="content-ad"></div>
<p>커스텀 상태는 Chrome, Edge, Safari Tech Preview 187에서는 CustomStateSet 기능 플래그가 활성화되어 있고, Firefox 122에서는 dom.element.customstateset.enabled가 true로 설정되어 있을 때 지원됩니다.</p>
<p>현대 웹 플랫폼, 웹 컴포넌트, 그리고 Progressive Web Apps에 관한 제 주간 뉴스레터 'Modern Web Weekly'에 가입해보세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"웹 컴포넌트에서 커스텀 상태의 숨겨진 힘","description":"","date":"2024-06-23 13:03","slug":"2024-06-23-TheHiddenPowerofCustomStatesForWebComponents","content":"\n\n사용자 정의 요소의 진화 과정에서 중요한 단계\n\n![image](/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png)\n\n이전에 썼던 \"웹 컴포넌트가 이제 네이티브 폼 요소가 될 수 있게 되었고\"와 \"웹 컴포넌트의 네이티브 폼 유효성 검사\"라는 기사에서, ElementInternals 속성에 대해 설명했었어요. 이 속성을 통해 사용자 정의 요소가 양식과 관련되도록 할 수 있게 되었죠.\n\n이 인터페이스는 또한 개발자들이 사용자 정의 상태와 사용자 정의 요소를 연관시킬 수 있도록 하며, 이 상태에 기반하여 스타일을 입힐 수 있게 해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nElementInternals의 states 속성은 사용자 지정 요소가 있는 상태를 나타내는 CustomStateSet을 반환합니다. 이 CustomStateSet은 집합에 추가 및 제거를 가능하게 합니다.\n\n집합의 각 상태는 문자열로 표시되며 현재 그에는 두 가지 유형의 구문이 있습니다:\n\n- 이전 구문: --mystate (향후 지원 중단 예정)\n- 새로운 구문: mystate\n\n이러한 상태는 내장된 상태와 마찬가지로 사용자 지정 상태 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 선택된 체크박스는 내장된 :checked 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\n\n```js\ninput[type=”checkbox”]:checked {\n outline: solid green;\n}\n```\n\n다른 예로, 비활성화된 버튼은 :disabled 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\n\n```js\nbutton:disabled {\n cursor: not-allowed;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비슷하게, 사용자 정의 상태를 포함하는 요소는 다음과 같은 방식으로 CSS에서 액세스할 수 있습니다:\n\n```js\n/* 이전 구문 */\nmy-element:--mystate {\n  color: red;\n}\n\n/* 새 구문 */\nmy-element:state(mystate) {\n  color: red;\n}\n```\n\n# 사용자 정의 상태의 사용 사례\n\n사용자 정의 상태는 강력한 기능을 해제합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내부 상태에 기반을 둔 Web Components의 스타일링을 지원하기 때문에 이러한 상태를 반영하기 위해 컴포넌트에 속성이나 클래스를 추가할 필요가 없어요. 따라서 완전히 내부적으로 유지됩니다.\n\n예를 들어, `video-player` 컴포넌트가 있고 이 컴포넌트는 비디오를 재생하는 데 사용되는 재생 버튼을 표시합니다.\n\n재생 버튼을 클릭하면 비디오가 재생되고, 이 때 재생 버튼이 숨겨지고 일시 정지 버튼이 표시되기를 원합니다.\n\n그런 후 일시 정지 버튼을 클릭하면 이 버튼이 숨겨지고 재생 버튼이 다시 표시되어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n이 작업을 간단히 수행하는 방법은 플레이 속성을 소개하고 해당 속성을 반영하고 :host 가상 클래스를 사용하여 버튼을 표시하거나 숨기는 것입니다.\n\n```js\nclass VideoPlayer extends HTMLElement {\n\n  constructor() {\n    super();\n\n    const shadowRoot = this.attachShadow({mode: 'open'});\n\n    shadowRoot.innerHTML = `\n      \u003cstyle\u003e\n        :host {\n          display: block;\n          width: 300px;\n          height: 300px;\n          border: 2px solid red;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          background-color: transparent;\n        }\n\n        #pause {\n          display: none;\n        }\n\n        :host([playing]) #play {\n          display: none;\n        }\n\n        :host([playing]) #pause {\n          display: block;\n        }\n      \u003c/style\u003e\n\n      \u003cbutton id=\"play\" type=\"button\"\u003ePlay\u003c/button\u003e\n      \u003cbutton id=\"pause\" type=\"button\"\u003ePause\u003c/button\n    `;\n  }\n\n  connectedCallback() {\n    const playButton = this.shadowRoot.querySelector('#play');\n    const pauseButton = this.shadowRoot.querySelector('#pause');\n\n    playButton.addEventListener('click', () =\u003e {\n      this.playing = true;\n    });\n\n    pauseButton.addEventListener('click', () =\u003e {\n      this.playing = false;\n    });\n  }\n\n  get playing() {\n    return this.hasAttribute('playing');\n  }\n\n  set playing(isPlaying) {\n    if(isPlaying) {\n      this.setAttribute('playing', '');\n    }\n    else {\n      this.removeAttribute('playing');\n    }\n  }\n}\n```\n\n기본적으로 재생 버튼이 표시됩니다. 플레이 속성을 위한 설정자가 정의되어 해당 속성을 설정하거나 제거하며 CSS 규칙은 :host 가상 클래스를 사용하여 버튼을 표시하거나 숨기는 역할을 합니다.\n\n아래에 작동하는 예제가 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법은 잘 작동하지만 이 구현에 잠재적인 문제가 있을 수 있어요.\n\n이렇게 내부 속성을 속성으로 노출하는 것은 항상 바람직하지 않을 수 있고 캡슐화를 깨버릴 수 있어요.\n\n이 경우 playing 속성을 노출하는 것은 나쁜 생각은 아닐 수 있지만, 이는 사용자가 그냥 속성을 추가함으로써 컴포넌트를 재생 상태로 수동 설정할 수 있지만, 실제로 비디오가 재생되는 것은 아니라는 점이에요.\n\n이 속성을 노출함으로써 사용자가 playing 속성을 추가하기만 하면 비디오를 재생할 수 있다는 기대감조차 줄 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사실 특정 상태의 웹 컴포넌트를 설정하기 위해 속성을 추가하는 것은 해당 상태를 설정하는 것이 아니기 때문에 playing 속성을 true로 설정하지 않습니다. playing 속성에 playing 속성을 추가하는 것만으로 playing 속성을 true로 설정하지는 않습니다.\n\n이 경우 실제로 심각한 피해를 입히지는 않겠지만 내부 속성을 노출하는 것이 좋지 않은 경우가 항상 있을 수 있습니다.\n\n이것은 사용자 정의 상태에 대한 완벽한 사용 사례입니다. 속성은 노출되지 않지만 이러한 상태에 기반한 CSS 스타일을 사용하여 컴포넌트를 여전히 스타일링할 수 있습니다.\n\n# 사용자 정의 상태 추가 및 제거\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n언급한 바와 같이 모든 사용자 지정 상태는 ElementInternals 인터페이스의 states 속성에 저장된 CustomStateSet 객체에 저장됩니다.\n\n상태를 추가하고 제거하는 데 사용되는 add 및 delete 메서드와 요소가 특정 상태를 갖고 있는지 확인하는 has 메서드가 있습니다.\n\n다른 주목할 만한 메서드로는 모든 상태를 지우는 clear 및 요소의 모든 상태를 반복하는 forEach가 있습니다:\n\n```js\n// 내부 구현 부착\nthis.internals = this.attachInternals();\n\n// 상태 추가 예전 문법\nthis.internals.states.add('--foo');\n\n// 상태 추가 새 문법\nthis.internals.states.add('bar');\n\n// 상태 반복\nthis.internals.states.forEach(state =\u003e {\n console.log(state); // foo bar\n});\n\n// 상태 제거 예전 문법\nthis.internals.states.delete('--bar');\n\n// 상태 제거 새 문법\nthis.internals.states.delete('bar');\n\n// 상태 존재 여부 확인 예전 문법\nthis.internals.states.has('--foo'); // true\nthis.internals.states.has('--bar'); // false\n\n// 상태 존재 여부 확인 새 문법\nthis.internals.states.has('foo'); // true\nthis.internals.states.has('bar'); // false\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n브라우저에서 오래된 구문만 지원하는 경우 --로 시작하지 않는 상태를 추가하려고 할 때 오류가 발생합니다:\n\n```js\nthis.internals = this.attachInternals();\nthis.internals.states.add('foo'); // 오류, '--'로 시작하지 않음 (오래된 구문만 지원)\n```\n\n이전 예제가 사용자 정의 상태와 함께 작동하도록 하려면 `playing` 속성의 게터 및 세터를 상태와 함께 작동하도록 변경해야 합니다. 이를 오래된 및 새로운 구문을 지원하는 브라우저에서 작동하도록 하려면 --없이 상태를 설정하는 것은 try/catch 블록으로 감싸야 합니다:\n\n```js\nget playing() {\n  return this.internals.states.has('--playing') || this.#internals.states.has('playing');\n}\n\nset playing(isPlaying) {\n  if(isPlaying) {\n    try {\n      this.internals.states.add('playing');\n    }\n    catch(e) {\n      this.internals.states.add('--playing');\n    }\n  }\n  else {\n   this.internals.states.delete('playing');\n   this.internals.states.delete('--playing');\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경했습니다.\n\n```js\n/* 이전 구문 */\nhost(:--playing) #play {\n  display: none;\n}\n\n/* 이전 구문 */\n:host(:--playing) #pause {\n  display: block;\n}\n\n/* 새로운 구문 */\nhost(:state(playing)) #play {\n  display: none;\n}\n\n/* 새로운 구문 */\n:host(:state(playing)) #pause {\n  display: block;\n}\n```\n\n내부 속성이 속성으로 노출되지 않도록 하는 것은 좋지만, 여전히 소비자가 내부 속성을 통해 상태에 액세스하고 add 및 delete 메서드를 호출하여 상태를 추가하거나 제거할 수 있습니다:\n\n```js\nconst player = document.querySelector('video-player');\n\n// 이전 구문\nplayer.internals.states.add('--playing');\n\n// 새로운 구문\nplayer.internals.states.add('playing');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 좋지 않은 점은 소비자가 내부 상태를 변경하기 위해 playing의 setter를 호출할 수 있다는 것입니다.\n\n이를 수정하여 getter와 setter 및 내부 속성을 모두 #으로 접두사를 붙여 private로 만들 수 있습니다:\n\n```js\n// internals is now private\nthis.#internals = this.attachInternals();\n\nget playing() {\n  return this.#internals.states.has('--playing') || this.#internals.states.has('playing');\n}\n\nset playing(isPlaying) {\n  if(isPlaying) {\n    try {\n      this.#internals.states.add('playing');\n    }\n    catch(e) {\n      this.#internals.states.add('--playing');\n    }\n        \n  }\n  else {\n   this.#internals.states.delete('playing');\n   this.#internals.states.delete('--playing');\n  }\n}\n```\n\nprivate 속성에 대한 getter와 setter 쌍을 작성하는 것이 직관적이지 않을 수 있지만, 이것이 실제로 작동한다는 것에 주목하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비록 playing에 getter와 setter가 정의되어 있지만, 여전히 private이며 클래스 내에서만 접근 가능합니다.\n\n값을 할당하면 setter가 호출되고 값을 읽으면 getter가 호출됩니다.\n\n아래에 전체 코드가 있습니다:\n\n```js\nclass VideoPlayer extends HTMLElement {\n  #internals;  // private property를 필요로 하는 클래스 필드\n\n  constructor() {\n    super();\n\n    const shadowRoot = this.attachShadow({mode: 'open'});\n\n    this.#internals = this.attachInternals();\n\n    shadowRoot.innerHTML = `\n      \u003cstyle\u003e\n        :host {\n          width: 300px;\n          height: 300px;\n          border: 2px solid red;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          background-color: transparent;\n        }\n\n        #pause {\n          display: none;\n        }\n\n        /* 예전 문법 */\n        :host(:--playing) #play {\n          display: none;\n        }\n\n        :host(:--playing) #pause {\n          display: block;\n        }\n\n        /* 새로운 문법 */\n        :host(:state(playing)) #play {\n          display: none;\n        }\n\n        :host(:state(playing)) #pause {\n          display: block;\n        }\n      \u003c/style\u003e\n\n      \u003cbutton id=\"play\" type=\"button\"\u003e재생\u003c/button\u003e\n      \u003cbutton id=\"pause\" type=\"button\"\u003e일시정지\u003c/button\u003e\n    `;\n  }\n\n  connectedCallback() {\n    const playButton = this.shadowRoot.querySelector('#play');\n    const pauseButton = this.shadowRoot.querySelector('#pause');\n\n    playButton.addEventListener('click', () =\u003e {\n      this.#playing = true;\n    });\n\n    pauseButton.addEventListener('click', () =\u003e {\n      this.#playing = false;\n    });\n  }\n\n  get playing() {\n    return this.#internals.states.has('--playing') || this.#internals.states.has('playing');\n  }\n\n  set playing(isPlaying) {\n    if(isPlaying) {\n      try {\n        this.#internals.states.add('playing');\n      }\n      catch(e) {\n        this.#internals.states.add('--playing');\n      }\n    }\n    else {\n      this.#internals.states.delete('playing');\n      this.#internals.states.delete('--playing');\n    }\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 여기에는 오래된 구문과 새 구문 둘 다 작동하는 작동 예제가 있습니다:\n\n이 예제들은 커스텀 상태에 기반하여 커스텀 요소를 내부 컴포넌트 내에서 :host 가상 클래스를 사용하여 스타일링하는 방법을 보여줍니다.\n\n커스텀 요소는 사용자 정의 상태에 기반하여 외부에서 스타일링될 수도 있습니다.\n\n이 스타일링은 :checked나 :hover와 같은 내장 상태에 기반하여 구성 요소를 스타일링하는 것과 동일한 형태를 가지고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/* 예전 구문 */\nvideo-player:--playing {\n  border: 1px solid red;\n}\n\n/* 새로운 구문 */\nvideo-player:state(playing) {\n  border: 1px solid red;\n}\n```\n\n같은 CSS 속성에 대한 사용자 지정 상태를 기반으로 스타일 지정이 내부와 외부에서 모두 정의된 경우, 외부에서 정의된 스타일이 우선합니다.\n\n다음 예제에서 컴포넌트는 --playing/playing 사용자 지정 상태일 때 녹색 테두리가 추가됩니다.\n\n--playing/playing 상태에 대해 컴포넌트 내부에서 정의된 파란색 테두리는 덮어씌워집니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 컴포넌트 외부에서 정의된 스타일\n// 이렇게 하면 컴포넌트에 녹색 테두리가 우선적으로 적용됩니다.\n// 이전 구문\nvideo-player:--playing {\n  border: 2px solid green;\n}\n\n// 새로운 구문\nvideo-player:state(playing) {\n  border: 2px solid green;\n}\n\n// 컴포넌트 내부에서 정의된 스타일\n// 외부에서 정의된 스타일에 덮어씌워지게 됩니다.\n// 이전 구문\n:host(:--playing) {\n  border: 2px solid blue;\n}\n\n// 새로운 구문\n:host(:state(playing)) {\n  border: 2px solid blue;\n}\n```\n\n# 결론\n\n사용자 정의 상태(Custom States)는 웹 컴포넌트의 진화를 위한 중요한 단계입니다.\n\n이를 통해 컴포넌트의 상태를 속성이나 클래스를 추가하지 않고도 스타일링할 수 있어 외부에서 상태를 조작할 수 없도록 유지할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n커스텀 상태는 Chrome, Edge, Safari Tech Preview 187에서는 CustomStateSet 기능 플래그가 활성화되어 있고, Firefox 122에서는 dom.element.customstateset.enabled가 true로 설정되어 있을 때 지원됩니다.\n\n현대 웹 플랫폼, 웹 컴포넌트, 그리고 Progressive Web Apps에 관한 제 주간 뉴스레터 'Modern Web Weekly'에 가입해보세요.","ogImage":{"url":"/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png"},"coverImage":"/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e사용자 정의 요소의 진화 과정에서 중요한 단계\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-TheHiddenPowerofCustomStatesForWebComponents_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이전에 썼던 \"웹 컴포넌트가 이제 네이티브 폼 요소가 될 수 있게 되었고\"와 \"웹 컴포넌트의 네이티브 폼 유효성 검사\"라는 기사에서, ElementInternals 속성에 대해 설명했었어요. 이 속성을 통해 사용자 정의 요소가 양식과 관련되도록 할 수 있게 되었죠.\u003c/p\u003e\n\u003cp\u003e이 인터페이스는 또한 개발자들이 사용자 정의 상태와 사용자 정의 요소를 연관시킬 수 있도록 하며, 이 상태에 기반하여 스타일을 입힐 수 있게 해줍니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eElementInternals의 states 속성은 사용자 지정 요소가 있는 상태를 나타내는 CustomStateSet을 반환합니다. 이 CustomStateSet은 집합에 추가 및 제거를 가능하게 합니다.\u003c/p\u003e\n\u003cp\u003e집합의 각 상태는 문자열로 표시되며 현재 그에는 두 가지 유형의 구문이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이전 구문: --mystate (향후 지원 중단 예정)\u003c/li\u003e\n\u003cli\u003e새로운 구문: mystate\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 상태는 내장된 상태와 마찬가지로 사용자 지정 상태 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예를 들어, 선택된 체크박스는 내장된 :checked 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einput[type=”checkbox”]:checked {\n \u003cspan class=\"hljs-attr\"\u003eoutline\u003c/span\u003e: solid green;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 예로, 비활성화된 버튼은 :disabled 가상 클래스를 사용하여 CSS에서 액세스할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003ebutton\u003c/span\u003e:disabled {\n \u003cspan class=\"hljs-attr\"\u003ecursor\u003c/span\u003e: not-allowed;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e비슷하게, 사용자 정의 상태를 포함하는 요소는 다음과 같은 방식으로 CSS에서 액세스할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 이전 구문 */\u003c/span\u003e\nmy-\u003cspan class=\"hljs-attr\"\u003eelement\u003c/span\u003e:--mystate {\n  \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: red;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e/* 새 구문 */\u003c/span\u003e\nmy-\u003cspan class=\"hljs-attr\"\u003eelement\u003c/span\u003e:\u003cspan class=\"hljs-title function_\"\u003estate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emystate\u003c/span\u003e) {\n  \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: red;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e사용자 정의 상태의 사용 사례\u003c/h1\u003e\n\u003cp\u003e사용자 정의 상태는 강력한 기능을 해제합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e내부 상태에 기반을 둔 Web Components의 스타일링을 지원하기 때문에 이러한 상태를 반영하기 위해 컴포넌트에 속성이나 클래스를 추가할 필요가 없어요. 따라서 완전히 내부적으로 유지됩니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, \u003ccode\u003evideo-player\u003c/code\u003e 컴포넌트가 있고 이 컴포넌트는 비디오를 재생하는 데 사용되는 재생 버튼을 표시합니다.\u003c/p\u003e\n\u003cp\u003e재생 버튼을 클릭하면 비디오가 재생되고, 이 때 재생 버튼이 숨겨지고 일시 정지 버튼이 표시되기를 원합니다.\u003c/p\u003e\n\u003cp\u003e그런 후 일시 정지 버튼을 클릭하면 이 버튼이 숨겨지고 재생 버튼이 다시 표시되어야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 작업을 간단히 수행하는 방법은 플레이 속성을 소개하고 해당 속성을 반영하고 :host 가상 클래스를 사용하여 버튼을 표시하거나 숨기는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eVideoPlayer\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eHTMLElement\u003c/span\u003e {\n\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e shadowRoot = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eattachShadow\u003c/span\u003e({\u003cspan class=\"hljs-attr\"\u003emode\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'open'\u003c/span\u003e});\n\n    shadowRoot.\u003cspan class=\"hljs-property\"\u003einnerHTML\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e`\n      \u0026#x3C;style\u003e\n        :host {\n          display: block;\n          width: 300px;\n          height: 300px;\n          border: 2px solid red;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          background-color: transparent;\n        }\n\n        #pause {\n          display: none;\n        }\n\n        :host([playing]) #play {\n          display: none;\n        }\n\n        :host([playing]) #pause {\n          display: block;\n        }\n      \u0026#x3C;/style\u003e\n\n      \u0026#x3C;button id=\"play\" type=\"button\"\u003ePlay\u0026#x3C;/button\u003e\n      \u0026#x3C;button id=\"pause\" type=\"button\"\u003ePause\u0026#x3C;/button\n    `\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003econnectedCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e playButton = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshadowRoot\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003equerySelector\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#play'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pauseButton = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshadowRoot\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003equerySelector\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#pause'\u003c/span\u003e);\n\n    playButton.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'click'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eplaying\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    });\n\n    pauseButton.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'click'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eplaying\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    });\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eplaying\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasAttribute\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'playing'\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eplaying\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eisPlaying\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(isPlaying) {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esetAttribute\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'playing'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eremoveAttribute\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'playing'\u003c/span\u003e);\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기본적으로 재생 버튼이 표시됩니다. 플레이 속성을 위한 설정자가 정의되어 해당 속성을 설정하거나 제거하며 CSS 규칙은 :host 가상 클래스를 사용하여 버튼을 표시하거나 숨기는 역할을 합니다.\u003c/p\u003e\n\u003cp\u003e아래에 작동하는 예제가 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 방법은 잘 작동하지만 이 구현에 잠재적인 문제가 있을 수 있어요.\u003c/p\u003e\n\u003cp\u003e이렇게 내부 속성을 속성으로 노출하는 것은 항상 바람직하지 않을 수 있고 캡슐화를 깨버릴 수 있어요.\u003c/p\u003e\n\u003cp\u003e이 경우 playing 속성을 노출하는 것은 나쁜 생각은 아닐 수 있지만, 이는 사용자가 그냥 속성을 추가함으로써 컴포넌트를 재생 상태로 수동 설정할 수 있지만, 실제로 비디오가 재생되는 것은 아니라는 점이에요.\u003c/p\u003e\n\u003cp\u003e이 속성을 노출함으로써 사용자가 playing 속성을 추가하기만 하면 비디오를 재생할 수 있다는 기대감조차 줄 수 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e사실 특정 상태의 웹 컴포넌트를 설정하기 위해 속성을 추가하는 것은 해당 상태를 설정하는 것이 아니기 때문에 playing 속성을 true로 설정하지 않습니다. playing 속성에 playing 속성을 추가하는 것만으로 playing 속성을 true로 설정하지는 않습니다.\u003c/p\u003e\n\u003cp\u003e이 경우 실제로 심각한 피해를 입히지는 않겠지만 내부 속성을 노출하는 것이 좋지 않은 경우가 항상 있을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이것은 사용자 정의 상태에 대한 완벽한 사용 사례입니다. 속성은 노출되지 않지만 이러한 상태에 기반한 CSS 스타일을 사용하여 컴포넌트를 여전히 스타일링할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e사용자 정의 상태 추가 및 제거\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e언급한 바와 같이 모든 사용자 지정 상태는 ElementInternals 인터페이스의 states 속성에 저장된 CustomStateSet 객체에 저장됩니다.\u003c/p\u003e\n\u003cp\u003e상태를 추가하고 제거하는 데 사용되는 add 및 delete 메서드와 요소가 특정 상태를 갖고 있는지 확인하는 has 메서드가 있습니다.\u003c/p\u003e\n\u003cp\u003e다른 주목할 만한 메서드로는 모든 상태를 지우는 clear 및 요소의 모든 상태를 반복하는 forEach가 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 내부 구현 부착\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eattachInternals\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 상태 추가 예전 문법\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--foo'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 상태 추가 새 문법\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'bar'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 상태 반복\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003estate\u003c/span\u003e =\u003e\u003c/span\u003e {\n \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(state); \u003cspan class=\"hljs-comment\"\u003e// foo bar\u003c/span\u003e\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 상태 제거 예전 문법\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--bar'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 상태 제거 새 문법\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'bar'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 상태 존재 여부 확인 예전 문법\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--foo'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--bar'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 상태 존재 여부 확인 새 문법\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'foo'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'bar'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e브라우저에서 오래된 구문만 지원하는 경우 --로 시작하지 않는 상태를 추가하려고 할 때 오류가 발생합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eattachInternals\u003c/span\u003e();\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'foo'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 오류, '--'로 시작하지 않음 (오래된 구문만 지원)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이전 예제가 사용자 정의 상태와 함께 작동하도록 하려면 \u003ccode\u003eplaying\u003c/code\u003e 속성의 게터 및 세터를 상태와 함께 작동하도록 변경해야 합니다. 이를 오래된 및 새로운 구문을 지원하는 브라우저에서 작동하도록 하려면 --없이 상태를 설정하는 것은 try/catch 블록으로 감싸야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eplaying\u003c/span\u003e() {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--playing'\u003c/span\u003e) || \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'playing'\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eplaying\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eisPlaying\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(isPlaying) {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'playing'\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(e) {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--playing'\u003c/span\u003e);\n    }\n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n   \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'playing'\u003c/span\u003e);\n   \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--playing'\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e테이블 태그를 마크다운 형식으로 변경했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 이전 구문 */\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003ehost\u003c/span\u003e(:--playing) #play {\n  \u003cspan class=\"hljs-attr\"\u003edisplay\u003c/span\u003e: none;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e/* 이전 구문 */\u003c/span\u003e\n:\u003cspan class=\"hljs-title function_\"\u003ehost\u003c/span\u003e(:--playing) #pause {\n  \u003cspan class=\"hljs-attr\"\u003edisplay\u003c/span\u003e: block;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e/* 새로운 구문 */\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003ehost\u003c/span\u003e(:\u003cspan class=\"hljs-title function_\"\u003estate\u003c/span\u003e(playing)) #play {\n  \u003cspan class=\"hljs-attr\"\u003edisplay\u003c/span\u003e: none;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e/* 새로운 구문 */\u003c/span\u003e\n:\u003cspan class=\"hljs-title function_\"\u003ehost\u003c/span\u003e(:\u003cspan class=\"hljs-title function_\"\u003estate\u003c/span\u003e(playing)) #pause {\n  \u003cspan class=\"hljs-attr\"\u003edisplay\u003c/span\u003e: block;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e내부 속성이 속성으로 노출되지 않도록 하는 것은 좋지만, 여전히 소비자가 내부 속성을 통해 상태에 액세스하고 add 및 delete 메서드를 호출하여 상태를 추가하거나 제거할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e player = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003equerySelector\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'video-player'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 이전 구문\u003c/span\u003e\nplayer.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--playing'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 구문\u003c/span\u003e\nplayer.\u003cspan class=\"hljs-property\"\u003einternals\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'playing'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e더 좋지 않은 점은 소비자가 내부 상태를 변경하기 위해 playing의 setter를 호출할 수 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003e이를 수정하여 getter와 setter 및 내부 속성을 모두 #으로 접두사를 붙여 private로 만들 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// internals is now private\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eattachInternals\u003c/span\u003e();\n\n\u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eplaying\u003c/span\u003e() {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--playing'\u003c/span\u003e) || \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'playing'\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eplaying\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eisPlaying\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(isPlaying) {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'playing'\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(e) {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--playing'\u003c/span\u003e);\n    }\n        \n  }\n  \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n   \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'playing'\u003c/span\u003e);\n   \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--playing'\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprivate 속성에 대한 getter와 setter 쌍을 작성하는 것이 직관적이지 않을 수 있지만, 이것이 실제로 작동한다는 것에 주목하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e비록 playing에 getter와 setter가 정의되어 있지만, 여전히 private이며 클래스 내에서만 접근 가능합니다.\u003c/p\u003e\n\u003cp\u003e값을 할당하면 setter가 호출되고 값을 읽으면 getter가 호출됩니다.\u003c/p\u003e\n\u003cp\u003e아래에 전체 코드가 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eVideoPlayer\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eHTMLElement\u003c/span\u003e {\n  #internals;  \u003cspan class=\"hljs-comment\"\u003e// private property를 필요로 하는 클래스 필드\u003c/span\u003e\n\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e shadowRoot = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eattachShadow\u003c/span\u003e({\u003cspan class=\"hljs-attr\"\u003emode\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'open'\u003c/span\u003e});\n\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eattachInternals\u003c/span\u003e();\n\n    shadowRoot.\u003cspan class=\"hljs-property\"\u003einnerHTML\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e`\n      \u0026#x3C;style\u003e\n        :host {\n          width: 300px;\n          height: 300px;\n          border: 2px solid red;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          background-color: transparent;\n        }\n\n        #pause {\n          display: none;\n        }\n\n        /* 예전 문법 */\n        :host(:--playing) #play {\n          display: none;\n        }\n\n        :host(:--playing) #pause {\n          display: block;\n        }\n\n        /* 새로운 문법 */\n        :host(:state(playing)) #play {\n          display: none;\n        }\n\n        :host(:state(playing)) #pause {\n          display: block;\n        }\n      \u0026#x3C;/style\u003e\n\n      \u0026#x3C;button id=\"play\" type=\"button\"\u003e재생\u0026#x3C;/button\u003e\n      \u0026#x3C;button id=\"pause\" type=\"button\"\u003e일시정지\u0026#x3C;/button\u003e\n    `\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003econnectedCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e playButton = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshadowRoot\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003equerySelector\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#play'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pauseButton = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshadowRoot\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003equerySelector\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'#pause'\u003c/span\u003e);\n\n    playButton.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'click'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#playing = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    });\n\n    pauseButton.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'click'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#playing = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    });\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eplaying\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--playing'\u003c/span\u003e) || \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'playing'\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eplaying\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eisPlaying\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(isPlaying) {\n      \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'playing'\u003c/span\u003e);\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(e) {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--playing'\u003c/span\u003e);\n      }\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'playing'\u003c/span\u003e);\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#internals.\u003cspan class=\"hljs-property\"\u003estates\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'--playing'\u003c/span\u003e);\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그리고 여기에는 오래된 구문과 새 구문 둘 다 작동하는 작동 예제가 있습니다:\u003c/p\u003e\n\u003cp\u003e이 예제들은 커스텀 상태에 기반하여 커스텀 요소를 내부 컴포넌트 내에서 :host 가상 클래스를 사용하여 스타일링하는 방법을 보여줍니다.\u003c/p\u003e\n\u003cp\u003e커스텀 요소는 사용자 정의 상태에 기반하여 외부에서 스타일링될 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e이 스타일링은 :checked나 :hover와 같은 내장 상태에 기반하여 구성 요소를 스타일링하는 것과 동일한 형태를 가지고 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 예전 구문 */\u003c/span\u003e\nvideo-\u003cspan class=\"hljs-attr\"\u003eplayer\u003c/span\u003e:--playing {\n  \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: 1px solid red;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e/* 새로운 구문 */\u003c/span\u003e\nvideo-\u003cspan class=\"hljs-attr\"\u003eplayer\u003c/span\u003e:\u003cspan class=\"hljs-title function_\"\u003estate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eplaying\u003c/span\u003e) {\n  \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: 1px solid red;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e같은 CSS 속성에 대한 사용자 지정 상태를 기반으로 스타일 지정이 내부와 외부에서 모두 정의된 경우, 외부에서 정의된 스타일이 우선합니다.\u003c/p\u003e\n\u003cp\u003e다음 예제에서 컴포넌트는 --playing/playing 사용자 지정 상태일 때 녹색 테두리가 추가됩니다.\u003c/p\u003e\n\u003cp\u003e--playing/playing 상태에 대해 컴포넌트 내부에서 정의된 파란색 테두리는 덮어씌워집니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 컴포넌트 외부에서 정의된 스타일\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이렇게 하면 컴포넌트에 녹색 테두리가 우선적으로 적용됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이전 구문\u003c/span\u003e\nvideo-\u003cspan class=\"hljs-attr\"\u003eplayer\u003c/span\u003e:--playing {\n  \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: 2px solid green;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 구문\u003c/span\u003e\nvideo-\u003cspan class=\"hljs-attr\"\u003eplayer\u003c/span\u003e:\u003cspan class=\"hljs-title function_\"\u003estate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eplaying\u003c/span\u003e) {\n  \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: 2px solid green;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 컴포넌트 내부에서 정의된 스타일\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 외부에서 정의된 스타일에 덮어씌워지게 됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이전 구문\u003c/span\u003e\n:\u003cspan class=\"hljs-title function_\"\u003ehost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e:--playing\u003c/span\u003e) {\n  \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: 2px solid blue;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 구문\u003c/span\u003e\n:\u003cspan class=\"hljs-title function_\"\u003ehost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e:state(playing)\u003c/span\u003e) {\n  \u003cspan class=\"hljs-attr\"\u003eborder\u003c/span\u003e: 2px solid blue;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e사용자 정의 상태(Custom States)는 웹 컴포넌트의 진화를 위한 중요한 단계입니다.\u003c/p\u003e\n\u003cp\u003e이를 통해 컴포넌트의 상태를 속성이나 클래스를 추가하지 않고도 스타일링할 수 있어 외부에서 상태를 조작할 수 없도록 유지할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e커스텀 상태는 Chrome, Edge, Safari Tech Preview 187에서는 CustomStateSet 기능 플래그가 활성화되어 있고, Firefox 122에서는 dom.element.customstateset.enabled가 true로 설정되어 있을 때 지원됩니다.\u003c/p\u003e\n\u003cp\u003e현대 웹 플랫폼, 웹 컴포넌트, 그리고 Progressive Web Apps에 관한 제 주간 뉴스레터 'Modern Web Weekly'에 가입해보세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-TheHiddenPowerofCustomStatesForWebComponents"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>