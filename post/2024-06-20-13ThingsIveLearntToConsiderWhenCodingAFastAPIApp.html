<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>파이파이 앱을 코딩할 때 고려해야 할 13가지를 배운 것들 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-13ThingsIveLearntToConsiderWhenCodingAFastAPIApp" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="파이파이 앱을 코딩할 때 고려해야 할 13가지를 배운 것들 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="파이파이 앱을 코딩할 때 고려해야 할 13가지를 배운 것들 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-13ThingsIveLearntToConsiderWhenCodingAFastAPIApp_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-13ThingsIveLearntToConsiderWhenCodingAFastAPIApp" data-gatsby-head="true"/><meta name="twitter:title" content="파이파이 앱을 코딩할 때 고려해야 할 13가지를 배운 것들 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-13ThingsIveLearntToConsiderWhenCodingAFastAPIApp_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 04:46" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">파이파이 앱을 코딩할 때 고려해야 할 13가지를 배운 것들</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="파이파이 앱을 코딩할 때 고려해야 할 13가지를 배운 것들" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-13ThingsIveLearntToConsiderWhenCodingAFastAPIApp&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>대학 시절에는 학교 프로젝트를 위해 쓸만한 한 페이지 FastAPI 백엔드 애플리케이션을 만들 수 있었어요. 솔직히 말해 많은 교수님들이 우리의 프로젝트 코드를 읽지도 않으셨다니까요.</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># 예시: 쓸만한 한 페이지 fastapi 앱</span>

<span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI

app = FastAPI()

<span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">'/stuff'</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_all</span>():
    <span class="hljs-keyword">return</span> {<span class="hljs-string">'과일'</span>: <span class="hljs-string">'사과'</span>}

<span class="hljs-keyword">import</span> uvicorn
uvicorn.run(app)
</code></pre>
<p>^ 우리는 이렇게 코드를 작성해서 가능한 빨리 일을 끝낼 수 있었고, 우리의 백엔드 엔드포인트가 올바른 결과를 반환하기만 하면, 대부분의 경우 우리 코드가 얼마나 잘 작성되었는지는 아무도 신경쓰지 않았어요.</p>
<div class="content-ad"></div>
<p>저는 현재 대규모 프로덕션급 FastAPI 앱을 개발 중이에요. 만약 제가 이 중 하나라도 하게 된다면, 개발 책임자님에게 혼날 거라고 확신해요. 지난 몇 달 동안 대규모 FastAPI 앱을 만들며 배운 13가지 고려 사항을 소개해드릴게요.</p>
<h1>1) 타입 어노테이션 (타입 힌트)</h1>
<p>이전에 내 코드를 작성했던 방식은 다음과 같아요:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_stuff</span>(<span class="hljs-params">a, b, c</span>):
    ...
</code></pre>
<div class="content-ad"></div>
<p>지금 제가 코드를 작성하는 방식은 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span>

def <span class="hljs-title function_">do_stuff</span>(<span class="hljs-attr">a</span>: int, <span class="hljs-attr">b</span>: str, <span class="hljs-attr">c</span>: <span class="hljs-title class_">List</span>[int]) -> <span class="hljs-title class_">List</span>[str]:
    ...
</code></pre>
<p>여기서 내장 typing 모듈을 사용하여 몇 가지 타입 주석을 추가했습니다:</p>
<ul>
<li>a는 정수여야 합니다.</li>
<li>b는 문자열이어야 합니다.</li>
<li>c는 정수들로 이루어진 리스트여야 합니다.</li>
<li>함수의 반환 값은 문자열들로 이루어진 리스트여야 합니다.</li>
</ul>
<div class="content-ad"></div>
<p>노트 — 타입 어노테이션(또는 타입 힌트)은 데이터 타입을 강제하지 않습니다. 그저 제안하는 것뿐입니다. 기술적으로 잘못된 데이터 타입을 전달할 수 있지만, Python은 여전히 허용합니다.</p>
<p>하지만, 타입 어노테이션을 작성하는 것은 내가 의도적으로 하는 선택입니다 — 나는 이것들을 다른 개발자들이 동일한 코드베이스에서 작업할 때 명확하고 이해하기 쉽도록 하기 위해 작성합니다. 이렇게 하면 다른 개발자들이 데이터 타입이 정확히 무엇인지 알아내기 위해 더 많은 시간을 낭비하지 않아도 됩니다.</p>
<h1>2) 정적 타입 체커를 사용하기</h1>
<p>타입 어노테이션은 데이터 타입을 강제하지 않지만, mypy와 같은 정적 타입 체커는 강제합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -> <span class="hljs-built_in">int</span>:
    <span class="hljs-keyword">return</span> a + b

<span class="hljs-built_in">print</span>(add(<span class="hljs-string">'hello '</span>, <span class="hljs-string">'world'</span>))
</code></pre>
<p>여기서 a와 b는 정수형이어야 하지만 문자열을 전달했습니다.</p>
<ul>
<li>일반적으로 Python은 이를 허용합니다</li>
<li>mypy와 같은 정적 형 검사 도구는 허용하지 않습니다</li>
</ul>
<p>따라서 데이터 유형 위반에 대한 추가적인 보호층으로 정적 유형 검사기를 CICD(지속적 통합 지속적 배포) 파이프라인의 일부로 포함하는 것이 중요하다는 것을 깨달았습니다.</p>
<div class="content-ad"></div>
<h1>3) PEP8 및 코드 스타일링</h1>
<p>링크: <a href="https://peps.python.org/pep-0008/" rel="nofollow" target="_blank">https://peps.python.org/pep-0008/</a></p>
<p>예전에 코드를 작성할 때 PEP8을 무시했었어요. 그러다가 코드가 금방 지저분하고 못생기게 되는 것을 깨달았죠.</p>
<p>PEP8 문서는 우리에게 Python 코딩 규칙을 제공하여 코드베이스를 일관되고 깔끔하게 유지하는 것이 이상적이라는 것을 알려줍니다. Python에서는 이를 무시할 수 있지만, 당신의 기술 리드는 그렇게 하지 말라고 할지도 몰라요.</p>
<div class="content-ad"></div>
<p>내 머릿속에 기억나는 몇 가지 규칙이 있어요:</p>
<ul>
<li>함수 간에는 1줄의 개행을 추가해 주세요, 클래스 간에는 2줄의 개행을 넣어 주세요.</li>
<li>들여쓰기는 탭 대신 공백을 사용해야 합니다.</li>
<li>from X import * 는 좋지 않은 습관입니다.</li>
<li>import 구문은 어떤 순서로든 정리되어야 합니다.</li>
<li>코드 라인은 79자 이상으로 길어지면 안 됩니다.</li>
</ul>
<p>파이썬 개발자가 되고 싶다면, PEP8 문서를 한 번은 꼭 살펴보기를 추천해요. 대부분의 코딩 관례를 조금이라도 익히는 데 도움이 될 거예요.</p>
<p>참고 — 때로는 제가 코드를 작성할 때 PEP8 규칙을 무시하기도 하지만, 프로덕션 코드를 작성할 때는 최대한 모든 규칙을 준수하려 노력하고 있어요.</p>
<div class="content-ad"></div>
<h1>4) 폴더 구조 및 도메인</h1>
<p>학교 프로젝트에서는 어디에 .py 파일을 놓느냐에 상관없이 파일을 마구 놓을 수 있지만, 제품용 코드에서는 그렇게 할 수 없습니다.</p>
<p>제품용 코드에서는 모든 사람이 따라야 할 폴더/파일 구조가 있습니다. 각 팀마다 약간씩 다를 수 있지만, 동일한 팀 구성원 모두가 합의해야 할 사항입니다.</p>
<p>src/
└── sqlmodels/
└── dog.py
└── cat.py
└── bird.py
└── dbchanges/
└── code/
└── bin/
└── utils/
└── web_api/
└── domain1
└── router.py
└── service.py
└── models.py
└── domain2
└── router.py
└── service.py
└── models.py
└── domain3
└── router.py
└── service.py
└── models.py
└── requirements/
.gitignore
README.md
dockerfile</p>
<div class="content-ad"></div>
<p>여기는 내 제품용 FastAPI 코드의 매우 간소화된 버전입니다 (실제 폴더 구조는 훨씬 더 큽니다)</p>
<p>참고 - 우리 응용 프로그램의 각 하위 섹션은 독립된 도메인 폴더가 제공됩니다.</p>
<p>.MD 파일을 마크다운 형식으로 변경해주세요.</p>
<p>.py 파일을 마음대로 어디에 둘 수 있고 아무도 신경 쓰지 않는 시절은 지나갔지만, 내가 주장하는 바에 의하면 이것은 좋은 일이라고 생각합니다 - 합의된 폴더 구조는 전체 프로젝트를 더 깔끔하고 유지 관리하기 쉽게 만듭니다.</p>
<p>ORM(객체-관계 매핑)을 사용하는 것이란 SQLAlchemy와 같은 것들.</p>
<div class="content-ad"></div>
<p>제가 학교 프로젝트에서 FastAPI 앱을 다룬 것을 기억해요:</p>
<ul>
<li>각 엔드포인트마다, 데이터에 접근할 때는 데이터베이스를 직접 호출했어요.</li>
<li>MongoDB에서 바로 사전을 받고, 곧바로 반환했어요.</li>
</ul>
<p>^ 다만 이 방법에는 문제가 있어요 — 앱이 커질수록 굉장히 지저분하고 유지보수하기 어려워져요. 작은 앱이라면 상관없을 수도 있지만, 대규모 앱에서는 어려울 거에요.</p>
<p>크고 복잡한 애플리케이션에서는 SQLAlchemy와 같은 ORM (객체-관계 매핑) 시스템 사용이 좋은 아이디어라고 말할 수 있어요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 데이터베이스를 직접 호출하기
query = <span class="hljs-string">'select * from dogs where age &#x3C; 5'</span>

cursor.<span class="hljs-title function_">execute</span>(query)
dogs = cursor.<span class="hljs-title function_">fetchall</span>()

<span class="hljs-title function_">print</span>(dogs)
</code></pre>
<pre><code class="hljs language-js"># <span class="hljs-title class_">SQLALchemy</span> 사용하기
stmt = <span class="hljs-title function_">select</span>(<span class="hljs-title class_">Dog</span>).<span class="hljs-title function_">where</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property">age</span>&#x3C;<span class="hljs-number">5</span>)
dogs = session.<span class="hljs-title function_">execute</span>(stmt)

<span class="hljs-title function_">print</span>(dogs)
</code></pre>
<p>ORM은 우리 데이터베이스를 감싼 래퍼인데, 시작하는 데는 학습 곡선이 있을 수 있어요. 하지만 거대한 응용프로그램에는 구조가 필요하다는 걸 기억해봐요.</p>
<p>만약 FastAPI 앱에서 수천 개의 문자열 SQL 쿼리를 처리해야 한다면 상황은 좀 체증스러울 거에요 (코드베이스와 정신 건강 모두 말이에요)</p>
<div class="content-ad"></div>
<h1>6) 엔드포인트에 대한 입력 및 출력 정의</h1>
<p>나는 예전에 이렇게 엔드포인트를 작성했어요:</p>
<pre><code class="hljs language-js"># 나쁜 코드

@app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/dogs'</span>)
def <span class="hljs-title function_">all_dogs</span>():
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">get_all_dogs</span>()

@app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/dogs/{id}'</span>)
def <span class="hljs-title function_">one_dog</span>(id):
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">get_dog</span>(id)
</code></pre>
<p>^ 정확한 입력 및 출력 구조가 정의되지 않았어요. 문제점:</p>
<div class="content-ad"></div>
<ul>
<li>다른 개발자들이 입력과 출력이 무엇인지 추측하는 데 시간을 낭비할 필요가 없어집니다</li>
<li>미래에는 아마도 당신이 입력과 출력이 무엇인지 추측하는 데 시간을 낭비할 수도 있습니다</li>
</ul>
<p>결국 이렇게 코드를 작성하는 것을 배웠어요:</p>
<pre><code class="hljs language-js"># 덜 나쁜 코드

@app.<span class="hljs-title function_">get</span>(
    <span class="hljs-string">'/dogs'</span>, 
    response_model=<span class="hljs-title class_">List</span>[<span class="hljs-title class_">Dog</span>],
    name=<span class="hljs-string">'모든 개 가져오기'</span>
)
def <span class="hljs-title function_">all_dogs</span>() -> <span class="hljs-title class_">List</span>[<span class="hljs-title class_">Dog</span>]:
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">get_all_dogs</span>()

@app.<span class="hljs-title function_">get</span>(
    <span class="hljs-string">'/dogs/{id}'</span>,
    response_model=<span class="hljs-title class_">DogWithMoreInfo</span>,
    name=<span class="hljs-string">'아이디로 한 마리 개 가져오기'</span>
)
def <span class="hljs-title function_">one_dog</span>(<span class="hljs-attr">id</span>: int) -> <span class="hljs-title class_">Dog</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">get_dog</span>(id)
</code></pre>
<p>^ 여기서 type 어노테이션을 사용하고 app.get() 내부의 response_model 키워드 인수를 사용하여 각 엔드포인트의 입력과 출력이 무엇이어야 하는지 훨씬 명확하게 만들었습니다.</p>
<div class="content-ad"></div>
<h1>7) 모델 간의 관계</h1>
<p>우리에게는 사람과 개가 있고, 한 사람이 여러 마리의 개를 소유할 수 있다고 가정해 봅시다.</p>
<p>모델 간의 관계를 사용하기 전에, 다음은 우리의 Dog 모델이 어떻게 보일지에 대한 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// dog</span>
{
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"rocky"</span>,
    <span class="hljs-string">"age"</span>: <span class="hljs-number">3</span>,
    <span class="hljs-string">"owner_id"</span>: <span class="hljs-number">1</span>
}
</code></pre>
<div class="content-ad"></div>
<p>기술적으로 우리는 이렇게 작성할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// dog</span>
{
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"rocky"</span>,
    <span class="hljs-string">"age"</span>: <span class="hljs-number">3</span>,
    <span class="hljs-string">"owner_id"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">"owner"</span>: {
        <span class="hljs-string">"name"</span>: <span class="hljs-string">"tom"</span>,
        <span class="hljs-string">"age"</span>: <span class="hljs-number">30</span>,
        <span class="hljs-string">"job"</span>: <span class="hljs-string">"teacher"</span>
    }
}
</code></pre>
<p>하지만 특히 수백 개의 API 엔드포인트를 다루고 있다면 이것이 지루할 수 있어요.</p>
<p>대신, SQLModels 관계를 사용하여 우리의 삶을 더 쉽게 만들 수 있어요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 매우 간단한 예시

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Human</span>(<span class="hljs-title class_">HumanBase</span>, table=<span class="hljs-title class_">True</span>):
    __tablename__ = <span class="hljs-string">'humans'</span>

    <span class="hljs-attr">dogs</span>: list[<span class="hljs-string">"Dog"</span>] = <span class="hljs-title class_">Relationship</span>(back_populates=<span class="hljs-string">'owner'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_">DogBase</span>, table=<span class="hljs-title class_">True</span>):
    __tablename__ = <span class="hljs-string">'dogs'</span>

    <span class="hljs-attr">owner</span>: <span class="hljs-title class_">Human</span> = <span class="hljs-title class_">Relationship</span>(back_populates=<span class="hljs-string">'dogs'</span>)
</code></pre>
<p>우리 엔드포인트 코드에서 response_model을 Dog로 설정하면 자동으로 Human 정보도 가져올 수 있습니다:</p>
<pre><code class="hljs language-js">{
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"rocky"</span>,
    <span class="hljs-string">"age"</span>: <span class="hljs-number">3</span>,
    <span class="hljs-string">"owner_id"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">"owner"</span>: {
        <span class="hljs-string">"name"</span>: <span class="hljs-string">"tom"</span>,
        <span class="hljs-string">"age"</span>: <span class="hljs-number">30</span>,
        <span class="hljs-string">"job"</span>: <span class="hljs-string">"teacher"</span>
    }
}
</code></pre>
<p>그리고 데이터베이스 내의 다른 중요한 관계들도 함께 가져옵니다.</p>
<div class="content-ad"></div>
<h1>8) 접근 제어 및 어떤 API에 누가 접근할 수 있는지</h1>
<p>학교 코드에서 기억하는 것은 모든 엔드포인트가 공개적이었다는 것입니다. 우리는 단지 엔드포인트의 입력과 출력이 올바른지에만 주의를 기울렸고, 다른 것들에는 그다지 신경을 쓰지 않았습니다.</p>
<p>그러나 모든 것이 공개적으로 되어 있다는 것은 좋지 않은 실천 방법입니다.</p>
<p>프로덕션 급 코드에서는 다음과 같은 시스템이 필요합니다:</p>
<div class="content-ad"></div>
<ul>
<li>API 호출을 하는 사용자 식별</li>
<li>해당 사용자가 호출할 수 있는 API 엔드포인트 결정</li>
</ul>
<p>한 걸음 더 나아가면, 서로 다른 사용자가 볼 수 있는 결과를 제어할 수도 있습니다. 예를 들어:</p>
<ul>
<li>관리자는 모든 것을 볼 수 있음</li>
<li>비관리자는 자신의 이름이 포함된 항목만 볼 수 있음</li>
</ul>
<p>이를 구현하는 하나의 올바른 방법이 없으므로 시간을 들여 신중하게 생각해보시기 바랍니다.</p>
<div class="content-ad"></div>
<h1>9) 로깅</h1>
<p>프로덕션급 FastAPI 코드에서는 아마도 독립형 스크립트를 제외하고는 print()를 사용하지 않습니다.</p>
<p>대신 로거를 사용합니다. 로깅의 몇 가지 장점:</p>
<ul>
<li>정보를 캡처하는 방법이 팀 전체에서 표준화됨</li>
<li>여러 로깅 기능이 이미 구현되어 있어 그냥 사용하기만 하면 됨</li>
<li>다양한 로깅 레벨은 애플리케이션을 실행할 때 얼마나 많은 출력을 원하는지 결정하는 데 매우 유용함</li>
</ul>
<div class="content-ad"></div>
<p>파이썬 백엔드/풀스택 개발자가 되고 싶다면, 로깅 라이브러리에 대해 배우거나 적어도 어느 정도는 알아야 합니다. 기억하세요 — 프로덕션급 코드에서는 print()를 많이 사용하지 않아요.</p>
<h1>10) 예외 처리</h1>
<p>여러 해 전에 예외를 처리했던 방법은 다음과 같습니다 (나쁜 방법):</p>
<pre><code class="hljs language-js"><span class="hljs-attr">try</span>:
    # 내 코드
except <span class="hljs-title class_">Exception</span> <span class="hljs-keyword">as</span> <span class="hljs-attr">e</span>:
    <span class="hljs-title function_">print</span>(e)
</code></pre>
<div class="content-ad"></div>
<p>프로덕션 수준의 FastAPI 코드베이스에서는 일반적으로 다음을 갖춥니다:</p>
<ul>
<li>상당수의 사용자 정의 예외</li>
<li>이러한 사용자 정의 예외를 저장하기 위한 별도의 폴더</li>
<li>정확히 어떤 예외를 잡고자 하는지 지정하는 보다 복잡한 예외 처리문</li>
<li>단순히 print(e)를 출력하는 것 이상의 작업을 수행하는 예외 및 마지막 문에서 더 복잡한 코드</li>
</ul>
<p>예를 들어:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># 어떤 코드</span>

<span class="hljs-keyword">except</span> CustomException1 <span class="hljs-keyword">as</span> e:
    <span class="hljs-comment"># 특별 처리 코드</span>
    
    logger.info(<span class="hljs-built_in">str</span>(e))

<span class="hljs-keyword">except</span> CustomException2 <span class="hljs-keyword">as</span> e:
    <span class="hljs-comment"># 한 번 다시 시도하는 코드</span>

    logger.info(<span class="hljs-built_in">str</span>(e))

<span class="hljs-keyword">except</span> CustomException3 <span class="hljs-keyword">as</span> e:
    <span class="hljs-comment"># 이 예외를 기반으로 다른 예외 발생</span>

    <span class="hljs-keyword">raise</span> CustomException4() <span class="hljs-keyword">from</span> e

<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
    logger.info(<span class="hljs-built_in">str</span>(e))
</code></pre>
<div class="content-ad"></div>
<p>프로덕션 수준의 FastAPI 앱에서는 단순히 Exception as e로 모든 예외를 처리할 수 없습니다.</p>
<h1>11) 단위 테스트 및 기타 테스트</h1>
<p>학교 프로젝트에서는 테스트를 작성할 필요가 없었습니다. 주로 프레젠테이션 이후에는 코드를 더 이상 사용하지 않기 때문입니다.</p>
<p>그러나 프로덕션 수준의 코드베이스에서는 단위 테스트뿐만 아니라 통합 테스트 등이 필수적입니다.</p>
<div class="content-ad"></div>
<ul>
<li>수십 개의 엔드포인트를 테스트해야 한다면 일종의 자동화된 테스트를 도입할 필요가 있어요.</li>
<li>모든 사람이 테스트를 수작업으로 모든 것을 테스트하면 만족스럽지 않을 거예요.</li>
</ul>
<p>단위 테스트를 작성하는 것이 지루할 수 있지만, 나는 대규모 코드 베이스에서는 필수적이라는 것을 깨달았어요.</p>
<p>테스트에 익숙하지 않다면 pytest 학습을 시도해 볼 수 있어요.</p>
<h1>12) 데이터의 업데이트 이력 추적</h1>
<div class="content-ad"></div>
<p>사용자가 데이터를 생성/업데이트/삭제할 때마다 이를 이상적으로는 어떤 종류의 히스토리 테이블에 기록해야 합니다.</p>
<p>예를 들어, 사용자가 PUT 엔드포인트 중 하나를 사용하여 그의 개의 색상을 노란색으로 업데이트하고 이를 데이터베이스에 저장했다고 가정해보겠습니다.</p>
<p>히스토리 테이블 내에서 이 작업을 추적하기 위해 다음과 같이 보일 수 있습니다.</p>
<ul>
<li>우리의 주요 개 데이터가 포함된 dogs 테이블이 있다고 가정해봅시다.</li>
<li>dogs 테이블에 있는 각 개에 대해 수행된 모든 변경 사항이 포함된 dog_history 테이블이 있습니다.</li>
</ul>
<div class="content-ad"></div>
<p>아래는 예시 워크플로우입니다:</p>
<ul>
<li>사용자 A가 자신의 강아지 색상을 노란색으로 업데이트합니다 (강아지 ID=100).</li>
<li>우리는 강아지 테이블을 보통대로 업데이트합니다.</li>
<li>그런 다음 강아지 이력 테이블에 새 항목을 삽입합니다.</li>
<li>새 항목에는 1) 사용자 2) 타임스탬프 3) 변경된 필드 4) 이전 값 5) 새 값이 포함됩니다.</li>
<li>예를 들어, "사용자 A가 (ID가 100인 강아지)의 색상을 초록에서 노란색으로 변경했습니다."</li>
</ul>
<pre><code class="hljs language-js">{
    user=A, 
    dog_id=<span class="hljs-number">100</span>, 
    field_changed=<span class="hljs-string">'color'</span>, 
    old_value=<span class="hljs-string">'green'</span>, 
    new_value=<span class="hljs-string">'yellow'</span>,
    timestamp=<span class="hljs-number">178787878787</span>
}
</code></pre>
<p>^ 이와 같이 사용자의 업데이트 작업을 추적할 수 있습니다.</p>
<div class="content-ad"></div>
<h1>13) 데이터베이스 변경 추적</h1>
<p>대규모 프로덕션급 앱에서는 데이터 모델에 변경 사항이 있을 수 있습니다. 이를 데이터베이스에서 (테이블 수정이 필요한 경우) 변경할 필요가 있을 수 있습니다.</p>
<ul>
<li>일부 테이블에 열 추가가 필요할 수 있습니다.</li>
<li>완전히 새로운 테이블을 추가해야 할 수도 있습니다.</li>
</ul>
<p>프로덕션급 앱에서는 데이터베이스를 직접 변경하지 않습니다. 여러 이유로 이는 최악의 실천 방법입니다.</p>
<div class="content-ad"></div>
<ul>
<li>변경 사항은 되돌릴 수 없습니다 — 누군가 변경을 실수하면 되돌릴 수 없어요</li>
<li>변경 사항은 추적할 수 없습니다 — 누군가 변경을 실수하면 누가 그것을 했는지 알 수 없어요</li>
</ul>
<p>보통, 팀 내 모든 사람들이 데이터베이스에 가하는 모든 변경 사항을 포함하는 전통적인 dbchanges 폴더가 있습니다</p>
<ul>
<li>이 dbchanges 폴더에는 보통 여러 폴더가 포함되어 있습니다.</li>
<li>각 폴더에는 일부 .xml 파일과 .sql 파일이 들어 있습니다. 이것들을 각각 changeset이라고 합니다.</li>
<li>우리가 changeset을 실행하면 그 안에 있는 변경 사항이 데이터베이스에 적용됩니다.</li>
<li>만약 changeset이 실수라면 데이터베이스가 손상되지 않도록 롤백을 수행할 수 있습니다.</li>
</ul>
<h1>결론</h1>
<div class="content-ad"></div>
<p>이해하기 쉽고 명확했기를 바랍니다.</p>
<h1>만약 나를 창작자로 지원하고 싶다면</h1>
<ul>
<li>내 책을 구매해 주세요! — 파이썬에 대해 알지 못했던 101가지</li>
<li>어디에서 찾을 수 있는지: <a href="https://payhip.com/b/vywcf" rel="nofollow" target="_blank">https://payhip.com/b/vywcf</a></li>
<li>해당 이야기에 50번의 박수를 쳐 주세요</li>
<li>당신의 생각을 말해 주는 댓글을 남겨주세요</li>
<li>이야기 중 가장 마음에 드는 부분을 강조해 주세요</li>
</ul>
<p>감사합니다! 이 작은 행동들은 큰 도움이 되며 정말 감사드립니다!</p>
<div class="content-ad"></div>
<p>YouTube: <a href="https://www.youtube.com/@zlliu246" rel="nofollow" target="_blank">https://www.youtube.com/@zlliu246</a></p>
<p>LinkedIn: <a href="https://www.linkedin.com/in/zlliu/" rel="nofollow" target="_blank">https://www.linkedin.com/in/zlliu/</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"파이파이 앱을 코딩할 때 고려해야 할 13가지를 배운 것들","description":"","date":"2024-06-20 04:46","slug":"2024-06-20-13ThingsIveLearntToConsiderWhenCodingAFastAPIApp","content":"\n\n대학 시절에는 학교 프로젝트를 위해 쓸만한 한 페이지 FastAPI 백엔드 애플리케이션을 만들 수 있었어요. 솔직히 말해 많은 교수님들이 우리의 프로젝트 코드를 읽지도 않으셨다니까요.\n\n```python\n# 예시: 쓸만한 한 페이지 fastapi 앱\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get('/stuff')\ndef get_all():\n    return {'과일': '사과'}\n\nimport uvicorn\nuvicorn.run(app)\n```\n\n^ 우리는 이렇게 코드를 작성해서 가능한 빨리 일을 끝낼 수 있었고, 우리의 백엔드 엔드포인트가 올바른 결과를 반환하기만 하면, 대부분의 경우 우리 코드가 얼마나 잘 작성되었는지는 아무도 신경쓰지 않았어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 현재 대규모 프로덕션급 FastAPI 앱을 개발 중이에요. 만약 제가 이 중 하나라도 하게 된다면, 개발 책임자님에게 혼날 거라고 확신해요. 지난 몇 달 동안 대규모 FastAPI 앱을 만들며 배운 13가지 고려 사항을 소개해드릴게요.\n\n# 1) 타입 어노테이션 (타입 힌트)\n\n이전에 내 코드를 작성했던 방식은 다음과 같아요:\n\n```python\ndef do_stuff(a, b, c):\n    ...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 제가 코드를 작성하는 방식은 다음과 같습니다:\n\n```js\nfrom typing import List\n\ndef do_stuff(a: int, b: str, c: List[int]) -\u003e List[str]:\n    ...\n```\n\n여기서 내장 typing 모듈을 사용하여 몇 가지 타입 주석을 추가했습니다:\n\n- a는 정수여야 합니다.\n- b는 문자열이어야 합니다.\n- c는 정수들로 이루어진 리스트여야 합니다.\n- 함수의 반환 값은 문자열들로 이루어진 리스트여야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노트 — 타입 어노테이션(또는 타입 힌트)은 데이터 타입을 강제하지 않습니다. 그저 제안하는 것뿐입니다. 기술적으로 잘못된 데이터 타입을 전달할 수 있지만, Python은 여전히 허용합니다.\n\n하지만, 타입 어노테이션을 작성하는 것은 내가 의도적으로 하는 선택입니다 — 나는 이것들을 다른 개발자들이 동일한 코드베이스에서 작업할 때 명확하고 이해하기 쉽도록 하기 위해 작성합니다. 이렇게 하면 다른 개발자들이 데이터 타입이 정확히 무엇인지 알아내기 위해 더 많은 시간을 낭비하지 않아도 됩니다.\n\n# 2) 정적 타입 체커를 사용하기\n\n타입 어노테이션은 데이터 타입을 강제하지 않지만, mypy와 같은 정적 타입 체커는 강제합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\ndef add(a: int, b: int) -\u003e int:\n    return a + b\n\nprint(add('hello ', 'world'))\n```\n\n여기서 a와 b는 정수형이어야 하지만 문자열을 전달했습니다.\n\n- 일반적으로 Python은 이를 허용합니다\n- mypy와 같은 정적 형 검사 도구는 허용하지 않습니다\n\n따라서 데이터 유형 위반에 대한 추가적인 보호층으로 정적 유형 검사기를 CICD(지속적 통합 지속적 배포) 파이프라인의 일부로 포함하는 것이 중요하다는 것을 깨달았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3) PEP8 및 코드 스타일링\n\n링크: [https://peps.python.org/pep-0008/](https://peps.python.org/pep-0008/)\n\n예전에 코드를 작성할 때 PEP8을 무시했었어요. 그러다가 코드가 금방 지저분하고 못생기게 되는 것을 깨달았죠.\n\nPEP8 문서는 우리에게 Python 코딩 규칙을 제공하여 코드베이스를 일관되고 깔끔하게 유지하는 것이 이상적이라는 것을 알려줍니다. Python에서는 이를 무시할 수 있지만, 당신의 기술 리드는 그렇게 하지 말라고 할지도 몰라요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 머릿속에 기억나는 몇 가지 규칙이 있어요:\n\n- 함수 간에는 1줄의 개행을 추가해 주세요, 클래스 간에는 2줄의 개행을 넣어 주세요.\n- 들여쓰기는 탭 대신 공백을 사용해야 합니다.\n- from X import * 는 좋지 않은 습관입니다.\n- import 구문은 어떤 순서로든 정리되어야 합니다.\n- 코드 라인은 79자 이상으로 길어지면 안 됩니다.\n\n파이썬 개발자가 되고 싶다면, PEP8 문서를 한 번은 꼭 살펴보기를 추천해요. 대부분의 코딩 관례를 조금이라도 익히는 데 도움이 될 거예요.\n\n참고 — 때로는 제가 코드를 작성할 때 PEP8 규칙을 무시하기도 하지만, 프로덕션 코드를 작성할 때는 최대한 모든 규칙을 준수하려 노력하고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4) 폴더 구조 및 도메인\n\n학교 프로젝트에서는 어디에 .py 파일을 놓느냐에 상관없이 파일을 마구 놓을 수 있지만, 제품용 코드에서는 그렇게 할 수 없습니다.\n\n제품용 코드에서는 모든 사람이 따라야 할 폴더/파일 구조가 있습니다. 각 팀마다 약간씩 다를 수 있지만, 동일한 팀 구성원 모두가 합의해야 할 사항입니다.\n\n\nsrc/\n └── sqlmodels/\n    └── dog.py\n    └── cat.py\n    └── bird.py\n └── dbchanges/\n └── code/\n    └── bin/\n    └── utils/\n    └── web_api/\n        └── domain1\n          └── router.py\n          └── service.py\n          └── models.py\n        └── domain2\n          └── router.py\n          └── service.py\n          └── models.py\n        └── domain3\n          └── router.py\n          └── service.py\n          └── models.py\n └── requirements/\n.gitignore\nREADME.md\ndockerfile\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기는 내 제품용 FastAPI 코드의 매우 간소화된 버전입니다 (실제 폴더 구조는 훨씬 더 큽니다)\n\n참고 - 우리 응용 프로그램의 각 하위 섹션은 독립된 도메인 폴더가 제공됩니다.\n\n.MD 파일을 마크다운 형식으로 변경해주세요. \n\n.py 파일을 마음대로 어디에 둘 수 있고 아무도 신경 쓰지 않는 시절은 지나갔지만, 내가 주장하는 바에 의하면 이것은 좋은 일이라고 생각합니다 - 합의된 폴더 구조는 전체 프로젝트를 더 깔끔하고 유지 관리하기 쉽게 만듭니다.\n\nORM(객체-관계 매핑)을 사용하는 것이란 SQLAlchemy와 같은 것들.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 학교 프로젝트에서 FastAPI 앱을 다룬 것을 기억해요:\n\n- 각 엔드포인트마다, 데이터에 접근할 때는 데이터베이스를 직접 호출했어요.\n- MongoDB에서 바로 사전을 받고, 곧바로 반환했어요.\n\n^ 다만 이 방법에는 문제가 있어요 — 앱이 커질수록 굉장히 지저분하고 유지보수하기 어려워져요. 작은 앱이라면 상관없을 수도 있지만, 대규모 앱에서는 어려울 거에요.\n\n크고 복잡한 애플리케이션에서는 SQLAlchemy와 같은 ORM (객체-관계 매핑) 시스템 사용이 좋은 아이디어라고 말할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n# 데이터베이스를 직접 호출하기\nquery = 'select * from dogs where age \u003c 5'\n\ncursor.execute(query)\ndogs = cursor.fetchall()\n\nprint(dogs)\r\n```\n\n```js\r\n# SQLALchemy 사용하기\nstmt = select(Dog).where(Dog.age\u003c5)\ndogs = session.execute(stmt)\n\nprint(dogs)\r\n```\n\nORM은 우리 데이터베이스를 감싼 래퍼인데, 시작하는 데는 학습 곡선이 있을 수 있어요. 하지만 거대한 응용프로그램에는 구조가 필요하다는 걸 기억해봐요.\n\n만약 FastAPI 앱에서 수천 개의 문자열 SQL 쿼리를 처리해야 한다면 상황은 좀 체증스러울 거에요 (코드베이스와 정신 건강 모두 말이에요)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 6) 엔드포인트에 대한 입력 및 출력 정의\n\n나는 예전에 이렇게 엔드포인트를 작성했어요:\n\n```js\n# 나쁜 코드\n\n@app.get('/dogs')\ndef all_dogs():\n    return get_all_dogs()\n\n@app.get('/dogs/{id}')\ndef one_dog(id):\n    return get_dog(id)\n```\n\n^ 정확한 입력 및 출력 구조가 정의되지 않았어요. 문제점:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다른 개발자들이 입력과 출력이 무엇인지 추측하는 데 시간을 낭비할 필요가 없어집니다\n- 미래에는 아마도 당신이 입력과 출력이 무엇인지 추측하는 데 시간을 낭비할 수도 있습니다\n\n결국 이렇게 코드를 작성하는 것을 배웠어요:\n\n```js\n# 덜 나쁜 코드\n\n@app.get(\n    '/dogs', \n    response_model=List[Dog],\n    name='모든 개 가져오기'\n)\ndef all_dogs() -\u003e List[Dog]:\n    return get_all_dogs()\n\n@app.get(\n    '/dogs/{id}',\n    response_model=DogWithMoreInfo,\n    name='아이디로 한 마리 개 가져오기'\n)\ndef one_dog(id: int) -\u003e Dog:\n    return get_dog(id)\n```\n\n^ 여기서 type 어노테이션을 사용하고 app.get() 내부의 response_model 키워드 인수를 사용하여 각 엔드포인트의 입력과 출력이 무엇이어야 하는지 훨씬 명확하게 만들었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7) 모델 간의 관계\n\n우리에게는 사람과 개가 있고, 한 사람이 여러 마리의 개를 소유할 수 있다고 가정해 봅시다.\n\n모델 간의 관계를 사용하기 전에, 다음은 우리의 Dog 모델이 어떻게 보일지에 대한 예시입니다:\n\n```js\n// dog\n{\n    \"name\": \"rocky\",\n    \"age\": 3,\n    \"owner_id\": 1\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기술적으로 우리는 이렇게 작성할 수 있어요:\n\n```js\n// dog\n{\n    \"name\": \"rocky\",\n    \"age\": 3,\n    \"owner_id\": 1,\n    \"owner\": {\n        \"name\": \"tom\",\n        \"age\": 30,\n        \"job\": \"teacher\"\n    }\n}\n```\n\n하지만 특히 수백 개의 API 엔드포인트를 다루고 있다면 이것이 지루할 수 있어요.\n\n대신, SQLModels 관계를 사용하여 우리의 삶을 더 쉽게 만들 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 매우 간단한 예시\n\nclass Human(HumanBase, table=True):\n    __tablename__ = 'humans'\n\n    dogs: list[\"Dog\"] = Relationship(back_populates='owner')\n\nclass Dog(DogBase, table=True):\n    __tablename__ = 'dogs'\n\n    owner: Human = Relationship(back_populates='dogs')\n```\n\n우리 엔드포인트 코드에서 response_model을 Dog로 설정하면 자동으로 Human 정보도 가져올 수 있습니다:\n\n```js\n{\n    \"name\": \"rocky\",\n    \"age\": 3,\n    \"owner_id\": 1,\n    \"owner\": {\n        \"name\": \"tom\",\n        \"age\": 30,\n        \"job\": \"teacher\"\n    }\n}\n```\n\n그리고 데이터베이스 내의 다른 중요한 관계들도 함께 가져옵니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 8) 접근 제어 및 어떤 API에 누가 접근할 수 있는지\n\n학교 코드에서 기억하는 것은 모든 엔드포인트가 공개적이었다는 것입니다. 우리는 단지 엔드포인트의 입력과 출력이 올바른지에만 주의를 기울렸고, 다른 것들에는 그다지 신경을 쓰지 않았습니다.\n\n그러나 모든 것이 공개적으로 되어 있다는 것은 좋지 않은 실천 방법입니다.\n\n프로덕션 급 코드에서는 다음과 같은 시스템이 필요합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- API 호출을 하는 사용자 식별\n- 해당 사용자가 호출할 수 있는 API 엔드포인트 결정\n\n한 걸음 더 나아가면, 서로 다른 사용자가 볼 수 있는 결과를 제어할 수도 있습니다. 예를 들어:\n\n- 관리자는 모든 것을 볼 수 있음\n- 비관리자는 자신의 이름이 포함된 항목만 볼 수 있음\n\n이를 구현하는 하나의 올바른 방법이 없으므로 시간을 들여 신중하게 생각해보시기 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 9) 로깅\n\n프로덕션급 FastAPI 코드에서는 아마도 독립형 스크립트를 제외하고는 print()를 사용하지 않습니다.\n\n대신 로거를 사용합니다. 로깅의 몇 가지 장점:\n\n- 정보를 캡처하는 방법이 팀 전체에서 표준화됨\n- 여러 로깅 기능이 이미 구현되어 있어 그냥 사용하기만 하면 됨\n- 다양한 로깅 레벨은 애플리케이션을 실행할 때 얼마나 많은 출력을 원하는지 결정하는 데 매우 유용함\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬 백엔드/풀스택 개발자가 되고 싶다면, 로깅 라이브러리에 대해 배우거나 적어도 어느 정도는 알아야 합니다. 기억하세요 — 프로덕션급 코드에서는 print()를 많이 사용하지 않아요.\n\n# 10) 예외 처리\n\n여러 해 전에 예외를 처리했던 방법은 다음과 같습니다 (나쁜 방법):\n\n```js\ntry:\n    # 내 코드\nexcept Exception as e:\n    print(e)\n```\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로덕션 수준의 FastAPI 코드베이스에서는 일반적으로 다음을 갖춥니다:\n\n- 상당수의 사용자 정의 예외\n- 이러한 사용자 정의 예외를 저장하기 위한 별도의 폴더\n- 정확히 어떤 예외를 잡고자 하는지 지정하는 보다 복잡한 예외 처리문\n- 단순히 print(e)를 출력하는 것 이상의 작업을 수행하는 예외 및 마지막 문에서 더 복잡한 코드\n\n예를 들어:\n\n```python\ntry:\n    # 어떤 코드\n\nexcept CustomException1 as e:\n    # 특별 처리 코드\n    \n    logger.info(str(e))\n\nexcept CustomException2 as e:\n    # 한 번 다시 시도하는 코드\n\n    logger.info(str(e))\n\nexcept CustomException3 as e:\n    # 이 예외를 기반으로 다른 예외 발생\n\n    raise CustomException4() from e\n\nexcept Exception as e:\n    logger.info(str(e))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로덕션 수준의 FastAPI 앱에서는 단순히 Exception as e로 모든 예외를 처리할 수 없습니다.\n\n# 11) 단위 테스트 및 기타 테스트\n\n학교 프로젝트에서는 테스트를 작성할 필요가 없었습니다. 주로 프레젠테이션 이후에는 코드를 더 이상 사용하지 않기 때문입니다.\n\n그러나 프로덕션 수준의 코드베이스에서는 단위 테스트뿐만 아니라 통합 테스트 등이 필수적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 수십 개의 엔드포인트를 테스트해야 한다면 일종의 자동화된 테스트를 도입할 필요가 있어요.\n- 모든 사람이 테스트를 수작업으로 모든 것을 테스트하면 만족스럽지 않을 거예요.\n\n단위 테스트를 작성하는 것이 지루할 수 있지만, 나는 대규모 코드 베이스에서는 필수적이라는 것을 깨달았어요.\n\n테스트에 익숙하지 않다면 pytest 학습을 시도해 볼 수 있어요.\n\n# 12) 데이터의 업데이트 이력 추적\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 데이터를 생성/업데이트/삭제할 때마다 이를 이상적으로는 어떤 종류의 히스토리 테이블에 기록해야 합니다.\n\n예를 들어, 사용자가 PUT 엔드포인트 중 하나를 사용하여 그의 개의 색상을 노란색으로 업데이트하고 이를 데이터베이스에 저장했다고 가정해보겠습니다.\n\n히스토리 테이블 내에서 이 작업을 추적하기 위해 다음과 같이 보일 수 있습니다.\n\n- 우리의 주요 개 데이터가 포함된 dogs 테이블이 있다고 가정해봅시다.\n- dogs 테이블에 있는 각 개에 대해 수행된 모든 변경 사항이 포함된 dog_history 테이블이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 예시 워크플로우입니다:\n\n- 사용자 A가 자신의 강아지 색상을 노란색으로 업데이트합니다 (강아지 ID=100).\n- 우리는 강아지 테이블을 보통대로 업데이트합니다.\n- 그런 다음 강아지 이력 테이블에 새 항목을 삽입합니다.\n- 새 항목에는 1) 사용자 2) 타임스탬프 3) 변경된 필드 4) 이전 값 5) 새 값이 포함됩니다.\n- 예를 들어, \"사용자 A가 (ID가 100인 강아지)의 색상을 초록에서 노란색으로 변경했습니다.\"\n\n```js\n{\n    user=A, \n    dog_id=100, \n    field_changed='color', \n    old_value='green', \n    new_value='yellow',\n    timestamp=178787878787\n}\n```\n\n^ 이와 같이 사용자의 업데이트 작업을 추적할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 13) 데이터베이스 변경 추적\n\n대규모 프로덕션급 앱에서는 데이터 모델에 변경 사항이 있을 수 있습니다. 이를 데이터베이스에서 (테이블 수정이 필요한 경우) 변경할 필요가 있을 수 있습니다.\n\n- 일부 테이블에 열 추가가 필요할 수 있습니다.\n- 완전히 새로운 테이블을 추가해야 할 수도 있습니다.\n\n프로덕션급 앱에서는 데이터베이스를 직접 변경하지 않습니다. 여러 이유로 이는 최악의 실천 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 변경 사항은 되돌릴 수 없습니다 — 누군가 변경을 실수하면 되돌릴 수 없어요\n- 변경 사항은 추적할 수 없습니다 — 누군가 변경을 실수하면 누가 그것을 했는지 알 수 없어요\n\n보통, 팀 내 모든 사람들이 데이터베이스에 가하는 모든 변경 사항을 포함하는 전통적인 dbchanges 폴더가 있습니다\n\n- 이 dbchanges 폴더에는 보통 여러 폴더가 포함되어 있습니다.\n- 각 폴더에는 일부 .xml 파일과 .sql 파일이 들어 있습니다. 이것들을 각각 changeset이라고 합니다.\n- 우리가 changeset을 실행하면 그 안에 있는 변경 사항이 데이터베이스에 적용됩니다.\n- 만약 changeset이 실수라면 데이터베이스가 손상되지 않도록 롤백을 수행할 수 있습니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이해하기 쉽고 명확했기를 바랍니다.\n\n# 만약 나를 창작자로 지원하고 싶다면\n\n- 내 책을 구매해 주세요! — 파이썬에 대해 알지 못했던 101가지\n- 어디에서 찾을 수 있는지: https://payhip.com/b/vywcf\n- 해당 이야기에 50번의 박수를 쳐 주세요\n- 당신의 생각을 말해 주는 댓글을 남겨주세요\n- 이야기 중 가장 마음에 드는 부분을 강조해 주세요\n\n감사합니다! 이 작은 행동들은 큰 도움이 되며 정말 감사드립니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nYouTube: [https://www.youtube.com/@zlliu246](https://www.youtube.com/@zlliu246)  \n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)  ","ogImage":{"url":"/assets/img/2024-06-20-13ThingsIveLearntToConsiderWhenCodingAFastAPIApp_0.png"},"coverImage":"/assets/img/2024-06-20-13ThingsIveLearntToConsiderWhenCodingAFastAPIApp_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e대학 시절에는 학교 프로젝트를 위해 쓸만한 한 페이지 FastAPI 백엔드 애플리케이션을 만들 수 있었어요. 솔직히 말해 많은 교수님들이 우리의 프로젝트 코드를 읽지도 않으셨다니까요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 예시: 쓸만한 한 페이지 fastapi 앱\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e fastapi \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e FastAPI\n\napp = FastAPI()\n\n\u003cspan class=\"hljs-meta\"\u003e@app.get(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-string\"\u003e'/stuff'\u003c/span\u003e\u003c/span\u003e)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_all\u003c/span\u003e():\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\u003cspan class=\"hljs-string\"\u003e'과일'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'사과'\u003c/span\u003e}\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e uvicorn\nuvicorn.run(app)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e^ 우리는 이렇게 코드를 작성해서 가능한 빨리 일을 끝낼 수 있었고, 우리의 백엔드 엔드포인트가 올바른 결과를 반환하기만 하면, 대부분의 경우 우리 코드가 얼마나 잘 작성되었는지는 아무도 신경쓰지 않았어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저는 현재 대규모 프로덕션급 FastAPI 앱을 개발 중이에요. 만약 제가 이 중 하나라도 하게 된다면, 개발 책임자님에게 혼날 거라고 확신해요. 지난 몇 달 동안 대규모 FastAPI 앱을 만들며 배운 13가지 고려 사항을 소개해드릴게요.\u003c/p\u003e\n\u003ch1\u003e1) 타입 어노테이션 (타입 힌트)\u003c/h1\u003e\n\u003cp\u003e이전에 내 코드를 작성했던 방식은 다음과 같아요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edo_stuff\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea, b, c\u003c/span\u003e):\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e지금 제가 코드를 작성하는 방식은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e typing \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\n\ndef \u003cspan class=\"hljs-title function_\"\u003edo_stuff\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: int, \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: str, \u003cspan class=\"hljs-attr\"\u003ec\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e[int]) -\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e[str]:\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 내장 typing 모듈을 사용하여 몇 가지 타입 주석을 추가했습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea는 정수여야 합니다.\u003c/li\u003e\n\u003cli\u003eb는 문자열이어야 합니다.\u003c/li\u003e\n\u003cli\u003ec는 정수들로 이루어진 리스트여야 합니다.\u003c/li\u003e\n\u003cli\u003e함수의 반환 값은 문자열들로 이루어진 리스트여야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e노트 — 타입 어노테이션(또는 타입 힌트)은 데이터 타입을 강제하지 않습니다. 그저 제안하는 것뿐입니다. 기술적으로 잘못된 데이터 타입을 전달할 수 있지만, Python은 여전히 허용합니다.\u003c/p\u003e\n\u003cp\u003e하지만, 타입 어노테이션을 작성하는 것은 내가 의도적으로 하는 선택입니다 — 나는 이것들을 다른 개발자들이 동일한 코드베이스에서 작업할 때 명확하고 이해하기 쉽도록 하기 위해 작성합니다. 이렇게 하면 다른 개발자들이 데이터 타입이 정확히 무엇인지 알아내기 위해 더 많은 시간을 낭비하지 않아도 됩니다.\u003c/p\u003e\n\u003ch1\u003e2) 정적 타입 체커를 사용하기\u003c/h1\u003e\n\u003cp\u003e타입 어노테이션은 데이터 타입을 강제하지 않지만, mypy와 같은 정적 타입 체커는 강제합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea: \u003cspan class=\"hljs-built_in\"\u003eint\u003c/span\u003e, b: \u003cspan class=\"hljs-built_in\"\u003eint\u003c/span\u003e\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-built_in\"\u003eint\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e a + b\n\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(add(\u003cspan class=\"hljs-string\"\u003e'hello '\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'world'\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 a와 b는 정수형이어야 하지만 문자열을 전달했습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e일반적으로 Python은 이를 허용합니다\u003c/li\u003e\n\u003cli\u003emypy와 같은 정적 형 검사 도구는 허용하지 않습니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e따라서 데이터 유형 위반에 대한 추가적인 보호층으로 정적 유형 검사기를 CICD(지속적 통합 지속적 배포) 파이프라인의 일부로 포함하는 것이 중요하다는 것을 깨달았습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e3) PEP8 및 코드 스타일링\u003c/h1\u003e\n\u003cp\u003e링크: \u003ca href=\"https://peps.python.org/pep-0008/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://peps.python.org/pep-0008/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e예전에 코드를 작성할 때 PEP8을 무시했었어요. 그러다가 코드가 금방 지저분하고 못생기게 되는 것을 깨달았죠.\u003c/p\u003e\n\u003cp\u003ePEP8 문서는 우리에게 Python 코딩 규칙을 제공하여 코드베이스를 일관되고 깔끔하게 유지하는 것이 이상적이라는 것을 알려줍니다. Python에서는 이를 무시할 수 있지만, 당신의 기술 리드는 그렇게 하지 말라고 할지도 몰라요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e내 머릿속에 기억나는 몇 가지 규칙이 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e함수 간에는 1줄의 개행을 추가해 주세요, 클래스 간에는 2줄의 개행을 넣어 주세요.\u003c/li\u003e\n\u003cli\u003e들여쓰기는 탭 대신 공백을 사용해야 합니다.\u003c/li\u003e\n\u003cli\u003efrom X import * 는 좋지 않은 습관입니다.\u003c/li\u003e\n\u003cli\u003eimport 구문은 어떤 순서로든 정리되어야 합니다.\u003c/li\u003e\n\u003cli\u003e코드 라인은 79자 이상으로 길어지면 안 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e파이썬 개발자가 되고 싶다면, PEP8 문서를 한 번은 꼭 살펴보기를 추천해요. 대부분의 코딩 관례를 조금이라도 익히는 데 도움이 될 거예요.\u003c/p\u003e\n\u003cp\u003e참고 — 때로는 제가 코드를 작성할 때 PEP8 규칙을 무시하기도 하지만, 프로덕션 코드를 작성할 때는 최대한 모든 규칙을 준수하려 노력하고 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e4) 폴더 구조 및 도메인\u003c/h1\u003e\n\u003cp\u003e학교 프로젝트에서는 어디에 .py 파일을 놓느냐에 상관없이 파일을 마구 놓을 수 있지만, 제품용 코드에서는 그렇게 할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e제품용 코드에서는 모든 사람이 따라야 할 폴더/파일 구조가 있습니다. 각 팀마다 약간씩 다를 수 있지만, 동일한 팀 구성원 모두가 합의해야 할 사항입니다.\u003c/p\u003e\n\u003cp\u003esrc/\n└── sqlmodels/\n└── dog.py\n└── cat.py\n└── bird.py\n└── dbchanges/\n└── code/\n└── bin/\n└── utils/\n└── web_api/\n└── domain1\n└── router.py\n└── service.py\n└── models.py\n└── domain2\n└── router.py\n└── service.py\n└── models.py\n└── domain3\n└── router.py\n└── service.py\n└── models.py\n└── requirements/\n.gitignore\nREADME.md\ndockerfile\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기는 내 제품용 FastAPI 코드의 매우 간소화된 버전입니다 (실제 폴더 구조는 훨씬 더 큽니다)\u003c/p\u003e\n\u003cp\u003e참고 - 우리 응용 프로그램의 각 하위 섹션은 독립된 도메인 폴더가 제공됩니다.\u003c/p\u003e\n\u003cp\u003e.MD 파일을 마크다운 형식으로 변경해주세요.\u003c/p\u003e\n\u003cp\u003e.py 파일을 마음대로 어디에 둘 수 있고 아무도 신경 쓰지 않는 시절은 지나갔지만, 내가 주장하는 바에 의하면 이것은 좋은 일이라고 생각합니다 - 합의된 폴더 구조는 전체 프로젝트를 더 깔끔하고 유지 관리하기 쉽게 만듭니다.\u003c/p\u003e\n\u003cp\u003eORM(객체-관계 매핑)을 사용하는 것이란 SQLAlchemy와 같은 것들.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e제가 학교 프로젝트에서 FastAPI 앱을 다룬 것을 기억해요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e각 엔드포인트마다, 데이터에 접근할 때는 데이터베이스를 직접 호출했어요.\u003c/li\u003e\n\u003cli\u003eMongoDB에서 바로 사전을 받고, 곧바로 반환했어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e^ 다만 이 방법에는 문제가 있어요 — 앱이 커질수록 굉장히 지저분하고 유지보수하기 어려워져요. 작은 앱이라면 상관없을 수도 있지만, 대규모 앱에서는 어려울 거에요.\u003c/p\u003e\n\u003cp\u003e크고 복잡한 애플리케이션에서는 SQLAlchemy와 같은 ORM (객체-관계 매핑) 시스템 사용이 좋은 아이디어라고 말할 수 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 데이터베이스를 직접 호출하기\nquery = \u003cspan class=\"hljs-string\"\u003e'select * from dogs where age \u0026#x3C; 5'\u003c/span\u003e\n\ncursor.\u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e(query)\ndogs = cursor.\u003cspan class=\"hljs-title function_\"\u003efetchall\u003c/span\u003e()\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(dogs)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eSQLALchemy\u003c/span\u003e 사용하기\nstmt = \u003cspan class=\"hljs-title function_\"\u003eselect\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ewhere\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eage\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\ndogs = session.\u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e(stmt)\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(dogs)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eORM은 우리 데이터베이스를 감싼 래퍼인데, 시작하는 데는 학습 곡선이 있을 수 있어요. 하지만 거대한 응용프로그램에는 구조가 필요하다는 걸 기억해봐요.\u003c/p\u003e\n\u003cp\u003e만약 FastAPI 앱에서 수천 개의 문자열 SQL 쿼리를 처리해야 한다면 상황은 좀 체증스러울 거에요 (코드베이스와 정신 건강 모두 말이에요)\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e6) 엔드포인트에 대한 입력 및 출력 정의\u003c/h1\u003e\n\u003cp\u003e나는 예전에 이렇게 엔드포인트를 작성했어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 나쁜 코드\n\n@app.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/dogs'\u003c/span\u003e)\ndef \u003cspan class=\"hljs-title function_\"\u003eall_dogs\u003c/span\u003e():\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_all_dogs\u003c/span\u003e()\n\n@app.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/dogs/{id}'\u003c/span\u003e)\ndef \u003cspan class=\"hljs-title function_\"\u003eone_dog\u003c/span\u003e(id):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_dog\u003c/span\u003e(id)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e^ 정확한 입력 및 출력 구조가 정의되지 않았어요. 문제점:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e다른 개발자들이 입력과 출력이 무엇인지 추측하는 데 시간을 낭비할 필요가 없어집니다\u003c/li\u003e\n\u003cli\u003e미래에는 아마도 당신이 입력과 출력이 무엇인지 추측하는 데 시간을 낭비할 수도 있습니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e결국 이렇게 코드를 작성하는 것을 배웠어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 덜 나쁜 코드\n\n@app.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\n    \u003cspan class=\"hljs-string\"\u003e'/dogs'\u003c/span\u003e, \n    response_model=\u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e[\u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e],\n    name=\u003cspan class=\"hljs-string\"\u003e'모든 개 가져오기'\u003c/span\u003e\n)\ndef \u003cspan class=\"hljs-title function_\"\u003eall_dogs\u003c/span\u003e() -\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e[\u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e]:\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_all_dogs\u003c/span\u003e()\n\n@app.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\n    \u003cspan class=\"hljs-string\"\u003e'/dogs/{id}'\u003c/span\u003e,\n    response_model=\u003cspan class=\"hljs-title class_\"\u003eDogWithMoreInfo\u003c/span\u003e,\n    name=\u003cspan class=\"hljs-string\"\u003e'아이디로 한 마리 개 가져오기'\u003c/span\u003e\n)\ndef \u003cspan class=\"hljs-title function_\"\u003eone_dog\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: int) -\u003e \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_dog\u003c/span\u003e(id)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e^ 여기서 type 어노테이션을 사용하고 app.get() 내부의 response_model 키워드 인수를 사용하여 각 엔드포인트의 입력과 출력이 무엇이어야 하는지 훨씬 명확하게 만들었습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e7) 모델 간의 관계\u003c/h1\u003e\n\u003cp\u003e우리에게는 사람과 개가 있고, 한 사람이 여러 마리의 개를 소유할 수 있다고 가정해 봅시다.\u003c/p\u003e\n\u003cp\u003e모델 간의 관계를 사용하기 전에, 다음은 우리의 Dog 모델이 어떻게 보일지에 대한 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// dog\u003c/span\u003e\n{\n    \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"rocky\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"age\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"owner_id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e기술적으로 우리는 이렇게 작성할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// dog\u003c/span\u003e\n{\n    \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"rocky\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"age\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"owner_id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"owner\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"tom\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"age\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"job\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"teacher\"\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 특히 수백 개의 API 엔드포인트를 다루고 있다면 이것이 지루할 수 있어요.\u003c/p\u003e\n\u003cp\u003e대신, SQLModels 관계를 사용하여 우리의 삶을 더 쉽게 만들 수 있어요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 매우 간단한 예시\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHuman\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eHumanBase\u003c/span\u003e, table=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e):\n    __tablename__ = \u003cspan class=\"hljs-string\"\u003e'humans'\u003c/span\u003e\n\n    \u003cspan class=\"hljs-attr\"\u003edogs\u003c/span\u003e: list[\u003cspan class=\"hljs-string\"\u003e\"Dog\"\u003c/span\u003e] = \u003cspan class=\"hljs-title class_\"\u003eRelationship\u003c/span\u003e(back_populates=\u003cspan class=\"hljs-string\"\u003e'owner'\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDogBase\u003c/span\u003e, table=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e):\n    __tablename__ = \u003cspan class=\"hljs-string\"\u003e'dogs'\u003c/span\u003e\n\n    \u003cspan class=\"hljs-attr\"\u003eowner\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eHuman\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eRelationship\u003c/span\u003e(back_populates=\u003cspan class=\"hljs-string\"\u003e'dogs'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리 엔드포인트 코드에서 response_model을 Dog로 설정하면 자동으로 Human 정보도 가져올 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n    \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"rocky\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"age\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"owner_id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"owner\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"tom\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"age\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"job\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"teacher\"\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 데이터베이스 내의 다른 중요한 관계들도 함께 가져옵니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e8) 접근 제어 및 어떤 API에 누가 접근할 수 있는지\u003c/h1\u003e\n\u003cp\u003e학교 코드에서 기억하는 것은 모든 엔드포인트가 공개적이었다는 것입니다. 우리는 단지 엔드포인트의 입력과 출력이 올바른지에만 주의를 기울렸고, 다른 것들에는 그다지 신경을 쓰지 않았습니다.\u003c/p\u003e\n\u003cp\u003e그러나 모든 것이 공개적으로 되어 있다는 것은 좋지 않은 실천 방법입니다.\u003c/p\u003e\n\u003cp\u003e프로덕션 급 코드에서는 다음과 같은 시스템이 필요합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eAPI 호출을 하는 사용자 식별\u003c/li\u003e\n\u003cli\u003e해당 사용자가 호출할 수 있는 API 엔드포인트 결정\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e한 걸음 더 나아가면, 서로 다른 사용자가 볼 수 있는 결과를 제어할 수도 있습니다. 예를 들어:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e관리자는 모든 것을 볼 수 있음\u003c/li\u003e\n\u003cli\u003e비관리자는 자신의 이름이 포함된 항목만 볼 수 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이를 구현하는 하나의 올바른 방법이 없으므로 시간을 들여 신중하게 생각해보시기 바랍니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e9) 로깅\u003c/h1\u003e\n\u003cp\u003e프로덕션급 FastAPI 코드에서는 아마도 독립형 스크립트를 제외하고는 print()를 사용하지 않습니다.\u003c/p\u003e\n\u003cp\u003e대신 로거를 사용합니다. 로깅의 몇 가지 장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e정보를 캡처하는 방법이 팀 전체에서 표준화됨\u003c/li\u003e\n\u003cli\u003e여러 로깅 기능이 이미 구현되어 있어 그냥 사용하기만 하면 됨\u003c/li\u003e\n\u003cli\u003e다양한 로깅 레벨은 애플리케이션을 실행할 때 얼마나 많은 출력을 원하는지 결정하는 데 매우 유용함\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e파이썬 백엔드/풀스택 개발자가 되고 싶다면, 로깅 라이브러리에 대해 배우거나 적어도 어느 정도는 알아야 합니다. 기억하세요 — 프로덕션급 코드에서는 print()를 많이 사용하지 않아요.\u003c/p\u003e\n\u003ch1\u003e10) 예외 처리\u003c/h1\u003e\n\u003cp\u003e여러 해 전에 예외를 처리했던 방법은 다음과 같습니다 (나쁜 방법):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n    # 내 코드\nexcept \u003cspan class=\"hljs-title class_\"\u003eException\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ee\u003c/span\u003e:\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e프로덕션 수준의 FastAPI 코드베이스에서는 일반적으로 다음을 갖춥니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e상당수의 사용자 정의 예외\u003c/li\u003e\n\u003cli\u003e이러한 사용자 정의 예외를 저장하기 위한 별도의 폴더\u003c/li\u003e\n\u003cli\u003e정확히 어떤 예외를 잡고자 하는지 지정하는 보다 복잡한 예외 처리문\u003c/li\u003e\n\u003cli\u003e단순히 print(e)를 출력하는 것 이상의 작업을 수행하는 예외 및 마지막 문에서 더 복잡한 코드\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e# 어떤 코드\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexcept\u003c/span\u003e CustomException1 \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e e:\n    \u003cspan class=\"hljs-comment\"\u003e# 특별 처리 코드\u003c/span\u003e\n    \n    logger.info(\u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e(e))\n\n\u003cspan class=\"hljs-keyword\"\u003eexcept\u003c/span\u003e CustomException2 \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e e:\n    \u003cspan class=\"hljs-comment\"\u003e# 한 번 다시 시도하는 코드\u003c/span\u003e\n\n    logger.info(\u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e(e))\n\n\u003cspan class=\"hljs-keyword\"\u003eexcept\u003c/span\u003e CustomException3 \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e e:\n    \u003cspan class=\"hljs-comment\"\u003e# 이 예외를 기반으로 다른 예외 발생\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003eraise\u003c/span\u003e CustomException4() \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e e\n\n\u003cspan class=\"hljs-keyword\"\u003eexcept\u003c/span\u003e Exception \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e e:\n    logger.info(\u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e(e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e프로덕션 수준의 FastAPI 앱에서는 단순히 Exception as e로 모든 예외를 처리할 수 없습니다.\u003c/p\u003e\n\u003ch1\u003e11) 단위 테스트 및 기타 테스트\u003c/h1\u003e\n\u003cp\u003e학교 프로젝트에서는 테스트를 작성할 필요가 없었습니다. 주로 프레젠테이션 이후에는 코드를 더 이상 사용하지 않기 때문입니다.\u003c/p\u003e\n\u003cp\u003e그러나 프로덕션 수준의 코드베이스에서는 단위 테스트뿐만 아니라 통합 테스트 등이 필수적입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e수십 개의 엔드포인트를 테스트해야 한다면 일종의 자동화된 테스트를 도입할 필요가 있어요.\u003c/li\u003e\n\u003cli\u003e모든 사람이 테스트를 수작업으로 모든 것을 테스트하면 만족스럽지 않을 거예요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단위 테스트를 작성하는 것이 지루할 수 있지만, 나는 대규모 코드 베이스에서는 필수적이라는 것을 깨달았어요.\u003c/p\u003e\n\u003cp\u003e테스트에 익숙하지 않다면 pytest 학습을 시도해 볼 수 있어요.\u003c/p\u003e\n\u003ch1\u003e12) 데이터의 업데이트 이력 추적\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e사용자가 데이터를 생성/업데이트/삭제할 때마다 이를 이상적으로는 어떤 종류의 히스토리 테이블에 기록해야 합니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 사용자가 PUT 엔드포인트 중 하나를 사용하여 그의 개의 색상을 노란색으로 업데이트하고 이를 데이터베이스에 저장했다고 가정해보겠습니다.\u003c/p\u003e\n\u003cp\u003e히스토리 테이블 내에서 이 작업을 추적하기 위해 다음과 같이 보일 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e우리의 주요 개 데이터가 포함된 dogs 테이블이 있다고 가정해봅시다.\u003c/li\u003e\n\u003cli\u003edogs 테이블에 있는 각 개에 대해 수행된 모든 변경 사항이 포함된 dog_history 테이블이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 예시 워크플로우입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자 A가 자신의 강아지 색상을 노란색으로 업데이트합니다 (강아지 ID=100).\u003c/li\u003e\n\u003cli\u003e우리는 강아지 테이블을 보통대로 업데이트합니다.\u003c/li\u003e\n\u003cli\u003e그런 다음 강아지 이력 테이블에 새 항목을 삽입합니다.\u003c/li\u003e\n\u003cli\u003e새 항목에는 1) 사용자 2) 타임스탬프 3) 변경된 필드 4) 이전 값 5) 새 값이 포함됩니다.\u003c/li\u003e\n\u003cli\u003e예를 들어, \"사용자 A가 (ID가 100인 강아지)의 색상을 초록에서 노란색으로 변경했습니다.\"\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n    user=A, \n    dog_id=\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, \n    field_changed=\u003cspan class=\"hljs-string\"\u003e'color'\u003c/span\u003e, \n    old_value=\u003cspan class=\"hljs-string\"\u003e'green'\u003c/span\u003e, \n    new_value=\u003cspan class=\"hljs-string\"\u003e'yellow'\u003c/span\u003e,\n    timestamp=\u003cspan class=\"hljs-number\"\u003e178787878787\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e^ 이와 같이 사용자의 업데이트 작업을 추적할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e13) 데이터베이스 변경 추적\u003c/h1\u003e\n\u003cp\u003e대규모 프로덕션급 앱에서는 데이터 모델에 변경 사항이 있을 수 있습니다. 이를 데이터베이스에서 (테이블 수정이 필요한 경우) 변경할 필요가 있을 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e일부 테이블에 열 추가가 필요할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e완전히 새로운 테이블을 추가해야 할 수도 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e프로덕션급 앱에서는 데이터베이스를 직접 변경하지 않습니다. 여러 이유로 이는 최악의 실천 방법입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e변경 사항은 되돌릴 수 없습니다 — 누군가 변경을 실수하면 되돌릴 수 없어요\u003c/li\u003e\n\u003cli\u003e변경 사항은 추적할 수 없습니다 — 누군가 변경을 실수하면 누가 그것을 했는지 알 수 없어요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e보통, 팀 내 모든 사람들이 데이터베이스에 가하는 모든 변경 사항을 포함하는 전통적인 dbchanges 폴더가 있습니다\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 dbchanges 폴더에는 보통 여러 폴더가 포함되어 있습니다.\u003c/li\u003e\n\u003cli\u003e각 폴더에는 일부 .xml 파일과 .sql 파일이 들어 있습니다. 이것들을 각각 changeset이라고 합니다.\u003c/li\u003e\n\u003cli\u003e우리가 changeset을 실행하면 그 안에 있는 변경 사항이 데이터베이스에 적용됩니다.\u003c/li\u003e\n\u003cli\u003e만약 changeset이 실수라면 데이터베이스가 손상되지 않도록 롤백을 수행할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이해하기 쉽고 명확했기를 바랍니다.\u003c/p\u003e\n\u003ch1\u003e만약 나를 창작자로 지원하고 싶다면\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e내 책을 구매해 주세요! — 파이썬에 대해 알지 못했던 101가지\u003c/li\u003e\n\u003cli\u003e어디에서 찾을 수 있는지: \u003ca href=\"https://payhip.com/b/vywcf\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://payhip.com/b/vywcf\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e해당 이야기에 50번의 박수를 쳐 주세요\u003c/li\u003e\n\u003cli\u003e당신의 생각을 말해 주는 댓글을 남겨주세요\u003c/li\u003e\n\u003cli\u003e이야기 중 가장 마음에 드는 부분을 강조해 주세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e감사합니다! 이 작은 행동들은 큰 도움이 되며 정말 감사드립니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eYouTube: \u003ca href=\"https://www.youtube.com/@zlliu246\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.youtube.com/@zlliu246\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eLinkedIn: \u003ca href=\"https://www.linkedin.com/in/zlliu/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.linkedin.com/in/zlliu/\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-13ThingsIveLearntToConsiderWhenCodingAFastAPIApp"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>