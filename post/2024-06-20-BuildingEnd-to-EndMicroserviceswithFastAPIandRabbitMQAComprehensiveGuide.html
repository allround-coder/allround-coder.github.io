<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>파스트 API와 RabbitMQ를 이용한 엔드-투-엔드 마이크로서비스 구축하기 포괄적 안내 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="파스트 API와 RabbitMQ를 이용한 엔드-투-엔드 마이크로서비스 구축하기 포괄적 안내 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="파스트 API와 RabbitMQ를 이용한 엔드-투-엔드 마이크로서비스 구축하기 포괄적 안내 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide" data-gatsby-head="true"/><meta name="twitter:title" content="파스트 API와 RabbitMQ를 이용한 엔드-투-엔드 마이크로서비스 구축하기 포괄적 안내 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 01:54" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">파스트 API와 RabbitMQ를 이용한 엔드-투-엔드 마이크로서비스 구축하기 포괄적 안내</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="파스트 API와 RabbitMQ를 이용한 엔드-투-엔드 마이크로서비스 구축하기 포괄적 안내" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">29<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png" alt="image"></p>
<h1>소개:</h1>
<p>최근 몇 년간, 마이크로서비스 아키텍처는 확장 가능하고 유지보수 가능하며 유연한 애플리케이션을 만드는 능력 때문에 인기를 얻었습니다. 이 블로그 포스트에서는 마이크로서비스 아키텍처의 개념을 탐구하고, 파이썬 생태계의 강력한 도구인 FastAPI와 RabbitMQ를 사용하여 간단한 마이크로서비스를 구축하는 방법을 보여드리겠습니다.</p>
<h1>몰리딕 아키텍처란?</h1>
<div class="content-ad"></div>
<p>단일체 아키텍처는 모든 비즈니스 관심을 결합하는 단일 대규모 컴퓨팅 네트워크로, 하나의 코드 베이스로 생각해 볼 수 있습니다. 애플리케이션의 모든 구성 요소를 하나의 지붕 아래에 모아둔 거대하고 빙하처럼 보이는 구조라고 상상해보세요. 단일체에서 변경을 하려면 전체 스택을 업데이트해야 하며, 이는 시간이 많이 소요되고 엄격할 수 있습니다. 아래 다이어그램에서 단일체 아키텍처의 예시를 볼 수 있습니다.</p>
<p><img src="/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_1.png" alt="단일체 아키텍처 다이어그램"></p>
<h1>마이크로서비스 아키텍처란?</h1>
<p>반면에, 마이크로서비스 아키텍처는 응용 프로그램이 작은, 독립적으로 배포 가능한 서비스로 분할되는 접근 방식입니다. 각 서비스는 해당하는 비즈니스 로직과 데이터베이스를 갖고 있으며, 가벼운 프로토콜을 통해 다른 서비스와 통신합니다. 이 접근 방식은 빠른 개발 주기, 쉬운 유지보수, 그리고 더 나은 확장성을 가능하게 합니다.</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_2.png">
<h1>Monolithic vs. Microservice의 차이</h1>
<img src="/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_3.png">
<h1>RabbitMQ는 무엇이며, 왜 마이크로서비스를 구축하는 데 사용되는가?</h1>
<div class="content-ad"></div>
<p>RabbitMQ는 진보된 메시지 큐잉 프로토콜(AMQP)을 구현하는 메시지 브로커입니다. RabbitMQ는 분산 시스템의 다양한 구성 요소 사이에서 중개자 역할을 하여 효율적으로 통신하고 작업을 조정할 수 있도록 합니다. RabbitMQ가 마이크로서비스 아키텍처에서 흔히 사용되는 이유는 다음과 같습니다:</p>
<ul>
<li>Decoupling: RabbitMQ는 시스템 구성 요소들을 비동기적으로 통신할 수 있게 함으로써 시스템을 분리하는 데 도움을 줍니다. 이는 서비스가 서로의 응답을 기다리지 않고 독립적으로 작동할 수 있어 더 견고하고 확장 가능한 시스템을 이끌어냅니다.</li>
<li>Load Balancing: RabbitMQ는 메시지를 여러 소비자 인스턴스에 분배함으로써 부하를 균형 있게 분배하고 효율적인 자원 활용을 보장합니다.</li>
<li>Fault Tolerance: RabbitMQ는 클러스터링과 복제를 지원하여 노드가 실패해도 메시지가 손실되지 않도록 합니다. 이는 시스템을 더욱 고장 내성이 뛰어나고 신뢰할 수 있도록 만듭니다.</li>
<li>Scalability: RabbitMQ를 사용하면 소비자 인스턴스나 클러스터에 노드를 추가하여 시스템을 확장할 수 있어 애플리케이션이 성장함에 따라 증가하는 메시지 트래픽을 처리할 수 있습니다.</li>
<li>Message Routing: RabbitMQ는 직접, 주제, 팬아웃과 같은 다양한 메시지 라우팅 메커니즘을 지원하여 라우팅 키나 패턴에 따라 특정 큐로 메시지를 전달할 수 있습니다.</li>
<li>Message Acknowledgment: RabbitMQ는 메시지 승인을 지원하여 메시지가 한 번만 처리되고 전송 중에 손실되지 않도록 보장합니다.</li>
<li>전반적으로 RabbitMQ는 확장 가능하고 분리되고 고장 내성이 뛰어난 마이크로서비스 아키텍처를 구축하는 데 도움이 되는 견고하고 신뢰할 수 있는 메시징 시스템입니다.</li>
</ul>
<h1>마이크로서비스 응용프로그램 코딩</h1>
<h1>1. 프로젝트 소개</h1>
<div class="content-ad"></div>
<p>저희 어플리케이션은 네 가지 주요 서비스로 구성되어 있습니다:</p>
<ul>
<li>Gateway Service: 이 서비스는 모든 들어오는 요청의 진입 지점 역할을 합니다. 요청을 적절한 마이크로서비스로 라우팅하고 어플리케이션의 전체적인 조정을 담당합니다.</li>
<li>ML Service: ML 서비스는 이미지 데이터를 처리하는 역할을 합니다. Keras OCR을 사용하여 이미지에서 텍스트를 추출하고 Gateway Service와 통신하여 이미지 데이터를 받아 추출된 텍스트를 전송합니다.</li>
<li>Auth Service: Auth 서비스는 사용자 인증 및 이메일 인증을 처리합니다. 사용자 등록, OTP 생성 및 검증, 이메일 인증 확인 기능이 포함되어 있습니다.</li>
<li>Notification Service: 이 서비스는 사용자에게 이메일을 보내는 역할을 합니다. 프로세스가 완료될 때 트리거됩니다.</li>
</ul>
<h2>2. 준비 사항</h2>
<p>시작하기 전에 다음 사항을 확인해주세요:</p>
<div class="content-ad"></div>
<ul>
<li>시스템에 Docker가 설치되어 있습니다.</li>
<li>시스템에 Python이 설치되어 있습니다.</li>
<li>Docker, Python 및 PostgreSQL에 대한 기본 지식이 있습니다.</li>
</ul>
<h1>3. 요구 사항 설정</h1>
<h2>Docker를 사용하여 PostgreSQL 설치</h2>
<p>PostgreSQL을 Docker를 사용하여 설치하려면 다음 명령을 실행하십시오:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">도커를 사용하여 <span class="hljs-title class_">RabbitMQ</span>를 설치하기 위해서는 다음 명령어를 실행하세요:

도커를 실행하여 <span class="hljs-title class_">RabbitMQ</span>를 설치하려면 다음 명령어를 실행하세요:

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content-ad"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>

# <span class="hljs-number">4.</span> 프로젝트 설정하기

## A. 프로젝트 폴더 설정하기

microservices-demo/
│
├── gateway/
│ ├── rpc_client.<span class="hljs-property">py</span>
│ ├── .<span class="hljs-property">env</span> 
│ ├── requirements.<span class="hljs-property">txt</span>
│ └── main.<span class="hljs-property">py</span>
│
├── ml_services/
│ ├── requirements.<span class="hljs-property">txt</span>
│ ├── artifacts/
│ ├── .<span class="hljs-property">env</span>
│ └── main.<span class="hljs-property">py</span>
│
├── notification_service/
│ ├── email_service.<span class="hljs-property">py</span>
│ ├── requirements.<span class="hljs-property">txt</span>
│ ├── .<span class="hljs-property">env</span>
│ └── main.<span class="hljs-property">py</span>
│
├── auth/
│ ├── database.<span class="hljs-property">py</span>
│ ├── models.<span class="hljs-property">py</span>
│ ├── schemas.<span class="hljs-property">py</span>
│ ├── service.<span class="hljs-property">py</span>
│ ├── requirements.<span class="hljs-property">txt</span>
│ ├── .<span class="hljs-property">env</span>
│ └── main.<span class="hljs-property">py</span>
│
└── <span class="hljs-variable constant_">README</span>.<span class="hljs-property">md</span>

## B. 게이트웨이 구현하기

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

이제 게이트웨이 서비스를 구현해 봅시다. gateway/ 디렉토리에 main.<span class="hljs-property">py</span> 파일을 만들어 아래 코드를 추가해주세요:

<span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> <span class="hljs-title class_">FastAPI</span>, <span class="hljs-title class_">HTTPException</span>, <span class="hljs-title class_">File</span>, <span class="hljs-title class_">UploadFile</span>
<span class="hljs-keyword">import</span> fastapi <span class="hljs-keyword">as</span> _fastapi
<span class="hljs-keyword">from</span> fastapi.<span class="hljs-property">security</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">OAuth2PasswordBearer</span>
<span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv
<span class="hljs-keyword">from</span> jwt.<span class="hljs-property">exceptions</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">DecodeError</span>
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> <span class="hljs-title class_">BaseModel</span>
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">import</span> base64
<span class="hljs-keyword">import</span> pika
<span class="hljs-keyword">import</span> logging
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> jwt
<span class="hljs-keyword">import</span> rpc_client

app = <span class="hljs-title class_">FastAPI</span>()
oauth2_scheme = <span class="hljs-title class_">OAuth2PasswordBearer</span>(tokenUrl=<span class="hljs-string">"token"</span>)

# 환경 변수 로드
<span class="hljs-title function_">load_dotenv</span>()
logging.<span class="hljs-title function_">basicConfig</span>(level=logging.<span class="hljs-property">INFO</span>)

# 환경 변수 가져오기
<span class="hljs-variable constant_">JWT_SECRET</span> = os.<span class="hljs-property">environ</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"JWT_SECRET"</span>)
<span class="hljs-variable constant_">AUTH_BASE_URL</span> = os.<span class="hljs-property">environ</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"AUTH_BASE_URL"</span>)
<span class="hljs-variable constant_">RABBITMQ_URL</span> = os.<span class="hljs-property">environ</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"RABBITMQ_URL"</span>)

# <span class="hljs-title class_">RabbitMQ</span>에 연결
connection = pika.<span class="hljs-title class_">BlockingConnection</span>(pika.<span class="hljs-title class_">ConnectionParameters</span>(<span class="hljs-variable constant_">RABBITMQ_URL</span>))
channel = connection.<span class="hljs-title function_">channel</span>()
channel.<span class="hljs-title function_">queue_declare</span>(queue=<span class="hljs-string">'gatewayservice'</span>)
channel.<span class="hljs-title function_">queue_declare</span>(queue=<span class="hljs-string">'ocr_service'</span>)

# <span class="hljs-variable constant_">JWT</span> 토큰 유효성 검사
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">jwt_validation</span>(<span class="hljs-attr">token</span>: str = _fastapi.<span class="hljs-title class_">Depends</span>(oauth2_scheme)):
    <span class="hljs-attr">try</span>:
        payload = jwt.<span class="hljs-title function_">decode</span>(token, <span class="hljs-variable constant_">JWT_SECRET</span>, algorithms=[<span class="hljs-string">"HS256"</span>])
        <span class="hljs-keyword">return</span> payload
    except <span class="hljs-title class_">DecodeError</span>:
        raise <span class="hljs-title class_">HTTPException</span>(status_code=<span class="hljs-number">401</span>, detail=<span class="hljs-string">"Invalid JWT token"</span>)

# 요청 바디를 위한 <span class="hljs-title class_">Pydantic</span> 모델
<span class="hljs-keyword">class</span> <span class="hljs-title class_">GenerateUserToken</span>(<span class="hljs-title class_">BaseModel</span>):
    <span class="hljs-attr">username</span>: str
    <span class="hljs-attr">password</span>: str

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserCredentials</span>(<span class="hljs-title class_">BaseModel</span>):
    <span class="hljs-attr">username</span>: str
    <span class="hljs-attr">password</span>: str

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserRegisteration</span>(<span class="hljs-title class_">BaseModel</span>):
    <span class="hljs-attr">name</span>: str
    <span class="hljs-attr">email</span>: str
    <span class="hljs-attr">password</span>: str

<span class="hljs-keyword">class</span> <span class="hljs-title class_">GenerateOtp</span>(<span class="hljs-title class_">BaseModel</span>):
    <span class="hljs-attr">email</span>: str

<span class="hljs-keyword">class</span> <span class="hljs-title class_">VerifyOtp</span>(<span class="hljs-title class_">BaseModel</span>):
    <span class="hljs-attr">email</span>: str
    <span class="hljs-attr">otp</span>: int

# 인증 라우트
@app.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/auth/login"</span>, tags=[<span class="hljs-string">'Authentication Service'</span>])
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">login</span>(<span class="hljs-attr">user_data</span>: <span class="hljs-title class_">UserCredentials</span>):
    <span class="hljs-attr">try</span>:
        response = requests.<span class="hljs-title function_">post</span>(f<span class="hljs-string">"{AUTH_BASE_URL}/api/token"</span>, json={<span class="hljs-string">"username"</span>: user_data.<span class="hljs-property">username</span>, <span class="hljs-string">"password"</span>: user_data.<span class="hljs-property">password</span>})
        <span class="hljs-keyword">if</span> response.<span class="hljs-property">status_code</span> == <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>()
        <span class="hljs-attr">else</span>:
            raise <span class="hljs-title class_">HTTPException</span>(status_code=response.<span class="hljs-property">status_code</span>, detail=response.<span class="hljs-title function_">json</span>())
    except requests.<span class="hljs-property">exceptions</span>.<span class="hljs-property">ConnectionError</span>:
        raise <span class="hljs-title class_">HTTPException</span>(status_code=<span class="hljs-number">503</span>, detail=<span class="hljs-string">"Authentication service is unavailable"</span>)

@app.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/auth/register"</span>, tags=[<span class="hljs-string">'Authentication Service'</span>])
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">registeration</span>(<span class="hljs-attr">user_data</span>: <span class="hljs-title class_">UserRegisteration</span>):
    <span class="hljs-attr">try</span>:
        response = requests.<span class="hljs-title function_">post</span>(f<span class="hljs-string">"{AUTH_BASE_URL}/api/users"</span>, json={<span class="hljs-string">"name"</span>: user_data.<span class="hljs-property">name</span>, <span class="hljs-string">"email"</span>: user_data.<span class="hljs-property">email</span>, <span class="hljs-string">"password"</span>: user_data.<span class="hljs-property">password</span>})
        <span class="hljs-keyword">if</span> response.<span class="hljs-property">status_code</span> == <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>()
        <span class="hljs-attr">else</span>:
            raise <span class="hljs-title class_">HTTPException</span>(status_code=response.<span class="hljs-property">status_code</span>, detail=response.<span class="hljs-title function_">json</span>())
    except requests.<span class="hljs-property">exceptions</span>.<span class="hljs-property">ConnectionError</span>:
        raise <span class="hljs-title class_">HTTPException</span>(status_code=<span class="hljs-number">503</span>, detail=<span class="hljs-string">"Authentication service is unavailable"</span>)

@app.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/auth/generate_otp"</span>, tags=[<span class="hljs-string">'Authentication Service'</span>])
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">generate_otp</span>(<span class="hljs-attr">user_data</span>: <span class="hljs-title class_">GenerateOtp</span>):
    <span class="hljs-attr">try</span>:
        response = requests.<span class="hljs-title function_">post</span>(f<span class="hljs-string">"{AUTH_BASE_URL}/api/users/generate_otp"</span>, json={<span class="hljs-string">"email"</span>: user_data.<span class="hljs-property">email</span>})
        <span class="hljs-keyword">if</span> response.<span class="hljs-property">status_code</span> == <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>()
        <span class="hljs-attr">else</span>:
            raise <span class="hljs-title class_">HTTPException</span>(status_code=response.<span class="hljs-property">status_code</span>, detail=response.<span class="hljs-title function_">json</span>())
    except requests.<span class="hljs-property">exceptions</span>.<span class="hljs-property">ConnectionError</span>:
        raise <span class="hljs-title class_">HTTPException</span>(status_code=<span class="hljs-number">503</span>, detail=<span class="hljs-string">"Authentication service is unavailable"</span>)

@app.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/auth/verify_otp"</span>, tags=[<span class="hljs-string">'Authentication Service'</span>])
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">verify_otp</span>(<span class="hljs-attr">user_data</span>: <span class="hljs-title class_">VerifyOtp</span>):
    <span class="hljs-attr">try</span>:
        response = requests.<span class="hljs-title function_">post</span>(f<span class="hljs-string">"{AUTH_BASE_URL}/api/users/verify_otp"</span>, json={<span class="hljs-string">"email"</span>: user_data.<span class="hljs-property">email</span>, <span class="hljs-string">"otp"</span>: user_data.<span class="hljs-property">otp</span>})
        <span class="hljs-keyword">if</span> response.<span class="hljs-property">status_code</span> == <span class="hljs-number">200</span>:
            <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>()
        <span class="hljs-attr">else</span>:
            raise <span class="hljs-title class_">HTTPException</span>(status_code=response.<span class="hljs-property">status_code</span>, detail=response.<span class="hljs-title function_">json</span>())
    except requests.<span class="hljs-property">exceptions</span>.<span class="hljs-property">ConnectionError</span>:
        raise <span class="hljs-title class_">HTTPException</span>(status_code=<span class="hljs-number">503</span>, detail=<span class="hljs-string">"Authentication service is unavailable"</span>)

# 확장 서비스 <span class="hljs-variable constant_">OCR</span> 라우트
@app.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/ocr'</span>, tags=[<span class="hljs-string">'Machine learning Service'</span>])
def <span class="hljs-title function_">ocr</span>(<span class="hljs-attr">file</span>: <span class="hljs-title class_">UploadFile</span> = <span class="hljs-title class_">File</span>(...), <span class="hljs-attr">payload</span>: dict = _fastapi.<span class="hljs-title class_">Depends</span>(jwt_validation)):
    # 파일을 임시 위치에 저장
    <span class="hljs-keyword">with</span> <span class="hljs-title function_">open</span>(file.<span class="hljs-property">filename</span>, <span class="hljs-string">"wb"</span>) <span class="hljs-keyword">as</span> <span class="hljs-attr">buffer</span>:
        buffer.<span class="hljs-title function_">write</span>(file.<span class="hljs-property">file</span>.<span class="hljs-title function_">read</span>())

    ocr_rpc = rpc_client.<span class="hljs-title class_">OcrRpcClient</span>()

    <span class="hljs-keyword">with</span> <span class="hljs-title function_">open</span>(file.<span class="hljs-property">filename</span>, <span class="hljs-string">"rb"</span>) <span class="hljs-keyword">as</span> <span class="hljs-attr">buffer</span>:
        file_data = buffer.<span class="hljs-title function_">read</span>()
        file_base64 = base64.<span class="hljs-title function_">b64encode</span>(file_data).<span class="hljs-title function_">decode</span>()

    request_json = {
        <span class="hljs-string">'user_name'</span>: payload[<span class="hljs-string">'name'</span>],
        <span class="hljs-string">'user_email'</span>: payload[<span class="hljs-string">'email'</span>],
        <span class="hljs-string">'user_id'</span>: payload[<span class="hljs-string">'id'</span>],
        <span class="hljs-string">'file'</span>: file_base64
    }

    # <span class="hljs-variable constant_">OCR</span> 마이크로서비스에 요청 <span class="hljs-title class_">JSON</span>을 사용하여 호출
    response = ocr_rpc.<span class="hljs-title function_">call</span>(request_json)

    # 임시 이미지 파일 삭제
    os.<span class="hljs-title function_">remove</span>(file.<span class="hljs-property">filename</span>)
    <span class="hljs-keyword">return</span> response

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-keyword">import</span> uvicorn
    uvicorn.<span class="hljs-title function_">run</span>(<span class="hljs-string">"main:app"</span>, host=<span class="hljs-string">"0.0.0.0"</span>, port=<span class="hljs-number">5001</span>, reload=<span class="hljs-title class_">True</span>)

게이트웨이 환경을 설정하려면 gateway 폴더에 .<span class="hljs-property">env</span> 파일을 만드세요.

<span class="hljs-variable constant_">AUTH_BASE_URL</span>=<span class="hljs-attr">http</span>:<span class="hljs-comment">//0.0.0.0:5000</span>
<span class="hljs-variable constant_">JWT_SECRET</span>=e56623570e0a0152989fd38e13da9cd6eb7031e4e039e939ba845167ee59b496
<span class="hljs-variable constant_">RABBITMQ_URL</span>=localhost

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

다른 마이크로서비스와 통신하기 위해 <span class="hljs-title class_">RabbitMQ</span>를 사용할 것입니다. 이는 서비스 간 비동기 메시징을 가능하게 하는 메시지 브로커입니다. <span class="hljs-title class_">RabbitMQ</span> 서버와의 통신을 처리하기 위해 gateway/ 디렉토리에 rpc_client.<span class="hljs-property">py</span> 파일을 생성할 것입니다.

<span class="hljs-keyword">import</span> pika
<span class="hljs-keyword">import</span> uuid
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv
<span class="hljs-keyword">import</span> os

# 환경 변수 로딩
<span class="hljs-title function_">load_dotenv</span>()
<span class="hljs-variable constant_">RABBITMQ_URL</span> = os.<span class="hljs-property">environ</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"RABBITMQ_URL"</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">OcrRpcClient</span>(object):

    def <span class="hljs-title function_">__init__</span>(self):
        self.<span class="hljs-property">connection</span> = pika.<span class="hljs-title class_">BlockingConnection</span>(
            pika.<span class="hljs-title class_">ConnectionParameters</span>(host=<span class="hljs-variable constant_">RABBITMQ_URL</span>))

        self.<span class="hljs-property">channel</span> = self.<span class="hljs-property">connection</span>.<span class="hljs-title function_">channel</span>()

        result = self.<span class="hljs-property">channel</span>.<span class="hljs-title function_">queue_declare</span>(queue=<span class="hljs-string">''</span>, exclusive=<span class="hljs-title class_">True</span>)
        self.<span class="hljs-property">callback_queue</span> = result.<span class="hljs-property">method</span>.<span class="hljs-property">queue</span>

        self.<span class="hljs-property">channel</span>.<span class="hljs-title function_">basic_consume</span>(
            queue=self.<span class="hljs-property">callback_queue</span>,
            on_message_callback=self.<span class="hljs-property">on_response</span>,
            auto_ack=<span class="hljs-title class_">True</span>)

    def <span class="hljs-title function_">on_response</span>(self, ch, method, props, body):
        <span class="hljs-keyword">if</span> self.<span class="hljs-property">corr_id</span> == props.<span class="hljs-property">correlation_id</span>:
            self.<span class="hljs-property">response</span> = body

    def <span class="hljs-title function_">call</span>(self, message):
        self.<span class="hljs-property">response</span> = <span class="hljs-title class_">None</span>
        self.<span class="hljs-property">corr_id</span> = <span class="hljs-title function_">str</span>(uuid.<span class="hljs-title function_">uuid4</span>())
        self.<span class="hljs-property">channel</span>.<span class="hljs-title function_">basic_publish</span>(
            exchange=<span class="hljs-string">''</span>,
            routing_key=<span class="hljs-string">'ocr_service'</span>,
            properties=pika.<span class="hljs-title class_">BasicProperties</span>(
                reply_to=self.<span class="hljs-property">callback_queue</span>,
                correlation_id=self.<span class="hljs-property">corr_id</span>,
            ),
            body=json.<span class="hljs-title function_">dumps</span>(message))
        <span class="hljs-keyword">while</span> self.<span class="hljs-property">response</span> is <span class="hljs-title class_">None</span>:
            self.<span class="hljs-property">connection</span>.<span class="hljs-title function_">process_data_events</span>()
        response_json = json.<span class="hljs-title function_">loads</span>(self.<span class="hljs-property">response</span>)
        <span class="hljs-keyword">return</span> response_json

이 코드는 <span class="hljs-title class_">RabbitMQ</span>를 사용하여 <span class="hljs-variable constant_">OCR</span> 마이크로서비스(<span class="hljs-variable constant_">ML</span> 마이크로서비스)로 메시지를 보내기 위한 클라이언트 클래스인 <span class="hljs-title class_">OcrRpcClient</span>를 정의합니다. 연결을 초기화하고, 응답을 위한 콜백 큐를 설정하고, 메시지를 보내고 응답을 비동기적으로 받을 수 있는 방법을 제공합니다.

- 초기화(__init__):

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content-ad"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>

<span class="hljs-title class_">RabbitMQ</span>에 연결을 설정합니다. 채널을 생성하고 고유한 콜백 큐를 선언합니다. 콜백 큐에서 응답을 수신하기 위해 소비자를 설정합니다.

<span class="hljs-number">2.</span> 요청 보내기 (호출):

<span class="hljs-variable constant_">OCR</span> 마이크로서비스(<span class="hljs-variable constant_">ML</span> 마이크로서비스)에 메시지를 보냅니다. 콜백 큐에서 응답을 기다리고 반환합니다.

이 클래스는 <span class="hljs-title class_">RabbitMQ</span>를 사용하여 게이트웨이 서비스가 <span class="hljs-variable constant_">OCR</span> 마이크로서비스와 효율적으로 통신할 수 있게 합니다.

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

## C. <span class="hljs-title class_">Auth</span> 마이크로서비스 구현

이 코드는 <span class="hljs-title class_">FastAPI</span>를 사용하여 사용자 등록, 로그인, <span class="hljs-variable constant_">JWT</span> 토큰 생성, <span class="hljs-variable constant_">OTP</span>를 사용한 이메일 확인 및 사용자 프로필 검색을 제공하는 인증 서비스를 구현합니다. 데이터베이스 작업에는 <span class="hljs-title class_">SQLAlchemy</span>를 사용하고 <span class="hljs-variable constant_">OTP</span> 이메일을 보내기 위해 <span class="hljs-title class_">RabbitMQ</span>를 사용합니다. 이 서비스에는 사용자 생성, <span class="hljs-variable constant_">JWT</span> 토큰 생성, 사용자 프로필 검색 및 이메일 확인을 위한 <span class="hljs-variable constant_">OTP</span> 확인에 대한 엔드포인트가 포함되어 있습니다.

<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span>
<span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> <span class="hljs-title class_">HTTPException</span> 
<span class="hljs-keyword">import</span> fastapi <span class="hljs-keyword">as</span> _fastapi
<span class="hljs-keyword">import</span> schemas <span class="hljs-keyword">as</span> _schemas
<span class="hljs-keyword">import</span> sqlalchemy.<span class="hljs-property">orm</span> <span class="hljs-keyword">as</span> _orm
<span class="hljs-keyword">import</span> models <span class="hljs-keyword">as</span> _models
<span class="hljs-keyword">import</span> service <span class="hljs-keyword">as</span> _services
<span class="hljs-keyword">import</span> logging
<span class="hljs-keyword">import</span> database <span class="hljs-keyword">as</span> _database
<span class="hljs-keyword">import</span> pika

# rabbitmq connection
connection = pika.<span class="hljs-title class_">BlockingConnection</span>(pika.<span class="hljs-title class_">ConnectionParameters</span>(host=<span class="hljs-string">"localhost"</span>))
channel = connection.<span class="hljs-title function_">channel</span>()
channel.<span class="hljs-title function_">queue_declare</span>(queue=<span class="hljs-string">'email_notification'</span>)

def <span class="hljs-title function_">get_db</span>():
    db = _database.<span class="hljs-title class_">SessionLocal</span>()
    <span class="hljs-attr">try</span>:
        <span class="hljs-keyword">yield</span> db
    <span class="hljs-attr">finally</span>:
        db.<span class="hljs-title function_">close</span>()

app = _fastapi.<span class="hljs-title class_">FastAPI</span>()
logging.<span class="hljs-title function_">basicConfig</span>(level=logging.<span class="hljs-property">INFO</span>)
_models.<span class="hljs-property">Base</span>.<span class="hljs-property">metadata</span>.<span class="hljs-title function_">create_all</span>(_models.<span class="hljs-property">engine</span>)

@app.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/api/users"</span>, tags=[<span class="hljs-string">'사용자 인증'</span>])
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">create_user</span>(
    <span class="hljs-attr">user</span>: _schemas.<span class="hljs-property">UserCreate</span>, 
    <span class="hljs-attr">db</span>: _orm.<span class="hljs-property">Session</span> = _fastapi.<span class="hljs-title class_">Depends</span>(_services.<span class="hljs-property">get_db</span>)):
    db_user = <span class="hljs-keyword">await</span> _services.<span class="hljs-title function_">get_user_by_email</span>(email=user.<span class="hljs-property">email</span>, db=db)

    <span class="hljs-keyword">if</span> <span class="hljs-attr">db_user</span>:
        logging.<span class="hljs-title function_">info</span>(<span class="hljs-string">'해당 이메일로 이미 가입된 사용자가 있습니다'</span>)
        raise _fastapi.<span class="hljs-title class_">HTTPException</span>(
            status_code=<span class="hljs-number">200</span>,
            detail=<span class="hljs-string">"해당 이메일로 이미 가입된 사용자가 있습니다"</span>)

    user = <span class="hljs-keyword">await</span> _services.<span class="hljs-title function_">create_user</span>(user=user, db=db)

    <span class="hljs-keyword">return</span> _fastapi.<span class="hljs-title class_">HTTPException</span>(
            status_code=<span class="hljs-number">201</span>,
            detail=<span class="hljs-string">"사용자 등록이 완료되었습니다. 계정을 활성화하려면 이메일을 확인하세요!"</span>)

# <span class="hljs-variable constant_">API</span> 상태 확인 엔드포인트
@app.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/check_api"</span>)
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">check_api</span>():
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"status"</span>: <span class="hljs-string">"API와 연결되었습니다"</span>}

@app.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/api/token"</span>, tags=[<span class="hljs-string">'사용자 인증'</span>])
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">generate_token</span>(
    <span class="hljs-attr">user_data</span>: _schemas.<span class="hljs-property">GenerateUserToken</span>,
    <span class="hljs-attr">db</span>: _orm.<span class="hljs-property">Session</span> = _fastapi.<span class="hljs-title class_">Depends</span>(_services.<span class="hljs-property">get_db</span>)):
    user = <span class="hljs-keyword">await</span> _services.<span class="hljs-title function_">authenticate_user</span>(email=user_data.<span class="hljs-property">username</span>, password=user_data.<span class="hljs-property">password</span>, db=db)

    <span class="hljs-keyword">if</span> user == <span class="hljs-string">"is_verified_false"</span>:
        logging.<span class="hljs-title function_">info</span>(<span class="hljs-string">'이메일 확인이 필요합니다. 계속하려면 이메일을 확인하세요.'</span>)
        raise _fastapi.<span class="hljs-title class_">HTTPException</span>(
            status_code=<span class="hljs-number">403</span>, detail=<span class="hljs-string">"이메일 확인이 필요합니다. 계속하려면 이메일을 확인하세요."</span>)

    <span class="hljs-keyword">if</span> not <span class="hljs-attr">user</span>:
        logging.<span class="hljs-title function_">info</span>(<span class="hljs-string">'잘못된 자격 증명'</span>)
        raise _fastapi.<span class="hljs-title class_">HTTPException</span>(
            status_code=<span class="hljs-number">401</span>, detail=<span class="hljs-string">"잘못된 자격 증명"</span>)

    logging.<span class="hljs-title function_">info</span>(<span class="hljs-string">'JWT 토큰이 생성되었습니다.'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> _services.<span class="hljs-title function_">create_token</span>(user=user)

@app.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/api/users/me"</span>, response_model=_schemas.<span class="hljs-property">User</span>, tags=[<span class="hljs-string">'사용자 인증'</span>])
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">get_user</span>(<span class="hljs-attr">user</span>: _schemas.<span class="hljs-property">User</span> = _fastapi.<span class="hljs-title class_">Depends</span>(_services.<span class="hljs-property">get_current_user</span>)):
    <span class="hljs-keyword">return</span> user

@app.<span class="hljs-title function_">get</span>(<span class="hljs-string">"/api/users/profile"</span>, tags=[<span class="hljs-string">'사용자 인증'</span>])
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">get_user</span>(<span class="hljs-attr">email</span>: str, <span class="hljs-attr">db</span>: _orm.<span class="hljs-property">Session</span> = _fastapi.<span class="hljs-title class_">Depends</span>(_services.<span class="hljs-property">get_db</span>)):
    <span class="hljs-keyword">return</span> db.<span class="hljs-title function_">query</span>(_models.<span class="hljs-property">User</span> and _models.<span class="hljs-property">Address</span>).<span class="hljs-title function_">filter_by</span>(id=<span class="hljs-number">1</span>).<span class="hljs-title function_">first</span>()

@app.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/api/users/generate_otp"</span>, response_model=str, tags=[<span class="hljs-string">"사용자 인증"</span>])
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">send_otp_mail</span>(<span class="hljs-attr">userdata</span>: _schemas.<span class="hljs-property">GenerateOtp</span>, <span class="hljs-attr">db</span>: _orm.<span class="hljs-property">Session</span> = _fastapi.<span class="hljs-title class_">Depends</span>(_services.<span class="hljs-property">get_db</span>)):
    user = <span class="hljs-keyword">await</span> _services.<span class="hljs-title function_">get_user_by_email</span>(email=userdata.<span class="hljs-property">email</span>, db=db)

    <span class="hljs-keyword">if</span> not <span class="hljs-attr">user</span>:
        raise _fastapi.<span class="hljs-title class_">HTTPException</span>(status_code=<span class="hljs-number">404</span>, detail=<span class="hljs-string">"사용자를 찾을 수 없습니다"</span>)

    <span class="hljs-keyword">if</span> user.<span class="hljs-property">is_verified</span>:
        raise _fastapi.<span class="hljs-title class_">HTTPException</span>(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">"이미 확인된 사용자입니다"</span>)

    # <span class="hljs-variable constant_">OTP</span> 생성 및 전송
    otp = _services.<span class="hljs-title function_">generate_otp</span>()
    <span class="hljs-title function_">print</span>(otp)
    _services.<span class="hljs-title function_">send_otp</span>(userdata.<span class="hljs-property">email</span>, otp, channel)

    # <span class="hljs-variable constant_">OTP</span>를 데이터베이스에 저장
    user.<span class="hljs-property">otp</span> = otp
    db.<span class="hljs-title function_">add</span>(user)
    db.<span class="hljs-title function_">commit</span>()

    <span class="hljs-keyword">return</span> <span class="hljs-string">"이메일로 OTP가 전송되었습니다"</span>

@app.<span class="hljs-title function_">post</span>(<span class="hljs-string">"/api/users/verify_otp"</span>, tags=[<span class="hljs-string">"사용자 인증"</span>])
<span class="hljs-keyword">async</span> def <span class="hljs-title function_">verify_otp</span>(<span class="hljs-attr">userdata</span>: _schemas.<span class="hljs-property">VerifyOtp</span>, <span class="hljs-attr">db</span>: _orm.<span class="hljs-property">Session</span> = _fastapi.<span class="hljs-title class_">Depends</span>(_services.<span class="hljs-property">get_db</span>)):
    user = <span class="hljs-keyword">await</span> _services.<span class="hljs-title function_">get_user_by_email</span>(email=userdata.<span class="hljs-property">email</span>, db=db )

    <span class="hljs-keyword">if</span> not <span class="hljs-attr">user</span>:
        raise _fastapi.<span class="hljs-title class_">HTTPException</span>(status_code=<span class="hljs-number">404</span>, detail=<span class="hljs-string">"사용자를 찾을 수 없습니다"</span>)

    <span class="hljs-keyword">if</span> not user.<span class="hljs-property">otp</span> or user.<span class="hljs-property">otp</span> != userdata.<span class="hljs-property">otp</span>:
        raise _fastapi.<span class="hljs-title class_">HTTPException</span>(status_code=<span class="hljs-number">400</span>, detail=<span class="hljs-string">"잘못된 OTP"</span>)

    # 사용자의 is_verified 필드 업데이트
    user.<span class="hljs-property">is_verified</span> = <span class="hljs-title class_">True</span>
    user.<span class="hljs-property">otp</span> = <span class="hljs-title class_">None</span>  # <span class="hljs-variable constant_">OTP</span> 초기화
    db.<span class="hljs-title function_">add</span>(user)
    db.<span class="hljs-title function_">commit</span>()

    <span class="hljs-keyword">return</span> <span class="hljs-string">"이메일 확인이 성공적으로 완료되었습니다"</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-keyword">import</span> uvicorn
    uvicorn.<span class="hljs-title function_">run</span>(<span class="hljs-string">"main:app"</span>, host=<span class="hljs-string">"0.0.0.0"</span>, port=<span class="hljs-number">5000</span>, reload=<span class="hljs-title class_">True</span>)

이 코드는 <span class="hljs-title class_">PostgreSQL</span> 데이터베이스에 연결하기 위해 <span class="hljs-title class_">SQLAlchemy</span> 엔진과 세션 메이커를 설정합니다. dotenv를 사용하여 환경 변수에서 데이터베이스 연결 세부 정보를 로드합니다. <span class="hljs-variable constant_">DATABASE_URL</span>은 호스트, 데이터베이스 이름, 사용자 이름 및 암호를 포함하여 검색된 환경 변수를 사용하여 구성됩니다. 데이터베이스 연결 세부를 사용하여 create_engine를 사용하여 엔진을 생성하고 해당 엔진에 바인딩된 세션 메이커인 <span class="hljs-title class_">SessionLocal</span>을 정의합니다. <span class="hljs-variable constant_">ORM</span> 모델을 정의하는 <span class="hljs-title class_">Declarative</span> <span class="hljs-title class_">Base</span>로 사용하기 위해 <span class="hljs-title class_">Base</span> 변수가 초기화됩니다.

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

<span class="hljs-keyword">import</span> sqlalchemy <span class="hljs-keyword">as</span> _sql
<span class="hljs-keyword">import</span> sqlalchemy.<span class="hljs-property">ext</span>.<span class="hljs-property">declarative</span> <span class="hljs-keyword">as</span> _declarative
<span class="hljs-keyword">import</span> sqlalchemy.<span class="hljs-property">orm</span> <span class="hljs-keyword">as</span> _orm
<span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv
<span class="hljs-keyword">import</span> os

# .<span class="hljs-property">env</span> 파일에서 환경 변수를 불러옵니다
<span class="hljs-title function_">load_dotenv</span>()

# 환경 변수를 가져옵니다
postgres_host = os.<span class="hljs-property">environ</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"POSTGRES_HOST"</span>)
postgres_db = os.<span class="hljs-property">environ</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"POSTGRES_DB"</span>)
postgres_user = os.<span class="hljs-property">environ</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"POSTGRES_USER"</span>)
postgres_password = os.<span class="hljs-property">environ</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"POSTGRES_PASSWORD"</span>)

# <span class="hljs-title class_">PostgreSQL</span> 서버가 로컬에서 실행 중이라고 가정하고 <span class="hljs-string">'mydatabase'</span>라는 이름의 데이터베이스가 있다고 가정합니다
<span class="hljs-variable constant_">DATABASE_URL</span> = f<span class="hljs-string">"postgresql://{postgres_user}:{postgres_password}@{postgres_host}/{postgres_db}"</span>

engine = _sql.<span class="hljs-title function_">create_engine</span>(<span class="hljs-variable constant_">DATABASE_URL</span>)
<span class="hljs-title class_">SessionLocal</span> = _orm.<span class="hljs-title function_">sessionmaker</span>(autocommit=<span class="hljs-title class_">False</span>, autoflush=<span class="hljs-title class_">False</span>, bind=engine)
<span class="hljs-title class_">Base</span> = _declarative.<span class="hljs-title function_">declarative_base</span>()

이 코드는 사용자 및 주소 테이블에 대한 <span class="hljs-title class_">SQLAlchemy</span> 모델을 정의하며, 사용자 정보 및 주소를 저장하고 이들 사이의 관계를 설정합니다. 또한 제공된 엔진을 사용하여 데이터베이스에 테이블을 생성합니다.

<span class="hljs-keyword">import</span> datetime <span class="hljs-keyword">as</span> _dt
<span class="hljs-keyword">import</span> sqlalchemy <span class="hljs-keyword">as</span> _sql
<span class="hljs-keyword">import</span> sqlalchemy.<span class="hljs-property">orm</span> <span class="hljs-keyword">as</span> _orm
<span class="hljs-keyword">import</span> passlib.<span class="hljs-property">hash</span> <span class="hljs-keyword">as</span> _hash
<span class="hljs-keyword">from</span> database <span class="hljs-keyword">import</span> <span class="hljs-title class_">Base</span>, engine
<span class="hljs-keyword">import</span> database <span class="hljs-keyword">as</span> _database

<span class="hljs-title class_">Base</span>.<span class="hljs-property">metadata</span>.<span class="hljs-title function_">create_all</span>(engine)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>(_database.<span class="hljs-property">Base</span>):
    __tablename__ = <span class="hljs-string">"users"</span>
    id = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">Integer</span>, primary_key=<span class="hljs-title class_">True</span>, index=<span class="hljs-title class_">True</span>)
    name = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">String</span>)
    email = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">String</span>, unique=<span class="hljs-title class_">True</span>, index=<span class="hljs-title class_">True</span>)
    is_verified = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">Boolean</span>, <span class="hljs-keyword">default</span>=<span class="hljs-title class_">False</span>)
    otp = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">Integer</span>)
    hashed_password = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">String</span>)
    addresses = _orm.<span class="hljs-title function_">relationship</span>(<span class="hljs-string">"Address"</span>, back_populates=<span class="hljs-string">"user"</span>)
    date_created = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">DateTime</span>, <span class="hljs-keyword">default</span>=_dt.<span class="hljs-property">datetime</span>.<span class="hljs-property">utcnow</span>)

    def <span class="hljs-title function_">verify_password</span>(self, <span class="hljs-attr">password</span>: str):
        <span class="hljs-keyword">return</span> _hash.<span class="hljs-property">bcrypt</span>.<span class="hljs-title function_">verify</span>(password, self.<span class="hljs-property">hashed_password</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>(_database.<span class="hljs-property">Base</span>):
    __tablename__ = <span class="hljs-string">"addresses"</span>
    id = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">Integer</span>, primary_key=<span class="hljs-title class_">True</span>, index=<span class="hljs-title class_">True</span>)
    street = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">String</span>)
    landmark = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">String</span>)
    city = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">String</span>)
    country = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">String</span>)
    pincode = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">String</span>)
    user_id = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">Integer</span>, _sql.<span class="hljs-title class_">ForeignKey</span>(<span class="hljs-string">"users.id"</span>))
    user = _orm.<span class="hljs-title function_">relationship</span>(<span class="hljs-string">"User"</span>, back_populates=<span class="hljs-string">"addresses"</span>)
    latitude = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">Float</span>)
    longitude = _sql.<span class="hljs-title class_">Column</span>(_sql.<span class="hljs-property">Float</span>)

이 코드는 사용자 관련 데이터 구조에 대한 <span class="hljs-title class_">Pydantic</span> 모델을 정의하며, 사용자 생성, 인증 및 <span class="hljs-variable constant_">OTP</span> 확인용입니다. 위치 정보를 위한 주소 모델도 포함되어 있습니다. 이 모델들은 사전 속성으로부터 인스턴스를 자동으로 생성하도록 구성되어 있습니다.

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

이 코드는 사용자 인증 및 <span class="hljs-title function_">OTP</span>(일회용 비밀번호) 생성 및 확인을 위한 다양한 함수 및 종속성을 정의합니다. <span class="hljs-variable constant_">HTTP</span> 요청을 처리하기 위해 <span class="hljs-title class_">FastAPI</span>를 사용하며, 데이터베이스 작업을 위해 <span class="hljs-title class_">SQLAlchemy</span>를 사용하고 데이터 유효성 검사 및 직렬화를 위해 <span class="hljs-title class_">Pydantic</span>을 사용하며, 인증을 위해 <span class="hljs-variable constant_">JWT</span>를 사용하고, 이메일 알림을 보내기 위해 <span class="hljs-title class_">RabbitMQ</span>를 사용합니다. 이 함수들은 데이터베이스 생성, 데이터베이스 세션 가져오기, 새 사용자 생성, 사용자 인증, <span class="hljs-variable constant_">JWT</span> 토큰 생성, <span class="hljs-variable constant_">JWT</span> 토큰에서 현재 사용자 가져오기, 무작위 <span class="hljs-variable constant_">OTP</span> 생성, <span class="hljs-title class_">RabbitMQ</span>에 연결 및 <span class="hljs-variable constant_">OTP</span> 이메일 알림 전송 등이 포함됩니다.

환경 변수 로드

<span class="hljs-variable constant_">JWT_SECRET</span> = os.<span class="hljs-title function_">getenv</span>(<span class="hljs-string">"JWT_SECRET"</span>)
<span class="hljs-variable constant_">RABBITMQ_URL</span> = os.<span class="hljs-title function_">getenv</span>(<span class="hljs-string">"RABBITMQ_URL"</span>)
oauth2schema = _security.<span class="hljs-title class_">OAuth2PasswordBearer</span>(<span class="hljs-string">"/api/token"</span>)

데이터베이스 생성

def <span class="hljs-title function_">create_database</span>():
    # 데이터베이스 테이블 생성
    <span class="hljs-keyword">return</span> _database.<span class="hljs-property">Base</span>.<span class="hljs-property">metadata</span>.<span class="hljs-title function_">create_all</span>(bind=_database.<span class="hljs-property">engine</span>)

데이터베이스 세션 가져오기

def <span class="hljs-title function_">get_db</span>():
    # 데이터베이스 세션을 얻는 의존성
    db = _database.<span class="hljs-title class_">SessionLocal</span>()
    <span class="hljs-attr">try</span>:
        <span class="hljs-keyword">yield</span> db
    <span class="hljs-attr">finally</span>:
        db.<span class="hljs-title function_">close</span>()

이메일별 사용자 가져오기

<span class="hljs-keyword">async</span> def <span class="hljs-title function_">get_user_by_email</span>(<span class="hljs-attr">email</span>: str, <span class="hljs-attr">db</span>: _orm.<span class="hljs-property">Session</span>):
    # 데이터베이스에서 이메일별로 사용자 검색
    <span class="hljs-keyword">return</span> db.<span class="hljs-title function_">query</span>(_models.<span class="hljs-property">User</span>).<span class="hljs-title function_">filter</span>(_models.<span class="hljs-property">User</span>.<span class="hljs-property">email</span> == email and _models.<span class="hljs-property">User</span>.<span class="hljs-property">is_verified</span> == <span class="hljs-title class_">True</span>).<span class="hljs-title function_">first</span>()

새 사용자 생성

<span class="hljs-keyword">async</span> def <span class="hljs-title function_">create_user</span>(<span class="hljs-attr">user</span>: _schemas.<span class="hljs-property">UserCreate</span>, <span class="hljs-attr">db</span>: _orm.<span class="hljs-property">Session</span>):
    # 데이터베이스에 새 사용자 생성
    <span class="hljs-attr">try</span>:
        valid = _email_check.<span class="hljs-title function_">validate_email</span>(user.<span class="hljs-property">email</span>)
        name = user.<span class="hljs-property">name</span>
        email = valid.<span class="hljs-property">email</span>
    except _email_check.<span class="hljs-property">EmailNotValidError</span>:
        raise _fastapi.<span class="hljs-title class_">HTTPException</span>(status_code=<span class="hljs-number">404</span>, detail=<span class="hljs-string">"정확한 이메일을 입력하세요"</span>)

    user_obj = _models.<span class="hljs-title class_">User</span>(email=email, name=name, hashed_password=_hash.<span class="hljs-property">bcrypt</span>.<span class="hljs-title function_">hash</span>(user.<span class="hljs-property">password</span>))
    db.<span class="hljs-title function_">add</span>(user_obj)
    db.<span class="hljs-title function_">commit</span>()
    db.<span class="hljs-title function_">refresh</span>(user_obj)
    <span class="hljs-keyword">return</span> user_obj

사용자 인증

<span class="hljs-keyword">async</span> def <span class="hljs-title function_">authenticate_user</span>(<span class="hljs-attr">email</span>: str, <span class="hljs-attr">password</span>: str, <span class="hljs-attr">db</span>: _orm.<span class="hljs-property">Session</span>):
    # 사용자 인증
    user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">get_user_by_email</span>(email=email, db=db)

    <span class="hljs-keyword">if</span> not <span class="hljs-attr">user</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">False</span>
    
    <span class="hljs-keyword">if</span> not user.<span class="hljs-property">is_verified</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">'is_verified_false'</span>
    
    <span class="hljs-keyword">if</span> not user.<span class="hljs-title function_">verify_password</span>(password):
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">False</span>

    <span class="hljs-keyword">return</span> user

<span class="hljs-variable constant_">JWT</span> 토큰 생성

<span class="hljs-keyword">async</span> def <span class="hljs-title function_">create_token</span>(<span class="hljs-attr">user</span>: _models.<span class="hljs-property">User</span>):
    # 인증을 위한 <span class="hljs-variable constant_">JWT</span> 토큰 생성
    user_obj = _schemas.<span class="hljs-property">User</span>.<span class="hljs-title function_">from_orm</span>(user)
    user_dict = user_obj.<span class="hljs-title function_">model_dump</span>()
    del user_dict[<span class="hljs-string">"date_created"</span>]
    token = jwt.<span class="hljs-title function_">encode</span>(user_dict, <span class="hljs-variable constant_">JWT_SECRET</span>, algorithm=<span class="hljs-string">"HS256"</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">dict</span>(access_token=token, token_type=<span class="hljs-string">"bearer"</span>)

현재 사용자 가져오기

<span class="hljs-keyword">async</span> def <span class="hljs-title function_">get_current_user</span>(<span class="hljs-attr">db</span>: _orm.<span class="hljs-property">Session</span> = _fastapi.<span class="hljs-title class_">Depends</span>(get_db), <span class="hljs-attr">token</span>: str = _fastapi.<span class="hljs-title class_">Depends</span>(oauth2schema)):
    # <span class="hljs-variable constant_">JWT</span> 토큰에서 현재 인증된 사용자 가져오기
    <span class="hljs-attr">try</span>:
        payload = jwt.<span class="hljs-title function_">decode</span>(token, <span class="hljs-variable constant_">JWT_SECRET</span>, algorithms=[<span class="hljs-string">"HS256"</span>])
        user = db.<span class="hljs-title function_">query</span>(_models.<span class="hljs-property">User</span>).<span class="hljs-title function_">get</span>(payload[<span class="hljs-string">"id"</span>])
    <span class="hljs-attr">except</span>:
        raise _fastapi.<span class="hljs-title class_">HTTPException</span>(status_code=<span class="hljs-number">401</span>, detail=<span class="hljs-string">"유효하지 않은 이메일 또는 비밀번호"</span>)
    <span class="hljs-keyword">return</span> _schemas.<span class="hljs-property">User</span>.<span class="hljs-title function_">from_orm</span>(user)

랜덤 <span class="hljs-variable constant_">OTP</span> 생성

def <span class="hljs-title function_">generate_otp</span>():
    # 랜덤 <span class="hljs-variable constant_">OTP</span> 생성
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">str</span>(random.<span class="hljs-title function_">randint</span>(<span class="hljs-number">100000</span>, <span class="hljs-number">999999</span>))

<span class="hljs-title class_">RabbitMQ</span>에 연결

def <span class="hljs-title function_">connect_to_rabbitmq</span>():
    # <span class="hljs-title class_">RabbitMQ</span>에 연결
    <span class="hljs-keyword">while</span> <span class="hljs-title class_">True</span>:
        <span class="hljs-attr">try</span>:
            connection = pika.<span class="hljs-title class_">BlockingConnection</span>(pika.<span class="hljs-title class_">ConnectionParameters</span>(<span class="hljs-variable constant_">RABBITMQ_URL</span>))
            <span class="hljs-keyword">return</span> connection
        except pika.<span class="hljs-property">exceptions</span>.<span class="hljs-property">AMQPConnectionError</span>:
            <span class="hljs-title function_">print</span>(<span class="hljs-string">"RabbitMQ에 연결하지 못했습니다. 5초 후 다시 시도 중..."</span>)
            time.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">5</span>)

<span class="hljs-variable constant_">OTP</span> 이메일 알림 전송

def <span class="hljs-title function_">send_otp</span>(email, otp, channel):
    # <span class="hljs-title class_">RabbitMQ</span>를 사용하여 <span class="hljs-variable constant_">OTP</span> 이메일 알림 전송
    connection = <span class="hljs-title function_">connect_to_rabbitmq</span>()
    channel = connection.<span class="hljs-title function_">channel</span>()
    message = {<span class="hljs-string">'email'</span>: email,
               <span class="hljs-string">'subject'</span>: <span class="hljs-string">'계정 확인 OTP 알림'</span>,
               <span class="hljs-string">'other'</span>: <span class="hljs-string">'null'</span>,
               <span class="hljs-string">'body'</span>: f<span class="hljs-string">'계정 확인을 위한 OTP는 다음과 같습니다: {otp} \n 계정 설정을 완료하려면 확인 페이지에 이 OTP를 입력하세요. \n 이 OTP를 요청하지 않았다면 이 메시지를 무시해주세요.\n 감사합니다 '</span>
               }

    <span class="hljs-attr">try</span>:
        queue_declare_ok = channel.<span class="hljs-title function_">queue_declare</span>(queue=<span class="hljs-string">'email_notification'</span>, passive=<span class="hljs-title class_">True</span>)
        current_durable = queue_declare_ok.<span class="hljs-property">method</span>.<span class="hljs-property">queue</span>

        <span class="hljs-keyword">if</span> <span class="hljs-attr">current_durable</span>:
            <span class="hljs-keyword">if</span> queue_declare_ok.<span class="hljs-property">method</span>.<span class="hljs-property">queue</span> != <span class="hljs-attr">current_durable</span>:
                channel.<span class="hljs-title function_">queue_delete</span>(queue=<span class="hljs-string">'email_notification'</span>)
                channel.<span class="hljs-title function_">queue_declare</span>(queue=<span class="hljs-string">'email_notification'</span>, durable=<span class="hljs-title class_">True</span>)
        <span class="hljs-attr">else</span>:
            channel.<span class="hljs-title function_">queue_declare</span>(queue=<span class="hljs-string">'email_notification'</span>, durable=<span class="hljs-title class_">True</span>)

        channel.<span class="hljs-title function_">basic_publish</span>(
            exchange=<span class="hljs-string">""</span>,
            routing_key=<span class="hljs-string">'email_notification'</span>,
            body=json.<span class="hljs-title function_">dumps</span>(message),
            properties=pika.<span class="hljs-title class_">BasicProperties</span>(
                delivery_mode=pika.<span class="hljs-property">spec</span>.<span class="hljs-property">PERSISTENT_DELIVERY_MODE</span>
            ),
        )
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"OTP 이메일 알림 전송 완료"</span>)
    except <span class="hljs-title class_">Exception</span> <span class="hljs-keyword">as</span> <span class="hljs-attr">err</span>:
        <span class="hljs-title function_">print</span>(f<span class="hljs-string">"메시지 전송 실패: {err}"</span>)
    <span class="hljs-attr">finally</span>:
        channel.<span class="hljs-title function_">close</span>()
        connection.<span class="hljs-title function_">close</span>()

## D. 머신 러닝 마이크로서비스 구현

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

이 <span class="hljs-title class_">Python</span> 스크립트는 <span class="hljs-title class_">RabbitMQ</span> 서버에 연결하여 <span class="hljs-string">'ocr_service'</span>라는 큐에서 메시지를 소비합니다. 메시지를받으면 <span class="hljs-title class_">OCRService</span> 객체를 사용하여 처리하고 send_email_notification 함수를 사용하여 이메일 알림을 보내며, 그런 다음 응답을 응답 큐에 발행합니다. 각 메시지를 처리한 후 <span class="hljs-title class_">RabbitMQ</span>에 메시지 전달을 인식합니다. 스크립트는 <span class="hljs-title class_">RabbitMQ</span>가 전달할 수 있는 미인증 메시지의 수를 제한하는 prefetch count <span class="hljs-number">1</span>을 사용합니다.

<span class="hljs-keyword">import</span> pika
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> utils <span class="hljs-keyword">import</span> <span class="hljs-title class_">OCRService</span>
<span class="hljs-keyword">from</span> utils <span class="hljs-keyword">import</span> send_email_notification

# <span class="hljs-title class_">RabbitMQ</span>에 연결
connection = pika.<span class="hljs-title class_">BlockingConnection</span>(pika.<span class="hljs-title class_">ConnectionParameters</span>(host=<span class="hljs-string">'localhost'</span>))
channel = connection.<span class="hljs-title function_">channel</span>()
channel.<span class="hljs-title function_">queue_declare</span>(queue=<span class="hljs-string">'ocr_service'</span>)

# <span class="hljs-variable constant_">OCR</span> 요청을 처리하기 위한 콜백 함수
def <span class="hljs-title function_">on_request</span>(ch, method, props, body):
    # <span class="hljs-variable constant_">OCR</span> 서비스 초기화
    ocr_service = <span class="hljs-title class_">OCRService</span>()
    # <span class="hljs-variable constant_">OCR</span> 요청 처리
    response = ocr_service.<span class="hljs-title function_">process_request</span>(body)

    # 이메일 알림 전송
    <span class="hljs-title function_">send_email_notification</span>(response[<span class="hljs-string">'user_email'</span>], response[<span class="hljs-string">'ocr_text'</span>], channel)

    # 응답을 응답 큐에 발행
    ch.<span class="hljs-title function_">basic_publish</span>(exchange=<span class="hljs-string">''</span>,
                     routing_key=props.<span class="hljs-property">reply_to</span>,
                     properties=pika.<span class="hljs-title class_">BasicProperties</span>(correlation_id = \
                                                         props.<span class="hljs-property">correlation_id</span>),
                     body=json.<span class="hljs-title function_">dumps</span>(response))
    # 메시지 전달을 인식
    ch.<span class="hljs-title function_">basic_ack</span>(delivery_tag=method.<span class="hljs-property">delivery_tag</span>)
# prefetch count를 <span class="hljs-number">1</span>로 설정
channel.<span class="hljs-title function_">basic_qos</span>(prefetch_count=<span class="hljs-number">1</span>)
# <span class="hljs-string">'ocr_service'</span> 큐에서 메시지 수신
channel.<span class="hljs-title function_">basic_consume</span>(queue=<span class="hljs-string">'ocr_service'</span>, on_message_callback=on_request)
# 메시지 수신 시작
<span class="hljs-title function_">print</span>(<span class="hljs-string">" [x] RPC 요청 대기중"</span>)
channel.<span class="hljs-title function_">start_consuming</span>()

<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> base64
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
#keras ocr pipeline and imports
<span class="hljs-keyword">import</span> keras_ocr
<span class="hljs-keyword">import</span> pika

<span class="hljs-keyword">class</span> <span class="hljs-title class_">OCRService</span>:
   
    def <span class="hljs-title function_">__init__</span>(self):
        self.<span class="hljs-property">keras_pipeline</span> = keras_ocr.<span class="hljs-property">pipeline</span>.<span class="hljs-title class_">Pipeline</span>()

    def <span class="hljs-title function_">keras_ocr</span>(self, image_path):
        results = self.<span class="hljs-property">keras_pipeline</span>.<span class="hljs-title function_">recognize</span>([image_path])
        df = pd.<span class="hljs-title class_">DataFrame</span>(results[<span class="hljs-number">0</span>], columns=[<span class="hljs-string">'text'</span>, <span class="hljs-string">'bbox'</span>])
        words = df[<span class="hljs-string">'text'</span>].<span class="hljs-title function_">tolist</span>()
        sentence = <span class="hljs-string">' '</span>.<span class="hljs-title function_">join</span>(words)
        <span class="hljs-keyword">return</span> sentence

    def <span class="hljs-title function_">process_request</span>(self, message):
        message_body = json.<span class="hljs-title function_">loads</span>(message)
        user_name = message_body[<span class="hljs-string">'user_name'</span>]
        user_email = message_body[<span class="hljs-string">'user_email'</span>]
        user_id = message_body[<span class="hljs-string">'user_id'</span>]
        file_base64 = message_body[<span class="hljs-string">'file'</span>]
        <span class="hljs-title function_">print</span>(f<span class="hljs-string">" [x]user_id: {user_id} request recieved from gateway.."</span>)
        <span class="hljs-title function_">print</span>(f<span class="hljs-string">" [x]processing request for {user_name}"</span>)

        # file_base64에 base64로 인코딩된 문자열이 포함되어 있다고 가정
        file_data = base64.<span class="hljs-title function_">b64decode</span>(file_base64.<span class="hljs-title function_">encode</span>())
        # 디코드된 파일 데이터를 새 파일에 작성
        <span class="hljs-keyword">with</span> <span class="hljs-title function_">open</span>(<span class="hljs-string">'artifacts/decoded_file.png'</span>, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> <span class="hljs-attr">f</span>:
            f.<span class="hljs-title function_">write</span>(file_data)

        image_path = <span class="hljs-string">"artifacts/decoded_file.png"</span>
        ocr_text = self.<span class="hljs-title function_">keras_ocr</span>(image_path)
        <span class="hljs-title function_">print</span>(<span class="hljs-string">" [^] OCR 처리 완료 !!!"</span>)

        response = {
            <span class="hljs-string">"user_id"</span>: user_id,
            <span class="hljs-string">"user_name"</span>: user_name,
            <span class="hljs-string">"user_email"</span>: user_email,
            <span class="hljs-string">"ocr_text"</span>: ocr_text
        }

        <span class="hljs-keyword">return</span> response

def <span class="hljs-title function_">send_email_notification</span>(email, ocr_text, channel):
    # <span class="hljs-title class_">RabbitMQ</span>를 사용하여 이메일 알림 전송
    message = {
        <span class="hljs-string">'email'</span>: email,
        <span class="hljs-string">'subject'</span>:<span class="hljs-string">'OCR 처리 완료 !!'</span>,
        <span class="hljs-string">'body'</span>:f<span class="hljs-string">'이미지에 대한 OCR (광학 문자 인식) 프로세스가 성공적으로 완료되었음을 알려드립니다.\n 추출된 텍스트가 처리되어 사용할 준비가되었습니다.\n\n  OCR 텍스트 : {ocr_text}'</span>,
        <span class="hljs-string">'other'</span>: <span class="hljs-string">'null'</span>,
       }

    <span class="hljs-attr">try</span>:
        channel.<span class="hljs-title function_">basic_publish</span>(
            exchange=<span class="hljs-string">""</span>,
            routing_key=<span class="hljs-string">'email_notification'</span>,
            body=json.<span class="hljs-title function_">dumps</span>(message),
            properties=pika.<span class="hljs-title class_">BasicProperties</span>(
                delivery_mode=pika.<span class="hljs-property">spec</span>.<span class="hljs-property">PERSISTENT_DELIVERY_MODE</span>
            ),
        )
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"OCR 처리 완료 이메일 알림 전송됨"</span>)
    except <span class="hljs-title class_">Exception</span> <span class="hljs-keyword">as</span> <span class="hljs-attr">err</span>:
        <span class="hljs-title function_">print</span>(f<span class="hljs-string">"메시지 게시 실패: {err}"</span>)

## D. 알림 마이크로서비스 구현

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

이 스크립트는 <span class="hljs-string">"email_notification"</span> 큐에서 메시지를 수신하는 <span class="hljs-title class_">RabbitMQ</span> 소비자를 설정합니다. 메시지를 받으면 email_service 모듈의 notification 함수를 호출하여 알림 프로세스를 처리합니다. 성공하면 메시지를 확인하고, 그렇지 않으면 메시지를 거부하고 오류 메시지를 출력합니다.

<span class="hljs-keyword">import</span> pika
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> email_service
<span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv

# 환경 변수 로드
<span class="hljs-title function_">load_dotenv</span>()
<span class="hljs-variable constant_">RABBITMQ_URL</span> = os.<span class="hljs-property">environ</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"RABBITMQ_URL"</span>)

def <span class="hljs-title function_">main</span>():
    # rabbitmq 연결
    connection = pika.<span class="hljs-title class_">BlockingConnection</span>(pika.<span class="hljs-title class_">ConnectionParameters</span>(host=<span class="hljs-variable constant_">RABBITMQ_URL</span>))
    channel = connection.<span class="hljs-title function_">channel</span>()

    def <span class="hljs-title function_">callback</span>(ch, method, properties, body):
        <span class="hljs-attr">try</span>:
            err = email_service.<span class="hljs-title function_">notification</span>(body)
            <span class="hljs-keyword">if</span> <span class="hljs-attr">err</span>:
                ch.<span class="hljs-title function_">basic_nack</span>(delivery_tag=method.<span class="hljs-property">delivery_tag</span>)
            <span class="hljs-attr">else</span>:
                ch.<span class="hljs-title function_">basic_ack</span>(delivery_tag=method.<span class="hljs-property">delivery_tag</span>)
        except <span class="hljs-title class_">Exception</span> <span class="hljs-keyword">as</span> <span class="hljs-attr">e</span>:
            <span class="hljs-title function_">print</span>(f<span class="hljs-string">"메시지 처리 중 오류 발생: {e}"</span>)
            ch.<span class="hljs-title function_">basic_nack</span>(delivery_tag=method.<span class="hljs-property">delivery_tag</span>)

    channel.<span class="hljs-title function_">basic_consume</span>(
        queue=<span class="hljs-string">"email_notification"</span>, on_message_callback=callback
    )

    <span class="hljs-title function_">print</span>(<span class="hljs-string">"메시지 수신 대기 중. 종료하려면 CTRL+C를 누르세요"</span>)

    channel.<span class="hljs-title function_">start_consuming</span>()


<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-attr">try</span>:
        <span class="hljs-title function_">main</span>()
    except <span class="hljs-title class_">KeyboardInterrupt</span>:
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"중단됨"</span>)
        <span class="hljs-attr">try</span>:
            sys.<span class="hljs-title function_">exit</span>(<span class="hljs-number">0</span>)
        except <span class="hljs-title class_">SystemExit</span>:
            os.<span class="hljs-title function_">_exit</span>(<span class="hljs-number">0</span>)

<span class="hljs-keyword">import</span> smtplib, os, json
<span class="hljs-keyword">from</span> email.<span class="hljs-property">message</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">EmailMessage</span>
<span class="hljs-keyword">from</span> dotenv <span class="hljs-keyword">import</span> load_dotenv
<span class="hljs-keyword">from</span> email.<span class="hljs-property">mime</span>.<span class="hljs-property">text</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">MIMEText</span>

<span class="hljs-title function_">load_dotenv</span>()

def <span class="hljs-title function_">notification</span>(message):
    <span class="hljs-attr">try</span>:
        message = json.<span class="hljs-title function_">loads</span>(message)
        receiver_address = message[<span class="hljs-string">"email"</span>]
        subject = message[<span class="hljs-string">"subject"</span>]
        body = message[<span class="hljs-string">"body"</span>]
        other = message[<span class="hljs-string">"other"</span>]

        sender_address = os.<span class="hljs-property">environ</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"GMAIL_ADDRESS"</span>)
        sender_password = os.<span class="hljs-property">environ</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">"GMAIL_PASSWORD"</span>)

        # <span class="hljs-title class_">Gmail</span> <span class="hljs-variable constant_">SMTP</span> 서버 설정
        smtp_server = <span class="hljs-string">'smtp.gmail.com'</span>
        smtp_port = <span class="hljs-number">587</span>

        server = smtplib.<span class="hljs-title function_">SMTP</span>(smtp_server, smtp_port)
        server.<span class="hljs-title function_">starttls</span>()
        server.<span class="hljs-title function_">login</span>(sender_address, sender_password)

        # 이메일 메시지 작성
        msg = <span class="hljs-title class_">MIMEText</span>(body)
        msg[<span class="hljs-string">'Subject'</span>] = subject
        msg[<span class="hljs-string">'From'</span>] = sender_address
        msg[<span class="hljs-string">'To'</span>] = receiver_address

        server.<span class="hljs-title function_">sendmail</span>(sender_address, receiver_address, msg.<span class="hljs-title function_">as_string</span>())
        server.<span class="hljs-title function_">quit</span>()

        <span class="hljs-title function_">print</span>(<span class="hljs-string">"이메일 발송 완료"</span>)
    except <span class="hljs-title class_">Exception</span> <span class="hljs-keyword">as</span> <span class="hljs-attr">e</span>:
        <span class="hljs-title function_">print</span>(f<span class="hljs-string">"이메일 발송 실패: {e}"</span>)

# 애플리케이션 데모

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

# 결론

마지막으로, <span class="hljs-title class_">FastAPI</span>와 <span class="hljs-title class_">RabbitMQ</span>를 사용하여 엔드 투 엔드 마이크로서비스 아키텍처를 성공적으로 구현했습니다. 사용자 인증 서비스, <span class="hljs-variable constant_">OCR</span> 처리를 위한 머신 러닝 서비스 및 이메일 알림을 위한 알림 서비스를 어떻게 만드는지 보여드렸습니다.

이 블로그를 통해 서비스 격리, 메시징 큐를 통한 통신, 확장성 및 성능을 위한 비동기 처리의 장점과 같은 마이크로서비스의 주요 개념에 대해 배웠습니다.

프로젝트를 실행하려면 <span class="hljs-title class_">GitHub</span> 저장소의 <span class="hljs-variable constant_">README</span> 파일에 있는 지침을 따르세요. 읽어 주셔서 감사합니다. 이 프로젝트가 여러분께 영감을 주어 직접 마이크로서비스 아키텍처를 탐구하고 구현하는 데 도움이 되기를 바랍니다.

&#x3C;div <span class="hljs-keyword">class</span>=<span class="hljs-string">"content-ad"</span>>&#x3C;/div>

깃허브: [<span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/shantanu1905/fastapi-microservice-demo](https://github.com/shantanu1905/fastapi-microservice-demo)</span>
</code></pre>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"파스트 API와 RabbitMQ를 이용한 엔드-투-엔드 마이크로서비스 구축하기 포괄적 안내","description":"","date":"2024-06-20 01:54","slug":"2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide","content":"\n\n\n![image](/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png)\n\n# 소개:\n\n최근 몇 년간, 마이크로서비스 아키텍처는 확장 가능하고 유지보수 가능하며 유연한 애플리케이션을 만드는 능력 때문에 인기를 얻었습니다. 이 블로그 포스트에서는 마이크로서비스 아키텍처의 개념을 탐구하고, 파이썬 생태계의 강력한 도구인 FastAPI와 RabbitMQ를 사용하여 간단한 마이크로서비스를 구축하는 방법을 보여드리겠습니다.\n\n# 몰리딕 아키텍처란? \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단일체 아키텍처는 모든 비즈니스 관심을 결합하는 단일 대규모 컴퓨팅 네트워크로, 하나의 코드 베이스로 생각해 볼 수 있습니다. 애플리케이션의 모든 구성 요소를 하나의 지붕 아래에 모아둔 거대하고 빙하처럼 보이는 구조라고 상상해보세요. 단일체에서 변경을 하려면 전체 스택을 업데이트해야 하며, 이는 시간이 많이 소요되고 엄격할 수 있습니다. 아래 다이어그램에서 단일체 아키텍처의 예시를 볼 수 있습니다.\n\n![단일체 아키텍처 다이어그램](/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_1.png)\n\n# 마이크로서비스 아키텍처란?\n\n반면에, 마이크로서비스 아키텍처는 응용 프로그램이 작은, 독립적으로 배포 가능한 서비스로 분할되는 접근 방식입니다. 각 서비스는 해당하는 비즈니스 로직과 데이터베이스를 갖고 있으며, 가벼운 프로토콜을 통해 다른 서비스와 통신합니다. 이 접근 방식은 빠른 개발 주기, 쉬운 유지보수, 그리고 더 나은 확장성을 가능하게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_2.png\" /\u003e\n\n# Monolithic vs. Microservice의 차이\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_3.png\" /\u003e\n\n# RabbitMQ는 무엇이며, 왜 마이크로서비스를 구축하는 데 사용되는가?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRabbitMQ는 진보된 메시지 큐잉 프로토콜(AMQP)을 구현하는 메시지 브로커입니다. RabbitMQ는 분산 시스템의 다양한 구성 요소 사이에서 중개자 역할을 하여 효율적으로 통신하고 작업을 조정할 수 있도록 합니다. RabbitMQ가 마이크로서비스 아키텍처에서 흔히 사용되는 이유는 다음과 같습니다:\n\n- Decoupling: RabbitMQ는 시스템 구성 요소들을 비동기적으로 통신할 수 있게 함으로써 시스템을 분리하는 데 도움을 줍니다. 이는 서비스가 서로의 응답을 기다리지 않고 독립적으로 작동할 수 있어 더 견고하고 확장 가능한 시스템을 이끌어냅니다.\n- Load Balancing: RabbitMQ는 메시지를 여러 소비자 인스턴스에 분배함으로써 부하를 균형 있게 분배하고 효율적인 자원 활용을 보장합니다.\n- Fault Tolerance: RabbitMQ는 클러스터링과 복제를 지원하여 노드가 실패해도 메시지가 손실되지 않도록 합니다. 이는 시스템을 더욱 고장 내성이 뛰어나고 신뢰할 수 있도록 만듭니다.\n- Scalability: RabbitMQ를 사용하면 소비자 인스턴스나 클러스터에 노드를 추가하여 시스템을 확장할 수 있어 애플리케이션이 성장함에 따라 증가하는 메시지 트래픽을 처리할 수 있습니다.\n- Message Routing: RabbitMQ는 직접, 주제, 팬아웃과 같은 다양한 메시지 라우팅 메커니즘을 지원하여 라우팅 키나 패턴에 따라 특정 큐로 메시지를 전달할 수 있습니다.\n- Message Acknowledgment: RabbitMQ는 메시지 승인을 지원하여 메시지가 한 번만 처리되고 전송 중에 손실되지 않도록 보장합니다.\n- 전반적으로 RabbitMQ는 확장 가능하고 분리되고 고장 내성이 뛰어난 마이크로서비스 아키텍처를 구축하는 데 도움이 되는 견고하고 신뢰할 수 있는 메시징 시스템입니다.\n\n# 마이크로서비스 응용프로그램 코딩\n\n# 1. 프로젝트 소개\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 어플리케이션은 네 가지 주요 서비스로 구성되어 있습니다:\n\n- Gateway Service: 이 서비스는 모든 들어오는 요청의 진입 지점 역할을 합니다. 요청을 적절한 마이크로서비스로 라우팅하고 어플리케이션의 전체적인 조정을 담당합니다.\n- ML Service: ML 서비스는 이미지 데이터를 처리하는 역할을 합니다. Keras OCR을 사용하여 이미지에서 텍스트를 추출하고 Gateway Service와 통신하여 이미지 데이터를 받아 추출된 텍스트를 전송합니다.\n- Auth Service: Auth 서비스는 사용자 인증 및 이메일 인증을 처리합니다. 사용자 등록, OTP 생성 및 검증, 이메일 인증 확인 기능이 포함되어 있습니다.\n- Notification Service: 이 서비스는 사용자에게 이메일을 보내는 역할을 합니다. 프로세스가 완료될 때 트리거됩니다.\n\n## 2. 준비 사항\n\n시작하기 전에 다음 사항을 확인해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 시스템에 Docker가 설치되어 있습니다.\n- 시스템에 Python이 설치되어 있습니다.\n- Docker, Python 및 PostgreSQL에 대한 기본 지식이 있습니다.\n\n# 3. 요구 사항 설정\n\n## Docker를 사용하여 PostgreSQL 설치\n\nPostgreSQL을 Docker를 사용하여 설치하려면 다음 명령을 실행하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n도커를 사용하여 RabbitMQ를 설치하기 위해서는 다음 명령어를 실행하세요:\n\n도커를 실행하여 RabbitMQ를 설치하려면 다음 명령어를 실행하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 프로젝트 설정하기\n\n## A. 프로젝트 폴더 설정하기\n\nmicroservices-demo/\n│\n├── gateway/\n│ ├── rpc_client.py\n│ ├── .env \n│ ├── requirements.txt\n│ └── main.py\n│\n├── ml_services/\n│ ├── requirements.txt\n│ ├── artifacts/\n│ ├── .env\n│ └── main.py\n│\n├── notification_service/\n│ ├── email_service.py\n│ ├── requirements.txt\n│ ├── .env\n│ └── main.py\n│\n├── auth/\n│ ├── database.py\n│ ├── models.py\n│ ├── schemas.py\n│ ├── service.py\n│ ├── requirements.txt\n│ ├── .env\n│ └── main.py\n│\n└── README.md\n\n## B. 게이트웨이 구현하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 게이트웨이 서비스를 구현해 봅시다. gateway/ 디렉토리에 main.py 파일을 만들어 아래 코드를 추가해주세요:\n\nfrom fastapi import FastAPI, HTTPException, File, UploadFile\nimport fastapi as _fastapi\nfrom fastapi.security import OAuth2PasswordBearer\nfrom dotenv import load_dotenv\nfrom jwt.exceptions import DecodeError\nfrom pydantic import BaseModel\nimport requests\nimport base64\nimport pika\nimport logging\nimport os\nimport jwt\nimport rpc_client\n\napp = FastAPI()\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n# 환경 변수 로드\nload_dotenv()\nlogging.basicConfig(level=logging.INFO)\n\n# 환경 변수 가져오기\nJWT_SECRET = os.environ.get(\"JWT_SECRET\")\nAUTH_BASE_URL = os.environ.get(\"AUTH_BASE_URL\")\nRABBITMQ_URL = os.environ.get(\"RABBITMQ_URL\")\n\n# RabbitMQ에 연결\nconnection = pika.BlockingConnection(pika.ConnectionParameters(RABBITMQ_URL))\nchannel = connection.channel()\nchannel.queue_declare(queue='gatewayservice')\nchannel.queue_declare(queue='ocr_service')\n\n# JWT 토큰 유효성 검사\nasync def jwt_validation(token: str = _fastapi.Depends(oauth2_scheme)):\n    try:\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[\"HS256\"])\n        return payload\n    except DecodeError:\n        raise HTTPException(status_code=401, detail=\"Invalid JWT token\")\n\n# 요청 바디를 위한 Pydantic 모델\nclass GenerateUserToken(BaseModel):\n    username: str\n    password: str\n\nclass UserCredentials(BaseModel):\n    username: str\n    password: str\n\nclass UserRegisteration(BaseModel):\n    name: str\n    email: str\n    password: str\n\nclass GenerateOtp(BaseModel):\n    email: str\n\nclass VerifyOtp(BaseModel):\n    email: str\n    otp: int\n\n# 인증 라우트\n@app.post(\"/auth/login\", tags=['Authentication Service'])\nasync def login(user_data: UserCredentials):\n    try:\n        response = requests.post(f\"{AUTH_BASE_URL}/api/token\", json={\"username\": user_data.username, \"password\": user_data.password})\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise HTTPException(status_code=response.status_code, detail=response.json())\n    except requests.exceptions.ConnectionError:\n        raise HTTPException(status_code=503, detail=\"Authentication service is unavailable\")\n\n@app.post(\"/auth/register\", tags=['Authentication Service'])\nasync def registeration(user_data: UserRegisteration):\n    try:\n        response = requests.post(f\"{AUTH_BASE_URL}/api/users\", json={\"name\": user_data.name, \"email\": user_data.email, \"password\": user_data.password})\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise HTTPException(status_code=response.status_code, detail=response.json())\n    except requests.exceptions.ConnectionError:\n        raise HTTPException(status_code=503, detail=\"Authentication service is unavailable\")\n\n@app.post(\"/auth/generate_otp\", tags=['Authentication Service'])\nasync def generate_otp(user_data: GenerateOtp):\n    try:\n        response = requests.post(f\"{AUTH_BASE_URL}/api/users/generate_otp\", json={\"email\": user_data.email})\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise HTTPException(status_code=response.status_code, detail=response.json())\n    except requests.exceptions.ConnectionError:\n        raise HTTPException(status_code=503, detail=\"Authentication service is unavailable\")\n\n@app.post(\"/auth/verify_otp\", tags=['Authentication Service'])\nasync def verify_otp(user_data: VerifyOtp):\n    try:\n        response = requests.post(f\"{AUTH_BASE_URL}/api/users/verify_otp\", json={\"email\": user_data.email, \"otp\": user_data.otp})\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise HTTPException(status_code=response.status_code, detail=response.json())\n    except requests.exceptions.ConnectionError:\n        raise HTTPException(status_code=503, detail=\"Authentication service is unavailable\")\n\n# 확장 서비스 OCR 라우트\n@app.post('/ocr', tags=['Machine learning Service'])\ndef ocr(file: UploadFile = File(...), payload: dict = _fastapi.Depends(jwt_validation)):\n    # 파일을 임시 위치에 저장\n    with open(file.filename, \"wb\") as buffer:\n        buffer.write(file.file.read())\n\n    ocr_rpc = rpc_client.OcrRpcClient()\n\n    with open(file.filename, \"rb\") as buffer:\n        file_data = buffer.read()\n        file_base64 = base64.b64encode(file_data).decode()\n\n    request_json = {\n        'user_name': payload['name'],\n        'user_email': payload['email'],\n        'user_id': payload['id'],\n        'file': file_base64\n    }\n\n    # OCR 마이크로서비스에 요청 JSON을 사용하여 호출\n    response = ocr_rpc.call(request_json)\n\n    # 임시 이미지 파일 삭제\n    os.remove(file.filename)\n    return response\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=5001, reload=True)\n\n게이트웨이 환경을 설정하려면 gateway 폴더에 .env 파일을 만드세요.\n\nAUTH_BASE_URL=http://0.0.0.0:5000\nJWT_SECRET=e56623570e0a0152989fd38e13da9cd6eb7031e4e039e939ba845167ee59b496\nRABBITMQ_URL=localhost\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 마이크로서비스와 통신하기 위해 RabbitMQ를 사용할 것입니다. 이는 서비스 간 비동기 메시징을 가능하게 하는 메시지 브로커입니다. RabbitMQ 서버와의 통신을 처리하기 위해 gateway/ 디렉토리에 rpc_client.py 파일을 생성할 것입니다.\n\nimport pika\nimport uuid\nimport json\nfrom dotenv import load_dotenv\nimport os\n\n# 환경 변수 로딩\nload_dotenv()\nRABBITMQ_URL = os.environ.get(\"RABBITMQ_URL\")\n\nclass OcrRpcClient(object):\n\n    def __init__(self):\n        self.connection = pika.BlockingConnection(\n            pika.ConnectionParameters(host=RABBITMQ_URL))\n\n        self.channel = self.connection.channel()\n\n        result = self.channel.queue_declare(queue='', exclusive=True)\n        self.callback_queue = result.method.queue\n\n        self.channel.basic_consume(\n            queue=self.callback_queue,\n            on_message_callback=self.on_response,\n            auto_ack=True)\n\n    def on_response(self, ch, method, props, body):\n        if self.corr_id == props.correlation_id:\n            self.response = body\n\n    def call(self, message):\n        self.response = None\n        self.corr_id = str(uuid.uuid4())\n        self.channel.basic_publish(\n            exchange='',\n            routing_key='ocr_service',\n            properties=pika.BasicProperties(\n                reply_to=self.callback_queue,\n                correlation_id=self.corr_id,\n            ),\n            body=json.dumps(message))\n        while self.response is None:\n            self.connection.process_data_events()\n        response_json = json.loads(self.response)\n        return response_json\n\n이 코드는 RabbitMQ를 사용하여 OCR 마이크로서비스(ML 마이크로서비스)로 메시지를 보내기 위한 클라이언트 클래스인 OcrRpcClient를 정의합니다. 연결을 초기화하고, 응답을 위한 콜백 큐를 설정하고, 메시지를 보내고 응답을 비동기적으로 받을 수 있는 방법을 제공합니다.\n\n- 초기화(__init__):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRabbitMQ에 연결을 설정합니다. 채널을 생성하고 고유한 콜백 큐를 선언합니다. 콜백 큐에서 응답을 수신하기 위해 소비자를 설정합니다.\n\n2. 요청 보내기 (호출):\n\nOCR 마이크로서비스(ML 마이크로서비스)에 메시지를 보냅니다. 콜백 큐에서 응답을 기다리고 반환합니다.\n\n이 클래스는 RabbitMQ를 사용하여 게이트웨이 서비스가 OCR 마이크로서비스와 효율적으로 통신할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## C. Auth 마이크로서비스 구현\n\n이 코드는 FastAPI를 사용하여 사용자 등록, 로그인, JWT 토큰 생성, OTP를 사용한 이메일 확인 및 사용자 프로필 검색을 제공하는 인증 서비스를 구현합니다. 데이터베이스 작업에는 SQLAlchemy를 사용하고 OTP 이메일을 보내기 위해 RabbitMQ를 사용합니다. 이 서비스에는 사용자 생성, JWT 토큰 생성, 사용자 프로필 검색 및 이메일 확인을 위한 OTP 확인에 대한 엔드포인트가 포함되어 있습니다.\n\nfrom typing import List\nfrom fastapi import HTTPException \nimport fastapi as _fastapi\nimport schemas as _schemas\nimport sqlalchemy.orm as _orm\nimport models as _models\nimport service as _services\nimport logging\nimport database as _database\nimport pika\n\n# rabbitmq connection\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host=\"localhost\"))\nchannel = connection.channel()\nchannel.queue_declare(queue='email_notification')\n\ndef get_db():\n    db = _database.SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = _fastapi.FastAPI()\nlogging.basicConfig(level=logging.INFO)\n_models.Base.metadata.create_all(_models.engine)\n\n@app.post(\"/api/users\", tags=['사용자 인증'])\nasync def create_user(\n    user: _schemas.UserCreate, \n    db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    db_user = await _services.get_user_by_email(email=user.email, db=db)\n\n    if db_user:\n        logging.info('해당 이메일로 이미 가입된 사용자가 있습니다')\n        raise _fastapi.HTTPException(\n            status_code=200,\n            detail=\"해당 이메일로 이미 가입된 사용자가 있습니다\")\n\n    user = await _services.create_user(user=user, db=db)\n\n    return _fastapi.HTTPException(\n            status_code=201,\n            detail=\"사용자 등록이 완료되었습니다. 계정을 활성화하려면 이메일을 확인하세요!\")\n\n# API 상태 확인 엔드포인트\n@app.get(\"/check_api\")\nasync def check_api():\n    return {\"status\": \"API와 연결되었습니다\"}\n\n@app.post(\"/api/token\", tags=['사용자 인증'])\nasync def generate_token(\n    user_data: _schemas.GenerateUserToken,\n    db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    user = await _services.authenticate_user(email=user_data.username, password=user_data.password, db=db)\n\n    if user == \"is_verified_false\":\n        logging.info('이메일 확인이 필요합니다. 계속하려면 이메일을 확인하세요.')\n        raise _fastapi.HTTPException(\n            status_code=403, detail=\"이메일 확인이 필요합니다. 계속하려면 이메일을 확인하세요.\")\n\n    if not user:\n        logging.info('잘못된 자격 증명')\n        raise _fastapi.HTTPException(\n            status_code=401, detail=\"잘못된 자격 증명\")\n\n    logging.info('JWT 토큰이 생성되었습니다.')\n    return await _services.create_token(user=user)\n\n@app.get(\"/api/users/me\", response_model=_schemas.User, tags=['사용자 인증'])\nasync def get_user(user: _schemas.User = _fastapi.Depends(_services.get_current_user)):\n    return user\n\n@app.get(\"/api/users/profile\", tags=['사용자 인증'])\nasync def get_user(email: str, db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    return db.query(_models.User and _models.Address).filter_by(id=1).first()\n\n@app.post(\"/api/users/generate_otp\", response_model=str, tags=[\"사용자 인증\"])\nasync def send_otp_mail(userdata: _schemas.GenerateOtp, db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    user = await _services.get_user_by_email(email=userdata.email, db=db)\n\n    if not user:\n        raise _fastapi.HTTPException(status_code=404, detail=\"사용자를 찾을 수 없습니다\")\n\n    if user.is_verified:\n        raise _fastapi.HTTPException(status_code=400, detail=\"이미 확인된 사용자입니다\")\n\n    # OTP 생성 및 전송\n    otp = _services.generate_otp()\n    print(otp)\n    _services.send_otp(userdata.email, otp, channel)\n\n    # OTP를 데이터베이스에 저장\n    user.otp = otp\n    db.add(user)\n    db.commit()\n\n    return \"이메일로 OTP가 전송되었습니다\"\n\n@app.post(\"/api/users/verify_otp\", tags=[\"사용자 인증\"])\nasync def verify_otp(userdata: _schemas.VerifyOtp, db: _orm.Session = _fastapi.Depends(_services.get_db)):\n    user = await _services.get_user_by_email(email=userdata.email, db=db )\n\n    if not user:\n        raise _fastapi.HTTPException(status_code=404, detail=\"사용자를 찾을 수 없습니다\")\n\n    if not user.otp or user.otp != userdata.otp:\n        raise _fastapi.HTTPException(status_code=400, detail=\"잘못된 OTP\")\n\n    # 사용자의 is_verified 필드 업데이트\n    user.is_verified = True\n    user.otp = None  # OTP 초기화\n    db.add(user)\n    db.commit()\n\n    return \"이메일 확인이 성공적으로 완료되었습니다\"\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=5000, reload=True)\n\n이 코드는 PostgreSQL 데이터베이스에 연결하기 위해 SQLAlchemy 엔진과 세션 메이커를 설정합니다. dotenv를 사용하여 환경 변수에서 데이터베이스 연결 세부 정보를 로드합니다. DATABASE_URL은 호스트, 데이터베이스 이름, 사용자 이름 및 암호를 포함하여 검색된 환경 변수를 사용하여 구성됩니다. 데이터베이스 연결 세부를 사용하여 create_engine를 사용하여 엔진을 생성하고 해당 엔진에 바인딩된 세션 메이커인 SessionLocal을 정의합니다. ORM 모델을 정의하는 Declarative Base로 사용하기 위해 Base 변수가 초기화됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nimport sqlalchemy as _sql\nimport sqlalchemy.ext.declarative as _declarative\nimport sqlalchemy.orm as _orm\nfrom dotenv import load_dotenv\nimport os\n\n# .env 파일에서 환경 변수를 불러옵니다\nload_dotenv()\n\n# 환경 변수를 가져옵니다\npostgres_host = os.environ.get(\"POSTGRES_HOST\")\npostgres_db = os.environ.get(\"POSTGRES_DB\")\npostgres_user = os.environ.get(\"POSTGRES_USER\")\npostgres_password = os.environ.get(\"POSTGRES_PASSWORD\")\n\n# PostgreSQL 서버가 로컬에서 실행 중이라고 가정하고 'mydatabase'라는 이름의 데이터베이스가 있다고 가정합니다\nDATABASE_URL = f\"postgresql://{postgres_user}:{postgres_password}@{postgres_host}/{postgres_db}\"\n\nengine = _sql.create_engine(DATABASE_URL)\nSessionLocal = _orm.sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = _declarative.declarative_base()\r\n\n이 코드는 사용자 및 주소 테이블에 대한 SQLAlchemy 모델을 정의하며, 사용자 정보 및 주소를 저장하고 이들 사이의 관계를 설정합니다. 또한 제공된 엔진을 사용하여 데이터베이스에 테이블을 생성합니다.\n\nimport datetime as _dt\nimport sqlalchemy as _sql\nimport sqlalchemy.orm as _orm\nimport passlib.hash as _hash\nfrom database import Base, engine\nimport database as _database\n\nBase.metadata.create_all(engine)\n\nclass User(_database.Base):\n    __tablename__ = \"users\"\n    id = _sql.Column(_sql.Integer, primary_key=True, index=True)\n    name = _sql.Column(_sql.String)\n    email = _sql.Column(_sql.String, unique=True, index=True)\n    is_verified = _sql.Column(_sql.Boolean, default=False)\n    otp = _sql.Column(_sql.Integer)\n    hashed_password = _sql.Column(_sql.String)\n    addresses = _orm.relationship(\"Address\", back_populates=\"user\")\n    date_created = _sql.Column(_sql.DateTime, default=_dt.datetime.utcnow)\n\n    def verify_password(self, password: str):\n        return _hash.bcrypt.verify(password, self.hashed_password)\n\nclass Address(_database.Base):\n    __tablename__ = \"addresses\"\n    id = _sql.Column(_sql.Integer, primary_key=True, index=True)\n    street = _sql.Column(_sql.String)\n    landmark = _sql.Column(_sql.String)\n    city = _sql.Column(_sql.String)\n    country = _sql.Column(_sql.String)\n    pincode = _sql.Column(_sql.String)\n    user_id = _sql.Column(_sql.Integer, _sql.ForeignKey(\"users.id\"))\n    user = _orm.relationship(\"User\", back_populates=\"addresses\")\n    latitude = _sql.Column(_sql.Float)\n    longitude = _sql.Column(_sql.Float)\r\n\n이 코드는 사용자 관련 데이터 구조에 대한 Pydantic 모델을 정의하며, 사용자 생성, 인증 및 OTP 확인용입니다. 위치 정보를 위한 주소 모델도 포함되어 있습니다. 이 모델들은 사전 속성으로부터 인스턴스를 자동으로 생성하도록 구성되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드는 사용자 인증 및 OTP(일회용 비밀번호) 생성 및 확인을 위한 다양한 함수 및 종속성을 정의합니다. HTTP 요청을 처리하기 위해 FastAPI를 사용하며, 데이터베이스 작업을 위해 SQLAlchemy를 사용하고 데이터 유효성 검사 및 직렬화를 위해 Pydantic을 사용하며, 인증을 위해 JWT를 사용하고, 이메일 알림을 보내기 위해 RabbitMQ를 사용합니다. 이 함수들은 데이터베이스 생성, 데이터베이스 세션 가져오기, 새 사용자 생성, 사용자 인증, JWT 토큰 생성, JWT 토큰에서 현재 사용자 가져오기, 무작위 OTP 생성, RabbitMQ에 연결 및 OTP 이메일 알림 전송 등이 포함됩니다.\n\n환경 변수 로드\n\nJWT_SECRET = os.getenv(\"JWT_SECRET\")\nRABBITMQ_URL = os.getenv(\"RABBITMQ_URL\")\noauth2schema = _security.OAuth2PasswordBearer(\"/api/token\")\n\n데이터베이스 생성\n\ndef create_database():\n    # 데이터베이스 테이블 생성\n    return _database.Base.metadata.create_all(bind=_database.engine)\n\n데이터베이스 세션 가져오기\n\ndef get_db():\n    # 데이터베이스 세션을 얻는 의존성\n    db = _database.SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n이메일별 사용자 가져오기\n\nasync def get_user_by_email(email: str, db: _orm.Session):\n    # 데이터베이스에서 이메일별로 사용자 검색\n    return db.query(_models.User).filter(_models.User.email == email and _models.User.is_verified == True).first()\n\n새 사용자 생성\n\nasync def create_user(user: _schemas.UserCreate, db: _orm.Session):\n    # 데이터베이스에 새 사용자 생성\n    try:\n        valid = _email_check.validate_email(user.email)\n        name = user.name\n        email = valid.email\n    except _email_check.EmailNotValidError:\n        raise _fastapi.HTTPException(status_code=404, detail=\"정확한 이메일을 입력하세요\")\n\n    user_obj = _models.User(email=email, name=name, hashed_password=_hash.bcrypt.hash(user.password))\n    db.add(user_obj)\n    db.commit()\n    db.refresh(user_obj)\n    return user_obj\n\n사용자 인증\n\nasync def authenticate_user(email: str, password: str, db: _orm.Session):\n    # 사용자 인증\n    user = await get_user_by_email(email=email, db=db)\n\n    if not user:\n        return False\n    \n    if not user.is_verified:\n        return 'is_verified_false'\n    \n    if not user.verify_password(password):\n        return False\n\n    return user\n\nJWT 토큰 생성\n\nasync def create_token(user: _models.User):\n    # 인증을 위한 JWT 토큰 생성\n    user_obj = _schemas.User.from_orm(user)\n    user_dict = user_obj.model_dump()\n    del user_dict[\"date_created\"]\n    token = jwt.encode(user_dict, JWT_SECRET, algorithm=\"HS256\")\n    return dict(access_token=token, token_type=\"bearer\")\n\n현재 사용자 가져오기\n\nasync def get_current_user(db: _orm.Session = _fastapi.Depends(get_db), token: str = _fastapi.Depends(oauth2schema)):\n    # JWT 토큰에서 현재 인증된 사용자 가져오기\n    try:\n        payload = jwt.decode(token, JWT_SECRET, algorithms=[\"HS256\"])\n        user = db.query(_models.User).get(payload[\"id\"])\n    except:\n        raise _fastapi.HTTPException(status_code=401, detail=\"유효하지 않은 이메일 또는 비밀번호\")\n    return _schemas.User.from_orm(user)\n\n랜덤 OTP 생성\n\ndef generate_otp():\n    # 랜덤 OTP 생성\n    return str(random.randint(100000, 999999))\n\nRabbitMQ에 연결\n\ndef connect_to_rabbitmq():\n    # RabbitMQ에 연결\n    while True:\n        try:\n            connection = pika.BlockingConnection(pika.ConnectionParameters(RABBITMQ_URL))\n            return connection\n        except pika.exceptions.AMQPConnectionError:\n            print(\"RabbitMQ에 연결하지 못했습니다. 5초 후 다시 시도 중...\")\n            time.sleep(5)\n\nOTP 이메일 알림 전송\n\ndef send_otp(email, otp, channel):\n    # RabbitMQ를 사용하여 OTP 이메일 알림 전송\n    connection = connect_to_rabbitmq()\n    channel = connection.channel()\n    message = {'email': email,\n               'subject': '계정 확인 OTP 알림',\n               'other': 'null',\n               'body': f'계정 확인을 위한 OTP는 다음과 같습니다: {otp} \\n 계정 설정을 완료하려면 확인 페이지에 이 OTP를 입력하세요. \\n 이 OTP를 요청하지 않았다면 이 메시지를 무시해주세요.\\n 감사합니다 '\n               }\n\n    try:\n        queue_declare_ok = channel.queue_declare(queue='email_notification', passive=True)\n        current_durable = queue_declare_ok.method.queue\n\n        if current_durable:\n            if queue_declare_ok.method.queue != current_durable:\n                channel.queue_delete(queue='email_notification')\n                channel.queue_declare(queue='email_notification', durable=True)\n        else:\n            channel.queue_declare(queue='email_notification', durable=True)\n\n        channel.basic_publish(\n            exchange=\"\",\n            routing_key='email_notification',\n            body=json.dumps(message),\n            properties=pika.BasicProperties(\n                delivery_mode=pika.spec.PERSISTENT_DELIVERY_MODE\n            ),\n        )\n        print(\"OTP 이메일 알림 전송 완료\")\n    except Exception as err:\n        print(f\"메시지 전송 실패: {err}\")\n    finally:\n        channel.close()\n        connection.close()\n\n## D. 머신 러닝 마이크로서비스 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 Python 스크립트는 RabbitMQ 서버에 연결하여 'ocr_service'라는 큐에서 메시지를 소비합니다. 메시지를받으면 OCRService 객체를 사용하여 처리하고 send_email_notification 함수를 사용하여 이메일 알림을 보내며, 그런 다음 응답을 응답 큐에 발행합니다. 각 메시지를 처리한 후 RabbitMQ에 메시지 전달을 인식합니다. 스크립트는 RabbitMQ가 전달할 수 있는 미인증 메시지의 수를 제한하는 prefetch count 1을 사용합니다.\n\nimport pika\nimport json\nfrom utils import OCRService\nfrom utils import send_email_notification\n\n# RabbitMQ에 연결\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\nchannel.queue_declare(queue='ocr_service')\n\n# OCR 요청을 처리하기 위한 콜백 함수\ndef on_request(ch, method, props, body):\n    # OCR 서비스 초기화\n    ocr_service = OCRService()\n    # OCR 요청 처리\n    response = ocr_service.process_request(body)\n\n    # 이메일 알림 전송\n    send_email_notification(response['user_email'], response['ocr_text'], channel)\n\n    # 응답을 응답 큐에 발행\n    ch.basic_publish(exchange='',\n                     routing_key=props.reply_to,\n                     properties=pika.BasicProperties(correlation_id = \\\n                                                         props.correlation_id),\n                     body=json.dumps(response))\n    # 메시지 전달을 인식\n    ch.basic_ack(delivery_tag=method.delivery_tag)\n# prefetch count를 1로 설정\nchannel.basic_qos(prefetch_count=1)\n# 'ocr_service' 큐에서 메시지 수신\nchannel.basic_consume(queue='ocr_service', on_message_callback=on_request)\n# 메시지 수신 시작\nprint(\" [x] RPC 요청 대기중\")\nchannel.start_consuming()\r\n\nimport json\nimport base64\nimport pandas as pd\n#keras ocr pipeline and imports\nimport keras_ocr\nimport pika\n\nclass OCRService:\n   \n    def __init__(self):\n        self.keras_pipeline = keras_ocr.pipeline.Pipeline()\n\n    def keras_ocr(self, image_path):\n        results = self.keras_pipeline.recognize([image_path])\n        df = pd.DataFrame(results[0], columns=['text', 'bbox'])\n        words = df['text'].tolist()\n        sentence = ' '.join(words)\n        return sentence\n\n    def process_request(self, message):\n        message_body = json.loads(message)\n        user_name = message_body['user_name']\n        user_email = message_body['user_email']\n        user_id = message_body['user_id']\n        file_base64 = message_body['file']\n        print(f\" [x]user_id: {user_id} request recieved from gateway..\")\n        print(f\" [x]processing request for {user_name}\")\n\n        # file_base64에 base64로 인코딩된 문자열이 포함되어 있다고 가정\n        file_data = base64.b64decode(file_base64.encode())\n        # 디코드된 파일 데이터를 새 파일에 작성\n        with open('artifacts/decoded_file.png', 'wb') as f:\n            f.write(file_data)\n\n        image_path = \"artifacts/decoded_file.png\"\n        ocr_text = self.keras_ocr(image_path)\n        print(\" [^] OCR 처리 완료 !!!\")\n\n        response = {\n            \"user_id\": user_id,\n            \"user_name\": user_name,\n            \"user_email\": user_email,\n            \"ocr_text\": ocr_text\n        }\n\n        return response\n\ndef send_email_notification(email, ocr_text, channel):\n    # RabbitMQ를 사용하여 이메일 알림 전송\n    message = {\n        'email': email,\n        'subject':'OCR 처리 완료 !!',\n        'body':f'이미지에 대한 OCR (광학 문자 인식) 프로세스가 성공적으로 완료되었음을 알려드립니다.\\n 추출된 텍스트가 처리되어 사용할 준비가되었습니다.\\n\\n  OCR 텍스트 : {ocr_text}',\n        'other': 'null',\n       }\n\n    try:\n        channel.basic_publish(\n            exchange=\"\",\n            routing_key='email_notification',\n            body=json.dumps(message),\n            properties=pika.BasicProperties(\n                delivery_mode=pika.spec.PERSISTENT_DELIVERY_MODE\n            ),\n        )\n        print(\"OCR 처리 완료 이메일 알림 전송됨\")\n    except Exception as err:\n        print(f\"메시지 게시 실패: {err}\")\r\n\n## D. 알림 마이크로서비스 구현\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 스크립트는 \"email_notification\" 큐에서 메시지를 수신하는 RabbitMQ 소비자를 설정합니다. 메시지를 받으면 email_service 모듈의 notification 함수를 호출하여 알림 프로세스를 처리합니다. 성공하면 메시지를 확인하고, 그렇지 않으면 메시지를 거부하고 오류 메시지를 출력합니다.\n\nimport pika\nimport sys\nimport os\nimport time\nimport email_service\nfrom dotenv import load_dotenv\n\n# 환경 변수 로드\nload_dotenv()\nRABBITMQ_URL = os.environ.get(\"RABBITMQ_URL\")\n\ndef main():\n    # rabbitmq 연결\n    connection = pika.BlockingConnection(pika.ConnectionParameters(host=RABBITMQ_URL))\n    channel = connection.channel()\n\n    def callback(ch, method, properties, body):\n        try:\n            err = email_service.notification(body)\n            if err:\n                ch.basic_nack(delivery_tag=method.delivery_tag)\n            else:\n                ch.basic_ack(delivery_tag=method.delivery_tag)\n        except Exception as e:\n            print(f\"메시지 처리 중 오류 발생: {e}\")\n            ch.basic_nack(delivery_tag=method.delivery_tag)\n\n    channel.basic_consume(\n        queue=\"email_notification\", on_message_callback=callback\n    )\n\n    print(\"메시지 수신 대기 중. 종료하려면 CTRL+C를 누르세요\")\n\n    channel.start_consuming()\n\n\nif __name__ == \"__main__\":\n    try:\n        main()\n    except KeyboardInterrupt:\n        print(\"중단됨\")\n        try:\n            sys.exit(0)\n        except SystemExit:\n            os._exit(0)\n\nimport smtplib, os, json\nfrom email.message import EmailMessage\nfrom dotenv import load_dotenv\nfrom email.mime.text import MIMEText\n\nload_dotenv()\n\ndef notification(message):\n    try:\n        message = json.loads(message)\n        receiver_address = message[\"email\"]\n        subject = message[\"subject\"]\n        body = message[\"body\"]\n        other = message[\"other\"]\n\n        sender_address = os.environ.get(\"GMAIL_ADDRESS\")\n        sender_password = os.environ.get(\"GMAIL_PASSWORD\")\n\n        # Gmail SMTP 서버 설정\n        smtp_server = 'smtp.gmail.com'\n        smtp_port = 587\n\n        server = smtplib.SMTP(smtp_server, smtp_port)\n        server.starttls()\n        server.login(sender_address, sender_password)\n\n        # 이메일 메시지 작성\n        msg = MIMEText(body)\n        msg['Subject'] = subject\n        msg['From'] = sender_address\n        msg['To'] = receiver_address\n\n        server.sendmail(sender_address, receiver_address, msg.as_string())\n        server.quit()\n\n        print(\"이메일 발송 완료\")\n    except Exception as e:\n        print(f\"이메일 발송 실패: {e}\")\n\n# 애플리케이션 데모\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n마지막으로, FastAPI와 RabbitMQ를 사용하여 엔드 투 엔드 마이크로서비스 아키텍처를 성공적으로 구현했습니다. 사용자 인증 서비스, OCR 처리를 위한 머신 러닝 서비스 및 이메일 알림을 위한 알림 서비스를 어떻게 만드는지 보여드렸습니다.\n\n이 블로그를 통해 서비스 격리, 메시징 큐를 통한 통신, 확장성 및 성능을 위한 비동기 처리의 장점과 같은 마이크로서비스의 주요 개념에 대해 배웠습니다.\n\n프로젝트를 실행하려면 GitHub 저장소의 README 파일에 있는 지침을 따르세요. 읽어 주셔서 감사합니다. 이 프로젝트가 여러분께 영감을 주어 직접 마이크로서비스 아키텍처를 탐구하고 구현하는 데 도움이 되기를 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n깃허브: [https://github.com/shantanu1905/fastapi-microservice-demo](https://github.com/shantanu1905/fastapi-microservice-demo)","ogImage":{"url":"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":29},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003e소개:\u003c/h1\u003e\n\u003cp\u003e최근 몇 년간, 마이크로서비스 아키텍처는 확장 가능하고 유지보수 가능하며 유연한 애플리케이션을 만드는 능력 때문에 인기를 얻었습니다. 이 블로그 포스트에서는 마이크로서비스 아키텍처의 개념을 탐구하고, 파이썬 생태계의 강력한 도구인 FastAPI와 RabbitMQ를 사용하여 간단한 마이크로서비스를 구축하는 방법을 보여드리겠습니다.\u003c/p\u003e\n\u003ch1\u003e몰리딕 아키텍처란?\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e단일체 아키텍처는 모든 비즈니스 관심을 결합하는 단일 대규모 컴퓨팅 네트워크로, 하나의 코드 베이스로 생각해 볼 수 있습니다. 애플리케이션의 모든 구성 요소를 하나의 지붕 아래에 모아둔 거대하고 빙하처럼 보이는 구조라고 상상해보세요. 단일체에서 변경을 하려면 전체 스택을 업데이트해야 하며, 이는 시간이 많이 소요되고 엄격할 수 있습니다. 아래 다이어그램에서 단일체 아키텍처의 예시를 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_1.png\" alt=\"단일체 아키텍처 다이어그램\"\u003e\u003c/p\u003e\n\u003ch1\u003e마이크로서비스 아키텍처란?\u003c/h1\u003e\n\u003cp\u003e반면에, 마이크로서비스 아키텍처는 응용 프로그램이 작은, 독립적으로 배포 가능한 서비스로 분할되는 접근 방식입니다. 각 서비스는 해당하는 비즈니스 로직과 데이터베이스를 갖고 있으며, 가벼운 프로토콜을 통해 다른 서비스와 통신합니다. 이 접근 방식은 빠른 개발 주기, 쉬운 유지보수, 그리고 더 나은 확장성을 가능하게 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_2.png\"\u003e\n\u003ch1\u003eMonolithic vs. Microservice의 차이\u003c/h1\u003e\n\u003cimg src=\"/assets/img/2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide_3.png\"\u003e\n\u003ch1\u003eRabbitMQ는 무엇이며, 왜 마이크로서비스를 구축하는 데 사용되는가?\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eRabbitMQ는 진보된 메시지 큐잉 프로토콜(AMQP)을 구현하는 메시지 브로커입니다. RabbitMQ는 분산 시스템의 다양한 구성 요소 사이에서 중개자 역할을 하여 효율적으로 통신하고 작업을 조정할 수 있도록 합니다. RabbitMQ가 마이크로서비스 아키텍처에서 흔히 사용되는 이유는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDecoupling: RabbitMQ는 시스템 구성 요소들을 비동기적으로 통신할 수 있게 함으로써 시스템을 분리하는 데 도움을 줍니다. 이는 서비스가 서로의 응답을 기다리지 않고 독립적으로 작동할 수 있어 더 견고하고 확장 가능한 시스템을 이끌어냅니다.\u003c/li\u003e\n\u003cli\u003eLoad Balancing: RabbitMQ는 메시지를 여러 소비자 인스턴스에 분배함으로써 부하를 균형 있게 분배하고 효율적인 자원 활용을 보장합니다.\u003c/li\u003e\n\u003cli\u003eFault Tolerance: RabbitMQ는 클러스터링과 복제를 지원하여 노드가 실패해도 메시지가 손실되지 않도록 합니다. 이는 시스템을 더욱 고장 내성이 뛰어나고 신뢰할 수 있도록 만듭니다.\u003c/li\u003e\n\u003cli\u003eScalability: RabbitMQ를 사용하면 소비자 인스턴스나 클러스터에 노드를 추가하여 시스템을 확장할 수 있어 애플리케이션이 성장함에 따라 증가하는 메시지 트래픽을 처리할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eMessage Routing: RabbitMQ는 직접, 주제, 팬아웃과 같은 다양한 메시지 라우팅 메커니즘을 지원하여 라우팅 키나 패턴에 따라 특정 큐로 메시지를 전달할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eMessage Acknowledgment: RabbitMQ는 메시지 승인을 지원하여 메시지가 한 번만 처리되고 전송 중에 손실되지 않도록 보장합니다.\u003c/li\u003e\n\u003cli\u003e전반적으로 RabbitMQ는 확장 가능하고 분리되고 고장 내성이 뛰어난 마이크로서비스 아키텍처를 구축하는 데 도움이 되는 견고하고 신뢰할 수 있는 메시징 시스템입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e마이크로서비스 응용프로그램 코딩\u003c/h1\u003e\n\u003ch1\u003e1. 프로젝트 소개\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저희 어플리케이션은 네 가지 주요 서비스로 구성되어 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGateway Service: 이 서비스는 모든 들어오는 요청의 진입 지점 역할을 합니다. 요청을 적절한 마이크로서비스로 라우팅하고 어플리케이션의 전체적인 조정을 담당합니다.\u003c/li\u003e\n\u003cli\u003eML Service: ML 서비스는 이미지 데이터를 처리하는 역할을 합니다. Keras OCR을 사용하여 이미지에서 텍스트를 추출하고 Gateway Service와 통신하여 이미지 데이터를 받아 추출된 텍스트를 전송합니다.\u003c/li\u003e\n\u003cli\u003eAuth Service: Auth 서비스는 사용자 인증 및 이메일 인증을 처리합니다. 사용자 등록, OTP 생성 및 검증, 이메일 인증 확인 기능이 포함되어 있습니다.\u003c/li\u003e\n\u003cli\u003eNotification Service: 이 서비스는 사용자에게 이메일을 보내는 역할을 합니다. 프로세스가 완료될 때 트리거됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e2. 준비 사항\u003c/h2\u003e\n\u003cp\u003e시작하기 전에 다음 사항을 확인해주세요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e시스템에 Docker가 설치되어 있습니다.\u003c/li\u003e\n\u003cli\u003e시스템에 Python이 설치되어 있습니다.\u003c/li\u003e\n\u003cli\u003eDocker, Python 및 PostgreSQL에 대한 기본 지식이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e3. 요구 사항 설정\u003c/h1\u003e\n\u003ch2\u003eDocker를 사용하여 PostgreSQL 설치\u003c/h2\u003e\n\u003cp\u003ePostgreSQL을 Docker를 사용하여 설치하려면 다음 명령을 실행하십시오:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e도커를 사용하여 \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e를 설치하기 위해서는 다음 명령어를 실행하세요:\n\n도커를 실행하여 \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e를 설치하려면 다음 명령어를 실행하세요:\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n# \u003cspan class=\"hljs-number\"\u003e4.\u003c/span\u003e 프로젝트 설정하기\n\n## A. 프로젝트 폴더 설정하기\n\nmicroservices-demo/\n│\n├── gateway/\n│ ├── rpc_client.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n│ ├── .\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e \n│ ├── requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n│ └── main.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n│\n├── ml_services/\n│ ├── requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n│ ├── artifacts/\n│ ├── .\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e\n│ └── main.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n│\n├── notification_service/\n│ ├── email_service.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n│ ├── requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n│ ├── .\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e\n│ └── main.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n│\n├── auth/\n│ ├── database.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n│ ├── models.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n│ ├── schemas.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n│ ├── service.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n│ ├── requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n│ ├── .\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e\n│ └── main.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n│\n└── \u003cspan class=\"hljs-variable constant_\"\u003eREADME\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emd\u003c/span\u003e\n\n## B. 게이트웨이 구현하기\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n이제 게이트웨이 서비스를 구현해 봅시다. gateway/ 디렉토리에 main.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e 파일을 만들어 아래 코드를 추가해주세요:\n\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e fastapi \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFastAPI\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eFile\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eUploadFile\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e fastapi \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _fastapi\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e fastapi.\u003cspan class=\"hljs-property\"\u003esecurity\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOAuth2PasswordBearer\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e dotenv \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e load_dotenv\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e jwt.\u003cspan class=\"hljs-property\"\u003eexceptions\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDecodeError\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e pydantic \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e requests\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e base64\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pika\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e logging\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e jwt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e rpc_client\n\napp = \u003cspan class=\"hljs-title class_\"\u003eFastAPI\u003c/span\u003e()\noauth2_scheme = \u003cspan class=\"hljs-title class_\"\u003eOAuth2PasswordBearer\u003c/span\u003e(tokenUrl=\u003cspan class=\"hljs-string\"\u003e\"token\"\u003c/span\u003e)\n\n# 환경 변수 로드\n\u003cspan class=\"hljs-title function_\"\u003eload_dotenv\u003c/span\u003e()\nlogging.\u003cspan class=\"hljs-title function_\"\u003ebasicConfig\u003c/span\u003e(level=logging.\u003cspan class=\"hljs-property\"\u003eINFO\u003c/span\u003e)\n\n# 환경 변수 가져오기\n\u003cspan class=\"hljs-variable constant_\"\u003eJWT_SECRET\u003c/span\u003e = os.\u003cspan class=\"hljs-property\"\u003eenviron\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"JWT_SECRET\"\u003c/span\u003e)\n\u003cspan class=\"hljs-variable constant_\"\u003eAUTH_BASE_URL\u003c/span\u003e = os.\u003cspan class=\"hljs-property\"\u003eenviron\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"AUTH_BASE_URL\"\u003c/span\u003e)\n\u003cspan class=\"hljs-variable constant_\"\u003eRABBITMQ_URL\u003c/span\u003e = os.\u003cspan class=\"hljs-property\"\u003eenviron\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"RABBITMQ_URL\"\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e에 연결\nconnection = pika.\u003cspan class=\"hljs-title class_\"\u003eBlockingConnection\u003c/span\u003e(pika.\u003cspan class=\"hljs-title class_\"\u003eConnectionParameters\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eRABBITMQ_URL\u003c/span\u003e))\nchannel = connection.\u003cspan class=\"hljs-title function_\"\u003echannel\u003c/span\u003e()\nchannel.\u003cspan class=\"hljs-title function_\"\u003equeue_declare\u003c/span\u003e(queue=\u003cspan class=\"hljs-string\"\u003e'gatewayservice'\u003c/span\u003e)\nchannel.\u003cspan class=\"hljs-title function_\"\u003equeue_declare\u003c/span\u003e(queue=\u003cspan class=\"hljs-string\"\u003e'ocr_service'\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-variable constant_\"\u003eJWT\u003c/span\u003e 토큰 유효성 검사\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003ejwt_validation\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etoken\u003c/span\u003e: str = _fastapi.\u003cspan class=\"hljs-title class_\"\u003eDepends\u003c/span\u003e(oauth2_scheme)):\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        payload = jwt.\u003cspan class=\"hljs-title function_\"\u003edecode\u003c/span\u003e(token, \u003cspan class=\"hljs-variable constant_\"\u003eJWT_SECRET\u003c/span\u003e, algorithms=[\u003cspan class=\"hljs-string\"\u003e\"HS256\"\u003c/span\u003e])\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e payload\n    except \u003cspan class=\"hljs-title class_\"\u003eDecodeError\u003c/span\u003e:\n        raise \u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=\u003cspan class=\"hljs-number\"\u003e401\u003c/span\u003e, detail=\u003cspan class=\"hljs-string\"\u003e\"Invalid JWT token\"\u003c/span\u003e)\n\n# 요청 바디를 위한 \u003cspan class=\"hljs-title class_\"\u003ePydantic\u003c/span\u003e 모델\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGenerateUserToken\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003eusername\u003c/span\u003e: str\n    \u003cspan class=\"hljs-attr\"\u003epassword\u003c/span\u003e: str\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserCredentials\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003eusername\u003c/span\u003e: str\n    \u003cspan class=\"hljs-attr\"\u003epassword\u003c/span\u003e: str\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserRegisteration\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: str\n    \u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: str\n    \u003cspan class=\"hljs-attr\"\u003epassword\u003c/span\u003e: str\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGenerateOtp\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: str\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eVerifyOtp\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: str\n    \u003cspan class=\"hljs-attr\"\u003eotp\u003c/span\u003e: int\n\n# 인증 라우트\n@app.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/auth/login\"\u003c/span\u003e, tags=[\u003cspan class=\"hljs-string\"\u003e'Authentication Service'\u003c/span\u003e])\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003elogin\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003euser_data\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUserCredentials\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        response = requests.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{AUTH_BASE_URL}/api/token\"\u003c/span\u003e, json={\u003cspan class=\"hljs-string\"\u003e\"username\"\u003c/span\u003e: user_data.\u003cspan class=\"hljs-property\"\u003eusername\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"password\"\u003c/span\u003e: user_data.\u003cspan class=\"hljs-property\"\u003epassword\u003c/span\u003e})\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e response.\u003cspan class=\"hljs-property\"\u003estatus_code\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e()\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            raise \u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=response.\u003cspan class=\"hljs-property\"\u003estatus_code\u003c/span\u003e, detail=response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n    except requests.\u003cspan class=\"hljs-property\"\u003eexceptions\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eConnectionError\u003c/span\u003e:\n        raise \u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=\u003cspan class=\"hljs-number\"\u003e503\u003c/span\u003e, detail=\u003cspan class=\"hljs-string\"\u003e\"Authentication service is unavailable\"\u003c/span\u003e)\n\n@app.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/auth/register\"\u003c/span\u003e, tags=[\u003cspan class=\"hljs-string\"\u003e'Authentication Service'\u003c/span\u003e])\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003eregisteration\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003euser_data\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUserRegisteration\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        response = requests.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{AUTH_BASE_URL}/api/users\"\u003c/span\u003e, json={\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: user_data.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"email\"\u003c/span\u003e: user_data.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"password\"\u003c/span\u003e: user_data.\u003cspan class=\"hljs-property\"\u003epassword\u003c/span\u003e})\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e response.\u003cspan class=\"hljs-property\"\u003estatus_code\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e()\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            raise \u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=response.\u003cspan class=\"hljs-property\"\u003estatus_code\u003c/span\u003e, detail=response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n    except requests.\u003cspan class=\"hljs-property\"\u003eexceptions\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eConnectionError\u003c/span\u003e:\n        raise \u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=\u003cspan class=\"hljs-number\"\u003e503\u003c/span\u003e, detail=\u003cspan class=\"hljs-string\"\u003e\"Authentication service is unavailable\"\u003c/span\u003e)\n\n@app.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/auth/generate_otp\"\u003c/span\u003e, tags=[\u003cspan class=\"hljs-string\"\u003e'Authentication Service'\u003c/span\u003e])\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003egenerate_otp\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003euser_data\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eGenerateOtp\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        response = requests.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{AUTH_BASE_URL}/api/users/generate_otp\"\u003c/span\u003e, json={\u003cspan class=\"hljs-string\"\u003e\"email\"\u003c/span\u003e: user_data.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e})\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e response.\u003cspan class=\"hljs-property\"\u003estatus_code\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e()\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            raise \u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=response.\u003cspan class=\"hljs-property\"\u003estatus_code\u003c/span\u003e, detail=response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n    except requests.\u003cspan class=\"hljs-property\"\u003eexceptions\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eConnectionError\u003c/span\u003e:\n        raise \u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=\u003cspan class=\"hljs-number\"\u003e503\u003c/span\u003e, detail=\u003cspan class=\"hljs-string\"\u003e\"Authentication service is unavailable\"\u003c/span\u003e)\n\n@app.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/auth/verify_otp\"\u003c/span\u003e, tags=[\u003cspan class=\"hljs-string\"\u003e'Authentication Service'\u003c/span\u003e])\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003everify_otp\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003euser_data\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eVerifyOtp\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        response = requests.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{AUTH_BASE_URL}/api/users/verify_otp\"\u003c/span\u003e, json={\u003cspan class=\"hljs-string\"\u003e\"email\"\u003c/span\u003e: user_data.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"otp\"\u003c/span\u003e: user_data.\u003cspan class=\"hljs-property\"\u003eotp\u003c/span\u003e})\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e response.\u003cspan class=\"hljs-property\"\u003estatus_code\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e()\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            raise \u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=response.\u003cspan class=\"hljs-property\"\u003estatus_code\u003c/span\u003e, detail=response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n    except requests.\u003cspan class=\"hljs-property\"\u003eexceptions\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eConnectionError\u003c/span\u003e:\n        raise \u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=\u003cspan class=\"hljs-number\"\u003e503\u003c/span\u003e, detail=\u003cspan class=\"hljs-string\"\u003e\"Authentication service is unavailable\"\u003c/span\u003e)\n\n# 확장 서비스 \u003cspan class=\"hljs-variable constant_\"\u003eOCR\u003c/span\u003e 라우트\n@app.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/ocr'\u003c/span\u003e, tags=[\u003cspan class=\"hljs-string\"\u003e'Machine learning Service'\u003c/span\u003e])\ndef \u003cspan class=\"hljs-title function_\"\u003eocr\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efile\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUploadFile\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eFile\u003c/span\u003e(...), \u003cspan class=\"hljs-attr\"\u003epayload\u003c/span\u003e: dict = _fastapi.\u003cspan class=\"hljs-title class_\"\u003eDepends\u003c/span\u003e(jwt_validation)):\n    # 파일을 임시 위치에 저장\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(file.\u003cspan class=\"hljs-property\"\u003efilename\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"wb\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebuffer\u003c/span\u003e:\n        buffer.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(file.\u003cspan class=\"hljs-property\"\u003efile\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eread\u003c/span\u003e())\n\n    ocr_rpc = rpc_client.\u003cspan class=\"hljs-title class_\"\u003eOcrRpcClient\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(file.\u003cspan class=\"hljs-property\"\u003efilename\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"rb\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebuffer\u003c/span\u003e:\n        file_data = buffer.\u003cspan class=\"hljs-title function_\"\u003eread\u003c/span\u003e()\n        file_base64 = base64.\u003cspan class=\"hljs-title function_\"\u003eb64encode\u003c/span\u003e(file_data).\u003cspan class=\"hljs-title function_\"\u003edecode\u003c/span\u003e()\n\n    request_json = {\n        \u003cspan class=\"hljs-string\"\u003e'user_name'\u003c/span\u003e: payload[\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e],\n        \u003cspan class=\"hljs-string\"\u003e'user_email'\u003c/span\u003e: payload[\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e],\n        \u003cspan class=\"hljs-string\"\u003e'user_id'\u003c/span\u003e: payload[\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e],\n        \u003cspan class=\"hljs-string\"\u003e'file'\u003c/span\u003e: file_base64\n    }\n\n    # \u003cspan class=\"hljs-variable constant_\"\u003eOCR\u003c/span\u003e 마이크로서비스에 요청 \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e을 사용하여 호출\n    response = ocr_rpc.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(request_json)\n\n    # 임시 이미지 파일 삭제\n    os.\u003cspan class=\"hljs-title function_\"\u003eremove\u003c/span\u003e(file.\u003cspan class=\"hljs-property\"\u003efilename\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main__\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e uvicorn\n    uvicorn.\u003cspan class=\"hljs-title function_\"\u003erun\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"main:app\"\u003c/span\u003e, host=\u003cspan class=\"hljs-string\"\u003e\"0.0.0.0\"\u003c/span\u003e, port=\u003cspan class=\"hljs-number\"\u003e5001\u003c/span\u003e, reload=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\n게이트웨이 환경을 설정하려면 gateway 폴더에 .\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e 파일을 만드세요.\n\n\u003cspan class=\"hljs-variable constant_\"\u003eAUTH_BASE_URL\u003c/span\u003e=\u003cspan class=\"hljs-attr\"\u003ehttp\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//0.0.0.0:5000\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eJWT_SECRET\u003c/span\u003e=e56623570e0a0152989fd38e13da9cd6eb7031e4e039e939ba845167ee59b496\n\u003cspan class=\"hljs-variable constant_\"\u003eRABBITMQ_URL\u003c/span\u003e=localhost\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n다른 마이크로서비스와 통신하기 위해 \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e를 사용할 것입니다. 이는 서비스 간 비동기 메시징을 가능하게 하는 메시지 브로커입니다. \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e 서버와의 통신을 처리하기 위해 gateway/ 디렉토리에 rpc_client.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e 파일을 생성할 것입니다.\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pika\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e uuid\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e json\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e dotenv \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e load_dotenv\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\n# 환경 변수 로딩\n\u003cspan class=\"hljs-title function_\"\u003eload_dotenv\u003c/span\u003e()\n\u003cspan class=\"hljs-variable constant_\"\u003eRABBITMQ_URL\u003c/span\u003e = os.\u003cspan class=\"hljs-property\"\u003eenviron\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"RABBITMQ_URL\"\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOcrRpcClient\u003c/span\u003e(object):\n\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self):\n        self.\u003cspan class=\"hljs-property\"\u003econnection\u003c/span\u003e = pika.\u003cspan class=\"hljs-title class_\"\u003eBlockingConnection\u003c/span\u003e(\n            pika.\u003cspan class=\"hljs-title class_\"\u003eConnectionParameters\u003c/span\u003e(host=\u003cspan class=\"hljs-variable constant_\"\u003eRABBITMQ_URL\u003c/span\u003e))\n\n        self.\u003cspan class=\"hljs-property\"\u003echannel\u003c/span\u003e = self.\u003cspan class=\"hljs-property\"\u003econnection\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003echannel\u003c/span\u003e()\n\n        result = self.\u003cspan class=\"hljs-property\"\u003echannel\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003equeue_declare\u003c/span\u003e(queue=\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e, exclusive=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n        self.\u003cspan class=\"hljs-property\"\u003ecallback_queue\u003c/span\u003e = result.\u003cspan class=\"hljs-property\"\u003emethod\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003equeue\u003c/span\u003e\n\n        self.\u003cspan class=\"hljs-property\"\u003echannel\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebasic_consume\u003c/span\u003e(\n            queue=self.\u003cspan class=\"hljs-property\"\u003ecallback_queue\u003c/span\u003e,\n            on_message_callback=self.\u003cspan class=\"hljs-property\"\u003eon_response\u003c/span\u003e,\n            auto_ack=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\n    def \u003cspan class=\"hljs-title function_\"\u003eon_response\u003c/span\u003e(self, ch, method, props, body):\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003ecorr_id\u003c/span\u003e == props.\u003cspan class=\"hljs-property\"\u003ecorrelation_id\u003c/span\u003e:\n            self.\u003cspan class=\"hljs-property\"\u003eresponse\u003c/span\u003e = body\n\n    def \u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(self, message):\n        self.\u003cspan class=\"hljs-property\"\u003eresponse\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n        self.\u003cspan class=\"hljs-property\"\u003ecorr_id\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(uuid.\u003cspan class=\"hljs-title function_\"\u003euuid4\u003c/span\u003e())\n        self.\u003cspan class=\"hljs-property\"\u003echannel\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebasic_publish\u003c/span\u003e(\n            exchange=\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n            routing_key=\u003cspan class=\"hljs-string\"\u003e'ocr_service'\u003c/span\u003e,\n            properties=pika.\u003cspan class=\"hljs-title class_\"\u003eBasicProperties\u003c/span\u003e(\n                reply_to=self.\u003cspan class=\"hljs-property\"\u003ecallback_queue\u003c/span\u003e,\n                correlation_id=self.\u003cspan class=\"hljs-property\"\u003ecorr_id\u003c/span\u003e,\n            ),\n            body=json.\u003cspan class=\"hljs-title function_\"\u003edumps\u003c/span\u003e(message))\n        \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003eresponse\u003c/span\u003e is \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n            self.\u003cspan class=\"hljs-property\"\u003econnection\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprocess_data_events\u003c/span\u003e()\n        response_json = json.\u003cspan class=\"hljs-title function_\"\u003eloads\u003c/span\u003e(self.\u003cspan class=\"hljs-property\"\u003eresponse\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response_json\n\n이 코드는 \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e를 사용하여 \u003cspan class=\"hljs-variable constant_\"\u003eOCR\u003c/span\u003e 마이크로서비스(\u003cspan class=\"hljs-variable constant_\"\u003eML\u003c/span\u003e 마이크로서비스)로 메시지를 보내기 위한 클라이언트 클래스인 \u003cspan class=\"hljs-title class_\"\u003eOcrRpcClient\u003c/span\u003e를 정의합니다. 연결을 초기화하고, 응답을 위한 콜백 큐를 설정하고, 메시지를 보내고 응답을 비동기적으로 받을 수 있는 방법을 제공합니다.\n\n- 초기화(__init__):\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e에 연결을 설정합니다. 채널을 생성하고 고유한 콜백 큐를 선언합니다. 콜백 큐에서 응답을 수신하기 위해 소비자를 설정합니다.\n\n\u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e 요청 보내기 (호출):\n\n\u003cspan class=\"hljs-variable constant_\"\u003eOCR\u003c/span\u003e 마이크로서비스(\u003cspan class=\"hljs-variable constant_\"\u003eML\u003c/span\u003e 마이크로서비스)에 메시지를 보냅니다. 콜백 큐에서 응답을 기다리고 반환합니다.\n\n이 클래스는 \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e를 사용하여 게이트웨이 서비스가 \u003cspan class=\"hljs-variable constant_\"\u003eOCR\u003c/span\u003e 마이크로서비스와 효율적으로 통신할 수 있게 합니다.\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n## C. \u003cspan class=\"hljs-title class_\"\u003eAuth\u003c/span\u003e 마이크로서비스 구현\n\n이 코드는 \u003cspan class=\"hljs-title class_\"\u003eFastAPI\u003c/span\u003e를 사용하여 사용자 등록, 로그인, \u003cspan class=\"hljs-variable constant_\"\u003eJWT\u003c/span\u003e 토큰 생성, \u003cspan class=\"hljs-variable constant_\"\u003eOTP\u003c/span\u003e를 사용한 이메일 확인 및 사용자 프로필 검색을 제공하는 인증 서비스를 구현합니다. 데이터베이스 작업에는 \u003cspan class=\"hljs-title class_\"\u003eSQLAlchemy\u003c/span\u003e를 사용하고 \u003cspan class=\"hljs-variable constant_\"\u003eOTP\u003c/span\u003e 이메일을 보내기 위해 \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e를 사용합니다. 이 서비스에는 사용자 생성, \u003cspan class=\"hljs-variable constant_\"\u003eJWT\u003c/span\u003e 토큰 생성, 사용자 프로필 검색 및 이메일 확인을 위한 \u003cspan class=\"hljs-variable constant_\"\u003eOTP\u003c/span\u003e 확인에 대한 엔드포인트가 포함되어 있습니다.\n\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e typing \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e fastapi \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e \n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e fastapi \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _fastapi\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e schemas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _schemas\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e sqlalchemy.\u003cspan class=\"hljs-property\"\u003eorm\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _orm\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e models \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _models\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e service \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _services\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e logging\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e database \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _database\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pika\n\n# rabbitmq connection\nconnection = pika.\u003cspan class=\"hljs-title class_\"\u003eBlockingConnection\u003c/span\u003e(pika.\u003cspan class=\"hljs-title class_\"\u003eConnectionParameters\u003c/span\u003e(host=\u003cspan class=\"hljs-string\"\u003e\"localhost\"\u003c/span\u003e))\nchannel = connection.\u003cspan class=\"hljs-title function_\"\u003echannel\u003c/span\u003e()\nchannel.\u003cspan class=\"hljs-title function_\"\u003equeue_declare\u003c/span\u003e(queue=\u003cspan class=\"hljs-string\"\u003e'email_notification'\u003c/span\u003e)\n\ndef \u003cspan class=\"hljs-title function_\"\u003eget_db\u003c/span\u003e():\n    db = _database.\u003cspan class=\"hljs-title class_\"\u003eSessionLocal\u003c/span\u003e()\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e db\n    \u003cspan class=\"hljs-attr\"\u003efinally\u003c/span\u003e:\n        db.\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e()\n\napp = _fastapi.\u003cspan class=\"hljs-title class_\"\u003eFastAPI\u003c/span\u003e()\nlogging.\u003cspan class=\"hljs-title function_\"\u003ebasicConfig\u003c/span\u003e(level=logging.\u003cspan class=\"hljs-property\"\u003eINFO\u003c/span\u003e)\n_models.\u003cspan class=\"hljs-property\"\u003eBase\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emetadata\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate_all\u003c/span\u003e(_models.\u003cspan class=\"hljs-property\"\u003eengine\u003c/span\u003e)\n\n@app.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/api/users\"\u003c/span\u003e, tags=[\u003cspan class=\"hljs-string\"\u003e'사용자 인증'\u003c/span\u003e])\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003ecreate_user\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003euser\u003c/span\u003e: _schemas.\u003cspan class=\"hljs-property\"\u003eUserCreate\u003c/span\u003e, \n    \u003cspan class=\"hljs-attr\"\u003edb\u003c/span\u003e: _orm.\u003cspan class=\"hljs-property\"\u003eSession\u003c/span\u003e = _fastapi.\u003cspan class=\"hljs-title class_\"\u003eDepends\u003c/span\u003e(_services.\u003cspan class=\"hljs-property\"\u003eget_db\u003c/span\u003e)):\n    db_user = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e _services.\u003cspan class=\"hljs-title function_\"\u003eget_user_by_email\u003c/span\u003e(email=user.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e, db=db)\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edb_user\u003c/span\u003e:\n        logging.\u003cspan class=\"hljs-title function_\"\u003einfo\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'해당 이메일로 이미 가입된 사용자가 있습니다'\u003c/span\u003e)\n        raise _fastapi.\u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(\n            status_code=\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e,\n            detail=\u003cspan class=\"hljs-string\"\u003e\"해당 이메일로 이미 가입된 사용자가 있습니다\"\u003c/span\u003e)\n\n    user = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e _services.\u003cspan class=\"hljs-title function_\"\u003ecreate_user\u003c/span\u003e(user=user, db=db)\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _fastapi.\u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(\n            status_code=\u003cspan class=\"hljs-number\"\u003e201\u003c/span\u003e,\n            detail=\u003cspan class=\"hljs-string\"\u003e\"사용자 등록이 완료되었습니다. 계정을 활성화하려면 이메일을 확인하세요!\"\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e 상태 확인 엔드포인트\n@app.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/check_api\"\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003echeck_api\u003c/span\u003e():\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\u003cspan class=\"hljs-string\"\u003e\"status\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"API와 연결되었습니다\"\u003c/span\u003e}\n\n@app.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/api/token\"\u003c/span\u003e, tags=[\u003cspan class=\"hljs-string\"\u003e'사용자 인증'\u003c/span\u003e])\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003egenerate_token\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003euser_data\u003c/span\u003e: _schemas.\u003cspan class=\"hljs-property\"\u003eGenerateUserToken\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003edb\u003c/span\u003e: _orm.\u003cspan class=\"hljs-property\"\u003eSession\u003c/span\u003e = _fastapi.\u003cspan class=\"hljs-title class_\"\u003eDepends\u003c/span\u003e(_services.\u003cspan class=\"hljs-property\"\u003eget_db\u003c/span\u003e)):\n    user = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e _services.\u003cspan class=\"hljs-title function_\"\u003eauthenticate_user\u003c/span\u003e(email=user_data.\u003cspan class=\"hljs-property\"\u003eusername\u003c/span\u003e, password=user_data.\u003cspan class=\"hljs-property\"\u003epassword\u003c/span\u003e, db=db)\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e user == \u003cspan class=\"hljs-string\"\u003e\"is_verified_false\"\u003c/span\u003e:\n        logging.\u003cspan class=\"hljs-title function_\"\u003einfo\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'이메일 확인이 필요합니다. 계속하려면 이메일을 확인하세요.'\u003c/span\u003e)\n        raise _fastapi.\u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(\n            status_code=\u003cspan class=\"hljs-number\"\u003e403\u003c/span\u003e, detail=\u003cspan class=\"hljs-string\"\u003e\"이메일 확인이 필요합니다. 계속하려면 이메일을 확인하세요.\"\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not \u003cspan class=\"hljs-attr\"\u003euser\u003c/span\u003e:\n        logging.\u003cspan class=\"hljs-title function_\"\u003einfo\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'잘못된 자격 증명'\u003c/span\u003e)\n        raise _fastapi.\u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(\n            status_code=\u003cspan class=\"hljs-number\"\u003e401\u003c/span\u003e, detail=\u003cspan class=\"hljs-string\"\u003e\"잘못된 자격 증명\"\u003c/span\u003e)\n\n    logging.\u003cspan class=\"hljs-title function_\"\u003einfo\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'JWT 토큰이 생성되었습니다.'\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e _services.\u003cspan class=\"hljs-title function_\"\u003ecreate_token\u003c/span\u003e(user=user)\n\n@app.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/api/users/me\"\u003c/span\u003e, response_model=_schemas.\u003cspan class=\"hljs-property\"\u003eUser\u003c/span\u003e, tags=[\u003cspan class=\"hljs-string\"\u003e'사용자 인증'\u003c/span\u003e])\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003eget_user\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003euser\u003c/span\u003e: _schemas.\u003cspan class=\"hljs-property\"\u003eUser\u003c/span\u003e = _fastapi.\u003cspan class=\"hljs-title class_\"\u003eDepends\u003c/span\u003e(_services.\u003cspan class=\"hljs-property\"\u003eget_current_user\u003c/span\u003e)):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e user\n\n@app.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/api/users/profile\"\u003c/span\u003e, tags=[\u003cspan class=\"hljs-string\"\u003e'사용자 인증'\u003c/span\u003e])\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003eget_user\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: str, \u003cspan class=\"hljs-attr\"\u003edb\u003c/span\u003e: _orm.\u003cspan class=\"hljs-property\"\u003eSession\u003c/span\u003e = _fastapi.\u003cspan class=\"hljs-title class_\"\u003eDepends\u003c/span\u003e(_services.\u003cspan class=\"hljs-property\"\u003eget_db\u003c/span\u003e)):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e db.\u003cspan class=\"hljs-title function_\"\u003equery\u003c/span\u003e(_models.\u003cspan class=\"hljs-property\"\u003eUser\u003c/span\u003e and _models.\u003cspan class=\"hljs-property\"\u003eAddress\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003efilter_by\u003c/span\u003e(id=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003efirst\u003c/span\u003e()\n\n@app.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/api/users/generate_otp\"\u003c/span\u003e, response_model=str, tags=[\u003cspan class=\"hljs-string\"\u003e\"사용자 인증\"\u003c/span\u003e])\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003esend_otp_mail\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003euserdata\u003c/span\u003e: _schemas.\u003cspan class=\"hljs-property\"\u003eGenerateOtp\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edb\u003c/span\u003e: _orm.\u003cspan class=\"hljs-property\"\u003eSession\u003c/span\u003e = _fastapi.\u003cspan class=\"hljs-title class_\"\u003eDepends\u003c/span\u003e(_services.\u003cspan class=\"hljs-property\"\u003eget_db\u003c/span\u003e)):\n    user = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e _services.\u003cspan class=\"hljs-title function_\"\u003eget_user_by_email\u003c/span\u003e(email=userdata.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e, db=db)\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not \u003cspan class=\"hljs-attr\"\u003euser\u003c/span\u003e:\n        raise _fastapi.\u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=\u003cspan class=\"hljs-number\"\u003e404\u003c/span\u003e, detail=\u003cspan class=\"hljs-string\"\u003e\"사용자를 찾을 수 없습니다\"\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e user.\u003cspan class=\"hljs-property\"\u003eis_verified\u003c/span\u003e:\n        raise _fastapi.\u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=\u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e, detail=\u003cspan class=\"hljs-string\"\u003e\"이미 확인된 사용자입니다\"\u003c/span\u003e)\n\n    # \u003cspan class=\"hljs-variable constant_\"\u003eOTP\u003c/span\u003e 생성 및 전송\n    otp = _services.\u003cspan class=\"hljs-title function_\"\u003egenerate_otp\u003c/span\u003e()\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(otp)\n    _services.\u003cspan class=\"hljs-title function_\"\u003esend_otp\u003c/span\u003e(userdata.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e, otp, channel)\n\n    # \u003cspan class=\"hljs-variable constant_\"\u003eOTP\u003c/span\u003e를 데이터베이스에 저장\n    user.\u003cspan class=\"hljs-property\"\u003eotp\u003c/span\u003e = otp\n    db.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(user)\n    db.\u003cspan class=\"hljs-title function_\"\u003ecommit\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"이메일로 OTP가 전송되었습니다\"\u003c/span\u003e\n\n@app.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/api/users/verify_otp\"\u003c/span\u003e, tags=[\u003cspan class=\"hljs-string\"\u003e\"사용자 인증\"\u003c/span\u003e])\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003everify_otp\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003euserdata\u003c/span\u003e: _schemas.\u003cspan class=\"hljs-property\"\u003eVerifyOtp\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edb\u003c/span\u003e: _orm.\u003cspan class=\"hljs-property\"\u003eSession\u003c/span\u003e = _fastapi.\u003cspan class=\"hljs-title class_\"\u003eDepends\u003c/span\u003e(_services.\u003cspan class=\"hljs-property\"\u003eget_db\u003c/span\u003e)):\n    user = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e _services.\u003cspan class=\"hljs-title function_\"\u003eget_user_by_email\u003c/span\u003e(email=userdata.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e, db=db )\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not \u003cspan class=\"hljs-attr\"\u003euser\u003c/span\u003e:\n        raise _fastapi.\u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=\u003cspan class=\"hljs-number\"\u003e404\u003c/span\u003e, detail=\u003cspan class=\"hljs-string\"\u003e\"사용자를 찾을 수 없습니다\"\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not user.\u003cspan class=\"hljs-property\"\u003eotp\u003c/span\u003e or user.\u003cspan class=\"hljs-property\"\u003eotp\u003c/span\u003e != userdata.\u003cspan class=\"hljs-property\"\u003eotp\u003c/span\u003e:\n        raise _fastapi.\u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=\u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e, detail=\u003cspan class=\"hljs-string\"\u003e\"잘못된 OTP\"\u003c/span\u003e)\n\n    # 사용자의 is_verified 필드 업데이트\n    user.\u003cspan class=\"hljs-property\"\u003eis_verified\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n    user.\u003cspan class=\"hljs-property\"\u003eotp\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e  # \u003cspan class=\"hljs-variable constant_\"\u003eOTP\u003c/span\u003e 초기화\n    db.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(user)\n    db.\u003cspan class=\"hljs-title function_\"\u003ecommit\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"이메일 확인이 성공적으로 완료되었습니다\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main__\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e uvicorn\n    uvicorn.\u003cspan class=\"hljs-title function_\"\u003erun\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"main:app\"\u003c/span\u003e, host=\u003cspan class=\"hljs-string\"\u003e\"0.0.0.0\"\u003c/span\u003e, port=\u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e, reload=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\n이 코드는 \u003cspan class=\"hljs-title class_\"\u003ePostgreSQL\u003c/span\u003e 데이터베이스에 연결하기 위해 \u003cspan class=\"hljs-title class_\"\u003eSQLAlchemy\u003c/span\u003e 엔진과 세션 메이커를 설정합니다. dotenv를 사용하여 환경 변수에서 데이터베이스 연결 세부 정보를 로드합니다. \u003cspan class=\"hljs-variable constant_\"\u003eDATABASE_URL\u003c/span\u003e은 호스트, 데이터베이스 이름, 사용자 이름 및 암호를 포함하여 검색된 환경 변수를 사용하여 구성됩니다. 데이터베이스 연결 세부를 사용하여 create_engine를 사용하여 엔진을 생성하고 해당 엔진에 바인딩된 세션 메이커인 \u003cspan class=\"hljs-title class_\"\u003eSessionLocal\u003c/span\u003e을 정의합니다. \u003cspan class=\"hljs-variable constant_\"\u003eORM\u003c/span\u003e 모델을 정의하는 \u003cspan class=\"hljs-title class_\"\u003eDeclarative\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e로 사용하기 위해 \u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e 변수가 초기화됩니다.\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e sqlalchemy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _sql\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e sqlalchemy.\u003cspan class=\"hljs-property\"\u003eext\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edeclarative\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _declarative\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e sqlalchemy.\u003cspan class=\"hljs-property\"\u003eorm\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _orm\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e dotenv \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e load_dotenv\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\n# .\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e 파일에서 환경 변수를 불러옵니다\n\u003cspan class=\"hljs-title function_\"\u003eload_dotenv\u003c/span\u003e()\n\n# 환경 변수를 가져옵니다\npostgres_host = os.\u003cspan class=\"hljs-property\"\u003eenviron\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"POSTGRES_HOST\"\u003c/span\u003e)\npostgres_db = os.\u003cspan class=\"hljs-property\"\u003eenviron\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"POSTGRES_DB\"\u003c/span\u003e)\npostgres_user = os.\u003cspan class=\"hljs-property\"\u003eenviron\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"POSTGRES_USER\"\u003c/span\u003e)\npostgres_password = os.\u003cspan class=\"hljs-property\"\u003eenviron\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"POSTGRES_PASSWORD\"\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-title class_\"\u003ePostgreSQL\u003c/span\u003e 서버가 로컬에서 실행 중이라고 가정하고 \u003cspan class=\"hljs-string\"\u003e'mydatabase'\u003c/span\u003e라는 이름의 데이터베이스가 있다고 가정합니다\n\u003cspan class=\"hljs-variable constant_\"\u003eDATABASE_URL\u003c/span\u003e = f\u003cspan class=\"hljs-string\"\u003e\"postgresql://{postgres_user}:{postgres_password}@{postgres_host}/{postgres_db}\"\u003c/span\u003e\n\nengine = _sql.\u003cspan class=\"hljs-title function_\"\u003ecreate_engine\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eDATABASE_URL\u003c/span\u003e)\n\u003cspan class=\"hljs-title class_\"\u003eSessionLocal\u003c/span\u003e = _orm.\u003cspan class=\"hljs-title function_\"\u003esessionmaker\u003c/span\u003e(autocommit=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e, autoflush=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e, bind=engine)\n\u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e = _declarative.\u003cspan class=\"hljs-title function_\"\u003edeclarative_base\u003c/span\u003e()\r\n\n이 코드는 사용자 및 주소 테이블에 대한 \u003cspan class=\"hljs-title class_\"\u003eSQLAlchemy\u003c/span\u003e 모델을 정의하며, 사용자 정보 및 주소를 저장하고 이들 사이의 관계를 설정합니다. 또한 제공된 엔진을 사용하여 데이터베이스에 테이블을 생성합니다.\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e datetime \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _dt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e sqlalchemy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _sql\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e sqlalchemy.\u003cspan class=\"hljs-property\"\u003eorm\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _orm\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e passlib.\u003cspan class=\"hljs-property\"\u003ehash\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _hash\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e database \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e, engine\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e database \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _database\n\n\u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emetadata\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate_all\u003c/span\u003e(engine)\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(_database.\u003cspan class=\"hljs-property\"\u003eBase\u003c/span\u003e):\n    __tablename__ = \u003cspan class=\"hljs-string\"\u003e\"users\"\u003c/span\u003e\n    id = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eInteger\u003c/span\u003e, primary_key=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, index=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n    name = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eString\u003c/span\u003e)\n    email = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eString\u003c/span\u003e, unique=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, index=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n    is_verified = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eBoolean\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n    otp = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eInteger\u003c/span\u003e)\n    hashed_password = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eString\u003c/span\u003e)\n    addresses = _orm.\u003cspan class=\"hljs-title function_\"\u003erelationship\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Address\"\u003c/span\u003e, back_populates=\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e)\n    date_created = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eDateTime\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e=_dt.\u003cspan class=\"hljs-property\"\u003edatetime\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eutcnow\u003c/span\u003e)\n\n    def \u003cspan class=\"hljs-title function_\"\u003everify_password\u003c/span\u003e(self, \u003cspan class=\"hljs-attr\"\u003epassword\u003c/span\u003e: str):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _hash.\u003cspan class=\"hljs-property\"\u003ebcrypt\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003everify\u003c/span\u003e(password, self.\u003cspan class=\"hljs-property\"\u003ehashed_password\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAddress\u003c/span\u003e(_database.\u003cspan class=\"hljs-property\"\u003eBase\u003c/span\u003e):\n    __tablename__ = \u003cspan class=\"hljs-string\"\u003e\"addresses\"\u003c/span\u003e\n    id = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eInteger\u003c/span\u003e, primary_key=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, index=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n    street = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eString\u003c/span\u003e)\n    landmark = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eString\u003c/span\u003e)\n    city = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eString\u003c/span\u003e)\n    country = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eString\u003c/span\u003e)\n    pincode = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eString\u003c/span\u003e)\n    user_id = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eInteger\u003c/span\u003e, _sql.\u003cspan class=\"hljs-title class_\"\u003eForeignKey\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"users.id\"\u003c/span\u003e))\n    user = _orm.\u003cspan class=\"hljs-title function_\"\u003erelationship\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"User\"\u003c/span\u003e, back_populates=\u003cspan class=\"hljs-string\"\u003e\"addresses\"\u003c/span\u003e)\n    latitude = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eFloat\u003c/span\u003e)\n    longitude = _sql.\u003cspan class=\"hljs-title class_\"\u003eColumn\u003c/span\u003e(_sql.\u003cspan class=\"hljs-property\"\u003eFloat\u003c/span\u003e)\r\n\n이 코드는 사용자 관련 데이터 구조에 대한 \u003cspan class=\"hljs-title class_\"\u003ePydantic\u003c/span\u003e 모델을 정의하며, 사용자 생성, 인증 및 \u003cspan class=\"hljs-variable constant_\"\u003eOTP\u003c/span\u003e 확인용입니다. 위치 정보를 위한 주소 모델도 포함되어 있습니다. 이 모델들은 사전 속성으로부터 인스턴스를 자동으로 생성하도록 구성되어 있습니다.\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n이 코드는 사용자 인증 및 \u003cspan class=\"hljs-title function_\"\u003eOTP\u003c/span\u003e(일회용 비밀번호) 생성 및 확인을 위한 다양한 함수 및 종속성을 정의합니다. \u003cspan class=\"hljs-variable constant_\"\u003eHTTP\u003c/span\u003e 요청을 처리하기 위해 \u003cspan class=\"hljs-title class_\"\u003eFastAPI\u003c/span\u003e를 사용하며, 데이터베이스 작업을 위해 \u003cspan class=\"hljs-title class_\"\u003eSQLAlchemy\u003c/span\u003e를 사용하고 데이터 유효성 검사 및 직렬화를 위해 \u003cspan class=\"hljs-title class_\"\u003ePydantic\u003c/span\u003e을 사용하며, 인증을 위해 \u003cspan class=\"hljs-variable constant_\"\u003eJWT\u003c/span\u003e를 사용하고, 이메일 알림을 보내기 위해 \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e를 사용합니다. 이 함수들은 데이터베이스 생성, 데이터베이스 세션 가져오기, 새 사용자 생성, 사용자 인증, \u003cspan class=\"hljs-variable constant_\"\u003eJWT\u003c/span\u003e 토큰 생성, \u003cspan class=\"hljs-variable constant_\"\u003eJWT\u003c/span\u003e 토큰에서 현재 사용자 가져오기, 무작위 \u003cspan class=\"hljs-variable constant_\"\u003eOTP\u003c/span\u003e 생성, \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e에 연결 및 \u003cspan class=\"hljs-variable constant_\"\u003eOTP\u003c/span\u003e 이메일 알림 전송 등이 포함됩니다.\n\n환경 변수 로드\n\n\u003cspan class=\"hljs-variable constant_\"\u003eJWT_SECRET\u003c/span\u003e = os.\u003cspan class=\"hljs-title function_\"\u003egetenv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"JWT_SECRET\"\u003c/span\u003e)\n\u003cspan class=\"hljs-variable constant_\"\u003eRABBITMQ_URL\u003c/span\u003e = os.\u003cspan class=\"hljs-title function_\"\u003egetenv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"RABBITMQ_URL\"\u003c/span\u003e)\noauth2schema = _security.\u003cspan class=\"hljs-title class_\"\u003eOAuth2PasswordBearer\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"/api/token\"\u003c/span\u003e)\n\n데이터베이스 생성\n\ndef \u003cspan class=\"hljs-title function_\"\u003ecreate_database\u003c/span\u003e():\n    # 데이터베이스 테이블 생성\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _database.\u003cspan class=\"hljs-property\"\u003eBase\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emetadata\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate_all\u003c/span\u003e(bind=_database.\u003cspan class=\"hljs-property\"\u003eengine\u003c/span\u003e)\n\n데이터베이스 세션 가져오기\n\ndef \u003cspan class=\"hljs-title function_\"\u003eget_db\u003c/span\u003e():\n    # 데이터베이스 세션을 얻는 의존성\n    db = _database.\u003cspan class=\"hljs-title class_\"\u003eSessionLocal\u003c/span\u003e()\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e db\n    \u003cspan class=\"hljs-attr\"\u003efinally\u003c/span\u003e:\n        db.\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e()\n\n이메일별 사용자 가져오기\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003eget_user_by_email\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: str, \u003cspan class=\"hljs-attr\"\u003edb\u003c/span\u003e: _orm.\u003cspan class=\"hljs-property\"\u003eSession\u003c/span\u003e):\n    # 데이터베이스에서 이메일별로 사용자 검색\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e db.\u003cspan class=\"hljs-title function_\"\u003equery\u003c/span\u003e(_models.\u003cspan class=\"hljs-property\"\u003eUser\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(_models.\u003cspan class=\"hljs-property\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e == email and _models.\u003cspan class=\"hljs-property\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eis_verified\u003c/span\u003e == \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003efirst\u003c/span\u003e()\n\n새 사용자 생성\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003ecreate_user\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003euser\u003c/span\u003e: _schemas.\u003cspan class=\"hljs-property\"\u003eUserCreate\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edb\u003c/span\u003e: _orm.\u003cspan class=\"hljs-property\"\u003eSession\u003c/span\u003e):\n    # 데이터베이스에 새 사용자 생성\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        valid = _email_check.\u003cspan class=\"hljs-title function_\"\u003evalidate_email\u003c/span\u003e(user.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e)\n        name = user.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\n        email = valid.\u003cspan class=\"hljs-property\"\u003eemail\u003c/span\u003e\n    except _email_check.\u003cspan class=\"hljs-property\"\u003eEmailNotValidError\u003c/span\u003e:\n        raise _fastapi.\u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=\u003cspan class=\"hljs-number\"\u003e404\u003c/span\u003e, detail=\u003cspan class=\"hljs-string\"\u003e\"정확한 이메일을 입력하세요\"\u003c/span\u003e)\n\n    user_obj = _models.\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(email=email, name=name, hashed_password=_hash.\u003cspan class=\"hljs-property\"\u003ebcrypt\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehash\u003c/span\u003e(user.\u003cspan class=\"hljs-property\"\u003epassword\u003c/span\u003e))\n    db.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(user_obj)\n    db.\u003cspan class=\"hljs-title function_\"\u003ecommit\u003c/span\u003e()\n    db.\u003cspan class=\"hljs-title function_\"\u003erefresh\u003c/span\u003e(user_obj)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e user_obj\n\n사용자 인증\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003eauthenticate_user\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: str, \u003cspan class=\"hljs-attr\"\u003epassword\u003c/span\u003e: str, \u003cspan class=\"hljs-attr\"\u003edb\u003c/span\u003e: _orm.\u003cspan class=\"hljs-property\"\u003eSession\u003c/span\u003e):\n    # 사용자 인증\n    user = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_user_by_email\u003c/span\u003e(email=email, db=db)\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not \u003cspan class=\"hljs-attr\"\u003euser\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n    \n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not user.\u003cspan class=\"hljs-property\"\u003eis_verified\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'is_verified_false'\u003c/span\u003e\n    \n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not user.\u003cspan class=\"hljs-title function_\"\u003everify_password\u003c/span\u003e(password):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e user\n\n\u003cspan class=\"hljs-variable constant_\"\u003eJWT\u003c/span\u003e 토큰 생성\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003ecreate_token\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003euser\u003c/span\u003e: _models.\u003cspan class=\"hljs-property\"\u003eUser\u003c/span\u003e):\n    # 인증을 위한 \u003cspan class=\"hljs-variable constant_\"\u003eJWT\u003c/span\u003e 토큰 생성\n    user_obj = _schemas.\u003cspan class=\"hljs-property\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_orm\u003c/span\u003e(user)\n    user_dict = user_obj.\u003cspan class=\"hljs-title function_\"\u003emodel_dump\u003c/span\u003e()\n    del user_dict[\u003cspan class=\"hljs-string\"\u003e\"date_created\"\u003c/span\u003e]\n    token = jwt.\u003cspan class=\"hljs-title function_\"\u003eencode\u003c/span\u003e(user_dict, \u003cspan class=\"hljs-variable constant_\"\u003eJWT_SECRET\u003c/span\u003e, algorithm=\u003cspan class=\"hljs-string\"\u003e\"HS256\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edict\u003c/span\u003e(access_token=token, token_type=\u003cspan class=\"hljs-string\"\u003e\"bearer\"\u003c/span\u003e)\n\n현재 사용자 가져오기\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003eget_current_user\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edb\u003c/span\u003e: _orm.\u003cspan class=\"hljs-property\"\u003eSession\u003c/span\u003e = _fastapi.\u003cspan class=\"hljs-title class_\"\u003eDepends\u003c/span\u003e(get_db), \u003cspan class=\"hljs-attr\"\u003etoken\u003c/span\u003e: str = _fastapi.\u003cspan class=\"hljs-title class_\"\u003eDepends\u003c/span\u003e(oauth2schema)):\n    # \u003cspan class=\"hljs-variable constant_\"\u003eJWT\u003c/span\u003e 토큰에서 현재 인증된 사용자 가져오기\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        payload = jwt.\u003cspan class=\"hljs-title function_\"\u003edecode\u003c/span\u003e(token, \u003cspan class=\"hljs-variable constant_\"\u003eJWT_SECRET\u003c/span\u003e, algorithms=[\u003cspan class=\"hljs-string\"\u003e\"HS256\"\u003c/span\u003e])\n        user = db.\u003cspan class=\"hljs-title function_\"\u003equery\u003c/span\u003e(_models.\u003cspan class=\"hljs-property\"\u003eUser\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(payload[\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e])\n    \u003cspan class=\"hljs-attr\"\u003eexcept\u003c/span\u003e:\n        raise _fastapi.\u003cspan class=\"hljs-title class_\"\u003eHTTPException\u003c/span\u003e(status_code=\u003cspan class=\"hljs-number\"\u003e401\u003c/span\u003e, detail=\u003cspan class=\"hljs-string\"\u003e\"유효하지 않은 이메일 또는 비밀번호\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _schemas.\u003cspan class=\"hljs-property\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_orm\u003c/span\u003e(user)\n\n랜덤 \u003cspan class=\"hljs-variable constant_\"\u003eOTP\u003c/span\u003e 생성\n\ndef \u003cspan class=\"hljs-title function_\"\u003egenerate_otp\u003c/span\u003e():\n    # 랜덤 \u003cspan class=\"hljs-variable constant_\"\u003eOTP\u003c/span\u003e 생성\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(random.\u003cspan class=\"hljs-title function_\"\u003erandint\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100000\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e999999\u003c/span\u003e))\n\n\u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e에 연결\n\ndef \u003cspan class=\"hljs-title function_\"\u003econnect_to_rabbitmq\u003c/span\u003e():\n    # \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e에 연결\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e:\n        \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n            connection = pika.\u003cspan class=\"hljs-title class_\"\u003eBlockingConnection\u003c/span\u003e(pika.\u003cspan class=\"hljs-title class_\"\u003eConnectionParameters\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eRABBITMQ_URL\u003c/span\u003e))\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e connection\n        except pika.\u003cspan class=\"hljs-property\"\u003eexceptions\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eAMQPConnectionError\u003c/span\u003e:\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"RabbitMQ에 연결하지 못했습니다. 5초 후 다시 시도 중...\"\u003c/span\u003e)\n            time.\u003cspan class=\"hljs-title function_\"\u003esleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\n\n\u003cspan class=\"hljs-variable constant_\"\u003eOTP\u003c/span\u003e 이메일 알림 전송\n\ndef \u003cspan class=\"hljs-title function_\"\u003esend_otp\u003c/span\u003e(email, otp, channel):\n    # \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e를 사용하여 \u003cspan class=\"hljs-variable constant_\"\u003eOTP\u003c/span\u003e 이메일 알림 전송\n    connection = \u003cspan class=\"hljs-title function_\"\u003econnect_to_rabbitmq\u003c/span\u003e()\n    channel = connection.\u003cspan class=\"hljs-title function_\"\u003echannel\u003c/span\u003e()\n    message = {\u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e: email,\n               \u003cspan class=\"hljs-string\"\u003e'subject'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'계정 확인 OTP 알림'\u003c/span\u003e,\n               \u003cspan class=\"hljs-string\"\u003e'other'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'null'\u003c/span\u003e,\n               \u003cspan class=\"hljs-string\"\u003e'body'\u003c/span\u003e: f\u003cspan class=\"hljs-string\"\u003e'계정 확인을 위한 OTP는 다음과 같습니다: {otp} \\n 계정 설정을 완료하려면 확인 페이지에 이 OTP를 입력하세요. \\n 이 OTP를 요청하지 않았다면 이 메시지를 무시해주세요.\\n 감사합니다 '\u003c/span\u003e\n               }\n\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        queue_declare_ok = channel.\u003cspan class=\"hljs-title function_\"\u003equeue_declare\u003c/span\u003e(queue=\u003cspan class=\"hljs-string\"\u003e'email_notification'\u003c/span\u003e, passive=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n        current_durable = queue_declare_ok.\u003cspan class=\"hljs-property\"\u003emethod\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003equeue\u003c/span\u003e\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecurrent_durable\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e queue_declare_ok.\u003cspan class=\"hljs-property\"\u003emethod\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003equeue\u003c/span\u003e != \u003cspan class=\"hljs-attr\"\u003ecurrent_durable\u003c/span\u003e:\n                channel.\u003cspan class=\"hljs-title function_\"\u003equeue_delete\u003c/span\u003e(queue=\u003cspan class=\"hljs-string\"\u003e'email_notification'\u003c/span\u003e)\n                channel.\u003cspan class=\"hljs-title function_\"\u003equeue_declare\u003c/span\u003e(queue=\u003cspan class=\"hljs-string\"\u003e'email_notification'\u003c/span\u003e, durable=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            channel.\u003cspan class=\"hljs-title function_\"\u003equeue_declare\u003c/span\u003e(queue=\u003cspan class=\"hljs-string\"\u003e'email_notification'\u003c/span\u003e, durable=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\n        channel.\u003cspan class=\"hljs-title function_\"\u003ebasic_publish\u003c/span\u003e(\n            exchange=\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n            routing_key=\u003cspan class=\"hljs-string\"\u003e'email_notification'\u003c/span\u003e,\n            body=json.\u003cspan class=\"hljs-title function_\"\u003edumps\u003c/span\u003e(message),\n            properties=pika.\u003cspan class=\"hljs-title class_\"\u003eBasicProperties\u003c/span\u003e(\n                delivery_mode=pika.\u003cspan class=\"hljs-property\"\u003espec\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePERSISTENT_DELIVERY_MODE\u003c/span\u003e\n            ),\n        )\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"OTP 이메일 알림 전송 완료\"\u003c/span\u003e)\n    except \u003cspan class=\"hljs-title class_\"\u003eException\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eerr\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"메시지 전송 실패: {err}\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-attr\"\u003efinally\u003c/span\u003e:\n        channel.\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e()\n        connection.\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e()\n\n## D. 머신 러닝 마이크로서비스 구현\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n이 \u003cspan class=\"hljs-title class_\"\u003ePython\u003c/span\u003e 스크립트는 \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e 서버에 연결하여 \u003cspan class=\"hljs-string\"\u003e'ocr_service'\u003c/span\u003e라는 큐에서 메시지를 소비합니다. 메시지를받으면 \u003cspan class=\"hljs-title class_\"\u003eOCRService\u003c/span\u003e 객체를 사용하여 처리하고 send_email_notification 함수를 사용하여 이메일 알림을 보내며, 그런 다음 응답을 응답 큐에 발행합니다. 각 메시지를 처리한 후 \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e에 메시지 전달을 인식합니다. 스크립트는 \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e가 전달할 수 있는 미인증 메시지의 수를 제한하는 prefetch count \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e을 사용합니다.\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pika\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e json\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e utils \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOCRService\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e utils \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e send_email_notification\n\n# \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e에 연결\nconnection = pika.\u003cspan class=\"hljs-title class_\"\u003eBlockingConnection\u003c/span\u003e(pika.\u003cspan class=\"hljs-title class_\"\u003eConnectionParameters\u003c/span\u003e(host=\u003cspan class=\"hljs-string\"\u003e'localhost'\u003c/span\u003e))\nchannel = connection.\u003cspan class=\"hljs-title function_\"\u003echannel\u003c/span\u003e()\nchannel.\u003cspan class=\"hljs-title function_\"\u003equeue_declare\u003c/span\u003e(queue=\u003cspan class=\"hljs-string\"\u003e'ocr_service'\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-variable constant_\"\u003eOCR\u003c/span\u003e 요청을 처리하기 위한 콜백 함수\ndef \u003cspan class=\"hljs-title function_\"\u003eon_request\u003c/span\u003e(ch, method, props, body):\n    # \u003cspan class=\"hljs-variable constant_\"\u003eOCR\u003c/span\u003e 서비스 초기화\n    ocr_service = \u003cspan class=\"hljs-title class_\"\u003eOCRService\u003c/span\u003e()\n    # \u003cspan class=\"hljs-variable constant_\"\u003eOCR\u003c/span\u003e 요청 처리\n    response = ocr_service.\u003cspan class=\"hljs-title function_\"\u003eprocess_request\u003c/span\u003e(body)\n\n    # 이메일 알림 전송\n    \u003cspan class=\"hljs-title function_\"\u003esend_email_notification\u003c/span\u003e(response[\u003cspan class=\"hljs-string\"\u003e'user_email'\u003c/span\u003e], response[\u003cspan class=\"hljs-string\"\u003e'ocr_text'\u003c/span\u003e], channel)\n\n    # 응답을 응답 큐에 발행\n    ch.\u003cspan class=\"hljs-title function_\"\u003ebasic_publish\u003c/span\u003e(exchange=\u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e,\n                     routing_key=props.\u003cspan class=\"hljs-property\"\u003ereply_to\u003c/span\u003e,\n                     properties=pika.\u003cspan class=\"hljs-title class_\"\u003eBasicProperties\u003c/span\u003e(correlation_id = \\\n                                                         props.\u003cspan class=\"hljs-property\"\u003ecorrelation_id\u003c/span\u003e),\n                     body=json.\u003cspan class=\"hljs-title function_\"\u003edumps\u003c/span\u003e(response))\n    # 메시지 전달을 인식\n    ch.\u003cspan class=\"hljs-title function_\"\u003ebasic_ack\u003c/span\u003e(delivery_tag=method.\u003cspan class=\"hljs-property\"\u003edelivery_tag\u003c/span\u003e)\n# prefetch count를 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e로 설정\nchannel.\u003cspan class=\"hljs-title function_\"\u003ebasic_qos\u003c/span\u003e(prefetch_count=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n# \u003cspan class=\"hljs-string\"\u003e'ocr_service'\u003c/span\u003e 큐에서 메시지 수신\nchannel.\u003cspan class=\"hljs-title function_\"\u003ebasic_consume\u003c/span\u003e(queue=\u003cspan class=\"hljs-string\"\u003e'ocr_service'\u003c/span\u003e, on_message_callback=on_request)\n# 메시지 수신 시작\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\" [x] RPC 요청 대기중\"\u003c/span\u003e)\nchannel.\u003cspan class=\"hljs-title function_\"\u003estart_consuming\u003c/span\u003e()\r\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e json\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e base64\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n#keras ocr pipeline and imports\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e keras_ocr\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pika\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOCRService\u003c/span\u003e:\n   \n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self):\n        self.\u003cspan class=\"hljs-property\"\u003ekeras_pipeline\u003c/span\u003e = keras_ocr.\u003cspan class=\"hljs-property\"\u003epipeline\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003ePipeline\u003c/span\u003e()\n\n    def \u003cspan class=\"hljs-title function_\"\u003ekeras_ocr\u003c/span\u003e(self, image_path):\n        results = self.\u003cspan class=\"hljs-property\"\u003ekeras_pipeline\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erecognize\u003c/span\u003e([image_path])\n        df = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(results[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], columns=[\u003cspan class=\"hljs-string\"\u003e'text'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'bbox'\u003c/span\u003e])\n        words = df[\u003cspan class=\"hljs-string\"\u003e'text'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003etolist\u003c/span\u003e()\n        sentence = \u003cspan class=\"hljs-string\"\u003e' '\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(words)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e sentence\n\n    def \u003cspan class=\"hljs-title function_\"\u003eprocess_request\u003c/span\u003e(self, message):\n        message_body = json.\u003cspan class=\"hljs-title function_\"\u003eloads\u003c/span\u003e(message)\n        user_name = message_body[\u003cspan class=\"hljs-string\"\u003e'user_name'\u003c/span\u003e]\n        user_email = message_body[\u003cspan class=\"hljs-string\"\u003e'user_email'\u003c/span\u003e]\n        user_id = message_body[\u003cspan class=\"hljs-string\"\u003e'user_id'\u003c/span\u003e]\n        file_base64 = message_body[\u003cspan class=\"hljs-string\"\u003e'file'\u003c/span\u003e]\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\" [x]user_id: {user_id} request recieved from gateway..\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\" [x]processing request for {user_name}\"\u003c/span\u003e)\n\n        # file_base64에 base64로 인코딩된 문자열이 포함되어 있다고 가정\n        file_data = base64.\u003cspan class=\"hljs-title function_\"\u003eb64decode\u003c/span\u003e(file_base64.\u003cspan class=\"hljs-title function_\"\u003eencode\u003c/span\u003e())\n        # 디코드된 파일 데이터를 새 파일에 작성\n        \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'artifacts/decoded_file.png'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'wb'\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ef\u003c/span\u003e:\n            f.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(file_data)\n\n        image_path = \u003cspan class=\"hljs-string\"\u003e\"artifacts/decoded_file.png\"\u003c/span\u003e\n        ocr_text = self.\u003cspan class=\"hljs-title function_\"\u003ekeras_ocr\u003c/span\u003e(image_path)\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\" [^] OCR 처리 완료 !!!\"\u003c/span\u003e)\n\n        response = {\n            \u003cspan class=\"hljs-string\"\u003e\"user_id\"\u003c/span\u003e: user_id,\n            \u003cspan class=\"hljs-string\"\u003e\"user_name\"\u003c/span\u003e: user_name,\n            \u003cspan class=\"hljs-string\"\u003e\"user_email\"\u003c/span\u003e: user_email,\n            \u003cspan class=\"hljs-string\"\u003e\"ocr_text\"\u003c/span\u003e: ocr_text\n        }\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response\n\ndef \u003cspan class=\"hljs-title function_\"\u003esend_email_notification\u003c/span\u003e(email, ocr_text, channel):\n    # \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e를 사용하여 이메일 알림 전송\n    message = {\n        \u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e: email,\n        \u003cspan class=\"hljs-string\"\u003e'subject'\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'OCR 처리 완료 !!'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'body'\u003c/span\u003e:f\u003cspan class=\"hljs-string\"\u003e'이미지에 대한 OCR (광학 문자 인식) 프로세스가 성공적으로 완료되었음을 알려드립니다.\\n 추출된 텍스트가 처리되어 사용할 준비가되었습니다.\\n\\n  OCR 텍스트 : {ocr_text}'\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e'other'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'null'\u003c/span\u003e,\n       }\n\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        channel.\u003cspan class=\"hljs-title function_\"\u003ebasic_publish\u003c/span\u003e(\n            exchange=\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n            routing_key=\u003cspan class=\"hljs-string\"\u003e'email_notification'\u003c/span\u003e,\n            body=json.\u003cspan class=\"hljs-title function_\"\u003edumps\u003c/span\u003e(message),\n            properties=pika.\u003cspan class=\"hljs-title class_\"\u003eBasicProperties\u003c/span\u003e(\n                delivery_mode=pika.\u003cspan class=\"hljs-property\"\u003espec\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePERSISTENT_DELIVERY_MODE\u003c/span\u003e\n            ),\n        )\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"OCR 처리 완료 이메일 알림 전송됨\"\u003c/span\u003e)\n    except \u003cspan class=\"hljs-title class_\"\u003eException\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eerr\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"메시지 게시 실패: {err}\"\u003c/span\u003e)\r\n\n## D. 알림 마이크로서비스 구현\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n이 스크립트는 \u003cspan class=\"hljs-string\"\u003e\"email_notification\"\u003c/span\u003e 큐에서 메시지를 수신하는 \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e 소비자를 설정합니다. 메시지를 받으면 email_service 모듈의 notification 함수를 호출하여 알림 프로세스를 처리합니다. 성공하면 메시지를 확인하고, 그렇지 않으면 메시지를 거부하고 오류 메시지를 출력합니다.\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pika\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e sys\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e time\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e email_service\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e dotenv \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e load_dotenv\n\n# 환경 변수 로드\n\u003cspan class=\"hljs-title function_\"\u003eload_dotenv\u003c/span\u003e()\n\u003cspan class=\"hljs-variable constant_\"\u003eRABBITMQ_URL\u003c/span\u003e = os.\u003cspan class=\"hljs-property\"\u003eenviron\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"RABBITMQ_URL\"\u003c/span\u003e)\n\ndef \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e():\n    # rabbitmq 연결\n    connection = pika.\u003cspan class=\"hljs-title class_\"\u003eBlockingConnection\u003c/span\u003e(pika.\u003cspan class=\"hljs-title class_\"\u003eConnectionParameters\u003c/span\u003e(host=\u003cspan class=\"hljs-variable constant_\"\u003eRABBITMQ_URL\u003c/span\u003e))\n    channel = connection.\u003cspan class=\"hljs-title function_\"\u003echannel\u003c/span\u003e()\n\n    def \u003cspan class=\"hljs-title function_\"\u003ecallback\u003c/span\u003e(ch, method, properties, body):\n        \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n            err = email_service.\u003cspan class=\"hljs-title function_\"\u003enotification\u003c/span\u003e(body)\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eerr\u003c/span\u003e:\n                ch.\u003cspan class=\"hljs-title function_\"\u003ebasic_nack\u003c/span\u003e(delivery_tag=method.\u003cspan class=\"hljs-property\"\u003edelivery_tag\u003c/span\u003e)\n            \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n                ch.\u003cspan class=\"hljs-title function_\"\u003ebasic_ack\u003c/span\u003e(delivery_tag=method.\u003cspan class=\"hljs-property\"\u003edelivery_tag\u003c/span\u003e)\n        except \u003cspan class=\"hljs-title class_\"\u003eException\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ee\u003c/span\u003e:\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"메시지 처리 중 오류 발생: {e}\"\u003c/span\u003e)\n            ch.\u003cspan class=\"hljs-title function_\"\u003ebasic_nack\u003c/span\u003e(delivery_tag=method.\u003cspan class=\"hljs-property\"\u003edelivery_tag\u003c/span\u003e)\n\n    channel.\u003cspan class=\"hljs-title function_\"\u003ebasic_consume\u003c/span\u003e(\n        queue=\u003cspan class=\"hljs-string\"\u003e\"email_notification\"\u003c/span\u003e, on_message_callback=callback\n    )\n\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"메시지 수신 대기 중. 종료하려면 CTRL+C를 누르세요\"\u003c/span\u003e)\n\n    channel.\u003cspan class=\"hljs-title function_\"\u003estart_consuming\u003c/span\u003e()\n\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main__\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e()\n    except \u003cspan class=\"hljs-title class_\"\u003eKeyboardInterrupt\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"중단됨\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n            sys.\u003cspan class=\"hljs-title function_\"\u003eexit\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n        except \u003cspan class=\"hljs-title class_\"\u003eSystemExit\u003c/span\u003e:\n            os.\u003cspan class=\"hljs-title function_\"\u003e_exit\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e smtplib, os, json\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e email.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEmailMessage\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e dotenv \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e load_dotenv\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e email.\u003cspan class=\"hljs-property\"\u003emime\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etext\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMIMEText\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003eload_dotenv\u003c/span\u003e()\n\ndef \u003cspan class=\"hljs-title function_\"\u003enotification\u003c/span\u003e(message):\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        message = json.\u003cspan class=\"hljs-title function_\"\u003eloads\u003c/span\u003e(message)\n        receiver_address = message[\u003cspan class=\"hljs-string\"\u003e\"email\"\u003c/span\u003e]\n        subject = message[\u003cspan class=\"hljs-string\"\u003e\"subject\"\u003c/span\u003e]\n        body = message[\u003cspan class=\"hljs-string\"\u003e\"body\"\u003c/span\u003e]\n        other = message[\u003cspan class=\"hljs-string\"\u003e\"other\"\u003c/span\u003e]\n\n        sender_address = os.\u003cspan class=\"hljs-property\"\u003eenviron\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"GMAIL_ADDRESS\"\u003c/span\u003e)\n        sender_password = os.\u003cspan class=\"hljs-property\"\u003eenviron\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"GMAIL_PASSWORD\"\u003c/span\u003e)\n\n        # \u003cspan class=\"hljs-title class_\"\u003eGmail\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSMTP\u003c/span\u003e 서버 설정\n        smtp_server = \u003cspan class=\"hljs-string\"\u003e'smtp.gmail.com'\u003c/span\u003e\n        smtp_port = \u003cspan class=\"hljs-number\"\u003e587\u003c/span\u003e\n\n        server = smtplib.\u003cspan class=\"hljs-title function_\"\u003eSMTP\u003c/span\u003e(smtp_server, smtp_port)\n        server.\u003cspan class=\"hljs-title function_\"\u003estarttls\u003c/span\u003e()\n        server.\u003cspan class=\"hljs-title function_\"\u003elogin\u003c/span\u003e(sender_address, sender_password)\n\n        # 이메일 메시지 작성\n        msg = \u003cspan class=\"hljs-title class_\"\u003eMIMEText\u003c/span\u003e(body)\n        msg[\u003cspan class=\"hljs-string\"\u003e'Subject'\u003c/span\u003e] = subject\n        msg[\u003cspan class=\"hljs-string\"\u003e'From'\u003c/span\u003e] = sender_address\n        msg[\u003cspan class=\"hljs-string\"\u003e'To'\u003c/span\u003e] = receiver_address\n\n        server.\u003cspan class=\"hljs-title function_\"\u003esendmail\u003c/span\u003e(sender_address, receiver_address, msg.\u003cspan class=\"hljs-title function_\"\u003eas_string\u003c/span\u003e())\n        server.\u003cspan class=\"hljs-title function_\"\u003equit\u003c/span\u003e()\n\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이메일 발송 완료\"\u003c/span\u003e)\n    except \u003cspan class=\"hljs-title class_\"\u003eException\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ee\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"이메일 발송 실패: {e}\"\u003c/span\u003e)\n\n# 애플리케이션 데모\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n# 결론\n\n마지막으로, \u003cspan class=\"hljs-title class_\"\u003eFastAPI\u003c/span\u003e와 \u003cspan class=\"hljs-title class_\"\u003eRabbitMQ\u003c/span\u003e를 사용하여 엔드 투 엔드 마이크로서비스 아키텍처를 성공적으로 구현했습니다. 사용자 인증 서비스, \u003cspan class=\"hljs-variable constant_\"\u003eOCR\u003c/span\u003e 처리를 위한 머신 러닝 서비스 및 이메일 알림을 위한 알림 서비스를 어떻게 만드는지 보여드렸습니다.\n\n이 블로그를 통해 서비스 격리, 메시징 큐를 통한 통신, 확장성 및 성능을 위한 비동기 처리의 장점과 같은 마이크로서비스의 주요 개념에 대해 배웠습니다.\n\n프로젝트를 실행하려면 \u003cspan class=\"hljs-title class_\"\u003eGitHub\u003c/span\u003e 저장소의 \u003cspan class=\"hljs-variable constant_\"\u003eREADME\u003c/span\u003e 파일에 있는 지침을 따르세요. 읽어 주셔서 감사합니다. 이 프로젝트가 여러분께 영감을 주어 직접 마이크로서비스 아키텍처를 탐구하고 구현하는 데 도움이 되기를 바랍니다.\n\n\u0026#x3C;div \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u0026#x3C;/div\u003e\n\n깃허브: [\u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//github.com/shantanu1905/fastapi-microservice-demo](https://github.com/shantanu1905/fastapi-microservice-demo)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-BuildingEnd-to-EndMicroserviceswithFastAPIandRabbitMQAComprehensiveGuide"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>