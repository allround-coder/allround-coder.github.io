<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>JavaScript와 TypeScript 비교 정리 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="JavaScript와 TypeScript 비교 정리 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="JavaScript와 TypeScript 비교 정리 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years" data-gatsby-head="true"/><meta name="twitter:title" content="JavaScript와 TypeScript 비교 정리 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 18:10" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">JavaScript와 TypeScript 비교 정리</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="JavaScript와 TypeScript 비교 정리" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">53<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png" alt="2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png"></p>
<p>이 기사는 지난 3년 동안 (그리고 그 이전에서도) JavaScript/ECMAScript와 TypeScript에서 발생한 거의 모든 변경 사항을 살펴봅니다.</p>
<p>다음의 기능들 중 일부는 여러분에게 적용되지 않거나 실용적이지 않을 수 있지만, 이러한 언어에 대한 이해를 더 깊게 하고 가능한 기능을 보여주기 위한 것입니다.</p>
<p>많은 TypeScript 기능들을 생략했는데, 그 이유는 "이전과 달리 예상대로 작동하지 않았으나, 지금은 그렇게 됩니다"로 요약할 수 있습니다. 따라서 과거에 작동하지 않았던 것이 있다면, 다시 시도해 보세요.</p>
<ul>
<li>JavaScript / ECMAScript (가장 오래된 것부터)</li>
<li>TypeScript (가장 오래된 것부터)</li>
</ul>
<h1>내용</h1>
<h1>ECMAScript</h1>
<h2>과거 (아직도 중요한 이전 소개들)</h2>
<ul>
<li>Tagged template literals: 템플릿 리터럴 앞에 함수 이름을 붙이면 함수가 템플릿 리터럴 및 템플릿 값들을 전달받게 됩니다. 이 방법에는 재미있는 활용법이 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 임의의 숫자를 포함한 문자열을 로깅할 때 숫자를 형식화하는 방법을 작성하고 싶다고 가정해 봅시다.</span>
<span class="hljs-comment">// 그럴 때 태그드 템플릿을 사용할 수 있습니다.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">formatNumbers</span>(<span class="hljs-params">strings: TemplateStringsArray, number: number</span>): string {
  <span class="hljs-keyword">return</span> strings[<span class="hljs-number">0</span>] + number.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) + strings[<span class="hljs-number">1</span>];
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(formatNumbers<span class="hljs-string">`This is the value: <span class="hljs-subst">${<span class="hljs-number">0</span>}</span>, it's important.`</span>); <span class="hljs-comment">// This is the value: 0.00, it's important.</span>

<span class="hljs-comment">// 문자열 내의 번역 키를 "번역"하고 싶을 때 (여기서는 소문자로 변경)</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">translateKey</span>(<span class="hljs-params">key: string</span>): string {
  <span class="hljs-keyword">return</span> key.<span class="hljs-title function_">toLocaleLowerCase</span>();
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">translate</span>(<span class="hljs-params">strings: TemplateStringsArray, ...expressions: string[]</span>): string {
  <span class="hljs-keyword">return</span> strings.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, currentValue, index</span>) =></span> accumulator + currentValue + <span class="hljs-title function_">translateKey</span>(expressions[index] ?? <span class="hljs-string">''</span>), <span class="hljs-string">''</span>);
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(translate<span class="hljs-string">`Hello, this is <span class="hljs-subst">${<span class="hljs-string">'NAME'</span>}</span> to say <span class="hljs-subst">${<span class="hljs-string">'MESSAGE'</span>}</span>.`</span>); <span class="hljs-comment">// Hello, this is name to say message.</span>
</code></pre>
<ul>
<li>Symbols: 객체에 대한 고유 키: Symbol("foo") === Symbol("foo"); // false. 내부적으로 사용됩니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: { [<span class="hljs-attr">index</span>: string]: string } = {};

<span class="hljs-keyword">const</span> symbolA = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'a'</span>);
<span class="hljs-keyword">const</span> symbolB = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">'b'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(symbolA.<span class="hljs-property">description</span>); <span class="hljs-comment">// "a"</span>

obj[symbolA] = <span class="hljs-string">'a'</span>;
obj[symbolB] = <span class="hljs-string">'b'</span>;
obj[<span class="hljs-string">'c'</span>] = <span class="hljs-string">'c'</span>;
obj.<span class="hljs-property">d</span> = <span class="hljs-string">'d'</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[symbolA]); <span class="hljs-comment">// "a"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[symbolB]); <span class="hljs-comment">// "b"</span>

<span class="hljs-comment">// 다른 심볼이나 심볼 없이는 키에 액세스할 수 없습니다.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'a'</span>)]); <span class="hljs-comment">// undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[<span class="hljs-string">'a'</span>]); <span class="hljs-comment">// undefined</span>

<span class="hljs-comment">// for ... in을 사용할 때 키가 열거되지 않습니다.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">in</span> obj) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// "c", "d"</span>
}
</code></pre>
<h2>ES2020</h2>
<ul>
<li>Optional chaining: 잠재적으로 정의되지 않은 객체의 값을 (인덱싱을 통해) 액세스하기 위해 부모 객체 이름 뒤에 ?를 사용하여 선택적 연결을 사용할 수 있습니다. 이는 인덱싱 ([...]) 또는 함수 호출에도 사용할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이전:</span>
<span class="hljs-comment">// 우리가 정확히 정의된 것인지 확신할 수 없는 객체 변수 (또는 다른 구조)가 있을 때,</span>
<span class="hljs-comment">// 속성에 쉽게 액세스할 수 없습니다.</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">object</span>: { <span class="hljs-attr">name</span>: string } | <span class="hljs-literal">undefined</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span> ? <span class="hljs-literal">undefined</span> : { <span class="hljs-attr">name</span>: <span class="hljs-string">'test'</span> };
<span class="hljs-keyword">const</span> value = object.<span class="hljs-property">name</span>; <span class="hljs-comment">// 타입 오류: 'object' 가 'undefined' 일 수 있습니다.</span>

<span class="hljs-comment">// 먼저 정의되었는지 확인해야 했지만, 이는 가독성을 해치며 중첩된 객체에 대해 복잡해집니다.</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">objectOld</span>: { <span class="hljs-attr">name</span>: string } | <span class="hljs-literal">undefined</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span> ? <span class="hljs-literal">undefined</span> : { <span class="hljs-attr">name</span>: <span class="hljs-string">'test'</span> };
<span class="hljs-keyword">const</span> valueOld = objectOld ? objectOld.<span class="hljs-property">name</span> : <span class="hljs-literal">undefined</span>;

<span class="hljs-comment">// 새로운 방법:</span>
<span class="hljs-comment">// 대신 선택적 연결을 사용할 수 있습니다.</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">objectNew</span>: { <span class="hljs-attr">name</span>: string } | <span class="hljs-literal">undefined</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span> ? <span class="hljs-literal">undefined</span> : { <span class="hljs-attr">name</span>: <span class="hljs-string">'test'</span> };
<span class="hljs-keyword">const</span> valueNew = objectNew?.<span class="hljs-property">name</span>;

<span class="hljs-comment">// 이것은 인덱싱 및 함수에도 사용할 수 있습니다.</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">array</span>: string[] | <span class="hljs-literal">undefined</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span> ? <span class="hljs-literal">undefined</span> : [<span class="hljs-string">'test'</span>];
<span class="hljs-keyword">const</span> item = array?.[<span class="hljs-number">0</span>];
<span class="hljs-keyword">const</span> <span class="hljs-attr">func</span>: (<span class="hljs-function">() =></span> string) | <span class="hljs-literal">undefined</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span> ? <span class="hljs-literal">undefined</span> : <span class="hljs-function">() =></span> <span class="hljs-string">'test'</span>;
<span class="hljs-keyword">const</span> result = func?.();
</code></pre>
<ul>
<li>널 병합 연산자 (??): 조건부 할당을 위해 || 연산자를 사용하는 대신 새로운 ?? 연산자를 사용할 수 있습니다. 모든 거짓 값에 적용되는 대신 undefined와 null에만 적용됩니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-attr">value</span>: string | <span class="hljs-literal">undefined</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() > <span class="hljs-number">0.5</span> ? <span class="hljs-literal">undefined</span> : <span class="hljs-string">'test'</span>;

<span class="hljs-comment">// 이전:</span>
<span class="hljs-comment">// 값이 undefined 또는 null인 경우 다른 값으로 조건적으로 할당하려면 "||" 연산자를 사용할 수 있었습니다.</span>
<span class="hljs-keyword">const</span> anotherValue = value || <span class="hljs-string">'hello'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anotherValue); <span class="hljs-comment">// "test" 또는 "hello"</span>

<span class="hljs-comment">// 이는 참 값 사용 시 잘 작동하지만, 0이나 빈 문자열과 비교할 경우에도 적용됩니다.</span>
<span class="hljs-keyword">const</span> incorrectValue = <span class="hljs-string">''</span> || <span class="hljs-string">'incorrect'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(incorrectValue); <span class="hljs-comment">// 항상 "incorrect"</span>
<span class="hljs-keyword">const</span> anotherIncorrectValue = <span class="hljs-number">0</span> || <span class="hljs-string">'incorrect'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anotherIncorrectValue); <span class="hljs-comment">// 항상 "incorrect"</span>

<span class="hljs-comment">// 새로운 방법:</span>
<span class="hljs-comment">// 이제 nullish 병합 연산자를 사용할 수 있습니다. 이는 오직 undefined와 null 값에만 적용됩니다.</span>
<span class="hljs-keyword">const</span> newValue = value ?? <span class="hljs-string">'hello'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newValue) <span class="hljs-comment">// 항상 "hello"</span>

<span class="hljs-comment">// 이제 falsy 값들이 교체되지 않습니다.</span>
<span class="hljs-keyword">const</span> correctValue = <span class="hljs-string">''</span> ?? <span class="hljs-string">'incorrect'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(correctValue); <span class="hljs-comment">// 항상 ""</span>
<span class="hljs-keyword">const</span> anotherCorrectValue = <span class="hljs-number">0</span> ?? <span class="hljs-string">'incorrect'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anotherCorrectValue); <span class="hljs-comment">// 항상 0</span>
</code></pre>
<ul>
<li>import(): 변수를 사용하여 런타임에서 동적으로 import ... from ... 처럼 모듈을 가져올 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> importModule;
<span class="hljs-keyword">if</span> (shouldImport) {
  importModule = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./module.mjs'</span>);
}
</code></pre>
<ul>
<li>String.matchAll(): 루프를 사용하지 않고 정규 표현식의 여러 일치 항목과 캡처 그룹을 모두 얻을 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> stringVar = <span class="hljs-string">'testhello,testagain,'</span>;

<span class="hljs-comment">// 이전:</span>
<span class="hljs-comment">// 일치 항목만 검색되며 캡처 그룹은 포함되지 않습니다.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(stringVar.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/test([\w]+?),/g</span>)); <span class="hljs-comment">// ["testhello,", "testagain,"]</span>

<span class="hljs-comment">// 캡처 그룹을 포함한 하나의 일치 항목만 검색합니다.</span>
<span class="hljs-keyword">const</span> singleMatch = stringVar.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/test([\w]+?),/</span>);
<span class="hljs-keyword">if</span> (singleMatch) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(singleMatch[<span class="hljs-number">0</span>]); <span class="hljs-comment">// "testhello,"</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(singleMatch[<span class="hljs-number">1</span>]); <span class="hljs-comment">// "hello"</span>
}

<span class="hljs-comment">// 같은 결과를 얻지만 매우 직관적이지 않습니다 (exec 메서드는 마지막 인덱스를 저장합니다).</span>
<span class="hljs-comment">// 루프 외부에서 정의되어야 하며 전역으로 선언되어야 하며 (/g) 모드여야 합니다.</span>
<span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/test([\w]+?),/g</span>;
<span class="hljs-keyword">let</span> execMatch;
<span class="hljs-keyword">while</span> ((execMatch = regex.<span class="hljs-title function_">exec</span>(stringVar)) !== <span class="hljs-literal">null</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(execMatch[<span class="hljs-number">0</span>]); <span class="hljs-comment">// "testhello,", "testagain,"</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(execMatch[<span class="hljs-number">1</span>]); <span class="hljs-comment">// "hello", "again"</span>
}

<span class="hljs-comment">// 새로운 방법:</span>
<span class="hljs-comment">// 정규식은 전역 (/g)이어야 합니다. 그렇지 않으면 작동하지 않습니다.</span>
<span class="hljs-keyword">const</span> matchesIterator = stringVar.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/test([\w]+?),/g</span>);
<span class="hljs-comment">// 순회해야 하거나 배열(Array.from())로 변환해야 하며 직접 색인화(인덱싱)할 수 없습니다.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> match <span class="hljs-keyword">of</span> matchesIterator) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(match[<span class="hljs-number">0</span>]); <span class="hljs-comment">// "testhello,", "testagain,"</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(match[<span class="hljs-number">1</span>]); <span class="hljs-comment">// "hello", "again"</span>
}
</code></pre>
<ul>
<li>Promise.allSettled(): Promise.all()과 유사하지만 모든 Promise가 완료될 때까지 기다리며 첫 번째 reject/throw에서 반환하지 않습니다. 모든 오류 처리를 보다 쉽게 할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">success1</span>(<span class="hljs-params"></span>) {<span class="hljs-keyword">return</span> <span class="hljs-string">'a'</span>}
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">success2</span>(<span class="hljs-params"></span>) {<span class="hljs-keyword">return</span> <span class="hljs-string">'b'</span>}
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fail1</span>(<span class="hljs-params"></span>) {<span class="hljs-keyword">throw</span> <span class="hljs-string">'fail 1'</span>}
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fail2</span>(<span class="hljs-params"></span>) {<span class="hljs-keyword">throw</span> <span class="hljs-string">'fail 2'</span>}

<span class="hljs-comment">// 이전:</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">success1</span>(), <span class="hljs-title function_">success2</span>()])); <span class="hljs-comment">// ["a", "b"]</span>
<span class="hljs-comment">// 하지만:</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">success1</span>(), <span class="hljs-title function_">success2</span>(), <span class="hljs-title function_">fail1</span>(), <span class="hljs-title function_">fail2</span>()]);
} <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); <span class="hljs-comment">// "fail 1"</span>
}
<span class="hljs-comment">// 주의: 하나의 에러만 처리하고 성공 값에 액세스할 수 없습니다.</span>

<span class="hljs-comment">// 이전 해결 방법 (정말 최적이 아님):</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([ <span class="hljs-comment">// ["a", "b", undefined, undefined]</span>
  <span class="hljs-title function_">success1</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =></span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); }),
  <span class="hljs-title function_">success2</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =></span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); }),
  <span class="hljs-title function_">fail1</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =></span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); }), <span class="hljs-comment">// "fail 1"</span>
  <span class="hljs-title function_">fail2</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =></span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); })])); <span class="hljs-comment">// "fail 2"</span>

<span class="hljs-comment">// 새로운 방법:</span>
<span class="hljs-keyword">const</span> results = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">allSettled</span>([<span class="hljs-title function_">success1</span>(), <span class="hljs-title function_">success2</span>(), <span class="hljs-title function_">fail1</span>(), <span class="hljs-title function_">fail2</span>()]);
<span class="hljs-keyword">const</span> sucessfulResults = results
  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">result</span> =></span> result.<span class="hljs-property">status</span> === <span class="hljs-string">'fulfilled'</span>)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">result</span> =></span> (result <span class="hljs-keyword">as</span> <span class="hljs-title class_">PromiseFulfilledResult</span>&#x3C;string>).<span class="hljs-property">value</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sucessfulResults); <span class="hljs-comment">// ["a", "b"]</span>
results.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">result</span> =></span> result.<span class="hljs-property">status</span> === <span class="hljs-string">'rejected'</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">error</span> =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((error <span class="hljs-keyword">as</span> <span class="hljs-title class_">PromiseRejectedResult</span>).<span class="hljs-property">reason</span>); <span class="hljs-comment">// "fail 1", "fail 2"</span>
});
<span class="hljs-comment">// 또는:</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> result <span class="hljs-keyword">of</span> results) {
  <span class="hljs-keyword">if</span> (result.<span class="hljs-property">status</span> === <span class="hljs-string">'fulfilled'</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">value</span>); <span class="hljs-comment">// "a", "b"</span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result.<span class="hljs-property">status</span> === <span class="hljs-string">'rejected'</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">reason</span>); <span class="hljs-comment">// "fail 1", "fail 2"</span>
  }
}
</code></pre>
<ul>
<li>BigInt: 새로운 BigInt 데이터 유형을 사용하여 큰 (정수) 숫자를 정확하게 저장하고 처리할 수 있어 JavaScript가 숫자를 부동 소수점으로 저장하는 것에 의한 오류를 방지할 수 있습니다. BigInt() 생성자를 사용하여 생성할 수 있고(불완전성을 방지하기 위해 문자열을 선호) 또는 숫자 끝에 n을 추가하여 생성할 수 있습니다.</li>
</ul>
<p>// 이전:
// JavaScript는 숫자를 부동 소수점으로 저장하기 때문에 항상 약간의 부정확성이 있습니다.
// 더 중요한 것은 특정 숫자 이후에 정수 연산에 부정확성이 시작됩니다.
const maxSafeInteger = 9007199254740991;
console.log(maxSafeInteger === Number.MAX_SAFE_INTEGER); // true</p>
<p>// 해당 숫자보다 큰 숫자와 비교하면 부정확성이 발생할 수 있습니다.
console.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2);</p>
<p>// NEW:
// BigInt 데이터 형식을 사용하면 이론적으로 무한히 큰 (정수) 숫자를 저장하고 조작할 수 있습니다.
// 숫자 끝에 "n"을 추가하거나 BigInt 생성자를 사용하여 사용합니다.
const maxSafeIntegerPreviously = 9007199254740991n;
console.log(maxSafeIntegerPreviously); // 9007199254740991</p>
<p>const anotherWay = BigInt(9007199254740991);
console.log(anotherWay); // 9007199254740991</p>
<p>// 안전한 정수(Number.MAX_SAFE_INTEGER)보다 큰 정수를 전달하면 안됩니다.
const incorrect = BigInt(9007199254740992);
console.log(incorrect); // 9007199254740992
const incorrectAgain = BigInt(9007199254740993);
console.log(incorrectAgain); // 9007199254740992
// 오랜, 동일한 값으로 변환됩니다.</p>
<p>// 대신 문자열을 사용하거나 더 좋은 다른 구문을 사용합니다.
const correct = BigInt('9007199254740993');
console.log(correct); // 9007199254740993
const correctAgain = 9007199254740993n;
console.log(correctAgain); // 9007199254740993</p>
<p>// 16진수, 8진수 및 2진수도 문자열로 전달할 수 있습니다.
const hex = BigInt('0x1fffffffffffff');
console.log(hex); // 9007199254740991
const octal = BigInt('0o377777777777777777');
console.log(octal); // 9007199254740991
const binary = BigInt('0b11111111111111111111111111111111111111111111111111111');
console.log(binary); // 9007199254740991</p>
<p>// 대부분의 산술 연산은 예상대로 작동하지만 다른 연산자도 BigInt 여야합니다. 모든 연산도 BigInt를 반환합니다.
const addition = maxSafeIntegerPreviously + 2n;
console.log(addition); // 9007199254740993</p>
<p>const multiplication = maxSafeIntegerPreviously * 2n;
console.log(multiplication); // 18014398509481982</p>
<p>const subtraction = multiplication - 10n;
console.log(subtraction); // 18014398509481972</p>
<p>const modulo = multiplication % 10n;
console.log(modulo); // 2</p>
<p>const exponentiation = 2n ** 54n;
console.log(exponentiation); // 18014398509481984</p>
<p>const exponentiationAgain = 2n ^ 54n;
console.log(exponentiationAgain); // 18014398509481984</p>
<p>const negative = exponentiation * -1n;
console.log(negative); // -18014398509481984</p>
<p>// BigInt로 인한 정수 나눗셈은 조금 다르게 작동합니다.
const division = multiplication / 2n;
console.log(division); // 9007199254740991
// 나뉠 수 있는 정수에 대해서는 제대로 작동합니다.</p>
<p>// 나누기가 안 되는 숫자에 대해서는 정수 나눗셈(내림)처럼 작동할 것입니다.
const divisionAgain = 5n / 2n;
console.log(divisionAgain); // 2</p>
<p>// 일치하는(엄격한) 비교가 BigInt 숫자에는 적용되지 않습니다.
console.log(0n === 0); // false
console.log(0n == 0); // true</p>
<p>// 그러나 비교는 예상대로 작동합니다.
console.log(1n &#x3C; 2); // true
console.log(2n > 1); // true
console.log(2 > 2); // false
console.log(2n > 2); // false
console.log(2n >= 2); // true</p>
<p>// 타입은 "bigint"입니다.
console.log(typeof 1n); // "bigint"</p>
<p>// 일반 숫자(부호있는 부호 없는 (음수 없음))로 다시 변환할 수 있습니다.
// 그러나 이는 정확도를 희생합니다. 유효 숫자의 수를 지정할 수 있습니다.</p>
<p>console.log(BigInt.asIntN(0, -2n)); // 0
console.log(BigInt.asIntN(1, -2n)); // 0
console.log(BigInt.asIntN(2, -2n)); // -2
// 보통 더 높은 비트 수를 사용할 것입니다.</p>
<p>// 음수 숫자는 부호가 있는 숫자로 변환될 때 2의 보수로 변환됩니다.
console.log(BigInt.asUintN(8, -2n)); // 254</p>
<ul>
<li>globalThis: 환경(브라우저, NodeJS, ...)와 상관없이 전역 컨텍스트에서 변수에 액세스할 수 있습니다. 여전히 권장되지는 않지만 때로는 필요합니다. 브라우저의 최상위 수준에서 this와 유사합니다.</li>
</ul>
<p>console.log(globalThis.Math); // Math Object</p>
<ul>
<li>import.meta: ES-모듈을 사용할 때 현재 모듈 URL import.meta.url을 얻습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>); <span class="hljs-comment">// "file://..."</span>
</code></pre>
<ul>
<li>export * as … from …: 쉽게 기본값을 하위 모듈로 다시 내보냅니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> * <span class="hljs-keyword">as</span> am <span class="hljs-keyword">from</span> <span class="hljs-string">'another-module'</span>
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { am } <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span>
</code></pre>
<h2>ES2021</h2>
<ul>
<li>String.replaceAll(): 이제 문자열 내에서 부분 문자열의 모든 인스턴스를 대체할 수 있습니다. 더 이상 항상 전역 플래그(/g)를 사용하는 정규 표현식을 사용할 필요가 없습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> testString = <span class="hljs-string">'hello/greetings everyone/everybody'</span>;
<span class="hljs-comment">// 이전:</span>
<span class="hljs-comment">// 첫 번째 인스턴스만 대체함</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(testString.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'/'</span>, <span class="hljs-string">'|'</span>)); <span class="hljs-comment">// 'hello|greetings everyone/everybody'</span>

<span class="hljs-comment">// 대체하기 위해 정규 표현식을 사용해야 했는데, 이는 성능이 좋지 않고 이스케이프가 필요합니다.</span>
<span class="hljs-comment">// 전역 플래그(/g)를 참고하세요.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(testString.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\//g</span>, <span class="hljs-string">'|'</span>)); <span class="hljs-comment">// 'hello|greetings everyone|everybody'</span>

<span class="hljs-comment">// 새로운 기능:</span>
<span class="hljs-comment">// replaceAll을 사용하면 더 명확하고 빠릅니다.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(testString.<span class="hljs-title function_">replaceAll</span>(<span class="hljs-string">'/'</span>, <span class="hljs-string">'|'</span>)); <span class="hljs-comment">// 'hello|greetings everyone|everybody'</span>
</code></pre>
<ul>
<li>Promise.any(): 프로미스 목록 중 하나의 결과만 필요한 경우, 첫 번째 결과를 반환합니다. 모든 프로미스가 거부될 때만 거부하고 AggregateError를 반환하며, 즉시 거부되는 Promise.race가 아닙니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-title function_">success1</span>(), <span class="hljs-title function_">success2</span>()])); <span class="hljs-comment">// "a"</span>
<span class="hljs-comment">// 그러나:</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([<span class="hljs-title function_">fail1</span>(), <span class="hljs-title function_">fail2</span>(), <span class="hljs-title function_">success1</span>(), <span class="hljs-title function_">success2</span>()]);
} <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); <span class="hljs-comment">// "fail 1"</span>
}
<span class="hljs-comment">// 유의: 하나의 오류만 catch하고 성공 값을 액세스할 수 없습니다.</span>

<span class="hljs-comment">// 이전 수정 (정말 최적화되지 않음):</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([ <span class="hljs-comment">// "a"</span>
  <span class="hljs-title function_">fail1</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =></span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); }), <span class="hljs-comment">// "fail 1"</span>
  <span class="hljs-title function_">fail2</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =></span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); }), <span class="hljs-comment">// "fail 2"</span>
  <span class="hljs-title function_">success1</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =></span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); }),
  <span class="hljs-title function_">success2</span>().<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =></span> { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); })]));

<span class="hljs-comment">// 새로운:</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([<span class="hljs-title function_">fail1</span>(), <span class="hljs-title function_">fail2</span>(), <span class="hljs-title function_">success1</span>(), <span class="hljs-title function_">success2</span>()])); <span class="hljs-comment">// "a"</span>
<span class="hljs-comment">// 모든 프로미스가 거부될 때만 거부하고 모든 오류를 포함하는 AggregateError를 리턴합니다.</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([<span class="hljs-title function_">fail1</span>(), <span class="hljs-title function_">fail2</span>()]);
} <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e); <span class="hljs-comment">// [AggregateError: All promises were rejected]</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">errors</span>); <span class="hljs-comment">// ["fail 1", "fail 2"]</span>
}
</code></pre>
<ul>
<li>Nullish coalescing assignment (??=): 이전에 "nullish"였을 때만 값을 할당합니다 (null 또는 undefined).</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> x1 = <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">let</span> x2 = <span class="hljs-string">'a'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getNewValue</span> = (<span class="hljs-params"></span>) => <span class="hljs-string">'b'</span>;

<span class="hljs-comment">// undefined는 nullish이므로 새 값이 x1에 할당됩니다.</span>
x1 ??= <span class="hljs-string">'b'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x1) <span class="hljs-comment">// "b"</span>

<span class="hljs-comment">// 문자열은 nullish가 아니므로 x2에 새 값이 할당되지 않습니다.</span>
<span class="hljs-comment">// 또한 참고: getNewValue()가 실행되지 않습니다.</span>
x2 ??= <span class="hljs-title function_">getNewValue</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x2) <span class="hljs-comment">// "a"</span>
</code></pre>
<ul>
<li>Logical and assignment (&#x26;&#x26;=): 이전에 "truthy"였을 때만 값을 할당합니다 (true 또는 true로 변환되는 값).</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> x1 = <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">let</span> x2 = <span class="hljs-string">'a'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getNewValue</span> = (<span class="hljs-params"></span>) => <span class="hljs-string">'b'</span>;

<span class="hljs-comment">// 지정되지 않은 값인 x1에 새 값이 할당되지 않습니다. 왜냐하면 지정되지 않은 값은 참이 아닙니다.</span>
<span class="hljs-comment">// 또한 주의: getNewValue()는 실행되지 않습니다.</span>
x1 &#x26;&#x26;= <span class="hljs-title function_">getNewValue</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x1) <span class="hljs-comment">// undefined</span>

<span class="hljs-comment">// 문자열은 참이므로 새 값이 x2에 할당됩니다.</span>
x2 &#x26;&#x26;= <span class="hljs-string">'b'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x2) <span class="hljs-comment">// "b"</span>
</code></pre>
<ul>
<li>논리 또는 할당 (||=): 이전에 "거짓"인 경우에만 값이 할당됩니다 (false 또는 false로 변환).</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> x1 = <span class="hljs-literal">undefined</span>;
<span class="hljs-keyword">let</span> x2 = <span class="hljs-string">'a'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getNewValue</span> = (<span class="hljs-params"></span>) => <span class="hljs-string">'b'</span>;

<span class="hljs-comment">// x1에 새 값이 할당됩니다. 왜냐하면 지정되지 않은 값은 거짓이기 때문입니다.</span>
x1 ||= <span class="hljs-string">'b'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x1) <span class="hljs-comment">// "b"</span>

<span class="hljs-comment">// x2에 새 값이 할당되지 않습니다. 왜냐하면 문자열은 거짓이 아닙니다.</span>
<span class="hljs-comment">// 또한 주의: getNewValue()는 실행되지 않습니다.</span>
x2 ||= <span class="hljs-title function_">getNewValue</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x2) <span class="hljs-comment">// "a"</span>
</code></pre>
<ul>
<li>WeakRef: 객체가 가비지 수집되는 것을 방지하지 않고 객체에 "약한" 참조를 보유합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakRef</span>(element);

<span class="hljs-comment">// 만약 객체/요소가 여전히 존재하고 쓰레기 수집되지 않았다면 값을 가져옵니다.</span>
<span class="hljs-keyword">const</span> value = ref.<span class="hljs-property">deref</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// undefined</span>
<span class="hljs-comment">// 객체가 더는 존재하지 않는 것 같습니다.</span>
</code></pre>
<ul>
<li>숫자 리터럴 구분자 (_): 가독성을 위해 숫자를 _로 구분합니다. 이는 기능에 영향을 미치지 않습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> int = <span class="hljs-number">1_000_000_000</span>;
<span class="hljs-keyword">const</span> float = <span class="hljs-number">1_000_000_000.999_999_999</span>;
<span class="hljs-keyword">const</span> max = <span class="hljs-number">9_223_372_036_854_775_807n</span>;
<span class="hljs-keyword">const</span> binary = <span class="hljs-number">0b1011_0101_0101</span>;
<span class="hljs-keyword">const</span> octal = <span class="hljs-number">0o1234_5670</span>;
<span class="hljs-keyword">const</span> hex = <span class="hljs-number">0xD0_E0_F0</span>;
</code></pre>
<h2>ES2022</h2>
<ul>
<li>최상위 대기: await 키워드는 이제 ES 모듈의 최상위 수준에서 사용할 수 있습니다. 이는 래퍼 함수의 필요성을 제거하고 오류 처리를 개선합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFuncSuccess</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">'test'</span>;
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFuncFail</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Test'</span>);
}

<span class="hljs-comment">// 이전:</span>
<span class="hljs-comment">// 프로미스를 대기하려면 async 함수 내부에서만 가능했습니다.</span>
<span class="hljs-comment">// await asyncFuncSuccess(); // SyntaxError: await is only valid in async functions</span>
<span class="hljs-comment">// 따라서 async 함수 내부로 래핑해야 했고 이는 오류 처리와 최상위 동시성을 잃게 했습니다.</span>
<span class="hljs-keyword">try</span> {
  (<span class="hljs-keyword">async</span> () => {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncFuncSuccess</span>()); <span class="hljs-comment">// "test"</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncFuncFail</span>();
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-comment">// 오류 처리를 위해 필요합니다. 그렇지 않으면 오류가 캐치되지 않거나 적절한 추적 없이 너무 늦게 되어버립니다.</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e); <span class="hljs-comment">// Error: "Test"</span>
      <span class="hljs-keyword">throw</span> e;
    }
  })();
} <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-comment">// 함수가 async여서 절대 호출되지 않거나(적절한 추적이 없거나 너무 늦게) 이유 때문에</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);
}

<span class="hljs-comment">// 비동기 함수가 기다려지지 않았기 때문에 이 프로미스 결과보다 먼저 기록됩니다.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Hey'</span>); <span class="hljs-comment">// "Hey"</span>

<span class="hljs-comment">// 새로운:</span>
<span class="hljs-comment">// 파일이 ES 모듈이라면(package.json에 설정되었고, exports가 있고, ".mts"로 명명된 경우) 최상위 수준에서 바로 await할 수 있습니다.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncFuncSuccess</span>()); <span class="hljs-comment">// "test"</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncFuncFail</span>();
} <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e); <span class="hljs-comment">// Error: "Test"</span>
}

<span class="hljs-comment">// 모든 비동기 호출이 기다려지기 때문에 이 프로미스 결과 뒤에 기록됩니다.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Hello'</span>); <span class="hljs-comment">// "Hello"</span>
</code></pre>
<ul>
<li>#private: 클래스 멤버(속성 및 메서드)를 이름이 #로 시작하게하여 비공개로 만듭니다. 따라서 이러한 멤버는 클래스 내부에서만 액세스할 수 있습니다. 삭제되거나 동적으로 할당할 수 없습니다. 잘못된 동작은 JavaScript(하지만 TypeScript가 아닌) 구문 오류를 발생시킵니다. TypeScript 프로젝트에서는 권장되지 않습니다. 대신 기존 private 키워드를 사용하십시오.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassWithPrivateField</span> {
  #privateField;
  #anotherPrivateField = <span class="hljs-number">4</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.#privateField = <span class="hljs-number">42</span>; <span class="hljs-comment">// 유효</span>
    <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.#privateField; <span class="hljs-comment">// 구문 오류</span>
    <span class="hljs-variable language_">this</span>.#undeclaredField = <span class="hljs-number">444</span>; <span class="hljs-comment">// 구문 오류</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.#anotherPrivateField); <span class="hljs-comment">// 4</span>
  }
}

<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWithPrivateField</span>();
instance.#privateField === <span class="hljs-number">42</span>; <span class="hljs-comment">// 구문 오류</span>
</code></pre>
<ul>
<li>static 클래스 멤버: 클래스 필드(속성 및 메서드)를 static으로 표시하세요.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> {
  <span class="hljs-keyword">static</span> id = <span class="hljs-string">'Logger1'</span>;
  <span class="hljs-keyword">static</span> type = <span class="hljs-string">'GenericLogger'</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">message: string | <span class="hljs-built_in">Error</span></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Logger</span> {
  <span class="hljs-keyword">static</span> type = <span class="hljs-string">'ErrorLogger'</span>;
  <span class="hljs-keyword">static</span> qualifiedType;
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">e: <span class="hljs-built_in">Error</span></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-title function_">toString</span>());
  }
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Logger</span>.<span class="hljs-property">type</span>); <span class="hljs-comment">// "GenericLogger"</span>
<span class="hljs-title class_">Logger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Test'</span>); <span class="hljs-comment">// "Test"</span>

<span class="hljs-comment">// 정적으로만 있는 클래스를 생성하는 것은 무의미하지만 여기선 시연을 위해 수행되었습니다.</span>
<span class="hljs-keyword">const</span> log = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>();

<span class="hljs-title class_">ErrorLogger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Test'</span>)); <span class="hljs-comment">// 에러: "Test" (부모 클래스의 생성에 영향을 받지 않음)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ErrorLogger</span>.<span class="hljs-property">type</span>); <span class="hljs-comment">// "ErrorLogger"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ErrorLogger</span>.<span class="hljs-property">qualifiedType</span>); <span class="hljs-comment">// undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ErrorLogger</span>.<span class="hljs-property">id</span>); <span class="hljs-comment">// "Logger1"</span>

<span class="hljs-comment">// log()가 인스턴스 메서드가 아닌 정적 메서드이기 때문에 예외를 발생시킵니다.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(log.<span class="hljs-title function_">log</span>()); <span class="hljs-comment">// log.log is not a function</span>
</code></pre>
<ul>
<li>클래스 내의 정적 초기화 블록: 클래스가 초기화될 때 실행되는 블록, 기본적으로 정적 멤버를 초기화하는 "생성자"입니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {
  <span class="hljs-keyword">static</span> staticProperty1 = <span class="hljs-string">'속성 1'</span>;
  <span class="hljs-keyword">static</span> staticProperty2;
  <span class="hljs-keyword">static</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">staticProperty2</span> = <span class="hljs-string">'속성 2'</span>;
  }
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Test</span>.<span class="hljs-property">staticProperty1</span>); <span class="hljs-comment">// "Property 1"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Test</span>.<span class="hljs-property">staticProperty2</span>); <span class="hljs-comment">// "Property 2"</span>
</code></pre>
<ul>
<li>가져오기 어설션 (비표준, V8에서 구현됨): 가져온 항목의 유형을 확인하기 위해 사용할 수 있습니다. <code>import ... from ... assert ' type: </code>json<code> '</code>로 JSON을 직접 가져오고 구문 분석할 필요 없이 사용할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> json <span class="hljs-keyword">from</span> <span class="hljs-string">'./foo.json'</span> assert { <span class="hljs-attr">type</span>: <span class="hljs-string">'json'</span> };
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(json.<span class="hljs-property">answer</span>); <span class="hljs-comment">// 42</span>
</code></pre>
<ul>
<li>정규표현식 일치 인덱스: 정규표현식 일치 및 캡처 그룹의 시작 및 끝 인덱스를 가져올 수 있습니다. RegExp.exec(), String.match() 및 String.matchAll()에 대해 작동합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> matchObj = <span class="hljs-regexp">/(test+)(hello+)/</span>d.<span class="hljs-title function_">exec</span>(<span class="hljs-string">'start-testesthello-stop'</span>);

<span class="hljs-comment">// 이전:</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(matchObj?.<span class="hljs-property">index</span>);

<span class="hljs-comment">// 새로운:</span>
<span class="hljs-keyword">if</span> (matchObj) {
  <span class="hljs-comment">// 전체 일치 항목의 시작 및 끝 인덱스(이전에 시작만 있었음).</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(matchObj.<span class="hljs-property">indices</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// [9, 18]</span>

  <span class="hljs-comment">// 캡처 그룹의 시작 및 끝 인덱스.</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(matchObj.<span class="hljs-property">indices</span>[<span class="hljs-number">1</span>]); <span class="hljs-comment">// [9, 13]</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(matchObj.<span class="hljs-property">indices</span>[<span class="hljs-number">2</span>]); <span class="hljs-comment">// [13, 18]</span>
}
</code></pre>
<ul>
<li>Negative indexing (.at(-1)): 배열이나 문자열을 인덱싱할 때, at()을 사용하여 뒤에서부터 인덱싱할 수 있습니다. 값 가져오기(arr[arr.length - 1]와 동일)만 가능하며 값을 설정할 수는 없습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>].<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>)) <span class="hljs-comment">// 5</span>

<span class="hljs-keyword">const</span> array = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
array.<span class="hljs-title function_">at</span>(-<span class="hljs-number">1</span>) = <span class="hljs-number">3</span>; <span class="hljs-comment">// SyntaxError: Assigning to rvalue</span>
</code></pre>
<ul>
<li>hasOwn: 객체가 어떤 속성을 가지고 있는지 obj.hasOwnProperty()을 사용하는 대신 추천되는 새 방법입니다. 일부 특수한 경우에 더 잘 작동합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">'test'</span> };

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(obj, <span class="hljs-string">'name'</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(obj, <span class="hljs-string">'gender'</span>)); <span class="hljs-comment">// false</span>
</code></pre>
<ul>
<li>오류 원인: 이제 오류에 대한 선택적 원인을 지정할 수 있습니다. 이는 다시 throw할 때 원래 오류를 지정할 수 있게 합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-title function_">connectToDatabase</span>();
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'데이터베이스 연결에 실패했습니다.'</span>, { <span class="hljs-attr">cause</span>: err });
  }
} <span class="hljs-keyword">catch</span> (err) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">cause</span>); <span class="hljs-comment">// ReferenceError: connectToDatabase is not defined</span>
}
</code></pre>
<h2>미래 (이미 TypeScript 4.9에서 사용 가능)</h2>
<ul>
<li>Auto-Accessor: 속성을 자동으로 비공개로 만들고 get/set 접근자를 만듭니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  accessir <span class="hljs-attr">name</span>: string;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: string</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>) <span class="hljs-comment">// 'test'</span>
  }
}

<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'test'</span>);
</code></pre>
<h1>TypeScript</h1>
<h2>기초 (추후 소개를 위한 문맥)</h2>
<ul>
<li>제네릭: 다른 유형으로 유형을 전달합니다. 이를 통해 유형을 일반화 할 수 있지만 여전히 유형 안전성을 유지할 수 있습니다. 항상 <code>any</code> 또는 <code>unknown</code> 대신 이를 선호해주세요.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// WITHOUT:</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getFirstUnsafe</span>(<span class="hljs-params">list: any[]</span>): any {
  <span class="hljs-keyword">return</span> list[<span class="hljs-number">0</span>];
}

<span class="hljs-keyword">const</span> firstUnsafe = <span class="hljs-title function_">getFirstUnsafe</span>([<span class="hljs-string">'test'</span>]); <span class="hljs-comment">// typed as any</span>

<span class="hljs-comment">// WITH:</span>
<span class="hljs-keyword">function</span> getFirst&#x3C;<span class="hljs-title class_">Type</span>>(<span class="hljs-attr">list</span>: <span class="hljs-title class_">Type</span>[]): <span class="hljs-title class_">Type</span> {
  <span class="hljs-keyword">return</span> list[<span class="hljs-number">0</span>];
}

<span class="hljs-keyword">const</span> first = getFirst&#x3C;string>([<span class="hljs-string">'test'</span>]); <span class="hljs-comment">// typed as string</span>

<span class="hljs-comment">// In this case the parameter can even be dropped because it is inferred from the argument.</span>
<span class="hljs-keyword">const</span> firstInferred = <span class="hljs-title function_">getFirst</span>([<span class="hljs-string">'test'</span>]); <span class="hljs-comment">// typed as string</span>

<span class="hljs-comment">// The types accepted as generics can also be limited using `extends`. The Type is also usually shortened to T.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>&#x3C;T <span class="hljs-keyword">extends</span> string | number> {
  private <span class="hljs-attr">list</span>: T[] = [];

  <span class="hljs-title function_">get</span>(<span class="hljs-attr">key</span>: number): T {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[key];
  }

  <span class="hljs-title function_">push</span>(<span class="hljs-attr">value</span>: T): <span class="hljs-keyword">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(value);
  }
}

<span class="hljs-keyword">const</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&#x3C;string>();
list.<span class="hljs-title function_">push</span>(<span class="hljs-number">9</span>); <span class="hljs-comment">// Type error: Argument of type 'number' is not assignable to parameter of type 'string'.</span>
<span class="hljs-keyword">const</span> booleanList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&#x3C;boolean>(); <span class="hljs-comment">// Type error: Type 'boolean' does not satisfy the constraint 'string | number'.</span>
</code></pre>
<h2>과거 (아직도 유효한 이전 소개)</h2>
<ul>
<li>유틸리티 타입: TypeScript에는 많은 유틸리티 타입이 포함되어 있으며, 그 중 가장 유용한 몇 가지가 여기에서 설명되었습니다.</li>
</ul>
<pre><code class="hljs language-js">interface <span class="hljs-title class_">Test</span> {
  <span class="hljs-attr">name</span>: string;
  <span class="hljs-attr">age</span>: number;
}

<span class="hljs-comment">// Partial 유틸리티 타입은 모든 속성을 선택적으로 만듭니다.</span>
type <span class="hljs-title class_">TestPartial</span> = <span class="hljs-title class_">Partial</span>&#x3C;<span class="hljs-title class_">Test</span>>; <span class="hljs-comment">// typed as { name?: string | undefined; age?: number | undefined; }</span>
<span class="hljs-comment">// Required 유틸리티 타입은 반대로 동작합니다.</span>
type <span class="hljs-title class_">TestRequired</span> = <span class="hljs-title class_">Required</span>&#x3C;<span class="hljs-title class_">TestPartial</span>>; <span class="hljs-comment">// typed as { name: string; age: number; }</span>
<span class="hljs-comment">// Readonly 유틸리티 타입은 모든 속성을 읽기 전용으로 만듭니다.</span>
type <span class="hljs-title class_">TestReadonly</span> = <span class="hljs-title class_">Readonly</span>&#x3C;<span class="hljs-title class_">Test</span>>; <span class="hljs-comment">// typed as { readonly name: string; readonly age: string }</span>
<span class="hljs-comment">// Record 유틸리티 타입은 객체/맵/사전을 간단하게 정의할 수 있습니다. 가능한 경우에는 인덱스 시그니처보다 선호됩니다.</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">config</span>: <span class="hljs-title class_">Record</span>&#x3C;string, boolean> = { <span class="hljs-attr">option</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">anotherOption</span>: <span class="hljs-literal">true</span> };
<span class="hljs-comment">// Pick 유틸리티 타입은 지정된 속성만 가져옵니다.</span>
type <span class="hljs-title class_">TestLess</span> = <span class="hljs-title class_">Pick</span>&#x3C;<span class="hljs-title class_">Test</span>, <span class="hljs-string">'name'</span>>; <span class="hljs-comment">// typed as { name: string; }</span>
type <span class="hljs-title class_">TestBoth</span> = <span class="hljs-title class_">Pick</span>&#x3C;<span class="hljs-title class_">Test</span>, <span class="hljs-string">'name'</span> | <span class="hljs-string">'age'</span>>; <span class="hljs-comment">// typed as { name: string; age: string; }</span>
<span class="hljs-comment">// Omit 유틸리티 타입은 지정된 속성을 무시합니다.</span>
type <span class="hljs-title class_">TestFewer</span> = <span class="hljs-title class_">Omit</span>&#x3C;<span class="hljs-title class_">Test</span>, <span class="hljs-string">'name'</span>>; <span class="hljs-comment">// typed as { age: string; }</span>
type <span class="hljs-title class_">TestNone</span> = <span class="hljs-title class_">Omit</span>&#x3C;<span class="hljs-title class_">Test</span>, <span class="hljs-string">'name'</span> | <span class="hljs-string">'age'</span>>; <span class="hljs-comment">// typed as {}</span>
<span class="hljs-comment">// Parameters 유틸리티 타입은 함수 타입의 매개변수를 가져옵니다.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">doSmth</span>(<span class="hljs-params">value: string, anotherValue: number</span>): string {
  <span class="hljs-keyword">return</span> <span class="hljs-string">'test'</span>;
}
type <span class="hljs-title class_">Params</span> = <span class="hljs-title class_">Parameters</span>&#x3C;<span class="hljs-keyword">typeof</span> doSmth>; <span class="hljs-comment">// typed as [value: string, anotherValue: number]</span>
<span class="hljs-comment">// ReturnType 유틸리티 타입은 함수 타입의 반환 타입을 가져옵니다.</span>
type <span class="hljs-title class_">Return</span> = <span class="hljs-title class_">ReturnType</span>&#x3C;<span class="hljs-keyword">typeof</span> doSmth>; <span class="hljs-comment">// typed as string</span>

<span class="hljs-comment">// 이 외에도 많은 유틸리티 타입이 있으며, 그 중 일부는 아래에서 소개됩니다.</span>
</code></pre>
<ul>
<li>조건부 타입: 어떤 타입이 다른 타입과 일치/확장되면 그에 따라 타입을 조건부로 설정합니다. 이는 JavaScript의 조건부(삼항) 연산자와 비슷하게 해석될 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 배열인 경우에만 배열 타입을 추출하고, 그렇지 않으면 동일한 타입을 반환합니다.</span>
type <span class="hljs-title class_">Flatten</span>&#x3C;T> = T <span class="hljs-keyword">extends</span> any[] ? T[number] : T;

<span class="hljs-comment">// 요소 타입을 추출합니다.</span>
type <span class="hljs-title class_">Str</span> = <span class="hljs-title class_">Flatten</span>&#x3C;string[]>; <span class="hljs-comment">// string 타입으로 지정됨</span>

<span class="hljs-comment">// 타입을 그대로 유지합니다.</span>
type <span class="hljs-title class_">Num</span> = <span class="hljs-title class_">Flatten</span>&#x3C;number>; <span class="hljs-comment">// number 타입으로 지정됨</span>
</code></pre>
<ul>
<li>조건부 타입으로 추론: 모든 일반 타입이 소비자에 의해 명시적으로 지정되어야 하는 것은 아닙니다. 일부는 코드로부터 추론될 수도 있습니다. 추론된 타입을 기반으로 조건부 논리를 작성하려면 infer 키워드가 필요합니다. 이는 일시적인 추론된 타입 변수를 정의하는 방식입니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이전 예제를 기반으로 해서 더 깔끔하게 작성할 수 있습니다.</span>
type <span class="hljs-title class_">FlattenOld</span>&#x3C;T> = T <span class="hljs-keyword">extends</span> any[] ? T[number] : T;

<span class="hljs-comment">// 배열에서 직접 인덱싱하는 대신, 배열에서 항목(Item)의 타입을 추론할 수 있습니다.</span>
type <span class="hljs-title class_">Flatten</span>&#x3C;T> = T <span class="hljs-keyword">extends</span> (infer <span class="hljs-title class_">Item</span>)[] ? <span class="hljs-title class_">Item</span> : T;

<span class="hljs-comment">// 함수의 반환 타입을 가져오고, 그 외의 경우에는 undefined로 지정하는 타입을 작성할 수도 있습니다.</span>
type <span class="hljs-title class_">GetReturnType</span>&#x3C;<span class="hljs-title class_">Type</span>> = <span class="hljs-title class_">Type</span> <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: any[]) => infer <span class="hljs-title class_">Return</span> ? <span class="hljs-title class_">Return</span> : <span class="hljs-literal">undefined</span>;

type <span class="hljs-title class_">Num</span> = <span class="hljs-title class_">GetReturnType</span>&#x3C;<span class="hljs-function">() =></span> number>; <span class="hljs-comment">// number 타입으로 지정됨</span>

type <span class="hljs-title class_">Str</span> = <span class="hljs-title class_">GetReturnType</span>&#x3C;<span class="hljs-function">(<span class="hljs-params">x: string</span>) =></span> string>; <span class="hljs-comment">// string 타입으로 지정됨</span>

type <span class="hljs-title class_">Bools</span> = <span class="hljs-title class_">GetReturnType</span>&#x3C;<span class="hljs-function">(<span class="hljs-params">a: boolean, b: boolean</span>) =></span> <span class="hljs-keyword">void</span>>; <span class="hljs-comment">// undefined 타입으로 지정됨</span>
</code></pre>
<ul>
<li>튜플 Optional Elements와 Rest: 튜플에서 <code>?</code>를 사용하여 옵셔널 요소를 선언하고, 다른 타입을 기반으로 나머지 요소를 사용할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 튜플의 길이를 아직 알 수 없지만 적어도 한 개는 있는 경우, `?`를 사용하여 옵셔널 타입을 지정할 수 있습니다.</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">list</span>: [number, number?, boolean?] = [];
list[<span class="hljs-number">0</span>] <span class="hljs-comment">// number 타입으로 지정됩니다</span>
list[<span class="hljs-number">1</span>] <span class="hljs-comment">// number 또는 undefined 타입으로 지정됩니다</span>
list[<span class="hljs-number">2</span>] <span class="hljs-comment">// boolean 또는 undefined 타입으로 지정됩니다</span>
list[<span class="hljs-number">3</span>] <span class="hljs-comment">// Type error: 길이가 '3'인 '[number, (number | undefined)?, (boolean | undefined)?]' 형식의 튜플에는 '3' 인덱스 요소가 없습니다.</span>

<span class="hljs-comment">// 기존 타입을 기반으로 튜플을 사용할 수도 있습니다.</span>
<span class="hljs-comment">// 배열의 시작 부분에 패딩을 추가하려면 나머지 연산자 `...`를 사용할 수 있습니다.</span>
<span class="hljs-keyword">function</span> padStart&#x3C;T <span class="hljs-keyword">extends</span> any[]>(<span class="hljs-attr">arr</span>: T, <span class="hljs-attr">pad</span>: string): [string, ...T] {
  <span class="hljs-keyword">return</span> [pad, ...arr];
}

<span class="hljs-keyword">const</span> padded = <span class="hljs-title function_">padStart</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">'test'</span>); <span class="hljs-comment">// [string, number, number] 타입으로 지정됩니다</span>
</code></pre>
<ul>
<li>추상 클래스와 메소드: 클래스와 그 내부 메소드를 추상으로 선언하여 인스턴스화되지 않도록 할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js">abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
  abstract <span class="hljs-title function_">makeSound</span>(): <span class="hljs-keyword">void</span>;

  <span class="hljs-title function_">move</span>(): <span class="hljs-keyword">void</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'roaming the earth...'</span>);
  }
}

<span class="hljs-comment">// 추상 메소드는 확장 시 구현되어야 합니다.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {} <span class="hljs-comment">// 컴파일 오류: 추상 클래스 'Animal'로부터 상속된 추상 멤버 'makeSound'가 구현되지 않은 비-추상 클래스 'Cat'입니다.</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> {
  <span class="hljs-title function_">makeSound</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'woof'</span>);
  }
}

<span class="hljs-comment">// 추상 클래스는 (인터페이스처럼) 인스턴스화할 수 없으며, 추상 메소드는 호출할 수 없습니다.</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(); <span class="hljs-comment">// 컴파일 오류: 추상 클래스의 인스턴스를 생성할 수 없습니다.</span>

<span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>().<span class="hljs-title function_">makeSound</span>(); <span class="hljs-comment">// "woof"가 출력됩니다</span>
</code></pre>
<ul>
<li>생성자 서명: 클래스 선언 외부에서 생성자의 유형을 정의합니다. 대부분의 경우에 사용되지 않아야 하며, 추상 클래스 대신 사용할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js">interface <span class="hljs-title class_">MyInterface</span> {
  <span class="hljs-attr">name</span>: string;
}

interface <span class="hljs-title class_">ConstructsMyInterface</span> {
  <span class="hljs-title function_">new</span>(<span class="hljs-attr">name</span>: string): <span class="hljs-title class_">MyInterface</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> implements <span class="hljs-title class_">MyInterface</span> {
  <span class="hljs-attr">name</span>: string;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: string</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherTest</span> {
  <span class="hljs-attr">age</span>: number;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">makeObj</span>(<span class="hljs-params">n: ConstructsMyInterface</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">n</span>(<span class="hljs-string">'hello!'</span>);
}

<span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">makeObj</span>(<span class="hljs-title class_">Test</span>); <span class="hljs-comment">// Test로 타입 지정됨</span>
<span class="hljs-keyword">const</span> anotherObj = <span class="hljs-title function_">makeObj</span>(<span class="hljs-title class_">AnotherTest</span>); <span class="hljs-comment">// 타입 오류: 'AnotherTest'의 유형은 'ConstructsMyInterface'의 매개변수에 할당할 수 없습니다.</span>
</code></pre>
<ul>
<li>ConstructorParameters 유틸리티 타입: TypeScript 도우미 함수로, 생성자 타입에서 생성자 매개변수를 가져옵니다 (클래스에서 가져오는 것이 아닙니다).</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// makeObj 함수에 생성자 인수를 얻고 싶다면?</span>
interface <span class="hljs-title class_">MyInterface</span> {
  <span class="hljs-attr">name</span>: string;
}

interface <span class="hljs-title class_">ConstructsMyInterface</span> {
  <span class="hljs-title function_">new</span>(<span class="hljs-attr">name</span>: string): <span class="hljs-title class_">MyInterface</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> implements <span class="hljs-title class_">MyInterface</span> {
  <span class="hljs-attr">name</span>: string;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: string</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">makeObj</span>(<span class="hljs-params">test: ConstructsMyInterface, ...args: ConstructorParameters&#x3C;ConstructsMyInterface></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">test</span>(...args);
}

<span class="hljs-title function_">makeObj</span>(<span class="hljs-title class_">Test</span>); <span class="hljs-comment">// 타입 오류: 2개의 매개변수가 필요하지만 1개만 전달되었습니다.</span>
<span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">makeObj</span>(<span class="hljs-title class_">Test</span>, <span class="hljs-string">'test'</span>); <span class="hljs-comment">// Test로 타입 지정됨</span>
</code></pre>
<h2>TypeScript 4.0</h2>
<ul>
<li>Variadic Tuple Types: 튜플에서의 나머지 요소는 이제 제네릭할 수 있습니다. 여러 개의 나머지 요소를 사용하는 것도 허용됩니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 만약 길이와 타입이 정의되지 않은 두 튜플을 결합하는 함수가 있다면 어떨까요? 반환 타입을 어떻게 정의할 수 있을까요?</span>

<span class="hljs-comment">// 이전:</span>
<span class="hljs-comment">// 우리는 몇 가지 오버로드를 작성할 수 있었습니다.</span>
declare <span class="hljs-keyword">function</span> <span class="hljs-title function_">concat</span>(<span class="hljs-params">arr1: [], arr2: []</span>): [];
declare <span class="hljs-keyword">function</span> concat&#x3C;A>(<span class="hljs-attr">arr1</span>: [A], <span class="hljs-attr">arr2</span>: []): [A];
declare <span class="hljs-keyword">function</span> concat&#x3C;A, B>(<span class="hljs-attr">arr1</span>: [A], <span class="hljs-attr">arr2</span>: [B]): [A, B];
<span class="hljs-comment">// 이하 생략</span>

<span class="hljs-comment">// 대신에 타입을 결합할 수 있습니다.</span>
declare <span class="hljs-keyword">function</span> concatBetter&#x3C;T, U>(<span class="hljs-attr">arr1</span>: T[], <span class="hljs-attr">arr2</span>: U[]): (T | U)[];
<span class="hljs-comment">// 그러나 이것은 (T | U)[]로 타입이 지정됩니다.</span>

<span class="hljs-comment">// 새로운 기능:</span>
<span class="hljs-comment">// 가변 길이 튜플 타입을 사용하면 쉽게 정의할 수 있고 길이 정보를 유지할 수 있습니다.</span>
declare <span class="hljs-keyword">function</span> concatNew&#x3C;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Arr</span>, U <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Arr</span>>(<span class="hljs-attr">arr1</span>: T, <span class="hljs-attr">arr2</span>: U): [...T, ...U];

<span class="hljs-keyword">const</span> tuple = <span class="hljs-title function_">concatNew</span>([<span class="hljs-number">23</span>, <span class="hljs-string">'hey'</span>, <span class="hljs-literal">false</span>] <span class="hljs-keyword">as</span> [number, string, boolean], [<span class="hljs-number">5</span>, <span class="hljs-number">99</span>, <span class="hljs-number">20</span>] <span class="hljs-keyword">as</span> [number, number, number]);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tuple[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 23</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">element</span>: number = tuple[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 타입 오류: 타입 'string'을 'number'에 할당할 수 없습니다.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tuple[<span class="hljs-number">6</span>]); <span class="hljs-comment">// 타입 오류: 길이 '6'인 튜플 타입 '[23, "hey", false, 5, 99, 20]'에는 인덱스 '6'에 요소가 없습니다.</span>
</code></pre>
<ul>
<li>Labeled Tuple Elements: 튜플 요소는 이제 [start: number, end: number]와 같이 이름을 지정할 수 있습니다. 요소 중 하나가 이름이 지정되면 모두 이름이 있어야 합니다.</li>
</ul>
<p>혹시 클래스 생성자에서 속성이 설정될 때 속성의 타입을 자동으로 추론할 수 있어서 더 이상 수동으로 설정할 필요가 없습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-comment">// 생성자에서 할당될 때 타입을 설정할 필요가 없습니다.</span>
  name;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: string</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// 문자열로 타입이 지정됨</span>
  }
}
</code></pre>
<ul>
<li>JSDoc @deprecated 지원: JSDoc/TSDoc의 @deprecated 태그가 TypeScript에서 인식됩니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">/** <span class="hljs-doctag">@deprecated</span> 메시지 */</span>
type <span class="hljs-title class_">Test</span> = string;

<span class="hljs-keyword">const</span> <span class="hljs-attr">test</span>: <span class="hljs-title class_">Test</span> = <span class="hljs-string">'dfadsf'</span>; <span class="hljs-comment">// 타입 오류: '테스트'가 사용되지 않습니다.</span>
</code></pre>
<h2>TypeScript 4.1</h2>
<ul>
<li>템플릿 리터럴 타입: 리터럴 타입을 정의할 때, '$'를 이용하여 템플릿을 활용할 수 있습니다. 이를 통해 여러 개의 문자열 리터럴을 조합하는 등 복잡한 문자열 타입을 만들 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js">type <span class="hljs-title class_">VerticalDirection</span> = <span class="hljs-string">'top'</span> | <span class="hljs-string">'bottom'</span>;
type <span class="hljs-title class_">HorizontalDirection</span> = <span class="hljs-string">'left'</span> | <span class="hljs-string">'right'</span>;
type <span class="hljs-title class_">Direction</span> = <span class="hljs-string">`<span class="hljs-subst">${VerticalDirection}</span> <span class="hljs-subst">${HorizontalDirection}</span>`</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">dir1</span>: <span class="hljs-title class_">Direction</span> = <span class="hljs-string">'top left'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">dir2</span>: <span class="hljs-title class_">Direction</span> = <span class="hljs-string">'left'</span>; <span class="hljs-comment">// 타입 오류: '"left"'은(는) '"top left" | "top right" | "bottom left" | "bottom right"' 타입에 할당할 수 없습니다.</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">dir3</span>: <span class="hljs-title class_">Direction</span> = <span class="hljs-string">'left top'</span>; <span class="hljs-comment">// 타입 오류: '"left top"'은(는) '"top left" | "top right" | "bottom left" | "bottom right"' 타입에 할당할 수 없습니다.</span>

<span class="hljs-comment">// 이는 제네릭 및 새로운 유틸리티 타입과도 결합할 수 있습니다.</span>
declare <span class="hljs-keyword">function</span> makeId&#x3C;T <span class="hljs-keyword">extends</span> string, U <span class="hljs-keyword">extends</span> string>(<span class="hljs-attr">first</span>: T, <span class="hljs-attr">second</span>: U): <span class="hljs-string">`<span class="hljs-subst">${Capitalize&#x3C;T>}</span>-<span class="hljs-subst">${Lowercase&#x3C;U>}</span>`</span>;
</code></pre>
<ul>
<li>키 다시 매핑하기: 매핑된 타입을 다시 정의하여 그 값들을 사용할 수 있습니다. [K in keyof T as NewKeyType]: T[K].</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 예를 들어, 객체를 다시 포맷하되 그 ID 앞에 밑줄을 추가하고 싶다고 가정해 봅시다.</span>
<span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">value1</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">value2</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">value3</span>: <span class="hljs-number">3</span> };
<span class="hljs-keyword">const</span> <span class="hljs-attr">newObj</span>: { [<span class="hljs-title class_">Property</span> <span class="hljs-keyword">in</span> keyof <span class="hljs-keyword">typeof</span> obj <span class="hljs-keyword">as</span> <span class="hljs-string">`_<span class="hljs-subst">${Property}</span>`</span>]: number }; <span class="hljs-comment">// { _value1: number; _value2: number; value3: number; }로 타입이 지정됩니다.</span>
</code></pre>
<ul>
<li>재귀 조건부 타입: 조건부 타입을 해당 정의 내부에서 사용합니다. 이를 통해 무한히 중첩된 값을 조건부적으로 언패킹하는 타입을 생성할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js">type <span class="hljs-title class_">Awaited</span>&#x3C;T> = T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PromiseLike</span>&#x3C;infer U> ? <span class="hljs-title class_">Awaited</span>&#x3C;U> : T;

type <span class="hljs-variable constant_">P1</span> = <span class="hljs-title class_">Awaited</span>&#x3C;string>; <span class="hljs-comment">// string으로 타입이 지정됩니다.</span>
type <span class="hljs-variable constant_">P2</span> = <span class="hljs-title class_">Awaited</span>&#x3C;<span class="hljs-title class_">Promise</span>&#x3C;string>>; <span class="hljs-comment">// string으로 타입이 지정됩니다.</span>
type <span class="hljs-variable constant_">P3</span> = <span class="hljs-title class_">Awaited</span>&#x3C;<span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">Promise</span>&#x3C;string>>>; <span class="hljs-comment">// string으로 타입이 지정됩니다.</span>
</code></pre>
<ul>
<li>JSDOC @see 태그를 지원하는 편집기: 이제 편집기에서 JSDoc/TSDoc @see 변수/유형/링크 태그가 지원됩니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> originalValue = <span class="hljs-number">1</span>;
<span class="hljs-comment">/**
 * 다른 값의 복사본
 * <span class="hljs-doctag">@see</span> <span class="hljs-variable">originalValue</span>
 */</span>
<span class="hljs-keyword">const</span> value = originalValue;
</code></pre>
<ul>
<li>tsc --explainFiles: --explainFiles 옵션은 TypeScript CLI에서 컴파일에 사용된 파일과 그 이유를 설명해주는 데 사용될 수 있습니다. 이는 디버깅에 유용할 수 있습니다. 경고: 대규모 프로젝트나 복잡한 설정의 경우 많은 출력물이 생성됩니다. 대신 tsc --explainFiles | less 또는 비슷한 방법을 사용하십시오.</li>
</ul>
<pre><code class="hljs language-js">tsc --explainFiles

&#x3C;&#x3C;output
../../.<span class="hljs-property">asdf</span>/installs/nodejs/<span class="hljs-number">16.13</span><span class="hljs-number">.1</span>/.<span class="hljs-property">npm</span>/lib/node_modules/typescript/lib/lib.<span class="hljs-property">es5</span>.<span class="hljs-property">d</span>.<span class="hljs-property">ts</span>
  파일 <span class="hljs-string">'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'</span>에서 <span class="hljs-string">'es5'</span>로 참조되는 라이브러리
  파일 <span class="hljs-string">'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'</span>에서 <span class="hljs-string">'es5'</span>로 참조되는 라이브러리
../../.<span class="hljs-property">asdf</span>/installs/nodejs/<span class="hljs-number">16.13</span><span class="hljs-number">.1</span>/.<span class="hljs-property">npm</span>/lib/node_modules/typescript/lib/lib.<span class="hljs-property">es2015</span>.<span class="hljs-property">d</span>.<span class="hljs-property">ts</span>
  파일 <span class="hljs-string">'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'</span>에서 <span class="hljs-string">'es2015'</span>로 참조되는 라이브러리
  파일 <span class="hljs-string">'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'</span>에서 <span class="hljs-string">'es2015'</span>로 참조되는 라이브러리
../../.<span class="hljs-property">asdf</span>/installs/nodejs/<span class="hljs-number">16.13</span><span class="hljs-number">.1</span>/.<span class="hljs-property">npm</span>/lib/node_modules/typescript/lib/lib.<span class="hljs-property">es2016</span>.<span class="hljs-property">d</span>.<span class="hljs-property">ts</span>
  파일 <span class="hljs-string">'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'</span>에서 <span class="hljs-string">'es2016'</span>로 참조되는 라이브러리
  파일 <span class="hljs-string">'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'</span>에서 <span class="hljs-string">'es2016'</span>로 참조되는 라이브러리
...
output
</code></pre>
<ul>
<li>Destructured 변수는 명시적으로 사용되지 않음을 표시할 수 있습니다: 구조 분해할 때 밑줄을 사용하여 변수가 사용되지 않음을 표시할 수 있습니다. 이를 통해 TypeScript에서 "사용되지 않는 변수" 오류를 방지할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [_first, second] = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(second);

<span class="hljs-comment">// 심지어 더 짧게</span>
<span class="hljs-keyword">const</span> [_, value] = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);
</code></pre>
<h2>TypeScript 4.3</h2>
<ul>
<li>속성에 대한 별도의 쓰기 유형: set/get 접근자를 정의할 때, 쓰기/설정 형식이 읽기/가져오기 형식과 다를 수 있습니다. 이를 통해 동일한 값의 여러 형식을 수락하는 setter를 정의할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {
  private <span class="hljs-attr">_value</span>: number;

  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>(): number {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span>;
  }

  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">value: number | string</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'number'</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = value;
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_value</span> = <span class="hljs-built_in">parseInt</span>(value, <span class="hljs-number">10</span>);
  }
}
</code></pre>
<ul>
<li>override: 상속된 클래스 메서드를 명확하게 오버라이드로 표시하기 위해 override를 사용하세요. 부모 클래스가 변경되면 TypeScript에서 부모 메서드가 더 이상 존재하지 않음을 알려줄 수 있습니다. 이를 통해 더 안전한 복잡한 상속 패턴을 구현할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> {
  <span class="hljs-title function_">getName</span>(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'name'</span>;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewParent</span> {
  <span class="hljs-title function_">getFirstName</span>(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'name'</span>;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Parent</span> {
  override <span class="hljs-title function_">getName</span>(): string {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'test'</span>;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">NewParent</span> {
  override <span class="hljs-title function_">getName</span>(): string { <span class="hljs-comment">// Type error: This member cannot have an 'override' modifier because it is not declared in the base class 'NewParent'.</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">'test'</span>;
  }
}
</code></pre>
<ul>
<li>static Index Signatures: 클래스에서 정적 속성을 사용할 때, 정적 [propName: string]: string을 사용하여 색인 서명을 설정할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이전 코드:</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {}

<span class="hljs-title class_">Test</span>.<span class="hljs-property">test</span> = <span class="hljs-string">''</span>; <span class="hljs-comment">// 타입 오류: 'test' 속성을 'Test' 형식에서 찾을 수 없습니다.</span>

<span class="hljs-comment">// 새로운 코드:</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewTest</span> {
  <span class="hljs-keyword">static</span> [<span class="hljs-attr">key</span>: string]: string;
}

<span class="hljs-title class_">NewTest</span>.<span class="hljs-property">test</span> = <span class="hljs-string">''</span>;
</code></pre>
<ul>
<li>JSDOC @link 태그를 위한 편집기 지원: JSDoc/TSDoc의 '@link 변수/타입/링크' 인라인 태그가 이제 지원되며 편집기에서 표시되고 해결됩니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> originalValue = <span class="hljs-number">1</span>;
<span class="hljs-comment">/**
 * {<span class="hljs-doctag">@link</span> originalValue}의 복사본
 */</span>
<span class="hljs-keyword">const</span> value = originalValue;
</code></pre>
<h2>TypeScript 4.4</h2>
<ul>
<li>정확한 선택적 속성 유형 (--exactOptionalPropertyTypes): 컴파일러 플래그 --exactOptionalPropertyTypes (또는 tsconfig.json에)를 사용하면, 암시적으로 undefined를 허용하는 속성에 대해 undefined로 할당하는 것이 허용되지 않습니다 (예: property?: string). 대신, property: string | undefined와 같이 명시적으로 undefined를 허용해야 합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {
  name?: string;
  <span class="hljs-attr">age</span>: number | <span class="hljs-literal">undefined</span>;
}

<span class="hljs-keyword">const</span> test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();
test.<span class="hljs-property">name</span> = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 타입 오류: 'exactOptionalPropertyTypes: true'를 사용하여 'undefined' 타입을 'string'에 할당할 수 없습니다. 대상의 유형에 'undefined'를 추가하는 것을 고려해보세요.</span>
test.<span class="hljs-property">age</span> = <span class="hljs-literal">undefined</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test.<span class="hljs-property">age</span>); <span class="hljs-comment">// undefined</span>
</code></pre>
<h2>TypeScript 4.5</h2>
<ul>
<li>Awaited<code> 유형 및 Promise 개선: 새로운 Awaited</code> 유틸리티 유형은 무한히 중첩된 Promises에서 값 유형을 추출합니다 (값에 대해 await이 하는 것과 같이). 이는 또한 Promise.all()에 대한 유형 추론을 개선했습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 제네릭 대기값을 가지고 싶다고 가정해 봅시다.</span>
<span class="hljs-comment">// 이러한 경우 Awaited 유틸리티 타입을 사용할 수 있습니다 (소스 코드는 이전 예제의 일부였습니다).</span>
<span class="hljs-comment">// 따라서 무한하게 중첩된 Promises가 모두 값으로 해결됩니다.</span>
type <span class="hljs-variable constant_">P1</span> = <span class="hljs-title class_">Awaited</span>&#x3C;string>; <span class="hljs-comment">// 문자열로 타입 지정</span>
type <span class="hljs-variable constant_">P2</span> = <span class="hljs-title class_">Awaited</span>&#x3C;<span class="hljs-title class_">Promise</span>&#x3C;string>>; <span class="hljs-comment">// 문자열로 타입 지정</span>
type <span class="hljs-variable constant_">P3</span> = <span class="hljs-title class_">Awaited</span>&#x3C;<span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">Promise</span>&#x3C;string>>>; <span class="hljs-comment">// 문자열로 타입 지정</span>
</code></pre>
<ul>
<li>Import 이름에 대한 유형 수식어: 일반 (import type 아닌) import 문 안에서 type 키워드를 사용하여 해당 값이 유형 컴파일을 위해만 가져와야 함을 신호로 삼을 수 있습니다 (컴파일 후에 제거할 수 있습니다).</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이전:</span>
<span class="hljs-comment">// 유형을 가져오는 가장 좋은 방법은 `import type` 키워드를 사용하여 컴파일 이후에 실제로 가져오지 않도록 하는 것입니다.</span>
<span class="hljs-keyword">import</span> { something } <span class="hljs-keyword">from</span> <span class="hljs-string">'./file'</span>;
<span class="hljs-keyword">import</span> type { <span class="hljs-title class_">SomeType</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./file'</span>;
<span class="hljs-comment">// 이 파일에 대해 두 개의 import 문이 필요했습니다.</span>

<span class="hljs-comment">// 새로운:</span>
<span class="hljs-comment">// 이제 이를 하나의 문으로 결합할 수 있습니다.</span>
<span class="hljs-keyword">import</span> { something, type <span class="hljs-title class_">SomeType</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./file'</span>;
</code></pre>
<ul>
<li>Const 어순: 상수를 정의할 때 const 키워드를 사용하여 이를 리터럴 타입으로 정확하게 지정할 수 있습니다. 이는 다양한 용례가 있으며 정확한 유형 정의가 쉬워집니다. 또한 상수 객체와 배열은 읽기 전용이 되어 상수 객체의 변이를 방지합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이전:</span>
<span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">name</span>: <span class="hljs-string">'foo'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">toggle</span>: <span class="hljs-literal">false</span> }; <span class="hljs-comment">// { name: string; value: number; toggle: boolean; }으로 타입 지정됨</span>
<span class="hljs-comment">// 일반적으로 타입이 지정되어 있으므로 어느 값이든 할당 가능합니다.</span>
obj.<span class="hljs-property">name</span> = <span class="hljs-string">'bar'</span>;

<span class="hljs-keyword">const</span> tuple = [<span class="hljs-string">'name'</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>]; <span class="hljs-comment">// (string | number | boolean)[]으로 타입 지정됨</span>
<span class="hljs-comment">// 타입으로 길이와 정확한 형식을 결정할 수 없습니다. 어떤 값이든 어디에든 할당할 수 있습니다.</span>
tuple[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
tuple[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>;

<span class="hljs-comment">// 새로운 방식:</span>
<span class="hljs-keyword">const</span> objNew = { <span class="hljs-attr">name</span>: <span class="hljs-string">'foo'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">9</span>, <span class="hljs-attr">toggle</span>: <span class="hljs-literal">false</span> } <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// { readonly name: "foo"; readonly value: 9; readonly toggle: false; }으로 타입 지정됨</span>
<span class="hljs-comment">// 값을 할당할 수 없습니다 ("foo"(그리고 readonly로 정의되었기 때문).</span>
objNew.<span class="hljs-property">name</span> = <span class="hljs-string">'bar'</span>; <span class="hljs-comment">// 타입 에러: 'name'에 할당할 수 없습니다. 읽기 전용 속성입니다.</span>

<span class="hljs-keyword">const</span> tupleNew = [<span class="hljs-string">'name'</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">true</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// readonly ["name", 4, true]으로 타입 지정됨</span>
<span class="hljs-comment">// 이제 길이와 정확한 형식이 정의되어 있고, 값을 할당할 수 없습니다 (리터럴로 정의되었으며 readonly).</span>
tupleNew[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 타입 에러: '0'에 할당할 수 없습니다. 읽기 전용 속성입니다.</span>
tupleNew[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 타입 에러: 'readonly["name", 4, true]'에 있는 인덱스 서명에는 읽기만 허용됩니다.</span>
</code></pre>
<ul>
<li>클래스 내의 메서드에 대한 코드 조각 완성: 클래스가 메서드 타입을 상속하면 편집기에서 코드 조각으로 제안됩니다.</li>
</ul>
<h2>TypeScript 4.6</h2>
<ul>
<li>인덱스된 액세스 추론 개선: 키로 직접 타입을 색인화할 때, 이제 같은 객체에 있는 경우 타입이 더 정확해집니다. 현대적인 TypeScript로 어떤 것이 가능한지 보여주는 좋은 예시입니다.</li>
</ul>
<pre><code class="hljs language-js">interface <span class="hljs-title class_">AllowedTypes</span> {
  <span class="hljs-string">'number'</span>: number;
  <span class="hljs-string">'string'</span>: string;
  <span class="hljs-string">'boolean'</span>: boolean;
}

<span class="hljs-comment">// Record는 허용된 타입의 종류와 값 타입을 지정합니다.</span>
type <span class="hljs-title class_">UnionRecord</span>&#x3C;<span class="hljs-title class_">AllowedKeys</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-title class_">AllowedTypes</span>> = { [<span class="hljs-title class_">Key</span> <span class="hljs-keyword">in</span> <span class="hljs-title class_">AllowedKeys</span>]:
{
  <span class="hljs-attr">kind</span>: <span class="hljs-title class_">Key</span>;
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">AllowedTypes</span>[<span class="hljs-title class_">Key</span>];
  <span class="hljs-attr">logValue</span>: <span class="hljs-function">(<span class="hljs-params">value: AllowedTypes[Key]</span>) =></span> <span class="hljs-keyword">void</span>;
}
}[<span class="hljs-title class_">AllowedKeys</span>];

<span class="hljs-comment">// 함수 logValue는 Record의 값만을 허용합니다.</span>
<span class="hljs-keyword">function</span> processRecord&#x3C;<span class="hljs-title class_">Key</span> <span class="hljs-keyword">extends</span> keyof <span class="hljs-title class_">AllowedTypes</span>>(<span class="hljs-attr">record</span>: <span class="hljs-title class_">UnionRecord</span>&#x3C;<span class="hljs-title class_">Key</span>>) {
  record.<span class="hljs-title function_">logValue</span>(record.<span class="hljs-property">value</span>);
}

<span class="hljs-title function_">processRecord</span>({
  <span class="hljs-attr">kind</span>: <span class="hljs-string">'string'</span>,
  <span class="hljs-attr">value</span>: <span class="hljs-string">'hello!'</span>,

  <span class="hljs-comment">// 값이 암묵적으로 string | number | boolean 타입을 가졌던 것이</span>
  <span class="hljs-comment">// 이제 올바르게 오직 string으로 추론됩니다.</span>
  <span class="hljs-attr">logValue</span>: <span class="hljs-function"><span class="hljs-params">value</span> =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-title function_">toUpperCase</span>());
  }
});
</code></pre>
<ul>
<li>TypeScript 추적 분석기 (--generateTrace): --generateTrace '출력 폴더' 옵션을 사용하여 TypeScript CLI가 타입 검사 및 컴파일 프로세스에 대한 자세한 내용을 포함한 파일을 생성할 수 있습니다. 이는 복잡한 타입을 최적화하는 데 도움이 될 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js">tsc --generateTrace trace

cat trace/trace.<span class="hljs-property">json</span>
&#x3C;&#x3C;출력
[
{<span class="hljs-string">"name"</span>:<span class="hljs-string">"process_name"</span>,<span class="hljs-string">"args"</span>:{<span class="hljs-string">"name"</span>:<span class="hljs-string">"tsc"</span>},<span class="hljs-string">"cat"</span>:<span class="hljs-string">"__metadata"</span>,<span class="hljs-string">"ph"</span>:<span class="hljs-string">"M"</span>,<span class="hljs-string">"ts"</span>:...,<span class="hljs-string">"pid"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"tid"</span>:<span class="hljs-number">1</span>},
{<span class="hljs-string">"name"</span>:<span class="hljs-string">"thread_name"</span>,<span class="hljs-string">"args"</span>:{<span class="hljs-string">"name"</span>:<span class="hljs-string">"Main"</span>},<span class="hljs-string">"cat"</span>:<span class="hljs-string">"__metadata"</span>,<span class="hljs-string">"ph"</span>:<span class="hljs-string">"M"</span>,<span class="hljs-string">"ts"</span>:...,<span class="hljs-string">"pid"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"tid"</span>:<span class="hljs-number">1</span>},
{<span class="hljs-string">"name"</span>:<span class="hljs-string">"TracingStartedInBrowser"</span>,<span class="hljs-string">"cat"</span>:<span class="hljs-string">"disabled-by-default-devtools.timeline"</span>,<span class="hljs-string">"ph"</span>:<span class="hljs-string">"M"</span>,<span class="hljs-string">"ts"</span>:...,<span class="hljs-string">"pid"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"tid"</span>:<span class="hljs-number">1</span>},
{<span class="hljs-string">"pid"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"tid"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"ph"</span>:<span class="hljs-string">"B"</span>,<span class="hljs-string">"cat"</span>:<span class="hljs-string">"program"</span>,<span class="hljs-string">"ts"</span>:...,<span class="hljs-string">"name"</span>:<span class="hljs-string">"createProgram"</span>,<span class="hljs-string">"args"</span>:{<span class="hljs-string">"configFilePath"</span>:<span class="hljs-string">"/..."</span>,<span class="hljs-string">"rootDir"</span>:<span class="hljs-string">"/..."</span>},
{<span class="hljs-string">"pid"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"tid"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"ph"</span>:<span class="hljs-string">"B"</span>,<span class="hljs-string">"cat"</span>:<span class="hljs-string">"parse"</span>,<span class="hljs-string">"ts"</span>:...,<span class="hljs-string">"name"</span>:<span class="hljs-string">"createSourceFile"</span>,<span class="hljs-string">"args"</span>:{<span class="hljs-string">"path"</span>:<span class="hljs-string">"/..."</span>},
{<span class="hljs-string">"pid"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"tid"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"ph"</span>:<span class="hljs-string">"E"</span>,<span class="hljs-string">"cat"</span>:<span class="hljs-string">"parse"</span>,<span class="hljs-string">"ts"</span>:...,<span class="hljs-string">"name"</span>:<span class="hljs-string">"createSourceFile"</span>,<span class="hljs-string">"args"</span>:{<span class="hljs-string">"path"</span>:<span class="hljs-string">"/..."</span>},
{<span class="hljs-string">"pid"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"tid"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"ph"</span>:<span class="hljs-string">"X"</span>,<span class="hljs-string">"cat"</span>:<span class="hljs-string">"program"</span>,<span class="hljs-string">"ts"</span>:...,<span class="hljs-string">"name"</span>:<span class="hljs-string">"resolveModuleNamesWorker"</span>,<span class="hljs-string">"dur"</span>:...,<span class="hljs-string">"args"</span>:{<span class="hljs-string">"containingFileName"</span>:<span class="hljs-string">"/..."</span>},
...
출력

cat trace/types.<span class="hljs-property">json</span>
&#x3C;&#x3C;출력
[{<span class="hljs-string">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"intrinsicName"</span>:<span class="hljs-string">"any"</span>,<span class="hljs-string">"recursionId"</span>:<span class="hljs-number">0</span>,<span class="hljs-string">"flags"</span>:[<span class="hljs-string">"..."</span>]},
{<span class="hljs-string">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-string">"intrinsicName"</span>:<span class="hljs-string">"any"</span>,<span class="hljs-string">"recursionId"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"flags"</span>:[<span class="hljs-string">"..."</span>]},
{<span class="hljs-string">"id"</span>:<span class="hljs-number">3</span>,<span class="hljs-string">"intrinsicName"</span>:<span class="hljs-string">"any"</span>,<span class="hljs-string">"recursionId"</span>:<span class="hljs-number">2</span>,<span class="hljs-string">"flags"</span>:[<span class="hljs-string">"..."</span>]},
{<span class="hljs-string">"id"</span>:<span class="hljs-number">4</span>,<span class="hljs-string">"intrinsicName"</span>:<span class="hljs-string">"error"</span>,<span class="hljs-string">"recursionId"</span>:<span class="hljs-number">3</span>,<span class="hljs-string">"flags"</span>:[<span class="hljs-string">"..."</span>]},
{<span class="hljs-string">"id"</span>:<span class="hljs-number">5</span>,<span class="hljs-string">"intrinsicName"</span>:<span class="hljs-string">"unresolved"</span>,<span class="hljs-string">"recursionId"</span>:<span class="hljs-number">4</span>,<span class="hljs-string">"flags"</span>:[<span class="hljs-string">"..."</span>]},
{<span class="hljs-string">"id"</span>:<span class="hljs-number">6</span>,<span class="hljs-string">"intrinsicName"</span>:<span class="hljs-string">"any"</span>,<span class="hljs-string">"recursionId"</span>:<span class="hljs-number">5</span>,<span class="hljs-string">"flags"</span>:[<span class="hljs-string">"..."</span>]},
{<span class="hljs-string">"id"</span>:<span class="hljs-number">7</span>,<span class="hljs-string">"intrinsicName"</span>:<span class="hljs-string">"intrinsic"</span>,<span class="hljs-string">"recursionId"</span>:<span class="hljs-number">6</span>,<span class="hljs-string">"flags"</span>:[<span class="hljs-string">"..."</span>]},
{<span class="hljs-string">"id"</span>:<span class="hljs-number">8</span>,<span class="hljs-string">"intrinsicName"</span>:<span class="hljs-string">"unknown"</span>,<span class="hljs-string">"recursionId"</span>:<span class="hljs-number">7</span>,<span class="hljs-string">"flags"</span>:[<span class="hljs-string">"..."</span>]},
{<span class="hljs-string">"id"</span>:<span class="hljs-number">9</span>,<span class="hljs-string">"intrinsicName"</span>:<span class="hljs-string">"unknown"</span>,<span class="hljs-string">"recursionId"</span>:<span class="hljs-number">8</span>,<span class="hljs-string">"flags"</span>:[<span class="hljs-string">"..."</span>]},
{<span class="hljs-string">"id"</span>:<span class="hljs-number">10</span>,<span class="hljs-string">"intrinsicName"</span>:<span class="hljs-string">"undefined"</span>,<span class="hljs-string">"recursionId"</span>:<span class="hljs-number">9</span>,<span class="hljs-string">"flags"</span>:[<span class="hljs-string">"..."</span>]},
{<span class="hljs-string">"id"</span>:<span class="hljs-number">11</span>,<span class="hljs-string">"intrinsicName"</span>:<span class="hljs-string">"undefined"</span>,<span class="hljs-string">"recursionId"</span>:<span class="hljs-number">10</span>,<span class="hljs-string">"flags"</span>:[<span class="hljs-string">"..."</span>]},
{<span class="hljs-string">"id"</span>:<span class="hljs-number">12</span>,<span class="hljs-string">"intrinsicName"</span>:<span class="hljs-string">"null"</span>,<span class="hljs-string">"recursionId"</span>:<span class="hljs-number">11</span>,<span class="hljs-string">"flags"</span>:[<span class="hljs-string">"..."</span>]},
{<span class="hljs-string">"id"</span>:<span class="hljs-number">13</span>,<span class="hljs-string">"intrinsicName"</span>:<span class="hljs-string">"string"</span>,<span class="hljs-string">"recursionId"</span>:<span class="hljs-number">12</span>,<span class="hljs-string">"flags"</span>:[<span class="hljs-string">"..."</span>]},
...
출력
</code></pre>
<h2>TypeScript 4.7</h2>
<ul>
<li>Node.js에서 ECMAScript 모듈 지원: CommonJS 대신 ES 모듈을 사용할 때, TypeScript가 이제 default를 지정할 수 있습니다. tsconfig.json에서 지정하세요.</li>
</ul>
<pre><code class="hljs language-js">...
<span class="hljs-string">"compilerOptions"</span>: [
  ...
  <span class="hljs-string">"module"</span>: <span class="hljs-string">"es2020"</span>
]
...
</code></pre>
<ul>
<li>package.json의 type: package.json의 type 필드를 "module"로 설정할 수 있습니다. 이것은 Node.js와 ES 모듈을 사용하기 위해 필요합니다. 대부분의 경우에 TypeScript에 충분하며 위의 컴파일러 옵션이 필요하지 않습니다.</li>
</ul>
<pre><code class="hljs language-js">...
<span class="hljs-string">"type"</span>: <span class="hljs-string">"module"</span>
...
</code></pre>
<ul>
<li>인스턴스화 표현식: 인스턴스화 표현식을 사용하면 값을 참조할 때 유형 매개변수를 지정할 수 있습니다. 이를 통해 래퍼를 생성하지 않고 일반적인 유형을 좁힐 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span>&#x3C;T> {
  private <span class="hljs-attr">list</span>: T[] = [];

  <span class="hljs-title function_">get</span>(<span class="hljs-attr">key</span>: number): T {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[key];
  }

  <span class="hljs-title function_">push</span>(<span class="hljs-attr">value</span>: T): <span class="hljs-keyword">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(value);
  }
}

<span class="hljs-keyword">function</span> makeList&#x3C;T>(<span class="hljs-attr">items</span>: T[]): <span class="hljs-title class_">List</span>&#x3C;T> {
  <span class="hljs-keyword">const</span> list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&#x3C;T>();
  items.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =></span> list.<span class="hljs-title function_">push</span>(item));
  <span class="hljs-keyword">return</span> list;
}

<span class="hljs-comment">// 특정 값만 허용하는 목록을 만드는 함수가 필요한 경우를 가정해 봅시다.</span>
<span class="hljs-comment">// 이전:</span>
<span class="hljs-comment">// 직접 래퍼 함수를 정의하고 인수를 전달해야 했습니다.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">makeStringList</span>(<span class="hljs-params">text: string[]</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">makeList</span>(text);
}

<span class="hljs-comment">// 새로운 방법:</span>
<span class="hljs-comment">// 인스턴스화 표현식을 사용하면 훨씬 쉽습니다.</span>
<span class="hljs-keyword">const</span> makeNumberList = makeList&#x3C;number>;
</code></pre>
<ul>
<li>추론된 유형 변수에 대한 extend 제한: 조건부 유형에서 유형 변수를 추론할 때, extends를 사용하여 직접 좁히거나 제한할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 배열의 첫 번째 요소가 문자열인 경우에만 해당 요소를 가져오는 유형을 작성하려고 한다고 가정해 봅시다.</span>
<span class="hljs-comment">// 이를 위해 조건부 유형을 사용할 수 있습니다.</span>

<span class="hljs-comment">// 이전:</span>
type <span class="hljs-title class_">FirstIfStringOld</span>&#x3C;T> =
  T <span class="hljs-keyword">extends</span> [infer S, ...unknown[]]
    ? S <span class="hljs-keyword">extends</span> string ? S : never
    : never;

<span class="hljs-comment">// 그러나 이 방법은 두 개의 중첩된 조건부 유형이 필요합니다. 이를 하나의 유형으로도 할 수 있습니다.</span>
type <span class="hljs-title class_">FirstIfString</span>&#x3C;T> =
  T <span class="hljs-keyword">extends</span> [string, ...unknown[]]
    <span class="hljs-comment">// `T`에서 첫 번째 유형을 가져옵니다.</span>
    ? T[<span class="hljs-number">0</span>]
    : never;

<span class="hljs-comment">// 이것도 여전히 최적화되지 않은 상태이며 올바른 유형을 위해 배열을 인덱싱해야 합니다.</span>

<span class="hljs-comment">// 새로운 방식:</span>
<span class="hljs-comment">// 추론된 유형 변수에 extends 제약 조건을 사용하여 이를 더 간단하게 선언할 수 있습니다.</span>
type <span class="hljs-title class_">FirstIfStringNew</span>&#x3C;T> =
  T <span class="hljs-keyword">extends</span> [infer S <span class="hljs-keyword">extends</span> string, ...unknown[]]
    ? S
    : never;
<span class="hljs-comment">// 유형을 알아내는 방식은 이전과 동일하지만 더 깔끔한 구문입니다.</span>

type A = <span class="hljs-title class_">FirstIfStringNew</span>&#x3C;[string, number, number]>; <span class="hljs-comment">// string으로 유형 지정</span>
type B = <span class="hljs-title class_">FirstIfStringNew</span>&#x3C;[<span class="hljs-string">"hello"</span>, number, number]>; <span class="hljs-comment">// "hello"로 유형 지정</span>
type C = <span class="hljs-title class_">FirstIfStringNew</span>&#x3C;[<span class="hljs-string">"hello"</span> | <span class="hljs-string">"world"</span>, boolean]>; <span class="hljs-comment">// "hello" 또는 "world"로 유형 지정</span>
type D = <span class="hljs-title class_">FirstIfStringNew</span>&#x3C;[boolean, number, string]>; <span class="hljs-comment">// never로 유형 지정</span>
</code></pre>
<ul>
<li>유형 매개변수를 위한 선택적 분산 주석: 제네릭은 "일치하는지" 확인할 때 다른 동작을 가질 수 있습니다. 예를 들어, 상속을 허용할 경우 getters 및 setters에 대해 반대로 반전됩니다. 이제 이를 명시적으로 지정할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 다른 인터페이스 / 클래스를 확장하는 인터페이스가 있다고 가정해 봅시다.</span>
interface <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">animalStuff</span>: any;
}

interface <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">dogStuff</span>: any;
}

<span class="hljs-comment">// 그리고 일반적인 "getter" 및 "setter"가 있습니다.</span>
type <span class="hljs-title class_">Getter</span>&#x3C;T> = <span class="hljs-function">() =></span> T;

type <span class="hljs-title class_">Setter</span>&#x3C;T> = <span class="hljs-function">(<span class="hljs-params">value: T</span>) =></span> <span class="hljs-keyword">void</span>;

<span class="hljs-comment">// Getter&#x3C;T1>과 Getter&#x3C;T2> 또는 Setter&#x3C;T1>과 Setter&#x3C;T2>가 일치하는지 확인하려면 분산에 따라 달라집니다.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useAnimalGetter</span>(<span class="hljs-params">getter: Getter&#x3C;Animal></span>) {
  <span class="hljs-title function_">getter</span>();
}

<span class="hljs-comment">// 이제 함수에 Getter를 전달할 수 있습니다.</span>
<span class="hljs-title function_">useAnimalGetter</span>((<span class="hljs-function">() =></span> ({ <span class="hljs-attr">animalStuff</span>: <span class="hljs-number">0</span> }) <span class="hljs-keyword">as</span> <span class="hljs-title class_">Animal</span>));
<span class="hljs-comment">// 당연히 작동합니다.</span>

<span class="hljs-comment">// 그러나 Dog를 반환하는 Getter를 사용하려면 어떻게 해야 할까요?</span>
<span class="hljs-title function_">useAnimalGetter</span>((<span class="hljs-function">() =></span> ({ <span class="hljs-attr">animalStuff</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">dogStuff</span>: <span class="hljs-number">0</span> }) <span class="hljs-keyword">as</span> <span class="hljs-title class_">Dog</span>));
<span class="hljs-comment">// 이 또한 작동합니다. 왜냐하면 Dog도 Animal이기 때문입니다.</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">useDogGetter</span>(<span class="hljs-params">getter: Getter&#x3C;Dog></span>) {
  <span class="hljs-title function_">getter</span>();
}

<span class="hljs-comment">// useDogGetter 함수에 동일한 작업을 시도하면 동일한 동작을 얻지 못할 것입니다.</span>
<span class="hljs-title function_">useDogGetter</span>((<span class="hljs-function">() =></span> ({ <span class="hljs-attr">animalStuff</span>: <span class="hljs-number">0</span> }) <span class="hljs-keyword">as</span> <span class="hljs-title class_">Animal</span>); <span class="hljs-comment">// Type error: Property 'dogStuff' is missing in type 'Animal' but required in type 'Dog'.</span>
<span class="hljs-comment">// 이는 Animal이 아닌 Dog가 필요하기 때문에 작동하지 않습니다.</span>

<span class="hljs-title function_">useDogGetter</span>((<span class="hljs-function">() =></span> ({ <span class="hljs-attr">animalStuff</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">dogStuff</span>: <span class="hljs-number">0</span> }) <span class="hljs-keyword">as</span> <span class="hljs-title class_">Dog</span>);
<span class="hljs-comment">// 그러나 이 경우는 작동합니다.</span>

<span class="hljs-comment">// 직관적으로 Setters가 같은 방식으로 작동할 것으로 기대할 수도 있지만, 사실은 그렇지 않습니다.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">setAnimalSetter</span>(<span class="hljs-params">setter: Setter&#x3C;Animal>, value: Animal</span>) {
  <span class="hljs-title function_">setter</span>(value);
}

<span class="hljs-comment">// 동일한 유형의 Setter를 전달해도 작동합니다.</span>
<span class="hljs-title function_">setAnimalSetter</span>(<span class="hljs-function">(<span class="hljs-params">value: Animal</span>) =></span> {}, { <span class="hljs-attr">animalStuff</span>: <span class="hljs-number">0</span> });

<span class="hljs-keyword">function</span> <span class="hljs-title function_">setDogSetter</span>(<span class="hljs-params">setter: Setter&#x3C;Dog>, value: Dog</span>) {
  <span class="hljs-title function_">setter</span>(value);
}

<span class="hljs-comment">// 여기도 마찬가지로 작동합니다.</span>
<span class="hljs-title function_">setDogSetter</span>(<span class="hljs-function">(<span class="hljs-params">value: Dog</span>) =></span> {}, { <span class="hljs-attr">animalStuff</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">dogStuff</span>: <span class="hljs-number">0</span> });

<span class="hljs-comment">// 그러나 Dog Setter를 setAnimalSetter 함수에 전달하면 Getter와는 반대로 동작이 반전됩니다.</span>
<span class="hljs-title function_">setAnimalSetter</span>(<span class="hljs-function">(<span class="hljs-params">value: Dog</span>) =></span> {}, { <span class="hljs-attr">animalStuff</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">dogStuff</span>: <span class="hljs-number">0</span> }); <span class="hljs-comment">// Type error: Argument of type '(value: Dog) => void' is not assignable to parameter of type 'Setter&#x3C;Animal>'.</span>

<span class="hljs-comment">// 이번에는 상황이 반대로 작동합니다.</span>
<span class="hljs-title function_">setDogSetter</span>(<span class="hljs-function">(<span class="hljs-params">value: Animal</span>) =></span> {}, { <span class="hljs-attr">animalStuff</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">dogStuff</span>: <span class="hljs-number">0</span> });

<span class="hljs-comment">// 새로운 방법:</span>
<span class="hljs-comment">// TypeScript에이를 표시하기 위해 (필수는 아니지만 가독성을 위해 유용), 유형 매개변수에 대한 선택적 분산 주석을 사용합니다.</span>
type <span class="hljs-title class_">GetterNew</span>&#x3C;out T> = <span class="hljs-function">() =></span> T;
type <span class="hljs-title class_">SetterNew</span>&#x3C;<span class="hljs-keyword">in</span> T> = <span class="hljs-function">(<span class="hljs-params">value: T</span>) =></span> <span class="hljs-keyword">void</span>;
</code></pre>
<ul>
<li>moduleSuffixes로 해상도 사용자 정의: 사용자 정의 파일 접미사를 사용하는 환경(예: 네이티브 앱 빌드에 .ios를 사용하는 경우)에서는 TypeScript가 가져오기를 정확하게 해석하도록 이 접미사를 tsconfig.json에 지정할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js">...
<span class="hljs-string">"compilerOptions"</span>: [
  ...
  <span class="hljs-string">"moduleSuffixes"</span>: [<span class="hljs-string">".ios"</span>, <span class="hljs-string">".native"</span>, <span class="hljs-string">""</span>]
]
...
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">'./foo'</span>;
<span class="hljs-comment">// 이 코드는 먼저 ./foo.ios.ts를 확인하고, 그 다음에는 ./foo.native.ts를, 마지막으로 ./foo.ts를 확인합니다.</span>
</code></pre>
<ul>
<li>에디터에서 소스 정의로 이동: 에디터에서 새로운 "소스 정의로 이동" 메뉴 옵션이 사용 가능합니다. 이는 "정의로 이동"과 유사하지만, .ts 및 .js 파일을 .d.ts 타입 정의 파일보다 우선합니다.</li>
</ul>
<p><img src="https://miro.medium.com/v2/resize:fit:800/1*qvzGqfF844cXCPMeDrg_IQ.gif" alt="이미지"></p>
<h2>TypeScript 4.9</h2>
<ul>
<li><code>satisfies</code> 연산자: <code>satisfies</code> 연산자는 실제로 그 타입을 할당하지 않고도 타입과의 호환성을 확인할 수 있게 해줍니다. 이를 통해 더 정확한 추론된 타입을 유지하면서도 호환성을 유지할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이전:</span>
<span class="hljs-comment">// 여러 항목과 그 색상을 저장하는 객체/맵/딕셔너리가 있다고 가정해 보겠습니다.</span>
<span class="hljs-keyword">const</span> obj = {
  <span class="hljs-attr">fireTruck</span>: [<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  <span class="hljs-attr">bush</span>: <span class="hljs-string">'#00ff00'</span>,
  <span class="hljs-attr">ocean</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>]
} <span class="hljs-comment">// { fireTruck: number[]; bush: string; ocean: number[]; } 타입으로 정의됨</span>

<span class="hljs-comment">// 배열과 문자열에 대해 작업을 수행할 수 있도록 속성을 암시적으로 타입 지정합니다.</span>
<span class="hljs-keyword">const</span> rgb1 = obj.<span class="hljs-property">fireTruck</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 숫자로 타입 지정</span>
<span class="hljs-keyword">const</span> hex = obj.<span class="hljs-property">bush</span>; <span class="hljs-comment">// 문자열로 타입 지정</span>

<span class="hljs-comment">// 특정 객체만 허용하고 싶다면 Record 타입을 사용할 수 있습니다.</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">oldObj</span>: <span class="hljs-title class_">Record</span>&#x3C;string, [number, number, number] | string> = {
  <span class="hljs-attr">fireTruck</span>: [<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  <span class="hljs-attr">bush</span>: <span class="hljs-string">'#00ff00'</span>,
  <span class="hljs-attr">ocean</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>]
} <span class="hljs-comment">// Record&#x3C;string, [number, number, number] | string> 타입으로 정의됨</span>
<span class="hljs-comment">// 하지만 이제 우리는 속성의 타입에 대한 정보를 잃어버립니다.</span>
<span class="hljs-keyword">const</span> oldRgb1 = oldObj.<span class="hljs-property">fireTruck</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">// string 또는 number로 타입 지정</span>
<span class="hljs-keyword">const</span> oldHex = oldObj.<span class="hljs-property">bush</span>; <span class="hljs-comment">// string 또는 number로 타입 지정</span>

<span class="hljs-comment">// 새롭게:</span>
<span class="hljs-comment">// `satisfies` 키워드를 사용하여 타입과 호환성을 확인할 수 있습니다.</span>
<span class="hljs-keyword">const</span> newObj = {
  <span class="hljs-attr">fireTruck</span>: [<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
  <span class="hljs-attr">bush</span>: <span class="hljs-string">'#00ff00'</span>,
  <span class="hljs-attr">ocean</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>]
} satisfies <span class="hljs-title class_">Record</span>&#x3C;string, [number, number, number] | string> <span class="hljs-comment">// { fireTruck: [number, number, number]; bush: string; ocean: [number, number, number]; } 타입으로 정의됨</span>
<span class="hljs-comment">// 이제 속성의 타입에 대한 정보를 유지할 수 있을 뿐만 아니라 배열은 튜플로 더 정확해집니다.</span>
<span class="hljs-keyword">const</span> newRgb1 = newObj.<span class="hljs-property">fireTruck</span>[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 숫자로 타입 지정</span>
<span class="hljs-keyword">const</span> newRgb4 = newObj.<span class="hljs-property">fireTruck</span>[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 타입 오류: 길이가 '3'인 튜플 타입 '[number, number, number]'에는 인덱스 '3'에 해당하는 요소가 없습니다.</span>
<span class="hljs-keyword">const</span> newHex = newObj.<span class="hljs-property">bush</span>; <span class="hljs-comment">// 문자열로 타입 지정</span>
</code></pre>
<ul>
<li>편집기의 "사용되지 않는 Imports 제거" 및 "Imports 정렬" 명령: 편집기에서 새로운 "사용되지 않는 Imports 제거" 및 "Imports 정렬" 명령(및 자동 수정)을 사용하면 Imports를 관리하는 것이 더 쉬워집니다.</li>
</ul>
<p><img src="https://miro.medium.com/v2/resize:fit:800/1*z5SG6BKwzyxrG6sG7OKciw.gif" alt="이미지"></p>
<h2>TypeScript 5.0</h2>
<ul>
<li>ES 데코레이터 지원: TypeScript는 이제 ES 데코레이터(곧 나올 ES 기능)를 지원하며, 기존 데코레이터와는 다릅니다. 이전에 TypeScript는 데코레이터에 대해 실험적인 지원을 했었는데, 이는 Angular와 같은 프레임워크에서 사용되는 것으로, --experimentalDecorators 플래그(또는 tsconfig.json에서)로 선택할 수 있었으며 약간 다르게 동작했습니다. 그러나 이제 새로운 ES 데코레이터는 이전 것과는 다르게 메타데이터를 내보내지 못하며 아직은 매개변수에서도 지원되지 않습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 주의: 2023년 5월 기준으로 이것은 예정된 ES 기능이므로 이 코드는 아직 작동하지 않습니다.</span>

<span class="hljs-comment">// 디버깅 중에 메서드에 진입하거나 나갈 때마다 기록하려고 합니다.</span>
<span class="hljs-comment">// 이것을 수동으로 하는 것은 상당히 지루할 수 있습니다. 자동화할 방법이 있을까요?</span>
<span class="hljs-comment">// 네, 데코레이터를 사용하여 실행 컨텍스트를 대체할 수 있습니다.</span>

<span class="hljs-comment">// 먼저 데코레이터 역할을 할 함수를 정의합니다. 이 함수는 원본 메서드와 컨텍스트 개체를 매개변수로 받아 새로운 실행 함수를 반환합니다.</span>
<span class="hljs-keyword">function</span> logMethod&#x3C;<span class="hljs-title class_">This</span>, <span class="hljs-title class_">Args</span> <span class="hljs-keyword">extends</span> any[], <span class="hljs-title class_">Return</span>>(<span class="hljs-attr">originalMethod</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-variable language_">this</span>: This, ...args: Args</span>) =></span> <span class="hljs-title class_">Return</span>, <span class="hljs-attr">context</span>: <span class="hljs-title class_">ClassMethodDecoratorContext</span>) {
  <span class="hljs-keyword">const</span> methodName = <span class="hljs-title class_">String</span>(context.<span class="hljs-property">name</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">replacementFunction</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: This, ...args: Args</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`LOG: 메서드 '<span class="hljs-subst">${methodName}</span>' 진입 중.`</span>)
    <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`LOG: 메서드 '<span class="hljs-subst">${methodName}</span>' 나감.`</span>)
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-keyword">return</span> replacementFunction;
}

<span class="hljs-comment">// 이제 이를 사용할 클래스를 정의합니다. 데코레이터는 클래스와 그 멤버에만 작동합니다.</span>
<span class="hljs-comment">// 메서드에 '@'와 함수명을 사용하여 데코레이터를 적용합니다.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {
  @logMethod
  <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'작업 중'</span>;
  }
}

<span class="hljs-keyword">const</span> testObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();

<span class="hljs-comment">// 메서드를 실행하면 대체 메서드가 호출됩니다.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(testObj.<span class="hljs-title function_">doSomething</span>()); <span class="hljs-comment">// "LOG: 메서드 'doSomething' 진입 중.", "작업 중", "LOG: 메서드 'doSomething' 나감."</span>

<span class="hljs-comment">// 사용자 정의 메시지와 같은 추가 인수를 전달하려면 데코레이터 팩토리(데코레이터 함수를 반환하는 함수)를 정의할 수 있습니다.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">logMethodCustom</span>(<span class="hljs-params">customMessage: string</span>) {
  <span class="hljs-keyword">return</span> &#x3C;<span class="hljs-title class_">This</span>, <span class="hljs-title class_">Args</span> <span class="hljs-keyword">extends</span> any[], <span class="hljs-title class_">Return</span>><span class="hljs-function">(<span class="hljs-params">originalMethod: (<span class="hljs-variable language_">this</span>: This, ...args: Args) => Return, context: ClassMethodDecoratorContext</span>) =></span> {
    <span class="hljs-keyword">const</span> methodName = <span class="hljs-title class_">String</span>(context.<span class="hljs-property">name</span>);

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">replacementFunction</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: This, ...args: Args</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${customMessage}</span>: 메서드 '<span class="hljs-subst">${methodName}</span>' 진입 중.`</span>)
      <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, ...args);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${customMessage}</span>: 메서드 '<span class="hljs-subst">${methodName}</span>' 나감.`</span>)
      <span class="hljs-keyword">return</span> result;
    }

    <span class="hljs-keyword">return</span> replacementFunction;
  }
}

<span class="hljs-comment">// 이번에는 함수 호출을 포함하는 `()`로 된 추가 인수를 사용하여 메서드에 데코레이터를 적용합니다.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCustom</span> {
  @<span class="hljs-title function_">logMethodCustom</span>(<span class="hljs-string">'테스트 로그'</span>)
  <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'작업 중'</span>;
  }
}

<span class="hljs-keyword">const</span> testCustomObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();

<span class="hljs-comment">// 메서드 실행시 모든 작업이 예상대로 작동합니다.</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(testCustomObj.<span class="hljs-title function_">doSomething</span>()); <span class="hljs-comment">// "테스트 로그: 메서드 'doSomething' 진입 중.", "작업 중", "테스트 로그: 메서드 'doSomething' 나감."</span>

<span class="hljs-comment">// 데코레이터 함수에서 대체 메서드를 반환하지 않으면 원본 메서드가 호출되지만 관련 설정을 아직 설정할 수 있습니다.</span>
<span class="hljs-comment">// 예를 들어 `constructor` 단계 이전에 `this`를 바인딩하여 클래스 외부에서 콜백으로 전달할 경우 동일하게 실행되도록합니다.</span>
<span class="hljs-comment">// `constructor` 단계 이전에 코드를 실행하려면 컨텍스트 개체의 `addInitializer` 메서드를 사용할 수 있습니다.</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bindThis</span>(<span class="hljs-params">_: unknown, context: ClassMethodDecoratorContext</span>) {
<span class="hljs-keyword">const</span> methodName = context.<span class="hljs-property">name</span>;
<span class="hljs-keyword">if</span> (context.<span class="hljs-property">private</span>) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`'bound'는 <span class="hljs-subst">${methodName <span class="hljs-keyword">as</span> string}</span>과 같은 비공개 속성을 데코레이션할 수 없습니다.`</span>);
}
context.<span class="hljs-title function_">addInitializer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">this</span>: any</span>) {
  <span class="hljs-keyword">const</span> methodName = context.<span class="hljs-property">name</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> methodName === <span class="hljs-string">'string'</span>) {
      <span class="hljs-variable language_">this</span>[methodName] = <span class="hljs-variable language_">this</span>[methodName].<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>);
    }
  });
}

<span class="hljs-comment">// 바인딩하지 않은 상태로 한번 정의합니다.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TestUnbound</span> {
  private returnVal = <span class="hljs-string">'작업 중'</span>;

  <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">returnVal</span>;
  }
}

<span class="hljs-keyword">const</span> testUnboundObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestUnbound</span>();

<span class="hljs-comment">// 메서드에 다시 "데코레이터"를 적용합니다.</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TestBound</span> {
  private returnVal = <span class="hljs-string">'작업 중'</span>;

  @bindThis
  <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">returnVal</span>;
  }
}

<span class="hljs-keyword">const</span> testBoundObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestBound</span>();

<span class="hljs-comment">// 클래스 컨텍스트 외부에 메서드를 저장하고 실행시키면 속성 값에 액세스할 수 없습니다.</span>
<span class="hljs-keyword">const</span> unboundFunc = testUnboundObj.<span class="hljs-property">doSomething</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">unboundFunc</span>()); <span class="hljs-comment">// 오류: "Cannot read properties of undefined (reading 'returnVal')"</span>

<span class="hljs-comment">// 그러나 바인딩하면 예상대로 작동합니다.</span>
<span class="hljs-keyword">const</span> boundFunc = testBoundObj.<span class="hljs-property">doSomething</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">boundFunc</span>()); <span class="hljs-comment">// "작업 중"</span>
</code></pre>
<ul>
<li>
<p>const 형식 매개변수: 형식 매개변수 앞에 const를 지정하는 const는 readonly 형식을 그대로 사용하는 것처럼 동작하도록 시도합니다. 그러나 변경 가능한 값을 형식화했다면 인자유추가 작동하지 않을 수 있습니다(왜냐하면 읽기전용 형식은 변경 가능한 형식에 할당할 수 없기 때문에 항상 readonly 형식을 상속해야 합니다). 이것은 여전히 허용된 매개변수를 제한하지 않습니다. 여전히 extends 내에서 제한해야 합니다.</p>
</li>
<li>
<p>타입을 활용한 여러 구성 파일 지원: 복잡한 상속 구조를 만들거나 모든 "tsconfig"에서 항상 동일한 구성을 확장하거나 모든 설정을 복사하여 모두 복사하는 대신, "tsconfig" 파일에서 "extends": ["./tsconfig1.json", "./tsconfig2.json"]를 지정함으로써 여러 파일을 확장하여 동작을 재정의할 수 있습니다. 후자의 파일이 오버라이드 동작을 우선시합니다.</p>
</li>
</ul>
<pre><code class="hljs language-js">...
<span class="hljs-comment">// 여기서 "tsconfig1.json"은 "@tsconfig/strictest/tsconfig.json"을 덮어씁니다. "tsconfig2.json"은 "tsconfig1.json"과 "@tsconfig/strictest/tsconfig.json"을 덮어쓰며, 이 파일은 모두 덮어씁니다.</span>
<span class="hljs-string">"extends"</span>: [<span class="hljs-string">"@tsconfig/strictest/tsconfig.json"</span>, <span class="hljs-string">"./tsconfig1.json"</span>, <span class="hljs-string">"./tsconfig2.json"</span>],
...
</code></pre>
<ul>
<li>모든 열거형이 합집합 열거형입니다: 동적으로 할당된 열거형 값은 이제 더 이상 예전의 열거형 전략 기본값을 갖지 않습니다(열거형 키에 대한 타입 없음, 값으로만 사용 가능하며 타입으로 사용할 수 없음). 대신 이제 타입으로도 사용할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 열거형은 각 값마다 다른 타입을 만듭니다.</span>
enum <span class="hljs-title class_">Color</span> {
  <span class="hljs-title class_">Red</span>, <span class="hljs-title class_">Green</span>, <span class="hljs-title class_">Blue</span>, <span class="hljs-title class_">Orange</span>, <span class="hljs-title class_">Yellow</span>, <span class="hljs-title class_">Violet</span>
}

<span class="hljs-comment">// 이를 통해 그들을 좁히고 다른 타입처럼 사용할 수 있습니다.</span>
type <span class="hljs-title class_">PrimaryColor</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span> | <span class="hljs-title class_">Color</span>.<span class="hljs-property">Green</span> | <span class="hljs-title class_">Color</span>.<span class="hljs-property">Blue</span>;

<span class="hljs-comment">// 하지만:</span>
<span class="hljs-comment">// 값이 동적으로 할당되면 고정된 값이 없습니다.</span>
<span class="hljs-comment">// 이전에는 예전 열거형 동작으로 되돌아가게 되었습니다.</span>
<span class="hljs-comment">// 예전 열거형 동작에서 그 멤버는 값으로만 존재하며 타입으로는 존재하지 않음.</span>
enum <span class="hljs-title class_">ColorRandom</span> {
  <span class="hljs-title class_">Red</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(),
  <span class="hljs-title class_">Green</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(),
  <span class="hljs-title class_">Blue</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(),
  <span class="hljs-title class_">Orange</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(),
  <span class="hljs-title class_">Yellow</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(),
  <span class="hljs-title class_">Violet</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()
}

<span class="hljs-comment">// 그래서 이전에는 좁혀지지 못했습니다.</span>
type <span class="hljs-title class_">PrimaryColorRandom</span> = <span class="hljs-title class_">ColorRandom</span>.<span class="hljs-property">Red</span> | <span class="hljs-title class_">ColorRandom</span>.<span class="hljs-property">Green</span> | <span class="hljs-title class_">ColorRandom</span>.<span class="hljs-property">Blue</span>; <span class="hljs-comment">// 이전 타입 오류: Enum 타입 'ColorRandom'은 리터럴이 아닌 초기화 값을 갖는 멤버를 가지고 있습니다.</span>
<span class="hljs-comment">// 하지만 이제 그들에게도 자체 타입이 있기 때문에 작동합니다.</span>
</code></pre>
<ul>
<li>--moduleResolution bundler: TS 4.7의 모듈 해결 전략 "node16"은 ES 모듈을 더 잘 모델링할 수 있게 해주지만 일부 불필요한 제약이 있었습니다(파일 확장자를 명시해야 했으며, ...). 번들러를 사용 중이라면, 새 전략은 최신 기능을 유지하면서 일부 제약을 제거하려고 시도합니다. 컴파일러 플래그 --moduleResolution bundle를 지정하여 사용할 수 있습니다(또는 tsconfig.json에서). 번들러를 사용할 때만 사용하세요.</li>
</ul>
<pre><code class="hljs language-json">...
<span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
  ...
  <span class="hljs-attr">"moduleResolution"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"bundler"</span>
<span class="hljs-punctuation">]</span>
...
</code></pre>
<pre><code class="hljs language-json">import * as foo from './foo';
<span class="hljs-comment">// 이제는 파일 확장자가 지정되지 않아도 다시 허용됩니다.</span>
</code></pre>
<ul>
<li>해상도 Customization Flags: "hybrid" 모듈 해상도에 대한 규칙을 설정합니다. 규칙은 다음과 같습니다: allowImportingTsExtensions, resolvePackageJsonExports (imports를 위해 package.json exports을 고려함), resolvePackageJsonImports (#로 시작하는 경로를 위해 로컬 package.json을 참조함), allowArbitraryExtensions 및 customConditions (node16 및 bundler 전용, package.json에서 조건부 exports 및 imports을 위해 사용됨)입니다. 이러한 모든 설정은 --를 접두사로 하여 컴파일러 플래그로 지정하거나 tsconfig.json에 지정할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-json">...
<span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
  ...
  <span class="hljs-attr">"allowImportingTsExtensions"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"resolvePackageJsonExports"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"resolvePackageJsonImports"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"allowArbitraryExtensions"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"customConditions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">"my-condition"</span><span class="hljs-punctuation">]</span>
  <span class="hljs-comment">// 이제는 `package.json`의 `exports` 및 `imports`에 대한 사용자 정의 조건을 해결하려고 시도합니다.</span>
  <span class="hljs-comment">// TS는 그런 다음 해당 사용자 정의 조건에 맞도록 파일을 매칭하려고 할 것입니다 (이 경우 `foo.mjs`).</span>
<span class="hljs-punctuation">]</span>
...
</code></pre>
<pre><code class="hljs language-js">{
  ...
  <span class="hljs-string">"exports"</span>: {
    <span class="hljs-string">"."</span>: {
      <span class="hljs-string">"my-condition"</span>: <span class="hljs-string">"./foo.mjs"</span>,
      <span class="hljs-string">"node"</span>: <span class="hljs-string">"./bar.mjs"</span>,
      <span class="hljs-string">"import"</span>: <span class="hljs-string">"./baz.mjs"</span>,
      <span class="hljs-string">"require"</span>: <span class="hljs-string">"./biz.mjs"</span>
    }
  }
}
</code></pre>
<ul>
<li><strong>--verbatimModuleSyntax:</strong> 자동으로 import (import elision) 및 exports를 제거하지 않도록 TypeScript를 중지합니다. 이것은 import side effects가 사용될 때 또는 TS가 import가 어디에서 사용되는지 인식하지 못할 때 유용할 수 있습니다. import type 및 export type 문은 여전히 최종 컴파일에서 제거됩니다. 대개 import가 타입인지 아닌지 명시하는 것이 권장됩니다. compiler flag --verbatimModuleSyntax(또는 tsconfig.json에서)를 지정하여 사용할 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// `verbatimModuleSyntax`가 설정되지 않으면 이 import는 최종 컴파일에서 제거될 것입니다.</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Car</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./car'</span>;
<span class="hljs-comment">// 이 import는 아무 경우에나 제거될 것입니다.</span>
<span class="hljs-keyword">import</span> type { <span class="hljs-title class_">Car</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./car'</span>;
<span class="hljs-comment">// 이 import는 절대로 제거되지 않습니다.</span>
<span class="hljs-keyword">import</span> { logCar } <span class="hljs-keyword">from</span> <span class="hljs-string">'./car'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">drive</span>(<span class="hljs-params">car: Car</span>) {
  <span class="hljs-title function_">logCar</span>(car);
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<ul>
<li><strong>export type * 지원:</strong> 기본 형식을 하위 모듈로 쉽게 다시 내보낼 수 있습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 기본 타입들을 다른 모듈로서 서브모듈로 내보냅니다.</span>
<span class="hljs-keyword">export</span> type * <span class="hljs-keyword">as</span> am <span class="hljs-keyword">from</span> <span class="hljs-string">'another-module'</span>;
<span class="hljs-comment">// 또는 다시 기본 내보낸 것으로 제공합니다.</span>
<span class="hljs-keyword">export</span> type * <span class="hljs-keyword">from</span> <span class="hljs-string">'another-module'</span>;
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> type { am } <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span>;
<span class="hljs-comment">// 또는</span>
<span class="hljs-keyword">import</span> type { } <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span>;
</code></pre>
<ul>
<li>--build 하위에서 Emit-Specific 플래그 전달: 빌드에 대한 동작을 지정하는 플래그들 (--build를 사용할 때). 이들은 --declaration, --emitDeclarationOnly, --declarationMap, --sourceMap 및 --inlineSourceMap를 포함합니다. 모두 이제 컴파일러 플래그로 지정할 수 있습니다. 이전에는 tsconfig.json에서만 설정할 수 있었어요.</li>
</ul>
<pre><code class="hljs language-js"># 이것은 <span class="hljs-string">`tsconfig.json`</span>에서 비활성화되어 있더라도 타입 선언을 생성합니다.
tsc --build --declaration
</code></pre>
<ul>
<li>에디터에서 대소문자 구분 없는 import 정렬: 에디터에서 import를 정렬할 때 대소문자 구분 동작을 변경하세요. 이 기능은 VSCode의 JSON 설정 내 typescript.unstable 아래에서 활성화하고 구성할 수 있습니다.</li>
</ul>
<p><img src="https://miro.medium.com/v2/resize:fit:1032/1*Fei6JPgYzIgnl_IMekhOQg.gif" alt="이미지"></p>
<ul>
<li>Exhaustive switch/case 자동 완성: 에디터에서 이제 리터럴 타입의 case 문을 자동으로 완성할 수 있습니다.</li>
</ul>
<p><img src="https://miro.medium.com/v2/resize:fit:656/1*e9FNtf4-kxU787rEl1w9lQ.gif" alt="이미지"></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JavaScript와 TypeScript 비교 정리","description":"","date":"2024-05-27 18:10","slug":"2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years","content":"\n\n\n![2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png](/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png)\n\n이 기사는 지난 3년 동안 (그리고 그 이전에서도) JavaScript/ECMAScript와 TypeScript에서 발생한 거의 모든 변경 사항을 살펴봅니다.\n\n다음의 기능들 중 일부는 여러분에게 적용되지 않거나 실용적이지 않을 수 있지만, 이러한 언어에 대한 이해를 더 깊게 하고 가능한 기능을 보여주기 위한 것입니다.\n\n많은 TypeScript 기능들을 생략했는데, 그 이유는 \"이전과 달리 예상대로 작동하지 않았으나, 지금은 그렇게 됩니다\"로 요약할 수 있습니다. 따라서 과거에 작동하지 않았던 것이 있다면, 다시 시도해 보세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- JavaScript / ECMAScript (가장 오래된 것부터)\n- TypeScript (가장 오래된 것부터)\n\n# 내용\n\n# ECMAScript\n\n## 과거 (아직도 중요한 이전 소개들)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Tagged template literals: 템플릿 리터럴 앞에 함수 이름을 붙이면 함수가 템플릿 리터럴 및 템플릿 값들을 전달받게 됩니다. 이 방법에는 재미있는 활용법이 있습니다.\n\n```js\n// 임의의 숫자를 포함한 문자열을 로깅할 때 숫자를 형식화하는 방법을 작성하고 싶다고 가정해 봅시다.\n// 그럴 때 태그드 템플릿을 사용할 수 있습니다.\nfunction formatNumbers(strings: TemplateStringsArray, number: number): string {\n  return strings[0] + number.toFixed(2) + strings[1];\n}\nconsole.log(formatNumbers`This is the value: ${0}, it's important.`); // This is the value: 0.00, it's important.\n\n// 문자열 내의 번역 키를 \"번역\"하고 싶을 때 (여기서는 소문자로 변경)\nfunction translateKey(key: string): string {\n  return key.toLocaleLowerCase();\n}\nfunction translate(strings: TemplateStringsArray, ...expressions: string[]): string {\n  return strings.reduce((accumulator, currentValue, index) =\u003e accumulator + currentValue + translateKey(expressions[index] ?? ''), '');\n}\nconsole.log(translate`Hello, this is ${'NAME'} to say ${'MESSAGE'}.`); // Hello, this is name to say message.\n```\n\n- Symbols: 객체에 대한 고유 키: Symbol(\"foo\") === Symbol(\"foo\"); // false. 내부적으로 사용됩니다.\n\n```js\nconst obj: { [index: string]: string } = {};\n\nconst symbolA = Symbol('a');\nconst symbolB = Symbol.for('b');\n\nconsole.log(symbolA.description); // \"a\"\n\nobj[symbolA] = 'a';\nobj[symbolB] = 'b';\nobj['c'] = 'c';\nobj.d = 'd';\n\nconsole.log(obj[symbolA]); // \"a\"\nconsole.log(obj[symbolB]); // \"b\"\n\n// 다른 심볼이나 심볼 없이는 키에 액세스할 수 없습니다.\nconsole.log(obj[Symbol('a')]); // undefined\nconsole.log(obj['a']); // undefined\n\n// for ... in을 사용할 때 키가 열거되지 않습니다.\nfor (const i in obj) {\n  console.log(i); // \"c\", \"d\"\n}\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ES2020\n\n- Optional chaining: 잠재적으로 정의되지 않은 객체의 값을 (인덱싱을 통해) 액세스하기 위해 부모 객체 이름 뒤에 ?를 사용하여 선택적 연결을 사용할 수 있습니다. 이는 인덱싱 ([...]) 또는 함수 호출에도 사용할 수 있습니다.\n\n```js\n// 이전:\n// 우리가 정확히 정의된 것인지 확신할 수 없는 객체 변수 (또는 다른 구조)가 있을 때,\n// 속성에 쉽게 액세스할 수 없습니다.\nconst object: { name: string } | undefined = Math.random() \u003e 0.5 ? undefined : { name: 'test' };\nconst value = object.name; // 타입 오류: 'object' 가 'undefined' 일 수 있습니다.\n\n// 먼저 정의되었는지 확인해야 했지만, 이는 가독성을 해치며 중첩된 객체에 대해 복잡해집니다.\nconst objectOld: { name: string } | undefined = Math.random() \u003e 0.5 ? undefined : { name: 'test' };\nconst valueOld = objectOld ? objectOld.name : undefined;\n\n// 새로운 방법:\n// 대신 선택적 연결을 사용할 수 있습니다.\nconst objectNew: { name: string } | undefined = Math.random() \u003e 0.5 ? undefined : { name: 'test' };\nconst valueNew = objectNew?.name;\n\n// 이것은 인덱싱 및 함수에도 사용할 수 있습니다.\nconst array: string[] | undefined = Math.random() \u003e 0.5 ? undefined : ['test'];\nconst item = array?.[0];\nconst func: (() =\u003e string) | undefined = Math.random() \u003e 0.5 ? undefined : () =\u003e 'test';\nconst result = func?.();\n```\n\n- 널 병합 연산자 (??): 조건부 할당을 위해 || 연산자를 사용하는 대신 새로운 ?? 연산자를 사용할 수 있습니다. 모든 거짓 값에 적용되는 대신 undefined와 null에만 적용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst value: string | undefined = Math.random() \u003e 0.5 ? undefined : 'test';\n\n// 이전:\n// 값이 undefined 또는 null인 경우 다른 값으로 조건적으로 할당하려면 \"||\" 연산자를 사용할 수 있었습니다.\nconst anotherValue = value || 'hello';\nconsole.log(anotherValue); // \"test\" 또는 \"hello\"\n\n// 이는 참 값 사용 시 잘 작동하지만, 0이나 빈 문자열과 비교할 경우에도 적용됩니다.\nconst incorrectValue = '' || 'incorrect';\nconsole.log(incorrectValue); // 항상 \"incorrect\"\nconst anotherIncorrectValue = 0 || 'incorrect';\nconsole.log(anotherIncorrectValue); // 항상 \"incorrect\"\n\n// 새로운 방법:\n// 이제 nullish 병합 연산자를 사용할 수 있습니다. 이는 오직 undefined와 null 값에만 적용됩니다.\nconst newValue = value ?? 'hello';\nconsole.log(newValue) // 항상 \"hello\"\n\n// 이제 falsy 값들이 교체되지 않습니다.\nconst correctValue = '' ?? 'incorrect';\nconsole.log(correctValue); // 항상 \"\"\nconst anotherCorrectValue = 0 ?? 'incorrect';\nconsole.log(anotherCorrectValue); // 항상 0\n```\n\n- import(): 변수를 사용하여 런타임에서 동적으로 import ... from ... 처럼 모듈을 가져올 수 있습니다.\n\n```js\nlet importModule;\nif (shouldImport) {\n  importModule = await import('./module.mjs');\n}\n```\n\n- String.matchAll(): 루프를 사용하지 않고 정규 표현식의 여러 일치 항목과 캡처 그룹을 모두 얻을 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst stringVar = 'testhello,testagain,';\n\n// 이전:\n// 일치 항목만 검색되며 캡처 그룹은 포함되지 않습니다.\nconsole.log(stringVar.match(/test([\\w]+?),/g)); // [\"testhello,\", \"testagain,\"]\n\n// 캡처 그룹을 포함한 하나의 일치 항목만 검색합니다.\nconst singleMatch = stringVar.match(/test([\\w]+?),/);\nif (singleMatch) {\n  console.log(singleMatch[0]); // \"testhello,\"\n  console.log(singleMatch[1]); // \"hello\"\n}\n\n// 같은 결과를 얻지만 매우 직관적이지 않습니다 (exec 메서드는 마지막 인덱스를 저장합니다).\n// 루프 외부에서 정의되어야 하며 전역으로 선언되어야 하며 (/g) 모드여야 합니다.\nconst regex = /test([\\w]+?),/g;\nlet execMatch;\nwhile ((execMatch = regex.exec(stringVar)) !== null) {\n  console.log(execMatch[0]); // \"testhello,\", \"testagain,\"\n  console.log(execMatch[1]); // \"hello\", \"again\"\n}\n\n// 새로운 방법:\n// 정규식은 전역 (/g)이어야 합니다. 그렇지 않으면 작동하지 않습니다.\nconst matchesIterator = stringVar.matchAll(/test([\\w]+?),/g);\n// 순회해야 하거나 배열(Array.from())로 변환해야 하며 직접 색인화(인덱싱)할 수 없습니다.\nfor (const match of matchesIterator) {\n  console.log(match[0]); // \"testhello,\", \"testagain,\"\n  console.log(match[1]); // \"hello\", \"again\"\n}\n```\n\n- Promise.allSettled(): Promise.all()과 유사하지만 모든 Promise가 완료될 때까지 기다리며 첫 번째 reject/throw에서 반환하지 않습니다. 모든 오류 처리를 보다 쉽게 할 수 있습니다.\n\n```js\nasync function success1() {return 'a'}\nasync function success2() {return 'b'}\nasync function fail1() {throw 'fail 1'}\nasync function fail2() {throw 'fail 2'}\n\n// 이전:\nconsole.log(await Promise.all([success1(), success2()])); // [\"a\", \"b\"]\n// 하지만:\ntry {\n  await Promise.all([success1(), success2(), fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// 주의: 하나의 에러만 처리하고 성공 값에 액세스할 수 없습니다.\n\n// 이전 해결 방법 (정말 최적이 아님):\nconsole.log(await Promise.all([ // [\"a\", \"b\", undefined, undefined]\n  success1().catch(e =\u003e { console.log(e); }),\n  success2().catch(e =\u003e { console.log(e); }),\n  fail1().catch(e =\u003e { console.log(e); }), // \"fail 1\"\n  fail2().catch(e =\u003e { console.log(e); })])); // \"fail 2\"\n\n// 새로운 방법:\nconst results = await Promise.allSettled([success1(), success2(), fail1(), fail2()]);\nconst sucessfulResults = results\n  .filter(result =\u003e result.status === 'fulfilled')\n  .map(result =\u003e (result as PromiseFulfilledResult\u003cstring\u003e).value);\nconsole.log(sucessfulResults); // [\"a\", \"b\"]\nresults.filter(result =\u003e result.status === 'rejected').forEach(error =\u003e {\n  console.log((error as PromiseRejectedResult).reason); // \"fail 1\", \"fail 2\"\n});\n// 또는:\nfor (const result of results) {\n  if (result.status === 'fulfilled') {\n    console.log(result.value); // \"a\", \"b\"\n  } else if (result.status === 'rejected') {\n    console.log(result.reason); // \"fail 1\", \"fail 2\"\n  }\n}\n```\n\n- BigInt: 새로운 BigInt 데이터 유형을 사용하여 큰 (정수) 숫자를 정확하게 저장하고 처리할 수 있어 JavaScript가 숫자를 부동 소수점으로 저장하는 것에 의한 오류를 방지할 수 있습니다. BigInt() 생성자를 사용하여 생성할 수 있고(불완전성을 방지하기 위해 문자열을 선호) 또는 숫자 끝에 n을 추가하여 생성할 수 있습니다.\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n// 이전:\n// JavaScript는 숫자를 부동 소수점으로 저장하기 때문에 항상 약간의 부정확성이 있습니다.\n// 더 중요한 것은 특정 숫자 이후에 정수 연산에 부정확성이 시작됩니다.\nconst maxSafeInteger = 9007199254740991;\nconsole.log(maxSafeInteger === Number.MAX_SAFE_INTEGER); // true\n\n// 해당 숫자보다 큰 숫자와 비교하면 부정확성이 발생할 수 있습니다.\nconsole.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2);\n\n// NEW:\n// BigInt 데이터 형식을 사용하면 이론적으로 무한히 큰 (정수) 숫자를 저장하고 조작할 수 있습니다.\n// 숫자 끝에 \"n\"을 추가하거나 BigInt 생성자를 사용하여 사용합니다.\nconst maxSafeIntegerPreviously = 9007199254740991n;\nconsole.log(maxSafeIntegerPreviously); // 9007199254740991\n\nconst anotherWay = BigInt(9007199254740991);\nconsole.log(anotherWay); // 9007199254740991\n\n// 안전한 정수(Number.MAX_SAFE_INTEGER)보다 큰 정수를 전달하면 안됩니다.\nconst incorrect = BigInt(9007199254740992);\nconsole.log(incorrect); // 9007199254740992\nconst incorrectAgain = BigInt(9007199254740993);\nconsole.log(incorrectAgain); // 9007199254740992\n// 오랜, 동일한 값으로 변환됩니다.\n\n// 대신 문자열을 사용하거나 더 좋은 다른 구문을 사용합니다.\nconst correct = BigInt('9007199254740993');\nconsole.log(correct); // 9007199254740993\nconst correctAgain = 9007199254740993n;\nconsole.log(correctAgain); // 9007199254740993\n\n// 16진수, 8진수 및 2진수도 문자열로 전달할 수 있습니다.\nconst hex = BigInt('0x1fffffffffffff');\nconsole.log(hex); // 9007199254740991\nconst octal = BigInt('0o377777777777777777');\nconsole.log(octal); // 9007199254740991\nconst binary = BigInt('0b11111111111111111111111111111111111111111111111111111');\nconsole.log(binary); // 9007199254740991\n\n// 대부분의 산술 연산은 예상대로 작동하지만 다른 연산자도 BigInt 여야합니다. 모든 연산도 BigInt를 반환합니다.\nconst addition = maxSafeIntegerPreviously + 2n;\nconsole.log(addition); // 9007199254740993\n\nconst multiplication = maxSafeIntegerPreviously * 2n;\nconsole.log(multiplication); // 18014398509481982\n\nconst subtraction = multiplication - 10n;\nconsole.log(subtraction); // 18014398509481972\n\nconst modulo = multiplication % 10n;\nconsole.log(modulo); // 2\n\nconst exponentiation = 2n ** 54n;\nconsole.log(exponentiation); // 18014398509481984\n\nconst exponentiationAgain = 2n ^ 54n;\nconsole.log(exponentiationAgain); // 18014398509481984\n\nconst negative = exponentiation * -1n;\nconsole.log(negative); // -18014398509481984\n\n// BigInt로 인한 정수 나눗셈은 조금 다르게 작동합니다.\nconst division = multiplication / 2n;\nconsole.log(division); // 9007199254740991\n// 나뉠 수 있는 정수에 대해서는 제대로 작동합니다.\n\n// 나누기가 안 되는 숫자에 대해서는 정수 나눗셈(내림)처럼 작동할 것입니다.\nconst divisionAgain = 5n / 2n;\nconsole.log(divisionAgain); // 2\n\n// 일치하는(엄격한) 비교가 BigInt 숫자에는 적용되지 않습니다.\nconsole.log(0n === 0); // false\nconsole.log(0n == 0); // true\n\n// 그러나 비교는 예상대로 작동합니다.\nconsole.log(1n \u003c 2); // true\nconsole.log(2n \u003e 1); // true\nconsole.log(2 \u003e 2); // false\nconsole.log(2n \u003e 2); // false\nconsole.log(2n \u003e= 2); // true\n\n// 타입은 \"bigint\"입니다.\nconsole.log(typeof 1n); // \"bigint\"\n\n// 일반 숫자(부호있는 부호 없는 (음수 없음))로 다시 변환할 수 있습니다.\n// 그러나 이는 정확도를 희생합니다. 유효 숫자의 수를 지정할 수 있습니다.\n\nconsole.log(BigInt.asIntN(0, -2n)); // 0\nconsole.log(BigInt.asIntN(1, -2n)); // 0\nconsole.log(BigInt.asIntN(2, -2n)); // -2\n// 보통 더 높은 비트 수를 사용할 것입니다.\n\n// 음수 숫자는 부호가 있는 숫자로 변환될 때 2의 보수로 변환됩니다.\nconsole.log(BigInt.asUintN(8, -2n)); // 254\n\n\n- globalThis: 환경(브라우저, NodeJS, ...)와 상관없이 전역 컨텍스트에서 변수에 액세스할 수 있습니다. 여전히 권장되지는 않지만 때로는 필요합니다. 브라우저의 최상위 수준에서 this와 유사합니다.\n\n\nconsole.log(globalThis.Math); // Math Object\n\n\n- import.meta: ES-모듈을 사용할 때 현재 모듈 URL import.meta.url을 얻습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconsole.log(import.meta.url); // \"file://...\"\n```\n\n- export * as … from …: 쉽게 기본값을 하위 모듈로 다시 내보냅니다.\n\n```js\nexport * as am from 'another-module'\n```\n\n```js\nimport { am } from 'module'\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ES2021\n\n- String.replaceAll(): 이제 문자열 내에서 부분 문자열의 모든 인스턴스를 대체할 수 있습니다. 더 이상 항상 전역 플래그(/g)를 사용하는 정규 표현식을 사용할 필요가 없습니다.\n\n```js\nconst testString = 'hello/greetings everyone/everybody';\n// 이전:\n// 첫 번째 인스턴스만 대체함\nconsole.log(testString.replace('/', '|')); // 'hello|greetings everyone/everybody'\n\n// 대체하기 위해 정규 표현식을 사용해야 했는데, 이는 성능이 좋지 않고 이스케이프가 필요합니다.\n// 전역 플래그(/g)를 참고하세요.\nconsole.log(testString.replace(/\\//g, '|')); // 'hello|greetings everyone|everybody'\n\n// 새로운 기능:\n// replaceAll을 사용하면 더 명확하고 빠릅니다.\nconsole.log(testString.replaceAll('/', '|')); // 'hello|greetings everyone|everybody'\n```\n\n- Promise.any(): 프로미스 목록 중 하나의 결과만 필요한 경우, 첫 번째 결과를 반환합니다. 모든 프로미스가 거부될 때만 거부하고 AggregateError를 반환하며, 즉시 거부되는 Promise.race가 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconsole.log(await Promise.race([success1(), success2()])); // \"a\"\n// 그러나:\ntry {\n  await Promise.race([fail1(), fail2(), success1(), success2()]);\n} catch (e) {\n  console.log(e); // \"fail 1\"\n}\n// 유의: 하나의 오류만 catch하고 성공 값을 액세스할 수 없습니다.\n\n// 이전 수정 (정말 최적화되지 않음):\nconsole.log(await Promise.race([ // \"a\"\n  fail1().catch(e =\u003e { console.log(e); }), // \"fail 1\"\n  fail2().catch(e =\u003e { console.log(e); }), // \"fail 2\"\n  success1().catch(e =\u003e { console.log(e); }),\n  success2().catch(e =\u003e { console.log(e); })]));\n\n// 새로운:\nconsole.log(await Promise.any([fail1(), fail2(), success1(), success2()])); // \"a\"\n// 모든 프로미스가 거부될 때만 거부하고 모든 오류를 포함하는 AggregateError를 리턴합니다.\ntry {\n  await Promise.any([fail1(), fail2()]);\n} catch (e) {\n  console.log(e); // [AggregateError: All promises were rejected]\n  console.log(e.errors); // [\"fail 1\", \"fail 2\"]\n}\n```\n\n- Nullish coalescing assignment (??=): 이전에 \"nullish\"였을 때만 값을 할당합니다 (null 또는 undefined).\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =\u003e 'b';\n\n// undefined는 nullish이므로 새 값이 x1에 할당됩니다.\nx1 ??= 'b';\nconsole.log(x1) // \"b\"\n\n// 문자열은 nullish가 아니므로 x2에 새 값이 할당되지 않습니다.\n// 또한 참고: getNewValue()가 실행되지 않습니다.\nx2 ??= getNewValue();\nconsole.log(x2) // \"a\"\n```\n\n- Logical and assignment (\u0026\u0026=): 이전에 \"truthy\"였을 때만 값을 할당합니다 (true 또는 true로 변환되는 값).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =\u003e 'b';\n\n// 지정되지 않은 값인 x1에 새 값이 할당되지 않습니다. 왜냐하면 지정되지 않은 값은 참이 아닙니다.\n// 또한 주의: getNewValue()는 실행되지 않습니다.\nx1 \u0026\u0026= getNewValue();\nconsole.log(x1) // undefined\n\n// 문자열은 참이므로 새 값이 x2에 할당됩니다.\nx2 \u0026\u0026= 'b';\nconsole.log(x2) // \"b\"\n```\n\n- 논리 또는 할당 (||=): 이전에 \"거짓\"인 경우에만 값이 할당됩니다 (false 또는 false로 변환).\n\n```js\nlet x1 = undefined;\nlet x2 = 'a';\nconst getNewValue = () =\u003e 'b';\n\n// x1에 새 값이 할당됩니다. 왜냐하면 지정되지 않은 값은 거짓이기 때문입니다.\nx1 ||= 'b';\nconsole.log(x1) // \"b\"\n\n// x2에 새 값이 할당되지 않습니다. 왜냐하면 문자열은 거짓이 아닙니다.\n// 또한 주의: getNewValue()는 실행되지 않습니다.\nx2 ||= getNewValue();\nconsole.log(x2) // \"a\"\n```\n\n- WeakRef: 객체가 가비지 수집되는 것을 방지하지 않고 객체에 \"약한\" 참조를 보유합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst ref = new WeakRef(element);\n\n// 만약 객체/요소가 여전히 존재하고 쓰레기 수집되지 않았다면 값을 가져옵니다.\nconst value = ref.deref;\nconsole.log(value); // undefined\n// 객체가 더는 존재하지 않는 것 같습니다.\n```\n\n- 숫자 리터럴 구분자 (_): 가독성을 위해 숫자를 _로 구분합니다. 이는 기능에 영향을 미치지 않습니다.\n\n```js\nconst int = 1_000_000_000;\nconst float = 1_000_000_000.999_999_999;\nconst max = 9_223_372_036_854_775_807n;\nconst binary = 0b1011_0101_0101;\nconst octal = 0o1234_5670;\nconst hex = 0xD0_E0_F0;\n```\n\n## ES2022\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 최상위 대기: await 키워드는 이제 ES 모듈의 최상위 수준에서 사용할 수 있습니다. 이는 래퍼 함수의 필요성을 제거하고 오류 처리를 개선합니다.\n\n```js\nasync function asyncFuncSuccess() {\n  return 'test';\n}\n\nasync function asyncFuncFail() {\n  throw new Error('Test');\n}\n\n// 이전:\n// 프로미스를 대기하려면 async 함수 내부에서만 가능했습니다.\n// await asyncFuncSuccess(); // SyntaxError: await is only valid in async functions\n// 따라서 async 함수 내부로 래핑해야 했고 이는 오류 처리와 최상위 동시성을 잃게 했습니다.\ntry {\n  (async () =\u003e {\n    console.log(await asyncFuncSuccess()); // \"test\"\n    try {\n      await asyncFuncFail();\n    } catch (e) {\n      // 오류 처리를 위해 필요합니다. 그렇지 않으면 오류가 캐치되지 않거나 적절한 추적 없이 너무 늦게 되어버립니다.\n      console.error(e); // Error: \"Test\"\n      throw e;\n    }\n  })();\n} catch (e) {\n  // 함수가 async여서 절대 호출되지 않거나(적절한 추적이 없거나 너무 늦게) 이유 때문에\n  console.error(e);\n}\n\n// 비동기 함수가 기다려지지 않았기 때문에 이 프로미스 결과보다 먼저 기록됩니다.\nconsole.log('Hey'); // \"Hey\"\n\n// 새로운:\n// 파일이 ES 모듈이라면(package.json에 설정되었고, exports가 있고, \".mts\"로 명명된 경우) 최상위 수준에서 바로 await할 수 있습니다.\nconsole.log(await asyncFuncSuccess()); // \"test\"\ntry {\n  await asyncFuncFail();\n} catch (e) {\n  console.error(e); // Error: \"Test\"\n}\n\n// 모든 비동기 호출이 기다려지기 때문에 이 프로미스 결과 뒤에 기록됩니다.\nconsole.log('Hello'); // \"Hello\"\n```\n\n- #private: 클래스 멤버(속성 및 메서드)를 이름이 #로 시작하게하여 비공개로 만듭니다. 따라서 이러한 멤버는 클래스 내부에서만 액세스할 수 있습니다. 삭제되거나 동적으로 할당할 수 없습니다. 잘못된 동작은 JavaScript(하지만 TypeScript가 아닌) 구문 오류를 발생시킵니다. TypeScript 프로젝트에서는 권장되지 않습니다. 대신 기존 private 키워드를 사용하십시오.\n\n```js\nclass ClassWithPrivateField {\n  #privateField;\n  #anotherPrivateField = 4;\n\n  constructor() {\n    this.#privateField = 42; // 유효\n    delete this.#privateField; // 구문 오류\n    this.#undeclaredField = 444; // 구문 오류\n    console.log(this.#anotherPrivateField); // 4\n  }\n}\n\nconst instance = new ClassWithPrivateField();\ninstance.#privateField === 42; // 구문 오류\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- static 클래스 멤버: 클래스 필드(속성 및 메서드)를 static으로 표시하세요.\n\n```js\nclass Logger {\n  static id = 'Logger1';\n  static type = 'GenericLogger';\n  static log(message: string | Error) {\n    console.log(message);\n  }\n}\n\nclass ErrorLogger extends Logger {\n  static type = 'ErrorLogger';\n  static qualifiedType;\n  static log(e: Error) {\n    return super.log(e.toString());\n  }\n}\n\nconsole.log(Logger.type); // \"GenericLogger\"\nLogger.log('Test'); // \"Test\"\n\n// 정적으로만 있는 클래스를 생성하는 것은 무의미하지만 여기선 시연을 위해 수행되었습니다.\nconst log = new Logger();\n\nErrorLogger.log(new Error('Test')); // 에러: \"Test\" (부모 클래스의 생성에 영향을 받지 않음)\nconsole.log(ErrorLogger.type); // \"ErrorLogger\"\nconsole.log(ErrorLogger.qualifiedType); // undefined\nconsole.log(ErrorLogger.id); // \"Logger1\"\n\n// log()가 인스턴스 메서드가 아닌 정적 메서드이기 때문에 예외를 발생시킵니다.\nconsole.log(log.log()); // log.log is not a function\n```\n\n- 클래스 내의 정적 초기화 블록: 클래스가 초기화될 때 실행되는 블록, 기본적으로 정적 멤버를 초기화하는 \"생성자\"입니다.\n\n```js\nclass Test {\n  static staticProperty1 = '속성 1';\n  static staticProperty2;\n  static {\n    this.staticProperty2 = '속성 2';\n  }\n}\n\nconsole.log(Test.staticProperty1); // \"Property 1\"\nconsole.log(Test.staticProperty2); // \"Property 2\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 가져오기 어설션 (비표준, V8에서 구현됨): 가져온 항목의 유형을 확인하기 위해 사용할 수 있습니다. `import ... from ... assert ' type: `json` '`로 JSON을 직접 가져오고 구문 분석할 필요 없이 사용할 수 있습니다.\n\n```js\nimport json from './foo.json' assert { type: 'json' };\nconsole.log(json.answer); // 42\n```\n\n- 정규표현식 일치 인덱스: 정규표현식 일치 및 캡처 그룹의 시작 및 끝 인덱스를 가져올 수 있습니다. RegExp.exec(), String.match() 및 String.matchAll()에 대해 작동합니다.\n\n```js\nconst matchObj = /(test+)(hello+)/d.exec('start-testesthello-stop');\n\n// 이전:\nconsole.log(matchObj?.index);\n\n// 새로운:\nif (matchObj) {\n  // 전체 일치 항목의 시작 및 끝 인덱스(이전에 시작만 있었음).\n  console.log(matchObj.indices[0]); // [9, 18]\n\n  // 캡처 그룹의 시작 및 끝 인덱스.\n  console.log(matchObj.indices[1]); // [9, 13]\n  console.log(matchObj.indices[2]); // [13, 18]\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Negative indexing (.at(-1)): 배열이나 문자열을 인덱싱할 때, at()을 사용하여 뒤에서부터 인덱싱할 수 있습니다. 값 가져오기(arr[arr.length - 1]와 동일)만 가능하며 값을 설정할 수는 없습니다.\n\n```js\nconsole.log([4, 5].at(-1)) // 5\n\nconst array = [4, 5];\narray.at(-1) = 3; // SyntaxError: Assigning to rvalue\n```\n\n- hasOwn: 객체가 어떤 속성을 가지고 있는지 obj.hasOwnProperty()을 사용하는 대신 추천되는 새 방법입니다. 일부 특수한 경우에 더 잘 작동합니다.\n\n```js\nconst obj = { name: 'test' };\n\nconsole.log(Object.hasOwn(obj, 'name')); // true\nconsole.log(Object.hasOwn(obj, 'gender')); // false\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 오류 원인: 이제 오류에 대한 선택적 원인을 지정할 수 있습니다. 이는 다시 throw할 때 원래 오류를 지정할 수 있게 합니다.\n\n```js\ntry {\n  try {\n    connectToDatabase();\n  } catch (err) {\n    throw new Error('데이터베이스 연결에 실패했습니다.', { cause: err });\n  }\n} catch (err) {\n  console.log(err.cause); // ReferenceError: connectToDatabase is not defined\n}\n```\n\n## 미래 (이미 TypeScript 4.9에서 사용 가능)\n\n- Auto-Accessor: 속성을 자동으로 비공개로 만들고 get/set 접근자를 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass Person {\n  accessir name: string;\n\n  constructor(name: string) {\n    this.name = name;\n    console.log(this.name) // 'test'\n  }\n}\n\nconst person = new Person('test');\n```\n\n# TypeScript\n\n## 기초 (추후 소개를 위한 문맥)\n\n- 제네릭: 다른 유형으로 유형을 전달합니다. 이를 통해 유형을 일반화 할 수 있지만 여전히 유형 안전성을 유지할 수 있습니다. 항상 `any` 또는 `unknown` 대신 이를 선호해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// WITHOUT:\nfunction getFirstUnsafe(list: any[]): any {\n  return list[0];\n}\n\nconst firstUnsafe = getFirstUnsafe(['test']); // typed as any\n\n// WITH:\nfunction getFirst\u003cType\u003e(list: Type[]): Type {\n  return list[0];\n}\n\nconst first = getFirst\u003cstring\u003e(['test']); // typed as string\n\n// In this case the parameter can even be dropped because it is inferred from the argument.\nconst firstInferred = getFirst(['test']); // typed as string\n\n// The types accepted as generics can also be limited using `extends`. The Type is also usually shortened to T.\nclass List\u003cT extends string | number\u003e {\n  private list: T[] = [];\n\n  get(key: number): T {\n    return this.list[key];\n  }\n\n  push(value: T): void {\n    this.list.push(value);\n  }\n}\n\nconst list = new List\u003cstring\u003e();\nlist.push(9); // Type error: Argument of type 'number' is not assignable to parameter of type 'string'.\nconst booleanList = new List\u003cboolean\u003e(); // Type error: Type 'boolean' does not satisfy the constraint 'string | number'.\n```\n\n## 과거 (아직도 유효한 이전 소개)\n\n- 유틸리티 타입: TypeScript에는 많은 유틸리티 타입이 포함되어 있으며, 그 중 가장 유용한 몇 가지가 여기에서 설명되었습니다.\n\n```js\ninterface Test {\n  name: string;\n  age: number;\n}\n\n// Partial 유틸리티 타입은 모든 속성을 선택적으로 만듭니다.\ntype TestPartial = Partial\u003cTest\u003e; // typed as { name?: string | undefined; age?: number | undefined; }\n// Required 유틸리티 타입은 반대로 동작합니다.\ntype TestRequired = Required\u003cTestPartial\u003e; // typed as { name: string; age: number; }\n// Readonly 유틸리티 타입은 모든 속성을 읽기 전용으로 만듭니다.\ntype TestReadonly = Readonly\u003cTest\u003e; // typed as { readonly name: string; readonly age: string }\n// Record 유틸리티 타입은 객체/맵/사전을 간단하게 정의할 수 있습니다. 가능한 경우에는 인덱스 시그니처보다 선호됩니다.\nconst config: Record\u003cstring, boolean\u003e = { option: false, anotherOption: true };\n// Pick 유틸리티 타입은 지정된 속성만 가져옵니다.\ntype TestLess = Pick\u003cTest, 'name'\u003e; // typed as { name: string; }\ntype TestBoth = Pick\u003cTest, 'name' | 'age'\u003e; // typed as { name: string; age: string; }\n// Omit 유틸리티 타입은 지정된 속성을 무시합니다.\ntype TestFewer = Omit\u003cTest, 'name'\u003e; // typed as { age: string; }\ntype TestNone = Omit\u003cTest, 'name' | 'age'\u003e; // typed as {}\n// Parameters 유틸리티 타입은 함수 타입의 매개변수를 가져옵니다.\nfunction doSmth(value: string, anotherValue: number): string {\n  return 'test';\n}\ntype Params = Parameters\u003ctypeof doSmth\u003e; // typed as [value: string, anotherValue: number]\n// ReturnType 유틸리티 타입은 함수 타입의 반환 타입을 가져옵니다.\ntype Return = ReturnType\u003ctypeof doSmth\u003e; // typed as string\n\n// 이 외에도 많은 유틸리티 타입이 있으며, 그 중 일부는 아래에서 소개됩니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 조건부 타입: 어떤 타입이 다른 타입과 일치/확장되면 그에 따라 타입을 조건부로 설정합니다. 이는 JavaScript의 조건부(삼항) 연산자와 비슷하게 해석될 수 있습니다.\n\n```js\n// 배열인 경우에만 배열 타입을 추출하고, 그렇지 않으면 동일한 타입을 반환합니다.\ntype Flatten\u003cT\u003e = T extends any[] ? T[number] : T;\n\n// 요소 타입을 추출합니다.\ntype Str = Flatten\u003cstring[]\u003e; // string 타입으로 지정됨\n\n// 타입을 그대로 유지합니다.\ntype Num = Flatten\u003cnumber\u003e; // number 타입으로 지정됨\n```\n\n- 조건부 타입으로 추론: 모든 일반 타입이 소비자에 의해 명시적으로 지정되어야 하는 것은 아닙니다. 일부는 코드로부터 추론될 수도 있습니다. 추론된 타입을 기반으로 조건부 논리를 작성하려면 infer 키워드가 필요합니다. 이는 일시적인 추론된 타입 변수를 정의하는 방식입니다.\n\n```js\n// 이전 예제를 기반으로 해서 더 깔끔하게 작성할 수 있습니다.\ntype FlattenOld\u003cT\u003e = T extends any[] ? T[number] : T;\n\n// 배열에서 직접 인덱싱하는 대신, 배열에서 항목(Item)의 타입을 추론할 수 있습니다.\ntype Flatten\u003cT\u003e = T extends (infer Item)[] ? Item : T;\n\n// 함수의 반환 타입을 가져오고, 그 외의 경우에는 undefined로 지정하는 타입을 작성할 수도 있습니다.\ntype GetReturnType\u003cType\u003e = Type extends (...args: any[]) =\u003e infer Return ? Return : undefined;\n\ntype Num = GetReturnType\u003c() =\u003e number\u003e; // number 타입으로 지정됨\n\ntype Str = GetReturnType\u003c(x: string) =\u003e string\u003e; // string 타입으로 지정됨\n\ntype Bools = GetReturnType\u003c(a: boolean, b: boolean) =\u003e void\u003e; // undefined 타입으로 지정됨\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 튜플 Optional Elements와 Rest: 튜플에서 `?`를 사용하여 옵셔널 요소를 선언하고, 다른 타입을 기반으로 나머지 요소를 사용할 수 있습니다.\n\n```js\n// 튜플의 길이를 아직 알 수 없지만 적어도 한 개는 있는 경우, `?`를 사용하여 옵셔널 타입을 지정할 수 있습니다.\nconst list: [number, number?, boolean?] = [];\nlist[0] // number 타입으로 지정됩니다\nlist[1] // number 또는 undefined 타입으로 지정됩니다\nlist[2] // boolean 또는 undefined 타입으로 지정됩니다\nlist[3] // Type error: 길이가 '3'인 '[number, (number | undefined)?, (boolean | undefined)?]' 형식의 튜플에는 '3' 인덱스 요소가 없습니다.\n\n// 기존 타입을 기반으로 튜플을 사용할 수도 있습니다.\n// 배열의 시작 부분에 패딩을 추가하려면 나머지 연산자 `...`를 사용할 수 있습니다.\nfunction padStart\u003cT extends any[]\u003e(arr: T, pad: string): [string, ...T] {\n  return [pad, ...arr];\n}\n\nconst padded = padStart([1, 2], 'test'); // [string, number, number] 타입으로 지정됩니다\n```\n\n- 추상 클래스와 메소드: 클래스와 그 내부 메소드를 추상으로 선언하여 인스턴스화되지 않도록 할 수 있습니다.\n\n```js\nabstract class Animal {\n  abstract makeSound(): void;\n\n  move(): void {\n    console.log('roaming the earth...');\n  }\n}\n\n// 추상 메소드는 확장 시 구현되어야 합니다.\nclass Cat extends Animal {} // 컴파일 오류: 추상 클래스 'Animal'로부터 상속된 추상 멤버 'makeSound'가 구현되지 않은 비-추상 클래스 'Cat'입니다.\n\nclass Dog extends Animal {\n  makeSound() {\n    console.log('woof');\n  }\n}\n\n// 추상 클래스는 (인터페이스처럼) 인스턴스화할 수 없으며, 추상 메소드는 호출할 수 없습니다.\nnew Animal(); // 컴파일 오류: 추상 클래스의 인스턴스를 생성할 수 없습니다.\n\nconst dog = new Dog().makeSound(); // \"woof\"가 출력됩니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 생성자 서명: 클래스 선언 외부에서 생성자의 유형을 정의합니다. 대부분의 경우에 사용되지 않아야 하며, 추상 클래스 대신 사용할 수 있습니다.\n\n```js\ninterface MyInterface {\n  name: string;\n}\n\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\n\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nclass AnotherTest {\n  age: number;\n}\n\nfunction makeObj(n: ConstructsMyInterface) {\n  return new n('hello!');\n}\n\nconst obj = makeObj(Test); // Test로 타입 지정됨\nconst anotherObj = makeObj(AnotherTest); // 타입 오류: 'AnotherTest'의 유형은 'ConstructsMyInterface'의 매개변수에 할당할 수 없습니다.\n```\n\n- ConstructorParameters 유틸리티 타입: TypeScript 도우미 함수로, 생성자 타입에서 생성자 매개변수를 가져옵니다 (클래스에서 가져오는 것이 아닙니다).\n\n```js\n// makeObj 함수에 생성자 인수를 얻고 싶다면?\ninterface MyInterface {\n  name: string;\n}\n\ninterface ConstructsMyInterface {\n  new(name: string): MyInterface;\n}\n\nclass Test implements MyInterface {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\nfunction makeObj(test: ConstructsMyInterface, ...args: ConstructorParameters\u003cConstructsMyInterface\u003e) {\n  return new test(...args);\n}\n\nmakeObj(Test); // 타입 오류: 2개의 매개변수가 필요하지만 1개만 전달되었습니다.\nconst obj = makeObj(Test, 'test'); // Test로 타입 지정됨\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## TypeScript 4.0\n\n- Variadic Tuple Types: 튜플에서의 나머지 요소는 이제 제네릭할 수 있습니다. 여러 개의 나머지 요소를 사용하는 것도 허용됩니다.\n\n```js\n// 만약 길이와 타입이 정의되지 않은 두 튜플을 결합하는 함수가 있다면 어떨까요? 반환 타입을 어떻게 정의할 수 있을까요?\n\n// 이전:\n// 우리는 몇 가지 오버로드를 작성할 수 있었습니다.\ndeclare function concat(arr1: [], arr2: []): [];\ndeclare function concat\u003cA\u003e(arr1: [A], arr2: []): [A];\ndeclare function concat\u003cA, B\u003e(arr1: [A], arr2: [B]): [A, B];\n// 이하 생략\n\n// 대신에 타입을 결합할 수 있습니다.\ndeclare function concatBetter\u003cT, U\u003e(arr1: T[], arr2: U[]): (T | U)[];\n// 그러나 이것은 (T | U)[]로 타입이 지정됩니다.\n\n// 새로운 기능:\n// 가변 길이 튜플 타입을 사용하면 쉽게 정의할 수 있고 길이 정보를 유지할 수 있습니다.\ndeclare function concatNew\u003cT extends Arr, U extends Arr\u003e(arr1: T, arr2: U): [...T, ...U];\n\nconst tuple = concatNew([23, 'hey', false] as [number, string, boolean], [5, 99, 20] as [number, number, number]);\nconsole.log(tuple[0]); // 23\nconst element: number = tuple[1]; // 타입 오류: 타입 'string'을 'number'에 할당할 수 없습니다.\nconsole.log(tuple[6]); // 타입 오류: 길이 '6'인 튜플 타입 '[23, \"hey\", false, 5, 99, 20]'에는 인덱스 '6'에 요소가 없습니다.\n```\n\n- Labeled Tuple Elements: 튜플 요소는 이제 [start: number, end: number]와 같이 이름을 지정할 수 있습니다. 요소 중 하나가 이름이 지정되면 모두 이름이 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n혹시 클래스 생성자에서 속성이 설정될 때 속성의 타입을 자동으로 추론할 수 있어서 더 이상 수동으로 설정할 필요가 없습니다.\n\n```js\nclass Animal {\n  // 생성자에서 할당될 때 타입을 설정할 필요가 없습니다.\n  name;\n\n  constructor(name: string) {\n    this.name = name;\n    console.log(this.name); // 문자열로 타입이 지정됨\n  }\n}\n```\n\n- JSDoc @deprecated 지원: JSDoc/TSDoc의 @deprecated 태그가 TypeScript에서 인식됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n/** @deprecated 메시지 */\ntype Test = string;\n\nconst test: Test = 'dfadsf'; // 타입 오류: '테스트'가 사용되지 않습니다.\n```\n\n## TypeScript 4.1\n\n- 템플릿 리터럴 타입: 리터럴 타입을 정의할 때, '$'를 이용하여 템플릿을 활용할 수 있습니다. 이를 통해 여러 개의 문자열 리터럴을 조합하는 등 복잡한 문자열 타입을 만들 수 있습니다.\n\n```js\ntype VerticalDirection = 'top' | 'bottom';\ntype HorizontalDirection = 'left' | 'right';\ntype Direction = `${VerticalDirection} ${HorizontalDirection}`;\n\nconst dir1: Direction = 'top left';\nconst dir2: Direction = 'left'; // 타입 오류: '\"left\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.\nconst dir3: Direction = 'left top'; // 타입 오류: '\"left top\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.\n\n// 이는 제네릭 및 새로운 유틸리티 타입과도 결합할 수 있습니다.\ndeclare function makeId\u003cT extends string, U extends string\u003e(first: T, second: U): `${Capitalize\u003cT\u003e}-${Lowercase\u003cU\u003e}`;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 키 다시 매핑하기: 매핑된 타입을 다시 정의하여 그 값들을 사용할 수 있습니다. [K in keyof T as NewKeyType]: T[K].\n\n```js\n// 예를 들어, 객체를 다시 포맷하되 그 ID 앞에 밑줄을 추가하고 싶다고 가정해 봅시다.\nconst obj = { value1: 0, value2: 1, value3: 3 };\nconst newObj: { [Property in keyof typeof obj as `_${Property}`]: number }; // { _value1: number; _value2: number; value3: number; }로 타입이 지정됩니다.\n```\n\n- 재귀 조건부 타입: 조건부 타입을 해당 정의 내부에서 사용합니다. 이를 통해 무한히 중첩된 값을 조건부적으로 언패킹하는 타입을 생성할 수 있습니다.\n\n```js\ntype Awaited\u003cT\u003e = T extends PromiseLike\u003cinfer U\u003e ? Awaited\u003cU\u003e : T;\n\ntype P1 = Awaited\u003cstring\u003e; // string으로 타입이 지정됩니다.\ntype P2 = Awaited\u003cPromise\u003cstring\u003e\u003e; // string으로 타입이 지정됩니다.\ntype P3 = Awaited\u003cPromise\u003cPromise\u003cstring\u003e\u003e\u003e; // string으로 타입이 지정됩니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- JSDOC @see 태그를 지원하는 편집기: 이제 편집기에서 JSDoc/TSDoc @see 변수/유형/링크 태그가 지원됩니다.\n\n```js\nconst originalValue = 1;\n/**\n * 다른 값의 복사본\n * @see originalValue\n */\nconst value = originalValue;\n```\n\n- tsc --explainFiles: --explainFiles 옵션은 TypeScript CLI에서 컴파일에 사용된 파일과 그 이유를 설명해주는 데 사용될 수 있습니다. 이는 디버깅에 유용할 수 있습니다. 경고: 대규모 프로젝트나 복잡한 설정의 경우 많은 출력물이 생성됩니다. 대신 tsc --explainFiles | less 또는 비슷한 방법을 사용하십시오.\n\n```js\ntsc --explainFiles\n\n\u003c\u003coutput\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es5.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'에서 'es5'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'에서 'es5'로 참조되는 라이브러리\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'에서 'es2015'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'에서 'es2015'로 참조되는 라이브러리\n../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'에서 'es2016'로 참조되는 라이브러리\n  파일 '../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'에서 'es2016'로 참조되는 라이브러리\n...\noutput\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Destructured 변수는 명시적으로 사용되지 않음을 표시할 수 있습니다: 구조 분해할 때 밑줄을 사용하여 변수가 사용되지 않음을 표시할 수 있습니다. 이를 통해 TypeScript에서 \"사용되지 않는 변수\" 오류를 방지할 수 있습니다.\n\n```js\nconst [_first, second] = [3, 5];\nconsole.log(second);\n\n// 심지어 더 짧게\nconst [_, value] = [3, 5];\nconsole.log(value);\n```\n\n## TypeScript 4.3\n\n- 속성에 대한 별도의 쓰기 유형: set/get 접근자를 정의할 때, 쓰기/설정 형식이 읽기/가져오기 형식과 다를 수 있습니다. 이를 통해 동일한 값의 여러 형식을 수락하는 setter를 정의할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass Test {\n  private _value: number;\n\n  get value(): number {\n    return this._value;\n  }\n\n  set value(value: number | string) {\n    if (typeof value === 'number') {\n      this._value = value;\n      return;\n    }\n    this._value = parseInt(value, 10);\n  }\n}\n```\n\n- override: 상속된 클래스 메서드를 명확하게 오버라이드로 표시하기 위해 override를 사용하세요. 부모 클래스가 변경되면 TypeScript에서 부모 메서드가 더 이상 존재하지 않음을 알려줄 수 있습니다. 이를 통해 더 안전한 복잡한 상속 패턴을 구현할 수 있습니다.\n\n```js\nclass Parent {\n  getName(): string {\n    return 'name';\n  }\n}\n\nclass NewParent {\n  getFirstName(): string {\n    return 'name';\n  }\n}\n\nclass Test extends Parent {\n  override getName(): string {\n    return 'test';\n  }\n}\n\nclass NewTest extends NewParent {\n  override getName(): string { // Type error: This member cannot have an 'override' modifier because it is not declared in the base class 'NewParent'.\n    return 'test';\n  }\n}\n```\n\n- static Index Signatures: 클래스에서 정적 속성을 사용할 때, 정적 [propName: string]: string을 사용하여 색인 서명을 설정할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 이전 코드:\nclass Test {}\n\nTest.test = ''; // 타입 오류: 'test' 속성을 'Test' 형식에서 찾을 수 없습니다.\n\n// 새로운 코드:\nclass NewTest {\n  static [key: string]: string;\n}\n\nNewTest.test = '';\n```\n\n- JSDOC @link 태그를 위한 편집기 지원: JSDoc/TSDoc의 '@link 변수/타입/링크' 인라인 태그가 이제 지원되며 편집기에서 표시되고 해결됩니다.\n\n```js\nconst originalValue = 1;\n/**\n * {@link originalValue}의 복사본\n */\nconst value = originalValue;\n```\n\n## TypeScript 4.4\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 정확한 선택적 속성 유형 (--exactOptionalPropertyTypes): 컴파일러 플래그 --exactOptionalPropertyTypes (또는 tsconfig.json에)를 사용하면, 암시적으로 undefined를 허용하는 속성에 대해 undefined로 할당하는 것이 허용되지 않습니다 (예: property?: string). 대신, property: string | undefined와 같이 명시적으로 undefined를 허용해야 합니다.\n\n```js\nclass Test {\n  name?: string;\n  age: number | undefined;\n}\n\nconst test = new Test();\ntest.name = undefined; // 타입 오류: 'exactOptionalPropertyTypes: true'를 사용하여 'undefined' 타입을 'string'에 할당할 수 없습니다. 대상의 유형에 'undefined'를 추가하는 것을 고려해보세요.\ntest.age = undefined;\nconsole.log(test.age); // undefined\n```\n\n## TypeScript 4.5\n\n- Awaited`` 유형 및 Promise 개선: 새로운 Awaited`` 유틸리티 유형은 무한히 중첩된 Promises에서 값 유형을 추출합니다 (값에 대해 await이 하는 것과 같이). 이는 또한 Promise.all()에 대한 유형 추론을 개선했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 제네릭 대기값을 가지고 싶다고 가정해 봅시다.\n// 이러한 경우 Awaited 유틸리티 타입을 사용할 수 있습니다 (소스 코드는 이전 예제의 일부였습니다).\n// 따라서 무한하게 중첩된 Promises가 모두 값으로 해결됩니다.\ntype P1 = Awaited\u003cstring\u003e; // 문자열로 타입 지정\ntype P2 = Awaited\u003cPromise\u003cstring\u003e\u003e; // 문자열로 타입 지정\ntype P3 = Awaited\u003cPromise\u003cPromise\u003cstring\u003e\u003e\u003e; // 문자열로 타입 지정\n```\n\n- Import 이름에 대한 유형 수식어: 일반 (import type 아닌) import 문 안에서 type 키워드를 사용하여 해당 값이 유형 컴파일을 위해만 가져와야 함을 신호로 삼을 수 있습니다 (컴파일 후에 제거할 수 있습니다).\n\n```js\n// 이전:\n// 유형을 가져오는 가장 좋은 방법은 `import type` 키워드를 사용하여 컴파일 이후에 실제로 가져오지 않도록 하는 것입니다.\nimport { something } from './file';\nimport type { SomeType } from './file';\n// 이 파일에 대해 두 개의 import 문이 필요했습니다.\n\n// 새로운:\n// 이제 이를 하나의 문으로 결합할 수 있습니다.\nimport { something, type SomeType } from './file';\n```\n\n- Const 어순: 상수를 정의할 때 const 키워드를 사용하여 이를 리터럴 타입으로 정확하게 지정할 수 있습니다. 이는 다양한 용례가 있으며 정확한 유형 정의가 쉬워집니다. 또한 상수 객체와 배열은 읽기 전용이 되어 상수 객체의 변이를 방지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 이전:\nconst obj = { name: 'foo', value: 9, toggle: false }; // { name: string; value: number; toggle: boolean; }으로 타입 지정됨\n// 일반적으로 타입이 지정되어 있으므로 어느 값이든 할당 가능합니다.\nobj.name = 'bar';\n\nconst tuple = ['name', 4, true]; // (string | number | boolean)[]으로 타입 지정됨\n// 타입으로 길이와 정확한 형식을 결정할 수 없습니다. 어떤 값이든 어디에든 할당할 수 있습니다.\ntuple[0] = 0;\ntuple[3] = 0;\n\n// 새로운 방식:\nconst objNew = { name: 'foo', value: 9, toggle: false } as const; // { readonly name: \"foo\"; readonly value: 9; readonly toggle: false; }으로 타입 지정됨\n// 값을 할당할 수 없습니다 (\"foo\"(그리고 readonly로 정의되었기 때문).\nobjNew.name = 'bar'; // 타입 에러: 'name'에 할당할 수 없습니다. 읽기 전용 속성입니다.\n\nconst tupleNew = ['name', 4, true] as const; // readonly [\"name\", 4, true]으로 타입 지정됨\n// 이제 길이와 정확한 형식이 정의되어 있고, 값을 할당할 수 없습니다 (리터럴로 정의되었으며 readonly).\ntupleNew[0] = 0; // 타입 에러: '0'에 할당할 수 없습니다. 읽기 전용 속성입니다.\ntupleNew[3] = 0; // 타입 에러: 'readonly[\"name\", 4, true]'에 있는 인덱스 서명에는 읽기만 허용됩니다.\n```\n\n- 클래스 내의 메서드에 대한 코드 조각 완성: 클래스가 메서드 타입을 상속하면 편집기에서 코드 조각으로 제안됩니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:800/1*31No189vLt2Kdx5Ay_Ihig.gif\" /\u003e\n\n## TypeScript 4.6\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 인덱스된 액세스 추론 개선: 키로 직접 타입을 색인화할 때, 이제 같은 객체에 있는 경우 타입이 더 정확해집니다. 현대적인 TypeScript로 어떤 것이 가능한지 보여주는 좋은 예시입니다.\n\n```js\ninterface AllowedTypes {\n  'number': number;\n  'string': string;\n  'boolean': boolean;\n}\n\n// Record는 허용된 타입의 종류와 값 타입을 지정합니다.\ntype UnionRecord\u003cAllowedKeys extends keyof AllowedTypes\u003e = { [Key in AllowedKeys]:\n{\n  kind: Key;\n  value: AllowedTypes[Key];\n  logValue: (value: AllowedTypes[Key]) =\u003e void;\n}\n}[AllowedKeys];\n\n// 함수 logValue는 Record의 값만을 허용합니다.\nfunction processRecord\u003cKey extends keyof AllowedTypes\u003e(record: UnionRecord\u003cKey\u003e) {\n  record.logValue(record.value);\n}\n\nprocessRecord({\n  kind: 'string',\n  value: 'hello!',\n\n  // 값이 암묵적으로 string | number | boolean 타입을 가졌던 것이\n  // 이제 올바르게 오직 string으로 추론됩니다.\n  logValue: value =\u003e {\n    console.log(value.toUpperCase());\n  }\n});\n```\n\n- TypeScript 추적 분석기 (--generateTrace): --generateTrace '출력 폴더' 옵션을 사용하여 TypeScript CLI가 타입 검사 및 컴파일 프로세스에 대한 자세한 내용을 포함한 파일을 생성할 수 있습니다. 이는 복잡한 타입을 최적화하는 데 도움이 될 수 있습니다.\n\n```js\ntsc --generateTrace trace\n\ncat trace/trace.json\n\u003c\u003c출력\n[\n{\"name\":\"process_name\",\"args\":{\"name\":\"tsc\"},\"cat\":\"__metadata\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"name\":\"thread_name\",\"args\":{\"name\":\"Main\"},\"cat\":\"__metadata\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"name\":\"TracingStartedInBrowser\",\"cat\":\"disabled-by-default-devtools.timeline\",\"ph\":\"M\",\"ts\":...,\"pid\":1,\"tid\":1},\n{\"pid\":1,\"tid\":1,\"ph\":\"B\",\"cat\":\"program\",\"ts\":...,\"name\":\"createProgram\",\"args\":{\"configFilePath\":\"/...\",\"rootDir\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"B\",\"cat\":\"parse\",\"ts\":...,\"name\":\"createSourceFile\",\"args\":{\"path\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"E\",\"cat\":\"parse\",\"ts\":...,\"name\":\"createSourceFile\",\"args\":{\"path\":\"/...\"},\n{\"pid\":1,\"tid\":1,\"ph\":\"X\",\"cat\":\"program\",\"ts\":...,\"name\":\"resolveModuleNamesWorker\",\"dur\":...,\"args\":{\"containingFileName\":\"/...\"},\n...\n출력\n\ncat trace/types.json\n\u003c\u003c출력\n[{\"id\":1,\"intrinsicName\":\"any\",\"recursionId\":0,\"flags\":[\"...\"]},\n{\"id\":2,\"intrinsicName\":\"any\",\"recursionId\":1,\"flags\":[\"...\"]},\n{\"id\":3,\"intrinsicName\":\"any\",\"recursionId\":2,\"flags\":[\"...\"]},\n{\"id\":4,\"intrinsicName\":\"error\",\"recursionId\":3,\"flags\":[\"...\"]},\n{\"id\":5,\"intrinsicName\":\"unresolved\",\"recursionId\":4,\"flags\":[\"...\"]},\n{\"id\":6,\"intrinsicName\":\"any\",\"recursionId\":5,\"flags\":[\"...\"]},\n{\"id\":7,\"intrinsicName\":\"intrinsic\",\"recursionId\":6,\"flags\":[\"...\"]},\n{\"id\":8,\"intrinsicName\":\"unknown\",\"recursionId\":7,\"flags\":[\"...\"]},\n{\"id\":9,\"intrinsicName\":\"unknown\",\"recursionId\":8,\"flags\":[\"...\"]},\n{\"id\":10,\"intrinsicName\":\"undefined\",\"recursionId\":9,\"flags\":[\"...\"]},\n{\"id\":11,\"intrinsicName\":\"undefined\",\"recursionId\":10,\"flags\":[\"...\"]},\n{\"id\":12,\"intrinsicName\":\"null\",\"recursionId\":11,\"flags\":[\"...\"]},\n{\"id\":13,\"intrinsicName\":\"string\",\"recursionId\":12,\"flags\":[\"...\"]},\n...\n출력\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## TypeScript 4.7\n\n- Node.js에서 ECMAScript 모듈 지원: CommonJS 대신 ES 모듈을 사용할 때, TypeScript가 이제 default를 지정할 수 있습니다. tsconfig.json에서 지정하세요.\n\n```js\n...\n\"compilerOptions\": [\n  ...\n  \"module\": \"es2020\"\n]\n...\n```\n\n- package.json의 type: package.json의 type 필드를 \"module\"로 설정할 수 있습니다. 이것은 Node.js와 ES 모듈을 사용하기 위해 필요합니다. 대부분의 경우에 TypeScript에 충분하며 위의 컴파일러 옵션이 필요하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n...\n\"type\": \"module\"\n...\n```\n\n- 인스턴스화 표현식: 인스턴스화 표현식을 사용하면 값을 참조할 때 유형 매개변수를 지정할 수 있습니다. 이를 통해 래퍼를 생성하지 않고 일반적인 유형을 좁힐 수 있습니다.\n\n```js\nclass List\u003cT\u003e {\n  private list: T[] = [];\n\n  get(key: number): T {\n    return this.list[key];\n  }\n\n  push(value: T): void {\n    this.list.push(value);\n  }\n}\n\nfunction makeList\u003cT\u003e(items: T[]): List\u003cT\u003e {\n  const list = new List\u003cT\u003e();\n  items.forEach(item =\u003e list.push(item));\n  return list;\n}\n\n// 특정 값만 허용하는 목록을 만드는 함수가 필요한 경우를 가정해 봅시다.\n// 이전:\n// 직접 래퍼 함수를 정의하고 인수를 전달해야 했습니다.\nfunction makeStringList(text: string[]) {\n  return makeList(text);\n}\n\n// 새로운 방법:\n// 인스턴스화 표현식을 사용하면 훨씬 쉽습니다.\nconst makeNumberList = makeList\u003cnumber\u003e;\n```\n\n- 추론된 유형 변수에 대한 extend 제한: 조건부 유형에서 유형 변수를 추론할 때, extends를 사용하여 직접 좁히거나 제한할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 배열의 첫 번째 요소가 문자열인 경우에만 해당 요소를 가져오는 유형을 작성하려고 한다고 가정해 봅시다.\n// 이를 위해 조건부 유형을 사용할 수 있습니다.\n\n// 이전:\ntype FirstIfStringOld\u003cT\u003e =\n  T extends [infer S, ...unknown[]]\n    ? S extends string ? S : never\n    : never;\n\n// 그러나 이 방법은 두 개의 중첩된 조건부 유형이 필요합니다. 이를 하나의 유형으로도 할 수 있습니다.\ntype FirstIfString\u003cT\u003e =\n  T extends [string, ...unknown[]]\n    // `T`에서 첫 번째 유형을 가져옵니다.\n    ? T[0]\n    : never;\n\n// 이것도 여전히 최적화되지 않은 상태이며 올바른 유형을 위해 배열을 인덱싱해야 합니다.\n\n// 새로운 방식:\n// 추론된 유형 변수에 extends 제약 조건을 사용하여 이를 더 간단하게 선언할 수 있습니다.\ntype FirstIfStringNew\u003cT\u003e =\n  T extends [infer S extends string, ...unknown[]]\n    ? S\n    : never;\n// 유형을 알아내는 방식은 이전과 동일하지만 더 깔끔한 구문입니다.\n\ntype A = FirstIfStringNew\u003c[string, number, number]\u003e; // string으로 유형 지정\ntype B = FirstIfStringNew\u003c[\"hello\", number, number]\u003e; // \"hello\"로 유형 지정\ntype C = FirstIfStringNew\u003c[\"hello\" | \"world\", boolean]\u003e; // \"hello\" 또는 \"world\"로 유형 지정\ntype D = FirstIfStringNew\u003c[boolean, number, string]\u003e; // never로 유형 지정\n```\n\n- 유형 매개변수를 위한 선택적 분산 주석: 제네릭은 \"일치하는지\" 확인할 때 다른 동작을 가질 수 있습니다. 예를 들어, 상속을 허용할 경우 getters 및 setters에 대해 반대로 반전됩니다. 이제 이를 명시적으로 지정할 수 있습니다.\n\n```js\n// 다른 인터페이스 / 클래스를 확장하는 인터페이스가 있다고 가정해 봅시다.\ninterface Animal {\n  animalStuff: any;\n}\n\ninterface Dog extends Animal {\n  dogStuff: any;\n}\n\n// 그리고 일반적인 \"getter\" 및 \"setter\"가 있습니다.\ntype Getter\u003cT\u003e = () =\u003e T;\n\ntype Setter\u003cT\u003e = (value: T) =\u003e void;\n\n// Getter\u003cT1\u003e과 Getter\u003cT2\u003e 또는 Setter\u003cT1\u003e과 Setter\u003cT2\u003e가 일치하는지 확인하려면 분산에 따라 달라집니다.\nfunction useAnimalGetter(getter: Getter\u003cAnimal\u003e) {\n  getter();\n}\n\n// 이제 함수에 Getter를 전달할 수 있습니다.\nuseAnimalGetter((() =\u003e ({ animalStuff: 0 }) as Animal));\n// 당연히 작동합니다.\n\n// 그러나 Dog를 반환하는 Getter를 사용하려면 어떻게 해야 할까요?\nuseAnimalGetter((() =\u003e ({ animalStuff: 0, dogStuff: 0 }) as Dog));\n// 이 또한 작동합니다. 왜냐하면 Dog도 Animal이기 때문입니다.\n\nfunction useDogGetter(getter: Getter\u003cDog\u003e) {\n  getter();\n}\n\n// useDogGetter 함수에 동일한 작업을 시도하면 동일한 동작을 얻지 못할 것입니다.\nuseDogGetter((() =\u003e ({ animalStuff: 0 }) as Animal); // Type error: Property 'dogStuff' is missing in type 'Animal' but required in type 'Dog'.\n// 이는 Animal이 아닌 Dog가 필요하기 때문에 작동하지 않습니다.\n\nuseDogGetter((() =\u003e ({ animalStuff: 0, dogStuff: 0 }) as Dog);\n// 그러나 이 경우는 작동합니다.\n\n// 직관적으로 Setters가 같은 방식으로 작동할 것으로 기대할 수도 있지만, 사실은 그렇지 않습니다.\nfunction setAnimalSetter(setter: Setter\u003cAnimal\u003e, value: Animal) {\n  setter(value);\n}\n\n// 동일한 유형의 Setter를 전달해도 작동합니다.\nsetAnimalSetter((value: Animal) =\u003e {}, { animalStuff: 0 });\n\nfunction setDogSetter(setter: Setter\u003cDog\u003e, value: Dog) {\n  setter(value);\n}\n\n// 여기도 마찬가지로 작동합니다.\nsetDogSetter((value: Dog) =\u003e {}, { animalStuff: 0, dogStuff: 0 });\n\n// 그러나 Dog Setter를 setAnimalSetter 함수에 전달하면 Getter와는 반대로 동작이 반전됩니다.\nsetAnimalSetter((value: Dog) =\u003e {}, { animalStuff: 0, dogStuff: 0 }); // Type error: Argument of type '(value: Dog) =\u003e void' is not assignable to parameter of type 'Setter\u003cAnimal\u003e'.\n\n// 이번에는 상황이 반대로 작동합니다.\nsetDogSetter((value: Animal) =\u003e {}, { animalStuff: 0, dogStuff: 0 });\n\n// 새로운 방법:\n// TypeScript에이를 표시하기 위해 (필수는 아니지만 가독성을 위해 유용), 유형 매개변수에 대한 선택적 분산 주석을 사용합니다.\ntype GetterNew\u003cout T\u003e = () =\u003e T;\ntype SetterNew\u003cin T\u003e = (value: T) =\u003e void;\n```\n\n- moduleSuffixes로 해상도 사용자 정의: 사용자 정의 파일 접미사를 사용하는 환경(예: 네이티브 앱 빌드에 .ios를 사용하는 경우)에서는 TypeScript가 가져오기를 정확하게 해석하도록 이 접미사를 tsconfig.json에 지정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n...\n\"compilerOptions\": [\n  ...\n  \"moduleSuffixes\": [\".ios\", \".native\", \"\"]\n]\n...\n```\n\n```js\nimport * as foo from './foo';\n// 이 코드는 먼저 ./foo.ios.ts를 확인하고, 그 다음에는 ./foo.native.ts를, 마지막으로 ./foo.ts를 확인합니다.\n```\n\n- 에디터에서 소스 정의로 이동: 에디터에서 새로운 \"소스 정의로 이동\" 메뉴 옵션이 사용 가능합니다. 이는 \"정의로 이동\"과 유사하지만, .ts 및 .js 파일을 .d.ts 타입 정의 파일보다 우선합니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:800/1*y45nF8mb-nfBuVIUPt7KJQ.gif\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*qvzGqfF844cXCPMeDrg_IQ.gif)\n\n## TypeScript 4.9\n\n- `satisfies` 연산자: `satisfies` 연산자는 실제로 그 타입을 할당하지 않고도 타입과의 호환성을 확인할 수 있게 해줍니다. 이를 통해 더 정확한 추론된 타입을 유지하면서도 호환성을 유지할 수 있습니다.\n\n```js\n// 이전:\n// 여러 항목과 그 색상을 저장하는 객체/맵/딕셔너리가 있다고 가정해 보겠습니다.\nconst obj = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} // { fireTruck: number[]; bush: string; ocean: number[]; } 타입으로 정의됨\n\n// 배열과 문자열에 대해 작업을 수행할 수 있도록 속성을 암시적으로 타입 지정합니다.\nconst rgb1 = obj.fireTruck[0]; // 숫자로 타입 지정\nconst hex = obj.bush; // 문자열로 타입 지정\n\n// 특정 객체만 허용하고 싶다면 Record 타입을 사용할 수 있습니다.\nconst oldObj: Record\u003cstring, [number, number, number] | string\u003e = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} // Record\u003cstring, [number, number, number] | string\u003e 타입으로 정의됨\n// 하지만 이제 우리는 속성의 타입에 대한 정보를 잃어버립니다.\nconst oldRgb1 = oldObj.fireTruck[0]; // string 또는 number로 타입 지정\nconst oldHex = oldObj.bush; // string 또는 number로 타입 지정\n\n// 새롭게:\n// `satisfies` 키워드를 사용하여 타입과 호환성을 확인할 수 있습니다.\nconst newObj = {\n  fireTruck: [255, 0, 0],\n  bush: '#00ff00',\n  ocean: [0, 0, 255]\n} satisfies Record\u003cstring, [number, number, number] | string\u003e // { fireTruck: [number, number, number]; bush: string; ocean: [number, number, number]; } 타입으로 정의됨\n// 이제 속성의 타입에 대한 정보를 유지할 수 있을 뿐만 아니라 배열은 튜플로 더 정확해집니다.\nconst newRgb1 = newObj.fireTruck[0]; // 숫자로 타입 지정\nconst newRgb4 = newObj.fireTruck[3]; // 타입 오류: 길이가 '3'인 튜플 타입 '[number, number, number]'에는 인덱스 '3'에 해당하는 요소가 없습니다.\nconst newHex = newObj.bush; // 문자열로 타입 지정\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 편집기의 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령: 편집기에서 새로운 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령(및 자동 수정)을 사용하면 Imports를 관리하는 것이 더 쉬워집니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*z5SG6BKwzyxrG6sG7OKciw.gif)\n\n## TypeScript 5.0\n\n- ES 데코레이터 지원: TypeScript는 이제 ES 데코레이터(곧 나올 ES 기능)를 지원하며, 기존 데코레이터와는 다릅니다. 이전에 TypeScript는 데코레이터에 대해 실험적인 지원을 했었는데, 이는 Angular와 같은 프레임워크에서 사용되는 것으로, --experimentalDecorators 플래그(또는 tsconfig.json에서)로 선택할 수 있었으며 약간 다르게 동작했습니다. 그러나 이제 새로운 ES 데코레이터는 이전 것과는 다르게 메타데이터를 내보내지 못하며 아직은 매개변수에서도 지원되지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 주의: 2023년 5월 기준으로 이것은 예정된 ES 기능이므로 이 코드는 아직 작동하지 않습니다.\n\n// 디버깅 중에 메서드에 진입하거나 나갈 때마다 기록하려고 합니다.\n// 이것을 수동으로 하는 것은 상당히 지루할 수 있습니다. 자동화할 방법이 있을까요?\n// 네, 데코레이터를 사용하여 실행 컨텍스트를 대체할 수 있습니다.\n\n// 먼저 데코레이터 역할을 할 함수를 정의합니다. 이 함수는 원본 메서드와 컨텍스트 개체를 매개변수로 받아 새로운 실행 함수를 반환합니다.\nfunction logMethod\u003cThis, Args extends any[], Return\u003e(originalMethod: (this: This, ...args: Args) =\u003e Return, context: ClassMethodDecoratorContext) {\n  const methodName = String(context.name);\n\n  function replacementFunction(this: This, ...args: Args) {\n    console.log(`LOG: 메서드 '${methodName}' 진입 중.`)\n    const result = originalMethod.call(this, ...args);\n    console.log(`LOG: 메서드 '${methodName}' 나감.`)\n    return result;\n  }\n\n  return replacementFunction;\n}\n\n// 이제 이를 사용할 클래스를 정의합니다. 데코레이터는 클래스와 그 멤버에만 작동합니다.\n// 메서드에 '@'와 함수명을 사용하여 데코레이터를 적용합니다.\nclass Test {\n  @logMethod\n  doSomething() {\n    return '작업 중';\n  }\n}\n\nconst testObj = new Test();\n\n// 메서드를 실행하면 대체 메서드가 호출됩니다.\nconsole.log(testObj.doSomething()); // \"LOG: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"LOG: 메서드 'doSomething' 나감.\"\n\n// 사용자 정의 메시지와 같은 추가 인수를 전달하려면 데코레이터 팩토리(데코레이터 함수를 반환하는 함수)를 정의할 수 있습니다.\nfunction logMethodCustom(customMessage: string) {\n  return \u003cThis, Args extends any[], Return\u003e(originalMethod: (this: This, ...args: Args) =\u003e Return, context: ClassMethodDecoratorContext) =\u003e {\n    const methodName = String(context.name);\n\n    function replacementFunction(this: This, ...args: Args) {\n      console.log(`${customMessage}: 메서드 '${methodName}' 진입 중.`)\n      const result = originalMethod.call(this, ...args);\n      console.log(`${customMessage}: 메서드 '${methodName}' 나감.`)\n      return result;\n    }\n\n    return replacementFunction;\n  }\n}\n\n// 이번에는 함수 호출을 포함하는 `()`로 된 추가 인수를 사용하여 메서드에 데코레이터를 적용합니다.\nclass TestCustom {\n  @logMethodCustom('테스트 로그')\n  doSomething() {\n    return '작업 중';\n  }\n}\n\nconst testCustomObj = new Test();\n\n// 메서드 실행시 모든 작업이 예상대로 작동합니다.\nconsole.log(testCustomObj.doSomething()); // \"테스트 로그: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"테스트 로그: 메서드 'doSomething' 나감.\"\n\n// 데코레이터 함수에서 대체 메서드를 반환하지 않으면 원본 메서드가 호출되지만 관련 설정을 아직 설정할 수 있습니다.\n// 예를 들어 `constructor` 단계 이전에 `this`를 바인딩하여 클래스 외부에서 콜백으로 전달할 경우 동일하게 실행되도록합니다.\n// `constructor` 단계 이전에 코드를 실행하려면 컨텍스트 개체의 `addInitializer` 메서드를 사용할 수 있습니다.\nfunction bindThis(_: unknown, context: ClassMethodDecoratorContext) {\nconst methodName = context.name;\nif (context.private) {\n  throw new Error(`'bound'는 ${methodName as string}과 같은 비공개 속성을 데코레이션할 수 없습니다.`);\n}\ncontext.addInitializer(function (this: any) {\n  const methodName = context.name;\n    if (typeof methodName === 'string') {\n      this[methodName] = this[methodName].bind(this);\n    }\n  });\n}\n\n// 바인딩하지 않은 상태로 한번 정의합니다.\nclass TestUnbound {\n  private returnVal = '작업 중';\n\n  doSomething() {\n    return this.returnVal;\n  }\n}\n\nconst testUnboundObj = new TestUnbound();\n\n// 메서드에 다시 \"데코레이터\"를 적용합니다.\nclass TestBound {\n  private returnVal = '작업 중';\n\n  @bindThis\n  doSomething() {\n    return this.returnVal;\n  }\n}\n\nconst testBoundObj = new TestBound();\n\n// 클래스 컨텍스트 외부에 메서드를 저장하고 실행시키면 속성 값에 액세스할 수 없습니다.\nconst unboundFunc = testUnboundObj.doSomething;\nconsole.log(unboundFunc()); // 오류: \"Cannot read properties of undefined (reading 'returnVal')\"\n\n// 그러나 바인딩하면 예상대로 작동합니다.\nconst boundFunc = testBoundObj.doSomething;\nconsole.log(boundFunc()); // \"작업 중\"\n```\n\n- const 형식 매개변수: 형식 매개변수 앞에 const를 지정하는 const는 readonly 형식을 그대로 사용하는 것처럼 동작하도록 시도합니다. 그러나 변경 가능한 값을 형식화했다면 인자유추가 작동하지 않을 수 있습니다(왜냐하면 읽기전용 형식은 변경 가능한 형식에 할당할 수 없기 때문에 항상 readonly 형식을 상속해야 합니다). 이것은 여전히 허용된 매개변수를 제한하지 않습니다. 여전히 extends 내에서 제한해야 합니다.\n\n- 타입을 활용한 여러 구성 파일 지원: 복잡한 상속 구조를 만들거나 모든 \"tsconfig\"에서 항상 동일한 구성을 확장하거나 모든 설정을 복사하여 모두 복사하는 대신, \"tsconfig\" 파일에서 \"extends\": [\"./tsconfig1.json\", \"./tsconfig2.json\"]를 지정함으로써 여러 파일을 확장하여 동작을 재정의할 수 있습니다. 후자의 파일이 오버라이드 동작을 우선시합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n...\n// 여기서 \"tsconfig1.json\"은 \"@tsconfig/strictest/tsconfig.json\"을 덮어씁니다. \"tsconfig2.json\"은 \"tsconfig1.json\"과 \"@tsconfig/strictest/tsconfig.json\"을 덮어쓰며, 이 파일은 모두 덮어씁니다.\n\"extends\": [\"@tsconfig/strictest/tsconfig.json\", \"./tsconfig1.json\", \"./tsconfig2.json\"],\n...\n```\n\n- 모든 열거형이 합집합 열거형입니다: 동적으로 할당된 열거형 값은 이제 더 이상 예전의 열거형 전략 기본값을 갖지 않습니다(열거형 키에 대한 타입 없음, 값으로만 사용 가능하며 타입으로 사용할 수 없음). 대신 이제 타입으로도 사용할 수 있습니다.\n\n```js\n// 열거형은 각 값마다 다른 타입을 만듭니다.\nenum Color {\n  Red, Green, Blue, Orange, Yellow, Violet\n}\n\n// 이를 통해 그들을 좁히고 다른 타입처럼 사용할 수 있습니다.\ntype PrimaryColor = Color.Red | Color.Green | Color.Blue;\n\n// 하지만:\n// 값이 동적으로 할당되면 고정된 값이 없습니다.\n// 이전에는 예전 열거형 동작으로 되돌아가게 되었습니다.\n// 예전 열거형 동작에서 그 멤버는 값으로만 존재하며 타입으로는 존재하지 않음.\nenum ColorRandom {\n  Red = Math.random(),\n  Green = Math.random(),\n  Blue = Math.random(),\n  Orange = Math.random(),\n  Yellow = Math.random(),\n  Violet = Math.random()\n}\n\n// 그래서 이전에는 좁혀지지 못했습니다.\ntype PrimaryColorRandom = ColorRandom.Red | ColorRandom.Green | ColorRandom.Blue; // 이전 타입 오류: Enum 타입 'ColorRandom'은 리터럴이 아닌 초기화 값을 갖는 멤버를 가지고 있습니다.\n// 하지만 이제 그들에게도 자체 타입이 있기 때문에 작동합니다.\n```\n\n- --moduleResolution bundler: TS 4.7의 모듈 해결 전략 \"node16\"은 ES 모듈을 더 잘 모델링할 수 있게 해주지만 일부 불필요한 제약이 있었습니다(파일 확장자를 명시해야 했으며, ...). 번들러를 사용 중이라면, 새 전략은 최신 기능을 유지하면서 일부 제약을 제거하려고 시도합니다. 컴파일러 플래그 --moduleResolution bundle를 지정하여 사용할 수 있습니다(또는 tsconfig.json에서). 번들러를 사용할 때만 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n...\n\"compilerOptions\": [\n  ...\n  \"moduleResolution\": \"bundler\"\n]\n...\n```\n\n```json\nimport * as foo from './foo';\n// 이제는 파일 확장자가 지정되지 않아도 다시 허용됩니다.\n```\n\n- 해상도 Customization Flags: \"hybrid\" 모듈 해상도에 대한 규칙을 설정합니다. 규칙은 다음과 같습니다: allowImportingTsExtensions, resolvePackageJsonExports (imports를 위해 package.json exports을 고려함), resolvePackageJsonImports (#로 시작하는 경로를 위해 로컬 package.json을 참조함), allowArbitraryExtensions 및 customConditions (node16 및 bundler 전용, package.json에서 조건부 exports 및 imports을 위해 사용됨)입니다. 이러한 모든 설정은 --를 접두사로 하여 컴파일러 플래그로 지정하거나 tsconfig.json에 지정할 수 있습니다.\n\n```json\n...\n\"compilerOptions\": [\n  ...\n  \"allowImportingTsExtensions\": false,\n  \"resolvePackageJsonExports\": true,\n  \"resolvePackageJsonImports\": true,\n  \"allowArbitraryExtensions\": false,\n  \"customConditions\": [\"my-condition\"]\n  // 이제는 `package.json`의 `exports` 및 `imports`에 대한 사용자 정의 조건을 해결하려고 시도합니다.\n  // TS는 그런 다음 해당 사용자 정의 조건에 맞도록 파일을 매칭하려고 할 것입니다 (이 경우 `foo.mjs`).\n]\n...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n  ...\n  \"exports\": {\n    \".\": {\n      \"my-condition\": \"./foo.mjs\",\n      \"node\": \"./bar.mjs\",\n      \"import\": \"./baz.mjs\",\n      \"require\": \"./biz.mjs\"\n    }\n  }\n}\n```\n\n- **--verbatimModuleSyntax:** 자동으로 import (import elision) 및 exports를 제거하지 않도록 TypeScript를 중지합니다. 이것은 import side effects가 사용될 때 또는 TS가 import가 어디에서 사용되는지 인식하지 못할 때 유용할 수 있습니다. import type 및 export type 문은 여전히 최종 컴파일에서 제거됩니다. 대개 import가 타입인지 아닌지 명시하는 것이 권장됩니다. compiler flag --verbatimModuleSyntax(또는 tsconfig.json에서)를 지정하여 사용할 수 있습니다.\n\n```js\n// `verbatimModuleSyntax`가 설정되지 않으면 이 import는 최종 컴파일에서 제거될 것입니다.\nimport { Car } from './car';\n// 이 import는 아무 경우에나 제거될 것입니다.\nimport type { Car } from './car';\n// 이 import는 절대로 제거되지 않습니다.\nimport { logCar } from './car';\n\nexport function drive(car: Car) {\n  logCar(car);\n  // ...\n}\n```\n\n- **export type * 지원:** 기본 형식을 하위 모듈로 쉽게 다시 내보낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 기본 타입들을 다른 모듈로서 서브모듈로 내보냅니다.\nexport type * as am from 'another-module';\n// 또는 다시 기본 내보낸 것으로 제공합니다.\nexport type * from 'another-module';\n```\n\n```js\nimport type { am } from 'module';\n// 또는\nimport type { } from 'module';\n```\n\n- --build 하위에서 Emit-Specific 플래그 전달: 빌드에 대한 동작을 지정하는 플래그들 (--build를 사용할 때). 이들은 --declaration, --emitDeclarationOnly, --declarationMap, --sourceMap 및 --inlineSourceMap를 포함합니다. 모두 이제 컴파일러 플래그로 지정할 수 있습니다. 이전에는 tsconfig.json에서만 설정할 수 있었어요.\n\n```js\n# 이것은 `tsconfig.json`에서 비활성화되어 있더라도 타입 선언을 생성합니다.\ntsc --build --declaration\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 에디터에서 대소문자 구분 없는 import 정렬: 에디터에서 import를 정렬할 때 대소문자 구분 동작을 변경하세요. 이 기능은 VSCode의 JSON 설정 내 typescript.unstable 아래에서 활성화하고 구성할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1032/1*Fei6JPgYzIgnl_IMekhOQg.gif)\n\n- Exhaustive switch/case 자동 완성: 에디터에서 이제 리터럴 타입의 case 문을 자동으로 완성할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:656/1*e9FNtf4-kxU787rEl1w9lQ.gif)","ogImage":{"url":"/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png"},"coverImage":"/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png","tag":["Tech"],"readingTime":53},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png\" alt=\"2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years_0.png\"\u003e\u003c/p\u003e\n\u003cp\u003e이 기사는 지난 3년 동안 (그리고 그 이전에서도) JavaScript/ECMAScript와 TypeScript에서 발생한 거의 모든 변경 사항을 살펴봅니다.\u003c/p\u003e\n\u003cp\u003e다음의 기능들 중 일부는 여러분에게 적용되지 않거나 실용적이지 않을 수 있지만, 이러한 언어에 대한 이해를 더 깊게 하고 가능한 기능을 보여주기 위한 것입니다.\u003c/p\u003e\n\u003cp\u003e많은 TypeScript 기능들을 생략했는데, 그 이유는 \"이전과 달리 예상대로 작동하지 않았으나, 지금은 그렇게 됩니다\"로 요약할 수 있습니다. 따라서 과거에 작동하지 않았던 것이 있다면, 다시 시도해 보세요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJavaScript / ECMAScript (가장 오래된 것부터)\u003c/li\u003e\n\u003cli\u003eTypeScript (가장 오래된 것부터)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e내용\u003c/h1\u003e\n\u003ch1\u003eECMAScript\u003c/h1\u003e\n\u003ch2\u003e과거 (아직도 중요한 이전 소개들)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTagged template literals: 템플릿 리터럴 앞에 함수 이름을 붙이면 함수가 템플릿 리터럴 및 템플릿 값들을 전달받게 됩니다. 이 방법에는 재미있는 활용법이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 임의의 숫자를 포함한 문자열을 로깅할 때 숫자를 형식화하는 방법을 작성하고 싶다고 가정해 봅시다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 그럴 때 태그드 템플릿을 사용할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eformatNumbers\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estrings: TemplateStringsArray, number: number\u003c/span\u003e): string {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e strings[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] + number.\u003cspan class=\"hljs-title function_\"\u003etoFixed\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) + strings[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n}\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(formatNumbers\u003cspan class=\"hljs-string\"\u003e`This is the value: \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e}\u003c/span\u003e, it's important.`\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// This is the value: 0.00, it's important.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 문자열 내의 번역 키를 \"번역\"하고 싶을 때 (여기서는 소문자로 변경)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etranslateKey\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ekey: string\u003c/span\u003e): string {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e key.\u003cspan class=\"hljs-title function_\"\u003etoLocaleLowerCase\u003c/span\u003e();\n}\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etranslate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estrings: TemplateStringsArray, ...expressions: string[]\u003c/span\u003e): string {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e strings.\u003cspan class=\"hljs-title function_\"\u003ereduce\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eaccumulator, currentValue, index\u003c/span\u003e) =\u003e\u003c/span\u003e accumulator + currentValue + \u003cspan class=\"hljs-title function_\"\u003etranslateKey\u003c/span\u003e(expressions[index] ?? \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e), \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e);\n}\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(translate\u003cspan class=\"hljs-string\"\u003e`Hello, this is \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-string\"\u003e'NAME'\u003c/span\u003e}\u003c/span\u003e to say \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-string\"\u003e'MESSAGE'\u003c/span\u003e}\u003c/span\u003e.`\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Hello, this is name to say message.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eSymbols: 객체에 대한 고유 키: Symbol(\"foo\") === Symbol(\"foo\"); // false. 내부적으로 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eobj\u003c/span\u003e: { [\u003cspan class=\"hljs-attr\"\u003eindex\u003c/span\u003e: string]: string } = {};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e symbolA = \u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e symbolB = \u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(symbolA.\u003cspan class=\"hljs-property\"\u003edescription\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"a\"\u003c/span\u003e\n\nobj[symbolA] = \u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e;\nobj[symbolB] = \u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e;\nobj[\u003cspan class=\"hljs-string\"\u003e'c'\u003c/span\u003e] = \u003cspan class=\"hljs-string\"\u003e'c'\u003c/span\u003e;\nobj.\u003cspan class=\"hljs-property\"\u003ed\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'd'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(obj[symbolA]); \u003cspan class=\"hljs-comment\"\u003e// \"a\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(obj[symbolB]); \u003cspan class=\"hljs-comment\"\u003e// \"b\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 다른 심볼이나 심볼 없이는 키에 액세스할 수 없습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(obj[\u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e)]); \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(obj[\u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// for ... in을 사용할 때 키가 열거되지 않습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e obj) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(i); \u003cspan class=\"hljs-comment\"\u003e// \"c\", \"d\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eES2020\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eOptional chaining: 잠재적으로 정의되지 않은 객체의 값을 (인덱싱을 통해) 액세스하기 위해 부모 객체 이름 뒤에 ?를 사용하여 선택적 연결을 사용할 수 있습니다. 이는 인덱싱 ([...]) 또는 함수 호출에도 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이전:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 우리가 정확히 정의된 것인지 확신할 수 없는 객체 변수 (또는 다른 구조)가 있을 때,\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 속성에 쉽게 액세스할 수 없습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eobject\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string } | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e() \u003e \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e : { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e value = object.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 타입 오류: 'object' 가 'undefined' 일 수 있습니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 먼저 정의되었는지 확인해야 했지만, 이는 가독성을 해치며 중첩된 객체에 대해 복잡해집니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eobjectOld\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string } | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e() \u003e \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e : { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e valueOld = objectOld ? objectOld.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e : \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 방법:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 대신 선택적 연결을 사용할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eobjectNew\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string } | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e() \u003e \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e : { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e valueNew = objectNew?.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 이것은 인덱싱 및 함수에도 사용할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003earray\u003c/span\u003e: string[] | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e() \u003e \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e : [\u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e item = array?.[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efunc\u003c/span\u003e: (\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e string) | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e() \u003e \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e : \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = func?.();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e널 병합 연산자 (??): 조건부 할당을 위해 || 연산자를 사용하는 대신 새로운 ?? 연산자를 사용할 수 있습니다. 모든 거짓 값에 적용되는 대신 undefined와 null에만 적용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: string | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e() \u003e \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 이전:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 값이 undefined 또는 null인 경우 다른 값으로 조건적으로 할당하려면 \"||\" 연산자를 사용할 수 있었습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e anotherValue = value || \u003cspan class=\"hljs-string\"\u003e'hello'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(anotherValue); \u003cspan class=\"hljs-comment\"\u003e// \"test\" 또는 \"hello\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 이는 참 값 사용 시 잘 작동하지만, 0이나 빈 문자열과 비교할 경우에도 적용됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e incorrectValue = \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e || \u003cspan class=\"hljs-string\"\u003e'incorrect'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(incorrectValue); \u003cspan class=\"hljs-comment\"\u003e// 항상 \"incorrect\"\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e anotherIncorrectValue = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e || \u003cspan class=\"hljs-string\"\u003e'incorrect'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(anotherIncorrectValue); \u003cspan class=\"hljs-comment\"\u003e// 항상 \"incorrect\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 방법:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이제 nullish 병합 연산자를 사용할 수 있습니다. 이는 오직 undefined와 null 값에만 적용됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newValue = value ?? \u003cspan class=\"hljs-string\"\u003e'hello'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(newValue) \u003cspan class=\"hljs-comment\"\u003e// 항상 \"hello\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 이제 falsy 값들이 교체되지 않습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e correctValue = \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e ?? \u003cspan class=\"hljs-string\"\u003e'incorrect'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(correctValue); \u003cspan class=\"hljs-comment\"\u003e// 항상 \"\"\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e anotherCorrectValue = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e ?? \u003cspan class=\"hljs-string\"\u003e'incorrect'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(anotherCorrectValue); \u003cspan class=\"hljs-comment\"\u003e// 항상 0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eimport(): 변수를 사용하여 런타임에서 동적으로 import ... from ... 처럼 모듈을 가져올 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e importModule;\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (shouldImport) {\n  importModule = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./module.mjs'\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eString.matchAll(): 루프를 사용하지 않고 정규 표현식의 여러 일치 항목과 캡처 그룹을 모두 얻을 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e stringVar = \u003cspan class=\"hljs-string\"\u003e'testhello,testagain,'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 이전:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 일치 항목만 검색되며 캡처 그룹은 포함되지 않습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(stringVar.\u003cspan class=\"hljs-title function_\"\u003ematch\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/test([\\w]+?),/g\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// [\"testhello,\", \"testagain,\"]\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 캡처 그룹을 포함한 하나의 일치 항목만 검색합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e singleMatch = stringVar.\u003cspan class=\"hljs-title function_\"\u003ematch\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/test([\\w]+?),/\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (singleMatch) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(singleMatch[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// \"testhello,\"\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(singleMatch[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// \"hello\"\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 같은 결과를 얻지만 매우 직관적이지 않습니다 (exec 메서드는 마지막 인덱스를 저장합니다).\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 루프 외부에서 정의되어야 하며 전역으로 선언되어야 하며 (/g) 모드여야 합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regex = \u003cspan class=\"hljs-regexp\"\u003e/test([\\w]+?),/g\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e execMatch;\n\u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e ((execMatch = regex.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(stringVar)) !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(execMatch[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// \"testhello,\", \"testagain,\"\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(execMatch[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// \"hello\", \"again\"\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 방법:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 정규식은 전역 (/g)이어야 합니다. 그렇지 않으면 작동하지 않습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e matchesIterator = stringVar.\u003cspan class=\"hljs-title function_\"\u003ematchAll\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/test([\\w]+?),/g\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 순회해야 하거나 배열(Array.from())로 변환해야 하며 직접 색인화(인덱싱)할 수 없습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e match \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e matchesIterator) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(match[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// \"testhello,\", \"testagain,\"\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(match[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// \"hello\", \"again\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003ePromise.allSettled(): Promise.all()과 유사하지만 모든 Promise가 완료될 때까지 기다리며 첫 번째 reject/throw에서 반환하지 않습니다. 모든 오류 처리를 보다 쉽게 할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esuccess1\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e}\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esuccess2\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e}\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efail1\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'fail 1'\u003c/span\u003e}\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efail2\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'fail 2'\u003c/span\u003e}\n\n\u003cspan class=\"hljs-comment\"\u003e// 이전:\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e([\u003cspan class=\"hljs-title function_\"\u003esuccess1\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003esuccess2\u003c/span\u003e()])); \u003cspan class=\"hljs-comment\"\u003e// [\"a\", \"b\"]\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 하지만:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e([\u003cspan class=\"hljs-title function_\"\u003esuccess1\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003esuccess2\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003efail1\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003efail2\u003c/span\u003e()]);\n} \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e); \u003cspan class=\"hljs-comment\"\u003e// \"fail 1\"\u003c/span\u003e\n}\n\u003cspan class=\"hljs-comment\"\u003e// 주의: 하나의 에러만 처리하고 성공 값에 액세스할 수 없습니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 이전 해결 방법 (정말 최적이 아님):\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e([ \u003cspan class=\"hljs-comment\"\u003e// [\"a\", \"b\", undefined, undefined]\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003esuccess1\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e =\u003e\u003c/span\u003e { \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e); }),\n  \u003cspan class=\"hljs-title function_\"\u003esuccess2\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e =\u003e\u003c/span\u003e { \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e); }),\n  \u003cspan class=\"hljs-title function_\"\u003efail1\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e =\u003e\u003c/span\u003e { \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e); }), \u003cspan class=\"hljs-comment\"\u003e// \"fail 1\"\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003efail2\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e =\u003e\u003c/span\u003e { \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e); })])); \u003cspan class=\"hljs-comment\"\u003e// \"fail 2\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 방법:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e results = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eallSettled\u003c/span\u003e([\u003cspan class=\"hljs-title function_\"\u003esuccess1\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003esuccess2\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003efail1\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003efail2\u003c/span\u003e()]);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sucessfulResults = results\n  .\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresult\u003c/span\u003e =\u003e\u003c/span\u003e result.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'fulfilled'\u003c/span\u003e)\n  .\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresult\u003c/span\u003e =\u003e\u003c/span\u003e (result \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromiseFulfilledResult\u003c/span\u003e\u0026#x3C;string\u003e).\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(sucessfulResults); \u003cspan class=\"hljs-comment\"\u003e// [\"a\", \"b\"]\u003c/span\u003e\nresults.\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresult\u003c/span\u003e =\u003e\u003c/span\u003e result.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'rejected'\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e((error \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromiseRejectedResult\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003ereason\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"fail 1\", \"fail 2\"\u003c/span\u003e\n});\n\u003cspan class=\"hljs-comment\"\u003e// 또는:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e results) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (result.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'fulfilled'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(result.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"a\", \"b\"\u003c/span\u003e\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (result.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'rejected'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(result.\u003cspan class=\"hljs-property\"\u003ereason\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"fail 1\", \"fail 2\"\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eBigInt: 새로운 BigInt 데이터 유형을 사용하여 큰 (정수) 숫자를 정확하게 저장하고 처리할 수 있어 JavaScript가 숫자를 부동 소수점으로 저장하는 것에 의한 오류를 방지할 수 있습니다. BigInt() 생성자를 사용하여 생성할 수 있고(불완전성을 방지하기 위해 문자열을 선호) 또는 숫자 끝에 n을 추가하여 생성할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e// 이전:\n// JavaScript는 숫자를 부동 소수점으로 저장하기 때문에 항상 약간의 부정확성이 있습니다.\n// 더 중요한 것은 특정 숫자 이후에 정수 연산에 부정확성이 시작됩니다.\nconst maxSafeInteger = 9007199254740991;\nconsole.log(maxSafeInteger === Number.MAX_SAFE_INTEGER); // true\u003c/p\u003e\n\u003cp\u003e// 해당 숫자보다 큰 숫자와 비교하면 부정확성이 발생할 수 있습니다.\nconsole.log(Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2);\u003c/p\u003e\n\u003cp\u003e// NEW:\n// BigInt 데이터 형식을 사용하면 이론적으로 무한히 큰 (정수) 숫자를 저장하고 조작할 수 있습니다.\n// 숫자 끝에 \"n\"을 추가하거나 BigInt 생성자를 사용하여 사용합니다.\nconst maxSafeIntegerPreviously = 9007199254740991n;\nconsole.log(maxSafeIntegerPreviously); // 9007199254740991\u003c/p\u003e\n\u003cp\u003econst anotherWay = BigInt(9007199254740991);\nconsole.log(anotherWay); // 9007199254740991\u003c/p\u003e\n\u003cp\u003e// 안전한 정수(Number.MAX_SAFE_INTEGER)보다 큰 정수를 전달하면 안됩니다.\nconst incorrect = BigInt(9007199254740992);\nconsole.log(incorrect); // 9007199254740992\nconst incorrectAgain = BigInt(9007199254740993);\nconsole.log(incorrectAgain); // 9007199254740992\n// 오랜, 동일한 값으로 변환됩니다.\u003c/p\u003e\n\u003cp\u003e// 대신 문자열을 사용하거나 더 좋은 다른 구문을 사용합니다.\nconst correct = BigInt('9007199254740993');\nconsole.log(correct); // 9007199254740993\nconst correctAgain = 9007199254740993n;\nconsole.log(correctAgain); // 9007199254740993\u003c/p\u003e\n\u003cp\u003e// 16진수, 8진수 및 2진수도 문자열로 전달할 수 있습니다.\nconst hex = BigInt('0x1fffffffffffff');\nconsole.log(hex); // 9007199254740991\nconst octal = BigInt('0o377777777777777777');\nconsole.log(octal); // 9007199254740991\nconst binary = BigInt('0b11111111111111111111111111111111111111111111111111111');\nconsole.log(binary); // 9007199254740991\u003c/p\u003e\n\u003cp\u003e// 대부분의 산술 연산은 예상대로 작동하지만 다른 연산자도 BigInt 여야합니다. 모든 연산도 BigInt를 반환합니다.\nconst addition = maxSafeIntegerPreviously + 2n;\nconsole.log(addition); // 9007199254740993\u003c/p\u003e\n\u003cp\u003econst multiplication = maxSafeIntegerPreviously * 2n;\nconsole.log(multiplication); // 18014398509481982\u003c/p\u003e\n\u003cp\u003econst subtraction = multiplication - 10n;\nconsole.log(subtraction); // 18014398509481972\u003c/p\u003e\n\u003cp\u003econst modulo = multiplication % 10n;\nconsole.log(modulo); // 2\u003c/p\u003e\n\u003cp\u003econst exponentiation = 2n ** 54n;\nconsole.log(exponentiation); // 18014398509481984\u003c/p\u003e\n\u003cp\u003econst exponentiationAgain = 2n ^ 54n;\nconsole.log(exponentiationAgain); // 18014398509481984\u003c/p\u003e\n\u003cp\u003econst negative = exponentiation * -1n;\nconsole.log(negative); // -18014398509481984\u003c/p\u003e\n\u003cp\u003e// BigInt로 인한 정수 나눗셈은 조금 다르게 작동합니다.\nconst division = multiplication / 2n;\nconsole.log(division); // 9007199254740991\n// 나뉠 수 있는 정수에 대해서는 제대로 작동합니다.\u003c/p\u003e\n\u003cp\u003e// 나누기가 안 되는 숫자에 대해서는 정수 나눗셈(내림)처럼 작동할 것입니다.\nconst divisionAgain = 5n / 2n;\nconsole.log(divisionAgain); // 2\u003c/p\u003e\n\u003cp\u003e// 일치하는(엄격한) 비교가 BigInt 숫자에는 적용되지 않습니다.\nconsole.log(0n === 0); // false\nconsole.log(0n == 0); // true\u003c/p\u003e\n\u003cp\u003e// 그러나 비교는 예상대로 작동합니다.\nconsole.log(1n \u0026#x3C; 2); // true\nconsole.log(2n \u003e 1); // true\nconsole.log(2 \u003e 2); // false\nconsole.log(2n \u003e 2); // false\nconsole.log(2n \u003e= 2); // true\u003c/p\u003e\n\u003cp\u003e// 타입은 \"bigint\"입니다.\nconsole.log(typeof 1n); // \"bigint\"\u003c/p\u003e\n\u003cp\u003e// 일반 숫자(부호있는 부호 없는 (음수 없음))로 다시 변환할 수 있습니다.\n// 그러나 이는 정확도를 희생합니다. 유효 숫자의 수를 지정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003econsole.log(BigInt.asIntN(0, -2n)); // 0\nconsole.log(BigInt.asIntN(1, -2n)); // 0\nconsole.log(BigInt.asIntN(2, -2n)); // -2\n// 보통 더 높은 비트 수를 사용할 것입니다.\u003c/p\u003e\n\u003cp\u003e// 음수 숫자는 부호가 있는 숫자로 변환될 때 2의 보수로 변환됩니다.\nconsole.log(BigInt.asUintN(8, -2n)); // 254\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eglobalThis: 환경(브라우저, NodeJS, ...)와 상관없이 전역 컨텍스트에서 변수에 액세스할 수 있습니다. 여전히 권장되지는 않지만 때로는 필요합니다. 브라우저의 최상위 수준에서 this와 유사합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003econsole.log(globalThis.Math); // Math Object\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eimport.meta: ES-모듈을 사용할 때 현재 모듈 URL import.meta.url을 얻습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emeta\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"file://...\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eexport * as … from …: 쉽게 기본값을 하위 모듈로 다시 내보냅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e am \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'another-module'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { am } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'module'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eES2021\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eString.replaceAll(): 이제 문자열 내에서 부분 문자열의 모든 인스턴스를 대체할 수 있습니다. 더 이상 항상 전역 플래그(/g)를 사용하는 정규 표현식을 사용할 필요가 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e testString = \u003cspan class=\"hljs-string\"\u003e'hello/greetings everyone/everybody'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 이전:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 첫 번째 인스턴스만 대체함\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(testString.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'|'\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 'hello|greetings everyone/everybody'\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 대체하기 위해 정규 표현식을 사용해야 했는데, 이는 성능이 좋지 않고 이스케이프가 필요합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 전역 플래그(/g)를 참고하세요.\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(testString.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\\//g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'|'\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 'hello|greetings everyone|everybody'\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 기능:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// replaceAll을 사용하면 더 명확하고 빠릅니다.\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(testString.\u003cspan class=\"hljs-title function_\"\u003ereplaceAll\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'|'\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 'hello|greetings everyone|everybody'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003ePromise.any(): 프로미스 목록 중 하나의 결과만 필요한 경우, 첫 번째 결과를 반환합니다. 모든 프로미스가 거부될 때만 거부하고 AggregateError를 반환하며, 즉시 거부되는 Promise.race가 아닙니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erace\u003c/span\u003e([\u003cspan class=\"hljs-title function_\"\u003esuccess1\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003esuccess2\u003c/span\u003e()])); \u003cspan class=\"hljs-comment\"\u003e// \"a\"\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 그러나:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erace\u003c/span\u003e([\u003cspan class=\"hljs-title function_\"\u003efail1\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003efail2\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003esuccess1\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003esuccess2\u003c/span\u003e()]);\n} \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e); \u003cspan class=\"hljs-comment\"\u003e// \"fail 1\"\u003c/span\u003e\n}\n\u003cspan class=\"hljs-comment\"\u003e// 유의: 하나의 오류만 catch하고 성공 값을 액세스할 수 없습니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 이전 수정 (정말 최적화되지 않음):\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erace\u003c/span\u003e([ \u003cspan class=\"hljs-comment\"\u003e// \"a\"\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003efail1\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e =\u003e\u003c/span\u003e { \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e); }), \u003cspan class=\"hljs-comment\"\u003e// \"fail 1\"\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003efail2\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e =\u003e\u003c/span\u003e { \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e); }), \u003cspan class=\"hljs-comment\"\u003e// \"fail 2\"\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003esuccess1\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e =\u003e\u003c/span\u003e { \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e); }),\n  \u003cspan class=\"hljs-title function_\"\u003esuccess2\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e =\u003e\u003c/span\u003e { \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e); })]));\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운:\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eany\u003c/span\u003e([\u003cspan class=\"hljs-title function_\"\u003efail1\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003efail2\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003esuccess1\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003esuccess2\u003c/span\u003e()])); \u003cspan class=\"hljs-comment\"\u003e// \"a\"\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 모든 프로미스가 거부될 때만 거부하고 모든 오류를 포함하는 AggregateError를 리턴합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eany\u003c/span\u003e([\u003cspan class=\"hljs-title function_\"\u003efail1\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003efail2\u003c/span\u003e()]);\n} \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e); \u003cspan class=\"hljs-comment\"\u003e// [AggregateError: All promises were rejected]\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e.\u003cspan class=\"hljs-property\"\u003eerrors\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// [\"fail 1\", \"fail 2\"]\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eNullish coalescing assignment (??=): 이전에 \"nullish\"였을 때만 값을 할당합니다 (null 또는 undefined).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e x1 = \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e x2 = \u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetNewValue\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// undefined는 nullish이므로 새 값이 x1에 할당됩니다.\u003c/span\u003e\nx1 ??= \u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x1) \u003cspan class=\"hljs-comment\"\u003e// \"b\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 문자열은 nullish가 아니므로 x2에 새 값이 할당되지 않습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 또한 참고: getNewValue()가 실행되지 않습니다.\u003c/span\u003e\nx2 ??= \u003cspan class=\"hljs-title function_\"\u003egetNewValue\u003c/span\u003e();\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x2) \u003cspan class=\"hljs-comment\"\u003e// \"a\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eLogical and assignment (\u0026#x26;\u0026#x26;=): 이전에 \"truthy\"였을 때만 값을 할당합니다 (true 또는 true로 변환되는 값).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e x1 = \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e x2 = \u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetNewValue\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 지정되지 않은 값인 x1에 새 값이 할당되지 않습니다. 왜냐하면 지정되지 않은 값은 참이 아닙니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 또한 주의: getNewValue()는 실행되지 않습니다.\u003c/span\u003e\nx1 \u0026#x26;\u0026#x26;= \u003cspan class=\"hljs-title function_\"\u003egetNewValue\u003c/span\u003e();\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x1) \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 문자열은 참이므로 새 값이 x2에 할당됩니다.\u003c/span\u003e\nx2 \u0026#x26;\u0026#x26;= \u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x2) \u003cspan class=\"hljs-comment\"\u003e// \"b\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e논리 또는 할당 (||=): 이전에 \"거짓\"인 경우에만 값이 할당됩니다 (false 또는 false로 변환).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e x1 = \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e x2 = \u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetNewValue\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// x1에 새 값이 할당됩니다. 왜냐하면 지정되지 않은 값은 거짓이기 때문입니다.\u003c/span\u003e\nx1 ||= \u003cspan class=\"hljs-string\"\u003e'b'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x1) \u003cspan class=\"hljs-comment\"\u003e// \"b\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// x2에 새 값이 할당되지 않습니다. 왜냐하면 문자열은 거짓이 아닙니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 또한 주의: getNewValue()는 실행되지 않습니다.\u003c/span\u003e\nx2 ||= \u003cspan class=\"hljs-title function_\"\u003egetNewValue\u003c/span\u003e();\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x2) \u003cspan class=\"hljs-comment\"\u003e// \"a\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eWeakRef: 객체가 가비지 수집되는 것을 방지하지 않고 객체에 \"약한\" 참조를 보유합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ref = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWeakRef\u003c/span\u003e(element);\n\n\u003cspan class=\"hljs-comment\"\u003e// 만약 객체/요소가 여전히 존재하고 쓰레기 수집되지 않았다면 값을 가져옵니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e value = ref.\u003cspan class=\"hljs-property\"\u003ederef\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value); \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 객체가 더는 존재하지 않는 것 같습니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e숫자 리터럴 구분자 (_): 가독성을 위해 숫자를 _로 구분합니다. 이는 기능에 영향을 미치지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e int = \u003cspan class=\"hljs-number\"\u003e1_000_000_000\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e float = \u003cspan class=\"hljs-number\"\u003e1_000_000_000.999_999_999\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e max = \u003cspan class=\"hljs-number\"\u003e9_223_372_036_854_775_807n\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e binary = \u003cspan class=\"hljs-number\"\u003e0b1011_0101_0101\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e octal = \u003cspan class=\"hljs-number\"\u003e0o1234_5670\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hex = \u003cspan class=\"hljs-number\"\u003e0xD0_E0_F0\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eES2022\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e최상위 대기: await 키워드는 이제 ES 모듈의 최상위 수준에서 사용할 수 있습니다. 이는 래퍼 함수의 필요성을 제거하고 오류 처리를 개선합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncFuncSuccess\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncFuncFail\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Test'\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 이전:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 프로미스를 대기하려면 async 함수 내부에서만 가능했습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// await asyncFuncSuccess(); // SyntaxError: await is only valid in async functions\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 따라서 async 함수 내부로 래핑해야 했고 이는 오류 처리와 최상위 동시성을 잃게 했습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n  (\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncFuncSuccess\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// \"test\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncFuncFail\u003c/span\u003e();\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n      \u003cspan class=\"hljs-comment\"\u003e// 오류 처리를 위해 필요합니다. 그렇지 않으면 오류가 캐치되지 않거나 적절한 추적 없이 너무 늦게 되어버립니다.\u003c/span\u003e\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(e); \u003cspan class=\"hljs-comment\"\u003e// Error: \"Test\"\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e e;\n    }\n  })();\n} \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 함수가 async여서 절대 호출되지 않거나(적절한 추적이 없거나 너무 늦게) 이유 때문에\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(e);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 비동기 함수가 기다려지지 않았기 때문에 이 프로미스 결과보다 먼저 기록됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Hey'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"Hey\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 파일이 ES 모듈이라면(package.json에 설정되었고, exports가 있고, \".mts\"로 명명된 경우) 최상위 수준에서 바로 await할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncFuncSuccess\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// \"test\"\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncFuncFail\u003c/span\u003e();\n} \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(e); \u003cspan class=\"hljs-comment\"\u003e// Error: \"Test\"\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 모든 비동기 호출이 기다려지기 때문에 이 프로미스 결과 뒤에 기록됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Hello'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"Hello\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e#private: 클래스 멤버(속성 및 메서드)를 이름이 #로 시작하게하여 비공개로 만듭니다. 따라서 이러한 멤버는 클래스 내부에서만 액세스할 수 있습니다. 삭제되거나 동적으로 할당할 수 없습니다. 잘못된 동작은 JavaScript(하지만 TypeScript가 아닌) 구문 오류를 발생시킵니다. TypeScript 프로젝트에서는 권장되지 않습니다. 대신 기존 private 키워드를 사용하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eClassWithPrivateField\u003c/span\u003e {\n  #privateField;\n  #anotherPrivateField = \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#privateField = \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 유효\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#privateField; \u003cspan class=\"hljs-comment\"\u003e// 구문 오류\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#undeclaredField = \u003cspan class=\"hljs-number\"\u003e444\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 구문 오류\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#anotherPrivateField); \u003cspan class=\"hljs-comment\"\u003e// 4\u003c/span\u003e\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eClassWithPrivateField\u003c/span\u003e();\ninstance.#privateField === \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 구문 오류\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003estatic 클래스 멤버: 클래스 필드(속성 및 메서드)를 static으로 표시하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLogger\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e id = \u003cspan class=\"hljs-string\"\u003e'Logger1'\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e type = \u003cspan class=\"hljs-string\"\u003e'GenericLogger'\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emessage: string | \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(message);\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eErrorLogger\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eLogger\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e type = \u003cspan class=\"hljs-string\"\u003e'ErrorLogger'\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e qualifiedType;\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ee: \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e());\n  }\n}\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eLogger\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"GenericLogger\"\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eLogger\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Test'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"Test\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 정적으로만 있는 클래스를 생성하는 것은 무의미하지만 여기선 시연을 위해 수행되었습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e log = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLogger\u003c/span\u003e();\n\n\u003cspan class=\"hljs-title class_\"\u003eErrorLogger\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Test'\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 에러: \"Test\" (부모 클래스의 생성에 영향을 받지 않음)\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eErrorLogger\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"ErrorLogger\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eErrorLogger\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003equalifiedType\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eErrorLogger\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"Logger1\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// log()가 인스턴스 메서드가 아닌 정적 메서드이기 때문에 예외를 발생시킵니다.\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(log.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// log.log is not a function\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e클래스 내의 정적 초기화 블록: 클래스가 초기화될 때 실행되는 블록, 기본적으로 정적 멤버를 초기화하는 \"생성자\"입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e staticProperty1 = \u003cspan class=\"hljs-string\"\u003e'속성 1'\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e staticProperty2;\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estaticProperty2\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'속성 2'\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estaticProperty1\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"Property 1\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estaticProperty2\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"Property 2\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e가져오기 어설션 (비표준, V8에서 구현됨): 가져온 항목의 유형을 확인하기 위해 사용할 수 있습니다. \u003ccode\u003eimport ... from ... assert ' type: \u003c/code\u003ejson\u003ccode\u003e '\u003c/code\u003e로 JSON을 직접 가져오고 구문 분석할 필요 없이 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e json \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./foo.json'\u003c/span\u003e assert { \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'json'\u003c/span\u003e };\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(json.\u003cspan class=\"hljs-property\"\u003eanswer\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 42\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e정규표현식 일치 인덱스: 정규표현식 일치 및 캡처 그룹의 시작 및 끝 인덱스를 가져올 수 있습니다. RegExp.exec(), String.match() 및 String.matchAll()에 대해 작동합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e matchObj = \u003cspan class=\"hljs-regexp\"\u003e/(test+)(hello+)/\u003c/span\u003ed.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'start-testesthello-stop'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 이전:\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(matchObj?.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (matchObj) {\n  \u003cspan class=\"hljs-comment\"\u003e// 전체 일치 항목의 시작 및 끝 인덱스(이전에 시작만 있었음).\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(matchObj.\u003cspan class=\"hljs-property\"\u003eindices\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// [9, 18]\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// 캡처 그룹의 시작 및 끝 인덱스.\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(matchObj.\u003cspan class=\"hljs-property\"\u003eindices\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// [9, 13]\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(matchObj.\u003cspan class=\"hljs-property\"\u003eindices\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// [13, 18]\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eNegative indexing (.at(-1)): 배열이나 문자열을 인덱싱할 때, at()을 사용하여 뒤에서부터 인덱싱할 수 있습니다. 값 가져오기(arr[arr.length - 1]와 동일)만 가능하며 값을 설정할 수는 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eat\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)) \u003cspan class=\"hljs-comment\"\u003e// 5\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e array = [\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\narray.\u003cspan class=\"hljs-title function_\"\u003eat\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// SyntaxError: Assigning to rvalue\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003ehasOwn: 객체가 어떤 속성을 가지고 있는지 obj.hasOwnProperty()을 사용하는 대신 추천되는 새 방법입니다. 일부 특수한 경우에 더 잘 작동합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e };\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasOwn\u003c/span\u003e(obj, \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasOwn\u003c/span\u003e(obj, \u003cspan class=\"hljs-string\"\u003e'gender'\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e오류 원인: 이제 오류에 대한 선택적 원인을 지정할 수 있습니다. 이는 다시 throw할 때 원래 오류를 지정할 수 있게 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003econnectToDatabase\u003c/span\u003e();\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\n    \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'데이터베이스 연결에 실패했습니다.'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003ecause\u003c/span\u003e: err });\n  }\n} \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(err.\u003cspan class=\"hljs-property\"\u003ecause\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// ReferenceError: connectToDatabase is not defined\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e미래 (이미 TypeScript 4.9에서 사용 가능)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eAuto-Accessor: 속성을 자동으로 비공개로 만들고 get/set 접근자를 만듭니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePerson\u003c/span\u003e {\n  accessir \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string;\n\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename: string\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = name;\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 'test'\u003c/span\u003e\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e person = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePerson\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eTypeScript\u003c/h1\u003e\n\u003ch2\u003e기초 (추후 소개를 위한 문맥)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e제네릭: 다른 유형으로 유형을 전달합니다. 이를 통해 유형을 일반화 할 수 있지만 여전히 유형 안전성을 유지할 수 있습니다. 항상 \u003ccode\u003eany\u003c/code\u003e 또는 \u003ccode\u003eunknown\u003c/code\u003e 대신 이를 선호해주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// WITHOUT:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetFirstUnsafe\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003elist: any[]\u003c/span\u003e): any {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e list[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e firstUnsafe = \u003cspan class=\"hljs-title function_\"\u003egetFirstUnsafe\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// typed as any\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// WITH:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e getFirst\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e\u003e(\u003cspan class=\"hljs-attr\"\u003elist\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e[]): \u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e list[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e];\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e first = getFirst\u0026#x3C;string\u003e([\u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// typed as string\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// In this case the parameter can even be dropped because it is inferred from the argument.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e firstInferred = \u003cspan class=\"hljs-title function_\"\u003egetFirst\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// typed as string\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// The types accepted as generics can also be limited using `extends`. The Type is also usually shortened to T.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e string | number\u003e {\n  private \u003cspan class=\"hljs-attr\"\u003elist\u003c/span\u003e: T[] = [];\n\n  \u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: number): T {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elist\u003c/span\u003e[key];\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: T): \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elist\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(value);\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e list = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;string\u003e();\nlist.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Type error: Argument of type 'number' is not assignable to parameter of type 'string'.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e booleanList = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;boolean\u003e(); \u003cspan class=\"hljs-comment\"\u003e// Type error: Type 'boolean' does not satisfy the constraint 'string | number'.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e과거 (아직도 유효한 이전 소개)\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e유틸리티 타입: TypeScript에는 많은 유틸리티 타입이 포함되어 있으며, 그 중 가장 유용한 몇 가지가 여기에서 설명되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einterface \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: number;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Partial 유틸리티 타입은 모든 속성을 선택적으로 만듭니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eTestPartial\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003ePartial\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e\u003e; \u003cspan class=\"hljs-comment\"\u003e// typed as { name?: string | undefined; age?: number | undefined; }\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Required 유틸리티 타입은 반대로 동작합니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eTestRequired\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eRequired\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eTestPartial\u003c/span\u003e\u003e; \u003cspan class=\"hljs-comment\"\u003e// typed as { name: string; age: number; }\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Readonly 유틸리티 타입은 모든 속성을 읽기 전용으로 만듭니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eTestReadonly\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eReadonly\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e\u003e; \u003cspan class=\"hljs-comment\"\u003e// typed as { readonly name: string; readonly age: string }\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Record 유틸리티 타입은 객체/맵/사전을 간단하게 정의할 수 있습니다. 가능한 경우에는 인덱스 시그니처보다 선호됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econfig\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRecord\u003c/span\u003e\u0026#x3C;string, boolean\u003e = { \u003cspan class=\"hljs-attr\"\u003eoption\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eanotherOption\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e };\n\u003cspan class=\"hljs-comment\"\u003e// Pick 유틸리티 타입은 지정된 속성만 가져옵니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eTestLess\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003ePick\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e\u003e; \u003cspan class=\"hljs-comment\"\u003e// typed as { name: string; }\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eTestBoth\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003ePick\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'age'\u003c/span\u003e\u003e; \u003cspan class=\"hljs-comment\"\u003e// typed as { name: string; age: string; }\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Omit 유틸리티 타입은 지정된 속성을 무시합니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eTestFewer\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eOmit\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e\u003e; \u003cspan class=\"hljs-comment\"\u003e// typed as { age: string; }\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eTestNone\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eOmit\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'age'\u003c/span\u003e\u003e; \u003cspan class=\"hljs-comment\"\u003e// typed as {}\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Parameters 유틸리티 타입은 함수 타입의 매개변수를 가져옵니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoSmth\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue: string, anotherValue: number\u003c/span\u003e): string {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e;\n}\ntype \u003cspan class=\"hljs-title class_\"\u003eParams\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eParameters\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e doSmth\u003e; \u003cspan class=\"hljs-comment\"\u003e// typed as [value: string, anotherValue: number]\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ReturnType 유틸리티 타입은 함수 타입의 반환 타입을 가져옵니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eReturn\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eReturnType\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e doSmth\u003e; \u003cspan class=\"hljs-comment\"\u003e// typed as string\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 이 외에도 많은 유틸리티 타입이 있으며, 그 중 일부는 아래에서 소개됩니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e조건부 타입: 어떤 타입이 다른 타입과 일치/확장되면 그에 따라 타입을 조건부로 설정합니다. 이는 JavaScript의 조건부(삼항) 연산자와 비슷하게 해석될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 배열인 경우에만 배열 타입을 추출하고, 그렇지 않으면 동일한 타입을 반환합니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eFlatten\u003c/span\u003e\u0026#x3C;T\u003e = T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e any[] ? T[number] : T;\n\n\u003cspan class=\"hljs-comment\"\u003e// 요소 타입을 추출합니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eStr\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eFlatten\u003c/span\u003e\u0026#x3C;string[]\u003e; \u003cspan class=\"hljs-comment\"\u003e// string 타입으로 지정됨\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 타입을 그대로 유지합니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eNum\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eFlatten\u003c/span\u003e\u0026#x3C;number\u003e; \u003cspan class=\"hljs-comment\"\u003e// number 타입으로 지정됨\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e조건부 타입으로 추론: 모든 일반 타입이 소비자에 의해 명시적으로 지정되어야 하는 것은 아닙니다. 일부는 코드로부터 추론될 수도 있습니다. 추론된 타입을 기반으로 조건부 논리를 작성하려면 infer 키워드가 필요합니다. 이는 일시적인 추론된 타입 변수를 정의하는 방식입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이전 예제를 기반으로 해서 더 깔끔하게 작성할 수 있습니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eFlattenOld\u003c/span\u003e\u0026#x3C;T\u003e = T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e any[] ? T[number] : T;\n\n\u003cspan class=\"hljs-comment\"\u003e// 배열에서 직접 인덱싱하는 대신, 배열에서 항목(Item)의 타입을 추론할 수 있습니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eFlatten\u003c/span\u003e\u0026#x3C;T\u003e = T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e (infer \u003cspan class=\"hljs-title class_\"\u003eItem\u003c/span\u003e)[] ? \u003cspan class=\"hljs-title class_\"\u003eItem\u003c/span\u003e : T;\n\n\u003cspan class=\"hljs-comment\"\u003e// 함수의 반환 타입을 가져오고, 그 외의 경우에는 undefined로 지정하는 타입을 작성할 수도 있습니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eGetReturnType\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e\u003e = \u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e (...\u003cspan class=\"hljs-attr\"\u003eargs\u003c/span\u003e: any[]) =\u003e infer \u003cspan class=\"hljs-title class_\"\u003eReturn\u003c/span\u003e ? \u003cspan class=\"hljs-title class_\"\u003eReturn\u003c/span\u003e : \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n\ntype \u003cspan class=\"hljs-title class_\"\u003eNum\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eGetReturnType\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e number\u003e; \u003cspan class=\"hljs-comment\"\u003e// number 타입으로 지정됨\u003c/span\u003e\n\ntype \u003cspan class=\"hljs-title class_\"\u003eStr\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eGetReturnType\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ex: string\u003c/span\u003e) =\u003e\u003c/span\u003e string\u003e; \u003cspan class=\"hljs-comment\"\u003e// string 타입으로 지정됨\u003c/span\u003e\n\ntype \u003cspan class=\"hljs-title class_\"\u003eBools\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eGetReturnType\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ea: boolean, b: boolean\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e\u003e; \u003cspan class=\"hljs-comment\"\u003e// undefined 타입으로 지정됨\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e튜플 Optional Elements와 Rest: 튜플에서 \u003ccode\u003e?\u003c/code\u003e를 사용하여 옵셔널 요소를 선언하고, 다른 타입을 기반으로 나머지 요소를 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 튜플의 길이를 아직 알 수 없지만 적어도 한 개는 있는 경우, `?`를 사용하여 옵셔널 타입을 지정할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003elist\u003c/span\u003e: [number, number?, boolean?] = [];\nlist[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e// number 타입으로 지정됩니다\u003c/span\u003e\nlist[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e// number 또는 undefined 타입으로 지정됩니다\u003c/span\u003e\nlist[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e// boolean 또는 undefined 타입으로 지정됩니다\u003c/span\u003e\nlist[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] \u003cspan class=\"hljs-comment\"\u003e// Type error: 길이가 '3'인 '[number, (number | undefined)?, (boolean | undefined)?]' 형식의 튜플에는 '3' 인덱스 요소가 없습니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 기존 타입을 기반으로 튜플을 사용할 수도 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 배열의 시작 부분에 패딩을 추가하려면 나머지 연산자 `...`를 사용할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e padStart\u0026#x3C;T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e any[]\u003e(\u003cspan class=\"hljs-attr\"\u003earr\u003c/span\u003e: T, \u003cspan class=\"hljs-attr\"\u003epad\u003c/span\u003e: string): [string, ...T] {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [pad, ...arr];\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e padded = \u003cspan class=\"hljs-title function_\"\u003epadStart\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e], \u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// [string, number, number] 타입으로 지정됩니다\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e추상 클래스와 메소드: 클래스와 그 내부 메소드를 추상으로 선언하여 인스턴스화되지 않도록 할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eabstract \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e {\n  abstract \u003cspan class=\"hljs-title function_\"\u003emakeSound\u003c/span\u003e(): \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-title function_\"\u003emove\u003c/span\u003e(): \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'roaming the earth...'\u003c/span\u003e);\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 추상 메소드는 확장 시 구현되어야 합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCat\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eAnimal\u003c/span\u003e {} \u003cspan class=\"hljs-comment\"\u003e// 컴파일 오류: 추상 클래스 'Animal'로부터 상속된 추상 멤버 'makeSound'가 구현되지 않은 비-추상 클래스 'Cat'입니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eAnimal\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003emakeSound\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'woof'\u003c/span\u003e);\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 추상 클래스는 (인터페이스처럼) 인스턴스화할 수 없으며, 추상 메소드는 호출할 수 없습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 컴파일 오류: 추상 클래스의 인스턴스를 생성할 수 없습니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dog = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003emakeSound\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// \"woof\"가 출력됩니다\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e생성자 서명: 클래스 선언 외부에서 생성자의 유형을 정의합니다. 대부분의 경우에 사용되지 않아야 하며, 추상 클래스 대신 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einterface \u003cspan class=\"hljs-title class_\"\u003eMyInterface\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string;\n}\n\ninterface \u003cspan class=\"hljs-title class_\"\u003eConstructsMyInterface\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string): \u003cspan class=\"hljs-title class_\"\u003eMyInterface\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eMyInterface\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename: string\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = name;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnotherTest\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: number;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emakeObj\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003en: ConstructsMyInterface\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003en\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'hello!'\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = \u003cspan class=\"hljs-title function_\"\u003emakeObj\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Test로 타입 지정됨\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e anotherObj = \u003cspan class=\"hljs-title function_\"\u003emakeObj\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eAnotherTest\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 타입 오류: 'AnotherTest'의 유형은 'ConstructsMyInterface'의 매개변수에 할당할 수 없습니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eConstructorParameters 유틸리티 타입: TypeScript 도우미 함수로, 생성자 타입에서 생성자 매개변수를 가져옵니다 (클래스에서 가져오는 것이 아닙니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// makeObj 함수에 생성자 인수를 얻고 싶다면?\u003c/span\u003e\ninterface \u003cspan class=\"hljs-title class_\"\u003eMyInterface\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string;\n}\n\ninterface \u003cspan class=\"hljs-title class_\"\u003eConstructsMyInterface\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string): \u003cspan class=\"hljs-title class_\"\u003eMyInterface\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eMyInterface\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename: string\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = name;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emakeObj\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etest: ConstructsMyInterface, ...args: ConstructorParameters\u0026#x3C;ConstructsMyInterface\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(...args);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003emakeObj\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 타입 오류: 2개의 매개변수가 필요하지만 1개만 전달되었습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = \u003cspan class=\"hljs-title function_\"\u003emakeObj\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Test로 타입 지정됨\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eTypeScript 4.0\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eVariadic Tuple Types: 튜플에서의 나머지 요소는 이제 제네릭할 수 있습니다. 여러 개의 나머지 요소를 사용하는 것도 허용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 만약 길이와 타입이 정의되지 않은 두 튜플을 결합하는 함수가 있다면 어떨까요? 반환 타입을 어떻게 정의할 수 있을까요?\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 이전:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 우리는 몇 가지 오버로드를 작성할 수 있었습니다.\u003c/span\u003e\ndeclare \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003econcat\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003earr1: [], arr2: []\u003c/span\u003e): [];\ndeclare \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e concat\u0026#x3C;A\u003e(\u003cspan class=\"hljs-attr\"\u003earr1\u003c/span\u003e: [A], \u003cspan class=\"hljs-attr\"\u003earr2\u003c/span\u003e: []): [A];\ndeclare \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e concat\u0026#x3C;A, B\u003e(\u003cspan class=\"hljs-attr\"\u003earr1\u003c/span\u003e: [A], \u003cspan class=\"hljs-attr\"\u003earr2\u003c/span\u003e: [B]): [A, B];\n\u003cspan class=\"hljs-comment\"\u003e// 이하 생략\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 대신에 타입을 결합할 수 있습니다.\u003c/span\u003e\ndeclare \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e concatBetter\u0026#x3C;T, U\u003e(\u003cspan class=\"hljs-attr\"\u003earr1\u003c/span\u003e: T[], \u003cspan class=\"hljs-attr\"\u003earr2\u003c/span\u003e: U[]): (T | U)[];\n\u003cspan class=\"hljs-comment\"\u003e// 그러나 이것은 (T | U)[]로 타입이 지정됩니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 기능:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 가변 길이 튜플 타입을 사용하면 쉽게 정의할 수 있고 길이 정보를 유지할 수 있습니다.\u003c/span\u003e\ndeclare \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e concatNew\u0026#x3C;T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArr\u003c/span\u003e, U \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArr\u003c/span\u003e\u003e(\u003cspan class=\"hljs-attr\"\u003earr1\u003c/span\u003e: T, \u003cspan class=\"hljs-attr\"\u003earr2\u003c/span\u003e: U): [...T, ...U];\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tuple = \u003cspan class=\"hljs-title function_\"\u003econcatNew\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'hey'\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e] \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e [number, string, boolean], [\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e99\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e] \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e [number, number, number]);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(tuple[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// 23\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eelement\u003c/span\u003e: number = tuple[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// 타입 오류: 타입 'string'을 'number'에 할당할 수 없습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(tuple[\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// 타입 오류: 길이 '6'인 튜플 타입 '[23, \"hey\", false, 5, 99, 20]'에는 인덱스 '6'에 요소가 없습니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eLabeled Tuple Elements: 튜플 요소는 이제 [start: number, end: number]와 같이 이름을 지정할 수 있습니다. 요소 중 하나가 이름이 지정되면 모두 이름이 있어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e혹시 클래스 생성자에서 속성이 설정될 때 속성의 타입을 자동으로 추론할 수 있어서 더 이상 수동으로 설정할 필요가 없습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 생성자에서 할당될 때 타입을 설정할 필요가 없습니다.\u003c/span\u003e\n  name;\n\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename: string\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = name;\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 문자열로 타입이 지정됨\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eJSDoc @deprecated 지원: JSDoc/TSDoc의 @deprecated 태그가 TypeScript에서 인식됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/** \u003cspan class=\"hljs-doctag\"\u003e@deprecated\u003c/span\u003e 메시지 */\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e = string;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etest\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'dfadsf'\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 타입 오류: '테스트'가 사용되지 않습니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eTypeScript 4.1\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e템플릿 리터럴 타입: 리터럴 타입을 정의할 때, '$'를 이용하여 템플릿을 활용할 수 있습니다. 이를 통해 여러 개의 문자열 리터럴을 조합하는 등 복잡한 문자열 타입을 만들 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype \u003cspan class=\"hljs-title class_\"\u003eVerticalDirection\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'top'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'bottom'\u003c/span\u003e;\ntype \u003cspan class=\"hljs-title class_\"\u003eHorizontalDirection\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'left'\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e'right'\u003c/span\u003e;\ntype \u003cspan class=\"hljs-title class_\"\u003eDirection\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${VerticalDirection}\u003c/span\u003e \u003cspan class=\"hljs-subst\"\u003e${HorizontalDirection}\u003c/span\u003e`\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edir1\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDirection\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'top left'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edir2\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDirection\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'left'\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 타입 오류: '\"left\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edir3\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDirection\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'left top'\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 타입 오류: '\"left top\"'은(는) '\"top left\" | \"top right\" | \"bottom left\" | \"bottom right\"' 타입에 할당할 수 없습니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 이는 제네릭 및 새로운 유틸리티 타입과도 결합할 수 있습니다.\u003c/span\u003e\ndeclare \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e makeId\u0026#x3C;T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e string, U \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e string\u003e(\u003cspan class=\"hljs-attr\"\u003efirst\u003c/span\u003e: T, \u003cspan class=\"hljs-attr\"\u003esecond\u003c/span\u003e: U): \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${Capitalize\u0026#x3C;T\u003e}\u003c/span\u003e-\u003cspan class=\"hljs-subst\"\u003e${Lowercase\u0026#x3C;U\u003e}\u003c/span\u003e`\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e키 다시 매핑하기: 매핑된 타입을 다시 정의하여 그 값들을 사용할 수 있습니다. [K in keyof T as NewKeyType]: T[K].\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 예를 들어, 객체를 다시 포맷하되 그 ID 앞에 밑줄을 추가하고 싶다고 가정해 봅시다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = { \u003cspan class=\"hljs-attr\"\u003evalue1\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue2\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue3\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enewObj\u003c/span\u003e: { [\u003cspan class=\"hljs-title class_\"\u003eProperty\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e keyof \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e obj \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`_\u003cspan class=\"hljs-subst\"\u003e${Property}\u003c/span\u003e`\u003c/span\u003e]: number }; \u003cspan class=\"hljs-comment\"\u003e// { _value1: number; _value2: number; value3: number; }로 타입이 지정됩니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e재귀 조건부 타입: 조건부 타입을 해당 정의 내부에서 사용합니다. 이를 통해 무한히 중첩된 값을 조건부적으로 언패킹하는 타입을 생성할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype \u003cspan class=\"hljs-title class_\"\u003eAwaited\u003c/span\u003e\u0026#x3C;T\u003e = T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromiseLike\u003c/span\u003e\u0026#x3C;infer U\u003e ? \u003cspan class=\"hljs-title class_\"\u003eAwaited\u003c/span\u003e\u0026#x3C;U\u003e : T;\n\ntype \u003cspan class=\"hljs-variable constant_\"\u003eP1\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eAwaited\u003c/span\u003e\u0026#x3C;string\u003e; \u003cspan class=\"hljs-comment\"\u003e// string으로 타입이 지정됩니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-variable constant_\"\u003eP2\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eAwaited\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;string\u003e\u003e; \u003cspan class=\"hljs-comment\"\u003e// string으로 타입이 지정됩니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-variable constant_\"\u003eP3\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eAwaited\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;string\u003e\u003e\u003e; \u003cspan class=\"hljs-comment\"\u003e// string으로 타입이 지정됩니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eJSDOC @see 태그를 지원하는 편집기: 이제 편집기에서 JSDoc/TSDoc @see 변수/유형/링크 태그가 지원됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e originalValue = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e/**\n * 다른 값의 복사본\n * \u003cspan class=\"hljs-doctag\"\u003e@see\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eoriginalValue\u003c/span\u003e\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e value = originalValue;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003etsc --explainFiles: --explainFiles 옵션은 TypeScript CLI에서 컴파일에 사용된 파일과 그 이유를 설명해주는 데 사용될 수 있습니다. 이는 디버깅에 유용할 수 있습니다. 경고: 대규모 프로젝트나 복잡한 설정의 경우 많은 출력물이 생성됩니다. 대신 tsc --explainFiles | less 또는 비슷한 방법을 사용하십시오.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etsc --explainFiles\n\n\u0026#x3C;\u0026#x3C;output\n../../.\u003cspan class=\"hljs-property\"\u003easdf\u003c/span\u003e/installs/nodejs/\u003cspan class=\"hljs-number\"\u003e16.13\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e/.\u003cspan class=\"hljs-property\"\u003enpm\u003c/span\u003e/lib/node_modules/typescript/lib/lib.\u003cspan class=\"hljs-property\"\u003ees5\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ed\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ets\u003c/span\u003e\n  파일 \u003cspan class=\"hljs-string\"\u003e'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'\u003c/span\u003e에서 \u003cspan class=\"hljs-string\"\u003e'es5'\u003c/span\u003e로 참조되는 라이브러리\n  파일 \u003cspan class=\"hljs-string\"\u003e'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2015.d.ts'\u003c/span\u003e에서 \u003cspan class=\"hljs-string\"\u003e'es5'\u003c/span\u003e로 참조되는 라이브러리\n../../.\u003cspan class=\"hljs-property\"\u003easdf\u003c/span\u003e/installs/nodejs/\u003cspan class=\"hljs-number\"\u003e16.13\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e/.\u003cspan class=\"hljs-property\"\u003enpm\u003c/span\u003e/lib/node_modules/typescript/lib/lib.\u003cspan class=\"hljs-property\"\u003ees2015\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ed\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ets\u003c/span\u003e\n  파일 \u003cspan class=\"hljs-string\"\u003e'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'\u003c/span\u003e에서 \u003cspan class=\"hljs-string\"\u003e'es2015'\u003c/span\u003e로 참조되는 라이브러리\n  파일 \u003cspan class=\"hljs-string\"\u003e'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2016.d.ts'\u003c/span\u003e에서 \u003cspan class=\"hljs-string\"\u003e'es2015'\u003c/span\u003e로 참조되는 라이브러리\n../../.\u003cspan class=\"hljs-property\"\u003easdf\u003c/span\u003e/installs/nodejs/\u003cspan class=\"hljs-number\"\u003e16.13\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e/.\u003cspan class=\"hljs-property\"\u003enpm\u003c/span\u003e/lib/node_modules/typescript/lib/lib.\u003cspan class=\"hljs-property\"\u003ees2016\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ed\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ets\u003c/span\u003e\n  파일 \u003cspan class=\"hljs-string\"\u003e'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'\u003c/span\u003e에서 \u003cspan class=\"hljs-string\"\u003e'es2016'\u003c/span\u003e로 참조되는 라이브러리\n  파일 \u003cspan class=\"hljs-string\"\u003e'../../.asdf/installs/nodejs/16.13.1/.npm/lib/node_modules/typescript/lib/lib.es2017.d.ts'\u003c/span\u003e에서 \u003cspan class=\"hljs-string\"\u003e'es2016'\u003c/span\u003e로 참조되는 라이브러리\n...\noutput\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eDestructured 변수는 명시적으로 사용되지 않음을 표시할 수 있습니다: 구조 분해할 때 밑줄을 사용하여 변수가 사용되지 않음을 표시할 수 있습니다. 이를 통해 TypeScript에서 \"사용되지 않는 변수\" 오류를 방지할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [_first, second] = [\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(second);\n\n\u003cspan class=\"hljs-comment\"\u003e// 심지어 더 짧게\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [_, value] = [\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eTypeScript 4.3\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e속성에 대한 별도의 쓰기 유형: set/get 접근자를 정의할 때, 쓰기/설정 형식이 읽기/가져오기 형식과 다를 수 있습니다. 이를 통해 동일한 값의 여러 형식을 수락하는 setter를 정의할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e {\n  private \u003cspan class=\"hljs-attr\"\u003e_value\u003c/span\u003e: number;\n\n  \u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003evalue\u003c/span\u003e(): number {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_value\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eset\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003evalue\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue: number | string\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e value === \u003cspan class=\"hljs-string\"\u003e'number'\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_value\u003c/span\u003e = value;\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e_value\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003eparseInt\u003c/span\u003e(value, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eoverride: 상속된 클래스 메서드를 명확하게 오버라이드로 표시하기 위해 override를 사용하세요. 부모 클래스가 변경되면 TypeScript에서 부모 메서드가 더 이상 존재하지 않음을 알려줄 수 있습니다. 이를 통해 더 안전한 복잡한 상속 패턴을 구현할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eParent\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003egetName\u003c/span\u003e(): string {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNewParent\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003egetFirstName\u003c/span\u003e(): string {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eParent\u003c/span\u003e {\n  override \u003cspan class=\"hljs-title function_\"\u003egetName\u003c/span\u003e(): string {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNewTest\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eNewParent\u003c/span\u003e {\n  override \u003cspan class=\"hljs-title function_\"\u003egetName\u003c/span\u003e(): string { \u003cspan class=\"hljs-comment\"\u003e// Type error: This member cannot have an 'override' modifier because it is not declared in the base class 'NewParent'.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'test'\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003estatic Index Signatures: 클래스에서 정적 속성을 사용할 때, 정적 [propName: string]: string을 사용하여 색인 서명을 설정할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이전 코드:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e {}\n\n\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etest\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 타입 오류: 'test' 속성을 'Test' 형식에서 찾을 수 없습니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 코드:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNewTest\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e [\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: string]: string;\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eNewTest\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etest\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e''\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eJSDOC @link 태그를 위한 편집기 지원: JSDoc/TSDoc의 '@link 변수/타입/링크' 인라인 태그가 이제 지원되며 편집기에서 표시되고 해결됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e originalValue = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e/**\n * {\u003cspan class=\"hljs-doctag\"\u003e@link\u003c/span\u003e originalValue}의 복사본\n */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e value = originalValue;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eTypeScript 4.4\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e정확한 선택적 속성 유형 (--exactOptionalPropertyTypes): 컴파일러 플래그 --exactOptionalPropertyTypes (또는 tsconfig.json에)를 사용하면, 암시적으로 undefined를 허용하는 속성에 대해 undefined로 할당하는 것이 허용되지 않습니다 (예: property?: string). 대신, property: string | undefined와 같이 명시적으로 undefined를 허용해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e {\n  name?: string;\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: number | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e test = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e();\ntest.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 타입 오류: 'exactOptionalPropertyTypes: true'를 사용하여 'undefined' 타입을 'string'에 할당할 수 없습니다. 대상의 유형에 'undefined'를 추가하는 것을 고려해보세요.\u003c/span\u003e\ntest.\u003cspan class=\"hljs-property\"\u003eage\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(test.\u003cspan class=\"hljs-property\"\u003eage\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eTypeScript 4.5\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eAwaited\u003ccode\u003e 유형 및 Promise 개선: 새로운 Awaited\u003c/code\u003e 유틸리티 유형은 무한히 중첩된 Promises에서 값 유형을 추출합니다 (값에 대해 await이 하는 것과 같이). 이는 또한 Promise.all()에 대한 유형 추론을 개선했습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 제네릭 대기값을 가지고 싶다고 가정해 봅시다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이러한 경우 Awaited 유틸리티 타입을 사용할 수 있습니다 (소스 코드는 이전 예제의 일부였습니다).\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 따라서 무한하게 중첩된 Promises가 모두 값으로 해결됩니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-variable constant_\"\u003eP1\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eAwaited\u003c/span\u003e\u0026#x3C;string\u003e; \u003cspan class=\"hljs-comment\"\u003e// 문자열로 타입 지정\u003c/span\u003e\ntype \u003cspan class=\"hljs-variable constant_\"\u003eP2\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eAwaited\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;string\u003e\u003e; \u003cspan class=\"hljs-comment\"\u003e// 문자열로 타입 지정\u003c/span\u003e\ntype \u003cspan class=\"hljs-variable constant_\"\u003eP3\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eAwaited\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;string\u003e\u003e\u003e; \u003cspan class=\"hljs-comment\"\u003e// 문자열로 타입 지정\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eImport 이름에 대한 유형 수식어: 일반 (import type 아닌) import 문 안에서 type 키워드를 사용하여 해당 값이 유형 컴파일을 위해만 가져와야 함을 신호로 삼을 수 있습니다 (컴파일 후에 제거할 수 있습니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이전:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 유형을 가져오는 가장 좋은 방법은 `import type` 키워드를 사용하여 컴파일 이후에 실제로 가져오지 않도록 하는 것입니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { something } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./file'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e type { \u003cspan class=\"hljs-title class_\"\u003eSomeType\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./file'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 이 파일에 대해 두 개의 import 문이 필요했습니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이제 이를 하나의 문으로 결합할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { something, type \u003cspan class=\"hljs-title class_\"\u003eSomeType\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./file'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eConst 어순: 상수를 정의할 때 const 키워드를 사용하여 이를 리터럴 타입으로 정확하게 지정할 수 있습니다. 이는 다양한 용례가 있으며 정확한 유형 정의가 쉬워집니다. 또한 상수 객체와 배열은 읽기 전용이 되어 상수 객체의 변이를 방지합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이전:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'foo'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etoggle\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e }; \u003cspan class=\"hljs-comment\"\u003e// { name: string; value: number; toggle: boolean; }으로 타입 지정됨\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 일반적으로 타입이 지정되어 있으므로 어느 값이든 할당 가능합니다.\u003c/span\u003e\nobj.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'bar'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tuple = [\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// (string | number | boolean)[]으로 타입 지정됨\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 타입으로 길이와 정확한 형식을 결정할 수 없습니다. 어떤 값이든 어디에든 할당할 수 있습니다.\u003c/span\u003e\ntuple[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\ntuple[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 방식:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e objNew = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'foo'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etoggle\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// { readonly name: \"foo\"; readonly value: 9; readonly toggle: false; }으로 타입 지정됨\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 값을 할당할 수 없습니다 (\"foo\"(그리고 readonly로 정의되었기 때문).\u003c/span\u003e\nobjNew.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'bar'\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 타입 에러: 'name'에 할당할 수 없습니다. 읽기 전용 속성입니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tupleNew = [\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e] \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// readonly [\"name\", 4, true]으로 타입 지정됨\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이제 길이와 정확한 형식이 정의되어 있고, 값을 할당할 수 없습니다 (리터럴로 정의되었으며 readonly).\u003c/span\u003e\ntupleNew[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 타입 에러: '0'에 할당할 수 없습니다. 읽기 전용 속성입니다.\u003c/span\u003e\ntupleNew[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 타입 에러: 'readonly[\"name\", 4, true]'에 있는 인덱스 서명에는 읽기만 허용됩니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e클래스 내의 메서드에 대한 코드 조각 완성: 클래스가 메서드 타입을 상속하면 편집기에서 코드 조각으로 제안됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eTypeScript 4.6\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e인덱스된 액세스 추론 개선: 키로 직접 타입을 색인화할 때, 이제 같은 객체에 있는 경우 타입이 더 정확해집니다. 현대적인 TypeScript로 어떤 것이 가능한지 보여주는 좋은 예시입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einterface \u003cspan class=\"hljs-title class_\"\u003eAllowedTypes\u003c/span\u003e {\n  \u003cspan class=\"hljs-string\"\u003e'number'\u003c/span\u003e: number;\n  \u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-string\"\u003e'boolean'\u003c/span\u003e: boolean;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Record는 허용된 타입의 종류와 값 타입을 지정합니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eUnionRecord\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eAllowedKeys\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e keyof \u003cspan class=\"hljs-title class_\"\u003eAllowedTypes\u003c/span\u003e\u003e = { [\u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAllowedKeys\u003c/span\u003e]:\n{\n  \u003cspan class=\"hljs-attr\"\u003ekind\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e;\n  \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAllowedTypes\u003c/span\u003e[\u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e];\n  \u003cspan class=\"hljs-attr\"\u003elogValue\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue: AllowedTypes[Key]\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e;\n}\n}[\u003cspan class=\"hljs-title class_\"\u003eAllowedKeys\u003c/span\u003e];\n\n\u003cspan class=\"hljs-comment\"\u003e// 함수 logValue는 Record의 값만을 허용합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e processRecord\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e keyof \u003cspan class=\"hljs-title class_\"\u003eAllowedTypes\u003c/span\u003e\u003e(\u003cspan class=\"hljs-attr\"\u003erecord\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUnionRecord\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eKey\u003c/span\u003e\u003e) {\n  record.\u003cspan class=\"hljs-title function_\"\u003elogValue\u003c/span\u003e(record.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003eprocessRecord\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003ekind\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'hello!'\u003c/span\u003e,\n\n  \u003cspan class=\"hljs-comment\"\u003e// 값이 암묵적으로 string | number | boolean 타입을 가졌던 것이\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 이제 올바르게 오직 string으로 추론됩니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003elogValue\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value.\u003cspan class=\"hljs-title function_\"\u003etoUpperCase\u003c/span\u003e());\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eTypeScript 추적 분석기 (--generateTrace): --generateTrace '출력 폴더' 옵션을 사용하여 TypeScript CLI가 타입 검사 및 컴파일 프로세스에 대한 자세한 내용을 포함한 파일을 생성할 수 있습니다. 이는 복잡한 타입을 최적화하는 데 도움이 될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etsc --generateTrace trace\n\ncat trace/trace.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e\n\u0026#x3C;\u0026#x3C;출력\n[\n{\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"process_name\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"args\"\u003c/span\u003e:{\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"tsc\"\u003c/span\u003e},\u003cspan class=\"hljs-string\"\u003e\"cat\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"__metadata\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ph\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"M\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ts\"\u003c/span\u003e:...,\u003cspan class=\"hljs-string\"\u003e\"pid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"tid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e},\n{\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"thread_name\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"args\"\u003c/span\u003e:{\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"Main\"\u003c/span\u003e},\u003cspan class=\"hljs-string\"\u003e\"cat\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"__metadata\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ph\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"M\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ts\"\u003c/span\u003e:...,\u003cspan class=\"hljs-string\"\u003e\"pid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"tid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e},\n{\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"TracingStartedInBrowser\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"cat\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"disabled-by-default-devtools.timeline\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ph\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"M\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ts\"\u003c/span\u003e:...,\u003cspan class=\"hljs-string\"\u003e\"pid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"tid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e},\n{\u003cspan class=\"hljs-string\"\u003e\"pid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"tid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ph\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"B\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"cat\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"program\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ts\"\u003c/span\u003e:...,\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"createProgram\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"args\"\u003c/span\u003e:{\u003cspan class=\"hljs-string\"\u003e\"configFilePath\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"/...\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"rootDir\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"/...\"\u003c/span\u003e},\n{\u003cspan class=\"hljs-string\"\u003e\"pid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"tid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ph\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"B\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"cat\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"parse\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ts\"\u003c/span\u003e:...,\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"createSourceFile\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"args\"\u003c/span\u003e:{\u003cspan class=\"hljs-string\"\u003e\"path\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"/...\"\u003c/span\u003e},\n{\u003cspan class=\"hljs-string\"\u003e\"pid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"tid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ph\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"E\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"cat\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"parse\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ts\"\u003c/span\u003e:...,\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"createSourceFile\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"args\"\u003c/span\u003e:{\u003cspan class=\"hljs-string\"\u003e\"path\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"/...\"\u003c/span\u003e},\n{\u003cspan class=\"hljs-string\"\u003e\"pid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"tid\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ph\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"X\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"cat\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"program\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"ts\"\u003c/span\u003e:...,\u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"resolveModuleNamesWorker\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"dur\"\u003c/span\u003e:...,\u003cspan class=\"hljs-string\"\u003e\"args\"\u003c/span\u003e:{\u003cspan class=\"hljs-string\"\u003e\"containingFileName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"/...\"\u003c/span\u003e},\n...\n출력\n\ncat trace/types.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e\n\u0026#x3C;\u0026#x3C;출력\n[{\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"intrinsicName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"any\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"recursionId\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"flags\"\u003c/span\u003e:[\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e]},\n{\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"intrinsicName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"any\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"recursionId\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"flags\"\u003c/span\u003e:[\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e]},\n{\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"intrinsicName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"any\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"recursionId\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"flags\"\u003c/span\u003e:[\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e]},\n{\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"intrinsicName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"error\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"recursionId\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"flags\"\u003c/span\u003e:[\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e]},\n{\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"intrinsicName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"unresolved\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"recursionId\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"flags\"\u003c/span\u003e:[\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e]},\n{\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"intrinsicName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"any\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"recursionId\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"flags\"\u003c/span\u003e:[\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e]},\n{\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"intrinsicName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"intrinsic\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"recursionId\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"flags\"\u003c/span\u003e:[\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e]},\n{\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"intrinsicName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"unknown\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"recursionId\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"flags\"\u003c/span\u003e:[\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e]},\n{\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"intrinsicName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"unknown\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"recursionId\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"flags\"\u003c/span\u003e:[\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e]},\n{\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"intrinsicName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"undefined\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"recursionId\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"flags\"\u003c/span\u003e:[\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e]},\n{\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"intrinsicName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"undefined\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"recursionId\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"flags\"\u003c/span\u003e:[\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e]},\n{\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"intrinsicName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"null\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"recursionId\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"flags\"\u003c/span\u003e:[\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e]},\n{\u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"intrinsicName\"\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"recursionId\"\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"flags\"\u003c/span\u003e:[\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e]},\n...\n출력\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eTypeScript 4.7\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eNode.js에서 ECMAScript 모듈 지원: CommonJS 대신 ES 모듈을 사용할 때, TypeScript가 이제 default를 지정할 수 있습니다. tsconfig.json에서 지정하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\u003cspan class=\"hljs-string\"\u003e\"compilerOptions\"\u003c/span\u003e: [\n  ...\n  \u003cspan class=\"hljs-string\"\u003e\"module\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"es2020\"\u003c/span\u003e\n]\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003epackage.json의 type: package.json의 type 필드를 \"module\"로 설정할 수 있습니다. 이것은 Node.js와 ES 모듈을 사용하기 위해 필요합니다. 대부분의 경우에 TypeScript에 충분하며 위의 컴파일러 옵션이 필요하지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"module\"\u003c/span\u003e\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e인스턴스화 표현식: 인스턴스화 표현식을 사용하면 값을 참조할 때 유형 매개변수를 지정할 수 있습니다. 이를 통해 래퍼를 생성하지 않고 일반적인 유형을 좁힐 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;T\u003e {\n  private \u003cspan class=\"hljs-attr\"\u003elist\u003c/span\u003e: T[] = [];\n\n  \u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: number): T {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elist\u003c/span\u003e[key];\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: T): \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elist\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(value);\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e makeList\u0026#x3C;T\u003e(\u003cspan class=\"hljs-attr\"\u003eitems\u003c/span\u003e: T[]): \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;T\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e list = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\u0026#x3C;T\u003e();\n  items.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e =\u003e\u003c/span\u003e list.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(item));\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e list;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 특정 값만 허용하는 목록을 만드는 함수가 필요한 경우를 가정해 봅시다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이전:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 직접 래퍼 함수를 정의하고 인수를 전달해야 했습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emakeStringList\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etext: string[]\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emakeList\u003c/span\u003e(text);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 방법:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 인스턴스화 표현식을 사용하면 훨씬 쉽습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e makeNumberList = makeList\u0026#x3C;number\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e추론된 유형 변수에 대한 extend 제한: 조건부 유형에서 유형 변수를 추론할 때, extends를 사용하여 직접 좁히거나 제한할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 배열의 첫 번째 요소가 문자열인 경우에만 해당 요소를 가져오는 유형을 작성하려고 한다고 가정해 봅시다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이를 위해 조건부 유형을 사용할 수 있습니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 이전:\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eFirstIfStringOld\u003c/span\u003e\u0026#x3C;T\u003e =\n  T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e [infer S, ...unknown[]]\n    ? S \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e string ? S : never\n    : never;\n\n\u003cspan class=\"hljs-comment\"\u003e// 그러나 이 방법은 두 개의 중첩된 조건부 유형이 필요합니다. 이를 하나의 유형으로도 할 수 있습니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eFirstIfString\u003c/span\u003e\u0026#x3C;T\u003e =\n  T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e [string, ...unknown[]]\n    \u003cspan class=\"hljs-comment\"\u003e// `T`에서 첫 번째 유형을 가져옵니다.\u003c/span\u003e\n    ? T[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n    : never;\n\n\u003cspan class=\"hljs-comment\"\u003e// 이것도 여전히 최적화되지 않은 상태이며 올바른 유형을 위해 배열을 인덱싱해야 합니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 방식:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 추론된 유형 변수에 extends 제약 조건을 사용하여 이를 더 간단하게 선언할 수 있습니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eFirstIfStringNew\u003c/span\u003e\u0026#x3C;T\u003e =\n  T \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e [infer S \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e string, ...unknown[]]\n    ? S\n    : never;\n\u003cspan class=\"hljs-comment\"\u003e// 유형을 알아내는 방식은 이전과 동일하지만 더 깔끔한 구문입니다.\u003c/span\u003e\n\ntype A = \u003cspan class=\"hljs-title class_\"\u003eFirstIfStringNew\u003c/span\u003e\u0026#x3C;[string, number, number]\u003e; \u003cspan class=\"hljs-comment\"\u003e// string으로 유형 지정\u003c/span\u003e\ntype B = \u003cspan class=\"hljs-title class_\"\u003eFirstIfStringNew\u003c/span\u003e\u0026#x3C;[\u003cspan class=\"hljs-string\"\u003e\"hello\"\u003c/span\u003e, number, number]\u003e; \u003cspan class=\"hljs-comment\"\u003e// \"hello\"로 유형 지정\u003c/span\u003e\ntype C = \u003cspan class=\"hljs-title class_\"\u003eFirstIfStringNew\u003c/span\u003e\u0026#x3C;[\u003cspan class=\"hljs-string\"\u003e\"hello\"\u003c/span\u003e | \u003cspan class=\"hljs-string\"\u003e\"world\"\u003c/span\u003e, boolean]\u003e; \u003cspan class=\"hljs-comment\"\u003e// \"hello\" 또는 \"world\"로 유형 지정\u003c/span\u003e\ntype D = \u003cspan class=\"hljs-title class_\"\u003eFirstIfStringNew\u003c/span\u003e\u0026#x3C;[boolean, number, string]\u003e; \u003cspan class=\"hljs-comment\"\u003e// never로 유형 지정\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e유형 매개변수를 위한 선택적 분산 주석: 제네릭은 \"일치하는지\" 확인할 때 다른 동작을 가질 수 있습니다. 예를 들어, 상속을 허용할 경우 getters 및 setters에 대해 반대로 반전됩니다. 이제 이를 명시적으로 지정할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 다른 인터페이스 / 클래스를 확장하는 인터페이스가 있다고 가정해 봅시다.\u003c/span\u003e\ninterface \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eanimalStuff\u003c/span\u003e: any;\n}\n\ninterface \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003edogStuff\u003c/span\u003e: any;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 그리고 일반적인 \"getter\" 및 \"setter\"가 있습니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eGetter\u003c/span\u003e\u0026#x3C;T\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e T;\n\ntype \u003cspan class=\"hljs-title class_\"\u003eSetter\u003c/span\u003e\u0026#x3C;T\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue: T\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// Getter\u0026#x3C;T1\u003e과 Getter\u0026#x3C;T2\u003e 또는 Setter\u0026#x3C;T1\u003e과 Setter\u0026#x3C;T2\u003e가 일치하는지 확인하려면 분산에 따라 달라집니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003euseAnimalGetter\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003egetter: Getter\u0026#x3C;Animal\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003egetter\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 이제 함수에 Getter를 전달할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003euseAnimalGetter\u003c/span\u003e((\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e ({ \u003cspan class=\"hljs-attr\"\u003eanimalStuff\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e }) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e));\n\u003cspan class=\"hljs-comment\"\u003e// 당연히 작동합니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 그러나 Dog를 반환하는 Getter를 사용하려면 어떻게 해야 할까요?\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003euseAnimalGetter\u003c/span\u003e((\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e ({ \u003cspan class=\"hljs-attr\"\u003eanimalStuff\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edogStuff\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e }) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e));\n\u003cspan class=\"hljs-comment\"\u003e// 이 또한 작동합니다. 왜냐하면 Dog도 Animal이기 때문입니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003euseDogGetter\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003egetter: Getter\u0026#x3C;Dog\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003egetter\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// useDogGetter 함수에 동일한 작업을 시도하면 동일한 동작을 얻지 못할 것입니다.\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003euseDogGetter\u003c/span\u003e((\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e ({ \u003cspan class=\"hljs-attr\"\u003eanimalStuff\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e }) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Type error: Property 'dogStuff' is missing in type 'Animal' but required in type 'Dog'.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이는 Animal이 아닌 Dog가 필요하기 때문에 작동하지 않습니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003euseDogGetter\u003c/span\u003e((\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e ({ \u003cspan class=\"hljs-attr\"\u003eanimalStuff\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edogStuff\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e }) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 그러나 이 경우는 작동합니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 직관적으로 Setters가 같은 방식으로 작동할 것으로 기대할 수도 있지만, 사실은 그렇지 않습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetAnimalSetter\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esetter: Setter\u0026#x3C;Animal\u003e, value: Animal\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003esetter\u003c/span\u003e(value);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 동일한 유형의 Setter를 전달해도 작동합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003esetAnimalSetter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue: Animal\u003c/span\u003e) =\u003e\u003c/span\u003e {}, { \u003cspan class=\"hljs-attr\"\u003eanimalStuff\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e });\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetDogSetter\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esetter: Setter\u0026#x3C;Dog\u003e, value: Dog\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003esetter\u003c/span\u003e(value);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 여기도 마찬가지로 작동합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003esetDogSetter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue: Dog\u003c/span\u003e) =\u003e\u003c/span\u003e {}, { \u003cspan class=\"hljs-attr\"\u003eanimalStuff\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edogStuff\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e });\n\n\u003cspan class=\"hljs-comment\"\u003e// 그러나 Dog Setter를 setAnimalSetter 함수에 전달하면 Getter와는 반대로 동작이 반전됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003esetAnimalSetter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue: Dog\u003c/span\u003e) =\u003e\u003c/span\u003e {}, { \u003cspan class=\"hljs-attr\"\u003eanimalStuff\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edogStuff\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e }); \u003cspan class=\"hljs-comment\"\u003e// Type error: Argument of type '(value: Dog) =\u003e void' is not assignable to parameter of type 'Setter\u0026#x3C;Animal\u003e'.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 이번에는 상황이 반대로 작동합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003esetDogSetter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue: Animal\u003c/span\u003e) =\u003e\u003c/span\u003e {}, { \u003cspan class=\"hljs-attr\"\u003eanimalStuff\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003edogStuff\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e });\n\n\u003cspan class=\"hljs-comment\"\u003e// 새로운 방법:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// TypeScript에이를 표시하기 위해 (필수는 아니지만 가독성을 위해 유용), 유형 매개변수에 대한 선택적 분산 주석을 사용합니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003eGetterNew\u003c/span\u003e\u0026#x3C;out T\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e T;\ntype \u003cspan class=\"hljs-title class_\"\u003eSetterNew\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e T\u003e = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue: T\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003emoduleSuffixes로 해상도 사용자 정의: 사용자 정의 파일 접미사를 사용하는 환경(예: 네이티브 앱 빌드에 .ios를 사용하는 경우)에서는 TypeScript가 가져오기를 정확하게 해석하도록 이 접미사를 tsconfig.json에 지정할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\u003cspan class=\"hljs-string\"\u003e\"compilerOptions\"\u003c/span\u003e: [\n  ...\n  \u003cspan class=\"hljs-string\"\u003e\"moduleSuffixes\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\".ios\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\".native\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e]\n]\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e foo \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./foo'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 이 코드는 먼저 ./foo.ios.ts를 확인하고, 그 다음에는 ./foo.native.ts를, 마지막으로 ./foo.ts를 확인합니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e에디터에서 소스 정의로 이동: 에디터에서 새로운 \"소스 정의로 이동\" 메뉴 옵션이 사용 가능합니다. 이는 \"정의로 이동\"과 유사하지만, .ts 및 .js 파일을 .d.ts 타입 정의 파일보다 우선합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:800/1*qvzGqfF844cXCPMeDrg_IQ.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003eTypeScript 4.9\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esatisfies\u003c/code\u003e 연산자: \u003ccode\u003esatisfies\u003c/code\u003e 연산자는 실제로 그 타입을 할당하지 않고도 타입과의 호환성을 확인할 수 있게 해줍니다. 이를 통해 더 정확한 추론된 타입을 유지하면서도 호환성을 유지할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이전:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 여러 항목과 그 색상을 저장하는 객체/맵/딕셔너리가 있다고 가정해 보겠습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e obj = {\n  \u003cspan class=\"hljs-attr\"\u003efireTruck\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003ebush\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#00ff00'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eocean\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e]\n} \u003cspan class=\"hljs-comment\"\u003e// { fireTruck: number[]; bush: string; ocean: number[]; } 타입으로 정의됨\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 배열과 문자열에 대해 작업을 수행할 수 있도록 속성을 암시적으로 타입 지정합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e rgb1 = obj.\u003cspan class=\"hljs-property\"\u003efireTruck\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// 숫자로 타입 지정\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hex = obj.\u003cspan class=\"hljs-property\"\u003ebush\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 문자열로 타입 지정\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 특정 객체만 허용하고 싶다면 Record 타입을 사용할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eoldObj\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eRecord\u003c/span\u003e\u0026#x3C;string, [number, number, number] | string\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003efireTruck\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003ebush\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#00ff00'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eocean\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e]\n} \u003cspan class=\"hljs-comment\"\u003e// Record\u0026#x3C;string, [number, number, number] | string\u003e 타입으로 정의됨\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 하지만 이제 우리는 속성의 타입에 대한 정보를 잃어버립니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldRgb1 = oldObj.\u003cspan class=\"hljs-property\"\u003efireTruck\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// string 또는 number로 타입 지정\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e oldHex = oldObj.\u003cspan class=\"hljs-property\"\u003ebush\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// string 또는 number로 타입 지정\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 새롭게:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// `satisfies` 키워드를 사용하여 타입과 호환성을 확인할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newObj = {\n  \u003cspan class=\"hljs-attr\"\u003efireTruck\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003ebush\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'#00ff00'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eocean\u003c/span\u003e: [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e]\n} satisfies \u003cspan class=\"hljs-title class_\"\u003eRecord\u003c/span\u003e\u0026#x3C;string, [number, number, number] | string\u003e \u003cspan class=\"hljs-comment\"\u003e// { fireTruck: [number, number, number]; bush: string; ocean: [number, number, number]; } 타입으로 정의됨\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이제 속성의 타입에 대한 정보를 유지할 수 있을 뿐만 아니라 배열은 튜플로 더 정확해집니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newRgb1 = newObj.\u003cspan class=\"hljs-property\"\u003efireTruck\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// 숫자로 타입 지정\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newRgb4 = newObj.\u003cspan class=\"hljs-property\"\u003efireTruck\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]; \u003cspan class=\"hljs-comment\"\u003e// 타입 오류: 길이가 '3'인 튜플 타입 '[number, number, number]'에는 인덱스 '3'에 해당하는 요소가 없습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newHex = newObj.\u003cspan class=\"hljs-property\"\u003ebush\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 문자열로 타입 지정\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e편집기의 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령: 편집기에서 새로운 \"사용되지 않는 Imports 제거\" 및 \"Imports 정렬\" 명령(및 자동 수정)을 사용하면 Imports를 관리하는 것이 더 쉬워집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:800/1*z5SG6BKwzyxrG6sG7OKciw.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003eTypeScript 5.0\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eES 데코레이터 지원: TypeScript는 이제 ES 데코레이터(곧 나올 ES 기능)를 지원하며, 기존 데코레이터와는 다릅니다. 이전에 TypeScript는 데코레이터에 대해 실험적인 지원을 했었는데, 이는 Angular와 같은 프레임워크에서 사용되는 것으로, --experimentalDecorators 플래그(또는 tsconfig.json에서)로 선택할 수 있었으며 약간 다르게 동작했습니다. 그러나 이제 새로운 ES 데코레이터는 이전 것과는 다르게 메타데이터를 내보내지 못하며 아직은 매개변수에서도 지원되지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 주의: 2023년 5월 기준으로 이것은 예정된 ES 기능이므로 이 코드는 아직 작동하지 않습니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 디버깅 중에 메서드에 진입하거나 나갈 때마다 기록하려고 합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이것을 수동으로 하는 것은 상당히 지루할 수 있습니다. 자동화할 방법이 있을까요?\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 네, 데코레이터를 사용하여 실행 컨텍스트를 대체할 수 있습니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 먼저 데코레이터 역할을 할 함수를 정의합니다. 이 함수는 원본 메서드와 컨텍스트 개체를 매개변수로 받아 새로운 실행 함수를 반환합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e logMethod\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eThis\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eArgs\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e any[], \u003cspan class=\"hljs-title class_\"\u003eReturn\u003c/span\u003e\u003e(\u003cspan class=\"hljs-attr\"\u003eoriginalMethod\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e: This, ...args: Args\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReturn\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003econtext\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eClassMethodDecoratorContext\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e methodName = \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(context.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereplacementFunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e: This, ...args: Args\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`LOG: 메서드 '\u003cspan class=\"hljs-subst\"\u003e${methodName}\u003c/span\u003e' 진입 중.`\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = originalMethod.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, ...args);\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`LOG: 메서드 '\u003cspan class=\"hljs-subst\"\u003e${methodName}\u003c/span\u003e' 나감.`\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e replacementFunction;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 이제 이를 사용할 클래스를 정의합니다. 데코레이터는 클래스와 그 멤버에만 작동합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 메서드에 '@'와 함수명을 사용하여 데코레이터를 적용합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e {\n  @logMethod\n  \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'작업 중'\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e testObj = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 메서드를 실행하면 대체 메서드가 호출됩니다.\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(testObj.\u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// \"LOG: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"LOG: 메서드 'doSomething' 나감.\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 사용자 정의 메시지와 같은 추가 인수를 전달하려면 데코레이터 팩토리(데코레이터 함수를 반환하는 함수)를 정의할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elogMethodCustom\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecustomMessage: string\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eThis\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eArgs\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e any[], \u003cspan class=\"hljs-title class_\"\u003eReturn\u003c/span\u003e\u003e\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eoriginalMethod: (\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e: This, ...args: Args) =\u003e Return, context: ClassMethodDecoratorContext\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e methodName = \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(context.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereplacementFunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e: This, ...args: Args\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${customMessage}\u003c/span\u003e: 메서드 '\u003cspan class=\"hljs-subst\"\u003e${methodName}\u003c/span\u003e' 진입 중.`\u003c/span\u003e)\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = originalMethod.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, ...args);\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${customMessage}\u003c/span\u003e: 메서드 '\u003cspan class=\"hljs-subst\"\u003e${methodName}\u003c/span\u003e' 나감.`\u003c/span\u003e)\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e replacementFunction;\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 이번에는 함수 호출을 포함하는 `()`로 된 추가 인수를 사용하여 메서드에 데코레이터를 적용합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTestCustom\u003c/span\u003e {\n  @\u003cspan class=\"hljs-title function_\"\u003elogMethodCustom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'테스트 로그'\u003c/span\u003e)\n  \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'작업 중'\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e testCustomObj = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 메서드 실행시 모든 작업이 예상대로 작동합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(testCustomObj.\u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// \"테스트 로그: 메서드 'doSomething' 진입 중.\", \"작업 중\", \"테스트 로그: 메서드 'doSomething' 나감.\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 데코레이터 함수에서 대체 메서드를 반환하지 않으면 원본 메서드가 호출되지만 관련 설정을 아직 설정할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 예를 들어 `constructor` 단계 이전에 `this`를 바인딩하여 클래스 외부에서 콜백으로 전달할 경우 동일하게 실행되도록합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// `constructor` 단계 이전에 코드를 실행하려면 컨텍스트 개체의 `addInitializer` 메서드를 사용할 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebindThis\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_: unknown, context: ClassMethodDecoratorContext\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e methodName = context.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (context.\u003cspan class=\"hljs-property\"\u003eprivate\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`'bound'는 \u003cspan class=\"hljs-subst\"\u003e${methodName \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e string}\u003c/span\u003e과 같은 비공개 속성을 데코레이션할 수 없습니다.`\u003c/span\u003e);\n}\ncontext.\u003cspan class=\"hljs-title function_\"\u003eaddInitializer\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e: any\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e methodName = context.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e methodName === \u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e[methodName] = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e[methodName].\u003cspan class=\"hljs-title function_\"\u003ebind\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e);\n    }\n  });\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 바인딩하지 않은 상태로 한번 정의합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTestUnbound\u003c/span\u003e {\n  private returnVal = \u003cspan class=\"hljs-string\"\u003e'작업 중'\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ereturnVal\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e testUnboundObj = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTestUnbound\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 메서드에 다시 \"데코레이터\"를 적용합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTestBound\u003c/span\u003e {\n  private returnVal = \u003cspan class=\"hljs-string\"\u003e'작업 중'\u003c/span\u003e;\n\n  @bindThis\n  \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ereturnVal\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e testBoundObj = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTestBound\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 클래스 컨텍스트 외부에 메서드를 저장하고 실행시키면 속성 값에 액세스할 수 없습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e unboundFunc = testUnboundObj.\u003cspan class=\"hljs-property\"\u003edoSomething\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eunboundFunc\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// 오류: \"Cannot read properties of undefined (reading 'returnVal')\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 그러나 바인딩하면 예상대로 작동합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e boundFunc = testBoundObj.\u003cspan class=\"hljs-property\"\u003edoSomething\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eboundFunc\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// \"작업 중\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003econst 형식 매개변수: 형식 매개변수 앞에 const를 지정하는 const는 readonly 형식을 그대로 사용하는 것처럼 동작하도록 시도합니다. 그러나 변경 가능한 값을 형식화했다면 인자유추가 작동하지 않을 수 있습니다(왜냐하면 읽기전용 형식은 변경 가능한 형식에 할당할 수 없기 때문에 항상 readonly 형식을 상속해야 합니다). 이것은 여전히 허용된 매개변수를 제한하지 않습니다. 여전히 extends 내에서 제한해야 합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e타입을 활용한 여러 구성 파일 지원: 복잡한 상속 구조를 만들거나 모든 \"tsconfig\"에서 항상 동일한 구성을 확장하거나 모든 설정을 복사하여 모두 복사하는 대신, \"tsconfig\" 파일에서 \"extends\": [\"./tsconfig1.json\", \"./tsconfig2.json\"]를 지정함으로써 여러 파일을 확장하여 동작을 재정의할 수 있습니다. 후자의 파일이 오버라이드 동작을 우선시합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e...\n\u003cspan class=\"hljs-comment\"\u003e// 여기서 \"tsconfig1.json\"은 \"@tsconfig/strictest/tsconfig.json\"을 덮어씁니다. \"tsconfig2.json\"은 \"tsconfig1.json\"과 \"@tsconfig/strictest/tsconfig.json\"을 덮어쓰며, 이 파일은 모두 덮어씁니다.\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"extends\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"@tsconfig/strictest/tsconfig.json\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"./tsconfig1.json\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"./tsconfig2.json\"\u003c/span\u003e],\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e모든 열거형이 합집합 열거형입니다: 동적으로 할당된 열거형 값은 이제 더 이상 예전의 열거형 전략 기본값을 갖지 않습니다(열거형 키에 대한 타입 없음, 값으로만 사용 가능하며 타입으로 사용할 수 없음). 대신 이제 타입으로도 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 열거형은 각 값마다 다른 타입을 만듭니다.\u003c/span\u003e\nenum \u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eRed\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eGreen\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eBlue\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOrange\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eYellow\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eViolet\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 이를 통해 그들을 좁히고 다른 타입처럼 사용할 수 있습니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003ePrimaryColor\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eRed\u003c/span\u003e | \u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eGreen\u003c/span\u003e | \u003cspan class=\"hljs-title class_\"\u003eColor\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBlue\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 하지만:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 값이 동적으로 할당되면 고정된 값이 없습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 이전에는 예전 열거형 동작으로 되돌아가게 되었습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 예전 열거형 동작에서 그 멤버는 값으로만 존재하며 타입으로는 존재하지 않음.\u003c/span\u003e\nenum \u003cspan class=\"hljs-title class_\"\u003eColorRandom\u003c/span\u003e {\n  \u003cspan class=\"hljs-title class_\"\u003eRed\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e(),\n  \u003cspan class=\"hljs-title class_\"\u003eGreen\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e(),\n  \u003cspan class=\"hljs-title class_\"\u003eBlue\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e(),\n  \u003cspan class=\"hljs-title class_\"\u003eOrange\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e(),\n  \u003cspan class=\"hljs-title class_\"\u003eYellow\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e(),\n  \u003cspan class=\"hljs-title class_\"\u003eViolet\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e()\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 그래서 이전에는 좁혀지지 못했습니다.\u003c/span\u003e\ntype \u003cspan class=\"hljs-title class_\"\u003ePrimaryColorRandom\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eColorRandom\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eRed\u003c/span\u003e | \u003cspan class=\"hljs-title class_\"\u003eColorRandom\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eGreen\u003c/span\u003e | \u003cspan class=\"hljs-title class_\"\u003eColorRandom\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eBlue\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 이전 타입 오류: Enum 타입 'ColorRandom'은 리터럴이 아닌 초기화 값을 갖는 멤버를 가지고 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 하지만 이제 그들에게도 자체 타입이 있기 때문에 작동합니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e--moduleResolution bundler: TS 4.7의 모듈 해결 전략 \"node16\"은 ES 모듈을 더 잘 모델링할 수 있게 해주지만 일부 불필요한 제약이 있었습니다(파일 확장자를 명시해야 했으며, ...). 번들러를 사용 중이라면, 새 전략은 최신 기능을 유지하면서 일부 제약을 제거하려고 시도합니다. 컴파일러 플래그 --moduleResolution bundle를 지정하여 사용할 수 있습니다(또는 tsconfig.json에서). 번들러를 사용할 때만 사용하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e...\n\u003cspan class=\"hljs-attr\"\u003e\"compilerOptions\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\n  ...\n  \u003cspan class=\"hljs-attr\"\u003e\"moduleResolution\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"bundler\"\u003c/span\u003e\n\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003eimport * as foo from './foo';\n\u003cspan class=\"hljs-comment\"\u003e// 이제는 파일 확장자가 지정되지 않아도 다시 허용됩니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e해상도 Customization Flags: \"hybrid\" 모듈 해상도에 대한 규칙을 설정합니다. 규칙은 다음과 같습니다: allowImportingTsExtensions, resolvePackageJsonExports (imports를 위해 package.json exports을 고려함), resolvePackageJsonImports (#로 시작하는 경로를 위해 로컬 package.json을 참조함), allowArbitraryExtensions 및 customConditions (node16 및 bundler 전용, package.json에서 조건부 exports 및 imports을 위해 사용됨)입니다. 이러한 모든 설정은 --를 접두사로 하여 컴파일러 플래그로 지정하거나 tsconfig.json에 지정할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e...\n\u003cspan class=\"hljs-attr\"\u003e\"compilerOptions\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\n  ...\n  \u003cspan class=\"hljs-attr\"\u003e\"allowImportingTsExtensions\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003efalse\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"resolvePackageJsonExports\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"resolvePackageJsonImports\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"allowArbitraryExtensions\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003e\u003cspan class=\"hljs-keyword\"\u003efalse\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003e\"customConditions\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"my-condition\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 이제는 `package.json`의 `exports` 및 `imports`에 대한 사용자 정의 조건을 해결하려고 시도합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// TS는 그런 다음 해당 사용자 정의 조건에 맞도록 파일을 매칭하려고 할 것입니다 (이 경우 `foo.mjs`).\u003c/span\u003e\n\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n  ...\n  \u003cspan class=\"hljs-string\"\u003e\"exports\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\".\"\u003c/span\u003e: {\n      \u003cspan class=\"hljs-string\"\u003e\"my-condition\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"./foo.mjs\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-string\"\u003e\"node\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"./bar.mjs\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-string\"\u003e\"import\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"./baz.mjs\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-string\"\u003e\"require\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"./biz.mjs\"\u003c/span\u003e\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e--verbatimModuleSyntax:\u003c/strong\u003e 자동으로 import (import elision) 및 exports를 제거하지 않도록 TypeScript를 중지합니다. 이것은 import side effects가 사용될 때 또는 TS가 import가 어디에서 사용되는지 인식하지 못할 때 유용할 수 있습니다. import type 및 export type 문은 여전히 최종 컴파일에서 제거됩니다. 대개 import가 타입인지 아닌지 명시하는 것이 권장됩니다. compiler flag --verbatimModuleSyntax(또는 tsconfig.json에서)를 지정하여 사용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// `verbatimModuleSyntax`가 설정되지 않으면 이 import는 최종 컴파일에서 제거될 것입니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./car'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 이 import는 아무 경우에나 제거될 것입니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e type { \u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./car'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 이 import는 절대로 제거되지 않습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { logCar } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./car'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edrive\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecar: Car\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003elogCar\u003c/span\u003e(car);\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eexport type * 지원:\u003c/strong\u003e 기본 형식을 하위 모듈로 쉽게 다시 내보낼 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 기본 타입들을 다른 모듈로서 서브모듈로 내보냅니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e type * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e am \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'another-module'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 또는 다시 기본 내보낸 것으로 제공합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e type * \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'another-module'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e type { am } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'module'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 또는\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e type { } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'module'\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e--build 하위에서 Emit-Specific 플래그 전달: 빌드에 대한 동작을 지정하는 플래그들 (--build를 사용할 때). 이들은 --declaration, --emitDeclarationOnly, --declarationMap, --sourceMap 및 --inlineSourceMap를 포함합니다. 모두 이제 컴파일러 플래그로 지정할 수 있습니다. 이전에는 tsconfig.json에서만 설정할 수 있었어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 이것은 \u003cspan class=\"hljs-string\"\u003e`tsconfig.json`\u003c/span\u003e에서 비활성화되어 있더라도 타입 선언을 생성합니다.\ntsc --build --declaration\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e에디터에서 대소문자 구분 없는 import 정렬: 에디터에서 import를 정렬할 때 대소문자 구분 동작을 변경하세요. 이 기능은 VSCode의 JSON 설정 내 typescript.unstable 아래에서 활성화하고 구성할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1032/1*Fei6JPgYzIgnl_IMekhOQg.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExhaustive switch/case 자동 완성: 에디터에서 이제 리터럴 타입의 case 문을 자동으로 완성할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:656/1*e9FNtf4-kxU787rEl1w9lQ.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-AllJavaScriptandTypeScriptFeaturesofthelast3years"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>