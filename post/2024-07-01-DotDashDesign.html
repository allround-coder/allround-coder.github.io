<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>도트와 대시 디자인 2024년 최신 디자인 트렌드와 활용 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-07-01-DotDashDesign" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="도트와 대시 디자인 2024년 최신 디자인 트렌드와 활용 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="도트와 대시 디자인 2024년 최신 디자인 트렌드와 활용 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-07-01-DotDashDesign_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-07-01-DotDashDesign" data-gatsby-head="true"/><meta name="twitter:title" content="도트와 대시 디자인 2024년 최신 디자인 트렌드와 활용 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-07-01-DotDashDesign_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-07-01 20:03" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">도트와 대시 디자인 2024년 최신 디자인 트렌드와 활용 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="도트와 대시 디자인 2024년 최신 디자인 트렌드와 활용 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jul 1, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-07-01-DotDashDesign&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>PathEffect로 Jetpack Compose에서 선을 특화하세요</h2>
<p><img src="/assets/img/2024-07-01-DotDashDesign_0.png" alt="이미지"></p>
<p>Jetpack Compose에서 UI를 생성할 때 선을 그리는 경우가 많습니다. 때로는 일부 공간을 구분하는 구분선으로, 때로는 더 복잡한 모양이나 디자인의 일부로 시각적으로 사용됩니다. 보통은 단순한 직선일 필요가 없을 때도 있습니다. 점 또는 대시를 사용하면 단순한 직선보다 덜 혹독한 효과를 줄 수 있으며 재미있는 모양이나 스타일 적용된 선 끝을 사용하면 디자인을 더욱 섬세하게 꾸밀 수 있습니다.</p>
<p>만약 선이 모스 부호처럼 점과 대시로 표시되길 원한다면, 선의 스타일링 비밀을 해독하는 방법을 계속 읽어보세요!</p>
<div class="content-ad"></div>
<h1>기본 사항.</h1>
<p>서로 이해하기 위해 기본적인 Jetpack Compose에서 선을 그리는 방법을 알려드리겠습니다:</p>
<p>여기서 선은 수평적이며 캔버스 내부에 있으며 시작 및 끝 오프셋이 있습니다. strokeWidth는 픽셀 값을 설정하며 (제 경우에는 dp에서 변환된 값), 색상을 설정할 수 있습니다. 단색 대신 브러시를 사용하는 버전을 사용하면 더 흥미로운 색상 효과를 적용할 수 있습니다.</p>
<p><img src="/assets/img/2024-07-01-DotDashDesign_1.png" alt="선"></p>
<div class="content-ad"></div>
<p>좌표가 (0,0)에서 시작하여 상단 왼쪽에 있으며 하단 오른쪽이 캔버스의 (너비, 높이) 지점입니다.</p>
<p><img src="/assets/img/2024-07-01-DotDashDesign_2.png" alt="image"></p>
<p>Jetpack Compose 및 DrawScope에서 Canvas에 그리는 방법에 대한 기본 안내서는 공식 문서를 확인해보세요.</p>
<p>이제 선이 그려졌으니, 좀 더 정교하게 만드는 방법은 무엇일까요?</p>
<div class="content-ad"></div>
<h2>선 끝 처리</h2>
<p>첫 번째로 할 수 있는 것은 선에 더 정교한 선 끝을 적용하는 것입니다.</p>
<p>여기서 선택할 수 있는 옵션은 StrokeCap.Butt로, 이는 기본값으로 아무 확장 없이 직사각형 끝이 있는 것입니다. 또한, 선을 반원으로 연장하는 StrokeCap.Rounded와 선을 사각형 모양으로 연장하는 StrokeCap.Square이 있습니다 (이는 Butt처럼 보이지만 연장된 부분이 사각형 모양이다).</p>
<p><img src="/assets/img/2024-07-01-DotDashDesign_3.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>모르는 것은 물어보세요. 실수를 겁내지 말아요. 편하게 물어보세요.</p>
<div class="content-ad"></div>
<p>Markdown 형식으로 표 태그를 변경해주세요.</p>
<div class="content-ad"></div>
<h2>모스 부호</h2>
<p>여기서는 dashPathEffect에 더 많은 간격을 추가하여 대시를 조금 더 복잡하게 만들 수 있습니다:</p>
<p>재미있고 흥미로운 선을 얻을 수 있어요:</p>
<p><img src="/assets/img/2024-07-01-DotDashDesign_6.png" alt="이미지"></p>
<div class="content-ad"></div>
<h1>스탬핑 시간</h1>
<p>만약 여러 줄로 이루어진 선을 원하지 않는다면 어떨까요? 대신에, stampedPathEffect를 사용하여 선 a아에 특정 모양을 찍어낼 수 있습니다. 여기서 원하는 모양을 구성하고, 모양 사이의 간격 (advance, 이전과 같은 상태 및 StampedPathEffectStyle을 사용하여 모양을 설정합니다.</p>
<p>원 모양을 찍어내는 경우, 우리는 원형 점들의 라인을 <img src="/assets/img/2024-07-01-DotDashDesign_7.png"> 처럼 갖게 됩니다.</p>
<div class="content-ad"></div>
<p>StampedPathEffectStyle.Translate은 선을 따라 움직이며 모양을 이전에 정의한 대로 유지합니다. 다른 유형의 StampedPathEffectStyle에 대해서는 나중에 설명하겠습니다. 직선을 보고 있을 때는 실제로 다른 유형이 적용되지 않습니다.</p>
<p>좀 더 화려하게 만들기 위해 모양을 다양하게 만들어보세요:</p>
<p><img src="/assets/img/2024-07-01-DotDashDesign_8.png" alt="image"></p>
<h1>짹짹? 파도?</h1>
<div class="content-ad"></div>
<p>그럼 이런 라인을 만드는 방법이 무엇이 있을까요:</p>
<p><img src="/assets/img/2024-07-01-DotDashDesign_9.png" alt="image"></p>
<p>선을 그리기 위해 경로를 만들고 모든 지그재그를 포인트로 계산하고 그릴 수도 있지만, 이 경로 모양을 한 번 생성한 다음 위에서 한 것처럼 이 경로를 찍으면 됩니다.</p>
<p>첫 번째 시도에서는 모양을 만들고 선을 따라 모양을 찍습니다 (전체 모양과 같은 너비의 진행을 사용하여)</p>
<div class="content-ad"></div>
<p>이것은 예상치 못한 (그러나 좋지 않은 결과는 아닙니다) 결과를 제공합니다:</p>
<p><img src="/assets/img/2024-07-01-DotDashDesign_10.png" alt="image"></p>
<p>보통, 이를 경로로 그릴 때는 <code>DrawStyle.Stroke</code> 스타일을 사용하여 <code>drawPath</code>를 사용할 수 있고 선으로 직선으로 그립니다. 그러나 이것을 모양으로 사용하고 있기 때문에 자동으로 채워집니다. 이를 수정하기 위해 경로를 닫아주어야 합니다.</p>
<p>이것을 줄에 넣으면:</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-07-01-DotDashDesign_11.png" alt="이미지"></p>
<p>여기서 실제 선이 점 (0,0)에서 그려지는 것을 알 수 있습니다. 이로 인해 지그재그 모양이 아래에 매달리고 실제 선의 끝에서 확장됩니다. 이를 더 쉽게 확인할 수 있습니다. 직선 경로를 함께 추가하면:</p>
<p><img src="/assets/img/2024-07-01-DotDashDesign_12.png" alt="이미지"></p>
<p>더욱 정확하게 그리고 싶다면 Offset을 사용하여 경로를 변환해 지정한 선 위에 정확하게 그릴 수 있습니다:</p>
<div class="content-ad"></div>
<p>달콤한 톤으로 한국어로 번역하면:</p>
<img src="/assets/img/2024-07-01-DotDashDesign_13.png">
<p>지그재그 선의 전체 코드:</p>
<h1>물론, 직선뿐만 아니라요!</h1>
<div class="content-ad"></div>
<p>이제 우리는 직선을 그리는 것에 숙달했어요! 만약 이를 도형으로 넣고 싶다면 어떻게 해야 할까요? 그럼 drawRect나 drawCircle 또는 drawPath를 사용해서 원하는 모양을 얻을 수 있어요:</p>
<p><img src="/assets/img/2024-07-01-DotDashDesign_14.png" alt="도형 이미지"></p>
<h2>모서리에서는 어떻게 될까요?</h2>
<p>모서리에서 무슨 일이 일어나나요?</p>
<p>이전에 StampedPathEffectStyle에 대해 언급했었는데, 이것은 직선만 그리지 않을 때 유용해요. 이는 라인이 방향을 바꿀 때 스탬프 경로에게 무엇을 해야 하는지 알려줘요.</p>
<div class="content-ad"></div>
<p>예를 들어, 하트 경로를 사용하여 서로 다른 스타일을 볼 수 있습니다:</p>
<img src="/assets/img/2024-07-01-DotDashDesign_15.png">
<p>번역한 것은 직역이며, 하트 모양의 오프셋을 수정하지 않았기 때문에 모양이 정확한 직사각형 윤곽을 따르지 않아 넘어집니다. 회전 스타일은 그 넘어짐을 수정하는 방식으로 모양을 회전시키지만, 서로 더 가깝거나 멀리 떨어져 있는 일부 하트가 생성됩니다. Morph의 경우에는 진동 경로로 더 쉽게 확인할 수 있습니다:</p>
<img src="/assets/img/2024-07-01-DotDashDesign_16.png">
<div class="content-ad"></div>
<p>여기서는 차이가 더 두드러지며, 회전은 하트 경로에 대해서는 잘 작동하지만 스탬프 모양이 연결된 지그재그에서는 구멍이 모서리에 뚜렷하게 나타납니다(그리고 일부 지점에서 겹침). Morph는 모서리를 따라 변형하여 간극을 해결하고(대부분의 경우 — 좌하단 코너 참조) 보다 부드러운 선 효과를 제공합니다. 하트 경로와 마찬가지로 하트들도 모서리에서 조금 작아져 모서리 주변을 이동할 수 있도록 허용됩니다.</p>
<h1>선. 마스터했다.</h1>
<p>지금은 Jetpack Compose에서 선을 스타일링하고 흥미로운 모양과 경로에서 사용하는 여러 방법을 볼 수 있습니다.</p>
<p>점과 대시로 즐거운 모스 부호를 만들고 사용자들에게 비밀 메시지를 보내세요!</p>
<div class="content-ad"></div>
<p>여기서 사용된 모든 샘플 코드를 내 GitHub 실험에서 찾을 수 있습니다:</p>
<p>옹골지는 사람들은 PathEffect.chainPathEffect에 대해 논의하지 않았다는 것을 알아차릴 수도 있습니다. 솔직히 말해서, 저는 이를 잘 사용할 수 있는 좋은 예제를 구성하지 못했고 다른 사람들이 그것을 사용한 예제를 찾을 수도 없었습니다(심지어 Gemini도 시도했습니다!) 좋은 예제를 발견하면 제게 공유해 주시기 바랍니다.</p>
<p>어쩌면 언젠가 chainPathEffect에 대한 따로 두 번째 파트를 작성할 수도 있을 것입니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"도트와 대시 디자인 2024년 최신 디자인 트렌드와 활용 방법","description":"","date":"2024-07-01 20:03","slug":"2024-07-01-DotDashDesign","content":"\n\n## PathEffect로 Jetpack Compose에서 선을 특화하세요\n\n![이미지](/assets/img/2024-07-01-DotDashDesign_0.png)\n\nJetpack Compose에서 UI를 생성할 때 선을 그리는 경우가 많습니다. 때로는 일부 공간을 구분하는 구분선으로, 때로는 더 복잡한 모양이나 디자인의 일부로 시각적으로 사용됩니다. 보통은 단순한 직선일 필요가 없을 때도 있습니다. 점 또는 대시를 사용하면 단순한 직선보다 덜 혹독한 효과를 줄 수 있으며 재미있는 모양이나 스타일 적용된 선 끝을 사용하면 디자인을 더욱 섬세하게 꾸밀 수 있습니다.\n\n만약 선이 모스 부호처럼 점과 대시로 표시되길 원한다면, 선의 스타일링 비밀을 해독하는 방법을 계속 읽어보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기본 사항.\n\n서로 이해하기 위해 기본적인 Jetpack Compose에서 선을 그리는 방법을 알려드리겠습니다:\n\n여기서 선은 수평적이며 캔버스 내부에 있으며 시작 및 끝 오프셋이 있습니다. strokeWidth는 픽셀 값을 설정하며 (제 경우에는 dp에서 변환된 값), 색상을 설정할 수 있습니다. 단색 대신 브러시를 사용하는 버전을 사용하면 더 흥미로운 색상 효과를 적용할 수 있습니다.\n\n![선](/assets/img/2024-07-01-DotDashDesign_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좌표가 (0,0)에서 시작하여 상단 왼쪽에 있으며 하단 오른쪽이 캔버스의 (너비, 높이) 지점입니다.\n\n![image](/assets/img/2024-07-01-DotDashDesign_2.png)\n\nJetpack Compose 및 DrawScope에서 Canvas에 그리는 방법에 대한 기본 안내서는 공식 문서를 확인해보세요.\n\n이제 선이 그려졌으니, 좀 더 정교하게 만드는 방법은 무엇일까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 선 끝 처리\n\n첫 번째로 할 수 있는 것은 선에 더 정교한 선 끝을 적용하는 것입니다.\n\n여기서 선택할 수 있는 옵션은 StrokeCap.Butt로, 이는 기본값으로 아무 확장 없이 직사각형 끝이 있는 것입니다. 또한, 선을 반원으로 연장하는 StrokeCap.Rounded와 선을 사각형 모양으로 연장하는 StrokeCap.Square이 있습니다 (이는 Butt처럼 보이지만 연장된 부분이 사각형 모양이다).\n\n![이미지](/assets/img/2024-07-01-DotDashDesign_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모르는 것은 물어보세요. 실수를 겁내지 말아요. 편하게 물어보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMarkdown 형식으로 표 태그를 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 모스 부호\n\n여기서는 dashPathEffect에 더 많은 간격을 추가하여 대시를 조금 더 복잡하게 만들 수 있습니다:\n\n재미있고 흥미로운 선을 얻을 수 있어요:\n\n![이미지](/assets/img/2024-07-01-DotDashDesign_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스탬핑 시간\n\n만약 여러 줄로 이루어진 선을 원하지 않는다면 어떨까요? 대신에, stampedPathEffect를 사용하여 선 a아에 특정 모양을 찍어낼 수 있습니다. 여기서 원하는 모양을 구성하고, 모양 사이의 간격 (advance, 이전과 같은 상태 및 StampedPathEffectStyle을 사용하여 모양을 설정합니다.\n\n원 모양을 찍어내는 경우, 우리는 원형 점들의 라인을 \u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_7.png\" /\u003e 처럼 갖게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nStampedPathEffectStyle.Translate은 선을 따라 움직이며 모양을 이전에 정의한 대로 유지합니다. 다른 유형의 StampedPathEffectStyle에 대해서는 나중에 설명하겠습니다. 직선을 보고 있을 때는 실제로 다른 유형이 적용되지 않습니다.\n\n좀 더 화려하게 만들기 위해 모양을 다양하게 만들어보세요:\n\n![image](/assets/img/2024-07-01-DotDashDesign_8.png)\n\n# 짹짹? 파도?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 이런 라인을 만드는 방법이 무엇이 있을까요:\n\n\n![image](/assets/img/2024-07-01-DotDashDesign_9.png)\n\n\n선을 그리기 위해 경로를 만들고 모든 지그재그를 포인트로 계산하고 그릴 수도 있지만, 이 경로 모양을 한 번 생성한 다음 위에서 한 것처럼 이 경로를 찍으면 됩니다.\n\n첫 번째 시도에서는 모양을 만들고 선을 따라 모양을 찍습니다 (전체 모양과 같은 너비의 진행을 사용하여)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 예상치 못한 (그러나 좋지 않은 결과는 아닙니다) 결과를 제공합니다:\n\n\n![image](/assets/img/2024-07-01-DotDashDesign_10.png)\n\n\n보통, 이를 경로로 그릴 때는 `DrawStyle.Stroke` 스타일을 사용하여 `drawPath`를 사용할 수 있고 선으로 직선으로 그립니다. 그러나 이것을 모양으로 사용하고 있기 때문에 자동으로 채워집니다. 이를 수정하기 위해 경로를 닫아주어야 합니다.\n\n이것을 줄에 넣으면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-07-01-DotDashDesign_11.png)\n\n여기서 실제 선이 점 (0,0)에서 그려지는 것을 알 수 있습니다. 이로 인해 지그재그 모양이 아래에 매달리고 실제 선의 끝에서 확장됩니다. 이를 더 쉽게 확인할 수 있습니다. 직선 경로를 함께 추가하면:\n\n![이미지](/assets/img/2024-07-01-DotDashDesign_12.png)\n\n더욱 정확하게 그리고 싶다면 Offset을 사용하여 경로를 변환해 지정한 선 위에 정확하게 그릴 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n달콤한 톤으로 한국어로 번역하면:\n\n\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_13.png\" /\u003e\n\n지그재그 선의 전체 코드:\n\n# 물론, 직선뿐만 아니라요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리는 직선을 그리는 것에 숙달했어요! 만약 이를 도형으로 넣고 싶다면 어떻게 해야 할까요? 그럼 drawRect나 drawCircle 또는 drawPath를 사용해서 원하는 모양을 얻을 수 있어요:\n\n![도형 이미지](/assets/img/2024-07-01-DotDashDesign_14.png)\n\n## 모서리에서는 어떻게 될까요?\n\n모서리에서 무슨 일이 일어나나요?\n\n이전에 StampedPathEffectStyle에 대해 언급했었는데, 이것은 직선만 그리지 않을 때 유용해요. 이는 라인이 방향을 바꿀 때 스탬프 경로에게 무엇을 해야 하는지 알려줘요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 하트 경로를 사용하여 서로 다른 스타일을 볼 수 있습니다:\n\n\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_15.png\" /\u003e\n\n번역한 것은 직역이며, 하트 모양의 오프셋을 수정하지 않았기 때문에 모양이 정확한 직사각형 윤곽을 따르지 않아 넘어집니다. 회전 스타일은 그 넘어짐을 수정하는 방식으로 모양을 회전시키지만, 서로 더 가깝거나 멀리 떨어져 있는 일부 하트가 생성됩니다. Morph의 경우에는 진동 경로로 더 쉽게 확인할 수 있습니다:\n\n\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_16.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서는 차이가 더 두드러지며, 회전은 하트 경로에 대해서는 잘 작동하지만 스탬프 모양이 연결된 지그재그에서는 구멍이 모서리에 뚜렷하게 나타납니다(그리고 일부 지점에서 겹침). Morph는 모서리를 따라 변형하여 간극을 해결하고(대부분의 경우 — 좌하단 코너 참조) 보다 부드러운 선 효과를 제공합니다. 하트 경로와 마찬가지로 하트들도 모서리에서 조금 작아져 모서리 주변을 이동할 수 있도록 허용됩니다.\n\n# 선. 마스터했다.\n\n지금은 Jetpack Compose에서 선을 스타일링하고 흥미로운 모양과 경로에서 사용하는 여러 방법을 볼 수 있습니다.\n\n점과 대시로 즐거운 모스 부호를 만들고 사용자들에게 비밀 메시지를 보내세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 사용된 모든 샘플 코드를 내 GitHub 실험에서 찾을 수 있습니다:\n\n옹골지는 사람들은 PathEffect.chainPathEffect에 대해 논의하지 않았다는 것을 알아차릴 수도 있습니다. 솔직히 말해서, 저는 이를 잘 사용할 수 있는 좋은 예제를 구성하지 못했고 다른 사람들이 그것을 사용한 예제를 찾을 수도 없었습니다(심지어 Gemini도 시도했습니다!) 좋은 예제를 발견하면 제게 공유해 주시기 바랍니다.\n\n어쩌면 언젠가 chainPathEffect에 대한 따로 두 번째 파트를 작성할 수도 있을 것입니다!","ogImage":{"url":"/assets/img/2024-07-01-DotDashDesign_0.png"},"coverImage":"/assets/img/2024-07-01-DotDashDesign_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003ePathEffect로 Jetpack Compose에서 선을 특화하세요\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eJetpack Compose에서 UI를 생성할 때 선을 그리는 경우가 많습니다. 때로는 일부 공간을 구분하는 구분선으로, 때로는 더 복잡한 모양이나 디자인의 일부로 시각적으로 사용됩니다. 보통은 단순한 직선일 필요가 없을 때도 있습니다. 점 또는 대시를 사용하면 단순한 직선보다 덜 혹독한 효과를 줄 수 있으며 재미있는 모양이나 스타일 적용된 선 끝을 사용하면 디자인을 더욱 섬세하게 꾸밀 수 있습니다.\u003c/p\u003e\n\u003cp\u003e만약 선이 모스 부호처럼 점과 대시로 표시되길 원한다면, 선의 스타일링 비밀을 해독하는 방법을 계속 읽어보세요!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e기본 사항.\u003c/h1\u003e\n\u003cp\u003e서로 이해하기 위해 기본적인 Jetpack Compose에서 선을 그리는 방법을 알려드리겠습니다:\u003c/p\u003e\n\u003cp\u003e여기서 선은 수평적이며 캔버스 내부에 있으며 시작 및 끝 오프셋이 있습니다. strokeWidth는 픽셀 값을 설정하며 (제 경우에는 dp에서 변환된 값), 색상을 설정할 수 있습니다. 단색 대신 브러시를 사용하는 버전을 사용하면 더 흥미로운 색상 효과를 적용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_1.png\" alt=\"선\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e좌표가 (0,0)에서 시작하여 상단 왼쪽에 있으며 하단 오른쪽이 캔버스의 (너비, 높이) 지점입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eJetpack Compose 및 DrawScope에서 Canvas에 그리는 방법에 대한 기본 안내서는 공식 문서를 확인해보세요.\u003c/p\u003e\n\u003cp\u003e이제 선이 그려졌으니, 좀 더 정교하게 만드는 방법은 무엇일까요?\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e선 끝 처리\u003c/h2\u003e\n\u003cp\u003e첫 번째로 할 수 있는 것은 선에 더 정교한 선 끝을 적용하는 것입니다.\u003c/p\u003e\n\u003cp\u003e여기서 선택할 수 있는 옵션은 StrokeCap.Butt로, 이는 기본값으로 아무 확장 없이 직사각형 끝이 있는 것입니다. 또한, 선을 반원으로 연장하는 StrokeCap.Rounded와 선을 사각형 모양으로 연장하는 StrokeCap.Square이 있습니다 (이는 Butt처럼 보이지만 연장된 부분이 사각형 모양이다).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e모르는 것은 물어보세요. 실수를 겁내지 말아요. 편하게 물어보세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eMarkdown 형식으로 표 태그를 변경해주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e모스 부호\u003c/h2\u003e\n\u003cp\u003e여기서는 dashPathEffect에 더 많은 간격을 추가하여 대시를 조금 더 복잡하게 만들 수 있습니다:\u003c/p\u003e\n\u003cp\u003e재미있고 흥미로운 선을 얻을 수 있어요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e스탬핑 시간\u003c/h1\u003e\n\u003cp\u003e만약 여러 줄로 이루어진 선을 원하지 않는다면 어떨까요? 대신에, stampedPathEffect를 사용하여 선 a아에 특정 모양을 찍어낼 수 있습니다. 여기서 원하는 모양을 구성하고, 모양 사이의 간격 (advance, 이전과 같은 상태 및 StampedPathEffectStyle을 사용하여 모양을 설정합니다.\u003c/p\u003e\n\u003cp\u003e원 모양을 찍어내는 경우, 우리는 원형 점들의 라인을 \u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_7.png\"\u003e 처럼 갖게 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eStampedPathEffectStyle.Translate은 선을 따라 움직이며 모양을 이전에 정의한 대로 유지합니다. 다른 유형의 StampedPathEffectStyle에 대해서는 나중에 설명하겠습니다. 직선을 보고 있을 때는 실제로 다른 유형이 적용되지 않습니다.\u003c/p\u003e\n\u003cp\u003e좀 더 화려하게 만들기 위해 모양을 다양하게 만들어보세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_8.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003e짹짹? 파도?\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그럼 이런 라인을 만드는 방법이 무엇이 있을까요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_9.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e선을 그리기 위해 경로를 만들고 모든 지그재그를 포인트로 계산하고 그릴 수도 있지만, 이 경로 모양을 한 번 생성한 다음 위에서 한 것처럼 이 경로를 찍으면 됩니다.\u003c/p\u003e\n\u003cp\u003e첫 번째 시도에서는 모양을 만들고 선을 따라 모양을 찍습니다 (전체 모양과 같은 너비의 진행을 사용하여)\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이것은 예상치 못한 (그러나 좋지 않은 결과는 아닙니다) 결과를 제공합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_10.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e보통, 이를 경로로 그릴 때는 \u003ccode\u003eDrawStyle.Stroke\u003c/code\u003e 스타일을 사용하여 \u003ccode\u003edrawPath\u003c/code\u003e를 사용할 수 있고 선으로 직선으로 그립니다. 그러나 이것을 모양으로 사용하고 있기 때문에 자동으로 채워집니다. 이를 수정하기 위해 경로를 닫아주어야 합니다.\u003c/p\u003e\n\u003cp\u003e이것을 줄에 넣으면:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_11.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e여기서 실제 선이 점 (0,0)에서 그려지는 것을 알 수 있습니다. 이로 인해 지그재그 모양이 아래에 매달리고 실제 선의 끝에서 확장됩니다. 이를 더 쉽게 확인할 수 있습니다. 직선 경로를 함께 추가하면:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_12.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e더욱 정확하게 그리고 싶다면 Offset을 사용하여 경로를 변환해 지정한 선 위에 정확하게 그릴 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e달콤한 톤으로 한국어로 번역하면:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_13.png\"\u003e\n\u003cp\u003e지그재그 선의 전체 코드:\u003c/p\u003e\n\u003ch1\u003e물론, 직선뿐만 아니라요!\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 우리는 직선을 그리는 것에 숙달했어요! 만약 이를 도형으로 넣고 싶다면 어떻게 해야 할까요? 그럼 drawRect나 drawCircle 또는 drawPath를 사용해서 원하는 모양을 얻을 수 있어요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_14.png\" alt=\"도형 이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e모서리에서는 어떻게 될까요?\u003c/h2\u003e\n\u003cp\u003e모서리에서 무슨 일이 일어나나요?\u003c/p\u003e\n\u003cp\u003e이전에 StampedPathEffectStyle에 대해 언급했었는데, 이것은 직선만 그리지 않을 때 유용해요. 이는 라인이 방향을 바꿀 때 스탬프 경로에게 무엇을 해야 하는지 알려줘요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예를 들어, 하트 경로를 사용하여 서로 다른 스타일을 볼 수 있습니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_15.png\"\u003e\n\u003cp\u003e번역한 것은 직역이며, 하트 모양의 오프셋을 수정하지 않았기 때문에 모양이 정확한 직사각형 윤곽을 따르지 않아 넘어집니다. 회전 스타일은 그 넘어짐을 수정하는 방식으로 모양을 회전시키지만, 서로 더 가깝거나 멀리 떨어져 있는 일부 하트가 생성됩니다. Morph의 경우에는 진동 경로로 더 쉽게 확인할 수 있습니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-07-01-DotDashDesign_16.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기서는 차이가 더 두드러지며, 회전은 하트 경로에 대해서는 잘 작동하지만 스탬프 모양이 연결된 지그재그에서는 구멍이 모서리에 뚜렷하게 나타납니다(그리고 일부 지점에서 겹침). Morph는 모서리를 따라 변형하여 간극을 해결하고(대부분의 경우 — 좌하단 코너 참조) 보다 부드러운 선 효과를 제공합니다. 하트 경로와 마찬가지로 하트들도 모서리에서 조금 작아져 모서리 주변을 이동할 수 있도록 허용됩니다.\u003c/p\u003e\n\u003ch1\u003e선. 마스터했다.\u003c/h1\u003e\n\u003cp\u003e지금은 Jetpack Compose에서 선을 스타일링하고 흥미로운 모양과 경로에서 사용하는 여러 방법을 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e점과 대시로 즐거운 모스 부호를 만들고 사용자들에게 비밀 메시지를 보내세요!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기서 사용된 모든 샘플 코드를 내 GitHub 실험에서 찾을 수 있습니다:\u003c/p\u003e\n\u003cp\u003e옹골지는 사람들은 PathEffect.chainPathEffect에 대해 논의하지 않았다는 것을 알아차릴 수도 있습니다. 솔직히 말해서, 저는 이를 잘 사용할 수 있는 좋은 예제를 구성하지 못했고 다른 사람들이 그것을 사용한 예제를 찾을 수도 없었습니다(심지어 Gemini도 시도했습니다!) 좋은 예제를 발견하면 제게 공유해 주시기 바랍니다.\u003c/p\u003e\n\u003cp\u003e어쩌면 언젠가 chainPathEffect에 대한 따로 두 번째 파트를 작성할 수도 있을 것입니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-07-01-DotDashDesign"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>