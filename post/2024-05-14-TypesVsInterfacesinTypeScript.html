<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>타입 vs 인터페이스 TypeScript에서 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-TypesVsInterfacesinTypeScript" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="타입 vs 인터페이스 TypeScript에서 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="타입 vs 인터페이스 TypeScript에서 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-TypesVsInterfacesinTypeScript" data-gatsby-head="true"/><meta name="twitter:title" content="타입 vs 인터페이스 TypeScript에서 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 15:27" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">타입 vs 인터페이스 TypeScript에서</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="타입 vs 인터페이스 TypeScript에서" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-TypesVsInterfacesinTypeScript&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png" alt="TypesVsInterfacesinTypeScript"></p>
<p>TypeScript는 놀라운 점들이 가득하고 일부 행동은 TypeScript에만 독점되어 있습니다.</p>
<p>오늘은 타입과 인터페이스의 차이점과 대부분의 경우에 타입을 사용해야 하는 이유에 대해 논의할 것입니다.</p>
<p>더 이상 미루지 말고 바로 들어가 봅시다.</p>
<p>차이가 무엇인가요?</p>
<p>이 동물 유형 및 인터페이스 정의를 분석해 봅시다:</p>
<pre><code class="hljs language-js">type <span class="hljs-title class_">Animal</span> = {
  <span class="hljs-attr">species</span>: string
  <span class="hljs-attr">name</span>: string
  <span class="hljs-attr">age</span>: number
}


interface <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">species</span>: string
  <span class="hljs-attr">name</span>: string
  <span class="hljs-attr">age</span>: number
}
</code></pre>
<p>구문은 거의 동일한데 유형은 객체의 모양을 정의하기 위해 =로 선언됩니다.</p>
<p>이는 큰 차이가 아닙니다. 주요 차이점을 자세히 살펴보겠습니다.</p>
<h1>확장성</h1>
<p>확장성 측면에서 인터페이스가 승자입니다. 인터페이스는 extends 키워드를 사용하여 확장할 수 있습니다.</p>
<pre><code class="hljs language-js">interface <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">species</span>: string
  <span class="hljs-attr">name</span>: string
  <span class="hljs-attr">age</span>: number
}

interface <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">breed</span>: string
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Dog</span> = {
  <span class="hljs-attr">species</span>: <span class="hljs-string">'포유동물'</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">'브루노'</span>,
  <span class="hljs-attr">breed</span>: <span class="hljs-string">'저먼 셰퍼드'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>
}
</code></pre>
<p>개 인터페이스는 동물 인터페이스의 속성을 확장하며 결과로 동물 인터페이스의 속성이 개 인터페이스에 병합됩니다.</p>
<p>타입은 두 개의 타입을 병합하는 데 Union(<code>|</code>) 및 Intersection(<code>&#x26;</code>) 연산자를 사용하여 속성을 확장할 수도 있습니다.</p>
<pre><code class="hljs language-js">type <span class="hljs-title class_">Animal</span> = {
  <span class="hljs-attr">species</span>: string
  <span class="hljs-attr">name</span>: string
  <span class="hljs-attr">age</span>: number
}

type <span class="hljs-title class_">Dog</span> = {
  <span class="hljs-attr">breed</span>: string
} &#x26; <span class="hljs-title class_">Animal</span>

<span class="hljs-comment">// ❌ 작동하지 않음</span>
interface <span class="hljs-title class_">Dog</span> {
  breed 
} &#x26; <span class="hljs-title class_">Animal</span>
</code></pre>
<h1>성능</h1>
<p>성능은 컴파일 시 TypeScript 컴파일러에서 수행되는 타입 체크를 의미합니다.
성능은 일반적으로 코드베이스가 커질수록 지수적으로 감소합니다.</p>
<p>이것이 왜 우리가 타입 대 인터페이스의 성능을 벤치마킹 하는 이유입니다.
나는 TypeScript 분야에서 Matt Pocock을 따르고 있습니다. Total TypeScript 강좌를 수강하는 것이 가치가 있다고 말할 수 있습니다.</p>
<p>Matt가 타입과 인터페이스의 차이를 설명한 비디오로, 타입과 인터페이스의 성능에는 차이가 없다는 것을 보여줍니다.</p>
<h1>인터페이스가 해로울 수 있는 이유</h1>
<p>TypeScript의 인터페이스는 선언 병합(Declaration Merging)이라는 독특한 기능을 가지고 있어.</p>
<p>선언 병합은 TypeScript 컴파일러가 동일한 이름을 가진 두 개 이상의 인터페이스를 하나로 병합하는 것이야.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 초기 Dog 인터페이스</span>
interface <span class="hljs-title class_">Dog</span> {
  <span class="hljs-attr">species</span>: string
  <span class="hljs-attr">name</span>: string
  <span class="hljs-attr">age</span>: number
}
<span class="hljs-comment">// "선언 병합"을 이용해 Dog 인터페이스 보강</span>
interface <span class="hljs-title class_">Dog</span> {
  <span class="hljs-attr">breed</span>: string
}

<span class="hljs-comment">// "병합된" 인터페이스로 새로운 "개"를 정의해봐</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Dog</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Bruno"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">breed</span>: <span class="hljs-string">"German Shepherd"</span>, <span class="hljs-attr">species</span>: <span class="hljs-string">"Mamamal"</span> }
</code></pre>
<p>이 방법은 인터페이스에 함수 멤버가 없는 경우 잘 동작해.</p>
<p>그런데 함수 멤버가 있는 경우, 선언 병합은 코드베이스에 불리하고 예상치 못한 영향을 미칠 수 있어. 멤버의 우선순위는 나중에 나오는 것이 더 높아져.</p>
<pre><code class="hljs language-js">인터페이스 <span class="hljs-title class_">Cloner</span> {
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span>): <span class="hljs-title class_">Animal</span>;
}
인터페이스 <span class="hljs-title class_">Cloner</span> {
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Sheep</span>): <span class="hljs-title class_">Sheep</span>;
}
인터페이스 <span class="hljs-title class_">Cloner</span> {
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Dog</span>): <span class="hljs-title class_">Dog</span>;
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Cat</span>): <span class="hljs-title class_">Cat</span>;
}

<span class="hljs-comment">// 세 가지 인터페이스가 병합되어 다음과 같은 하나의 선언으로 생성됩니다:</span>

인터페이스 <span class="hljs-title class_">Cloner</span> {
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Dog</span>): <span class="hljs-title class_">Dog</span>;
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Cat</span>): <span class="hljs-title class_">Cat</span>;
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Sheep</span>): <span class="hljs-title class_">Sheep</span>;
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span>): <span class="hljs-title class_">Animal</span>;
}
</code></pre>
<p>각 그룹의 요소들은 동일한 순서를 유지하지만, 그룹 자체는 나중에 오버로드 세트로 병합됩니다.</p>
<h2>클래스와의 안전하지 않은 병합</h2>
<p>TypeScript 컴파일러는 속성 초기화를 확인하지 않기 때문에 예기치 않은 런타임 오류가 발생할 수 있습니다.
두 인터페이스의 병합 중에</p>
<pre><code class="hljs language-js">인터페이스 동물 {
    <span class="hljs-attr">a</span>: 문자열;
    <span class="hljs-attr">b</span>: 문자열;
}

인터페이스 개는 동물을 확장하며 {
    <span class="hljs-attr">c</span>: 문자열;
}

클래스 개 {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}
}
</code></pre>
<p>위 예제에서는 속성 a, b 또는 c가 초기화되었는지 여부에 관계없이 초기화되지 않았음에 대한 오류나 경고가 나타나지 않습니다.</p>
<p>그러나 아래 코드를 작성할 때, 여전히 Properties 'a', 'b', 및 'c'에 대한 초기화 프로그램이 없으며 생성자에서 확실하게 할당되지 않았다는 오류가 발생합니다.</p>
<pre><code class="hljs language-js">클래스 개 {
    <span class="hljs-attr">a</span>: 문자열;
    <span class="hljs-attr">b</span>: 문자열;
    <span class="hljs-attr">c</span>: 문자열;
}
</code></pre>
<p>테이블 태그를 마크다운 형식으로 변경하십시오.</p>

















<table><thead><tr><th>Types do not have this problem, and hence are more straightforward and safe to use as a result.</th></tr></thead><tbody><tr><td><strong>Conclusion</strong></td></tr><tr><td>Unless specific interface behavior is necessary, e.g. extensible refinement or implementation using OOP, your best bet is to stick with types.</td></tr><tr><td>Types are flexible and straightforward, and avoid pitfalls associated with declaration merging.</td></tr></tbody></table>
<p>인터페이스와 성능 면에서도 타입들은 동일합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"타입 vs 인터페이스 TypeScript에서","description":"","date":"2024-05-14 15:27","slug":"2024-05-14-TypesVsInterfacesinTypeScript","content":"\n\n\n![TypesVsInterfacesinTypeScript](/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png)\n\nTypeScript는 놀라운 점들이 가득하고 일부 행동은 TypeScript에만 독점되어 있습니다.\n\n오늘은 타입과 인터페이스의 차이점과 대부분의 경우에 타입을 사용해야 하는 이유에 대해 논의할 것입니다.\n\n더 이상 미루지 말고 바로 들어가 봅시다.\n\n\n\n\n차이가 무엇인가요?\n\n이 동물 유형 및 인터페이스 정의를 분석해 봅시다:\n\n```js\ntype Animal = {\n  species: string\n  name: string\n  age: number\n}\n\n\ninterface Animal {\n  species: string\n  name: string\n  age: number\n}\n```\n\n구문은 거의 동일한데 유형은 객체의 모양을 정의하기 위해 =로 선언됩니다.\n\n\n\n이는 큰 차이가 아닙니다. 주요 차이점을 자세히 살펴보겠습니다.\n\n# 확장성\n\n확장성 측면에서 인터페이스가 승자입니다. 인터페이스는 extends 키워드를 사용하여 확장할 수 있습니다.\n\n```js\ninterface Animal {\n  species: string\n  name: string\n  age: number\n}\n\ninterface Dog extends Animal {\n  breed: string\n}\n\nconst dog: Dog = {\n  species: '포유동물',\n  name: '브루노',\n  breed: '저먼 셰퍼드',\n  age: 5\n}\n```\n\n\n\n개 인터페이스는 동물 인터페이스의 속성을 확장하며 결과로 동물 인터페이스의 속성이 개 인터페이스에 병합됩니다.\n\n타입은 두 개의 타입을 병합하는 데 Union(`|`) 및 Intersection(`\u0026`) 연산자를 사용하여 속성을 확장할 수도 있습니다.\n\n```js\ntype Animal = {\n  species: string\n  name: string\n  age: number\n}\n\ntype Dog = {\n  breed: string\n} \u0026 Animal\n\n// ❌ 작동하지 않음\ninterface Dog {\n  breed \n} \u0026 Animal\n```\n\n# 성능\n\n\n\n성능은 컴파일 시 TypeScript 컴파일러에서 수행되는 타입 체크를 의미합니다.\n성능은 일반적으로 코드베이스가 커질수록 지수적으로 감소합니다.\n\n이것이 왜 우리가 타입 대 인터페이스의 성능을 벤치마킹 하는 이유입니다.\n나는 TypeScript 분야에서 Matt Pocock을 따르고 있습니다. Total TypeScript 강좌를 수강하는 것이 가치가 있다고 말할 수 있습니다.\n\nMatt가 타입과 인터페이스의 차이를 설명한 비디오로, 타입과 인터페이스의 성능에는 차이가 없다는 것을 보여줍니다.\n\n# 인터페이스가 해로울 수 있는 이유\n\n\n\nTypeScript의 인터페이스는 선언 병합(Declaration Merging)이라는 독특한 기능을 가지고 있어.\n\n선언 병합은 TypeScript 컴파일러가 동일한 이름을 가진 두 개 이상의 인터페이스를 하나로 병합하는 것이야.\n\n```js\n// 초기 Dog 인터페이스\ninterface Dog {\n  species: string\n  name: string\n  age: number\n}\n// \"선언 병합\"을 이용해 Dog 인터페이스 보강\ninterface Dog {\n  breed: string\n}\n\n// \"병합된\" 인터페이스로 새로운 \"개\"를 정의해봐\nconst dog: Dog = { name: \"Bruno\", age: 5, breed: \"German Shepherd\", species: \"Mamamal\" }\n```\n\n이 방법은 인터페이스에 함수 멤버가 없는 경우 잘 동작해.\n\n그런데 함수 멤버가 있는 경우, 선언 병합은 코드베이스에 불리하고 예상치 못한 영향을 미칠 수 있어. 멤버의 우선순위는 나중에 나오는 것이 더 높아져.\n\n\n\n```js\n인터페이스 Cloner {\n  clone(animal: Animal): Animal;\n}\n인터페이스 Cloner {\n  clone(animal: Sheep): Sheep;\n}\n인터페이스 Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n}\n\n// 세 가지 인터페이스가 병합되어 다음과 같은 하나의 선언으로 생성됩니다:\n\n인터페이스 Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n  clone(animal: Sheep): Sheep;\n  clone(animal: Animal): Animal;\n}\n```\n\n각 그룹의 요소들은 동일한 순서를 유지하지만, 그룹 자체는 나중에 오버로드 세트로 병합됩니다.\n\n## 클래스와의 안전하지 않은 병합\n\nTypeScript 컴파일러는 속성 초기화를 확인하지 않기 때문에 예기치 않은 런타임 오류가 발생할 수 있습니다.\n두 인터페이스의 병합 중에\n\n\n\n```js\n인터페이스 동물 {\n    a: 문자열;\n    b: 문자열;\n}\n\n인터페이스 개는 동물을 확장하며 {\n    c: 문자열;\n}\n\n클래스 개 {\n    constructor() {}\n}\n```\n\n위 예제에서는 속성 a, b 또는 c가 초기화되었는지 여부에 관계없이 초기화되지 않았음에 대한 오류나 경고가 나타나지 않습니다.\n\n그러나 아래 코드를 작성할 때, 여전히 Properties 'a', 'b', 및 'c'에 대한 초기화 프로그램이 없으며 생성자에서 확실하게 할당되지 않았다는 오류가 발생합니다.\n\n```js\n클래스 개 {\n    a: 문자열;\n    b: 문자열;\n    c: 문자열;\n}\n```\n\n\n\n테이블 태그를 마크다운 형식으로 변경하십시오.\n\n| Types do not have this problem, and hence are more straightforward and safe to use as a result.                        |\n|--------------------------------------------------------------------------------------------------------------------------|\n| **Conclusion**                                                                                                          |\n| Unless specific interface behavior is necessary, e.g. extensible refinement or implementation using OOP, your best bet is to stick with types. |\n| Types are flexible and straightforward, and avoid pitfalls associated with declaration merging.                         |\n\n\n\n인터페이스와 성능 면에서도 타입들은 동일합니다.","ogImage":{"url":"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png\" alt=\"TypesVsInterfacesinTypeScript\"\u003e\u003c/p\u003e\n\u003cp\u003eTypeScript는 놀라운 점들이 가득하고 일부 행동은 TypeScript에만 독점되어 있습니다.\u003c/p\u003e\n\u003cp\u003e오늘은 타입과 인터페이스의 차이점과 대부분의 경우에 타입을 사용해야 하는 이유에 대해 논의할 것입니다.\u003c/p\u003e\n\u003cp\u003e더 이상 미루지 말고 바로 들어가 봅시다.\u003c/p\u003e\n\u003cp\u003e차이가 무엇인가요?\u003c/p\u003e\n\u003cp\u003e이 동물 유형 및 인터페이스 정의를 분석해 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003especies\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: number\n}\n\n\ninterface \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003especies\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: number\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e구문은 거의 동일한데 유형은 객체의 모양을 정의하기 위해 =로 선언됩니다.\u003c/p\u003e\n\u003cp\u003e이는 큰 차이가 아닙니다. 주요 차이점을 자세히 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003e확장성\u003c/h1\u003e\n\u003cp\u003e확장성 측면에서 인터페이스가 승자입니다. 인터페이스는 extends 키워드를 사용하여 확장할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einterface \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003especies\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: number\n}\n\ninterface \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ebreed\u003c/span\u003e: string\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edog\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003especies\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'포유동물'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'브루노'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ebreed\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'저먼 셰퍼드'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e개 인터페이스는 동물 인터페이스의 속성을 확장하며 결과로 동물 인터페이스의 속성이 개 인터페이스에 병합됩니다.\u003c/p\u003e\n\u003cp\u003e타입은 두 개의 타입을 병합하는 데 Union(\u003ccode\u003e|\u003c/code\u003e) 및 Intersection(\u003ccode\u003e\u0026#x26;\u003c/code\u003e) 연산자를 사용하여 속성을 확장할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003especies\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: number\n}\n\ntype \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003ebreed\u003c/span\u003e: string\n} \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// ❌ 작동하지 않음\u003c/span\u003e\ninterface \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e {\n  breed \n} \u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e성능\u003c/h1\u003e\n\u003cp\u003e성능은 컴파일 시 TypeScript 컴파일러에서 수행되는 타입 체크를 의미합니다.\n성능은 일반적으로 코드베이스가 커질수록 지수적으로 감소합니다.\u003c/p\u003e\n\u003cp\u003e이것이 왜 우리가 타입 대 인터페이스의 성능을 벤치마킹 하는 이유입니다.\n나는 TypeScript 분야에서 Matt Pocock을 따르고 있습니다. Total TypeScript 강좌를 수강하는 것이 가치가 있다고 말할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eMatt가 타입과 인터페이스의 차이를 설명한 비디오로, 타입과 인터페이스의 성능에는 차이가 없다는 것을 보여줍니다.\u003c/p\u003e\n\u003ch1\u003e인터페이스가 해로울 수 있는 이유\u003c/h1\u003e\n\u003cp\u003eTypeScript의 인터페이스는 선언 병합(Declaration Merging)이라는 독특한 기능을 가지고 있어.\u003c/p\u003e\n\u003cp\u003e선언 병합은 TypeScript 컴파일러가 동일한 이름을 가진 두 개 이상의 인터페이스를 하나로 병합하는 것이야.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 초기 Dog 인터페이스\u003c/span\u003e\ninterface \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003especies\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: string\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: number\n}\n\u003cspan class=\"hljs-comment\"\u003e// \"선언 병합\"을 이용해 Dog 인터페이스 보강\u003c/span\u003e\ninterface \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003ebreed\u003c/span\u003e: string\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// \"병합된\" 인터페이스로 새로운 \"개\"를 정의해봐\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edog\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Bruno\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebreed\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"German Shepherd\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003especies\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Mamamal\"\u003c/span\u003e }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 방법은 인터페이스에 함수 멤버가 없는 경우 잘 동작해.\u003c/p\u003e\n\u003cp\u003e그런데 함수 멤버가 있는 경우, 선언 병합은 코드베이스에 불리하고 예상치 못한 영향을 미칠 수 있어. 멤버의 우선순위는 나중에 나오는 것이 더 높아져.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e인터페이스 \u003cspan class=\"hljs-title class_\"\u003eCloner\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eanimal\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e;\n}\n인터페이스 \u003cspan class=\"hljs-title class_\"\u003eCloner\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eanimal\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSheep\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eSheep\u003c/span\u003e;\n}\n인터페이스 \u003cspan class=\"hljs-title class_\"\u003eCloner\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eanimal\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eanimal\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCat\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eCat\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 세 가지 인터페이스가 병합되어 다음과 같은 하나의 선언으로 생성됩니다:\u003c/span\u003e\n\n인터페이스 \u003cspan class=\"hljs-title class_\"\u003eCloner\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eanimal\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eanimal\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCat\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eCat\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eanimal\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSheep\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eSheep\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eanimal\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eAnimal\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e각 그룹의 요소들은 동일한 순서를 유지하지만, 그룹 자체는 나중에 오버로드 세트로 병합됩니다.\u003c/p\u003e\n\u003ch2\u003e클래스와의 안전하지 않은 병합\u003c/h2\u003e\n\u003cp\u003eTypeScript 컴파일러는 속성 초기화를 확인하지 않기 때문에 예기치 않은 런타임 오류가 발생할 수 있습니다.\n두 인터페이스의 병합 중에\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e인터페이스 동물 {\n    \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: 문자열;\n    \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: 문자열;\n}\n\n인터페이스 개는 동물을 확장하며 {\n    \u003cspan class=\"hljs-attr\"\u003ec\u003c/span\u003e: 문자열;\n}\n\n클래스 개 {\n    \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예제에서는 속성 a, b 또는 c가 초기화되었는지 여부에 관계없이 초기화되지 않았음에 대한 오류나 경고가 나타나지 않습니다.\u003c/p\u003e\n\u003cp\u003e그러나 아래 코드를 작성할 때, 여전히 Properties 'a', 'b', 및 'c'에 대한 초기화 프로그램이 없으며 생성자에서 확실하게 할당되지 않았다는 오류가 발생합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e클래스 개 {\n    \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: 문자열;\n    \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e: 문자열;\n    \u003cspan class=\"hljs-attr\"\u003ec\u003c/span\u003e: 문자열;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e테이블 태그를 마크다운 형식으로 변경하십시오.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eTypes do not have this problem, and hence are more straightforward and safe to use as a result.\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e\u003cstrong\u003eConclusion\u003c/strong\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eUnless specific interface behavior is necessary, e.g. extensible refinement or implementation using OOP, your best bet is to stick with types.\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTypes are flexible and straightforward, and avoid pitfalls associated with declaration merging.\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e인터페이스와 성능 면에서도 타입들은 동일합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-TypesVsInterfacesinTypeScript"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>