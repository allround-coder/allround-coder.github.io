<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>타입 vs 인터페이스 TypeScript에서 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-TypesVsInterfacesinTypeScript" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="타입 vs 인터페이스 TypeScript에서 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="타입 vs 인터페이스 TypeScript에서 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-TypesVsInterfacesinTypeScript" data-gatsby-head="true"/><meta name="twitter:title" content="타입 vs 인터페이스 TypeScript에서 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 15:27" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_buildManifest.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">타입 vs 인터페이스 TypeScript에서</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="타입 vs 인터페이스 TypeScript에서" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-TypesVsInterfacesinTypeScript&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png" alt="TypesVsInterfacesinTypeScript"/></p>
<p>TypeScript는 놀라운 점들이 가득하고 일부 행동은 TypeScript에만 독점되어 있습니다.</p>
<p>오늘은 타입과 인터페이스의 차이점과 대부분의 경우에 타입을 사용해야 하는 이유에 대해 논의할 것입니다.</p>
<p>더 이상 미루지 말고 바로 들어가 봅시다.</p>
<p>차이가 무엇인가요?</p>
<p>이 동물 유형 및 인터페이스 정의를 분석해 봅시다:</p>
<pre><code class="hljs language-js">type <span class="hljs-title class_">Animal</span> = {
  <span class="hljs-attr">species</span>: string
  <span class="hljs-attr">name</span>: string
  <span class="hljs-attr">age</span>: number
}


interface <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">species</span>: string
  <span class="hljs-attr">name</span>: string
  <span class="hljs-attr">age</span>: number
}
</code></pre>
<p>구문은 거의 동일한데 유형은 객체의 모양을 정의하기 위해 =로 선언됩니다.</p>
<p>이는 큰 차이가 아닙니다. 주요 차이점을 자세히 살펴보겠습니다.</p>
<h1>확장성</h1>
<p>확장성 측면에서 인터페이스가 승자입니다. 인터페이스는 extends 키워드를 사용하여 확장할 수 있습니다.</p>
<pre><code class="hljs language-js">interface <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">species</span>: string
  <span class="hljs-attr">name</span>: string
  <span class="hljs-attr">age</span>: number
}

interface <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> {
  <span class="hljs-attr">breed</span>: string
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Dog</span> = {
  <span class="hljs-attr">species</span>: <span class="hljs-string">&#x27;포유동물&#x27;</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;브루노&#x27;</span>,
  <span class="hljs-attr">breed</span>: <span class="hljs-string">&#x27;저먼 셰퍼드&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>
}
</code></pre>
<p>개 인터페이스는 동물 인터페이스의 속성을 확장하며 결과로 동물 인터페이스의 속성이 개 인터페이스에 병합됩니다.</p>
<p>타입은 두 개의 타입을 병합하는 데 Union(<code>|</code>) 및 Intersection(<code>&amp;</code>) 연산자를 사용하여 속성을 확장할 수도 있습니다.</p>
<pre><code class="hljs language-js">type <span class="hljs-title class_">Animal</span> = {
  <span class="hljs-attr">species</span>: string
  <span class="hljs-attr">name</span>: string
  <span class="hljs-attr">age</span>: number
}

type <span class="hljs-title class_">Dog</span> = {
  <span class="hljs-attr">breed</span>: string
} &amp; <span class="hljs-title class_">Animal</span>

<span class="hljs-comment">// ❌ 작동하지 않음</span>
interface <span class="hljs-title class_">Dog</span> {
  breed 
} &amp; <span class="hljs-title class_">Animal</span>
</code></pre>
<h1>성능</h1>
<p>성능은 컴파일 시 TypeScript 컴파일러에서 수행되는 타입 체크를 의미합니다.
성능은 일반적으로 코드베이스가 커질수록 지수적으로 감소합니다.</p>
<p>이것이 왜 우리가 타입 대 인터페이스의 성능을 벤치마킹 하는 이유입니다.
나는 TypeScript 분야에서 Matt Pocock을 따르고 있습니다. Total TypeScript 강좌를 수강하는 것이 가치가 있다고 말할 수 있습니다.</p>
<p>Matt가 타입과 인터페이스의 차이를 설명한 비디오로, 타입과 인터페이스의 성능에는 차이가 없다는 것을 보여줍니다.</p>
<h1>인터페이스가 해로울 수 있는 이유</h1>
<p>TypeScript의 인터페이스는 선언 병합(Declaration Merging)이라는 독특한 기능을 가지고 있어.</p>
<p>선언 병합은 TypeScript 컴파일러가 동일한 이름을 가진 두 개 이상의 인터페이스를 하나로 병합하는 것이야.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 초기 Dog 인터페이스</span>
interface <span class="hljs-title class_">Dog</span> {
  <span class="hljs-attr">species</span>: string
  <span class="hljs-attr">name</span>: string
  <span class="hljs-attr">age</span>: number
}
<span class="hljs-comment">// &quot;선언 병합&quot;을 이용해 Dog 인터페이스 보강</span>
interface <span class="hljs-title class_">Dog</span> {
  <span class="hljs-attr">breed</span>: string
}

<span class="hljs-comment">// &quot;병합된&quot; 인터페이스로 새로운 &quot;개&quot;를 정의해봐</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">dog</span>: <span class="hljs-title class_">Dog</span> = { <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bruno&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">breed</span>: <span class="hljs-string">&quot;German Shepherd&quot;</span>, <span class="hljs-attr">species</span>: <span class="hljs-string">&quot;Mamamal&quot;</span> }
</code></pre>
<p>이 방법은 인터페이스에 함수 멤버가 없는 경우 잘 동작해.</p>
<p>그런데 함수 멤버가 있는 경우, 선언 병합은 코드베이스에 불리하고 예상치 못한 영향을 미칠 수 있어. 멤버의 우선순위는 나중에 나오는 것이 더 높아져.</p>
<pre><code class="hljs language-js">인터페이스 <span class="hljs-title class_">Cloner</span> {
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span>): <span class="hljs-title class_">Animal</span>;
}
인터페이스 <span class="hljs-title class_">Cloner</span> {
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Sheep</span>): <span class="hljs-title class_">Sheep</span>;
}
인터페이스 <span class="hljs-title class_">Cloner</span> {
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Dog</span>): <span class="hljs-title class_">Dog</span>;
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Cat</span>): <span class="hljs-title class_">Cat</span>;
}

<span class="hljs-comment">// 세 가지 인터페이스가 병합되어 다음과 같은 하나의 선언으로 생성됩니다:</span>

인터페이스 <span class="hljs-title class_">Cloner</span> {
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Dog</span>): <span class="hljs-title class_">Dog</span>;
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Cat</span>): <span class="hljs-title class_">Cat</span>;
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Sheep</span>): <span class="hljs-title class_">Sheep</span>;
  <span class="hljs-title function_">clone</span>(<span class="hljs-attr">animal</span>: <span class="hljs-title class_">Animal</span>): <span class="hljs-title class_">Animal</span>;
}
</code></pre>
<p>각 그룹의 요소들은 동일한 순서를 유지하지만, 그룹 자체는 나중에 오버로드 세트로 병합됩니다.</p>
<h2>클래스와의 안전하지 않은 병합</h2>
<p>TypeScript 컴파일러는 속성 초기화를 확인하지 않기 때문에 예기치 않은 런타임 오류가 발생할 수 있습니다.
두 인터페이스의 병합 중에</p>
<pre><code class="hljs language-js">인터페이스 동물 {
    <span class="hljs-attr">a</span>: 문자열;
    <span class="hljs-attr">b</span>: 문자열;
}

인터페이스 개는 동물을 확장하며 {
    <span class="hljs-attr">c</span>: 문자열;
}

클래스 개 {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}
}
</code></pre>
<p>위 예제에서는 속성 a, b 또는 c가 초기화되었는지 여부에 관계없이 초기화되지 않았음에 대한 오류나 경고가 나타나지 않습니다.</p>
<p>그러나 아래 코드를 작성할 때, 여전히 Properties &#x27;a&#x27;, &#x27;b&#x27;, 및 &#x27;c&#x27;에 대한 초기화 프로그램이 없으며 생성자에서 확실하게 할당되지 않았다는 오류가 발생합니다.</p>
<pre><code class="hljs language-js">클래스 개 {
    <span class="hljs-attr">a</span>: 문자열;
    <span class="hljs-attr">b</span>: 문자열;
    <span class="hljs-attr">c</span>: 문자열;
}
</code></pre>
<p>테이블 태그를 마크다운 형식으로 변경하십시오.</p>
<p>| Types do not have this problem, and hence are more straightforward and safe to use as a result.                        |
|--------------------------------------------------------------------------------------------------------------------------|
| <strong>Conclusion</strong>                                                                                                          |
| Unless specific interface behavior is necessary, e.g. extensible refinement or implementation using OOP, your best bet is to stick with types. |
| Types are flexible and straightforward, and avoid pitfalls associated with declaration merging.                         |</p>
<p>인터페이스와 성능 면에서도 타입들은 동일합니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"타입 vs 인터페이스 TypeScript에서","description":"","date":"2024-05-14 15:27","slug":"2024-05-14-TypesVsInterfacesinTypeScript","content":"\n\n\n![TypesVsInterfacesinTypeScript](/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png)\n\nTypeScript는 놀라운 점들이 가득하고 일부 행동은 TypeScript에만 독점되어 있습니다.\n\n오늘은 타입과 인터페이스의 차이점과 대부분의 경우에 타입을 사용해야 하는 이유에 대해 논의할 것입니다.\n\n더 이상 미루지 말고 바로 들어가 봅시다.\n\n\n\n\n차이가 무엇인가요?\n\n이 동물 유형 및 인터페이스 정의를 분석해 봅시다:\n\n```js\ntype Animal = {\n  species: string\n  name: string\n  age: number\n}\n\n\ninterface Animal {\n  species: string\n  name: string\n  age: number\n}\n```\n\n구문은 거의 동일한데 유형은 객체의 모양을 정의하기 위해 =로 선언됩니다.\n\n\n\n이는 큰 차이가 아닙니다. 주요 차이점을 자세히 살펴보겠습니다.\n\n# 확장성\n\n확장성 측면에서 인터페이스가 승자입니다. 인터페이스는 extends 키워드를 사용하여 확장할 수 있습니다.\n\n```js\ninterface Animal {\n  species: string\n  name: string\n  age: number\n}\n\ninterface Dog extends Animal {\n  breed: string\n}\n\nconst dog: Dog = {\n  species: '포유동물',\n  name: '브루노',\n  breed: '저먼 셰퍼드',\n  age: 5\n}\n```\n\n\n\n개 인터페이스는 동물 인터페이스의 속성을 확장하며 결과로 동물 인터페이스의 속성이 개 인터페이스에 병합됩니다.\n\n타입은 두 개의 타입을 병합하는 데 Union(`|`) 및 Intersection(`\u0026`) 연산자를 사용하여 속성을 확장할 수도 있습니다.\n\n```js\ntype Animal = {\n  species: string\n  name: string\n  age: number\n}\n\ntype Dog = {\n  breed: string\n} \u0026 Animal\n\n// ❌ 작동하지 않음\ninterface Dog {\n  breed \n} \u0026 Animal\n```\n\n# 성능\n\n\n\n성능은 컴파일 시 TypeScript 컴파일러에서 수행되는 타입 체크를 의미합니다.\n성능은 일반적으로 코드베이스가 커질수록 지수적으로 감소합니다.\n\n이것이 왜 우리가 타입 대 인터페이스의 성능을 벤치마킹 하는 이유입니다.\n나는 TypeScript 분야에서 Matt Pocock을 따르고 있습니다. Total TypeScript 강좌를 수강하는 것이 가치가 있다고 말할 수 있습니다.\n\nMatt가 타입과 인터페이스의 차이를 설명한 비디오로, 타입과 인터페이스의 성능에는 차이가 없다는 것을 보여줍니다.\n\n# 인터페이스가 해로울 수 있는 이유\n\n\n\nTypeScript의 인터페이스는 선언 병합(Declaration Merging)이라는 독특한 기능을 가지고 있어.\n\n선언 병합은 TypeScript 컴파일러가 동일한 이름을 가진 두 개 이상의 인터페이스를 하나로 병합하는 것이야.\n\n```js\n// 초기 Dog 인터페이스\ninterface Dog {\n  species: string\n  name: string\n  age: number\n}\n// \"선언 병합\"을 이용해 Dog 인터페이스 보강\ninterface Dog {\n  breed: string\n}\n\n// \"병합된\" 인터페이스로 새로운 \"개\"를 정의해봐\nconst dog: Dog = { name: \"Bruno\", age: 5, breed: \"German Shepherd\", species: \"Mamamal\" }\n```\n\n이 방법은 인터페이스에 함수 멤버가 없는 경우 잘 동작해.\n\n그런데 함수 멤버가 있는 경우, 선언 병합은 코드베이스에 불리하고 예상치 못한 영향을 미칠 수 있어. 멤버의 우선순위는 나중에 나오는 것이 더 높아져.\n\n\n\n```js\n인터페이스 Cloner {\n  clone(animal: Animal): Animal;\n}\n인터페이스 Cloner {\n  clone(animal: Sheep): Sheep;\n}\n인터페이스 Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n}\n\n// 세 가지 인터페이스가 병합되어 다음과 같은 하나의 선언으로 생성됩니다:\n\n인터페이스 Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n  clone(animal: Sheep): Sheep;\n  clone(animal: Animal): Animal;\n}\n```\n\n각 그룹의 요소들은 동일한 순서를 유지하지만, 그룹 자체는 나중에 오버로드 세트로 병합됩니다.\n\n## 클래스와의 안전하지 않은 병합\n\nTypeScript 컴파일러는 속성 초기화를 확인하지 않기 때문에 예기치 않은 런타임 오류가 발생할 수 있습니다.\n두 인터페이스의 병합 중에\n\n\n\n```js\n인터페이스 동물 {\n    a: 문자열;\n    b: 문자열;\n}\n\n인터페이스 개는 동물을 확장하며 {\n    c: 문자열;\n}\n\n클래스 개 {\n    constructor() {}\n}\n```\n\n위 예제에서는 속성 a, b 또는 c가 초기화되었는지 여부에 관계없이 초기화되지 않았음에 대한 오류나 경고가 나타나지 않습니다.\n\n그러나 아래 코드를 작성할 때, 여전히 Properties 'a', 'b', 및 'c'에 대한 초기화 프로그램이 없으며 생성자에서 확실하게 할당되지 않았다는 오류가 발생합니다.\n\n```js\n클래스 개 {\n    a: 문자열;\n    b: 문자열;\n    c: 문자열;\n}\n```\n\n\n\n테이블 태그를 마크다운 형식으로 변경하십시오.\n\n| Types do not have this problem, and hence are more straightforward and safe to use as a result.                        |\n|--------------------------------------------------------------------------------------------------------------------------|\n| **Conclusion**                                                                                                          |\n| Unless specific interface behavior is necessary, e.g. extensible refinement or implementation using OOP, your best bet is to stick with types. |\n| Types are flexible and straightforward, and avoid pitfalls associated with declaration merging.                         |\n\n\n\n인터페이스와 성능 면에서도 타입들은 동일합니다.","ogImage":{"url":"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png"},"coverImage":"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    h1: \"h1\",\n    h2: \"h2\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-TypesVsInterfacesinTypeScript_0.png\",\n        alt: \"TypesVsInterfacesinTypeScript\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TypeScript는 놀라운 점들이 가득하고 일부 행동은 TypeScript에만 독점되어 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"오늘은 타입과 인터페이스의 차이점과 대부분의 경우에 타입을 사용해야 하는 이유에 대해 논의할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"더 이상 미루지 말고 바로 들어가 봅시다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"차이가 무엇인가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 동물 유형 및 인터페이스 정의를 분석해 봅시다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"type \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \" = {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": number\\n}\\n\\n\\ninterface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": number\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"구문은 거의 동일한데 유형은 객체의 모양을 정의하기 위해 =로 선언됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이는 큰 차이가 아닙니다. 주요 차이점을 자세히 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"확장성\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"확장성 측면에서 인터페이스가 승자입니다. 인터페이스는 extends 키워드를 사용하여 확장할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"interface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": number\\n}\\n\\ninterface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"extends\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"breed\"\n        }), \": string\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"dog\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" = {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'포유동물'\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'브루노'\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"breed\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'저먼 셰퍼드'\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"개 인터페이스는 동물 인터페이스의 속성을 확장하며 결과로 동물 인터페이스의 속성이 개 인터페이스에 병합됩니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"타입은 두 개의 타입을 병합하는 데 Union(\", _jsx(_components.code, {\n        children: \"|\"\n      }), \") 및 Intersection(\", _jsx(_components.code, {\n        children: \"\u0026\"\n      }), \") 연산자를 사용하여 속성을 확장할 수도 있습니다.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"type \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \" = {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": number\\n}\\n\\ntype \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" = {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"breed\"\n        }), \": string\\n} \u0026 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ❌ 작동하지 않음\"\n        }), \"\\ninterface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" {\\n  breed \\n} \u0026 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"성능\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"성능은 컴파일 시 TypeScript 컴파일러에서 수행되는 타입 체크를 의미합니다.\\n성능은 일반적으로 코드베이스가 커질수록 지수적으로 감소합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것이 왜 우리가 타입 대 인터페이스의 성능을 벤치마킹 하는 이유입니다.\\n나는 TypeScript 분야에서 Matt Pocock을 따르고 있습니다. Total TypeScript 강좌를 수강하는 것이 가치가 있다고 말할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Matt가 타입과 인터페이스의 차이를 설명한 비디오로, 타입과 인터페이스의 성능에는 차이가 없다는 것을 보여줍니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"인터페이스가 해로울 수 있는 이유\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TypeScript의 인터페이스는 선언 병합(Declaration Merging)이라는 독특한 기능을 가지고 있어.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"선언 병합은 TypeScript 컴파일러가 동일한 이름을 가진 두 개 이상의 인터페이스를 하나로 병합하는 것이야.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 초기 Dog 인터페이스\"\n        }), \"\\ninterface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": string\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": number\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"선언 병합\\\"을 이용해 Dog 인터페이스 보강\"\n        }), \"\\ninterface \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"breed\"\n        }), \": string\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"병합된\\\" 인터페이스로 새로운 \\\"개\\\"를 정의해봐\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"dog\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \" = { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Bruno\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"age\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"breed\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"German Shepherd\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"species\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Mamamal\\\"\"\n        }), \" }\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법은 인터페이스에 함수 멤버가 없는 경우 잘 동작해.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런데 함수 멤버가 있는 경우, 선언 병합은 코드베이스에 불리하고 예상치 못한 영향을 미칠 수 있어. 멤버의 우선순위는 나중에 나오는 것이 더 높아져.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"인터페이스 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cloner\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \";\\n}\\n인터페이스 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cloner\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sheep\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sheep\"\n        }), \";\\n}\\n인터페이스 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cloner\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cat\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cat\"\n        }), \";\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 세 가지 인터페이스가 병합되어 다음과 같은 하나의 선언으로 생성됩니다:\"\n        }), \"\\n\\n인터페이스 \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cloner\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Dog\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cat\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cat\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sheep\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Sheep\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"clone\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"animal\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Animal\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 그룹의 요소들은 동일한 순서를 유지하지만, 그룹 자체는 나중에 오버로드 세트로 병합됩니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"클래스와의 안전하지 않은 병합\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TypeScript 컴파일러는 속성 초기화를 확인하지 않기 때문에 예기치 않은 런타임 오류가 발생할 수 있습니다.\\n두 인터페이스의 병합 중에\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"인터페이스 동물 {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": 문자열;\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"b\"\n        }), \": 문자열;\\n}\\n\\n인터페이스 개는 동물을 확장하며 {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"c\"\n        }), \": 문자열;\\n}\\n\\n클래스 개 {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"constructor\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {}\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 예제에서는 속성 a, b 또는 c가 초기화되었는지 여부에 관계없이 초기화되지 않았음에 대한 오류나 경고가 나타나지 않습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러나 아래 코드를 작성할 때, 여전히 Properties 'a', 'b', 및 'c'에 대한 초기화 프로그램이 없으며 생성자에서 확실하게 할당되지 않았다는 오류가 발생합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"클래스 개 {\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"a\"\n        }), \": 문자열;\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"b\"\n        }), \": 문자열;\\n    \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"c\"\n        }), \": 문자열;\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블 태그를 마크다운 형식으로 변경하십시오.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"| Types do not have this problem, and hence are more straightforward and safe to use as a result.                        |\\n|--------------------------------------------------------------------------------------------------------------------------|\\n| \", _jsx(_components.strong, {\n        children: \"Conclusion\"\n      }), \"                                                                                                          |\\n| Unless specific interface behavior is necessary, e.g. extensible refinement or implementation using OOP, your best bet is to stick with types. |\\n| Types are flexible and straightforward, and avoid pitfalls associated with declaration merging.                         |\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"인터페이스와 성능 면에서도 타입들은 동일합니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-TypesVsInterfacesinTypeScript"},"buildId":"K-h7XvEVBqnNx_uXMgZoe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>