<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>코틀린 함수가 일등 시민인 이유 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-15-KotlinFunctionsasFirstClassCitizens" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="코틀린 함수가 일등 시민인 이유 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="코틀린 함수가 일등 시민인 이유 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-15-KotlinFunctionsasFirstClassCitizens" data-gatsby-head="true"/><meta name="twitter:title" content="코틀린 함수가 일등 시민인 이유 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-15 10:25" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_buildManifest.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">코틀린 함수가 일등 시민인 이유</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="코틀린 함수가 일등 시민인 이유" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 15, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-15-KotlinFunctionsasFirstClassCitizens&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>코틀린에서 함수 구성 이해하기</p>
<p><img src="/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png" alt="코틀린 함수"/></p>
<p>코틀린에서 함수는 일등 시민으로 취급되어 변수처럼 다룰 수 있습니다. 즉, 함수는 변수에 할당되거나 다른 함수에 매개변수로 전달되거나 함수에서 반환될 수 있습니다.</p>
<p>이를 통해 함수를 다양한 방식으로 결합하여 코드를 간소화하고 함수형 프로그래밍 패러다임을 사용할 수 있습니다.</p>
<p>자, 우리가 얻을 수 있는 몇 가지 기능들을 살펴봅시다!</p>
<h2>변수에 값 할당하기 📝</h2>
<p>이것에 대한 예시는 다음과 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 선언</span>
val foo : () -&gt; <span class="hljs-title class_">Unit</span> = {
    <span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;안녕 함수!&quot;</span>)
}

<span class="hljs-comment">// 사용</span>
<span class="hljs-title function_">foo</span>()

<span class="hljs-comment">// 결과</span>
안녕 함수!
</code></pre>
<p>참고: 네, 당신은 보통 또는 선언적으로 할 수 있습니다. 여기서는 함수 합성에 대해 이야기하고 있으므로 주석 섹션에서 소리치지 않아도 됩니다.</p>
<p>이 방법의 장점:</p>
<ul>
<li>재사용성</li>
</ul>
<p>변수에 저장해 두었기 때문에 코드베이스의 여러 곳에서 재사용할 수 있습니다.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// 현재 시간 계산</span>
<span class="hljs-keyword">val</span> currentTime: () -&gt; <span class="hljs-built_in">Unit</span> = {
    <span class="hljs-keyword">val</span> currentTime = LocalTime.now()
    <span class="hljs-keyword">val</span> formatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>)
    <span class="hljs-keyword">val</span> formattedTime = currentTime.format(formatter)
    println(<span class="hljs-string">&quot;현재 시간은: <span class="hljs-variable">$formattedTime</span>&quot;</span>)
}

<span class="hljs-comment">// 보통은 호출하여 사용</span>
currentTime()

<span class="hljs-comment">// 또는 일정 간격으로</span>

<span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">repeatInterval</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">Unit</span>, delay: <span class="hljs-type">Long</span>)</span></span> {
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        delay(delay)
        block.invoke()
    }
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    runBlocking {
        launch {
            <span class="hljs-comment">// 매개변수로 전달하는 사용법</span>
            repeatInterval(currentTime, <span class="hljs-number">1000</span>)
        }
    }
}
</code></pre>
<ol start="2">
<li>가독성</li>
</ol>
<p>익명 함수 대신 변수 이름을 전달하여 더 명확하게 만들 수 있습니다. 그렇지 않으면 전체 함수 블록을 읽어야 이해할 수 있습니다. 예시 :</p>
<pre><code class="hljs language-kotlin">repeatInterval({
  <span class="hljs-keyword">val</span> currentTime = LocalTime.now()
  <span class="hljs-keyword">val</span> formatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>)
  <span class="hljs-keyword">val</span> formattedTime = currentTime.format(formatter)
  println(<span class="hljs-string">&quot;현재 시간은: <span class="hljs-variable">$formattedTime</span>&quot;</span>)
  <span class="hljs-comment">// 이것을 이해하려면 전체를 읽어야 합니다</span>
 }, <span class="hljs-number">1000</span>)

<span class="hljs-comment">// 대비</span>

<span class="hljs-keyword">val</span> currentTime: () -&gt; <span class="hljs-built_in">Unit</span> = {
    <span class="hljs-keyword">val</span> currentTime = LocalTime.now()
    <span class="hljs-keyword">val</span> formatter = DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>)
    <span class="hljs-keyword">val</span> formattedTime = currentTime.format(formatter)
    println(<span class="hljs-string">&quot;현재 시간은: <span class="hljs-variable">$formattedTime</span>&quot;</span>)
}

repeatInterval(currentTime, <span class="hljs-number">1000</span>)
</code></pre>
<h2>함수를 인수로 전달할 수 있어요 🔀</h2>
<p>가장 흔한 사용 사례는 악명 높은 콜백 함수입니다. 예를 들어,</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// count complete callback</span>
val countCompleteCallback : () -&gt; <span class="hljs-title class_">Unit</span> = {
    <span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;카운팅이 완료되었습니다!&quot;</span>)
}

<span class="hljs-comment">// 콜백을 인수로 전달</span>
fun <span class="hljs-title function_">count10</span>(<span class="hljs-params">callback:() -&gt; Unit</span>){
    (<span class="hljs-number">1.</span><span class="hljs-number">.10</span>).<span class="hljs-title function_">toList</span>().<span class="hljs-title function_">joinToString</span>().<span class="hljs-title function_">also</span>(::println)
    callback.<span class="hljs-title function_">invoke</span>()
}

<span class="hljs-comment">// 트리거</span>
<span class="hljs-title function_">count10</span>(countCompleteCallback)

<span class="hljs-comment">// 결과</span>
<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>
카운팅이 완료되었습니다!
</code></pre>
<p>하지만 우리가 가장 흔히 하는 일은 무엇인지 되돌아보자</p>
<pre><code class="hljs language-js">(<span class="hljs-number">1.</span><span class="hljs-number">.10</span>).<span class="hljs-property">map</span> { it -&gt; it * it }.<span class="hljs-title function_">also</span>(::println)
</code></pre>
<p>여기서 map 함수는 구문 설탕을 추가하고 있지만 실제 코드는 다음과 같습니다.</p>
<pre><code class="hljs language-js">(<span class="hljs-number">1.</span><span class="hljs-number">.10</span>).<span class="hljs-property">map</span> ({ it -&gt; it * it }).<span class="hljs-title function_">also</span>(::println)

<span class="hljs-comment">// 또는 </span>

val double = { it -&gt; it * it }
(<span class="hljs-number">1.</span><span class="hljs-number">.10</span>).<span class="hljs-title function_">map</span>(double).<span class="hljs-title function_">also</span>(::println)
</code></pre>
<p>맵 작업에서는 함수를 매개변수로 전달하고 있습니다. 이 방식은 모듈화되어 있고 집중적이어서 좋은 접근 방식입니다.</p>
<h2>다른 함수에서 함수를 반환할 수 있어요 🔙</h2>
<p>이것은 많은 사람들에게 이해하기 어려운 내용이지만, 이것을 기반으로 한 가장 유용한 팩토리 함수가 있어요. 예시를 보겠습니다:</p>
<pre><code class="hljs language-js">enum <span class="hljs-keyword">class</span> <span class="hljs-title class_">Language</span> {
    <span class="hljs-variable constant_">ENGLISH</span>,
    <span class="hljs-variable constant_">FRENCH</span>,
    <span class="hljs-variable constant_">HINDI</span>
}

fun <span class="hljs-title function_">greet</span>(<span class="hljs-params">language: Language, name: <span class="hljs-built_in">String</span></span>) {
    val greetings = when (language) {
        <span class="hljs-title class_">Language</span>.<span class="hljs-property">ENGLISH</span> -&gt; <span class="hljs-string">&quot;Hello, $name!&quot;</span>
        <span class="hljs-title class_">Language</span>.<span class="hljs-property">FRENCH</span> -&gt; <span class="hljs-string">&quot;Bonjour, $name!&quot;</span>
        <span class="hljs-title class_">Language</span>.<span class="hljs-property">HINDI</span> -&gt; <span class="hljs-string">&quot;नमस्ते, $name!&quot;</span>
    }
    <span class="hljs-title function_">println</span>(greetings)
}

<span class="hljs-title function_">greet</span>(<span class="hljs-title class_">Language</span>.<span class="hljs-property">HINDI</span>, <span class="hljs-string">&quot;Chetan&quot;</span>) <span class="hljs-comment">// नमस्ते, Chetan!</span>
<span class="hljs-title function_">greet</span>(<span class="hljs-title class_">Language</span>.<span class="hljs-property">ENGLISH</span>, <span class="hljs-string">&quot;Chetan&quot;</span>) <span class="hljs-comment">// Hello, Chetan!</span>
<span class="hljs-title function_">greet</span>(<span class="hljs-title class_">Language</span>.<span class="hljs-property">FRENCH</span>, <span class="hljs-string">&quot;Chetan&quot;</span>) <span class="hljs-comment">// Bonjour, Chetan!</span>
</code></pre>
<p>이 프로그램은 언어와 이름을 인수로 사용하여 인사말을 출력합니다. 또는 이렇게도 할 수 있어요:</p>
<pre><code class="hljs language-js">enum <span class="hljs-keyword">class</span> <span class="hljs-title class_">Language</span> {
    <span class="hljs-variable constant_">ENGLISH</span>,
    <span class="hljs-variable constant_">FRENCH</span>,
    <span class="hljs-variable constant_">HINDI</span>
}

fun <span class="hljs-title function_">greetFactory</span>(<span class="hljs-attr">language</span>: <span class="hljs-title class_">Language</span>): (<span class="hljs-title class_">String</span>) -&gt; <span class="hljs-title class_">Unit</span> {
    <span class="hljs-comment">// function within function</span>
    val greetTo = { <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span> -&gt;
        val greetings = <span class="hljs-title function_">when</span>(<span class="hljs-params">language</span>){
            <span class="hljs-title class_">Language</span>.<span class="hljs-property">ENGLISH</span> -&gt; <span class="hljs-string">&quot;Hello, $name!&quot;</span>
            <span class="hljs-title class_">Language</span>.<span class="hljs-property">FRENCH</span> -&gt; <span class="hljs-string">&quot;Bonjour, $name!&quot;</span>
            <span class="hljs-title class_">Language</span>.<span class="hljs-property">HINDI</span> -&gt; <span class="hljs-string">&quot;नमस्ते, $name!&quot;</span>
        }
        <span class="hljs-title function_">println</span>(greetings)
    }

    <span class="hljs-comment">// returning function</span>
    <span class="hljs-keyword">return</span> greetTo
}

<span class="hljs-comment">// mini function factories which are reusable</span>
val englishGreeting = <span class="hljs-title function_">greetFactory</span>(<span class="hljs-title class_">Language</span>.<span class="hljs-property">ENGLISH</span>)
val frenchGreeting = <span class="hljs-title function_">greetFactory</span>(<span class="hljs-title class_">Language</span>.<span class="hljs-property">FRENCH</span>)
val hindiGreeting = <span class="hljs-title function_">greetFactory</span>(<span class="hljs-title class_">Language</span>.<span class="hljs-property">HINDI</span>)

<span class="hljs-comment">// use them separately </span>
<span class="hljs-title function_">hindiGreeting</span>(<span class="hljs-string">&quot;Chetan&quot;</span>) <span class="hljs-comment">// नमस्ते, Chetan!</span>
<span class="hljs-title function_">englishGreeting</span>(<span class="hljs-string">&quot;Chetan&quot;</span>) <span class="hljs-comment">// Hello, Chetan!</span>
<span class="hljs-title function_">frenchGreeting</span>(<span class="hljs-string">&quot;Chetan&quot;</span>) <span class="hljs-comment">// Bonjour, Chetan!</span>
</code></pre>
<p>추후에 좋아하는 경우에 우리가 다양한 함수 조합 방법을 알고 있다는 것을 걱정하지 마십시오.</p>
<h2>커링 함수: 부분 실행 🥘</h2>
<p>커링 함수 또는 부분 실행 함수는 함수를 반환하는 함수의 부작용입니다. 이를 사용하여 함수의 일부분만 실행할 수 있지만 모두 실행하는 것은 아닙니다. 한 예를 살펴보겠습니다 :```</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// 두 숫자를 더하는 커링된 함수를 정의했습니다</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">curriedAdd</span><span class="hljs-params">(firstNumber: <span class="hljs-type">Int</span>)</span></span>: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> {
    <span class="hljs-keyword">val</span> sumWith = { secondNumber: <span class="hljs-built_in">Int</span> -&gt;
        <span class="hljs-keyword">val</span> sum = firstNumber + secondNumber
        sum
    }
    <span class="hljs-keyword">return</span> sumWith
}

<span class="hljs-comment">// 커링을 사용하여 부분적으로 적용된 함수를 생성합니다</span>
<span class="hljs-keyword">val</span> partialResult = curriedAdd(<span class="hljs-number">2</span>) <span class="hljs-comment">// 이 함수는 첫 번째 인수를 2로 고정합니다</span>

<span class="hljs-comment">// 이제 addTwo는 인수에 2를 더하는 함수입니다</span>
<span class="hljs-keyword">val</span> result1 = partialResult(<span class="hljs-number">3</span>) 
<span class="hljs-keyword">val</span> result2 = partialResult(<span class="hljs-number">10</span>) 

println(<span class="hljs-string">&quot;Result1: <span class="hljs-variable">$result1</span>&quot;</span>) <span class="hljs-comment">// 결과: 2 + 3 = 5</span>
println(<span class="hljs-string">&quot;Result2: <span class="hljs-variable">$result2</span>&quot;</span>) <span class="hljs-comment">// 결과: 2 + 10 = 12</span>
</code></pre>
<p>여기서 <code>curriedAdd</code> 함수는 값 2로 부분 실행되며, 3이 전달될 때 완전 실행되어 결과를 반환합니다. 계산된 값들을 매개변수로 사용하는 경우 뒤에 계산을 완료한 값을로드할 수 있어 매우 편리합니다.</p>
<h2>클로저 👯</h2>
<p>클로저는 외부 함수 범위에 있는 변수에 접근할 수 있도록 내부 함수를 통해 제공합니다. 아래 예제를 참조하세요:</p>
<pre><code class="hljs language-js">fun <span class="hljs-title function_">countWithClosure</span>(): () -&gt; <span class="hljs-title class_">Unit</span> {
    <span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span> <span class="hljs-comment">// 외부 스코프에서 정의된 변수</span>
    val innerFunction = {
        counter++ <span class="hljs-comment">// 외부 스코프의 변수에 접근 및 수정</span>
        <span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;Counter: $counter&quot;</span>)
    }
    <span class="hljs-keyword">return</span> innerFunction
}

val increment = <span class="hljs-title function_">countWithClosure</span>()

<span class="hljs-title function_">increment</span>() <span class="hljs-comment">// 출력: Counter: 1</span>
<span class="hljs-title function_">increment</span>() <span class="hljs-comment">// 출력: Counter: 2</span>
<span class="hljs-title function_">increment</span>() <span class="hljs-comment">// 출력: Counter: 3</span>
</code></pre>
<p>기본적으로 두 개의 함수인 외부 함수와 내부 함수가 역할에 관여하며, 내부 함수는 외부 함수 스코프에 접근할 수 있으며 내부 함수 스코프를 사용하여 외부 스코프의 값을 변경할 수 있습니다.</p>
<p>React에서 매우 인기 있는 기능으로 사용자 정의 후크를 만드는 데 사용되며, Kotlin에서 Jetpack Compose에서도 사용할 수 있습니다.</p>
<pre><code class="hljs language-js">val <span class="hljs-attr">leakyClosure</span>: () -&gt; <span class="hljs-title class_">Unit</span> = {
    <span class="hljs-comment">// 여기서 컨텍스트나 다른 Composable에 액세스하면 메모리 누수가 발생할 수 있습니다.</span>
}
</code></pre>
<h2>함수는 데이터 구조에 저장될 수 있어요 💾</h2>
<p>함수를 컬렉션/데이터 구조에 저장할 수 있어요:</p>
<pre><code class="hljs language-js">fun <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;hello world!&quot;</span>)}
fun <span class="hljs-title function_">farewell</span>(<span class="hljs-params"></span>) {<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;bye bye world!&quot;</span>)}

val functions : <span class="hljs-title class_">List</span>&lt;()-&gt;<span class="hljs-title class_">Unit</span>&gt; = <span class="hljs-title function_">listOf</span>(::greet, ::farewell)

<span class="hljs-comment">// 리스트를 반복하며 각 함수를 호출해요</span>
functions.<span class="hljs-property">onEach</span> { it.<span class="hljs-title function_">invoke</span>() }

<span class="hljs-comment">// 결과</span>
hello world!
bye bye world!
</code></pre>
<p>런타임에서 코드 동작을 조작할 수 있어요. 저는 지난 회사에서 실시간 매개 변수 값을 가져와 서버에 기록하기 위해 분석을 구축하는 데 사용했어요. 예를 들어:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">logOnUserClicked</span> <span class="hljs-params">()</span></span> : Map&lt;String,Any&gt; { 
  ...
  <span class="hljs-keyword">return</span> mapOf(
    <span class="hljs-string">&quot;이메일&quot;</span> to datastore.userEmail,
    <span class="hljs-string">&quot;안드로이드 버전&quot;</span> to BuildConfig.Version
  )
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">logOnBackPress</span> <span class="hljs-params">()</span></span> : Map&lt;String,Any&gt; { ...}

<span class="hljs-keyword">val</span> events : List&lt;()-&gt;<span class="hljs-built_in">Unit</span>&gt; = listOf(::logOnUserClicked, ::logOnBackPress)

events.forEach { event -&gt;
  loggingSdk.log(event())
}
</code></pre>
<p>만약 지금 분석 시스템을 설계하는 방법에 대한 자세한 가이드가 필요하다면, 기사에 댓글을 달아주세요. 다음에 그에 맞는 내용을 만들어 보겠습니다.</p>
<p>함수를 객체에 저장할 수도 있습니다. 예를들어:</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span>(
    <span class="hljs-keyword">val</span> addition: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = { num1, num2 -&gt; num1 + num2 },
    <span class="hljs-keyword">val</span> subtraction: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = { num1, num2 -&gt; num1 - num2 },
    <span class="hljs-keyword">val</span> multiplication: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = { num1, num2 -&gt; num1 * num2 },
)

<span class="hljs-keyword">val</span> calculator = Calculator()

<span class="hljs-keyword">val</span> result1 = calculator.addition(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 결과: 8</span>
<span class="hljs-keyword">val</span> result2 = calculator.subtraction(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 결과: 6</span>
<span class="hljs-keyword">val</span> result3 = calculator.multiplication(<span class="hljs-number">6</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 결과: 12</span>
</code></pre>
<p>객체 내에 함수를 저장하면 코드 구조를 더 잘 정의하고 강력하고 다재다능한 프로그래밍 기술을 구현할 수 있습니다.</p>
<h2>익명 함수 🕵🏽‍♂️</h2>
<p>일시적이거나 일회성 함수에 매우 유용합니다. 이름을 부여하지 않은 함수들이기 때문에 당연히 인라인 함수라고도 불립니다 — 그렇지 않았다면 왜 익명인지요?</p>
<p>이미 알고 계신 예시:</p>
<pre><code class="hljs language-js">(<span class="hljs-number">1.</span><span class="hljs-number">.10</span>).<span class="hljs-property">map</span> { it -&gt; it * it }.<span class="hljs-title function_">also</span>(::println) <span class="hljs-comment">// 결과: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span>
(<span class="hljs-number">1.</span><span class="hljs-number">.10</span>).<span class="hljs-property">filter</span> { it -&gt; it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> }.<span class="hljs-title function_">also</span>(::println) <span class="hljs-comment">// 결과: [2, 4, 6, 8, 10]</span>
</code></pre>
<p>여기까지입니다. 읽어주셔서 감사합니다!</p>
<h2>- 삶 속에서의 업데이트 -</h2>
<p>안녕하세요 👋! 저는 코틀린과 안드로이드 개발에서 7년 이상의 실무 경험을 보유하고 있습니다. 새로운 흥미로운 기회를 찾고 있습니다! 제 포트폴리오와 GitHub 기여를 살펴보시고, 회사에서 경험 많은 안드로이드 개발자가 필요하다면 chetan.garg36@gmail.com으로 연락해주세요. 또한 WhatsApp 번호 +91 8368928213로 연락하거나 LinkedIn에서 저와 연결할 수도 있습니다. 제 전문성을 귀하의 팀에 어떻게 가져다줄 수 있는지 이야기해 보겠습니다!```</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"코틀린 함수가 일등 시민인 이유","description":"","date":"2024-05-15 10:25","slug":"2024-05-15-KotlinFunctionsasFirstClassCitizens","content":"\n\n코틀린에서 함수 구성 이해하기\n\n![코틀린 함수](/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png)\n\n코틀린에서 함수는 일등 시민으로 취급되어 변수처럼 다룰 수 있습니다. 즉, 함수는 변수에 할당되거나 다른 함수에 매개변수로 전달되거나 함수에서 반환될 수 있습니다.\n\n이를 통해 함수를 다양한 방식으로 결합하여 코드를 간소화하고 함수형 프로그래밍 패러다임을 사용할 수 있습니다.\n\n\n\n자, 우리가 얻을 수 있는 몇 가지 기능들을 살펴봅시다!\n\n## 변수에 값 할당하기 📝\n\n이것에 대한 예시는 다음과 같습니다:\n\n```js\n// 선언\nval foo : () -\u003e Unit = {\n    println(\"안녕 함수!\")\n}\n\n// 사용\nfoo()\n\n// 결과\n안녕 함수!\n```\n\n\n\n참고: 네, 당신은 보통 또는 선언적으로 할 수 있습니다. 여기서는 함수 합성에 대해 이야기하고 있으므로 주석 섹션에서 소리치지 않아도 됩니다.\n\n이 방법의 장점:\n\n- 재사용성\n\n변수에 저장해 두었기 때문에 코드베이스의 여러 곳에서 재사용할 수 있습니다.\n\n\n\n```kotlin\n// 현재 시간 계산\nval currentTime: () -\u003e Unit = {\n    val currentTime = LocalTime.now()\n    val formatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\")\n    val formattedTime = currentTime.format(formatter)\n    println(\"현재 시간은: $formattedTime\")\n}\n\n// 보통은 호출하여 사용\ncurrentTime()\n\n// 또는 일정 간격으로\n\nsuspend fun repeatInterval(block: () -\u003e Unit, delay: Long) {\n    while (true) {\n        delay(delay)\n        block.invoke()\n    }\n}\n\nfun main(){\n    runBlocking {\n        launch {\n            // 매개변수로 전달하는 사용법\n            repeatInterval(currentTime, 1000)\n        }\n    }\n}\n```\n\n2. 가독성\n\n익명 함수 대신 변수 이름을 전달하여 더 명확하게 만들 수 있습니다. 그렇지 않으면 전체 함수 블록을 읽어야 이해할 수 있습니다. 예시 :\n\n```kotlin\nrepeatInterval({\n  val currentTime = LocalTime.now()\n  val formatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\")\n  val formattedTime = currentTime.format(formatter)\n  println(\"현재 시간은: $formattedTime\")\n  // 이것을 이해하려면 전체를 읽어야 합니다\n }, 1000)\n\n// 대비\n\nval currentTime: () -\u003e Unit = {\n    val currentTime = LocalTime.now()\n    val formatter = DateTimeFormatter.ofPattern(\"HH:mm:ss\")\n    val formattedTime = currentTime.format(formatter)\n    println(\"현재 시간은: $formattedTime\")\n}\n\nrepeatInterval(currentTime, 1000)\n```\n\n\n\n## 함수를 인수로 전달할 수 있어요 🔀\n\n가장 흔한 사용 사례는 악명 높은 콜백 함수입니다. 예를 들어,\n\n```js\n// count complete callback\nval countCompleteCallback : () -\u003e Unit = {\n    println(\"카운팅이 완료되었습니다!\")\n}\n\n// 콜백을 인수로 전달\nfun count10(callback:() -\u003e Unit){\n    (1..10).toList().joinToString().also(::println)\n    callback.invoke()\n}\n\n// 트리거\ncount10(countCompleteCallback)\n\n// 결과\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n카운팅이 완료되었습니다!\n```\n\n하지만 우리가 가장 흔히 하는 일은 무엇인지 되돌아보자\n\n\n\n```js\n(1..10).map { it -\u003e it * it }.also(::println)\n```\n\n여기서 map 함수는 구문 설탕을 추가하고 있지만 실제 코드는 다음과 같습니다.\n\n```js\n(1..10).map ({ it -\u003e it * it }).also(::println)\n\n// 또는 \n\nval double = { it -\u003e it * it }\n(1..10).map(double).also(::println)\n```\n\n맵 작업에서는 함수를 매개변수로 전달하고 있습니다. 이 방식은 모듈화되어 있고 집중적이어서 좋은 접근 방식입니다.\n\n\n\n## 다른 함수에서 함수를 반환할 수 있어요 🔙\n\n이것은 많은 사람들에게 이해하기 어려운 내용이지만, 이것을 기반으로 한 가장 유용한 팩토리 함수가 있어요. 예시를 보겠습니다:\n\n```js\nenum class Language {\n    ENGLISH,\n    FRENCH,\n    HINDI\n}\n\nfun greet(language: Language, name: String) {\n    val greetings = when (language) {\n        Language.ENGLISH -\u003e \"Hello, $name!\"\n        Language.FRENCH -\u003e \"Bonjour, $name!\"\n        Language.HINDI -\u003e \"नमस्ते, $name!\"\n    }\n    println(greetings)\n}\n\ngreet(Language.HINDI, \"Chetan\") // नमस्ते, Chetan!\ngreet(Language.ENGLISH, \"Chetan\") // Hello, Chetan!\ngreet(Language.FRENCH, \"Chetan\") // Bonjour, Chetan!\n```\n\n이 프로그램은 언어와 이름을 인수로 사용하여 인사말을 출력합니다. 또는 이렇게도 할 수 있어요:\n\n\n\n```js\nenum class Language {\n    ENGLISH,\n    FRENCH,\n    HINDI\n}\n\nfun greetFactory(language: Language): (String) -\u003e Unit {\n    // function within function\n    val greetTo = { name: String -\u003e\n        val greetings = when(language){\n            Language.ENGLISH -\u003e \"Hello, $name!\"\n            Language.FRENCH -\u003e \"Bonjour, $name!\"\n            Language.HINDI -\u003e \"नमस्ते, $name!\"\n        }\n        println(greetings)\n    }\n\n    // returning function\n    return greetTo\n}\n\n// mini function factories which are reusable\nval englishGreeting = greetFactory(Language.ENGLISH)\nval frenchGreeting = greetFactory(Language.FRENCH)\nval hindiGreeting = greetFactory(Language.HINDI)\n\n// use them separately \nhindiGreeting(\"Chetan\") // नमस्ते, Chetan!\nenglishGreeting(\"Chetan\") // Hello, Chetan!\nfrenchGreeting(\"Chetan\") // Bonjour, Chetan!\n```\n\n추후에 좋아하는 경우에 우리가 다양한 함수 조합 방법을 알고 있다는 것을 걱정하지 마십시오.\n\n## 커링 함수: 부분 실행 🥘\n\n커링 함수 또는 부분 실행 함수는 함수를 반환하는 함수의 부작용입니다. 이를 사용하여 함수의 일부분만 실행할 수 있지만 모두 실행하는 것은 아닙니다. 한 예를 살펴보겠습니다 :```\n\n\n\n```kotlin\n// 두 숫자를 더하는 커링된 함수를 정의했습니다\nfun curriedAdd(firstNumber: Int): (Int) -\u003e Int {\n    val sumWith = { secondNumber: Int -\u003e\n        val sum = firstNumber + secondNumber\n        sum\n    }\n    return sumWith\n}\n\n// 커링을 사용하여 부분적으로 적용된 함수를 생성합니다\nval partialResult = curriedAdd(2) // 이 함수는 첫 번째 인수를 2로 고정합니다\n\n// 이제 addTwo는 인수에 2를 더하는 함수입니다\nval result1 = partialResult(3) \nval result2 = partialResult(10) \n\nprintln(\"Result1: $result1\") // 결과: 2 + 3 = 5\nprintln(\"Result2: $result2\") // 결과: 2 + 10 = 12\n```\n\n여기서 `curriedAdd` 함수는 값 2로 부분 실행되며, 3이 전달될 때 완전 실행되어 결과를 반환합니다. 계산된 값들을 매개변수로 사용하는 경우 뒤에 계산을 완료한 값을로드할 수 있어 매우 편리합니다.\n\n## 클로저 👯\n\n클로저는 외부 함수 범위에 있는 변수에 접근할 수 있도록 내부 함수를 통해 제공합니다. 아래 예제를 참조하세요:\n\n\n\n\n```js\nfun countWithClosure(): () -\u003e Unit {\n    var counter = 0 // 외부 스코프에서 정의된 변수\n    val innerFunction = {\n        counter++ // 외부 스코프의 변수에 접근 및 수정\n        println(\"Counter: $counter\")\n    }\n    return innerFunction\n}\n\nval increment = countWithClosure()\n\nincrement() // 출력: Counter: 1\nincrement() // 출력: Counter: 2\nincrement() // 출력: Counter: 3\n```\n\n기본적으로 두 개의 함수인 외부 함수와 내부 함수가 역할에 관여하며, 내부 함수는 외부 함수 스코프에 접근할 수 있으며 내부 함수 스코프를 사용하여 외부 스코프의 값을 변경할 수 있습니다.\n\nReact에서 매우 인기 있는 기능으로 사용자 정의 후크를 만드는 데 사용되며, Kotlin에서 Jetpack Compose에서도 사용할 수 있습니다.\n\n```js\nval leakyClosure: () -\u003e Unit = {\n    // 여기서 컨텍스트나 다른 Composable에 액세스하면 메모리 누수가 발생할 수 있습니다.\n}\n```\n\n\n\n## 함수는 데이터 구조에 저장될 수 있어요 💾\n\n함수를 컬렉션/데이터 구조에 저장할 수 있어요:\n\n```js\nfun greet() {println(\"hello world!\")}\nfun farewell() {println(\"bye bye world!\")}\n\nval functions : List\u003c()-\u003eUnit\u003e = listOf(::greet, ::farewell)\n\n// 리스트를 반복하며 각 함수를 호출해요\nfunctions.onEach { it.invoke() }\n\n// 결과\nhello world!\nbye bye world!\n```\n\n런타임에서 코드 동작을 조작할 수 있어요. 저는 지난 회사에서 실시간 매개 변수 값을 가져와 서버에 기록하기 위해 분석을 구축하는 데 사용했어요. 예를 들어:\n\n\n\n```kotlin\nfun logOnUserClicked () : Map\u003cString,Any\u003e { \n  ...\n  return mapOf(\n    \"이메일\" to datastore.userEmail,\n    \"안드로이드 버전\" to BuildConfig.Version\n  )\n}\n\nfun logOnBackPress () : Map\u003cString,Any\u003e { ...}\n\nval events : List\u003c()-\u003eUnit\u003e = listOf(::logOnUserClicked, ::logOnBackPress)\n\nevents.forEach { event -\u003e\n  loggingSdk.log(event())\n}\n```\n\n만약 지금 분석 시스템을 설계하는 방법에 대한 자세한 가이드가 필요하다면, 기사에 댓글을 달아주세요. 다음에 그에 맞는 내용을 만들어 보겠습니다.\n\n함수를 객체에 저장할 수도 있습니다. 예를들어:\n\n```kotlin\ndata class Calculator(\n    val addition: (Int, Int) -\u003e Int = { num1, num2 -\u003e num1 + num2 },\n    val subtraction: (Int, Int) -\u003e Int = { num1, num2 -\u003e num1 - num2 },\n    val multiplication: (Int, Int) -\u003e Int = { num1, num2 -\u003e num1 * num2 },\n)\n\nval calculator = Calculator()\n\nval result1 = calculator.addition(5, 3) // 결과: 8\nval result2 = calculator.subtraction(10, 4) // 결과: 6\nval result3 = calculator.multiplication(6, 2) // 결과: 12\n```\n\n\n\n객체 내에 함수를 저장하면 코드 구조를 더 잘 정의하고 강력하고 다재다능한 프로그래밍 기술을 구현할 수 있습니다.\n\n## 익명 함수 🕵🏽‍♂️\n\n일시적이거나 일회성 함수에 매우 유용합니다. 이름을 부여하지 않은 함수들이기 때문에 당연히 인라인 함수라고도 불립니다 — 그렇지 않았다면 왜 익명인지요?\n\n이미 알고 계신 예시:\n\n\n\n```js\n(1..10).map { it -\u003e it * it }.also(::println) // 결과: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n(1..10).filter { it -\u003e it % 2 == 0 }.also(::println) // 결과: [2, 4, 6, 8, 10]\n```\n\n여기까지입니다. 읽어주셔서 감사합니다!\n\n## - 삶 속에서의 업데이트 -\n\n안녕하세요 👋! 저는 코틀린과 안드로이드 개발에서 7년 이상의 실무 경험을 보유하고 있습니다. 새로운 흥미로운 기회를 찾고 있습니다! 제 포트폴리오와 GitHub 기여를 살펴보시고, 회사에서 경험 많은 안드로이드 개발자가 필요하다면 chetan.garg36@gmail.com으로 연락해주세요. 또한 WhatsApp 번호 +91 8368928213로 연락하거나 LinkedIn에서 저와 연결할 수도 있습니다. 제 전문성을 귀하의 팀에 어떻게 가져다줄 수 있는지 이야기해 보겠습니다!```","ogImage":{"url":"/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png"},"coverImage":"/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png","tag":["Tech"],"readingTime":8},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"코틀린에서 함수 구성 이해하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-KotlinFunctionsasFirstClassCitizens_0.png\",\n        alt: \"코틀린 함수\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코틀린에서 함수는 일등 시민으로 취급되어 변수처럼 다룰 수 있습니다. 즉, 함수는 변수에 할당되거나 다른 함수에 매개변수로 전달되거나 함수에서 반환될 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이를 통해 함수를 다양한 방식으로 결합하여 코드를 간소화하고 함수형 프로그래밍 패러다임을 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"자, 우리가 얻을 수 있는 몇 가지 기능들을 살펴봅시다!\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"변수에 값 할당하기 📝\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것에 대한 예시는 다음과 같습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 선언\"\n        }), \"\\nval foo : () -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Unit\"\n        }), \" = {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"println\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"안녕 함수!\\\"\"\n        }), \")\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 사용\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"foo\"\n        }), \"()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 결과\"\n        }), \"\\n안녕 함수!\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"참고: 네, 당신은 보통 또는 선언적으로 할 수 있습니다. 여기서는 함수 합성에 대해 이야기하고 있으므로 주석 섹션에서 소리치지 않아도 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 방법의 장점:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"재사용성\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"변수에 저장해 두었기 때문에 코드베이스의 여러 곳에서 재사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 현재 시간 계산\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" currentTime: () -\u003e \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \" = {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" currentTime = LocalTime.now()\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" formatter = DateTimeFormatter.ofPattern(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"HH:mm:ss\\\"\"\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" formattedTime = currentTime.format(formatter)\\n    println(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"현재 시간은: \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$formattedTime\"\n          }), \"\\\"\"]\n        }), \")\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 보통은 호출하여 사용\"\n        }), \"\\ncurrentTime()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 또는 일정 간격으로\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"suspend\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"repeatInterval\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(block: () -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \", delay: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Long\"\n            }), \")\"]\n          })]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"while\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \") {\\n        delay(delay)\\n        block.invoke()\\n    }\\n}\\n\\n\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"main\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \"{\\n    runBlocking {\\n        launch {\\n            \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 매개변수로 전달하는 사용법\"\n        }), \"\\n            repeatInterval(currentTime, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \")\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.ol, {\n      start: \"2\",\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"가독성\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"익명 함수 대신 변수 이름을 전달하여 더 명확하게 만들 수 있습니다. 그렇지 않으면 전체 함수 블록을 읽어야 이해할 수 있습니다. 예시 :\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"repeatInterval({\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" currentTime = LocalTime.now()\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" formatter = DateTimeFormatter.ofPattern(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"HH:mm:ss\\\"\"\n        }), \")\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" formattedTime = currentTime.format(formatter)\\n  println(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"현재 시간은: \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$formattedTime\"\n          }), \"\\\"\"]\n        }), \")\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 이것을 이해하려면 전체를 읽어야 합니다\"\n        }), \"\\n }, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \")\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 대비\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" currentTime: () -\u003e \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \" = {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" currentTime = LocalTime.now()\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" formatter = DateTimeFormatter.ofPattern(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"HH:mm:ss\\\"\"\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" formattedTime = currentTime.format(formatter)\\n    println(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"현재 시간은: \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$formattedTime\"\n          }), \"\\\"\"]\n        }), \")\\n}\\n\\nrepeatInterval(currentTime, \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"함수를 인수로 전달할 수 있어요 🔀\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가장 흔한 사용 사례는 악명 높은 콜백 함수입니다. 예를 들어,\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// count complete callback\"\n        }), \"\\nval countCompleteCallback : () -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Unit\"\n        }), \" = {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"println\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"카운팅이 완료되었습니다!\\\"\"\n        }), \")\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 콜백을 인수로 전달\"\n        }), \"\\nfun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"count10\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"callback:() -\u003e Unit\"\n        }), \"){\\n    (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".10\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toList\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"joinToString\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"also\"\n        }), \"(::println)\\n    callback.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"invoke\"\n        }), \"()\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 트리거\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"count10\"\n        }), \"(countCompleteCallback)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 결과\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"7\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"8\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"9\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \"\\n카운팅이 완료되었습니다!\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 우리가 가장 흔히 하는 일은 무엇인지 되돌아보자\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".10\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"map\"\n        }), \" { it -\u003e it * it }.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"also\"\n        }), \"(::println)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 map 함수는 구문 설탕을 추가하고 있지만 실제 코드는 다음과 같습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".10\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"map\"\n        }), \" ({ it -\u003e it * it }).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"also\"\n        }), \"(::println)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 또는 \"\n        }), \"\\n\\nval double = { it -\u003e it * it }\\n(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".10\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"map\"\n        }), \"(double).\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"also\"\n        }), \"(::println)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"맵 작업에서는 함수를 매개변수로 전달하고 있습니다. 이 방식은 모듈화되어 있고 집중적이어서 좋은 접근 방식입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"다른 함수에서 함수를 반환할 수 있어요 🔙\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 많은 사람들에게 이해하기 어려운 내용이지만, 이것을 기반으로 한 가장 유용한 팩토리 함수가 있어요. 예시를 보겠습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"enum \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ENGLISH\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FRENCH\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"HINDI\"\n        }), \"\\n}\\n\\nfun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"greet\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"language: Language, name: \", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"String\"\n          })]\n        }), \") {\\n    val greetings = when (language) {\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ENGLISH\"\n        }), \" -\u003e \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello, $name!\\\"\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"FRENCH\"\n        }), \" -\u003e \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Bonjour, $name!\\\"\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"HINDI\"\n        }), \" -\u003e \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"नमस्ते, $name!\\\"\"\n        }), \"\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"println\"\n        }), \"(greetings)\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"greet\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"HINDI\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Chetan\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// नमस्ते, Chetan!\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"greet\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ENGLISH\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Chetan\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Hello, Chetan!\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"greet\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"FRENCH\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Chetan\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Bonjour, Chetan!\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 프로그램은 언어와 이름을 인수로 사용하여 인사말을 출력합니다. 또는 이렇게도 할 수 있어요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"enum \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ENGLISH\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FRENCH\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"HINDI\"\n        }), \"\\n}\\n\\nfun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"greetFactory\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"language\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \"): (\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \") -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Unit\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// function within function\"\n        }), \"\\n    val greetTo = { \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"String\"\n        }), \" -\u003e\\n        val greetings = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"when\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"language\"\n        }), \"){\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ENGLISH\"\n        }), \" -\u003e \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello, $name!\\\"\"\n        }), \"\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"FRENCH\"\n        }), \" -\u003e \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Bonjour, $name!\\\"\"\n        }), \"\\n            \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"HINDI\"\n        }), \" -\u003e \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"नमस्ते, $name!\\\"\"\n        }), \"\\n        }\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"println\"\n        }), \"(greetings)\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// returning function\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" greetTo\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// mini function factories which are reusable\"\n        }), \"\\nval englishGreeting = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"greetFactory\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ENGLISH\"\n        }), \")\\nval frenchGreeting = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"greetFactory\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"FRENCH\"\n        }), \")\\nval hindiGreeting = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"greetFactory\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Language\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"HINDI\"\n        }), \")\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// use them separately \"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"hindiGreeting\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Chetan\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// नमस्ते, Chetan!\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"englishGreeting\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Chetan\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Hello, Chetan!\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"frenchGreeting\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Chetan\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Bonjour, Chetan!\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"추후에 좋아하는 경우에 우리가 다양한 함수 조합 방법을 알고 있다는 것을 걱정하지 마십시오.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"커링 함수: 부분 실행 🥘\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"커링 함수 또는 부분 실행 함수는 함수를 반환하는 함수의 부작용입니다. 이를 사용하여 함수의 일부분만 실행할 수 있지만 모두 실행하는 것은 아닙니다. 한 예를 살펴보겠습니다 :```\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 두 숫자를 더하는 커링된 함수를 정의했습니다\"\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"curriedAdd\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(firstNumber: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Int\"\n            }), \")\"]\n          })]\n        }), \": (\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \") -\u003e \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" sumWith = { secondNumber: \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \" -\u003e\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" sum = firstNumber + secondNumber\\n        sum\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" sumWith\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 커링을 사용하여 부분적으로 적용된 함수를 생성합니다\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" partialResult = curriedAdd(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 이 함수는 첫 번째 인수를 2로 고정합니다\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 이제 addTwo는 인수에 2를 더하는 함수입니다\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" result1 = partialResult(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \") \\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" result2 = partialResult(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \") \\n\\nprintln(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"Result1: \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$result1\"\n          }), \"\\\"\"]\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 결과: 2 + 3 = 5\"\n        }), \"\\nprintln(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"Result2: \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$result2\"\n          }), \"\\\"\"]\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 결과: 2 + 10 = 12\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"여기서 \", _jsx(_components.code, {\n        children: \"curriedAdd\"\n      }), \" 함수는 값 2로 부분 실행되며, 3이 전달될 때 완전 실행되어 결과를 반환합니다. 계산된 값들을 매개변수로 사용하는 경우 뒤에 계산을 완료한 값을로드할 수 있어 매우 편리합니다.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"클로저 👯\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"클로저는 외부 함수 범위에 있는 변수에 접근할 수 있도록 내부 함수를 통해 제공합니다. 아래 예제를 참조하세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"countWithClosure\"\n        }), \"(): () -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Unit\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" counter = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 외부 스코프에서 정의된 변수\"\n        }), \"\\n    val innerFunction = {\\n        counter++ \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 외부 스코프의 변수에 접근 및 수정\"\n        }), \"\\n        \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"println\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Counter: $counter\\\"\"\n        }), \")\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" innerFunction\\n}\\n\\nval increment = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"countWithClosure\"\n        }), \"()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"increment\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 출력: Counter: 1\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"increment\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 출력: Counter: 2\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"increment\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 출력: Counter: 3\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기본적으로 두 개의 함수인 외부 함수와 내부 함수가 역할에 관여하며, 내부 함수는 외부 함수 스코프에 접근할 수 있으며 내부 함수 스코프를 사용하여 외부 스코프의 값을 변경할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React에서 매우 인기 있는 기능으로 사용자 정의 후크를 만드는 데 사용되며, Kotlin에서 Jetpack Compose에서도 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"val \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"leakyClosure\"\n        }), \": () -\u003e \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Unit\"\n        }), \" = {\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 여기서 컨텍스트나 다른 Composable에 액세스하면 메모리 누수가 발생할 수 있습니다.\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"함수는 데이터 구조에 저장될 수 있어요 💾\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"함수를 컬렉션/데이터 구조에 저장할 수 있어요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"fun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"greet\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"println\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"hello world!\\\"\"\n        }), \")}\\nfun \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"farewell\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"println\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"bye bye world!\\\"\"\n        }), \")}\\n\\nval functions : \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"List\"\n        }), \"\u003c()-\u003e\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Unit\"\n        }), \"\u003e = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"listOf\"\n        }), \"(::greet, ::farewell)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 리스트를 반복하며 각 함수를 호출해요\"\n        }), \"\\nfunctions.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"onEach\"\n        }), \" { it.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"invoke\"\n        }), \"() }\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 결과\"\n        }), \"\\nhello world!\\nbye bye world!\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"런타임에서 코드 동작을 조작할 수 있어요. 저는 지난 회사에서 실시간 매개 변수 값을 가져와 서버에 기록하기 위해 분석을 구축하는 데 사용했어요. 예를 들어:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"logOnUserClicked\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \" : Map\u003cString,Any\u003e { \\n  ...\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" mapOf(\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"이메일\\\"\"\n        }), \" to datastore.userEmail,\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"안드로이드 버전\\\"\"\n        }), \" to BuildConfig.Version\\n  )\\n}\\n\\n\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"logOnBackPress\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \" : Map\u003cString,Any\u003e { ...}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" events : List\u003c()-\u003e\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \"\u003e = listOf(::logOnUserClicked, ::logOnBackPress)\\n\\nevents.forEach { event -\u003e\\n  loggingSdk.log(event())\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 지금 분석 시스템을 설계하는 방법에 대한 자세한 가이드가 필요하다면, 기사에 댓글을 달아주세요. 다음에 그에 맞는 내용을 만들어 보겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"함수를 객체에 저장할 수도 있습니다. 예를들어:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Calculator\"\n        }), \"(\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" addition: (\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \") -\u003e \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \" = { num1, num2 -\u003e num1 + num2 },\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" subtraction: (\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \") -\u003e \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \" = { num1, num2 -\u003e num1 - num2 },\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" multiplication: (\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \") -\u003e \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \" = { num1, num2 -\u003e num1 * num2 },\\n)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" calculator = Calculator()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" result1 = calculator.addition(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 결과: 8\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" result2 = calculator.subtraction(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"10\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"4\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 결과: 6\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" result3 = calculator.multiplication(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"6\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 결과: 12\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"객체 내에 함수를 저장하면 코드 구조를 더 잘 정의하고 강력하고 다재다능한 프로그래밍 기술을 구현할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"익명 함수 🕵🏽‍♂️\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"일시적이거나 일회성 함수에 매우 유용합니다. 이름을 부여하지 않은 함수들이기 때문에 당연히 인라인 함수라고도 불립니다 — 그렇지 않았다면 왜 익명인지요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이미 알고 계신 예시:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".10\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"map\"\n        }), \" { it -\u003e it * it }.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"also\"\n        }), \"(::println) \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 결과: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\"\n        }), \"\\n(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.\"\n        }), _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \".10\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"filter\"\n        }), \" { it -\u003e it % \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \" == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" }.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"also\"\n        }), \"(::println) \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 결과: [2, 4, 6, 8, 10]\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기까지입니다. 읽어주셔서 감사합니다!\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"- 삶 속에서의 업데이트 -\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"안녕하세요 👋! 저는 코틀린과 안드로이드 개발에서 7년 이상의 실무 경험을 보유하고 있습니다. 새로운 흥미로운 기회를 찾고 있습니다! 제 포트폴리오와 GitHub 기여를 살펴보시고, 회사에서 경험 많은 안드로이드 개발자가 필요하다면 chetan.garg36@gmail.com으로 연락해주세요. 또한 WhatsApp 번호 +91 8368928213로 연락하거나 LinkedIn에서 저와 연결할 수도 있습니다. 제 전문성을 귀하의 팀에 어떻게 가져다줄 수 있는지 이야기해 보겠습니다!```\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-15-KotlinFunctionsasFirstClassCitizens"},"buildId":"837W-BjvPVBgft6aM4api","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>