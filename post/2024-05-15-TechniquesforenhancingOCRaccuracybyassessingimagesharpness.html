<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>이미지 선명도를 평가하여 OCR 정확도 향상 기술 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="이미지 선명도를 평가하여 OCR 정확도 향상 기술 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="이미지 선명도를 평가하여 OCR 정확도 향상 기술 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness" data-gatsby-head="true"/><meta name="twitter:title" content="이미지 선명도를 평가하여 OCR 정확도 향상 기술 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-15 15:24" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_buildManifest.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">이미지 선명도를 평가하여 OCR 정확도 향상 기술</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="이미지 선명도를 평가하여 OCR 정확도 향상 기술" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 15, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_0.png" alt="Image"/></p>
<p>광학 문자 인식(OCR) 기술은 이미지에서 텍스트를 디지털화하는 방법을 혁신적으로 바꿨습니다. 그러나 OCR 시스템이 직면한 지속적인 어려움 중 하나는 흐린 이미지에서 텍스트를 정확하게 해독하는 것입니다. 흐림은 OCR 정확도를 심각하게 저하시켜 추출된 텍스트에서 해석 오류를 일으킬 수 있습니다. 이 기사에서는 OCR 애플리케이션용 이미지의 흐림 문제를 제시하고 이미지 선명도를 평가하기 위한 세 가지 기술을 탐색하여 OCR 정확도를 향상시키겠습니다.</p>
<h1>이미지에서의 흐림이란?</h1>
<p>이미지에서의 흐림은 모션 블러, 초점이 맞지 않은 블러 또는 낮은 이미지 해상도와 같은 다양한 요인 때문에 발생합니다. 이러한 요인은 텍스트의 세부사항과 가장자리를 왜곡시켜 OCR 시스템이 문자를 정확하게 인식하고 추출하는 것을 어렵게 만듭니다.</p>
<h1>OCR은 기업에 어떤 이점을 줄까요?</h1>
<p>OCR은 많은 다른 용도 중에서도 기업에서 널리 사용되는 다음과 같은 응용 프로그램에 사용됩니다:</p>
<ul>
<li>문서 디지털화: 인쇄 또는 손으로 쓴 문서, 양식 및 영수증을 디지털 텍스트로 변환하는 작업입니다.</li>
<li>데이터 추출: 금융, 소매 및 의료 분야와 같은 산업에서, OCR은 양식, 가격표 및 처방전에서 데이터나 중요 정보를 자동으로 추출합니다.</li>
<li>접근성 및 보조 기술: 텍스트 인식 소프트웨어는 인쇄된 텍스트를 청각적 발음이나 점자 출력으로 변환하여 시각 장애가 있는 사용자가 텍스트 콘텐츠에 접근하고 상호 작용할 수 있도록 합니다.</li>
</ul>
<h1>왜 OCR 모델의 데이터 정확도가 매우 중요한가요?</h1>
<p>흐려진 이미지에서 모델을 평가하면 모델의 정확도를 잘못 나타낼 수 있습니다. 정확도는 다음과 같은 이유로 매우 중요합니다:</p>
<ul>
<li>데이터 신뢰성: 높은 정확도는 추출된 텍스트가 원본 콘텐츠를 정확하게 반영하여 기업이 데이터 분석, 의사 결정 및 규정 준수에 OCR 출력에 의존할 수 있도록 보장합니다.</li>
<li>오류 최소화: 부정확한 OCR 결과는 데이터 입력, 문서 처리 및 정보 검색에서 오류를 초래할 수 있으며, 이는 재정적 손실, 규정 위반, 명예 훼손 및 법적 책임으로 이어질 수 있습니다.</li>
<li>효율성: OCR 출력의 수동 확인 및 수정 필요성을 제거함으로써 기업에 시간과 자원을 절약시킵니다.</li>
</ul>
<p>OCR 기술을 도입하면 많은 기업이 추가 수익을 창출할 가능성이 높습니다. 또한 자원 활용의 효율화를 통해 더 나은 비용 절감 효과를 가져오며, 데이터 오류나 준수 위반으로 인한 벌금, 처벌 및 법적 책임 위험을 줄입니다.</p>
<h1>이미지 선명도 평가 기술</h1>
<p>200개의 텍스트를 포함한 잘린 이미지 샘플을 대상으로 이미지의 선명도를 결정하는 최상의 메트릭을 정하는 실험을 진행했습니다. 샘플 이미지에는 일부 흐린 이미지와 카메라 농도가 많이 섞인 이미지도 포함되어 있습니다. 여기서 OpenCV를 사용하여 이미지의 흐림을 식별하는 세 가지 기술을 탐색했습니다: 라플라시안 연산자, 그래디언트 크기법 및 고속 푸리에 변환입니다. 다양한 기술을 비교하기 위해 각 기술에 대한 가장 날카로운 이미지와 가장 흐린 이미지를 참조로 추가했습니다.</p>
<p>이 섹션에서는 다음 기술을 자세히 살펴봅니다.</p>
<h2>라플라시안 연산자 방법</h2>
<p>라플라시안 연산자는 이미지 처리에서 가장자리를 감지하고 이미지의 선명도를 평가하는 데 사용되는 고전적인 기술입니다. 이미지의 두 번째 도함수를 계산하여 가장자리를 감지하고 이미지의 선명도를 평가합니다.</p>
<p>수학적으로 라플라스 연산자 ∇²은 이미지 함수 f(x, y)의 그래디언트의 발산으로 정의됩니다. 여기서 (x, y)는 이미지의 공간 좌표를 나타냅니다:</p>
<p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_1.png" alt="image"/></p>
<p>라플라스 연산자는 각 픽셀에서 이미지 강도 함수의 지역 곡률을 측정합니다. 높은 양수 값은 빠른 강도 변화(가장자리)를 나타내며, 낮은 값은 부드러운 영역을 나타냅니다.</p>
<p>라플라스 연산자의 분산을 계산함으로써 이미지의 선명도를 측정할 수 있습니다. 더 높은 분산 값은 더 날카로운 가장자리와 뚜렷한 특징을 나타냅니다.</p>
<p>다음은 라플라시안 연산자를 구현한 Python 코드입니다:</p>
<p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_2.png" alt="Code"/></p>
<p>이 기술을 샘플 데이터셋에 적용하면 Figure 1의 이미지가 날카로운 점수가 가장 낮지만 더 선명하게 보이고, 실제로 왜곡된 Figure 2의 이미지가 더 높은 날카로운 점수를 가지게 됨을 관찰할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_3.png" alt="Sample Dataset"/></p>
<p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_4.png" alt="이미지"/></p>
<p>노이즈에 민감한 한계: 노이즈가 많은 이미지에서는 라플라시안 연산자가 노이즈를 가장자리로 감지할 수 있으므로 높은 분산과 오해가능한 선명도 측정을 야기할 수 있습니다. 결과적으로 선명한 이미지와 흐린 이미지는 대부분 잘못 분류됩니다.</p>
<h1>그래디언트 크기 방법</h1>
<p>가장자리 감지는 이미지의 구조 정보를 공개하는 이미지의 가장자리를 찾는 과정입니다. Sobel 필터는 이미지 처리에서 일반적으로 사용되는 가장자리 검출 필터 유형입니다. 그들은 이미지 내에서 그래디언트 크기를 계산하여 이미지의 가장자리를 감지하는 데 자주 사용됩니다.</p>
<p>그라디언트는 이미지에서 픽셀 강도의 변화율을 나타냅니다. 그라디언트 크기는 이 그라디언트 벡터의 크기로, 이미지에서 한 지점에서 다른 지점으로 픽셀 강도가 얼마나 빨리 변하는지를 나타냅니다.</p>
<p>수학적으로, 이미지 함수 f(x, y)의 그라디언트는 공간 좌표 (x, y)에 대한 픽셀 강도의 변화율을 나타냅니다:</p>
<p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_5.png" alt="그래픽"/></p>
<p>그라디언트의 크기 ∥∇f(x, y)∥는 그라디언트 벡터의 유클리드 노름으로 계산됩니다:</p>
<p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_6.png" alt="Sobel Operator"/></p>
<p>이 값은 각 픽셀에서 모든 방향으로 픽셀 강도의 변화율을 나타냅니다. 높은 값은 가장자리와 질감과 같은 빠른 강도 변화 영역을 나타내고, 낮은 값은 부드러운 영역을 나타냅니다.</p>
<p>그런 다음 전체 이미지에서 이러한 그래디언트 크기의 평균(평균) 값을 계산합니다. 이 평균 그래디언트 크기는 이미지의 선명도나 가장자리의 존재를 전반적으로 측정하는 지표를 제공합니다. 높은 평균 또는 합계 값은 더 날카로운 가장자리와 뚜렷한 특징을 나타냅니다.</p>
<p>다음은 Sobel 연산자를 구현하는 Python 코드입니다:</p>
<p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_7.png" alt="image1"/></p>
<p>본 기술을 샘플 데이터셋에 적용하면, 아래 그림 3에 있는 이미지가 실제로 왜곡되었을 때 더 높은 선명도 점수를 갖는 반면, 선명도 점수가 가장 낮은 이미지들은 정확하게 식별됨을 관찰할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_8.png" alt="image2"/></p>
<p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_9.png" alt="image3"/></p>
<p>제한 사항: 균일한 영역이나 낮은 대비 특징을 가진 이미지의 경우, 그레디언트 크기는 낮은 크기의 값으로 나타날 수 있어 날카로움을 과소평가할 수 있습니다. 반면 복잡한 질감이나 높은 대비 가장자리를 가진 이미지의 경우, 그레디언트 크기는 더 높은 크기의 값을 생성할 수 있습니다. 따라서 전체적으로 이미지가 깨끗하다고 해도 높은 크기의 값이 나타날 수 있습니다.</p>
<h1>Fast Fourier Transformation 방법</h1>
<p>푸리에 변환은 이미지의 주파수 성분을 분석하기 위해 사용되는 수학적 기술입니다.</p>
<p>이미지 함수 f(x, y)의 푸리에 변환 F(u, v)는 다음과 같이 정의됩니다:</p>
<p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_10.png" alt="image"/></p>
<p>(u, v)은 주파수 도메인의 공간 주파수 좌표를 나타냅니다.</p>
<p>Fourier 변환의 크기 스펙트럼 |F(u, v)|은 이미지에 존재하는 공간 주파수의 분포를 나타냅니다. 높은 크기 값은 가장자리 및 질감과 같은 고주파 구성 요소에 해당하고, 낮은 값은 부드러운 영역과 같은 저주파 구성 요소에 해당합니다.</p>
<p>고속 푸리에 변환(FFT) 방법을 사용하여 이미지 선명도를 평가할 때, 일반적으로 크기 스펙트럼을 분석하고 관련 통계량(평균과 같은)을 계산하여 이미지 전체에서 고주파 콘텐츠의 분포를 양적으로 측정합니다. 높은 통계량 값은 더 날카로운 가장자리와 뚜렷한 특징을 나타냅니다.</p>
<p>여기에 Fourier 변환을 구현하는 Python 코드가 있습니다:</p>
<p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_11.png" alt="Python code"/></p>
<p>이 기술을 샘플 데이터 집합에 적용한 결과, Figure 5의 이미지는 낮은 선명도 점수로 흐린 것으로 올바르게 식별되었으며 Figure 6의 이미지는 높은 선명도 점수로 날카로운 것으로 올바르게 식별되었습니다.</p>
<p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_12.png" alt="Sample dataset application"/></p>
<p><img src="/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_13.png" alt="이미지"/></p>
<h1>우리의 비즈니스 문제에서 가장 잘 작동한 방법은 무엇인가요?</h1>
<p>사용된 이미지 샘플에서 Fast Fourier 변환은 다음과 같은 이유로 가장 잘 작동했습니다:</p>
<ul>
<li>고주파 요소에 대한 민감도: Fast Fourier Transform은 고주파 요소에 매우 민감하여 날카로운 이미지 특징을 탐지하는 데 특히 효과적입니다. 고주파 요소는 푸리에 변환의 크기 스펙트럼에 상당한 기여를 하기 때문에 이미지의 날카로움을 정확하게 식별하고 측정할 수 있습니다.</li>
<li>이동 불변성 특성: 이미지의 위치나 방향에 상관없이 푸리에 변환은 일관되게 주파수 내용을 캡처하므로 이미지의 날카로움을 평가하는 강력하고 안정적인 방법입니다.</li>
</ul>
<h1>임계값을 결정하는 방법</h1>
<p>임계값은 이미지의 선명도 점수를 기반으로 선명하고 흐린 이미지를 구별하는 기준점 역할을 합니다. 이미지의 품질, 텍스트의 특성(글꼴 크기, 스타일, 배경과의 대비) 및 애플리케이션의 특정 요구 사항 등 여러 요소에 따라 이미지 내 텍스트가 선명한지 흐린지를 결정하기 위한 이상적인 임계값이 달라집니다. 임계값을 초과하는 선명도 점수를 가진 이미지는 선명하다고 간주되며, 임계값 이하의 이미지는 흐린 것으로 간주됩니다. 임계값을 조정하면 OCR 처리에 적합한 선명도 수준을 유연하게 결정할 수 있습니다.</p>
<p>임계값을 결정하는 몇 가지 방법은 다음과 같습니다:</p>
<ul>
<li>시각적 검사: 선명한 이미지와 흐린 이미지를 분리하는 방법으로 이미지를 검사하여 임계값을 찾아보는 것.</li>
<li>경험적 테스트: 선명한지 흐린지를 나타내는 진실 레이블이 있는 이미지 세트로 테스트 하는 것.</li>
<li>반복적 개선: 보수적 임계값부터 시작하여 성능에 따라 임계값을 조정하는 것을 통해 개선하는 것이 있습니다.</li>
</ul>
<h1>결론</h1>
<p>결론적으로, 이미지에서의 흐림은 OCR 시스템에 중요한 도전 과제를 제공합니다. 이미지 처리의 기본 원리를 활용하고 임계값 기술을 통합함으로써, 푸리에 변환 방법은 이미지 선명도를 평가하는 믿을 수 있는 방법을 제공하여 OCR 정확성과 성능을 향상시킬 수 있습니다.</p>
<p>Monica Kadlay는 LinkedIn에서 활동 중입니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"이미지 선명도를 평가하여 OCR 정확도 향상 기술","description":"","date":"2024-05-15 15:24","slug":"2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness","content":"\n\n\n![Image](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_0.png)\n\n광학 문자 인식(OCR) 기술은 이미지에서 텍스트를 디지털화하는 방법을 혁신적으로 바꿨습니다. 그러나 OCR 시스템이 직면한 지속적인 어려움 중 하나는 흐린 이미지에서 텍스트를 정확하게 해독하는 것입니다. 흐림은 OCR 정확도를 심각하게 저하시켜 추출된 텍스트에서 해석 오류를 일으킬 수 있습니다. 이 기사에서는 OCR 애플리케이션용 이미지의 흐림 문제를 제시하고 이미지 선명도를 평가하기 위한 세 가지 기술을 탐색하여 OCR 정확도를 향상시키겠습니다.\n\n# 이미지에서의 흐림이란?\n\n이미지에서의 흐림은 모션 블러, 초점이 맞지 않은 블러 또는 낮은 이미지 해상도와 같은 다양한 요인 때문에 발생합니다. 이러한 요인은 텍스트의 세부사항과 가장자리를 왜곡시켜 OCR 시스템이 문자를 정확하게 인식하고 추출하는 것을 어렵게 만듭니다.\n\n\n\n\n# OCR은 기업에 어떤 이점을 줄까요?\n\nOCR은 많은 다른 용도 중에서도 기업에서 널리 사용되는 다음과 같은 응용 프로그램에 사용됩니다:\n\n- 문서 디지털화: 인쇄 또는 손으로 쓴 문서, 양식 및 영수증을 디지털 텍스트로 변환하는 작업입니다.\n- 데이터 추출: 금융, 소매 및 의료 분야와 같은 산업에서, OCR은 양식, 가격표 및 처방전에서 데이터나 중요 정보를 자동으로 추출합니다.\n- 접근성 및 보조 기술: 텍스트 인식 소프트웨어는 인쇄된 텍스트를 청각적 발음이나 점자 출력으로 변환하여 시각 장애가 있는 사용자가 텍스트 콘텐츠에 접근하고 상호 작용할 수 있도록 합니다.\n\n# 왜 OCR 모델의 데이터 정확도가 매우 중요한가요?\n\n\n\n흐려진 이미지에서 모델을 평가하면 모델의 정확도를 잘못 나타낼 수 있습니다. 정확도는 다음과 같은 이유로 매우 중요합니다:\n\n- 데이터 신뢰성: 높은 정확도는 추출된 텍스트가 원본 콘텐츠를 정확하게 반영하여 기업이 데이터 분석, 의사 결정 및 규정 준수에 OCR 출력에 의존할 수 있도록 보장합니다.\n- 오류 최소화: 부정확한 OCR 결과는 데이터 입력, 문서 처리 및 정보 검색에서 오류를 초래할 수 있으며, 이는 재정적 손실, 규정 위반, 명예 훼손 및 법적 책임으로 이어질 수 있습니다.\n- 효율성: OCR 출력의 수동 확인 및 수정 필요성을 제거함으로써 기업에 시간과 자원을 절약시킵니다.\n\nOCR 기술을 도입하면 많은 기업이 추가 수익을 창출할 가능성이 높습니다. 또한 자원 활용의 효율화를 통해 더 나은 비용 절감 효과를 가져오며, 데이터 오류나 준수 위반으로 인한 벌금, 처벌 및 법적 책임 위험을 줄입니다.\n\n# 이미지 선명도 평가 기술\n\n\n\n\n200개의 텍스트를 포함한 잘린 이미지 샘플을 대상으로 이미지의 선명도를 결정하는 최상의 메트릭을 정하는 실험을 진행했습니다. 샘플 이미지에는 일부 흐린 이미지와 카메라 농도가 많이 섞인 이미지도 포함되어 있습니다. 여기서 OpenCV를 사용하여 이미지의 흐림을 식별하는 세 가지 기술을 탐색했습니다: 라플라시안 연산자, 그래디언트 크기법 및 고속 푸리에 변환입니다. 다양한 기술을 비교하기 위해 각 기술에 대한 가장 날카로운 이미지와 가장 흐린 이미지를 참조로 추가했습니다.\n\n이 섹션에서는 다음 기술을 자세히 살펴봅니다.\n\n## 라플라시안 연산자 방법\n\n라플라시안 연산자는 이미지 처리에서 가장자리를 감지하고 이미지의 선명도를 평가하는 데 사용되는 고전적인 기술입니다. 이미지의 두 번째 도함수를 계산하여 가장자리를 감지하고 이미지의 선명도를 평가합니다.\n\n\n\n수학적으로 라플라스 연산자 ∇²은 이미지 함수 f(x, y)의 그래디언트의 발산으로 정의됩니다. 여기서 (x, y)는 이미지의 공간 좌표를 나타냅니다:\n\n![image](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_1.png)\n\n라플라스 연산자는 각 픽셀에서 이미지 강도 함수의 지역 곡률을 측정합니다. 높은 양수 값은 빠른 강도 변화(가장자리)를 나타내며, 낮은 값은 부드러운 영역을 나타냅니다.\n\n라플라스 연산자의 분산을 계산함으로써 이미지의 선명도를 측정할 수 있습니다. 더 높은 분산 값은 더 날카로운 가장자리와 뚜렷한 특징을 나타냅니다.\n\n\n\n다음은 라플라시안 연산자를 구현한 Python 코드입니다:\n\n\n![Code](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_2.png)\n\n\n이 기술을 샘플 데이터셋에 적용하면 Figure 1의 이미지가 날카로운 점수가 가장 낮지만 더 선명하게 보이고, 실제로 왜곡된 Figure 2의 이미지가 더 높은 날카로운 점수를 가지게 됨을 관찰할 수 있습니다.\n\n\n![Sample Dataset](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_3.png)\n\n\n\n\n![이미지](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_4.png)\n\n노이즈에 민감한 한계: 노이즈가 많은 이미지에서는 라플라시안 연산자가 노이즈를 가장자리로 감지할 수 있으므로 높은 분산과 오해가능한 선명도 측정을 야기할 수 있습니다. 결과적으로 선명한 이미지와 흐린 이미지는 대부분 잘못 분류됩니다.\n\n# 그래디언트 크기 방법\n\n가장자리 감지는 이미지의 구조 정보를 공개하는 이미지의 가장자리를 찾는 과정입니다. Sobel 필터는 이미지 처리에서 일반적으로 사용되는 가장자리 검출 필터 유형입니다. 그들은 이미지 내에서 그래디언트 크기를 계산하여 이미지의 가장자리를 감지하는 데 자주 사용됩니다.\n\n\n\n그라디언트는 이미지에서 픽셀 강도의 변화율을 나타냅니다. 그라디언트 크기는 이 그라디언트 벡터의 크기로, 이미지에서 한 지점에서 다른 지점으로 픽셀 강도가 얼마나 빨리 변하는지를 나타냅니다.\n\n수학적으로, 이미지 함수 f(x, y)의 그라디언트는 공간 좌표 (x, y)에 대한 픽셀 강도의 변화율을 나타냅니다:\n\n![그래픽](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_5.png)\n\n그라디언트의 크기 ∥∇f(x, y)∥는 그라디언트 벡터의 유클리드 노름으로 계산됩니다:\n\n\n\n\n![Sobel Operator](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_6.png)\n\n이 값은 각 픽셀에서 모든 방향으로 픽셀 강도의 변화율을 나타냅니다. 높은 값은 가장자리와 질감과 같은 빠른 강도 변화 영역을 나타내고, 낮은 값은 부드러운 영역을 나타냅니다.\n\n그런 다음 전체 이미지에서 이러한 그래디언트 크기의 평균(평균) 값을 계산합니다. 이 평균 그래디언트 크기는 이미지의 선명도나 가장자리의 존재를 전반적으로 측정하는 지표를 제공합니다. 높은 평균 또는 합계 값은 더 날카로운 가장자리와 뚜렷한 특징을 나타냅니다.\n\n다음은 Sobel 연산자를 구현하는 Python 코드입니다:\n\n\n\n\n![image1](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_7.png)\n\n본 기술을 샘플 데이터셋에 적용하면, 아래 그림 3에 있는 이미지가 실제로 왜곡되었을 때 더 높은 선명도 점수를 갖는 반면, 선명도 점수가 가장 낮은 이미지들은 정확하게 식별됨을 관찰할 수 있습니다.\n\n![image2](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_8.png)\n\n![image3](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_9.png)\n\n\n\n제한 사항: 균일한 영역이나 낮은 대비 특징을 가진 이미지의 경우, 그레디언트 크기는 낮은 크기의 값으로 나타날 수 있어 날카로움을 과소평가할 수 있습니다. 반면 복잡한 질감이나 높은 대비 가장자리를 가진 이미지의 경우, 그레디언트 크기는 더 높은 크기의 값을 생성할 수 있습니다. 따라서 전체적으로 이미지가 깨끗하다고 해도 높은 크기의 값이 나타날 수 있습니다.\n\n# Fast Fourier Transformation 방법\n\n푸리에 변환은 이미지의 주파수 성분을 분석하기 위해 사용되는 수학적 기술입니다.\n\n이미지 함수 f(x, y)의 푸리에 변환 F(u, v)는 다음과 같이 정의됩니다:\n\n\n\n\n![image](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_10.png)\n\n(u, v)은 주파수 도메인의 공간 주파수 좌표를 나타냅니다.\n\nFourier 변환의 크기 스펙트럼 |F(u, v)|은 이미지에 존재하는 공간 주파수의 분포를 나타냅니다. 높은 크기 값은 가장자리 및 질감과 같은 고주파 구성 요소에 해당하고, 낮은 값은 부드러운 영역과 같은 저주파 구성 요소에 해당합니다.\n\n고속 푸리에 변환(FFT) 방법을 사용하여 이미지 선명도를 평가할 때, 일반적으로 크기 스펙트럼을 분석하고 관련 통계량(평균과 같은)을 계산하여 이미지 전체에서 고주파 콘텐츠의 분포를 양적으로 측정합니다. 높은 통계량 값은 더 날카로운 가장자리와 뚜렷한 특징을 나타냅니다.\n\n\n\n\n여기에 Fourier 변환을 구현하는 Python 코드가 있습니다:\n\n\n![Python code](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_11.png)\n\n\n이 기술을 샘플 데이터 집합에 적용한 결과, Figure 5의 이미지는 낮은 선명도 점수로 흐린 것으로 올바르게 식별되었으며 Figure 6의 이미지는 높은 선명도 점수로 날카로운 것으로 올바르게 식별되었습니다.\n\n\n![Sample dataset application](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_12.png)\n\n\n\n\n![이미지](/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_13.png)\n\n# 우리의 비즈니스 문제에서 가장 잘 작동한 방법은 무엇인가요?\n\n사용된 이미지 샘플에서 Fast Fourier 변환은 다음과 같은 이유로 가장 잘 작동했습니다:\n\n- 고주파 요소에 대한 민감도: Fast Fourier Transform은 고주파 요소에 매우 민감하여 날카로운 이미지 특징을 탐지하는 데 특히 효과적입니다. 고주파 요소는 푸리에 변환의 크기 스펙트럼에 상당한 기여를 하기 때문에 이미지의 날카로움을 정확하게 식별하고 측정할 수 있습니다.\n- 이동 불변성 특성: 이미지의 위치나 방향에 상관없이 푸리에 변환은 일관되게 주파수 내용을 캡처하므로 이미지의 날카로움을 평가하는 강력하고 안정적인 방법입니다.\n\n\n\n# 임계값을 결정하는 방법\n\n임계값은 이미지의 선명도 점수를 기반으로 선명하고 흐린 이미지를 구별하는 기준점 역할을 합니다. 이미지의 품질, 텍스트의 특성(글꼴 크기, 스타일, 배경과의 대비) 및 애플리케이션의 특정 요구 사항 등 여러 요소에 따라 이미지 내 텍스트가 선명한지 흐린지를 결정하기 위한 이상적인 임계값이 달라집니다. 임계값을 초과하는 선명도 점수를 가진 이미지는 선명하다고 간주되며, 임계값 이하의 이미지는 흐린 것으로 간주됩니다. 임계값을 조정하면 OCR 처리에 적합한 선명도 수준을 유연하게 결정할 수 있습니다.\n\n임계값을 결정하는 몇 가지 방법은 다음과 같습니다:\n\n- 시각적 검사: 선명한 이미지와 흐린 이미지를 분리하는 방법으로 이미지를 검사하여 임계값을 찾아보는 것.\n- 경험적 테스트: 선명한지 흐린지를 나타내는 진실 레이블이 있는 이미지 세트로 테스트 하는 것.\n- 반복적 개선: 보수적 임계값부터 시작하여 성능에 따라 임계값을 조정하는 것을 통해 개선하는 것이 있습니다.\n\n\n\n# 결론\n\n결론적으로, 이미지에서의 흐림은 OCR 시스템에 중요한 도전 과제를 제공합니다. 이미지 처리의 기본 원리를 활용하고 임계값 기술을 통합함으로써, 푸리에 변환 방법은 이미지 선명도를 평가하는 믿을 수 있는 방법을 제공하여 OCR 정확성과 성능을 향상시킬 수 있습니다.\n\nMonica Kadlay는 LinkedIn에서 활동 중입니다.","ogImage":{"url":"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_0.png"},"coverImage":"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_0.png","tag":["Tech"],"readingTime":7},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_0.png\",\n        alt: \"Image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"광학 문자 인식(OCR) 기술은 이미지에서 텍스트를 디지털화하는 방법을 혁신적으로 바꿨습니다. 그러나 OCR 시스템이 직면한 지속적인 어려움 중 하나는 흐린 이미지에서 텍스트를 정확하게 해독하는 것입니다. 흐림은 OCR 정확도를 심각하게 저하시켜 추출된 텍스트에서 해석 오류를 일으킬 수 있습니다. 이 기사에서는 OCR 애플리케이션용 이미지의 흐림 문제를 제시하고 이미지 선명도를 평가하기 위한 세 가지 기술을 탐색하여 OCR 정확도를 향상시키겠습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"이미지에서의 흐림이란?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이미지에서의 흐림은 모션 블러, 초점이 맞지 않은 블러 또는 낮은 이미지 해상도와 같은 다양한 요인 때문에 발생합니다. 이러한 요인은 텍스트의 세부사항과 가장자리를 왜곡시켜 OCR 시스템이 문자를 정확하게 인식하고 추출하는 것을 어렵게 만듭니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"OCR은 기업에 어떤 이점을 줄까요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"OCR은 많은 다른 용도 중에서도 기업에서 널리 사용되는 다음과 같은 응용 프로그램에 사용됩니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"문서 디지털화: 인쇄 또는 손으로 쓴 문서, 양식 및 영수증을 디지털 텍스트로 변환하는 작업입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"데이터 추출: 금융, 소매 및 의료 분야와 같은 산업에서, OCR은 양식, 가격표 및 처방전에서 데이터나 중요 정보를 자동으로 추출합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"접근성 및 보조 기술: 텍스트 인식 소프트웨어는 인쇄된 텍스트를 청각적 발음이나 점자 출력으로 변환하여 시각 장애가 있는 사용자가 텍스트 콘텐츠에 접근하고 상호 작용할 수 있도록 합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"왜 OCR 모델의 데이터 정확도가 매우 중요한가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"흐려진 이미지에서 모델을 평가하면 모델의 정확도를 잘못 나타낼 수 있습니다. 정확도는 다음과 같은 이유로 매우 중요합니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"데이터 신뢰성: 높은 정확도는 추출된 텍스트가 원본 콘텐츠를 정확하게 반영하여 기업이 데이터 분석, 의사 결정 및 규정 준수에 OCR 출력에 의존할 수 있도록 보장합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"오류 최소화: 부정확한 OCR 결과는 데이터 입력, 문서 처리 및 정보 검색에서 오류를 초래할 수 있으며, 이는 재정적 손실, 규정 위반, 명예 훼손 및 법적 책임으로 이어질 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"효율성: OCR 출력의 수동 확인 및 수정 필요성을 제거함으로써 기업에 시간과 자원을 절약시킵니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"OCR 기술을 도입하면 많은 기업이 추가 수익을 창출할 가능성이 높습니다. 또한 자원 활용의 효율화를 통해 더 나은 비용 절감 효과를 가져오며, 데이터 오류나 준수 위반으로 인한 벌금, 처벌 및 법적 책임 위험을 줄입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"이미지 선명도 평가 기술\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"200개의 텍스트를 포함한 잘린 이미지 샘플을 대상으로 이미지의 선명도를 결정하는 최상의 메트릭을 정하는 실험을 진행했습니다. 샘플 이미지에는 일부 흐린 이미지와 카메라 농도가 많이 섞인 이미지도 포함되어 있습니다. 여기서 OpenCV를 사용하여 이미지의 흐림을 식별하는 세 가지 기술을 탐색했습니다: 라플라시안 연산자, 그래디언트 크기법 및 고속 푸리에 변환입니다. 다양한 기술을 비교하기 위해 각 기술에 대한 가장 날카로운 이미지와 가장 흐린 이미지를 참조로 추가했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 섹션에서는 다음 기술을 자세히 살펴봅니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"라플라시안 연산자 방법\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"라플라시안 연산자는 이미지 처리에서 가장자리를 감지하고 이미지의 선명도를 평가하는 데 사용되는 고전적인 기술입니다. 이미지의 두 번째 도함수를 계산하여 가장자리를 감지하고 이미지의 선명도를 평가합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"수학적으로 라플라스 연산자 ∇²은 이미지 함수 f(x, y)의 그래디언트의 발산으로 정의됩니다. 여기서 (x, y)는 이미지의 공간 좌표를 나타냅니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_1.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"라플라스 연산자는 각 픽셀에서 이미지 강도 함수의 지역 곡률을 측정합니다. 높은 양수 값은 빠른 강도 변화(가장자리)를 나타내며, 낮은 값은 부드러운 영역을 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"라플라스 연산자의 분산을 계산함으로써 이미지의 선명도를 측정할 수 있습니다. 더 높은 분산 값은 더 날카로운 가장자리와 뚜렷한 특징을 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 라플라시안 연산자를 구현한 Python 코드입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_2.png\",\n        alt: \"Code\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기술을 샘플 데이터셋에 적용하면 Figure 1의 이미지가 날카로운 점수가 가장 낮지만 더 선명하게 보이고, 실제로 왜곡된 Figure 2의 이미지가 더 높은 날카로운 점수를 가지게 됨을 관찰할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_3.png\",\n        alt: \"Sample Dataset\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_4.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"노이즈에 민감한 한계: 노이즈가 많은 이미지에서는 라플라시안 연산자가 노이즈를 가장자리로 감지할 수 있으므로 높은 분산과 오해가능한 선명도 측정을 야기할 수 있습니다. 결과적으로 선명한 이미지와 흐린 이미지는 대부분 잘못 분류됩니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"그래디언트 크기 방법\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"가장자리 감지는 이미지의 구조 정보를 공개하는 이미지의 가장자리를 찾는 과정입니다. Sobel 필터는 이미지 처리에서 일반적으로 사용되는 가장자리 검출 필터 유형입니다. 그들은 이미지 내에서 그래디언트 크기를 계산하여 이미지의 가장자리를 감지하는 데 자주 사용됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그라디언트는 이미지에서 픽셀 강도의 변화율을 나타냅니다. 그라디언트 크기는 이 그라디언트 벡터의 크기로, 이미지에서 한 지점에서 다른 지점으로 픽셀 강도가 얼마나 빨리 변하는지를 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"수학적으로, 이미지 함수 f(x, y)의 그라디언트는 공간 좌표 (x, y)에 대한 픽셀 강도의 변화율을 나타냅니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_5.png\",\n        alt: \"그래픽\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그라디언트의 크기 ∥∇f(x, y)∥는 그라디언트 벡터의 유클리드 노름으로 계산됩니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_6.png\",\n        alt: \"Sobel Operator\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 값은 각 픽셀에서 모든 방향으로 픽셀 강도의 변화율을 나타냅니다. 높은 값은 가장자리와 질감과 같은 빠른 강도 변화 영역을 나타내고, 낮은 값은 부드러운 영역을 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그런 다음 전체 이미지에서 이러한 그래디언트 크기의 평균(평균) 값을 계산합니다. 이 평균 그래디언트 크기는 이미지의 선명도나 가장자리의 존재를 전반적으로 측정하는 지표를 제공합니다. 높은 평균 또는 합계 값은 더 날카로운 가장자리와 뚜렷한 특징을 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 Sobel 연산자를 구현하는 Python 코드입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_7.png\",\n        alt: \"image1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"본 기술을 샘플 데이터셋에 적용하면, 아래 그림 3에 있는 이미지가 실제로 왜곡되었을 때 더 높은 선명도 점수를 갖는 반면, 선명도 점수가 가장 낮은 이미지들은 정확하게 식별됨을 관찰할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_8.png\",\n        alt: \"image2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_9.png\",\n        alt: \"image3\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제한 사항: 균일한 영역이나 낮은 대비 특징을 가진 이미지의 경우, 그레디언트 크기는 낮은 크기의 값으로 나타날 수 있어 날카로움을 과소평가할 수 있습니다. 반면 복잡한 질감이나 높은 대비 가장자리를 가진 이미지의 경우, 그레디언트 크기는 더 높은 크기의 값을 생성할 수 있습니다. 따라서 전체적으로 이미지가 깨끗하다고 해도 높은 크기의 값이 나타날 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Fast Fourier Transformation 방법\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"푸리에 변환은 이미지의 주파수 성분을 분석하기 위해 사용되는 수학적 기술입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이미지 함수 f(x, y)의 푸리에 변환 F(u, v)는 다음과 같이 정의됩니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_10.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(u, v)은 주파수 도메인의 공간 주파수 좌표를 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Fourier 변환의 크기 스펙트럼 |F(u, v)|은 이미지에 존재하는 공간 주파수의 분포를 나타냅니다. 높은 크기 값은 가장자리 및 질감과 같은 고주파 구성 요소에 해당하고, 낮은 값은 부드러운 영역과 같은 저주파 구성 요소에 해당합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"고속 푸리에 변환(FFT) 방법을 사용하여 이미지 선명도를 평가할 때, 일반적으로 크기 스펙트럼을 분석하고 관련 통계량(평균과 같은)을 계산하여 이미지 전체에서 고주파 콘텐츠의 분포를 양적으로 측정합니다. 높은 통계량 값은 더 날카로운 가장자리와 뚜렷한 특징을 나타냅니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기에 Fourier 변환을 구현하는 Python 코드가 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_11.png\",\n        alt: \"Python code\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 기술을 샘플 데이터 집합에 적용한 결과, Figure 5의 이미지는 낮은 선명도 점수로 흐린 것으로 올바르게 식별되었으며 Figure 6의 이미지는 높은 선명도 점수로 날카로운 것으로 올바르게 식별되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_12.png\",\n        alt: \"Sample dataset application\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness_13.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"우리의 비즈니스 문제에서 가장 잘 작동한 방법은 무엇인가요?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"사용된 이미지 샘플에서 Fast Fourier 변환은 다음과 같은 이유로 가장 잘 작동했습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"고주파 요소에 대한 민감도: Fast Fourier Transform은 고주파 요소에 매우 민감하여 날카로운 이미지 특징을 탐지하는 데 특히 효과적입니다. 고주파 요소는 푸리에 변환의 크기 스펙트럼에 상당한 기여를 하기 때문에 이미지의 날카로움을 정확하게 식별하고 측정할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이동 불변성 특성: 이미지의 위치나 방향에 상관없이 푸리에 변환은 일관되게 주파수 내용을 캡처하므로 이미지의 날카로움을 평가하는 강력하고 안정적인 방법입니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"임계값을 결정하는 방법\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"임계값은 이미지의 선명도 점수를 기반으로 선명하고 흐린 이미지를 구별하는 기준점 역할을 합니다. 이미지의 품질, 텍스트의 특성(글꼴 크기, 스타일, 배경과의 대비) 및 애플리케이션의 특정 요구 사항 등 여러 요소에 따라 이미지 내 텍스트가 선명한지 흐린지를 결정하기 위한 이상적인 임계값이 달라집니다. 임계값을 초과하는 선명도 점수를 가진 이미지는 선명하다고 간주되며, 임계값 이하의 이미지는 흐린 것으로 간주됩니다. 임계값을 조정하면 OCR 처리에 적합한 선명도 수준을 유연하게 결정할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"임계값을 결정하는 몇 가지 방법은 다음과 같습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"시각적 검사: 선명한 이미지와 흐린 이미지를 분리하는 방법으로 이미지를 검사하여 임계값을 찾아보는 것.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"경험적 테스트: 선명한지 흐린지를 나타내는 진실 레이블이 있는 이미지 세트로 테스트 하는 것.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"반복적 개선: 보수적 임계값부터 시작하여 성능에 따라 임계값을 조정하는 것을 통해 개선하는 것이 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결론적으로, 이미지에서의 흐림은 OCR 시스템에 중요한 도전 과제를 제공합니다. 이미지 처리의 기본 원리를 활용하고 임계값 기술을 통합함으로써, 푸리에 변환 방법은 이미지 선명도를 평가하는 믿을 수 있는 방법을 제공하여 OCR 정확성과 성능을 향상시킬 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Monica Kadlay는 LinkedIn에서 활동 중입니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-15-TechniquesforenhancingOCRaccuracybyassessingimagesharpness"},"buildId":"R94iUTCf1NWeBC_VXjTJG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>