<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Angular에서 존리스zoneless 미래에 대비하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-HowtogetreadyforzonelessfutureinAngular" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Angular에서 존리스zoneless 미래에 대비하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Angular에서 존리스zoneless 미래에 대비하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-HowtogetreadyforzonelessfutureinAngular_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-HowtogetreadyforzonelessfutureinAngular" data-gatsby-head="true"/><meta name="twitter:title" content="Angular에서 존리스zoneless 미래에 대비하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-HowtogetreadyforzonelessfutureinAngular_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 14:41" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Angular에서 존리스zoneless 미래에 대비하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Angular에서 존리스zoneless 미래에 대비하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">2<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-HowtogetreadyforzonelessfutureinAngular&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-22-HowtogetreadyforzonelessfutureinAngular_0.png">
<p>Angular 18은 zone.js를 기반으로 한 기존 버전보다 더 효율적인 zoneless change detection을 실험적으로 지원합니다.</p>
<p>이 기능에 대한 자세한 내용은 아래 링크를 참조하세요 👇</p>
<p>새 프로젝트를 시작하면 zoneless 옵션을 쉽게 선택할 수 있습니다. 하지만 기존 애플리케이션에 이 기능을 통합하는 것은 간단하지 않을 수 있습니다.</p>
<div class="content-ad"></div>
<p>이 블로그 포스트에서는 Angular의 무존재(zonless) 미래에 대비할 수 있는 두 가지 간단한 단계에 대해 이야기하겠습니다.</p>
<p>무존재 변경 감지(zoneless change detection)를 수용하는 새로운 기능을 생성하는 프로세스를 수립하는 것이 바람직합니다. 상세한 설명이 필요한 경우가 있겠지만, 코드가 OnPush 변경 감지 전략과 함께 작동한다면 무존재 변경 감지와 호환될 것으로 가정할 수 있습니다.</p>
<p>자세한 내용은 여기에서 확인하실 수 있습니다 👇</p>
<p>이 패턴을 구현하려면 두 가지 조치를 취할 수 있습니다:</p>
<div class="content-ad"></div>
<ul>
<li>angular.json (nx.json) 파일에서 기본 변경 감지 전략을 수정하십시오:</li>
</ul>
<pre><code class="hljs language-js">{
  <span class="hljs-string">"$schema"</span>: <span class="hljs-string">"./node_modules/@angular/cli/lib/config/schema.json"</span>,
  <span class="hljs-string">"version"</span>: <span class="hljs-number">1</span>,
  <span class="hljs-string">"newProjectRoot"</span>: <span class="hljs-string">"projects"</span>,
  <span class="hljs-string">"projects"</span>: {
    <span class="hljs-string">"ng-18-playground"</span>: {
      <span class="hljs-string">"projectType"</span>: <span class="hljs-string">"application"</span>,
      <span class="hljs-string">"schematics"</span>: {
        <span class="hljs-string">"@schematics/angular:component"</span>: {
          <span class="hljs-string">"changeDetection"</span>: <span class="hljs-string">"OnPush"</span>
        }
      }
      
      ...
    }
  }
}
</code></pre>
<ol start="2">
<li>OnPush 변경 감지를 강제하는 ESLint 규칙을 추가하십시오:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-comment">// @ts-check</span>
<span class="hljs-keyword">const</span> eslint = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@eslint/js"</span>);
<span class="hljs-keyword">const</span> tseslint = <span class="hljs-built_in">require</span>(<span class="hljs-string">"typescript-eslint"</span>);
<span class="hljs-keyword">const</span> angular = <span class="hljs-built_in">require</span>(<span class="hljs-string">"angular-eslint"</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = tseslint.<span class="hljs-title function_">config</span>(
  {
    <span class="hljs-attr">files</span>: [<span class="hljs-string">"**/*.ts"</span>],
    <span class="hljs-attr">extends</span>: [
      eslint.<span class="hljs-property">configs</span>.<span class="hljs-property">recommended</span>,
      ...tseslint.<span class="hljs-property">configs</span>.<span class="hljs-property">recommended</span>,
      ...tseslint.<span class="hljs-property">configs</span>.<span class="hljs-property">stylistic</span>,
      ...angular.<span class="hljs-property">configs</span>.<span class="hljs-property">tsRecommended</span>,
    ],
    <span class="hljs-attr">processor</span>: angular.<span class="hljs-property">processInlineTemplates</span>,
    <span class="hljs-attr">rules</span>: {
      <span class="hljs-string">"@angular-eslint/prefer-on-push-component-change-detection"</span>: [<span class="hljs-string">"warn|error"</span>],
    },
  }
  ...
);
</code></pre>
<div class="content-ad"></div>
<p>Nx를 사용하면 특정 프로젝트에 대해 규칙을 설정할 수 있습니다. 이 기능을 사용하면 새 프로젝트에 대해 오류로 심각도 수준을 지정할 수 있습니다. 기존 프로젝트는 리팩터링을 통해 존이 없는 변경 감지로 준수할 때까지 경고를 유지할 수 있습니다.</p>
<p>존이 없는 변경 감지는 실험적인 기능이지만, 새 기능을 개발할 때 고려해 두는 것이 좋습니다. 이렇게 하면 나중에 존.js 없이 쉽게 theworld로 전환할 수 있습니다.</p>
<p>제 블로그 글이 마음에 들었으면 좋겠어요. 읽어 주셔서 감사합니다! 🙂</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Angular에서 존리스zoneless 미래에 대비하는 방법","description":"","date":"2024-06-22 14:41","slug":"2024-06-22-HowtogetreadyforzonelessfutureinAngular","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-HowtogetreadyforzonelessfutureinAngular_0.png\" /\u003e\n\nAngular 18은 zone.js를 기반으로 한 기존 버전보다 더 효율적인 zoneless change detection을 실험적으로 지원합니다.\n\n이 기능에 대한 자세한 내용은 아래 링크를 참조하세요 👇\n\n새 프로젝트를 시작하면 zoneless 옵션을 쉽게 선택할 수 있습니다. 하지만 기존 애플리케이션에 이 기능을 통합하는 것은 간단하지 않을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 블로그 포스트에서는 Angular의 무존재(zonless) 미래에 대비할 수 있는 두 가지 간단한 단계에 대해 이야기하겠습니다.\n\n무존재 변경 감지(zoneless change detection)를 수용하는 새로운 기능을 생성하는 프로세스를 수립하는 것이 바람직합니다. 상세한 설명이 필요한 경우가 있겠지만, 코드가 OnPush 변경 감지 전략과 함께 작동한다면 무존재 변경 감지와 호환될 것으로 가정할 수 있습니다.\n\n자세한 내용은 여기에서 확인하실 수 있습니다 👇\n\n이 패턴을 구현하려면 두 가지 조치를 취할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- angular.json (nx.json) 파일에서 기본 변경 감지 전략을 수정하십시오:\n\n```js\n{\n  \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\",\n  \"version\": 1,\n  \"newProjectRoot\": \"projects\",\n  \"projects\": {\n    \"ng-18-playground\": {\n      \"projectType\": \"application\",\n      \"schematics\": {\n        \"@schematics/angular:component\": {\n          \"changeDetection\": \"OnPush\"\n        }\n      }\n      \n      ...\n    }\n  }\n}\n```\n\n2. OnPush 변경 감지를 강제하는 ESLint 규칙을 추가하십시오:\n\n```js\n// @ts-check\nconst eslint = require(\"@eslint/js\");\nconst tseslint = require(\"typescript-eslint\");\nconst angular = require(\"angular-eslint\");\n\nmodule.exports = tseslint.config(\n  {\n    files: [\"**/*.ts\"],\n    extends: [\n      eslint.configs.recommended,\n      ...tseslint.configs.recommended,\n      ...tseslint.configs.stylistic,\n      ...angular.configs.tsRecommended,\n    ],\n    processor: angular.processInlineTemplates,\n    rules: {\n      \"@angular-eslint/prefer-on-push-component-change-detection\": [\"warn|error\"],\n    },\n  }\n  ...\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNx를 사용하면 특정 프로젝트에 대해 규칙을 설정할 수 있습니다. 이 기능을 사용하면 새 프로젝트에 대해 오류로 심각도 수준을 지정할 수 있습니다. 기존 프로젝트는 리팩터링을 통해 존이 없는 변경 감지로 준수할 때까지 경고를 유지할 수 있습니다.\n\n존이 없는 변경 감지는 실험적인 기능이지만, 새 기능을 개발할 때 고려해 두는 것이 좋습니다. 이렇게 하면 나중에 존.js 없이 쉽게 theworld로 전환할 수 있습니다.\n\n제 블로그 글이 마음에 들었으면 좋겠어요. 읽어 주셔서 감사합니다! 🙂","ogImage":{"url":"/assets/img/2024-06-22-HowtogetreadyforzonelessfutureinAngular_0.png"},"coverImage":"/assets/img/2024-06-22-HowtogetreadyforzonelessfutureinAngular_0.png","tag":["Tech"],"readingTime":2},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-22-HowtogetreadyforzonelessfutureinAngular_0.png\"\u003e\n\u003cp\u003eAngular 18은 zone.js를 기반으로 한 기존 버전보다 더 효율적인 zoneless change detection을 실험적으로 지원합니다.\u003c/p\u003e\n\u003cp\u003e이 기능에 대한 자세한 내용은 아래 링크를 참조하세요 👇\u003c/p\u003e\n\u003cp\u003e새 프로젝트를 시작하면 zoneless 옵션을 쉽게 선택할 수 있습니다. 하지만 기존 애플리케이션에 이 기능을 통합하는 것은 간단하지 않을 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 블로그 포스트에서는 Angular의 무존재(zonless) 미래에 대비할 수 있는 두 가지 간단한 단계에 대해 이야기하겠습니다.\u003c/p\u003e\n\u003cp\u003e무존재 변경 감지(zoneless change detection)를 수용하는 새로운 기능을 생성하는 프로세스를 수립하는 것이 바람직합니다. 상세한 설명이 필요한 경우가 있겠지만, 코드가 OnPush 변경 감지 전략과 함께 작동한다면 무존재 변경 감지와 호환될 것으로 가정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e자세한 내용은 여기에서 확인하실 수 있습니다 👇\u003c/p\u003e\n\u003cp\u003e이 패턴을 구현하려면 두 가지 조치를 취할 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eangular.json (nx.json) 파일에서 기본 변경 감지 전략을 수정하십시오:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\"$schema\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"./node_modules/@angular/cli/lib/config/schema.json\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"version\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"newProjectRoot\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"projects\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"projects\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"ng-18-playground\"\u003c/span\u003e: {\n      \u003cspan class=\"hljs-string\"\u003e\"projectType\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"application\"\u003c/span\u003e,\n      \u003cspan class=\"hljs-string\"\u003e\"schematics\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"@schematics/angular:component\"\u003c/span\u003e: {\n          \u003cspan class=\"hljs-string\"\u003e\"changeDetection\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"OnPush\"\u003c/span\u003e\n        }\n      }\n      \n      ...\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eOnPush 변경 감지를 강제하는 ESLint 규칙을 추가하십시오:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// @ts-check\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e eslint = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"@eslint/js\"\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tseslint = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"typescript-eslint\"\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e angular = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"angular-eslint\"\u003c/span\u003e);\n\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = tseslint.\u003cspan class=\"hljs-title function_\"\u003econfig\u003c/span\u003e(\n  {\n    \u003cspan class=\"hljs-attr\"\u003efiles\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"**/*.ts\"\u003c/span\u003e],\n    \u003cspan class=\"hljs-attr\"\u003eextends\u003c/span\u003e: [\n      eslint.\u003cspan class=\"hljs-property\"\u003econfigs\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erecommended\u003c/span\u003e,\n      ...tseslint.\u003cspan class=\"hljs-property\"\u003econfigs\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erecommended\u003c/span\u003e,\n      ...tseslint.\u003cspan class=\"hljs-property\"\u003econfigs\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estylistic\u003c/span\u003e,\n      ...angular.\u003cspan class=\"hljs-property\"\u003econfigs\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etsRecommended\u003c/span\u003e,\n    ],\n    \u003cspan class=\"hljs-attr\"\u003eprocessor\u003c/span\u003e: angular.\u003cspan class=\"hljs-property\"\u003eprocessInlineTemplates\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003erules\u003c/span\u003e: {\n      \u003cspan class=\"hljs-string\"\u003e\"@angular-eslint/prefer-on-push-component-change-detection\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"warn|error\"\u003c/span\u003e],\n    },\n  }\n  ...\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eNx를 사용하면 특정 프로젝트에 대해 규칙을 설정할 수 있습니다. 이 기능을 사용하면 새 프로젝트에 대해 오류로 심각도 수준을 지정할 수 있습니다. 기존 프로젝트는 리팩터링을 통해 존이 없는 변경 감지로 준수할 때까지 경고를 유지할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e존이 없는 변경 감지는 실험적인 기능이지만, 새 기능을 개발할 때 고려해 두는 것이 좋습니다. 이렇게 하면 나중에 존.js 없이 쉽게 theworld로 전환할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e제 블로그 글이 마음에 들었으면 좋겠어요. 읽어 주셔서 감사합니다! 🙂\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-HowtogetreadyforzonelessfutureinAngular"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>