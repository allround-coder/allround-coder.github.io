<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>웹 워커 관련 프론트엔드 면접 질문 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-02-WebWorkersInterviewQuestions" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="웹 워커 관련 프론트엔드 면접 질문 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="웹 워커 관련 프론트엔드 면접 질문 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-02-WebWorkersInterviewQuestions_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-02-WebWorkersInterviewQuestions" data-gatsby-head="true"/><meta name="twitter:title" content="웹 워커 관련 프론트엔드 면접 질문 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-02-WebWorkersInterviewQuestions_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-02 00:08" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-742e6c91a18eb160.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">웹 워커 관련 프론트엔드 면접 질문</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="웹 워커 관련 프론트엔드 면접 질문" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 2, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-02-WebWorkersInterviewQuestions&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>주제 안내:</p>
<h1>웹 워커:</h1>
<p>웹 워커는 브라우저 기능의 일부입니다. 현재 페이지의 백그라운드에서 생성될 수 있는 실제 OS 스레드로, 복잡하고 자원 집약적인 작업을 수행할 수 있습니다.</p>
<p>서버에서 대량의 데이터를 가져와야 하거나 UI에 복잡한 렌더링이 필요한 경우를 상상해보세요. 이를 직접 웹페이지에서 처리한다면 페이지가 더 부드럽지 않을 수 있고 UI에 영향을 줄 수 있습니다.</p>
<p>위 웹 워커를 사용하여 이 문제를 완화할 수 있어요. 웹 워커는 웹 워커라 불리는 쓰레드를 만들고, 그 웹 워커가 복잡한 작업을 처리하도록 할 수 있어요.</p>
<p>웹 워커와 간단하게 소통할 수 있으며, 이를 통해 워커와 UI 간에 데이터를 주고받을 수 있어요.</p>
<p>아래는 웹 워커의 주요 기능 몇 가지에요:</p>
<ul>
<li>웹 워커는 쓰레드 기반의 JavaScript입니다.</li>
<li>웹 워커는 더 많은 공간과 CPU 시간을 요구해요.</li>
<li>웹 워커는 웹사이트의 속도를 향상시켜 줘요.</li>
<li>웹 워커는 클라이언트 측에서 코드를 실행해요 (서버 측이 아니에요).</li>
<li>웹 워커 쓰레드는 postMessage() 콜백 메서드를 사용하여 서로 소통해요.</li>
</ul>
<p>웹 워커의 일반적인 예시는 다음과 같습니다:</p>
<ul>
<li>주식 가격, 실시간 활성 사용자 등의 실시간 데이터를 표시하는 대시보드 페이지</li>
<li>서버에서 큰 파일을 가져오는 작업</li>
<li>자동 저장 기능</li>
</ul>
<h2>웹 워커 생성 구문</h2>
<pre><code class="hljs language-js">웹 워커 생성을 위해 사용됩니다
worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">"webWorker.js"</span>);
</code></pre>
<h2>웹 워커 종료하는 구문</h2>
<pre><code class="hljs language-js"><span class="hljs-comment">// 웹 워커를 종료하는 데 사용됩니다.</span>
worker.<span class="hljs-title function_">terminate</span>();
</code></pre>
<pre><code class="hljs language-js">&#x3C;!<span class="hljs-variable constant_">DOCTYPE</span> html>
&#x3C;html lang="en">
&#x3C;head>
  &#x3C;meta charset="UTF-8">
  &#x3C;meta name="viewport" content="width=device-width, initial-scale=1.0">
  &#x3C;title>웹 워커 예제&#x3C;/title>
&#x3C;/head>
&#x3C;body>
  &#x3C;h1>웹 워커 예제&#x3C;/h1>
  &#x3C;button onclick="startWorker()">워커 시작&#x3C;/button>
  &#x3C;p id="result">&#x3C;/p>

  &#x3C;script>
    function startWorker() {
      const worker = new Worker('worker.js');
      
      worker.onmessage = function(event) {
        document.getElementById('result').textContent = event.data;
      };
    }
  &#x3C;/script>
&#x3C;/body>
&#x3C;/html>
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doHeavyTask</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 무거운 CPU 작업을 시뮬레이션합니다.</span>
  <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">1000000000</span>; i++) {
    result += i;
  }
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-comment">// 메인 스레드로부터 메시지를 수신합니다.</span>
onmessage = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-keyword">const</span> heavyResult = <span class="hljs-title function_">doHeavyTask</span>();
  <span class="hljs-title function_">postMessage</span>(heavyResult); <span class="hljs-comment">// 결과를 메인 스레드로 다시 보냅니다.</span>
};
</code></pre>
<h2>React 예제, WebWorker Websocket 예제</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Homepage</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">const</span> [worker, setWorker] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [res, setRes] = <span class="hljs-title function_">useState</span>([]);
  <span class="hljs-keyword">const</span> [log, setLog] = <span class="hljs-title function_">useState</span>([]);
  <span class="hljs-keyword">const</span> [buttonState, setButtonState] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">hanldeStartConnection</span> = (<span class="hljs-params"></span>) => {
    <span class="hljs-comment">// 워커에 메시지 보내기 [postMessage]</span>
    worker.<span class="hljs-title function_">postMessage</span>({
      <span class="hljs-attr">connectionStatus</span>: <span class="hljs-string">"init"</span>,
    });
  };

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleStopConnection</span> = (<span class="hljs-params"></span>) => {
    worker.<span class="hljs-title function_">postMessage</span>({
      <span class="hljs-attr">connectionStatus</span>: <span class="hljs-string">"stop"</span>,
    });
  };
 
 <span class="hljs-comment">//UseEffect1</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> myWorker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(
      <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">"../workers/main.worker.js"</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>)
    ); <span class="hljs-comment">//NEW SYNTAX</span>
    <span class="hljs-title function_">setWorker</span>(myWorker);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> {
      myWorker.<span class="hljs-title function_">terminate</span>();
    };
  }, []);

 <span class="hljs-comment">//UseEffect2</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">if</span> (worker) {
      worker.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> e.<span class="hljs-property">data</span> === <span class="hljs-string">"string"</span>) {
          <span class="hljs-keyword">if</span>(e.<span class="hljs-property">data</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">"["</span>)){
            <span class="hljs-title function_">setLog</span>(<span class="hljs-function">(<span class="hljs-params">preLogs</span>) =></span> [...preLogs, e.<span class="hljs-property">data</span>]);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">setRes</span>(<span class="hljs-function">(<span class="hljs-params">prevRes</span>) =></span> [...prevRes, { <span class="hljs-attr">stockPrice</span>: e.<span class="hljs-property">data</span> }]);
          }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> e.<span class="hljs-property">data</span> === <span class="hljs-string">"object"</span>) {
          <span class="hljs-title function_">setButtonState</span>(e.<span class="hljs-property">data</span>.<span class="hljs-property">disableStartButton</span>);
        }
      };
    }
  }, [worker]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"stats"</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"control-panel"</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">h3</span>></span>WebWorker Websocket 예제<span class="hljs-tag">&#x3C;/<span class="hljs-name">h3</span>></span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span>
            <span class="hljs-attr">id</span>=<span class="hljs-string">"start-connection"</span>
            <span class="hljs-attr">onClick</span>=<span class="hljs-string">{hanldeStartConnection}</span>
            <span class="hljs-attr">disabled</span>=<span class="hljs-string">{!worker</span> || <span class="hljs-attr">buttonState</span>}
          ></span>
            연결 시작
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
          <span class="hljs-symbol">&#x26;nbsp;</span>
          <span class="hljs-tag">&#x3C;<span class="hljs-name">button</span>
            <span class="hljs-attr">id</span>=<span class="hljs-string">"stop-connection"</span>
            <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleStopConnection}</span>
            <span class="hljs-attr">disabled</span>=<span class="hljs-string">{!buttonState}</span>
          ></span>
            연결 중지
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">LineChartComponent</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{res}</span> /></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">Logger</span> <span class="hljs-attr">logs</span>=<span class="hljs-string">{log}/</span>></span>
    <span class="hljs-tag">&#x3C;/></span></span>
  );
};
</code></pre>
<h1>웹 워커의 종류</h1>
<p>웹 워커는 웹 페이지의 메인 스레드와 별도로 백그라운드에서 스크립트를 실행하는 방법을 제공합니다. 사용자 인터페이스를 방해하지 않고 작업을 수행할 수 있도록 합니다. 여기에는 두 가지 주요 웹 워커의 종류가 있습니다:</p>
<h2>1. 전용 워커:</h2>
<ul>
<li>전용 워커는 생성한 스크립트에 의해서만 접근할 수 있습니다.</li>
<li>메인 스레드와 격리된 자체 스레드에서 실행됩니다.</li>
<li>웹 페이지의 반응성에 영향을 미치지 않으면서 무거운 계산이나 시간이 오래 걸리는 작업을 처리해야 하는 상황에 유용합니다.</li>
<li>전용 워커는 일반적으로 단일 스크립트 내에서 사용됩니다.</li>
</ul>
<h2>2. 공유 워커:</h2>
<ul>
<li>공유 워커는 동일한 도메인에 속하는 여러 창, 아이프레임 또는 다른 컨텍스트에서 실행 중인 여러 스크립트에서 접근할 수 있습니다.</li>
<li>데이터를 공유하거나 응용 프로그램의 다른 부분 간의 작업을 조정해야 하는 상황에 공유 워커가 설계되었습니다.</li>
<li>서로 다른 탭이나 프레임 간의 통신과 협업을 제공합니다.</li>
<li>공유 워커는 더 다양하며 여러 스크립트가 동시에 활용할 수 있습니다.</li>
</ul>
<h1>인터뷰 질문:</h1>
<h2>웹 워커(Web Worker)란 무엇인가요?</h2>
<ul>
<li>웹 워커(Web Worker)는 웹 애플리케이션의 주 실행 스레드와 별도의 백그라운드 스레드에서 스크립트를 실행할 수 있는 JavaScript 기능입니다.</li>
</ul>
<h2>웹 워커(Web Worker)가 해결하는 문제는 무엇인가요?</h2>
<ul>
<li>웹 워커는 웹 애플리케이션의 응답성을 향상시키기 위해 주 스레드에서 작업을 오프로드하는 데 도움이 됩니다. 그들은 UI를 차단하지 않고 동시에 실행을 가능하게 합니다.</li>
</ul>
<h2>웹 워커를 어떻게 생성하나요?</h2>
<ul>
<li>웹 워커는 주 자바스크립트 코드에서 Worker 개체를 인스턴스화하고 워커 스크립트의 URL을 인수로 제공하여 생성합니다.</li>
</ul>
<h2>웹 워커와 주 스레드 간의 통신 메커니즘은 무엇인가요?</h2>
<ul>
<li>웹 워커는 postMessage() 메서드를 사용하여 주 스레드와 통신하고 onmessage 이벤트 핸들러를 통해 메시지를 수신합니다.</li>
</ul>
<h3>웹 워커와 주 스레드 간에 전송할 수 있는 데이터 유형은 무엇인가요?</h3>
<ul>
<li>전송할 수 있는 데이터 유형에는 JSON 객체, ArrayBuffer, ArrayBufferView, 파일/블롭 객체 및 기타 구조화된 복제 가능한 객체가 포함됩니다.</li>
</ul>
<h3>웹 워커의 제한사항은 무엇인가요?</h3>
<ul>
<li>웹 워커는 DOM, window, document와 같은 특정 API에 직접 액세스할 수 없으며 동기 XHR 요청을 수행할 수 없습니다. 또한, 동일 출처 정책으로 인해 다른 출처의 리소스에 액세스하는 데 제한이 있습니다.</li>
</ul>
<p><strong>웹 워커를 종료하는 방법은 무엇인가요?</strong></p>
<ul>
<li>메인 스레드에서 Worker 객체의 terminate() 메서드를 호출하여 웹 워커를 종료할 수 있습니다.</li>
</ul>
<p><strong>웹 워커에는 어떤 종류가 있나요?</strong></p>
<ul>
<li>웹 워커에는 Dedicated Workers와 Shared Workers 두 가지 유형이 있어요. Dedicated Workers는 하나의 스크립트에 특화되어 있지만, Shared Workers는 여러 스크립트에서 공유할 수 있어요.</li>
</ul>
<h2>웹 워커의 일반적인 사용 사례는 무엇인가요?</h2>
<ul>
<li>웹 워커는 이미지 처리, 오디오/비디오 처리, 데이터 구문 분석 및 암호화/해독과 같은 CPU 집약적 작업에 주로 사용돼요. 또한 서버에서 데이터를 가져오거나 WebSocket을 통해 수신한 데이터를 처리하는 백그라운드 작업에도 사용할 수 있어요.</li>
</ul>
<h2>웹 워커에서 오류를 처리하는 방법은 무엇인가요?</h2>
<ul>
<li>웹 워커 내에서 발생하는 오류는 onerror 이벤트 핸들러를 사용하여 캡처할 수 있습니다. 또한 postMessage()를 사용하여 메시지를 메인 스레드로 보내고 메인 스레드에서 처리할 수 있습니다.</li>
</ul>
<h2>참고 문서:</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" rel="nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers</a></li>
<li><a href="https://www.freecodecamp.org/news/how-webworkers-work-in-javascript-with-example/" rel="nofollow" target="_blank">https://www.freecodecamp.org/news/how-webworkers-work-in-javascript-with-example/</a></li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"웹 워커 관련 프론트엔드 면접 질문","description":"","date":"2024-05-02 00:08","slug":"2024-05-02-WebWorkersInterviewQuestions","content":"\n\n주제 안내:\n\n# 웹 워커:\n\n웹 워커는 브라우저 기능의 일부입니다. 현재 페이지의 백그라운드에서 생성될 수 있는 실제 OS 스레드로, 복잡하고 자원 집약적인 작업을 수행할 수 있습니다.\n\n서버에서 대량의 데이터를 가져와야 하거나 UI에 복잡한 렌더링이 필요한 경우를 상상해보세요. 이를 직접 웹페이지에서 처리한다면 페이지가 더 부드럽지 않을 수 있고 UI에 영향을 줄 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 웹 워커를 사용하여 이 문제를 완화할 수 있어요. 웹 워커는 웹 워커라 불리는 쓰레드를 만들고, 그 웹 워커가 복잡한 작업을 처리하도록 할 수 있어요.\n\n웹 워커와 간단하게 소통할 수 있으며, 이를 통해 워커와 UI 간에 데이터를 주고받을 수 있어요.\n\n아래는 웹 워커의 주요 기능 몇 가지에요:\n\n- 웹 워커는 쓰레드 기반의 JavaScript입니다.\n- 웹 워커는 더 많은 공간과 CPU 시간을 요구해요.\n- 웹 워커는 웹사이트의 속도를 향상시켜 줘요.\n- 웹 워커는 클라이언트 측에서 코드를 실행해요 (서버 측이 아니에요).\n- 웹 워커 쓰레드는 postMessage() 콜백 메서드를 사용하여 서로 소통해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 워커의 일반적인 예시는 다음과 같습니다:\n\n- 주식 가격, 실시간 활성 사용자 등의 실시간 데이터를 표시하는 대시보드 페이지\n- 서버에서 큰 파일을 가져오는 작업\n- 자동 저장 기능\n\n## 웹 워커 생성 구문\n\n```js\n웹 워커 생성을 위해 사용됩니다\nworker = new Worker(\"webWorker.js\");\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 웹 워커 종료하는 구문\n\n```js\n// 웹 워커를 종료하는 데 사용됩니다.\nworker.terminate();\n```\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n  \u003cmeta charset=\"UTF-8\"\u003e\n  \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n  \u003ctitle\u003e웹 워커 예제\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n  \u003ch1\u003e웹 워커 예제\u003c/h1\u003e\n  \u003cbutton onclick=\"startWorker()\"\u003e워커 시작\u003c/button\u003e\n  \u003cp id=\"result\"\u003e\u003c/p\u003e\n\n  \u003cscript\u003e\n    function startWorker() {\n      const worker = new Worker('worker.js');\n      \n      worker.onmessage = function(event) {\n        document.getElementById('result').textContent = event.data;\n      };\n    }\n  \u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\n```js\nfunction doHeavyTask() {\n  // 무거운 CPU 작업을 시뮬레이션합니다.\n  let result = 0;\n  for (let i = 0; i \u003c 1000000000; i++) {\n    result += i;\n  }\n  return result;\n}\n\n// 메인 스레드로부터 메시지를 수신합니다.\nonmessage = function(event) {\n  const heavyResult = doHeavyTask();\n  postMessage(heavyResult); // 결과를 메인 스레드로 다시 보냅니다.\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## React 예제, WebWorker Websocket 예제\n\n```js\nconst Homepage = () =\u003e {\n  const [worker, setWorker] = useState(null);\n  const [res, setRes] = useState([]);\n  const [log, setLog] = useState([]);\n  const [buttonState, setButtonState] = useState(false);\n\n  const hanldeStartConnection = () =\u003e {\n    // 워커에 메시지 보내기 [postMessage]\n    worker.postMessage({\n      connectionStatus: \"init\",\n    });\n  };\n\n  const handleStopConnection = () =\u003e {\n    worker.postMessage({\n      connectionStatus: \"stop\",\n    });\n  };\n \n //UseEffect1\n  useEffect(() =\u003e {\n    const myWorker = new Worker(\n      new URL(\"../workers/main.worker.js\", import.meta.url)\n    ); //NEW SYNTAX\n    setWorker(myWorker);\n\n    return () =\u003e {\n      myWorker.terminate();\n    };\n  }, []);\n\n //UseEffect2\n  useEffect(() =\u003e {\n    if (worker) {\n      worker.onmessage = function (e) {\n        if (typeof e.data === \"string\") {\n          if(e.data.includes(\"[\")){\n            setLog((preLogs) =\u003e [...preLogs, e.data]);\n          } else {\n            setRes((prevRes) =\u003e [...prevRes, { stockPrice: e.data }]);\n          }\n        }\n\n        if (typeof e.data === \"object\") {\n          setButtonState(e.data.disableStartButton);\n        }\n      };\n    }\n  }, [worker]);\n\n  return (\n    \u003c\u003e\n      \u003cdiv className=\"stats\"\u003e\n        \u003cdiv className=\"control-panel\"\u003e\n          \u003ch3\u003eWebWorker Websocket 예제\u003c/h3\u003e\n          \u003cbutton\n            id=\"start-connection\"\n            onClick={hanldeStartConnection}\n            disabled={!worker || buttonState}\n          \u003e\n            연결 시작\n          \u003c/button\u003e\n          \u0026nbsp;\n          \u003cbutton\n            id=\"stop-connection\"\n            onClick={handleStopConnection}\n            disabled={!buttonState}\n          \u003e\n            연결 중지\n          \u003c/button\u003e\n        \u003c/div\u003e\n        \u003cLineChartComponent data={res} /\u003e\n      \u003c/div\u003e\n      \u003cLogger logs={log}/\u003e\n    \u003c/\u003e\n  );\n};\n```\n\n# 웹 워커의 종류\n\n웹 워커는 웹 페이지의 메인 스레드와 별도로 백그라운드에서 스크립트를 실행하는 방법을 제공합니다. 사용자 인터페이스를 방해하지 않고 작업을 수행할 수 있도록 합니다. 여기에는 두 가지 주요 웹 워커의 종류가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 전용 워커:\n\n- 전용 워커는 생성한 스크립트에 의해서만 접근할 수 있습니다.\n- 메인 스레드와 격리된 자체 스레드에서 실행됩니다.\n- 웹 페이지의 반응성에 영향을 미치지 않으면서 무거운 계산이나 시간이 오래 걸리는 작업을 처리해야 하는 상황에 유용합니다.\n- 전용 워커는 일반적으로 단일 스크립트 내에서 사용됩니다.\n\n## 2. 공유 워커:\n\n- 공유 워커는 동일한 도메인에 속하는 여러 창, 아이프레임 또는 다른 컨텍스트에서 실행 중인 여러 스크립트에서 접근할 수 있습니다.\n- 데이터를 공유하거나 응용 프로그램의 다른 부분 간의 작업을 조정해야 하는 상황에 공유 워커가 설계되었습니다.\n- 서로 다른 탭이나 프레임 간의 통신과 협업을 제공합니다.\n- 공유 워커는 더 다양하며 여러 스크립트가 동시에 활용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 인터뷰 질문:\n\n## 웹 워커(Web Worker)란 무엇인가요?\n\n- 웹 워커(Web Worker)는 웹 애플리케이션의 주 실행 스레드와 별도의 백그라운드 스레드에서 스크립트를 실행할 수 있는 JavaScript 기능입니다.\n\n## 웹 워커(Web Worker)가 해결하는 문제는 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 웹 워커는 웹 애플리케이션의 응답성을 향상시키기 위해 주 스레드에서 작업을 오프로드하는 데 도움이 됩니다. 그들은 UI를 차단하지 않고 동시에 실행을 가능하게 합니다.\n\n## 웹 워커를 어떻게 생성하나요?\n\n- 웹 워커는 주 자바스크립트 코드에서 Worker 개체를 인스턴스화하고 워커 스크립트의 URL을 인수로 제공하여 생성합니다.\n\n## 웹 워커와 주 스레드 간의 통신 메커니즘은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 웹 워커는 postMessage() 메서드를 사용하여 주 스레드와 통신하고 onmessage 이벤트 핸들러를 통해 메시지를 수신합니다.\n\n### 웹 워커와 주 스레드 간에 전송할 수 있는 데이터 유형은 무엇인가요?\n\n- 전송할 수 있는 데이터 유형에는 JSON 객체, ArrayBuffer, ArrayBufferView, 파일/블롭 객체 및 기타 구조화된 복제 가능한 객체가 포함됩니다.\n\n### 웹 워커의 제한사항은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 웹 워커는 DOM, window, document와 같은 특정 API에 직접 액세스할 수 없으며 동기 XHR 요청을 수행할 수 없습니다. 또한, 동일 출처 정책으로 인해 다른 출처의 리소스에 액세스하는 데 제한이 있습니다.\n\n**웹 워커를 종료하는 방법은 무엇인가요?**\n\n- 메인 스레드에서 Worker 객체의 terminate() 메서드를 호출하여 웹 워커를 종료할 수 있습니다.\n\n**웹 워커에는 어떤 종류가 있나요?**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 웹 워커에는 Dedicated Workers와 Shared Workers 두 가지 유형이 있어요. Dedicated Workers는 하나의 스크립트에 특화되어 있지만, Shared Workers는 여러 스크립트에서 공유할 수 있어요.\n\n## 웹 워커의 일반적인 사용 사례는 무엇인가요?\n\n- 웹 워커는 이미지 처리, 오디오/비디오 처리, 데이터 구문 분석 및 암호화/해독과 같은 CPU 집약적 작업에 주로 사용돼요. 또한 서버에서 데이터를 가져오거나 WebSocket을 통해 수신한 데이터를 처리하는 백그라운드 작업에도 사용할 수 있어요.\n\n## 웹 워커에서 오류를 처리하는 방법은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 웹 워커 내에서 발생하는 오류는 onerror 이벤트 핸들러를 사용하여 캡처할 수 있습니다. 또한 postMessage()를 사용하여 메시지를 메인 스레드로 보내고 메인 스레드에서 처리할 수 있습니다.\n\n## 참고 문서:\n\n- https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\n- https://www.freecodecamp.org/news/how-webworkers-work-in-javascript-with-example/","ogImage":{"url":"/assets/img/2024-05-02-WebWorkersInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-05-02-WebWorkersInterviewQuestions_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e주제 안내:\u003c/p\u003e\n\u003ch1\u003e웹 워커:\u003c/h1\u003e\n\u003cp\u003e웹 워커는 브라우저 기능의 일부입니다. 현재 페이지의 백그라운드에서 생성될 수 있는 실제 OS 스레드로, 복잡하고 자원 집약적인 작업을 수행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e서버에서 대량의 데이터를 가져와야 하거나 UI에 복잡한 렌더링이 필요한 경우를 상상해보세요. 이를 직접 웹페이지에서 처리한다면 페이지가 더 부드럽지 않을 수 있고 UI에 영향을 줄 수 있습니다.\u003c/p\u003e\n\u003cp\u003e위 웹 워커를 사용하여 이 문제를 완화할 수 있어요. 웹 워커는 웹 워커라 불리는 쓰레드를 만들고, 그 웹 워커가 복잡한 작업을 처리하도록 할 수 있어요.\u003c/p\u003e\n\u003cp\u003e웹 워커와 간단하게 소통할 수 있으며, 이를 통해 워커와 UI 간에 데이터를 주고받을 수 있어요.\u003c/p\u003e\n\u003cp\u003e아래는 웹 워커의 주요 기능 몇 가지에요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e웹 워커는 쓰레드 기반의 JavaScript입니다.\u003c/li\u003e\n\u003cli\u003e웹 워커는 더 많은 공간과 CPU 시간을 요구해요.\u003c/li\u003e\n\u003cli\u003e웹 워커는 웹사이트의 속도를 향상시켜 줘요.\u003c/li\u003e\n\u003cli\u003e웹 워커는 클라이언트 측에서 코드를 실행해요 (서버 측이 아니에요).\u003c/li\u003e\n\u003cli\u003e웹 워커 쓰레드는 postMessage() 콜백 메서드를 사용하여 서로 소통해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e웹 워커의 일반적인 예시는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e주식 가격, 실시간 활성 사용자 등의 실시간 데이터를 표시하는 대시보드 페이지\u003c/li\u003e\n\u003cli\u003e서버에서 큰 파일을 가져오는 작업\u003c/li\u003e\n\u003cli\u003e자동 저장 기능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e웹 워커 생성 구문\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e웹 워커 생성을 위해 사용됩니다\nworker = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"webWorker.js\"\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e웹 워커 종료하는 구문\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 웹 워커를 종료하는 데 사용됩니다.\u003c/span\u003e\nworker.\u003cspan class=\"hljs-title function_\"\u003eterminate\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;!\u003cspan class=\"hljs-variable constant_\"\u003eDOCTYPE\u003c/span\u003e html\u003e\n\u0026#x3C;html lang=\"en\"\u003e\n\u0026#x3C;head\u003e\n  \u0026#x3C;meta charset=\"UTF-8\"\u003e\n  \u0026#x3C;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n  \u0026#x3C;title\u003e웹 워커 예제\u0026#x3C;/title\u003e\n\u0026#x3C;/head\u003e\n\u0026#x3C;body\u003e\n  \u0026#x3C;h1\u003e웹 워커 예제\u0026#x3C;/h1\u003e\n  \u0026#x3C;button onclick=\"startWorker()\"\u003e워커 시작\u0026#x3C;/button\u003e\n  \u0026#x3C;p id=\"result\"\u003e\u0026#x3C;/p\u003e\n\n  \u0026#x3C;script\u003e\n    function startWorker() {\n      const worker = new Worker('worker.js');\n      \n      worker.onmessage = function(event) {\n        document.getElementById('result').textContent = event.data;\n      };\n    }\n  \u0026#x3C;/script\u003e\n\u0026#x3C;/body\u003e\n\u0026#x3C;/html\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoHeavyTask\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 무거운 CPU 작업을 시뮬레이션합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e result = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e1000000000\u003c/span\u003e; i++) {\n    result += i;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 메인 스레드로부터 메시지를 수신합니다.\u003c/span\u003e\nonmessage = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e heavyResult = \u003cspan class=\"hljs-title function_\"\u003edoHeavyTask\u003c/span\u003e();\n  \u003cspan class=\"hljs-title function_\"\u003epostMessage\u003c/span\u003e(heavyResult); \u003cspan class=\"hljs-comment\"\u003e// 결과를 메인 스레드로 다시 보냅니다.\u003c/span\u003e\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eReact 예제, WebWorker Websocket 예제\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHomepage\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [worker, setWorker] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [res, setRes] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e([]);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [log, setLog] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e([]);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [buttonState, setButtonState] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehanldeStartConnection\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 워커에 메시지 보내기 [postMessage]\u003c/span\u003e\n    worker.\u003cspan class=\"hljs-title function_\"\u003epostMessage\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003econnectionStatus\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"init\"\u003c/span\u003e,\n    });\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehandleStopConnection\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    worker.\u003cspan class=\"hljs-title function_\"\u003epostMessage\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003econnectionStatus\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"stop\"\u003c/span\u003e,\n    });\n  };\n \n \u003cspan class=\"hljs-comment\"\u003e//UseEffect1\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myWorker = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWorker\u003c/span\u003e(\n      \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eURL\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"../workers/main.worker.js\"\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emeta\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e)\n    ); \u003cspan class=\"hljs-comment\"\u003e//NEW SYNTAX\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003esetWorker\u003c/span\u003e(myWorker);\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n      myWorker.\u003cspan class=\"hljs-title function_\"\u003eterminate\u003c/span\u003e();\n    };\n  }, []);\n\n \u003cspan class=\"hljs-comment\"\u003e//UseEffect2\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (worker) {\n      worker.\u003cspan class=\"hljs-property\"\u003eonmessage\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e) {\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eincludes\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"[\"\u003c/span\u003e)){\n            \u003cspan class=\"hljs-title function_\"\u003esetLog\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003epreLogs\u003c/span\u003e) =\u003e\u003c/span\u003e [...preLogs, e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e]);\n          } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-title function_\"\u003esetRes\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eprevRes\u003c/span\u003e) =\u003e\u003c/span\u003e [...prevRes, { \u003cspan class=\"hljs-attr\"\u003estockPrice\u003c/span\u003e: e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e }]);\n          }\n        }\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\"object\"\u003c/span\u003e) {\n          \u003cspan class=\"hljs-title function_\"\u003esetButtonState\u003c/span\u003e(e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edisableStartButton\u003c/span\u003e);\n        }\n      };\n    }\n  }, [worker]);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"stats\"\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"control-panel\"\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh3\u003c/span\u003e\u003e\u003c/span\u003eWebWorker Websocket 예제\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh3\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"start-connection\"\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{hanldeStartConnection}\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003edisabled\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{!worker\u003c/span\u003e || \u003cspan class=\"hljs-attr\"\u003ebuttonState\u003c/span\u003e}\n          \u003e\u003c/span\u003e\n            연결 시작\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-symbol\"\u003e\u0026#x26;nbsp;\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"stop-connection\"\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleStopConnection}\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003edisabled\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{!buttonState}\u003c/span\u003e\n          \u003e\u003c/span\u003e\n            연결 중지\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eLineChartComponent\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{res}\u003c/span\u003e /\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eLogger\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003elogs\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{log}/\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e웹 워커의 종류\u003c/h1\u003e\n\u003cp\u003e웹 워커는 웹 페이지의 메인 스레드와 별도로 백그라운드에서 스크립트를 실행하는 방법을 제공합니다. 사용자 인터페이스를 방해하지 않고 작업을 수행할 수 있도록 합니다. 여기에는 두 가지 주요 웹 워커의 종류가 있습니다:\u003c/p\u003e\n\u003ch2\u003e1. 전용 워커:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e전용 워커는 생성한 스크립트에 의해서만 접근할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e메인 스레드와 격리된 자체 스레드에서 실행됩니다.\u003c/li\u003e\n\u003cli\u003e웹 페이지의 반응성에 영향을 미치지 않으면서 무거운 계산이나 시간이 오래 걸리는 작업을 처리해야 하는 상황에 유용합니다.\u003c/li\u003e\n\u003cli\u003e전용 워커는 일반적으로 단일 스크립트 내에서 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e2. 공유 워커:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e공유 워커는 동일한 도메인에 속하는 여러 창, 아이프레임 또는 다른 컨텍스트에서 실행 중인 여러 스크립트에서 접근할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e데이터를 공유하거나 응용 프로그램의 다른 부분 간의 작업을 조정해야 하는 상황에 공유 워커가 설계되었습니다.\u003c/li\u003e\n\u003cli\u003e서로 다른 탭이나 프레임 간의 통신과 협업을 제공합니다.\u003c/li\u003e\n\u003cli\u003e공유 워커는 더 다양하며 여러 스크립트가 동시에 활용할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e인터뷰 질문:\u003c/h1\u003e\n\u003ch2\u003e웹 워커(Web Worker)란 무엇인가요?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e웹 워커(Web Worker)는 웹 애플리케이션의 주 실행 스레드와 별도의 백그라운드 스레드에서 스크립트를 실행할 수 있는 JavaScript 기능입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e웹 워커(Web Worker)가 해결하는 문제는 무엇인가요?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e웹 워커는 웹 애플리케이션의 응답성을 향상시키기 위해 주 스레드에서 작업을 오프로드하는 데 도움이 됩니다. 그들은 UI를 차단하지 않고 동시에 실행을 가능하게 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e웹 워커를 어떻게 생성하나요?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e웹 워커는 주 자바스크립트 코드에서 Worker 개체를 인스턴스화하고 워커 스크립트의 URL을 인수로 제공하여 생성합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e웹 워커와 주 스레드 간의 통신 메커니즘은 무엇인가요?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e웹 워커는 postMessage() 메서드를 사용하여 주 스레드와 통신하고 onmessage 이벤트 핸들러를 통해 메시지를 수신합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e웹 워커와 주 스레드 간에 전송할 수 있는 데이터 유형은 무엇인가요?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e전송할 수 있는 데이터 유형에는 JSON 객체, ArrayBuffer, ArrayBufferView, 파일/블롭 객체 및 기타 구조화된 복제 가능한 객체가 포함됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e웹 워커의 제한사항은 무엇인가요?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e웹 워커는 DOM, window, document와 같은 특정 API에 직접 액세스할 수 없으며 동기 XHR 요청을 수행할 수 없습니다. 또한, 동일 출처 정책으로 인해 다른 출처의 리소스에 액세스하는 데 제한이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e웹 워커를 종료하는 방법은 무엇인가요?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e메인 스레드에서 Worker 객체의 terminate() 메서드를 호출하여 웹 워커를 종료할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e웹 워커에는 어떤 종류가 있나요?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e웹 워커에는 Dedicated Workers와 Shared Workers 두 가지 유형이 있어요. Dedicated Workers는 하나의 스크립트에 특화되어 있지만, Shared Workers는 여러 스크립트에서 공유할 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e웹 워커의 일반적인 사용 사례는 무엇인가요?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e웹 워커는 이미지 처리, 오디오/비디오 처리, 데이터 구문 분석 및 암호화/해독과 같은 CPU 집약적 작업에 주로 사용돼요. 또한 서버에서 데이터를 가져오거나 WebSocket을 통해 수신한 데이터를 처리하는 백그라운드 작업에도 사용할 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e웹 워커에서 오류를 처리하는 방법은 무엇인가요?\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e웹 워커 내에서 발생하는 오류는 onerror 이벤트 핸들러를 사용하여 캡처할 수 있습니다. 또한 postMessage()를 사용하여 메시지를 메인 스레드로 보내고 메인 스레드에서 처리할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e참고 문서:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.freecodecamp.org/news/how-webworkers-work-in-javascript-with-example/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.freecodecamp.org/news/how-webworkers-work-in-javascript-with-example/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-02-WebWorkersInterviewQuestions"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>