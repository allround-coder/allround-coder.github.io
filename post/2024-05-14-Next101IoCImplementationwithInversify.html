<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>다음 시리즈 101 Inversify를 활용한 IoC 구현 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-Next101IoCImplementationwithInversify" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="다음 시리즈 101 Inversify를 활용한 IoC 구현 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="다음 시리즈 101 Inversify를 활용한 IoC 구현 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-Next101IoCImplementationwithInversify" data-gatsby-head="true"/><meta name="twitter:title" content="다음 시리즈 101 Inversify를 활용한 IoC 구현 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 10:26" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_buildManifest.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">다음 시리즈 101 Inversify를 활용한 IoC 구현</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="다음 시리즈 101 Inversify를 활용한 IoC 구현" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-Next101IoCImplementationwithInversify&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>Typescript IoC를 Next 14에 Inversify와 함께 올바르게 구현하는 방법을 배우세요.</p>
<p><img src="/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png" alt="image"/></p>
<p>IoC(Inversion of Control)는 객체의 동작 제어가 뒤바뀌거나 객체 외부로 이동되는 디자인 패턴입니다. 이는 소프트웨어 응용 프로그램 내 객체의 흐름을 관리하는 데 도움이 됩니다.</p>
<p>제어가 역전되고 컨테이너가 의존성을 관리하는 책임을 맡아 모듈성, 유연성 및 테스트 용이성을 높이게 됩니다.</p>
<p>아래는 <a href="https://www.markdownguide.org/cheat-sheet/">공식 줄임말(Markdown)</a> 형식으로 업데이트한 내용입니다.</p>
<p><img src="/assets/img/2024-05-14-Next101IoCImplementationwithInversify_1.png" alt="이미지"/></p>
<p>의존성 주입에 익숙하다면, IoC 디자인을 구현하는 기술 중 하나입니다.</p>
<p>이 패턴은 단순히 &quot;너가 객체를 만들지 마세요. 제가 그것을 제공할게요.&quot;라고 말합니다.</p>
<p><img src="/assets/img/2024-05-14-Next101IoCImplementationwithInversify_2.png" alt="이미지"/></p>
<h2>그렇지만 왜?</h2>
<p>디자인 패턴? 또 다시요? 진짜로, 이걸로 충분히 지쳤어요 🤣. 처음에 IoC나 의존성 주입이 Next 프레임워크와 진짜 유용하다고 생각하지 않았어요. 보통 사람들도 사용하지 않잖아요, ㅎㅎ.</p>
<p>하지만, 제게 호기심을 자극하는 흥미로운 점이 있어요. 만약 Next에서 Repository 패턴을 사용한다면 어떨까요? Next는 자바스크립트나 타입스크립트로 작성됐다는 걸 알고 있어요. 이는 OOP보다 함수형 접근 방식을 기본으로 사용한다는 데 특별히 신경쓰지 않아도 되겠죠.</p>
<p>저는 보통 백엔드에 더 많이 관심이 있는데, 주로 Rust나 PHP와 같은 OOP 언어로 대화를 나눠요. 제가 매일 사용하는 프레임워크는 Laravel이에요. 물론, 개발한 모든 프로젝트에 Repository 및 Service 패턴을 항상 구현해요.</p>
<p>저장소(repository)는 데이터가 저장되는 곳입니다. 서비스(service)는 데이터를 조작합니다. 간단하죠? 이러한 패턴을 사용하면 API를 통해 데이터를 관리해야 하는 경우나 프로젝트에서 데이터베이스에 직접적으로 접근해야 하는 경우에 견고하고 유지보수하기 쉬운 코드베이스를 개발하는 데 도움이 될 것입니다.</p>
<p>아래의 기사에서 더 많은 정보를 찾아볼 수 있습니다. 관심이 생긴다면 읽어보세요.</p>
<h2>Inversify</h2>
<p>Next 프레임워크에서 IoC를 구현하기 위해 InversifyJS를 사용할 예정입니다.</p>
<p>이것은 TypeScript로 구동되는 JavaScript 및 Node.js 앱을 위한 강력하고 가벼운 제어 반전 컨테이너입니다. 사용하기 쉬운 친절한 API 세트를 갖추고 있어서 최상의 OOP 및 IoC 모범 사례 사용을 촉진할 수 있습니다.</p>
<p>다른 IoC 및 DI 라이브러리 중에서, 제품 환경에서 사용할 수 있는 안정성을 고려하여 이것을 사용하는 것을 선호합니다. 그리고 가벼운 크기인 4 KB만큼만 차지한다는 점도 좋은데요.</p>
<p>Inversify는 다음과 같은 모던 JavaScript 엔진을 필요로 합니다:</p>
<ul>
<li>Reflect metadata</li>
<li>Map</li>
<li>Promise (공급자 주입 사용 시에만 필요)</li>
<li>Proxy (활성화 핸들러 사용 시에만 필요)</li>
</ul>
<h2>시작해봅시다</h2>
<p>일반적으로 Typescript와 App 기반 Router를 사용하여 새 Next 프로젝트를 만든 후에는 프로젝트 디렉토리 구조가 아래와 같이 나타날 것입니다.</p>
<pre><code class="hljs language-js">project
|
+-- app                  -&gt; 애플리케이션 디렉토리
|
+-- components           -&gt; <span class="hljs-variable constant_">UI</span> 컴포넌트 디렉토리
|
+-- public               -&gt; 공용 에셋 디렉토리
|
+-- package.<span class="hljs-property">json</span>
|
+-- tsconfig.<span class="hljs-property">json</span>
|
+-- next-env.<span class="hljs-property">d</span>.<span class="hljs-property">ts</span>
|
+-- next.<span class="hljs-property">config</span>.<span class="hljs-property">mjs</span>
</code></pre>
<p>다음 명령어를 사용하여 필요한 종속성을 설치해주세요.</p>
<pre><code class="hljs language-js">npm install inversify reflect-metadata --save
</code></pre>
<p>Inversify는 TypeScript에서 IoC를 구현하는 데 필요하며, reflect-metadata는 Typescript 파일에서 데코레이터 및 데코레이터 메타데이터를 사용하는 데 필요합니다.</p>
<p>이러한 유형의 정의는 inversify npm 패키지에 포함되어 있습니다. tsconfig.json 파일에 experimentalDecorators, emitDecoratorMetadata, types 및 lib와 같은 몇 가지 컴파일 옵션이 필요합니다.</p>
<pre><code class="hljs language-js">{
    <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
        <span class="hljs-string">&quot;target&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span>,
        <span class="hljs-string">&quot;lib&quot;</span>: [<span class="hljs-string">&quot;es6&quot;</span>, <span class="hljs-string">&quot;dom&quot;</span>],
        <span class="hljs-string">&quot;types&quot;</span>: [<span class="hljs-string">&quot;reflect-metadata&quot;</span>],
        <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,
        <span class="hljs-string">&quot;moduleResolution&quot;</span>: <span class="hljs-string">&quot;node&quot;</span>,
        <span class="hljs-string">&quot;experimentalDecorators&quot;</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-string">&quot;emitDecoratorMetadata&quot;</span>: <span class="hljs-literal">true</span>
    }
}
</code></pre>
<p>시작하려면 Inversify의 컨테이너 및 reflect-metadata에 필요한 파일을 만들어보세요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @/lib/di/container.ts</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;reflect-metadata&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Container</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;inversify&quot;</span>;

<span class="hljs-keyword">const</span> container = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> container;
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// @/lib/di/reflect-metadata.ts</span>

<span class="hljs-string">&quot;use client&quot;</span>;                           <span class="hljs-comment">// -&gt; 클라이언트-컴포넌트로 표시</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;reflect-metadata&quot;</span>;
</code></pre>
<p>다음으로 각 페이지 또는 구성 요소에 대해 기본적으로 SSR(서버 사이드 렌더링)를 사용하지만 reflect-metadata 라이브러리가 클라이언트 측에서 가져와지지 않으면 이상한 오류가 발생할 수 있어요. 그래서 reflect-metadata.ts를 루트 레이아웃 파일에 가져와야 해요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @/app/layout.tsx</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;@/lib/di/reflect-metadata&quot;</span>;    <span class="hljs-comment">// -&gt; reflect-metadata를 import합니다</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">RootLayout</span>(<span class="hljs-params">{
  children,
}: Readonly&lt;{
  children: React.ReactNode;
}&gt;</span>) {
  ...
}
</code></pre>
<p>이제 프로젝트 디렉토리 구조는 다음과 같을 것입니다.</p>
<pre><code class="hljs language-js">project
|
+-- app                            -&gt; 애플리케이션 디렉토리
|
+-- components                     -&gt; <span class="hljs-variable constant_">UI</span> 컴포넌트 디렉토리
|
+-- public                         -&gt; 퍼블릭 에셋 디렉토리
|
+-- lib                            -&gt; 라이브러리 디렉토리
|  |
|  +-- di                          -&gt; 의존성 주입 디렉토리
|     |
|     +-- container.<span class="hljs-property">ts</span>             -&gt; 컨테이너
|     |
|     +-- reflect-metadata.<span class="hljs-property">ts</span>      -&gt; reflect-metadata 클라이언트 컴포넌트
|
+-- package.<span class="hljs-property">json</span>
|
+-- tsconfig.<span class="hljs-property">json</span>
|
+-- next-env.<span class="hljs-property">d</span>.<span class="hljs-property">ts</span>
|
+-- next.<span class="hljs-property">config</span>.<span class="hljs-property">mjs</span>
</code></pre>
<p>그리고 이제 Inversify가 제대로 작동하고 사용할 준비가 되었습니다.</p>
<h2>모델</h2>
<p>이라고 불리는 모델은 당신이 코드에서 사용하는 데이터에 대한 엄격한 타입 정의입니다. &quot;모델&quot; 이라는 이름을 사용하는 이유는 이에 더 익숙하기 때문입니다. 이것을 &quot;타입&quot; 이라고 부르고 프로젝트 루트에 types 라는 디렉토리를 생성할 수도 있습니다.</p>
<p>예를 들어, 내 애플리케이션에서 제품으로 사용될 데이터에 대한 Product 모델을 생성할 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @/models/product.ts</span>

type <span class="hljs-title class_">Product</span> = {
  <span class="hljs-attr">id</span>: string;
  <span class="hljs-attr">image_url</span>: string;
  <span class="hljs-attr">image_blur_data_url</span>: string | <span class="hljs-literal">undefined</span>;
  <span class="hljs-attr">name</span>: string;
  <span class="hljs-attr">price</span>: number;
  <span class="hljs-attr">unit</span>: string;
  <span class="hljs-attr">short_description</span>: string;
  <span class="hljs-attr">description</span>: string;
  <span class="hljs-attr">statement_description</span>: string;
  <span class="hljs-attr">marketing_feature</span>: string;
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Product</span>;
</code></pre>
<h2>저장소</h2>
<p>저장소 클래스는 데이터 저장소(창고)로 사용되어 다른 코드가 이 클래스를 통해 필요한 데이터에 액세스할 수 있도록 합니다. 저장소는 앱에서 단일 진실의 원천입니다.</p>
<p>예를 들어, ProductRepository라는 클래스를 만들어 보겠습니다. 아래 예시는 이전에 생성된 Product 모델의 엄격한 유형을 사용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @/repositories/product-repository.ts</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;reflect-metadata&quot;</span>;
<span class="hljs-keyword">import</span> { injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;inversify&quot;</span>;
<span class="hljs-keyword">import</span> type <span class="hljs-title class_">Product</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/models/product&quot;</span>;

<span class="hljs-comment">// 더미 제품 데이터 목록</span>
<span class="hljs-keyword">const</span> products = [ ... ];

@<span class="hljs-title function_">injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductRepository</span> {
  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getProducts</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Product</span>&gt;&gt; {
    <span class="hljs-keyword">return</span> products.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">product: any</span>) =&gt;</span> product <span class="hljs-keyword">as</span> <span class="hljs-title class_">Product</span>);
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getProduct</span>(<span class="hljs-attr">id</span>: string): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Product</span> | <span class="hljs-literal">undefined</span>&gt; {
    <span class="hljs-keyword">const</span> product = products.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">product: any</span>) =&gt;</span> product.<span class="hljs-property">id</span> === id);

    <span class="hljs-keyword">if</span> (product) {
      <span class="hljs-keyword">return</span> product <span class="hljs-keyword">as</span> <span class="hljs-title class_">Product</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
  }
}
</code></pre>
<p>위 코드는 더미 데이터 목록에서 데이터를 얻는 시뮬레이션입니다.</p>
<p><code>@injectable</code> 데코레이터를 사용해야만 Inversify가 해당 클래스를 다른 인스턴스에 삽입할 수 있다는 것을 인지합니다.</p>
<p>비동기로 코드를 실행해야 하는 경우 <code>async</code>가 일반적으로 필요합니다. 왜냐하면 완료되기까지 시간이 걸리기 때문입니다. 데이터베이스나 외부 API와 상호 작용해야 하는 경우에 이를 사용할 수 있습니다.</p>
<h2>서비스</h2>
<p>레포지토리 클래스를 통해 데이터를 조작하는 서비스 클래스입니다. 필요한 경우 서비스 클래스에서 여러 레포지토리를 사용할 수 있습니다.</p>
<p>이 곳에서 Inversify를 사용한 의존성 주입이 도움이 됩니다. @inject 데코레이터를 통해 서비스 클래스에 필요한 레포지토리를 자동으로 주입할 수 있습니다.</p>
<p>예를 들어, ProductService 클래스를 만들어 보겠습니다. 아래 예시는 이전에 생성된 ProductRepository와 Product 모델의 엄격한 유형을 사용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @/services/product-service.ts</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;reflect-metadata&quot;</span>;
<span class="hljs-keyword">import</span> { inject, injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;inversify&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ProductRepository</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/repositories/product-repository&quot;</span>;
<span class="hljs-keyword">import</span> type <span class="hljs-title class_">Product</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/models/product&quot;</span>;

@<span class="hljs-title function_">injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductService</span> {
  @<span class="hljs-title function_">inject</span>(<span class="hljs-title class_">ProductRepository</span>)
  private <span class="hljs-attr">productRepository</span>: <span class="hljs-title class_">ProductRepository</span>;

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getProducts</span>(<span class="hljs-attr">query</span>: string): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Product</span>&gt;&gt; {
    <span class="hljs-keyword">let</span> products = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">productRepository</span>.<span class="hljs-title function_">getProducts</span>();

    <span class="hljs-keyword">if</span> (query !== <span class="hljs-string">&quot;&quot;</span>) {
      <span class="hljs-keyword">return</span> products.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">product: Product</span>) =&gt;</span>
        product.<span class="hljs-property">name</span>.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">includes</span>(query.<span class="hljs-title function_">toLowerCase</span>()),
      );
    }

    <span class="hljs-keyword">return</span> products;
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getProduct</span>(<span class="hljs-attr">id</span>: string): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Product</span> | <span class="hljs-literal">undefined</span>&gt; {
    <span class="hljs-keyword">const</span> product = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">productRepository</span>.<span class="hljs-title function_">getProduct</span>(id);

    <span class="hljs-keyword">if</span> (product) {
      <span class="hljs-keyword">return</span> product <span class="hljs-keyword">as</span> <span class="hljs-title class_">Product</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
  }
}
</code></pre>
<p>당신의 요구에 따라, 이 서비스 클래스를 사용하여 데이터를 관리하는 데 도움이 되는 추가적인 메서드를 추가할 수 있습니다.</p>
<p>@Injectable 데코레이터를 사용해야만 Inversify가 해당 클래스를 다른 인스턴스에 주입할 수 있다는 것을 알 수 있습니다.</p>
<p>@Inject 데코레이터를 사용해야만 Inversify에 해당 클래스의 필수 인스턴스를 주입하도록 알릴 수 있으므로 이 인스턴스를 사용하여 리포지토리의 메서드에 액세스할 수 있습니다.</p>
<h2>컨테이너</h2>
<p>이제 올바르게 작동하는 IoC를 위해 수행해야 할 마지막 단계입니다.</p>
<p>모델(타입), 리포지토리, 서비스 클래스를 생성한 후, 이러한 클래스를 IoC 컨테이너에 등록해야 합니다. 클래스가 컨테이너에 등록되면 앱의 런타임 중에 필요한 인스턴스에 주입될 수 있습니다.</p>
<p>컨테이너는 항상 앱의 런타임에 이용 가능할 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @/lib/di/container.ts</span>

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;reflect-metadata&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Container</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;inversify&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ProductRepository</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/repositories/product-repository&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ProductService</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/services/product-service&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">UserService</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/services/user-service&quot;</span>;

<span class="hljs-keyword">const</span> container = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Container</span>();

container.<span class="hljs-title function_">bind</span>(<span class="hljs-title class_">ProductRepository</span>).<span class="hljs-title function_">to</span>(<span class="hljs-title class_">ProductRepository</span>).<span class="hljs-title function_">inSingletonScope</span>();

container.<span class="hljs-title function_">bind</span>(<span class="hljs-title class_">ProductService</span>).<span class="hljs-title function_">to</span>(<span class="hljs-title class_">ProductService</span>).<span class="hljs-title function_">inSingletonScope</span>();

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> container;
</code></pre>
<p>클래스 인스턴스에 대한 scope를 지정할 수도 있어요.</p>
<ul>
<li>inTransientScope: 매 의존성 요청마다 새로운 인스턴스를 보장하여 가벼우면서도 일회용 의존성을 유지합니다. 이것이 기본 스코프에요.</li>
<li>inSingletonScope: 의존성에 대한 중앙 접근점을 생성하여 모든 곳에서 동일한 인스턴스를 사용하며 효율성과 상태 관리를 촉진합니다.</li>
<li>inRequestScope: 단일 해결 프로세스 내에서 중복된 객체 생성을 피해 성능 최적화를 제공하지만 HTTP 요청 당 단일 인스턴스를 보장하지는 않아요.</li>
</ul>
<h2>The Hook</h2>
<p>이 단계는 선택 사항으로, 앱의 다른 구성 요소에서 컨테이너에 액세스하는 데 도움을 줍니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @/lib/di/hook.ts</span>

<span class="hljs-keyword">import</span> container <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/lib/di/container&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ProductRepository</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/repositories/product-repository&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ProductService</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/services/product-service&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">UserService</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/services/user-service&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getProductRepository</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">ProductRepository</span> {
  <span class="hljs-keyword">return</span> container.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">ProductRepository</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getProductService</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">ProductService</span> {
  <span class="hljs-keyword">return</span> container.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">ProductService</span>);
}
</code></pre>
<p>마침내, 이제 프로젝트 디렉토리 구조는 다음과 같이 보일 것입니다.</p>
<pre><code class="hljs language-js">project
|
+-- app                            -&gt; 애플리케이션 디렉토리
|
+-- components                     -&gt; <span class="hljs-variable constant_">UI</span> 컴포넌트 디렉토리
|
+-- public                         -&gt; 공용 에셋 디렉토리
|
+-- lib                            -&gt; 라이브러리 디렉토리
|  |
|  +-- di                          -&gt; 의존성 주입 디렉토리
|     |
|     +-- container.<span class="hljs-property">ts</span>             -&gt; 컨테이너
|     |
|     +-- hook.<span class="hljs-property">ts</span>                  -&gt; 컨테이너 후크
|     |
|     +-- reflect-metadata.<span class="hljs-property">ts</span>      -&gt; reflect-metadata 클라이언트 컴포넌트
|
+-- models                         -&gt; 모델 디렉토리
|  |
|  +-- product.<span class="hljs-property">ts</span>                  -&gt; 제품 모델
|
+-- repositories                   -&gt; 리포지토리 디렉토리
|  |
|  +-- product-repository.<span class="hljs-property">ts</span>       -&gt; 제품 리포지토리
|
+-- services                       -&gt; 서비스 디렉토리
|  |
|  +-- product-service.<span class="hljs-property">ts</span>          -&gt; 제품 서비스
|
+-- package.<span class="hljs-property">json</span>
|
+-- tsconfig.<span class="hljs-property">json</span>
|
+-- next-env.<span class="hljs-property">d</span>.<span class="hljs-property">ts</span>
|
+-- next.<span class="hljs-property">config</span>.<span class="hljs-property">mjs</span>
</code></pre>
<h2>앱에서 사용하기</h2>
<p>컨테이너를 사용하여 인스턴스를 가져오는 것은 정말 쉽습니다.</p>
<p>예를 들어, 제품 데이터 목록을 표시해야 하는 페이지가 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @/app/page.tsx</span>

<span class="hljs-keyword">import</span> { getProductService } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/lib/di/hook&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Suspense</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ProductList</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/product-list&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ProductListSkeleton</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/components/product-list-skeleton&quot;</span>;

type <span class="hljs-title class_">Props</span> = {
  searchParams?: {
    search?: string;
    page?: string;
  };
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Page</span>(<span class="hljs-params">{ searchParams }: Props</span>) {
  <span class="hljs-comment">// 쿼리 매개변수 가져오기</span>
  <span class="hljs-keyword">const</span> query = searchParams?.<span class="hljs-property">search</span> || <span class="hljs-string">&quot;&quot;</span>;
  <span class="hljs-keyword">const</span> currentPage = <span class="hljs-title class_">Number</span>(searchParams?.<span class="hljs-property">page</span>) || <span class="hljs-number">1</span>;

  <span class="hljs-comment">// 제품 항목 가져오기</span>
  <span class="hljs-keyword">const</span> items = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getProductService</span>().<span class="hljs-title function_">getProducts</span>(query);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Suspense</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{query</span> + <span class="hljs-attr">currentPage</span>} <span class="hljs-attr">fallback</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">ProductListSkeleton</span> /&gt;</span>}&gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">ProductList</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{items}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Suspense</span>&gt;</span></span>
  );
}
</code></pre>
<p>정말 쉽죠? 이제 코드가 더 깔끔해 보입니다. 데이터 액세스가 IoC에 의해 중앙 집중화되고 관리되기 때문에 🎉.</p>
<h2>결론</h2>
<img src="/assets/img/2024-05-14-Next101IoCImplementationwithInversify_3.png"/>
<p>의존성 주입과 함께 역제어(IoC)를 사용하면 코드베이스를 더 깨끗하고 견고하며 유지보수하기 좋게 만들 수 있습니다.</p>
<p>코드베이스 전체에 중복되는 나쁜 냄새나는 코드를 제거할 수도 있어요. 끔찍해! 🤮</p>
<p>만약 Next 앱에서 Server Action을 더 선호한다면 IoC도 함께 사용할 수 있어요. 간단해요, 한 번 배우면 어디서든 사용할 수 있어요.</p>
<p>Next와 함께 Repository Pattern을 구현하는 기술과 지식을 향상시키기 위해 이 두 글을 읽어보길 권장해요.</p>
<h2>🚀 샘플 프로젝트</h2>
<p>Inversify를 IoC로 사용하여 개발한 데모 프로젝트를 실행해볼 수 있어요. 이 프로젝트는 MIT 라이센스로 라이선스가 부여되어 있어요.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"다음 시리즈 101 Inversify를 활용한 IoC 구현","description":"","date":"2024-05-14 10:26","slug":"2024-05-14-Next101IoCImplementationwithInversify","content":"\n\nTypescript IoC를 Next 14에 Inversify와 함께 올바르게 구현하는 방법을 배우세요.\n\n![image](/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png)\n\nIoC(Inversion of Control)는 객체의 동작 제어가 뒤바뀌거나 객체 외부로 이동되는 디자인 패턴입니다. 이는 소프트웨어 응용 프로그램 내 객체의 흐름을 관리하는 데 도움이 됩니다.\n\n제어가 역전되고 컨테이너가 의존성을 관리하는 책임을 맡아 모듈성, 유연성 및 테스트 용이성을 높이게 됩니다.\n\n\n\n아래는 [공식 줄임말(Markdown)](https://www.markdownguide.org/cheat-sheet/) 형식으로 업데이트한 내용입니다.\n\n\n![이미지](/assets/img/2024-05-14-Next101IoCImplementationwithInversify_1.png)\n\n의존성 주입에 익숙하다면, IoC 디자인을 구현하는 기술 중 하나입니다.\n\n이 패턴은 단순히 \"너가 객체를 만들지 마세요. 제가 그것을 제공할게요.\"라고 말합니다.\n\n![이미지](/assets/img/2024-05-14-Next101IoCImplementationwithInversify_2.png)\n\n\n\n\n## 그렇지만 왜?\n\n디자인 패턴? 또 다시요? 진짜로, 이걸로 충분히 지쳤어요 🤣. 처음에 IoC나 의존성 주입이 Next 프레임워크와 진짜 유용하다고 생각하지 않았어요. 보통 사람들도 사용하지 않잖아요, ㅎㅎ.\n\n하지만, 제게 호기심을 자극하는 흥미로운 점이 있어요. 만약 Next에서 Repository 패턴을 사용한다면 어떨까요? Next는 자바스크립트나 타입스크립트로 작성됐다는 걸 알고 있어요. 이는 OOP보다 함수형 접근 방식을 기본으로 사용한다는 데 특별히 신경쓰지 않아도 되겠죠.\n\n저는 보통 백엔드에 더 많이 관심이 있는데, 주로 Rust나 PHP와 같은 OOP 언어로 대화를 나눠요. 제가 매일 사용하는 프레임워크는 Laravel이에요. 물론, 개발한 모든 프로젝트에 Repository 및 Service 패턴을 항상 구현해요.\n\n\n\n저장소(repository)는 데이터가 저장되는 곳입니다. 서비스(service)는 데이터를 조작합니다. 간단하죠? 이러한 패턴을 사용하면 API를 통해 데이터를 관리해야 하는 경우나 프로젝트에서 데이터베이스에 직접적으로 접근해야 하는 경우에 견고하고 유지보수하기 쉬운 코드베이스를 개발하는 데 도움이 될 것입니다.\n\n아래의 기사에서 더 많은 정보를 찾아볼 수 있습니다. 관심이 생긴다면 읽어보세요.\n\n## Inversify\n\nNext 프레임워크에서 IoC를 구현하기 위해 InversifyJS를 사용할 예정입니다.\n\n\n\n이것은 TypeScript로 구동되는 JavaScript 및 Node.js 앱을 위한 강력하고 가벼운 제어 반전 컨테이너입니다. 사용하기 쉬운 친절한 API 세트를 갖추고 있어서 최상의 OOP 및 IoC 모범 사례 사용을 촉진할 수 있습니다.\n\n다른 IoC 및 DI 라이브러리 중에서, 제품 환경에서 사용할 수 있는 안정성을 고려하여 이것을 사용하는 것을 선호합니다. 그리고 가벼운 크기인 4 KB만큼만 차지한다는 점도 좋은데요.\n\nInversify는 다음과 같은 모던 JavaScript 엔진을 필요로 합니다:\n\n- Reflect metadata\n- Map\n- Promise (공급자 주입 사용 시에만 필요)\n- Proxy (활성화 핸들러 사용 시에만 필요)\n\n\n\n## 시작해봅시다\n\n일반적으로 Typescript와 App 기반 Router를 사용하여 새 Next 프로젝트를 만든 후에는 프로젝트 디렉토리 구조가 아래와 같이 나타날 것입니다.\n\n```js\nproject\n|\n+-- app                  -\u003e 애플리케이션 디렉토리\n|\n+-- components           -\u003e UI 컴포넌트 디렉토리\n|\n+-- public               -\u003e 공용 에셋 디렉토리\n|\n+-- package.json\n|\n+-- tsconfig.json\n|\n+-- next-env.d.ts\n|\n+-- next.config.mjs\n```\n\n다음 명령어를 사용하여 필요한 종속성을 설치해주세요.\n\n\n\n```js\nnpm install inversify reflect-metadata --save\n```\n\nInversify는 TypeScript에서 IoC를 구현하는 데 필요하며, reflect-metadata는 Typescript 파일에서 데코레이터 및 데코레이터 메타데이터를 사용하는 데 필요합니다.\n\n이러한 유형의 정의는 inversify npm 패키지에 포함되어 있습니다. tsconfig.json 파일에 experimentalDecorators, emitDecoratorMetadata, types 및 lib와 같은 몇 가지 컴파일 옵션이 필요합니다. \n\n```js\n{\n    \"compilerOptions\": {\n        \"target\": \"es5\",\n        \"lib\": [\"es6\", \"dom\"],\n        \"types\": [\"reflect-metadata\"],\n        \"module\": \"commonjs\",\n        \"moduleResolution\": \"node\",\n        \"experimentalDecorators\": true,\n        \"emitDecoratorMetadata\": true\n    }\n}\n```\n\n\n\n시작하려면 Inversify의 컨테이너 및 reflect-metadata에 필요한 파일을 만들어보세요.\n\n```js\n// @/lib/di/container.ts\n\nimport \"reflect-metadata\";\nimport { Container } from \"inversify\";\n\nconst container = new Container();\n\nexport default container;\n```\n\n```js\n// @/lib/di/reflect-metadata.ts\n\n\"use client\";                           // -\u003e 클라이언트-컴포넌트로 표시\n\nimport \"reflect-metadata\";\n```\n\n다음으로 각 페이지 또는 구성 요소에 대해 기본적으로 SSR(서버 사이드 렌더링)를 사용하지만 reflect-metadata 라이브러리가 클라이언트 측에서 가져와지지 않으면 이상한 오류가 발생할 수 있어요. 그래서 reflect-metadata.ts를 루트 레이아웃 파일에 가져와야 해요.\n\n\n\n```js\n// @/app/layout.tsx\n\nimport \"@/lib/di/reflect-metadata\";    // -\u003e reflect-metadata를 import합니다\n\nexport default function RootLayout({\n  children,\n}: Readonly\u003c{\n  children: React.ReactNode;\n}\u003e) {\n  ...\n}\n```\n\n이제 프로젝트 디렉토리 구조는 다음과 같을 것입니다.\n\n```js\nproject\n|\n+-- app                            -\u003e 애플리케이션 디렉토리\n|\n+-- components                     -\u003e UI 컴포넌트 디렉토리\n|\n+-- public                         -\u003e 퍼블릭 에셋 디렉토리\n|\n+-- lib                            -\u003e 라이브러리 디렉토리\n|  |\n|  +-- di                          -\u003e 의존성 주입 디렉토리\n|     |\n|     +-- container.ts             -\u003e 컨테이너\n|     |\n|     +-- reflect-metadata.ts      -\u003e reflect-metadata 클라이언트 컴포넌트\n|\n+-- package.json\n|\n+-- tsconfig.json\n|\n+-- next-env.d.ts\n|\n+-- next.config.mjs\n```\n\n그리고 이제 Inversify가 제대로 작동하고 사용할 준비가 되었습니다.\n\n\n\n\n## 모델\n\n이라고 불리는 모델은 당신이 코드에서 사용하는 데이터에 대한 엄격한 타입 정의입니다. \"모델\" 이라는 이름을 사용하는 이유는 이에 더 익숙하기 때문입니다. 이것을 \"타입\" 이라고 부르고 프로젝트 루트에 types 라는 디렉토리를 생성할 수도 있습니다.\n\n예를 들어, 내 애플리케이션에서 제품으로 사용될 데이터에 대한 Product 모델을 생성할 것입니다.\n\n```js\n// @/models/product.ts\n\ntype Product = {\n  id: string;\n  image_url: string;\n  image_blur_data_url: string | undefined;\n  name: string;\n  price: number;\n  unit: string;\n  short_description: string;\n  description: string;\n  statement_description: string;\n  marketing_feature: string;\n};\n\nexport default Product;\n```\n\n\n\n## 저장소\n\n저장소 클래스는 데이터 저장소(창고)로 사용되어 다른 코드가 이 클래스를 통해 필요한 데이터에 액세스할 수 있도록 합니다. 저장소는 앱에서 단일 진실의 원천입니다.\n\n예를 들어, ProductRepository라는 클래스를 만들어 보겠습니다. 아래 예시는 이전에 생성된 Product 모델의 엄격한 유형을 사용합니다.\n\n```js\n// @/repositories/product-repository.ts\n\nimport \"reflect-metadata\";\nimport { injectable } from \"inversify\";\nimport type Product from \"@/models/product\";\n\n// 더미 제품 데이터 목록\nconst products = [ ... ];\n\n@injectable()\nexport default class ProductRepository {\n  async getProducts(): Promise\u003cArray\u003cProduct\u003e\u003e {\n    return products.map((product: any) =\u003e product as Product);\n  }\n\n  async getProduct(id: string): Promise\u003cProduct | undefined\u003e {\n    const product = products.find((product: any) =\u003e product.id === id);\n\n    if (product) {\n      return product as Product;\n    }\n\n    return undefined;\n  }\n}\n```\n\n\n\n위 코드는 더미 데이터 목록에서 데이터를 얻는 시뮬레이션입니다.\n\n`@injectable` 데코레이터를 사용해야만 Inversify가 해당 클래스를 다른 인스턴스에 삽입할 수 있다는 것을 인지합니다.\n\n비동기로 코드를 실행해야 하는 경우 `async`가 일반적으로 필요합니다. 왜냐하면 완료되기까지 시간이 걸리기 때문입니다. 데이터베이스나 외부 API와 상호 작용해야 하는 경우에 이를 사용할 수 있습니다.\n\n## 서비스\n\n\n\n레포지토리 클래스를 통해 데이터를 조작하는 서비스 클래스입니다. 필요한 경우 서비스 클래스에서 여러 레포지토리를 사용할 수 있습니다.\n\n이 곳에서 Inversify를 사용한 의존성 주입이 도움이 됩니다. @inject 데코레이터를 통해 서비스 클래스에 필요한 레포지토리를 자동으로 주입할 수 있습니다.\n\n예를 들어, ProductService 클래스를 만들어 보겠습니다. 아래 예시는 이전에 생성된 ProductRepository와 Product 모델의 엄격한 유형을 사용합니다.\n\n```js\n// @/services/product-service.ts\n\nimport \"reflect-metadata\";\nimport { inject, injectable } from \"inversify\";\nimport ProductRepository from \"@/repositories/product-repository\";\nimport type Product from \"@/models/product\";\n\n@injectable()\nexport default class ProductService {\n  @inject(ProductRepository)\n  private productRepository: ProductRepository;\n\n  async getProducts(query: string): Promise\u003cArray\u003cProduct\u003e\u003e {\n    let products = await this.productRepository.getProducts();\n\n    if (query !== \"\") {\n      return products.filter((product: Product) =\u003e\n        product.name.toLowerCase().includes(query.toLowerCase()),\n      );\n    }\n\n    return products;\n  }\n\n  async getProduct(id: string): Promise\u003cProduct | undefined\u003e {\n    const product = await this.productRepository.getProduct(id);\n\n    if (product) {\n      return product as Product;\n    }\n\n    return undefined;\n  }\n}\n```\n\n\n\n당신의 요구에 따라, 이 서비스 클래스를 사용하여 데이터를 관리하는 데 도움이 되는 추가적인 메서드를 추가할 수 있습니다.\n\n@Injectable 데코레이터를 사용해야만 Inversify가 해당 클래스를 다른 인스턴스에 주입할 수 있다는 것을 알 수 있습니다.\n\n@Inject 데코레이터를 사용해야만 Inversify에 해당 클래스의 필수 인스턴스를 주입하도록 알릴 수 있으므로 이 인스턴스를 사용하여 리포지토리의 메서드에 액세스할 수 있습니다.\n\n## 컨테이너\n\n\n\n이제 올바르게 작동하는 IoC를 위해 수행해야 할 마지막 단계입니다.\n\n모델(타입), 리포지토리, 서비스 클래스를 생성한 후, 이러한 클래스를 IoC 컨테이너에 등록해야 합니다. 클래스가 컨테이너에 등록되면 앱의 런타임 중에 필요한 인스턴스에 주입될 수 있습니다.\n\n컨테이너는 항상 앱의 런타임에 이용 가능할 것입니다.\n\n```js\n// @/lib/di/container.ts\n\nimport \"reflect-metadata\";\nimport { Container } from \"inversify\";\nimport ProductRepository from \"@/repositories/product-repository\";\nimport ProductService from \"@/services/product-service\";\nimport UserService from \"@/services/user-service\";\n\nconst container = new Container();\n\ncontainer.bind(ProductRepository).to(ProductRepository).inSingletonScope();\n\ncontainer.bind(ProductService).to(ProductService).inSingletonScope();\n\nexport default container;\n```\n\n\n\n클래스 인스턴스에 대한 scope를 지정할 수도 있어요.\n\n- inTransientScope: 매 의존성 요청마다 새로운 인스턴스를 보장하여 가벼우면서도 일회용 의존성을 유지합니다. 이것이 기본 스코프에요.\n- inSingletonScope: 의존성에 대한 중앙 접근점을 생성하여 모든 곳에서 동일한 인스턴스를 사용하며 효율성과 상태 관리를 촉진합니다.\n- inRequestScope: 단일 해결 프로세스 내에서 중복된 객체 생성을 피해 성능 최적화를 제공하지만 HTTP 요청 당 단일 인스턴스를 보장하지는 않아요.\n\n## The Hook\n\n이 단계는 선택 사항으로, 앱의 다른 구성 요소에서 컨테이너에 액세스하는 데 도움을 줍니다.\n\n\n\n```js\n// @/lib/di/hook.ts\n\nimport container from \"@/lib/di/container\";\nimport ProductRepository from \"@/repositories/product-repository\";\nimport ProductService from \"@/services/product-service\";\nimport UserService from \"@/services/user-service\";\n\nexport function getProductRepository(): ProductRepository {\n  return container.get(ProductRepository);\n}\n\nexport function getProductService(): ProductService {\n  return container.get(ProductService);\n}\n```\n\n마침내, 이제 프로젝트 디렉토리 구조는 다음과 같이 보일 것입니다.\n\n```js\nproject\n|\n+-- app                            -\u003e 애플리케이션 디렉토리\n|\n+-- components                     -\u003e UI 컴포넌트 디렉토리\n|\n+-- public                         -\u003e 공용 에셋 디렉토리\n|\n+-- lib                            -\u003e 라이브러리 디렉토리\n|  |\n|  +-- di                          -\u003e 의존성 주입 디렉토리\n|     |\n|     +-- container.ts             -\u003e 컨테이너\n|     |\n|     +-- hook.ts                  -\u003e 컨테이너 후크\n|     |\n|     +-- reflect-metadata.ts      -\u003e reflect-metadata 클라이언트 컴포넌트\n|\n+-- models                         -\u003e 모델 디렉토리\n|  |\n|  +-- product.ts                  -\u003e 제품 모델\n|\n+-- repositories                   -\u003e 리포지토리 디렉토리\n|  |\n|  +-- product-repository.ts       -\u003e 제품 리포지토리\n|\n+-- services                       -\u003e 서비스 디렉토리\n|  |\n|  +-- product-service.ts          -\u003e 제품 서비스\n|\n+-- package.json\n|\n+-- tsconfig.json\n|\n+-- next-env.d.ts\n|\n+-- next.config.mjs\n```\n\n## 앱에서 사용하기\n\n\n\n컨테이너를 사용하여 인스턴스를 가져오는 것은 정말 쉽습니다.\n\n예를 들어, 제품 데이터 목록을 표시해야 하는 페이지가 있습니다.\n\n```js\n// @/app/page.tsx\n\nimport { getProductService } from \"@/lib/di/hook\";\nimport { Suspense } from \"react\";\nimport ProductList from \"@/components/product-list\";\nimport ProductListSkeleton from \"@/components/product-list-skeleton\";\n\ntype Props = {\n  searchParams?: {\n    search?: string;\n    page?: string;\n  };\n};\n\nexport default async function Page({ searchParams }: Props) {\n  // 쿼리 매개변수 가져오기\n  const query = searchParams?.search || \"\";\n  const currentPage = Number(searchParams?.page) || 1;\n\n  // 제품 항목 가져오기\n  const items = await getProductService().getProducts(query);\n\n  return (\n    \u003cSuspense key={query + currentPage} fallback={\u003cProductListSkeleton /\u003e}\u003e\n      \u003cProductList items={items} /\u003e\n    \u003c/Suspense\u003e\n  );\n}\n```\n\n정말 쉽죠? 이제 코드가 더 깔끔해 보입니다. 데이터 액세스가 IoC에 의해 중앙 집중화되고 관리되기 때문에 🎉.\n\n\n\n## 결론\n\n\u003cimg src=\"/assets/img/2024-05-14-Next101IoCImplementationwithInversify_3.png\" /\u003e\n\n의존성 주입과 함께 역제어(IoC)를 사용하면 코드베이스를 더 깨끗하고 견고하며 유지보수하기 좋게 만들 수 있습니다.\n\n코드베이스 전체에 중복되는 나쁜 냄새나는 코드를 제거할 수도 있어요. 끔찍해! 🤮\n\n\n\n만약 Next 앱에서 Server Action을 더 선호한다면 IoC도 함께 사용할 수 있어요. 간단해요, 한 번 배우면 어디서든 사용할 수 있어요.\n\nNext와 함께 Repository Pattern을 구현하는 기술과 지식을 향상시키기 위해 이 두 글을 읽어보길 권장해요.\n\n## 🚀 샘플 프로젝트\n\nInversify를 IoC로 사용하여 개발한 데모 프로젝트를 실행해볼 수 있어요. 이 프로젝트는 MIT 라이센스로 라이선스가 부여되어 있어요.","ogImage":{"url":"/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png"},"coverImage":"/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png","tag":["Tech"],"readingTime":11},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    a: \"a\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Typescript IoC를 Next 14에 Inversify와 함께 올바르게 구현하는 방법을 배우세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-Next101IoCImplementationwithInversify_0.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"IoC(Inversion of Control)는 객체의 동작 제어가 뒤바뀌거나 객체 외부로 이동되는 디자인 패턴입니다. 이는 소프트웨어 응용 프로그램 내 객체의 흐름을 관리하는 데 도움이 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제어가 역전되고 컨테이너가 의존성을 관리하는 책임을 맡아 모듈성, 유연성 및 테스트 용이성을 높이게 됩니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"아래는 \", _jsx(_components.a, {\n        href: \"https://www.markdownguide.org/cheat-sheet/\",\n        children: \"공식 줄임말(Markdown)\"\n      }), \" 형식으로 업데이트한 내용입니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-Next101IoCImplementationwithInversify_1.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"의존성 주입에 익숙하다면, IoC 디자인을 구현하는 기술 중 하나입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 패턴은 단순히 \\\"너가 객체를 만들지 마세요. 제가 그것을 제공할게요.\\\"라고 말합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-Next101IoCImplementationwithInversify_2.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"그렇지만 왜?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"디자인 패턴? 또 다시요? 진짜로, 이걸로 충분히 지쳤어요 🤣. 처음에 IoC나 의존성 주입이 Next 프레임워크와 진짜 유용하다고 생각하지 않았어요. 보통 사람들도 사용하지 않잖아요, ㅎㅎ.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만, 제게 호기심을 자극하는 흥미로운 점이 있어요. 만약 Next에서 Repository 패턴을 사용한다면 어떨까요? Next는 자바스크립트나 타입스크립트로 작성됐다는 걸 알고 있어요. 이는 OOP보다 함수형 접근 방식을 기본으로 사용한다는 데 특별히 신경쓰지 않아도 되겠죠.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저는 보통 백엔드에 더 많이 관심이 있는데, 주로 Rust나 PHP와 같은 OOP 언어로 대화를 나눠요. 제가 매일 사용하는 프레임워크는 Laravel이에요. 물론, 개발한 모든 프로젝트에 Repository 및 Service 패턴을 항상 구현해요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저장소(repository)는 데이터가 저장되는 곳입니다. 서비스(service)는 데이터를 조작합니다. 간단하죠? 이러한 패턴을 사용하면 API를 통해 데이터를 관리해야 하는 경우나 프로젝트에서 데이터베이스에 직접적으로 접근해야 하는 경우에 견고하고 유지보수하기 쉬운 코드베이스를 개발하는 데 도움이 될 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래의 기사에서 더 많은 정보를 찾아볼 수 있습니다. 관심이 생긴다면 읽어보세요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Inversify\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next 프레임워크에서 IoC를 구현하기 위해 InversifyJS를 사용할 예정입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 TypeScript로 구동되는 JavaScript 및 Node.js 앱을 위한 강력하고 가벼운 제어 반전 컨테이너입니다. 사용하기 쉬운 친절한 API 세트를 갖추고 있어서 최상의 OOP 및 IoC 모범 사례 사용을 촉진할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다른 IoC 및 DI 라이브러리 중에서, 제품 환경에서 사용할 수 있는 안정성을 고려하여 이것을 사용하는 것을 선호합니다. 그리고 가벼운 크기인 4 KB만큼만 차지한다는 점도 좋은데요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Inversify는 다음과 같은 모던 JavaScript 엔진을 필요로 합니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Reflect metadata\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Map\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Promise (공급자 주입 사용 시에만 필요)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Proxy (활성화 핸들러 사용 시에만 필요)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"시작해봅시다\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"일반적으로 Typescript와 App 기반 Router를 사용하여 새 Next 프로젝트를 만든 후에는 프로젝트 디렉토리 구조가 아래와 같이 나타날 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"project\\n|\\n+-- app                  -\u003e 애플리케이션 디렉토리\\n|\\n+-- components           -\u003e \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"UI\"\n        }), \" 컴포넌트 디렉토리\\n|\\n+-- public               -\u003e 공용 에셋 디렉토리\\n|\\n+-- package.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"json\"\n        }), \"\\n|\\n+-- tsconfig.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"json\"\n        }), \"\\n|\\n+-- next-env.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"d\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ts\"\n        }), \"\\n|\\n+-- next.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"config\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"mjs\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 명령어를 사용하여 필요한 종속성을 설치해주세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-js\",\n        children: \"npm install inversify reflect-metadata --save\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Inversify는 TypeScript에서 IoC를 구현하는 데 필요하며, reflect-metadata는 Typescript 파일에서 데코레이터 및 데코레이터 메타데이터를 사용하는 데 필요합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 유형의 정의는 inversify npm 패키지에 포함되어 있습니다. tsconfig.json 파일에 experimentalDecorators, emitDecoratorMetadata, types 및 lib와 같은 몇 가지 컴파일 옵션이 필요합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"compilerOptions\\\"\"\n        }), \": {\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"target\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"es5\\\"\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"lib\\\"\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"es6\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dom\\\"\"\n        }), \"],\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"types\\\"\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"reflect-metadata\\\"\"\n        }), \"],\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"module\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"commonjs\\\"\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"moduleResolution\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"node\\\"\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"experimentalDecorators\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"emitDecoratorMetadata\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"시작하려면 Inversify의 컨테이너 및 reflect-metadata에 필요한 파일을 만들어보세요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// @/lib/di/container.ts\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"reflect-metadata\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Container\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"inversify\\\"\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" container = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Container\"\n        }), \"();\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \" container;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// @/lib/di/reflect-metadata.ts\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"use client\\\"\"\n        }), \";                           \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// -\u003e 클라이언트-컴포넌트로 표시\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"reflect-metadata\\\"\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음으로 각 페이지 또는 구성 요소에 대해 기본적으로 SSR(서버 사이드 렌더링)를 사용하지만 reflect-metadata 라이브러리가 클라이언트 측에서 가져와지지 않으면 이상한 오류가 발생할 수 있어요. 그래서 reflect-metadata.ts를 루트 레이아웃 파일에 가져와야 해요.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// @/app/layout.tsx\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/lib/di/reflect-metadata\\\"\"\n        }), \";    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// -\u003e reflect-metadata를 import합니다\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"RootLayout\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{\\n  children,\\n}: Readonly\u003c{\\n  children: React.ReactNode;\\n}\u003e\"\n        }), \") {\\n  ...\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 프로젝트 디렉토리 구조는 다음과 같을 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"project\\n|\\n+-- app                            -\u003e 애플리케이션 디렉토리\\n|\\n+-- components                     -\u003e \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"UI\"\n        }), \" 컴포넌트 디렉토리\\n|\\n+-- public                         -\u003e 퍼블릭 에셋 디렉토리\\n|\\n+-- lib                            -\u003e 라이브러리 디렉토리\\n|  |\\n|  +-- di                          -\u003e 의존성 주입 디렉토리\\n|     |\\n|     +-- container.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ts\"\n        }), \"             -\u003e 컨테이너\\n|     |\\n|     +-- reflect-metadata.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ts\"\n        }), \"      -\u003e reflect-metadata 클라이언트 컴포넌트\\n|\\n+-- package.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"json\"\n        }), \"\\n|\\n+-- tsconfig.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"json\"\n        }), \"\\n|\\n+-- next-env.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"d\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ts\"\n        }), \"\\n|\\n+-- next.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"config\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"mjs\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그리고 이제 Inversify가 제대로 작동하고 사용할 준비가 되었습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"모델\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이라고 불리는 모델은 당신이 코드에서 사용하는 데이터에 대한 엄격한 타입 정의입니다. \\\"모델\\\" 이라는 이름을 사용하는 이유는 이에 더 익숙하기 때문입니다. 이것을 \\\"타입\\\" 이라고 부르고 프로젝트 루트에 types 라는 디렉토리를 생성할 수도 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, 내 애플리케이션에서 제품으로 사용될 데이터에 대한 Product 모델을 생성할 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// @/models/product.ts\"\n        }), \"\\n\\ntype \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \" = {\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": string;\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"image_url\"\n        }), \": string;\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"image_blur_data_url\"\n        }), \": string | \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"undefined\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"name\"\n        }), \": string;\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"price\"\n        }), \": number;\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"unit\"\n        }), \": string;\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"short_description\"\n        }), \": string;\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"description\"\n        }), \": string;\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"statement_description\"\n        }), \": string;\\n  \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"marketing_feature\"\n        }), \": string;\\n};\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"저장소\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"저장소 클래스는 데이터 저장소(창고)로 사용되어 다른 코드가 이 클래스를 통해 필요한 데이터에 액세스할 수 있도록 합니다. 저장소는 앱에서 단일 진실의 원천입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, ProductRepository라는 클래스를 만들어 보겠습니다. 아래 예시는 이전에 생성된 Product 모델의 엄격한 유형을 사용합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// @/repositories/product-repository.ts\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"reflect-metadata\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { injectable } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"inversify\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" type \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/models/product\\\"\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 더미 제품 데이터 목록\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" products = [ ... ];\\n\\n@\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"injectable\"\n        }), \"()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductRepository\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getProducts\"\n        }), \"(): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Promise\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Array\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \"\u003e\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" products.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"map\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"product: any\"\n          }), \") =\u003e\"]\n        }), \" product \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \");\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getProduct\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": string): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Promise\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \" | \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"undefined\"\n        }), \"\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" product = products.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"find\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"product: any\"\n          }), \") =\u003e\"]\n        }), \" product.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"id\"\n        }), \" === id);\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (product) {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" product \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \";\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"undefined\"\n        }), \";\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위 코드는 더미 데이터 목록에서 데이터를 얻는 시뮬레이션입니다.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"@injectable\"\n      }), \" 데코레이터를 사용해야만 Inversify가 해당 클래스를 다른 인스턴스에 삽입할 수 있다는 것을 인지합니다.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"비동기로 코드를 실행해야 하는 경우 \", _jsx(_components.code, {\n        children: \"async\"\n      }), \"가 일반적으로 필요합니다. 왜냐하면 완료되기까지 시간이 걸리기 때문입니다. 데이터베이스나 외부 API와 상호 작용해야 하는 경우에 이를 사용할 수 있습니다.\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"서비스\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"레포지토리 클래스를 통해 데이터를 조작하는 서비스 클래스입니다. 필요한 경우 서비스 클래스에서 여러 레포지토리를 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 곳에서 Inversify를 사용한 의존성 주입이 도움이 됩니다. @inject 데코레이터를 통해 서비스 클래스에 필요한 레포지토리를 자동으로 주입할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, ProductService 클래스를 만들어 보겠습니다. 아래 예시는 이전에 생성된 ProductRepository와 Product 모델의 엄격한 유형을 사용합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// @/services/product-service.ts\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"reflect-metadata\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { inject, injectable } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"inversify\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductRepository\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/repositories/product-repository\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" type \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/models/product\\\"\"\n        }), \";\\n\\n@\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"injectable\"\n        }), \"()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductService\"\n        }), \" {\\n  @\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"inject\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductRepository\"\n        }), \")\\n  private \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"productRepository\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductRepository\"\n        }), \";\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getProducts\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"query\"\n        }), \": string): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Promise\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Array\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \"\u003e\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" products = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"productRepository\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getProducts\"\n        }), \"();\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (query !== \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \") {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" products.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"filter\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"(\", _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"product: Product\"\n          }), \") =\u003e\"]\n        }), \"\\n        product.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"name\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toLowerCase\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"includes\"\n        }), \"(query.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"toLowerCase\"\n        }), \"()),\\n      );\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" products;\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getProduct\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"id\"\n        }), \": string): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Promise\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \" | \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"undefined\"\n        }), \"\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" product = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"this\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"productRepository\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getProduct\"\n        }), \"(id);\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (product) {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" product \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Product\"\n        }), \";\\n    }\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"undefined\"\n        }), \";\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"당신의 요구에 따라, 이 서비스 클래스를 사용하여 데이터를 관리하는 데 도움이 되는 추가적인 메서드를 추가할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"@Injectable 데코레이터를 사용해야만 Inversify가 해당 클래스를 다른 인스턴스에 주입할 수 있다는 것을 알 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"@Inject 데코레이터를 사용해야만 Inversify에 해당 클래스의 필수 인스턴스를 주입하도록 알릴 수 있으므로 이 인스턴스를 사용하여 리포지토리의 메서드에 액세스할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"컨테이너\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 올바르게 작동하는 IoC를 위해 수행해야 할 마지막 단계입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"모델(타입), 리포지토리, 서비스 클래스를 생성한 후, 이러한 클래스를 IoC 컨테이너에 등록해야 합니다. 클래스가 컨테이너에 등록되면 앱의 런타임 중에 필요한 인스턴스에 주입될 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"컨테이너는 항상 앱의 런타임에 이용 가능할 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// @/lib/di/container.ts\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"reflect-metadata\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Container\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"inversify\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductRepository\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/repositories/product-repository\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductService\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/services/product-service\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"UserService\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/services/user-service\\\"\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" container = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Container\"\n        }), \"();\\n\\ncontainer.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"bind\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductRepository\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductRepository\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"inSingletonScope\"\n        }), \"();\\n\\ncontainer.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"bind\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductService\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"to\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductService\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"inSingletonScope\"\n        }), \"();\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \" container;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"클래스 인스턴스에 대한 scope를 지정할 수도 있어요.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"inTransientScope: 매 의존성 요청마다 새로운 인스턴스를 보장하여 가벼우면서도 일회용 의존성을 유지합니다. 이것이 기본 스코프에요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"inSingletonScope: 의존성에 대한 중앙 접근점을 생성하여 모든 곳에서 동일한 인스턴스를 사용하며 효율성과 상태 관리를 촉진합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"inRequestScope: 단일 해결 프로세스 내에서 중복된 객체 생성을 피해 성능 최적화를 제공하지만 HTTP 요청 당 단일 인스턴스를 보장하지는 않아요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"The Hook\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 단계는 선택 사항으로, 앱의 다른 구성 요소에서 컨테이너에 액세스하는 데 도움을 줍니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// @/lib/di/hook.ts\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" container \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/lib/di/container\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductRepository\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/repositories/product-repository\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductService\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/services/product-service\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"UserService\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/services/user-service\\\"\"\n        }), \";\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getProductRepository\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductRepository\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" container.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductRepository\"\n        }), \");\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getProductService\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductService\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" container.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductService\"\n        }), \");\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마침내, 이제 프로젝트 디렉토리 구조는 다음과 같이 보일 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"project\\n|\\n+-- app                            -\u003e 애플리케이션 디렉토리\\n|\\n+-- components                     -\u003e \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"UI\"\n        }), \" 컴포넌트 디렉토리\\n|\\n+-- public                         -\u003e 공용 에셋 디렉토리\\n|\\n+-- lib                            -\u003e 라이브러리 디렉토리\\n|  |\\n|  +-- di                          -\u003e 의존성 주입 디렉토리\\n|     |\\n|     +-- container.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ts\"\n        }), \"             -\u003e 컨테이너\\n|     |\\n|     +-- hook.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ts\"\n        }), \"                  -\u003e 컨테이너 후크\\n|     |\\n|     +-- reflect-metadata.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ts\"\n        }), \"      -\u003e reflect-metadata 클라이언트 컴포넌트\\n|\\n+-- models                         -\u003e 모델 디렉토리\\n|  |\\n|  +-- product.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ts\"\n        }), \"                  -\u003e 제품 모델\\n|\\n+-- repositories                   -\u003e 리포지토리 디렉토리\\n|  |\\n|  +-- product-repository.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ts\"\n        }), \"       -\u003e 제품 리포지토리\\n|\\n+-- services                       -\u003e 서비스 디렉토리\\n|  |\\n|  +-- product-service.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ts\"\n        }), \"          -\u003e 제품 서비스\\n|\\n+-- package.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"json\"\n        }), \"\\n|\\n+-- tsconfig.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"json\"\n        }), \"\\n|\\n+-- next-env.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"d\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"ts\"\n        }), \"\\n|\\n+-- next.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"config\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"mjs\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"앱에서 사용하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"컨테이너를 사용하여 인스턴스를 가져오는 것은 정말 쉽습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, 제품 데이터 목록을 표시해야 하는 페이지가 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// @/app/page.tsx\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { getProductService } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/lib/di/hook\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Suspense\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"react\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductList\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/components/product-list\\\"\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ProductListSkeleton\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"@/components/product-list-skeleton\\\"\"\n        }), \";\\n\\ntype \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Props\"\n        }), \" = {\\n  searchParams?: {\\n    search?: string;\\n    page?: string;\\n  };\\n};\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"Page\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{ searchParams }: Props\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 쿼리 매개변수 가져오기\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" query = searchParams?.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"search\"\n        }), \" || \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" currentPage = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Number\"\n        }), \"(searchParams?.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"page\"\n        }), \") || \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \";\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 제품 항목 가져오기\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" items = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getProductService\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getProducts\"\n        }), \"(query);\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Suspense\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"key\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{query\"\n            }), \" + \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"currentPage\"\n            }), \"} \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"fallback\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{\"\n            }), \"\u003c\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"ProductListSkeleton\"\n            }), \" /\u003e\"]\n          }), \"}\u003e\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"ProductList\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"items\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{items}\"\n            }), \" /\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Suspense\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정말 쉽죠? 이제 코드가 더 깔끔해 보입니다. 데이터 액세스가 IoC에 의해 중앙 집중화되고 관리되기 때문에 🎉.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-14-Next101IoCImplementationwithInversify_3.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"의존성 주입과 함께 역제어(IoC)를 사용하면 코드베이스를 더 깨끗하고 견고하며 유지보수하기 좋게 만들 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"코드베이스 전체에 중복되는 나쁜 냄새나는 코드를 제거할 수도 있어요. 끔찍해! 🤮\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"만약 Next 앱에서 Server Action을 더 선호한다면 IoC도 함께 사용할 수 있어요. 간단해요, 한 번 배우면 어디서든 사용할 수 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Next와 함께 Repository Pattern을 구현하는 기술과 지식을 향상시키기 위해 이 두 글을 읽어보길 권장해요.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"🚀 샘플 프로젝트\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Inversify를 IoC로 사용하여 개발한 데모 프로젝트를 실행해볼 수 있어요. 이 프로젝트는 MIT 라이센스로 라이선스가 부여되어 있어요.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-Next101IoCImplementationwithInversify"},"buildId":"uXJWf9GNc_Ux38RlnQJQc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>