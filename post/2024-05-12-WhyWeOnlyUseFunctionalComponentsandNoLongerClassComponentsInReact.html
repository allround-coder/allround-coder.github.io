<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>React에서 함수형 컴포넌트만 사용하고 더 이상 클래스 컴포넌트를 사용하지 않는 이유 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="React에서 함수형 컴포넌트만 사용하고 더 이상 클래스 컴포넌트를 사용하지 않는 이유 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="React에서 함수형 컴포넌트만 사용하고 더 이상 클래스 컴포넌트를 사용하지 않는 이유 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact" data-gatsby-head="true"/><meta name="twitter:title" content="React에서 함수형 컴포넌트만 사용하고 더 이상 클래스 컴포넌트를 사용하지 않는 이유 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 23:07" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">React에서 함수형 컴포넌트만 사용하고 더 이상 클래스 컴포넌트를 사용하지 않는 이유</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="React에서 함수형 컴포넌트만 사용하고 더 이상 클래스 컴포넌트를 사용하지 않는 이유" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">2<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>리액트 개발자로서, UI에 대해 함수형 컴포넌트 또는 클래스 컴포넌트를 사용할 수 있습니다. 클래스 컴포넌트는 리액트 개발자들이 선호하는 선택이었습니다. 그러나 2018년 리액트 버전 16.8에서 리액트 훅이 소개되면서 함수형 컴포넌트가 리액트 개발자들에게 선호되는 선택이 되었습니다.</p>
<p><img src="/assets/img/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact_0.png" alt="이미지"></p>
<h1>왜 리액트 개발자들이 과거에 클래스 컴포넌트를 함수형 컴포넌트보다 선호했는가</h1>
<p>리액트에서 컴포넌트 UI를 렌더링하는 두 가지 방법이 있습니다. 하나는 JavaScript 함수인 함수형 컴포넌트이고, 다른 하나는 JavaScript 클래스인 클래스 컴포넌트입니다. 클래스 컴포넌트는 UI를 동적으로 만들기 위해 로직과 상태를 추가할 수 있어서 리액트 개발자들에게 선호되었습니다. 함수형 컴포넌트는 과거에는 정적 UI만 렌더링했습니다. 특히 현대적인 웹 앱을 개발할 때 클래스 컴포넌트가 리액트 개발자들에게 선호되었던 이유가 분명합니다.</p>
<h1>React에서 Hooks가 소개된 이유</h1>
<p>기존에는 클래스 컴포넌트가 UI를 렌더링하는 선호 방법이었지만, 이에는 문제점이 있었습니다. 하나의 문제는 클래스 컴포넌트 사이에서 로직과 상태 데이터를 공유하는 것이 어려웠다는 점입니다. 클래스 컴포넌트 사이에서 데이터 흐름을 관리하는 것은 번거로운 작업이었습니다. 또 다른 문제는 클래스 컴포넌트가 상태 로직이 커질수록 이해하기 어렵다는 것이었습니다. 이 복잡성으로 인해 컴포넌트를 렌더링하는 것이 더 어려워졌습니다. 이러한 문제를 해결하기 위해 React에서 Hooks가 소개되었습니다. Hooks를 사용하면 개발자가 함수형 컴포넌트에 더 많은 로직과 상태를 추가할 수 있으며, 이를 통해 컴포넌트 UI를 동적으로 만들고 로직을 재사용할 수 있게 되었습니다. 결과적으로 함수형 컴포넌트는 UI 컴포넌트를 렌더링하는 선호 방법이 되었으며, Hooks를 통해 개발자들이 함수형 컴포넌트를 통해 더 명확하고 관리하기 쉬운 코드를 작성할 수 있었습니다.</p>
<h1>결론</h1>
<p>그래서 React 개발자로서 함수형 컴포넌트를 전용으로 사용해야 합니다. 유지보수해야 할 레거시 코드베이스가 있는 경우를 제외하고요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"React에서 함수형 컴포넌트만 사용하고 더 이상 클래스 컴포넌트를 사용하지 않는 이유","description":"","date":"2024-05-12 23:07","slug":"2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact","content":"\n\n리액트 개발자로서, UI에 대해 함수형 컴포넌트 또는 클래스 컴포넌트를 사용할 수 있습니다. 클래스 컴포넌트는 리액트 개발자들이 선호하는 선택이었습니다. 그러나 2018년 리액트 버전 16.8에서 리액트 훅이 소개되면서 함수형 컴포넌트가 리액트 개발자들에게 선호되는 선택이 되었습니다.\n\n![이미지](/assets/img/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact_0.png)\n\n# 왜 리액트 개발자들이 과거에 클래스 컴포넌트를 함수형 컴포넌트보다 선호했는가\n\n리액트에서 컴포넌트 UI를 렌더링하는 두 가지 방법이 있습니다. 하나는 JavaScript 함수인 함수형 컴포넌트이고, 다른 하나는 JavaScript 클래스인 클래스 컴포넌트입니다. 클래스 컴포넌트는 UI를 동적으로 만들기 위해 로직과 상태를 추가할 수 있어서 리액트 개발자들에게 선호되었습니다. 함수형 컴포넌트는 과거에는 정적 UI만 렌더링했습니다. 특히 현대적인 웹 앱을 개발할 때 클래스 컴포넌트가 리액트 개발자들에게 선호되었던 이유가 분명합니다.\n\n\n\n# React에서 Hooks가 소개된 이유\n\n기존에는 클래스 컴포넌트가 UI를 렌더링하는 선호 방법이었지만, 이에는 문제점이 있었습니다. 하나의 문제는 클래스 컴포넌트 사이에서 로직과 상태 데이터를 공유하는 것이 어려웠다는 점입니다. 클래스 컴포넌트 사이에서 데이터 흐름을 관리하는 것은 번거로운 작업이었습니다. 또 다른 문제는 클래스 컴포넌트가 상태 로직이 커질수록 이해하기 어렵다는 것이었습니다. 이 복잡성으로 인해 컴포넌트를 렌더링하는 것이 더 어려워졌습니다. 이러한 문제를 해결하기 위해 React에서 Hooks가 소개되었습니다. Hooks를 사용하면 개발자가 함수형 컴포넌트에 더 많은 로직과 상태를 추가할 수 있으며, 이를 통해 컴포넌트 UI를 동적으로 만들고 로직을 재사용할 수 있게 되었습니다. 결과적으로 함수형 컴포넌트는 UI 컴포넌트를 렌더링하는 선호 방법이 되었으며, Hooks를 통해 개발자들이 함수형 컴포넌트를 통해 더 명확하고 관리하기 쉬운 코드를 작성할 수 있었습니다.\n\n# 결론\n\n그래서 React 개발자로서 함수형 컴포넌트를 전용으로 사용해야 합니다. 유지보수해야 할 레거시 코드베이스가 있는 경우를 제외하고요.","ogImage":{"url":"/assets/img/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact_0.png"},"coverImage":"/assets/img/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact_0.png","tag":["Tech"],"readingTime":2},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e리액트 개발자로서, UI에 대해 함수형 컴포넌트 또는 클래스 컴포넌트를 사용할 수 있습니다. 클래스 컴포넌트는 리액트 개발자들이 선호하는 선택이었습니다. 그러나 2018년 리액트 버전 16.8에서 리액트 훅이 소개되면서 함수형 컴포넌트가 리액트 개발자들에게 선호되는 선택이 되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e왜 리액트 개발자들이 과거에 클래스 컴포넌트를 함수형 컴포넌트보다 선호했는가\u003c/h1\u003e\n\u003cp\u003e리액트에서 컴포넌트 UI를 렌더링하는 두 가지 방법이 있습니다. 하나는 JavaScript 함수인 함수형 컴포넌트이고, 다른 하나는 JavaScript 클래스인 클래스 컴포넌트입니다. 클래스 컴포넌트는 UI를 동적으로 만들기 위해 로직과 상태를 추가할 수 있어서 리액트 개발자들에게 선호되었습니다. 함수형 컴포넌트는 과거에는 정적 UI만 렌더링했습니다. 특히 현대적인 웹 앱을 개발할 때 클래스 컴포넌트가 리액트 개발자들에게 선호되었던 이유가 분명합니다.\u003c/p\u003e\n\u003ch1\u003eReact에서 Hooks가 소개된 이유\u003c/h1\u003e\n\u003cp\u003e기존에는 클래스 컴포넌트가 UI를 렌더링하는 선호 방법이었지만, 이에는 문제점이 있었습니다. 하나의 문제는 클래스 컴포넌트 사이에서 로직과 상태 데이터를 공유하는 것이 어려웠다는 점입니다. 클래스 컴포넌트 사이에서 데이터 흐름을 관리하는 것은 번거로운 작업이었습니다. 또 다른 문제는 클래스 컴포넌트가 상태 로직이 커질수록 이해하기 어렵다는 것이었습니다. 이 복잡성으로 인해 컴포넌트를 렌더링하는 것이 더 어려워졌습니다. 이러한 문제를 해결하기 위해 React에서 Hooks가 소개되었습니다. Hooks를 사용하면 개발자가 함수형 컴포넌트에 더 많은 로직과 상태를 추가할 수 있으며, 이를 통해 컴포넌트 UI를 동적으로 만들고 로직을 재사용할 수 있게 되었습니다. 결과적으로 함수형 컴포넌트는 UI 컴포넌트를 렌더링하는 선호 방법이 되었으며, Hooks를 통해 개발자들이 함수형 컴포넌트를 통해 더 명확하고 관리하기 쉬운 코드를 작성할 수 있었습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e그래서 React 개발자로서 함수형 컴포넌트를 전용으로 사용해야 합니다. 유지보수해야 할 레거시 코드베이스가 있는 경우를 제외하고요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-WhyWeOnlyUseFunctionalComponentsandNoLongerClassComponentsInReact"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>