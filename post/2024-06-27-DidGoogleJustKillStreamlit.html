<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>구글이 Streamlit을 죽였는가 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-27-DidGoogleJustKillStreamlit" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="구글이 Streamlit을 죽였는가 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="구글이 Streamlit을 죽였는가 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-27-DidGoogleJustKillStreamlit" data-gatsby-head="true"/><meta name="twitter:title" content="구글이 Streamlit을 죽였는가 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-27 18:19" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">구글이 Streamlit을 죽였는가</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="구글이 Streamlit을 죽였는가" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 27, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-27-DidGoogleJustKillStreamlit&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>구글의 Mesop 프레임워크를 살펴보면 Streamlit보다 더 나은지 확인해보세요.</h2>
<p>내가 소파에 앉아 YouTube의 추천을 살펴보던 중 Google의 최신 오픈 소스 파이썬 프레임워크인 'Mesop'에 관한 Prompt Engineering의 비디오를 보게 되었습니다. 구글 팀이 내부 도구 및 빠른 프로토타이핑에 사용하는 'Mesop'라는 프레임워크입니다. 'Mesop'이 무엇을 의미하는지 궁금하다면, 너무 깊게 생각하지 마세요. 삶에는 모든 것이 의미가 있는 것은 아닙니다. 이 글을 읽는 Will이 있다면 아래 댓글에 남겨주세요.</p>
<p>아마 Mesop을 시도해보고 Streamlit보다 실제로 더 나은지 확인해봐야겠다고 생각했습니다. Streamlit은 코드 작성 경험이 매우 직관적하고 마법 같이 순식간에 앱을 생성할 수 있는 능력 때문에 정말 좋아합니다. 하지만 그 인터페이스를 보자마자 Streamlit임을 알 수 있습니다.</p>
<p>이 문제에 대처하기 위해 Python과 Tailwind CSS만 사용하여 아름다운 웹 앱을 개발하는 방법에 대해 작성한 블로그가 예상치 못하게 터져나왔습니다. 여기서 읽을 수 있습니다. 이 과정은 훨씬 더 제작 친화적이지만, 사용자 정의 가능한 프로토타입을 개발하려면 어떨까요?</p>
<div class="content-ad"></div>
<p>당신이 바로 Mesop이 하는 일입니다.</p>
<p>간략히 요약하면, Mesop은 아직 초기 단계에 있으므로 그것을 기반으로 SaaS 스타트업을 구축하기 위해 키보드로 코딩을 시작하지 마세요. 또한 Google에서 공식적으로 지원하지는 않습니다.</p>
<h1>Mesop의 기능</h1>
<ul>
<li>오픈 소스.</li>
<li>미리 구축된 구성 요소로 시작하기 쉽습니다.</li>
<li>Python에서 작성된 자연스러운 코드.</li>
<li>핫 리로드.</li>
<li>구성 요소는 기본적으로 Python 함수입니다.</li>
<li>Angular로 구축되었습니다.</li>
</ul>
<div class="content-ad"></div>
<h1>Mesop 시작하기</h1>
<p>안녕하세요! 메소프 기술의 다양한 기능에 대한 장황한 문학작품으로 사람들을 지루하게 만드는 것을 싫어하기 때문에, 메소프로 기본 UI를 만드는 것으로 바로 도입하겠습니다. 메소프로 작업할 때 알아두어야 할 주요한 세 가지 구성 요소가 있습니다:</p>
<ul>
<li>상태 클래스: 이는 세션의 상태 역할을 하며 다른 구성 요소 간에 데이터를 공유하는 능력을 제공합니다.</li>
<li>페이지 및 이벤트: 앱의 주요 UI입니다.</li>
<li>스타일링 요소: CSS 스타일 (Tailwind 지원은 아직 제공되지 않습니다)</li>
</ul>
<p>시작하기 전에 pip install mesop을 사용해서 메소프를 설치해보세요. 함께 즐거운 개발 시간 보내시길 바랍니다!</p>
<div class="content-ad"></div>
<h2>State 클래스</h2>
<p>앱 내에서 사용되는 모든 모델은 데코레이터 @me.stateclass를 사용하여 state 클래스를 인스턴스화하는 데 사용됩니다. 예를 들어, 제목과 개요를 사용하여 기사를 생성하는 GenAI 앱을 개발 중이라고 가정해보겠습니다. 'Article'이라는 이름의 state 클래스를 생성해야 합니다. 해당 state 클래스는 다음과 같이 보일 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> mesop <span class="hljs-keyword">as</span> me

@me.<span class="hljs-property">stateclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Article</span>:
    <span class="hljs-attr">title</span>: str
    <span class="hljs-attr">outline</span>: str
    <span class="hljs-attr">response</span>: str
</code></pre>
<p>우리가 생성하는 각 함수나 구성 요소에서 이 state 클래스 데이터는 유지되며 전역적으로 액세스할 수 있습니다.</p>
<div class="content-ad"></div>
<h2>페이지 및 이벤트</h2>
<p>모든 페이지는 Mesop에서 @me.page() 데코레이터를 사용하여 태그가 지정됩니다.</p>
<pre><code class="hljs language-js">@me.<span class="hljs-title function_">page</span>()
def <span class="hljs-title function_">app</span>():
    me.<span class="hljs-title function_">input</span>(label=<span class="hljs-string">"제목"</span>, type=<span class="hljs-string">"text"</span>)
    me.<span class="hljs-title function_">input</span>(label=<span class="hljs-string">"개요"</span>, type=<span class="hljs-string">"text"</span>)
</code></pre>
<p>위의 코드는 두 개의 입력 필드가 있는 기본 페이지를 생성합니다. 이전에 만든 상태 클래스에 데이터를 저장할 수 있도록 각 필드에는 별도의 함수가 필요합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">def <span class="hljs-title function_">on_title_input</span>(<span class="hljs-attr">title</span>: me.<span class="hljs-property">InputEvent</span>):
    s = me.<span class="hljs-title function_">state</span>(<span class="hljs-title class_">Article</span>)
    s.<span class="hljs-property">title</span> = title.<span class="hljs-property">value</span>

def <span class="hljs-title function_">on_outline_input</span>(<span class="hljs-attr">outline</span>: me.<span class="hljs-property">InputEvent</span>):
    s = me.<span class="hljs-title function_">state</span>(<span class="hljs-title class_">Article</span>)
    s.<span class="hljs-property">outline</span> = outline.<span class="hljs-property">value</span>

@me.<span class="hljs-title function_">page</span>()
def <span class="hljs-title function_">app</span>():
    me.<span class="hljs-title function_">input</span>(label=<span class="hljs-string">"Title"</span>, on_input=on_title_input, type=<span class="hljs-string">"text"</span>)
    me.<span class="hljs-title function_">input</span>(label=<span class="hljs-string">"Outline"</span>, on_input=on_outline_input, type=<span class="hljs-string">"text"</span>)
</code></pre>
<p>상태 클래스에 액세스하려면 me.state() 함수를 사용합니다. 그 인스턴스는 변수 s에 저장됩니다.</p>
<p>Mesop에서 이벤트는 InputEvent, ClickEvent 등의 클래스를 사용하여 처리됩니다.</p>
<p>클릭 이벤트를 처리하기 위해 다른 함수를 호출하여 입력 데이터를 제출할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 응답 스키마
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Blog</span>(typing_extensions.<span class="hljs-property">TypedDict</span>):
    <span class="hljs-attr">title</span>: str
    <span class="hljs-attr">content</span>: str

def <span class="hljs-title function_">on_title_input</span>(<span class="hljs-attr">title</span>: me.<span class="hljs-property">InputEvent</span>):
    s = me.<span class="hljs-title function_">state</span>(<span class="hljs-title class_">Article</span>)
    s.<span class="hljs-property">title</span> = title.<span class="hljs-property">value</span>

def <span class="hljs-title function_">on_outline_input</span>(<span class="hljs-attr">outline</span>: me.<span class="hljs-property">InputEvent</span>):
    s = me.<span class="hljs-title function_">state</span>(<span class="hljs-title class_">Article</span>)
    s.<span class="hljs-property">outline</span> = outline.<span class="hljs-property">value</span>

def <span class="hljs-title function_">on_click</span>(<span class="hljs-attr">click</span>: me.<span class="hljs-property">ClickEvent</span>):
    s = me.<span class="hljs-title function_">state</span>(<span class="hljs-title class_">Article</span>)
    prompt = f<span class="hljs-string">"다음 기사 제목 및 개요를 사용하여 블로그를 작성해주세요: &#x3C;article_title>{s.title}&#x3C;/article_title>&#x3C;article_outline>{s.outline}&#x3C;/article_outline>. 최종 블로그와 제목을 마크다운 형식으로 반환하세요."</span>
    # 훅 <span class="hljs-variable constant_">URL</span>을 저장할 환경 변수 추가
    response = model.<span class="hljs-title function_">generate_content</span>(
                prompt,
                generation_config=genai.<span class="hljs-title class_">GenerationConfig</span>(
                    response_mime_type=<span class="hljs-string">"application/json"</span>,
                    response_schema=<span class="hljs-title class_">Blog</span>,
                    temperature=<span class="hljs-number">0.8</span>
                ))
    data = json.<span class="hljs-title function_">loads</span>(response.<span class="hljs-property">text</span>)
    s.<span class="hljs-property">response</span> = data

@me.<span class="hljs-title function_">page</span>()
def <span class="hljs-title function_">app</span>():
    me.<span class="hljs-title function_">input</span>(label=<span class="hljs-string">"제목"</span>, on_input=on_title_input, type=<span class="hljs-string">"text"</span>)
    me.<span class="hljs-title function_">input</span>(label=<span class="hljs-string">"개요"</span>, on_input=on_outline_input, type=<span class="hljs-string">"text"</span>)
    me.<span class="hljs-title function_">button</span>(<span class="hljs-string">"블로그 생성"</span>, on_click=on_click)
</code></pre>
<p>재미있는 일을 위해 Mesop을 사용하여 Gemini 모델을 활용해 블로그를 생성할 것입니다. on_click 함수는 Article 인스턴스로부터 data s.title과 s.outline를 가져와서 만든 prompt에 주입할 것입니다. LLM의 응답은 블로그 내용을 담은 JSON일 것입니다.</p>
<h2>스타일링</h2>
<p>Mesop에서 요소를 스타일링하는 것은 기존 CSS 속성과 유사하지만, 모든 속성은 me.style()의 매개변수입니다.</p>
<div class="content-ad"></div>
<p>me.style()을 사용하여 스타일을 정의한 후, 해당 스타일을 변수에 저장하여 컴포넌트에서 매개변수로 호출할 수 있습니다.</p>
<pre><code class="hljs language-js">_STYLE_INPUT_WIDTH = me.<span class="hljs-title class_">Style</span>(width=<span class="hljs-string">"100%"</span>)

_STYLE_BUTTON = me.<span class="hljs-title class_">Style</span>(
    background=<span class="hljs-string">"#1976D2"</span>,
    color=<span class="hljs-string">"#fff"</span>,
    padding=me.<span class="hljs-property">Padding</span>.<span class="hljs-title function_">symmetric</span>(horizontal=<span class="hljs-number">20</span>, vertical=<span class="hljs-number">10</span>),
    font_size=<span class="hljs-string">"16px"</span>,
    cursor=<span class="hljs-string">"pointer"</span>,
    margin=me.<span class="hljs-title class_">Margin</span>(bottom=<span class="hljs-number">20</span>),
)

@me.<span class="hljs-title function_">page</span>()
def <span class="hljs-title function_">app</span>():
    <span class="hljs-keyword">with</span> me.<span class="hljs-title function_">box</span>(style=_STYLE_CONTAINER):
        s = me.<span class="hljs-title function_">state</span>(<span class="hljs-title class_">Article</span>)
        <span class="hljs-keyword">with</span> me.<span class="hljs-title function_">box</span>(style=_STYLE_MAIN_COLUMN):
            me.<span class="hljs-title function_">input</span>(label=<span class="hljs-string">"Title"</span>, on_input=on_title_input, type=<span class="hljs-string">"text"</span>, style=_STYLE_INPUT_WIDTH)
            me.<span class="hljs-title function_">input</span>(label=<span class="hljs-string">"Outline"</span>, on_input=on_outline_input, type=<span class="hljs-string">"text"</span>, style=_STYLE_INPUT_WIDTH)
            me.<span class="hljs-title function_">button</span>(<span class="hljs-string">"Generate Blog"</span>, on_click=on_click, style=_STYLE_BUTTON)
    <span class="hljs-keyword">with</span> me.<span class="hljs-title function_">box</span>(style=_STYLE_PREVIEW_CONTAINER):
        <span class="hljs-keyword">if</span> s.<span class="hljs-property">response</span>:
            me.<span class="hljs-title function_">markdown</span>(f<span class="hljs-string">"{s.response['content']}"</span>, style=_STYLE_PREVIEW)
</code></pre>
<h1>최종 인터페이스</h1>
<img src="/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png">
<div class="content-ad"></div>
<p>안녕하세요! 테이블 태그를 마크다운 형식으로 변경해 드릴게요.</p>
<p>| Not the best-looking UI, but that’s because I didn’t make the effort to style it enough. It still looks a lot better than raw HTML with just a few tweaks here and there. With the ability to use all CSS properties for the components, you can make the UI unique. |</p>
<h1>Is Streamlit dead?</h1>
<p>No, absolutely not. Mesop is still under development, and the documentation lacks in certain aspects. Deploying a Mesop application is not straightforward and requires containerization unless you are deploying it directly to Google Cloud.</p>
<p>Streamlit still comes with its own set of benefits and is fundamentally stronger compared to Mesop, especially if you are looking to build something in the data visualization domain. Moreover, Streamlit Cloud is a boon for anyone looking to share their applications absolutely free of charge.</p>
<p>무엇이든 더 도와드릴게요!</p>
<div class="content-ad"></div>
<p>그러나 Mesop은 성장 잠재력이 있으며 매일 업데이트를 받고 있어 가벼운 성격으로 REST API에서 작동하는 빠른 도구 및 간단한 프로토 타입에 더 적합해지고 있습니다.</p>
<p>Mesop의 Will과 다른 기여자들에게 시간과 노력을 들여 이러한 프레임워크를 개발하고 유지하는 데 기쁨을 느낍니다.</p>
<h1>더 많은 UI 프레임워크가 필요합니다</h1>
<p>Streamlit, Nicegui, Gradio 그리고 이제 Mesop와 같은 새로운 Python UI 프레임워크가 등장하는 것을 항상 좋게 생각합니다. Python의 관용구 문법은 코딩을 훨씬 더 접근 가능하게 만들어주며, 이는 지금 Streamlit 프로젝트의 많은 수로부터 명확히 확인됩니다.</p>
<div class="content-ad"></div>
<p>행운이던지 불행이던지, 파이썬이 내가 처음으로 배운 프로그래밍 언어였고, 그것에 즉시 사랑에 빠졌어요. 이와 같은 더 많은 프레임워크로 인해, Python은 사용량이 급격히 증가할 것이고, 미래에는 더 많은 실무급 Python 앱들을 볼 수 있기를 희망해요.</p>
<p>저는 Mesop에 관한 이 짧은 블로그를 좋아해주셨으면 좋겠어요. 더 깊이 파고들고 싶었지만, 제한된 시간 때문에 글을 짧게 유지하게 된 것과, 우리 모두가 금붕어 수준의 집중력을 고려했기 때문이에요. 만약 이 글에 박수를 보내주시고, 파이썬과 Google 커뮤니티의 더 많은 사용자와 공유해주시고, 앞으로의 다른 글들을 위해 팔로우해주시면 정말 감사하겠어요.</p>
<h1>링크</h1>
<ul>
<li>Github</li>
<li>Mesop</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"구글이 Streamlit을 죽였는가","description":"","date":"2024-06-27 18:19","slug":"2024-06-27-DidGoogleJustKillStreamlit","content":"\n\n## 구글의 Mesop 프레임워크를 살펴보면 Streamlit보다 더 나은지 확인해보세요.\n\n내가 소파에 앉아 YouTube의 추천을 살펴보던 중 Google의 최신 오픈 소스 파이썬 프레임워크인 'Mesop'에 관한 Prompt Engineering의 비디오를 보게 되었습니다. 구글 팀이 내부 도구 및 빠른 프로토타이핑에 사용하는 'Mesop'라는 프레임워크입니다. 'Mesop'이 무엇을 의미하는지 궁금하다면, 너무 깊게 생각하지 마세요. 삶에는 모든 것이 의미가 있는 것은 아닙니다. 이 글을 읽는 Will이 있다면 아래 댓글에 남겨주세요.\n\n아마 Mesop을 시도해보고 Streamlit보다 실제로 더 나은지 확인해봐야겠다고 생각했습니다. Streamlit은 코드 작성 경험이 매우 직관적하고 마법 같이 순식간에 앱을 생성할 수 있는 능력 때문에 정말 좋아합니다. 하지만 그 인터페이스를 보자마자 Streamlit임을 알 수 있습니다.\n\n이 문제에 대처하기 위해 Python과 Tailwind CSS만 사용하여 아름다운 웹 앱을 개발하는 방법에 대해 작성한 블로그가 예상치 못하게 터져나왔습니다. 여기서 읽을 수 있습니다. 이 과정은 훨씬 더 제작 친화적이지만, 사용자 정의 가능한 프로토타입을 개발하려면 어떨까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신이 바로 Mesop이 하는 일입니다.\n\n간략히 요약하면, Mesop은 아직 초기 단계에 있으므로 그것을 기반으로 SaaS 스타트업을 구축하기 위해 키보드로 코딩을 시작하지 마세요. 또한 Google에서 공식적으로 지원하지는 않습니다.\n\n# Mesop의 기능\n\n- 오픈 소스.\n- 미리 구축된 구성 요소로 시작하기 쉽습니다.\n- Python에서 작성된 자연스러운 코드.\n- 핫 리로드.\n- 구성 요소는 기본적으로 Python 함수입니다.\n- Angular로 구축되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Mesop 시작하기\n\n안녕하세요! 메소프 기술의 다양한 기능에 대한 장황한 문학작품으로 사람들을 지루하게 만드는 것을 싫어하기 때문에, 메소프로 기본 UI를 만드는 것으로 바로 도입하겠습니다. 메소프로 작업할 때 알아두어야 할 주요한 세 가지 구성 요소가 있습니다:\n\n- 상태 클래스: 이는 세션의 상태 역할을 하며 다른 구성 요소 간에 데이터를 공유하는 능력을 제공합니다.\n- 페이지 및 이벤트: 앱의 주요 UI입니다.\n- 스타일링 요소: CSS 스타일 (Tailwind 지원은 아직 제공되지 않습니다)\n\n시작하기 전에 pip install mesop을 사용해서 메소프를 설치해보세요. 함께 즐거운 개발 시간 보내시길 바랍니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## State 클래스\n\n앱 내에서 사용되는 모든 모델은 데코레이터 @me.stateclass를 사용하여 state 클래스를 인스턴스화하는 데 사용됩니다. 예를 들어, 제목과 개요를 사용하여 기사를 생성하는 GenAI 앱을 개발 중이라고 가정해보겠습니다. 'Article'이라는 이름의 state 클래스를 생성해야 합니다. 해당 state 클래스는 다음과 같이 보일 것입니다:\n\n```js\nimport mesop as me\n\n@me.stateclass\nclass Article:\n    title: str\n    outline: str\n    response: str\n```\n\n우리가 생성하는 각 함수나 구성 요소에서 이 state 클래스 데이터는 유지되며 전역적으로 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 페이지 및 이벤트\n\n모든 페이지는 Mesop에서 @me.page() 데코레이터를 사용하여 태그가 지정됩니다.\n\n```js\n@me.page()\ndef app():\n    me.input(label=\"제목\", type=\"text\")\n    me.input(label=\"개요\", type=\"text\")\n```\n\n위의 코드는 두 개의 입력 필드가 있는 기본 페이지를 생성합니다. 이전에 만든 상태 클래스에 데이터를 저장할 수 있도록 각 필드에는 별도의 함수가 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndef on_title_input(title: me.InputEvent):\n    s = me.state(Article)\n    s.title = title.value\n\ndef on_outline_input(outline: me.InputEvent):\n    s = me.state(Article)\n    s.outline = outline.value\n\n@me.page()\ndef app():\n    me.input(label=\"Title\", on_input=on_title_input, type=\"text\")\n    me.input(label=\"Outline\", on_input=on_outline_input, type=\"text\")\r\n```\n\n상태 클래스에 액세스하려면 me.state() 함수를 사용합니다. 그 인스턴스는 변수 s에 저장됩니다.\n\nMesop에서 이벤트는 InputEvent, ClickEvent 등의 클래스를 사용하여 처리됩니다.\n\n클릭 이벤트를 처리하기 위해 다른 함수를 호출하여 입력 데이터를 제출할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 응답 스키마\nclass Blog(typing_extensions.TypedDict):\n    title: str\n    content: str\n\ndef on_title_input(title: me.InputEvent):\n    s = me.state(Article)\n    s.title = title.value\n\ndef on_outline_input(outline: me.InputEvent):\n    s = me.state(Article)\n    s.outline = outline.value\n\ndef on_click(click: me.ClickEvent):\n    s = me.state(Article)\n    prompt = f\"다음 기사 제목 및 개요를 사용하여 블로그를 작성해주세요: \u003carticle_title\u003e{s.title}\u003c/article_title\u003e\u003carticle_outline\u003e{s.outline}\u003c/article_outline\u003e. 최종 블로그와 제목을 마크다운 형식으로 반환하세요.\"\n    # 훅 URL을 저장할 환경 변수 추가\n    response = model.generate_content(\n                prompt,\n                generation_config=genai.GenerationConfig(\n                    response_mime_type=\"application/json\",\n                    response_schema=Blog,\n                    temperature=0.8\n                ))\n    data = json.loads(response.text)\n    s.response = data\n\n@me.page()\ndef app():\n    me.input(label=\"제목\", on_input=on_title_input, type=\"text\")\n    me.input(label=\"개요\", on_input=on_outline_input, type=\"text\")\n    me.button(\"블로그 생성\", on_click=on_click)\r\n```\n\n재미있는 일을 위해 Mesop을 사용하여 Gemini 모델을 활용해 블로그를 생성할 것입니다. on_click 함수는 Article 인스턴스로부터 data s.title과 s.outline를 가져와서 만든 prompt에 주입할 것입니다. LLM의 응답은 블로그 내용을 담은 JSON일 것입니다.\n\n## 스타일링\n\nMesop에서 요소를 스타일링하는 것은 기존 CSS 속성과 유사하지만, 모든 속성은 me.style()의 매개변수입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nme.style()을 사용하여 스타일을 정의한 후, 해당 스타일을 변수에 저장하여 컴포넌트에서 매개변수로 호출할 수 있습니다.\n\n```js\n_STYLE_INPUT_WIDTH = me.Style(width=\"100%\")\n\n_STYLE_BUTTON = me.Style(\n    background=\"#1976D2\",\n    color=\"#fff\",\n    padding=me.Padding.symmetric(horizontal=20, vertical=10),\n    font_size=\"16px\",\n    cursor=\"pointer\",\n    margin=me.Margin(bottom=20),\n)\n\n@me.page()\ndef app():\n    with me.box(style=_STYLE_CONTAINER):\n        s = me.state(Article)\n        with me.box(style=_STYLE_MAIN_COLUMN):\n            me.input(label=\"Title\", on_input=on_title_input, type=\"text\", style=_STYLE_INPUT_WIDTH)\n            me.input(label=\"Outline\", on_input=on_outline_input, type=\"text\", style=_STYLE_INPUT_WIDTH)\n            me.button(\"Generate Blog\", on_click=on_click, style=_STYLE_BUTTON)\n    with me.box(style=_STYLE_PREVIEW_CONTAINER):\n        if s.response:\n            me.markdown(f\"{s.response['content']}\", style=_STYLE_PREVIEW)\n```\n\n# 최종 인터페이스\n\n\u003cimg src=\"/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 테이블 태그를 마크다운 형식으로 변경해 드릴게요. \n\n\n| Not the best-looking UI, but that’s because I didn’t make the effort to style it enough. It still looks a lot better than raw HTML with just a few tweaks here and there. With the ability to use all CSS properties for the components, you can make the UI unique. |\n\n# Is Streamlit dead?\n\nNo, absolutely not. Mesop is still under development, and the documentation lacks in certain aspects. Deploying a Mesop application is not straightforward and requires containerization unless you are deploying it directly to Google Cloud.\n\nStreamlit still comes with its own set of benefits and is fundamentally stronger compared to Mesop, especially if you are looking to build something in the data visualization domain. Moreover, Streamlit Cloud is a boon for anyone looking to share their applications absolutely free of charge.\n\n\n무엇이든 더 도와드릴게요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 Mesop은 성장 잠재력이 있으며 매일 업데이트를 받고 있어 가벼운 성격으로 REST API에서 작동하는 빠른 도구 및 간단한 프로토 타입에 더 적합해지고 있습니다.\n\nMesop의 Will과 다른 기여자들에게 시간과 노력을 들여 이러한 프레임워크를 개발하고 유지하는 데 기쁨을 느낍니다.\n\n# 더 많은 UI 프레임워크가 필요합니다\n\nStreamlit, Nicegui, Gradio 그리고 이제 Mesop와 같은 새로운 Python UI 프레임워크가 등장하는 것을 항상 좋게 생각합니다. Python의 관용구 문법은 코딩을 훨씬 더 접근 가능하게 만들어주며, 이는 지금 Streamlit 프로젝트의 많은 수로부터 명확히 확인됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행운이던지 불행이던지, 파이썬이 내가 처음으로 배운 프로그래밍 언어였고, 그것에 즉시 사랑에 빠졌어요. 이와 같은 더 많은 프레임워크로 인해, Python은 사용량이 급격히 증가할 것이고, 미래에는 더 많은 실무급 Python 앱들을 볼 수 있기를 희망해요.\n\n저는 Mesop에 관한 이 짧은 블로그를 좋아해주셨으면 좋겠어요. 더 깊이 파고들고 싶었지만, 제한된 시간 때문에 글을 짧게 유지하게 된 것과, 우리 모두가 금붕어 수준의 집중력을 고려했기 때문이에요. 만약 이 글에 박수를 보내주시고, 파이썬과 Google 커뮤니티의 더 많은 사용자와 공유해주시고, 앞으로의 다른 글들을 위해 팔로우해주시면 정말 감사하겠어요.\n\n# 링크\n\n- Github\n- Mesop","ogImage":{"url":"/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png"},"coverImage":"/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e구글의 Mesop 프레임워크를 살펴보면 Streamlit보다 더 나은지 확인해보세요.\u003c/h2\u003e\n\u003cp\u003e내가 소파에 앉아 YouTube의 추천을 살펴보던 중 Google의 최신 오픈 소스 파이썬 프레임워크인 'Mesop'에 관한 Prompt Engineering의 비디오를 보게 되었습니다. 구글 팀이 내부 도구 및 빠른 프로토타이핑에 사용하는 'Mesop'라는 프레임워크입니다. 'Mesop'이 무엇을 의미하는지 궁금하다면, 너무 깊게 생각하지 마세요. 삶에는 모든 것이 의미가 있는 것은 아닙니다. 이 글을 읽는 Will이 있다면 아래 댓글에 남겨주세요.\u003c/p\u003e\n\u003cp\u003e아마 Mesop을 시도해보고 Streamlit보다 실제로 더 나은지 확인해봐야겠다고 생각했습니다. Streamlit은 코드 작성 경험이 매우 직관적하고 마법 같이 순식간에 앱을 생성할 수 있는 능력 때문에 정말 좋아합니다. 하지만 그 인터페이스를 보자마자 Streamlit임을 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 문제에 대처하기 위해 Python과 Tailwind CSS만 사용하여 아름다운 웹 앱을 개발하는 방법에 대해 작성한 블로그가 예상치 못하게 터져나왔습니다. 여기서 읽을 수 있습니다. 이 과정은 훨씬 더 제작 친화적이지만, 사용자 정의 가능한 프로토타입을 개발하려면 어떨까요?\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e당신이 바로 Mesop이 하는 일입니다.\u003c/p\u003e\n\u003cp\u003e간략히 요약하면, Mesop은 아직 초기 단계에 있으므로 그것을 기반으로 SaaS 스타트업을 구축하기 위해 키보드로 코딩을 시작하지 마세요. 또한 Google에서 공식적으로 지원하지는 않습니다.\u003c/p\u003e\n\u003ch1\u003eMesop의 기능\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e오픈 소스.\u003c/li\u003e\n\u003cli\u003e미리 구축된 구성 요소로 시작하기 쉽습니다.\u003c/li\u003e\n\u003cli\u003ePython에서 작성된 자연스러운 코드.\u003c/li\u003e\n\u003cli\u003e핫 리로드.\u003c/li\u003e\n\u003cli\u003e구성 요소는 기본적으로 Python 함수입니다.\u003c/li\u003e\n\u003cli\u003eAngular로 구축되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eMesop 시작하기\u003c/h1\u003e\n\u003cp\u003e안녕하세요! 메소프 기술의 다양한 기능에 대한 장황한 문학작품으로 사람들을 지루하게 만드는 것을 싫어하기 때문에, 메소프로 기본 UI를 만드는 것으로 바로 도입하겠습니다. 메소프로 작업할 때 알아두어야 할 주요한 세 가지 구성 요소가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e상태 클래스: 이는 세션의 상태 역할을 하며 다른 구성 요소 간에 데이터를 공유하는 능력을 제공합니다.\u003c/li\u003e\n\u003cli\u003e페이지 및 이벤트: 앱의 주요 UI입니다.\u003c/li\u003e\n\u003cli\u003e스타일링 요소: CSS 스타일 (Tailwind 지원은 아직 제공되지 않습니다)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e시작하기 전에 pip install mesop을 사용해서 메소프를 설치해보세요. 함께 즐거운 개발 시간 보내시길 바랍니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003eState 클래스\u003c/h2\u003e\n\u003cp\u003e앱 내에서 사용되는 모든 모델은 데코레이터 @me.stateclass를 사용하여 state 클래스를 인스턴스화하는 데 사용됩니다. 예를 들어, 제목과 개요를 사용하여 기사를 생성하는 GenAI 앱을 개발 중이라고 가정해보겠습니다. 'Article'이라는 이름의 state 클래스를 생성해야 합니다. 해당 state 클래스는 다음과 같이 보일 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e mesop \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e me\n\n@me.\u003cspan class=\"hljs-property\"\u003estateclass\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArticle\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: str\n    \u003cspan class=\"hljs-attr\"\u003eoutline\u003c/span\u003e: str\n    \u003cspan class=\"hljs-attr\"\u003eresponse\u003c/span\u003e: str\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리가 생성하는 각 함수나 구성 요소에서 이 state 클래스 데이터는 유지되며 전역적으로 액세스할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e페이지 및 이벤트\u003c/h2\u003e\n\u003cp\u003e모든 페이지는 Mesop에서 @me.page() 데코레이터를 사용하여 태그가 지정됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@me.\u003cspan class=\"hljs-title function_\"\u003epage\u003c/span\u003e()\ndef \u003cspan class=\"hljs-title function_\"\u003eapp\u003c/span\u003e():\n    me.\u003cspan class=\"hljs-title function_\"\u003einput\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e\"제목\"\u003c/span\u003e, type=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e)\n    me.\u003cspan class=\"hljs-title function_\"\u003einput\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e\"개요\"\u003c/span\u003e, type=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 코드는 두 개의 입력 필드가 있는 기본 페이지를 생성합니다. 이전에 만든 상태 클래스에 데이터를 저장할 수 있도록 각 필드에는 별도의 함수가 필요합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eon_title_input\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: me.\u003cspan class=\"hljs-property\"\u003eInputEvent\u003c/span\u003e):\n    s = me.\u003cspan class=\"hljs-title function_\"\u003estate\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArticle\u003c/span\u003e)\n    s.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e = title.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e\n\ndef \u003cspan class=\"hljs-title function_\"\u003eon_outline_input\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eoutline\u003c/span\u003e: me.\u003cspan class=\"hljs-property\"\u003eInputEvent\u003c/span\u003e):\n    s = me.\u003cspan class=\"hljs-title function_\"\u003estate\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArticle\u003c/span\u003e)\n    s.\u003cspan class=\"hljs-property\"\u003eoutline\u003c/span\u003e = outline.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e\n\n@me.\u003cspan class=\"hljs-title function_\"\u003epage\u003c/span\u003e()\ndef \u003cspan class=\"hljs-title function_\"\u003eapp\u003c/span\u003e():\n    me.\u003cspan class=\"hljs-title function_\"\u003einput\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e\"Title\"\u003c/span\u003e, on_input=on_title_input, type=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e)\n    me.\u003cspan class=\"hljs-title function_\"\u003einput\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e\"Outline\"\u003c/span\u003e, on_input=on_outline_input, type=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e상태 클래스에 액세스하려면 me.state() 함수를 사용합니다. 그 인스턴스는 변수 s에 저장됩니다.\u003c/p\u003e\n\u003cp\u003eMesop에서 이벤트는 InputEvent, ClickEvent 등의 클래스를 사용하여 처리됩니다.\u003c/p\u003e\n\u003cp\u003e클릭 이벤트를 처리하기 위해 다른 함수를 호출하여 입력 데이터를 제출할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 응답 스키마\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBlog\u003c/span\u003e(typing_extensions.\u003cspan class=\"hljs-property\"\u003eTypedDict\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: str\n    \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: str\n\ndef \u003cspan class=\"hljs-title function_\"\u003eon_title_input\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: me.\u003cspan class=\"hljs-property\"\u003eInputEvent\u003c/span\u003e):\n    s = me.\u003cspan class=\"hljs-title function_\"\u003estate\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArticle\u003c/span\u003e)\n    s.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e = title.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e\n\ndef \u003cspan class=\"hljs-title function_\"\u003eon_outline_input\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eoutline\u003c/span\u003e: me.\u003cspan class=\"hljs-property\"\u003eInputEvent\u003c/span\u003e):\n    s = me.\u003cspan class=\"hljs-title function_\"\u003estate\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArticle\u003c/span\u003e)\n    s.\u003cspan class=\"hljs-property\"\u003eoutline\u003c/span\u003e = outline.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e\n\ndef \u003cspan class=\"hljs-title function_\"\u003eon_click\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eclick\u003c/span\u003e: me.\u003cspan class=\"hljs-property\"\u003eClickEvent\u003c/span\u003e):\n    s = me.\u003cspan class=\"hljs-title function_\"\u003estate\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArticle\u003c/span\u003e)\n    prompt = f\u003cspan class=\"hljs-string\"\u003e\"다음 기사 제목 및 개요를 사용하여 블로그를 작성해주세요: \u0026#x3C;article_title\u003e{s.title}\u0026#x3C;/article_title\u003e\u0026#x3C;article_outline\u003e{s.outline}\u0026#x3C;/article_outline\u003e. 최종 블로그와 제목을 마크다운 형식으로 반환하세요.\"\u003c/span\u003e\n    # 훅 \u003cspan class=\"hljs-variable constant_\"\u003eURL\u003c/span\u003e을 저장할 환경 변수 추가\n    response = model.\u003cspan class=\"hljs-title function_\"\u003egenerate_content\u003c/span\u003e(\n                prompt,\n                generation_config=genai.\u003cspan class=\"hljs-title class_\"\u003eGenerationConfig\u003c/span\u003e(\n                    response_mime_type=\u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e,\n                    response_schema=\u003cspan class=\"hljs-title class_\"\u003eBlog\u003c/span\u003e,\n                    temperature=\u003cspan class=\"hljs-number\"\u003e0.8\u003c/span\u003e\n                ))\n    data = json.\u003cspan class=\"hljs-title function_\"\u003eloads\u003c/span\u003e(response.\u003cspan class=\"hljs-property\"\u003etext\u003c/span\u003e)\n    s.\u003cspan class=\"hljs-property\"\u003eresponse\u003c/span\u003e = data\n\n@me.\u003cspan class=\"hljs-title function_\"\u003epage\u003c/span\u003e()\ndef \u003cspan class=\"hljs-title function_\"\u003eapp\u003c/span\u003e():\n    me.\u003cspan class=\"hljs-title function_\"\u003einput\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e\"제목\"\u003c/span\u003e, on_input=on_title_input, type=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e)\n    me.\u003cspan class=\"hljs-title function_\"\u003einput\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e\"개요\"\u003c/span\u003e, on_input=on_outline_input, type=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e)\n    me.\u003cspan class=\"hljs-title function_\"\u003ebutton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"블로그 생성\"\u003c/span\u003e, on_click=on_click)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e재미있는 일을 위해 Mesop을 사용하여 Gemini 모델을 활용해 블로그를 생성할 것입니다. on_click 함수는 Article 인스턴스로부터 data s.title과 s.outline를 가져와서 만든 prompt에 주입할 것입니다. LLM의 응답은 블로그 내용을 담은 JSON일 것입니다.\u003c/p\u003e\n\u003ch2\u003e스타일링\u003c/h2\u003e\n\u003cp\u003eMesop에서 요소를 스타일링하는 것은 기존 CSS 속성과 유사하지만, 모든 속성은 me.style()의 매개변수입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eme.style()을 사용하여 스타일을 정의한 후, 해당 스타일을 변수에 저장하여 컴포넌트에서 매개변수로 호출할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e_STYLE_INPUT_WIDTH = me.\u003cspan class=\"hljs-title class_\"\u003eStyle\u003c/span\u003e(width=\u003cspan class=\"hljs-string\"\u003e\"100%\"\u003c/span\u003e)\n\n_STYLE_BUTTON = me.\u003cspan class=\"hljs-title class_\"\u003eStyle\u003c/span\u003e(\n    background=\u003cspan class=\"hljs-string\"\u003e\"#1976D2\"\u003c/span\u003e,\n    color=\u003cspan class=\"hljs-string\"\u003e\"#fff\"\u003c/span\u003e,\n    padding=me.\u003cspan class=\"hljs-property\"\u003ePadding\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esymmetric\u003c/span\u003e(horizontal=\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, vertical=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e),\n    font_size=\u003cspan class=\"hljs-string\"\u003e\"16px\"\u003c/span\u003e,\n    cursor=\u003cspan class=\"hljs-string\"\u003e\"pointer\"\u003c/span\u003e,\n    margin=me.\u003cspan class=\"hljs-title class_\"\u003eMargin\u003c/span\u003e(bottom=\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e),\n)\n\n@me.\u003cspan class=\"hljs-title function_\"\u003epage\u003c/span\u003e()\ndef \u003cspan class=\"hljs-title function_\"\u003eapp\u003c/span\u003e():\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e me.\u003cspan class=\"hljs-title function_\"\u003ebox\u003c/span\u003e(style=_STYLE_CONTAINER):\n        s = me.\u003cspan class=\"hljs-title function_\"\u003estate\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArticle\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e me.\u003cspan class=\"hljs-title function_\"\u003ebox\u003c/span\u003e(style=_STYLE_MAIN_COLUMN):\n            me.\u003cspan class=\"hljs-title function_\"\u003einput\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e\"Title\"\u003c/span\u003e, on_input=on_title_input, type=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e, style=_STYLE_INPUT_WIDTH)\n            me.\u003cspan class=\"hljs-title function_\"\u003einput\u003c/span\u003e(label=\u003cspan class=\"hljs-string\"\u003e\"Outline\"\u003c/span\u003e, on_input=on_outline_input, type=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e, style=_STYLE_INPUT_WIDTH)\n            me.\u003cspan class=\"hljs-title function_\"\u003ebutton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Generate Blog\"\u003c/span\u003e, on_click=on_click, style=_STYLE_BUTTON)\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e me.\u003cspan class=\"hljs-title function_\"\u003ebox\u003c/span\u003e(style=_STYLE_PREVIEW_CONTAINER):\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e s.\u003cspan class=\"hljs-property\"\u003eresponse\u003c/span\u003e:\n            me.\u003cspan class=\"hljs-title function_\"\u003emarkdown\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{s.response['content']}\"\u003c/span\u003e, style=_STYLE_PREVIEW)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e최종 인터페이스\u003c/h1\u003e\n\u003cimg src=\"/assets/img/2024-06-27-DidGoogleJustKillStreamlit_0.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e안녕하세요! 테이블 태그를 마크다운 형식으로 변경해 드릴게요.\u003c/p\u003e\n\u003cp\u003e| Not the best-looking UI, but that’s because I didn’t make the effort to style it enough. It still looks a lot better than raw HTML with just a few tweaks here and there. With the ability to use all CSS properties for the components, you can make the UI unique. |\u003c/p\u003e\n\u003ch1\u003eIs Streamlit dead?\u003c/h1\u003e\n\u003cp\u003eNo, absolutely not. Mesop is still under development, and the documentation lacks in certain aspects. Deploying a Mesop application is not straightforward and requires containerization unless you are deploying it directly to Google Cloud.\u003c/p\u003e\n\u003cp\u003eStreamlit still comes with its own set of benefits and is fundamentally stronger compared to Mesop, especially if you are looking to build something in the data visualization domain. Moreover, Streamlit Cloud is a boon for anyone looking to share their applications absolutely free of charge.\u003c/p\u003e\n\u003cp\u003e무엇이든 더 도와드릴게요!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그러나 Mesop은 성장 잠재력이 있으며 매일 업데이트를 받고 있어 가벼운 성격으로 REST API에서 작동하는 빠른 도구 및 간단한 프로토 타입에 더 적합해지고 있습니다.\u003c/p\u003e\n\u003cp\u003eMesop의 Will과 다른 기여자들에게 시간과 노력을 들여 이러한 프레임워크를 개발하고 유지하는 데 기쁨을 느낍니다.\u003c/p\u003e\n\u003ch1\u003e더 많은 UI 프레임워크가 필요합니다\u003c/h1\u003e\n\u003cp\u003eStreamlit, Nicegui, Gradio 그리고 이제 Mesop와 같은 새로운 Python UI 프레임워크가 등장하는 것을 항상 좋게 생각합니다. Python의 관용구 문법은 코딩을 훨씬 더 접근 가능하게 만들어주며, 이는 지금 Streamlit 프로젝트의 많은 수로부터 명확히 확인됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e행운이던지 불행이던지, 파이썬이 내가 처음으로 배운 프로그래밍 언어였고, 그것에 즉시 사랑에 빠졌어요. 이와 같은 더 많은 프레임워크로 인해, Python은 사용량이 급격히 증가할 것이고, 미래에는 더 많은 실무급 Python 앱들을 볼 수 있기를 희망해요.\u003c/p\u003e\n\u003cp\u003e저는 Mesop에 관한 이 짧은 블로그를 좋아해주셨으면 좋겠어요. 더 깊이 파고들고 싶었지만, 제한된 시간 때문에 글을 짧게 유지하게 된 것과, 우리 모두가 금붕어 수준의 집중력을 고려했기 때문이에요. 만약 이 글에 박수를 보내주시고, 파이썬과 Google 커뮤니티의 더 많은 사용자와 공유해주시고, 앞으로의 다른 글들을 위해 팔로우해주시면 정말 감사하겠어요.\u003c/p\u003e\n\u003ch1\u003e링크\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eGithub\u003c/li\u003e\n\u003cli\u003eMesop\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-27-DidGoogleJustKillStreamlit"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>