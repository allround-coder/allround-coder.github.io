<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF" data-gatsby-head="true"/><meta name="twitter:title" content="문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-13 00:16" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_buildManifest.js" defer=""></script><script src="/_next/static/OFpTzInQeZKWBaqJEukNX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 13, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>만약 TypeScript를 사용해 보셨다면, 다음과 같은 컴파일 에러를 만날 기회가 많을 것입니다:</p>
<p>만약 저와 같이, 왜 ... 음 ... 다른 누군가의 코드가 그런 식으로 에러가 발생한 이유를 전혀 모를 때가 있었다면, 이 기사는 typing 시스템에서 무슨 일이 벌어지고 있는지에 대해 더 잘 이해하도록 도와줄 수 있습니다.</p>
<h1>JavaScript는 duck-typed입니다</h1>
<p><img src="/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png" alt="error"></p>
<p>자바스크립트는 덕 타이핑을 사용하기 때문에, 함수에 모든 올바른 속성을 갖춘 값을 전달하면 값의 출처가 어디인지에 상관없이 작동합니다.</p>
<p>TypeScript는 구조적 유형 시스템을 사용하여 이를 처리하는데, 이는 타입 체커가 유형의 속성만을 비교할 때만 신경 쓴다는 것을 의미합니다. 때로는 예상치 못한 동작으로 이어질 수 있습니다.</p>
<h1>TypeScript 구조적 유형 모델</h1>
<p>다음 인터페이스와 함수를 고려해보세요:</p>
<pre><code class="hljs language-js">인터페이스 <span class="hljs-title class_">Person</span> {
  <span class="hljs-attr">firstName</span>: string;
  <span class="hljs-attr">lastName</span>: string;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getFullName</span>(<span class="hljs-params">person: Person</span>): string {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${person.firstName}</span> <span class="hljs-subst">${person.lastName}</span>`</span>;
}
</code></pre>
<p>이제 다른 인터페이스를 만들어 봅시다:</p>
<pre><code class="hljs language-js">인터페이스 계정 {
  <span class="hljs-attr">id</span>: number;
  <span class="hljs-attr">email</span>: string;
  <span class="hljs-attr">firstName</span>: string;
  <span class="hljs-attr">lastName</span>: string;
}
</code></pre>
<p>만약 Person 대신에 Account를 getFullName() 함수에 전달하려고 하면 어떻게 될까요?</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-attr">francesco</span>: 계정 = { <span class="hljs-attr">id</span>: <span class="hljs-number">123</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">'borzifrancesco@gmail.com'</span>, <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Francesco'</span>, <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Borzì'</span> };

<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">getFullName</span>(francesco);
</code></pre>
<p>놀랍게도… 이건 오류가 발생하지 않아요!</p>
<p>getFullName() 함수는 firstName과 lastName 속성을 가진 typeAccount 입력을 받습니다.</p>
<p>다시 말해, 함수는 구조상 적절한 속성을 가진 모든 객체를 허용할 거예요 (이것이 구조화된 타이핑이라 불리는 이유에요).</p>
<p>하지만... 사물이 다른 속성을 가지고 있어도 관심이 없습니다.</p>
<h2>구조적 타이핑의 결과</h2>
<p>함수를 정의할 때 항상 선언된 속성만 가지고 호출된다고 가정하는 것이 유혹적일 수 있습니다. 이것은 "봉인된" 유형이라고 불릴 수 있지만 TypeScript에서는 그렇지 않습니다.</p>
<p>이를 이해하기 위해 새로운 시나리오를 고려해보십시오: 사용자가 서로 다른 색상의 보석을 모으는 게임을 구현 중이라고 상상해보겠습니다:</p>
<pre><code class="hljs language-js">인터페이스 <span class="hljs-title class_">GemCollection</span> {
  <span class="hljs-attr">blueCount</span>: number;
  <span class="hljs-attr">greenCount</span>: number;
  <span class="hljs-attr">redCount</span>: number;
  <span class="hljs-attr">yellowCount</span>: number;
  <span class="hljs-comment">// purpleCount: number; // 나중에 구현 예정</span>
}
</code></pre>
<p>이제 GemCollection을 입력으로 받아 총 보석 개수를 반환하는 함수를 구현해야 합니다. 나중에 새로운 보라색이 추가될 것을 알고 있으므로 다음과 같이 함수를 유연하게 만드는 것이 좋다고 생각합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTotalGemsCount</span>(<span class="hljs-params">gemCollection: GemCollection</span>): number {
  <span class="hljs-keyword">let</span> totalGemsCount = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(gemCollection)) {
    totalGemsCount += gemCollection[key];
  }

  <span class="hljs-keyword">return</span> totalGemsCount;
}
</code></pre>
<p>논리적으로는 이해가 되고 잘 작동할 것으로 기대하지만 타입 체커는 gemCollection[key]에서 에러를 발생시킬 것입니다:</p>
<p><img src="/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_1.png" alt="Issue Screenshot"></p>
<p>이 문제는, 예상했던 것과는 다르게, 타입 검사기가 gemCollection 입력이 GemCollection 인터페이스에서 지정된 속성을 최소한 가지고 있다는 것을 보장한다는 것입니다. 그러나 이는 추가 속성이 없음을 보장하지는 않습니다.</p>
<p>우리의 함수는 다음과 같이 다시 작성되어야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTotalGemsCount</span>(<span class="hljs-params">gemCollection: GemCollection</span>): number {
  <span class="hljs-keyword">return</span> gemCollection.<span class="hljs-property">blueCount</span>
    + gemCollection.<span class="hljs-property">greenCount</span>
    + gemCollection.<span class="hljs-property">redCount</span>
    + gemCollection.<span class="hljs-property">yellowCount</span>;
}
</code></pre>
<p>그리고 우리는 게임에 자주색이 구현되어야 할 때에는 수동으로 gemCollection.purpleCount를 추가해주어야 합니다.</p>
<h1>구조적 타이핑의 장점</h1>
<p>구조적 타이핑은 잠재적인 예상치 못한 행동 때문에 주의해야 하는 것만이 아닙니다. 이것은 우리에게 유연성을 제공하는 등 여러 이점을 줄 수도 있습니다.</p>
<p><img src="/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_2.png" alt="이미지"></p>
<p>이제 우리의 보석 수집 게임에서는 특정 사용자가 수집한 보석을 반환하는 API를 쿼리해야 합니다. 어쩌면 우리는 외부 라이브러리를 사용하여 특별한 HTTP 클라이언트인 SuperHttpClient를 제공하는 이유가 있습니다.</p>
<p>또한 호출하는 API 엔드포인트는 사용자가 존재하지 않거나 지금까지 어떤 보석도 수집하지 않은 경우에는 GemCollection 객체 또는 undefined를 반환한다고 가정합시다. 그래서 우리는 getGemsCollection() 함수를 다음과 같이 구현합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">SuperHttpClient</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@some-library/http-client'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getGemsCollection</span>(<span class="hljs-params">httpClient: SuperHttpClient, userId: number</span>): <span class="hljs-title class_">GemCollection</span> {
  <span class="hljs-keyword">const</span> gemsCollection = httpClient.<span class="hljs-title function_">get</span>(<span class="hljs-string">`https://game.gems.org/users/<span class="hljs-subst">${userId}</span>/gems`</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">GemCollection</span> | <span class="hljs-literal">undefined</span>;

  <span class="hljs-keyword">if</span> (gemsCollection) {
    <span class="hljs-keyword">return</span> gemsCollection;
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">blueCount</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">greenCount</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">redCount</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">yellowCount</span>: <span class="hljs-number">0</span>,
  };
}
</code></pre>
<p>예를 들어, 이제 위의 함수에 대한 단위 테스트를 작성하려면 SuperHttpClient의 모의(mock)를 제공해야 합니다. 이겢은 가끔 까다로울 수 있는데, 구조적 타입화를 활용하고 함수에 더 유연한 정의를 제공할 수 있는 방법이 있습니다:</p>
<pre><code class="hljs language-js">인터페이스 <span class="hljs-title class_">HttpClient</span> {
  <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">query: string</span>) =></span> unknown;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getGemsCollection</span>(<span class="hljs-params">httpClient: HttpClient, userId: number</span>): <span class="hljs-title class_">GemCollection</span> {
  <span class="hljs-comment">// 구현 내용은 이전과 동일합니다</span>
}
</code></pre>
<p>저희는 HttpClient인터페이스를 정의했는데, 이는 getGemsCollection 함수에서 필요한 최소한의 것들을 포함한 새로운 추상화입니다. 이는 우리가 SuperHttpClient 타입의 객체를 전달할 수 있기 때문에 제품 환경에서 잘 작동할 것입니다. SuperHttpClient는 필요한 get 속성을 가지고 있기 때문입니다.</p>
<p>또한 이것은SuperHttpClient를위한 목 라이브러리가 필요하지 않고 해당 함수를 단위 테스트할 수 있게 해 줄 것입니다. 우리의 단위 테스트는 다음과 같이 수행될 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">describe</span>(<span class="hljs-string">'getGemsCollection'</span>, <span class="hljs-function">() =></span> {
  <span class="hljs-title function_">it</span>(<span class="hljs-string">'지정된 사용자에 대해 사용 가능한 보석 컬렉션을 반환해야합니다'</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-comment">// 스텁 보석 컬렉션을 준비합니다</span>
    <span class="hljs-keyword">const</span> <span class="hljs-attr">testCollection</span>: <span class="hljs-title class_">GemCollection</span> = {
      <span class="hljs-attr">blueCount</span>: <span class="hljs-number">2</span>,
      <span class="hljs-attr">greenCount</span>: <span class="hljs-number">4</span>,
      <span class="hljs-attr">redCount</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">yellowCount</span>: <span class="hljs-number">7</span>,
    };
    <span class="hljs-comment">// 스텁 HttpClient를 준비하고 스텁 보석 컬렉션을 반환합니다</span>
    <span class="hljs-keyword">const</span> testHttpClientWithGems = {
      <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">_url: string</span>) =></span> testCollection,
    };

    <span class="hljs-comment">// getGemsCollection이 스텁 보석 컬렉션을 반환하는지 확인합니다</span>
    <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">getGemsCollection</span>(testHttpClientWithGems, <span class="hljs-number">10</span>)).<span class="hljs-title function_">toEqual</span>(testCollection);
  });

  <span class="hljs-title function_">it</span>(<span class="hljs-string">'지정된 사용자에 대해 사용할 수 없는 경우 새로운 빈 보석 컬렉션을 반환해야합니다'</span>, <span class="hljs-function">() =></span> {
    <span class="hljs-comment">// 아무것도 반환하지 않는 스텁 HttpClient를 준비합니다</span>
    <span class="hljs-keyword">const</span> testHttpClientWithoutGems = {
      <span class="hljs-attr">get</span>: <span class="hljs-function">(<span class="hljs-params">_url: string</span>) =></span> <span class="hljs-literal">undefined</span>,
    };

    <span class="hljs-comment">// getGemsCollection이 새로운 빈 보석 컬렉션을 반환하는지 확인합니다</span>
    <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">getGemsCollection</span>(testHttpClientWithoutGems, <span class="hljs-number">10</span>)).<span class="hljs-title function_">toEqual</span>({
      <span class="hljs-attr">blueCount</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">greenCount</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">redCount</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">yellowCount</span>: <span class="hljs-number">0</span>,
    });
  });
});
</code></pre>
<p>새 HttpClient 추상화 덕분에 로직과 유닛 테스트를 써드 파티 라이브러리에서 제공되는 HTTP 클라이언트 구현으로부터 분리할 수 있게 되었어요.</p>
<p>팁: 위 구현 및 유닛 테스트를 심플하게 유지하여 Structural Typing의 잠재력을 보여주었어요. 실제 시나리오에서는 다르게 처리할 부분이 여러 가지 있을 거예요. 위 코드는 주로 학습용이라고 생각해주세요.</p>
<h1>결론</h1>
<ul>
<li>자바스크립트는 덕 타이핑을 사용합니다: 개체가 할 수 있는 일은 해당 메서드 또는 속성이 있는지에 달려있고, 특정 유형에 의존하지 않아요;</li>
<li>이러한 동적 특성을 관리하기 위해 TypeScript는 Structural Typing을 사용하며, 개발자는 그 작동 방식을 이해해야 해요;</li>
<li>Structural Typing은 예상치 못한 동작이 발생할 수 있음에 주의해야 해요;</li>
<li>Structural Typing은 더 큰 유연성을 제공합니다. 개발자는 이를 활용하여 새로운 추상화를 만들어 관심사 분리를 장려하고 전체 코드 아키텍처를 개선할 수 있어요.</li>
</ul>
<h2>참고 사항</h2>
<p>Dan Vanderkam이 쓴 Effective TypeScript 책에서 영감을 받았습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"문제 해결 WTF   Element가 암시적으로 any 타입을 가지고 있습니다 왜냐하면 string 타입의 표현식을 사용하여 WTF  타입에 색인을 걸 수 없기 때문입니다","description":"","date":"2024-05-13 00:16","slug":"2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF","content":"\n\n만약 TypeScript를 사용해 보셨다면, 다음과 같은 컴파일 에러를 만날 기회가 많을 것입니다:\n\n만약 저와 같이, 왜 ... 음 ... 다른 누군가의 코드가 그런 식으로 에러가 발생한 이유를 전혀 모를 때가 있었다면, 이 기사는 typing 시스템에서 무슨 일이 벌어지고 있는지에 대해 더 잘 이해하도록 도와줄 수 있습니다.\n\n# JavaScript는 duck-typed입니다\n\n![error](/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png)\n\n\n\n자바스크립트는 덕 타이핑을 사용하기 때문에, 함수에 모든 올바른 속성을 갖춘 값을 전달하면 값의 출처가 어디인지에 상관없이 작동합니다.\n\nTypeScript는 구조적 유형 시스템을 사용하여 이를 처리하는데, 이는 타입 체커가 유형의 속성만을 비교할 때만 신경 쓴다는 것을 의미합니다. 때로는 예상치 못한 동작으로 이어질 수 있습니다.\n\n# TypeScript 구조적 유형 모델\n\n다음 인터페이스와 함수를 고려해보세요:\n\n\n\n```js\n인터페이스 Person {\n  firstName: string;\n  lastName: string;\n}\n\nfunction getFullName(person: Person): string {\n  return `${person.firstName} ${person.lastName}`;\n}\n```\n\n이제 다른 인터페이스를 만들어 봅시다:\n\n```js\n인터페이스 계정 {\n  id: number;\n  email: string;\n  firstName: string;\n  lastName: string;\n}\n```\n\n만약 Person 대신에 Account를 getFullName() 함수에 전달하려고 하면 어떻게 될까요?\n\n\n\n```js\nconst francesco: 계정 = { id: 123, email: 'borzifrancesco@gmail.com', firstName: 'Francesco', lastName: 'Borzì' };\n\nconst result = getFullName(francesco);\n```\n\n놀랍게도… 이건 오류가 발생하지 않아요!\n\ngetFullName() 함수는 firstName과 lastName 속성을 가진 typeAccount 입력을 받습니다.\n\n다시 말해, 함수는 구조상 적절한 속성을 가진 모든 객체를 허용할 거예요 (이것이 구조화된 타이핑이라 불리는 이유에요).\n\n\n\n하지만... 사물이 다른 속성을 가지고 있어도 관심이 없습니다.\n\n## 구조적 타이핑의 결과\n\n함수를 정의할 때 항상 선언된 속성만 가지고 호출된다고 가정하는 것이 유혹적일 수 있습니다. 이것은 \"봉인된\" 유형이라고 불릴 수 있지만 TypeScript에서는 그렇지 않습니다.\n\n이를 이해하기 위해 새로운 시나리오를 고려해보십시오: 사용자가 서로 다른 색상의 보석을 모으는 게임을 구현 중이라고 상상해보겠습니다:\n\n\n\n```js\n인터페이스 GemCollection {\n  blueCount: number;\n  greenCount: number;\n  redCount: number;\n  yellowCount: number;\n  // purpleCount: number; // 나중에 구현 예정\n}\n```\n\n이제 GemCollection을 입력으로 받아 총 보석 개수를 반환하는 함수를 구현해야 합니다. 나중에 새로운 보라색이 추가될 것을 알고 있으므로 다음과 같이 함수를 유연하게 만드는 것이 좋다고 생각합니다:\n\n```js\nfunction getTotalGemsCount(gemCollection: GemCollection): number {\n  let totalGemsCount = 0;\n\n  for (const key of Object.keys(gemCollection)) {\n    totalGemsCount += gemCollection[key];\n  }\n\n  return totalGemsCount;\n}\n```\n\n논리적으로는 이해가 되고 잘 작동할 것으로 기대하지만 타입 체커는 gemCollection[key]에서 에러를 발생시킬 것입니다:\n\n\n\n\n![Issue Screenshot](/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_1.png)\n\n이 문제는, 예상했던 것과는 다르게, 타입 검사기가 gemCollection 입력이 GemCollection 인터페이스에서 지정된 속성을 최소한 가지고 있다는 것을 보장한다는 것입니다. 그러나 이는 추가 속성이 없음을 보장하지는 않습니다.\n\n우리의 함수는 다음과 같이 다시 작성되어야 합니다:\n\n```js\nfunction getTotalGemsCount(gemCollection: GemCollection): number {\n  return gemCollection.blueCount\n    + gemCollection.greenCount\n    + gemCollection.redCount\n    + gemCollection.yellowCount;\n}\n```\n\n\n\n그리고 우리는 게임에 자주색이 구현되어야 할 때에는 수동으로 gemCollection.purpleCount를 추가해주어야 합니다.\n\n# 구조적 타이핑의 장점\n\n구조적 타이핑은 잠재적인 예상치 못한 행동 때문에 주의해야 하는 것만이 아닙니다. 이것은 우리에게 유연성을 제공하는 등 여러 이점을 줄 수도 있습니다.\n\n![이미지](/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_2.png)\n\n\n\n이제 우리의 보석 수집 게임에서는 특정 사용자가 수집한 보석을 반환하는 API를 쿼리해야 합니다. 어쩌면 우리는 외부 라이브러리를 사용하여 특별한 HTTP 클라이언트인 SuperHttpClient를 제공하는 이유가 있습니다.\n\n또한 호출하는 API 엔드포인트는 사용자가 존재하지 않거나 지금까지 어떤 보석도 수집하지 않은 경우에는 GemCollection 객체 또는 undefined를 반환한다고 가정합시다. 그래서 우리는 getGemsCollection() 함수를 다음과 같이 구현합니다:\n\n```js\nimport { SuperHttpClient } from '@some-library/http-client';\n\nfunction getGemsCollection(httpClient: SuperHttpClient, userId: number): GemCollection {\n  const gemsCollection = httpClient.get(`https://game.gems.org/users/${userId}/gems`) as GemCollection | undefined;\n\n  if (gemsCollection) {\n    return gemsCollection;\n  }\n\n  return {\n    blueCount: 0,\n    greenCount: 0,\n    redCount: 0,\n    yellowCount: 0,\n  };\n}\n```\n\n예를 들어, 이제 위의 함수에 대한 단위 테스트를 작성하려면 SuperHttpClient의 모의(mock)를 제공해야 합니다. 이겢은 가끔 까다로울 수 있는데, 구조적 타입화를 활용하고 함수에 더 유연한 정의를 제공할 수 있는 방법이 있습니다:\n\n\n\n```js\n인터페이스 HttpClient {\n  get: (query: string) =\u003e unknown;\n}\n\nfunction getGemsCollection(httpClient: HttpClient, userId: number): GemCollection {\n  // 구현 내용은 이전과 동일합니다\n}\n```\n\n저희는 HttpClient인터페이스를 정의했는데, 이는 getGemsCollection 함수에서 필요한 최소한의 것들을 포함한 새로운 추상화입니다. 이는 우리가 SuperHttpClient 타입의 객체를 전달할 수 있기 때문에 제품 환경에서 잘 작동할 것입니다. SuperHttpClient는 필요한 get 속성을 가지고 있기 때문입니다.\n\n또한 이것은SuperHttpClient를위한 목 라이브러리가 필요하지 않고 해당 함수를 단위 테스트할 수 있게 해 줄 것입니다. 우리의 단위 테스트는 다음과 같이 수행될 수 있습니다:\n\n```js\ndescribe('getGemsCollection', () =\u003e {\n  it('지정된 사용자에 대해 사용 가능한 보석 컬렉션을 반환해야합니다', () =\u003e {\n    // 스텁 보석 컬렉션을 준비합니다\n    const testCollection: GemCollection = {\n      blueCount: 2,\n      greenCount: 4,\n      redCount: 1,\n      yellowCount: 7,\n    };\n    // 스텁 HttpClient를 준비하고 스텁 보석 컬렉션을 반환합니다\n    const testHttpClientWithGems = {\n      get: (_url: string) =\u003e testCollection,\n    };\n\n    // getGemsCollection이 스텁 보석 컬렉션을 반환하는지 확인합니다\n    expect(getGemsCollection(testHttpClientWithGems, 10)).toEqual(testCollection);\n  });\n\n  it('지정된 사용자에 대해 사용할 수 없는 경우 새로운 빈 보석 컬렉션을 반환해야합니다', () =\u003e {\n    // 아무것도 반환하지 않는 스텁 HttpClient를 준비합니다\n    const testHttpClientWithoutGems = {\n      get: (_url: string) =\u003e undefined,\n    };\n\n    // getGemsCollection이 새로운 빈 보석 컬렉션을 반환하는지 확인합니다\n    expect(getGemsCollection(testHttpClientWithoutGems, 10)).toEqual({\n      blueCount: 0,\n      greenCount: 0,\n      redCount: 0,\n      yellowCount: 0,\n    });\n  });\n});\n```\n\n\n\n새 HttpClient 추상화 덕분에 로직과 유닛 테스트를 써드 파티 라이브러리에서 제공되는 HTTP 클라이언트 구현으로부터 분리할 수 있게 되었어요.\n\n팁: 위 구현 및 유닛 테스트를 심플하게 유지하여 Structural Typing의 잠재력을 보여주었어요. 실제 시나리오에서는 다르게 처리할 부분이 여러 가지 있을 거예요. 위 코드는 주로 학습용이라고 생각해주세요.\n\n# 결론\n\n- 자바스크립트는 덕 타이핑을 사용합니다: 개체가 할 수 있는 일은 해당 메서드 또는 속성이 있는지에 달려있고, 특정 유형에 의존하지 않아요;\n- 이러한 동적 특성을 관리하기 위해 TypeScript는 Structural Typing을 사용하며, 개발자는 그 작동 방식을 이해해야 해요;\n- Structural Typing은 예상치 못한 동작이 발생할 수 있음에 주의해야 해요;\n- Structural Typing은 더 큰 유연성을 제공합니다. 개발자는 이를 활용하여 새로운 추상화를 만들어 관심사 분리를 장려하고 전체 코드 아키텍처를 개선할 수 있어요.\n\n\n\n## 참고 사항\n\nDan Vanderkam이 쓴 Effective TypeScript 책에서 영감을 받았습니다.","ogImage":{"url":"/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png"},"coverImage":"/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e만약 TypeScript를 사용해 보셨다면, 다음과 같은 컴파일 에러를 만날 기회가 많을 것입니다:\u003c/p\u003e\n\u003cp\u003e만약 저와 같이, 왜 ... 음 ... 다른 누군가의 코드가 그런 식으로 에러가 발생한 이유를 전혀 모를 때가 있었다면, 이 기사는 typing 시스템에서 무슨 일이 벌어지고 있는지에 대해 더 잘 이해하도록 도와줄 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eJavaScript는 duck-typed입니다\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_0.png\" alt=\"error\"\u003e\u003c/p\u003e\n\u003cp\u003e자바스크립트는 덕 타이핑을 사용하기 때문에, 함수에 모든 올바른 속성을 갖춘 값을 전달하면 값의 출처가 어디인지에 상관없이 작동합니다.\u003c/p\u003e\n\u003cp\u003eTypeScript는 구조적 유형 시스템을 사용하여 이를 처리하는데, 이는 타입 체커가 유형의 속성만을 비교할 때만 신경 쓴다는 것을 의미합니다. 때로는 예상치 못한 동작으로 이어질 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eTypeScript 구조적 유형 모델\u003c/h1\u003e\n\u003cp\u003e다음 인터페이스와 함수를 고려해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e인터페이스 \u003cspan class=\"hljs-title class_\"\u003ePerson\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003efirstName\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003elastName\u003c/span\u003e: string;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetFullName\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eperson: Person\u003c/span\u003e): string {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${person.firstName}\u003c/span\u003e \u003cspan class=\"hljs-subst\"\u003e${person.lastName}\u003c/span\u003e`\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 다른 인터페이스를 만들어 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e인터페이스 계정 {\n  \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: number;\n  \u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003efirstName\u003c/span\u003e: string;\n  \u003cspan class=\"hljs-attr\"\u003elastName\u003c/span\u003e: string;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 Person 대신에 Account를 getFullName() 함수에 전달하려고 하면 어떻게 될까요?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003efrancesco\u003c/span\u003e: 계정 = { \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eemail\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'borzifrancesco@gmail.com'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003efirstName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Francesco'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003elastName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Borzì'\u003c/span\u003e };\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-title function_\"\u003egetFullName\u003c/span\u003e(francesco);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e놀랍게도… 이건 오류가 발생하지 않아요!\u003c/p\u003e\n\u003cp\u003egetFullName() 함수는 firstName과 lastName 속성을 가진 typeAccount 입력을 받습니다.\u003c/p\u003e\n\u003cp\u003e다시 말해, 함수는 구조상 적절한 속성을 가진 모든 객체를 허용할 거예요 (이것이 구조화된 타이핑이라 불리는 이유에요).\u003c/p\u003e\n\u003cp\u003e하지만... 사물이 다른 속성을 가지고 있어도 관심이 없습니다.\u003c/p\u003e\n\u003ch2\u003e구조적 타이핑의 결과\u003c/h2\u003e\n\u003cp\u003e함수를 정의할 때 항상 선언된 속성만 가지고 호출된다고 가정하는 것이 유혹적일 수 있습니다. 이것은 \"봉인된\" 유형이라고 불릴 수 있지만 TypeScript에서는 그렇지 않습니다.\u003c/p\u003e\n\u003cp\u003e이를 이해하기 위해 새로운 시나리오를 고려해보십시오: 사용자가 서로 다른 색상의 보석을 모으는 게임을 구현 중이라고 상상해보겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e인터페이스 \u003cspan class=\"hljs-title class_\"\u003eGemCollection\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eblueCount\u003c/span\u003e: number;\n  \u003cspan class=\"hljs-attr\"\u003egreenCount\u003c/span\u003e: number;\n  \u003cspan class=\"hljs-attr\"\u003eredCount\u003c/span\u003e: number;\n  \u003cspan class=\"hljs-attr\"\u003eyellowCount\u003c/span\u003e: number;\n  \u003cspan class=\"hljs-comment\"\u003e// purpleCount: number; // 나중에 구현 예정\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 GemCollection을 입력으로 받아 총 보석 개수를 반환하는 함수를 구현해야 합니다. 나중에 새로운 보라색이 추가될 것을 알고 있으므로 다음과 같이 함수를 유연하게 만드는 것이 좋다고 생각합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetTotalGemsCount\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003egemCollection: GemCollection\u003c/span\u003e): number {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e totalGemsCount = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e(gemCollection)) {\n    totalGemsCount += gemCollection[key];\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e totalGemsCount;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e논리적으로는 이해가 되고 잘 작동할 것으로 기대하지만 타입 체커는 gemCollection[key]에서 에러를 발생시킬 것입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_1.png\" alt=\"Issue Screenshot\"\u003e\u003c/p\u003e\n\u003cp\u003e이 문제는, 예상했던 것과는 다르게, 타입 검사기가 gemCollection 입력이 GemCollection 인터페이스에서 지정된 속성을 최소한 가지고 있다는 것을 보장한다는 것입니다. 그러나 이는 추가 속성이 없음을 보장하지는 않습니다.\u003c/p\u003e\n\u003cp\u003e우리의 함수는 다음과 같이 다시 작성되어야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetTotalGemsCount\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003egemCollection: GemCollection\u003c/span\u003e): number {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e gemCollection.\u003cspan class=\"hljs-property\"\u003eblueCount\u003c/span\u003e\n    + gemCollection.\u003cspan class=\"hljs-property\"\u003egreenCount\u003c/span\u003e\n    + gemCollection.\u003cspan class=\"hljs-property\"\u003eredCount\u003c/span\u003e\n    + gemCollection.\u003cspan class=\"hljs-property\"\u003eyellowCount\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 우리는 게임에 자주색이 구현되어야 할 때에는 수동으로 gemCollection.purpleCount를 추가해주어야 합니다.\u003c/p\u003e\n\u003ch1\u003e구조적 타이핑의 장점\u003c/h1\u003e\n\u003cp\u003e구조적 타이핑은 잠재적인 예상치 못한 행동 때문에 주의해야 하는 것만이 아닙니다. 이것은 우리에게 유연성을 제공하는 등 여러 이점을 줄 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 우리의 보석 수집 게임에서는 특정 사용자가 수집한 보석을 반환하는 API를 쿼리해야 합니다. 어쩌면 우리는 외부 라이브러리를 사용하여 특별한 HTTP 클라이언트인 SuperHttpClient를 제공하는 이유가 있습니다.\u003c/p\u003e\n\u003cp\u003e또한 호출하는 API 엔드포인트는 사용자가 존재하지 않거나 지금까지 어떤 보석도 수집하지 않은 경우에는 GemCollection 객체 또는 undefined를 반환한다고 가정합시다. 그래서 우리는 getGemsCollection() 함수를 다음과 같이 구현합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eSuperHttpClient\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@some-library/http-client'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetGemsCollection\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ehttpClient: SuperHttpClient, userId: number\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eGemCollection\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e gemsCollection = httpClient.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`https://game.gems.org/users/\u003cspan class=\"hljs-subst\"\u003e${userId}\u003c/span\u003e/gems`\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGemCollection\u003c/span\u003e | \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (gemsCollection) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e gemsCollection;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003eblueCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003egreenCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eredCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eyellowCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예를 들어, 이제 위의 함수에 대한 단위 테스트를 작성하려면 SuperHttpClient의 모의(mock)를 제공해야 합니다. 이겢은 가끔 까다로울 수 있는데, 구조적 타입화를 활용하고 함수에 더 유연한 정의를 제공할 수 있는 방법이 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e인터페이스 \u003cspan class=\"hljs-title class_\"\u003eHttpClient\u003c/span\u003e {\n  \u003cspan class=\"hljs-attr\"\u003eget\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003equery: string\u003c/span\u003e) =\u003e\u003c/span\u003e unknown;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetGemsCollection\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ehttpClient: HttpClient, userId: number\u003c/span\u003e): \u003cspan class=\"hljs-title class_\"\u003eGemCollection\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 구현 내용은 이전과 동일합니다\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e저희는 HttpClient인터페이스를 정의했는데, 이는 getGemsCollection 함수에서 필요한 최소한의 것들을 포함한 새로운 추상화입니다. 이는 우리가 SuperHttpClient 타입의 객체를 전달할 수 있기 때문에 제품 환경에서 잘 작동할 것입니다. SuperHttpClient는 필요한 get 속성을 가지고 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e또한 이것은SuperHttpClient를위한 목 라이브러리가 필요하지 않고 해당 함수를 단위 테스트할 수 있게 해 줄 것입니다. 우리의 단위 테스트는 다음과 같이 수행될 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003edescribe\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'getGemsCollection'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003eit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'지정된 사용자에 대해 사용 가능한 보석 컬렉션을 반환해야합니다'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 스텁 보석 컬렉션을 준비합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etestCollection\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eGemCollection\u003c/span\u003e = {\n      \u003cspan class=\"hljs-attr\"\u003eblueCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003egreenCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eredCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eyellowCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\n    };\n    \u003cspan class=\"hljs-comment\"\u003e// 스텁 HttpClient를 준비하고 스텁 보석 컬렉션을 반환합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e testHttpClientWithGems = {\n      \u003cspan class=\"hljs-attr\"\u003eget\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e_url: string\u003c/span\u003e) =\u003e\u003c/span\u003e testCollection,\n    };\n\n    \u003cspan class=\"hljs-comment\"\u003e// getGemsCollection이 스텁 보석 컬렉션을 반환하는지 확인합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003egetGemsCollection\u003c/span\u003e(testHttpClientWithGems, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)).\u003cspan class=\"hljs-title function_\"\u003etoEqual\u003c/span\u003e(testCollection);\n  });\n\n  \u003cspan class=\"hljs-title function_\"\u003eit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'지정된 사용자에 대해 사용할 수 없는 경우 새로운 빈 보석 컬렉션을 반환해야합니다'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 아무것도 반환하지 않는 스텁 HttpClient를 준비합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e testHttpClientWithoutGems = {\n      \u003cspan class=\"hljs-attr\"\u003eget\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e_url: string\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e,\n    };\n\n    \u003cspan class=\"hljs-comment\"\u003e// getGemsCollection이 새로운 빈 보석 컬렉션을 반환하는지 확인합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003egetGemsCollection\u003c/span\u003e(testHttpClientWithoutGems, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)).\u003cspan class=\"hljs-title function_\"\u003etoEqual\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003eblueCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003egreenCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eredCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eyellowCount\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    });\n  });\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새 HttpClient 추상화 덕분에 로직과 유닛 테스트를 써드 파티 라이브러리에서 제공되는 HTTP 클라이언트 구현으로부터 분리할 수 있게 되었어요.\u003c/p\u003e\n\u003cp\u003e팁: 위 구현 및 유닛 테스트를 심플하게 유지하여 Structural Typing의 잠재력을 보여주었어요. 실제 시나리오에서는 다르게 처리할 부분이 여러 가지 있을 거예요. 위 코드는 주로 학습용이라고 생각해주세요.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e자바스크립트는 덕 타이핑을 사용합니다: 개체가 할 수 있는 일은 해당 메서드 또는 속성이 있는지에 달려있고, 특정 유형에 의존하지 않아요;\u003c/li\u003e\n\u003cli\u003e이러한 동적 특성을 관리하기 위해 TypeScript는 Structural Typing을 사용하며, 개발자는 그 작동 방식을 이해해야 해요;\u003c/li\u003e\n\u003cli\u003eStructural Typing은 예상치 못한 동작이 발생할 수 있음에 주의해야 해요;\u003c/li\u003e\n\u003cli\u003eStructural Typing은 더 큰 유연성을 제공합니다. 개발자는 이를 활용하여 새로운 추상화를 만들어 관심사 분리를 장려하고 전체 코드 아키텍처를 개선할 수 있어요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e참고 사항\u003c/h2\u003e\n\u003cp\u003eDan Vanderkam이 쓴 Effective TypeScript 책에서 영감을 받았습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-13-ElementimplicitlyhasananytypebecauseexpressionoftypestringcantbeusedtoindextypeWTF"},"buildId":"OFpTzInQeZKWBaqJEukNX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>