<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs" data-gatsby-head="true"/><meta name="twitter:title" content="스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 12:09" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>다음.js, Stream 및 Chatscope를 사용하여 매력적이고 인터랙티브한 라이브 스트리밍 채팅 앱을 만드는 방법을 배워보세요.</p>
<p><img src="/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png" alt="이미지"></p>
<p>언제나 YouTube와 같은 라이브 스트리밍에서 발견되는 다이나믹한 채팅 경험을 어떻게 만들 수 있을지 궁금해했는데, 누구나 로그인 없이 참여할 수 있는 편리함을 더한 기능을 추가하고 싶었습니다.</p>
<p>Next.js와 Stream을 사용하여 그 경험을 성공적으로 만들어냈습니다. 이 튜토리얼에서는 사용자 권한에 대한 세밀한 제어를 통해 실시간 상호작용을 보다 접근하기 쉽게 만드는 라이브 스트리밍 채팅 환경을 만드는 간단한 방법을 다루고 있습니다.</p>
<h1>데모</h1>
<p>기술적인 내용에 들어가기 전에, 이 튜토리얼에서 무엇을 만들게 될지 간단히 소개해 드릴게요 👇🏻</p>
<h1>준비물</h1>
<p>구현을 시작하기 위해 다음이 필요합니다:</p>
<ul>
<li>Node.js 18 또는 그 이후 버전</li>
<li>Stream 계정</li>
<li>Vercel 계정</li>
</ul>
<h1>새 Stream 애플리케이션 설정하기</h1>
<p>이 섹션에서는 새 Stream 애플리케이션을 생성하고, 인증 없이 사용자를 활성화하며, 사용자 권한을 정의하여 채널에 대한 읽기 및 게시를 설정하는 방법을 배울 수 있습니다. 시작해봅시다.</p>
<p>Stream 계정을 만들고 로그인한 후, + 앱 만들기를 클릭하여 Stream 채팅 애플리케이션 생성을 시작해보세요.</p>
<p>어플리케이션 이름을 입력해주세요. 또한, 웹사이트 배포 지역/기능 근처의 채팅 저장 위치를 선택해주세요. 저는 인도에 있으므로 뭄바이로 설정했습니다.</p>
<p>설정이 완료되면 채팅 개요 화면으로 이동합니다. API 키를 복사하고, 안전한 장소에 저장하여 Next.js 애플리케이션에서 NEXT_PUBLIC_STREAM_API_KEY로 계속 사용할 수 있도록 해주세요.</p>
<p><img src="/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_3.png" alt="이미지"></p>
<p>권한 확인 없이 방문자가 채팅 메시지를 게시할 수 있도록 하려면 아래로 스크롤하여 "인증 확인 비활성화" 토글 버튼을 활성화하세요. 변경 사항을 동기화하려면 제출을 클릭하세요.</p>
<p><img src="/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_4.png" alt="이미지"></p>
<p>방문자가 특정 채널의 사용자로서 메시지를 게시할 수 있도록 하려면 그들을 위해 읽기 및 게시 권한을 활성화해야 합니다. 방문자가 채팅 애플리케이션에서 가정할 수 있는 역할과 권한을 구성할 수 있도록 하는 것이 매우 유용합니다.</p>
<p>사용자 역할을 선택하고 메시징을 스코프로 선택한 다음 편집 버튼을 클릭하여 방문자의 권한을 구성하실 수 있습니다.</p>
<p><img src="/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_5.png" alt="이미지"></p>
<p>방문자가 메시지를 게시할 수 있도록 하려면 메시지 생성을 검색하고 "메시지 생성" 권한을 활성화하여 채널의 모든 사용자가 메시지를 보낼 수 있도록 허용할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_6.png" alt="이미지"></p>
<p>방문자들이 채팅 기록을 읽을 수 있도록 하려면 'read channel'을 검색하여 Read Channel 및 Read Channel Members를 활성화하세요. 이렇게 하면 방문자가 메시지를 읽을 뿐만 아니라 해당 메시지를 게시한 사용자도 확인할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_7.png" alt="이미지"></p>
<p>마지막으로 변경 사항을 동기화하려면 저장을 클릭하세요.</p>
<p><img src="/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_8.png" alt="이미지"></p>
<p>이제 방문자가 할 수 있는 것들의 권한과 범위를 구성하는 것을 마쳤습니다. 이제 Chatscope UI Kit을 사용하여 Next.js에서 채팅 사용자 인터페이스를 구축해 봅시다.</p>
<h1>새 Next.js 애플리케이션 설정</h1>
<p>이 섹션에서는 새로운 Next.js 애플리케이션을 생성하는 방법, shadcn/ui를 설정하는 방법, 해당 애플리케이션의 요구 사항을 파악하여 빠른 구현을 위해 관련 라이브러리를 설치하는 방법을 배우게 될 것입니다.</p>
<p>새로운 Next.js 프로젝트를 생성하는 것으로 시작해 봅시다. 터미널을 열고 다음 명령을 실행하세요:</p>
<pre><code class="hljs language-js">npx create-next-app@latest my-chat-app
</code></pre>
<p>진행할 때, 다음을 선택하세요:</p>
<ul>
<li>TypeScript를 사용할 것인지 물으면 "Yes"를 선택하세요.</li>
<li>ESLint를 사용할 것인지 물으면 "No"를 선택하세요.</li>
<li>Tailwind CSS를 사용할 것인지 물으면 "Yes"를 선택하세요.</li>
<li>src/ 디렉토리를 사용할 것인지 물으면 "No"를 선택하세요.</li>
<li>App Router를 사용할 것인지 물으면 "Yes"를 선택하세요.</li>
<li>기본 import alias를 맞춤 설정할 것인지 물으면 "No"를 선택하세요.</li>
</ul>
<p>위 과정을 마치면 프로젝트 디렉토리로 이동하여 다음 명령어를 실행하여 개발 모드에서 앱을 시작할 수 있습니다:</p>
<pre><code class="hljs language-js">cd my-chat-app
npm run dev
</code></pre>
<p>앱은 localhost:3000에서 실행 중이어야 합니다.</p>
<p>이제 프로젝트의 루트에 .env 파일을 만드세요. 위 섹션에서 저장한 항목들을 추가할 것입니다.</p>
<p>다음과 같이 보여야 합니다:</p>
<pre><code class="hljs language-js"># .<span class="hljs-property">env</span>

# 스트림 환경 변수
<span class="hljs-variable constant_">NEXT_PUBLIC_STREAM_API_KEY</span>=<span class="hljs-string">"..."</span>

</code></pre>
<h2>shadcn/ui 컴포넌트 통합</h2>
<p>채팅 사용자 인터페이스를 빠르게 프로토타입화하기 위해 Next.js와 함께 shadcn/ui를 설정할 것입니다. shadcn/ui는 아름답게 디자인된 컴포넌트들의 모음으로, 여러분의 애플리케이션에 복사하여 붙여넣을 수 있습니다. 아래 명령어를 실행하여 shadcn/ui를 설정하세요:</p>
<pre><code class="hljs language-js">npx shadcn-ui@latest init
</code></pre>
<p>구성 파일 components.json을 구성하는 몇 가지 질문에 답해야합니다. 다음을 선택하세요:</p>
<ul>
<li>TypeScript를 사용하것이라고 하면 "예"를 선택하세요.</li>
<li>사용할 스타일을 선택하라는 프롬프트가 나오면 "기본"을 선택하세요.</li>
<li>기본 색상으로 선택하라는 프롬프트가 나오면 "Slate"를 선택하세요.</li>
<li>색상에 CSS 변수를 사용하냐고 묻힐 경우 "예"를 선택하세요.</li>
</ul>
<p>위 작업이 완료되면, Next.js 애플리케이션에 React 구성 요소를 쉽게 추가할 수 있는 CLI가 설정됩니다. 아래 명령어를 실행하여 버튼, 입력란, 그리고 텍스트영역 요소를 가져올 수 있습니다.</p>
<pre><code class="hljs language-js">npx shadcn-ui@latest add button
npx shadcn-ui@latest add input
npx shadcn-ui@latest add textarea
</code></pre>
<p>그것이 끝나면 이제 app/components 디렉토리 안에 ui 디렉토리가 보일 것입니다. 그 안에 button.tsx, input.tsx, textarea.tsx 파일이 있습니다.</p>
<h2>Chatscope 및 Stream UI Kit를 React에 설치하기</h2>
<p>구현을 더 쉽게 만들기 위해 필요한 작업을 이제 알아봅시다.</p>
<p>먼저, 각 방문자가 익명 사용자로 취급되므로 임의로 생성된 이름(id)으로 그들을 식별해야 합니다. 또한 채널에서 받은 각 메시지는 실시간으로 모든 방문자에게 전파되어야 합니다. 마지막으로, 모든 메시지가 채널로 들어오는 메시지로 표시되도록 해야 합니다.</p>
<p>위의 요구 사항을 충족하기 위해 다음 명령을 실행하여 필요한 라이브러리를 설치하세요:</p>
<pre><code class="hljs language-js">npm install @chatscope/chat-ui-kit-react
npm install stream-chat stream-chat-react
npm install unique-username-generator
</code></pre>
<p>다음 라이브러리가 설치됩니다:</p>
<ul>
<li>unique-username-generator: 고유한 사용자 이름을 생성하는 패키지입니다.</li>
<li>stream-chat: Stream의 JavaScript API 클라이언트입니다.</li>
<li>stream-chat-react: Stream Chat을 위한 React 훅(그리고 컴포넌트) 라이브러리입니다.</li>
<li>@chatscope/chat-ui-kit-react: 채팅 UI의 프로토타입을 위한 React 컴포넌트 라이브러리입니다.</li>
</ul>
<p>자, 이제 반응형 채팅 사용자 인터페이스를 만들어 봅시다.</p>
<h1>ChatScope와 Stream을 사용하여 채팅 사용자 인터페이스 만들기</h1>
<p>이 섹션에서는 방문자를 특정 채널에 연결하고, 채팅 기록을 렌더링하고, 메시지를 게시할 수 있도록 하는 React 컴포넌트를 구축하는 방법을 배우게 될 것입니다.</p>
<p>먼저, 채팅 메시지 목록을 동적으로 렌더링하는 React 컴포넌트를 만들어 봅시다. Stream 및 Chatscope 라이브러리에서 컴포넌트를 사용할 것입니다.</p>
<p>앱 디렉토리에 Messages.tsx 파일을 만들어서 아래 코드를 넣어주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { cn } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/lib/utils"</span>;
<span class="hljs-keyword">import</span> { useChannelStateContext } <span class="hljs-keyword">from</span> <span class="hljs-string">"stream-chat-react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Message</span>, <span class="hljs-title class_">MessageList</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@chatscope/chat-ui-kit-react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> { messages } = <span class="hljs-title function_">useChannelStateContext</span>();
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">MessageList</span>></span>
      {messages?.map((i, index: number) => (
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Message</span>
          <span class="hljs-attr">key</span>=<span class="hljs-string">{i.id}</span>
          <span class="hljs-attr">model</span>=<span class="hljs-string">{{</span>
            <span class="hljs-attr">position:</span> "<span class="hljs-attr">normal</span>",
            <span class="hljs-attr">sender:</span> <span class="hljs-attr">i.user</span>?<span class="hljs-attr">.id</span>,
            <span class="hljs-attr">direction:</span> "<span class="hljs-attr">incoming</span>",
            <span class="hljs-attr">message:</span> `${<span class="hljs-attr">i.user</span>?<span class="hljs-attr">.id</span>}<span class="hljs-attr">:</span> ${<span class="hljs-attr">i.text</span>}`,
            <span class="hljs-attr">sentTime:</span> <span class="hljs-attr">i.created_at</span>?<span class="hljs-attr">.toString</span>(),
          }}
          <span class="hljs-attr">className</span>=<span class="hljs-string">{cn(</span>
            "<span class="hljs-attr">bg-white</span> <span class="hljs-attr">rounded</span> <span class="hljs-attr">text-black</span> <span class="hljs-attr">py-2</span> <span class="hljs-attr">text-xs</span>",
            <span class="hljs-attr">index</span> !== <span class="hljs-string">messages.length</span> <span class="hljs-attr">-</span> <span class="hljs-attr">1</span> &#x26;&#x26; "<span class="hljs-attr">border-b</span>"
          )}
        /></span>
      ))}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">MessageList</span>></span></span>
  );
}
</code></pre>
<p><code>useChannelStateContext</code> 훅을 사용하여 채팅 기록을 가져오고 새로운 메시지를 수신할 수 있습니다. <code>MessageList</code> 및 <code>Message</code> Chatscope UI 구성 요소를 사용하여 모든 메시지를 채널로 수신하도록 표시하고, 발신자 정보, 메시지 내용 및 타임스탬프와 매핑할 수 있습니다.</p>
<p>이제 사용자가 채팅 기록을 볼 수 있고 메시지를 동시에 게시할 수 있는 경로를 작성해봅시다. 앱 디렉토리의 page.tsx 파일을 아래 코드로 업데이트해주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use client"</span>;

<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Messages</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./Messages"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Button</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/components/ui/button"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Channel</span>, <span class="hljs-title class_">Chat</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"stream-chat-react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Textarea</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/components/ui/textarea"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [channel, setChannel] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [chatClient, setChatClient] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex max-w-[300px] flex-col gap-y-3 p-5"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex w-[300px] flex-col gap-y-3"</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">span</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"border-b border-gray-100 font-semibold"</span>></span>채팅<span class="hljs-tag">&#x3C;/<span class="hljs-name">span</span>></span>
        {channel &#x26;&#x26; (
          <span class="hljs-tag">&#x3C;<span class="hljs-name">Chat</span> <span class="hljs-attr">client</span>=<span class="hljs-string">{chatClient}</span>></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">Channel</span> <span class="hljs-attr">channel</span>=<span class="hljs-string">{channel}</span>></span>
              <span class="hljs-tag">&#x3C;<span class="hljs-name">Messages</span> /></span>
            <span class="hljs-tag">&#x3C;/<span class="hljs-name">Channel</span>></span>
          <span class="hljs-tag">&#x3C;/<span class="hljs-name">Chat</span>></span>
        )}
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Textarea</span>
          <span class="hljs-attr">id</span>=<span class="hljs-string">"message_text"</span>
          <span class="hljs-attr">name</span>=<span class="hljs-string">"message_text"</span>
          <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"메시지..."</span>
          <span class="hljs-attr">className</span>=<span class="hljs-string">"min-h-[100px] w-full"</span>
        /></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Button</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"max-w-max"</span>></span>
          메시지 보내기 <span class="hljs-symbol">&#x26;rarr;</span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">Button</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}
</code></pre>
<p>이제 새 메시지 렌더링 및 방문자로부터 입력을 받을 수 있는 textarea 요소가 있는 인덱스 라우트를 볼 수 있습니다. 메시지를 게시하는 기능을 구현하기 전에 해당 메시지를 고유한 ID와 연결하려고 할 것입니다. 다음과 같이 코드를 업데이트하십시오:</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use client"</span>;

<span class="hljs-keyword">import</span> <span class="hljs-title class_">Messages</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./Messages"</span>;
+ <span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Button</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/components/ui/button"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Channel</span>, <span class="hljs-title class_">Chat</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"stream-chat-react"</span>;
+ <span class="hljs-keyword">import</span> { <span class="hljs-title class_">DevToken</span>, <span class="hljs-title class_">StreamChat</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"stream-chat"</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Textarea</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">"@/components/ui/textarea"</span>;
+ <span class="hljs-keyword">import</span> { generateUsername } <span class="hljs-keyword">from</span> <span class="hljs-string">"unique-username-generator"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [channel, setChannel] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [chatClient, setChatClient] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
+ <span class="hljs-keyword">const</span> <span class="hljs-title function_">loadChatClient</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) => {
+   <span class="hljs-keyword">const</span> newChatClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamChat</span>(
+     process.<span class="hljs-property">env</span>.<span class="hljs-property">NEXT_PUBLIC_STREAM_API_KEY</span>,
+     {
+       <span class="hljs-attr">enableWSFallback</span>: <span class="hljs-literal">true</span>,
+     }
+   );
+    <span class="hljs-keyword">if</span> (newChatClient.<span class="hljs-property">user</span>) <span class="hljs-keyword">await</span> newChatClient.<span class="hljs-title function_">disconnectUser</span>();
+   <span class="hljs-keyword">const</span> localUser = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">"local_user"</span>);
+   <span class="hljs-keyword">if</span> (!localUser) <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">"local_user"</span>, <span class="hljs-title function_">generateUsername</span>());
+   <span class="hljs-keyword">const</span> id = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">"local_user"</span>);
+   <span class="hljs-keyword">const</span> userToConnect = { id };
+   <span class="hljs-keyword">await</span> newChatClient.<span class="hljs-title function_">connectUser</span>(userToConnect, <span class="hljs-title class_">DevToken</span>(userToConnect.<span class="hljs-property">id</span>));
+   <span class="hljs-title function_">setChatClient</span>(newChatClient);
+ };
+ <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
+   <span class="hljs-title function_">loadChatClient</span>();
+ }, []);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex max-w-[300px] flex-col gap-y-3 p-5"</span>></span>
      {/* 나머지 컴포넌트는 그대로 유지 */}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}
</code></pre>
<p>이제 loadChatClient 함수를 한 번 호출하여 웹소켓 연결을 Stream의 메시징 채널로 활성화했습니다. 그런 다음 세션과 연관된 사용자를 연결 해제합니다. 마지막으로, 방문자를 위해 고유한 사용자명을 생성합니다 (localStorage에 없는 경우). 이러한 단계를 통해 방문자가 고유하게 식별됨을 보장합니다.</p>
<p>특정 채널의 메시지를 청취하려면 다음과 같이 코드를 업데이트하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use client"</span>;

<span class="hljs-comment">// Imports as is</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [channel, setChannel] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [chatClient, setChatClient] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
+  <span class="hljs-keyword">const</span> <span class="hljs-title function_">watchChannel</span> = (<span class="hljs-params"></span>) => {
+    <span class="hljs-keyword">const</span> channel = chatClient.<span class="hljs-title function_">channel</span>(<span class="hljs-string">"messaging"</span>, <span class="hljs-string">"livestreaming_chat"</span>, {
+      <span class="hljs-attr">name</span>: <span class="hljs-string">"실시간 스트리밍 채팅"</span>,
+    });
+    channel.<span class="hljs-title function_">watch</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">setChannel</span>(channel));
+  };
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">loadChatClient</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) => {
    <span class="hljs-keyword">const</span> newChatClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamChat</span>(
      process.<span class="hljs-property">env</span>.<span class="hljs-property">NEXT_PUBLIC_STREAM_API_KEY</span>,
      {
        <span class="hljs-attr">enableWSFallback</span>: <span class="hljs-literal">true</span>,
      }
    );
    <span class="hljs-keyword">if</span> (newChatClient.<span class="hljs-property">user</span>) <span class="hljs-keyword">await</span> newChatClient.<span class="hljs-title function_">disconnectUser</span>();
    <span class="hljs-keyword">const</span> localUser = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">"local_user"</span>);
    <span class="hljs-keyword">if</span> (!localUser) <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">"local_user"</span>, <span class="hljs-title function_">generateUsername</span>());
    <span class="hljs-keyword">const</span> id = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">"local_user"</span>);
    <span class="hljs-keyword">const</span> userToConnect = { id };
    <span class="hljs-keyword">await</span> newChatClient.<span class="hljs-title function_">connectUser</span>(userToConnect, <span class="hljs-title class_">DevToken</span>(userToConnect.<span class="hljs-property">id</span>));
    <span class="hljs-title function_">setChatClient</span>(newChatClient);
  };
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-title function_">loadChatClient</span>();
  }, []);
+  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =></span> {
+    <span class="hljs-keyword">if</span> (chatClient) <span class="hljs-title function_">watchChannel</span>();
+  }, [chatClient]);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex max-w-[300px] flex-col gap-y-3 p-5"</span>></span>
      {/* 나머지 컴포넌트는 동일한 상태로 유지 */}
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}
</code></pre>
<p>방문자는 이제 livestreaming_chat 고유 ID로 식별되는 Live Stream Chat 채널에 연결되었습니다. 그런 다음 watch() 유틸리티를 사용하여 수신된 메시지를 청취하고 컨텍스트를 업데이트합니다.</p>
<p>채널에 메시지를 게시하려면 다음과 같이 코드를 업데이트하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-string">"use client"</span>;

<span class="hljs-comment">// 그대로 가져오기</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 변수, 훅 그대로</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex max-w-[300px] flex-col gap-y-3 p-5"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"flex w-[300px] flex-col gap-y-3"</span>></span>
        {/* 컴포넌트 나머지 */}
        <span class="hljs-tag">&#x3C;<span class="hljs-name">Button</span>
          <span class="hljs-attr">className</span>=<span class="hljs-string">"max-w-max"</span>
          <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> {
            if (channel) {
              channel.sendMessage({
                text: document.getElementById("message_text").value,
              });
              document.getElementById("message_text").value = "";
            }
          }
        >
          Send Message <span class="hljs-symbol">&#x26;rarr;</span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">Button</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}
</code></pre>
<p>onClick 이벤트에서 sendMessage 유틸리티를 사용하여 방 정보에 메시지를 게시할 수 있습니다. 깔끔하게 구현했네요!</p>
<p>이제 손님이 방문자를 위해 고유한 ID를 무작위로 생성하고 메시지 목록을 동적으로 렌더링하며 메시지를 게시할 수 있는 반응형 채팅 인터페이스를 완성했습니다. 이제 Next.js 애플리케이션을 Vercel에 배포합시다.</p>
<h1>Vercel에 배포하기</h1>
<p>이제 코드를 Vercel에 배포할 준비가 되었습니다. 아래 단계를 따라 배포하세요:</p>
<ul>
<li>먼저 앱 코드가 포함된 GitHub 저장소를 만듭니다.</li>
<li>그런 다음 Vercel 대시보드로 이동하여 새 프로젝트를 만듭니다.</li>
<li>새 프로젝트를 방금 만든 GitHub 저장소에 연결합니다.</li>
<li>설정에서 환경 변수를 로컬 .env 파일과 일치하도록 업데이트합니다.</li>
<li>배포를 클릭합니다.</li>
</ul>
<h1>마치며</h1>
<p>요약하면, 이 튜토리얼은 Next.js와 Stream을 통합하여 동적 실시간 채팅 환경을 구축하는 방법에 대한 포괄적인 안내를 제공합니다. 사용자가 인증 없이 참여할 수 있도록 허용하고 권한을 세밀하게 제어하여 실시간 상호작용을 보다 쉽게 만드는 방법을 배웠습니다.</p>
<h1>더 많은 정보</h1>
<p>더 자세한 통찰력을 얻으려면 이 게시물에서 인용된 참고 자료를 살펴보세요.</p>
<ul>
<li>GitHub 저장소</li>
<li>챗스코프 UI 킷</li>
<li>인증되지 않은 사용자 - 스트림</li>
<li>채널 시청 - 스트림</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"스트림을 사용하여 Nextjs에서 라이브 스트림 채팅 구축하기","description":"","date":"2024-05-14 12:09","slug":"2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs","content":"\n\n다음.js, Stream 및 Chatscope를 사용하여 매력적이고 인터랙티브한 라이브 스트리밍 채팅 앱을 만드는 방법을 배워보세요.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png)\n\n언제나 YouTube와 같은 라이브 스트리밍에서 발견되는 다이나믹한 채팅 경험을 어떻게 만들 수 있을지 궁금해했는데, 누구나 로그인 없이 참여할 수 있는 편리함을 더한 기능을 추가하고 싶었습니다.\n\nNext.js와 Stream을 사용하여 그 경험을 성공적으로 만들어냈습니다. 이 튜토리얼에서는 사용자 권한에 대한 세밀한 제어를 통해 실시간 상호작용을 보다 접근하기 쉽게 만드는 라이브 스트리밍 채팅 환경을 만드는 간단한 방법을 다루고 있습니다.\n\n\n\n# 데모\n\n기술적인 내용에 들어가기 전에, 이 튜토리얼에서 무엇을 만들게 될지 간단히 소개해 드릴게요 👇🏻\n\n# 준비물\n\n구현을 시작하기 위해 다음이 필요합니다:\n\n\n\n- Node.js 18 또는 그 이후 버전\n- Stream 계정\n- Vercel 계정\n\n# 새 Stream 애플리케이션 설정하기\n\n이 섹션에서는 새 Stream 애플리케이션을 생성하고, 인증 없이 사용자를 활성화하며, 사용자 권한을 정의하여 채널에 대한 읽기 및 게시를 설정하는 방법을 배울 수 있습니다. 시작해봅시다.\n\nStream 계정을 만들고 로그인한 후, + 앱 만들기를 클릭하여 Stream 채팅 애플리케이션 생성을 시작해보세요.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_1.png\" /\u003e\n\n어플리케이션 이름을 입력해주세요. 또한, 웹사이트 배포 지역/기능 근처의 채팅 저장 위치를 선택해주세요. 저는 인도에 있으므로 뭄바이로 설정했습니다.\n\n\u003cimg src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_2.png\" /\u003e\n\n설정이 완료되면 채팅 개요 화면으로 이동합니다. API 키를 복사하고, 안전한 장소에 저장하여 Next.js 애플리케이션에서 NEXT_PUBLIC_STREAM_API_KEY로 계속 사용할 수 있도록 해주세요.\n\n\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_3.png)\n\n권한 확인 없이 방문자가 채팅 메시지를 게시할 수 있도록 하려면 아래로 스크롤하여 \"인증 확인 비활성화\" 토글 버튼을 활성화하세요. 변경 사항을 동기화하려면 제출을 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_4.png)\n\n방문자가 특정 채널의 사용자로서 메시지를 게시할 수 있도록 하려면 그들을 위해 읽기 및 게시 권한을 활성화해야 합니다. 방문자가 채팅 애플리케이션에서 가정할 수 있는 역할과 권한을 구성할 수 있도록 하는 것이 매우 유용합니다.\n\n\n\n사용자 역할을 선택하고 메시징을 스코프로 선택한 다음 편집 버튼을 클릭하여 방문자의 권한을 구성하실 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_5.png)\n\n방문자가 메시지를 게시할 수 있도록 하려면 메시지 생성을 검색하고 \"메시지 생성\" 권한을 활성화하여 채널의 모든 사용자가 메시지를 보낼 수 있도록 허용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_6.png)\n\n\n\n방문자들이 채팅 기록을 읽을 수 있도록 하려면 'read channel'을 검색하여 Read Channel 및 Read Channel Members를 활성화하세요. 이렇게 하면 방문자가 메시지를 읽을 뿐만 아니라 해당 메시지를 게시한 사용자도 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_7.png)\n\n마지막으로 변경 사항을 동기화하려면 저장을 클릭하세요.\n\n![이미지](/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_8.png)\n\n\n\n이제 방문자가 할 수 있는 것들의 권한과 범위를 구성하는 것을 마쳤습니다. 이제 Chatscope UI Kit을 사용하여 Next.js에서 채팅 사용자 인터페이스를 구축해 봅시다.\n\n# 새 Next.js 애플리케이션 설정\n\n이 섹션에서는 새로운 Next.js 애플리케이션을 생성하는 방법, shadcn/ui를 설정하는 방법, 해당 애플리케이션의 요구 사항을 파악하여 빠른 구현을 위해 관련 라이브러리를 설치하는 방법을 배우게 될 것입니다.\n\n새로운 Next.js 프로젝트를 생성하는 것으로 시작해 봅시다. 터미널을 열고 다음 명령을 실행하세요:\n\n\n\n```js\r\nnpx create-next-app@latest my-chat-app\r\n```\r\n\r\n진행할 때, 다음을 선택하세요:\r\n\r\n- TypeScript를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\r\n- ESLint를 사용할 것인지 물으면 \"No\"를 선택하세요.\r\n- Tailwind CSS를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\r\n- src/ 디렉토리를 사용할 것인지 물으면 \"No\"를 선택하세요.\r\n- App Router를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\r\n- 기본 import alias를 맞춤 설정할 것인지 물으면 \"No\"를 선택하세요.\r\n\r\n위 과정을 마치면 프로젝트 디렉토리로 이동하여 다음 명령어를 실행하여 개발 모드에서 앱을 시작할 수 있습니다:\n\n\n\n```js\ncd my-chat-app\nnpm run dev\n```\n\n앱은 localhost:3000에서 실행 중이어야 합니다.\n\n이제 프로젝트의 루트에 .env 파일을 만드세요. 위 섹션에서 저장한 항목들을 추가할 것입니다.\n\n다음과 같이 보여야 합니다:\n\n\n\n```js\n# .env\n\n# 스트림 환경 변수\nNEXT_PUBLIC_STREAM_API_KEY=\"...\"\n\n```\n\n## shadcn/ui 컴포넌트 통합\n\n채팅 사용자 인터페이스를 빠르게 프로토타입화하기 위해 Next.js와 함께 shadcn/ui를 설정할 것입니다. shadcn/ui는 아름답게 디자인된 컴포넌트들의 모음으로, 여러분의 애플리케이션에 복사하여 붙여넣을 수 있습니다. 아래 명령어를 실행하여 shadcn/ui를 설정하세요:\n\n```js\nnpx shadcn-ui@latest init\n```\n\n\n\n구성 파일 components.json을 구성하는 몇 가지 질문에 답해야합니다. 다음을 선택하세요:\n\n- TypeScript를 사용하것이라고 하면 \"예\"를 선택하세요.\n- 사용할 스타일을 선택하라는 프롬프트가 나오면 \"기본\"을 선택하세요.\n- 기본 색상으로 선택하라는 프롬프트가 나오면 \"Slate\"를 선택하세요.\n- 색상에 CSS 변수를 사용하냐고 묻힐 경우 \"예\"를 선택하세요.\n\n위 작업이 완료되면, Next.js 애플리케이션에 React 구성 요소를 쉽게 추가할 수 있는 CLI가 설정됩니다. 아래 명령어를 실행하여 버튼, 입력란, 그리고 텍스트영역 요소를 가져올 수 있습니다.\n\n```js\nnpx shadcn-ui@latest add button\nnpx shadcn-ui@latest add input\nnpx shadcn-ui@latest add textarea\n```\n\n\n\n그것이 끝나면 이제 app/components 디렉토리 안에 ui 디렉토리가 보일 것입니다. 그 안에 button.tsx, input.tsx, textarea.tsx 파일이 있습니다.\n\n## Chatscope 및 Stream UI Kit를 React에 설치하기\n\n구현을 더 쉽게 만들기 위해 필요한 작업을 이제 알아봅시다.\n\n먼저, 각 방문자가 익명 사용자로 취급되므로 임의로 생성된 이름(id)으로 그들을 식별해야 합니다. 또한 채널에서 받은 각 메시지는 실시간으로 모든 방문자에게 전파되어야 합니다. 마지막으로, 모든 메시지가 채널로 들어오는 메시지로 표시되도록 해야 합니다.\n\n\n\n위의 요구 사항을 충족하기 위해 다음 명령을 실행하여 필요한 라이브러리를 설치하세요:\n\n```js\nnpm install @chatscope/chat-ui-kit-react\nnpm install stream-chat stream-chat-react\nnpm install unique-username-generator\n```\n\n다음 라이브러리가 설치됩니다:\n\n- unique-username-generator: 고유한 사용자 이름을 생성하는 패키지입니다.\n- stream-chat: Stream의 JavaScript API 클라이언트입니다.\n- stream-chat-react: Stream Chat을 위한 React 훅(그리고 컴포넌트) 라이브러리입니다.\n- @chatscope/chat-ui-kit-react: 채팅 UI의 프로토타입을 위한 React 컴포넌트 라이브러리입니다.\n\n\n\n자, 이제 반응형 채팅 사용자 인터페이스를 만들어 봅시다.\n\n# ChatScope와 Stream을 사용하여 채팅 사용자 인터페이스 만들기\n\n이 섹션에서는 방문자를 특정 채널에 연결하고, 채팅 기록을 렌더링하고, 메시지를 게시할 수 있도록 하는 React 컴포넌트를 구축하는 방법을 배우게 될 것입니다.\n\n먼저, 채팅 메시지 목록을 동적으로 렌더링하는 React 컴포넌트를 만들어 봅시다. Stream 및 Chatscope 라이브러리에서 컴포넌트를 사용할 것입니다.\n\n\n\n앱 디렉토리에 Messages.tsx 파일을 만들어서 아래 코드를 넣어주세요:\n\n```js\nimport { cn } from \"@/lib/utils\";\nimport { useChannelStateContext } from \"stream-chat-react\";\nimport { Message, MessageList } from \"@chatscope/chat-ui-kit-react\";\n\nexport default function () {\n  const { messages } = useChannelStateContext();\n  return (\n    \u003cMessageList\u003e\n      {messages?.map((i, index: number) =\u003e (\n        \u003cMessage\n          key={i.id}\n          model={{\n            position: \"normal\",\n            sender: i.user?.id,\n            direction: \"incoming\",\n            message: `${i.user?.id}: ${i.text}`,\n            sentTime: i.created_at?.toString(),\n          }}\n          className={cn(\n            \"bg-white rounded text-black py-2 text-xs\",\n            index !== messages.length - 1 \u0026\u0026 \"border-b\"\n          )}\n        /\u003e\n      ))}\n    \u003c/MessageList\u003e\n  );\n}\n```\n\n`useChannelStateContext` 훅을 사용하여 채팅 기록을 가져오고 새로운 메시지를 수신할 수 있습니다. `MessageList` 및 `Message` Chatscope UI 구성 요소를 사용하여 모든 메시지를 채널로 수신하도록 표시하고, 발신자 정보, 메시지 내용 및 타임스탬프와 매핑할 수 있습니다.\n\n이제 사용자가 채팅 기록을 볼 수 있고 메시지를 동시에 게시할 수 있는 경로를 작성해봅시다. 앱 디렉토리의 page.tsx 파일을 아래 코드로 업데이트해주세요:\n\n\n\n```js\n\"use client\";\n\nimport { useState } from \"react\";\nimport Messages from \"./Messages\";\nimport { Button } from \"@/components/ui/button\";\nimport { Channel, Chat } from \"stream-chat-react\";\nimport { Textarea } from \"@/components/ui/textarea\";\n\nexport default function () {\n  const [channel, setChannel] = useState(null);\n  const [chatClient, setChatClient] = useState(null);\n  return (\n    \u003cdiv className=\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003e\n      \u003cdiv className=\"flex w-[300px] flex-col gap-y-3\"\u003e\n        \u003cspan className=\"border-b border-gray-100 font-semibold\"\u003e채팅\u003c/span\u003e\n        {channel \u0026\u0026 (\n          \u003cChat client={chatClient}\u003e\n            \u003cChannel channel={channel}\u003e\n              \u003cMessages /\u003e\n            \u003c/Channel\u003e\n          \u003c/Chat\u003e\n        )}\n        \u003cTextarea\n          id=\"message_text\"\n          name=\"message_text\"\n          placeholder=\"메시지...\"\n          className=\"min-h-[100px] w-full\"\n        /\u003e\n        \u003cButton className=\"max-w-max\"\u003e\n          메시지 보내기 \u0026rarr;\n        \u003c/Button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n이제 새 메시지 렌더링 및 방문자로부터 입력을 받을 수 있는 textarea 요소가 있는 인덱스 라우트를 볼 수 있습니다. 메시지를 게시하는 기능을 구현하기 전에 해당 메시지를 고유한 ID와 연결하려고 할 것입니다. 다음과 같이 코드를 업데이트하십시오:\n\n```js\n\"use client\";\n\nimport Messages from \"./Messages\";\n+ import { useEffect, useState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Channel, Chat } from \"stream-chat-react\";\n+ import { DevToken, StreamChat } from \"stream-chat\";\nimport { Textarea } from \"@/components/ui/textarea\";\n+ import { generateUsername } from \"unique-username-generator\";\n\nexport default function () {\n  const [channel, setChannel] = useState(null);\n  const [chatClient, setChatClient] = useState(null);\n+ const loadChatClient = async () =\u003e {\n+   const newChatClient = new StreamChat(\n+     process.env.NEXT_PUBLIC_STREAM_API_KEY,\n+     {\n+       enableWSFallback: true,\n+     }\n+   );\n+    if (newChatClient.user) await newChatClient.disconnectUser();\n+   const localUser = localStorage.getItem(\"local_user\");\n+   if (!localUser) localStorage.setItem(\"local_user\", generateUsername());\n+   const id = localStorage.getItem(\"local_user\");\n+   const userToConnect = { id };\n+   await newChatClient.connectUser(userToConnect, DevToken(userToConnect.id));\n+   setChatClient(newChatClient);\n+ };\n+ useEffect(() =\u003e {\n+   loadChatClient();\n+ }, []);\n  return (\n    \u003cdiv className=\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003e\n      {/* 나머지 컴포넌트는 그대로 유지 */}\n    \u003c/div\u003e\n  );\n}\n```\n\n이제 loadChatClient 함수를 한 번 호출하여 웹소켓 연결을 Stream의 메시징 채널로 활성화했습니다. 그런 다음 세션과 연관된 사용자를 연결 해제합니다. 마지막으로, 방문자를 위해 고유한 사용자명을 생성합니다 (localStorage에 없는 경우). 이러한 단계를 통해 방문자가 고유하게 식별됨을 보장합니다.\n\n\n\n특정 채널의 메시지를 청취하려면 다음과 같이 코드를 업데이트하세요:\n\n```js\n\"use client\";\n\n// Imports as is\n\nexport default function () {\n  const [channel, setChannel] = useState(null);\n  const [chatClient, setChatClient] = useState(null);\n+  const watchChannel = () =\u003e {\n+    const channel = chatClient.channel(\"messaging\", \"livestreaming_chat\", {\n+      name: \"실시간 스트리밍 채팅\",\n+    });\n+    channel.watch().then(() =\u003e setChannel(channel));\n+  };\n  const loadChatClient = async () =\u003e {\n    const newChatClient = new StreamChat(\n      process.env.NEXT_PUBLIC_STREAM_API_KEY,\n      {\n        enableWSFallback: true,\n      }\n    );\n    if (newChatClient.user) await newChatClient.disconnectUser();\n    const localUser = localStorage.getItem(\"local_user\");\n    if (!localUser) localStorage.setItem(\"local_user\", generateUsername());\n    const id = localStorage.getItem(\"local_user\");\n    const userToConnect = { id };\n    await newChatClient.connectUser(userToConnect, DevToken(userToConnect.id));\n    setChatClient(newChatClient);\n  };\n  useEffect(() =\u003e {\n    loadChatClient();\n  }, []);\n+  useEffect(() =\u003e {\n+    if (chatClient) watchChannel();\n+  }, [chatClient]);\n  return (\n    \u003cdiv className=\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003e\n      {/* 나머지 컴포넌트는 동일한 상태로 유지 */}\n    \u003c/div\u003e\n  );\n}\n```\n\n방문자는 이제 livestreaming_chat 고유 ID로 식별되는 Live Stream Chat 채널에 연결되었습니다. 그런 다음 watch() 유틸리티를 사용하여 수신된 메시지를 청취하고 컨텍스트를 업데이트합니다.\n\n채널에 메시지를 게시하려면 다음과 같이 코드를 업데이트하세요:\n\n\n\n```js\n\"use client\";\n\n// 그대로 가져오기\n\nexport default function () {\n  // 변수, 훅 그대로\n  return (\n    \u003cdiv className=\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003e\n      \u003cdiv className=\"flex w-[300px] flex-col gap-y-3\"\u003e\n        {/* 컴포넌트 나머지 */}\n        \u003cButton\n          className=\"max-w-max\"\n          onClick={() =\u003e {\n            if (channel) {\n              channel.sendMessage({\n                text: document.getElementById(\"message_text\").value,\n              });\n              document.getElementById(\"message_text\").value = \"\";\n            }\n          }\n        \u003e\n          Send Message \u0026rarr;\n        \u003c/Button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\nonClick 이벤트에서 sendMessage 유틸리티를 사용하여 방 정보에 메시지를 게시할 수 있습니다. 깔끔하게 구현했네요!\n\n이제 손님이 방문자를 위해 고유한 ID를 무작위로 생성하고 메시지 목록을 동적으로 렌더링하며 메시지를 게시할 수 있는 반응형 채팅 인터페이스를 완성했습니다. 이제 Next.js 애플리케이션을 Vercel에 배포합시다.\n\n# Vercel에 배포하기\n\n\n\n이제 코드를 Vercel에 배포할 준비가 되었습니다. 아래 단계를 따라 배포하세요:\n\n- 먼저 앱 코드가 포함된 GitHub 저장소를 만듭니다.\n- 그런 다음 Vercel 대시보드로 이동하여 새 프로젝트를 만듭니다.\n- 새 프로젝트를 방금 만든 GitHub 저장소에 연결합니다.\n- 설정에서 환경 변수를 로컬 .env 파일과 일치하도록 업데이트합니다.\n- 배포를 클릭합니다.\n\n# 마치며\n\n요약하면, 이 튜토리얼은 Next.js와 Stream을 통합하여 동적 실시간 채팅 환경을 구축하는 방법에 대한 포괄적인 안내를 제공합니다. 사용자가 인증 없이 참여할 수 있도록 허용하고 권한을 세밀하게 제어하여 실시간 상호작용을 보다 쉽게 만드는 방법을 배웠습니다.\n\n\n\n# 더 많은 정보\n\n더 자세한 통찰력을 얻으려면 이 게시물에서 인용된 참고 자료를 살펴보세요.\n\n- GitHub 저장소\n- 챗스코프 UI 킷\n- 인증되지 않은 사용자 - 스트림\n- 채널 시청 - 스트림","ogImage":{"url":"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png"},"coverImage":"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e다음.js, Stream 및 Chatscope를 사용하여 매력적이고 인터랙티브한 라이브 스트리밍 채팅 앱을 만드는 방법을 배워보세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e언제나 YouTube와 같은 라이브 스트리밍에서 발견되는 다이나믹한 채팅 경험을 어떻게 만들 수 있을지 궁금해했는데, 누구나 로그인 없이 참여할 수 있는 편리함을 더한 기능을 추가하고 싶었습니다.\u003c/p\u003e\n\u003cp\u003eNext.js와 Stream을 사용하여 그 경험을 성공적으로 만들어냈습니다. 이 튜토리얼에서는 사용자 권한에 대한 세밀한 제어를 통해 실시간 상호작용을 보다 접근하기 쉽게 만드는 라이브 스트리밍 채팅 환경을 만드는 간단한 방법을 다루고 있습니다.\u003c/p\u003e\n\u003ch1\u003e데모\u003c/h1\u003e\n\u003cp\u003e기술적인 내용에 들어가기 전에, 이 튜토리얼에서 무엇을 만들게 될지 간단히 소개해 드릴게요 👇🏻\u003c/p\u003e\n\u003ch1\u003e준비물\u003c/h1\u003e\n\u003cp\u003e구현을 시작하기 위해 다음이 필요합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNode.js 18 또는 그 이후 버전\u003c/li\u003e\n\u003cli\u003eStream 계정\u003c/li\u003e\n\u003cli\u003eVercel 계정\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e새 Stream 애플리케이션 설정하기\u003c/h1\u003e\n\u003cp\u003e이 섹션에서는 새 Stream 애플리케이션을 생성하고, 인증 없이 사용자를 활성화하며, 사용자 권한을 정의하여 채널에 대한 읽기 및 게시를 설정하는 방법을 배울 수 있습니다. 시작해봅시다.\u003c/p\u003e\n\u003cp\u003eStream 계정을 만들고 로그인한 후, + 앱 만들기를 클릭하여 Stream 채팅 애플리케이션 생성을 시작해보세요.\u003c/p\u003e\n\u003cp\u003e어플리케이션 이름을 입력해주세요. 또한, 웹사이트 배포 지역/기능 근처의 채팅 저장 위치를 선택해주세요. 저는 인도에 있으므로 뭄바이로 설정했습니다.\u003c/p\u003e\n\u003cp\u003e설정이 완료되면 채팅 개요 화면으로 이동합니다. API 키를 복사하고, 안전한 장소에 저장하여 Next.js 애플리케이션에서 NEXT_PUBLIC_STREAM_API_KEY로 계속 사용할 수 있도록 해주세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e권한 확인 없이 방문자가 채팅 메시지를 게시할 수 있도록 하려면 아래로 스크롤하여 \"인증 확인 비활성화\" 토글 버튼을 활성화하세요. 변경 사항을 동기화하려면 제출을 클릭하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e방문자가 특정 채널의 사용자로서 메시지를 게시할 수 있도록 하려면 그들을 위해 읽기 및 게시 권한을 활성화해야 합니다. 방문자가 채팅 애플리케이션에서 가정할 수 있는 역할과 권한을 구성할 수 있도록 하는 것이 매우 유용합니다.\u003c/p\u003e\n\u003cp\u003e사용자 역할을 선택하고 메시징을 스코프로 선택한 다음 편집 버튼을 클릭하여 방문자의 권한을 구성하실 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e방문자가 메시지를 게시할 수 있도록 하려면 메시지 생성을 검색하고 \"메시지 생성\" 권한을 활성화하여 채널의 모든 사용자가 메시지를 보낼 수 있도록 허용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e방문자들이 채팅 기록을 읽을 수 있도록 하려면 'read channel'을 검색하여 Read Channel 및 Read Channel Members를 활성화하세요. 이렇게 하면 방문자가 메시지를 읽을 뿐만 아니라 해당 메시지를 게시한 사용자도 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e마지막으로 변경 사항을 동기화하려면 저장을 클릭하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 방문자가 할 수 있는 것들의 권한과 범위를 구성하는 것을 마쳤습니다. 이제 Chatscope UI Kit을 사용하여 Next.js에서 채팅 사용자 인터페이스를 구축해 봅시다.\u003c/p\u003e\n\u003ch1\u003e새 Next.js 애플리케이션 설정\u003c/h1\u003e\n\u003cp\u003e이 섹션에서는 새로운 Next.js 애플리케이션을 생성하는 방법, shadcn/ui를 설정하는 방법, 해당 애플리케이션의 요구 사항을 파악하여 빠른 구현을 위해 관련 라이브러리를 설치하는 방법을 배우게 될 것입니다.\u003c/p\u003e\n\u003cp\u003e새로운 Next.js 프로젝트를 생성하는 것으로 시작해 봅시다. 터미널을 열고 다음 명령을 실행하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpx create-next-app@latest my-chat-app\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e진행할 때, 다음을 선택하세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTypeScript를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\u003c/li\u003e\n\u003cli\u003eESLint를 사용할 것인지 물으면 \"No\"를 선택하세요.\u003c/li\u003e\n\u003cli\u003eTailwind CSS를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\u003c/li\u003e\n\u003cli\u003esrc/ 디렉토리를 사용할 것인지 물으면 \"No\"를 선택하세요.\u003c/li\u003e\n\u003cli\u003eApp Router를 사용할 것인지 물으면 \"Yes\"를 선택하세요.\u003c/li\u003e\n\u003cli\u003e기본 import alias를 맞춤 설정할 것인지 물으면 \"No\"를 선택하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위 과정을 마치면 프로젝트 디렉토리로 이동하여 다음 명령어를 실행하여 개발 모드에서 앱을 시작할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd my-chat-app\nnpm run dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e앱은 localhost:3000에서 실행 중이어야 합니다.\u003c/p\u003e\n\u003cp\u003e이제 프로젝트의 루트에 .env 파일을 만드세요. 위 섹션에서 저장한 항목들을 추가할 것입니다.\u003c/p\u003e\n\u003cp\u003e다음과 같이 보여야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# .\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e\n\n# 스트림 환경 변수\n\u003cspan class=\"hljs-variable constant_\"\u003eNEXT_PUBLIC_STREAM_API_KEY\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eshadcn/ui 컴포넌트 통합\u003c/h2\u003e\n\u003cp\u003e채팅 사용자 인터페이스를 빠르게 프로토타입화하기 위해 Next.js와 함께 shadcn/ui를 설정할 것입니다. shadcn/ui는 아름답게 디자인된 컴포넌트들의 모음으로, 여러분의 애플리케이션에 복사하여 붙여넣을 수 있습니다. 아래 명령어를 실행하여 shadcn/ui를 설정하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpx shadcn-ui@latest init\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e구성 파일 components.json을 구성하는 몇 가지 질문에 답해야합니다. 다음을 선택하세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTypeScript를 사용하것이라고 하면 \"예\"를 선택하세요.\u003c/li\u003e\n\u003cli\u003e사용할 스타일을 선택하라는 프롬프트가 나오면 \"기본\"을 선택하세요.\u003c/li\u003e\n\u003cli\u003e기본 색상으로 선택하라는 프롬프트가 나오면 \"Slate\"를 선택하세요.\u003c/li\u003e\n\u003cli\u003e색상에 CSS 변수를 사용하냐고 묻힐 경우 \"예\"를 선택하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위 작업이 완료되면, Next.js 애플리케이션에 React 구성 요소를 쉽게 추가할 수 있는 CLI가 설정됩니다. 아래 명령어를 실행하여 버튼, 입력란, 그리고 텍스트영역 요소를 가져올 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpx shadcn-ui@latest add button\nnpx shadcn-ui@latest add input\nnpx shadcn-ui@latest add textarea\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그것이 끝나면 이제 app/components 디렉토리 안에 ui 디렉토리가 보일 것입니다. 그 안에 button.tsx, input.tsx, textarea.tsx 파일이 있습니다.\u003c/p\u003e\n\u003ch2\u003eChatscope 및 Stream UI Kit를 React에 설치하기\u003c/h2\u003e\n\u003cp\u003e구현을 더 쉽게 만들기 위해 필요한 작업을 이제 알아봅시다.\u003c/p\u003e\n\u003cp\u003e먼저, 각 방문자가 익명 사용자로 취급되므로 임의로 생성된 이름(id)으로 그들을 식별해야 합니다. 또한 채널에서 받은 각 메시지는 실시간으로 모든 방문자에게 전파되어야 합니다. 마지막으로, 모든 메시지가 채널로 들어오는 메시지로 표시되도록 해야 합니다.\u003c/p\u003e\n\u003cp\u003e위의 요구 사항을 충족하기 위해 다음 명령을 실행하여 필요한 라이브러리를 설치하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install @chatscope/chat-ui-kit-react\nnpm install stream-chat stream-chat-react\nnpm install unique-username-generator\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 라이브러리가 설치됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eunique-username-generator: 고유한 사용자 이름을 생성하는 패키지입니다.\u003c/li\u003e\n\u003cli\u003estream-chat: Stream의 JavaScript API 클라이언트입니다.\u003c/li\u003e\n\u003cli\u003estream-chat-react: Stream Chat을 위한 React 훅(그리고 컴포넌트) 라이브러리입니다.\u003c/li\u003e\n\u003cli\u003e@chatscope/chat-ui-kit-react: 채팅 UI의 프로토타입을 위한 React 컴포넌트 라이브러리입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e자, 이제 반응형 채팅 사용자 인터페이스를 만들어 봅시다.\u003c/p\u003e\n\u003ch1\u003eChatScope와 Stream을 사용하여 채팅 사용자 인터페이스 만들기\u003c/h1\u003e\n\u003cp\u003e이 섹션에서는 방문자를 특정 채널에 연결하고, 채팅 기록을 렌더링하고, 메시지를 게시할 수 있도록 하는 React 컴포넌트를 구축하는 방법을 배우게 될 것입니다.\u003c/p\u003e\n\u003cp\u003e먼저, 채팅 메시지 목록을 동적으로 렌더링하는 React 컴포넌트를 만들어 봅시다. Stream 및 Chatscope 라이브러리에서 컴포넌트를 사용할 것입니다.\u003c/p\u003e\n\u003cp\u003e앱 디렉토리에 Messages.tsx 파일을 만들어서 아래 코드를 넣어주세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { cn } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@/lib/utils\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useChannelStateContext } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"stream-chat-react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eMessage\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eMessageList\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@chatscope/chat-ui-kit-react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { messages } = \u003cspan class=\"hljs-title function_\"\u003euseChannelStateContext\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMessageList\u003c/span\u003e\u003e\u003c/span\u003e\n      {messages?.map((i, index: number) =\u003e (\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMessage\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{i.id}\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003emodel\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003eposition:\u003c/span\u003e \"\u003cspan class=\"hljs-attr\"\u003enormal\u003c/span\u003e\",\n            \u003cspan class=\"hljs-attr\"\u003esender:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ei.user\u003c/span\u003e?\u003cspan class=\"hljs-attr\"\u003e.id\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003edirection:\u003c/span\u003e \"\u003cspan class=\"hljs-attr\"\u003eincoming\u003c/span\u003e\",\n            \u003cspan class=\"hljs-attr\"\u003emessage:\u003c/span\u003e `${\u003cspan class=\"hljs-attr\"\u003ei.user\u003c/span\u003e?\u003cspan class=\"hljs-attr\"\u003e.id\u003c/span\u003e}\u003cspan class=\"hljs-attr\"\u003e:\u003c/span\u003e ${\u003cspan class=\"hljs-attr\"\u003ei.text\u003c/span\u003e}`,\n            \u003cspan class=\"hljs-attr\"\u003esentTime:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ei.created_at\u003c/span\u003e?\u003cspan class=\"hljs-attr\"\u003e.toString\u003c/span\u003e(),\n          }}\n          \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{cn(\u003c/span\u003e\n            \"\u003cspan class=\"hljs-attr\"\u003ebg-white\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erounded\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etext-black\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epy-2\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etext-xs\u003c/span\u003e\",\n            \u003cspan class=\"hljs-attr\"\u003eindex\u003c/span\u003e !== \u003cspan class=\"hljs-string\"\u003emessages.length\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e1\u003c/span\u003e \u0026#x26;\u0026#x26; \"\u003cspan class=\"hljs-attr\"\u003eborder-b\u003c/span\u003e\"\n          )}\n        /\u003e\u003c/span\u003e\n      ))}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eMessageList\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003euseChannelStateContext\u003c/code\u003e 훅을 사용하여 채팅 기록을 가져오고 새로운 메시지를 수신할 수 있습니다. \u003ccode\u003eMessageList\u003c/code\u003e 및 \u003ccode\u003eMessage\u003c/code\u003e Chatscope UI 구성 요소를 사용하여 모든 메시지를 채널로 수신하도록 표시하고, 발신자 정보, 메시지 내용 및 타임스탬프와 매핑할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 사용자가 채팅 기록을 볼 수 있고 메시지를 동시에 게시할 수 있는 경로를 작성해봅시다. 앱 디렉토리의 page.tsx 파일을 아래 코드로 업데이트해주세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use client\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMessages\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./Messages\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@/components/ui/button\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eChannel\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eChat\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"stream-chat-react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eTextarea\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@/components/ui/textarea\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [channel, setChannel] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [chatClient, setChatClient] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"flex w-[300px] flex-col gap-y-3\"\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"border-b border-gray-100 font-semibold\"\u003c/span\u003e\u003e\u003c/span\u003e채팅\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003espan\u003c/span\u003e\u003e\u003c/span\u003e\n        {channel \u0026#x26;\u0026#x26; (\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eChat\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclient\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{chatClient}\u003c/span\u003e\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eChannel\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003echannel\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{channel}\u003c/span\u003e\u003e\u003c/span\u003e\n              \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eMessages\u003c/span\u003e /\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eChannel\u003c/span\u003e\u003e\u003c/span\u003e\n          \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eChat\u003c/span\u003e\u003e\u003c/span\u003e\n        )}\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eTextarea\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"message_text\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"message_text\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eplaceholder\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"메시지...\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"min-h-[100px] w-full\"\u003c/span\u003e\n        /\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"max-w-max\"\u003c/span\u003e\u003e\u003c/span\u003e\n          메시지 보내기 \u003cspan class=\"hljs-symbol\"\u003e\u0026#x26;rarr;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 새 메시지 렌더링 및 방문자로부터 입력을 받을 수 있는 textarea 요소가 있는 인덱스 라우트를 볼 수 있습니다. 메시지를 게시하는 기능을 구현하기 전에 해당 메시지를 고유한 ID와 연결하려고 할 것입니다. 다음과 같이 코드를 업데이트하십시오:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use client\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMessages\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./Messages\"\u003c/span\u003e;\n+ \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useEffect, useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@/components/ui/button\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eChannel\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eChat\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"stream-chat-react\"\u003c/span\u003e;\n+ \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eDevToken\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eStreamChat\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"stream-chat\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eTextarea\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@/components/ui/textarea\"\u003c/span\u003e;\n+ \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { generateUsername } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"unique-username-generator\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [channel, setChannel] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [chatClient, setChatClient] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n+ \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloadChatClient\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n+   \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newChatClient = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStreamChat\u003c/span\u003e(\n+     process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNEXT_PUBLIC_STREAM_API_KEY\u003c/span\u003e,\n+     {\n+       \u003cspan class=\"hljs-attr\"\u003eenableWSFallback\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n+     }\n+   );\n+    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (newChatClient.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e newChatClient.\u003cspan class=\"hljs-title function_\"\u003edisconnectUser\u003c/span\u003e();\n+   \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e localUser = \u003cspan class=\"hljs-variable language_\"\u003elocalStorage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetItem\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"local_user\"\u003c/span\u003e);\n+   \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!localUser) \u003cspan class=\"hljs-variable language_\"\u003elocalStorage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esetItem\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"local_user\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003egenerateUsername\u003c/span\u003e());\n+   \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e id = \u003cspan class=\"hljs-variable language_\"\u003elocalStorage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetItem\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"local_user\"\u003c/span\u003e);\n+   \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userToConnect = { id };\n+   \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e newChatClient.\u003cspan class=\"hljs-title function_\"\u003econnectUser\u003c/span\u003e(userToConnect, \u003cspan class=\"hljs-title class_\"\u003eDevToken\u003c/span\u003e(userToConnect.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e));\n+   \u003cspan class=\"hljs-title function_\"\u003esetChatClient\u003c/span\u003e(newChatClient);\n+ };\n+ \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n+   \u003cspan class=\"hljs-title function_\"\u003eloadChatClient\u003c/span\u003e();\n+ }, []);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003c/span\u003e\u003e\u003c/span\u003e\n      {/* 나머지 컴포넌트는 그대로 유지 */}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 loadChatClient 함수를 한 번 호출하여 웹소켓 연결을 Stream의 메시징 채널로 활성화했습니다. 그런 다음 세션과 연관된 사용자를 연결 해제합니다. 마지막으로, 방문자를 위해 고유한 사용자명을 생성합니다 (localStorage에 없는 경우). 이러한 단계를 통해 방문자가 고유하게 식별됨을 보장합니다.\u003c/p\u003e\n\u003cp\u003e특정 채널의 메시지를 청취하려면 다음과 같이 코드를 업데이트하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use client\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// Imports as is\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [channel, setChannel] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [chatClient, setChatClient] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n+  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ewatchChannel\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n+    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e channel = chatClient.\u003cspan class=\"hljs-title function_\"\u003echannel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"messaging\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"livestreaming_chat\"\u003c/span\u003e, {\n+      \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"실시간 스트리밍 채팅\"\u003c/span\u003e,\n+    });\n+    channel.\u003cspan class=\"hljs-title function_\"\u003ewatch\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetChannel\u003c/span\u003e(channel));\n+  };\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloadChatClient\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newChatClient = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStreamChat\u003c/span\u003e(\n      process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNEXT_PUBLIC_STREAM_API_KEY\u003c/span\u003e,\n      {\n        \u003cspan class=\"hljs-attr\"\u003eenableWSFallback\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n      }\n    );\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (newChatClient.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e newChatClient.\u003cspan class=\"hljs-title function_\"\u003edisconnectUser\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e localUser = \u003cspan class=\"hljs-variable language_\"\u003elocalStorage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetItem\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"local_user\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!localUser) \u003cspan class=\"hljs-variable language_\"\u003elocalStorage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esetItem\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"local_user\"\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003egenerateUsername\u003c/span\u003e());\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e id = \u003cspan class=\"hljs-variable language_\"\u003elocalStorage\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetItem\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"local_user\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userToConnect = { id };\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e newChatClient.\u003cspan class=\"hljs-title function_\"\u003econnectUser\u003c/span\u003e(userToConnect, \u003cspan class=\"hljs-title class_\"\u003eDevToken\u003c/span\u003e(userToConnect.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e));\n    \u003cspan class=\"hljs-title function_\"\u003esetChatClient\u003c/span\u003e(newChatClient);\n  };\n  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003eloadChatClient\u003c/span\u003e();\n  }, []);\n+  \u003cspan class=\"hljs-title function_\"\u003euseEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n+    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (chatClient) \u003cspan class=\"hljs-title function_\"\u003ewatchChannel\u003c/span\u003e();\n+  }, [chatClient]);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003c/span\u003e\u003e\u003c/span\u003e\n      {/* 나머지 컴포넌트는 동일한 상태로 유지 */}\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e방문자는 이제 livestreaming_chat 고유 ID로 식별되는 Live Stream Chat 채널에 연결되었습니다. 그런 다음 watch() 유틸리티를 사용하여 수신된 메시지를 청취하고 컨텍스트를 업데이트합니다.\u003c/p\u003e\n\u003cp\u003e채널에 메시지를 게시하려면 다음과 같이 코드를 업데이트하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"use client\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 그대로 가져오기\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 변수, 훅 그대로\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"flex max-w-[300px] flex-col gap-y-3 p-5\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"flex w-[300px] flex-col gap-y-3\"\u003c/span\u003e\u003e\u003c/span\u003e\n        {/* 컴포넌트 나머지 */}\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"max-w-max\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eonClick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{()\u003c/span\u003e =\u003e\u003c/span\u003e {\n            if (channel) {\n              channel.sendMessage({\n                text: document.getElementById(\"message_text\").value,\n              });\n              document.getElementById(\"message_text\").value = \"\";\n            }\n          }\n        \u003e\n          Send Message \u003cspan class=\"hljs-symbol\"\u003e\u0026#x26;rarr;\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eButton\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eonClick 이벤트에서 sendMessage 유틸리티를 사용하여 방 정보에 메시지를 게시할 수 있습니다. 깔끔하게 구현했네요!\u003c/p\u003e\n\u003cp\u003e이제 손님이 방문자를 위해 고유한 ID를 무작위로 생성하고 메시지 목록을 동적으로 렌더링하며 메시지를 게시할 수 있는 반응형 채팅 인터페이스를 완성했습니다. 이제 Next.js 애플리케이션을 Vercel에 배포합시다.\u003c/p\u003e\n\u003ch1\u003eVercel에 배포하기\u003c/h1\u003e\n\u003cp\u003e이제 코드를 Vercel에 배포할 준비가 되었습니다. 아래 단계를 따라 배포하세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e먼저 앱 코드가 포함된 GitHub 저장소를 만듭니다.\u003c/li\u003e\n\u003cli\u003e그런 다음 Vercel 대시보드로 이동하여 새 프로젝트를 만듭니다.\u003c/li\u003e\n\u003cli\u003e새 프로젝트를 방금 만든 GitHub 저장소에 연결합니다.\u003c/li\u003e\n\u003cli\u003e설정에서 환경 변수를 로컬 .env 파일과 일치하도록 업데이트합니다.\u003c/li\u003e\n\u003cli\u003e배포를 클릭합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e마치며\u003c/h1\u003e\n\u003cp\u003e요약하면, 이 튜토리얼은 Next.js와 Stream을 통합하여 동적 실시간 채팅 환경을 구축하는 방법에 대한 포괄적인 안내를 제공합니다. 사용자가 인증 없이 참여할 수 있도록 허용하고 권한을 세밀하게 제어하여 실시간 상호작용을 보다 쉽게 만드는 방법을 배웠습니다.\u003c/p\u003e\n\u003ch1\u003e더 많은 정보\u003c/h1\u003e\n\u003cp\u003e더 자세한 통찰력을 얻으려면 이 게시물에서 인용된 참고 자료를 살펴보세요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGitHub 저장소\u003c/li\u003e\n\u003cli\u003e챗스코프 UI 킷\u003c/li\u003e\n\u003cli\u003e인증되지 않은 사용자 - 스트림\u003c/li\u003e\n\u003cli\u003e채널 시청 - 스트림\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-UsingStreamtoBuildaLivestreamChatinNextjs"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>