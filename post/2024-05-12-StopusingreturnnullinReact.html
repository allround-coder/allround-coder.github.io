<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트에서 return null을 사용하지 마세요 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-StopusingreturnnullinReact" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트에서 return null을 사용하지 마세요 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트에서 return null을 사용하지 마세요 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-StopusingreturnnullinReact_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-StopusingreturnnullinReact" data-gatsby-head="true"/><meta name="twitter:title" content="리액트에서 return null을 사용하지 마세요 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-StopusingreturnnullinReact_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 21:01" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_buildManifest.js" defer=""></script><script src="/_next/static/z1a6VTi5qHH9JJH7jaxL3/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트에서 return null을 사용하지 마세요</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트에서 return null을 사용하지 마세요" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-StopusingreturnnullinReact&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><img src="/assets/img/2024-05-12-StopusingreturnnullinReact_0.png"/>
<p>React를 사용할 때 컴포넌트에서 반환된 값의 의미를 이해하는 것이 중요합니다. 컴포넌트가 아무것도 렌더링하지 않아야 한다는 것을 나타내기 위해 return null을 사용하는 것이 유혹스러울 수 있지만, 이는 의도하지 않은 결과를 초래할 수 있습니다. 이 게시물에서는 React 컴포넌트에서 return null을 사용하는 것이 나쁜 습관으로 여겨지는 이유와 return false가 더 좋은 대안인 이유에 대해 살펴보겠습니다.</p>
<h1>&quot;return null&quot; 사용에 대한 문제점</h1>
<p>컴포넌트에서 return null을 사용하는 주된 문제점은 애플리케이션에서 예상치 못한 동작을 일으킬 수 있다는 것입니다. 특히, null은 React에서 렌더링할 유효한 값으로 처리되며, 이로 인해 컴포넌트의 자식 요소가 트리에서 분리될 수 있습니다. 이는 예기치 않은 다시 렌더링이나 상태 불일치 등 다양한 문제를 초래할 수 있습니다.</p>
<p>이것이 발생하는 이유를 이해하기 위해서는 React가 어떻게 작동하는지에 대해 알아야 도움이 됩니다. 컴포넌트가 렌더링될 때, React는 현재 UI 상태를 나타내는 가상 DOM 트리를 생성합니다. 그런 다음 이 트리는 이전 트리와 비교되어 UI의 어느 부분을 업데이트해야 하는지를 결정합니다. 컴포넌트가 null을 반환하면, React에게 아무것도 렌더링할 필요가 없다고 알립니다. 그러나 이는 컴포넌트의 자식들이 업데이트되어야 하는 상태나 프롭을 가지고 있을 때 문제를 일으킬 수 있습니다.</p>
<p>다음 예시를 살펴보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child rendered&#x27;</span>);
  });

  <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count - 1)}&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      {count}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>이 예시에서, Child 컴포넌트는 count가 0과 같을 때 아무것도 렌더링하지 않아야 한다는 것을 나타내기 위해 return null을 사용합니다. 그러나 이는 Child 컴포넌트가 count의 값이 0이 아닌 값으로 다시 렌더링될 때 문제를 일으킬 수 있습니다. 이 경우에 React는 Child 컴포넌트를 트리에 다시 연결해야 하며, 예상치 못한 동작을 일으킬 수 있습니다.</p>
<h1>&quot;return false&quot;의 장점</h1>
<p>return null 대신에 return false를 사용하는 것이 더 좋은 방법입니다. 컴포넌트가 false를 반환하면 React는 이를 null을 반환한 것처럼 처리하지만, 또한 React에게 해당 컴포넌트의 자식들을 렌더링하지 말라고 말합니다. 이렇게 하면 컴포넌트와 해당 자식들이 트리에 연결된 채로 유지되어, return null을 사용했을 때 발생할 수 있는 문제점을 회피할 수 있습니다.</p>
<p>다음은 return false를 사용하는 이전 예제의 업데이트된 버전입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Child rendered&#x27;</span>);
  });

  <span class="hljs-keyword">if</span> (count === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count - 1)}&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      {count}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>이 버전에서 Child 컴포넌트는 count가 0과 동일할 때 null 대신 false를 반환합니다. 이렇게 하면 컴포넌트와 해당 하위 요소가 렌더링할 필요가 없을 때에도 트리에 연결된 상태를 유지합니다. 결과적으로, 컴포넌트가 더 예측 가능하게 동작하고 return null을 사용할 때 발생할 수 있는 문제를 피할 수 있습니다.</p>
<h1>&quot;return false&quot;를 사용하는 경우</h1>
<p>일반적으로 return null 대신에 return false를 사용하는 것이 더 나은 실천 방법이지만, 적용하기에 적절하지 않을 수 있는 경우가 있음을 기억하는 것이 중요합니다. 구체적으로, 컴포넌트가 렌더링할 필요가 없음을 나타내야 하는 경우에만 return false를 사용해야 합니다. 컴포넌트가 조건에 따라 무언가를 렌더링해야 하는 경우에는 if 문이나 삼항 연산자와 같은 조건부 렌더링 기술을 사용해야 합니다.</p>
<p>다음은 if 문을 사용한 조건부 렌더링 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">{ isLoggedIn }</span>) {
  <span class="hljs-keyword">if</span> (!isLoggedIn) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginForm</span> /&gt;</span></span>;
  }

  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dashboard</span> /&gt;</span></span>;
}
</code></pre>
<p>이 예에서 MyComponent 컴포넌트는 사용자가 로그인했는지에 따라 LoginForm 또는 Dashboard를 조건부로 렌더링하는 if 문을 사용합니다. 이는 return false 대신 조건부 렌더링을 사용하는 더 적절한 방법입니다.</p>
<h1>결론</h1>
<p>결론적으로, React 컴포넌트에서 return null을 사용하면 예기치 않은 동작을 유발하므로 일반적으로 피해야 합니다. 대신 컴포넌트가 렌더링하지 말아야 함을 나타내어야 할 때는 return false를 사용해야 합니다. 이렇게 함으로써 컴포넌트와 그 하위 요소는 트리에 연결된 상태를 유지하고 return null 사용으로 발생할 수 있는 문제를 피할 수 있습니다.</p>
<pre><code>


그러나 return false를 사용하는 경우는 컴포넌트가 아무것도 렌더링하지 말아야 하는 경우에만 사용해야 한다는 점을 명심해야 합니다. 컴포넌트가 조건부로 렌더링해야 하는 경우에는 조건부 렌더링 기술을 사용해야 합니다.
</code></pre></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트에서 return null을 사용하지 마세요","description":"","date":"2024-05-12 21:01","slug":"2024-05-12-StopusingreturnnullinReact","content":"\n\n\u003cimg src=\"/assets/img/2024-05-12-StopusingreturnnullinReact_0.png\" /\u003e\n\nReact를 사용할 때 컴포넌트에서 반환된 값의 의미를 이해하는 것이 중요합니다. 컴포넌트가 아무것도 렌더링하지 않아야 한다는 것을 나타내기 위해 return null을 사용하는 것이 유혹스러울 수 있지만, 이는 의도하지 않은 결과를 초래할 수 있습니다. 이 게시물에서는 React 컴포넌트에서 return null을 사용하는 것이 나쁜 습관으로 여겨지는 이유와 return false가 더 좋은 대안인 이유에 대해 살펴보겠습니다.\n\n# \"return null\" 사용에 대한 문제점\n\n컴포넌트에서 return null을 사용하는 주된 문제점은 애플리케이션에서 예상치 못한 동작을 일으킬 수 있다는 것입니다. 특히, null은 React에서 렌더링할 유효한 값으로 처리되며, 이로 인해 컴포넌트의 자식 요소가 트리에서 분리될 수 있습니다. 이는 예기치 않은 다시 렌더링이나 상태 불일치 등 다양한 문제를 초래할 수 있습니다.\n\n\n\n이것이 발생하는 이유를 이해하기 위해서는 React가 어떻게 작동하는지에 대해 알아야 도움이 됩니다. 컴포넌트가 렌더링될 때, React는 현재 UI 상태를 나타내는 가상 DOM 트리를 생성합니다. 그런 다음 이 트리는 이전 트리와 비교되어 UI의 어느 부분을 업데이트해야 하는지를 결정합니다. 컴포넌트가 null을 반환하면, React에게 아무것도 렌더링할 필요가 없다고 알립니다. 그러나 이는 컴포넌트의 자식들이 업데이트되어야 하는 상태나 프롭을 가지고 있을 때 문제를 일으킬 수 있습니다.\n\n다음 예시를 살펴보세요:\n\n```js\nfunction Parent() {\n  return (\n    \u003cdiv\u003e\n      \u003cChild /\u003e\n    \u003c/div\u003e\n  );\n}\n\nfunction Child() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() =\u003e {\n    console.log('Child rendered');\n  });\n\n  if (count === 0) {\n    return null;\n  }\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={() =\u003e setCount(count - 1)}\u003e-\u003c/button\u003e\n      {count}\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e+\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n이 예시에서, Child 컴포넌트는 count가 0과 같을 때 아무것도 렌더링하지 않아야 한다는 것을 나타내기 위해 return null을 사용합니다. 그러나 이는 Child 컴포넌트가 count의 값이 0이 아닌 값으로 다시 렌더링될 때 문제를 일으킬 수 있습니다. 이 경우에 React는 Child 컴포넌트를 트리에 다시 연결해야 하며, 예상치 못한 동작을 일으킬 수 있습니다.\n\n\n\n# \"return false\"의 장점\n\nreturn null 대신에 return false를 사용하는 것이 더 좋은 방법입니다. 컴포넌트가 false를 반환하면 React는 이를 null을 반환한 것처럼 처리하지만, 또한 React에게 해당 컴포넌트의 자식들을 렌더링하지 말라고 말합니다. 이렇게 하면 컴포넌트와 해당 자식들이 트리에 연결된 채로 유지되어, return null을 사용했을 때 발생할 수 있는 문제점을 회피할 수 있습니다.\n\n다음은 return false를 사용하는 이전 예제의 업데이트된 버전입니다:\n\n```js\nfunction Parent() {\n  return (\n    \u003cdiv\u003e\n      \u003cChild /\u003e\n    \u003c/div\u003e\n  );\n}\n\nfunction Child() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() =\u003e {\n    console.log('Child rendered');\n  });\n\n  if (count === 0) {\n    return false;\n  }\n\n  return (\n    \u003cdiv\u003e\n      \u003cbutton onClick={() =\u003e setCount(count - 1)}\u003e-\u003c/button\u003e\n      {count}\n      \u003cbutton onClick={() =\u003e setCount(count + 1)}\u003e+\u003c/button\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n\n\n이 버전에서 Child 컴포넌트는 count가 0과 동일할 때 null 대신 false를 반환합니다. 이렇게 하면 컴포넌트와 해당 하위 요소가 렌더링할 필요가 없을 때에도 트리에 연결된 상태를 유지합니다. 결과적으로, 컴포넌트가 더 예측 가능하게 동작하고 return null을 사용할 때 발생할 수 있는 문제를 피할 수 있습니다.\n\n# \"return false\"를 사용하는 경우\n\n일반적으로 return null 대신에 return false를 사용하는 것이 더 나은 실천 방법이지만, 적용하기에 적절하지 않을 수 있는 경우가 있음을 기억하는 것이 중요합니다. 구체적으로, 컴포넌트가 렌더링할 필요가 없음을 나타내야 하는 경우에만 return false를 사용해야 합니다. 컴포넌트가 조건에 따라 무언가를 렌더링해야 하는 경우에는 if 문이나 삼항 연산자와 같은 조건부 렌더링 기술을 사용해야 합니다.\n\n다음은 if 문을 사용한 조건부 렌더링 예시입니다:\n\n\n\n```js\nfunction MyComponent({ isLoggedIn }) {\n  if (!isLoggedIn) {\n    return \u003cLoginForm /\u003e;\n  }\n\n  return \u003cDashboard /\u003e;\n}\n```\n\n이 예에서 MyComponent 컴포넌트는 사용자가 로그인했는지에 따라 LoginForm 또는 Dashboard를 조건부로 렌더링하는 if 문을 사용합니다. 이는 return false 대신 조건부 렌더링을 사용하는 더 적절한 방법입니다.\n\n# 결론\n\n결론적으로, React 컴포넌트에서 return null을 사용하면 예기치 않은 동작을 유발하므로 일반적으로 피해야 합니다. 대신 컴포넌트가 렌더링하지 말아야 함을 나타내어야 할 때는 return false를 사용해야 합니다. 이렇게 함으로써 컴포넌트와 그 하위 요소는 트리에 연결된 상태를 유지하고 return null 사용으로 발생할 수 있는 문제를 피할 수 있습니다.\n```\n\n\n\n그러나 return false를 사용하는 경우는 컴포넌트가 아무것도 렌더링하지 말아야 하는 경우에만 사용해야 한다는 점을 명심해야 합니다. 컴포넌트가 조건부로 렌더링해야 하는 경우에는 조건부 렌더링 기술을 사용해야 합니다.","ogImage":{"url":"/assets/img/2024-05-12-StopusingreturnnullinReact_0.png"},"coverImage":"/assets/img/2024-05-12-StopusingreturnnullinReact_0.png","tag":["Tech"],"readingTime":4},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-StopusingreturnnullinReact_0.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React를 사용할 때 컴포넌트에서 반환된 값의 의미를 이해하는 것이 중요합니다. 컴포넌트가 아무것도 렌더링하지 않아야 한다는 것을 나타내기 위해 return null을 사용하는 것이 유혹스러울 수 있지만, 이는 의도하지 않은 결과를 초래할 수 있습니다. 이 게시물에서는 React 컴포넌트에서 return null을 사용하는 것이 나쁜 습관으로 여겨지는 이유와 return false가 더 좋은 대안인 이유에 대해 살펴보겠습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"\\\"return null\\\" 사용에 대한 문제점\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"컴포넌트에서 return null을 사용하는 주된 문제점은 애플리케이션에서 예상치 못한 동작을 일으킬 수 있다는 것입니다. 특히, null은 React에서 렌더링할 유효한 값으로 처리되며, 이로 인해 컴포넌트의 자식 요소가 트리에서 분리될 수 있습니다. 이는 예기치 않은 다시 렌더링이나 상태 불일치 등 다양한 문제를 초래할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것이 발생하는 이유를 이해하기 위해서는 React가 어떻게 작동하는지에 대해 알아야 도움이 됩니다. 컴포넌트가 렌더링될 때, React는 현재 UI 상태를 나타내는 가상 DOM 트리를 생성합니다. 그런 다음 이 트리는 이전 트리와 비교되어 UI의 어느 부분을 업데이트해야 하는지를 결정합니다. 컴포넌트가 null을 반환하면, React에게 아무것도 렌더링할 필요가 없다고 알립니다. 그러나 이는 컴포넌트의 자식들이 업데이트되어야 하는 상태나 프롭을 가지고 있을 때 문제를 일으킬 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 예시를 살펴보세요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"Parent\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Child\"\n            }), \" /\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n  );\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"Child\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [count, setCount] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useEffect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Child rendered'\"\n        }), \");\\n  });\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (count === \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \";\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onClick\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{()\"\n            }), \" =\u003e\"]\n          }), \" setCount(count - 1)}\u003e-\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \"\u003e\"]\n          }), \"\\n      {count}\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onClick\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{()\"\n            }), \" =\u003e\"]\n          }), \" setCount(count + 1)}\u003e+\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예시에서, Child 컴포넌트는 count가 0과 같을 때 아무것도 렌더링하지 않아야 한다는 것을 나타내기 위해 return null을 사용합니다. 그러나 이는 Child 컴포넌트가 count의 값이 0이 아닌 값으로 다시 렌더링될 때 문제를 일으킬 수 있습니다. 이 경우에 React는 Child 컴포넌트를 트리에 다시 연결해야 하며, 예상치 못한 동작을 일으킬 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"\\\"return false\\\"의 장점\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"return null 대신에 return false를 사용하는 것이 더 좋은 방법입니다. 컴포넌트가 false를 반환하면 React는 이를 null을 반환한 것처럼 처리하지만, 또한 React에게 해당 컴포넌트의 자식들을 렌더링하지 말라고 말합니다. 이렇게 하면 컴포넌트와 해당 자식들이 트리에 연결된 채로 유지되어, return null을 사용했을 때 발생할 수 있는 문제점을 회피할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 return false를 사용하는 이전 예제의 업데이트된 버전입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"Parent\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Child\"\n            }), \" /\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n  );\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"Child\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [count, setCount] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useEffect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Child rendered'\"\n        }), \");\\n  });\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (count === \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \";\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onClick\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{()\"\n            }), \" =\u003e\"]\n          }), \" setCount(count - 1)}\u003e-\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \"\u003e\"]\n          }), \"\\n      {count}\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onClick\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{()\"\n            }), \" =\u003e\"]\n          }), \" setCount(count + 1)}\u003e+\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"button\"\n            }), \"\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"div\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n  );\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 버전에서 Child 컴포넌트는 count가 0과 동일할 때 null 대신 false를 반환합니다. 이렇게 하면 컴포넌트와 해당 하위 요소가 렌더링할 필요가 없을 때에도 트리에 연결된 상태를 유지합니다. 결과적으로, 컴포넌트가 더 예측 가능하게 동작하고 return null을 사용할 때 발생할 수 있는 문제를 피할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"\\\"return false\\\"를 사용하는 경우\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"일반적으로 return null 대신에 return false를 사용하는 것이 더 나은 실천 방법이지만, 적용하기에 적절하지 않을 수 있는 경우가 있음을 기억하는 것이 중요합니다. 구체적으로, 컴포넌트가 렌더링할 필요가 없음을 나타내야 하는 경우에만 return false를 사용해야 합니다. 컴포넌트가 조건에 따라 무언가를 렌더링해야 하는 경우에는 if 문이나 삼항 연산자와 같은 조건부 렌더링 기술을 사용해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 if 문을 사용한 조건부 렌더링 예시입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MyComponent\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"{ isLoggedIn }\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!isLoggedIn) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"LoginForm\"\n            }), \" /\u003e\"]\n          })\n        }), \";\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Dashboard\"\n            }), \" /\u003e\"]\n          })\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 예에서 MyComponent 컴포넌트는 사용자가 로그인했는지에 따라 LoginForm 또는 Dashboard를 조건부로 렌더링하는 if 문을 사용합니다. 이는 return false 대신 조건부 렌더링을 사용하는 더 적절한 방법입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"결론적으로, React 컴포넌트에서 return null을 사용하면 예기치 않은 동작을 유발하므로 일반적으로 피해야 합니다. 대신 컴포넌트가 렌더링하지 말아야 함을 나타내어야 할 때는 return false를 사용해야 합니다. 이렇게 함으로써 컴포넌트와 그 하위 요소는 트리에 연결된 상태를 유지하고 return null 사용으로 발생할 수 있는 문제를 피할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        children: \"\\n\\n\\n그러나 return false를 사용하는 경우는 컴포넌트가 아무것도 렌더링하지 말아야 하는 경우에만 사용해야 한다는 점을 명심해야 합니다. 컴포넌트가 조건부로 렌더링해야 하는 경우에는 조건부 렌더링 기술을 사용해야 합니다.\\n\"\n      })\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-StopusingreturnnullinReact"},"buildId":"z1a6VTi5qHH9JJH7jaxL3","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>