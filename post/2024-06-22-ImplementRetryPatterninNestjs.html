<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nestjs에서 Retry 패턴 구현하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-ImplementRetryPatterninNestjs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nestjs에서 Retry 패턴 구현하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Nestjs에서 Retry 패턴 구현하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-ImplementRetryPatterninNestjs" data-gatsby-head="true"/><meta name="twitter:title" content="Nestjs에서 Retry 패턴 구현하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 02:20" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nestjs에서 Retry 패턴 구현하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nestjs에서 Retry 패턴 구현하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">3<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-ImplementRetryPatterninNestjs&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png" alt="2024-06-22-ImplementRetryPatterninNestjs_0.png"></p>
<p>이 기사에서는 다시 시도 및 회로 차단 패턴의 개념을 살펴보고 구현해야 하는 시점과 이유를 파악할 것입니다.</p>
<p>가끔은 추가 서비스를 활용해야 할 때가 있습니다. 우리의 서비스 또는 결제 서비스와 같은 타사 서비스를 호출할 때 상상해 보세요. 그때 결제 서비스가 부하 상태에 있어 우리 요청에 응답하지 못할 수 있습니다. 또는 네트워크 지연이나 인프라 서비스의 문제로 인해 요청이 처리되지 않을 수 있습니다. 그러나 요청을 다시 보내면 대상 서비스가 부하가 해소될 수 있거나 인프라 문제가 해결될 수 있으며 우리 요청이 성공적으로 처리될 수 있습니다.</p>
<p>이 상황에서 우리는 어떻게 해야 할까요?
개발자로서 우리의 책임 중 하나는 시스템 실패의 허용한도를 높이는 것입니다. 개발된 서비스는 다양한 시나리오와 상황에서 호환되며 방탄이어야 하며 원활한 사용자 경험을 제공해야 합니다.</p>
<p>여러 번 시도하면 성공 응답을 받을 수 있는 경우가 있음을 알고 있습니다. 사용자에게는 제3자 서비스에서 오류가 발생하는 첫 번째 시도에 대해 응답하지 않아야 하며, 한 두 번 더 시도하면 성공 응답을 받을 수도 있습니다. 그러나 UnAuth, 액세스 거부 등과 같이 다시 시도할 수 없는 오류도 있음을 알고 있어야 합니다.</p>
<p>이제 다른 개념, Jitter에 대해 알아보겠습니다!</p>
<p>여러 클라이언트가 특정 서비스를 호출하려고 시도하는 상황을 상상해보세요. 해당 서비스는 부하를 받아 일부 클라이언트에게 응답하지 못할 것이며, 실패 응답을 받은 클라이언트는 동시에 해당 서비스를 호출하려고 하면 다시 부하를 받아 서비스 거부 상태가 될 것입니다. 이때, 다시 시도 사이에 지연을 설정하는 것이 좋습니다. 다음 공식을 통해 지연을 설정하세요:</p>
<p>고정된 밀리초 + 임의의 밀리초</p>
<p>무작위 시간에 서비스를 호출하여 서비스가 스스로 회복될 수 있도록 도와줍니다.</p>
<p>아래는 Axios와 호환되는 jitter를 사용한 재시도 유틸리티 서비스 구현 예시입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AxiosResponse</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;

<span class="hljs-keyword">export</span> type <span class="hljs-title class_">AxiosMethod</span> = <span class="hljs-function">() =></span> <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">AxiosResponse</span>>;

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Retry</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">retry</span>(
    <span class="hljs-attr">axiosMethod</span>: <span class="hljs-title class_">AxiosMethod</span>,
    <span class="hljs-attr">retry</span>: number,
    <span class="hljs-attr">delayInMs</span>: number,
    <span class="hljs-attr">jitter</span>: boolean,
  ): <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">AxiosResponse</span>> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-title class_">AxiosResponse</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C;= retry; i++) {
        <span class="hljs-keyword">try</span> {
          res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">axiosMethod</span>();
          <span class="hljs-keyword">break</span>;
        } <span class="hljs-keyword">catch</span> (err) {
          <span class="hljs-keyword">if</span> (i &#x3C; retry) {
            <span class="hljs-keyword">const</span> j = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getJitter</span>(jitter);
            <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">executeWithDelay</span>(delayInMs + j);
            <span class="hljs-keyword">continue</span>
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> err;
          }
        }
      }
      <span class="hljs-keyword">return</span> res;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">throw</span> error;
    }
  }

  private <span class="hljs-title function_">executeWithDelay</span>(<span class="hljs-params">delay: number</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> <span class="hljs-built_in">setTimeout</span>(resolve, delay));
  }

  private <span class="hljs-title function_">getJitter</span>(<span class="hljs-params">jitter: boolean</span>) {
    <span class="hljs-keyword">return</span> jitter ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (<span class="hljs-number">200</span> - <span class="hljs-number">50</span> + <span class="hljs-number">1</span>)) + <span class="hljs-number">50</span> : <span class="hljs-number">0</span>;
  }
}
</code></pre>
<p>이 설명이 프로젝트 개발에 높은 실패 허용성을 가로지어드릴 수 있기를 바랍니다. 궁금한 점이 있으시면 언제든지 질문해주세요.👌</p>
<h1>관련 자료</h1>
<p><a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/retry" rel="nofollow" target="_blank">https://learn.microsoft.com/en-us/azure/architecture/patterns/retry</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nestjs에서 Retry 패턴 구현하는 방법","description":"","date":"2024-06-22 02:20","slug":"2024-06-22-ImplementRetryPatterninNestjs","content":"\n\n![2024-06-22-ImplementRetryPatterninNestjs_0.png](/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png)\n\n이 기사에서는 다시 시도 및 회로 차단 패턴의 개념을 살펴보고 구현해야 하는 시점과 이유를 파악할 것입니다.\n\n가끔은 추가 서비스를 활용해야 할 때가 있습니다. 우리의 서비스 또는 결제 서비스와 같은 타사 서비스를 호출할 때 상상해 보세요. 그때 결제 서비스가 부하 상태에 있어 우리 요청에 응답하지 못할 수 있습니다. 또는 네트워크 지연이나 인프라 서비스의 문제로 인해 요청이 처리되지 않을 수 있습니다. 그러나 요청을 다시 보내면 대상 서비스가 부하가 해소될 수 있거나 인프라 문제가 해결될 수 있으며 우리 요청이 성공적으로 처리될 수 있습니다.\n\n이 상황에서 우리는 어떻게 해야 할까요?\n개발자로서 우리의 책임 중 하나는 시스템 실패의 허용한도를 높이는 것입니다. 개발된 서비스는 다양한 시나리오와 상황에서 호환되며 방탄이어야 하며 원활한 사용자 경험을 제공해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 번 시도하면 성공 응답을 받을 수 있는 경우가 있음을 알고 있습니다. 사용자에게는 제3자 서비스에서 오류가 발생하는 첫 번째 시도에 대해 응답하지 않아야 하며, 한 두 번 더 시도하면 성공 응답을 받을 수도 있습니다. 그러나 UnAuth, 액세스 거부 등과 같이 다시 시도할 수 없는 오류도 있음을 알고 있어야 합니다.\n\n이제 다른 개념, Jitter에 대해 알아보겠습니다!\n\n여러 클라이언트가 특정 서비스를 호출하려고 시도하는 상황을 상상해보세요. 해당 서비스는 부하를 받아 일부 클라이언트에게 응답하지 못할 것이며, 실패 응답을 받은 클라이언트는 동시에 해당 서비스를 호출하려고 하면 다시 부하를 받아 서비스 거부 상태가 될 것입니다. 이때, 다시 시도 사이에 지연을 설정하는 것이 좋습니다. 다음 공식을 통해 지연을 설정하세요:\n\n고정된 밀리초 + 임의의 밀리초\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n무작위 시간에 서비스를 호출하여 서비스가 스스로 회복될 수 있도록 도와줍니다.\n\n아래는 Axios와 호환되는 jitter를 사용한 재시도 유틸리티 서비스 구현 예시입니다:\n\n```js\nimport { Injectable } from '@nestjs/common';\nimport { AxiosResponse } from 'axios';\n\nexport type AxiosMethod = () =\u003e Promise\u003cAxiosResponse\u003e;\n\n@Injectable()\nexport class Retry {\n  constructor() {}\n\n  async retry(\n    axiosMethod: AxiosMethod,\n    retry: number,\n    delayInMs: number,\n    jitter: boolean,\n  ): Promise\u003cAxiosResponse\u003e {\n    try {\n      let res: AxiosResponse | null = null;\n\n      for (let i = 0; i \u003c= retry; i++) {\n        try {\n          res = await axiosMethod();\n          break;\n        } catch (err) {\n          if (i \u003c retry) {\n            const j = this.getJitter(jitter);\n            await this.executeWithDelay(delayInMs + j);\n            continue\n          } else {\n            throw err;\n          }\n        }\n      }\n      return res;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private executeWithDelay(delay: number) {\n    return new Promise((resolve) =\u003e setTimeout(resolve, delay));\n  }\n\n  private getJitter(jitter: boolean) {\n    return jitter ? Math.floor(Math.random() * (200 - 50 + 1)) + 50 : 0;\n  }\n}\n```\n\n이 설명이 프로젝트 개발에 높은 실패 허용성을 가로지어드릴 수 있기를 바랍니다. 궁금한 점이 있으시면 언제든지 질문해주세요.👌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 관련 자료\n\nhttps://learn.microsoft.com/en-us/azure/architecture/patterns/retry","ogImage":{"url":"/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png"},"coverImage":"/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png","tag":["Tech"],"readingTime":3},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-ImplementRetryPatterninNestjs_0.png\" alt=\"2024-06-22-ImplementRetryPatterninNestjs_0.png\"\u003e\u003c/p\u003e\n\u003cp\u003e이 기사에서는 다시 시도 및 회로 차단 패턴의 개념을 살펴보고 구현해야 하는 시점과 이유를 파악할 것입니다.\u003c/p\u003e\n\u003cp\u003e가끔은 추가 서비스를 활용해야 할 때가 있습니다. 우리의 서비스 또는 결제 서비스와 같은 타사 서비스를 호출할 때 상상해 보세요. 그때 결제 서비스가 부하 상태에 있어 우리 요청에 응답하지 못할 수 있습니다. 또는 네트워크 지연이나 인프라 서비스의 문제로 인해 요청이 처리되지 않을 수 있습니다. 그러나 요청을 다시 보내면 대상 서비스가 부하가 해소될 수 있거나 인프라 문제가 해결될 수 있으며 우리 요청이 성공적으로 처리될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 상황에서 우리는 어떻게 해야 할까요?\n개발자로서 우리의 책임 중 하나는 시스템 실패의 허용한도를 높이는 것입니다. 개발된 서비스는 다양한 시나리오와 상황에서 호환되며 방탄이어야 하며 원활한 사용자 경험을 제공해야 합니다.\u003c/p\u003e\n\u003cp\u003e여러 번 시도하면 성공 응답을 받을 수 있는 경우가 있음을 알고 있습니다. 사용자에게는 제3자 서비스에서 오류가 발생하는 첫 번째 시도에 대해 응답하지 않아야 하며, 한 두 번 더 시도하면 성공 응답을 받을 수도 있습니다. 그러나 UnAuth, 액세스 거부 등과 같이 다시 시도할 수 없는 오류도 있음을 알고 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e이제 다른 개념, Jitter에 대해 알아보겠습니다!\u003c/p\u003e\n\u003cp\u003e여러 클라이언트가 특정 서비스를 호출하려고 시도하는 상황을 상상해보세요. 해당 서비스는 부하를 받아 일부 클라이언트에게 응답하지 못할 것이며, 실패 응답을 받은 클라이언트는 동시에 해당 서비스를 호출하려고 하면 다시 부하를 받아 서비스 거부 상태가 될 것입니다. 이때, 다시 시도 사이에 지연을 설정하는 것이 좋습니다. 다음 공식을 통해 지연을 설정하세요:\u003c/p\u003e\n\u003cp\u003e고정된 밀리초 + 임의의 밀리초\u003c/p\u003e\n\u003cp\u003e무작위 시간에 서비스를 호출하여 서비스가 스스로 회복될 수 있도록 도와줍니다.\u003c/p\u003e\n\u003cp\u003e아래는 Axios와 호환되는 jitter를 사용한 재시도 유틸리티 서비스 구현 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eAxiosResponse\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'axios'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e type \u003cspan class=\"hljs-title class_\"\u003eAxiosMethod\u003c/span\u003e = \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eAxiosResponse\u003c/span\u003e\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRetry\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {}\n\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eretry\u003c/span\u003e(\n    \u003cspan class=\"hljs-attr\"\u003eaxiosMethod\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAxiosMethod\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eretry\u003c/span\u003e: number,\n    \u003cspan class=\"hljs-attr\"\u003edelayInMs\u003c/span\u003e: number,\n    \u003cspan class=\"hljs-attr\"\u003ejitter\u003c/span\u003e: boolean,\n  ): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eAxiosResponse\u003c/span\u003e\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eres\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAxiosResponse\u003c/span\u003e | \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n      \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C;= retry; i++) {\n        \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n          res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eaxiosMethod\u003c/span\u003e();\n          \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n        } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (i \u0026#x3C; retry) {\n            \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e j = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetJitter\u003c/span\u003e(jitter);\n            \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexecuteWithDelay\u003c/span\u003e(delayInMs + j);\n            \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e\n          } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e err;\n          }\n        }\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res;\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n      \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e error;\n    }\n  }\n\n  private \u003cspan class=\"hljs-title function_\"\u003eexecuteWithDelay\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edelay: number\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(resolve, delay));\n  }\n\n  private \u003cspan class=\"hljs-title function_\"\u003egetJitter\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ejitter: boolean\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e jitter ? \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efloor\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e() * (\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)) + \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e : \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 설명이 프로젝트 개발에 높은 실패 허용성을 가로지어드릴 수 있기를 바랍니다. 궁금한 점이 있으시면 언제든지 질문해주세요.👌\u003c/p\u003e\n\u003ch1\u003e관련 자료\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/azure/architecture/patterns/retry\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://learn.microsoft.com/en-us/azure/architecture/patterns/retry\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-ImplementRetryPatterninNestjs"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>