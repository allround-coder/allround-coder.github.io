<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>브라우저 아키텍처의 과거와 현재 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-ThePastandPresentofBrowserArchitecture" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="브라우저 아키텍처의 과거와 현재 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="브라우저 아키텍처의 과거와 현재 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-ThePastandPresentofBrowserArchitecture" data-gatsby-head="true"/><meta name="twitter:title" content="브라우저 아키텍처의 과거와 현재 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 23:47" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">브라우저 아키텍처의 과거와 현재</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="브라우저 아키텍처의 과거와 현재" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-ThePastandPresentofBrowserArchitecture&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><img src="/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png"/>
<p>브라우저 아키텍처는 단일 프로세스 브라우저에서 멀티 프로세스 브라우저로의 전환을 거쳤습니다. 안정성, 부드러움, 보안을 강조하며, 프로세스는 렌더링, GPU, 네트워크 및 플러그인으로 분해되어 아키텍처의 청결성이 향상되었습니다. 브라우저 아키텍처를 검토하려면 페이지를 열고, 페이지 렌더링 프로세스, 브라우저 플러그인 메커니즘을 더 잘 이해해야 합니다. 특히 Manifest V1에서 Manifest V3로의 전환을 중심으로 Chrome 확장 프로그램 버전 타임라인을 정리함으로써 브라우저의 진화 과정을 비교적 포괄적으로 이해할 수 있습니다.</p>
<h1>1. 브라우저 아키텍처의 진화</h1>
<p>2007년 이전에 전형적인 브라우저 아키텍쳐는 이러했습니다:</p>
<p><img src="/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_1.png" alt="브라우저 아키텍처의 과거와 현재"/></p>
<p>단일 프로세스 브라우저 아키텍처는 전체 웹 브라우저를 단일 운영 체제 프로세스에서 실행하여 네트워크 처리, 플러그인, JavaScript 런타임, 렌더링 엔진, 페이지 관리 및 사용자 인터페이스 요소 등의 작업을 하나의 실행 공간으로 통합합니다. 자원 관리를 단순화하는 반면, 이 아키텍처 디자인은 다음과 같은 주요 문제점이 있습니다:</p>
<ul>
<li>불안정함 — 플러그인 및 렌더링 엔진은 웹 비디오 및 게임과 같은 기능을 처리하는 동일한 프로세스에서 실행됩니다. 플러그인이나 렌더링 엔진의 충돌로 인해 전체 브라우저가 다운될 수 있으며, 특히 복잡한 JavaScript 코드를 처리할 때 이러한 불안정성이 두드러집니다.</li>
<li>부드러움 부족 — 모든 모듈(페이지 렌더링, JavaScript 실행, 플러그인 포함)이 하나의 스레드를 공유합니다. 스크립트가 매우 시간이 많이 걸리면 전체 스레드를 독점하여 다른 페이지가 응답하지 않게 만들고 전체 브라우저에서 지연이 발생할 수 있습니다.</li>
<li>보안성 부족 — 페이지에서 실행되는 플러그인은 운영 체제 자원에 액세스할 수 있습니다. 악성 플러그인은 이런 액세스를 악용하여 보안을 침해하거나 사용자 자격 증명과 같은 민감한 정보를 탈취할 수 있습니다.</li>
</ul>
<p>단일 프로세스 브라우저의 장점은 브라우저 구성 요소가 하나의 프로세스 내에서 작동하여 자원 관리와 조정을 간단하게 만든다는 것입니다. 단일 프로세스 브라우저는 보통 낮은 메모리 사용률을 나타내어 자원 효율성 향상에 도움을 줍니다. 작업은 통합된 프로세스 내에서 순차적으로 실행됩니다.</p>
<p>2008년에 출시된 Chrome 프로세스 아키텍처는 다음 다이어그램을 통해 볼 수 있듯이 멀티 프로세스 브라우저의 한 예입니다:</p>
<p><img src="/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_2.png" alt="다이어그램"/></p>
<p>이른 시기에 사용된 브라우저 아키텍처는 기능을 브라우저, 플러그인, 렌더링의 세 가지 주요 프로세스로 나눴습니다. 각 페이지와 해당 플러그인은 전용 렌더링 및 플러그인 프로세스에서 독립적으로 실행되며, IPC를 통해 통신합니다.</p>
<p>프로세스간 통신(IPC)은 프로세스가 컴퓨터에서 통신하고 작업을 동기화하는 메커니즘입니다. 이를 통해 다른 프로그램 간에 효율적인 데이터 교환과 조정이 가능해집니다. 주요 IPC 메커니즘에는 공유 메모리가 포함되어 있어 프로세스 간의 세마포어를 사용하여 공유된 공용 메모리 영역에 대한 액세스를 동기화합니다. Named 및 unnamed 파이프는 단방향 통신을 제공하며, Linux에서의 IPC는 일반적으로 세마포어를 사용하여 파일이나 공유 메모리 저장소를 공유합니다. 메시지 큐는 비동기 통신을 지원하여 송신자 및 수신자 프로세스를 분리하는 데 도움을 줍니다. 또한, 프로세스는 이벤트나 요청을 통지하기 위해 시그널을 통해 통신할 수 있습니다. 소켓은 네트워크 프로토콜을 사용하여 서로 다른 기계 간에 IPC를 확장합니다.</p>
<p>멀티 프로세스 브라우저는 안정성을 향상시킵니다. 격리된 프로세스 덕분에 충돌이 전체 브라우저에 영향을 미치지 않습니다. 페이지나 플러그인의 충돌은 해당 프로세스에만 영향을 미치며, 다른 페이지와 브라우저 전체의 안정성을 보장합니다. JavaScript를 별도의 렌더링 프로세스에서 실행하는 것도 영향을 격리시킵니다. 만약 스크립트가 렌더링 프로세스를 차단한다면, 현재 페이지에만 영향을 미치고 다른 페이지에는 영향을 미치지 않습니다. 각 페이지가 별도의 렌더링 프로세스에서 스크립트를 실행하기 때문에 브라우저 전체가 영향을 받지 않습니다. 더불어 Chrome은 플러그인과 렌더링 프로세스를 샌드박스 환경에 배치하여 데이터에 대한 읽기/쓰기 액세스를 제한합니다. 악성 소프트웨어가 이러한 프로세스 내에서 실행되더라도 시스템 권한을 획들할 수 없습니다. 이것이 구획화된 아키텍처 패턴의 한 예입니다.</p>
<p>샌드박스는 전체 시스템의 작동에 영향을 미치지 않고 프로그램을 실행하거나 파일을 열 수 있는 테스트 환경입니다. 사이버 보안 분야에서 산드박스는 잠재적으로 해로운 코드 실행을 분석하여 위협을 탐지하고 완화하는 용도로 사용됩니다.</p>
<p>최신 버전의 Chrome 브라우저에는 아래와 같은 주요 구성 요소가 있습니다:</p>
<p><img src="/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_3.png" alt="Chrome Browser Components"/></p>
<p>브라우저 프로세스는 디스플레이 인터페이스, 사용자 상호작용 및 서브프로세스 조정을 관리하며, 저장 기능을 제공합니다. 이는 다른 프로세스를 조정하는 &quot;스케줄러&quot;로 작용하여, 예를 들어 URL을 입력할 때 네트워크 프로세스를 호출합니다. 렌더링 프로세스는 HTML, CSS 및 JavaScript를 대화형 웹 페이지로 변환하고 V8 엔진을 실행합니다. 보안상의 이유로 Chrome은 각 탭에 대해 별도의 렌더링 프로세스를 샌드박스 모드로 생성합니다.</p>
<p>GPU 프로세스는 초기에 3D CSS 효과를 위해 설계되었지만 나중에 웹 페이지 및 Chrome UI 인터페이스를 그리는 데 확장되었습니다. 공통 브라우저 요구 사항을 충족하기 위해 Chrome의 다중 프로세스 아키텍처에 소개되었습니다. 네트워크 프로세스는 페이지 네트워크 리소스를 독립적으로 로드하며, 원래 브라우저 프로세스 내의 모듈이었지만 지금은 별도의 프로세스로 실행됩니다. 플러그인 프로세스는 플러그인을 관리하여 브라우저 및 페이지에 플러그인의 내재적 불안정성으로 인한 충돌을 방지합니다.</p>
<p>현대적인 브라우저 아키텍처는 아래 다이어그램에서 보실 수 있습니다:</p>
<p><img src="/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_4.png" alt="Diagram"/></p>
<h1>2. 브라우저 페이지 열리는 과정</h1>
<ul>
<li>탭 추가는 기본 프로세스 생성을 시작합니다: 시스템 브라우저, 렌더링, GPU 및 네트워크 프로세스.</li>
<li>사용자 입력은 브라우저 프로세스를 활성화하여 프로토콜을 확인하고 완전한 URL을 구성합니다.</li>
<li>브라우저 프로세스는 URL 요청을 네트워크 프로세스로 보냅니다. 여기서 인터프로세스 통신이 이루어집니다.</li>
<li>네트워크 프로세스는 요청된 리소스를 로컬 캐시에서 확인합니다. 캐시에서 찾을 경우 브라우저 프로세스로 반환합니다.</li>
<li>캐시에 없는 경우, 네트워크 프로세스는 웹 서버로 HTTP 요청을 보냅니다.</li>
<li>네트워크 프로세스는 응답을 구문 분석하고 상태 코드를 확인합니다. 비-200 상태 코드는 특정 처리 논리를 유도합니다.</li>
<li>200 응답의 경우, 브라우저 프로세스는 Content-Type을 확인합니다. 바이트 스트림은 다운로드 관리자를 활성화하고 HTML은 렌더링 준비를 신호로 합니다.</li>
<li>브라우저 프로세스는 현재 URL이 기존 렌더링 프로세스의 루트 도메인과 일치하는지 확인합니다. 다를 경우, 새로운 렌더링 프로세스를 시작합니다.</li>
<li>브라우저는 네트워크 프로세스와 데이터 전송 파이프라인을 설정하기 위해 렌더링 프로세스에 &quot;문서 제출&quot; 메시지를 보냅니다.</li>
<li>데이터 수신 후, 렌더링 프로세스는 브라우저로 확인을 보냅니다. 브라우저는 보안 표시기, 주소 표시줄 URL, 브라우징 기록 및 웹페이지 컨텐츠를 업데이트합니다.</li>
</ul>
<h1>3. 렌더링 프로세스</h1>
<p>현대 브라우저는 성능을 우선시하는 방법으로 레이지 로딩 및 캐싱 같은 전략을 사용합니다. 브라우저는 렌더링 프로세스를 통해 웹 콘텐츠를 표시합니다. 핵심 단계는 HTML 구문 분석, CSS 스타일링, 레이아웃 생성 및 그리기가 되며, 구체적인 단계는 다음과 같습니다:</p>
<ul>
<li>사용자 입력 — 브라우저 주소 표시줄에 URL을 입력하세요.</li>
<li>URL 구문 분석 — URL을 구문 분석하여 프로토콜, 호스트, 포트 및 경로를 식별합니다.</li>
<li>DNS 조회 — 호스트 이름을 IP 주소로 변환하기 위해 DNS 조회를 수행합니다.</li>
<li>소켓 연결 — 사용자와 서버 IP 간의 연결 설정.</li>
<li>HTTP 요청 — 프로토콜을 지정하는 HTTP 요청을 서버로 보냅니다.</li>
<li>서버 처리 — 서버는 요청을 평가하고 처리 플러그인(예: PHP, Java)을 결정합니다.</li>
<li>플러그인을 통한 처리 — HTTP 응답의 일부로 데이터베이스 또는 다른 리소스에 액세스합니다.</li>
<li>브라우저 응답 — HTTP 응답을 브라우저로 다시 보냅니다.</li>
<li>응답 분석 — 브라우저에서 응답의 HTML 데이터를 분석합니다.</li>
<li>DOM 트리 생성 — 구문 분석된 HTML에서 문서 객체 모델(DOM) 트리를 구성합니다.</li>
<li>스타일시트 구문 분석 — 프레젠테이션 데이터를 DOM 노드에 연결하는 스타일시트를 구문 분석합니다.</li>
<li>JavaScript 실행 — DOM 요소를 수정하기 위해 JavaScript 코드를 실행합니다.</li>
<li>페이지 렌더링 — DOM 및 스타일 데이터를 사용하여 웹 페이지를 표시합니다.</li>
</ul>
<h2>3.1 HTML 구문 분석</h2>
<p>브라우저가 HTML을 문자 단위로 읽어 요소, 속성 및 텍스트를 식별한 후, 웹 페이지의 구조를 표현하는 DOM 트리를 구성하여 HTML 코드가 올바르게 표시되도록 합니다.</p>
<h2>3.2 CSS Object Model</h2>
<p>CSS Object Model는 HTML 요소에 적용된 스타일을 표현하며, DOM 트리의 구조적 계층과 유사하게 특정성과 스타일의 캐스캐이딩 성질을 고려하여 스타일에 대한 접근, 조작 및 계산을 허용합니다.</p>
<h2>3.3 레이아웃 관리자</h2>
<p>레이아웃 관리자는 DOM과 CSS object model을 결합하여 렌더링 트리를 형성하고, 내용, 패딩 등을 기반으로 상자의 크기를 결정하며, 특정 위치를 구축하는 데 다양한 메소드를 사용합니다. 동시에 겹치는 요소를 처리하기 위해 쌓임 맥락과 Z-인덱스를 사용하고, 배치 변경을 최적화하기 위해 일괄 처리 기술을 사용합니다. 마지막으로 화면에 요소가 그려지고 사용자 상호작용 중에 지속적으로 업데이트됩니다.</p>
<h1>4 플러그인 메커니즘</h1>
<h2>4.1 플러그인 개발 역사</h2>
<p>플러그인 메커니즘의 개발 과정은 다음과 같습니다:</p>
<ul>
<li>2012년 8월 — 매니페스트 V1: Chrome 플러그인은 처음에 매니페스트 V1을 기반으로 했으며, 기본 기능 및 권한을 정의했습니다.</li>
<li>2013년 4월 — Chrome26 안정 버전: 매니페스트 V1 플러그인 지원이 포함되었습니다.</li>
<li>2014년 5월 — Chrome35 안정 버전: 브라우저의 점진적 업데이트가 계속해서 ManifestV1 플러그인을 지원했습니다.</li>
<li>2014년 9월 — Chrome 37 안정 버전: Manifest V1 플러그인을 위한 추가 개선 및 버그 수정이 이루어졌습니다.</li>
<li>2015년 5월 — Chrome43 안정 버전: Manifest V1 계속 지원됩니다.</li>
<li>2015년 12월 — Manifest V2 등장: ManifestV2가 도입되어 더 나은 보안 및 추가 기능을 제공했습니다.</li>
<li>2016년 6월 — Chrome51 안정 버전: Manifest V2가 플러그인 개발의 표준이 되었습니다.</li>
<li>2016년 9월 — Chrome53 안정 버전: Manifest V2의 지속적인 개선 및 최적화가 이루어졌습니다.</li>
<li>2019년 1월 — Manifest V3 출시: 보안, 성능 및 개발 유연성에 초점을 맞춥니다.</li>
<li>2020년 3월 — Chrome80 안정 버전: Manifest V2는 플러그인의 표준이지만, Manifest V3는 테스트용으로 제공되었지만 아직 필수는 아닙니다.</li>
<li>2021년 3월 — Chrome89 안정 버전: Manifest V2가 여전히 기본이지만 Manifest V3로의 관심이 증가하고 있습니다.</li>
<li>2021년 10월 — Chrome94 안정 버전: Manifest V3가 일부 기능을 강화하기 시작하며, 이전 버전에서의 이전 가이드 및 도구가 개발자에게 제공됩니다.</li>
<li>2022년 3월 — Chrome98 안정 버전: Manifest V3가 새로운 플러그인 버전의 기본이 됩니다. 그러면서 Manifest V2도 계속 지원됩니다.</li>
<li>2022년 8월 — Chrome104 안정 버전: 모든 플러그인이 공식적으로 Manifest V3로 전환되어, Manifest V2의 추가 지원이 중단되었습니다.</li>
<li>2023년 3월 — Chrome108 안정 버전: 모든 플러그인이 Manifest V3를 온전히 지원하며, 매끄러운 전환을 보장합니다.</li>
<li>2023년 7월 — Manifest V3 미리보기: 개발자들이 다가오는 변경 사항을 탐색하고 유용한 피드백을 제공할 수 있도록 합니다.</li>
<li>2023년 10월 — Chrome Z 안정 버전에서 ManifestV3 지원을 더 개선하며, 미리보기 단계에서 보고된 모든 문제를 해결합니다.</li>
<li>2024년 1월 — Manifest V3 사전 안정 버전 배포: Manifest V3가 안정 상태에 도달하여, 개발자들이 확장 프로그램을 V3로 이전하고 모든 문서 및 이전 가이드가 제공됩니다.</li>
<li>2024년 3월 — Chrome116 안정 버전: Manifest V3를 완전히 지원하며, 개발자들은 플러그인을 최신 표준과 호환되도록 업데이트합니다.</li>
</ul>
<p>총적으로, Chrome 익스텐션(또는 애드온)은 3가지 주요 버전인 Manifest V1, Manifest V2 및 Manifest V3의 개발 과정을 거쳤습니다.</p>
<p>Manifest V1 (MV1)은 Chrome 확장 프로그램 매니페스트의 초기 버전이었으며 오래되었습니다. Manifest V2 (MV2)는 현재 Chrome 확장 프로그램에서 널리 사용되는 주요 버전으로, 확장 프로그램을 더 많은 브라우저 기능과 기능으로 구축할 수 있는 견고한 프레임워크를 제공합니다. Manifest V3은 점차 MV2를 대체하는 최신 버전으로, 보안 및 성능 문제에 대응하기 위해 보안 조치를 강화하고 확장 프로그램 개발 시 더 나은 성능을 촉진하는 것을 목표로 합니다. Chrome 127 (2024년 6월)부터 Google은 안정화되지 않은 Chrome 버전에서 Manifest V2 확장 프로그램을 비활성화하기 시작할 예정이며, 개발자들이 MV3로 전환하도록 권장합니다.</p>
<h2>4.2 Manifest의 기능 및 버전 이전</h2>
<p>Manifest V2의 기능:</p>
<ul>
<li>Content-Security-Policy (CSP)를 설정하여 script-src &#x27;self&#x27;; object-src &#x27;self&#x27;;를 사용하여 기본 콘텐츠 보안 정책을 설정합니다.</li>
<li>플러그인 패키지 리소스는 외부로 더 이상 사용할 수 없으며, 허용 목록은 매니페스트의 web_access_resources 속성을 통해 나열됩니다.</li>
<li>브라우저 작업 API 및 페이지 작업 API에 변경 사항이 있으며, chrome.extension이 플러그인 자체를 가리키는 chrome.self를 대체하고, chrome.tension.getTabContentses는 tension.getView로 대체되고, Port.tab은 runtime.Port로 대체됩니다.</li>
</ul>
<p>Manifest V3의 기능:</p>
<ul>
<li>Manifest V3은 백그라운드 페이지를 대체하는 서비스 워커를 도입했습니다.</li>
<li>네트워크 요청 수정은 더 이상 사용되지 않는 webRequest API 대신 새로운 선언적 넷 요청 API를 사용합니다.</li>
<li>원격 코드 실행이 허용되지 않으며, 확장 프로그램 패키지 내의 JS만 실행할 수 있습니다.</li>
<li>Promises가 많은 메소드에 추가되었고, 콜백은 여전히 지원됩니다.</li>
<li>Browser Action API 및 Page Action API가 하나의 액션 API로 통합되었습니다.</li>
<li>웹 접근 가능한 리소스는 지정된 사이트 및 확장 프로그램으로 제한됩니다.</li>
<li>콘텐츠 보안 정책 (CSP)은 다른 실행 컨텍스트에 대해 별도의 CSP를 지정할 수 있습니다. executeScript는 스크립트 파일과 함수만 실행하고 임의의 문자열은 실행할 수 없습니다.</li>
</ul>
<p>Manifest V3은 Chrome이 개인 정보 보호, 보안 및 전반적인 확장 프로그램 성능 향상에 대한 약속으로부터 비롯된 V1과 V2로부터의 중요한 전환을 나타냅니다. 이전 버전과는 달리, Manifest V3은 자원 효율성을 우선시하여 Chrome의 과거 높은 자원 사용량에 대한 우려 사항을 해결합니다. 핵심 목표는 확장 프로그램을 통해 시스템 자원 소비를 제한하여 브라우저 성능을 최적화하는 것입니다. 추가 제약 사항을 부과하면서도, Manifest V3은 중요한 이점을 소개합니다. 서비스 워커 기능을 통해 확장 프로그램이 계속해서 백그라운드에 상주하지 않고도 작동할 수 있어, 확장 프로그램 자원을 재활용하고 브라우저 전반적인 오버헤드를 효과적으로 줄일 수 있습니다. 규칙 계산에 대한 제약 사항은 개별 확장 프로그램이 자원을 과도하게 소비하지 않도록 제어 메커니즘으로 작용합니다. 이러한 변경 사항들은 Chrome에서 더 부드러운 브라우징 경험을 제공하며, 향상된 브라우저 효율성에 대한 사용자 기대를 충족합니다.</p>
<p>V2에서 V3로 이전시, 페이지 배경을 구성하기 위한 background.html이 없다는 이유로 백그라운드.html에서 AJAX 요청을 구성하는 데 윈도우 개체의 XMLHttpRequest를 사용할 수 없습니다. 대신, 데이터를 추출하는 방법을 사용하여 데이터를 검색해야 합니다.</p>
<p>또한, 서비스 워커의 짧은 수명과 비활성 기간 동안의 종료로 인해 가끔 발생하는 시작, 실행 및 종료로 플러그인 수명주기 동안 불안정성이 발생합니다. MV2에서는 전역 변수가 데이터 저장에 직접 사용되었으므로 이러한 상황 하에서 안정성과 기능성을 향상시키기 위해 backound.js 로직을 수정해야 합니다. 또한 webRequest API에서 statativeNetRequest API로 전환하면 상당한 코드 리팩터링이 필요합니다.</p>
<h2>4.3 Chrome 확장 프로그램의 주요 구성 요소</h2>
<p>4.3.1 매니페스트 파일</p>
<p>매니페스트.json 파일은 루트 디렉토리에 위치한 Chrome 확장 프로그램에 매우 중요합니다. 이 파일을 통해 Manif_version, 이름, 버전과 같은 기본 매개변수를 포함하여 모든 플러그인 설정을 구성합니다.</p>
<p>Manifest V2의 예시는 다음과 같습니다:</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">&quot;manifest_version&quot;</span>: <span class="hljs-number">2</span>,
  <span class="hljs-comment">// 플러그인 이름</span>
  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>,
  <span class="hljs-comment">// 플러그인 버전</span>
  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,
  <span class="hljs-comment">// 플러그인 설명</span>
  <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>,
  <span class="hljs-string">&quot;icons&quot;</span>: {
    <span class="hljs-string">&quot;16&quot;</span>: <span class="hljs-string">&quot;img/icon16.png&quot;</span>,
    <span class="hljs-string">&quot;48&quot;</span>: <span class="hljs-string">&quot;img/icon48.png&quot;</span>,
    <span class="hljs-string">&quot;128&quot;</span>: <span class="hljs-string">&quot;img/icon128.png&quot;</span>
  },
  <span class="hljs-comment">// 브라우저의 백그라운드 JS 또는 백그라운드 페이지</span>
  <span class="hljs-string">&quot;background&quot;</span>: {
    <span class="hljs-string">&quot;scripts&quot;</span>: [<span class="hljs-string">&quot;js/background.js&quot;</span>]
  },
  <span class="hljs-comment">// 브라우저 아이콘 설정: browser_action, page_action, app</span>
  <span class="hljs-string">&quot;browser_action&quot;</span>: {
    <span class="hljs-string">&quot;default_icon&quot;</span>: <span class="hljs-string">&quot;img/icon.png&quot;</span>,
    <span class="hljs-string">&quot;default_title&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>,
    <span class="hljs-string">&quot;default_popup&quot;</span>: <span class="hljs-string">&quot;popup.html&quot;</span>
  },
  <span class="hljs-comment">// 특정 페이지가 열릴 때에만 표시되는 아이콘</span>
  <span class="hljs-string">&quot;page_action&quot;</span>: {
    <span class="hljs-string">&quot;default_icon&quot;</span>: <span class="hljs-string">&quot;img/icon.png&quot;</span>,
    <span class="hljs-string">&quot;default_title&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>,
    <span class="hljs-string">&quot;default_popup&quot;</span>: <span class="hljs-string">&quot;popup.html&quot;</span>
  },
  <span class="hljs-comment">// 페이지에 직접 주입되는 JS</span>
  <span class="hljs-string">&quot;content_scripts&quot;</span>: [{
    <span class="hljs-string">&quot;matches&quot;</span>: [<span class="hljs-string">&quot;&lt;all_urls&gt;&quot;</span>],
    <span class="hljs-string">&quot;js&quot;</span>: [<span class="hljs-string">&quot;js/content-script.js&quot;</span>],
    <span class="hljs-string">&quot;css&quot;</span>: [<span class="hljs-string">&quot;css/custom.css&quot;</span>],
    <span class="hljs-comment">// 코드 주입 시기, 기본값은 document_idle</span>
    <span class="hljs-string">&quot;run_at&quot;</span>: <span class="hljs-string">&quot;document_start&quot;</span>
  }],
  <span class="hljs-comment">// 요청되는 권한</span>
  <span class="hljs-string">&quot;permissions&quot;</span>: [
    <span class="hljs-string">&quot;contextMenus&quot;</span>, <span class="hljs-comment">// 우클릭 메뉴</span>
    <span class="hljs-string">&quot;tabs&quot;</span>, <span class="hljs-comment">// 탭</span>
    <span class="hljs-string">&quot;notifications&quot;</span>, <span class="hljs-comment">// 알림</span>
    <span class="hljs-string">&quot;webRequest&quot;</span>, <span class="hljs-comment">// 웹 요청</span>
    <span class="hljs-string">&quot;webRequestBlocking&quot;</span>,
    <span class="hljs-string">&quot;storage&quot;</span>, <span class="hljs-comment">// 플러그인 로컬 저장소</span>
    <span class="hljs-string">&quot;https://*/*&quot;</span> <span class="hljs-comment">// executeScript 또는 insertCSS를 통해 접근 가능한 웹 사이트</span>
  ],
  <span class="hljs-comment">// 일반 페이지에서 직접 액세스할 수있는 플러그인 자원 목록  &quot;web_accessible_resources&quot;: [&quot;js/inject.js&quot;],</span>
  <span class="hljs-string">&quot;homepage_url&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>, <span class="hljs-comment">// 플러그인 홈페이지</span>
  <span class="hljs-string">&quot;chrome_url_overrides&quot;</span>: { <span class="hljs-comment">// 브라우저 기본 페이지 재정의</span>
    <span class="hljs-string">&quot;newtab&quot;</span>: <span class="hljs-string">&quot;newtab.html&quot;</span>
  },
  <span class="hljs-string">&quot;options_ui&quot;</span>: { <span class="hljs-comment">// 플러그인 옵션 페이지</span>
    <span class="hljs-string">&quot;page&quot;</span>: <span class="hljs-string">&quot;options.html&quot;</span>,
    <span class="hljs-string">&quot;chrome_style&quot;</span>: <span class="hljs-literal">true</span>
  },
  <span class="hljs-string">&quot;omnibox&quot;</span>: { <span class="hljs-string">&quot;keyword&quot;</span> : <span class="hljs-string">&quot;...&quot;</span> }, <span class="hljs-comment">// 검색 제안을위한 주소 표시줄에 키워드 등록, 하나의 키워드 만 설정 가능</span>
  <span class="hljs-string">&quot;default_locale&quot;</span>: <span class="hljs-string">&quot;en&quot;</span>, <span class="hljs-comment">// 기본 언어</span>
  <span class="hljs-string">&quot;devtools_page&quot;</span>: <span class="hljs-string">&quot;devtools.html&quot;</span>, <span class="hljs-comment">// Devtools 페이지 진입점, HTML 파일만 지정 가능    &quot;content_security_policy&quot;: &quot;...&quot;, // 보안 정책</span>
  <span class="hljs-string">&quot;web_accessible_resources&quot;</span>: [ <span class="hljs-comment">// 로드 가능한 리소스</span>
    <span class="hljs-string">&quot;RESOURCE_PATHS&quot;</span>
  ]
}
</code></pre>
<p>Manifest V3의 예시는 다음과 같습니다:</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">&quot;manifest_version&quot;</span>: <span class="hljs-number">3</span>,
  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>, 
  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,
  <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>, 
  <span class="hljs-string">&quot;icons&quot;</span>: {
    <span class="hljs-string">&quot;16&quot;</span>: <span class="hljs-string">&quot;img/icon16.png&quot;</span>,
    <span class="hljs-string">&quot;48&quot;</span>: <span class="hljs-string">&quot;img/icon48.png&quot;</span>,
    <span class="hljs-string">&quot;128&quot;</span>: <span class="hljs-string">&quot;img/icon128.png&quot;</span>
  },
  <span class="hljs-string">&quot;background&quot;</span>: {
    <span class="hljs-string">&quot;service_worker&quot;</span>: <span class="hljs-string">&quot;js/background.js&quot;</span>
  },
  <span class="hljs-string">&quot;action&quot;</span>: {
    <span class="hljs-string">&quot;default_icon&quot;</span>: <span class="hljs-string">&quot;img/icon.png&quot;</span>,
    <span class="hljs-string">&quot;default_title&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>, 
    <span class="hljs-string">&quot;default_popup&quot;</span>: <span class="hljs-string">&quot;popup.html&quot;</span>
  },
  <span class="hljs-string">&quot;content_security_policy&quot;</span>: {
    <span class="hljs-string">&quot;extension_pages&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>,
    <span class="hljs-string">&quot;sandbox&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>
  },
  <span class="hljs-string">&quot;web_accessible_resources&quot;</span>: [
    {
      <span class="hljs-string">&quot;resources&quot;</span>: [<span class="hljs-string">&quot;RESOURCE_PATHS&quot;</span>]
    }
  ],
  <span class="hljs-string">&quot;permissions&quot;</span>: [
    <span class="hljs-string">&quot;contextMenus&quot;</span>,
    <span class="hljs-string">&quot;tabs&quot;</span>,
    <span class="hljs-string">&quot;notifications&quot;</span>,
    <span class="hljs-string">&quot;webRequest&quot;</span>,
    <span class="hljs-string">&quot;webRequestBlocking&quot;</span>,
    <span class="hljs-string">&quot;storage&quot;</span>,
    <span class="hljs-string">&quot;https://*/*&quot;</span>
  ],
  <span class="hljs-string">&quot;web_accessible_resources&quot;</span>: [<span class="hljs-string">&quot;js/inject.js&quot;</span>],
  <span class="hljs-string">&quot;homepage_url&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>, 
  <span class="hljs-string">&quot;chrome_url_overrides&quot;</span>: {
    <span class="hljs-string">&quot;newtab&quot;</span>: <span class="hljs-string">&quot;newtab.html&quot;</span>
  },
  <span class="hljs-string">&quot;options_ui&quot;</span>: {
    <span class="hljs-string">&quot;page&quot;</span>: <span class="hljs-string">&quot;options.html&quot;</span>,
    <span class="hljs-string">&quot;chrome_style&quot;</span>: <span class="hljs-literal">true</span>
  },
  <span class="hljs-string">&quot;omnibox&quot;</span>: {
    <span class="hljs-string">&quot;keyword&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>
  },
  <span class="hljs-string">&quot;default_locale&quot;</span>: <span class="hljs-string">&quot;zh_CN&quot;</span>, 
  <span class="hljs-string">&quot;devtools_page&quot;</span>: <span class="hljs-string">&quot;devtools.html&quot;</span>,
  <span class="hljs-string">&quot;content_security_policy&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>,
  <span class="hljs-string">&quot;web_accessible_resources&quot;</span>: [<span class="hljs-string">&quot;RESOURCE_PATHS&quot;</span>]
}
</code></pre>
<p>4.3.2 콘텐츠 스크립트</p>
<p>크롬 익스텐션의 콘텐츠 스크립트는 구성을 통해 지정된 페이지에 JS 및 CSS를 삽입합니다. 그들은 원래 페이지와 DOM을 공유하지만 JavaScript는 공유하지 않습니다. 페이지 JS 변수에 액세스하려면 JS를 삽입해야 합니다. 콘텐츠 스크립트는 다음을 제외한 대부분의 Chrome API에 액세스할 수 없습니다.</p>
<ul>
<li>chrome. extension</li>
<li>chrome.i18n</li>
<li>chrome. runtime</li>
<li>chrome.storage</li>
</ul>
<p>다른 API의 경우, 통신은 백그라운드 또는 서비스 워커를 통해 수행되어야 합니다.</p>
<h3>4.3.3 배경 스크립트</h3>
<p>크롬 확장프로그램의 배경 스크립트는 수명이 가장 길며 브라우저가 열려 있는 동안 계속 실행됩니다. 이들은 광범위한 권한을 가지고 있어 대부분의 크롬 확장프로그램 API에 액세스하고 CORS 제한 없이 교차 출처 요청을 할 수 있습니다. Manifest V3에서 배경 페이지는 수명이 짧고 이벤트 기반으로 실행되는 서비스 워커로 대체되어 글로벌 변수를 저장하기에 적합하지 않습니다.</p>
<h3>4.3.4 팝업 창</h3>
<p>팝업 창은 웹페이지의 작은 창으로, 오른쪽 상단의 아이콘을 클릭하면 나타납니다. 사용자가 웹페이지 외부에서 상호 작용하면 빠르게 닫힙니다. 일시적 상호작용에 사용되며 배경과 유사한 권한 수준을 가지지만 수명은 짧습니다.</p>
<h3>4.3.5 스크립트 삽입</h3>
<p>크롬 확장 프로그램 개발 중 개발자들이 &quot;스크립트 삽입&quot;이라는 용어를 만들었습니다. 이 용어는 DOM 조작을 통해 페이지에 주입된 JavaScript를 가리킵니다. 콘텐츠 스크립트는 DOM을 조작할 수 있지만 액세스 제한으로 인해 직접 액세스할 수 없습니다. 이 제한은 특히 이벤트 바인딩에서 잘 나타납니다. 웹 페이지에서 플러그인을 실행하는 버튼을 추가하는 일반적인 요구 사항을 충족하기 위해 개발자들은 스크립트 삽입 방식을 채택했습니다.</p>
<h2>4.4 크롬 확장 프로그램의 통신 메커니즘</h2>
<p>크롬 확장 프로그램에서 통신은 다섯 가지 유형의 스크립트에 의존합니다:</p>
<ul>
<li>인젝션 스크립트는 보통 window.postMessage에 의존하는 웹페이지에 동적으로 삽입되는 스크립트를 나타냅니다.</li>
<li>컨텐츠 스크립트는 특정 웹페이지 컨텍스트에서 실행되는 스크립트로, window.postMessage, chrome.runtime.sendMessage 및 chrome.runtime.connect를 사용하여 스크립트 간 통신을 합니다.</li>
<li>팝업 스크립트는 플러그인 팝업 인터페이스와 관련되며, 일반적으로 통신을 위해 chrome.tabs.sendMessage 및 chrome.tabs.connect를 사용합니다.</li>
<li>백그라운드 스크립트는 다양한 방법을 활용하며 백그라운드에서 독립적으로 실행되는 스크립트이며, &quot;chrome.tabs.sendMessage&quot;, chrome.tabs.connect, chrome.extension.getBackgroundPage 및 chrome.extension.getViews 등의 메서드를 사용합니다.</li>
<li>개발 도구는 chrome.devtools.inspectedWindow.eval 및 chrome.runtime.sendMessage과 같은 특정 API를 사용하여 상호 작용하는 개발 도구의 추가 기능을 제공합니다.</li>
</ul>
<p>각 스크립트에는 통신의 중요성을 강조하는 다른 권한이 있습니다. 이 상호 작용은 포괄적인 플러그인 기능을 활성화하는 데 중요합니다.</p>
<p>과거를 되짚어 새로운 것을 배우는 것은, 현대 인터넷의 기반인 브라우저 아키텍처가 다중 반복과 혁신을 거쳐 사용자와 웹 콘텐츠 간의 다리로서 항상 역할하고 있다는 것을 생각해봅니다. 초기에는 단일 렌더링 엔진부터 오늘날의 멀티 프로세스, 멀티 스레드 아키텍쳐까지, 각 변화는 더 스무스하고 안전한 브라우징 경험을 가져왔습니다. 앞으로 브라우저 아키텍처는 성능 최적화와 보안 강화를 더욱 심화시켜 사용자에게 더 나은 웹 브라우징 경험을 제공하기 위해 발전할 것입니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"브라우저 아키텍처의 과거와 현재","description":"","date":"2024-05-12 23:47","slug":"2024-05-12-ThePastandPresentofBrowserArchitecture","content":"\n\n\n\u003cimg src=\"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png\" /\u003e\n\n브라우저 아키텍처는 단일 프로세스 브라우저에서 멀티 프로세스 브라우저로의 전환을 거쳤습니다. 안정성, 부드러움, 보안을 강조하며, 프로세스는 렌더링, GPU, 네트워크 및 플러그인으로 분해되어 아키텍처의 청결성이 향상되었습니다. 브라우저 아키텍처를 검토하려면 페이지를 열고, 페이지 렌더링 프로세스, 브라우저 플러그인 메커니즘을 더 잘 이해해야 합니다. 특히 Manifest V1에서 Manifest V3로의 전환을 중심으로 Chrome 확장 프로그램 버전 타임라인을 정리함으로써 브라우저의 진화 과정을 비교적 포괄적으로 이해할 수 있습니다.\n\n# 1. 브라우저 아키텍처의 진화\n\n2007년 이전에 전형적인 브라우저 아키텍쳐는 이러했습니다:\n\n\n\n![브라우저 아키텍처의 과거와 현재](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_1.png)\n\n단일 프로세스 브라우저 아키텍처는 전체 웹 브라우저를 단일 운영 체제 프로세스에서 실행하여 네트워크 처리, 플러그인, JavaScript 런타임, 렌더링 엔진, 페이지 관리 및 사용자 인터페이스 요소 등의 작업을 하나의 실행 공간으로 통합합니다. 자원 관리를 단순화하는 반면, 이 아키텍처 디자인은 다음과 같은 주요 문제점이 있습니다:\n\n- 불안정함 — 플러그인 및 렌더링 엔진은 웹 비디오 및 게임과 같은 기능을 처리하는 동일한 프로세스에서 실행됩니다. 플러그인이나 렌더링 엔진의 충돌로 인해 전체 브라우저가 다운될 수 있으며, 특히 복잡한 JavaScript 코드를 처리할 때 이러한 불안정성이 두드러집니다.\n- 부드러움 부족 — 모든 모듈(페이지 렌더링, JavaScript 실행, 플러그인 포함)이 하나의 스레드를 공유합니다. 스크립트가 매우 시간이 많이 걸리면 전체 스레드를 독점하여 다른 페이지가 응답하지 않게 만들고 전체 브라우저에서 지연이 발생할 수 있습니다.\n- 보안성 부족 — 페이지에서 실행되는 플러그인은 운영 체제 자원에 액세스할 수 있습니다. 악성 플러그인은 이런 액세스를 악용하여 보안을 침해하거나 사용자 자격 증명과 같은 민감한 정보를 탈취할 수 있습니다.\n\n단일 프로세스 브라우저의 장점은 브라우저 구성 요소가 하나의 프로세스 내에서 작동하여 자원 관리와 조정을 간단하게 만든다는 것입니다. 단일 프로세스 브라우저는 보통 낮은 메모리 사용률을 나타내어 자원 효율성 향상에 도움을 줍니다. 작업은 통합된 프로세스 내에서 순차적으로 실행됩니다.\n\n\n\n2008년에 출시된 Chrome 프로세스 아키텍처는 다음 다이어그램을 통해 볼 수 있듯이 멀티 프로세스 브라우저의 한 예입니다:\n\n![다이어그램](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_2.png)\n\n이른 시기에 사용된 브라우저 아키텍처는 기능을 브라우저, 플러그인, 렌더링의 세 가지 주요 프로세스로 나눴습니다. 각 페이지와 해당 플러그인은 전용 렌더링 및 플러그인 프로세스에서 독립적으로 실행되며, IPC를 통해 통신합니다.\n\n프로세스간 통신(IPC)은 프로세스가 컴퓨터에서 통신하고 작업을 동기화하는 메커니즘입니다. 이를 통해 다른 프로그램 간에 효율적인 데이터 교환과 조정이 가능해집니다. 주요 IPC 메커니즘에는 공유 메모리가 포함되어 있어 프로세스 간의 세마포어를 사용하여 공유된 공용 메모리 영역에 대한 액세스를 동기화합니다. Named 및 unnamed 파이프는 단방향 통신을 제공하며, Linux에서의 IPC는 일반적으로 세마포어를 사용하여 파일이나 공유 메모리 저장소를 공유합니다. 메시지 큐는 비동기 통신을 지원하여 송신자 및 수신자 프로세스를 분리하는 데 도움을 줍니다. 또한, 프로세스는 이벤트나 요청을 통지하기 위해 시그널을 통해 통신할 수 있습니다. 소켓은 네트워크 프로토콜을 사용하여 서로 다른 기계 간에 IPC를 확장합니다.\n\n\n\n멀티 프로세스 브라우저는 안정성을 향상시킵니다. 격리된 프로세스 덕분에 충돌이 전체 브라우저에 영향을 미치지 않습니다. 페이지나 플러그인의 충돌은 해당 프로세스에만 영향을 미치며, 다른 페이지와 브라우저 전체의 안정성을 보장합니다. JavaScript를 별도의 렌더링 프로세스에서 실행하는 것도 영향을 격리시킵니다. 만약 스크립트가 렌더링 프로세스를 차단한다면, 현재 페이지에만 영향을 미치고 다른 페이지에는 영향을 미치지 않습니다. 각 페이지가 별도의 렌더링 프로세스에서 스크립트를 실행하기 때문에 브라우저 전체가 영향을 받지 않습니다. 더불어 Chrome은 플러그인과 렌더링 프로세스를 샌드박스 환경에 배치하여 데이터에 대한 읽기/쓰기 액세스를 제한합니다. 악성 소프트웨어가 이러한 프로세스 내에서 실행되더라도 시스템 권한을 획들할 수 없습니다. 이것이 구획화된 아키텍처 패턴의 한 예입니다.  \n\n샌드박스는 전체 시스템의 작동에 영향을 미치지 않고 프로그램을 실행하거나 파일을 열 수 있는 테스트 환경입니다. 사이버 보안 분야에서 산드박스는 잠재적으로 해로운 코드 실행을 분석하여 위협을 탐지하고 완화하는 용도로 사용됩니다. \n\n최신 버전의 Chrome 브라우저에는 아래와 같은 주요 구성 요소가 있습니다:\n\n![Chrome Browser Components](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_3.png)\n\n\n\n브라우저 프로세스는 디스플레이 인터페이스, 사용자 상호작용 및 서브프로세스 조정을 관리하며, 저장 기능을 제공합니다. 이는 다른 프로세스를 조정하는 \"스케줄러\"로 작용하여, 예를 들어 URL을 입력할 때 네트워크 프로세스를 호출합니다. 렌더링 프로세스는 HTML, CSS 및 JavaScript를 대화형 웹 페이지로 변환하고 V8 엔진을 실행합니다. 보안상의 이유로 Chrome은 각 탭에 대해 별도의 렌더링 프로세스를 샌드박스 모드로 생성합니다.\n\nGPU 프로세스는 초기에 3D CSS 효과를 위해 설계되었지만 나중에 웹 페이지 및 Chrome UI 인터페이스를 그리는 데 확장되었습니다. 공통 브라우저 요구 사항을 충족하기 위해 Chrome의 다중 프로세스 아키텍처에 소개되었습니다. 네트워크 프로세스는 페이지 네트워크 리소스를 독립적으로 로드하며, 원래 브라우저 프로세스 내의 모듈이었지만 지금은 별도의 프로세스로 실행됩니다. 플러그인 프로세스는 플러그인을 관리하여 브라우저 및 페이지에 플러그인의 내재적 불안정성으로 인한 충돌을 방지합니다.\n\n현대적인 브라우저 아키텍처는 아래 다이어그램에서 보실 수 있습니다:\n\n![Diagram](/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_4.png)\n\n\n\n# 2. 브라우저 페이지 열리는 과정\n\n- 탭 추가는 기본 프로세스 생성을 시작합니다: 시스템 브라우저, 렌더링, GPU 및 네트워크 프로세스.\n- 사용자 입력은 브라우저 프로세스를 활성화하여 프로토콜을 확인하고 완전한 URL을 구성합니다.\n- 브라우저 프로세스는 URL 요청을 네트워크 프로세스로 보냅니다. 여기서 인터프로세스 통신이 이루어집니다.\n- 네트워크 프로세스는 요청된 리소스를 로컬 캐시에서 확인합니다. 캐시에서 찾을 경우 브라우저 프로세스로 반환합니다.\n- 캐시에 없는 경우, 네트워크 프로세스는 웹 서버로 HTTP 요청을 보냅니다.\n- 네트워크 프로세스는 응답을 구문 분석하고 상태 코드를 확인합니다. 비-200 상태 코드는 특정 처리 논리를 유도합니다.\n- 200 응답의 경우, 브라우저 프로세스는 Content-Type을 확인합니다. 바이트 스트림은 다운로드 관리자를 활성화하고 HTML은 렌더링 준비를 신호로 합니다.\n- 브라우저 프로세스는 현재 URL이 기존 렌더링 프로세스의 루트 도메인과 일치하는지 확인합니다. 다를 경우, 새로운 렌더링 프로세스를 시작합니다.\n- 브라우저는 네트워크 프로세스와 데이터 전송 파이프라인을 설정하기 위해 렌더링 프로세스에 \"문서 제출\" 메시지를 보냅니다.\n- 데이터 수신 후, 렌더링 프로세스는 브라우저로 확인을 보냅니다. 브라우저는 보안 표시기, 주소 표시줄 URL, 브라우징 기록 및 웹페이지 컨텐츠를 업데이트합니다.\n\n# 3. 렌더링 프로세스\n\n현대 브라우저는 성능을 우선시하는 방법으로 레이지 로딩 및 캐싱 같은 전략을 사용합니다. 브라우저는 렌더링 프로세스를 통해 웹 콘텐츠를 표시합니다. 핵심 단계는 HTML 구문 분석, CSS 스타일링, 레이아웃 생성 및 그리기가 되며, 구체적인 단계는 다음과 같습니다:\n\n\n\n- 사용자 입력 — 브라우저 주소 표시줄에 URL을 입력하세요.\n- URL 구문 분석 — URL을 구문 분석하여 프로토콜, 호스트, 포트 및 경로를 식별합니다.\n- DNS 조회 — 호스트 이름을 IP 주소로 변환하기 위해 DNS 조회를 수행합니다.\n- 소켓 연결 — 사용자와 서버 IP 간의 연결 설정.\n- HTTP 요청 — 프로토콜을 지정하는 HTTP 요청을 서버로 보냅니다.\n- 서버 처리 — 서버는 요청을 평가하고 처리 플러그인(예: PHP, Java)을 결정합니다.\n- 플러그인을 통한 처리 — HTTP 응답의 일부로 데이터베이스 또는 다른 리소스에 액세스합니다.\n- 브라우저 응답 — HTTP 응답을 브라우저로 다시 보냅니다.\n- 응답 분석 — 브라우저에서 응답의 HTML 데이터를 분석합니다.\n- DOM 트리 생성 — 구문 분석된 HTML에서 문서 객체 모델(DOM) 트리를 구성합니다.\n- 스타일시트 구문 분석 — 프레젠테이션 데이터를 DOM 노드에 연결하는 스타일시트를 구문 분석합니다.\n- JavaScript 실행 — DOM 요소를 수정하기 위해 JavaScript 코드를 실행합니다.\n- 페이지 렌더링 — DOM 및 스타일 데이터를 사용하여 웹 페이지를 표시합니다.\n\n## 3.1 HTML 구문 분석\n\n브라우저가 HTML을 문자 단위로 읽어 요소, 속성 및 텍스트를 식별한 후, 웹 페이지의 구조를 표현하는 DOM 트리를 구성하여 HTML 코드가 올바르게 표시되도록 합니다.\n\n## 3.2 CSS Object Model\n\n\n\nCSS Object Model는 HTML 요소에 적용된 스타일을 표현하며, DOM 트리의 구조적 계층과 유사하게 특정성과 스타일의 캐스캐이딩 성질을 고려하여 스타일에 대한 접근, 조작 및 계산을 허용합니다.\n\n## 3.3 레이아웃 관리자\n\n레이아웃 관리자는 DOM과 CSS object model을 결합하여 렌더링 트리를 형성하고, 내용, 패딩 등을 기반으로 상자의 크기를 결정하며, 특정 위치를 구축하는 데 다양한 메소드를 사용합니다. 동시에 겹치는 요소를 처리하기 위해 쌓임 맥락과 Z-인덱스를 사용하고, 배치 변경을 최적화하기 위해 일괄 처리 기술을 사용합니다. 마지막으로 화면에 요소가 그려지고 사용자 상호작용 중에 지속적으로 업데이트됩니다.\n\n# 4 플러그인 메커니즘\n\n\n\n## 4.1 플러그인 개발 역사\n\n플러그인 메커니즘의 개발 과정은 다음과 같습니다:\n\n- 2012년 8월 — 매니페스트 V1: Chrome 플러그인은 처음에 매니페스트 V1을 기반으로 했으며, 기본 기능 및 권한을 정의했습니다.\n- 2013년 4월 — Chrome26 안정 버전: 매니페스트 V1 플러그인 지원이 포함되었습니다.\n- 2014년 5월 — Chrome35 안정 버전: 브라우저의 점진적 업데이트가 계속해서 ManifestV1 플러그인을 지원했습니다.\n- 2014년 9월 — Chrome 37 안정 버전: Manifest V1 플러그인을 위한 추가 개선 및 버그 수정이 이루어졌습니다.\n- 2015년 5월 — Chrome43 안정 버전: Manifest V1 계속 지원됩니다.\n- 2015년 12월 — Manifest V2 등장: ManifestV2가 도입되어 더 나은 보안 및 추가 기능을 제공했습니다.\n- 2016년 6월 — Chrome51 안정 버전: Manifest V2가 플러그인 개발의 표준이 되었습니다.\n- 2016년 9월 — Chrome53 안정 버전: Manifest V2의 지속적인 개선 및 최적화가 이루어졌습니다.\n- 2019년 1월 — Manifest V3 출시: 보안, 성능 및 개발 유연성에 초점을 맞춥니다.\n- 2020년 3월 — Chrome80 안정 버전: Manifest V2는 플러그인의 표준이지만, Manifest V3는 테스트용으로 제공되었지만 아직 필수는 아닙니다.\n- 2021년 3월 — Chrome89 안정 버전: Manifest V2가 여전히 기본이지만 Manifest V3로의 관심이 증가하고 있습니다.\n- 2021년 10월 — Chrome94 안정 버전: Manifest V3가 일부 기능을 강화하기 시작하며, 이전 버전에서의 이전 가이드 및 도구가 개발자에게 제공됩니다.\n- 2022년 3월 — Chrome98 안정 버전: Manifest V3가 새로운 플러그인 버전의 기본이 됩니다. 그러면서 Manifest V2도 계속 지원됩니다.\n- 2022년 8월 — Chrome104 안정 버전: 모든 플러그인이 공식적으로 Manifest V3로 전환되어, Manifest V2의 추가 지원이 중단되었습니다.\n- 2023년 3월 — Chrome108 안정 버전: 모든 플러그인이 Manifest V3를 온전히 지원하며, 매끄러운 전환을 보장합니다.\n- 2023년 7월 — Manifest V3 미리보기: 개발자들이 다가오는 변경 사항을 탐색하고 유용한 피드백을 제공할 수 있도록 합니다.\n- 2023년 10월 — Chrome Z 안정 버전에서 ManifestV3 지원을 더 개선하며, 미리보기 단계에서 보고된 모든 문제를 해결합니다.\n- 2024년 1월 — Manifest V3 사전 안정 버전 배포: Manifest V3가 안정 상태에 도달하여, 개발자들이 확장 프로그램을 V3로 이전하고 모든 문서 및 이전 가이드가 제공됩니다.\n- 2024년 3월 — Chrome116 안정 버전: Manifest V3를 완전히 지원하며, 개발자들은 플러그인을 최신 표준과 호환되도록 업데이트합니다.\n\n총적으로, Chrome 익스텐션(또는 애드온)은 3가지 주요 버전인 Manifest V1, Manifest V2 및 Manifest V3의 개발 과정을 거쳤습니다.\n\n\n\nManifest V1 (MV1)은 Chrome 확장 프로그램 매니페스트의 초기 버전이었으며 오래되었습니다. Manifest V2 (MV2)는 현재 Chrome 확장 프로그램에서 널리 사용되는 주요 버전으로, 확장 프로그램을 더 많은 브라우저 기능과 기능으로 구축할 수 있는 견고한 프레임워크를 제공합니다. Manifest V3은 점차 MV2를 대체하는 최신 버전으로, 보안 및 성능 문제에 대응하기 위해 보안 조치를 강화하고 확장 프로그램 개발 시 더 나은 성능을 촉진하는 것을 목표로 합니다. Chrome 127 (2024년 6월)부터 Google은 안정화되지 않은 Chrome 버전에서 Manifest V2 확장 프로그램을 비활성화하기 시작할 예정이며, 개발자들이 MV3로 전환하도록 권장합니다.\n\n## 4.2 Manifest의 기능 및 버전 이전\n\nManifest V2의 기능:\n\n- Content-Security-Policy (CSP)를 설정하여 script-src 'self'; object-src 'self';를 사용하여 기본 콘텐츠 보안 정책을 설정합니다.\n- 플러그인 패키지 리소스는 외부로 더 이상 사용할 수 없으며, 허용 목록은 매니페스트의 web_access_resources 속성을 통해 나열됩니다.\n- 브라우저 작업 API 및 페이지 작업 API에 변경 사항이 있으며, chrome.extension이 플러그인 자체를 가리키는 chrome.self를 대체하고, chrome.tension.getTabContentses는 tension.getView로 대체되고, Port.tab은 runtime.Port로 대체됩니다.\n\n\n\nManifest V3의 기능:\n\n- Manifest V3은 백그라운드 페이지를 대체하는 서비스 워커를 도입했습니다.\n- 네트워크 요청 수정은 더 이상 사용되지 않는 webRequest API 대신 새로운 선언적 넷 요청 API를 사용합니다.\n- 원격 코드 실행이 허용되지 않으며, 확장 프로그램 패키지 내의 JS만 실행할 수 있습니다.\n- Promises가 많은 메소드에 추가되었고, 콜백은 여전히 지원됩니다.\n- Browser Action API 및 Page Action API가 하나의 액션 API로 통합되었습니다.\n- 웹 접근 가능한 리소스는 지정된 사이트 및 확장 프로그램으로 제한됩니다.\n- 콘텐츠 보안 정책 (CSP)은 다른 실행 컨텍스트에 대해 별도의 CSP를 지정할 수 있습니다. executeScript는 스크립트 파일과 함수만 실행하고 임의의 문자열은 실행할 수 없습니다.\n\nManifest V3은 Chrome이 개인 정보 보호, 보안 및 전반적인 확장 프로그램 성능 향상에 대한 약속으로부터 비롯된 V1과 V2로부터의 중요한 전환을 나타냅니다. 이전 버전과는 달리, Manifest V3은 자원 효율성을 우선시하여 Chrome의 과거 높은 자원 사용량에 대한 우려 사항을 해결합니다. 핵심 목표는 확장 프로그램을 통해 시스템 자원 소비를 제한하여 브라우저 성능을 최적화하는 것입니다. 추가 제약 사항을 부과하면서도, Manifest V3은 중요한 이점을 소개합니다. 서비스 워커 기능을 통해 확장 프로그램이 계속해서 백그라운드에 상주하지 않고도 작동할 수 있어, 확장 프로그램 자원을 재활용하고 브라우저 전반적인 오버헤드를 효과적으로 줄일 수 있습니다. 규칙 계산에 대한 제약 사항은 개별 확장 프로그램이 자원을 과도하게 소비하지 않도록 제어 메커니즘으로 작용합니다. 이러한 변경 사항들은 Chrome에서 더 부드러운 브라우징 경험을 제공하며, 향상된 브라우저 효율성에 대한 사용자 기대를 충족합니다.\n\nV2에서 V3로 이전시, 페이지 배경을 구성하기 위한 background.html이 없다는 이유로 백그라운드.html에서 AJAX 요청을 구성하는 데 윈도우 개체의 XMLHttpRequest를 사용할 수 없습니다. 대신, 데이터를 추출하는 방법을 사용하여 데이터를 검색해야 합니다.\n\n\n\n또한, 서비스 워커의 짧은 수명과 비활성 기간 동안의 종료로 인해 가끔 발생하는 시작, 실행 및 종료로 플러그인 수명주기 동안 불안정성이 발생합니다. MV2에서는 전역 변수가 데이터 저장에 직접 사용되었으므로 이러한 상황 하에서 안정성과 기능성을 향상시키기 위해 backound.js 로직을 수정해야 합니다. 또한 webRequest API에서 statativeNetRequest API로 전환하면 상당한 코드 리팩터링이 필요합니다.\n\n## 4.3 Chrome 확장 프로그램의 주요 구성 요소\n\n4.3.1 매니페스트 파일\n\n매니페스트.json 파일은 루트 디렉토리에 위치한 Chrome 확장 프로그램에 매우 중요합니다. 이 파일을 통해 Manif_version, 이름, 버전과 같은 기본 매개변수를 포함하여 모든 플러그인 설정을 구성합니다.\n\n\n\nManifest V2의 예시는 다음과 같습니다:\n\n```js\n{\n  \"manifest_version\": 2,\n  // 플러그인 이름\n  \"name\": \"...\",\n  // 플러그인 버전\n  \"version\": \"1.0.0\",\n  // 플러그인 설명\n  \"description\": \"...\",\n  \"icons\": {\n    \"16\": \"img/icon16.png\",\n    \"48\": \"img/icon48.png\",\n    \"128\": \"img/icon128.png\"\n  },\n  // 브라우저의 백그라운드 JS 또는 백그라운드 페이지\n  \"background\": {\n    \"scripts\": [\"js/background.js\"]\n  },\n  // 브라우저 아이콘 설정: browser_action, page_action, app\n  \"browser_action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_title\": \"...\",\n    \"default_popup\": \"popup.html\"\n  },\n  // 특정 페이지가 열릴 때에만 표시되는 아이콘\n  \"page_action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_title\": \"...\",\n    \"default_popup\": \"popup.html\"\n  },\n  // 페이지에 직접 주입되는 JS\n  \"content_scripts\": [{\n    \"matches\": [\"\u003call_urls\u003e\"],\n    \"js\": [\"js/content-script.js\"],\n    \"css\": [\"css/custom.css\"],\n    // 코드 주입 시기, 기본값은 document_idle\n    \"run_at\": \"document_start\"\n  }],\n  // 요청되는 권한\n  \"permissions\": [\n    \"contextMenus\", // 우클릭 메뉴\n    \"tabs\", // 탭\n    \"notifications\", // 알림\n    \"webRequest\", // 웹 요청\n    \"webRequestBlocking\",\n    \"storage\", // 플러그인 로컬 저장소\n    \"https://*/*\" // executeScript 또는 insertCSS를 통해 접근 가능한 웹 사이트\n  ],\n  // 일반 페이지에서 직접 액세스할 수있는 플러그인 자원 목록  \"web_accessible_resources\": [\"js/inject.js\"],\n  \"homepage_url\": \"...\", // 플러그인 홈페이지\n  \"chrome_url_overrides\": { // 브라우저 기본 페이지 재정의\n    \"newtab\": \"newtab.html\"\n  },\n  \"options_ui\": { // 플러그인 옵션 페이지\n    \"page\": \"options.html\",\n    \"chrome_style\": true\n  },\n  \"omnibox\": { \"keyword\" : \"...\" }, // 검색 제안을위한 주소 표시줄에 키워드 등록, 하나의 키워드 만 설정 가능\n  \"default_locale\": \"en\", // 기본 언어\n  \"devtools_page\": \"devtools.html\", // Devtools 페이지 진입점, HTML 파일만 지정 가능    \"content_security_policy\": \"...\", // 보안 정책\n  \"web_accessible_resources\": [ // 로드 가능한 리소스\n    \"RESOURCE_PATHS\"\n  ]\n}\n```\n\nManifest V3의 예시는 다음과 같습니다:\n\n```js\n{\n  \"manifest_version\": 3,\n  \"name\": \"...\", \n  \"version\": \"1.0.0\",\n  \"description\": \"...\", \n  \"icons\": {\n    \"16\": \"img/icon16.png\",\n    \"48\": \"img/icon48.png\",\n    \"128\": \"img/icon128.png\"\n  },\n  \"background\": {\n    \"service_worker\": \"js/background.js\"\n  },\n  \"action\": {\n    \"default_icon\": \"img/icon.png\",\n    \"default_title\": \"...\", \n    \"default_popup\": \"popup.html\"\n  },\n  \"content_security_policy\": {\n    \"extension_pages\": \"...\",\n    \"sandbox\": \"...\"\n  },\n  \"web_accessible_resources\": [\n    {\n      \"resources\": [\"RESOURCE_PATHS\"]\n    }\n  ],\n  \"permissions\": [\n    \"contextMenus\",\n    \"tabs\",\n    \"notifications\",\n    \"webRequest\",\n    \"webRequestBlocking\",\n    \"storage\",\n    \"https://*/*\"\n  ],\n  \"web_accessible_resources\": [\"js/inject.js\"],\n  \"homepage_url\": \"...\", \n  \"chrome_url_overrides\": {\n    \"newtab\": \"newtab.html\"\n  },\n  \"options_ui\": {\n    \"page\": \"options.html\",\n    \"chrome_style\": true\n  },\n  \"omnibox\": {\n    \"keyword\": \"...\"\n  },\n  \"default_locale\": \"zh_CN\", \n  \"devtools_page\": \"devtools.html\",\n  \"content_security_policy\": \"...\",\n  \"web_accessible_resources\": [\"RESOURCE_PATHS\"]\n}\n```\n\n\n\n4.3.2 콘텐츠 스크립트\n\n크롬 익스텐션의 콘텐츠 스크립트는 구성을 통해 지정된 페이지에 JS 및 CSS를 삽입합니다. 그들은 원래 페이지와 DOM을 공유하지만 JavaScript는 공유하지 않습니다. 페이지 JS 변수에 액세스하려면 JS를 삽입해야 합니다. 콘텐츠 스크립트는 다음을 제외한 대부분의 Chrome API에 액세스할 수 없습니다.\n\n- chrome. extension\n- chrome.i18n\n- chrome. runtime\n- chrome.storage\n\n다른 API의 경우, 통신은 백그라운드 또는 서비스 워커를 통해 수행되어야 합니다.\n\n\n\n### 4.3.3 배경 스크립트\n\n크롬 확장프로그램의 배경 스크립트는 수명이 가장 길며 브라우저가 열려 있는 동안 계속 실행됩니다. 이들은 광범위한 권한을 가지고 있어 대부분의 크롬 확장프로그램 API에 액세스하고 CORS 제한 없이 교차 출처 요청을 할 수 있습니다. Manifest V3에서 배경 페이지는 수명이 짧고 이벤트 기반으로 실행되는 서비스 워커로 대체되어 글로벌 변수를 저장하기에 적합하지 않습니다.\n\n### 4.3.4 팝업 창\n\n팝업 창은 웹페이지의 작은 창으로, 오른쪽 상단의 아이콘을 클릭하면 나타납니다. 사용자가 웹페이지 외부에서 상호 작용하면 빠르게 닫힙니다. 일시적 상호작용에 사용되며 배경과 유사한 권한 수준을 가지지만 수명은 짧습니다.\n\n\n\n### 4.3.5 스크립트 삽입\n\n크롬 확장 프로그램 개발 중 개발자들이 \"스크립트 삽입\"이라는 용어를 만들었습니다. 이 용어는 DOM 조작을 통해 페이지에 주입된 JavaScript를 가리킵니다. 콘텐츠 스크립트는 DOM을 조작할 수 있지만 액세스 제한으로 인해 직접 액세스할 수 없습니다. 이 제한은 특히 이벤트 바인딩에서 잘 나타납니다. 웹 페이지에서 플러그인을 실행하는 버튼을 추가하는 일반적인 요구 사항을 충족하기 위해 개발자들은 스크립트 삽입 방식을 채택했습니다.\n\n## 4.4 크롬 확장 프로그램의 통신 메커니즘\n\n크롬 확장 프로그램에서 통신은 다섯 가지 유형의 스크립트에 의존합니다:\n\n\n\n- 인젝션 스크립트는 보통 window.postMessage에 의존하는 웹페이지에 동적으로 삽입되는 스크립트를 나타냅니다.\n- 컨텐츠 스크립트는 특정 웹페이지 컨텍스트에서 실행되는 스크립트로, window.postMessage, chrome.runtime.sendMessage 및 chrome.runtime.connect를 사용하여 스크립트 간 통신을 합니다.\n- 팝업 스크립트는 플러그인 팝업 인터페이스와 관련되며, 일반적으로 통신을 위해 chrome.tabs.sendMessage 및 chrome.tabs.connect를 사용합니다.\n- 백그라운드 스크립트는 다양한 방법을 활용하며 백그라운드에서 독립적으로 실행되는 스크립트이며, \"chrome.tabs.sendMessage\", chrome.tabs.connect, chrome.extension.getBackgroundPage 및 chrome.extension.getViews 등의 메서드를 사용합니다.\n- 개발 도구는 chrome.devtools.inspectedWindow.eval 및 chrome.runtime.sendMessage과 같은 특정 API를 사용하여 상호 작용하는 개발 도구의 추가 기능을 제공합니다.\n\n각 스크립트에는 통신의 중요성을 강조하는 다른 권한이 있습니다. 이 상호 작용은 포괄적인 플러그인 기능을 활성화하는 데 중요합니다.\n\n과거를 되짚어 새로운 것을 배우는 것은, 현대 인터넷의 기반인 브라우저 아키텍처가 다중 반복과 혁신을 거쳐 사용자와 웹 콘텐츠 간의 다리로서 항상 역할하고 있다는 것을 생각해봅니다. 초기에는 단일 렌더링 엔진부터 오늘날의 멀티 프로세스, 멀티 스레드 아키텍쳐까지, 각 변화는 더 스무스하고 안전한 브라우징 경험을 가져왔습니다. 앞으로 브라우저 아키텍처는 성능 최적화와 보안 강화를 더욱 심화시켜 사용자에게 더 나은 웹 브라우징 경험을 제공하기 위해 발전할 것입니다.","ogImage":{"url":"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png"},"coverImage":"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png","tag":["Tech"],"readingTime":15},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h1: \"h1\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_0.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"브라우저 아키텍처는 단일 프로세스 브라우저에서 멀티 프로세스 브라우저로의 전환을 거쳤습니다. 안정성, 부드러움, 보안을 강조하며, 프로세스는 렌더링, GPU, 네트워크 및 플러그인으로 분해되어 아키텍처의 청결성이 향상되었습니다. 브라우저 아키텍처를 검토하려면 페이지를 열고, 페이지 렌더링 프로세스, 브라우저 플러그인 메커니즘을 더 잘 이해해야 합니다. 특히 Manifest V1에서 Manifest V3로의 전환을 중심으로 Chrome 확장 프로그램 버전 타임라인을 정리함으로써 브라우저의 진화 과정을 비교적 포괄적으로 이해할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"1. 브라우저 아키텍처의 진화\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"2007년 이전에 전형적인 브라우저 아키텍쳐는 이러했습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_1.png\",\n        alt: \"브라우저 아키텍처의 과거와 현재\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단일 프로세스 브라우저 아키텍처는 전체 웹 브라우저를 단일 운영 체제 프로세스에서 실행하여 네트워크 처리, 플러그인, JavaScript 런타임, 렌더링 엔진, 페이지 관리 및 사용자 인터페이스 요소 등의 작업을 하나의 실행 공간으로 통합합니다. 자원 관리를 단순화하는 반면, 이 아키텍처 디자인은 다음과 같은 주요 문제점이 있습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"불안정함 — 플러그인 및 렌더링 엔진은 웹 비디오 및 게임과 같은 기능을 처리하는 동일한 프로세스에서 실행됩니다. 플러그인이나 렌더링 엔진의 충돌로 인해 전체 브라우저가 다운될 수 있으며, 특히 복잡한 JavaScript 코드를 처리할 때 이러한 불안정성이 두드러집니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"부드러움 부족 — 모든 모듈(페이지 렌더링, JavaScript 실행, 플러그인 포함)이 하나의 스레드를 공유합니다. 스크립트가 매우 시간이 많이 걸리면 전체 스레드를 독점하여 다른 페이지가 응답하지 않게 만들고 전체 브라우저에서 지연이 발생할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"보안성 부족 — 페이지에서 실행되는 플러그인은 운영 체제 자원에 액세스할 수 있습니다. 악성 플러그인은 이런 액세스를 악용하여 보안을 침해하거나 사용자 자격 증명과 같은 민감한 정보를 탈취할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단일 프로세스 브라우저의 장점은 브라우저 구성 요소가 하나의 프로세스 내에서 작동하여 자원 관리와 조정을 간단하게 만든다는 것입니다. 단일 프로세스 브라우저는 보통 낮은 메모리 사용률을 나타내어 자원 효율성 향상에 도움을 줍니다. 작업은 통합된 프로세스 내에서 순차적으로 실행됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"2008년에 출시된 Chrome 프로세스 아키텍처는 다음 다이어그램을 통해 볼 수 있듯이 멀티 프로세스 브라우저의 한 예입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_2.png\",\n        alt: \"다이어그램\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이른 시기에 사용된 브라우저 아키텍처는 기능을 브라우저, 플러그인, 렌더링의 세 가지 주요 프로세스로 나눴습니다. 각 페이지와 해당 플러그인은 전용 렌더링 및 플러그인 프로세스에서 독립적으로 실행되며, IPC를 통해 통신합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로세스간 통신(IPC)은 프로세스가 컴퓨터에서 통신하고 작업을 동기화하는 메커니즘입니다. 이를 통해 다른 프로그램 간에 효율적인 데이터 교환과 조정이 가능해집니다. 주요 IPC 메커니즘에는 공유 메모리가 포함되어 있어 프로세스 간의 세마포어를 사용하여 공유된 공용 메모리 영역에 대한 액세스를 동기화합니다. Named 및 unnamed 파이프는 단방향 통신을 제공하며, Linux에서의 IPC는 일반적으로 세마포어를 사용하여 파일이나 공유 메모리 저장소를 공유합니다. 메시지 큐는 비동기 통신을 지원하여 송신자 및 수신자 프로세스를 분리하는 데 도움을 줍니다. 또한, 프로세스는 이벤트나 요청을 통지하기 위해 시그널을 통해 통신할 수 있습니다. 소켓은 네트워크 프로토콜을 사용하여 서로 다른 기계 간에 IPC를 확장합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"멀티 프로세스 브라우저는 안정성을 향상시킵니다. 격리된 프로세스 덕분에 충돌이 전체 브라우저에 영향을 미치지 않습니다. 페이지나 플러그인의 충돌은 해당 프로세스에만 영향을 미치며, 다른 페이지와 브라우저 전체의 안정성을 보장합니다. JavaScript를 별도의 렌더링 프로세스에서 실행하는 것도 영향을 격리시킵니다. 만약 스크립트가 렌더링 프로세스를 차단한다면, 현재 페이지에만 영향을 미치고 다른 페이지에는 영향을 미치지 않습니다. 각 페이지가 별도의 렌더링 프로세스에서 스크립트를 실행하기 때문에 브라우저 전체가 영향을 받지 않습니다. 더불어 Chrome은 플러그인과 렌더링 프로세스를 샌드박스 환경에 배치하여 데이터에 대한 읽기/쓰기 액세스를 제한합니다. 악성 소프트웨어가 이러한 프로세스 내에서 실행되더라도 시스템 권한을 획들할 수 없습니다. 이것이 구획화된 아키텍처 패턴의 한 예입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"샌드박스는 전체 시스템의 작동에 영향을 미치지 않고 프로그램을 실행하거나 파일을 열 수 있는 테스트 환경입니다. 사이버 보안 분야에서 산드박스는 잠재적으로 해로운 코드 실행을 분석하여 위협을 탐지하고 완화하는 용도로 사용됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"최신 버전의 Chrome 브라우저에는 아래와 같은 주요 구성 요소가 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_3.png\",\n        alt: \"Chrome Browser Components\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"브라우저 프로세스는 디스플레이 인터페이스, 사용자 상호작용 및 서브프로세스 조정을 관리하며, 저장 기능을 제공합니다. 이는 다른 프로세스를 조정하는 \\\"스케줄러\\\"로 작용하여, 예를 들어 URL을 입력할 때 네트워크 프로세스를 호출합니다. 렌더링 프로세스는 HTML, CSS 및 JavaScript를 대화형 웹 페이지로 변환하고 V8 엔진을 실행합니다. 보안상의 이유로 Chrome은 각 탭에 대해 별도의 렌더링 프로세스를 샌드박스 모드로 생성합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"GPU 프로세스는 초기에 3D CSS 효과를 위해 설계되었지만 나중에 웹 페이지 및 Chrome UI 인터페이스를 그리는 데 확장되었습니다. 공통 브라우저 요구 사항을 충족하기 위해 Chrome의 다중 프로세스 아키텍처에 소개되었습니다. 네트워크 프로세스는 페이지 네트워크 리소스를 독립적으로 로드하며, 원래 브라우저 프로세스 내의 모듈이었지만 지금은 별도의 프로세스로 실행됩니다. 플러그인 프로세스는 플러그인을 관리하여 브라우저 및 페이지에 플러그인의 내재적 불안정성으로 인한 충돌을 방지합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"현대적인 브라우저 아키텍처는 아래 다이어그램에서 보실 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-12-ThePastandPresentofBrowserArchitecture_4.png\",\n        alt: \"Diagram\"\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"2. 브라우저 페이지 열리는 과정\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"탭 추가는 기본 프로세스 생성을 시작합니다: 시스템 브라우저, 렌더링, GPU 및 네트워크 프로세스.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"사용자 입력은 브라우저 프로세스를 활성화하여 프로토콜을 확인하고 완전한 URL을 구성합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"브라우저 프로세스는 URL 요청을 네트워크 프로세스로 보냅니다. 여기서 인터프로세스 통신이 이루어집니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"네트워크 프로세스는 요청된 리소스를 로컬 캐시에서 확인합니다. 캐시에서 찾을 경우 브라우저 프로세스로 반환합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"캐시에 없는 경우, 네트워크 프로세스는 웹 서버로 HTTP 요청을 보냅니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"네트워크 프로세스는 응답을 구문 분석하고 상태 코드를 확인합니다. 비-200 상태 코드는 특정 처리 논리를 유도합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"200 응답의 경우, 브라우저 프로세스는 Content-Type을 확인합니다. 바이트 스트림은 다운로드 관리자를 활성화하고 HTML은 렌더링 준비를 신호로 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"브라우저 프로세스는 현재 URL이 기존 렌더링 프로세스의 루트 도메인과 일치하는지 확인합니다. 다를 경우, 새로운 렌더링 프로세스를 시작합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"브라우저는 네트워크 프로세스와 데이터 전송 파이프라인을 설정하기 위해 렌더링 프로세스에 \\\"문서 제출\\\" 메시지를 보냅니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"데이터 수신 후, 렌더링 프로세스는 브라우저로 확인을 보냅니다. 브라우저는 보안 표시기, 주소 표시줄 URL, 브라우징 기록 및 웹페이지 컨텐츠를 업데이트합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"3. 렌더링 프로세스\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"현대 브라우저는 성능을 우선시하는 방법으로 레이지 로딩 및 캐싱 같은 전략을 사용합니다. 브라우저는 렌더링 프로세스를 통해 웹 콘텐츠를 표시합니다. 핵심 단계는 HTML 구문 분석, CSS 스타일링, 레이아웃 생성 및 그리기가 되며, 구체적인 단계는 다음과 같습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"사용자 입력 — 브라우저 주소 표시줄에 URL을 입력하세요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"URL 구문 분석 — URL을 구문 분석하여 프로토콜, 호스트, 포트 및 경로를 식별합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"DNS 조회 — 호스트 이름을 IP 주소로 변환하기 위해 DNS 조회를 수행합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"소켓 연결 — 사용자와 서버 IP 간의 연결 설정.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"HTTP 요청 — 프로토콜을 지정하는 HTTP 요청을 서버로 보냅니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"서버 처리 — 서버는 요청을 평가하고 처리 플러그인(예: PHP, Java)을 결정합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"플러그인을 통한 처리 — HTTP 응답의 일부로 데이터베이스 또는 다른 리소스에 액세스합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"브라우저 응답 — HTTP 응답을 브라우저로 다시 보냅니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"응답 분석 — 브라우저에서 응답의 HTML 데이터를 분석합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"DOM 트리 생성 — 구문 분석된 HTML에서 문서 객체 모델(DOM) 트리를 구성합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"스타일시트 구문 분석 — 프레젠테이션 데이터를 DOM 노드에 연결하는 스타일시트를 구문 분석합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"JavaScript 실행 — DOM 요소를 수정하기 위해 JavaScript 코드를 실행합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"페이지 렌더링 — DOM 및 스타일 데이터를 사용하여 웹 페이지를 표시합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3.1 HTML 구문 분석\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"브라우저가 HTML을 문자 단위로 읽어 요소, 속성 및 텍스트를 식별한 후, 웹 페이지의 구조를 표현하는 DOM 트리를 구성하여 HTML 코드가 올바르게 표시되도록 합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3.2 CSS Object Model\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"CSS Object Model는 HTML 요소에 적용된 스타일을 표현하며, DOM 트리의 구조적 계층과 유사하게 특정성과 스타일의 캐스캐이딩 성질을 고려하여 스타일에 대한 접근, 조작 및 계산을 허용합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3.3 레이아웃 관리자\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"레이아웃 관리자는 DOM과 CSS object model을 결합하여 렌더링 트리를 형성하고, 내용, 패딩 등을 기반으로 상자의 크기를 결정하며, 특정 위치를 구축하는 데 다양한 메소드를 사용합니다. 동시에 겹치는 요소를 처리하기 위해 쌓임 맥락과 Z-인덱스를 사용하고, 배치 변경을 최적화하기 위해 일괄 처리 기술을 사용합니다. 마지막으로 화면에 요소가 그려지고 사용자 상호작용 중에 지속적으로 업데이트됩니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"4 플러그인 메커니즘\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4.1 플러그인 개발 역사\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"플러그인 메커니즘의 개발 과정은 다음과 같습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"2012년 8월 — 매니페스트 V1: Chrome 플러그인은 처음에 매니페스트 V1을 기반으로 했으며, 기본 기능 및 권한을 정의했습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2013년 4월 — Chrome26 안정 버전: 매니페스트 V1 플러그인 지원이 포함되었습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2014년 5월 — Chrome35 안정 버전: 브라우저의 점진적 업데이트가 계속해서 ManifestV1 플러그인을 지원했습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2014년 9월 — Chrome 37 안정 버전: Manifest V1 플러그인을 위한 추가 개선 및 버그 수정이 이루어졌습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2015년 5월 — Chrome43 안정 버전: Manifest V1 계속 지원됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2015년 12월 — Manifest V2 등장: ManifestV2가 도입되어 더 나은 보안 및 추가 기능을 제공했습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2016년 6월 — Chrome51 안정 버전: Manifest V2가 플러그인 개발의 표준이 되었습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2016년 9월 — Chrome53 안정 버전: Manifest V2의 지속적인 개선 및 최적화가 이루어졌습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2019년 1월 — Manifest V3 출시: 보안, 성능 및 개발 유연성에 초점을 맞춥니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2020년 3월 — Chrome80 안정 버전: Manifest V2는 플러그인의 표준이지만, Manifest V3는 테스트용으로 제공되었지만 아직 필수는 아닙니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2021년 3월 — Chrome89 안정 버전: Manifest V2가 여전히 기본이지만 Manifest V3로의 관심이 증가하고 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2021년 10월 — Chrome94 안정 버전: Manifest V3가 일부 기능을 강화하기 시작하며, 이전 버전에서의 이전 가이드 및 도구가 개발자에게 제공됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2022년 3월 — Chrome98 안정 버전: Manifest V3가 새로운 플러그인 버전의 기본이 됩니다. 그러면서 Manifest V2도 계속 지원됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2022년 8월 — Chrome104 안정 버전: 모든 플러그인이 공식적으로 Manifest V3로 전환되어, Manifest V2의 추가 지원이 중단되었습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2023년 3월 — Chrome108 안정 버전: 모든 플러그인이 Manifest V3를 온전히 지원하며, 매끄러운 전환을 보장합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2023년 7월 — Manifest V3 미리보기: 개발자들이 다가오는 변경 사항을 탐색하고 유용한 피드백을 제공할 수 있도록 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2023년 10월 — Chrome Z 안정 버전에서 ManifestV3 지원을 더 개선하며, 미리보기 단계에서 보고된 모든 문제를 해결합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2024년 1월 — Manifest V3 사전 안정 버전 배포: Manifest V3가 안정 상태에 도달하여, 개발자들이 확장 프로그램을 V3로 이전하고 모든 문서 및 이전 가이드가 제공됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"2024년 3월 — Chrome116 안정 버전: Manifest V3를 완전히 지원하며, 개발자들은 플러그인을 최신 표준과 호환되도록 업데이트합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"총적으로, Chrome 익스텐션(또는 애드온)은 3가지 주요 버전인 Manifest V1, Manifest V2 및 Manifest V3의 개발 과정을 거쳤습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Manifest V1 (MV1)은 Chrome 확장 프로그램 매니페스트의 초기 버전이었으며 오래되었습니다. Manifest V2 (MV2)는 현재 Chrome 확장 프로그램에서 널리 사용되는 주요 버전으로, 확장 프로그램을 더 많은 브라우저 기능과 기능으로 구축할 수 있는 견고한 프레임워크를 제공합니다. Manifest V3은 점차 MV2를 대체하는 최신 버전으로, 보안 및 성능 문제에 대응하기 위해 보안 조치를 강화하고 확장 프로그램 개발 시 더 나은 성능을 촉진하는 것을 목표로 합니다. Chrome 127 (2024년 6월)부터 Google은 안정화되지 않은 Chrome 버전에서 Manifest V2 확장 프로그램을 비활성화하기 시작할 예정이며, 개발자들이 MV3로 전환하도록 권장합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4.2 Manifest의 기능 및 버전 이전\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Manifest V2의 기능:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Content-Security-Policy (CSP)를 설정하여 script-src 'self'; object-src 'self';를 사용하여 기본 콘텐츠 보안 정책을 설정합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"플러그인 패키지 리소스는 외부로 더 이상 사용할 수 없으며, 허용 목록은 매니페스트의 web_access_resources 속성을 통해 나열됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"브라우저 작업 API 및 페이지 작업 API에 변경 사항이 있으며, chrome.extension이 플러그인 자체를 가리키는 chrome.self를 대체하고, chrome.tension.getTabContentses는 tension.getView로 대체되고, Port.tab은 runtime.Port로 대체됩니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Manifest V3의 기능:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Manifest V3은 백그라운드 페이지를 대체하는 서비스 워커를 도입했습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"네트워크 요청 수정은 더 이상 사용되지 않는 webRequest API 대신 새로운 선언적 넷 요청 API를 사용합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"원격 코드 실행이 허용되지 않으며, 확장 프로그램 패키지 내의 JS만 실행할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Promises가 많은 메소드에 추가되었고, 콜백은 여전히 지원됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Browser Action API 및 Page Action API가 하나의 액션 API로 통합되었습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"웹 접근 가능한 리소스는 지정된 사이트 및 확장 프로그램으로 제한됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"콘텐츠 보안 정책 (CSP)은 다른 실행 컨텍스트에 대해 별도의 CSP를 지정할 수 있습니다. executeScript는 스크립트 파일과 함수만 실행하고 임의의 문자열은 실행할 수 없습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Manifest V3은 Chrome이 개인 정보 보호, 보안 및 전반적인 확장 프로그램 성능 향상에 대한 약속으로부터 비롯된 V1과 V2로부터의 중요한 전환을 나타냅니다. 이전 버전과는 달리, Manifest V3은 자원 효율성을 우선시하여 Chrome의 과거 높은 자원 사용량에 대한 우려 사항을 해결합니다. 핵심 목표는 확장 프로그램을 통해 시스템 자원 소비를 제한하여 브라우저 성능을 최적화하는 것입니다. 추가 제약 사항을 부과하면서도, Manifest V3은 중요한 이점을 소개합니다. 서비스 워커 기능을 통해 확장 프로그램이 계속해서 백그라운드에 상주하지 않고도 작동할 수 있어, 확장 프로그램 자원을 재활용하고 브라우저 전반적인 오버헤드를 효과적으로 줄일 수 있습니다. 규칙 계산에 대한 제약 사항은 개별 확장 프로그램이 자원을 과도하게 소비하지 않도록 제어 메커니즘으로 작용합니다. 이러한 변경 사항들은 Chrome에서 더 부드러운 브라우징 경험을 제공하며, 향상된 브라우저 효율성에 대한 사용자 기대를 충족합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"V2에서 V3로 이전시, 페이지 배경을 구성하기 위한 background.html이 없다는 이유로 백그라운드.html에서 AJAX 요청을 구성하는 데 윈도우 개체의 XMLHttpRequest를 사용할 수 없습니다. 대신, 데이터를 추출하는 방법을 사용하여 데이터를 검색해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"또한, 서비스 워커의 짧은 수명과 비활성 기간 동안의 종료로 인해 가끔 발생하는 시작, 실행 및 종료로 플러그인 수명주기 동안 불안정성이 발생합니다. MV2에서는 전역 변수가 데이터 저장에 직접 사용되었으므로 이러한 상황 하에서 안정성과 기능성을 향상시키기 위해 backound.js 로직을 수정해야 합니다. 또한 webRequest API에서 statativeNetRequest API로 전환하면 상당한 코드 리팩터링이 필요합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4.3 Chrome 확장 프로그램의 주요 구성 요소\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"4.3.1 매니페스트 파일\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"매니페스트.json 파일은 루트 디렉토리에 위치한 Chrome 확장 프로그램에 매우 중요합니다. 이 파일을 통해 Manif_version, 이름, 버전과 같은 기본 매개변수를 포함하여 모든 플러그인 설정을 구성합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Manifest V2의 예시는 다음과 같습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"manifest_version\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 플러그인 이름\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 플러그인 버전\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"version\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1.0.0\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 플러그인 설명\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"description\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"icons\\\"\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"16\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"img/icon16.png\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"48\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"img/icon48.png\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"128\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"img/icon128.png\\\"\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 브라우저의 백그라운드 JS 또는 백그라운드 페이지\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"background\\\"\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"scripts\\\"\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"js/background.js\\\"\"\n        }), \"]\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 브라우저 아이콘 설정: browser_action, page_action, app\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"browser_action\\\"\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"default_icon\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"img/icon.png\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"default_title\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"default_popup\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"popup.html\\\"\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 특정 페이지가 열릴 때에만 표시되는 아이콘\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"page_action\\\"\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"default_icon\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"img/icon.png\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"default_title\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"default_popup\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"popup.html\\\"\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 페이지에 직접 주입되는 JS\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content_scripts\\\"\"\n        }), \": [{\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"matches\\\"\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\u003call_urls\u003e\\\"\"\n        }), \"],\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"js\\\"\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"js/content-script.js\\\"\"\n        }), \"],\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"css\\\"\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"css/custom.css\\\"\"\n        }), \"],\\n    \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 코드 주입 시기, 기본값은 document_idle\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"run_at\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"document_start\\\"\"\n        }), \"\\n  }],\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 요청되는 권한\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"permissions\\\"\"\n        }), \": [\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"contextMenus\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 우클릭 메뉴\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"tabs\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 탭\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"notifications\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 알림\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"webRequest\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 웹 요청\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"webRequestBlocking\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"storage\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 플러그인 로컬 저장소\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://*/*\\\"\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// executeScript 또는 insertCSS를 통해 접근 가능한 웹 사이트\"\n        }), \"\\n  ],\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 일반 페이지에서 직접 액세스할 수있는 플러그인 자원 목록  \\\"web_accessible_resources\\\": [\\\"js/inject.js\\\"],\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"homepage_url\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 플러그인 홈페이지\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"chrome_url_overrides\\\"\"\n        }), \": { \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 브라우저 기본 페이지 재정의\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"newtab\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"newtab.html\\\"\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"options_ui\\\"\"\n        }), \": { \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 플러그인 옵션 페이지\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"page\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"options.html\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"chrome_style\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"omnibox\\\"\"\n        }), \": { \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"keyword\\\"\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \" }, \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 검색 제안을위한 주소 표시줄에 키워드 등록, 하나의 키워드 만 설정 가능\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"default_locale\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"en\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 기본 언어\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"devtools_page\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"devtools.html\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Devtools 페이지 진입점, HTML 파일만 지정 가능    \\\"content_security_policy\\\": \\\"...\\\", // 보안 정책\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"web_accessible_resources\\\"\"\n        }), \": [ \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 로드 가능한 리소스\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"RESOURCE_PATHS\\\"\"\n        }), \"\\n  ]\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Manifest V3의 예시는 다음과 같습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"manifest_version\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \", \\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"version\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1.0.0\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"description\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \", \\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"icons\\\"\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"16\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"img/icon16.png\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"48\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"img/icon48.png\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"128\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"img/icon128.png\\\"\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"background\\\"\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"service_worker\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"js/background.js\\\"\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"action\\\"\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"default_icon\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"img/icon.png\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"default_title\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \", \\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"default_popup\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"popup.html\\\"\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content_security_policy\\\"\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"extension_pages\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"sandbox\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"web_accessible_resources\\\"\"\n        }), \": [\\n    {\\n      \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"resources\\\"\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"RESOURCE_PATHS\\\"\"\n        }), \"]\\n    }\\n  ],\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"permissions\\\"\"\n        }), \": [\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"contextMenus\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"tabs\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"notifications\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"webRequest\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"webRequestBlocking\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"storage\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://*/*\\\"\"\n        }), \"\\n  ],\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"web_accessible_resources\\\"\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"js/inject.js\\\"\"\n        }), \"],\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"homepage_url\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \", \\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"chrome_url_overrides\\\"\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"newtab\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"newtab.html\\\"\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"options_ui\\\"\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"page\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"options.html\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"chrome_style\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"omnibox\\\"\"\n        }), \": {\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"keyword\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \"\\n  },\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"default_locale\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"zh_CN\\\"\"\n        }), \", \\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"devtools_page\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"devtools.html\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"content_security_policy\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"...\\\"\"\n        }), \",\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"web_accessible_resources\\\"\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"RESOURCE_PATHS\\\"\"\n        }), \"]\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"4.3.2 콘텐츠 스크립트\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"크롬 익스텐션의 콘텐츠 스크립트는 구성을 통해 지정된 페이지에 JS 및 CSS를 삽입합니다. 그들은 원래 페이지와 DOM을 공유하지만 JavaScript는 공유하지 않습니다. 페이지 JS 변수에 액세스하려면 JS를 삽입해야 합니다. 콘텐츠 스크립트는 다음을 제외한 대부분의 Chrome API에 액세스할 수 없습니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"chrome. extension\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"chrome.i18n\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"chrome. runtime\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"chrome.storage\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다른 API의 경우, 통신은 백그라운드 또는 서비스 워커를 통해 수행되어야 합니다.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.3.3 배경 스크립트\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"크롬 확장프로그램의 배경 스크립트는 수명이 가장 길며 브라우저가 열려 있는 동안 계속 실행됩니다. 이들은 광범위한 권한을 가지고 있어 대부분의 크롬 확장프로그램 API에 액세스하고 CORS 제한 없이 교차 출처 요청을 할 수 있습니다. Manifest V3에서 배경 페이지는 수명이 짧고 이벤트 기반으로 실행되는 서비스 워커로 대체되어 글로벌 변수를 저장하기에 적합하지 않습니다.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.3.4 팝업 창\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"팝업 창은 웹페이지의 작은 창으로, 오른쪽 상단의 아이콘을 클릭하면 나타납니다. 사용자가 웹페이지 외부에서 상호 작용하면 빠르게 닫힙니다. 일시적 상호작용에 사용되며 배경과 유사한 권한 수준을 가지지만 수명은 짧습니다.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"4.3.5 스크립트 삽입\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"크롬 확장 프로그램 개발 중 개발자들이 \\\"스크립트 삽입\\\"이라는 용어를 만들었습니다. 이 용어는 DOM 조작을 통해 페이지에 주입된 JavaScript를 가리킵니다. 콘텐츠 스크립트는 DOM을 조작할 수 있지만 액세스 제한으로 인해 직접 액세스할 수 없습니다. 이 제한은 특히 이벤트 바인딩에서 잘 나타납니다. 웹 페이지에서 플러그인을 실행하는 버튼을 추가하는 일반적인 요구 사항을 충족하기 위해 개발자들은 스크립트 삽입 방식을 채택했습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4.4 크롬 확장 프로그램의 통신 메커니즘\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"크롬 확장 프로그램에서 통신은 다섯 가지 유형의 스크립트에 의존합니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"인젝션 스크립트는 보통 window.postMessage에 의존하는 웹페이지에 동적으로 삽입되는 스크립트를 나타냅니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"컨텐츠 스크립트는 특정 웹페이지 컨텍스트에서 실행되는 스크립트로, window.postMessage, chrome.runtime.sendMessage 및 chrome.runtime.connect를 사용하여 스크립트 간 통신을 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"팝업 스크립트는 플러그인 팝업 인터페이스와 관련되며, 일반적으로 통신을 위해 chrome.tabs.sendMessage 및 chrome.tabs.connect를 사용합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"백그라운드 스크립트는 다양한 방법을 활용하며 백그라운드에서 독립적으로 실행되는 스크립트이며, \\\"chrome.tabs.sendMessage\\\", chrome.tabs.connect, chrome.extension.getBackgroundPage 및 chrome.extension.getViews 등의 메서드를 사용합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"개발 도구는 chrome.devtools.inspectedWindow.eval 및 chrome.runtime.sendMessage과 같은 특정 API를 사용하여 상호 작용하는 개발 도구의 추가 기능을 제공합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"각 스크립트에는 통신의 중요성을 강조하는 다른 권한이 있습니다. 이 상호 작용은 포괄적인 플러그인 기능을 활성화하는 데 중요합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"과거를 되짚어 새로운 것을 배우는 것은, 현대 인터넷의 기반인 브라우저 아키텍처가 다중 반복과 혁신을 거쳐 사용자와 웹 콘텐츠 간의 다리로서 항상 역할하고 있다는 것을 생각해봅니다. 초기에는 단일 렌더링 엔진부터 오늘날의 멀티 프로세스, 멀티 스레드 아키텍쳐까지, 각 변화는 더 스무스하고 안전한 브라우징 경험을 가져왔습니다. 앞으로 브라우저 아키텍처는 성능 최적화와 보안 강화를 더욱 심화시켜 사용자에게 더 나은 웹 브라우징 경험을 제공하기 위해 발전할 것입니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-ThePastandPresentofBrowserArchitecture"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>