<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트에서 데이터 가져오기 마스터하기 useFetchCache 소개 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트에서 데이터 가져오기 마스터하기 useFetchCache 소개 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트에서 데이터 가져오기 마스터하기 useFetchCache 소개 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache" data-gatsby-head="true"/><meta name="twitter:title" content="리액트에서 데이터 가져오기 마스터하기 useFetchCache 소개 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-12 19:02" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_buildManifest.js" defer=""></script><script src="/_next/static/7rKODeu6chWTLgXf6auoL/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트에서 데이터 가져오기 마스터하기 useFetchCache 소개</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트에서 데이터 가져오기 마스터하기 useFetchCache 소개" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 12, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><h1>TL;DR</h1>
<p>useFetchCache 훅은 React 애플리케이션의 데이터 가져오기, 캐싱 및 업데이트를 간단하게 만들기 위해 설계된 사용자 정의 훅입니다. 네트워크 요청을 로컬 캐싱과 원활하게 통합함으로써, 빈번한 액세스가 필요하지만 자주 변경되지 않는 데이터를 처리하는 효율적인 방법을 제공합니다.</p>
<h2>React 컴포넌트에서 같은 데이터를 계속해서 가져오는 것에 지쳤습니까?</h2>
<p>useFetchCache를 만나보세요! 데이터 가져오기와 캐싱의 슈퍼히어로! 🦸‍♂️</p>
<p>useFetchCache는 데이터 가져오기를 간편하게 만들어 주는 커스텀 React 훅이에요. 개인 비서처럼 작동하여 필요한 모든 것을 기억해 주어서 매번 요청할 필요가 없어요. 반복적인 데이터 가져오기 로직 작성이나 여러 개의 로딩 및 오류 상태를 처리하는 번거로움도 없어요. 😌</p>
<p>useFetchCache를 사용하면 API URL과 필요한 매개변수를 제공하고, 후는 모두 맡기면 돼요. 데이터를 가져오고 로딩 상태를 처리하며, AsyncStorage를 사용하여 결과를 로컬로 캐싱해요. 이렇게 하면 같은 데이터에 대한 후속 요청은 캐시에서 제공되어 네트워크 트래픽을 줄이고 성능을 향상시킬 수 있어요. ⚡</p>
<p>하지만 여기서 끝이 아니에요! useFetchCache에는 다시 불러오는 함수가 제공되어 데이터를 필요할 때마다 새롭게 불러올 수 있어요. 사용자 상호작용이나 주기적인 업데이트 때문이더라도 useFetchCache가 항상 도와줄 거예요. 🔄</p>
<p>그러니 React 컴포넌트를 강화하고 데이터 가져오기 프로세스를 간소화하려면 useFetchCache가 여러분의 새로운 친구가 될 거에요. 이 슈퍼히어로 훅으로 무거운 작업을 처리하고 사용자들을 위한 놀라운 경험을 만드는 데 집중할 수 있도록 해 주세요. 💯</p>
<p>useFetchCache를 통해 매끄러운 데이터 가져오기와 캐싱의 마법을 경험할 준비가 되셨나요? 🚀✨</p>
<h2>useFetchCache란?</h2>
<p>useFetchCache는 API에서 데이터를 가져오는 과정을 자동화하고, 그 데이터를 로컬 저장소(AsyncStorage 사용)에 저장하며, 이후 요청에서 해당 데이터를 불러오는 React의 커스텀 훅입니다. 이 훅은 데이터 가져오기, 캐싱, 오류 관리를 처리하고, 강제 데이터 새로고침을 허용합니다.</p>
<h2>useFetchCache 사용의 장점</h2>
<ul>
<li>네트워크 호출 감소: 데이터를 로컬로 캐싱함으로써 애플리케이션에서 만드는 API 요청 수가 줄어들어 모바일 데이터 사용 및 제한적이거나 고비용의 연결 환경에서 특히 유용합니다.</li>
<li>성능 향상: 데이터를 로컬로 캐싱하면 데이터 검색 시간이 빨라지며, 데이터가 대부분 로컬 저장소에서 즉시 사용 가능하기 때문에 서버로의 왕복을 필요로하지 않습니다.</li>
<li>사용자 경험 향상: 사용자들은 빠른 로드 시간과 더 빠른 반응이 가능한 인터페이스를 경험할 수 있으며, 데이터가 빠른 액세스 로컬 캐시에서 로드되기 때문입니다.</li>
<li>간편화된 데이터 관리: 훅은 데이터 가져오기, 캐싱 및 오류 처리를 캡슐화하여 구성 요소 코드를 단순화합니다.</li>
</ul>
<h1>useFetchCache 사용 방법</h1>
<ul>
<li>훅 가져오기: React 컴포넌트 파일에 useFetchCache를 가져와서 시작합니다.</li>
<li>훅 초기화: 필요한 매개변수(API URL 및 선택적으로 기본 캐시 키 및 만료 시간)를 사용하여 useFetchCache를 호출합니다. 특정 키가 제공되지 않으면 URL도 캐시 키로 사용할 수 있습니다.</li>
<li>데이터 표시: 훅이 반환하는 데이터 상태를 사용하여 컴포넌트에서 데이터를 표시합니다. 사용자에게 피드백을 제공하기 위해 필요한대로 로딩 상태 및 오류를 처리하세요.</li>
<li>새로 고침 및 페이지네이션 구현: 필요한 경우 신선한 데이터가 필요한 시나리오에 대비해 훅이 제공하는 refetch 메서드를 사용하고, API에서 지원하는 경우 API URL 또는 내부 상태를 조정하여 페이지네이션을 관리하세요.</li>
<li>코드 배치: 훅은 컴포넌트 함수 상단에 배치되어야 하며, 조건문이나 반복문 외부에 위치하여 훅의 규칙을 준수해야 합니다.</li>
</ul>
<h2>이것이 바로 훅입니다…</h2>
<pre><code class="hljs language-js"><span class="hljs-comment">// useFetchCache.js</span>

<span class="hljs-keyword">import</span> { useState, useEffect, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">AsyncStorage</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@react-native-async-storage/async-storage&#x27;</span>;
<span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;

<span class="hljs-comment">/**
 * AsyncStorage를 사용하여 데이터를 가져와 캐싱하는 커스텀 훅입니다. 옵션으로 강제 새로고침이 가능합니다.
 * 
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">url</span> - 데이터를 가져올 API URL입니다.
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} [baseCacheKey=null] - 데이터를 저장하는 기본 캐시 키입니다. 제공되지 않으면 URL이 기본값으로 사용됩니다.
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} [expirationTime=3600000] - 캐시 만료까지의 밀리초 단위 시간입니다 (기본값은 1시간).
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">Object</span>} 데이터, 로딩 상태, 오류 및 리페치 함수를 포함한 객체입니다.
 */</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">useFetchCache</span> = (<span class="hljs-params">url, baseCacheKey = <span class="hljs-literal">null</span>, expirationTime = <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span></span>) =&gt; {
  <span class="hljs-comment">// 제공된 baseCacheKey 또는 URL을 사용하여 캐시 키를 구성합니다.</span>
  <span class="hljs-keyword">const</span> cacheKey = <span class="hljs-string">`<span class="hljs-subst">${baseCacheKey ? baseCacheKey : <span class="hljs-built_in">encodeURIComponent</span>(url)}</span>`</span>;

  <span class="hljs-comment">// 데이터, 로딩 상태, 오류를 관리하는 상태 훅입니다.</span>
  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> [isLoading, setIsLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">const</span> [error, setError] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// 데이터를 가져오는 함수로, 옵션으로 캐시를 무시할 수 있습니다.</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">forceFetch = <span class="hljs-literal">false</span></span>) =&gt; {
    <span class="hljs-title function_">setIsLoading</span>(<span class="hljs-literal">true</span>);
    <span class="hljs-title function_">setError</span>(<span class="hljs-literal">null</span>);

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> storedDataString = <span class="hljs-keyword">await</span> <span class="hljs-title class_">AsyncStorage</span>.<span class="hljs-title function_">getItem</span>(cacheKey);

      <span class="hljs-comment">// 강제 새로고침하지 않고 캐시가 있고 유효한 경우 캐시된 데이터를 사용합니다.</span>
      <span class="hljs-keyword">if</span> (!forceFetch &amp;&amp; storedDataString) {
        <span class="hljs-keyword">const</span> storedData = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(storedDataString);
        <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
        <span class="hljs-keyword">if</span> (now - storedData.<span class="hljs-property">timestamp</span> &lt; expirationTime) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;캐시로부터 데이터를 제공합니다 for key:&quot;</span>, cacheKey);
          <span class="hljs-title function_">setData</span>(storedData.<span class="hljs-property">data</span>);
          <span class="hljs-keyword">return</span>;
        }
      }

      <span class="hljs-comment">// 강제 새로고침이거나 캐시가 만료된 경우 또는 캐시가 없는 경우 API에서 데이터를 가져옵니다.</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;API로부터 데이터를 가져옵니다 for URL:&quot;</span>, url);
      <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(url);
      <span class="hljs-keyword">const</span> newData = response.<span class="hljs-property">data</span>;
      <span class="hljs-title function_">setData</span>(newData);
      <span class="hljs-keyword">await</span> <span class="hljs-title class_">AsyncStorage</span>.<span class="hljs-title function_">setItem</span>(cacheKey, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
        <span class="hljs-attr">data</span>: newData,
        <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),
      }));
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;데이터를 가져오는 중 오류가 발생했습니다:&quot;</span>, err);
      <span class="hljs-title function_">setError</span>(err);
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-title function_">setIsLoading</span>(<span class="hljs-literal">false</span>);
    }
  };

  <span class="hljs-comment">// 캐시를 무시하여 데이터를 강제로 다시 가져오는 함수입니다.</span>
  <span class="hljs-keyword">const</span> refetch = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;캐시를 무시하고 데이터를 다시 가져옵니다...&quot;</span>);
    <span class="hljs-title function_">fetchData</span>(<span class="hljs-literal">true</span>);
  }, [url, cacheKey]);

  <span class="hljs-comment">// URL이나 cacheKey가 변경될 때 데이터를 가져오는 효과입니다.</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">fetchData</span>();
  }, [url, cacheKey]);

  <span class="hljs-keyword">return</span> { data, isLoading, error, refetch };
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useFetchCache;
</code></pre>
<h2>그리고 여기에 샘플 사용법이 있습니다...</h2>
<pre><code class="hljs language-js"><span class="hljs-comment">// DataFetchingComponent.js </span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">View</span>, <span class="hljs-title class_">Text</span>, <span class="hljs-title class_">ActivityIndicator</span>, <span class="hljs-title class_">Button</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-native&#x27;</span>;
<span class="hljs-keyword">import</span> useFetchCache <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./useFetchCache&#x27;</span>; <span class="hljs-comment">// useFetchCache가 정의된 파일로 올바르게 지정하세요.</span>

<span class="hljs-keyword">const</span> <span class="hljs-title function_">DataFetchingComponent</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-comment">// 데이터를 가져올 URL입니다.</span>
  <span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;https://api.example.com/data&quot;</span>;

  <span class="hljs-comment">// URL을 사용하여 훅을 초기화합니다. baseCacheKey를 제공하지 않으면 URL이 자동으로 캐시 키로 사용됩니다.</span>
  <span class="hljs-keyword">const</span> { data, isLoading, error, refetch } = <span class="hljs-title function_">useFetchCache</span>(url);

  <span class="hljs-comment">// 사용자가 &quot;새로고침&quot; 버튼을 누를 때 새로 고침 동작을 처리합니다.</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleRefresh</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-title function_">refetch</span>(); <span class="hljs-comment">// 훅에서 제공하는 refetch 함수를 호출하여 데이터를 강제로 다시 가져옵니다.</span>
  };

  <span class="hljs-comment">// 데이터를 가져오는 동안 로딩 표시줄을 렌더링합니다.</span>
  <span class="hljs-keyword">if</span> (isLoading) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ActivityIndicator</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;large&quot;</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;#0000ff&quot;</span> /&gt;</span></span>;

  <span class="hljs-comment">// 데이터를 가져오는 동안 오류가 발생하면 오류 메시지를 렌더링합니다.</span>
  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Error: {error.toString()}<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span></span>;

  <span class="hljs-comment">// 가져온 데이터 또는 가져온 데이터가 없을 경우 메시지를 렌더링합니다.</span>
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">flex:</span> <span class="hljs-attr">1</span>, <span class="hljs-attr">justifyContent:</span> &#x27;<span class="hljs-attr">center</span>&#x27;, <span class="hljs-attr">alignItems:</span> &#x27;<span class="hljs-attr">center</span>&#x27; }}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Data: {data ? JSON.stringify(data) : &#x27;데이터 없음&#x27;}<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;데이터 새로고침&quot;</span> <span class="hljs-attr">onPress</span>=<span class="hljs-string">{handleRefresh}</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;#0000ff&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DataFetchingComponent</span>;
</code></pre>
<h1>주요 내용```</h1>
<ul>
<li>일관성이 중요합니다: 항상 동일한 데이터 집합에 대해 동일한 캐시 키를 사용하여 응용 프로그램 전체의 일관성을 보장하세요.</li>
<li>오류 처리를 세련되게: 데이터 가져오기에서 발생하는 오류를 세련되게 처리하여 사용자 경험을 개선하세요.</li>
<li>캐시 정기적으로 업데이트: 캐시된 데이터에 적절한 만료 시간을 설정하고 주기적으로 또는 사용자 요구에 따라 캐시를 업데이트하는 refetch 함수를 사용하세요.</li>
</ul>
<h1>결론</h1>
<p>React 애플리케이션에서 useFetchCache 훅을 사용하면 데이터 처리를 최적화할 수 있습니다. 반복적이고 비용 소모적인 네트워크 요청이 줄어들며 데이터 로드 시간을 단축하고 구성 요소에서의 데이터 관리를 간단하게 할 수 있습니다. 이 훅을 통합함으로써 개발자들은 좋은 기능을 개발하는 데 더 집중할 수 있고 데이터 가져오기와 상태 관리의 복잡성에 대해 덜 걱정해도 됩니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트에서 데이터 가져오기 마스터하기 useFetchCache 소개","description":"","date":"2024-05-12 19:02","slug":"2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache","content":"\n\n# TL;DR\n\nuseFetchCache 훅은 React 애플리케이션의 데이터 가져오기, 캐싱 및 업데이트를 간단하게 만들기 위해 설계된 사용자 정의 훅입니다. 네트워크 요청을 로컬 캐싱과 원활하게 통합함으로써, 빈번한 액세스가 필요하지만 자주 변경되지 않는 데이터를 처리하는 효율적인 방법을 제공합니다.\n\n## React 컴포넌트에서 같은 데이터를 계속해서 가져오는 것에 지쳤습니까?\n\nuseFetchCache를 만나보세요! 데이터 가져오기와 캐싱의 슈퍼히어로! 🦸‍♂️\n\n\n\nuseFetchCache는 데이터 가져오기를 간편하게 만들어 주는 커스텀 React 훅이에요. 개인 비서처럼 작동하여 필요한 모든 것을 기억해 주어서 매번 요청할 필요가 없어요. 반복적인 데이터 가져오기 로직 작성이나 여러 개의 로딩 및 오류 상태를 처리하는 번거로움도 없어요. 😌\n\nuseFetchCache를 사용하면 API URL과 필요한 매개변수를 제공하고, 후는 모두 맡기면 돼요. 데이터를 가져오고 로딩 상태를 처리하며, AsyncStorage를 사용하여 결과를 로컬로 캐싱해요. 이렇게 하면 같은 데이터에 대한 후속 요청은 캐시에서 제공되어 네트워크 트래픽을 줄이고 성능을 향상시킬 수 있어요. ⚡\n\n하지만 여기서 끝이 아니에요! useFetchCache에는 다시 불러오는 함수가 제공되어 데이터를 필요할 때마다 새롭게 불러올 수 있어요. 사용자 상호작용이나 주기적인 업데이트 때문이더라도 useFetchCache가 항상 도와줄 거예요. 🔄\n\n그러니 React 컴포넌트를 강화하고 데이터 가져오기 프로세스를 간소화하려면 useFetchCache가 여러분의 새로운 친구가 될 거에요. 이 슈퍼히어로 훅으로 무거운 작업을 처리하고 사용자들을 위한 놀라운 경험을 만드는 데 집중할 수 있도록 해 주세요. 💯\n\n\n\nuseFetchCache를 통해 매끄러운 데이터 가져오기와 캐싱의 마법을 경험할 준비가 되셨나요? 🚀✨\n\n## useFetchCache란?\n\nuseFetchCache는 API에서 데이터를 가져오는 과정을 자동화하고, 그 데이터를 로컬 저장소(AsyncStorage 사용)에 저장하며, 이후 요청에서 해당 데이터를 불러오는 React의 커스텀 훅입니다. 이 훅은 데이터 가져오기, 캐싱, 오류 관리를 처리하고, 강제 데이터 새로고침을 허용합니다.\n\n## useFetchCache 사용의 장점\n\n\n\n- 네트워크 호출 감소: 데이터를 로컬로 캐싱함으로써 애플리케이션에서 만드는 API 요청 수가 줄어들어 모바일 데이터 사용 및 제한적이거나 고비용의 연결 환경에서 특히 유용합니다.\n- 성능 향상: 데이터를 로컬로 캐싱하면 데이터 검색 시간이 빨라지며, 데이터가 대부분 로컬 저장소에서 즉시 사용 가능하기 때문에 서버로의 왕복을 필요로하지 않습니다.\n- 사용자 경험 향상: 사용자들은 빠른 로드 시간과 더 빠른 반응이 가능한 인터페이스를 경험할 수 있으며, 데이터가 빠른 액세스 로컬 캐시에서 로드되기 때문입니다.\n- 간편화된 데이터 관리: 훅은 데이터 가져오기, 캐싱 및 오류 처리를 캡슐화하여 구성 요소 코드를 단순화합니다.\n\n# useFetchCache 사용 방법\n\n- 훅 가져오기: React 컴포넌트 파일에 useFetchCache를 가져와서 시작합니다.\n- 훅 초기화: 필요한 매개변수(API URL 및 선택적으로 기본 캐시 키 및 만료 시간)를 사용하여 useFetchCache를 호출합니다. 특정 키가 제공되지 않으면 URL도 캐시 키로 사용할 수 있습니다.\n- 데이터 표시: 훅이 반환하는 데이터 상태를 사용하여 컴포넌트에서 데이터를 표시합니다. 사용자에게 피드백을 제공하기 위해 필요한대로 로딩 상태 및 오류를 처리하세요.\n- 새로 고침 및 페이지네이션 구현: 필요한 경우 신선한 데이터가 필요한 시나리오에 대비해 훅이 제공하는 refetch 메서드를 사용하고, API에서 지원하는 경우 API URL 또는 내부 상태를 조정하여 페이지네이션을 관리하세요.\n- 코드 배치: 훅은 컴포넌트 함수 상단에 배치되어야 하며, 조건문이나 반복문 외부에 위치하여 훅의 규칙을 준수해야 합니다.\n\n## 이것이 바로 훅입니다…\n\n\n\n```js\n// useFetchCache.js\n\nimport { useState, useEffect, useCallback } from 'react';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\nimport axios from 'axios';\n\n/**\n * AsyncStorage를 사용하여 데이터를 가져와 캐싱하는 커스텀 훅입니다. 옵션으로 강제 새로고침이 가능합니다.\n * \n * @param {string} url - 데이터를 가져올 API URL입니다.\n * @param {string} [baseCacheKey=null] - 데이터를 저장하는 기본 캐시 키입니다. 제공되지 않으면 URL이 기본값으로 사용됩니다.\n * @param {number} [expirationTime=3600000] - 캐시 만료까지의 밀리초 단위 시간입니다 (기본값은 1시간).\n * @return {Object} 데이터, 로딩 상태, 오류 및 리페치 함수를 포함한 객체입니다.\n */\nconst useFetchCache = (url, baseCacheKey = null, expirationTime = 1000 * 60 * 60) =\u003e {\n  // 제공된 baseCacheKey 또는 URL을 사용하여 캐시 키를 구성합니다.\n  const cacheKey = `${baseCacheKey ? baseCacheKey : encodeURIComponent(url)}`;\n\n  // 데이터, 로딩 상태, 오류를 관리하는 상태 훅입니다.\n  const [data, setData] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // 데이터를 가져오는 함수로, 옵션으로 캐시를 무시할 수 있습니다.\n  const fetchData = async (forceFetch = false) =\u003e {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const storedDataString = await AsyncStorage.getItem(cacheKey);\n\n      // 강제 새로고침하지 않고 캐시가 있고 유효한 경우 캐시된 데이터를 사용합니다.\n      if (!forceFetch \u0026\u0026 storedDataString) {\n        const storedData = JSON.parse(storedDataString);\n        const now = Date.now();\n        if (now - storedData.timestamp \u003c expirationTime) {\n          console.log(\"캐시로부터 데이터를 제공합니다 for key:\", cacheKey);\n          setData(storedData.data);\n          return;\n        }\n      }\n\n      // 강제 새로고침이거나 캐시가 만료된 경우 또는 캐시가 없는 경우 API에서 데이터를 가져옵니다.\n      console.log(\"API로부터 데이터를 가져옵니다 for URL:\", url);\n      const response = await axios.get(url);\n      const newData = response.data;\n      setData(newData);\n      await AsyncStorage.setItem(cacheKey, JSON.stringify({\n        data: newData,\n        timestamp: Date.now(),\n      }));\n    } catch (err) {\n      console.error(\"데이터를 가져오는 중 오류가 발생했습니다:\", err);\n      setError(err);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // 캐시를 무시하여 데이터를 강제로 다시 가져오는 함수입니다.\n  const refetch = useCallback(() =\u003e {\n    console.log(\"캐시를 무시하고 데이터를 다시 가져옵니다...\");\n    fetchData(true);\n  }, [url, cacheKey]);\n\n  // URL이나 cacheKey가 변경될 때 데이터를 가져오는 효과입니다.\n  useEffect(() =\u003e {\n    fetchData();\n  }, [url, cacheKey]);\n\n  return { data, isLoading, error, refetch };\n};\n\nexport default useFetchCache;\n```\n\n## 그리고 여기에 샘플 사용법이 있습니다...\n\n```js\n// DataFetchingComponent.js \n\nimport React from 'react';\nimport { View, Text, ActivityIndicator, Button } from 'react-native';\nimport useFetchCache from './useFetchCache'; // useFetchCache가 정의된 파일로 올바르게 지정하세요.\n\nconst DataFetchingComponent = () =\u003e {\n  // 데이터를 가져올 URL입니다.\n  const url = \"https://api.example.com/data\";\n\n  // URL을 사용하여 훅을 초기화합니다. baseCacheKey를 제공하지 않으면 URL이 자동으로 캐시 키로 사용됩니다.\n  const { data, isLoading, error, refetch } = useFetchCache(url);\n\n  // 사용자가 \"새로고침\" 버튼을 누를 때 새로 고침 동작을 처리합니다.\n  const handleRefresh = () =\u003e {\n    refetch(); // 훅에서 제공하는 refetch 함수를 호출하여 데이터를 강제로 다시 가져옵니다.\n  };\n\n  // 데이터를 가져오는 동안 로딩 표시줄을 렌더링합니다.\n  if (isLoading) return \u003cActivityIndicator size=\"large\" color=\"#0000ff\" /\u003e;\n\n  // 데이터를 가져오는 동안 오류가 발생하면 오류 메시지를 렌더링합니다.\n  if (error) return \u003cText\u003eError: {error.toString()}\u003c/Text\u003e;\n\n  // 가져온 데이터 또는 가져온 데이터가 없을 경우 메시지를 렌더링합니다.\n  return (\n    \u003cView style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}\u003e\n      \u003cText\u003eData: {data ? JSON.stringify(data) : '데이터 없음'}\u003c/Text\u003e\n      \u003cButton title=\"데이터 새로고침\" onPress={handleRefresh} color=\"#0000ff\" /\u003e\n    \u003c/View\u003e\n  );\n};\n\nexport default DataFetchingComponent;\n```\n\n# 주요 내용```\n\n\n\n- 일관성이 중요합니다: 항상 동일한 데이터 집합에 대해 동일한 캐시 키를 사용하여 응용 프로그램 전체의 일관성을 보장하세요.\n- 오류 처리를 세련되게: 데이터 가져오기에서 발생하는 오류를 세련되게 처리하여 사용자 경험을 개선하세요.\n- 캐시 정기적으로 업데이트: 캐시된 데이터에 적절한 만료 시간을 설정하고 주기적으로 또는 사용자 요구에 따라 캐시를 업데이트하는 refetch 함수를 사용하세요.\n\n# 결론\n\nReact 애플리케이션에서 useFetchCache 훅을 사용하면 데이터 처리를 최적화할 수 있습니다. 반복적이고 비용 소모적인 네트워크 요청이 줄어들며 데이터 로드 시간을 단축하고 구성 요소에서의 데이터 관리를 간단하게 할 수 있습니다. 이 훅을 통합함으로써 개발자들은 좋은 기능을 개발하는 데 더 집중할 수 있고 데이터 가져오기와 상태 관리의 복잡성에 대해 덜 걱정해도 됩니다.","ogImage":{"url":"/assets/img/2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache_0.png"},"coverImage":"/assets/img/2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache_0.png","tag":["Tech"],"readingTime":7},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    p: \"p\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"TL;DR\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"useFetchCache 훅은 React 애플리케이션의 데이터 가져오기, 캐싱 및 업데이트를 간단하게 만들기 위해 설계된 사용자 정의 훅입니다. 네트워크 요청을 로컬 캐싱과 원활하게 통합함으로써, 빈번한 액세스가 필요하지만 자주 변경되지 않는 데이터를 처리하는 효율적인 방법을 제공합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"React 컴포넌트에서 같은 데이터를 계속해서 가져오는 것에 지쳤습니까?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"useFetchCache를 만나보세요! 데이터 가져오기와 캐싱의 슈퍼히어로! 🦸‍♂️\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"useFetchCache는 데이터 가져오기를 간편하게 만들어 주는 커스텀 React 훅이에요. 개인 비서처럼 작동하여 필요한 모든 것을 기억해 주어서 매번 요청할 필요가 없어요. 반복적인 데이터 가져오기 로직 작성이나 여러 개의 로딩 및 오류 상태를 처리하는 번거로움도 없어요. 😌\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"useFetchCache를 사용하면 API URL과 필요한 매개변수를 제공하고, 후는 모두 맡기면 돼요. 데이터를 가져오고 로딩 상태를 처리하며, AsyncStorage를 사용하여 결과를 로컬로 캐싱해요. 이렇게 하면 같은 데이터에 대한 후속 요청은 캐시에서 제공되어 네트워크 트래픽을 줄이고 성능을 향상시킬 수 있어요. ⚡\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 여기서 끝이 아니에요! useFetchCache에는 다시 불러오는 함수가 제공되어 데이터를 필요할 때마다 새롭게 불러올 수 있어요. 사용자 상호작용이나 주기적인 업데이트 때문이더라도 useFetchCache가 항상 도와줄 거예요. 🔄\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그러니 React 컴포넌트를 강화하고 데이터 가져오기 프로세스를 간소화하려면 useFetchCache가 여러분의 새로운 친구가 될 거에요. 이 슈퍼히어로 훅으로 무거운 작업을 처리하고 사용자들을 위한 놀라운 경험을 만드는 데 집중할 수 있도록 해 주세요. 💯\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"useFetchCache를 통해 매끄러운 데이터 가져오기와 캐싱의 마법을 경험할 준비가 되셨나요? 🚀✨\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"useFetchCache란?\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"useFetchCache는 API에서 데이터를 가져오는 과정을 자동화하고, 그 데이터를 로컬 저장소(AsyncStorage 사용)에 저장하며, 이후 요청에서 해당 데이터를 불러오는 React의 커스텀 훅입니다. 이 훅은 데이터 가져오기, 캐싱, 오류 관리를 처리하고, 강제 데이터 새로고침을 허용합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"useFetchCache 사용의 장점\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"네트워크 호출 감소: 데이터를 로컬로 캐싱함으로써 애플리케이션에서 만드는 API 요청 수가 줄어들어 모바일 데이터 사용 및 제한적이거나 고비용의 연결 환경에서 특히 유용합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"성능 향상: 데이터를 로컬로 캐싱하면 데이터 검색 시간이 빨라지며, 데이터가 대부분 로컬 저장소에서 즉시 사용 가능하기 때문에 서버로의 왕복을 필요로하지 않습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"사용자 경험 향상: 사용자들은 빠른 로드 시간과 더 빠른 반응이 가능한 인터페이스를 경험할 수 있으며, 데이터가 빠른 액세스 로컬 캐시에서 로드되기 때문입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"간편화된 데이터 관리: 훅은 데이터 가져오기, 캐싱 및 오류 처리를 캡슐화하여 구성 요소 코드를 단순화합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"useFetchCache 사용 방법\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"훅 가져오기: React 컴포넌트 파일에 useFetchCache를 가져와서 시작합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"훅 초기화: 필요한 매개변수(API URL 및 선택적으로 기본 캐시 키 및 만료 시간)를 사용하여 useFetchCache를 호출합니다. 특정 키가 제공되지 않으면 URL도 캐시 키로 사용할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"데이터 표시: 훅이 반환하는 데이터 상태를 사용하여 컴포넌트에서 데이터를 표시합니다. 사용자에게 피드백을 제공하기 위해 필요한대로 로딩 상태 및 오류를 처리하세요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"새로 고침 및 페이지네이션 구현: 필요한 경우 신선한 데이터가 필요한 시나리오에 대비해 훅이 제공하는 refetch 메서드를 사용하고, API에서 지원하는 경우 API URL 또는 내부 상태를 조정하여 페이지네이션을 관리하세요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"코드 배치: 훅은 컴포넌트 함수 상단에 배치되어야 하며, 조건문이나 반복문 외부에 위치하여 훅의 규칙을 준수해야 합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"이것이 바로 훅입니다…\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// useFetchCache.js\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { useState, useEffect, useCallback } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"AsyncStorage\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'@react-native-async-storage/async-storage'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" axios \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'axios'\"\n        }), \";\\n\\n\", _jsxs(_components.span, {\n          className: \"hljs-comment\",\n          children: [\"/**\\n * AsyncStorage를 사용하여 데이터를 가져와 캐싱하는 커스텀 훅입니다. 옵션으로 강제 새로고침이 가능합니다.\\n * \\n * \", _jsx(_components.span, {\n            className: \"hljs-doctag\",\n            children: \"@param\"\n          }), \" {\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"string\"\n          }), \"} \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"url\"\n          }), \" - 데이터를 가져올 API URL입니다.\\n * \", _jsx(_components.span, {\n            className: \"hljs-doctag\",\n            children: \"@param\"\n          }), \" {\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"string\"\n          }), \"} [baseCacheKey=null] - 데이터를 저장하는 기본 캐시 키입니다. 제공되지 않으면 URL이 기본값으로 사용됩니다.\\n * \", _jsx(_components.span, {\n            className: \"hljs-doctag\",\n            children: \"@param\"\n          }), \" {\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"number\"\n          }), \"} [expirationTime=3600000] - 캐시 만료까지의 밀리초 단위 시간입니다 (기본값은 1시간).\\n * \", _jsx(_components.span, {\n            className: \"hljs-doctag\",\n            children: \"@return\"\n          }), \" {\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Object\"\n          }), \"} 데이터, 로딩 상태, 오류 및 리페치 함수를 포함한 객체입니다.\\n */\"]\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useFetchCache\"\n        }), \" = (\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"url, baseCacheKey = \", _jsx(_components.span, {\n            className: \"hljs-literal\",\n            children: \"null\"\n          }), \", expirationTime = \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1000\"\n          }), \" * \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"60\"\n          }), \" * \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"60\"\n          })]\n        }), \") =\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 제공된 baseCacheKey 또는 URL을 사용하여 캐시 키를 구성합니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" cacheKey = \", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`\", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"${baseCacheKey ? baseCacheKey : \", _jsx(_components.span, {\n              className: \"hljs-built_in\",\n              children: \"encodeURIComponent\"\n            }), \"(url)}\"]\n          }), \"`\"]\n        }), \";\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 데이터, 로딩 상태, 오류를 관리하는 상태 훅입니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [data, setData] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [isLoading, setIsLoading] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" [error, setError] = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useState\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 데이터를 가져오는 함수로, 옵션으로 캐시를 무시할 수 있습니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetchData\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsxs(_components.span, {\n          className: \"hljs-params\",\n          children: [\"forceFetch = \", _jsx(_components.span, {\n            className: \"hljs-literal\",\n            children: \"false\"\n          })]\n        }), \") =\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setIsLoading\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setError\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \");\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"try\"\n        }), \" {\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" storedDataString = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"AsyncStorage\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getItem\"\n        }), \"(cacheKey);\\n\\n      \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 강제 새로고침하지 않고 캐시가 있고 유효한 경우 캐시된 데이터를 사용합니다.\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!forceFetch \u0026\u0026 storedDataString) {\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" storedData = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"JSON\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"parse\"\n        }), \"(storedDataString);\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" now = \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"now\"\n        }), \"();\\n        \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (now - storedData.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"timestamp\"\n        }), \" \u003c expirationTime) {\\n          \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"캐시로부터 데이터를 제공합니다 for key:\\\"\"\n        }), \", cacheKey);\\n          \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setData\"\n        }), \"(storedData.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"data\"\n        }), \");\\n          \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \";\\n        }\\n      }\\n\\n      \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 강제 새로고침이거나 캐시가 만료된 경우 또는 캐시가 없는 경우 API에서 데이터를 가져옵니다.\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"API로부터 데이터를 가져옵니다 for URL:\\\"\"\n        }), \", url);\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" response = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" axios.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"get\"\n        }), \"(url);\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" newData = response.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"data\"\n        }), \";\\n      \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setData\"\n        }), \"(newData);\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"AsyncStorage\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setItem\"\n        }), \"(cacheKey, \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"JSON\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"stringify\"\n        }), \"({\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"data\"\n        }), \": newData,\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"timestamp\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"now\"\n        }), \"(),\\n      }));\\n    } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"catch\"\n        }), \" (err) {\\n      \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"error\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"데이터를 가져오는 중 오류가 발생했습니다:\\\"\"\n        }), \", err);\\n      \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setError\"\n        }), \"(err);\\n    } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"finally\"\n        }), \" {\\n      \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"setIsLoading\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \");\\n    }\\n  };\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 캐시를 무시하여 데이터를 강제로 다시 가져오는 함수입니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" refetch = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useCallback\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"캐시를 무시하고 데이터를 다시 가져옵니다...\\\"\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetchData\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"true\"\n        }), \");\\n  }, [url, cacheKey]);\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// URL이나 cacheKey가 변경될 때 데이터를 가져오는 효과입니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useEffect\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"fetchData\"\n        }), \"();\\n  }, [url, cacheKey]);\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" { data, isLoading, error, refetch };\\n};\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \" useFetchCache;\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"그리고 여기에 샘플 사용법이 있습니다...\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// DataFetchingComponent.js \"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"React\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" { \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"View\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Text\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ActivityIndicator\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Button\"\n        }), \" } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'react-native'\"\n        }), \";\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" useFetchCache \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'./useFetchCache'\"\n        }), \"; \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// useFetchCache가 정의된 파일로 올바르게 지정하세요.\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"DataFetchingComponent\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") =\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 데이터를 가져올 URL입니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" url = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"https://api.example.com/data\\\"\"\n        }), \";\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// URL을 사용하여 훅을 초기화합니다. baseCacheKey를 제공하지 않으면 URL이 자동으로 캐시 키로 사용됩니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" { data, isLoading, error, refetch } = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"useFetchCache\"\n        }), \"(url);\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 사용자가 \\\"새로고침\\\" 버튼을 누를 때 새로 고침 동작을 처리합니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"handleRefresh\"\n        }), \" = (\", _jsx(_components.span, {\n          className: \"hljs-params\"\n        }), \") =\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"refetch\"\n        }), \"(); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 훅에서 제공하는 refetch 함수를 호출하여 데이터를 강제로 다시 가져옵니다.\"\n        }), \"\\n  };\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 데이터를 가져오는 동안 로딩 표시줄을 렌더링합니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (isLoading) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"xml\",\n          children: _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"ActivityIndicator\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"size\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"large\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"color\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"#0000ff\\\"\"\n            }), \" /\u003e\"]\n          })\n        }), \";\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 데이터를 가져오는 동안 오류가 발생하면 오류 메시지를 렌더링합니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (error) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Text\"\n            }), \"\u003e\"]\n          }), \"Error: {error.toString()}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Text\"\n            }), \"\u003e\"]\n          })]\n        }), \";\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 가져온 데이터 또는 가져온 데이터가 없을 경우 메시지를 렌더링합니다.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (\\n    \", _jsxs(_components.span, {\n          className: \"xml\",\n          children: [_jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"View\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"style\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{{\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"flex:\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"1\"\n            }), \", \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"justifyContent:\"\n            }), \" '\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"center\"\n            }), \"', \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"alignItems:\"\n            }), \" '\", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"center\"\n            }), \"' }}\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Text\"\n            }), \"\u003e\"]\n          }), \"Data: {data ? JSON.stringify(data) : '데이터 없음'}\", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Text\"\n            }), \"\u003e\"]\n          }), \"\\n      \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"Button\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"title\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"데이터 새로고침\\\"\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"onPress\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"{handleRefresh}\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-attr\",\n              children: \"color\"\n            }), \"=\", _jsx(_components.span, {\n              className: \"hljs-string\",\n              children: \"\\\"#0000ff\\\"\"\n            }), \" /\u003e\"]\n          }), \"\\n    \", _jsxs(_components.span, {\n            className: \"hljs-tag\",\n            children: [\"\u003c/\", _jsx(_components.span, {\n              className: \"hljs-name\",\n              children: \"View\"\n            }), \"\u003e\"]\n          })]\n        }), \"\\n  );\\n};\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"export\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"DataFetchingComponent\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"주요 내용```\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"일관성이 중요합니다: 항상 동일한 데이터 집합에 대해 동일한 캐시 키를 사용하여 응용 프로그램 전체의 일관성을 보장하세요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"오류 처리를 세련되게: 데이터 가져오기에서 발생하는 오류를 세련되게 처리하여 사용자 경험을 개선하세요.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"캐시 정기적으로 업데이트: 캐시된 데이터에 적절한 만료 시간을 설정하고 주기적으로 또는 사용자 요구에 따라 캐시를 업데이트하는 refetch 함수를 사용하세요.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"React 애플리케이션에서 useFetchCache 훅을 사용하면 데이터 처리를 최적화할 수 있습니다. 반복적이고 비용 소모적인 네트워크 요청이 줄어들며 데이터 로드 시간을 단축하고 구성 요소에서의 데이터 관리를 간단하게 할 수 있습니다. 이 훅을 통합함으로써 개발자들은 좋은 기능을 개발하는 데 더 집중할 수 있고 데이터 가져오기와 상태 관리의 복잡성에 대해 덜 걱정해도 됩니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-12-MasteringDataFetchinginReactIntroducinguseFetchCache"},"buildId":"7rKODeu6chWTLgXf6auoL","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>