<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>NumPy 마스터하기 효율적인 배열 처리 종합 가이드 Part 2 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="NumPy 마스터하기 효율적인 배열 처리 종합 가이드 Part 2 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="NumPy 마스터하기 효율적인 배열 처리 종합 가이드 Part 2 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22" data-gatsby-head="true"/><meta name="twitter:title" content="NumPy 마스터하기 효율적인 배열 처리 종합 가이드 Part 2 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 05:37" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">NumPy 마스터하기 효율적인 배열 처리 종합 가이드 Part 2</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="NumPy 마스터하기 효율적인 배열 처리 종합 가이드 Part 2" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">32<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>빠르고 똑똑한 데이터 조작을 위한 NumPy의 힘을 활용하세요.</h2>
<h1>소개</h1>
<p>NumPy 튜토리얼의 두 번째 파트에 오신 것을 환영합니다! 이전에는 다음 목록의 처음 7개 챕터를 다루었습니다. 이번 포스트에서는 8장부터 14장까지 진행하려고 합니다.</p>
<ul>
<li>NumPy 설치</li>
<li>배열 초기화</li>
<li>NumPy 배열 제한</li>
<li>계산 속도와 메모리 사용량</li>
<li>데이터 유형</li>
<li>색인 및 슬라이싱</li>
<li>배열 생성 함수</li>
<li>난수 생성</li>
<li>보기 및 복사</li>
<li>수학 함수</li>
<li>논리 및 비트 연산자</li>
<li>검색 및 정렬</li>
<li>모양 및 재구성</li>
<li>연결 및 분할</li>
</ul>
<div class="content-ad"></div>
<p>참고: 이 문서에서 사용된 모든 자료는 제 GitHub 저장소에서 확인할 수 있습니다. 여기에 링크를 남깁니다.</p>
<h1>8. 랜덤 숫자</h1>
<p>NumPy를 사용하면 랜덤 숫자를 생성할 수 있습니다. 제 경우에는 이 기능을 사용하여 기계 학습 및 딥 러닝 모델에서 무작위 가중치를 초기화하는 데 사용해 보았습니다. 제가 처음부터 구현하려고 노력했던 그때입니다. 이러한 유형의 NumPy 기능에는 다른 응용 프로그램이 있을 것이라고 믿습니다.</p>
<h2>균일 분포</h2>
<div class="content-ad"></div>
<p>이제 np.random.rand()로 시작해 봅시다. 이 함수는 [0.0, 1.0) 범위 내에서 균일 분포에서 무작위 숫자를 생성합니다. 이는 숫자가 정확히 0.0이 될 수는 있지만, 1.0에 근접할 뿐입니다. 이 함수를 사용하려면 우리가 원하는 배열의 형태를 전달해주기만 하면 됩니다. np.random.random()은 사실상 np.random.rand()와 동일합니다. 그러나 이 함수에 대한 입력은 튜플 형태여야 한다는 것을 염두에 두세요. 이 두 함수 중 어느 것이든 실제로 서로 교차하여 사용할 수 있습니다. 이는 단지 사용자의 취향에 따라 다를 뿐입니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">1</span>
np.<span class="hljs-property">random</span>.<span class="hljs-title function_">rand</span>(<span class="hljs-number">10</span>,<span class="hljs-number">3</span>)

### 대안
# np.<span class="hljs-property">random</span>.<span class="hljs-title function_">random</span>((<span class="hljs-number">10</span>,<span class="hljs-number">3</span>))
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_0.png">
<p>아직 무작위 균일 분포와 관련하여, 더 많은 유연성이 필요하다면 np.random.uniform()를 사용할 수 있습니다. 이 함수를 사용하면 분포의 범위를 지정할 수 있어 [0.0, 1.0)에 고정되어 있는 것보다 더 유연해집니다. 아래 코드 블록에서 수를 90부터 100 사이로 범위 설정하는 방법을 보여드리겠습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">2</span>
np.<span class="hljs-property">random</span>.<span class="hljs-title function_">uniform</span>(low=<span class="hljs-number">90</span>, high=<span class="hljs-number">100</span>, size=(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_1.png" alt="이미지"></p>
<p>만약 균일 분포에서 숫자를 np.histogram()에 넣으면, 모든 바구니(첫 번째 인덱스의 배열)에 유사한 빈도의 발생이 있음을 볼 수 있습니다. 아래 예제에서는 10개의 바구니로 분배된 50,000개의 숫자를 생성합니다. 이렇게 하면 각 바구니에 약 5,000개의 발생 횟수가 있습니다. 무작위 균일 함수의 세 가지 변형(np.random.rand(), np.random.random() 및 np.random.uniform())이 모두 이렇게 동작합니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">3</span>
np.<span class="hljs-title function_">histogram</span>(np.<span class="hljs-property">random</span>.<span class="hljs-title function_">uniform</span>(size=(<span class="hljs-number">50000</span>)))

### 유사한 결과를 제공합니다
# np.<span class="hljs-title function_">histogram</span>(np.<span class="hljs-property">random</span>.<span class="hljs-title function_">rand</span>(<span class="hljs-number">50000</span>))
# np.<span class="hljs-title function_">histogram</span>(np.<span class="hljs-property">random</span>.<span class="hljs-title function_">random</span>(<span class="hljs-number">50000</span>))
</code></pre>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_2.png">
<h2>정규 분포</h2>
<p>균일 분포 뿐만 아니라 np.random.randn()을 사용하여 정규 분포의 데이터도 생성할 수 있습니다. 여기서 전달할 수 있는 유일한 매개변수는 생성될 배열의 모양입니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">4</span>
np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randn</span>(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>)
</code></pre>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_3.png" alt="Image"></p>
<p>안타깝게도 np.random.randn() 함수는 분포의 평균과 표준 편차를 변경할 수 있는 기능을 제공하지 않습니다. 이 함수에서 두 매개변수는 각각 0과 1로 고정되어 있습니다. 만약 이러한 값을 사용자 정의하고 싶다면 np.random.normal()을 사용해야 합니다. np.random.normal()에서는 평균을 loc 매개변수를 사용하여 조절하고, 표준편차는 scale 매개변수를 통해 수정할 수 있습니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">5</span>
np.<span class="hljs-property">random</span>.<span class="hljs-title function_">normal</span>(loc=<span class="hljs-number">8</span>, scale=<span class="hljs-number">3</span>, size=(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_4.png" alt="Image"></p>
<div class="content-ad"></div>
<p>제가 앞서 사용한 np.histogram() 함수는 np.random.randn() 및 np.random.normal()에 의해 생성된 배열이 실제로 정규 분포를 따르는지 확인하는 데 사용될 수 있습니다. 아래 그림 6은 이를 설명하는데, 첫 번째 배열을 통해 가운데 있는 bin이 가장 빈도가 높음을 보여줍니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">6</span>
np.<span class="hljs-title function_">histogram</span>(np.<span class="hljs-property">random</span>.<span class="hljs-title function_">normal</span>(loc=<span class="hljs-number">0</span>, scale=<span class="hljs-number">1</span>, size=<span class="hljs-number">50000</span>))

### 비슷한 결과를 출력
# np.<span class="hljs-title function_">histogram</span>(np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randn</span>(<span class="hljs-number">50000</span>))
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_5.png">
<p>지금까지 많은 유사한 함수가 존재한다는 것을 알아차렸습니다. 특히, 무작위 숫자를 생성하는 데 사용되는 함수들은 균일 및 정규 분포와 관련된 함수들이 많습니다. 그런 경우에는 np.random.uniform() 및 np.random.normal()만 사용하는 것을 권장드립니다. 두 함수가 가장 유연하기 때문입니다.</p>
<div class="content-ad"></div>
<h2>랜덤 정수</h2>
<p>우리가 이전에 논의한 함수들은 주로 랜덤 소수점 숫자를 생성하는 데 초점을 맞췄습니다. 실제로 Numpy는 랜덤 정수를 생성하는 함수인 np.random.randint()를 제공합니다. 이 함수의 매개변수 및 동작은 np.random.uniform()와 동일합니다. 지정된 범위 내의 모든 숫자는 선택될 확률이 완전히 동일합니다. 다시 말해, np.random.randint()는 숫자 선택을 위해 균일한 이산 분포를 사용합니다. 아래 예시에서 생성된 숫자들은 [5,10) 범위 내에 있을 것입니다 (즉, 10은 포함되지 않음).</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">7</span>
np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randint</span>(low=<span class="hljs-number">5</span>, high=<span class="hljs-number">10</span>, size=(<span class="hljs-number">20</span>,<span class="hljs-number">3</span>))
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_6.png" alt="이미지"></p>
<div class="content-ad"></div>
<h2>배열 섞기</h2>
<p>다음으로 이야기하고 싶은 함수는 np.random.shuffle()입니다. 그러나 더 진행하기 전에 먼저 배열 K를 초기화하고 싶습니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">8</span>
K = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randint</span>(<span class="hljs-number">1</span>, <span class="hljs-number">30</span>, size=<span class="hljs-number">10</span>)
K
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_7.png">
<div class="content-ad"></div>
<p>아마 알아챌 수 있었던 것처럼, np.random.shuffle()은 배열의 요소 순서를 섞어주는 함수입니다. 이 함수는 배열을 그 자리에서 섞기 때문에, 새로운 배열을 만드는 것이 아니라 원본 배열을 직접 섞는다는 것을 명심해 주세요.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">9</span>
<span class="hljs-title function_">print</span>(<span class="hljs-string">'섞기 전 K\t: '</span>, K)
np.<span class="hljs-property">random</span>.<span class="hljs-title function_">shuffle</span>(K)
<span class="hljs-title function_">print</span>(<span class="hljs-string">'섞은 후 K\t: '</span>, K)
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_8.png">
<h2>랜덤 선택</h2>
<div class="content-ad"></div>
<p>아직 배열 K와 작업 중이시군요. 이제 그 중에서 숫자를 무작위로 선택하는 방법을 알려드릴게요. np.random.choice()를 사용하면 간단하죠. 아래 코드 블록에서 함수를 사용하는 여러 예제를 보여드릴게요.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">10</span>
<span class="hljs-title function_">print</span>(np.<span class="hljs-property">random</span>.<span class="hljs-title function_">choice</span>(K), end=<span class="hljs-string">'\n\n'</span>)                #(<span class="hljs-number">1</span>)
<span class="hljs-title function_">print</span>(np.<span class="hljs-property">random</span>.<span class="hljs-title function_">choice</span>(K, size=(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)), end=<span class="hljs-string">'\n\n'</span>)    #(<span class="hljs-number">2</span>)
<span class="hljs-title function_">print</span>(np.<span class="hljs-property">random</span>.<span class="hljs-title function_">choice</span>(K, size=(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>), replace=<span class="hljs-title class_">False</span>)) #(<span class="hljs-number">3</span>)
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_9.png">
<p>(1)에서 지정된 줄에서, 함수에 배열만 전달하면 해당 배열에서 한 개의 숫자를 반환합니다. (2)의 size 매개변수를 사용하여 출력의 차원을 지정할 수도 있어요. 출력 결과를 보면 16이 두 번 나타나는 것을 알 수 있어요. 이는 기본적으로 함수가 복원 선택으로 무작위 숫자를 선택하기 때문인데요, 즉, 원래 배열에서 하나의 숫자가 여러 번 선택될 수 있습니다. 이를 원치 않는 경우, replace=False를 써서 다음과 같이 쓸 수 있어요. (3)에서처럼요. 이렇게 하면 결과 배열의 요소 수가 원본 배열의 요소 수보다 크면 안 된다는 점에 유의하세요. 궁금하시다면, 세 번째 출력에서 두 번 나타나는 12는 배열 K에 12가 실제로 두 번 나타난 것 때문입니다.</p>
<div class="content-ad"></div>
<h2>시드</h2>
<p>생성된 무작위 숫자를 재현 가능하게 하는 경우가 많습니다. 이를 위해 np.random.seed()를 사용할 수 있습니다. 사용 방법은 간단합니다. 단지 인수로 숫자를 넣고 동일한 숫자를 출력을 정확히 원하는 노트북 셀에서 사용하면 됩니다. 다음 예제를 살펴봅시다. 여기서 np.random.randint()로 생성된 배열이 두 연속된 코드 블록에서 정확히 동일하게 나오기를 원합니다. 이 예에서 시드를 99로 설정하기로 결정했습니다(원하는 정수를 선택할 수 있습니다). np.random.randint()가 정확히 동일한 숫자를 반환하려면, 동일한 시드로 np.random.seed()를 다시 호출해야 합니다.</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># 코드 블록 11</span>
np.random.seed(<span class="hljs-number">99</span>)
np.random.randint(low=<span class="hljs-number">0</span>, high=<span class="hljs-number">10</span>, size=(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>))
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-json"># 코드 블록 <span class="hljs-number">12</span>
np.random.seed(<span class="hljs-number">99</span>)
np.random.randint(low=<span class="hljs-number">0</span><span class="hljs-punctuation">,</span> high=<span class="hljs-number">10</span><span class="hljs-punctuation">,</span> size=(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">5</span>))
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_11.png" alt="이미지"></p>
<h1>9. 뷰(View)와 복사(Copy)</h1>
<h2>뷰(View)</h2>
<div class="content-ad"></div>
<p>한 변수에서 다른 변수로 배열을 할당할 때 Numpy의 성질을 고려해야 합니다. 다음 예제를 살펴보겠습니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">13</span>
L = np.<span class="hljs-title function_">array</span>([<span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>, <span class="hljs-number">88</span>, <span class="hljs-number">99</span>])
M = L
<span class="hljs-title function_">print</span>(M)
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_12.png">
<p>여기서 배열 L을 변수 M에 할당했으므로 두 변수가 동일한 배열을 포함하게 됩니다. 다음으로, 아래 코드 블록 14를 사용하여 M의 0번 인덱스를 변경하려고 합니다. 그러나 M의 첫 번째 요소만 바꾸려고 했지만 배열 L의 요소도 변경됩니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">14</span>
M[<span class="hljs-number">0</span>] = <span class="hljs-number">15</span>
<span class="hljs-title function_">print</span>(<span class="hljs-string">'L:'</span>, L)
<span class="hljs-title function_">print</span>(<span class="hljs-string">'M:'</span>, M)
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_13.png" alt="이미지"></p>
<p>이 결과가 나온 이유는 M이 단순히 L의 "뷰(view)"일 뿐이기 때문입니다. 다시 말해 위에서 보여준 방법은 배열을 복사하는 것이 아니라 두 변수가 여전히 "연결"되어 있기 때문입니다.</p>
<h2>복사</h2>
<div class="content-ad"></div>
<p>위의 경우가 발생하지 않도록하려면, M에 할당할 때 copy() 메서드를 L에 넣으면 됩니다. 이렇게 하면 M에 저장된 배열이 완전히 다른 배열이 되어, 하나의 배열에 대한 수정이 다른 배열에 영향을 미치지 않도록 보장됩니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">15</span>
L = np.<span class="hljs-title function_">array</span>([<span class="hljs-number">55</span>, <span class="hljs-number">66</span>, <span class="hljs-number">77</span>, <span class="hljs-number">88</span>, <span class="hljs-number">99</span>])
M = L.<span class="hljs-title function_">copy</span>()
M[<span class="hljs-number">0</span>] = <span class="hljs-number">15</span>

<span class="hljs-title function_">print</span>(<span class="hljs-string">'L:'</span>, L)
<span class="hljs-title function_">print</span>(<span class="hljs-string">'M:'</span>, M)
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_14.png">
<h1>10. 수학 함수</h1>
<div class="content-ad"></div>
<h2>기본 수학 연산</h2>
<p>이 장에서는 Numpy의 수학 기능을 사용하는 방법에 대해 알아보려고 합니다. 시작하기 전에 사전에 배열 N과 O를 초기화해 봅시다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">16</span>
N = np.<span class="hljs-title function_">array</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], dtype=<span class="hljs-string">'int32'</span>)
O = np.<span class="hljs-title function_">array</span>([<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], dtype=<span class="hljs-string">'int32'</span>)
</code></pre>
<p>우리는 가장 기초적인 것부터 시작할 것입니다: 덧셈, 뺄셈, 곱셈 및 나눗셈입니다. Numpy에서 배열에 이러한 연산자를 적용하면 연산은 요소별로 수행됩니다. 이러한 이유로 배열 피연산자의 차원이 정확히 일치하는지 확인해야 합니다.</p>
<div class="content-ad"></div>
<h1>코드 블록 17</h1>
<p>print(N + O)
print(N - O)
print(N * O)
print(N / O)</p>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_15.png" alt="이미지"></p>
<p>위의 코드블록 17에서 소개된 방법들은 Numpy 배열에서만 작동합니다. 리스트에 똑같은 작업을 시도하면 모든 예제가 오류가 발생할 것이며, 덧셈 연산은 두 리스트를 연결할 것입니다.</p>
<p>대안으로 np.add(), np.subtract(), np.multiply() 및 np.divide()와 같은 Numpy에서 제공하는 함수들을 사용할 수도 있습니다. 연산자 기호와 함수 모두 정확히 같은 결과를 생성합니다. 따라서 이 경우에는 개인 취향에 따라 선택하면 됩니다. 아래 코드블록은 이러한 함수들을 어떻게 사용하는지 보여줍니다. 결과 출력은 Figure 16에 표시된 것과 완전히 동일합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">18</span>
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">add</span>(N, O))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">subtract</span>(N, O))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">multiply</span>(N, O))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">divide</span>(N, O))
</code></pre>
<p>넘파이(Numpy)에서 "브로드캐스팅(broadcasting)"이라는 개념이 있습니다. 이는 기본적으로 크기가 다른 배열 또는 배열과 스칼라 간의 연산을 수행할 수 있다는 것을 의미합니다. 다음 경우에는 숫자 5가 배열 N의 모든 요소로 브로드캐스팅된다고 말할 수 있습니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">19</span>
<span class="hljs-title function_">print</span>(N + <span class="hljs-number">5</span>)
<span class="hljs-title function_">print</span>(N - <span class="hljs-number">5</span>)
<span class="hljs-title function_">print</span>(N * <span class="hljs-number">5</span>)
<span class="hljs-title function_">print</span>(N / <span class="hljs-number">5</span>)
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_16.png">
<div class="content-ad"></div>
<p>제가 다음으로 논의하고 싶은 것은 행렬 곱셈입니다. 이전에 언급한 대로, 네 가지 기본 수학 연산 함수는 요소별로 작동합니다. 이는 np.multiply() 함수가 행렬 곱셈을 위해 의도된 것이 아니라는 것을 의미합니다. 대신 np.matmul()을 사용해야 합니다. 이 경우 두 입력 행렬이 연산 가능한지 확인해야 합니다. 다음 예제에서는 각각 크기가 (4,3)과 (3,2)인 배열 O와 P 사이의 곱셈을 수행합니다.</p>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">20</span>
O = np.<span class="hljs-title function_">array</span>([[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>], 
              [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>], 
              [<span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>], 
              [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>]])

P = np.<span class="hljs-title function_">array</span>([[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>], 
              [<span class="hljs-number">6</span>, <span class="hljs-number">5</span>], 
              [<span class="hljs-number">8</span>, <span class="hljs-number">7</span>]])

np.<span class="hljs-title function_">matmul</span>(O, P)
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_17.png">
<p>여전히 기본 수학 연산과 관련된 다른 함수에는 np.sign(), np.negative() 및 np.abs()가 있습니다. 이러한 함수들의 사용법을 배열 Q에 대해 보여드리겠습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">21</span>
Q = np.<span class="hljs-title function_">array</span>([-<span class="hljs-number">56</span>, <span class="hljs-number">92</span>, -<span class="hljs-number">24</span>, -<span class="hljs-number">66</span>, <span class="hljs-number">72</span>, -<span class="hljs-number">75</span>, <span class="hljs-number">90</span>, <span class="hljs-number">0</span>, <span class="hljs-number">32</span>, <span class="hljs-number">51</span>])

<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">sign</span>(Q))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">negative</span>(Q))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">abs</span>(Q))      # 대안: np.<span class="hljs-title function_">absolute</span>()
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_18.png" alt="이미지"></p>
<p>함수 이름대로, np.sign()은 배열의 각 요소의 부호를 취하는 데 사용됩니다. -1, 0 또는 1만 표시됩니다. 다음으로, np.negative()를 사용하여 숫자의 부호를 뒤집을 수 있습니다. 위의 예시에서 -56은 56이 되고, 92는 -92가 됩니다. 마지막으로, np.abs() 또는 np.absolute()를 사용하여 숫자의 절대값을 취할 수 있습니다.</p>
<h2>최대공약수(GCD)와 최소공배수(LCM)</h2>
<div class="content-ad"></div>
<p>최대공약수(GCD)와 최소공배수(LCM)는 Numpy에서 각각 np.gcd()와 np.lcm()으로 구현되어 있습니다. 이러한 함수들을 사용하려면, 간단히 두 숫자나 배열을 입력인수로 넣으면 됩니다.</p>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">22</span>
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">gcd</span>(<span class="hljs-number">81</span>, <span class="hljs-number">72</span>))    #(<span class="hljs-number">1</span>)
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">lcm</span>([<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>], <span class="hljs-number">24</span>))    #(<span class="hljs-number">2</span>)
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">lcm</span>([<span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">24</span>, <span class="hljs-number">16</span>, <span class="hljs-number">3</span>]))    #(<span class="hljs-number">3</span>)
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_19.png">
<p>위 코드블록 22의 예제를 살펴봅시다. #(1)으로 표시된 줄은 81과 72의 최대공약수인 하나의 숫자를 반환합니다. 한편, #(2) 줄에서는 숫자 24가 첫 번째 인수에 브로드캐스트되어 LCM이 24와 목록의 각 숫자 간에 계산됩니다. 마지막으로, 두 인수에 대해 리스트를 전달하면, LCM 또는 GCD 계산이 요소별로 수행됩니다 (#(3)).</p>
<div class="content-ad"></div>
<h2>지수 함수</h2>
<p>np.power() 함수를 사용하여 지수 연산을 수행할 수 있습니다. 이 함수는 두 개의 입력을 받습니다: 밑수와 지수입니다. 해당 함수는 지수로 분수를 전달하여 루트를 계산할 수 있도록 매우 유연합니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">23</span>
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">power</span>(<span class="hljs-number">8</span>, <span class="hljs-number">3</span>))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">power</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], <span class="hljs-number">2</span>))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">power</span>(<span class="hljs-number">144</span>, <span class="hljs-number">1</span>/<span class="hljs-number">2</span>))
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_20.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>유연성이 있긴 하지만, np.power()은 실제로 연산 속도에 있어서 최상이라고 할 수는 없습니다. 실제로 더 빠른 계산을 제공하는 몇 가지 특정 목적을 위한 대안들이 있습니다. np.square(), np.sqrt(), np.cbrt() 및 np.exp()가 그 예입니다. 아래 코드 블록은 np.power()와 이러한 함수들의 동등한 사용법을 보여줍니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">24</span>
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">square</span>(<span class="hljs-number">6</span>))             # np.<span class="hljs-title function_">power</span>(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>)와 동일
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">sqrt</span>([<span class="hljs-number">144</span>,<span class="hljs-number">16</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>]))    # np.<span class="hljs-title function_">power</span>([<span class="hljs-number">144</span>,<span class="hljs-number">16</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>], <span class="hljs-number">1</span>/<span class="hljs-number">2</span>)와 동일
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">cbrt</span>([<span class="hljs-number">343</span>,<span class="hljs-number">27</span>]))        # np.<span class="hljs-title function_">power</span>([<span class="hljs-number">343</span>,<span class="hljs-number">27</span>], <span class="hljs-number">1</span>/<span class="hljs-number">3</span>)와 동일
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">exp</span>([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]))          # np.<span class="hljs-title function_">power</span>(np.<span class="hljs-property">e</span>, [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])와 동일
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_21.png">
<h2>각도 변환 및 삼각함수</h2>
<div class="content-ad"></div>
<p>넘파이에서는 삼각함수를 사용할 수 있습니다. np.sin(), np.cos() 및 np.tan()을 사용할 때 주의해야 할 점은 이 함수들이 라디안 단위의 각도를 입력으로 받는다는 것입니다. 따라서 각도가 도(degree)로 주어진 경우 np.deg2rad()를 사용하여 라디안으로 변환해야 합니다. 아래 Codeblock 25에서는 각도를 도와 라디안으로 변환하는 방법을 보여줍니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">25</span>
R = np.<span class="hljs-title function_">array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">90</span>, <span class="hljs-number">180</span>, <span class="hljs-number">270</span>])    # 각도 (도)가 담긴 배열
S = np.<span class="hljs-title function_">array</span>([<span class="hljs-number">0</span>, np.<span class="hljs-property">pi</span>/<span class="hljs-number">2</span>, np.<span class="hljs-property">pi</span>, np.<span class="hljs-property">pi</span>*<span class="hljs-number">3</span>/<span class="hljs-number">2</span>])    # 각도 (라디안)가 담긴 배열

<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">deg2rad</span>(R))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">rad2deg</span>(S))
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_22.png">
<p>각도 변환 방법을 이해했으니, 이제 삼각함수의 사용법을 실제로 보여드리겠습니다. 다음 코드에서 숫자 0, 45, 60이 각도 (도)를 나타낸다고 가정합니다. 이 숫자들은 라디안으로 변환된 후 배열 T에 저장되어 np.sin(), np.cos(), np.tan()의 입력으로 사용됩니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">26</span>
T = np.<span class="hljs-title function_">deg2rad</span>([<span class="hljs-number">0</span>, <span class="hljs-number">45</span>, <span class="hljs-number">60</span>])

<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">sin</span>(T))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">cos</span>(T))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">tan</span>(T))
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_23.png" alt="이미지"></p>
<h2>로그 함수</h2>
<p>로그 함수에 대해 이야기할 때, 적어도 가장 기본적이라고 생각되는 세 가지 함수가 있습니다. 아래 코드 블록 27에서는 배열 U에 np.log(), np.log2() 및 np.log10() 함수를 어떻게 사용하는지 보여줍니다.</p>
<div class="content-ad"></div>
<h1>코드 블록 27</h1>
<p>U = [1, 2, 10, np.e]</p>
<p>print(np.log(U))
print(np.log2(U))
print(np.log10(U))</p>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_24.png" alt="Image"></p>
<p>Numpy에서 np.log()는 수학의 ln() 함수와 동일합니다 (밑이 e인 로그). 한편, np.log2()와 np.log10()은 각각 밑이 2와 10인 로그입니다.</p>
<h2>통계 함수</h2>
<div class="content-ad"></div>
<p>만약 숫자 데이터 분포를 가지고 있다면, 통계적 특성을 계산하여 추가 분석을 수행할 수 있습니다. 우리에게 운이 좋은 것은 Numpy가 이 작업을 쉽게 수행할 수 있는 다양한 함수를 제공해준다는 것입니다. 이와 관련된 모든 함수들 — 아마도 이들 모두가 명확히 이해할 만한 함수들로 보입니다 — 이 코드 블록 28에 나와 있습니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">28</span>
V = np.<span class="hljs-title function_">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>])

<span class="hljs-title function_">print</span>(<span class="hljs-string">'sum\t:'</span>, np.<span class="hljs-title function_">sum</span>(V))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'mean\t:'</span>, np.<span class="hljs-title function_">mean</span>(V))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'median\t:'</span>, np.<span class="hljs-title function_">median</span>(V))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'var\t:'</span>, np.<span class="hljs-title function_">var</span>(V))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'stddev\t:'</span>, np.<span class="hljs-title function_">std</span>(V))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'q1\t:'</span>, np.<span class="hljs-title function_">quantile</span>(V, <span class="hljs-number">0.25</span>))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'q2\t:'</span>, np.<span class="hljs-title function_">quantile</span>(V, <span class="hljs-number">0.5</span>))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'q3\t:'</span>, np.<span class="hljs-title function_">quantile</span>(V, <span class="hljs-number">0.75</span>))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'min\t:'</span>, np.<span class="hljs-title function_">min</span>(V))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'max\t:'</span>, np.<span class="hljs-title function_">max</span>(V))
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_25.png">
<p>이 주제 외에도 통계 측정과 직접적인 관련이 없지만 여전히 유용할 수 있는 두 가지 다른 함수가 실제로 있습니다. 말하고자 하는 두 함수는 np.argmin()과 np.argmax()인데, 이 두 함수는 배열에서 가장 작은 값과 가장 큰 값이 들어 있는 인덱스를 반환합니다. 가장 작거나 큰 값이 여러 개인 경우, 이 두 함수는 가장 낮은 인덱스를 반환합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">29</span>
<span class="hljs-title function_">print</span>(<span class="hljs-string">'argmin\t:'</span>, np.<span class="hljs-title function_">argmin</span>(V))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'argmax\t:'</span>, np.<span class="hljs-title function_">argmax</span>(V))
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_26.png" alt="image"></p>
<h2>선형 대수</h2>
<p>넘파이는 선형 대수 계산을 수행하는데 다양한 도구를 제공합니다. 여기서 여러분께 보여드릴 수 있는 몇 가지 사항들이 있습니다. 코드 블록 30에 표시된 두 배열이 있다고 가정해 봅시다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">30</span>
W = np.<span class="hljs-title function_">array</span>([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>])
X = np.<span class="hljs-title function_">array</span>([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])
</code></pre>
<p>넘파이에서 1차원 배열은 벡터로 생각할 수 있습니다. 따라서 np.dot()을 사용하여 W와 X의 내적을 계산할 수 있습니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">31</span>
np.<span class="hljs-title function_">dot</span>(W, X)
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_27.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>또한 NumPy는 np.inner() 및 np.outer()를 통해 내적과 외적을 계산할 수 있도록 합니다.</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># Codeblock 32</span>
<span class="hljs-built_in">print</span>(np.inner(W, X))
<span class="hljs-built_in">print</span>(np.outer(W, X))
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_28.png">
<p>이제 2D 배열을 다루고 있다면 우리가 할 수 있는 것들에 대해 좀 더 자세히 알아보겠습니다. 이를 시연하기 전에 배열 Y를 미리 초기화하고 싶습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">33</span>
Y = np.<span class="hljs-title function_">array</span>([[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],
              [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],
              [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>]])
</code></pre>
<p>행렬의 전치(transpose)를 얻으려면 np.transpose()를 사용하거나 해당 행렬의 T 속성을 사용할 수 있습니다. 아래 코드 블록을 확인해보세요.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">34</span>
np.<span class="hljs-title function_">transpose</span>(Y)

### 대안
# Y.<span class="hljs-property">T</span>
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_29.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>넘파이는 행렬의 역행렬을 계산하는 함수도 제공합니다. <code>np.linalg.inv()</code>를 사용하면 행렬 Y의 역행렬을 계산할 수 있습니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">35</span>
np.<span class="hljs-property">linalg</span>.<span class="hljs-title function_">inv</span>(Y)
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_30.png">
<p>그러나 중요한 점은 행렬이 특이행렬일 때, 즉 행렬식이 0일 때 <code>np.linalg.inv()</code>가 오류를 반환한다는 것입니다. 따라서 역행렬을 계산하기 전에 행렬의 행렬식 값을 확인하는 것이 좋은 아이디어라고 생각합니다. 확인을 위해 <code>np.linalg.det()</code>을 사용하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">36</span>
np.<span class="hljs-property">linalg</span>.<span class="hljs-title function_">det</span>(Y)
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_31.png" alt="Image"></p>
<p>더불어 Numpy는 np.linalg.eig()를 사용하여 고유값과 고유벡터를 계산할 수 있습니다. 이 함수는 두 값 모두 반환하므로 출력을 위해 두 변수를 할당해야 합니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">37</span>
eigenvalues, eigenvectors = np.<span class="hljs-property">linalg</span>.<span class="hljs-title function_">eig</span>(Y)

<span class="hljs-title function_">print</span>(eigenvalues, end=<span class="hljs-string">'\n\n'</span>)
<span class="hljs-title function_">print</span>(eigenvectors)
</code></pre>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_32.png">
<p>지금까지 Numpy에서 다양한 수학 함수에 대해 많이 이야기했습니다. 실제로 더 설명하지 않은 것도 많이 있습니다. 더 탐구하고 싶다면 <a href="1">이 사이트</a>를 방문해보세요.</p>
<h1>11. 논리 및 비트 연산자</h1>
<h2>논리 연산자</h2>
<div class="content-ad"></div>
<p>이 기사의 맨 처음에, NumPy가 우리에게 boolean 자료형의 배열을 만들 수 있게 한다고 언급했지만, 이 주제에 대해 아직 자세히 다루지는 않았습니다. 그리고 이제, 이 장에서 그에 대해 이야기하고 싶습니다. 먼저, Z와 AA라는 이름으로 두 배열을 초기화하는 것으로 시작합시다.</p>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">38</span>
Z = np.<span class="hljs-title function_">array</span>([<span class="hljs-title class_">True</span>, <span class="hljs-title class_">True</span>, <span class="hljs-title class_">True</span>])
<span class="hljs-variable constant_">AA</span> = np.<span class="hljs-title function_">array</span>([<span class="hljs-title class_">False</span>, <span class="hljs-title class_">True</span>, <span class="hljs-title class_">True</span>])
</code></pre>
<p>boolean 연산을 수행하는 가장 간단한 방법은 <code>np.logical_and()</code>, <code>np.logical_or()</code>, 및 <code>np.logical_xor()</code>를 사용하는 것입니다. 우리가 이 함수들을 인수로써 같은 차원의 두 배열을 넣어주면, 이 함수들은 요소별 연산을 수행할 것입니다. 다음 예제를 참조해주세요.</p>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">39</span>
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">logical_and</span>(Z, <span class="hljs-variable constant_">AA</span>))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">logical_or</span>(Z, <span class="hljs-variable constant_">AA</span>))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">logical_xor</span>(Z, <span class="hljs-variable constant_">AA</span>))
</code></pre>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_33.png" alt="이미지"></p>
<p>OR 및 AND 연산자와 약간 비슷한 두 가지 특수 기능이 실제로 있는데, np.any()와 np.all()입니다. np.any()는 배열에 하나 이상의 True가 있으면 True를 반환합니다. 반면에 np.all()은 배열의 모든 요소가 True인 경우에만 True를 반환합니다. 아래 코드 블록 40에서는 배열 Z와 AA에 대해 이 두 함수를 어떻게 사용하는지 보여줍니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">40</span>
<span class="hljs-title function_">print</span>(<span class="hljs-string">'np.any(Z): '</span>, np.<span class="hljs-title function_">any</span>(Z))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'np.all(Z): '</span>, np.<span class="hljs-title function_">all</span>(Z), end=<span class="hljs-string">'\n\n'</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">'np.any(AA):'</span>, np.<span class="hljs-title function_">any</span>(<span class="hljs-variable constant_">AA</span>))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'np.all(AA):'</span>, np.<span class="hljs-title function_">all</span>(<span class="hljs-variable constant_">AA</span>))
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_34.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>우리는 실제로 np.any()와 np.all()을 좀 더 고급으로 사용할 수 있어요. 다음 코드 블록에서 #(1) 행에서, np.any()는 배열 AB에서 4보다 큰 숫자가 하나 이상 있는 경우 True를 반환할 거에요. 다음으로, #(2) 행에서는 AB의 모든 요소가 4보다 큰 경우에만 True를 반환할 거에요.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">41</span>
<span class="hljs-variable constant_">AB</span> = np.<span class="hljs-title function_">array</span>([<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">4</span>])

<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">any</span>(<span class="hljs-variable constant_">AB</span> > <span class="hljs-number">4</span>))    #(<span class="hljs-number">1</span>)
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">all</span>(<span class="hljs-variable constant_">AB</span> > <span class="hljs-number">4</span>))    #(<span class="hljs-number">2</span>)
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_35.png">
<h2>비트 연산자</h2>
<div class="content-ad"></div>
<p>비트 연산자는 논리 연산자만큼 직관적으로 보이지 않을 수 있습니다. 그럼에도 불구하고 두 가지의 기본 아이디어는 정확히 같습니다. 차이는 비트 연산자가 정수를 입력으로 사용한다는 점뿐입니다. 연산 중에 이러한 정수들은 이진으로 먼저 변환된 후 비트 단위로 작동됩니다. 아래 예시에서는 np.bitwise_and(), np.bitwise_or() 및 np.bitwise_xor()에 12와 13을 입력 인수로 넣었습니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">42</span>
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">bitwise_and</span>(<span class="hljs-number">12</span>, <span class="hljs-number">13</span>))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">bitwise_or</span>(<span class="hljs-number">12</span>, <span class="hljs-number">13</span>))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">bitwise_xor</span>(<span class="hljs-number">12</span>, <span class="hljs-number">13</span>))
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_36.png">
<p>위 함수들은 모두 처음에 12와 13을 이진으로 변환하여 작동합니다: 1100과 1101. 이 값을 AND 연산자로 처리하면 1100이 됩니다. 한편 OR 연산자는 1101을 반환하고 XOR는 0001을 반환합니다. 이진 수열을 10진수로 변환하면 최종 결과로 12, 13 및 1이 나옵니다.</p>
<div class="content-ad"></div>
<p>이 주제에 추가로, np.binary_repr()을 사용하여 10진수의 이진 표현을 확인할 수 있습니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">43</span>
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">binary_repr</span>(<span class="hljs-number">12</span>))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">binary_repr</span>(<span class="hljs-number">13</span>))
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_37.png" alt="이미지"></p>
<h1>12. 검색 및 정렬</h1>
<div class="content-ad"></div>
<p>특정 숫자를 찾을 때에는 불리언 인덱싱이라는 기법을 사용할 수 있어요. 이 방법을 마스킹처럼 생각할 수도 있죠. 여기서 저는 다음 코드 블록에서 초기화한 배열 AC를 이 아이디어로 설명하고 싶어요.</p>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">44</span>
<span class="hljs-variable constant_">AC</span> = np.<span class="hljs-title function_">array</span>([<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>])

mask = <span class="hljs-variable constant_">AC</span> > <span class="hljs-number">5</span>  #(<span class="hljs-number">1</span>)
mask
</code></pre>
<p>이름이 "mask"인 것은 사실상 AC와 길이가 정확히 같은 다른 배열이며, 여기에는 불리언 값만 포함돼요. 이렇게 배열을 생성하려면 (1) 라인에서 하는 것처럼 조건을 적용하면 되요. 이 코드 라인에서는 배열 AC의 모든 요소가 지정된 조건을 충족하는지 확인해요. 만약 조건을 충족한다면 해당 인덱스는 True로 할당돼요.</p>
<div class="content-ad"></div>
<p>실제 마스킹은 아래의 코드블록 45를 사용하여 실행됩니다. 이렇게 하면 우리의 기준을 충족하는 숫자만 출력됩니다.</p>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">45</span>
<span class="hljs-variable constant_">AC</span>[mask]
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_39.png">
<p>사실, 마스크를 별도의 변수에 저장할 필요는 없습니다. 대신, 다음과 같이 간단히 작성할 수 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">46</span>
<span class="hljs-variable constant_">AC</span>[<span class="hljs-variable constant_">AC</span> > <span class="hljs-number">5</span>]
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_40.png" alt="이미지"></p>
<p>논리 연산자도 사용할 수 있습니다. 다음 예시는 9를 제외한 모든 요소 중 5보다 큰 모든 요소를 출력합니다.</p>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">47</span>
<span class="hljs-variable constant_">AC</span>[(<span class="hljs-variable constant_">AC</span> > <span class="hljs-number">5</span>) &#x26; (<span class="hljs-variable constant_">AC</span> != <span class="hljs-number">9</span>)]
</code></pre>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_41.png" alt="Image"></p>
<p>실제로 np.where()를 사용하여 동일한 결과를 얻을 수 있습니다. 아래는 그 방법입니다. 결과 출력은 이전 것과 정확히 동일하기 때문에 나타내지 않습니다.</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># Codeblock 48</span>
AC[np.where((AC > <span class="hljs-number">5</span>) &#x26; (AC != <span class="hljs-number">9</span>))]
</code></pre>
<p>np.where() 함수 자체는 배열에서 지정된 기준을 충족하는 색인을 반환하여 작동합니다. 이 특정 경우에는 선택된 색인이 6, 8 및 6에 해당하는 5, 6 및 7이며, 이는 배열 AC에서의 값들과 일치합니다.</p>
<div class="content-ad"></div>
<h1>코드블록 49</h1>
<p>np.where((AC > 5) &#x26; (AC != 9))</p>
<h1>AC의 요소를 떠올려보세요: [9, 4, 5, 3, 2, 6, 8, 6, 5, 4, 5, 5, 3, 2].</h1>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_42.png" alt="이미지"></p>
<p>np.where() 함수는 3개의 인수를 전달할 때 더 유용할 수 있습니다. 즉, 조건, x 및 y를 정확한 순서로 전달합니다. 이러한 인수를 다음과 같이 생각할 수 있습니다: "조건이 True를 반환하면 x를 수행하고, 그렇지 않으면 y를 수행합니다." 이를 더 잘 설명하기 위해 다음 코드는 배열 AC의 모든 요소를 5보다 큰 경우 0으로 변환합니다. 그렇지 않으면 숫자가 2씩 추가됩니다.</p>
<h1>코드블록 50</h1>
<p>print(AC)
print(np.where(AC > 5, 0, AC+2))</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_43.png" alt="마스터링 넘파이 효율적인 배열 처리를 위한 포괄적인 가이드 22_43 이미지"></p>
<p>만약 배열 내의 고유한 값의 수를 찾는다는 요청이 오면, np.unique()를 사용할 수 있습니다. 이 함수를 사용하는 방법은 간단합니다. 배열을 유일한 매개변수로 넣기만 하면 됩니다. 또는 만약 원한다면, return_counts=True를 사용하여 해당 값들의 발생 횟수도 얻을 수 있습니다.</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># 코드블록 51</span>
np.unique(AC, return_counts=<span class="hljs-literal">True</span>)
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_44.png" alt="마스터링 넘파이 효율적인 배열 처리를 위한 포괄적인 가이드 22_44 이미지"></p>
<div class="content-ad"></div>
<h2>정렬</h2>
<p>함수의 이름이 나타내듯이, 배열을 정렬하는 데 필요한 것은 np.sort()입니다. 예를 들어, 여기서 배열 AD와 AE를 가지고 정렬 작업을 수행할 것입니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">52</span>
<span class="hljs-variable constant_">AD</span> = np.<span class="hljs-title function_">array</span>([<span class="hljs-number">77</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">99</span>,<span class="hljs-number">22</span>,<span class="hljs-number">88</span>,<span class="hljs-number">55</span>,<span class="hljs-number">11</span>,<span class="hljs-number">66</span>])
<span class="hljs-variable constant_">AE</span> = np.<span class="hljs-title function_">array</span>([<span class="hljs-string">"Elon Musk"</span>, <span class="hljs-string">"Bill Gates"</span>, <span class="hljs-string">"Joe Biden"</span>, <span class="hljs-string">"Barack Obama"</span>])

<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">sort</span>(<span class="hljs-variable constant_">AD</span>))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">sort</span>(<span class="hljs-variable constant_">AE</span>))
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_45.png">
<div class="content-ad"></div>
<p>위의 결과에서 두 배열이 오름차순으로 정렬되어 있음을 확인할 수 있습니다. 실제로 np.sort()에는 결과 배열을 내림차순으로 정렬할 수 있는 매개변수가 없습니다. 따라서, 만일 원한다면 np.flip()을 사용하여 내림차순으로 정렬할 수 있습니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">53</span>
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">flip</span>(np.<span class="hljs-title function_">sort</span>(<span class="hljs-variable constant_">AD</span>)))
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">flip</span>(np.<span class="hljs-title function_">sort</span>(<span class="hljs-variable constant_">AE</span>)))

### 대체 방법
# <span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">sort</span>(<span class="hljs-variable constant_">AD</span>)[::-<span class="hljs-number">1</span>])
# <span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">sort</span>(<span class="hljs-variable constant_">AE</span>)[::-<span class="hljs-number">1</span>])
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_46.png">
<p>만약 배열을 정렬하긴 하되 값이 아닌 인덱스만 필요한 경우, np.argsort()를 사용할 수 있습니다.</p>
<div class="content-ad"></div>
<h1>코드블록 54</h1>
<p>np.argsort(AD)</p>
<h1>AD의 요소들을 상기해 봅시다: [77, 33, 44, 99, 22, 88, 55, 11, 66].</h1>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_47.png" alt="이미지"></p>
<p>Figure 48에 표시된 출력은 기본적으로 AD 배열에서 가장 작은 숫자를 포함하는 7번째 인덱스를 보여줍니다. 이후로 AD[4], AD[1], 등이 따릅니다. 정렬이 제대로 작동하는지 확인하기 위해 np.argsort()의 전체 출력을 사용하여 다음과 같이 인덱싱을 수행할 수 있습니다:</p>
<h1>코드블록 55</h1>
<p>AD[np.argsort(AD)]</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_48.png">
<p>2차원 배열의 경우, axis 매개변수를 사용하여 정렬 방향을 결정할 수 있습니다. 이는 np.sort()와 np.argsort() 둘 다에 적용할 수 있습니다. 아래 배열 AF를 고려해 봅시다.</p>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">56</span>
<span class="hljs-variable constant_">AF</span> = np.<span class="hljs-title function_">array</span>([[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>],
               [<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>], 
               [<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>]])
</code></pre>
<p>만약 위 행렬을 열을 따라 정렬하고 싶다면, axis=0을 사용해야 합니다. 반면, axis=1은 행을 따라 정렬할 수 있게 합니다. 아래 코드블록 57는 그 방법을 보여줍니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">57</span>
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">sort</span>(<span class="hljs-variable constant_">AF</span>, axis=<span class="hljs-number">0</span>), end=<span class="hljs-string">'\n\n'</span>)
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">sort</span>(<span class="hljs-variable constant_">AF</span>, axis=<span class="hljs-number">1</span>))
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_49.png">
<p>이 장에 대해 이야기하고 싶은 마지막 주제는 실제로는 정렬과는 크게 관련이 없지만, 여전히 배열 순서와 관련이 있는 주제입니다. 이야기하려는 함수는 np.roll()인데, 이 함수를 사용하여 요소들에 대한 순환 이동을 수행할 수 있습니다. 이 아이디어를 설명하기 위해 먼저 한 시퀀스를 생성할 것입니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">58</span>
<span class="hljs-variable constant_">AG</span> = np.<span class="hljs-title function_">arange</span>(<span class="hljs-number">13</span>)
<span class="hljs-variable constant_">AG</span>
</code></pre>
<div class="content-ad"></div>
<p>아래는 codeblock를 사용하여 시퀀스를 shift 매개변수에 전달한 값에 따라 회전시킬 수 있습니다. 이 경우에는 AG를 오른쪽으로 3번(#(1)) 회전하고 왼쪽으로 3번(#(2)) 회전해 봅니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">59</span>
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">roll</span>(<span class="hljs-variable constant_">AG</span>, shift=<span class="hljs-number">3</span>))     #(<span class="hljs-number">1</span>)
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">roll</span>(<span class="hljs-variable constant_">AG</span>, shift=-<span class="hljs-number">3</span>))    #(<span class="hljs-number">2</span>)
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_51.png">
<div class="content-ad"></div>
<h1>13. 형태와 변경</h1>
<p>Python 리스트에서는 len() 함수를 사용하여 요소의 개수를 알 수 있습니다. 그러나 이 방법은 다차원 배열에는 효과적이지 않을 수 있습니다. 다차원 배열에서는 len() 함수가 가장 바깥쪽 차원만을 세기 때문입니다. 아래의 코드 블록에서 len() 함수가 5를 반환하는 것을 볼 수 있습니다. 이는 전체 배열 차원을 나타내지 않습니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">60</span>
<span class="hljs-variable constant_">AH</span> = np.<span class="hljs-title function_">array</span>([[<span class="hljs-number">0</span>,   <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>,  <span class="hljs-number">5</span>], 
               [<span class="hljs-number">6</span>,   <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>], 
               [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>], 
               [<span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>], 
               [<span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span>]])

<span class="hljs-title function_">len</span>(<span class="hljs-variable constant_">AH</span>)
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_52.png">
<div class="content-ad"></div>
<p>len() 함수와 다르게 Numpy 배열의 shape 속성을 활용하면 더 정확한 결과를 얻을 수 있어요. 아래의 코드블록 61의 출력 결과를 보면 배열 AH가 5개의 내부 배열로 구성되어 있고, 각 내부 배열은 6개의 요소로 이루어져 있음을 알 수 있어요. 이를 이전 챕터에서 설명했던 대로 5×6 크기의 행렬로 생각할 수 있어요. 또는 이미지 처리에 관심이 있는 경우, 이는 높이가 5이고 너비가 6인 픽셀을 가진 이미지에 해당해요.</p>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">61</span>
<span class="hljs-variable constant_">AH</span>.<span class="hljs-property">shape</span>
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_53.png" alt="이미지"></p>
<p>Numpy는 reshape() 메소드를 통해 배열의 모양을 변경할 수 있게 해줘요. 다음 예제에서는 AH를 사이즈 (3,10)으로 재구성하는 방법을 보여드릴게요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">62</span>
<span class="hljs-variable constant_">AH</span>.<span class="hljs-title function_">reshape</span>(<span class="hljs-number">3</span>,<span class="hljs-number">10</span>)
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_54.png" alt="Image"></p>
<p>배열을 재구성할 때 중요한 점은 재구성 전후의 총 요소 수가 일정해야 한다는 것입니다. 다시 말해, 배열 차원은 총 요소 수의 인수여야 합니다. 이 요구 사항을 충족하지 못하면 오류가 발생합니다.</p>
<p>배열 재구성은 2D 배열에만 국한되지 않습니다. 아래 코드 블록에서 배열을 3D로 변환하는 예시를 보여드리겠습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">63</span>
<span class="hljs-variable constant_">AH</span>.<span class="hljs-title function_">reshape</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_55.png" alt="이미지"></p>
<p>축에 대해 선택할 숫자를 확신할 수 없는 경우, 간단히 -1을 쓰면 Numpy가 해당 값을 자동으로 설정해줍니다. 그러나 한 번에 둘 이상의 -1을 전달할 수 없다는 점을 염두에 두세요.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">64</span>
<span class="hljs-variable constant_">AH</span>.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)
</code></pre>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_56.png">
<p>다음은 또 다른 예시입니다. 이 경우에는 배열을 30행 1열로 설정했습니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">65</span>
<span class="hljs-variable constant_">AH</span>.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_57.png">
<div class="content-ad"></div>
<p>만약 다차원 배열을 1차원 배열로 재구성하고 싶다면 flatten()이나 reshape(-1) 메소드를 사용할 수 있어요.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">66</span>
<span class="hljs-variable constant_">AH</span>.<span class="hljs-title function_">flatten</span>()

### 대안
# <span class="hljs-variable constant_">AH</span>.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>)
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_58.png">
<p>이 주제 외에도, 만약 배열에 빈 축을 추가하고 싶다면 np.newaxis를 사용할 수 있어요. 솔직히 말해서, 이 기술은 조금 직관적이지 않아요. 그래서, 제가 일반적으로 Codeblock 65에서 한 것과 같은 작업을 하는 데 np.reshape()를 사용해요.</p>
<div class="content-ad"></div>
<h1>코드 블록 67</h1>
<p>AH.flatten()[:, np.newaxis]</p>
<h3>대안</h3>
<h1>AH.flatten().reshape(-1,1)</h1>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_59.png" alt="이미지"></p>
<p>아래는 np.newaxis에 대한 또 다른 예제입니다. 여기서는 행에 새로운 축을 추가하는 데 사용했습니다.</p>
<h1>코드 블록 68</h1>
<p>AH.flatten()[np.newaxis, :]</p>
<h3>대안</h3>
<h1>AH.flatten().reshape(1,-1)</h1>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_60.png" alt="Image"></p>
<h1>14. Concatenation and Splitting</h1>
<p>파이썬 리스트에 새 요소를 추가하려면 append() 메소드를 사용할 수 있습니다. Numpy에서는 np.vstack(), np.hstack(), np.append(), np.concatenate()와 같은 다양한 대안이 있습니다. 이러한 함수들은 모두 여러 배열을 결합하는 것이라는 기본 아이디어를 가지고 있지만, 이러한 함수들은 각각 다른 용도를 가지고 있습니다.</p>
<p>이 주제를 논의하기 전에 먼저 두 개의 새 배열 AI와 AJ를 초기화하고 싶습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">69</span>
<span class="hljs-variable constant_">AI</span> = np.<span class="hljs-title function_">array</span>(np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randint</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, (<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)))
<span class="hljs-variable constant_">AJ</span> = np.<span class="hljs-title function_">array</span>(np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randint</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, (<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)))

<span class="hljs-title function_">print</span>(<span class="hljs-variable constant_">AI</span>, end=<span class="hljs-string">'\n\n'</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-variable constant_">AJ</span>)
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_61.png" alt="이미지"></p>
<p>두 배열을 수직으로 연결하여 결합하려면 np.vstack()을 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">70</span>
np.<span class="hljs-title function_">vstack</span>((<span class="hljs-variable constant_">AI</span>,<span class="hljs-variable constant_">AJ</span>))
</code></pre>
<div class="content-ad"></div>
<p>알수 있듯이, np.hstack()은 두 배열을 수평으로 쌓는 데 사용됩니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">71</span>
np.<span class="hljs-title function_">hstack</span>((<span class="hljs-variable constant_">AI</span>, <span class="hljs-variable constant_">AJ</span>))
</code></pre>
<div class="content-ad"></div>
<p>np.vstack()과 np.hstack() 함수는 여러 배열을 한 번에 쌓을 수 있습니다. 주의할 점은 배열의 열 수가 동일한 경우 수직 스택이 가능하다는 것입니다. 수평 스택의 경우, 배열의 행 수가 동일할 때만 작동합니다.</p>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">72</span>
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">vstack</span>((<span class="hljs-variable constant_">AI</span>,<span class="hljs-variable constant_">AJ</span>,<span class="hljs-variable constant_">AJ</span>,<span class="hljs-variable constant_">AJ</span>,<span class="hljs-variable constant_">AI</span>)), end=<span class="hljs-string">'\n\n'</span>)
<span class="hljs-title function_">print</span>(np.<span class="hljs-title function_">hstack</span>((<span class="hljs-variable constant_">AI</span>,<span class="hljs-variable constant_">AJ</span>,<span class="hljs-variable constant_">AJ</span>,<span class="hljs-variable constant_">AJ</span>,<span class="hljs-variable constant_">AI</span>)))
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_64.png">
<p>또한, np.append() 함수는 배열을 연결하기 전에 먼저 배열을 평평하게 만든 후 작동합니다. 따라서 결과적으로 얻는 출력물은 1차원 배열이 됩니다. 이 기본 동작과는 상관없이 np.append() 함수를 np.vstack() 및 np.hstack()와 동일하게 작동하도록 axis 매개변수를 사용할 수 있습니다.</p>
<div class="content-ad"></div>
<h1>코드 블록 73</h1>
<p>print(np.append(AI, AJ), end='\n\n')
print(np.append(AI, AJ, axis=0), end='\n\n')
print(np.append(AI, AJ, axis=1))</p>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_65.png">
<p>사실 np.append() 함수는 한 번에 두 개 이상의 배열을 결합할 수 없습니다. 만약 그렇게 하고 싶다면 np.concatenate()를 사용할 수 있습니다. axis 매개변수도 np.append()와 동일하게 작동합니다. 만약 axis에 값을 지정하지 않으면 np.concatenate() 함수는 수직 스택을 수행합니다.</p>
<h1>코드 블록 74</h1>
<p>print(np.concatenate([AI, AI, AI], axis=None), end='\n\n')
print(np.concatenate([AI, AI, AI]), end='\n\n')
print(np.concatenate([AI, AI, AI], axis=1))</p>
<div class="content-ad"></div>
 태그를 Markdown 형식으로 바꿔보세요.
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_66.png">
<h2>Splitting</h2>
<p>스택에 사용되는 것뿐만 아니라 Numpy는 분할을 위한 몇 가지 함수도 제공합니다. 아래의 배열 AK를 고려해 봅시다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Codeblock</span> <span class="hljs-number">75</span>
<span class="hljs-variable constant_">AK</span> = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randint</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, (<span class="hljs-number">20</span>))
<span class="hljs-variable constant_">AK</span>
</code></pre>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_67.png" alt="이미지"></p>
<p>np.split() 함수를 먼저 소개하겠습니다. 이 함수는 두 가지 주요 매개변수를 받습니다: ary (나눌 배열) 및 indices_or_sections (분할 지점). 다음 코드에서는 배열 AL을 인덱스 3과 5에서 나누어 세 개의 새 배열을 얻으려고 합니다. 각 배열은 원본 배열에서 0부터 2까지, 3부터 4까지, 5부터 19까지의 범위를 갖습니다.</p>
<pre><code class="hljs language-js"># 코드 블록 <span class="hljs-number">76</span>
np.<span class="hljs-title function_">split</span>(<span class="hljs-variable constant_">AK</span>, indices_or_sections=[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>])
</code></pre>
<p><img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_68.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>2D 배열을 나누려면 np.hsplit() 또는 np.vsplit()을 사용할 수 있습니다. 사실 np.split()에 축 매개변수를 전달하여 동일한 작업을 수행할 수도 있습니다. 주요 아이디어는 기본적으로 동일하지만, np.vsplit() 및 np.hsplit()을 사용하여 분할 지점은 각각 행 번호와 열 번호를 참조합니다. 이러한 두 함수를 배열 AL에 대해 시연하겠습니다.</p>
<pre><code class="hljs language-js"># 코드블록 <span class="hljs-number">77</span>
<span class="hljs-variable constant_">AL</span> = np.<span class="hljs-property">random</span>.<span class="hljs-title function_">randint</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, (<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))
<span class="hljs-variable constant_">AL</span>
</code></pre>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_69.png">
<p>아래는 np.vsplit()을 사용하는 방법입니다.</p>
<div class="content-ad"></div>
<h1>코드 블록 78</h1>
<p>np.vsplit(AL, [2,4])</p>
<h3>대안</h3>
<h1>np.split(AL, [2,4], axis=0)</h1>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_70.png">
<p>마지막으로 np.hsplit() 사용법입니다.</p>
<h1>코드 블록 79</h1>
<p>np.hsplit(AL, [3,4])</p>
<h3>대안</h3>
<h1>np.split(AL, [3,4], axis=1) #동등한</h1>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_71.png">
<h1>마무리</h1>
<p>드디어 끝났어요! 지금까지 저가 자주 사용하는 NumPy 함수들을 다뤄봤어요. 사실 더 설명하지 않은 기능들도 많이 남아 있어요. 하지만 걱정하지 마세요. 이제 모든 기초를 마스터했기 때문에 쉽게 배울 수 있을 거예요.</p>
<p>읽어 주셔서 감사해요. 이 글이 유용했기를 바라며, 다음 글에서 만나요. 안녕히 계세요!</p>
<div class="content-ad"></div>
<h1>참고 자료</h1>
<p>[1] Universal functions (ufunc). NumPy. <a href="https://numpy.org/doc/stable/reference/ufuncs.html" rel="nofollow" target="_blank">https://numpy.org/doc/stable/reference/ufuncs.html</a> [접속일: 2024년 1월 8일].</p>
<h1>쉽게 이해하기 🚀</h1>
<p>In Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:</p>
<div class="content-ad"></div>
<ul>
<li>작가를 칭찬하고 팔로우하려면 클랩을 눌러주세요! 👏</li>
<li>팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터</li>
<li>다른 플랫폼에서 저희를 만나보세요: CoFeed | Differ</li>
<li>더 많은 콘텐츠: PlainEnglish.io</li>
</ul><table></table>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"NumPy 마스터하기 효율적인 배열 처리 종합 가이드 Part 2","description":"","date":"2024-06-22 05:37","slug":"2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22","content":"\n\n## 빠르고 똑똑한 데이터 조작을 위한 NumPy의 힘을 활용하세요.\n\n# 소개\n\nNumPy 튜토리얼의 두 번째 파트에 오신 것을 환영합니다! 이전에는 다음 목록의 처음 7개 챕터를 다루었습니다. 이번 포스트에서는 8장부터 14장까지 진행하려고 합니다.\n\n- NumPy 설치\n- 배열 초기화\n- NumPy 배열 제한\n- 계산 속도와 메모리 사용량\n- 데이터 유형\n- 색인 및 슬라이싱\n- 배열 생성 함수\n- 난수 생성\n- 보기 및 복사\n- 수학 함수\n- 논리 및 비트 연산자\n- 검색 및 정렬\n- 모양 및 재구성\n- 연결 및 분할\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고: 이 문서에서 사용된 모든 자료는 제 GitHub 저장소에서 확인할 수 있습니다. 여기에 링크를 남깁니다.\n\n# 8. 랜덤 숫자\n\nNumPy를 사용하면 랜덤 숫자를 생성할 수 있습니다. 제 경우에는 이 기능을 사용하여 기계 학습 및 딥 러닝 모델에서 무작위 가중치를 초기화하는 데 사용해 보았습니다. 제가 처음부터 구현하려고 노력했던 그때입니다. 이러한 유형의 NumPy 기능에는 다른 응용 프로그램이 있을 것이라고 믿습니다.\n\n## 균일 분포\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 np.random.rand()로 시작해 봅시다. 이 함수는 [0.0, 1.0) 범위 내에서 균일 분포에서 무작위 숫자를 생성합니다. 이는 숫자가 정확히 0.0이 될 수는 있지만, 1.0에 근접할 뿐입니다. 이 함수를 사용하려면 우리가 원하는 배열의 형태를 전달해주기만 하면 됩니다. np.random.random()은 사실상 np.random.rand()와 동일합니다. 그러나 이 함수에 대한 입력은 튜플 형태여야 한다는 것을 염두에 두세요. 이 두 함수 중 어느 것이든 실제로 서로 교차하여 사용할 수 있습니다. 이는 단지 사용자의 취향에 따라 다를 뿐입니다.\n\n```js\n# Codeblock 1\nnp.random.rand(10,3)\n\n### 대안\n# np.random.random((10,3))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_0.png\" /\u003e\n\n아직 무작위 균일 분포와 관련하여, 더 많은 유연성이 필요하다면 np.random.uniform()를 사용할 수 있습니다. 이 함수를 사용하면 분포의 범위를 지정할 수 있어 [0.0, 1.0)에 고정되어 있는 것보다 더 유연해집니다. 아래 코드 블록에서 수를 90부터 100 사이로 범위 설정하는 방법을 보여드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 2\nnp.random.uniform(low=90, high=100, size=(5,5))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_1.png)\n\n만약 균일 분포에서 숫자를 np.histogram()에 넣으면, 모든 바구니(첫 번째 인덱스의 배열)에 유사한 빈도의 발생이 있음을 볼 수 있습니다. 아래 예제에서는 10개의 바구니로 분배된 50,000개의 숫자를 생성합니다. 이렇게 하면 각 바구니에 약 5,000개의 발생 횟수가 있습니다. 무작위 균일 함수의 세 가지 변형(np.random.rand(), np.random.random() 및 np.random.uniform())이 모두 이렇게 동작합니다.\n\n```js\n# 코드 블록 3\nnp.histogram(np.random.uniform(size=(50000)))\n\n### 유사한 결과를 제공합니다\n# np.histogram(np.random.rand(50000))\n# np.histogram(np.random.random(50000))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_2.png\" /\u003e\n\n## 정규 분포\n\n균일 분포 뿐만 아니라 np.random.randn()을 사용하여 정규 분포의 데이터도 생성할 수 있습니다. 여기서 전달할 수 있는 유일한 매개변수는 생성될 배열의 모양입니다.\n\n```js\n# 코드 블록 4\nnp.random.randn(6,4)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_3.png)\n\n안타깝게도 np.random.randn() 함수는 분포의 평균과 표준 편차를 변경할 수 있는 기능을 제공하지 않습니다. 이 함수에서 두 매개변수는 각각 0과 1로 고정되어 있습니다. 만약 이러한 값을 사용자 정의하고 싶다면 np.random.normal()을 사용해야 합니다. np.random.normal()에서는 평균을 loc 매개변수를 사용하여 조절하고, 표준편차는 scale 매개변수를 통해 수정할 수 있습니다.\n\n```js\n# Codeblock 5\nnp.random.normal(loc=8, scale=3, size=(5,5))\n```\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_4.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 앞서 사용한 np.histogram() 함수는 np.random.randn() 및 np.random.normal()에 의해 생성된 배열이 실제로 정규 분포를 따르는지 확인하는 데 사용될 수 있습니다. 아래 그림 6은 이를 설명하는데, 첫 번째 배열을 통해 가운데 있는 bin이 가장 빈도가 높음을 보여줍니다.\n\n```js\n# 코드 블록 6\nnp.histogram(np.random.normal(loc=0, scale=1, size=50000))\n\n### 비슷한 결과를 출력\n# np.histogram(np.random.randn(50000))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_5.png\" /\u003e\n\n지금까지 많은 유사한 함수가 존재한다는 것을 알아차렸습니다. 특히, 무작위 숫자를 생성하는 데 사용되는 함수들은 균일 및 정규 분포와 관련된 함수들이 많습니다. 그런 경우에는 np.random.uniform() 및 np.random.normal()만 사용하는 것을 권장드립니다. 두 함수가 가장 유연하기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 랜덤 정수\n\n우리가 이전에 논의한 함수들은 주로 랜덤 소수점 숫자를 생성하는 데 초점을 맞췄습니다. 실제로 Numpy는 랜덤 정수를 생성하는 함수인 np.random.randint()를 제공합니다. 이 함수의 매개변수 및 동작은 np.random.uniform()와 동일합니다. 지정된 범위 내의 모든 숫자는 선택될 확률이 완전히 동일합니다. 다시 말해, np.random.randint()는 숫자 선택을 위해 균일한 이산 분포를 사용합니다. 아래 예시에서 생성된 숫자들은 [5,10) 범위 내에 있을 것입니다 (즉, 10은 포함되지 않음).\n\n```js\n# Codeblock 7\nnp.random.randint(low=5, high=10, size=(20,3))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 배열 섞기\n\n다음으로 이야기하고 싶은 함수는 np.random.shuffle()입니다. 그러나 더 진행하기 전에 먼저 배열 K를 초기화하고 싶습니다.\n\n```js\n# 코드 블록 8\nK = np.random.randint(1, 30, size=10)\nK\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_7.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아마 알아챌 수 있었던 것처럼, np.random.shuffle()은 배열의 요소 순서를 섞어주는 함수입니다. 이 함수는 배열을 그 자리에서 섞기 때문에, 새로운 배열을 만드는 것이 아니라 원본 배열을 직접 섞는다는 것을 명심해 주세요.\n\n```js\n# 코드 블록 9\nprint('섞기 전 K\\t: ', K)\nnp.random.shuffle(K)\nprint('섞은 후 K\\t: ', K)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_8.png\" /\u003e\n\n## 랜덤 선택\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아직 배열 K와 작업 중이시군요. 이제 그 중에서 숫자를 무작위로 선택하는 방법을 알려드릴게요. np.random.choice()를 사용하면 간단하죠. 아래 코드 블록에서 함수를 사용하는 여러 예제를 보여드릴게요.\n\n```js\n# 코드 블록 10\nprint(np.random.choice(K), end='\\n\\n')                #(1)\nprint(np.random.choice(K, size=(2,3)), end='\\n\\n')    #(2)\nprint(np.random.choice(K, size=(2,4), replace=False)) #(3)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_9.png\" /\u003e\n\n(1)에서 지정된 줄에서, 함수에 배열만 전달하면 해당 배열에서 한 개의 숫자를 반환합니다. (2)의 size 매개변수를 사용하여 출력의 차원을 지정할 수도 있어요. 출력 결과를 보면 16이 두 번 나타나는 것을 알 수 있어요. 이는 기본적으로 함수가 복원 선택으로 무작위 숫자를 선택하기 때문인데요, 즉, 원래 배열에서 하나의 숫자가 여러 번 선택될 수 있습니다. 이를 원치 않는 경우, replace=False를 써서 다음과 같이 쓸 수 있어요. (3)에서처럼요. 이렇게 하면 결과 배열의 요소 수가 원본 배열의 요소 수보다 크면 안 된다는 점에 유의하세요. 궁금하시다면, 세 번째 출력에서 두 번 나타나는 12는 배열 K에 12가 실제로 두 번 나타난 것 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 시드\n\n생성된 무작위 숫자를 재현 가능하게 하는 경우가 많습니다. 이를 위해 np.random.seed()를 사용할 수 있습니다. 사용 방법은 간단합니다. 단지 인수로 숫자를 넣고 동일한 숫자를 출력을 정확히 원하는 노트북 셀에서 사용하면 됩니다. 다음 예제를 살펴봅시다. 여기서 np.random.randint()로 생성된 배열이 두 연속된 코드 블록에서 정확히 동일하게 나오기를 원합니다. 이 예에서 시드를 99로 설정하기로 결정했습니다(원하는 정수를 선택할 수 있습니다). np.random.randint()가 정확히 동일한 숫자를 반환하려면, 동일한 시드로 np.random.seed()를 다시 호출해야 합니다.\n\n```python\n# 코드 블록 11\nnp.random.seed(99)\nnp.random.randint(low=0, high=10, size=(2,5))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n# 코드 블록 12\nnp.random.seed(99)\nnp.random.randint(low=0, high=10, size=(2,5))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_11.png)\n\n# 9. 뷰(View)와 복사(Copy)\n\n## 뷰(View)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 변수에서 다른 변수로 배열을 할당할 때 Numpy의 성질을 고려해야 합니다. 다음 예제를 살펴보겠습니다.\n\n```js\n# 코드 블록 13\nL = np.array([55, 66, 77, 88, 99])\nM = L\nprint(M)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_12.png\" /\u003e\n\n여기서 배열 L을 변수 M에 할당했으므로 두 변수가 동일한 배열을 포함하게 됩니다. 다음으로, 아래 코드 블록 14를 사용하여 M의 0번 인덱스를 변경하려고 합니다. 그러나 M의 첫 번째 요소만 바꾸려고 했지만 배열 L의 요소도 변경됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 14\nM[0] = 15\nprint('L:', L)\nprint('M:', M)\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_13.png)\n\n이 결과가 나온 이유는 M이 단순히 L의 \"뷰(view)\"일 뿐이기 때문입니다. 다시 말해 위에서 보여준 방법은 배열을 복사하는 것이 아니라 두 변수가 여전히 \"연결\"되어 있기 때문입니다.\n\n## 복사\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 경우가 발생하지 않도록하려면, M에 할당할 때 copy() 메서드를 L에 넣으면 됩니다. 이렇게 하면 M에 저장된 배열이 완전히 다른 배열이 되어, 하나의 배열에 대한 수정이 다른 배열에 영향을 미치지 않도록 보장됩니다.\n\n```js\n# Codeblock 15\nL = np.array([55, 66, 77, 88, 99])\nM = L.copy()\nM[0] = 15\n\nprint('L:', L)\nprint('M:', M)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_14.png\" /\u003e\n\n# 10. 수학 함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기본 수학 연산\n\n이 장에서는 Numpy의 수학 기능을 사용하는 방법에 대해 알아보려고 합니다. 시작하기 전에 사전에 배열 N과 O를 초기화해 봅시다.\n\n```js\n# Codeblock 16\nN = np.array([1,2,3], dtype='int32')\nO = np.array([4,5,6], dtype='int32')\n```\n\n우리는 가장 기초적인 것부터 시작할 것입니다: 덧셈, 뺄셈, 곱셈 및 나눗셈입니다. Numpy에서 배열에 이러한 연산자를 적용하면 연산은 요소별로 수행됩니다. 이러한 이유로 배열 피연산자의 차원이 정확히 일치하는지 확인해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드 블록 17\nprint(N + O)\nprint(N - O)\nprint(N * O)\nprint(N / O)\n\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_15.png)\n\n위의 코드블록 17에서 소개된 방법들은 Numpy 배열에서만 작동합니다. 리스트에 똑같은 작업을 시도하면 모든 예제가 오류가 발생할 것이며, 덧셈 연산은 두 리스트를 연결할 것입니다.\n\n대안으로 np.add(), np.subtract(), np.multiply() 및 np.divide()와 같은 Numpy에서 제공하는 함수들을 사용할 수도 있습니다. 연산자 기호와 함수 모두 정확히 같은 결과를 생성합니다. 따라서 이 경우에는 개인 취향에 따라 선택하면 됩니다. 아래 코드블록은 이러한 함수들을 어떻게 사용하는지 보여줍니다. 결과 출력은 Figure 16에 표시된 것과 완전히 동일합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Codeblock 18\nprint(np.add(N, O))\nprint(np.subtract(N, O))\nprint(np.multiply(N, O))\nprint(np.divide(N, O))\n```\n\n넘파이(Numpy)에서 \"브로드캐스팅(broadcasting)\"이라는 개념이 있습니다. 이는 기본적으로 크기가 다른 배열 또는 배열과 스칼라 간의 연산을 수행할 수 있다는 것을 의미합니다. 다음 경우에는 숫자 5가 배열 N의 모든 요소로 브로드캐스팅된다고 말할 수 있습니다.\n\n```js\n# Codeblock 19\nprint(N + 5)\nprint(N - 5)\nprint(N * 5)\nprint(N / 5)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_16.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 다음으로 논의하고 싶은 것은 행렬 곱셈입니다. 이전에 언급한 대로, 네 가지 기본 수학 연산 함수는 요소별로 작동합니다. 이는 np.multiply() 함수가 행렬 곱셈을 위해 의도된 것이 아니라는 것을 의미합니다. 대신 np.matmul()을 사용해야 합니다. 이 경우 두 입력 행렬이 연산 가능한지 확인해야 합니다. 다음 예제에서는 각각 크기가 (4,3)과 (3,2)인 배열 O와 P 사이의 곱셈을 수행합니다.\n\n```js\n# 코드블록 20\nO = np.array([[2, 1, 0], \n              [5, 4, 3], \n              [8, 7, 6], \n              [1, 0, 9]])\n\nP = np.array([[4, 3], \n              [6, 5], \n              [8, 7]])\n\nnp.matmul(O, P)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_17.png\" /\u003e\n\n여전히 기본 수학 연산과 관련된 다른 함수에는 np.sign(), np.negative() 및 np.abs()가 있습니다. 이러한 함수들의 사용법을 배열 Q에 대해 보여드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 21\nQ = np.array([-56, 92, -24, -66, 72, -75, 90, 0, 32, 51])\n\nprint(np.sign(Q))\nprint(np.negative(Q))\nprint(np.abs(Q))      # 대안: np.absolute()\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_18.png)\n\n함수 이름대로, np.sign()은 배열의 각 요소의 부호를 취하는 데 사용됩니다. -1, 0 또는 1만 표시됩니다. 다음으로, np.negative()를 사용하여 숫자의 부호를 뒤집을 수 있습니다. 위의 예시에서 -56은 56이 되고, 92는 -92가 됩니다. 마지막으로, np.abs() 또는 np.absolute()를 사용하여 숫자의 절대값을 취할 수 있습니다.\n\n## 최대공약수(GCD)와 최소공배수(LCM)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최대공약수(GCD)와 최소공배수(LCM)는 Numpy에서 각각 np.gcd()와 np.lcm()으로 구현되어 있습니다. 이러한 함수들을 사용하려면, 간단히 두 숫자나 배열을 입력인수로 넣으면 됩니다.\n\n```js\n# 코드블록 22\nprint(np.gcd(81, 72))    #(1)\nprint(np.lcm([3, 6, 9], 24))    #(2)\nprint(np.lcm([3, 12, 9], [24, 16, 3]))    #(3)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_19.png\" /\u003e\n\n위 코드블록 22의 예제를 살펴봅시다. #(1)으로 표시된 줄은 81과 72의 최대공약수인 하나의 숫자를 반환합니다. 한편, #(2) 줄에서는 숫자 24가 첫 번째 인수에 브로드캐스트되어 LCM이 24와 목록의 각 숫자 간에 계산됩니다. 마지막으로, 두 인수에 대해 리스트를 전달하면, LCM 또는 GCD 계산이 요소별로 수행됩니다 (#(3)).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 지수 함수\n\nnp.power() 함수를 사용하여 지수 연산을 수행할 수 있습니다. 이 함수는 두 개의 입력을 받습니다: 밑수와 지수입니다. 해당 함수는 지수로 분수를 전달하여 루트를 계산할 수 있도록 매우 유연합니다.\n\n```js\n# Codeblock 23\nprint(np.power(8, 3))\nprint(np.power([1,2,3,4], 2))\nprint(np.power(144, 1/2))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_20.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n유연성이 있긴 하지만, np.power()은 실제로 연산 속도에 있어서 최상이라고 할 수는 없습니다. 실제로 더 빠른 계산을 제공하는 몇 가지 특정 목적을 위한 대안들이 있습니다. np.square(), np.sqrt(), np.cbrt() 및 np.exp()가 그 예입니다. 아래 코드 블록은 np.power()와 이러한 함수들의 동등한 사용법을 보여줍니다.\n\n```js\n# 코드 블록 24\nprint(np.square(6))             # np.power(6,2)와 동일\nprint(np.sqrt([144,16,9,4]))    # np.power([144,16,9,4], 1/2)와 동일\nprint(np.cbrt([343,27]))        # np.power([343,27], 1/3)와 동일\nprint(np.exp([2,3,4]))          # np.power(np.e, [2,3,4])와 동일\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_21.png\" /\u003e\n\n## 각도 변환 및 삼각함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n넘파이에서는 삼각함수를 사용할 수 있습니다. np.sin(), np.cos() 및 np.tan()을 사용할 때 주의해야 할 점은 이 함수들이 라디안 단위의 각도를 입력으로 받는다는 것입니다. 따라서 각도가 도(degree)로 주어진 경우 np.deg2rad()를 사용하여 라디안으로 변환해야 합니다. 아래 Codeblock 25에서는 각도를 도와 라디안으로 변환하는 방법을 보여줍니다.\n\n```js\n# Codeblock 25\nR = np.array([0, 90, 180, 270])    # 각도 (도)가 담긴 배열\nS = np.array([0, np.pi/2, np.pi, np.pi*3/2])    # 각도 (라디안)가 담긴 배열\n\nprint(np.deg2rad(R))\nprint(np.rad2deg(S))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_22.png\" /\u003e\n\n각도 변환 방법을 이해했으니, 이제 삼각함수의 사용법을 실제로 보여드리겠습니다. 다음 코드에서 숫자 0, 45, 60이 각도 (도)를 나타낸다고 가정합니다. 이 숫자들은 라디안으로 변환된 후 배열 T에 저장되어 np.sin(), np.cos(), np.tan()의 입력으로 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 26\nT = np.deg2rad([0, 45, 60])\n\nprint(np.sin(T))\nprint(np.cos(T))\nprint(np.tan(T))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_23.png)\n\n## 로그 함수\n\n로그 함수에 대해 이야기할 때, 적어도 가장 기본적이라고 생각되는 세 가지 함수가 있습니다. 아래 코드 블록 27에서는 배열 U에 np.log(), np.log2() 및 np.log10() 함수를 어떻게 사용하는지 보여줍니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드 블록 27\nU = [1, 2, 10, np.e]\n\nprint(np.log(U))\nprint(np.log2(U))\nprint(np.log10(U))\n\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_24.png)\n\nNumpy에서 np.log()는 수학의 ln() 함수와 동일합니다 (밑이 e인 로그). 한편, np.log2()와 np.log10()은 각각 밑이 2와 10인 로그입니다.\n\n## 통계 함수\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 숫자 데이터 분포를 가지고 있다면, 통계적 특성을 계산하여 추가 분석을 수행할 수 있습니다. 우리에게 운이 좋은 것은 Numpy가 이 작업을 쉽게 수행할 수 있는 다양한 함수를 제공해준다는 것입니다. 이와 관련된 모든 함수들 — 아마도 이들 모두가 명확히 이해할 만한 함수들로 보입니다 — 이 코드 블록 28에 나와 있습니다.\n\n```js\n# 코드 블록 28\nV = np.array([1, 5, 4, 6, 8, 5, 4, 3, 2, 4, 7, 9, 5, 4, 3, 2, 0, 7, 9])\n\nprint('sum\\t:', np.sum(V))\nprint('mean\\t:', np.mean(V))\nprint('median\\t:', np.median(V))\nprint('var\\t:', np.var(V))\nprint('stddev\\t:', np.std(V))\nprint('q1\\t:', np.quantile(V, 0.25))\nprint('q2\\t:', np.quantile(V, 0.5))\nprint('q3\\t:', np.quantile(V, 0.75))\nprint('min\\t:', np.min(V))\nprint('max\\t:', np.max(V))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_25.png\" /\u003e\n\n이 주제 외에도 통계 측정과 직접적인 관련이 없지만 여전히 유용할 수 있는 두 가지 다른 함수가 실제로 있습니다. 말하고자 하는 두 함수는 np.argmin()과 np.argmax()인데, 이 두 함수는 배열에서 가장 작은 값과 가장 큰 값이 들어 있는 인덱스를 반환합니다. 가장 작거나 큰 값이 여러 개인 경우, 이 두 함수는 가장 낮은 인덱스를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 29\nprint('argmin\\t:', np.argmin(V))\nprint('argmax\\t:', np.argmax(V))\n```\n\n![image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_26.png)\n\n## 선형 대수\n\n넘파이는 선형 대수 계산을 수행하는데 다양한 도구를 제공합니다. 여기서 여러분께 보여드릴 수 있는 몇 가지 사항들이 있습니다. 코드 블록 30에 표시된 두 배열이 있다고 가정해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 30\nW = np.array([10, 20, 30, 40])\nX = np.array([3, 4, 5, 6])\n```\n\n넘파이에서 1차원 배열은 벡터로 생각할 수 있습니다. 따라서 np.dot()을 사용하여 W와 X의 내적을 계산할 수 있습니다.\n\n```js\n# 코드 블록 31\nnp.dot(W, X)\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_27.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 NumPy는 np.inner() 및 np.outer()를 통해 내적과 외적을 계산할 수 있도록 합니다.\n\n```python\n# Codeblock 32\nprint(np.inner(W, X))\nprint(np.outer(W, X))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_28.png\" /\u003e\n\n이제 2D 배열을 다루고 있다면 우리가 할 수 있는 것들에 대해 좀 더 자세히 알아보겠습니다. 이를 시연하기 전에 배열 Y를 미리 초기화하고 싶습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 33\nY = np.array([[2, 1, 0],\n              [0, 4, 5],\n              [2, 6, 3]])\n```\n\n행렬의 전치(transpose)를 얻으려면 np.transpose()를 사용하거나 해당 행렬의 T 속성을 사용할 수 있습니다. 아래 코드 블록을 확인해보세요.\n\n```js\n# 코드 블록 34\nnp.transpose(Y)\n\n### 대안\n# Y.T\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_29.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n넘파이는 행렬의 역행렬을 계산하는 함수도 제공합니다. `np.linalg.inv()`를 사용하면 행렬 Y의 역행렬을 계산할 수 있습니다. \n\n```js\n# 코드 블록 35\nnp.linalg.inv(Y)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_30.png\" /\u003e\n\n그러나 중요한 점은 행렬이 특이행렬일 때, 즉 행렬식이 0일 때 `np.linalg.inv()`가 오류를 반환한다는 것입니다. 따라서 역행렬을 계산하기 전에 행렬의 행렬식 값을 확인하는 것이 좋은 아이디어라고 생각합니다. 확인을 위해 `np.linalg.det()`을 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Codeblock 36\nnp.linalg.det(Y)\n```\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_31.png)\n\n더불어 Numpy는 np.linalg.eig()를 사용하여 고유값과 고유벡터를 계산할 수 있습니다. 이 함수는 두 값 모두 반환하므로 출력을 위해 두 변수를 할당해야 합니다.\n\n```js\n# Codeblock 37\neigenvalues, eigenvectors = np.linalg.eig(Y)\n\nprint(eigenvalues, end='\\n\\n')\nprint(eigenvectors)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_32.png\" /\u003e\n\n지금까지 Numpy에서 다양한 수학 함수에 대해 많이 이야기했습니다. 실제로 더 설명하지 않은 것도 많이 있습니다. 더 탐구하고 싶다면 [이 사이트](1)를 방문해보세요.\n\n# 11. 논리 및 비트 연산자\n\n## 논리 연산자\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사의 맨 처음에, NumPy가 우리에게 boolean 자료형의 배열을 만들 수 있게 한다고 언급했지만, 이 주제에 대해 아직 자세히 다루지는 않았습니다. 그리고 이제, 이 장에서 그에 대해 이야기하고 싶습니다. 먼저, Z와 AA라는 이름으로 두 배열을 초기화하는 것으로 시작합시다.\n\n```js\n# 코드블록 38\nZ = np.array([True, True, True])\nAA = np.array([False, True, True])\n```\n\nboolean 연산을 수행하는 가장 간단한 방법은 `np.logical_and()`, `np.logical_or()`, 및 `np.logical_xor()`를 사용하는 것입니다. 우리가 이 함수들을 인수로써 같은 차원의 두 배열을 넣어주면, 이 함수들은 요소별 연산을 수행할 것입니다. 다음 예제를 참조해주세요.\n\n```js\n# 코드블록 39\nprint(np.logical_and(Z, AA))\nprint(np.logical_or(Z, AA))\nprint(np.logical_xor(Z, AA))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_33.png)\n\nOR 및 AND 연산자와 약간 비슷한 두 가지 특수 기능이 실제로 있는데, np.any()와 np.all()입니다. np.any()는 배열에 하나 이상의 True가 있으면 True를 반환합니다. 반면에 np.all()은 배열의 모든 요소가 True인 경우에만 True를 반환합니다. 아래 코드 블록 40에서는 배열 Z와 AA에 대해 이 두 함수를 어떻게 사용하는지 보여줍니다.\n\n```js\n# 코드 블록 40\nprint('np.any(Z): ', np.any(Z))\nprint('np.all(Z): ', np.all(Z), end='\\n\\n')\nprint('np.any(AA):', np.any(AA))\nprint('np.all(AA):', np.all(AA))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_34.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 실제로 np.any()와 np.all()을 좀 더 고급으로 사용할 수 있어요. 다음 코드 블록에서 #(1) 행에서, np.any()는 배열 AB에서 4보다 큰 숫자가 하나 이상 있는 경우 True를 반환할 거에요. 다음으로, #(2) 행에서는 AB의 모든 요소가 4보다 큰 경우에만 True를 반환할 거에요.\n\n```js\n# Codeblock 41\nAB = np.array([2, 0, 3, -5, 5, -1, 2, -4])\n\nprint(np.any(AB \u003e 4))    #(1)\nprint(np.all(AB \u003e 4))    #(2)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_35.png\" /\u003e\n\n## 비트 연산자\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비트 연산자는 논리 연산자만큼 직관적으로 보이지 않을 수 있습니다. 그럼에도 불구하고 두 가지의 기본 아이디어는 정확히 같습니다. 차이는 비트 연산자가 정수를 입력으로 사용한다는 점뿐입니다. 연산 중에 이러한 정수들은 이진으로 먼저 변환된 후 비트 단위로 작동됩니다. 아래 예시에서는 np.bitwise_and(), np.bitwise_or() 및 np.bitwise_xor()에 12와 13을 입력 인수로 넣었습니다.\n\n```js\n# Codeblock 42\nprint(np.bitwise_and(12, 13))\nprint(np.bitwise_or(12, 13))\nprint(np.bitwise_xor(12, 13))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_36.png\" /\u003e\n\n위 함수들은 모두 처음에 12와 13을 이진으로 변환하여 작동합니다: 1100과 1101. 이 값을 AND 연산자로 처리하면 1100이 됩니다. 한편 OR 연산자는 1101을 반환하고 XOR는 0001을 반환합니다. 이진 수열을 10진수로 변환하면 최종 결과로 12, 13 및 1이 나옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 주제에 추가로, np.binary_repr()을 사용하여 10진수의 이진 표현을 확인할 수 있습니다.\n\n```js\n# 코드 블록 43\nprint(np.binary_repr(12))\nprint(np.binary_repr(13))\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_37.png)\n\n# 12. 검색 및 정렬\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 숫자를 찾을 때에는 불리언 인덱싱이라는 기법을 사용할 수 있어요. 이 방법을 마스킹처럼 생각할 수도 있죠. 여기서 저는 다음 코드 블록에서 초기화한 배열 AC를 이 아이디어로 설명하고 싶어요.\n\n```js\n# 코드블록 44\nAC = np.array([9, 4, 5, 3, 2, 6, 8, 6, 5, 4, 5, 5, 3, 2])\n\nmask = AC \u003e 5  #(1)\nmask\n```\n\n이름이 \"mask\"인 것은 사실상 AC와 길이가 정확히 같은 다른 배열이며, 여기에는 불리언 값만 포함돼요. 이렇게 배열을 생성하려면 (1) 라인에서 하는 것처럼 조건을 적용하면 되요. 이 코드 라인에서는 배열 AC의 모든 요소가 지정된 조건을 충족하는지 확인해요. 만약 조건을 충족한다면 해당 인덱스는 True로 할당돼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 마스킹은 아래의 코드블록 45를 사용하여 실행됩니다. 이렇게 하면 우리의 기준을 충족하는 숫자만 출력됩니다.\n\n```js\n# 코드블록 45\nAC[mask]\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_39.png\" /\u003e\n\n사실, 마스크를 별도의 변수에 저장할 필요는 없습니다. 대신, 다음과 같이 간단히 작성할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드블록 46\nAC[AC \u003e 5]\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_40.png)\n\n논리 연산자도 사용할 수 있습니다. 다음 예시는 9를 제외한 모든 요소 중 5보다 큰 모든 요소를 출력합니다.\n\n```js\n# 코드블록 47\nAC[(AC \u003e 5) \u0026 (AC != 9)]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_41.png)\n\n실제로 np.where()를 사용하여 동일한 결과를 얻을 수 있습니다. 아래는 그 방법입니다. 결과 출력은 이전 것과 정확히 동일하기 때문에 나타내지 않습니다.\n\n```python\n# Codeblock 48\nAC[np.where((AC \u003e 5) \u0026 (AC != 9))]\n```\n\nnp.where() 함수 자체는 배열에서 지정된 기준을 충족하는 색인을 반환하여 작동합니다. 이 특정 경우에는 선택된 색인이 6, 8 및 6에 해당하는 5, 6 및 7이며, 이는 배열 AC에서의 값들과 일치합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드블록 49\nnp.where((AC \u003e 5) \u0026 (AC != 9))\n\n# AC의 요소를 떠올려보세요: [9, 4, 5, 3, 2, 6, 8, 6, 5, 4, 5, 5, 3, 2].\n\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_42.png)\n\nnp.where() 함수는 3개의 인수를 전달할 때 더 유용할 수 있습니다. 즉, 조건, x 및 y를 정확한 순서로 전달합니다. 이러한 인수를 다음과 같이 생각할 수 있습니다: \"조건이 True를 반환하면 x를 수행하고, 그렇지 않으면 y를 수행합니다.\" 이를 더 잘 설명하기 위해 다음 코드는 배열 AC의 모든 요소를 5보다 큰 경우 0으로 변환합니다. 그렇지 않으면 숫자가 2씩 추가됩니다.\n\n\n# 코드블록 50\nprint(AC)\nprint(np.where(AC \u003e 5, 0, AC+2))\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![마스터링 넘파이 효율적인 배열 처리를 위한 포괄적인 가이드 22_43 이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_43.png)\n\n만약 배열 내의 고유한 값의 수를 찾는다는 요청이 오면, np.unique()를 사용할 수 있습니다. 이 함수를 사용하는 방법은 간단합니다. 배열을 유일한 매개변수로 넣기만 하면 됩니다. 또는 만약 원한다면, return_counts=True를 사용하여 해당 값들의 발생 횟수도 얻을 수 있습니다.\n\n```python\n# 코드블록 51\nnp.unique(AC, return_counts=True)\n```\n\n![마스터링 넘파이 효율적인 배열 처리를 위한 포괄적인 가이드 22_44 이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_44.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 정렬\n\n함수의 이름이 나타내듯이, 배열을 정렬하는 데 필요한 것은 np.sort()입니다. 예를 들어, 여기서 배열 AD와 AE를 가지고 정렬 작업을 수행할 것입니다.\n\n```js\n# 코드 블록 52\nAD = np.array([77,33,44,99,22,88,55,11,66])\nAE = np.array([\"Elon Musk\", \"Bill Gates\", \"Joe Biden\", \"Barack Obama\"])\n\nprint(np.sort(AD))\nprint(np.sort(AE))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_45.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 결과에서 두 배열이 오름차순으로 정렬되어 있음을 확인할 수 있습니다. 실제로 np.sort()에는 결과 배열을 내림차순으로 정렬할 수 있는 매개변수가 없습니다. 따라서, 만일 원한다면 np.flip()을 사용하여 내림차순으로 정렬할 수 있습니다.\n\n```js\n# Codeblock 53\nprint(np.flip(np.sort(AD)))\nprint(np.flip(np.sort(AE)))\n\n### 대체 방법\n# print(np.sort(AD)[::-1])\n# print(np.sort(AE)[::-1])\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_46.png\" /\u003e\n\n만약 배열을 정렬하긴 하되 값이 아닌 인덱스만 필요한 경우, np.argsort()를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드블록 54\nnp.argsort(AD)\n\n# AD의 요소들을 상기해 봅시다: [77, 33, 44, 99, 22, 88, 55, 11, 66].\n\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_47.png)\n\nFigure 48에 표시된 출력은 기본적으로 AD 배열에서 가장 작은 숫자를 포함하는 7번째 인덱스를 보여줍니다. 이후로 AD[4], AD[1], 등이 따릅니다. 정렬이 제대로 작동하는지 확인하기 위해 np.argsort()의 전체 출력을 사용하여 다음과 같이 인덱싱을 수행할 수 있습니다:\n\n\n# 코드블록 55\nAD[np.argsort(AD)]\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_48.png\" /\u003e\n\n2차원 배열의 경우, axis 매개변수를 사용하여 정렬 방향을 결정할 수 있습니다. 이는 np.sort()와 np.argsort() 둘 다에 적용할 수 있습니다. 아래 배열 AF를 고려해 봅시다.\n\n```js\n# 코드블록 56\nAF = np.array([[3, 1, 5, 7],\n               [8, 9, 3, 2], \n               [4, 8, 2, 6]])\n```\n\n만약 위 행렬을 열을 따라 정렬하고 싶다면, axis=0을 사용해야 합니다. 반면, axis=1은 행을 따라 정렬할 수 있게 합니다. 아래 코드블록 57는 그 방법을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Codeblock 57\nprint(np.sort(AF, axis=0), end='\\n\\n')\nprint(np.sort(AF, axis=1))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_49.png\" /\u003e\n\n이 장에 대해 이야기하고 싶은 마지막 주제는 실제로는 정렬과는 크게 관련이 없지만, 여전히 배열 순서와 관련이 있는 주제입니다. 이야기하려는 함수는 np.roll()인데, 이 함수를 사용하여 요소들에 대한 순환 이동을 수행할 수 있습니다. 이 아이디어를 설명하기 위해 먼저 한 시퀀스를 생성할 것입니다.\n\n```js\n# Codeblock 58\nAG = np.arange(13)\nAG\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 codeblock를 사용하여 시퀀스를 shift 매개변수에 전달한 값에 따라 회전시킬 수 있습니다. 이 경우에는 AG를 오른쪽으로 3번(#(1)) 회전하고 왼쪽으로 3번(#(2)) 회전해 봅니다.\n\n```js\n# Codeblock 59\nprint(np.roll(AG, shift=3))     #(1)\nprint(np.roll(AG, shift=-3))    #(2)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_51.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 13. 형태와 변경\n\nPython 리스트에서는 len() 함수를 사용하여 요소의 개수를 알 수 있습니다. 그러나 이 방법은 다차원 배열에는 효과적이지 않을 수 있습니다. 다차원 배열에서는 len() 함수가 가장 바깥쪽 차원만을 세기 때문입니다. 아래의 코드 블록에서 len() 함수가 5를 반환하는 것을 볼 수 있습니다. 이는 전체 배열 차원을 나타내지 않습니다.\n\n```js\n# 코드 블록 60\nAH = np.array([[0,   1,  2,  3,  4,  5], \n               [6,   7,  8,  9, 10, 11], \n               [12, 13, 14, 15, 16, 17], \n               [18, 19, 20, 21, 22, 23], \n               [24, 25, 26, 27, 28, 29]])\n\nlen(AH)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_52.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nlen() 함수와 다르게 Numpy 배열의 shape 속성을 활용하면 더 정확한 결과를 얻을 수 있어요. 아래의 코드블록 61의 출력 결과를 보면 배열 AH가 5개의 내부 배열로 구성되어 있고, 각 내부 배열은 6개의 요소로 이루어져 있음을 알 수 있어요. 이를 이전 챕터에서 설명했던 대로 5×6 크기의 행렬로 생각할 수 있어요. 또는 이미지 처리에 관심이 있는 경우, 이는 높이가 5이고 너비가 6인 픽셀을 가진 이미지에 해당해요.\n\n```js\n# 코드블록 61\nAH.shape\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_53.png)\n\nNumpy는 reshape() 메소드를 통해 배열의 모양을 변경할 수 있게 해줘요. 다음 예제에서는 AH를 사이즈 (3,10)으로 재구성하는 방법을 보여드릴게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Codeblock 62\nAH.reshape(3,10)\n```\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_54.png)\n\n배열을 재구성할 때 중요한 점은 재구성 전후의 총 요소 수가 일정해야 한다는 것입니다. 다시 말해, 배열 차원은 총 요소 수의 인수여야 합니다. 이 요구 사항을 충족하지 못하면 오류가 발생합니다.\n\n배열 재구성은 2D 배열에만 국한되지 않습니다. 아래 코드 블록에서 배열을 3D로 변환하는 예시를 보여드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드 블록 63\nAH.reshape(2,3,5)\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_55.png)\n\n축에 대해 선택할 숫자를 확신할 수 없는 경우, 간단히 -1을 쓰면 Numpy가 해당 값을 자동으로 설정해줍니다. 그러나 한 번에 둘 이상의 -1을 전달할 수 없다는 점을 염두에 두세요.\n\n```js\n# 코드 블록 64\nAH.reshape(-1,5)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_56.png\" /\u003e\n\n다음은 또 다른 예시입니다. 이 경우에는 배열을 30행 1열로 설정했습니다.\n\n```js\n# 코드 블록 65\nAH.reshape(-1,1)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_57.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 다차원 배열을 1차원 배열로 재구성하고 싶다면 flatten()이나 reshape(-1) 메소드를 사용할 수 있어요.\n\n```js\n# Codeblock 66\nAH.flatten()\n\n### 대안\n# AH.reshape(-1)\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_58.png\" /\u003e\n\n이 주제 외에도, 만약 배열에 빈 축을 추가하고 싶다면 np.newaxis를 사용할 수 있어요. 솔직히 말해서, 이 기술은 조금 직관적이지 않아요. 그래서, 제가 일반적으로 Codeblock 65에서 한 것과 같은 작업을 하는 데 np.reshape()를 사용해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드 블록 67\nAH.flatten()[:, np.newaxis]\n\n### 대안\n# AH.flatten().reshape(-1,1)\n\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_59.png)\n\n아래는 np.newaxis에 대한 또 다른 예제입니다. 여기서는 행에 새로운 축을 추가하는 데 사용했습니다.\n\n\n# 코드 블록 68\nAH.flatten()[np.newaxis, :]\n\n### 대안\n# AH.flatten().reshape(1,-1)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_60.png)\n\n# 14. Concatenation and Splitting\n\n파이썬 리스트에 새 요소를 추가하려면 append() 메소드를 사용할 수 있습니다. Numpy에서는 np.vstack(), np.hstack(), np.append(), np.concatenate()와 같은 다양한 대안이 있습니다. 이러한 함수들은 모두 여러 배열을 결합하는 것이라는 기본 아이디어를 가지고 있지만, 이러한 함수들은 각각 다른 용도를 가지고 있습니다.\n\n이 주제를 논의하기 전에 먼저 두 개의 새 배열 AI와 AJ를 초기화하고 싶습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 코드블록 69\nAI = np.array(np.random.randint(0, 5, (2,4)))\nAJ = np.array(np.random.randint(5, 10, (2,4)))\n\nprint(AI, end='\\n\\n')\nprint(AJ)\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_61.png)\n\n두 배열을 수직으로 연결하여 결합하려면 np.vstack()을 사용할 수 있습니다.\n\n```js\n# 코드블록 70\nnp.vstack((AI,AJ))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알수 있듯이, np.hstack()은 두 배열을 수평으로 쌓는 데 사용됩니다.\n\n```js\n# 코드 블록 71\nnp.hstack((AI, AJ))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nnp.vstack()과 np.hstack() 함수는 여러 배열을 한 번에 쌓을 수 있습니다. 주의할 점은 배열의 열 수가 동일한 경우 수직 스택이 가능하다는 것입니다. 수평 스택의 경우, 배열의 행 수가 동일할 때만 작동합니다.\n\n```js\n# 코드블록 72\nprint(np.vstack((AI,AJ,AJ,AJ,AI)), end='\\n\\n')\nprint(np.hstack((AI,AJ,AJ,AJ,AI)))\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_64.png\" /\u003e\n\n또한, np.append() 함수는 배열을 연결하기 전에 먼저 배열을 평평하게 만든 후 작동합니다. 따라서 결과적으로 얻는 출력물은 1차원 배열이 됩니다. 이 기본 동작과는 상관없이 np.append() 함수를 np.vstack() 및 np.hstack()와 동일하게 작동하도록 axis 매개변수를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드 블록 73\nprint(np.append(AI, AJ), end='\\n\\n')\nprint(np.append(AI, AJ, axis=0), end='\\n\\n')\nprint(np.append(AI, AJ, axis=1))\n\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_65.png\" /\u003e\n\n사실 np.append() 함수는 한 번에 두 개 이상의 배열을 결합할 수 없습니다. 만약 그렇게 하고 싶다면 np.concatenate()를 사용할 수 있습니다. axis 매개변수도 np.append()와 동일하게 작동합니다. 만약 axis에 값을 지정하지 않으면 np.concatenate() 함수는 수직 스택을 수행합니다.\n\n\n# 코드 블록 74\nprint(np.concatenate([AI, AI, AI], axis=None), end='\\n\\n')\nprint(np.concatenate([AI, AI, AI]), end='\\n\\n')\nprint(np.concatenate([AI, AI, AI], axis=1))\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003ctable\u003e 태그를 Markdown 형식으로 바꿔보세요.\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_66.png\" /\u003e\n\n## Splitting\n\n스택에 사용되는 것뿐만 아니라 Numpy는 분할을 위한 몇 가지 함수도 제공합니다. 아래의 배열 AK를 고려해 봅시다.\n\n```js\n# Codeblock 75\nAK = np.random.randint(0, 10, (20))\nAK\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_67.png)\n\nnp.split() 함수를 먼저 소개하겠습니다. 이 함수는 두 가지 주요 매개변수를 받습니다: ary (나눌 배열) 및 indices_or_sections (분할 지점). 다음 코드에서는 배열 AL을 인덱스 3과 5에서 나누어 세 개의 새 배열을 얻으려고 합니다. 각 배열은 원본 배열에서 0부터 2까지, 3부터 4까지, 5부터 19까지의 범위를 갖습니다.\n\n```js\n# 코드 블록 76\nnp.split(AK, indices_or_sections=[3,5])\n```\n\n![이미지](/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_68.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2D 배열을 나누려면 np.hsplit() 또는 np.vsplit()을 사용할 수 있습니다. 사실 np.split()에 축 매개변수를 전달하여 동일한 작업을 수행할 수도 있습니다. 주요 아이디어는 기본적으로 동일하지만, np.vsplit() 및 np.hsplit()을 사용하여 분할 지점은 각각 행 번호와 열 번호를 참조합니다. 이러한 두 함수를 배열 AL에 대해 시연하겠습니다.\n\n```js\n# 코드블록 77\nAL = np.random.randint(0, 10, (5,6))\nAL\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_69.png\" /\u003e\n\n아래는 np.vsplit()을 사용하는 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 코드 블록 78\nnp.vsplit(AL, [2,4])\n\n### 대안\n# np.split(AL, [2,4], axis=0)\n\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_70.png\" /\u003e\n\n마지막으로 np.hsplit() 사용법입니다.\n\n\n# 코드 블록 79\nnp.hsplit(AL, [3,4])\n\n### 대안\n# np.split(AL, [3,4], axis=1) #동등한\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_71.png\" /\u003e\n\n# 마무리\n\n드디어 끝났어요! 지금까지 저가 자주 사용하는 NumPy 함수들을 다뤄봤어요. 사실 더 설명하지 않은 기능들도 많이 남아 있어요. 하지만 걱정하지 마세요. 이제 모든 기초를 마스터했기 때문에 쉽게 배울 수 있을 거예요.\n\n읽어 주셔서 감사해요. 이 글이 유용했기를 바라며, 다음 글에서 만나요. 안녕히 계세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고 자료\n\n[1] Universal functions (ufunc). NumPy. https://numpy.org/doc/stable/reference/ufuncs.html [접속일: 2024년 1월 8일].\n\n# 쉽게 이해하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작가를 칭찬하고 팔로우하려면 클랩을 눌러주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼에서 저희를 만나보세요: CoFeed | Differ\n- 더 많은 콘텐츠: PlainEnglish.io","ogImage":{"url":"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_0.png"},"coverImage":"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_0.png","tag":["Tech"],"readingTime":32},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e빠르고 똑똑한 데이터 조작을 위한 NumPy의 힘을 활용하세요.\u003c/h2\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003eNumPy 튜토리얼의 두 번째 파트에 오신 것을 환영합니다! 이전에는 다음 목록의 처음 7개 챕터를 다루었습니다. 이번 포스트에서는 8장부터 14장까지 진행하려고 합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNumPy 설치\u003c/li\u003e\n\u003cli\u003e배열 초기화\u003c/li\u003e\n\u003cli\u003eNumPy 배열 제한\u003c/li\u003e\n\u003cli\u003e계산 속도와 메모리 사용량\u003c/li\u003e\n\u003cli\u003e데이터 유형\u003c/li\u003e\n\u003cli\u003e색인 및 슬라이싱\u003c/li\u003e\n\u003cli\u003e배열 생성 함수\u003c/li\u003e\n\u003cli\u003e난수 생성\u003c/li\u003e\n\u003cli\u003e보기 및 복사\u003c/li\u003e\n\u003cli\u003e수학 함수\u003c/li\u003e\n\u003cli\u003e논리 및 비트 연산자\u003c/li\u003e\n\u003cli\u003e검색 및 정렬\u003c/li\u003e\n\u003cli\u003e모양 및 재구성\u003c/li\u003e\n\u003cli\u003e연결 및 분할\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e참고: 이 문서에서 사용된 모든 자료는 제 GitHub 저장소에서 확인할 수 있습니다. 여기에 링크를 남깁니다.\u003c/p\u003e\n\u003ch1\u003e8. 랜덤 숫자\u003c/h1\u003e\n\u003cp\u003eNumPy를 사용하면 랜덤 숫자를 생성할 수 있습니다. 제 경우에는 이 기능을 사용하여 기계 학습 및 딥 러닝 모델에서 무작위 가중치를 초기화하는 데 사용해 보았습니다. 제가 처음부터 구현하려고 노력했던 그때입니다. 이러한 유형의 NumPy 기능에는 다른 응용 프로그램이 있을 것이라고 믿습니다.\u003c/p\u003e\n\u003ch2\u003e균일 분포\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 np.random.rand()로 시작해 봅시다. 이 함수는 [0.0, 1.0) 범위 내에서 균일 분포에서 무작위 숫자를 생성합니다. 이는 숫자가 정확히 0.0이 될 수는 있지만, 1.0에 근접할 뿐입니다. 이 함수를 사용하려면 우리가 원하는 배열의 형태를 전달해주기만 하면 됩니다. np.random.random()은 사실상 np.random.rand()와 동일합니다. 그러나 이 함수에 대한 입력은 튜플 형태여야 한다는 것을 염두에 두세요. 이 두 함수 중 어느 것이든 실제로 서로 교차하여 사용할 수 있습니다. 이는 단지 사용자의 취향에 따라 다를 뿐입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\nnp.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erand\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\n\n### 대안\n# np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e((\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_0.png\"\u003e\n\u003cp\u003e아직 무작위 균일 분포와 관련하여, 더 많은 유연성이 필요하다면 np.random.uniform()를 사용할 수 있습니다. 이 함수를 사용하면 분포의 범위를 지정할 수 있어 [0.0, 1.0)에 고정되어 있는 것보다 더 유연해집니다. 아래 코드 블록에서 수를 90부터 100 사이로 범위 설정하는 방법을 보여드리겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\nnp.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euniform\u003c/span\u003e(low=\u003cspan class=\"hljs-number\"\u003e90\u003c/span\u003e, high=\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, size=(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e만약 균일 분포에서 숫자를 np.histogram()에 넣으면, 모든 바구니(첫 번째 인덱스의 배열)에 유사한 빈도의 발생이 있음을 볼 수 있습니다. 아래 예제에서는 10개의 바구니로 분배된 50,000개의 숫자를 생성합니다. 이렇게 하면 각 바구니에 약 5,000개의 발생 횟수가 있습니다. 무작위 균일 함수의 세 가지 변형(np.random.rand(), np.random.random() 및 np.random.uniform())이 모두 이렇게 동작합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\nnp.\u003cspan class=\"hljs-title function_\"\u003ehistogram\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003euniform\u003c/span\u003e(size=(\u003cspan class=\"hljs-number\"\u003e50000\u003c/span\u003e)))\n\n### 유사한 결과를 제공합니다\n# np.\u003cspan class=\"hljs-title function_\"\u003ehistogram\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erand\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e50000\u003c/span\u003e))\n# np.\u003cspan class=\"hljs-title function_\"\u003ehistogram\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e50000\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_2.png\"\u003e\n\u003ch2\u003e정규 분포\u003c/h2\u003e\n\u003cp\u003e균일 분포 뿐만 아니라 np.random.randn()을 사용하여 정규 분포의 데이터도 생성할 수 있습니다. 여기서 전달할 수 있는 유일한 매개변수는 생성될 배열의 모양입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e\nnp.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandn\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_3.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e안타깝게도 np.random.randn() 함수는 분포의 평균과 표준 편차를 변경할 수 있는 기능을 제공하지 않습니다. 이 함수에서 두 매개변수는 각각 0과 1로 고정되어 있습니다. 만약 이러한 값을 사용자 정의하고 싶다면 np.random.normal()을 사용해야 합니다. np.random.normal()에서는 평균을 loc 매개변수를 사용하여 조절하고, 표준편차는 scale 매개변수를 통해 수정할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\nnp.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enormal\u003c/span\u003e(loc=\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, scale=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, size=(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_4.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e제가 앞서 사용한 np.histogram() 함수는 np.random.randn() 및 np.random.normal()에 의해 생성된 배열이 실제로 정규 분포를 따르는지 확인하는 데 사용될 수 있습니다. 아래 그림 6은 이를 설명하는데, 첫 번째 배열을 통해 가운데 있는 bin이 가장 빈도가 높음을 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e\nnp.\u003cspan class=\"hljs-title function_\"\u003ehistogram\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enormal\u003c/span\u003e(loc=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, scale=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, size=\u003cspan class=\"hljs-number\"\u003e50000\u003c/span\u003e))\n\n### 비슷한 결과를 출력\n# np.\u003cspan class=\"hljs-title function_\"\u003ehistogram\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandn\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e50000\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_5.png\"\u003e\n\u003cp\u003e지금까지 많은 유사한 함수가 존재한다는 것을 알아차렸습니다. 특히, 무작위 숫자를 생성하는 데 사용되는 함수들은 균일 및 정규 분포와 관련된 함수들이 많습니다. 그런 경우에는 np.random.uniform() 및 np.random.normal()만 사용하는 것을 권장드립니다. 두 함수가 가장 유연하기 때문입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e랜덤 정수\u003c/h2\u003e\n\u003cp\u003e우리가 이전에 논의한 함수들은 주로 랜덤 소수점 숫자를 생성하는 데 초점을 맞췄습니다. 실제로 Numpy는 랜덤 정수를 생성하는 함수인 np.random.randint()를 제공합니다. 이 함수의 매개변수 및 동작은 np.random.uniform()와 동일합니다. 지정된 범위 내의 모든 숫자는 선택될 확률이 완전히 동일합니다. 다시 말해, np.random.randint()는 숫자 선택을 위해 균일한 이산 분포를 사용합니다. 아래 예시에서 생성된 숫자들은 [5,10) 범위 내에 있을 것입니다 (즉, 10은 포함되지 않음).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e\nnp.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandint\u003c/span\u003e(low=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, high=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, size=(\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e배열 섞기\u003c/h2\u003e\n\u003cp\u003e다음으로 이야기하고 싶은 함수는 np.random.shuffle()입니다. 그러나 더 진행하기 전에 먼저 배열 K를 초기화하고 싶습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e\nK = np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandint\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e, size=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\nK\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_7.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아마 알아챌 수 있었던 것처럼, np.random.shuffle()은 배열의 요소 순서를 섞어주는 함수입니다. 이 함수는 배열을 그 자리에서 섞기 때문에, 새로운 배열을 만드는 것이 아니라 원본 배열을 직접 섞는다는 것을 명심해 주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'섞기 전 K\\t: '\u003c/span\u003e, K)\nnp.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eshuffle\u003c/span\u003e(K)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'섞은 후 K\\t: '\u003c/span\u003e, K)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_8.png\"\u003e\n\u003ch2\u003e랜덤 선택\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아직 배열 K와 작업 중이시군요. 이제 그 중에서 숫자를 무작위로 선택하는 방법을 알려드릴게요. np.random.choice()를 사용하면 간단하죠. 아래 코드 블록에서 함수를 사용하는 여러 예제를 보여드릴게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003echoice\u003c/span\u003e(K), end=\u003cspan class=\"hljs-string\"\u003e'\\n\\n'\u003c/span\u003e)                #(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003echoice\u003c/span\u003e(K, size=(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)), end=\u003cspan class=\"hljs-string\"\u003e'\\n\\n'\u003c/span\u003e)    #(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003echoice\u003c/span\u003e(K, size=(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e), replace=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)) #(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_9.png\"\u003e\n\u003cp\u003e(1)에서 지정된 줄에서, 함수에 배열만 전달하면 해당 배열에서 한 개의 숫자를 반환합니다. (2)의 size 매개변수를 사용하여 출력의 차원을 지정할 수도 있어요. 출력 결과를 보면 16이 두 번 나타나는 것을 알 수 있어요. 이는 기본적으로 함수가 복원 선택으로 무작위 숫자를 선택하기 때문인데요, 즉, 원래 배열에서 하나의 숫자가 여러 번 선택될 수 있습니다. 이를 원치 않는 경우, replace=False를 써서 다음과 같이 쓸 수 있어요. (3)에서처럼요. 이렇게 하면 결과 배열의 요소 수가 원본 배열의 요소 수보다 크면 안 된다는 점에 유의하세요. 궁금하시다면, 세 번째 출력에서 두 번 나타나는 12는 배열 K에 12가 실제로 두 번 나타난 것 때문입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e시드\u003c/h2\u003e\n\u003cp\u003e생성된 무작위 숫자를 재현 가능하게 하는 경우가 많습니다. 이를 위해 np.random.seed()를 사용할 수 있습니다. 사용 방법은 간단합니다. 단지 인수로 숫자를 넣고 동일한 숫자를 출력을 정확히 원하는 노트북 셀에서 사용하면 됩니다. 다음 예제를 살펴봅시다. 여기서 np.random.randint()로 생성된 배열이 두 연속된 코드 블록에서 정확히 동일하게 나오기를 원합니다. 이 예에서 시드를 99로 설정하기로 결정했습니다(원하는 정수를 선택할 수 있습니다). np.random.randint()가 정확히 동일한 숫자를 반환하려면, 동일한 시드로 np.random.seed()를 다시 호출해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 코드 블록 11\u003c/span\u003e\nnp.random.seed(\u003cspan class=\"hljs-number\"\u003e99\u003c/span\u003e)\nnp.random.randint(low=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, high=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, size=(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\nnp.random.seed(\u003cspan class=\"hljs-number\"\u003e99\u003c/span\u003e)\nnp.random.randint(low=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e high=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e size=(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_11.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e9. 뷰(View)와 복사(Copy)\u003c/h1\u003e\n\u003ch2\u003e뷰(View)\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e한 변수에서 다른 변수로 배열을 할당할 때 Numpy의 성질을 고려해야 합니다. 다음 예제를 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e\nL = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e66\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e77\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e88\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e99\u003c/span\u003e])\nM = L\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(M)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_12.png\"\u003e\n\u003cp\u003e여기서 배열 L을 변수 M에 할당했으므로 두 변수가 동일한 배열을 포함하게 됩니다. 다음으로, 아래 코드 블록 14를 사용하여 M의 0번 인덱스를 변경하려고 합니다. 그러나 M의 첫 번째 요소만 바꾸려고 했지만 배열 L의 요소도 변경됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e\nM[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'L:'\u003c/span\u003e, L)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'M:'\u003c/span\u003e, M)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_13.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 결과가 나온 이유는 M이 단순히 L의 \"뷰(view)\"일 뿐이기 때문입니다. 다시 말해 위에서 보여준 방법은 배열을 복사하는 것이 아니라 두 변수가 여전히 \"연결\"되어 있기 때문입니다.\u003c/p\u003e\n\u003ch2\u003e복사\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 경우가 발생하지 않도록하려면, M에 할당할 때 copy() 메서드를 L에 넣으면 됩니다. 이렇게 하면 M에 저장된 배열이 완전히 다른 배열이 되어, 하나의 배열에 대한 수정이 다른 배열에 영향을 미치지 않도록 보장됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e\nL = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e66\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e77\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e88\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e99\u003c/span\u003e])\nM = L.\u003cspan class=\"hljs-title function_\"\u003ecopy\u003c/span\u003e()\nM[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'L:'\u003c/span\u003e, L)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'M:'\u003c/span\u003e, M)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_14.png\"\u003e\n\u003ch1\u003e10. 수학 함수\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e기본 수학 연산\u003c/h2\u003e\n\u003cp\u003e이 장에서는 Numpy의 수학 기능을 사용하는 방법에 대해 알아보려고 합니다. 시작하기 전에 사전에 배열 N과 O를 초기화해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e\nN = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e], dtype=\u003cspan class=\"hljs-string\"\u003e'int32'\u003c/span\u003e)\nO = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e], dtype=\u003cspan class=\"hljs-string\"\u003e'int32'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 가장 기초적인 것부터 시작할 것입니다: 덧셈, 뺄셈, 곱셈 및 나눗셈입니다. Numpy에서 배열에 이러한 연산자를 적용하면 연산은 요소별로 수행됩니다. 이러한 이유로 배열 피연산자의 차원이 정확히 일치하는지 확인해야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e코드 블록 17\u003c/h1\u003e\n\u003cp\u003eprint(N + O)\nprint(N - O)\nprint(N * O)\nprint(N / O)\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_15.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e위의 코드블록 17에서 소개된 방법들은 Numpy 배열에서만 작동합니다. 리스트에 똑같은 작업을 시도하면 모든 예제가 오류가 발생할 것이며, 덧셈 연산은 두 리스트를 연결할 것입니다.\u003c/p\u003e\n\u003cp\u003e대안으로 np.add(), np.subtract(), np.multiply() 및 np.divide()와 같은 Numpy에서 제공하는 함수들을 사용할 수도 있습니다. 연산자 기호와 함수 모두 정확히 같은 결과를 생성합니다. 따라서 이 경우에는 개인 취향에 따라 선택하면 됩니다. 아래 코드블록은 이러한 함수들을 어떻게 사용하는지 보여줍니다. 결과 출력은 Figure 16에 표시된 것과 완전히 동일합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(N, O))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esubtract\u003c/span\u003e(N, O))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003emultiply\u003c/span\u003e(N, O))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003edivide\u003c/span\u003e(N, O))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e넘파이(Numpy)에서 \"브로드캐스팅(broadcasting)\"이라는 개념이 있습니다. 이는 기본적으로 크기가 다른 배열 또는 배열과 스칼라 간의 연산을 수행할 수 있다는 것을 의미합니다. 다음 경우에는 숫자 5가 배열 N의 모든 요소로 브로드캐스팅된다고 말할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e19\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(N + \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(N - \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(N * \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(N / \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_16.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e제가 다음으로 논의하고 싶은 것은 행렬 곱셈입니다. 이전에 언급한 대로, 네 가지 기본 수학 연산 함수는 요소별로 작동합니다. 이는 np.multiply() 함수가 행렬 곱셈을 위해 의도된 것이 아니라는 것을 의미합니다. 대신 np.matmul()을 사용해야 합니다. 이 경우 두 입력 행렬이 연산 가능한지 확인해야 합니다. 다음 예제에서는 각각 크기가 (4,3)과 (3,2)인 배열 O와 P 사이의 곱셈을 수행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e\nO = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], \n              [\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e], \n              [\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e], \n              [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e]])\n\nP = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([[\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e], \n              [\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e], \n              [\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e]])\n\nnp.\u003cspan class=\"hljs-title function_\"\u003ematmul\u003c/span\u003e(O, P)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_17.png\"\u003e\n\u003cp\u003e여전히 기본 수학 연산과 관련된 다른 함수에는 np.sign(), np.negative() 및 np.abs()가 있습니다. 이러한 함수들의 사용법을 배열 Q에 대해 보여드리겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e\nQ = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([-\u003cspan class=\"hljs-number\"\u003e56\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e92\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e66\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e72\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e90\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e32\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e51\u003c/span\u003e])\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esign\u003c/span\u003e(Q))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003enegative\u003c/span\u003e(Q))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(Q))      # 대안: np.\u003cspan class=\"hljs-title function_\"\u003eabsolute\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_18.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e함수 이름대로, np.sign()은 배열의 각 요소의 부호를 취하는 데 사용됩니다. -1, 0 또는 1만 표시됩니다. 다음으로, np.negative()를 사용하여 숫자의 부호를 뒤집을 수 있습니다. 위의 예시에서 -56은 56이 되고, 92는 -92가 됩니다. 마지막으로, np.abs() 또는 np.absolute()를 사용하여 숫자의 절대값을 취할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e최대공약수(GCD)와 최소공배수(LCM)\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e최대공약수(GCD)와 최소공배수(LCM)는 Numpy에서 각각 np.gcd()와 np.lcm()으로 구현되어 있습니다. 이러한 함수들을 사용하려면, 간단히 두 숫자나 배열을 입력인수로 넣으면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003egcd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e81\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e72\u003c/span\u003e))    #(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003elcm\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e))    #(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003elcm\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e], [\u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]))    #(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_19.png\"\u003e\n\u003cp\u003e위 코드블록 22의 예제를 살펴봅시다. #(1)으로 표시된 줄은 81과 72의 최대공약수인 하나의 숫자를 반환합니다. 한편, #(2) 줄에서는 숫자 24가 첫 번째 인수에 브로드캐스트되어 LCM이 24와 목록의 각 숫자 간에 계산됩니다. 마지막으로, 두 인수에 대해 리스트를 전달하면, LCM 또는 GCD 계산이 요소별로 수행됩니다 (#(3)).\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e지수 함수\u003c/h2\u003e\n\u003cp\u003enp.power() 함수를 사용하여 지수 연산을 수행할 수 있습니다. 이 함수는 두 개의 입력을 받습니다: 밑수와 지수입니다. 해당 함수는 지수로 분수를 전달하여 루트를 계산할 수 있도록 매우 유연합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003epower\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003epower\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003epower\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e144\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_20.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e유연성이 있긴 하지만, np.power()은 실제로 연산 속도에 있어서 최상이라고 할 수는 없습니다. 실제로 더 빠른 계산을 제공하는 몇 가지 특정 목적을 위한 대안들이 있습니다. np.square(), np.sqrt(), np.cbrt() 및 np.exp()가 그 예입니다. 아래 코드 블록은 np.power()와 이러한 함수들의 동등한 사용법을 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esquare\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e))             # np.\u003cspan class=\"hljs-title function_\"\u003epower\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)와 동일\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e144\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e]))    # np.\u003cspan class=\"hljs-title function_\"\u003epower\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e144\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)와 동일\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003ecbrt\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e343\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e27\u003c/span\u003e]))        # np.\u003cspan class=\"hljs-title function_\"\u003epower\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e343\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e27\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)와 동일\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003eexp\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e]))          # np.\u003cspan class=\"hljs-title function_\"\u003epower\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003ee\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e])와 동일\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_21.png\"\u003e\n\u003ch2\u003e각도 변환 및 삼각함수\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e넘파이에서는 삼각함수를 사용할 수 있습니다. np.sin(), np.cos() 및 np.tan()을 사용할 때 주의해야 할 점은 이 함수들이 라디안 단위의 각도를 입력으로 받는다는 것입니다. 따라서 각도가 도(degree)로 주어진 경우 np.deg2rad()를 사용하여 라디안으로 변환해야 합니다. 아래 Codeblock 25에서는 각도를 도와 라디안으로 변환하는 방법을 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e\nR = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e90\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e180\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e270\u003c/span\u003e])    # 각도 (도)가 담긴 배열\nS = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, np.\u003cspan class=\"hljs-property\"\u003epi\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, np.\u003cspan class=\"hljs-property\"\u003epi\u003c/span\u003e, np.\u003cspan class=\"hljs-property\"\u003epi\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])    # 각도 (라디안)가 담긴 배열\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003edeg2rad\u003c/span\u003e(R))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003erad2deg\u003c/span\u003e(S))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_22.png\"\u003e\n\u003cp\u003e각도 변환 방법을 이해했으니, 이제 삼각함수의 사용법을 실제로 보여드리겠습니다. 다음 코드에서 숫자 0, 45, 60이 각도 (도)를 나타낸다고 가정합니다. 이 숫자들은 라디안으로 변환된 후 배열 T에 저장되어 np.sin(), np.cos(), np.tan()의 입력으로 사용됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e26\u003c/span\u003e\nT = np.\u003cspan class=\"hljs-title function_\"\u003edeg2rad\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e45\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e])\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esin\u003c/span\u003e(T))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003ecos\u003c/span\u003e(T))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003etan\u003c/span\u003e(T))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_23.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e로그 함수\u003c/h2\u003e\n\u003cp\u003e로그 함수에 대해 이야기할 때, 적어도 가장 기본적이라고 생각되는 세 가지 함수가 있습니다. 아래 코드 블록 27에서는 배열 U에 np.log(), np.log2() 및 np.log10() 함수를 어떻게 사용하는지 보여줍니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e코드 블록 27\u003c/h1\u003e\n\u003cp\u003eU = [1, 2, 10, np.e]\u003c/p\u003e\n\u003cp\u003eprint(np.log(U))\nprint(np.log2(U))\nprint(np.log10(U))\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_24.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003eNumpy에서 np.log()는 수학의 ln() 함수와 동일합니다 (밑이 e인 로그). 한편, np.log2()와 np.log10()은 각각 밑이 2와 10인 로그입니다.\u003c/p\u003e\n\u003ch2\u003e통계 함수\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 숫자 데이터 분포를 가지고 있다면, 통계적 특성을 계산하여 추가 분석을 수행할 수 있습니다. 우리에게 운이 좋은 것은 Numpy가 이 작업을 쉽게 수행할 수 있는 다양한 함수를 제공해준다는 것입니다. 이와 관련된 모든 함수들 — 아마도 이들 모두가 명확히 이해할 만한 함수들로 보입니다 — 이 코드 블록 28에 나와 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e28\u003c/span\u003e\nV = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e])\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'sum\\t:'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003esum\u003c/span\u003e(V))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'mean\\t:'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e(V))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'median\\t:'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003emedian\u003c/span\u003e(V))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'var\\t:'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003evar\u003c/span\u003e(V))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'stddev\\t:'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003estd\u003c/span\u003e(V))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'q1\\t:'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003equantile\u003c/span\u003e(V, \u003cspan class=\"hljs-number\"\u003e0.25\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'q2\\t:'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003equantile\u003c/span\u003e(V, \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'q3\\t:'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003equantile\u003c/span\u003e(V, \u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'min\\t:'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(V))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'max\\t:'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(V))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_25.png\"\u003e\n\u003cp\u003e이 주제 외에도 통계 측정과 직접적인 관련이 없지만 여전히 유용할 수 있는 두 가지 다른 함수가 실제로 있습니다. 말하고자 하는 두 함수는 np.argmin()과 np.argmax()인데, 이 두 함수는 배열에서 가장 작은 값과 가장 큰 값이 들어 있는 인덱스를 반환합니다. 가장 작거나 큰 값이 여러 개인 경우, 이 두 함수는 가장 낮은 인덱스를 반환합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e29\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'argmin\\t:'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003eargmin\u003c/span\u003e(V))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'argmax\\t:'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003eargmax\u003c/span\u003e(V))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_26.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003e선형 대수\u003c/h2\u003e\n\u003cp\u003e넘파이는 선형 대수 계산을 수행하는데 다양한 도구를 제공합니다. 여기서 여러분께 보여드릴 수 있는 몇 가지 사항들이 있습니다. 코드 블록 30에 표시된 두 배열이 있다고 가정해 봅시다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e\nW = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e])\nX = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e넘파이에서 1차원 배열은 벡터로 생각할 수 있습니다. 따라서 np.dot()을 사용하여 W와 X의 내적을 계산할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e31\u003c/span\u003e\nnp.\u003cspan class=\"hljs-title function_\"\u003edot\u003c/span\u003e(W, X)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_27.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e또한 NumPy는 np.inner() 및 np.outer()를 통해 내적과 외적을 계산할 수 있도록 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# Codeblock 32\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(np.inner(W, X))\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(np.outer(W, X))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_28.png\"\u003e\n\u003cp\u003e이제 2D 배열을 다루고 있다면 우리가 할 수 있는 것들에 대해 좀 더 자세히 알아보겠습니다. 이를 시연하기 전에 배열 Y를 미리 초기화하고 싶습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e33\u003c/span\u003e\nY = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n              [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e],\n              [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e행렬의 전치(transpose)를 얻으려면 np.transpose()를 사용하거나 해당 행렬의 T 속성을 사용할 수 있습니다. 아래 코드 블록을 확인해보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e34\u003c/span\u003e\nnp.\u003cspan class=\"hljs-title function_\"\u003etranspose\u003c/span\u003e(Y)\n\n### 대안\n# Y.\u003cspan class=\"hljs-property\"\u003eT\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_29.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e넘파이는 행렬의 역행렬을 계산하는 함수도 제공합니다. \u003ccode\u003enp.linalg.inv()\u003c/code\u003e를 사용하면 행렬 Y의 역행렬을 계산할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e35\u003c/span\u003e\nnp.\u003cspan class=\"hljs-property\"\u003elinalg\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einv\u003c/span\u003e(Y)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_30.png\"\u003e\n\u003cp\u003e그러나 중요한 점은 행렬이 특이행렬일 때, 즉 행렬식이 0일 때 \u003ccode\u003enp.linalg.inv()\u003c/code\u003e가 오류를 반환한다는 것입니다. 따라서 역행렬을 계산하기 전에 행렬의 행렬식 값을 확인하는 것이 좋은 아이디어라고 생각합니다. 확인을 위해 \u003ccode\u003enp.linalg.det()\u003c/code\u003e을 사용하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e36\u003c/span\u003e\nnp.\u003cspan class=\"hljs-property\"\u003elinalg\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edet\u003c/span\u003e(Y)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_31.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e더불어 Numpy는 np.linalg.eig()를 사용하여 고유값과 고유벡터를 계산할 수 있습니다. 이 함수는 두 값 모두 반환하므로 출력을 위해 두 변수를 할당해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e37\u003c/span\u003e\neigenvalues, eigenvectors = np.\u003cspan class=\"hljs-property\"\u003elinalg\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eeig\u003c/span\u003e(Y)\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(eigenvalues, end=\u003cspan class=\"hljs-string\"\u003e'\\n\\n'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(eigenvectors)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_32.png\"\u003e\n\u003cp\u003e지금까지 Numpy에서 다양한 수학 함수에 대해 많이 이야기했습니다. 실제로 더 설명하지 않은 것도 많이 있습니다. 더 탐구하고 싶다면 \u003ca href=\"1\"\u003e이 사이트\u003c/a\u003e를 방문해보세요.\u003c/p\u003e\n\u003ch1\u003e11. 논리 및 비트 연산자\u003c/h1\u003e\n\u003ch2\u003e논리 연산자\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 기사의 맨 처음에, NumPy가 우리에게 boolean 자료형의 배열을 만들 수 있게 한다고 언급했지만, 이 주제에 대해 아직 자세히 다루지는 않았습니다. 그리고 이제, 이 장에서 그에 대해 이야기하고 싶습니다. 먼저, Z와 AA라는 이름으로 두 배열을 초기화하는 것으로 시작합시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e38\u003c/span\u003e\nZ = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e])\n\u003cspan class=\"hljs-variable constant_\"\u003eAA\u003c/span\u003e = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eboolean 연산을 수행하는 가장 간단한 방법은 \u003ccode\u003enp.logical_and()\u003c/code\u003e, \u003ccode\u003enp.logical_or()\u003c/code\u003e, 및 \u003ccode\u003enp.logical_xor()\u003c/code\u003e를 사용하는 것입니다. 우리가 이 함수들을 인수로써 같은 차원의 두 배열을 넣어주면, 이 함수들은 요소별 연산을 수행할 것입니다. 다음 예제를 참조해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e39\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003elogical_and\u003c/span\u003e(Z, \u003cspan class=\"hljs-variable constant_\"\u003eAA\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003elogical_or\u003c/span\u003e(Z, \u003cspan class=\"hljs-variable constant_\"\u003eAA\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003elogical_xor\u003c/span\u003e(Z, \u003cspan class=\"hljs-variable constant_\"\u003eAA\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_33.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eOR 및 AND 연산자와 약간 비슷한 두 가지 특수 기능이 실제로 있는데, np.any()와 np.all()입니다. np.any()는 배열에 하나 이상의 True가 있으면 True를 반환합니다. 반면에 np.all()은 배열의 모든 요소가 True인 경우에만 True를 반환합니다. 아래 코드 블록 40에서는 배열 Z와 AA에 대해 이 두 함수를 어떻게 사용하는지 보여줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'np.any(Z): '\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003eany\u003c/span\u003e(Z))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'np.all(Z): '\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(Z), end=\u003cspan class=\"hljs-string\"\u003e'\\n\\n'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'np.any(AA):'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003eany\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAA\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'np.all(AA):'\u003c/span\u003e, np.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAA\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_34.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리는 실제로 np.any()와 np.all()을 좀 더 고급으로 사용할 수 있어요. 다음 코드 블록에서 #(1) 행에서, np.any()는 배열 AB에서 4보다 큰 숫자가 하나 이상 있는 경우 True를 반환할 거에요. 다음으로, #(2) 행에서는 AB의 모든 요소가 4보다 큰 경우에만 True를 반환할 거에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAB\u003c/span\u003e = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e])\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003eany\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAB\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e))    #(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAB\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e))    #(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_35.png\"\u003e\n\u003ch2\u003e비트 연산자\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e비트 연산자는 논리 연산자만큼 직관적으로 보이지 않을 수 있습니다. 그럼에도 불구하고 두 가지의 기본 아이디어는 정확히 같습니다. 차이는 비트 연산자가 정수를 입력으로 사용한다는 점뿐입니다. 연산 중에 이러한 정수들은 이진으로 먼저 변환된 후 비트 단위로 작동됩니다. 아래 예시에서는 np.bitwise_and(), np.bitwise_or() 및 np.bitwise_xor()에 12와 13을 입력 인수로 넣었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003ebitwise_and\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003ebitwise_or\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003ebitwise_xor\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_36.png\"\u003e\n\u003cp\u003e위 함수들은 모두 처음에 12와 13을 이진으로 변환하여 작동합니다: 1100과 1101. 이 값을 AND 연산자로 처리하면 1100이 됩니다. 한편 OR 연산자는 1101을 반환하고 XOR는 0001을 반환합니다. 이진 수열을 10진수로 변환하면 최종 결과로 12, 13 및 1이 나옵니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 주제에 추가로, np.binary_repr()을 사용하여 10진수의 이진 표현을 확인할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e43\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003ebinary_repr\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003ebinary_repr\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_37.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e12. 검색 및 정렬\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e특정 숫자를 찾을 때에는 불리언 인덱싱이라는 기법을 사용할 수 있어요. 이 방법을 마스킹처럼 생각할 수도 있죠. 여기서 저는 다음 코드 블록에서 초기화한 배열 AC를 이 아이디어로 설명하고 싶어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e44\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAC\u003c/span\u003e = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])\n\nmask = \u003cspan class=\"hljs-variable constant_\"\u003eAC\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e  #(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\nmask\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이름이 \"mask\"인 것은 사실상 AC와 길이가 정확히 같은 다른 배열이며, 여기에는 불리언 값만 포함돼요. 이렇게 배열을 생성하려면 (1) 라인에서 하는 것처럼 조건을 적용하면 되요. 이 코드 라인에서는 배열 AC의 모든 요소가 지정된 조건을 충족하는지 확인해요. 만약 조건을 충족한다면 해당 인덱스는 True로 할당돼요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e실제 마스킹은 아래의 코드블록 45를 사용하여 실행됩니다. 이렇게 하면 우리의 기준을 충족하는 숫자만 출력됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e45\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAC\u003c/span\u003e[mask]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_39.png\"\u003e\n\u003cp\u003e사실, 마스크를 별도의 변수에 저장할 필요는 없습니다. 대신, 다음과 같이 간단히 작성할 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e46\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAC\u003c/span\u003e[\u003cspan class=\"hljs-variable constant_\"\u003eAC\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_40.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e논리 연산자도 사용할 수 있습니다. 다음 예시는 9를 제외한 모든 요소 중 5보다 큰 모든 요소를 출력합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e47\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAC\u003c/span\u003e[(\u003cspan class=\"hljs-variable constant_\"\u003eAC\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e) \u0026#x26; (\u003cspan class=\"hljs-variable constant_\"\u003eAC\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_41.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e실제로 np.where()를 사용하여 동일한 결과를 얻을 수 있습니다. 아래는 그 방법입니다. 결과 출력은 이전 것과 정확히 동일하기 때문에 나타내지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# Codeblock 48\u003c/span\u003e\nAC[np.where((AC \u003e \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e) \u0026#x26; (AC != \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e))]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003enp.where() 함수 자체는 배열에서 지정된 기준을 충족하는 색인을 반환하여 작동합니다. 이 특정 경우에는 선택된 색인이 6, 8 및 6에 해당하는 5, 6 및 7이며, 이는 배열 AC에서의 값들과 일치합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e코드블록 49\u003c/h1\u003e\n\u003cp\u003enp.where((AC \u003e 5) \u0026#x26; (AC != 9))\u003c/p\u003e\n\u003ch1\u003eAC의 요소를 떠올려보세요: [9, 4, 5, 3, 2, 6, 8, 6, 5, 4, 5, 5, 3, 2].\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_42.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003enp.where() 함수는 3개의 인수를 전달할 때 더 유용할 수 있습니다. 즉, 조건, x 및 y를 정확한 순서로 전달합니다. 이러한 인수를 다음과 같이 생각할 수 있습니다: \"조건이 True를 반환하면 x를 수행하고, 그렇지 않으면 y를 수행합니다.\" 이를 더 잘 설명하기 위해 다음 코드는 배열 AC의 모든 요소를 5보다 큰 경우 0으로 변환합니다. 그렇지 않으면 숫자가 2씩 추가됩니다.\u003c/p\u003e\n\u003ch1\u003e코드블록 50\u003c/h1\u003e\n\u003cp\u003eprint(AC)\nprint(np.where(AC \u003e 5, 0, AC+2))\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_43.png\" alt=\"마스터링 넘파이 효율적인 배열 처리를 위한 포괄적인 가이드 22_43 이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e만약 배열 내의 고유한 값의 수를 찾는다는 요청이 오면, np.unique()를 사용할 수 있습니다. 이 함수를 사용하는 방법은 간단합니다. 배열을 유일한 매개변수로 넣기만 하면 됩니다. 또는 만약 원한다면, return_counts=True를 사용하여 해당 값들의 발생 횟수도 얻을 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 코드블록 51\u003c/span\u003e\nnp.unique(AC, return_counts=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_44.png\" alt=\"마스터링 넘파이 효율적인 배열 처리를 위한 포괄적인 가이드 22_44 이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e정렬\u003c/h2\u003e\n\u003cp\u003e함수의 이름이 나타내듯이, 배열을 정렬하는 데 필요한 것은 np.sort()입니다. 예를 들어, 여기서 배열 AD와 AE를 가지고 정렬 작업을 수행할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e52\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAD\u003c/span\u003e = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e77\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e33\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e44\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e99\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e88\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e55\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e66\u003c/span\u003e])\n\u003cspan class=\"hljs-variable constant_\"\u003eAE\u003c/span\u003e = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e\"Elon Musk\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Bill Gates\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Joe Biden\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Barack Obama\"\u003c/span\u003e])\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAD\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAE\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_45.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 결과에서 두 배열이 오름차순으로 정렬되어 있음을 확인할 수 있습니다. 실제로 np.sort()에는 결과 배열을 내림차순으로 정렬할 수 있는 매개변수가 없습니다. 따라서, 만일 원한다면 np.flip()을 사용하여 내림차순으로 정렬할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e53\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003eflip\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAD\u003c/span\u003e)))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003eflip\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAE\u003c/span\u003e)))\n\n### 대체 방법\n# \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAD\u003c/span\u003e)[::-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\n# \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAE\u003c/span\u003e)[::-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_46.png\"\u003e\n\u003cp\u003e만약 배열을 정렬하긴 하되 값이 아닌 인덱스만 필요한 경우, np.argsort()를 사용할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e코드블록 54\u003c/h1\u003e\n\u003cp\u003enp.argsort(AD)\u003c/p\u003e\n\u003ch1\u003eAD의 요소들을 상기해 봅시다: [77, 33, 44, 99, 22, 88, 55, 11, 66].\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_47.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eFigure 48에 표시된 출력은 기본적으로 AD 배열에서 가장 작은 숫자를 포함하는 7번째 인덱스를 보여줍니다. 이후로 AD[4], AD[1], 등이 따릅니다. 정렬이 제대로 작동하는지 확인하기 위해 np.argsort()의 전체 출력을 사용하여 다음과 같이 인덱싱을 수행할 수 있습니다:\u003c/p\u003e\n\u003ch1\u003e코드블록 55\u003c/h1\u003e\n\u003cp\u003eAD[np.argsort(AD)]\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_48.png\"\u003e\n\u003cp\u003e2차원 배열의 경우, axis 매개변수를 사용하여 정렬 방향을 결정할 수 있습니다. 이는 np.sort()와 np.argsort() 둘 다에 적용할 수 있습니다. 아래 배열 AF를 고려해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e56\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAF\u003c/span\u003e = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e],\n               [\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e], \n               [\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e]])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 위 행렬을 열을 따라 정렬하고 싶다면, axis=0을 사용해야 합니다. 반면, axis=1은 행을 따라 정렬할 수 있게 합니다. 아래 코드블록 57는 그 방법을 보여줍니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e57\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAF\u003c/span\u003e, axis=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e), end=\u003cspan class=\"hljs-string\"\u003e'\\n\\n'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAF\u003c/span\u003e, axis=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_49.png\"\u003e\n\u003cp\u003e이 장에 대해 이야기하고 싶은 마지막 주제는 실제로는 정렬과는 크게 관련이 없지만, 여전히 배열 순서와 관련이 있는 주제입니다. 이야기하려는 함수는 np.roll()인데, 이 함수를 사용하여 요소들에 대한 순환 이동을 수행할 수 있습니다. 이 아이디어를 설명하기 위해 먼저 한 시퀀스를 생성할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e58\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAG\u003c/span\u003e = np.\u003cspan class=\"hljs-title function_\"\u003earange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e)\n\u003cspan class=\"hljs-variable constant_\"\u003eAG\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 codeblock를 사용하여 시퀀스를 shift 매개변수에 전달한 값에 따라 회전시킬 수 있습니다. 이 경우에는 AG를 오른쪽으로 3번(#(1)) 회전하고 왼쪽으로 3번(#(2)) 회전해 봅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e59\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003eroll\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAG\u003c/span\u003e, shift=\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))     #(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003eroll\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAG\u003c/span\u003e, shift=-\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))    #(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_51.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e13. 형태와 변경\u003c/h1\u003e\n\u003cp\u003ePython 리스트에서는 len() 함수를 사용하여 요소의 개수를 알 수 있습니다. 그러나 이 방법은 다차원 배열에는 효과적이지 않을 수 있습니다. 다차원 배열에서는 len() 함수가 가장 바깥쪽 차원만을 세기 때문입니다. 아래의 코드 블록에서 len() 함수가 5를 반환하는 것을 볼 수 있습니다. 이는 전체 배열 차원을 나타내지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAH\u003c/span\u003e = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,   \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,  \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,  \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,  \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,  \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e], \n               [\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,   \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,  \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,  \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e], \n               [\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e17\u003c/span\u003e], \n               [\u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e19\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e21\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e], \n               [\u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e26\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e27\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e28\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e29\u003c/span\u003e]])\n\n\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAH\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_52.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003elen() 함수와 다르게 Numpy 배열의 shape 속성을 활용하면 더 정확한 결과를 얻을 수 있어요. 아래의 코드블록 61의 출력 결과를 보면 배열 AH가 5개의 내부 배열로 구성되어 있고, 각 내부 배열은 6개의 요소로 이루어져 있음을 알 수 있어요. 이를 이전 챕터에서 설명했던 대로 5×6 크기의 행렬로 생각할 수 있어요. 또는 이미지 처리에 관심이 있는 경우, 이는 높이가 5이고 너비가 6인 픽셀을 가진 이미지에 해당해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e61\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAH\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_53.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eNumpy는 reshape() 메소드를 통해 배열의 모양을 변경할 수 있게 해줘요. 다음 예제에서는 AH를 사이즈 (3,10)으로 재구성하는 방법을 보여드릴게요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e62\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAH\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_54.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e배열을 재구성할 때 중요한 점은 재구성 전후의 총 요소 수가 일정해야 한다는 것입니다. 다시 말해, 배열 차원은 총 요소 수의 인수여야 합니다. 이 요구 사항을 충족하지 못하면 오류가 발생합니다.\u003c/p\u003e\n\u003cp\u003e배열 재구성은 2D 배열에만 국한되지 않습니다. 아래 코드 블록에서 배열을 3D로 변환하는 예시를 보여드리겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e63\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAH\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_55.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e축에 대해 선택할 숫자를 확신할 수 없는 경우, 간단히 -1을 쓰면 Numpy가 해당 값을 자동으로 설정해줍니다. 그러나 한 번에 둘 이상의 -1을 전달할 수 없다는 점을 염두에 두세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e64\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAH\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_56.png\"\u003e\n\u003cp\u003e다음은 또 다른 예시입니다. 이 경우에는 배열을 30행 1열로 설정했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e65\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAH\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_57.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 다차원 배열을 1차원 배열로 재구성하고 싶다면 flatten()이나 reshape(-1) 메소드를 사용할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e66\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAH\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eflatten\u003c/span\u003e()\n\n### 대안\n# \u003cspan class=\"hljs-variable constant_\"\u003eAH\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_58.png\"\u003e\n\u003cp\u003e이 주제 외에도, 만약 배열에 빈 축을 추가하고 싶다면 np.newaxis를 사용할 수 있어요. 솔직히 말해서, 이 기술은 조금 직관적이지 않아요. 그래서, 제가 일반적으로 Codeblock 65에서 한 것과 같은 작업을 하는 데 np.reshape()를 사용해요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e코드 블록 67\u003c/h1\u003e\n\u003cp\u003eAH.flatten()[:, np.newaxis]\u003c/p\u003e\n\u003ch3\u003e대안\u003c/h3\u003e\n\u003ch1\u003eAH.flatten().reshape(-1,1)\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_59.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e아래는 np.newaxis에 대한 또 다른 예제입니다. 여기서는 행에 새로운 축을 추가하는 데 사용했습니다.\u003c/p\u003e\n\u003ch1\u003e코드 블록 68\u003c/h1\u003e\n\u003cp\u003eAH.flatten()[np.newaxis, :]\u003c/p\u003e\n\u003ch3\u003e대안\u003c/h3\u003e\n\u003ch1\u003eAH.flatten().reshape(1,-1)\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_60.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003ch1\u003e14. Concatenation and Splitting\u003c/h1\u003e\n\u003cp\u003e파이썬 리스트에 새 요소를 추가하려면 append() 메소드를 사용할 수 있습니다. Numpy에서는 np.vstack(), np.hstack(), np.append(), np.concatenate()와 같은 다양한 대안이 있습니다. 이러한 함수들은 모두 여러 배열을 결합하는 것이라는 기본 아이디어를 가지고 있지만, 이러한 함수들은 각각 다른 용도를 가지고 있습니다.\u003c/p\u003e\n\u003cp\u003e이 주제를 논의하기 전에 먼저 두 개의 새 배열 AI와 AJ를 초기화하고 싶습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e69\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAI\u003c/span\u003e = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandint\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)))\n\u003cspan class=\"hljs-variable constant_\"\u003eAJ\u003c/span\u003e = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandint\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)))\n\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAI\u003c/span\u003e, end=\u003cspan class=\"hljs-string\"\u003e'\\n\\n'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAJ\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_61.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e두 배열을 수직으로 연결하여 결합하려면 np.vstack()을 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e70\u003c/span\u003e\nnp.\u003cspan class=\"hljs-title function_\"\u003evstack\u003c/span\u003e((\u003cspan class=\"hljs-variable constant_\"\u003eAI\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eAJ\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e알수 있듯이, np.hstack()은 두 배열을 수평으로 쌓는 데 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e71\u003c/span\u003e\nnp.\u003cspan class=\"hljs-title function_\"\u003ehstack\u003c/span\u003e((\u003cspan class=\"hljs-variable constant_\"\u003eAI\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eAJ\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003enp.vstack()과 np.hstack() 함수는 여러 배열을 한 번에 쌓을 수 있습니다. 주의할 점은 배열의 열 수가 동일한 경우 수직 스택이 가능하다는 것입니다. 수평 스택의 경우, 배열의 행 수가 동일할 때만 작동합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e72\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003evstack\u003c/span\u003e((\u003cspan class=\"hljs-variable constant_\"\u003eAI\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eAJ\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eAJ\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eAJ\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eAI\u003c/span\u003e)), end=\u003cspan class=\"hljs-string\"\u003e'\\n\\n'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003ehstack\u003c/span\u003e((\u003cspan class=\"hljs-variable constant_\"\u003eAI\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eAJ\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eAJ\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eAJ\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eAI\u003c/span\u003e)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_64.png\"\u003e\n\u003cp\u003e또한, np.append() 함수는 배열을 연결하기 전에 먼저 배열을 평평하게 만든 후 작동합니다. 따라서 결과적으로 얻는 출력물은 1차원 배열이 됩니다. 이 기본 동작과는 상관없이 np.append() 함수를 np.vstack() 및 np.hstack()와 동일하게 작동하도록 axis 매개변수를 사용할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e코드 블록 73\u003c/h1\u003e\n\u003cp\u003eprint(np.append(AI, AJ), end='\\n\\n')\nprint(np.append(AI, AJ, axis=0), end='\\n\\n')\nprint(np.append(AI, AJ, axis=1))\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_65.png\"\u003e\n\u003cp\u003e사실 np.append() 함수는 한 번에 두 개 이상의 배열을 결합할 수 없습니다. 만약 그렇게 하고 싶다면 np.concatenate()를 사용할 수 있습니다. axis 매개변수도 np.append()와 동일하게 작동합니다. 만약 axis에 값을 지정하지 않으면 np.concatenate() 함수는 수직 스택을 수행합니다.\u003c/p\u003e\n\u003ch1\u003e코드 블록 74\u003c/h1\u003e\n\u003cp\u003eprint(np.concatenate([AI, AI, AI], axis=None), end='\\n\\n')\nprint(np.concatenate([AI, AI, AI]), end='\\n\\n')\nprint(np.concatenate([AI, AI, AI], axis=1))\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n 태그를 Markdown 형식으로 바꿔보세요.\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_66.png\"\u003e\n\u003ch2\u003eSplitting\u003c/h2\u003e\n\u003cp\u003e스택에 사용되는 것뿐만 아니라 Numpy는 분할을 위한 몇 가지 함수도 제공합니다. 아래의 배열 AK를 고려해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eCodeblock\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAK\u003c/span\u003e = np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandint\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, (\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e))\n\u003cspan class=\"hljs-variable constant_\"\u003eAK\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_67.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003enp.split() 함수를 먼저 소개하겠습니다. 이 함수는 두 가지 주요 매개변수를 받습니다: ary (나눌 배열) 및 indices_or_sections (분할 지점). 다음 코드에서는 배열 AL을 인덱스 3과 5에서 나누어 세 개의 새 배열을 얻으려고 합니다. 각 배열은 원본 배열에서 0부터 2까지, 3부터 4까지, 5부터 19까지의 범위를 갖습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드 블록 \u003cspan class=\"hljs-number\"\u003e76\u003c/span\u003e\nnp.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eAK\u003c/span\u003e, indices_or_sections=[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_68.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e2D 배열을 나누려면 np.hsplit() 또는 np.vsplit()을 사용할 수 있습니다. 사실 np.split()에 축 매개변수를 전달하여 동일한 작업을 수행할 수도 있습니다. 주요 아이디어는 기본적으로 동일하지만, np.vsplit() 및 np.hsplit()을 사용하여 분할 지점은 각각 행 번호와 열 번호를 참조합니다. 이러한 두 함수를 배열 AL에 대해 시연하겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 코드블록 \u003cspan class=\"hljs-number\"\u003e77\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eAL\u003c/span\u003e = np.\u003cspan class=\"hljs-property\"\u003erandom\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandint\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, (\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e))\n\u003cspan class=\"hljs-variable constant_\"\u003eAL\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_69.png\"\u003e\n\u003cp\u003e아래는 np.vsplit()을 사용하는 방법입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e코드 블록 78\u003c/h1\u003e\n\u003cp\u003enp.vsplit(AL, [2,4])\u003c/p\u003e\n\u003ch3\u003e대안\u003c/h3\u003e\n\u003ch1\u003enp.split(AL, [2,4], axis=0)\u003c/h1\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_70.png\"\u003e\n\u003cp\u003e마지막으로 np.hsplit() 사용법입니다.\u003c/p\u003e\n\u003ch1\u003e코드 블록 79\u003c/h1\u003e\n\u003cp\u003enp.hsplit(AL, [3,4])\u003c/p\u003e\n\u003ch3\u003e대안\u003c/h3\u003e\n\u003ch1\u003enp.split(AL, [3,4], axis=1) #동등한\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22_71.png\"\u003e\n\u003ch1\u003e마무리\u003c/h1\u003e\n\u003cp\u003e드디어 끝났어요! 지금까지 저가 자주 사용하는 NumPy 함수들을 다뤄봤어요. 사실 더 설명하지 않은 기능들도 많이 남아 있어요. 하지만 걱정하지 마세요. 이제 모든 기초를 마스터했기 때문에 쉽게 배울 수 있을 거예요.\u003c/p\u003e\n\u003cp\u003e읽어 주셔서 감사해요. 이 글이 유용했기를 바라며, 다음 글에서 만나요. 안녕히 계세요!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e참고 자료\u003c/h1\u003e\n\u003cp\u003e[1] Universal functions (ufunc). NumPy. \u003ca href=\"https://numpy.org/doc/stable/reference/ufuncs.html\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://numpy.org/doc/stable/reference/ufuncs.html\u003c/a\u003e [접속일: 2024년 1월 8일].\u003c/p\u003e\n\u003ch1\u003e쉽게 이해하기 🚀\u003c/h1\u003e\n\u003cp\u003eIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e작가를 칭찬하고 팔로우하려면 클랩을 눌러주세요! 👏\u003c/li\u003e\n\u003cli\u003e팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\u003c/li\u003e\n\u003cli\u003e다른 플랫폼에서 저희를 만나보세요: CoFeed | Differ\u003c/li\u003e\n\u003cli\u003e더 많은 콘텐츠: PlainEnglish.io\u003c/li\u003e\n\u003c/ul\u003e\u003ctable\u003e\u003c/table\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-MasteringNumPyAComprehensiveGuidetoEfficientArrayProcessingPart22"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>