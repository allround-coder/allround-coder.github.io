<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>백엔드에서 Server-Sent EventsSSE로 실시간 알림을 전달하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="백엔드에서 Server-Sent EventsSSE로 실시간 알림을 전달하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="백엔드에서 Server-Sent EventsSSE로 실시간 알림을 전달하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend" data-gatsby-head="true"/><meta name="twitter:title" content="백엔드에서 Server-Sent EventsSSE로 실시간 알림을 전달하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 22:16" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-742e6c91a18eb160.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">백엔드에서 Server-Sent EventsSSE로 실시간 알림을 전달하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="백엔드에서 Server-Sent EventsSSE로 실시간 알림을 전달하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>판매자 성장팀으로서, 우리의 업무에는 판매자들의 시스템과의 상호작용을 향상시키기 위해 고안된 작업들로 구성된 다양한 도전 과제를 지정, 추적 및 관리하는 것이 포함되어 있습니다.</p>
<p>우리의 최신 목표는 새로운 작업 지정 또는 완료시에 즉각적인 알림을 판매자들에게 제공하는 것입니다. 이를 달성하기 위해 HTTP 폴링, Server-Sent Events (SSE), 그리고 웹 소켓이라는 세 가지 잠재적인 옵션을 탐색했습니다.</p>
<p>이 글에서는 알림 시스템으로 SSE (Server-Sent Events)를 사용하기로 결정한 이유에 대해 논의할 것입니다. 우리가 고려한 다른 옵션들보다 SSE의 장점을 알아보고, NestJS 프레임워크를 사용한 TypeScript 코드의 명확한 예시를 제공할 것입니다.</p>
<p><img src="/assets/img/2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend_0.png" alt="이미지"></p>
<h1>사용한 기술 소개</h1>
<p>실시간 알림 시스템을 구현하기 위해 다음을 사용했습니다:</p>
<ul>
<li>Server-Sent Events (SSE): 실시간 및 일방향 채널을 서버와 클라이언트 간에 수립하는 데 SSE를 사용합니다. 이를 통해 알림을 발생 즉시 전달할 수 있습니다. SSE는 가벼우면서도 직관적인 솔루션이며, 우리의 요구에 맞는 알림을 클라이언트로 푸시할 때 사용합니다.</li>
<li>Redis Pub/Sub: Redis pub/sub을 사용하여 다중 발행자가 다중 구독자에게 메시지를 보낼 수 있는 메시징 시스템으로 활용합니다. Redis pub/sub을 사용하여 알림을 다중 파드로 분산 배포함으로써 모든 판매자가 제때 알림을 받을 수 있도록 보장했습니다.</li>
<li>Notification Write API: 다른 응용 프로그램에서 알림을 수집하기 위해 알림 쓰기 API를 개발했습니다. 이 API는 알림을 Redis로 전송합니다.</li>
<li>Notification Read API: Redis를 구독하고 모든 알림을 수신하는 알림 읽기 API도 개발했습니다. 알림을 수신한 후, 읽기 API는 SSE를 통해 연결된 클라이언트에게 알림을 전송합니다.</li>
</ul>
<h2>왜 SSE를 선택했는가</h2>
<p>신중한 고려 끝에 SSE가 알림 시스템에 최적인 옵션이라고 결정했습니다. 이 결정의 주요 이유 중 하나는 HTTP 폴링이 가능한 옵션이지만 즉각적인 알림 전달을 제공하지 않는다는 것입니다. 폴링은 서버가 새 이벤트를 확인하기 위해 일정 간격마다 터치되어야 하며 많은 사용자가 알림에 구독되어있는 경우에는 자원을 많이 사용하고 비효율적일 수 있습니다.</p>
<p>그에 비해 SSE는 서버와 클라이언트 사이의 실시간 단방향 채널을 제공하여 발생하는 즉시 알림을 즉시 전달할 수 있습니다. 이는 판매자가 즉시 알림을 받을 수 있도록 해야 하는 우리의 사용 사례에 있어서 중요합니다.</p>
<p>웹 소켓이 실시간 통신에 대한 인기 있는 선택지이긴 하지만, SSE에 비해 구현이 더 복잡합니다. 웹 소켓은 서버와 클라이언트 간의 양방향 통신을 제공하여 전체 이중 통신이 가능합니다. 하지만 우리는 클라이언트로 알림을 푸시하는 것만 필요하기 때문에 SSE를 더 간단하고 효율적인 솔루션으로 선택했습니다.</p>
<p>요약하면, 시간당 실시간 알림을 제공하고 웹 소켓에 비해 더 간단하고 가벼운 솔루션인 SSE를 사용하기로 결정했습니다.</p>
<h2>Redis Pub/Sub</h2>
<p>여러 응용 프로그램 팟에서 알림을 보내기 위해 Redis pub/sub을 사용했습니다. Redis pub/sub은 여러 발행자가 여러 구독자에게 메시지를 보낼 수 있는 메시징 시스템입니다. Redis pub/sub을 사용하여 알림을 여러 팟에 분산하여, 판매자가 모든 알림을 제때 받을 수 있도록 했습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Redis</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'ioredis'</span>;

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisService</span> implements <span class="hljs-title class_">OnModuleInit</span> {

  ...

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">onModuleInit</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscriber</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Redis</span>({
      <span class="hljs-attr">sentinels</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisSentinelConfig</span>.<span class="hljs-property">addresses</span>,
      <span class="hljs-attr">name</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisSentinelConfig</span>.<span class="hljs-property">masterName</span>,
      <span class="hljs-attr">password</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisSentinelConfig</span>.<span class="hljs-property">password</span>,
    });
    
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscriber</span>.<span class="hljs-title function_">subscribe</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">redisSentinelConfig</span>.<span class="hljs-property">channelName</span>, <span class="hljs-keyword">async</span> (err, count) => {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Failed to subscribe: <span class="hljs-subst">${err.message}</span>`</span>);
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Subscribed successfully! This client is currently subscribed to <span class="hljs-subst">${count}</span> channels`</span>);
    });
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscriber</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">async</span> (channel, <span class="hljs-attr">message</span>: string) => {
      <span class="hljs-keyword">const</span> <span class="hljs-attr">liveNotification</span>: <span class="hljs-title class_">LiveNotification</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(message);
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">liveNotificationService</span>.<span class="hljs-title function_">emit</span>(liveNotification);
    });
  }
}
</code></pre>
<h1>시스템 디자인</h1>
<p>다른 애플리케이션으로부터 알림을 수집하기 위해 알림 작성 API를 개발했습니다. 이 API는 알림을 Redis로 전송합니다. 알림 읽기 API는 Redis를 구독하고 모든 알림을 수신합니다. 알림을 수신한 후 읽기 API는 SSE를 통해 연결된 클라이언트에게 알림을 전송합니다.</p>
<p>다양한 읽기 API가 서로 다른 애플리케이션 팟에서 실행될 수 있기 때문에 각 읽기 API는 Redis에서 모든 알림을 수신합니다. 그러나 읽기 API는 현재 팟에 연결된 클라이언트에 따라 알림을 필터링합니다. 이렇게 함으로써 연결된 각 클라이언트에게는 관련 알림만 전송되어 네트워크로 전송되는 불필요한 데이터 양을 최소화합니다.</p>
<p>판매자를 위해 Redis pub/sub를 통해 발행된 알림이 모든 읽기 API 인스턴스에 수신됩니다. 그러나 모든 알림이 모든 연결된 클라이언트에게 관련이 있는 것은 아닙니다. 연결된 각 클라이언트에게는 관련 알림만 전송되도록 하기 위해 읽기 API는 클라이언트의 구독에 따라 알림을 필터링합니다.</p>
<p>[2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend_1.png] 를 참고하세요.</p>
<p>table 태그를 Markdown 형식으로 변경하십시오.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">AuthGuard</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/passport'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Sse</span>, <span class="hljs-title class_">UseGuards</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

@<span class="hljs-title class_">Controller</span>(<span class="hljs-string">'/live-notification'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LiveNotificationController</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private readonly liveNotificationService: LiveNotificationService</span>) {}

  @<span class="hljs-title class_">Sse</span>()
  @<span class="hljs-title class_">ApiBearerAuth</span>()
  @<span class="hljs-title class_">UseGuards</span>(<span class="hljs-title class_">AuthGuard</span>(<span class="hljs-string">'jwt'</span>))
  public <span class="hljs-title function_">getEventsBySeller</span>(<span class="hljs-params">@Tracers() tracers: ITracers, @SellerId() sellerId: number</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">liveNotificationService</span>.<span class="hljs-title function_">subscribeForSeller</span>(sellerId);
  }
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">EventEmitter</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'events'</span>;
<span class="hljs-keyword">import</span> { filter, fromEvent } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LiveNotificationService</span> implements <span class="hljs-title class_">OnModuleInit</span> {
  
  private readonly emitter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventEmitter</span>();
  
  ...
  
  public <span class="hljs-keyword">async</span> <span class="hljs-title function_">emit</span>(<span class="hljs-params">data: LiveNotification</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">emitter</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'liveNotification'</span>, { data });
  }
  
  public <span class="hljs-title function_">subscribeForSeller</span>(<span class="hljs-params">sellerId: number</span>) {
    <span class="hljs-keyword">const</span> source = <span class="hljs-title function_">fromEvent</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">emitter</span>, <span class="hljs-string">'liveNotification'</span>);
    <span class="hljs-keyword">return</span> source.<span class="hljs-title function_">pipe</span>(
      <span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">{ data: liveNotification }</span>) =></span> 
        liveNotification?.<span class="hljs-property">content</span> == <span class="hljs-string">'heartbeat'</span> || 
        liveNotification?.<span class="hljs-property">sellerId</span> == sellerId)
    );
  }
}
</code></pre>
<h1>문제점</h1>
<h2>수직 확장 문제</h2>
<p>우리의 SSE와 Redis 기반 알림 시스템은 연결된 클라이언트에 신속하고 효율적으로 알림을 전달합니다. 그러나 알림이 증가함에 따라 모든 읽기 API가 모든 알림을 구독하기 때문에 시스템에서 잠재적인 수직 확장 문제가 예상됩니다. 이는 시스템에서 잠재적 병목 현상을 일으킬 수 있습니다. 판매자를 위해 Redis pub/sub를 통해 알림이 발행되면 읽기 API의 모든 인스턴스에서 받게 되지만, 모든 알림이 모든 연결된 클라이언트에게 관련이 있는 것은 아닙니다. 각 연결된 클라이언트에게는 관련 있는 알림만 전송되도록 하기 위해 읽기 API에서 고객의 구독에 따라 알림을 필터링합니다. 알림의 수가 많아지면 이 필터링 과정이 느려져 알림 전송이 지연될 수 있습니다.</p>
<h2>하트비트 메시지</h2>
<p>우리 프론트엔드 개발자들은 권한 부여 헤더를 보내기 위해 이벤트 소스 라이브러리를 사용했습니다. 그러나 서버와 브라우저 간 연결이 1분 후에 끊어진다고 보고했습니다. 문제를 조사한 후 라이브러리가 끊김을 감지하기 위해 하트비트 메시지를 보내도록 요구함을 깨닫게 되었습니다. 문제를 해결하기 위해 30초마다 하트비트 메시지를 보내는 기능을 구현하여 문제를 해결했습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">onModuleInit</span>(): any {
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =></span> {
    <span class="hljs-keyword">const</span> emitterListenerCount = <span class="hljs-variable language_">this</span>.<span class="hljs-property">emitter</span>.<span class="hljs-title function_">listenerCount</span>(<span class="hljs-string">'liveNotification'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`활성 에미터 리스너 수를 가진 SSE 클라이언트로 하트비트 메시지를 보냈습니다: <span class="hljs-subst">${emitterListenerCount}</span>`</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">emitter</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'liveNotification'</span>, { <span class="hljs-attr">data</span>: { <span class="hljs-attr">content</span>: <span class="hljs-string">'heartbeat'</span> } });
  }, <span class="hljs-number">30000</span>);
}
</code></pre>
<h1>성능</h1>
<p>현재 알림 시스템은 90,000개의 동시 연결을 처리하고 있으며, 우리는 15개의 팟을 운영 중이며 부하를 처리하고 있습니다. 각 Kubernetes 팟은 약 800MB의 메모리와 300Mi의 CPU 리소스를 소비합니다.</p>
<h1>요약</h1>
<p>서버-센트 이벤트(SSE)는 실시간 알림 전달 기능을 제공하면서 웹 소켓과 비교해 더 간단하고 가벼운 솔루션으로 입증되었습니다. Redis pub/sub를 사용하여 알림을 여러 팟에 분산하여 모든 클라이언트가 제때 알림을 수신하도록 보장했습니다. SSE 기반의 알림 시스템을 통해 우리는 클라이언트에게 알림을 효과적으로 전달하는 안정적이고 효율적인 솔루션을 성공적으로 구축했습니다.</p>
<p>프론트엔드 세부 정보와 구현에 대해 좀 더 알고 싶다면, 제 동료가 쓴 기사를 읽어보시기를 추천합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"백엔드에서 Server-Sent EventsSSE로 실시간 알림을 전달하는 방법","description":"","date":"2024-05-20 22:16","slug":"2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend","content":"\n\n판매자 성장팀으로서, 우리의 업무에는 판매자들의 시스템과의 상호작용을 향상시키기 위해 고안된 작업들로 구성된 다양한 도전 과제를 지정, 추적 및 관리하는 것이 포함되어 있습니다.\n\n우리의 최신 목표는 새로운 작업 지정 또는 완료시에 즉각적인 알림을 판매자들에게 제공하는 것입니다. 이를 달성하기 위해 HTTP 폴링, Server-Sent Events (SSE), 그리고 웹 소켓이라는 세 가지 잠재적인 옵션을 탐색했습니다.\n\n이 글에서는 알림 시스템으로 SSE (Server-Sent Events)를 사용하기로 결정한 이유에 대해 논의할 것입니다. 우리가 고려한 다른 옵션들보다 SSE의 장점을 알아보고, NestJS 프레임워크를 사용한 TypeScript 코드의 명확한 예시를 제공할 것입니다.\n\n![이미지](/assets/img/2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 사용한 기술 소개\n\n실시간 알림 시스템을 구현하기 위해 다음을 사용했습니다:\n\n- Server-Sent Events (SSE): 실시간 및 일방향 채널을 서버와 클라이언트 간에 수립하는 데 SSE를 사용합니다. 이를 통해 알림을 발생 즉시 전달할 수 있습니다. SSE는 가벼우면서도 직관적인 솔루션이며, 우리의 요구에 맞는 알림을 클라이언트로 푸시할 때 사용합니다.\n- Redis Pub/Sub: Redis pub/sub을 사용하여 다중 발행자가 다중 구독자에게 메시지를 보낼 수 있는 메시징 시스템으로 활용합니다. Redis pub/sub을 사용하여 알림을 다중 파드로 분산 배포함으로써 모든 판매자가 제때 알림을 받을 수 있도록 보장했습니다.\n- Notification Write API: 다른 응용 프로그램에서 알림을 수집하기 위해 알림 쓰기 API를 개발했습니다. 이 API는 알림을 Redis로 전송합니다.\n- Notification Read API: Redis를 구독하고 모든 알림을 수신하는 알림 읽기 API도 개발했습니다. 알림을 수신한 후, 읽기 API는 SSE를 통해 연결된 클라이언트에게 알림을 전송합니다.\n\n## 왜 SSE를 선택했는가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n신중한 고려 끝에 SSE가 알림 시스템에 최적인 옵션이라고 결정했습니다. 이 결정의 주요 이유 중 하나는 HTTP 폴링이 가능한 옵션이지만 즉각적인 알림 전달을 제공하지 않는다는 것입니다. 폴링은 서버가 새 이벤트를 확인하기 위해 일정 간격마다 터치되어야 하며 많은 사용자가 알림에 구독되어있는 경우에는 자원을 많이 사용하고 비효율적일 수 있습니다.\n\n그에 비해 SSE는 서버와 클라이언트 사이의 실시간 단방향 채널을 제공하여 발생하는 즉시 알림을 즉시 전달할 수 있습니다. 이는 판매자가 즉시 알림을 받을 수 있도록 해야 하는 우리의 사용 사례에 있어서 중요합니다.\n\n웹 소켓이 실시간 통신에 대한 인기 있는 선택지이긴 하지만, SSE에 비해 구현이 더 복잡합니다. 웹 소켓은 서버와 클라이언트 간의 양방향 통신을 제공하여 전체 이중 통신이 가능합니다. 하지만 우리는 클라이언트로 알림을 푸시하는 것만 필요하기 때문에 SSE를 더 간단하고 효율적인 솔루션으로 선택했습니다.\n\n요약하면, 시간당 실시간 알림을 제공하고 웹 소켓에 비해 더 간단하고 가벼운 솔루션인 SSE를 사용하기로 결정했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Redis Pub/Sub\n\n여러 응용 프로그램 팟에서 알림을 보내기 위해 Redis pub/sub을 사용했습니다. Redis pub/sub은 여러 발행자가 여러 구독자에게 메시지를 보낼 수 있는 메시징 시스템입니다. Redis pub/sub을 사용하여 알림을 여러 팟에 분산하여, 판매자가 모든 알림을 제때 받을 수 있도록 했습니다.\n\n```js\nimport { Redis } from 'ioredis';\n\n@Injectable()\nexport class RedisService implements OnModuleInit {\n\n  ...\n\n  async onModuleInit() {\n    this.subscriber = new Redis({\n      sentinels: this.redisSentinelConfig.addresses,\n      name: this.redisSentinelConfig.masterName,\n      password: this.redisSentinelConfig.password,\n    });\n    \n    await this.subscriber.subscribe(this.redisSentinelConfig.channelName, async (err, count) =\u003e {\n      if (err) {\n        this.logger.error(`Failed to subscribe: ${err.message}`);\n        return;\n      }\n      this.logger.log(`Subscribed successfully! This client is currently subscribed to ${count} channels`);\n    });\n    \n    this.subscriber.on('message', async (channel, message: string) =\u003e {\n      const liveNotification: LiveNotification = JSON.parse(message);\n      await this.liveNotificationService.emit(liveNotification);\n    });\n  }\n}\n```\n\n# 시스템 디자인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 애플리케이션으로부터 알림을 수집하기 위해 알림 작성 API를 개발했습니다. 이 API는 알림을 Redis로 전송합니다. 알림 읽기 API는 Redis를 구독하고 모든 알림을 수신합니다. 알림을 수신한 후 읽기 API는 SSE를 통해 연결된 클라이언트에게 알림을 전송합니다.\n\n다양한 읽기 API가 서로 다른 애플리케이션 팟에서 실행될 수 있기 때문에 각 읽기 API는 Redis에서 모든 알림을 수신합니다. 그러나 읽기 API는 현재 팟에 연결된 클라이언트에 따라 알림을 필터링합니다. 이렇게 함으로써 연결된 각 클라이언트에게는 관련 알림만 전송되어 네트워크로 전송되는 불필요한 데이터 양을 최소화합니다.\n\n판매자를 위해 Redis pub/sub를 통해 발행된 알림이 모든 읽기 API 인스턴스에 수신됩니다. 그러나 모든 알림이 모든 연결된 클라이언트에게 관련이 있는 것은 아닙니다. 연결된 각 클라이언트에게는 관련 알림만 전송되도록 하기 위해 읽기 API는 클라이언트의 구독에 따라 알림을 필터링합니다.\n\n[2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend_1.png] 를 참고하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ntable 태그를 Markdown 형식으로 변경하십시오.\n\n```js\nimport { AuthGuard } from '@nestjs/passport';\nimport { Controller, Sse, UseGuards } from '@nestjs/common';\n\n@Controller('/live-notification')\nexport class LiveNotificationController {\n  constructor(private readonly liveNotificationService: LiveNotificationService) {}\n\n  @Sse()\n  @ApiBearerAuth()\n  @UseGuards(AuthGuard('jwt'))\n  public getEventsBySeller(@Tracers() tracers: ITracers, @SellerId() sellerId: number) {\n    return this.liveNotificationService.subscribeForSeller(sellerId);\n  }\n}\n```\n\n```js\nimport { EventEmitter } from 'events';\nimport { filter, fromEvent } from 'rxjs';\n\n@Injectable()\nexport class LiveNotificationService implements OnModuleInit {\n  \n  private readonly emitter = new EventEmitter();\n  \n  ...\n  \n  public async emit(data: LiveNotification) {\n    this.emitter.emit('liveNotification', { data });\n  }\n  \n  public subscribeForSeller(sellerId: number) {\n    const source = fromEvent(this.emitter, 'liveNotification');\n    return source.pipe(\n      filter(({ data: liveNotification }) =\u003e \n        liveNotification?.content == 'heartbeat' || \n        liveNotification?.sellerId == sellerId)\n    );\n  }\n}\n```\n\n# 문제점\n\n## 수직 확장 문제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 SSE와 Redis 기반 알림 시스템은 연결된 클라이언트에 신속하고 효율적으로 알림을 전달합니다. 그러나 알림이 증가함에 따라 모든 읽기 API가 모든 알림을 구독하기 때문에 시스템에서 잠재적인 수직 확장 문제가 예상됩니다. 이는 시스템에서 잠재적 병목 현상을 일으킬 수 있습니다. 판매자를 위해 Redis pub/sub를 통해 알림이 발행되면 읽기 API의 모든 인스턴스에서 받게 되지만, 모든 알림이 모든 연결된 클라이언트에게 관련이 있는 것은 아닙니다. 각 연결된 클라이언트에게는 관련 있는 알림만 전송되도록 하기 위해 읽기 API에서 고객의 구독에 따라 알림을 필터링합니다. 알림의 수가 많아지면 이 필터링 과정이 느려져 알림 전송이 지연될 수 있습니다.\n\n## 하트비트 메시지\n\n우리 프론트엔드 개발자들은 권한 부여 헤더를 보내기 위해 이벤트 소스 라이브러리를 사용했습니다. 그러나 서버와 브라우저 간 연결이 1분 후에 끊어진다고 보고했습니다. 문제를 조사한 후 라이브러리가 끊김을 감지하기 위해 하트비트 메시지를 보내도록 요구함을 깨닫게 되었습니다. 문제를 해결하기 위해 30초마다 하트비트 메시지를 보내는 기능을 구현하여 문제를 해결했습니다.\n\n```js\nonModuleInit(): any {\n  setInterval(() =\u003e {\n    const emitterListenerCount = this.emitter.listenerCount('liveNotification');\n    this.logger.log(`활성 에미터 리스너 수를 가진 SSE 클라이언트로 하트비트 메시지를 보냈습니다: ${emitterListenerCount}`);\n    this.emitter.emit('liveNotification', { data: { content: 'heartbeat' } });\n  }, 30000);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 성능\n\n현재 알림 시스템은 90,000개의 동시 연결을 처리하고 있으며, 우리는 15개의 팟을 운영 중이며 부하를 처리하고 있습니다. 각 Kubernetes 팟은 약 800MB의 메모리와 300Mi의 CPU 리소스를 소비합니다.\n\n# 요약\n\n서버-센트 이벤트(SSE)는 실시간 알림 전달 기능을 제공하면서 웹 소켓과 비교해 더 간단하고 가벼운 솔루션으로 입증되었습니다. Redis pub/sub를 사용하여 알림을 여러 팟에 분산하여 모든 클라이언트가 제때 알림을 수신하도록 보장했습니다. SSE 기반의 알림 시스템을 통해 우리는 클라이언트에게 알림을 효과적으로 전달하는 안정적이고 효율적인 솔루션을 성공적으로 구축했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드 세부 정보와 구현에 대해 좀 더 알고 싶다면, 제 동료가 쓴 기사를 읽어보시기를 추천합니다.","ogImage":{"url":"/assets/img/2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend_0.png"},"coverImage":"/assets/img/2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e판매자 성장팀으로서, 우리의 업무에는 판매자들의 시스템과의 상호작용을 향상시키기 위해 고안된 작업들로 구성된 다양한 도전 과제를 지정, 추적 및 관리하는 것이 포함되어 있습니다.\u003c/p\u003e\n\u003cp\u003e우리의 최신 목표는 새로운 작업 지정 또는 완료시에 즉각적인 알림을 판매자들에게 제공하는 것입니다. 이를 달성하기 위해 HTTP 폴링, Server-Sent Events (SSE), 그리고 웹 소켓이라는 세 가지 잠재적인 옵션을 탐색했습니다.\u003c/p\u003e\n\u003cp\u003e이 글에서는 알림 시스템으로 SSE (Server-Sent Events)를 사용하기로 결정한 이유에 대해 논의할 것입니다. 우리가 고려한 다른 옵션들보다 SSE의 장점을 알아보고, NestJS 프레임워크를 사용한 TypeScript 코드의 명확한 예시를 제공할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e사용한 기술 소개\u003c/h1\u003e\n\u003cp\u003e실시간 알림 시스템을 구현하기 위해 다음을 사용했습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eServer-Sent Events (SSE): 실시간 및 일방향 채널을 서버와 클라이언트 간에 수립하는 데 SSE를 사용합니다. 이를 통해 알림을 발생 즉시 전달할 수 있습니다. SSE는 가벼우면서도 직관적인 솔루션이며, 우리의 요구에 맞는 알림을 클라이언트로 푸시할 때 사용합니다.\u003c/li\u003e\n\u003cli\u003eRedis Pub/Sub: Redis pub/sub을 사용하여 다중 발행자가 다중 구독자에게 메시지를 보낼 수 있는 메시징 시스템으로 활용합니다. Redis pub/sub을 사용하여 알림을 다중 파드로 분산 배포함으로써 모든 판매자가 제때 알림을 받을 수 있도록 보장했습니다.\u003c/li\u003e\n\u003cli\u003eNotification Write API: 다른 응용 프로그램에서 알림을 수집하기 위해 알림 쓰기 API를 개발했습니다. 이 API는 알림을 Redis로 전송합니다.\u003c/li\u003e\n\u003cli\u003eNotification Read API: Redis를 구독하고 모든 알림을 수신하는 알림 읽기 API도 개발했습니다. 알림을 수신한 후, 읽기 API는 SSE를 통해 연결된 클라이언트에게 알림을 전송합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e왜 SSE를 선택했는가\u003c/h2\u003e\n\u003cp\u003e신중한 고려 끝에 SSE가 알림 시스템에 최적인 옵션이라고 결정했습니다. 이 결정의 주요 이유 중 하나는 HTTP 폴링이 가능한 옵션이지만 즉각적인 알림 전달을 제공하지 않는다는 것입니다. 폴링은 서버가 새 이벤트를 확인하기 위해 일정 간격마다 터치되어야 하며 많은 사용자가 알림에 구독되어있는 경우에는 자원을 많이 사용하고 비효율적일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그에 비해 SSE는 서버와 클라이언트 사이의 실시간 단방향 채널을 제공하여 발생하는 즉시 알림을 즉시 전달할 수 있습니다. 이는 판매자가 즉시 알림을 받을 수 있도록 해야 하는 우리의 사용 사례에 있어서 중요합니다.\u003c/p\u003e\n\u003cp\u003e웹 소켓이 실시간 통신에 대한 인기 있는 선택지이긴 하지만, SSE에 비해 구현이 더 복잡합니다. 웹 소켓은 서버와 클라이언트 간의 양방향 통신을 제공하여 전체 이중 통신이 가능합니다. 하지만 우리는 클라이언트로 알림을 푸시하는 것만 필요하기 때문에 SSE를 더 간단하고 효율적인 솔루션으로 선택했습니다.\u003c/p\u003e\n\u003cp\u003e요약하면, 시간당 실시간 알림을 제공하고 웹 소켓에 비해 더 간단하고 가벼운 솔루션인 SSE를 사용하기로 결정했습니다.\u003c/p\u003e\n\u003ch2\u003eRedis Pub/Sub\u003c/h2\u003e\n\u003cp\u003e여러 응용 프로그램 팟에서 알림을 보내기 위해 Redis pub/sub을 사용했습니다. Redis pub/sub은 여러 발행자가 여러 구독자에게 메시지를 보낼 수 있는 메시징 시스템입니다. Redis pub/sub을 사용하여 알림을 여러 팟에 분산하여, 판매자가 모든 알림을 제때 받을 수 있도록 했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eRedis\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'ioredis'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRedisService\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eOnModuleInit\u003c/span\u003e {\n\n  ...\n\n  \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eonModuleInit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esubscriber\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRedis\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003esentinels\u003c/span\u003e: \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eredisSentinelConfig\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eaddresses\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eredisSentinelConfig\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emasterName\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003epassword\u003c/span\u003e: \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eredisSentinelConfig\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003epassword\u003c/span\u003e,\n    });\n    \n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esubscriber\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eredisSentinelConfig\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003echannelName\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (err, count) =\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elogger\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Failed to subscribe: \u003cspan class=\"hljs-subst\"\u003e${err.message}\u003c/span\u003e`\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n      }\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elogger\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Subscribed successfully! This client is currently subscribed to \u003cspan class=\"hljs-subst\"\u003e${count}\u003c/span\u003e channels`\u003c/span\u003e);\n    });\n    \n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esubscriber\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'message'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (channel, \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: string) =\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eliveNotification\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eLiveNotification\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(message);\n      \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eliveNotificationService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(liveNotification);\n    });\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e시스템 디자인\u003c/h1\u003e\n\u003cp\u003e다른 애플리케이션으로부터 알림을 수집하기 위해 알림 작성 API를 개발했습니다. 이 API는 알림을 Redis로 전송합니다. 알림 읽기 API는 Redis를 구독하고 모든 알림을 수신합니다. 알림을 수신한 후 읽기 API는 SSE를 통해 연결된 클라이언트에게 알림을 전송합니다.\u003c/p\u003e\n\u003cp\u003e다양한 읽기 API가 서로 다른 애플리케이션 팟에서 실행될 수 있기 때문에 각 읽기 API는 Redis에서 모든 알림을 수신합니다. 그러나 읽기 API는 현재 팟에 연결된 클라이언트에 따라 알림을 필터링합니다. 이렇게 함으로써 연결된 각 클라이언트에게는 관련 알림만 전송되어 네트워크로 전송되는 불필요한 데이터 양을 최소화합니다.\u003c/p\u003e\n\u003cp\u003e판매자를 위해 Redis pub/sub를 통해 발행된 알림이 모든 읽기 API 인스턴스에 수신됩니다. 그러나 모든 알림이 모든 연결된 클라이언트에게 관련이 있는 것은 아닙니다. 연결된 각 클라이언트에게는 관련 알림만 전송되도록 하기 위해 읽기 API는 클라이언트의 구독에 따라 알림을 필터링합니다.\u003c/p\u003e\n\u003cp\u003e[2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend_1.png] 를 참고하세요.\u003c/p\u003e\n\u003cp\u003etable 태그를 Markdown 형식으로 변경하십시오.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eAuthGuard\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/passport'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eSse\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eUseGuards\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/live-notification'\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLiveNotificationController\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate readonly liveNotificationService: LiveNotificationService\u003c/span\u003e) {}\n\n  @\u003cspan class=\"hljs-title class_\"\u003eSse\u003c/span\u003e()\n  @\u003cspan class=\"hljs-title class_\"\u003eApiBearerAuth\u003c/span\u003e()\n  @\u003cspan class=\"hljs-title class_\"\u003eUseGuards\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eAuthGuard\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'jwt'\u003c/span\u003e))\n  public \u003cspan class=\"hljs-title function_\"\u003egetEventsBySeller\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e@Tracers() tracers: ITracers, @SellerId() sellerId: number\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eliveNotificationService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esubscribeForSeller\u003c/span\u003e(sellerId);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eEventEmitter\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'events'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { filter, fromEvent } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLiveNotificationService\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eOnModuleInit\u003c/span\u003e {\n  \n  private readonly emitter = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEventEmitter\u003c/span\u003e();\n  \n  ...\n  \n  public \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata: LiveNotification\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eemitter\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'liveNotification'\u003c/span\u003e, { data });\n  }\n  \n  public \u003cspan class=\"hljs-title function_\"\u003esubscribeForSeller\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esellerId: number\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source = \u003cspan class=\"hljs-title function_\"\u003efromEvent\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eemitter\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'liveNotification'\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e source.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\n      \u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ data: liveNotification }\u003c/span\u003e) =\u003e\u003c/span\u003e \n        liveNotification?.\u003cspan class=\"hljs-property\"\u003econtent\u003c/span\u003e == \u003cspan class=\"hljs-string\"\u003e'heartbeat'\u003c/span\u003e || \n        liveNotification?.\u003cspan class=\"hljs-property\"\u003esellerId\u003c/span\u003e == sellerId)\n    );\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e문제점\u003c/h1\u003e\n\u003ch2\u003e수직 확장 문제\u003c/h2\u003e\n\u003cp\u003e우리의 SSE와 Redis 기반 알림 시스템은 연결된 클라이언트에 신속하고 효율적으로 알림을 전달합니다. 그러나 알림이 증가함에 따라 모든 읽기 API가 모든 알림을 구독하기 때문에 시스템에서 잠재적인 수직 확장 문제가 예상됩니다. 이는 시스템에서 잠재적 병목 현상을 일으킬 수 있습니다. 판매자를 위해 Redis pub/sub를 통해 알림이 발행되면 읽기 API의 모든 인스턴스에서 받게 되지만, 모든 알림이 모든 연결된 클라이언트에게 관련이 있는 것은 아닙니다. 각 연결된 클라이언트에게는 관련 있는 알림만 전송되도록 하기 위해 읽기 API에서 고객의 구독에 따라 알림을 필터링합니다. 알림의 수가 많아지면 이 필터링 과정이 느려져 알림 전송이 지연될 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e하트비트 메시지\u003c/h2\u003e\n\u003cp\u003e우리 프론트엔드 개발자들은 권한 부여 헤더를 보내기 위해 이벤트 소스 라이브러리를 사용했습니다. 그러나 서버와 브라우저 간 연결이 1분 후에 끊어진다고 보고했습니다. 문제를 조사한 후 라이브러리가 끊김을 감지하기 위해 하트비트 메시지를 보내도록 요구함을 깨닫게 되었습니다. 문제를 해결하기 위해 30초마다 하트비트 메시지를 보내는 기능을 구현하여 문제를 해결했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eonModuleInit\u003c/span\u003e(): any {\n  \u003cspan class=\"hljs-built_in\"\u003esetInterval\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e emitterListenerCount = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eemitter\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elistenerCount\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'liveNotification'\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elogger\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`활성 에미터 리스너 수를 가진 SSE 클라이언트로 하트비트 메시지를 보냈습니다: \u003cspan class=\"hljs-subst\"\u003e${emitterListenerCount}\u003c/span\u003e`\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eemitter\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'liveNotification'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'heartbeat'\u003c/span\u003e } });\n  }, \u003cspan class=\"hljs-number\"\u003e30000\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e성능\u003c/h1\u003e\n\u003cp\u003e현재 알림 시스템은 90,000개의 동시 연결을 처리하고 있으며, 우리는 15개의 팟을 운영 중이며 부하를 처리하고 있습니다. 각 Kubernetes 팟은 약 800MB의 메모리와 300Mi의 CPU 리소스를 소비합니다.\u003c/p\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003e서버-센트 이벤트(SSE)는 실시간 알림 전달 기능을 제공하면서 웹 소켓과 비교해 더 간단하고 가벼운 솔루션으로 입증되었습니다. Redis pub/sub를 사용하여 알림을 여러 팟에 분산하여 모든 클라이언트가 제때 알림을 수신하도록 보장했습니다. SSE 기반의 알림 시스템을 통해 우리는 클라이언트에게 알림을 효과적으로 전달하는 안정적이고 효율적인 솔루션을 성공적으로 구축했습니다.\u003c/p\u003e\n\u003cp\u003e프론트엔드 세부 정보와 구현에 대해 좀 더 알고 싶다면, 제 동료가 쓴 기사를 읽어보시기를 추천합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-HowWeUsedServer-SentEventsSSEtoDeliverReal-TimeNotificationsonOurBackend"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>