<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Typescript 런타임 설정 완벽 마스터하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-24-MasteringTypescriptRuntimeConfigurations" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Typescript 런타임 설정 완벽 마스터하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Typescript 런타임 설정 완벽 마스터하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-24-MasteringTypescriptRuntimeConfigurations" data-gatsby-head="true"/><meta name="twitter:title" content="Typescript 런타임 설정 완벽 마스터하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-24 02:24" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_buildManifest.js" defer=""></script><script src="/_next/static/QH5Mz7n7Y6w0r4_gCGFQf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Typescript 런타임 설정 완벽 마스터하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Typescript 런타임 설정 완벽 마스터하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 24, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-24-MasteringTypescriptRuntimeConfigurations&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>모든 사람이 경력 초반에 배우는 구성은 중요합니다. 대부분의 사람들은 처음에 배운 방법을 고수합니다. 저는 웹 개발을 10년 이상 해왔고, 무수히 많은 구성 방법을 보았습니다. 오늘은 여러분의 앱 구성을 좀 더 쉽게 만들어드리고, 물론 제 새로운 패키지 <a href="https://github.com/mrspartak/config" rel="nofollow" target="_blank">https://github.com/mrspartak/config</a> 를 홍보하기 위해 여기에 왔습니다.</p>
<p><img src="/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png" alt="이미지"></p>
<p>저는 풀 스택 개발자이지만, 백엔드와 프론트엔드 구성을 실제로 구분하지 않습니다. 둘 다 빌드 시간 및 실행 시간 구성을 사용할 수 있기 때문에 유사합니다. 우리는 컨테이너화 시대에 살고 있으므로, 주로 이 유형의 배포에 초점을 맞출 것입니다. 다음 섹션에 있는 통찰은 매우 주관적이므로, 다른 의견이 있으면 댓글로 의견을 공유해 주시면 감사하겠습니다.</p>
<h2>빌드 시간 구성.</h2>
<div class="content-ad"></div>
<p>백엔드에서는 빌드 시간 구성이 그리 흔하지는 않지만, 프론트엔드에서는 상당히 인기 있는 방식입니다. 여기에서는 구성 값을 패키지나 이미지에 포함하여 응용 프로그램을 실행하는 데 충분하게 활용합니다. 제게는 빌드 시간에 환경과 관련된 모든 것을 처리하는 것이 합리적으로 보입니다. 이는 코드에서의 IO 작업 동작에 영향을 주는 구체적인 테스트, 스테이징 및 프로덕션 환경 구성을 포함합니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1200/1*WIXN4ZkEhqUXVOfalToyAg.gif" alt="image"></p>
<p>그러나 어떤 사람들은 API 엔드포인트, 인증 키 등 외부 구성 요소를 빌드 시간에 포함하는 것이 너무 멀리간다고 생각합니다. 이 방식은 작동하지만, 각 환경별로 패키지 또는 이미지를 다시 빌드하고 테스트해야 하므로 빌드 사이에 불일치가 발생할 수 있습니다.</p>
<h2>런타임 구성.</h2>
<div class="content-ad"></div>
<p>이 곳이 백엔드의 진정한 빛이 나오는 곳입니다. 그러나 SSR (서버 측 렌더링) 및 SPA (단일 페이지 어플리케이션) 프론트 엔드에서 런타임 구성을 자주 사용합니다. 앱이 로드되는 가장 처음에 실행 구성 정보가 로드됩니다. 런타임 구성은 모든 외부 구성을 포함해야 하며, 환경에 따라 크게 다를 수 있습니다. 여기서 일회성 환경의 장점이 발휘되며, 더 큰 유연성과 적응성을 제공합니다.</p>
<h2>어떻게 구성하나요?</h2>
<p>그래서 구성이 정확히 무엇인가요? 네, 당신은 <code>.env</code> 파일을 알고 계시죠... 또는 <code>.toml</code>. 아마도 <code>.json</code> 또는 <code>.ini</code>도요? 음, 그냥 <code>.ts</code> 파일을 만들고 그 안에서 객체를 내보내겠습니다. 하지만 기다려주세요. 그 파일을 git에 커밋해야 할까요? 각 환경 당 파일을 만들어 비밀 데이터를 커밋해야 할까요?</p>
<p><img src="https://miro.medium.com/v2/resize:fit:960/1*7S4sjloFaBx5isjqi_OAXw.gif" alt="이미지"></p>
<div class="content-ad"></div>
<p>우리는 어떤 형식이 가장 좋은지를 두고 전쟁을 일으킬 수 있지만, 사실 별로 중요하지 않아요. 읽기 쉽고 확장 가능하며 텍스트로 저장할 수 있는 형식이라면 충분하죠. 당신이 사용하기 편한 형식으로 선택하세요. 하지만 저장 및 사용 전략은 상당히 중요합니다.</p>
<p>저장 측면에서, Kubernetes (k8s), Docker Swarm 또는 순수한 Docker를 사용한다면 아마도 설정 및 비밀키에 익숙할 것입니다. 이를 통해 코드와 함께 실행 중인 컨테이너에 어떤 파일이나 폴더를 첨부할 수 있어요. 대부분의 어려움은 개발 환경이나 프로덕션 환경으로 새 구성을 배포할 때 발생한다고 보아요.</p>
<h2>유효성 검사, 유효성 검사, 유효성 검사</h2>
<p>구성은 선언부터 시작돼요. 정말 간단하죠. 백엔드에서 데이터베이스를 호출해야 한다면, 해당 데이터베이스에 인증하는 데 필요한 것을 파악하고 구성 선언에 넣으세요. 그 결과로 얻는 것은 - 어플리케이션이 다운될 때입니다. 하지만 이것이 우리가 원하는 것이에요. 이를 통해 누락되거나 잘못된 구성을 조기에 식별할 수 있어요.</p>
<div class="content-ad"></div>
<img src="https://miro.medium.com/v2/resize:fit:960/1*hDRj2PnNe94Krj76Az67lQ.gif">
<p>그 다음으로, 물론 구성 파일에 필요한 필드를 추가하시게 됩니다. 여러분은 어떤 유효성 검사 라이브러리든 사용하시거나, 더 좋은 방법으로는 (몰래 광고 주의!) 제 라이브러리를 사용하여 유효성을 처리할 수 있습니다.</p>
<h2>병합은 때로는 시간을 절약할 수 있습니다</h2>
<p>기본 PORT를 설정하는 것을 잊었을 때 항상 기본값이 있는데요, 어떻게 하면 좋을까요? 당연히 그 기본값을 정의하겠죠. 그렇다면 이후에 그들을 어떻게 병합할까요? 단순히 lodash를 사용하시거나, 더 좋은 방법으로는 (무언가를 여러 차례 언급하면 짜증나는 것에서 당신이 생각하는 방식으로 변화한다고 들었습니다) 제 라이브러리를 사용하세요.</p>
<div class="content-ad"></div>
<h2>개발자에게 무엇을 할 수 있을까요? 더 좋은 것을 받을 수 있을까요?</h2>
<p>물론 가능합니다. 물어주셔서 감사합니다. 저의 메인 언어(도움을 부탁드려요)가 TypeScript인 지금, 제게 제일 잘 맞는 것을 얻고 싶어해요. 상상해보세요! 전체 구성이 타이핑된 채로 보일 수 있어요. 와우. 예를 들어 Zod로 유효성을 검사하는 사람들은 이미 이 훌륭한 삶을 살고 있어요. 제 라이브러리는 어떤 유효성 검사 라이브러리든 가져다 사용할 수 있게 해주고, 그것들은 모두 Out of the box로 작동할 거예요.</p>
<p>trpc의 개발자에게 큰 칭찬을 보내요 - 그는 천재에요. 유효성 검사의 결과로 구성을 추론하기 위해 그의 코드를 그대로 복사하거나 도용할 수 있어요. 마법 같죠.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:960/1*7sjOuoIpBuH3KTlkUFt1QQ.gif" alt="이미지"></p>
<div class="content-ad"></div>
<h2>개발 환경을 언급하셨군요. 커밋할까요?</h2>
<p>아니요. 절대 그러지 마세요. 제가 바로 OPENAPI_KEY를 훔쳐갈 거에요. 일주일 후면 길거리에서 구걸하게 될 거에요. 비밀 보관 솔루션을 사용해주세요. 1Password, Google Cloud, Amazon, Infisical, dotenv.org 및 다른 멋진 프로젝트들이 안전하게 비밀을 보관하고 공유할 수 있게 해줍니다.</p>
<p>패키지.json에 설치 스크립트를 포함하여 정확한 버전의 비밀을 다운로드할 수 있게 하세요. 또한 업로드 스크립트도 추가해서 버전을 업그레이드하고 git에서 충돌을 피할 수 있도록 해주세요. 나중에 감사의 인사를 드릴게요. 저는 이 방법을 여러 년간 사용해왔고 로컬 구성을 USB 드라이브나 Slack을 통해 공유하는 것으로는 돌아갈 수 없을 거에요.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:960/1*CR7GClSquXaYgsn6gmGv6Q.gif" alt="이미지"></p>
<div class="content-ad"></div>
<h2>알겠어요, 이제 다른 부풀린 npm 패키지에 대해 이야기해 주세요</h2>
<p>사실, 이 패키지는 의존성이 전혀 없으며 TypeScript를 사용하고 아마도 번들러를 사용한다고 가정합니다. 일반적으로 이 패키지는 위에서 언급한 모든 문제를 해결합니다 (물론 개발 환경은 제외하고), 아래와 같은 기능을 제공합니다:</p>
<ul>
<li>3가지 데이터 소스 옵션: JSON 파일, JSON URL 및 객체를 지원하여 대부분의 사용 사례를 처리합니다.</li>
<li>런타임 유효성 검사: Zod, Superstruct, Yup 등과 같은 인기있는 라이브러리와 호환됩니다.</li>
<li>TypeScript IntelliSense: 유효성 검사 라이브러리에서의 변환기를 고려하고 해결된 유효성 검사에 대한 모든 힌트를 제공합니다.</li>
<li>병합: 왜냐하면 가능한 이유가 있잖아요? 디폴트를 분리하여 가지고 있으면 상당히 멋집니다. 항상 유효성 검사자 스키마에 기본값을 넣을 수 있지만, 그러면 코드에 저장됩니다.</li>
<li>완전히 테스트됨: 프로덕션에 사용할 준비가 되어 있으며 이미 여러 응용 프로그램에서 사용 중입니다.</li>
<li>백엔드 및 프론트엔드 친화적: 두 환경 모두에서 원활하게 작동합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 파일: state/config.ts</span>
<span class="hljs-keyword">import</span> { fromJSONFile } <span class="hljs-keyword">from</span> <span class="hljs-string">"@mrspartak/config"</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> z <span class="hljs-keyword">from</span> <span class="hljs-string">"zod"</span>

<span class="hljs-keyword">const</span> config = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fromJSONFile</span>({
  <span class="hljs-attr">path</span>: [<span class="hljs-string">"../config/default.json"</span>, <span class="hljs-string">"../config/runtime.json"</span>],
  <span class="hljs-attr">schema</span>: z.<span class="hljs-title function_">object</span>({
    <span class="hljs-attr">db</span>: z.<span class="hljs-title function_">object</span>({
      <span class="hljs-attr">host</span>: z.<span class="hljs-title function_">string</span>(),
      <span class="hljs-attr">port</span>: z.<span class="hljs-title function_">number</span>(),
      <span class="hljs-attr">username</span>: z.<span class="hljs-title function_">string</span>(),
      <span class="hljs-attr">password</span>: z.<span class="hljs-title function_">string</span>()
    }),
    <span class="hljs-attr">app</span>: z.<span class="hljs-title function_">object</span>({
      <span class="hljs-attr">port</span>: z.<span class="hljs-title function_">number</span>().<span class="hljs-title function_">optional</span>().<span class="hljs-title function_">default</span>(<span class="hljs-number">3000</span>)
    })
  }),
});

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> config



<span class="hljs-comment">// 파일: index.ts</span>
<span class="hljs-comment">// 해결된 구성을 가져오세요</span>
<span class="hljs-keyword">import</span> config <span class="hljs-keyword">from</span> <span class="hljs-string">'./state/config.js'</span>;

<span class="hljs-comment">// 응용 프로그램에서 구성을 사용하세요</span>
<span class="hljs-keyword">import</span> db <span class="hljs-keyword">from</span> <span class="hljs-string">'some-db-provider'</span>;
<span class="hljs-keyword">const</span> dbClient = <span class="hljs-title function_">db</span>(config.<span class="hljs-property">db</span>); <span class="hljs-comment">// 여기서 IntelliSense를 즐기세요!</span>
</code></pre>
<div class="content-ad"></div>
<h2>그런데 JSON 지원만 보여요. system crap 환경 변수를 아름답게 하려면 어떻게 하죠?</h2>
<p>객체와 함께 작업을 지원하므로 env 객체를 함수에 전달하면 됩니다. 다른 .env 파서를 다시 작성하는 것이 이상할 것입니다. 이미 시험된 많은 파서가 시장에 있으니까요</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 파일: state/config.ts</span>
<span class="hljs-keyword">import</span> { fromObject } <span class="hljs-keyword">from</span> <span class="hljs-string">"@mrspartak/config"</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> z <span class="hljs-keyword">from</span> <span class="hljs-string">"zod"</span>

<span class="hljs-keyword">const</span> schema = z
  .<span class="hljs-title function_">object</span>({
    <span class="hljs-attr">NODE_ENV</span>: z.<span class="hljs-title function_">enum</span>([<span class="hljs-string">"development"</span>, <span class="hljs-string">"production"</span>]),
    <span class="hljs-attr">DB_HOST</span>: z.<span class="hljs-title function_">string</span>(),
    <span class="hljs-attr">DB_PORT</span>: z.<span class="hljs-title function_">number</span>(),
    <span class="hljs-attr">DB_USER</span>: z.<span class="hljs-title function_">string</span>(),
    <span class="hljs-attr">DB_PASSWORD</span>: z.<span class="hljs-title function_">string</span>(),
    <span class="hljs-attr">APP_PORT</span>: z.<span class="hljs-title function_">number</span>().<span class="hljs-title function_">default</span>(<span class="hljs-number">3000</span>),
  })
  .<span class="hljs-title function_">transform</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> ({
    <span class="hljs-attr">environment</span>: data.<span class="hljs-property">NODE_ENV</span>,
    <span class="hljs-attr">port</span>: data.<span class="hljs-property">APP_PORT</span>,
    <span class="hljs-attr">db</span>: {
      <span class="hljs-attr">host</span>: data.<span class="hljs-property">DB_HOST</span>,
      <span class="hljs-attr">port</span>: data.<span class="hljs-property">DB_PORT</span>,
      <span class="hljs-attr">user</span>: data.<span class="hljs-property">DB_USER</span>,
      <span class="hljs-attr">password</span>: data.<span class="hljs-property">DB_PASSWORD</span>,
    },
  }));

<span class="hljs-keyword">const</span> config = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fromObject</span>({
  <span class="hljs-attr">data</span>: process.<span class="hljs-property">env</span>,
  schema
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> config

<span class="hljs-comment">// 파일 index.ts</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'dotenv/config'</span>
<span class="hljs-comment">// ! dotenv 이후에 설정이 로드되어야 하므로 process.env가 채워질 겁니다</span>
<span class="hljs-keyword">import</span> config <span class="hljs-keyword">from</span> <span class="hljs-string">'./state/config.js'</span>;

<span class="hljs-comment">// 애플리케이션에서 구성을 사용하세요</span>
<span class="hljs-keyword">import</span> db <span class="hljs-keyword">from</span> <span class="hljs-string">'some-db-provider'</span>;
<span class="hljs-keyword">const</span> dbClient = <span class="hljs-title function_">db</span>(config.<span class="hljs-property">db</span>); <span class="hljs-comment">// 여기서 IntelliSense를 즐기세요!</span>
</code></pre>
<h2>frontend를 언급했는데 node 파일 API를 확실히 사용했기 때문에 빌드가 중단될 것입니다.</h2>
<div class="content-ad"></div>
<p>네, 당신이 요청한 작업을 수행해드릴 수 있어요. (만약 더 나은 해결책을 아시는 분이 계시다면, 연락주세요)</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 파일: state/config.ts</span>
<span class="hljs-keyword">import</span> { fromObject } <span class="hljs-keyword">from</span> <span class="hljs-string">"@mrspartak/config/web"</span>; <span class="hljs-comment">// 라이브러리의 별도 빌드</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> z <span class="hljs-keyword">from</span> <span class="hljs-string">"zod"</span>

<span class="hljs-keyword">const</span> schema = z
  .<span class="hljs-title function_">object</span>({
    <span class="hljs-attr">API_URL</span>: z.<span class="hljs-title function_">string</span>(),
  })

<span class="hljs-keyword">const</span> config = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fromObject</span>({
  <span class="hljs-attr">data</span>: <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>, <span class="hljs-comment">// vite를 사용한 예시 </span>
  schema
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> config
</code></pre>
<p><img src="https://miro.medium.com/v2/resize:fit:960/1*ipkgq4adHLjucIErFR2buA.gif" alt=""></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Typescript 런타임 설정 완벽 마스터하는 방법","description":"","date":"2024-06-24 02:24","slug":"2024-06-24-MasteringTypescriptRuntimeConfigurations","content":"\n\n모든 사람이 경력 초반에 배우는 구성은 중요합니다. 대부분의 사람들은 처음에 배운 방법을 고수합니다. 저는 웹 개발을 10년 이상 해왔고, 무수히 많은 구성 방법을 보았습니다. 오늘은 여러분의 앱 구성을 좀 더 쉽게 만들어드리고, 물론 제 새로운 패키지 https://github.com/mrspartak/config 를 홍보하기 위해 여기에 왔습니다.\n\n![이미지](/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png)\n\n저는 풀 스택 개발자이지만, 백엔드와 프론트엔드 구성을 실제로 구분하지 않습니다. 둘 다 빌드 시간 및 실행 시간 구성을 사용할 수 있기 때문에 유사합니다. 우리는 컨테이너화 시대에 살고 있으므로, 주로 이 유형의 배포에 초점을 맞출 것입니다. 다음 섹션에 있는 통찰은 매우 주관적이므로, 다른 의견이 있으면 댓글로 의견을 공유해 주시면 감사하겠습니다.\n\n## 빌드 시간 구성.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n백엔드에서는 빌드 시간 구성이 그리 흔하지는 않지만, 프론트엔드에서는 상당히 인기 있는 방식입니다. 여기에서는 구성 값을 패키지나 이미지에 포함하여 응용 프로그램을 실행하는 데 충분하게 활용합니다. 제게는 빌드 시간에 환경과 관련된 모든 것을 처리하는 것이 합리적으로 보입니다. 이는 코드에서의 IO 작업 동작에 영향을 주는 구체적인 테스트, 스테이징 및 프로덕션 환경 구성을 포함합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*WIXN4ZkEhqUXVOfalToyAg.gif)\n\n그러나 어떤 사람들은 API 엔드포인트, 인증 키 등 외부 구성 요소를 빌드 시간에 포함하는 것이 너무 멀리간다고 생각합니다. 이 방식은 작동하지만, 각 환경별로 패키지 또는 이미지를 다시 빌드하고 테스트해야 하므로 빌드 사이에 불일치가 발생할 수 있습니다.\n\n## 런타임 구성.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 곳이 백엔드의 진정한 빛이 나오는 곳입니다. 그러나 SSR (서버 측 렌더링) 및 SPA (단일 페이지 어플리케이션) 프론트 엔드에서 런타임 구성을 자주 사용합니다. 앱이 로드되는 가장 처음에 실행 구성 정보가 로드됩니다. 런타임 구성은 모든 외부 구성을 포함해야 하며, 환경에 따라 크게 다를 수 있습니다. 여기서 일회성 환경의 장점이 발휘되며, 더 큰 유연성과 적응성을 제공합니다.\n\n## 어떻게 구성하나요?\n\n그래서 구성이 정확히 무엇인가요? 네, 당신은 `.env` 파일을 알고 계시죠... 또는 `.toml`. 아마도 `.json` 또는 `.ini`도요? 음, 그냥 `.ts` 파일을 만들고 그 안에서 객체를 내보내겠습니다. 하지만 기다려주세요. 그 파일을 git에 커밋해야 할까요? 각 환경 당 파일을 만들어 비밀 데이터를 커밋해야 할까요?\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*7S4sjloFaBx5isjqi_OAXw.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 어떤 형식이 가장 좋은지를 두고 전쟁을 일으킬 수 있지만, 사실 별로 중요하지 않아요. 읽기 쉽고 확장 가능하며 텍스트로 저장할 수 있는 형식이라면 충분하죠. 당신이 사용하기 편한 형식으로 선택하세요. 하지만 저장 및 사용 전략은 상당히 중요합니다.\n\n저장 측면에서, Kubernetes (k8s), Docker Swarm 또는 순수한 Docker를 사용한다면 아마도 설정 및 비밀키에 익숙할 것입니다. 이를 통해 코드와 함께 실행 중인 컨테이너에 어떤 파일이나 폴더를 첨부할 수 있어요. 대부분의 어려움은 개발 환경이나 프로덕션 환경으로 새 구성을 배포할 때 발생한다고 보아요.\n\n## 유효성 검사, 유효성 검사, 유효성 검사\n\n구성은 선언부터 시작돼요. 정말 간단하죠. 백엔드에서 데이터베이스를 호출해야 한다면, 해당 데이터베이스에 인증하는 데 필요한 것을 파악하고 구성 선언에 넣으세요. 그 결과로 얻는 것은 - 어플리케이션이 다운될 때입니다. 하지만 이것이 우리가 원하는 것이에요. 이를 통해 누락되거나 잘못된 구성을 조기에 식별할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:960/1*hDRj2PnNe94Krj76Az67lQ.gif\" /\u003e\n\n그 다음으로, 물론 구성 파일에 필요한 필드를 추가하시게 됩니다. 여러분은 어떤 유효성 검사 라이브러리든 사용하시거나, 더 좋은 방법으로는 (몰래 광고 주의!) 제 라이브러리를 사용하여 유효성을 처리할 수 있습니다.\n\n## 병합은 때로는 시간을 절약할 수 있습니다\n\n기본 PORT를 설정하는 것을 잊었을 때 항상 기본값이 있는데요, 어떻게 하면 좋을까요? 당연히 그 기본값을 정의하겠죠. 그렇다면 이후에 그들을 어떻게 병합할까요? 단순히 lodash를 사용하시거나, 더 좋은 방법으로는 (무언가를 여러 차례 언급하면 짜증나는 것에서 당신이 생각하는 방식으로 변화한다고 들었습니다) 제 라이브러리를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개발자에게 무엇을 할 수 있을까요? 더 좋은 것을 받을 수 있을까요?\n\n물론 가능합니다. 물어주셔서 감사합니다. 저의 메인 언어(도움을 부탁드려요)가 TypeScript인 지금, 제게 제일 잘 맞는 것을 얻고 싶어해요. 상상해보세요! 전체 구성이 타이핑된 채로 보일 수 있어요. 와우. 예를 들어 Zod로 유효성을 검사하는 사람들은 이미 이 훌륭한 삶을 살고 있어요. 제 라이브러리는 어떤 유효성 검사 라이브러리든 가져다 사용할 수 있게 해주고, 그것들은 모두 Out of the box로 작동할 거예요.\n\ntrpc의 개발자에게 큰 칭찬을 보내요 - 그는 천재에요. 유효성 검사의 결과로 구성을 추론하기 위해 그의 코드를 그대로 복사하거나 도용할 수 있어요. 마법 같죠.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*7sjOuoIpBuH3KTlkUFt1QQ.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개발 환경을 언급하셨군요. 커밋할까요?\n\n아니요. 절대 그러지 마세요. 제가 바로 OPENAPI_KEY를 훔쳐갈 거에요. 일주일 후면 길거리에서 구걸하게 될 거에요. 비밀 보관 솔루션을 사용해주세요. 1Password, Google Cloud, Amazon, Infisical, dotenv.org 및 다른 멋진 프로젝트들이 안전하게 비밀을 보관하고 공유할 수 있게 해줍니다.\n\n패키지.json에 설치 스크립트를 포함하여 정확한 버전의 비밀을 다운로드할 수 있게 하세요. 또한 업로드 스크립트도 추가해서 버전을 업그레이드하고 git에서 충돌을 피할 수 있도록 해주세요. 나중에 감사의 인사를 드릴게요. 저는 이 방법을 여러 년간 사용해왔고 로컬 구성을 USB 드라이브나 Slack을 통해 공유하는 것으로는 돌아갈 수 없을 거에요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*CR7GClSquXaYgsn6gmGv6Q.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 알겠어요, 이제 다른 부풀린 npm 패키지에 대해 이야기해 주세요\n\n사실, 이 패키지는 의존성이 전혀 없으며 TypeScript를 사용하고 아마도 번들러를 사용한다고 가정합니다. 일반적으로 이 패키지는 위에서 언급한 모든 문제를 해결합니다 (물론 개발 환경은 제외하고), 아래와 같은 기능을 제공합니다:\n\n- 3가지 데이터 소스 옵션: JSON 파일, JSON URL 및 객체를 지원하여 대부분의 사용 사례를 처리합니다.\n- 런타임 유효성 검사: Zod, Superstruct, Yup 등과 같은 인기있는 라이브러리와 호환됩니다.\n- TypeScript IntelliSense: 유효성 검사 라이브러리에서의 변환기를 고려하고 해결된 유효성 검사에 대한 모든 힌트를 제공합니다.\n- 병합: 왜냐하면 가능한 이유가 있잖아요? 디폴트를 분리하여 가지고 있으면 상당히 멋집니다. 항상 유효성 검사자 스키마에 기본값을 넣을 수 있지만, 그러면 코드에 저장됩니다.\n- 완전히 테스트됨: 프로덕션에 사용할 준비가 되어 있으며 이미 여러 응용 프로그램에서 사용 중입니다.\n- 백엔드 및 프론트엔드 친화적: 두 환경 모두에서 원활하게 작동합니다.\n\n```js\n// 파일: state/config.ts\nimport { fromJSONFile } from \"@mrspartak/config\";\nimport * as z from \"zod\"\n\nconst config = await fromJSONFile({\n  path: [\"../config/default.json\", \"../config/runtime.json\"],\n  schema: z.object({\n    db: z.object({\n      host: z.string(),\n      port: z.number(),\n      username: z.string(),\n      password: z.string()\n    }),\n    app: z.object({\n      port: z.number().optional().default(3000)\n    })\n  }),\n});\n\nexport default config\n\n\n\n// 파일: index.ts\n// 해결된 구성을 가져오세요\nimport config from './state/config.js';\n\n// 응용 프로그램에서 구성을 사용하세요\nimport db from 'some-db-provider';\nconst dbClient = db(config.db); // 여기서 IntelliSense를 즐기세요!\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 그런데 JSON 지원만 보여요. system crap 환경 변수를 아름답게 하려면 어떻게 하죠?\n\n객체와 함께 작업을 지원하므로 env 객체를 함수에 전달하면 됩니다. 다른 .env 파서를 다시 작성하는 것이 이상할 것입니다. 이미 시험된 많은 파서가 시장에 있으니까요\n\n```js\n// 파일: state/config.ts\nimport { fromObject } from \"@mrspartak/config\";\nimport * as z from \"zod\"\n\nconst schema = z\n  .object({\n    NODE_ENV: z.enum([\"development\", \"production\"]),\n    DB_HOST: z.string(),\n    DB_PORT: z.number(),\n    DB_USER: z.string(),\n    DB_PASSWORD: z.string(),\n    APP_PORT: z.number().default(3000),\n  })\n  .transform((data) =\u003e ({\n    environment: data.NODE_ENV,\n    port: data.APP_PORT,\n    db: {\n      host: data.DB_HOST,\n      port: data.DB_PORT,\n      user: data.DB_USER,\n      password: data.DB_PASSWORD,\n    },\n  }));\n\nconst config = await fromObject({\n  data: process.env,\n  schema\n})\n\nexport default config\n\n// 파일 index.ts\nimport 'dotenv/config'\n// ! dotenv 이후에 설정이 로드되어야 하므로 process.env가 채워질 겁니다\nimport config from './state/config.js';\n\n// 애플리케이션에서 구성을 사용하세요\nimport db from 'some-db-provider';\nconst dbClient = db(config.db); // 여기서 IntelliSense를 즐기세요!\n```\n\n## frontend를 언급했는데 node 파일 API를 확실히 사용했기 때문에 빌드가 중단될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 당신이 요청한 작업을 수행해드릴 수 있어요. (만약 더 나은 해결책을 아시는 분이 계시다면, 연락주세요)\n\n```js\n// 파일: state/config.ts\nimport { fromObject } from \"@mrspartak/config/web\"; // 라이브러리의 별도 빌드\nimport * as z from \"zod\"\n\nconst schema = z\n  .object({\n    API_URL: z.string(),\n  })\n\nconst config = await fromObject({\n  data: import.meta.env, // vite를 사용한 예시 \n  schema\n})\n\nexport default config\n```\n\n![](https://miro.medium.com/v2/resize:fit:960/1*ipkgq4adHLjucIErFR2buA.gif)\n","ogImage":{"url":"/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png"},"coverImage":"/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e모든 사람이 경력 초반에 배우는 구성은 중요합니다. 대부분의 사람들은 처음에 배운 방법을 고수합니다. 저는 웹 개발을 10년 이상 해왔고, 무수히 많은 구성 방법을 보았습니다. 오늘은 여러분의 앱 구성을 좀 더 쉽게 만들어드리고, 물론 제 새로운 패키지 \u003ca href=\"https://github.com/mrspartak/config\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/mrspartak/config\u003c/a\u003e 를 홍보하기 위해 여기에 왔습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-24-MasteringTypescriptRuntimeConfigurations_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e저는 풀 스택 개발자이지만, 백엔드와 프론트엔드 구성을 실제로 구분하지 않습니다. 둘 다 빌드 시간 및 실행 시간 구성을 사용할 수 있기 때문에 유사합니다. 우리는 컨테이너화 시대에 살고 있으므로, 주로 이 유형의 배포에 초점을 맞출 것입니다. 다음 섹션에 있는 통찰은 매우 주관적이므로, 다른 의견이 있으면 댓글로 의견을 공유해 주시면 감사하겠습니다.\u003c/p\u003e\n\u003ch2\u003e빌드 시간 구성.\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e백엔드에서는 빌드 시간 구성이 그리 흔하지는 않지만, 프론트엔드에서는 상당히 인기 있는 방식입니다. 여기에서는 구성 값을 패키지나 이미지에 포함하여 응용 프로그램을 실행하는 데 충분하게 활용합니다. 제게는 빌드 시간에 환경과 관련된 모든 것을 처리하는 것이 합리적으로 보입니다. 이는 코드에서의 IO 작업 동작에 영향을 주는 구체적인 테스트, 스테이징 및 프로덕션 환경 구성을 포함합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*WIXN4ZkEhqUXVOfalToyAg.gif\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e그러나 어떤 사람들은 API 엔드포인트, 인증 키 등 외부 구성 요소를 빌드 시간에 포함하는 것이 너무 멀리간다고 생각합니다. 이 방식은 작동하지만, 각 환경별로 패키지 또는 이미지를 다시 빌드하고 테스트해야 하므로 빌드 사이에 불일치가 발생할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e런타임 구성.\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 곳이 백엔드의 진정한 빛이 나오는 곳입니다. 그러나 SSR (서버 측 렌더링) 및 SPA (단일 페이지 어플리케이션) 프론트 엔드에서 런타임 구성을 자주 사용합니다. 앱이 로드되는 가장 처음에 실행 구성 정보가 로드됩니다. 런타임 구성은 모든 외부 구성을 포함해야 하며, 환경에 따라 크게 다를 수 있습니다. 여기서 일회성 환경의 장점이 발휘되며, 더 큰 유연성과 적응성을 제공합니다.\u003c/p\u003e\n\u003ch2\u003e어떻게 구성하나요?\u003c/h2\u003e\n\u003cp\u003e그래서 구성이 정확히 무엇인가요? 네, 당신은 \u003ccode\u003e.env\u003c/code\u003e 파일을 알고 계시죠... 또는 \u003ccode\u003e.toml\u003c/code\u003e. 아마도 \u003ccode\u003e.json\u003c/code\u003e 또는 \u003ccode\u003e.ini\u003c/code\u003e도요? 음, 그냥 \u003ccode\u003e.ts\u003c/code\u003e 파일을 만들고 그 안에서 객체를 내보내겠습니다. 하지만 기다려주세요. 그 파일을 git에 커밋해야 할까요? 각 환경 당 파일을 만들어 비밀 데이터를 커밋해야 할까요?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:960/1*7S4sjloFaBx5isjqi_OAXw.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리는 어떤 형식이 가장 좋은지를 두고 전쟁을 일으킬 수 있지만, 사실 별로 중요하지 않아요. 읽기 쉽고 확장 가능하며 텍스트로 저장할 수 있는 형식이라면 충분하죠. 당신이 사용하기 편한 형식으로 선택하세요. 하지만 저장 및 사용 전략은 상당히 중요합니다.\u003c/p\u003e\n\u003cp\u003e저장 측면에서, Kubernetes (k8s), Docker Swarm 또는 순수한 Docker를 사용한다면 아마도 설정 및 비밀키에 익숙할 것입니다. 이를 통해 코드와 함께 실행 중인 컨테이너에 어떤 파일이나 폴더를 첨부할 수 있어요. 대부분의 어려움은 개발 환경이나 프로덕션 환경으로 새 구성을 배포할 때 발생한다고 보아요.\u003c/p\u003e\n\u003ch2\u003e유효성 검사, 유효성 검사, 유효성 검사\u003c/h2\u003e\n\u003cp\u003e구성은 선언부터 시작돼요. 정말 간단하죠. 백엔드에서 데이터베이스를 호출해야 한다면, 해당 데이터베이스에 인증하는 데 필요한 것을 파악하고 구성 선언에 넣으세요. 그 결과로 얻는 것은 - 어플리케이션이 다운될 때입니다. 하지만 이것이 우리가 원하는 것이에요. 이를 통해 누락되거나 잘못된 구성을 조기에 식별할 수 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:960/1*hDRj2PnNe94Krj76Az67lQ.gif\"\u003e\n\u003cp\u003e그 다음으로, 물론 구성 파일에 필요한 필드를 추가하시게 됩니다. 여러분은 어떤 유효성 검사 라이브러리든 사용하시거나, 더 좋은 방법으로는 (몰래 광고 주의!) 제 라이브러리를 사용하여 유효성을 처리할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e병합은 때로는 시간을 절약할 수 있습니다\u003c/h2\u003e\n\u003cp\u003e기본 PORT를 설정하는 것을 잊었을 때 항상 기본값이 있는데요, 어떻게 하면 좋을까요? 당연히 그 기본값을 정의하겠죠. 그렇다면 이후에 그들을 어떻게 병합할까요? 단순히 lodash를 사용하시거나, 더 좋은 방법으로는 (무언가를 여러 차례 언급하면 짜증나는 것에서 당신이 생각하는 방식으로 변화한다고 들었습니다) 제 라이브러리를 사용하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e개발자에게 무엇을 할 수 있을까요? 더 좋은 것을 받을 수 있을까요?\u003c/h2\u003e\n\u003cp\u003e물론 가능합니다. 물어주셔서 감사합니다. 저의 메인 언어(도움을 부탁드려요)가 TypeScript인 지금, 제게 제일 잘 맞는 것을 얻고 싶어해요. 상상해보세요! 전체 구성이 타이핑된 채로 보일 수 있어요. 와우. 예를 들어 Zod로 유효성을 검사하는 사람들은 이미 이 훌륭한 삶을 살고 있어요. 제 라이브러리는 어떤 유효성 검사 라이브러리든 가져다 사용할 수 있게 해주고, 그것들은 모두 Out of the box로 작동할 거예요.\u003c/p\u003e\n\u003cp\u003etrpc의 개발자에게 큰 칭찬을 보내요 - 그는 천재에요. 유효성 검사의 결과로 구성을 추론하기 위해 그의 코드를 그대로 복사하거나 도용할 수 있어요. 마법 같죠.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:960/1*7sjOuoIpBuH3KTlkUFt1QQ.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e개발 환경을 언급하셨군요. 커밋할까요?\u003c/h2\u003e\n\u003cp\u003e아니요. 절대 그러지 마세요. 제가 바로 OPENAPI_KEY를 훔쳐갈 거에요. 일주일 후면 길거리에서 구걸하게 될 거에요. 비밀 보관 솔루션을 사용해주세요. 1Password, Google Cloud, Amazon, Infisical, dotenv.org 및 다른 멋진 프로젝트들이 안전하게 비밀을 보관하고 공유할 수 있게 해줍니다.\u003c/p\u003e\n\u003cp\u003e패키지.json에 설치 스크립트를 포함하여 정확한 버전의 비밀을 다운로드할 수 있게 하세요. 또한 업로드 스크립트도 추가해서 버전을 업그레이드하고 git에서 충돌을 피할 수 있도록 해주세요. 나중에 감사의 인사를 드릴게요. 저는 이 방법을 여러 년간 사용해왔고 로컬 구성을 USB 드라이브나 Slack을 통해 공유하는 것으로는 돌아갈 수 없을 거에요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:960/1*CR7GClSquXaYgsn6gmGv6Q.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e알겠어요, 이제 다른 부풀린 npm 패키지에 대해 이야기해 주세요\u003c/h2\u003e\n\u003cp\u003e사실, 이 패키지는 의존성이 전혀 없으며 TypeScript를 사용하고 아마도 번들러를 사용한다고 가정합니다. 일반적으로 이 패키지는 위에서 언급한 모든 문제를 해결합니다 (물론 개발 환경은 제외하고), 아래와 같은 기능을 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e3가지 데이터 소스 옵션: JSON 파일, JSON URL 및 객체를 지원하여 대부분의 사용 사례를 처리합니다.\u003c/li\u003e\n\u003cli\u003e런타임 유효성 검사: Zod, Superstruct, Yup 등과 같은 인기있는 라이브러리와 호환됩니다.\u003c/li\u003e\n\u003cli\u003eTypeScript IntelliSense: 유효성 검사 라이브러리에서의 변환기를 고려하고 해결된 유효성 검사에 대한 모든 힌트를 제공합니다.\u003c/li\u003e\n\u003cli\u003e병합: 왜냐하면 가능한 이유가 있잖아요? 디폴트를 분리하여 가지고 있으면 상당히 멋집니다. 항상 유효성 검사자 스키마에 기본값을 넣을 수 있지만, 그러면 코드에 저장됩니다.\u003c/li\u003e\n\u003cli\u003e완전히 테스트됨: 프로덕션에 사용할 준비가 되어 있으며 이미 여러 응용 프로그램에서 사용 중입니다.\u003c/li\u003e\n\u003cli\u003e백엔드 및 프론트엔드 친화적: 두 환경 모두에서 원활하게 작동합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 파일: state/config.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { fromJSONFile } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@mrspartak/config\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e z \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"zod\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e config = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efromJSONFile\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"../config/default.json\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"../config/runtime.json\"\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003eschema\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003eobject\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003edb\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003eobject\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003ehost\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e(),\n      \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003enumber\u003c/span\u003e(),\n      \u003cspan class=\"hljs-attr\"\u003eusername\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e(),\n      \u003cspan class=\"hljs-attr\"\u003epassword\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e()\n    }),\n    \u003cspan class=\"hljs-attr\"\u003eapp\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003eobject\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003enumber\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eoptional\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e)\n    })\n  }),\n});\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e config\n\n\n\n\u003cspan class=\"hljs-comment\"\u003e// 파일: index.ts\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 해결된 구성을 가져오세요\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e config \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./state/config.js'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 응용 프로그램에서 구성을 사용하세요\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e db \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'some-db-provider'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dbClient = \u003cspan class=\"hljs-title function_\"\u003edb\u003c/span\u003e(config.\u003cspan class=\"hljs-property\"\u003edb\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 여기서 IntelliSense를 즐기세요!\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e그런데 JSON 지원만 보여요. system crap 환경 변수를 아름답게 하려면 어떻게 하죠?\u003c/h2\u003e\n\u003cp\u003e객체와 함께 작업을 지원하므로 env 객체를 함수에 전달하면 됩니다. 다른 .env 파서를 다시 작성하는 것이 이상할 것입니다. 이미 시험된 많은 파서가 시장에 있으니까요\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 파일: state/config.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { fromObject } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@mrspartak/config\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e z \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"zod\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e schema = z\n  .\u003cspan class=\"hljs-title function_\"\u003eobject\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eNODE_ENV\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003eenum\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e\"development\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"production\"\u003c/span\u003e]),\n    \u003cspan class=\"hljs-attr\"\u003eDB_HOST\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e(),\n    \u003cspan class=\"hljs-attr\"\u003eDB_PORT\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003enumber\u003c/span\u003e(),\n    \u003cspan class=\"hljs-attr\"\u003eDB_USER\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e(),\n    \u003cspan class=\"hljs-attr\"\u003eDB_PASSWORD\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e(),\n    \u003cspan class=\"hljs-attr\"\u003eAPP_PORT\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003enumber\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e),\n  })\n  .\u003cspan class=\"hljs-title function_\"\u003etransform\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u003e\u003c/span\u003e ({\n    \u003cspan class=\"hljs-attr\"\u003eenvironment\u003c/span\u003e: data.\u003cspan class=\"hljs-property\"\u003eNODE_ENV\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: data.\u003cspan class=\"hljs-property\"\u003eAPP_PORT\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003edb\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003ehost\u003c/span\u003e: data.\u003cspan class=\"hljs-property\"\u003eDB_HOST\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: data.\u003cspan class=\"hljs-property\"\u003eDB_PORT\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003euser\u003c/span\u003e: data.\u003cspan class=\"hljs-property\"\u003eDB_USER\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003epassword\u003c/span\u003e: data.\u003cspan class=\"hljs-property\"\u003eDB_PASSWORD\u003c/span\u003e,\n    },\n  }));\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e config = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efromObject\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e,\n  schema\n})\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e config\n\n\u003cspan class=\"hljs-comment\"\u003e// 파일 index.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'dotenv/config'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ! dotenv 이후에 설정이 로드되어야 하므로 process.env가 채워질 겁니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e config \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./state/config.js'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 애플리케이션에서 구성을 사용하세요\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e db \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'some-db-provider'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dbClient = \u003cspan class=\"hljs-title function_\"\u003edb\u003c/span\u003e(config.\u003cspan class=\"hljs-property\"\u003edb\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 여기서 IntelliSense를 즐기세요!\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003efrontend를 언급했는데 node 파일 API를 확실히 사용했기 때문에 빌드가 중단될 것입니다.\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e네, 당신이 요청한 작업을 수행해드릴 수 있어요. (만약 더 나은 해결책을 아시는 분이 계시다면, 연락주세요)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 파일: state/config.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { fromObject } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"@mrspartak/config/web\"\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 라이브러리의 별도 빌드\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e z \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"zod\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e schema = z\n  .\u003cspan class=\"hljs-title function_\"\u003eobject\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eAPI_URL\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e(),\n  })\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e config = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efromObject\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emeta\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// vite를 사용한 예시 \u003c/span\u003e\n  schema\n})\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e config\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:960/1*ipkgq4adHLjucIErFR2buA.gif\" alt=\"\"\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-24-MasteringTypescriptRuntimeConfigurations"},"buildId":"QH5Mz7n7Y6w0r4_gCGFQf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>