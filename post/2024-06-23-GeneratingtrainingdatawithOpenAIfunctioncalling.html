<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>OpenAI 기능 호출로 훈련 데이터 생성하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="OpenAI 기능 호출로 훈련 데이터 생성하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="OpenAI 기능 호출로 훈련 데이터 생성하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling" data-gatsby-head="true"/><meta name="twitter:title" content="OpenAI 기능 호출로 훈련 데이터 생성하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 13:54" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">OpenAI 기능 호출로 훈련 데이터 생성하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="OpenAI 기능 호출로 훈련 데이터 생성하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png">
<p>머신 러닝과 인공 지능 분야에 파묻혀들면 준비 데이터의 품질이 중요하다는 것을 알 수 있어요. 1만 개의 텍스트나 이미지에 레이블을 붙이는 등의 훈련 데이터를 생성하는 것은 지루한 작업일 수 있어요. 하지만 OpenAI 모델을 사용하면 이 과정을 자동화할 수 있답니다. OpenAI 모델은 우리 모델을 위해 구체적인 훈련 또는 세밀한 조정 데이터를 생성할 수 있어요. 이 블로그 글에서는 이 작업이 어떻게 이루어지는지에 대해 살펴볼 거에요.</p>
<p>(그런데 GPT가 밈을 생성할 수 있다는 거 알고 계셨나요?)</p>
<img src="/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_1.png">
<div class="content-ad"></div>
<h1>왜 이 기능을 사용해야 하나요?</h1>
<p>OpenAI의 가장 유용한 기능 중 하나는 함수 호출입니다. 사전 정의된 스키마로 함수를 호출할 수 있어 일관성을 보장합니다. 훈련 데이터를 생성할 때 이 일관성은 중요합니다. 예를 들어, 대부분의 레이블 값은 사전 정의된 옵션 세트를 따르는 스키마를 가져야 합니다. 또한 이러한 함수에 로직을 추가하여 깨끗하고 일관된 데이터를 처리하고 이를 데이터베이스나 CSV 파일에 저장하는 등의 작업을 수행할 수 있습니다.</p>
<h1>나의 동기</h1>
<p>최근 개발한 사이드 프로젝트에서 인공지능 기능이 탑재된 RSS 리더를 만들었습니다.
하나의 기능은 게시물 내용을 "긍정적", "부정적", "중립적"으로 분류하는 것입니다. 이를 통해 사용자들은 원할 경우 부정적인 게시물을 걸러낼 수 있습니다. 많은 모델이 잘 수행하는 것을 찾았지만, 저는 RSS 피드 데이터로 하나를 세밀하게 조정하여 정확도를 개선하려고 합니다. 그러나 사용자 정의 레이블로 더 고급 감정 분류기를 생성하려면 직접 훈련 데이터셋을 만들고 모델을 훈련해야 합니다. 기존 모델을 사용하든 새로 생성하든, 고품질의 훈련 데이터가 필요합니다. 이것이 저가 고안한 다음 방법을 찾은 이유입니다.</p>
<div class="content-ad"></div>
<h1>OpenAI를 사용하여 데이터 라벨링하기</h1>
<p>먼저 데이터를 수집하세요. 이 데이터를 사용하여 라벨링하거나 새로운 머신러닝 특성을 추가하여 세밀하게 조정된 데이터셋을 만들 수 있습니다. 이 간단한 가이드를 참고해보세요:</p>
<p>OpenAI에 적절한 컨텍스트 제공하기:</p>
<ul>
<li>명확한 시스템 프롬프트 추가, 예: "제공된 데이터에 라벨을 지정하는 것이 여러분의 작업입니다."</li>
<li>프롬프트에 데이터 컨텍스트 포함, 예: "이 블로그 게시물에 <code>blog post content...</code> 라벨을 추가하세요."</li>
</ul>
<div class="content-ad"></div>
<p>오픈에이아이(Function Schema)에 대한 기능 스키마를 작성해주세요:</p>
<ul>
<li>도구에 대한 자세한 설명을 제공해주세요.</li>
<li>응답을 제한하기 위해 enum 및 다른 스키마 요소를 사용하여 매개변수를 명확히 정의해주세요.</li>
</ul>
<p>스키마에 의해 정의된 함수를 작성해주세요:</p>
<ul>
<li>이 기능은 데이터를 처리하거나 저장하거나 다른 작업을 수행할 수 있습니다. 제 경우에는 훈련 데이터 CSV 파일에 새로운 행을 추가하여 새로운 훈련 요소를 만들 수 있습니다.</li>
</ul>
<div class="content-ad"></div>
<p>이러한 단계를 따르면 데이터를 정확하고 일관되게 레이블링하여 모델 훈련에 사용할 수 있습니다.</p>
<h1>간단한 코드 예제 살펴보기</h1>
<p>여기 텍스트 레이블링 도구의 간단한 예제가 있습니다. 이것보다 훨씬 복잡한 작업도 할 수 있지만, 복잡한 ML 피처를 생성하거나 이미지 인식 또는 텍스트 음성 변환 피처를 활용하는 등의 작업도 가능합니다. 하지만 명확하게 하기 위해 이 예제를 선택했습니다:</p>
<p>이 예제에서는 어떤 텍스트에 [<code>긍정적</code>, <code>부정적</code>, <code>중립적</code>] 중 하나의 레이블을 추가하고 해당 결과를 CSV 파일에 작성하여 나준에 모델을 가르치거나 세부 조정할 수 있도록 했습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> {<span class="hljs-title class_">ITool</span>, <span class="hljs-title class_">ToolSchema</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">'./interfaces/tool.interface'</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">ToolUtils</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">"../utils/tool-utils"</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> {createObjectCsvWriter <span class="hljs-keyword">as</span> createCsvWriter} <span class="hljs-keyword">from</span> <span class="hljs-string">'csv-writer'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LabelTool</span> implements <span class="hljs-title class_">ITool</span>&#x3C;string[], { <span class="hljs-attr">inputText</span>: string }> {
    private csvWriter;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private readonly labels: string[] = [<span class="hljs-string">'positive'</span>, <span class="hljs-string">'negative'</span>, <span class="hljs-string">'neutral'</span>], private readonly csvFilePath: string = path.join(<span class="hljs-string">'labeled_text.csv'</span>)</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">csvWriter</span> = <span class="hljs-title function_">createCsvWriter</span>({
            <span class="hljs-attr">path</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">csvFilePath</span>,
            <span class="hljs-attr">header</span>: [
                {<span class="hljs-attr">id</span>: <span class="hljs-string">'label'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Label'</span>},
                {<span class="hljs-attr">id</span>: <span class="hljs-string">'text'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Text'</span>},
            ],
            <span class="hljs-attr">append</span>: <span class="hljs-literal">true</span>
        });
    }

    <span class="hljs-comment">// 해당 도구를 사용하여 OpenAI에 요청을 생성하고 레이블이 필요한 데이터를 반복할 수 있습니다.</span>

    <span class="hljs-keyword">async</span> <span class="hljs-title function_">callback</span>(
        <span class="hljs-attr">options</span>: { <span class="hljs-attr">label</span>: string },
        <span class="hljs-attr">ctx</span>: { <span class="hljs-attr">inputText</span>: string },
    ): <span class="hljs-title class_">Promise</span>&#x3C;any> {

        <span class="hljs-comment">// 새로운 레이블이 지정된 데이터 행을 csv에 작성합니다.</span>
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">csvWriter</span>.<span class="hljs-title function_">writeRecords</span>([{
            <span class="hljs-attr">label</span>: options.<span class="hljs-property">label</span>,
            <span class="hljs-attr">text</span>: ctx.<span class="hljs-property">inputText</span>
        }]);

        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`CSV 행 추가됨: <span class="hljs-subst">${options.label}</span> | <span class="hljs-subst">${ctx.inputText}</span>`</span>);

        <span class="hljs-keyword">return</span> <span class="hljs-string">`레이블이 성공적으로 추가되었습니다: <span class="hljs-subst">${options.label}</span>`</span>;
    }

    <span class="hljs-comment">// JSON 스키마에 대해 더 알아보려면 여기를 방문하세요 https://json-schema.org/learn/getting-started-step-by-step</span>
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">getSchema</span>(<span class="hljs-attr">ctx</span>: { <span class="hljs-attr">inputText</span>: string }): <span class="hljs-title class_">Promise</span>&#x3C;<span class="hljs-title class_">ToolSchema</span>> {

        <span class="hljs-comment">// 이는 LLM을 위한 제공된 스키마입니다.</span>
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">type</span>: <span class="hljs-string">'function'</span>,
            <span class="hljs-attr">function</span>: {
                <span class="hljs-attr">name</span>: <span class="hljs-string">'set_label'</span>,
                <span class="hljs-attr">description</span>: <span class="hljs-string">'텍스트에 레이블 설정'</span>,
                <span class="hljs-attr">function</span>: <span class="hljs-title class_">ToolUtils</span>.<span class="hljs-title function_">getToolFn</span>(<span class="hljs-variable language_">this</span>, ctx),
                <span class="hljs-attr">parse</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-property">parse</span>,
                <span class="hljs-attr">parameters</span>: {
                    <span class="hljs-attr">type</span>: <span class="hljs-string">'object'</span>,
                    <span class="hljs-attr">properties</span>: { <span class="hljs-comment">// 이 속성들은 콜백 "options" 매개변수에 있을 것입니다</span>
                        <span class="hljs-attr">label</span>: {
                            <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>,
                            <span class="hljs-attr">description</span>: <span class="hljs-string">'입력 텍스트의 레이블'</span>,
                            <span class="hljs-attr">enum</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">labels</span> <span class="hljs-comment">// 가능한 문자열을 제한합니다</span>
                        },
                    },
                },
            },
        };
    }
}
</code></pre>
<p>이 도구를 사용하면 OpenAI에 요청을 보내고 레이블이 필요한 데이터를 반복할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">OpenAI</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"openai"</span>;
<span class="hljs-keyword">import</span> {<span class="hljs-title class_">LabelTool</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">"./tools/label.tool"</span>;
<span class="hljs-built_in">require</span>(<span class="hljs-string">'dotenv'</span>).<span class="hljs-title function_">config</span>()

<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenAI</span>({
    <span class="hljs-attr">apiKey</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">OPENAI_API_KEY</span>,
});

(<span class="hljs-keyword">async</span> () => {
    <span class="hljs-keyword">const</span> inputTexts = [ <span class="hljs-comment">// OpenAI 모델이 이를 ['positive', 'negative', 'neutral']로 레이블링합니다</span>
        <span class="hljs-string">"이 제품을 사랑해요!"</span>,
        <span class="hljs-string">"이게 내가 산 것 중에 가장 최악이에요."</span>,
        <span class="hljs-string">"괜찮아요, 유난히 좋진 않지만 나쁘진 않아요."</span>,
        <span class="hljs-string">"돈 안 아깝다고."</span>,
        <span class="hljs-string">"최고의 구매!"</span>,
    ];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> inputText <span class="hljs-keyword">of</span> inputTexts) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">debug</span>(<span class="hljs-string">`프롬프트: 이 텍스트에 레이블을 부여하세요: <span class="hljs-subst">${inputText}</span>`</span>);

        <span class="hljs-keyword">const</span> tool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LabelTool</span>([<span class="hljs-string">'positive'</span>, <span class="hljs-string">'negative'</span>, <span class="hljs-string">'neutral'</span>]);
        <span class="hljs-keyword">const</span> context = { <span class="hljs-attr">inputText</span>: inputText };
        <span class="hljs-keyword">const</span> prompt = <span class="hljs-string">`이 텍스트에 레이블을 부여하세요: <span class="hljs-subst">${inputText}</span>`</span>;
        <span class="hljs-keyword">const</span> system = <span class="hljs-string">'훈련 데이터 생성을 돕는 유용한 도우미입니다.'</span>;

        <span class="hljs-keyword">const</span> runner = client.<span class="hljs-property">beta</span>.<span class="hljs-property">chat</span>.<span class="hljs-property">completions</span>.<span class="hljs-title function_">runTools</span>({
            <span class="hljs-attr">model</span>: <span class="hljs-string">'gpt-3.5-turbo'</span>,
            <span class="hljs-attr">messages</span>: [
                {
                    <span class="hljs-attr">role</span>: <span class="hljs-string">'system'</span>,
                    <span class="hljs-attr">content</span>: system,
                },
                {
                    <span class="hljs-attr">role</span>: <span class="hljs-string">'user'</span>,
                    <span class="hljs-attr">content</span>: prompt,
                },
            ],
            <span class="hljs-attr">tools</span>: [<span class="hljs-keyword">await</span> tool.<span class="hljs-title function_">getSchema</span>(context)],
            <span class="hljs-attr">tool_choice</span>: <span class="hljs-string">'auto'</span>, <span class="hljs-comment">// 'auto' 대신 tool_choice: {function: {name: ...}를 전달하면 해당 함수를 호출한 후 즉시 반환됩니다</span>
        });

        <span class="hljs-keyword">const</span> finalContent = <span class="hljs-keyword">await</span> runner.<span class="hljs-title function_">finalContent</span>();
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`AI 응답: <span class="hljs-subst">${finalContent}</span>
        `</span>);
    }
})();
</code></pre>
<p>로그 결과:</p>
<div class="content-ad"></div>
<p>Prompt: 이 텍스트를 라벨링하세요: 나는이 제품을 좋아해요!
CSV 행 추가: 긍정적 | 나는이 제품을 좋아해요!
AI 응답: "나는이 제품을 좋아해요!" 텍스트가 긍정적으로 라벨링되었습니다.</p>
<p>Prompt: 이 텍스트를 라벨링하세요: 이건 내가 산 것 중 가장 최악입니다.
CSV 행 추가: 부정적 | 이건 내가 산 것 중 가장 최악입니다.
AI 응답: "이건 내가 산 것 중 가장 최악입니다." 텍스트가 부정적으로 라벨링되었습니다.</p>
<p>Prompt: 이 텍스트를 라벨링하세요: 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.
CSV 행 추가: 중립 | 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.
AI 응답: "그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요." 텍스트가 중립으로 라벨링되었습니다.</p>
<p>Prompt: 이 텍스트를 라벨링하세요: 가치가 없어요.
CSV 행 추가: 부정적 | 가치가 없어요.
AI 응답: "가치가 없어요." 텍스트가 부정적으로 라벨링되었습니다.</p>
<p>Prompt: 이 텍스트를 라벨링하세요: 최고의 구매!
CSV 행 추가: 긍정적 | 최고의 구매!
AI 응답: "최고의 구매!" 텍스트가 긍정적으로 라벨링되었습니다.</p>
<p>CSV 파일:</p>
<p>라벨,텍스트
긍정적,나는이 제품을 좋아해요!
부정적,이건 내가 산 것 중 가장 최악입니다.
중립,"그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요."
부정적,가치가 없어요.
긍정적,최고의 구매!</p>
<p>물론 이 방법을 단순화하거나 확장하는 다양한 방법이 있지만, 이 예제를 선택하여 아이디어를 제공했습니다. 이 코드를 다음 GitHub 저장소에서 시도해볼 수 있습니다: <a href="https://github.com/MaurerKrisztian/training_data_genration_with_openai" rel="nofollow" target="_blank">https://github.com/MaurerKrisztian/training_data_genration_with_openai</a></p>
<div class="content-ad"></div>
<p>OpenAI의 함수 호출을 사용하면 고품질의 훈련 데이터를 생성하는 것이 훨씬 쉬워집니다. 텍스트, 이미지, 오디오 또는 기타 데이터를 레이블링할 때, 이 방법을 사용하면 레이블이 정확하고 일관적임이 보장됩니다. 이를 통해 기계 학습 모델을 훈련하거나 세부 조정할 때 많은 시간과 노력을 절약할 수 있습니다.</p>
<p>이 블로그 글을 읽어 주셔서 감사합니다! 이 아이디어에 대해 여전히 실험 중이라 의견을 주시면 감사하겠습니다. 어떻게 이 방법을 활용하거나 확장할 수 있는지에 대한 생각이 있으면 댓글을 남겨주세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"OpenAI 기능 호출로 훈련 데이터 생성하는 방법","description":"","date":"2024-06-23 13:54","slug":"2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png\"/\u003e\n\n머신 러닝과 인공 지능 분야에 파묻혀들면 준비 데이터의 품질이 중요하다는 것을 알 수 있어요. 1만 개의 텍스트나 이미지에 레이블을 붙이는 등의 훈련 데이터를 생성하는 것은 지루한 작업일 수 있어요. 하지만 OpenAI 모델을 사용하면 이 과정을 자동화할 수 있답니다. OpenAI 모델은 우리 모델을 위해 구체적인 훈련 또는 세밀한 조정 데이터를 생성할 수 있어요. 이 블로그 글에서는 이 작업이 어떻게 이루어지는지에 대해 살펴볼 거에요.\n\n(그런데 GPT가 밈을 생성할 수 있다는 거 알고 계셨나요?)\n\n\u003cimg src=\"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_1.png\"/\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 왜 이 기능을 사용해야 하나요?\n\nOpenAI의 가장 유용한 기능 중 하나는 함수 호출입니다. 사전 정의된 스키마로 함수를 호출할 수 있어 일관성을 보장합니다. 훈련 데이터를 생성할 때 이 일관성은 중요합니다. 예를 들어, 대부분의 레이블 값은 사전 정의된 옵션 세트를 따르는 스키마를 가져야 합니다. 또한 이러한 함수에 로직을 추가하여 깨끗하고 일관된 데이터를 처리하고 이를 데이터베이스나 CSV 파일에 저장하는 등의 작업을 수행할 수 있습니다.\n\n# 나의 동기\n\n최근 개발한 사이드 프로젝트에서 인공지능 기능이 탑재된 RSS 리더를 만들었습니다.\n하나의 기능은 게시물 내용을 \"긍정적\", \"부정적\", \"중립적\"으로 분류하는 것입니다. 이를 통해 사용자들은 원할 경우 부정적인 게시물을 걸러낼 수 있습니다. 많은 모델이 잘 수행하는 것을 찾았지만, 저는 RSS 피드 데이터로 하나를 세밀하게 조정하여 정확도를 개선하려고 합니다. 그러나 사용자 정의 레이블로 더 고급 감정 분류기를 생성하려면 직접 훈련 데이터셋을 만들고 모델을 훈련해야 합니다. 기존 모델을 사용하든 새로 생성하든, 고품질의 훈련 데이터가 필요합니다. 이것이 저가 고안한 다음 방법을 찾은 이유입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# OpenAI를 사용하여 데이터 라벨링하기\n\n먼저 데이터를 수집하세요. 이 데이터를 사용하여 라벨링하거나 새로운 머신러닝 특성을 추가하여 세밀하게 조정된 데이터셋을 만들 수 있습니다. 이 간단한 가이드를 참고해보세요:\n\nOpenAI에 적절한 컨텍스트 제공하기:\n\n- 명확한 시스템 프롬프트 추가, 예: \"제공된 데이터에 라벨을 지정하는 것이 여러분의 작업입니다.\"\n- 프롬프트에 데이터 컨텍스트 포함, 예: \"이 블로그 게시물에 `blog post content...` 라벨을 추가하세요.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오픈에이아이(Function Schema)에 대한 기능 스키마를 작성해주세요:\n\n- 도구에 대한 자세한 설명을 제공해주세요.\n- 응답을 제한하기 위해 enum 및 다른 스키마 요소를 사용하여 매개변수를 명확히 정의해주세요.\n\n스키마에 의해 정의된 함수를 작성해주세요:\n\n- 이 기능은 데이터를 처리하거나 저장하거나 다른 작업을 수행할 수 있습니다. 제 경우에는 훈련 데이터 CSV 파일에 새로운 행을 추가하여 새로운 훈련 요소를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 단계를 따르면 데이터를 정확하고 일관되게 레이블링하여 모델 훈련에 사용할 수 있습니다.\n\n# 간단한 코드 예제 살펴보기\n\n여기 텍스트 레이블링 도구의 간단한 예제가 있습니다. 이것보다 훨씬 복잡한 작업도 할 수 있지만, 복잡한 ML 피처를 생성하거나 이미지 인식 또는 텍스트 음성 변환 피처를 활용하는 등의 작업도 가능합니다. 하지만 명확하게 하기 위해 이 예제를 선택했습니다:\n\n이 예제에서는 어떤 텍스트에 [`긍정적`, `부정적`, `중립적`] 중 하나의 레이블을 추가하고 해당 결과를 CSV 파일에 작성하여 나준에 모델을 가르치거나 세부 조정할 수 있도록 했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {ITool, ToolSchema} from './interfaces/tool.interface';\nimport {ToolUtils} from \"../utils/tool-utils\";\nimport * as path from 'path';\nimport {createObjectCsvWriter as createCsvWriter} from 'csv-writer';\n\nexport class LabelTool implements ITool\u003cstring[], { inputText: string }\u003e {\n    private csvWriter;\n\n    constructor(private readonly labels: string[] = ['positive', 'negative', 'neutral'], private readonly csvFilePath: string = path.join('labeled_text.csv')) {\n        this.csvWriter = createCsvWriter({\n            path: this.csvFilePath,\n            header: [\n                {id: 'label', title: 'Label'},\n                {id: 'text', title: 'Text'},\n            ],\n            append: true\n        });\n    }\n\n    // 해당 도구를 사용하여 OpenAI에 요청을 생성하고 레이블이 필요한 데이터를 반복할 수 있습니다.\n\n    async callback(\n        options: { label: string },\n        ctx: { inputText: string },\n    ): Promise\u003cany\u003e {\n\n        // 새로운 레이블이 지정된 데이터 행을 csv에 작성합니다.\n        await this.csvWriter.writeRecords([{\n            label: options.label,\n            text: ctx.inputText\n        }]);\n\n        console.log(`CSV 행 추가됨: ${options.label} | ${ctx.inputText}`);\n\n        return `레이블이 성공적으로 추가되었습니다: ${options.label}`;\n    }\n\n    // JSON 스키마에 대해 더 알아보려면 여기를 방문하세요 https://json-schema.org/learn/getting-started-step-by-step\n    async getSchema(ctx: { inputText: string }): Promise\u003cToolSchema\u003e {\n\n        // 이는 LLM을 위한 제공된 스키마입니다.\n        return {\n            type: 'function',\n            function: {\n                name: 'set_label',\n                description: '텍스트에 레이블 설정',\n                function: ToolUtils.getToolFn(this, ctx),\n                parse: JSON.parse,\n                parameters: {\n                    type: 'object',\n                    properties: { // 이 속성들은 콜백 \"options\" 매개변수에 있을 것입니다\n                        label: {\n                            type: 'string',\n                            description: '입력 텍스트의 레이블',\n                            enum: this.labels // 가능한 문자열을 제한합니다\n                        },\n                    },\n                },\n            },\n        };\n    }\n}\n```\n\n이 도구를 사용하면 OpenAI에 요청을 보내고 레이블이 필요한 데이터를 반복할 수 있습니다.\n\n```js\nimport OpenAI from \"openai\";\nimport {LabelTool} from \"./tools/label.tool\";\nrequire('dotenv').config()\n\nconst client = new OpenAI({\n    apiKey: process.env.OPENAI_API_KEY,\n});\n\n(async () =\u003e {\n    const inputTexts = [ // OpenAI 모델이 이를 ['positive', 'negative', 'neutral']로 레이블링합니다\n        \"이 제품을 사랑해요!\",\n        \"이게 내가 산 것 중에 가장 최악이에요.\",\n        \"괜찮아요, 유난히 좋진 않지만 나쁘진 않아요.\",\n        \"돈 안 아깝다고.\",\n        \"최고의 구매!\",\n    ];\n\n    for (const inputText of inputTexts) {\n        console.debug(`프롬프트: 이 텍스트에 레이블을 부여하세요: ${inputText}`);\n\n        const tool = new LabelTool(['positive', 'negative', 'neutral']);\n        const context = { inputText: inputText };\n        const prompt = `이 텍스트에 레이블을 부여하세요: ${inputText}`;\n        const system = '훈련 데이터 생성을 돕는 유용한 도우미입니다.';\n\n        const runner = client.beta.chat.completions.runTools({\n            model: 'gpt-3.5-turbo',\n            messages: [\n                {\n                    role: 'system',\n                    content: system,\n                },\n                {\n                    role: 'user',\n                    content: prompt,\n                },\n            ],\n            tools: [await tool.getSchema(context)],\n            tool_choice: 'auto', // 'auto' 대신 tool_choice: {function: {name: ...}를 전달하면 해당 함수를 호출한 후 즉시 반환됩니다\n        });\n\n        const finalContent = await runner.finalContent();\n        console.log(`AI 응답: ${finalContent}\n        `);\n    }\n})();\n```\n\n로그 결과:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nPrompt: 이 텍스트를 라벨링하세요: 나는이 제품을 좋아해요!\nCSV 행 추가: 긍정적 | 나는이 제품을 좋아해요!\nAI 응답: \"나는이 제품을 좋아해요!\" 텍스트가 긍정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 이건 내가 산 것 중 가장 최악입니다.\nCSV 행 추가: 부정적 | 이건 내가 산 것 중 가장 최악입니다.\nAI 응답: \"이건 내가 산 것 중 가장 최악입니다.\" 텍스트가 부정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\nCSV 행 추가: 중립 | 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\nAI 응답: \"그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\" 텍스트가 중립으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 가치가 없어요.\nCSV 행 추가: 부정적 | 가치가 없어요.\nAI 응답: \"가치가 없어요.\" 텍스트가 부정적으로 라벨링되었습니다.\n\nPrompt: 이 텍스트를 라벨링하세요: 최고의 구매!\nCSV 행 추가: 긍정적 | 최고의 구매!\nAI 응답: \"최고의 구매!\" 텍스트가 긍정적으로 라벨링되었습니다.\r\n\n\r\nCSV 파일:\r\n\r\n\n라벨,텍스트\r\n긍정적,나는이 제품을 좋아해요!\r\n부정적,이건 내가 산 것 중 가장 최악입니다.\r\n중립,\"그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\"\r\n부정적,가치가 없어요.\r\n긍정적,최고의 구매!\r\n\n\r\n물론 이 방법을 단순화하거나 확장하는 다양한 방법이 있지만, 이 예제를 선택하여 아이디어를 제공했습니다. 이 코드를 다음 GitHub 저장소에서 시도해볼 수 있습니다: https://github.com/MaurerKrisztian/training_data_genration_with_openai\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOpenAI의 함수 호출을 사용하면 고품질의 훈련 데이터를 생성하는 것이 훨씬 쉬워집니다. 텍스트, 이미지, 오디오 또는 기타 데이터를 레이블링할 때, 이 방법을 사용하면 레이블이 정확하고 일관적임이 보장됩니다. 이를 통해 기계 학습 모델을 훈련하거나 세부 조정할 때 많은 시간과 노력을 절약할 수 있습니다.\n\n이 블로그 글을 읽어 주셔서 감사합니다! 이 아이디어에 대해 여전히 실험 중이라 의견을 주시면 감사하겠습니다. 어떻게 이 방법을 활용하거나 확장할 수 있는지에 대한 생각이 있으면 댓글을 남겨주세요.","ogImage":{"url":"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png"},"coverImage":"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_0.png\"\u003e\n\u003cp\u003e머신 러닝과 인공 지능 분야에 파묻혀들면 준비 데이터의 품질이 중요하다는 것을 알 수 있어요. 1만 개의 텍스트나 이미지에 레이블을 붙이는 등의 훈련 데이터를 생성하는 것은 지루한 작업일 수 있어요. 하지만 OpenAI 모델을 사용하면 이 과정을 자동화할 수 있답니다. OpenAI 모델은 우리 모델을 위해 구체적인 훈련 또는 세밀한 조정 데이터를 생성할 수 있어요. 이 블로그 글에서는 이 작업이 어떻게 이루어지는지에 대해 살펴볼 거에요.\u003c/p\u003e\n\u003cp\u003e(그런데 GPT가 밈을 생성할 수 있다는 거 알고 계셨나요?)\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling_1.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e왜 이 기능을 사용해야 하나요?\u003c/h1\u003e\n\u003cp\u003eOpenAI의 가장 유용한 기능 중 하나는 함수 호출입니다. 사전 정의된 스키마로 함수를 호출할 수 있어 일관성을 보장합니다. 훈련 데이터를 생성할 때 이 일관성은 중요합니다. 예를 들어, 대부분의 레이블 값은 사전 정의된 옵션 세트를 따르는 스키마를 가져야 합니다. 또한 이러한 함수에 로직을 추가하여 깨끗하고 일관된 데이터를 처리하고 이를 데이터베이스나 CSV 파일에 저장하는 등의 작업을 수행할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e나의 동기\u003c/h1\u003e\n\u003cp\u003e최근 개발한 사이드 프로젝트에서 인공지능 기능이 탑재된 RSS 리더를 만들었습니다.\n하나의 기능은 게시물 내용을 \"긍정적\", \"부정적\", \"중립적\"으로 분류하는 것입니다. 이를 통해 사용자들은 원할 경우 부정적인 게시물을 걸러낼 수 있습니다. 많은 모델이 잘 수행하는 것을 찾았지만, 저는 RSS 피드 데이터로 하나를 세밀하게 조정하여 정확도를 개선하려고 합니다. 그러나 사용자 정의 레이블로 더 고급 감정 분류기를 생성하려면 직접 훈련 데이터셋을 만들고 모델을 훈련해야 합니다. 기존 모델을 사용하든 새로 생성하든, 고품질의 훈련 데이터가 필요합니다. 이것이 저가 고안한 다음 방법을 찾은 이유입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eOpenAI를 사용하여 데이터 라벨링하기\u003c/h1\u003e\n\u003cp\u003e먼저 데이터를 수집하세요. 이 데이터를 사용하여 라벨링하거나 새로운 머신러닝 특성을 추가하여 세밀하게 조정된 데이터셋을 만들 수 있습니다. 이 간단한 가이드를 참고해보세요:\u003c/p\u003e\n\u003cp\u003eOpenAI에 적절한 컨텍스트 제공하기:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e명확한 시스템 프롬프트 추가, 예: \"제공된 데이터에 라벨을 지정하는 것이 여러분의 작업입니다.\"\u003c/li\u003e\n\u003cli\u003e프롬프트에 데이터 컨텍스트 포함, 예: \"이 블로그 게시물에 \u003ccode\u003eblog post content...\u003c/code\u003e 라벨을 추가하세요.\"\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e오픈에이아이(Function Schema)에 대한 기능 스키마를 작성해주세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e도구에 대한 자세한 설명을 제공해주세요.\u003c/li\u003e\n\u003cli\u003e응답을 제한하기 위해 enum 및 다른 스키마 요소를 사용하여 매개변수를 명확히 정의해주세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e스키마에 의해 정의된 함수를 작성해주세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 기능은 데이터를 처리하거나 저장하거나 다른 작업을 수행할 수 있습니다. 제 경우에는 훈련 데이터 CSV 파일에 새로운 행을 추가하여 새로운 훈련 요소를 만들 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이러한 단계를 따르면 데이터를 정확하고 일관되게 레이블링하여 모델 훈련에 사용할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e간단한 코드 예제 살펴보기\u003c/h1\u003e\n\u003cp\u003e여기 텍스트 레이블링 도구의 간단한 예제가 있습니다. 이것보다 훨씬 복잡한 작업도 할 수 있지만, 복잡한 ML 피처를 생성하거나 이미지 인식 또는 텍스트 음성 변환 피처를 활용하는 등의 작업도 가능합니다. 하지만 명확하게 하기 위해 이 예제를 선택했습니다:\u003c/p\u003e\n\u003cp\u003e이 예제에서는 어떤 텍스트에 [\u003ccode\u003e긍정적\u003c/code\u003e, \u003ccode\u003e부정적\u003c/code\u003e, \u003ccode\u003e중립적\u003c/code\u003e] 중 하나의 레이블을 추가하고 해당 결과를 CSV 파일에 작성하여 나준에 모델을 가르치거나 세부 조정할 수 있도록 했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\u003cspan class=\"hljs-title class_\"\u003eITool\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eToolSchema\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./interfaces/tool.interface'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\u003cspan class=\"hljs-title class_\"\u003eToolUtils\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"../utils/tool-utils\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e path \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'path'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {createObjectCsvWriter \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e createCsvWriter} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'csv-writer'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLabelTool\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eITool\u003c/span\u003e\u0026#x3C;string[], { \u003cspan class=\"hljs-attr\"\u003einputText\u003c/span\u003e: string }\u003e {\n    private csvWriter;\n\n    \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate readonly labels: string[] = [\u003cspan class=\"hljs-string\"\u003e'positive'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'negative'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'neutral'\u003c/span\u003e], private readonly csvFilePath: string = path.join(\u003cspan class=\"hljs-string\"\u003e'labeled_text.csv'\u003c/span\u003e)\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecsvWriter\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ecreateCsvWriter\u003c/span\u003e({\n            \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecsvFilePath\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003eheader\u003c/span\u003e: [\n                {\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'label'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Label'\u003c/span\u003e},\n                {\u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'text'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Text'\u003c/span\u003e},\n            ],\n            \u003cspan class=\"hljs-attr\"\u003eappend\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n        });\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 해당 도구를 사용하여 OpenAI에 요청을 생성하고 레이블이 필요한 데이터를 반복할 수 있습니다.\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecallback\u003c/span\u003e(\n        \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: string },\n        \u003cspan class=\"hljs-attr\"\u003ectx\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003einputText\u003c/span\u003e: string },\n    ): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;any\u003e {\n\n        \u003cspan class=\"hljs-comment\"\u003e// 새로운 레이블이 지정된 데이터 행을 csv에 작성합니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecsvWriter\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewriteRecords\u003c/span\u003e([{\n            \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: options.\u003cspan class=\"hljs-property\"\u003elabel\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: ctx.\u003cspan class=\"hljs-property\"\u003einputText\u003c/span\u003e\n        }]);\n\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`CSV 행 추가됨: \u003cspan class=\"hljs-subst\"\u003e${options.label}\u003c/span\u003e | \u003cspan class=\"hljs-subst\"\u003e${ctx.inputText}\u003c/span\u003e`\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`레이블이 성공적으로 추가되었습니다: \u003cspan class=\"hljs-subst\"\u003e${options.label}\u003c/span\u003e`\u003c/span\u003e;\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// JSON 스키마에 대해 더 알아보려면 여기를 방문하세요 https://json-schema.org/learn/getting-started-step-by-step\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetSchema\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ectx\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003einputText\u003c/span\u003e: string }): \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eToolSchema\u003c/span\u003e\u003e {\n\n        \u003cspan class=\"hljs-comment\"\u003e// 이는 LLM을 위한 제공된 스키마입니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n            \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003efunction\u003c/span\u003e: {\n                \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'set_label'\u003c/span\u003e,\n                \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'텍스트에 레이블 설정'\u003c/span\u003e,\n                \u003cspan class=\"hljs-attr\"\u003efunction\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eToolUtils\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetToolFn\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, ctx),\n                \u003cspan class=\"hljs-attr\"\u003eparse\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eparse\u003c/span\u003e,\n                \u003cspan class=\"hljs-attr\"\u003eparameters\u003c/span\u003e: {\n                    \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'object'\u003c/span\u003e,\n                    \u003cspan class=\"hljs-attr\"\u003eproperties\u003c/span\u003e: { \u003cspan class=\"hljs-comment\"\u003e// 이 속성들은 콜백 \"options\" 매개변수에 있을 것입니다\u003c/span\u003e\n                        \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: {\n                            \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'string'\u003c/span\u003e,\n                            \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'입력 텍스트의 레이블'\u003c/span\u003e,\n                            \u003cspan class=\"hljs-attr\"\u003eenum\u003c/span\u003e: \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elabels\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 가능한 문자열을 제한합니다\u003c/span\u003e\n                        },\n                    },\n                },\n            },\n        };\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 도구를 사용하면 OpenAI에 요청을 보내고 레이블이 필요한 데이터를 반복할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"openai\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\u003cspan class=\"hljs-title class_\"\u003eLabelTool\u003c/span\u003e} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"./tools/label.tool\"\u003c/span\u003e;\n\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'dotenv'\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003econfig\u003c/span\u003e()\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e client = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eapiKey\u003c/span\u003e: process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eOPENAI_API_KEY\u003c/span\u003e,\n});\n\n(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e inputTexts = [ \u003cspan class=\"hljs-comment\"\u003e// OpenAI 모델이 이를 ['positive', 'negative', 'neutral']로 레이블링합니다\u003c/span\u003e\n        \u003cspan class=\"hljs-string\"\u003e\"이 제품을 사랑해요!\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"이게 내가 산 것 중에 가장 최악이에요.\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"괜찮아요, 유난히 좋진 않지만 나쁘진 않아요.\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"돈 안 아깝다고.\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"최고의 구매!\"\u003c/span\u003e,\n    ];\n\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e inputText \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e inputTexts) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edebug\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`프롬프트: 이 텍스트에 레이블을 부여하세요: \u003cspan class=\"hljs-subst\"\u003e${inputText}\u003c/span\u003e`\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tool = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLabelTool\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e'positive'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'negative'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'neutral'\u003c/span\u003e]);\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e context = { \u003cspan class=\"hljs-attr\"\u003einputText\u003c/span\u003e: inputText };\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e prompt = \u003cspan class=\"hljs-string\"\u003e`이 텍스트에 레이블을 부여하세요: \u003cspan class=\"hljs-subst\"\u003e${inputText}\u003c/span\u003e`\u003c/span\u003e;\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e system = \u003cspan class=\"hljs-string\"\u003e'훈련 데이터 생성을 돕는 유용한 도우미입니다.'\u003c/span\u003e;\n\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e runner = client.\u003cspan class=\"hljs-property\"\u003ebeta\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003echat\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecompletions\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erunTools\u003c/span\u003e({\n            \u003cspan class=\"hljs-attr\"\u003emodel\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'gpt-3.5-turbo'\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003emessages\u003c/span\u003e: [\n                {\n                    \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'system'\u003c/span\u003e,\n                    \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: system,\n                },\n                {\n                    \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'user'\u003c/span\u003e,\n                    \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e: prompt,\n                },\n            ],\n            \u003cspan class=\"hljs-attr\"\u003etools\u003c/span\u003e: [\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e tool.\u003cspan class=\"hljs-title function_\"\u003egetSchema\u003c/span\u003e(context)],\n            \u003cspan class=\"hljs-attr\"\u003etool_choice\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'auto'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 'auto' 대신 tool_choice: {function: {name: ...}를 전달하면 해당 함수를 호출한 후 즉시 반환됩니다\u003c/span\u003e\n        });\n\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e finalContent = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e runner.\u003cspan class=\"hljs-title function_\"\u003efinalContent\u003c/span\u003e();\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`AI 응답: \u003cspan class=\"hljs-subst\"\u003e${finalContent}\u003c/span\u003e\n        `\u003c/span\u003e);\n    }\n})();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e로그 결과:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003ePrompt: 이 텍스트를 라벨링하세요: 나는이 제품을 좋아해요!\nCSV 행 추가: 긍정적 | 나는이 제품을 좋아해요!\nAI 응답: \"나는이 제품을 좋아해요!\" 텍스트가 긍정적으로 라벨링되었습니다.\u003c/p\u003e\n\u003cp\u003ePrompt: 이 텍스트를 라벨링하세요: 이건 내가 산 것 중 가장 최악입니다.\nCSV 행 추가: 부정적 | 이건 내가 산 것 중 가장 최악입니다.\nAI 응답: \"이건 내가 산 것 중 가장 최악입니다.\" 텍스트가 부정적으로 라벨링되었습니다.\u003c/p\u003e\n\u003cp\u003ePrompt: 이 텍스트를 라벨링하세요: 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\nCSV 행 추가: 중립 | 그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\nAI 응답: \"그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\" 텍스트가 중립으로 라벨링되었습니다.\u003c/p\u003e\n\u003cp\u003ePrompt: 이 텍스트를 라벨링하세요: 가치가 없어요.\nCSV 행 추가: 부정적 | 가치가 없어요.\nAI 응답: \"가치가 없어요.\" 텍스트가 부정적으로 라벨링되었습니다.\u003c/p\u003e\n\u003cp\u003ePrompt: 이 텍스트를 라벨링하세요: 최고의 구매!\nCSV 행 추가: 긍정적 | 최고의 구매!\nAI 응답: \"최고의 구매!\" 텍스트가 긍정적으로 라벨링되었습니다.\u003c/p\u003e\n\u003cp\u003eCSV 파일:\u003c/p\u003e\n\u003cp\u003e라벨,텍스트\r\n긍정적,나는이 제품을 좋아해요!\r\n부정적,이건 내가 산 것 중 가장 최악입니다.\r\n중립,\"그저 괜찮아요, 훌륭하지 않지만 나쁘지도 않아요.\"\r\n부정적,가치가 없어요.\r\n긍정적,최고의 구매!\u003c/p\u003e\n\u003cp\u003e물론 이 방법을 단순화하거나 확장하는 다양한 방법이 있지만, 이 예제를 선택하여 아이디어를 제공했습니다. 이 코드를 다음 GitHub 저장소에서 시도해볼 수 있습니다: \u003ca href=\"https://github.com/MaurerKrisztian/training_data_genration_with_openai\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/MaurerKrisztian/training_data_genration_with_openai\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eOpenAI의 함수 호출을 사용하면 고품질의 훈련 데이터를 생성하는 것이 훨씬 쉬워집니다. 텍스트, 이미지, 오디오 또는 기타 데이터를 레이블링할 때, 이 방법을 사용하면 레이블이 정확하고 일관적임이 보장됩니다. 이를 통해 기계 학습 모델을 훈련하거나 세부 조정할 때 많은 시간과 노력을 절약할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 블로그 글을 읽어 주셔서 감사합니다! 이 아이디어에 대해 여전히 실험 중이라 의견을 주시면 감사하겠습니다. 어떻게 이 방법을 활용하거나 확장할 수 있는지에 대한 생각이 있으면 댓글을 남겨주세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-GeneratingtrainingdatawithOpenAIfunctioncalling"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>