<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nodejs를 사용하여 마이크로서비스 작성하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-19-WritingAMicroserviceUsingNodejs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nodejs를 사용하여 마이크로서비스 작성하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Nodejs를 사용하여 마이크로서비스 작성하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-19-WritingAMicroserviceUsingNodejs" data-gatsby-head="true"/><meta name="twitter:title" content="Nodejs를 사용하여 마이크로서비스 작성하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 22:49" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nodejs를 사용하여 마이크로서비스 작성하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nodejs를 사용하여 마이크로서비스 작성하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">21<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-WritingAMicroserviceUsingNodejs&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png" alt="Image"></p>
<p>자바스크립트는 프로그래밍 언어 평가에서 주요 위치를 유지하고 있습니다. 자바스크립트에는 브라우저와 Node.js 두 가지 구현이 있습니다. 후자는 웹 서비스 개발에 널리 사용됩니다.</p>
<p>IT 경력을 시작한 지 약 여덟 년 전에 자바스크립트를 배우기 시작했고, 몇 년 전에 David Flanagan의 훌륭한 책 "JavaScript: The Definitive Guide"를 읽었습니다.</p>
<p>이 책은 많은 질문에 답하고 흥미로운 자바스크립트 레시피를 보여줬는데, 이를 내 업무에 적용하고 있습니다. 그러나 더 중요한 것은, Node.js로 웹 서비스 개발에 초점을 맞추게 됐습니다 (이전에는 JS를 프론트엔드 개발에만 사용). 이 책을 새로운 자바스크립트 개발자뿐만 아니라 경험있는 개발자에게도 추천합니다.</p>
<div class="content-ad"></div>
<p>이 게시물에서는 Node.js를 사용하여 마이크로서비스를 구축하는 방법을 소개하려고 합니다. 웹 개발 경험을 기반으로 인기 있는 Node.js 스택을 활용하여 확장 가능하고 견고하며 신뢰성 있고 성능이 우수한 솔루션을 만들어 보겠습니다.</p>
<h1>소개</h1>
<p>이 글에서는 작업 관리 웹 서비스 예시에 마이크로서비스를 구축하는 방법을 보여드리려고 합니다. 다음 API를 제공할 것입니다:</p>
<ul>
<li>이름과 설명으로 작업 생성;</li>
<li>식별자로 작업 가져오기;</li>
<li>작업 상태/이름/설명 업데이트.</li>
</ul>
<div class="content-ad"></div>
<p>Node.js로 웹 애플리케이션을 빌드할 때 얼마나 강력한지 보여주는 간단한 API입니다. 개발 프로세스가 빠르고 쉽습니다.</p>
<p>몇 가지 애플리케이션 요구 사항:</p>
<ul>
<li>작업은 상태 'new'로 생성되어야 합니다.</li>
<li>사용 가능한 상태 전이: 'new'에서 'active'로, 'new'에서 'canceled'로, 'active'에서 'completed'로, 'active'에서 'canceled'로.</li>
<li>경쟁 상태를 피하십시오 (자세한 내용은 나중에).</li>
</ul>
<p>주요 비기능 요구 사항은:</p>
<div class="content-ad"></div>
<ul>
<li>확장성 — 마이크로서비스는 증가하는 요청 양을 처리할 수 있어야 합니다.</li>
<li>탄력성 — 마이크로서비스는 즉각 처리할 수 있어야 합니다.</li>
<li>성능 — 마이크로서비스는 빠르게 응답하여 더 나은 사용자 경험을 제공해야 합니다.</li>
<li>복원력 — 마이크로서비스는 장애에 대해 허용하고 회복할 수 있어야 하므로 올바르게 기능을 계속 수행할 수 있어야 합니다.</li>
<li>모니터링 — 마이크로서비스는 건강을 모니터링하는 방법을 제공해야 합니다.</li>
<li>관찰가능성 — 마이크로서비스는 로그 스트림 및 메트릭을 생성하여 유지할 수 있어야 합니다.</li>
<li>테스트 용이성 — 마이크로서비스는 쉽게 테스트할 수 있어야 합니다.</li>
<li>상태를 유지하지 않음 — 마이크로서비스는 클라이언트 컨텍스트를 저장하지 않아야 하며 대신 상태는 데이터베이스에 저장되어야 합니다.</li>
<li>배포 용이성 — 마이크로서비스는 쉽게 배포 및 업데이트할 수 있어야 합니다.</li>
</ul>
<p>Node.js로 웹 애플리케이션을 개발할 때 모두 가능합니다. 다음 단계에서 이러한 요구사항을 어떻게 달성할지 논의해보겠습니다.</p>
<h1>스택</h1>
<p>웹 서비스를 구축하기 위해 사용할 기술 스택을 처음부터 선택해야 합니다. 물론, 가장 먼저 고려해야 할 질문은 프로그래밍 언어입니다. 이 마이크로서비스에서는 Node.js를 사용할 것이지만, 그럼에도 불구하고, 웹 서비스 개발에 사용하는 데 Node.js의 몇 가지 이점을 소개해 드리겠습니다.</p>
<div class="content-ad"></div>
<ul>
<li>자바스크립트는 이미 프론트엔드 개발의 주요 언어이며, 백엔드 개발에도 사용하는 것이 합리적입니다. 이렇게 하면 동일한 개발자가 풀 스택 애플리케이션을 개발할 수 있습니다.</li>
<li>자바스크립트 커뮤니티는 엄청나게 큽니다. 개발 중 발생할 수 있는 모든 질문에 대한 답변을 찾을 수 있습니다. 또한 많은 라이브러리가 커뮤니티에 의해 개발되고 유지보수됩니다. 유사한 문제를 해결하는 다른 서드파티를 찾을 수 있으며, 각각 고유한 기능을 가집니다.</li>
<li>노드.제이에스는 구글의 V8 엔진을 사용하여 자바스크립트를 해석하며, 이를 빠르게 기계 코드로 컴파일합니다.</li>
</ul>
<p>그리고 이런식으로 계속됩니다! 하지만 가장 중요한 질문은 아닙니다.</p>
<h2>데이터베이스</h2>
<p>웹 요청간 데이터를 유지하고 싶습니다. 확장 가능한 상태 유지 웹 서비스를 개발하는 것은 복잡한 작업입니다. 그래서 웹 애플리케이션을 상태가 없는 상태로 유지하고 개별적으로 상태를 외부 데이터베이스에 유지하는 것이 권장됩니다.</p>
<div class="content-ad"></div>
<p>이 서비스를 개발하기 위해 인기 있는 문서 지향 데이터베이스 MongoDB를 사용할 것입니다.</p>
<p>MongoDB는 SQL 데이터베이스보다 몇 가지 이점을 제공하는 NoSQL 데이터베이스입니다:</p>
<ul>
<li>스키마 무료 — MongoDB 컬렉션 (SQL 테이블에 해당하는)은 다른 스키마를 가진 문서를 보유할 수 있습니다. 문서를 컬렉션에 저장하기 전에 구조를 먼저 정의할 필요가 없습니다;</li>
<li>확장성 — MongoDB는 여러 서버에 걸쳐 확장 가능하게 설계되었습니다;</li>
<li>성능 — MongoDB는 읽기 중심 작업에 최적화되어 있으며 대량의 데이터를 저장할 수 있습니다.</li>
</ul>
<p>Node.js 웹 서비스를 개발할 때 인기 있는 선택 사항입니다.</p>
<div class="content-ad"></div>
<h1>웹 프레임워크</h1>
<p>웹 프레임워크는 웹 애플리케이션을 구축하는 데 필요합니다. 웹 서비스 개발 시 필요한 많은 일상적인 작업을 처리합니다. 예를 들면 라우팅, 보안, 바인딩 등이 있습니다.</p>
<p>Node.js 웹 프레임워크에는 다양한 옵션이 있습니다. 그중에서 가장 인기 있는 것은 express입니다:</p>
<p>express의 가장 큰 장점은 사용하기 간편하며 웹 서버를 시작하는 데 필요한 코드가 최소량으로만 필요하다는 것입니다. express로 작성된 'Hello, World!' 예제가 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">'Hello World!'</span>)
})
app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Example app listening on port <span class="hljs-subst">${port}</span>`</span>)
})
</code></pre>
<p>또한, Express는 많은 커뮤니티가 있는데, 서버 기능을 확장하는 다양한 라이브러리(일반적으로 미들웨어로 개발됨)들을 찾을 수 있습니다.</p>
<h1>유효성 검사</h1>
<p>유효성 검사는 웹 애플리케이션의 중요한 부분입니다. 사용자가 API를 어떻게 사용할지 알 수 없기 때문에, 침입자가 잘못된 입력을 제공하여 응용프로그램을 손상시킬 수 있습니다.</p>
<div class="content-ad"></div>
<p>웹 요청에서 제공된 매개변수(경로, 본문 등)를 확인하고 올바른지 확인하기 위해 joi를 사용할 거에요:</p>
<p>joi는 다양한 모델을 확인하는 데 사용되는 강력한 라이브러리에요. 나중에 개발할 요청 중 하나를 확인하는 예시가 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> createTask = {
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">object</span>().<span class="hljs-title function_">keys</span>({
    <span class="hljs-attr">name</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().required(),
    <span class="hljs-attr">description</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">optional</span>(),
  }),
};
</code></pre>
<p>이는 객체가 두 개의 문자열을 가진 중첩된 body 객체를 갖는지 확인하며, 이 문자열은 필수인 name과 선택적인 description이에요.</p>
<div class="content-ad"></div>
<p>하지만 그것만이 아닙니다. 컬렉션을 삭제할 수 있는 위험한 MongoDB 인젝션을 제공하는 경우가 여전히 있습니다. 웹 요청을 정리하기 위해 express-mongo-sanitize 패키지를 사용할 것입니다:</p>
<h1>설정</h1>
<p>동일한 빌드 아티팩트를 다른 환경에서 실행할 수 있도록 응용 프로그램을 구성할 필요가 있습니다. 이를 위해 환경 변수를 통해 구성을 제공하는 것이 표준 접근 방식입니다.</p>
<p>응용 프로그램을 시작하기 전에 로컬 머신에서 환경 변수를 수동으로 설정하고 싶지 않을 것입니다. 이 문제에 대한 인기 있는 Node.js 솔루션은 dotenv 라이브러리에 구현되어 있습니다:</p>
<div class="content-ad"></div>
<p>이 라이브러리는 .env(파일 이름을 변경할 수 있음)이라는 파일에서 내용을 로드하고 이 파일의 내용을 환경 변수로 설정합니다.</p>
<h1>정적 분석</h1>
<p>JavaScript 애플리케이션의 경우 ESLint 라이브러리를 설치하여 코드 스타일을 쉽게 강제하고 응용 프로그램을 개발할 때 동일한 규칙을 따를 수 있습니다:</p>
<p>ESLint는 코드 품질을 향상하고 몇 가지 버그를 감지할 수 있습니다. 보안 취약점을 식별할 수 있습니다. CI(지속적 통합) 중에 ESLint 검사를 포함하여 팀원들이 ESLint에서 소개한 규칙을 준수하도록 강제할 수 있습니다. 나중에 이를 수행할 예정입니다.</p>
<div class="content-ad"></div>
<h1>테스트</h1>
<p>애플리케이션을 변경할 때 이전과 동일하게 작동하는지 확인하기 위해 자동 테스트를 작성하는 것이 좋은 실천법입니다. 단위, 통합, 부하, 엔드-투-엔드 (E2E) 등 다양한 테스트 유형이 있습니다. 애플리케이션의 품질과 성능을 확신하려면 더 많은 테스트가 필요합니다.</p>
<p>JavaScript 애플리케이션을 테스트하기 위한 가장 인기 있는 라이브러리 중 하나는 Jest입니다:</p>
<p>Jest를 사용하여 단위 및 통합 테스트를 구현할 것입니다. 이러한 테스트는 나중에 코드를 개선하고 리팩토링하는 데 도움이 되었으며 애플리케이션이 손상되지 않았음을 확인했습니다.</p>
<div class="content-ad"></div>
<h1>로깅</h1>
<p>애플리케이션 로그 스트림은 웹 서비스를 원격으로 디버깅하는 데 도움이 됩니다. 코드 실행 경로를 식별하고 요청 로직을 다양한 상황에서 설명할 수 있습니다. 코드에 로그를 삽입하면 이점을 누릴 수 있습니다.</p>
<p>JavaScript 로그를 수집하는 가장 인기 있는 패키지는 winston입니다:</p>
<p>winston은 간단하지만 강력한 로깅 라이브러리로, 다양한 전송 방법(콘솔, 파일 등)을 사용하여 로그를 수집하는 데 도움을 줍니다. 로그 형식(간단한 텍스트, JSON 등)도 변경할 수 있습니다.</p>
<div class="content-ad"></div>
<h1>메트릭</h1>
<p>메트릭을 통해 응용 프로그램의 상태를 모니터링할 수 있어요. 들어오는 요청의 수, 평균 요청 실행 시간, 5XX 응답의 수 등을 확인할 수 있습니다. 메트릭을 통해 어떠한 문제가 발생할 경우 이메일, 알림 등을 통해 알림을 받을 수 있는 다양한 모니터를 설정할 수 있어요.</p>
<p>제 응용 프로그램에서는 express-prom-bundle이라는 표준 웹 응용 프로그램 메트릭을 수집하는 Prometheus 미들웨어를 설치할 예정이에요.</p>
<p>다음 섹션에서 Prometheus에 대해 더 자세히 알아볼 거예요.</p>
<div class="content-ad"></div>
<h1>모니터링 스택</h1>
<p>로그 스트림 및 메트릭은 나중에 모니터링하거나 시각화하는 데 사용할 수 있도록 일부 데이터베이스에 수집되어야 합니다.</p>
<p>로그 및 메트릭을 수집하고 시각화하기 위해 다음 스택을 사용할 것입니다:</p>
<ul>
<li>Prometheus — 메트릭을 수집하기 위해 풀 모델을 사용하는 오픈 소스 모니터링 경보 툴킷;</li>
<li>Promtail — 로그를 포함하고 전송하는 에이전트;</li>
<li>Loki — 로그 집계 시스템;</li>
<li>Grafana — 관측 가능성 시스템.</li>
</ul>
<div class="content-ad"></div>
<h1>로컬 인프라스트럭처</h1>
<p>로컬에서 애플리케이션을 개발하고 테스트하기 위해 필요한 로컬 스택을 만들기 위해 도커를 사용할 거예요.</p>
<p>도커를 사용하면 스테이징 및 프로덕션 환경에서 사용될 것과 유사한 로컬 환경을 시작할 수 있어요. 로컬 컴퓨터에 많은 도구를 설치할 필요가 없어요. 대신 필요한 스택을 시작하기 위해 몇 가지 명령을 실행할 수 있어요.</p>
<p>도커 컴포즈를 사용하면 단일 compose.yml 파일로 모든 인프라스트럭처를 정의하고 단일 명령으로 시작할 수 있어요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">도커 컴포즈 업 -d
</code></pre>
<h1>지속적 통합</h1>
<p>커밋이 무엇인가를 망가뜨리지 않았는지 확인하기 위해, 지속적 통합(CI)가 필요합니다.</p>
<p>이를 위해, 저는 GitHub Actions를 사용할 것입니다:</p>
<div class="content-ad"></div>
<p>GitHub 계정에는 무료 티어가 있어서 애플리케이션 코드를 확인하기 위해 간단한 빌드를 실행할 수 있어요.</p>
<h1>애플리케이션 개발</h1>
<p>애플리케이션 구조를 시작했고 적절한 프로젝트 스타일을 따르는 데 도움이 된 훌륭한 저장소를 찾았어요:</p>
<p>이 저장소에서 코드 일부(예: 유효성 검사 미들웨어)를 빌려왔기 때문에 여러분이 확인하도록 추천드려요.</p>
<div class="content-ad"></div>
<p>나중에 저장소 링크를 공유할 건데, 그 전에 재미있는 애플리케이션 부분을 보여주고 싶어요.</p>
<p>나는 mongoose를 사용해서 애플리케이션을 MongoDB와 통합했어요. 먼저, 모델의 스키마를 정의했어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">Schema</span> } = mongoose;
<span class="hljs-keyword">const</span> <span class="hljs-title class_">TaskSchema</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>(
  {
    <span class="hljs-attr">name</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
    },
    <span class="hljs-attr">description</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
      <span class="hljs-attr">required</span>: <span class="hljs-literal">false</span>,
    },
    <span class="hljs-attr">status</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
      <span class="hljs-attr">enum</span>: [<span class="hljs-string">'new'</span>, <span class="hljs-string">'active'</span>, <span class="hljs-string">'completed'</span>, <span class="hljs-string">'cancelled'</span>],
      <span class="hljs-attr">default</span>: <span class="hljs-string">'new'</span>,
    },
    <span class="hljs-attr">createdAt</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Date</span>,
      <span class="hljs-attr">default</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span>,
    },
    <span class="hljs-attr">updatedAt</span>: <span class="hljs-title class_">Date</span>,
  },
  { <span class="hljs-attr">optimisticConcurrency</span>: <span class="hljs-literal">true</span> },
);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'task'</span>, <span class="hljs-title class_">TaskSchema</span>);
</code></pre>
<p>이 객체를 사용하여 모델을 유효성 검사하고 코드에서 다양한 MongoDB 작업을 수행할 수 있어요. 이는 작업 업데이트의 예시입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateTaskById</span>(<span class="hljs-params">id, { name, description, status }</span>) {
  <span class="hljs-keyword">if</span> (!name &#x26;&#x26; !description &#x26;&#x26; !status) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">error</span>: <span class="hljs-string">'적어도 하나의 업데이트가 필요합니다'</span>, <span class="hljs-attr">code</span>: <span class="hljs-variable constant_">AT_LEAST_ONE_UPDATE_REQUIRED_CODE</span> };
  }

<span class="hljs-keyword">if</span> (status &#x26;&#x26; !(status <span class="hljs-keyword">in</span> availableUpdates)) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">error</span>: <span class="hljs-string">'잘못된 상태입니다'</span>, <span class="hljs-attr">code</span>: <span class="hljs-variable constant_">INVALID_STATUS_CODE</span> };
  }
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> retry = <span class="hljs-number">0</span>; retry &#x3C; <span class="hljs-number">3</span>; retry += <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// eslint-disable-next-line no-await-in-loop</span>
    <span class="hljs-keyword">const</span> task = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Task</span>.<span class="hljs-title function_">findById</span>(id);
    <span class="hljs-keyword">if</span> (!task) {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">error</span>: <span class="hljs-string">'작업을 찾을 수 없습니다'</span>, <span class="hljs-attr">code</span>: <span class="hljs-variable constant_">INVALID_STATUS_TRANSITION_CODE</span> };
    }
    <span class="hljs-keyword">if</span> (status) {
      <span class="hljs-keyword">const</span> allowedStatuses = availableUpdates[task.<span class="hljs-property">status</span>];
      <span class="hljs-keyword">if</span> (!allowedStatuses.<span class="hljs-title function_">includes</span>(status)) {
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">error</span>: <span class="hljs-string">`'<span class="hljs-subst">${task.status}</span>'에서 '<span class="hljs-subst">${status}</span>'(으)로 업데이트할 수 없습니다`</span>,
          <span class="hljs-attr">code</span>: <span class="hljs-variable constant_">TASK_NOT_FOUND_CODE</span>,
        };
      }
    }
    task.<span class="hljs-property">status</span> = status ?? task.<span class="hljs-property">status</span>;
    task.<span class="hljs-property">name</span> = name ?? task.<span class="hljs-property">name</span>;
    task.<span class="hljs-property">description</span> = description ?? task.<span class="hljs-property">description</span>;
    task.<span class="hljs-property">updatedAt</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// eslint-disable-next-line no-await-in-loop</span>
      <span class="hljs-keyword">await</span> task.<span class="hljs-title function_">save</span>();
    } <span class="hljs-keyword">catch</span> (error) {
      logger.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'저장 중 오류 발생'</span>, { error });
      <span class="hljs-keyword">if</span> (error.<span class="hljs-property">name</span> === <span class="hljs-string">'VersionError'</span>) {
        <span class="hljs-comment">// eslint-disable-next-line no-continue</span>
        <span class="hljs-keyword">continue</span>;
      }
    }
    <span class="hljs-keyword">return</span> task;
  }
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">error</span>: <span class="hljs-string">'병행성 오류'</span>, <span class="hljs-attr">code</span>: <span class="hljs-variable constant_">CONCURRENCY_ERROR_CODE</span> };
}
</code></pre>
<p>가장 흥미로운 부분은 업데이트 후 모델을 저장하는 부분입니다. 격렬한 충돌 문제에 대처하기 위해 낙관적 락을 사용하고 있어요.</p>
<p>두 개의 동시 요청에서 동일한 작업을 완료하고 취소하려고 하는 상황을 상상해보세요. 두 요청이 모두 상태가 '활성'인 작업을 받고 모델을 저장할 때 충돌이 발생할 수 있어요. 첫 번째 작업의 상태가 '완료'로 변경되고 그런 다음 '취소'로 변경될 수 있습니다(또는 그 반대로). 이는 '완료'-'취소' 및 '취소'-'완료' 전이가 허용되지 않기 때문에 잘못된 동작입니다.</p>
<p>Mongoose는 낙관적 락으로 이 문제에 대한 해결책을 구현했어요. 낙관적 락은 데이터베이스에서 동시 요청을 처리하는 데 사용되는 전략입니다. 각 문서에는 추가적인 버전 속성이 있어요. 트랜잭션이 모델을 저장/업데이트하려고 할 때 버전을 확인합니다. 버전이 get 쿼리를 수행할 때 받은 버전과 다른 경우, 이미 누군가 문서를 동시에 업데이트했을 수 있어요. 트랜잭션이 중단됩니다(위의 코드에서는 오류가 발생합니다).</p>
<div class="content-ad"></div>
<p>문서 예시:</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">"_id"</span>: {
    <span class="hljs-string">"$oid"</span>: <span class="hljs-string">"654e03210948a61665b7c889"</span>
  },
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"damnatio"</span>,
  <span class="hljs-string">"description"</span>: <span class="hljs-string">"Ciminatio totus spiritus suffoco damnatio blanditiis."</span>,
  <span class="hljs-string">"status"</span>: <span class="hljs-string">"completed"</span>,
  <span class="hljs-string">"createdAt"</span>: {
    <span class="hljs-string">"$date"</span>: <span class="hljs-string">"2023-11-10T10:17:05.039Z"</span>
  },
  <span class="hljs-string">"__v"</span>: <span class="hljs-number">2</span>,
  <span class="hljs-string">"updatedAt"</span>: {
    <span class="hljs-string">"$date"</span>: <span class="hljs-string">"2023-11-10T10:17:05.064Z"</span>
  }
}
</code></pre>
<p>위의 문서는 속성 __v에 버전을 저장합니다.</p>
<p>다음 레벨은 컨트롤러입니다. 컨트롤러 예시는 다음과 같습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> updateTaskById = <span class="hljs-title function_">catchAsync</span>(<span class="hljs-keyword">async</span> (req, res) => {
  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> taskService.<span class="hljs-title function_">updateTaskById</span>(req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>, req.<span class="hljs-property">body</span>);
  <span class="hljs-keyword">if</span> (result.<span class="hljs-property">error</span>) {
    <span class="hljs-keyword">switch</span> (result.<span class="hljs-property">code</span>) {
      <span class="hljs-keyword">case</span> taskService.<span class="hljs-property">errorCodes</span>.<span class="hljs-property">AT_LEAST_ONE_UPDATE_REQUIRED_CODE</span>:
        res.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'적어도 하나의 업데이트가 필요합니다'</span> });
        <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">case</span> taskService.<span class="hljs-property">errorCodes</span>.<span class="hljs-property">INVALID_STATUS_CODE</span>:
        res.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'유효하지 않은 상태'</span> });
        <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">case</span> taskService.<span class="hljs-property">errorCodes</span>.<span class="hljs-property">INVALID_STATUS_TRANSITION_CODE</span>:
        res.<span class="hljs-title function_">status</span>(<span class="hljs-number">404</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'작업을 찾을 수 없음'</span> });
        <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">case</span> taskService.<span class="hljs-property">errorCodes</span>.<span class="hljs-property">TASK_NOT_FOUND_CODE</span>:
        res.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">message</span>: result.<span class="hljs-property">error</span> });
        <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">case</span> taskService.<span class="hljs-property">errorCodes</span>.<span class="hljs-property">CONCURRENCY_ERROR_CODE</span>:
        res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'동시성 오류'</span> });
        <span class="hljs-keyword">return</span>;
      <span class="hljs-attr">default</span>:
        res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'내부 서버 오류'</span> });
        <span class="hljs-keyword">return</span>;
    }
  }

res.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">json</span>({
    <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">task</span>: <span class="hljs-title function_">toDto</span>(result),
  });
});
</code></pre>
<p>이 코드는 애플리케이션 비즈니스 로직을 실행하고 HTTP 응답을 반환합니다. 컨트롤러는 routes 모듈에 등록됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Router</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> taskController = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../../controllers/task'</span>);
<span class="hljs-keyword">const</span> taskValidation = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../../validation/task'</span>);
<span class="hljs-keyword">const</span> validate = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../../middlewares/validate'</span>);

<span class="hljs-keyword">const</span> router = <span class="hljs-title class_">Router</span>();
router.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/:id'</span>, <span class="hljs-title function_">validate</span>(taskValidation.<span class="hljs-property">getTaskById</span>), taskController.<span class="hljs-property">getTaskById</span>);
router.<span class="hljs-title function_">put</span>(<span class="hljs-string">'/'</span>, <span class="hljs-title function_">validate</span>(taskValidation.<span class="hljs-property">createTask</span>), taskController.<span class="hljs-property">createTask</span>);
router.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/:id'</span>, <span class="hljs-title function_">validate</span>(taskValidation.<span class="hljs-property">updateTaskById</span>), taskController.<span class="hljs-property">updateTaskById</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@swagger</span>
 * tags:
 *  name: Tasks
 *  description: 작업 관리 및 검색
 * /v1/tasks/{id}:
 *  get:
 *   summary: ID로 작업 가져오기
 *   tags: [Tasks]
 *   description: ID로 작업 가져오기
 *   parameters:
 *    - in: path
 *      name: id
 *      schema:
 *       type: string
 *       required: true
 *       description: 작업 ID
 *       example: 5f0a3d9a3e06e52f3c7a6d5c
 *   responses:
 *    200:
 *     description: 작업 검색됨
 *     content:
 *      application/json:
 *       schema:
 *        $ref: '#/components/schemas/TaskResult'
 *    404:
 *     description: 작업을 찾을 수 없음
 *     content:
 *      application/json:
 *       schema:
 *        $ref: '#/components/schemas/TaskResult'
 *    500:
 *     description: 내부 서버 오류
 *  post:
 *   summary: ID로 작업 업데이트
 *   tags: [Tasks]
 *   description: ID로 작업 업데이트
 *   parameters:
 *    - in: path
 *      name: id
 *      schema:
 *       type: string
 *       required: true
 *       description: 작업 ID
 *       example: 5f0a3d9a3e06e52f3c7a6d5c
 *   requestBody:
 *    required: true
 *    content:
 *     application/json:
 *      schema:
 *       $ref: '#/components/schemas/UpdateTask'
 *   responses:
 *    200:
 *     description: 작업 업데이트됨
 *     content:
 *      application/json:
 *       schema:
 *        $ref: '#/components/schemas/TaskResult'
 *     404:
 *      description: 작업을 찾을 수 없음
 *      content:
 *       application/json:
 *        schema:
 *         $ref: '#/components/schemas/TaskResult'
 *     500:
 *      description: 내부 서버 오류
 * /v1/tasks:
 *  put:
 *   summary: 작업 생성
 *   tags: [Tasks]
 *   description: 작업 생성
 *   requestBody:
 *    required: true
 *    content:
 *     application/json:
 *      schema:
 *       $ref: '#/components/schemas/CreateTask'
 *   responses:
 *    201:
 *     description: 작업 생성됨
 *     content:
 *      application/json:
 *       schema:
 *        $ref: '#/components/schemas/TaskResult'
 *    500:
 *     description: 내부 서버 오류
 */</span>
</code></pre>
<p>맨 아래에서는 Swagger 미들웨어가 사용하는 OpenAPI 사양이 API 문서 페이지를 생성하는 데 사용됨을 볼 수 있습니다.</p>
<div class="content-ad"></div>
<p>각 경로 등록은 두 개의 핸들러를 사용합니다: 유효성 검사기와 컨트롤러 메서드 자체입니다. 유효성 검사기는 서로 다른 모델에 등록된 스키마를 유효성 검사합니다. 유효성 검사기 핸들러:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Joi</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'joi'</span>);
<span class="hljs-keyword">const</span> pick = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../utils/pick'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">validate</span>(<span class="hljs-params">schema</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =></span> {
    <span class="hljs-keyword">const</span> validSchema = <span class="hljs-title function_">pick</span>(schema, [<span class="hljs-string">'params'</span>, <span class="hljs-string">'query'</span>, <span class="hljs-string">'body'</span>]);
    <span class="hljs-keyword">const</span> object = <span class="hljs-title function_">pick</span>(req, <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(validSchema));
    <span class="hljs-keyword">const</span> { value, error } = <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">compile</span>(validSchema)
      .<span class="hljs-title function_">prefs</span>({ <span class="hljs-attr">errors</span>: { <span class="hljs-attr">label</span>: <span class="hljs-string">'key'</span> }, <span class="hljs-attr">abortEarly</span>: <span class="hljs-literal">false</span> })
      .<span class="hljs-title function_">validate</span>(object);
    <span class="hljs-keyword">if</span> (error) {
      <span class="hljs-keyword">const</span> errorMessage = error.<span class="hljs-property">details</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">details</span>) =></span> details.<span class="hljs-property">message</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">', '</span>);
      res.<span class="hljs-title function_">status</span>(<span class="hljs-number">400</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">message</span>: errorMessage });
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(req, value);
    <span class="hljs-title function_">next</span>();
  };
}
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = validate;
</code></pre>
<p>또한 업데이트 요청 유효성 검사 스키마가 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> updateTaskById = {
  <span class="hljs-attr">params</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">object</span>().<span class="hljs-title function_">keys</span>({
    <span class="hljs-attr">id</span>: objectId.required(),
  }),
  <span class="hljs-attr">body</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">object</span>().<span class="hljs-title function_">keys</span>({
    <span class="hljs-attr">name</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">optional</span>(),
    <span class="hljs-attr">description</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">optional</span>(),
    <span class="hljs-attr">status</span>: <span class="hljs-title class_">Joi</span>.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">valid</span>(<span class="hljs-string">'new'</span>, <span class="hljs-string">'active'</span>, <span class="hljs-string">'completed'</span>, <span class="hljs-string">'cancelled'</span>).<span class="hljs-title function_">optional</span>(),
  }),
};
</code></pre>
<div class="content-ad"></div>
<p>업데이트 메서드에 대해 말씀드리겠습니다. 저는 통합 테스트만 구현했습니다. 통합 테스트는 모든 테스트가 실행되기 전과 후에 서버를 시작하고 중지합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../src/app'</span>);
<span class="hljs-keyword">const</span> db = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../src/db'</span>);
<span class="hljs-keyword">const</span> { createConfig } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../src/config/config'</span>);
<span class="hljs-keyword">const</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../../src/config/logger'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title function_">setupServer</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-keyword">let</span> server;
  <span class="hljs-keyword">const</span> configPath = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'../../configs/tests.env'</span>);
  <span class="hljs-keyword">const</span> config = <span class="hljs-title function_">createConfig</span>(configPath);
  <span class="hljs-title function_">beforeAll</span>(<span class="hljs-keyword">async</span> () => {
    logger.<span class="hljs-title function_">init</span>(config);
    <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">init</span>(config);
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> {
      server = app.<span class="hljs-title function_">listen</span>(config.<span class="hljs-property">port</span>, <span class="hljs-function">() =></span> {
        <span class="hljs-title function_">resolve</span>();
      });
    });
  });
  <span class="hljs-title function_">afterAll</span>(<span class="hljs-keyword">async</span> () => {
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> {
      server.<span class="hljs-title function_">close</span>(<span class="hljs-function">() =></span> {
        <span class="hljs-title function_">resolve</span>();
      });
    });
    <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">destroy</span>();
    logger.<span class="hljs-title function_">destroy</span>();
  });
};
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  setupServer,
};
</code></pre>
<p>그리고 PUT 요청(태스크 생성)과 POST 요청(태스크 업데이트)을 수행하는 테스트가 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">describe</span>(<span class="hljs-string">'태스크 생성 및 업데이트'</span>, <span class="hljs-function">() =></span> {
      <span class="hljs-keyword">const</span> data = [
        {
          <span class="hljs-attr">name</span>: <span class="hljs-string">'상태만 업데이트'</span>,
          <span class="hljs-attr">taskName</span>: <span class="hljs-string">'태스크 1'</span>,
          <span class="hljs-attr">description</span>: <span class="hljs-string">'태스크 1 설명'</span>,
          <span class="hljs-attr">newStatus</span>: <span class="hljs-string">'활성'</span>,
        },
        {
          <span class="hljs-attr">name</span>: <span class="hljs-string">'영어 전체 업데이트'</span>,
          <span class="hljs-attr">taskName</span>: <span class="hljs-string">'태스크 1'</span>,
          <span class="hljs-attr">description</span>: <span class="hljs-string">'태스크 1 설명'</span>,
          <span class="hljs-attr">newTaskName</span>: <span class="hljs-string">'태스크 1 새로운'</span>,
          <span class="hljs-attr">newDescription</span>: <span class="hljs-string">'태스크 1 새로운 설명'</span>,
          <span class="hljs-attr">newStatus</span>: <span class="hljs-string">'활성'</span>,
        },
        <span class="hljs-comment">// 이하 생략</span>
      ];

data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">{
        name, taskName, description, newTaskName, newDescription, newStatus,
      }</span>) =></span> {
        <span class="hljs-title function_">it</span>(name, <span class="hljs-keyword">async</span> () => {
          <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(baseUrl, {
            <span class="hljs-attr">method</span>: <span class="hljs-string">'put'</span>,
            <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
              <span class="hljs-attr">name</span>: taskName,
              description,
            }),
            <span class="hljs-attr">headers</span>: { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> },
          });
          <span class="hljs-title function_">expect</span>(response.<span class="hljs-property">status</span>).<span class="hljs-title function_">toEqual</span>(<span class="hljs-number">201</span>);
          <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
          <span class="hljs-comment">// 여기서부터 이하는 생략</span>
        });
      });
    });
</code></pre>
<div class="content-ad"></div>
<p>도커 이미지를 생성하려면 간단한 Dockerfile을 정의했습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">node</span>:<span class="hljs-number">20</span>-alpine
<span class="hljs-variable constant_">WORKDIR</span> /app
<span class="hljs-variable constant_">COPY</span> package.<span class="hljs-property">json</span> yarn.<span class="hljs-property">lock</span> ./
<span class="hljs-variable constant_">RUN</span> yarn install --frozen-lockfile
<span class="hljs-variable constant_">COPY</span> src /app/src
<span class="hljs-variable constant_">CMD</span> [<span class="hljs-string">"node"</span>, <span class="hljs-string">"./src/index.js"</span>]
</code></pre>
<p>어플리케이션과 인프라를 시작하는 데 사용하는 compose.yml 정의입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">version</span>: <span class="hljs-string">'3.9'</span>
<span class="hljs-attr">services</span>:
    <span class="hljs-attr">app</span>:
        <span class="hljs-attr">build</span>: .
        <span class="hljs-attr">ports</span>:
            - <span class="hljs-string">'8081:80'</span>
        <span class="hljs-attr">depends_on</span>:
            - mongo
        <span class="hljs-attr">volumes</span>:
            - ./configs/docker.<span class="hljs-property">env</span>:<span class="hljs-regexp">/app/</span>configs/.<span class="hljs-property">env</span>
            - <span class="hljs-attr">logs</span>:<span class="hljs-regexp">/app/</span><span class="hljs-attr">logs</span>:rw
    <span class="hljs-attr">mongo</span>:
        <span class="hljs-attr">image</span>: <span class="hljs-attr">mongo</span>:<span class="hljs-number">5</span>
        <span class="hljs-attr">restart</span>: always
        <span class="hljs-attr">ports</span>:
            - <span class="hljs-number">27017</span>:<span class="hljs-number">27017</span>
        <span class="hljs-attr">volumes</span>:
            - <span class="hljs-attr">mongodata</span>:<span class="hljs-regexp">/data/</span>db
        <span class="hljs-attr">healthcheck</span>:
            <span class="hljs-attr">test</span>: echo <span class="hljs-string">'db.runCommand("ping").ok'</span> | mongo <span class="hljs-attr">localhost</span>:<span class="hljs-number">27017</span>/test --quiet
            <span class="hljs-attr">interval</span>: 10s
            <span class="hljs-attr">timeout</span>: 2s
            <span class="hljs-attr">retries</span>: <span class="hljs-number">5</span>
            <span class="hljs-attr">start_period</span>: 5s
    <span class="hljs-attr">loki</span>:
        <span class="hljs-attr">image</span>: grafana/<span class="hljs-attr">loki</span>:<span class="hljs-number">2.9</span><span class="hljs-number">.0</span>
        <span class="hljs-attr">expose</span>:
            - <span class="hljs-number">3100</span>
        <span class="hljs-attr">command</span>: -config.<span class="hljs-property">file</span>=<span class="hljs-regexp">/etc/</span>loki/local-config.<span class="hljs-property">yaml</span>
    <span class="hljs-attr">promtail</span>:
        <span class="hljs-attr">image</span>: grafana/<span class="hljs-attr">promtail</span>:<span class="hljs-number">2.9</span><span class="hljs-number">.0</span>
        <span class="hljs-attr">volumes</span>:
            - <span class="hljs-attr">logs</span>:<span class="hljs-regexp">/var/</span><span class="hljs-attr">log</span>:rw
            - ./infrastructure/promtail.<span class="hljs-property">yml</span>:<span class="hljs-regexp">/etc/</span>promtail/config.<span class="hljs-property">yml</span>
        <span class="hljs-attr">command</span>: -config.<span class="hljs-property">file</span>=<span class="hljs-regexp">/etc/</span>promtail/config.<span class="hljs-property">yml</span>
    <span class="hljs-attr">prometheus</span>:
        <span class="hljs-attr">image</span>: prom/<span class="hljs-attr">prometheus</span>:latest
        <span class="hljs-attr">volumes</span>:
            - ./infrastructure/prometheus.<span class="hljs-property">yml</span>:<span class="hljs-regexp">/etc/</span>prometheus/prometheus.<span class="hljs-property">yml</span>
        <span class="hljs-attr">command</span>:
            - <span class="hljs-string">'--config.file=/etc/prometheus/prometheus.yml'</span>
        <span class="hljs-attr">expose</span>:
            - <span class="hljs-number">9090</span>
    <span class="hljs-attr">grafana</span>:
        <span class="hljs-attr">image</span>: grafana/<span class="hljs-attr">grafana</span>:latest
        <span class="hljs-attr">volumes</span>:
            - <span class="hljs-attr">grafanadata</span>:<span class="hljs-regexp">/var/</span>lib/grafana
        <span class="hljs-attr">environment</span>:
            - <span class="hljs-variable constant_">GF_PATHS_PROVISIONING</span>=<span class="hljs-regexp">/etc/g</span>rafana/provisioning
            - <span class="hljs-variable constant_">GF_AUTH_ANONYMOUS_ENABLED</span>=<span class="hljs-literal">true</span>
            - <span class="hljs-variable constant_">GF_AUTH_ANONYMOUS_ORG_ROLE</span>=<span class="hljs-title class_">Admin</span>
        <span class="hljs-attr">ports</span>:
            - <span class="hljs-number">3000</span>:<span class="hljs-number">3000</span>
<span class="hljs-attr">volumes</span>:
    <span class="hljs-attr">mongodata</span>:
    <span class="hljs-attr">grafanadata</span>:
    <span class="hljs-attr">logs</span>:
</code></pre>
<div class="content-ad"></div>
<p>모두 Git push가 발생할 때마다 GitHub Actions CI가 빌드를 실행합니다. CI 중에는 종속성 설치, 린터 실행 및 모든 테스트 실행을 진행하고 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">name</span>: <span class="hljs-title class_">App</span> <span class="hljs-variable constant_">CI</span>
<span class="hljs-attr">on</span>:
  <span class="hljs-attr">push</span>:
    <span class="hljs-attr">branches</span>:
      - <span class="hljs-string">"*"</span>
<span class="hljs-attr">jobs</span>:
  <span class="hljs-attr">ci</span>:
    runs-<span class="hljs-attr">on</span>: ubuntu-latest
    <span class="hljs-attr">steps</span>:
      - <span class="hljs-attr">uses</span>: actions/checkout@v3
      - <span class="hljs-attr">uses</span>: actions/setup-node@v3
        <span class="hljs-attr">with</span>:
          node-<span class="hljs-attr">version</span>: <span class="hljs-number">20</span>
          <span class="hljs-attr">cache</span>: <span class="hljs-string">"yarn"</span>
      - <span class="hljs-attr">run</span>: yarn install --frozen-lockfile
      - <span class="hljs-attr">run</span>: yarn run lint
      - <span class="hljs-attr">run</span>: docker-compose up -d mongo
      - <span class="hljs-attr">run</span>: yarn test -- --verbose --coverage
      - <span class="hljs-attr">run</span>: docker-compose build
      - <span class="hljs-attr">run</span>: docker-compose logs
        <span class="hljs-attr">if</span>: <span class="hljs-title function_">always</span>()
      - <span class="hljs-attr">run</span>: docker-compose down --volumes
        <span class="hljs-attr">if</span>: <span class="hljs-title function_">always</span>()
</code></pre>
<h1>결론</h1>
<p>Node.js는 강력한 기술입니다. 더 중요한 것은 Node.js 커뮤니티가 매우 크다는 것이에요. 새로운 웹 서비스를 개발할 때마다 다른 스택을 사용할 수 있어요. 하지만 저는 이 방법을 추천하지 않아요; 만일 능숙한 Node.js 웹 개발자가 되고 싶다면 먼저 특정 기술의 기능을 익히고, 그런 다음에 다른 스택을 사용해보는 것이 좋아요.</p>
<div class="content-ad"></div>
<p>이 게시물에서 웹 애플리케이션을 구축하는 데 사용한 스택은 Node.js 웹 서비스를 구축하는 데 가장 인기가 많습니다. 구현중인 다양한 기능에 도움이되는 많은 문서와 라이브러리가 있습니다.</p>
<p>Node.js로 이전에 설정한 모든 비기능 요구 사항을 쉽게 달성할 수 있습니다. Kubernetes를 사용하여 응용 프로그램 도커 이미지를 작성하고 호스팅할 수 있습니다. Kubernetes는 배포 정의를 변경하여 응용 프로그램을 빠르게 확장하거나 축소하는 데 도움을줍니다. 또한 Kubernetes는 들어오는 트래픽에 따라 응용 프로그램을 확장할 수 있습니다. 또한 MongoDB는 필요에 따라 확장할 수 있도록 설계되어 있어서 트래픽 증가가 문제가 되지 않습니다.</p>
<p>Google의 V8 Node.js 엔진을 통해 더 나은 응용 프로그램 성능을 달성할 수 있습니다. 소스 코드가 기계 코드로 번역되는 속도는 인상적입니다!</p>
<p>Node.js를 사용하면 내결함성 있는 응용 프로그램을 구축하는 방법에 대한 다양한 인터넷 기사를 찾을 수 있습니다. 최선의 방법을 따라주세요! 또한 응용 프로그램 코드에서는 예기치 않은 연결 실패(네트워크 문제 또는 MongoDB 장애 등) 후 MongoDB 연결을 복원하는 데 시간을 소비했습니다. 이를 확인하고 응용 프로그램에 적용할 수 있습니다.</p>
<div class="content-ad"></div>
<p>Jest를 사용하면 애플리케이션을 위한 다양한 테스트를 작성하고 100%의 테스트 커버리지를 달성할 수 있어요. 몇 가지 까다로운 시나리오도 Jest를 사용하여 에뮬레이션할 수 있어요.</p>
<p>즐거운 코딩 되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nodejs를 사용하여 마이크로서비스 작성하기","description":"","date":"2024-06-19 22:49","slug":"2024-06-19-WritingAMicroserviceUsingNodejs","content":"\n\n\n![Image](/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png)\n\n자바스크립트는 프로그래밍 언어 평가에서 주요 위치를 유지하고 있습니다. 자바스크립트에는 브라우저와 Node.js 두 가지 구현이 있습니다. 후자는 웹 서비스 개발에 널리 사용됩니다.\n\nIT 경력을 시작한 지 약 여덟 년 전에 자바스크립트를 배우기 시작했고, 몇 년 전에 David Flanagan의 훌륭한 책 \"JavaScript: The Definitive Guide\"를 읽었습니다.\n\n이 책은 많은 질문에 답하고 흥미로운 자바스크립트 레시피를 보여줬는데, 이를 내 업무에 적용하고 있습니다. 그러나 더 중요한 것은, Node.js로 웹 서비스 개발에 초점을 맞추게 됐습니다 (이전에는 JS를 프론트엔드 개발에만 사용). 이 책을 새로운 자바스크립트 개발자뿐만 아니라 경험있는 개발자에게도 추천합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 게시물에서는 Node.js를 사용하여 마이크로서비스를 구축하는 방법을 소개하려고 합니다. 웹 개발 경험을 기반으로 인기 있는 Node.js 스택을 활용하여 확장 가능하고 견고하며 신뢰성 있고 성능이 우수한 솔루션을 만들어 보겠습니다.\n\n# 소개\n\n이 글에서는 작업 관리 웹 서비스 예시에 마이크로서비스를 구축하는 방법을 보여드리려고 합니다. 다음 API를 제공할 것입니다:\n\n- 이름과 설명으로 작업 생성;\n- 식별자로 작업 가져오기;\n- 작업 상태/이름/설명 업데이트.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNode.js로 웹 애플리케이션을 빌드할 때 얼마나 강력한지 보여주는 간단한 API입니다. 개발 프로세스가 빠르고 쉽습니다.\n\n몇 가지 애플리케이션 요구 사항:\n\n- 작업은 상태 'new'로 생성되어야 합니다.\n- 사용 가능한 상태 전이: 'new'에서 'active'로, 'new'에서 'canceled'로, 'active'에서 'completed'로, 'active'에서 'canceled'로.\n- 경쟁 상태를 피하십시오 (자세한 내용은 나중에).\n\n주요 비기능 요구 사항은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 확장성 — 마이크로서비스는 증가하는 요청 양을 처리할 수 있어야 합니다.\n- 탄력성 — 마이크로서비스는 즉각 처리할 수 있어야 합니다.\n- 성능 — 마이크로서비스는 빠르게 응답하여 더 나은 사용자 경험을 제공해야 합니다.\n- 복원력 — 마이크로서비스는 장애에 대해 허용하고 회복할 수 있어야 하므로 올바르게 기능을 계속 수행할 수 있어야 합니다.\n- 모니터링 — 마이크로서비스는 건강을 모니터링하는 방법을 제공해야 합니다.\n- 관찰가능성 — 마이크로서비스는 로그 스트림 및 메트릭을 생성하여 유지할 수 있어야 합니다.\n- 테스트 용이성 — 마이크로서비스는 쉽게 테스트할 수 있어야 합니다.\n- 상태를 유지하지 않음 — 마이크로서비스는 클라이언트 컨텍스트를 저장하지 않아야 하며 대신 상태는 데이터베이스에 저장되어야 합니다.\n- 배포 용이성 — 마이크로서비스는 쉽게 배포 및 업데이트할 수 있어야 합니다.\n\nNode.js로 웹 애플리케이션을 개발할 때 모두 가능합니다. 다음 단계에서 이러한 요구사항을 어떻게 달성할지 논의해보겠습니다.\n\n# 스택\n\n웹 서비스를 구축하기 위해 사용할 기술 스택을 처음부터 선택해야 합니다. 물론, 가장 먼저 고려해야 할 질문은 프로그래밍 언어입니다. 이 마이크로서비스에서는 Node.js를 사용할 것이지만, 그럼에도 불구하고, 웹 서비스 개발에 사용하는 데 Node.js의 몇 가지 이점을 소개해 드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 자바스크립트는 이미 프론트엔드 개발의 주요 언어이며, 백엔드 개발에도 사용하는 것이 합리적입니다. 이렇게 하면 동일한 개발자가 풀 스택 애플리케이션을 개발할 수 있습니다.\n- 자바스크립트 커뮤니티는 엄청나게 큽니다. 개발 중 발생할 수 있는 모든 질문에 대한 답변을 찾을 수 있습니다. 또한 많은 라이브러리가 커뮤니티에 의해 개발되고 유지보수됩니다. 유사한 문제를 해결하는 다른 서드파티를 찾을 수 있으며, 각각 고유한 기능을 가집니다.\n- 노드.제이에스는 구글의 V8 엔진을 사용하여 자바스크립트를 해석하며, 이를 빠르게 기계 코드로 컴파일합니다.\n\n그리고 이런식으로 계속됩니다! 하지만 가장 중요한 질문은 아닙니다.\n\n## 데이터베이스\n\n웹 요청간 데이터를 유지하고 싶습니다. 확장 가능한 상태 유지 웹 서비스를 개발하는 것은 복잡한 작업입니다. 그래서 웹 애플리케이션을 상태가 없는 상태로 유지하고 개별적으로 상태를 외부 데이터베이스에 유지하는 것이 권장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 서비스를 개발하기 위해 인기 있는 문서 지향 데이터베이스 MongoDB를 사용할 것입니다.\n\nMongoDB는 SQL 데이터베이스보다 몇 가지 이점을 제공하는 NoSQL 데이터베이스입니다:\n\n- 스키마 무료 — MongoDB 컬렉션 (SQL 테이블에 해당하는)은 다른 스키마를 가진 문서를 보유할 수 있습니다. 문서를 컬렉션에 저장하기 전에 구조를 먼저 정의할 필요가 없습니다;\n- 확장성 — MongoDB는 여러 서버에 걸쳐 확장 가능하게 설계되었습니다;\n- 성능 — MongoDB는 읽기 중심 작업에 최적화되어 있으며 대량의 데이터를 저장할 수 있습니다.\n\nNode.js 웹 서비스를 개발할 때 인기 있는 선택 사항입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 웹 프레임워크\n\n웹 프레임워크는 웹 애플리케이션을 구축하는 데 필요합니다. 웹 서비스 개발 시 필요한 많은 일상적인 작업을 처리합니다. 예를 들면 라우팅, 보안, 바인딩 등이 있습니다.\n\nNode.js 웹 프레임워크에는 다양한 옵션이 있습니다. 그중에서 가장 인기 있는 것은 express입니다:\n\nexpress의 가장 큰 장점은 사용하기 간편하며 웹 서버를 시작하는 데 필요한 코드가 최소량으로만 필요하다는 것입니다. express로 작성된 'Hello, World!' 예제가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst express = require('express')\nconst app = express()\nconst port = 3000;\n\napp.get('/', (req, res) =\u003e {\n  res.send('Hello World!')\n})\napp.listen(port, () =\u003e {\n  console.log(`Example app listening on port ${port}`)\n})\n```\n\n또한, Express는 많은 커뮤니티가 있는데, 서버 기능을 확장하는 다양한 라이브러리(일반적으로 미들웨어로 개발됨)들을 찾을 수 있습니다.\n\n# 유효성 검사\n\n유효성 검사는 웹 애플리케이션의 중요한 부분입니다. 사용자가 API를 어떻게 사용할지 알 수 없기 때문에, 침입자가 잘못된 입력을 제공하여 응용프로그램을 손상시킬 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 요청에서 제공된 매개변수(경로, 본문 등)를 확인하고 올바른지 확인하기 위해 joi를 사용할 거에요:\n\njoi는 다양한 모델을 확인하는 데 사용되는 강력한 라이브러리에요. 나중에 개발할 요청 중 하나를 확인하는 예시가 있어요:\n\n```js\nconst createTask = {\n  body: Joi.object().keys({\n    name: Joi.string().required(),\n    description: Joi.string().optional(),\n  }),\n};\n```\n\n이는 객체가 두 개의 문자열을 가진 중첩된 body 객체를 갖는지 확인하며, 이 문자열은 필수인 name과 선택적인 description이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 그것만이 아닙니다. 컬렉션을 삭제할 수 있는 위험한 MongoDB 인젝션을 제공하는 경우가 여전히 있습니다. 웹 요청을 정리하기 위해 express-mongo-sanitize 패키지를 사용할 것입니다:\n\n# 설정\n\n동일한 빌드 아티팩트를 다른 환경에서 실행할 수 있도록 응용 프로그램을 구성할 필요가 있습니다. 이를 위해 환경 변수를 통해 구성을 제공하는 것이 표준 접근 방식입니다.\n\n응용 프로그램을 시작하기 전에 로컬 머신에서 환경 변수를 수동으로 설정하고 싶지 않을 것입니다. 이 문제에 대한 인기 있는 Node.js 솔루션은 dotenv 라이브러리에 구현되어 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 라이브러리는 .env(파일 이름을 변경할 수 있음)이라는 파일에서 내용을 로드하고 이 파일의 내용을 환경 변수로 설정합니다.\n\n# 정적 분석\n\nJavaScript 애플리케이션의 경우 ESLint 라이브러리를 설치하여 코드 스타일을 쉽게 강제하고 응용 프로그램을 개발할 때 동일한 규칙을 따를 수 있습니다:\n\nESLint는 코드 품질을 향상하고 몇 가지 버그를 감지할 수 있습니다. 보안 취약점을 식별할 수 있습니다. CI(지속적 통합) 중에 ESLint 검사를 포함하여 팀원들이 ESLint에서 소개한 규칙을 준수하도록 강제할 수 있습니다. 나중에 이를 수행할 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테스트\n\n애플리케이션을 변경할 때 이전과 동일하게 작동하는지 확인하기 위해 자동 테스트를 작성하는 것이 좋은 실천법입니다. 단위, 통합, 부하, 엔드-투-엔드 (E2E) 등 다양한 테스트 유형이 있습니다. 애플리케이션의 품질과 성능을 확신하려면 더 많은 테스트가 필요합니다.\n\nJavaScript 애플리케이션을 테스트하기 위한 가장 인기 있는 라이브러리 중 하나는 Jest입니다:\n\nJest를 사용하여 단위 및 통합 테스트를 구현할 것입니다. 이러한 테스트는 나중에 코드를 개선하고 리팩토링하는 데 도움이 되었으며 애플리케이션이 손상되지 않았음을 확인했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 로깅\n\n애플리케이션 로그 스트림은 웹 서비스를 원격으로 디버깅하는 데 도움이 됩니다. 코드 실행 경로를 식별하고 요청 로직을 다양한 상황에서 설명할 수 있습니다. 코드에 로그를 삽입하면 이점을 누릴 수 있습니다.\n\nJavaScript 로그를 수집하는 가장 인기 있는 패키지는 winston입니다:\n\nwinston은 간단하지만 강력한 로깅 라이브러리로, 다양한 전송 방법(콘솔, 파일 등)을 사용하여 로그를 수집하는 데 도움을 줍니다. 로그 형식(간단한 텍스트, JSON 등)도 변경할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 메트릭\n\n메트릭을 통해 응용 프로그램의 상태를 모니터링할 수 있어요. 들어오는 요청의 수, 평균 요청 실행 시간, 5XX 응답의 수 등을 확인할 수 있습니다. 메트릭을 통해 어떠한 문제가 발생할 경우 이메일, 알림 등을 통해 알림을 받을 수 있는 다양한 모니터를 설정할 수 있어요.\n\n제 응용 프로그램에서는 express-prom-bundle이라는 표준 웹 응용 프로그램 메트릭을 수집하는 Prometheus 미들웨어를 설치할 예정이에요.\n\n다음 섹션에서 Prometheus에 대해 더 자세히 알아볼 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 모니터링 스택\n\n로그 스트림 및 메트릭은 나중에 모니터링하거나 시각화하는 데 사용할 수 있도록 일부 데이터베이스에 수집되어야 합니다.\n\n로그 및 메트릭을 수집하고 시각화하기 위해 다음 스택을 사용할 것입니다:\n\n- Prometheus — 메트릭을 수집하기 위해 풀 모델을 사용하는 오픈 소스 모니터링 경보 툴킷;\n- Promtail — 로그를 포함하고 전송하는 에이전트;\n- Loki — 로그 집계 시스템;\n- Grafana — 관측 가능성 시스템.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 로컬 인프라스트럭처\n\n로컬에서 애플리케이션을 개발하고 테스트하기 위해 필요한 로컬 스택을 만들기 위해 도커를 사용할 거예요.\n\n도커를 사용하면 스테이징 및 프로덕션 환경에서 사용될 것과 유사한 로컬 환경을 시작할 수 있어요. 로컬 컴퓨터에 많은 도구를 설치할 필요가 없어요. 대신 필요한 스택을 시작하기 위해 몇 가지 명령을 실행할 수 있어요.\n\n도커 컴포즈를 사용하면 단일 compose.yml 파일로 모든 인프라스트럭처를 정의하고 단일 명령으로 시작할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n도커 컴포즈 업 -d\r\n```\n\n# 지속적 통합\n\n커밋이 무엇인가를 망가뜨리지 않았는지 확인하기 위해, 지속적 통합(CI)가 필요합니다.\n\n이를 위해, 저는 GitHub Actions를 사용할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitHub 계정에는 무료 티어가 있어서 애플리케이션 코드를 확인하기 위해 간단한 빌드를 실행할 수 있어요.\n\n# 애플리케이션 개발\n\n애플리케이션 구조를 시작했고 적절한 프로젝트 스타일을 따르는 데 도움이 된 훌륭한 저장소를 찾았어요:\n\n이 저장소에서 코드 일부(예: 유효성 검사 미들웨어)를 빌려왔기 때문에 여러분이 확인하도록 추천드려요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나중에 저장소 링크를 공유할 건데, 그 전에 재미있는 애플리케이션 부분을 보여주고 싶어요.\n\n나는 mongoose를 사용해서 애플리케이션을 MongoDB와 통합했어요. 먼저, 모델의 스키마를 정의했어요:\n\n```js\nconst mongoose = require('mongoose');\nconst { Schema } = mongoose;\nconst TaskSchema = new Schema(\n  {\n    name: {\n      type: String,\n      required: true,\n    },\n    description: {\n      type: String,\n      required: false,\n    },\n    status: {\n      type: String,\n      enum: ['new', 'active', 'completed', 'cancelled'],\n      default: 'new',\n    },\n    createdAt: {\n      type: Date,\n      default: Date.now,\n    },\n    updatedAt: Date,\n  },\n  { optimisticConcurrency: true },\n);\nmodule.exports = mongoose.model('task', TaskSchema);\n```\n\n이 객체를 사용하여 모델을 유효성 검사하고 코드에서 다양한 MongoDB 작업을 수행할 수 있어요. 이는 작업 업데이트의 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nasync function updateTaskById(id, { name, description, status }) {\n  if (!name \u0026\u0026 !description \u0026\u0026 !status) {\n    return { error: '적어도 하나의 업데이트가 필요합니다', code: AT_LEAST_ONE_UPDATE_REQUIRED_CODE };\n  }\n\nif (status \u0026\u0026 !(status in availableUpdates)) {\n    return { error: '잘못된 상태입니다', code: INVALID_STATUS_CODE };\n  }\n  for (let retry = 0; retry \u003c 3; retry += 1) {\n    // eslint-disable-next-line no-await-in-loop\n    const task = await Task.findById(id);\n    if (!task) {\n      return { error: '작업을 찾을 수 없습니다', code: INVALID_STATUS_TRANSITION_CODE };\n    }\n    if (status) {\n      const allowedStatuses = availableUpdates[task.status];\n      if (!allowedStatuses.includes(status)) {\n        return {\n          error: `'${task.status}'에서 '${status}'(으)로 업데이트할 수 없습니다`,\n          code: TASK_NOT_FOUND_CODE,\n        };\n      }\n    }\n    task.status = status ?? task.status;\n    task.name = name ?? task.name;\n    task.description = description ?? task.description;\n    task.updatedAt = Date.now();\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      await task.save();\n    } catch (error) {\n      logger.warn('저장 중 오류 발생', { error });\n      if (error.name === 'VersionError') {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n    }\n    return task;\n  }\n  return { error: '병행성 오류', code: CONCURRENCY_ERROR_CODE };\n}\n```\n\n가장 흥미로운 부분은 업데이트 후 모델을 저장하는 부분입니다. 격렬한 충돌 문제에 대처하기 위해 낙관적 락을 사용하고 있어요.\n\n두 개의 동시 요청에서 동일한 작업을 완료하고 취소하려고 하는 상황을 상상해보세요. 두 요청이 모두 상태가 '활성'인 작업을 받고 모델을 저장할 때 충돌이 발생할 수 있어요. 첫 번째 작업의 상태가 '완료'로 변경되고 그런 다음 '취소'로 변경될 수 있습니다(또는 그 반대로). 이는 '완료'-'취소' 및 '취소'-'완료' 전이가 허용되지 않기 때문에 잘못된 동작입니다.\n\nMongoose는 낙관적 락으로 이 문제에 대한 해결책을 구현했어요. 낙관적 락은 데이터베이스에서 동시 요청을 처리하는 데 사용되는 전략입니다. 각 문서에는 추가적인 버전 속성이 있어요. 트랜잭션이 모델을 저장/업데이트하려고 할 때 버전을 확인합니다. 버전이 get 쿼리를 수행할 때 받은 버전과 다른 경우, 이미 누군가 문서를 동시에 업데이트했을 수 있어요. 트랜잭션이 중단됩니다(위의 코드에서는 오류가 발생합니다).\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문서 예시:\n\n```js\n{\n  \"_id\": {\n    \"$oid\": \"654e03210948a61665b7c889\"\n  },\n  \"name\": \"damnatio\",\n  \"description\": \"Ciminatio totus spiritus suffoco damnatio blanditiis.\",\n  \"status\": \"completed\",\n  \"createdAt\": {\n    \"$date\": \"2023-11-10T10:17:05.039Z\"\n  },\n  \"__v\": 2,\n  \"updatedAt\": {\n    \"$date\": \"2023-11-10T10:17:05.064Z\"\n  }\n}\n```\n\n위의 문서는 속성 __v에 버전을 저장합니다.\n\n다음 레벨은 컨트롤러입니다. 컨트롤러 예시는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst updateTaskById = catchAsync(async (req, res) =\u003e {\n  const result = await taskService.updateTaskById(req.params.id, req.body);\n  if (result.error) {\n    switch (result.code) {\n      case taskService.errorCodes.AT_LEAST_ONE_UPDATE_REQUIRED_CODE:\n        res.status(400).json({ success: false, message: '적어도 하나의 업데이트가 필요합니다' });\n        return;\n      case taskService.errorCodes.INVALID_STATUS_CODE:\n        res.status(400).json({ success: false, message: '유효하지 않은 상태' });\n        return;\n      case taskService.errorCodes.INVALID_STATUS_TRANSITION_CODE:\n        res.status(404).json({ success: false, message: '작업을 찾을 수 없음' });\n        return;\n      case taskService.errorCodes.TASK_NOT_FOUND_CODE:\n        res.status(400).json({ success: false, message: result.error });\n        return;\n      case taskService.errorCodes.CONCURRENCY_ERROR_CODE:\n        res.status(500).json({ success: false, message: '동시성 오류' });\n        return;\n      default:\n        res.status(500).json({ success: false, message: '내부 서버 오류' });\n        return;\n    }\n  }\n\nres.status(200).json({\n    success: true,\n    task: toDto(result),\n  });\n});\n```\n\n이 코드는 애플리케이션 비즈니스 로직을 실행하고 HTTP 응답을 반환합니다. 컨트롤러는 routes 모듈에 등록됩니다:\n\n```js\nconst { Router } = require('express');\nconst taskController = require('../../../controllers/task');\nconst taskValidation = require('../../../validation/task');\nconst validate = require('../../../middlewares/validate');\n\nconst router = Router();\nrouter.get('/:id', validate(taskValidation.getTaskById), taskController.getTaskById);\nrouter.put('/', validate(taskValidation.createTask), taskController.createTask);\nrouter.post('/:id', validate(taskValidation.updateTaskById), taskController.updateTaskById);\nmodule.exports = router;\n\n/**\n * @swagger\n * tags:\n *  name: Tasks\n *  description: 작업 관리 및 검색\n * /v1/tasks/{id}:\n *  get:\n *   summary: ID로 작업 가져오기\n *   tags: [Tasks]\n *   description: ID로 작업 가져오기\n *   parameters:\n *    - in: path\n *      name: id\n *      schema:\n *       type: string\n *       required: true\n *       description: 작업 ID\n *       example: 5f0a3d9a3e06e52f3c7a6d5c\n *   responses:\n *    200:\n *     description: 작업 검색됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    404:\n *     description: 작업을 찾을 수 없음\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    500:\n *     description: 내부 서버 오류\n *  post:\n *   summary: ID로 작업 업데이트\n *   tags: [Tasks]\n *   description: ID로 작업 업데이트\n *   parameters:\n *    - in: path\n *      name: id\n *      schema:\n *       type: string\n *       required: true\n *       description: 작업 ID\n *       example: 5f0a3d9a3e06e52f3c7a6d5c\n *   requestBody:\n *    required: true\n *    content:\n *     application/json:\n *      schema:\n *       $ref: '#/components/schemas/UpdateTask'\n *   responses:\n *    200:\n *     description: 작업 업데이트됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *     404:\n *      description: 작업을 찾을 수 없음\n *      content:\n *       application/json:\n *        schema:\n *         $ref: '#/components/schemas/TaskResult'\n *     500:\n *      description: 내부 서버 오류\n * /v1/tasks:\n *  put:\n *   summary: 작업 생성\n *   tags: [Tasks]\n *   description: 작업 생성\n *   requestBody:\n *    required: true\n *    content:\n *     application/json:\n *      schema:\n *       $ref: '#/components/schemas/CreateTask'\n *   responses:\n *    201:\n *     description: 작업 생성됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    500:\n *     description: 내부 서버 오류\n */\n```\n\n맨 아래에서는 Swagger 미들웨어가 사용하는 OpenAPI 사양이 API 문서 페이지를 생성하는 데 사용됨을 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 경로 등록은 두 개의 핸들러를 사용합니다: 유효성 검사기와 컨트롤러 메서드 자체입니다. 유효성 검사기는 서로 다른 모델에 등록된 스키마를 유효성 검사합니다. 유효성 검사기 핸들러:\n\n```js\nconst Joi = require('joi');\nconst pick = require('../utils/pick');\n\nfunction validate(schema) {\n  return (req, res, next) =\u003e {\n    const validSchema = pick(schema, ['params', 'query', 'body']);\n    const object = pick(req, Object.keys(validSchema));\n    const { value, error } = Joi.compile(validSchema)\n      .prefs({ errors: { label: 'key' }, abortEarly: false })\n      .validate(object);\n    if (error) {\n      const errorMessage = error.details.map((details) =\u003e details.message).join(', ');\n      res.status(400).json({ success: false, message: errorMessage });\n      return;\n    }\n    Object.assign(req, value);\n    next();\n  };\n}\nmodule.exports = validate;\n```\n\n또한 업데이트 요청 유효성 검사 스키마가 있습니다:\n\n```js\nconst updateTaskById = {\n  params: Joi.object().keys({\n    id: objectId.required(),\n  }),\n  body: Joi.object().keys({\n    name: Joi.string().optional(),\n    description: Joi.string().optional(),\n    status: Joi.string().valid('new', 'active', 'completed', 'cancelled').optional(),\n  }),\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n업데이트 메서드에 대해 말씀드리겠습니다. 저는 통합 테스트만 구현했습니다. 통합 테스트는 모든 테스트가 실행되기 전과 후에 서버를 시작하고 중지합니다. \n\n```js\nconst path = require('path');\nconst app = require('../../src/app');\nconst db = require('../../src/db');\nconst { createConfig } = require('../../src/config/config');\nconst logger = require('../../src/config/logger');\nconst setupServer = () =\u003e {\n  let server;\n  const configPath = path.join(__dirname, '../../configs/tests.env');\n  const config = createConfig(configPath);\n  beforeAll(async () =\u003e {\n    logger.init(config);\n    await db.init(config);\n    await new Promise((resolve) =\u003e {\n      server = app.listen(config.port, () =\u003e {\n        resolve();\n      });\n    });\n  });\n  afterAll(async () =\u003e {\n    await new Promise((resolve) =\u003e {\n      server.close(() =\u003e {\n        resolve();\n      });\n    });\n    await db.destroy();\n    logger.destroy();\n  });\n};\nmodule.exports = {\n  setupServer,\n};\n```\n\n그리고 PUT 요청(태스크 생성)과 POST 요청(태스크 업데이트)을 수행하는 테스트가 있습니다:\n\n```js\ndescribe('태스크 생성 및 업데이트', () =\u003e {\n      const data = [\n        {\n          name: '상태만 업데이트',\n          taskName: '태스크 1',\n          description: '태스크 1 설명',\n          newStatus: '활성',\n        },\n        {\n          name: '영어 전체 업데이트',\n          taskName: '태스크 1',\n          description: '태스크 1 설명',\n          newTaskName: '태스크 1 새로운',\n          newDescription: '태스크 1 새로운 설명',\n          newStatus: '활성',\n        },\n        // 이하 생략\n      ];\n\ndata.forEach(({\n        name, taskName, description, newTaskName, newDescription, newStatus,\n      }) =\u003e {\n        it(name, async () =\u003e {\n          let response = await fetch(baseUrl, {\n            method: 'put',\n            body: JSON.stringify({\n              name: taskName,\n              description,\n            }),\n            headers: { 'Content-Type': 'application/json' },\n          });\n          expect(response.status).toEqual(201);\n          const result = await response.json();\n          // 여기서부터 이하는 생략\n        });\n      });\n    });\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도커 이미지를 생성하려면 간단한 Dockerfile을 정의했습니다:\n\n```js\nFROM node:20-alpine\nWORKDIR /app\nCOPY package.json yarn.lock ./\nRUN yarn install --frozen-lockfile\nCOPY src /app/src\nCMD [\"node\", \"./src/index.js\"]\n```\n\n어플리케이션과 인프라를 시작하는 데 사용하는 compose.yml 정의입니다:\n\n```js\nversion: '3.9'\nservices:\n    app:\n        build: .\n        ports:\n            - '8081:80'\n        depends_on:\n            - mongo\n        volumes:\n            - ./configs/docker.env:/app/configs/.env\n            - logs:/app/logs:rw\n    mongo:\n        image: mongo:5\n        restart: always\n        ports:\n            - 27017:27017\n        volumes:\n            - mongodata:/data/db\n        healthcheck:\n            test: echo 'db.runCommand(\"ping\").ok' | mongo localhost:27017/test --quiet\n            interval: 10s\n            timeout: 2s\n            retries: 5\n            start_period: 5s\n    loki:\n        image: grafana/loki:2.9.0\n        expose:\n            - 3100\n        command: -config.file=/etc/loki/local-config.yaml\n    promtail:\n        image: grafana/promtail:2.9.0\n        volumes:\n            - logs:/var/log:rw\n            - ./infrastructure/promtail.yml:/etc/promtail/config.yml\n        command: -config.file=/etc/promtail/config.yml\n    prometheus:\n        image: prom/prometheus:latest\n        volumes:\n            - ./infrastructure/prometheus.yml:/etc/prometheus/prometheus.yml\n        command:\n            - '--config.file=/etc/prometheus/prometheus.yml'\n        expose:\n            - 9090\n    grafana:\n        image: grafana/grafana:latest\n        volumes:\n            - grafanadata:/var/lib/grafana\n        environment:\n            - GF_PATHS_PROVISIONING=/etc/grafana/provisioning\n            - GF_AUTH_ANONYMOUS_ENABLED=true\n            - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin\n        ports:\n            - 3000:3000\nvolumes:\n    mongodata:\n    grafanadata:\n    logs:\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모두 Git push가 발생할 때마다 GitHub Actions CI가 빌드를 실행합니다. CI 중에는 종속성 설치, 린터 실행 및 모든 테스트 실행을 진행하고 있어요:\n\n```js\nname: App CI\non:\n  push:\n    branches:\n      - \"*\"\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: 20\n          cache: \"yarn\"\n      - run: yarn install --frozen-lockfile\n      - run: yarn run lint\n      - run: docker-compose up -d mongo\n      - run: yarn test -- --verbose --coverage\n      - run: docker-compose build\n      - run: docker-compose logs\n        if: always()\n      - run: docker-compose down --volumes\n        if: always()\n```\n\n# 결론\n\nNode.js는 강력한 기술입니다. 더 중요한 것은 Node.js 커뮤니티가 매우 크다는 것이에요. 새로운 웹 서비스를 개발할 때마다 다른 스택을 사용할 수 있어요. 하지만 저는 이 방법을 추천하지 않아요; 만일 능숙한 Node.js 웹 개발자가 되고 싶다면 먼저 특정 기술의 기능을 익히고, 그런 다음에 다른 스택을 사용해보는 것이 좋아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 게시물에서 웹 애플리케이션을 구축하는 데 사용한 스택은 Node.js 웹 서비스를 구축하는 데 가장 인기가 많습니다. 구현중인 다양한 기능에 도움이되는 많은 문서와 라이브러리가 있습니다.\n\nNode.js로 이전에 설정한 모든 비기능 요구 사항을 쉽게 달성할 수 있습니다. Kubernetes를 사용하여 응용 프로그램 도커 이미지를 작성하고 호스팅할 수 있습니다. Kubernetes는 배포 정의를 변경하여 응용 프로그램을 빠르게 확장하거나 축소하는 데 도움을줍니다. 또한 Kubernetes는 들어오는 트래픽에 따라 응용 프로그램을 확장할 수 있습니다. 또한 MongoDB는 필요에 따라 확장할 수 있도록 설계되어 있어서 트래픽 증가가 문제가 되지 않습니다.\n\nGoogle의 V8 Node.js 엔진을 통해 더 나은 응용 프로그램 성능을 달성할 수 있습니다. 소스 코드가 기계 코드로 번역되는 속도는 인상적입니다!\n\nNode.js를 사용하면 내결함성 있는 응용 프로그램을 구축하는 방법에 대한 다양한 인터넷 기사를 찾을 수 있습니다. 최선의 방법을 따라주세요! 또한 응용 프로그램 코드에서는 예기치 않은 연결 실패(네트워크 문제 또는 MongoDB 장애 등) 후 MongoDB 연결을 복원하는 데 시간을 소비했습니다. 이를 확인하고 응용 프로그램에 적용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJest를 사용하면 애플리케이션을 위한 다양한 테스트를 작성하고 100%의 테스트 커버리지를 달성할 수 있어요. 몇 가지 까다로운 시나리오도 Jest를 사용하여 에뮬레이션할 수 있어요.\n\n즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png"},"coverImage":"/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png","tag":["Tech"],"readingTime":21},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WritingAMicroserviceUsingNodejs_0.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e자바스크립트는 프로그래밍 언어 평가에서 주요 위치를 유지하고 있습니다. 자바스크립트에는 브라우저와 Node.js 두 가지 구현이 있습니다. 후자는 웹 서비스 개발에 널리 사용됩니다.\u003c/p\u003e\n\u003cp\u003eIT 경력을 시작한 지 약 여덟 년 전에 자바스크립트를 배우기 시작했고, 몇 년 전에 David Flanagan의 훌륭한 책 \"JavaScript: The Definitive Guide\"를 읽었습니다.\u003c/p\u003e\n\u003cp\u003e이 책은 많은 질문에 답하고 흥미로운 자바스크립트 레시피를 보여줬는데, 이를 내 업무에 적용하고 있습니다. 그러나 더 중요한 것은, Node.js로 웹 서비스 개발에 초점을 맞추게 됐습니다 (이전에는 JS를 프론트엔드 개발에만 사용). 이 책을 새로운 자바스크립트 개발자뿐만 아니라 경험있는 개발자에게도 추천합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 게시물에서는 Node.js를 사용하여 마이크로서비스를 구축하는 방법을 소개하려고 합니다. 웹 개발 경험을 기반으로 인기 있는 Node.js 스택을 활용하여 확장 가능하고 견고하며 신뢰성 있고 성능이 우수한 솔루션을 만들어 보겠습니다.\u003c/p\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e이 글에서는 작업 관리 웹 서비스 예시에 마이크로서비스를 구축하는 방법을 보여드리려고 합니다. 다음 API를 제공할 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이름과 설명으로 작업 생성;\u003c/li\u003e\n\u003cli\u003e식별자로 작업 가져오기;\u003c/li\u003e\n\u003cli\u003e작업 상태/이름/설명 업데이트.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eNode.js로 웹 애플리케이션을 빌드할 때 얼마나 강력한지 보여주는 간단한 API입니다. 개발 프로세스가 빠르고 쉽습니다.\u003c/p\u003e\n\u003cp\u003e몇 가지 애플리케이션 요구 사항:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작업은 상태 'new'로 생성되어야 합니다.\u003c/li\u003e\n\u003cli\u003e사용 가능한 상태 전이: 'new'에서 'active'로, 'new'에서 'canceled'로, 'active'에서 'completed'로, 'active'에서 'canceled'로.\u003c/li\u003e\n\u003cli\u003e경쟁 상태를 피하십시오 (자세한 내용은 나중에).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e주요 비기능 요구 사항은:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e확장성 — 마이크로서비스는 증가하는 요청 양을 처리할 수 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e탄력성 — 마이크로서비스는 즉각 처리할 수 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e성능 — 마이크로서비스는 빠르게 응답하여 더 나은 사용자 경험을 제공해야 합니다.\u003c/li\u003e\n\u003cli\u003e복원력 — 마이크로서비스는 장애에 대해 허용하고 회복할 수 있어야 하므로 올바르게 기능을 계속 수행할 수 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e모니터링 — 마이크로서비스는 건강을 모니터링하는 방법을 제공해야 합니다.\u003c/li\u003e\n\u003cli\u003e관찰가능성 — 마이크로서비스는 로그 스트림 및 메트릭을 생성하여 유지할 수 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e테스트 용이성 — 마이크로서비스는 쉽게 테스트할 수 있어야 합니다.\u003c/li\u003e\n\u003cli\u003e상태를 유지하지 않음 — 마이크로서비스는 클라이언트 컨텍스트를 저장하지 않아야 하며 대신 상태는 데이터베이스에 저장되어야 합니다.\u003c/li\u003e\n\u003cli\u003e배포 용이성 — 마이크로서비스는 쉽게 배포 및 업데이트할 수 있어야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNode.js로 웹 애플리케이션을 개발할 때 모두 가능합니다. 다음 단계에서 이러한 요구사항을 어떻게 달성할지 논의해보겠습니다.\u003c/p\u003e\n\u003ch1\u003e스택\u003c/h1\u003e\n\u003cp\u003e웹 서비스를 구축하기 위해 사용할 기술 스택을 처음부터 선택해야 합니다. 물론, 가장 먼저 고려해야 할 질문은 프로그래밍 언어입니다. 이 마이크로서비스에서는 Node.js를 사용할 것이지만, 그럼에도 불구하고, 웹 서비스 개발에 사용하는 데 Node.js의 몇 가지 이점을 소개해 드리겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e자바스크립트는 이미 프론트엔드 개발의 주요 언어이며, 백엔드 개발에도 사용하는 것이 합리적입니다. 이렇게 하면 동일한 개발자가 풀 스택 애플리케이션을 개발할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e자바스크립트 커뮤니티는 엄청나게 큽니다. 개발 중 발생할 수 있는 모든 질문에 대한 답변을 찾을 수 있습니다. 또한 많은 라이브러리가 커뮤니티에 의해 개발되고 유지보수됩니다. 유사한 문제를 해결하는 다른 서드파티를 찾을 수 있으며, 각각 고유한 기능을 가집니다.\u003c/li\u003e\n\u003cli\u003e노드.제이에스는 구글의 V8 엔진을 사용하여 자바스크립트를 해석하며, 이를 빠르게 기계 코드로 컴파일합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그리고 이런식으로 계속됩니다! 하지만 가장 중요한 질문은 아닙니다.\u003c/p\u003e\n\u003ch2\u003e데이터베이스\u003c/h2\u003e\n\u003cp\u003e웹 요청간 데이터를 유지하고 싶습니다. 확장 가능한 상태 유지 웹 서비스를 개발하는 것은 복잡한 작업입니다. 그래서 웹 애플리케이션을 상태가 없는 상태로 유지하고 개별적으로 상태를 외부 데이터베이스에 유지하는 것이 권장됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 서비스를 개발하기 위해 인기 있는 문서 지향 데이터베이스 MongoDB를 사용할 것입니다.\u003c/p\u003e\n\u003cp\u003eMongoDB는 SQL 데이터베이스보다 몇 가지 이점을 제공하는 NoSQL 데이터베이스입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e스키마 무료 — MongoDB 컬렉션 (SQL 테이블에 해당하는)은 다른 스키마를 가진 문서를 보유할 수 있습니다. 문서를 컬렉션에 저장하기 전에 구조를 먼저 정의할 필요가 없습니다;\u003c/li\u003e\n\u003cli\u003e확장성 — MongoDB는 여러 서버에 걸쳐 확장 가능하게 설계되었습니다;\u003c/li\u003e\n\u003cli\u003e성능 — MongoDB는 읽기 중심 작업에 최적화되어 있으며 대량의 데이터를 저장할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNode.js 웹 서비스를 개발할 때 인기 있는 선택 사항입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e웹 프레임워크\u003c/h1\u003e\n\u003cp\u003e웹 프레임워크는 웹 애플리케이션을 구축하는 데 필요합니다. 웹 서비스 개발 시 필요한 많은 일상적인 작업을 처리합니다. 예를 들면 라우팅, 보안, 바인딩 등이 있습니다.\u003c/p\u003e\n\u003cp\u003eNode.js 웹 프레임워크에는 다양한 옵션이 있습니다. 그중에서 가장 인기 있는 것은 express입니다:\u003c/p\u003e\n\u003cp\u003eexpress의 가장 큰 장점은 사용하기 간편하며 웹 서버를 시작하는 데 필요한 코드가 최소량으로만 필요하다는 것입니다. express로 작성된 'Hello, World!' 예제가 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e express = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'express'\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e port = \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e;\n\napp.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  res.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Hello World!'\u003c/span\u003e)\n})\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(port, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Example app listening on port \u003cspan class=\"hljs-subst\"\u003e${port}\u003c/span\u003e`\u003c/span\u003e)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한, Express는 많은 커뮤니티가 있는데, 서버 기능을 확장하는 다양한 라이브러리(일반적으로 미들웨어로 개발됨)들을 찾을 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e유효성 검사\u003c/h1\u003e\n\u003cp\u003e유효성 검사는 웹 애플리케이션의 중요한 부분입니다. 사용자가 API를 어떻게 사용할지 알 수 없기 때문에, 침입자가 잘못된 입력을 제공하여 응용프로그램을 손상시킬 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e웹 요청에서 제공된 매개변수(경로, 본문 등)를 확인하고 올바른지 확인하기 위해 joi를 사용할 거에요:\u003c/p\u003e\n\u003cp\u003ejoi는 다양한 모델을 확인하는 데 사용되는 강력한 라이브러리에요. 나중에 개발할 요청 중 하나를 확인하는 예시가 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e createTask = {\n  \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJoi\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eobject\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJoi\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e().required(),\n    \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJoi\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eoptional\u003c/span\u003e(),\n  }),\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 객체가 두 개의 문자열을 가진 중첩된 body 객체를 갖는지 확인하며, 이 문자열은 필수인 name과 선택적인 description이에요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e하지만 그것만이 아닙니다. 컬렉션을 삭제할 수 있는 위험한 MongoDB 인젝션을 제공하는 경우가 여전히 있습니다. 웹 요청을 정리하기 위해 express-mongo-sanitize 패키지를 사용할 것입니다:\u003c/p\u003e\n\u003ch1\u003e설정\u003c/h1\u003e\n\u003cp\u003e동일한 빌드 아티팩트를 다른 환경에서 실행할 수 있도록 응용 프로그램을 구성할 필요가 있습니다. 이를 위해 환경 변수를 통해 구성을 제공하는 것이 표준 접근 방식입니다.\u003c/p\u003e\n\u003cp\u003e응용 프로그램을 시작하기 전에 로컬 머신에서 환경 변수를 수동으로 설정하고 싶지 않을 것입니다. 이 문제에 대한 인기 있는 Node.js 솔루션은 dotenv 라이브러리에 구현되어 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 라이브러리는 .env(파일 이름을 변경할 수 있음)이라는 파일에서 내용을 로드하고 이 파일의 내용을 환경 변수로 설정합니다.\u003c/p\u003e\n\u003ch1\u003e정적 분석\u003c/h1\u003e\n\u003cp\u003eJavaScript 애플리케이션의 경우 ESLint 라이브러리를 설치하여 코드 스타일을 쉽게 강제하고 응용 프로그램을 개발할 때 동일한 규칙을 따를 수 있습니다:\u003c/p\u003e\n\u003cp\u003eESLint는 코드 품질을 향상하고 몇 가지 버그를 감지할 수 있습니다. 보안 취약점을 식별할 수 있습니다. CI(지속적 통합) 중에 ESLint 검사를 포함하여 팀원들이 ESLint에서 소개한 규칙을 준수하도록 강제할 수 있습니다. 나중에 이를 수행할 예정입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e테스트\u003c/h1\u003e\n\u003cp\u003e애플리케이션을 변경할 때 이전과 동일하게 작동하는지 확인하기 위해 자동 테스트를 작성하는 것이 좋은 실천법입니다. 단위, 통합, 부하, 엔드-투-엔드 (E2E) 등 다양한 테스트 유형이 있습니다. 애플리케이션의 품질과 성능을 확신하려면 더 많은 테스트가 필요합니다.\u003c/p\u003e\n\u003cp\u003eJavaScript 애플리케이션을 테스트하기 위한 가장 인기 있는 라이브러리 중 하나는 Jest입니다:\u003c/p\u003e\n\u003cp\u003eJest를 사용하여 단위 및 통합 테스트를 구현할 것입니다. 이러한 테스트는 나중에 코드를 개선하고 리팩토링하는 데 도움이 되었으며 애플리케이션이 손상되지 않았음을 확인했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e로깅\u003c/h1\u003e\n\u003cp\u003e애플리케이션 로그 스트림은 웹 서비스를 원격으로 디버깅하는 데 도움이 됩니다. 코드 실행 경로를 식별하고 요청 로직을 다양한 상황에서 설명할 수 있습니다. 코드에 로그를 삽입하면 이점을 누릴 수 있습니다.\u003c/p\u003e\n\u003cp\u003eJavaScript 로그를 수집하는 가장 인기 있는 패키지는 winston입니다:\u003c/p\u003e\n\u003cp\u003ewinston은 간단하지만 강력한 로깅 라이브러리로, 다양한 전송 방법(콘솔, 파일 등)을 사용하여 로그를 수집하는 데 도움을 줍니다. 로그 형식(간단한 텍스트, JSON 등)도 변경할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e메트릭\u003c/h1\u003e\n\u003cp\u003e메트릭을 통해 응용 프로그램의 상태를 모니터링할 수 있어요. 들어오는 요청의 수, 평균 요청 실행 시간, 5XX 응답의 수 등을 확인할 수 있습니다. 메트릭을 통해 어떠한 문제가 발생할 경우 이메일, 알림 등을 통해 알림을 받을 수 있는 다양한 모니터를 설정할 수 있어요.\u003c/p\u003e\n\u003cp\u003e제 응용 프로그램에서는 express-prom-bundle이라는 표준 웹 응용 프로그램 메트릭을 수집하는 Prometheus 미들웨어를 설치할 예정이에요.\u003c/p\u003e\n\u003cp\u003e다음 섹션에서 Prometheus에 대해 더 자세히 알아볼 거예요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e모니터링 스택\u003c/h1\u003e\n\u003cp\u003e로그 스트림 및 메트릭은 나중에 모니터링하거나 시각화하는 데 사용할 수 있도록 일부 데이터베이스에 수집되어야 합니다.\u003c/p\u003e\n\u003cp\u003e로그 및 메트릭을 수집하고 시각화하기 위해 다음 스택을 사용할 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePrometheus — 메트릭을 수집하기 위해 풀 모델을 사용하는 오픈 소스 모니터링 경보 툴킷;\u003c/li\u003e\n\u003cli\u003ePromtail — 로그를 포함하고 전송하는 에이전트;\u003c/li\u003e\n\u003cli\u003eLoki — 로그 집계 시스템;\u003c/li\u003e\n\u003cli\u003eGrafana — 관측 가능성 시스템.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e로컬 인프라스트럭처\u003c/h1\u003e\n\u003cp\u003e로컬에서 애플리케이션을 개발하고 테스트하기 위해 필요한 로컬 스택을 만들기 위해 도커를 사용할 거예요.\u003c/p\u003e\n\u003cp\u003e도커를 사용하면 스테이징 및 프로덕션 환경에서 사용될 것과 유사한 로컬 환경을 시작할 수 있어요. 로컬 컴퓨터에 많은 도구를 설치할 필요가 없어요. 대신 필요한 스택을 시작하기 위해 몇 가지 명령을 실행할 수 있어요.\u003c/p\u003e\n\u003cp\u003e도커 컴포즈를 사용하면 단일 compose.yml 파일로 모든 인프라스트럭처를 정의하고 단일 명령으로 시작할 수 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e도커 컴포즈 업 -d\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e지속적 통합\u003c/h1\u003e\n\u003cp\u003e커밋이 무엇인가를 망가뜨리지 않았는지 확인하기 위해, 지속적 통합(CI)가 필요합니다.\u003c/p\u003e\n\u003cp\u003e이를 위해, 저는 GitHub Actions를 사용할 것입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eGitHub 계정에는 무료 티어가 있어서 애플리케이션 코드를 확인하기 위해 간단한 빌드를 실행할 수 있어요.\u003c/p\u003e\n\u003ch1\u003e애플리케이션 개발\u003c/h1\u003e\n\u003cp\u003e애플리케이션 구조를 시작했고 적절한 프로젝트 스타일을 따르는 데 도움이 된 훌륭한 저장소를 찾았어요:\u003c/p\u003e\n\u003cp\u003e이 저장소에서 코드 일부(예: 유효성 검사 미들웨어)를 빌려왔기 때문에 여러분이 확인하도록 추천드려요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e나중에 저장소 링크를 공유할 건데, 그 전에 재미있는 애플리케이션 부분을 보여주고 싶어요.\u003c/p\u003e\n\u003cp\u003e나는 mongoose를 사용해서 애플리케이션을 MongoDB와 통합했어요. 먼저, 모델의 스키마를 정의했어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mongoose = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'mongoose'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eSchema\u003c/span\u003e } = mongoose;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaskSchema\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSchema\u003c/span\u003e(\n  {\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003erequired\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    },\n    \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003erequired\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n    },\n    \u003cspan class=\"hljs-attr\"\u003estatus\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eenum\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'new'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'active'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'completed'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'cancelled'\u003c/span\u003e],\n      \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'new'\u003c/span\u003e,\n    },\n    \u003cspan class=\"hljs-attr\"\u003ecreatedAt\u003c/span\u003e: {\n      \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enow\u003c/span\u003e,\n    },\n    \u003cspan class=\"hljs-attr\"\u003eupdatedAt\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e,\n  },\n  { \u003cspan class=\"hljs-attr\"\u003eoptimisticConcurrency\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e },\n);\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = mongoose.\u003cspan class=\"hljs-title function_\"\u003emodel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'task'\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eTaskSchema\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 객체를 사용하여 모델을 유효성 검사하고 코드에서 다양한 MongoDB 작업을 수행할 수 있어요. 이는 작업 업데이트의 예시입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eupdateTaskById\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eid, { name, description, status }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!name \u0026#x26;\u0026#x26; !description \u0026#x26;\u0026#x26; !status) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e { \u003cspan class=\"hljs-attr\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'적어도 하나의 업데이트가 필요합니다'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecode\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eAT_LEAST_ONE_UPDATE_REQUIRED_CODE\u003c/span\u003e };\n  }\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (status \u0026#x26;\u0026#x26; !(status \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e availableUpdates)) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e { \u003cspan class=\"hljs-attr\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'잘못된 상태입니다'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecode\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eINVALID_STATUS_CODE\u003c/span\u003e };\n  }\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e retry = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; retry \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e; retry += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// eslint-disable-next-line no-await-in-loop\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e task = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTask\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efindById\u003c/span\u003e(id);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!task) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e { \u003cspan class=\"hljs-attr\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'작업을 찾을 수 없습니다'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecode\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eINVALID_STATUS_TRANSITION_CODE\u003c/span\u003e };\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (status) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e allowedStatuses = availableUpdates[task.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e];\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!allowedStatuses.\u003cspan class=\"hljs-title function_\"\u003eincludes\u003c/span\u003e(status)) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n          \u003cspan class=\"hljs-attr\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`'\u003cspan class=\"hljs-subst\"\u003e${task.status}\u003c/span\u003e'에서 '\u003cspan class=\"hljs-subst\"\u003e${status}\u003c/span\u003e'(으)로 업데이트할 수 없습니다`\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003ecode\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eTASK_NOT_FOUND_CODE\u003c/span\u003e,\n        };\n      }\n    }\n    task.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e = status ?? task.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e;\n    task.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = name ?? task.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e;\n    task.\u003cspan class=\"hljs-property\"\u003edescription\u003c/span\u003e = description ?? task.\u003cspan class=\"hljs-property\"\u003edescription\u003c/span\u003e;\n    task.\u003cspan class=\"hljs-property\"\u003eupdatedAt\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// eslint-disable-next-line no-await-in-loop\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e task.\u003cspan class=\"hljs-title function_\"\u003esave\u003c/span\u003e();\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (error) {\n      logger.\u003cspan class=\"hljs-title function_\"\u003ewarn\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'저장 중 오류 발생'\u003c/span\u003e, { error });\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (error.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'VersionError'\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// eslint-disable-next-line no-continue\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e;\n      }\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e task;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e { \u003cspan class=\"hljs-attr\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'병행성 오류'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ecode\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eCONCURRENCY_ERROR_CODE\u003c/span\u003e };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e가장 흥미로운 부분은 업데이트 후 모델을 저장하는 부분입니다. 격렬한 충돌 문제에 대처하기 위해 낙관적 락을 사용하고 있어요.\u003c/p\u003e\n\u003cp\u003e두 개의 동시 요청에서 동일한 작업을 완료하고 취소하려고 하는 상황을 상상해보세요. 두 요청이 모두 상태가 '활성'인 작업을 받고 모델을 저장할 때 충돌이 발생할 수 있어요. 첫 번째 작업의 상태가 '완료'로 변경되고 그런 다음 '취소'로 변경될 수 있습니다(또는 그 반대로). 이는 '완료'-'취소' 및 '취소'-'완료' 전이가 허용되지 않기 때문에 잘못된 동작입니다.\u003c/p\u003e\n\u003cp\u003eMongoose는 낙관적 락으로 이 문제에 대한 해결책을 구현했어요. 낙관적 락은 데이터베이스에서 동시 요청을 처리하는 데 사용되는 전략입니다. 각 문서에는 추가적인 버전 속성이 있어요. 트랜잭션이 모델을 저장/업데이트하려고 할 때 버전을 확인합니다. 버전이 get 쿼리를 수행할 때 받은 버전과 다른 경우, 이미 누군가 문서를 동시에 업데이트했을 수 있어요. 트랜잭션이 중단됩니다(위의 코드에서는 오류가 발생합니다).\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문서 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\"_id\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"$oid\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"654e03210948a61665b7c889\"\u003c/span\u003e\n  },\n  \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"damnatio\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"description\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Ciminatio totus spiritus suffoco damnatio blanditiis.\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"status\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"completed\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"createdAt\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"$date\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"2023-11-10T10:17:05.039Z\"\u003c/span\u003e\n  },\n  \u003cspan class=\"hljs-string\"\u003e\"__v\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"updatedAt\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"$date\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"2023-11-10T10:17:05.064Z\"\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 문서는 속성 __v에 버전을 저장합니다.\u003c/p\u003e\n\u003cp\u003e다음 레벨은 컨트롤러입니다. 컨트롤러 예시는 다음과 같습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e updateTaskById = \u003cspan class=\"hljs-title function_\"\u003ecatchAsync\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (req, res) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e taskService.\u003cspan class=\"hljs-title function_\"\u003eupdateTaskById\u003c/span\u003e(req.\u003cspan class=\"hljs-property\"\u003eparams\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e, req.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (result.\u003cspan class=\"hljs-property\"\u003eerror\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (result.\u003cspan class=\"hljs-property\"\u003ecode\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e taskService.\u003cspan class=\"hljs-property\"\u003eerrorCodes\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eAT_LEAST_ONE_UPDATE_REQUIRED_CODE\u003c/span\u003e:\n        res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003esuccess\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'적어도 하나의 업데이트가 필요합니다'\u003c/span\u003e });\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e taskService.\u003cspan class=\"hljs-property\"\u003eerrorCodes\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eINVALID_STATUS_CODE\u003c/span\u003e:\n        res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003esuccess\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'유효하지 않은 상태'\u003c/span\u003e });\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e taskService.\u003cspan class=\"hljs-property\"\u003eerrorCodes\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eINVALID_STATUS_TRANSITION_CODE\u003c/span\u003e:\n        res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e404\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003esuccess\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'작업을 찾을 수 없음'\u003c/span\u003e });\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e taskService.\u003cspan class=\"hljs-property\"\u003eerrorCodes\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eTASK_NOT_FOUND_CODE\u003c/span\u003e:\n        res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003esuccess\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: result.\u003cspan class=\"hljs-property\"\u003eerror\u003c/span\u003e });\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e taskService.\u003cspan class=\"hljs-property\"\u003eerrorCodes\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eCONCURRENCY_ERROR_CODE\u003c/span\u003e:\n        res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003esuccess\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'동시성 오류'\u003c/span\u003e });\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n      \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e:\n        res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003esuccess\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'내부 서버 오류'\u003c/span\u003e });\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    }\n  }\n\nres.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003esuccess\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003etask\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003etoDto\u003c/span\u003e(result),\n  });\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 애플리케이션 비즈니스 로직을 실행하고 HTTP 응답을 반환합니다. 컨트롤러는 routes 모듈에 등록됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eRouter\u003c/span\u003e } = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'express'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e taskController = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'../../../controllers/task'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e taskValidation = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'../../../validation/task'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e validate = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'../../../middlewares/validate'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e router = \u003cspan class=\"hljs-title class_\"\u003eRouter\u003c/span\u003e();\nrouter.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/:id'\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003evalidate\u003c/span\u003e(taskValidation.\u003cspan class=\"hljs-property\"\u003egetTaskById\u003c/span\u003e), taskController.\u003cspan class=\"hljs-property\"\u003egetTaskById\u003c/span\u003e);\nrouter.\u003cspan class=\"hljs-title function_\"\u003eput\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003evalidate\u003c/span\u003e(taskValidation.\u003cspan class=\"hljs-property\"\u003ecreateTask\u003c/span\u003e), taskController.\u003cspan class=\"hljs-property\"\u003ecreateTask\u003c/span\u003e);\nrouter.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/:id'\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003evalidate\u003c/span\u003e(taskValidation.\u003cspan class=\"hljs-property\"\u003eupdateTaskById\u003c/span\u003e), taskController.\u003cspan class=\"hljs-property\"\u003eupdateTaskById\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = router;\n\n\u003cspan class=\"hljs-comment\"\u003e/**\n * \u003cspan class=\"hljs-doctag\"\u003e@swagger\u003c/span\u003e\n * tags:\n *  name: Tasks\n *  description: 작업 관리 및 검색\n * /v1/tasks/{id}:\n *  get:\n *   summary: ID로 작업 가져오기\n *   tags: [Tasks]\n *   description: ID로 작업 가져오기\n *   parameters:\n *    - in: path\n *      name: id\n *      schema:\n *       type: string\n *       required: true\n *       description: 작업 ID\n *       example: 5f0a3d9a3e06e52f3c7a6d5c\n *   responses:\n *    200:\n *     description: 작업 검색됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    404:\n *     description: 작업을 찾을 수 없음\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    500:\n *     description: 내부 서버 오류\n *  post:\n *   summary: ID로 작업 업데이트\n *   tags: [Tasks]\n *   description: ID로 작업 업데이트\n *   parameters:\n *    - in: path\n *      name: id\n *      schema:\n *       type: string\n *       required: true\n *       description: 작업 ID\n *       example: 5f0a3d9a3e06e52f3c7a6d5c\n *   requestBody:\n *    required: true\n *    content:\n *     application/json:\n *      schema:\n *       $ref: '#/components/schemas/UpdateTask'\n *   responses:\n *    200:\n *     description: 작업 업데이트됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *     404:\n *      description: 작업을 찾을 수 없음\n *      content:\n *       application/json:\n *        schema:\n *         $ref: '#/components/schemas/TaskResult'\n *     500:\n *      description: 내부 서버 오류\n * /v1/tasks:\n *  put:\n *   summary: 작업 생성\n *   tags: [Tasks]\n *   description: 작업 생성\n *   requestBody:\n *    required: true\n *    content:\n *     application/json:\n *      schema:\n *       $ref: '#/components/schemas/CreateTask'\n *   responses:\n *    201:\n *     description: 작업 생성됨\n *     content:\n *      application/json:\n *       schema:\n *        $ref: '#/components/schemas/TaskResult'\n *    500:\n *     description: 내부 서버 오류\n */\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e맨 아래에서는 Swagger 미들웨어가 사용하는 OpenAPI 사양이 API 문서 페이지를 생성하는 데 사용됨을 볼 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e각 경로 등록은 두 개의 핸들러를 사용합니다: 유효성 검사기와 컨트롤러 메서드 자체입니다. 유효성 검사기는 서로 다른 모델에 등록된 스키마를 유효성 검사합니다. 유효성 검사기 핸들러:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eJoi\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'joi'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pick = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'../utils/pick'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003evalidate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eschema\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res, next\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e validSchema = \u003cspan class=\"hljs-title function_\"\u003epick\u003c/span\u003e(schema, [\u003cspan class=\"hljs-string\"\u003e'params'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'query'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'body'\u003c/span\u003e]);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e object = \u003cspan class=\"hljs-title function_\"\u003epick\u003c/span\u003e(req, \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e(validSchema));\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { value, error } = \u003cspan class=\"hljs-title class_\"\u003eJoi\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecompile\u003c/span\u003e(validSchema)\n      .\u003cspan class=\"hljs-title function_\"\u003eprefs\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003eerrors\u003c/span\u003e: { \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'key'\u003c/span\u003e }, \u003cspan class=\"hljs-attr\"\u003eabortEarly\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e })\n      .\u003cspan class=\"hljs-title function_\"\u003evalidate\u003c/span\u003e(object);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (error) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e errorMessage = error.\u003cspan class=\"hljs-property\"\u003edetails\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edetails\u003c/span\u003e) =\u003e\u003c/span\u003e details.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e', '\u003c/span\u003e);\n      res.\u003cspan class=\"hljs-title function_\"\u003estatus\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e400\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003esuccess\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: errorMessage });\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eassign\u003c/span\u003e(req, value);\n    \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n  };\n}\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = validate;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한 업데이트 요청 유효성 검사 스키마가 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e updateTaskById = {\n  \u003cspan class=\"hljs-attr\"\u003eparams\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJoi\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eobject\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: objectId.required(),\n  }),\n  \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJoi\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eobject\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJoi\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eoptional\u003c/span\u003e(),\n    \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJoi\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eoptional\u003c/span\u003e(),\n    \u003cspan class=\"hljs-attr\"\u003estatus\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJoi\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003evalid\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'new'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'active'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'completed'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'cancelled'\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eoptional\u003c/span\u003e(),\n  }),\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e업데이트 메서드에 대해 말씀드리겠습니다. 저는 통합 테스트만 구현했습니다. 통합 테스트는 모든 테스트가 실행되기 전과 후에 서버를 시작하고 중지합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e path = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'path'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'../../src/app'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e db = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'../../src/db'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { createConfig } = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'../../src/config/config'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e logger = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'../../src/config/logger'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetupServer\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e server;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e configPath = path.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(__dirname, \u003cspan class=\"hljs-string\"\u003e'../../configs/tests.env'\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e config = \u003cspan class=\"hljs-title function_\"\u003ecreateConfig\u003c/span\u003e(configPath);\n  \u003cspan class=\"hljs-title function_\"\u003ebeforeAll\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e {\n    logger.\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(config);\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e db.\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(config);\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      server = app.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(config.\u003cspan class=\"hljs-property\"\u003eport\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e();\n      });\n    });\n  });\n  \u003cspan class=\"hljs-title function_\"\u003eafterAll\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      server.\u003cspan class=\"hljs-title function_\"\u003eclose\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e();\n      });\n    });\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e db.\u003cspan class=\"hljs-title function_\"\u003edestroy\u003c/span\u003e();\n    logger.\u003cspan class=\"hljs-title function_\"\u003edestroy\u003c/span\u003e();\n  });\n};\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  setupServer,\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 PUT 요청(태스크 생성)과 POST 요청(태스크 업데이트)을 수행하는 테스트가 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003edescribe\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'태스크 생성 및 업데이트'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = [\n        {\n          \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'상태만 업데이트'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003etaskName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'태스크 1'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'태스크 1 설명'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003enewStatus\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'활성'\u003c/span\u003e,\n        },\n        {\n          \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'영어 전체 업데이트'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003etaskName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'태스크 1'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'태스크 1 설명'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003enewTaskName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'태스크 1 새로운'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003enewDescription\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'태스크 1 새로운 설명'\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003enewStatus\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'활성'\u003c/span\u003e,\n        },\n        \u003cspan class=\"hljs-comment\"\u003e// 이하 생략\u003c/span\u003e\n      ];\n\ndata.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{\n        name, taskName, description, newTaskName, newDescription, newStatus,\n      }\u003c/span\u003e) =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-title function_\"\u003eit\u003c/span\u003e(name, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e {\n          \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e response = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(baseUrl, {\n            \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'put'\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e({\n              \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: taskName,\n              description,\n            }),\n            \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: { \u003cspan class=\"hljs-string\"\u003e'Content-Type'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e },\n          });\n          \u003cspan class=\"hljs-title function_\"\u003eexpect\u003c/span\u003e(response.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003etoEqual\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e201\u003c/span\u003e);\n          \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n          \u003cspan class=\"hljs-comment\"\u003e// 여기서부터 이하는 생략\u003c/span\u003e\n        });\n      });\n    });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e도커 이미지를 생성하려면 간단한 Dockerfile을 정의했습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003enode\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e-alpine\n\u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /app\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e package.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e yarn.\u003cspan class=\"hljs-property\"\u003elock\u003c/span\u003e ./\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e yarn install --frozen-lockfile\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e src /app/src\n\u003cspan class=\"hljs-variable constant_\"\u003eCMD\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"node\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"./src/index.js\"\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e어플리케이션과 인프라를 시작하는 데 사용하는 compose.yml 정의입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003eversion\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'3.9'\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eservices\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003eapp\u003c/span\u003e:\n        \u003cspan class=\"hljs-attr\"\u003ebuild\u003c/span\u003e: .\n        \u003cspan class=\"hljs-attr\"\u003eports\u003c/span\u003e:\n            - \u003cspan class=\"hljs-string\"\u003e'8081:80'\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003edepends_on\u003c/span\u003e:\n            - mongo\n        \u003cspan class=\"hljs-attr\"\u003evolumes\u003c/span\u003e:\n            - ./configs/docker.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/app/\u003c/span\u003econfigs/.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e\n            - \u003cspan class=\"hljs-attr\"\u003elogs\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/app/\u003c/span\u003e\u003cspan class=\"hljs-attr\"\u003elogs\u003c/span\u003e:rw\n    \u003cspan class=\"hljs-attr\"\u003emongo\u003c/span\u003e:\n        \u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003emongo\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003erestart\u003c/span\u003e: always\n        \u003cspan class=\"hljs-attr\"\u003eports\u003c/span\u003e:\n            - \u003cspan class=\"hljs-number\"\u003e27017\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e27017\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003evolumes\u003c/span\u003e:\n            - \u003cspan class=\"hljs-attr\"\u003emongodata\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/data/\u003c/span\u003edb\n        \u003cspan class=\"hljs-attr\"\u003ehealthcheck\u003c/span\u003e:\n            \u003cspan class=\"hljs-attr\"\u003etest\u003c/span\u003e: echo \u003cspan class=\"hljs-string\"\u003e'db.runCommand(\"ping\").ok'\u003c/span\u003e | mongo \u003cspan class=\"hljs-attr\"\u003elocalhost\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e27017\u003c/span\u003e/test --quiet\n            \u003cspan class=\"hljs-attr\"\u003einterval\u003c/span\u003e: 10s\n            \u003cspan class=\"hljs-attr\"\u003etimeout\u003c/span\u003e: 2s\n            \u003cspan class=\"hljs-attr\"\u003eretries\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003estart_period\u003c/span\u003e: 5s\n    \u003cspan class=\"hljs-attr\"\u003eloki\u003c/span\u003e:\n        \u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e: grafana/\u003cspan class=\"hljs-attr\"\u003eloki\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e2.9\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eexpose\u003c/span\u003e:\n            - \u003cspan class=\"hljs-number\"\u003e3100\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ecommand\u003c/span\u003e: -config.\u003cspan class=\"hljs-property\"\u003efile\u003c/span\u003e=\u003cspan class=\"hljs-regexp\"\u003e/etc/\u003c/span\u003eloki/local-config.\u003cspan class=\"hljs-property\"\u003eyaml\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003epromtail\u003c/span\u003e:\n        \u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e: grafana/\u003cspan class=\"hljs-attr\"\u003epromtail\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e2.9\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003evolumes\u003c/span\u003e:\n            - \u003cspan class=\"hljs-attr\"\u003elogs\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/var/\u003c/span\u003e\u003cspan class=\"hljs-attr\"\u003elog\u003c/span\u003e:rw\n            - ./infrastructure/promtail.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/etc/\u003c/span\u003epromtail/config.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ecommand\u003c/span\u003e: -config.\u003cspan class=\"hljs-property\"\u003efile\u003c/span\u003e=\u003cspan class=\"hljs-regexp\"\u003e/etc/\u003c/span\u003epromtail/config.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eprometheus\u003c/span\u003e:\n        \u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e: prom/\u003cspan class=\"hljs-attr\"\u003eprometheus\u003c/span\u003e:latest\n        \u003cspan class=\"hljs-attr\"\u003evolumes\u003c/span\u003e:\n            - ./infrastructure/prometheus.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/etc/\u003c/span\u003eprometheus/prometheus.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003ecommand\u003c/span\u003e:\n            - \u003cspan class=\"hljs-string\"\u003e'--config.file=/etc/prometheus/prometheus.yml'\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eexpose\u003c/span\u003e:\n            - \u003cspan class=\"hljs-number\"\u003e9090\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003egrafana\u003c/span\u003e:\n        \u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e: grafana/\u003cspan class=\"hljs-attr\"\u003egrafana\u003c/span\u003e:latest\n        \u003cspan class=\"hljs-attr\"\u003evolumes\u003c/span\u003e:\n            - \u003cspan class=\"hljs-attr\"\u003egrafanadata\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/var/\u003c/span\u003elib/grafana\n        \u003cspan class=\"hljs-attr\"\u003eenvironment\u003c/span\u003e:\n            - \u003cspan class=\"hljs-variable constant_\"\u003eGF_PATHS_PROVISIONING\u003c/span\u003e=\u003cspan class=\"hljs-regexp\"\u003e/etc/g\u003c/span\u003erafana/provisioning\n            - \u003cspan class=\"hljs-variable constant_\"\u003eGF_AUTH_ANONYMOUS_ENABLED\u003c/span\u003e=\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n            - \u003cspan class=\"hljs-variable constant_\"\u003eGF_AUTH_ANONYMOUS_ORG_ROLE\u003c/span\u003e=\u003cspan class=\"hljs-title class_\"\u003eAdmin\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003eports\u003c/span\u003e:\n            - \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003evolumes\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003emongodata\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003egrafanadata\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003elogs\u003c/span\u003e:\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e모두 Git push가 발생할 때마다 GitHub Actions CI가 빌드를 실행합니다. CI 중에는 종속성 설치, 린터 실행 및 모든 테스트 실행을 진행하고 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCI\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eon\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003epush\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003ebranches\u003c/span\u003e:\n      - \u003cspan class=\"hljs-string\"\u003e\"*\"\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003ejobs\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003eci\u003c/span\u003e:\n    runs-\u003cspan class=\"hljs-attr\"\u003eon\u003c/span\u003e: ubuntu-latest\n    \u003cspan class=\"hljs-attr\"\u003esteps\u003c/span\u003e:\n      - \u003cspan class=\"hljs-attr\"\u003euses\u003c/span\u003e: actions/checkout@v3\n      - \u003cspan class=\"hljs-attr\"\u003euses\u003c/span\u003e: actions/setup-node@v3\n        \u003cspan class=\"hljs-attr\"\u003ewith\u003c/span\u003e:\n          node-\u003cspan class=\"hljs-attr\"\u003eversion\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003ecache\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"yarn\"\u003c/span\u003e\n      - \u003cspan class=\"hljs-attr\"\u003erun\u003c/span\u003e: yarn install --frozen-lockfile\n      - \u003cspan class=\"hljs-attr\"\u003erun\u003c/span\u003e: yarn run lint\n      - \u003cspan class=\"hljs-attr\"\u003erun\u003c/span\u003e: docker-compose up -d mongo\n      - \u003cspan class=\"hljs-attr\"\u003erun\u003c/span\u003e: yarn test -- --verbose --coverage\n      - \u003cspan class=\"hljs-attr\"\u003erun\u003c/span\u003e: docker-compose build\n      - \u003cspan class=\"hljs-attr\"\u003erun\u003c/span\u003e: docker-compose logs\n        \u003cspan class=\"hljs-attr\"\u003eif\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003ealways\u003c/span\u003e()\n      - \u003cspan class=\"hljs-attr\"\u003erun\u003c/span\u003e: docker-compose down --volumes\n        \u003cspan class=\"hljs-attr\"\u003eif\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003ealways\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eNode.js는 강력한 기술입니다. 더 중요한 것은 Node.js 커뮤니티가 매우 크다는 것이에요. 새로운 웹 서비스를 개발할 때마다 다른 스택을 사용할 수 있어요. 하지만 저는 이 방법을 추천하지 않아요; 만일 능숙한 Node.js 웹 개발자가 되고 싶다면 먼저 특정 기술의 기능을 익히고, 그런 다음에 다른 스택을 사용해보는 것이 좋아요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 게시물에서 웹 애플리케이션을 구축하는 데 사용한 스택은 Node.js 웹 서비스를 구축하는 데 가장 인기가 많습니다. 구현중인 다양한 기능에 도움이되는 많은 문서와 라이브러리가 있습니다.\u003c/p\u003e\n\u003cp\u003eNode.js로 이전에 설정한 모든 비기능 요구 사항을 쉽게 달성할 수 있습니다. Kubernetes를 사용하여 응용 프로그램 도커 이미지를 작성하고 호스팅할 수 있습니다. Kubernetes는 배포 정의를 변경하여 응용 프로그램을 빠르게 확장하거나 축소하는 데 도움을줍니다. 또한 Kubernetes는 들어오는 트래픽에 따라 응용 프로그램을 확장할 수 있습니다. 또한 MongoDB는 필요에 따라 확장할 수 있도록 설계되어 있어서 트래픽 증가가 문제가 되지 않습니다.\u003c/p\u003e\n\u003cp\u003eGoogle의 V8 Node.js 엔진을 통해 더 나은 응용 프로그램 성능을 달성할 수 있습니다. 소스 코드가 기계 코드로 번역되는 속도는 인상적입니다!\u003c/p\u003e\n\u003cp\u003eNode.js를 사용하면 내결함성 있는 응용 프로그램을 구축하는 방법에 대한 다양한 인터넷 기사를 찾을 수 있습니다. 최선의 방법을 따라주세요! 또한 응용 프로그램 코드에서는 예기치 않은 연결 실패(네트워크 문제 또는 MongoDB 장애 등) 후 MongoDB 연결을 복원하는 데 시간을 소비했습니다. 이를 확인하고 응용 프로그램에 적용할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eJest를 사용하면 애플리케이션을 위한 다양한 테스트를 작성하고 100%의 테스트 커버리지를 달성할 수 있어요. 몇 가지 까다로운 시나리오도 Jest를 사용하여 에뮬레이션할 수 있어요.\u003c/p\u003e\n\u003cp\u003e즐거운 코딩 되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-WritingAMicroserviceUsingNodejs"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>