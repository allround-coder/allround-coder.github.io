<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>12가지 유용한 JavaScript 면접 팁 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-12UsefulJavaScriptInterviewTips" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="12가지 유용한 JavaScript 면접 팁 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="12가지 유용한 JavaScript 면접 팁 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-12UsefulJavaScriptInterviewTips" data-gatsby-head="true"/><meta name="twitter:title" content="12가지 유용한 JavaScript 면접 팁 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 16:06" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">12가지 유용한 JavaScript 면접 팁</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="12가지 유용한 JavaScript 면접 팁" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">14<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-12UsefulJavaScriptInterviewTips&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>제 3 부: 자바스크립트에 대해 반드시 알아야 할 일반 지식 포인트 목록</p>
<p><img src="/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png" alt="자바스크립트에 대해 알아야 할 것들"></p>
<p>이 시리즈의 기사에서는 자바스크립트에 대해 반드시 알아야 할 일반 지식 포인트 목록을 정리했습니다. 이는 면접을 볼 때나 매일 개발할 때 큰 자신감을 줄 것입니다.</p>
<p>이전 기사에서는 일반 지식 포인트를 나열했으며 다음 링크를 클릭하여 확인할 수 있습니다.</p>
<h1>1. 'Set' 객체는 무엇이며 어떻게 작동하나요?</h1>
<p>Set 객체를 사용하면 원시 값이든 객체 참조든 어떠한 유형의 고유한 값도 저장할 수 있습니다.</p>
<p>Set 생성자를 사용하여 Set 인스턴스를 만들 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
<span class="hljs-keyword">const</span> set2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>,<span class="hljs-string">"d"</span>,<span class="hljs-string">"d"</span>,<span class="hljs-string">"e"</span>]);
</code></pre>
<p>Set 인스턴스에 새 값을 추가하려면 add 메서드를 사용할 수 있습니다. add 메서드는 Set 객체를 반환하기 때문에 여러 개의 add 호출을 연결할 수 있습니다. Set 객체에 값이 이미 존재한다면 다시 추가되지 않습니다.</p>
<pre><code class="hljs language-js">set2.<span class="hljs-title function_">add</span>(<span class="hljs-string">"f"</span>);
set2.<span class="hljs-title function_">add</span>(<span class="hljs-string">"g"</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">"h"</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">"i"</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">"j"</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">"k"</span>).<span class="hljs-title function_">add</span>(<span class="hljs-string">"k"</span>);
</code></pre>
<p>특정 값이 Set 인스턴스에 있는지 확인하려면 has 메서드를 사용할 수 있습니다.</p>
<pre><code class="hljs language-js">set2.<span class="hljs-title function_">has</span>(<span class="hljs-string">"a"</span>) <span class="hljs-comment">// true</span>
set2.<span class="hljs-title function_">has</span>(<span class="hljs-string">"z"</span>) <span class="hljs-comment">// true</span>
</code></pre>
<p>Set 인스턴스의 길이를 얻기 위해 size 속성을 사용할 수 있어요.</p>
<pre><code class="hljs language-js">set2.<span class="hljs-property">size</span> <span class="hljs-comment">// 10을 반환합니다</span>
</code></pre>
<p>모든 데이터를 Set에서 제거할 때 clear 메소드를 사용할 수 있어요.</p>
<pre><code class="hljs language-js">set2.<span class="hljs-title function_">clear</span>();
</code></pre>
<p>배열에서 중복된 요소를 제거하는 데 Set 객체를 사용할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> uniqueNums = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(numbers)]; <span class="hljs-comment">// [1,2,3,4,5,6,7,8]</span>
</code></pre>
<h2>2. 콜백 함수란 무엇인가요?</h2>
<p>콜백 함수는 다른 코드의 인자로 전달되어 실행 가능한 코드 조각입니다. 이 함수의 목적은 필요할 때 수신 코드에 의해 편리한 시간에 호출되도록 하는 것입니다.</p>
<p>자바스크립트에서 함수는 객체의 한 유형입니다. 객체처럼 함수도 다른 함수에게 인수로 전달될 수 있습니다. 따라서 다른 함수의 인수로 전달되는 함수는 콜백 함수라고 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> btnAdd = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'btnAdd'</span>);

btnAdd.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span> <span class="hljs-title function_">clickCallback</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-comment">// 아무 일도 하지 않음</span>
});
</code></pre>
<p>이 예시에서는 id가 btnAdd인 요소의 클릭 이벤트를 기다리고 있습니다. 클릭이 발생하면 clickCallback 함수가 실행됩니다. 콜백 함수는 특정 데이터나 이벤트에 기능을 추가합니다.</p>
<p>배열의 reduce, filter, map 메서드는 매개변수로 콜백 함수를 요구합니다. 콜백의 좋은 비유는 누군가에게 전화를 걸어서, 그들이 받지 않으면 메시지를 남기고 전화 받기를 기대하는 것입니다. 누군가에게 전화를 거는 행위나 메시지를 남기는 것이 이벤트나 데이터이며, 콜백은 나중에 발생할 기대되는 작업입니다.</p>
<h1>3. ES6 모듈이란 무엇인가요?</h1>
<p>모듈은 코드베이스를 여러 파일로 분할하여 유지 보수성을 향상시키고 모든 코드를 하나의 큰 파일에 모두 가지고 있지 않도록 해줍니다. ES6 이전에는 두 가지 인기있는 모듈 시스템이 있었습니다.</p>
<ul>
<li>CommonJS-Node.js</li>
<li>AMD (비동기 모듈 정의) - 브라우저</li>
</ul>
<p>기본적으로 모듈을 사용하는 것은 매우 간단합니다. import는 다른 파일에서 기능이나 여러 기능 또는 값을 검색하는 데 사용되며, export는 파일에서 기능이나 여러 기능 또는 값을 노출하는 데 사용됩니다.</p>
<h2>내보내기</h2>
<p>ES5(CommonJS) 사용</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// ES5(CommonJS)를 사용하여 - helpers.js</span>
<span class="hljs-built_in">exports</span>.<span class="hljs-property">isNull</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) {
  <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span>;
}

<span class="hljs-built_in">exports</span>.<span class="hljs-property">isUndefined</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) {
  <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span>;
}

<span class="hljs-built_in">exports</span>.<span class="hljs-property">isNullOrUndefined</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">exports</span>.<span class="hljs-title function_">isNull</span>(val) || <span class="hljs-built_in">exports</span>.<span class="hljs-title function_">isUndefined</span>(val);
}
</code></pre>
<p>ES6 모듈 사용</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Using ES6 Modules - helpers.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isNull</span>(<span class="hljs-params">val</span>){
  <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isUndefined</span>(<span class="hljs-params">val</span>) {
  <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span>;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">isNullOrUndefined</span>(<span class="hljs-params">val</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">isNull</span>(val) || <span class="hljs-title function_">isUndefined</span>(val);
}
</code></pre>
<p>다른 파일에서 함수 가져오기</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//ES5 (CommonJS) - index.js</span>
<span class="hljs-keyword">const</span> helpers = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>); <span class="hljs-comment">// helpers는 객체임</span>
<span class="hljs-keyword">const</span> isNull = helpers.<span class="hljs-property">isNull</span>;
<span class="hljs-keyword">const</span> isUndefined = helpers.<span class="hljs-property">isUndefined</span>;
<span class="hljs-keyword">const</span> isNullOrUndefined = helpers.<span class="hljs-property">isNullOrUndefined</span>;
<span class="hljs-comment">// 또는 환경이 구조 분해를 지원하는 경우</span>
<span class="hljs-keyword">const</span> { isNull, isUndefined, isNullOrUndefined } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>);
-------------------------------------------------------
<span class="hljs-comment">// ES6 Modules - index.js</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> helpers <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span>; <span class="hljs-comment">// helpers는 객체임</span>
<span class="hljs-comment">// 또는 </span>
<span class="hljs-keyword">import</span> { isNull, isUndefined, isNullOrUndefined <span class="hljs-keyword">as</span> isValid } <span class="hljs-keyword">from</span> <span class="hljs-string">'./helpers.js'</span>;
<span class="hljs-comment">// "as"를 사용하여 명명된 내보내기 이름 변경</span>
</code></pre>
<p>파일에서 단일 함수 또는 기본 내보내기 내보내기</p>
<p>ES5 (CommonJS)</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// ES5 (CommonJS) - index.js</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Helpers</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">isNull</span>(<span class="hljs-params">val</span>) {
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">isUndefined</span>(<span class="hljs-params">val</span>) {
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span>;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">isNullOrUndefined</span>(<span class="hljs-params">val</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isNull</span>(val) || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isUndefined</span>(val);
  }
}
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">Helpers</span>;
</code></pre>
<p>ES6 Modules을 사용하는 예시</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// using ES6 Modules - helpers.js</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Helpers</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">isNull</span>(<span class="hljs-params">val</span>) {
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">isUndefined</span>(<span class="hljs-params">val</span>) {
    <span class="hljs-keyword">return</span> val === <span class="hljs-literal">undefined</span>;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">isNullOrUndefined</span>(<span class="hljs-params">val</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isNull</span>(val) || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isUndefined</span>(val);
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Helpers</span>;
</code></pre>
<p>다른 파일에서 함수를 한 개 가져오기</p>
<p>ES5(CommonJS)를 사용하는 방법</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// ES5(CommonJS) - index.js</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Helpers</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers.js'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Helpers</span>.<span class="hljs-title function_">isNull</span>(<span class="hljs-literal">null</span>));
</code></pre>
<p>ES6 모듈 사용법</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Helpers</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'.helpers.js'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Helpers</span>.<span class="hljs-title function_">isNull</span>(<span class="hljs-literal">null</span>));
</code></pre>
<h2>4. Promise이 무엇인가요?</h2>
<p>Promise은 비동기 프로그래밍의 해결책입니다. 구문적으로 Promise은 비동기 작업의 결과를 얻을 수 있는 객체입니다. 개념적으로 일정 기간이 지난 후 결과를 제공할 것을 약속하는 것을 나타냅니다. Promise에는 세 가지 상태가 있습니다: pending(대기 중), fulfilled(이행됨) 및 rejected(거부됨). 상태가 변경되면 변경된 상태가 유지됩니다. Promise 인스턴스를 생성한 후에는 즉시 실행됩니다.</p>
<pre><code class="hljs language-js">fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'somefile.txt'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e, data</span>) {
  <span class="hljs-keyword">if</span> (e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
});
</code></pre>
<p>만약 콜백 안에 또 다른 비동기 작업이 있다면, 문제가 생길 수 있어요. 코드가 엉망이 되고 가독성이 떨어질 거예요. 이를 '콜백 지옥'이라고 해요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 콜백 지옥</span>
fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">'somefile.txt'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e, data</span>) {
  <span class="hljs-comment">//여기에 코드 작성</span>
  fs.<span class="hljs-title function_">readdir</span>(<span class="hljs-string">'directory'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e, files</span>) {
    <span class="hljs-comment">//여기에 코드 작성</span>
    fs.<span class="hljs-title function_">mkdir</span>(<span class="hljs-string">'directory'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) {
      <span class="hljs-comment">//여기에 코드 작성</span>
    })
  })
})
</code></pre>
<p>이 코드에서 promise를 사용하면 더 읽기 쉽고 이해하기 쉽고 유지보수하기 좋아질 거예요.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">promReadFile</span>(<span class="hljs-string">'file/path'</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =></span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promReaddir</span>(<span class="hljs-string">'directory'</span>);
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =></span> {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">promMkdir</span>(<span class="hljs-string">'directory'</span>);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">e</span> =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);
  })
</code></pre>
<p>약속은 세 가지 다른 상태를 가집니다:</p>
<ul>
<li>대기 중(pending): 이니셜 상태로, 충족 또는 거부되기 전의 상태입니다.</li>
<li>충족됨(fulfilled): 작업이 성공적으로 완료된 상태입니다.</li>
<li>거부됨(rejected): 작업이 실패한 상태입니다.</li>
</ul>
<p>대기 중인 객체는 충족됨/거부됨 상태를 발생시키며, 해당 상태 처리 메소드에 해결된 값/에러 메시지를 전달합니다. 작업이 성공적으로 완료되면, Promise 객체의 then 메소드가 호출됩니다. 그렇지 않으면 catch 메소드가 트리거됩니다. 예를 들면:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myFirstPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"Success!"</span>); 
    }, <span class="hljs-number">250</span>);
});

myFirstPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Yay! "</span> + data);
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =></span> {...});
</code></pre>
<h1>5. async/await이란 무엇이며 어떻게 동작합니까?</h1>
<p>async/await은 JavaScript에서 비동기 또는 블로킹 코드를 작성하는 새로운 방법입니다. 이는 Promises 위에 구축되어 있으며 비동기 코드의 가독성과 간결성을 높여줍니다.</p>
<p>async/await은 JavaScript에서 비동기 또는 블로킹 코드를 작성하는 새로운 방법입니다. Promises 및 콜백에 비해 높은 가독성과 간결성을 제공합니다. 그러나 이 기능을 사용하기 전에 Promises의 기본을 배우는 것이 필요합니다. 앞에서 언급한 대로 async/await은 Promises 위에 구축되어 있으므로 여전히 내부적으로 Promises를 사용합니다.</p>
<pre><code class="hljs language-js">기능 <span class="hljs-title function_">callApi</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"url/to/api/endpoint"</span>)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">resp</span> =></span> resp.<span class="hljs-title function_">json</span>())
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =></span> {
      <span class="hljs-comment">// "data"와 무언가를 처리합니다</span>
    }).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =></span> {
      <span class="hljs-comment">// "err"과 무언가를 처리합니다</span>
    });
}
</code></pre>
<p>async/await</p>
<p>async/await에서는 try/catch 구문을 사용하여 예외를 catch합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">callApi</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> resp = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"url/to/api/endpoint"</span>);
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> resp.<span class="hljs-title function_">json</span>();
    <span class="hljs-comment">// "data"와 무언가를 처리합니다</span>
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-comment">// "err"과 무언가를 처리합니다</span>
  }
}
</code></pre>
<p>참고: 'async' 키워드를 사용하여 함수를 선언하면 암시적으로 Promise가 반환됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">giveMeOne</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) => <span class="hljs-number">1</span>;

<span class="hljs-title function_">giveMeOne</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =></span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num); <span class="hljs-comment">// 1을 출력합니다</span>
  });
</code></pre>
<p>참고: 'await' 키워드는 오직 async 함수 내에서만 사용할 수 있습니다. 어떤 비동기 함수에서도 'await' 키워드를 사용하면 오류가 발생합니다. 'await' 키워드는 Promise가 반환될 때까지 오른쪽 표현식을 기다린 후 다음 코드 줄을 실행합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">giveMeOne</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) => <span class="hljs-number">1</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getOne</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> num = <span class="hljs-keyword">await</span> <span class="hljs-title function_">giveMeOne</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);
  }
}
<span class="hljs-comment">// Uncaught SyntaxError: await is only valid in async function</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getTwo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> num1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">giveMeOne</span>(); 
    <span class="hljs-keyword">const</span> num2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">giveMeOne</span>(); 
    <span class="hljs-keyword">return</span> num1 + num2;
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);
  }
}
<span class="hljs-keyword">await</span> <span class="hljs-title function_">getTwo</span>(); <span class="hljs-comment">// 2</span>
</code></pre>
<h1>6. 스프레드 연산자와 나머지 연산자의 차이는 무엇인가요?</h1>
<p>스프레드 연산자는 세 개의 점 ...으로 나타내며, 배열을 쉼표로 구분된 인수의 시퀀스로 변환할 수 있습니다. 좀 더 간단히 말하면, 큰 요소를 작은 요소로 나누어주는 것과 같습니다. 마치 손바닥 타격이 단단한 물체를 분산시키는 것처럼 말이죠.</p>
<p>나머지 연산자도 세 개의 점 ...로 표시되지만, 스프레드 연산자와 비슷해 보일 수 있지만, 배열과 객체의 해체에 사용됩니다. 어느 정도로는 스프레드 연산자의 반대 역할을 합니다. 스프레드 연산자는 배열을 여러 요소로 '펼치는' 반면, 나머지 연산자는 여러 요소를 '수집'하고 그것들을 한 요소로 '압축'합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a + b;
};

<span class="hljs-keyword">const</span> nums = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
<span class="hljs-keyword">const</span> sum = <span class="hljs-title function_">add</span>(...nums);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);
</code></pre>
<p>이 예에서는 add 함수를 호출할 때 전개 연산자를 사용하여 nums 배열을 확장했습니다. 따라서 매개변수 a의 값은 5이고, 매개변수 b의 값은 6이므로 합계는 11이 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">...rest</span>) {
  <span class="hljs-keyword">return</span> rest.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, current</span>) =></span> total + current);
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 3</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 15</span>
</code></pre>
<p>이 예에서는 임의의 개수의 매개변수를 수용하고 모두 더한 다음 총합을 반환하는 add 함수가 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> [first, ...others] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(others); <span class="hljs-comment">// [2, 3, 4, 5]</span>
</code></pre>
<p>여기서는 나머지 배열 값을 추출하여 다른 배열에 넣는 데 rest 연산자를 사용합니다. 첫 번째 항목을 제외하고 나머지 값을 모두 가져올 수 있어요.</p>
<h1>7. 기본 매개변수란?</h1>
<p>기본 매개변수는 JavaScript에서 기본 변수를 정의하는 새로운 방법으로, ES6 또는 ECMAScript 2015에서 사용할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//ES5 버전</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {
  a = a || <span class="hljs-number">0</span>;
  b = b || <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-comment">//ES6 버전</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span></span>) {
  <span class="hljs-keyword">return</span> a + b;
}
<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 1을 반환</span>
</code></pre>
<p>기본 매개변수에서 해체 할당을 사용할 수도 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFirst</span>(<span class="hljs-params">[first, ...rest] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span>) {
  <span class="hljs-keyword">return</span> first;
}

<span class="hljs-title function_">getFirst</span>();  <span class="hljs-comment">// 0</span>
<span class="hljs-title function_">getFirst</span>([<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>]);  <span class="hljs-comment">// 10</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getArr</span>(<span class="hljs-params">{ nums } = { nums: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] }</span>){
    <span class="hljs-keyword">return</span> nums;
}
<span class="hljs-title function_">getArr</span>(); <span class="hljs-comment">// [1, 2, 3, 4]</span>
<span class="hljs-title function_">getArr</span>({<span class="hljs-attr">nums</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]}); <span class="hljs-comment">// [5,4,3,2,1]</span>
</code></pre>
<p>이전에 정의된 매개변수를 나중에 정의된 매개변수보다 먼저 사용할 수도 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomethingWithValue</span>(<span class="hljs-params">value = <span class="hljs-string">"Hello World"</span>, callback = () => { <span class="hljs-variable language_">console</span>.log(value) }</span>) {
  <span class="hljs-title function_">callback</span>();
}
<span class="hljs-title function_">doSomethingWithValue</span>(); <span class="hljs-comment">//"Hello World"</span>
</code></pre>
<h1>8. 래퍼 객체란 무엇인가요?</h1>
<p>이제 JavaScript의 데이터 유형을 검토해봅시다. JavaScript 데이터 유형은 기본 유형과 참조 유형으로 나뉩니다.</p>
<p>기본 유형: Undefined, Null, Boolean, Number, String, Symbol, BigInt</p>
<p>참조 유형: Object, Array, Date, RegExp 등. 간단히 말해, 이들은 객체입니다.</p>
<p>참조 유형 중에는 프리미티브 유형에는 없는 메소드와 속성이 있습니다. 그러나 종종 다음과 같은 코드를 만날 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">"maxwell"</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> name); <span class="hljs-comment">// "string"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name.<span class="hljs-title function_">toUpperCase</span>()); <span class="hljs-comment">// "MAXWELL"</span>
</code></pre>
<p>이름 타입은 문자열이며 프리미티브 유형에 속합니다. 따라서 속성이나 메소드가 없습니다. 그러나 이 예제에서 toUpperCase() 메소드를 호출하는 것은 에러를 발생시키지 않고 문자열의 대문자 값을 반환합니다.</p>
<p>그 이유는 프리미티브 유형의 값이 일시적으로 객체로 변환되거나 강제 변환되기 때문에, 이름 변수의 동작이 객체와 유사합니다. null과 undefined를 제외한 모든 프리미티브 유형에는 String, Number, Boolean, Symbol 및 BigInt의 래퍼 객체가 있습니다. 이 경우, name.toUpperCase()은 '백그라운드에서' 다음과 같이 보입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(name).<span class="hljs-title function_">toUpperCase</span>()); <span class="hljs-comment">// "MAXWELL"</span>
</code></pre>
<p>속성에 접근하거나 메소드를 호출한 후에, 새로 생성된 객체는 즉시 폐기됩니다.</p>
<h2>9. 암시적 형 변환과 명시적 형 변환의 차이점은 무엇인가요?</h2>
<p>암시적 형 변환은 값의 형태를 다른 형태로 자동으로 변환하는 방법으로, 수동 개입 없이 자동으로 처리됩니다.</p>
<p>아래의 예시를 가정해 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> + <span class="hljs-string">'6'</span>); <span class="hljs-comment">// 16</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">false</span> + <span class="hljs-literal">true</span>); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span> * <span class="hljs-string">'2'</span>); <span class="hljs-comment">// 12</span>
</code></pre>
<p>첫 번째 <code>console.log</code> 문의 결과는 16입니다. 다른 언어에서는 컴파일 오류가 발생할 수 있지만 JavaScript에서는 1이 문자열로 변환되고 그 후 + 연산자와 연결됩니다. 우리는 아무것도 하지 않았습니다. JavaScript가 자동으로 처리해 주었습니다.</p>
<p>두 번째 <code>console.log</code> 문의 결과는 1입니다. JavaScript에서 false는 0으로, true는 1로 변환됩니다. 따라서 결과는 1이 됩니다.</p>
<p>세 번째 console.log 문의 결과는 12입니다. '2'를 숫자로 변환한 다음 6 * 2를 곱하여 12가 되었습니다.</p>
<p>반면에 명시적 타입 강제 변환은 값의 타입을 수동으로 변환해야 하는 경우에 사용하는 방법입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span> + <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'6'</span>));
</code></pre>
<p>이 예시에서는 parseInt 함수를 사용하여 '6'를 숫자로 변환한 후 + 연산자를 사용하여 1과 6을 더합니다.</p>
<h1>10. NaN이란 무엇인가요? 그리고 값이 NaN인지 확인하는 방법은 무엇인가요?</h1>
<p>NaN은 "숫자가 아님(Not a Number)"을 의미하며, JavaScript에서 숫자 연산이나 변환 결과로 의미있는 숫자 값을 생성하지 못할 때 발생합니다. 따라서 숫자 연산이나 변환에서 숫자가 아닌 값이 나오면 결과값은 NaN이 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> a;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'abc'</span>)); <span class="hljs-comment">// NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(++a)); <span class="hljs-comment">// NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>({} * <span class="hljs-number">10</span>)); <span class="hljs-comment">// NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'abc'</span> - <span class="hljs-number">2</span>)); <span class="hljs-comment">// NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0</span> / <span class="hljs-number">0</span>)); <span class="hljs-comment">// NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'10a'</span> * <span class="hljs-number">10</span>)); <span class="hljs-comment">// NaN</span>
</code></pre>
<p>JavaScript에는 값이 NaN인지 확인하는 isNaN 메서드가 내장되어 있습니다. 그러나 이 함수는 특이한 동작을 보입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>()); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>({})); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-title class_">String</span>(<span class="hljs-string">'a'</span>))); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">isNaN</span>(<span class="hljs-function">() =></span> { })); <span class="hljs-comment">// true</span>
</code></pre>
<p>모든 이 console.log 문은 값으로 NaN이 아닌 경우에도 true를 반환합니다.</p>
<p>ES6에서는 값이 NaN인지를 진정으로 확인하는 Number.isNaN 메서드를 사용하는 것이 좋습니다. 또는 JavaScript에서 NaN은 자신과 일치하지 않는 유일한 값이기 때문에 이 문제를 확인하기 위한 사용자 지정 도우미 함수를 만들 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkIfNaN</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">return</span> value !== value;
}
</code></pre>
<h1>11. 값이 배열인지 어떻게 판단할 수 있을까요?</h1>
<p>Array.isArray 메소드를 사용하여 값이 배열인지 확인할 수 있습니다. 배열이 인수로 전달되면 true를 반환하고, 그렇지 않으면 false를 반환합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-number">5</span>));  <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-string">""</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>()); <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">5</span> })); <span class="hljs-comment">// false</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>([])); <span class="hljs-comment">// true</span>
</code></pre>
<p>이 방법이 지원되지 않는 환경이라면, 폴리필을 구현할 수도 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isArray</span>(<span class="hljs-params">value</span>){
 <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(value) === <span class="hljs-string">"[object Array]"</span>
}
</code></pre>
<p>물론 전통적인 방법도 사용할 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> a = []
<span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'is an array'</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Non-Arrays'</span>)
}
</code></pre>
<h1>12. 객체에 속성이 존재하는지 확인하는 방법은 무엇인가요?</h1>
<p>객체에 특정 속성이 존재하는지 확인하는 세 가지 방법이 있어요.</p>
<p>첫 번째 방법은 in 연산자를 사용하는 것이에요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> o = { 
  <span class="hljs-string">"prop"</span> : <span class="hljs-string">"rabbit"</span>,
  <span class="hljs-string">"prop2"</span> : <span class="hljs-string">"tiger"</span>
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"prop"</span> <span class="hljs-keyword">in</span> o); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"prop1"</span> <span class="hljs-keyword">in</span> o); <span class="hljs-comment">// false</span>
</code></pre>
<p>두 번째 방법은 hasOwnProperty 메서드를 사용하는 것이에요. hasOwnProperty() 메서드는 객체가 지정된 속성을 직접 속성으로 가지고 있는지 여부를 나타내는 부울 값(true 또는 false)을 반환해줘요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">"prop2"</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">"prop1"</span>)); <span class="hljs-comment">// false</span>
</code></pre>
<p>세 번째 방법은 괄호 표기법 obj['prop']를 사용하는 것입니다. 속성이 존재하면 해당 속성의 값을 반환하고, 그렇지 않으면 undefined를 반환합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o[<span class="hljs-string">"prop"</span>]); <span class="hljs-comment">// "rabbit"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o[<span class="hljs-string">"prop1"</span>]); <span class="hljs-comment">// undefined</span>
</code></pre>
<p>더 많은 내용은 PlainEnglish.io에서 확인할 수 있습니다.</p>
<p>우리의 무료 주간 소식지 구독하세요. Twitter, LinkedIn, YouTube, Discord를 팔로우해보세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"12가지 유용한 JavaScript 면접 팁","description":"","date":"2024-05-14 16:06","slug":"2024-05-14-12UsefulJavaScriptInterviewTips","content":"\n\n제 3 부: 자바스크립트에 대해 반드시 알아야 할 일반 지식 포인트 목록\n\n![자바스크립트에 대해 알아야 할 것들](/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png)\n\n이 시리즈의 기사에서는 자바스크립트에 대해 반드시 알아야 할 일반 지식 포인트 목록을 정리했습니다. 이는 면접을 볼 때나 매일 개발할 때 큰 자신감을 줄 것입니다.\n\n이전 기사에서는 일반 지식 포인트를 나열했으며 다음 링크를 클릭하여 확인할 수 있습니다.\n\n\n\n# 1. 'Set' 객체는 무엇이며 어떻게 작동하나요?\n\nSet 객체를 사용하면 원시 값이든 객체 참조든 어떠한 유형의 고유한 값도 저장할 수 있습니다.\n\nSet 생성자를 사용하여 Set 인스턴스를 만들 수 있습니다.\n\n```js\nconst set1 = new Set();\nconst set2 = new Set([\"a\",\"b\",\"c\",\"d\",\"d\",\"e\"]);\n```\n\n\n\nSet 인스턴스에 새 값을 추가하려면 add 메서드를 사용할 수 있습니다. add 메서드는 Set 객체를 반환하기 때문에 여러 개의 add 호출을 연결할 수 있습니다. Set 객체에 값이 이미 존재한다면 다시 추가되지 않습니다.\n\n```js\nset2.add(\"f\");\nset2.add(\"g\").add(\"h\").add(\"i\").add(\"j\").add(\"k\").add(\"k\");\n```\n\n특정 값이 Set 인스턴스에 있는지 확인하려면 has 메서드를 사용할 수 있습니다.\n\n```js\nset2.has(\"a\") // true\nset2.has(\"z\") // true\n```\n\n\n\nSet 인스턴스의 길이를 얻기 위해 size 속성을 사용할 수 있어요.\n\n```js\nset2.size // 10을 반환합니다\n```\n\n모든 데이터를 Set에서 제거할 때 clear 메소드를 사용할 수 있어요.\n\n```js\nset2.clear();\n```\n\n\n\n배열에서 중복된 요소를 제거하는 데 Set 객체를 사용할 수 있어요.\n\n```js\nconst numbers = [1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 5];\nconst uniqueNums = [...new Set(numbers)]; // [1,2,3,4,5,6,7,8]\n```\n\n## 2. 콜백 함수란 무엇인가요?\n\n콜백 함수는 다른 코드의 인자로 전달되어 실행 가능한 코드 조각입니다. 이 함수의 목적은 필요할 때 수신 코드에 의해 편리한 시간에 호출되도록 하는 것입니다.\n\n\n\n자바스크립트에서 함수는 객체의 한 유형입니다. 객체처럼 함수도 다른 함수에게 인수로 전달될 수 있습니다. 따라서 다른 함수의 인수로 전달되는 함수는 콜백 함수라고 합니다.\n\n```js\nconst btnAdd = document.getElementById('btnAdd');\n\nbtnAdd.addEventListener('click', function clickCallback(e) {\n    // 아무 일도 하지 않음\n});\n```\n\n이 예시에서는 id가 btnAdd인 요소의 클릭 이벤트를 기다리고 있습니다. 클릭이 발생하면 clickCallback 함수가 실행됩니다. 콜백 함수는 특정 데이터나 이벤트에 기능을 추가합니다.\n\n배열의 reduce, filter, map 메서드는 매개변수로 콜백 함수를 요구합니다. 콜백의 좋은 비유는 누군가에게 전화를 걸어서, 그들이 받지 않으면 메시지를 남기고 전화 받기를 기대하는 것입니다. 누군가에게 전화를 거는 행위나 메시지를 남기는 것이 이벤트나 데이터이며, 콜백은 나중에 발생할 기대되는 작업입니다.\n\n\n\n# 3. ES6 모듈이란 무엇인가요?\n\n모듈은 코드베이스를 여러 파일로 분할하여 유지 보수성을 향상시키고 모든 코드를 하나의 큰 파일에 모두 가지고 있지 않도록 해줍니다. ES6 이전에는 두 가지 인기있는 모듈 시스템이 있었습니다.\n\n- CommonJS-Node.js\n- AMD (비동기 모듈 정의) - 브라우저\n\n기본적으로 모듈을 사용하는 것은 매우 간단합니다. import는 다른 파일에서 기능이나 여러 기능 또는 값을 검색하는 데 사용되며, export는 파일에서 기능이나 여러 기능 또는 값을 노출하는 데 사용됩니다.\n\n\n\n## 내보내기\n\nES5(CommonJS) 사용\n\n```js\n// ES5(CommonJS)를 사용하여 - helpers.js\nexports.isNull = function(val) {\n  return val === null;\n}\n\nexports.isUndefined = function(val) {\n  return val === undefined;\n}\n\nexports.isNullOrUndefined = function(val) {\n  return exports.isNull(val) || exports.isUndefined(val);\n}\n```\n\nES6 모듈 사용\n\n\n\n```js\n// Using ES6 Modules - helpers.js\nexport function isNull(val){\n  return val === null;\n}\n\nexport function isUndefined(val) {\n  return val === undefined;\n}\nexport function isNullOrUndefined(val) {\n  return isNull(val) || isUndefined(val);\n}\n```\n\n다른 파일에서 함수 가져오기\n\n```js\n//ES5 (CommonJS) - index.js\nconst helpers = require('./helpers.js'); // helpers는 객체임\nconst isNull = helpers.isNull;\nconst isUndefined = helpers.isUndefined;\nconst isNullOrUndefined = helpers.isNullOrUndefined;\n// 또는 환경이 구조 분해를 지원하는 경우\nconst { isNull, isUndefined, isNullOrUndefined } = require('./helpers.js');\n-------------------------------------------------------\n// ES6 Modules - index.js\nimport * as helpers from './helpers.js'; // helpers는 객체임\n// 또는 \nimport { isNull, isUndefined, isNullOrUndefined as isValid } from './helpers.js';\n// \"as\"를 사용하여 명명된 내보내기 이름 변경\n```\n\n파일에서 단일 함수 또는 기본 내보내기 내보내기\n\n\n\nES5 (CommonJS)\n\n```js\n// ES5 (CommonJS) - index.js\nclass Helpers {\n  static isNull(val) {\n    return val === null;\n  }\n\n  static isUndefined(val) {\n    return val === undefined;\n  }\n\n  static isNullOrUndefined(val) {\n    return this.isNull(val) || this.isUndefined(val);\n  }\n}\nmodule.exports = Helpers;\n```\n\nES6 Modules을 사용하는 예시\n\n```js\n// using ES6 Modules - helpers.js\nclass Helpers {\n  static isNull(val) {\n    return val === null;\n  }\n\n  static isUndefined(val) {\n    return val === undefined;\n  }\n\n  static isNullOrUndefined(val) {\n    return this.isNull(val) || this.isUndefined(val);\n  }\n}\nexport default Helpers;\n```\n\n\n\n다른 파일에서 함수를 한 개 가져오기\n\nES5(CommonJS)를 사용하는 방법\n\n```js\n// ES5(CommonJS) - index.js\nconst Helpers = require('./helpers.js');\nconsole.log(Helpers.isNull(null));\n```\n\nES6 모듈 사용법\n\n\n\n```js\nimport Helpers from '.helpers.js'\nconsole.log(Helpers.isNull(null));\n```\n\n## 4. Promise이 무엇인가요?\n\nPromise은 비동기 프로그래밍의 해결책입니다. 구문적으로 Promise은 비동기 작업의 결과를 얻을 수 있는 객체입니다. 개념적으로 일정 기간이 지난 후 결과를 제공할 것을 약속하는 것을 나타냅니다. Promise에는 세 가지 상태가 있습니다: pending(대기 중), fulfilled(이행됨) 및 rejected(거부됨). 상태가 변경되면 변경된 상태가 유지됩니다. Promise 인스턴스를 생성한 후에는 즉시 실행됩니다.\n\n```js\nfs.readFile('somefile.txt', function (e, data) {\n  if (e) {\n    console.log(e);\n  }\n  console.log(data);\n});\n```\n\n\n\n만약 콜백 안에 또 다른 비동기 작업이 있다면, 문제가 생길 수 있어요. 코드가 엉망이 되고 가독성이 떨어질 거예요. 이를 '콜백 지옥'이라고 해요.\n\n```js\n// 콜백 지옥\nfs.readFile('somefile.txt', function (e, data) {\n  //여기에 코드 작성\n  fs.readdir('directory', function (e, files) {\n    //여기에 코드 작성\n    fs.mkdir('directory', function (e) {\n      //여기에 코드 작성\n    })\n  })\n})\n```\n\n이 코드에서 promise를 사용하면 더 읽기 쉽고 이해하기 쉽고 유지보수하기 좋아질 거예요.\n\n```js\npromReadFile('file/path')\n  .then(data =\u003e {\n    return promReaddir('directory');\n  })\n  .then(data =\u003e {\n    return promMkdir('directory');\n  })\n  .catch(e =\u003e {\n    console.log(e);\n  })\n```  \n\n\n\n약속은 세 가지 다른 상태를 가집니다:\n\n- 대기 중(pending): 이니셜 상태로, 충족 또는 거부되기 전의 상태입니다.\n- 충족됨(fulfilled): 작업이 성공적으로 완료된 상태입니다.\n- 거부됨(rejected): 작업이 실패한 상태입니다.\n\n대기 중인 객체는 충족됨/거부됨 상태를 발생시키며, 해당 상태 처리 메소드에 해결된 값/에러 메시지를 전달합니다. 작업이 성공적으로 완료되면, Promise 객체의 then 메소드가 호출됩니다. 그렇지 않으면 catch 메소드가 트리거됩니다. 예를 들면:\n\n```js\nconst myFirstPromise = new Promise((resolve, reject) =\u003e {\n    setTimeout(function(){\n        resolve(\"Success!\"); \n    }, 250);\n});\n\nmyFirstPromise.then((data) =\u003e {\n    console.log(\"Yay! \" + data);\n}).catch((e) =\u003e {...});\n```\n\n\n\n# 5. async/await이란 무엇이며 어떻게 동작합니까?\n\nasync/await은 JavaScript에서 비동기 또는 블로킹 코드를 작성하는 새로운 방법입니다. 이는 Promises 위에 구축되어 있으며 비동기 코드의 가독성과 간결성을 높여줍니다.\n\nasync/await은 JavaScript에서 비동기 또는 블로킹 코드를 작성하는 새로운 방법입니다. Promises 및 콜백에 비해 높은 가독성과 간결성을 제공합니다. 그러나 이 기능을 사용하기 전에 Promises의 기본을 배우는 것이 필요합니다. 앞에서 언급한 대로 async/await은 Promises 위에 구축되어 있으므로 여전히 내부적으로 Promises를 사용합니다.\n\n\n\n```js\n기능 callApi() {\n  return fetch(\"url/to/api/endpoint\")\n    .then(resp =\u003e resp.json())\n    .then(data =\u003e {\n      // \"data\"와 무언가를 처리합니다\n    }).catch(err =\u003e {\n      // \"err\"과 무언가를 처리합니다\n    });\n}\n```\n\nasync/await\n\nasync/await에서는 try/catch 구문을 사용하여 예외를 catch합니다.\n\n```js\nasync function callApi() {\n  try {\n    const resp = await fetch(\"url/to/api/endpoint\");\n    const data = await resp.json();\n    // \"data\"와 무언가를 처리합니다\n  } catch (e) {\n    // \"err\"과 무언가를 처리합니다\n  }\n}\n```\n\n\n\n참고: 'async' 키워드를 사용하여 함수를 선언하면 암시적으로 Promise가 반환됩니다.\n\n```js\nconst giveMeOne = async () =\u003e 1;\n\ngiveMeOne()\n  .then((num) =\u003e {\n    console.log(num); // 1을 출력합니다\n  });\n```\n\n참고: 'await' 키워드는 오직 async 함수 내에서만 사용할 수 있습니다. 어떤 비동기 함수에서도 'await' 키워드를 사용하면 오류가 발생합니다. 'await' 키워드는 Promise가 반환될 때까지 오른쪽 표현식을 기다린 후 다음 코드 줄을 실행합니다.\n\n```js\nconst giveMeOne = async () =\u003e 1;\n\nfunction getOne() {\n  try {\n    const num = await giveMeOne();\n    console.log(num);\n  } catch (e) {\n    console.log(e);\n  }\n}\n// Uncaught SyntaxError: await is only valid in async function\nasync function getTwo() {\n  try {\n    const num1 = await giveMeOne(); \n    const num2 = await giveMeOne(); \n    return num1 + num2;\n  } catch (e) {\n    console.log(e);\n  }\n}\nawait getTwo(); // 2\n```\n\n\n\n# 6. 스프레드 연산자와 나머지 연산자의 차이는 무엇인가요?\n\n스프레드 연산자는 세 개의 점 ...으로 나타내며, 배열을 쉼표로 구분된 인수의 시퀀스로 변환할 수 있습니다. 좀 더 간단히 말하면, 큰 요소를 작은 요소로 나누어주는 것과 같습니다. 마치 손바닥 타격이 단단한 물체를 분산시키는 것처럼 말이죠.\n\n나머지 연산자도 세 개의 점 ...로 표시되지만, 스프레드 연산자와 비슷해 보일 수 있지만, 배열과 객체의 해체에 사용됩니다. 어느 정도로는 스프레드 연산자의 반대 역할을 합니다. 스프레드 연산자는 배열을 여러 요소로 '펼치는' 반면, 나머지 연산자는 여러 요소를 '수집'하고 그것들을 한 요소로 '압축'합니다.\n\n```js\nfunction add(a, b) {\n  return a + b;\n};\n\nconst nums = [5, 6];\nconst sum = add(...nums);\nconsole.log(sum);\n```\n\n\n\n이 예에서는 add 함수를 호출할 때 전개 연산자를 사용하여 nums 배열을 확장했습니다. 따라서 매개변수 a의 값은 5이고, 매개변수 b의 값은 6이므로 합계는 11이 됩니다.\n\n```js\nfunction add(...rest) {\n  return rest.reduce((total, current) =\u003e total + current);\n};\n\nconsole.log(add(1, 2)); // 3\nconsole.log(add(1, 2, 3, 4, 5)); // 15\n```\n\n이 예에서는 임의의 개수의 매개변수를 수용하고 모두 더한 다음 총합을 반환하는 add 함수가 있습니다.\n\n```js\nconst [first, ...others] = [1, 2, 3, 4, 5];\nconsole.log(first); // 1\nconsole.log(others); // [2, 3, 4, 5]\n```\n\n\n\n여기서는 나머지 배열 값을 추출하여 다른 배열에 넣는 데 rest 연산자를 사용합니다. 첫 번째 항목을 제외하고 나머지 값을 모두 가져올 수 있어요.\n\n# 7. 기본 매개변수란?\n\n기본 매개변수는 JavaScript에서 기본 변수를 정의하는 새로운 방법으로, ES6 또는 ECMAScript 2015에서 사용할 수 있어요.\n\n```js\n//ES5 버전\nfunction add(a, b) {\n  a = a || 0;\n  b = b || 0;\n  return a + b;\n}\n\n//ES6 버전\nfunction add(a = 0, b = 0) {\n  return a + b;\n}\nadd(1); // 1을 반환\n```\n\n\n\n기본 매개변수에서 해체 할당을 사용할 수도 있어요.\n\n```js\nfunction getFirst([first, ...rest] = [0, 1]) {\n  return first;\n}\n\ngetFirst();  // 0\ngetFirst([10,20,30]);  // 10\nfunction getArr({ nums } = { nums: [1, 2, 3, 4] }){\n    return nums;\n}\ngetArr(); // [1, 2, 3, 4]\ngetArr({nums:[5,4,3,2,1]}); // [5,4,3,2,1]\n```\n\n이전에 정의된 매개변수를 나중에 정의된 매개변수보다 먼저 사용할 수도 있어요.\n\n```js\nfunction doSomethingWithValue(value = \"Hello World\", callback = () =\u003e { console.log(value) }) {\n  callback();\n}\ndoSomethingWithValue(); //\"Hello World\"\n```\n\n\n\n# 8. 래퍼 객체란 무엇인가요?\n\n이제 JavaScript의 데이터 유형을 검토해봅시다. JavaScript 데이터 유형은 기본 유형과 참조 유형으로 나뉩니다.\n\n기본 유형: Undefined, Null, Boolean, Number, String, Symbol, BigInt\n\n참조 유형: Object, Array, Date, RegExp 등. 간단히 말해, 이들은 객체입니다.\n\n\n\n참조 유형 중에는 프리미티브 유형에는 없는 메소드와 속성이 있습니다. 그러나 종종 다음과 같은 코드를 만날 수 있습니다:\n\n```js\nlet name = \"maxwell\";\n\nconsole.log(typeof name); // \"string\"\nconsole.log(name.toUpperCase()); // \"MAXWELL\"\n```\n\n이름 타입은 문자열이며 프리미티브 유형에 속합니다. 따라서 속성이나 메소드가 없습니다. 그러나 이 예제에서 toUpperCase() 메소드를 호출하는 것은 에러를 발생시키지 않고 문자열의 대문자 값을 반환합니다.\n\n그 이유는 프리미티브 유형의 값이 일시적으로 객체로 변환되거나 강제 변환되기 때문에, 이름 변수의 동작이 객체와 유사합니다. null과 undefined를 제외한 모든 프리미티브 유형에는 String, Number, Boolean, Symbol 및 BigInt의 래퍼 객체가 있습니다. 이 경우, name.toUpperCase()은 '백그라운드에서' 다음과 같이 보입니다:\n\n\n\n```js\nconsole.log(new String(name).toUpperCase()); // \"MAXWELL\"\n```\n\n속성에 접근하거나 메소드를 호출한 후에, 새로 생성된 객체는 즉시 폐기됩니다.\n\n## 9. 암시적 형 변환과 명시적 형 변환의 차이점은 무엇인가요?\n\n암시적 형 변환은 값의 형태를 다른 형태로 자동으로 변환하는 방법으로, 수동 개입 없이 자동으로 처리됩니다.\n\n\n\n아래의 예시를 가정해 봅시다.\n\n```js\nconsole.log(1 + '6'); // 16\nconsole.log(false + true); // 1\nconsole.log(6 * '2'); // 12\n```\n\n첫 번째 `console.log` 문의 결과는 16입니다. 다른 언어에서는 컴파일 오류가 발생할 수 있지만 JavaScript에서는 1이 문자열로 변환되고 그 후 + 연산자와 연결됩니다. 우리는 아무것도 하지 않았습니다. JavaScript가 자동으로 처리해 주었습니다.\n\n두 번째 `console.log` 문의 결과는 1입니다. JavaScript에서 false는 0으로, true는 1로 변환됩니다. 따라서 결과는 1이 됩니다.\n\n\n\n세 번째 console.log 문의 결과는 12입니다. '2'를 숫자로 변환한 다음 6 * 2를 곱하여 12가 되었습니다.\n\n반면에 명시적 타입 강제 변환은 값의 타입을 수동으로 변환해야 하는 경우에 사용하는 방법입니다.\n\n```js\nconsole.log(1 + parseInt('6'));\n```\n\n이 예시에서는 parseInt 함수를 사용하여 '6'를 숫자로 변환한 후 + 연산자를 사용하여 1과 6을 더합니다.\n\n\n\n# 10. NaN이란 무엇인가요? 그리고 값이 NaN인지 확인하는 방법은 무엇인가요?\n\nNaN은 \"숫자가 아님(Not a Number)\"을 의미하며, JavaScript에서 숫자 연산이나 변환 결과로 의미있는 숫자 값을 생성하지 못할 때 발생합니다. 따라서 숫자 연산이나 변환에서 숫자가 아닌 값이 나오면 결과값은 NaN이 됩니다.\n\n```js\nlet a;\n\nconsole.log(parseInt('abc')); // NaN\nconsole.log(parseInt(null)); // NaN\nconsole.log(parseInt(undefined)); // NaN\nconsole.log(parseInt(++a)); // NaN\nconsole.log(parseInt({} * 10)); // NaN\nconsole.log(parseInt('abc' - 2)); // NaN\nconsole.log(parseInt(0 / 0)); // NaN\nconsole.log(parseInt('10a' * 10)); // NaN\n```\n\nJavaScript에는 값이 NaN인지 확인하는 isNaN 메서드가 내장되어 있습니다. 그러나 이 함수는 특이한 동작을 보입니다.\n\n\n\n```js\nconsole.log(isNaN()); // true\nconsole.log(isNaN(undefined)); // true\nconsole.log(isNaN({})); // true\nconsole.log(isNaN(String('a'))); // true\nconsole.log(isNaN(() =\u003e { })); // true\n```\n\n모든 이 console.log 문은 값으로 NaN이 아닌 경우에도 true를 반환합니다.\n\nES6에서는 값이 NaN인지를 진정으로 확인하는 Number.isNaN 메서드를 사용하는 것이 좋습니다. 또는 JavaScript에서 NaN은 자신과 일치하지 않는 유일한 값이기 때문에 이 문제를 확인하기 위한 사용자 지정 도우미 함수를 만들 수 있습니다.\n\n```js\nfunction checkIfNaN(value) {\n  return value !== value;\n}\n```\n\n\n\n# 11. 값이 배열인지 어떻게 판단할 수 있을까요?\n\nArray.isArray 메소드를 사용하여 값이 배열인지 확인할 수 있습니다. 배열이 인수로 전달되면 true를 반환하고, 그렇지 않으면 false를 반환합니다.\n\n```js\nconsole.log(Array.isArray(5));  // false\nconsole.log(Array.isArray(\"\")); // false\nconsole.log(Array.isArray()); // false\nconsole.log(Array.isArray(null)); // false\nconsole.log(Array.isArray({ length: 5 })); // false\n\nconsole.log(Array.isArray([])); // true\n```\n\n이 방법이 지원되지 않는 환경이라면, 폴리필을 구현할 수도 있습니다.\n\n\n\n```js\nfunction isArray(value){\n return Object.prototype.toString.call(value) === \"[object Array]\"\n}\n```\n\n물론 전통적인 방법도 사용할 수 있어요:\n\n```js\nlet a = []\nif (a instanceof Array) {\n  console.log('is an array')\n} else {\n  console.log('Non-Arrays')\n}\n```\n\n# 12. 객체에 속성이 존재하는지 확인하는 방법은 무엇인가요?\n\n\n\n객체에 특정 속성이 존재하는지 확인하는 세 가지 방법이 있어요.\n\n첫 번째 방법은 in 연산자를 사용하는 것이에요:\n\n```js\nconst o = { \n  \"prop\" : \"rabbit\",\n  \"prop2\" : \"tiger\"\n};\n\nconsole.log(\"prop\" in o); // true\nconsole.log(\"prop1\" in o); // false\n```\n\n두 번째 방법은 hasOwnProperty 메서드를 사용하는 것이에요. hasOwnProperty() 메서드는 객체가 지정된 속성을 직접 속성으로 가지고 있는지 여부를 나타내는 부울 값(true 또는 false)을 반환해줘요.\n\n\n\n```js\r\nconsole.log(o.hasOwnProperty(\"prop2\")); // true\nconsole.log(o.hasOwnProperty(\"prop1\")); // false\r\n```\n\n세 번째 방법은 괄호 표기법 obj['prop']를 사용하는 것입니다. 속성이 존재하면 해당 속성의 값을 반환하고, 그렇지 않으면 undefined를 반환합니다.\n\n```js\r\nconsole.log(o[\"prop\"]); // \"rabbit\"\nconsole.log(o[\"prop1\"]); // undefined\r\n```\n\n더 많은 내용은 PlainEnglish.io에서 확인할 수 있습니다.\n\n\n\n우리의 무료 주간 소식지 구독하세요. Twitter, LinkedIn, YouTube, Discord를 팔로우해보세요.","ogImage":{"url":"/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png"},"coverImage":"/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png","tag":["Tech"],"readingTime":14},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e제 3 부: 자바스크립트에 대해 반드시 알아야 할 일반 지식 포인트 목록\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-12UsefulJavaScriptInterviewTips_0.png\" alt=\"자바스크립트에 대해 알아야 할 것들\"\u003e\u003c/p\u003e\n\u003cp\u003e이 시리즈의 기사에서는 자바스크립트에 대해 반드시 알아야 할 일반 지식 포인트 목록을 정리했습니다. 이는 면접을 볼 때나 매일 개발할 때 큰 자신감을 줄 것입니다.\u003c/p\u003e\n\u003cp\u003e이전 기사에서는 일반 지식 포인트를 나열했으며 다음 링크를 클릭하여 확인할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e1. 'Set' 객체는 무엇이며 어떻게 작동하나요?\u003c/h1\u003e\n\u003cp\u003eSet 객체를 사용하면 원시 값이든 객체 참조든 어떠한 유형의 고유한 값도 저장할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eSet 생성자를 사용하여 Set 인스턴스를 만들 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e set1 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e set2 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"b\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"c\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"d\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"d\"\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\"e\"\u003c/span\u003e]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSet 인스턴스에 새 값을 추가하려면 add 메서드를 사용할 수 있습니다. add 메서드는 Set 객체를 반환하기 때문에 여러 개의 add 호출을 연결할 수 있습니다. Set 객체에 값이 이미 존재한다면 다시 추가되지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eset2.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"f\"\u003c/span\u003e);\nset2.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"g\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"h\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"i\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"j\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"k\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"k\"\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e특정 값이 Set 인스턴스에 있는지 확인하려면 has 메서드를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eset2.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"a\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\nset2.\u003cspan class=\"hljs-title function_\"\u003ehas\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"z\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSet 인스턴스의 길이를 얻기 위해 size 속성을 사용할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eset2.\u003cspan class=\"hljs-property\"\u003esize\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 10을 반환합니다\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모든 데이터를 Set에서 제거할 때 clear 메소드를 사용할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eset2.\u003cspan class=\"hljs-title function_\"\u003eclear\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e배열에서 중복된 요소를 제거하는 데 Set 객체를 사용할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e numbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e uniqueNums = [...\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e(numbers)]; \u003cspan class=\"hljs-comment\"\u003e// [1,2,3,4,5,6,7,8]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e2. 콜백 함수란 무엇인가요?\u003c/h2\u003e\n\u003cp\u003e콜백 함수는 다른 코드의 인자로 전달되어 실행 가능한 코드 조각입니다. 이 함수의 목적은 필요할 때 수신 코드에 의해 편리한 시간에 호출되도록 하는 것입니다.\u003c/p\u003e\n\u003cp\u003e자바스크립트에서 함수는 객체의 한 유형입니다. 객체처럼 함수도 다른 함수에게 인수로 전달될 수 있습니다. 따라서 다른 함수의 인수로 전달되는 함수는 콜백 함수라고 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e btnAdd = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'btnAdd'\u003c/span\u003e);\n\nbtnAdd.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'click'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eclickCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 아무 일도 하지 않음\u003c/span\u003e\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서는 id가 btnAdd인 요소의 클릭 이벤트를 기다리고 있습니다. 클릭이 발생하면 clickCallback 함수가 실행됩니다. 콜백 함수는 특정 데이터나 이벤트에 기능을 추가합니다.\u003c/p\u003e\n\u003cp\u003e배열의 reduce, filter, map 메서드는 매개변수로 콜백 함수를 요구합니다. 콜백의 좋은 비유는 누군가에게 전화를 걸어서, 그들이 받지 않으면 메시지를 남기고 전화 받기를 기대하는 것입니다. 누군가에게 전화를 거는 행위나 메시지를 남기는 것이 이벤트나 데이터이며, 콜백은 나중에 발생할 기대되는 작업입니다.\u003c/p\u003e\n\u003ch1\u003e3. ES6 모듈이란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e모듈은 코드베이스를 여러 파일로 분할하여 유지 보수성을 향상시키고 모든 코드를 하나의 큰 파일에 모두 가지고 있지 않도록 해줍니다. ES6 이전에는 두 가지 인기있는 모듈 시스템이 있었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCommonJS-Node.js\u003c/li\u003e\n\u003cli\u003eAMD (비동기 모듈 정의) - 브라우저\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e기본적으로 모듈을 사용하는 것은 매우 간단합니다. import는 다른 파일에서 기능이나 여러 기능 또는 값을 검색하는 데 사용되며, export는 파일에서 기능이나 여러 기능 또는 값을 노출하는 데 사용됩니다.\u003c/p\u003e\n\u003ch2\u003e내보내기\u003c/h2\u003e\n\u003cp\u003eES5(CommonJS) 사용\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ES5(CommonJS)를 사용하여 - helpers.js\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eisNull\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e val === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eisUndefined\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e val === \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eisNullOrUndefined\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisNull\u003c/span\u003e(val) || \u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisUndefined\u003c/span\u003e(val);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eES6 모듈 사용\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Using ES6 Modules - helpers.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisNull\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e){\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e val === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisUndefined\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e val === \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisNullOrUndefined\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisNull\u003c/span\u003e(val) || \u003cspan class=\"hljs-title function_\"\u003eisUndefined\u003c/span\u003e(val);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 파일에서 함수 가져오기\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//ES5 (CommonJS) - index.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e helpers = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./helpers.js'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// helpers는 객체임\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isNull = helpers.\u003cspan class=\"hljs-property\"\u003eisNull\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isUndefined = helpers.\u003cspan class=\"hljs-property\"\u003eisUndefined\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isNullOrUndefined = helpers.\u003cspan class=\"hljs-property\"\u003eisNullOrUndefined\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 또는 환경이 구조 분해를 지원하는 경우\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { isNull, isUndefined, isNullOrUndefined } = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./helpers.js'\u003c/span\u003e);\n-------------------------------------------------------\n\u003cspan class=\"hljs-comment\"\u003e// ES6 Modules - index.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e helpers \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./helpers.js'\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// helpers는 객체임\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 또는 \u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { isNull, isUndefined, isNullOrUndefined \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e isValid } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./helpers.js'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// \"as\"를 사용하여 명명된 내보내기 이름 변경\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e파일에서 단일 함수 또는 기본 내보내기 내보내기\u003c/p\u003e\n\u003cp\u003eES5 (CommonJS)\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ES5 (CommonJS) - index.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHelpers\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisNull\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e val === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisUndefined\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e val === \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisNullOrUndefined\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisNull\u003c/span\u003e(val) || \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisUndefined\u003c/span\u003e(val);\n  }\n}\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eHelpers\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eES6 Modules을 사용하는 예시\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// using ES6 Modules - helpers.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHelpers\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisNull\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e val === \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisUndefined\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e val === \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisNullOrUndefined\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisNull\u003c/span\u003e(val) || \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisUndefined\u003c/span\u003e(val);\n  }\n}\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHelpers\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 파일에서 함수를 한 개 가져오기\u003c/p\u003e\n\u003cp\u003eES5(CommonJS)를 사용하는 방법\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ES5(CommonJS) - index.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHelpers\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./helpers.js'\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eHelpers\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisNull\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eES6 모듈 사용법\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHelpers\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'.helpers.js'\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eHelpers\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisNull\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e4. Promise이 무엇인가요?\u003c/h2\u003e\n\u003cp\u003ePromise은 비동기 프로그래밍의 해결책입니다. 구문적으로 Promise은 비동기 작업의 결과를 얻을 수 있는 객체입니다. 개념적으로 일정 기간이 지난 후 결과를 제공할 것을 약속하는 것을 나타냅니다. Promise에는 세 가지 상태가 있습니다: pending(대기 중), fulfilled(이행됨) 및 rejected(거부됨). 상태가 변경되면 변경된 상태가 유지됩니다. Promise 인스턴스를 생성한 후에는 즉시 실행됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efs.\u003cspan class=\"hljs-title function_\"\u003ereadFile\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'somefile.txt'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ee, data\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e);\n  }\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 콜백 안에 또 다른 비동기 작업이 있다면, 문제가 생길 수 있어요. 코드가 엉망이 되고 가독성이 떨어질 거예요. 이를 '콜백 지옥'이라고 해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 콜백 지옥\u003c/span\u003e\nfs.\u003cspan class=\"hljs-title function_\"\u003ereadFile\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'somefile.txt'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ee, data\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e//여기에 코드 작성\u003c/span\u003e\n  fs.\u003cspan class=\"hljs-title function_\"\u003ereaddir\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'directory'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ee, files\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e//여기에 코드 작성\u003c/span\u003e\n    fs.\u003cspan class=\"hljs-title function_\"\u003emkdir\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'directory'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e//여기에 코드 작성\u003c/span\u003e\n    })\n  })\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드에서 promise를 사용하면 더 읽기 쉽고 이해하기 쉽고 유지보수하기 좋아질 거예요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003epromReadFile\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'file/path'\u003c/span\u003e)\n  .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epromReaddir\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'directory'\u003c/span\u003e);\n  })\n  .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003epromMkdir\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'directory'\u003c/span\u003e);\n  })\n  .\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e);\n  })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e약속은 세 가지 다른 상태를 가집니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e대기 중(pending): 이니셜 상태로, 충족 또는 거부되기 전의 상태입니다.\u003c/li\u003e\n\u003cli\u003e충족됨(fulfilled): 작업이 성공적으로 완료된 상태입니다.\u003c/li\u003e\n\u003cli\u003e거부됨(rejected): 작업이 실패한 상태입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e대기 중인 객체는 충족됨/거부됨 상태를 발생시키며, 해당 상태 처리 메소드에 해결된 값/에러 메시지를 전달합니다. 작업이 성공적으로 완료되면, Promise 객체의 then 메소드가 호출됩니다. 그렇지 않으면 catch 메소드가 트리거됩니다. 예를 들면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myFirstPromise = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve, reject\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e){\n        \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Success!\"\u003c/span\u003e); \n    }, \u003cspan class=\"hljs-number\"\u003e250\u003c/span\u003e);\n});\n\nmyFirstPromise.\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Yay! \"\u003c/span\u003e + data);\n}).\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u003e\u003c/span\u003e {...});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e5. async/await이란 무엇이며 어떻게 동작합니까?\u003c/h1\u003e\n\u003cp\u003easync/await은 JavaScript에서 비동기 또는 블로킹 코드를 작성하는 새로운 방법입니다. 이는 Promises 위에 구축되어 있으며 비동기 코드의 가독성과 간결성을 높여줍니다.\u003c/p\u003e\n\u003cp\u003easync/await은 JavaScript에서 비동기 또는 블로킹 코드를 작성하는 새로운 방법입니다. Promises 및 콜백에 비해 높은 가독성과 간결성을 제공합니다. 그러나 이 기능을 사용하기 전에 Promises의 기본을 배우는 것이 필요합니다. 앞에서 언급한 대로 async/await은 Promises 위에 구축되어 있으므로 여전히 내부적으로 Promises를 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e기능 \u003cspan class=\"hljs-title function_\"\u003ecallApi\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"url/to/api/endpoint\"\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresp\u003c/span\u003e =\u003e\u003c/span\u003e resp.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n    .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// \"data\"와 무언가를 처리합니다\u003c/span\u003e\n    }).\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// \"err\"과 무언가를 처리합니다\u003c/span\u003e\n    });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003easync/await\u003c/p\u003e\n\u003cp\u003easync/await에서는 try/catch 구문을 사용하여 예외를 catch합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecallApi\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e resp = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"url/to/api/endpoint\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e resp.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e();\n    \u003cspan class=\"hljs-comment\"\u003e// \"data\"와 무언가를 처리합니다\u003c/span\u003e\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n    \u003cspan class=\"hljs-comment\"\u003e// \"err\"과 무언가를 처리합니다\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참고: 'async' 키워드를 사용하여 함수를 선언하면 암시적으로 Promise가 반환됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egiveMeOne\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title function_\"\u003egiveMeOne\u003c/span\u003e()\n  .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(num); \u003cspan class=\"hljs-comment\"\u003e// 1을 출력합니다\u003c/span\u003e\n  });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참고: 'await' 키워드는 오직 async 함수 내에서만 사용할 수 있습니다. 어떤 비동기 함수에서도 'await' 키워드를 사용하면 오류가 발생합니다. 'await' 키워드는 Promise가 반환될 때까지 오른쪽 표현식을 기다린 후 다음 코드 줄을 실행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egiveMeOne\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetOne\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e num = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egiveMeOne\u003c/span\u003e();\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(num);\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e);\n  }\n}\n\u003cspan class=\"hljs-comment\"\u003e// Uncaught SyntaxError: await is only valid in async function\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetTwo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e num1 = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egiveMeOne\u003c/span\u003e(); \n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e num2 = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egiveMeOne\u003c/span\u003e(); \n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e num1 + num2;\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e);\n  }\n}\n\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetTwo\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e6. 스프레드 연산자와 나머지 연산자의 차이는 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e스프레드 연산자는 세 개의 점 ...으로 나타내며, 배열을 쉼표로 구분된 인수의 시퀀스로 변환할 수 있습니다. 좀 더 간단히 말하면, 큰 요소를 작은 요소로 나누어주는 것과 같습니다. 마치 손바닥 타격이 단단한 물체를 분산시키는 것처럼 말이죠.\u003c/p\u003e\n\u003cp\u003e나머지 연산자도 세 개의 점 ...로 표시되지만, 스프레드 연산자와 비슷해 보일 수 있지만, 배열과 객체의 해체에 사용됩니다. 어느 정도로는 스프레드 연산자의 반대 역할을 합니다. 스프레드 연산자는 배열을 여러 요소로 '펼치는' 반면, 나머지 연산자는 여러 요소를 '수집'하고 그것들을 한 요소로 '압축'합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea, b\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e a + b;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nums = [\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sum = \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(...nums);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(sum);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예에서는 add 함수를 호출할 때 전개 연산자를 사용하여 nums 배열을 확장했습니다. 따라서 매개변수 a의 값은 5이고, 매개변수 b의 값은 6이므로 합계는 11이 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e...rest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e rest.\u003cspan class=\"hljs-title function_\"\u003ereduce\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003etotal, current\u003c/span\u003e) =\u003e\u003c/span\u003e total + current);\n};\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 3\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 15\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예에서는 임의의 개수의 매개변수를 수용하고 모두 더한 다음 총합을 반환하는 add 함수가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [first, ...others] = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(first); \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(others); \u003cspan class=\"hljs-comment\"\u003e// [2, 3, 4, 5]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서는 나머지 배열 값을 추출하여 다른 배열에 넣는 데 rest 연산자를 사용합니다. 첫 번째 항목을 제외하고 나머지 값을 모두 가져올 수 있어요.\u003c/p\u003e\n\u003ch1\u003e7. 기본 매개변수란?\u003c/h1\u003e\n\u003cp\u003e기본 매개변수는 JavaScript에서 기본 변수를 정의하는 새로운 방법으로, ES6 또는 ECMAScript 2015에서 사용할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//ES5 버전\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea, b\u003c/span\u003e) {\n  a = a || \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  b = b || \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e a + b;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e//ES6 버전\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, b = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e a + b;\n}\n\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 1을 반환\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기본 매개변수에서 해체 할당을 사용할 수도 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetFirst\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e[first, ...rest] = [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e first;\n}\n\n\u003cspan class=\"hljs-title function_\"\u003egetFirst\u003c/span\u003e();  \u003cspan class=\"hljs-comment\"\u003e// 0\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003egetFirst\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e]);  \u003cspan class=\"hljs-comment\"\u003e// 10\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetArr\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ nums } = { nums: [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e] }\u003c/span\u003e){\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e nums;\n}\n\u003cspan class=\"hljs-title function_\"\u003egetArr\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// [1, 2, 3, 4]\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003egetArr\u003c/span\u003e({\u003cspan class=\"hljs-attr\"\u003enums\u003c/span\u003e:[\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]}); \u003cspan class=\"hljs-comment\"\u003e// [5,4,3,2,1]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이전에 정의된 매개변수를 나중에 정의된 매개변수보다 먼저 사용할 수도 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoSomethingWithValue\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue = \u003cspan class=\"hljs-string\"\u003e\"Hello World\"\u003c/span\u003e, callback = () =\u003e { \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.log(value) }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003ecallback\u003c/span\u003e();\n}\n\u003cspan class=\"hljs-title function_\"\u003edoSomethingWithValue\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e//\"Hello World\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e8. 래퍼 객체란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e이제 JavaScript의 데이터 유형을 검토해봅시다. JavaScript 데이터 유형은 기본 유형과 참조 유형으로 나뉩니다.\u003c/p\u003e\n\u003cp\u003e기본 유형: Undefined, Null, Boolean, Number, String, Symbol, BigInt\u003c/p\u003e\n\u003cp\u003e참조 유형: Object, Array, Date, RegExp 등. 간단히 말해, 이들은 객체입니다.\u003c/p\u003e\n\u003cp\u003e참조 유형 중에는 프리미티브 유형에는 없는 메소드와 속성이 있습니다. 그러나 종종 다음과 같은 코드를 만날 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e name = \u003cspan class=\"hljs-string\"\u003e\"maxwell\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e name); \u003cspan class=\"hljs-comment\"\u003e// \"string\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(name.\u003cspan class=\"hljs-title function_\"\u003etoUpperCase\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// \"MAXWELL\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이름 타입은 문자열이며 프리미티브 유형에 속합니다. 따라서 속성이나 메소드가 없습니다. 그러나 이 예제에서 toUpperCase() 메소드를 호출하는 것은 에러를 발생시키지 않고 문자열의 대문자 값을 반환합니다.\u003c/p\u003e\n\u003cp\u003e그 이유는 프리미티브 유형의 값이 일시적으로 객체로 변환되거나 강제 변환되기 때문에, 이름 변수의 동작이 객체와 유사합니다. null과 undefined를 제외한 모든 프리미티브 유형에는 String, Number, Boolean, Symbol 및 BigInt의 래퍼 객체가 있습니다. 이 경우, name.toUpperCase()은 '백그라운드에서' 다음과 같이 보입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(name).\u003cspan class=\"hljs-title function_\"\u003etoUpperCase\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// \"MAXWELL\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e속성에 접근하거나 메소드를 호출한 후에, 새로 생성된 객체는 즉시 폐기됩니다.\u003c/p\u003e\n\u003ch2\u003e9. 암시적 형 변환과 명시적 형 변환의 차이점은 무엇인가요?\u003c/h2\u003e\n\u003cp\u003e암시적 형 변환은 값의 형태를 다른 형태로 자동으로 변환하는 방법으로, 수동 개입 없이 자동으로 처리됩니다.\u003c/p\u003e\n\u003cp\u003e아래의 예시를 가정해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e'6'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 16\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e + \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e * \u003cspan class=\"hljs-string\"\u003e'2'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 12\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e첫 번째 \u003ccode\u003econsole.log\u003c/code\u003e 문의 결과는 16입니다. 다른 언어에서는 컴파일 오류가 발생할 수 있지만 JavaScript에서는 1이 문자열로 변환되고 그 후 + 연산자와 연결됩니다. 우리는 아무것도 하지 않았습니다. JavaScript가 자동으로 처리해 주었습니다.\u003c/p\u003e\n\u003cp\u003e두 번째 \u003ccode\u003econsole.log\u003c/code\u003e 문의 결과는 1입니다. JavaScript에서 false는 0으로, true는 1로 변환됩니다. 따라서 결과는 1이 됩니다.\u003c/p\u003e\n\u003cp\u003e세 번째 console.log 문의 결과는 12입니다. '2'를 숫자로 변환한 다음 6 * 2를 곱하여 12가 되었습니다.\u003c/p\u003e\n\u003cp\u003e반면에 명시적 타입 강제 변환은 값의 타입을 수동으로 변환해야 하는 경우에 사용하는 방법입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e + \u003cspan class=\"hljs-built_in\"\u003eparseInt\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'6'\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서는 parseInt 함수를 사용하여 '6'를 숫자로 변환한 후 + 연산자를 사용하여 1과 6을 더합니다.\u003c/p\u003e\n\u003ch1\u003e10. NaN이란 무엇인가요? 그리고 값이 NaN인지 확인하는 방법은 무엇인가요?\u003c/h1\u003e\n\u003cp\u003eNaN은 \"숫자가 아님(Not a Number)\"을 의미하며, JavaScript에서 숫자 연산이나 변환 결과로 의미있는 숫자 값을 생성하지 못할 때 발생합니다. 따라서 숫자 연산이나 변환에서 숫자가 아닌 값이 나오면 결과값은 NaN이 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a;\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eparseInt\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'abc'\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// NaN\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eparseInt\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// NaN\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eparseInt\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// NaN\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eparseInt\u003c/span\u003e(++a)); \u003cspan class=\"hljs-comment\"\u003e// NaN\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eparseInt\u003c/span\u003e({} * \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// NaN\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eparseInt\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'abc'\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// NaN\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eparseInt\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e / \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// NaN\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eparseInt\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'10a'\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// NaN\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJavaScript에는 값이 NaN인지 확인하는 isNaN 메서드가 내장되어 있습니다. 그러나 이 함수는 특이한 동작을 보입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eisNaN\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eisNaN\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eisNaN\u003c/span\u003e({})); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eisNaN\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'a'\u003c/span\u003e))); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-built_in\"\u003eisNaN\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e { })); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모든 이 console.log 문은 값으로 NaN이 아닌 경우에도 true를 반환합니다.\u003c/p\u003e\n\u003cp\u003eES6에서는 값이 NaN인지를 진정으로 확인하는 Number.isNaN 메서드를 사용하는 것이 좋습니다. 또는 JavaScript에서 NaN은 자신과 일치하지 않는 유일한 값이기 때문에 이 문제를 확인하기 위한 사용자 지정 도우미 함수를 만들 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003echeckIfNaN\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e value !== value;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e11. 값이 배열인지 어떻게 판단할 수 있을까요?\u003c/h1\u003e\n\u003cp\u003eArray.isArray 메소드를 사용하여 값이 배열인지 확인할 수 있습니다. 배열이 인수로 전달되면 true를 반환하고, 그렇지 않으면 false를 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisArray\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e));  \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisArray\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisArray\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisArray\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisArray\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003elength\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e })); \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisArray\u003c/span\u003e([])); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 방법이 지원되지 않는 환경이라면, 폴리필을 구현할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisArray\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e){\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(value) === \u003cspan class=\"hljs-string\"\u003e\"[object Array]\"\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e물론 전통적인 방법도 사용할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = []\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (a \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'is an array'\u003c/span\u003e)\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Non-Arrays'\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e12. 객체에 속성이 존재하는지 확인하는 방법은 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e객체에 특정 속성이 존재하는지 확인하는 세 가지 방법이 있어요.\u003c/p\u003e\n\u003cp\u003e첫 번째 방법은 in 연산자를 사용하는 것이에요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e o = { \n  \u003cspan class=\"hljs-string\"\u003e\"prop\"\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e\"rabbit\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"prop2\"\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e\"tiger\"\u003c/span\u003e\n};\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"prop\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e o); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"prop1\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e o); \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 번째 방법은 hasOwnProperty 메서드를 사용하는 것이에요. hasOwnProperty() 메서드는 객체가 지정된 속성을 직접 속성으로 가지고 있는지 여부를 나타내는 부울 값(true 또는 false)을 반환해줘요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(o.\u003cspan class=\"hljs-title function_\"\u003ehasOwnProperty\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"prop2\"\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(o.\u003cspan class=\"hljs-title function_\"\u003ehasOwnProperty\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"prop1\"\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e세 번째 방법은 괄호 표기법 obj['prop']를 사용하는 것입니다. 속성이 존재하면 해당 속성의 값을 반환하고, 그렇지 않으면 undefined를 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(o[\u003cspan class=\"hljs-string\"\u003e\"prop\"\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// \"rabbit\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(o[\u003cspan class=\"hljs-string\"\u003e\"prop1\"\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e더 많은 내용은 PlainEnglish.io에서 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e우리의 무료 주간 소식지 구독하세요. Twitter, LinkedIn, YouTube, Discord를 팔로우해보세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-12UsefulJavaScriptInterviewTips"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>