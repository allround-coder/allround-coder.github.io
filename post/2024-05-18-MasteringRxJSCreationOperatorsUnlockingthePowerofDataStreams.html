<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>RxJS Creation Operators 마스터하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="RxJS Creation Operators 마스터하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="RxJS Creation Operators 마스터하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams" data-gatsby-head="true"/><meta name="twitter:title" content="RxJS Creation Operators 마스터하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-18 22:03" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">RxJS Creation Operators 마스터하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="RxJS Creation Operators 마스터하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 18, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>반응형 프로그래밍은 현대 웹 개발에서 중요한 기반 기술이 되었으며 비동기 데이터 스트림을 처리하는 견고한 방법을 제공합니다. RxJS 또는 JavaScript용 반응형 익스텐션은 JavaScript에서 반응형 프로그래밍을 구현하는 가장 인기있는 라이브러리 중 하나입니다. 생성 연산자는 여러 기능 중에서도 관찰 가능한 스트림을 생성하는 데 필수적인 도구로 강조됩니다. 이 블로그 포스트에서는 다양한 RxJS 생성 연산자, 작동 방식 및 각각에 대한 실제 사용 사례를 살펴보겠습니다.</p>
<p><img src="/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png" alt="image"></p>
<h2>RxJS 생성 연산자란?</h2>
<p>이러한 연산자는 다양한 데이터 소스에서 새로운 Observables를 생성합니다. 이러한 연산자는 개발자들이 작업할 데이터 스트림의 소스를 정의할 수 있도록 해주기 때문에 중요합니다. 이러한 연산자를 이해하는 것은 RxJS의 전체 기능을 최대한 활용하는 데 필수적입니다.</p>
<div class="content-ad"></div>
<h1>Creation Operators 목록</h1>
<p>(참고: “⭐ — 일반적으로 사용됨”)</p>
<ul>
<li>⭐ajax: Ajax 요청을 위한 observable을 생성하는 데 사용됩니다.</li>
<li>bindCallback: 콜백 스타일 함수를 observable로 변환합니다.</li>
<li>bindNodeCallback: bindCallback과 유사하지만, Node.js 스타일 콜백(error-first)을 위한 것입니다.</li>
<li>defer: observable의 생성을 구독 지점까지 지연시킵니다.</li>
<li>empty: 어떤 값도 방출하지 않고 즉시 완료되는 observable을 생성합니다.</li>
<li>⭐from: 다양한 다른 객체 및 데이터 유형을 observable로 변환합니다.</li>
<li>⭐fromEvent: DOM 이벤트 대상 또는 Node.js EventEmitter에서 이벤트를 방출하는 observable을 생성합니다.</li>
<li>fromEventPattern: 주어진 addHandler/removeHandler 함수 쌍에서 observable을 생성합니다.</li>
<li>generate: 제공된 반복 함수에 기반하여 시간이 지남에 따라 값들을 생성합니다.</li>
<li>⭐interval: 지정된 간격에서 증가하는 숫자를 방출하는 observable을 생성합니다.</li>
<li>⭐of: 값의 시퀀스를 observable 시퀀스로 방출합니다.</li>
<li>range: 지정된 범위 내의 숫자 시퀀스를 방출합니다.</li>
<li>throwError: 오류를 방출하는 observable을 생성합니다.</li>
<li>timer: 지정된 지연 후 단일 값을 방출합니다.</li>
<li>iif: 두 가지 가능한 원본 observable 중 하나에 조건부로 구독합니다.</li>
</ul>
<p>이제 Creation Operator를 하나씩 검토하고 예제를 통해 학습하겠습니다.</p>
<div class="content-ad"></div>
<h1>Ajax</h1>
<p>XMLHttpRequest API를 사용하여 HTTP 요청을 보냅니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 실시간 사용 사례: 요청에서 반환되는 응답 객체를 방출하는 Observable */</span>
<span class="hljs-keyword">import</span> { ajax } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/ajax'</span>;

<span class="hljs-keyword">const</span> githubUsers = <span class="hljs-string">`https://api.github.com/users?per_page=2`</span>;
<span class="hljs-keyword">const</span> users = <span class="hljs-title function_">ajax</span>(githubUsers);

<span class="hljs-keyword">const</span> subscribe = users.<span class="hljs-title function_">subscribe</span>(
  <span class="hljs-function"><span class="hljs-params">res</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res),
  <span class="hljs-function"><span class="hljs-params">err</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err)
);
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 실시간 사용 사례: 요청에서 반환되는 응답 객체의 json 키만 방출하는 Observable */</span>
<span class="hljs-keyword">import</span> { ajax } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/ajax'</span>;

<span class="hljs-keyword">const</span> githubUsers = <span class="hljs-string">`https://api.github.com/users?per_page=2`</span>;
<span class="hljs-keyword">const</span> users = ajax.<span class="hljs-title function_">getJSON</span>(githubUsers);

<span class="hljs-keyword">const</span> subscribe = users.<span class="hljs-title function_">subscribe</span>(
  <span class="hljs-function"><span class="hljs-params">res</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res),
  <span class="hljs-function"><span class="hljs-params">err</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err)
);
</code></pre>
<div class="content-ad"></div>
<h1>bindCallback</h1>
<p>콜백 스타일의 함수를 Observable로 변환합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 실시간 사용 사례: jQuery의 getJSON을 Observable API로 변환하는 방법 */</span>

<span class="hljs-keyword">import</span> { bindCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> jQuery <span class="hljs-keyword">from</span> <span class="hljs-string">'jquery'</span>;

<span class="hljs-keyword">const</span> getJSONAsObservable = <span class="hljs-title function_">bindCallback</span>(jQuery.<span class="hljs-property">getJSON</span>);
<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">getJSONAsObservable</span>(<span class="hljs-string">'/my/url'</span>);
result.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">x</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x), <span class="hljs-function"><span class="hljs-params">e</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e));
</code></pre>
<h1>bindNodeCallback</h1>
<div class="content-ad"></div>
<ul>
<li>노드 스타일 콜백 함수를 Observable로 변환합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 실시간 사용 사례: 파일 시스템에서 파일 읽어오기 및 데이터를 Observable로 얻기 */</span>
<span class="hljs-keyword">import</span> { bindNodeCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;

<span class="hljs-keyword">const</span> readFileAsObservable = <span class="hljs-title function_">bindNodeCallback</span>(fs.<span class="hljs-property">readFile</span>);
<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">readFileAsObservable</span>(<span class="hljs-string">'./roadNames.txt'</span>, <span class="hljs-string">'utf8'</span>);

result.<span class="hljs-title function_">subscribe</span>(
  <span class="hljs-function"><span class="hljs-params">x</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x), <span class="hljs-comment">// 파일 내용 처리</span>
  <span class="hljs-function"><span class="hljs-params">e</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e) <span class="hljs-comment">// 오류 처리</span>
);
</code></pre>
<ul>
<li><code>defer</code></li>
</ul>
<p>Subscriber가 Observable에 구독할 때까지 실행을 지연시키는 Observable를 생성합니다.</p>
<div class="content-ad"></div>
<p>RxJS에서 defer는 Observable을 생성하는 함수입니다. 주요 목적은 Observable이 구독될 때까지 Observable의 생성을 지연하는 것입니다. 이는 새로운 옵저버가 Observable을 구독할 때마다 설정 또는 초기화 논리가 실행되어야 하는 시나리오에서 유용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 실시간 사용 사례: `of`를 사용하여 난수 생성 */</span>
<span class="hljs-keyword">import</span> { <span class="hljs-keyword">of</span>, defer } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">const</span> randomOf$ = <span class="hljs-title function_">of</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>());

<span class="hljs-comment">// 랜덤 숫자 생성을 위해 `defer` 사용</span>
<span class="hljs-keyword">const</span> randomDefer$ = <span class="hljs-title function_">defer</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">of</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()));

<span class="hljs-comment">// `randomOf$`를 여러 번 구독</span>
randomOf$.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">randomNumber</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'랜덤 숫자 (of):'</span>, randomNumber));
randomOf$.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">randomNumber</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'랜덤 숫자 (of):'</span>, randomNumber));
randomOf$.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">randomNumber</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'랜덤 숫자 (of):'</span>, randomNumber));

<span class="hljs-comment">// `randomDefer$`를 여러 번 구독</span>
randomDefer$.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">randomNumber</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'랜덤 숫자 (defer):'</span>, randomNumber));
randomDefer$.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">randomNumber</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'랜덤 숫자 (defer):'</span>, randomNumber));
randomDefer$.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">randomNumber</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'랜덤 숫자 (defer):'</span>, randomNumber));
</code></pre>
<p>Output</p>
<pre><code class="hljs language-js">랜덤 숫자 (<span class="hljs-keyword">of</span>): <span class="hljs-number">0.123456789</span>
랜덤 숫자 (<span class="hljs-keyword">of</span>): <span class="hljs-number">0.123456789</span>
랜덤 숫자 (<span class="hljs-keyword">of</span>): <span class="hljs-number">0.123456789</span>
랜덤 숫자 (defer): <span class="hljs-number">0.987654321</span>
랜덤 숫자 (defer): <span class="hljs-number">0.654321987</span>
랜덤 숫자 (defer): <span class="hljs-number">0.123456789</span>
</code></pre>
<div class="content-ad"></div>
<h1>빈</h1>
<p>빈 Observable을 생성하고 즉시 완료 콜백을 호출합니다.</p>
<p>RxJS의 빈 연산자는 값을 방출하지 않고 즉시 완료되는 Observable을 생성합니다. 값이 방출될 필요가 없지만 완료를 신호해야 하는 경우에 유용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 실시간 사용 사례: 빈 Observable 생성 */</span>
<span class="hljs-keyword">import</span> { empty } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">const</span> emptyObservable$ = <span class="hljs-title function_">empty</span>();
<span class="hljs-comment">// 빈 Observable에 구독하기</span>
emptyObservable$.<span class="hljs-title function_">subscribe</span>({
  <span class="hljs-attr">next</span>: <span class="hljs-function">() =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'다음 값'</span>), <span class="hljs-comment">// 호출되지 않음</span>
  <span class="hljs-attr">complete</span>: <span class="hljs-function">() =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'완료됨'</span>) <span class="hljs-comment">// 즉시 호출됨</span>
});
</code></pre>
<div class="content-ad"></div>
<h1>from</h1>
<p>배열, 프로미스, 이터러블 객체 또는 Observable과 유사한 객체에서 Observable을 생성합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">from</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">const</span> arraySource = <span class="hljs-title function_">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]);
<span class="hljs-keyword">const</span> subscribe = arraySource.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">val</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val));
<span class="hljs-comment">//출력: 1, 2, 3, 4, 5</span>
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">from</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">const</span> source = <span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello World'</span>);
<span class="hljs-keyword">const</span> subscribe = source.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">val</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val));
<span class="hljs-comment">//출력: 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'</span>
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> numbers = <span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'Hello World'</span>)));
numbers.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
});
<span class="hljs-comment">//output: Hello World</span>
</code></pre>
<h1>fromEvent</h1>
<ul>
<li>이벤트에서 Observable을 생성합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 실시간 사용 사례: 사용자가 화면을 클릭할 때 시간 추적 */</span>
<span class="hljs-keyword">import</span> { fromEvent } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> { map } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;

<span class="hljs-keyword">const</span> source = <span class="hljs-title function_">fromEvent</span>(<span class="hljs-variable language_">document</span>, <span class="hljs-string">'click'</span>);
<span class="hljs-keyword">const</span> example = source.<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">event</span> =></span> event.<span class="hljs-property">timeStamp</span>));
<span class="hljs-keyword">const</span> subscribe = example.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">val</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`이벤트 시간: <span class="hljs-subst">${val / <span class="hljs-number">1000</span>}</span> 초`</span>));
</code></pre>
<div class="content-ad"></div>
<p>출력</p>
<pre><code class="hljs language-js">이벤트 시간: <span class="hljs-number">5.418900000000373</span> 초
이벤트 시간: <span class="hljs-number">7.552900000000372</span> 초
</code></pre>
<h1>fromEventPattern</h1>
<p>fromEventPattern은 이벤트를 반환하는 함수에서 Observable을 생성합니다. fromEventPattern을 사용하면 이벤트 처리기 함수를 등록하는 API를 Observable로 변환할 수 있습니다. fromEvent과 유사하지만 훨씬 유연합니다. fromEvent의 모든 사용 사례는 fromEventPattern으로 쉽게 처리할 수 있습니다.</p>
<div class="content-ad"></div>
<h1>생성</h1>
<p>함수를 기반으로 값을 생성하는 옵저버블을 생성합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 실시간 사용 사례: 숫자 시퀀스 생성 */</span>

<span class="hljs-keyword">import</span> { generate } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">generate</span>(<span class="hljs-number">0</span>, <span class="hljs-function"><span class="hljs-params">x</span> =></span> x &#x3C; <span class="hljs-number">3</span>, <span class="hljs-function"><span class="hljs-params">x</span> =></span> x + <span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-params">x</span> =></span> x);
result.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">x</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x));

<span class="hljs-comment">// 결과:</span>
<span class="hljs-comment">// 0</span>
<span class="hljs-comment">// 1</span>
<span class="hljs-comment">// 2</span>
</code></pre>
<h1>간격</h1>
<div class="content-ad"></div>
<p>일정한 간격으로 정수 시퀀스를 방출하는 Observable을 생성합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 실시간 사용 사례: 1초 간격으로 값 시퀀스를 방출 */</span>
<span class="hljs-keyword">import</span> { interval } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-comment">// 1초마다 시퀀스 값 방출</span>
<span class="hljs-keyword">const</span> source = <span class="hljs-title function_">interval</span>(<span class="hljs-number">1000</span>);
<span class="hljs-keyword">const</span> subscribe = source.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">val</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val));
<span class="hljs-comment">//결과: 0, 1, 2, 3, 4, 5....</span>
</code></pre>
<h1>of</h1>
<ul>
<li>지정된 값을 순서대로 방출하는 Observable을 생성합니다.</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">of</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-title function_">of</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)
  .<span class="hljs-title function_">subscribe</span>({
    <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-params">value</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'다음 값:'</span>, value),
    <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-params">err</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'에러 발생:'</span>, err),
    <span class="hljs-attr">complete</span>: <span class="hljs-function">() =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'완료'</span>),
  });

<span class="hljs-comment">// 결과</span>
<span class="hljs-comment">// 다음 값: 10</span>
<span class="hljs-comment">// 다음 값: 20</span>
<span class="hljs-comment">// 다음 값: 30</span>
<span class="hljs-comment">// 완료</span>
</code></pre>
<h1>range</h1>
<p>지정된 범위 내에서 숫자의 시퀀스를 방출하는 Observable을 생성합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 실시간 사용 사례: 1에서 10까지 순차적으로 방출 */</span>

<span class="hljs-keyword">import</span> { range } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">const</span> source = <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>);
<span class="hljs-keyword">const</span> example = source.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">val</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val));
<span class="hljs-comment">// 출력: 1,2,3,4,5,6,7,8,9,10</span>
</code></pre>
<div class="content-ad"></div>
<h1>throwError</h1>
<ul>
<li>구독 시 오류를 발생시키는 Observable을 생성합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 구독 시 오류 발생 */</span>
<span class="hljs-keyword">import</span> { throwError } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-comment">// 특정 값과 함께 오류를 발생시킵니다.</span>

<span class="hljs-keyword">const</span> source = <span class="hljs-title function_">throwError</span>(<span class="hljs-string">'오류 발생!'</span>);
<span class="hljs-comment">// 출력: 'Error: 오류 발생!'</span>

<span class="hljs-keyword">const</span> subscribe = source.<span class="hljs-title function_">subscribe</span>({
  <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-params">val</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val),
  <span class="hljs-attr">complete</span>: <span class="hljs-function">() =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'완료!'</span>),
  <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-params">val</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`오류: <span class="hljs-subst">${val}</span>`</span>)
});
</code></pre>
<h1>timer</h1>
<div class="content-ad"></div>
<ul>
<li>특정 시간 간격 후에 발행을 시작하고 정수 시퀀스를 발행하는 Observable를 생성합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">/* 실제 시나리오: 타이머는 1초 후에 발행을 시작하고 그 이후 매 2초마다 값을 발행합니다 */</span>

<span class="hljs-keyword">import</span> { timer } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-comment">/*
  timer 함수는 두 번째 인자를 가지며, 연속적으로 값들을 발행하는 빈도를 정의합니다.
  이 경우, 1초 후에 첫 번째 값을 발행하고 그 이후 2초마다 값을 발행합니다.
*/</span>
<span class="hljs-keyword">const</span> source = <span class="hljs-title function_">timer</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>);
<span class="hljs-comment">//출력: 0,1,2,3,4,5......</span>
<span class="hljs-keyword">const</span> subscribe = source.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function"><span class="hljs-params">val</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val));
</code></pre>
<h1>iif</h1>
<p>조건에 따라 함수의 출력을 발행하는 Observable를 생성합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">/* Observable에 대한 액세스 제어 */</span>

<span class="hljs-keyword">import</span> { iif, <span class="hljs-keyword">of</span>, <span class="hljs-variable constant_">EMPTY</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
 
<span class="hljs-keyword">let</span> accessGranted;
<span class="hljs-keyword">const</span> observableIfYouHaveAccess = <span class="hljs-title function_">iif</span>(
  <span class="hljs-function">() =></span> accessGranted,
  <span class="hljs-title function_">of</span>(<span class="hljs-string">'액세스가 허용된 것 같아요...'</span>),
  <span class="hljs-variable constant_">EMPTY</span>
);
 
accessGranted = <span class="hljs-literal">true</span>;
observableIfYouHaveAccess.<span class="hljs-title function_">subscribe</span>({
  <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-params">value</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value),
  <span class="hljs-attr">complete</span>: <span class="hljs-function">() =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'끝'</span>)
});
 
<span class="hljs-comment">// 출력:</span>
<span class="hljs-comment">// '액세스가 허용된 것 같아요...'</span>
<span class="hljs-comment">// '끝'</span>
 
accessGranted = <span class="hljs-literal">false</span>;
observableIfYouHaveAccess.<span class="hljs-title function_">subscribe</span>({
  <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-params">value</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value),
  <span class="hljs-attr">complete</span>: <span class="hljs-function">() =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'끝'</span>)
});
 
<span class="hljs-comment">// 출력:</span>
<span class="hljs-comment">// '끝'</span>
</code></pre>
<p>요약하면, RxJS Creation Operators는 JavaScript에서 반응형 프로그래밍의 기본 구성 요소입니다. 다양한 데이터 소스에서 Observable을 생성할 수 있게 해줌으로써, 이러한 연산자는 비동기 데이터 스트림을 효율적으로 처리할 수 있도록 개발자들을 지원합니다. API에서 데이터를 가져오는 ajax, 사용자 상호 작용에 반응하는 fromEvent, interval 및 timer를 사용하여 작업을 예약하는 등, 이러한 연산자들은 반응형 애플리케이션에서 데이터 흐름을 유연하고 강력하게 관리할 수 있는 방법을 제공합니다. 이러한 생성 연산자를 숙달하는 것은 RxJS의 모든 잠재력을 발휘하고 반응형 프로그래밍을 통한 반응형, 확장 가능하고 유지보수 가능한 애플리케이션을 구축하는 데 필수적입니다. 이 연산자들을 깊이 이해하고 그 기능을 실험하며, RxJS를 활용한 반응형 프로그래밍 마스터의 길에 나아가 보세요.</p>
<p>즐거운 코딩되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"RxJS Creation Operators 마스터하기","description":"","date":"2024-05-18 22:03","slug":"2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams","content":"\n\n반응형 프로그래밍은 현대 웹 개발에서 중요한 기반 기술이 되었으며 비동기 데이터 스트림을 처리하는 견고한 방법을 제공합니다. RxJS 또는 JavaScript용 반응형 익스텐션은 JavaScript에서 반응형 프로그래밍을 구현하는 가장 인기있는 라이브러리 중 하나입니다. 생성 연산자는 여러 기능 중에서도 관찰 가능한 스트림을 생성하는 데 필수적인 도구로 강조됩니다. 이 블로그 포스트에서는 다양한 RxJS 생성 연산자, 작동 방식 및 각각에 대한 실제 사용 사례를 살펴보겠습니다.\n\n![image](/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png)\n\n## RxJS 생성 연산자란?\n\n이러한 연산자는 다양한 데이터 소스에서 새로운 Observables를 생성합니다. 이러한 연산자는 개발자들이 작업할 데이터 스트림의 소스를 정의할 수 있도록 해주기 때문에 중요합니다. 이러한 연산자를 이해하는 것은 RxJS의 전체 기능을 최대한 활용하는 데 필수적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Creation Operators 목록\n\n(참고: “⭐ — 일반적으로 사용됨”)\n\n- ⭐ajax: Ajax 요청을 위한 observable을 생성하는 데 사용됩니다.\n- bindCallback: 콜백 스타일 함수를 observable로 변환합니다.\n- bindNodeCallback: bindCallback과 유사하지만, Node.js 스타일 콜백(error-first)을 위한 것입니다.\n- defer: observable의 생성을 구독 지점까지 지연시킵니다.\n- empty: 어떤 값도 방출하지 않고 즉시 완료되는 observable을 생성합니다.\n- ⭐from: 다양한 다른 객체 및 데이터 유형을 observable로 변환합니다.\n- ⭐fromEvent: DOM 이벤트 대상 또는 Node.js EventEmitter에서 이벤트를 방출하는 observable을 생성합니다.\n- fromEventPattern: 주어진 addHandler/removeHandler 함수 쌍에서 observable을 생성합니다.\n- generate: 제공된 반복 함수에 기반하여 시간이 지남에 따라 값들을 생성합니다.\n- ⭐interval: 지정된 간격에서 증가하는 숫자를 방출하는 observable을 생성합니다.\n- ⭐of: 값의 시퀀스를 observable 시퀀스로 방출합니다.\n- range: 지정된 범위 내의 숫자 시퀀스를 방출합니다.\n- throwError: 오류를 방출하는 observable을 생성합니다.\n- timer: 지정된 지연 후 단일 값을 방출합니다.\n- iif: 두 가지 가능한 원본 observable 중 하나에 조건부로 구독합니다.\n\n이제 Creation Operator를 하나씩 검토하고 예제를 통해 학습하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Ajax\n\nXMLHttpRequest API를 사용하여 HTTP 요청을 보냅니다.\n\n```js\n/* 실시간 사용 사례: 요청에서 반환되는 응답 객체를 방출하는 Observable */\nimport { ajax } from 'rxjs/ajax';\n\nconst githubUsers = `https://api.github.com/users?per_page=2`;\nconst users = ajax(githubUsers);\n\nconst subscribe = users.subscribe(\n  res =\u003e console.log(res),\n  err =\u003e console.error(err)\n);\n```\n\n```js\n/* 실시간 사용 사례: 요청에서 반환되는 응답 객체의 json 키만 방출하는 Observable */\nimport { ajax } from 'rxjs/ajax';\n\nconst githubUsers = `https://api.github.com/users?per_page=2`;\nconst users = ajax.getJSON(githubUsers);\n\nconst subscribe = users.subscribe(\n  res =\u003e console.log(res),\n  err =\u003e console.error(err)\n);\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# bindCallback\n\n콜백 스타일의 함수를 Observable로 변환합니다.\n\n```js\n/* 실시간 사용 사례: jQuery의 getJSON을 Observable API로 변환하는 방법 */\n\nimport { bindCallback } from 'rxjs';\nimport * as jQuery from 'jquery';\n\nconst getJSONAsObservable = bindCallback(jQuery.getJSON);\nconst result = getJSONAsObservable('/my/url');\nresult.subscribe(x =\u003e console.log(x), e =\u003e console.error(e));\n```\n\n# bindNodeCallback\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 노드 스타일 콜백 함수를 Observable로 변환합니다.\n\n```js\n/* 실시간 사용 사례: 파일 시스템에서 파일 읽어오기 및 데이터를 Observable로 얻기 */\nimport { bindNodeCallback } from 'rxjs';\nimport * as fs from 'fs';\n\nconst readFileAsObservable = bindNodeCallback(fs.readFile);\nconst result = readFileAsObservable('./roadNames.txt', 'utf8');\n\nresult.subscribe(\n  x =\u003e console.log(x), // 파일 내용 처리\n  e =\u003e console.error(e) // 오류 처리\n);\n```\n\n- `defer`\n\nSubscriber가 Observable에 구독할 때까지 실행을 지연시키는 Observable를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRxJS에서 defer는 Observable을 생성하는 함수입니다. 주요 목적은 Observable이 구독될 때까지 Observable의 생성을 지연하는 것입니다. 이는 새로운 옵저버가 Observable을 구독할 때마다 설정 또는 초기화 논리가 실행되어야 하는 시나리오에서 유용합니다.\n\n```js\n/* 실시간 사용 사례: `of`를 사용하여 난수 생성 */\nimport { of, defer } from 'rxjs';\nconst randomOf$ = of(Math.random());\n\n// 랜덤 숫자 생성을 위해 `defer` 사용\nconst randomDefer$ = defer(() =\u003e of(Math.random()));\n\n// `randomOf$`를 여러 번 구독\nrandomOf$.subscribe(randomNumber =\u003e console.log('랜덤 숫자 (of):', randomNumber));\nrandomOf$.subscribe(randomNumber =\u003e console.log('랜덤 숫자 (of):', randomNumber));\nrandomOf$.subscribe(randomNumber =\u003e console.log('랜덤 숫자 (of):', randomNumber));\n\n// `randomDefer$`를 여러 번 구독\nrandomDefer$.subscribe(randomNumber =\u003e console.log('랜덤 숫자 (defer):', randomNumber));\nrandomDefer$.subscribe(randomNumber =\u003e console.log('랜덤 숫자 (defer):', randomNumber));\nrandomDefer$.subscribe(randomNumber =\u003e console.log('랜덤 숫자 (defer):', randomNumber));\n```\n\nOutput\n\n```js\n랜덤 숫자 (of): 0.123456789\n랜덤 숫자 (of): 0.123456789\n랜덤 숫자 (of): 0.123456789\n랜덤 숫자 (defer): 0.987654321\n랜덤 숫자 (defer): 0.654321987\n랜덤 숫자 (defer): 0.123456789\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 빈\n\n빈 Observable을 생성하고 즉시 완료 콜백을 호출합니다.\n\nRxJS의 빈 연산자는 값을 방출하지 않고 즉시 완료되는 Observable을 생성합니다. 값이 방출될 필요가 없지만 완료를 신호해야 하는 경우에 유용합니다.\n\n```js\n/* 실시간 사용 사례: 빈 Observable 생성 */\nimport { empty } from 'rxjs';\nconst emptyObservable$ = empty();\n// 빈 Observable에 구독하기\nemptyObservable$.subscribe({\n  next: () =\u003e console.log('다음 값'), // 호출되지 않음\n  complete: () =\u003e console.log('완료됨') // 즉시 호출됨\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# from\n\n배열, 프로미스, 이터러블 객체 또는 Observable과 유사한 객체에서 Observable을 생성합니다.\n\n```js\nimport { from } from 'rxjs';\nconst arraySource = from([1, 2, 3, 4, 5]);\nconst subscribe = arraySource.subscribe(val =\u003e console.log(val));\n//출력: 1, 2, 3, 4, 5\n```\n\n```js\nimport { from } from 'rxjs';\nconst source = from('Hello World');\nconst subscribe = source.subscribe(val =\u003e console.log(val));\n//출력: 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nconst numbers = from(new Promise((resolve, reject) =\u003e resolve('Hello World')));\nnumbers.subscribe((data) =\u003e {\n  console.log(data);\n});\n//output: Hello World\n```\n\n# fromEvent\n\n- 이벤트에서 Observable을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 사용자가 화면을 클릭할 때 시간 추적 */\nimport { fromEvent } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst source = fromEvent(document, 'click');\nconst example = source.pipe(map(event =\u003e event.timeStamp));\nconst subscribe = example.subscribe(val =\u003e console.log(`이벤트 시간: ${val / 1000} 초`));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n출력\n\n```js\n이벤트 시간: 5.418900000000373 초\n이벤트 시간: 7.552900000000372 초\n```\n\n# fromEventPattern\n\nfromEventPattern은 이벤트를 반환하는 함수에서 Observable을 생성합니다. fromEventPattern을 사용하면 이벤트 처리기 함수를 등록하는 API를 Observable로 변환할 수 있습니다. fromEvent과 유사하지만 훨씬 유연합니다. fromEvent의 모든 사용 사례는 fromEventPattern으로 쉽게 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 생성\n\n함수를 기반으로 값을 생성하는 옵저버블을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 숫자 시퀀스 생성 */\n\nimport { generate } from 'rxjs';\nconst result = generate(0, x =\u003e x \u003c 3, x =\u003e x + 1, x =\u003e x);\nresult.subscribe(x =\u003e console.log(x));\n\n// 결과:\n// 0\n// 1\n// 2\n```\n\n# 간격\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일정한 간격으로 정수 시퀀스를 방출하는 Observable을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 1초 간격으로 값 시퀀스를 방출 */\nimport { interval } from 'rxjs';\n\n// 1초마다 시퀀스 값 방출\nconst source = interval(1000);\nconst subscribe = source.subscribe(val =\u003e console.log(val));\n//결과: 0, 1, 2, 3, 4, 5....\n```\n\n# of\n\n- 지정된 값을 순서대로 방출하는 Observable을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { of } from 'rxjs';\n\nof(10, 20, 30)\n  .subscribe({\n    next: value =\u003e console.log('다음 값:', value),\n    error: err =\u003e console.log('에러 발생:', err),\n    complete: () =\u003e console.log('완료'),\n  });\n\n// 결과\n// 다음 값: 10\n// 다음 값: 20\n// 다음 값: 30\n// 완료\n```\n\n# range\n\n지정된 범위 내에서 숫자의 시퀀스를 방출하는 Observable을 생성합니다.\n\n```js\n/* 실시간 사용 사례: 1에서 10까지 순차적으로 방출 */\n\nimport { range } from 'rxjs';\nconst source = range(1, 10);\nconst example = source.subscribe(val =\u003e console.log(val));\n// 출력: 1,2,3,4,5,6,7,8,9,10\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# throwError\n\n- 구독 시 오류를 발생시키는 Observable을 생성합니다.\n\n```js\n/* 구독 시 오류 발생 */\nimport { throwError } from 'rxjs';\n// 특정 값과 함께 오류를 발생시킵니다.\n\nconst source = throwError('오류 발생!');\n// 출력: 'Error: 오류 발생!'\n\nconst subscribe = source.subscribe({\n  next: val =\u003e console.log(val),\n  complete: () =\u003e console.log('완료!'),\n  error: val =\u003e console.log(`오류: ${val}`)\n});\n```\n\n# timer\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 특정 시간 간격 후에 발행을 시작하고 정수 시퀀스를 발행하는 Observable를 생성합니다.\n\n```js\n/* 실제 시나리오: 타이머는 1초 후에 발행을 시작하고 그 이후 매 2초마다 값을 발행합니다 */\n\nimport { timer } from 'rxjs';\n\n/*\n  timer 함수는 두 번째 인자를 가지며, 연속적으로 값들을 발행하는 빈도를 정의합니다.\n  이 경우, 1초 후에 첫 번째 값을 발행하고 그 이후 2초마다 값을 발행합니다.\n*/\nconst source = timer(1000, 2000);\n//출력: 0,1,2,3,4,5......\nconst subscribe = source.subscribe(val =\u003e console.log(val));\n```\n\n# iif\n\n조건에 따라 함수의 출력을 발행하는 Observable를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n/* Observable에 대한 액세스 제어 */\n\nimport { iif, of, EMPTY } from 'rxjs';\n \nlet accessGranted;\nconst observableIfYouHaveAccess = iif(\n  () =\u003e accessGranted,\n  of('액세스가 허용된 것 같아요...'),\n  EMPTY\n);\n \naccessGranted = true;\nobservableIfYouHaveAccess.subscribe({\n  next: value =\u003e console.log(value),\n  complete: () =\u003e console.log('끝')\n});\n \n// 출력:\n// '액세스가 허용된 것 같아요...'\n// '끝'\n \naccessGranted = false;\nobservableIfYouHaveAccess.subscribe({\n  next: value =\u003e console.log(value),\n  complete: () =\u003e console.log('끝')\n});\n \n// 출력:\n// '끝'\n```\n\n요약하면, RxJS Creation Operators는 JavaScript에서 반응형 프로그래밍의 기본 구성 요소입니다. 다양한 데이터 소스에서 Observable을 생성할 수 있게 해줌으로써, 이러한 연산자는 비동기 데이터 스트림을 효율적으로 처리할 수 있도록 개발자들을 지원합니다. API에서 데이터를 가져오는 ajax, 사용자 상호 작용에 반응하는 fromEvent, interval 및 timer를 사용하여 작업을 예약하는 등, 이러한 연산자들은 반응형 애플리케이션에서 데이터 흐름을 유연하고 강력하게 관리할 수 있는 방법을 제공합니다. 이러한 생성 연산자를 숙달하는 것은 RxJS의 모든 잠재력을 발휘하고 반응형 프로그래밍을 통한 반응형, 확장 가능하고 유지보수 가능한 애플리케이션을 구축하는 데 필수적입니다. 이 연산자들을 깊이 이해하고 그 기능을 실험하며, RxJS를 활용한 반응형 프로그래밍 마스터의 길에 나아가 보세요.\n\n즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png"},"coverImage":"/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e반응형 프로그래밍은 현대 웹 개발에서 중요한 기반 기술이 되었으며 비동기 데이터 스트림을 처리하는 견고한 방법을 제공합니다. RxJS 또는 JavaScript용 반응형 익스텐션은 JavaScript에서 반응형 프로그래밍을 구현하는 가장 인기있는 라이브러리 중 하나입니다. 생성 연산자는 여러 기능 중에서도 관찰 가능한 스트림을 생성하는 데 필수적인 도구로 강조됩니다. 이 블로그 포스트에서는 다양한 RxJS 생성 연산자, 작동 방식 및 각각에 대한 실제 사용 사례를 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003eRxJS 생성 연산자란?\u003c/h2\u003e\n\u003cp\u003e이러한 연산자는 다양한 데이터 소스에서 새로운 Observables를 생성합니다. 이러한 연산자는 개발자들이 작업할 데이터 스트림의 소스를 정의할 수 있도록 해주기 때문에 중요합니다. 이러한 연산자를 이해하는 것은 RxJS의 전체 기능을 최대한 활용하는 데 필수적입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eCreation Operators 목록\u003c/h1\u003e\n\u003cp\u003e(참고: “⭐ — 일반적으로 사용됨”)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e⭐ajax: Ajax 요청을 위한 observable을 생성하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003ebindCallback: 콜백 스타일 함수를 observable로 변환합니다.\u003c/li\u003e\n\u003cli\u003ebindNodeCallback: bindCallback과 유사하지만, Node.js 스타일 콜백(error-first)을 위한 것입니다.\u003c/li\u003e\n\u003cli\u003edefer: observable의 생성을 구독 지점까지 지연시킵니다.\u003c/li\u003e\n\u003cli\u003eempty: 어떤 값도 방출하지 않고 즉시 완료되는 observable을 생성합니다.\u003c/li\u003e\n\u003cli\u003e⭐from: 다양한 다른 객체 및 데이터 유형을 observable로 변환합니다.\u003c/li\u003e\n\u003cli\u003e⭐fromEvent: DOM 이벤트 대상 또는 Node.js EventEmitter에서 이벤트를 방출하는 observable을 생성합니다.\u003c/li\u003e\n\u003cli\u003efromEventPattern: 주어진 addHandler/removeHandler 함수 쌍에서 observable을 생성합니다.\u003c/li\u003e\n\u003cli\u003egenerate: 제공된 반복 함수에 기반하여 시간이 지남에 따라 값들을 생성합니다.\u003c/li\u003e\n\u003cli\u003e⭐interval: 지정된 간격에서 증가하는 숫자를 방출하는 observable을 생성합니다.\u003c/li\u003e\n\u003cli\u003e⭐of: 값의 시퀀스를 observable 시퀀스로 방출합니다.\u003c/li\u003e\n\u003cli\u003erange: 지정된 범위 내의 숫자 시퀀스를 방출합니다.\u003c/li\u003e\n\u003cli\u003ethrowError: 오류를 방출하는 observable을 생성합니다.\u003c/li\u003e\n\u003cli\u003etimer: 지정된 지연 후 단일 값을 방출합니다.\u003c/li\u003e\n\u003cli\u003eiif: 두 가지 가능한 원본 observable 중 하나에 조건부로 구독합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 Creation Operator를 하나씩 검토하고 예제를 통해 학습하겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eAjax\u003c/h1\u003e\n\u003cp\u003eXMLHttpRequest API를 사용하여 HTTP 요청을 보냅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 실시간 사용 사례: 요청에서 반환되는 응답 객체를 방출하는 Observable */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { ajax } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs/ajax'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e githubUsers = \u003cspan class=\"hljs-string\"\u003e`https://api.github.com/users?per_page=2`\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = \u003cspan class=\"hljs-title function_\"\u003eajax\u003c/span\u003e(githubUsers);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subscribe = users.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(res),\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(err)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 실시간 사용 사례: 요청에서 반환되는 응답 객체의 json 키만 방출하는 Observable */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { ajax } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs/ajax'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e githubUsers = \u003cspan class=\"hljs-string\"\u003e`https://api.github.com/users?per_page=2`\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e users = ajax.\u003cspan class=\"hljs-title function_\"\u003egetJSON\u003c/span\u003e(githubUsers);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subscribe = users.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(res),\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(err)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003ebindCallback\u003c/h1\u003e\n\u003cp\u003e콜백 스타일의 함수를 Observable로 변환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 실시간 사용 사례: jQuery의 getJSON을 Observable API로 변환하는 방법 */\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { bindCallback } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e jQuery \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'jquery'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getJSONAsObservable = \u003cspan class=\"hljs-title function_\"\u003ebindCallback\u003c/span\u003e(jQuery.\u003cspan class=\"hljs-property\"\u003egetJSON\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-title function_\"\u003egetJSONAsObservable\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/my/url'\u003c/span\u003e);\nresult.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x), \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003ebindNodeCallback\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e노드 스타일 콜백 함수를 Observable로 변환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 실시간 사용 사례: 파일 시스템에서 파일 읽어오기 및 데이터를 Observable로 얻기 */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { bindNodeCallback } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e fs \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'fs'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e readFileAsObservable = \u003cspan class=\"hljs-title function_\"\u003ebindNodeCallback\u003c/span\u003e(fs.\u003cspan class=\"hljs-property\"\u003ereadFile\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-title function_\"\u003ereadFileAsObservable\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./roadNames.txt'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'utf8'\u003c/span\u003e);\n\nresult.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x), \u003cspan class=\"hljs-comment\"\u003e// 파일 내용 처리\u003c/span\u003e\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(e) \u003cspan class=\"hljs-comment\"\u003e// 오류 처리\u003c/span\u003e\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edefer\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSubscriber가 Observable에 구독할 때까지 실행을 지연시키는 Observable를 생성합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eRxJS에서 defer는 Observable을 생성하는 함수입니다. 주요 목적은 Observable이 구독될 때까지 Observable의 생성을 지연하는 것입니다. 이는 새로운 옵저버가 Observable을 구독할 때마다 설정 또는 초기화 논리가 실행되어야 하는 시나리오에서 유용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 실시간 사용 사례: `of`를 사용하여 난수 생성 */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e, defer } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e randomOf$ = \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e());\n\n\u003cspan class=\"hljs-comment\"\u003e// 랜덤 숫자 생성을 위해 `defer` 사용\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e randomDefer$ = \u003cspan class=\"hljs-title function_\"\u003edefer\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003erandom\u003c/span\u003e()));\n\n\u003cspan class=\"hljs-comment\"\u003e// `randomOf$`를 여러 번 구독\u003c/span\u003e\nrandomOf$.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003erandomNumber\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'랜덤 숫자 (of):'\u003c/span\u003e, randomNumber));\nrandomOf$.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003erandomNumber\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'랜덤 숫자 (of):'\u003c/span\u003e, randomNumber));\nrandomOf$.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003erandomNumber\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'랜덤 숫자 (of):'\u003c/span\u003e, randomNumber));\n\n\u003cspan class=\"hljs-comment\"\u003e// `randomDefer$`를 여러 번 구독\u003c/span\u003e\nrandomDefer$.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003erandomNumber\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'랜덤 숫자 (defer):'\u003c/span\u003e, randomNumber));\nrandomDefer$.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003erandomNumber\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'랜덤 숫자 (defer):'\u003c/span\u003e, randomNumber));\nrandomDefer$.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003erandomNumber\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'랜덤 숫자 (defer):'\u003c/span\u003e, randomNumber));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOutput\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e랜덤 숫자 (\u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e): \u003cspan class=\"hljs-number\"\u003e0.123456789\u003c/span\u003e\n랜덤 숫자 (\u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e): \u003cspan class=\"hljs-number\"\u003e0.123456789\u003c/span\u003e\n랜덤 숫자 (\u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e): \u003cspan class=\"hljs-number\"\u003e0.123456789\u003c/span\u003e\n랜덤 숫자 (defer): \u003cspan class=\"hljs-number\"\u003e0.987654321\u003c/span\u003e\n랜덤 숫자 (defer): \u003cspan class=\"hljs-number\"\u003e0.654321987\u003c/span\u003e\n랜덤 숫자 (defer): \u003cspan class=\"hljs-number\"\u003e0.123456789\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e빈\u003c/h1\u003e\n\u003cp\u003e빈 Observable을 생성하고 즉시 완료 콜백을 호출합니다.\u003c/p\u003e\n\u003cp\u003eRxJS의 빈 연산자는 값을 방출하지 않고 즉시 완료되는 Observable을 생성합니다. 값이 방출될 필요가 없지만 완료를 신호해야 하는 경우에 유용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 실시간 사용 사례: 빈 Observable 생성 */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { empty } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e emptyObservable$ = \u003cspan class=\"hljs-title function_\"\u003eempty\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 빈 Observable에 구독하기\u003c/span\u003e\nemptyObservable$.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'다음 값'\u003c/span\u003e), \u003cspan class=\"hljs-comment\"\u003e// 호출되지 않음\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ecomplete\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'완료됨'\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 즉시 호출됨\u003c/span\u003e\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003efrom\u003c/h1\u003e\n\u003cp\u003e배열, 프로미스, 이터러블 객체 또는 Observable과 유사한 객체에서 Observable을 생성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e arraySource = \u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subscribe = arraySource.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(val));\n\u003cspan class=\"hljs-comment\"\u003e//출력: 1, 2, 3, 4, 5\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source = \u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Hello World'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subscribe = source.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(val));\n\u003cspan class=\"hljs-comment\"\u003e//출력: 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e numbers = \u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve, reject\u003c/span\u003e) =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Hello World'\u003c/span\u003e)));\nnumbers.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data);\n});\n\u003cspan class=\"hljs-comment\"\u003e//output: Hello World\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003efromEvent\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e이벤트에서 Observable을 생성합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 실시간 사용 사례: 사용자가 화면을 클릭할 때 시간 추적 */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { fromEvent } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { map } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs/operators'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source = \u003cspan class=\"hljs-title function_\"\u003efromEvent\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'click'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e example = source.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e =\u003e\u003c/span\u003e event.\u003cspan class=\"hljs-property\"\u003etimeStamp\u003c/span\u003e));\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subscribe = example.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`이벤트 시간: \u003cspan class=\"hljs-subst\"\u003e${val / \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e}\u003c/span\u003e 초`\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e출력\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e이벤트 시간: \u003cspan class=\"hljs-number\"\u003e5.418900000000373\u003c/span\u003e 초\n이벤트 시간: \u003cspan class=\"hljs-number\"\u003e7.552900000000372\u003c/span\u003e 초\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003efromEventPattern\u003c/h1\u003e\n\u003cp\u003efromEventPattern은 이벤트를 반환하는 함수에서 Observable을 생성합니다. fromEventPattern을 사용하면 이벤트 처리기 함수를 등록하는 API를 Observable로 변환할 수 있습니다. fromEvent과 유사하지만 훨씬 유연합니다. fromEvent의 모든 사용 사례는 fromEventPattern으로 쉽게 처리할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e생성\u003c/h1\u003e\n\u003cp\u003e함수를 기반으로 값을 생성하는 옵저버블을 생성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 실시간 사용 사례: 숫자 시퀀스 생성 */\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { generate } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = \u003cspan class=\"hljs-title function_\"\u003egenerate\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u003e\u003c/span\u003e x \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u003e\u003c/span\u003e x + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u003e\u003c/span\u003e x);\nresult.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x));\n\n\u003cspan class=\"hljs-comment\"\u003e// 결과:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 0\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e간격\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e일정한 간격으로 정수 시퀀스를 방출하는 Observable을 생성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 실시간 사용 사례: 1초 간격으로 값 시퀀스를 방출 */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { interval } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 1초마다 시퀀스 값 방출\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source = \u003cspan class=\"hljs-title function_\"\u003einterval\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subscribe = source.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(val));\n\u003cspan class=\"hljs-comment\"\u003e//결과: 0, 1, 2, 3, 4, 5....\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eof\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e지정된 값을 순서대로 방출하는 Observable을 생성합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e)\n  .\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'다음 값:'\u003c/span\u003e, value),\n    \u003cspan class=\"hljs-attr\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'에러 발생:'\u003c/span\u003e, err),\n    \u003cspan class=\"hljs-attr\"\u003ecomplete\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'완료'\u003c/span\u003e),\n  });\n\n\u003cspan class=\"hljs-comment\"\u003e// 결과\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 다음 값: 10\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 다음 값: 20\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 다음 값: 30\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 완료\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003erange\u003c/h1\u003e\n\u003cp\u003e지정된 범위 내에서 숫자의 시퀀스를 방출하는 Observable을 생성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 실시간 사용 사례: 1에서 10까지 순차적으로 방출 */\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { range } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source = \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e example = source.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(val));\n\u003cspan class=\"hljs-comment\"\u003e// 출력: 1,2,3,4,5,6,7,8,9,10\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003ethrowError\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e구독 시 오류를 발생시키는 Observable을 생성합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 구독 시 오류 발생 */\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { throwError } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 특정 값과 함께 오류를 발생시킵니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source = \u003cspan class=\"hljs-title function_\"\u003ethrowError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'오류 발생!'\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 출력: 'Error: 오류 발생!'\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subscribe = source.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(val),\n  \u003cspan class=\"hljs-attr\"\u003ecomplete\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'완료!'\u003c/span\u003e),\n  \u003cspan class=\"hljs-attr\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`오류: \u003cspan class=\"hljs-subst\"\u003e${val}\u003c/span\u003e`\u003c/span\u003e)\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003etimer\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e특정 시간 간격 후에 발행을 시작하고 정수 시퀀스를 발행하는 Observable를 생성합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* 실제 시나리오: 타이머는 1초 후에 발행을 시작하고 그 이후 매 2초마다 값을 발행합니다 */\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { timer } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e/*\n  timer 함수는 두 번째 인자를 가지며, 연속적으로 값들을 발행하는 빈도를 정의합니다.\n  이 경우, 1초 후에 첫 번째 값을 발행하고 그 이후 2초마다 값을 발행합니다.\n*/\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e source = \u003cspan class=\"hljs-title function_\"\u003etimer\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e//출력: 0,1,2,3,4,5......\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e subscribe = source.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(val));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eiif\u003c/h1\u003e\n\u003cp\u003e조건에 따라 함수의 출력을 발행하는 Observable를 생성합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/* Observable에 대한 액세스 제어 */\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { iif, \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eEMPTY\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n \n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e accessGranted;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e observableIfYouHaveAccess = \u003cspan class=\"hljs-title function_\"\u003eiif\u003c/span\u003e(\n  \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e accessGranted,\n  \u003cspan class=\"hljs-title function_\"\u003eof\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'액세스가 허용된 것 같아요...'\u003c/span\u003e),\n  \u003cspan class=\"hljs-variable constant_\"\u003eEMPTY\u003c/span\u003e\n);\n \naccessGranted = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\nobservableIfYouHaveAccess.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value),\n  \u003cspan class=\"hljs-attr\"\u003ecomplete\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'끝'\u003c/span\u003e)\n});\n \n\u003cspan class=\"hljs-comment\"\u003e// 출력:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// '액세스가 허용된 것 같아요...'\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// '끝'\u003c/span\u003e\n \naccessGranted = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\nobservableIfYouHaveAccess.\u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003enext\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(value),\n  \u003cspan class=\"hljs-attr\"\u003ecomplete\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'끝'\u003c/span\u003e)\n});\n \n\u003cspan class=\"hljs-comment\"\u003e// 출력:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// '끝'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e요약하면, RxJS Creation Operators는 JavaScript에서 반응형 프로그래밍의 기본 구성 요소입니다. 다양한 데이터 소스에서 Observable을 생성할 수 있게 해줌으로써, 이러한 연산자는 비동기 데이터 스트림을 효율적으로 처리할 수 있도록 개발자들을 지원합니다. API에서 데이터를 가져오는 ajax, 사용자 상호 작용에 반응하는 fromEvent, interval 및 timer를 사용하여 작업을 예약하는 등, 이러한 연산자들은 반응형 애플리케이션에서 데이터 흐름을 유연하고 강력하게 관리할 수 있는 방법을 제공합니다. 이러한 생성 연산자를 숙달하는 것은 RxJS의 모든 잠재력을 발휘하고 반응형 프로그래밍을 통한 반응형, 확장 가능하고 유지보수 가능한 애플리케이션을 구축하는 데 필수적입니다. 이 연산자들을 깊이 이해하고 그 기능을 실험하며, RxJS를 활용한 반응형 프로그래밍 마스터의 길에 나아가 보세요.\u003c/p\u003e\n\u003cp\u003e즐거운 코딩되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-18-MasteringRxJSCreationOperatorsUnlockingthePowerofDataStreams"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>