<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리액트 컴파일러, 리액트의 새로운 방식 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-20-ReactCompileranewwaytoReact" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리액트 컴파일러, 리액트의 새로운 방식 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="리액트 컴파일러, 리액트의 새로운 방식 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-20-ReactCompileranewwaytoReact_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-20-ReactCompileranewwaytoReact" data-gatsby-head="true"/><meta name="twitter:title" content="리액트 컴파일러, 리액트의 새로운 방식 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-20-ReactCompileranewwaytoReact_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-20 22:13" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리액트 컴파일러, 리액트의 새로운 방식</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리액트 컴파일러, 리액트의 새로운 방식" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 20, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-20-ReactCompileranewwaytoReact&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>최근 Meta사에서 React를 위한 새로운 컴파일러를 발표했어요. 이 소식은 생각보다 더 큰 뜻을 가지고 있어요. 이 블로그에서는 React의 새로운 컴파일러에 대한 기본적인 내용을 이해해보려 합니다.</p>
<p><img src="/assets/img/2024-05-20-ReactCompileranewwaytoReact_0.png" alt="ReactCompileranewwaytoReact"></p>
<p>UI 컴파일러에 대해 간단히 살펴보자면:
Svelte, Angular, Solid과 같은 UI 프레임워크들은 이미 내장된 컴파일러를 가지고 있어요. 이러한 컴파일러들은 코드를 최적화된 JavaScript로 변환하여 성능을 향상시키고 런타임 오버헤드를 줄여줘요. 따라서 React에 컴파일러를 도입하는 것은 오랜 기간이 지나야 한다고 생각되었던 일이에요. 이러한 조치는 React를 이러한 현대적인 프레임워크들과 동일선상으로 끌어올리는 데 도움이 되며, 코드베이스가 커짐에 따라 발생하는 성능 문제를 해결하는 데 도움이 될 거예요.</p>
<p>컴파일러가 왜 필요한가요?
여러 이유가 있어요. 대부분의 React 개발자들은 이미 알고 있지만, React 렌더링은 코드베이스의 크기가 커지면 성능이 저하될 수 있는 공격적인 특성을 가지고 있어요. React는 메모이제이션 기술을 제공하지만, 효과적으로 학습하고 구현하기 어려울 수 있어요.</p>
<p>React 컴파일러 작동 방식에 대해 알아보겠습니다.
컴파일러가 일관된 최적화를 달성하는 데 사용하는 여러 기술이 있습니다. 이 중 몇 가지를 아래에서 언급해보겠습니다:</p>
<p>자동 의존성 분석: React 컴파일러는 자동 의존성 검출 및 최적화를 도입하여 성능을 향상시킵니다. 변경된 컴포넌트만 재렌더링함으로써 불필요한 렌더링을 최소화하고 애플리케이션 실행 속도를 높입니다. 컴포넌트 의존성을 분석하고 캐싱 메커니즘을 활용하여 React는 불필요한 렌더링을 최소화하고 응용 프로그램을 가속화합니다. 이는 수동 의존성 명시의 필요성을 줄이고 보일러플레이트 코드를 낮춥니다. 컴파일러는 코드베이스 전체에서 일관된 최적화를 보장하며 업데이트를 일괄처리하고 중복 렌더링을 건너뛰는 최적화된 렌더링 전략을 구현합니다.</p>
<p>코드 변환: React 컴파일러는 빌드 시간에 코드를 변환합니다. 클 때 필요한 곳에 메모이제이션 논리를 삽입하여 비용이 많이 드는 계산이나 큰 객체가 변경된 경우에만 다시 계산되거나 재생성되도록 보장합니다. 이 변환은 개발자가 컴포넌트를 최적화하는 데 필요한 수동 노력을 줄입니다.</p>
<p>향상된 Hooks: React 컴파일러는 useMemo와 useCallback과 같은 기존 훅을 개선할 수 있습니다. 적절한 곳에 자동으로 이러한 훅을 삽입하여 컴파일러는 개발자가 수동으로 의존성을 지정하지 않고도 메모이제이션의 이점을 얻을 수 있도록 보장합니다.</p>
<p>과거 트랜스파일된 코드와 새로운 컴파일된 코드 비교
코드로 들어가서 컴파일러의 유무에 따라 동일한 코드가 어떻게 다른지 살펴보겠습니다:</p>
<p>간단한 코드 스니펫을 살펴보죠. Hello World 텍스트가 있는 간단한 <code>div</code>입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"foo"</span>></span>Hi There<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>;
}
</code></pre>
<p>현재 컴파일 없이 트랜스파일된 코드는 이렇게 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// transpiled code (without compiler)</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">__jsx</span>(<span class="hljs-string">"div"</span>, {
    <span class="hljs-attr">className</span>: <span class="hljs-string">"foo"</span>
  }, <span class="hljs-string">"Hi There"</span>);
}
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// compiled code (with React compiler)</span>
<span class="hljs-keyword">import</span> { c <span class="hljs-keyword">as</span> _c } <span class="hljs-keyword">from</span> <span class="hljs-string">"react/compiler-runtime"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> $ = <span class="hljs-title function_">_c</span>(<span class="hljs-number">2</span>);
  <span class="hljs-keyword">if</span> ($[<span class="hljs-number">0</span>] !== <span class="hljs-string">"8b8c470796627445ffbcfa7127db0cfba267736e0e4708dfa79d32043c5e5a7c"</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> $i = <span class="hljs-number">0</span>; $i &#x3C; <span class="hljs-number">2</span>; $i += <span class="hljs-number">1</span>) {
      $[$i] = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">"react.memo_cache_sentinel"</span>);
    }
    $[<span class="hljs-number">0</span>] = <span class="hljs-string">"8b8c470796627445ffbcfa7127db0cfba267736e0e4708dfa79d32043c5e5a7c"</span>;
  }
  <span class="hljs-keyword">let</span> t0;
  <span class="hljs-comment">// cached component</span>
  <span class="hljs-keyword">if</span> ($[<span class="hljs-number">1</span>] === <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">"react.memo_cache_sentinel"</span>)) {
    t0 = <span class="hljs-title function_">__jsx</span>(<span class="hljs-string">"div"</span>, {
      <span class="hljs-attr">className</span>: <span class="hljs-string">"foo"</span>
    }, <span class="hljs-string">"Hi There"</span>);
    $[<span class="hljs-number">1</span>] = t0;
  } <span class="hljs-keyword">else</span> {
    t0 = $[<span class="hljs-number">1</span>];
  }
  <span class="hljs-keyword">return</span> t0;
}
</code></pre>
<p>Now there is a lot of compiled code; let's look at the code block by block.
The first block is responsible for loading the memo cache, which caches the components.
The second <code>if</code> statement is where the compiler saves our <code>div</code> in a cache. If there is a re-render and nothing in the component has changed, we get the cached component. This is how static content is handled by the compiler.</p>
<p>Let’s look at a more advanced code snippet to see how the compiler manages states in the code.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">"Jack"</span>);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Hi: {name}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">strong</span>></span>Static Content<span class="hljs-tag">&#x3C;/<span class="hljs-name">strong</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
  );
}
</code></pre>
<p>여기에는 코드에 정의된 상태 "name"이 있지만 컴포넌트 내에서 상태가 전혀 변경되지 않습니다. 이것이 React 컴파일러의 강점을 볼 때입니다. 변환된 코드와 컴파일된 코드를 비교해 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 변환된 코드 (컴파일러 미사용)</span>
<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">"Jack"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">__jsx</span>(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, <span class="hljs-title function_">__jsx</span>(<span class="hljs-string">"p"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"Hi: "</span>, name), <span class="hljs-title function_">__jsx</span>(<span class="hljs-string">"strong"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"Static Content"</span>));
}
</code></pre>
<p>지금 변환된 코드를 가져왔습니다. 상태는 최적화 없이 변환됩니다. 이제 컴파일된 코드를 살펴봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { c <span class="hljs-keyword">as</span> _c } <span class="hljs-keyword">from</span> <span class="hljs-string">"react/compiler-runtime"</span>;
<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> $ = <span class="hljs-title function_">_c</span>(<span class="hljs-number">6</span>);
  <span class="hljs-keyword">if</span> ($[<span class="hljs-number">0</span>] !== <span class="hljs-string">"ff7f138520311a2041bfadf8c5306ca9ddda64020c5c7c91ce7bfd217639da89"</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> $i = <span class="hljs-number">0</span>; $i &#x3C; <span class="hljs-number">6</span>; $i += <span class="hljs-number">1</span>) {
      $[$i] = <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">"react.memo_cache_sentinel"</span>);
    }
    $[<span class="hljs-number">0</span>] = <span class="hljs-string">"ff7f138520311a2041bfadf8c5306ca9ddda64020c5c7c91ce7bfd217639da89"</span>;
  }
  <span class="hljs-keyword">const</span> [name] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">"Jack"</span>);
  <span class="hljs-keyword">let</span> t0;
<span class="hljs-comment">// name is cached</span>
  <span class="hljs-keyword">if</span> ($[<span class="hljs-number">1</span>] !== name) {
    t0 = <span class="hljs-title function_">__jsx</span>(<span class="hljs-string">"p"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"Hi: "</span>, name);
    $[<span class="hljs-number">1</span>] = name;
    $[<span class="hljs-number">2</span>] = t0;
  } <span class="hljs-keyword">else</span> {
    t0 = $[<span class="hljs-number">2</span>];
  }
  <span class="hljs-keyword">let</span> t1;

  <span class="hljs-keyword">if</span> ($[<span class="hljs-number">3</span>] === <span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">"react.memo_cache_sentinel"</span>)) {
    t1 = <span class="hljs-title function_">__jsx</span>(<span class="hljs-string">"strong"</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">"Static Content"</span>);
    $[<span class="hljs-number">3</span>] = t1;
  } <span class="hljs-keyword">else</span> {
    t1 = $[<span class="hljs-number">3</span>];
  }
  <span class="hljs-keyword">let</span> t2;
  <span class="hljs-keyword">if</span> ($[<span class="hljs-number">4</span>] !== t0) {
    t2 = <span class="hljs-title function_">__jsx</span>(<span class="hljs-string">"div"</span>, <span class="hljs-literal">null</span>, t0, t1);
    $[<span class="hljs-number">4</span>] = t0;
    $[<span class="hljs-number">5</span>] = t2;
  } <span class="hljs-keyword">else</span> {
    t2 = $[<span class="hljs-number">5</span>];
  }
  <span class="hljs-keyword">return</span> t2;
}
</code></pre>
<p>여기에서 컴파일러에 의해 상태가 자동으로 캐시됩니다. 따라서 다음 렌더링에서는 값이 캐시에서 반환됩니다. 이름의 값을 변경할 때만 if 블록으로 이동하여 향후 렌더링을 위해 캐시에 저장합니다.</p>
<p>결론:
React에 컴파일러를 추가하면 프로그래머들이 더 쉽게 최적화된 코드를 작성할 수 있습니다. 이 블로그에서는 React의 컴파일러가 출시되면 기대할 수 있는 기능을 분석하고 이해하기 위한 기본 사용 사례를 탐색했습니다.
React 컴파일러의 고급 개념 및 사용 사례에 대해 계속 알아보십시오. 정적 분석, 최적화된 렌더링 및 useMemo와 같은 고급 훅의 사용과 같은 추가 기능을 탐색할 예정입니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리액트 컴파일러, 리액트의 새로운 방식","description":"","date":"2024-05-20 22:13","slug":"2024-05-20-ReactCompileranewwaytoReact","content":"\n\n최근 Meta사에서 React를 위한 새로운 컴파일러를 발표했어요. 이 소식은 생각보다 더 큰 뜻을 가지고 있어요. 이 블로그에서는 React의 새로운 컴파일러에 대한 기본적인 내용을 이해해보려 합니다.\n\n![ReactCompileranewwaytoReact](/assets/img/2024-05-20-ReactCompileranewwaytoReact_0.png)\n\nUI 컴파일러에 대해 간단히 살펴보자면:\nSvelte, Angular, Solid과 같은 UI 프레임워크들은 이미 내장된 컴파일러를 가지고 있어요. 이러한 컴파일러들은 코드를 최적화된 JavaScript로 변환하여 성능을 향상시키고 런타임 오버헤드를 줄여줘요. 따라서 React에 컴파일러를 도입하는 것은 오랜 기간이 지나야 한다고 생각되었던 일이에요. 이러한 조치는 React를 이러한 현대적인 프레임워크들과 동일선상으로 끌어올리는 데 도움이 되며, 코드베이스가 커짐에 따라 발생하는 성능 문제를 해결하는 데 도움이 될 거예요.\n\n컴파일러가 왜 필요한가요?\n여러 이유가 있어요. 대부분의 React 개발자들은 이미 알고 있지만, React 렌더링은 코드베이스의 크기가 커지면 성능이 저하될 수 있는 공격적인 특성을 가지고 있어요. React는 메모이제이션 기술을 제공하지만, 효과적으로 학습하고 구현하기 어려울 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReact 컴파일러 작동 방식에 대해 알아보겠습니다.\n컴파일러가 일관된 최적화를 달성하는 데 사용하는 여러 기술이 있습니다. 이 중 몇 가지를 아래에서 언급해보겠습니다:\n\n자동 의존성 분석: React 컴파일러는 자동 의존성 검출 및 최적화를 도입하여 성능을 향상시킵니다. 변경된 컴포넌트만 재렌더링함으로써 불필요한 렌더링을 최소화하고 애플리케이션 실행 속도를 높입니다. 컴포넌트 의존성을 분석하고 캐싱 메커니즘을 활용하여 React는 불필요한 렌더링을 최소화하고 응용 프로그램을 가속화합니다. 이는 수동 의존성 명시의 필요성을 줄이고 보일러플레이트 코드를 낮춥니다. 컴파일러는 코드베이스 전체에서 일관된 최적화를 보장하며 업데이트를 일괄처리하고 중복 렌더링을 건너뛰는 최적화된 렌더링 전략을 구현합니다.\n\n코드 변환: React 컴파일러는 빌드 시간에 코드를 변환합니다. 클 때 필요한 곳에 메모이제이션 논리를 삽입하여 비용이 많이 드는 계산이나 큰 객체가 변경된 경우에만 다시 계산되거나 재생성되도록 보장합니다. 이 변환은 개발자가 컴포넌트를 최적화하는 데 필요한 수동 노력을 줄입니다.\n\n향상된 Hooks: React 컴파일러는 useMemo와 useCallback과 같은 기존 훅을 개선할 수 있습니다. 적절한 곳에 자동으로 이러한 훅을 삽입하여 컴파일러는 개발자가 수동으로 의존성을 지정하지 않고도 메모이제이션의 이점을 얻을 수 있도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n과거 트랜스파일된 코드와 새로운 컴파일된 코드 비교\n코드로 들어가서 컴파일러의 유무에 따라 동일한 코드가 어떻게 다른지 살펴보겠습니다:\n\n간단한 코드 스니펫을 살펴보죠. Hello World 텍스트가 있는 간단한 `div`입니다.\n\n```js\nexport default function Hello() {\n  return \u003cdiv className=\"foo\"\u003eHi There\u003c/div\u003e;\n}\n```\n\n현재 컴파일 없이 트랜스파일된 코드는 이렇게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n// transpiled code (without compiler)\nexport default function Hello() {\n  return __jsx(\"div\", {\n    className: \"foo\"\n  }, \"Hi There\");\n}\n```\n\n```js\n// compiled code (with React compiler)\nimport { c as _c } from \"react/compiler-runtime\";\nexport default function Hello() {\n  const $ = _c(2);\n  if ($[0] !== \"8b8c470796627445ffbcfa7127db0cfba267736e0e4708dfa79d32043c5e5a7c\") {\n    for (let $i = 0; $i \u003c 2; $i += 1) {\n      $[$i] = Symbol.for(\"react.memo_cache_sentinel\");\n    }\n    $[0] = \"8b8c470796627445ffbcfa7127db0cfba267736e0e4708dfa79d32043c5e5a7c\";\n  }\n  let t0;\n  // cached component\n  if ($[1] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t0 = __jsx(\"div\", {\n      className: \"foo\"\n    }, \"Hi There\");\n    $[1] = t0;\n  } else {\n    t0 = $[1];\n  }\n  return t0;\n}\n```\n\nNow there is a lot of compiled code; let's look at the code block by block.\nThe first block is responsible for loading the memo cache, which caches the components.\nThe second `if` statement is where the compiler saves our `div` in a cache. If there is a re-render and nothing in the component has changed, we get the cached component. This is how static content is handled by the compiler.\n\nLet’s look at a more advanced code snippet to see how the compiler manages states in the code.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { useState } from \"react\";\n\nexport default function Hello() {\n  const [name, setName] = useState(\"Jack\");\n  return (\n    \u003cdiv\u003e\n      \u003cp\u003eHi: {name}\u003c/p\u003e\n      \u003cstrong\u003eStatic Content\u003c/strong\u003e\n    \u003c/div\u003e\n  );\n}\n```\n\n여기에는 코드에 정의된 상태 \"name\"이 있지만 컴포넌트 내에서 상태가 전혀 변경되지 않습니다. 이것이 React 컴파일러의 강점을 볼 때입니다. 변환된 코드와 컴파일된 코드를 비교해 봅시다.\n\n```js\n// 변환된 코드 (컴파일러 미사용)\nimport { useState } from \"react\";\nexport default function Hello() {\n  const [name, setName] = useState(\"Jack\");\n  return __jsx(\"div\", null, __jsx(\"p\", null, \"Hi: \", name), __jsx(\"strong\", null, \"Static Content\"));\n}\n```\n\n지금 변환된 코드를 가져왔습니다. 상태는 최적화 없이 변환됩니다. 이제 컴파일된 코드를 살펴봅시다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport { c as _c } from \"react/compiler-runtime\";\nimport { useState } from \"react\";\nexport default function Hello() {\n  const $ = _c(6);\n  if ($[0] !== \"ff7f138520311a2041bfadf8c5306ca9ddda64020c5c7c91ce7bfd217639da89\") {\n    for (let $i = 0; $i \u003c 6; $i += 1) {\n      $[$i] = Symbol.for(\"react.memo_cache_sentinel\");\n    }\n    $[0] = \"ff7f138520311a2041bfadf8c5306ca9ddda64020c5c7c91ce7bfd217639da89\";\n  }\n  const [name] = useState(\"Jack\");\n  let t0;\n// name is cached\n  if ($[1] !== name) {\n    t0 = __jsx(\"p\", null, \"Hi: \", name);\n    $[1] = name;\n    $[2] = t0;\n  } else {\n    t0 = $[2];\n  }\n  let t1;\n\n  if ($[3] === Symbol.for(\"react.memo_cache_sentinel\")) {\n    t1 = __jsx(\"strong\", null, \"Static Content\");\n    $[3] = t1;\n  } else {\n    t1 = $[3];\n  }\n  let t2;\n  if ($[4] !== t0) {\n    t2 = __jsx(\"div\", null, t0, t1);\n    $[4] = t0;\n    $[5] = t2;\n  } else {\n    t2 = $[5];\n  }\n  return t2;\n}\n```\n\n여기에서 컴파일러에 의해 상태가 자동으로 캐시됩니다. 따라서 다음 렌더링에서는 값이 캐시에서 반환됩니다. 이름의 값을 변경할 때만 if 블록으로 이동하여 향후 렌더링을 위해 캐시에 저장합니다.\n\n결론:\nReact에 컴파일러를 추가하면 프로그래머들이 더 쉽게 최적화된 코드를 작성할 수 있습니다. 이 블로그에서는 React의 컴파일러가 출시되면 기대할 수 있는 기능을 분석하고 이해하기 위한 기본 사용 사례를 탐색했습니다.\nReact 컴파일러의 고급 개념 및 사용 사례에 대해 계속 알아보십시오. 정적 분석, 최적화된 렌더링 및 useMemo와 같은 고급 훅의 사용과 같은 추가 기능을 탐색할 예정입니다.","ogImage":{"url":"/assets/img/2024-05-20-ReactCompileranewwaytoReact_0.png"},"coverImage":"/assets/img/2024-05-20-ReactCompileranewwaytoReact_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e최근 Meta사에서 React를 위한 새로운 컴파일러를 발표했어요. 이 소식은 생각보다 더 큰 뜻을 가지고 있어요. 이 블로그에서는 React의 새로운 컴파일러에 대한 기본적인 내용을 이해해보려 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-20-ReactCompileranewwaytoReact_0.png\" alt=\"ReactCompileranewwaytoReact\"\u003e\u003c/p\u003e\n\u003cp\u003eUI 컴파일러에 대해 간단히 살펴보자면:\nSvelte, Angular, Solid과 같은 UI 프레임워크들은 이미 내장된 컴파일러를 가지고 있어요. 이러한 컴파일러들은 코드를 최적화된 JavaScript로 변환하여 성능을 향상시키고 런타임 오버헤드를 줄여줘요. 따라서 React에 컴파일러를 도입하는 것은 오랜 기간이 지나야 한다고 생각되었던 일이에요. 이러한 조치는 React를 이러한 현대적인 프레임워크들과 동일선상으로 끌어올리는 데 도움이 되며, 코드베이스가 커짐에 따라 발생하는 성능 문제를 해결하는 데 도움이 될 거예요.\u003c/p\u003e\n\u003cp\u003e컴파일러가 왜 필요한가요?\n여러 이유가 있어요. 대부분의 React 개발자들은 이미 알고 있지만, React 렌더링은 코드베이스의 크기가 커지면 성능이 저하될 수 있는 공격적인 특성을 가지고 있어요. React는 메모이제이션 기술을 제공하지만, 효과적으로 학습하고 구현하기 어려울 수 있어요.\u003c/p\u003e\n\u003cp\u003eReact 컴파일러 작동 방식에 대해 알아보겠습니다.\n컴파일러가 일관된 최적화를 달성하는 데 사용하는 여러 기술이 있습니다. 이 중 몇 가지를 아래에서 언급해보겠습니다:\u003c/p\u003e\n\u003cp\u003e자동 의존성 분석: React 컴파일러는 자동 의존성 검출 및 최적화를 도입하여 성능을 향상시킵니다. 변경된 컴포넌트만 재렌더링함으로써 불필요한 렌더링을 최소화하고 애플리케이션 실행 속도를 높입니다. 컴포넌트 의존성을 분석하고 캐싱 메커니즘을 활용하여 React는 불필요한 렌더링을 최소화하고 응용 프로그램을 가속화합니다. 이는 수동 의존성 명시의 필요성을 줄이고 보일러플레이트 코드를 낮춥니다. 컴파일러는 코드베이스 전체에서 일관된 최적화를 보장하며 업데이트를 일괄처리하고 중복 렌더링을 건너뛰는 최적화된 렌더링 전략을 구현합니다.\u003c/p\u003e\n\u003cp\u003e코드 변환: React 컴파일러는 빌드 시간에 코드를 변환합니다. 클 때 필요한 곳에 메모이제이션 논리를 삽입하여 비용이 많이 드는 계산이나 큰 객체가 변경된 경우에만 다시 계산되거나 재생성되도록 보장합니다. 이 변환은 개발자가 컴포넌트를 최적화하는 데 필요한 수동 노력을 줄입니다.\u003c/p\u003e\n\u003cp\u003e향상된 Hooks: React 컴파일러는 useMemo와 useCallback과 같은 기존 훅을 개선할 수 있습니다. 적절한 곳에 자동으로 이러한 훅을 삽입하여 컴파일러는 개발자가 수동으로 의존성을 지정하지 않고도 메모이제이션의 이점을 얻을 수 있도록 보장합니다.\u003c/p\u003e\n\u003cp\u003e과거 트랜스파일된 코드와 새로운 컴파일된 코드 비교\n코드로 들어가서 컴파일러의 유무에 따라 동일한 코드가 어떻게 다른지 살펴보겠습니다:\u003c/p\u003e\n\u003cp\u003e간단한 코드 스니펫을 살펴보죠. Hello World 텍스트가 있는 간단한 \u003ccode\u003ediv\u003c/code\u003e입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHello\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e\u003e\u003c/span\u003eHi There\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재 컴파일 없이 트랜스파일된 코드는 이렇게 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// transpiled code (without compiler)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHello\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__jsx\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e\n  }, \u003cspan class=\"hljs-string\"\u003e\"Hi There\"\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// compiled code (with React compiler)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { c \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _c } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react/compiler-runtime\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHello\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e $ = \u003cspan class=\"hljs-title function_\"\u003e_c\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ($[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] !== \u003cspan class=\"hljs-string\"\u003e\"8b8c470796627445ffbcfa7127db0cfba267736e0e4708dfa79d32043c5e5a7c\"\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e $i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; $i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e; $i += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n      $[$i] = \u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"react.memo_cache_sentinel\"\u003c/span\u003e);\n    }\n    $[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-string\"\u003e\"8b8c470796627445ffbcfa7127db0cfba267736e0e4708dfa79d32043c5e5a7c\"\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e t0;\n  \u003cspan class=\"hljs-comment\"\u003e// cached component\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ($[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] === \u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"react.memo_cache_sentinel\"\u003c/span\u003e)) {\n    t0 = \u003cspan class=\"hljs-title function_\"\u003e__jsx\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, {\n      \u003cspan class=\"hljs-attr\"\u003eclassName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"foo\"\u003c/span\u003e\n    }, \u003cspan class=\"hljs-string\"\u003e\"Hi There\"\u003c/span\u003e);\n    $[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = t0;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    t0 = $[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e t0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow there is a lot of compiled code; let's look at the code block by block.\nThe first block is responsible for loading the memo cache, which caches the components.\nThe second \u003ccode\u003eif\u003c/code\u003e statement is where the compiler saves our \u003ccode\u003ediv\u003c/code\u003e in a cache. If there is a re-render and nothing in the component has changed, we get the cached component. This is how static content is handled by the compiler.\u003c/p\u003e\n\u003cp\u003eLet’s look at a more advanced code snippet to see how the compiler manages states in the code.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHello\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [name, setName] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Jack\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003eHi: {name}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003estrong\u003c/span\u003e\u003e\u003c/span\u003eStatic Content\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003estrong\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에는 코드에 정의된 상태 \"name\"이 있지만 컴포넌트 내에서 상태가 전혀 변경되지 않습니다. 이것이 React 컴파일러의 강점을 볼 때입니다. 변환된 코드와 컴파일된 코드를 비교해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 변환된 코드 (컴파일러 미사용)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHello\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [name, setName] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Jack\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__jsx\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003e__jsx\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"p\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Hi: \"\u003c/span\u003e, name), \u003cspan class=\"hljs-title function_\"\u003e__jsx\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"strong\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Static Content\"\u003c/span\u003e));\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e지금 변환된 코드를 가져왔습니다. 상태는 최적화 없이 변환됩니다. 이제 컴파일된 코드를 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { c \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _c } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react/compiler-runtime\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { useState } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"react\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eHello\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e $ = \u003cspan class=\"hljs-title function_\"\u003e_c\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ($[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] !== \u003cspan class=\"hljs-string\"\u003e\"ff7f138520311a2041bfadf8c5306ca9ddda64020c5c7c91ce7bfd217639da89\"\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e $i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; $i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e; $i += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n      $[$i] = \u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"react.memo_cache_sentinel\"\u003c/span\u003e);\n    }\n    $[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-string\"\u003e\"ff7f138520311a2041bfadf8c5306ca9ddda64020c5c7c91ce7bfd217639da89\"\u003c/span\u003e;\n  }\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [name] = \u003cspan class=\"hljs-title function_\"\u003euseState\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Jack\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e t0;\n\u003cspan class=\"hljs-comment\"\u003e// name is cached\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ($[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] !== name) {\n    t0 = \u003cspan class=\"hljs-title function_\"\u003e__jsx\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"p\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Hi: \"\u003c/span\u003e, name);\n    $[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = name;\n    $[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] = t0;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    t0 = $[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e];\n  }\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e t1;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ($[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] === \u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"react.memo_cache_sentinel\"\u003c/span\u003e)) {\n    t1 = \u003cspan class=\"hljs-title function_\"\u003e__jsx\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"strong\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Static Content\"\u003c/span\u003e);\n    $[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] = t1;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    t1 = $[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\n  }\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e t2;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e ($[\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e] !== t0) {\n    t2 = \u003cspan class=\"hljs-title function_\"\u003e__jsx\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"div\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, t0, t1);\n    $[\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e] = t0;\n    $[\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e] = t2;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    t2 = $[\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e];\n  }\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e t2;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기에서 컴파일러에 의해 상태가 자동으로 캐시됩니다. 따라서 다음 렌더링에서는 값이 캐시에서 반환됩니다. 이름의 값을 변경할 때만 if 블록으로 이동하여 향후 렌더링을 위해 캐시에 저장합니다.\u003c/p\u003e\n\u003cp\u003e결론:\nReact에 컴파일러를 추가하면 프로그래머들이 더 쉽게 최적화된 코드를 작성할 수 있습니다. 이 블로그에서는 React의 컴파일러가 출시되면 기대할 수 있는 기능을 분석하고 이해하기 위한 기본 사용 사례를 탐색했습니다.\nReact 컴파일러의 고급 개념 및 사용 사례에 대해 계속 알아보십시오. 정적 분석, 최적화된 렌더링 및 useMemo와 같은 고급 훅의 사용과 같은 추가 기능을 탐색할 예정입니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-20-ReactCompileranewwaytoReact"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>