<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SwiftUI에서 HTML 렌더링하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-RenderHTMLinSwiftUI" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SwiftUI에서 HTML 렌더링하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="SwiftUI에서 HTML 렌더링하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-RenderHTMLinSwiftUI" data-gatsby-head="true"/><meta name="twitter:title" content="SwiftUI에서 HTML 렌더링하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 03:39" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SwiftUI에서 HTML 렌더링하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SwiftUI에서 HTML 렌더링하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-RenderHTMLinSwiftUI&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>NSAttributedString, UITextView 및 UIViewRepresentable를 사용하여 SwiftUI에서 HTML 렌더링하기.</h2>
<p><img src="/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png" alt="이미지"></p>
<p>SwiftUI는 멋지지만 여전히 기능이 부족한 것이 많습니다. 몇 년간 UIKit을 사용한 후 익숙해진 기능이죠. 그 중 하나는 NSAttributedString 및 UITextView를 사용하여 간단한 HTML 텍스트를 렌더링할 수 있는 기능입니다.</p>
<p>이 글에서는 SwiftUI를 UIViewRepresentable을 사용하여 UIKit과 연결하고, HTML을 렌더링하는 사용자 정의 SwiftUI View를 만드는 방법을 간단히 살펴보겠습니다.</p>
<p>업데이트: 원본 기사 개선 사항</p>
<p>이 기사의 원본 버전에서는 NSAttributedString을 사용하여 HTML을 스타일링하고 렌더링하는 데 특화된 간단한 사용자 정의 SwiftUI 뷰를 만드는 방법에 대해 살펴보았습니다. 이 기사에서는 AttributedText 뷰도 언급되었습니다. 그러나 이로 인해 이상한 동작이 발생했는데, 아직 적절한 해결책을 찾지 못했습니다. 따라서 이 기사의 업데이트된 버전에서는 HTML 뷰를 제거하고 NSAttributedString에 대한 편리한 확장 기능이 몇 가지 추가되었습니다. 나는 이상한 동작에 대한 더 나은 이해를 얻기 위해 Apple 개발자 포럼과 스택 오버플로에 게시했습니다.</p>
<h2>주요 포인트</h2>
<ul>
<li>UIViewRepresentable 프로토콜을 사용하여 UIKit 뷰를 SwiftUI 뷰 계층구조에 포함할 수 있습니다.</li>
<li>NSAttributedString (UITextView를 통해)의 강력한 기능을 노출할 수 있으며, 현재 SwiftUI 세계에는 동등한 것이 없습니다 (하지만 AttributedString는 좋은 후보일 수 있음).</li>
<li>스타일이 지정된 HTML 형식의 NSAttributedStrings는 UIViewRepresentable에 의해 관리되는 UITextView에 의해 렌더링될 수 있습니다. HTML 형식의 텍스트에서 일부 CSS 스타일 속성을 인라인으로 정의하거나 HTML 형식의 텍스트의 전용 스타일 태그로 정의할 수 있습니다.</li>
</ul>
<p>이 기사에서 사용된 완성된 예제 코드는 GitHub에서 찾을 수 있어요: <a href="https://github.com/thomsmed/ios-examples/tree/main/SwiftUIHTML" rel="nofollow" target="_blank">https://github.com/thomsmed/ios-examples/tree/main/SwiftUIHTML</a>.</p>
<h1>커스텀 UIViewRepresentable</h1>
<p>SwiftUI가 처음 발표됐을 때는 기존 UIKit 뷰를 SwiftUI 뷰 계층구조에 임베드할 수 있도록 하는 API도 함께 제공되었습니다. 개발자들에게 UIKit에서 SwiftUI로의 전환이 쉬워졌어요.</p>
<p>이러한 API 중 하나는 UIViewRepresentable 프로토콜인데요, SwiftUI의 컨텍스트에서 UIKit 뷰를 관리하는 데 사용돼요. Apple은 이 프로토콜과 다른 SwiftUI와 UIKit을 연결하는 프로토콜을 통해 이를 통한 가능성을 보여주는 멋진 WWDC 비디오를 제공했어요. 적어도 'Integrating SwiftUI'를 확인해보시기를 권해요.</p>
<h2>AttributedText</h2>
<p>NSAttributedString은 텍스트 문자열을 강력하게 관리하는 도구로, 텍스트 문자열의 문자 범위를 스타일링하는 강력한 방법을 제공합니다. 심지어 간단한 HTML에 따라 텍스트를 스타일링할 수도 있습니다.</p>
<p>NSAttributedString을 스타일링된 상태로 초기화하려면 NSAttributedString.init(data:options:documentAttributes:) 이니셜라이저에 .documentType 옵션을 .html로 설정한 HTML 문자열(데이터 형식으로)을 전달하면 됩니다. 그리고 UITextView와 함께 사용하여 앱에서 HTML을 렌더링할 수 있습니다!</p>
<p>UIViewRepresentable 프로토콜을 사용하여 NSAttributedString 및 UITextView의 기능을 SwiftUI에 사용되는 사용자 지정 AttributedText View로 노출시킬 것입니다!</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">AttributedText</span>: <span class="hljs-title class_">UIViewRepresentable</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> attributedString: <span class="hljs-type">NSAttributedString</span>

    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">attributedString</span>: <span class="hljs-type">NSAttributedString</span>) {
        <span class="hljs-keyword">self</span>.attributedString <span class="hljs-operator">=</span> attributedString
    }

    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeUIView</span>(<span class="hljs-params">context</span>: <span class="hljs-type">Context</span>) -> <span class="hljs-type">UITextView</span> {
        <span class="hljs-comment">// SwiftUI이 이 "View"를 렌더링하는 첫 번째 시간에 호출됩니다.</span>

        <span class="hljs-keyword">let</span> uiTextView <span class="hljs-operator">=</span> <span class="hljs-type">UITextView</span>()

        <span class="hljs-comment">// 배경 뷰가 반짝일 수 있도록 투명하게 만듭니다.</span>
        uiTextView.backgroundColor <span class="hljs-operator">=</span> .clear

        <span class="hljs-comment">// 텍스트 시각화만을 위한 것이므로 편집되지 않도록 합니다.</span>
        uiTextView.isEditable <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>

        <span class="hljs-comment">// UITextView를 가능한 너비에 맞게 유연하게 만들지만, 콘텐츠에 맞는 높이를 요구합니다.</span>
        <span class="hljs-comment">// 또한 UITextView가 스크롤되지 않게 하여 UITextView가 텍스트 콘텐츠와 일치하도록 `intrinsicContentSize`를 설정합니다.</span>
        uiTextView.isScrollEnabled <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>
        uiTextView.setContentHuggingPriority(.defaultLow, for: .vertical)
        uiTextView.setContentHuggingPriority(.defaultLow, for: .horizontal)
        uiTextView.setContentCompressionResistancePriority(.required, for: .vertical)
        uiTextView.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)

        <span class="hljs-keyword">return</span> uiTextView
    }

    <span class="hljs-keyword">func</span> <span class="hljs-title function_">updateUIView</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">uiTextView</span>: <span class="hljs-type">UITextView</span>, <span class="hljs-params">context</span>: <span class="hljs-type">Context</span>) {
        <span class="hljs-comment">// SwiftUI이 이 UIViewRepresentable을 처음 렌더링하는 시간과 상태 변경에 대해 알림을 받을 때마다 호출됩니다. (예: @State 변수를 통해)</span>
        uiTextView.attributedText <span class="hljs-operator">=</span> attributedString
    }
}
</code></pre>
<p>UIViewRepresentable로 위에서 정의한 AttributedText를 사용하여 SwiftUI 앱에서 NSAttributedStrings를 렌더링할 수 있습니다. HTML 형식의 텍스트로 초기화된 NSAttributedStrings를 렌더링하는 것이 주된 목표이므로 NSAttributedString에 대한 편의 생성자를 만듭니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">import</span> UIKit

<span class="hljs-keyword">extension</span> <span class="hljs-title class_">NSAttributedString</span> {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">html</span>(<span class="hljs-params">withBody</span> <span class="hljs-params">body</span>: <span class="hljs-type">String</span>) -> <span class="hljs-type">NSAttributedString</span> {
        <span class="hljs-comment">// 앱에서 사용되는 현재 로케이션과 일치하는 HTML `lang` 속성을 매치합니다. (즉, Bundle.main)</span>
        <span class="hljs-keyword">let</span> bundle <span class="hljs-operator">=</span> <span class="hljs-type">Bundle</span>.main
        <span class="hljs-keyword">let</span> lang <span class="hljs-operator">=</span> bundle.preferredLocalizations.first
            <span class="hljs-operator">??</span> bundle.developmentLocalization
            <span class="hljs-operator">??</span> <span class="hljs-string">"en"</span>

        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">try?</span> <span class="hljs-type">NSAttributedString</span>(
            data: <span class="hljs-string">"""
            &#x3C;!doctype html>
            &#x3C;html lang="<span class="hljs-subst">\(lang)</span>">
            &#x3C;head>
                &#x3C;meta charset="utf-8">
                &#x3C;style type="text/css">
                    /*
                      HTML 형식의 텍스트에 대한 사용자 정의 CSS 스타일 지정
                      주의: NSAttributedString/UITextView에서 지원하는 CSS 기능은 제한적입니다.
                    */

                    body {
                        font: -apple-system-body;
                        color: <span class="hljs-subst">\(UIColor.secondaryLabel.hex)</span>;
                    }

                    h1, h2, h3, h4, h5, h6 {
                        color: <span class="hljs-subst">\(UIColor.label.hex)</span>;
                    }

                    a {
                        color: <span class="hljs-subst">\(UIColor.systemGreen.hex)</span>;
                    }

                    li:last-child {
                        margin-bottom: 1em;
                    }
                &#x3C;/style>
            &#x3C;/head>
            &#x3C;body>
                <span class="hljs-subst">\(body)</span>
            &#x3C;/body>
            &#x3C;/html>
            """</span>.data(using: .utf8)<span class="hljs-operator">!</span>,
            options: [
                .documentType: <span class="hljs-type">NSAttributedString</span>.<span class="hljs-type">DocumentType</span>.html,
                .characterEncoding: <span class="hljs-type">String</span>.<span class="hljs-type">Encoding</span>.utf8.rawValue,
            ],
            documentAttributes: <span class="hljs-literal">nil</span>
        )) <span class="hljs-operator">??</span> <span class="hljs-type">NSAttributedString</span>(string: body)
    }
}

<span class="hljs-comment">// UIColor를 CSS 친화적인 색상 헥스 문자열로 변환</span>

<span class="hljs-keyword">private</span> <span class="hljs-keyword">extension</span> <span class="hljs-title class_">UIColor</span> {
    <span class="hljs-keyword">var</span> hex: <span class="hljs-type">String</span> {
        <span class="hljs-keyword">var</span> red: <span class="hljs-type">CGFloat</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">var</span> green: <span class="hljs-type">CGFloat</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">var</span> blue: <span class="hljs-type">CGFloat</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">var</span> alpha: <span class="hljs-type">CGFloat</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>

        getRed(<span class="hljs-operator">&#x26;</span>red, green: <span class="hljs-operator">&#x26;</span>green, blue: <span class="hljs-operator">&#x26;</span>blue, alpha: <span class="hljs-operator">&#x26;</span>alpha)

        <span class="hljs-keyword">return</span> <span class="hljs-type">String</span>(
            format: <span class="hljs-string">"#%02lX%02lX%02lX%02lX"</span>,
            lroundf(<span class="hljs-type">Float</span>(red <span class="hljs-operator">*</span> <span class="hljs-number">255</span>)),
            lroundf(<span class="hljs-type">Float</span>(green <span class="hljs-operator">*</span> <span class="hljs-number">255</span>)),
            lroundf(<span class="hljs-type">Float</span>(blue <span class="hljs-operator">*</span> <span class="hljs-number">255</span>)),
            lroundf(<span class="hljs-type">Float</span>(alpha <span class="hljs-operator">*</span> <span class="hljs-number">255</span>))
        )
    }
}
</code></pre>
<p>NSAttributedString은 일부 CSS 기능을 지원합니다 (안타깝게도 어딘가 제대로 문서화되지 않은 기능들이 있습니다), 하지만 인라인 및 별도의 태그 내에서 스타일을 정의하는 것이 가능합니다 (일반적으로 HTML head 태그의 일부로).</p>
<h2>SwiftUI에서 HTML 렌더링하기</h2>
<p>그런 다음, 우리는 AttributedText UIViewRepresentable을 사용하여 NSAttributedString 편리한 초기화자를 함께 사용하여 SwiftUI 앱에서 HTML을 렌더링할 수 있습니다 - 심지어 인라인 스타일링도 가능합니다!</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">SwiftUI</span>

struct <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {
    <span class="hljs-keyword">var</span> <span class="hljs-attr">body</span>: some <span class="hljs-title class_">View</span> {
        <span class="hljs-title class_">NavigationStack</span> {
            <span class="hljs-title class_">ScrollView</span> {
                <span class="hljs-title class_">AttributedText</span>(.<span class="hljs-title function_">html</span>(<span class="hljs-attr">withBody</span>: <span class="hljs-string">""</span><span class="hljs-string">"
                &#x3C;h3>This is a H3 header&#x3C;/h3>
                &#x3C;p>This is a paragraph&#x3C;/p>
                &#x3C;ul>
                    &#x3C;li>List item one&#x3C;/li>
                    &#x3C;li>List item two&#x3C;/li>
                &#x3C;/ul>
                &#x3C;p>This is a paragraph with a &#x3C;a href="</span><span class="hljs-attr">https</span>:<span class="hljs-comment">//developer.apple.com/">link&#x3C;/a>&#x3C;/p></span>
                <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue; text-align: center;"</span>></span>
                    This is a paragraph with inline styling
                <span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span></span>
                <span class="hljs-string">""</span><span class="hljs-string">"))
                .padding()
            }
            .navigationTitle("</span><span class="hljs-title class_">Render</span> <span class="hljs-variable constant_">HTML</span> <span class="hljs-keyword">in</span> <span class="hljs-title class_">SwiftUI</span><span class="hljs-string">")
        }
    }
}
</span></code></pre>
<h2>보너스: 테마별 HTML 렌더링</h2>
<p>만약 앱이 (색상) 테마 개념을 사용하여 앱 전반에 대한 색상 정보 등을 전파한다면, 현재 테마 정보를 기반으로 HTML을 스타일링할 수도 있습니다.</p>
<p>사용자 정의 테마 환경 값과 다른 NSAttributedString 편의 이니셜라이저를 사용하면 다음과 같이 보일 수 있습니다:</p>
<p>사용자 정의 테마 환경 값</p>
<p>다음은 Markdown 형식으로 테이블 태그를 변경한 코드입니다.</p>
<p>import SwiftUI</p>
<p>// Example of a simple Theme struct.
struct Theme {
let textPrimary: UIColor
let textSecondary: UIColor
let textInteractive: UIColor
}</p>
<p>extension Theme {
static let <code>default</code> = Theme(
textPrimary: .label,
textSecondary: .secondaryLabel,
textInteractive: .systemGreen
)
}</p>
<p>private struct ThemeEnvironmentKey: EnvironmentKey {
static var defaultValue: Theme = .default
}</p>
<p>extension EnvironmentValues {
var theme: Theme {
get { self[ThemeEnvironmentKey.self] }
set { self[ThemeEnvironmentKey.self] = newValue }
}
}</p>
<p>NSAttributedString을 위한 편리한 이니셜라이저</p>
<p>import UIKit</p>
<p>extension NSAttributedString {
static func themedHtml(withBody body: String, theme: Theme = .default) -> NSAttributedString {
// Match the HTML <code>lang</code> attribute to current localisation used by the app (aka Bundle.main).
let bundle = Bundle.main
let lang = bundle.preferredLocalizations.first
?? bundle.developmentLocalization
?? "en"</p>
<pre><code>    return (try? NSAttributedString(
        data: """
        &#x3C;!doctype html>
        &#x3C;html lang="\(lang)">
        &#x3C;head>
            &#x3C;meta charset="utf-8">
            &#x3C;style type="text/css">
                /*
                  Custom CSS styling of HTML formatted text.
                  Note, only a limited number of CSS features are supported by NSAttributedString/UITextView.
                */

                body {
                    font: -apple-system-body;
                    color: \(theme.textSecondary.hex);
                }

                h1, h2, h3, h4, h5, h6 {
                    color: \(theme.textPrimary.hex);
                }

                a {
                    color: \(theme.textInteractive.hex);
                }

                li:last-child {
                    margin-bottom: 1em;
                }
            &#x3C;/style>
        &#x3C;/head>
        &#x3C;body>
            \(body)
        &#x3C;/body>
        &#x3C;/html>
        """.data(using: .utf8)!,
        options: [
            .documentType: NSAttributedString.DocumentType.html,
            .characterEncoding: String.Encoding.utf8.rawValue,
        ],
        documentAttributes: nil
    )) ?? NSAttributedString(string: body)
}
</code></pre>
<p>}</p>
<p>// MARK: Converting UIColors into CSS friendly color hex string</p>
<p>private extension UIColor {
var hex: String {
var red: CGFloat = 0
var green: CGFloat = 0
var blue: CGFloat = 0
var alpha: CGFloat = 0</p>
<pre><code>    getRed(&#x26;red, green: &#x26;green, blue: &#x26;blue, alpha: &#x26;alpha)

    return String(
        format: "#%02lX%02lX%02lX%02lX",
        lroundf(Float(red * 255)),
        lroundf(Float(green * 255)),
        lroundf(Float(blue * 255)),
        lroundf(Float(alpha * 255))
    )
}
</code></pre>
<p>}</p>
<p>SwiftUI에서 테마가 적용된 HTML 렌더링하기</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> {
    <span class="hljs-meta">@Environment</span>(\.theme) <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> theme: <span class="hljs-type">Theme</span>

    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        <span class="hljs-type">NavigationStack</span> {
            <span class="hljs-type">ScrollView</span> {
                <span class="hljs-type">AttributedText</span>(.themedHtml(withBody: <span class="hljs-string">"""
                &#x3C;h3>This is a H3 header&#x3C;/h3>
                &#x3C;p>This is a paragraph&#x3C;/p>
                &#x3C;ul>
                    &#x3C;li>List item one&#x3C;/li>
                    &#x3C;li>List item two&#x3C;/li>
                &#x3C;/ul>
                &#x3C;p>This is a paragraph with a &#x3C;a href="https://developer.apple.com/">link&#x3C;/a>&#x3C;/p>
                &#x3C;p style="color: blue; text-align: center;">
                    This is a paragraph with inline styling
                &#x3C;/p>
                """</span>, theme: theme))
                .padding()
            }
            .navigationTitle(<span class="hljs-string">"Render Themed HTML in SwiftUI"</span>)
        }
    }
}
</code></pre>
<h2>이게 다야!</h2>
<p>쉽죠! SwiftUI가 정말 멋지지만, 때로는 몇 년 동안 사랑해 온 UIKit 뷰와 기능을 임베드할 수 있는 것이 참 좋습니다.</p>
<p>코딩하세요! 🙌</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SwiftUI에서 HTML 렌더링하기","description":"","date":"2024-06-20 03:39","slug":"2024-06-20-RenderHTMLinSwiftUI","content":"\n\n## NSAttributedString, UITextView 및 UIViewRepresentable를 사용하여 SwiftUI에서 HTML 렌더링하기.\n\n![이미지](/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png)\n\nSwiftUI는 멋지지만 여전히 기능이 부족한 것이 많습니다. 몇 년간 UIKit을 사용한 후 익숙해진 기능이죠. 그 중 하나는 NSAttributedString 및 UITextView를 사용하여 간단한 HTML 텍스트를 렌더링할 수 있는 기능입니다.\n\n이 글에서는 SwiftUI를 UIViewRepresentable을 사용하여 UIKit과 연결하고, HTML을 렌더링하는 사용자 정의 SwiftUI View를 만드는 방법을 간단히 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n업데이트: 원본 기사 개선 사항\n\n이 기사의 원본 버전에서는 NSAttributedString을 사용하여 HTML을 스타일링하고 렌더링하는 데 특화된 간단한 사용자 정의 SwiftUI 뷰를 만드는 방법에 대해 살펴보았습니다. 이 기사에서는 AttributedText 뷰도 언급되었습니다. 그러나 이로 인해 이상한 동작이 발생했는데, 아직 적절한 해결책을 찾지 못했습니다. 따라서 이 기사의 업데이트된 버전에서는 HTML 뷰를 제거하고 NSAttributedString에 대한 편리한 확장 기능이 몇 가지 추가되었습니다. 나는 이상한 동작에 대한 더 나은 이해를 얻기 위해 Apple 개발자 포럼과 스택 오버플로에 게시했습니다.\n\n## 주요 포인트\n\n- UIViewRepresentable 프로토콜을 사용하여 UIKit 뷰를 SwiftUI 뷰 계층구조에 포함할 수 있습니다.\n- NSAttributedString (UITextView를 통해)의 강력한 기능을 노출할 수 있으며, 현재 SwiftUI 세계에는 동등한 것이 없습니다 (하지만 AttributedString는 좋은 후보일 수 있음).\n- 스타일이 지정된 HTML 형식의 NSAttributedStrings는 UIViewRepresentable에 의해 관리되는 UITextView에 의해 렌더링될 수 있습니다. HTML 형식의 텍스트에서 일부 CSS 스타일 속성을 인라인으로 정의하거나 HTML 형식의 텍스트의 전용 스타일 태그로 정의할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에서 사용된 완성된 예제 코드는 GitHub에서 찾을 수 있어요: https://github.com/thomsmed/ios-examples/tree/main/SwiftUIHTML.\n\n# 커스텀 UIViewRepresentable\n\nSwiftUI가 처음 발표됐을 때는 기존 UIKit 뷰를 SwiftUI 뷰 계층구조에 임베드할 수 있도록 하는 API도 함께 제공되었습니다. 개발자들에게 UIKit에서 SwiftUI로의 전환이 쉬워졌어요.\n\n이러한 API 중 하나는 UIViewRepresentable 프로토콜인데요, SwiftUI의 컨텍스트에서 UIKit 뷰를 관리하는 데 사용돼요. Apple은 이 프로토콜과 다른 SwiftUI와 UIKit을 연결하는 프로토콜을 통해 이를 통한 가능성을 보여주는 멋진 WWDC 비디오를 제공했어요. 적어도 'Integrating SwiftUI'를 확인해보시기를 권해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## AttributedText\n\nNSAttributedString은 텍스트 문자열을 강력하게 관리하는 도구로, 텍스트 문자열의 문자 범위를 스타일링하는 강력한 방법을 제공합니다. 심지어 간단한 HTML에 따라 텍스트를 스타일링할 수도 있습니다.\n\nNSAttributedString을 스타일링된 상태로 초기화하려면 NSAttributedString.init(data:options:documentAttributes:) 이니셜라이저에 .documentType 옵션을 .html로 설정한 HTML 문자열(데이터 형식으로)을 전달하면 됩니다. 그리고 UITextView와 함께 사용하여 앱에서 HTML을 렌더링할 수 있습니다!\n\nUIViewRepresentable 프로토콜을 사용하여 NSAttributedString 및 UITextView의 기능을 SwiftUI에 사용되는 사용자 지정 AttributedText View로 노출시킬 것입니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nimport SwiftUI\n\nstruct AttributedText: UIViewRepresentable {\n    private let attributedString: NSAttributedString\n\n    init(_ attributedString: NSAttributedString) {\n        self.attributedString = attributedString\n    }\n\n    func makeUIView(context: Context) -\u003e UITextView {\n        // SwiftUI이 이 \"View\"를 렌더링하는 첫 번째 시간에 호출됩니다.\n\n        let uiTextView = UITextView()\n\n        // 배경 뷰가 반짝일 수 있도록 투명하게 만듭니다.\n        uiTextView.backgroundColor = .clear\n\n        // 텍스트 시각화만을 위한 것이므로 편집되지 않도록 합니다.\n        uiTextView.isEditable = false\n\n        // UITextView를 가능한 너비에 맞게 유연하게 만들지만, 콘텐츠에 맞는 높이를 요구합니다.\n        // 또한 UITextView가 스크롤되지 않게 하여 UITextView가 텍스트 콘텐츠와 일치하도록 `intrinsicContentSize`를 설정합니다.\n        uiTextView.isScrollEnabled = false\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .vertical)\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .horizontal)\n        uiTextView.setContentCompressionResistancePriority(.required, for: .vertical)\n        uiTextView.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)\n\n        return uiTextView\n    }\n\n    func updateUIView(_ uiTextView: UITextView, context: Context) {\n        // SwiftUI이 이 UIViewRepresentable을 처음 렌더링하는 시간과 상태 변경에 대해 알림을 받을 때마다 호출됩니다. (예: @State 변수를 통해)\n        uiTextView.attributedText = attributedString\n    }\n}\n```\n\nUIViewRepresentable로 위에서 정의한 AttributedText를 사용하여 SwiftUI 앱에서 NSAttributedStrings를 렌더링할 수 있습니다. HTML 형식의 텍스트로 초기화된 NSAttributedStrings를 렌더링하는 것이 주된 목표이므로 NSAttributedString에 대한 편의 생성자를 만듭니다.\n\n```swift\nimport UIKit\n\nextension NSAttributedString {\n    static func html(withBody body: String) -\u003e NSAttributedString {\n        // 앱에서 사용되는 현재 로케이션과 일치하는 HTML `lang` 속성을 매치합니다. (즉, Bundle.main)\n        let bundle = Bundle.main\n        let lang = bundle.preferredLocalizations.first\n            ?? bundle.developmentLocalization\n            ?? \"en\"\n\n        return (try? NSAttributedString(\n            data: \"\"\"\n            \u003c!doctype html\u003e\n            \u003chtml lang=\"\\(lang)\"\u003e\n            \u003chead\u003e\n                \u003cmeta charset=\"utf-8\"\u003e\n                \u003cstyle type=\"text/css\"\u003e\n                    /*\n                      HTML 형식의 텍스트에 대한 사용자 정의 CSS 스타일 지정\n                      주의: NSAttributedString/UITextView에서 지원하는 CSS 기능은 제한적입니다.\n                    */\n\n                    body {\n                        font: -apple-system-body;\n                        color: \\(UIColor.secondaryLabel.hex);\n                    }\n\n                    h1, h2, h3, h4, h5, h6 {\n                        color: \\(UIColor.label.hex);\n                    }\n\n                    a {\n                        color: \\(UIColor.systemGreen.hex);\n                    }\n\n                    li:last-child {\n                        margin-bottom: 1em;\n                    }\n                \u003c/style\u003e\n            \u003c/head\u003e\n            \u003cbody\u003e\n                \\(body)\n            \u003c/body\u003e\n            \u003c/html\u003e\n            \"\"\".data(using: .utf8)!,\n            options: [\n                .documentType: NSAttributedString.DocumentType.html,\n                .characterEncoding: String.Encoding.utf8.rawValue,\n            ],\n            documentAttributes: nil\n        )) ?? NSAttributedString(string: body)\n    }\n}\n\n// UIColor를 CSS 친화적인 색상 헥스 문자열로 변환\n\nprivate extension UIColor {\n    var hex: String {\n        var red: CGFloat = 0\n        var green: CGFloat = 0\n        var blue: CGFloat = 0\n        var alpha: CGFloat = 0\n\n        getRed(\u0026red, green: \u0026green, blue: \u0026blue, alpha: \u0026alpha)\n\n        return String(\n            format: \"#%02lX%02lX%02lX%02lX\",\n            lroundf(Float(red * 255)),\n            lroundf(Float(green * 255)),\n            lroundf(Float(blue * 255)),\n            lroundf(Float(alpha * 255))\n        )\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNSAttributedString은 일부 CSS 기능을 지원합니다 (안타깝게도 어딘가 제대로 문서화되지 않은 기능들이 있습니다), 하지만 인라인 및 별도의 태그 내에서 스타일을 정의하는 것이 가능합니다 (일반적으로 HTML head 태그의 일부로).\n\n## SwiftUI에서 HTML 렌더링하기\n\n그런 다음, 우리는 AttributedText UIViewRepresentable을 사용하여 NSAttributedString 편리한 초기화자를 함께 사용하여 SwiftUI 앱에서 HTML을 렌더링할 수 있습니다 - 심지어 인라인 스타일링도 가능합니다!\n\n```js\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        NavigationStack {\n            ScrollView {\n                AttributedText(.html(withBody: \"\"\"\n                \u003ch3\u003eThis is a H3 header\u003c/h3\u003e\n                \u003cp\u003eThis is a paragraph\u003c/p\u003e\n                \u003cul\u003e\n                    \u003cli\u003eList item one\u003c/li\u003e\n                    \u003cli\u003eList item two\u003c/li\u003e\n                \u003c/ul\u003e\n                \u003cp\u003eThis is a paragraph with a \u003ca href=\"https://developer.apple.com/\"\u003elink\u003c/a\u003e\u003c/p\u003e\n                \u003cp style=\"color: blue; text-align: center;\"\u003e\n                    This is a paragraph with inline styling\n                \u003c/p\u003e\n                \"\"\"))\n                .padding()\n            }\n            .navigationTitle(\"Render HTML in SwiftUI\")\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 보너스: 테마별 HTML 렌더링\n\n만약 앱이 (색상) 테마 개념을 사용하여 앱 전반에 대한 색상 정보 등을 전파한다면, 현재 테마 정보를 기반으로 HTML을 스타일링할 수도 있습니다.\n\n사용자 정의 테마 환경 값과 다른 NSAttributedString 편의 이니셜라이저를 사용하면 다음과 같이 보일 수 있습니다:\n\n사용자 정의 테마 환경 값\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 Markdown 형식으로 테이블 태그를 변경한 코드입니다.\n\n\nimport SwiftUI\n\n// Example of a simple Theme struct.\nstruct Theme {\n    let textPrimary: UIColor\n    let textSecondary: UIColor\n    let textInteractive: UIColor\n}\n\nextension Theme {\n    static let `default` = Theme(\n        textPrimary: .label,\n        textSecondary: .secondaryLabel,\n        textInteractive: .systemGreen\n    )\n}\n\nprivate struct ThemeEnvironmentKey: EnvironmentKey {\n    static var defaultValue: Theme = .default\n}\n\nextension EnvironmentValues {\n    var theme: Theme {\n        get { self[ThemeEnvironmentKey.self] }\n        set { self[ThemeEnvironmentKey.self] = newValue }\n    }\n}\n\n\nNSAttributedString을 위한 편리한 이니셜라이저\n\n\nimport UIKit\n\nextension NSAttributedString {\n    static func themedHtml(withBody body: String, theme: Theme = .default) -\u003e NSAttributedString {\n        // Match the HTML `lang` attribute to current localisation used by the app (aka Bundle.main).\n        let bundle = Bundle.main\n        let lang = bundle.preferredLocalizations.first\n            ?? bundle.developmentLocalization\n            ?? \"en\"\n\n        return (try? NSAttributedString(\n            data: \"\"\"\n            \u003c!doctype html\u003e\n            \u003chtml lang=\"\\(lang)\"\u003e\n            \u003chead\u003e\n                \u003cmeta charset=\"utf-8\"\u003e\n                \u003cstyle type=\"text/css\"\u003e\n                    /*\n                      Custom CSS styling of HTML formatted text.\n                      Note, only a limited number of CSS features are supported by NSAttributedString/UITextView.\n                    */\n\n                    body {\n                        font: -apple-system-body;\n                        color: \\(theme.textSecondary.hex);\n                    }\n\n                    h1, h2, h3, h4, h5, h6 {\n                        color: \\(theme.textPrimary.hex);\n                    }\n\n                    a {\n                        color: \\(theme.textInteractive.hex);\n                    }\n\n                    li:last-child {\n                        margin-bottom: 1em;\n                    }\n                \u003c/style\u003e\n            \u003c/head\u003e\n            \u003cbody\u003e\n                \\(body)\n            \u003c/body\u003e\n            \u003c/html\u003e\n            \"\"\".data(using: .utf8)!,\n            options: [\n                .documentType: NSAttributedString.DocumentType.html,\n                .characterEncoding: String.Encoding.utf8.rawValue,\n            ],\n            documentAttributes: nil\n        )) ?? NSAttributedString(string: body)\n    }\n}\n\n// MARK: Converting UIColors into CSS friendly color hex string\n\nprivate extension UIColor {\n    var hex: String {\n        var red: CGFloat = 0\n        var green: CGFloat = 0\n        var blue: CGFloat = 0\n        var alpha: CGFloat = 0\n\n        getRed(\u0026red, green: \u0026green, blue: \u0026blue, alpha: \u0026alpha)\n\n        return String(\n            format: \"#%02lX%02lX%02lX%02lX\",\n            lroundf(Float(red * 255)),\n            lroundf(Float(green * 255)),\n            lroundf(Float(blue * 255)),\n            lroundf(Float(alpha * 255))\n        )\n    }\n}\n\n\nSwiftUI에서 테마가 적용된 HTML 렌더링하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    @Environment(\\.theme) private var theme: Theme\n\n    var body: some View {\n        NavigationStack {\n            ScrollView {\n                AttributedText(.themedHtml(withBody: \"\"\"\n                \u003ch3\u003eThis is a H3 header\u003c/h3\u003e\n                \u003cp\u003eThis is a paragraph\u003c/p\u003e\n                \u003cul\u003e\n                    \u003cli\u003eList item one\u003c/li\u003e\n                    \u003cli\u003eList item two\u003c/li\u003e\n                \u003c/ul\u003e\n                \u003cp\u003eThis is a paragraph with a \u003ca href=\"https://developer.apple.com/\"\u003elink\u003c/a\u003e\u003c/p\u003e\n                \u003cp style=\"color: blue; text-align: center;\"\u003e\n                    This is a paragraph with inline styling\n                \u003c/p\u003e\n                \"\"\", theme: theme))\n                .padding()\n            }\n            .navigationTitle(\"Render Themed HTML in SwiftUI\")\n        }\n    }\n}\n```\n\n## 이게 다야!\n\n쉽죠! SwiftUI가 정말 멋지지만, 때로는 몇 년 동안 사랑해 온 UIKit 뷰와 기능을 임베드할 수 있는 것이 참 좋습니다.\n\n코딩하세요! 🙌\n","ogImage":{"url":"/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png"},"coverImage":"/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003eNSAttributedString, UITextView 및 UIViewRepresentable를 사용하여 SwiftUI에서 HTML 렌더링하기.\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-RenderHTMLinSwiftUI_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eSwiftUI는 멋지지만 여전히 기능이 부족한 것이 많습니다. 몇 년간 UIKit을 사용한 후 익숙해진 기능이죠. 그 중 하나는 NSAttributedString 및 UITextView를 사용하여 간단한 HTML 텍스트를 렌더링할 수 있는 기능입니다.\u003c/p\u003e\n\u003cp\u003e이 글에서는 SwiftUI를 UIViewRepresentable을 사용하여 UIKit과 연결하고, HTML을 렌더링하는 사용자 정의 SwiftUI View를 만드는 방법을 간단히 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e업데이트: 원본 기사 개선 사항\u003c/p\u003e\n\u003cp\u003e이 기사의 원본 버전에서는 NSAttributedString을 사용하여 HTML을 스타일링하고 렌더링하는 데 특화된 간단한 사용자 정의 SwiftUI 뷰를 만드는 방법에 대해 살펴보았습니다. 이 기사에서는 AttributedText 뷰도 언급되었습니다. 그러나 이로 인해 이상한 동작이 발생했는데, 아직 적절한 해결책을 찾지 못했습니다. 따라서 이 기사의 업데이트된 버전에서는 HTML 뷰를 제거하고 NSAttributedString에 대한 편리한 확장 기능이 몇 가지 추가되었습니다. 나는 이상한 동작에 대한 더 나은 이해를 얻기 위해 Apple 개발자 포럼과 스택 오버플로에 게시했습니다.\u003c/p\u003e\n\u003ch2\u003e주요 포인트\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eUIViewRepresentable 프로토콜을 사용하여 UIKit 뷰를 SwiftUI 뷰 계층구조에 포함할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eNSAttributedString (UITextView를 통해)의 강력한 기능을 노출할 수 있으며, 현재 SwiftUI 세계에는 동등한 것이 없습니다 (하지만 AttributedString는 좋은 후보일 수 있음).\u003c/li\u003e\n\u003cli\u003e스타일이 지정된 HTML 형식의 NSAttributedStrings는 UIViewRepresentable에 의해 관리되는 UITextView에 의해 렌더링될 수 있습니다. HTML 형식의 텍스트에서 일부 CSS 스타일 속성을 인라인으로 정의하거나 HTML 형식의 텍스트의 전용 스타일 태그로 정의할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 기사에서 사용된 완성된 예제 코드는 GitHub에서 찾을 수 있어요: \u003ca href=\"https://github.com/thomsmed/ios-examples/tree/main/SwiftUIHTML\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/thomsmed/ios-examples/tree/main/SwiftUIHTML\u003c/a\u003e.\u003c/p\u003e\n\u003ch1\u003e커스텀 UIViewRepresentable\u003c/h1\u003e\n\u003cp\u003eSwiftUI가 처음 발표됐을 때는 기존 UIKit 뷰를 SwiftUI 뷰 계층구조에 임베드할 수 있도록 하는 API도 함께 제공되었습니다. 개발자들에게 UIKit에서 SwiftUI로의 전환이 쉬워졌어요.\u003c/p\u003e\n\u003cp\u003e이러한 API 중 하나는 UIViewRepresentable 프로토콜인데요, SwiftUI의 컨텍스트에서 UIKit 뷰를 관리하는 데 사용돼요. Apple은 이 프로토콜과 다른 SwiftUI와 UIKit을 연결하는 프로토콜을 통해 이를 통한 가능성을 보여주는 멋진 WWDC 비디오를 제공했어요. 적어도 'Integrating SwiftUI'를 확인해보시기를 권해요.\u003c/p\u003e\n\u003ch2\u003eAttributedText\u003c/h2\u003e\n\u003cp\u003eNSAttributedString은 텍스트 문자열을 강력하게 관리하는 도구로, 텍스트 문자열의 문자 범위를 스타일링하는 강력한 방법을 제공합니다. 심지어 간단한 HTML에 따라 텍스트를 스타일링할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003eNSAttributedString을 스타일링된 상태로 초기화하려면 NSAttributedString.init(data:options:documentAttributes:) 이니셜라이저에 .documentType 옵션을 .html로 설정한 HTML 문자열(데이터 형식으로)을 전달하면 됩니다. 그리고 UITextView와 함께 사용하여 앱에서 HTML을 렌더링할 수 있습니다!\u003c/p\u003e\n\u003cp\u003eUIViewRepresentable 프로토콜을 사용하여 NSAttributedString 및 UITextView의 기능을 SwiftUI에 사용되는 사용자 지정 AttributedText View로 노출시킬 것입니다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e SwiftUI\n\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAttributedText\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUIViewRepresentable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e attributedString: \u003cspan class=\"hljs-type\"\u003eNSAttributedString\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eattributedString\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eNSAttributedString\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.attributedString \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e attributedString\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emakeUIView\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003econtext\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eContext\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-type\"\u003eUITextView\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// SwiftUI이 이 \"View\"를 렌더링하는 첫 번째 시간에 호출됩니다.\u003c/span\u003e\n\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e uiTextView \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eUITextView\u003c/span\u003e()\n\n        \u003cspan class=\"hljs-comment\"\u003e// 배경 뷰가 반짝일 수 있도록 투명하게 만듭니다.\u003c/span\u003e\n        uiTextView.backgroundColor \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e .clear\n\n        \u003cspan class=\"hljs-comment\"\u003e// 텍스트 시각화만을 위한 것이므로 편집되지 않도록 합니다.\u003c/span\u003e\n        uiTextView.isEditable \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n\n        \u003cspan class=\"hljs-comment\"\u003e// UITextView를 가능한 너비에 맞게 유연하게 만들지만, 콘텐츠에 맞는 높이를 요구합니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 또한 UITextView가 스크롤되지 않게 하여 UITextView가 텍스트 콘텐츠와 일치하도록 `intrinsicContentSize`를 설정합니다.\u003c/span\u003e\n        uiTextView.isScrollEnabled \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .vertical)\n        uiTextView.setContentHuggingPriority(.defaultLow, for: .horizontal)\n        uiTextView.setContentCompressionResistancePriority(.required, for: .vertical)\n        uiTextView.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e uiTextView\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eupdateUIView\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003euiTextView\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eUITextView\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003econtext\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eContext\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// SwiftUI이 이 UIViewRepresentable을 처음 렌더링하는 시간과 상태 변경에 대해 알림을 받을 때마다 호출됩니다. (예: @State 변수를 통해)\u003c/span\u003e\n        uiTextView.attributedText \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e attributedString\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUIViewRepresentable로 위에서 정의한 AttributedText를 사용하여 SwiftUI 앱에서 NSAttributedStrings를 렌더링할 수 있습니다. HTML 형식의 텍스트로 초기화된 NSAttributedStrings를 렌더링하는 것이 주된 목표이므로 NSAttributedString에 대한 편의 생성자를 만듭니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e UIKit\n\n\u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNSAttributedString\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehtml\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ewithBody\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003ebody\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-type\"\u003eNSAttributedString\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 앱에서 사용되는 현재 로케이션과 일치하는 HTML `lang` 속성을 매치합니다. (즉, Bundle.main)\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e bundle \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eBundle\u003c/span\u003e.main\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e lang \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e bundle.preferredLocalizations.first\n            \u003cspan class=\"hljs-operator\"\u003e??\u003c/span\u003e bundle.developmentLocalization\n            \u003cspan class=\"hljs-operator\"\u003e??\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"en\"\u003c/span\u003e\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etry?\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eNSAttributedString\u003c/span\u003e(\n            data: \u003cspan class=\"hljs-string\"\u003e\"\"\"\n            \u0026#x3C;!doctype html\u003e\n            \u0026#x3C;html lang=\"\u003cspan class=\"hljs-subst\"\u003e\\(lang)\u003c/span\u003e\"\u003e\n            \u0026#x3C;head\u003e\n                \u0026#x3C;meta charset=\"utf-8\"\u003e\n                \u0026#x3C;style type=\"text/css\"\u003e\n                    /*\n                      HTML 형식의 텍스트에 대한 사용자 정의 CSS 스타일 지정\n                      주의: NSAttributedString/UITextView에서 지원하는 CSS 기능은 제한적입니다.\n                    */\n\n                    body {\n                        font: -apple-system-body;\n                        color: \u003cspan class=\"hljs-subst\"\u003e\\(UIColor.secondaryLabel.hex)\u003c/span\u003e;\n                    }\n\n                    h1, h2, h3, h4, h5, h6 {\n                        color: \u003cspan class=\"hljs-subst\"\u003e\\(UIColor.label.hex)\u003c/span\u003e;\n                    }\n\n                    a {\n                        color: \u003cspan class=\"hljs-subst\"\u003e\\(UIColor.systemGreen.hex)\u003c/span\u003e;\n                    }\n\n                    li:last-child {\n                        margin-bottom: 1em;\n                    }\n                \u0026#x3C;/style\u003e\n            \u0026#x3C;/head\u003e\n            \u0026#x3C;body\u003e\n                \u003cspan class=\"hljs-subst\"\u003e\\(body)\u003c/span\u003e\n            \u0026#x3C;/body\u003e\n            \u0026#x3C;/html\u003e\n            \"\"\"\u003c/span\u003e.data(using: .utf8)\u003cspan class=\"hljs-operator\"\u003e!\u003c/span\u003e,\n            options: [\n                .documentType: \u003cspan class=\"hljs-type\"\u003eNSAttributedString\u003c/span\u003e.\u003cspan class=\"hljs-type\"\u003eDocumentType\u003c/span\u003e.html,\n                .characterEncoding: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e.\u003cspan class=\"hljs-type\"\u003eEncoding\u003c/span\u003e.utf8.rawValue,\n            ],\n            documentAttributes: \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e\n        )) \u003cspan class=\"hljs-operator\"\u003e??\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eNSAttributedString\u003c/span\u003e(string: body)\n    }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// UIColor를 CSS 친화적인 색상 헥스 문자열로 변환\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUIColor\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e hex: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e red: \u003cspan class=\"hljs-type\"\u003eCGFloat\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e green: \u003cspan class=\"hljs-type\"\u003eCGFloat\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e blue: \u003cspan class=\"hljs-type\"\u003eCGFloat\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e alpha: \u003cspan class=\"hljs-type\"\u003eCGFloat\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n        getRed(\u003cspan class=\"hljs-operator\"\u003e\u0026#x26;\u003c/span\u003ered, green: \u003cspan class=\"hljs-operator\"\u003e\u0026#x26;\u003c/span\u003egreen, blue: \u003cspan class=\"hljs-operator\"\u003e\u0026#x26;\u003c/span\u003eblue, alpha: \u003cspan class=\"hljs-operator\"\u003e\u0026#x26;\u003c/span\u003ealpha)\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e(\n            format: \u003cspan class=\"hljs-string\"\u003e\"#%02lX%02lX%02lX%02lX\"\u003c/span\u003e,\n            lroundf(\u003cspan class=\"hljs-type\"\u003eFloat\u003c/span\u003e(red \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e)),\n            lroundf(\u003cspan class=\"hljs-type\"\u003eFloat\u003c/span\u003e(green \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e)),\n            lroundf(\u003cspan class=\"hljs-type\"\u003eFloat\u003c/span\u003e(blue \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e)),\n            lroundf(\u003cspan class=\"hljs-type\"\u003eFloat\u003c/span\u003e(alpha \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e))\n        )\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNSAttributedString은 일부 CSS 기능을 지원합니다 (안타깝게도 어딘가 제대로 문서화되지 않은 기능들이 있습니다), 하지만 인라인 및 별도의 태그 내에서 스타일을 정의하는 것이 가능합니다 (일반적으로 HTML head 태그의 일부로).\u003c/p\u003e\n\u003ch2\u003eSwiftUI에서 HTML 렌더링하기\u003c/h2\u003e\n\u003cp\u003e그런 다음, 우리는 AttributedText UIViewRepresentable을 사용하여 NSAttributedString 편리한 초기화자를 함께 사용하여 SwiftUI 앱에서 HTML을 렌더링할 수 있습니다 - 심지어 인라인 스타일링도 가능합니다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSwiftUI\u003c/span\u003e\n\nstruct \u003cspan class=\"hljs-title class_\"\u003eContentView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebody\u003c/span\u003e: some \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-title class_\"\u003eNavigationStack\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eScrollView\u003c/span\u003e {\n                \u003cspan class=\"hljs-title class_\"\u003eAttributedText\u003c/span\u003e(.\u003cspan class=\"hljs-title function_\"\u003ehtml\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ewithBody\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n                \u0026#x3C;h3\u003eThis is a H3 header\u0026#x3C;/h3\u003e\n                \u0026#x3C;p\u003eThis is a paragraph\u0026#x3C;/p\u003e\n                \u0026#x3C;ul\u003e\n                    \u0026#x3C;li\u003eList item one\u0026#x3C;/li\u003e\n                    \u0026#x3C;li\u003eList item two\u0026#x3C;/li\u003e\n                \u0026#x3C;/ul\u003e\n                \u0026#x3C;p\u003eThis is a paragraph with a \u0026#x3C;a href=\"\u003c/span\u003e\u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//developer.apple.com/\"\u003elink\u0026#x3C;/a\u003e\u0026#x3C;/p\u003e\u003c/span\u003e\n                \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"color: blue; text-align: center;\"\u003c/span\u003e\u003e\u003c/span\u003e\n                    This is a paragraph with inline styling\n                \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n                \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"))\n                .padding()\n            }\n            .navigationTitle(\"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003eRender\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eHTML\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSwiftUI\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\")\n        }\n    }\n}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e보너스: 테마별 HTML 렌더링\u003c/h2\u003e\n\u003cp\u003e만약 앱이 (색상) 테마 개념을 사용하여 앱 전반에 대한 색상 정보 등을 전파한다면, 현재 테마 정보를 기반으로 HTML을 스타일링할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e사용자 정의 테마 환경 값과 다른 NSAttributedString 편의 이니셜라이저를 사용하면 다음과 같이 보일 수 있습니다:\u003c/p\u003e\n\u003cp\u003e사용자 정의 테마 환경 값\u003c/p\u003e\n\u003cp\u003e다음은 Markdown 형식으로 테이블 태그를 변경한 코드입니다.\u003c/p\u003e\n\u003cp\u003eimport SwiftUI\u003c/p\u003e\n\u003cp\u003e// Example of a simple Theme struct.\nstruct Theme {\nlet textPrimary: UIColor\nlet textSecondary: UIColor\nlet textInteractive: UIColor\n}\u003c/p\u003e\n\u003cp\u003eextension Theme {\nstatic let \u003ccode\u003edefault\u003c/code\u003e = Theme(\ntextPrimary: .label,\ntextSecondary: .secondaryLabel,\ntextInteractive: .systemGreen\n)\n}\u003c/p\u003e\n\u003cp\u003eprivate struct ThemeEnvironmentKey: EnvironmentKey {\nstatic var defaultValue: Theme = .default\n}\u003c/p\u003e\n\u003cp\u003eextension EnvironmentValues {\nvar theme: Theme {\nget { self[ThemeEnvironmentKey.self] }\nset { self[ThemeEnvironmentKey.self] = newValue }\n}\n}\u003c/p\u003e\n\u003cp\u003eNSAttributedString을 위한 편리한 이니셜라이저\u003c/p\u003e\n\u003cp\u003eimport UIKit\u003c/p\u003e\n\u003cp\u003eextension NSAttributedString {\nstatic func themedHtml(withBody body: String, theme: Theme = .default) -\u003e NSAttributedString {\n// Match the HTML \u003ccode\u003elang\u003c/code\u003e attribute to current localisation used by the app (aka Bundle.main).\nlet bundle = Bundle.main\nlet lang = bundle.preferredLocalizations.first\n?? bundle.developmentLocalization\n?? \"en\"\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    return (try? NSAttributedString(\n        data: \"\"\"\n        \u0026#x3C;!doctype html\u003e\n        \u0026#x3C;html lang=\"\\(lang)\"\u003e\n        \u0026#x3C;head\u003e\n            \u0026#x3C;meta charset=\"utf-8\"\u003e\n            \u0026#x3C;style type=\"text/css\"\u003e\n                /*\n                  Custom CSS styling of HTML formatted text.\n                  Note, only a limited number of CSS features are supported by NSAttributedString/UITextView.\n                */\n\n                body {\n                    font: -apple-system-body;\n                    color: \\(theme.textSecondary.hex);\n                }\n\n                h1, h2, h3, h4, h5, h6 {\n                    color: \\(theme.textPrimary.hex);\n                }\n\n                a {\n                    color: \\(theme.textInteractive.hex);\n                }\n\n                li:last-child {\n                    margin-bottom: 1em;\n                }\n            \u0026#x3C;/style\u003e\n        \u0026#x3C;/head\u003e\n        \u0026#x3C;body\u003e\n            \\(body)\n        \u0026#x3C;/body\u003e\n        \u0026#x3C;/html\u003e\n        \"\"\".data(using: .utf8)!,\n        options: [\n            .documentType: NSAttributedString.DocumentType.html,\n            .characterEncoding: String.Encoding.utf8.rawValue,\n        ],\n        documentAttributes: nil\n    )) ?? NSAttributedString(string: body)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003cp\u003e// MARK: Converting UIColors into CSS friendly color hex string\u003c/p\u003e\n\u003cp\u003eprivate extension UIColor {\nvar hex: String {\nvar red: CGFloat = 0\nvar green: CGFloat = 0\nvar blue: CGFloat = 0\nvar alpha: CGFloat = 0\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    getRed(\u0026#x26;red, green: \u0026#x26;green, blue: \u0026#x26;blue, alpha: \u0026#x26;alpha)\n\n    return String(\n        format: \"#%02lX%02lX%02lX%02lX\",\n        lroundf(Float(red * 255)),\n        lroundf(Float(green * 255)),\n        lroundf(Float(blue * 255)),\n        lroundf(Float(alpha * 255))\n    )\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e}\u003c/p\u003e\n\u003cp\u003eSwiftUI에서 테마가 적용된 HTML 렌더링하기\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e SwiftUI\n\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eContentView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-meta\"\u003e@Environment\u003c/span\u003e(\\.theme) \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e theme: \u003cspan class=\"hljs-type\"\u003eTheme\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003eNavigationStack\u003c/span\u003e {\n            \u003cspan class=\"hljs-type\"\u003eScrollView\u003c/span\u003e {\n                \u003cspan class=\"hljs-type\"\u003eAttributedText\u003c/span\u003e(.themedHtml(withBody: \u003cspan class=\"hljs-string\"\u003e\"\"\"\n                \u0026#x3C;h3\u003eThis is a H3 header\u0026#x3C;/h3\u003e\n                \u0026#x3C;p\u003eThis is a paragraph\u0026#x3C;/p\u003e\n                \u0026#x3C;ul\u003e\n                    \u0026#x3C;li\u003eList item one\u0026#x3C;/li\u003e\n                    \u0026#x3C;li\u003eList item two\u0026#x3C;/li\u003e\n                \u0026#x3C;/ul\u003e\n                \u0026#x3C;p\u003eThis is a paragraph with a \u0026#x3C;a href=\"https://developer.apple.com/\"\u003elink\u0026#x3C;/a\u003e\u0026#x3C;/p\u003e\n                \u0026#x3C;p style=\"color: blue; text-align: center;\"\u003e\n                    This is a paragraph with inline styling\n                \u0026#x3C;/p\u003e\n                \"\"\"\u003c/span\u003e, theme: theme))\n                .padding()\n            }\n            .navigationTitle(\u003cspan class=\"hljs-string\"\u003e\"Render Themed HTML in SwiftUI\"\u003c/span\u003e)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e이게 다야!\u003c/h2\u003e\n\u003cp\u003e쉽죠! SwiftUI가 정말 멋지지만, 때로는 몇 년 동안 사랑해 온 UIKit 뷰와 기능을 임베드할 수 있는 것이 참 좋습니다.\u003c/p\u003e\n\u003cp\u003e코딩하세요! 🙌\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-RenderHTMLinSwiftUI"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>