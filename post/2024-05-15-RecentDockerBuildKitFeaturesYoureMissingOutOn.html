<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>최근 놓치고 있는 도커 빌드킷의 기능들 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="최근 놓치고 있는 도커 빌드킷의 기능들 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="최근 놓치고 있는 도커 빌드킷의 기능들 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn" data-gatsby-head="true"/><meta name="twitter:title" content="최근 놓치고 있는 도커 빌드킷의 기능들 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-15 03:35" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">최근 놓치고 있는 도커 빌드킷의 기능들</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="최근 놓치고 있는 도커 빌드킷의 기능들" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 15, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_0.png" alt="이미지"></p>
<p>BuildKit 도입으로 Docker의 향상된 빌더 백엔드가 도입되었고, 많은 새로운 기능이 Docker에 추가되었습니다. 그 중 많이 알려지지 않은 기능들을 알아야 할 것이며, Docker를 더 잘 활용하기 위해 사용해야 할 것들에 대한 소개입니다.</p>
<h1>디버깅</h1>
<p>가장 일반적인 작업인 디버깅부터 시작해보겠습니다. Docker 빌드의 디버깅은 항상 고통스러운 작업이었습니다. RUN 또는 COPY 명령이 실패하면 일반적으로 문제가 발생한 상황을 확인하고 디버깅하기가 까다로웠습니다. 일반적으로 RUN ls -la와 같은 명령을 추가하여 더 많은 정보를 얻기 위해 시도했습니다. 그러나 이제는 docker buildx debug를 통해 이 상황이 바뀌었습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-variable constant_">BUILDX_EXPERIMENTAL</span>=<span class="hljs-number">1</span>
docker buildx debug --invoke /bin/sh --on=error build .

[+] <span class="hljs-title class_">Building</span> <span class="hljs-number">1.</span>2s (<span class="hljs-number">14</span>/<span class="hljs-number">18</span>)                <span class="hljs-attr">docker</span>:<span class="hljs-keyword">default</span>
...
------
 > [builder <span class="hljs-number">5</span>/<span class="hljs-number">6</span>] <span class="hljs-variable constant_">RUN</span> exit <span class="hljs-number">1</span>:
------
<span class="hljs-title class_">Dockerfile</span>:<span class="hljs-number">10</span>
--------------------
   <span class="hljs-number">8</span> |     <span class="hljs-variable constant_">RUN</span> pip3 install -r requirements.<span class="hljs-property">txt</span>
   <span class="hljs-number">9</span> |     
  <span class="hljs-number">10</span> | >>> <span class="hljs-variable constant_">RUN</span> exit <span class="hljs-number">1</span>
  <span class="hljs-number">11</span> |     
  <span class="hljs-number">12</span> |     <span class="hljs-variable constant_">COPY</span> . /app
--------------------
<span class="hljs-attr">ERROR</span>: process <span class="hljs-string">"/bin/sh -c exit 1"</span> did not complete <span class="hljs-attr">successfully</span>: exit <span class="hljs-attr">code</span>: <span class="hljs-number">1</span>
[+] <span class="hljs-title class_">Building</span> <span class="hljs-number">0.</span>0s (<span class="hljs-number">0</span>/<span class="hljs-number">0</span>)                  <span class="hljs-attr">docker</span>:<span class="hljs-keyword">default</span>
<span class="hljs-title class_">Launching</span> interactive container. <span class="hljs-title class_">Press</span> <span class="hljs-title class_">Ctrl</span>-a-c to <span class="hljs-keyword">switch</span> to monitor <span class="hljs-variable language_">console</span>
<span class="hljs-title class_">Interactive</span> container was restarted <span class="hljs-keyword">with</span> process <span class="hljs-string">"u6agxp1ywqapemxrt8iexfv4h"</span>. <span class="hljs-title class_">Press</span> <span class="hljs-title class_">Ctrl</span>-a-c to <span class="hljs-keyword">switch</span> to the <span class="hljs-keyword">new</span> container
/ # ls -la
total <span class="hljs-number">72</span>
drwxr-xr-x    <span class="hljs-number">1</span> root     root          <span class="hljs-number">4096</span> <span class="hljs-title class_">May</span>  <span class="hljs-number">5</span> <span class="hljs-number">12</span>:<span class="hljs-number">59</span> .
drwxr-xr-x    <span class="hljs-number">1</span> root     root          <span class="hljs-number">4096</span> <span class="hljs-title class_">May</span>  <span class="hljs-number">5</span> <span class="hljs-number">12</span>:<span class="hljs-number">59</span> ..
drwxr-xr-x    <span class="hljs-number">1</span> root     root          <span class="hljs-number">4096</span> <span class="hljs-title class_">May</span>  <span class="hljs-number">4</span> <span class="hljs-number">10</span>:<span class="hljs-number">11</span> app
...
</code></pre>
<p>위 스니펫에서 먼저 실험적인 BuildKit 기능을 BUILDX_EXPERIMENTAL 환경 변수로 활성화합니다. 그런 다음 docker buildx debug를 통해 빌드를 시작합니다. 빌드가 어느 시점에서든 실패하면 컨테이너로 이동하여 실행 문맥을 탐색하고 디버깅할 수 있습니다.</p>
<p>빌드가 실패했을 때만 디버그 세션을 시작하는 --on=error 옵션을 포함했음에 유의하세요.</p>
<p>자세한 내용은 디버깅 문서를 참조하십시오.</p>
<h1>환경 변수</h1>
<p>만약 이전에 BuildKit으로 빌드를 실행했다면 새롭고 멋진 로그 출력을 눈치챘을 것입니다. 멋져 보이긴 하지만 디버깅할 때는 그리 실용적이지 않죠. 그럴 때는 평범한 로그 출력으로 전환할 수 있는 환경 변수가 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-variable constant_">BUILDKIT_PROGRESS</span>=plain
</code></pre>
<p>원하는 경우 rawjson으로 설정할 수도 있지만, 이는 사람이 직관적으로 읽기 어려울 수 있지만 어떤 방식으로든 로그를 처리하고 싶을 때 유용할 수 있습니다.</p>
<p>만약 TTY 기반의 동적 출력을 좋아하지만 색상을 싫어한다면, 간단히 다음과 같이 변경할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">BUILDKIT_COLORS</span>=<span class="hljs-string">"run=green:warning=yellow:error=red:cancel=cyan"</span> docker buildx debug --invoke /bin/sh --on=error build .
</code></pre>
<p>위와 같이 출력이 변합니다:</p>
<img src="/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_1.png">
<p>기타 환경 변수에 대한 문서를 참조해보세요.</p>
<h1>Exporters</h1>
<p>BuildKit은 빌드 결과물이 어떻게 저장될지를 정의하는 수출자(Exporters) 개념을 소개합니다. 가장 유용한 두 가지 옵션은 이미지(image)와 레지스트리(registry)입니다. image는 기대했을 것처럼 빌드 결과물을 컨테이너 이미지로 저장하며, 레지스트리 수출자는 자동으로 지정된 레지스트리로 푸시합니다:</p>
<pre><code class="hljs language-js">docker buildx build --output type=registry,name=martinheinz/<span class="hljs-attr">testimage</span>:latest .
</code></pre>
<p>우리가 해야 할 일은 --output 옵션을 지정하고 registry의 유형과 대상을 설정하는 것뿐입니다. 이 옵션은 한 번에 여러 레지스트리를 지정하는 것도 지원합니다:</p>
<pre><code class="hljs language-js">docker buildx build --output type=registry,\<span class="hljs-string">"name=docker.io/martinheinz/testimage,docker.io/martinheinz/testimage2\" .
</span></code></pre>
<p>마지막으로, --cache-to 및 --cache-from 옵션을 제공하여 레지스트리에서 기존 이미지를 캐시 소스로 사용할 수도 있습니다:</p>
<pre><code class="hljs language-js">docker buildx build --output type=registry,name=martinheinz/<span class="hljs-attr">testimage</span>:latest \
 --cache-to type=inline \
 --cache-<span class="hljs-keyword">from</span> type=registry,ref=docker.<span class="hljs-property">io</span>/martinheinz/testimage .

...
 => <span class="hljs-variable constant_">CACHED</span> docker-<span class="hljs-attr">image</span>:<span class="hljs-comment">//docker.io/docker/dockerfile:1.4@sha256:9ba7531bd80fb0a858632727cf7a112fbfd19b17e94c4e84ced81e24ef1a0dbc</span>
...
 => <span class="hljs-variable constant_">CACHED</span> [builder <span class="hljs-number">2</span>/<span class="hljs-number">5</span>] <span class="hljs-variable constant_">WORKDIR</span> /app                                                                                                  <span class="hljs-number">0.0</span>초
 => <span class="hljs-variable constant_">CACHED</span> [builder <span class="hljs-number">3</span>/<span class="hljs-number">5</span>] <span class="hljs-variable constant_">COPY</span> requirements.<span class="hljs-property">txt</span> /app                                                                                    <span class="hljs-number">0.0</span>초
 => <span class="hljs-variable constant_">CACHED</span> [builder <span class="hljs-number">4</span>/<span class="hljs-number">5</span>] <span class="hljs-variable constant_">RUN</span> --mount=type=cache,target=<span class="hljs-regexp">/root/</span>.<span class="hljs-property">cache</span>/pip     pip3 install -r requirements.<span class="hljs-property">txt</span>                           <span class="hljs-number">0.0</span>초
 => <span class="hljs-variable constant_">CACHED</span> [builder <span class="hljs-number">5</span>/<span class="hljs-number">5</span>] <span class="hljs-variable constant_">COPY</span> . /app                                                                                                   <span class="hljs-number">0.0</span>초
 => <span class="hljs-variable constant_">CACHED</span> [dev-envs <span class="hljs-number">1</span>/<span class="hljs-number">3</span>] <span class="hljs-variable constant_">RUN</span> &#x3C;&#x3C;<span class="hljs-variable constant_">EOF</span> (apk update...)                                                                                    <span class="hljs-number">0.0</span>초
 => <span class="hljs-variable constant_">CACHED</span> [dev-envs <span class="hljs-number">2</span>/<span class="hljs-number">3</span>] <span class="hljs-variable constant_">RUN</span> &#x3C;&#x3C;<span class="hljs-variable constant_">EOF</span> (addgroup -S docker...)                                                                            <span class="hljs-number">0.0</span>초
 => <span class="hljs-variable constant_">CACHED</span> [dev-envs <span class="hljs-number">3</span>/<span class="hljs-number">3</span>] <span class="hljs-variable constant_">COPY</span> --<span class="hljs-keyword">from</span>=gloursdocker/docker / /                                                                          <span class="hljs-number">0.0</span>초
 => preparing layers <span class="hljs-keyword">for</span> inline cache                                                                                                  <span class="hljs-number">0.0</span>초
...
</code></pre>
<h1>이미지 도구</h1>
<p>도커 빌드x의 간편하지만 유용한 서브커맨드인 imagetools는 이미지를 가져오지 않고도 레지스트리의 이미지를 검사할 수 있게 해줍니다. 자세한 내용은 많은 예시를 포함하고 있지만, 저에게 가장 유용한 것은 원격 이미지의 다이제스트를 가져오는 것입니다:</p>
<pre><code class="hljs language-js">docker buildx imagetools inspect alpine --format <span class="hljs-string">"{json .Manifest}"</span> | jq .<span class="hljs-property">digest</span>
<span class="hljs-string">"sha256:c5b1261d6d3e43071626931fc004f70149baeba2c8ec672bd4f27761f8e1ad6a"</span>
</code></pre>
<h1>최신 Dockerfile 구문</h1>
<p>빌드킷과 함께 새로운 Dockerfile 구문이 도입되었습니다. 이를 통해 Dockerfile 프론트엔드라는 것이 사용됩니다. 현재 최신 구문을 활성화하려면 Dockerfile 맨 위에 다음과 같은 지시문을 추가해야 합니다:</p>
<pre><code class="hljs language-js"># syntax=docker/<span class="hljs-attr">dockerfile</span>:<span class="hljs-number">1.3</span>
<span class="hljs-variable constant_">FROM</span> ...
</code></pre>
<p>버전을 확인하려면 dockerfile-upstream 도커 허브 저장소를 확인하세요.</p>
<p>지금부터 소개할 첫 번째 도커 파일 문법 개선 사항은 here-docs입니다. 여기서는 멀티 라인 스크립트를 RUN 및 COPY 명령어에 전달할 수 있게 해줍니다:</p>
<pre><code class="hljs language-js"># syntax = docker/<span class="hljs-attr">dockerfile</span>:<span class="hljs-number">1.3</span>-labs
<span class="hljs-variable constant_">FROM</span> debian
<span class="hljs-variable constant_">RUN</span> &#x3C;&#x3C;eot bash
  apt-get update
  apt-get install -y vim
eot

# 같은 내용:
<span class="hljs-variable constant_">RUN</span> apt-get update &#x26;&#x26; apt-get install -y vim
</code></pre>
<p>과거에는 단일 RUN에 여러 명령어를 넣고 싶다면 &#x26;&#x26;을 사용해야 했지만, 이제는 here-docs를 사용하여 일반 스크립트를 작성할 수 있습니다.</p>
<p>게다가, 첫 번째 줄에서 해석기를 지정할 수 있어 Python 스크립트를 작성할 수도 있습니다:</p>
<pre><code class="hljs language-bash"><span class="hljs-comment"># syntax = docker/dockerfile:1.3-labs</span>
FROM python:3.6
RUN &#x3C;&#x3C;<span class="hljs-string">eot
#!/usr/bin/env python
print("hello world")
eot</span>
</code></pre>
<h1>COPY and ADD Features</h1>
<p>새로운 Dockerfile 구문에서는 COPY 및 ADD에 대한 변경 사항과 개선 사항도 더 많이 있습니다.</p>
<p>COPY는 이제 --parents 옵션을 지원합니다:</p>
<pre><code class="hljs language-js"># syntax=docker/<span class="hljs-attr">dockerfile</span>:<span class="hljs-number">1.7</span><span class="hljs-number">.0</span>-labs
<span class="hljs-variable constant_">FROM</span> ubuntu

<span class="hljs-variable constant_">COPY</span> ./one/two/some.<span class="hljs-property">txt</span> /normal/

<span class="hljs-variable constant_">RUN</span> find /normal
#<span class="hljs-number">10</span> [<span class="hljs-number">3</span>/<span class="hljs-number">5</span>] <span class="hljs-variable constant_">RUN</span> find /normal
#<span class="hljs-number">10</span> <span class="hljs-number">0.223</span> /normal
#<span class="hljs-number">10</span> <span class="hljs-number">0.223</span> /normal/some.<span class="hljs-property">txt</span>

<span class="hljs-variable constant_">COPY</span> --parents ./one/two/some.<span class="hljs-property">txt</span> /parents/

<span class="hljs-variable constant_">RUN</span> find /parents
#<span class="hljs-number">12</span> [<span class="hljs-number">5</span>/<span class="hljs-number">5</span>] <span class="hljs-variable constant_">RUN</span> find /parents
#<span class="hljs-number">12</span> <span class="hljs-number">0.509</span> /parents
#<span class="hljs-number">12</span> <span class="hljs-number">0.509</span> /parents/one
#<span class="hljs-number">12</span> <span class="hljs-number">0.509</span> /parents/one/two
#<span class="hljs-number">12</span> <span class="hljs-number">0.509</span> /parents/one/two/some.<span class="hljs-property">txt</span>
</code></pre>
<p>만약 일반 COPY로 중첩된 파일을 복사하면 이미지에는 부모 디렉토리 없이 파일 자체만 포함되며, --parents로 전체 파일 트리가 복사됩니다. 이는 cp --parents의 작동 방식과 유사합니다.</p>
<p>--exclude 옵션을 사용할 수 있는 것과 같이, --parents 옵션도 사용할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">COPY</span> --exclude=*.<span class="hljs-property">txt</span> ./some-dir<span class="hljs-comment">/* ./some-dest
</span></code></pre>
<p>파일을 복사할 때 제외된 파일 및 패턴을 무시하는 옵션입니다.</p>
<p>마침내 ADD 명령어도 향상되었습니다 - 이제 Git 저장소를 직접 추가할 수 있습니다:</p>
<pre><code class="hljs language-js"># syntax=docker/<span class="hljs-attr">dockerfile</span>:<span class="hljs-number">1.7</span><span class="hljs-number">.0</span>-labs
<span class="hljs-variable constant_">FROM</span> ubuntu

<span class="hljs-variable constant_">ADD</span> git@github.<span class="hljs-property">com</span>:kelseyhightower/helloworld.<span class="hljs-property">git</span> /repo
<span class="hljs-variable constant_">RUN</span> ls -la /repo
</code></pre>
<p>이 Dockerfile을 빌드하면 다음과 같은 결과를 얻을 수 있습니다:</p>
<p>docker buildx build --ssh default --progress=plain .</p>
<ul>
<li>[2/3] ADD <a href="mailto:git@github.com">git@github.com</a>:kelseyhightower/helloworld.git /repo
<ul>
<li>Warning: Permanently added 'github.com' (ED25519) to the list of known hosts.</li>
<li>ref: refs/heads/master HEAD
<ul>
<li>96a652519d1aaca11085ca3a7806bead4d2c273f   HEAD</li>
<li>96a652519d1aaca11085ca3a7806bead4d2c273f   refs/heads/master</li>
</ul>
</li>
<li>ref: refs/heads/master HEAD
<ul>
<li>96a652519d1aaca11085ca3a7806bead4d2c273f   HEAD</li>
<li>From github.com:kelseyhightower/helloworld
<ul>
<li>[new branch]      master     -> master</li>
<li>[new branch]      master     -> origin/master</li>
</ul>
</li>
</ul>
</li>
<li>DONE 7.4s</li>
</ul>
</li>
<li>[2/3] ADD <a href="mailto:git@github.com">git@github.com</a>:kelseyhightower/helloworld.git /repo
<ul>
<li>DONE 0.0s</li>
</ul>
</li>
</ul>
<p>이것은 비공개 저장소에도 작동합니다.</p>
<p>더 많은 흥미로운 옵션을 문서에서 볼 수 있습니다. 예를 들어, --keep-git-dir이나 --checksum을 통해 아티팩트 체크섬을 유효성 검사할 수 있습니다.</p>
<h1>보너스: 들여쓰기</h1>
<p>그리고 BuildKit 기능은 아니지만, 최근에 발견한 하나의 사실은 Dockerfile에서 줄을 들여쓰면 잘 작동한다는 것입니다. 이렇게 하면 다단계 빌드를 진행할 때 가독성이 향상되는 효과를 얻을 수 있습니다:</p>
<pre><code class="hljs language-js"># syntax=docker/<span class="hljs-attr">dockerfile</span>:<span class="hljs-number">1</span>
<span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">golang</span>:<span class="hljs-number">1.21</span>
  <span class="hljs-variable constant_">WORKDIR</span> /src
  
  <span class="hljs-variable constant_">COPY</span> main.<span class="hljs-property">go</span> .
  <span class="hljs-variable constant_">RUN</span> go build -o /bin/hello ./main.<span class="hljs-property">go</span>

<span class="hljs-variable constant_">FROM</span> scratch
  <span class="hljs-variable constant_">COPY</span> --<span class="hljs-keyword">from</span>=<span class="hljs-number">0</span> /bin/hello /bin/hello
  <span class="hljs-variable constant_">CMD</span> [<span class="hljs-string">"/bin/hello"</span>]
</code></pre>
<p>처음에는 이상하게 보일 수 있지만, 내견에 따르면 더 읽기 쉬워져서 각 단계가 어디에서 시작되고 어떤 명령이 속해 있는지 명확해집니다.</p>
<h1>결론</h1>
<p>이 기사의 예시는 내가 가장 유용하다고 생각하는 기능들만을 보여줍니다. 그러나 Docker 공식 문서와 BuildKit 문서, 또한 최신 변경 사항을 확인해보십시오. Docker 블로그도 좋은 자료가 있으며 특히 표시된 글들을 확인해보세요.</p>
<p>이 기사는 원래 martinheinz.dev에서 게시되었습니다.</p>
<p>또한 다음 글들을 즐기실 수도 있습니다...</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"최근 놓치고 있는 도커 빌드킷의 기능들","description":"","date":"2024-05-15 03:35","slug":"2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn","content":"\n\n![이미지](/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_0.png)\n\nBuildKit 도입으로 Docker의 향상된 빌더 백엔드가 도입되었고, 많은 새로운 기능이 Docker에 추가되었습니다. 그 중 많이 알려지지 않은 기능들을 알아야 할 것이며, Docker를 더 잘 활용하기 위해 사용해야 할 것들에 대한 소개입니다.\n\n# 디버깅\n\n가장 일반적인 작업인 디버깅부터 시작해보겠습니다. Docker 빌드의 디버깅은 항상 고통스러운 작업이었습니다. RUN 또는 COPY 명령이 실패하면 일반적으로 문제가 발생한 상황을 확인하고 디버깅하기가 까다로웠습니다. 일반적으로 RUN ls -la와 같은 명령을 추가하여 더 많은 정보를 얻기 위해 시도했습니다. 그러나 이제는 docker buildx debug를 통해 이 상황이 바뀌었습니다.\n\n\n\n```js\nexport BUILDX_EXPERIMENTAL=1\ndocker buildx debug --invoke /bin/sh --on=error build .\n\n[+] Building 1.2s (14/18)                docker:default\n...\n------\n \u003e [builder 5/6] RUN exit 1:\n------\nDockerfile:10\n--------------------\n   8 |     RUN pip3 install -r requirements.txt\n   9 |     \n  10 | \u003e\u003e\u003e RUN exit 1\n  11 |     \n  12 |     COPY . /app\n--------------------\nERROR: process \"/bin/sh -c exit 1\" did not complete successfully: exit code: 1\n[+] Building 0.0s (0/0)                  docker:default\nLaunching interactive container. Press Ctrl-a-c to switch to monitor console\nInteractive container was restarted with process \"u6agxp1ywqapemxrt8iexfv4h\". Press Ctrl-a-c to switch to the new container\n/ # ls -la\ntotal 72\ndrwxr-xr-x    1 root     root          4096 May  5 12:59 .\ndrwxr-xr-x    1 root     root          4096 May  5 12:59 ..\ndrwxr-xr-x    1 root     root          4096 May  4 10:11 app\n...\n```\n\n위 스니펫에서 먼저 실험적인 BuildKit 기능을 BUILDX_EXPERIMENTAL 환경 변수로 활성화합니다. 그런 다음 docker buildx debug를 통해 빌드를 시작합니다. 빌드가 어느 시점에서든 실패하면 컨테이너로 이동하여 실행 문맥을 탐색하고 디버깅할 수 있습니다.\n\n빌드가 실패했을 때만 디버그 세션을 시작하는 --on=error 옵션을 포함했음에 유의하세요.\n\n자세한 내용은 디버깅 문서를 참조하십시오.\n\n\n\n# 환경 변수\n\n만약 이전에 BuildKit으로 빌드를 실행했다면 새롭고 멋진 로그 출력을 눈치챘을 것입니다. 멋져 보이긴 하지만 디버깅할 때는 그리 실용적이지 않죠. 그럴 때는 평범한 로그 출력으로 전환할 수 있는 환경 변수가 있습니다:\n\n```js\nexport BUILDKIT_PROGRESS=plain\n```\n\n원하는 경우 rawjson으로 설정할 수도 있지만, 이는 사람이 직관적으로 읽기 어려울 수 있지만 어떤 방식으로든 로그를 처리하고 싶을 때 유용할 수 있습니다.\n\n\n\n만약 TTY 기반의 동적 출력을 좋아하지만 색상을 싫어한다면, 간단히 다음과 같이 변경할 수 있습니다:\n\n```js\nBUILDKIT_COLORS=\"run=green:warning=yellow:error=red:cancel=cyan\" docker buildx debug --invoke /bin/sh --on=error build .\n```\n\n위와 같이 출력이 변합니다:\n\n\u003cimg src=\"/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_1.png\" /\u003e\n\n\n\n기타 환경 변수에 대한 문서를 참조해보세요.\n\n# Exporters\n\nBuildKit은 빌드 결과물이 어떻게 저장될지를 정의하는 수출자(Exporters) 개념을 소개합니다. 가장 유용한 두 가지 옵션은 이미지(image)와 레지스트리(registry)입니다. image는 기대했을 것처럼 빌드 결과물을 컨테이너 이미지로 저장하며, 레지스트리 수출자는 자동으로 지정된 레지스트리로 푸시합니다:\n\n```js\ndocker buildx build --output type=registry,name=martinheinz/testimage:latest .\n```\n\n\n\n우리가 해야 할 일은 --output 옵션을 지정하고 registry의 유형과 대상을 설정하는 것뿐입니다. 이 옵션은 한 번에 여러 레지스트리를 지정하는 것도 지원합니다:\n\n```js\ndocker buildx build --output type=registry,\\\"name=docker.io/martinheinz/testimage,docker.io/martinheinz/testimage2\\\" .\n```\n\n마지막으로, --cache-to 및 --cache-from 옵션을 제공하여 레지스트리에서 기존 이미지를 캐시 소스로 사용할 수도 있습니다:\n\n```js\ndocker buildx build --output type=registry,name=martinheinz/testimage:latest \\\n --cache-to type=inline \\\n --cache-from type=registry,ref=docker.io/martinheinz/testimage .\n\n...\n =\u003e CACHED docker-image://docker.io/docker/dockerfile:1.4@sha256:9ba7531bd80fb0a858632727cf7a112fbfd19b17e94c4e84ced81e24ef1a0dbc\n...\n =\u003e CACHED [builder 2/5] WORKDIR /app                                                                                                  0.0초\n =\u003e CACHED [builder 3/5] COPY requirements.txt /app                                                                                    0.0초\n =\u003e CACHED [builder 4/5] RUN --mount=type=cache,target=/root/.cache/pip     pip3 install -r requirements.txt                           0.0초\n =\u003e CACHED [builder 5/5] COPY . /app                                                                                                   0.0초\n =\u003e CACHED [dev-envs 1/3] RUN \u003c\u003cEOF (apk update...)                                                                                    0.0초\n =\u003e CACHED [dev-envs 2/3] RUN \u003c\u003cEOF (addgroup -S docker...)                                                                            0.0초\n =\u003e CACHED [dev-envs 3/3] COPY --from=gloursdocker/docker / /                                                                          0.0초\n =\u003e preparing layers for inline cache                                                                                                  0.0초\n...\n```\n\n\n\n# 이미지 도구\n\n도커 빌드x의 간편하지만 유용한 서브커맨드인 imagetools는 이미지를 가져오지 않고도 레지스트리의 이미지를 검사할 수 있게 해줍니다. 자세한 내용은 많은 예시를 포함하고 있지만, 저에게 가장 유용한 것은 원격 이미지의 다이제스트를 가져오는 것입니다:\n\n```js\ndocker buildx imagetools inspect alpine --format \"{json .Manifest}\" | jq .digest\n\"sha256:c5b1261d6d3e43071626931fc004f70149baeba2c8ec672bd4f27761f8e1ad6a\"\n```\n\n# 최신 Dockerfile 구문\n\n\n\n빌드킷과 함께 새로운 Dockerfile 구문이 도입되었습니다. 이를 통해 Dockerfile 프론트엔드라는 것이 사용됩니다. 현재 최신 구문을 활성화하려면 Dockerfile 맨 위에 다음과 같은 지시문을 추가해야 합니다:\n\n```js\n# syntax=docker/dockerfile:1.3\nFROM ...\n```\n\n버전을 확인하려면 dockerfile-upstream 도커 허브 저장소를 확인하세요.\n\n\n\n지금부터 소개할 첫 번째 도커 파일 문법 개선 사항은 here-docs입니다. 여기서는 멀티 라인 스크립트를 RUN 및 COPY 명령어에 전달할 수 있게 해줍니다:\n\n```js\n# syntax = docker/dockerfile:1.3-labs\nFROM debian\nRUN \u003c\u003ceot bash\n  apt-get update\n  apt-get install -y vim\neot\n\n# 같은 내용:\nRUN apt-get update \u0026\u0026 apt-get install -y vim\n```\n\n과거에는 단일 RUN에 여러 명령어를 넣고 싶다면 \u0026\u0026을 사용해야 했지만, 이제는 here-docs를 사용하여 일반 스크립트를 작성할 수 있습니다.\n\n게다가, 첫 번째 줄에서 해석기를 지정할 수 있어 Python 스크립트를 작성할 수도 있습니다:\n\n\n\n```bash\n# syntax = docker/dockerfile:1.3-labs\nFROM python:3.6\nRUN \u003c\u003ceot\n#!/usr/bin/env python\nprint(\"hello world\")\neot\n```\n\n# COPY and ADD Features\n\n새로운 Dockerfile 구문에서는 COPY 및 ADD에 대한 변경 사항과 개선 사항도 더 많이 있습니다.\n\nCOPY는 이제 --parents 옵션을 지원합니다:\n\n\n\n\n```js\n# syntax=docker/dockerfile:1.7.0-labs\nFROM ubuntu\n\nCOPY ./one/two/some.txt /normal/\n\nRUN find /normal\n#10 [3/5] RUN find /normal\n#10 0.223 /normal\n#10 0.223 /normal/some.txt\n\nCOPY --parents ./one/two/some.txt /parents/\n\nRUN find /parents\n#12 [5/5] RUN find /parents\n#12 0.509 /parents\n#12 0.509 /parents/one\n#12 0.509 /parents/one/two\n#12 0.509 /parents/one/two/some.txt\n```\n\n만약 일반 COPY로 중첩된 파일을 복사하면 이미지에는 부모 디렉토리 없이 파일 자체만 포함되며, --parents로 전체 파일 트리가 복사됩니다. 이는 cp --parents의 작동 방식과 유사합니다.\n\n--exclude 옵션을 사용할 수 있는 것과 같이, --parents 옵션도 사용할 수 있습니다:\n\n```js\nCOPY --exclude=*.txt ./some-dir/* ./some-dest\n```\n\n\n\n파일을 복사할 때 제외된 파일 및 패턴을 무시하는 옵션입니다.\n\n마침내 ADD 명령어도 향상되었습니다 - 이제 Git 저장소를 직접 추가할 수 있습니다:\n\n```js\n# syntax=docker/dockerfile:1.7.0-labs\nFROM ubuntu\n\nADD git@github.com:kelseyhightower/helloworld.git /repo\nRUN ls -la /repo\n```\n\n이 Dockerfile을 빌드하면 다음과 같은 결과를 얻을 수 있습니다:\n\n\n\n\ndocker buildx build --ssh default --progress=plain .\n- [2/3] ADD git@github.com:kelseyhightower/helloworld.git /repo\n  - Warning: Permanently added 'github.com' (ED25519) to the list of known hosts.\n  - ref: refs/heads/master HEAD\n    - 96a652519d1aaca11085ca3a7806bead4d2c273f   HEAD\n    - 96a652519d1aaca11085ca3a7806bead4d2c273f   refs/heads/master\n  - ref: refs/heads/master HEAD\n    - 96a652519d1aaca11085ca3a7806bead4d2c273f   HEAD\n    - From github.com:kelseyhightower/helloworld\n      - [new branch]      master     -\u003e master\n      - [new branch]      master     -\u003e origin/master\n  - DONE 7.4s\n- [2/3] ADD git@github.com:kelseyhightower/helloworld.git /repo\n  - DONE 0.0s\n\n\n이것은 비공개 저장소에도 작동합니다.\n\n더 많은 흥미로운 옵션을 문서에서 볼 수 있습니다. 예를 들어, --keep-git-dir이나 --checksum을 통해 아티팩트 체크섬을 유효성 검사할 수 있습니다.\n\n# 보너스: 들여쓰기\n\n\n\n그리고 BuildKit 기능은 아니지만, 최근에 발견한 하나의 사실은 Dockerfile에서 줄을 들여쓰면 잘 작동한다는 것입니다. 이렇게 하면 다단계 빌드를 진행할 때 가독성이 향상되는 효과를 얻을 수 있습니다:\n\n```js\n# syntax=docker/dockerfile:1\nFROM golang:1.21\n  WORKDIR /src\n  \n  COPY main.go .\n  RUN go build -o /bin/hello ./main.go\n\nFROM scratch\n  COPY --from=0 /bin/hello /bin/hello\n  CMD [\"/bin/hello\"]\n```\n\n처음에는 이상하게 보일 수 있지만, 내견에 따르면 더 읽기 쉬워져서 각 단계가 어디에서 시작되고 어떤 명령이 속해 있는지 명확해집니다.\n\n# 결론\n\n\n\n이 기사의 예시는 내가 가장 유용하다고 생각하는 기능들만을 보여줍니다. 그러나 Docker 공식 문서와 BuildKit 문서, 또한 최신 변경 사항을 확인해보십시오. Docker 블로그도 좋은 자료가 있으며 특히 표시된 글들을 확인해보세요.\n\n이 기사는 원래 martinheinz.dev에서 게시되었습니다.\n\n또한 다음 글들을 즐기실 수도 있습니다...","ogImage":{"url":"/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_0.png"},"coverImage":"/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eBuildKit 도입으로 Docker의 향상된 빌더 백엔드가 도입되었고, 많은 새로운 기능이 Docker에 추가되었습니다. 그 중 많이 알려지지 않은 기능들을 알아야 할 것이며, Docker를 더 잘 활용하기 위해 사용해야 할 것들에 대한 소개입니다.\u003c/p\u003e\n\u003ch1\u003e디버깅\u003c/h1\u003e\n\u003cp\u003e가장 일반적인 작업인 디버깅부터 시작해보겠습니다. Docker 빌드의 디버깅은 항상 고통스러운 작업이었습니다. RUN 또는 COPY 명령이 실패하면 일반적으로 문제가 발생한 상황을 확인하고 디버깅하기가 까다로웠습니다. 일반적으로 RUN ls -la와 같은 명령을 추가하여 더 많은 정보를 얻기 위해 시도했습니다. 그러나 이제는 docker buildx debug를 통해 이 상황이 바뀌었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBUILDX_EXPERIMENTAL\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\ndocker buildx debug --invoke /bin/sh --on=error build .\n\n[+] \u003cspan class=\"hljs-title class_\"\u003eBuilding\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1.\u003c/span\u003e2s (\u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e)                \u003cspan class=\"hljs-attr\"\u003edocker\u003c/span\u003e:\u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e\n...\n------\n \u003e [builder \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e] \u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e exit \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:\n------\n\u003cspan class=\"hljs-title class_\"\u003eDockerfile\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\n--------------------\n   \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e |     \u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e pip3 install -r requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n   \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e |     \n  \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e | \u003e\u003e\u003e \u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e exit \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n  \u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e |     \n  \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e |     \u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e . /app\n--------------------\n\u003cspan class=\"hljs-attr\"\u003eERROR\u003c/span\u003e: process \u003cspan class=\"hljs-string\"\u003e\"/bin/sh -c exit 1\"\u003c/span\u003e did not complete \u003cspan class=\"hljs-attr\"\u003esuccessfully\u003c/span\u003e: exit \u003cspan class=\"hljs-attr\"\u003ecode\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n[+] \u003cspan class=\"hljs-title class_\"\u003eBuilding\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e0s (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)                  \u003cspan class=\"hljs-attr\"\u003edocker\u003c/span\u003e:\u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eLaunching\u003c/span\u003e interactive container. \u003cspan class=\"hljs-title class_\"\u003ePress\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCtrl\u003c/span\u003e-a-c to \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e to monitor \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eInteractive\u003c/span\u003e container was restarted \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e process \u003cspan class=\"hljs-string\"\u003e\"u6agxp1ywqapemxrt8iexfv4h\"\u003c/span\u003e. \u003cspan class=\"hljs-title class_\"\u003ePress\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCtrl\u003c/span\u003e-a-c to \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e to the \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e container\n/ # ls -la\ntotal \u003cspan class=\"hljs-number\"\u003e72\u003c/span\u003e\ndrwxr-xr-x    \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e root     root          \u003cspan class=\"hljs-number\"\u003e4096\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMay\u003c/span\u003e  \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e59\u003c/span\u003e .\ndrwxr-xr-x    \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e root     root          \u003cspan class=\"hljs-number\"\u003e4096\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMay\u003c/span\u003e  \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e59\u003c/span\u003e ..\ndrwxr-xr-x    \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e root     root          \u003cspan class=\"hljs-number\"\u003e4096\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMay\u003c/span\u003e  \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e app\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 스니펫에서 먼저 실험적인 BuildKit 기능을 BUILDX_EXPERIMENTAL 환경 변수로 활성화합니다. 그런 다음 docker buildx debug를 통해 빌드를 시작합니다. 빌드가 어느 시점에서든 실패하면 컨테이너로 이동하여 실행 문맥을 탐색하고 디버깅할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e빌드가 실패했을 때만 디버그 세션을 시작하는 --on=error 옵션을 포함했음에 유의하세요.\u003c/p\u003e\n\u003cp\u003e자세한 내용은 디버깅 문서를 참조하십시오.\u003c/p\u003e\n\u003ch1\u003e환경 변수\u003c/h1\u003e\n\u003cp\u003e만약 이전에 BuildKit으로 빌드를 실행했다면 새롭고 멋진 로그 출력을 눈치챘을 것입니다. 멋져 보이긴 하지만 디버깅할 때는 그리 실용적이지 않죠. 그럴 때는 평범한 로그 출력으로 전환할 수 있는 환경 변수가 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBUILDKIT_PROGRESS\u003c/span\u003e=plain\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e원하는 경우 rawjson으로 설정할 수도 있지만, 이는 사람이 직관적으로 읽기 어려울 수 있지만 어떤 방식으로든 로그를 처리하고 싶을 때 유용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e만약 TTY 기반의 동적 출력을 좋아하지만 색상을 싫어한다면, 간단히 다음과 같이 변경할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eBUILDKIT_COLORS\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"run=green:warning=yellow:error=red:cancel=cyan\"\u003c/span\u003e docker buildx debug --invoke /bin/sh --on=error build .\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같이 출력이 변합니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn_1.png\"\u003e\n\u003cp\u003e기타 환경 변수에 대한 문서를 참조해보세요.\u003c/p\u003e\n\u003ch1\u003eExporters\u003c/h1\u003e\n\u003cp\u003eBuildKit은 빌드 결과물이 어떻게 저장될지를 정의하는 수출자(Exporters) 개념을 소개합니다. 가장 유용한 두 가지 옵션은 이미지(image)와 레지스트리(registry)입니다. image는 기대했을 것처럼 빌드 결과물을 컨테이너 이미지로 저장하며, 레지스트리 수출자는 자동으로 지정된 레지스트리로 푸시합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker buildx build --output type=registry,name=martinheinz/\u003cspan class=\"hljs-attr\"\u003etestimage\u003c/span\u003e:latest .\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리가 해야 할 일은 --output 옵션을 지정하고 registry의 유형과 대상을 설정하는 것뿐입니다. 이 옵션은 한 번에 여러 레지스트리를 지정하는 것도 지원합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker buildx build --output type=registry,\\\u003cspan class=\"hljs-string\"\u003e\"name=docker.io/martinheinz/testimage,docker.io/martinheinz/testimage2\\\" .\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, --cache-to 및 --cache-from 옵션을 제공하여 레지스트리에서 기존 이미지를 캐시 소스로 사용할 수도 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker buildx build --output type=registry,name=martinheinz/\u003cspan class=\"hljs-attr\"\u003etestimage\u003c/span\u003e:latest \\\n --cache-to type=inline \\\n --cache-\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e type=registry,ref=docker.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/martinheinz/testimage .\n\n...\n =\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCACHED\u003c/span\u003e docker-\u003cspan class=\"hljs-attr\"\u003eimage\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//docker.io/docker/dockerfile:1.4@sha256:9ba7531bd80fb0a858632727cf7a112fbfd19b17e94c4e84ced81e24ef1a0dbc\u003c/span\u003e\n...\n =\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCACHED\u003c/span\u003e [builder \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e] \u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /app                                                                                                  \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e초\n =\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCACHED\u003c/span\u003e [builder \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e] \u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e /app                                                                                    \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e초\n =\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCACHED\u003c/span\u003e [builder \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e] \u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e --mount=type=cache,target=\u003cspan class=\"hljs-regexp\"\u003e/root/\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecache\u003c/span\u003e/pip     pip3 install -r requirements.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e                           \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e초\n =\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCACHED\u003c/span\u003e [builder \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e] \u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e . /app                                                                                                   \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e초\n =\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCACHED\u003c/span\u003e [dev-envs \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] \u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e \u0026#x3C;\u0026#x3C;\u003cspan class=\"hljs-variable constant_\"\u003eEOF\u003c/span\u003e (apk update...)                                                                                    \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e초\n =\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCACHED\u003c/span\u003e [dev-envs \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] \u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e \u0026#x3C;\u0026#x3C;\u003cspan class=\"hljs-variable constant_\"\u003eEOF\u003c/span\u003e (addgroup -S docker...)                                                                            \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e초\n =\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCACHED\u003c/span\u003e [dev-envs \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] \u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e --\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e=gloursdocker/docker / /                                                                          \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e초\n =\u003e preparing layers \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e inline cache                                                                                                  \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e초\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e이미지 도구\u003c/h1\u003e\n\u003cp\u003e도커 빌드x의 간편하지만 유용한 서브커맨드인 imagetools는 이미지를 가져오지 않고도 레지스트리의 이미지를 검사할 수 있게 해줍니다. 자세한 내용은 많은 예시를 포함하고 있지만, 저에게 가장 유용한 것은 원격 이미지의 다이제스트를 가져오는 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker buildx imagetools inspect alpine --format \u003cspan class=\"hljs-string\"\u003e\"{json .Manifest}\"\u003c/span\u003e | jq .\u003cspan class=\"hljs-property\"\u003edigest\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"sha256:c5b1261d6d3e43071626931fc004f70149baeba2c8ec672bd4f27761f8e1ad6a\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e최신 Dockerfile 구문\u003c/h1\u003e\n\u003cp\u003e빌드킷과 함께 새로운 Dockerfile 구문이 도입되었습니다. 이를 통해 Dockerfile 프론트엔드라는 것이 사용됩니다. 현재 최신 구문을 활성화하려면 Dockerfile 맨 위에 다음과 같은 지시문을 추가해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# syntax=docker/\u003cspan class=\"hljs-attr\"\u003edockerfile\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.3\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e버전을 확인하려면 dockerfile-upstream 도커 허브 저장소를 확인하세요.\u003c/p\u003e\n\u003cp\u003e지금부터 소개할 첫 번째 도커 파일 문법 개선 사항은 here-docs입니다. 여기서는 멀티 라인 스크립트를 RUN 및 COPY 명령어에 전달할 수 있게 해줍니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# syntax = docker/\u003cspan class=\"hljs-attr\"\u003edockerfile\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.3\u003c/span\u003e-labs\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e debian\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e \u0026#x3C;\u0026#x3C;eot bash\n  apt-get update\n  apt-get install -y vim\neot\n\n# 같은 내용:\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e apt-get update \u0026#x26;\u0026#x26; apt-get install -y vim\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e과거에는 단일 RUN에 여러 명령어를 넣고 싶다면 \u0026#x26;\u0026#x26;을 사용해야 했지만, 이제는 here-docs를 사용하여 일반 스크립트를 작성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e게다가, 첫 번째 줄에서 해석기를 지정할 수 있어 Python 스크립트를 작성할 수도 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-comment\"\u003e# syntax = docker/dockerfile:1.3-labs\u003c/span\u003e\nFROM python:3.6\nRUN \u0026#x3C;\u0026#x3C;\u003cspan class=\"hljs-string\"\u003eeot\n#!/usr/bin/env python\nprint(\"hello world\")\neot\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eCOPY and ADD Features\u003c/h1\u003e\n\u003cp\u003e새로운 Dockerfile 구문에서는 COPY 및 ADD에 대한 변경 사항과 개선 사항도 더 많이 있습니다.\u003c/p\u003e\n\u003cp\u003eCOPY는 이제 --parents 옵션을 지원합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# syntax=docker/\u003cspan class=\"hljs-attr\"\u003edockerfile\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.7\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e-labs\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e ubuntu\n\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e ./one/two/some.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e /normal/\n\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e find /normal\n#\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e [\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e] \u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e find /normal\n#\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.223\u003c/span\u003e /normal\n#\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.223\u003c/span\u003e /normal/some.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e --parents ./one/two/some.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e /parents/\n\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e find /parents\n#\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e [\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e] \u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e find /parents\n#\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.509\u003c/span\u003e /parents\n#\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.509\u003c/span\u003e /parents/one\n#\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.509\u003c/span\u003e /parents/one/two\n#\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0.509\u003c/span\u003e /parents/one/two/some.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 일반 COPY로 중첩된 파일을 복사하면 이미지에는 부모 디렉토리 없이 파일 자체만 포함되며, --parents로 전체 파일 트리가 복사됩니다. 이는 cp --parents의 작동 방식과 유사합니다.\u003c/p\u003e\n\u003cp\u003e--exclude 옵션을 사용할 수 있는 것과 같이, --parents 옵션도 사용할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e --exclude=*.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e ./some-dir\u003cspan class=\"hljs-comment\"\u003e/* ./some-dest\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e파일을 복사할 때 제외된 파일 및 패턴을 무시하는 옵션입니다.\u003c/p\u003e\n\u003cp\u003e마침내 ADD 명령어도 향상되었습니다 - 이제 Git 저장소를 직접 추가할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# syntax=docker/\u003cspan class=\"hljs-attr\"\u003edockerfile\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.7\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e-labs\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e ubuntu\n\n\u003cspan class=\"hljs-variable constant_\"\u003eADD\u003c/span\u003e git@github.\u003cspan class=\"hljs-property\"\u003ecom\u003c/span\u003e:kelseyhightower/helloworld.\u003cspan class=\"hljs-property\"\u003egit\u003c/span\u003e /repo\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e ls -la /repo\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 Dockerfile을 빌드하면 다음과 같은 결과를 얻을 수 있습니다:\u003c/p\u003e\n\u003cp\u003edocker buildx build --ssh default --progress=plain .\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e[2/3] ADD \u003ca href=\"mailto:git@github.com\"\u003egit@github.com\u003c/a\u003e:kelseyhightower/helloworld.git /repo\n\u003cul\u003e\n\u003cli\u003eWarning: Permanently added 'github.com' (ED25519) to the list of known hosts.\u003c/li\u003e\n\u003cli\u003eref: refs/heads/master HEAD\n\u003cul\u003e\n\u003cli\u003e96a652519d1aaca11085ca3a7806bead4d2c273f   HEAD\u003c/li\u003e\n\u003cli\u003e96a652519d1aaca11085ca3a7806bead4d2c273f   refs/heads/master\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eref: refs/heads/master HEAD\n\u003cul\u003e\n\u003cli\u003e96a652519d1aaca11085ca3a7806bead4d2c273f   HEAD\u003c/li\u003e\n\u003cli\u003eFrom github.com:kelseyhightower/helloworld\n\u003cul\u003e\n\u003cli\u003e[new branch]      master     -\u003e master\u003c/li\u003e\n\u003cli\u003e[new branch]      master     -\u003e origin/master\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDONE 7.4s\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e[2/3] ADD \u003ca href=\"mailto:git@github.com\"\u003egit@github.com\u003c/a\u003e:kelseyhightower/helloworld.git /repo\n\u003cul\u003e\n\u003cli\u003eDONE 0.0s\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이것은 비공개 저장소에도 작동합니다.\u003c/p\u003e\n\u003cp\u003e더 많은 흥미로운 옵션을 문서에서 볼 수 있습니다. 예를 들어, --keep-git-dir이나 --checksum을 통해 아티팩트 체크섬을 유효성 검사할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e보너스: 들여쓰기\u003c/h1\u003e\n\u003cp\u003e그리고 BuildKit 기능은 아니지만, 최근에 발견한 하나의 사실은 Dockerfile에서 줄을 들여쓰면 잘 작동한다는 것입니다. 이렇게 하면 다단계 빌드를 진행할 때 가독성이 향상되는 효과를 얻을 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# syntax=docker/\u003cspan class=\"hljs-attr\"\u003edockerfile\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003egolang\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.21\u003c/span\u003e\n  \u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /src\n  \n  \u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e main.\u003cspan class=\"hljs-property\"\u003ego\u003c/span\u003e .\n  \u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e go build -o /bin/hello ./main.\u003cspan class=\"hljs-property\"\u003ego\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e scratch\n  \u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e --\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e /bin/hello /bin/hello\n  \u003cspan class=\"hljs-variable constant_\"\u003eCMD\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"/bin/hello\"\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e처음에는 이상하게 보일 수 있지만, 내견에 따르면 더 읽기 쉬워져서 각 단계가 어디에서 시작되고 어떤 명령이 속해 있는지 명확해집니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 기사의 예시는 내가 가장 유용하다고 생각하는 기능들만을 보여줍니다. 그러나 Docker 공식 문서와 BuildKit 문서, 또한 최신 변경 사항을 확인해보십시오. Docker 블로그도 좋은 자료가 있으며 특히 표시된 글들을 확인해보세요.\u003c/p\u003e\n\u003cp\u003e이 기사는 원래 martinheinz.dev에서 게시되었습니다.\u003c/p\u003e\n\u003cp\u003e또한 다음 글들을 즐기실 수도 있습니다...\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-15-RecentDockerBuildKitFeaturesYoureMissingOutOn"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>