<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>JavaScript - ECMAScript 2024 ES15에 대해 새롭게 알아본 것들 - 깊이 있는 안내 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="JavaScript - ECMAScript 2024 ES15에 대해 새롭게 알아본 것들 - 깊이 있는 안내 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="JavaScript - ECMAScript 2024 ES15에 대해 새롭게 알아본 것들 - 깊이 있는 안내 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide" data-gatsby-head="true"/><meta name="twitter:title" content="JavaScript - ECMAScript 2024 ES15에 대해 새롭게 알아본 것들 - 깊이 있는 안내 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 14:02" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">JavaScript - ECMAScript 2024 ES15에 대해 새롭게 알아본 것들 - 깊이 있는 안내</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="JavaScript - ECMAScript 2024 ES15에 대해 새롭게 알아본 것들 - 깊이 있는 안내" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png" alt="image"></p>
<p>라이브 기사 — 최근 업데이트: 2024년 2월 7일.</p>
<p>프로그래밍 언어에서 새로운 기능을 발견하는 것은 휴일이나 생일처럼 기대감과 새로운 선물을 탐험하는 기쁨으로 가득한 흥미진진한 시간입니다. ES2024®의 제안된 기능으로 인해 개발자들은 JavaScript 코딩을 더 효율적이고 가독성 있고 견고하게 만들어 주는 다양한 향상을 풀어나가려는 이유입니다. 최상위 await의 직관적인 구문부터 파이프라인 연산자의 표현력 있는 기능, 그리고 불변 레코드와 튜플의 신뢰성까지, 각 새로운 기능은 선택된 선물처럼 주어져서 JavaScript 생태계를 발전시키고 개발자들에게 더 많은 도구를 제공하기 위해 공들여 디자인되었습니다.</p>
<p>ECMAScript 2024 국제화 API 사양(ECMA-402 11판)에 따르면 ES2024에는 여러 기능이 포함될 예정입니다.</p>
<p>그냥 유의해 주세요. 몇 가지는 여전히 "제안 사항"이라서 조금씩 변경될 수 있지만, 다행히도 이 문서는 승인된 변경 사항에 맞춰 조정될 것입니다!</p>
<p>더 이상 미루지 말고…</p>
<h1>잘 형성된 유니코드 문자열</h1>
<p>이 기능은 JavaScript가 유니코드 문자열을 처리하는 방식을 개선하려는 것입니다. 유니코드 문자열은 다양한 언어와 기호를 나타내는 데 중요합니다. 이 업데이트는 다른 JavaScript 환경에서 이러한 문자열을 일관되고 정확하게 처리할 수 있도록 보장할 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> sampleStrings = [
  <span class="hljs-comment">// 혼자 있는 대체문자가 포함된 예제</span>
  <span class="hljs-string">"igor\uD800"</span>, <span class="hljs-comment">// 앞 부분 대체문자</span>
  <span class="hljs-string">"igor\uD800komolov"</span>, <span class="hljs-comment">// 앞 부분 대체문자 뒤에 텍스트</span>
  <span class="hljs-string">"\uDC00yourfuse"</span>,    <span class="hljs-comment">// 뒷 부분 대체문자</span>
  <span class="hljs-string">"your\uDC00fuse"</span>,    <span class="hljs-comment">// 뒷 부분 대체문자 뒤에 텍스트</span>
  
  <span class="hljs-comment">// 올바르게 작성된 예제</span>
  <span class="hljs-string">"yourFuse"</span>,       <span class="hljs-comment">// 대체문자 없는 일반 문자열</span>
  <span class="hljs-string">"emoji\uD83D\uDE00"</span>, <span class="hljs-comment">// 완전한 대체 문자 쌍(이모지)을 갖는 문자열</span>
];

sampleStrings.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">str</span> =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`처리된 문자열: <span class="hljs-subst">${str.toWellFormed()}</span>`</span>);
});

<span class="hljs-comment">// 기대 출력:</span>
<span class="hljs-comment">// "처리된 문자열: igor�"</span>
<span class="hljs-comment">// "처리된 문자열: igor�komolov"</span>
<span class="hljs-comment">// "처리된 문자열: �yourfuse"</span>
<span class="hljs-comment">// "처리된 문자열: your�fuse"</span>
<span class="hljs-comment">// "처리된 문자열: yourFuse"</span>
<span class="hljs-comment">// "처리된 문자열: emoji😀"</span>
</code></pre>
<p>위의 예제에서는 toWellFormed() 메소드가 혼자 있는 대체 문자와 올바르게 작성된 문자열이 포함된 문자열 배열에 적용됩니다. 이 메소드는 혼자 있는 대체 문자를 올바르게 작성된 유니코드 문자열로 변환하여 잘못된 시퀀스를 대체 문자로 바꾸며, 이미 올바르게 작성된 문자열은 변경하지 않습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> problematicURL = <span class="hljs-string">"https://yourfuse.com/query=\uDC00data"</span>;

<span class="hljs-keyword">try</span> {
  <span class="hljs-built_in">encodeURI</span>(problematicURL);
} <span class="hljs-keyword">catch</span> (e) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'에러:'</span>, e.<span class="hljs-property">message</span>); <span class="hljs-comment">// 기대 결과: URIError: URI malformed</span>
}

<span class="hljs-comment">// toWellFormed()를 사용하여 에러 방지</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'올바른 형식의 URI:'</span>, <span class="hljs-built_in">encodeURI</span>(problematicURL.<span class="hljs-title function_">toWellFormed</span>())); 
<span class="hljs-comment">// 기대 출력: "https://yourfuse.com/query=%EF%BF%BDdata"</span>
</code></pre>
<ul>
<li>problematicURL 변수에는 뒷 부분 대체 문자(\uDC00)를 포함한 URL이 들어 있습니다.</li>
<li>encodeURI()로 이 URL을 인코딩하려고 하면 잘못된 유니코드 문자열로 인해 URIError가 발생합니다.</li>
<li>toWellFormed()를 적용하면 혼자 있는 대체 문자가 유니코드 대체 문자(U+FFFD, %EF%BF%BD로 인코드)로 대체되어 encodeURI()가 오류 없이 처리할 수 있게 됩니다.</li>
</ul>
<h1>Atomic waitSync</h1>
<p>이 추가 사항은 주로 공유 메모리 컨텍스트에서 동시 작업을 대상으로 합니다. 이는 데이터 무결성을 보장하고 멀티스레드 작업에서 경합 조건을 방지하는 데 중요한 동기화 메커니즘을 제공합니다. 예를 들어, waitSync는 여러 작업자 간의 공유 버퍼에 대한 액세스를 동기화하는 데 사용될 수 있습니다.</p>
<p>아직 예제가 제공되지 않아 문서가 아직 작성 중이므로 어떻게 구현될지 보여드릴 수 없습니다. 그러나 기존 Atomics 메서드를 기반으로 가정을 할 수 있습니다. 다음과 같습니다...</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// sharedArray가 SharedArrayBuffer임을 가정합니다.</span>
<span class="hljs-keyword">const</span> sharedArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int32Array</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedArrayBuffer</span>(<span class="hljs-number">1024</span>));

<span class="hljs-keyword">function</span> <span class="hljs-title function_">performSynchronizedOperation</span>(<span class="hljs-params">index, value</span>) {
    <span class="hljs-comment">// waitSync 메서드는 특정 조건이 충족될 때까지 실행을 차단합니다.</span>
    <span class="hljs-comment">// 예를 들어, 지정된 인덱스의 값이 0이 아닌 값이 될 때까지 기다릴 수 있습니다.</span>
    <span class="hljs-title class_">Atomics</span>.<span class="hljs-title function_">waitSync</span>(sharedArray, index, <span class="hljs-number">0</span>);

    <span class="hljs-comment">// 공유 메모리에서 작업 수행</span>
    sharedArray[index] = value;

    <span class="hljs-comment">// 다른 스레드나 작업자에게 인덱스의 값이 업데이트되었음을 알립니다.</span>
    <span class="hljs-title class_">Atomics</span>.<span class="hljs-title function_">notify</span>(sharedArray, index, <span class="hljs-number">1</span>);
}

<span class="hljs-comment">// 웹 워커나 다른 스레드에서</span>
<span class="hljs-title function_">performSynchronizedOperation</span>(<span class="hljs-number">0</span>, <span class="hljs-number">123</span>);
</code></pre>
<h1>정규 표현식의 v 플래그와 집합 표기법 + 문자열 속성</h1>
<p>자바스크립트의 정규 표현식에 대한 이 개선 사항은 더 복잡한 패턴 매칭과 문자열 조작을 가능하게 합니다. 'v' 플래그와 집합 표기법을 사용하면 더 정확하고 표현력 있는 정규식 패턴을 생성할 수 있습니다. 예를 들어, 이 기능을 사용하여 특정 유니코드 속성을 가진 문자 집합을 일치시킬 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 차이/빼기</span>
[A--B]

<span class="hljs-comment">// 교집합</span>
[A&#x26;&#x26;B]

<span class="hljs-comment">// 중첩된 문자 클래스</span>
[A--[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]]
</code></pre>
<p>A와 B는 문자 클래스(예: [a-z])나 속성 이스케이프를 나타냅니다. 제안에 대한 설명적인 예제와 FAQ을 확인할 수 있습니다.</p>
<h1>최상위 await</h1>
<p>이 "Just Do It" 기능은 await 키워드가 비동기 함수 외부에서도 사용되도록 허용하여 비동기 코드를 더 쉽게 작성하고 읽을 수 있게 합니다. 예를 들어, 모듈의 최상위 수준에서 프로미스를 직접 await할 수 있어 모듈 가져오기 또는 데이터 비동기로 가져오는 코드를 간소화할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 최상위 await 사용</span>
<span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);
</code></pre>
<p>정말로 무겁고 복잡한 async/await 구조에 새로운 바람을 불어넣어 줍니다!</p>
<h1>파이프라인 연산자</h1>
<p>파이프라인 연산자(<code>|</code>)는 여러 함수 호출로 이루어진 코드의 가독성을 향상시킵니다. 이는 함수형 스타일 구문을 허용하여 식의 결과를 다음 함수의 인자로 전달할 수 있게 합니다. 예를 들어, 중첩된 함수 호출을 명확한 연산 순서로 재구성할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 파이프라인 연산자 없이</span>
<span class="hljs-keyword">const</span> calculatedValue = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">10</span>), <span class="hljs-number">1</span>/<span class="hljs-number">3</span>));

<span class="hljs-comment">// 파이프라인 연산자 사용 시</span>
<span class="hljs-keyword">const</span> calculatedValue = -<span class="hljs-number">10</span>
  |> (<span class="hljs-function"><span class="hljs-params">n</span> =></span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, n)) <span class="hljs-comment">// Math.max 대체</span>
  |> (<span class="hljs-function"><span class="hljs-params">n</span> =></span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(n, <span class="hljs-number">1</span>/<span class="hljs-number">3</span>)) <span class="hljs-comment">// Math.pow 대체</span>
  |> <span class="hljs-title class_">Math</span>.<span class="hljs-property">ceil</span>; <span class="hljs-comment">// Math.ceil 사용</span>
</code></pre>
<p>이 예제에서:</p>
<ul>
<li>Math.max 함수는 숫자가 음수가 아닌지 확인합니다.</li>
<li>Math.pow 함수는 세제곱근을 계산합니다 (1/3의 거듭제곱).</li>
<li>Math.ceil 함수는 숫자를 가장 가까운 정수로 올립니다.</li>
</ul>
<p>파이프라인 연산자(<code>|</code>)는 이러한 작업들을 연쇄적으로 쉽게 할 수 있게 해주어 코드를 더 읽기 쉽게 만듭니다.</p>
<p>이제 다음은 데이터 변환에 파이프라인 연산자가 얼마나 유용한지 보여주는 예제입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 파이프라인 연산자는 일련의 함수들을 명확하고 간결한 방식으로 연쇄적으로 적용하여 복잡한 데이터 조작을 간단하게 합니다.</span>

<span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>];

<span class="hljs-keyword">const</span> processedNumbers = numbers
  |> (<span class="hljs-function"><span class="hljs-params">_</span> =></span> _.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">n</span> =></span> n / <span class="hljs-number">2</span>)) <span class="hljs-comment">// 각 숫자를 절반으로 나누기</span>
  |> (<span class="hljs-function"><span class="hljs-params">_</span> =></span> _.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">n</span> =></span> n > <span class="hljs-number">10</span>)); <span class="hljs-comment">// 10보다 작거나 같은 숫자 제외하기</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(processedNumbers); <span class="hljs-comment">// [15, 20, 25]</span>
</code></pre>
<p>이 예제에서:</p>
<ul>
<li>map 함수는 배열 내의 각 숫자를 절반으로 나눕니다.</li>
<li>filter 함수는 10 이하인 숫자를 제거합니다.</li>
<li>파이프라인 연산자 (|`)를 사용하여 이러한 변환을 우아하게 연결하여 코드 가독성을 향상시킵니다.</li>
</ul>
<p>기억하세요, 파이프라인 연산자는 여전히 "Draft" 상태인 TC39의 단계 2에 있습니다.</p>
<h1>레코드 및 튜플</h1>
<p>이 변하지 않는 데이터 구조들은 각각 객체와 배열과 유사하지만 생성 후 수정할 수 없습니다. 예를 들어, 레코드나 튜플을 업데이트하면 새로운 인스턴스가 생성됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 불변한 레코드 생성</span>
<span class="hljs-keyword">const</span> userProfile = #{
  <span class="hljs-attr">username</span>: <span class="hljs-string">"IgorKomolov"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">39</span>,
};

<span class="hljs-comment">// 불변한 튜플 생성</span>
<span class="hljs-keyword">const</span> numberSequence = #[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];

<span class="hljs-comment">// 이러한 구조를 업데이트하면 새로운 인스턴스가 생성됩니다</span>
<span class="hljs-keyword">const</span> updatedProfile = userProfile.<span class="hljs-title function_">with</span>({ <span class="hljs-attr">age</span>: <span class="hljs-number">40</span>});
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(updatedProfile); <span class="hljs-comment">// #{ username: "IgorKomolov", age: 40 }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userProfile); <span class="hljs-comment">// #{ username: "IgorKomolov", age: 39 } (변하지 않음)</span>

<span class="hljs-keyword">const</span> newNumberSequence = numberSequence.<span class="hljs-title function_">with</span>(<span class="hljs-number">1</span>, <span class="hljs-number">25</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newNumberSequence); <span class="hljs-comment">// #[10, 25, 30]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numberSequence); <span class="hljs-comment">// #[10, 20, 30] (변하지 않음)</span>
</code></pre>
<p>레코드는 객체와 유사하게 동작하고, 튜플은 배열과 유사합니다. 그러나 그들의 핵심 특징은 불변성입니다.</p>
<p>레코드와 튜플은 특정 상황에서 성능을 향상시키고 코드베이스에서 불변성을 강제할 수 있습니다. 이들은 제안의 2단계에 있으며 아직 JavaScript 엔진에 구현되지는 않았지만, 개발자들은 Babel과 같은 트랜스파일러를 사용하여 이들을 실험할 수 있습니다.</p>
<h1>데코레이터</h1>
<p>이제 이게 가능해졌어요, TypeScript에 감사해요! 클래스, 메서드, 속성 또는 매개변수의 동작을 수정하거나 확장하는 기능을 제공합니다. 주석 추가, 로깅 또는 선언적 방식으로 동작을 수정하는 데 특히 유용합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 메서드 실행을 추적하기 위해 데코레이터 적용</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SampleClass</span> {
  @trackExecution
  <span class="hljs-title function_">performAction</span>(<span class="hljs-params">parameter1, parameter2</span>) {
    <span class="hljs-comment">// 메서드 구현 내용이 여기에 있습니다</span>
  }
}
</code></pre>
<p>이 예시에서:</p>
<ul>
<li>SampleClass는 정의되는 클래스입니다.</li>
<li>@trackExecution은 performAction 메서드 호출을 기록하거나 추적하기 위해 사용되는 데코레이터입니다.</li>
<li>performAction은 SampleClass 내의 메서드로, 두 개의 매개변수(parameter1 및 parameter2)를 사용합니다. 이 데코레이터는 이 메서드에 대한 각 호출을 기록하거나 추적합니다.</li>
</ul>
<h1>패턴 매칭</h1>
<p>이 기능은 복잡한 데이터 구조의 비구조화 및 일치에 대한 간결한 구문을 소개하여 코드 가독성을 높이고 보일러플레이트를 줄입니다.</p>
<p>(연구 중) 더 많은 정보가 곧 제공될 예정이니 나중에 다시 확인해주세요!</p>
<h1>Temporal</h1>
<p>잠시만요! 엄청 오래전에 기획되었지만, 업데이트된 Temporal은 JavaScript를 위해 제안된 최신 및 포괄적인 날짜 및 시간 API로, 현재 Stage 3에 있어요. 기존 Date 객체의 제한 사항과 복잡성 중 많은 부분을 해결하기 위해 설계되었어요. 여기 ES2024에서 Temporal을 사용하는 몇 가지 예시가 있어요:</p>
<p>이 객체는 현재 시간에 대한 Temporal 값을 생성하기 위한 여러 팩토리 메서드를 제공해요.</p>
<h2>UTC에서 현재 시간 가져오기</h2>
<p>Temporal.Now.instant().toString()</p>
<h2>특정 시간대에서 현재 존재하는 날짜 및 시간 가져오기</h2>
<p>Temporal.Now.zonedDateTimeISO(<code>Asia/Shanghai</code>).toString()</p>
<h2>ISO 형식의 현재 플레인 날짜 및 시간 가져오기</h2>
<p>표를 아래와 같이 Markdown 형식으로 변경해주세요.</p>
<p>Temporal.Now.plainDateTimeISO().toString()</p>
<h2>현재 plain 시간을 ISO 형식으로 얻기</h2>
<p>Temporal.Now.plainTimeISO().toString().</p>
<h2>ZonedDateTime.prototype의 속성</h2>
<p>Temporal의 ZonedDateTime 클래스에는 날짜 및 시간 정보를 자세히 조작하고 검색할 수 있는 여러 속성과 메서드가 있습니다.</p>
<ul>
<li>이러한 속성 및 메서드에는 달력, 시간대, 연도, 월, 일, 시간, 분, 초 및 나노초를 반환하는 getter가 포함됩니다.</li>
<li>.with(), .add(), .subtract(), .until(), .since(), .round()과 같은 메서드도 포함되어 있어, 지역 시간 값을 다루는 데 풍부한 기능을 제공합니다.</li>
</ul>
<h2>Temporal의 Plain Time 클래스</h2>
<p>Temporal은 시간대 없이 시간을 나타내는 추상 클래스인 "plain" 클래스를 소개합니다.</p>
<ul>
<li>이러한 클래스에는 PlainDateTime, PlainDate 및 PlainTime이 포함됩니다.</li>
<li>이들은 특정 시간대에서 벽시간을 표시하거나 1984년 6월의 첫 번째 화요일을 찾는 것과 같이 시간대가 중요하지 않은 시간 계산에 유용합니다.</li>
</ul>
<p>이 예시들은 ES2024의 Temporal이 JavaScript에서의 날짜 및 시간 처리를 간단하고 향상시킬 수 있다는 것을 보여줍니다. 개발자들에게 더 견고하고 다재다능한 도구를 제공합니다.</p>
<p>지금 사용해보고 싶으신가요? 문제없어요!</p>
<p>제안을 가져오거나 Babel Polyfil을 사용해보세요. 이렇게 제안을 가져오는 방법이 있습니다...</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//네 맞아요, 제안서도 가져올 수 있어요 :)</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Temporal</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@std/proposal-temporal'</span>;


<span class="hljs-comment">//기본 연산</span>
<span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Temporal</span>.<span class="hljs-property">Now</span>.<span class="hljs-title function_">zonedDateTimeISO</span>(<span class="hljs-string">'America/New_York'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(now.<span class="hljs-title function_">toString</span>());

<span class="hljs-comment">//조작 및 비교</span>

<span class="hljs-keyword">const</span> date = <span class="hljs-title class_">Temporal</span>.<span class="hljs-property">PlainDate</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'2024-01-01'</span>);
<span class="hljs-keyword">const</span> newDate = date.<span class="hljs-title function_">add</span>({ <span class="hljs-attr">days</span>: <span class="hljs-number">10</span> });
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newDate.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 결과 '2024-01-11'</span>
</code></pre>
<h1>에르고노믹 브랜드 체크</h1>
<p>사용자 지정 클래스 및 데이터 구조에서 객체 타입을 확인하는 것을 단순화하여 유형 검증을 더 직관적이고 실수를 줄입니다. 이제 부모 복제본은 보지 않을 거예요!</p>
<h2>전통적인 방법 (ES2024 이전)</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> {
    #author;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">author</span>) {
        <span class="hljs-variable language_">this</span>.#author = author;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">hasAuthorField</span>(<span class="hljs-params">obj</span>) {
        <span class="hljs-keyword">try</span> {
            obj.#author; <span class="hljs-comment">// 비공개 필드에 접근 시도</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 접근 성공</span>
        } <span class="hljs-keyword">catch</span> (err) {
            <span class="hljs-keyword">if</span> (err <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">TypeError</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 접근 실패, 필드가 존재하지 않음</span>
            }
            <span class="hljs-keyword">throw</span> err; <span class="hljs-comment">// 다른 오류는 다시 던짐</span>
        }
    }
}

<span class="hljs-comment">// 사용 예시:</span>
<span class="hljs-keyword">const</span> myBook = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">"Igor Komolov"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Book</span>.<span class="hljs-title function_">hasAuthorField</span>(myBook)); <span class="hljs-comment">// 예상 결과: true</span>

<span class="hljs-keyword">const</span> otherObject = {};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Book</span>.<span class="hljs-title function_">hasAuthorField</span>(otherObject)); <span class="hljs-comment">// 예상 결과: false</span>
</code></pre>
<h2>새로운 ES2024 방식</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BookES2024</span> {
    #author;

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">author</span>) {
        <span class="hljs-variable language_">this</span>.#author = author;
    }

    <span class="hljs-keyword">static</span> <span class="hljs-title function_">hasAuthorField</span>(<span class="hljs-params">obj</span>) {
        <span class="hljs-keyword">return</span> #author <span class="hljs-keyword">in</span> obj; <span class="hljs-comment">// 비공개 필드를 확인하는 새로운 ES2024 구문</span>
    }
}

<span class="hljs-comment">// 사용 예시:</span>
<span class="hljs-keyword">const</span> myBook2024 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookES2024</span>(<span class="hljs-string">"Igor Komolov"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">BookES2024</span>.<span class="hljs-title function_">hasAuthorField</span>(myBook2024)); <span class="hljs-comment">// 예상 결과: true</span>

<span class="hljs-keyword">const</span> otherObject2024 = {};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">BookES2024</span>.<span class="hljs-title function_">hasAuthorField</span>(otherObject2024)); <span class="hljs-comment">// 예상 결과: false</span>
</code></pre>
<p>이 예제에서 Book 클래스는 전통적인 방식을 보여주고, BookES2024는 새로운 ES2024 구문을 사용합니다. hasAuthorField 정적 메소드는 #author 비공개 필드가 객체에 존재하는지 확인하며, 각 클래스에서 서로 다른 접근 방식을 사용합니다.</p>
<h1>Realms API</h1>
<p>이 API는 격리된 JavaScript 환경을 만드는 메커니즘을 제공합니다. 안전한 코드 실행 및 샌드박싱에 유용하며, 제어된 격리된 컨텍스트에서 코드를 실행할 수 있게 합니다. 게다가, 이름도 너무 멋져요!</p>
<h2>Realm 생성 및 간단한 표현식 평가</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> igorsRealm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Realm</span>();
igorsRealm.evaluate(<span class="hljs-string">'3 * 5'</span>); <span class="hljs-comment">// Igor의 영역에서 15로 계산됨</span>
</code></pre>
<h2>다른 영역 간 심볼 공유</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> igorsRealm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Realm</span>();
<span class="hljs-title class_">Symbol</span>.<span class="hljs-title function_">for</span>(<span class="hljs-string">'y'</span>) === igorsRealm.evaluate(<span class="hljs-string">'Symbol.for("y")'</span>); <span class="hljs-comment">// true 반환, 공유된 심볼 'y'</span>
</code></pre>
<h2>자동 래핑된 함수 사용</h2>
<p>한 영역에서 다른 영역으로 전송된 호출 가능한 객체의 경우 대상 영역에서 래핑된 함수 이국적 객체가 생성됩니다. 호출되는 경우 래핑된 함수는 원래 영역의 연결된 함수로 호출을 연결합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> igorsRealm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Realm</span>();
<span class="hljs-keyword">const</span> doubleFunction = igorsRealm.evaluate(<span class="hljs-string">'num => num * 2'</span>);
<span class="hljs-title function_">doubleFunction</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 결과: 20</span>
</code></pre>
<h2>콜백을 이용한 함수 평가</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> igorsRealm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Realm</span>();
<span class="hljs-keyword">const</span> processNumber = igorsRealm.evaluate(<span class="hljs-string">'(number, callback) => callback(number + 5)'</span>);
<span class="hljs-title function_">processNumber</span>(<span class="hljs-number">5</span>, (<span class="hljs-function"><span class="hljs-params">result</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result))); <span class="hljs-comment">// 로그: 10 (5 + 5)</span>
</code></pre>
<h2>제한된 전역 컨텍스트 접근</h2>
<p>글로벌 객체인 globalThis, 배열 또는 Object.prototype에 realm.evaluate를 통해 직접 액세스하는 것은 TypeError를 발생시킵니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> igorsRealm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Realm</span>();
igorsRealm.evaluate(<span class="hljs-string">'this'</span>); <span class="hljs-comment">// TypeError 발생</span>
igorsRealm.evaluate(<span class="hljs-string">'new Array()'</span>); <span class="hljs-comment">// TypeError 발생</span>
igorsRealm.evaluate(<span class="hljs-string">'Object.keys({})'</span>); <span class="hljs-comment">// TypeError 발생</span>
</code></pre>
<p>ES2024에서 예정된 새로운 기능들은 자바스크립트 코딩에 접근하는 방식을 혁신할 것으로 예상됩니다. 이러한 향상들은 코드 가독성과 효율성을 향상시키는 것뿐만 아니라 불변 데이터 구조와 고급 패턴 매칭과 같은 강력한 새로운 패러다임을 소개하기도 합니다. 이러한 기능들이 제안에서 구현으로 이동할 때, 개발자들이 더 깨끗하고 유지보수 가능하며 표현력이 풍부한 자바스크립트 코드를 작성할 수 있는 새로운 가능성을 열어줍니다. 이러한 진보로운 발전과 함께 자바스크립트의 미래는 밝아보이며, 현대 웹 개발의 중요한 요충지가 된 언어의 지속적인 발전을 시사합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JavaScript - ECMAScript 2024 ES15에 대해 새롭게 알아본 것들 - 깊이 있는 안내","description":"","date":"2024-05-14 14:02","slug":"2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide","content":"\n\n![image](/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png)\n\n라이브 기사 — 최근 업데이트: 2024년 2월 7일.\n\n프로그래밍 언어에서 새로운 기능을 발견하는 것은 휴일이나 생일처럼 기대감과 새로운 선물을 탐험하는 기쁨으로 가득한 흥미진진한 시간입니다. ES2024®의 제안된 기능으로 인해 개발자들은 JavaScript 코딩을 더 효율적이고 가독성 있고 견고하게 만들어 주는 다양한 향상을 풀어나가려는 이유입니다. 최상위 await의 직관적인 구문부터 파이프라인 연산자의 표현력 있는 기능, 그리고 불변 레코드와 튜플의 신뢰성까지, 각 새로운 기능은 선택된 선물처럼 주어져서 JavaScript 생태계를 발전시키고 개발자들에게 더 많은 도구를 제공하기 위해 공들여 디자인되었습니다.\n\nECMAScript 2024 국제화 API 사양(ECMA-402 11판)에 따르면 ES2024에는 여러 기능이 포함될 예정입니다.\n\n\n\n그냥 유의해 주세요. 몇 가지는 여전히 \"제안 사항\"이라서 조금씩 변경될 수 있지만, 다행히도 이 문서는 승인된 변경 사항에 맞춰 조정될 것입니다!\n\n더 이상 미루지 말고…\n\n# 잘 형성된 유니코드 문자열\n\n이 기능은 JavaScript가 유니코드 문자열을 처리하는 방식을 개선하려는 것입니다. 유니코드 문자열은 다양한 언어와 기호를 나타내는 데 중요합니다. 이 업데이트는 다른 JavaScript 환경에서 이러한 문자열을 일관되고 정확하게 처리할 수 있도록 보장할 것입니다.\n\n\n\n```js\nconst sampleStrings = [\n  // 혼자 있는 대체문자가 포함된 예제\n  \"igor\\uD800\", // 앞 부분 대체문자\n  \"igor\\uD800komolov\", // 앞 부분 대체문자 뒤에 텍스트\n  \"\\uDC00yourfuse\",    // 뒷 부분 대체문자\n  \"your\\uDC00fuse\",    // 뒷 부분 대체문자 뒤에 텍스트\n  \n  // 올바르게 작성된 예제\n  \"yourFuse\",       // 대체문자 없는 일반 문자열\n  \"emoji\\uD83D\\uDE00\", // 완전한 대체 문자 쌍(이모지)을 갖는 문자열\n];\n\nsampleStrings.forEach(str =\u003e {\n  console.log(`처리된 문자열: ${str.toWellFormed()}`);\n});\n\n// 기대 출력:\n// \"처리된 문자열: igor�\"\n// \"처리된 문자열: igor�komolov\"\n// \"처리된 문자열: �yourfuse\"\n// \"처리된 문자열: your�fuse\"\n// \"처리된 문자열: yourFuse\"\n// \"처리된 문자열: emoji😀\"\n```\n\n위의 예제에서는 toWellFormed() 메소드가 혼자 있는 대체 문자와 올바르게 작성된 문자열이 포함된 문자열 배열에 적용됩니다. 이 메소드는 혼자 있는 대체 문자를 올바르게 작성된 유니코드 문자열로 변환하여 잘못된 시퀀스를 대체 문자로 바꾸며, 이미 올바르게 작성된 문자열은 변경하지 않습니다.\n\n```js\nconst problematicURL = \"https://yourfuse.com/query=\\uDC00data\";\n\ntry {\n  encodeURI(problematicURL);\n} catch (e) {\n  console.log('에러:', e.message); // 기대 결과: URIError: URI malformed\n}\n\n// toWellFormed()를 사용하여 에러 방지\nconsole.log('올바른 형식의 URI:', encodeURI(problematicURL.toWellFormed())); \n// 기대 출력: \"https://yourfuse.com/query=%EF%BF%BDdata\"\n```\n\n- problematicURL 변수에는 뒷 부분 대체 문자(\\uDC00)를 포함한 URL이 들어 있습니다.\n- encodeURI()로 이 URL을 인코딩하려고 하면 잘못된 유니코드 문자열로 인해 URIError가 발생합니다.\n- toWellFormed()를 적용하면 혼자 있는 대체 문자가 유니코드 대체 문자(U+FFFD, %EF%BF%BD로 인코드)로 대체되어 encodeURI()가 오류 없이 처리할 수 있게 됩니다.\n\n\n\n# Atomic waitSync\n\n이 추가 사항은 주로 공유 메모리 컨텍스트에서 동시 작업을 대상으로 합니다. 이는 데이터 무결성을 보장하고 멀티스레드 작업에서 경합 조건을 방지하는 데 중요한 동기화 메커니즘을 제공합니다. 예를 들어, waitSync는 여러 작업자 간의 공유 버퍼에 대한 액세스를 동기화하는 데 사용될 수 있습니다.\n\n아직 예제가 제공되지 않아 문서가 아직 작성 중이므로 어떻게 구현될지 보여드릴 수 없습니다. 그러나 기존 Atomics 메서드를 기반으로 가정을 할 수 있습니다. 다음과 같습니다...\n\n```js\n// sharedArray가 SharedArrayBuffer임을 가정합니다.\nconst sharedArray = new Int32Array(new SharedArrayBuffer(1024));\n\nfunction performSynchronizedOperation(index, value) {\n    // waitSync 메서드는 특정 조건이 충족될 때까지 실행을 차단합니다.\n    // 예를 들어, 지정된 인덱스의 값이 0이 아닌 값이 될 때까지 기다릴 수 있습니다.\n    Atomics.waitSync(sharedArray, index, 0);\n\n    // 공유 메모리에서 작업 수행\n    sharedArray[index] = value;\n\n    // 다른 스레드나 작업자에게 인덱스의 값이 업데이트되었음을 알립니다.\n    Atomics.notify(sharedArray, index, 1);\n}\n\n// 웹 워커나 다른 스레드에서\nperformSynchronizedOperation(0, 123);\n```\n\n\n\n# 정규 표현식의 v 플래그와 집합 표기법 + 문자열 속성\n\n자바스크립트의 정규 표현식에 대한 이 개선 사항은 더 복잡한 패턴 매칭과 문자열 조작을 가능하게 합니다. 'v' 플래그와 집합 표기법을 사용하면 더 정확하고 표현력 있는 정규식 패턴을 생성할 수 있습니다. 예를 들어, 이 기능을 사용하여 특정 유니코드 속성을 가진 문자 집합을 일치시킬 수 있습니다.\n\n```js\n// 차이/빼기\n[A--B]\n\n// 교집합\n[A\u0026\u0026B]\n\n// 중첩된 문자 클래스\n[A--[0-9]]\n```\n\nA와 B는 문자 클래스(예: [a-z])나 속성 이스케이프를 나타냅니다. 제안에 대한 설명적인 예제와 FAQ을 확인할 수 있습니다.\n\n\n\n# 최상위 await\n\n이 \"Just Do It\" 기능은 await 키워드가 비동기 함수 외부에서도 사용되도록 허용하여 비동기 코드를 더 쉽게 작성하고 읽을 수 있게 합니다. 예를 들어, 모듈의 최상위 수준에서 프로미스를 직접 await할 수 있어 모듈 가져오기 또는 데이터 비동기로 가져오는 코드를 간소화할 수 있습니다.\n\n```js\n// 최상위 await 사용\nconst data = await fetchData();\nconsole.log(data);\n```\n\n정말로 무겁고 복잡한 async/await 구조에 새로운 바람을 불어넣어 줍니다!\n\n\n\n# 파이프라인 연산자\n\n파이프라인 연산자(`|`)는 여러 함수 호출로 이루어진 코드의 가독성을 향상시킵니다. 이는 함수형 스타일 구문을 허용하여 식의 결과를 다음 함수의 인자로 전달할 수 있게 합니다. 예를 들어, 중첩된 함수 호출을 명확한 연산 순서로 재구성할 수 있습니다:\n\n```js\n// 파이프라인 연산자 없이\nconst calculatedValue = Math.ceil(Math.pow(Math.max(0, -10), 1/3));\n\n// 파이프라인 연산자 사용 시\nconst calculatedValue = -10\n  |\u003e (n =\u003e Math.max(0, n)) // Math.max 대체\n  |\u003e (n =\u003e Math.pow(n, 1/3)) // Math.pow 대체\n  |\u003e Math.ceil; // Math.ceil 사용\n```\n\n이 예제에서:\n\n\n\n- Math.max 함수는 숫자가 음수가 아닌지 확인합니다.\n- Math.pow 함수는 세제곱근을 계산합니다 (1/3의 거듭제곱).\n- Math.ceil 함수는 숫자를 가장 가까운 정수로 올립니다.\n\n파이프라인 연산자(`|`)는 이러한 작업들을 연쇄적으로 쉽게 할 수 있게 해주어 코드를 더 읽기 쉽게 만듭니다.\n\n이제 다음은 데이터 변환에 파이프라인 연산자가 얼마나 유용한지 보여주는 예제입니다:\n\n```js\n// 파이프라인 연산자는 일련의 함수들을 명확하고 간결한 방식으로 연쇄적으로 적용하여 복잡한 데이터 조작을 간단하게 합니다.\n\nconst numbers = [10, 20, 30, 40, 50];\n\nconst processedNumbers = numbers\n  |\u003e (_ =\u003e _.map(n =\u003e n / 2)) // 각 숫자를 절반으로 나누기\n  |\u003e (_ =\u003e _.filter(n =\u003e n \u003e 10)); // 10보다 작거나 같은 숫자 제외하기\n\nconsole.log(processedNumbers); // [15, 20, 25]\n```  \n\n\n\n이 예제에서:\n\n- map 함수는 배열 내의 각 숫자를 절반으로 나눕니다.\n- filter 함수는 10 이하인 숫자를 제거합니다.\n- 파이프라인 연산자 (|`)를 사용하여 이러한 변환을 우아하게 연결하여 코드 가독성을 향상시킵니다.\n\n기억하세요, 파이프라인 연산자는 여전히 \"Draft\" 상태인 TC39의 단계 2에 있습니다.\n\n# 레코드 및 튜플\n\n\n\n이 변하지 않는 데이터 구조들은 각각 객체와 배열과 유사하지만 생성 후 수정할 수 없습니다. 예를 들어, 레코드나 튜플을 업데이트하면 새로운 인스턴스가 생성됩니다:\n\n```js\n// 불변한 레코드 생성\nconst userProfile = #{\n  username: \"IgorKomolov\",\n  age: 39,\n};\n\n// 불변한 튜플 생성\nconst numberSequence = #[10, 20, 30];\n\n// 이러한 구조를 업데이트하면 새로운 인스턴스가 생성됩니다\nconst updatedProfile = userProfile.with({ age: 40});\nconsole.log(updatedProfile); // #{ username: \"IgorKomolov\", age: 40 }\nconsole.log(userProfile); // #{ username: \"IgorKomolov\", age: 39 } (변하지 않음)\n\nconst newNumberSequence = numberSequence.with(1, 25);\nconsole.log(newNumberSequence); // #[10, 25, 30]\nconsole.log(numberSequence); // #[10, 20, 30] (변하지 않음)\n```\n\n레코드는 객체와 유사하게 동작하고, 튜플은 배열과 유사합니다. 그러나 그들의 핵심 특징은 불변성입니다.\n\n레코드와 튜플은 특정 상황에서 성능을 향상시키고 코드베이스에서 불변성을 강제할 수 있습니다. 이들은 제안의 2단계에 있으며 아직 JavaScript 엔진에 구현되지는 않았지만, 개발자들은 Babel과 같은 트랜스파일러를 사용하여 이들을 실험할 수 있습니다.\n\n\n\n# 데코레이터\n\n이제 이게 가능해졌어요, TypeScript에 감사해요! 클래스, 메서드, 속성 또는 매개변수의 동작을 수정하거나 확장하는 기능을 제공합니다. 주석 추가, 로깅 또는 선언적 방식으로 동작을 수정하는 데 특히 유용합니다:\n\n```js\n// 메서드 실행을 추적하기 위해 데코레이터 적용\nclass SampleClass {\n  @trackExecution\n  performAction(parameter1, parameter2) {\n    // 메서드 구현 내용이 여기에 있습니다\n  }\n}\n```\n\n이 예시에서:\n\n\n\n- SampleClass는 정의되는 클래스입니다.\n- @trackExecution은 performAction 메서드 호출을 기록하거나 추적하기 위해 사용되는 데코레이터입니다.\n- performAction은 SampleClass 내의 메서드로, 두 개의 매개변수(parameter1 및 parameter2)를 사용합니다. 이 데코레이터는 이 메서드에 대한 각 호출을 기록하거나 추적합니다.\n\n# 패턴 매칭\n\n이 기능은 복잡한 데이터 구조의 비구조화 및 일치에 대한 간결한 구문을 소개하여 코드 가독성을 높이고 보일러플레이트를 줄입니다.\n\n(연구 중) 더 많은 정보가 곧 제공될 예정이니 나중에 다시 확인해주세요!\n\n\n\n# Temporal\n\n잠시만요! 엄청 오래전에 기획되었지만, 업데이트된 Temporal은 JavaScript를 위해 제안된 최신 및 포괄적인 날짜 및 시간 API로, 현재 Stage 3에 있어요. 기존 Date 객체의 제한 사항과 복잡성 중 많은 부분을 해결하기 위해 설계되었어요. 여기 ES2024에서 Temporal을 사용하는 몇 가지 예시가 있어요:\n\n이 객체는 현재 시간에 대한 Temporal 값을 생성하기 위한 여러 팩토리 메서드를 제공해요.\n\n## UTC에서 현재 시간 가져오기\n\n\n\n\nTemporal.Now.instant().toString()\n\n## 특정 시간대에서 현재 존재하는 날짜 및 시간 가져오기\n\nTemporal.Now.zonedDateTimeISO(`Asia/Shanghai`).toString()\n\n## ISO 형식의 현재 플레인 날짜 및 시간 가져오기\n\n\n\n\n표를 아래와 같이 Markdown 형식으로 변경해주세요.\n\nTemporal.Now.plainDateTimeISO().toString()\n\n## 현재 plain 시간을 ISO 형식으로 얻기\n\nTemporal.Now.plainTimeISO().toString().\n\n## ZonedDateTime.prototype의 속성\n\n\n\nTemporal의 ZonedDateTime 클래스에는 날짜 및 시간 정보를 자세히 조작하고 검색할 수 있는 여러 속성과 메서드가 있습니다.\n\n- 이러한 속성 및 메서드에는 달력, 시간대, 연도, 월, 일, 시간, 분, 초 및 나노초를 반환하는 getter가 포함됩니다.\n- .with(), .add(), .subtract(), .until(), .since(), .round()과 같은 메서드도 포함되어 있어, 지역 시간 값을 다루는 데 풍부한 기능을 제공합니다.\n\n## Temporal의 Plain Time 클래스\n\nTemporal은 시간대 없이 시간을 나타내는 추상 클래스인 \"plain\" 클래스를 소개합니다.\n\n\n\n- 이러한 클래스에는 PlainDateTime, PlainDate 및 PlainTime이 포함됩니다.\n- 이들은 특정 시간대에서 벽시간을 표시하거나 1984년 6월의 첫 번째 화요일을 찾는 것과 같이 시간대가 중요하지 않은 시간 계산에 유용합니다.\n\n이 예시들은 ES2024의 Temporal이 JavaScript에서의 날짜 및 시간 처리를 간단하고 향상시킬 수 있다는 것을 보여줍니다. 개발자들에게 더 견고하고 다재다능한 도구를 제공합니다.\n\n지금 사용해보고 싶으신가요? 문제없어요!\n\n제안을 가져오거나 Babel Polyfil을 사용해보세요. 이렇게 제안을 가져오는 방법이 있습니다...\n\n\n\n```js\n//네 맞아요, 제안서도 가져올 수 있어요 :)\nimport { Temporal } from '@std/proposal-temporal';\n\n\n//기본 연산\nconst now = Temporal.Now.zonedDateTimeISO('America/New_York');\nconsole.log(now.toString());\n\n//조작 및 비교\n\nconst date = Temporal.PlainDate.from('2024-01-01');\nconst newDate = date.add({ days: 10 });\nconsole.log(newDate.toString()); // 결과 '2024-01-11'\n```\n\n# 에르고노믹 브랜드 체크\n\n사용자 지정 클래스 및 데이터 구조에서 객체 타입을 확인하는 것을 단순화하여 유형 검증을 더 직관적이고 실수를 줄입니다. 이제 부모 복제본은 보지 않을 거예요!\n\n## 전통적인 방법 (ES2024 이전)\n\n\n\n```js\nclass Book {\n    #author;\n\n    constructor(author) {\n        this.#author = author;\n    }\n\n    static hasAuthorField(obj) {\n        try {\n            obj.#author; // 비공개 필드에 접근 시도\n            return true; // 접근 성공\n        } catch (err) {\n            if (err instanceof TypeError) {\n                return false; // 접근 실패, 필드가 존재하지 않음\n            }\n            throw err; // 다른 오류는 다시 던짐\n        }\n    }\n}\n\n// 사용 예시:\nconst myBook = new Book(\"Igor Komolov\");\nconsole.log(Book.hasAuthorField(myBook)); // 예상 결과: true\n\nconst otherObject = {};\nconsole.log(Book.hasAuthorField(otherObject)); // 예상 결과: false\n```\n\n## 새로운 ES2024 방식\n\n```js\nclass BookES2024 {\n    #author;\n\n    constructor(author) {\n        this.#author = author;\n    }\n\n    static hasAuthorField(obj) {\n        return #author in obj; // 비공개 필드를 확인하는 새로운 ES2024 구문\n    }\n}\n\n// 사용 예시:\nconst myBook2024 = new BookES2024(\"Igor Komolov\");\nconsole.log(BookES2024.hasAuthorField(myBook2024)); // 예상 결과: true\n\nconst otherObject2024 = {};\nconsole.log(BookES2024.hasAuthorField(otherObject2024)); // 예상 결과: false\n```\n\n이 예제에서 Book 클래스는 전통적인 방식을 보여주고, BookES2024는 새로운 ES2024 구문을 사용합니다. hasAuthorField 정적 메소드는 #author 비공개 필드가 객체에 존재하는지 확인하며, 각 클래스에서 서로 다른 접근 방식을 사용합니다.\n\n\n\n# Realms API\n\n이 API는 격리된 JavaScript 환경을 만드는 메커니즘을 제공합니다. 안전한 코드 실행 및 샌드박싱에 유용하며, 제어된 격리된 컨텍스트에서 코드를 실행할 수 있게 합니다. 게다가, 이름도 너무 멋져요!\n\n## Realm 생성 및 간단한 표현식 평가\n\n```js\nconst igorsRealm = new Realm();\nigorsRealm.evaluate('3 * 5'); // Igor의 영역에서 15로 계산됨\n```\n\n\n\n## 다른 영역 간 심볼 공유\n\n```js\nconst igorsRealm = new Realm();\nSymbol.for('y') === igorsRealm.evaluate('Symbol.for(\"y\")'); // true 반환, 공유된 심볼 'y'\n```\n\n## 자동 래핑된 함수 사용\n\n한 영역에서 다른 영역으로 전송된 호출 가능한 객체의 경우 대상 영역에서 래핑된 함수 이국적 객체가 생성됩니다. 호출되는 경우 래핑된 함수는 원래 영역의 연결된 함수로 호출을 연결합니다.\n\n\n\n```js\nconst igorsRealm = new Realm();\nconst doubleFunction = igorsRealm.evaluate('num =\u003e num * 2');\ndoubleFunction(10); // 결과: 20\n```\n\n## 콜백을 이용한 함수 평가\n\n```js\nconst igorsRealm = new Realm();\nconst processNumber = igorsRealm.evaluate('(number, callback) =\u003e callback(number + 5)');\nprocessNumber(5, (result =\u003e console.log(result))); // 로그: 10 (5 + 5)\n```\n\n## 제한된 전역 컨텍스트 접근\n\n\n\n\n글로벌 객체인 globalThis, 배열 또는 Object.prototype에 realm.evaluate를 통해 직접 액세스하는 것은 TypeError를 발생시킵니다.\n\n```js\nconst igorsRealm = new Realm();\nigorsRealm.evaluate('this'); // TypeError 발생\nigorsRealm.evaluate('new Array()'); // TypeError 발생\nigorsRealm.evaluate('Object.keys({})'); // TypeError 발생\n```\n\nES2024에서 예정된 새로운 기능들은 자바스크립트 코딩에 접근하는 방식을 혁신할 것으로 예상됩니다. 이러한 향상들은 코드 가독성과 효율성을 향상시키는 것뿐만 아니라 불변 데이터 구조와 고급 패턴 매칭과 같은 강력한 새로운 패러다임을 소개하기도 합니다. 이러한 기능들이 제안에서 구현으로 이동할 때, 개발자들이 더 깨끗하고 유지보수 가능하며 표현력이 풍부한 자바스크립트 코드를 작성할 수 있는 새로운 가능성을 열어줍니다. 이러한 진보로운 발전과 함께 자바스크립트의 미래는 밝아보이며, 현대 웹 개발의 중요한 요충지가 된 언어의 지속적인 발전을 시사합니다.","ogImage":{"url":"/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png"},"coverImage":"/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e라이브 기사 — 최근 업데이트: 2024년 2월 7일.\u003c/p\u003e\n\u003cp\u003e프로그래밍 언어에서 새로운 기능을 발견하는 것은 휴일이나 생일처럼 기대감과 새로운 선물을 탐험하는 기쁨으로 가득한 흥미진진한 시간입니다. ES2024®의 제안된 기능으로 인해 개발자들은 JavaScript 코딩을 더 효율적이고 가독성 있고 견고하게 만들어 주는 다양한 향상을 풀어나가려는 이유입니다. 최상위 await의 직관적인 구문부터 파이프라인 연산자의 표현력 있는 기능, 그리고 불변 레코드와 튜플의 신뢰성까지, 각 새로운 기능은 선택된 선물처럼 주어져서 JavaScript 생태계를 발전시키고 개발자들에게 더 많은 도구를 제공하기 위해 공들여 디자인되었습니다.\u003c/p\u003e\n\u003cp\u003eECMAScript 2024 국제화 API 사양(ECMA-402 11판)에 따르면 ES2024에는 여러 기능이 포함될 예정입니다.\u003c/p\u003e\n\u003cp\u003e그냥 유의해 주세요. 몇 가지는 여전히 \"제안 사항\"이라서 조금씩 변경될 수 있지만, 다행히도 이 문서는 승인된 변경 사항에 맞춰 조정될 것입니다!\u003c/p\u003e\n\u003cp\u003e더 이상 미루지 말고…\u003c/p\u003e\n\u003ch1\u003e잘 형성된 유니코드 문자열\u003c/h1\u003e\n\u003cp\u003e이 기능은 JavaScript가 유니코드 문자열을 처리하는 방식을 개선하려는 것입니다. 유니코드 문자열은 다양한 언어와 기호를 나타내는 데 중요합니다. 이 업데이트는 다른 JavaScript 환경에서 이러한 문자열을 일관되고 정확하게 처리할 수 있도록 보장할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sampleStrings = [\n  \u003cspan class=\"hljs-comment\"\u003e// 혼자 있는 대체문자가 포함된 예제\u003c/span\u003e\n  \u003cspan class=\"hljs-string\"\u003e\"igor\\uD800\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 앞 부분 대체문자\u003c/span\u003e\n  \u003cspan class=\"hljs-string\"\u003e\"igor\\uD800komolov\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 앞 부분 대체문자 뒤에 텍스트\u003c/span\u003e\n  \u003cspan class=\"hljs-string\"\u003e\"\\uDC00yourfuse\"\u003c/span\u003e,    \u003cspan class=\"hljs-comment\"\u003e// 뒷 부분 대체문자\u003c/span\u003e\n  \u003cspan class=\"hljs-string\"\u003e\"your\\uDC00fuse\"\u003c/span\u003e,    \u003cspan class=\"hljs-comment\"\u003e// 뒷 부분 대체문자 뒤에 텍스트\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 올바르게 작성된 예제\u003c/span\u003e\n  \u003cspan class=\"hljs-string\"\u003e\"yourFuse\"\u003c/span\u003e,       \u003cspan class=\"hljs-comment\"\u003e// 대체문자 없는 일반 문자열\u003c/span\u003e\n  \u003cspan class=\"hljs-string\"\u003e\"emoji\\uD83D\\uDE00\"\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 완전한 대체 문자 쌍(이모지)을 갖는 문자열\u003c/span\u003e\n];\n\nsampleStrings.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003estr\u003c/span\u003e =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`처리된 문자열: \u003cspan class=\"hljs-subst\"\u003e${str.toWellFormed()}\u003c/span\u003e`\u003c/span\u003e);\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 기대 출력:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \"처리된 문자열: igor�\"\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \"처리된 문자열: igor�komolov\"\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \"처리된 문자열: �yourfuse\"\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \"처리된 문자열: your�fuse\"\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \"처리된 문자열: yourFuse\"\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \"처리된 문자열: emoji😀\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 예제에서는 toWellFormed() 메소드가 혼자 있는 대체 문자와 올바르게 작성된 문자열이 포함된 문자열 배열에 적용됩니다. 이 메소드는 혼자 있는 대체 문자를 올바르게 작성된 유니코드 문자열로 변환하여 잘못된 시퀀스를 대체 문자로 바꾸며, 이미 올바르게 작성된 문자열은 변경하지 않습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e problematicURL = \u003cspan class=\"hljs-string\"\u003e\"https://yourfuse.com/query=\\uDC00data\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n  \u003cspan class=\"hljs-built_in\"\u003eencodeURI\u003c/span\u003e(problematicURL);\n} \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'에러:'\u003c/span\u003e, e.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 기대 결과: URIError: URI malformed\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// toWellFormed()를 사용하여 에러 방지\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'올바른 형식의 URI:'\u003c/span\u003e, \u003cspan class=\"hljs-built_in\"\u003eencodeURI\u003c/span\u003e(problematicURL.\u003cspan class=\"hljs-title function_\"\u003etoWellFormed\u003c/span\u003e())); \n\u003cspan class=\"hljs-comment\"\u003e// 기대 출력: \"https://yourfuse.com/query=%EF%BF%BDdata\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eproblematicURL 변수에는 뒷 부분 대체 문자(\\uDC00)를 포함한 URL이 들어 있습니다.\u003c/li\u003e\n\u003cli\u003eencodeURI()로 이 URL을 인코딩하려고 하면 잘못된 유니코드 문자열로 인해 URIError가 발생합니다.\u003c/li\u003e\n\u003cli\u003etoWellFormed()를 적용하면 혼자 있는 대체 문자가 유니코드 대체 문자(U+FFFD, %EF%BF%BD로 인코드)로 대체되어 encodeURI()가 오류 없이 처리할 수 있게 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eAtomic waitSync\u003c/h1\u003e\n\u003cp\u003e이 추가 사항은 주로 공유 메모리 컨텍스트에서 동시 작업을 대상으로 합니다. 이는 데이터 무결성을 보장하고 멀티스레드 작업에서 경합 조건을 방지하는 데 중요한 동기화 메커니즘을 제공합니다. 예를 들어, waitSync는 여러 작업자 간의 공유 버퍼에 대한 액세스를 동기화하는 데 사용될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e아직 예제가 제공되지 않아 문서가 아직 작성 중이므로 어떻게 구현될지 보여드릴 수 없습니다. 그러나 기존 Atomics 메서드를 기반으로 가정을 할 수 있습니다. 다음과 같습니다...\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// sharedArray가 SharedArrayBuffer임을 가정합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sharedArray = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInt32Array\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSharedArrayBuffer\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e));\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eperformSynchronizedOperation\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eindex, value\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// waitSync 메서드는 특정 조건이 충족될 때까지 실행을 차단합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 예를 들어, 지정된 인덱스의 값이 0이 아닌 값이 될 때까지 기다릴 수 있습니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eAtomics\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ewaitSync\u003c/span\u003e(sharedArray, index, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 공유 메모리에서 작업 수행\u003c/span\u003e\n    sharedArray[index] = value;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 다른 스레드나 작업자에게 인덱스의 값이 업데이트되었음을 알립니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eAtomics\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enotify\u003c/span\u003e(sharedArray, index, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 웹 워커나 다른 스레드에서\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eperformSynchronizedOperation\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e정규 표현식의 v 플래그와 집합 표기법 + 문자열 속성\u003c/h1\u003e\n\u003cp\u003e자바스크립트의 정규 표현식에 대한 이 개선 사항은 더 복잡한 패턴 매칭과 문자열 조작을 가능하게 합니다. 'v' 플래그와 집합 표기법을 사용하면 더 정확하고 표현력 있는 정규식 패턴을 생성할 수 있습니다. 예를 들어, 이 기능을 사용하여 특정 유니코드 속성을 가진 문자 집합을 일치시킬 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 차이/빼기\u003c/span\u003e\n[A--B]\n\n\u003cspan class=\"hljs-comment\"\u003e// 교집합\u003c/span\u003e\n[A\u0026#x26;\u0026#x26;B]\n\n\u003cspan class=\"hljs-comment\"\u003e// 중첩된 문자 클래스\u003c/span\u003e\n[A--[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e]]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA와 B는 문자 클래스(예: [a-z])나 속성 이스케이프를 나타냅니다. 제안에 대한 설명적인 예제와 FAQ을 확인할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e최상위 await\u003c/h1\u003e\n\u003cp\u003e이 \"Just Do It\" 기능은 await 키워드가 비동기 함수 외부에서도 사용되도록 허용하여 비동기 코드를 더 쉽게 작성하고 읽을 수 있게 합니다. 예를 들어, 모듈의 최상위 수준에서 프로미스를 직접 await할 수 있어 모듈 가져오기 또는 데이터 비동기로 가져오는 코드를 간소화할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 최상위 await 사용\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e();\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e정말로 무겁고 복잡한 async/await 구조에 새로운 바람을 불어넣어 줍니다!\u003c/p\u003e\n\u003ch1\u003e파이프라인 연산자\u003c/h1\u003e\n\u003cp\u003e파이프라인 연산자(\u003ccode\u003e|\u003c/code\u003e)는 여러 함수 호출로 이루어진 코드의 가독성을 향상시킵니다. 이는 함수형 스타일 구문을 허용하여 식의 결과를 다음 함수의 인자로 전달할 수 있게 합니다. 예를 들어, 중첩된 함수 호출을 명확한 연산 순서로 재구성할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 파이프라인 연산자 없이\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e calculatedValue = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eceil\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epow\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, -\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e), \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e));\n\n\u003cspan class=\"hljs-comment\"\u003e// 파이프라인 연산자 사용 시\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e calculatedValue = -\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\n  |\u003e (\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003en\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, n)) \u003cspan class=\"hljs-comment\"\u003e// Math.max 대체\u003c/span\u003e\n  |\u003e (\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003en\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epow\u003c/span\u003e(n, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)) \u003cspan class=\"hljs-comment\"\u003e// Math.pow 대체\u003c/span\u003e\n  |\u003e \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eceil\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// Math.ceil 사용\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMath.max 함수는 숫자가 음수가 아닌지 확인합니다.\u003c/li\u003e\n\u003cli\u003eMath.pow 함수는 세제곱근을 계산합니다 (1/3의 거듭제곱).\u003c/li\u003e\n\u003cli\u003eMath.ceil 함수는 숫자를 가장 가까운 정수로 올립니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e파이프라인 연산자(\u003ccode\u003e|\u003c/code\u003e)는 이러한 작업들을 연쇄적으로 쉽게 할 수 있게 해주어 코드를 더 읽기 쉽게 만듭니다.\u003c/p\u003e\n\u003cp\u003e이제 다음은 데이터 변환에 파이프라인 연산자가 얼마나 유용한지 보여주는 예제입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 파이프라인 연산자는 일련의 함수들을 명확하고 간결한 방식으로 연쇄적으로 적용하여 복잡한 데이터 조작을 간단하게 합니다.\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e numbers = [\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e];\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e processedNumbers = numbers\n  |\u003e (\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e_\u003c/span\u003e =\u003e\u003c/span\u003e _.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003en\u003c/span\u003e =\u003e\u003c/span\u003e n / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)) \u003cspan class=\"hljs-comment\"\u003e// 각 숫자를 절반으로 나누기\u003c/span\u003e\n  |\u003e (\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003e_\u003c/span\u003e =\u003e\u003c/span\u003e _.\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003en\u003c/span\u003e =\u003e\u003c/span\u003e n \u003e \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 10보다 작거나 같은 숫자 제외하기\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(processedNumbers); \u003cspan class=\"hljs-comment\"\u003e// [15, 20, 25]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emap 함수는 배열 내의 각 숫자를 절반으로 나눕니다.\u003c/li\u003e\n\u003cli\u003efilter 함수는 10 이하인 숫자를 제거합니다.\u003c/li\u003e\n\u003cli\u003e파이프라인 연산자 (|`)를 사용하여 이러한 변환을 우아하게 연결하여 코드 가독성을 향상시킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e기억하세요, 파이프라인 연산자는 여전히 \"Draft\" 상태인 TC39의 단계 2에 있습니다.\u003c/p\u003e\n\u003ch1\u003e레코드 및 튜플\u003c/h1\u003e\n\u003cp\u003e이 변하지 않는 데이터 구조들은 각각 객체와 배열과 유사하지만 생성 후 수정할 수 없습니다. 예를 들어, 레코드나 튜플을 업데이트하면 새로운 인스턴스가 생성됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 불변한 레코드 생성\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userProfile = #{\n  \u003cspan class=\"hljs-attr\"\u003eusername\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"IgorKomolov\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e39\u003c/span\u003e,\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// 불변한 튜플 생성\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e numberSequence = #[\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e];\n\n\u003cspan class=\"hljs-comment\"\u003e// 이러한 구조를 업데이트하면 새로운 인스턴스가 생성됩니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e updatedProfile = userProfile.\u003cspan class=\"hljs-title function_\"\u003ewith\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e40\u003c/span\u003e});\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(updatedProfile); \u003cspan class=\"hljs-comment\"\u003e// #{ username: \"IgorKomolov\", age: 40 }\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(userProfile); \u003cspan class=\"hljs-comment\"\u003e// #{ username: \"IgorKomolov\", age: 39 } (변하지 않음)\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newNumberSequence = numberSequence.\u003cspan class=\"hljs-title function_\"\u003ewith\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(newNumberSequence); \u003cspan class=\"hljs-comment\"\u003e// #[10, 25, 30]\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(numberSequence); \u003cspan class=\"hljs-comment\"\u003e// #[10, 20, 30] (변하지 않음)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e레코드는 객체와 유사하게 동작하고, 튜플은 배열과 유사합니다. 그러나 그들의 핵심 특징은 불변성입니다.\u003c/p\u003e\n\u003cp\u003e레코드와 튜플은 특정 상황에서 성능을 향상시키고 코드베이스에서 불변성을 강제할 수 있습니다. 이들은 제안의 2단계에 있으며 아직 JavaScript 엔진에 구현되지는 않았지만, 개발자들은 Babel과 같은 트랜스파일러를 사용하여 이들을 실험할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e데코레이터\u003c/h1\u003e\n\u003cp\u003e이제 이게 가능해졌어요, TypeScript에 감사해요! 클래스, 메서드, 속성 또는 매개변수의 동작을 수정하거나 확장하는 기능을 제공합니다. 주석 추가, 로깅 또는 선언적 방식으로 동작을 수정하는 데 특히 유용합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 메서드 실행을 추적하기 위해 데코레이터 적용\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSampleClass\u003c/span\u003e {\n  @trackExecution\n  \u003cspan class=\"hljs-title function_\"\u003eperformAction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eparameter1, parameter2\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 메서드 구현 내용이 여기에 있습니다\u003c/span\u003e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSampleClass는 정의되는 클래스입니다.\u003c/li\u003e\n\u003cli\u003e@trackExecution은 performAction 메서드 호출을 기록하거나 추적하기 위해 사용되는 데코레이터입니다.\u003c/li\u003e\n\u003cli\u003eperformAction은 SampleClass 내의 메서드로, 두 개의 매개변수(parameter1 및 parameter2)를 사용합니다. 이 데코레이터는 이 메서드에 대한 각 호출을 기록하거나 추적합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e패턴 매칭\u003c/h1\u003e\n\u003cp\u003e이 기능은 복잡한 데이터 구조의 비구조화 및 일치에 대한 간결한 구문을 소개하여 코드 가독성을 높이고 보일러플레이트를 줄입니다.\u003c/p\u003e\n\u003cp\u003e(연구 중) 더 많은 정보가 곧 제공될 예정이니 나중에 다시 확인해주세요!\u003c/p\u003e\n\u003ch1\u003eTemporal\u003c/h1\u003e\n\u003cp\u003e잠시만요! 엄청 오래전에 기획되었지만, 업데이트된 Temporal은 JavaScript를 위해 제안된 최신 및 포괄적인 날짜 및 시간 API로, 현재 Stage 3에 있어요. 기존 Date 객체의 제한 사항과 복잡성 중 많은 부분을 해결하기 위해 설계되었어요. 여기 ES2024에서 Temporal을 사용하는 몇 가지 예시가 있어요:\u003c/p\u003e\n\u003cp\u003e이 객체는 현재 시간에 대한 Temporal 값을 생성하기 위한 여러 팩토리 메서드를 제공해요.\u003c/p\u003e\n\u003ch2\u003eUTC에서 현재 시간 가져오기\u003c/h2\u003e\n\u003cp\u003eTemporal.Now.instant().toString()\u003c/p\u003e\n\u003ch2\u003e특정 시간대에서 현재 존재하는 날짜 및 시간 가져오기\u003c/h2\u003e\n\u003cp\u003eTemporal.Now.zonedDateTimeISO(\u003ccode\u003eAsia/Shanghai\u003c/code\u003e).toString()\u003c/p\u003e\n\u003ch2\u003eISO 형식의 현재 플레인 날짜 및 시간 가져오기\u003c/h2\u003e\n\u003cp\u003e표를 아래와 같이 Markdown 형식으로 변경해주세요.\u003c/p\u003e\n\u003cp\u003eTemporal.Now.plainDateTimeISO().toString()\u003c/p\u003e\n\u003ch2\u003e현재 plain 시간을 ISO 형식으로 얻기\u003c/h2\u003e\n\u003cp\u003eTemporal.Now.plainTimeISO().toString().\u003c/p\u003e\n\u003ch2\u003eZonedDateTime.prototype의 속성\u003c/h2\u003e\n\u003cp\u003eTemporal의 ZonedDateTime 클래스에는 날짜 및 시간 정보를 자세히 조작하고 검색할 수 있는 여러 속성과 메서드가 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이러한 속성 및 메서드에는 달력, 시간대, 연도, 월, 일, 시간, 분, 초 및 나노초를 반환하는 getter가 포함됩니다.\u003c/li\u003e\n\u003cli\u003e.with(), .add(), .subtract(), .until(), .since(), .round()과 같은 메서드도 포함되어 있어, 지역 시간 값을 다루는 데 풍부한 기능을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eTemporal의 Plain Time 클래스\u003c/h2\u003e\n\u003cp\u003eTemporal은 시간대 없이 시간을 나타내는 추상 클래스인 \"plain\" 클래스를 소개합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이러한 클래스에는 PlainDateTime, PlainDate 및 PlainTime이 포함됩니다.\u003c/li\u003e\n\u003cli\u003e이들은 특정 시간대에서 벽시간을 표시하거나 1984년 6월의 첫 번째 화요일을 찾는 것과 같이 시간대가 중요하지 않은 시간 계산에 유용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 예시들은 ES2024의 Temporal이 JavaScript에서의 날짜 및 시간 처리를 간단하고 향상시킬 수 있다는 것을 보여줍니다. 개발자들에게 더 견고하고 다재다능한 도구를 제공합니다.\u003c/p\u003e\n\u003cp\u003e지금 사용해보고 싶으신가요? 문제없어요!\u003c/p\u003e\n\u003cp\u003e제안을 가져오거나 Babel Polyfil을 사용해보세요. 이렇게 제안을 가져오는 방법이 있습니다...\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//네 맞아요, 제안서도 가져올 수 있어요 :)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eTemporal\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@std/proposal-temporal'\u003c/span\u003e;\n\n\n\u003cspan class=\"hljs-comment\"\u003e//기본 연산\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e now = \u003cspan class=\"hljs-title class_\"\u003eTemporal\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNow\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ezonedDateTimeISO\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'America/New_York'\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(now.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e());\n\n\u003cspan class=\"hljs-comment\"\u003e//조작 및 비교\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e date = \u003cspan class=\"hljs-title class_\"\u003eTemporal\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePlainDate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'2024-01-01'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newDate = date.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003edays\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e });\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(newDate.\u003cspan class=\"hljs-title function_\"\u003etoString\u003c/span\u003e()); \u003cspan class=\"hljs-comment\"\u003e// 결과 '2024-01-11'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e에르고노믹 브랜드 체크\u003c/h1\u003e\n\u003cp\u003e사용자 지정 클래스 및 데이터 구조에서 객체 타입을 확인하는 것을 단순화하여 유형 검증을 더 직관적이고 실수를 줄입니다. 이제 부모 복제본은 보지 않을 거예요!\u003c/p\u003e\n\u003ch2\u003e전통적인 방법 (ES2024 이전)\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e {\n    #author;\n\n    \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eauthor\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#author = author;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehasAuthorField\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n            obj.#author; \u003cspan class=\"hljs-comment\"\u003e// 비공개 필드에 접근 시도\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 접근 성공\u003c/span\u003e\n        } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTypeError\u003c/span\u003e) {\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 접근 실패, 필드가 존재하지 않음\u003c/span\u003e\n            }\n            \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e err; \u003cspan class=\"hljs-comment\"\u003e// 다른 오류는 다시 던짐\u003c/span\u003e\n        }\n    }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 사용 예시:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myBook = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Igor Komolov\"\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasAuthorField\u003c/span\u003e(myBook)); \u003cspan class=\"hljs-comment\"\u003e// 예상 결과: true\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e otherObject = {};\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBook\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasAuthorField\u003c/span\u003e(otherObject)); \u003cspan class=\"hljs-comment\"\u003e// 예상 결과: false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e새로운 ES2024 방식\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBookES2024\u003c/span\u003e {\n    #author;\n\n    \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eauthor\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.#author = author;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehasAuthorField\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e #author \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e obj; \u003cspan class=\"hljs-comment\"\u003e// 비공개 필드를 확인하는 새로운 ES2024 구문\u003c/span\u003e\n    }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 사용 예시:\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myBook2024 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBookES2024\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Igor Komolov\"\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBookES2024\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasAuthorField\u003c/span\u003e(myBook2024)); \u003cspan class=\"hljs-comment\"\u003e// 예상 결과: true\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e otherObject2024 = {};\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBookES2024\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasAuthorField\u003c/span\u003e(otherObject2024)); \u003cspan class=\"hljs-comment\"\u003e// 예상 결과: false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서 Book 클래스는 전통적인 방식을 보여주고, BookES2024는 새로운 ES2024 구문을 사용합니다. hasAuthorField 정적 메소드는 #author 비공개 필드가 객체에 존재하는지 확인하며, 각 클래스에서 서로 다른 접근 방식을 사용합니다.\u003c/p\u003e\n\u003ch1\u003eRealms API\u003c/h1\u003e\n\u003cp\u003e이 API는 격리된 JavaScript 환경을 만드는 메커니즘을 제공합니다. 안전한 코드 실행 및 샌드박싱에 유용하며, 제어된 격리된 컨텍스트에서 코드를 실행할 수 있게 합니다. 게다가, 이름도 너무 멋져요!\u003c/p\u003e\n\u003ch2\u003eRealm 생성 및 간단한 표현식 평가\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e igorsRealm = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRealm\u003c/span\u003e();\nigorsRealm.evaluate(\u003cspan class=\"hljs-string\"\u003e'3 * 5'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Igor의 영역에서 15로 계산됨\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e다른 영역 간 심볼 공유\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e igorsRealm = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRealm\u003c/span\u003e();\n\u003cspan class=\"hljs-title class_\"\u003eSymbol\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'y'\u003c/span\u003e) === igorsRealm.evaluate(\u003cspan class=\"hljs-string\"\u003e'Symbol.for(\"y\")'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// true 반환, 공유된 심볼 'y'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e자동 래핑된 함수 사용\u003c/h2\u003e\n\u003cp\u003e한 영역에서 다른 영역으로 전송된 호출 가능한 객체의 경우 대상 영역에서 래핑된 함수 이국적 객체가 생성됩니다. 호출되는 경우 래핑된 함수는 원래 영역의 연결된 함수로 호출을 연결합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e igorsRealm = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRealm\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e doubleFunction = igorsRealm.evaluate(\u003cspan class=\"hljs-string\"\u003e'num =\u003e num * 2'\u003c/span\u003e);\n\u003cspan class=\"hljs-title function_\"\u003edoubleFunction\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 결과: 20\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e콜백을 이용한 함수 평가\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e igorsRealm = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRealm\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e processNumber = igorsRealm.evaluate(\u003cspan class=\"hljs-string\"\u003e'(number, callback) =\u003e callback(number + 5)'\u003c/span\u003e);\n\u003cspan class=\"hljs-title function_\"\u003eprocessNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, (\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresult\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(result))); \u003cspan class=\"hljs-comment\"\u003e// 로그: 10 (5 + 5)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e제한된 전역 컨텍스트 접근\u003c/h2\u003e\n\u003cp\u003e글로벌 객체인 globalThis, 배열 또는 Object.prototype에 realm.evaluate를 통해 직접 액세스하는 것은 TypeError를 발생시킵니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e igorsRealm = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRealm\u003c/span\u003e();\nigorsRealm.evaluate(\u003cspan class=\"hljs-string\"\u003e'this'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// TypeError 발생\u003c/span\u003e\nigorsRealm.evaluate(\u003cspan class=\"hljs-string\"\u003e'new Array()'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// TypeError 발생\u003c/span\u003e\nigorsRealm.evaluate(\u003cspan class=\"hljs-string\"\u003e'Object.keys({})'\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// TypeError 발생\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eES2024에서 예정된 새로운 기능들은 자바스크립트 코딩에 접근하는 방식을 혁신할 것으로 예상됩니다. 이러한 향상들은 코드 가독성과 효율성을 향상시키는 것뿐만 아니라 불변 데이터 구조와 고급 패턴 매칭과 같은 강력한 새로운 패러다임을 소개하기도 합니다. 이러한 기능들이 제안에서 구현으로 이동할 때, 개발자들이 더 깨끗하고 유지보수 가능하며 표현력이 풍부한 자바스크립트 코드를 작성할 수 있는 새로운 가능성을 열어줍니다. 이러한 진보로운 발전과 함께 자바스크립트의 미래는 밝아보이며, 현대 웹 개발의 중요한 요충지가 된 언어의 지속적인 발전을 시사합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-JavaScriptWhatsnewwithECMAScript2024ES15InDepthGuide"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>