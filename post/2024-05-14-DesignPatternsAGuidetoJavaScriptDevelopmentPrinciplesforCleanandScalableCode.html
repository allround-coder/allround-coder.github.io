<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode" data-gatsby-head="true"/><meta name="twitter:title" content="디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 15:59" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-742e6c91a18eb160.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_buildManifest.js" defer=""></script><script src="/_next/static/6w6Yg3qJxLtqeXNguENru/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png" alt="이미지"></p>
<h2>소프트웨어 개발 원칙</h2>
<h1>소개 — JavaScript 디자인 패턴</h1>
<p><img src="/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_1.png" alt="이미지"></p>
<h2>디자인 패턴의 본질</h2>
<p>안녕하세요 여러분! 저는 시니어 소프트웨어 엔지니어로 활동한 지 오랜 시간이 되었지만, 깔끔하고 확장 가능한 코드를 작성하는 데 있어 단순히 무엇을 만드냐 보다는 코드의 구조가 중요하다는 것을 깨닫게 되었습니다. 여기서 디자인 패턴이 중요한 역할을 한다는 사실을 발견했습니다.</p>
<h2>디자인 패턴 — 무엇인가요?</h2>
<p>디자인 패턴은 소프트웨어 개발 중에 흔히 발생하는 문제에 대한 검증된 해결책으로, 코드 구조를 안내하는 템플릿 역할을 하여 우리가 코드를 구조화하는 데 도움을 줍니다. 디자인 패턴을 사용하면 더 읽기 쉽고 유연하며 유지보수하기 쉬운 코드를 작성하는 것이 쉬워지며, 개발자들이 더 효과적으로 소통할 수 있는 일종의 공통 언어를 제공하기도 합니다.</p>
<h2>자바스크립트 디자인 패턴의 힘</h2>
<p>자바스크립트는 다양한 프로그래밍 스타일을 지원하여 다재다능하며, 이는 중요한 장점이지만 동시에 언어를 혼란스럽게 만들 수도 있습니다. 그러나 디자인 패턴은 코드를 조직화하고 효율적으로 유지할 수 있는 방법을 제공합니다.</p>
<p>다음 섹션에서는 자바스크립트 디자인 패턴을 더 깊게 탐색하며, 생성, 구조 및 행동 패턴을 탐구하고 각 유형에 대한 실용적인 예제를 제공하며 장단점 및 잠재적인 위험을 논의할 것입니다.</p>
<h1>자바스크립트 디자인 패턴 유형 탐색</h1>
<p><img src="/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_2.png" alt="image"></p>
<h2>생성 디자인 패턴: 객체 생성</h2>
<p>JavaScript에서 객체는 핵심 기능이며 종종 유사한 특성을 갖는 개체 또는 것들을 나타내는 데 사용됩니다. 이러한 객체의 생성을 조직화하기 위해 생성 디자인 패턴을 사용합니다.</p>
<p>생성 패턴은 객체의 생성, 구성 및 표현 방식과는 독립적인 시스템을 만들어 인스턴스화 프로세스를 추상화하는 데 도움을 줍니다.</p>
<p>공장 패턴</p>
<p>공장 패턴은 객체를 생성하는 방법을 제공하지만 하위 클래스가 생성될 객체의 유형을 변경할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CarFactory</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">createCar</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) {
    <span class="hljs-keyword">let</span> car;
    <span class="hljs-keyword">if</span> (model === <span class="hljs-string">'세단'</span>) {
      car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sedan</span>();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (model === <span class="hljs-string">'SUV'</span>) {
      car = <span class="hljs-keyword">new</span> <span class="hljs-title function_">SUV</span>();
    }
    <span class="hljs-keyword">return</span> car;
  };
}
</code></pre>
<p>싱글톤 패턴</p>
<p>싱글톤 패턴은 클래스가 여러 객체를 생성하는 것을 제한하며, 특정 동작을 제어해야 할 때 유용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Singleton</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> instance;
 
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createInstance</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(<span class="hljs-string">"I am the instance"</span>);
  }
 
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">getInstance</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">if</span> (!instance) {
        instance = <span class="hljs-title function_">createInstance</span>();
      }
      <span class="hljs-keyword">return</span> instance;
    }
  };
})();
</code></pre>
<p>빌더 패턴</p>
<p>빌더 패턴은 클라이언트가 타입과 내용에만 집중해 복잡한 객체를 구축할 수 있도록 하고, 객체를 조립하는 작업을 관리합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">CarBuilder</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">step1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();
  };

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">step2</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span>.<span class="hljs-title function_">addParts</span>();
  };

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">get</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span>;
  };
}
</code></pre>
<h2>구조적 디자인 패턴: 코드 모양을 만드는 방법</h2>
<p>구조적 패턴은 서로 다른 클래스와 객체를 조직화하여 더 큰 구조를 형성하는 것에 관한 것이며 시스템의 한 부분이 변경될 때 전체 시스템이 함께 바뀌지 않도록 보장합니다.</p>
<p>어댑터 패턴```</p>
<p>어댑터 패턴은 호환되지 않는 인터페이스를 가진 클래스가 함께 작동할 수 있도록 객체 주변에 래핑하고 해당 객체와 상호 작용하는 표준 인터페이스를 노출하는 것을 가능하게 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OldCalculator</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">term1, term2, operation</span>) {
      <span class="hljs-keyword">switch</span> (operation) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'add'</span>:
          <span class="hljs-keyword">return</span> term1 + term2;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'sub'</span>:
          <span class="hljs-keyword">return</span> term1 - term2;
        <span class="hljs-attr">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title class_">NaN</span>;
      }
    };
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NewCalculator</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">add</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">term1, term2</span>) {
      <span class="hljs-keyword">return</span> term1 + term2;
    };
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sub</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">term1, term2</span>) {
      <span class="hljs-keyword">return</span> term1 - term2;
    };
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">CalculatorAdapter</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> newCalc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewCalculator</span>();
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">operations</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">term1, term2, operation</span>) {
      <span class="hljs-keyword">switch</span> (operation) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'add'</span>:
          <span class="hljs-keyword">return</span> newCalc.<span class="hljs-title function_">add</span>(term1, term2);
        <span class="hljs-keyword">case</span> <span class="hljs-string">'sub'</span>:
          <span class="hljs-keyword">return</span> newCalc.<span class="hljs-title function_">sub</span>(term1, term2);
        <span class="hljs-attr">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title class_">NaN</span>;
      }
    };
  }
}
</code></pre>
<p>데코레이터 패턴</p>
<p>데코레이터 패턴은 동일한 클래스의 다른 객체들의 행동에 영향을 미치지 않고 특정 개체에 정적 또는 동적으로 추가할 동작을 설명합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Car</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-title class_">Car</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">DecoratedCar</span>(<span class="hljs-params">car, color, price</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span> = car;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price;
}

<span class="hljs-title class_">DecoratedCar</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">car</span>.<span class="hljs-title function_">getName</span>() + <span class="hljs-string">' has color '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> + <span class="hljs-string">' and price '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span>;
};
</code></pre>
<p>프록시 패턴</p>
<p>프록시 패턴은 원본 객체에 대한 액세스를 제어하기 위해 대리자 또는 플레이스홀더 객체를 제공합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">NetworkAccess</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">connect</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'네트워크에 연결되었습니다.'</span>);
  };
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">NetworkProxy</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">network</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetworkAccess</span>();
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">connect</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'네트워크 프록시를 사용합니다.'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">network</span>.<span class="hljs-title function_">connect</span>();
  };
}
</code></pre>
<h2>행동 디자인 패턴: 객체 협업 관리</h2>
<p>행동 디자인 패턴은 객체 간 통신에 관심을 가지며, 객체들이 작동하고 책임을 수행하는 방식에 대해 다룹니다. 대부분의 경우 객체 간 통신을 유연하게 처리할 수 있도록 돕습니다.</p>
<p>옵저버 패턴</p>
<p>옵저버 패턴은 객체 간의 일대다 종속성을 정의하여 한 객체의 상태가 변경되면 해당 객체에 의존하는 모든 객체가 자동으로 통지되고 업데이트됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];
    }

    <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">observer</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer);
    }

    <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params">observer</span>) {
        <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">indexOf</span>(observer);
        <span class="hljs-keyword">if</span> (index > -<span class="hljs-number">1</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
        }
    }

    <span class="hljs-title function_">notifyAll</span>(<span class="hljs-params">data</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-property">length</span>; i++) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>[i].<span class="hljs-title function_">notify</span>(data);
        }
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> {
    <span class="hljs-title function_">notify</span>(<span class="hljs-params">data</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Observer received: <span class="hljs-subst">${data}</span>`</span>);
    }
}
</code></pre>
<p>전략 패턴</p>
<p>전략 패턴은 클라이언트가 인식하지 못하고 메서드(전략)를 런타임에 다른 메서드로 교체할 수 있게 하는 것을 가능하게 합니다. 이것은 교환 가능한 알고리즘 그룹입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shipping</span> {
    <span class="hljs-title function_">setStrategy</span>(<span class="hljs-params">strategy</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">strategy</span> = strategy;
    }

    <span class="hljs-title function_">calculate</span>(<span class="hljs-params">parcel</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">strategy</span>.<span class="hljs-title function_">calculate</span>(parcel);
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UPS</span> {
    <span class="hljs-title function_">calculate</span>(<span class="hljs-params">parcel</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`$<span class="hljs-subst">${parcel.weight * <span class="hljs-number">1.75</span>}</span>`</span>;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">FedEx</span> {
    <span class="hljs-title function_">calculate</span>(<span class="hljs-params">parcel</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`$<span class="hljs-subst">${parcel.weight * <span class="hljs-number">2.45</span>}</span>`</span>;
    }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">USPS</span> {
    <span class="hljs-title function_">calculate</span>(<span class="hljs-params">parcel</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`$<span class="hljs-subst">${parcel.weight * <span class="hljs-number">1.25</span>}</span>`</span>;
    }
}
</code></pre>
<h2>커맨드 패턴</h2>
<p>커맨드 패턴은 요청의 구체적인 내용을 알지 못한 채로 작업을 객체에 캡슐화하는 기능을 제공합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Switch</span> {
  <span class="hljs-title function_">execute</span>(<span class="hljs-params">command</span>) {
    command.<span class="hljs-title function_">execute</span>();
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOnCommand</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">light</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">light</span> = light;
  }

  <span class="hljs-title function_">execute</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">light</span>.<span class="hljs-title function_">turnOn</span>();
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span> {
  <span class="hljs-title function_">turnOn</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'불이 켜졌습니다'</span>);
  }

  <span class="hljs-title function_">turnOff</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'불이 꺼졌습니다'</span>);
  }
}
</code></pre>
<p>다음 섹션에서 이러한 패턴이 실제 JavaScript 애플리케이션에서 어떻게 사용되며 깔끔하고 확장 가능한 코드를 어떻게 이끌어내는지 알아보겠습니다.</p>
<h1>JavaScript 디자인 패턴의 실제 응용</h1>
<p><img src="/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_3.png" alt="Design Patterns"></p>
<p>디자인 패턴은 강력한 도구입니다. 하지만 실제 상황에서 그들의 응용을 통해 우리는 그들의 힘을 진정으로 이해할 수 있고, 이를 보여주기 위해 우리가 논의한 패턴 중 일부가 실제 상황에서 어떻게 활용될 수 있는지 살펴봅시다.</p>
<h2>사용자 프로필 생성</h2>
<p>사회적 미디어 사이트를 위한 사용자 프로필 시스템을 만드는 작업이 있다고 상상해보세요: Factory 패턴을 사용하면 미리 정의된 템플릿을 사용하여 프로필을 만들어 프로세스를 간소화할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserFactory</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">createUser</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>) {
    <span class="hljs-keyword">let</span> user;

    <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'개인'</span>) {
      user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonalUser</span>();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'비즈니스'</span>) {
      user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessUser</span>();
    }

    user.<span class="hljs-property">type</span> = type;
    user.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> + <span class="hljs-string">": 프로필이 생성되었습니다"</span>);
    }
    <span class="hljs-keyword">return</span> user;
  }
}
</code></pre>
<h2>제3자 API와의 통합</h2>
<p>다른 상황에서는 응용 프로그램에 제3자 API를 통합해야 할 필요가 있다고 상상해보세요. 그러나 이 API의 인터페이스가 응용 프로그램의 기존 시스템과 일치하지 않는 경우: Adapter 패턴을 사용하여 기존 코드베이스를 변경하지 않고 API를 응용 프로그램과 호환되도록 만들 수 있습니다.</p>
<pre><code class="hljs language-md"><span class="hljs-code">```js
class ThirdPartyAPI {
  constructor() {
    this.specificRequest = function() {
      return "Third-party API response";
    };
  }
}

class Adapter {
  constructor(thirdPartyAPI) {
    this.request = function() {
      return thirdPartyAPI.specificRequest();
    };
  }
}

// Using the Adapter
const thirdPartyAPI = new ThirdPartyAPI();
const adapter = new Adapter(thirdPartyAPI);
adapter.request();
</span></code></pre>
<h2>사용자 프로필에 기능 추가하기</h2>
<p>Decorator Pattern은 사용자 프로필에 프리미엄 뱃지나 사용자 정의 테마와 같은 새로운 기능을 추가하고 원래의 사용자 객체를 변경하지 않고 싶을 때 적용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">User</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-title class_">User</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">DecoratedUser</span>(<span class="hljs-params">user, badge, theme</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = user;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">badge</span> = badge;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">theme</span> = theme;
}

<span class="hljs-title class_">DecoratedUser</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.user.getName()}</span>, Badge: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.badge}</span>, Theme: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.theme}</span>`</span>;
};
</code></pre>
<h2>게시물과 사용자 상호작용</h2>
<p>옵저버 패턴은 사용자가 게시물과 상호작용할 수 있는 시스템을 구현해야 할 때 유용합니다. 사용자가 게시물을 좋아하거나 댓글을 달 수 있는 경우, 각 게시물이 주제로 작용하고 다른 사용자가 상호작용을 통지받는 관찰자로 작용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Post</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];
  }

  <span class="hljs-title function_">like</span>(<span class="hljs-params">user</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">notifyAll</span>(<span class="hljs-string">`게시물이 <span class="hljs-subst">${user}</span>님에 의해 좋아요!`</span>);
  }

  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">observer</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer);
  }

  <span class="hljs-title function_">notifyAll</span>(<span class="hljs-params">message</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> observer <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>) {
      observer.<span class="hljs-title function_">notify</span>(message);
    }
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-title function_">notify</span>(<span class="hljs-params">message</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`사용자에게 알림: <span class="hljs-subst">${message}</span>`</span>);
  }
}
</code></pre>
<h2>다양한 배송 방법</h2>
<p>이제 전자 상거래 애플리케이션이 다른 배송 방법을 지원해야 하는 경우를 가정해 보겠습니다: 각 배송 방법을 별도의 전략으로 구현할 수 있기 때문에 Strategy Pattern은 이 경우에 완벽합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shipping</span> {
  <span class="hljs-title function_">setStrategy</span>(<span class="hljs-params">strategy</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">strategy</span> = strategy;
  }

  <span class="hljs-title function_">calculate</span>(<span class="hljs-params">parcel</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">strategy</span>.<span class="hljs-title function_">calculate</span>(parcel);
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UPS</span> {
  <span class="hljs-title function_">calculate</span>(<span class="hljs-params">parcel</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`$<span class="hljs-subst">${parcel.weight * <span class="hljs-number">1.75</span>}</span>`</span>;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">FedEx</span> {
  <span class="hljs-title function_">calculate</span>(<span class="hljs-params">parcel</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`$<span class="hljs-subst">${parcel.weight * <span class="hljs-number">2.45</span>}</span>`</span>;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">USPS</span> {
  <span class="hljs-title function_">calculate</span>(<span class="hljs-params">parcel</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`$<span class="hljs-subst">${parcel.weight * <span class="hljs-number">1.25</span>}</span>`</span>;
  }
}
</code></pre>
<h2>웹사이트 테마 사용자 정의</h2>
<p>사용자가 테마를 사용자 정의할 수 있는 웹사이트가 있다고 상상해보세요. 여러 테마 객체를 만들기 위해 Factory Pattern을 사용하고, 그 테마에 추가 기능을 추가하기 위해 Decorator Pattern을 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 팩토리 패턴</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeFactory</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">createTheme</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>) {
    <span class="hljs-keyword">let</span> theme;

    <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'Dark'</span>) {
      theme = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DarkTheme</span>();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'Light'</span>) {
      theme = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LightTheme</span>();
    }

    theme.<span class="hljs-property">type</span> = type;
    <span class="hljs-keyword">return</span> theme;
  }
}

<span class="hljs-comment">// 데코레이터 패턴</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">DecoratedTheme</span>(<span class="hljs-params">theme, color</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">theme</span> = theme;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;
}

<span class="hljs-title class_">DecoratedTheme</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">theme</span>.<span class="hljs-title function_">getName</span>() + <span class="hljs-string">' in '</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> + <span class="hljs-string">' color'</span>;
};
</code></pre>
<h2>할인 이벤트가 적용된 전자 상거래 사이트</h2>
<p>전자 상거래 사이트를 상상해보세요. 여러분은 제품에 특별 할인 이벤트를 적용하는 시스템을 구현하려고 합니다. 여기서는 다양한 종류의 특별 할인을 나타내기 위해 전략 패턴을 사용하고 관심 있는 제품에 특별 할인이 적용될 때 고객들에게 알리기 위해 옵서버 패턴을 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 전략 패턴</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialOffer</span> {
  <span class="hljs-title function_">apply</span>(<span class="hljs-params">product</span>) {
    <span class="hljs-comment">// abstract method</span>
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackFridayOffer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SpecialOffer</span> {
  <span class="hljs-title function_">apply</span>(<span class="hljs-params">product</span>) {
    product.<span class="hljs-property">price</span> *= <span class="hljs-number">0.8</span>;  <span class="hljs-comment">// 20% 할인</span>
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ChristmasOffer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">SpecialOffer</span> {
  <span class="hljs-title function_">apply</span>(<span class="hljs-params">product</span>) {
    product.<span class="hljs-property">price</span> *= <span class="hljs-number">0.85</span>;  <span class="hljs-comment">// 15% 할인</span>
  }
}

<span class="hljs-comment">// 옵서버 패턴</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">price</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span> = [];
  }

  <span class="hljs-title function_">setPrice</span>(<span class="hljs-params">price</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">price</span> = price;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">notifyAll</span>();
  }

  <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">observer</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>.<span class="hljs-title function_">push</span>(observer);
  }

  <span class="hljs-title function_">notifyAll</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> observer <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">observers</span>) {
      observer.<span class="hljs-title function_">notify</span>(<span class="hljs-variable language_">this</span>);
    }
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> {
  <span class="hljs-title function_">notify</span>(<span class="hljs-params">product</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`제품 가격이 $<span class="hljs-subst">${product.price}</span>로 업데이트되었습니다.`</span>);
  }
}
</code></pre>
<h2>성능 모니터링 시스템</h2>
<p>알겠어요, 그럼 어떤 응용 프로그램의 다른 모듈의 성능을 모니터링하는 시스템을 구축한다고 생각해봅시다. 이러한 모듈은 Factory Pattern을 사용하여 나타낼 수 있으며 이러한 모듈의 성능을 관찰하고 문제를 보고하려면 Proxy Pattern을 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Factory Pattern</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ModuleFactory</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">createModule</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>) {
    <span class="hljs-keyword">let</span> <span class="hljs-variable language_">module</span>;

    <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'Database'</span>) {
      <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatabaseModule</span>();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'Network'</span>) {
      <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetworkModule</span>();
    }

    <span class="hljs-variable language_">module</span>.<span class="hljs-property">type</span> = type;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>;
  }
}

<span class="hljs-comment">// Proxy Pattern</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PerformanceProxy</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">module</span> = <span class="hljs-variable language_">module</span>;
  }

  <span class="hljs-title function_">monitor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'성능 모니터링 중...'</span>);
    <span class="hljs-comment">// 호출을 원래 객체로 위임합니다.</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">module</span>.<span class="hljs-title function_">monitor</span>();
  }
}
</code></pre>
<h2>채팅 애플리케이션</h2>
<p>매우 흔한 채팅 애플리케이션에서는 ChatRoom 클래스의 인스턴스가 하나만 있는지를 보장하기 위해 싱글톤 패턴을 사용할 수 있으며, 각 사용자는 옵서버가 되어 다른 사용자가 메시지를 보낼 때마다 메시지를 수신할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 싱글톤 패턴</span>
<span class="hljs-keyword">let</span> <span class="hljs-title class_">ChatRoom</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> instance;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createInstance</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> object = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(<span class="hljs-string">"ChatRoom"</span>);
    <span class="hljs-keyword">return</span> object;
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">getInstance</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">if</span> (!instance) {
        instance = <span class="hljs-title function_">createInstance</span>();
      }
      <span class="hljs-keyword">return</span> instance;
    }
  };
})();

<span class="hljs-comment">// 옵서버 패턴</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
  <span class="hljs-title function_">notify</span>(<span class="hljs-params">message</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received message: <span class="hljs-subst">${message}</span>`</span>);
  }
}
</code></pre>
<h2>온라인 게임 시스템</h2>
<p>온라인 게임 시스템과 같은 다른 예시에서는 게임 캐릭터의 다른 유형을 생성하기 위해 팩토리 패턴을 사용할 수 있고, 캐릭터가 맞았을 때 다른 플레이어에게 알리기 위해 옵서버 패턴을 사용할 수 있으며, 캐릭터에 특별 능력을 추가하기 위해 데코레이터 패턴을 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Factory Pattern</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">CharacterFactory</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">createCharacter</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">type</span>) {
    <span class="hljs-keyword">let</span> character;

    <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'Warrior'</span>) {
      character = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Warrior</span>();
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'Mage'</span>) {
      character = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mage</span>();
    }

    character.<span class="hljs-property">type</span> = type;
    <span class="hljs-keyword">return</span> character;
  }
}

<span class="hljs-comment">// Observer Pattern</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> {
  <span class="hljs-title function_">hit</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Notify all observers</span>
  }
}

<span class="hljs-comment">// Decorator Pattern</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">EnhancedCharacter</span>(<span class="hljs-params">character, ability</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">character</span> = character;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">ability</span> = ability;
}

<span class="hljs-title class_">EnhancedCharacter</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">useAbility</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Using ability: <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.ability}</span>`</span>);
}
</code></pre>
<p>These examples demonstrate the power of combining different design patterns to create a flexible and scalable solution, but remember: the key is not to force the use of patterns, it’s to identify when a pattern can improve code quality and maintainability.</p>
<h1>Design Patterns를 사용할 때 피해야 할 함정</h1>
<p><img src="/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_4.png" alt="Design Patterns"></p>
<p>디자인 패턴은 소프트웨어 개발 프로세스에서 중대한 차이를 만들어낼 수 있지만, 모든 도구와 마찬가지로 신중하게 사용해야 합니다.</p>
<p>다음은 피해야 할 몇 가지 일반적인 함정입니다:</p>
<h2>디자인 패턴 과용</h2>
<p>디자인 패턴은 흔한 문제에 대한 해결책이지만, 모든 소프트웨어 개발 고민의 치료약은 아니기 때문에 필요하지 않은 곳에 사용하면 불필요하게 복잡하고 난해한 코드로 이어질 수 있습니다.</p>
<h2>디자인 패턴 오용</h2>
<p>각 디자인 패턴은 빛을 발하는 특정 시나리오가 있으며, 그것이 맞지 않는 문맥에서 사용하면 혼란스럽고 유지보수하기 어려운 코드로 이어질 수 있습니다.</p>
<h2>패턴을 완전히 이해하지 못한 경우</h2>
<p>디자인 패턴을 사용하기 전에 그 구조, 목적 및 영향을 완전히 이해하는 것이 중요합니다. 이해하지 못하면 잘못된 구현 및 디버깅하기 어려운 버그로 이어질 수 있습니다.</p>
<h2>간단함의 원칙을 무시하다</h2>
<p>KISS (Keep It Simple, Stupid) 원칙은 소프트웨어 개발에서 중요한 요소이며 항상 강조하는 편입니다: 때로는 복잡한 디자인 패턴보다 간단한 절차적 해결책이 더 적합할 수 있습니다.</p>
<h1>요약 및 권장 사항</h1>
<p><img src="/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_5.png" alt=""></p>
<p>본질적으로 디자인 패턴은 반복되는 코딩 문제에 효율적인 해결책을 제공합니다. 그러나 이를 남용하지 않는 것이 중요합니다. 남용하거나 이해없이 적용하면 코드가 불필요하게 복잡해질 수 있습니다.</p>
<h2>추가 학습</h2>
<p>지속적인 학습과 능력 향상을 위해 다양한 디자인 패턴을 실험하고, 강점과 약점을 이해하며 효율적으로 사용할 수 있는 방법을 찾아보세요.</p>
<p>자바스크립트에 더 깊이 파고들고 싶은 분들을 위해, 저의 라이브러리에서 이 글들을 추천합니다: "JavaScript 오브젝트 구조 분해와 스프레드 구문 활용: Use Case 및 Best Practice" 그리고 "JavaScript Promises: 에러 처리와 Best Practice에 대한 깊은 탐구"</p>
<p>두 기사 모두 JavaScript의 특정 측면에 대한 실용적인 통찰을 제공하여 디자인 패턴과 같이 개발 작업을 향상시킬 수 있습니다.</p>
<p>항상 여러분의 이야기를 듣는 것에 흥미가 있어요. 댓글에서 여러분의 생각, 경험 또는 질문을 공유해주세요. 우리는 서로서로에서 배우고, 여러분의 통찰은 커뮤니티에 도움이 될 수 있습니다.</p>
<p><img src="/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_6.png" alt="이미지"></p>
<p>PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.</p>
<p>우리의 무료 주간 뉴스레터를 구독하세요. 트위터, 링크드인, 유튜브, 디스코드에서도 팔로우하세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"디자인 패턴 깨끗하고 확장 가능한 코드를 위한 JavaScript 개발 원칙 안내","description":"","date":"2024-05-14 15:59","slug":"2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode","content":"\n\n![이미지](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png)\n\n## 소프트웨어 개발 원칙\n\n# 소개 — JavaScript 디자인 패턴\n\n![이미지](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_1.png)\n\n\n\n## 디자인 패턴의 본질\n\n안녕하세요 여러분! 저는 시니어 소프트웨어 엔지니어로 활동한 지 오랜 시간이 되었지만, 깔끔하고 확장 가능한 코드를 작성하는 데 있어 단순히 무엇을 만드냐 보다는 코드의 구조가 중요하다는 것을 깨닫게 되었습니다. 여기서 디자인 패턴이 중요한 역할을 한다는 사실을 발견했습니다.\n\n## 디자인 패턴 — 무엇인가요?\n\n디자인 패턴은 소프트웨어 개발 중에 흔히 발생하는 문제에 대한 검증된 해결책으로, 코드 구조를 안내하는 템플릿 역할을 하여 우리가 코드를 구조화하는 데 도움을 줍니다. 디자인 패턴을 사용하면 더 읽기 쉽고 유연하며 유지보수하기 쉬운 코드를 작성하는 것이 쉬워지며, 개발자들이 더 효과적으로 소통할 수 있는 일종의 공통 언어를 제공하기도 합니다.\n\n\n\n## 자바스크립트 디자인 패턴의 힘\n\n자바스크립트는 다양한 프로그래밍 스타일을 지원하여 다재다능하며, 이는 중요한 장점이지만 동시에 언어를 혼란스럽게 만들 수도 있습니다. 그러나 디자인 패턴은 코드를 조직화하고 효율적으로 유지할 수 있는 방법을 제공합니다.\n\n다음 섹션에서는 자바스크립트 디자인 패턴을 더 깊게 탐색하며, 생성, 구조 및 행동 패턴을 탐구하고 각 유형에 대한 실용적인 예제를 제공하며 장단점 및 잠재적인 위험을 논의할 것입니다.\n\n# 자바스크립트 디자인 패턴 유형 탐색\n\n\n\n![image](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_2.png)\n\n## 생성 디자인 패턴: 객체 생성\n\nJavaScript에서 객체는 핵심 기능이며 종종 유사한 특성을 갖는 개체 또는 것들을 나타내는 데 사용됩니다. 이러한 객체의 생성을 조직화하기 위해 생성 디자인 패턴을 사용합니다.\n\n생성 패턴은 객체의 생성, 구성 및 표현 방식과는 독립적인 시스템을 만들어 인스턴스화 프로세스를 추상화하는 데 도움을 줍니다.\n\n\n\n공장 패턴\n\n공장 패턴은 객체를 생성하는 방법을 제공하지만 하위 클래스가 생성될 객체의 유형을 변경할 수 있습니다.\n\n```js\nfunction CarFactory() {\n  this.createCar = function(model) {\n    let car;\n    if (model === '세단') {\n      car = new Sedan();\n    } else if (model === 'SUV') {\n      car = new SUV();\n    }\n    return car;\n  };\n}\n```\n\n싱글톤 패턴\n\n\n\n싱글톤 패턴은 클래스가 여러 객체를 생성하는 것을 제한하며, 특정 동작을 제어해야 할 때 유용합니다.\n\n```js\nlet Singleton = (function () {\n  let instance;\n \n  function createInstance() {\n    return new Object(\"I am the instance\");\n  }\n \n  return {\n    getInstance: function () {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n```\n\n빌더 패턴\n\n빌더 패턴은 클라이언트가 타입과 내용에만 집중해 복잡한 객체를 구축할 수 있도록 하고, 객체를 조립하는 작업을 관리합니다.\n\n\n\n```js\nfunction CarBuilder() {\n  this.car = null;\n\n  this.step1 = function () {\n    this.car = new Car();\n  };\n\n  this.step2 = function () {\n    this.car.addParts();\n  };\n\n  this.get = function () {\n    return this.car;\n  };\n}\n```\n\n## 구조적 디자인 패턴: 코드 모양을 만드는 방법\n\n구조적 패턴은 서로 다른 클래스와 객체를 조직화하여 더 큰 구조를 형성하는 것에 관한 것이며 시스템의 한 부분이 변경될 때 전체 시스템이 함께 바뀌지 않도록 보장합니다.\n\n어댑터 패턴```\n\n\n\n어댑터 패턴은 호환되지 않는 인터페이스를 가진 클래스가 함께 작동할 수 있도록 객체 주변에 래핑하고 해당 객체와 상호 작용하는 표준 인터페이스를 노출하는 것을 가능하게 합니다.\n\n```js\nclass OldCalculator {\n  constructor() {\n    this.operations = function(term1, term2, operation) {\n      switch (operation) {\n        case 'add':\n          return term1 + term2;\n        case 'sub':\n          return term1 - term2;\n        default:\n          return NaN;\n      }\n    };\n  }\n}\n\nclass NewCalculator {\n  constructor() {\n    this.add = function(term1, term2) {\n      return term1 + term2;\n    };\n    this.sub = function(term1, term2) {\n      return term1 - term2;\n    };\n  }\n}\n\nclass CalculatorAdapter {\n  constructor() {\n    const newCalc = new NewCalculator();\n    \n    this.operations = function(term1, term2, operation) {\n      switch (operation) {\n        case 'add':\n          return newCalc.add(term1, term2);\n        case 'sub':\n          return newCalc.sub(term1, term2);\n        default:\n          return NaN;\n      }\n    };\n  }\n}\n```\n\n데코레이터 패턴\n\n데코레이터 패턴은 동일한 클래스의 다른 객체들의 행동에 영향을 미치지 않고 특정 개체에 정적 또는 동적으로 추가할 동작을 설명합니다.\n\n\n\n```js\nfunction Car(name) {\n  this.name = name;\n}\n\nCar.prototype.getName = function () {\n  return this.name;\n};\n\nfunction DecoratedCar(car, color, price) {\n  this.car = car;\n  this.color = color;\n  this.price = price;\n}\n\nDecoratedCar.prototype.getName = function () {\n  return this.car.getName() + ' has color ' + this.color + ' and price ' + this.price;\n};\n```\n\n프록시 패턴\n\n프록시 패턴은 원본 객체에 대한 액세스를 제어하기 위해 대리자 또는 플레이스홀더 객체를 제공합니다.\n\n```js\nfunction NetworkAccess() {\n  this.connect = function () {\n    console.log('네트워크에 연결되었습니다.');\n  };\n}\n\nfunction NetworkProxy() {\n  this.network = new NetworkAccess();\n  this.connect = function () {\n    console.log('네트워크 프록시를 사용합니다.');\n    this.network.connect();\n  };\n}\n```\n\n\n\n## 행동 디자인 패턴: 객체 협업 관리\n\n행동 디자인 패턴은 객체 간 통신에 관심을 가지며, 객체들이 작동하고 책임을 수행하는 방식에 대해 다룹니다. 대부분의 경우 객체 간 통신을 유연하게 처리할 수 있도록 돕습니다.\n\n옵저버 패턴\n\n옵저버 패턴은 객체 간의 일대다 종속성을 정의하여 한 객체의 상태가 변경되면 해당 객체에 의존하는 모든 객체가 자동으로 통지되고 업데이트됩니다.\n\n\n\n```js\nclass Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n\n    unsubscribe(observer) {\n        const index = this.observers.indexOf(observer);\n        if (index \u003e -1) {\n            this.observers.splice(index, 1);\n        }\n    }\n\n    notifyAll(data) {\n        for (let i = 0; i \u003c this.observers.length; i++) {\n            this.observers[i].notify(data);\n        }\n    }\n}\n\nclass Observer {\n    notify(data) {\n        console.log(`Observer received: ${data}`);\n    }\n}\n```\n\n전략 패턴\n\n전략 패턴은 클라이언트가 인식하지 못하고 메서드(전략)를 런타임에 다른 메서드로 교체할 수 있게 하는 것을 가능하게 합니다. 이것은 교환 가능한 알고리즘 그룹입니다.\n\n```js\nclass Shipping {\n    setStrategy(strategy) {\n        this.strategy = strategy;\n    }\n\n    calculate(parcel) {\n        return this.strategy.calculate(parcel);\n    }\n}\n\nclass UPS {\n    calculate(parcel) {\n        return `$${parcel.weight * 1.75}`;\n    }\n}\n\nclass FedEx {\n    calculate(parcel) {\n        return `$${parcel.weight * 2.45}`;\n    }\n}\n\nclass USPS {\n    calculate(parcel) {\n        return `$${parcel.weight * 1.25}`;\n    }\n}\n```\n\n\n\n## 커맨드 패턴\n\n커맨드 패턴은 요청의 구체적인 내용을 알지 못한 채로 작업을 객체에 캡슐화하는 기능을 제공합니다.\n\n```js\nclass Switch {\n  execute(command) {\n    command.execute();\n  }\n}\n\nclass TurnOnCommand {\n  constructor(light) {\n    this.light = light;\n  }\n\n  execute() {\n    this.light.turnOn();\n  }\n}\n\nclass Light {\n  turnOn() {\n    console.log('불이 켜졌습니다');\n  }\n\n  turnOff() {\n    console.log('불이 꺼졌습니다');\n  }\n}\n```\n\n다음 섹션에서 이러한 패턴이 실제 JavaScript 애플리케이션에서 어떻게 사용되며 깔끔하고 확장 가능한 코드를 어떻게 이끌어내는지 알아보겠습니다.\n\n\n\n# JavaScript 디자인 패턴의 실제 응용\n\n![Design Patterns](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_3.png)\n\n디자인 패턴은 강력한 도구입니다. 하지만 실제 상황에서 그들의 응용을 통해 우리는 그들의 힘을 진정으로 이해할 수 있고, 이를 보여주기 위해 우리가 논의한 패턴 중 일부가 실제 상황에서 어떻게 활용될 수 있는지 살펴봅시다.\n\n## 사용자 프로필 생성\n\n\n\n사회적 미디어 사이트를 위한 사용자 프로필 시스템을 만드는 작업이 있다고 상상해보세요: Factory 패턴을 사용하면 미리 정의된 템플릿을 사용하여 프로필을 만들어 프로세스를 간소화할 수 있습니다.\n\n```js\nfunction UserFactory() {\n  this.createUser = function(type) {\n    let user;\n\n    if (type === '개인') {\n      user = new PersonalUser();\n    } else if (type === '비즈니스') {\n      user = new BusinessUser();\n    }\n\n    user.type = type;\n    user.say = function() {\n      console.log(this.type + \": 프로필이 생성되었습니다\");\n    }\n    return user;\n  }\n}\n```\n\n## 제3자 API와의 통합\n\n다른 상황에서는 응용 프로그램에 제3자 API를 통합해야 할 필요가 있다고 상상해보세요. 그러나 이 API의 인터페이스가 응용 프로그램의 기존 시스템과 일치하지 않는 경우: Adapter 패턴을 사용하여 기존 코드베이스를 변경하지 않고 API를 응용 프로그램과 호환되도록 만들 수 있습니다.\n\n\n\n```md\n```js\nclass ThirdPartyAPI {\n  constructor() {\n    this.specificRequest = function() {\n      return \"Third-party API response\";\n    };\n  }\n}\n\nclass Adapter {\n  constructor(thirdPartyAPI) {\n    this.request = function() {\n      return thirdPartyAPI.specificRequest();\n    };\n  }\n}\n\n// Using the Adapter\nconst thirdPartyAPI = new ThirdPartyAPI();\nconst adapter = new Adapter(thirdPartyAPI);\nadapter.request();\n```\n\n## 사용자 프로필에 기능 추가하기\n\nDecorator Pattern은 사용자 프로필에 프리미엄 뱃지나 사용자 정의 테마와 같은 새로운 기능을 추가하고 원래의 사용자 객체를 변경하지 않고 싶을 때 적용할 수 있습니다.\n\n```js\nfunction User(name) {\n  this.name = name;\n}\n\nUser.prototype.getName = function () {\n  return this.name;\n};\n\nfunction DecoratedUser(user, badge, theme) {\n  this.user = user;\n  this.badge = badge;\n  this.theme = theme;\n}\n\nDecoratedUser.prototype.getName = function () {\n  return `${this.user.getName()}, Badge: ${this.badge}, Theme: ${this.theme}`;\n};\n```\n\n\n\n## 게시물과 사용자 상호작용\n\n옵저버 패턴은 사용자가 게시물과 상호작용할 수 있는 시스템을 구현해야 할 때 유용합니다. 사용자가 게시물을 좋아하거나 댓글을 달 수 있는 경우, 각 게시물이 주제로 작용하고 다른 사용자가 상호작용을 통지받는 관찰자로 작용할 수 있습니다.\n\n```js\nclass Post {\n  constructor() {\n    this.observers = [];\n  }\n\n  like(user) {\n    this.notifyAll(`게시물이 ${user}님에 의해 좋아요!`);\n  }\n\n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n\n  notifyAll(message) {\n    for (let observer of this.observers) {\n      observer.notify(message);\n    }\n  }\n}\n\nclass User {\n  notify(message) {\n    console.log(`사용자에게 알림: ${message}`);\n  }\n}\n```\n\n## 다양한 배송 방법\n\n\n\n이제 전자 상거래 애플리케이션이 다른 배송 방법을 지원해야 하는 경우를 가정해 보겠습니다: 각 배송 방법을 별도의 전략으로 구현할 수 있기 때문에 Strategy Pattern은 이 경우에 완벽합니다.\n\n```js\nclass Shipping {\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  calculate(parcel) {\n    return this.strategy.calculate(parcel);\n  }\n}\n\nclass UPS {\n  calculate(parcel) {\n    return `$${parcel.weight * 1.75}`;\n  }\n}\n\nclass FedEx {\n  calculate(parcel) {\n    return `$${parcel.weight * 2.45}`;\n  }\n}\n\nclass USPS {\n  calculate(parcel) {\n    return `$${parcel.weight * 1.25}`;\n  }\n}\n```\n\n## 웹사이트 테마 사용자 정의\n\n사용자가 테마를 사용자 정의할 수 있는 웹사이트가 있다고 상상해보세요. 여러 테마 객체를 만들기 위해 Factory Pattern을 사용하고, 그 테마에 추가 기능을 추가하기 위해 Decorator Pattern을 사용할 수 있습니다.\n\n\n\n```js\n// 팩토리 패턴\nfunction ThemeFactory() {\n  this.createTheme = function(type) {\n    let theme;\n\n    if (type === 'Dark') {\n      theme = new DarkTheme();\n    } else if (type === 'Light') {\n      theme = new LightTheme();\n    }\n\n    theme.type = type;\n    return theme;\n  }\n}\n\n// 데코레이터 패턴\nfunction DecoratedTheme(theme, color) {\n  this.theme = theme;\n  this.color = color;\n}\n\nDecoratedTheme.prototype.getName = function () {\n  return this.theme.getName() + ' in ' + this.color + ' color';\n};\n```\n\n## 할인 이벤트가 적용된 전자 상거래 사이트\n\n전자 상거래 사이트를 상상해보세요. 여러분은 제품에 특별 할인 이벤트를 적용하는 시스템을 구현하려고 합니다. 여기서는 다양한 종류의 특별 할인을 나타내기 위해 전략 패턴을 사용하고 관심 있는 제품에 특별 할인이 적용될 때 고객들에게 알리기 위해 옵서버 패턴을 사용할 수 있습니다.\n\n```js\n// 전략 패턴\nclass SpecialOffer {\n  apply(product) {\n    // abstract method\n  }\n}\n\nclass BlackFridayOffer extends SpecialOffer {\n  apply(product) {\n    product.price *= 0.8;  // 20% 할인\n  }\n}\n\nclass ChristmasOffer extends SpecialOffer {\n  apply(product) {\n    product.price *= 0.85;  // 15% 할인\n  }\n}\n\n// 옵서버 패턴\nclass Product {\n  constructor(price) {\n    this.price = price;\n    this.observers = [];\n  }\n\n  setPrice(price) {\n    this.price = price;\n    this.notifyAll();\n  }\n\n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n\n  notifyAll() {\n    for (let observer of this.observers) {\n      observer.notify(this);\n    }\n  }\n}\n\nclass Customer {\n  notify(product) {\n    console.log(`제품 가격이 $${product.price}로 업데이트되었습니다.`);\n  }\n}\n```\n\n\n\n## 성능 모니터링 시스템\n\n알겠어요, 그럼 어떤 응용 프로그램의 다른 모듈의 성능을 모니터링하는 시스템을 구축한다고 생각해봅시다. 이러한 모듈은 Factory Pattern을 사용하여 나타낼 수 있으며 이러한 모듈의 성능을 관찰하고 문제를 보고하려면 Proxy Pattern을 사용할 수 있습니다.\n\n```js\n// Factory Pattern\nfunction ModuleFactory() {\n  this.createModule = function(type) {\n    let module;\n\n    if (type === 'Database') {\n      module = new DatabaseModule();\n    } else if (type === 'Network') {\n      module = new NetworkModule();\n    }\n\n    module.type = type;\n    return module;\n  }\n}\n\n// Proxy Pattern\nclass PerformanceProxy {\n  constructor(module) {\n    this.module = module;\n  }\n\n  monitor() {\n    console.log('성능 모니터링 중...');\n    // 호출을 원래 객체로 위임합니다.\n    this.module.monitor();\n  }\n}\n```\n\n## 채팅 애플리케이션\n\n\n\n매우 흔한 채팅 애플리케이션에서는 ChatRoom 클래스의 인스턴스가 하나만 있는지를 보장하기 위해 싱글톤 패턴을 사용할 수 있으며, 각 사용자는 옵서버가 되어 다른 사용자가 메시지를 보낼 때마다 메시지를 수신할 수 있습니다.\n\n```js\n// 싱글톤 패턴\nlet ChatRoom = (function() {\n  let instance;\n\n  function createInstance() {\n    let object = new Object(\"ChatRoom\");\n    return object;\n  }\n\n  return {\n    getInstance: function() {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    }\n  };\n})();\n\n// 옵서버 패턴\nclass User {\n  notify(message) {\n    console.log(`Received message: ${message}`);\n  }\n}\n```\n\n## 온라인 게임 시스템\n\n온라인 게임 시스템과 같은 다른 예시에서는 게임 캐릭터의 다른 유형을 생성하기 위해 팩토리 패턴을 사용할 수 있고, 캐릭터가 맞았을 때 다른 플레이어에게 알리기 위해 옵서버 패턴을 사용할 수 있으며, 캐릭터에 특별 능력을 추가하기 위해 데코레이터 패턴을 사용할 수 있습니다.\n\n\n\n```js\n// Factory Pattern\nfunction CharacterFactory() {\n  this.createCharacter = function(type) {\n    let character;\n\n    if (type === 'Warrior') {\n      character = new Warrior();\n    } else if (type === 'Mage') {\n      character = new Mage();\n    }\n\n    character.type = type;\n    return character;\n  }\n}\n\n// Observer Pattern\nclass Character {\n  hit() {\n    // Notify all observers\n  }\n}\n\n// Decorator Pattern\nfunction EnhancedCharacter(character, ability) {\n  this.character = character;\n  this.ability = ability;\n}\n\nEnhancedCharacter.prototype.useAbility = function() {\n  console.log(`Using ability: ${this.ability}`);\n}\n```\n\nThese examples demonstrate the power of combining different design patterns to create a flexible and scalable solution, but remember: the key is not to force the use of patterns, it’s to identify when a pattern can improve code quality and maintainability.\n\n# Design Patterns를 사용할 때 피해야 할 함정\n\n![Design Patterns](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_4.png)\n\n\n\n\n디자인 패턴은 소프트웨어 개발 프로세스에서 중대한 차이를 만들어낼 수 있지만, 모든 도구와 마찬가지로 신중하게 사용해야 합니다.\n\n다음은 피해야 할 몇 가지 일반적인 함정입니다:\n\n## 디자인 패턴 과용\n\n디자인 패턴은 흔한 문제에 대한 해결책이지만, 모든 소프트웨어 개발 고민의 치료약은 아니기 때문에 필요하지 않은 곳에 사용하면 불필요하게 복잡하고 난해한 코드로 이어질 수 있습니다.\n\n\n\n## 디자인 패턴 오용\n\n각 디자인 패턴은 빛을 발하는 특정 시나리오가 있으며, 그것이 맞지 않는 문맥에서 사용하면 혼란스럽고 유지보수하기 어려운 코드로 이어질 수 있습니다.\n\n## 패턴을 완전히 이해하지 못한 경우\n\n디자인 패턴을 사용하기 전에 그 구조, 목적 및 영향을 완전히 이해하는 것이 중요합니다. 이해하지 못하면 잘못된 구현 및 디버깅하기 어려운 버그로 이어질 수 있습니다.\n\n\n\n## 간단함의 원칙을 무시하다\n\nKISS (Keep It Simple, Stupid) 원칙은 소프트웨어 개발에서 중요한 요소이며 항상 강조하는 편입니다: 때로는 복잡한 디자인 패턴보다 간단한 절차적 해결책이 더 적합할 수 있습니다.\n\n# 요약 및 권장 사항\n\n![](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_5.png)\n\n\n\n본질적으로 디자인 패턴은 반복되는 코딩 문제에 효율적인 해결책을 제공합니다. 그러나 이를 남용하지 않는 것이 중요합니다. 남용하거나 이해없이 적용하면 코드가 불필요하게 복잡해질 수 있습니다.\n\n## 추가 학습\n\n지속적인 학습과 능력 향상을 위해 다양한 디자인 패턴을 실험하고, 강점과 약점을 이해하며 효율적으로 사용할 수 있는 방법을 찾아보세요.\n\n자바스크립트에 더 깊이 파고들고 싶은 분들을 위해, 저의 라이브러리에서 이 글들을 추천합니다: \"JavaScript 오브젝트 구조 분해와 스프레드 구문 활용: Use Case 및 Best Practice\" 그리고 \"JavaScript Promises: 에러 처리와 Best Practice에 대한 깊은 탐구\"\n\n\n\n두 기사 모두 JavaScript의 특정 측면에 대한 실용적인 통찰을 제공하여 디자인 패턴과 같이 개발 작업을 향상시킬 수 있습니다.\n\n항상 여러분의 이야기를 듣는 것에 흥미가 있어요. 댓글에서 여러분의 생각, 경험 또는 질문을 공유해주세요. 우리는 서로서로에서 배우고, 여러분의 통찰은 커뮤니티에 도움이 될 수 있습니다.\n\n![이미지](/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_6.png)\n\nPlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.\n\n\n\n우리의 무료 주간 뉴스레터를 구독하세요. 트위터, 링크드인, 유튜브, 디스코드에서도 팔로우하세요.","ogImage":{"url":"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png"},"coverImage":"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e소프트웨어 개발 원칙\u003c/h2\u003e\n\u003ch1\u003e소개 — JavaScript 디자인 패턴\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e디자인 패턴의 본질\u003c/h2\u003e\n\u003cp\u003e안녕하세요 여러분! 저는 시니어 소프트웨어 엔지니어로 활동한 지 오랜 시간이 되었지만, 깔끔하고 확장 가능한 코드를 작성하는 데 있어 단순히 무엇을 만드냐 보다는 코드의 구조가 중요하다는 것을 깨닫게 되었습니다. 여기서 디자인 패턴이 중요한 역할을 한다는 사실을 발견했습니다.\u003c/p\u003e\n\u003ch2\u003e디자인 패턴 — 무엇인가요?\u003c/h2\u003e\n\u003cp\u003e디자인 패턴은 소프트웨어 개발 중에 흔히 발생하는 문제에 대한 검증된 해결책으로, 코드 구조를 안내하는 템플릿 역할을 하여 우리가 코드를 구조화하는 데 도움을 줍니다. 디자인 패턴을 사용하면 더 읽기 쉽고 유연하며 유지보수하기 쉬운 코드를 작성하는 것이 쉬워지며, 개발자들이 더 효과적으로 소통할 수 있는 일종의 공통 언어를 제공하기도 합니다.\u003c/p\u003e\n\u003ch2\u003e자바스크립트 디자인 패턴의 힘\u003c/h2\u003e\n\u003cp\u003e자바스크립트는 다양한 프로그래밍 스타일을 지원하여 다재다능하며, 이는 중요한 장점이지만 동시에 언어를 혼란스럽게 만들 수도 있습니다. 그러나 디자인 패턴은 코드를 조직화하고 효율적으로 유지할 수 있는 방법을 제공합니다.\u003c/p\u003e\n\u003cp\u003e다음 섹션에서는 자바스크립트 디자인 패턴을 더 깊게 탐색하며, 생성, 구조 및 행동 패턴을 탐구하고 각 유형에 대한 실용적인 예제를 제공하며 장단점 및 잠재적인 위험을 논의할 것입니다.\u003c/p\u003e\n\u003ch1\u003e자바스크립트 디자인 패턴 유형 탐색\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003e생성 디자인 패턴: 객체 생성\u003c/h2\u003e\n\u003cp\u003eJavaScript에서 객체는 핵심 기능이며 종종 유사한 특성을 갖는 개체 또는 것들을 나타내는 데 사용됩니다. 이러한 객체의 생성을 조직화하기 위해 생성 디자인 패턴을 사용합니다.\u003c/p\u003e\n\u003cp\u003e생성 패턴은 객체의 생성, 구성 및 표현 방식과는 독립적인 시스템을 만들어 인스턴스화 프로세스를 추상화하는 데 도움을 줍니다.\u003c/p\u003e\n\u003cp\u003e공장 패턴\u003c/p\u003e\n\u003cp\u003e공장 패턴은 객체를 생성하는 방법을 제공하지만 하위 클래스가 생성될 객체의 유형을 변경할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eCarFactory\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecreateCar\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emodel\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e car;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (model === \u003cspan class=\"hljs-string\"\u003e'세단'\u003c/span\u003e) {\n      car = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSedan\u003c/span\u003e();\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (model === \u003cspan class=\"hljs-string\"\u003e'SUV'\u003c/span\u003e) {\n      car = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eSUV\u003c/span\u003e();\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e car;\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e싱글톤 패턴\u003c/p\u003e\n\u003cp\u003e싱글톤 패턴은 클래스가 여러 객체를 생성하는 것을 제한하며, 특정 동작을 제어해야 할 때 유용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSingleton\u003c/span\u003e = (\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e instance;\n \n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateInstance\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"I am the instance\"\u003c/span\u003e);\n  }\n \n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003egetInstance\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!instance) {\n        instance = \u003cspan class=\"hljs-title function_\"\u003ecreateInstance\u003c/span\u003e();\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instance;\n    }\n  };\n})();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e빌더 패턴\u003c/p\u003e\n\u003cp\u003e빌더 패턴은 클라이언트가 타입과 내용에만 집중해 복잡한 객체를 구축할 수 있도록 하고, 객체를 조립하는 작업을 관리합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eCarBuilder\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecar\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estep1\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecar\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e();\n  };\n\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estep2\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecar\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddParts\u003c/span\u003e();\n  };\n\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eget\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecar\u003c/span\u003e;\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e구조적 디자인 패턴: 코드 모양을 만드는 방법\u003c/h2\u003e\n\u003cp\u003e구조적 패턴은 서로 다른 클래스와 객체를 조직화하여 더 큰 구조를 형성하는 것에 관한 것이며 시스템의 한 부분이 변경될 때 전체 시스템이 함께 바뀌지 않도록 보장합니다.\u003c/p\u003e\n\u003cp\u003e어댑터 패턴```\u003c/p\u003e\n\u003cp\u003e어댑터 패턴은 호환되지 않는 인터페이스를 가진 클래스가 함께 작동할 수 있도록 객체 주변에 래핑하고 해당 객체와 상호 작용하는 표준 인터페이스를 노출하는 것을 가능하게 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOldCalculator\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoperations\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eterm1, term2, operation\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (operation) {\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'add'\u003c/span\u003e:\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e term1 + term2;\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'sub'\u003c/span\u003e:\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e term1 - term2;\n        \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e:\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNaN\u003c/span\u003e;\n      }\n    };\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNewCalculator\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadd\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eterm1, term2\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e term1 + term2;\n    };\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esub\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eterm1, term2\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e term1 - term2;\n    };\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCalculatorAdapter\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newCalc = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNewCalculator\u003c/span\u003e();\n    \n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoperations\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eterm1, term2, operation\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e (operation) {\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'add'\u003c/span\u003e:\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e newCalc.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(term1, term2);\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'sub'\u003c/span\u003e:\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e newCalc.\u003cspan class=\"hljs-title function_\"\u003esub\u003c/span\u003e(term1, term2);\n        \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e:\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNaN\u003c/span\u003e;\n      }\n    };\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e데코레이터 패턴\u003c/p\u003e\n\u003cp\u003e데코레이터 패턴은 동일한 클래스의 다른 객체들의 행동에 영향을 미치지 않고 특정 개체에 정적 또는 동적으로 추가할 동작을 설명합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eCar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = name;\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egetName\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eDecoratedCar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecar, color, price\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecar\u003c/span\u003e = car;\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecolor\u003c/span\u003e = color;\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eprice\u003c/span\u003e = price;\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eDecoratedCar\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egetName\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecar\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetName\u003c/span\u003e() + \u003cspan class=\"hljs-string\"\u003e' has color '\u003c/span\u003e + \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecolor\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e' and price '\u003c/span\u003e + \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eprice\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e프록시 패턴\u003c/p\u003e\n\u003cp\u003e프록시 패턴은 원본 객체에 대한 액세스를 제어하기 위해 대리자 또는 플레이스홀더 객체를 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eNetworkAccess\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003econnect\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'네트워크에 연결되었습니다.'\u003c/span\u003e);\n  };\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eNetworkProxy\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enetwork\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNetworkAccess\u003c/span\u003e();\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003econnect\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'네트워크 프록시를 사용합니다.'\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enetwork\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e();\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e행동 디자인 패턴: 객체 협업 관리\u003c/h2\u003e\n\u003cp\u003e행동 디자인 패턴은 객체 간 통신에 관심을 가지며, 객체들이 작동하고 책임을 수행하는 방식에 대해 다룹니다. 대부분의 경우 객체 간 통신을 유연하게 처리할 수 있도록 돕습니다.\u003c/p\u003e\n\u003cp\u003e옵저버 패턴\u003c/p\u003e\n\u003cp\u003e옵저버 패턴은 객체 간의 일대다 종속성을 정의하여 한 객체의 상태가 변경되면 해당 객체에 의존하는 모든 객체가 자동으로 통지되고 업데이트됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSubject\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e = [];\n    }\n\n    \u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eobserver\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(observer);\n    }\n\n    \u003cspan class=\"hljs-title function_\"\u003eunsubscribe\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eobserver\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e index = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eindexOf\u003c/span\u003e(observer);\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (index \u003e -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n            \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esplice\u003c/span\u003e(index, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n        }\n    }\n\n    \u003cspan class=\"hljs-title function_\"\u003enotifyAll\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e; i++) {\n            \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e[i].\u003cspan class=\"hljs-title function_\"\u003enotify\u003c/span\u003e(data);\n        }\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObserver\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003enotify\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Observer received: \u003cspan class=\"hljs-subst\"\u003e${data}\u003c/span\u003e`\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e전략 패턴\u003c/p\u003e\n\u003cp\u003e전략 패턴은 클라이언트가 인식하지 못하고 메서드(전략)를 런타임에 다른 메서드로 교체할 수 있게 하는 것을 가능하게 합니다. 이것은 교환 가능한 알고리즘 그룹입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eShipping\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003esetStrategy\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estrategy\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estrategy\u003c/span\u003e = strategy;\n    }\n\n    \u003cspan class=\"hljs-title function_\"\u003ecalculate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eparcel\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estrategy\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecalculate\u003c/span\u003e(parcel);\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUPS\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003ecalculate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eparcel\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`$\u003cspan class=\"hljs-subst\"\u003e${parcel.weight * \u003cspan class=\"hljs-number\"\u003e1.75\u003c/span\u003e}\u003c/span\u003e`\u003c/span\u003e;\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFedEx\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003ecalculate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eparcel\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`$\u003cspan class=\"hljs-subst\"\u003e${parcel.weight * \u003cspan class=\"hljs-number\"\u003e2.45\u003c/span\u003e}\u003c/span\u003e`\u003c/span\u003e;\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUSPS\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003ecalculate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eparcel\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`$\u003cspan class=\"hljs-subst\"\u003e${parcel.weight * \u003cspan class=\"hljs-number\"\u003e1.25\u003c/span\u003e}\u003c/span\u003e`\u003c/span\u003e;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e커맨드 패턴\u003c/h2\u003e\n\u003cp\u003e커맨드 패턴은 요청의 구체적인 내용을 알지 못한 채로 작업을 객체에 캡슐화하는 기능을 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSwitch\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecommand\u003c/span\u003e) {\n    command.\u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e();\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTurnOnCommand\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003elight\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elight\u003c/span\u003e = light;\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elight\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eturnOn\u003c/span\u003e();\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLight\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003eturnOn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'불이 켜졌습니다'\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003eturnOff\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'불이 꺼졌습니다'\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 섹션에서 이러한 패턴이 실제 JavaScript 애플리케이션에서 어떻게 사용되며 깔끔하고 확장 가능한 코드를 어떻게 이끌어내는지 알아보겠습니다.\u003c/p\u003e\n\u003ch1\u003eJavaScript 디자인 패턴의 실제 응용\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_3.png\" alt=\"Design Patterns\"\u003e\u003c/p\u003e\n\u003cp\u003e디자인 패턴은 강력한 도구입니다. 하지만 실제 상황에서 그들의 응용을 통해 우리는 그들의 힘을 진정으로 이해할 수 있고, 이를 보여주기 위해 우리가 논의한 패턴 중 일부가 실제 상황에서 어떻게 활용될 수 있는지 살펴봅시다.\u003c/p\u003e\n\u003ch2\u003e사용자 프로필 생성\u003c/h2\u003e\n\u003cp\u003e사회적 미디어 사이트를 위한 사용자 프로필 시스템을 만드는 작업이 있다고 상상해보세요: Factory 패턴을 사용하면 미리 정의된 템플릿을 사용하여 프로필을 만들어 프로세스를 간소화할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUserFactory\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecreateUser\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etype\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e user;\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (type === \u003cspan class=\"hljs-string\"\u003e'개인'\u003c/span\u003e) {\n      user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePersonalUser\u003c/span\u003e();\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (type === \u003cspan class=\"hljs-string\"\u003e'비즈니스'\u003c/span\u003e) {\n      user = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBusinessUser\u003c/span\u003e();\n    }\n\n    user.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e = type;\n    user.\u003cspan class=\"hljs-property\"\u003esay\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e\": 프로필이 생성되었습니다\"\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e user;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e제3자 API와의 통합\u003c/h2\u003e\n\u003cp\u003e다른 상황에서는 응용 프로그램에 제3자 API를 통합해야 할 필요가 있다고 상상해보세요. 그러나 이 API의 인터페이스가 응용 프로그램의 기존 시스템과 일치하지 않는 경우: Adapter 패턴을 사용하여 기존 코드베이스를 변경하지 않고 API를 응용 프로그램과 호환되도록 만들 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-md\"\u003e\u003cspan class=\"hljs-code\"\u003e```js\nclass ThirdPartyAPI {\n  constructor() {\n    this.specificRequest = function() {\n      return \"Third-party API response\";\n    };\n  }\n}\n\nclass Adapter {\n  constructor(thirdPartyAPI) {\n    this.request = function() {\n      return thirdPartyAPI.specificRequest();\n    };\n  }\n}\n\n// Using the Adapter\nconst thirdPartyAPI = new ThirdPartyAPI();\nconst adapter = new Adapter(thirdPartyAPI);\nadapter.request();\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e사용자 프로필에 기능 추가하기\u003c/h2\u003e\n\u003cp\u003eDecorator Pattern은 사용자 프로필에 프리미엄 뱃지나 사용자 정의 테마와 같은 새로운 기능을 추가하고 원래의 사용자 객체를 변경하지 않고 싶을 때 적용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = name;\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egetName\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eDecoratedUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003euser, badge, theme\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003euser\u003c/span\u003e = user;\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebadge\u003c/span\u003e = badge;\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etheme\u003c/span\u003e = theme;\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eDecoratedUser\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egetName\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.user.getName()}\u003c/span\u003e, Badge: \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.badge}\u003c/span\u003e, Theme: \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.theme}\u003c/span\u003e`\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e게시물과 사용자 상호작용\u003c/h2\u003e\n\u003cp\u003e옵저버 패턴은 사용자가 게시물과 상호작용할 수 있는 시스템을 구현해야 할 때 유용합니다. 사용자가 게시물을 좋아하거나 댓글을 달 수 있는 경우, 각 게시물이 주제로 작용하고 다른 사용자가 상호작용을 통지받는 관찰자로 작용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePost\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e = [];\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003elike\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003euser\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enotifyAll\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`게시물이 \u003cspan class=\"hljs-subst\"\u003e${user}\u003c/span\u003e님에 의해 좋아요!`\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eobserver\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(observer);\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003enotifyAll\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emessage\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e observer \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e) {\n      observer.\u003cspan class=\"hljs-title function_\"\u003enotify\u003c/span\u003e(message);\n    }\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003enotify\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emessage\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`사용자에게 알림: \u003cspan class=\"hljs-subst\"\u003e${message}\u003c/span\u003e`\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e다양한 배송 방법\u003c/h2\u003e\n\u003cp\u003e이제 전자 상거래 애플리케이션이 다른 배송 방법을 지원해야 하는 경우를 가정해 보겠습니다: 각 배송 방법을 별도의 전략으로 구현할 수 있기 때문에 Strategy Pattern은 이 경우에 완벽합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eShipping\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003esetStrategy\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estrategy\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estrategy\u003c/span\u003e = strategy;\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003ecalculate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eparcel\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estrategy\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecalculate\u003c/span\u003e(parcel);\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUPS\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003ecalculate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eparcel\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`$\u003cspan class=\"hljs-subst\"\u003e${parcel.weight * \u003cspan class=\"hljs-number\"\u003e1.75\u003c/span\u003e}\u003c/span\u003e`\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFedEx\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003ecalculate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eparcel\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`$\u003cspan class=\"hljs-subst\"\u003e${parcel.weight * \u003cspan class=\"hljs-number\"\u003e2.45\u003c/span\u003e}\u003c/span\u003e`\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUSPS\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003ecalculate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eparcel\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`$\u003cspan class=\"hljs-subst\"\u003e${parcel.weight * \u003cspan class=\"hljs-number\"\u003e1.25\u003c/span\u003e}\u003c/span\u003e`\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e웹사이트 테마 사용자 정의\u003c/h2\u003e\n\u003cp\u003e사용자가 테마를 사용자 정의할 수 있는 웹사이트가 있다고 상상해보세요. 여러 테마 객체를 만들기 위해 Factory Pattern을 사용하고, 그 테마에 추가 기능을 추가하기 위해 Decorator Pattern을 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 팩토리 패턴\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eThemeFactory\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecreateTheme\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etype\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e theme;\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (type === \u003cspan class=\"hljs-string\"\u003e'Dark'\u003c/span\u003e) {\n      theme = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDarkTheme\u003c/span\u003e();\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (type === \u003cspan class=\"hljs-string\"\u003e'Light'\u003c/span\u003e) {\n      theme = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLightTheme\u003c/span\u003e();\n    }\n\n    theme.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e = type;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e theme;\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 데코레이터 패턴\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eDecoratedTheme\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etheme, color\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etheme\u003c/span\u003e = theme;\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecolor\u003c/span\u003e = color;\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eDecoratedTheme\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egetName\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etheme\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetName\u003c/span\u003e() + \u003cspan class=\"hljs-string\"\u003e' in '\u003c/span\u003e + \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecolor\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e' color'\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e할인 이벤트가 적용된 전자 상거래 사이트\u003c/h2\u003e\n\u003cp\u003e전자 상거래 사이트를 상상해보세요. 여러분은 제품에 특별 할인 이벤트를 적용하는 시스템을 구현하려고 합니다. 여기서는 다양한 종류의 특별 할인을 나타내기 위해 전략 패턴을 사용하고 관심 있는 제품에 특별 할인이 적용될 때 고객들에게 알리기 위해 옵서버 패턴을 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 전략 패턴\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSpecialOffer\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eproduct\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// abstract method\u003c/span\u003e\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBlackFridayOffer\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eSpecialOffer\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eproduct\u003c/span\u003e) {\n    product.\u003cspan class=\"hljs-property\"\u003eprice\u003c/span\u003e *= \u003cspan class=\"hljs-number\"\u003e0.8\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// 20% 할인\u003c/span\u003e\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChristmasOffer\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eSpecialOffer\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eproduct\u003c/span\u003e) {\n    product.\u003cspan class=\"hljs-property\"\u003eprice\u003c/span\u003e *= \u003cspan class=\"hljs-number\"\u003e0.85\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// 15% 할인\u003c/span\u003e\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 옵서버 패턴\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProduct\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprice\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eprice\u003c/span\u003e = price;\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e = [];\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003esetPrice\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprice\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eprice\u003c/span\u003e = price;\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enotifyAll\u003c/span\u003e();\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003esubscribe\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eobserver\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(observer);\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003enotifyAll\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e observer \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eobservers\u003c/span\u003e) {\n      observer.\u003cspan class=\"hljs-title function_\"\u003enotify\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e);\n    }\n  }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCustomer\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003enotify\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eproduct\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`제품 가격이 $\u003cspan class=\"hljs-subst\"\u003e${product.price}\u003c/span\u003e로 업데이트되었습니다.`\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e성능 모니터링 시스템\u003c/h2\u003e\n\u003cp\u003e알겠어요, 그럼 어떤 응용 프로그램의 다른 모듈의 성능을 모니터링하는 시스템을 구축한다고 생각해봅시다. 이러한 모듈은 Factory Pattern을 사용하여 나타낼 수 있으며 이러한 모듈의 성능을 관찰하고 문제를 보고하려면 Proxy Pattern을 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Factory Pattern\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eModuleFactory\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecreateModule\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etype\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (type === \u003cspan class=\"hljs-string\"\u003e'Database'\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDatabaseModule\u003c/span\u003e();\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (type === \u003cspan class=\"hljs-string\"\u003e'Network'\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNetworkModule\u003c/span\u003e();\n    }\n\n    \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e = type;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e;\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Proxy Pattern\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePerformanceProxy\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emodule\u003c/span\u003e = \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003emonitor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'성능 모니터링 중...'\u003c/span\u003e);\n    \u003cspan class=\"hljs-comment\"\u003e// 호출을 원래 객체로 위임합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emonitor\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e채팅 애플리케이션\u003c/h2\u003e\n\u003cp\u003e매우 흔한 채팅 애플리케이션에서는 ChatRoom 클래스의 인스턴스가 하나만 있는지를 보장하기 위해 싱글톤 패턴을 사용할 수 있으며, 각 사용자는 옵서버가 되어 다른 사용자가 메시지를 보낼 때마다 메시지를 수신할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 싱글톤 패턴\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatRoom\u003c/span\u003e = (\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e instance;\n\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecreateInstance\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e object = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ChatRoom\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e object;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003egetInstance\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!instance) {\n        instance = \u003cspan class=\"hljs-title function_\"\u003ecreateInstance\u003c/span\u003e();\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instance;\n    }\n  };\n})();\n\n\u003cspan class=\"hljs-comment\"\u003e// 옵서버 패턴\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003enotify\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003emessage\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Received message: \u003cspan class=\"hljs-subst\"\u003e${message}\u003c/span\u003e`\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e온라인 게임 시스템\u003c/h2\u003e\n\u003cp\u003e온라인 게임 시스템과 같은 다른 예시에서는 게임 캐릭터의 다른 유형을 생성하기 위해 팩토리 패턴을 사용할 수 있고, 캐릭터가 맞았을 때 다른 플레이어에게 알리기 위해 옵서버 패턴을 사용할 수 있으며, 캐릭터에 특별 능력을 추가하기 위해 데코레이터 패턴을 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Factory Pattern\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eCharacterFactory\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecreateCharacter\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etype\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e character;\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (type === \u003cspan class=\"hljs-string\"\u003e'Warrior'\u003c/span\u003e) {\n      character = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWarrior\u003c/span\u003e();\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (type === \u003cspan class=\"hljs-string\"\u003e'Mage'\u003c/span\u003e) {\n      character = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMage\u003c/span\u003e();\n    }\n\n    character.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e = type;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e character;\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Observer Pattern\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCharacter\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003ehit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// Notify all observers\u003c/span\u003e\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Decorator Pattern\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eEnhancedCharacter\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003echaracter, ability\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003echaracter\u003c/span\u003e = character;\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eability\u003c/span\u003e = ability;\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eEnhancedCharacter\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003euseAbility\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Using ability: \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.ability}\u003c/span\u003e`\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese examples demonstrate the power of combining different design patterns to create a flexible and scalable solution, but remember: the key is not to force the use of patterns, it’s to identify when a pattern can improve code quality and maintainability.\u003c/p\u003e\n\u003ch1\u003eDesign Patterns를 사용할 때 피해야 할 함정\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_4.png\" alt=\"Design Patterns\"\u003e\u003c/p\u003e\n\u003cp\u003e디자인 패턴은 소프트웨어 개발 프로세스에서 중대한 차이를 만들어낼 수 있지만, 모든 도구와 마찬가지로 신중하게 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003e다음은 피해야 할 몇 가지 일반적인 함정입니다:\u003c/p\u003e\n\u003ch2\u003e디자인 패턴 과용\u003c/h2\u003e\n\u003cp\u003e디자인 패턴은 흔한 문제에 대한 해결책이지만, 모든 소프트웨어 개발 고민의 치료약은 아니기 때문에 필요하지 않은 곳에 사용하면 불필요하게 복잡하고 난해한 코드로 이어질 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e디자인 패턴 오용\u003c/h2\u003e\n\u003cp\u003e각 디자인 패턴은 빛을 발하는 특정 시나리오가 있으며, 그것이 맞지 않는 문맥에서 사용하면 혼란스럽고 유지보수하기 어려운 코드로 이어질 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e패턴을 완전히 이해하지 못한 경우\u003c/h2\u003e\n\u003cp\u003e디자인 패턴을 사용하기 전에 그 구조, 목적 및 영향을 완전히 이해하는 것이 중요합니다. 이해하지 못하면 잘못된 구현 및 디버깅하기 어려운 버그로 이어질 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e간단함의 원칙을 무시하다\u003c/h2\u003e\n\u003cp\u003eKISS (Keep It Simple, Stupid) 원칙은 소프트웨어 개발에서 중요한 요소이며 항상 강조하는 편입니다: 때로는 복잡한 디자인 패턴보다 간단한 절차적 해결책이 더 적합할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e요약 및 권장 사항\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_5.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e본질적으로 디자인 패턴은 반복되는 코딩 문제에 효율적인 해결책을 제공합니다. 그러나 이를 남용하지 않는 것이 중요합니다. 남용하거나 이해없이 적용하면 코드가 불필요하게 복잡해질 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e추가 학습\u003c/h2\u003e\n\u003cp\u003e지속적인 학습과 능력 향상을 위해 다양한 디자인 패턴을 실험하고, 강점과 약점을 이해하며 효율적으로 사용할 수 있는 방법을 찾아보세요.\u003c/p\u003e\n\u003cp\u003e자바스크립트에 더 깊이 파고들고 싶은 분들을 위해, 저의 라이브러리에서 이 글들을 추천합니다: \"JavaScript 오브젝트 구조 분해와 스프레드 구문 활용: Use Case 및 Best Practice\" 그리고 \"JavaScript Promises: 에러 처리와 Best Practice에 대한 깊은 탐구\"\u003c/p\u003e\n\u003cp\u003e두 기사 모두 JavaScript의 특정 측면에 대한 실용적인 통찰을 제공하여 디자인 패턴과 같이 개발 작업을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e항상 여러분의 이야기를 듣는 것에 흥미가 있어요. 댓글에서 여러분의 생각, 경험 또는 질문을 공유해주세요. 우리는 서로서로에서 배우고, 여러분의 통찰은 커뮤니티에 도움이 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003ePlainEnglish.io에서 더 많은 콘텐츠를 만나보세요.\u003c/p\u003e\n\u003cp\u003e우리의 무료 주간 뉴스레터를 구독하세요. 트위터, 링크드인, 유튜브, 디스코드에서도 팔로우하세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-DesignPatternsAGuidetoJavaScriptDevelopmentPrinciplesforCleanandScalableCode"},"buildId":"6w6Yg3qJxLtqeXNguENru","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>