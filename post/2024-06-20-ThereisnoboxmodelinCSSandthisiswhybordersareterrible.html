<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>CSS에서는 박스 모델이 없습니다 - 그래서 테두리가 좋지 않은 이유 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="CSS에서는 박스 모델이 없습니다 - 그래서 테두리가 좋지 않은 이유 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="CSS에서는 박스 모델이 없습니다 - 그래서 테두리가 좋지 않은 이유 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible" data-gatsby-head="true"/><meta name="twitter:title" content="CSS에서는 박스 모델이 없습니다 - 그래서 테두리가 좋지 않은 이유 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 00:58" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">CSS에서는 박스 모델이 없습니다 - 그래서 테두리가 좋지 않은 이유</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="CSS에서는 박스 모델이 없습니다 - 그래서 테두리가 좋지 않은 이유" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>자바스크립트UI — 개발 블로그 #7</h2>
<p>“이제 좀, 너무하지 마. 모두가 박스 모델이 CSS의 기반이라는 것을 알아. 넌 대체 뭘 얘기하고 있어?”</p>
<p>음, 그런 식으로 말하기는 싫지만, 이건 박스야:</p>
<p><img src="/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_0.png" alt="box"></p>
<div class="content-ad"></div>
<p>그리고 이것이 사각형입니다:</p>
<p><img src="/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_1.png" alt="Rectangle"></p>
<p>음, 사실은 여러 개의 직사각형이지만, 확실히 상자는 아닙니다. "사각형 모델"이라고 부르면 그렇게 멋있어 보이진 않겠지만, 정말로 일을 훨씬 쉽게 만들어줄 거에요.</p>
<p>사실, 더 자세히 살펴보면 상자와 사각형 사이에 뚜렷한 차이를 느낄 수 있을 거에요: 하나는 3차원이고 다른 하나는 완전히 평면입니다. 무언가를 "상자"라고 부르면 사람들은 자연스럽게 3차원적인 것을 기대할 테지만, CSS는 모든 것을 2차원으로 평평하게 만들려고 최선을 다합니다.</p>
<div class="content-ad"></div>
<p>이 불일치로 웹 레이아웃과 사용자 인터페이스를 구축하는 데 심각한 결과가 발생했습니다. 이 중 하나는 CSS에서 적절한 테두리를 적용할 수 없는 것입니다. 이것은 테두리가 문서 내로 펼쳐지기 때문입니다. 이것만으로도 CSS "박스" 모델이 근본적으로 깨진 이유를 보여줍니다.</p>
<p>이유를 살펴보겠습니다.</p>
<h2>셋 중에서 하나</h2>
<p>CSS "박스" 모델의 핵심에는 세 가지 개념이 있습니다: 마진 "박스", 테두리 "박스" 및 패딩 "박스"가 있습니다. 간단해 보이죠? 그렇지만, CSS에서 테두리는 항상 레이아웃의 일부인데 실제로는 그렇지 않아야 합니다. 이것이 두 가지 중요한 문제를 일으킵니다:</p>
<div class="content-ad"></div>
<ul>
<li>어떤 요소의 크기가 애매해집니다</li>
<li>테두리의 너비가 변경될 때마다 레이아웃이 바뀌게 됩니다.</li>
</ul>
<p>첫 번째 문제를 해결하기 위해 CSS에서는 box-sizing 속성을 소개했습니다. 이 속성을 border-box로 설정하면 요소의 크기에 테두리의 너비가 포함되고 content-box로 설정하면 포함되지 않습니다. 문제 해결되었죠, 맞나요?</p>
<p>다시 한 번 틀렸습니다. 아마도 제가 깐깐한 편이겠지만, 이 모델에서 content-box란 존재하지 않습니다. 여기에는 margin "상자", border "상자", 그리고 padding "상자"가 있습니다. padding "상자"가 이미 우리가 원하는 것(테두리는 제외하고 padding은 포함하는 크기)을 전달하고 있기 때문에, 왜 이것을 content-box라고 부르는지 정말 이해가 안 가요. 오히려, 직관적으로는 이것이 padding "상자" 안의 영역(네 번째 "상자")일 것이라고 생각할 텐데요.</p>
<p>그래도 두 번째 문제가 남아있습니다: 레이아웃이 바뀌는 문제입니다. box-sizing에 관계없이 레이아웃이 계속 바뀝니다. 그저 "상자" 내부의 모든 것을 엉망으로 만들 지, 바깥쪽 모든 것을 엉망으로 만들 지를 선택할 수 있을 뿐입니다. 버튼에 호버 효과를 추가할 때 테두리를 넣어보는 단순한 예제를 살펴보세요:</p>
<div class="content-ad"></div>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*ayv0dXb1OsnY0qv6EaxxUQ.gif" alt="Image"></p>
<p>아래는 이를 달성하는 코드입니다.:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Stack</span>(
    <span class="hljs-title class_">Button</span>(<span class="hljs-string">`Border "box"`</span>)
        .<span class="hljs-title function_">css</span>(<span class="hljs-string">"box-sizing"</span>, <span class="hljs-string">"border-box"</span>)
        .<span class="hljs-title function_">width</span>(<span class="hljs-number">150</span>)
        .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)
        .<span class="hljs-title function_">cornerRadius</span>(<span class="hljs-number">25</span>)
        .<span class="hljs-title function_">css</span>(<span class="hljs-string">"text-align"</span>, <span class="hljs-string">"center"</span>) <span class="hljs-comment">//수평 정렬</span>
        .<span class="hljs-title function_">css</span>(<span class="hljs-string">"line-height"</span>, <span class="hljs-string">"50px"</span>) <span class="hljs-comment">//수직 정렬 요령</span>
        .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">"#027FFC"</span>)
        .<span class="hljs-title function_">onMouseOver</span>(<span class="hljs-function"><span class="hljs-params">self</span> =></span> self.<span class="hljs-title function_">border</span>(<span class="hljs-string">"2px solid black"</span>))
        .<span class="hljs-title function_">onMouseOut</span>(<span class="hljs-function"><span class="hljs-params">self</span> =></span> self.<span class="hljs-title function_">border</span>(<span class="hljs-string">"none"</span>)),
        
    <span class="hljs-title class_">Button</span>(<span class="hljs-string">`Content "box"`</span>)
        .<span class="hljs-title function_">css</span>(<span class="hljs-string">"box-sizing"</span>, <span class="hljs-string">"content-box"</span>)
        .<span class="hljs-title function_">width</span>(<span class="hljs-number">150</span>)
        .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)
        .<span class="hljs-title function_">cornerRadius</span>(<span class="hljs-number">25</span>)
        .<span class="hljs-title function_">css</span>(<span class="hljs-string">"text-align"</span>, <span class="hljs-string">"center"</span>) <span class="hljs-comment">//수평 정렬</span>
        .<span class="hljs-title function_">css</span>(<span class="hljs-string">"line-height"</span>, <span class="hljs-string">"50px"</span>) <span class="hljs-comment">//수직 정렬 요령</span>
        .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">"#027FFC"</span>)
        .<span class="hljs-title function_">onMouseOver</span>(<span class="hljs-function"><span class="hljs-params">self</span> =></span> self.<span class="hljs-title function_">border</span>(<span class="hljs-string">"2px solid black"</span>))
        .<span class="hljs-title function_">onMouseOut</span>(<span class="hljs-function"><span class="hljs-params">self</span> =></span> self.<span class="hljs-title function_">border</span>(<span class="hljs-string">"none"</span>))
)
    .<span class="hljs-title function_">width</span>(<span class="hljs-number">680</span>)
    .<span class="hljs-title function_">height</span>(<span class="hljs-number">500</span>)
    .<span class="hljs-title function_">gapX</span>(<span class="hljs-number">20</span>)
    .<span class="hljs-title function_">css</span>(<span class="hljs-string">"justify-content"</span>, <span class="hljs-string">"center"</span>) <span class="hljs-comment">//수평 정렬</span>
    .<span class="hljs-title function_">css</span>(<span class="hljs-string">"align-items"</span>, <span class="hljs-string">"center"</span>); <span class="hljs-comment">//수직 정렬</span>
</code></pre>
<p>이는 일반적이고 상대적으로 간단한 레이아웃 상황입니다: 동일한 크기의 두 버튼을 만들어 호버 시 2px 폭의 검은 실선 테두리를 추가합니다. border-box를 사용하면 버튼 내부의 레이아웃이 깨지고 content-box를 사용하면 주변에 레이아웃이 깨집니다. 이보다 더 기본적인 예제를 찾기 어려울 것이며, 심지어 여기서도 "box" 모델이 완전히 붕괴됩니다.</p>
<div class="content-ad"></div>
<p>이 문제는 단순한 픽셀 조정이라고 속시원하게 말할 수 있지만, 시각 장애나 인지 장애를 가진 사람들에게는 중요한 접근성 문제입니다. 그리고 어떤 요소에도 동적으로 테두리를 설정할 때 이 문제가 널리 발생합니다.</p>
<h2>꿍꿍이, 해킹, 하지만 진짜 해결책은 없다</h2>
<p>불행히도, 이 문제에 대한 좋은 해결책은 없습니다. 도리어 크리에이티브한 꿍꿍이와 비겁한 해킹이 많이 있지만, 이러한 해결책들은 심각한 단점 없이는 작동하지 않습니다:</p>
<ul>
<li>배경과 동일한 스타일링을 사용하는 유휴 상태의 플레이스홀더 테두리를 추가하고 테두리의 존재 여부를 토글하는 대신 이러한 스타일을 모두 테두리에 적용: 이 방법은 우리 코드의 의미적 성격을 파괴하며 단일 테두리 속성 대신 여러 값을 변경해야 하며 배경의 스타일 복잡성이 증가할수록(투명도, 백드롭 필터, 유휴 및 호버 상태 이상) 점점 복잡해집니다. 또한 CSS로 가운데 테두리를 구현할 수 없습니다 (이 후에 이에 대해 언급할 것이고) (또한 CSS로 가운데 정렬은 왜 거의 어디서나 끔찍한가요?)</li>
<li>패딩을 사용하여 유휴 테두리를 가짜로 만들기: 이 또한 의미론적으로 적합하지 않고, 단일 테두리 속성 대신 여러 값을 토글해야 하며 가운데 "테두리"가 없습니다 (내부 또는 외부만 가능)</li>
<li>아웃라인을 사용하여 테두리를 가짜로 만들기: 다시한번 의미론적 해결책이 아닌 다른 도구를 사용하며 이미 목적이 있고, 코드가 혼란스럽게 만들어지며 가운데 "테두리"가 없습니다 (내부 또는 외부만 가능)</li>
<li>드롭 섀도우를 사용하여 테두리를 가짜로 만들기: 동일한 문제가 있으며, 의미론적이 아니며, 목적이 다르며, 깔끔하지 않으며, 가운데 "테두리"가 없습니다 (내부 또는 외부만 가능)</li>
<li>일반 요소나 svg 사각형을 기존 요소 위에 추가하여 테두리 역할을 하는 요소로 사용: 의미론적이 아니며, 스타일링뿐만 아니라 뷰 트리(html 계층 구조)를 불필요하게 늘려주며 (예: 둥근 모서리?), CSS에서 요소를 겹치는 것은 일반적으로 고통스럽지만 적어도 가운데 정렬할 수 있습니다 (내부 또는 외부만 가능)</li>
<li>명시적인 대신 상대적인 크기 사용: 두 개 이상의 버튼 너비를 일치시킬 수 없으며, 항상 콘텐츠 상자처럼 동작하기 때문에 모든 것이 외부로 커져 (버튼 내의 레이아웃 변화하는 문제를 포함시킬 수 없게됩니다), 여전히 가운데 테두리가 없습니다. (외부만 가능)</li>
</ul>
<div class="content-ad"></div>
<p>무엇을 시도해도 "해결책"은 추해고 부자연스럽며 번거로울 것입니다. 이렇게 쉬운 것조차도 이렇게 불행스러울 때, 우리는 어떻게 효율적으로 가치 있는 것을 구축할 것을 기대할 수 있을까요? 그리고 이것이 CSS의 핵심입니다는 것을 염두에 두세요.</p>
<h2>개요</h2>
<p>우리는 실제로 직사각형 모델인 상자 모델이 있고, 실제로는 패딩 상자인 content-box가 있습니다. 레이아웃을 망치치 않고 테두리를 추가할 수 없습니다. 우리는 배경 스타일과 일치하는 placeholder 테두리를 사용하도록 강요당하며, 이 기본적인 문제를 해결하기 위해 패딩, 외곽선 또는 그림자를 사용하여 가짜 테두리를 추가하거나 다른 겹치는 요소를 사용해야 합니다. 그럼에도 불구하고, 여전히 중앙에 테두리를 넣을 수 없습니다. 붕출(outset) 또는 삽입(inset)만 가능합니다. 그리고 CSS가 가파른 학습 곡선을 갖는 이유에 궁금해할 수도 있습니다.</p>
<h2>다른 차원에서 참된 해결책</h2>
<div class="content-ad"></div>
<p>기본 CSS "박스" 모델이 그렇게 나쁘다면 올바른 접근 방식은 무엇인가요?</p>
<p>쉬워요: "박스" 모델에서 테두리를 제거하고 우리 요소 위에 배치하세요. 테두리를 내용, 여백 및 안쪽 여백과 함께 같은 평면으로 펴야 할 필요는 전혀 없어요. 우리는 단순히 세 번째 차원을 활용해야 해요. 정상적인 시각 디자인 소프트웨어가 동작하는 방식처럼요:</p>
<p><img src="/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_2.png" alt="이미지1"></p>
<p><img src="/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_3.png" alt="이미지2"></p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_4.png" alt="image"></p>
<p>이 모델에서는 테두리(border)를 inset/inside 또는 outset/outside로 설정해도 실제 내용 위에 다른 레이어로 렌더링됩니다. 테두리는 레이아웃에 영향을 미치지 않아야 합니다.</p>
<h2>결과</h2>
<p>이 접근 방식을 사용하면 단일하고 명확한 요소 크기를 얻을 수 있으며, 레이아웃에 영향을 주지 않고 테두리를 어떤 방식으로든 변경할 수 있습니다. 심지어 테두리를 제대로 정렬할 수도 있습니다. 갑자기 모든 해킹, box-sizing 및 content-box와 같은 불필요한 개념이 완전히 워크플로우에서 제거되고 이제 Box Model이라는 이름도 약간 더 의미를 갖게 됩니다.</p>
<div class="content-ad"></div>
<p>하지만 이 모든 것 위에 엄청난 추가 혜택이 하나 더 있는데, 이제 디자인 (특히 그래픽 디자인) 및 웹 개발팀이 같은 언어를 구사할 수 있다는 것입니다. 마찰도 없고 번복도 없습니다. 웹이 다른 모든 것과 마찬가지로 작동하는 것이다. 항상 모든 가능한 방법을 다시 창조하는 것이 아닌 것이다.</p>
<p><img src="/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_5.png" alt="image"></p>
<h2>결론</h2>
<p>CSS "박스" 모델이라는 용어는 3차원으로 작업할 수 있다는 것을 시사하는 것이 틀림없고 오해를 불러일으킨다. 실제로, 심지어 겹치는 테두리를 구현하는 것조차 거의 불가능하다. 모든 가능한 해결책은 매우 제한적이며 문제를 더 많이 일으키는 경우가 훨씬 많다. 웹 레이아웃에서 테두리를 제거하면 레이아웃 자체뿐만 아니라 작업하기가 훨씬 편리해지며 그래픽 디자인과 웹 개발 간의 간격을 줄일 수 있습니다. 불행히도, JavaScriptUI에서 수용할만한 해결책을 찾지 못했지만, 해결책이 떠오르면 댓글 섹션에서 공유해주세요.</p>
<div class="content-ad"></div>
<p>테이블 태그를 Markdown 형식으로 변경하세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"CSS에서는 박스 모델이 없습니다 - 그래서 테두리가 좋지 않은 이유","description":"","date":"2024-06-20 00:58","slug":"2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible","content":"\n\n## 자바스크립트UI — 개발 블로그 #7\n\n“이제 좀, 너무하지 마. 모두가 박스 모델이 CSS의 기반이라는 것을 알아. 넌 대체 뭘 얘기하고 있어?”\n\n음, 그런 식으로 말하기는 싫지만, 이건 박스야:\n\n![box](/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 이것이 사각형입니다:\n\n![Rectangle](/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_1.png)\n\n음, 사실은 여러 개의 직사각형이지만, 확실히 상자는 아닙니다. \"사각형 모델\"이라고 부르면 그렇게 멋있어 보이진 않겠지만, 정말로 일을 훨씬 쉽게 만들어줄 거에요.\n\n사실, 더 자세히 살펴보면 상자와 사각형 사이에 뚜렷한 차이를 느낄 수 있을 거에요: 하나는 3차원이고 다른 하나는 완전히 평면입니다. 무언가를 \"상자\"라고 부르면 사람들은 자연스럽게 3차원적인 것을 기대할 테지만, CSS는 모든 것을 2차원으로 평평하게 만들려고 최선을 다합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 불일치로 웹 레이아웃과 사용자 인터페이스를 구축하는 데 심각한 결과가 발생했습니다. 이 중 하나는 CSS에서 적절한 테두리를 적용할 수 없는 것입니다. 이것은 테두리가 문서 내로 펼쳐지기 때문입니다. 이것만으로도 CSS \"박스\" 모델이 근본적으로 깨진 이유를 보여줍니다.\n\n이유를 살펴보겠습니다.\n\n## 셋 중에서 하나\n\nCSS \"박스\" 모델의 핵심에는 세 가지 개념이 있습니다: 마진 \"박스\", 테두리 \"박스\" 및 패딩 \"박스\"가 있습니다. 간단해 보이죠? 그렇지만, CSS에서 테두리는 항상 레이아웃의 일부인데 실제로는 그렇지 않아야 합니다. 이것이 두 가지 중요한 문제를 일으킵니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 어떤 요소의 크기가 애매해집니다\n- 테두리의 너비가 변경될 때마다 레이아웃이 바뀌게 됩니다.\n\n첫 번째 문제를 해결하기 위해 CSS에서는 box-sizing 속성을 소개했습니다. 이 속성을 border-box로 설정하면 요소의 크기에 테두리의 너비가 포함되고 content-box로 설정하면 포함되지 않습니다. 문제 해결되었죠, 맞나요?\n\n다시 한 번 틀렸습니다. 아마도 제가 깐깐한 편이겠지만, 이 모델에서 content-box란 존재하지 않습니다. 여기에는 margin \"상자\", border \"상자\", 그리고 padding \"상자\"가 있습니다. padding \"상자\"가 이미 우리가 원하는 것(테두리는 제외하고 padding은 포함하는 크기)을 전달하고 있기 때문에, 왜 이것을 content-box라고 부르는지 정말 이해가 안 가요. 오히려, 직관적으로는 이것이 padding \"상자\" 안의 영역(네 번째 \"상자\")일 것이라고 생각할 텐데요.\n\n그래도 두 번째 문제가 남아있습니다: 레이아웃이 바뀌는 문제입니다. box-sizing에 관계없이 레이아웃이 계속 바뀝니다. 그저 \"상자\" 내부의 모든 것을 엉망으로 만들 지, 바깥쪽 모든 것을 엉망으로 만들 지를 선택할 수 있을 뿐입니다. 버튼에 호버 효과를 추가할 때 테두리를 넣어보는 단순한 예제를 살펴보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*ayv0dXb1OsnY0qv6EaxxUQ.gif)\n\n아래는 이를 달성하는 코드입니다.:\n\n```js\nStack(\n    Button(`Border \"box\"`)\n        .css(\"box-sizing\", \"border-box\")\n        .width(150)\n        .height(50)\n        .cornerRadius(25)\n        .css(\"text-align\", \"center\") //수평 정렬\n        .css(\"line-height\", \"50px\") //수직 정렬 요령\n        .backgroundColor(\"#027FFC\")\n        .onMouseOver(self =\u003e self.border(\"2px solid black\"))\n        .onMouseOut(self =\u003e self.border(\"none\")),\n        \n    Button(`Content \"box\"`)\n        .css(\"box-sizing\", \"content-box\")\n        .width(150)\n        .height(50)\n        .cornerRadius(25)\n        .css(\"text-align\", \"center\") //수평 정렬\n        .css(\"line-height\", \"50px\") //수직 정렬 요령\n        .backgroundColor(\"#027FFC\")\n        .onMouseOver(self =\u003e self.border(\"2px solid black\"))\n        .onMouseOut(self =\u003e self.border(\"none\"))\n)\n    .width(680)\n    .height(500)\n    .gapX(20)\n    .css(\"justify-content\", \"center\") //수평 정렬\n    .css(\"align-items\", \"center\"); //수직 정렬\n```\n\n이는 일반적이고 상대적으로 간단한 레이아웃 상황입니다: 동일한 크기의 두 버튼을 만들어 호버 시 2px 폭의 검은 실선 테두리를 추가합니다. border-box를 사용하면 버튼 내부의 레이아웃이 깨지고 content-box를 사용하면 주변에 레이아웃이 깨집니다. 이보다 더 기본적인 예제를 찾기 어려울 것이며, 심지어 여기서도 \"box\" 모델이 완전히 붕괴됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제는 단순한 픽셀 조정이라고 속시원하게 말할 수 있지만, 시각 장애나 인지 장애를 가진 사람들에게는 중요한 접근성 문제입니다. 그리고 어떤 요소에도 동적으로 테두리를 설정할 때 이 문제가 널리 발생합니다.\n\n## 꿍꿍이, 해킹, 하지만 진짜 해결책은 없다\n\n불행히도, 이 문제에 대한 좋은 해결책은 없습니다. 도리어 크리에이티브한 꿍꿍이와 비겁한 해킹이 많이 있지만, 이러한 해결책들은 심각한 단점 없이는 작동하지 않습니다:\n\n- 배경과 동일한 스타일링을 사용하는 유휴 상태의 플레이스홀더 테두리를 추가하고 테두리의 존재 여부를 토글하는 대신 이러한 스타일을 모두 테두리에 적용: 이 방법은 우리 코드의 의미적 성격을 파괴하며 단일 테두리 속성 대신 여러 값을 변경해야 하며 배경의 스타일 복잡성이 증가할수록(투명도, 백드롭 필터, 유휴 및 호버 상태 이상) 점점 복잡해집니다. 또한 CSS로 가운데 테두리를 구현할 수 없습니다 (이 후에 이에 대해 언급할 것이고) (또한 CSS로 가운데 정렬은 왜 거의 어디서나 끔찍한가요?)\n- 패딩을 사용하여 유휴 테두리를 가짜로 만들기: 이 또한 의미론적으로 적합하지 않고, 단일 테두리 속성 대신 여러 값을 토글해야 하며 가운데 \"테두리\"가 없습니다 (내부 또는 외부만 가능)\n- 아웃라인을 사용하여 테두리를 가짜로 만들기: 다시한번 의미론적 해결책이 아닌 다른 도구를 사용하며 이미 목적이 있고, 코드가 혼란스럽게 만들어지며 가운데 \"테두리\"가 없습니다 (내부 또는 외부만 가능)\n- 드롭 섀도우를 사용하여 테두리를 가짜로 만들기: 동일한 문제가 있으며, 의미론적이 아니며, 목적이 다르며, 깔끔하지 않으며, 가운데 \"테두리\"가 없습니다 (내부 또는 외부만 가능)\n- 일반 요소나 svg 사각형을 기존 요소 위에 추가하여 테두리 역할을 하는 요소로 사용: 의미론적이 아니며, 스타일링뿐만 아니라 뷰 트리(html 계층 구조)를 불필요하게 늘려주며 (예: 둥근 모서리?), CSS에서 요소를 겹치는 것은 일반적으로 고통스럽지만 적어도 가운데 정렬할 수 있습니다 (내부 또는 외부만 가능)\n- 명시적인 대신 상대적인 크기 사용: 두 개 이상의 버튼 너비를 일치시킬 수 없으며, 항상 콘텐츠 상자처럼 동작하기 때문에 모든 것이 외부로 커져 (버튼 내의 레이아웃 변화하는 문제를 포함시킬 수 없게됩니다), 여전히 가운데 테두리가 없습니다. (외부만 가능)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n무엇을 시도해도 \"해결책\"은 추해고 부자연스럽며 번거로울 것입니다. 이렇게 쉬운 것조차도 이렇게 불행스러울 때, 우리는 어떻게 효율적으로 가치 있는 것을 구축할 것을 기대할 수 있을까요? 그리고 이것이 CSS의 핵심입니다는 것을 염두에 두세요.\n\n## 개요\n\n우리는 실제로 직사각형 모델인 상자 모델이 있고, 실제로는 패딩 상자인 content-box가 있습니다. 레이아웃을 망치치 않고 테두리를 추가할 수 없습니다. 우리는 배경 스타일과 일치하는 placeholder 테두리를 사용하도록 강요당하며, 이 기본적인 문제를 해결하기 위해 패딩, 외곽선 또는 그림자를 사용하여 가짜 테두리를 추가하거나 다른 겹치는 요소를 사용해야 합니다. 그럼에도 불구하고, 여전히 중앙에 테두리를 넣을 수 없습니다. 붕출(outset) 또는 삽입(inset)만 가능합니다. 그리고 CSS가 가파른 학습 곡선을 갖는 이유에 궁금해할 수도 있습니다.\n\n## 다른 차원에서 참된 해결책\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 CSS \"박스\" 모델이 그렇게 나쁘다면 올바른 접근 방식은 무엇인가요?\n\n쉬워요: \"박스\" 모델에서 테두리를 제거하고 우리 요소 위에 배치하세요. 테두리를 내용, 여백 및 안쪽 여백과 함께 같은 평면으로 펴야 할 필요는 전혀 없어요. 우리는 단순히 세 번째 차원을 활용해야 해요. 정상적인 시각 디자인 소프트웨어가 동작하는 방식처럼요:\n\n![이미지1](/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_2.png)\n\n![이미지2](/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_4.png)\n\n이 모델에서는 테두리(border)를 inset/inside 또는 outset/outside로 설정해도 실제 내용 위에 다른 레이어로 렌더링됩니다. 테두리는 레이아웃에 영향을 미치지 않아야 합니다.\n\n## 결과\n\n이 접근 방식을 사용하면 단일하고 명확한 요소 크기를 얻을 수 있으며, 레이아웃에 영향을 주지 않고 테두리를 어떤 방식으로든 변경할 수 있습니다. 심지어 테두리를 제대로 정렬할 수도 있습니다. 갑자기 모든 해킹, box-sizing 및 content-box와 같은 불필요한 개념이 완전히 워크플로우에서 제거되고 이제 Box Model이라는 이름도 약간 더 의미를 갖게 됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 이 모든 것 위에 엄청난 추가 혜택이 하나 더 있는데, 이제 디자인 (특히 그래픽 디자인) 및 웹 개발팀이 같은 언어를 구사할 수 있다는 것입니다. 마찰도 없고 번복도 없습니다. 웹이 다른 모든 것과 마찬가지로 작동하는 것이다. 항상 모든 가능한 방법을 다시 창조하는 것이 아닌 것이다.\n\n![image](/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_5.png)\n\n## 결론\n\nCSS \"박스\" 모델이라는 용어는 3차원으로 작업할 수 있다는 것을 시사하는 것이 틀림없고 오해를 불러일으킨다. 실제로, 심지어 겹치는 테두리를 구현하는 것조차 거의 불가능하다. 모든 가능한 해결책은 매우 제한적이며 문제를 더 많이 일으키는 경우가 훨씬 많다. 웹 레이아웃에서 테두리를 제거하면 레이아웃 자체뿐만 아니라 작업하기가 훨씬 편리해지며 그래픽 디자인과 웹 개발 간의 간격을 줄일 수 있습니다. 불행히도, JavaScriptUI에서 수용할만한 해결책을 찾지 못했지만, 해결책이 떠오르면 댓글 섹션에서 공유해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경하세요.","ogImage":{"url":"/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_0.png"},"coverImage":"/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e자바스크립트UI — 개발 블로그 #7\u003c/h2\u003e\n\u003cp\u003e“이제 좀, 너무하지 마. 모두가 박스 모델이 CSS의 기반이라는 것을 알아. 넌 대체 뭘 얘기하고 있어?”\u003c/p\u003e\n\u003cp\u003e음, 그런 식으로 말하기는 싫지만, 이건 박스야:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_0.png\" alt=\"box\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그리고 이것이 사각형입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_1.png\" alt=\"Rectangle\"\u003e\u003c/p\u003e\n\u003cp\u003e음, 사실은 여러 개의 직사각형이지만, 확실히 상자는 아닙니다. \"사각형 모델\"이라고 부르면 그렇게 멋있어 보이진 않겠지만, 정말로 일을 훨씬 쉽게 만들어줄 거에요.\u003c/p\u003e\n\u003cp\u003e사실, 더 자세히 살펴보면 상자와 사각형 사이에 뚜렷한 차이를 느낄 수 있을 거에요: 하나는 3차원이고 다른 하나는 완전히 평면입니다. 무언가를 \"상자\"라고 부르면 사람들은 자연스럽게 3차원적인 것을 기대할 테지만, CSS는 모든 것을 2차원으로 평평하게 만들려고 최선을 다합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 불일치로 웹 레이아웃과 사용자 인터페이스를 구축하는 데 심각한 결과가 발생했습니다. 이 중 하나는 CSS에서 적절한 테두리를 적용할 수 없는 것입니다. 이것은 테두리가 문서 내로 펼쳐지기 때문입니다. 이것만으로도 CSS \"박스\" 모델이 근본적으로 깨진 이유를 보여줍니다.\u003c/p\u003e\n\u003cp\u003e이유를 살펴보겠습니다.\u003c/p\u003e\n\u003ch2\u003e셋 중에서 하나\u003c/h2\u003e\n\u003cp\u003eCSS \"박스\" 모델의 핵심에는 세 가지 개념이 있습니다: 마진 \"박스\", 테두리 \"박스\" 및 패딩 \"박스\"가 있습니다. 간단해 보이죠? 그렇지만, CSS에서 테두리는 항상 레이아웃의 일부인데 실제로는 그렇지 않아야 합니다. 이것이 두 가지 중요한 문제를 일으킵니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e어떤 요소의 크기가 애매해집니다\u003c/li\u003e\n\u003cli\u003e테두리의 너비가 변경될 때마다 레이아웃이 바뀌게 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e첫 번째 문제를 해결하기 위해 CSS에서는 box-sizing 속성을 소개했습니다. 이 속성을 border-box로 설정하면 요소의 크기에 테두리의 너비가 포함되고 content-box로 설정하면 포함되지 않습니다. 문제 해결되었죠, 맞나요?\u003c/p\u003e\n\u003cp\u003e다시 한 번 틀렸습니다. 아마도 제가 깐깐한 편이겠지만, 이 모델에서 content-box란 존재하지 않습니다. 여기에는 margin \"상자\", border \"상자\", 그리고 padding \"상자\"가 있습니다. padding \"상자\"가 이미 우리가 원하는 것(테두리는 제외하고 padding은 포함하는 크기)을 전달하고 있기 때문에, 왜 이것을 content-box라고 부르는지 정말 이해가 안 가요. 오히려, 직관적으로는 이것이 padding \"상자\" 안의 영역(네 번째 \"상자\")일 것이라고 생각할 텐데요.\u003c/p\u003e\n\u003cp\u003e그래도 두 번째 문제가 남아있습니다: 레이아웃이 바뀌는 문제입니다. box-sizing에 관계없이 레이아웃이 계속 바뀝니다. 그저 \"상자\" 내부의 모든 것을 엉망으로 만들 지, 바깥쪽 모든 것을 엉망으로 만들 지를 선택할 수 있을 뿐입니다. 버튼에 호버 효과를 추가할 때 테두리를 넣어보는 단순한 예제를 살펴보세요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*ayv0dXb1OsnY0qv6EaxxUQ.gif\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e아래는 이를 달성하는 코드입니다.:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eStack\u003c/span\u003e(\n    \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Border \"box\"`\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ecss\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"box-sizing\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"border-box\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ewidth\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e150\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003eheight\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ecornerRadius\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ecss\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"text-align\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"center\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e//수평 정렬\u003c/span\u003e\n        .\u003cspan class=\"hljs-title function_\"\u003ecss\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"line-height\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"50px\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e//수직 정렬 요령\u003c/span\u003e\n        .\u003cspan class=\"hljs-title function_\"\u003ebackgroundColor\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"#027FFC\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003eonMouseOver\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e =\u003e\u003c/span\u003e self.\u003cspan class=\"hljs-title function_\"\u003eborder\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"2px solid black\"\u003c/span\u003e))\n        .\u003cspan class=\"hljs-title function_\"\u003eonMouseOut\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e =\u003e\u003c/span\u003e self.\u003cspan class=\"hljs-title function_\"\u003eborder\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"none\"\u003c/span\u003e)),\n        \n    \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Content \"box\"`\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ecss\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"box-sizing\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content-box\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ewidth\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e150\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003eheight\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ecornerRadius\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003ecss\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"text-align\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"center\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e//수평 정렬\u003c/span\u003e\n        .\u003cspan class=\"hljs-title function_\"\u003ecss\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"line-height\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"50px\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e//수직 정렬 요령\u003c/span\u003e\n        .\u003cspan class=\"hljs-title function_\"\u003ebackgroundColor\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"#027FFC\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003eonMouseOver\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e =\u003e\u003c/span\u003e self.\u003cspan class=\"hljs-title function_\"\u003eborder\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"2px solid black\"\u003c/span\u003e))\n        .\u003cspan class=\"hljs-title function_\"\u003eonMouseOut\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e =\u003e\u003c/span\u003e self.\u003cspan class=\"hljs-title function_\"\u003eborder\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"none\"\u003c/span\u003e))\n)\n    .\u003cspan class=\"hljs-title function_\"\u003ewidth\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e680\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eheight\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003egapX\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003ecss\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"justify-content\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"center\"\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e//수평 정렬\u003c/span\u003e\n    .\u003cspan class=\"hljs-title function_\"\u003ecss\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"align-items\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"center\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e//수직 정렬\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이는 일반적이고 상대적으로 간단한 레이아웃 상황입니다: 동일한 크기의 두 버튼을 만들어 호버 시 2px 폭의 검은 실선 테두리를 추가합니다. border-box를 사용하면 버튼 내부의 레이아웃이 깨지고 content-box를 사용하면 주변에 레이아웃이 깨집니다. 이보다 더 기본적인 예제를 찾기 어려울 것이며, 심지어 여기서도 \"box\" 모델이 완전히 붕괴됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 문제는 단순한 픽셀 조정이라고 속시원하게 말할 수 있지만, 시각 장애나 인지 장애를 가진 사람들에게는 중요한 접근성 문제입니다. 그리고 어떤 요소에도 동적으로 테두리를 설정할 때 이 문제가 널리 발생합니다.\u003c/p\u003e\n\u003ch2\u003e꿍꿍이, 해킹, 하지만 진짜 해결책은 없다\u003c/h2\u003e\n\u003cp\u003e불행히도, 이 문제에 대한 좋은 해결책은 없습니다. 도리어 크리에이티브한 꿍꿍이와 비겁한 해킹이 많이 있지만, 이러한 해결책들은 심각한 단점 없이는 작동하지 않습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e배경과 동일한 스타일링을 사용하는 유휴 상태의 플레이스홀더 테두리를 추가하고 테두리의 존재 여부를 토글하는 대신 이러한 스타일을 모두 테두리에 적용: 이 방법은 우리 코드의 의미적 성격을 파괴하며 단일 테두리 속성 대신 여러 값을 변경해야 하며 배경의 스타일 복잡성이 증가할수록(투명도, 백드롭 필터, 유휴 및 호버 상태 이상) 점점 복잡해집니다. 또한 CSS로 가운데 테두리를 구현할 수 없습니다 (이 후에 이에 대해 언급할 것이고) (또한 CSS로 가운데 정렬은 왜 거의 어디서나 끔찍한가요?)\u003c/li\u003e\n\u003cli\u003e패딩을 사용하여 유휴 테두리를 가짜로 만들기: 이 또한 의미론적으로 적합하지 않고, 단일 테두리 속성 대신 여러 값을 토글해야 하며 가운데 \"테두리\"가 없습니다 (내부 또는 외부만 가능)\u003c/li\u003e\n\u003cli\u003e아웃라인을 사용하여 테두리를 가짜로 만들기: 다시한번 의미론적 해결책이 아닌 다른 도구를 사용하며 이미 목적이 있고, 코드가 혼란스럽게 만들어지며 가운데 \"테두리\"가 없습니다 (내부 또는 외부만 가능)\u003c/li\u003e\n\u003cli\u003e드롭 섀도우를 사용하여 테두리를 가짜로 만들기: 동일한 문제가 있으며, 의미론적이 아니며, 목적이 다르며, 깔끔하지 않으며, 가운데 \"테두리\"가 없습니다 (내부 또는 외부만 가능)\u003c/li\u003e\n\u003cli\u003e일반 요소나 svg 사각형을 기존 요소 위에 추가하여 테두리 역할을 하는 요소로 사용: 의미론적이 아니며, 스타일링뿐만 아니라 뷰 트리(html 계층 구조)를 불필요하게 늘려주며 (예: 둥근 모서리?), CSS에서 요소를 겹치는 것은 일반적으로 고통스럽지만 적어도 가운데 정렬할 수 있습니다 (내부 또는 외부만 가능)\u003c/li\u003e\n\u003cli\u003e명시적인 대신 상대적인 크기 사용: 두 개 이상의 버튼 너비를 일치시킬 수 없으며, 항상 콘텐츠 상자처럼 동작하기 때문에 모든 것이 외부로 커져 (버튼 내의 레이아웃 변화하는 문제를 포함시킬 수 없게됩니다), 여전히 가운데 테두리가 없습니다. (외부만 가능)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e무엇을 시도해도 \"해결책\"은 추해고 부자연스럽며 번거로울 것입니다. 이렇게 쉬운 것조차도 이렇게 불행스러울 때, 우리는 어떻게 효율적으로 가치 있는 것을 구축할 것을 기대할 수 있을까요? 그리고 이것이 CSS의 핵심입니다는 것을 염두에 두세요.\u003c/p\u003e\n\u003ch2\u003e개요\u003c/h2\u003e\n\u003cp\u003e우리는 실제로 직사각형 모델인 상자 모델이 있고, 실제로는 패딩 상자인 content-box가 있습니다. 레이아웃을 망치치 않고 테두리를 추가할 수 없습니다. 우리는 배경 스타일과 일치하는 placeholder 테두리를 사용하도록 강요당하며, 이 기본적인 문제를 해결하기 위해 패딩, 외곽선 또는 그림자를 사용하여 가짜 테두리를 추가하거나 다른 겹치는 요소를 사용해야 합니다. 그럼에도 불구하고, 여전히 중앙에 테두리를 넣을 수 없습니다. 붕출(outset) 또는 삽입(inset)만 가능합니다. 그리고 CSS가 가파른 학습 곡선을 갖는 이유에 궁금해할 수도 있습니다.\u003c/p\u003e\n\u003ch2\u003e다른 차원에서 참된 해결책\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e기본 CSS \"박스\" 모델이 그렇게 나쁘다면 올바른 접근 방식은 무엇인가요?\u003c/p\u003e\n\u003cp\u003e쉬워요: \"박스\" 모델에서 테두리를 제거하고 우리 요소 위에 배치하세요. 테두리를 내용, 여백 및 안쪽 여백과 함께 같은 평면으로 펴야 할 필요는 전혀 없어요. 우리는 단순히 세 번째 차원을 활용해야 해요. 정상적인 시각 디자인 소프트웨어가 동작하는 방식처럼요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_2.png\" alt=\"이미지1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_3.png\" alt=\"이미지2\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_4.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이 모델에서는 테두리(border)를 inset/inside 또는 outset/outside로 설정해도 실제 내용 위에 다른 레이어로 렌더링됩니다. 테두리는 레이아웃에 영향을 미치지 않아야 합니다.\u003c/p\u003e\n\u003ch2\u003e결과\u003c/h2\u003e\n\u003cp\u003e이 접근 방식을 사용하면 단일하고 명확한 요소 크기를 얻을 수 있으며, 레이아웃에 영향을 주지 않고 테두리를 어떤 방식으로든 변경할 수 있습니다. 심지어 테두리를 제대로 정렬할 수도 있습니다. 갑자기 모든 해킹, box-sizing 및 content-box와 같은 불필요한 개념이 완전히 워크플로우에서 제거되고 이제 Box Model이라는 이름도 약간 더 의미를 갖게 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e하지만 이 모든 것 위에 엄청난 추가 혜택이 하나 더 있는데, 이제 디자인 (특히 그래픽 디자인) 및 웹 개발팀이 같은 언어를 구사할 수 있다는 것입니다. 마찰도 없고 번복도 없습니다. 웹이 다른 모든 것과 마찬가지로 작동하는 것이다. 항상 모든 가능한 방법을 다시 창조하는 것이 아닌 것이다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible_5.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003eCSS \"박스\" 모델이라는 용어는 3차원으로 작업할 수 있다는 것을 시사하는 것이 틀림없고 오해를 불러일으킨다. 실제로, 심지어 겹치는 테두리를 구현하는 것조차 거의 불가능하다. 모든 가능한 해결책은 매우 제한적이며 문제를 더 많이 일으키는 경우가 훨씬 많다. 웹 레이아웃에서 테두리를 제거하면 레이아웃 자체뿐만 아니라 작업하기가 훨씬 편리해지며 그래픽 디자인과 웹 개발 간의 간격을 줄일 수 있습니다. 불행히도, JavaScriptUI에서 수용할만한 해결책을 찾지 못했지만, 해결책이 떠오르면 댓글 섹션에서 공유해주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e테이블 태그를 Markdown 형식으로 변경하세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-ThereisnoboxmodelinCSSandthisiswhybordersareterrible"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>