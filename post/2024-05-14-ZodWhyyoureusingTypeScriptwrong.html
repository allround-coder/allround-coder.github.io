<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>잠시만, 종 TypeScript를 잘못 사용하는 이유입니다 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-ZodWhyyoureusingTypeScriptwrong" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="잠시만, 종 TypeScript를 잘못 사용하는 이유입니다 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="잠시만, 종 TypeScript를 잘못 사용하는 이유입니다 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-ZodWhyyoureusingTypeScriptwrong" data-gatsby-head="true"/><meta name="twitter:title" content="잠시만, 종 TypeScript를 잘못 사용하는 이유입니다 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 13:35" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">잠시만, 종 TypeScript를 잘못 사용하는 이유입니다</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="잠시만, 종 TypeScript를 잘못 사용하는 이유입니다" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-ZodWhyyoureusingTypeScriptwrong&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png" alt="이미지"></p>
<p>간략 요약: 런타임에서 외부 데이터를 검증해야 합니다.</p>
<p>웹 개발 경험이 있다면, API에서 외부 데이터를 다룰 때 런타임 오류를 반드시 마주쳐보았을 것입니다. TypeScript를 사용하면 애플리케이션 전체에서 모든 데이터의 구조와 유형을 상기시켜 주어 이러한 오류를 크게 줄일 수 있습니다. 그러나 TypeScript는 컴파일 중에 알려진 데이터에 대한 불가능한 작업을 방지하는 데 강점을 가지고 있지만, 외부(다른 말로, 알 수 없는) 데이터에 대해서는 너무 관대할 수 있습니다.</p>
<p>본 문서에서는 TypeScript를 사용하여 런타임에서 실패할 수 있는 코드를 작성할 수 있게 하는 이유와 Zod가 이러한 데이터 관련 오류를 방지할 수 있는 방법에 대해 설명하겠습니다.</p>
<h1>TypeScript의 목표</h1>
<p>소개에서 말했듯이, TypeScript의 아이디어는 전체 코드에서 모든 데이터의 구조와 유형을 추적하는 것입니다. 이는 IDE에서 자동완성을 제공하는 데 도움이 되는 것뿐만 아니라 런타임 중에 오류를 일으킬 수있는 유효하지 않은 작업을 방지하기도 합니다. 이론적으로 TypeScript 컴파일 중에 발생할 수 있는 모든 런타임 오류를 예측하고 식별할 수 있습니다. 그러나 실제론 그렇지 않습니다.</p>
<h2>TypeScript는 목표를 달성하지 못했을까요?</h2>
<p>실제로 TypeScript의 주요 목표는 생산성을 향상시키는 것입니다. 이것은 TypeScript가 언제나 "안전"보다는 생산성을 선택한다는 것을 의미합니다.</p>
<p>있는 것은 any 타입입니다. 그러나 널리 받아들여지는 것은 사용하지 말아야 한다는 것입니다. 그러나 우리 코드에서 any를 하나도 쓰지 않는다고 해서 우리 애플리케이션이 런타임 오류에 면역이라는 뜻은 아닙니다. 다음 스니펫을 살펴보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-attr">obviouslyAnArticle</span>: <span class="hljs-title class_">Article</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(input); <span class="hljs-comment">// input is a string</span>
</code></pre>
<p>JSON.parse의 반환 타입이 any인데, 이는 명시적으로 타입이 지정된 변수(이 예에서는 Article)와 연관시킬 수 있습니다. 우리 자신으로부터 명시적으로 작성하지 않아도 TypeScript에게 우리가 any로 작성하지 않고도 파싱된 내용이 Article 타입을 충족하지 않을 수 있는 런타임 가능성을 무시하도록 알려주고 있는 것입니다.</p>
<h2>unknown 및 단언(assertions)</h2>
<p>만약 '어느' 대신 '모든'이 사용되었다면 위 조각을 만들 수 없었을 것입니다. 대신 as 키워드를 사용하여 명시적인 주장을 작성해야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> shouldBeAnArticle = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(input) <span class="hljs-keyword">as</span> <span class="hljs-title class_">Article</span>;
</code></pre>
<p>이 구문을 사용하면 TypeScript에게 명시적으로 경계를 낮추도록 지시합니다. 여전히 좋지 않지만 숨겨지지 않았어요!</p>
<h2>유형 좁히기 식</h2>
<p>위험한 유형 단언을 의존하는 대신, 유형 축소 표현식을 사용할 수 있어요.</p>
<p>예를 들어, JavaScript에서 제공하는 typeof 연산자는 객체의 유형을 런타임 중에 결정할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">42</span>);
<span class="hljs-comment">// 기대하는 출력: "number"</span>
</code></pre>
<p>조건문에서 사용되면 TypeScript는 객체의 유형을 축소할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> input === <span class="hljs-string">"string"</span>) {
    <span class="hljs-comment">// input이 문자열 형식으로 좁혀졌습니다.</span>
    <span class="hljs-title function_">submit</span>(input.<span class="hljs-title function_">toLowerCase</span>());
}
</code></pre>
<p>이 표현은 TypeScript에게 해당 범위에서 input이 문자열만 가능함을 예측할 수 있도록 해줍니다.</p>
<h2>타입 추론</h2>
<p>TypeScript는 다른 표현식들로 타입을 좁힐 수 있지만, 이는 보통 유니언 혹은 원시 타입을 구체화할 때 의미가 있습니다. 이를 "타입의 차별"이라고 부릅니다.</p>
<pre><code class="hljs language-js">type <span class="hljs-title class_">Fish</span> = { <span class="hljs-attr">swim</span>: <span class="hljs-function">() =></span> <span class="hljs-keyword">void</span> };
type <span class="hljs-title class_">Bird</span> = { <span class="hljs-attr">fly</span>: <span class="hljs-function">() =></span> <span class="hljs-keyword">void</span> };

<span class="hljs-keyword">function</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">animal: Fish | Bird</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-string">"swim"</span> <span class="hljs-keyword">in</span> animal) {
    <span class="hljs-comment">// input is narrowed to the type Fish</span>
    <span class="hljs-keyword">return</span> animal.<span class="hljs-title function_">swim</span>();
  }
  <span class="hljs-comment">// input is narrowed to the type Bird</span>
  <span class="hljs-keyword">return</span> animal.<span class="hljs-title function_">fly</span>();
}
</code></pre>
<p>위 예제에서 키워드 in은 TypeScript가 animal 객체의 유형을 식별하도록 합니다.</p>
<p>알 수 없는 데이터의 경우, 유형 판별은 시간 낭비일 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> input !== <span class="hljs-string">"string"</span>) {
    <span class="hljs-comment">// input is still unkown</span>
}
</code></pre>
<p>외부 데이터에 대해 유형 좁히기 표현식에만 의존할 수 없다는 뜻이에요. 유형을 좁히기 위한 또 다른 방법이 필요합니다: 데이터 유효성 검사.</p>
<h1>Zod가 도와줍니다</h1>
<p>Zod는 기본적으로 객체 스키마 유효성 검사 도구입니다. 이는 정의된 스키마를 가진 모든 객체의 유효성을 런타임에서 보장할 수 있다는 뜻이에요.</p>
<h2>스키마 선언</h2>
<p>Zod을 사용할 때 첫 번째 할 일은 스키마를 정의하는 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> z <span class="hljs-keyword">from</span> <span class="hljs-string">"zod"</span>;

<span class="hljs-keyword">const</span> userSchema = z.<span class="hljs-title function_">object</span>({
    <span class="hljs-attr">id</span>: z.<span class="hljs-title function_">number</span>(),
    <span class="hljs-attr">name</span>: z.<span class="hljs-title function_">string</span>(),
    <span class="hljs-attr">age</span>: z.<span class="hljs-title function_">number</span>().<span class="hljs-title function_">optional</span>()
}).<span class="hljs-title function_">strict</span>();
</code></pre>
<p>만약 이전에 yup이나 joi와 같은 유효성 검사 도구를 사용해본 적이 있다면, 이 방법에 익숙할지도 모릅니다. Zod은 object(), string()과 같은 여러 함수를 제공하며, 각 함수는 Zod 스키마를 반환하고 이를 조합하여 더 큰 스키마를 만들 수 있습니다.</p>
<p>각 스키마 조각은 .optional()과 같은 메소드를 사용하여 "새롭게 정의"될 수 있으며, 이를 통해 복잡한 유효성 검사 규칙을 얻을 수 있습니다.</p>
<h2>스키마 사용하기</h2>
<p>스키마는 데이터를 유효성 검사하는 두 가지 방법을 제공합니다. .parse() 메서드는 에러를 throw할 수 있고, .safeParse() 메서드도 그렇습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> result = userSchema.<span class="hljs-title function_">safeParse</span>(input);
<span class="hljs-keyword">if</span> (!result.<span class="hljs-property">success</span>) {
  result.<span class="hljs-property">error</span>;
} <span class="hljs-keyword">else</span> {
  result.<span class="hljs-property">data</span>; <span class="hljs-comment">// 데이터 유형은 userSchema에서 유추됩니다</span>
}
</code></pre>
<p>파싱이 실패하거나 정의된 유효성 검사 스키마와 일치하는 객체가 반환됩니다. 이 경우 객체는 스키마 구조에서 추론된 유형을 상속받습니다.</p>
<h2>스키마로부터 타입 추론하기</h2>
<p>일반적으로 데이터는 여러 범위와 문맥에서 공유됩니다. 이러한 이유로 우리는 보통 한번만 타입 별칭을 선언하고 나서 데이터가 전달되는 모든 곳에서 사용합니다. Zod는 z.infer`` 제네릭을 제공하여 스키마에서 추론된 타입에 액세스할 수 있습니다.</p>
<pre><code class="hljs language-js">type <span class="hljs-title class_">Article</span> = z.<span class="hljs-property">infer</span>&#x3C;<span class="hljs-keyword">typeof</span> articleSchema>;
</code></pre>
<h1>Zod 실용적 사용법</h1>
<p>따라서, TypeScript 프로젝트에서 Zod를 사용하는 경우는 어디인가요?</p>
<h2>API 응답 구문 분석</h2>
<p>알 수 없거나 예측할 수 없는 데이터의 주요 원천은 API 응답입니다. fetch promise에서 오는 데이터를 수동으로 유효성을 검사할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">fetch</span>(getArticle)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =></span> response.<span class="hljs-title function_">json</span>())
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =></span> {
    <span class="hljs-keyword">return</span> articleSchema.<span class="hljs-title function_">parse</span>(data);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>);
</code></pre>
<p>테이블 태그를 Markdown 형식으로 변경할 수도 있어요.</p>
<h2>양식 데이터 유효성 검사</h2>
<p>사용자 입력 또한 외부 데이터의 하나이죠. Zod는 문자열 유효성 검사를 위한 내장 유틸리티를 제공해요. 물론, .refine() 메서드를 사용하여 자신만의 규칙을 구현할 수도 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> myString = z.<span class="hljs-title function_">string</span>().<span class="hljs-title function_">refine</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =></span> val.<span class="hljs-property">length</span> &#x3C;= <span class="hljs-number">255</span>, {
  <span class="hljs-attr">message</span>: <span class="hljs-string">"문자열은 255자를 초과할 수 없어요"</span>,
});
</code></pre>
<p>만약 React를 사용 중이라면, React Hook Form에서 양식 유효성 검사를 위해 Zod 스키마를 사용할 수 있어요.</p>
<h2>구분하는 유형?</h2>
<p>저는 버전 1부터 Zod를 사용하기 시작했어요. 이 버전에는 .check() 메서드가 포함되어 스키마를 유형 가드로 사용할 수 있게 되었는데, 이는 유형을 구분하는 조건으로 사용될 수 있었어요.</p>
<p>이 기능 때문에 “full-schema" 접근 방식을 선택하고 Zod를 유효성 검사 및 유형 구분 모두에 사용하게 되는 것이 유혹스러웠어요. 그러나 이 방식을 취하는 것은 빠르게 시간이 낭비되는 것으로 나타났어요.</p>
<p>해당 메서드는 라이브러리의 다음 버전에서 삭제되었습니다. 이것은 좋은 일이에요. 왜냐하면 Zod는 이제 외부 데이터 유효성 검사에 집중하고 있거든. 타입 축소 표현은 대부분의 상황에서 충분히 유용해서 타입 판별에 좋은 도구가 됐어요.</p>
<h1>요약</h1>
<p>TypeScript는 기본적으로 너무 관대해요. 더 안전한 코드를 작성하려면 외부 데이터(본질적으로 알 수 없는 데이터)를 Zod와 같은 도구로 유효성을 검사해야 해요. Zod는 폼 입력이나 API 응답과 같이 예측할 수 없는 데이터를 유효성 검사하는 데 가장 유용해요. 그 외의 대부분의 시나리오에서는 타입 축소 표현만으로 충분할 거에요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"잠시만, 종 TypeScript를 잘못 사용하는 이유입니다","description":"","date":"2024-05-14 13:35","slug":"2024-05-14-ZodWhyyoureusingTypeScriptwrong","content":"\n\n![이미지](/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png)\n\n간략 요약: 런타임에서 외부 데이터를 검증해야 합니다.\n\n웹 개발 경험이 있다면, API에서 외부 데이터를 다룰 때 런타임 오류를 반드시 마주쳐보았을 것입니다. TypeScript를 사용하면 애플리케이션 전체에서 모든 데이터의 구조와 유형을 상기시켜 주어 이러한 오류를 크게 줄일 수 있습니다. 그러나 TypeScript는 컴파일 중에 알려진 데이터에 대한 불가능한 작업을 방지하는 데 강점을 가지고 있지만, 외부(다른 말로, 알 수 없는) 데이터에 대해서는 너무 관대할 수 있습니다.\n\n본 문서에서는 TypeScript를 사용하여 런타임에서 실패할 수 있는 코드를 작성할 수 있게 하는 이유와 Zod가 이러한 데이터 관련 오류를 방지할 수 있는 방법에 대해 설명하겠습니다.\n\n\n\n# TypeScript의 목표\n\n소개에서 말했듯이, TypeScript의 아이디어는 전체 코드에서 모든 데이터의 구조와 유형을 추적하는 것입니다. 이는 IDE에서 자동완성을 제공하는 데 도움이 되는 것뿐만 아니라 런타임 중에 오류를 일으킬 수있는 유효하지 않은 작업을 방지하기도 합니다. 이론적으로 TypeScript 컴파일 중에 발생할 수 있는 모든 런타임 오류를 예측하고 식별할 수 있습니다. 그러나 실제론 그렇지 않습니다.\n\n## TypeScript는 목표를 달성하지 못했을까요?\n\n실제로 TypeScript의 주요 목표는 생산성을 향상시키는 것입니다. 이것은 TypeScript가 언제나 \"안전\"보다는 생산성을 선택한다는 것을 의미합니다.\n\n\n\n있는 것은 any 타입입니다. 그러나 널리 받아들여지는 것은 사용하지 말아야 한다는 것입니다. 그러나 우리 코드에서 any를 하나도 쓰지 않는다고 해서 우리 애플리케이션이 런타임 오류에 면역이라는 뜻은 아닙니다. 다음 스니펫을 살펴보세요:\n\n```js\nconst obviouslyAnArticle: Article = JSON.parse(input); // input is a string\n```\n\nJSON.parse의 반환 타입이 any인데, 이는 명시적으로 타입이 지정된 변수(이 예에서는 Article)와 연관시킬 수 있습니다. 우리 자신으로부터 명시적으로 작성하지 않아도 TypeScript에게 우리가 any로 작성하지 않고도 파싱된 내용이 Article 타입을 충족하지 않을 수 있는 런타임 가능성을 무시하도록 알려주고 있는 것입니다.\n\n## unknown 및 단언(assertions)\n\n\n\n만약 '어느' 대신 '모든'이 사용되었다면 위 조각을 만들 수 없었을 것입니다. 대신 as 키워드를 사용하여 명시적인 주장을 작성해야 합니다:\n\n```js\nconst shouldBeAnArticle = JSON.parse(input) as Article;\n```\n\n이 구문을 사용하면 TypeScript에게 명시적으로 경계를 낮추도록 지시합니다. 여전히 좋지 않지만 숨겨지지 않았어요!\n\n## 유형 좁히기 식\n\n\n\n위험한 유형 단언을 의존하는 대신, 유형 축소 표현식을 사용할 수 있어요.\n\n예를 들어, JavaScript에서 제공하는 typeof 연산자는 객체의 유형을 런타임 중에 결정할 수 있어요.\n\n```js\nconsole.log(typeof 42);\n// 기대하는 출력: \"number\"\n```\n\n조건문에서 사용되면 TypeScript는 객체의 유형을 축소할 수 있어요.\n\n\n\n```js\nif(typeof input === \"string\") {\n    // input이 문자열 형식으로 좁혀졌습니다.\n    submit(input.toLowerCase());\n}\n```\n\n이 표현은 TypeScript에게 해당 범위에서 input이 문자열만 가능함을 예측할 수 있도록 해줍니다.\n\n## 타입 추론\n\nTypeScript는 다른 표현식들로 타입을 좁힐 수 있지만, 이는 보통 유니언 혹은 원시 타입을 구체화할 때 의미가 있습니다. 이를 \"타입의 차별\"이라고 부릅니다.\n\n\n\n```js\ntype Fish = { swim: () =\u003e void };\ntype Bird = { fly: () =\u003e void };\n\nfunction move(animal: Fish | Bird) {\n  if (\"swim\" in animal) {\n    // input is narrowed to the type Fish\n    return animal.swim();\n  }\n  // input is narrowed to the type Bird\n  return animal.fly();\n}\n```\n\n위 예제에서 키워드 in은 TypeScript가 animal 객체의 유형을 식별하도록 합니다.\n\n알 수 없는 데이터의 경우, 유형 판별은 시간 낭비일 수 있습니다:\n\n```js\nif(typeof input !== \"string\") {\n    // input is still unkown\n}\n```\n\n\n\n외부 데이터에 대해 유형 좁히기 표현식에만 의존할 수 없다는 뜻이에요. 유형을 좁히기 위한 또 다른 방법이 필요합니다: 데이터 유효성 검사.\n\n# Zod가 도와줍니다\n\nZod는 기본적으로 객체 스키마 유효성 검사 도구입니다. 이는 정의된 스키마를 가진 모든 객체의 유효성을 런타임에서 보장할 수 있다는 뜻이에요.\n\n## 스키마 선언\n\n\n\nZod을 사용할 때 첫 번째 할 일은 스키마를 정의하는 것입니다.\n\n```js\nimport * as z from \"zod\";\n\nconst userSchema = z.object({\n    id: z.number(),\n    name: z.string(),\n    age: z.number().optional()\n}).strict();\n```\n\n만약 이전에 yup이나 joi와 같은 유효성 검사 도구를 사용해본 적이 있다면, 이 방법에 익숙할지도 모릅니다. Zod은 object(), string()과 같은 여러 함수를 제공하며, 각 함수는 Zod 스키마를 반환하고 이를 조합하여 더 큰 스키마를 만들 수 있습니다.\n\n각 스키마 조각은 .optional()과 같은 메소드를 사용하여 \"새롭게 정의\"될 수 있으며, 이를 통해 복잡한 유효성 검사 규칙을 얻을 수 있습니다.\n\n\n\n## 스키마 사용하기\n\n스키마는 데이터를 유효성 검사하는 두 가지 방법을 제공합니다. .parse() 메서드는 에러를 throw할 수 있고, .safeParse() 메서드도 그렇습니다:\n\n```js\nconst result = userSchema.safeParse(input);\nif (!result.success) {\n  result.error;\n} else {\n  result.data; // 데이터 유형은 userSchema에서 유추됩니다\n}\n```\n\n파싱이 실패하거나 정의된 유효성 검사 스키마와 일치하는 객체가 반환됩니다. 이 경우 객체는 스키마 구조에서 추론된 유형을 상속받습니다.\n\n\n\n## 스키마로부터 타입 추론하기\n\n일반적으로 데이터는 여러 범위와 문맥에서 공유됩니다. 이러한 이유로 우리는 보통 한번만 타입 별칭을 선언하고 나서 데이터가 전달되는 모든 곳에서 사용합니다. Zod는 z.infer`` 제네릭을 제공하여 스키마에서 추론된 타입에 액세스할 수 있습니다.\n\n```js\ntype Article = z.infer\u003ctypeof articleSchema\u003e;\n```\n\n# Zod 실용적 사용법\n\n\n\n따라서, TypeScript 프로젝트에서 Zod를 사용하는 경우는 어디인가요?\n\n## API 응답 구문 분석\n\n알 수 없거나 예측할 수 없는 데이터의 주요 원천은 API 응답입니다. fetch promise에서 오는 데이터를 수동으로 유효성을 검사할 수 있습니다.\n\n```js\nfetch(getArticle)\n  .then((response) =\u003e response.json())\n  .then((data) =\u003e {\n    return articleSchema.parse(data);\n  })\n  .catch(console.error);\n```\n\n\n\n테이블 태그를 Markdown 형식으로 변경할 수도 있어요. \n\n## 양식 데이터 유효성 검사\n\n사용자 입력 또한 외부 데이터의 하나이죠. Zod는 문자열 유효성 검사를 위한 내장 유틸리티를 제공해요. 물론, .refine() 메서드를 사용하여 자신만의 규칙을 구현할 수도 있어요.\n\n```js\nconst myString = z.string().refine((val) =\u003e val.length \u003c= 255, {\n  message: \"문자열은 255자를 초과할 수 없어요\",\n});\n```\n\n\n\n만약 React를 사용 중이라면, React Hook Form에서 양식 유효성 검사를 위해 Zod 스키마를 사용할 수 있어요.\n\n## 구분하는 유형?\n\n저는 버전 1부터 Zod를 사용하기 시작했어요. 이 버전에는 .check() 메서드가 포함되어 스키마를 유형 가드로 사용할 수 있게 되었는데, 이는 유형을 구분하는 조건으로 사용될 수 있었어요.\n\n이 기능 때문에 “full-schema\" 접근 방식을 선택하고 Zod를 유효성 검사 및 유형 구분 모두에 사용하게 되는 것이 유혹스러웠어요. 그러나 이 방식을 취하는 것은 빠르게 시간이 낭비되는 것으로 나타났어요.\n\n\n\n해당 메서드는 라이브러리의 다음 버전에서 삭제되었습니다. 이것은 좋은 일이에요. 왜냐하면 Zod는 이제 외부 데이터 유효성 검사에 집중하고 있거든. 타입 축소 표현은 대부분의 상황에서 충분히 유용해서 타입 판별에 좋은 도구가 됐어요.\n\n# 요약\n\nTypeScript는 기본적으로 너무 관대해요. 더 안전한 코드를 작성하려면 외부 데이터(본질적으로 알 수 없는 데이터)를 Zod와 같은 도구로 유효성을 검사해야 해요. Zod는 폼 입력이나 API 응답과 같이 예측할 수 없는 데이터를 유효성 검사하는 데 가장 유용해요. 그 외의 대부분의 시나리오에서는 타입 축소 표현만으로 충분할 거에요.","ogImage":{"url":"/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png"},"coverImage":"/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-ZodWhyyoureusingTypeScriptwrong_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e간략 요약: 런타임에서 외부 데이터를 검증해야 합니다.\u003c/p\u003e\n\u003cp\u003e웹 개발 경험이 있다면, API에서 외부 데이터를 다룰 때 런타임 오류를 반드시 마주쳐보았을 것입니다. TypeScript를 사용하면 애플리케이션 전체에서 모든 데이터의 구조와 유형을 상기시켜 주어 이러한 오류를 크게 줄일 수 있습니다. 그러나 TypeScript는 컴파일 중에 알려진 데이터에 대한 불가능한 작업을 방지하는 데 강점을 가지고 있지만, 외부(다른 말로, 알 수 없는) 데이터에 대해서는 너무 관대할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e본 문서에서는 TypeScript를 사용하여 런타임에서 실패할 수 있는 코드를 작성할 수 있게 하는 이유와 Zod가 이러한 데이터 관련 오류를 방지할 수 있는 방법에 대해 설명하겠습니다.\u003c/p\u003e\n\u003ch1\u003eTypeScript의 목표\u003c/h1\u003e\n\u003cp\u003e소개에서 말했듯이, TypeScript의 아이디어는 전체 코드에서 모든 데이터의 구조와 유형을 추적하는 것입니다. 이는 IDE에서 자동완성을 제공하는 데 도움이 되는 것뿐만 아니라 런타임 중에 오류를 일으킬 수있는 유효하지 않은 작업을 방지하기도 합니다. 이론적으로 TypeScript 컴파일 중에 발생할 수 있는 모든 런타임 오류를 예측하고 식별할 수 있습니다. 그러나 실제론 그렇지 않습니다.\u003c/p\u003e\n\u003ch2\u003eTypeScript는 목표를 달성하지 못했을까요?\u003c/h2\u003e\n\u003cp\u003e실제로 TypeScript의 주요 목표는 생산성을 향상시키는 것입니다. 이것은 TypeScript가 언제나 \"안전\"보다는 생산성을 선택한다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e있는 것은 any 타입입니다. 그러나 널리 받아들여지는 것은 사용하지 말아야 한다는 것입니다. 그러나 우리 코드에서 any를 하나도 쓰지 않는다고 해서 우리 애플리케이션이 런타임 오류에 면역이라는 뜻은 아닙니다. 다음 스니펫을 살펴보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eobviouslyAnArticle\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eArticle\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(input); \u003cspan class=\"hljs-comment\"\u003e// input is a string\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJSON.parse의 반환 타입이 any인데, 이는 명시적으로 타입이 지정된 변수(이 예에서는 Article)와 연관시킬 수 있습니다. 우리 자신으로부터 명시적으로 작성하지 않아도 TypeScript에게 우리가 any로 작성하지 않고도 파싱된 내용이 Article 타입을 충족하지 않을 수 있는 런타임 가능성을 무시하도록 알려주고 있는 것입니다.\u003c/p\u003e\n\u003ch2\u003eunknown 및 단언(assertions)\u003c/h2\u003e\n\u003cp\u003e만약 '어느' 대신 '모든'이 사용되었다면 위 조각을 만들 수 없었을 것입니다. 대신 as 키워드를 사용하여 명시적인 주장을 작성해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e shouldBeAnArticle = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(input) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArticle\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 구문을 사용하면 TypeScript에게 명시적으로 경계를 낮추도록 지시합니다. 여전히 좋지 않지만 숨겨지지 않았어요!\u003c/p\u003e\n\u003ch2\u003e유형 좁히기 식\u003c/h2\u003e\n\u003cp\u003e위험한 유형 단언을 의존하는 대신, 유형 축소 표현식을 사용할 수 있어요.\u003c/p\u003e\n\u003cp\u003e예를 들어, JavaScript에서 제공하는 typeof 연산자는 객체의 유형을 런타임 중에 결정할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 기대하는 출력: \"number\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e조건문에서 사용되면 TypeScript는 객체의 유형을 축소할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e input === \u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// input이 문자열 형식으로 좁혀졌습니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003esubmit\u003c/span\u003e(input.\u003cspan class=\"hljs-title function_\"\u003etoLowerCase\u003c/span\u003e());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 표현은 TypeScript에게 해당 범위에서 input이 문자열만 가능함을 예측할 수 있도록 해줍니다.\u003c/p\u003e\n\u003ch2\u003e타입 추론\u003c/h2\u003e\n\u003cp\u003eTypeScript는 다른 표현식들로 타입을 좁힐 수 있지만, 이는 보통 유니언 혹은 원시 타입을 구체화할 때 의미가 있습니다. 이를 \"타입의 차별\"이라고 부릅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype \u003cspan class=\"hljs-title class_\"\u003eFish\u003c/span\u003e = { \u003cspan class=\"hljs-attr\"\u003eswim\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e };\ntype \u003cspan class=\"hljs-title class_\"\u003eBird\u003c/span\u003e = { \u003cspan class=\"hljs-attr\"\u003efly\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e };\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emove\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eanimal: Fish | Bird\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-string\"\u003e\"swim\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e animal) {\n    \u003cspan class=\"hljs-comment\"\u003e// input is narrowed to the type Fish\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e animal.\u003cspan class=\"hljs-title function_\"\u003eswim\u003c/span\u003e();\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// input is narrowed to the type Bird\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e animal.\u003cspan class=\"hljs-title function_\"\u003efly\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예제에서 키워드 in은 TypeScript가 animal 객체의 유형을 식별하도록 합니다.\u003c/p\u003e\n\u003cp\u003e알 수 없는 데이터의 경우, 유형 판별은 시간 낭비일 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e input !== \u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// input is still unkown\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e외부 데이터에 대해 유형 좁히기 표현식에만 의존할 수 없다는 뜻이에요. 유형을 좁히기 위한 또 다른 방법이 필요합니다: 데이터 유효성 검사.\u003c/p\u003e\n\u003ch1\u003eZod가 도와줍니다\u003c/h1\u003e\n\u003cp\u003eZod는 기본적으로 객체 스키마 유효성 검사 도구입니다. 이는 정의된 스키마를 가진 모든 객체의 유효성을 런타임에서 보장할 수 있다는 뜻이에요.\u003c/p\u003e\n\u003ch2\u003e스키마 선언\u003c/h2\u003e\n\u003cp\u003eZod을 사용할 때 첫 번째 할 일은 스키마를 정의하는 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e * \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e z \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"zod\"\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userSchema = z.\u003cspan class=\"hljs-title function_\"\u003eobject\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003enumber\u003c/span\u003e(),\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e(),\n    \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: z.\u003cspan class=\"hljs-title function_\"\u003enumber\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003eoptional\u003c/span\u003e()\n}).\u003cspan class=\"hljs-title function_\"\u003estrict\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 이전에 yup이나 joi와 같은 유효성 검사 도구를 사용해본 적이 있다면, 이 방법에 익숙할지도 모릅니다. Zod은 object(), string()과 같은 여러 함수를 제공하며, 각 함수는 Zod 스키마를 반환하고 이를 조합하여 더 큰 스키마를 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e각 스키마 조각은 .optional()과 같은 메소드를 사용하여 \"새롭게 정의\"될 수 있으며, 이를 통해 복잡한 유효성 검사 규칙을 얻을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e스키마 사용하기\u003c/h2\u003e\n\u003cp\u003e스키마는 데이터를 유효성 검사하는 두 가지 방법을 제공합니다. .parse() 메서드는 에러를 throw할 수 있고, .safeParse() 메서드도 그렇습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = userSchema.\u003cspan class=\"hljs-title function_\"\u003esafeParse\u003c/span\u003e(input);\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!result.\u003cspan class=\"hljs-property\"\u003esuccess\u003c/span\u003e) {\n  result.\u003cspan class=\"hljs-property\"\u003eerror\u003c/span\u003e;\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  result.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 데이터 유형은 userSchema에서 유추됩니다\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e파싱이 실패하거나 정의된 유효성 검사 스키마와 일치하는 객체가 반환됩니다. 이 경우 객체는 스키마 구조에서 추론된 유형을 상속받습니다.\u003c/p\u003e\n\u003ch2\u003e스키마로부터 타입 추론하기\u003c/h2\u003e\n\u003cp\u003e일반적으로 데이터는 여러 범위와 문맥에서 공유됩니다. 이러한 이유로 우리는 보통 한번만 타입 별칭을 선언하고 나서 데이터가 전달되는 모든 곳에서 사용합니다. Zod는 z.infer`` 제네릭을 제공하여 스키마에서 추론된 타입에 액세스할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003etype \u003cspan class=\"hljs-title class_\"\u003eArticle\u003c/span\u003e = z.\u003cspan class=\"hljs-property\"\u003einfer\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e articleSchema\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eZod 실용적 사용법\u003c/h1\u003e\n\u003cp\u003e따라서, TypeScript 프로젝트에서 Zod를 사용하는 경우는 어디인가요?\u003c/p\u003e\n\u003ch2\u003eAPI 응답 구문 분석\u003c/h2\u003e\n\u003cp\u003e알 수 없거나 예측할 수 없는 데이터의 주요 원천은 API 응답입니다. fetch promise에서 오는 데이터를 수동으로 유효성을 검사할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(getArticle)\n  .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) =\u003e\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e())\n  .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e articleSchema.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(data);\n  })\n  .\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eerror\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e테이블 태그를 Markdown 형식으로 변경할 수도 있어요.\u003c/p\u003e\n\u003ch2\u003e양식 데이터 유효성 검사\u003c/h2\u003e\n\u003cp\u003e사용자 입력 또한 외부 데이터의 하나이죠. Zod는 문자열 유효성 검사를 위한 내장 유틸리티를 제공해요. 물론, .refine() 메서드를 사용하여 자신만의 규칙을 구현할 수도 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e myString = z.\u003cspan class=\"hljs-title function_\"\u003estring\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003erefine\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eval\u003c/span\u003e) =\u003e\u003c/span\u003e val.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e \u0026#x3C;= \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"문자열은 255자를 초과할 수 없어요\"\u003c/span\u003e,\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 React를 사용 중이라면, React Hook Form에서 양식 유효성 검사를 위해 Zod 스키마를 사용할 수 있어요.\u003c/p\u003e\n\u003ch2\u003e구분하는 유형?\u003c/h2\u003e\n\u003cp\u003e저는 버전 1부터 Zod를 사용하기 시작했어요. 이 버전에는 .check() 메서드가 포함되어 스키마를 유형 가드로 사용할 수 있게 되었는데, 이는 유형을 구분하는 조건으로 사용될 수 있었어요.\u003c/p\u003e\n\u003cp\u003e이 기능 때문에 “full-schema\" 접근 방식을 선택하고 Zod를 유효성 검사 및 유형 구분 모두에 사용하게 되는 것이 유혹스러웠어요. 그러나 이 방식을 취하는 것은 빠르게 시간이 낭비되는 것으로 나타났어요.\u003c/p\u003e\n\u003cp\u003e해당 메서드는 라이브러리의 다음 버전에서 삭제되었습니다. 이것은 좋은 일이에요. 왜냐하면 Zod는 이제 외부 데이터 유효성 검사에 집중하고 있거든. 타입 축소 표현은 대부분의 상황에서 충분히 유용해서 타입 판별에 좋은 도구가 됐어요.\u003c/p\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003eTypeScript는 기본적으로 너무 관대해요. 더 안전한 코드를 작성하려면 외부 데이터(본질적으로 알 수 없는 데이터)를 Zod와 같은 도구로 유효성을 검사해야 해요. Zod는 폼 입력이나 API 응답과 같이 예측할 수 없는 데이터를 유효성 검사하는 데 가장 유용해요. 그 외의 대부분의 시나리오에서는 타입 축소 표현만으로 충분할 거에요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-ZodWhyyoureusingTypeScriptwrong"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>