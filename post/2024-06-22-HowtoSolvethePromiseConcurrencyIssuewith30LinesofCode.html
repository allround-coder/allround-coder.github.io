<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>30줄 코드로 쉽게 해결하는 프라미스 동시성 문제 해결 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="30줄 코드로 쉽게 해결하는 프라미스 동시성 문제 해결 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="30줄 코드로 쉽게 해결하는 프라미스 동시성 문제 해결 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode" data-gatsby-head="true"/><meta name="twitter:title" content="30줄 코드로 쉽게 해결하는 프라미스 동시성 문제 해결 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 02:01" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">30줄 코드로 쉽게 해결하는 프라미스 동시성 문제 해결 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="30줄 코드로 쉽게 해결하는 프라미스 동시성 문제 해결 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png" alt="image"></p>
<h1>1. Why</h1>
<h2>Why Control Concurrency?</h2>
<p>Controlling concurrency is essential for effectively managing system resources, preventing overload, improving performance and response time, ensuring system stability, and maintaining a good user experience. By limiting the number of concurrent requests, the system can continue to operate normally even under high load conditions.</p>
<div class="content-ad"></div>
<h1>2. 무엇</h1>
<h2>2.1 동시성이란 무엇인가요?</h2>
<p>동시성은 시스템 또는 프로그램이 동시에 여러 작업이나 요청을 처리할 수 있는 능력을 의미합니다. 일반적으로 이는 여러 프로세스나 스레드가 동시에 작업을 실행하여 시스템의 처리량과 응답 속도를 높이는 것을 포함합니다. 동시 환경에서 여러 작업이 번갈아가며 실행되어 리소스 활용이 더 효율적으로 이루어집니다. 그러나 리소스 충돌, 성능 저하, 데드락과 데이터 불일치 등의 문제를 방지하기 위해 효과적인 관리와 제어가 필요합니다.</p>
<h2>2.2 일반적인 동시 작업</h2>
<div class="content-ad"></div>
<p>웹 개발에서 일반적인 동시 작업이 많이 있습니다. 프론트엔드, 백엔드, 데이터베이스 작업 및 시스템 수준의 작업 처리 등을 다룹니다. 웹 개발에서 일반적인 동시 작업의 몇 가지 예는 다음과 같습니다:</p>
<ul>
<li>여러 동시 인터페이스 요청: 프론트엔드 개발에서는 데이터를 가져오기 위해 동시에 여러 API 엔드포인트에 요청을 보내는 것이 일반적입니다.</li>
<li>동시에 여러 요청 처리: 웹 서버는 동시에 여러 클라이언트 요청을 처리합니다.</li>
<li>병렬로 작업 실행: 예를 들어 Node.js의 비동기 기능을 사용하여 여러 작업을 병렬로 실행하는 것입니다.</li>
</ul>
<h1>3. 방법</h1>
<h2>3.1 Promise.all</h2>
<div class="content-ad"></div>
<p>프론트엔드에서 동시 요청을 보낼 때 Promise.all을 많이 사용합니다. 예를 들어:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 비동기 작업을 시뮬레이션하는 함수</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-params">duration</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`총 <span class="hljs-subst">${duration}</span>밀리초 소요`</span>);
    }, duration);
  });
}

<span class="hljs-comment">// 모든 비동기 작업이 완료될 때까지 기다리기 위해 Promise.all 사용</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">simulatePromiseAll</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> promise1 = <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-number">1000</span>);
  <span class="hljs-keyword">const</span> promise2 = <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-number">2000</span>);
  <span class="hljs-keyword">const</span> promise3 = <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-number">3000</span>);

  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1, promise2, promise3])
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =></span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'모든 작업이 완료되었습니다:'</span>);
      results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">result</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result));
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'오류 발생:'</span>, error);
    });
}

<span class="hljs-comment">// Promise.all 함수 시뮬레이션 실행</span>
<span class="hljs-title function_">simulatePromiseAll</span>();
</code></pre>
<p>그러나 Promise.all은 동시성을 제어할 수 없거나 정확히는 이 능력을 가지고 있지 않습니다. 따라서 각 asyncOperation을 수정하여 Promise.all이 Promise를 실행할 때 동시성 제어를 지원하도록 몇 가지 수정을 해야 합니다.</p>
<h2>3.2 구현 방법</h2>
<div class="content-ad"></div>
<p>기본 아이디어는 100개의 동시 작업이 있고 최대 동시성을 10으로 설정한다면 다음 단계를 따릅니다:</p>
<ol>
<li>먼저 10개의 슬롯을 설정합니다.</li>
<li>처음 10개의 동시 작업이 슬롯을 차지하고 실행됩니다.</li>
<li>어떤 슬롯이 먼저 작업을 완료했는지 모니터링한 후, 나머지 작업에서 다른 작업을 가져와 슬롯을 채웁니다.</li>
<li>모든 동시 작업이 완료될 때까지 단계 3을 반복합니다.</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-comment">// 우리가 구현해야 하는 함수</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">simulateLimit</span> = (<span class="hljs-params"></span>) => {
  <span class="hljs-comment">// 코드 작성 </span>
}

<span class="hljs-comment">// 비동기 작업을 시뮬레이션하는 함수</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-params">duration</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =></span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {
      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`Completed in <span class="hljs-subst">${duration}</span> ms`</span>);
    }, duration);
  });
}

<span class="hljs-comment">// 동시성을 제한하기 위해 simulateLimit을 사용합니다</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">simulateControlledPromiseAll</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> limit = <span class="hljs-title function_">simulateLimit</span>(<span class="hljs-number">10</span>);

  <span class="hljs-keyword">const</span> tasks = [
    <span class="hljs-title function_">limit</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-number">1000</span>)),
    <span class="hljs-title function_">limit</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-number">2000</span>)),
    <span class="hljs-title function_">limit</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-number">3000</span>)),
    <span class="hljs-title function_">limit</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-number">1500</span>)),
    <span class="hljs-title function_">limit</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-number">2500</span>)),
    <span class="hljs-title function_">limit</span>(<span class="hljs-function">() =></span> <span class="hljs-title function_">asyncOperation</span>(<span class="hljs-number">3500</span>)),
    <span class="hljs-comment">// 여기에 더 많은 작업을 추가하세요</span>
    <span class="hljs-comment">// ...</span>
  ];

  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(tasks)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">results</span>) =></span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'모든 작업이 완료되었습니다:'</span>);
      results.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">result</span> =></span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result));
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'에러가 발생했습니다:'</span>, error);
    });
}

<span class="hljs-title function_">simulateControlledPromiseAll</span>();
</code></pre>
<p>3.3 30줄의 코드로 simulateLimit를 구현하는 방법</p>
<div class="content-ad"></div>
<p>테이블 태그를 마크다운 형식으로 바꿔주세요.</p>
<div class="content-ad"></div>
<p>반환된 함수 내부에서는 실제 작업 함수 fn을 래핑하는 작업 함수를 만듭니다. task가 호출되면 activeCount를 증가시키고 작업 함수 fn을 실행합니다. 작업이 완료되면 성공 또는 실패 여부에 상관없이 다음 함수가 호출됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">task</span> = (<span class="hljs-params"></span>) => {
  activeCount++;

  <span class="hljs-title function_">fn</span>(...args).<span class="hljs-title function_">then</span>(
    <span class="hljs-function">(<span class="hljs-params">value</span>) =></span> {
      <span class="hljs-title function_">resolve</span>(value);
      <span class="hljs-title function_">next</span>();
    },
    <span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
      <span class="hljs-title function_">reject</span>(error);
      <span class="hljs-title function_">next</span>();
    }
  );
};
</code></pre>
<p>현재 작업이 완료된 후 next 함수가 호출됩니다. activeCount를 감소시키고 대기 중인 작업이 있고 동시성 제한이 아직 초과되지 않았다면 대기열에서 다음 작업을 가져와 실행합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">next</span> = (<span class="hljs-params"></span>) => {
  activeCount--;
  <span class="hljs-keyword">if</span> (queue.<span class="hljs-property">length</span> > <span class="hljs-number">0</span> &#x26;&#x26; activeCount &#x3C; concurrency) {
    <span class="hljs-keyword">const</span> nextTask = queue.<span class="hljs-title function_">shift</span>();
    <span class="hljs-title function_">nextTask</span>();
  }
};
</code></pre>
<div class="content-ad"></div>
<p>반환된 함수 내부에서 현재 활성 작업 수 activeCount가 동시성 제한(concurrency)보다 작은지 확인합니다. 작업 수가 모자라면 해당 작업을 즉시 실행하고, 그렇지 않다면 해당 작업을 대기열에 추가합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (activeCount &#x3C; concurrency) {
  <span class="hljs-title function_">task</span>();
} <span class="hljs-keyword">else</span> {
  queue.<span class="hljs-title function_">push</span>(task);
}
</code></pre>
<p>전체 코드 구현은 아래와 같습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">simulateLimit</span>(<span class="hljs-params">concurrency</span>) {
  <span class="hljs-keyword">const</span> queue = [];
  <span class="hljs-keyword">let</span> activeCount = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">fn, ...args</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =></span> {
      <span class="hljs-keyword">const</span> <span class="hljs-title function_">task</span> = (<span class="hljs-params"></span>) => {
        activeCount++;
        <span class="hljs-title function_">fn</span>(...args).<span class="hljs-title function_">then</span>(
          <span class="hljs-function">(<span class="hljs-params">value</span>) =></span> {
            <span class="hljs-title function_">resolve</span>(value);
            <span class="hljs-title function_">next</span>();
          },
          <span class="hljs-function">(<span class="hljs-params">error</span>) =></span> {
            <span class="hljs-title function_">reject</span>(error);
            <span class="hljs-title function_">next</span>();
          }
        );
      };

      <span class="hljs-keyword">const</span> <span class="hljs-title function_">next</span> = (<span class="hljs-params"></span>) => {
        activeCount--;
        <span class="hljs-keyword">if</span> (queue.<span class="hljs-property">length</span> > <span class="hljs-number">0</span> &#x26;&#x26; activeCount &#x3C; concurrency) {
          <span class="hljs-keyword">const</span> nextTask = queue.<span class="hljs-title function_">shift</span>();
          <span class="hljs-title function_">nextTask</span>();
        }
      };

      <span class="hljs-keyword">if</span> (activeCount &#x3C; concurrency) {
        <span class="hljs-title function_">task</span>();
      } <span class="hljs-keyword">else</span> {
        queue.<span class="hljs-title function_">push</span>(task);
      }
    });
  };
}
</code></pre>
<div class="content-ad"></div>
<p>실제로 이것은 유명한 라이브러리인 p-limit의 소스 코드입니다. 더 완벽한 사용법과 정제된 코드를 보려면 npm에서 p-limit을 참조해주세요. 배워갔나요?</p>
<h1>간단하고 쉬운 영어로 🚀</h1>
<p>In Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:</p>
<ul>
<li>작가를 박수로 응원하고 팔로우하기 ️👏️</li>
<li>팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter</li>
<li>다른 플랫폼에서 만나기: CoFeed | Differ</li>
<li>PlainEnglish.io에서 더 많은 콘텐츠 만나보기</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"30줄 코드로 쉽게 해결하는 프라미스 동시성 문제 해결 방법","description":"","date":"2024-06-22 02:01","slug":"2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode","content":"\n\n\n![image](/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png)\n\n# 1. Why\n\n## Why Control Concurrency?\n\nControlling concurrency is essential for effectively managing system resources, preventing overload, improving performance and response time, ensuring system stability, and maintaining a good user experience. By limiting the number of concurrent requests, the system can continue to operate normally even under high load conditions.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 무엇\n\n## 2.1 동시성이란 무엇인가요?\n\n동시성은 시스템 또는 프로그램이 동시에 여러 작업이나 요청을 처리할 수 있는 능력을 의미합니다. 일반적으로 이는 여러 프로세스나 스레드가 동시에 작업을 실행하여 시스템의 처리량과 응답 속도를 높이는 것을 포함합니다. 동시 환경에서 여러 작업이 번갈아가며 실행되어 리소스 활용이 더 효율적으로 이루어집니다. 그러나 리소스 충돌, 성능 저하, 데드락과 데이터 불일치 등의 문제를 방지하기 위해 효과적인 관리와 제어가 필요합니다.\n\n## 2.2 일반적인 동시 작업\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 개발에서 일반적인 동시 작업이 많이 있습니다. 프론트엔드, 백엔드, 데이터베이스 작업 및 시스템 수준의 작업 처리 등을 다룹니다. 웹 개발에서 일반적인 동시 작업의 몇 가지 예는 다음과 같습니다:\n\n- 여러 동시 인터페이스 요청: 프론트엔드 개발에서는 데이터를 가져오기 위해 동시에 여러 API 엔드포인트에 요청을 보내는 것이 일반적입니다.\n- 동시에 여러 요청 처리: 웹 서버는 동시에 여러 클라이언트 요청을 처리합니다.\n- 병렬로 작업 실행: 예를 들어 Node.js의 비동기 기능을 사용하여 여러 작업을 병렬로 실행하는 것입니다.\n\n# 3. 방법\n\n## 3.1 Promise.all\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드에서 동시 요청을 보낼 때 Promise.all을 많이 사용합니다. 예를 들어:\n\n```js\n// 비동기 작업을 시뮬레이션하는 함수\nfunction asyncOperation(duration) {\n  return new Promise((resolve) =\u003e {\n    setTimeout(() =\u003e {\n      resolve(`총 ${duration}밀리초 소요`);\n    }, duration);\n  });\n}\n\n// 모든 비동기 작업이 완료될 때까지 기다리기 위해 Promise.all 사용\nfunction simulatePromiseAll() {\n  const promise1 = asyncOperation(1000);\n  const promise2 = asyncOperation(2000);\n  const promise3 = asyncOperation(3000);\n\n  Promise.all([promise1, promise2, promise3])\n    .then((results) =\u003e {\n      console.log('모든 작업이 완료되었습니다:');\n      results.forEach(result =\u003e console.log(result));\n    })\n    .catch((error) =\u003e {\n      console.error('오류 발생:', error);\n    });\n}\n\n// Promise.all 함수 시뮬레이션 실행\nsimulatePromiseAll();\r\n```\n\n그러나 Promise.all은 동시성을 제어할 수 없거나 정확히는 이 능력을 가지고 있지 않습니다. 따라서 각 asyncOperation을 수정하여 Promise.all이 Promise를 실행할 때 동시성 제어를 지원하도록 몇 가지 수정을 해야 합니다.\n\n## 3.2 구현 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 아이디어는 100개의 동시 작업이 있고 최대 동시성을 10으로 설정한다면 다음 단계를 따릅니다:\n\n1. 먼저 10개의 슬롯을 설정합니다.\n2. 처음 10개의 동시 작업이 슬롯을 차지하고 실행됩니다.\n3. 어떤 슬롯이 먼저 작업을 완료했는지 모니터링한 후, 나머지 작업에서 다른 작업을 가져와 슬롯을 채웁니다.\n4. 모든 동시 작업이 완료될 때까지 단계 3을 반복합니다.\n\n```js\n// 우리가 구현해야 하는 함수\nconst simulateLimit = () =\u003e {\n  // 코드 작성 \n}\n\n// 비동기 작업을 시뮬레이션하는 함수\nfunction asyncOperation(duration) {\n  return new Promise((resolve) =\u003e {\n    setTimeout(() =\u003e {\n      resolve(`Completed in ${duration} ms`);\n    }, duration);\n  });\n}\n\n// 동시성을 제한하기 위해 simulateLimit을 사용합니다\nfunction simulateControlledPromiseAll() {\n  const limit = simulateLimit(10);\n\n  const tasks = [\n    limit(() =\u003e asyncOperation(1000)),\n    limit(() =\u003e asyncOperation(2000)),\n    limit(() =\u003e asyncOperation(3000)),\n    limit(() =\u003e asyncOperation(1500)),\n    limit(() =\u003e asyncOperation(2500)),\n    limit(() =\u003e asyncOperation(3500)),\n    // 여기에 더 많은 작업을 추가하세요\n    // ...\n  ];\n\n  Promise.all(tasks)\n    .then((results) =\u003e {\n      console.log('모든 작업이 완료되었습니다:');\n      results.forEach(result =\u003e console.log(result));\n    })\n    .catch((error) =\u003e {\n      console.error('에러가 발생했습니다:', error);\n    });\n}\n\nsimulateControlledPromiseAll();\r\n```\n\n3.3 30줄의 코드로 simulateLimit를 구현하는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 바꿔주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n반환된 함수 내부에서는 실제 작업 함수 fn을 래핑하는 작업 함수를 만듭니다. task가 호출되면 activeCount를 증가시키고 작업 함수 fn을 실행합니다. 작업이 완료되면 성공 또는 실패 여부에 상관없이 다음 함수가 호출됩니다.\n\n```js\nconst task = () =\u003e {\n  activeCount++;\n\n  fn(...args).then(\n    (value) =\u003e {\n      resolve(value);\n      next();\n    },\n    (error) =\u003e {\n      reject(error);\n      next();\n    }\n  );\n};\n```\n\n현재 작업이 완료된 후 next 함수가 호출됩니다. activeCount를 감소시키고 대기 중인 작업이 있고 동시성 제한이 아직 초과되지 않았다면 대기열에서 다음 작업을 가져와 실행합니다.\n\n```js\nconst next = () =\u003e {\n  activeCount--;\n  if (queue.length \u003e 0 \u0026\u0026 activeCount \u003c concurrency) {\n    const nextTask = queue.shift();\n    nextTask();\n  }\n};\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n반환된 함수 내부에서 현재 활성 작업 수 activeCount가 동시성 제한(concurrency)보다 작은지 확인합니다. 작업 수가 모자라면 해당 작업을 즉시 실행하고, 그렇지 않다면 해당 작업을 대기열에 추가합니다.\n\n```js\nif (activeCount \u003c concurrency) {\n  task();\n} else {\n  queue.push(task);\n}\n```\n\n전체 코드 구현은 아래와 같습니다:\n\n```js\nfunction simulateLimit(concurrency) {\n  const queue = [];\n  let activeCount = 0;\n\n  return function (fn, ...args) {\n    return new Promise((resolve, reject) =\u003e {\n      const task = () =\u003e {\n        activeCount++;\n        fn(...args).then(\n          (value) =\u003e {\n            resolve(value);\n            next();\n          },\n          (error) =\u003e {\n            reject(error);\n            next();\n          }\n        );\n      };\n\n      const next = () =\u003e {\n        activeCount--;\n        if (queue.length \u003e 0 \u0026\u0026 activeCount \u003c concurrency) {\n          const nextTask = queue.shift();\n          nextTask();\n        }\n      };\n\n      if (activeCount \u003c concurrency) {\n        task();\n      } else {\n        queue.push(task);\n      }\n    });\n  };\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제로 이것은 유명한 라이브러리인 p-limit의 소스 코드입니다. 더 완벽한 사용법과 정제된 코드를 보려면 npm에서 p-limit을 참조해주세요. 배워갔나요?\n\n# 간단하고 쉬운 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\n\n- 작가를 박수로 응원하고 팔로우하기 ️👏️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼에서 만나기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 만나보기","ogImage":{"url":"/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003e1. Why\u003c/h1\u003e\n\u003ch2\u003eWhy Control Concurrency?\u003c/h2\u003e\n\u003cp\u003eControlling concurrency is essential for effectively managing system resources, preventing overload, improving performance and response time, ensuring system stability, and maintaining a good user experience. By limiting the number of concurrent requests, the system can continue to operate normally even under high load conditions.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e2. 무엇\u003c/h1\u003e\n\u003ch2\u003e2.1 동시성이란 무엇인가요?\u003c/h2\u003e\n\u003cp\u003e동시성은 시스템 또는 프로그램이 동시에 여러 작업이나 요청을 처리할 수 있는 능력을 의미합니다. 일반적으로 이는 여러 프로세스나 스레드가 동시에 작업을 실행하여 시스템의 처리량과 응답 속도를 높이는 것을 포함합니다. 동시 환경에서 여러 작업이 번갈아가며 실행되어 리소스 활용이 더 효율적으로 이루어집니다. 그러나 리소스 충돌, 성능 저하, 데드락과 데이터 불일치 등의 문제를 방지하기 위해 효과적인 관리와 제어가 필요합니다.\u003c/p\u003e\n\u003ch2\u003e2.2 일반적인 동시 작업\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e웹 개발에서 일반적인 동시 작업이 많이 있습니다. 프론트엔드, 백엔드, 데이터베이스 작업 및 시스템 수준의 작업 처리 등을 다룹니다. 웹 개발에서 일반적인 동시 작업의 몇 가지 예는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e여러 동시 인터페이스 요청: 프론트엔드 개발에서는 데이터를 가져오기 위해 동시에 여러 API 엔드포인트에 요청을 보내는 것이 일반적입니다.\u003c/li\u003e\n\u003cli\u003e동시에 여러 요청 처리: 웹 서버는 동시에 여러 클라이언트 요청을 처리합니다.\u003c/li\u003e\n\u003cli\u003e병렬로 작업 실행: 예를 들어 Node.js의 비동기 기능을 사용하여 여러 작업을 병렬로 실행하는 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e3. 방법\u003c/h1\u003e\n\u003ch2\u003e3.1 Promise.all\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e프론트엔드에서 동시 요청을 보낼 때 Promise.all을 많이 사용합니다. 예를 들어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 비동기 작업을 시뮬레이션하는 함수\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncOperation\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eduration\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`총 \u003cspan class=\"hljs-subst\"\u003e${duration}\u003c/span\u003e밀리초 소요`\u003c/span\u003e);\n    }, duration);\n  });\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 모든 비동기 작업이 완료될 때까지 기다리기 위해 Promise.all 사용\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esimulatePromiseAll\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e promise1 = \u003cspan class=\"hljs-title function_\"\u003easyncOperation\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e promise2 = \u003cspan class=\"hljs-title function_\"\u003easyncOperation\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e promise3 = \u003cspan class=\"hljs-title function_\"\u003easyncOperation\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e([promise1, promise2, promise3])\n    .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresults\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'모든 작업이 완료되었습니다:'\u003c/span\u003e);\n      results.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresult\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(result));\n    })\n    .\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'오류 발생:'\u003c/span\u003e, error);\n    });\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Promise.all 함수 시뮬레이션 실행\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003esimulatePromiseAll\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 Promise.all은 동시성을 제어할 수 없거나 정확히는 이 능력을 가지고 있지 않습니다. 따라서 각 asyncOperation을 수정하여 Promise.all이 Promise를 실행할 때 동시성 제어를 지원하도록 몇 가지 수정을 해야 합니다.\u003c/p\u003e\n\u003ch2\u003e3.2 구현 방법\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e기본 아이디어는 100개의 동시 작업이 있고 최대 동시성을 10으로 설정한다면 다음 단계를 따릅니다:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e먼저 10개의 슬롯을 설정합니다.\u003c/li\u003e\n\u003cli\u003e처음 10개의 동시 작업이 슬롯을 차지하고 실행됩니다.\u003c/li\u003e\n\u003cli\u003e어떤 슬롯이 먼저 작업을 완료했는지 모니터링한 후, 나머지 작업에서 다른 작업을 가져와 슬롯을 채웁니다.\u003c/li\u003e\n\u003cli\u003e모든 동시 작업이 완료될 때까지 단계 3을 반복합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 우리가 구현해야 하는 함수\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esimulateLimit\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 코드 작성 \u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 비동기 작업을 시뮬레이션하는 함수\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncOperation\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eduration\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Completed in \u003cspan class=\"hljs-subst\"\u003e${duration}\u003c/span\u003e ms`\u003c/span\u003e);\n    }, duration);\n  });\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 동시성을 제한하기 위해 simulateLimit을 사용합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esimulateControlledPromiseAll\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e limit = \u003cspan class=\"hljs-title function_\"\u003esimulateLimit\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tasks = [\n    \u003cspan class=\"hljs-title function_\"\u003elimit\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncOperation\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e)),\n    \u003cspan class=\"hljs-title function_\"\u003elimit\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncOperation\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e)),\n    \u003cspan class=\"hljs-title function_\"\u003elimit\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncOperation\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e)),\n    \u003cspan class=\"hljs-title function_\"\u003elimit\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncOperation\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1500\u003c/span\u003e)),\n    \u003cspan class=\"hljs-title function_\"\u003elimit\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncOperation\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2500\u003c/span\u003e)),\n    \u003cspan class=\"hljs-title function_\"\u003elimit\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easyncOperation\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3500\u003c/span\u003e)),\n    \u003cspan class=\"hljs-comment\"\u003e// 여기에 더 많은 작업을 추가하세요\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  ];\n\n  \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(tasks)\n    .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresults\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'모든 작업이 완료되었습니다:'\u003c/span\u003e);\n      results.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eresult\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(result));\n    })\n    .\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'에러가 발생했습니다:'\u003c/span\u003e, error);\n    });\n}\n\n\u003cspan class=\"hljs-title function_\"\u003esimulateControlledPromiseAll\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e3.3 30줄의 코드로 simulateLimit를 구현하는 방법\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e테이블 태그를 마크다운 형식으로 바꿔주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e반환된 함수 내부에서는 실제 작업 함수 fn을 래핑하는 작업 함수를 만듭니다. task가 호출되면 activeCount를 증가시키고 작업 함수 fn을 실행합니다. 작업이 완료되면 성공 또는 실패 여부에 상관없이 다음 함수가 호출됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etask\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  activeCount++;\n\n  \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(...args).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\n    \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(value);\n      \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n    },\n    \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-title function_\"\u003ereject\u003c/span\u003e(error);\n      \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n    }\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e현재 작업이 완료된 후 next 함수가 호출됩니다. activeCount를 감소시키고 대기 중인 작업이 있고 동시성 제한이 아직 초과되지 않았다면 대기열에서 다음 작업을 가져와 실행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n  activeCount--;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (queue.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026#x26;\u0026#x26; activeCount \u0026#x3C; concurrency) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nextTask = queue.\u003cspan class=\"hljs-title function_\"\u003eshift\u003c/span\u003e();\n    \u003cspan class=\"hljs-title function_\"\u003enextTask\u003c/span\u003e();\n  }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e반환된 함수 내부에서 현재 활성 작업 수 activeCount가 동시성 제한(concurrency)보다 작은지 확인합니다. 작업 수가 모자라면 해당 작업을 즉시 실행하고, 그렇지 않다면 해당 작업을 대기열에 추가합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (activeCount \u0026#x3C; concurrency) {\n  \u003cspan class=\"hljs-title function_\"\u003etask\u003c/span\u003e();\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  queue.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(task);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e전체 코드 구현은 아래와 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esimulateLimit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003econcurrency\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e queue = [];\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e activeCount = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003efn, ...args\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve, reject\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etask\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n        activeCount++;\n        \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(...args).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\n          \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003evalue\u003c/span\u003e) =\u003e\u003c/span\u003e {\n            \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(value);\n            \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n          },\n          \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e) =\u003e\u003c/span\u003e {\n            \u003cspan class=\"hljs-title function_\"\u003ereject\u003c/span\u003e(error);\n            \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n          }\n        );\n      };\n\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) =\u003e {\n        activeCount--;\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (queue.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e \u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u0026#x26;\u0026#x26; activeCount \u0026#x3C; concurrency) {\n          \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nextTask = queue.\u003cspan class=\"hljs-title function_\"\u003eshift\u003c/span\u003e();\n          \u003cspan class=\"hljs-title function_\"\u003enextTask\u003c/span\u003e();\n        }\n      };\n\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (activeCount \u0026#x3C; concurrency) {\n        \u003cspan class=\"hljs-title function_\"\u003etask\u003c/span\u003e();\n      } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        queue.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(task);\n      }\n    });\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e실제로 이것은 유명한 라이브러리인 p-limit의 소스 코드입니다. 더 완벽한 사용법과 정제된 코드를 보려면 npm에서 p-limit을 참조해주세요. 배워갔나요?\u003c/p\u003e\n\u003ch1\u003e간단하고 쉬운 영어로 🚀\u003c/h1\u003e\n\u003cp\u003eIn Plain English 커뮤니티의 일원이 되어주셔서 감사합니다! 떠나시기 전에:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작가를 박수로 응원하고 팔로우하기 ️👏️\u003c/li\u003e\n\u003cli\u003e팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\u003c/li\u003e\n\u003cli\u003e다른 플랫폼에서 만나기: CoFeed | Differ\u003c/li\u003e\n\u003cli\u003ePlainEnglish.io에서 더 많은 콘텐츠 만나보기\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-HowtoSolvethePromiseConcurrencyIssuewith30LinesofCode"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>