<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SwiftUI 간단하게 시작하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-17-SwiftUIThinking" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SwiftUI 간단하게 시작하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="SwiftUI 간단하게 시작하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-SwiftUIThinking_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-17-SwiftUIThinking" data-gatsby-head="true"/><meta name="twitter:title" content="SwiftUI 간단하게 시작하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-SwiftUIThinking_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 03:53" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SwiftUI 간단하게 시작하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SwiftUI 간단하게 시작하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-SwiftUIThinking&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-05-17-SwiftUIThinking_0.png">
<p>SwiftUI가 우리의 백로그에 올라온 지 어느 정도 되었네요. iOS 개발자로서, 우리는 SwiftUI를 기다리며 올바른 시기에 빠져들기를 기다리고 있었어요.</p>
<p>여기에 SwiftUI에 대한 간략한 소개가 있습니다!</p>
<p>SwiftUI의 시작점을 찾고 있다면, 여기서 시작하시면 됩니다!</p>
<div class="content-ad"></div>
<h1>일반적인 뷰 구성 요소와 속성들</h1>
<p>SwiftUI에는 UIKit과 유사하게 사용되는 몇 가지 인기 있는 UI 구성 요소가 있습니다.</p>
<h2>Text</h2>
<p>Text는 UILabel과 동일합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-title class_">Text</span>(<span class="hljs-string">"Hello World!"</span>)
    .<span class="hljs-title function_">font</span>(.<span class="hljs-property">title</span>.<span class="hljs-title function_">bold</span>())
    .<span class="hljs-title function_">foregroundStyle</span>(.<span class="hljs-property">blue</span>)
</code></pre>
<p><img src="/assets/img/2024-05-17-SwiftUIThinking_1.png" alt="SwiftUI Thinking"></p>
<h2>버튼</h2>
<p>예상했던대로, Button은 UIButton에 해당합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-swift"><span class="hljs-type">Button</span> {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Button Action"</span>)
} label: {
    <span class="hljs-type">Text</span>(<span class="hljs-string">"Hello World!"</span>)
        .font(.title.bold())
        .foregroundStyle(.white)
        .padding()
        .background(.blue)
        .clipShape(<span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">16</span>))
}
</code></pre>
<p><img src="/assets/img/2024-05-17-SwiftUIThinking_2.png" alt="Image"></p>
<h2>이미지</h2>
<p>Image는 UIImageView와 같다고 생각하면 됩니다.</p>
<div class="content-ad"></div>
<p>![시스템 이름을 사용한 이미지](Image(systemName: "house.fill")
.resizable()
.scaledToFit()
.foregroundStyle(.blue)
)</p>
<p><img src="/assets/img/2024-05-17-SwiftUIThinking_3.png" alt="SwiftUI를 학습하는 이미지"></p>
<h2>TextField</h2>
<p>TextField은 UITextField와 동일합니다.</p>
<div class="content-ad"></div>
<p>TextField("placeholder", text: .constant(""))
.textFieldStyle(.roundedBorder)</p>
<p><img src="/assets/img/2024-05-17-SwiftUIThinking_4.png" alt="SwiftUIThinking_4"></p>
<h1>HStack &#x26; VStack</h1>
<p>앱의 UI를 구조화할 때는 뷰를 서로 정렬하는 것이 중요합니다.</p>
<div class="content-ad"></div>
<p>SwiftUI에서는 이를 위한 두 가지 주요 레이아웃 빌더가 있습니다: HStack과 VStack.</p>
<p>이러한 레이아웃 빌더를 사용하면 각각 뷰를 수평 및 수직으로 정렬할 수 있습니다.</p>
<p>보다 복잡한 레이아웃을 구현하기 위해 이들을 결합할 수도 있습니다.</p>
<h2>HStack</h2>
<div class="content-ad"></div>
<p><code>HStack</code>은 뷰를 수평으로 정렬합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">HStack</span> {
    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"Leading Text"</span>)
        .<span class="hljs-title function_">font</span>(.<span class="hljs-property">body</span>.<span class="hljs-title function_">bold</span>())
        .<span class="hljs-title function_">foregroundStyle</span>(.<span class="hljs-property">blue</span>)

    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"Trailing Text"</span>)
        .<span class="hljs-title function_">fonts</span>(.<span class="hljs-property">caption</span>.<span class="hljs-title function_">bold</span>())
        .<span class="hljs-title function_">foregroundStyle</span>(.<span class="hljs-property">orange</span>)
}
</code></pre>
<p><img src="/assets/img/2024-05-17-SwiftUIThinking_5.png" alt="SwiftUIThinking_5"></p>
<h2>VStack</h2>
<div class="content-ad"></div>
<p>뷰를 수직으로 정렬합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">VStack</span> {
    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"상단 텍스트"</span>)
        .<span class="hljs-title function_">font</span>(.<span class="hljs-property">body</span>.<span class="hljs-title function_">bold</span>())
        .<span class="hljs-title function_">foregroundStyle</span>(.<span class="hljs-property">blue</span>)

    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"하단 텍스트"</span>)
        .<span class="hljs-title function_">font</span>(.<span class="hljs-property">caption</span>.<span class="hljs-title function_">bold</span>())
        .<span class="hljs-title function_">foregroundStyle</span>(.<span class="hljs-property">orange</span>)
}
</code></pre>
<img src="/assets/img/2024-05-17-SwiftUIThinking_6.png">
<h1>뷰 간의 관계: Spacer로 유연한 UI</h1>
<div class="content-ad"></div>
<p>Spacer는 SwiftUI의 가벼우면서 강력한 구성 요소로 유연한 UI를 구축하는 데 사용됩니다.</p>
<p>원하는 뷰를 다른 뷰에 일정한 여백(leading, top, trailing, bottom)을 사용하여 정렬하는 것은 지루할 수 있습니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-type">HStack</span> {
    <span class="hljs-type">Text</span>(<span class="hljs-string">"Leading Text"</span>)
        .font(.body.bold())
        .foregroundStyle(.blue)

    <span class="hljs-type">Spacer</span>()

    <span class="hljs-type">Text</span>(<span class="hljs-string">"Trailing Text"</span>)
        .font(.caption.bold())
        .foregroundStyle(.orange)
}
</code></pre>
<p><img src="/assets/img/2024-05-17-SwiftUIThinking_7.png" alt="SwiftUIThinking_7"></p>
<div class="content-ad"></div>
<p>Spacer가 HStack 안의 두 개의 Text 사이에 배치되면, 디자인된대로 Text를 가장자리쪽으로 밀어냅니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">HStack</span> {
    <span class="hljs-title class_">Spacer</span>()

    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"Leading Text"</span>)
        .<span class="hljs-title function_">font</span>(.<span class="hljs-property">body</span>.<span class="hljs-title function_">bold</span>())
        .<span class="hljs-title function_">foregroundStyle</span>(.<span class="hljs-property">blue</span>)

    <span class="hljs-title class_">Spacer</span>()

    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"Trailing Text"</span>)
        .<span class="hljs-title function_">font</span>(.<span class="hljs-property">caption</span>.<span class="hljs-title function_">bold</span>())
        .<span class="hljs-title function_">foregroundStyle</span>(.<span class="hljs-property">orange</span>)

    <span class="hljs-title class_">Spacer</span>()
    <span class="hljs-title class_">Spacer</span>()
}
</code></pre>
<p>Leading Text 앞에 Spacer를 하나 추가하고, Trailing Text 뒤에 Spacer를 두 개 더 추가했어요.</p>
<img src="/assets/img/2024-05-17-SwiftUIThinking_8.png">
<div class="content-ad"></div>
<p>스페이서를 추가할 때, 선두 텍스트는 선도를 기준으로 한 스페이서 만큼 멀어지고, 추적 텍스트는 후도를 기준으로 두 스페이서 만큼 멀어집니다.</p>
<p>그 결과로, 추적 텍스트는 선두 텍스트에 비해 기기 가장자리로부터 더 멀리 떨어지게 됩니다.</p>
<h1>데이터 목록 다루기</h1>
<p>데이터 목록에 대해, SwiftUI에는 List 또는 Foreach라는 두 가지 옵션이 있습니다.</p>
<div class="content-ad"></div>
<h2>목록</h2>
<p>목록은 UIKit의 UITableView와 같습니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">var</span> numbers <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]

<span class="hljs-type">List</span>(numbers, id: \.<span class="hljs-keyword">self</span>) { number <span class="hljs-keyword">in</span>
    <span class="hljs-type">Text</span>(<span class="hljs-string">"<span class="hljs-subst">\(number)</span>"</span>)
}
</code></pre>
<img src="/assets/img/2024-05-17-SwiftUIThinking_9.png">
<div class="content-ad"></div>
<p>안녕하세요!</p>
<p>Markdown 형식으로 표를 변환하려면 다음과 같이 해보세요.</p>
<p>List에는 구분선, 카드 모양 등과 같은 준비된 UI가 포함되어 있습니다. 쉽죠!</p>
<h2>Foreach</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]

<span class="hljs-title class_">VStack</span> {
    <span class="hljs-title class_">ForEach</span>(numbers, <span class="hljs-attr">id</span>: \.<span class="hljs-property">self</span>) { number <span class="hljs-keyword">in</span>
        <span class="hljs-title class_">Text</span>(<span class="hljs-string">"\(number)"</span>)
    }
}
</code></pre>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-17-SwiftUIThinking_10.png" alt="image"></p>
<p>The Foreach construct offers a leaner alternative to the List component. With Foreach, you have full control over building your list UI, resulting in a simpler and more customizable approach.</p>
<h2>Updating UI with Observable Property</h2>
<p>SwiftUI differs from UIKit by embracing the Declarative Programming approach.</p>
<div class="content-ad"></div>
<p>선언적 프로그래밍에서 UI는 Observable 값이나 속성의 변경을 관찰합니다.</p>
<p>값이 변경될 때마다 UI는 동적으로 변경 사항을 반영합니다.</p>
<p>SwiftUI의 기본 속성 래퍼(State 및 Binding)는 관찰 가능성을 활성화합니다:</p>
<p>State: 단방향 연결을 용이하게 해 주며 주로 연결된 뷰 내에서 사용됩니다.</p>
<div class="content-ad"></div>
<p>바인딩: 양방향 연결을 수립하고 상태 속성을 다른 뷰로 전송하는 데 사용됩니다.</p>
<h2>지금은 상태에 집중해 보겠습니다</h2>
<pre><code class="hljs language-js">@<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">text</span>: <span class="hljs-title class_">String</span> = <span class="hljs-string">"초기 텍스트"</span>

<span class="hljs-title class_">VStack</span>(<span class="hljs-attr">spacing</span>: <span class="hljs-number">32</span>) {
    <span class="hljs-title class_">Button</span> {
        text = <span class="hljs-string">"수정된 변경"</span>
    } <span class="hljs-attr">label</span>: {
        <span class="hljs-title class_">Text</span>(<span class="hljs-string">"텍스트 변경"</span>)
            .<span class="hljs-title function_">font</span>(.<span class="hljs-property">title</span>.<span class="hljs-title function_">bold</span>())
            .<span class="hljs-title function_">foregroundStyle</span>(.<span class="hljs-property">white</span>)
            .<span class="hljs-title function_">padding</span>()
            .<span class="hljs-title function_">background</span>(.<span class="hljs-property">blue</span>)
            .<span class="hljs-title function_">clipShape</span>(<span class="hljs-title class_">RoundedRectangle</span>(<span class="hljs-attr">cornerRadius</span>: <span class="hljs-number">16</span>))
    }

    <span class="hljs-title class_">Text</span>(text)
        .<span class="hljs-title function_">font</span>(.<span class="hljs-property">body</span>.<span class="hljs-title function_">bold</span>())
        .<span class="hljs-title function_">foregroundStyle</span>(.<span class="hljs-property">blue</span>)
}
</code></pre>
<p><img src="https://miro.medium.com/v2/resize:fit:590/1*UAzw-1G__azlbNUSfevu9Q.gif" alt="이미지"></p>
<div class="content-ad"></div>
<p>변경 텍스트 버튼 액션은 observable text 속성을 수정합니다. UI는 텍스트 속성의 변경 사항을 듣도록 설계되어 있으므로 자동으로 업데이트됩니다. 이 기능은 State 프로퍼티 래퍼로 가능해졌습니다.</p>
<h1>뷰</h1>
<p>모든 SwiftUI 뷰는 View 프로토콜을 준수하는 구조체입니다.</p>
<p>구조체는 클래스 상속을 허용하지 않으므로 SwiftUI 뷰는 프로토콜에만 준수할 수 있습니다.</p>
<div class="content-ad"></div>
<p>위 특성들은 SwiftUI에서 뷰를 독립적이고 고유하게 보는 방식을 채택해야 함을 필요로 합니다.</p>
<p>UIKit에서는 UIViewController 및 UITableViewController와 같은 특정 뷰를 위한 기본 클래스를 생성하는 것이 일반적입니다. 이 습관에서 벗어나는 것은 어려울 수 있지만, 마음가짐을 바꿈으로써 가능합니다!</p>
<h1>유용한 구성 요소</h1>
<p>SwiftUI의 핵심 원칙 중 하나는 작성 코드를 줄이고 더 많은 작업을 하는 것입니다.</p>
<div class="content-ad"></div>
<p>뒤에 표식을 확인 해주세요.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-05-17-SwiftUIThinking_11.png" alt="Image"></p>
<h2>Picker</h2>
<p>It is a combination of UISegmentedControl and UIPickerView.</p>
<p>It provides various styles such as wheel, inline, segmented, and palette.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
@<span class="hljs-title class_">State</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">selection</span>: <span class="hljs-title class_">Int</span> = <span class="hljs-number">0</span>

<span class="hljs-title class_">Picker</span>(<span class="hljs-string">"Select"</span>, <span class="hljs-attr">selection</span>: $selection) {
    <span class="hljs-title class_">ForEach</span>(numbers, <span class="hljs-attr">id</span>: \.<span class="hljs-property">self</span>) { number <span class="hljs-keyword">in</span>
        <span class="hljs-title class_">Text</span>(<span class="hljs-string">"\(number)"</span>)
    }
}
.<span class="hljs-title function_">pickerStyle</span>(.<span class="hljs-property">inline</span>)
</code></pre>
<p><img src="https://miro.medium.com/v2/resize:fit:590/1*fy8_zvsJAsM7_4dQB4QgdA.gif" alt="Image Scale"></p>
<h1>이미지 크기 조절</h1>
<p>SwiftUI가 처음 나온 이후, Apple은 이미지 라이브러리인 SF Symbols를 제공해 왔습니다. Image 뷰를 사용하여 이 라이브러리의 이미지에 쉽게 액세스할 수 있습니다.</p>
<div class="content-ad"></div>
<p>또한, Text 뷰의 글꼴 설정과 유사하게 이미지 크기를 조절할 수 있는 font 기능을 사용해 이미지의 크기를 조절할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Image</span>(<span class="hljs-attr">systemName</span>: <span class="hljs-string">"house.fill"</span>)
    .<span class="hljs-title function_">font</span>(.<span class="hljs-property">largeTitle</span>)
</code></pre>
<p>SwiftUI는 Apple 환경에서 프로젝트를 개발하는 새로운 방법입니다.</p>
<p>SwiftUI의 방식에 대해 생각을 조정하면 됩니다.</p>
<div class="content-ad"></div>
<p>한번 그것을 할 수 있다면, SwiftUI의 문들이 완전히 열릴 것입니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SwiftUI 간단하게 시작하기","description":"","date":"2024-05-17 03:53","slug":"2024-05-17-SwiftUIThinking","content":"\n\n\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_0.png\" /\u003e\n\nSwiftUI가 우리의 백로그에 올라온 지 어느 정도 되었네요. iOS 개발자로서, 우리는 SwiftUI를 기다리며 올바른 시기에 빠져들기를 기다리고 있었어요.\n\n여기에 SwiftUI에 대한 간략한 소개가 있습니다!\n\nSwiftUI의 시작점을 찾고 있다면, 여기서 시작하시면 됩니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 일반적인 뷰 구성 요소와 속성들\n\nSwiftUI에는 UIKit과 유사하게 사용되는 몇 가지 인기 있는 UI 구성 요소가 있습니다.\n\n## Text\n\nText는 UILabel과 동일합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nText(\"Hello World!\")\n    .font(.title.bold())\n    .foregroundStyle(.blue)\n```\n\n![SwiftUI Thinking](/assets/img/2024-05-17-SwiftUIThinking_1.png)\n\n## 버튼\n\n예상했던대로, Button은 UIButton에 해당합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nButton {\n    print(\"Button Action\")\n} label: {\n    Text(\"Hello World!\")\n        .font(.title.bold())\n        .foregroundStyle(.white)\n        .padding()\n        .background(.blue)\n        .clipShape(RoundedRectangle(cornerRadius: 16))\n}\n```\n\n![Image](/assets/img/2024-05-17-SwiftUIThinking_2.png)\n\n## 이미지\n\nImage는 UIImageView와 같다고 생각하면 됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![시스템 이름을 사용한 이미지](Image(systemName: \"house.fill\")\n    .resizable()\n    .scaledToFit()\n    .foregroundStyle(.blue)\n)\n\n![SwiftUI를 학습하는 이미지](/assets/img/2024-05-17-SwiftUIThinking_3.png)\n\n## TextField\n\nTextField은 UITextField와 동일합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nTextField(\"placeholder\", text: .constant(\"\"))\n    .textFieldStyle(.roundedBorder)\n\n\n![SwiftUIThinking_4](/assets/img/2024-05-17-SwiftUIThinking_4.png)\n\n# HStack \u0026 VStack\n\n앱의 UI를 구조화할 때는 뷰를 서로 정렬하는 것이 중요합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSwiftUI에서는 이를 위한 두 가지 주요 레이아웃 빌더가 있습니다: HStack과 VStack.\n\n이러한 레이아웃 빌더를 사용하면 각각 뷰를 수평 및 수직으로 정렬할 수 있습니다.\n\n보다 복잡한 레이아웃을 구현하기 위해 이들을 결합할 수도 있습니다.\n\n## HStack\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`HStack`은 뷰를 수평으로 정렬합니다.\n\n```js\nHStack {\n    Text(\"Leading Text\")\n        .font(.body.bold())\n        .foregroundStyle(.blue)\n\n    Text(\"Trailing Text\")\n        .fonts(.caption.bold())\n        .foregroundStyle(.orange)\n}\n```\n\n![SwiftUIThinking_5](/assets/img/2024-05-17-SwiftUIThinking_5.png)\n\n## VStack\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n뷰를 수직으로 정렬합니다.\n\n```js\nVStack {\n    Text(\"상단 텍스트\")\n        .font(.body.bold())\n        .foregroundStyle(.blue)\n\n    Text(\"하단 텍스트\")\n        .font(.caption.bold())\n        .foregroundStyle(.orange)\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_6.png\" /\u003e\n\n# 뷰 간의 관계: Spacer로 유연한 UI\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpacer는 SwiftUI의 가벼우면서 강력한 구성 요소로 유연한 UI를 구축하는 데 사용됩니다.\n\n원하는 뷰를 다른 뷰에 일정한 여백(leading, top, trailing, bottom)을 사용하여 정렬하는 것은 지루할 수 있습니다.\n\n```swift\nHStack {\n    Text(\"Leading Text\")\n        .font(.body.bold())\n        .foregroundStyle(.blue)\n\n    Spacer()\n\n    Text(\"Trailing Text\")\n        .font(.caption.bold())\n        .foregroundStyle(.orange)\n}\n``` \n\n![SwiftUIThinking_7](/assets/img/2024-05-17-SwiftUIThinking_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpacer가 HStack 안의 두 개의 Text 사이에 배치되면, 디자인된대로 Text를 가장자리쪽으로 밀어냅니다.\n\n```js\nHStack {\n    Spacer()\n\n    Text(\"Leading Text\")\n        .font(.body.bold())\n        .foregroundStyle(.blue)\n\n    Spacer()\n\n    Text(\"Trailing Text\")\n        .font(.caption.bold())\n        .foregroundStyle(.orange)\n\n    Spacer()\n    Spacer()\n}\n```\n\nLeading Text 앞에 Spacer를 하나 추가하고, Trailing Text 뒤에 Spacer를 두 개 더 추가했어요.\n\n\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_8.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스페이서를 추가할 때, 선두 텍스트는 선도를 기준으로 한 스페이서 만큼 멀어지고, 추적 텍스트는 후도를 기준으로 두 스페이서 만큼 멀어집니다.\n\n그 결과로, 추적 텍스트는 선두 텍스트에 비해 기기 가장자리로부터 더 멀리 떨어지게 됩니다.\n\n# 데이터 목록 다루기\n\n데이터 목록에 대해, SwiftUI에는 List 또는 Foreach라는 두 가지 옵션이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 목록\n\n목록은 UIKit의 UITableView와 같습니다.\n\n```swift\nvar numbers = [1, 2, 3, 4, 5]\n\nList(numbers, id: \\.self) { number in\n    Text(\"\\(number)\")\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_9.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요!\n\nMarkdown 형식으로 표를 변환하려면 다음과 같이 해보세요.\n\nList에는 구분선, 카드 모양 등과 같은 준비된 UI가 포함되어 있습니다. 쉽죠!\n\n## Foreach\n\n```js\nvar numbers = [1, 2, 3, 4, 5]\n\nVStack {\n    ForEach(numbers, id: \\.self) { number in\n        Text(\"\\(number)\")\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-05-17-SwiftUIThinking_10.png)\n\nThe Foreach construct offers a leaner alternative to the List component. With Foreach, you have full control over building your list UI, resulting in a simpler and more customizable approach.\n\n## Updating UI with Observable Property\n\nSwiftUI differs from UIKit by embracing the Declarative Programming approach.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n선언적 프로그래밍에서 UI는 Observable 값이나 속성의 변경을 관찰합니다.\n\n값이 변경될 때마다 UI는 동적으로 변경 사항을 반영합니다.\n\nSwiftUI의 기본 속성 래퍼(State 및 Binding)는 관찰 가능성을 활성화합니다:\n\nState: 단방향 연결을 용이하게 해 주며 주로 연결된 뷰 내에서 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n바인딩: 양방향 연결을 수립하고 상태 속성을 다른 뷰로 전송하는 데 사용됩니다.\n\n## 지금은 상태에 집중해 보겠습니다\n\n```js\n@State var text: String = \"초기 텍스트\"\n\nVStack(spacing: 32) {\n    Button {\n        text = \"수정된 변경\"\n    } label: {\n        Text(\"텍스트 변경\")\n            .font(.title.bold())\n            .foregroundStyle(.white)\n            .padding()\n            .background(.blue)\n            .clipShape(RoundedRectangle(cornerRadius: 16))\n    }\n\n    Text(text)\n        .font(.body.bold())\n        .foregroundStyle(.blue)\n}\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:590/1*UAzw-1G__azlbNUSfevu9Q.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n변경 텍스트 버튼 액션은 observable text 속성을 수정합니다. UI는 텍스트 속성의 변경 사항을 듣도록 설계되어 있으므로 자동으로 업데이트됩니다. 이 기능은 State 프로퍼티 래퍼로 가능해졌습니다.\n\n# 뷰\n\n모든 SwiftUI 뷰는 View 프로토콜을 준수하는 구조체입니다.\n\n구조체는 클래스 상속을 허용하지 않으므로 SwiftUI 뷰는 프로토콜에만 준수할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 특성들은 SwiftUI에서 뷰를 독립적이고 고유하게 보는 방식을 채택해야 함을 필요로 합니다.\n\nUIKit에서는 UIViewController 및 UITableViewController와 같은 특정 뷰를 위한 기본 클래스를 생성하는 것이 일반적입니다. 이 습관에서 벗어나는 것은 어려울 수 있지만, 마음가짐을 바꿈으로써 가능합니다!\n\n# 유용한 구성 요소\n\nSwiftUI의 핵심 원칙 중 하나는 작성 코드를 줄이고 더 많은 작업을 하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n뒤에 표식을 확인 해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-05-17-SwiftUIThinking_11.png)\n  \n## Picker\n\nIt is a combination of UISegmentedControl and UIPickerView.\n\nIt provides various styles such as wheel, inline, segmented, and palette.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nlet numbers = [1, 2, 3, 4, 5]\n@State var selection: Int = 0\n\nPicker(\"Select\", selection: $selection) {\n    ForEach(numbers, id: \\.self) { number in\n        Text(\"\\(number)\")\n    }\n}\n.pickerStyle(.inline)\n``` \n\n![Image Scale](https://miro.medium.com/v2/resize:fit:590/1*fy8_zvsJAsM7_4dQB4QgdA.gif)\n\n# 이미지 크기 조절\n\nSwiftUI가 처음 나온 이후, Apple은 이미지 라이브러리인 SF Symbols를 제공해 왔습니다. Image 뷰를 사용하여 이 라이브러리의 이미지에 쉽게 액세스할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, Text 뷰의 글꼴 설정과 유사하게 이미지 크기를 조절할 수 있는 font 기능을 사용해 이미지의 크기를 조절할 수 있습니다.\n\n```js\nImage(systemName: \"house.fill\")\n    .font(.largeTitle)\n```\n\nSwiftUI는 Apple 환경에서 프로젝트를 개발하는 새로운 방법입니다.\n\nSwiftUI의 방식에 대해 생각을 조정하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한번 그것을 할 수 있다면, SwiftUI의 문들이 완전히 열릴 것입니다!","ogImage":{"url":"/assets/img/2024-05-17-SwiftUIThinking_0.png"},"coverImage":"/assets/img/2024-05-17-SwiftUIThinking_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_0.png\"\u003e\n\u003cp\u003eSwiftUI가 우리의 백로그에 올라온 지 어느 정도 되었네요. iOS 개발자로서, 우리는 SwiftUI를 기다리며 올바른 시기에 빠져들기를 기다리고 있었어요.\u003c/p\u003e\n\u003cp\u003e여기에 SwiftUI에 대한 간략한 소개가 있습니다!\u003c/p\u003e\n\u003cp\u003eSwiftUI의 시작점을 찾고 있다면, 여기서 시작하시면 됩니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e일반적인 뷰 구성 요소와 속성들\u003c/h1\u003e\n\u003cp\u003eSwiftUI에는 UIKit과 유사하게 사용되는 몇 가지 인기 있는 UI 구성 요소가 있습니다.\u003c/p\u003e\n\u003ch2\u003eText\u003c/h2\u003e\n\u003cp\u003eText는 UILabel과 동일합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Hello World!\"\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003efont\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebold\u003c/span\u003e())\n    .\u003cspan class=\"hljs-title function_\"\u003eforegroundStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eblue\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_1.png\" alt=\"SwiftUI Thinking\"\u003e\u003c/p\u003e\n\u003ch2\u003e버튼\u003c/h2\u003e\n\u003cp\u003e예상했던대로, Button은 UIButton에 해당합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-type\"\u003eButton\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Button Action\"\u003c/span\u003e)\n} label: {\n    \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Hello World!\"\u003c/span\u003e)\n        .font(.title.bold())\n        .foregroundStyle(.white)\n        .padding()\n        .background(.blue)\n        .clipShape(\u003cspan class=\"hljs-type\"\u003eRoundedRectangle\u003c/span\u003e(cornerRadius: \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_2.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003ch2\u003e이미지\u003c/h2\u003e\n\u003cp\u003eImage는 UIImageView와 같다고 생각하면 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e![시스템 이름을 사용한 이미지](Image(systemName: \"house.fill\")\n.resizable()\n.scaledToFit()\n.foregroundStyle(.blue)\n)\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_3.png\" alt=\"SwiftUI를 학습하는 이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003eTextField\u003c/h2\u003e\n\u003cp\u003eTextField은 UITextField와 동일합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eTextField(\"placeholder\", text: .constant(\"\"))\n.textFieldStyle(.roundedBorder)\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_4.png\" alt=\"SwiftUIThinking_4\"\u003e\u003c/p\u003e\n\u003ch1\u003eHStack \u0026#x26; VStack\u003c/h1\u003e\n\u003cp\u003e앱의 UI를 구조화할 때는 뷰를 서로 정렬하는 것이 중요합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eSwiftUI에서는 이를 위한 두 가지 주요 레이아웃 빌더가 있습니다: HStack과 VStack.\u003c/p\u003e\n\u003cp\u003e이러한 레이아웃 빌더를 사용하면 각각 뷰를 수평 및 수직으로 정렬할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e보다 복잡한 레이아웃을 구현하기 위해 이들을 결합할 수도 있습니다.\u003c/p\u003e\n\u003ch2\u003eHStack\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eHStack\u003c/code\u003e은 뷰를 수평으로 정렬합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eHStack\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Leading Text\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003efont\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebold\u003c/span\u003e())\n        .\u003cspan class=\"hljs-title function_\"\u003eforegroundStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eblue\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Trailing Text\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003efonts\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ecaption\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebold\u003c/span\u003e())\n        .\u003cspan class=\"hljs-title function_\"\u003eforegroundStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eorange\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_5.png\" alt=\"SwiftUIThinking_5\"\u003e\u003c/p\u003e\n\u003ch2\u003eVStack\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e뷰를 수직으로 정렬합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"상단 텍스트\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003efont\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebold\u003c/span\u003e())\n        .\u003cspan class=\"hljs-title function_\"\u003eforegroundStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eblue\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"하단 텍스트\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003efont\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ecaption\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebold\u003c/span\u003e())\n        .\u003cspan class=\"hljs-title function_\"\u003eforegroundStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eorange\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_6.png\"\u003e\n\u003ch1\u003e뷰 간의 관계: Spacer로 유연한 UI\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eSpacer는 SwiftUI의 가벼우면서 강력한 구성 요소로 유연한 UI를 구축하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e원하는 뷰를 다른 뷰에 일정한 여백(leading, top, trailing, bottom)을 사용하여 정렬하는 것은 지루할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-type\"\u003eHStack\u003c/span\u003e {\n    \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Leading Text\"\u003c/span\u003e)\n        .font(.body.bold())\n        .foregroundStyle(.blue)\n\n    \u003cspan class=\"hljs-type\"\u003eSpacer\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Trailing Text\"\u003c/span\u003e)\n        .font(.caption.bold())\n        .foregroundStyle(.orange)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_7.png\" alt=\"SwiftUIThinking_7\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eSpacer가 HStack 안의 두 개의 Text 사이에 배치되면, 디자인된대로 Text를 가장자리쪽으로 밀어냅니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eHStack\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eSpacer\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Leading Text\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003efont\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebold\u003c/span\u003e())\n        .\u003cspan class=\"hljs-title function_\"\u003eforegroundStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eblue\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-title class_\"\u003eSpacer\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Trailing Text\"\u003c/span\u003e)\n        .\u003cspan class=\"hljs-title function_\"\u003efont\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ecaption\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebold\u003c/span\u003e())\n        .\u003cspan class=\"hljs-title function_\"\u003eforegroundStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eorange\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-title class_\"\u003eSpacer\u003c/span\u003e()\n    \u003cspan class=\"hljs-title class_\"\u003eSpacer\u003c/span\u003e()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLeading Text 앞에 Spacer를 하나 추가하고, Trailing Text 뒤에 Spacer를 두 개 더 추가했어요.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_8.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e스페이서를 추가할 때, 선두 텍스트는 선도를 기준으로 한 스페이서 만큼 멀어지고, 추적 텍스트는 후도를 기준으로 두 스페이서 만큼 멀어집니다.\u003c/p\u003e\n\u003cp\u003e그 결과로, 추적 텍스트는 선두 텍스트에 비해 기기 가장자리로부터 더 멀리 떨어지게 됩니다.\u003c/p\u003e\n\u003ch1\u003e데이터 목록 다루기\u003c/h1\u003e\n\u003cp\u003e데이터 목록에 대해, SwiftUI에는 List 또는 Foreach라는 두 가지 옵션이 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e목록\u003c/h2\u003e\n\u003cp\u003e목록은 UIKit의 UITableView와 같습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e numbers \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\n\n\u003cspan class=\"hljs-type\"\u003eList\u003c/span\u003e(numbers, id: \\.\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e) { number \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-subst\"\u003e\\(number)\u003c/span\u003e\"\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_9.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e안녕하세요!\u003c/p\u003e\n\u003cp\u003eMarkdown 형식으로 표를 변환하려면 다음과 같이 해보세요.\u003c/p\u003e\n\u003cp\u003eList에는 구분선, 카드 모양 등과 같은 준비된 UI가 포함되어 있습니다. 쉽죠!\u003c/p\u003e\n\u003ch2\u003eForeach\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e numbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\n\n\u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e {\n    \u003cspan class=\"hljs-title class_\"\u003eForEach\u003c/span\u003e(numbers, \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \\.\u003cspan class=\"hljs-property\"\u003eself\u003c/span\u003e) { number \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\(number)\"\u003c/span\u003e)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_10.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eThe Foreach construct offers a leaner alternative to the List component. With Foreach, you have full control over building your list UI, resulting in a simpler and more customizable approach.\u003c/p\u003e\n\u003ch2\u003eUpdating UI with Observable Property\u003c/h2\u003e\n\u003cp\u003eSwiftUI differs from UIKit by embracing the Declarative Programming approach.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e선언적 프로그래밍에서 UI는 Observable 값이나 속성의 변경을 관찰합니다.\u003c/p\u003e\n\u003cp\u003e값이 변경될 때마다 UI는 동적으로 변경 사항을 반영합니다.\u003c/p\u003e\n\u003cp\u003eSwiftUI의 기본 속성 래퍼(State 및 Binding)는 관찰 가능성을 활성화합니다:\u003c/p\u003e\n\u003cp\u003eState: 단방향 연결을 용이하게 해 주며 주로 연결된 뷰 내에서 사용됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e바인딩: 양방향 연결을 수립하고 상태 속성을 다른 뷰로 전송하는 데 사용됩니다.\u003c/p\u003e\n\u003ch2\u003e지금은 상태에 집중해 보겠습니다\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etext\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"초기 텍스트\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003eVStack\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003espacing\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e32\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e {\n        text = \u003cspan class=\"hljs-string\"\u003e\"수정된 변경\"\u003c/span\u003e\n    } \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: {\n        \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"텍스트 변경\"\u003c/span\u003e)\n            .\u003cspan class=\"hljs-title function_\"\u003efont\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebold\u003c/span\u003e())\n            .\u003cspan class=\"hljs-title function_\"\u003eforegroundStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ewhite\u003c/span\u003e)\n            .\u003cspan class=\"hljs-title function_\"\u003epadding\u003c/span\u003e()\n            .\u003cspan class=\"hljs-title function_\"\u003ebackground\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eblue\u003c/span\u003e)\n            .\u003cspan class=\"hljs-title function_\"\u003eclipShape\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eRoundedRectangle\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ecornerRadius\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e))\n    }\n\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(text)\n        .\u003cspan class=\"hljs-title function_\"\u003efont\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebold\u003c/span\u003e())\n        .\u003cspan class=\"hljs-title function_\"\u003eforegroundStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003eblue\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:590/1*UAzw-1G__azlbNUSfevu9Q.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e변경 텍스트 버튼 액션은 observable text 속성을 수정합니다. UI는 텍스트 속성의 변경 사항을 듣도록 설계되어 있으므로 자동으로 업데이트됩니다. 이 기능은 State 프로퍼티 래퍼로 가능해졌습니다.\u003c/p\u003e\n\u003ch1\u003e뷰\u003c/h1\u003e\n\u003cp\u003e모든 SwiftUI 뷰는 View 프로토콜을 준수하는 구조체입니다.\u003c/p\u003e\n\u003cp\u003e구조체는 클래스 상속을 허용하지 않으므로 SwiftUI 뷰는 프로토콜에만 준수할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위 특성들은 SwiftUI에서 뷰를 독립적이고 고유하게 보는 방식을 채택해야 함을 필요로 합니다.\u003c/p\u003e\n\u003cp\u003eUIKit에서는 UIViewController 및 UITableViewController와 같은 특정 뷰를 위한 기본 클래스를 생성하는 것이 일반적입니다. 이 습관에서 벗어나는 것은 어려울 수 있지만, 마음가짐을 바꿈으로써 가능합니다!\u003c/p\u003e\n\u003ch1\u003e유용한 구성 요소\u003c/h1\u003e\n\u003cp\u003eSwiftUI의 핵심 원칙 중 하나는 작성 코드를 줄이고 더 많은 작업을 하는 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e뒤에 표식을 확인 해주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-SwiftUIThinking_11.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003ch2\u003ePicker\u003c/h2\u003e\n\u003cp\u003eIt is a combination of UISegmentedControl and UIPickerView.\u003c/p\u003e\n\u003cp\u003eIt provides various styles such as wheel, inline, segmented, and palette.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e numbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\n@\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eselection\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eInt\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n\u003cspan class=\"hljs-title class_\"\u003ePicker\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Select\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eselection\u003c/span\u003e: $selection) {\n    \u003cspan class=\"hljs-title class_\"\u003eForEach\u003c/span\u003e(numbers, \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \\.\u003cspan class=\"hljs-property\"\u003eself\u003c/span\u003e) { number \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\(number)\"\u003c/span\u003e)\n    }\n}\n.\u003cspan class=\"hljs-title function_\"\u003epickerStyle\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003einline\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:590/1*fy8_zvsJAsM7_4dQB4QgdA.gif\" alt=\"Image Scale\"\u003e\u003c/p\u003e\n\u003ch1\u003e이미지 크기 조절\u003c/h1\u003e\n\u003cp\u003eSwiftUI가 처음 나온 이후, Apple은 이미지 라이브러리인 SF Symbols를 제공해 왔습니다. Image 뷰를 사용하여 이 라이브러리의 이미지에 쉽게 액세스할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e또한, Text 뷰의 글꼴 설정과 유사하게 이미지 크기를 조절할 수 있는 font 기능을 사용해 이미지의 크기를 조절할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003esystemName\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"house.fill\"\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003efont\u003c/span\u003e(.\u003cspan class=\"hljs-property\"\u003elargeTitle\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSwiftUI는 Apple 환경에서 프로젝트를 개발하는 새로운 방법입니다.\u003c/p\u003e\n\u003cp\u003eSwiftUI의 방식에 대해 생각을 조정하면 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e한번 그것을 할 수 있다면, SwiftUI의 문들이 완전히 열릴 것입니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-SwiftUIThinking"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>