<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>자바스크립트의 기본 타입과 참조 타입 이해하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="자바스크립트의 기본 타입과 참조 타입 이해하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="자바스크립트의 기본 타입과 참조 타입 이해하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript" data-gatsby-head="true"/><meta name="twitter:title" content="자바스크립트의 기본 타입과 참조 타입 이해하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 20:25" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">자바스크립트의 기본 타입과 참조 타입 이해하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="자바스크립트의 기본 타입과 참조 타입 이해하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">2<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>JavaScript을 다룰 때, 원시(primitive) 타입과 참조(reference) 타입의 차이를 알고 데이터가 가변(mutable)인지 불변(immutable)인지 이해하는 것이 매우 중요합니다. 간단한 용어로 설명해보겠습니다.</p>
<p>원시 타입
원시 타입은 자신의 값을 직접 저장하는 기본 데이터 유형입니다. 이에는 다음이 포함됩니다:</p>
<pre><code class="hljs language-js">- <span class="hljs-title class_">Number</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">100</span>과 같은 숫자
- <span class="hljs-title class_">String</span>: <span class="hljs-string">"hello"</span>, <span class="hljs-string">"123"</span>과 같은 문자열
- <span class="hljs-title class_">Boolean</span>: <span class="hljs-literal">true</span> 또는 <span class="hljs-literal">false</span>
- <span class="hljs-title class_">Null</span>: 어떠한 객체 값도 의도적으로 없음을 나타내는 특별한 값
- <span class="hljs-title class_">Undefined</span>: 할당된 값이 없는 변수를 나타냄
</code></pre>
<p>변수에 원시 값을 할당할 때, 값을 복사합니다.</p>
<div class="content-ad"></div>
<p>예시:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;
<span class="hljs-keyword">let</span> y = x;
y = <span class="hljs-number">20</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <span class="hljs-comment">// 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// 20</span>
</code></pre>
<p>참조형 타입
객체(Object)와 배열(Array)과 같은 참조형 타입은 데이터가 메모리에 어디에 저장되어 있는지를 가리키는 참조(또는 주소)를 저장합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> obj1 = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Ali"</span> };
<span class="hljs-keyword">let</span> obj2 = obj1;
obj2.<span class="hljs-property">name</span> = <span class="hljs-string">"Reza"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">name</span>); <span class="hljs-comment">// "Reza"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-property">name</span>); <span class="hljs-comment">// "Reza"</span>
</code></pre>
<div class="content-ad"></div>
<p>가변이란 무엇을 의미합니까?
가변이란 데이터가 생성된 후에 변경될 수 있다는 것을 의미합니다. JavaScript의 객체, 배열 및 함수는 가변입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> person = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Ali"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };
person.<span class="hljs-property">name</span> = <span class="hljs-string">"Reza"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person); <span class="hljs-comment">// { name: "Reza", age: 25 }</span>
<span class="hljs-comment">// 배열을 사용한 예시:</span>

<span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
numbers.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numbers); <span class="hljs-comment">// [1, 2, 3, 4]</span>
</code></pre>
<p>불변이란 무엇을 의미합니까?
불변이란 데이터가 생성된 후에는 변경할 수 없다는 것을 의미합니다. 숫자, 문자열 및 불리언과 같은 기본 유형은 불변입니다.</p>
<p>문자열을 사용한 예시:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> greeting = <span class="hljs-string">"Hello"</span>;
<span class="hljs-keyword">let</span> newGreeting = greeting.<span class="hljs-title function_">replace</span>(<span class="hljs-string">"H"</span>, <span class="hljs-string">"J"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(greeting); <span class="hljs-comment">// "Hello"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newGreeting); <span class="hljs-comment">// "Jello"</span>
</code></pre>
<p>왜 중요한가요?</p>
<ul>
<li>메모리 관리: 가변 데이터는 변경이 원본 데이터에 직접적으로 반영되기 때문에 메모리 사용을 최적화하는 데 도움이 됩니다.</li>
</ul>
<p>실용적인 팁:
객체나 배열을 다룰 때, 하나의 변수를 변경하면 다른 변수에도 같은 데이터를 참조하고 있다면 영향을 줄 수 있습니다. 이를 피하기 위해 깊은 복사(deep copy)를 사용할 수 있습니다.</p>
<pre><code class="hljs language-js">#### 객체의 깊은 복사:
<span class="hljs-keyword">let</span> original = { <span class="hljs-attr">name</span>: <span class="hljs-string">"Ali"</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };
<span class="hljs-keyword">let</span> copy = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(original));
copy.<span class="hljs-property">name</span> = <span class="hljs-string">"Reza"</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(original); <span class="hljs-comment">// { name: "Ali", age: 25 }</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copy); <span class="hljs-comment">// { name: "Reza", age: 25 }</span>

<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"content-ad"</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>

깊은 복사를 통해 원본 객체의 완전히 독립적인 복사본을 생성하므로 복사본을 변경해도 원본에는 영향을 미치지 않습니다.

---

이 개념을 이해하면 더 나은 코드를 작성하고 잠재적인 문제를 피할 수 있습니다. 이에 대해 어떻게 생각하시나요? 생각과 경험을 공유해 주세요!
</code></pre>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"자바스크립트의 기본 타입과 참조 타입 이해하기","description":"","date":"2024-05-17 20:25","slug":"2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript","content":"\n\nJavaScript을 다룰 때, 원시(primitive) 타입과 참조(reference) 타입의 차이를 알고 데이터가 가변(mutable)인지 불변(immutable)인지 이해하는 것이 매우 중요합니다. 간단한 용어로 설명해보겠습니다.\n\n원시 타입\n원시 타입은 자신의 값을 직접 저장하는 기본 데이터 유형입니다. 이에는 다음이 포함됩니다:\n\n```js\n- Number: 1, 2.5, 100과 같은 숫자\n- String: \"hello\", \"123\"과 같은 문자열\n- Boolean: true 또는 false\n- Null: 어떠한 객체 값도 의도적으로 없음을 나타내는 특별한 값\n- Undefined: 할당된 값이 없는 변수를 나타냄\n```\n\n변수에 원시 값을 할당할 때, 값을 복사합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n```js\nlet x = 10;\nlet y = x;\ny = 20;\nconsole.log(x); // 10\nconsole.log(y); // 20\n```\n\n참조형 타입\n객체(Object)와 배열(Array)과 같은 참조형 타입은 데이터가 메모리에 어디에 저장되어 있는지를 가리키는 참조(또는 주소)를 저장합니다.\n\n```js\nlet obj1 = { name: \"Ali\" };\nlet obj2 = obj1;\nobj2.name = \"Reza\";\nconsole.log(obj1.name); // \"Reza\"\nconsole.log(obj2.name); // \"Reza\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가변이란 무엇을 의미합니까?\n가변이란 데이터가 생성된 후에 변경될 수 있다는 것을 의미합니다. JavaScript의 객체, 배열 및 함수는 가변입니다.\n\n```js\nlet person = { name: \"Ali\", age: 25 };\nperson.name = \"Reza\";\nconsole.log(person); // { name: \"Reza\", age: 25 }\n// 배열을 사용한 예시:\n\nlet numbers = [1, 2, 3];\nnumbers.push(4);\nconsole.log(numbers); // [1, 2, 3, 4]\n```\n\n불변이란 무엇을 의미합니까?\n불변이란 데이터가 생성된 후에는 변경할 수 없다는 것을 의미합니다. 숫자, 문자열 및 불리언과 같은 기본 유형은 불변입니다.\n\n문자열을 사용한 예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet greeting = \"Hello\";\nlet newGreeting = greeting.replace(\"H\", \"J\");\nconsole.log(greeting); // \"Hello\"\nconsole.log(newGreeting); // \"Jello\"\n```\n\n왜 중요한가요?\n- 메모리 관리: 가변 데이터는 변경이 원본 데이터에 직접적으로 반영되기 때문에 메모리 사용을 최적화하는 데 도움이 됩니다.\n\n실용적인 팁:\n객체나 배열을 다룰 때, 하나의 변수를 변경하면 다른 변수에도 같은 데이터를 참조하고 있다면 영향을 줄 수 있습니다. 이를 피하기 위해 깊은 복사(deep copy)를 사용할 수 있습니다.\n\n```js\n#### 객체의 깊은 복사:\nlet original = { name: \"Ali\", age: 25 };\nlet copy = JSON.parse(JSON.stringify(original));\ncopy.name = \"Reza\";\nconsole.log(original); // { name: \"Ali\", age: 25 }\nconsole.log(copy); // { name: \"Reza\", age: 25 }\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n깊은 복사를 통해 원본 객체의 완전히 독립적인 복사본을 생성하므로 복사본을 변경해도 원본에는 영향을 미치지 않습니다.\n\n---\n\n이 개념을 이해하면 더 나은 코드를 작성하고 잠재적인 문제를 피할 수 있습니다. 이에 대해 어떻게 생각하시나요? 생각과 경험을 공유해 주세요!","ogImage":{"url":"/assets/img/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript_0.png"},"coverImage":"/assets/img/2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript_0.png","tag":["Tech"],"readingTime":2},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003eJavaScript을 다룰 때, 원시(primitive) 타입과 참조(reference) 타입의 차이를 알고 데이터가 가변(mutable)인지 불변(immutable)인지 이해하는 것이 매우 중요합니다. 간단한 용어로 설명해보겠습니다.\u003c/p\u003e\n\u003cp\u003e원시 타입\n원시 타입은 자신의 값을 직접 저장하는 기본 데이터 유형입니다. 이에는 다음이 포함됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e- \u003cspan class=\"hljs-title class_\"\u003eNumber\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2.5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e과 같은 숫자\n- \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"hello\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"123\"\u003c/span\u003e과 같은 문자열\n- \u003cspan class=\"hljs-title class_\"\u003eBoolean\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e 또는 \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n- \u003cspan class=\"hljs-title class_\"\u003eNull\u003c/span\u003e: 어떠한 객체 값도 의도적으로 없음을 나타내는 특별한 값\n- \u003cspan class=\"hljs-title class_\"\u003eUndefined\u003c/span\u003e: 할당된 값이 없는 변수를 나타냄\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e변수에 원시 값을 할당할 때, 값을 복사합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e y = x;\ny = \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x); \u003cspan class=\"hljs-comment\"\u003e// 10\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(y); \u003cspan class=\"hljs-comment\"\u003e// 20\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참조형 타입\n객체(Object)와 배열(Array)과 같은 참조형 타입은 데이터가 메모리에 어디에 저장되어 있는지를 가리키는 참조(또는 주소)를 저장합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e obj1 = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Ali\"\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e obj2 = obj1;\nobj2.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Reza\"\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(obj1.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"Reza\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(obj2.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \"Reza\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e가변이란 무엇을 의미합니까?\n가변이란 데이터가 생성된 후에 변경될 수 있다는 것을 의미합니다. JavaScript의 객체, 배열 및 함수는 가변입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e person = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Ali\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e };\nperson.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Reza\"\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(person); \u003cspan class=\"hljs-comment\"\u003e// { name: \"Reza\", age: 25 }\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 배열을 사용한 예시:\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e numbers = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e];\nnumbers.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(numbers); \u003cspan class=\"hljs-comment\"\u003e// [1, 2, 3, 4]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e불변이란 무엇을 의미합니까?\n불변이란 데이터가 생성된 후에는 변경할 수 없다는 것을 의미합니다. 숫자, 문자열 및 불리언과 같은 기본 유형은 불변입니다.\u003c/p\u003e\n\u003cp\u003e문자열을 사용한 예시:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e greeting = \u003cspan class=\"hljs-string\"\u003e\"Hello\"\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e newGreeting = greeting.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"H\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"J\"\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(greeting); \u003cspan class=\"hljs-comment\"\u003e// \"Hello\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(newGreeting); \u003cspan class=\"hljs-comment\"\u003e// \"Jello\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e왜 중요한가요?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e메모리 관리: 가변 데이터는 변경이 원본 데이터에 직접적으로 반영되기 때문에 메모리 사용을 최적화하는 데 도움이 됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e실용적인 팁:\n객체나 배열을 다룰 때, 하나의 변수를 변경하면 다른 변수에도 같은 데이터를 참조하고 있다면 영향을 줄 수 있습니다. 이를 피하기 위해 깊은 복사(deep copy)를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#### 객체의 깊은 복사:\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e original = { \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Ali\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eage\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e };\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e copy = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(original));\ncopy.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"Reza\"\u003c/span\u003e;\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(original); \u003cspan class=\"hljs-comment\"\u003e// { name: \"Ali\", age: 25 }\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(copy); \u003cspan class=\"hljs-comment\"\u003e// { name: \"Reza\", age: 25 }\u003c/span\u003e\n\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"content-ad\"\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\n깊은 복사를 통해 원본 객체의 완전히 독립적인 복사본을 생성하므로 복사본을 변경해도 원본에는 영향을 미치지 않습니다.\n\n---\n\n이 개념을 이해하면 더 나은 코드를 작성하고 잠재적인 문제를 피할 수 있습니다. 이에 대해 어떻게 생각하시나요? 생각과 경험을 공유해 주세요!\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-UnderstandingPrimitiveandReferenceTypesinJavaScript"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>