<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>앵귤러 애니메이션 튜토리얼 라우트 전환 쉽게 배우기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-AngularAnimationsTutorialRouteTransitions" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="앵귤러 애니메이션 튜토리얼 라우트 전환 쉽게 배우기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="앵귤러 애니메이션 튜토리얼 라우트 전환 쉽게 배우기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-AngularAnimationsTutorialRouteTransitions_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-AngularAnimationsTutorialRouteTransitions" data-gatsby-head="true"/><meta name="twitter:title" content="앵귤러 애니메이션 튜토리얼 라우트 전환 쉽게 배우기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-AngularAnimationsTutorialRouteTransitions_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 03:31" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">앵귤러 애니메이션 튜토리얼 라우트 전환 쉽게 배우기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="앵귤러 애니메이션 튜토리얼 라우트 전환 쉽게 배우기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-AngularAnimationsTutorialRouteTransitions&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>만약 라우팅을 갖춘 Angular 애플리케이션을 다룬 적이 있다면, 루트 간 이동 시에 트랜지션을 추가하고 싶었을 것입니다. 이렇게 하면 애플리케이션이 전체적으로 더 우아해 보입니다. 알고 계셨나요? Animation 모듈을 이용하면 이를 쉽게 구현할 수 있습니다. 이번 예제에서 그 방법을 보여드리겠습니다. 그럼 시작해봅시다.</p>
<h1>시작하기 전에</h1>
<p>자, 그러기 전에 너무 멀리 나가기 전에 Angular의 애니메이션 프레임워크에 중점을 둔 다수의 포스트를 이미 만들었다는 것을 기억하는 것이 중요합니다.</p>
<h2>Angular 애니메이션 자습서:</h2>
<ul>
<li>기초 학습</li>
<li>입장 및 퇴장 애니메이션</li>
<li>Keyframes 기능</li>
<li>쿼리 및 Stagger 함수</li>
<li>시작 및 완료 이벤트</li>
<li>병렬 애니메이션</li>
<li>알 수 없는 높이로 애니메이션 설정하기</li>
<li>매개변수로 유연성 추가</li>
<li>재사용 가능한 애니메이션 생성</li>
<li>애니메이션 비활성화 및 활성화</li>
</ul>
<p>위 포스트들은 다양한 애니메이션 주제를 다루고 있습니다. 따라서 이 중 어떤 개념이 익숙하지 않다면, 이 포스트들을 먼저 확인해보는 것이 좋습니다. 그렇지 않으면 이 예제에서 헤맬 수 있습니다.</p>
<p>그리고, 이것들을 쉽게 찾을 수 있도록 우리는 Angular Animation 재생 목록을 YouTube 채널에서 만들었으니 확인해보세요!</p>
<p>좋아요, 충분하니까, 이제 이 포스트의 예제로 넘어가 보겠습니다.</p>
<h1>데모 애플리케이션</h1>
<p>이 예제에서는 이 간단한 데모 애플리케이션을 사용할 것입니다. 이동할 수 있는 몇 가지 다른 페이지가 있습니다. 주 메뉴에서 링크를 클릭하면 해당 페이지로 이동됩니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*wysR9eAe-EwO7yxd.gif" alt="image"></p>
<p>하지만 서로 다른 페이지로 이동할 때 전환 효과가 있는 것이 더 좋을 것입니다. 여기서 보는 것처럼 횡단페이드 효과나 다른 효과가 있으면 좋을 것 같습니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*-Szw6y8W09ki2NN9.gif" alt="image"></p>
<p>요번 예제에서 우리가 할 일이 바로 이것입니다. 하지만 먼저, 필요한 내용을 더 잘 이해하기 위해 기존 코드를 살펴보겠습니다.</p>
<h1>기존 코드</h1>
<p>그래, 언급했듯이, 이 앱은 이미 라우팅이 설정되어 있습니다. 따라서, 앱 컴포넌트를 살펴보면 템플릿에 router-outlet이 있다는 것을 알 수 있습니다.</p>
<h2>main.ts</h2>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Component</span>({
    <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
    <span class="hljs-attr">template</span>: <span class="hljs-string">`
        &#x3C;app-nav>&#x3C;/app-nav>
        &#x3C;router-outlet>&#x3C;/router-outlet>
    `</span>,
    ...
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> {
}
</code></pre>
<p>내비게이션 구성 요소의 링크 중 하나를 클릭하면 라우트된 구성 요소가 router-outlet 요소의 형제로 삽입됩니다. 라우트 구성을 살펴보면, 주소 표시줄에서 볼 경로와 해당 경로로 이동할 때 표시하려는 구성 요소를 모두 제공한 곳입니다.</p>
<p>따라서 예를 들어 "blog" 경로로 이동하면 BlogComponent가 표시됩니다.</p>
<pre><code class="hljs language-js">{
    <span class="hljs-attr">path</span>: <span class="hljs-string">'blog'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">BlogComponent</span>,
    <span class="hljs-attr">title</span>: <span class="hljs-string">'우리 블로그'</span>,
}
</code></pre>
<p>또는 "contact" 경로로 이동하면 ContactComponent가 표시됩니다.</p>
<pre><code class="hljs language-js">{
    <span class="hljs-attr">path</span>: <span class="hljs-string">'contact'</span>,
    <span class="hljs-attr">component</span>: <span class="hljs-title class_">ContactComponent</span>,
    <span class="hljs-attr">title</span>: <span class="hljs-string">'문의하기'</span>,
}
</code></pre>
<p>이해하셨죠? 새 경로의 활성 컴포넌트는 Angular 애니메이션 측면에서 "입력" 항목으로 간주됩니다. 그리고 이전 경로의 컴포넌트는 "떠나는" 항목으로 간주됩니다. 이것은 두 개를 모두 애니메이션화하는 방법을 갖게 될 것을 의미합니다.</p>
<p>만약 "입장" 및 "퇴장" 애니메이션 개념이 익숙하지 않다면, 여기에 비디오가 있으니 꼭 확인해보세요. 개념을 더 잘 이해할 수 있습니다.</p>
<h1>라우트 전환 애니메이션 만들기</h1>
<p>자, 지금까지 모든 작업 방식에 대한 이해가 되었으니, 이제 애니메이션을 만드는 것부터 시작해봅시다. 이를 위해 애니메이션 코드를 추가하는 새 파일을 만들어야 합니다. "route-transition.ts" 라고 이름 짓겠습니다.</p>
<p>이제 내보낼 수 있는 상수를 추가해야 합니다. 앱 구성 요소에이 애니메이션을 가져올 수 있도록 하기 위해 "route-transition.ts"라고 이름 짓습니다. 상수의 이름은 "routeTransition"으로 지정해보겠습니다. 우리는 Angular 애니메이션 모듈에서 trigger() 함수를 사용하여 이를 설정할 것입니다. 이름으로도 routeTransition으로 지정할 수 있습니다.</p>
<h2>route-transition.ts</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { trigger } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/animations'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> routeTransition = <span class="hljs-title function_">trigger</span>(<span class="hljs-string">'routeTransition'</span>, [
]);
</code></pre>
<p>그 다음, transition() 함수가 필요합니다. 이 라우트 전환에서는 라우트 데이터 변경 시마다 실행되길 원할 것입니다. 따라서 별표(*)가 있는 모든 상태에서 다른 상태로 애니메이션을 적용할 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { ..., transition } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/animations'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> routeTransition = <span class="hljs-title function_">trigger</span>(<span class="hljs-string">'routeTransition'</span>, [
    <span class="hljs-title function_">transition</span>(<span class="hljs-string">'* => *'</span>, [
    ])
]);
</code></pre>
<p>이제 이 애니메이션에서 처음 할 일은 항목이 "숨겨진" 상태에서 시작하도록 설정하는 것입니다. 그러니까, entering 컴포넌트를 쿼리하기 위해 query() 함수를 추가해봐요. 그런 다음 시작 스타일을 제공할 수 있도록 style() 함수를 추가할 거에요. 우리는 불투명도가 0이고 크기가 0.9인 상태로 시작할 거에요. 마지막으로 해야 할 일은 entering 항목을 찾지 못했을 때의 선택적 플래그를 추가하는 것이에요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { ..., query, style } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/animations'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> routeTransition = <span class="hljs-title function_">trigger</span>(<span class="hljs-string">'routeTransition'</span>, [
    <span class="hljs-title function_">transition</span>(<span class="hljs-string">'* => *'</span>, [
        <span class="hljs-title function_">query</span>(<span class="hljs-string">':enter'</span>, [
            <span class="hljs-title function_">style</span>({ <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">scale</span>: <span class="hljs-number">0.9</span> }),
        ], { <span class="hljs-attr">optional</span>: <span class="hljs-literal">true</span> })
    ])
]);
</code></pre>
<p>그렇죠, 다음은 leaving 컴포넌트를 전환할거에요. 그래서 떠나는 항목을 쿼리하기 위해 또 다른 query() 함수를 추가해봅시다.</p>
<p>이 항목의 경우 시작 스타일이 필요하지 않습니다. 왜냐하면 자동적으로 완전히 불투명하고 전체 크기로 시작하거든요. 우리가 해야 할 일은 애니메이션을 추가해서 animate() 함수를 추가하는 것이에요. 이 애니메이션을 정말로 볼 수 있도록 하기 위해 우리는 일 초 동안 애니메이션을 수행하도록 설정할 거에요. 그런 다음 애니메이션 효과를 줄 스타일을 추가하기 위해 다른 style() 함수를 사용하도록 해봅시다.</p>
<p>테이블 태그를 Markdown 형식으로 변경해주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> routeTransition = <span class="hljs-title function_">trigger</span>(<span class="hljs-string">'routeTransition'</span>, [
    <span class="hljs-title function_">transition</span>(<span class="hljs-string">'* => *'</span>, [
        ...,
        <span class="hljs-title function_">query</span>(<span class="hljs-string">':enter'</span>, [
            <span class="hljs-title function_">animate</span>(<span class="hljs-string">'1s'</span>, <span class="hljs-title function_">style</span>({ <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">scale</span>: <span class="hljs-number">1</span> }))
        ], { <span class="hljs-attr">optional</span>: <span class="hljs-literal">true</span> })
    ])
]);
</code></pre>
<p>자, 애니메이션에 필요한 모든 것을 추가했습니다. 이제 전환하여 앱 컴포넌트에 추가할 수 있습니다.</p>
<h1>부모 컴포넌트에 라우트 전환 애니메이션 추가</h1>
<p>애니메이션을 사용하려면 먼저 컴포넌트 메타데이터에 애니메이션 배열을 추가해야 합니다. 이 배열 내에서 새 "routeTransition" 애니메이션을 추가해보세요.</p>
<h2>main.ts</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { routeTransition } <span class="hljs-keyword">from</span> <span class="hljs-string">'./route-transition'</span>;

@<span class="hljs-title class_">Component</span>({
    <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
    ...,
    <span class="hljs-attr">animations</span>: [
        routeTransition
    ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> {
}
</code></pre>
<p>그럼, 이제 이것을 연결할 수 있습니다. 그전에 이 레이아웃이 어떻게 작동하는지 이해하는 것이 중요합니다. 그리드를 사용합니다. 첫 번째 열은 내비게이션을 위한 것이고, 두 번째 열은 라우트된 컴포넌트를 위한 것입니다. router-outlet의 형제인 모든 것은 두 번째 그리드 열에 배치됩니다. 즉, 들어오고 나가는 항목 모두 이 열 안에 서로 겹쳐 있습니다.</p>
<p>안타깝게도 여기서 해야할 일이 라우터 출력 주위에 컨테이너를 추가하는 것입니다. 애니메이션을 제대로 연결하려면 들어오고 나가는 항목을 쿼리할 수 있어야 하기 때문입니다.</p>
<p>하지만 걱정하지 마세요. display: contents로 설정하여 사실상 보이지 않도록 만들 수 있습니다. 그래서, div를 추가하고 이 div에 display, contents 스타일을 추가합시다.</p>
<pre><code class="hljs language-js">&#x3C;div style=<span class="hljs-string">"display: contents"</span>>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">router-outlet</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">router-outlet</span>></span></span>
&#x3C;/div>
</code></pre>
<p>그래서 여기가 우리가 애니메이션 트리거를 바인딩할 곳이며, 어떤 것에 바인딩하여 경로를 변경할 때 트리거할 것인가요?</p>
<h1>경로 전환을 트리거하는 방법</h1>
<p>루트를 변경할 때 활성 라우트의 스냅샷 데이터 개체를 사용할 수 있습니다.</p>
<p>이를 위해 생성자를 추가해야 합니다. 그런 다음 ActivatedRoute를 주입해야 합니다. "route"라는 이름의 보호된 필드를 만들고 ActivatedRoute 클래스에 주입해야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { ..., <span class="hljs-title class_">ActivatedRoute</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;

@<span class="hljs-title class_">Component</span>({
    <span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
    ...
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">protected route: ActivatedRoute</span>) {
    }
}
</code></pre>
<p>이제 애니메이션 트리거를 div에 바인딩해봅시다. route, snapshot, data 객체에 바인딩할 거에요. 이 객체는 route가 변경될 때마다 업데이트되니 우리 애니메이션을 제대로 트리거하게 될 거에요.</p>
<pre><code class="hljs language-js">&#x3C;div [@routeTransition]=<span class="hljs-string">"route.snapshot.data"</span> style=<span class="hljs-string">"display: contents"</span>>
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">router-outlet</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">router-outlet</span>></span></span>
&#x3C;/div>
</code></pre>
<p>좋아요, 거의 다 왔어요. 이 애니메이션이 작동하려면 providers 배열에 provideAnimations() 함수를 추가하여 애니메이션을 활성화해야 합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { provideAnimations } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser/animations'</span>;

<span class="hljs-title function_">bootstrapApplication</span>(<span class="hljs-title class_">App</span>, {
    <span class="hljs-attr">providers</span>: [ 
        ...,
        <span class="hljs-title function_">provideAnimations</span>()
    ]
});
</code></pre>
<p>좋아요, 이제 라우트 간에 전환할 때 필요한 모든 것이 준비되었어요. 이제 저장하고 시도해봅시다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*ZC_28tRmHkrNc482.gif" alt="image"></p>
<p>좋아요, 나가는 구성 요소와 들어오는 구성 요소를 모두 제대로 애니메이션화하는 것 같아요. 이제 조금 이상해 보이죠, 주로 얼마나 느리게 애니메이션되는지 때문에요. 기억하시죠, 나가는 항목에 1초간, 들어오는 항목에 또 1초간 애니메이션을 주고 있어요. 이것은 이러한 유형의 전환에 대해 꽤 느린 속도에요. 하지만 이 애니메이션이 어떻게 작동하는지 제시하고 싶었어요.</p>
<p>이제 작동하는 것을 볼 수 있고, 그것을 이해했으니, 0.2초와 같이 짧은 기간으로 전환해봅시다.</p>
<h2>route-transition.ts</h2>
<pre><code class="hljs language-js">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> routeTransition = <span class="hljs-title function_">trigger</span>(<span class="hljs-string">'routeTransition'</span>, [
        <span class="hljs-title function_">transition</span>(<span class="hljs-string">'* => *'</span>, [
            ...,
            <span class="hljs-title function_">query</span>(<span class="hljs-string">':leave'</span>, [
                <span class="hljs-title function_">animate</span>(<span class="hljs-string">'0.2s'</span>, ...)
            ], ...),
            <span class="hljs-title function_">query</span>(<span class="hljs-string">':enter'</span>, [
                <span class="hljs-title function_">animate</span>(<span class="hljs-string">'0.2s'</span>, ...)
            ], ...)
        ])
    ]);
</code></pre>
<p>이제 저장하고 다시 시도해 보세요.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*FyBZwrhqsmy4Y9XB.gif" alt="이미지"></p>
<p>잘 했어요!</p>
<h1>결론</h1>
<p>물론, 이러한 종류의 애니메이션을 만드는 다양한 방법이 있습니다. 이제 Angular 애플리케이션에 라우트 전환을 추가하기 위해 필요한 모든 것을 알았으니, 상상력만이 당신을 막는 것일 뿐입니다.</p>
<p>아직도 Angular 애니메이션에 대해 다룰 내용이 많이 남아 있지만, 여기까지 하겠습니다. 앞으로 미래의 게시물을 계속 주시기 바랍니다.</p>
<h1>실제로 보고 싶으세요?</h1>
<p>Stackblitz 예시에서 이 기술들의 데모 코드와 예시를 확인해보세요. 궁금한 점이나 생각이 있으시면 언제든 댓글을 남겨주세요.</p>
<h1>이 내용 중에 도움이 되는 것이 있으셨나요?</h1>
<p>만약 도움이 되는 내용이 있다면, 사랑을 표현해주고 싶다면 언제든 커피 한 잔 사주세요!</p>
<p>원래 2024년 6월 13일에 <a href="https://briantree.se%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">https://briantree.se에서</a> 게시된 내용입니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"앵귤러 애니메이션 튜토리얼 라우트 전환 쉽게 배우기","description":"","date":"2024-06-22 03:31","slug":"2024-06-22-AngularAnimationsTutorialRouteTransitions","content":"\n\n만약 라우팅을 갖춘 Angular 애플리케이션을 다룬 적이 있다면, 루트 간 이동 시에 트랜지션을 추가하고 싶었을 것입니다. 이렇게 하면 애플리케이션이 전체적으로 더 우아해 보입니다. 알고 계셨나요? Animation 모듈을 이용하면 이를 쉽게 구현할 수 있습니다. 이번 예제에서 그 방법을 보여드리겠습니다. 그럼 시작해봅시다.\n\n# 시작하기 전에\n\n자, 그러기 전에 너무 멀리 나가기 전에 Angular의 애니메이션 프레임워크에 중점을 둔 다수의 포스트를 이미 만들었다는 것을 기억하는 것이 중요합니다.\n\n## Angular 애니메이션 자습서:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 기초 학습\n- 입장 및 퇴장 애니메이션\n- Keyframes 기능\n- 쿼리 및 Stagger 함수\n- 시작 및 완료 이벤트\n- 병렬 애니메이션\n- 알 수 없는 높이로 애니메이션 설정하기\n- 매개변수로 유연성 추가\n- 재사용 가능한 애니메이션 생성\n- 애니메이션 비활성화 및 활성화\n\n위 포스트들은 다양한 애니메이션 주제를 다루고 있습니다. 따라서 이 중 어떤 개념이 익숙하지 않다면, 이 포스트들을 먼저 확인해보는 것이 좋습니다. 그렇지 않으면 이 예제에서 헤맬 수 있습니다.\n\n그리고, 이것들을 쉽게 찾을 수 있도록 우리는 Angular Animation 재생 목록을 YouTube 채널에서 만들었으니 확인해보세요!\n\n좋아요, 충분하니까, 이제 이 포스트의 예제로 넘어가 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데모 애플리케이션\n\n이 예제에서는 이 간단한 데모 애플리케이션을 사용할 것입니다. 이동할 수 있는 몇 가지 다른 페이지가 있습니다. 주 메뉴에서 링크를 클릭하면 해당 페이지로 이동됩니다. \n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*wysR9eAe-EwO7yxd.gif)\n\n하지만 서로 다른 페이지로 이동할 때 전환 효과가 있는 것이 더 좋을 것입니다. 여기서 보는 것처럼 횡단페이드 효과나 다른 효과가 있으면 좋을 것 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*-Szw6y8W09ki2NN9.gif)\n\n요번 예제에서 우리가 할 일이 바로 이것입니다. 하지만 먼저, 필요한 내용을 더 잘 이해하기 위해 기존 코드를 살펴보겠습니다.\n\n# 기존 코드\n\n그래, 언급했듯이, 이 앱은 이미 라우팅이 설정되어 있습니다. 따라서, 앱 컴포넌트를 살펴보면 템플릿에 router-outlet이 있다는 것을 알 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## main.ts\n\n```js\n@Component({\n    selector: 'app-root',\n    template: `\n        \u003capp-nav\u003e\u003c/app-nav\u003e\n        \u003crouter-outlet\u003e\u003c/router-outlet\u003e\n    `,\n    ...\n})\nexport class App {\n}\n```\n\n내비게이션 구성 요소의 링크 중 하나를 클릭하면 라우트된 구성 요소가 router-outlet 요소의 형제로 삽입됩니다. 라우트 구성을 살펴보면, 주소 표시줄에서 볼 경로와 해당 경로로 이동할 때 표시하려는 구성 요소를 모두 제공한 곳입니다.\n\n따라서 예를 들어 \"blog\" 경로로 이동하면 BlogComponent가 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n    path: 'blog',\n    component: BlogComponent,\n    title: '우리 블로그',\n}\n```\n\n또는 \"contact\" 경로로 이동하면 ContactComponent가 표시됩니다.\n\n```js\n{\n    path: 'contact',\n    component: ContactComponent,\n    title: '문의하기',\n}\n```\n\n이해하셨죠? 새 경로의 활성 컴포넌트는 Angular 애니메이션 측면에서 \"입력\" 항목으로 간주됩니다. 그리고 이전 경로의 컴포넌트는 \"떠나는\" 항목으로 간주됩니다. 이것은 두 개를 모두 애니메이션화하는 방법을 갖게 될 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 \"입장\" 및 \"퇴장\" 애니메이션 개념이 익숙하지 않다면, 여기에 비디오가 있으니 꼭 확인해보세요. 개념을 더 잘 이해할 수 있습니다.\n\n# 라우트 전환 애니메이션 만들기\n\n자, 지금까지 모든 작업 방식에 대한 이해가 되었으니, 이제 애니메이션을 만드는 것부터 시작해봅시다. 이를 위해 애니메이션 코드를 추가하는 새 파일을 만들어야 합니다. \"route-transition.ts\" 라고 이름 짓겠습니다.\n\n이제 내보낼 수 있는 상수를 추가해야 합니다. 앱 구성 요소에이 애니메이션을 가져올 수 있도록 하기 위해 \"route-transition.ts\"라고 이름 짓습니다. 상수의 이름은 \"routeTransition\"으로 지정해보겠습니다. 우리는 Angular 애니메이션 모듈에서 trigger() 함수를 사용하여 이를 설정할 것입니다. 이름으로도 routeTransition으로 지정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## route-transition.ts\n\n```js\nimport { trigger } from '@angular/animations';\n\nexport const routeTransition = trigger('routeTransition', [\n]);\n```\n\n그 다음, transition() 함수가 필요합니다. 이 라우트 전환에서는 라우트 데이터 변경 시마다 실행되길 원할 것입니다. 따라서 별표(*)가 있는 모든 상태에서 다른 상태로 애니메이션을 적용할 것입니다.\n\n```js\nimport { ..., transition } from '@angular/animations';\n\nexport const routeTransition = trigger('routeTransition', [\n    transition('* =\u003e *', [\n    ])\n]);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이 애니메이션에서 처음 할 일은 항목이 \"숨겨진\" 상태에서 시작하도록 설정하는 것입니다. 그러니까, entering 컴포넌트를 쿼리하기 위해 query() 함수를 추가해봐요. 그런 다음 시작 스타일을 제공할 수 있도록 style() 함수를 추가할 거에요. 우리는 불투명도가 0이고 크기가 0.9인 상태로 시작할 거에요. 마지막으로 해야 할 일은 entering 항목을 찾지 못했을 때의 선택적 플래그를 추가하는 것이에요.\n\n```js\nimport { ..., query, style } from '@angular/animations';\n\nexport const routeTransition = trigger('routeTransition', [\n    transition('* =\u003e *', [\n        query(':enter', [\n            style({ opacity: 0, scale: 0.9 }),\n        ], { optional: true })\n    ])\n]);\n```\n\n그렇죠, 다음은 leaving 컴포넌트를 전환할거에요. 그래서 떠나는 항목을 쿼리하기 위해 또 다른 query() 함수를 추가해봅시다.\n\n이 항목의 경우 시작 스타일이 필요하지 않습니다. 왜냐하면 자동적으로 완전히 불투명하고 전체 크기로 시작하거든요. 우리가 해야 할 일은 애니메이션을 추가해서 animate() 함수를 추가하는 것이에요. 이 애니메이션을 정말로 볼 수 있도록 하기 위해 우리는 일 초 동안 애니메이션을 수행하도록 설정할 거에요. 그런 다음 애니메이션 효과를 줄 스타일을 추가하기 위해 다른 style() 함수를 사용하도록 해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport const routeTransition = trigger('routeTransition', [\n    transition('* =\u003e *', [\n        ...,\n        query(':enter', [\n            animate('1s', style({ opacity: 1, scale: 1 }))\n        ], { optional: true })\n    ])\n]);\n```\n\n자, 애니메이션에 필요한 모든 것을 추가했습니다. 이제 전환하여 앱 컴포넌트에 추가할 수 있습니다.\n\n# 부모 컴포넌트에 라우트 전환 애니메이션 추가\n\n애니메이션을 사용하려면 먼저 컴포넌트 메타데이터에 애니메이션 배열을 추가해야 합니다. 이 배열 내에서 새 \"routeTransition\" 애니메이션을 추가해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## main.ts\n\n```js\nimport { routeTransition } from './route-transition';\n\n@Component({\n    selector: 'app-root',\n    ...,\n    animations: [\n        routeTransition\n    ]\n})\nexport class App {\n}\n```\n\n그럼, 이제 이것을 연결할 수 있습니다. 그전에 이 레이아웃이 어떻게 작동하는지 이해하는 것이 중요합니다. 그리드를 사용합니다. 첫 번째 열은 내비게이션을 위한 것이고, 두 번째 열은 라우트된 컴포넌트를 위한 것입니다. router-outlet의 형제인 모든 것은 두 번째 그리드 열에 배치됩니다. 즉, 들어오고 나가는 항목 모두 이 열 안에 서로 겹쳐 있습니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*MTj1pIyBHdnErdu5.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안타깝게도 여기서 해야할 일이 라우터 출력 주위에 컨테이너를 추가하는 것입니다. 애니메이션을 제대로 연결하려면 들어오고 나가는 항목을 쿼리할 수 있어야 하기 때문입니다.\n\n하지만 걱정하지 마세요. display: contents로 설정하여 사실상 보이지 않도록 만들 수 있습니다. 그래서, div를 추가하고 이 div에 display, contents 스타일을 추가합시다.\n\n```js\n\u003cdiv style=\"display: contents\"\u003e\n    \u003crouter-outlet\u003e\u003c/router-outlet\u003e\n\u003c/div\u003e\n```\n\n그래서 여기가 우리가 애니메이션 트리거를 바인딩할 곳이며, 어떤 것에 바인딩하여 경로를 변경할 때 트리거할 것인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 경로 전환을 트리거하는 방법\n\n루트를 변경할 때 활성 라우트의 스냅샷 데이터 개체를 사용할 수 있습니다.\n\n이를 위해 생성자를 추가해야 합니다. 그런 다음 ActivatedRoute를 주입해야 합니다. \"route\"라는 이름의 보호된 필드를 만들고 ActivatedRoute 클래스에 주입해야 합니다.\n\n```js\nimport { ..., ActivatedRoute } from '@angular/router';\n\n@Component({\n    selector: 'app-root',\n    ...\n})\nexport class App {\n    constructor(protected route: ActivatedRoute) {\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 애니메이션 트리거를 div에 바인딩해봅시다. route, snapshot, data 객체에 바인딩할 거에요. 이 객체는 route가 변경될 때마다 업데이트되니 우리 애니메이션을 제대로 트리거하게 될 거에요.\n\n```js\n\u003cdiv [@routeTransition]=\"route.snapshot.data\" style=\"display: contents\"\u003e\n    \u003crouter-outlet\u003e\u003c/router-outlet\u003e\n\u003c/div\u003e\n```\n\n좋아요, 거의 다 왔어요. 이 애니메이션이 작동하려면 providers 배열에 provideAnimations() 함수를 추가하여 애니메이션을 활성화해야 합니다.\n\n```js\nimport { provideAnimations } from '@angular/platform-browser/animations';\n\nbootstrapApplication(App, {\n    providers: [ \n        ...,\n        provideAnimations()\n    ]\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요, 이제 라우트 간에 전환할 때 필요한 모든 것이 준비되었어요. 이제 저장하고 시도해봅시다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/0*ZC_28tRmHkrNc482.gif)\n\n좋아요, 나가는 구성 요소와 들어오는 구성 요소를 모두 제대로 애니메이션화하는 것 같아요. 이제 조금 이상해 보이죠, 주로 얼마나 느리게 애니메이션되는지 때문에요. 기억하시죠, 나가는 항목에 1초간, 들어오는 항목에 또 1초간 애니메이션을 주고 있어요. 이것은 이러한 유형의 전환에 대해 꽤 느린 속도에요. 하지만 이 애니메이션이 어떻게 작동하는지 제시하고 싶었어요.\n\n이제 작동하는 것을 볼 수 있고, 그것을 이해했으니, 0.2초와 같이 짧은 기간으로 전환해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## route-transition.ts\n\n```js\n    export const routeTransition = trigger('routeTransition', [\n        transition('* =\u003e *', [\n            ...,\n            query(':leave', [\n                animate('0.2s', ...)\n            ], ...),\n            query(':enter', [\n                animate('0.2s', ...)\n            ], ...)\n        ])\n    ]);\n```\n\n이제 저장하고 다시 시도해 보세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*FyBZwrhqsmy4Y9XB.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘 했어요!\n\n# 결론\n\n물론, 이러한 종류의 애니메이션을 만드는 다양한 방법이 있습니다. 이제 Angular 애플리케이션에 라우트 전환을 추가하기 위해 필요한 모든 것을 알았으니, 상상력만이 당신을 막는 것일 뿐입니다.\n\n아직도 Angular 애니메이션에 대해 다룰 내용이 많이 남아 있지만, 여기까지 하겠습니다. 앞으로 미래의 게시물을 계속 주시기 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 실제로 보고 싶으세요?\n\nStackblitz 예시에서 이 기술들의 데모 코드와 예시를 확인해보세요. 궁금한 점이나 생각이 있으시면 언제든 댓글을 남겨주세요.\n\n# 이 내용 중에 도움이 되는 것이 있으셨나요?\n\n만약 도움이 되는 내용이 있다면, 사랑을 표현해주고 싶다면 언제든 커피 한 잔 사주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n원래 2024년 6월 13일에 https://briantree.se에서 게시된 내용입니다.","ogImage":{"url":"/assets/img/2024-06-22-AngularAnimationsTutorialRouteTransitions_0.png"},"coverImage":"/assets/img/2024-06-22-AngularAnimationsTutorialRouteTransitions_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e만약 라우팅을 갖춘 Angular 애플리케이션을 다룬 적이 있다면, 루트 간 이동 시에 트랜지션을 추가하고 싶었을 것입니다. 이렇게 하면 애플리케이션이 전체적으로 더 우아해 보입니다. 알고 계셨나요? Animation 모듈을 이용하면 이를 쉽게 구현할 수 있습니다. 이번 예제에서 그 방법을 보여드리겠습니다. 그럼 시작해봅시다.\u003c/p\u003e\n\u003ch1\u003e시작하기 전에\u003c/h1\u003e\n\u003cp\u003e자, 그러기 전에 너무 멀리 나가기 전에 Angular의 애니메이션 프레임워크에 중점을 둔 다수의 포스트를 이미 만들었다는 것을 기억하는 것이 중요합니다.\u003c/p\u003e\n\u003ch2\u003eAngular 애니메이션 자습서:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e기초 학습\u003c/li\u003e\n\u003cli\u003e입장 및 퇴장 애니메이션\u003c/li\u003e\n\u003cli\u003eKeyframes 기능\u003c/li\u003e\n\u003cli\u003e쿼리 및 Stagger 함수\u003c/li\u003e\n\u003cli\u003e시작 및 완료 이벤트\u003c/li\u003e\n\u003cli\u003e병렬 애니메이션\u003c/li\u003e\n\u003cli\u003e알 수 없는 높이로 애니메이션 설정하기\u003c/li\u003e\n\u003cli\u003e매개변수로 유연성 추가\u003c/li\u003e\n\u003cli\u003e재사용 가능한 애니메이션 생성\u003c/li\u003e\n\u003cli\u003e애니메이션 비활성화 및 활성화\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위 포스트들은 다양한 애니메이션 주제를 다루고 있습니다. 따라서 이 중 어떤 개념이 익숙하지 않다면, 이 포스트들을 먼저 확인해보는 것이 좋습니다. 그렇지 않으면 이 예제에서 헤맬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그리고, 이것들을 쉽게 찾을 수 있도록 우리는 Angular Animation 재생 목록을 YouTube 채널에서 만들었으니 확인해보세요!\u003c/p\u003e\n\u003cp\u003e좋아요, 충분하니까, 이제 이 포스트의 예제로 넘어가 보겠습니다.\u003c/p\u003e\n\u003ch1\u003e데모 애플리케이션\u003c/h1\u003e\n\u003cp\u003e이 예제에서는 이 간단한 데모 애플리케이션을 사용할 것입니다. 이동할 수 있는 몇 가지 다른 페이지가 있습니다. 주 메뉴에서 링크를 클릭하면 해당 페이지로 이동됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*wysR9eAe-EwO7yxd.gif\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e하지만 서로 다른 페이지로 이동할 때 전환 효과가 있는 것이 더 좋을 것입니다. 여기서 보는 것처럼 횡단페이드 효과나 다른 효과가 있으면 좋을 것 같습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*-Szw6y8W09ki2NN9.gif\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e요번 예제에서 우리가 할 일이 바로 이것입니다. 하지만 먼저, 필요한 내용을 더 잘 이해하기 위해 기존 코드를 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003e기존 코드\u003c/h1\u003e\n\u003cp\u003e그래, 언급했듯이, 이 앱은 이미 라우팅이 설정되어 있습니다. 따라서, 앱 컴포넌트를 살펴보면 템플릿에 router-outlet이 있다는 것을 알 수 있습니다.\u003c/p\u003e\n\u003ch2\u003emain.ts\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-root'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003etemplate\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\n        \u0026#x3C;app-nav\u003e\u0026#x3C;/app-nav\u003e\n        \u0026#x3C;router-outlet\u003e\u0026#x3C;/router-outlet\u003e\n    `\u003c/span\u003e,\n    ...\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e {\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e내비게이션 구성 요소의 링크 중 하나를 클릭하면 라우트된 구성 요소가 router-outlet 요소의 형제로 삽입됩니다. 라우트 구성을 살펴보면, 주소 표시줄에서 볼 경로와 해당 경로로 이동할 때 표시하려는 구성 요소를 모두 제공한 곳입니다.\u003c/p\u003e\n\u003cp\u003e따라서 예를 들어 \"blog\" 경로로 이동하면 BlogComponent가 표시됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n    \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'blog'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eBlogComponent\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'우리 블로그'\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또는 \"contact\" 경로로 이동하면 ContactComponent가 표시됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n    \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'contact'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eContactComponent\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'문의하기'\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이해하셨죠? 새 경로의 활성 컴포넌트는 Angular 애니메이션 측면에서 \"입력\" 항목으로 간주됩니다. 그리고 이전 경로의 컴포넌트는 \"떠나는\" 항목으로 간주됩니다. 이것은 두 개를 모두 애니메이션화하는 방법을 갖게 될 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e만약 \"입장\" 및 \"퇴장\" 애니메이션 개념이 익숙하지 않다면, 여기에 비디오가 있으니 꼭 확인해보세요. 개념을 더 잘 이해할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e라우트 전환 애니메이션 만들기\u003c/h1\u003e\n\u003cp\u003e자, 지금까지 모든 작업 방식에 대한 이해가 되었으니, 이제 애니메이션을 만드는 것부터 시작해봅시다. 이를 위해 애니메이션 코드를 추가하는 새 파일을 만들어야 합니다. \"route-transition.ts\" 라고 이름 짓겠습니다.\u003c/p\u003e\n\u003cp\u003e이제 내보낼 수 있는 상수를 추가해야 합니다. 앱 구성 요소에이 애니메이션을 가져올 수 있도록 하기 위해 \"route-transition.ts\"라고 이름 짓습니다. 상수의 이름은 \"routeTransition\"으로 지정해보겠습니다. 우리는 Angular 애니메이션 모듈에서 trigger() 함수를 사용하여 이를 설정할 것입니다. 이름으로도 routeTransition으로 지정할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003eroute-transition.ts\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { trigger } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/animations'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e routeTransition = \u003cspan class=\"hljs-title function_\"\u003etrigger\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'routeTransition'\u003c/span\u003e, [\n]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 다음, transition() 함수가 필요합니다. 이 라우트 전환에서는 라우트 데이터 변경 시마다 실행되길 원할 것입니다. 따라서 별표(*)가 있는 모든 상태에서 다른 상태로 애니메이션을 적용할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { ..., transition } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/animations'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e routeTransition = \u003cspan class=\"hljs-title function_\"\u003etrigger\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'routeTransition'\u003c/span\u003e, [\n    \u003cspan class=\"hljs-title function_\"\u003etransition\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'* =\u003e *'\u003c/span\u003e, [\n    ])\n]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 이 애니메이션에서 처음 할 일은 항목이 \"숨겨진\" 상태에서 시작하도록 설정하는 것입니다. 그러니까, entering 컴포넌트를 쿼리하기 위해 query() 함수를 추가해봐요. 그런 다음 시작 스타일을 제공할 수 있도록 style() 함수를 추가할 거에요. 우리는 불투명도가 0이고 크기가 0.9인 상태로 시작할 거에요. 마지막으로 해야 할 일은 entering 항목을 찾지 못했을 때의 선택적 플래그를 추가하는 것이에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { ..., query, style } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/animations'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e routeTransition = \u003cspan class=\"hljs-title function_\"\u003etrigger\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'routeTransition'\u003c/span\u003e, [\n    \u003cspan class=\"hljs-title function_\"\u003etransition\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'* =\u003e *'\u003c/span\u003e, [\n        \u003cspan class=\"hljs-title function_\"\u003equery\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e':enter'\u003c/span\u003e, [\n            \u003cspan class=\"hljs-title function_\"\u003estyle\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003eopacity\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003escale\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.9\u003c/span\u003e }),\n        ], { \u003cspan class=\"hljs-attr\"\u003eoptional\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e })\n    ])\n]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그렇죠, 다음은 leaving 컴포넌트를 전환할거에요. 그래서 떠나는 항목을 쿼리하기 위해 또 다른 query() 함수를 추가해봅시다.\u003c/p\u003e\n\u003cp\u003e이 항목의 경우 시작 스타일이 필요하지 않습니다. 왜냐하면 자동적으로 완전히 불투명하고 전체 크기로 시작하거든요. 우리가 해야 할 일은 애니메이션을 추가해서 animate() 함수를 추가하는 것이에요. 이 애니메이션을 정말로 볼 수 있도록 하기 위해 우리는 일 초 동안 애니메이션을 수행하도록 설정할 거에요. 그런 다음 애니메이션 효과를 줄 스타일을 추가하기 위해 다른 style() 함수를 사용하도록 해봅시다.\u003c/p\u003e\n\u003cp\u003e테이블 태그를 Markdown 형식으로 변경해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e routeTransition = \u003cspan class=\"hljs-title function_\"\u003etrigger\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'routeTransition'\u003c/span\u003e, [\n    \u003cspan class=\"hljs-title function_\"\u003etransition\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'* =\u003e *'\u003c/span\u003e, [\n        ...,\n        \u003cspan class=\"hljs-title function_\"\u003equery\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e':enter'\u003c/span\u003e, [\n            \u003cspan class=\"hljs-title function_\"\u003eanimate\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'1s'\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003estyle\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003eopacity\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003escale\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e }))\n        ], { \u003cspan class=\"hljs-attr\"\u003eoptional\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e })\n    ])\n]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e자, 애니메이션에 필요한 모든 것을 추가했습니다. 이제 전환하여 앱 컴포넌트에 추가할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e부모 컴포넌트에 라우트 전환 애니메이션 추가\u003c/h1\u003e\n\u003cp\u003e애니메이션을 사용하려면 먼저 컴포넌트 메타데이터에 애니메이션 배열을 추가해야 합니다. 이 배열 내에서 새 \"routeTransition\" 애니메이션을 추가해보세요.\u003c/p\u003e\n\u003ch2\u003emain.ts\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { routeTransition } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./route-transition'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-root'\u003c/span\u003e,\n    ...,\n    \u003cspan class=\"hljs-attr\"\u003eanimations\u003c/span\u003e: [\n        routeTransition\n    ]\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e {\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그럼, 이제 이것을 연결할 수 있습니다. 그전에 이 레이아웃이 어떻게 작동하는지 이해하는 것이 중요합니다. 그리드를 사용합니다. 첫 번째 열은 내비게이션을 위한 것이고, 두 번째 열은 라우트된 컴포넌트를 위한 것입니다. router-outlet의 형제인 모든 것은 두 번째 그리드 열에 배치됩니다. 즉, 들어오고 나가는 항목 모두 이 열 안에 서로 겹쳐 있습니다.\u003c/p\u003e\n\u003cp\u003e안타깝게도 여기서 해야할 일이 라우터 출력 주위에 컨테이너를 추가하는 것입니다. 애니메이션을 제대로 연결하려면 들어오고 나가는 항목을 쿼리할 수 있어야 하기 때문입니다.\u003c/p\u003e\n\u003cp\u003e하지만 걱정하지 마세요. display: contents로 설정하여 사실상 보이지 않도록 만들 수 있습니다. 그래서, div를 추가하고 이 div에 display, contents 스타일을 추가합시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;div style=\u003cspan class=\"hljs-string\"\u003e\"display: contents\"\u003c/span\u003e\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003erouter-outlet\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003erouter-outlet\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/div\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그래서 여기가 우리가 애니메이션 트리거를 바인딩할 곳이며, 어떤 것에 바인딩하여 경로를 변경할 때 트리거할 것인가요?\u003c/p\u003e\n\u003ch1\u003e경로 전환을 트리거하는 방법\u003c/h1\u003e\n\u003cp\u003e루트를 변경할 때 활성 라우트의 스냅샷 데이터 개체를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이를 위해 생성자를 추가해야 합니다. 그런 다음 ActivatedRoute를 주입해야 합니다. \"route\"라는 이름의 보호된 필드를 만들고 ActivatedRoute 클래스에 주입해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { ..., \u003cspan class=\"hljs-title class_\"\u003eActivatedRoute\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/router'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eselector\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'app-root'\u003c/span\u003e,\n    ...\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprotected route: ActivatedRoute\u003c/span\u003e) {\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 애니메이션 트리거를 div에 바인딩해봅시다. route, snapshot, data 객체에 바인딩할 거에요. 이 객체는 route가 변경될 때마다 업데이트되니 우리 애니메이션을 제대로 트리거하게 될 거에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;div [@routeTransition]=\u003cspan class=\"hljs-string\"\u003e\"route.snapshot.data\"\u003c/span\u003e style=\u003cspan class=\"hljs-string\"\u003e\"display: contents\"\u003c/span\u003e\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003erouter-outlet\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003erouter-outlet\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;/div\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e좋아요, 거의 다 왔어요. 이 애니메이션이 작동하려면 providers 배열에 provideAnimations() 함수를 추가하여 애니메이션을 활성화해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { provideAnimations } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/platform-browser/animations'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title function_\"\u003ebootstrapApplication\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eApp\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003eproviders\u003c/span\u003e: [ \n        ...,\n        \u003cspan class=\"hljs-title function_\"\u003eprovideAnimations\u003c/span\u003e()\n    ]\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e좋아요, 이제 라우트 간에 전환할 때 필요한 모든 것이 준비되었어요. 이제 저장하고 시도해봅시다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*ZC_28tRmHkrNc482.gif\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e좋아요, 나가는 구성 요소와 들어오는 구성 요소를 모두 제대로 애니메이션화하는 것 같아요. 이제 조금 이상해 보이죠, 주로 얼마나 느리게 애니메이션되는지 때문에요. 기억하시죠, 나가는 항목에 1초간, 들어오는 항목에 또 1초간 애니메이션을 주고 있어요. 이것은 이러한 유형의 전환에 대해 꽤 느린 속도에요. 하지만 이 애니메이션이 어떻게 작동하는지 제시하고 싶었어요.\u003c/p\u003e\n\u003cp\u003e이제 작동하는 것을 볼 수 있고, 그것을 이해했으니, 0.2초와 같이 짧은 기간으로 전환해봅시다.\u003c/p\u003e\n\u003ch2\u003eroute-transition.ts\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    \u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e routeTransition = \u003cspan class=\"hljs-title function_\"\u003etrigger\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'routeTransition'\u003c/span\u003e, [\n        \u003cspan class=\"hljs-title function_\"\u003etransition\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'* =\u003e *'\u003c/span\u003e, [\n            ...,\n            \u003cspan class=\"hljs-title function_\"\u003equery\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e':leave'\u003c/span\u003e, [\n                \u003cspan class=\"hljs-title function_\"\u003eanimate\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'0.2s'\u003c/span\u003e, ...)\n            ], ...),\n            \u003cspan class=\"hljs-title function_\"\u003equery\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e':enter'\u003c/span\u003e, [\n                \u003cspan class=\"hljs-title function_\"\u003eanimate\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'0.2s'\u003c/span\u003e, ...)\n            ], ...)\n        ])\n    ]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 저장하고 다시 시도해 보세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*FyBZwrhqsmy4Y9XB.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e잘 했어요!\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e물론, 이러한 종류의 애니메이션을 만드는 다양한 방법이 있습니다. 이제 Angular 애플리케이션에 라우트 전환을 추가하기 위해 필요한 모든 것을 알았으니, 상상력만이 당신을 막는 것일 뿐입니다.\u003c/p\u003e\n\u003cp\u003e아직도 Angular 애니메이션에 대해 다룰 내용이 많이 남아 있지만, 여기까지 하겠습니다. 앞으로 미래의 게시물을 계속 주시기 바랍니다.\u003c/p\u003e\n\u003ch1\u003e실제로 보고 싶으세요?\u003c/h1\u003e\n\u003cp\u003eStackblitz 예시에서 이 기술들의 데모 코드와 예시를 확인해보세요. 궁금한 점이나 생각이 있으시면 언제든 댓글을 남겨주세요.\u003c/p\u003e\n\u003ch1\u003e이 내용 중에 도움이 되는 것이 있으셨나요?\u003c/h1\u003e\n\u003cp\u003e만약 도움이 되는 내용이 있다면, 사랑을 표현해주고 싶다면 언제든 커피 한 잔 사주세요!\u003c/p\u003e\n\u003cp\u003e원래 2024년 6월 13일에 \u003ca href=\"https://briantree.se%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://briantree.se에서\u003c/a\u003e 게시된 내용입니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-AngularAnimationsTutorialRouteTransitions"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>