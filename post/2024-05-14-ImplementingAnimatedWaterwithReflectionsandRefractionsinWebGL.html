<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>웹지엘WebGL로 애니메이션된 물 효과 구현하기 반사와 굴절 추가하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="웹지엘WebGL로 애니메이션된 물 효과 구현하기 반사와 굴절 추가하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="웹지엘WebGL로 애니메이션된 물 효과 구현하기 반사와 굴절 추가하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL" data-gatsby-head="true"/><meta name="twitter:title" content="웹지엘WebGL로 애니메이션된 물 효과 구현하기 반사와 굴절 추가하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 14:23" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">웹지엘WebGL로 애니메이션된 물 효과 구현하기 반사와 굴절 추가하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="웹지엘WebGL로 애니메이션된 물 효과 구현하기 반사와 굴절 추가하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_0.png" alt="워터 이미지"></p>
<p>물은 컴퓨터 그래픽에서 렌더링하기 가장 어려운 부분 중 하나이면서 동시에 가장 보상이 큰 요소 중 하나입니다, 특히 실시간으로 처리할 때입니다. 잘 보이는 물은 시각적으로 매력적이며 나는 항상 현실적인 물을 렌더링하는 도전에 매혹을 느꼈습니다. 그래서 나는 지난 몇 주간 WebGL 엔진에 물을 추가해 보았습니다. 이 게시물에서는 WebGL에서 물을 렌더링하는 데 사용할 수 있는 다양한 기술과 제가 구현한 것에 대해 알아보겠습니다.</p>
<h1>기본 물</h1>
<p>실시간 그래픽에서 물을 렌더링하는 여러 가지 방법이 있습니다. 장면의 모양에 따라 쉬울 수도, 매우 복잡할 수도 있습니다. 아마 가장 간단한 방법은 큰 파란색 사각형을 그리는 것입니다. 이것만으로도 Minecraft 환경과 같은 것에 충분할 수도 있습니다.</p>
<p>파란색 쿼드에서 발전하는 다음 단계는 원활한 애니메이션된 물 질감을 추가하고 루프를 돌아야 할 것입니다. 그러나 평면 물은 별로 흥미로워 보이지 않기 때문에 파도를 추가하는 것이 좋을 것 같습니다. 첫 번째 옵션은 쿼드를 훨씬 작은 쿼드 그리드로 세분화한 다음 버텍스의 y 위치를 버텍스 셰이더에서 애니메이션하는 것입니다. 이 접근 방식은 실제로 물 표면의 고도가 변경된다는 장점이 있습니다. 그러나 이러한 방법의 단점은 물의 크기와 규모에 따라 좋아 보이려면 많은 버텍스가 필요할 수 있다는 것입니다.</p>
<p>두 번째 옵션은 보통 선호하는 방법이라고 할 수 있는데, 노멀 맵으로 파도를 추가하는 것입니다. 이로 인해 물의 고도는 실제로 변경되지 않고 항상 완벽히 평평합니다. 노멀 맵은 표면과 빛이 상호 작용하는 방식을 변경하기 때문에 파도가 있는 것처럼 보입니다. 노멀은 프래그먼트 수준에서 계산되고 애니메이션되며, 이는 성능에 미치는 영향이 최소화되면서 작은 파도를 쉽게 추가할 수 있다는 것을 의미합니다.</p>
<p>과거에는 사인스 패턴이나 인터넷에서 가져온 물 질감 및 노멀 맵을 사용했었는데, 이는 학습과 테스트에는 적합한 방법이었습니다. 그러나 (유감스럽게도 아직 출시되지 않은) 독립 개발 게임을 작업할 때는 인터넷에서 무작위 텍스처를 사용할 수 없었습니다. 대신에 나는 연속 애니메이션된 물 질감과 노멀 맵을 만들기 위한 절차적 알고리즘을 만들었습니다. 이러한 질감을 만들기 위한 꼼수는 주기적 3D Perlin 잡음입니다. 주기적 3D 잡음은 3D 공간을 완벽하게 타일링하는 3D 쿠브로 상상할 수 있으며 쿠브의 모든 면이 이웃과 일치합니다. 그런 다음 Perlin 잡음의 값들을 물의 고도로 사용하여 메시를 만들고 노멀을 계산한 다음, RGB 값으로 인코딩하게 됩니다. 비슷하게 몇 가지 다른 푸른색을 섞어 색 질감을 만들 수 있습니다. 지금까지는 C++에서만 이를 구현했으며 JavaScript 및 WebGL의 이미지만 사용하고 있습니다. 그러나 이러한 텍스처는 상당히 크기 때문에 WebGL에서는 제한된 인터넷 속도 문제로 인해 훨씬 큰 문제가 됩니다. 앞으로는 이 접근 방식을 JavaScript로 변환하고 대용량 텍스처의 평균 다운로드 속도보다 더 빠르게 생성할 수 있는지 시도해 볼 수도 있을 것입니다.</p>
<h1>반사 및 굴절</h1>
<p>물의 가장 상징적인 측면 중 하나는 그 반사입니다: 고요한 빙하 호수에 산과 나무가 반영되는 모습, 해질녘의 색감이 바다에 반사되는 모습, 혹은 지역 연못에 당신의 반영. 반영은 정말 멋집니다. 하지만 광선 추적 없이 반사를 어떻게 렌더링할까요? 임의의 반사는 WebGL과 같은 래스터화 API로는 매우 어려우며, 레이 트레이싱 기술의 가장 큰 이점인 그림자와 함께 구현은 더욱 어렵습니다. 가장 좋은 선택은 사전에 빠져 나온 반사 큐브맵인데, 이는 플레이어 캐릭터와 같은 동적 실시간 객체를 반사할 수 없습니다.</p>
<p>그러나 큰 물 표면은 행운의 예외입니다. 생각해 보면, 물체의 반사는 마치 수면 아래서 보는 듯한 것이다.</p>
<p><img src="/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_1.png" alt="image"></p>
<p>이는 단순히 카메라를 물 표면에 반사시키고 새로운 카메라 위치에서 장면을 텍스처로 렌더링하는 것을 의미합니다. 물 표면 아래의 모든 것은 어차피 반사될 수 없기 때문에 제거됩니다. 같은 트릭은 굴절에도 작동합니다. 장면은 일반 카메라 위치에서 또 다른 텍스처로 렌더링되며, 물 표면 위의 모든 것이 잘립니다.</p>
<p>하지만, 이는 추가적인 렌더링 패스 두 개를 추가합니다. 낮은 해상도와 더 적은 세부 정보로 렌더링할 수 있지만, 장면의 복잡성에 따라 프레임 시간에 상당한 시간을 추가할 수 있습니다.</p>
<p>물 표면이 그려질 때, 보통 맵을 사용하여 반사와 굴절을 왜곡시킬 수 있어 물결에도 영향을 받게 만들 수 있습니다.</p>
<h1>구현</h1>
<p>일반 맵 파도나 반사를 위해 카메라를 반사하는 것과 같은 물 관련 트릭은 그 자체로 복잡하지 않습니다. 그러나 잘 보이는 물을 얻기 위해서는 많은 작은 효과가 필요하며, 이러한 조합은 더 복잡해질 수 있습니다. 물이 잘 보이기 시작하려면 최소한 일련의 조작해야할 다양한 매개변수가 있습니다. 하나의 값이 너무 많이 벗어나면 상당히 나쁘게 보일 수 있습니다. 그러나 이것을 이용할 수도 있습니다. 몇 가지 매개변수를 이상한 값으로 설정하면 여전히 파란 물 텍스처를 사용하여 라바를 꽤 잘 보이게 만들 수도 있었습니다.</p>
<img src="/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_2.png">
<p>내 WebGL 물 구현은 그것이 기반으로하는 OpenGL 버전과 비교해서 큰 향상을 이루었습니다. 물을 사용하고 싶을 때, 물 개체를 만들고 반사 및 굴절할 모든 개체를 추가하기만 하면 됩니다. 복잡한 쉐이더 전환, 유니폼, 카메라 반사 등은 내부적으로 처리됩니다. 이것이 지난 리팩터링 블로그 글에서 이야기한 쉐이더 모듈과 행렬 슬롯이 필요한 이유 중 하나였습니다. 외부에서 물 클래스를 사용하는 것은 매우 깨끗하고 간단하지만, 엔진 내부 코드는 여전히 복잡성을 줄이고 앞으로 유지보수 가능하도록 개선할 필요가 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> water = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sparrow</span>.<span class="hljs-title class_">Water</span>( engine , { <span class="hljs-comment">/* 물 옵션 */</span> } );
water.<span class="hljs-title function_">addObject</span>( cube );
water.<span class="hljs-title function_">addObject</span>( model );
</code></pre>
<p>WebGL이나 다른 그래픽 API에서 물을 렌더링하는 것은 매우 간단한 경우부터 매우 복잡한 경우까지 다양한데, 이를 수행하는 여러 가지 방법과 맞춰야 할 많은 세부 사항이 있기 때문입니다. 그러나 이 포스트가 무엇이 필요한지에 대한 좋은 아이디어를 제공했으면 좋겠습니다. 현재 물 구현의 상태에 만족하고 있지만, 미래에 다양한 시나리오에 대해 더 맞춤화할 수 있도록 추가적인 컨트롤을 추가하고 싶습니다.</p>
<p>원문: <a href="https://pingpoli.de" rel="nofollow" target="_blank">https://pingpoli.de</a>.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"웹지엘WebGL로 애니메이션된 물 효과 구현하기 반사와 굴절 추가하기","description":"","date":"2024-05-14 14:23","slug":"2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL","content":"\n\n![워터 이미지](/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_0.png)\n\n물은 컴퓨터 그래픽에서 렌더링하기 가장 어려운 부분 중 하나이면서 동시에 가장 보상이 큰 요소 중 하나입니다, 특히 실시간으로 처리할 때입니다. 잘 보이는 물은 시각적으로 매력적이며 나는 항상 현실적인 물을 렌더링하는 도전에 매혹을 느꼈습니다. 그래서 나는 지난 몇 주간 WebGL 엔진에 물을 추가해 보았습니다. 이 게시물에서는 WebGL에서 물을 렌더링하는 데 사용할 수 있는 다양한 기술과 제가 구현한 것에 대해 알아보겠습니다.\n\n# 기본 물\n\n실시간 그래픽에서 물을 렌더링하는 여러 가지 방법이 있습니다. 장면의 모양에 따라 쉬울 수도, 매우 복잡할 수도 있습니다. 아마 가장 간단한 방법은 큰 파란색 사각형을 그리는 것입니다. 이것만으로도 Minecraft 환경과 같은 것에 충분할 수도 있습니다.\n\n\n\n파란색 쿼드에서 발전하는 다음 단계는 원활한 애니메이션된 물 질감을 추가하고 루프를 돌아야 할 것입니다. 그러나 평면 물은 별로 흥미로워 보이지 않기 때문에 파도를 추가하는 것이 좋을 것 같습니다. 첫 번째 옵션은 쿼드를 훨씬 작은 쿼드 그리드로 세분화한 다음 버텍스의 y 위치를 버텍스 셰이더에서 애니메이션하는 것입니다. 이 접근 방식은 실제로 물 표면의 고도가 변경된다는 장점이 있습니다. 그러나 이러한 방법의 단점은 물의 크기와 규모에 따라 좋아 보이려면 많은 버텍스가 필요할 수 있다는 것입니다.\n\n두 번째 옵션은 보통 선호하는 방법이라고 할 수 있는데, 노멀 맵으로 파도를 추가하는 것입니다. 이로 인해 물의 고도는 실제로 변경되지 않고 항상 완벽히 평평합니다. 노멀 맵은 표면과 빛이 상호 작용하는 방식을 변경하기 때문에 파도가 있는 것처럼 보입니다. 노멀은 프래그먼트 수준에서 계산되고 애니메이션되며, 이는 성능에 미치는 영향이 최소화되면서 작은 파도를 쉽게 추가할 수 있다는 것을 의미합니다.\n\n과거에는 사인스 패턴이나 인터넷에서 가져온 물 질감 및 노멀 맵을 사용했었는데, 이는 학습과 테스트에는 적합한 방법이었습니다. 그러나 (유감스럽게도 아직 출시되지 않은) 독립 개발 게임을 작업할 때는 인터넷에서 무작위 텍스처를 사용할 수 없었습니다. 대신에 나는 연속 애니메이션된 물 질감과 노멀 맵을 만들기 위한 절차적 알고리즘을 만들었습니다. 이러한 질감을 만들기 위한 꼼수는 주기적 3D Perlin 잡음입니다. 주기적 3D 잡음은 3D 공간을 완벽하게 타일링하는 3D 쿠브로 상상할 수 있으며 쿠브의 모든 면이 이웃과 일치합니다. 그런 다음 Perlin 잡음의 값들을 물의 고도로 사용하여 메시를 만들고 노멀을 계산한 다음, RGB 값으로 인코딩하게 됩니다. 비슷하게 몇 가지 다른 푸른색을 섞어 색 질감을 만들 수 있습니다. 지금까지는 C++에서만 이를 구현했으며 JavaScript 및 WebGL의 이미지만 사용하고 있습니다. 그러나 이러한 텍스처는 상당히 크기 때문에 WebGL에서는 제한된 인터넷 속도 문제로 인해 훨씬 큰 문제가 됩니다. 앞으로는 이 접근 방식을 JavaScript로 변환하고 대용량 텍스처의 평균 다운로드 속도보다 더 빠르게 생성할 수 있는지 시도해 볼 수도 있을 것입니다.\n\n# 반사 및 굴절\n\n\n\n물의 가장 상징적인 측면 중 하나는 그 반사입니다: 고요한 빙하 호수에 산과 나무가 반영되는 모습, 해질녘의 색감이 바다에 반사되는 모습, 혹은 지역 연못에 당신의 반영. 반영은 정말 멋집니다. 하지만 광선 추적 없이 반사를 어떻게 렌더링할까요? 임의의 반사는 WebGL과 같은 래스터화 API로는 매우 어려우며, 레이 트레이싱 기술의 가장 큰 이점인 그림자와 함께 구현은 더욱 어렵습니다. 가장 좋은 선택은 사전에 빠져 나온 반사 큐브맵인데, 이는 플레이어 캐릭터와 같은 동적 실시간 객체를 반사할 수 없습니다.\n\n그러나 큰 물 표면은 행운의 예외입니다. 생각해 보면, 물체의 반사는 마치 수면 아래서 보는 듯한 것이다.\n\n![image](/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_1.png)\n\n이는 단순히 카메라를 물 표면에 반사시키고 새로운 카메라 위치에서 장면을 텍스처로 렌더링하는 것을 의미합니다. 물 표면 아래의 모든 것은 어차피 반사될 수 없기 때문에 제거됩니다. 같은 트릭은 굴절에도 작동합니다. 장면은 일반 카메라 위치에서 또 다른 텍스처로 렌더링되며, 물 표면 위의 모든 것이 잘립니다.\n\n\n\n하지만, 이는 추가적인 렌더링 패스 두 개를 추가합니다. 낮은 해상도와 더 적은 세부 정보로 렌더링할 수 있지만, 장면의 복잡성에 따라 프레임 시간에 상당한 시간을 추가할 수 있습니다.\n\n물 표면이 그려질 때, 보통 맵을 사용하여 반사와 굴절을 왜곡시킬 수 있어 물결에도 영향을 받게 만들 수 있습니다.\n\n# 구현\n\n일반 맵 파도나 반사를 위해 카메라를 반사하는 것과 같은 물 관련 트릭은 그 자체로 복잡하지 않습니다. 그러나 잘 보이는 물을 얻기 위해서는 많은 작은 효과가 필요하며, 이러한 조합은 더 복잡해질 수 있습니다. 물이 잘 보이기 시작하려면 최소한 일련의 조작해야할 다양한 매개변수가 있습니다. 하나의 값이 너무 많이 벗어나면 상당히 나쁘게 보일 수 있습니다. 그러나 이것을 이용할 수도 있습니다. 몇 가지 매개변수를 이상한 값으로 설정하면 여전히 파란 물 텍스처를 사용하여 라바를 꽤 잘 보이게 만들 수도 있었습니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_2.png\" /\u003e\n\n내 WebGL 물 구현은 그것이 기반으로하는 OpenGL 버전과 비교해서 큰 향상을 이루었습니다. 물을 사용하고 싶을 때, 물 개체를 만들고 반사 및 굴절할 모든 개체를 추가하기만 하면 됩니다. 복잡한 쉐이더 전환, 유니폼, 카메라 반사 등은 내부적으로 처리됩니다. 이것이 지난 리팩터링 블로그 글에서 이야기한 쉐이더 모듈과 행렬 슬롯이 필요한 이유 중 하나였습니다. 외부에서 물 클래스를 사용하는 것은 매우 깨끗하고 간단하지만, 엔진 내부 코드는 여전히 복잡성을 줄이고 앞으로 유지보수 가능하도록 개선할 필요가 있습니다.\n\n```js\nvar water = new Sparrow.Water( engine , { /* 물 옵션 */ } );\nwater.addObject( cube );\nwater.addObject( model );\n```\n\nWebGL이나 다른 그래픽 API에서 물을 렌더링하는 것은 매우 간단한 경우부터 매우 복잡한 경우까지 다양한데, 이를 수행하는 여러 가지 방법과 맞춰야 할 많은 세부 사항이 있기 때문입니다. 그러나 이 포스트가 무엇이 필요한지에 대한 좋은 아이디어를 제공했으면 좋겠습니다. 현재 물 구현의 상태에 만족하고 있지만, 미래에 다양한 시나리오에 대해 더 맞춤화할 수 있도록 추가적인 컨트롤을 추가하고 싶습니다.\n\n\n\n원문: https://pingpoli.de.","ogImage":{"url":"/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_0.png\" alt=\"워터 이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e물은 컴퓨터 그래픽에서 렌더링하기 가장 어려운 부분 중 하나이면서 동시에 가장 보상이 큰 요소 중 하나입니다, 특히 실시간으로 처리할 때입니다. 잘 보이는 물은 시각적으로 매력적이며 나는 항상 현실적인 물을 렌더링하는 도전에 매혹을 느꼈습니다. 그래서 나는 지난 몇 주간 WebGL 엔진에 물을 추가해 보았습니다. 이 게시물에서는 WebGL에서 물을 렌더링하는 데 사용할 수 있는 다양한 기술과 제가 구현한 것에 대해 알아보겠습니다.\u003c/p\u003e\n\u003ch1\u003e기본 물\u003c/h1\u003e\n\u003cp\u003e실시간 그래픽에서 물을 렌더링하는 여러 가지 방법이 있습니다. 장면의 모양에 따라 쉬울 수도, 매우 복잡할 수도 있습니다. 아마 가장 간단한 방법은 큰 파란색 사각형을 그리는 것입니다. 이것만으로도 Minecraft 환경과 같은 것에 충분할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e파란색 쿼드에서 발전하는 다음 단계는 원활한 애니메이션된 물 질감을 추가하고 루프를 돌아야 할 것입니다. 그러나 평면 물은 별로 흥미로워 보이지 않기 때문에 파도를 추가하는 것이 좋을 것 같습니다. 첫 번째 옵션은 쿼드를 훨씬 작은 쿼드 그리드로 세분화한 다음 버텍스의 y 위치를 버텍스 셰이더에서 애니메이션하는 것입니다. 이 접근 방식은 실제로 물 표면의 고도가 변경된다는 장점이 있습니다. 그러나 이러한 방법의 단점은 물의 크기와 규모에 따라 좋아 보이려면 많은 버텍스가 필요할 수 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003e두 번째 옵션은 보통 선호하는 방법이라고 할 수 있는데, 노멀 맵으로 파도를 추가하는 것입니다. 이로 인해 물의 고도는 실제로 변경되지 않고 항상 완벽히 평평합니다. 노멀 맵은 표면과 빛이 상호 작용하는 방식을 변경하기 때문에 파도가 있는 것처럼 보입니다. 노멀은 프래그먼트 수준에서 계산되고 애니메이션되며, 이는 성능에 미치는 영향이 최소화되면서 작은 파도를 쉽게 추가할 수 있다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e과거에는 사인스 패턴이나 인터넷에서 가져온 물 질감 및 노멀 맵을 사용했었는데, 이는 학습과 테스트에는 적합한 방법이었습니다. 그러나 (유감스럽게도 아직 출시되지 않은) 독립 개발 게임을 작업할 때는 인터넷에서 무작위 텍스처를 사용할 수 없었습니다. 대신에 나는 연속 애니메이션된 물 질감과 노멀 맵을 만들기 위한 절차적 알고리즘을 만들었습니다. 이러한 질감을 만들기 위한 꼼수는 주기적 3D Perlin 잡음입니다. 주기적 3D 잡음은 3D 공간을 완벽하게 타일링하는 3D 쿠브로 상상할 수 있으며 쿠브의 모든 면이 이웃과 일치합니다. 그런 다음 Perlin 잡음의 값들을 물의 고도로 사용하여 메시를 만들고 노멀을 계산한 다음, RGB 값으로 인코딩하게 됩니다. 비슷하게 몇 가지 다른 푸른색을 섞어 색 질감을 만들 수 있습니다. 지금까지는 C++에서만 이를 구현했으며 JavaScript 및 WebGL의 이미지만 사용하고 있습니다. 그러나 이러한 텍스처는 상당히 크기 때문에 WebGL에서는 제한된 인터넷 속도 문제로 인해 훨씬 큰 문제가 됩니다. 앞으로는 이 접근 방식을 JavaScript로 변환하고 대용량 텍스처의 평균 다운로드 속도보다 더 빠르게 생성할 수 있는지 시도해 볼 수도 있을 것입니다.\u003c/p\u003e\n\u003ch1\u003e반사 및 굴절\u003c/h1\u003e\n\u003cp\u003e물의 가장 상징적인 측면 중 하나는 그 반사입니다: 고요한 빙하 호수에 산과 나무가 반영되는 모습, 해질녘의 색감이 바다에 반사되는 모습, 혹은 지역 연못에 당신의 반영. 반영은 정말 멋집니다. 하지만 광선 추적 없이 반사를 어떻게 렌더링할까요? 임의의 반사는 WebGL과 같은 래스터화 API로는 매우 어려우며, 레이 트레이싱 기술의 가장 큰 이점인 그림자와 함께 구현은 더욱 어렵습니다. 가장 좋은 선택은 사전에 빠져 나온 반사 큐브맵인데, 이는 플레이어 캐릭터와 같은 동적 실시간 객체를 반사할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e그러나 큰 물 표면은 행운의 예외입니다. 생각해 보면, 물체의 반사는 마치 수면 아래서 보는 듯한 것이다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이는 단순히 카메라를 물 표면에 반사시키고 새로운 카메라 위치에서 장면을 텍스처로 렌더링하는 것을 의미합니다. 물 표면 아래의 모든 것은 어차피 반사될 수 없기 때문에 제거됩니다. 같은 트릭은 굴절에도 작동합니다. 장면은 일반 카메라 위치에서 또 다른 텍스처로 렌더링되며, 물 표면 위의 모든 것이 잘립니다.\u003c/p\u003e\n\u003cp\u003e하지만, 이는 추가적인 렌더링 패스 두 개를 추가합니다. 낮은 해상도와 더 적은 세부 정보로 렌더링할 수 있지만, 장면의 복잡성에 따라 프레임 시간에 상당한 시간을 추가할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e물 표면이 그려질 때, 보통 맵을 사용하여 반사와 굴절을 왜곡시킬 수 있어 물결에도 영향을 받게 만들 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e구현\u003c/h1\u003e\n\u003cp\u003e일반 맵 파도나 반사를 위해 카메라를 반사하는 것과 같은 물 관련 트릭은 그 자체로 복잡하지 않습니다. 그러나 잘 보이는 물을 얻기 위해서는 많은 작은 효과가 필요하며, 이러한 조합은 더 복잡해질 수 있습니다. 물이 잘 보이기 시작하려면 최소한 일련의 조작해야할 다양한 매개변수가 있습니다. 하나의 값이 너무 많이 벗어나면 상당히 나쁘게 보일 수 있습니다. 그러나 이것을 이용할 수도 있습니다. 몇 가지 매개변수를 이상한 값으로 설정하면 여전히 파란 물 텍스처를 사용하여 라바를 꽤 잘 보이게 만들 수도 있었습니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL_2.png\"\u003e\n\u003cp\u003e내 WebGL 물 구현은 그것이 기반으로하는 OpenGL 버전과 비교해서 큰 향상을 이루었습니다. 물을 사용하고 싶을 때, 물 개체를 만들고 반사 및 굴절할 모든 개체를 추가하기만 하면 됩니다. 복잡한 쉐이더 전환, 유니폼, 카메라 반사 등은 내부적으로 처리됩니다. 이것이 지난 리팩터링 블로그 글에서 이야기한 쉐이더 모듈과 행렬 슬롯이 필요한 이유 중 하나였습니다. 외부에서 물 클래스를 사용하는 것은 매우 깨끗하고 간단하지만, 엔진 내부 코드는 여전히 복잡성을 줄이고 앞으로 유지보수 가능하도록 개선할 필요가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e water = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSparrow\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eWater\u003c/span\u003e( engine , { \u003cspan class=\"hljs-comment\"\u003e/* 물 옵션 */\u003c/span\u003e } );\nwater.\u003cspan class=\"hljs-title function_\"\u003eaddObject\u003c/span\u003e( cube );\nwater.\u003cspan class=\"hljs-title function_\"\u003eaddObject\u003c/span\u003e( model );\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWebGL이나 다른 그래픽 API에서 물을 렌더링하는 것은 매우 간단한 경우부터 매우 복잡한 경우까지 다양한데, 이를 수행하는 여러 가지 방법과 맞춰야 할 많은 세부 사항이 있기 때문입니다. 그러나 이 포스트가 무엇이 필요한지에 대한 좋은 아이디어를 제공했으면 좋겠습니다. 현재 물 구현의 상태에 만족하고 있지만, 미래에 다양한 시나리오에 대해 더 맞춤화할 수 있도록 추가적인 컨트롤을 추가하고 싶습니다.\u003c/p\u003e\n\u003cp\u003e원문: \u003ca href=\"https://pingpoli.de\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://pingpoli.de\u003c/a\u003e.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-ImplementingAnimatedWaterwithReflectionsandRefractionsinWebGL"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>