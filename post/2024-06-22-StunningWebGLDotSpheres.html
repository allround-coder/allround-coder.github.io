<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>경이로운 WebGL 점 구체 만드는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-StunningWebGLDotSpheres" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="경이로운 WebGL 점 구체 만드는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="경이로운 WebGL 점 구체 만드는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-StunningWebGLDotSpheres" data-gatsby-head="true"/><meta name="twitter:title" content="경이로운 WebGL 점 구체 만드는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 13:43" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">경이로운 WebGL 점 구체 만드는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="경이로운 WebGL 점 구체 만드는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-StunningWebGLDotSpheres&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png" alt="Image"></p>
<p>최근에 Stripe와 GitHub에서 WebGL 지구 모형이 눈에 띄게 사용되면서 많은 관심을 받았습니다. 둘 다 자사 홈페이지에서 그것들을 주목적으로 활용했고, 이에 관한 블로그 포스트를 작성했습니다(Stripe의 포스트는 [여기](Stripe's link)에서 확인할 수 있고, GitHub의는 [여기](GitHub's link)에서 확인할 수 있습니다).</p>
<p>두 지구 모형은 대부분 점들로 이루어져 있는데, 이것이 저에게 구체 표면에 점들을 분산시키는 다양한 방법에 대해 생각해보게 했습니다. 구 형태에 대한 점 배치는 수학자들이 적극적으로 고민하는 복잡한 퍼즐로, 이 기사를 위해서 제가 몇 가지 기본적인 방법을 소개하고 WebGL에서 어떻게 구현할 수 있는지에 대해 제한했습니다.</p>
<h1>씬 설정하기</h1>
<p>현재 진행하기 전에, 구를 만들 WebGL 씬을 구축하는 것이 필요합니다. WebGL API와 상호 작용하기 위한 주요 프레임워크로 Three.js를 사용하고 있어요. 이 글의 코드 스니펫은 간결하고 관련성이 높도록 유지하고 있으니, 전체 코드를 확인하려면 포함된 샌드박스를 살펴보세요.</p>
<p>씬을 생성한 후, 모든 점에 대한 geometries를 포함할 dotGeometries 배열을 정의합니다. 그런 다음, 씬 내의 공간에 빈 벡터, 즉 3D 포인트를 생성하며, 해당 위치는 각각의 점을 만들 때마다 재할당됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 씬을 설정합니다.</span>
<span class="hljs-keyword">const</span> scene = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Scene</span>();

<span class="hljs-comment">// 모든 점의 geometries를 보관할 배열을 정의합니다.</span>
<span class="hljs-keyword">const</span> dotGeometries = [];

<span class="hljs-comment">// 점에서 사용할 빈 벡터를 생성합니다.</span>
<span class="hljs-keyword">const</span> vector = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>();

<span class="hljs-comment">// 이곳에서 점을 생성하고 위치를 지정합니다!</span>
</code></pre>
<p>점을 생성하고 그 geometries를 dotGeometries 배열에 넣은 후, mergeBufferGeometries 유틸리티를 사용하여 이를 하나의 geometry로 병합할 수 있습니다. 그런 다음, dot geometries에서 mesh를 생성하고, 이에 재질을 부여하고 씬에 추가하면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 모든 점 지오메트리를 하나의 버퍼 지오메트리로 병합합니다.</span>
<span class="hljs-keyword">const</span> mergedDotGeometries = <span class="hljs-title class_">BufferGeometryUtils</span>.<span class="hljs-title function_">mergeBufferGeometries</span>(
  dotGeometries
);

<span class="hljs-comment">// 점을 위한 재질을 정의합니다.</span>
<span class="hljs-keyword">const</span> dotMaterial = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>({
  <span class="hljs-attr">color</span>: <span class="hljs-variable constant_">DOT_COLOR</span>,
  <span class="hljs-attr">side</span>: <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">DoubleSide</span>
});

<span class="hljs-comment">// 점 지오메트리와 재질에서 점 메시를 생성합니다.</span>
<span class="hljs-keyword">const</span> dotMesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(mergedDotGeometries, dotMaterial);

<span class="hljs-comment">// 점 메시를 씬에 추가합니다.</span>
scene.<span class="hljs-title function_">add</span>(dotMesh);
</code></pre>
<p>이제 어떻게 점을 생성하고 배치할지 살펴봅시다.</p>
<h1>기본적인 접근 방법</h1>
<p>구에 점을 추가하는 가장 쉬운 방법은 단순히 구가 갖도록 원하는 위도 선 및 경도 선의 수를 정의한 다음 해당 선들에 따라 점을 배치하는 것입니다. 여기에는 몇 가지 중요한 사항이 있습니다.</p>
<p>먼저, 각 점에 대해 phi와 theta 각도를 정의합니다. 이러한 각도는 구 좌표계의 일부로, 점이 3D 공간에서 원점과의 관계를 정확히 나타내는 시스템입니다 (우리의 경우에는 구의 중심).</p>
<p>두 번째로, phi와 theta는 모두 라디안으로 측정됩니다. 핵심은 180º에 π 라디안이 있다는 것을 기억하는 것입니다. 여기서 phi를 찾기 위해선 단순히 π를 위도 주선 수로 나누면 됩니다. 그러나 theta를 찾기 위해서는 경도 주선 수로 2 * π를 나누어야 합니다. 왜냐하면 경도 주선이 구의 전체 360º를 계속 감싸도록 하기 때문입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 위도를 반복합니다.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> lat = <span class="hljs-number">0</span>; lat &#x3C; <span class="hljs-variable constant_">LATITUDE_COUNT</span>; lat += <span class="hljs-number">1</span>) {
  <span class="hljs-comment">// 경도를 반복합니다.</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> lng = <span class="hljs-number">0</span>; lng &#x3C; <span class="hljs-variable constant_">LONGITUDE_COUNT</span>; lng += <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// 점에 대한 geometry를 생성합니다.</span>
    <span class="hljs-keyword">const</span> dotGeometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">CircleGeometry</span>(<span class="hljs-variable constant_">DOT_SIZE</span>, <span class="hljs-number">5</span>);
    <span class="hljs-comment">// 점을 위한 phi와 theta 각도를 정의합니다.</span>
    <span class="hljs-keyword">const</span> phi = (<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-variable constant_">LATITUDE_COUNT</span>) * lat;
    <span class="hljs-keyword">const</span> theta = ((<span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) / <span class="hljs-variable constant_">LONGITUDE_COUNT</span>) * lng;

    <span class="hljs-comment">// 구 반지름, phi 및 theta에서 생성된 구 좌표를 사용하여 벡터를 설정합니다.</span>
    vector.<span class="hljs-title function_">setFromSphericalCoords</span>(<span class="hljs-variable constant_">SPHERE_RADIUS</span>, phi, theta);

    <span class="hljs-comment">// 점이 올바른 방향을 향하도록 합니다.</span>
    dotGeometry.<span class="hljs-title function_">lookAt</span>(vector);

    <span class="hljs-comment">// 점 geometry를 올바른 위치로 이동합니다.</span>
    dotGeometry.<span class="hljs-title function_">translate</span>(vector.<span class="hljs-property">x</span>, vector.<span class="hljs-property">y</span>, vector.<span class="hljs-property">z</span>);

    <span class="hljs-comment">// 위치 지정 geometry를 배열에 추가합니다.</span>
    dotGeometries.<span class="hljs-title function_">push</span>(dotGeometry);
  }
}
</code></pre>
<p>이렇게 해서 다음 결과를 얻을 수 있습니다:</p>
<p>만약 구를 회전시키면, 맨 위와 맨 아래의 고리가 가운데보다 훨씬 더 밀집되어 있는 것을 알게 될 거에요. 이는 각 위도선에 있는 점들의 개수를 다양하게 하지 않았기 때문입니다. 여기서 구 패킹이 필요한 때입니다.</p>
<h1>실로택시스 방법론</h1>
<p>해바라기 꽃의 머리나 솔방울의 바닥을 본 적이 있다면, 이상하고 독특한 패턴을 알아차릴 수 있을 겁니다. 이 패턴은 피보나치 수열을 기반으로 하는 배열에 의해 만들어져, 실로택시스로 알려져 있습니다. 이를 이용하여 점들을 구의 표면 위에 더 균일하게 위치시켜 보이도록 할 수 있습니다.</p>
<p>이번에는 위도와 경도 선의 개수를 정의하는 대신, 단순히 구에 나타나길 원하는 총 점의 수를 정의합니다. 위도 선을 가로지르는 대신, 점들은 구의 한 극에서 다른 극까지 단일하고 연속적인 나선 형태로 렌더링될 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 점의 개수만큼 반복합니다.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> dot = <span class="hljs-number">0</span>; dot &#x3C; <span class="hljs-variable constant_">DOT_COUNT</span>; dot += <span class="hljs-number">1</span>) {
  <span class="hljs-comment">// 점을 위한 geometry를 생성합니다.</span>
  <span class="hljs-keyword">const</span> dotGeometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">CircleGeometry</span>(<span class="hljs-variable constant_">DOT_SIZE</span>, <span class="hljs-number">5</span>);

  <span class="hljs-comment">// 각 점의 구면 좌표를 계산하여 피로태시스 패턴으로 만듭니다.</span>
  <span class="hljs-keyword">const</span> phi = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">acos</span>(-<span class="hljs-number">1</span> + (<span class="hljs-number">2</span> * dot) / <span class="hljs-variable constant_">DOT_COUNT</span>);
  <span class="hljs-keyword">const</span> theta = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(<span class="hljs-variable constant_">DOT_COUNT</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * phi;

  <span class="hljs-comment">// 구의 반지름, phi 및 theta에서 생성된 구면 좌표를 사용하여 벡터를 설정합니다.</span>
  vector.<span class="hljs-title function_">setFromSphericalCoords</span>(<span class="hljs-variable constant_">SPHERE_RADIUS</span>, phi, theta);

  ...

}
</code></pre>
<p>위와 같은 결과가 나타납니다.</p>
<p>이 방법은 훨씬 더 만족스럽습니다. 그러나 가능한 한 점들을 골고루 배치하고 싶지만 자유롭게 위도 선 수를 정의하고 싶다면 어떻게 해야 할까요?</p>
<h1>선형 접근법</h1>
<p>이번에는 필요한 위도선 수를 정의하되, 점의 수도 위치한 위도선의 둘레에 기반하여 조절됩니다. 간격에 대한 더 큰 제어를 위해 점 밀도 매개변수도 정의할 것입니다.</p>
<p>여기서 까다로운 부분은 각 위도선의 반지름을 계산하는 것입니다. 일단 그것을 구했다면, 얼마나 많은 점을 표시해야 하는지 간단히 알아내고, 각각에 대해 첫 번째 방법과 유사한 방식으로 파이와 세타를 찾는 것도 상대적으로 간단합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 위도 선을 가로지르는 루프</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> lat = <span class="hljs-number">0</span>; lat &#x3C; <span class="hljs-variable constant_">LATITUDE_COUNT</span>; lat += <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// 위도선의 반지름 계산</span>
    <span class="hljs-keyword">const</span> radius =
      <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>((-<span class="hljs-number">90</span> + (<span class="hljs-number">180</span> / <span class="hljs-variable constant_">LATITUDE_COUNT</span>) * lat) * (<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span>)) *
      <span class="hljs-variable constant_">SPHERE_RADIUS</span>;
    <span class="hljs-comment">// 위도선의 둘레 계산</span>
    <span class="hljs-keyword">const</span> latitudeCircumference = radius * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> * <span class="hljs-number">2</span>;
    <span class="hljs-comment">// 해당 위도선에 필요한 점의 수 계산</span>
    <span class="hljs-keyword">const</span> latitudeDotCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(latitudeCircumference * <span class="hljs-variable constant_">DOT_DENSITY</span>);

    <span class="hljs-comment">// 해당 위도선의 점 수에 대해 루프 수행</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> dot = <span class="hljs-number">0</span>; dot &#x3C; latitudeDotCount; dot += <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">const</span> dotGeometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">CircleGeometry</span>(<span class="hljs-variable constant_">DOT_SIZE</span>, <span class="hljs-number">5</span>);
      <span class="hljs-comment">// 점을 위한 파이와 세타 각도 계산</span>
      <span class="hljs-keyword">const</span> phi = (<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-variable constant_">LATITUDE_COUNT</span>) * lat;
      <span class="hljs-keyword">const</span> theta = ((<span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) / latitudeDotCount) * dot;

      ...

    }
  }
</code></pre>
<p>이로써 매우 만족스러운 점 배치가 됩니다:</p>
<p>저희는 구체에 점들이 표시되는 방법에 대해 다루었습니다. 그렇다면 더 복잡한 효과를 얻을 수는 없을까요?</p>
<h1>모양 마스킹</h1>
<p>더 복잡한 패턴으로 점을 표시하는 방법을 알아내려면 수학적인 두통으로 빠르게 빠질 수 있습니다. 그러나 위의 포장 배치 중 하나와 마스크 이미지를 결합하여 일부 특별한 효과를 얻을 수 있습니다.</p>
<p>이를 위해 먼저 HTML 캔버스 요소를 만들고 마스크 이미지를 그려야 합니다. 이 요소는 실제로 화면에 렌더링되지 않습니다. 이미지에서 픽셀 데이터를 추출하는 편리한 방법 뿐입니다. 이 일은 한 번만 해야하므로 미리 수행한 다음 추출된 이미지 데이터를 renderScene 함수로 전달하면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이미지 로더를 초기화합니다.</span>
<span class="hljs-keyword">const</span> imageLoader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">ImageLoader</span>();

<span class="hljs-comment">// 점이 표시되는 위치를 결정하는 이미지를 로드합니다. 이 작업이 완료되기 전에 구 cannot be initialised until this is complete.</span>
imageLoader.<span class="hljs-title function_">load</span>(<span class="hljs-variable constant_">MASK_IMAGE</span>, <span class="hljs-function">(<span class="hljs-params">image</span>) =></span> {
    <span class="hljs-comment">// HTML 캔버스를 생성하고 해당 캔버스의 컨텍스트를 가져와 이미지를 그립니다.</span>
    <span class="hljs-keyword">const</span> tempCanvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"canvas"</span>);

    tempCanvas.<span class="hljs-property">width</span> = image.<span class="hljs-property">width</span>;
    tempCanvas.<span class="hljs-property">height</span> = image.<span class="hljs-property">height</span>;

    <span class="hljs-keyword">const</span> ctx = tempCanvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">"2d"</span>);

    ctx.<span class="hljs-title function_">drawImage</span>(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);

    <span class="hljs-comment">// 캔버스 컨텍스트에서 이미지 데이터를 읽어옵니다.</span>
    <span class="hljs-keyword">const</span> imageData = ctx.<span class="hljs-title function_">getImageData</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, image.<span class="hljs-property">width</span>, image.<span class="hljs-property">height</span>);

    <span class="hljs-title function_">renderScene</span>(imageData);
});
</code></pre>
<p>이제 이미지 데이터를 사용할 수 있으므로 몇 가지 유틸리티 함수를 추가해야 합니다. 첫 번째 함수는 구의 한 점을 가져와 해당 점이 구에 매핑된 경우 mask 이미지에서의 UV 좌표를 반환합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 구의 한 점을 가져와 해당 점이 사각 텍스처 또는 이미지에서 UV 포인트로 변환하는 유틸리티 함수입니다.</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">spherePointToUV</span> = (<span class="hljs-params">dotCenter, sphereCenter</span>) => {
    <span class="hljs-comment">// 구의 중심에서 점의 중심 방향을 나타내는 새로운 벡터를 만듭니다.</span>
    <span class="hljs-keyword">const</span> newVector = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>();
    newVector.<span class="hljs-title function_">subVectors</span>(sphereCenter, dotCenter).<span class="hljs-title function_">normalize</span>();

    <span class="hljs-comment">// 점의 UV 좌표를 계산해서 벡터로 반환합니다.</span>
    <span class="hljs-keyword">const</span> uvX = <span class="hljs-number">1</span> - (<span class="hljs-number">0.5</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">atan2</span>(newVector.<span class="hljs-property">z</span>, newVector.<span class="hljs-property">x</span>) / (<span class="hljs-number">2</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>));
    <span class="hljs-keyword">const</span> uvY = <span class="hljs-number">0.5</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">asin</span>(newVector.<span class="hljs-property">y</span>) / <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector2</span>(uvX, uvY);
};
</code></pre>
<p>두 번째 함수는 주어진 UV 좌표에서 mask 이미지의 픽셀 데이터를 반환합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이미지에서 특정 지점의 데이터를 샘플링하는 유틸리티 함수입니다. imageData 객체가 필요합니다.</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">sampleImage</span> = (<span class="hljs-params">imageData, uv</span>) => {
  <span class="hljs-comment">// UV 좌표를 기반으로 점의 데이터를 계산하고 반환합니다.</span>
  <span class="hljs-keyword">const</span> point =
    <span class="hljs-number">4</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(uv.<span class="hljs-property">x</span> * imageData.<span class="hljs-property">width</span>) +
    <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(uv.<span class="hljs-property">y</span> * imageData.<span class="hljs-property">height</span>) * (<span class="hljs-number">4</span> * imageData.<span class="hljs-property">width</span>);

  <span class="hljs-keyword">return</span> imageData.<span class="hljs-property">data</span>.<span class="hljs-title function_">slice</span>(point, point + <span class="hljs-number">4</span>);
};
</code></pre>
<p>이제 마스킹 효과를 적용하는 데 필요한 모든 것을 갖추었습니다. 각 점의 위치를 계산한 후에 해당 점의 경계 구를 계산합니다. 이후에 이를 사용하여 dot의 중심점을 spherePointToUV 함수에 전달할 수 있습니다. 이후에는 sampleImage 함수를 사용하여 해당 지점의 특정 픽셀 데이터를 찾을 수 있습니다. 픽셀이 투명하지 않으면 도트를 포함하고, 투명하면 도트를 제외합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 도트 geometry를 위치로 이동합니다.</span>
dotGeometry.<span class="hljs-title function_">translate</span>(vector.<span class="hljs-property">x</span>, vector.<span class="hljs-property">y</span>, vector.<span class="hljs-property">z</span>);

<span class="hljs-comment">// 도트의 경계 구를 찾습니다.</span>
dotGeometry.<span class="hljs-title function_">computeBoundingSphere</span>();

<span class="hljs-comment">// 랜드 이미지에서 도트의 UV 위치를 찾습니다.</span>
<span class="hljs-keyword">const</span> uv = <span class="hljs-title function_">spherePointToUV</span>(
  dotGeometry.<span class="hljs-property">boundingSphere</span>.<span class="hljs-property">center</span>,
  <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Vector3</span>()
);

<span class="hljs-comment">// 주어진 UV 위치에서 랜드 이미지의 픽셀을 샘플링합니다.</span>
<span class="hljs-keyword">const</span> sampledPixel = <span class="hljs-title function_">sampleImage</span>(imageData, uv);

<span class="hljs-comment">// 픽셀에 색상 값이 포함되어 있으면 (다시 말해, 투명하지 않으면),</span>
<span class="hljs-comment">// 도트를 생성합니다. 그렇지 않으면 건너뜁니다.</span>
<span class="hljs-keyword">if</span> (sampledPixel[<span class="hljs-number">3</span>]) {
  <span class="hljs-comment">// 위치 지정 geometry를 배열에 추가합니다.</span>
  dotGeometries.<span class="hljs-title function_">push</span>(dotGeometry);
}
</code></pre>
<p>실제로는 투명 배경을 가진 png 이미지를 마스크로 지정할 수 있습니다. 도트는 이미지의 해당 점이 투명하지 않은 경우에만 구로 렌더링됩니다. 간단한 다이아몬드 패턴을 가진 이미지로부터 이 멋진 결과를 얻을 수 있습니다:</p>
<p>더 복잡한 마스크 이미지를 사용하여 이 지구 효과와 같은 모양을 얻을 수 있어요:</p>
<p>또한 텍스트를 렌더링할 수도 있어요:</p>
<h1>여기까지!</h1>
<p>이러한 구 형상 기법들을 WebGL 쇼피스의 기초로 여러 곳에서 사용했어요. 이를 통해 여러분도 같은 작업을 해볼 수 있기를 바랄게요. 만약 이 기사를 즐겨보았거나 어떤 면에서 도움이 되었다면 꼭 알려주세요! 제 웹사이트는 여기 있어요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"경이로운 WebGL 점 구체 만드는 방법","description":"","date":"2024-06-22 13:43","slug":"2024-06-22-StunningWebGLDotSpheres","content":"\n\n\n![Image](/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png)\n\n최근에 Stripe와 GitHub에서 WebGL 지구 모형이 눈에 띄게 사용되면서 많은 관심을 받았습니다. 둘 다 자사 홈페이지에서 그것들을 주목적으로 활용했고, 이에 관한 블로그 포스트를 작성했습니다(Stripe의 포스트는 [여기](Stripe's link)에서 확인할 수 있고, GitHub의는 [여기](GitHub's link)에서 확인할 수 있습니다).\n\n두 지구 모형은 대부분 점들로 이루어져 있는데, 이것이 저에게 구체 표면에 점들을 분산시키는 다양한 방법에 대해 생각해보게 했습니다. 구 형태에 대한 점 배치는 수학자들이 적극적으로 고민하는 복잡한 퍼즐로, 이 기사를 위해서 제가 몇 가지 기본적인 방법을 소개하고 WebGL에서 어떻게 구현할 수 있는지에 대해 제한했습니다.\n\n# 씬 설정하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 진행하기 전에, 구를 만들 WebGL 씬을 구축하는 것이 필요합니다. WebGL API와 상호 작용하기 위한 주요 프레임워크로 Three.js를 사용하고 있어요. 이 글의 코드 스니펫은 간결하고 관련성이 높도록 유지하고 있으니, 전체 코드를 확인하려면 포함된 샌드박스를 살펴보세요.\n\n씬을 생성한 후, 모든 점에 대한 geometries를 포함할 dotGeometries 배열을 정의합니다. 그런 다음, 씬 내의 공간에 빈 벡터, 즉 3D 포인트를 생성하며, 해당 위치는 각각의 점을 만들 때마다 재할당됩니다.\n\n```js\n// 씬을 설정합니다.\nconst scene = new THREE.Scene();\n\n// 모든 점의 geometries를 보관할 배열을 정의합니다.\nconst dotGeometries = [];\n\n// 점에서 사용할 빈 벡터를 생성합니다.\nconst vector = new THREE.Vector3();\n\n// 이곳에서 점을 생성하고 위치를 지정합니다!\n```\n\n점을 생성하고 그 geometries를 dotGeometries 배열에 넣은 후, mergeBufferGeometries 유틸리티를 사용하여 이를 하나의 geometry로 병합할 수 있습니다. 그런 다음, dot geometries에서 mesh를 생성하고, 이에 재질을 부여하고 씬에 추가하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 모든 점 지오메트리를 하나의 버퍼 지오메트리로 병합합니다.\nconst mergedDotGeometries = BufferGeometryUtils.mergeBufferGeometries(\n  dotGeometries\n);\n\n// 점을 위한 재질을 정의합니다.\nconst dotMaterial = new THREE.MeshBasicMaterial({\n  color: DOT_COLOR,\n  side: THREE.DoubleSide\n});\n\n// 점 지오메트리와 재질에서 점 메시를 생성합니다.\nconst dotMesh = new THREE.Mesh(mergedDotGeometries, dotMaterial);\n\n// 점 메시를 씬에 추가합니다.\nscene.add(dotMesh);\n```\n\n이제 어떻게 점을 생성하고 배치할지 살펴봅시다.\n\n# 기본적인 접근 방법\n\n구에 점을 추가하는 가장 쉬운 방법은 단순히 구가 갖도록 원하는 위도 선 및 경도 선의 수를 정의한 다음 해당 선들에 따라 점을 배치하는 것입니다. 여기에는 몇 가지 중요한 사항이 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 각 점에 대해 phi와 theta 각도를 정의합니다. 이러한 각도는 구 좌표계의 일부로, 점이 3D 공간에서 원점과의 관계를 정확히 나타내는 시스템입니다 (우리의 경우에는 구의 중심).\n\n두 번째로, phi와 theta는 모두 라디안으로 측정됩니다. 핵심은 180º에 π 라디안이 있다는 것을 기억하는 것입니다. 여기서 phi를 찾기 위해선 단순히 π를 위도 주선 수로 나누면 됩니다. 그러나 theta를 찾기 위해서는 경도 주선 수로 2 * π를 나누어야 합니다. 왜냐하면 경도 주선이 구의 전체 360º를 계속 감싸도록 하기 때문입니다.\n\n```js\n// 위도를 반복합니다.\nfor (let lat = 0; lat \u003c LATITUDE_COUNT; lat += 1) {\n  // 경도를 반복합니다.\n  for (let lng = 0; lng \u003c LONGITUDE_COUNT; lng += 1) {\n    // 점에 대한 geometry를 생성합니다.\n    const dotGeometry = new THREE.CircleGeometry(DOT_SIZE, 5);\n    // 점을 위한 phi와 theta 각도를 정의합니다.\n    const phi = (Math.PI / LATITUDE_COUNT) * lat;\n    const theta = ((2 * Math.PI) / LONGITUDE_COUNT) * lng;\n\n    // 구 반지름, phi 및 theta에서 생성된 구 좌표를 사용하여 벡터를 설정합니다.\n    vector.setFromSphericalCoords(SPHERE_RADIUS, phi, theta);\n\n    // 점이 올바른 방향을 향하도록 합니다.\n    dotGeometry.lookAt(vector);\n\n    // 점 geometry를 올바른 위치로 이동합니다.\n    dotGeometry.translate(vector.x, vector.y, vector.z);\n\n    // 위치 지정 geometry를 배열에 추가합니다.\n    dotGeometries.push(dotGeometry);\n  }\n}\n```\n\n이렇게 해서 다음 결과를 얻을 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 구를 회전시키면, 맨 위와 맨 아래의 고리가 가운데보다 훨씬 더 밀집되어 있는 것을 알게 될 거에요. 이는 각 위도선에 있는 점들의 개수를 다양하게 하지 않았기 때문입니다. 여기서 구 패킹이 필요한 때입니다.\n\n# 실로택시스 방법론\n\n해바라기 꽃의 머리나 솔방울의 바닥을 본 적이 있다면, 이상하고 독특한 패턴을 알아차릴 수 있을 겁니다. 이 패턴은 피보나치 수열을 기반으로 하는 배열에 의해 만들어져, 실로택시스로 알려져 있습니다. 이를 이용하여 점들을 구의 표면 위에 더 균일하게 위치시켜 보이도록 할 수 있습니다.\n\n이번에는 위도와 경도 선의 개수를 정의하는 대신, 단순히 구에 나타나길 원하는 총 점의 수를 정의합니다. 위도 선을 가로지르는 대신, 점들은 구의 한 극에서 다른 극까지 단일하고 연속적인 나선 형태로 렌더링될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 점의 개수만큼 반복합니다.\nfor (let dot = 0; dot \u003c DOT_COUNT; dot += 1) {\n  // 점을 위한 geometry를 생성합니다.\n  const dotGeometry = new THREE.CircleGeometry(DOT_SIZE, 5);\n\n  // 각 점의 구면 좌표를 계산하여 피로태시스 패턴으로 만듭니다.\n  const phi = Math.acos(-1 + (2 * dot) / DOT_COUNT);\n  const theta = Math.sqrt(DOT_COUNT * Math.PI) * phi;\n\n  // 구의 반지름, phi 및 theta에서 생성된 구면 좌표를 사용하여 벡터를 설정합니다.\n  vector.setFromSphericalCoords(SPHERE_RADIUS, phi, theta);\n\n  ...\n\n}\n```\n\n위와 같은 결과가 나타납니다.\n\n이 방법은 훨씬 더 만족스럽습니다. 그러나 가능한 한 점들을 골고루 배치하고 싶지만 자유롭게 위도 선 수를 정의하고 싶다면 어떻게 해야 할까요?\n\n# 선형 접근법\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이번에는 필요한 위도선 수를 정의하되, 점의 수도 위치한 위도선의 둘레에 기반하여 조절됩니다. 간격에 대한 더 큰 제어를 위해 점 밀도 매개변수도 정의할 것입니다.\n\n여기서 까다로운 부분은 각 위도선의 반지름을 계산하는 것입니다. 일단 그것을 구했다면, 얼마나 많은 점을 표시해야 하는지 간단히 알아내고, 각각에 대해 첫 번째 방법과 유사한 방식으로 파이와 세타를 찾는 것도 상대적으로 간단합니다.\n\n```js\n// 위도 선을 가로지르는 루프\n  for (let lat = 0; lat \u003c LATITUDE_COUNT; lat += 1) {\n    // 위도선의 반지름 계산\n    const radius =\n      Math.cos((-90 + (180 / LATITUDE_COUNT) * lat) * (Math.PI / 180)) *\n      SPHERE_RADIUS;\n    // 위도선의 둘레 계산\n    const latitudeCircumference = radius * Math.PI * 2 * 2;\n    // 해당 위도선에 필요한 점의 수 계산\n    const latitudeDotCount = Math.ceil(latitudeCircumference * DOT_DENSITY);\n\n    // 해당 위도선의 점 수에 대해 루프 수행\n    for (let dot = 0; dot \u003c latitudeDotCount; dot += 1) {\n      const dotGeometry = new THREE.CircleGeometry(DOT_SIZE, 5);\n      // 점을 위한 파이와 세타 각도 계산\n      const phi = (Math.PI / LATITUDE_COUNT) * lat;\n      const theta = ((2 * Math.PI) / latitudeDotCount) * dot;\n\n      ...\n\n    }\n  }\n```\n\n이로써 매우 만족스러운 점 배치가 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 구체에 점들이 표시되는 방법에 대해 다루었습니다. 그렇다면 더 복잡한 효과를 얻을 수는 없을까요?\n\n# 모양 마스킹\n\n더 복잡한 패턴으로 점을 표시하는 방법을 알아내려면 수학적인 두통으로 빠르게 빠질 수 있습니다. 그러나 위의 포장 배치 중 하나와 마스크 이미지를 결합하여 일부 특별한 효과를 얻을 수 있습니다.\n\n이를 위해 먼저 HTML 캔버스 요소를 만들고 마스크 이미지를 그려야 합니다. 이 요소는 실제로 화면에 렌더링되지 않습니다. 이미지에서 픽셀 데이터를 추출하는 편리한 방법 뿐입니다. 이 일은 한 번만 해야하므로 미리 수행한 다음 추출된 이미지 데이터를 renderScene 함수로 전달하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 이미지 로더를 초기화합니다.\nconst imageLoader = new THREE.ImageLoader();\n\n// 점이 표시되는 위치를 결정하는 이미지를 로드합니다. 이 작업이 완료되기 전에 구 cannot be initialised until this is complete.\nimageLoader.load(MASK_IMAGE, (image) =\u003e {\n    // HTML 캔버스를 생성하고 해당 캔버스의 컨텍스트를 가져와 이미지를 그립니다.\n    const tempCanvas = document.createElement(\"canvas\");\n\n    tempCanvas.width = image.width;\n    tempCanvas.height = image.height;\n\n    const ctx = tempCanvas.getContext(\"2d\");\n\n    ctx.drawImage(image, 0, 0);\n\n    // 캔버스 컨텍스트에서 이미지 데이터를 읽어옵니다.\n    const imageData = ctx.getImageData(0, 0, image.width, image.height);\n\n    renderScene(imageData);\n});\n```\n\n이제 이미지 데이터를 사용할 수 있으므로 몇 가지 유틸리티 함수를 추가해야 합니다. 첫 번째 함수는 구의 한 점을 가져와 해당 점이 구에 매핑된 경우 mask 이미지에서의 UV 좌표를 반환합니다.\n\n```js\n// 구의 한 점을 가져와 해당 점이 사각 텍스처 또는 이미지에서 UV 포인트로 변환하는 유틸리티 함수입니다.\nconst spherePointToUV = (dotCenter, sphereCenter) =\u003e {\n    // 구의 중심에서 점의 중심 방향을 나타내는 새로운 벡터를 만듭니다.\n    const newVector = new THREE.Vector3();\n    newVector.subVectors(sphereCenter, dotCenter).normalize();\n\n    // 점의 UV 좌표를 계산해서 벡터로 반환합니다.\n    const uvX = 1 - (0.5 + Math.atan2(newVector.z, newVector.x) / (2 * Math.PI));\n    const uvY = 0.5 + Math.asin(newVector.y) / Math.PI;\n\n    return new THREE.Vector2(uvX, uvY);\n};\n```\n\n두 번째 함수는 주어진 UV 좌표에서 mask 이미지의 픽셀 데이터를 반환합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 이미지에서 특정 지점의 데이터를 샘플링하는 유틸리티 함수입니다. imageData 객체가 필요합니다.\nconst sampleImage = (imageData, uv) =\u003e {\n  // UV 좌표를 기반으로 점의 데이터를 계산하고 반환합니다.\n  const point =\n    4 * Math.floor(uv.x * imageData.width) +\n    Math.floor(uv.y * imageData.height) * (4 * imageData.width);\n\n  return imageData.data.slice(point, point + 4);\n};\n```\n\n이제 마스킹 효과를 적용하는 데 필요한 모든 것을 갖추었습니다. 각 점의 위치를 계산한 후에 해당 점의 경계 구를 계산합니다. 이후에 이를 사용하여 dot의 중심점을 spherePointToUV 함수에 전달할 수 있습니다. 이후에는 sampleImage 함수를 사용하여 해당 지점의 특정 픽셀 데이터를 찾을 수 있습니다. 픽셀이 투명하지 않으면 도트를 포함하고, 투명하면 도트를 제외합니다.\n\n```js\n// 도트 geometry를 위치로 이동합니다.\ndotGeometry.translate(vector.x, vector.y, vector.z);\n\n// 도트의 경계 구를 찾습니다.\ndotGeometry.computeBoundingSphere();\n\n// 랜드 이미지에서 도트의 UV 위치를 찾습니다.\nconst uv = spherePointToUV(\n  dotGeometry.boundingSphere.center,\n  new THREE.Vector3()\n);\n\n// 주어진 UV 위치에서 랜드 이미지의 픽셀을 샘플링합니다.\nconst sampledPixel = sampleImage(imageData, uv);\n\n// 픽셀에 색상 값이 포함되어 있으면 (다시 말해, 투명하지 않으면),\n// 도트를 생성합니다. 그렇지 않으면 건너뜁니다.\nif (sampledPixel[3]) {\n  // 위치 지정 geometry를 배열에 추가합니다.\n  dotGeometries.push(dotGeometry);\n}\n```\n\n실제로는 투명 배경을 가진 png 이미지를 마스크로 지정할 수 있습니다. 도트는 이미지의 해당 점이 투명하지 않은 경우에만 구로 렌더링됩니다. 간단한 다이아몬드 패턴을 가진 이미지로부터 이 멋진 결과를 얻을 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 복잡한 마스크 이미지를 사용하여 이 지구 효과와 같은 모양을 얻을 수 있어요:\n\n또한 텍스트를 렌더링할 수도 있어요:\n\n# 여기까지!\n\n이러한 구 형상 기법들을 WebGL 쇼피스의 기초로 여러 곳에서 사용했어요. 이를 통해 여러분도 같은 작업을 해볼 수 있기를 바랄게요. 만약 이 기사를 즐겨보았거나 어떤 면에서 도움이 되었다면 꼭 알려주세요! 제 웹사이트는 여기 있어요.","ogImage":{"url":"/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png"},"coverImage":"/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-StunningWebGLDotSpheres_0.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e최근에 Stripe와 GitHub에서 WebGL 지구 모형이 눈에 띄게 사용되면서 많은 관심을 받았습니다. 둘 다 자사 홈페이지에서 그것들을 주목적으로 활용했고, 이에 관한 블로그 포스트를 작성했습니다(Stripe의 포스트는 [여기](Stripe's link)에서 확인할 수 있고, GitHub의는 [여기](GitHub's link)에서 확인할 수 있습니다).\u003c/p\u003e\n\u003cp\u003e두 지구 모형은 대부분 점들로 이루어져 있는데, 이것이 저에게 구체 표면에 점들을 분산시키는 다양한 방법에 대해 생각해보게 했습니다. 구 형태에 대한 점 배치는 수학자들이 적극적으로 고민하는 복잡한 퍼즐로, 이 기사를 위해서 제가 몇 가지 기본적인 방법을 소개하고 WebGL에서 어떻게 구현할 수 있는지에 대해 제한했습니다.\u003c/p\u003e\n\u003ch1\u003e씬 설정하기\u003c/h1\u003e\n\u003cp\u003e현재 진행하기 전에, 구를 만들 WebGL 씬을 구축하는 것이 필요합니다. WebGL API와 상호 작용하기 위한 주요 프레임워크로 Three.js를 사용하고 있어요. 이 글의 코드 스니펫은 간결하고 관련성이 높도록 유지하고 있으니, 전체 코드를 확인하려면 포함된 샌드박스를 살펴보세요.\u003c/p\u003e\n\u003cp\u003e씬을 생성한 후, 모든 점에 대한 geometries를 포함할 dotGeometries 배열을 정의합니다. 그런 다음, 씬 내의 공간에 빈 벡터, 즉 3D 포인트를 생성하며, 해당 위치는 각각의 점을 만들 때마다 재할당됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 씬을 설정합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e scene = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTHREE\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eScene\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 모든 점의 geometries를 보관할 배열을 정의합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dotGeometries = [];\n\n\u003cspan class=\"hljs-comment\"\u003e// 점에서 사용할 빈 벡터를 생성합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e vector = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTHREE\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eVector3\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 이곳에서 점을 생성하고 위치를 지정합니다!\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e점을 생성하고 그 geometries를 dotGeometries 배열에 넣은 후, mergeBufferGeometries 유틸리티를 사용하여 이를 하나의 geometry로 병합할 수 있습니다. 그런 다음, dot geometries에서 mesh를 생성하고, 이에 재질을 부여하고 씬에 추가하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 모든 점 지오메트리를 하나의 버퍼 지오메트리로 병합합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mergedDotGeometries = \u003cspan class=\"hljs-title class_\"\u003eBufferGeometryUtils\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003emergeBufferGeometries\u003c/span\u003e(\n  dotGeometries\n);\n\n\u003cspan class=\"hljs-comment\"\u003e// 점을 위한 재질을 정의합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dotMaterial = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTHREE\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eMeshBasicMaterial\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003ecolor\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eDOT_COLOR\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eside\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eTHREE\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDoubleSide\u003c/span\u003e\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 점 지오메트리와 재질에서 점 메시를 생성합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dotMesh = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTHREE\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eMesh\u003c/span\u003e(mergedDotGeometries, dotMaterial);\n\n\u003cspan class=\"hljs-comment\"\u003e// 점 메시를 씬에 추가합니다.\u003c/span\u003e\nscene.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(dotMesh);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 어떻게 점을 생성하고 배치할지 살펴봅시다.\u003c/p\u003e\n\u003ch1\u003e기본적인 접근 방법\u003c/h1\u003e\n\u003cp\u003e구에 점을 추가하는 가장 쉬운 방법은 단순히 구가 갖도록 원하는 위도 선 및 경도 선의 수를 정의한 다음 해당 선들에 따라 점을 배치하는 것입니다. 여기에는 몇 가지 중요한 사항이 있습니다.\u003c/p\u003e\n\u003cp\u003e먼저, 각 점에 대해 phi와 theta 각도를 정의합니다. 이러한 각도는 구 좌표계의 일부로, 점이 3D 공간에서 원점과의 관계를 정확히 나타내는 시스템입니다 (우리의 경우에는 구의 중심).\u003c/p\u003e\n\u003cp\u003e두 번째로, phi와 theta는 모두 라디안으로 측정됩니다. 핵심은 180º에 π 라디안이 있다는 것을 기억하는 것입니다. 여기서 phi를 찾기 위해선 단순히 π를 위도 주선 수로 나누면 됩니다. 그러나 theta를 찾기 위해서는 경도 주선 수로 2 * π를 나누어야 합니다. 왜냐하면 경도 주선이 구의 전체 360º를 계속 감싸도록 하기 때문입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 위도를 반복합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e lat = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; lat \u0026#x3C; \u003cspan class=\"hljs-variable constant_\"\u003eLATITUDE_COUNT\u003c/span\u003e; lat += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 경도를 반복합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e lng = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; lng \u0026#x3C; \u003cspan class=\"hljs-variable constant_\"\u003eLONGITUDE_COUNT\u003c/span\u003e; lng += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 점에 대한 geometry를 생성합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dotGeometry = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTHREE\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eCircleGeometry\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eDOT_SIZE\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e);\n    \u003cspan class=\"hljs-comment\"\u003e// 점을 위한 phi와 theta 각도를 정의합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e phi = (\u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePI\u003c/span\u003e / \u003cspan class=\"hljs-variable constant_\"\u003eLATITUDE_COUNT\u003c/span\u003e) * lat;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e theta = ((\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePI\u003c/span\u003e) / \u003cspan class=\"hljs-variable constant_\"\u003eLONGITUDE_COUNT\u003c/span\u003e) * lng;\n\n    \u003cspan class=\"hljs-comment\"\u003e// 구 반지름, phi 및 theta에서 생성된 구 좌표를 사용하여 벡터를 설정합니다.\u003c/span\u003e\n    vector.\u003cspan class=\"hljs-title function_\"\u003esetFromSphericalCoords\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eSPHERE_RADIUS\u003c/span\u003e, phi, theta);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 점이 올바른 방향을 향하도록 합니다.\u003c/span\u003e\n    dotGeometry.\u003cspan class=\"hljs-title function_\"\u003elookAt\u003c/span\u003e(vector);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 점 geometry를 올바른 위치로 이동합니다.\u003c/span\u003e\n    dotGeometry.\u003cspan class=\"hljs-title function_\"\u003etranslate\u003c/span\u003e(vector.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e, vector.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e, vector.\u003cspan class=\"hljs-property\"\u003ez\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 위치 지정 geometry를 배열에 추가합니다.\u003c/span\u003e\n    dotGeometries.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(dotGeometry);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 해서 다음 결과를 얻을 수 있습니다:\u003c/p\u003e\n\u003cp\u003e만약 구를 회전시키면, 맨 위와 맨 아래의 고리가 가운데보다 훨씬 더 밀집되어 있는 것을 알게 될 거에요. 이는 각 위도선에 있는 점들의 개수를 다양하게 하지 않았기 때문입니다. 여기서 구 패킹이 필요한 때입니다.\u003c/p\u003e\n\u003ch1\u003e실로택시스 방법론\u003c/h1\u003e\n\u003cp\u003e해바라기 꽃의 머리나 솔방울의 바닥을 본 적이 있다면, 이상하고 독특한 패턴을 알아차릴 수 있을 겁니다. 이 패턴은 피보나치 수열을 기반으로 하는 배열에 의해 만들어져, 실로택시스로 알려져 있습니다. 이를 이용하여 점들을 구의 표면 위에 더 균일하게 위치시켜 보이도록 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이번에는 위도와 경도 선의 개수를 정의하는 대신, 단순히 구에 나타나길 원하는 총 점의 수를 정의합니다. 위도 선을 가로지르는 대신, 점들은 구의 한 극에서 다른 극까지 단일하고 연속적인 나선 형태로 렌더링될 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 점의 개수만큼 반복합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e dot = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; dot \u0026#x3C; \u003cspan class=\"hljs-variable constant_\"\u003eDOT_COUNT\u003c/span\u003e; dot += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 점을 위한 geometry를 생성합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dotGeometry = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTHREE\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eCircleGeometry\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eDOT_SIZE\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 각 점의 구면 좌표를 계산하여 피로태시스 패턴으로 만듭니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e phi = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eacos\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e + (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * dot) / \u003cspan class=\"hljs-variable constant_\"\u003eDOT_COUNT\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e theta = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eDOT_COUNT\u003c/span\u003e * \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePI\u003c/span\u003e) * phi;\n\n  \u003cspan class=\"hljs-comment\"\u003e// 구의 반지름, phi 및 theta에서 생성된 구면 좌표를 사용하여 벡터를 설정합니다.\u003c/span\u003e\n  vector.\u003cspan class=\"hljs-title function_\"\u003esetFromSphericalCoords\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eSPHERE_RADIUS\u003c/span\u003e, phi, theta);\n\n  ...\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같은 결과가 나타납니다.\u003c/p\u003e\n\u003cp\u003e이 방법은 훨씬 더 만족스럽습니다. 그러나 가능한 한 점들을 골고루 배치하고 싶지만 자유롭게 위도 선 수를 정의하고 싶다면 어떻게 해야 할까요?\u003c/p\u003e\n\u003ch1\u003e선형 접근법\u003c/h1\u003e\n\u003cp\u003e이번에는 필요한 위도선 수를 정의하되, 점의 수도 위치한 위도선의 둘레에 기반하여 조절됩니다. 간격에 대한 더 큰 제어를 위해 점 밀도 매개변수도 정의할 것입니다.\u003c/p\u003e\n\u003cp\u003e여기서 까다로운 부분은 각 위도선의 반지름을 계산하는 것입니다. 일단 그것을 구했다면, 얼마나 많은 점을 표시해야 하는지 간단히 알아내고, 각각에 대해 첫 번째 방법과 유사한 방식으로 파이와 세타를 찾는 것도 상대적으로 간단합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 위도 선을 가로지르는 루프\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e lat = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; lat \u0026#x3C; \u003cspan class=\"hljs-variable constant_\"\u003eLATITUDE_COUNT\u003c/span\u003e; lat += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 위도선의 반지름 계산\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e radius =\n      \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecos\u003c/span\u003e((-\u003cspan class=\"hljs-number\"\u003e90\u003c/span\u003e + (\u003cspan class=\"hljs-number\"\u003e180\u003c/span\u003e / \u003cspan class=\"hljs-variable constant_\"\u003eLATITUDE_COUNT\u003c/span\u003e) * lat) * (\u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePI\u003c/span\u003e / \u003cspan class=\"hljs-number\"\u003e180\u003c/span\u003e)) *\n      \u003cspan class=\"hljs-variable constant_\"\u003eSPHERE_RADIUS\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// 위도선의 둘레 계산\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e latitudeCircumference = radius * \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePI\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// 해당 위도선에 필요한 점의 수 계산\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e latitudeDotCount = \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eceil\u003c/span\u003e(latitudeCircumference * \u003cspan class=\"hljs-variable constant_\"\u003eDOT_DENSITY\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 해당 위도선의 점 수에 대해 루프 수행\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e dot = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; dot \u0026#x3C; latitudeDotCount; dot += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e dotGeometry = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTHREE\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eCircleGeometry\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eDOT_SIZE\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e);\n      \u003cspan class=\"hljs-comment\"\u003e// 점을 위한 파이와 세타 각도 계산\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e phi = (\u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePI\u003c/span\u003e / \u003cspan class=\"hljs-variable constant_\"\u003eLATITUDE_COUNT\u003c/span\u003e) * lat;\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e theta = ((\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePI\u003c/span\u003e) / latitudeDotCount) * dot;\n\n      ...\n\n    }\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이로써 매우 만족스러운 점 배치가 됩니다:\u003c/p\u003e\n\u003cp\u003e저희는 구체에 점들이 표시되는 방법에 대해 다루었습니다. 그렇다면 더 복잡한 효과를 얻을 수는 없을까요?\u003c/p\u003e\n\u003ch1\u003e모양 마스킹\u003c/h1\u003e\n\u003cp\u003e더 복잡한 패턴으로 점을 표시하는 방법을 알아내려면 수학적인 두통으로 빠르게 빠질 수 있습니다. 그러나 위의 포장 배치 중 하나와 마스크 이미지를 결합하여 일부 특별한 효과를 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이를 위해 먼저 HTML 캔버스 요소를 만들고 마스크 이미지를 그려야 합니다. 이 요소는 실제로 화면에 렌더링되지 않습니다. 이미지에서 픽셀 데이터를 추출하는 편리한 방법 뿐입니다. 이 일은 한 번만 해야하므로 미리 수행한 다음 추출된 이미지 데이터를 renderScene 함수로 전달하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이미지 로더를 초기화합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e imageLoader = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTHREE\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eImageLoader\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 점이 표시되는 위치를 결정하는 이미지를 로드합니다. 이 작업이 완료되기 전에 구 cannot be initialised until this is complete.\u003c/span\u003e\nimageLoader.\u003cspan class=\"hljs-title function_\"\u003eload\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eMASK_IMAGE\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eimage\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// HTML 캔버스를 생성하고 해당 캔버스의 컨텍스트를 가져와 이미지를 그립니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tempCanvas = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"canvas\"\u003c/span\u003e);\n\n    tempCanvas.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e = image.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e;\n    tempCanvas.\u003cspan class=\"hljs-property\"\u003eheight\u003c/span\u003e = image.\u003cspan class=\"hljs-property\"\u003eheight\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ctx = tempCanvas.\u003cspan class=\"hljs-title function_\"\u003egetContext\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"2d\"\u003c/span\u003e);\n\n    ctx.\u003cspan class=\"hljs-title function_\"\u003edrawImage\u003c/span\u003e(image, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 캔버스 컨텍스트에서 이미지 데이터를 읽어옵니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e imageData = ctx.\u003cspan class=\"hljs-title function_\"\u003egetImageData\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, image.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e, image.\u003cspan class=\"hljs-property\"\u003eheight\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-title function_\"\u003erenderScene\u003c/span\u003e(imageData);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 이미지 데이터를 사용할 수 있으므로 몇 가지 유틸리티 함수를 추가해야 합니다. 첫 번째 함수는 구의 한 점을 가져와 해당 점이 구에 매핑된 경우 mask 이미지에서의 UV 좌표를 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 구의 한 점을 가져와 해당 점이 사각 텍스처 또는 이미지에서 UV 포인트로 변환하는 유틸리티 함수입니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003espherePointToUV\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003edotCenter, sphereCenter\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 구의 중심에서 점의 중심 방향을 나타내는 새로운 벡터를 만듭니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e newVector = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTHREE\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eVector3\u003c/span\u003e();\n    newVector.\u003cspan class=\"hljs-title function_\"\u003esubVectors\u003c/span\u003e(sphereCenter, dotCenter).\u003cspan class=\"hljs-title function_\"\u003enormalize\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-comment\"\u003e// 점의 UV 좌표를 계산해서 벡터로 반환합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e uvX = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - (\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e + \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eatan2\u003c/span\u003e(newVector.\u003cspan class=\"hljs-property\"\u003ez\u003c/span\u003e, newVector.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e) / (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e * \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePI\u003c/span\u003e));\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e uvY = \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e + \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003easin\u003c/span\u003e(newVector.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e) / \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ePI\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTHREE\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eVector2\u003c/span\u003e(uvX, uvY);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 번째 함수는 주어진 UV 좌표에서 mask 이미지의 픽셀 데이터를 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이미지에서 특정 지점의 데이터를 샘플링하는 유틸리티 함수입니다. imageData 객체가 필요합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esampleImage\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eimageData, uv\u003c/span\u003e) =\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// UV 좌표를 기반으로 점의 데이터를 계산하고 반환합니다.\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e point =\n    \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e * \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efloor\u003c/span\u003e(uv.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e * imageData.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e) +\n    \u003cspan class=\"hljs-title class_\"\u003eMath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efloor\u003c/span\u003e(uv.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e * imageData.\u003cspan class=\"hljs-property\"\u003eheight\u003c/span\u003e) * (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e * imageData.\u003cspan class=\"hljs-property\"\u003ewidth\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e imageData.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eslice\u003c/span\u003e(point, point + \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 마스킹 효과를 적용하는 데 필요한 모든 것을 갖추었습니다. 각 점의 위치를 계산한 후에 해당 점의 경계 구를 계산합니다. 이후에 이를 사용하여 dot의 중심점을 spherePointToUV 함수에 전달할 수 있습니다. 이후에는 sampleImage 함수를 사용하여 해당 지점의 특정 픽셀 데이터를 찾을 수 있습니다. 픽셀이 투명하지 않으면 도트를 포함하고, 투명하면 도트를 제외합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 도트 geometry를 위치로 이동합니다.\u003c/span\u003e\ndotGeometry.\u003cspan class=\"hljs-title function_\"\u003etranslate\u003c/span\u003e(vector.\u003cspan class=\"hljs-property\"\u003ex\u003c/span\u003e, vector.\u003cspan class=\"hljs-property\"\u003ey\u003c/span\u003e, vector.\u003cspan class=\"hljs-property\"\u003ez\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 도트의 경계 구를 찾습니다.\u003c/span\u003e\ndotGeometry.\u003cspan class=\"hljs-title function_\"\u003ecomputeBoundingSphere\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 랜드 이미지에서 도트의 UV 위치를 찾습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e uv = \u003cspan class=\"hljs-title function_\"\u003espherePointToUV\u003c/span\u003e(\n  dotGeometry.\u003cspan class=\"hljs-property\"\u003eboundingSphere\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecenter\u003c/span\u003e,\n  \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTHREE\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eVector3\u003c/span\u003e()\n);\n\n\u003cspan class=\"hljs-comment\"\u003e// 주어진 UV 위치에서 랜드 이미지의 픽셀을 샘플링합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e sampledPixel = \u003cspan class=\"hljs-title function_\"\u003esampleImage\u003c/span\u003e(imageData, uv);\n\n\u003cspan class=\"hljs-comment\"\u003e// 픽셀에 색상 값이 포함되어 있으면 (다시 말해, 투명하지 않으면),\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 도트를 생성합니다. 그렇지 않으면 건너뜁니다.\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (sampledPixel[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]) {\n  \u003cspan class=\"hljs-comment\"\u003e// 위치 지정 geometry를 배열에 추가합니다.\u003c/span\u003e\n  dotGeometries.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(dotGeometry);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e실제로는 투명 배경을 가진 png 이미지를 마스크로 지정할 수 있습니다. 도트는 이미지의 해당 점이 투명하지 않은 경우에만 구로 렌더링됩니다. 간단한 다이아몬드 패턴을 가진 이미지로부터 이 멋진 결과를 얻을 수 있습니다:\u003c/p\u003e\n\u003cp\u003e더 복잡한 마스크 이미지를 사용하여 이 지구 효과와 같은 모양을 얻을 수 있어요:\u003c/p\u003e\n\u003cp\u003e또한 텍스트를 렌더링할 수도 있어요:\u003c/p\u003e\n\u003ch1\u003e여기까지!\u003c/h1\u003e\n\u003cp\u003e이러한 구 형상 기법들을 WebGL 쇼피스의 기초로 여러 곳에서 사용했어요. 이를 통해 여러분도 같은 작업을 해볼 수 있기를 바랄게요. 만약 이 기사를 즐겨보았거나 어떤 면에서 도움이 되었다면 꼭 알려주세요! 제 웹사이트는 여기 있어요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-StunningWebGLDotSpheres"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>