<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>LWC 인터뷰 질문 시리즈 1 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-LWCInterviewQuestionsSeries1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="LWC 인터뷰 질문 시리즈 1 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="LWC 인터뷰 질문 시리즈 1 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-LWCInterviewQuestionsSeries1" data-gatsby-head="true"/><meta name="twitter:title" content="LWC 인터뷰 질문 시리즈 1 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 07:28" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">LWC 인터뷰 질문 시리즈 1</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="LWC 인터뷰 질문 시리즈 1" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-LWCInterviewQuestionsSeries1&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>(2024)</h2>
<p><img src="/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png" alt="LWC Interview Questions"></p>
<p>라이트닝 웹 컴포넌트(LWC)는 Salesforce 개발 분야에서 동적이고 반응적인 사용자 인터페이스를 개발하는 강력한 도구입니다. 성능을 향상시키고 개발 프로세스를 더 효율적으로 만들어 주는 능력 덕분에 LWC는 현대 Salesforce 플랫폼 앱의 기본 구성 요소가 되었습니다. 자격 있는 LWC 개발자를 찾는 것은 이 기술을 완벽히 활용할 수 있는 유능한 팀을 구성하기 위해 매우 중요합니다.</p>
<p>우리는 이러한 노력을 돕기 위해 개념적 이해와 현실 시나리오에 대한 LWC 인터뷰 문제를 철저하게 수집했습니다. 이러한 질문의 목적은 후보자의 문제 해결 능력, LWC 개발에 대한 전문 지식, 그리고 Salesforce 개발의 최선의 실천 방법의 적용을 평가하는 데 도움을 주는 것입니다. 이제 시작해 보겠습니다!</p>
<h2>주의 !</h2>
<p>LWC 인터뷰 준비는 압도적인 과제일 수 있습니다. LWC 개념, 최고의 실천 방법 및 실무 경험을 철저히 이해해야 합니다. 여러분의 여정을 돕기 위해 LWC 관련 다양한 주제를 다루는 면접 질문 목록을 엄선했습니다.</p>
<p>이 블로그 시리즈에서는 LWC 개발자들이 면접에서 자주 묻는 개념 및 시나리오 기반의 LWC 인터뷰 질문을 모두 다루려고 노력했습니다.</p>
<h2>인터뷰 시리즈</h2>
<p>번쨰 인터뷰 시리즈를 시작해볼까요? 라이트닝 웹 컴포넌트에 대해 얘기해보려고 해요. 인터뷰어와 인터뷰 대상자 사이에서 진행될거에요.</p>
<h1>개념적인 질문들:</h1>
<h2>인터뷰어: 라이트닝 웹 컴포넌트(Lightning Web Components, LWC)란 무엇이고, Aura 컴포넌트와 어떻게 다른가요?</h2>
<h2>인터뷔 대상자:</h2>
<p>번개 웹 컴포넌트(LWC)는 Salesforce 플랫폼에서 번개 컴포넌트를 구축하기 위한 새로운 프로그래밍 모델입니다. 이는 ECMAScript 6와 같은 현대 웹 표준을 활용하여 Aura 컴포넌트와 비교하여 더 나은 성능을 제공합니다. Aura와 달리 LWC는 더 가벼운 프레임워크를 사용하며 웹 개발에 더 간단하고 표준 기반의 접근을 촉진합니다.</p>
<h2>주목하세요!</h2>
<p>여기서 인터뷰어는 위의 질문을 다른 방식으로도 할 수 있습니다.</p>
<h2>인터뷰어: LWC와 Aura 컴포넌트의 주요 차이점은 무엇인가요? 아키텍처, 성능 및 개발 경험을 비교해보세요.</h2>
<p>인터뷰ee: LWC와 헤일로 컴포넌트 사이의 차이점:</p>
<h2>1. 구조:</h2>
<p>헤일로 컴포넌트:</p>
<ul>
<li>클라이언트 측 JavaScript 프레임워크 및 서버 측 Apex 컨트롤러를 활용하는 Aura 프레임워크에 기반함.</li>
<li>마크업, JavaScript 컨트롤러 및 스타일이 하나의 파일 내에 캡슐화된 컴포넌트 기반 구조를 따름.</li>
<li>이벤트, 속성 및 메소드를 포함한 컴포넌트 간 통신을 위해 Aura 컴포넌트 모델을 활용함.</li>
</ul>
<p>LWC (라이트닝 웹 컴포넌트):</p>
<ul>
<li>W3C가 지원하는 최신 웹 컴포넌트 표준을 기반으로 한 웹 표준에 맞춰 개발되었습니다.</li>
<li>형태, 자바스크립트 및 스타일을 위한 별도의 파일을 사용하여 모듈화 아키텍처를 따르며, 캡슐화를 위해 셰도우 DOM을 준수합니다.</li>
<li>컴포넌트 개발을 위해 ECMAScript 모듈과 표준 DOM API를 활용하여, 다른 프레임워크와의 상호 운용성을 제공합니다.</li>
</ul>
<h2>2. 성능:</h2>
<p>Aura 컴포넌트:</p>
<ul>
<li>성능은 프레임워크의 오버헤드와 통신을 위한 Aura 컴포넌트 모델의 사용으로 영향을 받을 수 있습니다.</li>
<li>데이터 검색 및 업데이트를 위한 서버 라운드트립은 지연을 유발하고 전체적인 성능에 영향을 줄 수 있습니다.</li>
</ul>
<p>LWC (라이트닝 웹 컴포넌트):</p>
<ul>
<li>Shadow DOM 및 가상 DOM과 같은 최적화 기술을 사용하여 원시 웹 표준을 사용하므로 성능이 향상됩니다.</li>
<li>클라이언트 측 렌더링 및 최소한의 서버 라운드트립은 더 빠른 로딩 시간과 더 나은 응답성에 기여합니다.</li>
</ul>
<h2>3. 개발 경험:</h2>
<p>오로라 컴포넌트:</p>
<ul>
<li>개발 경험은 오로라 프레임워크의 학습 곡선과 복잡성에 의해 특징 지어질 수 있습니다.</li>
<li>컨트롤러, 헬퍼 및 이벤트와 같은 오로라 특정 개념에 대한 친숙함이 필요합니다.</li>
<li>오로라 개발에 대한 도구 지원은 다른 현대 웹 개발 프레임워크와 비교하여 더 제한적일 수 있습니다.</li>
</ul>
<p>LWC (라이트닝 웹 컴포넌트):</p>
<ul>
<li>ECMAScript 6+ 기능과 표준 웹 API를 지원하여 더 간소화되고 현대적인 개발 경험을 제공합니다.</li>
<li>Salesforce CLI 및 VS Code 확장 프로그램과 같은 현대적인 도구를 활용하여 효율적인 개발 워크플로우를 위해 지원합니다.</li>
<li>오로라와 비교하여 더 깨끗하고 직관적인 구문을 제공하여 코드의 가독성과 유지 보수성이 향상됩니다.</li>
</ul>
<p>개요: 전반적으로 LWC는 Aura 구성 요소에서 중요한 발전을 나타내며, Salesforce 플랫폼에서 구성 요소를 구축하기 위해 더 현대적이고 성능 중심적인 접근 방식을 제공합니다. Aura 구성 요소는 계속 지원되지만, LWC는 Salesforce 개발의 미래 방향으로 위치하고 있으며, 개발자들에게 더 효율적이고 확장 가능한 프레임워크를 제공하여 Lightning UI를 구축합니다.</p>
<h2>인터뷰어: LWC(Lightning Web Components)에서 데이터 바인딩 개념을 설명해 주세요. 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간의 통신을 어떻게 용이하게 하는가요?</h2>
<h2>인터뷉이:</h2>
<p>라이트닝 웹 컴포넌트(LWC)에서 데이터 바인딩은 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간의 연결을 설정하는 메커니즘입니다. 이를 통해 두 요소 간에 데이터의 동기화를 가능케 하여 JavaScript 컨트롤러에서 수행한 변경 사항이 HTML 템플릿에 반영되고 그 반대도 성립합니다. 데이터 바인딩은 컴포넌트 내에서 무결한 통신과 상호작용을 용이하게 하며, 데이터나 사용자 입력의 변경에 따라 동적으로 업데이트하고 콘텐츠를 렌더링할 수 있도록 합니다.</p>
<h2>데이터 바인딩이 어떻게 통신을 용이하게 하는지:</h2>
<h2>1. 속성 바인딩:</h2>
<ul>
<li>속성 바인딩은 JavaScript 속성을 HTML 템플릿의 요소나 속성에 바인딩하는 데 사용됩니다.</li>
<li>중괄호 구문 <code>''</code>을 사용하여 HTML 템플릿 내에서 JavaScript 속성을 참조합니다.</li>
<li>JavaScript 컨트롤러에서 속성 값이 변경되면 HTML 템플릿의 해당 요소나 속성이 자동으로 새 값으로 업데이트됩니다.</li>
<li>마찬가지로 HTML 템플릿의 값이 변경되면 JavaScript 컨트롤러에 다시 반영됩니다.</li>
</ul>
<h2>2. 이벤트 바인딩:</h2>
<ul>
<li>이벤트 바인딩을 사용하면 DOM 이벤트를 JavaScript 컨트롤러의 메서드나 함수에 바인딩할 수 있습니다.</li>
<li>HTML 템플릿에서 이벤트 바인딩을 지정하려면 이벤트 이름 뒤에 <code>on-</code> 접두사를 사용합니다.</li>
<li>지정된 DOM 이벤트가 트리거될 때, JavaScript 컨트롤러의 연관된 메서드나 함수가 호출됩니다.</li>
<li>이를 통해 컴포넌트의 로직 내에서 사용자 상호작용이나 브라우저 이벤트를 처리할 수 있습니다.</li>
</ul>
<p>아래는 LWC에서 데이터 바인딩을 보여주는 예시입니다:</p>
<p>HTML 템플릿 (dataBinding.html):</p>
<pre><code class="hljs language-js">&#x3C;!--dataBinding.<span class="hljs-property">html</span>-->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">template</span>></span>
  <span class="hljs-tag">&#x3C;<span class="hljs-name">lightning-card</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Input Component Example"</span> <span class="hljs-attr">variant</span>=<span class="hljs-string">"narrow"</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"slds-p-around_medium"</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{message}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
      <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"slds-m-top_medium"</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">lightning-input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">onchange</span>=<span class="hljs-string">{handleChange}</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">lightning-input</span>></span>
      <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
  <span class="hljs-tag">&#x3C;/<span class="hljs-name">lightning-card</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">template</span>></span></span>
</code></pre>
<p>JavaScript Controller (dataBinding.js):</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//dataBinding.js</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">LightningElement</span>,track } <span class="hljs-keyword">from</span> <span class="hljs-string">'lwc'</span>;
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataBinding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LightningElement</span> {
  @track message = <span class="hljs-string">'Initial message'</span>;
 
  <span class="hljs-title function_">handleChange</span>(<span class="hljs-params">event</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;
  }
}
</code></pre>
<h2>이 예제에서:</h2>
<ul>
<li>HTML 템플릿에서 <code>'message'</code> 구문은 속성 바인딩을 나타내며, JavaScript 컨트롤러의 <code>message</code> 속성이 <code>p</code> 요소의 내용에 바인딩됩니다.</li>
<li>입력 필드의 값이 변경될 때 (<code>onchange</code> 이벤트), JavaScript 컨트롤러의 <code>handleChange</code> 메서드가 호출되어 <code>message</code> 속성이 업데이트됩니다.</li>
</ul>
<p>결과적으로, <code>p</code> 요소의 내용이 <code>message</code> 속성의 새 값으로 자동으로 업데이트됩니다.</p>
<h2>결과:</h2>
<p>LWC에서 데이터 바인딩은 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간에 원활한 통신을 용이하게 합니다. 이를 통해 컴포넌트의 UI 내에서 동적 업데이트와 상호 작용이 가능해집니다.</p>
<h2>인터뷰어: 쉐도우 DOM이란 무엇이며, LWC가 어떻게 활용하는가?</h2>
<h2>인터뷔이:</h2>
<p>쉐도우 DOM(쉐도우 문서 객체 모델)은 웹 컴포넌트의 기본 기능으로, 스타일, 마크업 및 동작을 문서의 나머지 부분과 분리된 범위 내에 캡슐화하는 것을 허용합니다. 이 캡슐화는 스타일 및 스크립트가 누출되지 않고 페이지의 다른 부분과 충돌하지 않도록 방지하여 더 나은 모듈성과 재사용성을 제공합니다.</p>
<p>라이트닝 웹 컴포넌츠(LWC)에서는 쉐도우 DOM이 컴포넌트의 마크업과 스타일을 주변 문서와 격리시키는 데 활용됩니다. 이는 컴포넌트 내에서 정의한 스타일이 해당 컴포넌트의 쉐도우 DOM 내 요소에만 적용되도록 함으로써 페이지의 다른 컴포넌트나 요소와의 의도치 않은 스타일 충돌을 방지합니다.</p>
<h2>예시:</h2>
<p>간단한 LWC 컴포넌트인 helloWorld를 고려해 보겠습니다. 이 컴포넌트는 인사 메시지를 표시합니다:</p>
<pre><code class="hljs language-javascript">&#x3C;!-- helloWorld.<span class="hljs-property">html</span> -->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">template</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>{greeting}<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">template</span>></span></span>
</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// helloWorld.js</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">LightningElement</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'lwc'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LightningElement</span> {
    greeting = <span class="hljs-string">'Hello, World!'</span>;
}
</code></pre>
<p>이 예시에서는:</p>
<ul>
<li><code>helloWorld</code> 컴포넌트는 <code>greeting</code> 속성의 값을 표시하는 <code>h1</code> 제목이 있는 <code>div</code> 컨테이너로 구성됩니다.</li>
<li><code>greeting</code> 속성은 JavaScript 파일에 정의되어 "Hello, World!" 값으로 초기화됩니다.</li>
</ul>
<h2>결과:</h2>
<p><code>helloWorld</code> 컴포넌트가 렌더링되면 라이트닝 웹 컴포넌트 컨텍스트에서 자체 Shadow DOM을 생성합니다. 브라우저에 나타나는 결과물은 다음과 같습니다:</p>
<pre><code class="hljs language-js">&#x3C;!----shadow-root (open)---->
    <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">h1</span>></span>Hello, World!<span class="hljs-tag">&#x3C;/<span class="hljs-name">h1</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
&#x3C;!----/shadow-root---->
</code></pre>
<p><code>div class=”container”</code>와 <code>h1</code> 요소는 <code>helloWorld</code> 컴포넌트의 Shadow DOM 경계 내에 캡슐화됩니다. 이러한 요소에 적용된 스타일은 컴포넌트 내의 요소에만 영향을 미치므로 격리되어 의도치 않은 스타일 충돌을 방지합니다.</p>
<p>요약하자면, LWC의 Shadow DOM은 컴포넌트 마크업, 스타일링, 동작을 캡슐화하는 메커니즘을 제공하여 향상된 모듈성, 재사용성, 그리고 컴포넌트 기능의 더 나은 캡슐화를 도모합니다.</p>
<h2>면접관: LWC의 맥락에서 명령형과 선언형 프로그래밍을 구별하십시오.</h2>
<h2>면접자:</h2>
<p>라이트닝 웹 컴포넌트(LWC)의 맥락에서 명령형과 선언형 프로그래밍은 컴포넌트를 구축하고 상호 작용하는 두 가지 다른 방식을 나타냅니다.</p>
<h2>명령형 프로그래밍:</h2>
<p>명령형 프로그래밍은 작업이 어떻게 수행되어야 하는지를 명시적으로 정의하는 상세한 지시 사항을 지정하는 것을 포함합니다. LWC의 맥락에서 명령형 프로그래밍은 일반적으로 DOM을 직접 조작하거나 외부 리소스와 상호 작용하기 위해 명령형 API 호출을 하는 것을 포함합니다.</p>
<p>LWC에서의 명령형 프로그래밍 예시:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">LightningElement</span>, wire } <span class="hljs-keyword">from</span> <span class="hljs-string">'lwc'</span>;
<span class="hljs-keyword">import</span> { getRecord } <span class="hljs-keyword">from</span> <span class="hljs-string">'lightning/uiRecordApi'</span>;
 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImperativeExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LightningElement</span> {
    recordId;
    error;
 
    @<span class="hljs-title function_">wire</span>(getRecord, { <span class="hljs-attr">recordId</span>: <span class="hljs-string">'$recordId'</span>, <span class="hljs-attr">fields</span>: [<span class="hljs-string">'Account.Name'</span>] })
    <span class="hljs-title function_">wiredRecord</span>(<span class="hljs-params">{ error, data }</span>) {
        <span class="hljs-keyword">if</span> (data) {
            <span class="hljs-comment">// 데이터 처리</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error) {
            <span class="hljs-comment">// 오류 처리</span>
        }
    }
 
    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// 레코드 데이터를 로드하기 위한 명령형 호출</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">recordId</span> = <span class="hljs-string">'001XXXXXXXXXXXXXXX'</span>;
    }
}
</code></pre>
<h2>선언적 프로그래밍:</h2>
<p>반면에 선언적 프로그래밍은 어떻게 해야 하는지 자세히 설명하지 않고 달성해야 할 목표를 지정하는 것을 포함합니다. LWC에서 선언적 프로그래밍은 주로 마크업을 사용하여 구성 요소 동작을 정의하고 프레임워크에서 제공하는 내장 기능 및 기능을 활용하는 것을 포함합니다.</p>
<p>LWC에서 선언적 프로그래밍의 예시:</p>
<pre><code class="hljs language-js">&#x3C;!--declarativeExample.<span class="hljs-property">html</span>-->
<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">template</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">lightning-card</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Declarative Example"</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">if:true</span>=<span class="hljs-string">{isDataLoaded}</span>></span>
            <span class="hljs-comment">&#x3C;!-- 데이터에 따른 선언적 렌더링 --></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>{accountName}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">div</span> <span class="hljs-attr">if:true</span>=<span class="hljs-string">{error}</span>></span>
            <span class="hljs-comment">&#x3C;!-- 오류에 따른 선언적 렌더링 --></span>
            <span class="hljs-tag">&#x3C;<span class="hljs-name">p</span>></span>Error: {error}<span class="hljs-tag">&#x3C;/<span class="hljs-name">p</span>></span>
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>
        <span class="hljs-tag">&#x3C;<span class="hljs-name">lightning-button</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"Load Data"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">{handleClick}</span>></span><span class="hljs-tag">&#x3C;/<span class="hljs-name">lightning-button</span>></span>
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">lightning-card</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">template</span>></span></span>
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">//declarativeExample.js</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">LightningElement</span>, wire } <span class="hljs-keyword">from</span> <span class="hljs-string">'lwc'</span>;
<span class="hljs-keyword">import</span> { getRecord } <span class="hljs-keyword">from</span> <span class="hljs-string">'lightning/uiRecordApi'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeclarativeExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LightningElement</span> {
    recordId = <span class="hljs-string">'001XXXXXXXXXXXXXXX'</span>;
    error;
    accountName;
    isDataLoaded = <span class="hljs-literal">false</span>;

    @<span class="hljs-title function_">wire</span>(getRecord, { <span class="hljs-attr">recordId</span>: <span class="hljs-string">'$recordId'</span>, <span class="hljs-attr">fields</span>: [<span class="hljs-string">'Account.Name'</span>] })
    <span class="hljs-title function_">wiredRecord</span>(<span class="hljs-params">{ error, data }</span>) {
        <span class="hljs-keyword">if</span> (data) {
            <span class="hljs-comment">// 데이터를 선언적으로 처리</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">accountName</span> = data.<span class="hljs-property">fields</span>.<span class="hljs-property">Name</span>.<span class="hljs-property">value</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDataLoaded</span> = <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (error) {
            <span class="hljs-comment">// 오류를 선언적으로 처리</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">error</span> = error.<span class="hljs-property">body</span>.<span class="hljs-property">message</span>;
        }
    }

    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// 레코드 데이터 로드를 선언적으로 트리거</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">recordId</span> = <span class="hljs-string">'001XXXXXXXXXXXXXXX'</span>;
    }
}
</code></pre>
<p>아래는 예시입니다:</p>
<ul>
<li><code>accountName</code>과 <code>isDataLoaded</code>는 컴포넌트 속성으로 초기화됩니다.</li>
<li>recordId는 JavaScript 클래스의 속성 <code>recordId</code>에 직접 할당됩니다. 이로써 <code>handleClick()</code> 내에서 <code>this.recordId = ‘001XXXXXXXXXXXXXXX’;</code>를 호출할 필요가 없어집니다.</li>
<li>컴포넌트가 로드될 때, 와이어 어댑터를 사용하여 자동으로 계정 레코드의 이름을 불러옵니다.</li>
<li>버튼 클릭 이벤트가 레코드 데이터 로드를 트리거하지만, 정적 recordId를 사용하기 때문에 시각적으로 변화는 없습니다.</li>
</ul>
<p>출력:</p>
<p>차이점:</p>
<p>LWC에서 명령형과 선언적 프로그래밍의 주요 차이점은 구성 요소 동작이 어떻게 정의되고 구현되는지에 있습니다:</p>
<h2>1. 명령형 프로그래밍:</h2>
<ul>
<li>작업을 수행하는 방법에 명확한 지시사항을 지정하는 것을 포함합니다.</li>
<li>주로 DOM을 직접 조작하거나 명령형 API 호출을 하는 것을 포함합니다.</li>
<li>더 많은 제어와 유연성을 제공하지만 길고 가독성이 떨어지는 코드로 이어질 수 있습니다.</li>
</ul>
<h2>2. 선언형 프로그래밍:</h2>
<ul>
<li>어떻게 해야 하는지를 명시하지 않고 무엇을 달성해야 하는지를 정의하는 것을 포함합니다.</li>
<li>종종 마크업을 사용하여 구성 요소 동작을 정의하고 프레임워크에서 제공하는 내장 기능을 활용하는 것을 포함합니다.</li>
<li>구성 요소 동작을 정의하는 더 간결하고 표현력이 있는 방식을 제공하여 더 깨끗하고 유지보수가 쉬운 코드를 만들어줍니다.</li>
</ul>
<p>LWC 개발에서 명령형 및 선언형 프로그래밍 패러다임은 각각의 장소를 가지고 있으며, 개발자는 종종 구성 요소의 특정 요구사항과 복잡성에 가장 적합한 방법을 선택합니다.</p>
<h2>인터뷰어: LWC는 구성 요소 간 통신을 어떻게 용이하게 해주나요?</h2>
<h2>면접자:</h2>
<p>LWC는 구성 요소 통신을 위한 여러 메커니즘을 제공합니다. 속성 전달, 이벤트 처리 및 pub-sub 패턴을 포함합니다. 구성 요소는 속성과 속성을 통해 데이터를 교환하거나 이벤트를 발행하고 처리하거나 라이트닝 메시지 서비스나 플랫폼 이벤트를 사용하여 사용자 정의 이벤트에 가입함으로써 데이터를 교환할 수 있습니다.</p>
<h2>주의!</h2>
<p>여기서 인터뷰관은 위의 질문들을 다른 방식으로도 할 수 있습니다.</p>
<h2>면접관: 라이트닝 웹 컴포넌트 간 통신하는 다양한 방법은 무엇인가요? 컴포넌트 이벤트, 공개 속성, 그리고 메소드의 사용법에 대해 비교하고 대조해보세요.</h2>
<h2>면접자:</h2>
<p>라이트닝 웹 컴포넌트(LWC)에서는 컴포넌트 간 통신을 위한 여러 방법이 있으며, 각각의 사용 사례와 장단점을 갖고 있습니다. 주요 방법으로는 컴포넌트 이벤트, 공개 속성, 그리고 메소드가 포함됩니다. 이러한 접근 방식을 비교하고 대조해보겠습니다:</p>
<h2>1. 컴포넌트 이벤트:</h2>
<p>목적: 컴포넌트 이벤트는 컴포넌트 계층 구조에서 직접적으로 관려되지 않은 컴포넌트 간의 통신을 가능하게 합니다. 이를 통해 컴포넌트가 서로의 구현 세부 정보를 알 필요 없이 통신할 수 있는 느슨한 결합을 가능하게 합니다.</p>
<p>사용법: 컴포넌트는 <code>CustomEvent</code> 생성자나 <code>dispatchEvent</code> 메서드를 사용하여 이벤트를 발송합니다. 다른 컴포넌트는 이러한 이벤트를 템플릿 안의 이벤트 핸들러를 통해 처리할 수 있습니다.</p>
<p>예시:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 커스텀 이벤트 발송</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">'customEventName'</span>, { <span class="hljs-attr">detail</span>: eventData }));
</code></pre>
<p>장점:</p>
<ul>
<li>컴포넌트를 분리함으로써 재사용성이 높아지고 모듈화가 용이해집니다.</li>
<li>계층적 관계와 무관하게 컴포넌트 간의 통신이 가능합니다.</li>
</ul>
<p>단점:</p>
<ul>
<li>다른 방법에 비해 추가 설정과 오버헤드가 필요합니다.</li>
<li>특히 초보자에게는 구현과 이해가 더 복잡할 수 있습니다.</li>
</ul>
<h2>2. 공개 속성:</h2>
<p>목적: 공개 속성은 컴포넌트에서 노출되는 속성으로, 다른 컴포넌트가 설정하거나 액세스할 수 있습니다. 부모-자식 간 통신을 가능하게 해 부모 컴포넌트가 데이터나 구성을 자식 컴포넌트에 전달할 수 있게 합니다.</p>
<p>사용법: 공개 속성은 자식 컴포넌트에서 <code>@api</code> 데코레이터로 표시됩니다. 부모 컴포넌트는 자식 컴포넌트를 인스턴스화할 때 이러한 속성의 값을 설정합니다.</p>
<p>예제:</p>
<pre><code class="hljs language-html">// 자식 컴포넌트
import { LightningElement, api } from 'lwc';
export default class ChildComponent extends LightningElement {
    @api message;
}
</code></pre>
<p>장점:</p>
<ul>
<li>구현하기 간단하고 직관적입니다.</li>
<li>부모 및 자식 컴포넌트간의 통신을 용이하게합니다.</li>
</ul>
<p>단점:</p>
<ul>
<li>더 복잡한 통신 시나리오에는 사용할 수 없는 부모-자식 관계로 제한됩니다.</li>
<li>컴포넌트 내부를 부모 컴포넌트에 노출하여 긴밀한 결합을 유발할 수 있습니다.</li>
</ul>
<h2>3. 메서드:</h2>
<p>목적: 메서드를 사용하면 다른 컴포넌트에서 호출할 수 있는 기능을 노출시킬 수 있습니다. 부모-자식 및 자식-부모 간 통신을 가능하게 하여 컴포넌트가 상호작용하고 협업할 수 있습니다.</p>
<p>사용법: 메서드는 컴포넌트의 JavaScript 클래스에서 정의되며 다른 컴포넌트에서 메서드 호출을 통해 호출될 수 있습니다.</p>
<p>예시:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 하위 컴포넌트</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">LightningElement</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'lwc'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LightningElement</span> {
    <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">// 클릭 로직 처리</span>
    }
}
</code></pre>
<p>장점:</p>
<ul>
<li>컴포넌트가 서로 기능을 호출하여 상호작용하고 협업하는 방법을 제공합니다.</li>
<li>부모에서 자식으로, 그리고 자식에서 부모로 통신을 지원합니다.</li>
</ul>
<p>단점:</p>
<ul>
<li>상호 참조를 가진 구성 요소에 제한되어 더 자유롭게 결합된 시나리오에는 사용이 제한될 수 있습니다.</li>
<li>과도하게 사용되거나 잘못 사용될 경우 강력한 결합을 초래할 수 있습니다.</li>
</ul>
<p>요약하면, 구성 요소 이벤트, 공용 속성 및 메서드는 모두 라이트닝 웹 컴포넌트 간의 통신을 촉진하는 데 유용한 도구입니다. 어떤 방법을 사용할지 선택하는 것은 통신 시나리오의 특정 요구 사항, 관련된 구성 요소 간의 관계 및 원하는 캡슐화 및 결합 수준에 따라 달라집니다.</p>
<h2>인터뷰어: LWC에서 라이프사이클 훅의 개념을 설명해주세요. 사용 가능한 여러 라이프사이클 훅은 무엇이며, 구성 요소 라이프사이클 중에 언제 호출되나요?</h2>
<h2>면접자:</h2>
<p>라이트닝 웹 컴포넌트(LWC)에서의 라이프사이클 훅은 컴포넌트의 라이프사이클 중 특정 시점에 자동으로 호출되는 메서드입니다. 이러한 훅을 사용하면 초기화, 렌더링 및 소멸과 같은 컴포넌트의 라이프사이클의 다양한 단계에서 사용자 정의 로직을 실행할 수 있습니다. 라이프사이클 훅을 활용하여 데이터 초기화, 외부 리소스 가져오기 및 컴포넌트가 소멸될 때 리소스 정리와 같은 작업을 수행할 수 있습니다.</p>
<p>LWC의 다양한 라이프사이클 훅:</p>
<ol>
<li>constructor():
생성자 함수는 생성자 메서드로서 객체 인스턴스가 생성될 때 호출되는 훅입니다.</li>
</ol>
<ul>
<li>컴포넌트가 생성될 때 호출됩니다.</li>
<li>컴포넌트 속성 및 상태를 초기화하는 데 사용됩니다.</li>
</ul>
<p>예시:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>();
    <span class="hljs-comment">// 초기화 로직</span>
}
</code></pre>
<ol start="2">
<li>connectedCallback():</li>
</ol>
<ul>
<li>DOM에 구성 요소가 삽입될 때 호출됩니다.</li>
<li>DOM에 액세스가 필요한 설정 작업을 수행하는 데 사용됩니다.</li>
</ul>
<p>예:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">connectedCallback</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 설정 작업</span>
}
</code></pre>
<ol start="3">
<li>renderedCallback():</li>
</ol>
<ul>
<li>구성 요소 템플릿 렌더링 후에 호출됩니다.</li>
<li>렌더링된 DOM에 따라 동작을 수행하는 데 사용됩니다.</li>
</ul>
<p>예시:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">renderedCallback</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// DOM 조작</span>
}
</code></pre>
<ol start="4">
<li>disconnectedCallback():</li>
</ol>
<ul>
<li>DOM에서 구성 요소가 제거될 때 호출됩니다.</li>
<li>리소스 정리 또는 정리 작업을 수행하는 데 사용됩니다.</li>
</ul>
<p>예시:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">disconnectedCallback</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 정리 작업</span>
}
</code></pre>
<ol start="5">
<li>render():</li>
</ol>
<ul>
<li>컴포넌트 템플릿을 렌더링하기 위해 호출됩니다.</li>
<li>컴포넌트 UI의 구조와 내용을 정의하는 데 사용됩니다.</li>
</ul>
<p>예시:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> html`<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">div</span>></span>Hello, World!<span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span>`</span>;
}
</code></pre>
<ol start="6">
<li>reconnectedCallback():</li>
</ol>
<ul>
<li>구성 요소가 제거된 후 DOM에 다시 삽입될 때 호출됩니다.</li>
<li>상태를 재설정하거나 설정 작업을 수행하는 데 사용됩니다.</li>
</ul>
<p>예시:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">reconnectedCallback</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 초기화 작업</span>
}
</code></pre>
<p>라이프사이클 훅 호출:</p>
<ul>
<li>생성자(Constructor): 컴포넌트가 생성될 때 호출됩니다.</li>
<li>연결된 콜백(Connected Callback): 컴포넌트가 DOM에 삽입될 때 호출됩니다.</li>
<li>렌더링된 콜백(Rendered Callback): 컴포넌트의 템플릿이 렌더링된 후 호출됩니다.</li>
<li>연결 해제된 콜백(Disconnected Callback): 컴포넌트가 DOM에서 제거될 때 호출됩니다.</li>
<li>렌더(Render): 컴포넌트가 템플릿을 렌더링해야 할 때 호출됩니다.</li>
<li>다시 연결된 콜백(Reconnected Callback): 컴포넌트가 제거된 후 다시 DOM에 삽입될 때 호출됩니다.</li>
</ul>
<p>LWC(Lightning Web Components)에서 제공되는 라이프사이클 훅과 그 호출 순서를 이해함으로써, 개발자들은 컴포넌트 초기화, 렌더링 및 정리 작업을 효과적으로 관리하여 컴포넌트의 라이프사이클 동안 최적의 성능과 동작을 확보할 수 있습니다.</p>
<p>더 궁금한 점이 있다면 아래 링크를 방문해주세요:</p>
<p>희망하건대, 이번 Lightning Web Components (LWC) 인터뷰 시리즈가 LWC 개념에 관한 질문들을 명확히 이해하고 인터뷰에 성공하는 데 도움이 될 것입니다.</p>
<p>표 태그를 마크다운 형식으로 변경해주세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"LWC 인터뷰 질문 시리즈 1","description":"","date":"2024-06-20 07:28","slug":"2024-06-20-LWCInterviewQuestionsSeries1","content":"\n\n## (2024)\n\n![LWC Interview Questions](/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png)\n\n라이트닝 웹 컴포넌트(LWC)는 Salesforce 개발 분야에서 동적이고 반응적인 사용자 인터페이스를 개발하는 강력한 도구입니다. 성능을 향상시키고 개발 프로세스를 더 효율적으로 만들어 주는 능력 덕분에 LWC는 현대 Salesforce 플랫폼 앱의 기본 구성 요소가 되었습니다. 자격 있는 LWC 개발자를 찾는 것은 이 기술을 완벽히 활용할 수 있는 유능한 팀을 구성하기 위해 매우 중요합니다.\n\n우리는 이러한 노력을 돕기 위해 개념적 이해와 현실 시나리오에 대한 LWC 인터뷰 문제를 철저하게 수집했습니다. 이러한 질문의 목적은 후보자의 문제 해결 능력, LWC 개발에 대한 전문 지식, 그리고 Salesforce 개발의 최선의 실천 방법의 적용을 평가하는 데 도움을 주는 것입니다. 이제 시작해 보겠습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 주의 !\n\nLWC 인터뷰 준비는 압도적인 과제일 수 있습니다. LWC 개념, 최고의 실천 방법 및 실무 경험을 철저히 이해해야 합니다. 여러분의 여정을 돕기 위해 LWC 관련 다양한 주제를 다루는 면접 질문 목록을 엄선했습니다.\n\n이 블로그 시리즈에서는 LWC 개발자들이 면접에서 자주 묻는 개념 및 시나리오 기반의 LWC 인터뷰 질문을 모두 다루려고 노력했습니다.\n\n## 인터뷰 시리즈\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번쨰 인터뷰 시리즈를 시작해볼까요? 라이트닝 웹 컴포넌트에 대해 얘기해보려고 해요. 인터뷰어와 인터뷰 대상자 사이에서 진행될거에요.\n\n# 개념적인 질문들:\n\n## 인터뷰어: 라이트닝 웹 컴포넌트(Lightning Web Components, LWC)란 무엇이고, Aura 컴포넌트와 어떻게 다른가요?\n\n## 인터뷔 대상자:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번개 웹 컴포넌트(LWC)는 Salesforce 플랫폼에서 번개 컴포넌트를 구축하기 위한 새로운 프로그래밍 모델입니다. 이는 ECMAScript 6와 같은 현대 웹 표준을 활용하여 Aura 컴포넌트와 비교하여 더 나은 성능을 제공합니다. Aura와 달리 LWC는 더 가벼운 프레임워크를 사용하며 웹 개발에 더 간단하고 표준 기반의 접근을 촉진합니다.\n\n## 주목하세요!\n\n여기서 인터뷰어는 위의 질문을 다른 방식으로도 할 수 있습니다.\n\n## 인터뷰어: LWC와 Aura 컴포넌트의 주요 차이점은 무엇인가요? 아키텍처, 성능 및 개발 경험을 비교해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터뷰ee: LWC와 헤일로 컴포넌트 사이의 차이점:\n\n## 1. 구조:\n\n헤일로 컴포넌트:\n\n- 클라이언트 측 JavaScript 프레임워크 및 서버 측 Apex 컨트롤러를 활용하는 Aura 프레임워크에 기반함.\n- 마크업, JavaScript 컨트롤러 및 스타일이 하나의 파일 내에 캡슐화된 컴포넌트 기반 구조를 따름.\n- 이벤트, 속성 및 메소드를 포함한 컴포넌트 간 통신을 위해 Aura 컴포넌트 모델을 활용함.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLWC (라이트닝 웹 컴포넌트):\n\n- W3C가 지원하는 최신 웹 컴포넌트 표준을 기반으로 한 웹 표준에 맞춰 개발되었습니다.\n- 형태, 자바스크립트 및 스타일을 위한 별도의 파일을 사용하여 모듈화 아키텍처를 따르며, 캡슐화를 위해 셰도우 DOM을 준수합니다.\n- 컴포넌트 개발을 위해 ECMAScript 모듈과 표준 DOM API를 활용하여, 다른 프레임워크와의 상호 운용성을 제공합니다.\n\n## 2. 성능:\n\nAura 컴포넌트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 성능은 프레임워크의 오버헤드와 통신을 위한 Aura 컴포넌트 모델의 사용으로 영향을 받을 수 있습니다.\n- 데이터 검색 및 업데이트를 위한 서버 라운드트립은 지연을 유발하고 전체적인 성능에 영향을 줄 수 있습니다.\n\nLWC (라이트닝 웹 컴포넌트):\n\n- Shadow DOM 및 가상 DOM과 같은 최적화 기술을 사용하여 원시 웹 표준을 사용하므로 성능이 향상됩니다.\n- 클라이언트 측 렌더링 및 최소한의 서버 라운드트립은 더 빠른 로딩 시간과 더 나은 응답성에 기여합니다.\n\n## 3. 개발 경험:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오로라 컴포넌트:\n\n- 개발 경험은 오로라 프레임워크의 학습 곡선과 복잡성에 의해 특징 지어질 수 있습니다.\n- 컨트롤러, 헬퍼 및 이벤트와 같은 오로라 특정 개념에 대한 친숙함이 필요합니다.\n- 오로라 개발에 대한 도구 지원은 다른 현대 웹 개발 프레임워크와 비교하여 더 제한적일 수 있습니다.\n\nLWC (라이트닝 웹 컴포넌트):\n\n- ECMAScript 6+ 기능과 표준 웹 API를 지원하여 더 간소화되고 현대적인 개발 경험을 제공합니다.\n- Salesforce CLI 및 VS Code 확장 프로그램과 같은 현대적인 도구를 활용하여 효율적인 개발 워크플로우를 위해 지원합니다.\n- 오로라와 비교하여 더 깨끗하고 직관적인 구문을 제공하여 코드의 가독성과 유지 보수성이 향상됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개요: 전반적으로 LWC는 Aura 구성 요소에서 중요한 발전을 나타내며, Salesforce 플랫폼에서 구성 요소를 구축하기 위해 더 현대적이고 성능 중심적인 접근 방식을 제공합니다. Aura 구성 요소는 계속 지원되지만, LWC는 Salesforce 개발의 미래 방향으로 위치하고 있으며, 개발자들에게 더 효율적이고 확장 가능한 프레임워크를 제공하여 Lightning UI를 구축합니다.\n\n## 인터뷰어: LWC(Lightning Web Components)에서 데이터 바인딩 개념을 설명해 주세요. 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간의 통신을 어떻게 용이하게 하는가요?\n\n## 인터뷉이:\n\n라이트닝 웹 컴포넌트(LWC)에서 데이터 바인딩은 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간의 연결을 설정하는 메커니즘입니다. 이를 통해 두 요소 간에 데이터의 동기화를 가능케 하여 JavaScript 컨트롤러에서 수행한 변경 사항이 HTML 템플릿에 반영되고 그 반대도 성립합니다. 데이터 바인딩은 컴포넌트 내에서 무결한 통신과 상호작용을 용이하게 하며, 데이터나 사용자 입력의 변경에 따라 동적으로 업데이트하고 콘텐츠를 렌더링할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 데이터 바인딩이 어떻게 통신을 용이하게 하는지:\n\n## 1. 속성 바인딩:\n\n- 속성 바인딩은 JavaScript 속성을 HTML 템플릿의 요소나 속성에 바인딩하는 데 사용됩니다.\n- 중괄호 구문 `''`을 사용하여 HTML 템플릿 내에서 JavaScript 속성을 참조합니다.\n- JavaScript 컨트롤러에서 속성 값이 변경되면 HTML 템플릿의 해당 요소나 속성이 자동으로 새 값으로 업데이트됩니다.\n- 마찬가지로 HTML 템플릿의 값이 변경되면 JavaScript 컨트롤러에 다시 반영됩니다.\n\n## 2. 이벤트 바인딩:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이벤트 바인딩을 사용하면 DOM 이벤트를 JavaScript 컨트롤러의 메서드나 함수에 바인딩할 수 있습니다.\n- HTML 템플릿에서 이벤트 바인딩을 지정하려면 이벤트 이름 뒤에 `on-` 접두사를 사용합니다.\n- 지정된 DOM 이벤트가 트리거될 때, JavaScript 컨트롤러의 연관된 메서드나 함수가 호출됩니다.\n- 이를 통해 컴포넌트의 로직 내에서 사용자 상호작용이나 브라우저 이벤트를 처리할 수 있습니다.\n\n아래는 LWC에서 데이터 바인딩을 보여주는 예시입니다:\n\nHTML 템플릿 (dataBinding.html):\n\n```js\n\u003c!--dataBinding.html--\u003e\n\u003ctemplate\u003e\n  \u003clightning-card title=\"Input Component Example\" variant=\"narrow\"\u003e\n    \u003cdiv class=\"slds-p-around_medium\"\u003e\n      \u003cp\u003e{message}\u003c/p\u003e\n      \u003cdiv class=\"slds-m-top_medium\"\u003e\n        \u003clightning-input type=\"text\" onchange={handleChange}\u003e\u003c/lightning-input\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/lightning-card\u003e\n\u003c/template\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJavaScript Controller (dataBinding.js):\n\n```js\n//dataBinding.js\nimport { LightningElement,track } from 'lwc';\n \nexport default class DataBinding extends LightningElement {\n  @track message = 'Initial message';\n \n  handleChange(event) {\n      this.message = event.target.value;\n  }\n}\n```\n\n## 이 예제에서:\n\n- HTML 템플릿에서 `'message'` 구문은 속성 바인딩을 나타내며, JavaScript 컨트롤러의 `message` 속성이 ``p`` 요소의 내용에 바인딩됩니다.\n- 입력 필드의 값이 변경될 때 (`onchange` 이벤트), JavaScript 컨트롤러의 `handleChange` 메서드가 호출되어 `message` 속성이 업데이트됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과적으로, ``p`` 요소의 내용이 `message` 속성의 새 값으로 자동으로 업데이트됩니다.\n\n## 결과:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/0*erCBAckytrHhVEgu.gif\" /\u003e\n\nLWC에서 데이터 바인딩은 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간에 원활한 통신을 용이하게 합니다. 이를 통해 컴포넌트의 UI 내에서 동적 업데이트와 상호 작용이 가능해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 인터뷰어: 쉐도우 DOM이란 무엇이며, LWC가 어떻게 활용하는가?\n\n## 인터뷔이:\n\n쉐도우 DOM(쉐도우 문서 객체 모델)은 웹 컴포넌트의 기본 기능으로, 스타일, 마크업 및 동작을 문서의 나머지 부분과 분리된 범위 내에 캡슐화하는 것을 허용합니다. 이 캡슐화는 스타일 및 스크립트가 누출되지 않고 페이지의 다른 부분과 충돌하지 않도록 방지하여 더 나은 모듈성과 재사용성을 제공합니다.\n\n라이트닝 웹 컴포넌츠(LWC)에서는 쉐도우 DOM이 컴포넌트의 마크업과 스타일을 주변 문서와 격리시키는 데 활용됩니다. 이는 컴포넌트 내에서 정의한 스타일이 해당 컴포넌트의 쉐도우 DOM 내 요소에만 적용되도록 함으로써 페이지의 다른 컴포넌트나 요소와의 의도치 않은 스타일 충돌을 방지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 예시:\n\n간단한 LWC 컴포넌트인 helloWorld를 고려해 보겠습니다. 이 컴포넌트는 인사 메시지를 표시합니다:\n\n```javascript\n\u003c!-- helloWorld.html --\u003e\n\u003ctemplate\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ch1\u003e{greeting}\u003c/h1\u003e\n    \u003c/div\u003e\n\u003c/template\u003e\n```\n\n```javascript\n// helloWorld.js\nimport { LightningElement } from 'lwc';\n\nexport default class HelloWorld extends LightningElement {\n    greeting = 'Hello, World!';\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서는:\n\n- `helloWorld` 컴포넌트는 `greeting` 속성의 값을 표시하는 `h1` 제목이 있는 `div` 컨테이너로 구성됩니다.\n- `greeting` 속성은 JavaScript 파일에 정의되어 \"Hello, World!\" 값으로 초기화됩니다.\n\n## 결과:\n\n\u003cimg src=\"/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`helloWorld` 컴포넌트가 렌더링되면 라이트닝 웹 컴포넌트 컨텍스트에서 자체 Shadow DOM을 생성합니다. 브라우저에 나타나는 결과물은 다음과 같습니다:\n\n```js\n\u003c!----shadow-root (open)----\u003e\n    \u003cdiv class=\"container\"\u003e\n        \u003ch1\u003eHello, World!\u003c/h1\u003e\n    \u003c/div\u003e\n\u003c!----/shadow-root----\u003e\r\n```\n\n``div class=”container”``와 ``h1`` 요소는 `helloWorld` 컴포넌트의 Shadow DOM 경계 내에 캡슐화됩니다. 이러한 요소에 적용된 스타일은 컴포넌트 내의 요소에만 영향을 미치므로 격리되어 의도치 않은 스타일 충돌을 방지합니다.\n\n요약하자면, LWC의 Shadow DOM은 컴포넌트 마크업, 스타일링, 동작을 캡슐화하는 메커니즘을 제공하여 향상된 모듈성, 재사용성, 그리고 컴포넌트 기능의 더 나은 캡슐화를 도모합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 면접관: LWC의 맥락에서 명령형과 선언형 프로그래밍을 구별하십시오.\n\n## 면접자:\n\n라이트닝 웹 컴포넌트(LWC)의 맥락에서 명령형과 선언형 프로그래밍은 컴포넌트를 구축하고 상호 작용하는 두 가지 다른 방식을 나타냅니다.\n\n## 명령형 프로그래밍:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n명령형 프로그래밍은 작업이 어떻게 수행되어야 하는지를 명시적으로 정의하는 상세한 지시 사항을 지정하는 것을 포함합니다. LWC의 맥락에서 명령형 프로그래밍은 일반적으로 DOM을 직접 조작하거나 외부 리소스와 상호 작용하기 위해 명령형 API 호출을 하는 것을 포함합니다.\n\nLWC에서의 명령형 프로그래밍 예시:\n\n```js\nimport { LightningElement, wire } from 'lwc';\nimport { getRecord } from 'lightning/uiRecordApi';\n \nexport default class ImperativeExample extends LightningElement {\n    recordId;\n    error;\n \n    @wire(getRecord, { recordId: '$recordId', fields: ['Account.Name'] })\n    wiredRecord({ error, data }) {\n        if (data) {\n            // 데이터 처리\n        } else if (error) {\n            // 오류 처리\n        }\n    }\n \n    handleClick() {\n        // 레코드 데이터를 로드하기 위한 명령형 호출\n        this.recordId = '001XXXXXXXXXXXXXXX';\n    }\n}\n```\n\n## 선언적 프로그래밍:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n반면에 선언적 프로그래밍은 어떻게 해야 하는지 자세히 설명하지 않고 달성해야 할 목표를 지정하는 것을 포함합니다. LWC에서 선언적 프로그래밍은 주로 마크업을 사용하여 구성 요소 동작을 정의하고 프레임워크에서 제공하는 내장 기능 및 기능을 활용하는 것을 포함합니다.\n\nLWC에서 선언적 프로그래밍의 예시:\n\n```js\n\u003c!--declarativeExample.html--\u003e\n\u003ctemplate\u003e\n    \u003clightning-card title=\"Declarative Example\"\u003e\n        \u003cdiv if:true={isDataLoaded}\u003e\n            \u003c!-- 데이터에 따른 선언적 렌더링 --\u003e\n            \u003cp\u003e{accountName}\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv if:true={error}\u003e\n            \u003c!-- 오류에 따른 선언적 렌더링 --\u003e\n            \u003cp\u003eError: {error}\u003c/p\u003e\n        \u003c/div\u003e\n        \u003clightning-button label=\"Load Data\" onclick={handleClick}\u003e\u003c/lightning-button\u003e\n    \u003c/lightning-card\u003e\n\u003c/template\u003e\n```\n\n```js\n//declarativeExample.js\nimport { LightningElement, wire } from 'lwc';\nimport { getRecord } from 'lightning/uiRecordApi';\n\nexport default class DeclarativeExample extends LightningElement {\n    recordId = '001XXXXXXXXXXXXXXX';\n    error;\n    accountName;\n    isDataLoaded = false;\n\n    @wire(getRecord, { recordId: '$recordId', fields: ['Account.Name'] })\n    wiredRecord({ error, data }) {\n        if (data) {\n            // 데이터를 선언적으로 처리\n            this.accountName = data.fields.Name.value;\n            this.isDataLoaded = true;\n        } else if (error) {\n            // 오류를 선언적으로 처리\n            this.error = error.body.message;\n        }\n    }\n\n    handleClick() {\n        // 레코드 데이터 로드를 선언적으로 트리거\n        this.recordId = '001XXXXXXXXXXXXXXX';\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 예시입니다:\n\n- `accountName`과 `isDataLoaded`는 컴포넌트 속성으로 초기화됩니다.\n- recordId는 JavaScript 클래스의 속성 `recordId`에 직접 할당됩니다. 이로써 `handleClick()` 내에서 `this.recordId = ‘001XXXXXXXXXXXXXXX’;`를 호출할 필요가 없어집니다.\n- 컴포넌트가 로드될 때, 와이어 어댑터를 사용하여 자동으로 계정 레코드의 이름을 불러옵니다.\n- 버튼 클릭 이벤트가 레코드 데이터 로드를 트리거하지만, 정적 recordId를 사용하기 때문에 시각적으로 변화는 없습니다.\n\n출력:\n\n\u003cimg src=\"/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n차이점:\n\nLWC에서 명령형과 선언적 프로그래밍의 주요 차이점은 구성 요소 동작이 어떻게 정의되고 구현되는지에 있습니다:\n\n## 1. 명령형 프로그래밍:\n\n- 작업을 수행하는 방법에 명확한 지시사항을 지정하는 것을 포함합니다.\n- 주로 DOM을 직접 조작하거나 명령형 API 호출을 하는 것을 포함합니다.\n- 더 많은 제어와 유연성을 제공하지만 길고 가독성이 떨어지는 코드로 이어질 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 선언형 프로그래밍:\n\n- 어떻게 해야 하는지를 명시하지 않고 무엇을 달성해야 하는지를 정의하는 것을 포함합니다.\n- 종종 마크업을 사용하여 구성 요소 동작을 정의하고 프레임워크에서 제공하는 내장 기능을 활용하는 것을 포함합니다.\n- 구성 요소 동작을 정의하는 더 간결하고 표현력이 있는 방식을 제공하여 더 깨끗하고 유지보수가 쉬운 코드를 만들어줍니다.\n\nLWC 개발에서 명령형 및 선언형 프로그래밍 패러다임은 각각의 장소를 가지고 있으며, 개발자는 종종 구성 요소의 특정 요구사항과 복잡성에 가장 적합한 방법을 선택합니다.\n\n## 인터뷰어: LWC는 구성 요소 간 통신을 어떻게 용이하게 해주나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 면접자:\n\nLWC는 구성 요소 통신을 위한 여러 메커니즘을 제공합니다. 속성 전달, 이벤트 처리 및 pub-sub 패턴을 포함합니다. 구성 요소는 속성과 속성을 통해 데이터를 교환하거나 이벤트를 발행하고 처리하거나 라이트닝 메시지 서비스나 플랫폼 이벤트를 사용하여 사용자 정의 이벤트에 가입함으로써 데이터를 교환할 수 있습니다.\n\n## 주의!\n\n여기서 인터뷰관은 위의 질문들을 다른 방식으로도 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 면접관: 라이트닝 웹 컴포넌트 간 통신하는 다양한 방법은 무엇인가요? 컴포넌트 이벤트, 공개 속성, 그리고 메소드의 사용법에 대해 비교하고 대조해보세요.\n\n## 면접자:\n\n라이트닝 웹 컴포넌트(LWC)에서는 컴포넌트 간 통신을 위한 여러 방법이 있으며, 각각의 사용 사례와 장단점을 갖고 있습니다. 주요 방법으로는 컴포넌트 이벤트, 공개 속성, 그리고 메소드가 포함됩니다. 이러한 접근 방식을 비교하고 대조해보겠습니다:\n\n## 1. 컴포넌트 이벤트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n목적: 컴포넌트 이벤트는 컴포넌트 계층 구조에서 직접적으로 관려되지 않은 컴포넌트 간의 통신을 가능하게 합니다. 이를 통해 컴포넌트가 서로의 구현 세부 정보를 알 필요 없이 통신할 수 있는 느슨한 결합을 가능하게 합니다.\n\n사용법: 컴포넌트는 `CustomEvent` 생성자나 `dispatchEvent` 메서드를 사용하여 이벤트를 발송합니다. 다른 컴포넌트는 이러한 이벤트를 템플릿 안의 이벤트 핸들러를 통해 처리할 수 있습니다.\n\n예시:\n\n```js\n// 커스텀 이벤트 발송\nthis.dispatchEvent(new CustomEvent('customEventName', { detail: eventData }));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n장점:\n\n- 컴포넌트를 분리함으로써 재사용성이 높아지고 모듈화가 용이해집니다.\n- 계층적 관계와 무관하게 컴포넌트 간의 통신이 가능합니다.\n\n단점:\n\n- 다른 방법에 비해 추가 설정과 오버헤드가 필요합니다.\n- 특히 초보자에게는 구현과 이해가 더 복잡할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 공개 속성:\n\n목적: 공개 속성은 컴포넌트에서 노출되는 속성으로, 다른 컴포넌트가 설정하거나 액세스할 수 있습니다. 부모-자식 간 통신을 가능하게 해 부모 컴포넌트가 데이터나 구성을 자식 컴포넌트에 전달할 수 있게 합니다.\n\n사용법: 공개 속성은 자식 컴포넌트에서 `@api` 데코레이터로 표시됩니다. 부모 컴포넌트는 자식 컴포넌트를 인스턴스화할 때 이러한 속성의 값을 설정합니다.\n\n예제:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```html\n// 자식 컴포넌트\nimport { LightningElement, api } from 'lwc';\nexport default class ChildComponent extends LightningElement {\n    @api message;\n}\n```\n\n장점:\n\n- 구현하기 간단하고 직관적입니다.\n- 부모 및 자식 컴포넌트간의 통신을 용이하게합니다.\n\n단점:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 더 복잡한 통신 시나리오에는 사용할 수 없는 부모-자식 관계로 제한됩니다.\n- 컴포넌트 내부를 부모 컴포넌트에 노출하여 긴밀한 결합을 유발할 수 있습니다.\n\n## 3. 메서드:\n\n목적: 메서드를 사용하면 다른 컴포넌트에서 호출할 수 있는 기능을 노출시킬 수 있습니다. 부모-자식 및 자식-부모 간 통신을 가능하게 하여 컴포넌트가 상호작용하고 협업할 수 있습니다.\n\n사용법: 메서드는 컴포넌트의 JavaScript 클래스에서 정의되며 다른 컴포넌트에서 메서드 호출을 통해 호출될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n```js\n// 하위 컴포넌트\nimport { LightningElement } from 'lwc';\nexport default class ChildComponent extends LightningElement {\n    handleClick() {\n        // 클릭 로직 처리\n    }\n}\n```\n\n장점:\n\n- 컴포넌트가 서로 기능을 호출하여 상호작용하고 협업하는 방법을 제공합니다.\n- 부모에서 자식으로, 그리고 자식에서 부모로 통신을 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단점:\n\n- 상호 참조를 가진 구성 요소에 제한되어 더 자유롭게 결합된 시나리오에는 사용이 제한될 수 있습니다.\n- 과도하게 사용되거나 잘못 사용될 경우 강력한 결합을 초래할 수 있습니다.\n\n요약하면, 구성 요소 이벤트, 공용 속성 및 메서드는 모두 라이트닝 웹 컴포넌트 간의 통신을 촉진하는 데 유용한 도구입니다. 어떤 방법을 사용할지 선택하는 것은 통신 시나리오의 특정 요구 사항, 관련된 구성 요소 간의 관계 및 원하는 캡슐화 및 결합 수준에 따라 달라집니다.\n\n## 인터뷰어: LWC에서 라이프사이클 훅의 개념을 설명해주세요. 사용 가능한 여러 라이프사이클 훅은 무엇이며, 구성 요소 라이프사이클 중에 언제 호출되나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 면접자:\n\n라이트닝 웹 컴포넌트(LWC)에서의 라이프사이클 훅은 컴포넌트의 라이프사이클 중 특정 시점에 자동으로 호출되는 메서드입니다. 이러한 훅을 사용하면 초기화, 렌더링 및 소멸과 같은 컴포넌트의 라이프사이클의 다양한 단계에서 사용자 정의 로직을 실행할 수 있습니다. 라이프사이클 훅을 활용하여 데이터 초기화, 외부 리소스 가져오기 및 컴포넌트가 소멸될 때 리소스 정리와 같은 작업을 수행할 수 있습니다.\n\nLWC의 다양한 라이프사이클 훅:\n\n1. constructor():\n   생성자 함수는 생성자 메서드로서 객체 인스턴스가 생성될 때 호출되는 훅입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 컴포넌트가 생성될 때 호출됩니다.\n- 컴포넌트 속성 및 상태를 초기화하는 데 사용됩니다.\n\n예시:\n\n```js\nconstructor() {\n    super();\n    // 초기화 로직\n}\n```\n\n2. connectedCallback():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DOM에 구성 요소가 삽입될 때 호출됩니다.\n- DOM에 액세스가 필요한 설정 작업을 수행하는 데 사용됩니다.\n\n예:\n```js\nconnectedCallback() {\n    // 설정 작업\n}\n```\n\n3. renderedCallback():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 구성 요소 템플릿 렌더링 후에 호출됩니다.\n- 렌더링된 DOM에 따라 동작을 수행하는 데 사용됩니다.\n\n예시:\n\n```js\nrenderedCallback() {\n    // DOM 조작\n}\n```\n\n4. disconnectedCallback():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DOM에서 구성 요소가 제거될 때 호출됩니다.\n- 리소스 정리 또는 정리 작업을 수행하는 데 사용됩니다.\n\n예시:\n\n```js\ndisconnectedCallback() {\n    // 정리 작업\n}\n```\n\n5. render():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 컴포넌트 템플릿을 렌더링하기 위해 호출됩니다.\n- 컴포넌트 UI의 구조와 내용을 정의하는 데 사용됩니다.\n\n예시:\n\n```js\nrender() {\n    return html`\u003cdiv\u003eHello, World!\u003c/div\u003e`;\n}\n```\n\n6. reconnectedCallback():\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 구성 요소가 제거된 후 DOM에 다시 삽입될 때 호출됩니다.\n- 상태를 재설정하거나 설정 작업을 수행하는 데 사용됩니다.\n\n예시:\n\n```js\nreconnectedCallback() {\n    // 초기화 작업\n}\n```\n\n라이프사이클 훅 호출:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 생성자(Constructor): 컴포넌트가 생성될 때 호출됩니다.\n- 연결된 콜백(Connected Callback): 컴포넌트가 DOM에 삽입될 때 호출됩니다.\n- 렌더링된 콜백(Rendered Callback): 컴포넌트의 템플릿이 렌더링된 후 호출됩니다.\n- 연결 해제된 콜백(Disconnected Callback): 컴포넌트가 DOM에서 제거될 때 호출됩니다.\n- 렌더(Render): 컴포넌트가 템플릿을 렌더링해야 할 때 호출됩니다.\n- 다시 연결된 콜백(Reconnected Callback): 컴포넌트가 제거된 후 다시 DOM에 삽입될 때 호출됩니다.\n\nLWC(Lightning Web Components)에서 제공되는 라이프사이클 훅과 그 호출 순서를 이해함으로써, 개발자들은 컴포넌트 초기화, 렌더링 및 정리 작업을 효과적으로 관리하여 컴포넌트의 라이프사이클 동안 최적의 성능과 동작을 확보할 수 있습니다.\n\n더 궁금한 점이 있다면 아래 링크를 방문해주세요:\n\n희망하건대, 이번 Lightning Web Components (LWC) 인터뷰 시리즈가 LWC 개념에 관한 질문들을 명확히 이해하고 인터뷰에 성공하는 데 도움이 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표 태그를 마크다운 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png"},"coverImage":"/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e(2024)\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-LWCInterviewQuestionsSeries1_0.png\" alt=\"LWC Interview Questions\"\u003e\u003c/p\u003e\n\u003cp\u003e라이트닝 웹 컴포넌트(LWC)는 Salesforce 개발 분야에서 동적이고 반응적인 사용자 인터페이스를 개발하는 강력한 도구입니다. 성능을 향상시키고 개발 프로세스를 더 효율적으로 만들어 주는 능력 덕분에 LWC는 현대 Salesforce 플랫폼 앱의 기본 구성 요소가 되었습니다. 자격 있는 LWC 개발자를 찾는 것은 이 기술을 완벽히 활용할 수 있는 유능한 팀을 구성하기 위해 매우 중요합니다.\u003c/p\u003e\n\u003cp\u003e우리는 이러한 노력을 돕기 위해 개념적 이해와 현실 시나리오에 대한 LWC 인터뷰 문제를 철저하게 수집했습니다. 이러한 질문의 목적은 후보자의 문제 해결 능력, LWC 개발에 대한 전문 지식, 그리고 Salesforce 개발의 최선의 실천 방법의 적용을 평가하는 데 도움을 주는 것입니다. 이제 시작해 보겠습니다!\u003c/p\u003e\n\u003ch2\u003e주의 !\u003c/h2\u003e\n\u003cp\u003eLWC 인터뷰 준비는 압도적인 과제일 수 있습니다. LWC 개념, 최고의 실천 방법 및 실무 경험을 철저히 이해해야 합니다. 여러분의 여정을 돕기 위해 LWC 관련 다양한 주제를 다루는 면접 질문 목록을 엄선했습니다.\u003c/p\u003e\n\u003cp\u003e이 블로그 시리즈에서는 LWC 개발자들이 면접에서 자주 묻는 개념 및 시나리오 기반의 LWC 인터뷰 질문을 모두 다루려고 노력했습니다.\u003c/p\u003e\n\u003ch2\u003e인터뷰 시리즈\u003c/h2\u003e\n\u003cp\u003e번쨰 인터뷰 시리즈를 시작해볼까요? 라이트닝 웹 컴포넌트에 대해 얘기해보려고 해요. 인터뷰어와 인터뷰 대상자 사이에서 진행될거에요.\u003c/p\u003e\n\u003ch1\u003e개념적인 질문들:\u003c/h1\u003e\n\u003ch2\u003e인터뷰어: 라이트닝 웹 컴포넌트(Lightning Web Components, LWC)란 무엇이고, Aura 컴포넌트와 어떻게 다른가요?\u003c/h2\u003e\n\u003ch2\u003e인터뷔 대상자:\u003c/h2\u003e\n\u003cp\u003e번개 웹 컴포넌트(LWC)는 Salesforce 플랫폼에서 번개 컴포넌트를 구축하기 위한 새로운 프로그래밍 모델입니다. 이는 ECMAScript 6와 같은 현대 웹 표준을 활용하여 Aura 컴포넌트와 비교하여 더 나은 성능을 제공합니다. Aura와 달리 LWC는 더 가벼운 프레임워크를 사용하며 웹 개발에 더 간단하고 표준 기반의 접근을 촉진합니다.\u003c/p\u003e\n\u003ch2\u003e주목하세요!\u003c/h2\u003e\n\u003cp\u003e여기서 인터뷰어는 위의 질문을 다른 방식으로도 할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e인터뷰어: LWC와 Aura 컴포넌트의 주요 차이점은 무엇인가요? 아키텍처, 성능 및 개발 경험을 비교해보세요.\u003c/h2\u003e\n\u003cp\u003e인터뷰ee: LWC와 헤일로 컴포넌트 사이의 차이점:\u003c/p\u003e\n\u003ch2\u003e1. 구조:\u003c/h2\u003e\n\u003cp\u003e헤일로 컴포넌트:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e클라이언트 측 JavaScript 프레임워크 및 서버 측 Apex 컨트롤러를 활용하는 Aura 프레임워크에 기반함.\u003c/li\u003e\n\u003cli\u003e마크업, JavaScript 컨트롤러 및 스타일이 하나의 파일 내에 캡슐화된 컴포넌트 기반 구조를 따름.\u003c/li\u003e\n\u003cli\u003e이벤트, 속성 및 메소드를 포함한 컴포넌트 간 통신을 위해 Aura 컴포넌트 모델을 활용함.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLWC (라이트닝 웹 컴포넌트):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eW3C가 지원하는 최신 웹 컴포넌트 표준을 기반으로 한 웹 표준에 맞춰 개발되었습니다.\u003c/li\u003e\n\u003cli\u003e형태, 자바스크립트 및 스타일을 위한 별도의 파일을 사용하여 모듈화 아키텍처를 따르며, 캡슐화를 위해 셰도우 DOM을 준수합니다.\u003c/li\u003e\n\u003cli\u003e컴포넌트 개발을 위해 ECMAScript 모듈과 표준 DOM API를 활용하여, 다른 프레임워크와의 상호 운용성을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e2. 성능:\u003c/h2\u003e\n\u003cp\u003eAura 컴포넌트:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e성능은 프레임워크의 오버헤드와 통신을 위한 Aura 컴포넌트 모델의 사용으로 영향을 받을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e데이터 검색 및 업데이트를 위한 서버 라운드트립은 지연을 유발하고 전체적인 성능에 영향을 줄 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLWC (라이트닝 웹 컴포넌트):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eShadow DOM 및 가상 DOM과 같은 최적화 기술을 사용하여 원시 웹 표준을 사용하므로 성능이 향상됩니다.\u003c/li\u003e\n\u003cli\u003e클라이언트 측 렌더링 및 최소한의 서버 라운드트립은 더 빠른 로딩 시간과 더 나은 응답성에 기여합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e3. 개발 경험:\u003c/h2\u003e\n\u003cp\u003e오로라 컴포넌트:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e개발 경험은 오로라 프레임워크의 학습 곡선과 복잡성에 의해 특징 지어질 수 있습니다.\u003c/li\u003e\n\u003cli\u003e컨트롤러, 헬퍼 및 이벤트와 같은 오로라 특정 개념에 대한 친숙함이 필요합니다.\u003c/li\u003e\n\u003cli\u003e오로라 개발에 대한 도구 지원은 다른 현대 웹 개발 프레임워크와 비교하여 더 제한적일 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLWC (라이트닝 웹 컴포넌트):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eECMAScript 6+ 기능과 표준 웹 API를 지원하여 더 간소화되고 현대적인 개발 경험을 제공합니다.\u003c/li\u003e\n\u003cli\u003eSalesforce CLI 및 VS Code 확장 프로그램과 같은 현대적인 도구를 활용하여 효율적인 개발 워크플로우를 위해 지원합니다.\u003c/li\u003e\n\u003cli\u003e오로라와 비교하여 더 깨끗하고 직관적인 구문을 제공하여 코드의 가독성과 유지 보수성이 향상됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e개요: 전반적으로 LWC는 Aura 구성 요소에서 중요한 발전을 나타내며, Salesforce 플랫폼에서 구성 요소를 구축하기 위해 더 현대적이고 성능 중심적인 접근 방식을 제공합니다. Aura 구성 요소는 계속 지원되지만, LWC는 Salesforce 개발의 미래 방향으로 위치하고 있으며, 개발자들에게 더 효율적이고 확장 가능한 프레임워크를 제공하여 Lightning UI를 구축합니다.\u003c/p\u003e\n\u003ch2\u003e인터뷰어: LWC(Lightning Web Components)에서 데이터 바인딩 개념을 설명해 주세요. 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간의 통신을 어떻게 용이하게 하는가요?\u003c/h2\u003e\n\u003ch2\u003e인터뷉이:\u003c/h2\u003e\n\u003cp\u003e라이트닝 웹 컴포넌트(LWC)에서 데이터 바인딩은 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간의 연결을 설정하는 메커니즘입니다. 이를 통해 두 요소 간에 데이터의 동기화를 가능케 하여 JavaScript 컨트롤러에서 수행한 변경 사항이 HTML 템플릿에 반영되고 그 반대도 성립합니다. 데이터 바인딩은 컴포넌트 내에서 무결한 통신과 상호작용을 용이하게 하며, 데이터나 사용자 입력의 변경에 따라 동적으로 업데이트하고 콘텐츠를 렌더링할 수 있도록 합니다.\u003c/p\u003e\n\u003ch2\u003e데이터 바인딩이 어떻게 통신을 용이하게 하는지:\u003c/h2\u003e\n\u003ch2\u003e1. 속성 바인딩:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e속성 바인딩은 JavaScript 속성을 HTML 템플릿의 요소나 속성에 바인딩하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e중괄호 구문 \u003ccode\u003e''\u003c/code\u003e을 사용하여 HTML 템플릿 내에서 JavaScript 속성을 참조합니다.\u003c/li\u003e\n\u003cli\u003eJavaScript 컨트롤러에서 속성 값이 변경되면 HTML 템플릿의 해당 요소나 속성이 자동으로 새 값으로 업데이트됩니다.\u003c/li\u003e\n\u003cli\u003e마찬가지로 HTML 템플릿의 값이 변경되면 JavaScript 컨트롤러에 다시 반영됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e2. 이벤트 바인딩:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e이벤트 바인딩을 사용하면 DOM 이벤트를 JavaScript 컨트롤러의 메서드나 함수에 바인딩할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eHTML 템플릿에서 이벤트 바인딩을 지정하려면 이벤트 이름 뒤에 \u003ccode\u003eon-\u003c/code\u003e 접두사를 사용합니다.\u003c/li\u003e\n\u003cli\u003e지정된 DOM 이벤트가 트리거될 때, JavaScript 컨트롤러의 연관된 메서드나 함수가 호출됩니다.\u003c/li\u003e\n\u003cli\u003e이를 통해 컴포넌트의 로직 내에서 사용자 상호작용이나 브라우저 이벤트를 처리할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래는 LWC에서 데이터 바인딩을 보여주는 예시입니다:\u003c/p\u003e\n\u003cp\u003eHTML 템플릿 (dataBinding.html):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;!--dataBinding.\u003cspan class=\"hljs-property\"\u003ehtml\u003c/span\u003e--\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003elightning-card\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Input Component Example\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evariant\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"narrow\"\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"slds-p-around_medium\"\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{message}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"slds-m-top_medium\"\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003elightning-input\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"text\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonchange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleChange}\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003elightning-input\u003c/span\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003elightning-card\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJavaScript Controller (dataBinding.js):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//dataBinding.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eLightningElement\u003c/span\u003e,track } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'lwc'\u003c/span\u003e;\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDataBinding\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eLightningElement\u003c/span\u003e {\n  @track message = \u003cspan class=\"hljs-string\"\u003e'Initial message'\u003c/span\u003e;\n \n  \u003cspan class=\"hljs-title function_\"\u003ehandleChange\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e = event.\u003cspan class=\"hljs-property\"\u003etarget\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e이 예제에서:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eHTML 템플릿에서 \u003ccode\u003e'message'\u003c/code\u003e 구문은 속성 바인딩을 나타내며, JavaScript 컨트롤러의 \u003ccode\u003emessage\u003c/code\u003e 속성이 \u003ccode\u003ep\u003c/code\u003e 요소의 내용에 바인딩됩니다.\u003c/li\u003e\n\u003cli\u003e입력 필드의 값이 변경될 때 (\u003ccode\u003eonchange\u003c/code\u003e 이벤트), JavaScript 컨트롤러의 \u003ccode\u003ehandleChange\u003c/code\u003e 메서드가 호출되어 \u003ccode\u003emessage\u003c/code\u003e 속성이 업데이트됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e결과적으로, \u003ccode\u003ep\u003c/code\u003e 요소의 내용이 \u003ccode\u003emessage\u003c/code\u003e 속성의 새 값으로 자동으로 업데이트됩니다.\u003c/p\u003e\n\u003ch2\u003e결과:\u003c/h2\u003e\n\u003cp\u003eLWC에서 데이터 바인딩은 컴포넌트의 JavaScript 컨트롤러와 HTML 템플릿 간에 원활한 통신을 용이하게 합니다. 이를 통해 컴포넌트의 UI 내에서 동적 업데이트와 상호 작용이 가능해집니다.\u003c/p\u003e\n\u003ch2\u003e인터뷰어: 쉐도우 DOM이란 무엇이며, LWC가 어떻게 활용하는가?\u003c/h2\u003e\n\u003ch2\u003e인터뷔이:\u003c/h2\u003e\n\u003cp\u003e쉐도우 DOM(쉐도우 문서 객체 모델)은 웹 컴포넌트의 기본 기능으로, 스타일, 마크업 및 동작을 문서의 나머지 부분과 분리된 범위 내에 캡슐화하는 것을 허용합니다. 이 캡슐화는 스타일 및 스크립트가 누출되지 않고 페이지의 다른 부분과 충돌하지 않도록 방지하여 더 나은 모듈성과 재사용성을 제공합니다.\u003c/p\u003e\n\u003cp\u003e라이트닝 웹 컴포넌츠(LWC)에서는 쉐도우 DOM이 컴포넌트의 마크업과 스타일을 주변 문서와 격리시키는 데 활용됩니다. 이는 컴포넌트 내에서 정의한 스타일이 해당 컴포넌트의 쉐도우 DOM 내 요소에만 적용되도록 함으로써 페이지의 다른 컴포넌트나 요소와의 의도치 않은 스타일 충돌을 방지합니다.\u003c/p\u003e\n\u003ch2\u003e예시:\u003c/h2\u003e\n\u003cp\u003e간단한 LWC 컴포넌트인 helloWorld를 고려해 보겠습니다. 이 컴포넌트는 인사 메시지를 표시합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u0026#x3C;!-- helloWorld.\u003cspan class=\"hljs-property\"\u003ehtml\u003c/span\u003e --\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"container\"\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e{greeting}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// helloWorld.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eLightningElement\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'lwc'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHelloWorld\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eLightningElement\u003c/span\u003e {\n    greeting = \u003cspan class=\"hljs-string\"\u003e'Hello, World!'\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서는:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ehelloWorld\u003c/code\u003e 컴포넌트는 \u003ccode\u003egreeting\u003c/code\u003e 속성의 값을 표시하는 \u003ccode\u003eh1\u003c/code\u003e 제목이 있는 \u003ccode\u003ediv\u003c/code\u003e 컨테이너로 구성됩니다.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egreeting\u003c/code\u003e 속성은 JavaScript 파일에 정의되어 \"Hello, World!\" 값으로 초기화됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e결과:\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ehelloWorld\u003c/code\u003e 컴포넌트가 렌더링되면 라이트닝 웹 컴포넌트 컨텍스트에서 자체 Shadow DOM을 생성합니다. 브라우저에 나타나는 결과물은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;!----shadow-root (open)----\u003e\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"container\"\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003eHello, World!\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u0026#x3C;!----/shadow-root----\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ediv class=”container”\u003c/code\u003e와 \u003ccode\u003eh1\u003c/code\u003e 요소는 \u003ccode\u003ehelloWorld\u003c/code\u003e 컴포넌트의 Shadow DOM 경계 내에 캡슐화됩니다. 이러한 요소에 적용된 스타일은 컴포넌트 내의 요소에만 영향을 미치므로 격리되어 의도치 않은 스타일 충돌을 방지합니다.\u003c/p\u003e\n\u003cp\u003e요약하자면, LWC의 Shadow DOM은 컴포넌트 마크업, 스타일링, 동작을 캡슐화하는 메커니즘을 제공하여 향상된 모듈성, 재사용성, 그리고 컴포넌트 기능의 더 나은 캡슐화를 도모합니다.\u003c/p\u003e\n\u003ch2\u003e면접관: LWC의 맥락에서 명령형과 선언형 프로그래밍을 구별하십시오.\u003c/h2\u003e\n\u003ch2\u003e면접자:\u003c/h2\u003e\n\u003cp\u003e라이트닝 웹 컴포넌트(LWC)의 맥락에서 명령형과 선언형 프로그래밍은 컴포넌트를 구축하고 상호 작용하는 두 가지 다른 방식을 나타냅니다.\u003c/p\u003e\n\u003ch2\u003e명령형 프로그래밍:\u003c/h2\u003e\n\u003cp\u003e명령형 프로그래밍은 작업이 어떻게 수행되어야 하는지를 명시적으로 정의하는 상세한 지시 사항을 지정하는 것을 포함합니다. LWC의 맥락에서 명령형 프로그래밍은 일반적으로 DOM을 직접 조작하거나 외부 리소스와 상호 작용하기 위해 명령형 API 호출을 하는 것을 포함합니다.\u003c/p\u003e\n\u003cp\u003eLWC에서의 명령형 프로그래밍 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eLightningElement\u003c/span\u003e, wire } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'lwc'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { getRecord } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'lightning/uiRecordApi'\u003c/span\u003e;\n \n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImperativeExample\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eLightningElement\u003c/span\u003e {\n    recordId;\n    error;\n \n    @\u003cspan class=\"hljs-title function_\"\u003ewire\u003c/span\u003e(getRecord, { \u003cspan class=\"hljs-attr\"\u003erecordId\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'$recordId'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003efields\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'Account.Name'\u003c/span\u003e] })\n    \u003cspan class=\"hljs-title function_\"\u003ewiredRecord\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ error, data }\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (data) {\n            \u003cspan class=\"hljs-comment\"\u003e// 데이터 처리\u003c/span\u003e\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (error) {\n            \u003cspan class=\"hljs-comment\"\u003e// 오류 처리\u003c/span\u003e\n        }\n    }\n \n    \u003cspan class=\"hljs-title function_\"\u003ehandleClick\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// 레코드 데이터를 로드하기 위한 명령형 호출\u003c/span\u003e\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erecordId\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'001XXXXXXXXXXXXXXX'\u003c/span\u003e;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e선언적 프로그래밍:\u003c/h2\u003e\n\u003cp\u003e반면에 선언적 프로그래밍은 어떻게 해야 하는지 자세히 설명하지 않고 달성해야 할 목표를 지정하는 것을 포함합니다. LWC에서 선언적 프로그래밍은 주로 마크업을 사용하여 구성 요소 동작을 정의하고 프레임워크에서 제공하는 내장 기능 및 기능을 활용하는 것을 포함합니다.\u003c/p\u003e\n\u003cp\u003eLWC에서 선언적 프로그래밍의 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u0026#x3C;!--declarativeExample.\u003cspan class=\"hljs-property\"\u003ehtml\u003c/span\u003e--\u003e\n\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003elightning-card\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Declarative Example\"\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eif:true\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{isDataLoaded}\u003c/span\u003e\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- 데이터에 따른 선언적 렌더링 --\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e{accountName}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eif:true\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{error}\u003c/span\u003e\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-comment\"\u003e\u0026#x3C;!-- 오류에 따른 선언적 렌더링 --\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003eError: {error}\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003elightning-button\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Load Data\"\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonclick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{handleClick}\u003c/span\u003e\u003e\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003elightning-button\u003c/span\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003elightning-card\u003c/span\u003e\u003e\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003etemplate\u003c/span\u003e\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//declarativeExample.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eLightningElement\u003c/span\u003e, wire } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'lwc'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { getRecord } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'lightning/uiRecordApi'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDeclarativeExample\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eLightningElement\u003c/span\u003e {\n    recordId = \u003cspan class=\"hljs-string\"\u003e'001XXXXXXXXXXXXXXX'\u003c/span\u003e;\n    error;\n    accountName;\n    isDataLoaded = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n    @\u003cspan class=\"hljs-title function_\"\u003ewire\u003c/span\u003e(getRecord, { \u003cspan class=\"hljs-attr\"\u003erecordId\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'$recordId'\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003efields\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'Account.Name'\u003c/span\u003e] })\n    \u003cspan class=\"hljs-title function_\"\u003ewiredRecord\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ error, data }\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (data) {\n            \u003cspan class=\"hljs-comment\"\u003e// 데이터를 선언적으로 처리\u003c/span\u003e\n            \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eaccountName\u003c/span\u003e = data.\u003cspan class=\"hljs-property\"\u003efields\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eName\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e;\n            \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eisDataLoaded\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (error) {\n            \u003cspan class=\"hljs-comment\"\u003e// 오류를 선언적으로 처리\u003c/span\u003e\n            \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eerror\u003c/span\u003e = error.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e;\n        }\n    }\n\n    \u003cspan class=\"hljs-title function_\"\u003ehandleClick\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// 레코드 데이터 로드를 선언적으로 트리거\u003c/span\u003e\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erecordId\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'001XXXXXXXXXXXXXXX'\u003c/span\u003e;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래는 예시입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eaccountName\u003c/code\u003e과 \u003ccode\u003eisDataLoaded\u003c/code\u003e는 컴포넌트 속성으로 초기화됩니다.\u003c/li\u003e\n\u003cli\u003erecordId는 JavaScript 클래스의 속성 \u003ccode\u003erecordId\u003c/code\u003e에 직접 할당됩니다. 이로써 \u003ccode\u003ehandleClick()\u003c/code\u003e 내에서 \u003ccode\u003ethis.recordId = ‘001XXXXXXXXXXXXXXX’;\u003c/code\u003e를 호출할 필요가 없어집니다.\u003c/li\u003e\n\u003cli\u003e컴포넌트가 로드될 때, 와이어 어댑터를 사용하여 자동으로 계정 레코드의 이름을 불러옵니다.\u003c/li\u003e\n\u003cli\u003e버튼 클릭 이벤트가 레코드 데이터 로드를 트리거하지만, 정적 recordId를 사용하기 때문에 시각적으로 변화는 없습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e출력:\u003c/p\u003e\n\u003cp\u003e차이점:\u003c/p\u003e\n\u003cp\u003eLWC에서 명령형과 선언적 프로그래밍의 주요 차이점은 구성 요소 동작이 어떻게 정의되고 구현되는지에 있습니다:\u003c/p\u003e\n\u003ch2\u003e1. 명령형 프로그래밍:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e작업을 수행하는 방법에 명확한 지시사항을 지정하는 것을 포함합니다.\u003c/li\u003e\n\u003cli\u003e주로 DOM을 직접 조작하거나 명령형 API 호출을 하는 것을 포함합니다.\u003c/li\u003e\n\u003cli\u003e더 많은 제어와 유연성을 제공하지만 길고 가독성이 떨어지는 코드로 이어질 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e2. 선언형 프로그래밍:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e어떻게 해야 하는지를 명시하지 않고 무엇을 달성해야 하는지를 정의하는 것을 포함합니다.\u003c/li\u003e\n\u003cli\u003e종종 마크업을 사용하여 구성 요소 동작을 정의하고 프레임워크에서 제공하는 내장 기능을 활용하는 것을 포함합니다.\u003c/li\u003e\n\u003cli\u003e구성 요소 동작을 정의하는 더 간결하고 표현력이 있는 방식을 제공하여 더 깨끗하고 유지보수가 쉬운 코드를 만들어줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLWC 개발에서 명령형 및 선언형 프로그래밍 패러다임은 각각의 장소를 가지고 있으며, 개발자는 종종 구성 요소의 특정 요구사항과 복잡성에 가장 적합한 방법을 선택합니다.\u003c/p\u003e\n\u003ch2\u003e인터뷰어: LWC는 구성 요소 간 통신을 어떻게 용이하게 해주나요?\u003c/h2\u003e\n\u003ch2\u003e면접자:\u003c/h2\u003e\n\u003cp\u003eLWC는 구성 요소 통신을 위한 여러 메커니즘을 제공합니다. 속성 전달, 이벤트 처리 및 pub-sub 패턴을 포함합니다. 구성 요소는 속성과 속성을 통해 데이터를 교환하거나 이벤트를 발행하고 처리하거나 라이트닝 메시지 서비스나 플랫폼 이벤트를 사용하여 사용자 정의 이벤트에 가입함으로써 데이터를 교환할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e주의!\u003c/h2\u003e\n\u003cp\u003e여기서 인터뷰관은 위의 질문들을 다른 방식으로도 할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e면접관: 라이트닝 웹 컴포넌트 간 통신하는 다양한 방법은 무엇인가요? 컴포넌트 이벤트, 공개 속성, 그리고 메소드의 사용법에 대해 비교하고 대조해보세요.\u003c/h2\u003e\n\u003ch2\u003e면접자:\u003c/h2\u003e\n\u003cp\u003e라이트닝 웹 컴포넌트(LWC)에서는 컴포넌트 간 통신을 위한 여러 방법이 있으며, 각각의 사용 사례와 장단점을 갖고 있습니다. 주요 방법으로는 컴포넌트 이벤트, 공개 속성, 그리고 메소드가 포함됩니다. 이러한 접근 방식을 비교하고 대조해보겠습니다:\u003c/p\u003e\n\u003ch2\u003e1. 컴포넌트 이벤트:\u003c/h2\u003e\n\u003cp\u003e목적: 컴포넌트 이벤트는 컴포넌트 계층 구조에서 직접적으로 관려되지 않은 컴포넌트 간의 통신을 가능하게 합니다. 이를 통해 컴포넌트가 서로의 구현 세부 정보를 알 필요 없이 통신할 수 있는 느슨한 결합을 가능하게 합니다.\u003c/p\u003e\n\u003cp\u003e사용법: 컴포넌트는 \u003ccode\u003eCustomEvent\u003c/code\u003e 생성자나 \u003ccode\u003edispatchEvent\u003c/code\u003e 메서드를 사용하여 이벤트를 발송합니다. 다른 컴포넌트는 이러한 이벤트를 템플릿 안의 이벤트 핸들러를 통해 처리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 커스텀 이벤트 발송\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edispatchEvent\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCustomEvent\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'customEventName'\u003c/span\u003e, { \u003cspan class=\"hljs-attr\"\u003edetail\u003c/span\u003e: eventData }));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e컴포넌트를 분리함으로써 재사용성이 높아지고 모듈화가 용이해집니다.\u003c/li\u003e\n\u003cli\u003e계층적 관계와 무관하게 컴포넌트 간의 통신이 가능합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e다른 방법에 비해 추가 설정과 오버헤드가 필요합니다.\u003c/li\u003e\n\u003cli\u003e특히 초보자에게는 구현과 이해가 더 복잡할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e2. 공개 속성:\u003c/h2\u003e\n\u003cp\u003e목적: 공개 속성은 컴포넌트에서 노출되는 속성으로, 다른 컴포넌트가 설정하거나 액세스할 수 있습니다. 부모-자식 간 통신을 가능하게 해 부모 컴포넌트가 데이터나 구성을 자식 컴포넌트에 전달할 수 있게 합니다.\u003c/p\u003e\n\u003cp\u003e사용법: 공개 속성은 자식 컴포넌트에서 \u003ccode\u003e@api\u003c/code\u003e 데코레이터로 표시됩니다. 부모 컴포넌트는 자식 컴포넌트를 인스턴스화할 때 이러한 속성의 값을 설정합니다.\u003c/p\u003e\n\u003cp\u003e예제:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-html\"\u003e// 자식 컴포넌트\nimport { LightningElement, api } from 'lwc';\nexport default class ChildComponent extends LightningElement {\n    @api message;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e구현하기 간단하고 직관적입니다.\u003c/li\u003e\n\u003cli\u003e부모 및 자식 컴포넌트간의 통신을 용이하게합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e더 복잡한 통신 시나리오에는 사용할 수 없는 부모-자식 관계로 제한됩니다.\u003c/li\u003e\n\u003cli\u003e컴포넌트 내부를 부모 컴포넌트에 노출하여 긴밀한 결합을 유발할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e3. 메서드:\u003c/h2\u003e\n\u003cp\u003e목적: 메서드를 사용하면 다른 컴포넌트에서 호출할 수 있는 기능을 노출시킬 수 있습니다. 부모-자식 및 자식-부모 간 통신을 가능하게 하여 컴포넌트가 상호작용하고 협업할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e사용법: 메서드는 컴포넌트의 JavaScript 클래스에서 정의되며 다른 컴포넌트에서 메서드 호출을 통해 호출될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 하위 컴포넌트\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eLightningElement\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'lwc'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChildComponent\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eLightningElement\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003ehandleClick\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// 클릭 로직 처리\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e컴포넌트가 서로 기능을 호출하여 상호작용하고 협업하는 방법을 제공합니다.\u003c/li\u003e\n\u003cli\u003e부모에서 자식으로, 그리고 자식에서 부모로 통신을 지원합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e상호 참조를 가진 구성 요소에 제한되어 더 자유롭게 결합된 시나리오에는 사용이 제한될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e과도하게 사용되거나 잘못 사용될 경우 강력한 결합을 초래할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e요약하면, 구성 요소 이벤트, 공용 속성 및 메서드는 모두 라이트닝 웹 컴포넌트 간의 통신을 촉진하는 데 유용한 도구입니다. 어떤 방법을 사용할지 선택하는 것은 통신 시나리오의 특정 요구 사항, 관련된 구성 요소 간의 관계 및 원하는 캡슐화 및 결합 수준에 따라 달라집니다.\u003c/p\u003e\n\u003ch2\u003e인터뷰어: LWC에서 라이프사이클 훅의 개념을 설명해주세요. 사용 가능한 여러 라이프사이클 훅은 무엇이며, 구성 요소 라이프사이클 중에 언제 호출되나요?\u003c/h2\u003e\n\u003ch2\u003e면접자:\u003c/h2\u003e\n\u003cp\u003e라이트닝 웹 컴포넌트(LWC)에서의 라이프사이클 훅은 컴포넌트의 라이프사이클 중 특정 시점에 자동으로 호출되는 메서드입니다. 이러한 훅을 사용하면 초기화, 렌더링 및 소멸과 같은 컴포넌트의 라이프사이클의 다양한 단계에서 사용자 정의 로직을 실행할 수 있습니다. 라이프사이클 훅을 활용하여 데이터 초기화, 외부 리소스 가져오기 및 컴포넌트가 소멸될 때 리소스 정리와 같은 작업을 수행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eLWC의 다양한 라이프사이클 훅:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003econstructor():\n생성자 함수는 생성자 메서드로서 객체 인스턴스가 생성될 때 호출되는 훅입니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e컴포넌트가 생성될 때 호출됩니다.\u003c/li\u003e\n\u003cli\u003e컴포넌트 속성 및 상태를 초기화하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e();\n    \u003cspan class=\"hljs-comment\"\u003e// 초기화 로직\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003econnectedCallback():\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eDOM에 구성 요소가 삽입될 때 호출됩니다.\u003c/li\u003e\n\u003cli\u003eDOM에 액세스가 필요한 설정 작업을 수행하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003econnectedCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 설정 작업\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003erenderedCallback():\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e구성 요소 템플릿 렌더링 후에 호출됩니다.\u003c/li\u003e\n\u003cli\u003e렌더링된 DOM에 따라 동작을 수행하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003erenderedCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// DOM 조작\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003edisconnectedCallback():\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003eDOM에서 구성 요소가 제거될 때 호출됩니다.\u003c/li\u003e\n\u003cli\u003e리소스 정리 또는 정리 작업을 수행하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003edisconnectedCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 정리 작업\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003erender():\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e컴포넌트 템플릿을 렌더링하기 위해 호출됩니다.\u003c/li\u003e\n\u003cli\u003e컴포넌트 UI의 구조와 내용을 정의하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e html`\u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003eHello, World!\u003cspan class=\"hljs-tag\"\u003e\u0026#x3C;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u003e\u003c/span\u003e`\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003ereconnectedCallback():\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e구성 요소가 제거된 후 DOM에 다시 삽입될 때 호출됩니다.\u003c/li\u003e\n\u003cli\u003e상태를 재설정하거나 설정 작업을 수행하는 데 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003ereconnectedCallback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 초기화 작업\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e라이프사이클 훅 호출:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e생성자(Constructor): 컴포넌트가 생성될 때 호출됩니다.\u003c/li\u003e\n\u003cli\u003e연결된 콜백(Connected Callback): 컴포넌트가 DOM에 삽입될 때 호출됩니다.\u003c/li\u003e\n\u003cli\u003e렌더링된 콜백(Rendered Callback): 컴포넌트의 템플릿이 렌더링된 후 호출됩니다.\u003c/li\u003e\n\u003cli\u003e연결 해제된 콜백(Disconnected Callback): 컴포넌트가 DOM에서 제거될 때 호출됩니다.\u003c/li\u003e\n\u003cli\u003e렌더(Render): 컴포넌트가 템플릿을 렌더링해야 할 때 호출됩니다.\u003c/li\u003e\n\u003cli\u003e다시 연결된 콜백(Reconnected Callback): 컴포넌트가 제거된 후 다시 DOM에 삽입될 때 호출됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLWC(Lightning Web Components)에서 제공되는 라이프사이클 훅과 그 호출 순서를 이해함으로써, 개발자들은 컴포넌트 초기화, 렌더링 및 정리 작업을 효과적으로 관리하여 컴포넌트의 라이프사이클 동안 최적의 성능과 동작을 확보할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e더 궁금한 점이 있다면 아래 링크를 방문해주세요:\u003c/p\u003e\n\u003cp\u003e희망하건대, 이번 Lightning Web Components (LWC) 인터뷰 시리즈가 LWC 개념에 관한 질문들을 명확히 이해하고 인터뷰에 성공하는 데 도움이 될 것입니다.\u003c/p\u003e\n\u003cp\u003e표 태그를 마크다운 형식으로 변경해주세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-LWCInterviewQuestionsSeries1"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>