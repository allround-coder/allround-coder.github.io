<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>거북이와 토끼의 이야기 승리의 비결은 무엇일까 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-thetaleoftortoiseandhare" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="거북이와 토끼의 이야기 승리의 비결은 무엇일까 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="거북이와 토끼의 이야기 승리의 비결은 무엇일까 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-thetaleoftortoiseandhare" data-gatsby-head="true"/><meta name="twitter:title" content="거북이와 토끼의 이야기 승리의 비결은 무엇일까 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 02:02" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">거북이와 토끼의 이야기 승리의 비결은 무엇일까</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="거북이와 토끼의 이야기 승리의 비결은 무엇일까" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-thetaleoftortoiseandhare&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>소개</h1>
<p>거북이와 토끼 알고리즘 또는 플로이드의 순환 감지 알고리즘은 연결 리스트의 경우에 매우 일반적으로 사용되는 알고리즘입니다. 이는 기초 역학 법칙과 직관에 기반을 둔 것입니다. 본문은 본 알고리즘에 대해 간단히 설명하고, 이 마법 같은 알고리즘에 대해 모두에게 알려주려고 합니다.</p>
<h1>직관</h1>
<p>우리에게 루프가 있는 연결 리스트가 있다고 가정해 봅시다. 만약 여러분이 연결 리스트의 루프가 무엇인지 모르는 경우, 마지막 노드가 리스트의 중간 노드를 자신의 노드로 가지고 있는 경우를 의미합니다.</p>
<div class="content-ad"></div>
<p>이건 무한 루프를 만들어버리네요!!!</p>
<p><img src="/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png" alt="image"></p>
<p>하지만 어떻게 해결할 수 있을까요?</p>
<p>한 순간 동안 이 문제를 내버려두고 다른 영역으로 들어가볼까요?</p>
<div class="content-ad"></div>
<p>고속과 저속(토끼와 거북이) 두 개의 포인터를 만들어서 거북이와 토끼를 반영하겠습니다. 빠른 포인터는 2의 속도(반복당 두 노드)로 이동하고, 느린 포인터는 1의 속도(반복당 한 노드)로 이동합니다. 두 포인터가 만난다면 이는 반복이 있음을 의미합니다.</p>
<p>하지만 이 두 포인터가 어떻게 만나게 되는지 아십니까?</p>
<div class="content-ad"></div>
<h1>수학적 증명</h1>
<p>알고리즘이 왜 동작하는지 자세히 살펴보겠습니다.</p>
<p>지금 우리는 느린 포인터와 빠른 포인터가 서로 다른 시간에 루프에 들어간다는 것을 알고 있습니다. 느린 포인터는 속도가 1이므로 각 반복에서 링크를 한 번씩만 건너뜁니다. 빠른 포인터는 속도가 2입니다. 따라서 매 반복마다 빠른 포인터는 1단계씩 느린 포인터에 접근하게 되고, 루프에 들어갈 때 느린 포인터와 빠른 포인터 사이의 거리는 항상 1로 나눌 수 있으므로, 빠른 포인터는 한 번의 루프 이내에 느린 포인터를 잡아내게 됩니다.</p>
<p>또 다른 방식으로 생각해 보실 수도 있습니다. 느린 포인터가 한 위치에 갇혀 있고 전체 링크드 리스트가 속도 1로 움직인다고 상상해 보십시오. 이것은 빠른 포인터가 느린 포인터에 대해 매 반복에서 노드 1개씩만 움직인다는 것을 의미합니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-22-thetaleoftortoiseandhare_2.png" alt="이미지 1"></p>
<p><img src="/assets/img/2024-06-22-thetaleoftortoiseandhare_3.png" alt="이미지 2"></p>
<p>빠른 속도와 느린 속도 사이의 거리와 시작 위치와는 관계없이 루프가 있다면 결국 만날 것을 증명했습니다.</p>
<h1>코드</h1>
<div class="content-ad"></div>
<p>내감으로 코드를 작성해볼까요?</p>
<p>우선, 노드를 만들어봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name = <span class="hljs-literal">null</span></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">val</span> = name;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;
    }
}
</code></pre>
<p>그런 다음 두 개의 포인터를 생성하고, 이를 헤드를 가리키도록 할 것입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> isLoop = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) {
    <span class="hljs-keyword">let</span> slow = head;
    <span class="hljs-keyword">let</span> fast = head;
}
</code></pre>
<p>제거 사례 설정 중입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> isLoop = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) {
    <span class="hljs-keyword">let</span> slow = head;
    <span class="hljs-keyword">let</span> fast = head;
    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &#x26;&#x26; fast.<span class="hljs-property">next</span> != <span class="hljs-literal">null</span>) {

    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}
</code></pre>
<p>포인터를 이동합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> isLoop = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) {
    <span class="hljs-keyword">let</span> slow = head;
    <span class="hljs-keyword">let</span> fast = head;
    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &#x26;&#x26; fast.<span class="hljs-property">next</span> != <span class="hljs-literal">null</span>) {
        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;
        slow = slow.<span class="hljs-property">next</span>;
        <span class="hljs-keyword">if</span> (fast == slow) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
</code></pre>
<p>이제 우리의 코드가 완성되었어요. 우리는 드디어 루프를 감지할 수 있는 코드를 작성했어요.</p>
<p>그게 다일까요? 이 알고리즘의 유일한 용도인가요?</p>
<h1>사용 사례</h1>
<div class="content-ad"></div>
<p>이 알고리즘의 주요 사용 사례 중 하나가 사이클 탐지인데, 단순히 그것만이 아닙니다. 다른 사용 사례를 살펴봅시다.</p>
<p>연결 리스트의 중간을 찾아 봅시다. 우연히도 이를 수행하는 최적 알고리즘은 토끼와 거북이 알고리즘입니다.</p>
<p>두 대의 차량이 있는 트랙이 있다고 가정해 봅시다. 차량 1은 차량 2의 반 속도입니다. 따라서 차량 2가 트랙 끝에 도달할 때, 차량 1은 트랙의 중간에 있을 것입니다. 이것이 우리의 직관입니다.</p>
<p>이를 코딩해 봅시다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">// 코드 함수 변환</span>
<span class="hljs-keyword">var</span> mid = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) {
    <span class="hljs-keyword">let</span> slow = head;
    <span class="hljs-keyword">let</span> fast = head;
    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> || fast.<span class="hljs-property">next</span> != <span class="hljs-literal">null</span>) {
        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;
        slow = slow.<span class="hljs-property">next</span>;
    }
    <span class="hljs-keyword">return</span> slow;
}
</code></pre>
<p>다른 예제 사용 사례로는 연결 리스트의 중간 노드를 삭제하는 것이 있습니다.</p>
<p>이전 솔루션을 이 질문에 구현하려고 하면 문제가 발생합니다. 만약 중간 노드를 삭제해야 한다면, 우리는 slow가 중간 노드 직전 노드에서 멈추길 원합니다. 어떻게 할 수 있을까요?</p>
<p>한 가지 분명한 해결책은 slow 포인터보다 한 단계 이전인 이전 포인터를 사용하는 것일 수 있고, 실제로 이것은 좋은 해결책입니다. 그러나 더 나은 해결책은 fast 포인터에 앞서 시작하는 기회를 주는 것입니다. 이렇게 하면 slow가 이전 알고리즘보다 한 단계 더 적게 이동합니다. 그러므로 우리는 해결책을 찾았습니다.</p>
<div class="content-ad"></div>
<p>솔루션을 코드로 작성해 보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">var</span> midRemover = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) {
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.<span class="hljs-property">next</span> == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> head;
    }
    <span class="hljs-keyword">let</span> slow = head;
    <span class="hljs-keyword">let</span> fast = head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;
    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &#x26;&#x26; fast.<span class="hljs-property">next</span> != <span class="hljs-literal">null</span>) {
        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;
        slow = slow.<span class="hljs-property">next</span>;
    }
    slow.<span class="hljs-property">next</span> = slow.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;
    <span class="hljs-keyword">return</span> head;
}
</code></pre>
<p>그래서 Linked Lists의 경우 거북이와 토끼 알고리즘은 매우 유용하지만, 시간 복잡도와 공간 복잡도는 어떨까요?</p>
<h1>시간 복잡도</h1>
<div class="content-ad"></div>
<p>이 알고리즘의 시간 복잡도를 찾아 봅시다. 머리와 루프의 시작 사이에 거리 x가 있다고 가정하고, 루프의 길이가 y이라고 합시다. slow가 루프의 시작점에 도달할 때, 걸린 반복 횟수는 x일 것입니다. 또한, fast 포인터가 slow가 루프의 시작점에 도달할 때 어디에 있든, fast가 slow에 도달하는 데 걸릴 수 있는 최대 반복 횟수는 y입니다. 왜냐하면 두 지점 사이의 최대 가능한 거리는 y-1이기 때문에, 거리는 1단위로 감소하므로 fast가 slow에 도달하는 데 걸리는 최대 시간은 y-1이지만 우리는 y로 근사합니다.</p>
<p>따라서 알고리즘의 시간 복잡도는 O(N)입니다.</p>
<h1>공간 복잡도</h1>
<p>이 알고리즘은 두 개의 포인터만 사용합니다. 따라서 링크드 리스트의 크기가 변경되더라도 알고리즘에 사용되는 추가 공간은 변하지 않습니다.</p>
<div class="content-ad"></div>
<p>이 알고리즘에 사용된 추가 공간은 O(1)입니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"거북이와 토끼의 이야기 승리의 비결은 무엇일까","description":"","date":"2024-06-22 02:02","slug":"2024-06-22-thetaleoftortoiseandhare","content":"\n\n# 소개\n\n거북이와 토끼 알고리즘 또는 플로이드의 순환 감지 알고리즘은 연결 리스트의 경우에 매우 일반적으로 사용되는 알고리즘입니다. 이는 기초 역학 법칙과 직관에 기반을 둔 것입니다. 본문은 본 알고리즘에 대해 간단히 설명하고, 이 마법 같은 알고리즘에 대해 모두에게 알려주려고 합니다.\n\n# 직관\n\n우리에게 루프가 있는 연결 리스트가 있다고 가정해 봅시다. 만약 여러분이 연결 리스트의 루프가 무엇인지 모르는 경우, 마지막 노드가 리스트의 중간 노드를 자신의 노드로 가지고 있는 경우를 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이건 무한 루프를 만들어버리네요!!!\n\n![image](/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png)\n\n하지만 어떻게 해결할 수 있을까요?\n\n한 순간 동안 이 문제를 내버려두고 다른 영역으로 들어가볼까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n고속과 저속(토끼와 거북이) 두 개의 포인터를 만들어서 거북이와 토끼를 반영하겠습니다. 빠른 포인터는 2의 속도(반복당 두 노드)로 이동하고, 느린 포인터는 1의 속도(반복당 한 노드)로 이동합니다. 두 포인터가 만난다면 이는 반복이 있음을 의미합니다.\n\n하지만 이 두 포인터가 어떻게 만나게 되는지 아십니까?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 수학적 증명\n\n알고리즘이 왜 동작하는지 자세히 살펴보겠습니다.\n\n지금 우리는 느린 포인터와 빠른 포인터가 서로 다른 시간에 루프에 들어간다는 것을 알고 있습니다. 느린 포인터는 속도가 1이므로 각 반복에서 링크를 한 번씩만 건너뜁니다. 빠른 포인터는 속도가 2입니다. 따라서 매 반복마다 빠른 포인터는 1단계씩 느린 포인터에 접근하게 되고, 루프에 들어갈 때 느린 포인터와 빠른 포인터 사이의 거리는 항상 1로 나눌 수 있으므로, 빠른 포인터는 한 번의 루프 이내에 느린 포인터를 잡아내게 됩니다.\n\n또 다른 방식으로 생각해 보실 수도 있습니다. 느린 포인터가 한 위치에 갇혀 있고 전체 링크드 리스트가 속도 1로 움직인다고 상상해 보십시오. 이것은 빠른 포인터가 느린 포인터에 대해 매 반복에서 노드 1개씩만 움직인다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지 1](/assets/img/2024-06-22-thetaleoftortoiseandhare_2.png)\n\n![이미지 2](/assets/img/2024-06-22-thetaleoftortoiseandhare_3.png)\n\n빠른 속도와 느린 속도 사이의 거리와 시작 위치와는 관계없이 루프가 있다면 결국 만날 것을 증명했습니다.\n\n# 코드\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내감으로 코드를 작성해볼까요?\n\n우선, 노드를 만들어봅시다.\n\n```js\nclass Node {\n    constructor(name = null) {\n        this.val = name;\n        this.next = null;\n    }\n}\n```\n\n그런 다음 두 개의 포인터를 생성하고, 이를 헤드를 가리키도록 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar isLoop = function(head) {\n    let slow = head;\n    let fast = head;\n}\n```\n\n제거 사례 설정 중입니다.\n\n```js\nvar isLoop = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast != null \u0026\u0026 fast.next != null) {\n\n    }\n    return false\n}\n```\n\n포인터를 이동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar isLoop = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast != null \u0026\u0026 fast.next != null) {\n        fast = fast.next.next;\n        slow = slow.next;\n        if (fast == slow) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n이제 우리의 코드가 완성되었어요. 우리는 드디어 루프를 감지할 수 있는 코드를 작성했어요.\n\n그게 다일까요? 이 알고리즘의 유일한 용도인가요?\n\n# 사용 사례\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 알고리즘의 주요 사용 사례 중 하나가 사이클 탐지인데, 단순히 그것만이 아닙니다. 다른 사용 사례를 살펴봅시다.\n\n연결 리스트의 중간을 찾아 봅시다. 우연히도 이를 수행하는 최적 알고리즘은 토끼와 거북이 알고리즘입니다.\n\n두 대의 차량이 있는 트랙이 있다고 가정해 봅시다. 차량 1은 차량 2의 반 속도입니다. 따라서 차량 2가 트랙 끝에 도달할 때, 차량 1은 트랙의 중간에 있을 것입니다. 이것이 우리의 직관입니다.\n\n이를 코딩해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 코드 함수 변환\nvar mid = function(head) {\n    let slow = head;\n    let fast = head;\n    while (fast != null || fast.next != null) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    return slow;\n}\n```\n\n다른 예제 사용 사례로는 연결 리스트의 중간 노드를 삭제하는 것이 있습니다.\n\n이전 솔루션을 이 질문에 구현하려고 하면 문제가 발생합니다. 만약 중간 노드를 삭제해야 한다면, 우리는 slow가 중간 노드 직전 노드에서 멈추길 원합니다. 어떻게 할 수 있을까요?\n\n한 가지 분명한 해결책은 slow 포인터보다 한 단계 이전인 이전 포인터를 사용하는 것일 수 있고, 실제로 이것은 좋은 해결책입니다. 그러나 더 나은 해결책은 fast 포인터에 앞서 시작하는 기회를 주는 것입니다. 이렇게 하면 slow가 이전 알고리즘보다 한 단계 더 적게 이동합니다. 그러므로 우리는 해결책을 찾았습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔루션을 코드로 작성해 보겠습니다.\n\n```js\nvar midRemover = function(head) {\n    if (head == null || head.next == null) {\n        return head;\n    }\n    let slow = head;\n    let fast = head.next.next;\n    while (fast != null \u0026\u0026 fast.next != null) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    slow.next = slow.next.next;\n    return head;\n}\n```\n\n그래서 Linked Lists의 경우 거북이와 토끼 알고리즘은 매우 유용하지만, 시간 복잡도와 공간 복잡도는 어떨까요?\n\n# 시간 복잡도\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 알고리즘의 시간 복잡도를 찾아 봅시다. 머리와 루프의 시작 사이에 거리 x가 있다고 가정하고, 루프의 길이가 y이라고 합시다. slow가 루프의 시작점에 도달할 때, 걸린 반복 횟수는 x일 것입니다. 또한, fast 포인터가 slow가 루프의 시작점에 도달할 때 어디에 있든, fast가 slow에 도달하는 데 걸릴 수 있는 최대 반복 횟수는 y입니다. 왜냐하면 두 지점 사이의 최대 가능한 거리는 y-1이기 때문에, 거리는 1단위로 감소하므로 fast가 slow에 도달하는 데 걸리는 최대 시간은 y-1이지만 우리는 y로 근사합니다.\n\n따라서 알고리즘의 시간 복잡도는 O(N)입니다.\n\n# 공간 복잡도\n\n이 알고리즘은 두 개의 포인터만 사용합니다. 따라서 링크드 리스트의 크기가 변경되더라도 알고리즘에 사용되는 추가 공간은 변하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 알고리즘에 사용된 추가 공간은 O(1)입니다.","ogImage":{"url":"/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png"},"coverImage":"/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e거북이와 토끼 알고리즘 또는 플로이드의 순환 감지 알고리즘은 연결 리스트의 경우에 매우 일반적으로 사용되는 알고리즘입니다. 이는 기초 역학 법칙과 직관에 기반을 둔 것입니다. 본문은 본 알고리즘에 대해 간단히 설명하고, 이 마법 같은 알고리즘에 대해 모두에게 알려주려고 합니다.\u003c/p\u003e\n\u003ch1\u003e직관\u003c/h1\u003e\n\u003cp\u003e우리에게 루프가 있는 연결 리스트가 있다고 가정해 봅시다. 만약 여러분이 연결 리스트의 루프가 무엇인지 모르는 경우, 마지막 노드가 리스트의 중간 노드를 자신의 노드로 가지고 있는 경우를 의미합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이건 무한 루프를 만들어버리네요!!!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-thetaleoftortoiseandhare_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e하지만 어떻게 해결할 수 있을까요?\u003c/p\u003e\n\u003cp\u003e한 순간 동안 이 문제를 내버려두고 다른 영역으로 들어가볼까요?\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e고속과 저속(토끼와 거북이) 두 개의 포인터를 만들어서 거북이와 토끼를 반영하겠습니다. 빠른 포인터는 2의 속도(반복당 두 노드)로 이동하고, 느린 포인터는 1의 속도(반복당 한 노드)로 이동합니다. 두 포인터가 만난다면 이는 반복이 있음을 의미합니다.\u003c/p\u003e\n\u003cp\u003e하지만 이 두 포인터가 어떻게 만나게 되는지 아십니까?\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e수학적 증명\u003c/h1\u003e\n\u003cp\u003e알고리즘이 왜 동작하는지 자세히 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e지금 우리는 느린 포인터와 빠른 포인터가 서로 다른 시간에 루프에 들어간다는 것을 알고 있습니다. 느린 포인터는 속도가 1이므로 각 반복에서 링크를 한 번씩만 건너뜁니다. 빠른 포인터는 속도가 2입니다. 따라서 매 반복마다 빠른 포인터는 1단계씩 느린 포인터에 접근하게 되고, 루프에 들어갈 때 느린 포인터와 빠른 포인터 사이의 거리는 항상 1로 나눌 수 있으므로, 빠른 포인터는 한 번의 루프 이내에 느린 포인터를 잡아내게 됩니다.\u003c/p\u003e\n\u003cp\u003e또 다른 방식으로 생각해 보실 수도 있습니다. 느린 포인터가 한 위치에 갇혀 있고 전체 링크드 리스트가 속도 1로 움직인다고 상상해 보십시오. 이것은 빠른 포인터가 느린 포인터에 대해 매 반복에서 노드 1개씩만 움직인다는 것을 의미합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-thetaleoftortoiseandhare_2.png\" alt=\"이미지 1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-thetaleoftortoiseandhare_3.png\" alt=\"이미지 2\"\u003e\u003c/p\u003e\n\u003cp\u003e빠른 속도와 느린 속도 사이의 거리와 시작 위치와는 관계없이 루프가 있다면 결국 만날 것을 증명했습니다.\u003c/p\u003e\n\u003ch1\u003e코드\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e내감으로 코드를 작성해볼까요?\u003c/p\u003e\n\u003cp\u003e우선, 노드를 만들어봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNode\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eval\u003c/span\u003e = name;\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 두 개의 포인터를 생성하고, 이를 헤드를 가리키도록 할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e isLoop = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ehead\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e slow = head;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e fast = head;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제거 사례 설정 중입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e isLoop = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ehead\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e slow = head;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e fast = head;\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (fast != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026#x26;\u0026#x26; fast.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e포인터를 이동합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e isLoop = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ehead\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e slow = head;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e fast = head;\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (fast != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026#x26;\u0026#x26; fast.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        fast = fast.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e;\n        slow = slow.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e;\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (fast == slow) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n        }\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 우리의 코드가 완성되었어요. 우리는 드디어 루프를 감지할 수 있는 코드를 작성했어요.\u003c/p\u003e\n\u003cp\u003e그게 다일까요? 이 알고리즘의 유일한 용도인가요?\u003c/p\u003e\n\u003ch1\u003e사용 사례\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 알고리즘의 주요 사용 사례 중 하나가 사이클 탐지인데, 단순히 그것만이 아닙니다. 다른 사용 사례를 살펴봅시다.\u003c/p\u003e\n\u003cp\u003e연결 리스트의 중간을 찾아 봅시다. 우연히도 이를 수행하는 최적 알고리즘은 토끼와 거북이 알고리즘입니다.\u003c/p\u003e\n\u003cp\u003e두 대의 차량이 있는 트랙이 있다고 가정해 봅시다. 차량 1은 차량 2의 반 속도입니다. 따라서 차량 2가 트랙 끝에 도달할 때, 차량 1은 트랙의 중간에 있을 것입니다. 이것이 우리의 직관입니다.\u003c/p\u003e\n\u003cp\u003e이를 코딩해 봅시다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 코드 함수 변환\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e mid = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ehead\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e slow = head;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e fast = head;\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (fast != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e || fast.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        fast = fast.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e;\n        slow = slow.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e slow;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다른 예제 사용 사례로는 연결 리스트의 중간 노드를 삭제하는 것이 있습니다.\u003c/p\u003e\n\u003cp\u003e이전 솔루션을 이 질문에 구현하려고 하면 문제가 발생합니다. 만약 중간 노드를 삭제해야 한다면, 우리는 slow가 중간 노드 직전 노드에서 멈추길 원합니다. 어떻게 할 수 있을까요?\u003c/p\u003e\n\u003cp\u003e한 가지 분명한 해결책은 slow 포인터보다 한 단계 이전인 이전 포인터를 사용하는 것일 수 있고, 실제로 이것은 좋은 해결책입니다. 그러나 더 나은 해결책은 fast 포인터에 앞서 시작하는 기회를 주는 것입니다. 이렇게 하면 slow가 이전 알고리즘보다 한 단계 더 적게 이동합니다. 그러므로 우리는 해결책을 찾았습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e솔루션을 코드로 작성해 보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e midRemover = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ehead\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (head == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e || head.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e head;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e slow = head;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e fast = head.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (fast != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026#x26;\u0026#x26; fast.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n        fast = fast.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e;\n        slow = slow.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e;\n    }\n    slow.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e = slow.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e head;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그래서 Linked Lists의 경우 거북이와 토끼 알고리즘은 매우 유용하지만, 시간 복잡도와 공간 복잡도는 어떨까요?\u003c/p\u003e\n\u003ch1\u003e시간 복잡도\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 알고리즘의 시간 복잡도를 찾아 봅시다. 머리와 루프의 시작 사이에 거리 x가 있다고 가정하고, 루프의 길이가 y이라고 합시다. slow가 루프의 시작점에 도달할 때, 걸린 반복 횟수는 x일 것입니다. 또한, fast 포인터가 slow가 루프의 시작점에 도달할 때 어디에 있든, fast가 slow에 도달하는 데 걸릴 수 있는 최대 반복 횟수는 y입니다. 왜냐하면 두 지점 사이의 최대 가능한 거리는 y-1이기 때문에, 거리는 1단위로 감소하므로 fast가 slow에 도달하는 데 걸리는 최대 시간은 y-1이지만 우리는 y로 근사합니다.\u003c/p\u003e\n\u003cp\u003e따라서 알고리즘의 시간 복잡도는 O(N)입니다.\u003c/p\u003e\n\u003ch1\u003e공간 복잡도\u003c/h1\u003e\n\u003cp\u003e이 알고리즘은 두 개의 포인터만 사용합니다. 따라서 링크드 리스트의 크기가 변경되더라도 알고리즘에 사용되는 추가 공간은 변하지 않습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 알고리즘에 사용된 추가 공간은 O(1)입니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-thetaleoftortoiseandhare"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>