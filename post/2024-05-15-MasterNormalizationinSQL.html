<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SQL에서 정규화 마스터하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-15-MasterNormalizationinSQL" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SQL에서 정규화 마스터하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="SQL에서 정규화 마스터하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-15-MasterNormalizationinSQL_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-15-MasterNormalizationinSQL" data-gatsby-head="true"/><meta name="twitter:title" content="SQL에서 정규화 마스터하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-15-MasterNormalizationinSQL_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-15 11:19" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_buildManifest.js" defer=""></script><script src="/_next/static/837W-BjvPVBgft6aM4api/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SQL에서 정규화 마스터하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SQL에서 정규화 마스터하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 15, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-15-MasterNormalizationinSQL&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p><img src="/assets/img/2024-05-15-MasterNormalizationinSQL_0.png" alt="이미지1"/></p>
<p><img src="/assets/img/2024-05-15-MasterNormalizationinSQL_1.png" alt="이미지2"/></p>
<p>데이터베이스 관리에서 중요한 개념인 정규화는 특히 SQL(구조화된 쿼리 언어)에서 중요합니다. 이는 데이터베이스의 효율성, 무결성 및 확장성을 보장하며, 데이터베이스의 데이터를 중복 없이 정리하고 의존성을 줄이는 프로세스입니다. SQL에서 정규화를 마스터하는 것은 효율적이고 확장 가능하며 유지보수가 용이한 데이터베이스를 생성하는 데 필수적입니다. 이 글에서는 정규화의 원칙과 기술을 자세히 살펴보고, 여러 형태와 효과적인 구현 방법에 대해 다룰 것입니다.</p>
<h1>정규화 이해하기:</h1>
<p>정규화는 데이터를 테이블로 구성할 때 발생하는 중복 및 종속성을 최소화하는 일련의 규칙에 기반하고 있습니다. 이 과정은 일반적으로 큰 테이블을 더 작고 관리하기 쉬운 작은 테이블로 나누고 그들 간의 관계를 정의하는 것을 포함합니다.</p>
<h2>정규화를 사용하는 이유:</h2>
<p><img src="/assets/img/2024-05-15-MasterNormalizationinSQL_2.png" alt="MasterNormalizationinSQL_2"/></p>
<p>정규화를 숙달하기 전에 왜 정규화를 사용하며 정규화의 필요성에 대해 이해해야 합니다. 그래서 &quot;왜 정규화를 배워야 하는지&quot;에 대한 참고 자료를 가질 수 있게 됩니다.</p>
<p>데이터베이스 설계에서 중요한 개념인 정규화는 데이터를 효율적으로 구성하고 데이터 무결성을 유지하는 데 사용됩니다. 여러 가지 중요한 목적을 가지고 있으며, 전반적으로 데이터베이스 시스템의 효과성과 신뢰성에 기여합니다:</p>
<h3>1. 중복 최소화:</h3>
<p>정규화는 큰 테이블을 작고 관리하기 쉬운 작은 테이블로 분해하여 중복 데이터를 제거하는 데 도움을 줍니다. 중복은 데이터베이스의 일관성 및 이상 현상을 유발할 수 있습니다. 데이터를 정규화된 형태로 저장함으로써 각 정보 조각이 한 곳에만 저장되어 일관성 문제의 가능성을 줄입니다.</p>
<h3>2. 업데이트 이상 방지:</h3>
<p>변경된 테이블은 날 위험성을 최소화하고 다른 곳에서 불일치나 오류가 발생하지 않도록 하는 정규화를 통해 발생할 수 있는 갱신 이상 현상을 방지합니다.</p>
<h2>3. 데이터 무결성 향상:</h2>
<p>데이터 무결성은 데이터베이스에 저장된 데이터의 정확성과 일관성을 의미합니다. 정규화는 부정확하거나 일관되지 않은 데이터를 저장하는 것을 방지하기 위한 제약 조건과 규칙을 강제함으로써 데이터 무결성을 향상시킵니다. 예를 들어, 각 열이 원자적(분할할 수 없는) 값만 포함하고 테이블 간의 관계가 올바르게 정의되도록 보장합니다.</p>
<h2>4. 쿼리 성능 향상:</h2>
<p>정규화된 데이터베이스는 쿼리에 대해 종종 더 효율적입니다. 데이터를 잘 정의된 관계를 가진 작은 테이블로 구성함으로써 쿼리를 더 빨리 효과적으로 실행할 수 있습니다. 정규화된 테이블은 일반적으로 특정 개체나 개념과 관련된 데이터를 저장하도록 설계되어 각 쿼리에 처리해야 하는 데이터 양을 줄입니다.</p>
<h2>5. 데이터베이스 유지관리를 간단하게:</h2>
<p>정규화된 데이터베이스는 유지 관리 및 업데이트가 시간이 지나서도 더 쉽습니다. 데이터베이스 구조를 수정해야 할 때(예: 새로운 필드나 테이블 추가), 정규화는 변경 사항을 다른 부분에 영향을 미치지 않고 적용할 수 있도록 합니다. 이를 통해 데이터베이스는 변화하는 요구 사항에 빠르게 적응할 수 있고 유지 보수 활동 중 오류 발생 가능성을 줄입니다.</p>
<h2>6. 확장 가능성을 용이하게하는:</h2>
<p>정규화된 데이터베이스는 본질적으로 확장 가능성이 높습니다. 데이터 양이나 데이터베이스의 복잡성이 증가함에 따라 정규화는 성능이나 데이터 무결성을 희생하지 않고 쉽게 확장할 수 있게 합니다. 새로운 테이블을 추가하거나 기존 테이블을 수정하거나 확장하여 새로운 요구 사항을 수용할 수 있습니다. 이렇게 하면 전체 데이터베이스 구조에 중요한 장애가 없이 확장할 수 있습니다.</p>
<h1>정규화 유형</h1>
<p>정규화는 데이터베이스 설계에서 사용되는 과정으로 데이터를 중복과 의존성을 최소화하는 구조화된 테이블로 구성합니다. 각각의 규칙 세트를 갖는 여러 가지 정규 형태가 있습니다. 다양한 유형의 정규화를 살펴보겠습니다:</p>
<h2>1. 제1정규화(1NF):</h2>
<p>1NF에 따르면, 테이블이 정규화되었다고 말할 수 있는 조건은 다음과 같습니다:</p>
<ul>
<li>각 열에는 원자적(분할할 수 없는) 값이 포함되어 있어야 합니다.</li>
<li>열 내에 반복 그룹이나 배열이 없어야 합니다.</li>
<li>테이블의 각 셀에는 하나의 값만 있어야 합니다.</li>
</ul>
<p>예를 들어, 각 셀이 반복 그룹이나 배열과 같은 것이 없이 하나의 값만 포함하고 있는 테이블은 1NF에 속합니다.</p>
<h2>2. 두 번째 정규형 (2NF):</h2>
<p>위의 내용을 친근한 톤으로 한국어로 번역하겠습니다.</p>
<p>표가 2NF에 있다는 것은 다음과 같습니다:</p>
<ul>
<li>1NF에 있습니다.</li>
<li>모든 비-키 속성이 기본 키 전체에 완전히 함수 종속성을 갖습니다.</li>
</ul>
<p>이는 모든 비-키 속성이 기본 키 전체에 의존해야 한다는 것을 의미합니다. 표가 복합 기본 키를 가지는 경우 각 비-키 속성은 복합 키 전체에 의존해야 하며 그 일부만으로는 안 됩니다.</p>
<h2>3. 세 번째 정규형 (3NF):</h2>
<p>3NF에있는 테이블은 다음과 같습니다:</p>
<ul>
<li>2NF에 있습니다.</li>
<li>이러한 종속성이 없습니다.</li>
</ul>
<p>다시 말해, 비 주요 속성은 다른 비 주요 속성에 의존해서는 안됩니다. 이러한 종속성은 별도의 테이블을 생성하여 제거해야 합니다.</p>
<h2>4. Boyce-Codd Normal Form (BCNF):</h2>
<p>BCNF은 3NF의 강력한 형태이며 다음 조건을 만족할 때 달성됩니다:</p>
<ul>
<li>3NF에 있어야 합니다.</li>
<li>모든 비자명 함수 종속인 𝑋→𝑌X→Y에 대해, X가 수퍼키여야 합니다.</li>
</ul>
<p>여기서 수퍼키는 테이블의 각 행을 고유하게 식별하는 속성 세트입니다.</p>
<h2>5. 제4 정규형 (4NF):</h2>
<p>4NF는 다중값 종속성을 해결하여 테이블이 다중값 속성이 없는 것을 보장합니다. 이것은 다중값 종속성을 제거하고 이를 위한 별도의 테이블을 생성함으로써 달성됩니다.</p>
<h2>6. 다섯 번째 정규 형태 (5NF):</h2>
<p>5NF, 또는 Project-Join 정규 형태 (PJ/NF)로도 알려져 있으며 조인 종속성을 다룹니다. 이는 테이블을 분해하여 각 테이블이 단일 주제를 나타내고 중복없이 다른 테이블과 결합될 수 있도록 보장함으로써 달성됩니다.</p>
<h1>주요 여정을 시작해봅시다!</h1>
<p>그래서, 지금까지 우리는 정규화가 무엇인지, 왜 정규화를 하는지, 그리고 정규화의 종류에 대한 기본 아이디어를 알게 되었습니다. 이 기본 지식을 바탕으로 정규화를 더 깊이 이해해볼 수 있게 되었습니다. 이제 메인 여정을 시작해봅시다.</p>
<h1>제1정규형 / 1NF</h1>
<p>제1정규형(1NF)은 정규화의 가장 기본적인 수준이며, 관계형 데이터베이스의 각 테이블이 원자 값만 포함하도록 하는 데 초점을 맞춥니다. 즉, 각 셀이 단일하고 분할할 수 없는 데이터 조각을 보유하도록 하는 것입니다. 이를 통해 열 내에서 반복 그룹이나 배열을 제거할 수 있습니다. 예제를 통해 1NF를 자세히 살펴봅시다:</p>
<p>예제:</p>
<p>학생들과 강의에 관한 정보를 저장하는 표를 생각해보세요. 이 표는 반복 그룹과 비원자적인 값을 포함하여 1NF를 위반합니다:</p>
<p><img src="/assets/img/2024-05-15-MasterNormalizationinSQL_3.png" alt="표"/></p>
<p>예제의 문제점:</p>
<ul>
<li>반복 그룹: &quot;Courses&quot; 열에는 쉼표로 구분된 여러 값을 포함합니다. 이는 1NF의 원자성 규칙을 위반합니다.</li>
<li>비원자적인 값: &quot;Courses&quot; 열의 값은 원자적이지 않으며, 여러 조각의 데이터를 나타냅니다.</li>
</ul>
<p>이 표를 1NF로 바꾸려면 각 행에 원자 값만 포함되도록 여러 행으로 분할해야 합니다.</p>
<h2>1NF에서 재구성된 표:</h2>
<p><img src="/assets/img/2024-05-15-MasterNormalizationinSQL_4.png" alt="Restructured Table in 1NF"/></p>
<p>설명:</p>
<ul>
<li>&quot;Course&quot; column의 각 행은 이제 원자성 규칙을 준수하며 하나의 값만 포함합니다.</li>
<li>반복 그룹이 제거되었고, 각 학생-과정 조합이 별도의 행으로 표시됩니다.</li>
</ul>
<h2>제2 정규형 / 2NF</h2>
<p>제 2 정규형(2NF)은 부분 종속성 문제를 해결함으로써 제 1 정규형(1NF)을 기반으로 합니다. 이는 테이블 내의 모든 비-키 속성이 전체 주 키에 완전히 기능적으로 종속되도록 보장합니다. 예시를 통해 2NF를 자세히 살펴보겠습니다:</p>
<p>예시:</p>
<p>책과 저자 정보를 저장하는 테이블을 고려해보세요. 아래는 테이블이 어떻게 보일지에 대한 예시입니다:</p>
<p><img src="/assets/img/2024-05-15-MasterNormalizationinSQL_5.png" alt="테이블 예시"/></p>
<p>예시의 문제점:</p>
<ul>
<li>테이블은 복합 기본 키(BookID, AuthorID)를 포함하고 있습니다. 여기서 BookID는 책을 고유하게 식별하지만 AuthorID는 저자를 고유하게 식별하지 않습니다.</li>
<li>&quot;AuthorName&quot; 열은 AuthorID에만 종속되어 있으며 전체 기본 키에 종속되지 않습니다.</li>
<li>이 테이블은 2NF를 위반합니다. AuthorName이 기본 키의 일부 (AuthorID)에 함수적으로 종속되어 있기 때문입니다.</li>
</ul>
<h2>2NF에 재구성된 테이블:</h2>
<p>테이블을 2NF로 변경하기 위해 테이블을 두 개로 나눴어요: 책을 위한 하나와 작가를 위한 다른 하나입니다.</p>
<p><img src="/assets/img/2024-05-15-MasterNormalizationinSQL_6.png" alt="테이블"/></p>
<h2>설명:</h2>
<ul>
<li>Books 테이블에서 BookID가 기본 키(primary key)입니다.</li>
<li>Books 테이블의 AuthorID는 현재 Authors 테이블을 참조하는 외래 키(foreign key)입니다.</li>
<li>Authors 테이블에는 AuthorID가 기본 키로 포함되어 있습니다.</li>
<li>Authors 테이블은 각 작가의 이름이 중복으로 저장되지 않도록 보장합니다.</li>
<li>Authors 테이블은 AuthorID에 의해 결정되는 AuthorName이 전체 기본 키에 기능적으로 의존할 수 있습니다.</li>
</ul>
<h2>제 3 정규형 / 3NF</h2>
<p>제 3 정규형(3NF)은 제 1 정규형(1NF)과 제 2 정규형(2NF)의 원칙을 확장하여 이행 종속성(transitive dependencies)을 다룹니다. 이는 비 기본 키(non-key attributes)가 다른 비 기본 키에 의존하지 않고 기본 키에만 의존하도록 보장합니다. 예시를 통해 3NF를 알아보겠습니다:</p>
<p>예시:</p>
<p>직원 및 부서에 관한 정보를 저장하는 테이블을 고려해보세요. 테이블에는 부서 관리자의 전화번호도 포함되어 있습니다.</p>
<p>다음은 이 예시에 관한 문제점입니다:</p>
<ul>
<li>이 테이블에는 이행 종속성이 포함되어 있습니다: ManagerPhone이 기본 키가 아닌 Manager에 종속되어 있습니다.</li>
</ul>
<h2>3NF로 재구성된 테이블:</h2>
<p>테이블을 3NF로 변경하기 위해 이원종속성을 제거해야 합니다. 테이블을 직원, 부서 및 매니저로 세 개의 별도 테이블로 분할할 것입니다.</p>
<p><img src="/assets/img/2024-05-15-MasterNormalizationinSQL_8.png" alt="테이블 이미지"/></p>
<p>설명:</p>
<ul>
<li>사원 테이블은 사원별 정보를 포함하며, 주요 키로 EmployeeID가 사용됩니다.</li>
<li>부서 테이블은 각 부서에 대한 정보를 포함하며, 주요 키로 DepartmentID가 사용됩니다.</li>
<li>매니저 테이블은 각 매니저에 대한 정보를 포함하며, 주요 키로 ManagerID가 사용됩니다.</li>
<li>원본 테이블에서 ManagerPhone은 주키가 아닌 Manager에 종속적입니다. 테이블을 분할하여 이 체이닝 종속성을 제거합니다.</li>
</ul>
<h1>Boyce-Codd 정규형 (BCNF)</h1>
<p>Boyce-Codd 정규형(BCNF)은 제3 정규형(3NF)의 원리를 기반으로 한 더 높은 정규화 수준입니다. BCNF는 특정 유형의 기능적 종속성을 다루어 모든 비자명 기능적 종속성 𝑋→𝑌X→Y에 대해 결정자(X)가 수퍼키임을 보장합니다. 예시를 통해 BCNF를 살펴봅시다:</p>
<p>예시:</p>
<p>다음은 강의와 강사 정보를 저장하는 테이블을 고려해보세요:</p>
<p>Issues with the Example:</p>
<ul>
<li>The table contains a non-trivial functional dependency: 𝐼𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟𝐼𝐷→𝐼𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟𝑁𝑎𝑚𝑒,𝐸𝑚𝑎𝑖𝑙</li>
<li>The InstructorID determines both the InstructorName and Email, but InstructorID is not a superkey since multiple instructors can have the same ID.</li>
</ul>
<h2>BCNF로 재구성된 테이블:</h2>
<p>테이블을 BCNF로 가져오려면 모든 비자명 함수 종속의 결정자가 수퍼키여야 함을 보장해야 합니다. 테이블을 두 개로 분할할 것입니다: Courses와 Instructors.</p>
<p><img src="/assets/img/2024-05-15-MasterNormalizationinSQL_10.png" alt="BCNF 테이블"/></p>
<p>설명:</p>
<ul>
<li>Courses 테이블은 각 과정에 대한 정보를 포함하며 CourseID가 기본 키로 사용됩니다.</li>
<li>Instructors 테이블은 각각의 강사에 대한 정보를 포함하며 InstructorID가 기본 키로 사용됩니다.</li>
<li>원래 테이블은 BCNF를 위반합니다. 이유는 InstructorID가 InstructorName과 Email을 모두 결정하고, InstructorID가 슈퍼키가 아니기 때문입니다. 테이블을 분할함으로써, 모든 비자명 함수 종속성의 결정자가 슈퍼키임을 보장합니다.</li>
</ul>
<h1>제4 정규형 / 4NF</h1>
<p>4차 정규형(4NF)은 다중 값 종속성을 처리하여 제3 정규형(3NF)을 넘어가는 정규화 수준입니다. 데이터베이스 스키마에 비자명 다중 값 종속성이 없는지 확인합니다. 예제를 통해 4NF를 살펴보겠습니다:</p>
<p>예시:</p>
<p>프로젝트 및 해당 프로젝트에 배정된 직원, 그리고 각 직원이 책임지는 작업에 대한 정보를 저장하는 테이블을 고려해보세요:</p>
<p><img src="/assets/img/2024-05-15-MasterNormalizationinSQL_11.png" alt="테이블"/></p>
<p>예제의 문제점:</p>
<ul>
<li>다중 값 종속성이 있습니다. 예를 들어 (프로젝트ID, 직원ID)의 조합이 여러 TaskID와 TaskName 쌍을 결정합니다.</li>
<li>테이블은 비자명 다중 값 종속성을 포함하고 있어 4NF를 위반합니다.</li>
</ul>
<h2>4NF에서 재구성된 테이블:</h2>
<p>테이블을 4NF로 전환하기 위해 다중 값 종속성을 제거하고 별도의 테이블로 분할해야 합니다.</p>
<p><img src="/assets/img/2024-05-15-MasterNormalizationinSQL_12.png" alt="Restructured Table"/></p>
<p>설명:</p>
<ul>
<li>Projects 테이블은 ProjectID를 기본 키로 포함합니다.</li>
<li>Employees 테이블은 EmployeeID를 기본 키로 포함합니다.</li>
<li>Tasks 테이블은 ProjectID와 EmployeeID를 외래 키로 포함하며 TaskID를 기본 키로 포함합니다.</li>
<li>Tasks 테이블의 각 행은 프로젝트에서 직원에게 할당된 단일 작업을 나타냅니다.</li>
<li>원래 테이블을 세 개의 별도 테이블로 분할함으로써 다중 값 종속성을 제거하여 데이터베이스 스키마가 4NF를 준수하도록 합니다.</li>
</ul>
<h1>다섯 번째 정규 형식 / 5NF</h1>
<p>다섯 번째 정규 형식 (5NF), 또는 프로젝트 조인 정규 형식 (PJ/NF)은 조인 종속성을 다루며 데이터베이스 스키마에 조인 이상 현상이 없는 것을 보장합니다. 각 테이블이 단일 주제를 나타내고 중복없이 다른 테이블과 조인될 수 있도록 테이블을 분해하는 것을 포함합니다. 예제로 5NF를 살펴봅시다:</p>
<p>예시:</p>
<p>학생, 강의 및 각 강의에서 학생들이 받은 성적에 대한 정보를 저장하는 표를 고려해 보세요:</p>
<p>| StudentID | StudentName | CourseID | CourseName | Grade |
|-----------|-------------|----------|------------|-------|
| 1         | Alice       | 1        | Math       | A     |
| 2         | Bob         | 1        | Math       | B     |
| 1         | Alice       | 2        | Science    | B     |</p>
<p>예제의 문제점:</p>
<ul>
<li>표에 결합 의존성이 있는데, 특정 속성이 다른 속성들의 조합에 따라 종속되어 있습니다.</li>
<li>예를 들어, CourseName은 CourseID에 의해 결정되며, Grade는 StudentID와 CourseID의 조합에 의해 결정됩니다.</li>
</ul>
<h2>5NF로 재구성된 테이블:</h2>
<p>테이블을 5NF로 가져오기 위해 조인 종속성을 제거하기 위해 여러 개의 테이블로 분해합니다:</p>
<p><img src="/assets/img/2024-05-15-MasterNormalizationinSQL_14.png" alt="테이블 이미지"/></p>
<h2>설명:</h2>
<ul>
<li>학생 테이블은 주요 키로 학생ID와 이름을 포함합니다.</li>
<li>강좌 테이블은 주요 키로 강좌ID와 강좌명을 포함합니다.</li>
<li>성적 테이블은 외래 키로 학생ID와 강좌ID를 포함하며 성적이 있습니다.</li>
<li>원본 테이블을 세 개의 별도 테이블로 분해함으로써 조인 종속성을 제거하여 데이터베이스 스키마가 5NF를 준수하도록 보장합니다.</li>
</ul>
<h1>결론:</h1>
<p>SQL에서 정규화를 숙달하는 것은 효율적이고 확장 가능한 데이터베이스를 설계하는 데 중요합니다. 정규 형태를 이해하고 효과적으로 구현함으로써 데이터 무결성을 보장하고 중복을 줄이며 데이터베이스 관리를 간소화할 수 있습니다. 새 데이터베이스를 설계하거나 기존 데이터베이스를 최적화하는 경우 정규화 원칙은 견고하고 신뢰할 수 있는 데이터 인프라를 유지하는 데 필수적입니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SQL에서 정규화 마스터하기","description":"","date":"2024-05-15 11:19","slug":"2024-05-15-MasterNormalizationinSQL","content":"\n\n\n![이미지1](/assets/img/2024-05-15-MasterNormalizationinSQL_0.png)\n\n![이미지2](/assets/img/2024-05-15-MasterNormalizationinSQL_1.png)\n\n데이터베이스 관리에서 중요한 개념인 정규화는 특히 SQL(구조화된 쿼리 언어)에서 중요합니다. 이는 데이터베이스의 효율성, 무결성 및 확장성을 보장하며, 데이터베이스의 데이터를 중복 없이 정리하고 의존성을 줄이는 프로세스입니다. SQL에서 정규화를 마스터하는 것은 효율적이고 확장 가능하며 유지보수가 용이한 데이터베이스를 생성하는 데 필수적입니다. 이 글에서는 정규화의 원칙과 기술을 자세히 살펴보고, 여러 형태와 효과적인 구현 방법에 대해 다룰 것입니다.\n\n# 정규화 이해하기:\n\n\n\n\n정규화는 데이터를 테이블로 구성할 때 발생하는 중복 및 종속성을 최소화하는 일련의 규칙에 기반하고 있습니다. 이 과정은 일반적으로 큰 테이블을 더 작고 관리하기 쉬운 작은 테이블로 나누고 그들 간의 관계를 정의하는 것을 포함합니다.\n\n## 정규화를 사용하는 이유:\n\n![MasterNormalizationinSQL_2](/assets/img/2024-05-15-MasterNormalizationinSQL_2.png)\n\n정규화를 숙달하기 전에 왜 정규화를 사용하며 정규화의 필요성에 대해 이해해야 합니다. 그래서 \"왜 정규화를 배워야 하는지\"에 대한 참고 자료를 가질 수 있게 됩니다.\n\n\n\n데이터베이스 설계에서 중요한 개념인 정규화는 데이터를 효율적으로 구성하고 데이터 무결성을 유지하는 데 사용됩니다. 여러 가지 중요한 목적을 가지고 있으며, 전반적으로 데이터베이스 시스템의 효과성과 신뢰성에 기여합니다:\n\n### 1. 중복 최소화:\n\n정규화는 큰 테이블을 작고 관리하기 쉬운 작은 테이블로 분해하여 중복 데이터를 제거하는 데 도움을 줍니다. 중복은 데이터베이스의 일관성 및 이상 현상을 유발할 수 있습니다. 데이터를 정규화된 형태로 저장함으로써 각 정보 조각이 한 곳에만 저장되어 일관성 문제의 가능성을 줄입니다.\n\n### 2. 업데이트 이상 방지:\n\n\n\n변경된 테이블은 날 위험성을 최소화하고 다른 곳에서 불일치나 오류가 발생하지 않도록 하는 정규화를 통해 발생할 수 있는 갱신 이상 현상을 방지합니다.\n\n## 3. 데이터 무결성 향상:\n\n데이터 무결성은 데이터베이스에 저장된 데이터의 정확성과 일관성을 의미합니다. 정규화는 부정확하거나 일관되지 않은 데이터를 저장하는 것을 방지하기 위한 제약 조건과 규칙을 강제함으로써 데이터 무결성을 향상시킵니다. 예를 들어, 각 열이 원자적(분할할 수 없는) 값만 포함하고 테이블 간의 관계가 올바르게 정의되도록 보장합니다.\n\n## 4. 쿼리 성능 향상:\n\n\n\n정규화된 데이터베이스는 쿼리에 대해 종종 더 효율적입니다. 데이터를 잘 정의된 관계를 가진 작은 테이블로 구성함으로써 쿼리를 더 빨리 효과적으로 실행할 수 있습니다. 정규화된 테이블은 일반적으로 특정 개체나 개념과 관련된 데이터를 저장하도록 설계되어 각 쿼리에 처리해야 하는 데이터 양을 줄입니다.\n\n## 5. 데이터베이스 유지관리를 간단하게:\n\n정규화된 데이터베이스는 유지 관리 및 업데이트가 시간이 지나서도 더 쉽습니다. 데이터베이스 구조를 수정해야 할 때(예: 새로운 필드나 테이블 추가), 정규화는 변경 사항을 다른 부분에 영향을 미치지 않고 적용할 수 있도록 합니다. 이를 통해 데이터베이스는 변화하는 요구 사항에 빠르게 적응할 수 있고 유지 보수 활동 중 오류 발생 가능성을 줄입니다.\n\n## 6. 확장 가능성을 용이하게하는:\n\n\n\n정규화된 데이터베이스는 본질적으로 확장 가능성이 높습니다. 데이터 양이나 데이터베이스의 복잡성이 증가함에 따라 정규화는 성능이나 데이터 무결성을 희생하지 않고 쉽게 확장할 수 있게 합니다. 새로운 테이블을 추가하거나 기존 테이블을 수정하거나 확장하여 새로운 요구 사항을 수용할 수 있습니다. 이렇게 하면 전체 데이터베이스 구조에 중요한 장애가 없이 확장할 수 있습니다.\n\n# 정규화 유형\n\n정규화는 데이터베이스 설계에서 사용되는 과정으로 데이터를 중복과 의존성을 최소화하는 구조화된 테이블로 구성합니다. 각각의 규칙 세트를 갖는 여러 가지 정규 형태가 있습니다. 다양한 유형의 정규화를 살펴보겠습니다:\n\n## 1. 제1정규화(1NF):\n\n\n\n1NF에 따르면, 테이블이 정규화되었다고 말할 수 있는 조건은 다음과 같습니다:\n\n- 각 열에는 원자적(분할할 수 없는) 값이 포함되어 있어야 합니다.\n- 열 내에 반복 그룹이나 배열이 없어야 합니다.\n- 테이블의 각 셀에는 하나의 값만 있어야 합니다.\n\n예를 들어, 각 셀이 반복 그룹이나 배열과 같은 것이 없이 하나의 값만 포함하고 있는 테이블은 1NF에 속합니다.\n\n## 2. 두 번째 정규형 (2NF):\n\n\n\n위의 내용을 친근한 톤으로 한국어로 번역하겠습니다.\n\n표가 2NF에 있다는 것은 다음과 같습니다:\n\n- 1NF에 있습니다.\n- 모든 비-키 속성이 기본 키 전체에 완전히 함수 종속성을 갖습니다.\n\n이는 모든 비-키 속성이 기본 키 전체에 의존해야 한다는 것을 의미합니다. 표가 복합 기본 키를 가지는 경우 각 비-키 속성은 복합 키 전체에 의존해야 하며 그 일부만으로는 안 됩니다.\n\n## 3. 세 번째 정규형 (3NF):\n\n\n\n3NF에있는 테이블은 다음과 같습니다:\n\n- 2NF에 있습니다.\n- 이러한 종속성이 없습니다.\n\n다시 말해, 비 주요 속성은 다른 비 주요 속성에 의존해서는 안됩니다. 이러한 종속성은 별도의 테이블을 생성하여 제거해야 합니다.\n\n## 4. Boyce-Codd Normal Form (BCNF):\n\n\n\nBCNF은 3NF의 강력한 형태이며 다음 조건을 만족할 때 달성됩니다:\n\n- 3NF에 있어야 합니다.\n- 모든 비자명 함수 종속인 𝑋→𝑌X→Y에 대해, X가 수퍼키여야 합니다.\n\n여기서 수퍼키는 테이블의 각 행을 고유하게 식별하는 속성 세트입니다.\n\n## 5. 제4 정규형 (4NF):\n\n\n\n4NF는 다중값 종속성을 해결하여 테이블이 다중값 속성이 없는 것을 보장합니다. 이것은 다중값 종속성을 제거하고 이를 위한 별도의 테이블을 생성함으로써 달성됩니다.\n\n## 6. 다섯 번째 정규 형태 (5NF):\n\n5NF, 또는 Project-Join 정규 형태 (PJ/NF)로도 알려져 있으며 조인 종속성을 다룹니다. 이는 테이블을 분해하여 각 테이블이 단일 주제를 나타내고 중복없이 다른 테이블과 결합될 수 있도록 보장함으로써 달성됩니다.\n\n# 주요 여정을 시작해봅시다!\n\n\n\n그래서, 지금까지 우리는 정규화가 무엇인지, 왜 정규화를 하는지, 그리고 정규화의 종류에 대한 기본 아이디어를 알게 되었습니다. 이 기본 지식을 바탕으로 정규화를 더 깊이 이해해볼 수 있게 되었습니다. 이제 메인 여정을 시작해봅시다.\n\n# 제1정규형 / 1NF\n\n제1정규형(1NF)은 정규화의 가장 기본적인 수준이며, 관계형 데이터베이스의 각 테이블이 원자 값만 포함하도록 하는 데 초점을 맞춥니다. 즉, 각 셀이 단일하고 분할할 수 없는 데이터 조각을 보유하도록 하는 것입니다. 이를 통해 열 내에서 반복 그룹이나 배열을 제거할 수 있습니다. 예제를 통해 1NF를 자세히 살펴봅시다:\n\n예제:\n\n\n\n학생들과 강의에 관한 정보를 저장하는 표를 생각해보세요. 이 표는 반복 그룹과 비원자적인 값을 포함하여 1NF를 위반합니다:\n\n![표](/assets/img/2024-05-15-MasterNormalizationinSQL_3.png)\n\n예제의 문제점:\n\n- 반복 그룹: \"Courses\" 열에는 쉼표로 구분된 여러 값을 포함합니다. 이는 1NF의 원자성 규칙을 위반합니다.\n- 비원자적인 값: \"Courses\" 열의 값은 원자적이지 않으며, 여러 조각의 데이터를 나타냅니다.\n\n\n\n이 표를 1NF로 바꾸려면 각 행에 원자 값만 포함되도록 여러 행으로 분할해야 합니다.\n\n## 1NF에서 재구성된 표:\n\n![Restructured Table in 1NF](/assets/img/2024-05-15-MasterNormalizationinSQL_4.png)\n\n설명:\n\n\n\n- \"Course\" column의 각 행은 이제 원자성 규칙을 준수하며 하나의 값만 포함합니다.\n- 반복 그룹이 제거되었고, 각 학생-과정 조합이 별도의 행으로 표시됩니다.\n\n## 제2 정규형 / 2NF\n\n제 2 정규형(2NF)은 부분 종속성 문제를 해결함으로써 제 1 정규형(1NF)을 기반으로 합니다. 이는 테이블 내의 모든 비-키 속성이 전체 주 키에 완전히 기능적으로 종속되도록 보장합니다. 예시를 통해 2NF를 자세히 살펴보겠습니다:\n\n예시:\n\n\n\n책과 저자 정보를 저장하는 테이블을 고려해보세요. 아래는 테이블이 어떻게 보일지에 대한 예시입니다:\n\n![테이블 예시](/assets/img/2024-05-15-MasterNormalizationinSQL_5.png)\n\n예시의 문제점:\n\n- 테이블은 복합 기본 키(BookID, AuthorID)를 포함하고 있습니다. 여기서 BookID는 책을 고유하게 식별하지만 AuthorID는 저자를 고유하게 식별하지 않습니다.\n- \"AuthorName\" 열은 AuthorID에만 종속되어 있으며 전체 기본 키에 종속되지 않습니다.\n- 이 테이블은 2NF를 위반합니다. AuthorName이 기본 키의 일부 (AuthorID)에 함수적으로 종속되어 있기 때문입니다.\n\n\n\n## 2NF에 재구성된 테이블:\n\n테이블을 2NF로 변경하기 위해 테이블을 두 개로 나눴어요: 책을 위한 하나와 작가를 위한 다른 하나입니다.\n\n![테이블](/assets/img/2024-05-15-MasterNormalizationinSQL_6.png)\n\n## 설명:\n\n\n\n- Books 테이블에서 BookID가 기본 키(primary key)입니다.\n- Books 테이블의 AuthorID는 현재 Authors 테이블을 참조하는 외래 키(foreign key)입니다.\n- Authors 테이블에는 AuthorID가 기본 키로 포함되어 있습니다.\n- Authors 테이블은 각 작가의 이름이 중복으로 저장되지 않도록 보장합니다.\n- Authors 테이블은 AuthorID에 의해 결정되는 AuthorName이 전체 기본 키에 기능적으로 의존할 수 있습니다.\n\n## 제 3 정규형 / 3NF\n\n제 3 정규형(3NF)은 제 1 정규형(1NF)과 제 2 정규형(2NF)의 원칙을 확장하여 이행 종속성(transitive dependencies)을 다룹니다. 이는 비 기본 키(non-key attributes)가 다른 비 기본 키에 의존하지 않고 기본 키에만 의존하도록 보장합니다. 예시를 통해 3NF를 알아보겠습니다:\n\n예시:\n\n\n\n직원 및 부서에 관한 정보를 저장하는 테이블을 고려해보세요. 테이블에는 부서 관리자의 전화번호도 포함되어 있습니다.\n\n다음은 이 예시에 관한 문제점입니다:\n\n- 이 테이블에는 이행 종속성이 포함되어 있습니다: ManagerPhone이 기본 키가 아닌 Manager에 종속되어 있습니다.\n\n\n\n## 3NF로 재구성된 테이블:\n\n테이블을 3NF로 변경하기 위해 이원종속성을 제거해야 합니다. 테이블을 직원, 부서 및 매니저로 세 개의 별도 테이블로 분할할 것입니다.\n\n![테이블 이미지](/assets/img/2024-05-15-MasterNormalizationinSQL_8.png)\n\n설명:\n\n\n\n- 사원 테이블은 사원별 정보를 포함하며, 주요 키로 EmployeeID가 사용됩니다.\n- 부서 테이블은 각 부서에 대한 정보를 포함하며, 주요 키로 DepartmentID가 사용됩니다.\n- 매니저 테이블은 각 매니저에 대한 정보를 포함하며, 주요 키로 ManagerID가 사용됩니다.\n- 원본 테이블에서 ManagerPhone은 주키가 아닌 Manager에 종속적입니다. 테이블을 분할하여 이 체이닝 종속성을 제거합니다.\n\n# Boyce-Codd 정규형 (BCNF)\n\nBoyce-Codd 정규형(BCNF)은 제3 정규형(3NF)의 원리를 기반으로 한 더 높은 정규화 수준입니다. BCNF는 특정 유형의 기능적 종속성을 다루어 모든 비자명 기능적 종속성 𝑋→𝑌X→Y에 대해 결정자(X)가 수퍼키임을 보장합니다. 예시를 통해 BCNF를 살펴봅시다:\n\n예시:\n\n\n\n다음은 강의와 강사 정보를 저장하는 테이블을 고려해보세요:\n\nIssues with the Example:\n\n- The table contains a non-trivial functional dependency: 𝐼𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟𝐼𝐷→𝐼𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟𝑁𝑎𝑚𝑒,𝐸𝑚𝑎𝑖𝑙\n- The InstructorID determines both the InstructorName and Email, but InstructorID is not a superkey since multiple instructors can have the same ID.\n\n\n\n## BCNF로 재구성된 테이블:\n\n테이블을 BCNF로 가져오려면 모든 비자명 함수 종속의 결정자가 수퍼키여야 함을 보장해야 합니다. 테이블을 두 개로 분할할 것입니다: Courses와 Instructors.\n\n![BCNF 테이블](/assets/img/2024-05-15-MasterNormalizationinSQL_10.png)\n\n설명:\n\n\n\n- Courses 테이블은 각 과정에 대한 정보를 포함하며 CourseID가 기본 키로 사용됩니다.\n- Instructors 테이블은 각각의 강사에 대한 정보를 포함하며 InstructorID가 기본 키로 사용됩니다.\n- 원래 테이블은 BCNF를 위반합니다. 이유는 InstructorID가 InstructorName과 Email을 모두 결정하고, InstructorID가 슈퍼키가 아니기 때문입니다. 테이블을 분할함으로써, 모든 비자명 함수 종속성의 결정자가 슈퍼키임을 보장합니다.\n\n# 제4 정규형 / 4NF\n\n4차 정규형(4NF)은 다중 값 종속성을 처리하여 제3 정규형(3NF)을 넘어가는 정규화 수준입니다. 데이터베이스 스키마에 비자명 다중 값 종속성이 없는지 확인합니다. 예제를 통해 4NF를 살펴보겠습니다:\n\n예시:\n\n\n\n프로젝트 및 해당 프로젝트에 배정된 직원, 그리고 각 직원이 책임지는 작업에 대한 정보를 저장하는 테이블을 고려해보세요:\n\n\n![테이블](/assets/img/2024-05-15-MasterNormalizationinSQL_11.png)\n\n\n예제의 문제점:\n\n- 다중 값 종속성이 있습니다. 예를 들어 (프로젝트ID, 직원ID)의 조합이 여러 TaskID와 TaskName 쌍을 결정합니다.\n- 테이블은 비자명 다중 값 종속성을 포함하고 있어 4NF를 위반합니다.\n\n\n\n## 4NF에서 재구성된 테이블:\n\n테이블을 4NF로 전환하기 위해 다중 값 종속성을 제거하고 별도의 테이블로 분할해야 합니다.\n\n![Restructured Table](/assets/img/2024-05-15-MasterNormalizationinSQL_12.png)\n\n설명:\n\n\n\n- Projects 테이블은 ProjectID를 기본 키로 포함합니다.\n- Employees 테이블은 EmployeeID를 기본 키로 포함합니다.\n- Tasks 테이블은 ProjectID와 EmployeeID를 외래 키로 포함하며 TaskID를 기본 키로 포함합니다.\n- Tasks 테이블의 각 행은 프로젝트에서 직원에게 할당된 단일 작업을 나타냅니다.\n- 원래 테이블을 세 개의 별도 테이블로 분할함으로써 다중 값 종속성을 제거하여 데이터베이스 스키마가 4NF를 준수하도록 합니다.\n\n# 다섯 번째 정규 형식 / 5NF\n\n다섯 번째 정규 형식 (5NF), 또는 프로젝트 조인 정규 형식 (PJ/NF)은 조인 종속성을 다루며 데이터베이스 스키마에 조인 이상 현상이 없는 것을 보장합니다. 각 테이블이 단일 주제를 나타내고 중복없이 다른 테이블과 조인될 수 있도록 테이블을 분해하는 것을 포함합니다. 예제로 5NF를 살펴봅시다:\n\n예시:\n\n\n\n학생, 강의 및 각 강의에서 학생들이 받은 성적에 대한 정보를 저장하는 표를 고려해 보세요:\n\n\n| StudentID | StudentName | CourseID | CourseName | Grade |\n|-----------|-------------|----------|------------|-------|\n| 1         | Alice       | 1        | Math       | A     |\n| 2         | Bob         | 1        | Math       | B     |\n| 1         | Alice       | 2        | Science    | B     |\n\n\n예제의 문제점:\n\n- 표에 결합 의존성이 있는데, 특정 속성이 다른 속성들의 조합에 따라 종속되어 있습니다.\n- 예를 들어, CourseName은 CourseID에 의해 결정되며, Grade는 StudentID와 CourseID의 조합에 의해 결정됩니다.\n\n\n\n## 5NF로 재구성된 테이블:\n\n테이블을 5NF로 가져오기 위해 조인 종속성을 제거하기 위해 여러 개의 테이블로 분해합니다:\n\n![테이블 이미지](/assets/img/2024-05-15-MasterNormalizationinSQL_14.png)\n\n## 설명:\n\n\n\n- 학생 테이블은 주요 키로 학생ID와 이름을 포함합니다.\n- 강좌 테이블은 주요 키로 강좌ID와 강좌명을 포함합니다.\n- 성적 테이블은 외래 키로 학생ID와 강좌ID를 포함하며 성적이 있습니다.\n- 원본 테이블을 세 개의 별도 테이블로 분해함으로써 조인 종속성을 제거하여 데이터베이스 스키마가 5NF를 준수하도록 보장합니다.\n\n# 결론:\nSQL에서 정규화를 숙달하는 것은 효율적이고 확장 가능한 데이터베이스를 설계하는 데 중요합니다. 정규 형태를 이해하고 효과적으로 구현함으로써 데이터 무결성을 보장하고 중복을 줄이며 데이터베이스 관리를 간소화할 수 있습니다. 새 데이터베이스를 설계하거나 기존 데이터베이스를 최적화하는 경우 정규화 원칙은 견고하고 신뢰할 수 있는 데이터 인프라를 유지하는 데 필수적입니다.","ogImage":{"url":"/assets/img/2024-05-15-MasterNormalizationinSQL_0.png"},"coverImage":"/assets/img/2024-05-15-MasterNormalizationinSQL_0.png","tag":["Tech"],"readingTime":9},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h1: \"h1\",\n    h2: \"h2\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-MasterNormalizationinSQL_0.png\",\n        alt: \"이미지1\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-MasterNormalizationinSQL_1.png\",\n        alt: \"이미지2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데이터베이스 관리에서 중요한 개념인 정규화는 특히 SQL(구조화된 쿼리 언어)에서 중요합니다. 이는 데이터베이스의 효율성, 무결성 및 확장성을 보장하며, 데이터베이스의 데이터를 중복 없이 정리하고 의존성을 줄이는 프로세스입니다. SQL에서 정규화를 마스터하는 것은 효율적이고 확장 가능하며 유지보수가 용이한 데이터베이스를 생성하는 데 필수적입니다. 이 글에서는 정규화의 원칙과 기술을 자세히 살펴보고, 여러 형태와 효과적인 구현 방법에 대해 다룰 것입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"정규화 이해하기:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정규화는 데이터를 테이블로 구성할 때 발생하는 중복 및 종속성을 최소화하는 일련의 규칙에 기반하고 있습니다. 이 과정은 일반적으로 큰 테이블을 더 작고 관리하기 쉬운 작은 테이블로 나누고 그들 간의 관계를 정의하는 것을 포함합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"정규화를 사용하는 이유:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-MasterNormalizationinSQL_2.png\",\n        alt: \"MasterNormalizationinSQL_2\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정규화를 숙달하기 전에 왜 정규화를 사용하며 정규화의 필요성에 대해 이해해야 합니다. 그래서 \\\"왜 정규화를 배워야 하는지\\\"에 대한 참고 자료를 가질 수 있게 됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데이터베이스 설계에서 중요한 개념인 정규화는 데이터를 효율적으로 구성하고 데이터 무결성을 유지하는 데 사용됩니다. 여러 가지 중요한 목적을 가지고 있으며, 전반적으로 데이터베이스 시스템의 효과성과 신뢰성에 기여합니다:\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"1. 중복 최소화:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정규화는 큰 테이블을 작고 관리하기 쉬운 작은 테이블로 분해하여 중복 데이터를 제거하는 데 도움을 줍니다. 중복은 데이터베이스의 일관성 및 이상 현상을 유발할 수 있습니다. 데이터를 정규화된 형태로 저장함으로써 각 정보 조각이 한 곳에만 저장되어 일관성 문제의 가능성을 줄입니다.\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"2. 업데이트 이상 방지:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"변경된 테이블은 날 위험성을 최소화하고 다른 곳에서 불일치나 오류가 발생하지 않도록 하는 정규화를 통해 발생할 수 있는 갱신 이상 현상을 방지합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. 데이터 무결성 향상:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데이터 무결성은 데이터베이스에 저장된 데이터의 정확성과 일관성을 의미합니다. 정규화는 부정확하거나 일관되지 않은 데이터를 저장하는 것을 방지하기 위한 제약 조건과 규칙을 강제함으로써 데이터 무결성을 향상시킵니다. 예를 들어, 각 열이 원자적(분할할 수 없는) 값만 포함하고 테이블 간의 관계가 올바르게 정의되도록 보장합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. 쿼리 성능 향상:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정규화된 데이터베이스는 쿼리에 대해 종종 더 효율적입니다. 데이터를 잘 정의된 관계를 가진 작은 테이블로 구성함으로써 쿼리를 더 빨리 효과적으로 실행할 수 있습니다. 정규화된 테이블은 일반적으로 특정 개체나 개념과 관련된 데이터를 저장하도록 설계되어 각 쿼리에 처리해야 하는 데이터 양을 줄입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"5. 데이터베이스 유지관리를 간단하게:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정규화된 데이터베이스는 유지 관리 및 업데이트가 시간이 지나서도 더 쉽습니다. 데이터베이스 구조를 수정해야 할 때(예: 새로운 필드나 테이블 추가), 정규화는 변경 사항을 다른 부분에 영향을 미치지 않고 적용할 수 있도록 합니다. 이를 통해 데이터베이스는 변화하는 요구 사항에 빠르게 적응할 수 있고 유지 보수 활동 중 오류 발생 가능성을 줄입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"6. 확장 가능성을 용이하게하는:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정규화된 데이터베이스는 본질적으로 확장 가능성이 높습니다. 데이터 양이나 데이터베이스의 복잡성이 증가함에 따라 정규화는 성능이나 데이터 무결성을 희생하지 않고 쉽게 확장할 수 있게 합니다. 새로운 테이블을 추가하거나 기존 테이블을 수정하거나 확장하여 새로운 요구 사항을 수용할 수 있습니다. 이렇게 하면 전체 데이터베이스 구조에 중요한 장애가 없이 확장할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"정규화 유형\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"정규화는 데이터베이스 설계에서 사용되는 과정으로 데이터를 중복과 의존성을 최소화하는 구조화된 테이블로 구성합니다. 각각의 규칙 세트를 갖는 여러 가지 정규 형태가 있습니다. 다양한 유형의 정규화를 살펴보겠습니다:\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1. 제1정규화(1NF):\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"1NF에 따르면, 테이블이 정규화되었다고 말할 수 있는 조건은 다음과 같습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"각 열에는 원자적(분할할 수 없는) 값이 포함되어 있어야 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"열 내에 반복 그룹이나 배열이 없어야 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"테이블의 각 셀에는 하나의 값만 있어야 합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예를 들어, 각 셀이 반복 그룹이나 배열과 같은 것이 없이 하나의 값만 포함하고 있는 테이블은 1NF에 속합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. 두 번째 정규형 (2NF):\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"위의 내용을 친근한 톤으로 한국어로 번역하겠습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"표가 2NF에 있다는 것은 다음과 같습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"1NF에 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"모든 비-키 속성이 기본 키 전체에 완전히 함수 종속성을 갖습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이는 모든 비-키 속성이 기본 키 전체에 의존해야 한다는 것을 의미합니다. 표가 복합 기본 키를 가지는 경우 각 비-키 속성은 복합 키 전체에 의존해야 하며 그 일부만으로는 안 됩니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. 세 번째 정규형 (3NF):\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"3NF에있는 테이블은 다음과 같습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"2NF에 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이러한 종속성이 없습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다시 말해, 비 주요 속성은 다른 비 주요 속성에 의존해서는 안됩니다. 이러한 종속성은 별도의 테이블을 생성하여 제거해야 합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4. Boyce-Codd Normal Form (BCNF):\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"BCNF은 3NF의 강력한 형태이며 다음 조건을 만족할 때 달성됩니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"3NF에 있어야 합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"모든 비자명 함수 종속인 𝑋→𝑌X→Y에 대해, X가 수퍼키여야 합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서 수퍼키는 테이블의 각 행을 고유하게 식별하는 속성 세트입니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"5. 제4 정규형 (4NF):\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"4NF는 다중값 종속성을 해결하여 테이블이 다중값 속성이 없는 것을 보장합니다. 이것은 다중값 종속성을 제거하고 이를 위한 별도의 테이블을 생성함으로써 달성됩니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"6. 다섯 번째 정규 형태 (5NF):\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"5NF, 또는 Project-Join 정규 형태 (PJ/NF)로도 알려져 있으며 조인 종속성을 다룹니다. 이는 테이블을 분해하여 각 테이블이 단일 주제를 나타내고 중복없이 다른 테이블과 결합될 수 있도록 보장함으로써 달성됩니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"주요 여정을 시작해봅시다!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"그래서, 지금까지 우리는 정규화가 무엇인지, 왜 정규화를 하는지, 그리고 정규화의 종류에 대한 기본 아이디어를 알게 되었습니다. 이 기본 지식을 바탕으로 정규화를 더 깊이 이해해볼 수 있게 되었습니다. 이제 메인 여정을 시작해봅시다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"제1정규형 / 1NF\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제1정규형(1NF)은 정규화의 가장 기본적인 수준이며, 관계형 데이터베이스의 각 테이블이 원자 값만 포함하도록 하는 데 초점을 맞춥니다. 즉, 각 셀이 단일하고 분할할 수 없는 데이터 조각을 보유하도록 하는 것입니다. 이를 통해 열 내에서 반복 그룹이나 배열을 제거할 수 있습니다. 예제를 통해 1NF를 자세히 살펴봅시다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예제:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"학생들과 강의에 관한 정보를 저장하는 표를 생각해보세요. 이 표는 반복 그룹과 비원자적인 값을 포함하여 1NF를 위반합니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-MasterNormalizationinSQL_3.png\",\n        alt: \"표\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예제의 문제점:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"반복 그룹: \\\"Courses\\\" 열에는 쉼표로 구분된 여러 값을 포함합니다. 이는 1NF의 원자성 규칙을 위반합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"비원자적인 값: \\\"Courses\\\" 열의 값은 원자적이지 않으며, 여러 조각의 데이터를 나타냅니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 표를 1NF로 바꾸려면 각 행에 원자 값만 포함되도록 여러 행으로 분할해야 합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"1NF에서 재구성된 표:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-MasterNormalizationinSQL_4.png\",\n        alt: \"Restructured Table in 1NF\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"설명:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"\\\"Course\\\" column의 각 행은 이제 원자성 규칙을 준수하며 하나의 값만 포함합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"반복 그룹이 제거되었고, 각 학생-과정 조합이 별도의 행으로 표시됩니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"제2 정규형 / 2NF\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 2 정규형(2NF)은 부분 종속성 문제를 해결함으로써 제 1 정규형(1NF)을 기반으로 합니다. 이는 테이블 내의 모든 비-키 속성이 전체 주 키에 완전히 기능적으로 종속되도록 보장합니다. 예시를 통해 2NF를 자세히 살펴보겠습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"책과 저자 정보를 저장하는 테이블을 고려해보세요. 아래는 테이블이 어떻게 보일지에 대한 예시입니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-MasterNormalizationinSQL_5.png\",\n        alt: \"테이블 예시\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시의 문제점:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"테이블은 복합 기본 키(BookID, AuthorID)를 포함하고 있습니다. 여기서 BookID는 책을 고유하게 식별하지만 AuthorID는 저자를 고유하게 식별하지 않습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"\\\"AuthorName\\\" 열은 AuthorID에만 종속되어 있으며 전체 기본 키에 종속되지 않습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"이 테이블은 2NF를 위반합니다. AuthorName이 기본 키의 일부 (AuthorID)에 함수적으로 종속되어 있기 때문입니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2NF에 재구성된 테이블:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블을 2NF로 변경하기 위해 테이블을 두 개로 나눴어요: 책을 위한 하나와 작가를 위한 다른 하나입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-MasterNormalizationinSQL_6.png\",\n        alt: \"테이블\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"설명:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Books 테이블에서 BookID가 기본 키(primary key)입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Books 테이블의 AuthorID는 현재 Authors 테이블을 참조하는 외래 키(foreign key)입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Authors 테이블에는 AuthorID가 기본 키로 포함되어 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Authors 테이블은 각 작가의 이름이 중복으로 저장되지 않도록 보장합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Authors 테이블은 AuthorID에 의해 결정되는 AuthorName이 전체 기본 키에 기능적으로 의존할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"제 3 정규형 / 3NF\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"제 3 정규형(3NF)은 제 1 정규형(1NF)과 제 2 정규형(2NF)의 원칙을 확장하여 이행 종속성(transitive dependencies)을 다룹니다. 이는 비 기본 키(non-key attributes)가 다른 비 기본 키에 의존하지 않고 기본 키에만 의존하도록 보장합니다. 예시를 통해 3NF를 알아보겠습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"직원 및 부서에 관한 정보를 저장하는 테이블을 고려해보세요. 테이블에는 부서 관리자의 전화번호도 포함되어 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 이 예시에 관한 문제점입니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이 테이블에는 이행 종속성이 포함되어 있습니다: ManagerPhone이 기본 키가 아닌 Manager에 종속되어 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3NF로 재구성된 테이블:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블을 3NF로 변경하기 위해 이원종속성을 제거해야 합니다. 테이블을 직원, 부서 및 매니저로 세 개의 별도 테이블로 분할할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-MasterNormalizationinSQL_8.png\",\n        alt: \"테이블 이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"설명:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"사원 테이블은 사원별 정보를 포함하며, 주요 키로 EmployeeID가 사용됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"부서 테이블은 각 부서에 대한 정보를 포함하며, 주요 키로 DepartmentID가 사용됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"매니저 테이블은 각 매니저에 대한 정보를 포함하며, 주요 키로 ManagerID가 사용됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"원본 테이블에서 ManagerPhone은 주키가 아닌 Manager에 종속적입니다. 테이블을 분할하여 이 체이닝 종속성을 제거합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Boyce-Codd 정규형 (BCNF)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Boyce-Codd 정규형(BCNF)은 제3 정규형(3NF)의 원리를 기반으로 한 더 높은 정규화 수준입니다. BCNF는 특정 유형의 기능적 종속성을 다루어 모든 비자명 기능적 종속성 𝑋→𝑌X→Y에 대해 결정자(X)가 수퍼키임을 보장합니다. 예시를 통해 BCNF를 살펴봅시다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음은 강의와 강사 정보를 저장하는 테이블을 고려해보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Issues with the Example:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"The table contains a non-trivial functional dependency: 𝐼𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟𝐼𝐷→𝐼𝑛𝑠𝑡𝑟𝑢𝑐𝑡𝑜𝑟𝑁𝑎𝑚𝑒,𝐸𝑚𝑎𝑖𝑙\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"The InstructorID determines both the InstructorName and Email, but InstructorID is not a superkey since multiple instructors can have the same ID.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"BCNF로 재구성된 테이블:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블을 BCNF로 가져오려면 모든 비자명 함수 종속의 결정자가 수퍼키여야 함을 보장해야 합니다. 테이블을 두 개로 분할할 것입니다: Courses와 Instructors.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-MasterNormalizationinSQL_10.png\",\n        alt: \"BCNF 테이블\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"설명:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Courses 테이블은 각 과정에 대한 정보를 포함하며 CourseID가 기본 키로 사용됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Instructors 테이블은 각각의 강사에 대한 정보를 포함하며 InstructorID가 기본 키로 사용됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"원래 테이블은 BCNF를 위반합니다. 이유는 InstructorID가 InstructorName과 Email을 모두 결정하고, InstructorID가 슈퍼키가 아니기 때문입니다. 테이블을 분할함으로써, 모든 비자명 함수 종속성의 결정자가 슈퍼키임을 보장합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"제4 정규형 / 4NF\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"4차 정규형(4NF)은 다중 값 종속성을 처리하여 제3 정규형(3NF)을 넘어가는 정규화 수준입니다. 데이터베이스 스키마에 비자명 다중 값 종속성이 없는지 확인합니다. 예제를 통해 4NF를 살펴보겠습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트 및 해당 프로젝트에 배정된 직원, 그리고 각 직원이 책임지는 작업에 대한 정보를 저장하는 테이블을 고려해보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-MasterNormalizationinSQL_11.png\",\n        alt: \"테이블\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예제의 문제점:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"다중 값 종속성이 있습니다. 예를 들어 (프로젝트ID, 직원ID)의 조합이 여러 TaskID와 TaskName 쌍을 결정합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"테이블은 비자명 다중 값 종속성을 포함하고 있어 4NF를 위반합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4NF에서 재구성된 테이블:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블을 4NF로 전환하기 위해 다중 값 종속성을 제거하고 별도의 테이블로 분할해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-MasterNormalizationinSQL_12.png\",\n        alt: \"Restructured Table\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"설명:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Projects 테이블은 ProjectID를 기본 키로 포함합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Employees 테이블은 EmployeeID를 기본 키로 포함합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Tasks 테이블은 ProjectID와 EmployeeID를 외래 키로 포함하며 TaskID를 기본 키로 포함합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Tasks 테이블의 각 행은 프로젝트에서 직원에게 할당된 단일 작업을 나타냅니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"원래 테이블을 세 개의 별도 테이블로 분할함으로써 다중 값 종속성을 제거하여 데이터베이스 스키마가 4NF를 준수하도록 합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"다섯 번째 정규 형식 / 5NF\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다섯 번째 정규 형식 (5NF), 또는 프로젝트 조인 정규 형식 (PJ/NF)은 조인 종속성을 다루며 데이터베이스 스키마에 조인 이상 현상이 없는 것을 보장합니다. 각 테이블이 단일 주제를 나타내고 중복없이 다른 테이블과 조인될 수 있도록 테이블을 분해하는 것을 포함합니다. 예제로 5NF를 살펴봅시다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예시:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"학생, 강의 및 각 강의에서 학생들이 받은 성적에 대한 정보를 저장하는 표를 고려해 보세요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"| StudentID | StudentName | CourseID | CourseName | Grade |\\n|-----------|-------------|----------|------------|-------|\\n| 1         | Alice       | 1        | Math       | A     |\\n| 2         | Bob         | 1        | Math       | B     |\\n| 1         | Alice       | 2        | Science    | B     |\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"예제의 문제점:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"표에 결합 의존성이 있는데, 특정 속성이 다른 속성들의 조합에 따라 종속되어 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"예를 들어, CourseName은 CourseID에 의해 결정되며, Grade는 StudentID와 CourseID의 조합에 의해 결정됩니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"5NF로 재구성된 테이블:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"테이블을 5NF로 가져오기 위해 조인 종속성을 제거하기 위해 여러 개의 테이블로 분해합니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-MasterNormalizationinSQL_14.png\",\n        alt: \"테이블 이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"설명:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"학생 테이블은 주요 키로 학생ID와 이름을 포함합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"강좌 테이블은 주요 키로 강좌ID와 강좌명을 포함합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"성적 테이블은 외래 키로 학생ID와 강좌ID를 포함하며 성적이 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"원본 테이블을 세 개의 별도 테이블로 분해함으로써 조인 종속성을 제거하여 데이터베이스 스키마가 5NF를 준수하도록 보장합니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"결론:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SQL에서 정규화를 숙달하는 것은 효율적이고 확장 가능한 데이터베이스를 설계하는 데 중요합니다. 정규 형태를 이해하고 효과적으로 구현함으로써 데이터 무결성을 보장하고 중복을 줄이며 데이터베이스 관리를 간소화할 수 있습니다. 새 데이터베이스를 설계하거나 기존 데이터베이스를 최적화하는 경우 정규화 원칙은 견고하고 신뢰할 수 있는 데이터 인프라를 유지하는 데 필수적입니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-15-MasterNormalizationinSQL"},"buildId":"837W-BjvPVBgft6aM4api","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>