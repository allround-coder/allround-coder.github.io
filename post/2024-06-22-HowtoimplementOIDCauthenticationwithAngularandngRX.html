<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Angular와 ngRX를 사용하여 OIDC 인증 구현하는 방법 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Angular와 ngRX를 사용하여 OIDC 인증 구현하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Angular와 ngRX를 사용하여 OIDC 인증 구현하는 방법 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX" data-gatsby-head="true"/><meta name="twitter:title" content="Angular와 ngRX를 사용하여 OIDC 인증 구현하는 방법 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 14:54" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_buildManifest.js" defer=""></script><script src="/_next/static/Y-fCAg8BUV7y2HNFwX9AA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Angular와 ngRX를 사용하여 OIDC 인증 구현하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Angular와 ngRX를 사용하여 OIDC 인증 구현하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>angular-oauth2-oidc 라이브러리를 사용하여 JWT 토큰 처리를 자동화하고 있어요.</p>
<p><img src="/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png" alt="이미지"></p>
<p>다들 OIDC를 여기서, 거기서 계속 듣곤 하는데, 정확히 무슨 의미일까요?</p>
<p>Microsoft의 정의를 따르면 OpenId Connect (OIDC)은 권한 부여 (OAuth 2.0의 확장)의 인증 프로토콜로, 디지털 서비스에 액세스하기 위한 로그인 프로세스를 표준화한 것이라고 해요.</p>
<div class="content-ad"></div>
<p>다른 말로, 사용자 데이터를 공유하지 않고 관련없는 응용 프로그램에서 사용자를 확인하는 메커니즘입니다. 이 방법을 통해 사용자는 한 번만 로그인하고 여러 응용 프로그램에 액세스할 수 있습니다.</p>
<p>이러한 메커니즘은 이미 상당히 인기가 있으며 기업들이 이미 자사의 생태계에 통합하기 시작했습니다.</p>
<p>그래, 이제 기본 개념을 파악하고 OIDC가 해결하고자 하는 문제 유형과 목표를 알게 되었습니다. 그 목표는 다음 단계를 통해 달성됩니다:</p>
<ul>
<li>사용자가 특정 응용 프로그램에 입력하여 OpenID 제공자로 리디렉션됩니다.</li>
<li>사용자가 사용자 이름과 암호를 제공합니다.</li>
<li>사용자 자격 증명이 OpenID 제공자로 전달됩니다.</li>
<li>제공자가 자격 증명을 확인하고 권한을 획득합니다.</li>
<li>사용자가 ID 토큰을 포함하여 원래의 응용 프로그램으로 리디렉션됩니다.</li>
</ul>
<div class="content-ad"></div>
<p>복잡해 보이죠?</p>
<p>하지만 구현하기가 생각보다 어렵지 않습니다. 외부 라이브러리를 전혀 사용하지 않고 자체 솔루션을 구축하려고 하면 좀 더 많은 시간이 걸릴 것입니다. 로켓 과학은 아니지만 전적으로 혼자서 해결할 필요는 없습니다. Angular 세계에서 소개 없이 잘 알려진 Manfred Steyer가 개발한 angular-oauth2-oidc 라이브러리가 있습니다.:-))</p>
<p>이 라이브러리는 모듈 기반 및 독립형 접근 방식을 포함하여 다양한 Angular 버전을 지원합니다. 제대로 설정하면 리디렉션, 요청 헤더에 토큰 추가, 심지어 토큰 갱신에 대해 걱정할 필요가 없습니다!</p>
<p>먼저 모듈 기반 접근 방식부터 시작해 보죠. 하지만 그 전에 프로젝트 의존성에 라이브러리를 추가해야 합니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">npm i angular-oauth2-oidc --save
</code></pre>
<p>라이브러리가 성공적으로 설치되면 구성 및 처리를 설정하기 위해 일부 준비를 해야합니다.</p>
<p>인가를 처리하기 위해 이미 존재하는 사용자 기능 저장소의 구현을 사용할 것입니다. 해당 주제에 익숙하지 않다면 다른 기사를 참조해주세요:</p>
<p>이제 동일한 페이지에 있는 경우 사용자 기능 저장소를 확장하여 OIDC를 처리해봅시다.</p>
<div class="content-ad"></div>
<p>먼저 user.state.ts 파일에서 UserState를 아래와 같이 추가 속성과 함께 확장해 보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> interface <span class="hljs-title class_">UserState</span> {
  <span class="hljs-comment">// ... 다른 속성들</span>
  <span class="hljs-attr">loggedIn</span>: boolean;
  <span class="hljs-attr">logInRequestHandled</span>: boolean;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">initialState</span>: <span class="hljs-title class_">UserState</span> = {
  <span class="hljs-comment">// ... 다른 속성들</span>
  <span class="hljs-attr">loggedIn</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">logInRequestHandled</span>: <span class="hljs-literal">false</span>,
};
</code></pre>
<p>또한 user.selectors.ts 파일에서 store에서 정보를 다시 가져오기 위한 selector를 만들어 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> selectIsLogInRequestHandled = <span class="hljs-title function_">createSelector</span>(
  selectUserState,
  <span class="hljs-function">(<span class="hljs-params">{ logInRequestHandled }: UserState</span>) =></span> logInRequestHandled
);
</code></pre>
<div class="content-ad"></div>
<p>전체 프로세스를 탐색하는 데 도움이 되는 일부 동작을 정의해야 합니다. 이를 user.actions.ts 파일 내에 다음과 같이 작성해야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> user = <span class="hljs-string">'[사용자]'</span>;
<span class="hljs-comment">// ... 다른 액션들</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> logIn = <span class="hljs-title function_">createAction</span>(<span class="hljs-string">`<span class="hljs-subst">${user}</span> 로그인`</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> logInSuccess = <span class="hljs-title function_">createAction</span>(<span class="hljs-string">`<span class="hljs-subst">${user}</span> 로그인 성공`</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> logInError = <span class="hljs-title function_">createAction</span>(<span class="hljs-string">`<span class="hljs-subst">${user}</span> 로그인 오류`</span>);
</code></pre>
<p>우리의 액션들은 상태에 영향을 미쳐야 하므로 user.reducer.ts 파일 내에서 이러한 상태 변경이 어떻게 발생할지를 정의해야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { createReducer, on } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ngrx/store'</span>;
<span class="hljs-keyword">import</span> {
  initialState,
  logInSuccess,
  <span class="hljs-title class_">UserState</span>,
  logInError,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./index'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> userReducer = <span class="hljs-title function_">createReducer</span>(
  initialState,
  <span class="hljs-comment">// ... 일부 다른 액션들</span>
  <span class="hljs-title function_">on</span>(logInSuccess, <span class="hljs-function">(<span class="hljs-params">state: UserState</span>) =></span> ({ 
      ...state, 
      <span class="hljs-attr">loggedIn</span>: <span class="hljs-literal">true</span>, 
      <span class="hljs-attr">logInRequestHandled</span>: <span class="hljs-literal">true</span>,
   })),
  <span class="hljs-title function_">on</span>(logInError, <span class="hljs-function">(<span class="hljs-params">state: UserState</span>) =></span> ({ 
      ...state, 
      <span class="hljs-attr">loggedIn</span>: <span class="hljs-literal">false</span>, 
      <span class="hljs-attr">logInRequestHandled</span>: <span class="hljs-literal">true</span>,
   }))
);
</code></pre>
<div class="content-ad"></div>
<p>거의 완성 단계에 다다랐어요. UsersFacade를 user.facade.ts 파일 내부에서 업데이트해야하며, 모두 통합할 수 있게 될 거예요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Store</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ngrx/store'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UserState</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./user.state'</span>;
<span class="hljs-keyword">import</span> { logIn } <span class="hljs-keyword">from</span> <span class="hljs-string">'./user.actions'</span>;
<span class="hljs-keyword">import</span> { selectIsLogInRequestHandled } <span class="hljs-keyword">from</span> <span class="hljs-string">'./user.selectors'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Observable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

@<span class="hljs-title class_">Injectable</span>({
    <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserFacadeService</span> {
    readonly <span class="hljs-attr">logInRequestHandled$</span>: <span class="hljs-title class_">Observable</span>&#x3C;boolean> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-title function_">select</span>(selectIsLogInRequestHandled);

    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private readonly store: Store&#x3C;UserState></span>) {} <span class="hljs-comment">// 생성자 대신에 주입 토큰 사용할 수 있어요</span>

    <span class="hljs-title function_">logIn</span>(): <span class="hljs-keyword">void</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-title function_">logIn</span>());
    }
}
</code></pre>
<p>이제 준비 상태를 설정하겠어요. 앞으로 모두 통합하기 위해 user.effects.ts 파일 내에서 비동기 작업을 정의해야 해요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Router</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Actions</span>, createEffect, ofType } <span class="hljs-keyword">from</span> <span class="hljs-string">'@ngrx/effects'</span>;
<span class="hljs-keyword">import</span> { catchError, map, mergeMap, tap } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">EMPTY</span>, <span class="hljs-keyword">from</span>, iif } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;
<span class="hljs-keyword">import</span> {
    getUserSettings,
    logIn,
    logInError,
    logInSuccess,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./index'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">OAuthErrorEvent</span>, <span class="hljs-title class_">OAuthEvent</span>, <span class="hljs-title class_">OAuthService</span>, <span class="hljs-title class_">OAuthSuccessEvent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'angular-oauth2-oidc'</span>;
<span class="hljs-keyword">import</span> { environment } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../environments/environment'</span>;

@<span class="hljs-title class_">Injectable</span>({ <span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span> })
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEffects</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">
        private readonly actions$: Actions,
        private readonly router: Router,
        private readonly oAuthService: OAuthService
    </span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">oAuthService</span>.<span class="hljs-title function_">configure</span>(environment); <span class="hljs-comment">// 공급자 구성</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">oAuthService</span>.<span class="hljs-title function_">setupAutomaticSilentRefresh</span>(); <span class="hljs-comment">// 조용한 자동 토큰 새로고침, 그렇지 않으면 토큰이 오래되어 refresh되지 않을 수 있어요</span>
    }

    listenOAuth$ = <span class="hljs-title function_">createEffect</span>(<span class="hljs-function">() =></span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">oAuthService</span>.<span class="hljs-property">events</span>.<span class="hljs-title function_">pipe</span>(
            <span class="hljs-title function_">mergeMap</span>(<span class="hljs-function">(<span class="hljs-params">event: OAuthEvent</span>) =></span> {
                <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">OAuthErrorEvent</span>) {
                    <span class="hljs-keyword">return</span> [<span class="hljs-title function_">logInError</span>()];
                }
                <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">OAuthSuccessEvent</span> &#x26;&#x26; event.<span class="hljs-property">type</span> === <span class="hljs-string">'token_received'</span>) {
                    <span class="hljs-keyword">return</span> [<span class="hljs-title function_">logInSuccess</span>()];
                }

                <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">EMPTY</span>;
            })
        )
    );

    logIn$ = <span class="hljs-title function_">createEffect</span>(<span class="hljs-function">() =></span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions$</span>.<span class="hljs-title function_">pipe</span>(
            <span class="hljs-title function_">ofType</span>(logIn),
            <span class="hljs-title function_">mergeMap</span>(<span class="hljs-function">() =></span>
                <span class="hljs-title function_">iif</span>(
                    <span class="hljs-function">() =></span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">oAuthService</span>.<span class="hljs-title function_">hasValidIdToken</span>() &#x26;&#x26; <span class="hljs-variable language_">this</span>.<span class="hljs-property">oAuthService</span>.<span class="hljs-title function_">hasValidAccessToken</span>(),
                    [<span class="hljs-title function_">logInSuccess</span>()],
                    <span class="hljs-title function_">from</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">oAuthService</span>.<span class="hljs-title function_">loadDiscoveryDocumentAndLogin</span>()).<span class="hljs-title function_">pipe</span>(
                        <span class="hljs-title function_">tap</span>((<span class="hljs-attr">result</span>: boolean): <span class="hljs-function"><span class="hljs-params">void</span> =></span> {
                            <span class="hljs-keyword">if</span> (!result) {
                                <span class="hljs-variable language_">this</span>.<span class="hljs-property">oAuthService</span>.<span class="hljs-title function_">initCodeFlow</span>();
                            }
                        }),
                        <span class="hljs-title function_">mergeMap</span>(<span class="hljs-function">() =></span> <span class="hljs-variable constant_">EMPTY</span>),
                        <span class="hljs-title function_">catchError</span>(<span class="hljs-function">() =></span> [<span class="hljs-title function_">logInError</span>()])
                    )
                )
            )
        )
    );

    logInSuccess$ = <span class="hljs-title function_">createEffect</span>(<span class="hljs-function">() =></span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions$</span>.<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">ofType</span>(logInSuccess), <span class="hljs-title function_">map</span>(getUserSettings)));

    logInError$ = <span class="hljs-title function_">createEffect</span>(
        <span class="hljs-function">() =></span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">actions$</span>.<span class="hljs-title function_">pipe</span>(
                <span class="hljs-title function_">ofType</span>(logInError),
                <span class="hljs-title function_">tap</span>(<span class="hljs-function">() =></span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-title function_">navigate</span>([<span class="hljs-string">'no-access'</span>]))
            ),
        { <span class="hljs-attr">dispatch</span>: <span class="hljs-literal">false</span> }
    );
}
</code></pre>
<div class="content-ad"></div>
<p>그래서, 이제 angular-oauth2-oidc 라이브러리 구현에 대해 이야기해보겠습니다. 라이브러리 자체에 공급자 정보를 설정하기 위해 전달하는 초기 정보가 있는 구성 파일이 필요합니다. 아래는 라이브러리 문서에서 가져온 기본 구현입니다. 그러나 애플리케이션이 배포될 다양한 환경에 따라 구성이 다를 수 있으므로, 이를 환경.$'specific'.ts 파일 내에 유지하는 것을 제안합니다.</p>
<p>Markdown 포맷으로 표를 변경하겠습니다:</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">AuthConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'angular-oauth2-oidc'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">authCodeFlowConfig</span>: <span class="hljs-title class_">AuthConfig</span> = {
    <span class="hljs-comment">// Identity Provider의 URL</span>
    <span class="hljs-attr">issuer</span>: <span class="hljs-string">'https://idsvr4.azurewebsites.net'</span>,

    <span class="hljs-comment">// 로그인 후 사용자를 리디렉션할 SPA의 URL</span>
    <span class="hljs-attr">redirectUri</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">origin</span> + <span class="hljs-string">'/index.html'</span>,

    <span class="hljs-comment">// SPA의 ID. 해당 ID로 SPA가 권한 서버에 등록됨</span>
    <span class="hljs-attr">clientId</span>: <span class="hljs-string">'spa'</span>,

    <span class="hljs-comment">// 권한 서버에서 비밀번호를 요구하는 경우 필요함. 일반적으로 이 경우,</span>
    <span class="hljs-comment">// 권한 서버가 SPA를 고려하여 구성되지 않았다는 것을 의미하며, 보안을 위해 중요한 추가적인 최선의 방법을 강요할 수도 있음</span>
    <span class="hljs-comment">// dummyClientSecret: 'secret',</span>

    <span class="hljs-attr">responseType</span>: <span class="hljs-string">'code'</span>,

    <span class="hljs-comment">// 클라이언트가 요청해야 하는 권한의 범위 설정</span>
    <span class="hljs-comment">// 처음 네 가지는 OIDC에서 정의된 것들임</span>
    <span class="hljs-comment">// 중요: refresh 토큰을 받으려면 offline_access를 요청</span>
    <span class="hljs-comment">// api scope는 usecase-specific한 것임</span>
    <span class="hljs-attr">scope</span>: <span class="hljs-string">'openid profile email offline_access api'</span>,

    <span class="hljs-attr">showDebugInformation</span>: <span class="hljs-literal">true</span>,
};
</code></pre>
<p>모듈 기반 접근 방식:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { <span class="hljs-variable constant_">APP_INITIALIZER</span>, <span class="hljs-title class_">NgModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">BrowserModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">BrowserAnimationsModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser/animations'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.component'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UserFacadeService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./store'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">OAuthModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'angular-oauth2-oidc'</span>;
<span class="hljs-keyword">import</span> { filter } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/operators'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">HttpClientModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">initializeLogIn</span>(<span class="hljs-params">userFacade: UserFacadeService</span>): <span class="hljs-function">() =></span> <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">return</span> (): <span class="hljs-title class_">Observable</span>&#x3C;<span class="hljs-built_in">boolean</span>> => {
        userFacade.<span class="hljs-title function_">logIn</span>();
        <span class="hljs-keyword">return</span> userFacade.<span class="hljs-property">logInRequestHandled$</span>.<span class="hljs-title function_">pipe</span>(<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>));
    };
}

<span class="hljs-meta">@NgModule</span>({
    <span class="hljs-attr">declarations</span>: [<span class="hljs-title class_">AppComponent</span>],
    <span class="hljs-attr">imports</span>: [
        <span class="hljs-title class_">BrowserModule</span>,
        <span class="hljs-title class_">BrowserAnimationsModule</span>,
        <span class="hljs-title class_">HttpClientModule</span>,
        <span class="hljs-title class_">OAuthModule</span>.<span class="hljs-title function_">forRoot</span>({
            <span class="hljs-attr">resourceServer</span>: { <span class="hljs-comment">// You can pass the array of URIs entitled to include the authorization token or allow all requests by not passing it at all.</span>
                <span class="hljs-attr">sendAccessToken</span>: <span class="hljs-literal">true</span>,
            },
        }),
    ],
    <span class="hljs-attr">providers</span>: [
        { 
          <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">APP_INITIALIZER</span>, 
          <span class="hljs-attr">useFactory</span>: initializeLogIn, 
          <span class="hljs-attr">deps</span>: [<span class="hljs-title class_">UserFacadeService</span>], 
          <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span> 
        },
    ],
    <span class="hljs-attr">bootstrap</span>: [<span class="hljs-title class_">AppComponent</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> {}
</code></pre>
<p>위의 코드를 분석해봅시다. 우리는 initializeLogIn을 APP_INITIALIZER로 선언하고, 이를 주 애플리케이션 모듈 내의 providers 배열 안에 전달했습니다. 여기서 로그인 시도가 호출되고, UserFacade 소스로부터의 logInRequestHandled$ Observable이 true를 발행할 때까지 기다립니다.</p>
<p>APP_INITIALIZER가 무엇인지 잘 모르겠나요? 해당 주제와 관련된 다른 기사를 확인해보세요:</p>
<p>또한 주 애플리케이션 모듈 내에서 Angular common 라이브러리에서 HttpClientModule와 방금 설치한 라이브러리인 OAuthModule을 import 했습니다.</p>
<div class="content-ad"></div>
<h1>독립 실행 방식 Angular v15:</h1>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { bootstrapApplication } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;
<span class="hljs-keyword">import</span> { provideHttpClient } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app/app.component'</span>;
<span class="hljs-keyword">import</span> { provideOAuthClient } <span class="hljs-keyword">from</span> <span class="hljs-string">'angular-oauth2-oidc'</span>;

<span class="hljs-title function_">bootstrapApplication</span>(<span class="hljs-title class_">AppComponent</span>, {
  <span class="hljs-attr">providers</span>: [
    <span class="hljs-title function_">provideHttpClient</span>(),
    <span class="hljs-title function_">provideOAuthClient</span>(),
    { 
      <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">APP_INITIALIZER</span>, 
      <span class="hljs-attr">useFactory</span>: initializeLogIn, 
      <span class="hljs-attr">deps</span>: [<span class="hljs-title class_">UserFacadeService</span>], 
      <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>,
    },
  ]
});
</code></pre>
<h1>독립 실행 방식 Angular v14:</h1>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { bootstrapApplication } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">HttpClientModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">AppComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app/app.component'</span>;
<span class="hljs-keyword">import</span> { provideOAuthClient } <span class="hljs-keyword">from</span> <span class="hljs-string">'angular-oauth2-oidc'</span>;
<span class="hljs-keyword">import</span> { importProvidersFrom } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-title function_">bootstrapApplication</span>(<span class="hljs-title class_">AppComponent</span>, {
  <span class="hljs-attr">providers</span>: [
    importProvidersFrom(<span class="hljs-title class_">HttpClientModule</span>),
    <span class="hljs-title function_">provideOAuthClient</span>(),
    { 
      <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">APP_INITIALIZER</span>, 
      <span class="hljs-attr">useFactory</span>: initializeLogIn, 
      <span class="hljs-attr">deps</span>: [<span class="hljs-title class_">UserFacadeService</span>], 
      <span class="hljs-attr">multi</span>: <span class="hljs-literal">true</span>,
    },
  ]
});
</code></pre>
<div class="content-ad"></div>
<p>Angular v14에서는 독립적인 구성 요소가 여전히 실험 단계였고 모든 기능이 과거와 같이 공급자를 갖추지 않았다는 것이 차이점입니다.</p>
<p>그게 전부에요, 이제 ngRX 기반의 OIDC 구현이 준비되었습니다!</p>
<p>정말 쉬웠죠?</p>
<p>프로젝트에 대한 상담이 필요하다면 언제든 연락주세요. 앱을 망치지 마시고 문의해주세요 :-)</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Angular와 ngRX를 사용하여 OIDC 인증 구현하는 방법","description":"","date":"2024-06-22 14:54","slug":"2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX","content":"\n\nangular-oauth2-oidc 라이브러리를 사용하여 JWT 토큰 처리를 자동화하고 있어요.\n\n![이미지](/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png)\n\n다들 OIDC를 여기서, 거기서 계속 듣곤 하는데, 정확히 무슨 의미일까요?\n\nMicrosoft의 정의를 따르면 OpenId Connect (OIDC)은 권한 부여 (OAuth 2.0의 확장)의 인증 프로토콜로, 디지털 서비스에 액세스하기 위한 로그인 프로세스를 표준화한 것이라고 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 말로, 사용자 데이터를 공유하지 않고 관련없는 응용 프로그램에서 사용자를 확인하는 메커니즘입니다. 이 방법을 통해 사용자는 한 번만 로그인하고 여러 응용 프로그램에 액세스할 수 있습니다.\n\n이러한 메커니즘은 이미 상당히 인기가 있으며 기업들이 이미 자사의 생태계에 통합하기 시작했습니다.\n\n그래, 이제 기본 개념을 파악하고 OIDC가 해결하고자 하는 문제 유형과 목표를 알게 되었습니다. 그 목표는 다음 단계를 통해 달성됩니다:\n\n- 사용자가 특정 응용 프로그램에 입력하여 OpenID 제공자로 리디렉션됩니다.\n- 사용자가 사용자 이름과 암호를 제공합니다.\n- 사용자 자격 증명이 OpenID 제공자로 전달됩니다.\n- 제공자가 자격 증명을 확인하고 권한을 획득합니다.\n- 사용자가 ID 토큰을 포함하여 원래의 응용 프로그램으로 리디렉션됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n복잡해 보이죠?\n\n하지만 구현하기가 생각보다 어렵지 않습니다. 외부 라이브러리를 전혀 사용하지 않고 자체 솔루션을 구축하려고 하면 좀 더 많은 시간이 걸릴 것입니다. 로켓 과학은 아니지만 전적으로 혼자서 해결할 필요는 없습니다. Angular 세계에서 소개 없이 잘 알려진 Manfred Steyer가 개발한 angular-oauth2-oidc 라이브러리가 있습니다.:-))\n\n이 라이브러리는 모듈 기반 및 독립형 접근 방식을 포함하여 다양한 Angular 버전을 지원합니다. 제대로 설정하면 리디렉션, 요청 헤더에 토큰 추가, 심지어 토큰 갱신에 대해 걱정할 필요가 없습니다!\n\n먼저 모듈 기반 접근 방식부터 시작해 보죠. 하지만 그 전에 프로젝트 의존성에 라이브러리를 추가해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnpm i angular-oauth2-oidc --save\n```\n\n라이브러리가 성공적으로 설치되면 구성 및 처리를 설정하기 위해 일부 준비를 해야합니다.\n\n인가를 처리하기 위해 이미 존재하는 사용자 기능 저장소의 구현을 사용할 것입니다. 해당 주제에 익숙하지 않다면 다른 기사를 참조해주세요:\n\n이제 동일한 페이지에 있는 경우 사용자 기능 저장소를 확장하여 OIDC를 처리해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 user.state.ts 파일에서 UserState를 아래와 같이 추가 속성과 함께 확장해 보겠습니다.\n\n```js\nexport interface UserState {\n  // ... 다른 속성들\n  loggedIn: boolean;\n  logInRequestHandled: boolean;\n}\n\nexport const initialState: UserState = {\n  // ... 다른 속성들\n  loggedIn: false,\n  logInRequestHandled: false,\n};\n```\n\n또한 user.selectors.ts 파일에서 store에서 정보를 다시 가져오기 위한 selector를 만들어 봅시다.\n\n```js\nexport const selectIsLogInRequestHandled = createSelector(\n  selectUserState,\n  ({ logInRequestHandled }: UserState) =\u003e logInRequestHandled\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전체 프로세스를 탐색하는 데 도움이 되는 일부 동작을 정의해야 합니다. 이를 user.actions.ts 파일 내에 다음과 같이 작성해야 합니다:\n\n```js\nconst user = '[사용자]';\n// ... 다른 액션들\nexport const logIn = createAction(`${user} 로그인`);\nexport const logInSuccess = createAction(`${user} 로그인 성공`);\nexport const logInError = createAction(`${user} 로그인 오류`);\n```\n\n우리의 액션들은 상태에 영향을 미쳐야 하므로 user.reducer.ts 파일 내에서 이러한 상태 변경이 어떻게 발생할지를 정의해야 합니다:\n\n```js\nimport { createReducer, on } from '@ngrx/store';\nimport {\n  initialState,\n  logInSuccess,\n  UserState,\n  logInError,\n} from './index';\n\nexport const userReducer = createReducer(\n  initialState,\n  // ... 일부 다른 액션들\n  on(logInSuccess, (state: UserState) =\u003e ({ \n      ...state, \n      loggedIn: true, \n      logInRequestHandled: true,\n   })),\n  on(logInError, (state: UserState) =\u003e ({ \n      ...state, \n      loggedIn: false, \n      logInRequestHandled: true,\n   }))\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n거의 완성 단계에 다다랐어요. UsersFacade를 user.facade.ts 파일 내부에서 업데이트해야하며, 모두 통합할 수 있게 될 거예요.\n\n```js\nimport { Injectable } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { UserState } from './user.state';\nimport { logIn } from './user.actions';\nimport { selectIsLogInRequestHandled } from './user.selectors';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class UserFacadeService {\n    readonly logInRequestHandled$: Observable\u003cboolean\u003e = this.store.select(selectIsLogInRequestHandled);\n\n    constructor(private readonly store: Store\u003cUserState\u003e) {} // 생성자 대신에 주입 토큰 사용할 수 있어요\n\n    logIn(): void {\n        this.store.dispatch(logIn());\n    }\n}\n```\n\n이제 준비 상태를 설정하겠어요. 앞으로 모두 통합하기 위해 user.effects.ts 파일 내에서 비동기 작업을 정의해야 해요:\n\n```js\nimport { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { catchError, map, mergeMap, tap } from 'rxjs/operators';\nimport { EMPTY, from, iif } from 'rxjs';\nimport {\n    getUserSettings,\n    logIn,\n    logInError,\n    logInSuccess,\n} from './index';\nimport { OAuthErrorEvent, OAuthEvent, OAuthService, OAuthSuccessEvent } from 'angular-oauth2-oidc';\nimport { environment } from '../../../environments/environment';\n\n@Injectable({ providedIn: 'root' })\nexport class UserEffects {\n    constructor(\n        private readonly actions$: Actions,\n        private readonly router: Router,\n        private readonly oAuthService: OAuthService\n    ) {\n        this.oAuthService.configure(environment); // 공급자 구성\n        this.oAuthService.setupAutomaticSilentRefresh(); // 조용한 자동 토큰 새로고침, 그렇지 않으면 토큰이 오래되어 refresh되지 않을 수 있어요\n    }\n\n    listenOAuth$ = createEffect(() =\u003e\n        this.oAuthService.events.pipe(\n            mergeMap((event: OAuthEvent) =\u003e {\n                if (event instanceof OAuthErrorEvent) {\n                    return [logInError()];\n                }\n                if (event instanceof OAuthSuccessEvent \u0026\u0026 event.type === 'token_received') {\n                    return [logInSuccess()];\n                }\n\n                return EMPTY;\n            })\n        )\n    );\n\n    logIn$ = createEffect(() =\u003e\n        this.actions$.pipe(\n            ofType(logIn),\n            mergeMap(() =\u003e\n                iif(\n                    () =\u003e this.oAuthService.hasValidIdToken() \u0026\u0026 this.oAuthService.hasValidAccessToken(),\n                    [logInSuccess()],\n                    from(this.oAuthService.loadDiscoveryDocumentAndLogin()).pipe(\n                        tap((result: boolean): void =\u003e {\n                            if (!result) {\n                                this.oAuthService.initCodeFlow();\n                            }\n                        }),\n                        mergeMap(() =\u003e EMPTY),\n                        catchError(() =\u003e [logInError()])\n                    )\n                )\n            )\n        )\n    );\n\n    logInSuccess$ = createEffect(() =\u003e this.actions$.pipe(ofType(logInSuccess), map(getUserSettings)));\n\n    logInError$ = createEffect(\n        () =\u003e\n            this.actions$.pipe(\n                ofType(logInError),\n                tap(() =\u003e this.router.navigate(['no-access']))\n            ),\n        { dispatch: false }\n    );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서, 이제 angular-oauth2-oidc 라이브러리 구현에 대해 이야기해보겠습니다. 라이브러리 자체에 공급자 정보를 설정하기 위해 전달하는 초기 정보가 있는 구성 파일이 필요합니다. 아래는 라이브러리 문서에서 가져온 기본 구현입니다. 그러나 애플리케이션이 배포될 다양한 환경에 따라 구성이 다를 수 있으므로, 이를 환경.$'specific'.ts 파일 내에 유지하는 것을 제안합니다.\n\nMarkdown 포맷으로 표를 변경하겠습니다:\n\n```typescript\nimport { AuthConfig } from 'angular-oauth2-oidc';\n\nexport const authCodeFlowConfig: AuthConfig = {\n    // Identity Provider의 URL\n    issuer: 'https://idsvr4.azurewebsites.net',\n\n    // 로그인 후 사용자를 리디렉션할 SPA의 URL\n    redirectUri: window.location.origin + '/index.html',\n\n    // SPA의 ID. 해당 ID로 SPA가 권한 서버에 등록됨\n    clientId: 'spa',\n\n    // 권한 서버에서 비밀번호를 요구하는 경우 필요함. 일반적으로 이 경우,\n    // 권한 서버가 SPA를 고려하여 구성되지 않았다는 것을 의미하며, 보안을 위해 중요한 추가적인 최선의 방법을 강요할 수도 있음\n    // dummyClientSecret: 'secret',\n\n    responseType: 'code',\n\n    // 클라이언트가 요청해야 하는 권한의 범위 설정\n    // 처음 네 가지는 OIDC에서 정의된 것들임\n    // 중요: refresh 토큰을 받으려면 offline_access를 요청\n    // api scope는 usecase-specific한 것임\n    scope: 'openid profile email offline_access api',\n\n    showDebugInformation: true,\n};\n```\n\n모듈 기반 접근 방식:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```typescript\nimport { APP_INITIALIZER, NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { AppComponent } from './app.component';\nimport { UserFacadeService } from './store';\nimport { OAuthModule } from 'angular-oauth2-oidc';\nimport { filter } from 'rxjs/operators';\nimport { HttpClientModule } from '@angular/common/http';\n\nfunction initializeLogIn(userFacade: UserFacadeService): () =\u003e void {\n    return (): Observable\u003cboolean\u003e =\u003e {\n        userFacade.logIn();\n        return userFacade.logInRequestHandled$.pipe(filter(Boolean));\n    };\n}\n\n@NgModule({\n    declarations: [AppComponent],\n    imports: [\n        BrowserModule,\n        BrowserAnimationsModule,\n        HttpClientModule,\n        OAuthModule.forRoot({\n            resourceServer: { // You can pass the array of URIs entitled to include the authorization token or allow all requests by not passing it at all.\n                sendAccessToken: true,\n            },\n        }),\n    ],\n    providers: [\n        { \n          provide: APP_INITIALIZER, \n          useFactory: initializeLogIn, \n          deps: [UserFacadeService], \n          multi: true \n        },\n    ],\n    bootstrap: [AppComponent],\n})\nexport class AppModule {}\n```\n\n위의 코드를 분석해봅시다. 우리는 initializeLogIn을 APP_INITIALIZER로 선언하고, 이를 주 애플리케이션 모듈 내의 providers 배열 안에 전달했습니다. 여기서 로그인 시도가 호출되고, UserFacade 소스로부터의 logInRequestHandled$ Observable이 true를 발행할 때까지 기다립니다.\n\nAPP_INITIALIZER가 무엇인지 잘 모르겠나요? 해당 주제와 관련된 다른 기사를 확인해보세요:\n\n또한 주 애플리케이션 모듈 내에서 Angular common 라이브러리에서 HttpClientModule와 방금 설치한 라이브러리인 OAuthModule을 import 했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 독립 실행 방식 Angular v15:\n\n```js\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { provideHttpClient } from '@angular/common/http';\nimport { AppComponent } from './app/app.component';\nimport { provideOAuthClient } from 'angular-oauth2-oidc';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    provideHttpClient(),\n    provideOAuthClient(),\n    { \n      provide: APP_INITIALIZER, \n      useFactory: initializeLogIn, \n      deps: [UserFacadeService], \n      multi: true,\n    },\n  ]\n});\n```\n\n# 독립 실행 방식 Angular v14:\n\n```js\nimport { bootstrapApplication } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\nimport { AppComponent } from './app/app.component';\nimport { provideOAuthClient } from 'angular-oauth2-oidc';\nimport { importProvidersFrom } from '@angular/core';\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    importProvidersFrom(HttpClientModule),\n    provideOAuthClient(),\n    { \n      provide: APP_INITIALIZER, \n      useFactory: initializeLogIn, \n      deps: [UserFacadeService], \n      multi: true,\n    },\n  ]\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAngular v14에서는 독립적인 구성 요소가 여전히 실험 단계였고 모든 기능이 과거와 같이 공급자를 갖추지 않았다는 것이 차이점입니다.\n\n그게 전부에요, 이제 ngRX 기반의 OIDC 구현이 준비되었습니다!\n\n정말 쉬웠죠?\n\n프로젝트에 대한 상담이 필요하다면 언제든 연락주세요. 앱을 망치지 마시고 문의해주세요 :-)","ogImage":{"url":"/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003eangular-oauth2-oidc 라이브러리를 사용하여 JWT 토큰 처리를 자동화하고 있어요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e다들 OIDC를 여기서, 거기서 계속 듣곤 하는데, 정확히 무슨 의미일까요?\u003c/p\u003e\n\u003cp\u003eMicrosoft의 정의를 따르면 OpenId Connect (OIDC)은 권한 부여 (OAuth 2.0의 확장)의 인증 프로토콜로, 디지털 서비스에 액세스하기 위한 로그인 프로세스를 표준화한 것이라고 해요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다른 말로, 사용자 데이터를 공유하지 않고 관련없는 응용 프로그램에서 사용자를 확인하는 메커니즘입니다. 이 방법을 통해 사용자는 한 번만 로그인하고 여러 응용 프로그램에 액세스할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 메커니즘은 이미 상당히 인기가 있으며 기업들이 이미 자사의 생태계에 통합하기 시작했습니다.\u003c/p\u003e\n\u003cp\u003e그래, 이제 기본 개념을 파악하고 OIDC가 해결하고자 하는 문제 유형과 목표를 알게 되었습니다. 그 목표는 다음 단계를 통해 달성됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자가 특정 응용 프로그램에 입력하여 OpenID 제공자로 리디렉션됩니다.\u003c/li\u003e\n\u003cli\u003e사용자가 사용자 이름과 암호를 제공합니다.\u003c/li\u003e\n\u003cli\u003e사용자 자격 증명이 OpenID 제공자로 전달됩니다.\u003c/li\u003e\n\u003cli\u003e제공자가 자격 증명을 확인하고 권한을 획득합니다.\u003c/li\u003e\n\u003cli\u003e사용자가 ID 토큰을 포함하여 원래의 응용 프로그램으로 리디렉션됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e복잡해 보이죠?\u003c/p\u003e\n\u003cp\u003e하지만 구현하기가 생각보다 어렵지 않습니다. 외부 라이브러리를 전혀 사용하지 않고 자체 솔루션을 구축하려고 하면 좀 더 많은 시간이 걸릴 것입니다. 로켓 과학은 아니지만 전적으로 혼자서 해결할 필요는 없습니다. Angular 세계에서 소개 없이 잘 알려진 Manfred Steyer가 개발한 angular-oauth2-oidc 라이브러리가 있습니다.:-))\u003c/p\u003e\n\u003cp\u003e이 라이브러리는 모듈 기반 및 독립형 접근 방식을 포함하여 다양한 Angular 버전을 지원합니다. 제대로 설정하면 리디렉션, 요청 헤더에 토큰 추가, 심지어 토큰 갱신에 대해 걱정할 필요가 없습니다!\u003c/p\u003e\n\u003cp\u003e먼저 모듈 기반 접근 방식부터 시작해 보죠. 하지만 그 전에 프로젝트 의존성에 라이브러리를 추가해야 합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm i angular-oauth2-oidc --save\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e라이브러리가 성공적으로 설치되면 구성 및 처리를 설정하기 위해 일부 준비를 해야합니다.\u003c/p\u003e\n\u003cp\u003e인가를 처리하기 위해 이미 존재하는 사용자 기능 저장소의 구현을 사용할 것입니다. 해당 주제에 익숙하지 않다면 다른 기사를 참조해주세요:\u003c/p\u003e\n\u003cp\u003e이제 동일한 페이지에 있는 경우 사용자 기능 저장소를 확장하여 OIDC를 처리해봅시다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e먼저 user.state.ts 파일에서 UserState를 아래와 같이 추가 속성과 함께 확장해 보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e interface \u003cspan class=\"hljs-title class_\"\u003eUserState\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// ... 다른 속성들\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eloggedIn\u003c/span\u003e: boolean;\n  \u003cspan class=\"hljs-attr\"\u003elogInRequestHandled\u003c/span\u003e: boolean;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003einitialState\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eUserState\u003c/span\u003e = {\n  \u003cspan class=\"hljs-comment\"\u003e// ... 다른 속성들\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eloggedIn\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003elogInRequestHandled\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한 user.selectors.ts 파일에서 store에서 정보를 다시 가져오기 위한 selector를 만들어 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e selectIsLogInRequestHandled = \u003cspan class=\"hljs-title function_\"\u003ecreateSelector\u003c/span\u003e(\n  selectUserState,\n  \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ logInRequestHandled }: UserState\u003c/span\u003e) =\u003e\u003c/span\u003e logInRequestHandled\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e전체 프로세스를 탐색하는 데 도움이 되는 일부 동작을 정의해야 합니다. 이를 user.actions.ts 파일 내에 다음과 같이 작성해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = \u003cspan class=\"hljs-string\"\u003e'[사용자]'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// ... 다른 액션들\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e logIn = \u003cspan class=\"hljs-title function_\"\u003ecreateAction\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${user}\u003c/span\u003e 로그인`\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e logInSuccess = \u003cspan class=\"hljs-title function_\"\u003ecreateAction\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${user}\u003c/span\u003e 로그인 성공`\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e logInError = \u003cspan class=\"hljs-title function_\"\u003ecreateAction\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${user}\u003c/span\u003e 로그인 오류`\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리의 액션들은 상태에 영향을 미쳐야 하므로 user.reducer.ts 파일 내에서 이러한 상태 변경이 어떻게 발생할지를 정의해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { createReducer, on } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@ngrx/store'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\n  initialState,\n  logInSuccess,\n  \u003cspan class=\"hljs-title class_\"\u003eUserState\u003c/span\u003e,\n  logInError,\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./index'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userReducer = \u003cspan class=\"hljs-title function_\"\u003ecreateReducer\u003c/span\u003e(\n  initialState,\n  \u003cspan class=\"hljs-comment\"\u003e// ... 일부 다른 액션들\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(logInSuccess, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003estate: UserState\u003c/span\u003e) =\u003e\u003c/span\u003e ({ \n      ...state, \n      \u003cspan class=\"hljs-attr\"\u003eloggedIn\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \n      \u003cspan class=\"hljs-attr\"\u003elogInRequestHandled\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n   })),\n  \u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(logInError, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003estate: UserState\u003c/span\u003e) =\u003e\u003c/span\u003e ({ \n      ...state, \n      \u003cspan class=\"hljs-attr\"\u003eloggedIn\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e, \n      \u003cspan class=\"hljs-attr\"\u003elogInRequestHandled\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n   }))\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e거의 완성 단계에 다다랐어요. UsersFacade를 user.facade.ts 파일 내부에서 업데이트해야하며, 모두 통합할 수 있게 될 거예요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eStore\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@ngrx/store'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eUserState\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./user.state'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { logIn } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./user.actions'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { selectIsLogInRequestHandled } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./user.selectors'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003eprovidedIn\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e,\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserFacadeService\u003c/span\u003e {\n    readonly \u003cspan class=\"hljs-attr\"\u003elogInRequestHandled$\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e\u0026#x3C;boolean\u003e = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estore\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eselect\u003c/span\u003e(selectIsLogInRequestHandled);\n\n    \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate readonly store: Store\u0026#x3C;UserState\u003e\u003c/span\u003e) {} \u003cspan class=\"hljs-comment\"\u003e// 생성자 대신에 주입 토큰 사용할 수 있어요\u003c/span\u003e\n\n    \u003cspan class=\"hljs-title function_\"\u003elogIn\u003c/span\u003e(): \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003estore\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edispatch\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elogIn\u003c/span\u003e());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 준비 상태를 설정하겠어요. 앞으로 모두 통합하기 위해 user.effects.ts 파일 내에서 비동기 작업을 정의해야 해요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eRouter\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/router'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eActions\u003c/span\u003e, createEffect, ofType } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@ngrx/effects'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { catchError, map, mergeMap, tap } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs/operators'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-variable constant_\"\u003eEMPTY\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e, iif } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\n    getUserSettings,\n    logIn,\n    logInError,\n    logInSuccess,\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./index'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eOAuthErrorEvent\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOAuthEvent\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOAuthService\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOAuthSuccessEvent\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'angular-oauth2-oidc'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { environment } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'../../../environments/environment'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003eprovidedIn\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'root'\u003c/span\u003e })\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserEffects\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n        private readonly actions$: Actions,\n        private readonly router: Router,\n        private readonly oAuthService: OAuthService\n    \u003c/span\u003e) {\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoAuthService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003econfigure\u003c/span\u003e(environment); \u003cspan class=\"hljs-comment\"\u003e// 공급자 구성\u003c/span\u003e\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoAuthService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esetupAutomaticSilentRefresh\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 조용한 자동 토큰 새로고침, 그렇지 않으면 토큰이 오래되어 refresh되지 않을 수 있어요\u003c/span\u003e\n    }\n\n    listenOAuth$ = \u003cspan class=\"hljs-title function_\"\u003ecreateEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoAuthService\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eevents\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\n            \u003cspan class=\"hljs-title function_\"\u003emergeMap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent: OAuthEvent\u003c/span\u003e) =\u003e\u003c/span\u003e {\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (event \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOAuthErrorEvent\u003c/span\u003e) {\n                    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\u003cspan class=\"hljs-title function_\"\u003elogInError\u003c/span\u003e()];\n                }\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (event \u003cspan class=\"hljs-keyword\"\u003einstanceof\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOAuthSuccessEvent\u003c/span\u003e \u0026#x26;\u0026#x26; event.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e'token_received'\u003c/span\u003e) {\n                    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\u003cspan class=\"hljs-title function_\"\u003elogInSuccess\u003c/span\u003e()];\n                }\n\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eEMPTY\u003c/span\u003e;\n            })\n        )\n    );\n\n    logIn$ = \u003cspan class=\"hljs-title function_\"\u003ecreateEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e\n        \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eactions$\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\n            \u003cspan class=\"hljs-title function_\"\u003eofType\u003c/span\u003e(logIn),\n            \u003cspan class=\"hljs-title function_\"\u003emergeMap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e\n                \u003cspan class=\"hljs-title function_\"\u003eiif\u003c/span\u003e(\n                    \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoAuthService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasValidIdToken\u003c/span\u003e() \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoAuthService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasValidAccessToken\u003c/span\u003e(),\n                    [\u003cspan class=\"hljs-title function_\"\u003elogInSuccess\u003c/span\u003e()],\n                    \u003cspan class=\"hljs-title function_\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoAuthService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eloadDiscoveryDocumentAndLogin\u003c/span\u003e()).\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\n                        \u003cspan class=\"hljs-title function_\"\u003etap\u003c/span\u003e((\u003cspan class=\"hljs-attr\"\u003eresult\u003c/span\u003e: boolean): \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003evoid\u003c/span\u003e =\u003e\u003c/span\u003e {\n                            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!result) {\n                                \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoAuthService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einitCodeFlow\u003c/span\u003e();\n                            }\n                        }),\n                        \u003cspan class=\"hljs-title function_\"\u003emergeMap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eEMPTY\u003c/span\u003e),\n                        \u003cspan class=\"hljs-title function_\"\u003ecatchError\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e [\u003cspan class=\"hljs-title function_\"\u003elogInError\u003c/span\u003e()])\n                    )\n                )\n            )\n        )\n    );\n\n    logInSuccess$ = \u003cspan class=\"hljs-title function_\"\u003ecreateEffect\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eactions$\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eofType\u003c/span\u003e(logInSuccess), \u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(getUserSettings)));\n\n    logInError$ = \u003cspan class=\"hljs-title function_\"\u003ecreateEffect\u003c/span\u003e(\n        \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e\n            \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eactions$\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\n                \u003cspan class=\"hljs-title function_\"\u003eofType\u003c/span\u003e(logInError),\n                \u003cspan class=\"hljs-title function_\"\u003etap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003erouter\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003enavigate\u003c/span\u003e([\u003cspan class=\"hljs-string\"\u003e'no-access'\u003c/span\u003e]))\n            ),\n        { \u003cspan class=\"hljs-attr\"\u003edispatch\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e }\n    );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그래서, 이제 angular-oauth2-oidc 라이브러리 구현에 대해 이야기해보겠습니다. 라이브러리 자체에 공급자 정보를 설정하기 위해 전달하는 초기 정보가 있는 구성 파일이 필요합니다. 아래는 라이브러리 문서에서 가져온 기본 구현입니다. 그러나 애플리케이션이 배포될 다양한 환경에 따라 구성이 다를 수 있으므로, 이를 환경.$'specific'.ts 파일 내에 유지하는 것을 제안합니다.\u003c/p\u003e\n\u003cp\u003eMarkdown 포맷으로 표를 변경하겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eAuthConfig\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'angular-oauth2-oidc'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eauthCodeFlowConfig\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAuthConfig\u003c/span\u003e = {\n    \u003cspan class=\"hljs-comment\"\u003e// Identity Provider의 URL\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eissuer\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'https://idsvr4.azurewebsites.net'\u003c/span\u003e,\n\n    \u003cspan class=\"hljs-comment\"\u003e// 로그인 후 사용자를 리디렉션할 SPA의 URL\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eredirectUri\u003c/span\u003e: \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elocation\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eorigin\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e'/index.html'\u003c/span\u003e,\n\n    \u003cspan class=\"hljs-comment\"\u003e// SPA의 ID. 해당 ID로 SPA가 권한 서버에 등록됨\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003eclientId\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'spa'\u003c/span\u003e,\n\n    \u003cspan class=\"hljs-comment\"\u003e// 권한 서버에서 비밀번호를 요구하는 경우 필요함. 일반적으로 이 경우,\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 권한 서버가 SPA를 고려하여 구성되지 않았다는 것을 의미하며, 보안을 위해 중요한 추가적인 최선의 방법을 강요할 수도 있음\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// dummyClientSecret: 'secret',\u003c/span\u003e\n\n    \u003cspan class=\"hljs-attr\"\u003eresponseType\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'code'\u003c/span\u003e,\n\n    \u003cspan class=\"hljs-comment\"\u003e// 클라이언트가 요청해야 하는 권한의 범위 설정\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 처음 네 가지는 OIDC에서 정의된 것들임\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 중요: refresh 토큰을 받으려면 offline_access를 요청\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// api scope는 usecase-specific한 것임\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003escope\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'openid profile email offline_access api'\u003c/span\u003e,\n\n    \u003cspan class=\"hljs-attr\"\u003eshowDebugInformation\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모듈 기반 접근 방식:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-typescript\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-variable constant_\"\u003eAPP_INITIALIZER\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNgModule\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eBrowserModule\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/platform-browser'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eBrowserAnimationsModule\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/platform-browser/animations'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./app.component'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eUserFacadeService\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./store'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eOAuthModule\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'angular-oauth2-oidc'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { filter } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'rxjs/operators'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eHttpClientModule\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/common/http'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einitializeLogIn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003euserFacade: UserFacadeService\u003c/span\u003e): \u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003evoid\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (): \u003cspan class=\"hljs-title class_\"\u003eObservable\u003c/span\u003e\u0026#x3C;\u003cspan class=\"hljs-built_in\"\u003eboolean\u003c/span\u003e\u003e =\u003e {\n        userFacade.\u003cspan class=\"hljs-title function_\"\u003elogIn\u003c/span\u003e();\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e userFacade.\u003cspan class=\"hljs-property\"\u003elogInRequestHandled$\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epipe\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efilter\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBoolean\u003c/span\u003e));\n    };\n}\n\n\u003cspan class=\"hljs-meta\"\u003e@NgModule\u003c/span\u003e({\n    \u003cspan class=\"hljs-attr\"\u003edeclarations\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e],\n    \u003cspan class=\"hljs-attr\"\u003eimports\u003c/span\u003e: [\n        \u003cspan class=\"hljs-title class_\"\u003eBrowserModule\u003c/span\u003e,\n        \u003cspan class=\"hljs-title class_\"\u003eBrowserAnimationsModule\u003c/span\u003e,\n        \u003cspan class=\"hljs-title class_\"\u003eHttpClientModule\u003c/span\u003e,\n        \u003cspan class=\"hljs-title class_\"\u003eOAuthModule\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eforRoot\u003c/span\u003e({\n            \u003cspan class=\"hljs-attr\"\u003eresourceServer\u003c/span\u003e: { \u003cspan class=\"hljs-comment\"\u003e// You can pass the array of URIs entitled to include the authorization token or allow all requests by not passing it at all.\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003esendAccessToken\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n            },\n        }),\n    ],\n    \u003cspan class=\"hljs-attr\"\u003eproviders\u003c/span\u003e: [\n        { \n          \u003cspan class=\"hljs-attr\"\u003eprovide\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eAPP_INITIALIZER\u003c/span\u003e, \n          \u003cspan class=\"hljs-attr\"\u003euseFactory\u003c/span\u003e: initializeLogIn, \n          \u003cspan class=\"hljs-attr\"\u003edeps\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eUserFacadeService\u003c/span\u003e], \n          \u003cspan class=\"hljs-attr\"\u003emulti\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e \n        },\n    ],\n    \u003cspan class=\"hljs-attr\"\u003ebootstrap\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e],\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppModule\u003c/span\u003e {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 코드를 분석해봅시다. 우리는 initializeLogIn을 APP_INITIALIZER로 선언하고, 이를 주 애플리케이션 모듈 내의 providers 배열 안에 전달했습니다. 여기서 로그인 시도가 호출되고, UserFacade 소스로부터의 logInRequestHandled$ Observable이 true를 발행할 때까지 기다립니다.\u003c/p\u003e\n\u003cp\u003eAPP_INITIALIZER가 무엇인지 잘 모르겠나요? 해당 주제와 관련된 다른 기사를 확인해보세요:\u003c/p\u003e\n\u003cp\u003e또한 주 애플리케이션 모듈 내에서 Angular common 라이브러리에서 HttpClientModule와 방금 설치한 라이브러리인 OAuthModule을 import 했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e독립 실행 방식 Angular v15:\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { bootstrapApplication } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/platform-browser'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { provideHttpClient } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/common/http'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./app/app.component'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { provideOAuthClient } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'angular-oauth2-oidc'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title function_\"\u003ebootstrapApplication\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003eproviders\u003c/span\u003e: [\n    \u003cspan class=\"hljs-title function_\"\u003eprovideHttpClient\u003c/span\u003e(),\n    \u003cspan class=\"hljs-title function_\"\u003eprovideOAuthClient\u003c/span\u003e(),\n    { \n      \u003cspan class=\"hljs-attr\"\u003eprovide\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eAPP_INITIALIZER\u003c/span\u003e, \n      \u003cspan class=\"hljs-attr\"\u003euseFactory\u003c/span\u003e: initializeLogIn, \n      \u003cspan class=\"hljs-attr\"\u003edeps\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eUserFacadeService\u003c/span\u003e], \n      \u003cspan class=\"hljs-attr\"\u003emulti\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    },\n  ]\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e독립 실행 방식 Angular v14:\u003c/h1\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { bootstrapApplication } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/platform-browser'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eHttpClientModule\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/common/http'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./app/app.component'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { provideOAuthClient } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'angular-oauth2-oidc'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { importProvidersFrom } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@angular/core'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title function_\"\u003ebootstrapApplication\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eAppComponent\u003c/span\u003e, {\n  \u003cspan class=\"hljs-attr\"\u003eproviders\u003c/span\u003e: [\n    importProvidersFrom(\u003cspan class=\"hljs-title class_\"\u003eHttpClientModule\u003c/span\u003e),\n    \u003cspan class=\"hljs-title function_\"\u003eprovideOAuthClient\u003c/span\u003e(),\n    { \n      \u003cspan class=\"hljs-attr\"\u003eprovide\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eAPP_INITIALIZER\u003c/span\u003e, \n      \u003cspan class=\"hljs-attr\"\u003euseFactory\u003c/span\u003e: initializeLogIn, \n      \u003cspan class=\"hljs-attr\"\u003edeps\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eUserFacadeService\u003c/span\u003e], \n      \u003cspan class=\"hljs-attr\"\u003emulti\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n    },\n  ]\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eAngular v14에서는 독립적인 구성 요소가 여전히 실험 단계였고 모든 기능이 과거와 같이 공급자를 갖추지 않았다는 것이 차이점입니다.\u003c/p\u003e\n\u003cp\u003e그게 전부에요, 이제 ngRX 기반의 OIDC 구현이 준비되었습니다!\u003c/p\u003e\n\u003cp\u003e정말 쉬웠죠?\u003c/p\u003e\n\u003cp\u003e프로젝트에 대한 상담이 필요하다면 언제든 연락주세요. 앱을 망치지 마시고 문의해주세요 :-)\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-HowtoimplementOIDCauthenticationwithAngularandngRX"},"buildId":"Y-fCAg8BUV7y2HNFwX9AA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>