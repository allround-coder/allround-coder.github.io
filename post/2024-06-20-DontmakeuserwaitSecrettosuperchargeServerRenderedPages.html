<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages" data-gatsby-head="true"/><meta name="twitter:title" content="사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 01:11" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png">
<p>우리는 빠르게 움직이는 디지털 시대에 살고 있습니다. 사용자들은 내용에 즉시 접근하길 원하기 때문에 웹 사이트의 성능은 매우 중요합니다. 페이지가 느리게 로딩되면 사용자들은 답답함을 느끼고 잠재적인 고객을 놓칠 수 있습니다. 서버 측 렌더링(SSR)은 서버 측에서 HTML을 생성하여 사용자 경험에 부근을 가져다주는 축복처럼 나타났지만, 핵심적으로 최적화되어야 합니다.</p>
<h1>속도에 대한 필요성</h1>
<p>연구는 항상 느린 페이지가 사용자 참여와 전환율에 심각한 영향을 미친다는 것을 발견해왔습니다.</p>
<div class="content-ad"></div>
<p>온라인 소비자들은 판단을 빨리 내립니다. 연구에 따르면, 88%의 사용자는 나쁜 경험 후 웹사이트로 다시 돌아오기를 더욱 꺼립니다.</p>
<p><img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_1.png" alt="이미지"></p>
<p>또 다른 연구에 따르면, 모바일 페이지 로드 시간을 0.1초 줄이면 소매 사이트의 전환율이 8.4% 상승하고 여행 사이트의 경우 10.1% 증가했습니다.</p>
<p><img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_2.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>이거 엄청 커. 그렇기 때문에 웹 성능을 무시할 수 없어요.</p>
<h1>Angelone SSR 아키텍처</h1>
<p>우리는 주요 UI 기술 스택으로 Sveltekit과 tailwind css를 선택했어요.</p>
<p>사용자는 3가지 방법으로 웹 앱에 접근할 수 있어요.</p>
<div class="content-ad"></div>
<ul>
<li>Angelone Android 네이티브 앱</li>
<li>Angelone iOS 네이티브 앱</li>
<li>웹 브라우저</li>
</ul>
<p>네이티브 앱의 경우 웹 앱을 웹뷰 내에서 열고 있습니다.</p>
<p>따라서 앱 내 다양한 부분을 이동할 때 사용자가 연결이 끊어졌다고 느끼지 않도록 성능이 더욱 중요합니다.</p>
<h1>병목 현상 식별 및 해결</h1>
<div class="content-ad"></div>
<p>초기의 SSR 슈퍼차징 단계는 성능 제한 요인을 식별하는 것입니다. 이러한 제한 요인은 서버 측과 브라우저 측에서 발생할 수 있습니다.</p>
<p>서버 측 제한 요인:</p>
<ul>
<li>비효율적인 코드 및 데이터 처리: 최적화되지 않은 코드와 비효율적인 알고리즘은 서버가 HTML을 생성하는 데 느릴 수 있습니다. 분석 및 코드 리팩토링을 통해 이러한 문제를 식별하고 해결할 수 있습니다.</li>
<li>비효율적인 캐싱 전략: SSR에서 캐싱은 중요한 역할을 합니다. 올바르게 구성되지 않은 캐시는 불필요한 재랜더링과 지연을 초래할 수 있습니다. 효율적인 캐싱 메커니즘을 구현하면 성능을 크게 향상시킬 수 있습니다.</li>
<li>네트워크 지연: 서버와 사용자 브라우저 간 데이터 전송에 소요되는 시간은 페이지 로드 시간에 큰 영향을 미칠 수 있습니다. 콘텐츠 전달 네트워크(CDN) 및 엣지 서버를 활용하여 콘텐츠를 사용자에게 더 근접하게 배포하고 지연을 줄일 수 있습니다.</li>
</ul>
<p>브라우저 측 제한 요인:</p>
<div class="content-ad"></div>
<ul>
<li>큰 JavaScript 번들: JavaScript는 상호 작용에 필수적이지만, 큰 번들은 페이지 렌더링을 지연시킬 수 있습니다. 코드 분할과 최소화를 통해 JavaScript 파일의 크기를 줄이고 로드 시간을 개선할 수 있습니다.</li>
<li>최적화되지 않은 DOM 조작: 문서 객체 모델(DOM)의 과도하거나 비효율적인 조작은 성능 문제로 이어질 수 있습니다. DOM 업데이트를 신중히 최적화하면 렌더링 속도를 향상시킬 수 있습니다.</li>
<li>최적화되지 않은 에셋: 큰 이미지, CSS 파일 및 폰트도 페이지 로드 시간을 늦출 수 있습니다. 이러한 에셋을 압축 및 최적화하면 상당한 차이를 만들 수 있습니다.</li>
</ul>
<h1>웹 비탈스(Web Vitals)로 성능 모니터링하기</h1>
<p>Google의 웹 비탈스는 웹 페이지에서 사용자 경험을 측정하고 추적하기 위한 표준화된 메트릭을 제공합니다.</p>
<p><img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_3.png" alt="이미지"></p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_4.png">
<p>여기서 페이지 로드 지표는 다음과 같습니다:</p>
<ul>
<li>가장 큰 콘텐츠 페인트 (LCP): 페이지에서 가장 큰 콘텐츠 요소가 보이기 시작하는 데 걸리는 시간을 측정합니다.</li>
<li>첫 번째 콘텐츠 페인트 (FCP): 사용자가 페이지로 처음 이동한 시점부터 화면에 콘텐츠의 일부가 렌더링되기 시작하는 시간을 측정합니다.</li>
<li>첫 번째 바이트까지의 시간 (TTFB): 리소스 요청과 응답의 첫 번째 바이트가 도착하기 시작하는 시간을 측정하는 지표입니다.</li>
</ul>
<p>이러한 지표를 모니터링하면 최적화가 필요한 영역을 식별하고 노력의 영향을 추적할 수 있습니다.</p>
<div class="content-ad"></div>
<h1>전문가 도구</h1>
<p>SSR 최적화 여정을 돕기 위한 여러 도구들이 있습니다:</p>
<ul>
<li>Lighthouse: 웹 사이트 성능, 접근성 등에 대한 포괄적인 통찰을 제공하는 구글의 오픈소스 도구입니다.</li>
<li>PageSpeed Insights: 페이지 속도 분석과 최적화 제안을 제공하는 또 다른 구글 도구입니다.</li>
<li>WebPageTest: 다양한 조건 하에서 웹 사이트 성능을 측정하는 강력한 도구입니다.</li>
<li>실제 사용자 모니터링(RUM) 데이터: 실제 사용자들이 웹 사이트를 경험하는 방식에 대한 데이터를 수집하여 소중한 현실 세계의 통찰을 제공합니다.</li>
</ul>
<h1>최적화 전략</h1>
<div class="content-ad"></div>
<p>SSR 페이지를 업그레이드하기 위한 주요 최적화 전략 몇 가지를 소개해 드릴게요:</p>
<p>캐싱에 대해 언급할 때, 세 가지 방법으로 구현할 수 있어요</p>
<ul>
<li>단기 - 몇 분</li>
<li>중기 - 몇 시간</li>
<li>장기 - 몇 일</li>
</ul>
<p>우리는 초기 페이지 렌더링에 필요한 API 목록을 식별했고, 자주 변경되지 않는 데이터에 대한 단기 메모리 API 캐싱을 구현했어요.</p>
<div class="content-ad"></div>
<p>아래는 마크다운 형식으로 변경한 내용입니다.</p>
<p><img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_5.png" alt="Image 1"></p>
<p>우리가 이 변경 사항을 배포한 후에는 Backend API에 대한 히트가 급격히 감소했습니다.</p>
<p><img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_6.png" alt="Image 2"></p>
<p>이는 이제 Backend 서버가 다른 중요 사항에 더 많은 시간을 할애하고 더 적은 부하로 인해 더 빠르고 지연 시간이 낮아질 것을 의미합니다.</p>
<div class="content-ad"></div>
<p>우리의 프런트엔드 서버와 백엔드 서버는 같은 가상 사설 클라우드(VPC) 안에 있어요. 이 설정을 활용해서 백엔드 API의 내부 엔드포인트를 호출하기 시작했어요.</p>
<p><img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_7.png" alt="이미지"></p>
<p>장점:</p>
<ul>
<li>성능: 내부 API는 외부 엔드포인트를 통과하는 것보다 더 빠를 수 있어요.</li>
<li>신뢰성: 내부 API는 덜 고장이 날 가능성이 높기 때문에 믿을 만해요.</li>
</ul>
<div class="content-ad"></div>
<p>사용자가 즉시 볼 수 있는 콘텐츠 렌더링을 우선시하세요.</p>
<p><img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_8.png" alt="image"></p>
<p>혜택:</p>
<ul>
<li>html, javascript 및 이미지를 포함한 데이터 양을 줄여 데이터 전송 양을 줄임</li>
<li>즉 브라우저가 더 적은 작업을 해야 하므로 콘텐츠를 보다 빠르게 렌더링할 수 있습니다.</li>
</ul>
<div class="content-ad"></div>
<p>로딩 프로세스 중에 필수 리소스를 미리 가져오세요.</p>
<p>이렇게 하면 스타일이 적용되지 않은 텍스트(Flash of unstyled text, FOUT)가 방지됩니다.</p>
<p><img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_9.png" alt="image1"></p>
<p><img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_10.png" alt="image2"></p>
<div class="content-ad"></div>
<p>Pre-connect은 페이지 상단 콘텐츠가 제 3자 또는 CDN 네트워크에서 에셋이나 이미지를 필요로 하는 경우에 유용합니다.</p>
<p><img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_11.png" alt="이미지"></p>
<p>Pre-connect를 사용하지 않으면 브라우저는 우선 콘텐츠를 다운로드한 후, 다른 출처에 대한 에셋에 따라 특정 콘텐츠를 찾으면, 먼저 제 3자와 연결을 시도한 뒤 연결이 확립되면 콘텐츠를 다운로드하므로 중요한 시간이 소비됩니다.</p>
<p>Pre-connect를 사용하면 브라우저는 우선 콘텐츠를 다운로드하는 동안 제 3자와 연결을 설정하고 필요한 다운로드가 즉시 시작됩니다.</p>
<div class="content-ad"></div>
<p>폰트는 두 가지 방법으로 사용할 수 있어요.</p>
<ul>
<li>구글 폰트, 폰트 어썸 등과 같은 타사 서비스 사용</li>
<li>폰트 자체 호스팅</li>
</ul>
<p>데이터에 따르면 웹 페이지의 20%만이 자체 호스팅된 폰트를 사용하는데, 나머지는 자체 호스팅 + 타사 혹은 단독으로 타사 폰트를 사용하고 있어요.</p>
<p>이전에는 브라우저의 공유 캐시 때문에 타사 폰트를 사용하는 것에 성능상의 이점이 있었어요.</p>
<div class="content-ad"></div>
<p>하지만 Chrome 버전 85부터 Chrome 팀이 캐시 파티션을 도입했는데, 이는 한 웹사이트의 캐시된 리소스를 다른 웹사이트가 사용할 수 없다는 뜻입니다. 따라서 성능 상의 이점이 없어졌습니다.</p>
<p>이에 더해, 써드파티 원본과의 사전 연결(pre-connect)에 대한 추가적인 부담이 있습니다. 이는 고가 소요됩니다.</p>
<p><img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_12.png" alt="이미지"></p>
<p>하지만 자체 호스팅 폰트를 사용하면 도전이 발생합니다. 모든 자체 호스팅 폰트의 제 75 백분위수 크기는 75KB로 매우 큽니다. 이는 폰트가 많은 언어와 문자를 포함하기 때문인데, 대부분의 경우 사이트에서 실제로 필요하지 않은 것입니다.</p>
<div class="content-ad"></div>
<p>저희는 온라인으로 글꼴을 다운로드 받아서 (크기는 63kb였습니다) 모든 불필요한 문자를 제거하여 글꼴 크기를 7.2kb로 줄였어요. 이는 Yellow Lab 도구의 도움으로 88% 감소했습니다.</p>
<p><img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_13.png" alt="이미지"></p>
<h1>최적화의 영향</h1>
<p>다행히도, SSR을 최대한 최적화하는 투자는 매우 좋은 수확을 낼 수 있습니다.</p>
<div class="content-ad"></div>
<p>엔젤 원을 예로 들어보면, FCP 숫자를 1500ms 대신 1230ms로 개선했더니 전환율이 최대 30%까지 상승했습니다.</p>
<p><img src="/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_14.png" alt="이미지"></p>
<p>작은 개선조치라도 비즈니스 결과로 이어질 수 있는 좋은 예시입니다.</p>
<h1>결론</h1>
<div class="content-ad"></div>
<p>요약하자면, 서버 측 렌더링의 최적화는 현대 웹에서 모두에게 이상적인 경험을 제공하기 위해 반드시 해야 합니다.</p>
<p>성능 병목 현상을 최적화하고 웹 핵심 지표를 모니터링하며 적절한 최적화 전략을 활용하면 SSR 페이지를 빠르게 만들어 사용자 참여도를 높이고 전환율을 높이는데 도움이 됩니다.</p>
<p><a href="https://www.youtube.com/watch?v=xUMgwaKkDg4&#x26;ab_channel=DeveloperSummit" rel="nofollow" target="_blank">https://www.youtube.com/watch?v=xUMgwaKkDg4&#x26;ab_channel=DeveloperSummit</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"사용자를 기다리게 하지 마세요 서버 렌더링 페이지를 강화하는 비결","description":"","date":"2024-06-20 01:11","slug":"2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png\" /\u003e\n\n우리는 빠르게 움직이는 디지털 시대에 살고 있습니다. 사용자들은 내용에 즉시 접근하길 원하기 때문에 웹 사이트의 성능은 매우 중요합니다. 페이지가 느리게 로딩되면 사용자들은 답답함을 느끼고 잠재적인 고객을 놓칠 수 있습니다. 서버 측 렌더링(SSR)은 서버 측에서 HTML을 생성하여 사용자 경험에 부근을 가져다주는 축복처럼 나타났지만, 핵심적으로 최적화되어야 합니다.\n\n# 속도에 대한 필요성\n\n연구는 항상 느린 페이지가 사용자 참여와 전환율에 심각한 영향을 미친다는 것을 발견해왔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n온라인 소비자들은 판단을 빨리 내립니다. 연구에 따르면, 88%의 사용자는 나쁜 경험 후 웹사이트로 다시 돌아오기를 더욱 꺼립니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_1.png)\n\n또 다른 연구에 따르면, 모바일 페이지 로드 시간을 0.1초 줄이면 소매 사이트의 전환율이 8.4% 상승하고 여행 사이트의 경우 10.1% 증가했습니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이거 엄청 커. 그렇기 때문에 웹 성능을 무시할 수 없어요.\n\n# Angelone SSR 아키텍처\n\n우리는 주요 UI 기술 스택으로 Sveltekit과 tailwind css를 선택했어요.\n\n사용자는 3가지 방법으로 웹 앱에 접근할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Angelone Android 네이티브 앱\n- Angelone iOS 네이티브 앱\n- 웹 브라우저\n\n네이티브 앱의 경우 웹 앱을 웹뷰 내에서 열고 있습니다.\n\n따라서 앱 내 다양한 부분을 이동할 때 사용자가 연결이 끊어졌다고 느끼지 않도록 성능이 더욱 중요합니다.\n\n# 병목 현상 식별 및 해결\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n초기의 SSR 슈퍼차징 단계는 성능 제한 요인을 식별하는 것입니다. 이러한 제한 요인은 서버 측과 브라우저 측에서 발생할 수 있습니다.\n\n서버 측 제한 요인:\n\n- 비효율적인 코드 및 데이터 처리: 최적화되지 않은 코드와 비효율적인 알고리즘은 서버가 HTML을 생성하는 데 느릴 수 있습니다. 분석 및 코드 리팩토링을 통해 이러한 문제를 식별하고 해결할 수 있습니다.\n- 비효율적인 캐싱 전략: SSR에서 캐싱은 중요한 역할을 합니다. 올바르게 구성되지 않은 캐시는 불필요한 재랜더링과 지연을 초래할 수 있습니다. 효율적인 캐싱 메커니즘을 구현하면 성능을 크게 향상시킬 수 있습니다.\n- 네트워크 지연: 서버와 사용자 브라우저 간 데이터 전송에 소요되는 시간은 페이지 로드 시간에 큰 영향을 미칠 수 있습니다. 콘텐츠 전달 네트워크(CDN) 및 엣지 서버를 활용하여 콘텐츠를 사용자에게 더 근접하게 배포하고 지연을 줄일 수 있습니다.\n\n브라우저 측 제한 요인:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 큰 JavaScript 번들: JavaScript는 상호 작용에 필수적이지만, 큰 번들은 페이지 렌더링을 지연시킬 수 있습니다. 코드 분할과 최소화를 통해 JavaScript 파일의 크기를 줄이고 로드 시간을 개선할 수 있습니다.\n- 최적화되지 않은 DOM 조작: 문서 객체 모델(DOM)의 과도하거나 비효율적인 조작은 성능 문제로 이어질 수 있습니다. DOM 업데이트를 신중히 최적화하면 렌더링 속도를 향상시킬 수 있습니다.\n- 최적화되지 않은 에셋: 큰 이미지, CSS 파일 및 폰트도 페이지 로드 시간을 늦출 수 있습니다. 이러한 에셋을 압축 및 최적화하면 상당한 차이를 만들 수 있습니다.\n\n# 웹 비탈스(Web Vitals)로 성능 모니터링하기\n\nGoogle의 웹 비탈스는 웹 페이지에서 사용자 경험을 측정하고 추적하기 위한 표준화된 메트릭을 제공합니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_4.png\" /\u003e\n\n여기서 페이지 로드 지표는 다음과 같습니다:\n\n- 가장 큰 콘텐츠 페인트 (LCP): 페이지에서 가장 큰 콘텐츠 요소가 보이기 시작하는 데 걸리는 시간을 측정합니다.\n- 첫 번째 콘텐츠 페인트 (FCP): 사용자가 페이지로 처음 이동한 시점부터 화면에 콘텐츠의 일부가 렌더링되기 시작하는 시간을 측정합니다.\n- 첫 번째 바이트까지의 시간 (TTFB): 리소스 요청과 응답의 첫 번째 바이트가 도착하기 시작하는 시간을 측정하는 지표입니다.\n\n이러한 지표를 모니터링하면 최적화가 필요한 영역을 식별하고 노력의 영향을 추적할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 전문가 도구\n\nSSR 최적화 여정을 돕기 위한 여러 도구들이 있습니다:\n\n- Lighthouse: 웹 사이트 성능, 접근성 등에 대한 포괄적인 통찰을 제공하는 구글의 오픈소스 도구입니다.\n- PageSpeed Insights: 페이지 속도 분석과 최적화 제안을 제공하는 또 다른 구글 도구입니다.\n- WebPageTest: 다양한 조건 하에서 웹 사이트 성능을 측정하는 강력한 도구입니다.\n- 실제 사용자 모니터링(RUM) 데이터: 실제 사용자들이 웹 사이트를 경험하는 방식에 대한 데이터를 수집하여 소중한 현실 세계의 통찰을 제공합니다.\n\n# 최적화 전략\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSSR 페이지를 업그레이드하기 위한 주요 최적화 전략 몇 가지를 소개해 드릴게요:\n\n캐싱에 대해 언급할 때, 세 가지 방법으로 구현할 수 있어요\n\n- 단기 - 몇 분\n- 중기 - 몇 시간\n- 장기 - 몇 일\n\n우리는 초기 페이지 렌더링에 필요한 API 목록을 식별했고, 자주 변경되지 않는 데이터에 대한 단기 메모리 API 캐싱을 구현했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 마크다운 형식으로 변경한 내용입니다.\n\n\n![Image 1](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_5.png)\n\n우리가 이 변경 사항을 배포한 후에는 Backend API에 대한 히트가 급격히 감소했습니다.\n\n![Image 2](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_6.png)\n\n이는 이제 Backend 서버가 다른 중요 사항에 더 많은 시간을 할애하고 더 적은 부하로 인해 더 빠르고 지연 시간이 낮아질 것을 의미합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 프런트엔드 서버와 백엔드 서버는 같은 가상 사설 클라우드(VPC) 안에 있어요. 이 설정을 활용해서 백엔드 API의 내부 엔드포인트를 호출하기 시작했어요.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_7.png)\n\n장점:\n- 성능: 내부 API는 외부 엔드포인트를 통과하는 것보다 더 빠를 수 있어요.\n- 신뢰성: 내부 API는 덜 고장이 날 가능성이 높기 때문에 믿을 만해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 즉시 볼 수 있는 콘텐츠 렌더링을 우선시하세요.\n\n![image](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_8.png)\n\n혜택:\n\n- html, javascript 및 이미지를 포함한 데이터 양을 줄여 데이터 전송 양을 줄임\n- 즉 브라우저가 더 적은 작업을 해야 하므로 콘텐츠를 보다 빠르게 렌더링할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로딩 프로세스 중에 필수 리소스를 미리 가져오세요.\n\n이렇게 하면 스타일이 적용되지 않은 텍스트(Flash of unstyled text, FOUT)가 방지됩니다.\n\n![image1](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_9.png)\n\n![image2](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_10.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPre-connect은 페이지 상단 콘텐츠가 제 3자 또는 CDN 네트워크에서 에셋이나 이미지를 필요로 하는 경우에 유용합니다.\n\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_11.png)\n\n\nPre-connect를 사용하지 않으면 브라우저는 우선 콘텐츠를 다운로드한 후, 다른 출처에 대한 에셋에 따라 특정 콘텐츠를 찾으면, 먼저 제 3자와 연결을 시도한 뒤 연결이 확립되면 콘텐츠를 다운로드하므로 중요한 시간이 소비됩니다.\n\nPre-connect를 사용하면 브라우저는 우선 콘텐츠를 다운로드하는 동안 제 3자와 연결을 설정하고 필요한 다운로드가 즉시 시작됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n폰트는 두 가지 방법으로 사용할 수 있어요.\n\n- 구글 폰트, 폰트 어썸 등과 같은 타사 서비스 사용\n- 폰트 자체 호스팅\n\n데이터에 따르면 웹 페이지의 20%만이 자체 호스팅된 폰트를 사용하는데, 나머지는 자체 호스팅 + 타사 혹은 단독으로 타사 폰트를 사용하고 있어요.\n\n이전에는 브라우저의 공유 캐시 때문에 타사 폰트를 사용하는 것에 성능상의 이점이 있었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 Chrome 버전 85부터 Chrome 팀이 캐시 파티션을 도입했는데, 이는 한 웹사이트의 캐시된 리소스를 다른 웹사이트가 사용할 수 없다는 뜻입니다. 따라서 성능 상의 이점이 없어졌습니다.\n\n이에 더해, 써드파티 원본과의 사전 연결(pre-connect)에 대한 추가적인 부담이 있습니다. 이는 고가 소요됩니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_12.png)\n\n하지만 자체 호스팅 폰트를 사용하면 도전이 발생합니다. 모든 자체 호스팅 폰트의 제 75 백분위수 크기는 75KB로 매우 큽니다. 이는 폰트가 많은 언어와 문자를 포함하기 때문인데, 대부분의 경우 사이트에서 실제로 필요하지 않은 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 온라인으로 글꼴을 다운로드 받아서 (크기는 63kb였습니다) 모든 불필요한 문자를 제거하여 글꼴 크기를 7.2kb로 줄였어요. 이는 Yellow Lab 도구의 도움으로 88% 감소했습니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_13.png)\n\n# 최적화의 영향\n\n다행히도, SSR을 최대한 최적화하는 투자는 매우 좋은 수확을 낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n엔젤 원을 예로 들어보면, FCP 숫자를 1500ms 대신 1230ms로 개선했더니 전환율이 최대 30%까지 상승했습니다.\n\n![이미지](/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_14.png)\n\n작은 개선조치라도 비즈니스 결과로 이어질 수 있는 좋은 예시입니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하자면, 서버 측 렌더링의 최적화는 현대 웹에서 모두에게 이상적인 경험을 제공하기 위해 반드시 해야 합니다.\n\n성능 병목 현상을 최적화하고 웹 핵심 지표를 모니터링하며 적절한 최적화 전략을 활용하면 SSR 페이지를 빠르게 만들어 사용자 참여도를 높이고 전환율을 높이는데 도움이 됩니다.\n\nhttps://www.youtube.com/watch?v=xUMgwaKkDg4\u0026ab_channel=DeveloperSummit","ogImage":{"url":"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png"},"coverImage":"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_0.png\"\u003e\n\u003cp\u003e우리는 빠르게 움직이는 디지털 시대에 살고 있습니다. 사용자들은 내용에 즉시 접근하길 원하기 때문에 웹 사이트의 성능은 매우 중요합니다. 페이지가 느리게 로딩되면 사용자들은 답답함을 느끼고 잠재적인 고객을 놓칠 수 있습니다. 서버 측 렌더링(SSR)은 서버 측에서 HTML을 생성하여 사용자 경험에 부근을 가져다주는 축복처럼 나타났지만, 핵심적으로 최적화되어야 합니다.\u003c/p\u003e\n\u003ch1\u003e속도에 대한 필요성\u003c/h1\u003e\n\u003cp\u003e연구는 항상 느린 페이지가 사용자 참여와 전환율에 심각한 영향을 미친다는 것을 발견해왔습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e온라인 소비자들은 판단을 빨리 내립니다. 연구에 따르면, 88%의 사용자는 나쁜 경험 후 웹사이트로 다시 돌아오기를 더욱 꺼립니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e또 다른 연구에 따르면, 모바일 페이지 로드 시간을 0.1초 줄이면 소매 사이트의 전환율이 8.4% 상승하고 여행 사이트의 경우 10.1% 증가했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이거 엄청 커. 그렇기 때문에 웹 성능을 무시할 수 없어요.\u003c/p\u003e\n\u003ch1\u003eAngelone SSR 아키텍처\u003c/h1\u003e\n\u003cp\u003e우리는 주요 UI 기술 스택으로 Sveltekit과 tailwind css를 선택했어요.\u003c/p\u003e\n\u003cp\u003e사용자는 3가지 방법으로 웹 앱에 접근할 수 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eAngelone Android 네이티브 앱\u003c/li\u003e\n\u003cli\u003eAngelone iOS 네이티브 앱\u003c/li\u003e\n\u003cli\u003e웹 브라우저\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e네이티브 앱의 경우 웹 앱을 웹뷰 내에서 열고 있습니다.\u003c/p\u003e\n\u003cp\u003e따라서 앱 내 다양한 부분을 이동할 때 사용자가 연결이 끊어졌다고 느끼지 않도록 성능이 더욱 중요합니다.\u003c/p\u003e\n\u003ch1\u003e병목 현상 식별 및 해결\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e초기의 SSR 슈퍼차징 단계는 성능 제한 요인을 식별하는 것입니다. 이러한 제한 요인은 서버 측과 브라우저 측에서 발생할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e서버 측 제한 요인:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e비효율적인 코드 및 데이터 처리: 최적화되지 않은 코드와 비효율적인 알고리즘은 서버가 HTML을 생성하는 데 느릴 수 있습니다. 분석 및 코드 리팩토링을 통해 이러한 문제를 식별하고 해결할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e비효율적인 캐싱 전략: SSR에서 캐싱은 중요한 역할을 합니다. 올바르게 구성되지 않은 캐시는 불필요한 재랜더링과 지연을 초래할 수 있습니다. 효율적인 캐싱 메커니즘을 구현하면 성능을 크게 향상시킬 수 있습니다.\u003c/li\u003e\n\u003cli\u003e네트워크 지연: 서버와 사용자 브라우저 간 데이터 전송에 소요되는 시간은 페이지 로드 시간에 큰 영향을 미칠 수 있습니다. 콘텐츠 전달 네트워크(CDN) 및 엣지 서버를 활용하여 콘텐츠를 사용자에게 더 근접하게 배포하고 지연을 줄일 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e브라우저 측 제한 요인:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e큰 JavaScript 번들: JavaScript는 상호 작용에 필수적이지만, 큰 번들은 페이지 렌더링을 지연시킬 수 있습니다. 코드 분할과 최소화를 통해 JavaScript 파일의 크기를 줄이고 로드 시간을 개선할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e최적화되지 않은 DOM 조작: 문서 객체 모델(DOM)의 과도하거나 비효율적인 조작은 성능 문제로 이어질 수 있습니다. DOM 업데이트를 신중히 최적화하면 렌더링 속도를 향상시킬 수 있습니다.\u003c/li\u003e\n\u003cli\u003e최적화되지 않은 에셋: 큰 이미지, CSS 파일 및 폰트도 페이지 로드 시간을 늦출 수 있습니다. 이러한 에셋을 압축 및 최적화하면 상당한 차이를 만들 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e웹 비탈스(Web Vitals)로 성능 모니터링하기\u003c/h1\u003e\n\u003cp\u003eGoogle의 웹 비탈스는 웹 페이지에서 사용자 경험을 측정하고 추적하기 위한 표준화된 메트릭을 제공합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_4.png\"\u003e\n\u003cp\u003e여기서 페이지 로드 지표는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e가장 큰 콘텐츠 페인트 (LCP): 페이지에서 가장 큰 콘텐츠 요소가 보이기 시작하는 데 걸리는 시간을 측정합니다.\u003c/li\u003e\n\u003cli\u003e첫 번째 콘텐츠 페인트 (FCP): 사용자가 페이지로 처음 이동한 시점부터 화면에 콘텐츠의 일부가 렌더링되기 시작하는 시간을 측정합니다.\u003c/li\u003e\n\u003cli\u003e첫 번째 바이트까지의 시간 (TTFB): 리소스 요청과 응답의 첫 번째 바이트가 도착하기 시작하는 시간을 측정하는 지표입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 지표를 모니터링하면 최적화가 필요한 영역을 식별하고 노력의 영향을 추적할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e전문가 도구\u003c/h1\u003e\n\u003cp\u003eSSR 최적화 여정을 돕기 위한 여러 도구들이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLighthouse: 웹 사이트 성능, 접근성 등에 대한 포괄적인 통찰을 제공하는 구글의 오픈소스 도구입니다.\u003c/li\u003e\n\u003cli\u003ePageSpeed Insights: 페이지 속도 분석과 최적화 제안을 제공하는 또 다른 구글 도구입니다.\u003c/li\u003e\n\u003cli\u003eWebPageTest: 다양한 조건 하에서 웹 사이트 성능을 측정하는 강력한 도구입니다.\u003c/li\u003e\n\u003cli\u003e실제 사용자 모니터링(RUM) 데이터: 실제 사용자들이 웹 사이트를 경험하는 방식에 대한 데이터를 수집하여 소중한 현실 세계의 통찰을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e최적화 전략\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eSSR 페이지를 업그레이드하기 위한 주요 최적화 전략 몇 가지를 소개해 드릴게요:\u003c/p\u003e\n\u003cp\u003e캐싱에 대해 언급할 때, 세 가지 방법으로 구현할 수 있어요\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e단기 - 몇 분\u003c/li\u003e\n\u003cli\u003e중기 - 몇 시간\u003c/li\u003e\n\u003cli\u003e장기 - 몇 일\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e우리는 초기 페이지 렌더링에 필요한 API 목록을 식별했고, 자주 변경되지 않는 데이터에 대한 단기 메모리 API 캐싱을 구현했어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 마크다운 형식으로 변경한 내용입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_5.png\" alt=\"Image 1\"\u003e\u003c/p\u003e\n\u003cp\u003e우리가 이 변경 사항을 배포한 후에는 Backend API에 대한 히트가 급격히 감소했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_6.png\" alt=\"Image 2\"\u003e\u003c/p\u003e\n\u003cp\u003e이는 이제 Backend 서버가 다른 중요 사항에 더 많은 시간을 할애하고 더 적은 부하로 인해 더 빠르고 지연 시간이 낮아질 것을 의미합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리의 프런트엔드 서버와 백엔드 서버는 같은 가상 사설 클라우드(VPC) 안에 있어요. 이 설정을 활용해서 백엔드 API의 내부 엔드포인트를 호출하기 시작했어요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e장점:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e성능: 내부 API는 외부 엔드포인트를 통과하는 것보다 더 빠를 수 있어요.\u003c/li\u003e\n\u003cli\u003e신뢰성: 내부 API는 덜 고장이 날 가능성이 높기 때문에 믿을 만해요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e사용자가 즉시 볼 수 있는 콘텐츠 렌더링을 우선시하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_8.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e혜택:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ehtml, javascript 및 이미지를 포함한 데이터 양을 줄여 데이터 전송 양을 줄임\u003c/li\u003e\n\u003cli\u003e즉 브라우저가 더 적은 작업을 해야 하므로 콘텐츠를 보다 빠르게 렌더링할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e로딩 프로세스 중에 필수 리소스를 미리 가져오세요.\u003c/p\u003e\n\u003cp\u003e이렇게 하면 스타일이 적용되지 않은 텍스트(Flash of unstyled text, FOUT)가 방지됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_9.png\" alt=\"image1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_10.png\" alt=\"image2\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003ePre-connect은 페이지 상단 콘텐츠가 제 3자 또는 CDN 네트워크에서 에셋이나 이미지를 필요로 하는 경우에 유용합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_11.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003ePre-connect를 사용하지 않으면 브라우저는 우선 콘텐츠를 다운로드한 후, 다른 출처에 대한 에셋에 따라 특정 콘텐츠를 찾으면, 먼저 제 3자와 연결을 시도한 뒤 연결이 확립되면 콘텐츠를 다운로드하므로 중요한 시간이 소비됩니다.\u003c/p\u003e\n\u003cp\u003ePre-connect를 사용하면 브라우저는 우선 콘텐츠를 다운로드하는 동안 제 3자와 연결을 설정하고 필요한 다운로드가 즉시 시작됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e폰트는 두 가지 방법으로 사용할 수 있어요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e구글 폰트, 폰트 어썸 등과 같은 타사 서비스 사용\u003c/li\u003e\n\u003cli\u003e폰트 자체 호스팅\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e데이터에 따르면 웹 페이지의 20%만이 자체 호스팅된 폰트를 사용하는데, 나머지는 자체 호스팅 + 타사 혹은 단독으로 타사 폰트를 사용하고 있어요.\u003c/p\u003e\n\u003cp\u003e이전에는 브라우저의 공유 캐시 때문에 타사 폰트를 사용하는 것에 성능상의 이점이 있었어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e하지만 Chrome 버전 85부터 Chrome 팀이 캐시 파티션을 도입했는데, 이는 한 웹사이트의 캐시된 리소스를 다른 웹사이트가 사용할 수 없다는 뜻입니다. 따라서 성능 상의 이점이 없어졌습니다.\u003c/p\u003e\n\u003cp\u003e이에 더해, 써드파티 원본과의 사전 연결(pre-connect)에 대한 추가적인 부담이 있습니다. 이는 고가 소요됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_12.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e하지만 자체 호스팅 폰트를 사용하면 도전이 발생합니다. 모든 자체 호스팅 폰트의 제 75 백분위수 크기는 75KB로 매우 큽니다. 이는 폰트가 많은 언어와 문자를 포함하기 때문인데, 대부분의 경우 사이트에서 실제로 필요하지 않은 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저희는 온라인으로 글꼴을 다운로드 받아서 (크기는 63kb였습니다) 모든 불필요한 문자를 제거하여 글꼴 크기를 7.2kb로 줄였어요. 이는 Yellow Lab 도구의 도움으로 88% 감소했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_13.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e최적화의 영향\u003c/h1\u003e\n\u003cp\u003e다행히도, SSR을 최대한 최적화하는 투자는 매우 좋은 수확을 낼 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e엔젤 원을 예로 들어보면, FCP 숫자를 1500ms 대신 1230ms로 개선했더니 전환율이 최대 30%까지 상승했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages_14.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e작은 개선조치라도 비즈니스 결과로 이어질 수 있는 좋은 예시입니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e요약하자면, 서버 측 렌더링의 최적화는 현대 웹에서 모두에게 이상적인 경험을 제공하기 위해 반드시 해야 합니다.\u003c/p\u003e\n\u003cp\u003e성능 병목 현상을 최적화하고 웹 핵심 지표를 모니터링하며 적절한 최적화 전략을 활용하면 SSR 페이지를 빠르게 만들어 사용자 참여도를 높이고 전환율을 높이는데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.youtube.com/watch?v=xUMgwaKkDg4\u0026#x26;ab_channel=DeveloperSummit\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.youtube.com/watch?v=xUMgwaKkDg4\u0026#x26;ab_channel=DeveloperSummit\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-DontmakeuserwaitSecrettosuperchargeServerRenderedPages"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>