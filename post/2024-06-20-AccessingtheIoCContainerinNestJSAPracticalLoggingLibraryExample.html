<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>NestJS에서 IoC 컨테이너에 접근하기 실용적인 로깅 라이브러리 예제 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="NestJS에서 IoC 컨테이너에 접근하기 실용적인 로깅 라이브러리 예제 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="NestJS에서 IoC 컨테이너에 접근하기 실용적인 로깅 라이브러리 예제 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample" data-gatsby-head="true"/><meta name="twitter:title" content="NestJS에서 IoC 컨테이너에 접근하기 실용적인 로깅 라이브러리 예제 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 04:34" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_buildManifest.js" defer=""></script><script src="/_next/static/Rv-NbbtWUaja2joH5WkO_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">NestJS에서 IoC 컨테이너에 접근하기 실용적인 로깅 라이브러리 예제</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="NestJS에서 IoC 컨테이너에 접근하기 실용적인 로깅 라이브러리 예제" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png" alt="2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png"></p>
<p>안녕하세요! 이 세부적인 자습서에서는 NestJS 프로젝트를 만들고 특정 메타데이터가 지정된 모든 프로바이더 및 컨트롤러의 메서드 호출을 동적으로 탐지하고 기록하는 로깅 라이브러리를 구축할 것입니다. 이 예제는 IoC(Inversion of Control) 컨테이너에 액세스하고 등록된 프로바이더 및 컨트롤러를 조사하며 사용자 정의 데코레이터를 사용하여 동적 동작을 적용하는 방법을 이해하는 데 도움이 될 것입니다.</p>
<h1>IoC 컨테이너란?</h1>
<p>NestJS의 IoC 컨테이너는 애플리케이션 구성 요소의 생성, 설정 및 라이프사이클을 관리하여 의존성 주입을 가능하게 합니다. 이는 컨테이너가 필요한 클래스에 자동으로 의존성을 제공하는 의존성 주입을 허용합니다.</p>
<div class="content-ad"></div>
<h1>IoC 컨테이너에 접근하는 이유</h1>
<p>IoC 컨테이너에 접근하는 것은 다음과 같은 이유로 매우 중요합니다:</p>
<ul>
<li>살펴보기: 등록된 제공자(Providers) 및 컨트롤러(Controllers)를 모두 검사하기 위해.</li>
<li>동적 동작: 로깅, 모니터링 또는 메타데이터를 기반으로 동작을 수정하는 등 동적 동작을 적용하기 위해.</li>
<li>일반 라이브러리: 다양한 응용프로그램 구성 요소와 동적으로 상호작용해야 하는 라이브러리를 구축하기 위해.</li>
</ul>
<h1>단계별 안내</h1>
<div class="content-ad"></div>
<p>NestJS 프로젝트를 만들고 동적 로깅 라이브러리를 빌드하는 단계를 함께 진행해 보겠습니다.</p>
<h2>단계 1: NestJS 프로젝트 설정하기</h2>
<ul>
<li>NestJS CLI를 설치합니다:</li>
</ul>
<pre><code class="hljs language-js">npm install -g @nestjs/cli
</code></pre>
<div class="content-ad"></div>
<ol start="2">
<li>새로운 NestJS 프로젝트 만들기:</li>
</ol>
<pre><code class="hljs language-js">nest <span class="hljs-keyword">new</span> logging-library
cd logging-library
</code></pre>
<ol start="3">
<li>필수 종속성 설치:</li>
</ol>
<pre><code class="hljs language-js">npm install @nestjs/core @nestjs/common @nestjs-plus/discovery
</code></pre>
<div class="content-ad"></div>
<h2>단계 2: LoggerService 생성하기</h2>
<p>NestJS 라이프사이클 훅을 사용하여 메서드 호출 로깅을 동적으로 설정하고 지우는 LoggerService를 생성합니다.</p>
<ul>
<li>LoggerService 생성하기:</li>
</ul>
<pre><code class="hljs language-js">nest generate service logger
</code></pre>
<div class="content-ad"></div>
<ol start="2">
<li>LoggerService를 구현하세요:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/logger/logger.service.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span>, <span class="hljs-title class_">OnApplicationBootstrap</span>, <span class="hljs-title class_">OnApplicationShutdown</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">DiscoveryService</span>, <span class="hljs-title class_">Reflector</span>, <span class="hljs-title class_">MetadataScanner</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerService</span> implements <span class="hljs-title class_">OnApplicationBootstrap</span>, <span class="hljs-title class_">OnApplicationShutdown</span> {
  <span class="hljs-comment">// 원본 메소드를 저장하고 종료 시 복원하기 위한 Map</span>
  private readonly <span class="hljs-attr">originals</span>: <span class="hljs-title class_">Map</span>&#x3C;any, any> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">
    <span class="hljs-comment">// DiscoveryService는 모든 프로바이더와 컨트롤러를 찾기 위해 사용됩니다.</span>
    private readonly discoveryService: DiscoveryService,
    <span class="hljs-comment">// Reflector는 클래스와 메소드에서 메타데이터를 읽기 위해 사용됩니다.</span>
    private readonly reflector: Reflector,
    <span class="hljs-comment">// MetadataScanner는 클래스 프로토타입을 메소드 이름으로 스캔하기 위해 사용됩니다.</span>
    private readonly metadataScanner: MetadataScanner
  </span>) {}

  <span class="hljs-comment">// 모든 모듈이 초기화된 후에 실행되는 라이프사이클 훅</span>
  <span class="hljs-title function_">onApplicationBootstrap</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 애플리케이션에서 모든 프로바이더(컨트롤러 포함)를 가져옵니다.</span>
    <span class="hljs-keyword">const</span> providers = <span class="hljs-variable language_">this</span>.<span class="hljs-property">discoveryService</span>.<span class="hljs-title function_">getProviders</span>();
    providers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">wrapper</span>) =></span> {
      <span class="hljs-comment">// 프로바이더의 인스턴스(실제 객체) 가져오기</span>
      <span class="hljs-keyword">const</span> { instance } = wrapper;
      <span class="hljs-comment">// 프로바이더의 프로토타입(모든 인스턴스에서 공유되는 메소드와 속성) 가져오기</span>
      <span class="hljs-keyword">const</span> prototype = instance &#x26;&#x26; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(instance);
      <span class="hljs-comment">// 인스턴스나 프로토타입이 없는 경우 건너뜁니다.</span>
      <span class="hljs-keyword">if</span> (!instance || !prototype) {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-comment">// 클래스가 @Loggable로 표시되어 있는지 확인합니다.</span>
      <span class="hljs-keyword">const</span> isLoggable = <span class="hljs-variable language_">this</span>.<span class="hljs-property">reflector</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'LOGGABLE_KEY'</span>, instance.<span class="hljs-property">constructor</span>) ?? <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (!isLoggable) {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-comment">// 클래스 프로토타입에서 모든 메소드 이름 가져오기</span>
      <span class="hljs-keyword">const</span> methodKeys = <span class="hljs-variable language_">this</span>.<span class="hljs-property">metadataScanner</span>.<span class="hljs-title function_">getAllMethodNames</span>(prototype);
      methodKeys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">methodKey</span>) =></span> {
        <span class="hljs-comment">// 이름으로 메소드 가져오기</span>
        <span class="hljs-keyword">const</span> method = instance[methodKey];
        <span class="hljs-comment">// 함수(메소드)인지 확인합니다.</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> method === <span class="hljs-string">'function'</span>) {
          <span class="hljs-comment">// 원본 메소드 저장</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">originals</span>.<span class="hljs-title function_">set</span>(method, method.<span class="hljs-title function_">bind</span>(instance));
          <span class="hljs-comment">// 원본 메소드를 로깅 래퍼로 대체합니다.</span>
          instance[methodKey] = <span class="hljs-function">(<span class="hljs-params">...args: any[]</span>) =></span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Calling <span class="hljs-subst">${methodKey}</span> with args:`</span>, args);
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">originals</span>.<span class="hljs-title function_">get</span>(method)(...args);
          };
        }
      });
    });
  }

  <span class="hljs-comment">// 애플리케이션이 종료되기 전에 실행되는 라이프사이클 훅</span>
  <span class="hljs-title function_">onApplicationShutdown</span>(<span class="hljs-params">signal?: string</span>) {
    <span class="hljs-comment">// 모든 원본 메소드를 복원합니다.</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">originals</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">original, method</span>) =></span> {
      method = original;
    });
    <span class="hljs-comment">// 원본 메소드 Map을 비웁니다.</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">originals</span>.<span class="hljs-title function_">clear</span>();
  }
}
</code></pre>
<ul>
<li>Instance: IoC 컨테이너에서 생성된 실제 객체입니다. 이는 응용프로그램에서 상호작용하는 실시간 객체입니다.</li>
<li>Prototype: 객체의 청사진입니다. 클래스의 모든 인스턴스간에 공유되는 메소드와 속성이 포함되어 있습니다. 프로토타입을 사용하면 클래스 메소드의 동적 조회 및 수정이 가능합니다.</li>
</ul>
<h1>로깅 메소드의 상세 설명</h1>
<div class="content-ad"></div>
<p>코드의 일부를 더 깊이 파헤쳐 보겠습니다. 여기서는 로깅 기능을 가진 메소드를 동적으로 래핑하는 부분에 집중해 봅시다:</p>
<pre><code class="hljs language-js">methodKeys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">methodKey</span>) =></span> {
  <span class="hljs-comment">// 메소드 이름으로 메소드를 가져옵니다</span>
  <span class="hljs-keyword">const</span> method = instance[methodKey];
  <span class="hljs-comment">// 속성이 함수(메소드)인지 확인합니다</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> method === <span class="hljs-string">'function'</span>) {
    <span class="hljs-comment">// 원본 메소드를 저장합니다</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">originals</span>.<span class="hljs-title function_">set</span>(method, method.<span class="hljs-title function_">bind</span>(instance));
    <span class="hljs-comment">// 원본 메소드를 로깅 래퍼로 교체합니다</span>
    instance[methodKey] = <span class="hljs-function">(<span class="hljs-params">...args: any[]</span>) =></span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${methodKey}</span>를 인수와 함께 호출 중:`</span>, args);
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">originals</span>.<span class="hljs-title function_">get</span>(method)(...args);
    };
  }
});
</code></pre>
<h2>단계별 설명</h2>
<div class="content-ad"></div>
<pre><code class="hljs language-js">methodKeys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">methodKey</span>) =></span> {
</code></pre>
<ul>
<li>methodKeys: 프로바이더의 프로토타입에 있는 모든 메서드 이름의 배열입니다.</li>
</ul>
<ol start="2">
<li>이름으로 메서드 가져오기:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> method = instance[methodKey];
</code></pre>
<div class="content-ad"></div>
<ul>
<li>instance[methodKey]: 이름(key)으로 인스턴스의 메서드에 액세스합니다.</li>
<li>method: 실제 메서드 함수에 대한 참조를 보유합니다.</li>
</ul>
<ol start="3">
<li>속성이 함수인지 확인합니다:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> method === <span class="hljs-string">'function'</span>) {
</code></pre>
<ul>
<li>속성이 실제로 함수이고 다른 유형의 속성(예: 변수)이 아님을 보장합니다.</li>
</ul>
<div class="content-ad"></div>
<ol start="4">
<li>원본 메소드 저장:</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">originals</span>.<span class="hljs-title function_">set</span>(method, method.<span class="hljs-title function_">bind</span>(instance));
</code></pre>
<ul>
<li>this.originals: 원본 메소드 참조를 저장하는 Map 객체입니다.</li>
<li>set(method, method.bind(instance)): 해당 메소드를 인스턴스에 바인딩하여 저장하여 메소드가 호출될 때 올바른 컨텍스트(this)를 유지합니다.</li>
</ul>
<ol start="5">
<li>원본 메소드를 로깅 래퍼로 대체하기:</li>
</ol>
<div class="content-ad"></div>
<pre><code class="hljs language-js">instance[methodKey] = <span class="hljs-function">(<span class="hljs-params">...args: any[]</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Calling <span class="hljs-subst">${methodKey}</span> with args:`</span>, args);
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">originals</span>.<span class="hljs-title function_">get</span>(method)(...args);
};
</code></pre>
<ul>
<li>instance[methodKey]: 기존 메소드를 새 함수로 대체합니다.</li>
<li>(...args: any[]): '...'는 새 함수를 나타내며:</li>
<li>메소드 호출과 인수를 기록합니다.</li>
<li>this.originals에 저장된 참조를 사용하여 원본 메소드를 호출합니다.</li>
</ul>
<h1>실제 예시</h1>
<p>createUser 및 deleteUser 메소드를 갖는 UserService 클래스가 있다고 가정해보겠습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">@<span class="hljs-title class_">Loggable</span>
@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
  <span class="hljs-title function_">createUser</span>(<span class="hljs-params">name: string</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`User <span class="hljs-subst">${name}</span> created.`</span>);
  }

  <span class="hljs-title function_">deleteUser</span>(<span class="hljs-params">id: number</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`User with id <span class="hljs-subst">${id}</span> deleted.`</span>);
  }
}
</code></pre>
<p>LoggerService가 초기화될 때 다음을 합니다:</p>
<ul>
<li>UserService 제공자를 탐색합니다.</li>
<li>UserService에 @Loggable이 표시되어 있는지 확인합니다.</li>
<li>UserService의 각 메서드(예: createUser 및 deleteUser)에 대해</li>
<li>원본 메서드를 저장합니다.</li>
<li>원본 메서드를 호출하기 전에 호출과 매개변수를 기록하는 새 함수로 메서드를 대체합니다</li>
</ul>
<h2>단계 3: 사용자 정의 데코레이터 정의하기</h2>
<div class="content-ad"></div>
<p>클래스 및 메서드에 로깅을 위한 표시를 지정하기 위해 @Loggable 데코레이터를 정의합니다.</p>
<p>데코레이터를 생성하세요:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/logger/loggable.decorator.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">SetMetadata</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

<span class="hljs-comment">// loggable 메타데이터를 위한 키</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">LOGGABLE_KEY</span> = <span class="hljs-string">'LOGGABLE_KEY'</span>;
<span class="hljs-comment">// 로깅을 위해 클래스를 표시하는 Loggable 데코레이터</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">Loggable</span>: <span class="hljs-title class_">ClassDecorator</span> = <span class="hljs-title class_">SetMetadata</span>(<span class="hljs-variable constant_">LOGGABLE_KEY</span>, <span class="hljs-literal">true</span>);
</code></pre>
<h2>스텝 4: 사용자 지정 데코레이터 사용하기</h2>
<div class="content-ad"></div>
<p>@Service 클래스에서 @Loggable 데코레이터를 사용하여 로깅해야 하는 메서드를 생성하세요.</p>
<ul>
<li>서비스 생성:</li>
</ul>
<pre><code class="hljs language-js">nest generate service user
</code></pre>
<ol start="2">
<li>UserService를 구현하세요.</li>
</ol>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/user/user.service.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Loggable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'../logger/loggable.decorator'</span>;

<span class="hljs-comment">// UserService 클래스를 로깅하기 위해 표시합니다</span>
@<span class="hljs-title class_">Loggable</span>
@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
  <span class="hljs-comment">// 사용자 생성 메서드</span>
  <span class="hljs-title function_">createUser</span>(<span class="hljs-params">name: string</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`사용자 <span class="hljs-subst">${name}</span>이(가) 생성되었습니다.`</span>);
  }

  <span class="hljs-comment">// 사용자 삭제 메서드</span>
  <span class="hljs-title function_">deleteUser</span>(<span class="hljs-params">id: number</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`ID가 <span class="hljs-subst">${id}</span>인 사용자가 삭제되었습니다.`</span>);
  }
}
</code></pre>
<ol start="3">
<li>로깅을 테스트하기 위해 UserController를 생성합니다:</li>
</ol>
<pre><code class="hljs language-bash">nest generate controller user
</code></pre>
<ol start="4">
<li>UserController를 구현합니다:</li>
</ol>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/user/user.controller.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Post</span>, <span class="hljs-title class_">Body</span>, <span class="hljs-title class_">Delete</span>, <span class="hljs-title class_">Param</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UserService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./user.service'</span>;

@<span class="hljs-title class_">Controller</span>(<span class="hljs-string">'users'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private readonly userService: UserService</span>) {}

  @<span class="hljs-title class_">Post</span>()
  <span class="hljs-title function_">createUser</span>(<span class="hljs-params">@Body(<span class="hljs-string">'name'</span>) name: string</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">userService</span>.<span class="hljs-title function_">createUser</span>(name);
  }

  @<span class="hljs-title class_">Delete</span>(<span class="hljs-string">':id'</span>)
  <span class="hljs-title function_">deleteUser</span>(<span class="hljs-params">@Param(<span class="hljs-string">'id'</span>) id: number</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">userService</span>.<span class="hljs-title function_">deleteUser</span>(id);
  }
}
</code></pre>
<ol start="5">
<li>Step 5: AppModule에서 LoggerService 통합</li>
</ol>
<p>LoggerService와 UserController가 응용 프로그램 모듈에 포함되어 있는지 확인하십시오.</p>
<p>AppModule 업데이트:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">// src/app.module.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Module</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">DiscoveryModule</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/core'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">LoggerService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./logger/logger.service'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UserService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./user/user.service'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UserController</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./user/user.controller'</span>;

@<span class="hljs-title class_">Module</span>({
  <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">DiscoveryModule</span>],
  <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">LoggerService</span>, <span class="hljs-title class_">UserService</span>],
  <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">UserController</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppModule</span> {
  <span class="hljs-comment">// Inject LoggerService to initialize it on application start</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private readonly loggerService: LoggerService</span>) {}
}
</code></pre>
<h2>단계 6: 로깅 테스트</h2>
<p>curl을 사용하여 엔드포인트를 테스트하고 로깅 기능을 확인할 수 있습니다.</p>
<ul>
<li>유저 생성:</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-bash"><span class="hljs-comment"># 사용자 추가:</span>
curl -X POST http://localhost:3000/users -H <span class="hljs-string">"Content-Type: application/json"</span> -d <span class="hljs-string">'{"name": "John Doe"}'</span>
</code></pre>
<ol start="2">
<li>사용자 삭제:</li>
</ol>
<pre><code class="hljs language-bash">curl -X DELETE http://localhost:3000/users/1
</code></pre>
<h1>결과</h1>
<div class="content-ad"></div>
<pre><code class="hljs language-js">createUser을 다음과 같은 args와 함께 호출했습니다: [<span class="hljs-string">'John Doe'</span>]
사용자 <span class="hljs-title class_">John</span> <span class="hljs-title class_">Doe</span>가 생성되었습니다.
deleteUser을 다음과 같은 args와 함께 호출했습니다: [<span class="hljs-string">'1'</span>]
id가 <span class="hljs-number">1</span>인 사용자가 삭제되었습니다.
</code></pre>
<h1>요약</h1>
<p>이 지침을 따라 NestJS 프로젝트를 생성하고, 특정 메타데이터로 표시된 모든 프로바이더 및 컨트롤러에 대한 메서드 호출을 동적으로 기록하는 로깅 라이브러리를 구축했습니다. 이 튜토리얼은 NestJS의 IoC 컨테이너에 액세스하여 등록된 프로바이더 및 컨트롤러를 검사하고 동적 동작을 적용하는 방법을 보여주었습니다.</p>
<p>사용자 지정 데코레이터와 메타데이터 반사를 활용하여 메서드 호출을 기록하는 유연한 시스템을 구축하여, NestJS의 강력한 IoC 컨테이너를 활용하여 고급 사용 사례에 대처하는 방법을 시연했습니다. 이 접근 방식은 NestJS 애플리케이션의 다른 부분과 동적으로 상호작용해야 하는 다양한 제네릭 및 통합 라이브러리를 구축하기 위해 확장할 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"NestJS에서 IoC 컨테이너에 접근하기 실용적인 로깅 라이브러리 예제","description":"","date":"2024-06-20 04:34","slug":"2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample","content":"\n\n![2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png](/assets/img/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png)\n\n안녕하세요! 이 세부적인 자습서에서는 NestJS 프로젝트를 만들고 특정 메타데이터가 지정된 모든 프로바이더 및 컨트롤러의 메서드 호출을 동적으로 탐지하고 기록하는 로깅 라이브러리를 구축할 것입니다. 이 예제는 IoC(Inversion of Control) 컨테이너에 액세스하고 등록된 프로바이더 및 컨트롤러를 조사하며 사용자 정의 데코레이터를 사용하여 동적 동작을 적용하는 방법을 이해하는 데 도움이 될 것입니다.\n\n# IoC 컨테이너란?\n\nNestJS의 IoC 컨테이너는 애플리케이션 구성 요소의 생성, 설정 및 라이프사이클을 관리하여 의존성 주입을 가능하게 합니다. 이는 컨테이너가 필요한 클래스에 자동으로 의존성을 제공하는 의존성 주입을 허용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# IoC 컨테이너에 접근하는 이유\n\nIoC 컨테이너에 접근하는 것은 다음과 같은 이유로 매우 중요합니다:\n\n- 살펴보기: 등록된 제공자(Providers) 및 컨트롤러(Controllers)를 모두 검사하기 위해.\n- 동적 동작: 로깅, 모니터링 또는 메타데이터를 기반으로 동작을 수정하는 등 동적 동작을 적용하기 위해.\n- 일반 라이브러리: 다양한 응용프로그램 구성 요소와 동적으로 상호작용해야 하는 라이브러리를 구축하기 위해.\n\n# 단계별 안내\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNestJS 프로젝트를 만들고 동적 로깅 라이브러리를 빌드하는 단계를 함께 진행해 보겠습니다.\n\n## 단계 1: NestJS 프로젝트 설정하기\n\n- NestJS CLI를 설치합니다:\n\n```js\nnpm install -g @nestjs/cli\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 새로운 NestJS 프로젝트 만들기:\n\n```js\nnest new logging-library\ncd logging-library\n```\n\n3. 필수 종속성 설치:\n\n```js\nnpm install @nestjs/core @nestjs/common @nestjs-plus/discovery\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 2: LoggerService 생성하기\n\nNestJS 라이프사이클 훅을 사용하여 메서드 호출 로깅을 동적으로 설정하고 지우는 LoggerService를 생성합니다.\n\n- LoggerService 생성하기:\n\n```js\nnest generate service logger\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. LoggerService를 구현하세요:\n\n```js\n// src/logger/logger.service.ts\nimport { Injectable, OnApplicationBootstrap, OnApplicationShutdown } from '@nestjs/common';\nimport { DiscoveryService, Reflector, MetadataScanner } from '@nestjs/core';\n\n@Injectable()\nexport class LoggerService implements OnApplicationBootstrap, OnApplicationShutdown {\n  // 원본 메소드를 저장하고 종료 시 복원하기 위한 Map\n  private readonly originals: Map\u003cany, any\u003e = new Map();\n\n  constructor(\n    // DiscoveryService는 모든 프로바이더와 컨트롤러를 찾기 위해 사용됩니다.\n    private readonly discoveryService: DiscoveryService,\n    // Reflector는 클래스와 메소드에서 메타데이터를 읽기 위해 사용됩니다.\n    private readonly reflector: Reflector,\n    // MetadataScanner는 클래스 프로토타입을 메소드 이름으로 스캔하기 위해 사용됩니다.\n    private readonly metadataScanner: MetadataScanner\n  ) {}\n\n  // 모든 모듈이 초기화된 후에 실행되는 라이프사이클 훅\n  onApplicationBootstrap() {\n    // 애플리케이션에서 모든 프로바이더(컨트롤러 포함)를 가져옵니다.\n    const providers = this.discoveryService.getProviders();\n    providers.forEach((wrapper) =\u003e {\n      // 프로바이더의 인스턴스(실제 객체) 가져오기\n      const { instance } = wrapper;\n      // 프로바이더의 프로토타입(모든 인스턴스에서 공유되는 메소드와 속성) 가져오기\n      const prototype = instance \u0026\u0026 Object.getPrototypeOf(instance);\n      // 인스턴스나 프로토타입이 없는 경우 건너뜁니다.\n      if (!instance || !prototype) {\n        return;\n      }\n      // 클래스가 @Loggable로 표시되어 있는지 확인합니다.\n      const isLoggable = this.reflector.get('LOGGABLE_KEY', instance.constructor) ?? false;\n      if (!isLoggable) {\n        return;\n      }\n      // 클래스 프로토타입에서 모든 메소드 이름 가져오기\n      const methodKeys = this.metadataScanner.getAllMethodNames(prototype);\n      methodKeys.forEach((methodKey) =\u003e {\n        // 이름으로 메소드 가져오기\n        const method = instance[methodKey];\n        // 함수(메소드)인지 확인합니다.\n        if (typeof method === 'function') {\n          // 원본 메소드 저장\n          this.originals.set(method, method.bind(instance));\n          // 원본 메소드를 로깅 래퍼로 대체합니다.\n          instance[methodKey] = (...args: any[]) =\u003e {\n            console.log(`Calling ${methodKey} with args:`, args);\n            return this.originals.get(method)(...args);\n          };\n        }\n      });\n    });\n  }\n\n  // 애플리케이션이 종료되기 전에 실행되는 라이프사이클 훅\n  onApplicationShutdown(signal?: string) {\n    // 모든 원본 메소드를 복원합니다.\n    this.originals.forEach((original, method) =\u003e {\n      method = original;\n    });\n    // 원본 메소드 Map을 비웁니다.\n    this.originals.clear();\n  }\n}\n```\n\n- Instance: IoC 컨테이너에서 생성된 실제 객체입니다. 이는 응용프로그램에서 상호작용하는 실시간 객체입니다.\n- Prototype: 객체의 청사진입니다. 클래스의 모든 인스턴스간에 공유되는 메소드와 속성이 포함되어 있습니다. 프로토타입을 사용하면 클래스 메소드의 동적 조회 및 수정이 가능합니다.\n\n# 로깅 메소드의 상세 설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드의 일부를 더 깊이 파헤쳐 보겠습니다. 여기서는 로깅 기능을 가진 메소드를 동적으로 래핑하는 부분에 집중해 봅시다:\n\n```js\nmethodKeys.forEach((methodKey) =\u003e {\n  // 메소드 이름으로 메소드를 가져옵니다\n  const method = instance[methodKey];\n  // 속성이 함수(메소드)인지 확인합니다\n  if (typeof method === 'function') {\n    // 원본 메소드를 저장합니다\n    this.originals.set(method, method.bind(instance));\n    // 원본 메소드를 로깅 래퍼로 교체합니다\n    instance[methodKey] = (...args: any[]) =\u003e {\n      console.log(`${methodKey}를 인수와 함께 호출 중:`, args);\n      return this.originals.get(method)(...args);\n    };\n  }\n});\n```\n\n## 단계별 설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmethodKeys.forEach((methodKey) =\u003e {\n```\n\n- methodKeys: 프로바이더의 프로토타입에 있는 모든 메서드 이름의 배열입니다.\n\n2. 이름으로 메서드 가져오기:\n\n```js\nconst method = instance[methodKey];\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- instance[methodKey]: 이름(key)으로 인스턴스의 메서드에 액세스합니다.\n- method: 실제 메서드 함수에 대한 참조를 보유합니다.\n\n3. 속성이 함수인지 확인합니다:\n\n```js\nif (typeof method === 'function') {\n```\n\n- 속성이 실제로 함수이고 다른 유형의 속성(예: 변수)이 아님을 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 원본 메소드 저장:\n\n```js\nthis.originals.set(method, method.bind(instance));\n```\n\n- this.originals: 원본 메소드 참조를 저장하는 Map 객체입니다.\n- set(method, method.bind(instance)): 해당 메소드를 인스턴스에 바인딩하여 저장하여 메소드가 호출될 때 올바른 컨텍스트(this)를 유지합니다.\n\n5. 원본 메소드를 로깅 래퍼로 대체하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ninstance[methodKey] = (...args: any[]) =\u003e {\n  console.log(`Calling ${methodKey} with args:`, args);\n  return this.originals.get(method)(...args);\n};\n```\n\n- instance[methodKey]: 기존 메소드를 새 함수로 대체합니다.\n- (...args: any[]): '...'는 새 함수를 나타내며:\n- 메소드 호출과 인수를 기록합니다.\n- this.originals에 저장된 참조를 사용하여 원본 메소드를 호출합니다.\n\n# 실제 예시\n\ncreateUser 및 deleteUser 메소드를 갖는 UserService 클래스가 있다고 가정해보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@Loggable\n@Injectable()\nexport class UserService {\n  createUser(name: string) {\n    console.log(`User ${name} created.`);\n  }\n\n  deleteUser(id: number) {\n    console.log(`User with id ${id} deleted.`);\n  }\n}\n```\n\nLoggerService가 초기화될 때 다음을 합니다:\n\n- UserService 제공자를 탐색합니다.\n- UserService에 @Loggable이 표시되어 있는지 확인합니다.\n- UserService의 각 메서드(예: createUser 및 deleteUser)에 대해\n- 원본 메서드를 저장합니다.\n- 원본 메서드를 호출하기 전에 호출과 매개변수를 기록하는 새 함수로 메서드를 대체합니다\n\n## 단계 3: 사용자 정의 데코레이터 정의하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클래스 및 메서드에 로깅을 위한 표시를 지정하기 위해 @Loggable 데코레이터를 정의합니다.\n\n데코레이터를 생성하세요:\n\n```js\n// src/logger/loggable.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\n// loggable 메타데이터를 위한 키\nexport const LOGGABLE_KEY = 'LOGGABLE_KEY';\n// 로깅을 위해 클래스를 표시하는 Loggable 데코레이터\nexport const Loggable: ClassDecorator = SetMetadata(LOGGABLE_KEY, true);\n```\n\n## 스텝 4: 사용자 지정 데코레이터 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n@Service 클래스에서 @Loggable 데코레이터를 사용하여 로깅해야 하는 메서드를 생성하세요.\n\n- 서비스 생성:\n\n```js\nnest generate service user\n```\n\n2. UserService를 구현하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// src/user/user.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { Loggable } from '../logger/loggable.decorator';\n\n// UserService 클래스를 로깅하기 위해 표시합니다\n@Loggable\n@Injectable()\nexport class UserService {\n  // 사용자 생성 메서드\n  createUser(name: string) {\n    console.log(`사용자 ${name}이(가) 생성되었습니다.`);\n  }\n\n  // 사용자 삭제 메서드\n  deleteUser(id: number) {\n    console.log(`ID가 ${id}인 사용자가 삭제되었습니다.`);\n  }\n}\n```\n\n3. 로깅을 테스트하기 위해 UserController를 생성합니다:\n\n```bash\nnest generate controller user\n```\n\n4. UserController를 구현합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// src/user/user.controller.ts\nimport { Controller, Post, Body, Delete, Param } from '@nestjs/common';\nimport { UserService } from './user.service';\n\n@Controller('users')\nexport class UserController {\n  constructor(private readonly userService: UserService) {}\n\n  @Post()\n  createUser(@Body('name') name: string) {\n    return this.userService.createUser(name);\n  }\n\n  @Delete(':id')\n  deleteUser(@Param('id') id: number) {\n    return this.userService.deleteUser(id);\n  }\n}\n```\n\n5. Step 5: AppModule에서 LoggerService 통합\n\nLoggerService와 UserController가 응용 프로그램 모듈에 포함되어 있는지 확인하십시오.\n\nAppModule 업데이트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// src/app.module.ts\nimport { Module } from '@nestjs/common';\nimport { DiscoveryModule } from '@nestjs/core';\nimport { LoggerService } from './logger/logger.service';\nimport { UserService } from './user/user.service';\nimport { UserController } from './user/user.controller';\n\n@Module({\n  imports: [DiscoveryModule],\n  providers: [LoggerService, UserService],\n  controllers: [UserController],\n})\nexport class AppModule {\n  // Inject LoggerService to initialize it on application start\n  constructor(private readonly loggerService: LoggerService) {}\n}\n```\n\n## 단계 6: 로깅 테스트\n\ncurl을 사용하여 엔드포인트를 테스트하고 로깅 기능을 확인할 수 있습니다.\n\n- 유저 생성:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n# 사용자 추가:\ncurl -X POST http://localhost:3000/users -H \"Content-Type: application/json\" -d '{\"name\": \"John Doe\"}'\n```\n\n2. 사용자 삭제:\n\n```bash\ncurl -X DELETE http://localhost:3000/users/1\n```\n\n# 결과\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncreateUser을 다음과 같은 args와 함께 호출했습니다: ['John Doe']\n사용자 John Doe가 생성되었습니다.\ndeleteUser을 다음과 같은 args와 함께 호출했습니다: ['1']\nid가 1인 사용자가 삭제되었습니다.\n```\n\n# 요약\n\n이 지침을 따라 NestJS 프로젝트를 생성하고, 특정 메타데이터로 표시된 모든 프로바이더 및 컨트롤러에 대한 메서드 호출을 동적으로 기록하는 로깅 라이브러리를 구축했습니다. 이 튜토리얼은 NestJS의 IoC 컨테이너에 액세스하여 등록된 프로바이더 및 컨트롤러를 검사하고 동적 동작을 적용하는 방법을 보여주었습니다.\n\n사용자 지정 데코레이터와 메타데이터 반사를 활용하여 메서드 호출을 기록하는 유연한 시스템을 구축하여, NestJS의 강력한 IoC 컨테이너를 활용하여 고급 사용 사례에 대처하는 방법을 시연했습니다. 이 접근 방식은 NestJS 애플리케이션의 다른 부분과 동적으로 상호작용해야 하는 다양한 제네릭 및 통합 라이브러리를 구축하기 위해 확장할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png"},"coverImage":"/assets/img/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png\" alt=\"2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample_0.png\"\u003e\u003c/p\u003e\n\u003cp\u003e안녕하세요! 이 세부적인 자습서에서는 NestJS 프로젝트를 만들고 특정 메타데이터가 지정된 모든 프로바이더 및 컨트롤러의 메서드 호출을 동적으로 탐지하고 기록하는 로깅 라이브러리를 구축할 것입니다. 이 예제는 IoC(Inversion of Control) 컨테이너에 액세스하고 등록된 프로바이더 및 컨트롤러를 조사하며 사용자 정의 데코레이터를 사용하여 동적 동작을 적용하는 방법을 이해하는 데 도움이 될 것입니다.\u003c/p\u003e\n\u003ch1\u003eIoC 컨테이너란?\u003c/h1\u003e\n\u003cp\u003eNestJS의 IoC 컨테이너는 애플리케이션 구성 요소의 생성, 설정 및 라이프사이클을 관리하여 의존성 주입을 가능하게 합니다. 이는 컨테이너가 필요한 클래스에 자동으로 의존성을 제공하는 의존성 주입을 허용합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eIoC 컨테이너에 접근하는 이유\u003c/h1\u003e\n\u003cp\u003eIoC 컨테이너에 접근하는 것은 다음과 같은 이유로 매우 중요합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e살펴보기: 등록된 제공자(Providers) 및 컨트롤러(Controllers)를 모두 검사하기 위해.\u003c/li\u003e\n\u003cli\u003e동적 동작: 로깅, 모니터링 또는 메타데이터를 기반으로 동작을 수정하는 등 동적 동작을 적용하기 위해.\u003c/li\u003e\n\u003cli\u003e일반 라이브러리: 다양한 응용프로그램 구성 요소와 동적으로 상호작용해야 하는 라이브러리를 구축하기 위해.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e단계별 안내\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eNestJS 프로젝트를 만들고 동적 로깅 라이브러리를 빌드하는 단계를 함께 진행해 보겠습니다.\u003c/p\u003e\n\u003ch2\u003e단계 1: NestJS 프로젝트 설정하기\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eNestJS CLI를 설치합니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install -g @nestjs/cli\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e새로운 NestJS 프로젝트 만들기:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enest \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e logging-library\ncd logging-library\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e필수 종속성 설치:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enpm install @nestjs/core @nestjs/common @nestjs-plus/discovery\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e단계 2: LoggerService 생성하기\u003c/h2\u003e\n\u003cp\u003eNestJS 라이프사이클 훅을 사용하여 메서드 호출 로깅을 동적으로 설정하고 지우는 LoggerService를 생성합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLoggerService 생성하기:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enest generate service logger\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eLoggerService를 구현하세요:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/logger/logger.service.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOnApplicationBootstrap\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOnApplicationShutdown\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eDiscoveryService\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eReflector\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eMetadataScanner\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/core'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLoggerService\u003c/span\u003e implements \u003cspan class=\"hljs-title class_\"\u003eOnApplicationBootstrap\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eOnApplicationShutdown\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 원본 메소드를 저장하고 종료 시 복원하기 위한 Map\u003c/span\u003e\n  private readonly \u003cspan class=\"hljs-attr\"\u003eoriginals\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e\u0026#x3C;any, any\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMap\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// DiscoveryService는 모든 프로바이더와 컨트롤러를 찾기 위해 사용됩니다.\u003c/span\u003e\n    private readonly discoveryService: DiscoveryService,\n    \u003cspan class=\"hljs-comment\"\u003e// Reflector는 클래스와 메소드에서 메타데이터를 읽기 위해 사용됩니다.\u003c/span\u003e\n    private readonly reflector: Reflector,\n    \u003cspan class=\"hljs-comment\"\u003e// MetadataScanner는 클래스 프로토타입을 메소드 이름으로 스캔하기 위해 사용됩니다.\u003c/span\u003e\n    private readonly metadataScanner: MetadataScanner\n  \u003c/span\u003e) {}\n\n  \u003cspan class=\"hljs-comment\"\u003e// 모든 모듈이 초기화된 후에 실행되는 라이프사이클 훅\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003eonApplicationBootstrap\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 애플리케이션에서 모든 프로바이더(컨트롤러 포함)를 가져옵니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e providers = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ediscoveryService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetProviders\u003c/span\u003e();\n    providers.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ewrapper\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// 프로바이더의 인스턴스(실제 객체) 가져오기\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { instance } = wrapper;\n      \u003cspan class=\"hljs-comment\"\u003e// 프로바이더의 프로토타입(모든 인스턴스에서 공유되는 메소드와 속성) 가져오기\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e prototype = instance \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetPrototypeOf\u003c/span\u003e(instance);\n      \u003cspan class=\"hljs-comment\"\u003e// 인스턴스나 프로토타입이 없는 경우 건너뜁니다.\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!instance || !prototype) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n      }\n      \u003cspan class=\"hljs-comment\"\u003e// 클래스가 @Loggable로 표시되어 있는지 확인합니다.\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isLoggable = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ereflector\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'LOGGABLE_KEY'\u003c/span\u003e, instance.\u003cspan class=\"hljs-property\"\u003econstructor\u003c/span\u003e) ?? \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!isLoggable) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n      }\n      \u003cspan class=\"hljs-comment\"\u003e// 클래스 프로토타입에서 모든 메소드 이름 가져오기\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e methodKeys = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emetadataScanner\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetAllMethodNames\u003c/span\u003e(prototype);\n      methodKeys.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emethodKey\u003c/span\u003e) =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// 이름으로 메소드 가져오기\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e method = instance[methodKey];\n        \u003cspan class=\"hljs-comment\"\u003e// 함수(메소드)인지 확인합니다.\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e method === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n          \u003cspan class=\"hljs-comment\"\u003e// 원본 메소드 저장\u003c/span\u003e\n          \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoriginals\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(method, method.\u003cspan class=\"hljs-title function_\"\u003ebind\u003c/span\u003e(instance));\n          \u003cspan class=\"hljs-comment\"\u003e// 원본 메소드를 로깅 래퍼로 대체합니다.\u003c/span\u003e\n          instance[methodKey] = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) =\u003e\u003c/span\u003e {\n            \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Calling \u003cspan class=\"hljs-subst\"\u003e${methodKey}\u003c/span\u003e with args:`\u003c/span\u003e, args);\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoriginals\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(method)(...args);\n          };\n        }\n      });\n    });\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 애플리케이션이 종료되기 전에 실행되는 라이프사이클 훅\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003eonApplicationShutdown\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esignal?: string\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 모든 원본 메소드를 복원합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoriginals\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eoriginal, method\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      method = original;\n    });\n    \u003cspan class=\"hljs-comment\"\u003e// 원본 메소드 Map을 비웁니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoriginals\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eclear\u003c/span\u003e();\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eInstance: IoC 컨테이너에서 생성된 실제 객체입니다. 이는 응용프로그램에서 상호작용하는 실시간 객체입니다.\u003c/li\u003e\n\u003cli\u003ePrototype: 객체의 청사진입니다. 클래스의 모든 인스턴스간에 공유되는 메소드와 속성이 포함되어 있습니다. 프로토타입을 사용하면 클래스 메소드의 동적 조회 및 수정이 가능합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e로깅 메소드의 상세 설명\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e코드의 일부를 더 깊이 파헤쳐 보겠습니다. 여기서는 로깅 기능을 가진 메소드를 동적으로 래핑하는 부분에 집중해 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emethodKeys.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emethodKey\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 메소드 이름으로 메소드를 가져옵니다\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e method = instance[methodKey];\n  \u003cspan class=\"hljs-comment\"\u003e// 속성이 함수(메소드)인지 확인합니다\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e method === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 원본 메소드를 저장합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoriginals\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(method, method.\u003cspan class=\"hljs-title function_\"\u003ebind\u003c/span\u003e(instance));\n    \u003cspan class=\"hljs-comment\"\u003e// 원본 메소드를 로깅 래퍼로 교체합니다\u003c/span\u003e\n    instance[methodKey] = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) =\u003e\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${methodKey}\u003c/span\u003e를 인수와 함께 호출 중:`\u003c/span\u003e, args);\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoriginals\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(method)(...args);\n    };\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e단계별 설명\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emethodKeys.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emethodKey\u003c/span\u003e) =\u003e\u003c/span\u003e {\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003emethodKeys: 프로바이더의 프로토타입에 있는 모든 메서드 이름의 배열입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e이름으로 메서드 가져오기:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e method = instance[methodKey];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003einstance[methodKey]: 이름(key)으로 인스턴스의 메서드에 액세스합니다.\u003c/li\u003e\n\u003cli\u003emethod: 실제 메서드 함수에 대한 참조를 보유합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e속성이 함수인지 확인합니다:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e method === \u003cspan class=\"hljs-string\"\u003e'function'\u003c/span\u003e) {\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e속성이 실제로 함수이고 다른 유형의 속성(예: 변수)이 아님을 보장합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e원본 메소드 저장:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoriginals\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(method, method.\u003cspan class=\"hljs-title function_\"\u003ebind\u003c/span\u003e(instance));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003ethis.originals: 원본 메소드 참조를 저장하는 Map 객체입니다.\u003c/li\u003e\n\u003cli\u003eset(method, method.bind(instance)): 해당 메소드를 인스턴스에 바인딩하여 저장하여 메소드가 호출될 때 올바른 컨텍스트(this)를 유지합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e원본 메소드를 로깅 래퍼로 대체하기:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einstance[methodKey] = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e...args: any[]\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Calling \u003cspan class=\"hljs-subst\"\u003e${methodKey}\u003c/span\u003e with args:`\u003c/span\u003e, args);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoriginals\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(method)(...args);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003einstance[methodKey]: 기존 메소드를 새 함수로 대체합니다.\u003c/li\u003e\n\u003cli\u003e(...args: any[]): '...'는 새 함수를 나타내며:\u003c/li\u003e\n\u003cli\u003e메소드 호출과 인수를 기록합니다.\u003c/li\u003e\n\u003cli\u003ethis.originals에 저장된 참조를 사용하여 원본 메소드를 호출합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e실제 예시\u003c/h1\u003e\n\u003cp\u003ecreateUser 및 deleteUser 메소드를 갖는 UserService 클래스가 있다고 가정해보겠습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e@\u003cspan class=\"hljs-title class_\"\u003eLoggable\u003c/span\u003e\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserService\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003ecreateUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename: string\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`User \u003cspan class=\"hljs-subst\"\u003e${name}\u003c/span\u003e created.`\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003edeleteUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eid: number\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`User with id \u003cspan class=\"hljs-subst\"\u003e${id}\u003c/span\u003e deleted.`\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLoggerService가 초기화될 때 다음을 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUserService 제공자를 탐색합니다.\u003c/li\u003e\n\u003cli\u003eUserService에 @Loggable이 표시되어 있는지 확인합니다.\u003c/li\u003e\n\u003cli\u003eUserService의 각 메서드(예: createUser 및 deleteUser)에 대해\u003c/li\u003e\n\u003cli\u003e원본 메서드를 저장합니다.\u003c/li\u003e\n\u003cli\u003e원본 메서드를 호출하기 전에 호출과 매개변수를 기록하는 새 함수로 메서드를 대체합니다\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e단계 3: 사용자 정의 데코레이터 정의하기\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e클래스 및 메서드에 로깅을 위한 표시를 지정하기 위해 @Loggable 데코레이터를 정의합니다.\u003c/p\u003e\n\u003cp\u003e데코레이터를 생성하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/logger/loggable.decorator.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eSetMetadata\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// loggable 메타데이터를 위한 키\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLOGGABLE_KEY\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'LOGGABLE_KEY'\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 로깅을 위해 클래스를 표시하는 Loggable 데코레이터\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLoggable\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eClassDecorator\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eSetMetadata\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eLOGGABLE_KEY\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e스텝 4: 사용자 지정 데코레이터 사용하기\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e@Service 클래스에서 @Loggable 데코레이터를 사용하여 로깅해야 하는 메서드를 생성하세요.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e서비스 생성:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003enest generate service user\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eUserService를 구현하세요.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/user/user.service.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eLoggable\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'../logger/loggable.decorator'\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// UserService 클래스를 로깅하기 위해 표시합니다\u003c/span\u003e\n@\u003cspan class=\"hljs-title class_\"\u003eLoggable\u003c/span\u003e\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserService\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 사용자 생성 메서드\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003ecreateUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ename: string\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`사용자 \u003cspan class=\"hljs-subst\"\u003e${name}\u003c/span\u003e이(가) 생성되었습니다.`\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 사용자 삭제 메서드\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003edeleteUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eid: number\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`ID가 \u003cspan class=\"hljs-subst\"\u003e${id}\u003c/span\u003e인 사용자가 삭제되었습니다.`\u003c/span\u003e);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e로깅을 테스트하기 위해 UserController를 생성합니다:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003enest generate controller user\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eUserController를 구현합니다:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/user/user.controller.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003ePost\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eBody\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eDelete\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eParam\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eUserService\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./user.service'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'users'\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserController\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate readonly userService: UserService\u003c/span\u003e) {}\n\n  @\u003cspan class=\"hljs-title class_\"\u003ePost\u003c/span\u003e()\n  \u003cspan class=\"hljs-title function_\"\u003ecreateUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e@Body(\u003cspan class=\"hljs-string\"\u003e'name'\u003c/span\u003e) name: string\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003euserService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateUser\u003c/span\u003e(name);\n  }\n\n  @\u003cspan class=\"hljs-title class_\"\u003eDelete\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e':id'\u003c/span\u003e)\n  \u003cspan class=\"hljs-title function_\"\u003edeleteUser\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e@Param(\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e) id: number\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003euserService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edeleteUser\u003c/span\u003e(id);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003eStep 5: AppModule에서 LoggerService 통합\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eLoggerService와 UserController가 응용 프로그램 모듈에 포함되어 있는지 확인하십시오.\u003c/p\u003e\n\u003cp\u003eAppModule 업데이트:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// src/app.module.ts\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eModule\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eDiscoveryModule\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/core'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eLoggerService\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./logger/logger.service'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eUserService\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./user/user.service'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eUserController\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./user/user.controller'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eModule\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eimports\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eDiscoveryModule\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003eproviders\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eLoggerService\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eUserService\u003c/span\u003e],\n  \u003cspan class=\"hljs-attr\"\u003econtrollers\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eUserController\u003c/span\u003e],\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAppModule\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// Inject LoggerService to initialize it on application start\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate readonly loggerService: LoggerService\u003c/span\u003e) {}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e단계 6: 로깅 테스트\u003c/h2\u003e\n\u003cp\u003ecurl을 사용하여 엔드포인트를 테스트하고 로깅 기능을 확인할 수 있습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e유저 생성:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 사용자 추가:\u003c/span\u003e\ncurl -X POST http://localhost:3000/users -H \u003cspan class=\"hljs-string\"\u003e\"Content-Type: application/json\"\u003c/span\u003e -d \u003cspan class=\"hljs-string\"\u003e'{\"name\": \"John Doe\"}'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e사용자 삭제:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ecurl -X DELETE http://localhost:3000/users/1\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결과\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecreateUser을 다음과 같은 args와 함께 호출했습니다: [\u003cspan class=\"hljs-string\"\u003e'John Doe'\u003c/span\u003e]\n사용자 \u003cspan class=\"hljs-title class_\"\u003eJohn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDoe\u003c/span\u003e가 생성되었습니다.\ndeleteUser을 다음과 같은 args와 함께 호출했습니다: [\u003cspan class=\"hljs-string\"\u003e'1'\u003c/span\u003e]\nid가 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e인 사용자가 삭제되었습니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003e이 지침을 따라 NestJS 프로젝트를 생성하고, 특정 메타데이터로 표시된 모든 프로바이더 및 컨트롤러에 대한 메서드 호출을 동적으로 기록하는 로깅 라이브러리를 구축했습니다. 이 튜토리얼은 NestJS의 IoC 컨테이너에 액세스하여 등록된 프로바이더 및 컨트롤러를 검사하고 동적 동작을 적용하는 방법을 보여주었습니다.\u003c/p\u003e\n\u003cp\u003e사용자 지정 데코레이터와 메타데이터 반사를 활용하여 메서드 호출을 기록하는 유연한 시스템을 구축하여, NestJS의 강력한 IoC 컨테이너를 활용하여 고급 사용 사례에 대처하는 방법을 시연했습니다. 이 접근 방식은 NestJS 애플리케이션의 다른 부분과 동적으로 상호작용해야 하는 다양한 제네릭 및 통합 라이브러리를 구축하기 위해 확장할 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-AccessingtheIoCContainerinNestJSAPracticalLoggingLibraryExample"},"buildId":"Rv-NbbtWUaja2joH5WkO_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>