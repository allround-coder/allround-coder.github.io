<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Nodejs에서 Middleware 구현하기 Expressjs와 Koajs의 비교 연구 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Nodejs에서 Middleware 구현하기 Expressjs와 Koajs의 비교 연구 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Nodejs에서 Middleware 구현하기 Expressjs와 Koajs의 비교 연구 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs" data-gatsby-head="true"/><meta name="twitter:title" content="Nodejs에서 Middleware 구현하기 Expressjs와 Koajs의 비교 연구 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-14 15:39" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_buildManifest.js" defer=""></script><script src="/_next/static/K-h7XvEVBqnNx_uXMgZoe/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Nodejs에서 Middleware 구현하기 Expressjs와 Koajs의 비교 연구</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Nodejs에서 Middleware 구현하기 Expressjs와 Koajs의 비교 연구" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 14, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><img src="/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png"/>
<h2>BACK-END DEVELOPMENT</h2>
<h1>Introduction</h1>
<img src="/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_1.png"/>
<p>안녕하세요! 미들웨어는 요청 및 응답 객체에서 작동하는 함수로, 종종 이러한 객체들을 최종 라우트 핸들러에 도달하기 전에 정보를 변경하거나 추가하거나 처리하는 방식으로 작동하기 때문에 서버 측 프로그래밍의 중요한 부분이 되었습니다.</p>
<p>이러한 미들웨어의 유틸리티를 고려하면, 서버 측 기술들은 종종 이러한 도구의 개발과 사용을 용이하게 하는 프레임워크를 제공합니다. 본 문서에서는 Node.js 생태계에서 두 가지 인기 있는 프레임워크인 Express.js와 Koa.js에 대해 다룹니다.</p>
<h2>Express.js와 Koa.js</h2>
<p>Express.js는 Node.js를 위한 표준 서버 프레임워크로 인정받고 있으며 강력한 미들웨어 시스템을 포함한 강력한 기능들로 웹 개발의 풍경을 형성하는 데 중요한 역할을 하고 있습니다. 반면에 Koa.js는 Express.js를 개발한 팀에 의해 개발된 Node.js를 위한 최신 웹 프레임워크로, 더 작고 표현력이 뛰어나며 웹 애플리케이션과 API를 위한 훨씬 견고한 기반을 제공하려고 합니다. 이 프레임워크는 핵심에 어떤 미들웨어도 번들로 제공하지 않아 개발자들에게 더 많은 제어와 자유를 제공합니다.</p>
<h2>사례 연구</h2>
<p>이 문서는 Express.js와 Koa.js의 미들웨어 구현 능력에 중점을 두고 깊이 있는 비교를 제공합니다. 또한 인증, 권한 부여, 자세한 요청 분석 로깅 및 책 요청 로깅 및 유효성 검사와 같은 예시들을 탐구합니다. 이러한 예시들은 실제 사용 사례인 약학 마이크로서비스를 통해 설명될 것입니다. 이 서비스는 의약품 목록을 관리하고 새로운 의약품을 필요할 때 매입하여 추적하는 역할을 담당합니다.</p>
<h1>Express.js를 이용한 미들웨어 구현</h1>
<p><img src="/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_2.png" alt="이미지"/></p>
<h2>Express.js: 간단한 개요</h2>
<p>Express.js 또는 Express는 Node.js를 위한 강력한 백엔드 웹 애플리케이션 프레임워크로 널리 알려져 있습니다. 그 간결함, 유연성, 확장성으로 칭찬받고 있으며, MEAN/MERN 스택(MongoDB, Express, Angular/React, Node.js)의 필수 구성 요소이기도 합니다. 간소한 성격에도 불구하고, 라우팅, 템플릿 엔진, 미들웨어, 오류 처리 등의 기능을 포함한 강력한 기능을 자랑합니다.</p>
<h2>Express.js가 미들웨어를 처리하는 방식</h2>
<p>Express의 핵심은 미들웨어 시스템입니다. 미들웨어는 요청 객체(req), 응답 객체(res), 및 응용 프로그램의 요청-응답 주기 내의 다음 미들웨어 함수에 접근 권한이 있는 함수들입니다. 이들은 코드를 실행하거나 요청 및 응답 객체를 변경하며 요청-응답 주기를 종료하거나 다음 미들웨어 함수에 제어를 전달할 수 있습니다.</p>
<p>이 미들웨어 파이프라인은 개발자가 중요한 유연성을 제공하여 애플리케이션의 고유한 요구 사항에 맞춰 미들웨어 기능을 추가하고 계층화할 수 있도록 합니다.</p>
<h2>Express 미들웨어 예시</h2>
<p>의약품 마이크로서비스 시나리오를 살펴보면 Express를 사용하여 필요한 미들웨어 기능을 구현하는 방법을 알아볼 수 있습니다. 인증(Authentication), 권한 부여(Authorization), 분석을 위한 요청 로깅(Request Logging) 및 도서 요청 로깅 및 유효성 검사(Book Request Logging &amp; Validation)가 포함됩니다.</p>
<p>인증 미들웨어 — 인증은 사용자, 프로세스 또는 시스템의 신원을 확인하는 과정이며, Express에서는 미들웨어를 사용하여 유효 자격 증명이 있는지 확인하기 위해 요청 헤더를 검사하여 들어오는 요청을 인증할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">auth</span>(<span class="hljs-params">req, res, next</span>) {
  <span class="hljs-keyword">const</span> token = req.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;auth-token&#x27;</span>);
  <span class="hljs-keyword">if</span> (!token) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">401</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Access Denied&#x27;</span>);

  <span class="hljs-comment">// 토큰을 확인하고 계속 진행</span>
  <span class="hljs-comment">// ...</span>
  <span class="hljs-title function_">next</span>();
}
</code></pre>
<p>인증 미들웨어 — 인증 후에 사용되는 인가는, 인증된 사용자가 어떤 자원에 액세스할 수 있는지 결정하는 것이며, 다시 한 번 Express 미들웨어가 유용하게 사용됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">authorize</span>(<span class="hljs-params">req, res, next</span>) {
  <span class="hljs-keyword">const</span> user = req.<span class="hljs-property">user</span>;
  <span class="hljs-keyword">if</span> (!user || !user.<span class="hljs-property">isAdmin</span>) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">403</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Unauthorized access.&#x27;</span>);

  <span class="hljs-title function_">next</span>();
}
</code></pre>
<p>로깅 미들웨어 — 그리고 우리는 로깅에 도달했습니다. 로깅은 애플리케이션 활동 추적과 디버깅에 중요하며, 여기 Express 미들웨어를 사용해 요청 세부 정보를 로깅할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">req, res, next</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`요청 방법이 <span class="hljs-subst">${req.method}</span>이고 URL이 <span class="hljs-subst">${req.url}</span>인 요청을 받았습니다. 시간: <span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>`</span>);
  <span class="hljs-title function_">next</span>();
}
</code></pre>
<p>도서 요청 로깅 및 유효성 검사 미들웨어 — 재고에 새로운 약품을 추가하는 경로와 같은 특정 경로를 다룰 때, 미들웨어는 요청 데이터를 유효성 검사하고 요청을 로그에 남길 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">validateAndLogBookRequest</span>(<span class="hljs-params">req, res, next</span>) {
  <span class="hljs-comment">// 요청 데이터 유효성 검사 (Joi와 같은 라이브러리 사용 가능)</span>
  <span class="hljs-comment">// 유효하지 않으면 &#x27;400 Bad Request&#x27; 응답 반환</span>

  <span class="hljs-comment">// 도서 요청 로깅</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`도서 요청이 <span class="hljs-subst">${req.body.drugName}</span>인 요청을 받았습니다. 시간: <span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>`</span>);

  <span class="hljs-title function_">next</span>();
}
</code></pre>
<h2>더 알아보기:</h2>
<h1>미들웨어 구현을 위한 Koa.js</h1>
<img src="/assets/img/2024-05-14-Nodejs에서의미들웨어구현Expressjs와Koajs의비교연구_3.png"/>
<p>Koa.js 또는 간단히 Koa는 Express 팀이 디자인한 웹 프레임워크로, 더 현대적이고 최신 솔루션으로 웹 애플리케이션과 API를 위한 표현력이 풍부하고 견고하며 가벼운 기반을 제공하려고 합니다. Koa는 핵심 내부에 미들웨어를 번들로 제공하지 않으며 대신, 서버를 빠르고 즐겁게 작성할 수 있게 하는 우아한 메서드 모음을 제공합니다.</p>
<h2>Koa.js가 미들웨어를 처리하는 방법</h2>
<p>Koa는 미들웨어 처리 방식에 혁신적인 접근을 제공합니다. 최신 JavaScript 기능인 특히 ES6 제너레이터 함수를 활용하여 콜백을 제거하고 에러 처리를 간소화함으로써 미들웨어 스택을 간단하게 만들고 여러 종류의 미들웨어 함수를 관리하는 복잡성을 줄입니다.</p>
<p>Koa 미들웨어의 주요 차이점은 제너레이터 함수를 사용하며 실행을 일시 중지하고 재개할 수 있는 yield 키워드를 사용한다는 점입니다. 이는 미들웨어 함수가 어떻게 그리고 언제 실행되는지에 대한 높은 수준의 제어를 제공합니다.</p>
<h2>Koa.js 미들웨어 예시</h2>
<p>약학 마이크로서비스 시나리오를 계속해가며, Express로 했던 것과 같은 미들웨어 함수를 만드는 방법을 살펴보겠습니다: 인증, 권한 부여, 요청 로깅 및 도서 요청 로깅 및 유효성 검사.</p>
<p>인증 미들웨어 — 익스프레스처럼, Koa에서도 미들웨어를 사용하여 제공된 자격 증명을 확인하여 들어오는 요청을 인증할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">auth</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">ctx, next</span>) =&gt; {
  <span class="hljs-keyword">const</span> token = ctx.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;auth-token&#x27;</span>];
  <span class="hljs-keyword">if</span> (!token) ctx.<span class="hljs-keyword">throw</span>(<span class="hljs-number">401</span>, <span class="hljs-string">&#x27;Access Denied&#x27;</span>);

  <span class="hljs-comment">// 토큰을 확인하고 계속 진행합니다</span>
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();
}
</code></pre>
<p>인가 미들웨어 — 인증된 사용자에 대한 자원 접근 가능성을 결정하기 위해 Koa 미들웨어를 사용할 수도 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">authorize</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">ctx, next</span>) =&gt; {
  <span class="hljs-keyword">const</span> user = ctx.<span class="hljs-property">user</span>;
  <span class="hljs-keyword">if</span> (!user || !user.<span class="hljs-property">isAdmin</span>) ctx.<span class="hljs-keyword">throw</span>(<span class="hljs-number">403</span>, <span class="hljs-string">&#x27;Unauthorized access.&#x27;</span>);

  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();
}
</code></pre>
<p>Logging Middleware — Koa의 로깅 미들웨어는 수신된 요청의 세부 정보를 기록하여 디버깅 및 분석을 지원합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">logger</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">ctx, next</span>) =&gt; {
  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();
  <span class="hljs-keyword">const</span> ms = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() - start;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${ctx.method}</span> <span class="hljs-subst">${ctx.url}</span> - <span class="hljs-subst">${ms}</span>ms`</span>);
}
</code></pre>
<p>책 요청 로깅 및 유효성 검사 미들웨어 — 재고에 새로운 약물을 추가하는 라우트와 같은 특정 라우트는 데이터 유효성 검사와 로깅을 위해 Koa 미들웨어를 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">validateAndLogBookRequest</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">ctx, next</span>) =&gt; {
  <span class="hljs-comment">// 요청 데이터 유효성 검사 (다시 말해, Joi나 다른 라이브러리를 사용할 수 있음)</span>
  <span class="hljs-comment">// 유효하지 않은 경우 &#x27;400 잘못된 요청&#x27; 오류 발생</span>

  <span class="hljs-comment">// 책 요청 기록</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received a book request for <span class="hljs-subst">${ctx.request.body.drugName}</span> at <span class="hljs-subst">${<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()}</span>`</span>);

  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();
}
</code></pre>
<h1>사례 연구: 제약 마이크로서비스에서 미들웨어 구현하기</h1>
<p><img src="/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_4.png" alt="image"/></p>
<p>Node.js에서 Express와 Koa를 사용하여 미들웨어를 실제로 구현하는 방법에 대해 더 깊이 이해하기 위해, 제약 마이크로서비스의 사례 연구를 살펴보겠습니다. 이 마이크로서비스는 약물 목록을 제공하고 필요할 때 새로운 약물을 재고에 등록할 수 있는 권한이 있는 사용자에게 이 서비스를 제공합니다.</p>
<h2>우리의 사용 사례 시나리오</h2>
<p>이 시나리오에서는 네 가지 유형의 미들웨어를 구현해야 하므로, 다시 한 번 정리해보겠습니다:</p>
<ul>
<li>사용자 자격 증명을 확인하기 위한 인증(Authentication)</li>
<li>리소스 접근을 제어하기 위한 권한 부여(Authorization)</li>
<li>분석을 위해 들어오는 요청의 세부 내용을 추적하는 요청 로깅(Request Logging)</li>
<li>새로운 약품을 재고에 추가하는 요청을 기록하고 유효성을 검사하는 Book Request Logging and Validation</li>
</ul>
<p>여기서, Express와 Koa를 사용하여 각 유형의 미들웨어에 대한 코드 조각을 제공하며, 이 두 인기있는 Node 프레임워크의 미들웨어 접근 방식의 유사점과 차이점을 관찰할 수 있습니다.</p>
<h2>Express.js 구현</h2>
<p>우리는 필요한 라이브러리를 요구하고, 미들웨어 함수를 정의한 다음, 이러한 미들웨어 함수를 사용하여 서버 라우트를 설정할 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

<span class="hljs-comment">// 인증 미들웨어</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">auth</span>(<span class="hljs-params">req, res, next</span>) {
  <span class="hljs-keyword">const</span> token = req.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;auth-token&#x27;</span>);
  <span class="hljs-keyword">if</span> (!token) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">401</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;액세스 거부됨&#x27;</span>);

  <span class="hljs-comment">// 토큰 확인 및 계속 진행</span>
  <span class="hljs-comment">// ...</span>
  <span class="hljs-title function_">next</span>();
}

<span class="hljs-comment">// 권한 미들웨어</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">authorize</span>(<span class="hljs-params">req, res, next</span>) {
  <span class="hljs-keyword">const</span> user = req.<span class="hljs-property">user</span>;
  <span class="hljs-keyword">if</span> (!user || !user.<span class="hljs-property">isAdmin</span>) <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">403</span>).<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;인가되지 않은 액세스입니다.&#x27;</span>);

  <span class="hljs-title function_">next</span>();
}

<span class="hljs-comment">// 로깅 미들웨어</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">logger</span>(<span class="hljs-params">req, res, next</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`요청 방식 <span class="hljs-subst">${req.method}</span> 요청을 받음: <span class="hljs-subst">${req.url}</span>, 시간: <span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>`</span>);
  <span class="hljs-title function_">next</span>();
}

<span class="hljs-comment">// 책 요청 로깅 및 유효성 검사 미들웨어</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">validateAndLogBookRequest</span>(<span class="hljs-params">req, res, next</span>) {
  <span class="hljs-comment">// 요청 데이터 유효성 검사 (Joi 또는 다른 라이브러리 사용 가능)</span>
  <span class="hljs-comment">// 유효하지 않은 경우 &#x27;400 잘못된 요청&#x27; 응답 반환</span>
  
  <span class="hljs-comment">// 책 요청 로깅</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`책 요청 받음: <span class="hljs-subst">${req.body.drugName}</span>, 시간: <span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>`</span>);

  <span class="hljs-title function_">next</span>();
}

<span class="hljs-comment">// 서버 라우트 설정</span>
app.<span class="hljs-title function_">use</span>(logger); <span class="hljs-comment">// 모든 라우트에 로깅 사용</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api/drugs&#x27;</span>, auth, authorize); <span class="hljs-comment">// &#x27;/api/drugs&#x27; 라우트에 인증 및 권한 사용</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api/book&#x27;</span>, validateAndLogBookRequest); <span class="hljs-comment">// &#x27;/api/book&#x27; 라우트에 책 요청 로거 및 유효성 검사 사용</span>

<span class="hljs-comment">// 요청 수신 대기</span>
app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;서버가 포트 3000에서 대기 중&#x27;</span>);
});
</code></pre>
<h2>Koa.js 구현 방법</h2>
<p>이제 Koa에서 동등한 내용을 살펴봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();

<span class="hljs-comment">// 인증 미들웨어</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">auth</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">ctx, next</span>) =&gt; {
  <span class="hljs-keyword">const</span> token = ctx.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;auth-token&#x27;</span>];
  <span class="hljs-keyword">if</span> (!token) ctx.<span class="hljs-keyword">throw</span>(<span class="hljs-number">401</span>, <span class="hljs-string">&#x27;액세스 거부&#x27;</span>);

  <span class="hljs-comment">// 토큰 확인 및 진행</span>
  <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();
}

<span class="hljs-comment">// 권한 부여 미들웨어</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">authorize</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">ctx, next</span>) =&gt; {
  <span class="hljs-keyword">const</span> user = ctx.<span class="hljs-property">user</span>;
  <span class="hljs-keyword">if</span> (!user || !user.<span class="hljs-property">isAdmin</span>) ctx.<span class="hljs-keyword">throw</span>(<span class="hljs-number">403</span>, <span class="hljs-string">&#x27;사용 권한이 없습니다.&#x27;</span>);

  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();
}

<span class="hljs-comment">// 로깅 미들웨어</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">logger</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">ctx, next</span>) =&gt; {
  <span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();
  <span class="hljs-keyword">const</span> ms = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() - start;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${ctx.method}</span> <span class="hljs-subst">${ctx.url}</span> - <span class="hljs-subst">${ms}</span>ms`</span>);
}

<span class="hljs-comment">// 책 요청 로깅 및 유효성 검사 미들웨어</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">validateAndLogBookRequest</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">ctx, next</span>) =&gt; {
  <span class="hljs-comment">// 요청 데이터 유효성 검사 (Joi 또는 다른 라이브러리 사용 가능)</span>
  <span class="hljs-comment">// 잘못된 경우 &#x27;400 잘못된 요청&#x27; 오류 발생</span>

  <span class="hljs-comment">// 책 요청 로깅</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Received a book request for <span class="hljs-subst">${ctx.request.body.drugName}</span> at <span class="hljs-subst">${<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()}</span>`</span>);

  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();
}

<span class="hljs-comment">// 서버 경로 설정</span>
app.<span class="hljs-title function_">use</span>(logger); <span class="hljs-comment">// 모든 경로에 로거 사용</span>
app.<span class="hljs-title function_">use</span>(auth, authorize); <span class="hljs-comment">// 모든 경로에 인증과 권한을 사용</span>
app.<span class="hljs-title function_">use</span>(validateAndLogBookRequest); <span class="hljs-comment">// 모든 경로에 책 요청 로거 및 유효성 검사 사용</span>

<span class="hljs-comment">// 요청 수신 대기</span>
app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;서버가 3000번 포트에서 수신 대기 중입니다.&#x27;</span>);
});
</code></pre>
<p>이 간단한 예제에서는 모든 요청에 대한 로깅, 의약품 자원에 대한 인증 및 권한 부여, 그리고 책 요청 로깅 및 유효성 검사를 위해 미들웨어를 사용했습니다. Express와 Koa 사이의 구현이 매우 유사하다는 점을 알 수 있습니다. 주요 차이점은 Koa가 더 읽기 쉽고 유지보수하기 쉬운 코드를 위해 async/await 구문을 사용한다는 것입니다.</p>
<h1>Express.js vs Koa.js: 두 미들웨어의 이야기</h1>
<img src="/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_5.png"/>
<p>Node 마이크로서비스를 개발할 때 Express와 Koa 중 어떤 것을 선택할지는 특정 프로젝트 요구 사항, 팀이 프레임워크에 익숙한 정도, 장기적인 유지 보수 관점 등 여러 요소에 따라 결정됩니다. 그럼 각 프레임워크의 강점을 살펴보고 미들웨어 처리 면에서 어떻게 비교되는지 알아봅시다.</p>
<h2>Express.js 장점</h2>
<p>Express는 Koa보다 오랜 기간 사용되어 왔으며 현재 더 인기가 많습니다. 방대한 커뮤니티와 다양한 자원이 제공되어 많은 개발자들에게 특히 간단한 웹 애플리케이션이나 REST API 개발에 용이한 선택지입니다.</p>
<p>Express의 미들웨어 아키텍처는 간단하고 직관적으로 설계되어 있어, 가파른 학습 곡선 없이도 강력한 기능 세트가 필요한 애플리케이션에 좋은 선택으로 떠오릅니다.</p>
<h2>Koa.js의 강점</h2>
<p>Koa는 미들웨어 관리에 대한 혁신적인 접근 방식을 제공하며, 비동기 함수의 사용으로 코드를 더 읽기 쉽고 유지보수하기 쉽게 만들어 줍니다. 이는 Node.js에서 보편적으로 발생하는 콜백 지옥(callback hell)을 제거해줍니다.</p>
<p>Koa는 더 가벼우면서도 표현력이 풍부하고 견고한 웹 애플리케이션과 API의 기반을 제공하며, async 함수를 통해 콜백을 버리고 에러 처리를 크게 향상시킬 수 있습니다. Koa는 자체적으로 미들웨어를 포함하지 않으며, 서버를 빠르고 즐겁게 작성할 수 있는 다양한 메서드를 제공합니다.</p>
<p><img src="/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_6.png" alt="2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_6"/></p>
<h2>미들웨어 비교</h2>
<p>익스프레스와 코아는 각자 독특한 방식으로 미들웨어를 다루는데, 첫 번째는 더 전통적인 방식을 사용합니다. 미들웨어 함수는 요청 및 응답 객체에 액세스할 수 있으며 직접 작동할 수 있어서 제어 흐름을 이해하고 디버깅하기 쉽습니다.</p>
<p>반면, 코아는 현대적인 JavaScript 기능을 사용하며, 미들웨어가 실행을 다음 미들웨어에 &quot;양보&quot;하고 스택이 해제될 때 재개될 수 있도록 흐름을 제어하게 합니다. 이는 코드를 더 선형적이고 쉽게 읽을 수 있게 만드는 반면, JavaScript 제너레이터 및 프로미스에 대한 깊은 이해가 필요합니다.</p>
<h1>아직 끝나지 않았어요</h1>
<p><img src="/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_8.png" alt="이미지"/></p>
<p>Express.js와 Koa.js를 비교한 결론을 도출해본 결과, Express는 직관적이고 간단한 방법론을 채택했으며, Koa는 JavaScript의 비동기 함수를 활용한 더 간략하고 현대적인 접근 방식을 취했습니다.</p>
<p>Middleware를 최적화하는 것은 Node.js 애플리케이션 전반의 성능을 향상시키는 일부분에 불과하다는 것을 명심해주세요. 저의 이전 글인 &quot;이벤트 루프를 통해 Node.js의 성능 향상하기: 사례 연구를 통해 더 나은 성능&quot;에서 Node가 이벤트 루프를 어떻게 활용해 효율적으로 작업을 처리하는지 심층적으로 살펴볼 수 있습니다. 이를 통해 성능 최적화에 대한 깊은 이해를 얻을 수 있습니다.</p>
<p>반면에, 애플리케이션의 구조와 효율성을 더욱 향상시키기 위해 이벤트 주도 아키텍처를 채택하는 것을 고려해보세요. 또 다른 기사인 &quot;Node.js 및 TypeScript를 사용한 이벤트 주도형 REST API 만들기: 실용적인 접근&quot;에서는 Node와 TypeScript를 활용하여 강력하고 효율적인 REST API를 구축하는 방법을 안내하고 있습니다. 여기서는 간단한 이벤트 주도 접근 방식에 중점을 두며 독자를 안내합니다.</p>
<p>즐거운 코딩하시고, 앞으로의 기사에서 더 많은 통찰과 실용적인 접근법을 공유하기를 기대하고 있습니다!</p>
<h1>레고처럼 재사용 가능한 컴포넌트로 구성 가능한 앱을 구축하자</h1>
<p><img src="/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_9.png" alt="이미지"/></p>
<p>Bit는 본질적으로 조립 가능한 소프트웨어를 개발하기 위한 오픈 소스 도구 모음입니다.</p>
<p>Bit를 사용하면 현대적인 웹 애플리케이션, UI 컴포넌트, 백엔드 서비스 또는 CLI 스크립트와 같은 어떤 소프트웨어 요소든 독립적이고 재사용 가능하며 조립 가능한 소프트웨어 단위로 개발할 수 있습니다. 어플리케이션 간에 어떤 컴포넌트라도 공유하여 협업을 더 쉽게 하고 더 빠르게 빌드할 수 있습니다.</p>
<p>조립 가능한 소프트웨어를 함께 만드는 100,000명 이상의 개발자 중 하나가 되어보세요.</p>
<p>다음 자습서로 시작해보세요:</p>
<h1>→ 마이크로 프론트엔드: 비디오 // 안내</h1>
<h1>→ 코드 공유: 비디오 // 안내</h1>
<h1>→ 현대화: 비디오 // 안내</h1>
<h1>→ 모노 레포: 비디오 // 안내</h1>
<h1>→ 마이크로서비스: 비디오 // 가이드</h1>
<h1>→ 디자인 시스템: 비디오 // 가이드</h1>
<h1>추천 문서:</h1></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Nodejs에서 Middleware 구현하기 Expressjs와 Koajs의 비교 연구","description":"","date":"2024-05-14 15:39","slug":"2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs","content":"\n\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png\" /\u003e\n\n## BACK-END DEVELOPMENT\n\n# Introduction\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_1.png\" /\u003e\n\n\n\n\n안녕하세요! 미들웨어는 요청 및 응답 객체에서 작동하는 함수로, 종종 이러한 객체들을 최종 라우트 핸들러에 도달하기 전에 정보를 변경하거나 추가하거나 처리하는 방식으로 작동하기 때문에 서버 측 프로그래밍의 중요한 부분이 되었습니다.\n\n이러한 미들웨어의 유틸리티를 고려하면, 서버 측 기술들은 종종 이러한 도구의 개발과 사용을 용이하게 하는 프레임워크를 제공합니다. 본 문서에서는 Node.js 생태계에서 두 가지 인기 있는 프레임워크인 Express.js와 Koa.js에 대해 다룹니다.\n\n## Express.js와 Koa.js\n\nExpress.js는 Node.js를 위한 표준 서버 프레임워크로 인정받고 있으며 강력한 미들웨어 시스템을 포함한 강력한 기능들로 웹 개발의 풍경을 형성하는 데 중요한 역할을 하고 있습니다. 반면에 Koa.js는 Express.js를 개발한 팀에 의해 개발된 Node.js를 위한 최신 웹 프레임워크로, 더 작고 표현력이 뛰어나며 웹 애플리케이션과 API를 위한 훨씬 견고한 기반을 제공하려고 합니다. 이 프레임워크는 핵심에 어떤 미들웨어도 번들로 제공하지 않아 개발자들에게 더 많은 제어와 자유를 제공합니다.\n\n\n\n## 사례 연구\n\n이 문서는 Express.js와 Koa.js의 미들웨어 구현 능력에 중점을 두고 깊이 있는 비교를 제공합니다. 또한 인증, 권한 부여, 자세한 요청 분석 로깅 및 책 요청 로깅 및 유효성 검사와 같은 예시들을 탐구합니다. 이러한 예시들은 실제 사용 사례인 약학 마이크로서비스를 통해 설명될 것입니다. 이 서비스는 의약품 목록을 관리하고 새로운 의약품을 필요할 때 매입하여 추적하는 역할을 담당합니다.\n\n# Express.js를 이용한 미들웨어 구현\n\n![이미지](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_2.png)\n\n\n\n## Express.js: 간단한 개요\n\nExpress.js 또는 Express는 Node.js를 위한 강력한 백엔드 웹 애플리케이션 프레임워크로 널리 알려져 있습니다. 그 간결함, 유연성, 확장성으로 칭찬받고 있으며, MEAN/MERN 스택(MongoDB, Express, Angular/React, Node.js)의 필수 구성 요소이기도 합니다. 간소한 성격에도 불구하고, 라우팅, 템플릿 엔진, 미들웨어, 오류 처리 등의 기능을 포함한 강력한 기능을 자랑합니다.\n\n## Express.js가 미들웨어를 처리하는 방식\n\nExpress의 핵심은 미들웨어 시스템입니다. 미들웨어는 요청 객체(req), 응답 객체(res), 및 응용 프로그램의 요청-응답 주기 내의 다음 미들웨어 함수에 접근 권한이 있는 함수들입니다. 이들은 코드를 실행하거나 요청 및 응답 객체를 변경하며 요청-응답 주기를 종료하거나 다음 미들웨어 함수에 제어를 전달할 수 있습니다.\n\n\n\n이 미들웨어 파이프라인은 개발자가 중요한 유연성을 제공하여 애플리케이션의 고유한 요구 사항에 맞춰 미들웨어 기능을 추가하고 계층화할 수 있도록 합니다.\n\n## Express 미들웨어 예시\n\n의약품 마이크로서비스 시나리오를 살펴보면 Express를 사용하여 필요한 미들웨어 기능을 구현하는 방법을 알아볼 수 있습니다. 인증(Authentication), 권한 부여(Authorization), 분석을 위한 요청 로깅(Request Logging) 및 도서 요청 로깅 및 유효성 검사(Book Request Logging \u0026 Validation)가 포함됩니다. \n\n인증 미들웨어 — 인증은 사용자, 프로세스 또는 시스템의 신원을 확인하는 과정이며, Express에서는 미들웨어를 사용하여 유효 자격 증명이 있는지 확인하기 위해 요청 헤더를 검사하여 들어오는 요청을 인증할 수 있습니다.\n\n\n\n```js\nfunction auth(req, res, next) {\n  const token = req.header('auth-token');\n  if (!token) return res.status(401).send('Access Denied');\n\n  // 토큰을 확인하고 계속 진행\n  // ...\n  next();\n}\n```\n\n인증 미들웨어 — 인증 후에 사용되는 인가는, 인증된 사용자가 어떤 자원에 액세스할 수 있는지 결정하는 것이며, 다시 한 번 Express 미들웨어가 유용하게 사용됩니다.\n\n```js\nfunction authorize(req, res, next) {\n  const user = req.user;\n  if (!user || !user.isAdmin) return res.status(403).send('Unauthorized access.');\n\n  next();\n}\n```\n\n로깅 미들웨어 — 그리고 우리는 로깅에 도달했습니다. 로깅은 애플리케이션 활동 추적과 디버깅에 중요하며, 여기 Express 미들웨어를 사용해 요청 세부 정보를 로깅할 수 있습니다.\n\n\n\n\n```js\nfunction logger(req, res, next) {\n  console.log(`요청 방법이 ${req.method}이고 URL이 ${req.url}인 요청을 받았습니다. 시간: ${Date.now()}`);\n  next();\n}\n```\n\n도서 요청 로깅 및 유효성 검사 미들웨어 — 재고에 새로운 약품을 추가하는 경로와 같은 특정 경로를 다룰 때, 미들웨어는 요청 데이터를 유효성 검사하고 요청을 로그에 남길 수 있습니다.\n\n```js\nfunction validateAndLogBookRequest(req, res, next) {\n  // 요청 데이터 유효성 검사 (Joi와 같은 라이브러리 사용 가능)\n  // 유효하지 않으면 '400 Bad Request' 응답 반환\n\n  // 도서 요청 로깅\n  console.log(`도서 요청이 ${req.body.drugName}인 요청을 받았습니다. 시간: ${Date.now()}`);\n\n  next();\n}\n```\n\n## 더 알아보기:\n\n\n\n# 미들웨어 구현을 위한 Koa.js\n\n\u003cimg src=\"/assets/img/2024-05-14-Nodejs에서의미들웨어구현Expressjs와Koajs의비교연구_3.png\"/\u003e\n\nKoa.js 또는 간단히 Koa는 Express 팀이 디자인한 웹 프레임워크로, 더 현대적이고 최신 솔루션으로 웹 애플리케이션과 API를 위한 표현력이 풍부하고 견고하며 가벼운 기반을 제공하려고 합니다. Koa는 핵심 내부에 미들웨어를 번들로 제공하지 않으며 대신, 서버를 빠르고 즐겁게 작성할 수 있게 하는 우아한 메서드 모음을 제공합니다.\n\n## Koa.js가 미들웨어를 처리하는 방법\n\n\n\nKoa는 미들웨어 처리 방식에 혁신적인 접근을 제공합니다. 최신 JavaScript 기능인 특히 ES6 제너레이터 함수를 활용하여 콜백을 제거하고 에러 처리를 간소화함으로써 미들웨어 스택을 간단하게 만들고 여러 종류의 미들웨어 함수를 관리하는 복잡성을 줄입니다.\n\nKoa 미들웨어의 주요 차이점은 제너레이터 함수를 사용하며 실행을 일시 중지하고 재개할 수 있는 yield 키워드를 사용한다는 점입니다. 이는 미들웨어 함수가 어떻게 그리고 언제 실행되는지에 대한 높은 수준의 제어를 제공합니다.\n\n## Koa.js 미들웨어 예시\n\n약학 마이크로서비스 시나리오를 계속해가며, Express로 했던 것과 같은 미들웨어 함수를 만드는 방법을 살펴보겠습니다: 인증, 권한 부여, 요청 로깅 및 도서 요청 로깅 및 유효성 검사.\n\n\n\n인증 미들웨어 — 익스프레스처럼, Koa에서도 미들웨어를 사용하여 제공된 자격 증명을 확인하여 들어오는 요청을 인증할 수 있습니다.\n\n```js\nconst auth = async (ctx, next) =\u003e {\n  const token = ctx.headers['auth-token'];\n  if (!token) ctx.throw(401, 'Access Denied');\n\n  // 토큰을 확인하고 계속 진행합니다\n  // ...\n  await next();\n}\n```\n\n인가 미들웨어 — 인증된 사용자에 대한 자원 접근 가능성을 결정하기 위해 Koa 미들웨어를 사용할 수도 있습니다.\n\n```js\nconst authorize = async (ctx, next) =\u003e {\n  const user = ctx.user;\n  if (!user || !user.isAdmin) ctx.throw(403, 'Unauthorized access.');\n\n  await next();\n}\n```\n\n\n\nLogging Middleware — Koa의 로깅 미들웨어는 수신된 요청의 세부 정보를 기록하여 디버깅 및 분석을 지원합니다.\n\n```js\nconst logger = async (ctx, next) =\u003e {\n  const start = new Date().getTime();\n  await next();\n  const ms = new Date().getTime() - start;\n  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);\n}\n```\n\n책 요청 로깅 및 유효성 검사 미들웨어 — 재고에 새로운 약물을 추가하는 라우트와 같은 특정 라우트는 데이터 유효성 검사와 로깅을 위해 Koa 미들웨어를 사용할 수 있습니다.\n\n```js\nconst validateAndLogBookRequest = async (ctx, next) =\u003e {\n  // 요청 데이터 유효성 검사 (다시 말해, Joi나 다른 라이브러리를 사용할 수 있음)\n  // 유효하지 않은 경우 '400 잘못된 요청' 오류 발생\n\n  // 책 요청 기록\n  console.log(`Received a book request for ${ctx.request.body.drugName} at ${new Date().getTime()}`);\n\n  await next();\n}\n```\n\n\n\n# 사례 연구: 제약 마이크로서비스에서 미들웨어 구현하기\n\n![image](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_4.png)\n\nNode.js에서 Express와 Koa를 사용하여 미들웨어를 실제로 구현하는 방법에 대해 더 깊이 이해하기 위해, 제약 마이크로서비스의 사례 연구를 살펴보겠습니다. 이 마이크로서비스는 약물 목록을 제공하고 필요할 때 새로운 약물을 재고에 등록할 수 있는 권한이 있는 사용자에게 이 서비스를 제공합니다.\n\n## 우리의 사용 사례 시나리오\n\n\n\n이 시나리오에서는 네 가지 유형의 미들웨어를 구현해야 하므로, 다시 한 번 정리해보겠습니다:\n\n- 사용자 자격 증명을 확인하기 위한 인증(Authentication)\n- 리소스 접근을 제어하기 위한 권한 부여(Authorization)\n- 분석을 위해 들어오는 요청의 세부 내용을 추적하는 요청 로깅(Request Logging)\n- 새로운 약품을 재고에 추가하는 요청을 기록하고 유효성을 검사하는 Book Request Logging and Validation\n\n여기서, Express와 Koa를 사용하여 각 유형의 미들웨어에 대한 코드 조각을 제공하며, 이 두 인기있는 Node 프레임워크의 미들웨어 접근 방식의 유사점과 차이점을 관찰할 수 있습니다.\n\n## Express.js 구현\n\n\n\n우리는 필요한 라이브러리를 요구하고, 미들웨어 함수를 정의한 다음, 이러한 미들웨어 함수를 사용하여 서버 라우트를 설정할 것입니다.\n\n```js\nconst express = require('express');\nconst app = express();\n\n// 인증 미들웨어\nfunction auth(req, res, next) {\n  const token = req.header('auth-token');\n  if (!token) return res.status(401).send('액세스 거부됨');\n\n  // 토큰 확인 및 계속 진행\n  // ...\n  next();\n}\n\n// 권한 미들웨어\nfunction authorize(req, res, next) {\n  const user = req.user;\n  if (!user || !user.isAdmin) return res.status(403).send('인가되지 않은 액세스입니다.');\n\n  next();\n}\n\n// 로깅 미들웨어\nfunction logger(req, res, next) {\n  console.log(`요청 방식 ${req.method} 요청을 받음: ${req.url}, 시간: ${Date.now()}`);\n  next();\n}\n\n// 책 요청 로깅 및 유효성 검사 미들웨어\nfunction validateAndLogBookRequest(req, res, next) {\n  // 요청 데이터 유효성 검사 (Joi 또는 다른 라이브러리 사용 가능)\n  // 유효하지 않은 경우 '400 잘못된 요청' 응답 반환\n  \n  // 책 요청 로깅\n  console.log(`책 요청 받음: ${req.body.drugName}, 시간: ${Date.now()}`);\n\n  next();\n}\n\n// 서버 라우트 설정\napp.use(logger); // 모든 라우트에 로깅 사용\napp.use('/api/drugs', auth, authorize); // '/api/drugs' 라우트에 인증 및 권한 사용\napp.use('/api/book', validateAndLogBookRequest); // '/api/book' 라우트에 책 요청 로거 및 유효성 검사 사용\n\n// 요청 수신 대기\napp.listen(3000, () =\u003e {\n  console.log('서버가 포트 3000에서 대기 중');\n});\n```\n\n## Koa.js 구현 방법\n\n이제 Koa에서 동등한 내용을 살펴봅시다.\n\n\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\n\n// 인증 미들웨어\nconst auth = async (ctx, next) =\u003e {\n  const token = ctx.headers['auth-token'];\n  if (!token) ctx.throw(401, '액세스 거부');\n\n  // 토큰 확인 및 진행\n  // ...\n  await next();\n}\n\n// 권한 부여 미들웨어\nconst authorize = async (ctx, next) =\u003e {\n  const user = ctx.user;\n  if (!user || !user.isAdmin) ctx.throw(403, '사용 권한이 없습니다.');\n\n  await next();\n}\n\n// 로깅 미들웨어\nconst logger = async (ctx, next) =\u003e {\n  const start = new Date().getTime();\n  await next();\n  const ms = new Date().getTime() - start;\n  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);\n}\n\n// 책 요청 로깅 및 유효성 검사 미들웨어\nconst validateAndLogBookRequest = async (ctx, next) =\u003e {\n  // 요청 데이터 유효성 검사 (Joi 또는 다른 라이브러리 사용 가능)\n  // 잘못된 경우 '400 잘못된 요청' 오류 발생\n\n  // 책 요청 로깅\n  console.log(`Received a book request for ${ctx.request.body.drugName} at ${new Date().getTime()}`);\n\n  await next();\n}\n\n// 서버 경로 설정\napp.use(logger); // 모든 경로에 로거 사용\napp.use(auth, authorize); // 모든 경로에 인증과 권한을 사용\napp.use(validateAndLogBookRequest); // 모든 경로에 책 요청 로거 및 유효성 검사 사용\n\n// 요청 수신 대기\napp.listen(3000, () =\u003e {\n  console.log('서버가 3000번 포트에서 수신 대기 중입니다.');\n});\n```\n\n이 간단한 예제에서는 모든 요청에 대한 로깅, 의약품 자원에 대한 인증 및 권한 부여, 그리고 책 요청 로깅 및 유효성 검사를 위해 미들웨어를 사용했습니다. Express와 Koa 사이의 구현이 매우 유사하다는 점을 알 수 있습니다. 주요 차이점은 Koa가 더 읽기 쉽고 유지보수하기 쉬운 코드를 위해 async/await 구문을 사용한다는 것입니다.\n\n# Express.js vs Koa.js: 두 미들웨어의 이야기\n\n\u003cimg src=\"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_5.png\" /\u003e\n\n\n\n\nNode 마이크로서비스를 개발할 때 Express와 Koa 중 어떤 것을 선택할지는 특정 프로젝트 요구 사항, 팀이 프레임워크에 익숙한 정도, 장기적인 유지 보수 관점 등 여러 요소에 따라 결정됩니다. 그럼 각 프레임워크의 강점을 살펴보고 미들웨어 처리 면에서 어떻게 비교되는지 알아봅시다.\n\n## Express.js 장점\n\nExpress는 Koa보다 오랜 기간 사용되어 왔으며 현재 더 인기가 많습니다. 방대한 커뮤니티와 다양한 자원이 제공되어 많은 개발자들에게 특히 간단한 웹 애플리케이션이나 REST API 개발에 용이한 선택지입니다.\n\nExpress의 미들웨어 아키텍처는 간단하고 직관적으로 설계되어 있어, 가파른 학습 곡선 없이도 강력한 기능 세트가 필요한 애플리케이션에 좋은 선택으로 떠오릅니다.\n\n\n\n## Koa.js의 강점\n\nKoa는 미들웨어 관리에 대한 혁신적인 접근 방식을 제공하며, 비동기 함수의 사용으로 코드를 더 읽기 쉽고 유지보수하기 쉽게 만들어 줍니다. 이는 Node.js에서 보편적으로 발생하는 콜백 지옥(callback hell)을 제거해줍니다.\n\nKoa는 더 가벼우면서도 표현력이 풍부하고 견고한 웹 애플리케이션과 API의 기반을 제공하며, async 함수를 통해 콜백을 버리고 에러 처리를 크게 향상시킬 수 있습니다. Koa는 자체적으로 미들웨어를 포함하지 않으며, 서버를 빠르고 즐겁게 작성할 수 있는 다양한 메서드를 제공합니다.\n\n![2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_6](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_6.png)\n\n\n\n## 미들웨어 비교\n\n익스프레스와 코아는 각자 독특한 방식으로 미들웨어를 다루는데, 첫 번째는 더 전통적인 방식을 사용합니다. 미들웨어 함수는 요청 및 응답 객체에 액세스할 수 있으며 직접 작동할 수 있어서 제어 흐름을 이해하고 디버깅하기 쉽습니다.\n\n반면, 코아는 현대적인 JavaScript 기능을 사용하며, 미들웨어가 실행을 다음 미들웨어에 \"양보\"하고 스택이 해제될 때 재개될 수 있도록 흐름을 제어하게 합니다. 이는 코드를 더 선형적이고 쉽게 읽을 수 있게 만드는 반면, JavaScript 제너레이터 및 프로미스에 대한 깊은 이해가 필요합니다.\n\n\n\n# 아직 끝나지 않았어요\n\n![이미지](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_8.png)\n\nExpress.js와 Koa.js를 비교한 결론을 도출해본 결과, Express는 직관적이고 간단한 방법론을 채택했으며, Koa는 JavaScript의 비동기 함수를 활용한 더 간략하고 현대적인 접근 방식을 취했습니다.\n\nMiddleware를 최적화하는 것은 Node.js 애플리케이션 전반의 성능을 향상시키는 일부분에 불과하다는 것을 명심해주세요. 저의 이전 글인 \"이벤트 루프를 통해 Node.js의 성능 향상하기: 사례 연구를 통해 더 나은 성능\"에서 Node가 이벤트 루프를 어떻게 활용해 효율적으로 작업을 처리하는지 심층적으로 살펴볼 수 있습니다. 이를 통해 성능 최적화에 대한 깊은 이해를 얻을 수 있습니다.\n\n\n\n반면에, 애플리케이션의 구조와 효율성을 더욱 향상시키기 위해 이벤트 주도 아키텍처를 채택하는 것을 고려해보세요. 또 다른 기사인 \"Node.js 및 TypeScript를 사용한 이벤트 주도형 REST API 만들기: 실용적인 접근\"에서는 Node와 TypeScript를 활용하여 강력하고 효율적인 REST API를 구축하는 방법을 안내하고 있습니다. 여기서는 간단한 이벤트 주도 접근 방식에 중점을 두며 독자를 안내합니다.\n\n즐거운 코딩하시고, 앞으로의 기사에서 더 많은 통찰과 실용적인 접근법을 공유하기를 기대하고 있습니다!\n\n# 레고처럼 재사용 가능한 컴포넌트로 구성 가능한 앱을 구축하자\n\n![이미지](/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_9.png)\n\n\n\nBit는 본질적으로 조립 가능한 소프트웨어를 개발하기 위한 오픈 소스 도구 모음입니다.\n\nBit를 사용하면 현대적인 웹 애플리케이션, UI 컴포넌트, 백엔드 서비스 또는 CLI 스크립트와 같은 어떤 소프트웨어 요소든 독립적이고 재사용 가능하며 조립 가능한 소프트웨어 단위로 개발할 수 있습니다. 어플리케이션 간에 어떤 컴포넌트라도 공유하여 협업을 더 쉽게 하고 더 빠르게 빌드할 수 있습니다.\n\n조립 가능한 소프트웨어를 함께 만드는 100,000명 이상의 개발자 중 하나가 되어보세요.\n\n다음 자습서로 시작해보세요:\n\n\n\n# → 마이크로 프론트엔드: 비디오 // 안내\n\n# → 코드 공유: 비디오 // 안내\n\n# → 현대화: 비디오 // 안내\n\n# → 모노 레포: 비디오 // 안내\n\n\n\n# → 마이크로서비스: 비디오 // 가이드\n\n# → 디자인 시스템: 비디오 // 가이드\n\n# 추천 문서:","ogImage":{"url":"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png"},"coverImage":"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png","tag":["Tech"],"readingTime":12},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    h1: \"h1\",\n    p: \"p\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_0.png\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"BACK-END DEVELOPMENT\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Introduction\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_1.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"안녕하세요! 미들웨어는 요청 및 응답 객체에서 작동하는 함수로, 종종 이러한 객체들을 최종 라우트 핸들러에 도달하기 전에 정보를 변경하거나 추가하거나 처리하는 방식으로 작동하기 때문에 서버 측 프로그래밍의 중요한 부분이 되었습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이러한 미들웨어의 유틸리티를 고려하면, 서버 측 기술들은 종종 이러한 도구의 개발과 사용을 용이하게 하는 프레임워크를 제공합니다. 본 문서에서는 Node.js 생태계에서 두 가지 인기 있는 프레임워크인 Express.js와 Koa.js에 대해 다룹니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Express.js와 Koa.js\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Express.js는 Node.js를 위한 표준 서버 프레임워크로 인정받고 있으며 강력한 미들웨어 시스템을 포함한 강력한 기능들로 웹 개발의 풍경을 형성하는 데 중요한 역할을 하고 있습니다. 반면에 Koa.js는 Express.js를 개발한 팀에 의해 개발된 Node.js를 위한 최신 웹 프레임워크로, 더 작고 표현력이 뛰어나며 웹 애플리케이션과 API를 위한 훨씬 견고한 기반을 제공하려고 합니다. 이 프레임워크는 핵심에 어떤 미들웨어도 번들로 제공하지 않아 개발자들에게 더 많은 제어와 자유를 제공합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"사례 연구\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 문서는 Express.js와 Koa.js의 미들웨어 구현 능력에 중점을 두고 깊이 있는 비교를 제공합니다. 또한 인증, 권한 부여, 자세한 요청 분석 로깅 및 책 요청 로깅 및 유효성 검사와 같은 예시들을 탐구합니다. 이러한 예시들은 실제 사용 사례인 약학 마이크로서비스를 통해 설명될 것입니다. 이 서비스는 의약품 목록을 관리하고 새로운 의약품을 필요할 때 매입하여 추적하는 역할을 담당합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Express.js를 이용한 미들웨어 구현\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_2.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Express.js: 간단한 개요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Express.js 또는 Express는 Node.js를 위한 강력한 백엔드 웹 애플리케이션 프레임워크로 널리 알려져 있습니다. 그 간결함, 유연성, 확장성으로 칭찬받고 있으며, MEAN/MERN 스택(MongoDB, Express, Angular/React, Node.js)의 필수 구성 요소이기도 합니다. 간소한 성격에도 불구하고, 라우팅, 템플릿 엔진, 미들웨어, 오류 처리 등의 기능을 포함한 강력한 기능을 자랑합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Express.js가 미들웨어를 처리하는 방식\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Express의 핵심은 미들웨어 시스템입니다. 미들웨어는 요청 객체(req), 응답 객체(res), 및 응용 프로그램의 요청-응답 주기 내의 다음 미들웨어 함수에 접근 권한이 있는 함수들입니다. 이들은 코드를 실행하거나 요청 및 응답 객체를 변경하며 요청-응답 주기를 종료하거나 다음 미들웨어 함수에 제어를 전달할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 미들웨어 파이프라인은 개발자가 중요한 유연성을 제공하여 애플리케이션의 고유한 요구 사항에 맞춰 미들웨어 기능을 추가하고 계층화할 수 있도록 합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Express 미들웨어 예시\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"의약품 마이크로서비스 시나리오를 살펴보면 Express를 사용하여 필요한 미들웨어 기능을 구현하는 방법을 알아볼 수 있습니다. 인증(Authentication), 권한 부여(Authorization), 분석을 위한 요청 로깅(Request Logging) 및 도서 요청 로깅 및 유효성 검사(Book Request Logging \u0026 Validation)가 포함됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"인증 미들웨어 — 인증은 사용자, 프로세스 또는 시스템의 신원을 확인하는 과정이며, Express에서는 미들웨어를 사용하여 유효 자격 증명이 있는지 확인하기 위해 요청 헤더를 검사하여 들어오는 요청을 인증할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"auth\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"req, res, next\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" token = req.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"header\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'auth-token'\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!token) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" res.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"status\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"401\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"send\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Access Denied'\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 토큰을 확인하고 계속 진행\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ...\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"인증 미들웨어 — 인증 후에 사용되는 인가는, 인증된 사용자가 어떤 자원에 액세스할 수 있는지 결정하는 것이며, 다시 한 번 Express 미들웨어가 유용하게 사용됩니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"authorize\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"req, res, next\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" user = req.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"user\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!user || !user.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"isAdmin\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" res.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"status\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"403\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"send\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Unauthorized access.'\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"로깅 미들웨어 — 그리고 우리는 로깅에 도달했습니다. 로깅은 애플리케이션 활동 추적과 디버깅에 중요하며, 여기 Express 미들웨어를 사용해 요청 세부 정보를 로깅할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"logger\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"req, res, next\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`요청 방법이 \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${req.method}\"\n          }), \"이고 URL이 \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${req.url}\"\n          }), \"인 요청을 받았습니다. 시간: \", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"${\", _jsx(_components.span, {\n              className: \"hljs-built_in\",\n              children: \"Date\"\n            }), \".now()}\"]\n          }), \"`\"]\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"도서 요청 로깅 및 유효성 검사 미들웨어 — 재고에 새로운 약품을 추가하는 경로와 같은 특정 경로를 다룰 때, 미들웨어는 요청 데이터를 유효성 검사하고 요청을 로그에 남길 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"validateAndLogBookRequest\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"req, res, next\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 요청 데이터 유효성 검사 (Joi와 같은 라이브러리 사용 가능)\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 유효하지 않으면 '400 Bad Request' 응답 반환\"\n        }), \"\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 도서 요청 로깅\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`도서 요청이 \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${req.body.drugName}\"\n          }), \"인 요청을 받았습니다. 시간: \", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"${\", _jsx(_components.span, {\n              className: \"hljs-built_in\",\n              children: \"Date\"\n            }), \".now()}\"]\n          }), \"`\"]\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"더 알아보기:\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"미들웨어 구현을 위한 Koa.js\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-14-Nodejs에서의미들웨어구현Expressjs와Koajs의비교연구_3.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Koa.js 또는 간단히 Koa는 Express 팀이 디자인한 웹 프레임워크로, 더 현대적이고 최신 솔루션으로 웹 애플리케이션과 API를 위한 표현력이 풍부하고 견고하며 가벼운 기반을 제공하려고 합니다. Koa는 핵심 내부에 미들웨어를 번들로 제공하지 않으며 대신, 서버를 빠르고 즐겁게 작성할 수 있게 하는 우아한 메서드 모음을 제공합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Koa.js가 미들웨어를 처리하는 방법\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Koa는 미들웨어 처리 방식에 혁신적인 접근을 제공합니다. 최신 JavaScript 기능인 특히 ES6 제너레이터 함수를 활용하여 콜백을 제거하고 에러 처리를 간소화함으로써 미들웨어 스택을 간단하게 만들고 여러 종류의 미들웨어 함수를 관리하는 복잡성을 줄입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Koa 미들웨어의 주요 차이점은 제너레이터 함수를 사용하며 실행을 일시 중지하고 재개할 수 있는 yield 키워드를 사용한다는 점입니다. 이는 미들웨어 함수가 어떻게 그리고 언제 실행되는지에 대한 높은 수준의 제어를 제공합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Koa.js 미들웨어 예시\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"약학 마이크로서비스 시나리오를 계속해가며, Express로 했던 것과 같은 미들웨어 함수를 만드는 방법을 살펴보겠습니다: 인증, 권한 부여, 요청 로깅 및 도서 요청 로깅 및 유효성 검사.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"인증 미들웨어 — 익스프레스처럼, Koa에서도 미들웨어를 사용하여 제공된 자격 증명을 확인하여 들어오는 요청을 인증할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"auth\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"ctx, next\"\n        }), \") =\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" token = ctx.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"headers\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'auth-token'\"\n        }), \"];\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!token) ctx.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"throw\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"401\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Access Denied'\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 토큰을 확인하고 계속 진행합니다\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ...\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"인가 미들웨어 — 인증된 사용자에 대한 자원 접근 가능성을 결정하기 위해 Koa 미들웨어를 사용할 수도 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"authorize\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"ctx, next\"\n        }), \") =\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" user = ctx.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"user\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!user || !user.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"isAdmin\"\n        }), \") ctx.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"throw\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"403\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'Unauthorized access.'\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Logging Middleware — Koa의 로깅 미들웨어는 수신된 요청의 세부 정보를 기록하여 디버깅 및 분석을 지원합니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"logger\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"ctx, next\"\n        }), \") =\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" start = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getTime\"\n        }), \"();\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" ms = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getTime\"\n        }), \"() - start;\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${ctx.method}\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${ctx.url}\"\n          }), \" - \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${ms}\"\n          }), \"ms`\"]\n        }), \");\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"책 요청 로깅 및 유효성 검사 미들웨어 — 재고에 새로운 약물을 추가하는 라우트와 같은 특정 라우트는 데이터 유효성 검사와 로깅을 위해 Koa 미들웨어를 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"validateAndLogBookRequest\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"ctx, next\"\n        }), \") =\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 요청 데이터 유효성 검사 (다시 말해, Joi나 다른 라이브러리를 사용할 수 있음)\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 유효하지 않은 경우 '400 잘못된 요청' 오류 발생\"\n        }), \"\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 책 요청 기록\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`Received a book request for \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${ctx.request.body.drugName}\"\n          }), \" at \", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"${\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"new\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-built_in\",\n              children: \"Date\"\n            }), \"().getTime()}\"]\n          }), \"`\"]\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"사례 연구: 제약 마이크로서비스에서 미들웨어 구현하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_4.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Node.js에서 Express와 Koa를 사용하여 미들웨어를 실제로 구현하는 방법에 대해 더 깊이 이해하기 위해, 제약 마이크로서비스의 사례 연구를 살펴보겠습니다. 이 마이크로서비스는 약물 목록을 제공하고 필요할 때 새로운 약물을 재고에 등록할 수 있는 권한이 있는 사용자에게 이 서비스를 제공합니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"우리의 사용 사례 시나리오\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 시나리오에서는 네 가지 유형의 미들웨어를 구현해야 하므로, 다시 한 번 정리해보겠습니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"사용자 자격 증명을 확인하기 위한 인증(Authentication)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"리소스 접근을 제어하기 위한 권한 부여(Authorization)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"분석을 위해 들어오는 요청의 세부 내용을 추적하는 요청 로깅(Request Logging)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"새로운 약품을 재고에 추가하는 요청을 기록하고 유효성을 검사하는 Book Request Logging and Validation\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서, Express와 Koa를 사용하여 각 유형의 미들웨어에 대한 코드 조각을 제공하며, 이 두 인기있는 Node 프레임워크의 미들웨어 접근 방식의 유사점과 차이점을 관찰할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Express.js 구현\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"우리는 필요한 라이브러리를 요구하고, 미들웨어 함수를 정의한 다음, 이러한 미들웨어 함수를 사용하여 서버 라우트를 설정할 것입니다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" express = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"require\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'express'\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" app = \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"express\"\n        }), \"();\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 인증 미들웨어\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"auth\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"req, res, next\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" token = req.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"header\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'auth-token'\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!token) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" res.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"status\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"401\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"send\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'액세스 거부됨'\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 토큰 확인 및 계속 진행\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ...\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 권한 미들웨어\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"authorize\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"req, res, next\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" user = req.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"user\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!user || !user.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"isAdmin\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" res.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"status\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"403\"\n        }), \").\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"send\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'인가되지 않은 액세스입니다.'\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 로깅 미들웨어\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"logger\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"req, res, next\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`요청 방식 \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${req.method}\"\n          }), \" 요청을 받음: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${req.url}\"\n          }), \", 시간: \", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"${\", _jsx(_components.span, {\n              className: \"hljs-built_in\",\n              children: \"Date\"\n            }), \".now()}\"]\n          }), \"`\"]\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 책 요청 로깅 및 유효성 검사 미들웨어\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"function\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"validateAndLogBookRequest\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"req, res, next\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 요청 데이터 유효성 검사 (Joi 또는 다른 라이브러리 사용 가능)\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 유효하지 않은 경우 '400 잘못된 요청' 응답 반환\"\n        }), \"\\n  \\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 책 요청 로깅\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`책 요청 받음: \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${req.body.drugName}\"\n          }), \", 시간: \", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"${\", _jsx(_components.span, {\n              className: \"hljs-built_in\",\n              children: \"Date\"\n            }), \".now()}\"]\n          }), \"`\"]\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 서버 라우트 설정\"\n        }), \"\\napp.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"use\"\n        }), \"(logger); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 모든 라우트에 로깅 사용\"\n        }), \"\\napp.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"use\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/api/drugs'\"\n        }), \", auth, authorize); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// '/api/drugs' 라우트에 인증 및 권한 사용\"\n        }), \"\\napp.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"use\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'/api/book'\"\n        }), \", validateAndLogBookRequest); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// '/api/book' 라우트에 책 요청 로거 및 유효성 검사 사용\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 요청 수신 대기\"\n        }), \"\\napp.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"listen\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3000\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'서버가 포트 3000에서 대기 중'\"\n        }), \");\\n});\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Koa.js 구현 방법\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이제 Koa에서 동등한 내용을 살펴봅시다.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Koa\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"require\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'koa'\"\n        }), \");\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" app = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Koa\"\n        }), \"();\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 인증 미들웨어\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"auth\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"ctx, next\"\n        }), \") =\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" token = ctx.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"headers\"\n        }), \"[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'auth-token'\"\n        }), \"];\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!token) ctx.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"throw\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"401\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'액세스 거부'\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 토큰 확인 및 진행\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ...\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 권한 부여 미들웨어\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"authorize\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"ctx, next\"\n        }), \") =\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" user = ctx.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"user\"\n        }), \";\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (!user || !user.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"isAdmin\"\n        }), \") ctx.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"throw\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"403\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'사용 권한이 없습니다.'\"\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 로깅 미들웨어\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"logger\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"ctx, next\"\n        }), \") =\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" start = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getTime\"\n        }), \"();\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" ms = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Date\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"getTime\"\n        }), \"() - start;\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`\", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${ctx.method}\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${ctx.url}\"\n          }), \" - \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${ms}\"\n          }), \"ms`\"]\n        }), \");\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 책 요청 로깅 및 유효성 검사 미들웨어\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"validateAndLogBookRequest\"\n        }), \" = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"async\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"ctx, next\"\n        }), \") =\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 요청 데이터 유효성 검사 (Joi 또는 다른 라이브러리 사용 가능)\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 잘못된 경우 '400 잘못된 요청' 오류 발생\"\n        }), \"\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 책 요청 로깅\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"`Received a book request for \", _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${ctx.request.body.drugName}\"\n          }), \" at \", _jsxs(_components.span, {\n            className: \"hljs-subst\",\n            children: [\"${\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"new\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-built_in\",\n              children: \"Date\"\n            }), \"().getTime()}\"]\n          }), \"`\"]\n        }), \");\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"await\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"next\"\n        }), \"();\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 서버 경로 설정\"\n        }), \"\\napp.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"use\"\n        }), \"(logger); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 모든 경로에 로거 사용\"\n        }), \"\\napp.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"use\"\n        }), \"(auth, authorize); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 모든 경로에 인증과 권한을 사용\"\n        }), \"\\napp.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"use\"\n        }), \"(validateAndLogBookRequest); \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 모든 경로에 책 요청 로거 및 유효성 검사 사용\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 요청 수신 대기\"\n        }), \"\\napp.\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"listen\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3000\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-function\",\n          children: \"() =\u003e\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable language_\",\n          children: \"console\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"log\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'서버가 3000번 포트에서 수신 대기 중입니다.'\"\n        }), \");\\n});\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 간단한 예제에서는 모든 요청에 대한 로깅, 의약품 자원에 대한 인증 및 권한 부여, 그리고 책 요청 로깅 및 유효성 검사를 위해 미들웨어를 사용했습니다. Express와 Koa 사이의 구현이 매우 유사하다는 점을 알 수 있습니다. 주요 차이점은 Koa가 더 읽기 쉽고 유지보수하기 쉬운 코드를 위해 async/await 구문을 사용한다는 것입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"Express.js vs Koa.js: 두 미들웨어의 이야기\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_5.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Node 마이크로서비스를 개발할 때 Express와 Koa 중 어떤 것을 선택할지는 특정 프로젝트 요구 사항, 팀이 프레임워크에 익숙한 정도, 장기적인 유지 보수 관점 등 여러 요소에 따라 결정됩니다. 그럼 각 프레임워크의 강점을 살펴보고 미들웨어 처리 면에서 어떻게 비교되는지 알아봅시다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Express.js 장점\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Express는 Koa보다 오랜 기간 사용되어 왔으며 현재 더 인기가 많습니다. 방대한 커뮤니티와 다양한 자원이 제공되어 많은 개발자들에게 특히 간단한 웹 애플리케이션이나 REST API 개발에 용이한 선택지입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Express의 미들웨어 아키텍처는 간단하고 직관적으로 설계되어 있어, 가파른 학습 곡선 없이도 강력한 기능 세트가 필요한 애플리케이션에 좋은 선택으로 떠오릅니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Koa.js의 강점\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Koa는 미들웨어 관리에 대한 혁신적인 접근 방식을 제공하며, 비동기 함수의 사용으로 코드를 더 읽기 쉽고 유지보수하기 쉽게 만들어 줍니다. 이는 Node.js에서 보편적으로 발생하는 콜백 지옥(callback hell)을 제거해줍니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Koa는 더 가벼우면서도 표현력이 풍부하고 견고한 웹 애플리케이션과 API의 기반을 제공하며, async 함수를 통해 콜백을 버리고 에러 처리를 크게 향상시킬 수 있습니다. Koa는 자체적으로 미들웨어를 포함하지 않으며, 서버를 빠르고 즐겁게 작성할 수 있는 다양한 메서드를 제공합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_6.png\",\n        alt: \"2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_6\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"미들웨어 비교\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"익스프레스와 코아는 각자 독특한 방식으로 미들웨어를 다루는데, 첫 번째는 더 전통적인 방식을 사용합니다. 미들웨어 함수는 요청 및 응답 객체에 액세스할 수 있으며 직접 작동할 수 있어서 제어 흐름을 이해하고 디버깅하기 쉽습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"반면, 코아는 현대적인 JavaScript 기능을 사용하며, 미들웨어가 실행을 다음 미들웨어에 \\\"양보\\\"하고 스택이 해제될 때 재개될 수 있도록 흐름을 제어하게 합니다. 이는 코드를 더 선형적이고 쉽게 읽을 수 있게 만드는 반면, JavaScript 제너레이터 및 프로미스에 대한 깊은 이해가 필요합니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"아직 끝나지 않았어요\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_8.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Express.js와 Koa.js를 비교한 결론을 도출해본 결과, Express는 직관적이고 간단한 방법론을 채택했으며, Koa는 JavaScript의 비동기 함수를 활용한 더 간략하고 현대적인 접근 방식을 취했습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Middleware를 최적화하는 것은 Node.js 애플리케이션 전반의 성능을 향상시키는 일부분에 불과하다는 것을 명심해주세요. 저의 이전 글인 \\\"이벤트 루프를 통해 Node.js의 성능 향상하기: 사례 연구를 통해 더 나은 성능\\\"에서 Node가 이벤트 루프를 어떻게 활용해 효율적으로 작업을 처리하는지 심층적으로 살펴볼 수 있습니다. 이를 통해 성능 최적화에 대한 깊은 이해를 얻을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"반면에, 애플리케이션의 구조와 효율성을 더욱 향상시키기 위해 이벤트 주도 아키텍처를 채택하는 것을 고려해보세요. 또 다른 기사인 \\\"Node.js 및 TypeScript를 사용한 이벤트 주도형 REST API 만들기: 실용적인 접근\\\"에서는 Node와 TypeScript를 활용하여 강력하고 효율적인 REST API를 구축하는 방법을 안내하고 있습니다. 여기서는 간단한 이벤트 주도 접근 방식에 중점을 두며 독자를 안내합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"즐거운 코딩하시고, 앞으로의 기사에서 더 많은 통찰과 실용적인 접근법을 공유하기를 기대하고 있습니다!\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"레고처럼 재사용 가능한 컴포넌트로 구성 가능한 앱을 구축하자\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs_9.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Bit는 본질적으로 조립 가능한 소프트웨어를 개발하기 위한 오픈 소스 도구 모음입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Bit를 사용하면 현대적인 웹 애플리케이션, UI 컴포넌트, 백엔드 서비스 또는 CLI 스크립트와 같은 어떤 소프트웨어 요소든 독립적이고 재사용 가능하며 조립 가능한 소프트웨어 단위로 개발할 수 있습니다. 어플리케이션 간에 어떤 컴포넌트라도 공유하여 협업을 더 쉽게 하고 더 빠르게 빌드할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"조립 가능한 소프트웨어를 함께 만드는 100,000명 이상의 개발자 중 하나가 되어보세요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 자습서로 시작해보세요:\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"→ 마이크로 프론트엔드: 비디오 // 안내\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"→ 코드 공유: 비디오 // 안내\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"→ 현대화: 비디오 // 안내\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"→ 모노 레포: 비디오 // 안내\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"→ 마이크로서비스: 비디오 // 가이드\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"→ 디자인 시스템: 비디오 // 가이드\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"추천 문서:\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-14-ImplementingMiddlewareinNodejsAComparativeStudyofExpressjsandKoajs"},"buildId":"K-h7XvEVBqnNx_uXMgZoe","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>