<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>고객 세분화 SQL로 RFM 모델 구현하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="고객 세분화 SQL로 RFM 모델 구현하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="고객 세분화 SQL로 RFM 모델 구현하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL" data-gatsby-head="true"/><meta name="twitter:title" content="고객 세분화 SQL로 RFM 모델 구현하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-15 16:08" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-a8eda6c93e0b14fe.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_buildManifest.js" defer=""></script><script src="/_next/static/R94iUTCf1NWeBC_VXjTJG/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">고객 세분화 SQL로 RFM 모델 구현하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="고객 세분화 SQL로 RFM 모델 구현하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 15, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><img src="/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_0.png"/>
<p>현재의 데이터 기반 비즈니스 환경에서는 고객 행동을 이해하는 것이 성공에 중요합니다. 여러 산업의 기업들은 고객의 선호도, 구매 패턴, 충성도를 파악하여 정보에 기반한 결정을 내리고 성장을 이끌기 위해 노력합니다. 고객 행동을 분석하는 가장 강력한 방법 중 하나는 RFM 모델입니다. 이 모델을 통해 기업은 기존 고객층의 구매 행동에 대한 더 나은 통찰력을 얻어 고객 분할을 실시하고 각 세그먼트의 성과를 향상시키기 위한 점수 시스템을 적용할 수 있습니다.</p>
<p>RFM 모델을 통해 기업은 중요한 소비 및 광범위한 쇼핑 요구를 가진 고객(즉, 가장 활동적인 구매자)를 식별할 수 있으며, 최근 접촉 기회가 적은 고객들을 재참여시키고, 리텐션 비율을 개선하고, 사용자 이탈을 방지하며, 데이터 기반 접근 방식을 사용하여 세그먼트 간의 마케팅 예산 할당을 향상시킬 수 있습니다.</p>
<h2>RFM 모델 이해하기</h2>
<p>RFM 모델은 고객 분할 기술로, 고객 행동의 세 가지 주요 요소인 Recency(최근성), Frequency(빈도), Monetary Value(금액)을 평가합니다.</p>
<ul>
<li>Recency(최근성, R): 고객이 회사에서 마지막 구매 또는 상호 작용 이후로 경과한 시간을 측정하는 메트릭입니다. 구매가 더 최근에 이루어지면 재구매 및 고객 참여 가능성이 높아집니다.</li>
<li>Frequency(빈도, F): 이 메트릭은 고객이 주어진 기간 동안 구매를 얼마나 자주하거나 회사와 상호 작용하는지를 추적합니다. 더 높은 구매 빈도를 갖는 고객들은 일반적으로 더 충성도가 높고 가치가 있는 고객입니다.</li>
<li>Monetary Value(금액, M): 이 메트릭은 고객이 회사에서 지출한 총 금액을 정량화합니다. 높은 금액은 종종 수익에 크게 기여하는 더 유리한 고객을 나타냅니다.</li>
</ul>
<p>이 세 가지 요소 (R, F, &amp; M)를 결합하여 RFM 모델은 각 고객에게 점수를 할당하여 비즈니스가 고객 기반을 분할하고 그에 맞게 전략을 조정할 수 있도록 돕습니다.</p>
<h2>RFM 모델의 비즈니스 영향</h2>
<p>RFM 모델은 고객 관계와 마케팅 노력을 최적화하려는 비즈니스에 다양한 이점을 제공합니다:</p>
<ul>
<li>고가치 및 위험한 고객 식별: RFM 모델을 사용하면 비즈니스가 가장 가치 있는 고객과 이탈 위험이 있는 고객을 식별할 수 있습니다. 이 정보를 활용하여 자원 할당 및 선제적 유지 노력을 가이드할 수 있습니다.</li>
<li>타겟 마케팅 및 고객 유지 전략: RFM 점수를 기준으로 고객을 세분화하여, 각 세그먼트의 요구 사항과 행동에 맞는 타겟 마케팅 캠페인 및 유지 전략을 개발할 수 있습니다.</li>
<li>자원 할당 및 캠페인 효과성 최적화: 가장 유망한 고객 세그먼트에 마케팅 노력과 자원을 집중함으로써, 비즈니스는 투자 대비 최대 수익률(ROI)과 캠페인 효과를 극대화할 수 있습니다.</li>
</ul>
<h2>데이터 준비</h2>
<p>RFM 모델을 구현하기 전에 고객 데이터의 무결성과 품질을 보장하는 것이 중요합니다. 이 글에서는 학습 목적으로 흔히 사용되는 샘플 데이터베이스인 SQL Server의 Northwind 데이터베이스를 사용할 것입니다.</p>
<p>노스윈드 데이터베이스에는 주문, 고객, 제품과 같은 가상 거래 회사와 관련된 엔티티에 대한 테이블이 포함되어 있습니다. 저희의 분석에서는 주문, 주문 상세 및 고객 테이블에 초점을 맞출 것입니다. 이 테이블들은 고객 구매 및 고객 세부 정보에 관한 정보가 포함되어 있습니다.</p>
<p>데이터 준비 단계에서는 누락된 값 처리, 다른 소스에서 데이터 통합 및 데이터 일관성 보장과 같은 작업이 포함될 수 있습니다. 데이터가 준비되면 SQL Server 쿼리를 사용하여 RFM 모델을 구현할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_1.png" alt="RFM Model"/></p>
<p>Customers: 이 테이블은 회사의 등록 고객에 대한 포괄적인 세부 정보를 저장하며, 아직 구매를 안 한 고객도 포함됩니다.</p>
<p>주문: 이 테이블은 고객이 주문한 모든 주문의 기록을 포함하며, 주문 날짜, 필요 날짜, 배송 주소 및 관련 주문 세부 정보와 같은 세부 사항이 포함되어 있습니다.</p>
<p>주문 세부 정보: 이 테이블은 각 주문에 포함된 개별 제품 및 수량에 대한 섬세한 정보를 저장하며, 단위 가격 및 적용된 할인과 같은 세부 사항이 포함되어 있습니다.</p>
<h2>SQL Server로 RFM 모델 구현</h2>
<p>노스윈드 데이터베이스의 각 고객에 대한 RFM 점수를 계산하기 위해 SQL 쿼리를 작성할 것입니다. 이 쿼리들은 데이터베이스 테이블에서 필요한 정보를 추출하기 위해 다양한 SQL 함수와 기술을 활용할 것입니다.</p>
<p>Step 1: 노스윈드 데이터베이스 설정</p>
<p>다음 GitHub 저장소에서 instnwnd.sql 스크립트를 다운로드하여 SQL Server용 노스윈드 샘플 데이터베이스를 생성하고 로드합니다. 노스윈드 데이터베이스를 사용하기 전에 SQL Server Management Studio나 유사한 도구를 사용하여 다운로드한 instnwnd.sql 스크립트 파일을 실행하여 SQL Server의 인스턴스에 데이터베이스를 다시 만들어야 합니다. 저장소의 README 파일 안내에 따라 진행하십시오.</p>
<p>Step 2: 고객 테이블 준비:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">WITH</span> customers_cte <span class="hljs-variable constant_">AS</span> (
  <span class="hljs-variable constant_">SELECT</span> 
    c.<span class="hljs-property">CustomerID</span>
   ,<span class="hljs-title function_">COUNT</span>(<span class="hljs-variable constant_">DISTINCT</span> o.<span class="hljs-property">OrderID</span>) <span class="hljs-variable constant_">AS</span> orders
   ,<span class="hljs-title function_">SUM</span>(od.<span class="hljs-property">UnitPrice</span> * od.<span class="hljs-property">Quantity</span> * (<span class="hljs-number">1</span> - od.<span class="hljs-property">Discount</span>)) <span class="hljs-variable constant_">AS</span> order_value
   ,<span class="hljs-title function_">MAX</span>(o.<span class="hljs-property">OrderDate</span>) <span class="hljs-variable constant_">AS</span> last_order_date
   <span class="hljs-variable constant_">FROM</span> <span class="hljs-title class_">Customers</span> c 
   <span class="hljs-variable constant_">LEFT</span> <span class="hljs-variable constant_">JOIN</span> <span class="hljs-title class_">Orders</span> o <span class="hljs-variable constant_">ON</span> (c.<span class="hljs-property">CustomerID</span> = o.<span class="hljs-property">CustomerID</span>)
   <span class="hljs-variable constant_">LEFT</span> <span class="hljs-variable constant_">JOIN</span> [<span class="hljs-title class_">Order</span> <span class="hljs-title class_">Details</span>] od <span class="hljs-variable constant_">ON</span> (o.<span class="hljs-property">OrderID</span> = od.<span class="hljs-property">OrderID</span>)
   <span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span>  c.<span class="hljs-property">CustomerID</span>
  )


<span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> customers_cte
</code></pre>
<p>RFM 모델 구현의 첫 번째 부분인이 쿼리는 데이터베이스의 각 CustomerID에 대해 RFM 분석에 필요한 주요 지표를 계산합니다.</p>
<ul>
<li>이 쿼리는 Customers 테이블과 Orders / Order Details 테이블을 CustomerID 열을 기준으로 왼쪽 조인합니다. 이렇게 함으로써 모든 고객이 결과에 포함되도록 보장합니다. 심지어 주문 내역이 없는 경우에도 포함됩니다.</li>
<li>MAX(o.OrderDate)를 사용하여 고객의 가장 최근 주문 날짜를 찾고 last_order_date의 별칭으로 할당합니다.</li>
<li>각 고객이 한 번 이상 주문한 고유 주문 수를 COUNT(DISTINCT o.OrderID)로 계산하고 orders의 별칭을 할당합니다.</li>
<li>고객이 주문한 모든 주문의 총 금액을 다음 표현식을 사용하여 계산합니다: SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)). 이 표현식은 각 주문 라인 항목 (Order Details 테이블)에 대해 단가, 수량 및 할인 요소(1 - 할인)의 곱셈을 합산합니다. 결과는 order_value의 별칭으로 할당됩니다.</li>
</ul>
<p>단계 3: 최신성, 빈도 및 경제적 가치 점수 계산:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">WITH</span> rfm_cte <span class="hljs-variable constant_">AS</span> (
   <span class="hljs-variable constant_">SELECT</span> *
   ,<span class="hljs-title function_">PERCENT_RANK</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-title class_">Order</span> by last_order_date) <span class="hljs-variable constant_">AS</span> recency
   ,<span class="hljs-title function_">PERCENT_RANK</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-title class_">Order</span> by orders) <span class="hljs-variable constant_">AS</span> frequency
   ,<span class="hljs-title function_">PERCENT_RANK</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-title class_">Order</span> by order_value) <span class="hljs-variable constant_">AS</span> monetary
   <span class="hljs-variable constant_">FROM</span> customers_cte
  )


<span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> rfm_cte
</code></pre>
<p>이 쿼리는 PERCENT_RANK() 창 함수를 사용하여 각 고객의 Recency, Frequency 및 Monetary Value 점수를 계산합니다. PERCENT_RANK() 함수는 지정된 순서대로 각 행을 순위 매기고 해당 파티션의 행 중에서 상대적 위치를 나타내는 0에서 1 사이의 백분위 순위 값을 각 행에 할당합니다.</p>
<ul>
<li>PERCENT_RANK() OVER (ORDER BY last_order_date): 이는 last_order_date로 정렬된 모든 고객의 각 고객 last_order_date의 백분위 순위를 계산합니다. 더 최근 주문을 한 고객일수록 더 높은 순위를 갖습니다.</li>
<li>PERCENT_RANK() OVER (ORDER BY orders): 이는 주문 횟수로 모든 고객의 주문 횟수의 백분위 순위를 계산합니다. 주문이 더 많은 고객일수록 더 높은 순위를 갖습니다.</li>
<li>PERCENT_RANK() OVER (ORDER BY order_value): 이는 주문 가치로 모든 고객의 주문 가치의 백분위 순위를 계산합니다. 주문 가치가 높은 고객일수록 더 높은 순위를 갖습니다.</li>
</ul>
<p>0부터 1 사이의 이러한 점수를 정규화하는 이유는 세 가지 RFM 요인이 최종 점수에 동등하게 기여하도록하고 값의 크기나 척도의 차이로 인해 어떤 단일 요인도 우위를 선점하지 못하도록하기 위함입니다.</p>
<p>단계 4: RFM 점수 결합하기:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">WITH</span> score_cte <span class="hljs-variable constant_">AS</span> (
   <span class="hljs-variable constant_">SELECT</span> *
   ,(<span class="hljs-number">0.2</span> * recency) + (<span class="hljs-number">0.4</span> * frequency) + (<span class="hljs-number">0.4</span> * monetary) <span class="hljs-variable constant_">AS</span> rfm_wights
   ,<span class="hljs-title function_">PERCENT_RANK</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> (<span class="hljs-number">0.2</span> * recency)
                                + (<span class="hljs-number">0.4</span> * frequency)
                                + (<span class="hljs-number">0.4</span> * monetary)) <span class="hljs-variable constant_">AS</span> norm rfm_score
   <span class="hljs-variable constant_">FROM</span> rfm_cte
   )

 <span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> score_cte
</code></pre>
<p>이 쿼리는 각 고객에 대해 Recency, Frequency, Monetary Value 점수를 지정된 가중치를 사용하여 결합하여 가중 RFM 점수를 계산합니다.</p>
<ul>
<li>recency<em>0.2 + frequency</em>0.4 + monetary*0.4 AS rfm_weights: 이것은 R-F-M 값 점수의 가중 합계를 계산합니다. 이 예에서, 빈도 및 통화 가치가 내 비즈니스에서 동일하게 중요하며 Recency 수직보다 더 중요하다고 결정했습니다. 따라서 빈도 및 통화 가치 점수는 각각 40%의 가중치가 주어지고, Recency 점수는 오직 20%의 가중치가 주어집니다. 가중 합계는 rfm_weights 별칭에 할당됩니다. 이 가중치는 특정 비즈니스 및 사용 사례에 대한 RFM 모델의 각 요소의 상대적 중요도를 기반으로 조정할 수 있습니다.</li>
<li>그런 다음 PERCENT_RANK 함수를 사용하여 가중 RFM 점수를 다시 0과 1 사이의 값으로 정규화합니다. 이것은 norm_rfm_score 별칭에 할당됩니다. 결과적인 norm_rfm_score 열은 각 고객에 대한 전반적인 RFM 점수를 나타내며, 나중에 고객 분할 및 분석에 사용할 수 있습니다 (다음 단계에서 설명하겠습니다).</li>
</ul>
<p>단계 5: RFM 모델을 사용한 고객 분할 적용하기```</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
 <span class="hljs-title class_">CustomerID</span>
,orders
,<span class="hljs-title function_">ISNULL</span>(order_value,<span class="hljs-number">0</span>) <span class="hljs-variable constant_">AS</span> order_value
,<span class="hljs-title function_">CAST</span>(last_order_date <span class="hljs-variable constant_">AS</span> <span class="hljs-variable constant_">DATE</span>) <span class="hljs-variable constant_">AS</span> last_order_date
,recency
,frequency
,monetary
,norm_rfm_score
,<span class="hljs-variable constant_">CASE</span> <span class="hljs-variable constant_">WHEN</span> orders = <span class="hljs-number">0</span> <span class="hljs-variable constant_">THEN</span> <span class="hljs-string">&#x27;E&#x27;</span>
   <span class="hljs-variable constant_">WHEN</span> norm_rfm_score &gt;= <span class="hljs-number">0.95</span> <span class="hljs-variable constant_">THEN</span> <span class="hljs-string">&#x27;A&#x27;</span>
   <span class="hljs-variable constant_">WHEN</span> norm_rfm_score &gt;= <span class="hljs-number">0.80</span> <span class="hljs-variable constant_">THEN</span> <span class="hljs-string">&#x27;B&#x27;</span>
   <span class="hljs-variable constant_">WHEN</span> norm_rfm_score &gt;= <span class="hljs-number">0.50</span> <span class="hljs-variable constant_">THEN</span> <span class="hljs-string">&#x27;C&#x27;</span>
   <span class="hljs-variable constant_">ELSE</span> <span class="hljs-string">&#x27;D&#x27;</span>
   <span class="hljs-variable constant_">END</span> <span class="hljs-variable constant_">AS</span> segment
<span class="hljs-variable constant_">FROM</span> score_cte
<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> norm_rfm_score <span class="hljs-variable constant_">DESC</span>
</code></pre>
<p>이 최종 쿼리는 RFM 모델 결과를 제시하고 계산된 RFM 정규화 점수를 기반으로 고객 세분화를 제안합니다:</p>
<p>CASE WHEN orders = 0 THEN <code>E</code> WHEN norm_rfm_score <code>= 0.95 THEN </code>A<code>WHEN norm_rfm_score</code>= 0.80 THEN <code>B</code> WHEN norm_rfm_score <code>= 0.50 THEN </code>C<code>ELSE</code>D` END AS segment: 각 고객에 대한 RFM 점수를 기준으로 세그먼트 레이블을 할당하는 CASE 문입니다.</p>
<p>A. 상위 5%의 고객으로 RFM 점수가 0.95 이상인 고객</p>
<p>B. RFM 점수가 0.8에서 0.95 사이인 고객 중 상위 15%</p>
<p>C. RFM 점수가 0.5에서 0.8 사이인 고객 중 상위 30%</p>
<p>D. RFM 점수가 0.5 미만인 고객 중 하위 50%</p>
<p>E. 아무 주문이 없는 고객(주문 횟수 = 0)</p>
<h2>RFM 점수 및 세분화 해석</h2>
<p>RFM 점수를 계산하고 나면 결과를 해석하고 고객 베이스를 적절히 분할할 수 있습니다. 일반적으로 높은 RFM 점수를 받은 고객은 최고 가치가 있거나 충성도가 높은 고객으로 간주됩니다. 왜냐하면 최근에 구매를 한 경우가 많고 비즈니스와 자주 상호 작용하며 상당한 금전적 가치를 제공하기 때문입니다. 반면에 낮은 RFM 점수를 받은 고객은 최근에 구매를 하지 않았거나 구매 빈도가 낮으며 상대적으로 낮은 금전적 가치를 제공할 수 있어 이탈 위험에 처해 있을 수 있습니다.</p>
<p>RFM 점수와 고객 세그먼트의 분포를 분석함으로써, 기업은 고객 유지, 유치, 교차 판매/상위 판매를 위한 타겟팅된 전략을 개발할 수 있습니다.</p>
<h2>분석 시각화</h2>
<p>RFM 행렬은 RFM 모델로부터 통찰력을 얻고 해석하는 데 강력한 도구입니다. 데이터 기반의 의사결정을 용이하게 하며 고객 관계 관리 전략을 최적화합니다.</p>
<p>RFM 행렬은 고객 세그먼트의 시각적 표현을 제공하여 기업이 패턴, 이상값 및 기회 영역을 식별할 수 있도록 돕습니다. 행렬을 통해 고객이 분산되는 상황을 분석함으로써, 기업은 각 세그먼트에 대해 리텐션 노력, 위험에 노출된 고객을 되찾는 캠페인, 미표시된 세그먼트에 대한 확보 전략 등을 개발할 수 있습니다.</p>
<p>RFM 산점도 행렬 분석</p>
<p>RFM 산점도 행렬은 최근성, 빈도 및 금액 가치 차원 간의 분포와 관계를 시각화합니다. 이 강력한 시각화 도구는 대각선 상에 각 개별 RFM 차원의 분포를 나타내며, 비대각선 도표는 이러한 차원 쌍 간의 관계를 설명합니다.</p>
<img src="/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_2.png"/>
<p>색으로 구분된 세그먼트는 서로 다른 고객 그룹의 특성에 대한 소중한 통찰력을 제공합니다. 가장 가치 있는 고객을 대표하는 &#x27;A&#x27; 세그먼트(파란 점)는 상위 우측 모서리에 집중되어 있어 높은 최근성(Recency), 빈도(Frequency), 그리고 통화가치(Monetary Value) 점수를 나타냅니다. 반면에, 상대적으로 가치가 낮거나 비활성화된 고객을 대표하는 &#x27;D&#x27;와 &#x27;E&#x27; 세그먼트(주황색 및 빨간 점)는 낮은 점수를 보이는 하향 좌하단에 집중되어 있습니다.</p>
<p>색상 점의 분포와 패턴을 분석함으로써, 타겟 마케팅 전략, 고객 유지 노력, 또는 고객 유치 캠페인을 위한 잠재적인 영역을 식별할 수 있습니다. 예를 들어, 평균적인 최근성과 빈도를 가진 &#x27;C&#x27; 세그먼트(초록 점)의 고객을 파악함으로써, 효과적인 교차 판매 또는 업셀링 캠페인에 기회를 발견할 수 있습니다.</p>
<p>참여: 최근성/빈도 매트릭스(ERF)</p>
<p>ERF 행렬은 최신성과 빈도 점수를 기반으로 한 고객 세그먼트의 포괄적인 전망을 제공합니다. 이 시각화는 다음을 기반으로 합니다:</p>
<ul>
<li>참여: 위 예에서 참여 활동은 구매로 정의됩니다. 사용자가 더 많이 구매할수록 비즈니스에 더 많이 참여하게 됩니다. 그러나 참여는 사용자가 비즈니스와 참여를 보이기 위해 수행하는 모든 활동(예: 이메일 오픈, 푸시 알림, 장바구니에 상품 추가 등)로 정의될 수 있습니다.</li>
<li>최신성: 사용자가 참여 활동을 마지막으로 수행한 시간.</li>
<li>빈도: 사용자가 참여 활동을 수행한 횟수.</li>
</ul>
<p>ERF 분석은 R-F 점수 임계값을 사용하여 구성 가능한 세그먼트 정의로 9가지 가능한 세그먼트를 가진 3x3 행렬을 제안하며, 세그먼트 정의는 다음 다이어그램에서 확인할 수 있습니다:</p>
<p><img src="/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_3.png" alt="다이어그램"/></p>
<p>섹션을 구성한 후에는 아래에 플로팅된 ERF 매트릭스를 시각화할 수 있습니다.</p>
<p><img src="/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_4.png" alt="ERF Matrix"/></p>
<h2>결론 및 향후 방향</h2>
<p>RFM 모델은 최근성(Recency), 빈도(Frequency), 금액(Monetary Value) 메트릭을 평가하여 고객 기반을 이해하고 세분화하는 강력한 도구입니다. 이 모델을 구현함으로써 기업은 고객 행동에 대한 가치 있는 통찰력을 얻을 수 있고, 고가치 고객 및 위험 고객을 식별하며, 타겟 마케팅 전략을 개발할 수 있습니다. RFM 매트릭스 및 ERF 매트릭스와 같은 도구를 활용하여 이러한 세그먼트를 시각화하면 의사결정력을 높이고 고객 관계 관리를 최적화할 수 있습니다.</p>
<p>기업들이 데이터 중심의 세계에서 계속 발전함에 따라, 고객 세분화의 미래는 K-평균 모델 및/또는 계층적 군집 덴드로그램과 같은 보다 고급분석과 머신러닝 기술을 통합할 것입니다. 이러한 방법들은 RFM 모델의 개념을 활용하면서 고객 행동에 대한 더 깊은 통찰력과 더 정확한 예측을 제공할 수 있습니다.</p>
<p>실시간 데이터와 AI의 통합은 기업들이 전례 없는 규모로 전략을 동적으로 조정하고 고객 상호작용을 개인화하는 데 도움이 될 것입니다. 앞으로는 RFM 모델을 이러한 고급 기술과 결합하여 기업들이 경쟁력을 유지하고 고객 참여 노력을 향상시킬 수 있습니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"고객 세분화 SQL로 RFM 모델 구현하기","description":"","date":"2024-05-15 16:08","slug":"2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL","content":"\n\n\u003cimg src=\"/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_0.png\" /\u003e\n\n현재의 데이터 기반 비즈니스 환경에서는 고객 행동을 이해하는 것이 성공에 중요합니다. 여러 산업의 기업들은 고객의 선호도, 구매 패턴, 충성도를 파악하여 정보에 기반한 결정을 내리고 성장을 이끌기 위해 노력합니다. 고객 행동을 분석하는 가장 강력한 방법 중 하나는 RFM 모델입니다. 이 모델을 통해 기업은 기존 고객층의 구매 행동에 대한 더 나은 통찰력을 얻어 고객 분할을 실시하고 각 세그먼트의 성과를 향상시키기 위한 점수 시스템을 적용할 수 있습니다.\n\nRFM 모델을 통해 기업은 중요한 소비 및 광범위한 쇼핑 요구를 가진 고객(즉, 가장 활동적인 구매자)를 식별할 수 있으며, 최근 접촉 기회가 적은 고객들을 재참여시키고, 리텐션 비율을 개선하고, 사용자 이탈을 방지하며, 데이터 기반 접근 방식을 사용하여 세그먼트 간의 마케팅 예산 할당을 향상시킬 수 있습니다.\n\n## RFM 모델 이해하기\n\n\n\nRFM 모델은 고객 분할 기술로, 고객 행동의 세 가지 주요 요소인 Recency(최근성), Frequency(빈도), Monetary Value(금액)을 평가합니다.\n\n- Recency(최근성, R): 고객이 회사에서 마지막 구매 또는 상호 작용 이후로 경과한 시간을 측정하는 메트릭입니다. 구매가 더 최근에 이루어지면 재구매 및 고객 참여 가능성이 높아집니다.\n- Frequency(빈도, F): 이 메트릭은 고객이 주어진 기간 동안 구매를 얼마나 자주하거나 회사와 상호 작용하는지를 추적합니다. 더 높은 구매 빈도를 갖는 고객들은 일반적으로 더 충성도가 높고 가치가 있는 고객입니다.\n- Monetary Value(금액, M): 이 메트릭은 고객이 회사에서 지출한 총 금액을 정량화합니다. 높은 금액은 종종 수익에 크게 기여하는 더 유리한 고객을 나타냅니다.\n\n이 세 가지 요소 (R, F, \u0026 M)를 결합하여 RFM 모델은 각 고객에게 점수를 할당하여 비즈니스가 고객 기반을 분할하고 그에 맞게 전략을 조정할 수 있도록 돕습니다.\n\n## RFM 모델의 비즈니스 영향\n\n\n\nRFM 모델은 고객 관계와 마케팅 노력을 최적화하려는 비즈니스에 다양한 이점을 제공합니다:\n\n- 고가치 및 위험한 고객 식별: RFM 모델을 사용하면 비즈니스가 가장 가치 있는 고객과 이탈 위험이 있는 고객을 식별할 수 있습니다. 이 정보를 활용하여 자원 할당 및 선제적 유지 노력을 가이드할 수 있습니다.\n- 타겟 마케팅 및 고객 유지 전략: RFM 점수를 기준으로 고객을 세분화하여, 각 세그먼트의 요구 사항과 행동에 맞는 타겟 마케팅 캠페인 및 유지 전략을 개발할 수 있습니다.\n- 자원 할당 및 캠페인 효과성 최적화: 가장 유망한 고객 세그먼트에 마케팅 노력과 자원을 집중함으로써, 비즈니스는 투자 대비 최대 수익률(ROI)과 캠페인 효과를 극대화할 수 있습니다.\n\n## 데이터 준비\n\nRFM 모델을 구현하기 전에 고객 데이터의 무결성과 품질을 보장하는 것이 중요합니다. 이 글에서는 학습 목적으로 흔히 사용되는 샘플 데이터베이스인 SQL Server의 Northwind 데이터베이스를 사용할 것입니다.\n\n\n\n노스윈드 데이터베이스에는 주문, 고객, 제품과 같은 가상 거래 회사와 관련된 엔티티에 대한 테이블이 포함되어 있습니다. 저희의 분석에서는 주문, 주문 상세 및 고객 테이블에 초점을 맞출 것입니다. 이 테이블들은 고객 구매 및 고객 세부 정보에 관한 정보가 포함되어 있습니다.\n\n데이터 준비 단계에서는 누락된 값 처리, 다른 소스에서 데이터 통합 및 데이터 일관성 보장과 같은 작업이 포함될 수 있습니다. 데이터가 준비되면 SQL Server 쿼리를 사용하여 RFM 모델을 구현할 수 있습니다.\n\n![RFM Model](/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_1.png)\n\nCustomers: 이 테이블은 회사의 등록 고객에 대한 포괄적인 세부 정보를 저장하며, 아직 구매를 안 한 고객도 포함됩니다.\n\n\n\n주문: 이 테이블은 고객이 주문한 모든 주문의 기록을 포함하며, 주문 날짜, 필요 날짜, 배송 주소 및 관련 주문 세부 정보와 같은 세부 사항이 포함되어 있습니다.\n\n주문 세부 정보: 이 테이블은 각 주문에 포함된 개별 제품 및 수량에 대한 섬세한 정보를 저장하며, 단위 가격 및 적용된 할인과 같은 세부 사항이 포함되어 있습니다.\n\n## SQL Server로 RFM 모델 구현\n\n노스윈드 데이터베이스의 각 고객에 대한 RFM 점수를 계산하기 위해 SQL 쿼리를 작성할 것입니다. 이 쿼리들은 데이터베이스 테이블에서 필요한 정보를 추출하기 위해 다양한 SQL 함수와 기술을 활용할 것입니다.\n\n\n\nStep 1: 노스윈드 데이터베이스 설정\n\n다음 GitHub 저장소에서 instnwnd.sql 스크립트를 다운로드하여 SQL Server용 노스윈드 샘플 데이터베이스를 생성하고 로드합니다. 노스윈드 데이터베이스를 사용하기 전에 SQL Server Management Studio나 유사한 도구를 사용하여 다운로드한 instnwnd.sql 스크립트 파일을 실행하여 SQL Server의 인스턴스에 데이터베이스를 다시 만들어야 합니다. 저장소의 README 파일 안내에 따라 진행하십시오.\n\nStep 2: 고객 테이블 준비:\n\n```js\nWITH customers_cte AS (\n  SELECT \n    c.CustomerID\n   ,COUNT(DISTINCT o.OrderID) AS orders\n   ,SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)) AS order_value\n   ,MAX(o.OrderDate) AS last_order_date\n   FROM Customers c \n   LEFT JOIN Orders o ON (c.CustomerID = o.CustomerID)\n   LEFT JOIN [Order Details] od ON (o.OrderID = od.OrderID)\n   GROUP BY  c.CustomerID\n  )\n\n\nSELECT * FROM customers_cte\n```\n\n\n\nRFM 모델 구현의 첫 번째 부분인이 쿼리는 데이터베이스의 각 CustomerID에 대해 RFM 분석에 필요한 주요 지표를 계산합니다.\n\n- 이 쿼리는 Customers 테이블과 Orders / Order Details 테이블을 CustomerID 열을 기준으로 왼쪽 조인합니다. 이렇게 함으로써 모든 고객이 결과에 포함되도록 보장합니다. 심지어 주문 내역이 없는 경우에도 포함됩니다.\n- MAX(o.OrderDate)를 사용하여 고객의 가장 최근 주문 날짜를 찾고 last_order_date의 별칭으로 할당합니다.\n- 각 고객이 한 번 이상 주문한 고유 주문 수를 COUNT(DISTINCT o.OrderID)로 계산하고 orders의 별칭을 할당합니다.\n- 고객이 주문한 모든 주문의 총 금액을 다음 표현식을 사용하여 계산합니다: SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)). 이 표현식은 각 주문 라인 항목 (Order Details 테이블)에 대해 단가, 수량 및 할인 요소(1 - 할인)의 곱셈을 합산합니다. 결과는 order_value의 별칭으로 할당됩니다.\n\n단계 3: 최신성, 빈도 및 경제적 가치 점수 계산:\n\n```js\nWITH rfm_cte AS (\n   SELECT *\n   ,PERCENT_RANK() OVER (Order by last_order_date) AS recency\n   ,PERCENT_RANK() OVER (Order by orders) AS frequency\n   ,PERCENT_RANK() OVER (Order by order_value) AS monetary\n   FROM customers_cte\n  )\n\n\nSELECT * FROM rfm_cte\n```\n\n\n\n이 쿼리는 PERCENT_RANK() 창 함수를 사용하여 각 고객의 Recency, Frequency 및 Monetary Value 점수를 계산합니다. PERCENT_RANK() 함수는 지정된 순서대로 각 행을 순위 매기고 해당 파티션의 행 중에서 상대적 위치를 나타내는 0에서 1 사이의 백분위 순위 값을 각 행에 할당합니다.\n\n- PERCENT_RANK() OVER (ORDER BY last_order_date): 이는 last_order_date로 정렬된 모든 고객의 각 고객 last_order_date의 백분위 순위를 계산합니다. 더 최근 주문을 한 고객일수록 더 높은 순위를 갖습니다.\n- PERCENT_RANK() OVER (ORDER BY orders): 이는 주문 횟수로 모든 고객의 주문 횟수의 백분위 순위를 계산합니다. 주문이 더 많은 고객일수록 더 높은 순위를 갖습니다.\n- PERCENT_RANK() OVER (ORDER BY order_value): 이는 주문 가치로 모든 고객의 주문 가치의 백분위 순위를 계산합니다. 주문 가치가 높은 고객일수록 더 높은 순위를 갖습니다.\n\n0부터 1 사이의 이러한 점수를 정규화하는 이유는 세 가지 RFM 요인이 최종 점수에 동등하게 기여하도록하고 값의 크기나 척도의 차이로 인해 어떤 단일 요인도 우위를 선점하지 못하도록하기 위함입니다.\n\n단계 4: RFM 점수 결합하기:\n\n\n\n```js\nWITH score_cte AS (\n   SELECT *\n   ,(0.2 * recency) + (0.4 * frequency) + (0.4 * monetary) AS rfm_wights\n   ,PERCENT_RANK() OVER (ORDER BY (0.2 * recency)\n                                + (0.4 * frequency)\n                                + (0.4 * monetary)) AS norm rfm_score\n   FROM rfm_cte\n   )\n\n SELECT * FROM score_cte\n```\n\n이 쿼리는 각 고객에 대해 Recency, Frequency, Monetary Value 점수를 지정된 가중치를 사용하여 결합하여 가중 RFM 점수를 계산합니다.\n\n- recency*0.2 + frequency*0.4 + monetary*0.4 AS rfm_weights: 이것은 R-F-M 값 점수의 가중 합계를 계산합니다. 이 예에서, 빈도 및 통화 가치가 내 비즈니스에서 동일하게 중요하며 Recency 수직보다 더 중요하다고 결정했습니다. 따라서 빈도 및 통화 가치 점수는 각각 40%의 가중치가 주어지고, Recency 점수는 오직 20%의 가중치가 주어집니다. 가중 합계는 rfm_weights 별칭에 할당됩니다. 이 가중치는 특정 비즈니스 및 사용 사례에 대한 RFM 모델의 각 요소의 상대적 중요도를 기반으로 조정할 수 있습니다.\n- 그런 다음 PERCENT_RANK 함수를 사용하여 가중 RFM 점수를 다시 0과 1 사이의 값으로 정규화합니다. 이것은 norm_rfm_score 별칭에 할당됩니다. 결과적인 norm_rfm_score 열은 각 고객에 대한 전반적인 RFM 점수를 나타내며, 나중에 고객 분할 및 분석에 사용할 수 있습니다 (다음 단계에서 설명하겠습니다).\n\n단계 5: RFM 모델을 사용한 고객 분할 적용하기```\n\n\n\n```js\nSELECT \n CustomerID\n,orders\n,ISNULL(order_value,0) AS order_value\n,CAST(last_order_date AS DATE) AS last_order_date\n,recency\n,frequency\n,monetary\n,norm_rfm_score\n,CASE WHEN orders = 0 THEN 'E'\n   WHEN norm_rfm_score \u003e= 0.95 THEN 'A'\n   WHEN norm_rfm_score \u003e= 0.80 THEN 'B'\n   WHEN norm_rfm_score \u003e= 0.50 THEN 'C'\n   ELSE 'D'\n   END AS segment\nFROM score_cte\nORDER BY norm_rfm_score DESC\n```\n\n이 최종 쿼리는 RFM 모델 결과를 제시하고 계산된 RFM 정규화 점수를 기반으로 고객 세분화를 제안합니다:\n\n\nCASE WHEN orders = 0 THEN `E` WHEN norm_rfm_score `= 0.95 THEN `A` WHEN norm_rfm_score `= 0.80 THEN `B` WHEN norm_rfm_score `= 0.50 THEN `C` ELSE `D` END AS segment: 각 고객에 대한 RFM 점수를 기준으로 세그먼트 레이블을 할당하는 CASE 문입니다.\n\nA. 상위 5%의 고객으로 RFM 점수가 0.95 이상인 고객\n\n\n\nB. RFM 점수가 0.8에서 0.95 사이인 고객 중 상위 15%\n\nC. RFM 점수가 0.5에서 0.8 사이인 고객 중 상위 30%\n\nD. RFM 점수가 0.5 미만인 고객 중 하위 50%\n\nE. 아무 주문이 없는 고객(주문 횟수 = 0)\n\n\n\n## RFM 점수 및 세분화 해석\n\nRFM 점수를 계산하고 나면 결과를 해석하고 고객 베이스를 적절히 분할할 수 있습니다. 일반적으로 높은 RFM 점수를 받은 고객은 최고 가치가 있거나 충성도가 높은 고객으로 간주됩니다. 왜냐하면 최근에 구매를 한 경우가 많고 비즈니스와 자주 상호 작용하며 상당한 금전적 가치를 제공하기 때문입니다. 반면에 낮은 RFM 점수를 받은 고객은 최근에 구매를 하지 않았거나 구매 빈도가 낮으며 상대적으로 낮은 금전적 가치를 제공할 수 있어 이탈 위험에 처해 있을 수 있습니다.\n\nRFM 점수와 고객 세그먼트의 분포를 분석함으로써, 기업은 고객 유지, 유치, 교차 판매/상위 판매를 위한 타겟팅된 전략을 개발할 수 있습니다.\n\n## 분석 시각화\n\n\n\nRFM 행렬은 RFM 모델로부터 통찰력을 얻고 해석하는 데 강력한 도구입니다. 데이터 기반의 의사결정을 용이하게 하며 고객 관계 관리 전략을 최적화합니다.\n\nRFM 행렬은 고객 세그먼트의 시각적 표현을 제공하여 기업이 패턴, 이상값 및 기회 영역을 식별할 수 있도록 돕습니다. 행렬을 통해 고객이 분산되는 상황을 분석함으로써, 기업은 각 세그먼트에 대해 리텐션 노력, 위험에 노출된 고객을 되찾는 캠페인, 미표시된 세그먼트에 대한 확보 전략 등을 개발할 수 있습니다.\n\nRFM 산점도 행렬 분석\n\nRFM 산점도 행렬은 최근성, 빈도 및 금액 가치 차원 간의 분포와 관계를 시각화합니다. 이 강력한 시각화 도구는 대각선 상에 각 개별 RFM 차원의 분포를 나타내며, 비대각선 도표는 이러한 차원 쌍 간의 관계를 설명합니다.\n\n\n\n\u003cimg src=\"/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_2.png\" /\u003e\n\n색으로 구분된 세그먼트는 서로 다른 고객 그룹의 특성에 대한 소중한 통찰력을 제공합니다. 가장 가치 있는 고객을 대표하는 'A' 세그먼트(파란 점)는 상위 우측 모서리에 집중되어 있어 높은 최근성(Recency), 빈도(Frequency), 그리고 통화가치(Monetary Value) 점수를 나타냅니다. 반면에, 상대적으로 가치가 낮거나 비활성화된 고객을 대표하는 'D'와 'E' 세그먼트(주황색 및 빨간 점)는 낮은 점수를 보이는 하향 좌하단에 집중되어 있습니다.\n\n색상 점의 분포와 패턴을 분석함으로써, 타겟 마케팅 전략, 고객 유지 노력, 또는 고객 유치 캠페인을 위한 잠재적인 영역을 식별할 수 있습니다. 예를 들어, 평균적인 최근성과 빈도를 가진 'C' 세그먼트(초록 점)의 고객을 파악함으로써, 효과적인 교차 판매 또는 업셀링 캠페인에 기회를 발견할 수 있습니다.\n\n참여: 최근성/빈도 매트릭스(ERF)\n\n\n\nERF 행렬은 최신성과 빈도 점수를 기반으로 한 고객 세그먼트의 포괄적인 전망을 제공합니다. 이 시각화는 다음을 기반으로 합니다:\n\n- 참여: 위 예에서 참여 활동은 구매로 정의됩니다. 사용자가 더 많이 구매할수록 비즈니스에 더 많이 참여하게 됩니다. 그러나 참여는 사용자가 비즈니스와 참여를 보이기 위해 수행하는 모든 활동(예: 이메일 오픈, 푸시 알림, 장바구니에 상품 추가 등)로 정의될 수 있습니다.\n- 최신성: 사용자가 참여 활동을 마지막으로 수행한 시간.\n- 빈도: 사용자가 참여 활동을 수행한 횟수.\n\nERF 분석은 R-F 점수 임계값을 사용하여 구성 가능한 세그먼트 정의로 9가지 가능한 세그먼트를 가진 3x3 행렬을 제안하며, 세그먼트 정의는 다음 다이어그램에서 확인할 수 있습니다:\n\n![다이어그램](/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_3.png)\n\n\n\n섹션을 구성한 후에는 아래에 플로팅된 ERF 매트릭스를 시각화할 수 있습니다.\n\n![ERF Matrix](/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_4.png)\n\n## 결론 및 향후 방향\n\nRFM 모델은 최근성(Recency), 빈도(Frequency), 금액(Monetary Value) 메트릭을 평가하여 고객 기반을 이해하고 세분화하는 강력한 도구입니다. 이 모델을 구현함으로써 기업은 고객 행동에 대한 가치 있는 통찰력을 얻을 수 있고, 고가치 고객 및 위험 고객을 식별하며, 타겟 마케팅 전략을 개발할 수 있습니다. RFM 매트릭스 및 ERF 매트릭스와 같은 도구를 활용하여 이러한 세그먼트를 시각화하면 의사결정력을 높이고 고객 관계 관리를 최적화할 수 있습니다.\n\n\n\n기업들이 데이터 중심의 세계에서 계속 발전함에 따라, 고객 세분화의 미래는 K-평균 모델 및/또는 계층적 군집 덴드로그램과 같은 보다 고급분석과 머신러닝 기술을 통합할 것입니다. 이러한 방법들은 RFM 모델의 개념을 활용하면서 고객 행동에 대한 더 깊은 통찰력과 더 정확한 예측을 제공할 수 있습니다.\n\n실시간 데이터와 AI의 통합은 기업들이 전례 없는 규모로 전략을 동적으로 조정하고 고객 상호작용을 개인화하는 데 도움이 될 것입니다. 앞으로는 RFM 모델을 이러한 고급 기술과 결합하여 기업들이 경쟁력을 유지하고 고객 참여 노력을 향상시킬 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_0.png"},"coverImage":"/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_0.png","tag":["Tech"],"readingTime":10},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h2: \"h2\",\n    ul: \"ul\",\n    li: \"li\",\n    img: \"img\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    em: \"em\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(\"img\", {\n      src: \"/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_0.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"현재의 데이터 기반 비즈니스 환경에서는 고객 행동을 이해하는 것이 성공에 중요합니다. 여러 산업의 기업들은 고객의 선호도, 구매 패턴, 충성도를 파악하여 정보에 기반한 결정을 내리고 성장을 이끌기 위해 노력합니다. 고객 행동을 분석하는 가장 강력한 방법 중 하나는 RFM 모델입니다. 이 모델을 통해 기업은 기존 고객층의 구매 행동에 대한 더 나은 통찰력을 얻어 고객 분할을 실시하고 각 세그먼트의 성과를 향상시키기 위한 점수 시스템을 적용할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RFM 모델을 통해 기업은 중요한 소비 및 광범위한 쇼핑 요구를 가진 고객(즉, 가장 활동적인 구매자)를 식별할 수 있으며, 최근 접촉 기회가 적은 고객들을 재참여시키고, 리텐션 비율을 개선하고, 사용자 이탈을 방지하며, 데이터 기반 접근 방식을 사용하여 세그먼트 간의 마케팅 예산 할당을 향상시킬 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"RFM 모델 이해하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RFM 모델은 고객 분할 기술로, 고객 행동의 세 가지 주요 요소인 Recency(최근성), Frequency(빈도), Monetary Value(금액)을 평가합니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Recency(최근성, R): 고객이 회사에서 마지막 구매 또는 상호 작용 이후로 경과한 시간을 측정하는 메트릭입니다. 구매가 더 최근에 이루어지면 재구매 및 고객 참여 가능성이 높아집니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Frequency(빈도, F): 이 메트릭은 고객이 주어진 기간 동안 구매를 얼마나 자주하거나 회사와 상호 작용하는지를 추적합니다. 더 높은 구매 빈도를 갖는 고객들은 일반적으로 더 충성도가 높고 가치가 있는 고객입니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Monetary Value(금액, M): 이 메트릭은 고객이 회사에서 지출한 총 금액을 정량화합니다. 높은 금액은 종종 수익에 크게 기여하는 더 유리한 고객을 나타냅니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 세 가지 요소 (R, F, \u0026 M)를 결합하여 RFM 모델은 각 고객에게 점수를 할당하여 비즈니스가 고객 기반을 분할하고 그에 맞게 전략을 조정할 수 있도록 돕습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"RFM 모델의 비즈니스 영향\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RFM 모델은 고객 관계와 마케팅 노력을 최적화하려는 비즈니스에 다양한 이점을 제공합니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"고가치 및 위험한 고객 식별: RFM 모델을 사용하면 비즈니스가 가장 가치 있는 고객과 이탈 위험이 있는 고객을 식별할 수 있습니다. 이 정보를 활용하여 자원 할당 및 선제적 유지 노력을 가이드할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"타겟 마케팅 및 고객 유지 전략: RFM 점수를 기준으로 고객을 세분화하여, 각 세그먼트의 요구 사항과 행동에 맞는 타겟 마케팅 캠페인 및 유지 전략을 개발할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"자원 할당 및 캠페인 효과성 최적화: 가장 유망한 고객 세그먼트에 마케팅 노력과 자원을 집중함으로써, 비즈니스는 투자 대비 최대 수익률(ROI)과 캠페인 효과를 극대화할 수 있습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"데이터 준비\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RFM 모델을 구현하기 전에 고객 데이터의 무결성과 품질을 보장하는 것이 중요합니다. 이 글에서는 학습 목적으로 흔히 사용되는 샘플 데이터베이스인 SQL Server의 Northwind 데이터베이스를 사용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"노스윈드 데이터베이스에는 주문, 고객, 제품과 같은 가상 거래 회사와 관련된 엔티티에 대한 테이블이 포함되어 있습니다. 저희의 분석에서는 주문, 주문 상세 및 고객 테이블에 초점을 맞출 것입니다. 이 테이블들은 고객 구매 및 고객 세부 정보에 관한 정보가 포함되어 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"데이터 준비 단계에서는 누락된 값 처리, 다른 소스에서 데이터 통합 및 데이터 일관성 보장과 같은 작업이 포함될 수 있습니다. 데이터가 준비되면 SQL Server 쿼리를 사용하여 RFM 모델을 구현할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_1.png\",\n        alt: \"RFM Model\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Customers: 이 테이블은 회사의 등록 고객에 대한 포괄적인 세부 정보를 저장하며, 아직 구매를 안 한 고객도 포함됩니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"주문: 이 테이블은 고객이 주문한 모든 주문의 기록을 포함하며, 주문 날짜, 필요 날짜, 배송 주소 및 관련 주문 세부 정보와 같은 세부 사항이 포함되어 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"주문 세부 정보: 이 테이블은 각 주문에 포함된 개별 제품 및 수량에 대한 섬세한 정보를 저장하며, 단위 가격 및 적용된 할인과 같은 세부 사항이 포함되어 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"SQL Server로 RFM 모델 구현\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"노스윈드 데이터베이스의 각 고객에 대한 RFM 점수를 계산하기 위해 SQL 쿼리를 작성할 것입니다. 이 쿼리들은 데이터베이스 테이블에서 필요한 정보를 추출하기 위해 다양한 SQL 함수와 기술을 활용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Step 1: 노스윈드 데이터베이스 설정\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"다음 GitHub 저장소에서 instnwnd.sql 스크립트를 다운로드하여 SQL Server용 노스윈드 샘플 데이터베이스를 생성하고 로드합니다. 노스윈드 데이터베이스를 사용하기 전에 SQL Server Management Studio나 유사한 도구를 사용하여 다운로드한 instnwnd.sql 스크립트 파일을 실행하여 SQL Server의 인스턴스에 데이터베이스를 다시 만들어야 합니다. 저장소의 README 파일 안내에 따라 진행하십시오.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Step 2: 고객 테이블 준비:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WITH\"\n        }), \" customers_cte \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" (\\n  \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SELECT\"\n        }), \" \\n    c.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"CustomerID\"\n        }), \"\\n   ,\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"COUNT\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"DISTINCT\"\n        }), \" o.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"OrderID\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" orders\\n   ,\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"SUM\"\n        }), \"(od.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"UnitPrice\"\n        }), \" * od.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Quantity\"\n        }), \" * (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \" - od.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"Discount\"\n        }), \")) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" order_value\\n   ,\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"MAX\"\n        }), \"(o.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"OrderDate\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" last_order_date\\n   \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FROM\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Customers\"\n        }), \" c \\n   \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"LEFT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"JOIN\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Orders\"\n        }), \" o \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ON\"\n        }), \" (c.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"CustomerID\"\n        }), \" = o.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"CustomerID\"\n        }), \")\\n   \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"LEFT\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"JOIN\"\n        }), \" [\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Order\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Details\"\n        }), \"] od \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ON\"\n        }), \" (o.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"OrderID\"\n        }), \" = od.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"OrderID\"\n        }), \")\\n   \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"GROUP\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BY\"\n        }), \"  c.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"CustomerID\"\n        }), \"\\n  )\\n\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SELECT\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FROM\"\n        }), \" customers_cte\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RFM 모델 구현의 첫 번째 부분인이 쿼리는 데이터베이스의 각 CustomerID에 대해 RFM 분석에 필요한 주요 지표를 계산합니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"이 쿼리는 Customers 테이블과 Orders / Order Details 테이블을 CustomerID 열을 기준으로 왼쪽 조인합니다. 이렇게 함으로써 모든 고객이 결과에 포함되도록 보장합니다. 심지어 주문 내역이 없는 경우에도 포함됩니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"MAX(o.OrderDate)를 사용하여 고객의 가장 최근 주문 날짜를 찾고 last_order_date의 별칭으로 할당합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"각 고객이 한 번 이상 주문한 고유 주문 수를 COUNT(DISTINCT o.OrderID)로 계산하고 orders의 별칭을 할당합니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"고객이 주문한 모든 주문의 총 금액을 다음 표현식을 사용하여 계산합니다: SUM(od.UnitPrice * od.Quantity * (1 - od.Discount)). 이 표현식은 각 주문 라인 항목 (Order Details 테이블)에 대해 단가, 수량 및 할인 요소(1 - 할인)의 곱셈을 합산합니다. 결과는 order_value의 별칭으로 할당됩니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단계 3: 최신성, 빈도 및 경제적 가치 점수 계산:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WITH\"\n        }), \" rfm_cte \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" (\\n   \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SELECT\"\n        }), \" *\\n   ,\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"PERCENT_RANK\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"OVER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Order\"\n        }), \" by last_order_date) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" recency\\n   ,\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"PERCENT_RANK\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"OVER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Order\"\n        }), \" by orders) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" frequency\\n   ,\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"PERCENT_RANK\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"OVER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Order\"\n        }), \" by order_value) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" monetary\\n   \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FROM\"\n        }), \" customers_cte\\n  )\\n\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SELECT\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FROM\"\n        }), \" rfm_cte\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 쿼리는 PERCENT_RANK() 창 함수를 사용하여 각 고객의 Recency, Frequency 및 Monetary Value 점수를 계산합니다. PERCENT_RANK() 함수는 지정된 순서대로 각 행을 순위 매기고 해당 파티션의 행 중에서 상대적 위치를 나타내는 0에서 1 사이의 백분위 순위 값을 각 행에 할당합니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"PERCENT_RANK() OVER (ORDER BY last_order_date): 이는 last_order_date로 정렬된 모든 고객의 각 고객 last_order_date의 백분위 순위를 계산합니다. 더 최근 주문을 한 고객일수록 더 높은 순위를 갖습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"PERCENT_RANK() OVER (ORDER BY orders): 이는 주문 횟수로 모든 고객의 주문 횟수의 백분위 순위를 계산합니다. 주문이 더 많은 고객일수록 더 높은 순위를 갖습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"PERCENT_RANK() OVER (ORDER BY order_value): 이는 주문 가치로 모든 고객의 주문 가치의 백분위 순위를 계산합니다. 주문 가치가 높은 고객일수록 더 높은 순위를 갖습니다.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"0부터 1 사이의 이러한 점수를 정규화하는 이유는 세 가지 RFM 요인이 최종 점수에 동등하게 기여하도록하고 값의 크기나 척도의 차이로 인해 어떤 단일 요인도 우위를 선점하지 못하도록하기 위함입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단계 4: RFM 점수 결합하기:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WITH\"\n        }), \" score_cte \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" (\\n   \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SELECT\"\n        }), \" *\\n   ,(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.2\"\n        }), \" * recency) + (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.4\"\n        }), \" * frequency) + (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.4\"\n        }), \" * monetary) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" rfm_wights\\n   ,\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"PERCENT_RANK\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"OVER\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORDER\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BY\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.2\"\n        }), \" * recency)\\n                                + (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.4\"\n        }), \" * frequency)\\n                                + (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.4\"\n        }), \" * monetary)) \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" norm rfm_score\\n   \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FROM\"\n        }), \" rfm_cte\\n   )\\n\\n \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SELECT\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FROM\"\n        }), \" score_cte\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 쿼리는 각 고객에 대해 Recency, Frequency, Monetary Value 점수를 지정된 가중치를 사용하여 결합하여 가중 RFM 점수를 계산합니다.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"recency\", _jsx(_components.em, {\n          children: \"0.2 + frequency\"\n        }), \"0.4 + monetary*0.4 AS rfm_weights: 이것은 R-F-M 값 점수의 가중 합계를 계산합니다. 이 예에서, 빈도 및 통화 가치가 내 비즈니스에서 동일하게 중요하며 Recency 수직보다 더 중요하다고 결정했습니다. 따라서 빈도 및 통화 가치 점수는 각각 40%의 가중치가 주어지고, Recency 점수는 오직 20%의 가중치가 주어집니다. 가중 합계는 rfm_weights 별칭에 할당됩니다. 이 가중치는 특정 비즈니스 및 사용 사례에 대한 RFM 모델의 각 요소의 상대적 중요도를 기반으로 조정할 수 있습니다.\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"그런 다음 PERCENT_RANK 함수를 사용하여 가중 RFM 점수를 다시 0과 1 사이의 값으로 정규화합니다. 이것은 norm_rfm_score 별칭에 할당됩니다. 결과적인 norm_rfm_score 열은 각 고객에 대한 전반적인 RFM 점수를 나타내며, 나중에 고객 분할 및 분석에 사용할 수 있습니다 (다음 단계에서 설명하겠습니다).\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"단계 5: RFM 모델을 사용한 고객 분할 적용하기```\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"SELECT\"\n        }), \" \\n \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"CustomerID\"\n        }), \"\\n,orders\\n,\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"ISNULL\"\n        }), \"(order_value,\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" order_value\\n,\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"CAST\"\n        }), \"(last_order_date \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"DATE\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" last_order_date\\n,recency\\n,frequency\\n,monetary\\n,norm_rfm_score\\n,\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"CASE\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WHEN\"\n        }), \" orders = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"THEN\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'E'\"\n        }), \"\\n   \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WHEN\"\n        }), \" norm_rfm_score \u003e= \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.95\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"THEN\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'A'\"\n        }), \"\\n   \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WHEN\"\n        }), \" norm_rfm_score \u003e= \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.80\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"THEN\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'B'\"\n        }), \"\\n   \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"WHEN\"\n        }), \" norm_rfm_score \u003e= \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.50\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"THEN\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'C'\"\n        }), \"\\n   \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ELSE\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'D'\"\n        }), \"\\n   \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"END\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"AS\"\n        }), \" segment\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FROM\"\n        }), \" score_cte\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"ORDER\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"BY\"\n        }), \" norm_rfm_score \", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"DESC\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 최종 쿼리는 RFM 모델 결과를 제시하고 계산된 RFM 정규화 점수를 기반으로 고객 세분화를 제안합니다:\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"CASE WHEN orders = 0 THEN \", _jsx(_components.code, {\n        children: \"E\"\n      }), \" WHEN norm_rfm_score \", _jsx(_components.code, {\n        children: \"= 0.95 THEN \"\n      }), \"A\", _jsx(_components.code, {\n        children: \"WHEN norm_rfm_score\"\n      }), \"= 0.80 THEN \", _jsx(_components.code, {\n        children: \"B\"\n      }), \" WHEN norm_rfm_score \", _jsx(_components.code, {\n        children: \"= 0.50 THEN \"\n      }), \"C\", _jsx(_components.code, {\n        children: \"ELSE\"\n      }), \"D` END AS segment: 각 고객에 대한 RFM 점수를 기준으로 세그먼트 레이블을 할당하는 CASE 문입니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"A. 상위 5%의 고객으로 RFM 점수가 0.95 이상인 고객\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"B. RFM 점수가 0.8에서 0.95 사이인 고객 중 상위 15%\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"C. RFM 점수가 0.5에서 0.8 사이인 고객 중 상위 30%\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"D. RFM 점수가 0.5 미만인 고객 중 하위 50%\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"E. 아무 주문이 없는 고객(주문 횟수 = 0)\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"RFM 점수 및 세분화 해석\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RFM 점수를 계산하고 나면 결과를 해석하고 고객 베이스를 적절히 분할할 수 있습니다. 일반적으로 높은 RFM 점수를 받은 고객은 최고 가치가 있거나 충성도가 높은 고객으로 간주됩니다. 왜냐하면 최근에 구매를 한 경우가 많고 비즈니스와 자주 상호 작용하며 상당한 금전적 가치를 제공하기 때문입니다. 반면에 낮은 RFM 점수를 받은 고객은 최근에 구매를 하지 않았거나 구매 빈도가 낮으며 상대적으로 낮은 금전적 가치를 제공할 수 있어 이탈 위험에 처해 있을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RFM 점수와 고객 세그먼트의 분포를 분석함으로써, 기업은 고객 유지, 유치, 교차 판매/상위 판매를 위한 타겟팅된 전략을 개발할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"분석 시각화\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RFM 행렬은 RFM 모델로부터 통찰력을 얻고 해석하는 데 강력한 도구입니다. 데이터 기반의 의사결정을 용이하게 하며 고객 관계 관리 전략을 최적화합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RFM 행렬은 고객 세그먼트의 시각적 표현을 제공하여 기업이 패턴, 이상값 및 기회 영역을 식별할 수 있도록 돕습니다. 행렬을 통해 고객이 분산되는 상황을 분석함으로써, 기업은 각 세그먼트에 대해 리텐션 노력, 위험에 노출된 고객을 되찾는 캠페인, 미표시된 세그먼트에 대한 확보 전략 등을 개발할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RFM 산점도 행렬 분석\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RFM 산점도 행렬은 최근성, 빈도 및 금액 가치 차원 간의 분포와 관계를 시각화합니다. 이 강력한 시각화 도구는 대각선 상에 각 개별 RFM 차원의 분포를 나타내며, 비대각선 도표는 이러한 차원 쌍 간의 관계를 설명합니다.\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_2.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"색으로 구분된 세그먼트는 서로 다른 고객 그룹의 특성에 대한 소중한 통찰력을 제공합니다. 가장 가치 있는 고객을 대표하는 'A' 세그먼트(파란 점)는 상위 우측 모서리에 집중되어 있어 높은 최근성(Recency), 빈도(Frequency), 그리고 통화가치(Monetary Value) 점수를 나타냅니다. 반면에, 상대적으로 가치가 낮거나 비활성화된 고객을 대표하는 'D'와 'E' 세그먼트(주황색 및 빨간 점)는 낮은 점수를 보이는 하향 좌하단에 집중되어 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"색상 점의 분포와 패턴을 분석함으로써, 타겟 마케팅 전략, 고객 유지 노력, 또는 고객 유치 캠페인을 위한 잠재적인 영역을 식별할 수 있습니다. 예를 들어, 평균적인 최근성과 빈도를 가진 'C' 세그먼트(초록 점)의 고객을 파악함으로써, 효과적인 교차 판매 또는 업셀링 캠페인에 기회를 발견할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"참여: 최근성/빈도 매트릭스(ERF)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ERF 행렬은 최신성과 빈도 점수를 기반으로 한 고객 세그먼트의 포괄적인 전망을 제공합니다. 이 시각화는 다음을 기반으로 합니다:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"참여: 위 예에서 참여 활동은 구매로 정의됩니다. 사용자가 더 많이 구매할수록 비즈니스에 더 많이 참여하게 됩니다. 그러나 참여는 사용자가 비즈니스와 참여를 보이기 위해 수행하는 모든 활동(예: 이메일 오픈, 푸시 알림, 장바구니에 상품 추가 등)로 정의될 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"최신성: 사용자가 참여 활동을 마지막으로 수행한 시간.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"빈도: 사용자가 참여 활동을 수행한 횟수.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ERF 분석은 R-F 점수 임계값을 사용하여 구성 가능한 세그먼트 정의로 9가지 가능한 세그먼트를 가진 3x3 행렬을 제안하며, 세그먼트 정의는 다음 다이어그램에서 확인할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_3.png\",\n        alt: \"다이어그램\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"섹션을 구성한 후에는 아래에 플로팅된 ERF 매트릭스를 시각화할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL_4.png\",\n        alt: \"ERF Matrix\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"결론 및 향후 방향\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"RFM 모델은 최근성(Recency), 빈도(Frequency), 금액(Monetary Value) 메트릭을 평가하여 고객 기반을 이해하고 세분화하는 강력한 도구입니다. 이 모델을 구현함으로써 기업은 고객 행동에 대한 가치 있는 통찰력을 얻을 수 있고, 고가치 고객 및 위험 고객을 식별하며, 타겟 마케팅 전략을 개발할 수 있습니다. RFM 매트릭스 및 ERF 매트릭스와 같은 도구를 활용하여 이러한 세그먼트를 시각화하면 의사결정력을 높이고 고객 관계 관리를 최적화할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"기업들이 데이터 중심의 세계에서 계속 발전함에 따라, 고객 세분화의 미래는 K-평균 모델 및/또는 계층적 군집 덴드로그램과 같은 보다 고급분석과 머신러닝 기술을 통합할 것입니다. 이러한 방법들은 RFM 모델의 개념을 활용하면서 고객 행동에 대한 더 깊은 통찰력과 더 정확한 예측을 제공할 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"실시간 데이터와 AI의 통합은 기업들이 전례 없는 규모로 전략을 동적으로 조정하고 고객 상호작용을 개인화하는 데 도움이 될 것입니다. 앞으로는 RFM 모델을 이러한 고급 기술과 결합하여 기업들이 경쟁력을 유지하고 고객 참여 노력을 향상시킬 수 있습니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-15-CustomerSegmentationImplementingtheRFMModelwithSQL"},"buildId":"R94iUTCf1NWeBC_VXjTJG","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>