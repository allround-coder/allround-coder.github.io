<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Niels가 Rust 2를 배웁니다  AVR Rust 시작하기 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Niels가 Rust 2를 배웁니다  AVR Rust 시작하기 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Niels가 Rust 2를 배웁니다  AVR Rust 시작하기 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust" data-gatsby-head="true"/><meta name="twitter:title" content="Niels가 Rust 2를 배웁니다  AVR Rust 시작하기 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 04:11" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cd012fc8787133d0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cd012fc8787133d0.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/551-3069cf29fe274aab.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-985df180e46efe53.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_buildManifest.js" defer=""></script><script src="/_next/static/uXJWf9GNc_Ux38RlnQJQc/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Niels가 Rust 2를 배웁니다  AVR Rust 시작하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Niels가 Rust 2를 배웁니다  AVR Rust 시작하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/assets/profile.jpg"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><p>저는 러스트를 배우기 위해 내 임베디드 Java 가상 머신을 러스트로 이식하는 여정을 문서화하는 시리즈의 두 번째 부분입니다.</p>
<h1>개발 컨테이너에 러스트 설치</h1>
<p>이 첫 번째 단계는 Rust를 설치하는 것인데, rustup을 사용하면 간단합니다:</p>
<pre><code class="hljs language-bash">curl --proto <span class="hljs-string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<div class="content-ad"></div>
<p>하지만 안정적이고 반복 가능한 방식으로 하자면 개발 컨테이너를 사용하는 게 좋겠죠. 개발 컨테이너는 VS Code가 코드를 빌드, 실행 및 디버깅하기 위해 생성하는 컨테이너입니다. 모든 개발 작업은 컨테이너에서 이루어지며, 데스크톱에서 실행 중인 VS Code는 단순히 컨테이너에서 실행 중인 다른 VS Code 인스턴스와 통신하는 UI 역할을 합니다:</p>
<p><img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png" alt="image"/></p>
<p>(출처)</p>
<p>이점은 더 나은 격리와 명확히 정의된 개발 환경입니다. 이 프로젝트에만 사용되는 로컬 도구를 로컬에 설치할 필요가 없으며, 이 리포지토리를 내려받는 모든 사람이 동일한 컨테이너를 사용할 수 있습니다.</p>
<div class="content-ad"></div>
<p>개발 컨테이너를 만드는 것은 매우 쉬워요. 필요한 것은 .devcontainer/devcontainer.json 파일(.devcontainer.json도 가능) 하나 뿐인데, 이 파일 안에는 VS Code가 컨테이너를 빌드하는 데 필요한 정보들이 들어가 있어요.</p>
<p>미리 만들어진 이미지를 사용하거나, 자체 Dockerfile을 지정하여 컨테이너를 빌드할 수 있어요. 저는 후자를 사용하고 있고, 제 devcontainer.json은 이렇게 생겼어요:</p>
<pre><code class="hljs language-js">{
    <span class="hljs-string">&quot;build&quot;</span>: { <span class="hljs-string">&quot;dockerfile&quot;</span>: <span class="hljs-string">&quot;Dockerfile&quot;</span> },

    <span class="hljs-string">&quot;customizations&quot;</span>: {
        <span class="hljs-string">&quot;vscode&quot;</span>: {
            <span class="hljs-string">&quot;extensions&quot;</span>: [<span class="hljs-string">&quot;rust-lang.rust-analyzer&quot;</span>]
        }
    }
}
</code></pre>
<p>dev 컨테이너에서 실행 중인 VS Code 인스턴스에는 기본적으로 어떤 확장도 설치되어 있지 않아요. 로컬로 설치된 확장 목록에서 간단히 클릭하여 추가하거나, json 파일에서 명시하여 자동으로 추가할 수 있어요. 형식은 <code>provider</code>.<code>extension</code>이고, 실제 이름은 UI에서 매우 명확하지 않지만 ~/.vscode/extensions 디렉토리에서 쉽게 찾을 수 있어요.</p>
<div class="content-ad"></div>
<p>도커 파일도 꽤 간단합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">rust</span>:<span class="hljs-number">1.78</span>

<span class="hljs-variable constant_">RUN</span> apt update
<span class="hljs-variable constant_">RUN</span> apt -y install gcc-avr avr-libc <span class="hljs-keyword">default</span>-jre

<span class="hljs-variable constant_">RUN</span> cargo install cargo-generate
</code></pre>
<p>Rust 프로젝트는 사용할 수 있는 도커 이미지를 제공하며, 보통의 Rust 개발에는 충분할 수 있습니다. 그러나 이 프로젝트의 목표는 임베디드 CPU용 Java VM을 빌드하는 것이며, 이 경우 Atmel AVR ATmega 128에 대해 작업하기 위해 몇 가지 추가 패키지를 설치해야 합니다.</p>
<p>cargo는 Rust의 빌드 매니저이며, .NET에서는 dotnet, Scala에서는 sbt, Golang에서는 go와 같은 역할을 합니다. 마지막 줄은 새로운 프로젝트를 템플릿을 기반으로 생성할 수 있도록 하는 크레이트를 설치합니다. 이를 다음 섹션에서 사용할 것입니다.</p>
<div class="content-ad"></div>
<h1>AVR용 러스트</h1>
<p>여기서는 작동하는 러스트 설치 방법을 소개해 드릴게요. Cargo를 사용하여 새 프로젝트를 만들고 실행할 수 있습니다:</p>
<p><img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_1.png" alt="이미지"/></p>
<p>하지만 이것은 저의 로컬 아키텍처에 맞게 빌드되었는데, 저희는 Atmel AVR ATmega128을 위해 빌드하고 싶어요.</p>
<div class="content-ad"></div>
<p>행운이다! 많은 사람들이 AVR을 개발하기 위해 Rust를 사용하고 있어서, 이 동영상을 포함하여 도움이 되는 다양한 자료들이 있습니다. 이 동영상은 새 프로젝트를 설정하기 위한 cargo generate 템플릿을 소개하고 있습니다.</p>
<p>cargo generate --git https://github.com/Rahix/avr-hal-template.git</p>
<p>이 명령은 우리 프로젝트를 위해 템플릿을 구성하는 상호작용적인 흐름을 시작합니다. 이 경우에는 프로젝트 이름과 대상 보드에 대해 두 가지 질문만 있습니다. 실제 보드를 사용하지는 않고 대신 시뮬레이터에서 VM을 실행할 것이기 때문에, 제가 선택한 것은 아두이노 메가 1280입니다.</p>
<p><img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_2.png" alt="NielslearnsRust2GettingstartedwithAVRRust_2 이미지"/></p>
<div class="content-ad"></div>
<p>지금은 ATmega128을 위해 구성된 프로젝트가 있습니다.</p>
<p>Cargo에 빌드하라고 요청하면, 흥미로운 일이 발생합니다:</p>
<p><img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_3.png" alt="이미지"/></p>
<p>Rust의 새 버전을 다운로드 중입니다! Dockerfile이 1.78을 지정했는데도 불구하고 1.79의 nightly 빌드를 받고 있습니다. 왜 이런 일이 발생했을까요?</p>
<div class="content-ad"></div>
<p>여러 개의 Rust 도구 체인을 나란히 설치할 수 있다는 것이 밝혀졌어요. rustup 도구체인 목록을 보면 설치된 도구 체인을 확인할 수 있어요:</p>
<p><img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_4.png" alt="이미지"/></p>
<p>개발 컨테이너의 기본 버전은 1.78이지만, 우리가 만든 프로젝트 내부에서 동일한 명령을 실행하면 2024-03-22의 nightly 빌드로 재정의돼요.</p>
<p>이 일이 발생하는 이유는 템플릿에 rust-toolchain.toml이 포함돼 있어서 특정 버전을 요청했기 때문이에요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-json"><span class="hljs-punctuation">[</span>toolchain<span class="hljs-punctuation">]</span>
channel = <span class="hljs-string">&quot;nightly-2024-03-22&quot;</span>
components = <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;rust-src&quot;</span><span class="hljs-punctuation">]</span>
profile = <span class="hljs-string">&quot;minimal&quot;</span>
</code></pre>
<p>프로젝트를 nightly 빌드에서 시작하는 것이 조금 이상해 보이지만, 템플릿에서 생성된 코드는 1.78에서 컴파일되지 않습니다. 그래서 일단 여기에 남겨둔 채로 나중에 안정 버전으로 옮길 수 있는지 확인해 보겠습니다.</p>
<h1>코드 실행하기</h1>
<p>Cargo도 프로그램을 실행할 수 있지만, 현재 버전에서 시도하면 다음과 같은 오류가 발생합니다:```</p>
<div class="content-ad"></div>
<p>md
<img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_5.png" alt="이미지"/></p>
<p>템플릿은 생성된 실행 파일을 대상 장치로 보내는 도구인 ravedude를 사용하도록 구성되어 있지만 우리는 물리적 장치가 없으므로 수정된 Avrora 시뮬레이터의 버전을 대신 사용할 것입니다.</p>
<p>cargo run을 실행하면 생성된 프로젝트의 capevm/.cargo/config.toml 파일에 있는 설정된 내용이 실행됩니다. 현재 이 파일은 다음과 같은 내용을 포함하고 있습니다:</p>
<pre><code class="hljs language-js">[target.<span class="hljs-string">&#x27;cfg(target_arch = &quot;avr&quot;)&#x27;</span>]
runner = <span class="hljs-string">&quot;ravedude mega1280 -cb 57600&quot;</span>
</code></pre>
<div class="content-ad"></div>
<p>생성된 Rust 코드를 Avrora에서 실행하려면 다음과 같이 변경했어요:</p>
<pre><code class="hljs language-js">[target.<span class="hljs-string">&#x27;cfg(target_arch = &quot;avr&quot;)&#x27;</span>]
runner = <span class="hljs-string">&quot;java -jar ../avrora/avrora-beta-1.7.117.jar -monitors=memory,stack -single&quot;</span>
</code></pre>
<p>지금은 Avrora 시뮬레이터를 컴파일한 파일(단일 .jar 파일)을 직접 저장소에 넣었어요. 이 Avrora 버전은 실행 중인 프로그램을 모니터링할 수 있도록 다양한 프로브로 확장되었지만, 이러한 세부사항은 훨씬 나중에 의미가 있을 거예요. 해당 수정 사항이 포함된 소스코드는 원본 CapeVM 저장소에 있어요.</p>
<h1>AVR “Hello, world”</h1>
<div class="content-ad"></div>
<p>아래는 AVR을 위한 &quot;Hello, world&quot; 동등물을 생성하는 템플릿입니다:</p>
<pre><code class="hljs language-rust"><span class="hljs-meta">#![no_std]</span>
<span class="hljs-meta">#![no_main]</span>

<span class="hljs-keyword">use</span> panic_halt <span class="hljs-keyword">as</span> _;

<span class="hljs-meta">#[arduino_hal::entry]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> ! {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">dp</span> = arduino_hal::Peripherals::<span class="hljs-title function_ invoke__">take</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">pins</span> = arduino_hal::pins!(dp);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">led</span> = pins.d13.<span class="hljs-title function_ invoke__">into_output</span>();

    <span class="hljs-keyword">loop</span> {
        led.<span class="hljs-title function_ invoke__">toggle</span>();
        arduino_hal::<span class="hljs-title function_ invoke__">delay_ms</span>(<span class="hljs-number">1000</span>);
    }
}
</code></pre>
<p>main 함수의 서명인 <code>fn main() -&gt; !</code>는 흥미롭습니다: ! 반환 유형은 함수가 종료되지 않음을 나타냅니다.</p>
<p>이것은 여전히 내게는 이해하기 어렵지만 코드에서 강요된 #[arduino_hal::entry] 속성에 의해 시행됩니다. Rust의 좋은 점 중 하나는 &quot;F12&quot;(정의로 이동)로 거의 모든 것을 조회하여 구현을 볼 수 있다는 것이며, arduino_hal::entry에는 syn::Type::Never(_)가 반환 유형인 !을 포함하는 이 코드 조각이 포함되어 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">// 함수 시그니처를 확인합니다</span>
<span class="hljs-keyword">let</span> valid_signature = f.<span class="hljs-property">sig</span>.<span class="hljs-property">constness</span>.<span class="hljs-title function_">is_none</span>()
    &amp;&amp; f.<span class="hljs-property">vis</span> == <span class="hljs-attr">syn</span>::<span class="hljs-title class_">Visibility</span>::<span class="hljs-title class_">Inherited</span>
    &amp;&amp; f.<span class="hljs-property">sig</span>.<span class="hljs-property">abi</span>.<span class="hljs-title function_">is_none</span>()
    &amp;&amp; f.<span class="hljs-property">sig</span>.<span class="hljs-property">inputs</span>.<span class="hljs-title function_">is_empty</span>()
    &amp;&amp; f.<span class="hljs-property">sig</span>.<span class="hljs-property">generics</span>.<span class="hljs-property">params</span>.<span class="hljs-title function_">is_empty</span>()
    &amp;&amp; f.<span class="hljs-property">sig</span>.<span class="hljs-property">generics</span>.<span class="hljs-property">where_clause</span>.<span class="hljs-title function_">is_none</span>()
    &amp;&amp; f.<span class="hljs-property">sig</span>.<span class="hljs-property">variadic</span>.<span class="hljs-title function_">is_none</span>()
    &amp;&amp; match f.<span class="hljs-property">sig</span>.<span class="hljs-property">output</span> {
        <span class="hljs-attr">syn</span>::<span class="hljs-title class_">ReturnType</span>::<span class="hljs-function"><span class="hljs-params">Default</span> =&gt;</span> <span class="hljs-literal">false</span>,
        <span class="hljs-attr">syn</span>::<span class="hljs-title class_">ReturnType</span>::<span class="hljs-title class_">Type</span>(_, ref ty) =&gt; matches!(**ty, <span class="hljs-attr">syn</span>::<span class="hljs-title class_">Type</span>::<span class="hljs-title class_">Never</span>(_)),
    };
</code></pre>
<p>대부분의 임베디드 CPU 응용 프로그램에는 매우 유용합니다. OS가 없기 때문에 프로그램이 종료되는 방법이 정말 없습니다. 디바이스에서 계속 실행되어야 합니다. 정말 할 일이 남지 않았다면, 디바이스를 절전 상태로 전환하고 깨우는 트리거를 기다리는 것이 가장 좋습니다.</p>
<p>이 루프는 여기서 끝없이 단일 핀을 토글하지만, 실제 보드가 없기 때문에 아직 테스트할 방법이 없습니다. 코드를 시뮬레이터에서 실행하고, Ctrl-C를 눌러 중지한 후에 Avrora가 config.toml에서 활성화한 -monitors에 따라 프로그램이 무엇을 수행했는지에 대한 정보를 출력할 것입니다:</p>
<img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_6.png"/>
<div class="content-ad"></div>
<p>좋아요, 작동이 되네요! 하지만 아직 결과물이 그렇게 유용하진 않네요.</p>
<p>마지막 목표는 네이티브 코드로 컴파일되어 실행되고 성능을 측정하기 위해 여러 벤치마크를 실행하고 확인하는 JVM을 구축하는 것입니다. 이를 위해 더 자세한 출력이 필요하므로, 다음 게시물에서는 디버그 출력 및 다른 계산 도구를 추가하는 방법에 대해 다뤄볼 예정입니다.</p>
<p>이 단계에서의 코드 상태는 여기 Github에서 찾을 수 있습니다.</p>
<p>원문은 2024년 5월 6일에 https://nielsreijers.github.io에서 최초로 게시되었습니다.</p></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Niels가 Rust 2를 배웁니다  AVR Rust 시작하기","description":"","date":"2024-05-17 04:11","slug":"2024-05-17-NielslearnsRust2GettingstartedwithAVRRust","content":"\n\n저는 러스트를 배우기 위해 내 임베디드 Java 가상 머신을 러스트로 이식하는 여정을 문서화하는 시리즈의 두 번째 부분입니다.\n\n# 개발 컨테이너에 러스트 설치\n\n이 첫 번째 단계는 Rust를 설치하는 것인데, rustup을 사용하면 간단합니다:\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 안정적이고 반복 가능한 방식으로 하자면 개발 컨테이너를 사용하는 게 좋겠죠. 개발 컨테이너는 VS Code가 코드를 빌드, 실행 및 디버깅하기 위해 생성하는 컨테이너입니다. 모든 개발 작업은 컨테이너에서 이루어지며, 데스크톱에서 실행 중인 VS Code는 단순히 컨테이너에서 실행 중인 다른 VS Code 인스턴스와 통신하는 UI 역할을 합니다:\n\n![image](/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png)\n\n(출처)\n\n이점은 더 나은 격리와 명확히 정의된 개발 환경입니다. 이 프로젝트에만 사용되는 로컬 도구를 로컬에 설치할 필요가 없으며, 이 리포지토리를 내려받는 모든 사람이 동일한 컨테이너를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개발 컨테이너를 만드는 것은 매우 쉬워요. 필요한 것은 .devcontainer/devcontainer.json 파일(.devcontainer.json도 가능) 하나 뿐인데, 이 파일 안에는 VS Code가 컨테이너를 빌드하는 데 필요한 정보들이 들어가 있어요.\n\n미리 만들어진 이미지를 사용하거나, 자체 Dockerfile을 지정하여 컨테이너를 빌드할 수 있어요. 저는 후자를 사용하고 있고, 제 devcontainer.json은 이렇게 생겼어요:\n\n```js\n{\n    \"build\": { \"dockerfile\": \"Dockerfile\" },\n\n    \"customizations\": {\n        \"vscode\": {\n            \"extensions\": [\"rust-lang.rust-analyzer\"]\n        }\n    }\n}\n```\n\ndev 컨테이너에서 실행 중인 VS Code 인스턴스에는 기본적으로 어떤 확장도 설치되어 있지 않아요. 로컬로 설치된 확장 목록에서 간단히 클릭하여 추가하거나, json 파일에서 명시하여 자동으로 추가할 수 있어요. 형식은 `provider`.`extension`이고, 실제 이름은 UI에서 매우 명확하지 않지만 ~/.vscode/extensions 디렉토리에서 쉽게 찾을 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도커 파일도 꽤 간단합니다:\n\n```js\nFROM rust:1.78\n\nRUN apt update\nRUN apt -y install gcc-avr avr-libc default-jre\n\nRUN cargo install cargo-generate\n```\n\nRust 프로젝트는 사용할 수 있는 도커 이미지를 제공하며, 보통의 Rust 개발에는 충분할 수 있습니다. 그러나 이 프로젝트의 목표는 임베디드 CPU용 Java VM을 빌드하는 것이며, 이 경우 Atmel AVR ATmega 128에 대해 작업하기 위해 몇 가지 추가 패키지를 설치해야 합니다.\n\ncargo는 Rust의 빌드 매니저이며, .NET에서는 dotnet, Scala에서는 sbt, Golang에서는 go와 같은 역할을 합니다. 마지막 줄은 새로운 프로젝트를 템플릿을 기반으로 생성할 수 있도록 하는 크레이트를 설치합니다. 이를 다음 섹션에서 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# AVR용 러스트\n\n여기서는 작동하는 러스트 설치 방법을 소개해 드릴게요. Cargo를 사용하여 새 프로젝트를 만들고 실행할 수 있습니다:\n\n![이미지](/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_1.png)\n\n하지만 이것은 저의 로컬 아키텍처에 맞게 빌드되었는데, 저희는 Atmel AVR ATmega128을 위해 빌드하고 싶어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행운이다! 많은 사람들이 AVR을 개발하기 위해 Rust를 사용하고 있어서, 이 동영상을 포함하여 도움이 되는 다양한 자료들이 있습니다. 이 동영상은 새 프로젝트를 설정하기 위한 cargo generate 템플릿을 소개하고 있습니다.\n\n\ncargo generate --git https://github.com/Rahix/avr-hal-template.git\n\n\n이 명령은 우리 프로젝트를 위해 템플릿을 구성하는 상호작용적인 흐름을 시작합니다. 이 경우에는 프로젝트 이름과 대상 보드에 대해 두 가지 질문만 있습니다. 실제 보드를 사용하지는 않고 대신 시뮬레이터에서 VM을 실행할 것이기 때문에, 제가 선택한 것은 아두이노 메가 1280입니다. \n\n![NielslearnsRust2GettingstartedwithAVRRust_2 이미지](/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 ATmega128을 위해 구성된 프로젝트가 있습니다.\n\nCargo에 빌드하라고 요청하면, 흥미로운 일이 발생합니다:\n\n![이미지](/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_3.png)\n\nRust의 새 버전을 다운로드 중입니다! Dockerfile이 1.78을 지정했는데도 불구하고 1.79의 nightly 빌드를 받고 있습니다. 왜 이런 일이 발생했을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 개의 Rust 도구 체인을 나란히 설치할 수 있다는 것이 밝혀졌어요. rustup 도구체인 목록을 보면 설치된 도구 체인을 확인할 수 있어요:\n\n![이미지](/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_4.png)\n\n개발 컨테이너의 기본 버전은 1.78이지만, 우리가 만든 프로젝트 내부에서 동일한 명령을 실행하면 2024-03-22의 nightly 빌드로 재정의돼요.\n\n이 일이 발생하는 이유는 템플릿에 rust-toolchain.toml이 포함돼 있어서 특정 버전을 요청했기 때문이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n[toolchain]\nchannel = \"nightly-2024-03-22\"\ncomponents = [\"rust-src\"]\nprofile = \"minimal\"\n```\n\n프로젝트를 nightly 빌드에서 시작하는 것이 조금 이상해 보이지만, 템플릿에서 생성된 코드는 1.78에서 컴파일되지 않습니다. 그래서 일단 여기에 남겨둔 채로 나중에 안정 버전으로 옮길 수 있는지 확인해 보겠습니다.\n\n# 코드 실행하기\n\nCargo도 프로그램을 실행할 수 있지만, 현재 버전에서 시도하면 다음과 같은 오류가 발생합니다:```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmd\n![이미지](/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_5.png)\n\n템플릿은 생성된 실행 파일을 대상 장치로 보내는 도구인 ravedude를 사용하도록 구성되어 있지만 우리는 물리적 장치가 없으므로 수정된 Avrora 시뮬레이터의 버전을 대신 사용할 것입니다.\n\ncargo run을 실행하면 생성된 프로젝트의 capevm/.cargo/config.toml 파일에 있는 설정된 내용이 실행됩니다. 현재 이 파일은 다음과 같은 내용을 포함하고 있습니다:\n\n```js\n[target.'cfg(target_arch = \"avr\")']\nrunner = \"ravedude mega1280 -cb 57600\"\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생성된 Rust 코드를 Avrora에서 실행하려면 다음과 같이 변경했어요:\n\n```js\n[target.'cfg(target_arch = \"avr\")']\nrunner = \"java -jar ../avrora/avrora-beta-1.7.117.jar -monitors=memory,stack -single\"\n```\n\n지금은 Avrora 시뮬레이터를 컴파일한 파일(단일 .jar 파일)을 직접 저장소에 넣었어요. 이 Avrora 버전은 실행 중인 프로그램을 모니터링할 수 있도록 다양한 프로브로 확장되었지만, 이러한 세부사항은 훨씬 나중에 의미가 있을 거예요. 해당 수정 사항이 포함된 소스코드는 원본 CapeVM 저장소에 있어요.\n\n# AVR “Hello, world”\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 AVR을 위한 \"Hello, world\" 동등물을 생성하는 템플릿입니다:\n\n```rust\n#![no_std]\n#![no_main]\n\nuse panic_halt as _;\n\n#[arduino_hal::entry]\nfn main() -\u003e ! {\n    let dp = arduino_hal::Peripherals::take().unwrap();\n    let pins = arduino_hal::pins!(dp);\n    let mut led = pins.d13.into_output();\n\n    loop {\n        led.toggle();\n        arduino_hal::delay_ms(1000);\n    }\n}\n```\n\nmain 함수의 서명인 `fn main() -\u003e !`는 흥미롭습니다: ! 반환 유형은 함수가 종료되지 않음을 나타냅니다.\n\n이것은 여전히 내게는 이해하기 어렵지만 코드에서 강요된 #[arduino_hal::entry] 속성에 의해 시행됩니다. Rust의 좋은 점 중 하나는 \"F12\"(정의로 이동)로 거의 모든 것을 조회하여 구현을 볼 수 있다는 것이며, arduino_hal::entry에는 syn::Type::Never(_)가 반환 유형인 !을 포함하는 이 코드 조각이 포함되어 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 함수 시그니처를 확인합니다\nlet valid_signature = f.sig.constness.is_none()\n    \u0026\u0026 f.vis == syn::Visibility::Inherited\n    \u0026\u0026 f.sig.abi.is_none()\n    \u0026\u0026 f.sig.inputs.is_empty()\n    \u0026\u0026 f.sig.generics.params.is_empty()\n    \u0026\u0026 f.sig.generics.where_clause.is_none()\n    \u0026\u0026 f.sig.variadic.is_none()\n    \u0026\u0026 match f.sig.output {\n        syn::ReturnType::Default =\u003e false,\n        syn::ReturnType::Type(_, ref ty) =\u003e matches!(**ty, syn::Type::Never(_)),\n    };\n```\n\n대부분의 임베디드 CPU 응용 프로그램에는 매우 유용합니다. OS가 없기 때문에 프로그램이 종료되는 방법이 정말 없습니다. 디바이스에서 계속 실행되어야 합니다. 정말 할 일이 남지 않았다면, 디바이스를 절전 상태로 전환하고 깨우는 트리거를 기다리는 것이 가장 좋습니다.\n\n이 루프는 여기서 끝없이 단일 핀을 토글하지만, 실제 보드가 없기 때문에 아직 테스트할 방법이 없습니다. 코드를 시뮬레이터에서 실행하고, Ctrl-C를 눌러 중지한 후에 Avrora가 config.toml에서 활성화한 -monitors에 따라 프로그램이 무엇을 수행했는지에 대한 정보를 출력할 것입니다:\n\n\u003cimg src=\"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_6.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요, 작동이 되네요! 하지만 아직 결과물이 그렇게 유용하진 않네요.\n\n마지막 목표는 네이티브 코드로 컴파일되어 실행되고 성능을 측정하기 위해 여러 벤치마크를 실행하고 확인하는 JVM을 구축하는 것입니다. 이를 위해 더 자세한 출력이 필요하므로, 다음 게시물에서는 디버그 출력 및 다른 계산 도구를 추가하는 방법에 대해 다뤄볼 예정입니다.\n\n이 단계에서의 코드 상태는 여기 Github에서 찾을 수 있습니다.\n\n원문은 2024년 5월 6일에 https://nielsreijers.github.io에서 최초로 게시되었습니다.","ogImage":{"url":"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png"},"coverImage":"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png","tag":["Tech"],"readingTime":7},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    h1: \"h1\",\n    pre: \"pre\",\n    code: \"code\",\n    span: \"span\",\n    img: \"img\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"저는 러스트를 배우기 위해 내 임베디드 Java 가상 머신을 러스트로 이식하는 여정을 문서화하는 시리즈의 두 번째 부분입니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"개발 컨테이너에 러스트 설치\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 첫 번째 단계는 Rust를 설치하는 것인데, rustup을 사용하면 간단합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-bash\",\n        children: [\"curl --proto \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'=https'\"\n        }), \" --tlsv1.2 -sSf https://sh.rustup.rs | sh\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 안정적이고 반복 가능한 방식으로 하자면 개발 컨테이너를 사용하는 게 좋겠죠. 개발 컨테이너는 VS Code가 코드를 빌드, 실행 및 디버깅하기 위해 생성하는 컨테이너입니다. 모든 개발 작업은 컨테이너에서 이루어지며, 데스크톱에서 실행 중인 VS Code는 단순히 컨테이너에서 실행 중인 다른 VS Code 인스턴스와 통신하는 UI 역할을 합니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png\",\n        alt: \"image\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(출처)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이점은 더 나은 격리와 명확히 정의된 개발 환경입니다. 이 프로젝트에만 사용되는 로컬 도구를 로컬에 설치할 필요가 없으며, 이 리포지토리를 내려받는 모든 사람이 동일한 컨테이너를 사용할 수 있습니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"개발 컨테이너를 만드는 것은 매우 쉬워요. 필요한 것은 .devcontainer/devcontainer.json 파일(.devcontainer.json도 가능) 하나 뿐인데, 이 파일 안에는 VS Code가 컨테이너를 빌드하는 데 필요한 정보들이 들어가 있어요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"미리 만들어진 이미지를 사용하거나, 자체 Dockerfile을 지정하여 컨테이너를 빌드할 수 있어요. 저는 후자를 사용하고 있고, 제 devcontainer.json은 이렇게 생겼어요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"{\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"build\\\"\"\n        }), \": { \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"dockerfile\\\"\"\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Dockerfile\\\"\"\n        }), \" },\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"customizations\\\"\"\n        }), \": {\\n        \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"vscode\\\"\"\n        }), \": {\\n            \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"extensions\\\"\"\n        }), \": [\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"rust-lang.rust-analyzer\\\"\"\n        }), \"]\\n        }\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"dev 컨테이너에서 실행 중인 VS Code 인스턴스에는 기본적으로 어떤 확장도 설치되어 있지 않아요. 로컬로 설치된 확장 목록에서 간단히 클릭하여 추가하거나, json 파일에서 명시하여 자동으로 추가할 수 있어요. 형식은 \", _jsx(_components.code, {\n        children: \"provider\"\n      }), \".\", _jsx(_components.code, {\n        children: \"extension\"\n      }), \"이고, 실제 이름은 UI에서 매우 명확하지 않지만 ~/.vscode/extensions 디렉토리에서 쉽게 찾을 수 있어요.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"도커 파일도 꽤 간단합니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"FROM\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"rust\"\n        }), \":\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1.78\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RUN\"\n        }), \" apt update\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RUN\"\n        }), \" apt -y install gcc-avr avr-libc \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"default\"\n        }), \"-jre\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-variable constant_\",\n          children: \"RUN\"\n        }), \" cargo install cargo-generate\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rust 프로젝트는 사용할 수 있는 도커 이미지를 제공하며, 보통의 Rust 개발에는 충분할 수 있습니다. 그러나 이 프로젝트의 목표는 임베디드 CPU용 Java VM을 빌드하는 것이며, 이 경우 Atmel AVR ATmega 128에 대해 작업하기 위해 몇 가지 추가 패키지를 설치해야 합니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"cargo는 Rust의 빌드 매니저이며, .NET에서는 dotnet, Scala에서는 sbt, Golang에서는 go와 같은 역할을 합니다. 마지막 줄은 새로운 프로젝트를 템플릿을 기반으로 생성할 수 있도록 하는 크레이트를 설치합니다. 이를 다음 섹션에서 사용할 것입니다.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"AVR용 러스트\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여기서는 작동하는 러스트 설치 방법을 소개해 드릴게요. Cargo를 사용하여 새 프로젝트를 만들고 실행할 수 있습니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_1.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"하지만 이것은 저의 로컬 아키텍처에 맞게 빌드되었는데, 저희는 Atmel AVR ATmega128을 위해 빌드하고 싶어요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"행운이다! 많은 사람들이 AVR을 개발하기 위해 Rust를 사용하고 있어서, 이 동영상을 포함하여 도움이 되는 다양한 자료들이 있습니다. 이 동영상은 새 프로젝트를 설정하기 위한 cargo generate 템플릿을 소개하고 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"cargo generate --git https://github.com/Rahix/avr-hal-template.git\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 명령은 우리 프로젝트를 위해 템플릿을 구성하는 상호작용적인 흐름을 시작합니다. 이 경우에는 프로젝트 이름과 대상 보드에 대해 두 가지 질문만 있습니다. 실제 보드를 사용하지는 않고 대신 시뮬레이터에서 VM을 실행할 것이기 때문에, 제가 선택한 것은 아두이노 메가 1280입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_2.png\",\n        alt: \"NielslearnsRust2GettingstartedwithAVRRust_2 이미지\"\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금은 ATmega128을 위해 구성된 프로젝트가 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cargo에 빌드하라고 요청하면, 흥미로운 일이 발생합니다:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_3.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rust의 새 버전을 다운로드 중입니다! Dockerfile이 1.78을 지정했는데도 불구하고 1.79의 nightly 빌드를 받고 있습니다. 왜 이런 일이 발생했을까요?\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"여러 개의 Rust 도구 체인을 나란히 설치할 수 있다는 것이 밝혀졌어요. rustup 도구체인 목록을 보면 설치된 도구 체인을 확인할 수 있어요:\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_4.png\",\n        alt: \"이미지\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"개발 컨테이너의 기본 버전은 1.78이지만, 우리가 만든 프로젝트 내부에서 동일한 명령을 실행하면 2024-03-22의 nightly 빌드로 재정의돼요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 일이 발생하는 이유는 템플릿에 rust-toolchain.toml이 포함돼 있어서 특정 버전을 요청했기 때문이에요.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-json\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"[\"\n        }), \"toolchain\", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"]\"\n        }), \"\\nchannel = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"nightly-2024-03-22\\\"\"\n        }), \"\\ncomponents = \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"[\"\n        }), _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"rust-src\\\"\"\n        }), _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"]\"\n        }), \"\\nprofile = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"minimal\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"프로젝트를 nightly 빌드에서 시작하는 것이 조금 이상해 보이지만, 템플릿에서 생성된 코드는 1.78에서 컴파일되지 않습니다. 그래서 일단 여기에 남겨둔 채로 나중에 안정 버전으로 옮길 수 있는지 확인해 보겠습니다.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"코드 실행하기\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cargo도 프로그램을 실행할 수 있지만, 현재 버전에서 시도하면 다음과 같은 오류가 발생합니다:```\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"md\\n\", _jsx(_components.img, {\n        src: \"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_5.png\",\n        alt: \"이미지\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"템플릿은 생성된 실행 파일을 대상 장치로 보내는 도구인 ravedude를 사용하도록 구성되어 있지만 우리는 물리적 장치가 없으므로 수정된 Avrora 시뮬레이터의 버전을 대신 사용할 것입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"cargo run을 실행하면 생성된 프로젝트의 capevm/.cargo/config.toml 파일에 있는 설정된 내용이 실행됩니다. 현재 이 파일은 다음과 같은 내용을 포함하고 있습니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"[target.\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'cfg(target_arch = \\\"avr\\\")'\"\n        }), \"]\\nrunner = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ravedude mega1280 -cb 57600\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"생성된 Rust 코드를 Avrora에서 실행하려면 다음과 같이 변경했어요:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [\"[target.\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"'cfg(target_arch = \\\"avr\\\")'\"\n        }), \"]\\nrunner = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"java -jar ../avrora/avrora-beta-1.7.117.jar -monitors=memory,stack -single\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"지금은 Avrora 시뮬레이터를 컴파일한 파일(단일 .jar 파일)을 직접 저장소에 넣었어요. 이 Avrora 버전은 실행 중인 프로그램을 모니터링할 수 있도록 다양한 프로브로 확장되었지만, 이러한 세부사항은 훨씬 나중에 의미가 있을 거예요. 해당 수정 사항이 포함된 소스코드는 원본 CapeVM 저장소에 있어요.\"\n    }), \"\\n\", _jsx(_components.h1, {\n      children: \"AVR “Hello, world”\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"아래는 AVR을 위한 \\\"Hello, world\\\" 동등물을 생성하는 템플릿입니다:\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-rust\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"#![no_std]\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"#![no_main]\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"use\"\n        }), \" panic_halt \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" _;\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"#[arduino_hal::entry]\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"fn\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"main\"\n        }), \"() \", _jsx(_components.span, {\n          className: \"hljs-punctuation\",\n          children: \"-\u003e\"\n        }), \" ! {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"dp\"\n        }), \" = arduino_hal::Peripherals::\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"take\"\n        }), \"().\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"unwrap\"\n        }), \"();\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"pins\"\n        }), \" = arduino_hal::pins!(dp);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"mut \"\n        }), _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"led\"\n        }), \" = pins.d13.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"into_output\"\n        }), \"();\\n\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"loop\"\n        }), \" {\\n        led.\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"toggle\"\n        }), \"();\\n        arduino_hal::\", _jsx(_components.span, {\n          className: \"hljs-title function_ invoke__\",\n          children: \"delay_ms\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \");\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"main 함수의 서명인 \", _jsx(_components.code, {\n        children: \"fn main() -\u003e !\"\n      }), \"는 흥미롭습니다: ! 반환 유형은 함수가 종료되지 않음을 나타냅니다.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이것은 여전히 내게는 이해하기 어렵지만 코드에서 강요된 #[arduino_hal::entry] 속성에 의해 시행됩니다. Rust의 좋은 점 중 하나는 \\\"F12\\\"(정의로 이동)로 거의 모든 것을 조회하여 구현을 볼 수 있다는 것이며, arduino_hal::entry에는 syn::Type::Never(_)가 반환 유형인 !을 포함하는 이 코드 조각이 포함되어 있습니다:\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-js\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// 함수 시그니처를 확인합니다\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"let\"\n        }), \" valid_signature = f.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"sig\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"constness\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"is_none\"\n        }), \"()\\n    \u0026\u0026 f.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"vis\"\n        }), \" == \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"syn\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Visibility\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Inherited\"\n        }), \"\\n    \u0026\u0026 f.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"sig\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"abi\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"is_none\"\n        }), \"()\\n    \u0026\u0026 f.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"sig\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"inputs\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"is_empty\"\n        }), \"()\\n    \u0026\u0026 f.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"sig\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"generics\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"params\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"is_empty\"\n        }), \"()\\n    \u0026\u0026 f.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"sig\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"generics\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"where_clause\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"is_none\"\n        }), \"()\\n    \u0026\u0026 f.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"sig\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"variadic\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"is_none\"\n        }), \"()\\n    \u0026\u0026 match f.\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"sig\"\n        }), \".\", _jsx(_components.span, {\n          className: \"hljs-property\",\n          children: \"output\"\n        }), \" {\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"syn\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ReturnType\"\n        }), \"::\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"Default\"\n          }), \" =\u003e\"]\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"false\"\n        }), \",\\n        \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"syn\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"ReturnType\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Type\"\n        }), \"(_, ref ty) =\u003e matches!(**ty, \", _jsx(_components.span, {\n          className: \"hljs-attr\",\n          children: \"syn\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Type\"\n        }), \"::\", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Never\"\n        }), \"(_)),\\n    };\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"대부분의 임베디드 CPU 응용 프로그램에는 매우 유용합니다. OS가 없기 때문에 프로그램이 종료되는 방법이 정말 없습니다. 디바이스에서 계속 실행되어야 합니다. 정말 할 일이 남지 않았다면, 디바이스를 절전 상태로 전환하고 깨우는 트리거를 기다리는 것이 가장 좋습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 루프는 여기서 끝없이 단일 핀을 토글하지만, 실제 보드가 없기 때문에 아직 테스트할 방법이 없습니다. 코드를 시뮬레이터에서 실행하고, Ctrl-C를 눌러 중지한 후에 Avrora가 config.toml에서 활성화한 -monitors에 따라 프로그램이 무엇을 수행했는지에 대한 정보를 출력할 것입니다:\"\n    }), \"\\n\", _jsx(\"img\", {\n      src: \"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_6.png\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"content-ad\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"좋아요, 작동이 되네요! 하지만 아직 결과물이 그렇게 유용하진 않네요.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"마지막 목표는 네이티브 코드로 컴파일되어 실행되고 성능을 측정하기 위해 여러 벤치마크를 실행하고 확인하는 JVM을 구축하는 것입니다. 이를 위해 더 자세한 출력이 필요하므로, 다음 게시물에서는 디버그 출력 및 다른 계산 도구를 추가하는 방법에 대해 다뤄볼 예정입니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"이 단계에서의 코드 상태는 여기 Github에서 찾을 수 있습니다.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"원문은 2024년 5월 6일에 https://nielsreijers.github.io에서 최초로 게시되었습니다.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-NielslearnsRust2GettingstartedwithAVRRust"},"buildId":"uXJWf9GNc_Ux38RlnQJQc","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>