<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Rust 2 공부 내용 정리 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Rust 2 공부 내용 정리 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="Rust 2 공부 내용 정리 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust" data-gatsby-head="true"/><meta name="twitter:title" content="Rust 2 공부 내용 정리 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-17 04:11" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_buildManifest.js" defer=""></script><script src="/_next/static/aCCUs-qPrLLLWRnkN0AOd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Rust 2 공부 내용 정리</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Rust 2 공부 내용 정리" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 17, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>저는 러스트를 배우기 위해 내 임베디드 Java 가상 머신을 러스트로 이식하는 여정을 문서화하는 시리즈의 두 번째 부분입니다.</p>
<h1>개발 컨테이너에 러스트 설치</h1>
<p>이 첫 번째 단계는 Rust를 설치하는 것인데, rustup을 사용하면 간단합니다:</p>
<pre><code class="hljs language-bash">curl --proto <span class="hljs-string">'=https'</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<div class="content-ad"></div>
<p>하지만 안정적이고 반복 가능한 방식으로 하자면 개발 컨테이너를 사용하는 게 좋겠죠. 개발 컨테이너는 VS Code가 코드를 빌드, 실행 및 디버깅하기 위해 생성하는 컨테이너입니다. 모든 개발 작업은 컨테이너에서 이루어지며, 데스크톱에서 실행 중인 VS Code는 단순히 컨테이너에서 실행 중인 다른 VS Code 인스턴스와 통신하는 UI 역할을 합니다:</p>
<p><img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png" alt="image"></p>
<p>(출처)</p>
<p>이점은 더 나은 격리와 명확히 정의된 개발 환경입니다. 이 프로젝트에만 사용되는 로컬 도구를 로컬에 설치할 필요가 없으며, 이 리포지토리를 내려받는 모든 사람이 동일한 컨테이너를 사용할 수 있습니다.</p>
<div class="content-ad"></div>
<p>개발 컨테이너를 만드는 것은 매우 쉬워요. 필요한 것은 .devcontainer/devcontainer.json 파일(.devcontainer.json도 가능) 하나 뿐인데, 이 파일 안에는 VS Code가 컨테이너를 빌드하는 데 필요한 정보들이 들어가 있어요.</p>
<p>미리 만들어진 이미지를 사용하거나, 자체 Dockerfile을 지정하여 컨테이너를 빌드할 수 있어요. 저는 후자를 사용하고 있고, 제 devcontainer.json은 이렇게 생겼어요:</p>
<pre><code class="hljs language-js">{
    <span class="hljs-string">"build"</span>: { <span class="hljs-string">"dockerfile"</span>: <span class="hljs-string">"Dockerfile"</span> },

    <span class="hljs-string">"customizations"</span>: {
        <span class="hljs-string">"vscode"</span>: {
            <span class="hljs-string">"extensions"</span>: [<span class="hljs-string">"rust-lang.rust-analyzer"</span>]
        }
    }
}
</code></pre>
<p>dev 컨테이너에서 실행 중인 VS Code 인스턴스에는 기본적으로 어떤 확장도 설치되어 있지 않아요. 로컬로 설치된 확장 목록에서 간단히 클릭하여 추가하거나, json 파일에서 명시하여 자동으로 추가할 수 있어요. 형식은 <code>provider</code>.<code>extension</code>이고, 실제 이름은 UI에서 매우 명확하지 않지만 ~/.vscode/extensions 디렉토리에서 쉽게 찾을 수 있어요.</p>
<div class="content-ad"></div>
<p>도커 파일도 꽤 간단합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">rust</span>:<span class="hljs-number">1.78</span>

<span class="hljs-variable constant_">RUN</span> apt update
<span class="hljs-variable constant_">RUN</span> apt -y install gcc-avr avr-libc <span class="hljs-keyword">default</span>-jre

<span class="hljs-variable constant_">RUN</span> cargo install cargo-generate
</code></pre>
<p>Rust 프로젝트는 사용할 수 있는 도커 이미지를 제공하며, 보통의 Rust 개발에는 충분할 수 있습니다. 그러나 이 프로젝트의 목표는 임베디드 CPU용 Java VM을 빌드하는 것이며, 이 경우 Atmel AVR ATmega 128에 대해 작업하기 위해 몇 가지 추가 패키지를 설치해야 합니다.</p>
<p>cargo는 Rust의 빌드 매니저이며, .NET에서는 dotnet, Scala에서는 sbt, Golang에서는 go와 같은 역할을 합니다. 마지막 줄은 새로운 프로젝트를 템플릿을 기반으로 생성할 수 있도록 하는 크레이트를 설치합니다. 이를 다음 섹션에서 사용할 것입니다.</p>
<div class="content-ad"></div>
<h1>AVR용 러스트</h1>
<p>여기서는 작동하는 러스트 설치 방법을 소개해 드릴게요. Cargo를 사용하여 새 프로젝트를 만들고 실행할 수 있습니다:</p>
<p><img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_1.png" alt="이미지"></p>
<p>하지만 이것은 저의 로컬 아키텍처에 맞게 빌드되었는데, 저희는 Atmel AVR ATmega128을 위해 빌드하고 싶어요.</p>
<div class="content-ad"></div>
<p>행운이다! 많은 사람들이 AVR을 개발하기 위해 Rust를 사용하고 있어서, 이 동영상을 포함하여 도움이 되는 다양한 자료들이 있습니다. 이 동영상은 새 프로젝트를 설정하기 위한 cargo generate 템플릿을 소개하고 있습니다.</p>
<p>cargo generate --git <a href="https://github.com/Rahix/avr-hal-template.git" rel="nofollow" target="_blank">https://github.com/Rahix/avr-hal-template.git</a></p>
<p>이 명령은 우리 프로젝트를 위해 템플릿을 구성하는 상호작용적인 흐름을 시작합니다. 이 경우에는 프로젝트 이름과 대상 보드에 대해 두 가지 질문만 있습니다. 실제 보드를 사용하지는 않고 대신 시뮬레이터에서 VM을 실행할 것이기 때문에, 제가 선택한 것은 아두이노 메가 1280입니다.</p>
<p><img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_2.png" alt="NielslearnsRust2GettingstartedwithAVRRust_2 이미지"></p>
<div class="content-ad"></div>
<p>지금은 ATmega128을 위해 구성된 프로젝트가 있습니다.</p>
<p>Cargo에 빌드하라고 요청하면, 흥미로운 일이 발생합니다:</p>
<p><img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_3.png" alt="이미지"></p>
<p>Rust의 새 버전을 다운로드 중입니다! Dockerfile이 1.78을 지정했는데도 불구하고 1.79의 nightly 빌드를 받고 있습니다. 왜 이런 일이 발생했을까요?</p>
<div class="content-ad"></div>
<p>여러 개의 Rust 도구 체인을 나란히 설치할 수 있다는 것이 밝혀졌어요. rustup 도구체인 목록을 보면 설치된 도구 체인을 확인할 수 있어요:</p>
<p><img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_4.png" alt="이미지"></p>
<p>개발 컨테이너의 기본 버전은 1.78이지만, 우리가 만든 프로젝트 내부에서 동일한 명령을 실행하면 2024-03-22의 nightly 빌드로 재정의돼요.</p>
<p>이 일이 발생하는 이유는 템플릿에 rust-toolchain.toml이 포함돼 있어서 특정 버전을 요청했기 때문이에요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-json"><span class="hljs-punctuation">[</span>toolchain<span class="hljs-punctuation">]</span>
channel = <span class="hljs-string">"nightly-2024-03-22"</span>
components = <span class="hljs-punctuation">[</span><span class="hljs-string">"rust-src"</span><span class="hljs-punctuation">]</span>
profile = <span class="hljs-string">"minimal"</span>
</code></pre>
<p>프로젝트를 nightly 빌드에서 시작하는 것이 조금 이상해 보이지만, 템플릿에서 생성된 코드는 1.78에서 컴파일되지 않습니다. 그래서 일단 여기에 남겨둔 채로 나중에 안정 버전으로 옮길 수 있는지 확인해 보겠습니다.</p>
<h1>코드 실행하기</h1>
<p>Cargo도 프로그램을 실행할 수 있지만, 현재 버전에서 시도하면 다음과 같은 오류가 발생합니다:</p>
<div class="content-ad"></div>
<p>md
<img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_5.png" alt="이미지"></p>
<p>템플릿은 생성된 실행 파일을 대상 장치로 보내는 도구인 ravedude를 사용하도록 구성되어 있지만 우리는 물리적 장치가 없으므로 수정된 Avrora 시뮬레이터의 버전을 대신 사용할 것입니다.</p>
<p>cargo run을 실행하면 생성된 프로젝트의 capevm/.cargo/config.toml 파일에 있는 설정된 내용이 실행됩니다. 현재 이 파일은 다음과 같은 내용을 포함하고 있습니다:</p>
<pre><code class="hljs language-js">[target.<span class="hljs-string">'cfg(target_arch = "avr")'</span>]
runner = <span class="hljs-string">"ravedude mega1280 -cb 57600"</span>
</code></pre>
<div class="content-ad"></div>
<p>생성된 Rust 코드를 Avrora에서 실행하려면 다음과 같이 변경했어요:</p>
<pre><code class="hljs language-js">[target.<span class="hljs-string">'cfg(target_arch = "avr")'</span>]
runner = <span class="hljs-string">"java -jar ../avrora/avrora-beta-1.7.117.jar -monitors=memory,stack -single"</span>
</code></pre>
<p>지금은 Avrora 시뮬레이터를 컴파일한 파일(단일 .jar 파일)을 직접 저장소에 넣었어요. 이 Avrora 버전은 실행 중인 프로그램을 모니터링할 수 있도록 다양한 프로브로 확장되었지만, 이러한 세부사항은 훨씬 나중에 의미가 있을 거예요. 해당 수정 사항이 포함된 소스코드는 원본 CapeVM 저장소에 있어요.</p>
<h1>AVR “Hello, world”</h1>
<div class="content-ad"></div>
<p>아래는 AVR을 위한 "Hello, world" 동등물을 생성하는 템플릿입니다:</p>
<pre><code class="hljs language-rust"><span class="hljs-meta">#![no_std]</span>
<span class="hljs-meta">#![no_main]</span>

<span class="hljs-keyword">use</span> panic_halt <span class="hljs-keyword">as</span> _;

<span class="hljs-meta">#[arduino_hal::entry]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-></span> ! {
    <span class="hljs-keyword">let</span> <span class="hljs-variable">dp</span> = arduino_hal::Peripherals::<span class="hljs-title function_ invoke__">take</span>().<span class="hljs-title function_ invoke__">unwrap</span>();
    <span class="hljs-keyword">let</span> <span class="hljs-variable">pins</span> = arduino_hal::pins!(dp);
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">led</span> = pins.d13.<span class="hljs-title function_ invoke__">into_output</span>();

    <span class="hljs-keyword">loop</span> {
        led.<span class="hljs-title function_ invoke__">toggle</span>();
        arduino_hal::<span class="hljs-title function_ invoke__">delay_ms</span>(<span class="hljs-number">1000</span>);
    }
}
</code></pre>
<p>main 함수의 서명인 <code>fn main() -> !</code>는 흥미롭습니다: ! 반환 유형은 함수가 종료되지 않음을 나타냅니다.</p>
<p>이것은 여전히 내게는 이해하기 어렵지만 코드에서 강요된 #[arduino_hal::entry] 속성에 의해 시행됩니다. Rust의 좋은 점 중 하나는 "F12"(정의로 이동)로 거의 모든 것을 조회하여 구현을 볼 수 있다는 것이며, arduino_hal::entry에는 syn::Type::Never(_)가 반환 유형인 !을 포함하는 이 코드 조각이 포함되어 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">// 함수 시그니처를 확인합니다</span>
<span class="hljs-keyword">let</span> valid_signature = f.<span class="hljs-property">sig</span>.<span class="hljs-property">constness</span>.<span class="hljs-title function_">is_none</span>()
    &#x26;&#x26; f.<span class="hljs-property">vis</span> == <span class="hljs-attr">syn</span>::<span class="hljs-title class_">Visibility</span>::<span class="hljs-title class_">Inherited</span>
    &#x26;&#x26; f.<span class="hljs-property">sig</span>.<span class="hljs-property">abi</span>.<span class="hljs-title function_">is_none</span>()
    &#x26;&#x26; f.<span class="hljs-property">sig</span>.<span class="hljs-property">inputs</span>.<span class="hljs-title function_">is_empty</span>()
    &#x26;&#x26; f.<span class="hljs-property">sig</span>.<span class="hljs-property">generics</span>.<span class="hljs-property">params</span>.<span class="hljs-title function_">is_empty</span>()
    &#x26;&#x26; f.<span class="hljs-property">sig</span>.<span class="hljs-property">generics</span>.<span class="hljs-property">where_clause</span>.<span class="hljs-title function_">is_none</span>()
    &#x26;&#x26; f.<span class="hljs-property">sig</span>.<span class="hljs-property">variadic</span>.<span class="hljs-title function_">is_none</span>()
    &#x26;&#x26; match f.<span class="hljs-property">sig</span>.<span class="hljs-property">output</span> {
        <span class="hljs-attr">syn</span>::<span class="hljs-title class_">ReturnType</span>::<span class="hljs-function"><span class="hljs-params">Default</span> =></span> <span class="hljs-literal">false</span>,
        <span class="hljs-attr">syn</span>::<span class="hljs-title class_">ReturnType</span>::<span class="hljs-title class_">Type</span>(_, ref ty) => matches!(**ty, <span class="hljs-attr">syn</span>::<span class="hljs-title class_">Type</span>::<span class="hljs-title class_">Never</span>(_)),
    };
</code></pre>
<p>대부분의 임베디드 CPU 응용 프로그램에는 매우 유용합니다. OS가 없기 때문에 프로그램이 종료되는 방법이 정말 없습니다. 디바이스에서 계속 실행되어야 합니다. 정말 할 일이 남지 않았다면, 디바이스를 절전 상태로 전환하고 깨우는 트리거를 기다리는 것이 가장 좋습니다.</p>
<p>이 루프는 여기서 끝없이 단일 핀을 토글하지만, 실제 보드가 없기 때문에 아직 테스트할 방법이 없습니다. 코드를 시뮬레이터에서 실행하고, Ctrl-C를 눌러 중지한 후에 Avrora가 config.toml에서 활성화한 -monitors에 따라 프로그램이 무엇을 수행했는지에 대한 정보를 출력할 것입니다:</p>
<img src="/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_6.png">
<div class="content-ad"></div>
<p>좋아요, 작동이 되네요! 하지만 아직 결과물이 그렇게 유용하진 않네요.</p>
<p>마지막 목표는 네이티브 코드로 컴파일되어 실행되고 성능을 측정하기 위해 여러 벤치마크를 실행하고 확인하는 JVM을 구축하는 것입니다. 이를 위해 더 자세한 출력이 필요하므로, 다음 게시물에서는 디버그 출력 및 다른 계산 도구를 추가하는 방법에 대해 다뤄볼 예정입니다.</p>
<p>이 단계에서의 코드 상태는 여기 Github에서 찾을 수 있습니다.</p>
<p>원문은 2024년 5월 6일에 <a href="https://nielsreijers.github.io%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">https://nielsreijers.github.io에서</a> 최초로 게시되었습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Rust 2 공부 내용 정리","description":"","date":"2024-05-17 04:11","slug":"2024-05-17-NielslearnsRust2GettingstartedwithAVRRust","content":"\n\n저는 러스트를 배우기 위해 내 임베디드 Java 가상 머신을 러스트로 이식하는 여정을 문서화하는 시리즈의 두 번째 부분입니다.\n\n# 개발 컨테이너에 러스트 설치\n\n이 첫 번째 단계는 Rust를 설치하는 것인데, rustup을 사용하면 간단합니다:\n\n```bash\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 안정적이고 반복 가능한 방식으로 하자면 개발 컨테이너를 사용하는 게 좋겠죠. 개발 컨테이너는 VS Code가 코드를 빌드, 실행 및 디버깅하기 위해 생성하는 컨테이너입니다. 모든 개발 작업은 컨테이너에서 이루어지며, 데스크톱에서 실행 중인 VS Code는 단순히 컨테이너에서 실행 중인 다른 VS Code 인스턴스와 통신하는 UI 역할을 합니다:\n\n![image](/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png)\n\n(출처)\n\n이점은 더 나은 격리와 명확히 정의된 개발 환경입니다. 이 프로젝트에만 사용되는 로컬 도구를 로컬에 설치할 필요가 없으며, 이 리포지토리를 내려받는 모든 사람이 동일한 컨테이너를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개발 컨테이너를 만드는 것은 매우 쉬워요. 필요한 것은 .devcontainer/devcontainer.json 파일(.devcontainer.json도 가능) 하나 뿐인데, 이 파일 안에는 VS Code가 컨테이너를 빌드하는 데 필요한 정보들이 들어가 있어요.\n\n미리 만들어진 이미지를 사용하거나, 자체 Dockerfile을 지정하여 컨테이너를 빌드할 수 있어요. 저는 후자를 사용하고 있고, 제 devcontainer.json은 이렇게 생겼어요:\n\n```js\n{\n    \"build\": { \"dockerfile\": \"Dockerfile\" },\n\n    \"customizations\": {\n        \"vscode\": {\n            \"extensions\": [\"rust-lang.rust-analyzer\"]\n        }\n    }\n}\n```\n\ndev 컨테이너에서 실행 중인 VS Code 인스턴스에는 기본적으로 어떤 확장도 설치되어 있지 않아요. 로컬로 설치된 확장 목록에서 간단히 클릭하여 추가하거나, json 파일에서 명시하여 자동으로 추가할 수 있어요. 형식은 `provider`.`extension`이고, 실제 이름은 UI에서 매우 명확하지 않지만 ~/.vscode/extensions 디렉토리에서 쉽게 찾을 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도커 파일도 꽤 간단합니다:\n\n```js\nFROM rust:1.78\n\nRUN apt update\nRUN apt -y install gcc-avr avr-libc default-jre\n\nRUN cargo install cargo-generate\n```\n\nRust 프로젝트는 사용할 수 있는 도커 이미지를 제공하며, 보통의 Rust 개발에는 충분할 수 있습니다. 그러나 이 프로젝트의 목표는 임베디드 CPU용 Java VM을 빌드하는 것이며, 이 경우 Atmel AVR ATmega 128에 대해 작업하기 위해 몇 가지 추가 패키지를 설치해야 합니다.\n\ncargo는 Rust의 빌드 매니저이며, .NET에서는 dotnet, Scala에서는 sbt, Golang에서는 go와 같은 역할을 합니다. 마지막 줄은 새로운 프로젝트를 템플릿을 기반으로 생성할 수 있도록 하는 크레이트를 설치합니다. 이를 다음 섹션에서 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# AVR용 러스트\n\n여기서는 작동하는 러스트 설치 방법을 소개해 드릴게요. Cargo를 사용하여 새 프로젝트를 만들고 실행할 수 있습니다:\n\n![이미지](/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_1.png)\n\n하지만 이것은 저의 로컬 아키텍처에 맞게 빌드되었는데, 저희는 Atmel AVR ATmega128을 위해 빌드하고 싶어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n행운이다! 많은 사람들이 AVR을 개발하기 위해 Rust를 사용하고 있어서, 이 동영상을 포함하여 도움이 되는 다양한 자료들이 있습니다. 이 동영상은 새 프로젝트를 설정하기 위한 cargo generate 템플릿을 소개하고 있습니다.\n\n\ncargo generate --git https://github.com/Rahix/avr-hal-template.git\n\n\n이 명령은 우리 프로젝트를 위해 템플릿을 구성하는 상호작용적인 흐름을 시작합니다. 이 경우에는 프로젝트 이름과 대상 보드에 대해 두 가지 질문만 있습니다. 실제 보드를 사용하지는 않고 대신 시뮬레이터에서 VM을 실행할 것이기 때문에, 제가 선택한 것은 아두이노 메가 1280입니다. \n\n![NielslearnsRust2GettingstartedwithAVRRust_2 이미지](/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 ATmega128을 위해 구성된 프로젝트가 있습니다.\n\nCargo에 빌드하라고 요청하면, 흥미로운 일이 발생합니다:\n\n![이미지](/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_3.png)\n\nRust의 새 버전을 다운로드 중입니다! Dockerfile이 1.78을 지정했는데도 불구하고 1.79의 nightly 빌드를 받고 있습니다. 왜 이런 일이 발생했을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 개의 Rust 도구 체인을 나란히 설치할 수 있다는 것이 밝혀졌어요. rustup 도구체인 목록을 보면 설치된 도구 체인을 확인할 수 있어요:\n\n![이미지](/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_4.png)\n\n개발 컨테이너의 기본 버전은 1.78이지만, 우리가 만든 프로젝트 내부에서 동일한 명령을 실행하면 2024-03-22의 nightly 빌드로 재정의돼요.\n\n이 일이 발생하는 이유는 템플릿에 rust-toolchain.toml이 포함돼 있어서 특정 버전을 요청했기 때문이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n[toolchain]\nchannel = \"nightly-2024-03-22\"\ncomponents = [\"rust-src\"]\nprofile = \"minimal\"\n```\n\n프로젝트를 nightly 빌드에서 시작하는 것이 조금 이상해 보이지만, 템플릿에서 생성된 코드는 1.78에서 컴파일되지 않습니다. 그래서 일단 여기에 남겨둔 채로 나중에 안정 버전으로 옮길 수 있는지 확인해 보겠습니다.\n\n# 코드 실행하기\n\nCargo도 프로그램을 실행할 수 있지만, 현재 버전에서 시도하면 다음과 같은 오류가 발생합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmd\n![이미지](/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_5.png)\n\n템플릿은 생성된 실행 파일을 대상 장치로 보내는 도구인 ravedude를 사용하도록 구성되어 있지만 우리는 물리적 장치가 없으므로 수정된 Avrora 시뮬레이터의 버전을 대신 사용할 것입니다.\n\ncargo run을 실행하면 생성된 프로젝트의 capevm/.cargo/config.toml 파일에 있는 설정된 내용이 실행됩니다. 현재 이 파일은 다음과 같은 내용을 포함하고 있습니다:\n\n```js\n[target.'cfg(target_arch = \"avr\")']\nrunner = \"ravedude mega1280 -cb 57600\"\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생성된 Rust 코드를 Avrora에서 실행하려면 다음과 같이 변경했어요:\n\n```js\n[target.'cfg(target_arch = \"avr\")']\nrunner = \"java -jar ../avrora/avrora-beta-1.7.117.jar -monitors=memory,stack -single\"\n```\n\n지금은 Avrora 시뮬레이터를 컴파일한 파일(단일 .jar 파일)을 직접 저장소에 넣었어요. 이 Avrora 버전은 실행 중인 프로그램을 모니터링할 수 있도록 다양한 프로브로 확장되었지만, 이러한 세부사항은 훨씬 나중에 의미가 있을 거예요. 해당 수정 사항이 포함된 소스코드는 원본 CapeVM 저장소에 있어요.\n\n# AVR “Hello, world”\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 AVR을 위한 \"Hello, world\" 동등물을 생성하는 템플릿입니다:\n\n```rust\n#![no_std]\n#![no_main]\n\nuse panic_halt as _;\n\n#[arduino_hal::entry]\nfn main() -\u003e ! {\n    let dp = arduino_hal::Peripherals::take().unwrap();\n    let pins = arduino_hal::pins!(dp);\n    let mut led = pins.d13.into_output();\n\n    loop {\n        led.toggle();\n        arduino_hal::delay_ms(1000);\n    }\n}\n```\n\nmain 함수의 서명인 `fn main() -\u003e !`는 흥미롭습니다: ! 반환 유형은 함수가 종료되지 않음을 나타냅니다.\n\n이것은 여전히 내게는 이해하기 어렵지만 코드에서 강요된 #[arduino_hal::entry] 속성에 의해 시행됩니다. Rust의 좋은 점 중 하나는 \"F12\"(정의로 이동)로 거의 모든 것을 조회하여 구현을 볼 수 있다는 것이며, arduino_hal::entry에는 syn::Type::Never(_)가 반환 유형인 !을 포함하는 이 코드 조각이 포함되어 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 함수 시그니처를 확인합니다\nlet valid_signature = f.sig.constness.is_none()\n    \u0026\u0026 f.vis == syn::Visibility::Inherited\n    \u0026\u0026 f.sig.abi.is_none()\n    \u0026\u0026 f.sig.inputs.is_empty()\n    \u0026\u0026 f.sig.generics.params.is_empty()\n    \u0026\u0026 f.sig.generics.where_clause.is_none()\n    \u0026\u0026 f.sig.variadic.is_none()\n    \u0026\u0026 match f.sig.output {\n        syn::ReturnType::Default =\u003e false,\n        syn::ReturnType::Type(_, ref ty) =\u003e matches!(**ty, syn::Type::Never(_)),\n    };\n```\n\n대부분의 임베디드 CPU 응용 프로그램에는 매우 유용합니다. OS가 없기 때문에 프로그램이 종료되는 방법이 정말 없습니다. 디바이스에서 계속 실행되어야 합니다. 정말 할 일이 남지 않았다면, 디바이스를 절전 상태로 전환하고 깨우는 트리거를 기다리는 것이 가장 좋습니다.\n\n이 루프는 여기서 끝없이 단일 핀을 토글하지만, 실제 보드가 없기 때문에 아직 테스트할 방법이 없습니다. 코드를 시뮬레이터에서 실행하고, Ctrl-C를 눌러 중지한 후에 Avrora가 config.toml에서 활성화한 -monitors에 따라 프로그램이 무엇을 수행했는지에 대한 정보를 출력할 것입니다:\n\n\u003cimg src=\"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_6.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요, 작동이 되네요! 하지만 아직 결과물이 그렇게 유용하진 않네요.\n\n마지막 목표는 네이티브 코드로 컴파일되어 실행되고 성능을 측정하기 위해 여러 벤치마크를 실행하고 확인하는 JVM을 구축하는 것입니다. 이를 위해 더 자세한 출력이 필요하므로, 다음 게시물에서는 디버그 출력 및 다른 계산 도구를 추가하는 방법에 대해 다뤄볼 예정입니다.\n\n이 단계에서의 코드 상태는 여기 Github에서 찾을 수 있습니다.\n\n원문은 2024년 5월 6일에 https://nielsreijers.github.io에서 최초로 게시되었습니다.","ogImage":{"url":"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png"},"coverImage":"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e저는 러스트를 배우기 위해 내 임베디드 Java 가상 머신을 러스트로 이식하는 여정을 문서화하는 시리즈의 두 번째 부분입니다.\u003c/p\u003e\n\u003ch1\u003e개발 컨테이너에 러스트 설치\u003c/h1\u003e\n\u003cp\u003e이 첫 번째 단계는 Rust를 설치하는 것인데, rustup을 사용하면 간단합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003ecurl --proto \u003cspan class=\"hljs-string\"\u003e'=https'\u003c/span\u003e --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e하지만 안정적이고 반복 가능한 방식으로 하자면 개발 컨테이너를 사용하는 게 좋겠죠. 개발 컨테이너는 VS Code가 코드를 빌드, 실행 및 디버깅하기 위해 생성하는 컨테이너입니다. 모든 개발 작업은 컨테이너에서 이루어지며, 데스크톱에서 실행 중인 VS Code는 단순히 컨테이너에서 실행 중인 다른 VS Code 인스턴스와 통신하는 UI 역할을 합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e(출처)\u003c/p\u003e\n\u003cp\u003e이점은 더 나은 격리와 명확히 정의된 개발 환경입니다. 이 프로젝트에만 사용되는 로컬 도구를 로컬에 설치할 필요가 없으며, 이 리포지토리를 내려받는 모든 사람이 동일한 컨테이너를 사용할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e개발 컨테이너를 만드는 것은 매우 쉬워요. 필요한 것은 .devcontainer/devcontainer.json 파일(.devcontainer.json도 가능) 하나 뿐인데, 이 파일 안에는 VS Code가 컨테이너를 빌드하는 데 필요한 정보들이 들어가 있어요.\u003c/p\u003e\n\u003cp\u003e미리 만들어진 이미지를 사용하거나, 자체 Dockerfile을 지정하여 컨테이너를 빌드할 수 있어요. 저는 후자를 사용하고 있고, 제 devcontainer.json은 이렇게 생겼어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n    \u003cspan class=\"hljs-string\"\u003e\"build\"\u003c/span\u003e: { \u003cspan class=\"hljs-string\"\u003e\"dockerfile\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Dockerfile\"\u003c/span\u003e },\n\n    \u003cspan class=\"hljs-string\"\u003e\"customizations\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"vscode\"\u003c/span\u003e: {\n            \u003cspan class=\"hljs-string\"\u003e\"extensions\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"rust-lang.rust-analyzer\"\u003c/span\u003e]\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edev 컨테이너에서 실행 중인 VS Code 인스턴스에는 기본적으로 어떤 확장도 설치되어 있지 않아요. 로컬로 설치된 확장 목록에서 간단히 클릭하여 추가하거나, json 파일에서 명시하여 자동으로 추가할 수 있어요. 형식은 \u003ccode\u003eprovider\u003c/code\u003e.\u003ccode\u003eextension\u003c/code\u003e이고, 실제 이름은 UI에서 매우 명확하지 않지만 ~/.vscode/extensions 디렉토리에서 쉽게 찾을 수 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e도커 파일도 꽤 간단합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erust\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.78\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e apt update\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e apt -y install gcc-avr avr-libc \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e-jre\n\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e cargo install cargo-generate\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRust 프로젝트는 사용할 수 있는 도커 이미지를 제공하며, 보통의 Rust 개발에는 충분할 수 있습니다. 그러나 이 프로젝트의 목표는 임베디드 CPU용 Java VM을 빌드하는 것이며, 이 경우 Atmel AVR ATmega 128에 대해 작업하기 위해 몇 가지 추가 패키지를 설치해야 합니다.\u003c/p\u003e\n\u003cp\u003ecargo는 Rust의 빌드 매니저이며, .NET에서는 dotnet, Scala에서는 sbt, Golang에서는 go와 같은 역할을 합니다. 마지막 줄은 새로운 프로젝트를 템플릿을 기반으로 생성할 수 있도록 하는 크레이트를 설치합니다. 이를 다음 섹션에서 사용할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eAVR용 러스트\u003c/h1\u003e\n\u003cp\u003e여기서는 작동하는 러스트 설치 방법을 소개해 드릴게요. Cargo를 사용하여 새 프로젝트를 만들고 실행할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e하지만 이것은 저의 로컬 아키텍처에 맞게 빌드되었는데, 저희는 Atmel AVR ATmega128을 위해 빌드하고 싶어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e행운이다! 많은 사람들이 AVR을 개발하기 위해 Rust를 사용하고 있어서, 이 동영상을 포함하여 도움이 되는 다양한 자료들이 있습니다. 이 동영상은 새 프로젝트를 설정하기 위한 cargo generate 템플릿을 소개하고 있습니다.\u003c/p\u003e\n\u003cp\u003ecargo generate --git \u003ca href=\"https://github.com/Rahix/avr-hal-template.git\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/Rahix/avr-hal-template.git\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e이 명령은 우리 프로젝트를 위해 템플릿을 구성하는 상호작용적인 흐름을 시작합니다. 이 경우에는 프로젝트 이름과 대상 보드에 대해 두 가지 질문만 있습니다. 실제 보드를 사용하지는 않고 대신 시뮬레이터에서 VM을 실행할 것이기 때문에, 제가 선택한 것은 아두이노 메가 1280입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_2.png\" alt=\"NielslearnsRust2GettingstartedwithAVRRust_2 이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e지금은 ATmega128을 위해 구성된 프로젝트가 있습니다.\u003c/p\u003e\n\u003cp\u003eCargo에 빌드하라고 요청하면, 흥미로운 일이 발생합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eRust의 새 버전을 다운로드 중입니다! Dockerfile이 1.78을 지정했는데도 불구하고 1.79의 nightly 빌드를 받고 있습니다. 왜 이런 일이 발생했을까요?\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여러 개의 Rust 도구 체인을 나란히 설치할 수 있다는 것이 밝혀졌어요. rustup 도구체인 목록을 보면 설치된 도구 체인을 확인할 수 있어요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e개발 컨테이너의 기본 버전은 1.78이지만, 우리가 만든 프로젝트 내부에서 동일한 명령을 실행하면 2024-03-22의 nightly 빌드로 재정의돼요.\u003c/p\u003e\n\u003cp\u003e이 일이 발생하는 이유는 템플릿에 rust-toolchain.toml이 포함돼 있어서 특정 버전을 요청했기 때문이에요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e\u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003etoolchain\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\nchannel = \u003cspan class=\"hljs-string\"\u003e\"nightly-2024-03-22\"\u003c/span\u003e\ncomponents = \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"rust-src\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\nprofile = \u003cspan class=\"hljs-string\"\u003e\"minimal\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e프로젝트를 nightly 빌드에서 시작하는 것이 조금 이상해 보이지만, 템플릿에서 생성된 코드는 1.78에서 컴파일되지 않습니다. 그래서 일단 여기에 남겨둔 채로 나중에 안정 버전으로 옮길 수 있는지 확인해 보겠습니다.\u003c/p\u003e\n\u003ch1\u003e코드 실행하기\u003c/h1\u003e\n\u003cp\u003eCargo도 프로그램을 실행할 수 있지만, 현재 버전에서 시도하면 다음과 같은 오류가 발생합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003emd\n\u003cimg src=\"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e템플릿은 생성된 실행 파일을 대상 장치로 보내는 도구인 ravedude를 사용하도록 구성되어 있지만 우리는 물리적 장치가 없으므로 수정된 Avrora 시뮬레이터의 버전을 대신 사용할 것입니다.\u003c/p\u003e\n\u003cp\u003ecargo run을 실행하면 생성된 프로젝트의 capevm/.cargo/config.toml 파일에 있는 설정된 내용이 실행됩니다. 현재 이 파일은 다음과 같은 내용을 포함하고 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[target.\u003cspan class=\"hljs-string\"\u003e'cfg(target_arch = \"avr\")'\u003c/span\u003e]\nrunner = \u003cspan class=\"hljs-string\"\u003e\"ravedude mega1280 -cb 57600\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e생성된 Rust 코드를 Avrora에서 실행하려면 다음과 같이 변경했어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[target.\u003cspan class=\"hljs-string\"\u003e'cfg(target_arch = \"avr\")'\u003c/span\u003e]\nrunner = \u003cspan class=\"hljs-string\"\u003e\"java -jar ../avrora/avrora-beta-1.7.117.jar -monitors=memory,stack -single\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e지금은 Avrora 시뮬레이터를 컴파일한 파일(단일 .jar 파일)을 직접 저장소에 넣었어요. 이 Avrora 버전은 실행 중인 프로그램을 모니터링할 수 있도록 다양한 프로브로 확장되었지만, 이러한 세부사항은 훨씬 나중에 의미가 있을 거예요. 해당 수정 사항이 포함된 소스코드는 원본 CapeVM 저장소에 있어요.\u003c/p\u003e\n\u003ch1\u003eAVR “Hello, world”\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 AVR을 위한 \"Hello, world\" 동등물을 생성하는 템플릿입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-meta\"\u003e#![no_std]\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e#![no_main]\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003euse\u003c/span\u003e panic_halt \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e _;\n\n\u003cspan class=\"hljs-meta\"\u003e#[arduino_hal::entry]\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e() \u003cspan class=\"hljs-punctuation\"\u003e-\u003e\u003c/span\u003e ! {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003edp\u003c/span\u003e = arduino_hal::Peripherals::\u003cspan class=\"hljs-title function_ invoke__\"\u003etake\u003c/span\u003e().\u003cspan class=\"hljs-title function_ invoke__\"\u003eunwrap\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epins\u003c/span\u003e = arduino_hal::pins!(dp);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003eled\u003c/span\u003e = pins.d13.\u003cspan class=\"hljs-title function_ invoke__\"\u003einto_output\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003eloop\u003c/span\u003e {\n        led.\u003cspan class=\"hljs-title function_ invoke__\"\u003etoggle\u003c/span\u003e();\n        arduino_hal::\u003cspan class=\"hljs-title function_ invoke__\"\u003edelay_ms\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emain 함수의 서명인 \u003ccode\u003efn main() -\u003e !\u003c/code\u003e는 흥미롭습니다: ! 반환 유형은 함수가 종료되지 않음을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e이것은 여전히 내게는 이해하기 어렵지만 코드에서 강요된 #[arduino_hal::entry] 속성에 의해 시행됩니다. Rust의 좋은 점 중 하나는 \"F12\"(정의로 이동)로 거의 모든 것을 조회하여 구현을 볼 수 있다는 것이며, arduino_hal::entry에는 syn::Type::Never(_)가 반환 유형인 !을 포함하는 이 코드 조각이 포함되어 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 함수 시그니처를 확인합니다\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e valid_signature = f.\u003cspan class=\"hljs-property\"\u003esig\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003econstness\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eis_none\u003c/span\u003e()\n    \u0026#x26;\u0026#x26; f.\u003cspan class=\"hljs-property\"\u003evis\u003c/span\u003e == \u003cspan class=\"hljs-attr\"\u003esyn\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eVisibility\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eInherited\u003c/span\u003e\n    \u0026#x26;\u0026#x26; f.\u003cspan class=\"hljs-property\"\u003esig\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eabi\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eis_none\u003c/span\u003e()\n    \u0026#x26;\u0026#x26; f.\u003cspan class=\"hljs-property\"\u003esig\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003einputs\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eis_empty\u003c/span\u003e()\n    \u0026#x26;\u0026#x26; f.\u003cspan class=\"hljs-property\"\u003esig\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egenerics\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eparams\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eis_empty\u003c/span\u003e()\n    \u0026#x26;\u0026#x26; f.\u003cspan class=\"hljs-property\"\u003esig\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egenerics\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ewhere_clause\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eis_none\u003c/span\u003e()\n    \u0026#x26;\u0026#x26; f.\u003cspan class=\"hljs-property\"\u003esig\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evariadic\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eis_none\u003c/span\u003e()\n    \u0026#x26;\u0026#x26; match f.\u003cspan class=\"hljs-property\"\u003esig\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eoutput\u003c/span\u003e {\n        \u003cspan class=\"hljs-attr\"\u003esyn\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eReturnType\u003c/span\u003e::\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eDefault\u003c/span\u003e =\u003e\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003esyn\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eReturnType\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e(_, ref ty) =\u003e matches!(**ty, \u003cspan class=\"hljs-attr\"\u003esyn\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eNever\u003c/span\u003e(_)),\n    };\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e대부분의 임베디드 CPU 응용 프로그램에는 매우 유용합니다. OS가 없기 때문에 프로그램이 종료되는 방법이 정말 없습니다. 디바이스에서 계속 실행되어야 합니다. 정말 할 일이 남지 않았다면, 디바이스를 절전 상태로 전환하고 깨우는 트리거를 기다리는 것이 가장 좋습니다.\u003c/p\u003e\n\u003cp\u003e이 루프는 여기서 끝없이 단일 핀을 토글하지만, 실제 보드가 없기 때문에 아직 테스트할 방법이 없습니다. 코드를 시뮬레이터에서 실행하고, Ctrl-C를 눌러 중지한 후에 Avrora가 config.toml에서 활성화한 -monitors에 따라 프로그램이 무엇을 수행했는지에 대한 정보를 출력할 것입니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-05-17-NielslearnsRust2GettingstartedwithAVRRust_6.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e좋아요, 작동이 되네요! 하지만 아직 결과물이 그렇게 유용하진 않네요.\u003c/p\u003e\n\u003cp\u003e마지막 목표는 네이티브 코드로 컴파일되어 실행되고 성능을 측정하기 위해 여러 벤치마크를 실행하고 확인하는 JVM을 구축하는 것입니다. 이를 위해 더 자세한 출력이 필요하므로, 다음 게시물에서는 디버그 출력 및 다른 계산 도구를 추가하는 방법에 대해 다뤄볼 예정입니다.\u003c/p\u003e\n\u003cp\u003e이 단계에서의 코드 상태는 여기 Github에서 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e원문은 2024년 5월 6일에 \u003ca href=\"https://nielsreijers.github.io%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://nielsreijers.github.io에서\u003c/a\u003e 최초로 게시되었습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-17-NielslearnsRust2GettingstartedwithAVRRust"},"buildId":"aCCUs-qPrLLLWRnkN0AOd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>