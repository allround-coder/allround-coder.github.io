<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>2024년 최고의 Nodejs 백엔드 프레임워크 5가지 | allround-coder</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://allround-coder.github.io///post/2024-06-22-Top5NodejsBackendFrameworksin2024" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="2024년 최고의 Nodejs 백엔드 프레임워크 5가지 | allround-coder" data-gatsby-head="true"/><meta property="og:title" content="2024년 최고의 Nodejs 백엔드 프레임워크 5가지 | allround-coder" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://allround-coder.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://allround-coder.github.io///post/2024-06-22-Top5NodejsBackendFrameworksin2024" data-gatsby-head="true"/><meta name="twitter:title" content="2024년 최고의 Nodejs 백엔드 프레임워크 5가지 | allround-coder" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | allround-coder" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 05:27" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZFDEQ947R4"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
  
            gtag('config', 'G-ZFDEQ947R4');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-b088bc509ff5c497.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_buildManifest.js" defer=""></script><script src="/_next/static/t9N7vwmpvBMQnO2PSctoH/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">Allround Coder</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">2024년 최고의 Nodejs 백엔드 프레임워크 5가지</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="2024년 최고의 Nodejs 백엔드 프레임워크 5가지" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">Allround Coder</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-Top5NodejsBackendFrameworksin2024&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>2024년 API를 구축하기 위해 Hapi, Express.js, NestJS, Koa.js 및 Adonis.js를 탐험해보세요</h2>
<h1>소개</h1>
<p>Node.js는 2009년 이후로 핫한 주제였으며 대부분의 백엔드 개발자들은 Node.js를 선호합니다. 그 인기는 지난 몇 년간 계속 증가해 왔습니다.</p>
<p><img src="/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_0.png" alt="이미지"></p>
<p>인기 증가의 이유는 로딩 시간의 감소와 성능 향상 때문입니다. 따라서, 2024년을 위한 상위 5개 Node.js 백엔드 프레임워크를 분석하는 것이 중요합니다.</p>
<p>따라서 이 기사에서는 2024년을 위한 상위 5개 Node.js 백엔드 프레임워크, 그들의 특징, 그리고 일반적인 사용 사례에 대해 다룰 것입니다.</p>
<p><img src="/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_1.png" alt="image"></p>
<h1>Express.js: 검증된 챔피언</h1>
<p><img src="/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_2.png" alt="Express.js"></p>
<p>Express.js는 Node.js의 가장 유명한 백엔드 프레임워크 중 하나입니다. 오픈 소스 웹 어플리케이션 프레임워크로, Node.js 플랫폼 위에 만들어져 있어 무료로 이용할 수 있습니다. Express.js는 미니멀한 프레임워크이기 때문에 초보자부터 경험이 풍부한 웹 개발자들이 선호합니다. 웹 애플리케이션 및 RESTful API를 작성하는 데 주로 사용됩니다.</p>
<h1>주요 기능: 높은 효율의 라우팅</h1>
<p>Express.js는 다양한 HTTP 요청을 관리하고 특정 작업에 할당하는 간단하고 깔끔한 방법을 제공합니다. 아래 예제를 살펴봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// app.js</span>
<span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;

<span class="hljs-comment">// 홈페이지 라우트</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">'홈페이지에 오신 것을 환영합니다!'</span>);
});

<span class="hljs-comment">// 사용자 라우트</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/user/:id'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =></span> {
  <span class="hljs-keyword">const</span> userId = req.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>;
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`사용자 프로필 페이지 - ID: <span class="hljs-subst">${userId}</span>`</span>);
});
</code></pre>
<ol start="2">
<li>미들웨어 지원</li>
</ol>
<p>Express.js는 HTTP 요청을 처리하기 위한 미들웨어 지원을 제공합니다. HTTP 요청 세부 정보를 기록하는 미들웨어를 만드는 간단한 예제를 살펴봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;

app.<span class="hljs-title function_">use</span>(<span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`[<span class="hljs-subst">${<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleString()}</span>] <span class="hljs-subst">${req.method}</span> <span class="hljs-subst">${req.url}</span>`</span> );
  <span class="hljs-title function_">next</span>();
});
</code></pre>
<ol start="3">
<li>쉬운 데이터베이스 통합</li>
</ol>
<p>Express.js는 데이터베이스에 구애받지 않습니다. 특정 데이터베이스 선택을 강요하지 않습니다. 개발자들은 원하는 데이터베이스를 선택할 수 있습니다. Express.js와 데이터베이스를 통합시키는 것은 모듈식이고 유연한 성질과 데이터베이스 연결을 제공하는 npm 패키지의 풍부한 생태계 덕분에 쉽습니다.</p>
<ol start="4">
<li>배우기 쉽습니다</li>
</ol>
<p>Express.js는 간결하고 최소주의 디자인으로 유명하며, 특히 JavaScript와 Node.js에 익숙한 개발자들에게 배우기 쉬운 것으로 알려져 있어요.</p>
<p>게다가 Bit와 같은 도구를 사용하여 Express.js를 쉽게 시작할 수 있어요. Bit는 추가 구성 가능한 소프트웨어를 위한 차세대 빌드 시스템입니다.</p>
<p>예를 들어 미들웨어 구성 요소를 만들어 필요할 때마다 끼워 넣거나 빼낼 수 있어요.</p>
<p><img src="/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_3.png" alt="이미지"></p>
<p>제목: Bit 및 독립 컴포넌트를 사용하여 설계된 Express API의 범위</p>
<p>두 개의 컴포넌트를 볼 수 있어요: Authorizer와 API 앱입니다. 이 두 컴포넌트는 독립적인 Bit 컴포넌트로 구현되어 있으며 별도의 공간에서 유지 및 버전 관리됩니다.</p>
<p>이렇게 함으로써 앱을 조합 가능한 방식으로 빠르게 설계할 수 있어요!</p>
<p>이 완벽한 구현을 보려면 Bit Scope를 확인해주세요.</p>
<h1>NestJS: 현대적이고 체계적인 방법</h1>
<p><img src="/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_4.png" alt="image"></p>
<p>NestJS는 확장 가능하고 효율적인 Node.js 서버 측 애플리케이션을 구축하는 데 알려진 프레임워크입니다. Progressive JavaScript를 사용하며 TypeScript로 코드를 작성할 수 있는 기능을 갖추고 있습니다. TypeScript를 완전히 지원하지만, 순수 JavaScript로 코드를 작성할 수 있으며 객체지향 프로그래밍, 함수형 프로그래밍 및 함수형 반응형 프로그래밍을 포함하고 있습니다.</p>
<h1>주요 기능: 높게 평가되는 이유</h1>
<ol>
<li>모듈성</li>
</ol>
<p>Nest.js는 코드를 별도의 관리 가능한 모듈로 분할할 수 있어 유지 보수가 더 쉬워집니다. 예를 들어 아래 모듈을 살펴봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Module</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

@<span class="hljs-title class_">Module</span>({
 <span class="hljs-attr">imports</span>: [
  <span class="hljs-title class_">CacheModule</span>
 ],
 <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">PaymentController</span>],
 <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">PaymentService</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentModule</span> {}
</code></pre>
<p>이 결제 모듈은 다른 모듈로 내보낼 수 있습니다. 이 예시에서는 이 모듈 내에서 공통 캐시 모듈을 내보냈습니다. Nest.js는 모듈 구조를 가지고 있기 때문에 관리가 용이합니다.</p>
<h3>2. 확장 가능성</h3>
<p>Nest.js는 어플리케이션을 관리 가능한 모듈로 분할하여 확장을 용이하게 합니다. 유연한 컴포넌트 교체를 지원하며, 마이크로서비스 및 비동기 작업을 통해 고트래픽을 처리할 수 있습니다. 늘어난 작업 부하를 효율적으로 처리하면서도 안정성을 유지합니다.</p>
<h3>3. 의존성 주입</h3>
<p>의존성 주입은 외부 종속성을 클래스 내부에서 생성하는 대신 클래스에 추가하는 간단한 방법입니다. 예제를 살펴보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> {
 <span class="hljs-title class_">HttpException</span>, <span class="hljs-title class_">Injectable</span>, <span class="hljs-title class_">NotFoundException</span>
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

@<span class="hljs-title class_">Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentService</span> {

 <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {}

 <span class="hljs-title function_">getReceipt</span>(<span class="hljs-params"></span>) {
   <span class="hljs-keyword">return</span> <span class="hljs-string">'Payment Receipt'</span>;
 }

}
</code></pre>
<p>저희는 결제 서비스를 만들었고 @Injectable() 어노테이션을 추가하여 주입 가능하게 만들었습니다. 아래와 같이 만들어진 서비스를 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span>, <span class="hljs-title class_">Post</span>, <span class="hljs-title class_">Body</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">PaymentService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./payment.service'</span>;
@<span class="hljs-title class_">Controller</span>(<span class="hljs-string">'payment'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentController</span> {
 <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private readonly paymentService: PaymentService</span>) {}
@<span class="hljs-title class_">Get</span>()
 <span class="hljs-title function_">getPaymentReceipt</span>(<span class="hljs-params"></span>) {
 <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">paymentService</span>.<span class="hljs-title function_">getReceipt</span>();
 }
}
</code></pre>
<ol start="4">
<li>타입 안전성</li>
</ol>
<p><code>Nest.js</code>에서는 TypeScript를 사용하여 유형 안전성을 제공하며, 개발 중 잠재적인 오류를 찾아내고 코드 유지보수성을 개선하는 데 사용할 수 있습니다. 예를 살펴봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentDto</span> {

  @<span class="hljs-title class_">IsNotEmpty</span>()
  @<span class="hljs-title class_">IsEnum</span>(<span class="hljs-variable constant_">SERVICE_PROVIDER_SLUG</span>, {
    <span class="hljs-attr">message</span>: <span class="hljs-string">`Invalid serviceProvider. Valid options are: <span class="hljs-subst">${<span class="hljs-built_in">Object</span>.values(SERVICE_PROVIDER_SLUG).join(<span class="hljs-string">', '</span>)}</span>`</span>,
  })
  <span class="hljs-attr">serviceProvider</span>: string;

  @<span class="hljs-title class_">IsNotEmpty</span>()
  @<span class="hljs-title class_">IsNumber</span>()
  <span class="hljs-attr">value</span>: number;

  @<span class="hljs-title class_">IsNotEmpty</span>()
  @<span class="hljs-title class_">IsString</span>()
  <span class="hljs-attr">validityPeriod</span>: string;

  @<span class="hljs-title class_">IsNotEmpty</span>()
  @<span class="hljs-title class_">IsArray</span>()
  @<span class="hljs-title class_">ArrayNotEmpty</span>()
  @<span class="hljs-title class_">ValidateNested</span>()
  @<span class="hljs-title class_">Type</span>(<span class="hljs-function">() =></span> <span class="hljs-title class_">PaymentAttributesDto</span>)
  <span class="hljs-attr">paymentAttributes</span>: <span class="hljs-title class_">PaymentAttributesDto</span>[]

}
</code></pre>
<p>이 예시에서, 우리는 여러 매개변수를 포함하는 DTO를 생성하고 매개변수 유형을 유효성 검사하는 어노테이션을 추가했습니다. 예를 들어, "value" 매개변수에 문자열 값을 보내면 오류가 발생합니다.</p>
<h1>Koa.js: 우아하고 가벼운</h1>
<p>Koa.js는 Express.js 팀이 설계한 더 작고 표현력 있는 웹 프레임워크입니다. 이를 사용하면 콜백을 버릴 수 있고 async 함수를 활용하여 오류를 처리할 수 있습니다.</p>
<h1>주요 기능: 눈에 띄는 특징</h1>
<ol>
<li>컨텍스트 객체(ctx)</li>
</ol>
<p>Koa.js에는 요청과 응답 세부 사항을 캡처하는 ctx라는 기능이 포함되어 있습니다. 이 컨텍스트는 각 미들웨어에 전달됩니다. 이 예시에서는 ctx 객체에서 메서드와 요청을 기록했습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();

app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx) => {
  <span class="hljs-keyword">const</span> { method, url, request, response } = ctx;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Method :'</span> + method + <span class="hljs-string">' Request : '</span> + request);
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre>
<ol start="2">
<li>미들웨어 조합</li>
</ol>
<p>Express Js와 유사하게, Koa는 HTTP 요청과 응답을 처리하기 위한 미들웨어 함수를 지원합니다. 이 예시에서는 간단한 미들웨어를 만들었습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();

app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) => {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>(); 
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre>
<ol start="3">
<li>Async/Await Support</li>
</ol>
<p>Koa는 비동기 코드를 더 동기적으로 보이게 작성하기 위해 async/await 구문을 사용합니다. 아래 예제는 async/await 키워드를 사용하는 예시입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();

app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx) => {
  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchData</span>();
  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">`Data: <span class="hljs-subst">${data}</span>`</span>;
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre>
<ol start="4">
<li>오류 처리</li>
</ol>
<p>Koa.Js는 다양한 종류의 오류 처리를 지원합니다. 오류를 처리하기 위해 app.emit() 또는 ctx.throw()를 사용할 수 있습니다. 아래 예시는 언급된 오류 처리 방법을 포함하고 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">'koa'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title function_">koa</span>();

<span class="hljs-comment">// 오류 처리 방법 1</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) => {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">'문제가 발생했습니다'</span>);
  } <span class="hljs-keyword">catch</span> (err) {
    ctx.<span class="hljs-property">status</span> = err.<span class="hljs-property">status</span> || <span class="hljs-number">500</span>;
    ctx.<span class="hljs-property">body</span> = err.<span class="hljs-property">message</span>;
    ctx.<span class="hljs-property">app</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'error'</span>, err, ctx);
  }
});

<span class="hljs-comment">// 오류 처리 방법 2</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) => {
  ctx.<span class="hljs-keyword">throw</span>(<span class="hljs-number">500</span>, <span class="hljs-string">'에러'</span>);
});

app.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err, ctx</span>) =></span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre>
<h1>Hapi.js</h1>
<p>Hapi.js는 Http-API를 축약한 것으로, 확장 가능한 웹 애플리케이션을 개발하기 위한 오픈 소스 프레임워크입니다. hapi의 가장 기본적인 사용 사례 중 하나는 REST API를 구축하는 것입니다.</p>
<h1>주요 기능: 뛰어나게 만드는 요소</h1>
<ol>
<li>구성 중심 설계</li>
</ol>
<p>Hapi.js의 구성 객체를 사용하면 라우트, 설정 및 플러그인을 설정할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Hapi</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@hapi/hapi'</span>);

<span class="hljs-keyword">const</span> server = <span class="hljs-title class_">Hapi</span>.<span class="hljs-title function_">server</span>({
  <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,
  <span class="hljs-attr">routes</span>: {
    <span class="hljs-attr">cors</span>: <span class="hljs-literal">true</span>,
  },
});

server.<span class="hljs-title function_">route</span>({
  <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
  <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>,
  <span class="hljs-attr">handler</span>: <span class="hljs-function">(<span class="hljs-params">request, h</span>) =></span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello, Hapi!'</span>;
  },
});

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">start</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> server.<span class="hljs-title function_">start</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'서버가 ${server.info.uri}에서 실행 중'</span>);
}

<span class="hljs-title function_">start</span>();
</code></pre>
<ol start="2">
<li>강력한 플러그인 시스템</li>
</ol>
<p>Hapi.js는 플러그인을 간편하게 통합할 수 있는 기능을 제공합니다. 다음 예제를 살펴봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> start = <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {

    <span class="hljs-keyword">const</span> server = <span class="hljs-title class_">Hapi</span>.<span class="hljs-title function_">server</span>();

    <span class="hljs-keyword">await</span> server.<span class="hljs-title function_">register</span>([{
        <span class="hljs-attr">plugin</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'plugin1'</span>),
        <span class="hljs-attr">options</span>: {}
    }, {
        <span class="hljs-attr">plugin</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">'plugin2'</span>),
        <span class="hljs-attr">options</span>: {}
    }]);
};
</code></pre>
<p>이 예제에서는 두 개의 플러그인이 통합되었습니다. 옵션은 options 키를 사용하여 플러그인에 전달할 수 있습니다.</p>
<ol start="3">
<li>인증 및 권한</li>
</ol>
<p>Hapi.js는 다양한 인증 전략에 대한 내장 지원을 제공하며, 개발자들이 쉽게 액세스 제어 정책을 정의할 수 있도록 합니다.</p>
<pre><code class="hljs language-js">server.<span class="hljs-title function_">route</span>({
  <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span>,
  <span class="hljs-attr">path</span>: <span class="hljs-string">'/private-data'</span>,
  <span class="hljs-attr">handler</span>: <span class="hljs-function">(<span class="hljs-params">request, h</span>) =></span> {
    <span class="hljs-comment">// 인증된 경우에만 개인 데이터에 액세스합니다</span>
    <span class="hljs-keyword">const</span> user = request.<span class="hljs-property">auth</span>.<span class="hljs-property">credentials</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">`환영합니다, <span class="hljs-subst">${user.username}</span>!`</span>;
  },
  <span class="hljs-attr">options</span>: {
    <span class="hljs-attr">auth</span>: <span class="hljs-string">'jwt'</span>, <span class="hljs-comment">// JWT 인증 전략 사용</span>
  },
});
</code></pre>
<p>이 예제를 기반으로하여, 우리는 인증 전략을 'jwt'로 직접 정의할 수 있습니다.</p>
<ol start="4">
<li>입력 유효성 검사</li>
</ol>
<p>입력 유효성 검사는 hapi.js의 또 다른 중요한 측면입니다. route의 options 객체에서 어떤 입력을 검증해야 하는지 정의할 수 있습니다. 기본 validate 객체는 아래 값으로 구성됩니다.</p>
<pre><code class="hljs language-js">{ 
   <span class="hljs-attr">headers</span>: <span class="hljs-literal">true</span>, 
   <span class="hljs-attr">params</span>: <span class="hljs-literal">true</span>, 
   <span class="hljs-attr">query</span>: <span class="hljs-literal">true</span>, 
   <span class="hljs-attr">payload</span>: <span class="hljs-literal">true</span>, 
   <span class="hljs-attr">state</span>: <span class="hljs-literal">true</span>, 
   <span class="hljs-attr">failAction</span>: <span class="hljs-string">'error'</span>
}
</code></pre>
<h1>Adonis.js</h1>
<p><img src="/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_7.png" alt="Adonis.js Logo"></p>
<p>Adonis.js는 Node.js를 위한 전체 기능을 갖춘 MVC 프레임워크입니다. 확장 가능하고 유지 보수 가능한 애플리케이션을 구축할 수 있습니다. Adonis.js는 Laravel과 유사한 구조를 따르며 ORM, 인증 및 라우팅과 같은 기능을 기본 제공합니다.</p>
<h1>핵심 기능: 두드러지는 이유</h1>
<ol>
<li>풀 스택 MVC 프레임워크</li>
</ol>
<p>Adonis.js는 MVC 아키텍처 패턴을 따릅니다. MVC 프레임워크를 사용하면 코드를 조직화하고 유지 관리하고 확장하기 쉬워집니다.</p>
<ol start="2">
<li>데이터베이스 상호 작용을 위한 통합된 ORM(Lucid)</li>
</ol>
<p>Adonis.js는 Lucid라는 자체 ORM을 가지고 있어요. Lucid는 표현적인 쿼리 빌더를 제공하며 다양한 데이터베이스 시스템을 지원해요. Lucid에서는 데이터베이스에 읽고 쓰기 위해 모델을 생성할 수 있어요. 아래 예시를 살펴보세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Model</span> = <span class="hljs-title function_">use</span>(<span class="hljs-string">'Model'</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Model</span> {
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">User</span>
</code></pre>
<p>우리는 이 사용자 모델을 데이터베이스 쿼리 대신 사용하고 있어요. 이제 라우트를 생성하는데, 해당 내부에서 사용자를 가져오고 있어요. 사용자를 가져오기 위해, 간단히 <code>User.all()</code>을 사용할 수 있어요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Route</span> = <span class="hljs-title function_">use</span>(<span class="hljs-string">'Route'</span>)
<span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = <span class="hljs-title function_">use</span>(<span class="hljs-string">'App/Models/User'</span>)

<span class="hljs-title class_">Route</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'users'</span>, <span class="hljs-keyword">async</span> () => {
<span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">all</span>()
})
</code></pre>
<ol start="3">
<li>인증 시스템</li>
</ol>
<p>Adonis.js에는 사용자 인증 및 권한 부여를 위한 기본 지원이 있습니다. 사용자 세션, 비밀번호 해싱, 및 접근 제어를 다루는 일련의 메서드와 미들웨어를 제공합니다.</p>
<h1>결론</h1>
<p>2024년에는 위에서 언급한 백엔드 프레임워크들이 시장에서 높은 위치를 차지하고 있습니다.</p>
<p>Express.js는 간결함 때문에, Nest.js는 구조 때문에, Adonis.js는 생산성 때문에, Koa.js는 우아함 때문에 선택했을지라도, 올바른 프레임워크를 선택하는 것이 중요합니다.</p>
<p>또한, 2024년에 성공적인 백엔드 개발 여정을 하려면 최신 트렌드, 기존 프레임워크의 새로운 기능, 그리고 새로운 프레임워크를 찾는 것이 중요합니다.</p>
<h1>더 알아보기</h1>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"2024년 최고의 Nodejs 백엔드 프레임워크 5가지","description":"","date":"2024-06-22 05:27","slug":"2024-06-22-Top5NodejsBackendFrameworksin2024","content":"\n\n## 2024년 API를 구축하기 위해 Hapi, Express.js, NestJS, Koa.js 및 Adonis.js를 탐험해보세요\n\n# 소개\n\nNode.js는 2009년 이후로 핫한 주제였으며 대부분의 백엔드 개발자들은 Node.js를 선호합니다. 그 인기는 지난 몇 년간 계속 증가해 왔습니다.\n\n![이미지](/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인기 증가의 이유는 로딩 시간의 감소와 성능 향상 때문입니다. 따라서, 2024년을 위한 상위 5개 Node.js 백엔드 프레임워크를 분석하는 것이 중요합니다.\n\n따라서 이 기사에서는 2024년을 위한 상위 5개 Node.js 백엔드 프레임워크, 그들의 특징, 그리고 일반적인 사용 사례에 대해 다룰 것입니다.\n\n![image](/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_1.png)\n\n# Express.js: 검증된 챔피언\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Express.js](/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_2.png)\n\nExpress.js는 Node.js의 가장 유명한 백엔드 프레임워크 중 하나입니다. 오픈 소스 웹 어플리케이션 프레임워크로, Node.js 플랫폼 위에 만들어져 있어 무료로 이용할 수 있습니다. Express.js는 미니멀한 프레임워크이기 때문에 초보자부터 경험이 풍부한 웹 개발자들이 선호합니다. 웹 애플리케이션 및 RESTful API를 작성하는 데 주로 사용됩니다.\n\n# 주요 기능: 높은 효율의 라우팅\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExpress.js는 다양한 HTTP 요청을 관리하고 특정 작업에 할당하는 간단하고 깔끔한 방법을 제공합니다. 아래 예제를 살펴봅시다.\n\n```js\n// app.js\nconst express = require('express');\nconst app = express();\nconst port = 3000;\n\n// 홈페이지 라우트\napp.get('/', (req, res) =\u003e {\n  res.send('홈페이지에 오신 것을 환영합니다!');\n});\n\n// 사용자 라우트\napp.get('/user/:id', (req, res) =\u003e {\n  const userId = req.params.id;\n  res.send(`사용자 프로필 페이지 - ID: ${userId}`);\n});\n```\n\n2. 미들웨어 지원\n\nExpress.js는 HTTP 요청을 처리하기 위한 미들웨어 지원을 제공합니다. HTTP 요청 세부 정보를 기록하는 미들웨어를 만드는 간단한 예제를 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.use((req, res, next) =\u003e {\n  console.log(`[${new Date().toLocaleString()}] ${req.method} ${req.url}` );\n  next();\n});\n```\n\n3. 쉬운 데이터베이스 통합\n\nExpress.js는 데이터베이스에 구애받지 않습니다. 특정 데이터베이스 선택을 강요하지 않습니다. 개발자들은 원하는 데이터베이스를 선택할 수 있습니다. Express.js와 데이터베이스를 통합시키는 것은 모듈식이고 유연한 성질과 데이터베이스 연결을 제공하는 npm 패키지의 풍부한 생태계 덕분에 쉽습니다.\n\n4. 배우기 쉽습니다\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExpress.js는 간결하고 최소주의 디자인으로 유명하며, 특히 JavaScript와 Node.js에 익숙한 개발자들에게 배우기 쉬운 것으로 알려져 있어요.\n\n게다가 Bit와 같은 도구를 사용하여 Express.js를 쉽게 시작할 수 있어요. Bit는 추가 구성 가능한 소프트웨어를 위한 차세대 빌드 시스템입니다.\n\n예를 들어 미들웨어 구성 요소를 만들어 필요할 때마다 끼워 넣거나 빼낼 수 있어요.\n\n![이미지](/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제목: Bit 및 독립 컴포넌트를 사용하여 설계된 Express API의 범위\n\n두 개의 컴포넌트를 볼 수 있어요: Authorizer와 API 앱입니다. 이 두 컴포넌트는 독립적인 Bit 컴포넌트로 구현되어 있으며 별도의 공간에서 유지 및 버전 관리됩니다.\n\n이렇게 함으로써 앱을 조합 가능한 방식으로 빠르게 설계할 수 있어요!\n\n이 완벽한 구현을 보려면 Bit Scope를 확인해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# NestJS: 현대적이고 체계적인 방법\n\n![image](/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_4.png)\n\nNestJS는 확장 가능하고 효율적인 Node.js 서버 측 애플리케이션을 구축하는 데 알려진 프레임워크입니다. Progressive JavaScript를 사용하며 TypeScript로 코드를 작성할 수 있는 기능을 갖추고 있습니다. TypeScript를 완전히 지원하지만, 순수 JavaScript로 코드를 작성할 수 있으며 객체지향 프로그래밍, 함수형 프로그래밍 및 함수형 반응형 프로그래밍을 포함하고 있습니다.\n\n# 주요 기능: 높게 평가되는 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 모듈성\n\nNest.js는 코드를 별도의 관리 가능한 모듈로 분할할 수 있어 유지 보수가 더 쉬워집니다. 예를 들어 아래 모듈을 살펴봅시다.\n\n```js\nimport { Module } from '@nestjs/common';\n\n@Module({\n imports: [\n  CacheModule\n ],\n controllers: [PaymentController],\n providers: [PaymentService],\n})\nexport class PaymentModule {}\n```\n\n이 결제 모듈은 다른 모듈로 내보낼 수 있습니다. 이 예시에서는 이 모듈 내에서 공통 캐시 모듈을 내보냈습니다. Nest.js는 모듈 구조를 가지고 있기 때문에 관리가 용이합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 2. 확장 가능성\n\nNest.js는 어플리케이션을 관리 가능한 모듈로 분할하여 확장을 용이하게 합니다. 유연한 컴포넌트 교체를 지원하며, 마이크로서비스 및 비동기 작업을 통해 고트래픽을 처리할 수 있습니다. 늘어난 작업 부하를 효율적으로 처리하면서도 안정성을 유지합니다.\n\n### 3. 의존성 주입\n\n의존성 주입은 외부 종속성을 클래스 내부에서 생성하는 대신 클래스에 추가하는 간단한 방법입니다. 예제를 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport {\n HttpException, Injectable, NotFoundException\n} from '@nestjs/common';\n\n@Injectable()\nexport class PaymentService {\n\n constructor() {}\n\n getReceipt() {\n   return 'Payment Receipt';\n }\n\n}\n```\n\n저희는 결제 서비스를 만들었고 @Injectable() 어노테이션을 추가하여 주입 가능하게 만들었습니다. 아래와 같이 만들어진 서비스를 사용할 수 있습니다.\n\n```js\nimport { Controller, Get, Post, Body } from '@nestjs/common';\nimport { PaymentService } from './payment.service';\n@Controller('payment')\nexport class PaymentController {\n constructor(private readonly paymentService: PaymentService) {}\n@Get()\n getPaymentReceipt() {\n return this.paymentService.getReceipt();\n }\n}\n```\n\n4. 타입 안전성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`Nest.js`에서는 TypeScript를 사용하여 유형 안전성을 제공하며, 개발 중 잠재적인 오류를 찾아내고 코드 유지보수성을 개선하는 데 사용할 수 있습니다. 예를 살펴봅시다.\n\n```js\nexport class PaymentDto {\n\n  @IsNotEmpty()\n  @IsEnum(SERVICE_PROVIDER_SLUG, {\n    message: `Invalid serviceProvider. Valid options are: ${Object.values(SERVICE_PROVIDER_SLUG).join(', ')}`,\n  })\n  serviceProvider: string;\n\n  @IsNotEmpty()\n  @IsNumber()\n  value: number;\n\n  @IsNotEmpty()\n  @IsString()\n  validityPeriod: string;\n\n  @IsNotEmpty()\n  @IsArray()\n  @ArrayNotEmpty()\n  @ValidateNested()\n  @Type(() =\u003e PaymentAttributesDto)\n  paymentAttributes: PaymentAttributesDto[]\n\n}\n```\n\n이 예시에서, 우리는 여러 매개변수를 포함하는 DTO를 생성하고 매개변수 유형을 유효성 검사하는 어노테이션을 추가했습니다. 예를 들어, \"value\" 매개변수에 문자열 값을 보내면 오류가 발생합니다.\n\n# Koa.js: 우아하고 가벼운\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_5.png\" /\u003e\n\nKoa.js는 Express.js 팀이 설계한 더 작고 표현력 있는 웹 프레임워크입니다. 이를 사용하면 콜백을 버릴 수 있고 async 함수를 활용하여 오류를 처리할 수 있습니다.\n\n# 주요 기능: 눈에 띄는 특징\n\n1. 컨텍스트 객체(ctx)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKoa.js에는 요청과 응답 세부 사항을 캡처하는 ctx라는 기능이 포함되어 있습니다. 이 컨텍스트는 각 미들웨어에 전달됩니다. 이 예시에서는 ctx 객체에서 메서드와 요청을 기록했습니다.\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.use(async (ctx) =\u003e {\n  const { method, url, request, response } = ctx;\n  console.log('Method :' + method + ' Request : ' + request);\n});\n\napp.listen(3000);\n```\n\n2. 미들웨어 조합\n\nExpress Js와 유사하게, Koa는 HTTP 요청과 응답을 처리하기 위한 미들웨어 함수를 지원합니다. 이 예시에서는 간단한 미들웨어를 만들었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.use(async (ctx, next) =\u003e {\n  await next(); \n});\n\napp.listen(3000);\n```\n\n3. Async/Await Support\n\nKoa는 비동기 코드를 더 동기적으로 보이게 작성하기 위해 async/await 구문을 사용합니다. 아래 예제는 async/await 키워드를 사용하는 예시입니다.\n\n```js\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.use(async (ctx) =\u003e {\n  const data = await fetchData();\n  ctx.body = `Data: ${data}`;\n});\n\napp.listen(3000);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 오류 처리\n\nKoa.Js는 다양한 종류의 오류 처리를 지원합니다. 오류를 처리하기 위해 app.emit() 또는 ctx.throw()를 사용할 수 있습니다. 아래 예시는 언급된 오류 처리 방법을 포함하고 있습니다.\n\n```js\nconst koa = require('koa');\nconst app = new koa();\n\n// 오류 처리 방법 1\napp.use(async (ctx, next) =\u003e {\n  try {\n    await Promise.reject('문제가 발생했습니다');\n  } catch (err) {\n    ctx.status = err.status || 500;\n    ctx.body = err.message;\n    ctx.app.emit('error', err, ctx);\n  }\n});\n\n// 오류 처리 방법 2\napp.use(async (ctx, next) =\u003e {\n  ctx.throw(500, '에러');\n});\n\napp.on('error', (err, ctx) =\u003e {\n  console.log(err);\n});\n\napp.listen(3000);\n```\n\n# Hapi.js\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_6.png\" /\u003e\n\nHapi.js는 Http-API를 축약한 것으로, 확장 가능한 웹 애플리케이션을 개발하기 위한 오픈 소스 프레임워크입니다. hapi의 가장 기본적인 사용 사례 중 하나는 REST API를 구축하는 것입니다.\n\n# 주요 기능: 뛰어나게 만드는 요소\n\n1. 구성 중심 설계\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHapi.js의 구성 객체를 사용하면 라우트, 설정 및 플러그인을 설정할 수 있습니다.\n\n```js\nconst Hapi = require('@hapi/hapi');\n\nconst server = Hapi.server({\n  port: 3000,\n  routes: {\n    cors: true,\n  },\n});\n\nserver.route({\n  method: 'GET',\n  path: '/',\n  handler: (request, h) =\u003e {\n    return 'Hello, Hapi!';\n  },\n});\n\nasync function start() {\n  await server.start();\n  console.log('서버가 ${server.info.uri}에서 실행 중');\n}\n\nstart();\n```\n\n2. 강력한 플러그인 시스템\n\nHapi.js는 플러그인을 간편하게 통합할 수 있는 기능을 제공합니다. 다음 예제를 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst start = async function () {\n\n    const server = Hapi.server();\n\n    await server.register([{\n        plugin: require('plugin1'),\n        options: {}\n    }, {\n        plugin: require('plugin2'),\n        options: {}\n    }]);\n};\n```\n이 예제에서는 두 개의 플러그인이 통합되었습니다. 옵션은 options 키를 사용하여 플러그인에 전달할 수 있습니다.\n\n3. 인증 및 권한\n\nHapi.js는 다양한 인증 전략에 대한 내장 지원을 제공하며, 개발자들이 쉽게 액세스 제어 정책을 정의할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nserver.route({\n  method: 'GET',\n  path: '/private-data',\n  handler: (request, h) =\u003e {\n    // 인증된 경우에만 개인 데이터에 액세스합니다\n    const user = request.auth.credentials;\n    return `환영합니다, ${user.username}!`;\n  },\n  options: {\n    auth: 'jwt', // JWT 인증 전략 사용\n  },\n});\n```\n\n이 예제를 기반으로하여, 우리는 인증 전략을 'jwt'로 직접 정의할 수 있습니다.\n\n4. 입력 유효성 검사\n\n입력 유효성 검사는 hapi.js의 또 다른 중요한 측면입니다. route의 options 객체에서 어떤 입력을 검증해야 하는지 정의할 수 있습니다. 기본 validate 객체는 아래 값으로 구성됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{ \n   headers: true, \n   params: true, \n   query: true, \n   payload: true, \n   state: true, \n   failAction: 'error'\n}\n```\n\n# Adonis.js\n\n![Adonis.js Logo](/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_7.png)\n\nAdonis.js는 Node.js를 위한 전체 기능을 갖춘 MVC 프레임워크입니다. 확장 가능하고 유지 보수 가능한 애플리케이션을 구축할 수 있습니다. Adonis.js는 Laravel과 유사한 구조를 따르며 ORM, 인증 및 라우팅과 같은 기능을 기본 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 핵심 기능: 두드러지는 이유\n\n1. 풀 스택 MVC 프레임워크\n\nAdonis.js는 MVC 아키텍처 패턴을 따릅니다. MVC 프레임워크를 사용하면 코드를 조직화하고 유지 관리하고 확장하기 쉬워집니다.\n\n2. 데이터베이스 상호 작용을 위한 통합된 ORM(Lucid)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAdonis.js는 Lucid라는 자체 ORM을 가지고 있어요. Lucid는 표현적인 쿼리 빌더를 제공하며 다양한 데이터베이스 시스템을 지원해요. Lucid에서는 데이터베이스에 읽고 쓰기 위해 모델을 생성할 수 있어요. 아래 예시를 살펴보세요.\n\n```js\nconst Model = use('Model')\n\nclass User extends Model {\n}\n\nmodule.exports = User\n```\n\n우리는 이 사용자 모델을 데이터베이스 쿼리 대신 사용하고 있어요. 이제 라우트를 생성하는데, 해당 내부에서 사용자를 가져오고 있어요. 사용자를 가져오기 위해, 간단히 `User.all()`을 사용할 수 있어요.\n\n```js\nconst Route = use('Route')\nconst User = use('App/Models/User')\n\nRoute.get('users', async () =\u003e {\nreturn await User.all()\n})\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 인증 시스템\n\nAdonis.js에는 사용자 인증 및 권한 부여를 위한 기본 지원이 있습니다. 사용자 세션, 비밀번호 해싱, 및 접근 제어를 다루는 일련의 메서드와 미들웨어를 제공합니다.\n\n# 결론\n\n2024년에는 위에서 언급한 백엔드 프레임워크들이 시장에서 높은 위치를 차지하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nExpress.js는 간결함 때문에, Nest.js는 구조 때문에, Adonis.js는 생산성 때문에, Koa.js는 우아함 때문에 선택했을지라도, 올바른 프레임워크를 선택하는 것이 중요합니다.\n\n또한, 2024년에 성공적인 백엔드 개발 여정을 하려면 최신 트렌드, 기존 프레임워크의 새로운 기능, 그리고 새로운 프레임워크를 찾는 것이 중요합니다.\n\n# 더 알아보기","ogImage":{"url":"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_0.png"},"coverImage":"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e2024년 API를 구축하기 위해 Hapi, Express.js, NestJS, Koa.js 및 Adonis.js를 탐험해보세요\u003c/h2\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003eNode.js는 2009년 이후로 핫한 주제였으며 대부분의 백엔드 개발자들은 Node.js를 선호합니다. 그 인기는 지난 몇 년간 계속 증가해 왔습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e인기 증가의 이유는 로딩 시간의 감소와 성능 향상 때문입니다. 따라서, 2024년을 위한 상위 5개 Node.js 백엔드 프레임워크를 분석하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e따라서 이 기사에서는 2024년을 위한 상위 5개 Node.js 백엔드 프레임워크, 그들의 특징, 그리고 일반적인 사용 사례에 대해 다룰 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch1\u003eExpress.js: 검증된 챔피언\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_2.png\" alt=\"Express.js\"\u003e\u003c/p\u003e\n\u003cp\u003eExpress.js는 Node.js의 가장 유명한 백엔드 프레임워크 중 하나입니다. 오픈 소스 웹 어플리케이션 프레임워크로, Node.js 플랫폼 위에 만들어져 있어 무료로 이용할 수 있습니다. Express.js는 미니멀한 프레임워크이기 때문에 초보자부터 경험이 풍부한 웹 개발자들이 선호합니다. 웹 애플리케이션 및 RESTful API를 작성하는 데 주로 사용됩니다.\u003c/p\u003e\n\u003ch1\u003e주요 기능: 높은 효율의 라우팅\u003c/h1\u003e\n\u003cp\u003eExpress.js는 다양한 HTTP 요청을 관리하고 특정 작업에 할당하는 간단하고 깔끔한 방법을 제공합니다. 아래 예제를 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// app.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e express = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'express'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e port = \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 홈페이지 라우트\u003c/span\u003e\napp.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  res.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'홈페이지에 오신 것을 환영합니다!'\u003c/span\u003e);\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 사용자 라우트\u003c/span\u003e\napp.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'/user/:id'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e userId = req.\u003cspan class=\"hljs-property\"\u003eparams\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e;\n  res.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`사용자 프로필 페이지 - ID: \u003cspan class=\"hljs-subst\"\u003e${userId}\u003c/span\u003e`\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e미들웨어 지원\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eExpress.js는 HTTP 요청을 처리하기 위한 미들웨어 지원을 제공합니다. HTTP 요청 세부 정보를 기록하는 미들웨어를 만드는 간단한 예제를 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e express = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'express'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e port = \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e;\n\napp.\u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ereq, res, next\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`[\u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eDate\u003c/span\u003e().toLocaleString()}\u003c/span\u003e] \u003cspan class=\"hljs-subst\"\u003e${req.method}\u003c/span\u003e \u003cspan class=\"hljs-subst\"\u003e${req.url}\u003c/span\u003e`\u003c/span\u003e );\n  \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e쉬운 데이터베이스 통합\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eExpress.js는 데이터베이스에 구애받지 않습니다. 특정 데이터베이스 선택을 강요하지 않습니다. 개발자들은 원하는 데이터베이스를 선택할 수 있습니다. Express.js와 데이터베이스를 통합시키는 것은 모듈식이고 유연한 성질과 데이터베이스 연결을 제공하는 npm 패키지의 풍부한 생태계 덕분에 쉽습니다.\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e배우기 쉽습니다\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eExpress.js는 간결하고 최소주의 디자인으로 유명하며, 특히 JavaScript와 Node.js에 익숙한 개발자들에게 배우기 쉬운 것으로 알려져 있어요.\u003c/p\u003e\n\u003cp\u003e게다가 Bit와 같은 도구를 사용하여 Express.js를 쉽게 시작할 수 있어요. Bit는 추가 구성 가능한 소프트웨어를 위한 차세대 빌드 시스템입니다.\u003c/p\u003e\n\u003cp\u003e예를 들어 미들웨어 구성 요소를 만들어 필요할 때마다 끼워 넣거나 빼낼 수 있어요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e제목: Bit 및 독립 컴포넌트를 사용하여 설계된 Express API의 범위\u003c/p\u003e\n\u003cp\u003e두 개의 컴포넌트를 볼 수 있어요: Authorizer와 API 앱입니다. 이 두 컴포넌트는 독립적인 Bit 컴포넌트로 구현되어 있으며 별도의 공간에서 유지 및 버전 관리됩니다.\u003c/p\u003e\n\u003cp\u003e이렇게 함으로써 앱을 조합 가능한 방식으로 빠르게 설계할 수 있어요!\u003c/p\u003e\n\u003cp\u003e이 완벽한 구현을 보려면 Bit Scope를 확인해주세요.\u003c/p\u003e\n\u003ch1\u003eNestJS: 현대적이고 체계적인 방법\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_4.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eNestJS는 확장 가능하고 효율적인 Node.js 서버 측 애플리케이션을 구축하는 데 알려진 프레임워크입니다. Progressive JavaScript를 사용하며 TypeScript로 코드를 작성할 수 있는 기능을 갖추고 있습니다. TypeScript를 완전히 지원하지만, 순수 JavaScript로 코드를 작성할 수 있으며 객체지향 프로그래밍, 함수형 프로그래밍 및 함수형 반응형 프로그래밍을 포함하고 있습니다.\u003c/p\u003e\n\u003ch1\u003e주요 기능: 높게 평가되는 이유\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e모듈성\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eNest.js는 코드를 별도의 관리 가능한 모듈로 분할할 수 있어 유지 보수가 더 쉬워집니다. 예를 들어 아래 모듈을 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eModule\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eModule\u003c/span\u003e({\n \u003cspan class=\"hljs-attr\"\u003eimports\u003c/span\u003e: [\n  \u003cspan class=\"hljs-title class_\"\u003eCacheModule\u003c/span\u003e\n ],\n \u003cspan class=\"hljs-attr\"\u003econtrollers\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003ePaymentController\u003c/span\u003e],\n \u003cspan class=\"hljs-attr\"\u003eproviders\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003ePaymentService\u003c/span\u003e],\n})\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePaymentModule\u003c/span\u003e {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 결제 모듈은 다른 모듈로 내보낼 수 있습니다. 이 예시에서는 이 모듈 내에서 공통 캐시 모듈을 내보냈습니다. Nest.js는 모듈 구조를 가지고 있기 때문에 관리가 용이합니다.\u003c/p\u003e\n\u003ch3\u003e2. 확장 가능성\u003c/h3\u003e\n\u003cp\u003eNest.js는 어플리케이션을 관리 가능한 모듈로 분할하여 확장을 용이하게 합니다. 유연한 컴포넌트 교체를 지원하며, 마이크로서비스 및 비동기 작업을 통해 고트래픽을 처리할 수 있습니다. 늘어난 작업 부하를 효율적으로 처리하면서도 안정성을 유지합니다.\u003c/p\u003e\n\u003ch3\u003e3. 의존성 주입\u003c/h3\u003e\n\u003cp\u003e의존성 주입은 외부 종속성을 클래스 내부에서 생성하는 대신 클래스에 추가하는 간단한 방법입니다. 예제를 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e {\n \u003cspan class=\"hljs-title class_\"\u003eHttpException\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eNotFoundException\u003c/span\u003e\n} \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\n@\u003cspan class=\"hljs-title class_\"\u003eInjectable\u003c/span\u003e()\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePaymentService\u003c/span\u003e {\n\n \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {}\n\n \u003cspan class=\"hljs-title function_\"\u003egetReceipt\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'Payment Receipt'\u003c/span\u003e;\n }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e저희는 결제 서비스를 만들었고 @Injectable() 어노테이션을 추가하여 주입 가능하게 만들었습니다. 아래와 같이 만들어진 서비스를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003ePost\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eBody\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'@nestjs/common'\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { \u003cspan class=\"hljs-title class_\"\u003ePaymentService\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'./payment.service'\u003c/span\u003e;\n@\u003cspan class=\"hljs-title class_\"\u003eController\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'payment'\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePaymentController\u003c/span\u003e {\n \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eprivate readonly paymentService: PaymentService\u003c/span\u003e) {}\n@\u003cspan class=\"hljs-title class_\"\u003eGet\u003c/span\u003e()\n \u003cspan class=\"hljs-title function_\"\u003egetPaymentReceipt\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003epaymentService\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetReceipt\u003c/span\u003e();\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e타입 안전성\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ccode\u003eNest.js\u003c/code\u003e에서는 TypeScript를 사용하여 유형 안전성을 제공하며, 개발 중 잠재적인 오류를 찾아내고 코드 유지보수성을 개선하는 데 사용할 수 있습니다. 예를 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePaymentDto\u003c/span\u003e {\n\n  @\u003cspan class=\"hljs-title class_\"\u003eIsNotEmpty\u003c/span\u003e()\n  @\u003cspan class=\"hljs-title class_\"\u003eIsEnum\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eSERVICE_PROVIDER_SLUG\u003c/span\u003e, {\n    \u003cspan class=\"hljs-attr\"\u003emessage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`Invalid serviceProvider. Valid options are: \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.values(SERVICE_PROVIDER_SLUG).join(\u003cspan class=\"hljs-string\"\u003e', '\u003c/span\u003e)}\u003c/span\u003e`\u003c/span\u003e,\n  })\n  \u003cspan class=\"hljs-attr\"\u003eserviceProvider\u003c/span\u003e: string;\n\n  @\u003cspan class=\"hljs-title class_\"\u003eIsNotEmpty\u003c/span\u003e()\n  @\u003cspan class=\"hljs-title class_\"\u003eIsNumber\u003c/span\u003e()\n  \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: number;\n\n  @\u003cspan class=\"hljs-title class_\"\u003eIsNotEmpty\u003c/span\u003e()\n  @\u003cspan class=\"hljs-title class_\"\u003eIsString\u003c/span\u003e()\n  \u003cspan class=\"hljs-attr\"\u003evalidityPeriod\u003c/span\u003e: string;\n\n  @\u003cspan class=\"hljs-title class_\"\u003eIsNotEmpty\u003c/span\u003e()\n  @\u003cspan class=\"hljs-title class_\"\u003eIsArray\u003c/span\u003e()\n  @\u003cspan class=\"hljs-title class_\"\u003eArrayNotEmpty\u003c/span\u003e()\n  @\u003cspan class=\"hljs-title class_\"\u003eValidateNested\u003c/span\u003e()\n  @\u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u003e\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePaymentAttributesDto\u003c/span\u003e)\n  \u003cspan class=\"hljs-attr\"\u003epaymentAttributes\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePaymentAttributesDto\u003c/span\u003e[]\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서, 우리는 여러 매개변수를 포함하는 DTO를 생성하고 매개변수 유형을 유효성 검사하는 어노테이션을 추가했습니다. 예를 들어, \"value\" 매개변수에 문자열 값을 보내면 오류가 발생합니다.\u003c/p\u003e\n\u003ch1\u003eKoa.js: 우아하고 가벼운\u003c/h1\u003e\n\u003cp\u003eKoa.js는 Express.js 팀이 설계한 더 작고 표현력 있는 웹 프레임워크입니다. 이를 사용하면 콜백을 버릴 수 있고 async 함수를 활용하여 오류를 처리할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e주요 기능: 눈에 띄는 특징\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e컨텍스트 객체(ctx)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eKoa.js에는 요청과 응답 세부 사항을 캡처하는 ctx라는 기능이 포함되어 있습니다. 이 컨텍스트는 각 미들웨어에 전달됩니다. 이 예시에서는 ctx 객체에서 메서드와 요청을 기록했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eKoa\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'koa'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eKoa\u003c/span\u003e();\n\napp.\u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (ctx) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { method, url, request, response } = ctx;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Method :'\u003c/span\u003e + method + \u003cspan class=\"hljs-string\"\u003e' Request : '\u003c/span\u003e + request);\n});\n\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e미들웨어 조합\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eExpress Js와 유사하게, Koa는 HTTP 요청과 응답을 처리하기 위한 미들웨어 함수를 지원합니다. 이 예시에서는 간단한 미들웨어를 만들었습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eKoa\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'koa'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eKoa\u003c/span\u003e();\n\napp.\u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (ctx, next) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(); \n});\n\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eAsync/Await Support\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eKoa는 비동기 코드를 더 동기적으로 보이게 작성하기 위해 async/await 구문을 사용합니다. 아래 예제는 async/await 키워드를 사용하는 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eKoa\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'koa'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eKoa\u003c/span\u003e();\n\napp.\u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (ctx) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e data = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchData\u003c/span\u003e();\n  ctx.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e`Data: \u003cspan class=\"hljs-subst\"\u003e${data}\u003c/span\u003e`\u003c/span\u003e;\n});\n\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e오류 처리\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eKoa.Js는 다양한 종류의 오류 처리를 지원합니다. 오류를 처리하기 위해 app.emit() 또는 ctx.throw()를 사용할 수 있습니다. 아래 예시는 언급된 오류 처리 방법을 포함하고 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e koa = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'koa'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ekoa\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 오류 처리 방법 1\u003c/span\u003e\napp.\u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (ctx, next) =\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereject\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'문제가 발생했습니다'\u003c/span\u003e);\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\n    ctx.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e = err.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e || \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e;\n    ctx.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e = err.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e;\n    ctx.\u003cspan class=\"hljs-property\"\u003eapp\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eemit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'error'\u003c/span\u003e, err, ctx);\n  }\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 오류 처리 방법 2\u003c/span\u003e\napp.\u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (ctx, next) =\u003e {\n  ctx.\u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'에러'\u003c/span\u003e);\n});\n\napp.\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'error'\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerr, ctx\u003c/span\u003e) =\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(err);\n});\n\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eHapi.js\u003c/h1\u003e\n\u003cp\u003eHapi.js는 Http-API를 축약한 것으로, 확장 가능한 웹 애플리케이션을 개발하기 위한 오픈 소스 프레임워크입니다. hapi의 가장 기본적인 사용 사례 중 하나는 REST API를 구축하는 것입니다.\u003c/p\u003e\n\u003ch1\u003e주요 기능: 뛰어나게 만드는 요소\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e구성 중심 설계\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHapi.js의 구성 객체를 사용하면 라우트, 설정 및 플러그인을 설정할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHapi\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'@hapi/hapi'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e server = \u003cspan class=\"hljs-title class_\"\u003eHapi\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eserver\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eport\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eroutes\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003ecors\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  },\n});\n\nserver.\u003cspan class=\"hljs-title function_\"\u003eroute\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'GET'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ehandler\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003erequest, h\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'Hello, Hapi!'\u003c/span\u003e;\n  },\n});\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e server.\u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e();\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'서버가 ${server.info.uri}에서 실행 중'\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003estart\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e강력한 플러그인 시스템\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHapi.js는 플러그인을 간편하게 통합할 수 있는 기능을 제공합니다. 다음 예제를 살펴봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e start = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e server = \u003cspan class=\"hljs-title class_\"\u003eHapi\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eserver\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e server.\u003cspan class=\"hljs-title function_\"\u003eregister\u003c/span\u003e([{\n        \u003cspan class=\"hljs-attr\"\u003eplugin\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'plugin1'\u003c/span\u003e),\n        \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: {}\n    }, {\n        \u003cspan class=\"hljs-attr\"\u003eplugin\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'plugin2'\u003c/span\u003e),\n        \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: {}\n    }]);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제에서는 두 개의 플러그인이 통합되었습니다. 옵션은 options 키를 사용하여 플러그인에 전달할 수 있습니다.\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e인증 및 권한\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHapi.js는 다양한 인증 전략에 대한 내장 지원을 제공하며, 개발자들이 쉽게 액세스 제어 정책을 정의할 수 있도록 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eserver.\u003cspan class=\"hljs-title function_\"\u003eroute\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'GET'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'/private-data'\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003ehandler\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003erequest, h\u003c/span\u003e) =\u003e\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 인증된 경우에만 개인 데이터에 액세스합니다\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e user = request.\u003cspan class=\"hljs-property\"\u003eauth\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecredentials\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`환영합니다, \u003cspan class=\"hljs-subst\"\u003e${user.username}\u003c/span\u003e!`\u003c/span\u003e;\n  },\n  \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003eauth\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'jwt'\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// JWT 인증 전략 사용\u003c/span\u003e\n  },\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예제를 기반으로하여, 우리는 인증 전략을 'jwt'로 직접 정의할 수 있습니다.\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e입력 유효성 검사\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e입력 유효성 검사는 hapi.js의 또 다른 중요한 측면입니다. route의 options 객체에서 어떤 입력을 검증해야 하는지 정의할 수 있습니다. 기본 validate 객체는 아래 값으로 구성됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{ \n   \u003cspan class=\"hljs-attr\"\u003eheaders\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \n   \u003cspan class=\"hljs-attr\"\u003eparams\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \n   \u003cspan class=\"hljs-attr\"\u003equery\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \n   \u003cspan class=\"hljs-attr\"\u003epayload\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \n   \u003cspan class=\"hljs-attr\"\u003estate\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e, \n   \u003cspan class=\"hljs-attr\"\u003efailAction\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'error'\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eAdonis.js\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-Top5NodejsBackendFrameworksin2024_7.png\" alt=\"Adonis.js Logo\"\u003e\u003c/p\u003e\n\u003cp\u003eAdonis.js는 Node.js를 위한 전체 기능을 갖춘 MVC 프레임워크입니다. 확장 가능하고 유지 보수 가능한 애플리케이션을 구축할 수 있습니다. Adonis.js는 Laravel과 유사한 구조를 따르며 ORM, 인증 및 라우팅과 같은 기능을 기본 제공합니다.\u003c/p\u003e\n\u003ch1\u003e핵심 기능: 두드러지는 이유\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e풀 스택 MVC 프레임워크\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAdonis.js는 MVC 아키텍처 패턴을 따릅니다. MVC 프레임워크를 사용하면 코드를 조직화하고 유지 관리하고 확장하기 쉬워집니다.\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e데이터베이스 상호 작용을 위한 통합된 ORM(Lucid)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAdonis.js는 Lucid라는 자체 ORM을 가지고 있어요. Lucid는 표현적인 쿼리 빌더를 제공하며 다양한 데이터베이스 시스템을 지원해요. Lucid에서는 데이터베이스에 읽고 쓰기 위해 모델을 생성할 수 있어요. 아래 예시를 살펴보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eModel\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Model'\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eModel\u003c/span\u003e {\n}\n\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 이 사용자 모델을 데이터베이스 쿼리 대신 사용하고 있어요. 이제 라우트를 생성하는데, 해당 내부에서 사용자를 가져오고 있어요. 사용자를 가져오기 위해, 간단히 \u003ccode\u003eUser.all()\u003c/code\u003e을 사용할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRoute\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Route'\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'App/Models/User'\u003c/span\u003e)\n\n\u003cspan class=\"hljs-title class_\"\u003eRoute\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'users'\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u003e {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e()\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e인증 시스템\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAdonis.js에는 사용자 인증 및 권한 부여를 위한 기본 지원이 있습니다. 사용자 세션, 비밀번호 해싱, 및 접근 제어를 다루는 일련의 메서드와 미들웨어를 제공합니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e2024년에는 위에서 언급한 백엔드 프레임워크들이 시장에서 높은 위치를 차지하고 있습니다.\u003c/p\u003e\n\u003cp\u003eExpress.js는 간결함 때문에, Nest.js는 구조 때문에, Adonis.js는 생산성 때문에, Koa.js는 우아함 때문에 선택했을지라도, 올바른 프레임워크를 선택하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e또한, 2024년에 성공적인 백엔드 개발 여정을 하려면 최신 트렌드, 기존 프레임워크의 새로운 기능, 그리고 새로운 프레임워크를 찾는 것이 중요합니다.\u003c/p\u003e\n\u003ch1\u003e더 알아보기\u003c/h1\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-Top5NodejsBackendFrameworksin2024"},"buildId":"t9N7vwmpvBMQnO2PSctoH","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>